         TITLE '   P D S M A T C H   '
***********************************************************************
*          THIS PROGRAM COMPARES THE DIRECTORIES OF TWO PARTITIONED
*          DATA SETS AND PRINTS A REPORT SHOWING WHICH MEMBERS
*          MATCH AND WHICH MEMBERS DO NOT MATCH OR ARE NOT PRESENT
*          IN BOTH DIRECTORIES.
*
*          MEMBERS ARE SAID TO MATCH IF THEIR NAMES ARE THE SAME.
*          IF PARM=USER, IF ALL THE STATISTICS IN THEIR DIRECTORY
*          ENTRIES ARE EQUAL (EXCEPT FIELDS CONTAINING TTR TRACK
*          ADDRESSES). IF PARM=DATA, IF THEIR DATA ARE THE SAME.
*
*          DDNAMES.
*             SYSPRINT - REPORT OUTPUT
*             SYSLIB1  - PDS 1 INPUT
*             SYSLIB2  - PDS 2 INPUT
*
*          IF PARM=EQO
*             ONLY MEMBERS THAT MATCH WILL BE LISTED.
*          IF PARM=NEO
*             ONLY MEMBERS THAT DONT MATCH WILL BE LISTED.
*          IF DEFAULTED
*             ALL MEMBERS WILL BE LISTED FOR BOTH LIBRARIES.
*          IF PARM=USER
*             MEMBERS THAT ARE PRESENT IN BOTH LIBRARIES
*             WILL BE COMPARED FOR MATCHING USERDATA.
*             USERDATA CONSISTS OF UP TO 64 BYTES OF DATA
*             IN THE DIRECTORY ENTRY WHICH IS PUT THERE BY
*             THE LINKAGE EDITOR, SPF EDIT, AND OTHERS.
*             NOTE. WITH PARM=USER,
*             IF TWO MEMBERS HAVE THE SAME NAME AND NEITHER
*             HAS ANY USERDATA, THEY ARE TREATED AS UNEQUAL,
*             WITH A UNIQUE MESSAGE FOR THIS CASE.
*          IF PARM=DATA
*             MEMBERS THAT ARE PRESENT IN BOTH LIBRARIES
*             WILL BE COMPARED FOR MATCHING DATA.
*             IF TWO MEMBERS HAVE THE SAME NAME AND BOTH ARE
*             EMPTY, THEY ARE TREATED AS UNEQUAL,
*             WITH A UNIQUE MESSAGE FOR THIS CASE.
*          IF PARM=SUMS
*             COUNTS ARE PRINTED AT THE END FOR:
*             NUMBER OF MEMBERS IN LIBRARY 1 ONLY
*             NUMBER OF MEMBERS IN LIBRARY 2 ONLY
*             NUMBER OF MEMBERS IN BOTH BUT DIFFERENT
*             NUMBER OF MEMBERS IN BOTH AND EQUAL
*
*          LOG OF CHANGES.
*           2015 DEC 13 - CHANGES TO GET IT TO ASSEMBLE ON MVS 3.8.
*             CHANGED 'STORAGE' TO 'GETMAIN' AND 'FREEMAIN'
*             IN RENTER AND REXIT SO IT ASSEMBLES ON MVS 3.8.
*             ADDED 'LCLA' AND 'LCLB' TO RENTER AND REXIT FOR IFOX00.
*           2015 DEC 13 - FIXES AND MINOR IMPROVEMENTS.
*             REMOVED RENTER AND REXIT MACRO DEFS PRECEDING PDSMATCH,
*             AS THEY ARE NOT USED BY PDSMATCH.
*             AT CHECKF ADD CODE TO CORRECTLY HANDLE UNBLOCKED RECORDS.
*             ADD A 'CLOSE' FUNCTION TO PDSCOMP.
*             CALL PDSCOMP ONE LAST TIME WITH CLOSE REQUESTED.
*             CHANGE 'END PDSCOMP' TO JUST 'END'
*             FIX A PROBLEM AT PDS1EOF THAT CAUSED FALSE 'EQUAL'
*             WHEN SYSLIB1 HIT EOF AND SYSLIB2 STILL HAD MORE IN
*             ITS LAST BLOCK.
*           2016 FEB 4 - WHEN COMPARING PDS'ES WITH A VERY LARGE NUMBER
*             OF MEMBERS, PDSMATCH REQUIRED A BIGGER GETMAIN AT LABEL
*             DIRSIZE.  FOR NOW, INCREASED TO 1000K.  ADEQUATE SO FAR.
*           2016 AUG 2 - FIX BUG SHOWING 2 EMPTY MEMBERS NOT EQUAL.
*             ADDED PARM OPTION 'SUMS' TO SHOW COUNTS AT END.
*           2016 AUG 5 - IF THE VALUE OF DIRSIZE IS TOO SMALL TO
*             CONTAIN THE COMBINED DIRECTORIES, ADDITIONAL MEMORY
*             IS OBTAINED IN DIRSIZE CHUNKS AS NEEDED. DIRSIZE IS
*             REDUCED FROM 2000*512 (~1 MB) TO 8+260*100 (~26 KB).
*             DIRSIZE SHOULD ALWAYS BE 8 + A MULTIPLE OF 260.
*             EACH 256-BYTE DIRECTORY BLOCK IN MEMORY WILL BE
*             FOLLOWED BY A POINTER TO THE NEXT BLOCK, SO 260.
*             THE OTHER 8 ARE TO KEEP TRACK OF CHUNKS FOR FREEMAIN.
*           2016 NOV 22 - FIX RECFM V BUG, CHANGES MARKED "FIX4".
*             IN THE PDSCOMP SUBPROGRAM, IF PDS1 AND PDS2 HAVE
*             DIFFERENT BLOCK SIZES, FOR MEMBERS THAT HAVE MORE THAN
*             ONE BLOCK, THE SECOND AND SUBSEQUENT BLOCKS WERE
*             COMPARED AS A BLOCK USING BDW INSTEAD OF RECORD BY RECORD
*             RESULTING IN IDENTICAL MEMBERS BEING MARKED AS UNEQUAL.
*
***********************************************************************

         MACRO
         REGS  &PP=R
         LCLA  &II
&II      SETA  0
.LOOP    ANOP
&PP&II   EQU   &II
&II      SETA  &II+1
         AIF   (&II LT 16).LOOP
         MEND
PDSMATCH START
         REGS
         USING *,R10,R11
         B     @PROLOG-*(,15)
         DC    AL1(11),CL11'PDSMATCH'
         DC    CL16' &SYSDATE &SYSTIME '
@SIZE    DC    0F'0',AL1(1),AL3(@DATAL)
@PROLOG  STM   14,12,12(R13)
         LR    R10,15
         LA    R15,1
         LA    R11,4095(R15,R10)
         LR    R4,R1               SAVE PARM POINTER
         L     R0,@SIZE
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         USING @DATA,R13
         SR    R15,R15
         STH   R15,RC
         STC   R15,STATUS
         STC   R15,OPTIONS
         MVC   DDNAMEP,=CL8'SYSPRINT'
         MVC   DDNAME1,=CL8'SYSLIB1'
         MVC   DDNAME2,=CL8'SYSLIB2'
         MVI   LINE-1,C' '
         MVC   LINE,LINE-1
         MVI   MESG-1,C' '
         ZAP   REPORTPG,=P'0'
         ZAP   REPORTLN,=P'0'
         ZAP   REPORTMX,=P'60'
         MVI   REPORTO-1,C' '
         MVI   JFCB1,C' '
         MVC   JFCB1+1(175),JFCB1
         MVC   JFCB2(176),JFCB1
         XC    COUNTEQ(16),COUNTEQ  ZERO 4 COUNTERS

************************************************************
*         OPEN THE PRINT FILE                              *
************************************************************

         MVC   PRTDCBW(PRTDCBL),PRTDCB
         LA    R2,PRTDCBW
         MVC   DDNAM(8,R2),DDNAMEP
         MVI   OPEN,X'80'
         OPEN  ((R2),OUTPUT),MF=(E,OPEN)
         TM    OFLGS(R2),X'10'
         BNO   EXIT12
         OI    STATUS,PRTOPEN
         B     PRTX
PRTEXITO CLC   62(2,R1),=H'0'      IS BLKSIZE ZERO
         BNE   0(R14)              NO
         MVC   62(2,R1),82(R1)     YES - MAKE IT SAME AS LRECL
         BR    R14
PRTX     EQU   *

************************************************************
*         SCAN THE PARM FIELD                              *
************************************************************

*
*               REGISTERS USED
*                R14 - RETURN FROM PARSE
*                R15 - ADDRESS OF REMAINING PARM DATA
*                R0  - WORK
*                R1  - USED BY TRT INSTRUCTION
*                R2  - USED BY TRT INSTRUCTION
*                R3  - LENGTH OF REMAINING PARM DATA MINUS 1
*
*               PARSE MUST NOT ALTER R0, R1, OR R3
*
         L     R15,0(,R4)          POINT TO PARM
         LH    R3,0(,R15)          GET LENGTH OF PARM
         LTR   R3,R3               IS THERE A PARM
         BZ    PARMX               NO, BRANCH
         LA    R15,2(,R15)         POINT TO PARM DATA

         SR    R1,R1               INSURE HI ORDER BYTE ZERO
         BCTR  R3,0                LENGTH CODE OF PARM DATA
         B     *+16                SKIP EXECUTED INSTRUCTIONS
TRTNONBL TRT   0(0,R15),TABNONBL   (EXECUTED)
TRTBLANK TRT   0(0,R15),TABBLANK   (EXECUTED)
*              NOTE: TRT CAN CHANGE 8 BITS OF R2 AND 24 BITS OF R1
PARMLOOP EX    R3,TRTNONBL         FIND A NONBLANK
         BZ    PARMX               BRANCH IF ALL BLANKS
         LR    R0,R1               GET ADDRESS OF STRING
         SR    R0,R15              GET LENGTH OF PRECEDING BLANKS
         SR    R3,R0               GET LENGTH OF REMAINING TEXT
         LR    R15,R1              GET ADDRESS OF NONBLANK
         EX    R3,TRTBLANK         FIND A BLANK
         BZ    PARMLAST            BRANCH IF NOT FOUND
         LR    R0,R1               GET ADDRESS OF BLANK
         SR    R0,R15              GET LENGTH OF FIELD
         BAL   R14,PARSE
         SR    R3,R0               GET LENGTH CODE OF REMAINING TEXT
         BZ    PARMX               BRANCH IF ONE TRAILING BLANK
         LR    R15,R1              POINT TO BLANK
         B     PARMLOOP
PARMLAST LA    R0,1(,R3)           GET LENGTH
         BAL   R14,PARSE
         B     PARMX

************************************************************
*         PROCESS EACH PARM KEYWORD                        *
************************************************************

PARSE    STM   R14,R1,PARSES       SAVE REGS
         CH    R0,=H'4'            IS KEYWORD LENGTH 4
         BNE   PARSL4X             NO, BRANCH
         CLC   0(4,R15),=C'USER'
         BNE   *+12
         OI    OPTIONS,OPTUSER
         B     PARSX
         CLC   0(4,R15),=C'DATA'
         BNE   *+12
         OI    OPTIONS,OPTDATA
         B     PARSX
         CLC   0(4,R15),=C'SUMS'
         BNE   PARSL4X
         OI    OPTIONS,OPTSUMS
         B     PARSX
PARSL4X  EQU   *
         CH    R0,=H'3'            IS KEYWORD LENGTH 3
         BNE   PARSL3X             NO, BRANCH
         CLC   0(3,R15),=C'EQO'    EQONLY
         BNE   *+8
         OI    OPTIONS,OPTEQO
         CLC   0(3,R15),=C'NEO'    NEONLY
         BNE   *+8
         OI    OPTIONS,OPTNEO
         B     PARSX
PARSL3X  EQU   *
PARSX    LM    R14,R1,PARSES
         BR    R14

PARMX    EQU   *

************************************************************
*         SHOW CRITERIA                                    *
************************************************************

         TM    OPTIONS,OPTUSER
         BO    PRTCRI2
         TM    OPTIONS,OPTDATA
         BO    PRTCRI3
         LA    R1,MSGCRI1A
         LA    R0,L'MSGCRI1A
         BAL   R14,PRTMSG
         LA    R1,MSGCRI1B
         LA    R0,L'MSGCRI1B
         BAL   R14,PRTMSG
         B     PRTCRIX
PRTCRI2  LA    R1,MSGCRI2A
         LA    R0,L'MSGCRI2A
         BAL   R14,PRTMSG
         LA    R1,MSGCRI2B
         LA    R0,L'MSGCRI2B
         BAL   R14,PRTMSG
         B     PRTCRIX
PRTCRI3  LA    R1,MSGCRI3A
         LA    R0,L'MSGCRI3A
         BAL   R14,PRTMSG
         LA    R1,MSGCRI3B
         LA    R0,L'MSGCRI3B
         BAL   R14,PRTMSG
PRTCRIX  LA    R1,=C' '
         LA    R0,1
         BAL   R14,PRTMSG

************************************************************
*         OPEN THE FIRST PDS                               *
************************************************************

         MVC   DIRDCBW(DIRDCBL),DIRDCB
         LA    R2,DIRDCBW          ADDRESS OF DCB
         MVC   DDNAM(8,R2),DDNAME1 CHANGE THE DDNAME
         LA    R3,DDNAM(,R2)       POINT TO DDNAME FOR DEVTYPE
         DEVTYPE (R3),DEVAREA
         LTR   R15,R15             IS DDNAME ALLOCATED
         BNZ   EXIT12              NO, BRANCH

         LA    R1,DIREXLST         PUT EXLST
         IC    R0,EXLST(,R2)        ADDRESS
         ST    R1,EXLST(,R2)         IN
         STC   R0,EXLST(,R2)          DCB
         LA    R0,JFCB1            PUT JFCB ADDRESS
         ST    R0,0(,R1)            IN EXLST
         MVI   0(R1),X'87'           AND INDICATE EXLST ENTRY TYPE
         MVI   RDJFCB,X'80'
         RDJFCB ((R2)),MF=(E,RDJFCB)

         MVI   OPEN,X'80'
         OPEN  ((R2),INPUT),MF=(E,OPEN)
         TM    OFLGS(R2),X'10'
         BNO   EXIT12
         OI    STATUS,DIROPEN

         MVC   LINE,LINE-1         BLANK LINE
         MVC   LINE+1(10),=C'LIBRARY1 -'
         LA    R15,LINE+12
         MVC   0(44,R15),JFCB1
         LA    R15,44(,R15)
APPENDV1 CLI   0(R15),C' '
         BNE   *+8
         BCT   R15,APPENDV1
         MVC   2(2,R15),=C'ON'
         MVC   5(6,R15),JFCB1+118  VOLUME SERIAL
         BAL   R14,REPORTL         PUT HEADING LIBRARY1 DSN

         L     R0,DIRSIZE          8 + (260 * 100)
         GETMAIN R,LV=(0)
         XC    0(8,R1),0(R1)       MARK THIS AS FIRST GETMAIN
         L     R0,DIRSIZE
         STM   R0,R1,LASTGM        SAVE MOST RECENT GETMAIN
         LA    R3,8(,R1)           1ST DIR BLOCK AT OFFSET 8
         ST    R3,DIRPTR1          SAVE FOR WALKING THRU DIR 1
         LR    R15,R0              GET LENGTH
         LA    R15,0(,R15)         CLEAR SUBPOOL
         SR    R14,R14
         SH    R15,=H'8'           LENGTH MINUS 8
         D     R14,=F'260'         # DIR BLOCKS PER GETMAIN
         LR    R1,R3               POINT TO 1ST 260-BYTE AREA
GMDIR1   LA    R0,260(,R1)         POINT TO NEXT 260-BYTE AREA
         ST    R0,256(,R1)         STORE THAT ADDRESS AFTER CURR
         LR    R1,R0               POINT TO NEXT 260-BYTE AREA
         BCT   R15,GMDIR1
         S     R1,=F'4'            BACK UP TO LAST WORD OF PREV
         SR    R0,R0
         ST    R0,0(,R1)           ZERO IT TO FORCE A GETMAIN
         ST    R1,LASTNEXT         REMEMBER IT FOR NEXT GETMAIN
         OI    STATUS,GOTMAIN
         MVC   DIRDECBW(DIRDECBL),DIRDECB
         MVI   DIRSW,0
         BAL   R8,DIRIN
         CLOSE ((R2)),MF=(E,OPEN)
         NI    STATUS,255-DIROPEN
         TM    DIRSW,1             WAS DIRECTORY VALID
         BZ    EXIT12              NO, QUIT
*        LA    R3,256(,R3)         SET START OF SECOND DIRECTORY
         BAL   R14,NEXTDIR         SET START OF SECOND DIRECTORY
         ST    R3,DIRPTR2          SAVE FOR WALKING THRU DIR 2

************************************************************
*         OPEN THE SECOND PDS                              *
************************************************************

         MVC   DIRDCBW(DIRDCBL),DIRDCB
         LA    R2,DIRDCBW          ADDRESS OF DCB
         MVC   DDNAM(8,R2),DDNAME2 CHANGE THE DDNAME
         LA    R3,DDNAM(,R2)       POINT TO DDNAME FOR DEVTYPE
         DEVTYPE (R3),DEVAREA
         LTR   R15,R15             IS DDNAME ALLOCATED
         BNZ   EXIT12              NO, BRANCH

         LA    R1,DIREXLST         PUT EXLST
         IC    R0,EXLST(,R2)        ADDRESS
         ST    R1,EXLST(,R2)         IN
         STC   R0,EXLST(,R2)          DCB
         LA    R0,JFCB2            PUT JFCB ADDRESS
         ST    R0,0(,R1)            IN EXLST
         MVI   0(R1),X'87'           AND INDICATE EXLST ENTRY TYPE
         MVI   RDJFCB,X'80'
         RDJFCB ((R2)),MF=(E,RDJFCB)

         MVI   OPEN,X'80'
         OPEN  ((R2),INPUT),MF=(E,OPEN)
         TM    OFLGS(R2),X'10'
         BNO   EXIT12
         OI    STATUS,DIROPEN

         MVC   LINE,LINE-1         BLANK LINE
         MVC   LINE+1(10),=C'LIBRARY2 -'
         LA    R15,LINE+12
         MVC   0(44,R15),JFCB2
         LA    R15,44(,R15)
APPENDV2 CLI   0(R15),C' '
         BNE   *+8
         BCT   R15,APPENDV2
         MVC   2(2,R15),=C'ON'
         MVC   5(6,R15),JFCB2+118  VOLUME SERIAL
         BAL   R14,REPORTL         PUT HEADING LIBRARY2 DSN
         MVC   LINE,LINE-1         BLANK LINE
         BAL   R14,REPORTL         PUT HEADING BLANK LINE

         L     R3,DIRPTR2
         MVC   DIRDECBW(DIRDECBL),DIRDECB
         MVI   DIRSW,0
         BAL   R8,DIRIN
         CLOSE ((R2)),MF=(E,OPEN)
         NI    STATUS,255-DIROPEN
         TM    DIRSW,1             WAS DIRECTORY VALID
         BZ    EXIT12              NO, QUIT
         B     COMPARE

************************************************************
*         READ THE DIRECTORY INTO STORAGE                  *
************************************************************

DIRIN    XC    DIRBLKS,DIRBLKS
         XC    DIRBLKSU,DIRBLKSU
         XC    MEMBERS,MEMBERS
         XC    ALIASES,ALIASES

         B     *+8
*IRREAD  LA    R3,256(,R3)
DIRREAD  BAL   R14,NEXTDIR
         READ  DIRDECBW,SF,(R2),(R3),256,MF=E
         CHECK DIRDECBW
         TM    DIRSW,2             I/O ERROR
         BO    DIRERR              YES, BRANCH
         LA    R1,1
         A     R1,DIRBLKS
         ST    R1,DIRBLKS
*        TM    DIRSW,1             ARE WE PAST USED BLOCKS
*        BO    DIRREAD             YES, BRANCH
         LR    R1,R3               POINT TO DATA JUST READ
         LH    R0,0(,R1)           GET NUMBER OF BYTES IN USE
         LTR   R0,R0               IS THIS NEGATIVE
         BM    DIRINV              YES, NOT A DIRECTORY BLOCK
         CH    R0,=H'256'          IS THIS TOO LARGE
         BH    DIRINV              YES, NOT A DIRECTORY BLOCK
         AR    R0,R1               POINT PAST LAST BYTE
         LA    R1,2(,R1)           POINT TO FIRST MEMBER
DIRENTRY CLC   0(8,R1),=8X'FF'     END OF MEMBERS
         BE    DIRUSED
         TM    11(R1),X'80'        ALIAS
         BO    DIRALIAS
         LA    R15,1               COUNT NON-ALIAS MEMBERS
         A     R15,MEMBERS
         ST    R15,MEMBERS
         B     DIRNEXT
DIRALIAS LA    R15,1               COUNT ALIAS MEMBERS
         A     R15,ALIASES
         ST    R15,ALIASES
DIRNEXT  SLR   R15,R15
         IC    R15,11(,R1)
         N     R15,=F'31'          SET OFF ALL BUT LAST 5 BITS
         SLL   R15,1               CHANGE HALFWORDS TO BYTES
         LA    R1,12(R15,R1)       POINT PAST USER DATA
         CR    R1,R0               END OF BLOCK
         BL    DIRENTRY            NO, BRANCH
         B     DIRREAD             YES, READ NEXT BLOCK
DIRUSED  EQU   *
         OI    DIRSW,1             STOP COUNTING MEMBERS
         MVC   DIRBLKSU,DIRBLKS    SAVE NUMBER OF USED BLOCKS
*        B     DIRREAD             GO COUNT UNUSED BLOCKS
         B     DIREND

NEXTDIR  L     R3,256(,R3)         POINT TO WHERE NEXT BLOCK WILL GO
         LTR   R3,R3               IF NOT ZERO
         BNZR  R14                  RETURN
         ST    R14,NEXTD14         IF ZERO, PREPARE TO GET MORE MEM
         L     R0,DIRSIZE          8 + (260 * 100)
         GETMAIN R,LV=(0)
         MVC   0(8,R1),LASTGM      SAVE PREVIOUS GETMAIN INFO
         L     R0,DIRSIZE
         STM   R0,R1,LASTGM        UPDATE MOST RECENT GETMAIN
         LA    R3,8(,R1)           1ST 260-BYTE BLOCK AT OFFSET 8
         L     R14,LASTNEXT        LAST BLOCK OF PREV GETMAIN
         ST    R3,0(,R14)          POINTS TO 1ST BLOCK OF NEW GETMAIN
         LR    R15,R0              GET LENGTH
         LA    R15,0(,R15)         CLEAR SUBPOOL
         SR    R14,R14
         SH    R15,=H'8'           LENGTH MINUS 8
         D     R14,=F'260'         COMPUTE # DIR BLOCKS THAT WILL FIT
         LR    R1,R3               POINT TO 1ST 260-BYTE AREA
GMDIR2   LA    R0,260(,R1)         POINT TO NEXT 260-BYTE AREA
         ST    R0,256(,R1)         STORE THAT ADDRESS AT END OF CURRENT
         LR    R1,R0               POINT TO NEXT 260-BYTE AREA
         BCT   R15,GMDIR2
         S     R1,=F'4'            BACK UP TO LAST WORD OF LAST 260
         SR    R0,R0
         ST    R0,0(,R1)           ZERO IT
         ST    R1,LASTNEXT         REMEMBER IT FOR NEXT GETMAIN
         L     R14,NEXTD14
         BR    R14

DIRSYN   EQU   *
         SYNADAF ACSMETH=BSAM
         MVC   MESSAGE(72),50(R1)
         OI    DIRSW,2
         SYNADRLS
         BR    R14
DIRINV   LA    R1,MSGINV
         LA    R0,L'MSGINV
         BAL   R14,PRTMSG
         OI    DIRSW,4
         B     DIREND
DIRERR   LA    R1,MESSAGE
         LA    R0,72
         BAL   R14,PRTMSG
         OI    DIRSW,4
         B     DIREND
DIREOF   LA    R1,MSGEOF
         LA    R0,L'MSGEOF
         BAL   R14,PRTMSG
         OI    DIRSW,4
DIREND   EQU   *
         BR    R8

************************************************************
*         COMPARE ROUTINE                                  *
************************************************************

COMPARE  EQU   *
         L     R1,DIRPTR1          POINT TO FIRST BLOCK OF PDS1
         ST    R1,PDSWORK1+8
         LH    R0,0(,R1)           GET NUMBER OF BYTES IN USE
         AR    R0,R1               POINT PAST LAST BYTE
         LA    R1,2(,R1)           POINT TO FIRST MEMBER
         LA    R2,PDSWORK1
         BAL   R8,GETMEM1          GET FIRST MEMBER

         L     R1,DIRPTR2          POINT TO FIRST BLOCK OF PDS2
         ST    R1,PDSWORK2+8
         LH    R0,0(,R1)           GET NUMBER OF BYTES IN USE
         AR    R0,R1               POINT PAST LAST BYTE
         LA    R1,2(,R1)           POINT TO FIRST MEMBER
         LA    R2,PDSWORK2
         BAL   R8,GETMEM1          GET FIRST MEMBER

************************************************************
*         READY TO COMPARE                                 *
************************************************************

         LA    R3,PDSWORK1
         LA    R4,PDSWORK2
READY    CLC   20(8,R3),20(R4)
         BL    SHOW1
         BH    SHOW2
         CLC   20(8,R3),=8X'FF'
         BE    DONE

************************************************************
*         MEMBER EXISTS IN BOTH LIBRARIES                  *
************************************************************

         MVC   LINE,LINE-1
         MVC   LINE+01(8),20(R3)
         MVC   COMPMEM,20(R3)
         MVC   LINE+22(8),20(R4)
         TM    OPTIONS,OPTUSER    ARE WE COMPARING USERDATA
         BZ    DATAOPTN           NO, CHECK FOR DATA OPTION
         CLC   19(73,R3),19(R4)   IS USERDATA THE SAME
         BE    SAME               YES, BRANCH
         MVC   LINE+10(11),=C' ********* '
         MVC   LINE+32(25),=C'NON-SPF USER DATA UNEQUAL'
*              SEE IF BOTH ARE SPF STATS.
*              IF BOTH ARE SPF STATS, SHOW WHICH IS MORE RECENT
         TM    12(R3),SPFFLAG      IS USERDATA SPF
         BNO   DIFF1               NO, BRANCH
         TM    12(R4),SPFFLAG      IS USERDATA SPF
         BNO   DIFF2               NO, BRANCH
         CLC   28+8(6,R3),28+8(R4) COMPARE YY.DDD HH.MM LAST UPDATED
         BH    RECENT1
         BL    RECENT2
         MVC   LINE+10(11),=C' ********* '
         MVC   LINE+32(32),=C'SPF STATS DIFFER BUT NOT IN DATE'
         B     MATCHP
DIFF1    TM    12(R4),SPFFLAG      IS USERDATA SPF
         BNO   MATCHP              NO - NEITHER MEMBER IS SPF
         MVC   LINE+32(27),=C'ONLY LIBRARY2 HAS SPF STATS'
         B     MATCHP
DIFF2    MVC   LINE+32(27),=C'ONLY LIBRARY1 HAS SPF STATS'
         B     MATCHP
RECENT1  MVC   LINE+10(11),=C' <-- NEWER '
         MVC   LINE+32(25),=C'LIBRARY1 IS MORE RECENT  '
         B     MATCHP
RECENT2  MVC   LINE+10(11),=C' NEWER --> '
         MVC   LINE+32(25),=C'LIBRARY2 IS MORE RECENT  '
         B     MATCHP
DATAOPTN TM    OPTIONS,OPTDATA    ARE WE COMPARING REAL DATA
         BZ    MATCHP             NO, GO ON WITH OTHER MEMBERS
         CALL  PDSCOMP,COMPMEM,VL
         LTR   R15,R15
         BZ    MATCHP
UNEQUAL  MVC   LINE+10(11),=C' <UNEQUAL> '
         MVC   LINE+32(25),=C'LIBRARY DATA IS NOT SAME '
         B     MATCHP             GO ON WITH OTHER MEMBERS

************************************************************
*         DIRECTORY DATA MATCHES                           *
************************************************************

SAME     CLI   15(R3),0           ZERO USERDATA IN BOTH
         BNE   SAME2              NO, BRANCH
         MVC   LINE+10(11),=C' ********* '
         MVC   LINE+32(27),=C'NEITHER MEMBER HAS USERDATA'
         B     MATCHP
SAME2    TM    12(R3),SPFFLAG     SPF STATS IN BOTH
         BO    MATCHP             YES - OMIT MESSAGE
         MVC   LINE+10(11),=C' ********* '
         MVC   LINE+32(23),=C'NON-SPF USER DATA EQUAL'
MATCHP   CLI   LINE+32,C' '        IS THIS A MATCH
         BNE   MATCHNE             NO, BRANCH
         LA    R0,1
         A     R0,COUNTEQ
         ST    R0,COUNTEQ
         TM    OPTIONS,OPTNEO     ARE WE PRINTING .NE. ONLY
         BO    MATCHX             YES, DONT PRINT THESE
         B     MATCHPR
MATCHNE  LA    R0,1
         A     R0,COUNTNE
         ST    R0,COUNTNE
         TM    OPTIONS,OPTEQO     ARE WE PRINTING .EQ. ONLY
         BO    MATCHX             YES, DONT PRINT THESE
MATCHPR  BAL   R14,REPORTL
MATCHX   LR    R2,R3
         BAL   R8,GETMEM
         LR    R2,R4
         BAL   R8,GETMEM
         B     READY

************************************************************
*         MEMBER EXISTS ONLY IN LIBRARY 1                  *
************************************************************

SHOW1    LA    R0,1
         A     R0,COUNTL1
         ST    R0,COUNTL1
         TM    OPTIONS,OPTEQO     ARE WE PRINTING .EQ. ONLY
         BO    SHOW1X             YES, DONT PRINT THESE
         MVC   LINE,LINE-1
         MVC   LINE+01(8),20(R3)
         MVC   LINE+32(23),=C'MEMBER IN LIBRARY1 ONLY'
         BAL   R14,REPORTL
SHOW1X   LR    R2,R3
         BAL   R8,GETMEM
         B     READY

************************************************************
*         MEMBER EXISTS ONLY IN LIBRARY 2                  *
************************************************************

SHOW2    LA    R0,1
         A     R0,COUNTL2
         ST    R0,COUNTL2
         TM    OPTIONS,OPTEQO     ARE WE PRINTING .EQ. ONLY
         BO    SHOW2X             YES, DONT PRINT THESE
         MVC   LINE,LINE-1
         MVC   LINE+22(8),20(R4)
         MVC   LINE+32(23),=C'MEMBER IN LIBRARY2 ONLY'
         BAL   R14,REPORTL
SHOW2X   LR    R2,R4
         BAL   R8,GETMEM
         B     READY

************************************************************
*         END OF BOTH DIRECTORIES                          *
************************************************************

DONE     TM    OPTIONS,OPTSUMS
         BZ    EXIT
         MVC   LINE,LINE-1
         L     R0,COUNTL1
         CVD   R0,DOUBLE
         MVC   LINE(6),=X'402020202020' EDIT MASK
         ED    LINE(6),DOUBLE+5
         MVC   LINE+7(24),=C'MEMBERS IN LIBRARY1 ONLY'
         BAL   R14,REPORTL
         L     R0,COUNTL2
         CVD   R0,DOUBLE
         MVC   LINE(6),=X'402020202020' EDIT MASK
         ED    LINE(6),DOUBLE+5
         MVC   LINE+7(24),=C'MEMBERS IN LIBRARY2 ONLY'
         BAL   R14,REPORTL
         L     R0,COUNTNE
         CVD   R0,DOUBLE
         MVC   LINE(6),=X'402020202020' EDIT MASK
         ED    LINE(6),DOUBLE+5
         MVC   LINE+7(29),=C'MEMBERS IN BOTH BUT DIFFERENT'
         BAL   R14,REPORTL
         MVC   LINE,LINE-1
         L     R0,COUNTEQ
         CVD   R0,DOUBLE
         MVC   LINE(6),=X'402020202020' EDIT MASK
         ED    LINE(6),DOUBLE+5
         MVC   LINE+7(25),=C'MEMBERS IN BOTH AND EQUAL'
         BAL   R14,REPORTL
         B     EXIT

************************************************************
*         SUBROUTINE TO GET NEXT MEMBER FROM DIRECTORY     *
************************************************************

GETMEM   LM    R0,R1,0(R2)
         CLC   0(8,R1),=8X'FF'     END OF MEMBERS
         BE    GETEOF
GET1R    SLR   R15,R15
         IC    R15,11(,R1)
         N     R15,=F'31'          SET OFF ALL BUT LAST 5 BITS
         SLL   R15,1               CHANGE HALFWORDS TO BYTES
         LA    R1,12(R15,R1)       POINT PAST USER DATA
         CR    R1,R0               END OF BLOCK
         BL    GETMEM1             NO, BRANCH
*        LA    R1,256              YES, READ NEXT BLOCK
*        A     R1,8(,R2)           YES, READ NEXT BLOCK
*        ST    R1,8(,R2)           YES, READ NEXT BLOCK
         L     R1,8(,R2)           NEW WAY TO GET NEXT BLOCK
         L     R1,256(,R1)         NEW WAY TO GET NEXT BLOCK
         ST    R1,8(,R2)           NEW WAY TO GET NEXT BLOCK
         LH    R0,0(,R1)           GET NUMBER OF BYTES IN USE
         AR    R0,R1               POINT PAST LAST BYTE
         LA    R1,2(,R1)           POINT TO FIRST MEMBER
*        B     GET1R
GETMEM1  STM   R0,R1,0(R2)
         MVC   20(8,R2),0(R1)      SAVE MEMBER NAME
         CLC   0(8,R1),=8X'FF'     END OF MEMBERS
         BE    GETEOF
         MVC   16(4,R2),8(R1)      SAVE TTR, ALIAS BIT, ETC
         XC    28(64,R2),28(R2)    ZERO USER DATA AREA
*              COPY USER DATA
         SLR   R15,R15
         IC    R15,11(,R1)
         N     R15,=F'31'          SET OFF ALL BUT LAST 5 BITS
         SLL   R15,1               CHANGE HALFWORDS TO BYTES
         ST    R15,12(,R2)         SAVE LENGTH OF USER DATA
         LTR   R15,R15
         BZ    GETZERO
         TM    OPTIONS,OPTUSER     IS USERDATA TO BE COMPARED
         BZ    GETZERO             NO, BRANCH
         CLI   15(R2),30           IS LENGTH 30
         BNE   *+8                 NO
         OI    12(R2),SPFFLAG      YES, INDICATE IT MAY BE SPF STATS
         BCTR  R15,0               LENGTH MINUS 1 FOR EX
         B     *+10
         MVC   28(0,R2),12(R1)     EXECUTED
         EX    R15,*-6             MOVE THE USER DATA
         TM    11(R1),B'01100000'  ANY TTR'S IN THE USER DATA
         BZ    GETZERO             NO, BRANCH
         NI    12(R2),255-SPFFLAG  YES, CAN'T BE SPF
         IC    R15,11(,R1)         YES, PREPARE TO ZERO THEM
         N     R15,=A(X'0000007F') SET OFF ALIAS BIT
         SRL   R15,5               SHIFT OUT RIGHT 5 BITS
         LA    R14,28(,R2)         POINT TO FIRST TTR IN USER DATA
GETUTTR  XC    0(3,R14),0(R14)     ZERO THE TTR IN THE USER DATA
         LA    R14,4(,R14)         POINT TO NEXT TTR IN THE USER DATA
         BCT   R15,GETUTTR         REPEAT UNTIL R15 ZERO
GETZERO  EQU   *
GETEOF   BR    R8

************************************************************
*         MESSAGE ROUTINE                                  *
************************************************************

PRTMSG   STM   R14,R1,PRTMSGS
         MVC   MESG,MESG-1
         LR    R15,R0
         BCTR  R15,0
         B     *+10
         MVC   MESG+1(0),0(R1)
         EX    R15,*-6
         LA    R1,MESG
         LA    R0,L'MESG
         BAL   R14,REPORT
         LM    R14,R1,PRTMSGS
         BR    R14

************************************************************
*         REPORT WRITER                                    *
************************************************************

REPORTL  LA    R1,LINE
         LA    R0,121
REPORT   STM   R14,R3,REPORTS
         LA    R3,PRTDCBW          POINT R3 TO DCB
         CP    REPORTLN,REPORTMX   IS LINECOUNT LIMIT REACHED
         BL    *+10                NO
         ZAP   REPORTLN,=P'0'      YES, FORCE NEW PAGE
         CP    REPORTLN,=P'0'      IS NEW PAGE REQUESTED?
         BE    REPORTH             YES, GO PRINT HEADING
REPORTD  CH    R0,=H'121'          IS OUTPUT LINE LENGTH OK?
         BNL   REPORTP             YES, BRANCH
         MVC   REPORTO,REPORTO-1   BLANK THE WORK AREA
         LTR   R14,R0              COPY LENGTH
         BNP   REPORTB             BLANK LINE IF < 1
         BCTR  R14,0               LENGTH MINUS 1
         B     *+10
         MVC   REPORTO(0),0(R1)    COPY OUTPUT LINE
         EX    R14,*-6             EXECUTE MVC
REPORTB  LA    R1,REPORTO          POINT TO NEW OUTPUT LINE
REPORTP  LR    R2,R1               POINT R2 TO OUTPUT LINE
         PUT   (R3),(R2)           WRITE OUTPUT LINE
         AP    REPORTLN,=P'1'      INCREMENT LINE COUNTER
REPORTX  LM    R14,R3,REPORTS      RESTORE REGS
         BR    R14                 RETURN
REPORTH  AP    REPORTPG,=P'1'      INCREMENT PAGE COUNTER
         MVC   REPORTO,REPORTO-1   BLANK HEADING
         MVI   REPORTO,C'1'        CC = NEW PAGE
         MVC   REPORTO+1(L'HEAD1),HEAD1
         LA    R1,REPORTO+79-9     RIGHT EDGE PAGE NO
         MVC   3(6,R1),=X'402020202020' EDIT MASK
         ED    3(6,R1),REPORTPG    UNPACK PAGE NO
         MVC   0(4,R1),=C'PAGE'    INSERT 'PAGE'
         PUT   (R3),REPORTO        PUT HEADING LINE 1
         MVC   REPORTO,REPORTO-1   BLANK LINE
         PUT   (R3),REPORTO        PUT HEADING BLANK LINE
         AP    REPORTLN,=P'2'      COUNT HEADING LINES
REPORTHX LM    R0,R1,REPORTS+8     RESTORE R0 AND R1
         B     REPORTD             GO PRINT DETAIL LINE
         EJECT
************************************************************
*         TERMINATION                                      *
************************************************************

EXIT12   MVI   RC+1,12
EXIT     EQU   *
         MVC   COMPMEM,=8X'FF'     INDICATE CLOSE
         CALL  PDSCOMP,COMPMEM,VL
         TM    STATUS,GOTMAIN      IS DIRECTORY AREA GOTTEN
         BZ    EXITGOTX            NO, BYPASS FREEMAIN
EXITGOTL LM    R0,R1,LASTGM
         LTR   R0,R0
         BZ    EXITGOTX
         LM    R14,R15,0(R1)       POINT TO PREVIOUS GETMAIN INFO
         STM   R14,R15,LASTGM
*        L     R0,DIRSIZE
*        L     R1,DIRFREE
         FREEMAIN R,LV=(0),A=(1)
         B     EXITGOTL
EXITGOTX EQU   *
         TM    STATUS,PRTOPEN      IS SYSPRINT OPEN
         BZ    EXITPRTX            NO - BYPASS CLOSE
         LA    R2,PRTDCBW
         MVI   CLOSE,X'80'
         CLOSE ((R2)),MF=(E,CLOSE)
         FREEPOOL (R2)
EXITPRTX EQU   *
         LH    R15,RC
         LR    R1,R13
         L     R0,@SIZE
         L     R13,4(,R13)
         LR    R2,R15
         FREEMAIN R,A=(1),LV=(0)
         LR    R15,R2
         LM    0,12,20(R13)
         L     R14,12(,R13)
         BR    R14

************************************************************
*        CONSTANTS                                         *
************************************************************

         LTORG
HEAD1    DC    C'--- PDSMATCH --- PDS DIRECTORY COMPARE UTILITY ---'
*IRSIZE  DC    0F'0',AL1(1),AL3(128*1024)  128K FOR 2 DIRECTORIES
*IRSIZE  DC    0F'0',AL1(1),AL3(2000*512)  1000K FOR 2 DIRECTORIES
DIRSIZE  DC    0F'0',AL1(1),AL3(8+260*100) 100 DIR BLOCKS PER GETMAIN
*              DIRSIZE SHOULD BE 8 + A MULTIPLE OF 260
YMDNY    DC    AL2(334,304,273,243)
         DC    AL2(212,181,151,120)
         DC    AL2(90,59,31,0)
YMDLY    DC    AL2(335,305,274,244)
         DC    AL2(213,182,152,121)
         DC    AL2(91,60,31,0)
         PRINT NOGEN
PRTDCB   DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,                      +
               RECFM=FBA,LRECL=121,EXLST=PRTEXLST
PRTDCBL  EQU   *-PRTDCB

DIRDCB   DCB   DDNAME=DYNAM,DSORG=PO,MACRF=R,EODAD=DIREOF,SYNAD=DIRSYN,X
               RECFM=U,BLKSIZE=256
DIRDCBL  EQU   *-DIRDCB

         PRINT GEN
PRTEXLST DC    0F'0',X'85',AL3(PRTEXITO)
DIRREADM READ  DIRDECB,SF,MF=L
DIRDECBL EQU   *-DIRDECB
         PRINT GEN
HEXTAB   DC    C'0123456789ABCDEF'
MSGINV   DC    C'INVALID DIRECTORY BLOCK'
MSGEOF   DC    C'NO END-OF-DIRECTORY INDICATOR FOUND'
MSGCRI1A DC    C'CRITERIA FOR MATCHING IS MEMBER NAME ONLY.  USERDATA I+
               N THE DIRECTORY'
MSGCRI1B DC    C'(SUCH AS SPF STATISTICS, LOAD ATTRIBUTES) IS NOT COMPA+
               RED.'
MSGCRI2A DC    C'CRITERIA FOR MATCHING IS MEMBER NAME AND ALL USERDATA +
               IN THE DIRECTORY'
MSGCRI2B DC    C'(SUCH AS SPF STATISTICS, LOAD ATTRIBUTES) EXCEPT TTR F+
               IELDS.'
MSGCRI3A DC    C'CRITERIA FOR MATCHING IS MEMBER NAME AND THE ACTUAL ME+
               MBER DATA'
MSGCRI3B DC    C'(SPF STATISTICS ARE NOT COMPARED).'
         DC    0D'0'
TABNONBL DC    64X'FF'
         DC    X'00'               BLANK
         DC    42X'FF'
         DC    X'00'               COMMA
         DC    148X'FF'
TABBLANK DC    64X'00'
         DC    X'40'               BLANK
         DC    42X'00'
         DC    X'6B'               COMMA
         DC    148X'00'
         DC    0D'0'
EODAD    EQU   32
RECFM    EQU   36
EXLST    EQU   36
DDNAM    EQU   40
OFLGS    EQU   48
SYNAD    EQU   56
BLKSI    EQU   62
LRECL    EQU   82
         DC    0D'0'
COMPMEM  DS    CL08

************************************************************
*        DSECTS                                            *
************************************************************

@DATA    DSECT
         DS    18F                 REGISTER SAVEAREA
DOUBLE   DS    D
HALF     EQU   DOUBLE,2
FULL     EQU   DOUBLE,4
DDNAMEP  DS    CL8
DDNAME1  DS    CL8
DDNAME2  DS    CL8
RC       DS    H
STATUS   DS    X
PRTOPEN  EQU   X'80'
DIROPEN  EQU   X'40'
GOTMAIN  EQU   X'20'
OPTIONS  DS    X
OPTUSER  EQU   X'80'
OPTEQO   EQU   X'40'
OPTNEO   EQU   X'20'
OPTDATA  EQU   X'10'
OPTSUMS  EQU   X'08'
LASTGM   DS    2F
LASTNEXT DS    F
NEXTD14  DS    F
DIRPTR1  DS    F
DIRPTR2  DS    F
DIRSW    DS    F
DIRBLKS  DS    F
DIRBLKSU DS    F
MEMBERS  DS    F
ALIASES  DS    F
PRTDCBW  DS    0F,(PRTDCBL)X
DIRDCBW  DS    0F,(DIRDCBL)X
DIRDECBW DS    0F,(DIRDECBL)X
DIREXLST DS    F
DEVAREA  DS    2F
CLOSE    DS    0F
OPEN     DS    F
RDJFCB   DS    F
COUNTEQ  DS    F
COUNTNE  DS    F
COUNTL1  DS    F
COUNTL2  DS    F
PARSES   DS    6F
REPORTS  DS    6F
REPORTPG DS    PL3
REPORTLN DS    PL2
REPORTMX DS    PL2
PRTMSGS  DS    4F
PDSWORK1 DS    3F
         DS    F                   USER DATA LENGTH
SPFFLAG  EQU   X'80'               USER DATA CONTAINS SPF STATISTICS
         DS    XL3                 TTR
         DS    X                   ALIAS BIT AND USER DATA LENGTH
         DS    CL8                 MEMBER NAME
         DS    CL64                USER DATA
PDSWORK2 DS    3F
         DS    F                   USER DATA LENGTH
         DS    XL3                 TTR
         DS    X                   ALIAS BIT AND USER DATA LENGTH
         DS    CL8                 MEMBER NAME
         DS    CL64                USER DATA
LINEB    DS    C  (LINE-1)
LINE     DS    CL133
MESGB    DS    C  (MESG-1)
MESG     DS    CL133
MESSAGE  DS    CL72
REPORTOB DS    C (REPORTO-1)
REPORTO  DS    CL133
JFCB1    DS    0D,CL176
JFCB2    DS    0D,CL176
         DS    0D
@DATAL   EQU   *-@DATA

         END
         MACRO
&NAME    RENTER  &BASEREG=R11,&SALEN=108,&REGS=YES
         GBLC  &SASIZE
         LCLA  &#BR,&#BRX,&#BRY,&BASELEN   NEEDED BY IFOX00
         LCLC  &BASES                      NEEDED BY IFOX00
&SASIZE  SETC  '&SALEN'
.* THIS MACRO PROVIDES ENTRY CODE FOR A REENTRANT PROGRAM.
.* THE DEFAULT BASE REGISTER IS 11 BUT MAY BE CHANGED VIA
.* THE BASEREG PARAMETER.  THE SAVE AREA SIZE MAY BE SET
.* THROUGH THE SALEN PARAMETER AND DEFAULTS TO 108.
         AIF   ('&REGS' NE 'YES').NOREGS
         REGS
.NOREGS  ANOP
&NAME    CSECT
         STM   R14,R12,12(R13)     SAVE INCOMING REGS
         LR    &BASEREG(1),R15     ESTABLISH ADDRESSABILITY
&#BR     SETA  N'&BASEREG
         AIF   (&#BR GT 1).MULTIRG
         USING &NAME,&BASEREG
         AGO   .OUTBASE
.MULTIRG ANOP
&#BRX    SETA  1
&#BRY    SETA  2
         LA    &BASEREG(&#BR),4095
.LOADNXT LA    &BASEREG(&#BRY),1(&BASEREG(&#BRX),&BASEREG(&#BR))
&#BRX    SETA  &#BRX+1
&#BRY    SETA  &#BRY+1
         AIF   (&#BRY LE &#BR).LOADNXT
&BASELEN SETA  K'&BASEREG-2
&BASES   SETC  '&BASEREG'(2,&BASELEN)
         USING &NAME,&BASES
.OUTBASE ANOP
         LA    R0,&SASIZE          LOAD SAVE AREA SIZE FOR GETMAIN
         GETMAIN R,LV=(0)
         ST    R1,8(R13)           STORE ADDRESS OF NEW SAVE AREA
         ST    R13,4(R1)           SAVE CALLERS SAVE AREA ADDRESS
         LM    R0,R1,20(R13)       RELOAD R0 & R1
         L     R13,8(R13)          LOAD NEW SAVE AREA ADDRESS INTO R13
         MEND
         MACRO
         REGS  &PP=R
         LCLA  &II
&II      SETA  0
.LOOP    ANOP
&PP&II   EQU   &II
&II      SETA  &II+1
         AIF   (&II LT 16).LOOP
         MEND
         MACRO
&NAME    REXIT &RC15=YES
         GBLC  &SASIZE
         LCLA  &#BR,&#BRX,&#BRY,&BASELEN   NEEDED BY IFOX00
         LCLC  &BASES                      NEEDED BY IFOX00
&NAME    DS    0H
         LA    R0,&SASIZE          LOAD SAVE AREA LENGTH FOR RELEASE
         LR    R1,R13              LOAD SAVE AREA ADDRESS FOR RELEASE
         L     R13,4(R13)          RESTORE CALLING SAVE AREA ADDRESS
         AIF   ('&RC15' NE 'YES').NORETC
         ST    R15,16(R13)         SAVE RETURN CODE
.NORETC  ANOP
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)     RESTORE CALLING REGS R14 - R12
         BR    R14
         MEND
PDSCOMP  RENTER

*  R0
*  R1    SHORT TERM WORK REG
*  R2
*  R3    PDS 1 DCB
*  R4    PDS 1 DATA READ/1 PAST
*  R5    PDS 1 DATA POINTER
*  R6    PDS 2 DCB
*  R7    PDS 2 DATA READ/1 PAST
*  R8    PDS 2 DATA POINTER
*  R9
*  R10
*  R11   BASE
*  R12   SUBROUTINE RETURN
*  R13   SAVEAREA
*  R14   SHORT TERM WORK REG
*  R15   SHORT TERM WORK REG

         L     R14,0(R1)           GET MEMBER NAME
         CLC   0(8,R14),=8X'FF'       IF MEMBER IS ALL HEX FF
         BE    CLOSEM                 GO CLOSE THE DCB'S
         MVC   MEMBER,0(R14)

         CLI   INITIAL,C'Y'        FIRST TIME THROUGH?
         BNE   NOTFIRST            IF NOT, DON'T DO BASIC STUFF AGAIN

         MVI   INITIAL,C'N'        FIRST TIME THROUGH ONLY
         OPEN  (PDS1,,PDS2)
         L     R0,PDSDATAL
         GETMAIN R,LV=(0)
         ST    R1,PDS1DATA
         A     R1,PDSDATAH
         ST    R1,PDS2DATA

NOTFIRST EQU   *
         MVI   PDS1DONE,C'N'
         MVI   PDS2READ,C'N'
         LA    R3,PDS1             POINT TO PDS' DCB'S & DATA AREAS
         LA    R6,PDS2

         FIND  PDS1,MEMBER,D
*        MVC   MBUF(7),=C'FIND 1 '
*        MVC   MBUF+7(8),MEMBER
*        LA    R1,MBUF
*        LA    R0,15
*        SVC   93 TPUT
         BAL   R12,READ1

         FIND  PDS2,MEMBER,D
         BAL   R12,READ2

         USING IHADCB,R3
         TM    DCBRECFM,DCBRECU    WHAT RECORD FORMAT?
         BO    CHECKU
         TM    DCBRECFM,DCBRECV
         BO    CHECKV
         B     CHECKF

CHECKF   EQU   *
         LH    R14,DCBLRECL
         TM    DCBRECFM,DCBRECBR   IF RECFM NOT BLOCKED          .FIX1.
         BO    CHECKF05              THEN                        .FIX1.
         LH    R14,DCBBLKSI          USE BLKSI AS RECORD LENGTH  .FIX1.
CHECKF05 EQU   *                                                 .FIX1.
         ST    R14,LRECL
CHECKF10 EQU   *
         LR    R14,R5              R5 --> SYSLIB1 DATA
         L     R15,LRECL
         LR    R0,R8               R8 --> SYSLIB2 DATA
         LR    R1,R15
         CLCL  R14,R0
         BNE   NOTEQUAL
         A     R5,LRECL
         CR    R5,R4               R4 --> END OF SYSLIB1 BLOCK
         BL    CHECKF20
         BAL   R12,READ1
CHECKF20 EQU   *
         A     R8,LRECL
         CR    R8,R7               R7--> END OF SYSLIB2 BLOCK
         BL    CHECKF10
         BAL   R12,READ2
         B     CHECKF10

CHECKV   EQU   *
         LA    R5,4(R5)            POINT PAST BDW TO 1ST RDW
         LA    R8,4(R8)            POINT PAST BDW TO 1ST RDW
CHECKV10 EQU   *
         LH    R15,0(R5)           GET RECORD LENGTH 1
         LH    R1,0(R8)            GET RECORD LENGTH 2
         S     R15,FW4             MINUS 4
         S     R1,FW4              MINUS 4
         ST    R15,LRECL           SAVE RECORD LENGTH EXCLUDING RDW
         CR    R15,R1              IF RECORD LENGTHS DON'T MATCH
         BNE   NOTEQUAL              NOT EQUAL
         LA    R5,4(R5)            POINT PAST RDW 1
         LA    R8,4(R8)            POINT PAST RDW 2
         LR    R14,R5
         LR    R0,R8
         CLCL  R14,R0              COMPARE RECORDS
         BNE   NOTEQUAL              NOT EQUAL
         L     R15,LRECL
         LA    R5,0(R15,R5)        POINT TO NEXT RDW 1 OR EOB
         CR    R5,R4               IF END OF BLOCK
         BL    CHECKV20              THEN
         BAL   R12,READ1             READ NEXT BLOCK
         LA    R5,4(,R5)             POINT PAST BDW TO 1ST RDW   .FIX4.
CHECKV20 EQU   *
         L     R15,LRECL
         LA    R8,0(R15,R8)        POINT TO NEXT RDW 2 OR EOB
         CR    R8,R7               IF END OF BLOCK
         BL    CHECKV10              THEN
         BAL   R12,READ2             READ NEXT BLOCK
         LA    R8,4(,R8)             POINT PAST BDW TO 1ST RDW   .FIX4.
         B     CHECKV10

CHECKU   EQU   *
         SR    R4,R5
         SR    R7,R8
         CR    R4,R7
         BNE   NOTEQUAL
         LR    R14,R5
         LR    R15,R4
         LR    R0,R8
         LR    R1,R7
         CLCL  R14,R0
         BNE   NOTEQUAL
         BAL   R12,READ1
         BAL   R12,READ2
         B     CHECKU

PDS1EOF  EQU   *
         MVI   PDS1DONE,C'Y'
*              NEXT 4 LINES ADDED AUG 2 2016                     .FIX3.
         CLI   PDS2READ,C'N'       IF READ2 HAS NOT BEEN CALLED  .FIX3.
         BNE   PDS1EO1                THEN                       .FIX3.
         FIND  PDS2,MEMBER,D          FIND BEFORE 1ST READ2      .FIX3.
         B     PDS1EO2                SKIP DEC 13 2015 LOGIC.    .FIX3.
*              POSSIBLE PROBLEM DISCOVERED DEC 13 2015.
*              THERE MIGHT BE MORE DATA IN THE CURRENT READ2 BLOCK
*              BETWEEN R8 AND R7. DOING A READ2 IS PREMATURE.
*              THE READ2 COULD HIT EOF AND FALSELY INDICATE EQUAL.
*              IF R8 < R7 THEN GO TO NOTEQUAL. ADDED CR AND BL.
*              BUT THIS ONLY FIXES RECFM F. NEEDS MORE LOGIC.
PDS1EO1  A     R8,LRECL            IF ANOTHER RECORD IN PDS2 BLK .FIX2.
         CR    R8,R7                 THEN                        .FIX2.
         BL    NOTEQUAL              NOT EQUAL                   .FIX2.
PDS1EO2  EQU   *                                                 .FIX3.
         BAL   R12,READ2           IF READ PDS2 HITS EOF TOO, EQUAL
         B     NOTEQUAL

PDS2EOF  EQU   *
         CLI   PDS1DONE,C'Y'
         BE    EQUAL
         B     NOTEQUAL

EQUAL    EQU   *
         SR    R15,R15
         B     EXIT
NOTEQUAL EQU   *
         LA    R15,4
EXIT     REXIT

READ1    EQU   *
         L     R5,PDS1DATA
         READ  PDS1DECB,SF,PDS1,(R5),'S'
         CHECK PDS1DECB
         L     R14,PDS1DECB+16     FIGURE DATA LENGTH ACTUALLY READ
         USING IHADCB,R3
         LH    R4,DCBBLKSI
         SH    R4,14(R14)
         LA    R4,0(R4,R5)
         BR    R12

READ2    EQU   *
         MVI   PDS2READ,C'Y'       READ2 HAS BEEN CALLED AT LEAST ONCE
         L     R8,PDS2DATA
         READ  PDS2DECB,SF,PDS2,(R8),'S'
         CHECK PDS2DECB
         L     R14,PDS2DECB+16     FIGURE DATA LENGTH ACTUALLY READ
         DROP  R3
         USING IHADCB,R6
         LH    R7,DCBBLKSI
         SH    R7,14(R14)
         LA    R7,0(R7,R8)
         BR    R12

CLOSEM   CLI   INITIAL,C'Y'
         BE    EQUAL
         MVI   INITIAL,C'Y'
         L     R1,PDS1DATA
         L     R0,PDSDATAL
         FREEMAIN R,LV=(0),A=(1)
         CLOSE (PDS1,,PDS2)
         B     EQUAL

FW4      DC    F'4'
LRECL    DS    F
MEMBER   DS    CL8
INITIAL  DC    C'Y'
PDS1DONE DC    C'N'
PDS2READ DC    C'N'
PDSDATAL DC    F'65536'
PDSDATAH DC    F'32768'
PDS1DATA DS    A
PDS2DATA DS    A
MBUF     DS    CL32
RECFM1   DS    C
RECFM2   DS    C
         LTORG
         PRINT NOGEN
PDS1     DCB   DSORG=PO,MACRF=R,DDNAME=SYSLIB1,EODAD=PDS1EOF
PDS2     DCB   DSORG=PO,MACRF=R,DDNAME=SYSLIB2,EODAD=PDS2EOF
         DCBD  DSORG=(PO),DEVD=DA
         END
