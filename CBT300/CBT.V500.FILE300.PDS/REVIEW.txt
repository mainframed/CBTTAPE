         TITLE '  R E V I E W   '
***********************************************************************
*                                                                     *
*        REVIEW - TSO COMMAND FOR EXAMINING A DATA SET                *
*                 ON A 3270 DISPLAY STATION SCREEN                    *
*                                                                     *
***********************************************************************
*
*        WRITTEN BY. BILL GODFREY, PRC (PLANNING RESEARCH CORPORATION).
*        INSTALLATION. AIR FORCE DATA SERVICES CENTER, PENTAGON.
*        DATE WRITTEN. JANUARY 19 1981.
*        DATE UPDATED. MARCH 18 1982.
*        ATTRIBUTES. RE-ENTRANT.
*        LOCAL MACROS USED. DCS. (DEFINE CONSTANTS FOR SCREEN).
*        DESCRIPTION.
*         THIS TSO COMMAND DISPLAYS A DATA SET ON A 3270 TERMINAL
*         IN FULLSCREEN MODE.
*
*         LOG OF CHANGES.
*         27MAR81 - ALLOW PFK DEFINITIONS TO BE CHANGED.
*         10JUL81 - IKJRLSA SOON AFTER PARSE. VOLUME KEYWORD.
*                   FIXED BUG OF IKJEFF18 BEING CALLED TWICE.
*                   MISCELLANEOUS INTERNAL RESTRUCTURING OF CODE TO
*                   TO ALLOW FUTURE CHANGES. OLD CODE HAD USED UP
*                   ALL 3 BASE REGISTERS.
*         14JUL81 - BYPASS IKJEHDEF IF VOL SPECIFIED. ADD UNIT KW.
*                   HEX SUBCOMMAND WITHOUT OPERANDS WILL FLIP-FLOP
*                   BETWEEN HEX ON AND HEX OFF. PFK9 IS NOW HEX
*                   INSTEAD OF HEX ON. PFK12 IS NO LONGER HEX OFF.
*                   SMF SUBCOMMAND WITHOUT OPERANDS WILL FLIP FLOP.
*         20JUL81 - FINDSMF SUBCOMMAND ADDED, FOR SMF RECORD TYPE.
*         29SEP81 - ACCEPT PFK 13-24 CORRESPONDING TO 1-12.
*                   FIX BUG AT CLC FOR REPLY 'FINDSMF'.
*         29JAN82 - SET UP IOPL BEFORE DOING GTSIZE/ERRTERM.
*         29JAN82 - ALLOW MEMBER TO BE SPECIFIED WITH DDNAME, SO USER
*                   CAN DO THINGS LIKE REVIEW SYSPROC(MEMBER) FILE
*                   (AND SHOW DDNAME+NNN IF CONCATENATED).
*                   REPLACE 'POINT' WITH 'FIND' TO SUPPORT
*                   CONCATENATED PDS'S.
*         18MAR82 - CALL REVSMF SUBPROGRAM TO FORMAT SMF DATA.
*         29JAN91 - REALLY DID THE CALL AS ABOVE   JDM1      .
*
*        NOTES.
*         KNOWN BUGS.
*          WHEN BROWSING VARIABLE SPANNED RECORDS, THE 'UP'
*          SUBCOMMAND WILL GIVE UNPREDICTABLE RESULTS.
*          SO WILL 'DOWN' IF THE RECORDS YOU ARE GOING DOWN TO
*          HAVE ALREADY BEEN READ ONCE AND ARE THEREFORE IN THE
*          CHECKPOINT TABLE.
*          MORE INFORMATION MUST BE SAVED IN THE CHECKPOINT TABLE
*          IN ORDER TO FIX THIS BUG. (SMF IS VARIABLE SPANNED).
*
***********************************************************************
         EJECT
***********************************************************************
*
*         SYNTAX -   REVIEW DSNAME
*          OR        REVIEW DDNAME FILE
*
*         IF THE SECOND OPERAND IS 'FILE', THAT MEANS THE
*         FIRST OPERAND IS NOT A DSNAME BUT A DDNAME.
*
*         THE SCREEN WILL NORMALLY CONTAIN 20 RECORDS, ONE PER LINE,
*         80 CHARACTERS PER LINE.  TO DISPLAY RECORDS LONGER THAN 80
*         BYTES, THERE IS A 'RIGHT' SUBCOMMAND WHICH CAUSES DATA TO
*         THE RIGHT OF THE DATA ON THE SCREEN TO BE DISPLAYED.
*         THE 'LEFT' SUBCOMMAND CAN THEN BE USED TO DISPLAY DATA
*         BACK TOWARDS THE FRONT OF THE RECORD.
*
*         SUBCOMMANDS -
*         UP       - DISPLAY RECORDS ABOVE THOSE ON THE SCREEN
*         DOWN     - DISPLAY RECORDS BELOW THOSE ON THE SCREEN
*         TOP      - DISPLAY THE FIRST RECORDS
*         BOTTOM   - DISPLAY THE LAST RECORDS
*         RIGHT    - DISPLAY DATA TO THE RIGHT
*         LEFT     - DISPLAY DATA TO THE LEFT
*         LIST     - DISPLAY A SPECIFIED RECORD NUMBER
*         FIND     - DISPLAY A RECORD CONTAINING A SPECIFIED STRING
*         CAPS     - TRANSLATE LOWER CASE LETTERS TO CAPS
*         ASIS     - LEAVE LOWER CASE LETTERS IN LOWER CASE
*         HEX ON   - DISPLAY DATA IN HEXADECIMAL FORMAT
*         HEX OFF  - TURN OFF HEXADECIMAL FORMATTING
*         HEX      - SWITCH HEXADECIMAL FORMATTING ON/OFF.
*         PFKNN    - CHANGE DEFINITION OF PF KEY NN.
*         SMF ON   - DISPLAY SMF RECORDS WITH TIME AND DATE FORMATTED
*         SMF OFF  - TURN OFF SMF FORMATTING
*         SMF      - SWITCH SMF FORMATTING ON/OFF.
*         FINDSMF  - FIND A TYPE OF SMF RECORD
*         MEMBER   - DISPLAY A DIFFERENT MEMBER OF THE SAME PDS
*         END      - END THE COMMAND
*
*         WHEN 'UP' OR 'DOWN' DOES NOT SPECIFY HOW FAR UP OR DOWN,
*         THE 'RANGE' VALUE IS USED.  THIS VALUE IS ALWAYS DISPLAYED
*         NEAR THE TOP OF THE SCREEN AND CAN BE CHANGED BY MOVING
*         THE CURSOR OVER THE VALUE AND TYPING IN A NEW VALUE.
*         THE NEW VALUE WILL REMAIN IN EFFECT UNTIL THE COMMAND
*         ENDS OR UNTIL YOU CHANGE IT AGAIN.
*
***********************************************************************
         EJECT
***********************************************************************
*
*         PROGRAM FUNCTION KEYS
*
*         SOME OF THE SUBCOMMANDS DO NOT HAVE TO BE TYPED IN
*         IF THE TERMINAL IS EQUIPPED WITH PROGRAM FUNCTION KEYS.
*         FOR EXAMPLE, HITTING KEY 'PF8' IS EQUIVALENT TO
*         TYPING IN 'DOWN' AND HITTING THE 'ENTER' KEY.
*
*         HERE ARE THE MEANINGS ASSIGNED TO EACH PF KEY.
*
*         ----------------------------------------------------
*         I                I                I                I
*         I      PF1       I      PF2       I      PF3       I
*         I                I                I                I
*         I      TOP       I     BOTTOM     I      END       I
*         I                I                I                I
*         ----------------------------------------------------
*         I                I                I                I
*         I      PF4       I      PF5       I      PF6       I
*         I                I                I                I
*         I                I      FIND      I                I
*         I                I                I                I
*         ----------------------------------------------------
*         I                I                I                I
*         I      PF7       I      PF8       I      PF9       I
*         I                I                I                I
*         I      UP        I      DOWN      I      HEX       I
*         I                I                I                I
*         ----------------------------------------------------
*         I                I                I                I
*         I      PF10      I      PF11      I      PF12      I
*         I                I                I                I
*         I      LEFT      I      RIGHT     I                I
*         I                I                I                I
*         ----------------------------------------------------
*
*         THE SCREEN IS WRITTEN USING THE 'EXPANDED FULLSCREEN'
*         (EXPFLS=YES) FEATURE OF TCAM, WHICH REQUIRES THAT THE
*         FIRST ORDER IN THE BUFFER BE 'SBA,24,80' OR 'SBA,24,79'.
*         THE FIRST IS USED TO SUPPRESS LINE COUNTING, AND THE
*         LATTER IS USED TO RESET THE LINE COUNTER.
*
*         IF AN UNQUALIFIED DATA SET NAME IS ENTERED, THE
*         CATALOG MUST BE READ TWICE, ONCE TO APPEND A
*         TRAILING QUALIFIER IF NECESSARY, AND AGAIN DURING
*         ALLOCATION. THE USER CAN ELIMINATE THE FIRST BY USING
*         THE FULLY QUALIFIED NAME, PREFIX AND ALL, IN QUOTES,
*         OR BY ENTERING ALL BUT THE PREFIX, WITHOUT QUOTES,
*         PLUS THE KEYWORD 'Q'. THE LATTER IS MUCH SIMPLER
*         AND GIVES THE SAME PERFORMANCE IMPROVEMENT AS A
*         FULLY QUALIFIED NAME.
*
*         THE 'FILE' KEYWORD IS USEFUL FOR LOOKING AT TEMPORARY
*         DATA SETS.  IT TELLS THE COMMAND TO TREAT THE FIRST
*         OPERAND AS A FILENAME (DDNAME) INSTEAD OF A DSNAME.
*         WHATEVER DATA SET IS CURRENTLY ALLOCATED TO THE
*         FILENAME WILL BE DISPLAYED (AND QUICKLY, BECAUSE
*         THE COMMAND DOESNT HAVE TO ALLOCATE ANYTHING).
*
***********************************************************************
         SPACE
         MACRO
&NAME    MSGZ  &MSG
&NAME    DC    AL2(&NAME.L-2)
         DC    C&MSG
&NAME.L  EQU   *-&NAME
         MEND
         SPACE
         GBLB  &MVS
&MVS     SETB  1                   1 - MVS   0 - SVS,MVT
         SPACE
REVIEW   START
         USING *,R10,R11,R12
CSECT1   EQU   *
         B     @PROLOG-*(,R15)
         DC    AL1(11),CL11'REVIEW '
         DC    CL16' &SYSDATE &SYSTIME '
@SIZE    DC    0F'0',AL1(1),AL3(@DATAL)
@PROLOG  STM   14,12,12(13)
         LR    R10,R15             BASE
         LA    R15,1
         LA    R11,4095(R15,R10)   BASE
         LA    R12,4095(R15,R11)   BASE
         LR    R2,R1
         USING CPPL,R2
         L     R0,@SIZE
         GETMAIN R,LV=(0)
         LR    R9,R1
         USING @DATA,R9
         ST    13,4(,1)            CHAIN SAVEAREA
         ST    1,8(,13)            CHAIN SAVEAREA
         LR    13,1                NEW SAVEAREA
         SPACE 1
         STM   R10,R12,BASE1
         L     R14,=A(REVIEW2)
         ST    R14,BASE2
         LA    R15,1
         LA    R14,4095(R15,R14)   BASE
         ST    R14,BASE2+4
         LA    R14,4095(R15,R14)   BASE
         ST    R14,BASE2+8
         MVC   SIZE,@SIZE
         ST    R2,CPPLPTR
         MVI   STATUS,0
         MVI   MODE,0
         MVI   SMFSW,0
         XC    LINKAREA(8),LINKAREA
         SLR   R15,R15
         STH   R15,RC              SET RC = 0
         ST    R15,KOUNT
         ST    R15,TTRZ            SET Z = 0
         XC    MSG(2),MSG
         XC    MYANS,MYANS         IN CASE IKJRLSA BEFORE PARSE
         XC    CALLSMFA,CALLSMFA
         SPACE
************************************************************
*                                                          *
*        SET UP IOPL FOR PUTLINE                           *
*                                                          *
************************************************************
         SPACE
         LA    R15,MYIOPL
         USING IOPL,R15
         MVC   IOPLUPT(4),CPPLUPT
         MVC   IOPLECT(4),CPPLECT
         LA    R0,MYECB
         ST    R0,IOPLECB
         XC    MYECB,MYECB
         LA    R0,MYPTPB
         ST    R0,IOPLIOPB
         DROP  R15                 IOPL
         SPACE
         AIF   (NOT &MVS).SKIP1
         L     R15,16              LOAD CVT POINTER
         TM    444(R15),X'80'      IS PUTLINE LOADED? (VS2)
         BNO   PUTLOAD             NO - BRANCH TO LOAD
         L     R15,444(,R15)       YES - USE CVTPUTL
         B     PUTLOADX            BRANCH AROUND LOAD
.SKIP1   ANOP
PUTLOAD  LA    R0,=CL8'IKJPUTL '
         LOAD  EPLOC=(0)
         LR    R15,R0              GET ENTRY ADDRESS
         LA    R15,0(,R15)         CLEAR HI BYTE FOR DELETE ROUTINE
PUTLOADX ST    R15,MYPUTLEP        SAVE PUTLINE ENTRY ADDRESS
         SPACE
************************************************************
*                                                          *
*        CHECK TERMINAL SCREEN SIZE                        *
*                                                          *
************************************************************
         SPACE
         GTSIZE
         CH    R0,=H'24'           24 ROWS (LINES)
         BNE   ERRTERM
         CH    R1,=H'80'           80 COLUMNS
         BNE   ERRTERM
         SPACE
************************************************************
*                                                          *
*        SET UP PFK DEFAULTS                               *
*                                                          *
************************************************************
         SPACE
         LA    R1,PFKDEF
         LA    R15,PFKTAB
         LA    R0,12
PFKINIT  MVI   0(R15),C' '
         MVC   1(PFKTABL-1,R15),0(R15) PAD WITH BLANKS
         MVC   0(PFKDEFL,R15),0(R1) INSERT DEFAULT
         LA    R1,PFKDEFL(,R1)     POINT TO NEXT DEFAULT
         LA    R15,PFKTABL(,R15)   POINT TO NEXT PFK ENTRY
         BCT   R0,PFKINIT          11 MORE TIMES
         MVI   0(R15),0            END OF TABLE
         SPACE
************************************************************
*                                                          *
*        SET UP PPL FOR PARSE                              *
*                                                          *
************************************************************
         SPACE
         LA    R15,MYPPL
         USING PPL,R15
         MVC   PPLUPT(4),CPPLUPT
         MVC   PPLECT(4),CPPLECT
         LA    R0,MYECB
         ST    R0,PPLECB
         XC    MYECB,MYECB
         L     R0,=A(REVPCL)
         ST    R0,PPLPCL
         LA    R0,MYANS
         ST    R0,PPLANS
         MVC   PPLCBUF(4),CPPLCBUF
         ST    R9,PPLUWA
         DROP  R15                 PPL
         SPACE 1
************************************************************
*                                                          *
*        CALL THE PARSE SERVICE ROUTINE                    *
*                                                          *
************************************************************
         SPACE 1
         LR    R1,R15              POINT TO PPL
         AIF   (NOT &MVS).SKIP2
         L     R15,16              CVTPTR
         TM    524(R15),X'80'      IF HI ORDER BIT NOT ON
         BNO   PARSELNK               THEN DO LINK, NOT CALL
         L     R15,524(,R15)       CVTPARS
         BALR  R14,R15             CALL IKJPARS
         B     PARSEEXT            SKIP AROUND LINK
PARSELNK EQU   *
.SKIP2   ANOP
         LINK  EP=IKJPARS,SF=(E,LINKAREA)
PARSEEXT EQU   *
         SPACE 1
         LTR   R15,R15
         BZ    PARSEOK
         LA    R1,MSG01
         LA    R0,L'MSG01
         BAL   R14,PUTMSG1
         LA    R15,12
         B     EXIT
PARSEOK  EQU   *
         SPACE
         L     R3,MYANS
         USING IKJPARMD,R3
         SPACE
************************************************************
*                                                          *
*         FILL IN ALL INFO FROM PARSE                      *
*                                                          *
************************************************************
         SPACE
         MVC   FILEKV,FILEKW
         MVC   QUICKV,QUICKW
         LA    R6,DSN
         TM    6(R6),X'80'         IS DATASET NAME SPECIFIED?
         BO    OKDSN               YES - BRANCH
         LA    R1,MSG05            NO - JUST MEMBER NAME
         LA    R0,L'MSG05
         BAL   R14,PUTMSG1
         B     EXITA12
         SPACE
OKDSN    EQU   *
         MVC   UDSNAME(4),4(R6)    COPY LENGTH AND QUOTE FLAGS
         LA    R15,UDSNAME+4
         MVI   0(R15),C' '         BLANK THE DSNAME AREA
         MVC   1(43,R15),0(R15)
         L     R14,0(,R6)          POINT TO DSN VALUE
         LH    R1,4(,R6)           GET LENGTH
         STH   R1,UDSNAME
         BCTR  R1,0                LENGTH MINUS 1 FOR EX
         B     *+10                BRANCH AROUND EXECUTED MVC
         MVC   0(0,R15),0(R14)     (EXECUTED)
         EX    R1,*-6              MOVE DSN TO DSNAME (AFTER PREFIX)
         SPACE
         MVC   $MEMBER,=CL8' '
         TM    14(R6),X'80'        MEMBER SPECIFIED?
         BZ    PARSEMX             NO - BRANCH
         LH    R1,12(,R6)          GET LENGTH OF MEMBER
         BCTR  R1,0                MINUS 1 FOR EX
         L     R14,8(,R6)          GET ADDRESS OF MEMBER NAME
         B     *+10
         MVC   $MEMBER(0),0(R14)   MOVE MEMBER NAME
         EX    R1,*-6
PARSEMX  EQU   *
         SPACE
         MVC   $PASSWRD,=CL8' '
         TM    22(R6),X'80'        PASSWORD SPECIFIED?
         BZ    PARSEPX             NO - BRANCH
         LH    R1,20(,R6)          GET LENGTH OF PSWD
         BCTR  R1,0                MINUS 1 FOR EX
         L     R14,16(,R6)         GET ADDRESS OF PSWD
         B     *+10
         MVC   $PASSWRD(0),0(R14)  MOVE PSWD
         EX    R1,*-6
PARSEPX  EQU   *
         MVC   $VOLSER,=CL8' '     (6 BYTES)
         MVC   $UNIT,=CL8' '
         LA    R6,VOL
         TM    6(R6),X'80'         VOLUME SPECIFIED
         BZ    PARSEVX             NO, LEAVE VOL AND UNIT BLANK
         L     R14,0(,R6)          POINT TO VOL VALUE
         LH    R1,4(,R6)           GET LENGTH
         BCTR  R1,0                LENGTH MINUS 1 FOR EX
         B     *+10                BRANCH AROUND EXECUTED MVC
         MVC   $VOLSER(0),0(R14)   (EXECUTED)
         EX    R1,*-6              MOVE VOLUME
         LA    R6,UNIT
         TM    6(R6),X'80'         UNIT SPECIFIED
         BZ    PARSEUX             NO, BRANCH
         L     R14,0(,R6)          POINT TO UNITNAME VALUE
         LH    R1,4(,R6)           GET LENGTH
         BCTR  R1,0                LENGTH MINUS 1 FOR EX
         B     *+10                BRANCH AROUND EXECUTED MVC
         MVC   $UNIT(0),0(R14)     (EXECUTED)
         EX    R1,*-6              MOVE UNIT NAME
PARSEUX  EQU   *
PARSEVX  EQU   *
         DROP  R3                  IKJPARMD
         IKJRLSA MYANS
         XC    MYANS,MYANS
         SPACE
************************************************************
*                                                          *
*        QUALIFY THE DSNAME IF NECESSARY                   *
*                                                          *
************************************************************
         SPACE
         LA    R15,$DSNAME+2
         MVI   0(R15),C' '         BLANK THE DSNAME AREA
         MVC   1(43,R15),0(R15)
         SLR   R1,R1
         STH   R1,$DSNAME          ZERO DSNAME LENGTH
         TM    UDSNAME+2,X'40'     IS DSN QUOTED?
         BO    NOPREF              YES, SKIP PREFIXING
         CLI   FILEKV+1,1          DSN TO BE TREATED AS DDNAME
         BE    NOPREF              YES, SKIP PREFIXING
         AIF   (NOT &MVS).SKIPP    PREFIX WITH PREFIX
         L     R14,CPPLUPT         POINT TO UPT
         USING UPT,R14
         IC    R1,UPTPREFL         GET LENGTH OF PREFIX
         LTR   R1,R1               IS IT ZERO
         BZ    NOPREF              YES, SKIP PREFIXING
         B     *+10
         MVC   0(0,R15),UPTPREFX
         DROP  R14                 UPT
.SKIPP   AIF   (&MVS).SKIPU        PREFIX WITH USERID
         L     R14,CPPLPSCB        POINT TO PSCB
         USING PSCB,R14
         IC    R1,PSCBUSRL         GET LENGTH OF USERID
         LTR   R1,R1               IS IT ZERO
         BZ    NOPREF              YES, SKIP PREFIXING
         B     *+10
         MVC   0(0,R15),PSCBUSER
         DROP  R14                 PSCB
.SKIPU   ANOP
         EX    R1,*-6              MOVE USERID TO DSNAME AREA
         LA    R15,0(R1,R15)       POINT PAST USERID
         MVI   0(R15),C'.'         APPEND PERIOD
         LA    R15,1(,R15)         POINT PAST PERIOD
         LA    R1,1(,R1)           ADD 1 TO LENGTH
         STH   R1,$DSNAME          STORE LENGTH OF USERID PLUS 1
NOPREF   EQU   *
         LH    R1,UDSNAME          GET LENGTH
         LR    R0,R1
         AH    R0,$DSNAME          ADD LENGTH OF PREFIX OR ZERO
         STH   R0,$DSNAME          SET COMBINED LENGTH
         LA    R14,UDSNAME+4       POINT TO DSN VALUE
         BCTR  R1,0                LENGTH MINUS 1 FOR EX
         B     *+10                BRANCH AROUND EXECUTED MVC
         MVC   0(0,R15),0(R14)     (EXECUTED)
         EX    R1,*-6              MOVE DSN TO DSNAME (AFTER PREFIX)
         SPACE
************************************************************
*                                                          *
*        IF 'FILE' KEYWORD IS SPECIFIED,                   *
*        GET DSNAME FROM JFCB USING FILE NAME.             *
*                                                          *
************************************************************
         SPACE
         CLI   FILEKV+1,1          'FILE' SPECIFIED?
         BNE   NOFILE              NO, BRANCH
         CLI   $DSNAME+1,8         IS LENGTH 8 OR LESS
         BH    FILERR1             NO, BRANCH
         DEVTYPE $DSNAME+2,DEVDATA GET DEVICE TYPE
         LTR   R15,R15             WAS FILENAME VALID
         BNZ   FILERR2             NO, BRANCH
         TM    DEVDATA+2,X'20'     DIRECT ACCESS
         BZ    FILERR3             NO, BRANCH
         LA    R4,DYNDCBW
         L     R1,=A(SEQDCB)
         MVC   0(SEQDCBL,R4),0(R1)
         LA    R0,JFCB
         LA    R1,DYNEXLST
         ST    R0,0(,R1)
         MVI   0(R1),X'87'
         ST    R1,36(,R4)          DCBEXLST
         MVC   40(8,R4),$DSNAME+2  DCBDDNAM
         MVC   $DDNAML(46),$DSNAME
         LA    R0,4                ADD 4
         AH    R0,$DDNAML           TO LENGTH OF DDNAME
         STH   R0,$DDNAML            FOR +NNN (CONCAT NUMBER)
         MVI   OPEND,X'80'
         RDJFCB ((R4)),MF=(E,OPEND)
         MVC   $DSNAME+2(44),JFCB
         LA    R1,$DSNAME+45       LAST CHAR OF DSNAME
         LA    R0,44               INITIAL LENGTH
FILEA    CLI   0(R1),C' '          IS THIS LAST NONBLANK
         BNE   FILEB               YES, BRANCH
         BCTR  R1,0                BACK UP 1 CHARACTER
         BCT   R0,FILEA            DECREMENT LENGTH AND BRANCH
FILEB    STH   R0,$DSNAME          STORE LENGTH OF DSNAME
         MVI   DSORG,X'40'         DSORG PS
         CLI   $MEMBER,C' '        DDNAME(MEMBER)
         BE    FILEC               NO
         MVI   DSORG,X'02'         YES, INDICATE PARTITIONED
         B     FILED               DONT LOOK AT JFCB
FILEC    CLI   JFCB+44,X'40'       DDNAME ALLOCATED TO A MEMBER
         BE    *+14                NO
         MVC   $MEMBER,JFCB+44     YES, SAVE THE MEMBER NAME
         MVI   DSORG,X'02'         DSORG PO
FILED    EQU   *
*        MVC   $VOLSER(6),JFCB+118 GET VOLUME FROM JFCB
         B     FILESPEC
FILERR1  LA    R0,MSG14A
         B     FILERR
FILERR2  LA    R0,MSG14B
         B     FILERR
FILERR3  LA    R0,MSG14C
FILERR   MVC   MSG(L'MSG14),MSG14
         LA    R15,MSG+L'MSG14
         LA    R14,$DSNAME
         LH    R1,0(,R14)
         BCTR  R1,0
         B     *+10
         MVC   MSG+L'MSG14(0),2(R14)
         EX    R1,*-6
         LA    R15,1(R1,R15)
         LR    R14,R0 POINT TO MSG14A, B, OR C
         MVC   0(L'MSG14A,R15),0(R14)
         LA    R0,L'MSG14+L'MSG14A+1(,R1)
         LA    R1,MSG
         BAL   R14,PUTMSG1
         B     EXITA12
NOFILE   EQU   *
         TM    UDSNAME+2,X'40'     IS DSNAME QUOTED?
         BO    DEFX                YES - SKIP DEFAULT SERVICE
         CLI   $VOLSER,C' '        IS VOLUME SPECIFIED?
         BNE   DEFX                YES - SKIP DEFAULT SERVICE
         CLI   QUICKV+1,1          QUICK SPECIFIED
         BE    DEFX                YES, USER ENTERED ALL BUT PREFIX
         SPACE
         LA    R15,MYIOPL
         USING IOPL,R15
         LA    R14,MYDFPB
         ST    R14,IOPLIOPB
         USING DFPB,R14
         XC    0(20,R14),0(R14)
         LA    R0,$DSNAME
         ST    R0,DFPBDSN
         OI    DFPBCODE,X'04'      SEARCH CAT AND PROMPT IF MULTI
         MVC   DFPBPSCB,CPPLPSCB
*        MVI   DFPBCNTL,X'20'      PREFIX THE DSNAME
         DROP  R14                 DFPB
         SPACE
         LA    R1,MYIOPL
         SPACE
         LR    R1,R15              POINT TO IOPL
         AIF   (NOT &MVS).SKIP4
         L     R15,16              CVTPTR
         TM    736(R15),X'80'      IF HI ORDER BIT NOT ON
         BNO   EHDEFLNK               THEN DO LINK, NOT CALL
         L     R15,736(,R15)       CVTEHDEF
         BALR  R14,R15             CALL IKJEHDEF
         B     EHDEFEXT            SKIP AROUND LINK
EHDEFLNK EQU   *
.SKIP4   ANOP
         LINK  EP=IKJEHDEF,SF=(E,LINKAREA)
EHDEFEXT EQU   *
         SPACE
         B     DEFCODE(R15)
DEFCODE  B     DEF00               SUCCESS
         B     EXITA12              MSG ALREADY ISSUED
         B     DEF08               INVALID NAME GT 44
         B     EXITA12              MSG ALREADY ISUED
         B     DEF16               NOT IN CATALOG
         B     DEF20               NOT IN CATALOG
         B     DEF24               IMPOSSIBLE
         B     DEF28               COMMAND SYSTEM ERROR
         B     DEF32               IMPOSSIBLE
         B     DEF36               ?
DEF08    EQU   *
DEF16    EQU   *
         B     DEF24
DEF20    EQU   *
LOCERR   EQU   *
         MVC   MSG(L'MSG02),MSG02
         LA    R15,MSG+L'MSG02
         LA    R14,$DSNAME
         LH    R1,0(,R14)
         BCTR  R1,0
         B     *+10
         MVC   MSG+L'MSG02(0),2(R14)
         EX    R1,*-6
         LA    R15,1(R1,R15)
         MVC   0(L'MSG02A,R15),MSG02A
         LA    R0,L'MSG02+L'MSG02A+1(,R1)
         LA    R1,MSG
         BAL   R14,PUTMSG1
         B     EXITA12
DEF24    EQU   *
DEF28    EQU   *
DEF32    EQU   *
DEF36    EQU   *
         LA    R1,MSG03
         LA    R0,L'MSG03
         BAL   R14,PUTMSG1
         B     EXITA12
         SPACE
DEF00    EQU   *
DEFX     EQU   *
         SPACE
************************************************************
*                                                          *
*        ALLOCATE THE DATASET                              *
*                                                          *
************************************************************
         SPACE
         LA    R1,MYDAPL
         USING DAPL,R1
         MVC   DAPLUPT(4),CPPLUPT
         MVC   DAPLECT(4),CPPLECT
         LA    R0,MYECB
         ST    R0,DAPLECB
         MVC   DAPLPSCB(4),CPPLPSCB
         LA    R15,MYDAPB
         ST    R15,DAPLDAPB
         DROP  R1                  DAPL
         USING DAPB08,R15
         XC    0(84,R15),0(R15)
         MVI   DA08CD+1,X'08'
         LA    R0,$DSNAME
         ST    R0,DA08PDSN
         MVC   DA08DDN(8),=CL8' '
         MVC   DA08UNIT,$UNIT
         MVC   DA08SER,=CL8' '
         MVC   DA08SER(6),$VOLSER
         MVC   DA08MNM,=CL8' '     NEVER ALLOCATE WITH MEMBER
         MVC   DA08PSWD,$PASSWRD
         MVI   DA08DSP1,DA08SHR
         MVI   DA08DPS2,DA08KEEP
         MVI   DA08DPS3,DA08KEP
         LA    R1,MYDAPL
         SPACE
         BAL   R14,CALLDAIR
         LTR   R15,R15
         BZ    OKDAIR
         BAL   R14,DAIRFAIL
         B     EXITA12
OKDAIR   EQU   *
         OI    STATUS,STALLOC      TELL CLEANUP TO FREE IT
         LA    R15,MYDAPB
         MVC   $DDNAME,DA08DDN
         MVC   DSORG,DA08DSO
         TM    DA08DSO,X'40'       IS DSORG SEQUENTIAL?
         BO    OKDSORGS            YES - BRANCH
         TM    DA08DSO,X'02'       IS DSORG PARTITIONED?
         BO    OKDSORGP            YES, BRANCH
*
*              DSORG IS NEITHER PS NOR PO
*              ISAM=X'80' DA=X'20' VSAM=X'00' NONE=X'00'
*
ERRDSORG LA    R1,MSG06
         LA    R0,L'MSG06
         BAL   R14,PUTMSG1
         B     EXITA12
OKDSORGP EQU   *
         CLI   $MEMBER,C' '        WAS MEMBER SPECIFIED?
         BNE   OKDSORG             YES - BRANCH
         LA    R1,MSG07            DSORG PO BUT MEMBER NOT SPEC
         LA    R0,L'MSG07
         BAL   R14,PUTMSG1
         B     EXITA12
OKDSORGS MVC   $MEMBER,=CL8' '
OKDSORG  EQU   *
         DROP  R15                 DAPB08
FILESPEC EQU   *
         SPACE
************************************************************
*                                                          *
*         GET THE UCB ADDRESS AND VOLUME SERIAL            *
*                                                          *
************************************************************
         SPACE
         L     R1,16               CVTPTR
         L     R1,0(,R1)           TCB WORDS
         L     R1,4(,R1)           CURRENT TCB
         L     R1,12(,R1)          TIOT
         LA    R1,24(,R1)          TIOENTRY
DDLOOP   CLI   0(R1),0             END OF TIOT
         BE    EXITA12             YES, BRANCH (NEVER HAPPENS)
         CLC   4(8,R1),$DDNAME     DOES DDNAME MATCH
         BE    DDFOUND
         SLR   R15,R15
         IC    R15,0(,R1)
         LA    R1,0(R15,R1)
         B     DDLOOP
DDFOUND  L     R15,16(,R1)         TIOEFSRT-1
         ST    R15,$UCBAD
         TM    18(R15),X'20'       DIRECT ACCESS DEVICE?
         BZ    *+10                NO, BYPASS VOLSER
         MVC   $VOLSER,28(R15)     UCBVOLI
         SPACE
************************************************************
*                                                          *
*         OBTAIN THE DSCB FROM THE VTOC                    *
*                                                          *
************************************************************
         SPACE
         CLI   FILEKV+1,1          'FILE' SPECIFIED?
         BNE   OBTX                NO, BYPASS OBTAIN
         L     R15,$UCBAD          POINT TO UCB
         TM    18(R15),X'20'       DIRECT ACCESS DEVICE?
         BZ    OBTX                NO, BYPASS OBTAIN
OBTDSCB  LA    R1,OBTAINW
         MVC   0(OBTAINL,R1),OBTAIN
         LA    R0,$DSNAME+2        DSN FOR OBTAIN
         ST    R0,4(,R1)
         LA    R0,$VOLSER          VOLUME FOR OBTAIN
         ST    R0,8(,R1)
         LA    R0,MYDSCB           ANSWER AREA FOR OBTAIN
         ST    R0,12(,R1)
         OBTAIN (1)
         LTR   R15,R15             WAS OBTAIN SUCCESSFUL
         BZ    OKDSCB              YES, BRANCH
         SPACE
*               OBTAIN HAS FAILED. HOW CAN THAT HAPPEN WHEN
*               DYNAMIC ALLOCATION WAS SUCCESSFUL? ONE WAY IT
*               CAN HAPPEN IS IF THE DSNAME IS AN ALIAS ENTRY
*               IN A VSAM CATALOG.  IF IT IS, A 'LOCATE' WILL
*               PUT THE TRUE NAME IN THE DSNAME FIELD, SO NOW
*               WE ISSUE A LOCATE, AND TRY THE OBTAIN AGAIN.
         SPACE
         TM    STATUS,STLOCAT      HAS LOCATE BEEN TRIED ALREADY?
         BZ    OBTALIAS            NO, GO TRY IT
OBTERR   LA    R1,MSG09            UNABLE TO OBTAIN DSCB
         LA    R0,L'MSG09
         BAL   R14,PUTMSG1
         B     EXITA12
OBTALIAS OI    STATUS,STLOCAT      TRIP THE SWITCH
         LA    R1,LOCATEW
         MVC   0(LOCATEL,R1),LOCATE
         LA    R0,$DSNAME+2        DSNAME FOR LOCATE
         ST    R0,4(,R1)
         LA    R0,LOCBUF           ANSWER AREA FOR LOCATE
         ST    R0,12(,R1)
         LOCATE (1)
         LTR   15,15               WAS LOCATE SUCCESSFUL?
         BZ    OBTDSCB             YES, GO OBTAIN AGAIN
         B     OBTERR              NO, ISSUE MESSAGE
         SPACE
OKDSCB   NI    STATUS,255-STLOCAT  TURN OFF LOCATE SWITCH
*        CLC   MYDSCB-44+X'62'(3),=X'000000' CHECK DS1LSTAR
*        BE    EMPTY               BRANCH IF EMPTY DATA SET
         MVC   DSORG,MYDSCB-44+X'52'
         TM    DSORG,X'40'         DSORG = PS
         BO    OBTX
         TM    DSORG,X'02'         DSORG = PO
         BNO   ERRDSORG
         CLI   $MEMBER,C' '        WAS MEMBER SPECIFIED?
         BNE   OBTX                YES - BRANCH
         LA    R1,MSG07            DSORG PO BUT MEMBER NOT SPEC
         LA    R0,L'MSG07
         BAL   R14,PUTMSG1
         B     EXITA12
OBTX     EQU   *
         SPACE
************************************************************
*                                                          *
*         CALL PHASE 2 FOR MAIN PROCESSING                 *
*                                                          *
************************************************************
         SPACE
         L     R15,=A(REVIEW2)     GET ADDRESS OF PHASE 2
         BALR  R14,R15             GO TO PHASE 2
         B     EXITARC             PHASE 2 HAS SET RC
         SPACE
************************************************************
*                                                          *
*         RETURN FROM PHASE 2 TO TERMINATE                 *
*                                                          *
************************************************************
         SPACE
EXITA12  LA    R15,12
         STH   R15,RC
EXITARC  TM    STATUS,STALLOC      FREE REQUIRED?
         BZ    NOFREE
         LA    R1,MYDAPL
         LA    R15,MYDAPB
         USING DAPB18,R15
         XC    0(40,R15),0(R15)
         MVI   DA18CD+1,X'18'
         MVC   DA18DDN,$DDNAME
         MVC   DA18MNM(8),=CL8' '
         MVC   DA18SCLS(2),=CL8' '
         BAL   R14,CALLDAIR        UNALLOCATE
         NI    STATUS,255-STALLOC  UNALLOCATED
         DROP  R15                 DAPB18
NOFREE   EQU   *
         SPACE
         IKJRLSA MYANS
         SPACE
         CLI   RC+1,0              IS RC ZERO?
         BZ    STACKDX             YES, BRANCH
         MVC   MYSTPB(STACKDL),STACKD
         SPACE
         STACK DELETE=ALL,PARM=MYSTPB,MF=(E,MYIOPL)
         SPACE
         TCLEARQ
STACKDX  EQU   *
         SPACE
         LH    R15,RC
         B     EXIT
         SPACE
************************************************************
*                                                          *
*         EXIT TO CALLER                                   *
*                                                          *
************************************************************
         SPACE
ERRRECFM LA    R1,MSGRECFM
         LA    R0,L'MSGRECFM
         BAL   R14,PUTMSG1
         B     EXITA12
         SPACE
ERRTERM  LA    R1,MSGTERM
         LA    R0,L'MSGTERM
         BAL   R14,PUTMSG1
         B     EXITA12
         SPACE
EXIT     LR    R1,R13
         L     R0,SIZE
         L     R13,4(,R13)
         LR    R2,R15
         FREEMAIN R,A=(1),LV=(0)
         LR    R15,R2
         LM    0,12,20(R13)
         L     R14,12(,R13)
         BR    R14
         SPACE
************************************************************
*                                                          *
*         CALL IKJDAIR SERVICE ROUTINE                     *
*                                                          *
************************************************************
          SPACE
CALLDAIR ST    R14,DAIRREGS
         AIF   (NOT &MVS).SKIP6
         L     R15,16
         TM    732(R15),X'80'     CVTDAIR
         BNO   DAIRLINK
         L     R15,732(,R15)
         BALR  R14,R15
         B     DAIRFINI
DAIRLINK EQU   *
.SKIP6   ANOP
         LINK  EP=IKJDAIR,SF=(E,LINKAREA)
DAIRFINI L     R14,DAIRREGS
         BR    R14
         SPACE
************************************************************
*                                                          *
*        DYNAMIC ALLOCATION FAILURE ROUTINE                *
*                                                          *
************************************************************
         SPACE
DAIRFAIL ST    R14,MYDFREGS
         LA    R1,MYDFPARM
*        USING DFDSECTD,R1         MAPPED BY IKJEFFDF DFDSECT=YES MACRO
         ST    R15,MYDFRC
         LA    R15,MYDFRC
         ST    R15,4(,R1)          DFRCP
         LA    R15,MYDAPL
         ST    R15,0(,R1)          DFDAPLP
         SLR   R15,R15
         ST    R15,MYJEFF02
         LA    R15,MYJEFF02
         ST    R15,8(,R1)          DFJEFF02
         LA    R15,1               DFDAIR
         STH   R15,MYDFID
         LA    R15,MYDFID
         ST    R15,12(,R1)         DFIDP
         MVC   16(4,R1),CPPLPTR    DFCPPLP
         LINK  EP=IKJEFF18,SF=(E,LINKAREA)
*        DROP  R1                  DFDSECTD
         L     R15,MYDFRC
         L     R14,MYDFREGS
         BR    R14
         SPACE
************************************************************
*                                                          *
*         PHASE 1 INTERFACES TO PHASE 2                    *
*                                                          *
************************************************************
         SPACE
PUTMSG1  ST    R14,BASE1+12
         L     R15,=A(PUTMSG)
         LM    R10,R12,BASE2       SWITCH BASE REGS
         BALR  R14,R15
         LM    R10,R12,BASE1       RESTORE BASE REGS
         L     R14,BASE1+12
         BR    R14
         SPACE
************************************************************
*                                                          *
*         PHASE 1 CONSTANTS                                *
*                                                          *
************************************************************
         SPACE
         LTORG
PFKDEF   DC    0D'0'               INITIAL VALUES OF PF KEYS
         DC    X'F1',CL15'TOP '    1
         DC    X'F2',CL15'BOTTOM ' 2
         DC    X'F3',CL15'END '    3
         DC    X'F4',CL15' '       4
         DC    X'F5',CL15'FIND '   5
         DC    X'F6',CL15' '       6
         DC    X'F7',CL15'UP '     7
         DC    X'F8',CL15'DOWN '   8
         DC    X'F9',CL15'HEX '    9
         DC    X'7A',CL15'LEFT '   10
         DC    X'7B',CL15'RIGHT '  11
         DC    X'7C',CL15' '       12
PFKDEFL  EQU   16                  LENGTH OF EACH DEFAULT ENTRY
         SPACE
OBTAIN   CAMLST SEARCH,2,3,4
OBTAINL  EQU   *-OBTAIN
         SPACE
LOCATE   CAMLST NAME,2,,4
LOCATEL  EQU   *-LOCATE
         SPACE
MSG01    DC    C'ERROR IN PARSE SERVICE ROUTINE'
MSG02    DC    C'IKJ58503I DATA SET '
MSG02A   DC    C' NOT IN CATALOG'
MSG03    DC    C'ERROR IN DEFAULT SERVICE ROUTINE'
MSG05    DC    C'IKJ58509I DATA SET NAME REQUIRED WHEN MEMBER IS SPECIF+
               IED'
MSG06    DC    C'ORGANIZATION OF DATA SET MUST BE PARTITIONED OR SEQUEN+
               TIAL'
MSG07    DC    C'DATA SET IS PARTITIONED, MEMBER NOT SPECIFIED'
MSG09    DC    C'UNABLE TO OBTAIN DSCB FOR DATA SET'
MSG14    DC    C'FILENAME '
MSG14A   DC    C' INVALID, MORE THAN 8 CHARACTERS  '
MSG14B   DC    C' IS NOT CURRENTLY ALLOCATED       '
MSG14C   DC    C' NOT ALLOCATED TO A DASD DATA SET '
MSGRECFM DC    C'RECORD FORMAT U NOT SUPPORTED'
MSGTERM  DC    C'TERMINAL IS NOT A 3270 DISPLAY WITH 24 LINES'
STACKD   STACK DELETE=ALL,MF=L
STACKDL  EQU   *-STACKD
         SPACE
*                   DC    (((*-C-1)/N)*N+N+C-*)X'00'
*                 WHERE N IS BOUNDARY (I.E. 256, 4096, ...)
*                 AND C IS THE BEGINNING OF THE CSECT.
         DC    (((*-CSECT1-1)/256)*256+256+CSECT1-*)X'00'
         DC    0D'0'
         EJECT
************************************************************
*                                                          *
*         PHASE 2 INITIALIZATION                           *
*                                                          *
************************************************************
         SPACE
*
*         FROM THIS POINT ON, PROCESSING IS THE SAME
*         FOR BOTH DSNAME AND DDNAME OPTIONS.
*
*         $DSNAME  - CONTAINS THE FULLY QUALIFIED DSNAME,
*                    FROM THE USER OR FROM THE JFCB.
*         $MEMBER  - CONTAINS THE MEMBER NAME, IF SPECIFIED,
*                    FROM THE USER OR FROM THE JFCB.
*         $DDNAME  - CONTAINS THE DDNAME, FROM IKJDAIR OR
*                    FROM THE USER.
*         $UCBAD   - CONTAINS THE UCB ADDRESS,
*                    FROM THE TIOT ENTRY.
*         $VOLSER  - CONTAINS THE VOLUME, FROM THE UCB POINTED
*                    TO BY THE TIOT ENTRY.
*
*         IF THE USER SPECIFIED A DSNAME (DID NOT SPECIFY THE FILE
*         KEYWORD) THEN THE STALLOC BIT IS SET ON SO THE DDNAME
*         WILL BE UNALLOCATED WHEN THE COMMAND IS FINISHED WITH IT.
*
REVIEW2  CSECT
         USING *,R10,R11,R12
         LR    R10,R15             RESET BASE REGISTER
         LA    R15,1
         LA    R11,4095(R15,R10)   BASE
         LA    R12,4095(R15,R11)   BASE
         ST    R14,RET1
         SPACE
************************************************************
*                                                          *
*        SET UP THE DCB                                    *
*                                                          *
************************************************************
         SPACE
         MVC   DYNDCBW(SEQDCBL),SEQDCB
         TM    DSORG,X'02'
         BZ    *+10
         MVC   DYNDCBW(PDSDCBL),PDSDCB
         LA    R4,DYNDCBW
         USING IHADCB,R4
         MVC   DCBDDNAM(8),$DDNAME
         SPACE
         LA    R15,DYNEOD
         IC    R0,DCBEODAD-1
         ST    R15,DCBEODAD-1
         STC   R0,DCBEODAD-1
         SPACE
         LA    R15,DYNSYNAD
         IC    R0,DCBSYNAD-1
         ST    R15,DCBSYNAD-1
         STC   R0,DCBSYNAD-1
         SPACE
         LA    R15,DYNEXLST
         IC    R0,DCBEXLSA-1
         ST    R15,DCBEXLSA-1
         STC   R0,DCBEXLSA-1
         LA    R1,DYNDCBEX
         ST    R1,0(,R15)
         MVI   0(R15),X'05'
         LA    R1,DYNABEND
         ST    R1,4(,R15)
         MVI   4(R15),128+X'11'    OPEN ABEND EXIT (MVS)
         SPACE
         OI    STATUS,STOPEN       TELL CLEANUP TO CLOSE DCB
         MVI   OPEND,X'80'
         SPACE
         OPEN  ((R4),INPUT),MF=(E,OPEND)
         SPACE
         TM    DCBOFLGS,X'10'
         BO    OKOPEN
         LA    R1,MSG08
         LA    R0,L'MSG08
         TM    STATUS,STABEND      MEMBER NOT FOUND?
         BO    DYNOPENM            YES, BRANCH
         LA    R1,MSG04
         LA    R0,L'MSG04
DYNOPENM BAL   R14,PUTMSG
         B     EXIT12
         SPACE
DYNDCBEX EQU   *
*              TESTING THE RECFM FOR RECFM V OR F
*              REQUIRES AT LEAST 2 TESTS BECAUSE BOTH THE
*              V AND F BITS ARE ON WHEN RECFM IS U.
*              THIS ROUTINE MAKES A COPY OF THE RECFM BITS
*              AND ZEROES BOTH THE V AND F BITS IN THE COPY
*              IF THE RECFM IS U.  NOW WE CAN DETERMINE
*              RECFM V OR F IN ONE TEST INSTEAD OF TWO.
         MVC   TSTRECFM,DCBRECFM   COPY RECFM
         TM    DCBRECFM,X'C0'      RECFM U
         BNOR  R14                 NO, BRANCH
         NI    TSTRECFM,255-X'C0'  YES, SET BOTH BITS OFF
         BR    R14
         SPACE
DYNABEND EQU   *
         L     R8,0(,R1)           GET COMPLETION CODE
         N     R8,=A(X'FFF0FF00')
         CL    R8,=A(X'01301800')  IS IT AN 013-18 ABEND
         BE    *+10                YES, BRANCH
         MVI   4(R1),0             ABNORMALLY TERMINATE
         BR    R14
         OI    STATUS,STABEND      INDICATE MEMBER NOT FOUND
         MVI   3(R1),4             IGNORE THE ABEND
         BR    R14
         SPACE
OKOPEN   EQU   *
         MVC   DYNDECBW(DYNDECBL),DYNDECB
         SPACE
************************************************************
*                                                          *
*        SET UP THE BUFFER AREA                            *
*                                                          *
************************************************************
         SPACE
         LH    R0,DCBBLKSI
         AH    R0,=H'7'            ROUND
         N     R0,=A(X'FFFFFFF8')   UPWARDS TO MULTIPLE OF 8
         ST    R0,SAVBLKSI         SAVE FOR PARTITIONING
         SPACE
         SLR   R0,R0
         TM    TSTRECFM,X'48'      VS OR VBS
         BNO   NOTSPAN             NO, BRANCH
         LH    R0,DCBLRECL         YES, GET LRECL
         AH    R0,=H'7'            ROUND
         N     R0,=A(X'FFFFFFF8')   UPWARDS TO MULTIPLE OF 8
         LTR   R0,R0               WAS LRECL ZERO
         BNZ   *+8                 NO, SKIP NEXT INSTR
         L     R0,SAVBLKSI         YES, USE BLKSIZE ROUNDED
         A     R0,=A(2048)         ADD 2K IN CASE LRECL IS WRONG
NOTSPAN  ST    R0,SAVSPANL         SAVE FOR PARTITIONING
         SPACE
         LH    R0,DCBLRECL
         LTR   R0,R0
         BNZ   *+8
         LH    R0,DCBBLKSI
         STH   R0,RECSIZE
         AH    R0,=H'7'            ROUND
         N     R0,=A(X'FFFFFFF8')   UPWARDS TO MULTIPLE OF 8
         CH    R0,=H'1000'         IS LRECL GREATER THAN MAX
         BNH   *+8                 NO, SKIP NEXT INSTR
         LH    R0,=H'1000'         YES, HELD RECORDS MUST BE TRUNCATED
         ST    R0,SAVLRECL         SAVE FOR HOLD AREA DIVISION
         MH    R0,PAGESIZE
         ST    R0,SAVHOLDL         SAVE FOR PARTITIONING
         SPACE
         A     R0,SAVSPANL         COMBINE LENGTHS FOR GETMAIN
         A     R0,SAVBLKSI         COMBINE LENGTHS FOR GETMAIN
         A     R0,=A(20*200)       PLUS ROOM FOR 200 CHECKPOINTS
         LA    R7,RANGE
         ST    R0,0(,R7)
         A     R0,=A(20*824)       OPTIONAL ROOM FOR 1024 CHECKPOINTS
*        L     R0,=A(16*1024*1024-8) 16 MEG
         ST    R0,4(,R7)
         LA    R8,ANSWER
         MVC   GMVUW(GMVUL),GMVU
         GETMAIN VU,LA=(R7),A=(R8),MF=(E,GMVUW)
         OI    STATUS,STGMVU
*        L     R0,ANSWER+4         LENGTH
*        L     R1,ANSWER           ADDRESS
*        FREEMAIN R,LV=(0),A=(1)
         L     R1,ANSWER
         LR    R0,R1
         A     R0,ANSWER+4
         ST    R0,ENDPTR           END OF GETMAINED AREA
         ST    R1,BLOCKPTR
         A     R1,SAVBLKSI         POINT PAST BLOCK AREA
         ST    R1,SPANPTR
         A     R1,SAVSPANL         POINT PAST SPANNED RECORD AREA
         ST    R1,HOLDPTR
         A     R1,SAVHOLDL         POINT PAST HOLD AREA
         ST    R1,CHKPTTOP
         XC    0(16,R1),0(R1)      FIRST ENTRY IN TABLE
         XC    DEBLOCKS(12),DEBLOCKS
         XC    OFFSET,OFFSET
         LH    R0,PAGESIZE         LINES PER PAGE
         ST    R0,SCROLL
         SLR   R0,R0
         ST    R0,FNDNUM
         STH   R0,FNDOFF
         ST    R0,CHKPTBOT
         MVC   PERIODS,CAPST
         SPACE
************************************************************
*                                                          *
*         INITIALIZE HOLD AREA DIRECTORY                   *
*                                                          *
************************************************************
         SPACE
         LA    R7,HOLDDIR
         SLR   R0,R0
         L     R15,HOLDPTR
         TM    TSTRECFM,X'40'      RECFM V
         BZ    *+8                 NO
         LA    R15,4(,R15)         YES, POINT 4 BYTES INTO EACH RECORD
         LH    R8,PAGESIZE         LINES PER PAGE
HOLDINIT ST    R0,DIRNUM(,R7)      PUT ZERO IN RECORD LENGTH
         ST    R0,DIRLEN(,R7)      PUT ZERO IN RECORD NUMBER
         ST    R15,DIRREC(,R7)     STORE ADDRESS OF HELD RECORD
         A     R15,SAVLRECL        POINT TO NEXT HELD RECORD
         LA    R1,DIRSIZ(,R7)      POINT TO NEXT ENTRY
         ST    R1,DIRNXT(,R7)      STORE ITS ADDRESS IN THIS ENTRY
         LR    R14,R7              SAVE LAST ENTRY
         LR    R7,R1               MAKE NEXT ENTRY THIS ENTRY
         BCT   R8,HOLDINIT         DO IT FOR ALL BUT LAST ENTRY
         LA    R1,HOLDDIR          ADDRESS OF FIRST ENTRY
         ST    R1,DIRNXT(,R14)     CLOSE THE CIRCLE
         ST    R1,HOLDTOP          START WITH FIRST AS TOP
         SPACE
************************************************************
*                                                          *
*         POINT TO MEMBER                                  *
*                                                          *
************************************************************
         SPACE
         MVC   DSNAIM(46),$DSNAME
         TM    DSORG,X'02'         IS THIS A PDS
         BZ    NOBLDL              NO, SKIP MEMBER PROCESS
         MVC   BLDL(4),=AL2(1,76)
         MVC   BLDL+4(8),$MEMBER
         BLDL  (R4),BLDL
         LTR   R15,R15             WAS BLDL SUCCESSFUL
         BNZ   NOMEM               NO, BRANCH
         MVC   TTR,BLDL+12
         MVC   TTRK,BLDL+12
         FIND  (R4),TTRK,C
*        POINT (R4),TTR
         SLR   R15,R15
         IC    R15,TTR+3           GET CONCATENATION NUMBER
         LTR   R15,R15
         BZ    NOCONCAT
         CVD   R15,DOUBLE          APPEND
         OI    DOUBLE+7,X'0F'       CONCAT
         LH    R15,$DDNAML           NUMBER
         SH    R15,=H'4'              TO DDNAME
         LA    R15,$DDNAME(R15)         SO IT
         UNPK  1(3,R15),DOUBLE+6(2)      BECOMES
         MVI   0(R15),C'+'                DDNAME+NNN
         MVC   DSNAIM(14),$DDNAML  SHOW DDNAME INSTEAD OF DSNAME
NOCONCAT EQU   *
NOBLDL   EQU   *
         B     NEWNAME
NOMEM    MVC   MSG(MSG36L),MSG36   MEMBER NOT FOUND
         CH    R15,=H'4'
         BE    *+10
         MVC   MSG(MSG37L),MSG37   BLDL FAILED
         OI    STATUS,STNOMEM
         MVC   $MEMBER,=CL8'* '
         SPACE
************************************************************
*                                                          *
*         BUILD DATA SET NAME FOR TOP LINE                 *
*                                                          *
************************************************************
         SPACE
NEWNAME  MVC   DSPLUS(46),DSNAIM
         CLI   $MEMBER,C' '
         BE    DSPLUSX
         LA    R1,$MEMBER
         LA    R0,8
         LA    R15,DSPLUS+2
         AH    R15,DSNAIM
         MVI   0(R15),C'('
         LA    R15,1(,R15)
DSPMEM   CLI   0(R1),C' '
         BE    DSPMEMX
         MVC   0(1,R15),0(R1)
         LA    R15,1(,R15)
         LA    R1,1(,R1)
         BCT   R0,DSPMEM
DSPMEMX  MVI   0(R15),C')'
         LA    R1,DSPLUS+1
         SR    R15,R1
         STH   R15,DSPLUS
DSPLUSX  EQU   *
         MVC   SCREENW(SCREENL),SCREEN
*        MVC   SCREENW(256),SCREEN
*        MVC   SCREENW+256(SCREENL-256),SCREEN+256
         LA    R1,SCREENW
         LA    R15,SCRDSN-SCREEN(R1)
         LR    R0,R15
         LH    R1,DSPLUS
         BCTR  R1,0
         B     *+10
         MVC   0(0,R15),DSPLUS+2
         EX    R1,*-6
         LA    R15,1(R1,R15)
         MVI   0(R15),C' '
         LR    R15,R0
         MVC   MSGDSN,0(R15)
         SPACE
         BAL   R14,FILLHOLD
         B     FILLSCR
         SPACE
************************************************************
*                                                          *
*         READ ENOUGH RECORDS TO FILL HOLD AREA            *
*                                                          *
************************************************************
         SPACE
FILLHOLD ST    R14,HOLDR
         L     R6,HOLDPTR
         LR    R0,R6
         L     R1,SAVHOLDL
         SLR   R14,R14
         L     R15,=A(X'40000000')
         MVCL  R0,R14              FILL HOLD AREA WITH BLANKS
         L     R7,HOLDTOP          POINT TO HOLD AREA DIRECTORY
         LH    R8,PAGESIZE         NUMBER OF DATA LINES PER SCREEN
HILLOOP  EQU   *
         BAL   R14,GET
         LA    R0,1                COMPUTE
         A     R0,COUNT             THE
         ST    R0,COUNT              RECORD NUMBER
         ST    R0,DIRNUM(,R7)      STORE THE RECORD NUMBER
         ST    R1,DIRLEN(,R7)      LENGTH IN DIRECTORY
         LTR   R1,R1               END OF FILE
         BM    HILLED              YES BRANCH
         C     R1,SAVLRECL         IS RECORD LONGER THAN MAX
         BNH   *+8                 NO, SKIP NEXT INSTR
         L     R1,SAVLRECL         YES, TRUNCATE TO MAX
         LR    R0,R2               ADDRESS TO MOVE FROM
         L     R14,DIRREC(,R7)     ADDRESS TO MOVE TO
         TM    TSTRECFM,X'40'      RECFM V
         BZ    HILLNOTV            NO
         SH    R14,=H'4'           YES, MOVE TO PTR MINUS 4
         L     R15,DIRLEN(,R7)
         SH    R15,=H'4'
         ST    R15,DIRLEN(,R7)
HILLNOTV LR    R15,R1              LENGTH FOR MOVE
         MVCL  R14,R0
         LR    R1,R7               SAVE PTR TO MOST CURRENT ENTRY
         L     R7,DIRNXT(,R7)      POINT TO NEXT DIRECTORY ENTRY
         BCT   R8,HILLOOP
         LR    R7,R1               GET MOST CURRENT ENTRY
HILLED   EQU   *
         ST    R7,HOLDEND          SAVE LAST RECORD ENTRY
         L     R14,HOLDR
         BR    R14
         SPACE
************************************************************
*                                                          *
*         SET UP THE SCREEN HEADER PRIOR TO DISPLAY        *
*                                                          *
************************************************************
         SPACE
FILLSCR  LA    R1,SCREENW
         LA    R15,SCRCOL-SCREEN(,R1)
         MVC   0(8,R15),=CL8' '
         LH    R1,OFFSET
         LA    R1,1(,R1)
         LA    R0,79(,R1)
         TM    MODE,MODEX
         BZ    *+8
         SH    R0,=H'40'
         CH    R0,RECSIZE
         BNH   *+8
         LH    R0,RECSIZE
         CVD   R1,DOUBLE
         OI    DOUBLE+7,X'0F'
         CH    R1,=H'1000'
         BL    FILL3DIG
         UNPK  0(4,R15),DOUBLE+5(3)
         CVD   R0,DOUBLE
         OI    DOUBLE+7,X'0F'
         UNPK  5(3,R15),DOUBLE+6(2)
         B     FILLCOLX
FILL3DIG UNPK  0(3,R15),DOUBLE+6(2)
         CVD   R0,DOUBLE
         OI    DOUBLE+7,X'0F'
         UNPK  4(3,R15),DOUBLE+6(2)
FILLCOLX EQU   *
         SPACE
************************************************************
*                                                          *
*         SET UP THE COLUMN HEADER PRIOR TO DISPLAY        *
*                                                          *
************************************************************
         SPACE
*               IT WOULD BE MORE EFFICIENT TO DO MOST OF THIS WORK
*               ONLY WHEN THE OFFSET IS INITIALIZED OR CHANGED
*               AND SAVE THE RESULTS.
         SPACE
         LA    R1,SCREENW
         LA    R6,SCRDATA-SCREEN(,R1)
         MVI   0(R6),C' '
         MVC   1(79,R6),0(R6)
         LH    R1,OFFSET
         LTR   R1,R1               IS OFFSET ZERO
         BNZ   *+8                 NO
         MVI   0(R6),C'1'          YES, SPECIAL CASE, 1
         SR    R0,R0
         LA    R14,10
         DR    R0,R14
         SR    R14,R0              10 MINUS REMAINDER
         LTR   R0,R0               WAS REMAINDER 0
         BZ    *+6                 YES, USE 0, NOT 10
         LR    R0,R14
*
         LR    R14,R6
         AR    R14,R0              ADD (0 TO 9) TO LINE
         BCTR  R14,0               START AT LINE-1 FOR OFFSET 0
*                                  LINE+8 FOR OFFSET 1
*                                  LINE+7 FOR OFFSET 2
*                                  LINE+6 FOR OFFSET 3
*                                  LINE+0 FOR OFFSET 9
         LH    R1,OFFSET
         AR    R1,R0               ADD (0 TO 9) TO OFFSET
         LA    R0,9
COLNUML  CH    R1,RECSIZE
         BH    COLNUMX
         CVD   R1,DOUBLE
         MVC   COLNUM,=X'402020202120'
         ED    COLNUM,DOUBLE+5
         CH    R1,=H'10000'        10000-32768
         BNL   COLNUMN             YES, USE NNNNN
*        MVC   COLNUM(5),COLNUM+1
*        MVI   COLNUM+5,C' '
*        CH    R1,=H'1000'         1000-9999
*        BNL   COLNUMN             YES, USE NNNNX
         MVC   COLNUM(5),COLNUM+1
         MVI   COLNUM+5,C' '
         CH    R1,=H'100'          100-999
         BNL   COLNUMN             YES, USE XNNNX
         MVC   COLNUM(5),COLNUM+1  USE XNNXX
         MVI   COLNUM+5,C' '
COLNUMN  EQU   *
         SH    R14,=H'2'
         CR    R14,R6
         BL    *+10
         MVC   0(5,R14),COLNUM+1
         LA    R14,12(,R14)
         AH    R1,=H'10'
         BCT   R0,COLNUML
COLNUMX  EQU   *
*
         LH    R1,OFFSET
         SR    R0,R0
         LA    R14,10
         DR    R0,R14
         LR    R1,R0
         LA    R14,MARKS(R1)
         LH    R1,RECSIZE
         SH    R1,OFFSET
         CH    R1,=H'80'
         BL    MARKE
         MVC   80(80,R6),0(R14)
         B     MARKX
MARKE    MVI   80(R6),C' '
         MVC   81(79,R6),80(R6)
         BCTR  R1,0
         B     *+10
         MVC   80(00,R6),0(R14)
         EX    R1,*-6
MARKX    EQU   *
         LH    R1,OFFSET
         LTR   R1,R1               IS OFFSET ZERO
         BNZ   *+8                 NO
         MVI   80(R6),C'+'         YES, SPECIAL CASE
         LA    R6,160(,R6)
         SPACE
************************************************************
*                                                          *
*         FILL IN THE DATA AREA OF THE SCREEN              *
*                                                          *
************************************************************
         SPACE
         SR    R5,R5
*        LR    R0,R6
*        L     R1,=A(80*PAGE)
*        SLR   R14,R14
*        L     R15,=A(X'40000000')
*        MVCL  R0,R14              FILL DATA AREA WITH BLANKS
         L     R7,HOLDTOP
         LA    R1,SCREENW
         LA    R15,SCRLINE-SCREEN(,R1)
         L     R1,DIRNUM(,R7)      GET NUMBER OF FIRST LINE
         CVD   R1,DOUBLE
         OI    DOUBLE+7,X'0F'
         UNPK  0(5,R15),DOUBLE+5(3)
         LH    R8,PAGESIZE         NUMBER OF DATA LINES
FILLOOP  EQU   *
         LM    R1,R2,DIRLEN(R7)    GET LENGTH AND ADDRESS
         LTR   R1,R1
         BM    FILBOT
         MVI   0(R6),C' '
         MVC   1(79,R6),0(R6)      FILL LINE WITH BLANKS
         BZ    FILNUL              BRANCH IF R1 ZERO
         TM    SMFSW,SMFBIT        IS SMF FORMATTING ON
         BO    CALLSMF             YES, BRANCH
         SH    R1,OFFSET           IS OFFSET BEYOND END OF RECORD
         BNP   FILLNEXT            YES, LEAVE LINE BLANK
         AH    R2,OFFSET
         TM    MODE,MODEX
         BO    FILLHEX
         CH    R1,=H'80'
         BNH   *+8
         LA    R1,80
         BCTR  R1,0
         B     *+10
         MVC   0(0,R6),0(R2)
         EX    R1,*-6
         TR    0(80,R6),PERIODS
         B     FILLNEXT
FILLHEX  CH    R1,=H'40'
         BNH   *+8
         LA    R1,40
         LR    R0,R1
         LR    R1,R2
         LR    R15,R6
         BAL   R14,HEX
         B     FILLNEXT
FILNUL   MVC   0(6,R6),=C'(NULL)'
         B     FILLNEXT
CALLSMF  STM   R1,R2,CALLPARM
         ST    R6,CALLPARM+8
         LA    R0,CALLSAVE
         ST    R0,CALLPARM+12
         OI    CALLPARM+12,X'80'
         LA    R1,CALLPARM
         L     R15,CALLSMFA
         BALR  R14,R15
         TR    0(80,R6),PERIODS
FILLNEXT LA    R5,01(,R5)          COUNT LINES FILLED IN
         LA    R6,80(,R6)
         L     R7,DIRNXT(,R7)
         BCT   R8,FILLOOP
         B     FILLED
FILBOT   MVI   0(R6),C'*'
         MVC   1(79,R6),0(R6)
         MVC   32(16,R6),=C' BOTTOM OF DATA '
         LA    R6,80(,R6)
         LA    R5,01(,R5)          COUNT LINES FILLED IN
FILLED   EQU   *
         CH    R5,PAGESIZE         IS SCREEN FILLED UP
         BNL   NOPAD
         MVC   0(4,R6),SCRPAD      FILL REMAINING LINES WITH BLANKS
         LA    R6,4(,R6)
NOPAD    MVC   0(4,R6),SCRSUF      SET CURSOR ADDRESS
         LA    R6,4(,R6)
         ST    R6,SCREENF          STORE END-OF-SCREEN FOR TPUT
         SPACE
PROMPT   LA    R1,SCREENW
         LA    R15,SCRDSN-SCREEN(R1)
         LH    R1,MSG              GET LENGTH OF MESSAGE
         LTR   R1,R1               IS THERE A MESSAGE
         BNZ   PROMPTM             YES, BRANCH
         MVC   0(55,R15),MSGDSN    NO, DISPLAY DSNAME
         B     PROMPTT
PROMPTMV MVC   0(0,R15),MSG+2
PROMPTM  CH    R1,=H'55'           MSG TOO LONG
         BNH   *+8                 NO
         LA    R1,55               YES, TRUNCATE IT
         MVI   0(R15),C'-'
         MVC   1(54,R15),0(R15)
         BCTR  R1,0                LENGTH-1 FOR EX
         EX    R1,PROMPTMV
         LA    R15,1(R1,R15)
         MVI   0(R15),C' '
         XC    MSG(2),MSG          SET OFF MESSAGE FLAG
PROMPTT  LA    R1,SCREENW
         L     R0,SCREENF
         SR    R0,R1               COMPUTE SIZE OF SCREEN
         O     R1,=A(X'03000000')
         SVC   93                  TPUT
         SPACE
************************************************************
*                                                          *
*         READ REPLY FROM THE TERMINAL                     *
*                                                          *
************************************************************
         SPACE
         XC    REPLY(256),REPLY    TO SIMPLIFY DEBUGGING
         LA    R1,REPLY
         LA    R0,256
         O     R1,=A(X'81000000')
         SVC   93                  TGET
         STM   R15,R1,TGETREGS
         CH    R15,=H'12'          WAS REPLY AREA LONG ENOUGH
         BNE   TGETOK              YES, BRANCH
         TCLEARQ INPUT
TGETOK   LA    R15,REPLY
*               REPLY AREA CONTENTS:
*               OFFSET 0 LENGTH 1  -  ID OF KEY
*               OFFSET 1 LENGTH 2  -  ADDRESS OF CURSOR
*               OFFSET 3 LENGTH 1  -  X'11' IF ANY FIELDS MODIFIED
*               OFFSET 4 LENGTH 2  -  SCREEN ADDRESS OF FIELD
*               OFFSET 6 LENGTH V  -  DATA FROM FIELD
*               DATA EXTENDS TO END OF BUFFER OR NEXT X'11'
         OI    REPLY,X'30'         MAKE PFK 13-24 LOOK LIKE 1-12
         CLI   REPLY,X'F3'         PFK 3
         BE    END
*        CLI   REPLY,X'7D'         ENTER
*        BNE   PFK
         L     R14,TGETREGS+8      GET LENGTH OF REPLY
         CH    R14,=H'3'           ANYTHING BEYOND CURSOR ADDRESS
         BNH   CMDNULL             NO, BRANCH
         CLI   3(R15),X'11'        SBA (SHOULD ALWAYS BE PRESENT)
         BNE   CMDNULL             NO
*
*               PROCESS FIELDS IN TGET BUFFER
*
         SLR   R0,R0
         ST    R0,CMDPTR           START WITH COMMAND-NOT-PRESENT
         BCTR  R14,0               LENGTH-1 FOR EX
         B     *+10
TRTSBA   TRT   0(0,R15),FINDSBA
         EX    R14,*-6
         BZ    CMDNULL             NO FIELDS PRESENT
         LR    R0,R1               ADDRESS OF SBA
         SR    R0,R15              LENGTH OF PRECEDING DATA
         SR    R14,R0              LENGTH CODE OF REMAINING DATA
         BZ    PARSED              BRANCH IF NOTHING FOLLOWS SBA
LOOP     ST    R1,FLDPTR
         LA    R15,1(,R1)          POINT PAST SBA
         BCTR  R14,0               REDUCE LENGTH ACCORDINGLY
         EX    R14,TRTSBA          LOOK FOR SECOND SBA
         BZ    LAST                BRANCH IF NONE PRESENT
         LR    R0,R1               POINT TO NEXT SBA
         SR    R0,R15              GET LENGTH OF THIS DATA
         ST    R0,FLDLEN
         STM   R14,R1,SBASAVE
         BAL   R2,FIELD
         LM    R14,R1,SBASAVE
         SR    R14,R0              LENGTH CODE OF REMAINING DATA
         BNZ   LOOP                SOMETHING FOLLOWS SECOND SBA
         B     PARSED              NOTHING FOLLOWS SECOND SBA
LAST     LA    R0,1(,R14)          GET LENGTH OF THIS DATA
         ST    R0,FLDLEN
*        STM   R14,R1,SBASAVE
         BAL   R2,FIELD
         B     PARSED
FIELD    L     R15,FLDPTR          POINT TO SBA FOR FIELD
         L     R1,FLDLEN           GET LENGTH CODE
         SH    R1,=H'3'            GET LENGTH CODE OF DATA
         BM    0(,R2)              NO DATA PRESENT
         CLC   1(2,R15),FLD1BA     IS IT COMMAND
         BE    FLD1
         CLC   1(2,R15),FLD2BA     IS IT RANGE
         BE    FLD2
         B     0(,R2)              USER MUST HAVE USED CLEAR KEY
FLD1     LA    R15,3(,R15)         POINT TO COMMAND
         ST    R15,CMDPTR          SAVE FOR LATER
         ST    R1,CMDLEN           SAVE LENGTH CODE FOR LATER
         BR    R2                  RETURN
FLD2     LA    R15,3(,R15)         POINT TO RANGE
         CH    R1,=H'1'            IS IT 2 BYTES
         BNE   FLD2A               NO, BRANCH
         CLC   0(2,R15),=C'  '     BLANK
         BE    0(,R2)              YES, IGNORE
         CLI   0(R1),C' '          LEADING BLANK
         BNE   *+8                 NO, BRANCH
         MVI   0(R1),C'0'          CHANGE TO LEADING ZERO
         CLI   1(R15),C' '         TRAILING BLANK
         BNE   FLD2A               NO, BRANCH
         BCTR  R1,0                YES, REDUCE LENGTH BY 1
FLD2A    LR    R14,R2              SAVE R2
         EX    R1,TRTNUM           IS DATA NUMERIC
         LR    R2,R14              RESTORE R2
         BNZ   0(,R2)              NOT NUMERIC, BRANCH
         EX    R1,FLD2PACK         PACK IT
         CVB   R1,DOUBLE           CONVERT TO BINARY
         LTR   R1,R1               IS IT ZERO
         BZ    0(,R2)              YES, IGNORE
         CH    R1,PAGESIZE         IT IT GREATER THAN SCREEN SIZE
         BH    0(,R2)              YES, IGNORE
         ST    R1,SCROLL           SET NEW RANGE
         LR    R0,R1
         LA    R1,SCREENW
         LA    R1,SCRRGE+2-SCREEN(,R1)
         CVD   R0,DOUBLE
         OI    DOUBLE+7,X'0F'
         UNPK  0(2,R1),DOUBLE+6(2)
         BR    R2
TRTNUM   TRT   0(0,R15),NUMERIC    (EXECUTED)
FLD2PACK PACK  DOUBLE(8),0(0,R15)  (EXECUTED)
PARSED   L     R15,CMDPTR          POINT TO COMMAND
         LTR   R15,R15             IS THERE A COMMAND
         BZ    CMDNULL             NO, BRANCH TO CHECK PFK
         L     R14,CMDLEN          GET LENGTH CODE
         LA    R1,CMDAREA
         MVI   0(R1),C' '
         MVC   1(62,R1),0(R1)
         EX    R14,CMDMOVE
         LA    R0,30
CMDJUST  CLI   0(R1),C' '          IS COMMAND LEFT JUSTIFIED
         BNE   CMDJUSTX            YES, BRANCH
         MVC   0(62,R1),1(R1)      SHIFT IT LEFT
         MVI   62(R1),C' '         APPEND BLANK
         BCT   R0,CMDJUST          REPEAT
CMDJUSTX EQU   *
         OC    0(63,R1),=CL63' '   UPPER CASE
         B     CMDSCAN
CMDMOVE  MVC   0(0,R1),0(R15)      (EXECUTED)
CMDNULL  CLI   REPLY,X'7D'         ENTER
         BE    PROMPT              YES, NO ACTION
         SPACE
************************************************************
*                                                          *
*         INTERPRET PROGRAM FUNCTION KEY                   *
*                                                          *
************************************************************
         SPACE
*               NOTE - IF A COMMAND IS TYPED IN THEN
*               IT OVERRIDES THE PF KEY.
PFK      LA    R1,PFKTAB
PFKSRCH  CLI   0(R1),0             END OF PFK TABLE
         BE    NOTPFK              YES, NOT IN TABLE
         CLC   0(1,R1),REPLY       DOES PFK CODE MATCH
         BE    PFKMOVE             YES, BRANCH
         LA    R1,PFKTABL(,R1)     NO, POINT TO NEXT ENTRY IN TABLE
         B     PFKSRCH             KEEP SEARCHING THE TABLE
PFKMOVE  CLI   1(R1),C' '          IS PFK DEFINITION EMPTY
         BE    NOTPFK              YES, BRANCH
         LA    R1,1(,R1)           POINT TO ASSOCIATED COMMAND
         SPACE
************************************************************
*                                                          *
*         PARSE THE COMMAND AND OPERANDS                   *
*                                                          *
************************************************************
         SPACE
CMDSCAN  EQU   *
         LR    R15,R1              POINT TO COLUMN 1
         LA    R3,39               LENGTH CODE OF STATEMENT
         LA    R6,OPDL             POINT TO OPERAND DESCRIPTOR LIST
         XC    0(OPDLL,R6),0(R6)   ZERO THE OPDL
         SR    R1,R1               INSURE HI ORDER BYTE ZERO
         LA    R0,OPDLL/8-1        NUMBER OF ENTRIES IN O.D.L.
*                                  MINUS 1 (LAST ODE WILL REMAIN ZERO)
         B     PARLOOP
TRTNONBL TRT   0(0,R15),TABNONBL   (EXECUTED)
TRTBLANK TRT   0(0,R15),TABBLANK   (EXECUTED)
TRTQUOTE TRT   0(0,R15),TABQUOTE   (EXECUTED)
PARLOOP  XC    0(8,R6),0(R6)       ZERO THE OPERAND DESCRIPTOR ENTRY
         EX    R3,TRTNONBL         FIND A NONBLANK
         BZ    PARDONE             BRANCH IF ALL BLANKS
         LR    R14,R1              GET ADDRESS OF STRING
         SR    R14,R15             GET LENGTH OF PRECEDING BLANKS
         SR    R3,R14              GET LENGTH OF REMAINING TEXT
         LR    R15,R1              GET ADDRESS OF NONBLANK
         CLI   0(R15),QUOTE        DOES OPERAND BEGIN WITH A QUOTE
         BE    PARQUOTE            YES, BRANCH
         EX    R3,TRTBLANK         FIND A BLANK
         BZ    PARLAST             BRANCH IF NOT FOUND
         LR    R14,R1              GET ADDRESS OF BLANK
         SR    R14,R15             GET LENGTH OF FIELD
         OI    6(R6),PRESENT       OPERAND PRESENT
         ST    R15,0(,R6)          ADDRESS OF OPERAND
         STH   R14,4(,R6)          LENGTH OF OPERAND
         SR    R3,R14              GET LENGTH CODE OF REMAINING TEXT
         BZ    PARDONE             BRANCH IF ONE TRAILING BLANK
         LR    R15,R1              POINT TO BLANK
PARNEXT  LA    R6,8(,R6)           POINT TO NEXT O.D.E.
         BCT   R0,PARLOOP          GO PROCESS NEXT OPERAND
         B     PARDONE             MAX OPERANDS PROCESSED
PARQUOTE LA    R15,1(,R15)         POINT PAST QUOTE
         LA    R1,1                VALUE 1
         SR    R3,R1               REDUCE LENGTH CODE BY 1
         BM    PARDONE             IGNORE QUOTE IN LAST COLUMN
         EX    R3,TRTQUOTE         FIND THE NEXT QUOTE
         BZ    PARLASTQ            NOT FOUND, USE ALL REM TEXT
         LR    R14,R1              GET ADDRESS OF QUOTE
         SR    R14,R15             GET LENGTH OF FIELD
         OI    6(R6),PRESENT+QUOTED OPERAND PRESENT AND IN QUOTES
         ST    R15,0(,R6)          ADDRESS OF OPERAND
         STH   R14,4(,R6)          LENGTH OF OPERAND
         SR    R3,R14              GET LENGTH CODE OF REM TEXT
         BZ    PARDONE             BRANCH IF QUOTE WAS FINAL CHAR
         LA    R15,1(,R1)          POINT TO CHAR AFTER ENDING QUOTE
         BCTR  R3,0                REDUCE LENGTH CODE BY 1
         B     PARNEXT             SET UP FOR NEXT OPERAND
PARLASTQ OI    6(R6),QUOTED        OPERAND IN QUOTES
PARLAST  LA    R14,1(,R3)          GET LENGTH
         OI    6(R6),PRESENT       OPERAND PRESENT
         ST    R15,0(,R6)          ADDRESS OF OPERAND
         STH   R14,4(,R6)          LENGTH OF OPERAND
PARDONE  EQU   *
         L     R1,OPD0             POINT TO COMMAND
         CLC   0(5,R1),=C'LEFT '
         BE    LEFT
         CLC   0(2,R1),=C'< '
         BE    LEFT
         CLC   0(6,R1),=C'RIGHT '
         BE    RIGHT
         CLC   0(2,R1),=C'> '
         BE    RIGHT
         CLC   0(3,R1),=C'UP '
         BE    UP
         CLC   0(2,R1),=C'- '
         BE    UP
         CLC   0(5,R1),=C'DOWN '
         BE    DOWN
         CLC   0(2,R1),=C'+ '
         BE    DOWN
         CLC   0(4,R1),=C'TOP '
         BE    TOP
         CLC   0(7,R1),=C'BOTTOM '
         BE    BOTTOM
         CLC   0(4,R1),=C'BOT '
         BE    BOTTOM
         CLC   0(5,R1),=C'LIST '
         BE    LIST
         CLC   0(2,R1),=C'L '
         BE    LIST
         CLC   0(5,R1),=C'FIND '
         BE    FIND
         CLC   0(2,R1),=C'F '
         BE    FIND
         CLC   0(8,R1),=C'FINDSMF '
         BE    FINDSMF
         CLC   0(3,R1),=C'FS '
         BE    FINDSMF
         CLC   0(7,R1),=C'MEMBER '
         BE    MEMBERP
         CLC   0(4,R1),=C'MEM '
         BE    MEMBERP
         CLC   0(4,R1),=C'END '
         BE    END
         CLC   0(5,R1),=C'ASIS '
         BE    ASIS
         CLC   0(5,R1),=C'CAPS '
         BE    CAPS
         CLC   0(4,R1),=C'HEX '
         BE    HEXMODE
         CLC   0(3,R1),=C'PFK'
         BE    PFKSET
         CLC   0(4,R1),=C'SMF '
         BE    SMFMODE
         CLC   0(5,R1),=C'SNAP '
         BE    SNAP
         CLC   0(6,R1),=C'DEBUG '
         BE    DEBUG
         MVC   MSG(MSG20L),MSG20
         B     PROMPT
NOTPFK   EQU   *
         MVC   MSG(MSG21L),MSG21
         B     PROMPT
         SPACE
************************************************************
*                                                          *
*         RIGHT                                            *
*                                                          *
************************************************************
         SPACE
RIGHT    EQU   *
         LA    R15,OPD1            GET FIRST OPERAND ENTRY
         TM    6(R15),PRESENT      ARE THERE ANY OPERANDS
         BZ    RIGHTDEF            NO, USE DEFAULT
         TM    6(R15),QUOTED       IS OPERAND QUOTED
         BO    ERRINV              YES, INVALID
         LH    R1,4(,R15)          GET LENGTH
         LTR   R1,R1               IS IT NULL STRING
         BZ    ERRINV              YES, ERROR
         CH    R1,=H'7'            IS LENGTH MORE THAN 7
         BH    ERRINV              YES, ERROR
         L     R14,0(,R15)         GET ADDRESS OF DATA
         BCTR  R1,0
         B     *+10
         TRT   0(0,R14),NUMERIC
         EX    R1,*-6              IS IT NUMERIC
         BNZ   ERRINV              NO, ERROR
         B     *+10
         PACK  DOUBLE(8),0(0,R14)
         EX    R1,*-6
         CVB   R1,DOUBLE
         LTR   R15,R1
         BZ    PROMPT
         B     RIGHTR15
RIGHTDEF LA    R15,80
         TM    MODE,MODEX
         BZ    *+8
         LA    R15,40
RIGHTR15 LH    R0,OFFSET
         AR    R0,R15
         LH    R1,RECSIZE
         CH    R1,=H'1000'
         BNH   *+8
         LH    R1,=H'1000'
         SR    R1,R15              GET RECSIZE-80
         BNM   *+6                 IF RECSIZE IS LESS THAN 80
         SLR   R1,R1                  THEN RECSIZE-80 IS ZERO
         CR    R0,R1               IF OFFSET+80 GT RECSIZE-80
         BNH   *+6                    THEN
         LR    R0,R1                  USE RECSIZE-80
         STH   R0,OFFSET
         B     FILLSCR
         SPACE
************************************************************
*                                                          *
*         LEFT                                             *
*                                                          *
************************************************************
         SPACE
LEFT     EQU   *
         LA    R15,OPD1            GET FIRST OPERAND ENTRY
         TM    6(R15),PRESENT      ARE THERE ANY OPERANDS
         BZ    LEFTDEF             NO, USE DEFAULT
         TM    6(R15),QUOTED       IS OPERAND QUOTED
         BO    ERRINV              YES, INVALID
         LH    R1,4(,R15)          GET LENGTH
         LTR   R1,R1               IS IT NULL STRING
         BZ    ERRINV              YES, ERROR
         CH    R1,=H'7'            IS LENGTH MORE THAN 7
         BH    ERRINV              YES, ERROR
         L     R14,0(,R15)         GET ADDRESS OF DATA
         BCTR  R1,0
         B     *+10
         TRT   0(0,R14),NUMERIC
         EX    R1,*-6              IS IT NUMERIC
         BNZ   ERRINV              NO, ERROR
         B     *+10
         PACK  DOUBLE(8),0(0,R14)
         EX    R1,*-6
         CVB   R1,DOUBLE
         LTR   R15,R1
         BZ    PROMPT
         B     LEFTR15
LEFTDEF  LA    R15,80
         TM    MODE,MODEX
         BZ    *+8
         LA    R15,40
LEFTR15  LH    R0,OFFSET
         SR    R0,R15              REDUCE OFFSET BY 80
         BNM   *+6                 IF RESULT IS NEGATIVE
         SLR   R0,R0                  THEN MAKE IT ZERO
         STH   R0,OFFSET
         B     FILLSCR
         SPACE
************************************************************
*                                                          *
*         DOWN                                             *
*                                                          *
************************************************************
         SPACE
DOWN     EQU   *
         L     R0,SCROLL
         LA    R15,OPD1            GET FIRST OPERAND ENTRY
         TM    6(R15),PRESENT      ARE THERE ANY OPERANDS
         BZ    DOWNRGE             NO, USE RANGE
         TM    6(R15),QUOTED       IS OPERAND QUOTED
         BO    ERRINV              YES, INVALID
         LH    R1,4(,R15)          GET LENGTH
         LTR   R1,R1               IS IT NULL STRING
         BZ    ERRINV              YES, ERROR
         CH    R1,=H'7'            IS LENGTH MORE THAN 7
         BH    ERRINV              YES, ERROR
         L     R14,0(,R15)         GET ADDRESS OF DATA
         BCTR  R1,0
         B     *+10
         TRT   0(0,R14),NUMERIC
         EX    R1,*-6              IS IT NUMERIC
         BNZ   ERRINV              NO, ERROR
         B     *+10
         PACK  DOUBLE(8),0(0,R14)
         EX    R1,*-6
         CVB   R1,DOUBLE
         LTR   R0,R1
         BZ    PROMPT
DOWNRGE  ST    R0,DOWNAMT
         BAL   R14,DOWNER
         LTR   R15,R15             ACTION TAKEN
         BNZ   PROMPT              NO, BRANCH
         B     FILLSCR             YES, BRANCH
DOWNER   EQU   *
*
*              SEE IF EOF IS ON SCREEN AND WOULD BE FORCED OFF
*
         LA    R15,4
         L     R7,HOLDEND          POINT TO ENTRY FOR LAST RECORD
         TM    DIRLEN(R7),X'80'    IS EOF ON SCREEN
         BZ    DOWNNEOF            NO, DOWN IS POSSIBLE
         L     R7,HOLDTOP
         L     R0,DOWNAMT          GET DOWN AMOUNT
         CH    R0,PAGESIZE         OR SCREEN SIZE IF SMALLER
         BNH   *+8
         LH    R0,PAGESIZE
DOWNTEST TM    DIRLEN(R7),X'80'    IS THIS END OF DATA
         BO    0(R14)              YES, CANT GO DOWN
         L     R7,DIRNXT(,R7)      GET ENTRY FOR NEXT RECORD
         BCT   R0,DOWNTEST
         L     R7,HOLDEND          POINT TO ENTRY FOR LAST RECORD
DOWNNEOF ST    R14,DOWNR
         L     R8,DOWNAMT          GET NUMBER OF LINES TO GO DOWN
DOWNLOOP L     R15,HOLDTOP         POINT TO TOP ENTRY
         L     R15,DIRNXT(,R15)    GET ADDRESS OF ENTRY AFTER TOP
         ST    R15,HOLDTOP         MAKE IT NEW TOP
         TM    DIRLEN(R7),X'80'    IS EOF ON SCREEN
         BO    DOWNNXT             YES, BYPASS GET
         L     R7,DIRNXT(,R7)      POINT TO NEXT ENTRY
         BAL   R14,GET
         LA    R0,1                COMPUTE
         A     R0,COUNT             THE
         ST    R0,COUNT              RECORD NUMBER
         ST    R0,DIRNUM(,R7)      STORE THE RECORD NUMBER
         ST    R1,DIRLEN(,R7)      STORE LENGTH
         LTR   R1,R1               END OF FILE
         BM    DOWNX               YES BRANCH
         C     R1,SAVLRECL         IS RECORD LONGER THAN MAX
         BNH   *+8                 NO, SKIP NEXT INSTR
         L     R1,SAVLRECL         YES, TRUNCATE TO MAX
         LR    R0,R2               ADDRESS TO MOVE FROM
         L     R14,DIRREC(,R7)     ADDRESS TO MOVE TO
         TM    TSTRECFM,X'40'      RECFM V
         BZ    DOWNNOTV            NO
         SH    R14,=H'4'           YES, MOVE TO PTR MINUS 4
         L     R15,DIRLEN(,R7)
         SH    R15,=H'4'
         ST    R15,DIRLEN(,R7)
DOWNNOTV L     R15,SAVLRECL        LENGTH OF RECEIVING FIELD
         O     R1,=A(X'40000000')  PAD WITH BLANKS
         MVCL  R14,R0
DOWNNXT  BCT   R8,DOWNLOOP
DOWNX    ST    R7,HOLDEND          NEW END POINTER
         SLR   R15,R15
         L     R14,DOWNR
         BR    R14
         SPACE
************************************************************
*                                                          *
*         UP                                               *
*                                                          *
************************************************************
         SPACE
UP       EQU   *
         L     R0,SCROLL
         LA    R15,OPD1            GET FIRST OPERAND ENTRY
         TM    6(R15),PRESENT      ARE THERE ANY OPERANDS
         BZ    UPRANGE             NO, USE RANGE
         TM    6(R15),QUOTED       IS OPERAND QUOTED
         BO    ERRINV              YES, INVALID
         LH    R1,4(,R15)          GET LENGTH
         LTR   R1,R1               IS IT NULL STRING
         BZ    ERRINV              YES, ERROR
         CH    R1,=H'7'            IS LENGTH MORE THAN 7
         BH    ERRINV              YES, ERROR
         L     R14,0(,R15)         GET ADDRESS OF DATA
         BCTR  R1,0
         B     *+10
         TRT   0(0,R14),NUMERIC
         EX    R1,*-6              IS IT NUMERIC
         BNZ   ERRINV              NO, ERROR
         B     *+10
         PACK  DOUBLE(8),0(0,R14)
         EX    R1,*-6
         CVB   R1,DOUBLE
         LTR   R0,R1
         BZ    PROMPT
UPRANGE  ST    R0,DOWNAMT
         L     R7,HOLDTOP
         CLC   DIRNUM(4,R7),=F'1'  ARE WE AT TOP ALREADY
         BNH   PROMPT              YES, BRANCH
         TM    DIRLEN(R7),X'80'    IS FIRST LINE EOF
         BZ    UPTOP               NO, BRANCH
         NC    COUNT,COUNT         IS DATA SET EMPTY
         BZ    PROMPT              YES, BRANCH
UPTOP    EQU   *
         L     R0,DIRNUM(,R7)      GET RECORD NUMBER OF TOP LINE
         S     R0,DOWNAMT          GET RECORD NUMBER TO GO BACK TO
         BP    *+8                 IF NEGATIVE
         LA    R0,1                   THEN MAKE IT 1
         B     LISTAT
*
         L     R1,CHKPTTOP
         MVC   TTR,4(R1)           TTR OF FIRST BLOCK
         MVC   TTRZ(3),TTR         TTR OF FIRST BLOCK
         POINT (R4),TTRZ
         XC    COUNT,COUNT
         XC    DEBLOCKS(12),DEBLOCKS
         L     R14,SPANPTR
         XC    0(2,R14),0(R14)     RESET SPANNED BUFFER LENGTH
         L     R0,DIRNUM(,R7)      GET RECORD NUMBER OF TOP LINE
         S     R0,SCROLL           GET RECORD NUMBER TO GO BACK TO
         BP    *+8                 IF NEGATIVE
         LA    R0,1                   THEN MAKE IT 1
         AH    R0,PAGESIZE         GET RECORD NUMBER TO READ UP TO
         BCTR  R0,0
         ST    R0,AIMFOR           SAVE FOR DOWNTO
         BAL   R14,FILLHOLD        READ FIRST 20 RECORDS
         L     R7,HOLDEND          GET ENTRY FOR LAST RECORD
         TM    DIRLEN(R7),X'80'    IS EOF ON SCREEN
         BO    FILLSCR             YES, WE ARE FINISHED
         L     R0,AIMFOR           GET NUMBER WERE AIMING FOR
         S     R0,DIRNUM(,R7)      HAVE WE REACHED IT
         BNP   FILLSCR             YES, WE ARE FINISHED
         ST    R0,DOWNAMT          NO, NEED TO GO DOWN
         BAL   R14,DOWNER
         B     FILLSCR
         SPACE
************************************************************
*                                                          *
*         TOP                                              *
*                                                          *
************************************************************
         SPACE
TOP      EQU   *
         L     R1,CHKPTTOP
         MVC   TTR,4(R1)           TTR OF FIRST BLOCK
         MVC   TTRZ(3),TTR         TTR OF FIRST BLOCK
         POINT (R4),TTRZ
         XC    COUNT,COUNT
         XC    DEBLOCKS(12),DEBLOCKS
         L     R14,SPANPTR
         SLR   R0,R0
         STH   R0,0(,R14)          RESET SPAN BUFFER LENGTH
         ST    R0,FNDNUM           RESET LAST-FOUND NUMBER
         STH   R0,FNDOFF           RESET LAST-FOUND OFFSET
         BAL   R14,FILLHOLD
         B     FILLSCR
         SPACE
************************************************************
*                                                          *
*         BOTTOM                                           *
*                                                          *
************************************************************
         SPACE
BOTTOM   EQU   *
         L     R0,BOTNINES
         B     LISTAT
BOTRET   L     R0,SCROLL
         B     UPRANGE
         SPACE
*        MVC   DOWNAMT,=F'99999999'
*        BAL   R14,DOWNER
*        B     FILLSCR
         SPACE
************************************************************
*                                                          *
*         LIST                                             *
*                                                          *
************************************************************
         SPACE
LIST     EQU   *
         LA    R15,OPD1            GET FIRST OPERAND ENTRY
         TM    6(R15),PRESENT      ARE THERE ANY OPERANDS
         BZ    ERRMISS             NO, MISSING OPERAND
         TM    6(R15),QUOTED       IS OPERAND QUOTED
         BO    ERRINV              YES, INVALID
         LH    R1,4(,R15)          GET LENGTH
         LTR   R1,R1               IS IT NULL STRING
         BZ    ERRINV              YES, ERROR
         CH    R1,=H'7'            IS LENGTH MORE THAN 7
         BH    ERRINV              YES, ERROR
         L     R14,0(,R15)         GET ADDRESS OF DATA
         BCTR  R1,0
         B     *+10
         TRT   0(0,R14),NUMERIC
         EX    R1,*-6              IS IT NUMERIC
         BNZ   ERRINV              NO, ERROR
         B     *+10
         PACK  DOUBLE(8),0(0,R14)
         EX    R1,*-6
         CVB   R1,DOUBLE
         LTR   R0,R1
         BZ    TOP
*
LISTAT   ST    R0,LISTNUM
         AH    R0,PAGESIZE         GET RECORD NUMBER TO READ UP TO
         BCTR  R0,0
         ST    R0,AIMFOR           SAVE FOR DOWNTO
*
         LA    R15,20              LENGTH OF CHKPT ENTRY
         L     R1,CHKPTBOT
         TM    0(R1),X'80'         IS IT EOF
         BZ    LISTNB
         C     R1,CHKPTTOP         IS DATA SET EMPTY
         BE    PROMPT              YES
         SR    R1,R15              NO, BACK UP ONE ENTRY
LISTNB   L     R0,LISTNUM
LISTCK   C     R0,0(,R1)           DOES THIS BLOCK PRECEDE OUR RECORD
         BH    LISTPNT             YES, GO POINT TO IT
         SR    R1,R15              NO, BACK UP ONE BLOCK ENTRY
         B     LISTCK
LISTPNT  MVC   COUNT,0(R1)
         MVC   DEBLOCKS(12),8(R1)
         MVC   TTR,4(R1)           TTR OF FIRST BLOCK
         MVC   TTRZ(3),TTR
         POINT (R4),TTRZ
         L     R14,SPANPTR
         SLR   R0,R0
         STH   R0,0(,R14)          RESET SPAN BUFFER LENGTH
         ST    R0,FNDNUM           RESET LAST-FOUND NUMBER
         STH   R0,FNDOFF           RESET LAST-FOUND OFFSET
*
         BAL   R14,FILLHOLD        READ NEXT 20 RECORDS
*
LISTFINE L     R7,HOLDTOP          GET ENTRY FOR TOP OF HOLD AREA
         TM    DIRLEN(R7),X'80'    IS EOF ON TOP OF SCREEN
         BO    LISTRDY             YES, WE ARE FINISHED
         CLC   LISTNUM,DIRNUM(R7)  IS REQUESTED NUMBER AT TOP
         BNH   FILLSCR             YES, BRANCH
         MVC   DOWNAMT,=F'1'       DOWN 1
         BAL   R14,DOWNER
         B     LISTFINE
LISTRDY  CLC   LISTNUM,BOTNINES    WAS THIS A LIST 99999999
         BE    BOTRET              YES, BRANCH
         B     FILLSCR
ERRMISS  MVC   MSG(MSG35L),MSG35
         B     PROMPT
         SPACE
************************************************************
*                                                          *
*         FIND                                             *
*                                                          *
************************************************************
         SPACE
FIND     EQU   *
         MVI   FINDSW,0
         LA    R15,OPD1            GET FIRST OPERAND ENTRY
         TM    6(R15),PRESENT      ARE THERE ANY OPERANDS
         BZ    FINDSAME            NO, USE PREVIOUS STRING
         XC    STRING,STRING       ERASE OLD STRING
         SLR   R0,R0
         ST    R0,FNDNUM           RESET LAST-FOUND NUMBER
         STH   R0,FNDOFF           RESET LAST-FOUND OFFSET
         STH   R0,FINDCOL          RESET COLUMN
         LH    R1,4(,R15)          GET LENGTH
         LTR   R1,R1               IS IT NULL STRING
         BZ    FINDNULL            YES, ERROR
         L     R14,0(,R15)         GET ADDRESS OF DATA
         BCTR  R1,0
         STH   R1,STRINGL          SAVE LENGTH CODE
         B     *+10
         MVC   STRING(0),0(R14)
         EX    R1,*-6
         LA    R15,OPD2
         TM    6(R15),PRESENT      IS THERE A SECOND OPERAND
         BZ    FINDSAME            NO, LEAVE FINDCOL NULL
         TM    6(R15),QUOTED       IS OPERAND QUOTED
         BO    ERRINV              YES, INVALID
         LH    R1,4(,R15)          GET LENGTH
         LTR   R1,R1               IS IT NULL STRING
         BZ    ERRINV              YES, ERROR
         CH    R1,=H'3'            IS LENGTH MORE THAN 3
         BH    ERRINV              YES, ERROR
         L     R14,0(,R15)         GET ADDRESS OF DATA
         BCTR  R1,0
         B     *+10
         TRT   0(0,R14),NUMERIC
         EX    R1,*-6              IS IT NUMERIC
         BNZ   ERRINV              NO, ERROR
         B     *+10
         PACK  DOUBLE(8),0(0,R14)
         EX    R1,*-6
         CVB   R1,DOUBLE
         LTR   R1,R1               IS IT ZERO
         BZ    ERRINV              YES, ERROR
         C     R1,SAVLRECL         IS IT GREATER THAN LRECL
         BH    ERRINV              YES, ERROR
         STH   R1,FINDCOL
FINDSAME EQU   *
         NC    STRING,STRING       HAS A STRING BEEN ENTERED
         BZ    FINDNULL            NO, ERROR
         LH    R6,FINDCOL
         L     R7,HOLDTOP          GET INFO FOR FIRST HELD RECORD
         L     R0,DIRNUM(,R7)      GET RECORD NUMBER OF FIRST HELD
         L     R1,FNDNUM           GET RECORD NUMBER WHERE LAST FOUND
         LTR   R1,R1               HAS IT BEEN FOUND
         BNP   FINDSCR             NO, START WITH HELD RECORDS
         CR    R0,R1               ARE WE PAST LAST FOUND REC
         BH    FINDSCR             YES, START WITH HELD RECORDS
         L     R14,HOLDEND
         L     R15,DIRNUM(,R14)    GET RECORD NUMBER OF LAST HELD
         CR    R1,R15              IS LAST FOUND REC ON SCREEN
         BH    FINDDOWN            NO, BRANCH
FINDPREV C     R1,DIRNUM(,R7)      IS THIS RECORD WHERE LAST FOUND
         BE    FINDPCOL            YES, BRANCH
         C     R7,HOLDEND          IS THIS LAST RECORD ON SCREEN
         BE    FINDDOWN            SHOULD NOT HAPPEN
         L     R7,DIRNXT(,R7)      POINT TO NEXT RECORD
         B     FINDPREV
FINDPCOL L     R15,DIRREC(,R7)     POINT TO RECORD
         LTR   R6,R6               WAS A COLUMN SPECIFIED
         BZ    FINDPOFF            NO, LOOK AT SAME RECORD
         C     R7,HOLDEND          IS THIS LAST RECORD ON SCREEN
         BE    FINDDOWN            YES, BRANCH
         L     R7,DIRNXT(,R7)      NO, POINT TO NEXT RECORD
         B     FINDSCR             GO EXAMINE RECORD
FINDPOFF AH    R15,FNDOFF          POINT TO LAST FOUND STRING
         LA    R15,1(,R15)         POINT PAST LAST FOUND STRING
         B     FINDSTR
FINDCLC  CLC   0(0,R15),STRING     (EXECUTED)
FINDSCR  TM    DIRLEN(R7),X'80'    ARE WE AT EOF
         BO    FINDBOT             YES, BRANCH
         L     R15,DIRREC(,R7)     POINT TO FIRST BYTE TO EXAMINE
         LTR   R6,R6               WAS A COLUMN SPECIFIED
         BZ    FINDSTR             NO, BRANCH
         AR    R15,R6              YES, POINT TO COLUMN PLUS 1
         BCTR  R15,0               POINT TO COLUMN
         LH    R14,STRINGL
         EX    R14,FINDCLC
         BE    FOUND
         B     FINDNEXT
FINDSTR  L     R0,DIRLEN(,R7)      GET LENGTH OF RECORD
         C     R0,SAVLRECL         IS RECORD TRUNCATED
         BNH   *+8                 NO, SKIP NEXT INSTR
         L     R0,SAVLRECL         YES, USE TRUNCATED LENGTH
         L     R1,DIRREC(,R7)      GET ADDRESS OF RECORD
         AR    R0,R1               POINT PAST LAST BYTE OF RECORD
         LH    R14,STRINGL         GET LENGTH CODE OF STRING
         AR    R15,R14             POINT TO LAST BYTE TO BE COMPARED
         SR    R0,R15              GET NUMBER OF COMPARISONS
         BNP   FINDNEXT            STRING TOO LONG FOR REMAINING TEXT
         SR    R15,R14             PUT STRING ADDRESS BACK
FINDCOMP EX    R14,FINDCLC         COMPARE STRING TO DATA
         BE    FOUND
         LA    R15,1(,R15)         INCREMENT DATA POINTER
         BCT   R0,FINDCOMP         GO COMPARE AGAIN
FINDNEXT C     R7,HOLDEND          WAS THAT LAST HELD RECORD
         BE    FINDDOWN            YES, BRANCH
         L     R7,DIRNXT(,R7)      POINT TO NEXT RECORD
         B     FINDSCR             GO PROCESS NEXT RECORD
FINDBOT  EQU   *
         MVC   MSG(MSG32L),MSG32
         B     FILLSCR
FINDDOWN EQU   *
         LA    R1,1
         ST    R1,DOWNAMT
         BAL   R14,DOWNER
         L     R7,HOLDEND
         OI    FINDSW,1
         B     FINDSCR
FINDNULL MVC   MSG(MSG33L),MSG33
         B     PROMPT
ERRINV MVC     MSG(MSG34L),MSG34
         B     PROMPT
FOUND    MVC   MSG(MSG31L),MSG31
         MVC   FNDNUM,DIRNUM(R7)   SAVE RECORD NUMBER
         S     R15,DIRREC(,R7)     GET OFFSET TO FOUND LOCATION
         STH   R15,FNDOFF          SAVE OFFSET
         LA    R15,1(,R15)         MAKE IT COLUMN NUMBER
         CVD   R15,DOUBLE
         OI    DOUBLE+7,X'0F'
         LA    R15,MSG+26
         UNPK  0(5,R15),DOUBLE+5(3)
         L     R15,FNDNUM
         CVD   R15,DOUBLE
         OI    DOUBLE+7,X'0F'
         LA    R15,MSG+16
         UNPK  0(5,R15),DOUBLE+5(3)
         TM    FINDSW,1
         BZ    FILLSCR
         LH    R6,PAGESIZE
         SH    R6,=H'2'
FINDLN2  LA    R1,1
         ST    R1,DOWNAMT
         BAL   R14,DOWNER
         BCT   R6,FINDLN2
         B     FILLSCR
         SPACE
************************************************************
*                                                          *
*         FINDSMF   (FIND SMF RECORD TYPE)                 *
*                                                          *
************************************************************
         SPACE
FINDSMF EQU    *
         MVI   FINDSW,0
         LA    R15,OPD1            GET FIRST OPERAND ENTRY
         TM    6(R15),PRESENT      ARE THERE ANY OPERANDS
         BZ    FINDSAME            NO, USE PREVIOUS STRING
         XC    STRING,STRING       ERASE OLD STRING
         SLR   R0,R0
         ST    R0,FNDNUM           RESET LAST-FOUND NUMBER
         STH   R0,FNDOFF           RESET LAST-FOUND OFFSET
         STH   R0,FINDCOL          RESET COLUMN
         TM    6(R15),QUOTED       IS OPERAND QUOTED
         BO    ERRINV              YES, INVALID
         LH    R1,4(,R15)          GET LENGTH
         LTR   R1,R1               IS IT NULL STRING
         BZ    FINDNULL            YES, ERROR
         L     R14,0(,R15)         GET ADDRESS OF DATA
         BCTR  R1,0
         B     *+10
         TRT   0(0,R14),NUMERIC
         EX    R1,*-6              IS IT NUMERIC
         BNZ   ERRINV              NO, ERROR
         B     *+10
         PACK  DOUBLE(8),0(0,R14)
         EX    R1,*-6
         CVB   R1,DOUBLE
         CH    R1,=H'255'          IS IT GREATER THAN 255
         BH    ERRINV              YES, ERROR
         STC   R1,STRING           STORE BINARY VALUE 0 TO 255
         LA    R1,2                COLUMN 2
         STH   R1,FINDCOL
         SR    R1,R1               LENGTH MINUS 1 IS ZERO
         STH   R1,STRINGL          SAVE LENGTH CODE
         B     FINDSAME
         SPACE
************************************************************
*                                                          *
*         HEX                                              *
*                                                          *
************************************************************
         SPACE
HEXMODE  EQU   *
         LA    R15,OPD1            GET FIRST OPERAND ENTRY
         TM    6(R15),PRESENT      ARE THERE ANY OPERANDS
         BZ    HEXFLIP             NO, FLIP FLOP
         L     R14,0(,R15)         POINT TO OPERAND
         CLI   5(R15),2            IS LENGTH 2
         BNE   HEXOFF              NO, TRY OFF
         CLC   0(2,R14),=C'ON'     YES, IS IT 'ON'
         BNE   ERRKW               NO, INVALID OPERAND
         OI    MODE,MODEX
         B     FILLSCR
HEXOFF   CLI   5(R15),3            IS LENGTH 3
         BNE   ERRKW
         CLC   0(3,R14),=C'OFF'
         BNE   ERRKW
         NI    MODE,255-MODEX
         B     FILLSCR
HEXFLIP  XI    MODE,MODEX          FLIP FLOP THE SWITCH
         B     FILLSCR
ERRKW    MVC   MSG(MSG34L),MSG34
         B     PROMPT
         SPACE
************************************************************
*                                                          *
*         PFK SET                                          *
*                                                          *
************************************************************
         SPACE
PFKSET   EQU   *
         LA    R15,3(,R1)          POINT TO NN AFTER PFK
         TRT   0(1,R15),NUMERIC    PFKN
         BNZ   PFKSET9             ERROR, N NOT NUMERIC
         PACK  DOUBLE,0(1,R15)
         CLI   1(R15),C' '         SINGLE DIGIT
         BE    PFKSET1             YES, BRANCH
         TRT   1(1,R15),NUMERIC
         BNZ   PFKSET9             SECOND DIGIT NOT NUMERIC
         CLI   2(R15),C' '
         BNE   PFKSET9             MORE THAN 2 DIGITS
         PACK  DOUBLE,0(2,R15)
PFKSET1  CVB   R1,DOUBLE           GET VALUE OF N OR NN
         CH    R1,=H'1'
         BL    PFKSET9             ERROR, LESS THAN 1
         CH    R1,=H'12'
         BH    PFKSET9             ERROR, GREATER THAN 12
         BCTR  R1,0                CHANGE 1-12 TO 0-11
         LA    R0,PFKTABL          LENGTH OF EACH PFK ENTRY
         MR    R0,R0               COMPUTE OFFSET INTO TABLE
         LA    R15,PFKTAB(R1)      POINT TO TABLE ENTRY
         LA    R1,OPD1             GET FIRST OPERAND ENTRY
         TM    6(R1),PRESENT       ARE THERE ANY OPERANDS
         BZ    PFKSETF             NO, BLANK IT
         CLI   5(R1),0             IS IT NULL LENGTH
         BE    PFKSETF             YES, BLANK IT
         L     R1,0(,R1)           POINT TO OPERAND
         CLC   0(3,R1),=C'PFK'     IS OPERAND ANOTHER PFK COMMAND
         BE    PFKSET9             YES, ERROR
         LA    R0,CMDAREA+62       POINT TO END OF COMMAND AREA
         SR    R0,R1               GET LENGTH CODE OF COMMAND
         BM    PFKSET9
         LR    R14,R0
         MVI   1(R15),C' '
         MVC   2(PFKTABL-2,R15),1(R15)
         B     *+10
         MVC   1(0,R15),0(R1)      EXECUTED
         EX    R14,*-6             MOVE COMMAND INTO PFK TABLE
*        LA    R14,1(,R14)         D
*        CVD   R14,DOUBLE           E
*        OI    DOUBLE+7,X'0F'        B
*        UNPK  MSG+2(3),DOUBLE+6(2)   U
*        MVI   MSG+5,C' '              G
*        MVC   MSG+6(10),1(R15)    D
*        LA    R0,14                E
*        STH   R0,MSG                B
*        B     PROMPT                 U
PFKSETX  MVC   MSG(MSG40L),MSG40   HAS BEEN RESET
         B     PROMPT
PFKSETF  MVI   1(R15),C' '
         MVC   2(PFKTABL-2,R15),1(R15)
         B     PFKSETX
PFKSET9  MVC   MSG(MSG41L),MSG41   INVALID PFK COMMAND
         B     PROMPT
         SPACE
************************************************************
*                                                          *
*         SMF                                              *
*                                                          *
************************************************************
         SPACE
SMFMODE  EQU   *
         LA    R15,OPD1            GET FIRST OPERAND ENTRY
         TM    6(R15),PRESENT      ARE THERE ANY OPERANDS
         BZ    SMFFLIP             NO, FLIP FLOP
         L     R14,0(,R15)         POINT TO OPERAND
         CLI   5(R15),2            IS LENGTH 2
         BNE   SMFOFF              NO, TRY OFF
         CLC   0(2,R14),=C'ON'     YES, IS IT 'ON'
         BNE   ERRKW               NO, INVALID OPERAND
         OI    SMFSW,SMFBIT
SMFLOAD  L     R15,CALLSMFA        GET ADDRESS OF REVSMF
         LTR   R15,R15             IS REVSMF LOADED
         BNZ   FILLSCR             YES, BRANCH
         L     R0,=V(REVSMF)       WILL USE THIS INSTEAD OF LOAD
*                                  AFTER REVSMF IS TESTED
*        LOAD  EP=REVSMF,ERRET=SMFERR
         ST    R0,CALLSMFA         SAVE ADDRESS OF REVSMF
         B     FILLSCR
SMFERR   NI    SMFSW,255-SMFBIT    LOAD FAILED
         B     FILLSCR
SMFOFF   CLI   5(R15),3            IS LENGTH 3
         BNE   ERRKW
         CLC   0(3,R14),=C'OFF'
         BNE   ERRKW
         NI    SMFSW,255-SMFBIT
         B     FILLSCR
SMFFLIP  XI    SMFSW,SMFBIT
         TM    SMFSW,SMFBIT        DID WE FLIP IT ON
         BO    SMFLOAD             YES - CHECK FOR REVSMF
         B     FILLSCR
         SPACE
************************************************************
*                                                          *
*         CAPS / ASIS                                      *
*                                                          *
************************************************************
         SPACE
CAPS     MVC   PERIODS,CAPST
         B     FILLSCR
         SPACE
ASIS     MVC   PERIODS,ASIST
         B     FILLSCR
         SPACE
************************************************************
*                                                          *
*         MEMBER                                           *
*                                                          *
************************************************************
         SPACE
MEMBERP  EQU   *
         TM    DSORG,X'02'         IS DSORG PO
         BZ    MEMPDS              NO, BRANCH
         LA    R15,OPD1            GET FIRST OPERAND ENTRY
         TM    6(R15),PRESENT      ARE THERE ANY OPERANDS
         BZ    ERRMISS             NO, MISSING OPERAND
         TM    6(R15),QUOTED       IS OPERAND QUOTED
         BO    ERRINV              YES, INVALID
         LH    R1,4(,R15)          GET LENGTH
         LTR   R1,R1               IS IT NULL STRING
         BZ    ERRMISS             YES, ERROR
         CH    R1,=H'8'            IS LENGTH MORE THAN 8
         BH    ERRINV              YES, ERROR
         MVC   BLDL(4),=AL2(1,76)
         MVC   BLDL+4(8),=CL8' '
         L     R14,0(,R15)         GET ADDRESS OF DATA
         BCTR  R1,0
         B     *+10
         MVC   BLDL+4(0),0(R14)
         EX    R1,*-6
         BLDL  (R4),BLDL
         LTR   R15,R15
         BNZ   MEMERR
         NI    STATUS,255-STNOMEM
         MVC   $MEMBER,BLDL+4
         L     R1,CHKPTTOP
         MVC   4(4,R1),BLDL+12     COPY TTR
         ST    R15,CHKPTBOT        ZERO CHKPT TABLE
         MVC   TTR,BLDL+12         TTR OF FIRST BLOCK
         MVC   TTRK,BLDL+12        TTR OF FIRST BLOCK
         FIND  (R4),TTRK,C
*        POINT (R4),TTR
         MVC   DSNAIM(46),$DSNAME
         SLR   R15,R15
         IC    R15,TTR+3           GET CONCATENATION NUMBER
         LTR   R15,R15
         BZ    NOCONCAM
         CVD   R15,DOUBLE          APPEND
         OI    DOUBLE+7,X'0F'       CONCAT
         LH    R15,$DDNAML           NUMBER
         SH    R15,=H'4'              TO DDNAME
         LA    R15,$DDNAME(R15)         SO IT
         UNPK  1(3,R15),DOUBLE+6(2)      BECOMES
         MVI   0(R15),C'+'                DDNAME+NNN
         MVC   DSNAIM(46),$DDNAML  SHOW DDNAME INSTEAD OF DSNAME
NOCONCAM EQU   *
         XC    COUNT,COUNT
         XC    DEBLOCKS(12),DEBLOCKS
         L     R14,SPANPTR
         SLR   R0,R0
         STH   R0,0(,R14)          RESET SPAN BUFFER LENGTH
         ST    R0,FNDNUM           RESET LAST-FOUND NUMBER
         STH   R0,FNDOFF           RESET LAST-FOUND OFFSET
         B     NEWNAME
MEMERR   CH    R15,=H'4'
         BNE   MEMERR2
         MVC   MSG(MSG36L),MSG36   MEMBER NOT FOUND
         B     PROMPT
MEMERR2  MVC   MSG(MSG37L),MSG37   BLDL FAILED
         B     PROMPT
MEMPDS   MVC   MSG(MSG38L),MSG38   NOT PARTITIONED
         B     PROMPT
         SPACE
************************************************************
*                                                          *
*         SNAP                                             *
*                                                          *
************************************************************
         SPACE
SNAP     EQU   *
         LA    R7,SNAPR
         LA    R0,@DATA
         ST    R0,0(,R7)
         A     R0,=A(@DATAL)
         BCTR  R0,0
         ST    R0,4(,R7)
         L     R0,CHKPTTOP
         ST    R0,8(,R7)
         L     R0,CHKPTBOT
         AH    R0,=H'80'
         C     R0,ENDPTR
         BNH   *+8
         LH    R0,ENDPTR
         SH    R0,=H'4'
         ST    R0,12(,R7)
         OI    12(R7),X'80'
         MVC   SNAPDW(SNAPDL),SNAPD
*        LA    R6,SNAPDW
*        OPEN  ((R6),OUTPUT),MF=(E,OPEND)
*        TM    48(R6),X'10'
*        BNO   PROMPT
*        MVC   SNAPLW(SNAPLL),SNAPL
*        SNAP  DCB=(R6),ID=7,PDATA=(REGS),LIST=(R7),MF=(E,SNAPLW)
*        CLOSE ((R6)),MF=(E,OPEND)
         B     PROMPT
         SPACE
************************************************************
*                                                          *
*         DEBUG  (SHOW TGET RESULTS ON SCREEN)             *
*                                                          *
************************************************************
         SPACE
DEBUG    EQU   *
         LA    R1,TGETREGS         POINT TO R15, R0, R1
         L     R2,HOLDTOP
         LA    R0,26               8+1+8+1+8
         ST    R0,DIRLEN(,R2)      FAKE RECORD LENGTH
         LA    R0,4                FIRST 4 BYTES (R15)
         L     R15,DIRREC(,R2)
         BAL   R14,HEX
         LA    R15,1(,R15)
         LA    R0,4                SECOND 4 BYTES (R0)
         BAL   R14,HEX
         LA    R15,1(,R15)
         LA    R0,4                THIRD 4 BYTES (R1)
         BAL   R14,HEX
         LA    R1,REPLY            REPLY AREA
         L     R2,DIRNXT(,R2)
         L     R0,TGETREGS+8       REPLY LENGTH RETURNED BY TGET
         SLL   R0,1                DOUBLE FOR HEX
         ST    R0,DIRLEN(,R2)      FAKE RECORD LENGTH
         SRL   R0,1                RESTORE R1 FOR HEX ROUTINE
         L     R15,DIRREC(,R2)
         BAL   R14,HEX             CONVERT REPLY TO HEX
         L     R2,DIRNXT(,R2)
         MVC   DIRLEN(4,R2),=F'-1'
         ST    R2,HOLDEND
         B     FILLSCR
         SPACE
************************************************************
*                                                          *
*         SUBROUTINE TO CONVERT DATA TO HEX                *
*                                                          *
************************************************************
         SPACE
HEX      MVC   1(1,R15),0(R1)      MOVE BYTE
         UNPK  0(3,R15),1(2,R15)   UNPACK
         TR    0(2,R15),HEXTAB-240
         LA    R15,2(,R15)         INCREMENT OUTPUT PTR
         LA    R1,1(,R1)           INCREMENT INPUT PTR
         BCT   R0,HEX              DECREMENT LENGTH, THEN LOOP
         MVI   0(R15),C' '         BLANK THE TRAILING BYTE
         BR    R14                 RETURN TO CALLER
         SPACE
HEXTAB   DC    C'0123456789ABCDEF' TRANSLATE TABLE
         SPACE
************************************************************
*                                                          *
*         SUBROUTINE TO GET A LOGICAL RECORD               *
*                                                          *
************************************************************
         SPACE
*
*               INPUT
*                R4 DCB ADDRESS
*                CHKPTTOP  -  TOP OF CHECKPOINT TABLE
*                CHKPTBOT  -  BOTTOM OF CHECKPOINT TABLE, ZERO 1ST TIME
*                COUNT     -  LAST LOGICAL RECORD NUMBER READ
*                BLOCKPTR  -  ADDRESS OF BUFFER
*                DEBLOCKS  -  DEBLOCKING INFO (ZEROS FIRST TIME)
*                SPANPTR   -  ADDRESS OF AREA TO COMBINE
*                             SPANNED RECORD SEGMENTS
*
*               OUTPUT
*                 R1 CONTAINS LENGTH OF RECORD (OR -1 IF END OF FILE)
*                 R2 CONTAINS ADDRESS OF RECORD (OR 0 IF END OF FILE)
*
GET      ST    R14,READR
         TM    DCBRECFM,X'10'      BLOCKED
         BZ    READI               NO, BRANCH
*        TM    DCBRECFM,X'C0'      UNDEFINED
*        BO    READI               YES, BRANCH
         LM    R0,R2,DEBLOCKS      GET DEBLOCKING STATUS
         AR    R2,R1               POINT TO NEXT RECORD
         CR    R2,R0               END OF BLOCK (OR FIRST TIME)
         BNL   READI               YES, BRANCH
         TM    TSTRECFM,X'40'      VARIABLE LENGTH
         BO    READVB              YES, BRANCH
         ST    R2,DEBLOCKS+8       FIXED BLOCKED
         B     READX
READI    L     R5,CHKPTBOT         GET LAST CHECKPOINT
         LTR   R5,R5               IS THIS FIRST READ
         BNZ   READNF              BRANCH IF NOT FIRST
         L     R5,CHKPTTOP
         B     READNEW             READING A RECORD NOT READ BEFORE
READNF   L     R1,0(,R5)           GET NUMBER OF HIGHEST RECORD READ
         LTR   R1,R1               WAS IT EOF
         BM    READOLD             YES, BRANCH
         C     R1,COUNT            HAVE WE READ THIS RECORD BEFORE
         BNH   READADD             NO, BRANCH
READOLD  LA    R5,CHKPTDUM         YES, DONT CHANGE CHKPT TABLE
         B     READ
READADD  LA    R5,20(,R5)          ADD AN ENTRY TO THE CHKPT TABLE
         C     R5,ENDPTR           IS TABLE FILLED UP
         BL    *+8                 NO, SKIP NEXT INSTR
         BAL   R14,READHALF        YES, HALVE THE TABLE
READNEW  ST    R5,CHKPTBOT         SAVE NEW CURRENT CHECKPOINT POINTER
         MVC   0(4,R5),COUNT
         XC    4(4,R5),4(R5)
         MVC   8(12,R5),DEBLOCKS
READ     TM    STATUS,STNOMEM      ARE WE IN MEMBER-NOT-FOUND STATUS
         BO    DYNEOD              YES, JUST GO TO END OF FILE
         L     R2,BLOCKPTR
         READ  DYNDECBW,SF,(R4),(R2),'S',MF=E
         CHECK DYNDECBW
         CLI   SYNADSW,0           WAS SYNAD EXIT TAKEN?
         BNE   IOERR               YES, BRANCH
         LH    R1,DCBBLKSI
         L     R14,DYNDECBW+16
         SH    R1,14(,R14)         SUBTRACT RESIDUAL COUNT
         TM    TSTRECFM,X'40'      VARIABLE LENGTH RECORDS
         BZ    OKREAD              NO, BRANCH
         LH    R1,0(,R2)           YES, USE BLKSIZE IN BDW
*        SH    R1,=H'4'                                              $V
*        LA    R2,4(,R2)                                             $V
OKREAD   LA    R0,0(R1,R2)         END OF BLOCK
         STM   R0,R2,DEBLOCKS      SAVE STATUS INFO
         CLC   4(4,R5),=F'0'       IS THIS 2ND READ PER GET
         BNZ   NOTED               YES, BYPASS NOTE
         NOTE  (R4)
         ST    R1,4(,R5)           SAVE TTR IN TABLE
NOTED    EQU   *
         L     R1,DEBLOCKS+4       RESTORE LENGTH
         TM    DCBRECFM,X'10'      BLOCKED?
         BO    READB               YES, BRANCH
         TM    TSTRECFM,X'48'      VARIABLE UNBLOCKED SPANNED
         BNO   READX               NO
         B     READVBS             YES, SAME AS BLOCKED
READB    TM    DCBRECFM,X'C0'      UNDEFINED
         BO    READX
         TM    DCBRECFM,X'40'      VARIABLE LENGTH
         BO    READVBI
READFB   LH    R1,DCBLRECL         FIXED BLOCKED
         ST    R1,DEBLOCKS+4       SAVE STATUS INFO
         B     READX
READVBI  LA    R2,4(,R2)           POINT PAST BDW                    $V
READVB   TM    DCBRECFM,X'08'      SPANNED
         BO    READVBS
READVBR  LH    R1,0(,R2)
*        SH    R1,=H'4'                                              $V
*        LA    R2,4(,R2)                                             $V
         STM   R1,R2,DEBLOCKS+4    SAVE STATUS INFO
         B     READX
READVBS  CLI   2(R2),0             SEGMENT
         BE    READVBR             NO, BRANCH
*               THIRD BYTE IS X'01' FOR FIRST SEGMENT
*                             X'03' FOR MIDDLE SEGMENT
*                             X'02' FOR LAST SEGMENT
         CLI   2(R2),1             FIRST SEGMENT
         BNE   READSEG2
         L     R14,SPANPTR         ADDRESS TO MOVE TO
         LH    R15,0(,R2)          LENGTH TO MOVE
         LR    R1,R15              LENGTH TO MOVE
         LR    R0,R2               ADDRESS TO MOVE FROM
         MVCL  R14,R0              MOVE SEGMENT RDW AND DATA
         B     READSEGD            GO DEBLOCK NEXT SEGMENT
READSEG2 L     R14,SPANPTR         ADDRESS OF PRIOR SEGMENTS
         LH    R0,0(,R14)          LENGTH OF PRIOR SEGMENTS
         LH    R15,0(,R2)          LENGTH+4 OF NEW SEGMENT
         SH    R15,=H'4'           LENGTH OF NEW SEGMENT
         LR    R1,R15              LENGTH TO BE MOVED
         AR    R15,R0              COMBINE LENGTHS
         STH   R15,0(,R14)         STORE COMBINED LENGTHS
         LR    R15,R1              LENGTH TO ME MOVED
         AR    R14,R0              ADDRESS TO MOVE TO
         LA    R0,4(,R2)           ADDRESS TO MOVE FROM
         MVCL  R14,R0              MOVE SEGMENT DATA
         CLI   2(R2),2             LAST SEGMENT
         BNE   READSEGD            NO, GO DEBLOCK NEXT SEGMENT
         LH    R1,0(,R2)           GET LENGTH OF THIS SEGMENT
         STM   R1,R2,DEBLOCKS+4    SAVE LENGTH AND ADDRESS
         L     R2,SPANPTR          POINT TO COMBINED RECORD
         LH    R1,0(,R2)           GET COMBINED LENGTH
*        SH    R1,=H'4'                                              $V
*        LA    R2,4(,R2)                                             $V
         B     READX               EXIT
READSEGD EQU   *                   NOT NECESSARY TO CHECK RECFM X'10'
         LH    R1,0(,R2)           LENGTH
         AR    R2,R1               POINT TO NEXT SEGMENT
         C     R2,DEBLOCKS         END OF BLOCK
         BNL   READ                YES, BRANCH
         B     READVBS             GO PROCESS NEW SEGMENT
READX    L     R14,READR
         BR    R14
DYNEOD   EQU   *
         L     R1,=F'-1'           EOF
         ST    R1,0(,R5)           SAVE EOF IN CHKPT TABLE
         SLR   R2,R2
         B     READX
         SPACE
READHALF LA    R0,20               LENGTH OF EACH ENTRY
         L     R15,CHKPTTOP        POINT TO FIRST ENTRY
         AR    R15,R0              POINT TO SECOND ENTRY
         LR    R1,R15
         AR    R1,R0               POINT TO THIRD ENTRY
READHMOV MVC   0(20,R15),0(R1)     MOVE 3RD TO 2ND
*                                       5TH TO 3RD
*                                       7TH TO 4TH, ETC
         AR    R15,R0              RECEIVING FIELD DOWN 1
         AR    R1,R0               SENDING FIELD DOWN 1
         AR    R1,R0               SENDING FIELD DOWN 2
         CR    R1,R5               ARE WE PAST THE LAST ENTRY
         BL    READHMOV            NO, BRANCH
         LR    R5,R15              YES, NEW CURRENT POINTER
         BR    R14                 RETURN
         SPACE
************************************************************
*                                                          *
*         END OF PROGRAM                                   *
*                                                          *
************************************************************
         SPACE
END      LA    R1,ERAZE
         LA    R0,ERAZEL
         O     R1,=A(X'03000000')
         SVC   93                  ERASE THE SCREEN
         LA    R15,0
         B     EXITRC
         SPACE
IOERR    LA    R1,SYNADMSG
         LA    R0,78
         BAL   R14,PUTMSG
         B     EXIT12
         SPACE
EXIT12   LA    R15,12
         SPACE
EXITRC   CH    R15,RC
         BNH   *+8
         STH   R15,RC              SET HIGHEST RC
         TM    STATUS,STGMVU
         BZ    NOGMVU
         L     R0,ANSWER+4         LENGTH
         L     R1,ANSWER           ADDRESS
         FREEMAIN R,LV=(0),A=(1)
         NI    STATUS,255-STGMVU
NOGMVU   EQU   *
         TM    STATUS,STOPEN
         BZ    NOCLOSE
         TM    DCBOFLGS,X'10'      IS IT OPEN?
         BZ    NOCLOSE             NO, BRANCH
         MVI   CLOSED,X'80'
         CLOSE ((R4)),MF=(E,CLOSED)
         NI    STATUS,255-STOPEN   CLOSED
         DROP  R4                  IHADCB
NOCLOSE  EQU   *
         LM    R10,R12,BASE1
         L     R14,RET1
         BR    R14                 RETURN TO PHASE 1
         SPACE
************************************************************
*                                                          *
*        PUTMSG ROUTINE                                    *
*                                                          *
************************************************************
         SPACE
PUTMSG   STM   R14,R1,PUTLINS
         XC    MYOLD(8),MYOLD
         XC    MYSEG1(4),MYSEG1
         MVC   MYPTPB(12),MODLPTPM
         LA    R14,1               NO. OF MESSAGE SEGMENTS
         ST    R14,MYOLD
         LA    R14,MYSEG1          POINT TO 1ST SEGMENT
         ST    R14,MYOLD+4
         LR    R14,R0              LENGTH IN R0
         LA    R14,4(,R14)         ADD 4
         LA    R15,MYSEG1+4
         CLC   0(3,R1),=C'IKJ'     IS DATA PRECEEDED BY MESSAGE ID?
         BE    *+16                YES - BRANCH
         LA    R14,1(,R14)         ADD 1 TO LENGTH
         MVI   0(R15),C' '         INSERT LEADING BLANK
         LA    R15,1(,R15)         BUMP POINTER
         STH   R14,MYSEG1
         LR    R14,R0
         BCTR  R14,0
         B     *+10
         MVC   0(0,R15),0(R1)      MOVE MESSAGE IN
         EX    R14,*-6
         L     R15,MYPUTLEP
         SPACE
         PUTLINE PARM=MYPTPB,OUTPUT=(MYOLD),ENTRY=(15),MF=(E,MYIOPL)
         SPACE
         LM    R14,R1,PUTLINS
         BR    R14
         SPACE
************************************************************
*                                                          *
*        SYNAD EXIT                                        *
*                                                          *
************************************************************
         SPACE
*        THIS ROUTINE IS ENTERED DURING THE 'CHECK' MACRO
*        IF AN I/O ERROR OCCURS.
         SPACE
DYNSYNAD EQU   *
         SYNADAF ACSMETH=BSAM
         MVC   SYNADMSG(78),50(R1)
         MVI   SYNADSW,X'FF'
         SYNADRLS
         BR    R14
         SPACE
************************************************************
*                                                          *
*        CONSTANTS                                         *
*                                                          *
************************************************************
         SPACE
         LTORG
         SPACE
PAGE     EQU   20                  LINES PER SCREEN
PAGESIZE DC    0H'0',AL2(PAGE)     LINES PER SCREEN
BOTNINES DC    F'99999999'
         SPACE
MODLPTPM PUTLINE OUTPUT=(1,TERM,SINGLE,INFOR),                         X
               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),MF=L
         SPACE
MODLPTPB PUTLINE OUTPUT=(1,TERM,SINGLE,DATA),                          X
               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),MF=L
         SPACE
         PRINT NOGEN
         SPACE
SEQDCB   DCB   DDNAME=DYNAM,DSORG=PS,MACRF=(RP),                       +
               EODAD=0,SYNAD=0
SEQDCBL  EQU   *-SEQDCB
         SPACE
PDSDCB   DCB   DDNAME=DYNAM,DSORG=PO,MACRF=(R),                        +
               EODAD=0,SYNAD=0
PDSDCBL  EQU   *-PDSDCB
         SPACE
         PRINT GEN
         SPACE
DYNREAD  READ  DYNDECB,SF,0,0,'S',MF=L
DYNDECBL EQU   *-DYNDECB
         SPACE
GMVU     GETMAIN VU,MF=L
GMVUL    EQU   *-GMVU
         SPACE
MSG04    DC    C'UNABLE TO OPEN DATASET'
MSG08    DC    C'SPECIFIED MEMBER NOT FOUND IN DATASET'
MSG20    MSGZ  'INVALID COMMAND'
MSG21    MSGZ  'INVALID PF KEY'
MSG31    MSGZ  'FOUND IN LINE XXXXX COL XXXXX'
MSG32    MSGZ  'BOTTOM OF DATA REACHED'
MSG33    MSGZ  'STRING NOT SPECIFIED'
MSG34    MSGZ  'INVALID OPERAND'
MSG35    MSGZ  'MISSING OPERAND'
MSG36    MSGZ  'MEMBER NOT FOUND'
MSG37    MSGZ  'BLDL FAILED'
MSG38    MSGZ  'NOT A PDS'
MSG40    MSGZ  'PFK HAS BEEN RESET'
MSG41    MSGZ  'INVALID PFK COMMAND'
ASIST    DC    64X'4B',X'40',9X'4B'
         DC    X'4A4B4C4D4E4F'       CENT,PERIOD,LESS,LPAREN,PLUS,BAR
         DC    X'50',9X'4B'          AMPERSAND
         DC    X'5A5B5C5D5E5F'       EXCL,$,DOT,RPAREN,SEMI,NOT
         DC    X'6061',8X'4B'        HYPHEN,SLASH
         DC    X'6A6B6C6D6E6F'       WHAT,COMMA,PERCENT,UNDLN,GT,QM
         DC    9X'4B',X'79'          70-78
         DC    X'7A7B7C7D7E7F'       COLON,POUND,AT,APOST,EQ,DBLQUOTE
         DC    X'4B'
         DC    X'818283848586878889',7X'4B'
         DC    X'919293949596979899',8X'4B'
         DC    X'A2A3A4A5A6A7A8A9',23X'4B'
         DC    C'ABCDEFGHI',7X'4B'
         DC    C'JKLMNOPQR',8X'4B'
         DC    C'STUVWXYZ',06X'4B'
         DC    C'0123456789',6X'4B'
CAPST    DC    64X'4B',X'40',9X'4B'
         DC    X'4A4B4C4D4E4F'       CENT,PERIOD,LESS,LPAREN,PLUS,BAR
         DC    X'50',9X'4B'          AMPERSAND
         DC    X'5A5B5C5D5E5F'       EXCL,$,DOT,RPAREN,SEMI,NOT
         DC    X'6061',8X'4B'        HYPHEN,SLASH
         DC    X'6A6B6C6D6E6F'       WHAT,COMMA,PERCENT,UNDLN,GT,QM
         DC    9X'4B',X'79'          70-78
         DC    X'7A7B7C7D7E7F'       COLON,POUND,AT,APOST,EQ,DBLQUOTE
         DC    X'4B'
         DC    C'ABCDEFGHI',7X'4B'
         DC    C'JKLMNOPQR',8X'4B'
         DC    C'STUVWXYZ',23X'4B'
         DC    C'ABCDEFGHI',7X'4B'
         DC    C'JKLMNOPQR',8X'4B'
         DC    C'STUVWXYZ',06X'4B'
         DC    C'0123456789',6X'4B'
SCREEN   DCS   X'40',SBA,24,80,SBA,1,1
         DCS   SF,PROHI
SCRDSN   DC    55C'-'
         DC    C' LINE '
SCRLINE  DCS   C'00000'
         DCS   C' COL '
SCRCOL   DCS   C'001 080 '
         DCS   SF,PROHI,C'INPUT >>--->'
         DCS   SF,UNPHI,RTA,02,71,X'00'
         DCS   SF,PROHI,C'RANGE'
SCRRGE   DCS   SF,UNPHI,C'20'      START WITH RANGE EQUAL PAGE
         DCS   SF,PROLO
SCREENL  EQU   *-SCREEN
SCRDATA  EQU   *
SCRPAD   DCS   RTA,24,80,C' '
SCRSUF   DCS   SBA,02,15,IC
         SPACE
FLD1BA   DCS   2,15
FLD2BA   DCS   2,78
         SPACE
MARKS    DC    18C'----+'
         SPACE
ERAZE    DCS   X'40',SBA,24,79,SBA,1,1
         DCS   RTA,7,1,X'00',RTA,13,1,X'00'
         DCS   RTA,19,1,X'00',RTA,1,1,X'00',IC
ERAZEL   EQU   *-ERAZE
*
*               TRANSLATE TABLES
*
FINDSBA  DC    17X'00',X'11',238X'00'
NUMERIC  DC    240X'FF',10X'00',6X'FF'
HEXDATA  DC    193X'FF',6X'00',41X'FF',10X'00',6X'FF'
         SPACE
TABNONBL DC    64X'FF'
         DC    X'00'               BLANK
         DC    42X'FF'
         DC    X'FF'               COMMA
         DC    148X'FF'
TABBLANK DC    64X'00'
         DC    X'40'               BLANK
         DC    42X'00'
         DC    X'00'               COMMA
         DC    148X'00'
TABQUOTE DC    125X'00',X'7D',130X'00'
         SPACE
KAPS     DC    129AL1(*-KAPS)      00-80
         DC    9AL1(*-KAPS+X'40')  81-89 BECOME C1-C9
         DC    7AL1(*-KAPS)        8A-90
         DC    9AL1(*-KAPS+X'40')  91-99 BECOME D1-D9
         DC    8AL1(*-KAPS)        9A-A1
         DC    8AL1(*-KAPS+X'40')  A2-A9 BECOME E2-E9
         DC    86AL1(*-KAPS)       AA-FF
         SPACE
*SNAPD   DCB   DDNAME=SNAPOUT,MACRF=(W),DSORG=PS,
*              RECFM=VBA,LRECL=125,BLKSIZE=882
SNAPD    DC    0F'0',20X'00',A(1),X'00004000',A(1,1),X'54',AL3(0)
         DC    CL8'SNAPOUT',X'02000020',A(1,1),AL2(0,882)
         DC    A(0,1,1,1),AL2(0,125),A(1)
SNAPDL   EQU   *-SNAPD
SNAPL    SNAP  DCB=0,ID=7,PDATA=(REGS),LIST=0,MF=L
SNAPLL   EQU   *-SNAPL
         DC    0D'0'               END OF CSECT
         SPACE
************************************************************
*                                                          *
*        PARSE PARAMETERS                                  *
*                                                          *
************************************************************
         SPACE
         PRINT NOGEN
REVPCL   IKJPARM
DSN      IKJPOSIT DSNAME,PROMPT='DATA SET NAME'
UNITKW   IKJKEYWD
         IKJNAME 'UNIT',SUBFLD=UNITSF
VOLKW    IKJKEYWD
         IKJNAME 'VOLUME',SUBFLD=VOLSF
FILEKW   IKJKEYWD
         IKJNAME 'FILE'
QUICKW   IKJKEYWD
         IKJNAME 'QUICK'
UNITSF   IKJSUBF
UNIT     IKJIDENT 'UNIT NAME',                                         +
               FIRST=ALPHANUM,OTHER=ALPHANUM,MAXLNTH=8,                +
               PROMPT='UNIT NAME'
VOLSF    IKJSUBF
VOL      IKJIDENT 'VOLUME SERIAL',                                     +
               FIRST=ALPHANUM,OTHER=ALPHANUM,MAXLNTH=6,                +
               PROMPT='VOLUME SERIAL'
         IKJENDP
         PRINT GEN
         SPACE
************************************************************
*                                                          *
*        DSECTS                                            *
*                                                          *
************************************************************
         SPACE
@DATA    DSECT
         DS    18F                 REGISTER SAVEAREA
SIZE     DS    F                   SIZE OF THIS AREA
CPPLPTR  DS    F
LINKAREA DS    2F
BASE1    DS    4F
BASE2    DS    3F
RET1     DS    F
MYPPL    DS    7F
MYANS    DS    F
MYECB    DS    F                   USED BY PUTLINE ROUTINE
MYIOPL   DS    4F                  USED BY PUTLINE ROUTINE
MYPTPB   DS    3F                  USED BY PUTLINE ROUTINE
MYOLD    DS    2F                  USED BY PUTLINE ROUTINE
MYSEG1   DS    2H,CL256            USED BY PUTLINE ROUTINE
PUTLINS  DS    4F                  USED BY PUTLINE ROUTINE
MYPUTLEP DS    F                   ADDRESS OF IKJPUTL
MYSTPB   DS    0F                  5 WORDS USED BY STACK DELETE
MYDAPL   DS    5F
MYDAPB   DS    21F
MYDFPB   DS    5F
UDSNAME  DS    2H,CL44
$DSNAME  DS    H,CL44
$MEMBER  DS    CL8
$PASSWRD DS    CL8
$DDNAML  DS    H                   THESE
$DDNAME  DS    CL8                  THREE
$CONCAT  DS    CL36                  TOGETHER
$VOLSER  DS    CL6
$UCBAD   DS    F
$UNIT    DS    CL8
DSNAIM   DS    H,CL44
DSPLUS   DS    H,CL54
CALLSMFA DS    F
CALLPARM DS    4F
CALLSAVE DS    10D                 18 WORD SAVE AREA PLUS 1 DOUBLE WORD
LOCATEW  DS    0F
OBTAINW  DS    4F
LOCBUF   DS    0D                  USES NEXT 265 BYTES
MYDSCB   DS    CL140               96 BYTES OF DSCB, 5 BYTES CCHHR
MSG      DS    CL128
STATUS   DS    X
STALLOC  EQU   X'80'
STOPEN   EQU   X'40'
STABEND  EQU   X'20'
STLOCAT  EQU   X'10'
STGMVU   EQU   X'08'
STRECV   EQU   X'04'
STEOF    EQU   X'02'
STNOMEM  EQU   X'01'
MODE     DS    X
MODEX    EQU   X'80'
SMFSW    DS    X
SMFBIT   EQU   X'80'
DSORG    DS    X
TSTRECFM DS    X
FINDSW   DS    X
RC       DS    H
FILEKV   DS    H
QUICKV   DS    H
MYDFPARM DS    5F  USED BY DAIRFAIL
MYDFREGS DS    F   USED BY DAIRFAIL
MYDFRC   DS    F   USED BY DAIRFAIL
MYJEFF02 DS    F   USED BY DAIRFAIL
MYDFID   DS    H   USED BY DAIRFAIL
DOUBLE   DS    D
COLNUM   DS    CL6
         DS    CL2
DAIRREGS DS    F
OPEND    DS    0F
CLOSED   DS    F
DYNEXLST DS    2F
KOUNT    DS    F
DYNDCBW  DS    0D,XL(SEQDCBL)
DYNDECBW DS    0F,XL(DYNDECBL)
RANGE    DS    2F
ANSWER   DS    2F
GMVUW    DS    0F,XL(GMVUL)
SAVSPANL DS    F
SAVLRECL DS    F
SAVBLKSI DS    F
SAVHOLDL DS    F
BLOCKPTR DS    F
SPANPTR  DS    F
HOLDPTR  DS    F
CHKPTTOP DS    F
CHKPTBOT DS    F
CHKPTDUM DS    2F
ENDPTR   DS    F
HOLDTOP  DS    F
HOLDEND  DS    F
HOLDDIR  DS    88F
DIRNUM   EQU   0
DIRLEN   EQU   4
DIRREC   EQU   8
DIRNXT   EQU   12
DIRSIZ   EQU   16
OFFSET   DS    H
RECSIZE  DS    H
COUNT    DS    F
TTR      DS    F
TTRZ     DS    F                   TTR + 0 FOR POINT
TTRK     DS    F                   TTR + CONCAT FOR FIND
SCROLL   DS    F
DOWNAMT  DS    F
LISTNUM  DS    F
AIMFOR   DS    F
FLDPTR   DS    F
FLDLEN   DS    F
CMDPTR   DS    F
CMDLEN   DS    F
CMDAREA  DS    CL63
MSGDSN   DS    CL55
SBASAVE  DS    4F
FINDCOL  DS    H
FNDNUM   DS    F
FNDOFF   DS    H
STRINGL  DS    H
STRING   DS    CL64
OPDL     DS    0F                  OPERAND DESCRIPTOR LIST
OPD0     DS    2F                  COMMAND DESCRIPTOR
OPD1     DS    2F                  OPERAND DESCRIPTOR 1
OPD2     DS    2F                  OPERAND DESCRIPTOR 2
OPD3     DS    2F                  OPERAND DESCRIPTOR 3
OPD4     DS    2F                  OPERAND DESCRIPTOR 4
OPD5     DS    2F                  OPERAND DESCRIPTOR 5
OPDLL    EQU   *-OPDL              LENGTH OF LIST
PRESENT  EQU   X'80'
QUOTED   EQU   X'40'
HOLDR    DS    F
READR    DS    F
DOWNR    DS    F
DEBLOCKS DS    3F
SCREENF  DS    F
TGETREGS DS    3F
SYNADSW  DS    F
SYNADMSG DS    CL78
DEVDATA  DS    2F
JFCB     DS    0F,CL176
POOLSIZ  DS    F
POOLLEN  DS    2F
         DS    0D
REPLY    DS    CL256
PERIODS  DS    CL256
BLDL     DS    0H,CL80
PFKTAB   DS    12CL64,CL1
PFKTABL  EQU   64                  LENGTH OF EACH ENTRY
SNAPDW   DS    0F,(SNAPDL)X
SNAPLW   DS    0F,(SNAPLL)X
SNAPR    DS    4F
SCREENW  DS    0D,3072C
@DATAEND EQU   *
@DATAL   EQU   *-@DATA
         SPACE
IHADCB   DSECT
         DS    32XL1
DCBBFTEK DS    XL1
DCBEODAD DS    AL3
DCBRECFM DS    X
DCBEXLSA DS    AL3
DCBDDNAM DS    CL8
DCBOFLGS DS    X
         DS    7XL1
         DS    X
DCBSYNAD DS    AL3
DCBBLKSI EQU   IHADCB+62,2
DCBLRECL EQU   IHADCB+82,2
         SPACE
         IKJCPPL
         SPACE 3
         IKJPPL
         SPACE
         IKJDFPB
         SPACE 2
         IKJUPT
         SPACE 2
         IKJIOPL
         SPACE 2
         IKJDAPL
         SPACE 2
         IKJDAP08
         SPACE 2
         IKJDAP18
         SPACE 2
         IKJPSCB
         SPACE 2
QUOTE    EQU   X'7D'
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         MACRO
&NAME    DCS
.**********************************************************************
.*                                                                    *
.*        DCS  -  DEFINE CONSTANT FOR SCREEN                          *
.*                                                                    *
.*        WRITTEN BY BILL GODFREY                                     *
.*        PLANNING RESEARCH CORPORATION                               *
.*        PRC COMPUTER CENTER, MCLEAN VA 22101                        *
.*        DATE WRITTEN. JANUARY 8 1981.                               *
.*        DATE UPDATED. MARCH 18 1982. (ROW AND COL IN PARENS)        *
.*                                                                    *
.*        THIS MACRO IS USED FOR CODING A FULLSCREEN 3270 DISPLAY.    *
.*                                                                    *
.*        SAMPLE                                                      *
.*           DCS    AL1(WCC),SBA,(1,1),RTA,(7,1),X'00',IC             *
.*                                                                    *
.*        IT SIMPLIFIES THE CODING OF A SCREEN IN THE FOLLOWING WAYS. *
.*        .  BUFFER ADDRESSES ARE SPECIFIED AS ROW AND COLUMN NUM-    *
.*           BER.  THE MACRO TRANSLATES THEM INTO THE 3270 CODE.      *
.*        .  ORDERS ARE SPECIFIED BY NAME, SUCH AS 'SBA' AND 'SF',    *
.*           SO YOU DONT HAVE TO KNOW THE HEX CODES FOR THEM,         *
.*        .  COMMONLY USED ATTRIBUTE BYTES ARE SPECIFIED BY NAME      *
.*           (A SET OF RESERVED NAMES) SO YOU DONT HAVE TO KNOW       *
.*           THE HEX CODES FOR THEM.                                  *
.*        .  IT SAVES A LOT OF DOCUMENTATION WORK, AND MAKES          *
.*           THE CODE EASIER FOR OTHERS TO UNDERSTAND.                *
.*                                                                    *
.*        THE USER OF THE MACRO MUST STILL UNDERSTAND HOW A SCREEN    *
.*        IS CONSTRUCTED BEFORE USING IT. THE MACRO MERELY MAKES IT   *
.*        EASIER TO SPECIFY THE VALUES.  IT DOES VERY LITTLE ERROR    *
.*        CHECKING.  FOR INSTANCE, IT DOES NOT CHECK TO SEE IF        *
.*        YOU FOLLOW AN 'SBA' WITH A BUFFER ADDRESS.  IT IS POSSIBLE  *
.*        TO CODE A THOROUGHLY INVALID SCREEN.                        *
.*                                                                    *
.*        THE MACRO MAY HAVE ANY NUMBER OF OPERANDS, CONSISTING OF    *
.*        ANY COMBINATION OF THE FOLLOWING.                           *
.*                                                                    *
.*        .  AN ORDER.                                                *
.*           VALID ORDERS ARE: SBA, SF, RTA, IC, PT, EUA.             *
.*        .  A BUFFER ADDRESS IN PARENTHESES.                         *
.*           IF AN OPERAND IS IN PARENTHESES, IT IS ASSUMED THAT      *
.*           THE ROW AND COLUMN NUMBER ARE BETWEEN THE PARENS,        *
.*           SEPARATED BY A COMMA.  EXAMPLE: (1,1)                    *
.*           THIS FORM OF BUFFER ADDRESS IS NEW AS OF MARCH 18 1982.  *
.*        .  A ROW OR COLUMN NUMBER OF A BUFFER ADDRESS (OLD FORMAT). *
.*           IF AN OPERAND IS NUMERIC, IT IS ASSUMED TO BE            *
.*           A ROW OR COLUMN NUMBER.  IT TAKES 2 OPERANDS TO          *
.*           SPECIFY THE BUFFER ADDRESS (ROW AND COLUMN) SO NUMERIC   *
.*           OPERANDS MUST ALWAYS BE SPECIFIED IN PAIRS, THE          *
.*           FIRST BEING THE ROW AND THE SECOND BEING THE COLUMN.     *
.*           THIS FORMAT IS SUPPORTED ONLY FOR COMPATIBILITY WITH     *
.*           THE ORIGINAL VERSION OF THIS MACRO.                      *
.*        .  AN ATTRIBUTE BYTE.                                       *
.*           VALID ATTRIBUTE BYTES ARE:                               *
.*           UNPLO -  UNPROTECTED NORMAL INTENSITY                    *
.*           UNPHI  - UNPROTECTED HIGH INTENSITY                      *
.*           UNPNP  - UNPROTECTED NO-DISPLAY                          *
.*           PROLO  - PROTECTED NORMAL INTENSITY                      *
.*           PROLOS - PROTECTED NORMAL INTENSITY AUTO-SKIP            *
.*           PROHI  - PROTECTED HIGH INTENSITY                        *
.*           PROHIS - PROTECTED HIGH INTENSITY AUTO-SKIP              *
.*        .  A HEX, CHARACTER, OR ADDRESS CONSTANT.                   *
.*           FOR EXAMPLE, X'00', OR C'ENTER SIGNON'                   *
.*           THIS CAN BE USED FOR DATA WITHIN FIELDS OR FOR           *
.*           ATTRIBUTE BYTES, ORDERS, THE 'WCC', OR BUFFER            *
.*           ADDRESSES (IF YOU WANT TO FIGURE THEM OUT).              *
.*                                                                    *
.*        IF THE OPERANDS DO NOT ALL FIT ON ONE LINE, YOU CAN         *
.*        EITHER CONTINUE THE LINE IN THE STANDARD ASSEMBLER WAY      *
.*        OR CODE THE MACRO AGAIN ON THE NEXT LINE WITH THE           *
.*        REMAINING OPERANDS.  THE RESULT IS THE SAME EITHER WAY.     *
.*                                                                    *
.*        THE BUFFER ADDRESS CONVERSIONS ARE FOR A                    *
.*        SCREEN SIZE OF 24 ROWS BY 80 COLUMNS. FOR SCREENS           *
.*        OF OTHER DIMENSIONS (43 BY 80, 12 BY 40) THE MACRO          *
.*        NEEDS ONLY A FEW CHANGES.                                   *
.*                                                                    *
.*        WARNING: IF YOU CODE THE MACRO WITH A LABEL IN COLUMN 1,    *
.*        AND YOU LIKE USING LENGTH ATTRIBUTES, BEWARE THAT THE       *
.*        LENGTH ATTRIBUTE OF THE LABEL IS NOT NECESSARILY THE        *
.*        TOTAL LENGTH OF THE DATA GENERATED BY THE MACRO.            *
.*                                                                    *
.**********************************************************************
.*
         LCLA  &R,&C,&P,&Q
         LCLA  &AN,&AS,&AL
         LCLB  &B,&NUMERIC,&INTEGER
         LCLC  &T(64)
         LCLC  &N,&ROW,&COL
         LCLC  &CS,&STRING
&T(1)    SETC  '40'
&T(2)    SETC  'C1'
&T(3)    SETC  'C2'
&T(4)    SETC  'C3'
&T(5)    SETC  'C4'
&T(6)    SETC  'C5'
&T(7)    SETC  'C6'
&T(8)    SETC  'C7'
&T(9)    SETC  'C8'
&T(10)   SETC  'C9'
&T(11)   SETC  '4A'
&T(12)   SETC  '4B'
&T(13)   SETC  '4C'
&T(14)   SETC  '4D'
&T(15)   SETC  '4E'
&T(16)   SETC  '4F'
.*
&T(17)   SETC  '50'
&T(18)   SETC  'D1'
&T(19)   SETC  'D2'
&T(20)   SETC  'D3'
&T(21)   SETC  'D4'
&T(22)   SETC  'D5'
&T(23)   SETC  'D6'
&T(24)   SETC  'D7'
&T(25)   SETC  'D8'
&T(26)   SETC  'D9'
&T(27)   SETC  '5A'
&T(28)   SETC  '5B'
&T(29)   SETC  '5C'
&T(30)   SETC  '5D'
&T(31)   SETC  '5E'
&T(32)   SETC  '5F'
.*
&T(33)   SETC  '60'
&T(34)   SETC  '61'
&T(35)   SETC  'E2'
&T(36)   SETC  'E3'
&T(37)   SETC  'E4'
&T(38)   SETC  'E5'
&T(39)   SETC  'E6'
&T(40)   SETC  'E7'
&T(41)   SETC  'E8'
&T(42)   SETC  'E9'
&T(43)   SETC  '6A'
&T(44)   SETC  '6B'
&T(45)   SETC  '6C'
&T(46)   SETC  '6D'
&T(47)   SETC  '6E'
&T(48)   SETC  '6F'
.*
&T(49)   SETC  'F0'
&T(50)   SETC  'F1'
&T(51)   SETC  'F2'
&T(52)   SETC  'F3'
&T(53)   SETC  'F4'
&T(54)   SETC  'F5'
&T(55)   SETC  'F6'
&T(56)   SETC  'F7'
&T(57)   SETC  'F8'
&T(58)   SETC  'F9'
&T(59)   SETC  '7A'
&T(60)   SETC  '7B'
&T(61)   SETC  '7C'
&T(62)   SETC  '7D'
&T(63)   SETC  '7E'
&T(64)   SETC  '7F'
.*
&N       SETC  '&NAME'
&AN      SETA  N'&SYSLIST          NUMBER OF OPERANDS
&AS      SETA  0
&B       SETB  0 FALSE
.EACH    AIF   (&AN EQ 0).EPILOG
&AS      SETA  &AS+1
&CS      SETC  '&AS'
&AL      SETA  K'&SYSLIST(&AS)
         AIF   (T'&SYSLIST(&AS) EQ 'O').NEXT
         AIF   ('&SYSLIST(&AS)'(1,1) EQ '(').PAIR
&NUMERIC SETB  (T'&SYSLIST(&AS) EQ 'N')
&INTEGER SETB  ('&SYSLIST(&AS)'(1,1) GE '0')
         AIF   (&NUMERIC AND &INTEGER).ROWCOL
         AIF   (NOT &B).ROWCOLX
         MNOTE 4,'             &CS.) MISSING COLUMN NUMBER'
&B       SETB  0 FALSE
.ROWCOLX ANOP
&STRING  SETC  '&SYSLIST(&AS)'
.*             ORDERS
         AIF   ('&STRING' EQ 'SBA').SBA
         AIF   ('&STRING' EQ 'SF').SF
         AIF   ('&STRING' EQ 'RTA').RTA
         AIF   ('&STRING' EQ 'IC').IC
         AIF   ('&STRING' EQ 'PT').PT
         AIF   ('&STRING' EQ 'EUA').EUA
.*             ATTRIBUTES
         AIF   ('&STRING' EQ 'UNPLO').UNPLO
         AIF   ('&STRING' EQ 'UNPHI').UNPHI
         AIF   ('&STRING' EQ 'UNPNP').UNPNP
         AIF   ('&STRING' EQ 'PROLO').PROLO
         AIF   ('&STRING' EQ 'PROLOS').PROLOS
         AIF   ('&STRING' EQ 'PROHI').PROHI
         AIF   ('&STRING' EQ 'PROHIS').PROHIS
.*             CONSTANTS
.*             IF THE OPERAND IS NONE OF THE ABOVE, IT IS
.*             PRESUMED TO BE ANY VALID 'DC' CONSTANT.
.DC      ANOP
&N       DC    &STRING
         AGO   .NEXT
.SBA     ANOP
&N       DC    X'11'               SET BUFFER ADDRESS
         AGO   .NEXT
.SF      ANOP
&N       DC    X'1D'               START FIELD
         AGO   .NEXT
.RTA     ANOP
&N       DC    X'3C'               REPEAT TO ADDRESS
         AGO   .NEXT
.IC      ANOP
&N       DC    X'13'               INSERT CURSOR
         AGO   .NEXT
.PT      ANOP
&N       DC    X'05'               PROGRAM TAB
         AGO   .NEXT
.EUA     ANOP
&N       DC    X'12'               ERASE UNPROTECTED TO ADDRESS
         AGO   .NEXT
.UNPLO   ANOP
&N       DC    X'40'               UNPROTECTED NORMAL INTENSITY
         AGO   .NEXT
.UNPHI   ANOP
&N       DC    X'C8'               UNPROTECTED HIGH INTENSITY
         AGO   .NEXT
.UNPNP   ANOP
&N       DC    X'4C'               UNPROTECTED NO-DISPLAY
         AGO   .NEXT
.PROLO   ANOP
&N       DC    X'60'               PROTECTED NORMAL INTENSITY
         AGO   .NEXT
.PROLOS  ANOP
&N       DC    X'F0'               PROTECTED NORMAL INTENSITY SKIP
         AGO   .NEXT
.PROHI   ANOP
&N       DC    X'E8'               PROTECTED HIGH INTENSITY
         AGO   .NEXT
.PROHIS  ANOP
&N       DC    X'F8'               PROTECTED HIGH INTENSITY SKIP
         AGO   .NEXT
.**********************************************************************
.PAIR    ANOP
         AIF   (N'&SYSLIST(&AS) NE 2).PERR1
&NUMERIC SETB  (T'&SYSLIST(&AS,1) EQ 'N')
&INTEGER SETB  ('&SYSLIST(&AS,1)'(1,1) GE '0')
         AIF   (NOT &NUMERIC OR NOT &INTEGER).PERR2
&R       SETA  &SYSLIST(&AS,1)
&NUMERIC SETB  (T'&SYSLIST(&AS,2) EQ 'N')
&INTEGER SETB  ('&SYSLIST(&AS,2)'(1,1) GE '0')
         AIF   (NOT &NUMERIC OR NOT &INTEGER).PERR2
&C       SETA  &SYSLIST(&AS,2)
         AIF   (&R LT 1 OR &R GT 24).ROWERR
         AIF   (&C LT 1 OR &C GT 80).COLERR
&P       SETA  (&R-1)*80+&C-1
&Q       SETA  &P/64               QUOTIENT
&R       SETA  &P-&Q*64+1          REMAINDER+1
&Q       SETA  &Q+1                QUOTIENT+1
&N       DC    X'&T(&Q)&T(&R)'     ROW AND COLUMN
         AGO   .NEXT
.PERR1   MNOTE 4,'             &CS.) PARENS FOUND BUT NOT 2 NUMBERS'
         MEXIT
.PERR2   MNOTE 4,'             &CS.) NON NUMERIC ROW/COLUMN'
         MEXIT
.**********************************************************************
.ROWCOL  ANOP
         AIF   (&B).COL            BRANCH IF ROW HAS BEEN CAPTURED
&R       SETA  &SYSLIST(&AS)
&B       SETB  1 TRUE              SET ROW-HAS-BEEN-CAPTURED
         AGO   .NEXTR
.COL     ANOP
&C       SETA  &SYSLIST(&AS)
&B       SETB  0 FALSE             RESET SWITCH
         AIF   (&R LT 1 OR &R GT 24).ROWERR
         AIF   (&C LT 1 OR &C GT 80).COLERR
&P       SETA  (&R-1)*80+&C-1
&Q       SETA  &P/64               QUOTIENT
&R       SETA  &P-&Q*64+1          REMAINDER+1
&Q       SETA  &Q+1                QUOTIENT+1
&N       DC    X'&T(&Q)&T(&R)'     ROW AND COLUMN
         AGO   .NEXT
.ROWERR  MNOTE 4,'             &CS.) VALUE &R INVALID, MUST BE 1 TO 24'
         AGO   .NEXT
.COLERR  MNOTE 4,'             &CS.) VALUE &C INVALID, MUST BE 1 TO 80'
.NEXT    ANOP
&N       SETC  ''                  TURN OFF NAME
.NEXTR   ANOP
&AN      SETA  &AN-1
         AGO   .EACH
.EPILOG  ANOP
         MEND
         END
