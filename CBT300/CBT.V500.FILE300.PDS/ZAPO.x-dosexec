ZAP      TITLE 'ZAP --- DISPLAY AND MODIFY DATA SETS   ---   TSO'
***********************************************************************
*                                                                     *
*  THIS PROGRAM HAS BEEN THOROUGHLY TESTED, HOWEVER, NO               *
*  RESPONSIBILITY OF ANY KIND CAN BE ASSUMED FOR ITS RELIABLE OR      *
*  CORRECT OPERATION.  THIS PROGRAM MAY NOT BE FURTHER DISTRIBUTED    *
*  WITHOUT THE WRITTEN PERMISSION OF THE AUTHORS.                     *
*                                                                     *
***********************************************************************
         SPACE 3
***********************************************************************
*                                                                     *
*  U C L A / O A C   ' Z A P '   T S O  C O M M A N D                 *
*                                                                     *
***********************************************************************
* UPDATES:                                                            *
*                                                                     *
*  10/02/81 AFDSC: MODS AT AFDSC/PENTAGON BY BILL GODFREY:            *
*                  SUPPORT PFK3 AS 'END'.                             *
*                  SUPPORT PFK5 AS 'L' (REPEAT LOCATE OR FIND)        *
*                  SUPPORT PFK7 AS 'U' (UP)                           *
*                  SUPPORT PFK8 AS 'D' (DOWN)                         *
*                  CHECK FOR PRE-ALLOCATED 'ZAPLOG' DD. THIS ALLOWS   *
*                  USER TO PUT THE LOG SOMEWHERE BESIDES SYSOUT(A).   *
*                  OACTMP MISSING. BYPASS INSERTED TO AVOID ABEND806. *
*                  OACNOW MISSING. WROTE OUR OWN VERSION.             *
*                  CALL INSTEAD OF LINK TO OACNOW.                    *
*                  FREEMAIN THE AREA RETURNED BY OUR OACNOW.          *
*                  SOURCE FOR OUR OACNOW APPENDED FOR BATCH ASSEMBLY. *
*                  CHANGE TITLE LINE ON LOG LISTING.                  *
*                                                                     *
*  12/18/80 MAS3:  ASK AT EXIT IF ZAP LOG REQUIRED, DELETE IF 'NO'    *
*                                                                     *
*  12/18/80 MAS2:  NAME(E) COMMAND - FIND TEXT BLOCK BY ORIG IN       *
*                   PREVIOUS CONTROL RECORD (NOT JUST COUNTING BYTES) *
*                  ADD J COMMAND - 'P' RELATIVE TO VOLUME             *
*                  FIX "INPUT DATA LOST" (TRCHARE HAS NO ORG AT END)  *
*                  DELETE 'FCME' COMMAND                              *
*                                                                     *
*  12/18/80 MAS1:  REMOVE ALL &CCN CODE (NO MORE CCN/MVT)             *
*                  INCLUDE ZAPS --                                    *
*                   VSAPL ZCODE TABLE                                 *
*                   GTSIZE CODE TO ALLOW OTHER THAN 24 LINE SCREENS   *
*                                                                     *
*  12/27/79 LDW5:  MODIFY FULLSCREEN FLAGS LOGIC (F3270 FSMODE)       *
*                  SIMPLIFY "DO" COMMAND CODE                         *
*                  DELETE "RESHOW" COMMAND                            *
*                  FIX "WINDOW" COMMAND BUG                           *
*                  CHANGE VERSION TO 2.3                              *
*                  CHANGE SENSITIVE DATASET CRITERIA FOR GIBRALTAR    *
*                  MERGE "INITSHOW" FLAG INTO "RESHOWF"               *
*                  PRE-BLANK REPLY BUFFER AFTER PUTGET                *
*  12/27/79 SDM6:  FIX COMSCAN TO HANDLE ZERO LENGTH REPLIES RIGHT    *
*                  FIX SHORT RESPONSE LOGIC FOR FULLSCR SUPPORT       *
*  11/29/79 LDW4:  FIX IDR & LOG USERID                               *
*                  PAUSE 'F' AT DS1LSTAR                              *
*                  ADD 'WM' ALIAS FOR WHATMEM COMMAND                 *
*                  MAKE JCJ HAPPY: SAME CMD TWICE IN A ROW WILL GET   *
*                       OUT OF A MODIFIED BLOCK WITHOUT "ZAP"ING IT   *
*                       ("NOZAP" COMMAND REMOVED)                     *
*                  CHANGE TO VERSION 2.2B                             *
*                  CHANGE MESSAGE ID'S FROM CSM3XX TO ZAP0XX          *
*                  FORCE LOG FOR ANY SYSN. DATASET                    *
*                  CHANGE TITLE ON LOG FROM UCLA-CCN TO GIS           *
*                  ADD USID TO ALLOCDSN PARSE ENTRY                   *
*                  ROUND UP BY 50 BYTES THE SIZE OF THE GETMAIN'D BUF *
*                  MOVE LASTDS1 TO ITS OWN FIELD                      *
*                  DIDDLE CODE IN 'FORMAT' TO PREVENT 0C4'S           *
*  11/28/79 SDM5:  CHANGE LINE01 LENGTH TO NORMAL                     *
*                  IMPROVE PARTIAL SCREEN DISPLAY CODE                *
*                  IMPROVE TGET ASIS CODE                             *
*                  MOVE BASE FROM R7 TO R9                            *
*  11/27/79 SDM4:  ELIMINATE 'UNLOCK KEYBOARD' FROM 3270 OUTPUT       *
*                  FIX ERROR MESSAGE BLANKING BUG                     *
*                  FIX HELP PROMPT FIELD CLEAR LENGTH BUG             *
*                  FIX HELP PROMPT FIELD MDT BUG                      *
*  11/09/79 SDM3:  FIX INTERMITTENT 0C4 IN 'L' COMMAND                *
*  09/26/79 SDM2:  ADD ROUTCDE=9 (SECURITY) TO WTO                    *
*  09/05/79 LDW3:  DELETE ALL SSL CODE                                *
*  08/07/79 SDM1:  1) CHANGE TGET WHEN IN FULLSCREEN MODE TO ASIS     *
*                  2) ADD ROUTCDE=2 (MASTER CONSOLE) TO WTO           *
*  06/27/79 LDW2:  1) CHANGE FULLSCREEN I/O TO ONLY TPUT CHANGED LINES*
*                  2) FIX BUG IN FULLSCREEN HELP                      *
*                  3) ADD HELP INFO                                   *
*  05/05/79 LDW1:  THIS IS A MAJOR CLEANUP/REWRITE THAT KEPT MAINLY   *
*                       THE ORIGINAL FRAMEWORK, BUT ALMOST EVERYTHING *
*                       WAS CHANGED SOMEWHAT.                         *
*        1) CHANGE ACCESS METHOD FROM BDAM TO EXCP                    *
*        2) FIX SO "X" WORKS IF LOG IS ON                             *
*        3) FIX SO "ZAP REQ'D" WORKS IF LOG OFF                       *
*        4) CHANGE TPUT TO PUTLINE                                    *
*        5) MAKE SINGLE ASSEMBLY                                      *
*        6) INCLUDE CHAR FORM OF DATA AND ABS LOC IN LOG              *
*        7) VARIOUS RE-ARRANGING TO CONSERVE PAPER                    *
*        8) FULLSCREEN 3270 & SSL SUPPORT                             *
*        9) JUST "M" GIVES SAME MEMBER AGAIN (NOT DIRECTORY)          *
*       10) DELETE LOGTEST MACRO, PUT CODE IN SUBROUTINE              *
*       11) UPDATE IDR FOR ALL ENTRY POINTS SELECTED                  *
*       12) MISC CODE CLEANUP, EG "BLANKS", EQU'S FOR TTR+3           *
*       13) ADD DUMPE COMMAND TO DUMP CURRENT REC TO EOF              *
*       14) ADD LINELEN=80 FEATURE/OPTION                             *
*       15) DIDDLE BASE REGISTERS & ADD ONE                           *
*       16) VTOC SUPPORT                                              *
*       17) CHANGE CSOUT TO USE QSAM, LARGE BLKSIZE, FIX BUGS         *
*       18) FIX EXPR HANDLER TO MULT/DIV                              *
*       19) NEW CMDS:  WHATMEM, F, V, LASTDS1, U, DISP, %             *
*       20) SET LOG DEFAULT, FIX SO DELETED IF UNUSED                 *
*       21) REDESIGN "CHKPT" OPERATION                                *
*       22) USE 'HEX' MACRO                                           *
*       23) FIX 15 NIBBLE HEX STRING BUG                              *
*       24) ADD CONDITIONAL ASSEMBLY FOR MVT/MVS, SSL/NOSSL, CCN/Â¬CCN *
*  05/20/78 JCJ1:  1) PROPAGATE LPR URSA ZAP FIXES TO TSO ZAP         *
*                  2) PROPAGATE ABS COMMAND FROM URSA ZAP TO TSO ZAP  *
*                  3) FIX LOST SP 0 CORE AT EODAD BUG.                *
*                  4) FIX VERBOSE MODE MSG OVERLAY BUG.               *
*  12/20/75 VIC: ADD 'NAME' COMMAND TO LOCATE ENTRY POINTS/CSECTS  *N**
*                WITHIN LOAD MODULES                               *N**
*  09/12/75 WDD:                                                      *
*        . GET USERID FOR ZAP UPDATE RECORD, ALLOW USERS TO USE ZAP   *
*        . ALLOCATE DATASET PERM=NO, AND SET CORRECT DSNAME LENGTH    *
*                                                                     *
***********************************************************************
         SPACE 2
*  POSSIBLE NEW FEATURES;  BUGS;  THINGS TO CHECK
*  5) COMMAND STACKING
* 17) ENQ ON SPZAPLIB/SYSVTOC/SYSCTLG   (SPZAPLIB L'RNAME=44)
* 22) STORE TTR IN DEFINE TABLE, ADD P= COMMAND
* 26) OFFSET COMMAND?
* 36) RECORD MAY BE > 32K BYTES... BUT O/S WON'T LET IT, SO NO PROBLEM.
* 45) EXP IS SCREWED
* 46) SYSOUT ENQ LOG TO DEST C (DEST/BIN KEYWORDS?)
* 47) NOTE WHERE IDR'S ARE WHILE LOOKING FOR ENTRY POINT
* 48) DO 256 READ COUNTS
* 55) RN GOES TO NEXT TRACK IF CURR TRK DOESN'T HAVE N RECORDS
* 63) OFFSET IN LOG WILL BE FISHY IF NOT ADJUSTED FOR DISPC/K/D
* 71) AUTO "M" IF MEMBER GIVEN?
* 72) WSHORT & DELETE ALL 40 CHAR CODE?
* 74) DON'T POSITION CURSOR UNLESS RMOD
* 76) MAKE HELP USE LONGER SCREEN LINES
* 81) DON'T DISP COUNT AS PART OF REC, HAVE SET COUNT CMD
* 82) USE 'MSG' FOR HELPS.
* 83) CHANGE TRAILING BLANKS TO NULLS AT DISPLAY TIME
* 84) MOVE CSOUT MF=L TO TSDSECT
* 85) "FORMAT" COMMAND
* 86) SCAN OFF BLANKS BETWEEN COMMAND AND OPERAND
* 87) FEOF COMMAND TO FIND NEXT EOF
* 88) LC/UC COMMANDS                                               LDW4
* 89) BLKSIZE 0 SHOULD USE DEVTYPE FOR BUFLEN (WHAT ABOUT TRK OFLO?)
         SPACE 6
         MACRO
         PGPB  &J,&DSECT=YES
         AIF   ('&DSECT' NE 'YES').L1
PGPB     DSECT
         AGO   .L2
.L1      ANOP
PGPB     DS    0F
.L2      ANOP
***********************************************************************
*    THE PUTGET PARAMETER BLOCK (PGPB) IS POINTED TO BY THE LIST      *
*    PASSED TO PUTGET.  PUTGET USES IT FOR CONTROL AS WELL AS         *
*    RETURNING INFORMATION.                                           *
***********************************************************************
         DS    0F
         DS    CL12     INTERNAL TO GETLINE/PUTLINE
PGPBIBUF DS    A        PTR TO OBTAINED INPUT LINE
**/
         MEND
         MACRO
         TSDMPL
         SPACE 2
***********************************************************************
*
* (DMPL)       DAIR MESSAGE PARAMETER LIST
*
* FUNCTION     THE ADDRESS OF THIS PARAMETER LIST IS PASSED IN
*              REGISTER 1 BY THE INVOKER OF IKJEFF18 TO DIAGNOSE DAIR
*              ERRORS AND PRINT APPROPRIATE MESSAGES.
*
***********************************************************************
         SPACE 2
DMPL     DS    0F *                     DAIR MESSAGE PARAMETER LIST
DMPLDAPL DS    A *                      PTR TO THE DAPL ADDRESS
DMPLRC   DS    A *                      PTR TO THE DAIR RETURN CODE
DMPLMSG  DS    A *                      PTR TO A(IKJEFT02) IF LOADED
DMPLCALL DS    A *                      PTR TO THE CALLER NUMBER
DMPLCODE DS    0F *                     R15 SAVE IS DAIR RETURN CODE
DMPLSAVE DS    3F *                     REGISTER SAVEAREA FOR 15-1
DMPLL    EQU   *-DMPL *                 LENGTH OF THE DMPL
         SPACE 2
         MEND
         MACRO
&LBL     TSDAIR &Z,&DAPB=,&SYNAD=,&ENTRY=
         GBLB   &TSDAIRE                WAS TSDAIRER ROUTINE GENERATED
&LBL     OACINNER  F=&DAPB,T=DAPLDAPB,OP=MA,COM='DAPB ADDR'
         LA    1,DAPL
         AIF   ('&ENTRY' EQ '').NOENT
         $RXR  ,&ENTRY,15,A=            FROM REGISTER OR FULLWORD
         BALR  14,15
         AGO   .NOLINK
.NOENT   LINK  EP=IKJDAIR
.NOLINK  AIF   ('&SYNAD' EQ '').L1
         LTR   15,15
         BZ    TSD&SYSNDX+4
         LA    0,&SYNAD
         L     14,TSD&SYSNDX
         BR    14
         AIF   ('&SYNAD' EQ '').L0
         AIF   (&TSDAIRE).L0
         TSDAIRER
.L0      ANOP
TSD&SYSNDX DC  A(TSDAIRER)
.L1      MEND
         MACRO
         $RXQ  &TARGET,&SEND,&LEN
         GBLB  &OMITTED
&OMITTED SETB  0
         AIF   ('&SEND' EQ '' ).NOSEND
         AIF   ('&SEND'(1,1) EQ '(').REGSEND
         AIF   ('&SEND'(1,1) EQ '''').QSEND
         MVC   &TARGET,&SEND
         AGO   .END
.REGSEND MVC   &TARGET,0&SEND
         AGO   .END
.QSEND   MVC   &TARGET,=CL&LEN&SEND
         AGO   .END
.NOSEND  MVC   &TARGET,=CL&LEN' '       NOT SPECIFIED
&OMITTED SETB  1                        OPERAND WAS OMMITTED
.END     ANOP
         MEND
         MACRO
         $MF   &MAP,&REG,&MF,&FAKE1,&SP=
.******* &MAP=MAPPING DSECT NAME
.******* &REG=REGISTER FOR ADDRESSIBILITY
.******* &MF=(L|B|E,AREA)
         GBLB  &OMITTED,&DROP
         LCLC  &AREA
&OMITTED SETB  0
&DROP    SETB  0                        DO NOT DROP REGISTER
         AIF   ('&MF' NE '').MFYES
&OMITTED SETB  1                        PARAMETER WAS OMMITTED
.MFYES   ANOP
&AREA    SETC  'DAPBAREA'
         AIF   ('&MF(2)' EQ '').USEAREA
&AREA    SETC  '&MF(2)'
.USEAREA AIF   ('&MF(1)' EQ 'E' OR '&MF(1)' EQ '').MF1OK
         AIF   ('&MF(1)' EQ 'B').MF1OK
         AIF   ('&MF(1)' EQ 'L').MF1OK
         MNOTE 4,'MF=&MF(1) IS AN INVALID TYPE, MF=E ASSUMED'
.MF1OK   $RXR   ,&AREA,&REG             MF=(L|B|E,AREA)
         USING  &MAP,&REG               ADDRESSIBILITY
&DROP    SETB  1                        DROP REGISTER
         MEND
         MACRO
&LABEL   FREE  &DDNAME=,&DSN=,&MEMBER=,&PREFIX=NO,                     $
               &FILE=,&DATASET=,                                       $
               &SYSOUT=,                                               $
               &JOBNAME=,                                              $
               &DISP=,&PERM=YES,                                       $
               &MF=,&SYNAD=
         GBLB  &OMITTED,&DROP
         LCLA  &PERMBIT
&PERMBIT SETA  0                        PERM = X'10'
         AIF   ('&PERM' NE 'YES').NOTPERM
&PERMBIT SETA  16                       =X'10'
.NOTPERM ANOP
&LABEL   DS    0H
         $MF   DAPB18,15,&MF
         XC    DAPB18(DAPB18L),DAPB18   INITIALIZE DAIR BLOCK TO ZERO
         MVI   DA18CD+1,X'18'           DAIR ENTRY CODE FOR FREE
         $RXR  DA18PDSN,&DSN&DATASET,0  POINTER TO DSNAME
         $RXQ  DA18DDN,&DDNAME&FILE,8   DDNAME
         $RXQ  DA18JBNM,&JOBNAME,8      JOBNAME
         $RXQ  DA18SCLS,&SYSOUT,2       SYSOUT CLASS
         AIF   (&OMITTED).MEM
         MVI   DA18SCLS+1,C' '          BLANK 2ND BYTE OF OUTPUT CLASS
.MEM     $RXQ  DA18MNM,&MEMBER,8        MEMBER NAME
         AIF   ('&PREFIX' NE  'YES').NOPREF
         OI    DA18CTL,DA18UID+&PERMBIT PREFIX CHARGENO.USERID TO DSN
         AGO   .DISPOS
.NOPREF  AIF   ('&PERM' NE 'YES').DISPOS FREE PERM DATASET ?
         OI    DA18CTL,&PERMBIT         FREE PERMANENTLY ALLOCATED DS
.DISPOS  AIF   (T'&DISP    EQ 'O').NODISP2
         AIF   ('&DISP'    NE 'KEEP').DELETE2
         MVI   DA18DPS2,DA18KEEP        DISP=(,KEEP)
         AGO   .DISP3
.DELETE2 AIF   ('&DISP'    NE 'DELETE').CATLG2
         MVI   DA18DPS2,DA18DEL         DISP=(,DELETE)
         AGO   .DISP3
.CATLG2  AIF   ('&DISP'    NE 'CATLG').UNCAT2
         MVI   DA18DPS2,DA18CAT         DISP=(,CATLG)
         AGO   .DISP3
.UNCAT2  AIF   ('&DISP'    NE 'UNCATLG').DISPBAD
         MVI   DA18DPS2,DA18UCAT        DISP=(,UNCATLG)
         AGO   .DISP3
.NODISP2 ANOP
*        DISPOSITION SPECIFIED WHEN ALLOCATED WILL BE USED
         AGO   .DISP3
.DISPBAD ANOP
         MNOTE *,'*****************************************'
         MNOTE  12,'INVALID DISPOSITON, DISP= &DISP  '
         MNOTE  *,'*****************************************'
         AGO   .END
.DISP3   AIF   ('&MF(1)' EQ 'B').ENDB
         AIF   ('&MF(1)' EQ 'L').END
         TSDAIR DAPB=(15),SYNAD=&SYNAD
         AGO   .END
.ENDB    ST    15,DAPLDAPB
         LA    R1,DAPL
.END     AIF    (NOT &DROP).END1
         DROP  15               DROP ADDRESSIBLITY TO DAIR BLOCK
.END1    SPACE 3
         MEND
         MACRO
&NAME    TPUTX &BFF,&SIZE,&EDIT,&WAIT,&HOLD,&BRKI,&PRTY,&TJID=,        *
               &TJIDLOC=,&MF=I
         GBLA  &GETLENL
         GBLC  &$NFS
         LCLA  &K,&I,&BITS
         LCLA  &N,&MAXLEN
         LCLB  &ED,&WA,&HO,&BR,&PR
&$NFS    SETC  '&NAME'
&K       SETA  3                        NORMAL PLACE TO START SCAN
         AIF   ('&BFF' NE '').HAVEBFF
         MNOTE 8,'*** MESSAGE OR MESSAGE ADDR OMITTED.'
         MEXIT
.HAVEBFF AIF   ('&BFF'(1,1) NE '''').NOTQ
&K       SETA  K'&BFF-2                 LENGTH OF CHAR STRING
&N       SETA  2                        START AT FIRST TEXT CHAR
&MAXLEN  SETA  &K                       SET LENGTH OF CHAR STRING
.QLOOP   AIF   ('&BFF'(&N,2) NE '''''' AND '&BFF'(&N,2) NE '&&').QCONT
&K       SETA  &K-1                     ACCOUNT FOR DBLE CHAR
&N       SETA  &N+1                     FUDGE PAST
.QCONT   ANOP
&N       SETA  &N+1
         AIF   (&N LE &MAXLEN).QLOOP
&$NFS    LA    0,&K                     GET STRING LENGTH
&$NFS    SETC  ''                       NAME FIELD SYMBOL DONE
         LA    1,=C&BFF
&K       SETA  2                        ONLY ONE OPERAND FOR STRING
         AGO   .GOTPTRS
.NOTQ    ANOP
&$NFS    $RXR  ,&BFF,1                  LOAD BUFFER PTR
         $RXR  ,&SIZE,0                 LOAD BUFFER LENGTH
.GOTPTRS AIF   ('&TJID' EQ '' AND '&TJIDLOC' EQ '').NOTJID
         AIF   ('&TJID' EQ '').LOADTJ
&$NFS    $RXR  ,&TJID,14                GET TJID
         AGO   .ORTJ
.LOADTJ  ANOP
&$NFS    $RXR  ,&TJIDLOC,15             INDIRECT TJID
         LH    15,0(,15)                LOAD TJID
.ORTJ    SLL   15,16                    TJID INTO TOP HALF
         OR    0,15                     ADD TO PARM REG 0
.NOTJID  ANOP
&I       SETA  &K                       FIRST OPERAND TO CHECK
.LOOP    AIF   (&I GT N'&SYSLIST).SETOP IF ALL ARE PROCESSED, JUMP OUT
         AIF   ('&SYSLIST(&I)' EQ 'EDIT').EDIT
         AIF   ('&SYSLIST(&I)' EQ 'ASIS').ASIS
         AIF   ('&SYSLIST(&I)' EQ 'CONTROL').CONTROL
         AIF   ('&SYSLIST(&I)' EQ 'FULLSCR').FULLS
         AIF   ('&SYSLIST(&I)' EQ 'WAIT').WAIT
         AIF   ('&SYSLIST(&I)' EQ 'NOWAIT').NOWAIT
         AIF   ('&SYSLIST(&I)' EQ 'NOHOLD').NOHOLD
         AIF   ('&SYSLIST(&I)' EQ 'HOLD').HOLD
         AIF   ('&SYSLIST(&I)' EQ 'NOBREAK').NOBREAK
         AIF   ('&SYSLIST(&I)' EQ 'BREAKIN').BREAKIN
         AIF   ('&SYSLIST(&I)' EQ 'HIGHP').HIGHP
         AIF   ('&SYSLIST(&I)' EQ 'LOWP').LOWP
         AIF   ('&SYSLIST(&I)' EQ 'R').NEXTI
         AIF   ('&SYSLIST(&I)'(1,4) EQ 'TJID').SETOP
         MNOTE 8,'INVALID OPTION &SYSLIST(&I) - IGNORED'
.NEXTI   ANOP
&I       SETA  &I+1                     INCREMENT COUNTER
         AGO   .LOOP                    GET NEXT OPTION IF ANY
.MUTEX   MNOTE 8,'MUTUALLY EXCLUSIVE KEYWORDS'
         AGO   .NEXTI
.FULLS   ANOP
&BITS    SETA  &BITS+3                  SET ASIS+CONTROL FOR FULL SCRN
         AGO   .EDIT                    MAKE IT MUTUALLY EXCLUSIVE
.ASIS    ANOP
&BITS    SETA  &BITS+1                  SET ASIS OPTION
         AGO   .EDIT                    MAKE IT MUTUALLY EXCLUSIVE
.CONTROL ANOP
&BITS    SETA  &BITS+2                  SET CONTROL OPTION
.EDIT    AIF   (&ED).MUTEX
&ED      SETB  1                        EDIT,ASIS OR CONTROL SET
         AGO   .NEXTI
.NOWAIT  ANOP
&BITS    SETA  &BITS+16                 SET NOWAIT OPTION
.WAIT    AIF   (&WA).MUTEX
&WA      SETB  1                        WAIT OR NOWAIT SET
         AGO   .NEXTI
.HOLD    ANOP
&BITS    SETA  &BITS+8                  SET HOLD OPTION
.NOHOLD  AIF   (&HO).MUTEX
&HO      SETB  1                        HOLD OR NOHOLD SET
         AGO   .NEXTI
.BREAKIN ANOP
&BITS    SETA  &BITS+4                  SET BREAKIN OPTION
.NOBREAK AIF   (&BR).MUTEX
&BR      SETB  1                        BREAKIN OR NOBREAK SET
         AGO   .NEXTI
.LOWP    ANOP
&BITS    SETA  &BITS+X'20'              FORCE LOW PRTY (EVEN IF KEY0)
.HIGHP   AIF   (&PR).MUTEX
&PR      SETB  1                        HIGHP OR LOWP SET
         AGO   .NEXTI
.SETOP   AIF   ('&BFF'(1,1) NE '(').NOTREG I MUST HAVE DONE LA
&$NFS    LA    1,0(,1)                  MAKE HIGH BYTE 0
.NOTREG  AIF   (&BITS EQ 0).CALL
         LA    15,&BITS                 GET OPTIONS
         SLL   15,24                    SHIFT TO TOP BYTE
         OR    1,15                     OR IN OPTIONS
.CALL    AIF   ('&MF' EQ 'I' OR '&MF' EQ 'B').CHK2
         MNOTE 4,'*** INVALID MF OPTION'
         MEXIT
.CHK2    AIF   ('&MF' EQ 'I').CALLIT
         MEXIT
.CALLIT  SVC   93                       ISSUE TPUT SVC
         MEND
         MACRO
&LBL     TSPARSE &Z,&PCL=,&CBUF=,&USER=,&SYNAD=,&ENTRY=,&MF=I
         GBLC  &$NFS
         LCLC  &IHBNX
&IHBNX   SETC  'IHB&SYSNDX'
&$NFS    SETC  '&LBL'
         AIF  (('&MF' NE 'I') AND ('&MF' NE 'E') AND ('&MF' NE 'L')).E1
        AIF (('&MF' EQ 'I') AND (('&PCL' EQ '') OR ('&CBUF' EQ ''))).E2
&$NFS    OACINNER F=&PCL,T=PPLPCL,OP=MA,COM='MOVE IN PCL ADDR'
&$NFS    OACINNER F=&CBUF,T=PPLCBUF,OP=MA,COM='MOVE IN CBUF ADDR'
&$NFS    OACINNER F=&USER,T=PPLUWA,OP=MA,COM='MOVE IN UWA ADDR'
         AIF   ('&MF' EQ 'L').DONE
&$NFS    LA    1,PPL
&$NFS    SETC  ''
         AIF   ('&ENTRY' EQ '').NOENT
         $RXR  ,&ENTRY,15,A=            FROM REGISTER OR FULLWORD
         BALR  14,15
         AGO   .NOLINK
.NOENT   LINK  EP=IKJPARS
.NOLINK  AIF   ('&SYNAD' EQ '').DONE
         LTR   15,15
         BZ    &IHBNX+4
         LA    0,&SYNAD
         L     14,&IHBNX
         BR    14
&IHBNX   DC    A(TSPARERR)
.DONE    AIF   ('&$NFS' EQ '').MEND
&$NFS    DS    0H                       DEFINE NAME
.MEND    MEXIT
.E1      MNOTE 12,'MF=&MF IS INVALID'
         AGO   .DONE
.E2      MNOTE 12,'PCL= AND CBUF= REQUIRED WITH MF=I'
         AGO   .DONE
         MEND
         MACRO
&LABEL   TSFIND &TYPE,&REG,&RG2
         LCLA   &KEY
&LABEL   L     &REG,16                  CVT
         AIF   ('&TYPE' EQ 'CVT').END
         AIF   ('&REG' NE '0' AND '&REG' NE 'R0').CONT
.REG0    MNOTE 8,'REGISTER 0 IS NOT A VALID REGISTER'
         MEXIT
.CONT    AIF   ('&TYPE' EQ 'TSCVT').TSCVT
         AIF   ('&TYPE' EQ 'TJB').TJB
         AIF   ('&TYPE' EQ 'TSB').TJB
         AIF   ('&TYPE' EQ 'TJBX').TJB
         AIF   ('&TYPE' EQ 'DSE').TJB
         AIF   ('&TYPE' EQ 'TJBL').TJBL
         AIF   ('&TYPE' EQ 'TJBTABLE').TJBTAB
         L     &REG,0(,&REG)            OLD/CURRENT
         L     &REG,4(,&REG)            CURRENT TCB
         AIF   ('&TYPE' EQ 'TCB').END
         AIF   ('&TYPE' EQ 'TCBFSA').TCBFSA
         AIF   ('&TYPE' EQ 'TIOT').TIOT
         AIF   ('&TYPE' EQ 'TJID').TJID
         AIF   ('&TYPE' EQ 'JSCB').JSCB
         AIF   ('&TYPE' EQ 'PBE').PSCB
         AIF   ('&TYPE' EQ 'PSCB').PSCB
         AIF   ('&TYPE' EQ 'UPT').PSCB
         AIF   ('&TYPE' EQ 'TAT').TAT
         AIF   ('&TYPE' EQ 'CCNUID').CCNUID
         MNOTE 8,' &TYPE IS UNSUPPORTED'
         MEXIT
.TIOT    L     &REG,12(,&REG)           TCB.TIOT
         MEXIT
.TCBFSA  L     &REG,112(,&REG)          TCB.FSA
         MEXIT
.JSCB    L     &REG,180(,&REG)          TCB.JSCB
         MEXIT
.PSCB    L     &REG,180(,&REG)          TCB.JSCB
         L     &REG,264(,&REG)          JSCB.PSCB
         AIF   ('&TYPE' EQ 'PSCB').END
         AIF   ('&TYPE' EQ 'UPT').UPT
         L     &REG,64(,&REG)           PSCB.PBE
         MEXIT
.UPT     L     &REG,52(,&REG)           PSCB.UPT
         MEXIT
.TJID    L     &REG,180(,&REG)          TCB.JSCB
         LH    &REG,268(,&REG)          JSCB.TJID
         MEXIT
.TSCVT   L     &REG,228(,&REG)          CVT.TSCVT
         MEXIT
.TJBL    L     &REG,228(,&REG)          CVT.TSCVT
         LH    &REG,26(,&REG)           TSCVT.SZU
         MEXIT
.TJBTAB  L     &REG,228(,&REG)          CVT.TSCVT
         L     &REG,0(,&REG)            TSCVT.TJB (TABLE BEGINNING)
         MEXIT
.TJB     AIF   ('&RG2' NE '').TJB2
         MNOTE 8,'2ND REGISTER NOT SPECIFIED'
         MEXIT
.TJB2    AIF   ('&RG2' EQ '0' OR  '&RG2' EQ 'R0').REG0
         L     &RG2,0(,&REG)            OLD/CURRENT
         L     &RG2,4(,&RG2)            CURRENT TCB
         L     &RG2,180(,&RG2)          TCB.JSCB
         LH    &RG2,268(,&RG2)          JSCB.TJID
         L     &REG,228(,&REG)          CVT.TSCVT
         MH    &RG2,26(,&REG)           TSCVT.SZU
         L     &REG,0(,&REG)            TSCVT.TJB
         AIF   ('&TYPE' EQ 'TJBX').TJBX
         AIF   ('&TYPE' EQ 'TSB').TSB
         AIF   ('&TYPE' EQ 'DSE').DSE
         LA    &REG,0(&RG2,&REG)        USER'S TJB
         MEXIT
.TJBX    L     &REG,8(&RG2,&REG)        TJB.TJBX
         MEXIT
.TSB     L     &REG,0(&RG2,&REG)        TJB.TSB
         MEXIT
.DSE     L     &REG,8(&RG2,&REG)        TJB.TJBX
         L     &REG,8(&REG)             TJBX.DSE
         MEXIT
.TAT     ANOP
&KEY     SETA  1                        SEARCH FOR TAT
         AGO   .TAT1
.CCNUID  ANOP
&KEY     SETA  5                        SEARCH FOR CCNUID
.TAT1    AIF   ('&RG2' NE '').TAT2
         MNOTE 8,'2ND REGISTER NOT SPECIFIED'
         MEXIT
.TAT2    AIF   ('&RG2' EQ '0' OR  '&RG2' EQ 'R0').REG0
L&SYSNDX L     &RG2,X'A8'(,&REG)        TCB.USER
L1&SYSNDX LA   &RG2,0(,&RG2)            CLEAR HIGH ORDER BYTE
         LTR   &RG2,&RG2                END TCB.USER CHAIN ?
         BZ    L2&SYSNDX                YES
         CLI   0(&RG2),&KEY             THE BLOCK WERE LOOKING FOR ?
         BE    LF&SYSNDX                YES
         L     &RG2,0(,&RG2)            STEP DOWN CHAIN
         B     L1&SYSNDX                SAME CHECKS ON THIS
L2&SYSNDX L    &REG,X'84'(,&REG)        TCB.OTC
         LTR   &REG,&REG                HIGHER TCB PRESENT ?
         BZ    LF&SYSNDX                NO, REG=0 INDICATES NOT FOUND
         TM    X'94'(&REG),X'80'        TCB.TSFLG = TCB.TSTSK
         BO    L&SYSNDX
LF&SYSNDX LTR  &REG,&RG2                TO RESULT REGISTER
         MNOTE *,'&REG =ADDRESS OF &TYPE OR 0, CC HAS BEEN SET'
.END     MEND
         MACRO
         TSIOPL
***********************************************************************
*    THE I/O SERVICE ROUTINE PARAMETER LIST (IOPL) IS A LIST OF       *
*    FULLWORD ADDRESSES PASSED BY THE INVOKER OF ANY I/O SERVICE      *
*    ROUTINE TO THE APPROPRIATE SERVICE ROUTINE VIA REGISTER ONE.     *
***********************************************************************
IOPL     DS    0A
IOPLUPT  DS    A                        PTR TO UPT
IOPLECT  DS    A                        PTR TO ECT
IOPLECB  DS    A                        PTR TO USER'S ECB
IOPLIOPB DS    A                        PTR TO THE I/O SRV RTN PARM BLK
IOPLL    EQU   *-IOPL
         SPACE 2
         MEND
         MACRO
         TSDAPL
***********************************************************************
*    THE DYNAMIC ALLOCATION INTERFACE ROUTINE (DAIR) PARAMETER LIST   *
*    (DAPL) IS A LIST OF ADDRESSES PASSED FROM THE INVOKER TO DAIR    *
*    VIA REGISTER 1
***********************************************************************
DAPL     DS    0F
DAPLUPT  DS    A        PTR TO UPT
DAPLECT  DS    A        PTR TO ECT
DAPLECB  DS    A        PTR TO CP'S ECB
DAPLPSCB DS    A        PTR TO PSCB
DAPLDAPB DS    A        PTR TO DAIR PARAMETER BLOCK
DAPLL    EQU   *-DAPL
         SPACE 2
         MEND
         MACRO
         TSPPL
***********************************************************************
*    THE PARSE PARAMETER LIST (PPL) IS A LIST OF ADDRESSES PASSED     *
*    FROM THE INVOKER TO PARSE VIA REGISTER 1                         *
***********************************************************************
PPL      DS    0A
PPLUPT   DS    A                        PTR TO UPT
PPLECT   DS    A                        PTR TO ECT
PPLECB   DS    A                        PTR TO CP'S ECB
PPLPCL   DS    A                        PTR TO PCL
PPLANS   DS    A                        PTR TO ANS PLACE
PPLCBUF  DS    A                        PTR TO CMD BUFFER
PPLUWA   DS    A                        PTR TO USER WORK AREA
*                                       (FOR VALIDITY CHECK ROUTINES)
PPLL     EQU   *-PPL
TSPARANS DS    F                        PARSE RETURNS PTR TO PDL HERE
         SPACE 2
         MEND
         MACRO
         TSCPPL
***********************************************************************
*    THE COMMAND PROCESSOR PARAMETER LIST (CPPL) IS A LIST OF         *
*    ADDRESSES PASSED FROM THE TMP TO THE CP VIA REGISTER 1           *
***********************************************************************
CPPL     DS    0A
CPPLCBUF DS    A                        PTR TO COMMAND BUFFER
CPPLUPT  DS    A                        PTR TO UPT
CPPLPSCB DS    A                        PTR TO PSCB
CPPLECT  DS    A                        PTR TO ECT
CPPLL    EQU   *-CPPL
         SPACE 3
         MEND
         MACRO
         $$ASM &M=(JAN,FEB,MAR,APR,MAY,JUN,JUL,AUG,SEP,OCT,NOV,DEC)
         GBLC  &$$DATE1,&$$DATE2,&$$ASM
         GBLC  &$$MM,&$$DD,&$$YY
         GBLC  &$$MONTH,&$$DAY,&$$YEAR
         LCLC  &D
         LCLA  &I
&D       SETC  '&SYSDATE'
         AIF   ('&D'(3,1) EQ '/').D1
&$$ASM   SETC  'G'
&$$YY    SETC  '&D'(1,2)                GET YEAR YY
&$$MONTH SETC  '&D'(3,3)                GET MONTH MMM
         AIF   (K'&D EQ 6).D2
&$$DD    SETC  '&D'(6,2)                GET DAY DD
         AGO   .D3
.D2      ANOP
&$$DD    SETC  '0'.'&D'(6,1)            GET DAY 0D
.D3      ANOP
&$$DATE1 SETC  '&$$DD&$$MONTH&$$YY'     SET DDMMMYY
.D3A     ANOP
&I       SETA  &I+1
         AIF   ('&$$MONTH' NE '&M(&I)').D3A    FIND MONTH NAME
&$$MM    SETC  '&I'
         AIF   (&I GT 9).D4
&$$MM    SETC  '0&I'
.D4      ANOP
&$$DATE2 SETC  '&$$MM/&$$DD/&$$YY'      SET MM/DD/YY
         AGO   .COMMON
.D1      ANOP
&$$DATE2 SETC  '&D'                     SET MM/DD/YY
&$$MM    SETC  '&D'(1,2)                GET MM
&$$DD    SETC  '&D'(4,2)                GET DD
&$$YY    SETC  '&D'(7,2)                GET YY
&$$MONTH SETC  '&M(&$$MM)'              GET MONTH MMM
&$$DATE1 SETC  '&$$DD&$$MONTH&$$YY'
&D       SETC  'ABCDEFGHI'
         AIF   (K'&D EQ 8).D5           ASMF OR SPASM
&$$ASM   SETC  'H'
         AGO   .COMMON
.D5      AIF   (K'&SYSTIME GT 5).D6
&$$ASM   SETC  'F'
         MEXIT
.D6      ANOP
&$$ASM   SETC  'S'
.COMMON  ANOP
&$$YEAR  SETC  '19&$$YY'                GET 19YY
         MEND
         MACRO
&NFS     $RXR  &TARGET,&SEND,&REG,&H,&A=A
         GBLB  &OMITTED
         GBLC  &$NFS
&OMITTED SETB  0
         AIF   ('&SEND' EQ '' ).NOSEND  NO SOURCE FIELD
         AIF   ('&SEND'(1,1) EQ '(').REGSEND   SOURCE IS A REGISTER
&NFS     L&A   &REG,&SEND
&$NFS    SETC  ''
         AIF   ('&TARGET' EQ '').END    LEAVE IN REGISTER
         ST&H  &REG,&TARGET
         AGO   .END
.REGSEND AIF   ('&TARGET' NE '').RSTORE
         AIF   ('&SEND(1)' EQ '&REG').END
&NFS     LR    &REG,&SEND(1)
&$NFS    SETC  ''
         AGO   .END
.RSTORE  ANOP
&NFS     ST&H  &SEND(1),&TARGET
&$NFS    SETC  ''
         AGO   .END
.NOSEND  ANOP
&OMITTED SETB  1                        OPERAND WAS OMITTED
.END     MEND
         MACRO
&LBL     MSGZ  &C
         LCLA  &A
&A       SETA  K'&C
&A       SETA  &A-2
&LBL     DC    AL1(&A),CL&A.&C
         MEND
         MACRO
         REGEQU  &F=,&FR=,&PREFIX=R,&STARS=YES
         GBLC  &$REGS$(15),&R,&FF
         LCLA  &X
&R       SETC  '&PREFIX'
.RLOOP   ANOP
&X       SETA  &X+1
         AIF   (&X GT 15).GEN
         AIF   ('&$REGS$(&X)' EQ '').GEN
         AIF   ('&R' EQ '&$REGS$(&X)').NOGEN
         AGO   .RLOOP
.GEN     ANOP
&$REGS$(&X) SETC '&R'
         AIF   ('&STARS' NE 'YES').NOSTAR1
***********************************************************************
.NOSTAR1 ANOP
&R.0     EQU   0
&R.1     EQU   1
&R.2     EQU   2
&R.3     EQU   3
&R.4     EQU   4
&R.5     EQU   5                        *************
&R.6     EQU   6                        *  DEFINE   *
&R.7     EQU   7                        * SYMBOLIC  *
&R.8     EQU   8                        * REGISTERS *
&R.9     EQU   9                        *************
&R.10    EQU   10
&R.11    EQU   11
&R.12    EQU   12
&R.13    EQU   13
&R.14    EQU   14
&R.15    EQU   15
         AGO   .CONT11
.NOGEN   ANOP
******** REGEQU ALREADY CODED FOR THIS PREFIX, IGNORED ****************
.CONT11  AIF   ('&F&FR' EQ '').NOF
&X       SETA  0                        RE-INIT
&FF      SETC  '&F&FR'
.FLOOP   ANOP
&X       SETA  &X+1
         AIF   (&X GT 15).FGEN
         AIF   ('&$REGS$(&X)' EQ '').FGEN
         AIF   ('&FF' EQ '&$REGS$(&X)').NOGENF
         AGO   .FLOOP
.FGEN    ANOP
&$REGS$(&X) SETC '&FF'
         SPACE 1
&FF.0    EQU   0
&FF.2    EQU   2
&FF.4    EQU   4
&FF.6    EQU   6
.NOF     AIF   ('&STARS' NE 'YES').NOSTAR2
***********************************************************************
.NOSTAR2 SPACE
         AGO   .MEND
.NOGENF  ANOP
******** REGEQU F= ALREADY CODED FOR THIS PREFIX, IGNORED *************
.MEND    MEND
         MACRO
&LABEL   ALLOC &DDNAME=,&DSN=,&MEMBER=,                                $
               &FILE=,&DATASET=,&PASSWD=,                              $
               &PREFIX=NO,&DUMMY=NO,&PERM=YES,                         $
               &SYSOUT=,&FORM=,&PROG=,&ATRNAME=,                       $
               &UNIT=,&VOL=,                                           $
               &SPACE=,&DISP=,                                         $
               &MF=,&SYNAD=
         GBLB  &OMITTED,&DROP
         LCLC  &PER,&PRE,&DUM,&REL,&TYP
         LCLC  &SER,&SRE,&SUM,&SEL,&SYP
&LABEL   DS    0H
         AIF   (T'&SYSOUT NE 'O').SYSOUT
         AIF   ('&DSN' EQ '*' OR '&DATASET' EQ '*').TERMAL
         $MF   DAPB08,15,&MF
         XC    DAPB08(DAPB08L),DAPB08   INITIALIZE DAIR BLOCK TO ZERO
         MVI   DA08CD+1,X'08'           DAIR ENTRY CODE FOR ALLOCATE
         $RXR  DA08PDSN,&DSN&DATASET,0  POINTER TO DATASET BUFFER
         $RXQ  DA08DDN,&DDNAME&FILE,8   DDNAME
         $RXQ  DA08UNIT,&UNIT,8         UNIT
         $RXQ  DA08SER,&VOL,8           VOLUME NAME
         AIF   (&OMITTED).MEMBER
         MVC   DA08SER+6(2),=CL2' '     CLEAR LAST 2 BYTES OF VOLUME
.MEMBER  $RXQ  DA08MNM,&MEMBER,8        MEMBER NAME
         $RXQ  DA08PSWD,&PASSWD,8       PASSWORD
         AIF   ('&DISP(1)' EQ 'OLD' AND '&SPACE(1)' NE '').SPACMSG
         AIF   ('&DISP(1)' EQ 'SHR' AND '&SPACE(1)' NE '').SPACMSG
         AIF   ('&SPACE' EQ '' ).NOSPACE
         AIF   ( '&SPACE(1)' EQ '' ).SPACE2
         AIF   ('&SPACE(1)' EQ 'TRK').TRK
         AIF   ('&SPACE(1)' EQ 'CYL').CYL
         $RXR  DA08BLK,&SPACE(1),0      AVERAGE BLOCK LENGTH
&TYP     SETC  'DA08ABKL'
&SYP     SETC  '+'
**       ALLOCATION BY AVERAGE BLOCK LENGTH
         AGO   .SPACE2
.TRK     ANOP
&TYP     SETC  'DA08TRKS'
&SYP     SETC  '+'
**       ALLOCATION IN TRACKS
         AGO   .SPACE2
.CYL     ANOP
&TYP     SETC  'DA08CYLS'
&SYP     SETC  '+'
**       ALLOCATION IN CYLINDERS
         AGO   .SPACE2
.NOSPACE ANOP
         AGO   .DISP
.SPACE2  ANOP
         $RXR  DA08PQTY,&SPACE(2),0     PRIMARY SPACE ALLOCATION
         $RXR  DA08SQTY,&SPACE(3),0     SECONDARY QUANTITY
         $RXR  DA08DQTY,&SPACE(4),0     DIRECTORY QUANTITY
         AGO   .SKIP
.SPACMSG MNOTE *,'DISP=&DISP(1) SPECIFIED, SPACE PARAMETERS IGNORED'
.SKIP    AIF   ('&SPACE(5)' NE 'RLSE').DISP
&REL     SETC  'DA08RLSE'
**       RELEASE REQUESTED
&SEL     SETC  '+'
.DISP    AIF   ('&PREFIX' NE  'YES').NOPREF
&PRE     SETC  'DA08UID'
**       PREFIX WITH CHARGENO.USERID. REQUESTED
&SRE     SETC  '+'
.NOPREF  AIF   ('&PERM' NE 'YES').NOTPERM
&PER     SETC  'DA08PERM'
**       DATASET MUST BE SPECIFICALLY FREED
&SER     SETC  '+'
.NOTPERM AIF   ('&DUMMY' NE 'YES').NODUMMY
&DUM     SETC  'DA08DMMY'
**       THIS IS A DUMMY DATASET
&SUM     SETC  '+'
.NODUMMY ANOP
         AIF   ('&PRE' EQ ''  AND '&PER' EQ ''  AND '&REL' EQ ''       X
               AND '&DUM' EQ '' AND '&TYP' EQ '').NOCTL
         OI    DA08CTL,0&SYP&TYP&SER&PER&SEL&REL&SUM&DUM&SRE&PRE
.NOCTL   AIF   (T'&DISP EQ 'O').NODISP
         AIF   (T'&DISP(1) EQ 'O').NODISP1
         AIF   ('&DISP(1)' NE 'NEW').OLD1
         MVI   DA08DSP1,DA08NEW         DISP=NEW
         AGO   .DISP2
.OLD1    AIF   ('&DISP(1)' NE 'OLD').SHR1
         MVI   DA08DSP1,DA08OLD         DISP=OLD
         AGO   .DISP2
.SHR1    AIF   ('&DISP(1)' NE 'SHR').MOD1
         MVI   DA08DSP1,DA08SHR         DISP=SHR
         AGO   .DISP2
.MOD1    AIF   ('&DISP(1)' NE 'MOD').DISPBAD
         MVI   DA08DSP1,DA08MOD         DISP=MOD
         AGO   .DISP2
.NODISP1 ANOP
**       DEFAULT INITIAL DISPOSTION IS DISP=NEW
.DISP2   AIF   (T'&DISP(2) EQ 'O').NODISP2
         AIF   ('&DISP(2)' NE 'KEEP').DELETE2
         MVI   DA08DPS2,DA08KEEP        DISP=(,KEEP)
         AGO   .DISP3
.DELETE2 AIF   ('&DISP(2)' NE 'DELETE').CATLG2
         MVI   DA08DPS2,DA08DEL         DISP=(,DELETE)
         AGO   .DISP3
.CATLG2  AIF   ('&DISP(2)' NE 'CATLG').UNCAT2
         MVI   DA08DPS2,DA08CAT         DISP=(,CATLG)
         AGO   .DISP3
.UNCAT2  AIF   ('&DISP(2)' NE 'UNCATLG').DISPBAD
         MVI   DA08DPS2,DA08UCAT        DISP=(,UNCATLG)
         AGO   .DISP3
.NODISP2 ANOP
**       DEFAULT FINAL DISPOSITION IS DISP=(,KEEP)
         AGO   .DISP3
.DISP3   AIF   (T'&DISP(3) EQ 'O').MF
         AIF   ('&DISP(3)' NE 'KEEP').DELETE3
         MVI   DA08DPS3,DA08KEP         DISP=(,,KEEP)
         AGO   .MF
.DELETE3 AIF   ('&DISP(3)' NE 'DELETE').CATLG3
         MVI   DA08DPS3,DA08DELE        DISP=(,,DELETE)
         AGO   .MF
.CATLG3  AIF   ('&DISP(3)' NE 'CATLG').UNCAT3
         MVI   DA08DPS3,DA08CATL        DISP=(,,CATLG)
         AGO   .MF
.UNCAT3  AIF   ('&DISP(3)' NE 'UNCATLG').DISPBAD
         MVI   DA08DPS3,DA08UNCT        DISP=(,,UNCATLG)
         AGO   .MF
.NODISP  ANOP
**       DEFAULT DISPOSITION IS DISP=(NEW,KEEP)
         AGO   .MF
.DISPBAD ANOP
         MNOTE  *,'*****************************************'
         MNOTE  12,'INVALID DISPOSITON, EXPANSION TERMINATED'
         MNOTE  *,'*****************************************'
         MEXIT
.MF      $RXQ  DA08ALN,&ATRNAME,8       ATTRIBUTE LIST NAME
         AIF   (&OMITTED).LBE
         OI    DA08CTL,DA08ATRL         ATTRIBUTE LIST SUPPLIED
         AGO   .LBE
.SYSOUT  $MF   DAPB30,15,&MF
         XC    DAPB30(DAPB30L),DAPB30   INITIALIZE DAIR BLOCK TO ZERO
         MVI   DA30CD+1,X'30'           DAIR ENTRY CODE SYSOUT ALLOCATE
         $RXR  DA30PDSN,&DSN&DATASET,0  POINTER TO DATASET NAME
         $RXQ  DA30DDN,&DDNAME&FILE,8   DDNAME
         $RXQ  DA30UNIT,&UNIT,8         UNITNAME
         $RXQ  DA30SER,&VOL,8           VOLUME NAME
         AIF   (&OMITTED).PROG
         MVC   DA30SER+6(2),=CL2' '     CLEAR LAST 2 BYTES OF VOLUME
.PROG    $RXQ  DA30PGNM,&PROG,8         PROGRAM NAME
         AIF   (T'&SPACE EQ 'O').DISPS
         AIF   ('&SPACE(1)' EQ 'TRK').TRKS
         AIF   ('&SPACE(1)' EQ 'CYL').CYLS
         $RXR  DA30BLK,&SPACE(1),0      AVERAGE BLOCK LENGTH
&TYP     SETC  'DA30ABKL'
&SYP     SETC  '+'
**       ALLOCATION BY AVERAGE BLOCK LENGTH
         AGO   .SPACE2S
.TRKS    ANOP
&TYP     SETC  'DA30TRKS'
&SYP     SETC  '+'
**       ALLOCATION IN TRACKS
         AGO   .SPACE2S
.CYLS    ANOP
&TYP     SETC  'DA08CYLS'
&SYP     SETC  '+'
**       ALLOCATION IN CYLINDERS
.SPACE2S $RXR  DA30PQTY,&SPACE(2),0     PRIMARY ALLOCATION QUANTITY
         $RXR  DA30SQTY,&SPACE(3),0     SECONDARY QUANTITY
         AIF   (T'&SPACE(4) EQ 'O').SPACE5S
        MNOTE *,'SPACE=, DIRECTORY QUANTITY INVALID FOR SYSOUT DATASET'
.SPACE5S AIF   ('&SPACE(5)' NE 'RLSE').DISPS
&REL     SETC  'DA30RLSE'
**       RELEASE REQUESTED
&SEL     SETC  '+'
.DISPS   AIF   ('&PREFIX' NE  'YES').NOPREFS
&PRE     SETC  'DA30UID'
**       PREFIX WITH CHARGENO.USERID. REQUESTED
&SRE     SETC  '+'
.NOPREFS AIF   ('&PERM' NE 'YES').NOTPERS
&PER     SETC  'DA30PERM'
**       DATASET MUST BE SPECIFICALLY FREED
&SER     SETC  '+'
.NOTPERS AIF   ('&DUMMY' NE 'YES').NODUMMS
&DUM     SETC  'DA30DMMY'
**       THIS IS A DUMMY DATASET
&SUM     SETC  '+'
.NODUMMS AIF   ('&PRE' EQ ''  AND '&PER' EQ ''  AND '&REL' EQ ''       X
               AND '&DUM' EQ '' AND '&TYP' EQ '').NOCTLS
         OI DA30CTL,&TYP&SER&PER&SEL&REL&SUM&DUM&SRE&PRE
.NOCTLS  $RXQ  DA30FORM,&FORM,4         FORM NUMBER
         $RXQ  DA30OCLS,&SYSOUT,2       SYSOUT CLASS
         AIF   (&OMITTED).CONT2
         MVI   DA30OCLS+1,C' '          CLEAR SECOND BYTE
         AGO   .CONT2
.TERMAL  $MF   DAPB1C,15,&MF
         XC    DAPB1C(DAPB1CL),DAPB1C   INITIALIZE DAIR BLOCK TO ZERO
         MVI   DA1CCD+1,X'1C'  DAIR ENTRY CODE FOR TERMINAL ALLOCATION
         AIF   ('&PERM' NE 'YES').NOPERMT
         OI    DA1CCTL,DA1CPERM PERMANENTYLY ALLOCATED BIT
.NOPERMT $RXQ  DA1CDDN,&DDNAME&FILE,8   DDNAME
         $RXQ  DA1CALN,&ATRNAME,8       ATTRIBUTE LIST NAME
         AIF   (&OMITTED).LBE
         OI    DA1CCTL,DA1CATRL         ATTRIBUTE LIST SUPPLIED
         AGO   .LBE
.CONT2   $RXQ  DA30ALN,&ATRNAME,8       ATTRIBUTE LIST NAME
         AIF   (&OMITTED).LBE
         OI    DA30CTL,DA30ATRL         ATTRIBUTE LIST SUPPLIED
.LBE     AIF   ('&MF(1)' EQ 'B').ENDB
         AIF   ('&MF(1)' EQ 'L').ENDS
         TSDAIR DAPB=(15),SYNAD=&SYNAD
         AGO   .ENDS
.ENDB    ST    15,DAPLDAPB
         LA    1,DAPL
.ENDS    AIF   (NOT &DROP).END2S
         DROP  15                 DROP ADDRESSIBILITY TO DAIR BLOCK
.END2S   SPACE 3
         MEND
         SPACE 2                                                   LDW1
         MACRO
&N       OP    &M,&F,&O
         GBLA  &#                                                  LDW1
         LCLC  &F$
&F$      SETC  '&F'
         AIF   ('&F'(1,1) NE '''').OK
&F$      SETC  '&F'(2,1)
.OK      ANOP
&#       SETA  &#+1                                                LDW1
@&O      EQU   &#                                                  LDW1
&N       DC    CL4'&M',C'&F$',X'&O'
         MEND
         SPACE 2                                                   LDW1
         MACRO
&NFS     STCMX &REG,&MASK,&ADDR,&BYTE=,&COPY=                      LDW1
         GBLB  &MVS                                                LDW1
         AIF   (&MVS).MVS                                          LDW1
         AIF   ('&MASK' EQ 'B''0111''' OR &MASK EQ 7).MASKOK       LDW1
         MNOTE 8,'UNSUPPORTED MASK'                                LDW1
         DC    6X'0700'                 PATCH SPACE                LDW1
         MEXIT ,                                                   LDW1
.MASKOK  AIF   ('&COPY' NE '').COPY                                LDW1
&NFS     ST    &REG,&ADDR-1             SET ADDR                   LDW1
         MVI   &ADDR-1,X'&BYTE'         RESTORE DEAD BYTE          LDW1
         MEXIT ,                                                   LDW1
.COPY    ANOP  ,                                                   LDW1
&NFS     MVC   &ADDR.(3),&COPY          SET IT                     LDW1
         MEXIT                                                     LDW1
.MVS     ANOP                                                      LDW1
&NFS     STCM  &REG,B'0111',&ADDR       DO IT RIGHT                LDW1
         MEND
         SPACE 6
         MACRO
&N       TSWORK &DUMMY
         GBLB  &MVS,&MVT                                           MAS1
         EJECT
*
*  OLD CS DSECT SORTA
*
TSOBITS  DS    0F,4X                    GUESS
GODFLAG  DS    X                        MOST USEFUL FLAG
         AIF   (&MVS).MVS01                                        LDW1
JQFLAG   DS    X                        .                         *LPR*
.MVS01   ANOP                                                      LDW1
CSALTFLG DS    X                        BITS
USERID   DS    0C'CPC013.LDW'           HANDLE FOR BOTH            LDW1
CSJOBNO  DS    CL6                      CHARGE NO
CSDOT    DC    C'.'                                                LDW1
CSINIT   DS    CL3                      UID
DISPCONS DS    0F                       DISPLAY CONSTANTS          LDW1
NOWMASK  DS    F'-8'                                               LDW1
BITMASK  DS    F'7'                                                LDW1
LINELEN  DS    H'40'                    LENGTH OF LINES TO USE     LDW1
SCRBYTES DS    H'96'                    (BYTES/SCREEN)/2           LDW1
LINEHEX  DS    H'16'                    NUMBER OF BYTES/LINE HEX   LDW1
LINEHEX2 DS    H'32'                    TWICE THE ABOVE            LDW1
BYTES    DS    16AL1                    TRTAB FOR CARET            LDW1
DISPCONL EQU   *-NOWMASK                LEN OF DISPLAY CONSTANTS   LDW1
*
*  ZAP'S DATA AREA FOR EXP
*
GORF     DS    F                        SAVE AREA FOR PTR
EXPOPT   DS    X                        WHETHER TO SCAN LABLE TAB
DBLW     DS    D
EXPWORK  DS    D
EXPARMS  DS    0F                       'SAVEAREA' FOR 'EXP'
EXPFLAG  DS    3F
         DS    A
EXPSTART DS    A
         DS    F                        LENGTH
EXPPTR   DS    A
         SPACE 3
*
*  ZAP'S DATA AREA
*
NOWSTUFF DS    0F                                                  LDW1
*  FOLLOWING 3 LINES *MUST*BE*TOGETHER*
OLDPOINT DS    H                        OFFSET INTO BUFFER
OFFSET   DS    F                        (OLDPOINT + BASEVAL)       LDW1
BASEVAL  DS    F                        BASE VALUE                 LDW1
NOWLEN   EQU   *-NOWSTUFF                                          LDW1
         SPACE 2
AIDEFTAB DS    A                        ADDR OF DEFINE TABLE
AITRCTAB DS    A                        ADDR OF TRACE TABLE        LDW1
AITREND  DS    A                        -> END OF TRACE TABLE      LDW1
FIRSTSCR DS    A                        ADDR OF FIRST SCREEN LOC
MAXSCR   DS    A                        ADDR OF END OF AVAIL SCR
ADDRWORK DS    F                        ADDRESS OF MSG AND WTO WORK
CSOUTWK  EQU   ADDRWORK                 CSOUT WORKAREA IS FIRST
TEMPTRT  DS    XL256                    TEMP TRTAB FOR STRING ANAL
         SPACE 2
$L       EQU   79                       LENGTH OF DISPLAY LINE     LDW1
$I       EQU   81                       LINE INCREMENT (IN SCREEN) LDW1
SCREEN   EQU   *                                                   SDM5
CTL3270  DS    XL7                      WHERE THE 3270 STUFF GOES  LDW1
         DS    X'1D60'                  PROT NORMAL                SDM5
LINE01   DS    CL79,X'1DC8'             SCREEN BUFFER...           SDM5
LINE02   DS    CL79,X'1D60'             .                          LDW1
LINE03   DS    CL79,X'1DC8'             .                          LDW1
REP      DS    CL79,X'1DF8'             .                          LDW1
LINE05   DS    CL79,X'1D60'             .                          LDW1
LINE06   DS    CL79,X'1D60'             .                          LDW1
LINE07   DS    CL79,X'1D60'             .                          LDW1
LINE08   DS    CL79,X'1D60'             .                          LDW1
LINE09   DS    CL79,X'1D60'             .                          LDW1
LINE10   DS    CL79,X'1D60'             .                          LDW1
LINE11   DS    CL79,X'1D60'             .                          LDW1
LINE12   DS    CL79,X'1D60'             .                          LDW1
LINE13   DS    CL79,X'1D60'             .                          LDW1
LINE14   DS    CL79,X'1D60'             .                          LDW1
LINE15   DS    CL79,X'1D60'             .                          LDW1
LINE16   DS    CL79,X'1D60'             .                          LDW1
LINE17   DS    CL79,X'1D60'             .                          LDW1
LINE18   DS    CL79,X'1DF8'             .                          LDW1
LINE19   DS    CL79,X'1D60'             .                          LDW1
LINE20   DS    CL79,X'1D60'             .                          LDW1
LINE21   DS    CL79                     .                          SDM5
END3270  DS    XL8                      WHERE THE REST GOES        SDM5
SCREENL  EQU   *-SCREEN                 LENGTH OF SCREEN DATA      SDM5
REGS3270 DS    A(SCREEN,SCREENL)        TPUT FULLSCR REGS          SDM5
ASCRWORK DS    A(SCRWORK)               -> SCREEN WORK AREA        LDW2
AOLDSCR  DS    A(OLDSCR)                -> SCREEN SAVE AREA        SDM5
REPX     DS    CL(1+2+(3+79)*2)         REPLY BUFF FOR TGET ASIS   SDM1
PREVREP  DS    CL79                     THE PREVIOUS REPLY         LDW4
VERSION  DS    C'VERSION=V.MC DDMMMYY LDW'                         LDW1
CURPOS   DS    H                        CURSOR POSITION            LDW1
TERMSAVE DS    A                        SAVE FOR R14 IN PUTLINE    LDW1
LINEDESC DC    Y($L+4,0)                THE "OLD" FOR PUTLINE      LDW1
LINEBUFF DS    CL80                     PUTLINE'S BUFFER           LDW1
DSNAMEL  DS    H                        LENGTH OF DSN (44)
DSNAME   DS    CL44                     DSN
PASSWORD DS    CL8                      GUESS WHAT?                LDW1
DISPDSN  DS    CL44                     DISPLAYABLE DSN            LDW1
ALLOCDSN DS    CL44                     DSN TO ALLOCATE            LDW1
TTR      DS    F                        TTR OF BLK
*  THE LAST BYTE OF "TTR" IS USED FOR A SEQUENTIAL READ FLAG.
*
OLDTTR   DS    F                        TTR OF LAST STORE OR SET CMD
STOPDUMP DS    XL3                      TTR WHERE TO STOP DUMP
DSORG    DS    X                        DSORG OF CURRENT DATASET
DSORGPO  EQU   X'02'                    DSORG=PARTITIONED ORGANIZATION
         SPACE 2
IDEFAVAL DS    A                        1ST AVAL POSIT IN DEFINE TAB
ITRAVAL  DS    A                        1ST AVAIL TRACE TAB POSIT
CURRITR  DS    F                        CURRENT TRACE TABLE ENTRY PTR
         SPACE 2
TEMP     DS    2D                       WORK AREA
TEMP2    DS    5D                       WORK AREA
TRTABADD DS    A                        PTR TO TRTAB FOR DUMP DISPLAY
         SPACE 1
MIDLINE  DS    A                        CARET
WIDTHS   DS    0F                       FOR WINDOWS       |**********|
WIDTHD   DS    F                        FOR DOWN          |CONTIGUOUS|
WIDTHU   DS    F                        UP                |**********|
         SPACE 2
REALRDLN DS    H                        ACTUAL COMND READ LENGTH
READLEN  DS    H                        READLENGTH FROM TGET
TRACE    DS    X                        FLAG-TRACE IN EFFECT OR NOT
CONTINUE DS    X                        STORES, SCAN, SET IN EFFECT
IOERROR  DS    X                        FLAG-SYNAD I/O ERROR OR NOT
CPUTFLAG DS    X                        WHETHER CSOUT CAN ENQ OR NOT
EOFRET   DS    X                        IGNORE EOF'S?
ENQIT    DS    X                        WHETHER THERES ANYTHING TO ENQ
CHNGED   DS    X                        SET IF BUFFER NEEDS CHKPOINTING
IDRFLAG  DS    X                        WHETHER IDR WAS UPDATED OR NOT
         SPACE 1
FLAGS2   DS    X                        MISC FLAGS FOR TSO VERSION
MUSTZAP  EQU   X'80'                    BLK NOT REP, ENTER SAVE/EN
ATTNHIT  EQU   X'40'                    ATTN HIT SINCE LAST TGET   LDW5
SENSF    EQU   X'20'                    URSA OR SYS DS
LOGF     EQU   X'10'                    IN LOGGING STATE
NOWHEREF EQU   X'08'                    WHERE NOT NEEDED           SDM6
TERSEF   EQU   X'04'                    PERMANENTLY SUPPRESS WHERE SDM6
         SPACE 1
FLAGS3   DS    X                        CRT AND 3270 FLAGS         LDW2
RESHOWF  EQU   X'40'                    REFRESH WHOLE SCR NXT TPUT LDW2
NODISPF  EQU   X'20'                    DON'T DISP SCRN THIS TIME  SDM6
F3270    EQU   X'10'                    3270 OPTION ON             LDW5
FSMODE   EQU   X'08'                    FULLSCR MODE ACTIVE        LDW5
CRTF     EQU   X'04'                    CRT KEYWORD GIVEN          LDW5
         SPACE 1
         DS    X                        (UNUSED)                   LDW2
LOOKFOR  DS    H,CL16                   SCAN WORK AREA (LEN+STRING)
ZAPSTRNG DS    H,CL16                   S,X,O,N WORK AREA (LEN+STRING)
SETSTR   DS    H,CL16                   SET WORK AREA (LEN+STRING)
         SPACE 2
ADDRCNT  DS    A                        ADDRESS OF RECORD COUNT    LDW1
ADDRKEY  DS    A                        ADDRESS OF RECORD KEY      LDW1
ADDRDATA DS    A                        ADDRESS OF RECORD DATA     LDW1
ADDRBUFF DS    A                        ONE OF THE ABOVE 3 ADDRS   LDW1
BUFFSIZE DS    H                        MAX BUFFER SIZE             *N*
KEYLEN   DS    H                        CURRENT KEY LENGTH          *N*
BLKLEN   DS    H                        ACTUAL BLOCK LENGTH AFT READ*N*
         SPACE 2
ESDID    DS    H                        ESD ID
MEMTTR   DS    XL3                      SAVE MEMBER'S TTR
TXTTTR   DS    XL3                      LOAD MOD'S FIRST TEXT BLK   *N*
CTL1TTR  DS    XL3                      TTR OF 1ST CTL REC OR 0    MAS2
TXTORIG  DS    F                        ORIG OF NXT TXT BLOCK      MAS2
MEMBER   DS    CL8                      MEMBER FOR PDS SEARCH
NAME     DS    CL8                      ENTRY NAME FOR EPA SEARCH   *N*
ENDTTR   DS    XL3                      TTR OF LAST BLK IN DATASET
LASTFMT1 DS    XL5                      CCHHR OF LAST FMT1 DSCB    LDW4
ESDTTR   DS    XL3                      START OF ESD               LDW1
         SPACE 2
DCBLIST  DS    F                        DCB PTR MF=L OPEN AND CLOSE
DSCBLIST EQU   TEMP2+16                                            LDW1
VOLSER   DS    CL6                      VOL=SER OF DSN
         SPACE 2
         SPACE 1
TMPLIST  OACTMP MF=L                    FOR 'DO'
TMPLISTL EQU   *-TMPLIST                LEN
         SPACE 2
*DCBU    DCB   MACRF=E,DDNAME=DDNAME,DEVD=DA                       LDW1
DCBU     DCB   MACRF=E,DDNAME=DDNAME,DEVD=DA                       LDW1
         DS    5F                       TURKEY SYSTEM (NEED 72 BYTELDW1
         SPACE 2                                                   LDW1
IOB      DC    X'42000000'              IOBFLAG                    LDW1
         DC    A(ECB)                   IOBECBA                    LDW1
CSW      DS    XL8                      IOBCSW                     LDW1
IOBCCWA  DC    A(CCWS,DCBU,0,0)         IOBCCWA,IOBDCBA,?,?        LDW1
MBBCCHHR DS    0XL8,XL3                 IOBSEEK                    LDW1
CCHHR    DS    XL5                      INTERESTING PART           LDW1
         SPACE 2                                                   LDW1
ECB      DS    A                        ECB FOR ECXP               LDW1
         SPACE 1
CCWS     DS    0D                       HANDLE FOR ALL CCWS        LDW1
CCW##R   CCW   X'16',0,X'70',1          READ R0 TO ORIENT          LDW1
CCW#R#S  CCW   X'31',CCHHR,X'40',5      SEARCH ID EQ               LDW1
CCW#R#T  CCW   X'08',*-8,X'00',0        TIC *-8                    LDW1
CCW#R#R  CCW   X'1E',*-*,X'20',*-*      READ CKD                   LDW1
         SPACE 1
CCW##W   DS    0D                                                  LDW1
CCW#W#S  CCW   X'31',CCHHR,X'40',5      SEARCH ID EQ               LDW1
CCW#W#T  CCW   X'08',*-8,X'00',0        TIC *-8                    LDW1
CCW#W#W  CCW   X'0D',*-*,X'00',*-*      WRITE KD                   LDW1
         SPACE 1
CCW##R0  CCW   X'16',*-*,X'20',*-*      READ R0                    LDW1
         SPACE 1
CCW##D   CCW   X'16',0,X'70',1          READ R0 TO ORIENT          LDW1
CCW#D#S  CCW   X'E9',NAME,X'40',8       SEARCH KEY EQ/HI MT        LDW1
CCW#D#T  CCW   X'08',*-8,X'00',0        TIC *-8                    LDW1
CCW#D#R  CCW   X'0E',*-*,X'00',8+256    READ KD                    LDW1
         SPACE 1
CCW##F   DS    0D                                                  LDW1
CCW#F#S  CCW   X'31',CCHHR,X'40',5      SEARCH ID EQ               LDW1
CCW#F#T  CCW   X'08',*-8,X'00',0        TIC *-8                    LDW1
CCW#F#W  CCW   X'1D',*-*,X'20',*-*      WRITE CKD                  LDW1
         SPACE 1
CCWL     EQU   *-CCWS                   LENGTH OF CCW PATTERNS     LDW1
         AIF   (&MVS).MVS02                                        LDW1
         SPACE 2
JQQMHDA  DS    9F                       MASTER QCR FROM JOBQUEUE  *LPR*
.MVS02   SPACE 5                                                   LDW1
*STAXLIST STAX 0,MF=L
STAXLIST STAX  0,MF=L
STAXL    EQU   *-STAXLIST
         SPACE 5
FLAGESD  DS    X                        FLAGS                       *N*
FESDTEXT EQU   X'80'                    NEXT BLOCK IS TEXT          *N*
         SPACE 2                                                   LDW1
PTPB     DS    0F,XL12                  FOR PUTLINE                LDW1
*        PGPB  DSECT=NO
         PGPB  DSECT=NO
         SPACE 2
EXLST    DS    A(JFCB)                  OBVIOUS                    LDW1
JFCB     DS    44F                      OBVIOUS                    LDW1
BLANKS   DS    CL256                    CONSTANT FOR CLEARING      LDW1
         SPACE 2                                                   LDW3
IDEFTAB  DS    24XL10                   24 ENTRY DEFINE TABLE
ENDITAB  DS    X                        END OF TABLE (X'FF')
*
*  EACH ENTRY ABOVE IS OF THE FORM (8C,H), CORRESP TO 'SYMBOL,OFFSET'
*
         SPACE 2
ITRTAB   DS    24XL5                    TRACE TABLE
ITREND   DS    X                        END OF TABLE (X'FF')
*
*  EACH ENTRY ABOVE IS OF THE FORM (3X,2X), CORRESP TO 'TTR,OFFSET'
*
         SPACE 3
OLDSCR   DS    CL(21*$I)                SCEEN SAVE AREA            SDM5
SCRWORK  DS    CL(SCREENL+3*21)         JUST PARTS THAT CHANGED    LDW2
         SPACE 2
         MEND
         MACRO
&NFS     ENTR  &BASE=12,&BASE2=,&BASE3=,&BASE4=,                       $
               &SAVE=*,&REGS=(YES,R),&F=,                              $
               &USING=,&SECTYPE=CSECT,&GETMAIN=,&PARMREG=,&LPARM=,     $
               &SP=1,&ID=*,&EXIT=,&ADDRREG=,&LENREG=,&ENV=CALL,        $
               &RC=,&RCLOC=,&T=T,&PL=,&LOAD=,&SYMREG=,&DSECT=,         $
               &TSFAKE=,&PARSE=,&MACRO=,&PRINT=,&DATE=,&TIME=
         GBLB  &GDAIRM,&GPARSEM         TO AVOID DUPLICATES
         GBLB  &GDAIR,&GPARSE           DAIR OR PARSE LOADED
         LCLC  &BA$E,&$AVE,&Q,&NAME,&RCRC,&LR,&AR,&T$FAKE,&GET1,&GET2
         LCLC  &PARNAME
         LCLC  &IHBNX,&BLANK1,&BLANK2
         LCLC  &R0,&R1,&R2,&R3,&R12,&R13,&R14,&R15
         LCLA  &L,&X
         LCLB  &ENVTSO,&ENVCALL,&ENVCP,&ENVPLI,&ENVMVT,&ENVMVS
         LCLB  &FKCALL,&FKCP,&MVSCVT
         LCLB  &CSPL,&PARS,&DAIR,&IO,&MSG
&IHBNX   SETC  'IHB&SYSNDX'
&BLANK1  SETC  '        '
&BLANK2  SETC  '        '
&PARNAME SETC  ''
         AIF   ('&PRINT' NE 'NOGEN').PRINTOK
         AIF   ('&PRINT' NE '').PRINTOK
         MNOTE 4,'WHAT DOES PRINT=&PRINT MEAN???'
.PRINTOK AIF   ('&SYMREG' EQ '').NOSYMRG
         MNOTE 0,'SYMREG= IS UNSUPPORTED -- USE REGS='
.NOSYMRG AIF   ('&DSECT' EQ '').NOD$ECT
         MNOTE 4,'DSECT= IS UNSUPPORTED'
.NOD$ECT ANOP
&X       SETA  0
.ENVLOOP AIF   (N'&ENV EQ &X).ENVDONE
&X       SETA  &X+1
         AIF   ('&ENV(&X)' EQ 'TSO'  ).ENVTSO
         AIF   ('&ENV(&X)' EQ 'CALL' ).ENVCALL
         AIF   ('&ENV(&X)' EQ 'CP'   ).ENVCP
         AIF   ('&ENV(&X)' EQ 'TSOCP').ENVCP
         AIF   ('&ENV(&X)' EQ 'MVS'  ).ENVMVS
         AIF   ('&ENV(&X)' EQ 'MVT'  ).ENVMVT
         MNOTE 4,'ENV=&ENV(&X) IS INVALID -- IGNORED'
         AGO   .ENVLOOP
.ENVTSO  ANOP
&ENVTSO  SETB  1
         AGO   .ENVLOOP
.ENVCALL ANOP
&ENVCALL SETB  1
         AGO   .ENVLOOP
.ENVCP   ANOP
&ENVCP   SETB  1
&ENVTSO  SETB  1                        ENV=CP IMPLIES ENV=TSO
         AGO   .ENVLOOP
.ENVMVS  ANOP
&ENVMVS  SETB  1
         AGO   .ENVLOOP
.ENVMVT  ANOP
&ENVMVT  SETB  1
         AGO   .ENVLOOP
.ENVPLI  ANOP
&ENVPLI  SETB  1
         AIF   ('&BASE' NE '12' AND '&BASE' NE 'R12').ENVLOOP
         MNOTE 0,'WARNING:  BASE=&BASE IS NOT COMPATIBLE WITH ENV=PLIX'
         AGO   .ENVLOOP
.ENVDONE AIF   (NOT &ENVCALL OR NOT &ENVCP).ENVOK1
        MNOTE 4,'ENV=(CALL,CP) MAY NOT BOTH BE GIVEN.  "CALL" IGNORED.'
&ENVCALL SETB  0                        IGNORE IT
.ENVOK1  AIF   (NOT &ENVMVT OR NOT &ENVMVS).ENVOK2
         MNOTE 4,'MAKE UP YOUR MIND:  ENV=MVT OR ENV=MVS, BUT NOT BOTH.$
                 MVT ASSUMED.'
&ENVMVS  SETB  0                        IGNORE IT
.ENVOK2  AIF   ('&TSFAKE' EQ '').NOFAKE
&T$FAKE  SETC  '&TSFAKE'
         AIF   ('&TSFAKE' NE 'YES').FAKENO
&T$FAKE  SETC  '&IHBNX.F'
.FAKENO  AIF   ('&PARMREG' NE '').OKFAKE0
         MNOTE 4,'*** PARMREG= MUST BE GIVEN IF TSFAKE= IS GIVEN.  TSFA$
               KE=&TSFAKE IGNORED.'
         AGO   .NOFAKE
.OKFAKE0 AIF   (NOT &ENVCALL).NOFKCAL
&FKCALL  SETB  1
         AGO   .NOFAKE
.NOFKCAL AIF   (NOT &ENVCP).NOFKCP
&FKCP    SETB  1
         AGO   .NOFAKE
.NOFKCP  MNOTE 0,'WHAT TO FAKE?????'
.NOFAKE  ANOP
&$AVE    SETC  '&SAVE'                  INIT DEFAULT
&GET1    SETC  '&GETMAIN(1)'
&GET2    SETC  '&GETMAIN(2)'
         AIF   ('&MACRO' NE 'YES').OKGET2
         AIF   ('&GET1' NE '').OKGET1
&GET1    SETC  'TSDSECTL'               SET DEFAULT
.OKGET1  AIF   ('&GET2' NE '').OKGET2
&GET2    SETC  'TSDSECT'                SET DEFAULT
.OKGET2  AIF   ('&GETMAIN' EQ '').KEEPSAV
         AIF   ('&GETMAIN(1)' NE '').GMOK1
         AIF   ('&MACRO' EQ 'YES').GMOK1
         MNOTE 8,'GETMAIN= CODED INCORRECTLY.  MACRO TERMINATED'
         MEXIT
.GMOK1   ANOP
&$AVE    SETC  ''                       NO SAVE AREA
.KEEPSAV AIF   ('&BASE4' EQ '').NOBASE4
         AIF   ('&BASE3' NE '').BASE3
         MNOTE 8,'*** BASE4 IGNORED, INVALID WITHOUT BASE3= ***'
.NOBASE4 AIF   ('&BASE3' EQ '').OKBASES
.BASE3   AIF   ('&BASE2' NE '').OKBASES
         MNOTE 8,'*** BASE3 IGNORED, INVALID WITHOUT BASE2= ***'
.OKBASES AIF   (('&GETMAIN' EQ '') AND ('&MACRO' NE 'YES')).OK1
         AIF   ('&SAVE'   EQ '*').OK1
         AIF   ('&SAVE'    EQ '').OK1
         MNOTE 12,'*** SAVE= MUTUALLY EXCLUSIVE WITH GETMAIN= AND/OR MA$
               CRO=YES.  MACRO TERMINATED ***'
         MEXIT
.OK1     AIF   ('&NFS' NE '').GOTNAME
         MNOTE 12,'*** CSECT NAME OMMITTED ***'
.GOTNAME AIF   ('&SECTYPE' NE 'CSECT').NOCSECT
.DOCSECT ANOP
&NFS     CSECT                          ENTR -- 09/27/79 -- LDW
         AGO   .SECDONE
.NOCSECT AIF   ('&SECTYPE' NE 'DSECT').NODSECT
&NFS     DSECT                          ENTR -- 09/27/79 -- LDW
         AGO   .SECDONE
.NODSECT AIF   ('&SECTYPE' EQ 'NONE').SECNONE
         AIF   ('&SECTYPE' EQ 'ENTRY').ENTRY
       MNOTE 8,'*** SECTYPE=&SECTYPE IS INVALID, SECTYPE=CSECT ASSUMED'
         AGO   .DOCSECT
.ENTRY   ENTRY &NFS
.SECNONE ANOP
*  DEFINE NAME
&NFS     DC    0D'0'                    ENTR -- 09/27/79 -- LDW
.SECDONE AIF   ('&REGS(1)' EQ '' AND '&REGS(2)' NE '').DOREGS
         AIF   ('&REGS(1)' EQ 'NO').NOREGS
         AIF   ('&REGS(2)' NE '').DOREGS
&Q       SETC  'R'
         AGO   .CONT1
.DOREGS  ANOP
&Q       SETC  '&REGS(2)'
.CONT1   ANOP                           WAS SPACE 1
&L       SETA  K'&Q
***********************************************************************
*        REGISTER EQUATES                                             *
         REGEQU  PREFIX=&Q,FR=&F
         SPACE 1
.NOREGS  ANOP
&R0      SETC  '&Q'.'0'
&R1      SETC  '&Q'.'1'
&R2      SETC  '&Q'.'2'
&R3      SETC  '&Q'.'3'
&R12     SETC  '&Q'.'12'
&R13     SETC  '&Q'.'13'
&R14     SETC  '&Q'.'14'
&R15     SETC  '&Q'.'15'
&L       SETA  K'&REGS(2)
         AIF   (&ENVCP AND '&PL' NE '').NOGM2   WILL BE GENERATED LATER
         AIF   ('&GET2' EQ '').NOGM2
&GET2    DSECT
         DS    18F                      SAVE AREA
         AIF   ('&TSFAKE' NE 'YES' OR &ENVCP).NOFKY1
&T$FAKE  DS    A,2H,CL100               AREA FOR FAKE PARM FIELD
.NOFKY1  AIF   (NOT &ENVCP).NO$CPPL
         AIF   ('&PL' EQ '').NOTSECB
TSECB    DS    F
.NOTSECB SPACE 1
*        TSCPPL
         TSCPPL
         SPACE 1
.NO$CPPL AIF   ('&LOAD' EQ '').NOLOAD1
&X       SETA  0
.LOADLP1 ANOP
&X       SETA  &X+1
&LOAD(&X) DS   A
         AIF   (&X LT N'&LOAD).LOADLP1
.NOLOAD1 SPACE 3
&NFS     CSECT                          RESUME
.NOGM2   AIF   ('&REGS(1)' EQ 'NO').REGBASE
         AIF   ('&BASE'(1,&L) EQ '&REGS(2)').REGBASE
&BA$E    SETC  '&Q&BASE'
         AGO   .CONT2
.REGBASE ANOP
&BA$E    SETC  '&BASE'
.CONT2   USING *,&R15                   TEMPORARY BASE
         B     &IHBNX.B                 AROUND GORF
         DROP  &R15                     DROP TEMP BASE
         OACUSING &NFS,&BA$E
         AIF   ('&ID(1)' EQ '*').IDSTAR
         AIF   ('&ID(1)' EQ '' ).IDSTAR
         AIF   ('&ID' EQ '*NONE*').DONEID
         ID    &ID(1),&ID(2),DATE=&DATE,TIME=&TIME
         AGO   .DONEID
.IDSTAR  ID    &NFS,&ID(2),DATE=&DATE,TIME=&TIME
.DONEID  AIF   ('&BASE2' EQ '').NOBASE2
&IHBNX.A DC    A(&NFS+4096)             SECOND BASE REGISTER
         AIF   ('&BASE3' EQ '').NOBASE2
&IHBNX.Z DC    A(&NFS+8192)             LET'S NOT GET CARRIED AWAY...
         AIF   ('&BASE4' EQ '').NOBASE2
&IHBNX.Q DC    A(&NFS+12288)            BUT THIS IS GETTING REDICULOUS
.NOBASE2 AIF   (('&$AVE' NE '*') OR ('&GET1' NE '')).NOSVSTR NO INL SA
&IHBNX.S DC    18F'0'                   SAVE AREA
&$AVE    SETC  '&IHBNX.S'
.NOSVSTR AIF   ('&TSFAKE' NE 'YES' OR &ENVCP OR '&GET2' NE '').NOFKY2
&T$FAKE  DC    A(0),2H'0',CL100' '      AREA FOR FAKE PARM FIELD
.NOFKY2  AIF   ('&GET1&GET2' EQ '').NOSPLEN  NO SP & LENGTH
         AIF   ('&BASE2' NE '').BASE2L
         DC    0A(0)                    ALIGNMENT
.BASE2L  ANOP                           DON'T NEED ALIGNMENT
&IHBNX.L DC    AL1(&SP),AL3(&GET1)      GETMAIN SP AND LENGTH
.NOSPLEN AIF   ('&EXIT' EQ '').NOEXIT
         SPACE 2
*=====================================================================*
&RCRC    SETC  '&RC(1)'
         AIF   ('&RC' NE '').OKRC1
&RCRC    SETC  '&R15'
.OKRC1   AIF   ('&RCLOC' EQ '').OKRC3
         AIF   ('&RC'    EQ '').OKRC2
         MNOTE 0,'*** RC= AND RCLOC= MUTUALLY EXCLUSIVE -- RC= IGNORED'
.OKRC2   ANOP
&RCRC    SETC  '&RCLOC'
.OKRC3   ANOP
&X       SETA  8-K'&RCRC                NUMBER OF BLANKS NEEDED
         AIF   (&X GT 0).OKRCL
&BLANK1  SETC  ''
         AGO   .CHAR8RC
.OKRCL   ANOP
&BLANK1  SETC  '&BLANK1'(1,&X)
.CHAR8RC ANOP
&X       SETA  8-K'&EXIT(1)             NUMBER OF BLANKS NEEDED
         AIF   (&X GT 0).OKEXITL
&BLANK2  SETC  ''
         AGO   .CHAR8EX
.OKEXITL ANOP
&BLANK2  SETC  '&BLANK2'(1,&X)
.CHAR8EX AIF   ('&RC' EQ '').MREGRC
         AIF   ('&RC'(1,1) EQ '(').MREGRC
         MNOTE *,'   BRANCH TO "&EXIT" TO EXIT WITH RETURN CODE=&RCRC  X
                 &BLANK1   &BLANK2    *'
         AGO   .MRCCONT
.MREGRC  MNOTE *,'   BRANCH TO "&EXIT" TO EXIT WITH RETURN CODE IN &RCR$
               C &BLANK1   &BLANK2    *'
.MRCCONT ANOP
*=====================================================================*
&NAME    SETC  '&EXIT'
         AIF   ('&RCRC' NE '0').RCNOT0
&NAME    XR    &R15,&R15                SET RETURN CODE ZERO
&NAME    SETC  ''
         AGO   .HAVERC
.RCNOT0  AIF   ('&RCLOC' EQ '').NORCLOC RCLOC NOT GIVEN
         AIF   ('&GET2' EQ '').NORCUSE
         USING &GET2,&R13               IN CASE RCLOC IS IN DSECT
.NORCUSE AIF   (T'&RCLOC EQ 'F').RCLOCF
         AIF   (T'&RCLOC EQ 'H').RCLOCH
         MNOTE 0,'*** UNKNOWN TYPE FOR RCLOC=&RCLOC -- "F" ASSUMED'
.RCLOCF  ANOP
&NAME    L     &R15,&RCLOC              LOAD RETURN CODE
         AGO   .RCCOM1                  GO TO COMMON
.RCLOCH  ANOP
&NAME    LH    &R15,&RCLOC              LOAD RETURN CODE
.RCCOM1  AIF   ('&GET2' EQ '').RCCOM2
         DROP  &R13                     IN CASE RCLOC IS IN DSECT
         AGO   .RCCOM2                  GO TO COMMON
.NORCLOC AIF   ('&RC' EQ '').HAVERC     RC IS IN A REG
         AIF   ('&RC'(1,1) EQ '(').HAVERC   DITTO
&NAME    LA    &R15,&RCRC               LOAD RETURN CODE
.RCCOM2  ANOP                           COMMON POINT
&NAME    SETC  ''
.HAVERC  AIF   ('&GET1' EQ '').NOWORK1  NO DSA TO FREE
&NAME    LR    &R1,&R13                 COPY DSA PTR
&NAME    SETC  ''
.NOWORK1 ANOP
&NAME    L     &R13,4(,&R13)            DECHAIN SAVE AREAS
&NAME    SETC  ''
         AIF   ('&RC' EQ '').WORKE
         AIF   ('&RC'(1,1) NE '(').NOWORKE
.WORKE   AIF   ('&RCLOC' NE '').NOWORKE STORE R15
         AIF   ('&GET1' EQ '').RCNOT1   RC=(1) IS OK IF NO DYNAMIC AREA
         AIF   (('&RCRC' NE '&R1') AND ('&RCRC' NE '1')).RCNOT1
         MNOTE 4,'YOU TURKEY.  RC=(R1) DOESN''T WORK RIGHT IF YOU HAVE $
               A DYNAMIC AREA'
         MNOTE 0,'... I HOPE YOU INSTALLED ZAP...'
.RCNOT1  ST    &RCRC,16(,&R13)          SET RETURN CODE
         AGO   .WASRGRC
.NOWORKE ST    &R15,16(,&R13)           SET RETURN CODE
.WASRGRC AIF   ('&GET1' EQ '').NOWRKE2  NO DSA TO FREE
         L     &R0,&IHBNX.L             PICK UP SP AND LENGTH
*        FREEMAIN  R,A=(1),LV=(0)       FREE THE DSA
         FREEMAIN  R,A=(1),LV=(0)
.NOWRKE2 LM    &R14,&R12,12(&R13)       RESTORE CALLERS REGS
         AIF   ('&T' NE 'T').BR14
         MVI   12(&R13),X'FF'           FLAG SAVEAREA AS INACTIVE
.BR14    BR    &R14                     RETURN TO CALLER
.NOEXIT  SPACE 3
*=====================================================================*
*    ENTRY CODE                                                       *
*=====================================================================*
&IHBNX.B STM   &R14,&R12,12(&R13)       SAVE CALLER'S REGS
         LR    &BA$E,&R15               LOAD BASE REGISTER
         AIF   ('&BASE2' EQ '').BASEFIN
         L     &BASE2,&IHBNX.A          LOAD SECOND BASE REGISTER
         OACUSING &NFS+4096,&BASE2
         AIF   ('&BASE3' EQ '').BASEFIN
         L     &BASE3,&IHBNX.Z          LOAD BASE3 FOR MLE,BMD,VIC
         OACUSING &NFS+8192,&BASE3
         AIF   ('&BASE4' EQ '').BASEFIN
         L     &BASE4,&IHBNX.Q          WHAT'S GOING ON HERE???
         OACUSING &NFS+12288,&BASE4
.BASEFIN AIF   (N'&USING LT 1).NOUSING
&X       SETA  1
.USINGLP OACUSING &USING(&X),&USING(&X+1)
&X       SETA  &X+2
         AIF   (&X LT N'&USING).USINGLP
.NOUSING ANOP
&AR      SETC  '&R14'                   SET DEFAULT FOR LENREG=
&LR      SETC  '&R15'                   SET DEFAULT FOR ADDRREG=
         AIF   (('&ADDRREG' EQ '') AND ('&LENREG' EQ '')).NO$AR
         AIF   (('&ADDRREG' NE '') AND ('&LENREG' NE '')).ARLR
         MNOTE 8,'ADDRREG= AND LENREG= MUST BOTH BE GIVEN'
.ARLR    ANOP
&AR      SETC  '&ADDRREG'
&LR      SETC  '&LENREG'
.NO$AR   AIF   ('&PARMREG' EQ '').NOPARMR
         LR    &PARMREG,&R1             SAVE PARM POINTER
.NOPARMR AIF   ('&LPARM' EQ '').NOLPARM
&NAME    L     &LPARM,0(,&R1)           PICK UP PARM POINTER
&NAME    SETC  ''
         AIF   (&ENVTSO).NOLPARM
         AIF   ('&ADDRREG' EQ '').NOLPARM
         LH    &LR,0(,&LPARM)           GET PARM LENGTH
         LA    &AR,2(,&LPARM)           POINT PAST LENGTH
.NOLPARM AIF   ('&GET1' EQ '').STATIC
&NAME    L     &R0,&IHBNX.L             PICK UP SP AND LENGTH
&NAME    SETC  ''
*        GETMAIN  R,LV=(0)              GET A WORKAREA (DSA)
         GETMAIN  R,LV=(0)
.USE1    ST    &R1,8(,&R13)             FORW CHAIN SAVE AREAS
         ST    &R13,4(,&R1)             BACK CHAIN SAVE AREAS
         LR    &R13,&R1                 GET NEW SAVE AREA ADDR
         AIF   ('&GET2' EQ '').CONT3
         OACUSING &GET2,&R13
         AGO   .CONT3
.STATIC  AIF   ('&PARMREG' NE '&R15').NOT15
&NAME    LA    &R1,&$AVE                GET SAVE AREA ADDR
&NAME    SETC  ''
         AGO   .USE1
.NOT15   LA    &R15,&$AVE               GET SAVE AREA ADDR
         ST    &R15,8(,&R13)            FORW CHAIN SAVE AREAS
         ST    &R13,4(,&R15)            BACK CHAIN SAVE AREAS
         LR    &R13,&R15                GET NEW SAVE AREA ADDR
.CONT3   AIF   ('&RCLOC' EQ '').CONT3B
         XC    &RCLOC,&RCLOC            INIT RCLOC TO ZERO
.CONT3B  SPACE 3
         AIF   (NOT &ENVCP).NMVCPPL
         MVC   CPPL(CPPLL),0(&PARMREG)  COPY CPPL TO SAFE PLACE
.NMVCPPL AIF   (&FKCALL OR &FKCP).FAKE$A
         AIF   ('&ADDRREG' EQ '').LOAD
         AIF   (&ENVTSO).FAKE$A
         L     &AR,0(,&PARMREG)         POINT TO PARM (LENGTH)
         LH    &LR,0(,&AR)              GET PARM LENGTH
         LA    &AR,2(,&AR)              POINT PAST LENGTH
         AGO   .INUSE
.FAKE$A  SPACE 2
*  DETERMINE WHETHER WE HAVE BEEN CALLED AS A TSO CP OR THRU CALL
         SPACE 1
         L     &R1,16                   CVTPTR
         L     &R1,0(,&R1)              TCBWORDS
         L     &R1,4(,&R1)              TCB
*%%      TM    148(&R1),X'80'           IS THIS TSO?    %%%
*%%      BNO   &IHBNX.C                 NO - SKIP       %%%
         L     &R1,180(,&R1)            TCB.JSCB
         L     &R1,264(,&R1)            JSCB.PSCB
         LA    &R0,0(,&R1)              CLEAR HIGH BYTE
         L     &R1,8(,&PARMREG)         POSSIBLE PSCB PTR
         LA    &R1,0(,&R1)              CLEAR HIGH BYTE
         TM    0(&PARMREG),X'80'        ONLY 1 PARM?
         BO    &IHBNX.E                 YES - // EXEC OR TSO CALL
         CR    &R0,&R1                  THIRD PARM -> PSCB?
         AIF   (('&ADDRREG' NE '') OR (&FKCALL)).SETCPR
         BE    &IHBNX.C                 YES - WERE CALLED AS A TSO CP
         AGO   .CONT5                   SKIP AROUND
.SETCPR  BNE   &IHBNX.E                 NO - NOT TSO CP
         SPACE 2
*  HAVE BEEN CALLED AS A CP
         SPACE 1
         AIF   ('&ADDRREG' EQ '').NO$AR2
         L     &R1,0(,&PARMREG)         CBUF PTR
         LH    &LR,0(,&R1)              LENGTH OF CBUF
         LH    &AR,2(,&R1)              OFFSET TO FIRST NON-BLANK
         LA    &LR,0(&LR,&R1)           POINT PAST CBUF
         LA    &AR,4(&AR,&R1)           POINT TO FIRST NON-BLANK
         SR    &LR,&AR                  LENGTH OF PARMS
.NO$AR2  AIF   (&FKCALL).CONT4
         B     &IHBNX.C                 CONTINUE
         AGO   .CONT5
.CONT4   AIF   (NOT &FKCALL).NOFAKE1
         STH   &LR,&T$FAKE+4            SET FAKED LENGTH OF PARM
         LTR   &R1,&LR                  COPY LENGTH
         AIF   ('&TSFAKE(2)' EQ '').NOMXCK1
         CH    &R1,&TSFAKE(2)           PARM TOO BIG?
         BNH   *+8                      NO - OK
         LH    &R1,&TSFAKE(2)           TOO BIG - USE MAX
         LTR   &R15,&R15                TEST PARM LENGTH
.NOMXCK1 BNP   *+16                     SKIP IF NO PARM       >=====+
         BCTR  &R1,0                    -1 FOR EXECUTE              |
         EX    &R1,*+4                  MOVE THE PARM TO WORKAREA   |
         MVC   &T$FAKE+6(0),0(&AR)      << EXECUTED >>              |
         LA    &R1,&T$FAKE+4            GET FAKE PARM ADDR    <=====+
         ST    &R1,&T$FAKE              STORE IT
         LA    &PARMREG,&T$FAKE         GET ADDR OF FAKED PARM
         MVI   &T$FAKE,X'80'            SET END OF LIST BIT
         B     &IHBNX.C                 CONTINUE
         AGO   .CONT5
.NOFAKE1 AIF   (NOT &FKCP).LOAD
.CONT5   SPACE 2
*  HAVE BEEN CALLED FROM BATCH, OR TSO CALL
         SPACE 1
&IHBNX.E L     &AR,0(,&PARMREG)         POINT TO PARM LENGTH
         LH    &LR,0(,&AR)              GET LENGTH OF PARM
         LA    &AR,2(,&AR)              POINT PAST LENGTH
         AIF   (NOT &FKCP).NOFAKE2
*  CPPL=ADDR(CBUF,UPT,PSCB,ECT)
         LA    &R1,&T$FAKE              GET ADDR OF FAKE CBUF
         ST    &R1,CPPLCBUF             SET INTO CPPL                +0
         LR    &R1,&R0                  COPY PSCB ADDR
         ST    &R0,CPPLPSCB             SET INTO FAKE CPPL           +8
         MVC   CPPLUPT(4),52(&R1)       MOVE UPT ADDR INTO CPPL      +4
         L     &R1,48(,&R1)             PSCB.RLGB
         L     &R1,256(,&R1)            RLGB.ECT
         ST    &R1,CPPLECT              SET IN CPPL                 +12
         SPACE 1
*  CBUF=Y(CBUF_LEN,OFFSET_TO_NONBLANK),C'CMDNAME',C' ',C'OPERANDS'
         MVC   &T$FAKE+4(8),12(&R1)     MOVE CMD NAME TO CBUF
         MVI   &T$FAKE+4+8,C' '         PUT IN DELIMETER
         NI    28(&R1),X'7F'            TURN OFF "NO OPERANDS" BIT
         LTR   &LR,&LR                  ANY OPERANDS?
         BP    *+8                      YES - SKIP
         OI    28(&R1),X'80'            SET "NO OPERANDS" BIT IN ECT
         SPACE 1
         LA    &R1,8+1                  OFFSET TO FIRST NON-BLANK
         STH   &R1,&T$FAKE+2            SET IN FAKE CBUF
         LA    &R0,8+1+4(,&LR)          GET LENGTH OF CBUF
         STH   &R0,&T$FAKE              SET INTO FAKE CBUF
         AIF   ('&TSFAKE(2)' NE '').MAXCK
         LTR   &R1,&LR                  ANY OPERANDS?
         AGO   .NOMXCK2                 CONTINUE
.MAXCK   LR    &R1,&LR                  COPY PARM LENGTH
         CH    &R1,&TSFAKE(2)           PARM TOO BIG?
         BNH   *+8                      NO - OK
         LH    &R1,&TSFAKE(2)           TOO BIG - USE MAX
         LTR   &LR,&LR                  ANY OPERANDS?
.NOMXCK2 BNP   *+16                     NO - SKIP             >=====+
         BCTR  &R1,0                    -1 FOR EXECUTE              |
         MVC   &T$FAKE+4+8+1(0),0(&AR)  << EXECUTED >>              |
         EX    &R1,*-6                  MOVE THE PARM TO FAKE CBUF  |
         LA    &PARMREG,CPPL            POINT TO CPPL         <=====+
.NOFAKE2 SPACE 2
&NAME    SETC  '&IHBNX.C'
         SPACE 2
.LOAD    AIF   ('&LOAD' EQ '').NOLOAD
&X       SETA  1
.LOAD$LP AIF   ('&LOAD(&X)' EQ '').NOLOAD
         AIF   (NOT &ENVMVS).YESLOAD
&NAME    ENTR1I  &LOAD(&X),IKJPTGT,464
&NAME    ENTR1I  &LOAD(&X),IKJPUTL,444
&NAME    ENTR1I  &LOAD(&X),IKJGETL,348
&NAME    ENTR1I  &LOAD(&X),IKJPARS,524
&NAME    ENTR1I  &LOAD(&X),IKJDAIR,732
&NAME    ENTR1I  &LOAD(&X),IKJSTCK,472
&NAME    ENTR1I  &LOAD(&X),IKJSCAN,480
&NAME    ENTR1I  &LOAD(&X),IKJEHCIR,740
&NAME    ENTR1I  &LOAD(&X),IKJEHDEF,736
&NAME    ENTR1I  &LOAD(&X),IKJEFF02,976                            SDM
         AIF   (NOT &MVSCVT).YESLOAD    IT WAS NOT ONE OF THE ABOVE
&NAME    SETC  ''                       IT WAS
.YESLOAD MNOTE *,'       LOAD  EPLOC==CL8''&LOAD(&X)'''
&NAME    LOAD  EPLOC==CL8'&LOAD(&X)'
&NAME    SETC  ''
.ADDRSAV ST    &R0,&LOAD(&X)
.SKIPASV SPACE 1
         AIF   ('&LOAD(&X)' NE 'IKJDAIR').NO$DAIR
&GDAIR   SETB  1                        DAIR LOADED
         AGO   .LOADNXT
.NO$DAIR AIF   ('&LOAD(&X)' NE 'IKJPARS').NO$PARS
&GPARSE  SETB  1                        PARSE WAS LOADED
&PARNAME SETC  'IKJPARS'
.NO$PARS ANOP
.LOADNXT ANOP
&X       SETA  &X+1
         AGO   .LOAD$LP
.NOLOAD  AIF   ('&PL' EQ '').NO$PL$1
&X       SETA  1
.PLLOOP  AIF   ('&PL(&X)' NE 'CSCAN').PL2
&CSPL    SETB  1
         AGO   .PLNEXT
.PL2     AIF   ('&PL(&X)' NE 'PARSE').PL3
&PARS    SETB  1
         AGO   .PLNEXT
.PL3     AIF   ('&PL(&X)' NE 'DAIR').PL4
&DAIR    SETB  1
         AGO   .PLNEXT
.PL4     AIF   ('&PL(&X)' NE 'IO').PL5
&IO      SETB  1
         AGO   .PLNEXT
.PL5     AIF   ('&PL(&X)' NE 'MESSAGE').PL6
&MSG     SETB  1
         AGO   .PLNEXT
.PL6     MNOTE 4,'PL=&PL(&X) UNKNOWN -- IGNORED'
.PLNEXT  ANOP
&X       SETA  &X+1
         AIF   (&X LE N'&PL).PLLOOP
.NO$PL$1 AIF   ('&PARSE(2)' EQ '').PLNOTM
&MSG     SETB  1
.PLNOTM  AIF   (NOT (&CSPL OR &PARS OR &DAIR OR &IO OR &MSG)).NOSETPL
&NAME    L     &R1,CPPLUPT              GET UPT PTR
&NAME    SETC  ''
         L     &R2,CPPLECT              GET ECT PTR
         LA    &R3,TSECB                GET ECB PTR
         SR    &R0,&R0                  GET A 0
         ST    &R0,TSECB                CLEAR ECB
         AIF   (NOT &CSPL).NOSETC
         SPACE 1
         STM   &R1,&R3,CSPL             INITIALIZE CSPL (UPT, ECT, ECB)
         ST    &R0,CSFLG                ZERO CSFLG
         LA    &R0,CSFLG
         ST    &R0,CSPLFLG
         LA    &R0,CSOA
         ST    &R0,CSPLOA
.NOSETC  AIF   (NOT &PARS).NOSETP
         STM   &R1,&R3,PPL              INITIALIZE PPL (UPT, ECT, ECB)
         LA    &R0,TSPARANS             PTR TO PARSE ANSWER PLACE
         ST    &R0,PPLANS
         ST    &R13,PPLUWA              PARSE USER WORK AREA PTR
         XC    TSPARANS(4),TSPARANS     AVOID DUPLICATE IKJRLSA
.NOSETP  AIF   (NOT &DAIR).NOSETD
         STM   &R1,&R3,DAPL             INITIALIZE DMPL (UPT, ECT, ECB)
         MVC   DAPLPSCB(4),CPPLPSCB
.NOSETD  AIF   (NOT &IO).NOSETI
         STM   &R1,&R3,IOPL             INITIALIZE IOPL (UPT, ECT, ECB)
.NOSETI  AIF   (NOT &MSG).NOSETM
         ST    &R3,MPLECB               INIT MPL ECB PTR
         LA    &R0,CPPL
         ST    &R0,MPLCPPL
         LA    &R0,MPLCSECT             PTR TO MSG CSECT
         ST    &R0,MPLCSECP
         XC    MPLSW(MPLZL),MPLSW       INITIALIZE REMAINING MPL TO 0
.NOSETM  ANOP
.NOSETPL AIF   ('&PARSE(1)' EQ '').NOPARSE
         SPACE 2
***********************************************************************
*                                                                     *
*  PARSE THE COMMAND LINE                                             *
*                                                                     *
***********************************************************************
         SPACE 2
         MNOTE *,'       TSPARSE CBUF=(CPPLCBUF,I),PCL=(=V(&PARSE(1)),I$
               ),'
         MNOTE *,'               SYNAD=&PARSE(2),ENTRY=&PARNAME'
         TSPARSE  CBUF=(CPPLCBUF,I),PCL=(=V(&PARSE(1)),I),             $
               SYNAD=&PARSE(2),ENTRY=&PARNAME
&NAME    SETC  ''
         SPACE 5
         AIF   ('&PARSE(2)' EQ '').NOPARSE   NO ERROR ANALYSIS ROUTINE
&NAME    SETC  '&IHBNX.P'
         SPACE 2
         B     &NAME                    SKIP AROUND PARSE ERR ANALYSIS
         SPACE 6
***********************************************************************
*                                                                     *
*  PARSE ERROR ANALYSIS SUBROUTINE                                    *
*                                                                     *
***********************************************************************
         TSPARERR
         SPACE 6
.NOPARSE AIF   ('&NAME' EQ '').NONAME
&NAME    DS    0H
.NONAME  ANOP
.INUSE   OACINUSE
         SPACE 2
         AIF   ('&PL' EQ '').MEND
         AIF   ('&GET2' NE '').PLOK2
         MNOTE 8,'*** PL= INVALID WITHOUT SECOND OPERAND OF GETMAIN='
         MEXIT
.PLOK2   EJECT
&GET2    DSECT
         DS    18F                      SAVE AREA
TSECB    DS    F                        ECB FOR TSO SERVICES
         SPACE 2
*        TSCPPL
         TSCPPL
         AIF   ('&TSFAKE' NE 'YES').NOFAKED
         SPACE 1
&T$FAKE  DS    2H,CL256                 AREA FOR FAKE CBUF
         AIF   ('&PRINT' NE 'NOGEN').NOFAKED
         PRINT NOGEN                    SUPPRESS THE DSECTS
.NOFAKED AIF   (NOT &CSPL).NOTCSPL
         SPACE 2
         MNOTE *,'       TSCSPL'
         TSCSPL
.NOTCSPL AIF   (NOT &PARS).NOTPARS
         SPACE 2
         MNOTE *,'       TSPPL'
         TSPPL
.NOTPARS AIF   (NOT &DAIR).NOTDAIR
         SPACE 2
         MNOTE *,'       TSDAPL'
         TSDAPL
         SPACE 1
DAPBAREA DS    22F                      AREA FOR DAIR PARAMETER BLOCK
         SPACE 2
         MNOTE *,'       TSDMPL'
         TSDMPL
.NOTDAIR AIF   (NOT &IO).NOTIO
         SPACE 2
         MNOTE *,'       TSIOPL'
         TSIOPL
.NOTIO   AIF   (NOT &MSG).NOTMSG
         SPACE 2
         MNOTE *,'       TSMPL'
         TSMPL
.NOTMSG  AIF   ('&PRINT' NE 'NOGEN').NOTMSGX
         PRINT GEN
.NOTMSGX AIF   ('&LOAD' EQ '').NOLOAD2
         SPACE 2
&X       SETA  1
.NXTLOAD AIF   (&X GT N'&LOAD).NOLOAD2
&LOAD(&X) DS   A
&X       SETA  &X+1
         AGO   .NXTLOAD
.NOLOAD2 SPACE 2
         AIF   ('&MACRO' NE 'YES').NOMACRO
         SPACE 3
***********************************************************************
*                                                                     *
*  DYNAMIC STORAGE DEFINED BY USER TSWORK MACRO                       *
*                                                                     *
***********************************************************************
         SPACE 1
         TSWORK
         SPACE 2
&GET1    EQU   *-&GET2                  LNTH OF DYNAMIC AREA TO GETMAIN
         SPACE 2
.NOMACRO AIF   (NOT &DAIR).NODAPBS
         AIF   (&GDAIRM).NODAPBS
&GDAIRM  SETB  1
         AIF   ('&PRINT' NE 'NOGEN').GEN4
         PRINT NOGEN                    SAVE SOME PAPER
.GEN4    EJECT
         MNOTE *,'       IKJDAP08'
         IKJDAP08
DAPB08L  EQU   *-DAPB08
         SPACE 5
         MNOTE *,'       IKJDAP18'
         IKJDAP18
DAPB18L  EQU   *-DAPB18
         SPACE 5
         MNOTE *,'       IKJDAP1C'
         IKJDAP1C
DAPB1CL  EQU   *-DAPB1C
         SPACE 5
         MNOTE *,'       IKJDAP30'
         IKJDAP30
DAPB30L  EQU   *-DAPB30
         AIF   ('&PRINT' NE 'NOGEN').NODAPBS
         PRINT GEN                      RESTORE
         SPACE 10
.NODAPBS ANOP
&NFS     CSECT
         SPACE 3
.MEND    MEND
         MACRO
&NFS     HEX   &TO,&FROM,&L,&LEN=,&HEXTAB=,&BYTE=C' ',&DIGITS=
         GBLC  &HEXTAB#
         LCLA  &LT                      UNPK "TO" LENGTH
         LCLA  &LF                      UNPK "FROM" LENGTH
         LCLA  &LTR                     TR "TO" LENGTH
         LCLA  &LL                      &LEN ONE WAY OR ANOTHER
         LCLC  &F1,&F2,&T1,&T2,&LX
&F1      SETC  '&FROM(1)'               FOR SHORTER STRING LATER
&F2      SETC  '&FROM(2)'               FOR SHORTER STRING LATER
&T1      SETC  '&TO(1)'                 FOR SHORTER STRING LATER
&T2      SETC  '&TO(2)'                 FOR SHORTER STRING LATER
&LX      SETC  '&L&LEN'                 GET LENGTH USING EITHER METHOD
         AIF   ('&LX' EQ '').DEFLEN     LENGTH WILL DEFAULT TO 4
&LL      SETA  &LX                      GET IT
         AGO   .OKLEN
.DEFLEN  ANOP
&LL      SETA  4                        SET THE DEFAULT LENGTH
.OKLEN   AIF   ('&HEXTAB' EQ '').OKHEX1
&HEXTAB# SETC  '&HEXTAB'
.OKHEX1  AIF   ('&HEXTAB#' NE '').OKHEX2
&HEXTAB# SETC  'HEXTAB'
.OKHEX2  ANOP
&LT      SETA  &LL*2
         AIF   ('&DIGITS' EQ '').OKDIGIT
&LT      SETA  &DIGITS
.OKDIGIT AIF   (N'&TO NE 2).TO1
         AIF   (N'&FROM NE 2).T2F1
&NFS     UNPK  &T1.(&LT+1,&T2),&F1.(&LL+1,&F2)
         TR    &T1.(&LT,&T2),&HEXTAB#
         MVI   &T1+&LT.(&T2),&BYTE
         AGO   .DONE
.T2F1    AIF   (N'&FROM NE 1).ERRF
&NFS     UNPK  &T1.(&LT+1,&T2),&FROM.(&LL+1)
         TR    &T1.(&LT,&T2),&HEXTAB#
         MVI   &T1+&LT.(&T2),&BYTE
         AGO   .DONE
.TO1     AIF   (N'&TO NE 1).ERRT
         AIF   (N'&FROM NE 2).T1F1
&NFS     UNPK  &TO.(&LT+1),&F1.(&LL+1,&F2)
         TR    &TO.(&LT),&HEXTAB#
         MVI   &TO+&LT,&BYTE
         AGO   .DONE
.T1F1    AIF   (N'&FROM NE 1).ERRF
&NFS     UNPK  &TO.(&LT+1),&FROM.(&LL+1)
         TR    &TO.(&LT),&HEXTAB#
         MVI   &TO+&LT,&BYTE
         AGO   .DONE
.ERRF    MNOTE 8,'ERROR IN "FROM" PARAMETER, MACRO TERMINATED'
         MEXIT
.ERRT    MNOTE 8,'ERROR IN "TO" PARAMETER, MACRO TERMINATED'
         MEXIT
.DONE    SPACE 1
         MEND
         MACRO
&NFS     ID    &ID,&OPT,&DATE=,&TIME=
         GBLC  &$$DATE1
         LCLC  &XDATE,&XTIME
         LCLA  &L
&L       SETA  K'&ID
         AIF   ('&OPT' EQ 'ASIS').ASIS
         AIF   ('&OPT' NE 'NODATE').DATE
.ASIS    ANOP
&NFS     DC    AL1(&L),C'&ID'
         MEXIT
.DATE    $$ASM
&XDATE   SETC  '&$$DATE1'
         AIF   ('&DATE' EQ '').OKDATE
&XDATE   SETC  '&DATE'                  USE WHAT HE WANTS
.OKDATE  ANOP
&L       SETA  &L+K'&XDATE+2
         AIF   ('&OPT' NE 'NOTIME').TIME
&NFS     DC    AL1(&L),C'&ID  &XDATE'
         MEXIT
.TIME    ANOP
&XTIME   SETC  '&SYSTIME'               DEFAULT TO CURRENT TIME
         AIF   ('&TIME' EQ '').OKTIME   HE DIDN'T SPECIFY, USE CURRENT
&XTIME   SETC  '&TIME'                  USE WHAT HE WANTS
.OKTIME  ANOP
&L       SETA &L+K'&XTIME+1             =1+8
         AIF   ('&OPT' NE '').BADOPT
&NFS     DC    AL1(&L),C'&ID  &XDATE &XTIME'
         MEXIT
.BADOPT  MNOTE 0,'*** (ID MACRO) OPT=&OPT IS INVALID, IGNORED.'
         MNOTE *,'(MUST BE NULL, "NOTIME", "NODATE", OR "ASIS")'
         MEND
         EJECT                                                     LDW1
         GBLB  &MVS                     1 = THIS IS MVS            LDW1
         GBLB  &MVT                     1 = THIS IS MVT            LDW1
         SPACE 3
&MVS     SETB  1 (WAS 0)                IT TAKES A 3033 TO RUN MVS  MVS
&MVT     SETB  0 (WAS 1)                BUT IT'S STILL NOT UP.      MVS
****LDW$ ACTR  100
         AIF   (&MVS NE &MVT).OK1                                  LDW1
***********************************************************************
***********************************************************************
%%%%%% ERROR---MVT AND/OR MVS SETB SET INCORRECTLY %%%%%%%%%%%%%%%%%%%%
***********************************************************************
***********************************************************************
.OK1     SPACE 4
*  SEQUENCE SYMBOLS IN USE:                                        LDW1
*
*  .MVS**   01 02 03 04 05 06 07 08 09 10 11
*  .MVT**   01 02 03 04 05 06 07
*  .CCN**   01 02 03 04 05 06
*  .NCCN**  01 02 03 04 05 06 07 08 09
         EJECT
**********************************************************************
*                                                                    *
*  PROGRAM:  ZAP    (UNDER TSO)                                      *
*                                                                    *
*                                                                    *
*  THIS PROCESSOR IS RE-ENTRANT AND SERIALLY REUSABLE                *
*                                                                    *
*                                                                    *
*                                                                    *
*                                                                    *
*  FOR FULL DOCUMENTATION OF COMMANDS AND SO ON, SEE THE LISTING     *
*  OF THE URSA VERSION IN BINDER 'URSA MISCELLANEOUS VOLUME 3'       *
*                                                                    *
*                                                                    *
*                                                                    *
*                                                                    *
*  PROGRAMMER:  VIC TOLOMEI                                          *
*                                                                    *
*                                                                    *
*  WRITTEN FOR URSA:         5/22/73                                 *
*  CHANGE TO TSO VERSION:    1/22/75                                 *
*                                                                    *
**********************************************************************
         SPACE 5
**********************************************************************
*                                                                    *
*  ZAP                                                               *
*                                                                    *
*  GENERAL ZAP OUTLINE:                                              *
*                                                                    *
*  THIS SERVICE WILL DISPLAY ANY TYPE OF DATA SET (EXCLUDING         *
*  ISAM) IN DUMP FORMAT, ACCEPT VARIOUS DISPLAY FORMATTING           *
*  AND MODIFYING COMMANDS, AND APPLY INTERACTIVE CHANGES             *
*  AS DOES IBM'S SERVICE AID, IMASPZAP (SUPERZAP).                   *
*  HARDCOPY LINES ARE PRINTED FOR ALL DATA SET MODIFICATIONS         *
*  AND 'POTENTIAL MODIFICATIONS'  (THOSE NOT YET APPLIED) AS WELL AS *
*  COMMENTS AND DUMPED BLOCKS.  THE FOLLOWING CONDITIONS CAUSE       *
*  A LINE TO BE WRITTEN INTO THE PRINT FILE:  ACCESSING A DATA SET,  *
*  'ZAPPING' A BLOCK, STORING IN THE BUFFER (S,X,O,N, OR SET),       *
*  SELECTING A MEMBER, CREATING A COMMENT, EJECTING A PAGE, OR       *
*  DUMPING A BLOCK OR BLOCKS.  THE FILE WILL BE PRINTED ONLY IF AN   *
*  EXPLICIT DUMP, COMMENT, OR PERMANENT CHANGE IS MADE.  THE FILE    *
*  IS ACTUALLY RELEASED FOR PRINTING UPON EXIT FROM THE DATA SET.    *
*  IDR'S ARE UPDATED IN LOAD MODULE DATA SETS IN THE FORMAT SUPERZAP *
*  USES (WITH 'TSO--III' AS THE ID DATA FIELD).                      *
*  END-OF-FILES MAY BE JUMPED TO VIEW DATA BEYOND UP TO THE EXTENT   *
*  OF THE DATA SET  (USEFUL IF AN INADVERTANT EOF WAS WRITTEN IN THE *
*  MIDDLE OF A DATA SET).                                            *
*                                                                    *
**********************************************************************
         EJECT
*  THE OLD SCREEN FORMAT WAS AS FOLLOWS:                           LDW1
         SPACE 2
*               ##########################################
*               # *MSG*  *TALK*  Z  A  P  *BULL*  *OUT* >#
*               #L'NOTHING'                              #
*               #ENTER VALID COMMAND ABOVE OR ? FOR HELP #
*               # ***** I/O ERROR: XXXXXXXXXXXXXXX ***** #
*               #000000  F1F2 F3F4  F5F6 F7F8  |12345678|#
*               #000008  F1F2 F3F4  F5F6 F7F8  |12345678|#
*               #000010 >F1F2 F3F4  F5F6 F7F8  |12345678|#
*               #000018  F1F2 F3F4  F5F6 F7F8  |12345678|#
*               #000020  F1F2 F3F4  F5F6 F7F8  |12345678|#
*               #000028  F1F2 F3F4  F5F6 F7F8  |12345678|#
*               #000030  F1F2 F3F4  F5F6 F7F8  |12345678|#
*               #000038  F1F2 F3F4  F5F6 F7F8  |12345678|#
*               #000040  F1F2 F3F4  F5F6 F7F8  |12345678|#
*               #000048  F1F2 F3F4  F5F6 F7F8  |12345678|#
*               #000050  F1F2 F3F4  F5F6 F7F8  |12345678|#
*               #000058  F1F2 F3F4  F5F6 F7F8  |12345678|#
*               #000060  F1F2 F3F4  F5F6 F7F8  |12345678|#
*               #        *****  SCAN MATCH  *****        #
*               #DSN: CPC013.LDW.SCREEN.SAMPLE OFF:  0010#
*               #TTR: 000001 CCHHR: 0022000301 LEN:   400#
*               ##########################################
         SPACE 3
*  THE NEW FORMAT IS AS FOLLOWS:                                   LDW1
*  (SOME BLANK COLUMNS HAVE BEEN OMITTED SO IT WILL FIT)           LDW1
         SPACE 2
*              *MSG*  *TALK*  Z  A  P  *BULL*  *OUT*                  >
*(TYPE HERE)
*ENTER VALID COMMAND ABOVE OR ? FOR HELP
*L'12345678'
*             ***** I/O ERROR: XXXXXXXXXXXXXXX *****
*00000  F1F2 F3F4  F5F6 F7F8  F9C1 C2C3  C4C5 C6F0   |123456789ABCDEF0|
*00010 >F1F2 F3F4  F5F6 F7F8  F9C1 C2C3  C4C5 C6F0   |123456789ABCDEF0|
*00020  F1F2 F3F4  F5F6 F7F8  F9C1 C2C3  C4C5 C6F0   |123456789ABCDEF0|
*00030  F1F2 F3F4  F5F6 F7F8  F9C1 C2C3  C4C5 C6F0   |123456789ABCDEF0|
*00040  F1F2 F3F4  F5F6 F7F8  F9C1 C2C3  C4C5 C6F0   |123456789ABCDEF0|
*00050  F1F2 F3F4  F5F6 F7F8  F9C1 C2C3  C4C5 C6F0   |123456789ABCDEF0|
*00060  F1F2 F3F4  F5F6 F7F8  F9C1 C2C3  C4C5 C6F0   |123456789ABCDEF0|
*00070  F1F2 F3F4  F5F6 F7F8  F9C1 C2C3  C4C5 C6F0   |123456789ABCDEF0|
*00080  F1F2 F3F4  F5F6 F7F8  F9C1 C2C3  C4C5 C6F0   |123456789ABCDEF0|
*00090  F1F2 F3F4  F5F6 F7F8  F9C1 C2C3  C4C5 C6F0   |123456789ABCDEF0|
*000A0  F1F2 F3F4  F5F6 F7F8  F9C1 C2C3  C4C5 C6F0   |123456789ABCDEF0|
*000B0  F1F2 F3F4  F5F6 F7F8  F9C1 C2C3  C4C5 C6F0   |123456789ABCDEF0|
*000C0  F1F2 F3F4  F5F6 F7F8  F9C1 C2C3  C4C5 C6F0   |123456789ABCDEF0|
*000D0  F1F2 F3F4  F5F6 F7F8  F9C1 C2C3  C4C5 C6F0   |123456789ABCDEF0|
*                    *****  SCAN MATCH  *****
*OFF: 0010 (    16) ADDR: 00010 (     16) DSN: CPC013.LDW.SCREEN.SAMPLE
*LEN: 0190 (   400) BASE: 00000 (      0) CCHHR: 0022003301 TTR: 000001
         SPACE 1
         EJECT
ZAP      CSECT ,
         SPACE 1
F0       EQU   0
F2       EQU   2
F4       EQU   4
F6       EQU   6
F8       EQU   8
         SPACE 2
**********************************************************************
*                                                                    *
*  REGISTER USAGE:  R0-R7...WORK REGS                                *
*                   R8......PRIMARY BAL REG                          *
*                   R9......FOURTH BASE REGISTER                     *
*                   R10.....THIRD BASE REGISTER                      *
*                   R11.....SECOND BASE REGISTER                     *
*                   R12.....FIRST BASE REGISTER (BASE FOR EXP)       *
*                   R13.....TS WORKAREA (SAVEAREA, 'CSAREA', ETC)    *
*                   R14.....WORK AND RET ADDR                        *
*                   R15.....WORK AND ENTRY POINT ADDR                *
*                                                                    *
**********************************************************************
         TITLE 'ZAP --- INITIALIZATION'
*ZAP     TSENTRY BASE=R12,SYMREG=NO,PL=(PARSE,DAIR,MESSAGE,IO),    LDW1X
               MACRO=YES,LOAD=(IKJPTGT,IKJPUTL)                    LDW1
ZAP      ENTR  PL=(PARSE,DAIR,IO),LOAD=(IKJPTGT,IKJPUTL),          LDW1$
               ENV=CP,TSFAKE=YES,MACRO=YES,PARMREG=R5,             LDW1$
               BASE=R12,BASE2=R11,BASE3=R10,BASE4=R9               LDW1
         EJECT                                                     LDW1
CSREG    EQU   13
*LDW1    LA    R11,4095(,R12)           BASE #2                    LDW1
*LDW1    LA    R11,1(,R11)                                         LDW1
*LDW1    LA    R10,4095(,R11)           BASE #3                    LDW1
*LDW1    LA    R10,1(,R10)                                         LDW1
*LDW1    LA    R9,4095(,R10)            BASE #4                    LDW1
*LDW1    LA    R9,1(,R10)                                          LDW1
         SPACE 2
         MVI   BLANKS,C' '              INIT                       LDW1
         MVC   BLANKS+1(L'BLANKS-1),BLANKS                         LDW1
         MVC   VERSION,BLANKS           INIT                       LDW1
         MVC   VERSION(12),=C'VERSION=2.3 '                        LDW5
         MVC   VERSION+13(7),ZAP+10     DATE                       LDW1
*MAS2    MVC   VERSION+21(3),=C'LDW'                               LDW1
         SPACE 1
         TSFIND  PSCB,R1                -> PSCB                    LDW1
         SPACE 1
         MVC   USERID(7),0(R1)          GET THE TSO USER ID        LDW1
         MVC   USERID+7(L'USERID-7),BLANKS   BLANK THE REST        LDW1
*%       MVC   LINELEN,=H'80'           DEFAULT LINE LENGTH        LDW1
         MVC   DISPCONS(DISPCONL),DSPCON80  CONSTANTS FOR LEN=80   LDW1
         MVC   CTL3270,CTL3270C         INIT 3270 CONTROL BYTES    LDW1
         MVC   END3270,END3270C         FINISH IT                  LDW1
         LA    R0,SCREENL               GET TPUT LENGTH            LDW2
         LA    R1,SCREEN                GET TPUT ADDR              SDM5
         STM   R0,R1,REGS3270           SAVE FOR FULLSCR TPUT      LDW1
         MVI   REGS3270+4,X'03'         SET FULLSCR TPUT FLAG      SDM5
         XC    CURPOS,CURPOS            CLEAR CURSOR POSITION      LDW1
         LA    R1,JFCB                  -> JFCB                    LDW1
         ST    R1,EXLST                                            LDW1
         MVI   EXLST,X'87'              CALL IT A JFCB             LDW1
         SPACE 1
         LA    R6,4095(,R13)            TEMP POINT TO EXTRA        LDW1
         USING TSDSECT+4095,R6                                     LDW1
         LA    R0,IDEFTAB                                          LDW3
         ST    R0,AIDEFTAB                                         LDW1
         LA    R1,ITRTAB                                           LDW1
         ST    R1,AITRCTAB                                         LDW1
         MVI   0(R1),X'FE'              SET TO INITIAL VALUE       LDW1
         MVC   1(120-1,R1),0(R1)        SET THE WHOLE THING        LDW1
         ST    R1,ITRAVAL               -> FIRST POS               LDW1
         ST    R1,CURRITR               -> CURRENT POS             LDW1
         MVI   ENDITAB,X'FF'            MARK THE END OF THE TABLE  LDW1
         MVI   ITREND,X'FF'             DITTO                      LDW1
         LA    R0,ITREND                POINT TO IT                LDW1
         ST    R0,AITREND               SAVE                       LDW1
         LA    R1,SCRWORK               -> WORK AREA               LDW2
         ST    R1,ASCRWORK              SAVE ADDR                  LDW2
         LA    R1,OLDSCR                -> SCREEN SAVE AREA        SDM5
         ST    R1,AOLDSCR               SAVE ADDRESS               SDM5
         DROP  R6                                                  LDW1
         L     R1,=A(DCBMSK)            GET ADDR OF PATTERN DCB    LDW1
         MVC   DCBU(DCBUL),0(R1)        SET UP DCB FOR INPUT       LDW1
         XC    IOB(40),IOB              INIT IOB                   LDW1
         MVI   IOB,X'42'                IOBFLAGS                   LDW1
         LA    R0,ECB                   -> EXCP ECB                LDW1
         ST    R0,IOB+4                                            LDW1
         LA    R0,DCBU                                             LDW1
         ST    R0,IOB+20                                           LDW1
         MVC   CCWS(CCWL),CCWLIST       INIT CCWS                  LDW1
         LA    R0,CCHHR                 PTR FOR SEARCH ID EQ       LDW1
         STCMX R0,B'0111',CCW#R#S+1,BYTE=31   SET ADDR             LDW1
         STCMX R0,B'0111',CCW#W#S+1,COPY=CCW#R#S+1     HERE TOO    LDW1
         STCMX R0,B'0111',CCW#F#S+1,COPY=CCW#R#S+1     HERE TOO    LDW1
         LA    R1,CCW#R#S               GET TIC ADDR               LDW1
         STCMX R1,B'0111',CCW#R#T+1,BYTE=08    SET IT              LDW1
         LA    R1,CCW#W#S               GET TIC ADDR               LDW1
         STCMX R1,B'0111',CCW#W#T+1,BYTE=08    SET IT              LDW1
         LA    R1,NAME                  -> KEY                     LDW1
         STCMX R1,B'0111',CCW#D#S+1,BYTE=E9    SET IT              LDW1
         LA    R1,CCW#D#S               GET TIC ADDR               LDW1
         STCMX R1,B'0111',CCW#D#T+1,BYTE=08   SET IT               LDW1
         LA    R1,CCW#F#S               GET TIC ADDR               LDW1
         STCMX R1,B'0111',CCW#F#T+1,BYTE=08   SET IT               LDW1
         MVI   FLAGS2,0                 INIT FLAGS                 LDW1
         MVI   FLAGS3,0                 INIT FLAGS                 LDW5
         SPACE 2                                                   LDW3
*  GUESS IF THIS IS A 3270                                         LDW1
         GTSIZE
         LTR   R0,R0                    ANY LINES?        (ZAP)    MAS1
         BZ    *+16                     BIF NOT 3270      (ZAP)    MAS1
         CH    R1,=H'80'                80 COLUMNS?                LDW1
         BNE   *+8                      NO - NOT 3270              LDW1
         OI    FLAGS3,F3270+RESHOWF     24 LNS & 80 COLS ==> 3270  LDW5
         EJECT                                                     LDW1
*
*  PARSE THE INPUT LINE:
*
*       ZAP  'DSN'  VOL(VOLSER) CRT LOG TERSE/VERBOSE
*
         TSPARSE CBUF=(CPPLCBUF,I),PCL=(=V(PCL),I)
         SPACE 1
         BXLE  R15,R15,OKPARSE          IT'S OK
         SPACE 2
         LA    R1,=CL40'INVALID INPUT'  OOOPS
         B     CSIO#                    SHOW AND QUIT
         SPACE 3
OKPARSE  L     R7,TSPARANS              POINT TO PARSE BLOCK
         OACUSING IKJPARMD,R7           TEMP TO GET DSN AND VOL     MVS
         SPACE 3
         CLI   NWK+1,2                  SEE IF TERSE
         BNE   *+8                      IF NOT NO FLAG
         OI    FLAGS2,TERSEF            SUPRESS WHERE
         SPACE 1
         CLI   CRTK+1,1                 SEE IF CRT SPECIFIED
         BNE   *+8                      IF NOT DONT SET FLAG
         OI    FLAGS3,CRTF              IF SO SET FLAG             LDW5
         SPACE 1
         CLI   LOGK+1,1                 SEE IF LOG SPECIFIED
         BNE   *+8                      IF NOT NO LOG
         OI    FLAGS2,LOGF
         SPACE 1
         SPACE 1                                                   LDW3
         CLI   NOT3270K+1,1             NOT3270 SPECIFIED?         LDW1
         BNE   *+8                      NO - SKIP                  LDW1
         NI    FLAGS3,255-F3270         YES - TURN OFF FLAG        LDW5
         SPACE 1
         XC    WIDTHS(4+4),WIDTHS       DEFAULT = CARET LINE ONLY  LDW1
         TM    FLAGS3,F3270+CRTF        ANYTHING INTERESTING?      LDW5
         BZ    NOT$FULL                 NO - SKIP                  LDW3
         NI    FLAGS2,255-TERSEF        ANY OF THEM IMPLY VERBOSE  LDW5
         MVC   WIDTHD(4),MAXWIDTH       SO 'D' WORKS               LDW1
         MVC   WIDTHU(4),MAXWIDTH       DITTO                      LDW1
NOT$FULL DS    0H                                                  LDW1
         SPACE 2
*
*  CHECK OUT THE USER.  IF HE CAN'T GET IN, OR CAN'T TOUCH THE
*  DATASET, KICK HIM OUT.
*
         L     R1,PDEPTR-PDE+PDLDSN     POINT TO DSN SUPPLIED
         LH    R15,PDELEN-PDE+PDLDSN    POINT TO ITS LEN (<= 45)
         STH   R15,DSNAMEL              SET DSNAME LENGTH         *WDD*
         BCTR  R15,0                    EX LEN
         MVC   DSNAME(44),BLANKS        CLEAR TARGET               LDW1
         MVC   VOLSER(6),BLANKS         BLANK VOL TOO
         MVC   PASSWORD(8),BLANKS       AND THE PASSWORD           LDW1
         MVC   DSNAME(0),0(R1)          <<< EXECUTED >>>
         EX    R15,*-6                  MOVE PARSE DSN TO FULL TARGET
         MVC   DISPDSN,DSNAME           COPY FOR DISPLAYING        LDW1
         CLC   DSNAME(7),=CL7'SYSCTLG'  IS IT CATALOG              JCJ1
         BNE   *+8                      IF NOT LET IT BY
SENSTIVE OI    FLAGS2,SENSF+LOGF        MARK AS SENSITIVE
         SPACE 1
         TM    PDLDSN+PDEFLAG3-PDE,PDEFPRES  PSWD PRESENT?         LDW1
         BNO   NOPASS                   NO                         LDW1
         L     R1,PDLDSN+PDEPTR3-PDE    -> PSWD                    LDW1
         LH    R15,PDLDSN+PDELEN3-PDE   LENGTH                     LDW1
         BCTR  R15,0                    -1 FOR EX                  LDW1
         MVC   PASSWORD(0),0(R1)        << EXECUTED >>             LDW1
         EX    R15,*-6                                             LDW1
NOPASS   TM    PDEFLAG-PDE+VOLVOL,PDEFPRES   ANY VOL SPEC?         LDW1
         BNO   NOVOL                    NO, BLANK (=DAIR CATALOG)
         L     R1,PDEPTR-PDE+VOLVOL     GET PTR TO VOL SER
         LH    R15,PDELEN-PDE+VOLVOL    YES, GET ITS LEN
         BCTR  R15,0                    GET EX LEN
         MVC   VOLSER(0),0(R1)          <<< EXECUTED >>>
         EX    R15,*-6                  MOVE VOL SPEC TO VOLSER
         SPACE 1
NOVOL    MVC   ALLOCDSN,BLANKS          CLEAR FIELD                LDW1
         TM    PDEFLAG-PDE+PDLALCDS,PDEFPRES   GIVEN?              LDW1
         BNO   NOALCDSN                 NO - SKIP                  LDW1
         L     R1,PDEPTR-PDE+PDLALCDS   POINT TO DSN               LDW1
         LH    R15,PDELEN-PDE+PDLALCDS  GET LENGTH                 LDW1
         STH   R15,DSNAMEL              SET LENGTH FOR ALLOC       LDW1
         BCTR  R15,0                    -1 FOR EX                  LDW1
         MVC   ALLOCDSN(0),0(R1)        << EXECUTED >>             LDW1
         EX    R15,*-6                  MOVE IN DSN                LDW1
NOALCDSN DS    0H                                                  LDW1
         CLC   =C'FORMAT4.DSCB',DSNAME  VTOC?
         BNE   NOTVTOC3
         SPACE 2
         MVC   DSNAMEL(2),=H'44'                                 *WDD*
         MVI   DSNAME,X'04'             YES, CHANGE DSN
         MVC   DSNAME+1(43),DSNAME      TO 44X'04'
         MVC   DISPDSN,BLANKS           RESET FIELD                LDW1
         MVC   DISPDSN(8),=C'VTOC FOR'  SHOW SOMETHING GOOD        LDW1
         MVC   DISPDSN+9(6),VOLSER      MOVE IN VOLUME NAME        LDW1
         OI    FLAGS2,SENSF+LOGF        MARK AS SENSITIVE          LDW1
         CLI   ALLOCDSN,C' '            ALLOCDSN GIVEN?            LDW1
         BNE   NOTVTOC3                 YES - VOLSER IS IMPLIED    LDW1
         CLI   VOLSER,C' '              CATALOG FOR VTOC?
         BE    BADDSN                   YES, WHAT DOES THAT MEAN?
         SPACE 3
NOTVTOC3 OI    GODFLAG,GOD              ASSUME HE CAN UPDATE       LDW1
         B     OKDSN5                   CONTINUE                   LDW1
         SPACE 2                                                   LDW1
*
*  INVALID DSN OR INVALID ACCESS. SORRY.
*
BADDSN   LA    R1,=CL40'DATA SET UNAVAILABLE OR NON-EXISTENT'
         B     CSIO#                    INVALID DSN
         SPACE 3
         DROP  R7                       NO NEED FOR IKJPARMD NOW
         SPACE 3
OKDSN5   DS    0H
         EJECT
*
*  SET UP DEFAULTS AND INITIALS COND'S
*
*LDW1    LA    R2,=C'ATTN SIGNALED'     WHAT TO SAY WHEN HE DOES
*LDW1    LA    R3,13                    LENGTH
         XC    STAXLIST(STAXL),STAXLIST INITIALIZE STAX LIST
         L     R14,=A(STAXEXIT)         POINT TO STAX EXIT
*LDW1    STAX  (R14),OBUF=((R2),(R3)),USADDR=(R13),MF=(E,STAXLIST)
         STAX  (R14),USADDR=(R13),MF=(E,STAXLIST)                  LDW1
         SPACE 1
         TM    FLAGS3,CRTF              SEE IF CRT SPECIFIED       LDW5
         BNO   *+10                     IF NOT LEAVE WIDTH ASIS
         MVC   WIDTHS(8),=XL8'0000000400000004'
OKDSN5A  DS    0H                                                  LDW1
         LA    R1,TRCHARE               INITIALIZE PTR TO...
         ST    R1,TRTABADD              TR TABLE (THE EBCDIC ONE)
         LA    R1,LINE06                PT TO FIRST AVAIL SCREEN LOC
         ST    R1,FIRSTSCR              SAVE IT
         LA    R1,LINE19                PT TO LAST AVAIL SCREEN LOC
         ST    R1,MAXSCR                SAVE IT
         XC    LOOKFOR(3*18),LOOKFOR    CLEAR SCAN STRNG SAVE AREA LDW1
         XC    MEMTTR(3),MEMTTR         NO MEMBER YET
         XC    TXTTTR(3),TXTTTR         NO TEXT FOR MEMBER YET      *N*
         XC    ESDTTR(3),ESDTTR         NO ESD PTR YET             LDW1
         MVC   ESDID(2),=H'1'           ESDID DEFAULTS TO 1 FOR IBM
         MVI   CONTINUE,0               NO SCAN, STORES OR SETS YET
         MVI   CPUTFLAG,NOCSERR         CSOUT WILL WORK FOR SURE
         BAL   R8,CLEARDEF              INITIALIZE IDEF TABLE AND PTRS
         MVC   TTR(4),=XL4'00000100'    INITIALIZE TTRN= 00000100
         TITLE 'ZAP --- OPEN AND INITIALIZE I/O FILE'
         CLI   ALLOCDSN,C' '            ALLOC DSN GIVEN?           LDW3
         BE    GO$ALLOC                 NO - GO DO IT              LDW1
         MVC   LINE07(44),DSNAME        SAVE MOMENTARILY           LDW1
         MVC   DSNAME,ALLOCDSN          CHANGE DSN'S               LDW1
*
*  ALLOC THE FILE AND OPEN IT, UPDAT RIGHT OFF THE BAT
*  *** OPEN IT FOR INPUT ***                                       LDW1
         SPACE 1
GO$ALLOC ALLOC DSN=DSNAMEL,VOL=VOLSER,DISP=(SHR,KEEP,KEEP),        *WDD$
               PERM=NO,PASSWD=PASSWORD                             LDW1
         SPACE 1
         BXH   R15,R15,BADDSN
         CLI   ALLOCDSN,C' '            WAS THIS ALLOCDSN?         LDW1
         BE    *+10                     NO - OK                    LDW1
         MVC   DSNAME,LINE07            RESTORE DSN                LDW1
         SPACE 1
NO$ALLOC DS    0H                                                  LDW1
         EJECT
         LA    R0,DCBU                  POINT TO DCB
         ST    R0,DCBLIST               PUT IN OPEN/CLOSE LIST
         MVI   DCBLIST,X'80'            INPUT                      LDW1
         MVC   DCBDDNAM-IHADCB+DCBU(8),DA08DDN-DAPB08+DAPBAREA  DDNAME
         LA    R0,EXLST                 SET UP FOR RDJFCB          LDW1
         ST    R0,DCBEXLST-1+DCBU-IHADCB  SET IN DCB               LDW1
         SPACE 1
         RDJFCB  MF=(E,DCBLIST)         GET THE JFCB               LDW1
         SPACE 1
         L     R1,EXLST                 -> JFCB                    LDW1
         MVC   0(44,R1),DSNAME          MAYBE CHANGE THE DSN       LDW3
         SPACE 1                                                   LDW3
OPEN$IT  OPEN  MF=(E,DCBLIST),TYPE=J    OPEN THE DATASET           LDW1
         SPACE 1
         TM    DCBU+48,X'10'            DID IT OPEN?
         BNO   BADDSN                   NO DARN
         SPACE 2
*
*  GET VOLSER
*
         L     R3,DCBDEBAD-IHADCB+DCBU  GET THE DEB PTR
         L     R3,DEBUCBAD-DEBDS(R3)    GET THE UCB PTR
         MVC   VOLSER(6),SRTEVOLI-UCB(R3)  SAVE VOL=SER OF DATASET
         CLI   DSNAME,X'04'             VTOC?                      LDW1
         BNE   OKVOLSER                 NO - OK                    LDW1
         CLI   DISPDSN+9,C' '           HAVE THE VOL ALREADY?      LDW1
         BNE   OKVOLSER                 YES - SKIP                 LDW1
         MVC   DISPDSN+9(6),VOLSER      NO - FILL IT IN            LDW1
         EJECT
*
*  FIND THE LAST TTR FROM THE FORMAT 1 DSCB OF THE DATASET, OBTAINED,
*  CLEVERLY ENOUGH, BY AN 'OBTAIN' (ASSUMING IT'S NOT A VTOC)
*
OKVOLSER XC    ENDTTR,ENDTTR            SAY NO LAST TTR FOR DEFAULT
         XC    DSCB(256),DSCB           CLEAR OUT DEFAULT DSCB
         MVI   DSORG,0                  SAY NOT PARTITIONED FOR NOW
*LDW1    CLI   DSNAME,X'04'             VTOC HERE?
*LDW1    BE    NOLAST                   YES - DS1LSTAR DOESN'T EXIST
*DSCBLIST CAMLST SEARCH,DSNAME,VOLSER,DSCB                         LDW1
         MVC   DSCBLIST(4),=AL1(193,0,0,0) MOVE IN OPTIONS
         LA    R14,DSNAME               DSNAME FOR OBTAIN
         LA    R15,VOLSER               PT TO VOLSER
         LA    R0,DSCB+44               DSCB BUFFER                LDW1
         STM   R14,R0,DSCBLIST+4        STORE ALL 3 POINTERS
         OBTAIN DSCBLIST                GET THE FMT1 DSCB
         BXLE  R15,R15,GETLTTR1         IF OK USE INFO
         AIF   (&MVS).MVS03                                        LDW1
         CH    R15,=H'16'               RC = 8?                    LDW1
         BE    GOTVTOC                  YES - GO SAVE INFO         LDW1
.MVS03   SPACE 2
*LDW1    TPUTX 'OBTAIN FAILED'
*LDW1    B     END
OBTFAIL  LA    R1,=CL40'OBTAIN FAILED'  POINT TO MSG               LDW1
         B     CSIO#                    LEAVE                      LDW1
         SPACE 3
GOTVTOC  MVC   DS1BLKL,=H'96'           SET BLKSIZE OF VTOC        LDW1
         MVI   DS1KEYL,44               SET KEYLEN OF VTOC         LDW1
         MVI   DSORG,0                  NO DSORG                   LDW1
         MVC   LASTFMT1(5),DSCB+45      SAVE PTR TO LAST FMT1 USED LDW4
         B     NOLAST                   CONTINUE                   LDW1
         SPACE 3
GETLTTR1 DS    0H                                                  LDW1
         AIF   (&MVT).MVT01                                        LDW1
         CLI   DSNAME,X'04'             VTOC?                      LDW1
         BE    GOTVTOC                  YES - GET INFO             LDW1
.MVT01   MVC   DSORG(1),DS1DSORG        SAVE DSORG FOR M           LDW1
         MVC   ENDTTR,DS1LSTAR          SAVE IT                    LDW4
         CLI   DS1NOEPV,0               ANY EXTENTS?              *LPR*
         BE    BADDSN                   NO - CAN'T ACCESS         *LPR*
         SPACE 1
*
*  BUY BUFFER                           (THIS CODE MOVED HERE BY LDW)
*
NOLAST   LH    R0,DS1BLKL               PICK IT UP                 LDW1
         LTR   R0,R0                    ZERO BLKSIZE (LIKE JOBQ)?
         BP    *+8                      NO - GO ON
         LH    R0,=AL2(20*1024)         USE 20K FOR DEFAULT IN CASE
         CH    R0,=H'264'               BELOW MIN (ESP PDS DIRECTORY)
         BNL   *+8                      NO, LEAVE BLKSIZE AS IS
         LH    R0,=H'264'               YES, SET MIN=PDS DIRECTORY SIZE
         MVI   KEYLEN,0                 CLEAR FOR COPY             LDW1
         MVC   KEYLEN+1(1),DS1KEYL      COPY KEYLEN                LDW1
         AH    R0,KEYLEN                ADD TO BUFFERSIZE
         AH    R0,=Y(8+1)               GET ROOM FOR COUNT         LDW1
*  THE +1 IS SO WILL ALWAYS HAVE RESIDUAL                          LDW1
         LR    R1,R0                    COPY VALUE
         AH    R0,=AL2(LCSOUT)          WORKAREA SIZE
         STH   R1,BUFFSIZE              STORE AWAY FOR LATER USE
         STH   R1,CCW#R#R+6             SET FOR MAX READ           LDW1
         STH   R1,CCW##R0+6             DITTO FOR R0               LDW1
         AH    R0,=Y(50)                SO NO 0C4'S NEAR BUFF. END LDW4
*LDW1    XC    GETLIST(GETLISTL),GETLIST  FIX IT
*LDW1    GETMAIN  EC,LV=(0),A=ADDRWORK,MF=(E,GETLIST)
*LDW1    L     R1,ADDRWORK              GET ADDR OF CORE WE HOPE
*LDW1    BXLE  R15,R15,OKGETCS          IT WORKED
*LDW1    BAL   R8,CLOSE                 NO - CLOSE THE DATASET AND
*LDW1    LA    R1,=CL40'NOT ENOUGH CORE FOR BUFFERS'  POINT TO MSG
*LDW1    B     CSIO#                    ABOUT HIS MISFORTUNE, THEN...
         GETMAIN R,LV=(0)               MAKE IT UNCONDITIONAL      LDW1
         ST    R1,ADDRWORK              SAVE ADDR FOR LATER        LDW1
         SPACE 1
         AH    R1,=AL2(LCSOUT)          ADD WORKAREA SIZ TO PT TO BUFF
         ST    R1,ADDRCNT               SAVE ADDR OF COUNT         LDW1
         STCMX R1,B'0111',CCW#R#R+1,COPY=ADDRCNT+1                 LDW1
         STCMX R1,B'0111',CCW##R0+1,COPY=ADDRCNT+1                 LDW1
         STCMX R1,B'0111',CCW#F#W+1,COPY=ADDRCNT+1                 LDW1
         LA    R1,8(,R1)                -> KEY FIELD               LDW1
         ST    R1,ADDRKEY               SAVE ADDR OF KEY           LDW1
         ST    R1,ADDRBUFF              DEFAULT DISPLAY IS KEY     LDW1
         STCMX R1,B'0111',CCW#W#W+1,COPY=ADDRBUFF+1                LDW1
         STCMX R1,B'0111',CCW#D#R+1,COPY=ADDRBUFF+1                LDW1
         SPACE 2
         TM    FLAGS2,LOGF              ARE WE LOGGING?
         BNO   *+8                      IF NOT SKIP OPEN
         BAL   R8,OPENOUT               IF SO DO THE OPEN
         SPACE 2
*  GET FREE DEFINE TABLE SYMBOLS FOR 'LRECL', 'KEYLEN', AND 'BLKSIZE'
         SPACE 1
         L     R3,AIDEFTAB              PT TO DEFINE TABLE
         MVI   0(R3),C'L'               GIVE SYMBOL 'L' FOR 'LRECL'
         MVC   8(2,R3),DS1LRECL         GET LRECL, PUT IN TAB
         MVC   10(2,R3),=C'BL'          GIVE 'BL' FOR BLKSIZE (MAX)
         MVC   18(2,R3),DS1BLKL         GET BLKSIZE, PUT IN TAB    LDW1
         MVI   20(R3),C'K'              GIVE 'K' FOR 'KEYLEN' SYMBOL
         MVC   28(2,R3),KEYLEN          GET KEYLEN AND PUT IN TABLE
         LA    R3,30(,R3)               UPDATE DEFINE TABLE PTR
         ST    R3,IDEFAVAL              SAVE IT AS PTR TO CURR ENTRY
         MVC   REP,BLANKS               CLEAR REPLY OUT            LDW1
         MVC   LINE19,BLANKS            CLEAR ERR MSG PART OF SCRN LDW1
         AIF   (&MVS).MVS04                                        LDW1
         MVI   JQFLAG,0                 NO MASTER QCR YET         *LPR*
.MVS04   XC    BASEVAL,BASEVAL          BASE = 0                   LDW1
         SPACE 1
         TM    FLAGS3,F3270             3270 MODE?                 LDW5
         BNO   NO$STFS                  NO - SKIP                  LDW1
         SPACE 1
         AIF   (&MVT).MVT02                                        LDW5
         STFSMODE  ON,INITIAL=YES       START IT UP                LDW1
         SPACE 1
.MVT02   OI    FLAGS3,FSMODE            IT'S ON, NOW               LDW5
         B     NEW$READ                 DON'T TPUT VERSION LINE    LDW5
         SPACE 2
NO$STFS  MVC   LINEBUFF(40),BLANKS      INIT                       LDW5
         MVC   LINEBUFF(L'VERSION),VERSION                         LDW1
         BAL   R14,PUTLINE$             SAY WHAT VERSION           LDW1
         TITLE 'ZAP --- CREATE THE SCREEN DISPLAY AND GET COMMAND'
*  HERE IF A NEW BLOCK IS TO BE READ AND THE SCREEN IS TO BE BUILT
*  FROM IT
         SPACE 1                                                   LDW1
NEW$READ XC    NOWSTUFF(NOWLEN-L'BASEVAL),NOWSTUFF RESET BUFF OFF  LDW1
         BAL   R8,READBLK               GET A BLK FROM DS (BDAM)
         AIF   (&MVS).MVS05                                        LDW1
         TS    JQFLAG                   MASTER QCR SAVED YET?     *LPR*
         BNZ   NEW$DISP                 YES                       *LPR*
         CLC   DSNAME(13),=C'SYS1.SYSJOBQE'  DOING A JOB Q?       *LPR*
         BNE   NEW$DISP                 NO                        *LPR*
         L     R8,ADDRDATA              LOAD DATA ADDRESS          LDW1
         MVC   JQQMHDA(36),0(R8)        SAVE MASTER QCR           *LPR*
.MVS05   B     NEW$DISP                 SKIP AROUND                LDW1
*
*  HERE IF BUILD SCREEN WITHOUT READING A NEW BUFFER IN
*
NEWDSPNT MVI   TRACE,NOTRACE            SET FLAG                   LDW1
         SPACE 1
NEW$DISP BAL   R8,CLEAR                 CLEAR THE SCREEN
         OC    BLKLEN(2),BLKLEN         0 READ BEFORE?
         BZ    DISPLAY                  YES - THERE'S NOTHING TO DISP
         LH    R8,OLDPOINT              GET CARET OFFSET           LDW1
         N     R8,NOWMASK               GET HIGH PART              LDW1
         LR    R5,R8                    COPY                       LDW1
         SH    R8,SCRBYTES              BACK UP TO SCREEN START    LDW1
         BNM   *+6                      CONTINUE IF OK             LDW1
         SR    R8,R8                    SCR START = BLK START      LDW1
         A     R8,ADDRBUFF              GET ADDRESS INTO BUFFER
         A     R5,ADDRBUFF              GET DBLW ADDRESS INTO BUFFER
         L     R15,FIRSTSCR             PT TO FIRST AVAIL SCREEN POS
*
*  FORMAT ONE LINE OF SCREEN DISPLAY
*
FORMAT   LR    R0,R8                    COPY BUFFER PTR            LDW1
         S     R0,ADDRBUFF              OFFSET INTO BUFFER FOR SCR LDW1
         ST    R0,TEMP                  SAVE FOR UNPK              LDW1
         HEX   (0,R15),TEMP+1,LEN=3,DIGITS=5,HEXTAB=TRHEX          LDW1
         MVC   TEMP(16),0(R8)           COPY CHAR FORM OF DATA     LDW1
         UNPK  TEMP2+00(14+1),TEMP+00(7+1)   BYTES 01-07           LDW1
         UNPK  TEMP2+14(14+1),TEMP+07(7+1)   BYTES 08-14           LDW1
         UNPK  TEMP2+28(04+1),TEMP+14(2+1)   BYTES 15-16           LDW1
         TR    TEMP2(32),TRHEX          MAKE EBCDIC                LDW1
         L     R1,TRTABADD              GET RIGHT TRTAB PTR        LDW4
         TR    TEMP(16),0(R1)           MAKE IT VALID CHARS        LDW4
         LR    R1,R0                    COPY BLK OFFSET            LDW1
         AH    R1,LINEHEX               GET NEXT OFFSET            LDW1
         SH    R1,BLKLEN                COMPUTE AMOUNT SHORT       LDW1
         BNP   FORMATOK                 SKIP IF THIS LINE FULL     LDW1
         LA    R14,TEMP2                -> AREA                    LDW1
         AH    R14,LINEHEX2             -> PAST END                LDW1
         LA    R2,0(R1,R1)              GET LENGTH OF HEX GARBAGE  LDW1
         SR    R14,R2                   -> GARBAGE HEX             LDW1
FMTBLANK MVC   0(0,R14),BLANKS          << EXECUTED >>             LDW1
         EX    R2,*-6                   BLANK THE GARBAGE HEX      LDW1
*  NOTE THAT TEMP2 IS LONG ENOUGH THAT BLANKING 1 CHAR TOO MANY    LDW1
*  DOESN'T HURT ANYTHING                                           LDW1
         LA    R14,TEMP                 -> CHARS                   LDW1
         AH    R14,LINEHEX              -> PAST END                LDW1
         SR    R14,R1                   -> GARBAGE CHARS           LDW1
         BCTR  R1,0                     -1 FOR EX                  LDW1
         EX    R1,FMTBLANK              CHARS ALSO GET TREATMENT   LDW1
         SPACE 2
*ORMATOK MVC   08(4,R15),TEMP2+00       MOVE HEX TO SCREEN         LDW1
*        MVC   13(4,R15),TEMP2+04                                  LDW1
*        MVC   19(4,R15),TEMP2+08                                  LDW1
*        MVC   24(4,R15),TEMP2+12                                  LDW1
*        MVC   31(4,R15),TEMP2+16                                  LDW1
*        MVC   36(4,R15),TEMP2+20                                  LDW1
*        MVC   42(4,R15),TEMP2+24                                  LDW1
*        MVC   47(4,R15),TEMP2+28                                  LDW1
*        MVI   54(R15),C'|'             PUT IN DELIM               LDW1
*        MVC   55(16,R15),TEMP          MOVE CHARS                 LDW1
*        MVI   71(R15),C'|'             ENDING DELIM               LDW1
FORMATOK MVC   TEMP2+32(2),=C' |'       MOVE IN CONSTANTS FOR TR   LDW1
         CLI   LINELEN+1,40             WHICH ONE?                 LDW1
         BE    FORMAT40                 SHORT                      LDW1
         MVC   7(65,R15),DISPTR80       MOVE IN "TRANSLATE" TABLE  LDW1
         TR    7(65,R15),TEMP           DISTRIBUTE HEX TO SCREEN   LDW1
         B     FORMATXX                 CONTINUE                   LDW1
FORMAT40 MVC   7(32,R15),DISPTR40       MOVE IN SHORT TABLE        LDW1
         TR    7(32,R15),TEMP           DISTRIBUTE HEX TO SCREEN   LDW1
         SPACE 1
FORMATXX CR    R8,R5                    BUFF PTR = DATA PTR?       LDW1
         BNE   NO$CARET                 NO - SKIP CARET            LDW1
         LR    R1,R15                   COPY LINE ADDR             LDW1
         BCTR  R1,0                     BACK UP TO ATTR BYTE       LDW1
         MVI   0(R1),X'E8'              HIGH INTENSITY PROTECTED   LDW1
         LH    R1,OLDPOINT              GET CARET OFFSET           LDW1
         N     R1,BITMASK               GET LOW ORDER PART         LDW1
         LA    R3,BYTES(R1)             PT TO COLUMN OF SCRN       LDW1
         IC    R1,0(,R3)                GET SCREEN COL FOR CARET   LDW1
         LA    R14,0(R15,R1)            PT TO WHERE IT GOES        LDW1
         MVI   0(R14),C'>'              ASSUME EVEN                LDW1
         TM    OLDPOINT+1,1             IS IT?                     LDW1
         BNO   *+8                      YES - SKIP                 LDW1
         MVI   0(R14),C'<'              ODD POINTS THE OTHER WAY   LDW1
         ST    R14,MIDLINE              SAVE PTR TO CARET LINE     LDW1
         SPACE 1
NO$CARET AH    R8,LINEHEX               UPDATE BUFFER PTR          LDW1
         LA    R15,$I(,R15)             UPDATE SCREEN PTR          LDW1
         AH    R0,LINEHEX               NEXT OFFSET                LDW1
         CH    R0,BLKLEN                PAST END OF BLOCK?         LDW1
         BNL   DISPLAY                  YES - GO DISPLAY           LDW1
         C     R15,MAXSCR               OUT OF SCREEN?             LDW1
         BL    FORMAT                   NO - DO ANOTHER LINE       LDW1
         B     DISPLAY                  SKIP (WE WILL TRACE)       LDW1
         EJECT
DISPLYNT MVI   TRACE,NOTRACE            SET NOTRACE FLAG           LDW1
         SPACE 2
DISPLAY  MVI   TTR+3,NOSEQRD            TURN OFF SEQ READ          LDW5
         MVI   EOFRET,YESEOF            SAY EOF'S WILL BE RECOGNIZED
         TM    FLAGS3,F3270             FULLSCREEN?                LDW5
         BNO   *+12                     NO - SKIP                  LDW3
         NI    FLAGS2,255-NOWHEREF      YES - DON'T SUPPRESS WHERE LDW1
         NI    FLAGS3,255-NODISPF       ... OR REDISPLAY           SDM6
         TM    FLAGS3,NODISPF           SUPPRESS REDISPLAY?        SDM6
         BO    NOTWHERE                 YES, GO DIRECT TO OUTPUT   SDM6
         TM    FLAGS2,NOWHEREF+TERSEF   SEE IF WHERE SUPPRESSED
         BNZ   NOTWHERE                 IF ON SUPPRESS IT
     MVC LINE03(40),=CL40'ENTER VALID COMMAND ABOVE OR ? FOR HELP' LDW1
         MVC   LINE03+72-L'VERSION(L'VERSION),VERSION              LDW1
         MVC   LINE03+61(7),ZAP+10      PUT IN THE ASM DATE        LDW1
         SPACE 1
WHEREAMI CLI   LINELEN+1,80             LONG LINES?                LDW1
         BE    WHERE80                  YES - FORMAT MORE INFO     LDW1
         MVC  LINE21+17(34),=C'TTR: XXXXXX CCHHR: XXXXXXXXXX LEN:' LDW1
         HEX   LINE21+36,CCHHR,LEN=5                               LDW1
         HEX   LINE21+22,TTR,LEN=3                                 LDW1
         MVC   LINE20+17(4),=C'DSN:'    MOVE IN MASK               LDW1
         MVC   LINE20+22(24),DISPDSN    SHOW THE DSNAME            LDW1
         MVC   LINE20+47(4),=C'OFF:'    MOVE IN MASK               LDW1
         HEX   LINE20+53,OLDPOINT,LEN=2 OFFSET                     LDW1
         MVC   LINE21+52(5),EDMASK+3    GET READY TO EDIT IN BLKLN LDW1
         LH    R1,BLKLEN                GET THE LENGTH READ        LDW1
         CVD   R1,TEMP                  CONV TO DECIMAL            LDW1
         ED    LINE21+51(6),TEMP+5      EDIT IT TO SCREEN          LDW1
         B     NOTWHERE                 CONTINUE                   LDW1
         SPACE 2
WHERE80  MVC   LINE20+00(4),=C'OFF:'                               LDW1
         LH    R15,OLDPOINT             GET OFFSET IN BUFFER       LDW1
         BAL   R14,NUMCONV              CONVERT IT                 LDW1
         MVC   LINE20+05(4),TEMP2+12+4  MOVE IN HEX PART           LDW1
         MVI   LINE20+10,C'('                                      LDW1
         MVC   LINE20+11(6),TEMP2+6     DECIMAL PART               LDW1
         MVC   LINE20+17(7),=C') ADDR:'                            LDW1
         L     R15,OFFSET               GET IT                     LDW1
         BAL   R14,NUMCONV              CONVERT                    LDW1
         MVC   LINE20+25(5),TEMP2+12+3  HEX PART                   LDW1
         MVI   LINE20+31,C'('                                      LDW1
         MVC   LINE20+32(8),TEMP2+4     DECIMAL PART               LDW1
         MVC   LINE20+40(6),=C') DSN:'                             LDW1
         MVC   LINE20+47($L-47),DISPDSN DSN                        LDW1
         SPACE 1
         MVC   LINE21+00(4),=C'LEN:'                               LDW1
         LH    R15,BLKLEN               GET LENGTH OF BLOCK        LDW1
         BAL   R14,NUMCONV              CONVERT                    LDW1
         MVC   LINE21+05(4),TEMP2+12+4  HEX PART                   LDW1
         MVI   LINE21+10,C'('                                      LDW1
         MVC   LINE21+11(6),TEMP2+6     DECIMAL PART               LDW1
         MVC   LINE21+17(7),=C') BASE:'                            LDW1
         L     R15,BASEVAL              BASE                       LDW1
         BAL   R14,NUMCONV              CONVERT                    LDW1
         MVC   LINE21+25(5),TEMP2+12+3  HEX PART                   LDW1
         MVI   LINE21+31,C'('                                      LDW1
         MVC   LINE21+32(8),TEMP2+4     DECIMAL PART               LDW1
         MVC   LINE21+40(8),=C') CCHHR:'                           LDW1
         UNPK  LINE21+49(10+1),CCHHR(5+1)                          LDW1
         TR    LINE21+49(10),TRHEX      MAKE IT EBCDIC             LDW1
         MVC   LINE21+59(5),=C' TTR:'                              LDW1
         HEX   LINE21+66,TTR,LEN=3                                 LDW1
         SPACE 1                                                   LDW1
NOTWHERE NI    FLAGS2,255-NOWHEREF      ENABLE WHERE LINE          LDW1
         BAL   R8,CSIO                  DISPLAY SCREEN JUST MADE   SDM6
         TITLE 'ZAP --- COMMAND CHECKING AND EXECUTION'
*
*  FIND REPLY LENGTH AND COPY IT TO TEMP2
*
COMSCAN  OC    REP,BLANKS               MAKE IT UPPER CASE         LDW1
         LH    R1,READLEN               GET READ LENGTH            SDM6
         LA    R1,REP(R1)               POINT TO LAST CHAR + 1     SDM6
COMGET   BCTR  R1,0                     DECREMENT POINTER          SDM6
         CLI   0(R1),C' '               END OF STRING?             SDM6
         BE    COMGET                   NO, GO TEST ANOTHER CHAR   SDM6
         SPACE 1
         LA    R0,REP-1                 GET LENGTH...              SDM6
         SR    R1,R0                    ... OF DATA                SDM6
         BNP   NEWDSPNT                 ZERO, IGNORE WITH NO TRACE SDM6
         STH   R1,REALRDLN              PHONY UP THE ACTUAL READ LEN
         MVC   TEMP2(40),REP            COPY START OF COMMAND      LDW1
*    (SOME ROUTINES MODIFY THE COMMAND IN TEMP2)                   LDW1
         SPACE 5
*  SEE IF THE COMMAND IS IN THE COMMAND TABLE
         SPACE 2
         LR    R0,R1                    GET THE TRUE READ LENGTH   LDW1
         SR    R1,R1                    CLEAR REG FOR IC'S
         L     R2,=A(COMTAB)            PT TO COMMAND TABLE        LDW1
         BAL   R14,*+8                  SET LOOP ADDR & SKIP       LDW1
         SPACE 1
         LA    R2,12(,R2)               -> NEXT TABLE ENTRY        LDW1
         CLI   0(R2),X'FF'              END OF TABLE
         BE    EXPR                     YES - NOT IN TAB, AN EXPRESS?
         IC    R1,0(,R2)                NO - PICK UP LEN OF COMMAND
         EX    R1,COMCLC                COMMAND MATCH?
         BNER  R14                      NO - CHECK NEXT            LDW1
         L     R2,8(,R2)                PICK UP ROUTINE ADDR
         BCTR  R0,0                     COMPUTE LENGTH OF ...      LDW1
         SR    R0,R1                    ... REMAINING INPUT        LDW1
         LA    R1,TEMP2+1(R1)           -> START OF OPERANDS       LDW1
         BR    R2                       GO DO IT
*  NOTE:  CC IS SET FOR OPERAND LENGTH = 0 OR Â¬=0                  LDW1
COMCLC   CLC   REP(0),1(R2)             << EXECUTED >>             LDW1
         TITLE 'ZAP --- COMMAND EXECUTION --- EXPRESSION'
*
*****  NO COMMAND (EXPRESSION)  *****
*
EXPR     LA    R1,REP                   GET EXPRESSION PTR         LDW1
         LH    R0,REALRDLN              GET EXPRESSION LEN
         SPACE 2
PARSE    L     R15,OFFSET               GET '*' (CURRENT VALUE)    LDW1
         MVI   EXPOPT,YESSYMB           SAY 'LOOK AT THE SYMBOL TABLE'
         BAL   R8,CALLEXP               GO PARSE                   LDW1
         S     R15,BASEVAL              GET OFFSET IN BUFFER       LDW1
         BNM   SETPOINT                 IT'S NON-NEG, SO WE'RE OK  LDW1
         SPACE 2
SETPNT00 XR    R15,R15                  CAN'T HAVE NEGATIVE
         CLC   ADDRBUFF,ADDRCNT         DISPLAYING COUNT FIELD?    LDW1
         BNE   SETPOINT                 NO - OK                    LDW1
         LA    R15,8                    YES - PUT CARET AT KEY     LDW1
         SPACE 1
SETPOINT LH    R2,BLKLEN                GET BLKLENGTH              LDW1
         BCTR  R2,0                     -1 FOR COMPARE
         CR    R15,R2                   ARE WE STILL WITHIN THE BLK?
         BNH   *+6                      YES - WE'RE OK
         LR    R15,R2                   NO - MAKE IT THE END OF BLK
         STH   R15,OLDPOINT             SAVE OFFSET FOR CURR LOC
         A     R15,BASEVAL              RELOCATE IT                LDW1
         ST    R15,OFFSET               SAVE ADDR                  LDW1
         B     NEW$DISP                 GO DO IT
         SPACE 2
INVEXPER LA    R2,INVEXP                YES - SAY INVALID SYNTAX
*  NOTE:  R1 WILL PT TO THE COLUMN OF THE ERROR
         B     BOTCH                    AND GO TELL HIM WITH NO TRACE
         SPACE 6                        SPLIT HERE
         TITLE 'ZAP --- COMMAND EXECUTION --- HELP, ?'
*
*****  HELP (?, ?1, ?2, ?3, ?4, ?5, ?6, ?7, HELP, H, H1,...,H7)    LDW1
*
HELPHELP TM    FLAGS3,F3270             FULLSCREEN?                LDW5
         BZ    HELPALL                  NO - DO IT OLD WAY         LDW3
         SR    R3,R3                    HE WANTS HELP #1 ("HELP")  LDW2
         B     HELPOK                   AND PROCESS                LDW1
         SPACE 2
HELP     BNP   HELPHELP                 JUST "?" - GIVE HIM "?1"   LDW1
         TM    FLAGS3,F3270             FULLSCREEN?                LDW5
         BZ    HELPALL                  NO - DO IT OLD WAY         LDW3
         XR    R15,R15                  * = 0                      LDW1
         BAL   R8,CALLEXP               PARSE OPERAND              LDW1
         LTR   R3,R15                   GET THE ANSWER             LDW2
         BNP   INVEXPER                 NO GOOD                    LDW1
         BCTR  R3,0                     -1 FOR OFFSET              LDW2
         CH    R3,=H'15'                GREATER THAN 9?            LDW2
         BL    *+8                      NO - SKIP                  LDW1
         SH    R3,=H'6'                 EXP THOUGHT IT WAS HEX     LDW1
         SPACE 2
HELPOK   LA    R2,1+C'1'(,R3)           GET NEXT PROMPT            LDW1
         BAL   R8,CLEAR                 CLEAR THE SCREEN FIRST     LDW1
         CH    R3,=Y(13-1)              TOO BIG?                   LDW1
         BH    INVEXPER                 YES, BYE BYE               LDW1
         BL    *+8                      NO, USE IT, WE HAVE PROMPT LDW1
         LA    R2,C'1'                  AT END, WRAP TO BEGIN      LDW1
         LR    R1,R3                    COPY # TO BETTER REG       LDW1
         OI    REP-1,X'01'              SET THE MDT FLAG           SDM4
         MVC   REP,BLANKS               BLANK THE PROMPT           SDM4
         MVI   REP,C'?'                 SET UP PROMPT              LDW1
         STC   R2,REP+1                 DO IT                      LDW1
         CLI   REP+1,X'FA'              TOO BIG?                   LDW1
         BL    *+16   >============+    NO - OK                    LDW1
         MVI   REP+1,C'1'          |    SET FIRST DIGIT            LDW1
         SH    R2,=H'10'           |    FIX OTHER DIGIT            LDW1
         STC   R2,REP+2            |    SET IT                     LDW1
         L     R2,=V(ZAPHELP)  <===+    POINT TO STUFF             LDW1
         MH    R1,=H'520'               * LENGTH OF EACH           LDW1
         A     R1,4(,R2)                POINT TO IMAGE             LDW1
         LA    R2,LINE06                FIRST SCREEN LINE FOR HELP LDW1
         LA    R14,$I                   BXLE INCR                  LDW1
         LA    R15,LINE18+20            LAST SCREEN LINE FOR HELP  LDW1
         LA    R0,40                    INCR FOR HELP              LDW1
         CLI   LINELEN+1,80             LONG LINES?                LDW1
         BNE   *+8                      NO - SKIP                  LDW1
         LA    R2,LINE06+17             YES - CENTER IT            LDW1
         SPACE 1
         MVC   0(40,R2),0(R1)           MOVE 1 LINE                LDW1
         AR    R1,R0                    INCR SOURCE PTR            LDW1
         BXLE  R2,R14,*-8               MOVE 520 BYTES             LDW1
         B     DISPLYNT                 GIVE HIM SCR (NOTRACE)     LDW1
         SPACE 6
*
*****  HELP (NON FULLSCREEN TERMINALS)  *****
*
HELPALL  OI    FLAGS3,NODISPF           DON'T REDISPLAY AT END     SDM5
         L     R2,=V(ZAPHELP)           POINT TO HELP              SDM6
         L     R3,0(,R2)                GET NUMBER OF LINES TO TPUT
         LA    R8,8(,R2)                -> INDICATOR BYTES         LDW1
         L     R2,4(,R2)                -> FIRST LINE              LDW1
         SPACE 1
HELPLOOP CLI   0(R8),0                  DUMP THIS LINE?            LDW1
         BE    HELPSKIP                 NO - SKIP IT               LDW1
         MVC   LINEBUFF(40),0(R2)       MOVE TO TEMP BUFFER        LDW1
         BAL   R14,PUTLINE$             PRINT IT                   LDW1
         TM    FLAGS2,ATTNHIT           SEE IF USER INTERRUPTED IT LDW5
         BO    HELPINT                  I DON'T BLAME HIM
HELPSKIP LA    R2,40(,R2)               POINT TO NEXT LINE         LDW1
         LA    R8,1(,R8)                NEXT INDICATOR BYTE        LDW1
         BCT   R3,HELPLOOP              GIVE HIM NEXT LINE
         B     DISPLYNT                 GO BACK TO USER            SDM6
HELPINT  NI    FLAGS2,255-ATTNHIT       TURN OFF INTERRUPT         LDW5
         B     DISPLYNT                 GO BACK TO USER            SDM6
   TITLE 'ZAP --- COMMAND EXECUTION --- LOG, CRT, TERSE, VERBOSE, DISP'
*
***** LOG
*
LOG      BAL   R8,LOGTEST               OPEN THE DS IF NOT OPEN    LDW1
         LA    R2,LOGONMSG              POINT TO MSG               LDW1
         B     BOTCH                    DISPLAY MSG                LDW1
         SPACE 2
*
***** CRT
*
CRT      OI    FLAGS3,CRTF              SET FLAG                   LDW5
         MVC   WIDTHS(8),=XL8'0000000400000004' SET WIDTH
         NI    FLAGS2,255-TERSEF        SET VERBOSE MODE
         OI    FLAGS3,NODISPF           DON'T REDISPLAY            SDM6
         B     DISPLYNT                 GO BACK TO USER, NO TRACE  SDM6
         SPACE 2
*
***** TERSE/VERBOSE
*
TERSE    OI    FLAGS2,TERSEF            SUPPRESS WHERE
         OI    FLAGS3,NODISPF           DON'T REDISPLAY            SDM6
         B     DISPLYNT                 GO BACK TO USER, NO TRACE  SDM6
         SPACE 1
VERBOSE  NI    FLAGS2,255-TERSEF        ALLOW WHERE
         OI    FLAGS3,NODISPF           DON'T REDISPLAY            SDM6
         B     DISPLYNT                 GO BACK TO USER, NO TRACE  SDM6
         SPACE 3
*
*****  DISP  *****
*
DISPC    MVC   ADDRBUFF,ADDRCNT         -> COUNT                   LDW1
         LH    R14,CCW#W#W+6            GET KL+DL                  LDW1
         LA    R14,8(,R14)              INCLUDE LEN OF COUNT       LDW1
         STH   R14,BLKLEN               SET DISPLAY BLOCK LENGTH   LDW1
         LA    R15,8                    DISPLAY OFFSET             LDW1
         B     SETPOINT                 RE-DISPLAY NEAR TOP        LDW1
         SPACE 1
DISPK    MVC   ADDRBUFF,ADDRKEY         -> KEY                     LDW1
         MVC   BLKLEN,CCW#W#W+6         SET DISPLAY BLOCK LENGTH   LDW1
         B     SETPNT00                 RE-DISPLAY AT TOP          LDW1
         SPACE 1
DISPD    MVC   ADDRBUFF,ADDRDATA        -> DATA                    LDW1
         LH    R14,CCW#W#W+6            GET KL+DL                  LDW1
         SH    R14,KEYLEN               DON'T DISPLAY KEY          LDW1
         STH   R14,BLKLEN               SET DISPLAY BLOCK LENGTH   LDW1
         B     SETPNT00                 RE-DISPLAY AT TOP          LDW1
         TITLE 'ZAP --- COMMAND EXECUTION --- END'                 LDW3
*
*****  END  *****
*
         SPACE 2
ENDPFK   MVC   REP,BLANKS
         MVC   REP(3),=C'END'
END      BAL   R8,CHKPT                 CHECK TO SEE IF ZAP REQ
         BAL   R8,KILL3270              TURN OFF 3270 MODE         LDW3
         BAL   R8,CLOSE                 CLOSE THE FILE IF ANY
         TM    FLAGS2,LOGF              SEE IF LOGGING
         BNO   EXITOUT                  IF NOT NO CLOSE
         L     R1,CSOUTWK               GET WORKAREA
         LTR   R1,R1                    IF ANY
         BZ    EXITOUT                  NONE, CAN'T BE OPEN THEN
         CLI   ENQIT,0                  WAS ANYTHING IMPORTANT SAID?
         BNE   EXITENQ                  YES, DO IT
EXITSCR  TPUTX 'ZAP LOG DELETED'                                   MAS3
         L     R1,CSOUTWK               @ CSOUT WORK AREA          MAS3
*LDW1    CSOUT SCR,MF=(E,(1)),CALL=CALL DELETE FILE
         MVI   0(R1),X'02'          (+) INDICATE SCRATCH
         LR    R2,R1                (+) COPY WORKAREA PTR
         L     R15,=V(CSOUT)        (+) POINT TO ROUTINE
         LR    R1,CSREG             (+) GET CSAREA PTR
         BALR  R14,R15              (+) CALL IT
         B     EXITOUT                  THEN LEAVE
         SPACE 1
EXITENQ  LA    R1,N5                    POINT TO DIGIT
         BAL   R8,SETLINE               SET UP A LINE
         B     EXITOUT                  NOT PRINTING?
         MVC   20(33,R2),=C'FILE CLOSED - PROCESSING COMPLETE'
         MVI   0(R2),C'-'               TRIPLE SPACE IT
         BAL   R8,CPUT                  DUMP IT
         SPACE 1
         TPUTX 'ZAP LOG REQUIRED? (YES,NO)',ASIS                   MAS3
         LM    R0,R1,REGS3270     SCREENL, @ SCREEN                MAS3
         LA    R1,0(,R1)          CLEAR TPUT FULSCR FLAG           MAS3
         O     R1,=X'80000000'    MAKE IT TGET                     MAS3
         TPUT  (1),(0),R          GET USER RESPONSE                MAS3
         LTR   R15,R15            CHECK RC FROM TGET               MAS3
         BNZ   EXITENQ1           GO ENQ IF ERROR ON INPUT         MAS3
         CH    R1,=H'2'           EXACTLY 2 CHARS OF INPUT?        MAS3
         BNE   EXITENQ1           BIF NOT 2 CHARS OF INPUT         MAS3
         OC    SCREEN(2),BLANKS   MAP TO UPPER CASE                MAS3
         CLC   SCREEN(2),=CL2'NO' EXACTLY 'NO'?                    MAS3
         BE    EXITSCR                                             MAS3
EXITENQ1 L     R1,CSOUTWK               RELOAD WORKAREA PTR
*LDW1    LA    R14,HISBIN
*LDW1    CSOUT ENQ,(14),=H'1',CALL=CALL,MF=(E,(1))
         MVI   0(R1),X'40'          (+) FLAG AS ENQUEUE CALL
*LDW1    ST    R14,4(,R1)           (+) STORE FIRST PARM
*LDW1    LA    R0,=H'1'             (+)
*LDW1    ST    R0,8(,R1)            (+) STORE SECOND PARM
         LR    R2,R1                (+) COPY WORKAREA PTR
         L     R15,=V(CSOUT)        (+) POINT TO ROUTINE
         LR    R1,CSREG             (+) GET CSAREA PTR
         BALR  R14,R15              (+) CALL IT
         SPACE 1
EXITOUT  L     R13,4(,R13)              RESTORE THE REG STUPID
         LM    R14,R12,12(R13)          RESTORE
         XR    R15,R15                  RC=0
         BR    R14                      BYE BYE
 TITLE 'ZAP --- COMMAND EXECUTION --- EBCDIC, ASCII, ZCODE, //DEBUG' LW
*
*****  EBCDIC  *****
*
EBCDIC   LA    R1,TRCHARE               PICK UP PTR TO EBCDIC TRTAB
         LA    R2,EBCDCMSG              TELL HIM WHAT JUST HAPPENED
EBCDIC#  ST    R1,TRTABADD              SAVE FOR LATER DISPLAYS
         OI    FLAGS2,NOWHEREF          SUPRESS WHERE
         B     BOTCH                    GO DO IT AND DISPLAY
         SPACE 6                                                   LDW1
*
*****  ASCII  *****
*
ASCII    LA    R1,TRCHARA               PICK UP PTR TO ASCII TRTAB
         LA    R2,ASCIIMSG              TELL HIM WHAT JUST HAPPENED
         B     EBCDIC#                  GO FINISH THE JOB
         SPACE 6                                                   LDW1
*
*****  ZCODE  *****
*
ZCODE    LA    R1,TRCHARZ               PICK UP PTR TO ZCODE TRTAB
         LA    R2,ZCODEMSG              SAY WHAT TYPE OF TRANS
         B     EBCDIC#                  AND DO IT FROM NOW ON
         SPACE 6
*
*****  //DEBUG  *****
*
DIEFAST  BAL   R8,KILL3270              TURN OFF 3270 MODE         LDW1
         DC    X'00C1'                  "HALT..."                  LDW1
         LA    R2,OUCH                  PT TO MSG                  LDW1
         B     BOTCH                    RESUME IF "GO" FROM TEST   LDW1
         TITLE 'ZAP --- COMMAND EXECUTION --- #, LAST, LASTDS1'    LDW1
*
*****  # (CALC)  *****
*
CALC     L     R15,OFFSET               GET '*' = CURRENT OFFSET   LDW1
         MVI   EXPOPT,YESSYMB           TELL HIM SCAN SYMB TAB
         BAL   R8,CALLEXP               PARSE & CHECK              LDW1
         MVC   LINE19+17(20),=CL20'CALCULATE VALUE:'    MOVE IN MASK
         BAL   R14,NUMCONV              CONVERT                    LDW1
         MVC   LINE19+34(12),TEMP2      DECIMAL PART               LDW1
         MVC   LINE19+48(8),TEMP2+12    HEX PART                   LDW1
         B     NEWDSPNT                 GIVE IT TO HIM
         SPACE 6
*
*****  LAST  *****
*
LAST     BAL   R8,CHKPT                 CHECK TO SEE IF ZAP REQ
         CLI   DSNAME,X'04'             IS THERE A LAST TTR (NOT VTOC)?
         LA    R2,LASTINV               PT TO MESSAGE IN CASE
         BE    BOTCH                    NO - TELL HIM              LDW1
         MVC   TTR(3),ENDTTR            PICK UP LAST TTR           LDW4
         B     NEW$READ                 GO GIVE IT TO HIM
         SPACE 6
*
*****  LASTDS1  *****                                              LDW1
*
LASTDS1  BAL   R8,CHKPT                 CHECK TO SEE IF ZAP REQ    LDW1
         CLI   DSNAME,X'04'             IS THIS THE VTOC?          LDW1
         LA    R2,NOTVTOC               PT TO MESSAGE IN CASE      LDW1
         BNE   BOTCH                    NO - TELL HIM              LDW1
         XC    DBLW,DBLW                CLEAR AREA FOR 'ABS'       LDW1
*  ASSUME VTOC IS 1 EXTENT ==> M=0                                 LDW1
         MVC   DBLW+3(5),LASTFMT1       SET CCHHR OF LAST FMT1     LDW1
         B     ABSGOT1                  GO FAKE AN 'ABS' COMMAND   LDW1
         TITLE 'ZAP --- COMMAND EXECUTION --- D, U'                LDW1
*
*****  D  *****
*
PFKDOWN  MVC   REP,BLANKS                                       .AFDSC.
         MVI   REP,C'D'                                         .AFDSC.
         SR    R0,R0                                            .AFDSC.
DISPLAY# BNZ   PARSE                    MORE THAN A 'D'            LDW1
         BAL   R8,DU$COM                GET # OF BYTES             LDW1
         AR    R15,R14                  WHERE TO POINT TO NOW (OFFSET)
         CH    R15,BLKLEN               PAST BLK?
         BL    SETPOINT                 NO - GO ON
         SRL   R14,1                    TRY HALF WAY THEN
         SR    R15,R14                  MAYBE NOW?
         CH    R15,BLKLEN               STILL ICKY?
         BNL   OFLOD                    YES - GIVE UP AND NEXT BLK
         LH    R15,BLKLEN               NO - PT TO END OF BLK + 1
         B     SETPOINT                 GO GIVE IT TO HIM
         SPACE 2
OFLOD    BAL   R8,CHKPT                 CHECK TO SEE IF ZAP REQ
         BAL   R8,READNBLK              GET THE NEX BLK            LDW1
         B     SETPNT00                 GO GIVE HIM OFFSET 0       LDW1
         SPACE 3
*
*****  U  *****                                                    LDW1
*
PFKUP    MVC   REP,BLANKS                                       .AFDSC.
         MVI   REP,C'U'                                         .AFDSC.
         SR    R0,R0                                            ,AFDSC.
UP       BAL   R8,DU$COM                GET # OF BYTES             LDW1
         SR    R15,R14                  BACK UP                    LDW1
         BNM   SETPOINT                 USE IT IF OK               LDW1
         B     SETPNT00                 TOO FAR, USE 0             LDW1
         SPACE 5
DU$COM   L     R14,WIDTHD               GET # OF LINES BELOW       LDW1
         A     R14,WIDTHU               ADD NUMBER OF LINES ABOVE  LDW1
         LA    R14,1(,R14)              ADD CARET LINE             LDW1
         MH    R14,LINEHEX              GET # OF BYTES DISPLAYED   LDW1
         LH    R15,OLDPOINT             GET CURRENT OFFSET         LDW1
         BR    R8                       RETURN TO "D" OR "U"       LDW1
         TITLE 'ZAP --- COMMAND EXECUTION --- =, NODEF'            LDW1
*
*****  =  *****
*
EQUALS   BNP   INVEXPER                 ERROR IF JUST '='          LDW1
         LR    R7,R1                    -> STRING                  LDW1
         LR    R1,R0                    LENGTH                     LDW1
         BAL   R8,HEXCHECK              SEE IF VALID NUMBER        LDW1
         B     EQUALBAD                 CAN'T USE #'S FOR SYMBOLS  LDW1
         L     R4,IDEFAVAL              GET PTR TO 1ST AVAIL TABL POS
         CLI   0(R4),X'FF'              END OF TABLE?
         LA    R2,TABFULL               GET MSG ADDR IN CASE       LDW1
         BE    BOTCH                    NO ROOM...                 LDW1
         L     R3,AIDEFTAB              PT TO BEGINNING            LDW1
         SPACE 1
*  SEE IF THE SYMBOL IS ALREADY DEFINED
         SPACE 1
ICLOOP   CR    R3,R4                    UP TO FIRST AVAIL POS YET?
         BNL   OKIDEF                   YES - NO DUPLICATE, SO DEFINE
         CLC   0(8,R3),REP+1            NO - SYMBOL ALREADY HERE?  LDW1
         BE    REDEF                    YES - SO REDEFINE IT
         LA    R3,10(,R3)               NO - PT TO NEXT SPOT IN TABLE
         B     ICLOOP                   KEEP GOING TILL OUT
         SPACE 1
REDEF    MVC   0(8,R3),REP+1            MOVE IN THE SYMBOL         LDW1
         MVC   8(2,R3),OFFSET+2         MOVE IN THE OFFSET         LDW1
         LA    R2,REDEFMSG              PT TO MSG SAYING REDEFINED SYM
         B     BOTCH                    DONT RESET FIRST AVAIL - LEAVE
         SPACE 1
OKIDEF   MVC   0(8,R4),REP+1            MOVE IN THE SYMBOL TO TAB  LDW1
*LDW1    MVC   8(2,R4),OLDPOINT         MOVE IN OFFSET INTO BLK
         MVC   8(2,R4),OFFSET+2         MOVE IN THE OFFSET         LDW1
         LA    R4,10(,R4)               POINT TO NEXT AVAIL
         ST    R4,IDEFAVAL              SAVE FOR NEXT TIME
         OI    FLAGS2,NOWHEREF          SUPRESS WHERE LINES
         B     NEWDSPNT                 DISPLAY (NOTRACE)
         SPACE 2
EQUALBAD LA    R2,BADEQUAL              PT TO MSG                  LDW1
         B     BOTCH                    MAS CAN'T COMPLAIN ANYMORE LDW1
         SPACE 7
*
*****  NODEF  *****
*
NODEF    BAL   R8,CLEARDEF              YES - LET HIM HAVE IT
         LA    R2,DEFRESET              TELL HIM WE RESET THE TABLE
         OI    FLAGS2,NOWHEREF          SUPRESS WHERE LINES
         B     BOTCH                    GO BACK TO DISPLAY (NOTRACE)
         TITLE 'ZAP --- COMMAND EXECUTION --- IDEF'
*
*****  IDEF  *****
*
IDEF     BAL   R8,CLEAR                 CLEAR THE SCREEN
         MVC   LINE06(16),=C' SYMBOL   OFFSET'  MOVE MASK FOR COL 1
         MVC   LINE06+20(3*20-4),LINE06  MAKE 3 MORE COLUMNS       LDW1
         LA    R1,LINE08                PT TO DISPLAY              LDW1
         CLI   LINELEN+1,80             4 COLUMNS OK?              LDW1
         BE    *+14                     YES - LEAVE IT             LDW1
         MVC   LINE06+40($L-40),BLANKS  NO - KILL LAST 2           LDW1
         LA    R1,LINE07                PT TO DISPLAY              LDW1
         L     R2,IDEFAVAL              PT PAST LAST LOC TO FMT    LDW1
         L     R3,AIDEFTAB              PT TO TABLE                LDW1
         OI    FLAGS2,NOWHEREF          SUPRESS WHERE LINES
         SPACE 1
IDEFNEWL LA    R4,2                     ASSUME 2 COLUMNS           LDW1
         CLI   LINELEN+1,80             RIGHT?                     LDW1
         BNE   *+6                      YES - OK                   LDW1
         AR    R4,R4                    NO - MAKE IT 4 COLUMNS     LDW1
IFMTLOOP CR    R3,R2                    DONE WITH FORMATTABLE STUFF?
         BNL   DISPLYNT                 YES - DISPLAY WITH NO TRACE
         MVC   0(8,R1),0(R3)            MOVE SYMBOL TO DISPLAY
         HEX   (11,R1),(8,R3),LEN=2     MOVE IN OFFSET             LDW1
         LA    R1,20(,R1)               UPDATE DISPLAY PTR
         LA    R3,10(R3)                UPDATE TABLE PTR
         BCT   R4,IFMTLOOP              DO ANOTHER                 LDW1
         LA    R1,$I-4*20(,R1)          INCREMENT A LITTLE MORE    LDW1
         CLI   LINELEN+1,80             WAS THAT ENOUGH MORE?      LDW1
         BE    IDEFNEWL                 YES - DO ANOTHER LINE      LDW1
         LA    R1,40(,R1)               NO - FIX IT                LDW1
         B     IFMTLOOP                 KEEP UP THE GOOD WORK
         TITLE 'ZAP --- COMMAND EXECUTION --- ITRACE'
*
*****  ITRACE  *****
*
ITRACE   L     R2,AITRCTAB              PT TO BEGINNING OF TABLE   LDW1
         OI    FLAGS2,NOWHEREF          SUPRESS WHERE LINES
         BAL   R8,CLEAR                 CLEAR THE SCREEN
         MVC   LINE06+1(11),=C' TTR   OFFS'   MOVE IN TITLE FOR COL 1
         MVC   LINE06+14(13*5-2),LINE06+1     MAKE 5 MORE COLUMNS  LDW1
         LA    R3,LINE08                FIRST AVAIL SCREEN POSIT   LDW1
         CLI   LINELEN+1,80             6 COLUMNS OK?              LDW1
         BE    *+14                     YES - LEAVE IT             LDW1
         MVC   LINE06+40($L-40),BLANKS  NO - KILL LAST 2           LDW1
         LA    R3,LINE07                FIRST AVAIL SCREEN POSIT   LDW1
NEWLINE  LA    R4,3                     CNT FOR GOOD OFFSET DISP LOOP
         CLI   LINELEN+1,80             NEED 6 COLUMNS?            LDW1
         BNE   *+6                      NO - LEAVE IT              LDW1
         AR    R4,R4                    YES - MAKE IT 6            LDW1
ITRFMTLP CLI   0(R2),X'FF'              END OF TABLE
         BE    DISPLYNT                 GO DISPLAY (NOTRACE & NO REBLD)
         HEX   (1,R3),(0,R2),LEN=3      MOVE IN TTR                LDW1
         HEX   (8,R3),(3,R2),LEN=2      MOVE IN OFFSET             LDW1
         C     R2,CURRITR               IS THIS THE CURRENT TRACE TAB
         BNE   *+8                      NO - GO ON WITH FORMATTING
         MVI   0(R3),C'>'               MOVE IN THE PTR TO CURR ENTRY
         LA    R3,13(R3)                UPDATE SCREEN PTR
         LA    R2,5(,R2)                UPDATE TABLE PTR
         BCT   R4,ITRFMTLP              DO IT THRICE (OR 6)
         LA    R3,$I-6*13(,R3)          MAKE UP FOR ODDBALL SCREEN LDW1
         CLI   LINELEN+1,80             6 COLUMNS?                 LDW1
         BE    NEWLINE                  YES - DO NEXT LINE         LDW1
         LA    R3,39(,R3)               MAKE UP FOR ODDBALL SCREEN
         B     NEWLINE                  DO IT ALL OVER
         TITLE 'ZAP --- COMMAND EXECUTION --- >, <'
*
*****  >  *****
*
FORWARD  L     R3,ITRAVAL               PICK UP PTR TO NEXT TRACE
         MVI   TRACE,NOTRACE            DON'T TRACE > FOR PETE'S SAKE
         CLI   0(R3),X'FF'              END OF TABLE?
         BNE   *+8                      NO - NO PROBLEM
         L     R3,AITRCTAB              YES - SO WRAP TO TOP       LDW1
         CLI   0(R3),X'FE'              EXIST YET?                 LDW1
         LA    R2,INVFMSG               GET MSG ADDR IN CASE       LDW1
         BE    BOTCH                    NO - TELL HIM NO GOOD      LDW1
         LA    R2,5(,R3)                PT TO NEXT ONE AFTER THAT
         LR    R4,R2                    SAVE NEXT CURRENT ONE
         B     CARET                    FINISH ALL THE REST
         SPACE 2                                                   LDW1
*
*****  <  *****
*
BACKWARD MVI   TRACE,NOTRACE            DON'T TRACE A < EITHER
         L     R2,AITRCTAB              PT TO TRACE TABLE          LDW1
         L     R3,ITRAVAL               PT TO NEXT CURRENT ENTRY
         CR    R3,R2                    CURRENT ENTRY = FIRST ENTRY?
         BNE   *+8                      NO - NO PROBLEM (YET)
         L     R3,AITREND               YES - MUST LOOP TO TAB END LDW1
         SH    R3,=H'5'                 BACKTRACK ONE ENTRY
         LR    R4,R3                    SAVE FOR LATER ITRAVAL
         CR    R3,R2                    IS THAT THE BEGINNING NOW?
         BNE   *+8                      NO - NO MORE WORRIES
         L     R3,AITREND               YES - WE LOOP TO ENDTAB    LDW1
         SH    R3,=H'5'                 BACKTRACK ONE ENTRY
         CLI   0(R3),X'FE'              DOES THAT ENTRY EXIST?     LDW1
         BNE   CARET                    YES - WE'RE OK
         LA    R2,INVBMSG               NO - TELL HIM SO AND
         B     BOTCH                    GO TELL HIM
         SPACE 2                                                   LDW1
*
*  DO THE CARET.  IF LEAVING BLOCK, CHECK TO SEE OF BLK REPLACED.
*
CARET    CLC   TTR(3),0(R3)             NEW BLOCK NEEDED?
         BE    RDNOTNEC                 NO, DON'T BOTHER WITH CHECK
         BAL   R8,CHKPT                 YES, MAKE SURE THIS ONES OK
         MVC   TTR(3),0(R3)             NEW BLK - GET CORRECT TTR
         ST    R3,TEMP                  SAVE PTR TO THE ENTRY
         BAL   R8,READBLK               READ THE BLOCK IN
         L     R3,TEMP                  PICK UP THE PTR BACK
         SPACE 1
RDNOTNEC ST    R4,ITRAVAL               NEW TRACE TABLE PTR
         ST    R3,CURRITR               SAVE CURRENT TRACE TAB ENTRY
         MVC   TEMP(2),3(R3)            NOW GET OFFSET FROM TRACE TAB
         LH    R15,TEMP                 INTO RIGHT REG             LDW1
         B     SETPOINT                 GO FAKE A '+' COMMAND
         TITLE 'ZAP --- COMMAND EXECUTION --- T, P, %'             LDW1
*
*****  T  *****
*
TRACK    BAL   R8,CHKPT                 ANY ZAP NEEDED?
         LTR   R0,R0                    TEST OPERAND LENGTH        LDW1
         BNZ   MORET                    NOT JUST 'T'
         LH    R15,TTR                  JUST A T (T=T+1)
         LA    R15,1(R15)               POINT TO NEXT TRACK
         B     POSTRACK                 GO DO IT
MORET    LH    R15,TTR                  PICK UP '*' TRACK
         BAL   R8,CALLEXP               PARSE & CHECK              LDW1
         BM    TTRLT1                   NEGATIVE IS BAD            LDW1
POSTRACK STH   R15,TTR                  SAVE TRACK #
         MVI   TTR+2,X'01'              GIVE HIM REC=01
         B     NEW$READ                 READ AND DISPLAY
         SPACE 7                                                   LDW1
*
*****  P  *****
*
POINT    BAL   R8,CHKPT                 ANY ZAP NEEDED?
         LTR   R0,R0                    TEST OPERAND LENGTH        LDW1
         BNZ   MOREP                    MORE THAN P - GET TTR
         MVC   TTR(4),=XL4'00000100'    JUST 'P',GIVE HIM TTRN=00000100
         B     NEW$READ                 DO IT
MOREP    BAL   R6,TTRPARSE              GET THE TTR SPECIFIED      LDW1
         MVC   TTR(3),TEMP+1            MOVE IN TTR
         B     NEW$READ                 GO GET IT
         SPACE 1
*                                                                  MAS2
*****  J  *****   (TTR FROM BEGINING OF VOLUME - FOR JES HASPACE)  MAS2
*                                                                  MAS2
POINT$J  BAL   R8,CHKPT                 ANY ZAP NEEDED?            MAS2
         LTR   R0,R0                    TEST OPERAND LENGTH        MAS2
         BNZ   POINT$J2                 MORE THAN P - GET TTR      MAS2
         MVC   TTR(4),=XL4'00000100'    JUST 'P',GIVE HIM TTRN=00000100
         B     NEW$READ                 DO IT                      MAS2
POINT$J2 BAL   R6,TTRPARSE              GET THE TTR SPECIFIED      MAS2
         MVC   TTR(3),TEMP+1            MOVE IN TTR                MAS2
POINT$J3 L     R14,DCBU+12              @ DEVICE CHAR TABLE ENTRY  MAS2
         L     R15,DCBU+44              @ DEB                      MAS2
         LH    R0,32+6(,R15)            1ST EXTENT CYL BEGIN       MAS2
         MH    R0,2(,R14)               * # OF TRKS/CYL            MAS2
         AH    R0,32+8(,R15)            + 1ST EXTENT TRK BEGIN     MAS2
         LH    R1,TTR                   GET TRACK SPECIFIED        MAS2
         SR    R1,R0                     ON VOLUME                 MAS2
         STH   R1,TTR                     (FOR JES/VTOC TTRS)      MAS2
         B     NEW$READ                 GO GET IT                  MAS2
         SPACE 7
*
*****  %  *****                                                    LDW1
*
INDPOINT LH    R15,OLDPOINT             GET BUFFER OFFSET          LDW1
         MVI   EXPOPT,YESSYMB           WANT SYM TAB LOOKUP        LDW1
         BAL   R8,CALLEXP               EVALUATE OPERAND           LDW1
         BM    INVEXPER                 NEG IS INVALID             LDW1
         LH    R0,BLKLEN                GET BLOCK LENGTH           LDW1
         SH    R0,=H'3'                 LAST POSSIBLE TTR          LDW1
         CR    R15,R0                   PAST END?                  LDW1
         BH    INVEXPER                 YES - ERROR                LDW1
         A     R15,ADDRBUFF             GET ADDR IN BUFFER         LDW1
         BAL   R8,CHKPT                 CAN HE LEAVE?              LDW1
         MVC   TTR(3),0(R15)            SET NEW TTR                LDW1
         B     NEW$READ                 GO READ IT & DISPLAY       LDW1
         TITLE 'ZAP --- COMMAND EXECUTION --- ABS'
*
*****  ABS *****
*
ABS      BAL   R8,CHKPT                 SEE IF HE CAN LEAVE
         LTR   R15,R0                   TEST OPERAND LENGTH        LDW1
         BNP   INVEXPER                 IT'S BAD                   LDW1
         CH    R15,=H'10'               CCHHR TOO LONG?
         BNH   *+8                      NO, OK
         LH    R15,=H'10'               YES, TRUNCATE
         EX    R15,ABSTR                TRANSLATE TO "HEX", NO EX LEN
         EX    R15,ABSPACK              GET 000CCHHR        NO EX LEN
         SPACE 1
*  FIND 'M'
         SPACE 1
         L     R15,DCBDEBAD-IHADCB+DCBU GET DEB
         XR    R1,R1                    START WITH M=0
         XR    R0,R0                    FOR IC
         IC    R0,DEBNMEXT-DEBDS(,R15)  GET NUMBER OF EXTENTS
ABSLOOP  CLC   DBLW+3(4),DEBSTRCC-DEBDS(R15)  CCHH : START CCHH
         BL    ABSNEXT                  NOT IN THIS EXTENT
         CLC   DBLW+3(4),DEBENDCC-DEBDS(R15)  CCHH : END   CCHH
         BNH   ABSGOT                   NOT IN THIS EXTENT
ABSNEXT  LA    R15,16(,R15)             NEXT EXTENT
         LA    R1,1(,R1)                NEXT 'M'
         BCT   R0,ABSLOOP               NEXT EXTENT
         BAL   R8,CLEAR                 CLEAR THE SCREEN FIRST     LDW1
         MVC   TTR(3),=X'FFFFFFFFFF'    SET UP A BAD TTR           LDW1
         MVC   CCHHR(5),=X'FFFFFFFFFF'  HERE TOO                   LDW1
         MVI   IOERROR,YESSYN           SAY "IOERROR"              LDW1
         XC    BLKLEN,BLKLEN            NOTHING TO DISPLAY         LDW1
         MVC   LINE05+17(40),IOERRMSG   MOVE IN MASK               LDW1
         MVC   LINE05+35(15),=CL15'NOT IN DATA SET'                LDW1
         B     DISPLYNT                 GO SAY BOTCHED             LDW1
         SPACE 1
ABSGOT   STC   R1,DBLW                  SET 'M'
ABSGOT1  STM   R9,R12,56(R13)           SAVE REGS CONVERT KILLS
         L     R1,DCBDEBAD-IHADCB+DCBU  GET DEB AGAIN
         LA    R2,DBLW                  GET 'MBBCCHHR'
         LR    R3,R13                   SAVE R13 TOO
         L     R15,CVTPTR               CVT
         L     R15,CVTPRLTV-CVT(,R15)   GET ABS=>REL CONVERT
         BALR  R14,R15                  GO GET TTRZ
         LR    R13,R3                   RESTORE R13
         LM    R9,R12,56(R13)           RESTORE OTHER REGS
         ST    R0,TTR                   SAVE TTR
         B     NEW$READ                 GO READ/DISPLAY
         SPACE 1
ABSTR    TR    TEMP2+3(0),TRHEX         << EXECUTED >>             LDW1
ABSPACK  PACK  DBLW(9),TEMP2+3(0)       << EXECUTED >>
         TITLE 'ZAP --- COMMAND EXECUTION --- B, R'                LDW1
*
*****  B  *****
*
BACK     BAL   R8,CHKPT                 ANY ZAP NEEDED?
         MVI   EOFRET,NOEOF             TREAT EOF'S AS DATA BLKS
         XR    R15,R15                  CLEAR FOR IC               LDW1
         IC    R15,TTR+2                GET R                      LDW1
         SH    R15,=H'1'                BACK IT UP 1               LDW1
         B     RBACK                    GO CHECK IT                LDW1
         SPACE 7                                                   LDW1
*
*****  R  *****
*
RECORD   BAL   R8,CHKPT                 ANY ZAP NEEDED?
         CLI   DSORG,DSORGPO            ARE WE IN A PDS?
         BNE   *+8                      NO - TELL HIM ABOUT EOF'S
         MVI   EOFRET,NOEOF             YES - TREAT EOF'S AS DATA BLKS
         LTR   R0,R0                    TEST OPERAND LENGTH        LDW1
         BP    MORER                    NOT JUST 'R'
         MVI   TTR+3,SEQREAD            GO TO NEXT RECORD
         B     NEW$READ                 READ AND DISPLAY
         SPACE 1
MORER    XR    R15,R15                  CLEAR FOR IC
         IC    R15,TTR+2                GET CURRENT RECORD
         BAL   R8,CALLEXP               PARSE & CHECK              LDW1
         SPACE 1
RBACK    XR    R1,R1                    CLEAR FOR IC
         IC    R1,TTR+2                 GET CURRENT RECORD
         LR    R3,R15                   PRESERVE ABSOLUTE FOR BACK
         SR    R3,R1                    FIND OFFSET
         LR    R5,R15                   SAVE IT
* R3 IS RELATIVE OFFSET
* R5 IS ABSOLUTE VALUE
         BZ    NEW$READ                 IF STILL HERE, REREAD
         BM    RGOBACK                  IF NEGATIVE, BACK UP
         SPACE 2
*
*  OFFSET IS POSITIVE: READ FORWARD ENOUGH TIMES
*
RGOFORW  MVI   EOFRET,YESEOF            WE WANT TO STOP AT EOF FOR +
         BAL   R8,READNBLK              READ NEXT BLOCK            LDW1
         CLI   IOERROR,YESSYN           WAS THERE AN I/O ERROR?
         BE    NEWDSPNT                 YES - CUT THIS OUT
         BCT   R3,RGOFORW               GO FORWARD
         B     NEW$READ                 WHEN DONE, DISPLAY IT
         TITLE 'ZAP --- COMMAND EXECUTION --- R'                   LDW1
*
*  OFFSET IS NEGATIVE: READ BACKWARD ENOUGH TIMES
*
RGOBACK  LTR   R5,R5                    WAS ABSOLUTE ON THIS TRACK?
         STC   R5,TTR+2                 ASSUME YES - SET NEW RECORD
         BP    NEW$READ                 YES - READ IT              LDW1
*  BACK UP A TRACK
         LH    R0,TTR                   GET TRACK NUMBER
         BCTR  R0,0                     MINUS ONE
         LTR   R0,R0                    BACK TO ZERO?
         BNM   RCOUNT                   ITS GOOD, COUNT TRACK
         MVC   TTR(4),=XL4'00000100'    BACKED UP TOO FAR
         BAL   R8,SETMSG                MOVE MSG TO RIGHT PLACE    LDW1
         DC    Y(TTRSMALL-ZAP)          'TTR < 000001 INVALID'     LDW1
         B     NEW$READ                 DISPLAY FIRST RECORD
RCOUNT   STH   R0,TTR                   SAVE FOR COUNT
         MVI   TTR+2,0                  IT WILL INCREMENT
         MVC   TEMP(3),TTR              SAVE TTR
         SPACE 1
BCKCNT   BAL   R8,READNBLK              GET A BLK                  LDW1
         CLC   TEMP(2),TTR              STILL THIS TRACK?
         BNE   RNEWTRK                  NO
         CLI   IOERROR,YESSYN           I/O ERROR?
         BE    NEWDSPNT                 GET OUTA HERE
         MVC   TEMP+2(1),TTR+2          SAVE THIS RECORD
         B     BCKCNT                   CONTINUE DOWN TRACK
RNEWTRK  MVC   TTR(2),TEMP              RESTORE PREVIOUS TRACK
         XR    R1,R1                    CLEAR FOR PICKUP
         IC    R1,TEMP+2                GET NUMBER OF RECS
         AR    R5,R1                    WE NOW ARE THIS FAR BACK
         B     RGOBACK                  GO SEE IF ITS ON THIS TRK
         TITLE 'ZAP --- COMMAND EXECUTION --- L, F'
PFKLOC   MVC   REP,BLANKS                                       .AFDSC.
         MVI   REP,C'L'                                         .AFDSC.
         SR    R0,R0                                            .AFDSC.
*
*****  F  *****
*
FIND     MVI   EOFRET,NOEOF             SET SO EOF'S COME BACK     LDW1
         SPACE 3
*
*****  L  *****
*
LOCATE   LTR   R3,R0                    TEST OPERAND LENGTH        LDW1
         BZ    LGO                      JUST L, GO CONTINUE        LDW1
         LR    R4,R1                    PT TO STRING               LDW1
         LA    R5,LOOKFOR               POINT TO STRING SAVEAREA
         BAL   R6,GETSTRNG              GET THE HEX OR CHAR STRING
         B     AROUND1
*
*  CONTINUE SCAN
*
LGO      TM    CONTINUE,YESCONTL        CAN WE CONTINUE SCAN?
         LA    R2,LINMSG                ASSUME NO - PT TO MSG
         BNO   BOTCH                    NO - NO SCAN WAS STARTED   LDW1
*  CONTINUE THE SCAN
         LH    R3,LOOKFOR               YES - GET THE SCAN LEN     LDW1
*
*  SET UP SCAN
*
AROUND1  XR    R2,R2                    CLEAR REG FOR IC (WHAT ELSE?)
         IC    R2,LOOKFOR+2             GET 1ST CHAR TO FIND       LDW1
         LA    R2,TEMPTRT(R2)           PT TO OFFSET IN TRTAB
         XC    TEMPTRT(256),TEMPTRT     CLEAR TRTAB
         MVI   0(R2),X'FF'              MOVE IN FF THERE
         OI    CONTINUE,YESCONTL        SAY HE CAN CONTINUE SCAN NOW
         LH    R1,OLDPOINT              GET CURRENT OFFSET         LDW1
         CLI   REALRDLN+1,1             JUST 'L' ENTERED?          LDW1
         BNE   *+8                      NO - START FROM HERE       LDW1
         LA    R1,1(,R1)                YES - START FROM NEXT BYTE LDW1
         B     LOOK8                    GO ON
         EJECT
*
*  BLOCK SCAN LOOP
*
LOOK7    SR    R1,R1                    RESET BUFFER PTR
LOOK8    A     R1,ADDRBUFF              PT TO OFFSET IN BUFFER
         BCTR  R1,0                     -1
         LH    R5,BLKLEN                GET BLK LENGTH
         A     R5,ADDRBUFF              PT TO END OF BLK
*
*  DO THE SCAN
*
*SDM3    TRT   1(256,R1),TEMPTRT        IS 1ST CHAR THERE?
LOOKLOOP LR    R2,R5                    GET END                    SDM3
         SR    R2,R1                    COMPUTE LENGTH             SDM3
         SH    R2,=H'2'                 GET LENGTH OF REMAINDER    SDM3
         BM    TOOFAR                   NOT ENOUGH                 SDM3
         EX    R2,SCANTRT               FIND INTERESTING STRING    SDM3
         BZ    LOOK1                    NOT YET - KEEP TRYING
         CR    R1,R5                    YES - BUT IS IT PAST THE BLK?
         BNL   TOOFAR                   YES - SO GET A NEW ONE
         EX    R3,SCANCLC               NO - IS ALL OF IT THERE?
         BNE   LOOKLOOP                 NO - KEEP CHECKING
         MVC   LINE19+17(40),=CL40'        *****  SCAN MATCH  *****'
         S     R1,ADDRBUFF              YES - GET WHERE IT IS AND...
         LR    R15,R1                   INTO RIGHT REG             LDW1
         B     SETPOINT                 FAKE A '+' COMMAND TO IT
SCANTRT  TRT   1(0,R1),TEMPTRT          <<< EXECUTED >>>           SDM3
SCANCLC  CLC   0(0,R1),LOOKFOR+2        <<< EXECUTED >>>           LDW1
*SDM3    LA    R1,256(R1)               UPDATE TRT PTR TO BUFFER
LOOK1    N     R2,=XL4'FF'              GET CLEAN SINGLE BYTE      SDM3
         LA    R1,1(R1,R2)              SET LOCATION TO TRY AGAIN  SDM3
         CR    R1,R5                    PAST BLK?
         BL    LOOKLOOP                 NO - KEEP SCANNING
         SPACE 1
TOOFAR   BAL   R8,CHKPT                 ANY ZAP NEEDED?
TOOFAR2  BAL   R8,READNBLK              GET NEXT BLK FOR SCANNING  LDW1
         CLI   IOERROR,YESSYN           I/O ERROR?
         BE    NEWDSPNT                 YES - GET OUT
         CLI   DSNAME,X'04'             VTOC?                      LDW4
         BE    TOOFAR4                  YES - DIFFERENT CHECK      LDW4
         CLC   TTR(3),ENDTTR            HAVE WE ARRIVED?           LDW4
         BE    TOOFAR3                  YES - PAUSE                LDW4
NOT2FAR  OC    BLKLEN,BLKLEN            ANYTHING HERE? (EOF IF 'F')LDW1
         BE    TOOFAR2                  NO - GET NEXT BLOCK        LDW1
         B     LOOK7                    GO SCAN IT THEN
         SPACE 1
TOOFAR3  MVC   LINE19+22(33),=C'*****  HOLDING AT DS1LSTAR  *****' LDW4
         B     SETPNT00                 DISP OFF 0, CURR BLK       LDW4
         SPACE 2
TOOFAR4  CLC   CCHHR(5),LASTFMT1        IS THIS THE LAST FMT1?     LDW4
         BNE   NOT2FAR                  NO - CONTINUE SCAN         LDW4
         MVC   LINE19+22(33),=C'*****  HOLDING AT LASTFMT1  *****' LDW4
         B     SETPNT00                 DISP OFF 0, CURR BLK       LDW4
         TITLE 'ZAP --- COMMAND EXECUTION --- S, X, O, N'
         SPACE 5
*
*****  N  *****
*
AND      BAL   R2,SXON                  PT TO EX INSTR, GO DO IT   LDW1
         NC    0(0,R5),ZAPSTRNG+2       <<< EXECUTED >>>    'N'    LDW1
         SPACE 5
*
*****  O  *****
*
OR       BAL   R2,SXON                  PT TO EX INSTR, GO DO IT   LDW1
         OC    0(0,R5),ZAPSTRNG+2       <<< EXECUTED >>>    'O'    LDW1
         SPACE 5
*
*****  X  *****
*
EXOR     BAL   R2,SXON                  PT TO EX INSTR, GO DO IT   LDW1
         XC    0(0,R5),ZAPSTRNG+2       <<< EXECUTED >>>    'X'    LDW1
         SPACE 5
*
*****  S  *****
*
STORE    BAL   R2,SXON                  PT TO EX INSTR, GO DO IT   LDW1
         MVC   0(0,R5),ZAPSTRNG+2       <<< EXECUTED >>>    'S'    LDW1
         EJECT
*  ALLOW HIM TO USE PREVIOUS STRING IF HE JUST ENTERS THE COMMAND
*  WITH NO SUBSEQUENT STRING OPERAND.
         SPACE 5
SXON     ST    R2,0(,R13)               SAVE THE EX INSTR PTR
         LTR   R3,R0                    TEST OPERAND LENGTH        LDW1
         BP    SXONNEW#                 HAVE AN OPERAND - USE IT   LDW1
         SPACE 2
*  USE AN OLD STRING FOR S,X,O,N WITH NO OPERANDS
         SPACE 1
         TM    CONTINUE,YESCONTS        JUST 'S'.  OLD STRING YET?
         BO    SXONNEW                  YES, GO ON
         B     INVEXPER                 SAY SYNTAX ERROR COL 2     LDW1
         SPACE 2
INVALCOM LA    R2,INVCOM                PT TO MSG                  LDW1
         B     BOTCH                    AND TELL HIM               LDW1
         SPACE 2
*  USE SPECIFIED STRING
         SPACE 1
SXONNEW# LR    R4,R1                    POINT TO STRING OPERAND    LDW1
         LA    R5,ZAPSTRNG              POINT TO STRING WORK AREA
         BAL   R6,GETSTRNG              GET AL2(LEN),C'STRING'
         SPACE 1
*  AT THIS POINT, ZAPSTRNG CONTAINS THE INFO NECESSARY TO STORE:
*        AL2(STRING_LENGTH),C'STRING'
         SPACE 1
SXONNEW  OC    BLKLEN(2),BLKLEN         ANYTHING TO CHANGE HERE?
         BZ    INVALCOM                 NO - TELL HIM              LDW1
         CLI   GODFLAG,NOGOD            CAN HE EVER UPDATE?
         BNE   LETSTORE                 YES - SO GO ON
         BAL   R8,SETMSG                MOVE MSG TO RIGHT PLACE    LDW1
         DC    Y(STORMSG-ZAP)           TELL HIM NOT UPDATING      LDW1
LETSTORE LH    R4,ZAPSTRNG              GET LEN                    LDW1
         LH    R5,OLDPOINT              PT TO ZAPPED OFFSET
         EJECT ,                                                   LDW1
*
*  CHECK TO SEE IF STRING WILL FIT IN THE REMAINING PART OF THE BLK
*  WHERE HE IS POINTING
*
         SPACE 2                                                   LDW1
         LH    R6,BLKLEN                GET LENGTH OF BLK
         SR    R6,R5                    GET LENGTH OF PIECE REMAINING
         CR    R6,R4                    IS IT SMALLER THAN THE STRING?
         LA    R2,LENERR                ASSUME STRING IS INVALID LENGTH
         BNH   BOTCH                    YES - SO GO TELL HIM       LDW1
*  STRING WILL FIT
         A     R5,ADDRBUFF              PT TO ACTUAL ZAPPED DATA
         OI    CONTINUE,YESCONTS        SAY HE CAN DO 'SXON' NO OPRND
         LA    R1,N1                    MESSAGE NUMBER
         BAL   R8,SETLINE               SET UP THE LINE
         B     NOMSGEX                  NOT PRINTING
         CLI   CHNGED,0                 VIRGIN BUFFER?
         BNE   *+8                      NO, SINGLE SPACE
         MVI   0(R2),C'0'               ELSE, DOUBLE SPACE FIRST CHANGE
         MVC   31(16,R2),=C'OFFSET XXXX DATA'
******%% MVC   31(27,R2),=C'OFFSET XXXX ADDR XXXXX DATA'    SOMEDAY
         HEX   (38,R2),OLDPOINT,LEN=2   CONVERT OFFSET TO THE LINE LDW1
         LA    R1,48(R2)                POINT TO SPOT
         BAL   R8,SETSTRNG              CONVERT STRING TO LINE AS WAS
         MVC   104(5,R2),=C'CCHHR'      MOVE IN IDENTIFIER         LDW1
         HEX   (110,R2),CCHHR,LEN=5     GET THE CCHHR              LDW1
         BAL   R8,CPUT                                             LDW1
*LDW1    MVC   81(16,R2),=C'TO BE CHANGED TO'
*LDW1    LA    R1,81+16+1(R2)           NEXT STRING LOCATION
         LA    R1,N1                                               LDW1
         BAL   R8,SETLINE                                          LDW1
         EX    0,*                                                 LDW1
         MVC   20(10,R2),19(R2)         BLANK THE TTR THIS TIME    LDW1
         MVC   31(16,R2),=C'TO BE CHANGED TO'                      LDW1
         LA    R1,48(,R2)                                          LDW1
         L     R2,0(R13)                RESTORE EX INS PTR
         EX    R4,0(R2)                 CHANGE DATA IN BUFFER
         BAL   R8,SETSTRNG              RECORD THE CHANGE
         BAL   R8,CPUT                  PUT THE LINE
         MVI   CHNGED,255               MARK AS CHANGED FOR LATER
         OI    FLAGS2,MUSTZAP           BLK NEEDS A ZAP NOW
         MVC   OLDTTR(3),TTR            COPY FOR PRINTING
         B     NEWDSPNT                 THEN RETURN TO HIM         LDW1
         SPACE 2                                                   LDW1
NOMSGEX  L     R2,0(R13)                RESTORE EX INSTRUCTION PTR
         EX    R4,0(R2)                 MAKE THE APPROPRIATE CHANGE
         OI    FLAGS2,MUSTZAP           BLK NEEDS A ZAP NOW        LDW1
         B     NEWDSPNT                 GIVE IT TO HIM
         TITLE 'ZAP --- COMMAND EXECUTION --- SET'
*
*****  SET  *****
*
SET      LTR   R3,R0                    TEST OPERAND LENGTH        LDW1
         BP    SETNEW#                  THERE IS ONE               LDW1
         SPACE 1
*  USE OLD STRING FOR SET NO OPERANDS
         SPACE 1
         TM    CONTINUE,YESCONTT        IS THERE AN OLD ONE TO USE?
         BO    SETNEW                   YES - USE IT               LDW1
         B     INVEXPER                 INVALID SYNTAX COL 4       LDW1
         SPACE 2
*  USE SPECIFIED STRING
         SPACE 1
SETNEW#  LR    R4,R1                    -> TO THE STRING OPERAND   LDW1
         LA    R5,SETSTR                WHERE TO SAVE THE INFO
         BAL   R6,GETSTRNG              GET AL2(LEN),C'STRING'
         EJECT                                                     LDW1
*  NOW SETSTR CONTAINS:
*        AL2(SET_LEN),C'SET_STRING'
         SPACE 1
SETNEW   OC    BLKLEN(2),BLKLEN         IS THERE ANYTHING TO SET?
         BZ    INVALCOM                 NO - SO DON'T AND TELL HIM
         CLI   GODFLAG,NOGOD            CAN HE EVER UPDATE?
         BNE   LETSET                   YES - WE HAVE NOTHING TO SAY
         BAL   R8,SETMSG                MOVE MSG TO RIGHT PLACE    LDW1
         DC    Y(STORMSG-ZAP)           TELL HIM NOT UPDATING      LDW1
LETSET   LH    R4,SETSTR                GET BCTR'D STRING LEN      LDW1
         LA    R5,SETSTR+2              POINT TO STRING            LDW1
         LA    R1,N2                    MSG NUMBER
         BAL   R8,SETLINE               SET UP LINE
         B     NOSETMSG                 OOPS, NOT PRINTING
         CLI   CHNGED,0                 VIRGIN BUFFER?
         BNE   *+8                      NO, SINGLE SPACE
         MVI   0(R2),C'0'               ELSE, DOUBLE SPACE FIRST CHANGE
*LDW1    MVC   31(18,R2),=C'BLOCK TO BE SET TO'  MOVE TEXT
*LDW1    LA    R1,31+18+1(R2)           POINT WHERE IT GOES
         MVC   31(28,R2),=C'FOLLOWING BLOCK TO BE SET TO'          LDW1
         LA    R1,31+28+1(,R2)          POINT WHERE IT GOES        LDW1
         BAL   R8,SETSTRNG              CONVERT THE STRING
         BAL   R8,CPUT                  DUMP THE LINE NOW
         MVI   CHNGED,255               ITS CHANGED NOW
         MVC   OLDTTR(3),TTR            SAVE TTR
         IC    R7,ENQIT                 PRESERVE FLAG              LDW1
         BAL   R6,PREPDMPX              GET READY FOR THE DUMP     LDW1
         BAL   R6,DUMPER                DUMP THE BLOCK             LDW1
         STC   R7,ENQIT                 RESTORE FLAG               LDW1
         LH    R4,SETSTR                RESTORE LENGTH             LDW1
         SPACE 1
NOSETMSG OI    CONTINUE,YESCONTT        SAY HE CAN SET NO OPRND NOW
         OI    FLAGS2,MUSTZAP           BLK NEEDS A ZAP NOW        LDW1
         L     R5,ADDRBUFF              PT TO BUFFER
         XR    R8,R8                    CLEAR REM REG FOR DIVIDE
         LH    R7,BLKLEN                GET LEN OF BLK IN BUFFER
         LA    R1,1(R4)                 GET REAL STRING LENGTH
         DR    R8,R1                    HOW MANY STRINGS FIT IN BLK
         LTR   R7,R7                    BLK SHORTER THAN STRING?
         BZ    JUSTSPEW                 YES - JUST MOVE IN REMAINDER
*  R7 HAS BCT COUNT OF HOW MANY STRINGS CAN FIT IN THIS
*  PARTICULAR BLK, WHILE R8 HAS THE LENGTH OF THE PIECE LEFT OVER.
SETLOOP  EX    R4,SETMVC                MOVE 1 STRING IN
         LA    R5,1(R4,R5)              UPDATE BUFFER PTR FOR NEXT
         BCT   R7,SETLOOP               FILL AS MUCH OF BUFFER AS CAN
JUSTSPEW LTR   R8,R8                    IS THERE A SMALL PIECE LEFT?
         BZ    NEWDSPNT                 NO - WE ARE ALL DONE
         BCTR  R8,0                     YES - GET EXECUTE LEN
         EX    R8,SETMVC                MOVE AS MUCH AS WILL FIT IN
         B     NEWDSPNT                 AND GO DISPLAY WHAT WE DID
         SPACE 1
SETMVC   MVC   0(0,R5),SETSTR+2         <<< EXECUTED >>>           LDW1
         TITLE 'ZAP --- COMMAND EXECUTION --- ZAP/SAVE'
*
*****  ZAP/SAVE  *****
*
REPLACE  CLI   IOERROR,YESSYN           WAS THERE AN I/O ERROR ON BLK?
         BE    WRTNONO                  YES - CAN'T ZAP THAT
         OC    BLKLEN(2),BLKLEN         NO - BUT IS THERE A BLK TO ZAP?
         BZ    WRTNONO                  NO - SO DON'T ZAP ALREADY
         TM    DCBLIST,X'0F'            UPDATING ALREADY?
         BNZ   THERE                    YES, CONTINUE
         CLI   GODFLAG,NOGOD            CAN HE CHANGE FROM INPUT TO UP
         BE    WRTNONO                  NO - TOUGH BEANS FOR HIM
         MVC   REP,BLANKS               CLEAR REPLY                LDW1
         MVC   REP(3),=C'ZAP'           RE-PROMPT THE RIGHT THING  LDW1
         CLOSE MF=(E,DCBLIST)           CLOSE THE DATASET SO THAT....
         MVI   DCBLIST,X'84'            WE CAN OPEN FOR UPDATE
         OPEN  MF=(E,DCBLIST),TYPE=J    THEN DO IT ALREADY         LDW1
         TM    DCBU+48,X'10'            OPEN?
         BO    THERE#                   YES, OK
         BCR   0,1                      DRAIN PIPELINE
         EX    0,*                      THIS BETTER NEVER HAPPEN
THERE#   TM    FLAGS2,LOGF              SEE IF LOGGING
         BNO   THERE                    IF NOT, THEN NO MSG
         L     R1,CSOUTWK               POINT TO WORK AREA
         LTR   R1,R1                    SEE IF THERE
         BZ    THERE                    IF NOT, NO MSG
         LA    R8,THERE                 GET RETURN ADDR
         ST    R8,DBLW                  STORE FOR SUBROUTINE
         B     OPENMSG                  GO WRITE THE MESSAGE
THERE    BAL   R8,WRITE                 WRITE THE BUFFER OUT
         CLI   IOERROR,YESSYN           I/O ERROR?
         BE    NEWDSPNT                 YES - IGNORE TELLING HIM OK
         MVI   CHNGED,0                 BUFFER HAS BEEN CHECKPOINTED
         NI    FLAGS2,255-MUSTZAP       BLK NO LONGER NEEDS ZAP
         SPACE 2
*  UPDATE THE IDR IF APPLICABLE
*  IDR FOR SUPERZAP (AND THEREFORE ZAP) TAKES THE FOLLOWING FORM:
*        BYTE  0.....'80' FOR ID
*        BYTE  1.....LENGTH OF IDR (USUALLY X'FA' = 250.)
*        BYTE  2.....WHO'S IDR IT IS (X'01' FOR SUPERZAP AND ZAP)
*        BYTE  3.....NUMBER OF 13-BYTE IDR DATA ENTRIES (BITS 2-7)
*        BYTES 4-16, 17-29,... IDR DATA ENTRY AS FOLLOWS:
*              BYTES 0-1 --- ESD ID (DEFAULT 1)
*              BYTES 2-4 --- DATE ('YYDDDF')
*              BYTES 5-12 -- INFO ('TSO--UUU, WHERE UUU=ZAPPER'S UID)
         SPACE 2
         CLI   DSORG,DSORGPO            IS THIS A PDS?
         BNE   FINZAP                   NO - FORGET THE IDR
         CLI   DCBRECFM-IHADCB+DCBU,RECFMU  IS THIS A LIBRARY?
         BNE   FINZAP                   NO - DON'T UPDATE THE 'IDR'
         CLI   IDRFLAG,CHGIDR           ALREADY UPDATED THIS IDR
         BE    FINZAP                   YES - DON'T DO IT AGAIN NOW
         MVC   0(3,R13),TTR             LET'S SAVE WHERE HE WAS FIRST
         OC    MEMTTR(3),MEMTTR         WAS THERE A 'M' COMMAND?
         BZ    ENDIDR                   NO - FORGET IT
         MVC   TTR(3),MEMTTR            PICK UP MEMBER PTR
         BAL   R8,READBLK               READ 1ST BLK OF MEMBER
         SPACE 1
IDRFIND  L     R1,ADDRBUFF              GET BUFFER PTR
         TM    0(R1),X'01'              CONTROL RECORD OF SOME SORT?
         BO    ENDIDR                   YES - WE ARE ALL DONE LOOKING
         CLI   0(R1),X'80'              IDR?
         BNE   NEWBLK                   NO - GET ANOTHER BLK
         TM    2(R1),X'01'              YES - BUT DONE BY SUPERZAP?
         BNO   NEWBLK                   NO - FORGET THIS ONE
         XR    R2,R2                    CLEAR WORK REG
         IC    R2,3(R1)                 PICK UP # OF IDR DATA ENTRIES
         LR    R4,R2                    SAVE IT FOR LATER
         N     R2,=XL4'0000003F'        WE JUST WANT BITS 2-7
         MH    R2,=H'13'                EACH ENTRY IS 13 BYTES LONG
         LA    R2,3(R2)                 IDR HDR IS 3 BYTES LONG
*  SO NOW R2 HAS AN OFFSET TO THE NEXT AVAILABLE POSITION IN THE IDR
         XR    R3,R3                    CLEAR WORK REG
         IC    R3,1(R1)                 PICK UP IDR LENGTH
         CR    R3,R2                    ARE WE AT END OF IDR?
         BH    UPDATIDR                 NO - SO UPDATE THE IDR
*
NEWBLK   MVI   EOFRET,NOEOF             TREAT EOF'S AS DATA BLKS
         BAL   R8,READNBLK              READ ON ANOTHER BLK        LDW1
         CLC   LINE05+27(20),EOFMSG     DID I HIT END OF FILE?     LDW1
         BE    ENDIDR                   YES - STOP THIS STUPID THING
         CLI   IOERROR,YESSYN           I/O ERROR?
         BE    ENDIDR                   YES - LEAVE
         B     IDRFIND                  NO - CHECK THIS BLK
*
UPDATIDR AR    R2,R1                    R2 PTS TO NEXT IDR SPOT
         LA    R4,1(R4)                 INCREMENT # OF IDR ENTRIES...
         STC   R4,3(R1)                 AND PUT IT BACK
         MVC   1(2,R2),ESDID            MOVE IN ESDID (IF ANY)
*
         TIME  ,                        GET THE DATE IN R1
*
         ST    R1,DBLW                  SAVE IT IN TEMP WORD
         MVC   3(3,R2),DBLW+1           MOVE YYDDDF TO IDR
         MVI   6(R2),C'/'               INDICATE TSO USERID        LDW4
         MVC   7(7,R2),USERID           MOVE IN THE CULPRIT        LDW4
         BAL   R8,WRITE                 GO WRITE THE RECORD BACK   LDW4
         CLI   IOERROR,YESSYN           I/O ERROR?
         BE    ENDIDR                   YES - SAY WE DIDN'T UPDATE
         MVI   IDRFLAG,CHGIDR           NO - SO WE DID UPDATE THE IDR
         SPACE 1
ENDIDR   DS    0H
         LA    R1,N6                    ASSUME NOT UPDATED
         CLI   IDRFLAG,CHGIDR           WAS THE IDR UPDATED?
         BNE   *+8                      NO - WE WERE RIGHT
         LA    R1,N7                    DID UPDATE
         BAL   R8,SETLINE               SET UP OUTPUT LINE
         B     PUTBACK                  NO PRINT FILE - LEAVE
         MVI   0(R2),C'0'               DOUBLE SPACE
         MVC   20(25,R2),=C'IDR FOR CSECT NOT UPDATED'
         CLI   IDRFLAG,CHGIDR           WAS IT UPDATED?
         BNE   PUTITOUT                 NO - MSG IS OK
         MVC   34(3,R2),EDMASK+9        YES - SO GIVE ESDID         *N*
         LH    R0,ESDID                 GET ESDID (USUALLY)         *N*
         CVD   R0,DBLW                  IN DEC                      *N*
         ED    33(4,R2),DBLW+6          ESDID TO MSG                *N*
PUTITOUT BAL   R8,CPUT                  PUT MSG OUT
PUTBACK  CLC   TTR(3),0(R13)            HAS HE MOVED ANY?
         BE    FINZAP                   YES - DON'T BOTHER PUTTING BACK
         MVI   TTR+3,NOSEQRD            GET THE RIGHT ONE, NOT THE NEXT
         MVC   TTR(3),0(R13)            LET'S PUT HIM BACK WHERE HE WAS
         BAL   R8,READBLK               HE'LL NEVER KNOW WHAT HAPPENED
FINZAP   MVC   LINE19+17(40),=CL40'      *****  BLOCK REPLACED  *****'
         MVI   ENQIT,255                FORCE ENQ NOW THAT ITS ZAPPED
         LA    R1,N3                    MSG NUMBER
         BAL   R8,SETLINE               SETUP THE LINE
         B     NEWDSPNT                 NOT PRINTING
         MVC   31(14,R2),=C'BLOCK REPLACED'
         MVI   0(R2),C'0'               DOUBLE SPACE THIS ONE
         BAL   R8,CPUT                  DUMP THE LINE
*  TRUNCATE CURRENT LOG BLOCK, IN CASE OF SYSTEM/PROGRAM FAILURE
         L     R2,CSOUTWK               IT'S GOTTA BE HERE         LDW1
         MVI   0(R2),X'01'              INDICATE TRUNC             LDW1
         BAL   R8,CPUTRUNC              TRUNCATE THIS LOG BLOCK    LDW1
         B     NEWDSPNT                 YES - DISPLAY WITH NO TRACE
         SPACE 1
WRTNONO  LA    R2,WRITERR               TELL HIM WRITE NOT ALLOWED
         MVC   REP,BLANKS               CLEAR OUT REPLY BUFF AND   LDW1
*                                       SO DON'T TEMPT HIM TO RE-'ZAP'
         B     BOTCH                    AND DISPLAY
         TITLE 'ZAP --- COMMAND EXECUTION --- DISASM, ASM'         LDW1
*
*****  DISASM
*
DISASM   LH    R15,OLDPOINT             CURR OFFSET
         MVI   EXPOPT,YESSYMB           WANT SYM TAB LOOKUP
         BAL   R8,CALLEXP               PARSE & CHECK              LDW1
         BM    INVEXPER                 NEG IS BAD                 LDW1
         LH    R0,BLKLEN                GET LENGTH BLK
         SH    R0,=H'2'                 LAST POSS INSTRUCTION
         CR    R15,R0                   PAST END OF BLK?
         BH    INVEXPER
         A     R15,ADDRBUFF             GET ADDR IN BUFFER
         LNR   R1,R15                   NEG FOR 'DISASM'
         LA    R0,LINE19+24             GIVE HIM 33 BYTES TO WORK WITH
         LA    R2,TEMP2                 GIVE HIM SOME WORKAREA TOO
         L     R15,=V(ASMGASM)          POINT TO 'ASSEMBLER' HAR HAR
         BALR  R14,R15                  DISASSEMBLE IT
         LA    R2,INVOPCOD              ASSUME BOTCHUP
         BXH   R15,R15,BOTCH            YUP
         SPACE 1
         MVC   LINE19+17(7),=C'INSTR:'  NO, MOVE MASK
         B     NEWDSPNT                 AND SHOW IT OFF
         SPACE 10                                                  LDW1
*
*****  ASM
*
ASM      BNP   INVEXPER                 NO OPERAND - BAD           LDW1
         L     R15,=V(ASMGASM)          PT TO SUB
         BALR  R14,R15                  GET OBJECT
         SPACE 1
         LA    R2,INVOPCOD              ASSUME NO
         BXH   R15,R15,BOTCH
         MVC   LINE19+17(8),=C'OP CODE:'  MASK
         HEX   LINE19+27,(0,R1),LEN=1                              LDW1
         B     NEWDSPNT                 SHOW IT
         TITLE 'ZAP --- COMMAND EXECUTION --- V, BASE'             LDW1
*
*****  V  *****
*
INDIRECT LH    R15,OLDPOINT             * = CURRENT OFFSET         LDW1
         MVI   EXPOPT,YESSYMB           WANT SYM TAB LOOKUP        LDW1
         BAL   R8,CALLEXP               PARSE & CHECK              LDW1
         BM    INVEXPER                 NEG IS INVALID             LDW1
         LH    R0,BLKLEN                GET BLOCK LENGTH           LDW1
         SH    R0,=H'2'                 LAST POSSIBLE RDW          LDW1
         CR    R15,R0                   PAST END?                  LDW1
         BH    INVEXPER                 YES - BYE                  LDW1
         A     R15,ADDRBUFF             GET ADDR IN BUFFER         LDW1
         MVC   0(2,R13),0(R15)          REC LEN TO ALIGNED PLACE   LDW1
         LH    R15,0(,R13)              GET RECORD LENGTH          LDW1
         AH    R15,OLDPOINT             BUMP OFFSET                LDW1
         B     SETPOINT                 GO SET IT                  LDW1
*  DO WE WANT TO GO TO THE NEXT BLK IF NECESSARY?                  LDW1
         SPACE 9
*
*****  BASE  *****                                                 LDW1
*
BASE     L     R15,OFFSET               * = CURRENT OFFSET         LDW1
         MVI   EXPOPT,YESSYMB           WANT SYM TAB LOOKUP        LDW1
         BAL   R8,CALLEXP               PARSE & CHECK              LDW1
         ST    R15,BASEVAL              SET NEW BASE VALUE         LDW1
         AH    R15,OLDPOINT             ADD OLD BUFFER OFFSET      LDW1
         ST    R15,OFFSET               SET NEW OFFSET             LDW1
         B     NEWDSPNT                 GO SHOW IT OFF             LDW1
         TITLE 'ZAP --- COMMAND EXECUTION --- DO'
*
*****  DO
*
DO       LA    R2,INVEXP                'INVALID COMMAND'          LDW1
         LTR   R3,R0                    TEST OPERAND LENGTH        LDW3
         BNP   INVEXPER                 ERROR
         SPACE 1
DOL      CLI   0(R1),C' '               SCAN OFF LEADING BLNKS
         BNE   DO1                      FOUND A NON BLNK
         LA    R1,1(R1)                 LOOK AT NXT CHAR
         BCT   R3,DOL                   - THE COUNT
         B     INVEXPER
DO1      LR    R2,R1                    PUT IN RIGHT REG
         BAL   R8,KILL3270              TURN OFF 3270 MODE IF ON   LDW3
         SPACE 1
         TPUTX 'THE "DO" COMMAND IS NOT IMPLEMENTED YET'        .AFDSC.
         B     DO2                                              .AFDSC.
         XC    TMPLIST(TMPLISTL),TMPLIST CLEAR THE LIST
         TPUTX 'DOING'
         OACTMP CMD=((R2),(R3)),MF=(E,TMPLIST)  DO THE 'DO'
         BXH   R15,R15,DO2
         TPUTX 'DONE'
         SPACE 1
DO2      BAL   R8,TGET                  BRANCH ENTRY               LDW1
         B     COMSCAN                  PARSE COMMAND
         TITLE 'ZAP --- COMMAND EXECUTION --- WHERE'
*
*****  WHERE
*
WHERE    MVI   TRACE,NOTRACE            DONT TRACE
         BAL   R8,CLEAR                 CLEAR SCREEN
         B     WHEREAMI                 FORMAT LINE                LDW1
         SPACE 4
*
*****  NOT3270  *****                                              LDW1
*
NOT3270  BAL   R8,KILL3270              TURN OFF 3270 MODE IF ON   LDW1
         NI    FLAGS3,255-F3270         TURN OFF FLAG              LDW5
         B     NEWDSPNT                 DISPLAY AGAIN, NOTRACE     LDW1
         SPACE 4
*
*****  YES3270  *****                                              LDW2
*
YES3270  OI    FLAGS3,F3270+RESHOWF     TELL THE WORLD             LDW5
         B     NEWDSPNT                 DISPLAY AGAIN, NOTRACE     LDW1
         SPACE 4
*
*****  LINE80  *****                                               LDW1
*
LINE80   MVC   DISPCONS(DISPCONL),DSPCON80  CONSTANTS FOR LEN=80   LDW1
         B     NEWDSPNT                 GO DISPLAY, NOTRACE        LDW1
         SPACE 4
*
*****  LINE40  *****                                               LDW1
*
LINE40   MVC   DISPCONS(DISPCONL),DSPCON40  CONSTANTS FOR LEN=40   LDW1
         B     NEWDSPNT                 GO DISPLAY, NOTRACE        LDW1
         TITLE 'ZAP --- COMMAND EXECUTION --- W (WINDOW)'
*
*****  W   (WINDOW)
*
WINDOW   BP    OKWIND                   GO PROCESS OPERANDS
         XC    WIDTHS(4+4),WIDTHS       ONLY 'W', SET DEFAULTS
         NI    FLAGS3,255-CRTF          TURN OFF CRT MODE          LDW1
         OI    FLAGS2,NOWHEREF          SUPRESS WHERE LINES
         B     NEWDSPNT                 AND QUIT
         SPACE 2
OKWIND   CLC   =C'FULL',REP+1           FULL WINDOW SPECIFIED?     LDW1
         BNE   OKWIND#                  NO, GO ON
         L     R6,MAXWIDTH              YES, SAY FULL              SDM6
         LR    R7,R6                    SAY FULL HERE TOO          SDM6
         B     WINDSAVE                 WE ARE DONE
         SPACE 2
OKWIND#  LM    R6,R7,WIDTHS             ASSUME WIND=CURR WIND      SDM6
         LR    R4,R0                    SAVE LEN OP(S)             SDM6
         LR    R5,R1                    SAVE PTR TO OPERANDS       SDM6
         SPACE 1
*
*  W<DOWN>,<UP>
*
WINDLOOP CLI   0(R5),C','               END 1ST OP?                SDM6
         LA    R5,1(,R5)                ASSUME YES                 SDM6
         BE    *+8                      RIGHT, DO 1ST
         BCT   R4,WINDLOOP              TRY TRY                    SDM6
         SPACE 1
         SR    R0,R4                    LEN 1ST                    SDM6
         BZ    WIND2                    NO 1ST, DO 2ND
         BAL   R3,WINDEXP               PARSE, R1 SET, *=0         SDM6
         LR    R6,R15                   ALL OK, SAVE FOR <DOWN>    SDM6
         SPACE 2
WIND2    LR    R0,R4                    LEN LEFT = LEN 2ND (ALMOST)SDM6
         SH    R0,=H'1'                 -1 FOR COMMA (IF ANY)
         BNP   WINDSAVE                 NO 2ND OP, LEAVE ALONE
         LR    R1,R5                    SET OP PTR FOR EXP         SDM6
         BAL   R3,WINDEXP               GO PARSE 2                 SDM6
         LR    R7,R15                   ALL OK, SAVE <UP>          SDM6
         SPACE 2
WINDSAVE STM   R6,R7,WIDTHS             SAVE THE 2 WIDTHS          SDM6
         B     NEWDSPNT
         SPACE 2
WINDEXP  XR    R15,R15                  * = 0                      LDW1
         BAL   R8,CALLEXP               PARSE & CHECK              LDW1
         BM    INVEXPER                 NEG IS BAD                 LDW1
         C     R15,MAXWIDTH             TOO BIG?                   LDW1
         BNHR  R3                       NO - RETURN                SDM6
         B     INVEXPER                 YES - COMPLAIN             LDW1
         TITLE 'ZAP --- COMMAND EXECUTION --- FLOAT'
*
*****  FLOAT
*
*  (ORIGINAL INTX SVCX 6 CODE WRITTEN BY STEVE SILVER.  MODIFIED
*   FOR ZAP USE BY JCJ AND VIC - IE:  WE DON'T UNDERSTAND)
         SPACE 1
FLOAT    LTR   R2,R0                    TEST OPERAND LENGTH        LDW1
         BP    FLOAT$                   GO USE IT                  LDW1
         LH    R15,OLDPOINT             GET CURRENT OFFSET         LDW1
         LR    R14,R15                  COPY                       LDW1
         AH    R14,=H'8'                POINT PAST END OF OPERAND  LDW1
         CH    R14,BLKLEN               IN BLOCK?                  LDW1
         BNL   INVEXPER                 NO - ERROR                 LDW1
         A     R15,ADDRBUFF             -> OPERAND                 LDW1
         MVC   TEMP(8),0(R15)           GET IN ALIGNED PLACE       LDW1
         B     FLOAT#                   CONTINUE WITH IT           LDW1
         SPACE 1
FLOAT$   BCTR  R2,0                     GET EXECUTE LENGTH         LDW1
         CH    R2,=H'15'                WAS THE OPERAND TOO LONG?
         BH    LENERROR                 YES - TELL HIM AND QUIT
         LR    R7,R1                    POINT TO THE STRING        LDW1
         LA    R1,1(,R2)                PICK UP LENGTH OF STRING
         BAL   R8,HEXCHECK              IS IT VALID HEX?
         B     OKFLOAT                  YES - SO LET'S DO IT
         LR    R1,R7                    NO - POINT TO THE ERROR
         B     INVEXPER                 AND SAY SYNTAX ERROR
         SPACE 1
OKFLOAT  EX    R2,TRFLOAT               START TRANSLATE TO REAL HEX
         PACK  TEMP(8),TEMP2+5(15)      MAKE IT HONEST-TO-GOODNESS HEX
         MVN   TEMP+7(1),TEMP2+20       GET THE LAST NIBBLE TOO
FLOAT#   LD    F0,TEMP                  LOAD IT IN FLOAT REG 0     LDW1
         LA    R7,LINE19+36             PT TO START OF SCRN RESULT AREA
         SPACE 2
*  SET THE PROGRAM MASK TO MASK OUT FIX PT OFLO, DEC OFLO,
*  EXPON UNFLO, AND SIGNIFICANCE.  SAVE IT IN R6 TO RESET IT LATER.
         SPACE 1
         XR    R2,R2                    0 R2 FOR SPM
         BALR  R6,0                     SAVE PGM MASK FOR RESTORE
         SPM   R2                       0 THE PGM MASK (NO INTERR)
         SPACE 1
         MVI   16(R7),C'0'              ASSUME ANSWER IS 0
         AD    F0,=D'0'                 NORMALIZE BY ADDING 0
         LTDR  F0,F0                    CHECK THE SIGN
         BZ    CVFCI3                   ZERO (WE'RE ALMOST DONE)
         BP    CVFC00                   PLUS - GO ON
         LPDR  F0,F0                    MINUS - MAKE IT PLUS...
         MVI   0(R7),C'-'               INSERT SIGN AND GO ON LIKE PLUS
CVFC00   LA    R7,1(R7)                 UPDATE OUTPUT PTR EITHER CASE
         CD    F0,=X'7FFFFFFFFFFFFF00'  DATA WILL CAUSE EXP OVERFLOW?
         BNH   *+8                      NO - SKIP PREVENT LOAD
         LD    F0,=X'7FFFFFFFFFFFFF00'  ELSE GET MAX ALLOWABLE
* MAX ALLOWABLE IS X'7FFFFFFFFFFFFF00'
         MD    F0,=X'4110000000000010'  MULT BY FUDGE FACTOR
         EJECT
*
*  GENERATE THE NUMBER IN D-FORMAT
*
         SPACE 2
         XR    R2,R2                    INITIALIZE EXPON REG
         LD    F4,=D'10'                SET F4 TO 10
         LD    F6,=D'1'                 SET F6 TO 1
         LD    F2,=X'401999999999999A'  SET F2 TO .1
         MVI   0(R7),C'.'               SET UP OUTPUT
         LA    R7,1(R7)                 INCREMENT LINE POINTER
         MVI   14(R7),C'D'              FORM THE OUTLINE OF EXPONENT
         MVI   15(R7),C'+'              MOVE IN EXPONENT SIGN
*  GET THE EXPONENT IN R2 (>=1)
CVFC1A   CDR   F0,F6                    SEE IF # < 1
         BL    CVFC2                    IF SO, GO TO NEXT PART
         DDR   F0,F4                    NO - DIVIDE BY 10
         LA    R2,1(R2)                 INCREMENT EXPONENT
         B     CVFC1A                   CONTINUE
*  GET THE EXPONENT (<.1)
CVFC2    CDR   F0,F2                    SEE IF >= .1
         BNL   CVFC3                    IF SO, GO TO NEXT PART
         BCTR  R2,0                     DECREMENT EXPONENT
         MDR   F0,F4                    MULT NUMBER BY 10
         B     CVFC2                    CONTINUE
*  GET EXPONENT SIGN
CVFC3    LTR   R2,R2                    SEE IF EXPONENT +
         BNM   CVFC3A                   IF SO, SKIP CODE
         LPR   R2,R2                    MAKE IT PLUS BUT.....
         MVI   15(R7),C'-'              WRITE OUT A MINUS
CVFC3A   LA    R0,10                    DIVISER FOR BELOW
         SRDL  R2,32                    SET UP FOR DIVIDE
         DR    R2,R0                    DO THE DIVIDE
         LA    R2,C'0'(R2)              GET THE EBCDIC VALUE
         LA    R3,C'0'(R3)              GET THE EBCDIC VALUE
         STC   R2,17(R7)                AND STORE IT
         STC   R3,16(R7)                AND STORE IT
         LA    R0,14                    GET NUMBER OF DIGITS FOR BCT
         LD    F6,=X'4100000000000000'  LOAD F6 WITH UN-NORMALIZER
*  GET THE MANTISSA
CVFC4    MDR   F0,F4                    MULT NUMBER BY 10
         AWR   F0,F6                    UN-NORMALIZE
         STD   F0,TEMP                  STORE RESULT
         SR    R4,R4                    ZERO FOR IC
         IC    R4,TEMP+1                GET FIRST HEX DIGIT
         SRA   R4,4                     KILL LOW NIBBLE (LAST HEX DIG)
         LA    R3,C'0'(R4)              CONVERT TO CHAR
         STC   R3,0(R7)                 MOVE RESULT TO OUTPUT
         XC    TEMP(8),TEMP             SET UP DBLW
         LA    R7,1(R7)                 POINT TO NEXT OUTPUT COL
         LTR   R4,R4                    IS R4 0?
         BZ    CVFC4#                   YES - WE HAVE NOTHING TO DO
         MVI   TEMP,X'41'               MAKE DBLW INTERNAL FLOATING PT
         SLL   R4,4                     MOVE NUMBER TO HIGH ORDR NIBBLE
         STC   R4,TEMP+1                AND MOVE IT TO DBLW
*
*  WE HAVE NOW BUILT A DBLW WHICH MAY CONTAIN D'0' THROUGH D'10'
*
         SD    F0,TEMP                  SUBTRACT THE INTEGER PART
CVFC4#   BCT   R0,CVFC4                 DO TILL END
         B     CVFCI3                   CLEAN UP AND GO AWAY
         SPACE 4
*  IF NUMBER IS ZERO TO BEGIN WITH, THERE'S NOTHING TO DO BUT.......
         SPACE 1
         MVI   16(R7),C'0'              SET UP ZERO RESULT
         SPACE 2
*  RESTORE PROGRAM MASK TO WHAT IT WAS
         SPACE 2
CVFCI3   SPM   R6                       RESET PROGRAM MASK
         SPACE 2
         MVC   LINE19+17(15),=CL15'FLOATING POINT:'
         B     NEWDSPNT                 RETURN TO CALLER
TRFLOAT  TR    TEMP2+5(0),TRHEX         <<< EXECUTED >>>           LDW1
         TITLE 'ZAP --- COMMAND EXECUTION --- DUMP, DUMPE, DUMPF'  LDW1
*
*****  DUMP, DUMPE  *****                                          LDW1
*
DUMP     BAL   R8,LOGTEST                                          LDW1
         BAL   R8,CHKPT                 SEE IF HE CAN LEAVE        LDW1
         CLI   CPUTFLAG,YESCSERR        CAN CSOUT ENQ NOW?
         BE    BADCSOUT                 NO - WHY BOTHER TO DUMP THEN?
         L     R7,=XL4'7FFFFFFF'        NUMBER OF BLOCKS TO READ (HAH)
         MVC   0(3,R13),TTR             SAVE WHERE WE ARE
         CLI   REP+4,C'E'               IS THIS REALLY DUMPE?      LDW1
         BE    PREPDMPF                 YES - DUMP FROM HERE       LDW1
         MVC   TTR(4),=XL4'00000100'    POINT TO BEGINNING OF DATASET
         B     PREPDMPF                 START DUMPING TILL END OF DS
         SPACE 3                                                   LDW1
*
*****  DUMPF  *****
*
DUMPF    BAL   R8,LOGTEST                                          LDW1
         BAL   R8,CHKPT                 SEE IF HE CAN LEAVE        LDW1
         CLI   CPUTFLAG,YESCSERR        CAN CSOUT ENQ IT TO PRINT?
         BE    BADCSOUT                 NO - SO WHY DUMP MAY I ASK?
         LH    R0,REALRDLN              GET LEN OF COMMAND
         SH    R0,=H'5'                 -5 FOR 'DUMPF' ACTUAL LEN
         BNZ   DUMPFOR                  HE GAVE AN OPERAND, PROCESS IT
JUSTDUMP LA    R7,1                     DUMP R* ONLY - R7 = # TO DUMP
         B     STARTDF                  ALL SET, START THE DUMP-FOR
         SPACE 1
*  PROCESS OPERAND OF DUMPF COMMAND (NUMBER OF BLOCKS TO DUMP)
         SPACE 1
DUMPFOR  XR    R15,R15                  LOAD *, CURRENT LOC FOR 'EXP'
         LA    R1,REP+5                 POINT TO OPERAND TO PARSE  LDW1
         BAL   R8,CALLEXP               GO PARSE                   LDW1
         BM    NOBACK                   NEG - WE CAN'T DUMP BACKWARDS
         BZ    INVEXPER                 ZERO - INVALID SYNTAX
         SPACE 1
         LR    R7,R15                   NUMBER OF BLOCKS TO DUMP
STARTDF  MVC   0(3,R13),TTR             SAVE WHERE WE ARE
PREPDMPF MVI   TTR+3,NOSEQRD            1ST BLK - READ IT BEFORE DUMP
DMPFLOOP BAL   R6,PREPDUMP              GET READY FOR THE DUMP
         BAL   R6,DUMPER                DUMP A BLOCK
         MVI   TTR+3,SEQREAD            SAY NEXT PASS, NOW READ BLK
         BCT   R7,DMPFLOOP              DO ALL THE BLOCKS HE WANTS
         SPACE 2
DUMPEND  MVC   TTR(3),0(R13)            PICK UP WHERE WE WERE
         MVI   TTR+3,NOSEQRD            DON'T PUT HIM IN NEXT BLOCK
         BAL   R8,READBLK               SO THAT HE'LL NEVER KNOW
         LA    R2,DUMPWORK              IT WORKED SO TELL HIM
         B     BOTCH                    DISPLAY (NOT REALLY A BOTCH)
         TITLE 'ZAP --- COMMAND EXECUTION --- DUMPT'
*
*****  DUMPT  *****
*
DUMPT    BAL   R8,LOGTEST                                          LDW1
         BAL   R8,CHKPT                 SEE IF HE CAN LEAVE        LDW1
         CLI   CPUTFLAG,YESCSERR        CAN CSOUT ENQ TO PRINT?
         BE    BADCSOUT                 NO - DON'T BOTHER WITH DUMP
         LH    R0,REALRDLN              GET LEN OF READ
         SH    R0,=H'5'                 -5 FOR 'DUMPT' ACTUAL LEN
         BZ    JUSTDUMP                 NO OPERAND, JUST DUMP THIS BLK
         SPACE 1
*  PARSE OUT THE TTR OPERAND OF THE DUMPT COMMAND
         SPACE 1
         LA    R1,REP+5                 POINT TO THE OPERAND       LDW1
         BAL   R6,TTRPARSE              GO PARSE (USE POINT'S RTN) LDW1
         CLC   TEMP+1(3),TTR            RESULT (TEMP+1) < CURRENT TTR?
         BNL   OKDUMPT                  NO - HIS WISH IS MY COMMAND
NOBACK   LA    R2,BACKDUMP              YES - WE CAN'T DUMP BACKWARDS
         B     BOTCH                    WHAT DOES HE THINK WE ARE?
         SPACE 1
OKDUMPT  MVC   STOPDUMP(3),TEMP+1       TTR TO STOP AT
         MVC   0(3,R13),TTR             SAVE WHERE WE ARE
         SPACE 1
         MVI   TTR+3,NOSEQRD            1ST BLK - READ 1ST BLK FOR DUMP
DMPTLOOP BAL   R6,PREPDUMP              NO - SO PREPARE TO DUMP
         BAL   R6,DUMPER                AND DUMP WHAT WE HAVE
         MVI   TTR+3,SEQREAD            NOW WE CAN READ SEQ BLKS
         CLC   TTR(3),STOPDUMP          ARE WE THERE OR PAST YET?
         BNL   DUMPEND                  YES - WE ARE ALL DONE THEN
         B     DMPTLOOP                 GO TILL WE ARE AT HIS TTR
         TITLE 'ZAP --- COMMAND EXECUTION --- WHATMEM'             LDW1
*
*****  WHATMEM  *****
*
WHATMEM  BAL   R8,CHKPT                 SEE IF HE CAN LEAVE        LDW1
         CLI   DSORG,DSORGPO            IS IT PARTITIONED?         LDW1
         LA    R2,NOMCOM                GET MSG ADDR IN CASE       LDW1
         BNE   BOTCH                    NO - ERROR                 LDW1
         MVC   0(3,R13),TTR             SAVE CURRENT TTR           LDW1
         XC    STOPDUMP(3),STOPDUMP     SAVE CLOSEST TTR HERE      LDW1
         XC    TTR(3),TTR               START AT BEGINNING OF DIR  LDW1
         SPACE 1
WHATLOOP BAL   R8,READNBLK              GET NEXT DIRECTORY BLOCK   LDW1
         CLI   IOERROR,YESSYN           DID IT WORK?               LDW1
         BE    NEWDSPNT                 NO - ABORT                 LDW1
         L     R3,ADDRDATA              -> BUFFER                  LDW1
         LH    R2,0(,R3)                BLK LEN USED               LDW1
         LA    R3,2(,R3)                -> REAL BEGIN LOC          LDW1
         BCTR  R2,0                     -1                         LDW1
         BCTR  R2,0                     AND -2 FOR REAL LEN USED   LDW1
         SPACE 1
WMLOOP2  CLC   0(4,R3),=XL4'FFFFFFFF'   END OF DIRECTORY?          LDW1
         BE    WMEND                    YES                        LDW1
         CLC   8(3,R3),0(R13)           THIS MEM PAST CURRENT LOC? LDW1
         BH    WMNEXT                   YES - TRY NEXT             LDW1
         CLC   8(3,R3),STOPDUMP         NO - HIGHER THAN PREVIOUS? LDW1
         BL    WMNEXT                   NO - PREVIOUS IS CLOSER    LDW1
         MVC   STOPDUMP(3),8(R3)        SAVE THIS TTR              LDW1
         MVC   LINE19+35(8),0(R3)       SAVE MEMBER NAME           LDW1
         SPACE 1
WMNEXT   BAL   R8,NXTDIRNT              INCR TO NEXT ENTRY         LDW1
         BP    WMLOOP2                  CHECK NEXT                 LDW1
         B     WHATLOOP                 GET ANOTHER DIR BLK        LDW1
         SPACE 1
WMEND    MVC   TTR(3),0(R13)            RESTORE WHERE HE WAS       LDW1
         OC    STOPDUMP(3),STOPDUMP     DID I FIND ANYTHING?       LDW1
         BNZ   WMENDOK                  YES - DISPLAY IT           LDW1
         MVC   LINE19,BLANKS            RESET THE LINE             LDW1
         BAL   R8,SETMSG                MOVE IN MSG                LDW1
         DC    Y(NOMEMFND-ZAP)          'NONE FOUND'               LDW1
         B     WMDONE                   SKIP OTHER                 LDW1
         SPACE 1
WMENDOK  MVC   LINE19+17(17),=C'CLOSEST MEMBER IS'                 LDW1
         MVC   LINE19+44(6),=C'AT TTR'                             LDW1
         HEX   LINE19+51,STOPDUMP,LEN=3 GIVE HIM THE START         LDW1
         SPACE 1
WMDONE   BAL   R8,READBLK               PUT HIM BACK WHERE HE WAS  LDW1
         B     NEWDSPNT                 AND GO DISPLAY             LDW1
*  SEE NOTE AT END OF MLOOP2 (NEXT PAGE)                           LDW1
         TITLE 'ZAP --- COMMAND EXECUTION --- M'
*
*****  M  *****
*
MEMBER#  BAL   R8,CHKPT                 NEED ZAP?
         CLI   DSORG,DSORGPO            IS IT PARTITIONED?
         LA    R2,NOMCOM                -> MSG IN CASE
         BNE   BOTCH                    THE DATASET ISNT PARTITIONED
         MVC   0(3,R13),TTR             SAVE TTR IN CASE NO FIND
         LTR   R0,R0                    TEST OPERAND LENGTH        LDW1
         BNP   JUSTM                    NONE - USE LAST MEM        LDW1
         MVC   MEMBER(8),REP+1          MOVE MEMBER TO FIELD       LDW1
         XC    TTR(3),TTR               POINT TO BEGINNING OF DIRECT -1
*
*  FIND THE MEMBER IN THE DIRECTORY
*
*  READ A DIRECTORY BLOCK
*
MLOOP    BAL   R8,READNBLK              GET NEXT BLK               LDW1
         CLI   IOERROR,YESSYN           I/O ERROR?
         BE    NEWDSPNT                 YES - GET OUT
         L     R3,ADDRKEY               GET BUFFER PTR             LDW1
         CLC   MEMBER,0(R3)             IN THIS BLOCK?             LDW1
         BH    MLOOP                    NO - GET NEXT              LDW1
         LH    R2,8+0(,R3)              GET BLK LEN USED           LDW1
         BCTR  R2,0                     -1
         BCTR  R2,0                     AND -2 FOR REAL LEN USED
         LA    R3,8+2(,R3)              POINT TO REAL BEGIN LOC    LDW1
*
*  MEMBER SCAN LOOP WITHIN BLK
*
MLOOP2   CLC   0(4,R3),=XL4'FFFFFFFF'   END OF DIRECTORY?
         BNE   NOTEND                   NO - THERE'S MORE TO LOOK
MNF      MVC   TTR(3),0(R13)            PICK UP WHERE HE WAS
         BAL   R8,SETMSG                MOVE MSG TO RIGHT PLACE    LDW1
         DC    Y(INVMEM-ZAP)            SAY INV MEMBER (NOT FOUND) LDW1
         BAL   R8,READBLK               PUT HIM BACK WHERE HE WAS
         B     NEWDSPNT                 AND GO DISPLAY
*
*  NOTE:  READBLK WILL RETURN ONLY IF THE USER IS NOT AT AN EOF
*         IF EOF, SYNAD==>EODAD==>DISPLAY GET EXECUTED, SO THE
*         MESSAGE MUST BE PRE-SET
*
NOTEND   CLC   0(8,R3),MEMBER           MEMBER HERE?
         BE    FOUNDM                   YES - GO WORK ON IT
         BH    MNF                      IF PAST ALPHA SEQ GIVE UP *PCN*
         BAL   R8,NXTDIRNT              INCR TO NEXT ENTRY         LDW1
         BNP   MLOOP                    NEG - END BLK - READ ANOTHER
         B     MLOOP2                   MORE TO GO - KEEP LOOKING
         SPACE 1                                                   MAS2
FOUNDM   MVC   TTR(3),8(R3)             PICK UP MEMBER'S TTR
         MVC   MEMTTR(3),8(R3)          SAVE IT FOR LATER USE
         MVC   ESDID,=H'1'              RESET ESDID TO DEFAULT      *N*
         MVI   IDRFLAG,NOCHGIDR         HAVEN'T CHANGED IDR YET   *LPR*
         XC    TXTTTR(3),TXTTTR         ASSUME NOT A LOAD MOD       *N*
         XC    CTL1TTR(3),CTL1TTR        NO 1ST CTL REC YET        MAS2
         MVC   8(1,R13),11(R3)          FLAGS/LEN FROM DIR ENTRY   MAS2
         NI    8(R13),B'01100000'       # TTR'S IN USER DATA FILED MAS2
         CLI   8(R13),B'00100000'       AT LEAST ONE USER TTR?     MAS2
         BL    FOUNDM1                  BIF NOT LOAD MODULE        MAS2
         MVC   8(1,R13),11(R3)          FLAGS/LEN FROM DIR ENTRY   MAS2
         NI    8(R13),B'00011111'       # H-WORDS USER DATA        MAS2
         CLI   8(R13),12                AT LEAST 12 H-WORDS?       MAS2
         BL    FOUNDM1                  BIF NOT LOAD MODULE        MAS2
         CLI   DCBRECFM-IHADCB+DCBU,RECFMU  A LOAD MODULE?          *N*
         BNE   FOUNDM1                  NO, NO TEXT THEN            *N*
         MVC   TXTTTR(3),12(R3)         YES, SAVE 1ST TEXT BLK TTR  *N*
FOUNDM1  LA    R1,N0                    POINT TO PROPER NUMBER
         BAL   R8,SETLINE               SET UP LINE TO PUT
         B     NEW$READ                 NOT PRINTING, EXIT
         MVI   0(R2),C'0'               DOUBLE SPACE IT
         MVC   20(24,R2),=C'MEMBER XXXXXXXX SELECTED'
         MVC   27(8,R2),MEMBER          FILL IN THE MEMBER IN QUESTION
         BAL   R8,CPUT                  NOW DUMP THE LINE OUT
         B     NEW$READ                 GO DO IT
         SPACE 3                                                   LDW1
JUSTM    MVC   TTR(3),MEMTTR            RESTORE START OF MEMBER    LDW1
         B     NEW$READ                 GET IT                     LDW1
         SPACE 3
NXTDIRNT IC    R4,11(,R3)               GET INDICATORS             LDW1
         N     R4,=X'0000001F'          JUST # USER DATA HALFWORDS LDW1
         LA    R4,12(R4,R4)             ENTRY LENGTH               LDW1
         AR    R3,R4                    -> NEXT ENTRY              LDW1
         SR    R2,R4                    DECR LENGTH REMAINING      LDW1
         BR    R8                       RETURN WITH CC SET         LDW1
         TITLE 'ZAP --- COMMAND EXECUTION --- NAME'                 *N*
*                                                                   *N*
*****  NAME  *****                                                  *N*
*                                                                   *N*
NAME#    BAL   R8,CHKPT                 NEED CHKPT?                 *N*
         OC    TXTTTR(3),TXTTTR         IS THERE ANY TEXT?          *N*
         BZ    NAMENFN#                 NO, CAN'T HAVE ESD'S THEN   *N*
         SPACE 1
         MVC   NAME(8),MEMBER           ASSUME CSECT IS MODULE    *LPR*
         LTR   R0,R0                    IS THERE AN ARGUMENT?      LDW1
         BNP   *+10                     NO - OK THEN               LDW1
         MVC   NAME(8),0(R1)            MOVE NAME TO FIELD         LDW1
         MVI   FLAGESD,0                NO FLAGS YET                *N*
         SPACE 2
*                                                                   *N*
*  FIND THE ESD'S FIRST                                             *N*
*                                                                   *N*
         MVC   0(3,R13),TTR             REMEMBER WHERE WE ARE NOW   *N*
         MVC   TTR(3),MEMTTR            START LOOKING AT BEGIN MEMB *N*
         BAL   R8,READBLK               GET 1ST BLK                 *N*
         SPACE 1
NAMEFIND L     R1,ADDRDATA              POINT TO RECORD            LDW1
         TM    0(R1),X'01'              CONTROL REC?                *N*
         BNO   NAMECHKE                 NO, POSSIBLE ESD OR SYM     *N*
NAMENFND CLC   TTR(3),0(R13)            NOT FOUND. HAVE WE MOVED?   *N*
         BE    NAMENFN#                 NO, NO RE-POSITION NECESSRY *N*
         MVI   TTR+3,NOSEQRD            YES, NO SEQUENTIAL READ     *N*
         MVC   TTR(3),0(R13)            RESET WHERE WE WERE         *N*
         BAL   R8,READBLK               PUT US BACK                 *N*
NAMENFN# LA    R2,NAMEMNF               'INVALID' MSG               *N*
         B     BOTCH                    OH WELL                     *N*
         SPACE 1
NAMECHKE CLI   0(R1),X'20'              ESD?                        *N*
         BE    NAMEESD                  YES, HAVE ONE, TRY IT       *N*
NAMEENXT MVI   EOFRET,NOEOF             EOF'S ARE DATA NOW          *N*
         BAL   R8,READNBLK              GET NEXT BLK               LDW1
         CLC   LINE05+27(20),EOFMSG     HIT EOF HERE?              LDW1
         BE    NAMENFND                 YES, NOT FOUND              *N*
         CLI   IOERROR,YESSYN           I/O ERROR                   *N*
         BE    NAMENFND                 YES, NOT FOUND              *N*
         B     NAMEFIND                 NONE, KEEP LOOKING          *N*
         SPACE 1
NAMEESD  LH    R15,6(,R1)               GET LEN ESD DATA THIS BLK   *N*
         LA    R1,8(,R1)                PT PAST ESD PREFIX TO DATA  *N*
         AR    R15,R1                   PT PAST LAST ESD DATA       *N*
         USING ESDDATA,R1               ESD ENTRIES                 *N*
         SPACE 1                                                   LDW1
NAMECHK  CR    R1,R15                   PAST END THIS BLK?          *N*
         BNL   NAMEENXT                 YES, NEXT ESD BLK           *N*
         CLC   ESDDNAME(8),NAME         NO, NAME MATCH?             *N*
         BE    NAMEGOT                  YES, WE MIGHT HAVE IT       *N*
NAMEBNXT LA    R1,ESDDL(,R1)            NEXT ENTRY IN BLK           *N*
         B     NAMECHK                  KEEP SCANNING BLK           *N*
         SPACE 2
*                                                                   *N*
*  THE ENTRY POINT EXISTS.  FIND THE PLACE IN THE MODULE TEXT.      *N*
*                                                                   *N*
NAMEGOT  NI    ESDDTYPE,255-X'F0'       JUST WANT LOW NIBBLE        *N*
         CLI   ESDDTYPE,X'02'           EXT REF ENTRY  (ER)?        *N*
         BE    NAMEBNXT                 YES, IGNORE, NEXT ENTRY     *N*
         CLI   ESDDTYPE,X'0A'           WEAK EXT REF?  (WEX)?       *N*
         BE    NAMEBNXT                 YES, IGNORE, NEXT ENTRY     *N*
         L     R3,ESDDADDR-1            NO, GET LKED ADDR OF EP     *N*
         LA    R3,0(,R3)                GET RID OF TYPE BYTE        *N*
         DROP  R1                       NO MORE ENTRIES             *N*
         SPACE 1
         L     R15,ADDRDATA             PT TO ESD BLK PREFIX       LDW1
         LH    R14,4(,R15)              GET ESDID 1ST NTRY THIS BLK *N*
         LA    R15,8(,R15)              PT PAST PRFX TO 1ST ENTRY   *N*
         SR    R1,R15                   OFFSET MTHC ENTRY FROM PRFX *N*
         XR    R0,R0                    FOR DIVIDE                  *N*
         D     R0,=A(ESDDL)             GET ESDID REL THIS BLK      *N*
         AR    R1,R14                   GET ESDID MATCH ENTRY POINT *N*
         STH   R1,ESDID                 SAVE FOR IDR UPDATE         *N*
         MVI   TTR+3,NOSEQRD            NO MORE SEQ READ            *N*
         MVC   TTR(3),CTL1TTR           START AT 1ST CTL RECORD    MAS2
         OC    TTR(3),TTR               ANY 1ST CTL TTR?           MAS2
         BNZ   *+10                     BIF HAVE TTR 1ST CTL REC   MAS2
         MVC   TTR(3),MEMTTR            ELSE START AT MEMBER       MAS2
         BAL   R8,READBLK               GET ESD, CTL, IDR RECORD   MAS2
         NI    FLAGESD,255-FESDTEXT     NEXT BLK IS NOT TEXT       MAS2
         SPACE 1
NAME$L1  TM    FLAGESD,FESDTEXT         IS THIS TEXT BLOCK?        MAS2
         BO    NAME$T1                  BIF IS TEXT RECORD         MAS2
         L     R1,ADDRDATA              @ NON-TEXT RECORD          MAS2
         TM    0(R1),X'01'              CONTROL RECORD?            MAS2
         BZ    NAME$NX                  BIF NOT CTL REC, TRY NXT   MAS2
         OI    FLAGESD,FESDTEXT         NEXT BLK IS TEXT           MAS2
         OC    CTL1TTR(3),CTL1TTR       HAVE SAVED 1ST CTL TTR?    MAS2
         BNZ   *+10                                                MAS2
         MVC   CTL1TTR(3),TTR           SAVE TTR 1ST CTL REC       MAS2
         MVC   TXTORIG(4),8(R1)         LKED ORIG NXT BLK (TEXT)   MAS2
         MVI   TXTORIG,0                CLEAR HIGH BYTE            MAS2
         SPACE 1
NAME$NX  MVI   EOFRET,NOEOF             EOF'S ARE DATA              *N*
         BAL   R8,READNBLK              GET NEXT LOADMOD BLK       LDW1
         CLC   LINE05+27(20),EOFMSG     EOF?                       LDW1
         BE    NAMENFND                 OOPS, CAN'T HAPPEN          *N*
         B     NAME$L1                  CONTINUE SEARCH            MAS2
         SPACE 1
NAME$T1  NI    FLAGESD,255-FESDTEXT     NEXT BLK IS NOT TEXT       MAS2
         LR    R0,R3                    COPY ENTRY ORIGIN          MAS2
         S     R0,TXTORIG               ENTRY - TXT BLOCK ORIG     MAS2
         BM    NAME$NX                  BIF NOT IN NEXT TXT BLK    MAS2
         CH    R0,BLKLEN                OFFSET IN BLOCK :: BLKLEN  MAS2
         BNL   NAME$NX                  BIF NOT IN NEXT TXT BLK    MAS2
         SPACE 12                                                  LDW1
*                                                                   *N*
*  WE HAVE THE BLOCK AND OFFSET OF THE ENTRY POINT. NOTIFY/DISPLAY  *N*
*                                                                   *N*
         MVI   TTR+3,NOSEQRD            NO MORE SEQ READS          MAS2
         LR    R3,R0                    OFFSET INTO BLOCK           *N*
         LA    R1,N8                    MSG/WTO                     *N*
         BAL   R8,SETLINE               SET IT UP                   *N*
         B     NAMEDONE                 NOT PRINTING                *N*
         MVI   0(R2),C'0'               DBL SPACE                   *N*
         MVC   20(24,R2),=C'MEMBER XXXXXXXX SELECTED'  FOR SPACE    *N*
         MVC   20(6,R2),=CL6'ENTRY'     MEMBER=ENTRY                *N*
         MVC   27(8,R2),NAME            MOVE ENTRY NAME IN          *N*
         BAL   R8,CPUT                  DO IT                       *N*
         SPACE 1
NAMEDONE LR    R15,R3                   GET OFFSET INTO BLOCK       *N*
         MVI   IDRFLAG,NOCHGIDR         HAVEN'T CHANGED IDR YET    LDW1
         B     SETPOINT                 SIMULATE A '+' COMMAND      *N*
         AIF   (&MVS).MVS06                                        LDW1
         TITLE 'ZAP --- COMMAND EXECUTION --- NN'
*
*****  NN  *****
*
NN       BAL   R8,CHKPT                 NEED ZAP?
         CLC   =C'SYS1.SYSJOBQE',DSNAME ARE WE IN RIGHT DSN (JOBQ)?
         LA    R2,NOTJQMSG              POINT TO MESSAGE IN CASE
         BNE   BOTCH                    NO - EXIT TO DISPLAY       LDW1
*LDW1    LH    R0,REALRDLN              GET LEN OF COMMAND
*LDW1    SH    R0,=H'2'                 -2 FOR 'NN'
         XR    R15,R15                  '*'=0
*LDW1    LA    R1,TEMP2+2               PT TO EXPRESSION
*LDW1    BAL   R14,EXP                  GO PARSE
         BAL   R8,CALLEXP               PARSE & CHECK              LDW1
*LDW1    LTR   R1,R1                    DID IT WORK?
*LDW1    BNM   INVEXPER                 NO - SAY SYNTAX ERROR
*
*  WE HAVE AN 'NN' VALUE IN R15.  BEGIN ALGORITHM TO FIND TTR OF
*  JOB
*
         USING QMRCAR,R3
*LPR*    L     R3,CVTPTR                PICK UP CVT PTR
*LPR*    L     R3,CVTJOB-CVT(R3)        PT TO QMANAGER WORK AREA
         LA    R3,JQQMHDA-QMHDA+QMRCAR  PT TO QMANAGER WORK AREA  *LPR*
         LR    R1,R15                   SAVE NN VAL
         SH    R1,QMFQR                 REL 'NN' OF FIRST JOB Q RECRD
         BNM   POSNN                    IF NOT ON MIXED TRK, CONTINUE
         LH    R0,QMKTT                 GET 'TT' OF FIRST NON-MIXED
         BCTR  R0,0                     FIND MIXED TRACK
         STH   R0,TTR                   SAVE IT IN TTR
         AH    R15,QMNHM                NUM OF HANDLES (QCRS) IN MIX
         STC   R15,TTR+2                THAT'S THE REC
         B     NEW$READ                 GO DISPLAY IT FOR HIM
*
POSNN    XR    R0,R0                    CLEAR REM REG
         LH    R14,QMRPT                GET RECS/TRACK
         DR    R0,R14                   GET NUMBER OF TRACKS
         AH    R1,QMKTT                 ADD MIXED TRKS TO THAT
         AH    R0,=H'1'                 ADJUST REC FOR OFFSET
         STH   R1,TTR                   SAVE TT
         STC   R0,TTR+2                 SAVE REC
         B     NEW$READ                 GO DISPLAY
         DROP  R3
.MVS06   TITLE 'ZAP --- COMMAND EXECUTION --- NOTE, EJECT'         MAS2
*
*****  NOTE  *****
*
NOTE     BAL   R8,LOGTEST                                          LDW1
         OI    FLAGS2,NOWHEREF          SUPRESS WHERE LINES
         L     R2,CSOUTWK               FIND WORKAREA
         LTR   R2,R2                    ANY THERE?
         BZ    BADCSOUT                 NO - TELL HIM SORRY        LDW1
         L     R2,0(,R2)                FIND THE NEXT LINE IMAGE
         MVC   1($L-4,R2),REP+4         COPY NOTATION TO BUFFER    LDW1
         MVI   ENQIT,255                FORCE IT TO BE ENQUEUED
         MVI   0(R2),C'0'               DOUBLE SPACE NOTES
         BAL   R8,CPUT                  DUMP THIS LINE NOW
         B     NEWDSPNT                 THEN CONTINUE ON MERRY WAY
         SPACE 2
BADCSOUT LA    R2,NOCSOUT               TELL HIM CAN'T ENQ
         B     BOTCH                    BYE
         SPACE 5                                                   LDW1
*
*****  EJECT  *****
*
EJECT    BAL   R8,LOGTEST                                          LDW1
         OI    FLAGS2,NOWHEREF          SUPRESS WHERE LINES
         L     R2,CSOUTWK               GET THE WORKAREA PTR
         LTR   R2,R2                    IS THERE ONE?
         BZ    BADCSOUT                 NO - GIVE UP ON THIS ENDEAVOR
         L     R2,0(R2)                 FIND THE NEXT LINE IMAGE
         MVI   0(R2),C'1'               PAGE EJECT
         MVI   ENQIT,255                FORCE ENQ TO PRINT
         BAL   R8,CPUT                  DO IT
         B     NEWDSPNT                 ALL DONE
         TITLE 'ZAP --- UTILITY BAL ROUTINES'
*  ROUTINES INCLUDE:
*
*  CLEAR........CLEAR SCREEN
*  READBLK......GET A DATA BLOCK
*  CALLEXP......CALL EXP TO PARSE EXPR, CHECK ERROR RETURNS        LDW1
*  HEXCHECK.....VALIDITY CHECK HEX
*  GETSTRNG.....VALIDITY CHECK AND PARSE HEX/CHAR STRING
*  NUMCONV......CONVERT A NUMBER TO HEX AND SIGNED DECIMAL         LDW1
*  CSIO.........PRIMARY SCREEN DISPLAY
*  CSIO#........SECONDARY SCREEN DISPLAY
*  PUTLINE......PUTLINE 1 LINE TO TERMINAL                         LDW1
*  TTRPARSE.....PARSE OUT SPECIFIED TTR
*  PREPDUMP.....PREPARE FOR DUMP - GET BLOCK, PRINT HEADER LINE
*  DUMPER.......DUMP A BLOCK IN DUMP FORMAT
*  CLEARDEF.....RESET DEFINE TABLE
*  CLOSE........CLOSE DATASET
*  WRITE........EXCP WRITE OUT A BLK
*  OPENMSG......GIVE PRINT FILE MSG OF DATASET OPEN
*  CPUT.........ENQ TO PRINT AN OUTPUT LINE
*  SETLINE......SET UP THE OUTPUT LINE FOR CPU
*  SETSTRNG.....CONVERT VARIOUS CONSTANTS FOR CPUT
*  SETMSG.......MOVE INFO MSG TO CORRECT PLACE ON SCREEN           LDW1
*  BOTCH........DISPLAY ERROR MESSAGES
*  EODAD........END OF FILE EXIT (SYNAD)
*  CHKPT........CHECK IF ZAP NEEDED.  IF SO IGNORE COMMAND PENDING
*  INIT3270.....TURN ON  3270 MODE CONSOLE I/O                     LDW1
*  KILL3270.....TURN OFF 3270 MODE CONSOLE I/O                     LDW1
         SPACE 5
**********************************************************************
********************************  CLEAR  *****************************
**********************************************************************
         SPACE 1
*  CLEAR THE SCREEN BUFFER EXCEPT FOR ERROR AND I/O ERROR LINES
         SPACE 1
CLEAR    LA    R15,LINE01-2             -> START                   SDM5
         LA    R0,3                     NUMBER OF LINES            SDM5
         BAL   R14,CLEARX               CLEAR 1-3                  SDM5
         LA    R15,LINE06-2             -> START                   LDW1
         LA    R0,13                    NUMBER OF LINES            LDW1
         BAL   R14,CLEARX               CLEAR 6-18                 LDW1
         LA    R15,LINE20-2             -> START                   LDW1
         LA    R0,2                     NUMBER OF LINES            LDW1
         BAL   R14,CLEARX               CLEAR 20-21                LDW1
         MVI   LINE02-1,X'C8'           UNPROT HIGH                LDW1
         XC    LINE02,LINE02            NULLS FOR THIS ONE         SDM5
         MVC   LINE05-2(2),=X'1DE8'     I/O ERRMSG LINE (PROT HIGH)SDM5
         MVC   LINE19-2(2),=X'1DE8'     AND OTHER ERRMSG LINE      SDM5
         MVC   REP-2(2),LINE02-2        UNPROT HIGH                LDW1
         BR    R8                       RETURN TO CALLER
         SPACE 2
*  X... ....  SET TO MAKE VALID CHAR                               LDW1
*  .1.. ....  MUST BE 1                                            LDW1
*  ..1. ....  PROT                                                 LDW1
*  ...1 ....  NUMERIC                                              LDW1
*  ..11 ....  AUTOSKIP                                             LDW1
*  .... 00..  DISPLAY / NOT SELECTOR PEN DETECTABLE                LDW1
*  .... 01..  DISPLAY / DETECTABLE                                 LDW1
*  .... 10..  HIGH INTENSITY / DETECTABLE                          LDW1
*  .... 11..  NO DISPLAY / NOT DETECTABLE                          LDW1
*  .... ..0.  MUST BE 0                                            LDW1
*  .... ...1  MDT FLAG                                             LDW1
         SPACE 1
CLEARX   MVC   0(2,R15),=X'1D60'        PROT AUTOSKIP LOW          LDW1
         MVC   2($L,R15),BLANKS         BLANK THE LINE             LDW1
         LA    R15,$I(,R15)             -> NEXT LINE               LDW1
         BCT   R0,CLEARX                CONTINUE                   LDW1
         BR    R14                      DONE THIS SECTION          LDW1
         SPACE 5
**********************************************************************
********************************  READBLK  ***************************
**********************************************************************
         SPACE 3
*  EXCP READ A BLOCK (PHYSICAL RECORD) INCLUDING KEY (IF ANY).
*  IF TTR+3 CONTAINS A 1 (FLAG) THEN READ SEQUENTIALLY, SIMULATING
*  BSAM
         SPACE 1
READNBLK MVI   TTR+3,SEQREAD            SET NEXT BLOCK FLAG        LDW1
READBLK  NI    FLAGS2,255-ATTNHIT       NO ATTN YET                LDW1
READBLK2 MVI   IOERROR,NOSYN            START WITH NO I/O ERROR
         ST    R8,DBLW                  SAVE RETURN ADDR           LDW1
         BAL   R8,CHKPT                 SEE IF HE CAN LEAVE        LDW1
         CLI   TTR+3,SEQREAD            DO BLOCK +1?
         BNE   READBLK#                 NO
         IC    R15,TTR+2                GET RECORD NO
         LA    R15,1(R15)               NEXT RECORD
         STC   R15,TTR+2                NEXT ONE
         SPACE 1
READBLK# MVC   LINE05,BLANKS            CLEAR I/O ERR MSG IF ANY   LDW1
         CLI   CHNGED,0                 BUFFER TAMPERED WITH W/O CHKPT?
         BE    NORDBMSG                 NO, ITS OK TO READ THEN
         MVI   CHNGED,0                 WELL IT'LL BE CLEAN NOW
         NI    FLAGS2,255-MUSTZAP       NEW BLOCK, NO ZAP NEEDED YET
         LA    R1,N4                    MSG NUMBER
*LDW1    ST    R8,DBLW                  SAVE FOR LATER
         BAL   R8,SETLINE               SETUP THE LINE
         B     NORDBMSG                 NOT PRINTING               LDW1
         MVC   31(18,R2),=C'BLOCK NOT REPLACED'
         MVI   0(R2),C'0'               DOUBLE SPACE
         HEX   (24,R2),OLDTTR,LEN=3     DIFF TTR THIS TIME         LDW1
         BAL   R8,CPUT                  DUMP THE LINE
NORDBMSG L     R8,DBLW                  RESTORE RET REG            LDW1
         XC    BLKLEN(2),BLKLEN         ASSUME NOTHING READ        LDW1
         LA    R15,CCW##R               -> CCW CHAIN               LDW1
         CLI   TTR+2,0                  R0?                        LDW1
         BNE   *+8                      NO - OK                    LDW1
         LA    R15,CCW##R0              READ R0                    LDW1
         ST    R15,IOBCCWA              SET IN IOB                 LDW1
         SPACE 1                                                   LDW1
         L     R0,TTR                   GIVE HIM THE TTRN          LDW1
         N     R0,=X'FFFFFF00'          MAKE IT A TTRN             LDW1
         L     R1,DCBDEBAD+DCBU-IHADCB  GIVE HIM THE DEB           LDW1
         LA    R2,MBBCCHHR              GIVE HIM A WORKAREA FOR IT LDW1
         STM   R8,R12,52(R13)           SAVE SOME REGISTERS        LDW1
         LR    R8,R13                   SAVE PTR TO SAVEAREA       LDW1
         L     R15,CVTPTR               CVT PTR                    LDW1
         L     R15,CVTPCNVT-CVT(,R15)   POINT TO THE ROUTINE       LDW1
         BALR  R14,R15                  GO DO IT                   LDW1
         LR    R13,R8                   RESTORE PTR TO SAVE AREA   LDW1
         LM    R8,R12,52(R13)           RESTORE THE DEAD REGS      LDW1
         LTR   R15,R15                  OUT OF DS?                 LDW1
         BNZ   EXCP42                   YES - DON'T BOTHER READING LDW1
         IC    R1,CCHHR+4               GET "R"                    LDW1
         BCTR  R1,0                     -1 FOR SEARCH ID           LDW1
         STC   R1,CCHHR+4               SET BACK                   LDW1
         SPACE 1
         EXCP  IOB                                                 LDW1
         SPACE 1
         WAIT  ECB=ECB                                             LDW1
         SPACE 1
         MVC   CCHHR+4(1),TTR+2         RESTORE "R"                LDW1
         LH    R2,BUFFSIZE              GET BUFSIZ (MAX READ=BLKSI)LDW1
         SH    R2,CSW+6                 =AMOUNT READ               LDW1
         LR    R0,R2                    COPY 8+KL+DL               LDW1
         SH    R0,=H'8'                 GET KEYLEN+DATALEN         LDW1
         STH   R0,CCW#W#W+6             SAVE IT FOR LATER USE      LDW1
         L     R1,ADDRCNT               -> COUNT                   LDW1
         MVC   KEYLEN+1(1),5(R1)        SET UP KEYLEN              LDW1
         LH    R15,KEYLEN               GET KEYLEN                 LDW1
         LA    R0,8(R1,R15)             -> DATA                    LDW1
         ST    R0,ADDRDATA              SET ADDR OF DATA           LDW1
         CLC   ADDRBUFF,ADDRKEY         HOW MUCH DO WE DISPLAY?    LDW1
         BL    SAVE$LEN                 COUNT + KEY + DATA         LDW1
         BE    *+6                      KEY + DATA                 LDW1
         SR    R2,R15                   JUST DATA                  LDW1
         SH    R2,=H'8'                 NOT COUNT FIELD            LDW1
         SPACE 1
SAVE$LEN STH   R2,BLKLEN                SAVE IT FINALLY            LDW1
         SPACE 1
*  NOW CHECK THE READ, FINALLY...                                  LDW1
         CLI   ECB,X'7F'                OK?                        LDW1
         BE    EXCPOK                                              LDW1
         CLI   ECB,X'42'                END OF EXTENT              LDW1
         BE    EXCP42                                              LDW1
         CLI   ECB,X'41'                PERM ERROR?                LDW1
         BE    EXCP41                                              LDW1
         SPACE 1                                                   LDW1
REALERR  LA    R1,=CL15' TYPE UNKNOWN  '  GET MSG ADDR             LDW1
         SPACE 1                                                   LDW1
EXCPERR  SR    R0,R0                    GET A ZERO                 LDW1
         STH   R0,BLKLEN                NOTHING WAS READ           LDW1
         STH   R0,CCW#W#W+6             AND NOTHING TO WRITE.      LDW1
EXCPERR$ MVI   IOERROR,YESSYN           AND IT WAS IN ERROR        LDW1
         MVC   LINE05+17(40),IOERRMSG   MOVE IN MASK               LDW1
         MVC   LINE05+35(15),0(R1)      MOVE IN ERROR MSG          LDW1
         MVI   TTR+3,NOSEQRD            TURN OFF SEQ READ FLAG     LDW1
         BR    R8                                                  LDW1
         SPACE 2                                                   LDW1
EXCP42   LA    R1,=CL15'NOT IN DATA SET'  GET MSG ADDR             LDW1
         B     EXCPERR                                             LDW1
         SPACE 2                                                   LDW1
EXCP41   TM    CSW+4,X'01'              UNIT EXCEPTION?            LDW1
         BO    EODAD                    YES - EOF                  LDW1
         TM    IOB+3,X'08'              NRF?                       LDW1
         BNO   NOT$NRF                  NO                         LDW1
         SPACE 1
EXCP$NRF CLI   TTR+3,SEQREAD            NEXT BLOCK REQ?            LDW1
         LA    R1,=CL15'NO RECORD FOUND'  GET MSG ADDR IN CASE     LDW1
         BNE   EXCPERR                                             LDW1
         LH    R15,TTR                  GET TRACK                  LDW1
         LA    R15,1(,R15)              NEXT TRACK                 LDW1
         STH   R15,TTR                  SAVE IT                    LDW1
         MVI   TTR+2,1                  RECORD 1                   LDW1
         MVI   TTR+3,NOSEQRD            RESET SEQ READ FLAG        LDW1
         B     READBLK2                 GO REREAD                  LDW1
         SPACE 2
NOT$NRF  TM    CSW+5,X'40'              INCORRECT LENGTH?          LDW1
         BNO   REALERR                  NO - SOMETHING ELSE        LDW1
         LA    R1,=CL15'INCORR. LENGTH '  GET MSG ADDR             LDW1
         B     EXCPERR                  GO SAY INCORRECT LENGTH    LDW1
         SPACE 2                                                   LDW1
EXCPOK   L     R15,ADDRCNT              -> COUNT                   LDW1
         CLC   CCHHR(5),0(R15)          RIGHT RECORD?              LDW1
         BE    EXCPOK$                  YES - CONTINUE             LDW1
         LA    R1,=CL15'CCHHR INCORRECT'  GET MSG ADDR IN CASE     LDW1
         CLC   CCHHR(4),0(R15)          RIGHT CCHH?                LDW1
         BNE   EXCPERR$                 NO - ARRGH                 LDW1
         CLI   4(R15),1                 IS IT R1?                  LDW1
         BE    EXCP$NRF                 YES - IT'S REALLY NRF      LDW1
         B     EXCPERR$                 NO - ARRGH                 LDW1
         SPACE 2
EXCPOK$  MVI   TTR+3,NOSEQRD            TURN OFF SEQ READ FLAG     LDW1
         OC    CSW+6(2),CSW+6           ANY RESIDUAL?              LDW1
         LA    R1,=CL15'BLKLEN > BUFFSZ'   -> MSG IN CASE          LDW1
         BZ    EXCPERR$                 NO - ERROR                 LDW1
         TM    FLAGS2,ATTNHIT           WAS ATTN SIGNALED LATELY?  LDW5
         BNOR  R8                       NO, ALL DONE, RETURN BLK
         BAL   R8,CLEAR                 YES, CLEAR SCREEN
         MVC   LINE19+17(40),=CL40'         *****  HOLDING  ******'
         B     SETPNT00                 DISP OFF 0, CURR BLK       LDW1
         SPACE 5
**********************************************************************
*******************************  CALLEXP  *************************LDW1
**********************************************************************
         SPACE 3
*  CALL EXP, CHECK ERROR RETURNS                                   LDW1
*                                                                  LDW1
*  R1 -> STRING                                                    LDW1
*  R0  = LENGTH                                                    LDW1
*  R8  = RETURN ADDR - NOTE: CC IS SET ACCORDING RESULT'S SIGN     LDW1
         SPACE 1
CALLEXP  LR    R2,R15                   COPY "*" VALUE             LDW1
         L     R15,=A(EXP)              -> ROUTINE                 LDW1
         BALR  R14,R15                  CALL IT                    LDW1
         LTR   R1,R1                    WORK?                      LDW1
         BNM   INVEXPER                 NO                         LDW1
         LTR   R15,R15                  SET CC                     LDW1
         BR    R8                       RETURN TO CALLER           LDW1
         SPACE 5
**********************************************************************
*******************************  HEXCHECK  ***************************
**********************************************************************
         SPACE 3
*  VALIDITY CHECK FOR HEXADECIMAL, DECIMAL, OR CHARACTER
*
*  R7 = POINTER TO STRING
*  R1 = LENGTH OF STRING
*  R8 = RETURN ADDR - NOTE: 0(R8)=GOOD HEX, 4(R8)=BAD HEX AT 0(R7)
*  R15= 0 IF PURE DECIMAL UP TO EXIT, 4 IF HEX
         SPACE 1
HEXCHECK XR    R15,R15                  ASSUME DECIMAL
HEXCHK   TM    0(R7),X'F0'              NUMBER?
         BO    OKHEX                    YES - ITS OK
         CLI   0(R7),C'A'               LESS THAN ALPHA?
         BL    4(R8)                    YES, MUST BE CHARACTER
         CLI   0(R7),C'F'               'F' OR SMALLER?
         BH    4(R8)                    NO - MUST BE CHARACTER
         LA    R15,4                    INDICATE HEX (NOT DECIMAL)
OKHEX    LA    R7,1(R7)                 SO FAR SO GOOD, UPDATE HEX PTR
         BCT   R1,HEXCHK                DO THE WHOLE STRING
         BR    R8                       WE'RE OK - ALL DONE
         SPACE 5
**********************************************************************
********************************  GETSTRNG  **************************
**********************************************************************
         SPACE 3
*  PARSE OUT HEX OR CHARACTER STRING FOR S, X, O, N, L AND SET COMMS.
*  DETERMINE STRING LENGTH AND STRING ITSELF, AND SAVE BOTH IN AREA.
*
*  IF DECIMAL - A FULLWORD IS STORED (< 2147483647.)
*  IF HEXADECIMAL - UP TO 16 DIGITS (DOUBLEWORD) MAY BE STORED
*  IF CHARACTER - ANY DELIMITERS MAY SURROUND THE STRING (EXCEPT
*                 HEX DIGITS) AND UP TO 16 CHAR (2 DOUBLEWORDS) MAY
*                 MAY BE STORED.
*
*  R3 = ACTUAL LENGTH OF STRING TO BE PARSED
*  R4 = PTR TO THE STRING ITSELF
*  R5  =  PTR TO STRING SAVEAREA  (1ST BYTE = LEN)
         SPACE 1
GETSTRNG LA    R1,1                     LEN OF HEX TO BE CHECKED
         LR    R7,R4                    LOC OF HEX TO BE CHECKED
         BAL   R8,HEXCHECK              DO IT
         B     HEXSTR                   FIRST CHAR HEX - SO HEX STRING
*
*  CHARACTER STRING
*
         CH    R3,=H'18'                STRING LONGER THAN 16 CHARS?
         BH    LENERROR                 YES - SAY LENGTH ERROR     LDW1
         XC    TEMPTRT(256),TEMPTRT     CLEAR OUT TRTAB
         SR    R1,R1                    CLEAR OUT WORK REG
         IC    R1,0(,R4)                GET DELIM FOR CHAR STRING
         STC   R1,TEMPTRT(R1)           PUT IT IN RIGHT PLACE IN TRTAB
         SH    R3,=H'2'                 GET ADJUST STRING LEN (DELIMS)
         BNP   LENERROR                 HE ENTERED S'' OR LESS - ERROR
DELIMTRT TRT   1(0,R4),TEMPTRT          <<< EXECUTED >>>
         EX    R3,DELIMTRT              FIND THE OTHER DELIMITER
         LA    R2,=CL20'NO ENDING DELIMITER'   GET MSG ADDR IN CASE
         BZ    BOTCH                    NO - TELL HIM              LDW1
         LA    R3,1(,R4)                PT TO BEGINNING OF STRING
         SR    R1,R3                    GET STRING LEN (NO DELIMS)
         LR    R3,R1                    PUT IN RIGHT REG
         BCTR  R3,0
         LTR   R3,R3                    NULL INPUT?
         BM    LENERROR                 YES - SAY LENGTH ERROR
CHARMVC  MVC   2(0,R5),1(R4)            <<< EXECUTED >>>           LDW1
         EX    R3,CHARMVC               MOVE STRING CHARS TO SAVE AREA
         B     FINSTR                   GO FINISH THE JOB
         SPACE 2
LENERROR LA    R2,LENERR                YES - SAY LENGTH ERROR
         B     BOTCH                    GO TELL HIM
*
*  HEX STRING
*
HEXSTR   CH    R3,=H'16'                HEX STRING LONGER THAN 16?
         BH    LENERROR                 YES - SAY LENGTH ERROR
         LR    R1,R3                    PUT IT IN RIGHT REG FOR CHECK
         LR    R7,R4                    POINT TO LOC TO CHECK
         BAL   R8,HEXCHECK              CHECK THE HEX
         B     OK1#                     ITS GOOD
         CLI   0(R7),C' '               IS IT HEX?
         BE    OK1#                     YES, GO DO IT
         CLI   0(R7),C'.'               DECIMAL?
         BE    DECMAYBE                 MAYBE SO
         LA    R2,=CL20'INVALID HEXADECIMAL'   IT'S BAD - PT TO MSG
         B     BOTCH                    TELL HIM
OK1#     TR    0(16,R4),TRHEX           YES - START TO CONVERT TO HEX
         CH    R3,=H'15'                IS THIS THE MAX CASE?
         BL    HEXPACK                  NO, DO JUST ENOUGH
         PACK  TEMP(5),0(9,R4)          PACK FIRST GROUP
         PACK  TEMP+4(5),8(9,R4)        PACK SECOND GROUP
         BH    HEX16                    SKIP IF 16 DIGITS          LDW1
         LM    R14,R15,TEMP             GET THE RESULT             LDW1
         SRDL  R14,4                    DOWN 1 NIBBLE              LDW1
         STM   R14,R15,TEMP             RESTORE IT CORRECTLY       LDW1
HEX16    LA    R3,7                     NUMBER OF BYTES (EX LEN)
         MVC   2(8,R5),TEMP             GET HEX                    LDW1
         B     FINSTR                   AND THEN RETURN TO CALLER
* R3 IS NOT BCTRED BECAUSE WE NEED A FLIP BYTE ON THE END
HEXPACK  PACK  TEMP(8),0(0,R4)          <<< EXECUTED >>>
         EX    R3,HEXPACK               PACK TO MAKE REAL HEX
         LA    R3,1(,R3)                ROUND UP ...
         SRL   R3,1                     AND FIND NUMBER OF BYTES
         LA    R15,TEMP+7               POINT TO GORF BYTE
         SR    R15,R3                   POINT TO FIRST BYTE
         BCTR  R3,0                     GET EXECUTE LENGTH
MOVEHEX  MVC   2(0,R5),0(R15)           <<< EXECUTED >>>           LDW1
         EX    R3,MOVEHEX               MOVE HEX TO OUTPUT LOCATION
FINSTR   STH   R3,0(,R5)                SAVE THE LEN IN SCAN AREA  LDW1
         BR    R6                       RET TO CALLER
*
*  DECIMAL STRING
*
DECMAYBE BXLE  R15,R15,DECOK            IF REALLY DECIMAL - JUMP
         LA    R2,INVDEC                NO - TELL HIM SO BECAUSE...
         B     BOTCH                    ITS GOT A-F IN IT
DECOK    CH    R3,=H'10'                APPROACHING LEN ERR (BCTR'D)?
         BL    DECOK#                   NO - DON'T WORRY ABOUT IT
         CLC   0(11,R4),=C'2147483647.' TOO BIG FOR FULLWORD?
         BH    LENERROR                 YES - TELL HIM AND GET OUT
DECPACK  PACK  TEMP(8),0(0,R4)          <<< EXECUTE >>>
DECOK#   LA    R0,1(R4)                 POINT TO STRING + 1 FOR TO....
         SR    R7,R0                    GET EXECUTE LENGTH
         EX    R7,DECPACK               PACK UP YOUR DECIMALS IN ...
*        COMMENT TYPE=CONTINUED         IN YOUR OLD DOUBLE WORD
         CVB   R1,TEMP                  AND CONVERT, CONVERT, CONVERT
         ST    R1,TEMP                  SAVE IN ALIGNED PLACE
         MVC   2(4,R5),TEMP             COPY TO OUTPUT STRING      LDW1
         MVI   1(R5),3                  EXECUTE LENGTH             LDW1
         BR    R6                       RETURN
         SPACE 5
**********************************************************************
*********************************  NUMCONV  ***********************LDW1
**********************************************************************
         SPACE 2
*  R15 = NUMBER TO BE CONVERTED                                    LDW1
*  R14 = RETURN ADDR                                               LDW1
*  NUMBER IS CONVERTED TO 12 SIGNED DECIMAL DIGITS AT TEMP2,       LDW1
*  AND TO HEX AT TEMP2+12 (8 CHARS)                                LDW1
         SPACE 1
NUMCONV  ST    R15,TEMP                 SET FOR UNPK               LDW1
         UNPK  TEMP2+12(8+1),TEMP(4+1)                             LDW1
         TR    TEMP2+12(8),TRHEX        MAKE EBCDIC                LDW1
         CVD   R15,TEMP                 GET IN PACKED FORM         LDW1
         LA    R1,TEMP2+11              INIT LOC FOR FLOATING SIGN LDW1
         MVC   TEMP2(12),EDMASK         MOVE IN EDIT MASK          LDW1
         EDMK  TEMP2(12),TEMP+2         GET 11 DECIMAL DIGITS      LDW1
         LTR   R15,R15                  IS IT NEGATIVE?            LDW1
         BNMR  R14                      NO - ALL DONE              LDW1
         BCTR  R1,0                     YES - SO BACK UP AND...    LDW1
         MVI   0(R1),C'-'               ...PUT IN THE SIGN         LDW1
         BR    R14                      NOW DONE                   LDW1
         SPACE 5
**********************************************************************
*********************************  CSIO  *****************************
**********************************************************************
         SPACE 3
*  MAIN SCREEN DISPLAY.
*  CREATE TRACE TABLE ENTRY IF NECESSARY.
*  DISPLAY WITH TPUTS FOR NOW
         SPACE 1
CSIO     MVC   PREVREP,REP              SAVE FOR TWICE TEST        LDW4
         TM    TRACE,NOTRACE            TRACE FOR THIS GUY?
         BO    NOTRACIT                 NO - SO DONT
*
*  MAKE THE TRACE TABLE ENTRY
*
         L     R1,ITRAVAL               PICK UP NEXT SPOT IN TABLE
         CLI   0(R1),X'FF'              END?
         BNE   MORETAB                  NO - THERE'S MORE
         L     R1,AITRCTAB              YES - START OVER AT TOP    LDW1
         ST    R1,ITRAVAL               AND RESET AVAIL POS PTR
MORETAB  MVC   0(3,R1),TTR              MOVE TTR TO TABLE
         MVC   3(2,R1),OLDPOINT         AND OFFSET TOO
         ST    R1,CURRITR               SAVE PTR TO CURR TRACE ENTRY
         LA    R1,5(,R1)                UPDATE AVAIL PTR
         ST    R1,ITRAVAL               SAVE IT
NOTRACIT MVI   TRACE,YESTRACE           MAKE IT TRACE AGAIN
         TM    FLAGS3,NODISPF           DISPLAY SUPPRESSED ?       SDM6
         BO    NOTSHORT                 YES, DON'T FIX STUFF TWICE SDM6
         SPACE 1
         CLI   LINELEN+1,80             SHORT LINES?               LDW1
         BE    NOTSHORT                 NO - OK AS IS              LDW1
         MVC   LINE01($L-17),LINE01+17  SHIFT INFO LINES OVER      SDM5
         MVC   LINE05($L-17),LINE05+17  SHIFT INFO LINES OVER      LDW1
         MVC   LINE19($L-17),LINE19+17  SHIFT INFO LINES OVER      LDW1
         MVC   LINE20($L-17),LINE20+17  SHIFT INFO LINES OVER      LDW1
         MVC   LINE21($L-17),LINE21+17  SHIFT INFO LINES OVER      LDW1
NOTSHORT TM    FLAGS3,F3270             FULLSCREEN?                LDW5
         BO    CSIO3270                 YES, GO TO HIS STUFF       SDM6
         TM    FLAGS3,NODISPF           DISPLAY SUPPRESSED ?       SDM6
         BO    TGET                     MAKE IT SIMPLE, STUPID     SDM6
         TM    FLAGS3,CRTF              CRT MODE?                  LDW5
         BZ    NOFORMFD                 NO - DON'T CLEAR THE SCRN  LDW1
         TPUTX =X'0C',1,CONTROL         CLEAR THE SCREEN           LDW1
         SPACE 2
NOFORMFD LA    R6,$I                    BXLE INCR                  LDW1
         LA    R1,LINE05                TPUT I/O ERROR MSG
         BAL   R14,PUTLINE              (IF ANY)                   LDW1
         SPACE 1
         L     R5,MIDLINE               ADDR OF CARET
         LTR   R5,R5                    ANY CARET (BLK DISPLAY?)
         BNZ   DOWINDOW                 YES, WINDOW SCREEN
         LA    R3,LINE06                NO, FULL SCR, BEGIN
         LA    R5,LINE18                END (BXLE)
         B     DUMPSCR                  DUMP IT
         SPACE 2
*  CREATE TSO SCREEN WINDOW. DEFAULT SIZE IS ONLY CARET LINE. THE
*  'W' COMMAND CHANGES IT TILL NEXT 'W' COMMAND.  LINES ABOVE AND
*  BELOW 'CARET' LINE ARE SPECIFIED.  THIS ALLOWS FEWER LINES FOR
*  HARDCOPY TERMINALS.  EG:
*
*  D,U ... U LINES ABOVE, CARET LINE, D LINES BELOW
*  ,U .... U LINES ABOVE, CARET LINE, PREVIOUS D LINES BELOW
*  D|D, .. PREVIOUS U LINE ABOVE, CARET LINE, D LINES BELOW
*
         SPACE 1
DOWINDOW S     R5,FIRSTSCR              OFFSET TO SCREEN CARET
         XR    R4,R4                    DIVIDE
         DR    R4,R6                    LINE NUMBER CARET
         LR    R3,R5                    SAVE IT
         S     R3,WIDTHU                BACK UP 'U' LINES <UP>
         BNM   *+6                      SKIP IF OK
         XR    R3,R3                    TOO FAR, MAKE IT TOP OF BUFF
         A     R5,WIDTHD                GO DOWN 'D' LINES <DOWN>
*LDW1    L     R0,MAXWIDTH              MAX LINE NUM
*LDW1    BCTR  R0,0                     -1 FOR OFFSET
         LA    R0,(LINE19-LINE06)/2     GET MAX # OF LINES         LDW1
         CR    R5,R0                    BOTTOM TOO HIGH
         BNH   *+6                      NO
         LR    R5,R0                    YES, MAKE IT MAX LINE#
         MR    R2,R6                    GET OFFSET TO TOP LINE
         MR    R4,R6                    GET OFFSET TO BOTT LINE
         A     R3,FIRSTSCR              POINT TO TOP
         A     R5,FIRSTSCR              POINT TO BOTTOM
DUMPSCR  LR    R4,R6                    GET LENGTH IN BXLE REG
         SPACE 1
*  R3=BEGIN, R4=LEN, R5=END
         SPACE 1
TPUTL    LR    R1,R3                    COPY LINE ADDR             LDW1
         BAL   R14,PUTLINE              PRINT IT IF NOT BLANK      LDW1
         BXLE  R3,R4,TPUTL
         SPACE 2
         LA    R2,LINE19                POSSIBLE MSGS BELOW WINDOW
         LA    R3,3                     3 LINES
TPUTL2   LR    R1,R2                    COPY LINE ADDR             LDW1
         BAL   R14,PUTLINE              PRINT IT IF NOT BLANK      LDW1
         AR    R2,R6                    DO ALL
         BCT   R3,TPUTL2
         SPACE 2
TGET     MVI   TSECB,0                  RESET ECB                  LDW1
         MVC   PGPB(PGPBDCL),PGPBDC     INIT PARM BLOCK
         NI    FLAGS2,255-ATTNHIT       RESET FLAG                 LDW1
         L     R15,IKJPTGT              ADDR OF LOADED PUTGET
         PUTGET PARM=PGPB,MF=(E,IOPL),ENTRY=(15)
         LA    R14,8                                               LDW1
         CR    R15,R14                                             LDW1
         BL    *+16       >==========+                             LDW1
         BE    TGET                  |  ATTN, TRY AGAIN            LDW1
         EX    0,*                   |                             LDW1
         B     TGET                  |  RESUME IF TEST RESTARTS ME LDW1
         NI    FLAGS3,255-NODISPF  <=+  STOP SUPPRESSING DISPLAY   SDM6
         L     R1,PGPBIBUF              POINT TO INPUT LINE
         LH    R15,0(,R1)               GET LENGTH OF BUFFER
         SH    R15,=H'4'                GET LENGTH OF REPLY
         STH   R15,READLEN              SAVE REPLY LNTH
         BZ    TGET1                    IF NO REPLY SKIP MOVE TO REPLY
         CH    R15,=Y($L)               COMPARE WITH MAX           LDW1
         BNH   TGET0                    OK
         LH    R15,=Y($L)               USE MAX                    LDW1
         STH   R15,READLEN              SAVE IT
TGET0    DS    0H
         MVC   REP,BLANKS               PRE-BLANK THE BUFFER       LDW5
         BCTR  R15,0                    DECREMENT FOR EXECUTE
         MVC   REP(*-*),4(R1)           EXECUTED
         EX    R15,*-6                  MOVE IN THE REPLY
TGET1    LH    R15,0(,R1)               GET LNTH AGAIN
         LA    R0,1                     GET SP
         SLL   R0,24                    SHIFT INTO PLACE
         AR    R0,R15                   ADD IN LENGTH
         FREEMAIN R,LV=(0),A=(1)
         LH    R1,READLEN               GET REPLY LENGTH
         MVC   LINE19,BLANKS            CLEAR ERROR MSG IF ANY     LDW1
         XC    MIDLINE,MIDLINE          NO CARET LINE NOW
         BR    R8                       YES, PARSE IT
         SPACE 3                                                   LDW3
*  THIS HUNK OF CODE MOVE DOWN HERE FROM SOMEWHERE IN "DISPLAY"    SDM6
CSIO3270 TM    FLAGS3,FSMODE            IS FSMODE ON ?             LDW5
         BO    CSIOINIT                 YES, THAT'S GOOD           LDW5
         SPACE 1
         AIF   (&MVT).MVT03                                        LDW5
         STFSMODE  ON                   SET 3270 FULLSCREEN MODE   LDW1
         SPACE 1
.MVT03   OI    FLAGS3,FSMODE            IT'S ON NOW                LDW5
         SPACE 1
CSIOINIT MVC   LINE01,BLANKS            CLEAR THE TOPLINE          SDM6
         MVC   LINE01+33(7),=C'Z  A  P' MOVE TOPLINE               SDM5
         SPACE 2                                                   SDM6
         LA    R1,REP+$L-1              END OF REPROMPT BUFFER     SDM6
CSIOCLR  CLI   0(R1),C' '               TRAILING BLANK?            SDM5
         BNE   CSIOCLRX                 NO, LEAVE THE LOOP         SDM5
         MVI   0(R1),X'00'              CHANGE TO TRAILING NULL    SDM5
         BCT   R1,CSIOCLR               GO BACK AND CHECK AGAIN    SDM5
CSIOCLRX L     R2,AOLDSCR               -> SAVED LINE1             SDM6
         LA    R4,LINE01-2              -> CURRENT LINE1           SDM6
         TM    FLAGS3,RESHOWF           FULL SCREEN TPUT?          LDW5
         BNO   CSIOCHNG                 NO, PROCESS CHANGED LINES  LDW5
         LA    R3,L'OLDSCR              GET SAVE AREA LENGTH       SDM6
         LR    R5,R3                    COPY LENGTH FOR MVCL       SDM6
         MVCL  R2,R4                    SAVE INITIAL SCREEN IMAGE  SDM6
CSIOFULL LM    R0,R1,REGS3270           GET THE TPUT REGS          SDM5
         B     CSIOTPUT                 GO WRITE THE WHOLE SCREEN  SDM5
CSIOCHNG L     R3,ASCRWORK              -> WORK AREA               SDM5
         MVC   0(L'CTL3270,R3),CTL3270  COPY CONTROL INFO          SDM5
         LA    R3,L'CTL3270(,R3)        BUMP PTR                   SDM5
         SR    R5,R5                    INITIAL SCREEN ADDRESS     SDM5
         SPACE 1
         MVI   $I+2(R2),X'FE'           FORCE LINE02 MISMATCH      SDM5
         MVI   3*$I+2(R2),X'FE'         FORCE LINE04 MISMATCH      SDM5
         LA    R6,21                    NUMBER OF LINES TO TEST    SDM5
         BAL   R14,CSIOTMOD             GO CHECK ONE               LDW2
         BCT   R6,*-4                   CHECK ALL 21               SDM5
         SPACE 1
         MVC   0(L'END3270M,R3),END3270M MOVE IN ENDING CTL STUFF  SDM5
         LA    R0,L'END3270M(,R3)       GET END+1 ADDR             SDM5
         L     R1,ASCRWORK              -> START OF WORK AREA      LDW2
         SR    R0,R1                    GET LENGTH TO TPUT         LDW2
         BP    *+8                      CONTINUE IF OK             LDW2
         EX    0,*                      DIE IF LOGIC ERROR         LDW2
         ICM   R1,B'1000',=X'03'        GET FULLSCR TPUT FLAG      LDW2
         SPACE 2
CSIOTPUT TPUT  (1),(0),R                                           LDW1
         SPACE 1
         NI    FLAGS3,255-RESHOWF-NODISPF   REFRESH IS DONE        SDM6
         LA    R1,REPX                  BUFFER ADDR                LDW1
         ICM   R1,B'1000',=X'81'        MAKE IT A TGET ASIS        SDM1
         LA    R0,L'REPX                LENGTH OF INPUT BUFFER     LDW1
         TGET  (1),(0),R                                           SDM5
         SPACE 1
         NI    CTL3270,255-X'04'        CHANGE WCC TO NO ALARM     SDM4
         CLI   REPX,X'7D'               ENTER?                  .AFDSC.
         BE    NOTPFK                   YES - BYPASS PFK        .AFDSC.
         CLI   REPX,X'6E'               PA2?  (RESHOW?)            SDM1
         BE    CSIOFULL                 YES - GO DO IT             SDM6
         OI    REPX,X'30'               PFK 13-24 LIKE 1-12     .AFDSC.
         CLI   REPX,X'F5'               PF5? (L?)               .AFDSC.
         BE    PFKLOC                   YES - GO DO IT          .AFDSC.
         CLI   REPX,X'F8'               PF8? (D?)               .AFDSC.
         BE    PFKDOWN                  YES - GO DO IT          .AFDSC.
         CLI   REPX,X'F7'               PF7? (U?)               .AFDSC.
         BE    PFKUP                    YES - GO DO IT          .AFDSC.
         CLI   REPX,X'F3'               PF3? (END?)             .AFDSC.
         BE    ENDPFK                   YES - GO DO IT          .AFDSC.
NOTPFK   EQU   *
         LA    R2,REP                   THIS IS WHERE IT WILL GO   SDM5
         LA    R3,REPX+3                POINT SRC PAST CURSOR ADDR SDM1
         LA    R4,REPX-1(R1)            END OF REPLY DATA          SDM1
         CR    R3,R4                    TOO FAR?                   SDM5
         BH    ASIS08                   YES, NO DATA CAME IN       SDM5
         CLI   0(R3),X'11'              SBA SEQUENCE?              SDM5
         BE    ASIS02                   YES, SCREEN IS FORMATTED   SDM5
         OI    FLAGS3,RESHOWF           NO, FORCE FULL REWRITE     SDM5
ASIS02   CR    R3,R4                    TOO FAR?                   SDM1
         BH    ASIS08                   YES, NO DATA CAME IN       SDM1
         CLI   0(R3),X'11'              SBA SEQUENCE?              SDM5
         BNE   ASIS05                   NO, DON'T WORRY ABOUT IT   SDM5
         CLC   1(2,R3),=X'C1D1'         FIRST LINE INPUT?          SDM5
         BE    ASIS04                   YES, ALL'S COOL SO FAR     SDM5
         CLC   1(2,R3),=X'C3F1'         SECOND LINE INPUT?         SDM5
         BE    ASIS03                   YES, GO CLEAR REP          SDM5
         TPUTX '** SCREEN FORMAT ERROR **'   TOO BAD               SDM1
         B     CSIOFULL                 GIVE HIM BACK WHOLE SCREEN SDM6
         SPACE 1
ASIS03   MVC   REP,BLANKS               CLEAR REMEMBERED INPUT     SDM5
ASIS04   LA    R3,3(,R3)                SKIP THE SBA SEQUENCE      SDM5
         B     ASIS02                   AND TRY SOME MORE          SDM5
         SPACE 1                                                   SDM5
ASIS05   CLI   0(R3),C' '               LEADING BLANK?             SDM5
         BNE   ASIS06                   NO, FOUND DATA             SDM5
         LA    R3,1(,R3)                SKIP THE BLANK             SDM5
         B     ASIS02                   GO LOOK FOR MORE           SDM5
         SPACE 1                                                   SDM5
ASIS06   MVC   REP,BLANKS               FORCE CLEAR REPLY          SDM5
ASIS07   CR    R3,R4                    TOO FAR?                   SDM1
         BH    ASIS08                   YES, FILL IT UP NOW        SDM1
         CLI   0(R3),X'11'              SBA?                       SDM1
         BE    ASIS08                   YES, IGNORE THE 2ND LINE   SDM1
         MVC   0(1,R2),0(R3)            MOVE ONE MORE BYTE         SDM1
         LA    R2,1(,R2)                OK, UP THIS ONE            SDM1
         LA    R3,1(,R3)                AND THE FROM POINTER, TOO  SDM1
         B     ASIS07                   CONTINUE THIS TRAVESTY     SDM1
         SPACE 1                                                   SDM5
ASIS08   LA    R4,REP                   COMPUTE THE REAL           SDM1
         SR    R2,R4                      LENGTH OF THE REPLY      SDM1
         STH   R2,READLEN                   AND SAVE IT FOR LATER  SDM1
         MVC   LINE19,BLANKS            CLEAR THE ERROR MSG IF ANY LDW1
         BR    R8                       GO PARSE IT                LDW1
         SPACE 2
CSIOTMOD CLC   0($I,R2),0(R4)           DOES IT MATCH ?            SDM5
         BE    CSIONMOD                 YES - SKIP                 LDW2
         MVI   0(R3),X'11'              SBA                        SDM5
         LR    R0,R5                    COPY ADDRESS               SDM5
         STC   R0,2(,R3)                STORE LOW 8 BITS           SDM5
         NI    2(R3),B'00111111'        MAKE THAT LOW 6 BITS       SDM5
         SRL   R0,6                     DOWNSHIFT                  LDW2
         STC   R0,1(,R3)                STORE SOME MORE BITS       SDM5
         NI    1(R3),B'00111111'        MAKE THAT HIGH 6 BITS      SDM5
         TR    1(2,R3),TR3270           MAKE VALID CHARS           SDM5
         MVC   0($I,R2),0(R4)           UPDATE SAVED SCREEN        SDM5
         MVC   3($I,R3),0(R4)           MOVE IN NEW DATA           SDM5
         LA    R3,$I+3(,R3)             -> NEXT SCRWORK AREA       SDM5
         SPACE 1
CSIONMOD LA    R2,$I(,R2)               -> NEXT SCREEN LINE        SDM5
         LA    R4,$I(,R4)               -> NEXT SCREEN LINE        SDM5
         LA    R5,$I-1(,R5)             =NEXT SCREEN OFFSET        SDM5
         BR    R14                      RETURN TO ABOVE            LDW2
         SPACE 5
**********************************************************************
*********************************  CSIO#  ****************************
**********************************************************************
         SPACE 3
*  SECONDARY DISPLAY.
*  SHORT SCREEN MSGS
*
*  R1 = ADDR OF BUFFER (40 BYTES ONLY)
         SPACE 1
CSIO#    MVC   LINEBUFF(40),0(R1)       COPY THE LINE              LDW1
         BAL   R8,KILL3270              TURN OFF 3270 MODE IF ON   LDW1
         NI    FLAGS3,255-F3270         TURN OFF THE FLAG          LDW1
         BAL   R14,PUTLINE$             PUT THE SHORT LINE         LDW1
         SPACE 2
         B     END                      QUIT THIS CP
         SPACE 5
*********************************************************************
**********************************  PUTLINE  **********************LDW1
*********************************************************************
         SPACE 3                                                   LDW1
PUTLINE$ MVC   LINEDESC(4),=H'44,0'                                LDW1
         B     PUTLINEX                                            LDW1
         SPACE 2
PUTLINE  CLC   0($L,R1),BLANKS          BLANK LINE?                LDW1
         BER   R14                      YES - DON'T TPUT IT        LDW1
         MVC   LINEBUFF($L),0(R1)       COPY OUTPUT LINE           LDW1
         MVC   LINEDESC(4),=Y($L+4,0)   SET DESCRIPTOR WORD        LDW1
         SPACE 1
PUTLINEX TM    FLAGS2,ATTNHIT           STOP???                    LDW5
         BOR   R14                      YES.                       LDW1
         ST    R14,TERMSAVE             SAVE RETURN ADDR           LDW1
         MVC   PTPB(PTPBDCL),PTPBDC     INIT PARM BLOCK            LDW1
         LA    R0,LINEDESC              POINT TO O.L.D.            LDW1
         ST    R0,PTPB+4                SET ADDR IN PARM BLOCK     LDW1
         L     R15,IKJPUTL                                         LDW1
         MVI   TSECB,0                  RESET ECB                  LDW1
         SPACE 1                                                   LDW1
         PUTLINE  PARM=PTPB,MF=(E,IOPL),ENTRY=(15)                 LDW1
         SPACE 1                                                   LDW1
         LA    R14,4                                               LDW1
         CR    R15,R14                                             LDW1
         L     R14,TERMSAVE             RESTORE RETURN ADDR        LDW1
         BNHR  R14                                                 LDW1
         EX    0,*                                                 LDW1
         SPACE 5                                                   LDW1
**********************************************************************
**********************************  TTRPARSE  ************************
**********************************************************************
         SPACE 3
*  DETERMINES AND VALIDITY CHECKS TTR SPECIFIED.
*  R1 POINTS TO THE TTR;  R0 HAS ITS LENGTH;  OUTPUT IS IN TEMP+1(3)
         SPACE 1
TTRPARSE L     R15,TTR                  GET '*' = CURRENT TTR
         SRL   R15,8                    RIGHT JUSTIFY
         BAL   R8,CALLEXP               GO PARSE                   LDW1
         BNP   TTRLT1                   NOT POSITIVE IS INVALID    LDW1
         ST    R15,TEMP                 SAVE THE VALUE RETURNED    LDW1
         CLI   TEMP+3,0                 REC 0?                     LDW1
         BNZR  R6                       NO - GIVE IT
         LA    R2,REC0INV               YES - TELL HIM
         B     BOTCH                    WITH A MSG
         SPACE 2
TTRLT1   LA    R2,TTRSMALL              POINT TO ERROR MSG
         B     BOTCH                    DISPLAY ERROR STYLE
         SPACE 5
**********************************************************************
**********************************  PREPDUMP  ************************
**********************************************************************
         SPACE 3
*  THIS ROUTINE IS THE 'PREPROCESSOR' TO THE DUMPER.  IT GETS THE
*  BLOCK TO BE DUMPED, PREPARES AND WRITES OUT THE BLOCK HEADER
*  LINE (WITH TTR, LENGTH, AND CCHHR), AND IF THERE IS AN EOF OR
*  I/O ERROR AT THE BLOCK, AND MESSAGE IS PUT OUT TO THE RECORDING
*  FILE AND THE 'BLOCK' IS NOT DUMPED.
*  RETURNS:  0(R6) - NORMAL RETURN WITH DUMP OF BLOCK TO FOLLOW.
*            4(R6) - I/O ERROR OR EOF, RETURN WITH NO DUMP, OR EXIT
*                    FROM ENTIRE DUMPING LOOP IF I/O ERROR WAS
*                    'OUT OF DATASET', MEANING THERE IS NO MORE
*                    DATASET, NO MORE EXTENT.
         SPACE 1
PREPDUMP MVI   EOFRET,NOEOF             SAY ALSO EOF'S ARE DATA BLOCKS
         BAL   R8,READBLK               GET THE BLOCK, SUCH AS IT IS
PREPDMPX TM    FLAGS2,LOGF              ARE WE LOGGING
         BNO   NEWDSPNT                 IF NOT FORGET THIS
         L     R2,CSOUTWK               POINT TO THE OUTPUT WORKAREA
         LTR   R2,R2                    IS THERE ONE?
         BZ    NEWDSPNT                 NO - FORGET THIS WHOLE THING
         L     R2,0(R2)                 GET ADDR IN REG
         MVC   1+0(40,R2),=C'LENGTH=XXXXX TTR=XXXXXX CCHHR=XXXXXXXXXX'
         LH    R1,BLKLEN                GET THE LENGTH OF THE BLK
         CVD   R1,TEMP                  PACKED DEC
         UNPK  1+7(5,R2),TEMP+5(3)      PUT LENGTH INTO MSG
         OI    1+11(R2),X'F0'           FIX FLIP BYTE
         HEX   (1+17,R2),TTR,LEN=3      CONVERT TTR                LDW1
         HEX   (1+30,R2),CCHHR,LEN=5    CONVERT CCHHR              LDW1
         MVI   0(R2),C'-'               TRIPLE SPACE BEFORE HDR PRINTED
         MVI   ENQIT,255                FORCE ENQ TO PRINT
         BAL   R8,CPUT#                 PUT OUT THE LINE
         CLI   IOERROR,YESSYN           I/O ERROR IN READ BEFORE?
         BE    OOPSDUMP                 YES - DON'T DUMP, JUST MSG
         CLC   LINE05+27(20),EOFMSG     NO - BUT WAS THERE AN EOF? LDW1
         BNER  R6                       NO - RETURN NORMALLY AND DUMP
         SPACE 1
*  EITHER THE BLOCK HAS AN I/O ERROR WAS AN END-OF-FILE, SO WE CANNOT
*  DUMP.  INSTEAD, PRINT OUT, IF POSSIBLE, THE TYPE OF CONDITION
*  WHICH HAS OCCURRED, AND RETURN BEYOND DUMP CODE - 4(R6).
*  IF THE I/O ERROR 'NOT IN DATASET' HAS OCCURRED, THEN STOP THE
*  PROCESS ALTOGETHER.  WE ARE AT THE REAL END OF THE DATASET.
         SPACE 1
OOPSDUMP TM    FLAGS2,LOGF              ARE WE LOGGING      %%NEED%%
         BNO   NEWDSPNT                 IF NOT FORGET IT    %%THIS?%%
         L     R2,CSOUTWK               PT TO OUTPUT BUFFER PTR
         LTR   R2,R2                    AHA.  IS THERE ONE, HE ASKS
         BZ    NEWDSPNT                 NOPE - TOUGH LUCK, FELLA
         L     R2,0(R2)                 GET ADDR OF BUFFER
         MVC   1+0(40,R2),LINE05+17     COPY EXACTLY WHAT IS ON THE SCR
         MVI   0(R2),C' '               CARRIAGE CONTROL
         MVI   ENQIT,255                FORCE ENQ
         BAL   R8,CPUT#                 WRITE IT OUT
         CLC   LINE05+35(15),=CL15'NOT IN DATA SET'   END OF EXTENT?
         BE    NEW$DISP                 YES - GET OUT OF LOOP AND DISP
         CLC   LINE05+27(20),EOFMSG     WAS IT EOF?                LDW1
         BE    NEW$DISP                 YES - GET OUT AND DISPLAY LOC
         B     4(R6)                    NO - BUT DON'T DUMP THIS 'BLK'
         SPACE 5
**********************************************************************
*********************************  DUMPER  ***************************
**********************************************************************
         SPACE 3
*  THIS ROUTINE DUMPS ANY SIZE BLOCK WHICH IS IN THE BUFFER TO
*  THE OUTPUT RECORDING FILE.  THE HEX OFFSETS, THE ACTUAL HEX DATA,
*  AND THE TRANSLATION OF THAT DATA IS PRINTED OUT.
*  NOTE:  (1) GARBAGE DATA IS NOT PRINTED.  THAT IS, DATA IS DISPLAYED
*             ONLY UP TO THE LAST BYTE, AND NO FARTHER.
*         (2) TRANSLATED DATA IS EITHER IN EBCDIC OR IN ASCII
*             TRANSLATION, DEPENDING ON WHICH COMMAND IS IN EFFECT
*             AT THE TIME OF THE DUMP, 'EBCDIC' OR 'ASCII'.
*         (3) THE 'PREPROCESSOR' ROUTINE 'PREPDUMP' MUST BE CALLED
*             FIRST TO GET THE BLOCK, WRITE OUT THE BLOCK HEADER
*             LINE, AND TO CHECK FOR SYNAD AND EODAD ON THE BLOCK.
         SPACE 1
DUMPER   L     R3,ADDRBUFF              PT TO INPUT BUFFER (THE BLOCK)
         ST    R6,TEMP2+20              SAVE RETURN BAL ADDR
         XR    R4,R4                    CLEAR REM REG FOR DIVIDE
         LH    R5,BLKLEN                GET LEN OF BLK
         D     R4,=F'32'                HOW MANY 4 DBLW LINES IN BLK
*  R4 HAS THE LENGTH OF THE OFLO 'SHORT' LINE.  R5 HAS THE NUMBER OF
*  LINES TO DUMP OUT (THE NUMBER OR 1 SHORT).
         LTR   R4,R4                    IS THERE A SHORT LAST LINE?
         BZ    *+8                      NO - HAVE NUMBER OF LINES NOW
         LA    R5,1(R5)                 YES - CORRECT NUM OF LINES
         XC    TEMP(4),TEMP             INITIALIZE OFFSET COUNTER
         SPACE 1
DMPFMTLP TM    FLAGS2,LOGF              ARE WE LOGGING
         BNO   BADCSOUT
         L     R2,CSOUTWK               PT TO CSOUT OUTPUT BUFFER
         LTR   R2,R2                    IS THERE ONE?
         BZ    BADCSOUT                 NO - TELL HIM UNABLE TO RECORD
         L     R2,0(,R2)                YES - PICK UP BUFFER PTR
         MVI   0(R2),C' '               CARRIAGE CONTROL
         HEX   (1+0,R2),TEMP+1,LEN=3    GET OFFSET                 LDW1
         MVC   1+91(32,R2),0(R3)        MOVE DATA TO DUMP SECTION
         L     R15,TRTABADD             PICK UP CURRENT TRANSLATE TAB
         TR    1+91(32,R2),0(R15)       TRANSLATE IT IN PLACE
         MVI   1+90(R2),C'*'            MOVE IN DELIMITER
         MVI   1+123(R2),C'*'           MOVE IN DELIMITER
         SPACE 1
*  FORMAT THE LINE
*  THE LINE IS COMPOSED OF 4 COMPLETE DOUBLEWORDS.  EACH DOUBLEWORD
*  IS FORMATTED INTO FULLWORDS SEPARATED BY A BLANK, AND EACH PAIR
*  OF DOUBLEWORDS IS SEPARATED BY 3 BLANKS.  THUS DUMPER LOOPS TWICE
*  A LOOP OF 4 PASSES, ONE PER FULLWORD.
         SPACE 1
         LA    R14,1+9(R2)              POINT TO 1ST AVAIL LINE POS
         LA    R6,2                     BCT OUTER LOOP (2 PAIRS DBLW'S)
*
LINELP1  LA    R4,4                     BCT INNER LOOP (4 FULLWORDS)
*
LINELP2  HEX   (0,R14),(0,R3),LEN=4     GET ONE FULLWORD           LDW1
         LA    R3,4(,R3)                UPDATE INPUT BUFFER PTR
         LA    R14,9(,R14)              UPDATE OUTPUT LINE PTR
         BCT   R4,LINELP2               DO IT FOR 4 FULLWORDS
         LA    R14,3(,R14)              FOR NEXT PAIR OF DBLW'S, SPACE
         BCT   R6,LINELP1               DO IT FOR 2 PAIRS OF DBLW'S
         SPACE 1
         MVI   ENQIT,255                FORCE ENQ TO PRINT
         CH    R5,=H'1'                 LAST LINE NOW?
         BE    LASTLINE                 YES - CHECK FOR SHORT LAST LINE
         L     R15,TEMP                 NO - UPDATE OFFSET BY GETTING
         LA    R15,X'20'(R15)           IT IN THE REG, ADDING INCR,
         ST    R15,TEMP                 AND PUTTING IT BACK
         BAL   R8,CPUT#                 WRITE IT OUT
         BCT   R5,DMPFMTLP              DO ALL THE LINES EXCEPT LAST
         SPACE 2
*  LAST LINE ROUTINE
*  IF THE LINE IS A SHORT LAST LINE, ONLY WRITE OUT THE CORRECT
*  AMOUNT OF DATA.
         SPACE 1
LASTLINE LH    R1,BLKLEN                GET LEN OF BLK
         N     R1,=F'31'                TURN OFF ALL BUT LOW ORDR BITS
         LTR   R1,R1                    ARE THERE ANY LOW ORDER BITS?
         BZ    BYELAST                  NO - FULL LAST LINE, DUMP IT
         SPACE 1
*  GET RID OF THE JUNK IN THE DUMP (TRANSLATED) PART FIRST
         SPACE 1
         LA    R14,32-1-1               MAX WIDTH -1 FOR MVI -1 EX LEN
         SR    R14,R1                   GET LEN OF JUNK
         LA    R3,1+91(R2,R1)           POINT TO BEGINNING OF JUNK
         MVI   0(R3),C' '               KILL THE FIRST BYTE
         LTR   R14,R14                  ANY MORE STUFF TO BLANK?
         BM    *+8                      NO - GO ON AND FIX THE LINE NOW
         EX    R14,DMPBKMVC             KILL THAT JUNK
         SPACE 1
         XR    R0,R0                    CLEAR REM REG FOR DIVIDE
         D     R0,=F'4'                 HOW MANY FLWRD GRPS ARE THERE?
*  R0 HAS SLOPOVER WITHIN 1 FULLWORD, R1 HAS NUMBER OF FULLWORDS
*  ON THE LAST LINE
         LA    R4,DUMPOFFS(R1)          POIN TO THE TAB TABLE OFFSET
         XR    R3,R3                    CLEAR REG FOR IC
         IC    R3,0(R4)                 GET THE TAB TO THE COLUMN
         SLL   R0,1                     *2 SLOPOVER FOR CHARACTER BYTES
         AR    R3,R0                    OFFSET TO FIRST GARBAGE CHAR
         LA    R4,86-1                  GET MAX LEN  OF LINE (-1 MVI)
         SR    R4,R3                    GET LEN OF GARBAGE TO BLANK
         LA    R3,1(R3,R2)              POINT TO 1ST GARBAGE BYTE
         MVI   0(R3),C' '               BLANK OUT AT LEAST ONE
         BCTR  R4,0                     GET EXECUTE LEN
         LTR   R4,R4                    IS THERE ANY MORE TO GET RID OF
         BM    BYELAST                  NO - GOOD BYE LAST LINE
DMPBKMVC MVC   1(0,R3),0(R3)            <<< EXECUTED >>>
         EX    R4,DMPBKMVC              GET RID OF THE REST
BYELAST  BAL   R8,CPUT#                 WRITE OUT LAST LINE
         L     R6,TEMP2+20              RESTORE RET ADDR
         BR    R6                       RETURN TO CALLER
         SPACE 5
**********************************************************************
********************************  CLEARDEF  **************************
**********************************************************************
         SPACE 3
*  RESET AND/OR INITIALIZE THE DEFINE TABLE
         SPACE 1
CLEARDEF L     R2,AIDEFTAB              PT TO BEGINNING OF TABLE   LDW1
         ST    R2,IDEFAVAL              MAKE THAT THE 1ST AVAIL POSIT
         MVC   0(240,R2),BLANKS         CLEAR OUT THE TABLE ALSO   LDW1
         BR    R8                       RET TO CALLER
         SPACE 5
**********************************************************************
**********************************  CLOSE  ***************************
**********************************************************************
         SPACE 3
*  CLOSE THE DATASET
         SPACE 1
CLOSE    TM    DCBU+48,X'10'            IS IT OPEN?
         BNOR  R8                       NO, WHY CLOSE THEN?
         CLOSE MF=(E,DCBLIST)           GOODBYE DATASET
         BR    R8                       RET TO CALLER
         SPACE 5
**********************************************************************
*********************************  WRITE  ****************************
**********************************************************************
         SPACE 2
WRITE    LA    R14,CCW##W               -> CCW CHAIN               LDW1
         SPACE 1
WRITE$GO ST    R14,IOBCCWA              SET IN IOB                 LDW1
         SPACE 1
         EXCP  IOB                                                 LDW1
         SPACE 1
         WAIT  ECB=ECB                                             LDW1
         SPACE 1
         CLI   ECB,X'7F'                                           LDW1
         BER   R8                                                  LDW1
         B     REALERR                                             LDW1
         SPACE 5
***********************************************************************
***************************  OPENMSG  *********************************
***********************************************************************
         SPACE 2
*  IF WE MUST OPEN A DATA SET, CREATE A MESSAGE ABOUT IT
         SPACE 2
LOGTEST  TM    FLAGS2,LOGF              ALREADY LOGGING?           LDW1
         BOR   R8                       YES - ALL DONE             LDW1
         SPACE 2
OPENOUT  ST    R8,DBLW                  SAVE FOR LATER
         L     R1,CSOUTWK               FIND CSOUT'S WORKAREA
         LTR   R1,R1                    ANY WORKAREA?
         BZR   R8                       NO, EXIT NOW
         OI    FLAGS2,LOGF              WE ARE NOW LOGGING         LDW1
*LDW1    CSOUT OPN,=CL6'SYSDA3',=H'10',CALL=CALL,MF=(E,(1))  (10,10)
         MVI   0(R1),X'80'          (+) FLAG AS OPEN CALL
*LDW1    LA    0,=CL6'SYSDA3'       (+)
*LDW1    ST    0,4(,R1)             (+) STORE FIRST PARM
*LDW1    LA    R0,=H'10'            (+)
*LDW1    ST    R0,8(,R1)            (+) STORE SECOND PARM
         LR    R2,R1                (+) COPY WORKAREA PTR
         L     R15,=V(CSOUT)        (+) POINT TO ROUTINE
         LR    R1,CSREG             (+) GET CSAREA PTR
         BALR  R14,R15              (+) CALL IT
         LTR   R0,R0                    ERROR?
         BZ    SAYOPEN                  NO
         NI    FLAGS2,255-LOGF          TURN OFF FLAG              LDW1
         LA    R1,=CL40'UNABLE TO ALLOCATE PRINT FILE'             LDW1
         BAL   R8,CSIO#                 DISPLAY IT
***  CSIO# DOESN'T RETURN ??????                                   LDW1
         XC    CSOUTWK,CSOUTWK (NOOUT)  NO MORE TRIES AT IT
         B     LOCRET                   RETURN TO CALLER
SAYOPEN  DS    0H
         MVI   ENQIT,0                  MAYBE
         MVI   CHNGED,0                 VIRGIN BUFFER
         L     R1,CSOUTWK               POINT TO WORK AREA
OPENMSG  L     R1,0(R1)                 FIND LINE TO USE
         L     R15,=A(OPNMSG)           ADDRESSIBILITY
         MVC   0(OPNMSGL,R1),0(R15)
         CLI   DSNAME,X'04'             VTOC?
         BNE   *+8                      NO - INFORMATION ONLY
         MVI   7(R1),C'A'      (ACTION) MAKE OPR SIT UP AND TAKE NOTICE
*LDW4    MVC   9(6,R1),CSJOBNO (INFORM) CHARGE NUMBER...
*LDW4    MVC   16(3,R1),CSINIT          INITIALS
         MVC   9(L'USERID,R1),USERID    CULPRIT                    LDW4
         TM    DCBLIST,X'0F'            NOW, WAS IT OPEN FOR INPUT?
         BZ    DSNWTO                   YES - SO THERE'S NOTHING TO DO
         MVI   7(R1),C'A'               IF UPDATING, ACTION MSG
         MVC   35(6,R1),=CL6'UPDATE'    AND SAY UPDATE
DSNWTO   CLI   DSNAME,X'04'             VTOC HERE?
         MVC   42(44,R1),DISPDSN        MOVE IN DISPLAYABLE DSN    LDW1
         BE    WTOIT                    YES - VOLSER ALREADY SET   LDW1
         MVC   87(2,R1),=C'ON'          ADD                       *LPR*
         MVC   90(6,R1),VOLSER            VOLSER                  *LPR*
WTOIT    BAL   R8,CPUT                  DUMP THE LINE
LOCRET   L     R8,DBLW                  PICK UP RET ADDR
         BR    R8                       ALL OK - RETURN NORMALLY
         SPACE 5
**********************************************************************
********************************  CPUT  ******************************
**********************************************************************
         SPACE 3
*  PASS A LINE TO THE RECORDING SUBROUTINE
*
*  ENTRY CPUT IS ENQUEUE TO PRINT WITH POSSIBLE WTO'S
*  ENTRY CPUT# IS ENQUEUE BUT WITH NO WTO'S (FOR DUMP COMMANDS)
         SPACE 1
CPUT     TM    FLAGS2,LOGF              SEE IF LOGGING
         BNOR  R8                       IF NOT RETURN TO CALLER
         L     R2,CSOUTWK               GET WA ADDR
         LTR   R2,R2                    ANY THERE?
         BZR   R8                       NO, EXIT NOW
         MVI   0(R2),X'20'              SET INITIAL VALUE (WTO)
         TM    FLAGS2,SENSF             IS DS SYS OR URSA?
         BNO   CPUT#                    IF NOT NO WTO
         CLI   GODFLAG,GOD              CAN HE EVER UPDATE?        LDW1
         BE    ISWTOCPT                 YES - DO THE WTO           LDW1
*  IF HE CAN NEVER UPDATE, DON'T WTO.  (USER LOOKING AT SYS1. DS)  LDW1
CPUT#    L     R2,CSOUTWK               DUMP ENTRY - GET WORKAREA PTR
         MVI   0(R2),0                  DON'T ISSUE WTO
ISWTOCPT CLI   CPUTFLAG,YESCSERR        WAS THERE A CSOUT ENQ ERROR?
         BER   R8                       YES - ACT LIKE I ENQUEUED IT
CPUTRUNC LR    R1,CSREG                 GET CSAREA PTR             LDW1
         L     R15,=V(CSOUT)            FIND SUBROUTINE
         BALR  R14,R15                  CALL IT
         LTR   R0,R0                    DID IT WORK?
         BZR   R8                       YES - RETURN TO CALLER
         MVI   CPUTFLAG,YESCSERR        RECORD THAT THERE WAS AN ERROR
         B     BADCSOUT                 AND TELL THE USER OF HIS FATE
         SPACE 5
**********************************************************************
********************************  SETLINE  ***************************
**********************************************************************
         SPACE 3
*  SET UP LINE FOR CPUT
*        INPUT: R1 POINTS TO SINGLE MESSAGE NUMBER IN CHAR FORM
*               R8 RETURN ADDRESS IF NOT PRINTING, +4 IF PRINTING
*        OUTPT: R2 POINTS TO LINE
         SPACE 2
SETLINE  TM    FLAGS2,LOGF              ARE WE LOGGING?
         BNOR  R8                       IF NOT RETURN
         L     R2,CSOUTWK               FIND WORKAREA
         LTR   R2,R2                    ANY THERE?
         BZR   R8                       NO, EXIT ERROR
         L     R2,0(,R2)                FIND THE LINE
         MVC   1(7,R2),=C'ZAP01XI'      MOVE IN MESSAGE NUMBER     LDW4
         MVC   6(1,R2),0(R1)            COPY CORRECT DIGIT
*LDW4    MVC   9(6,R2),CSJOBNO          FIRST PART OF JOBNO
*LDW4    MVC   15(08,R2),=C',XXX TTR'   REST OF MASK
*LDW4    MVC   16(3,R2),CSINIT          INITIALS
         MVC   9(L'USERID,R2),USERID    CULPRIT                    LDW4
         MVC   9+L'USERID+1(3,R2),=C'TTR'                          LDW4
         HEX   (24,R2),TTR,LEN=3        GET THIS TTR               LDW1
         B     4(R8)                    NOW RETURN TO CALLER
         SPACE 5
**********************************************************************
********************************  SETSTRNG  **************************
**********************************************************************
         SPACE 3
*  CONVERT STRING FOR CPUTING
*        INPUT: R1 POINTER TO OUTPUT LINE
*               R8 RETURN ADDRESS
*               R4 EXECUTE LENGTH OF STRING
*               R5 ADDRESS OF DATA TO BE CONVERTED
         SPACE 3
SETSTRNG UNPK  12(9,R13),0(5,R5)        CONVERT FIRST WORD
         UNPK  20(9,R13),4(5,R5)        CONVERT SECOND
         UNPK  28(9,R13),8(5,R5)        CONVERT THIRD
         UNPK  36(9,R13),12(5,R5)       CONVERT FOURTH AND LAST
         TR    12(32,R13),TRHEX         FIX UP HEX
         LTR   R4,R4                    ANY?
         BMR   R8                       NO, LEAVE IT BLANK
         LA    R15,1(R4,R4)             GET EXECUTE LENGTH OF HEX
         EX    R15,CPMVC                MOVE CONVERTED DATA
         MVI   35(R1),C''''                                        LDW1
         EX    R4,SETSTRMV              MOVE CHAR FORM TO BUFFER   LDW1
         L     R15,TRTABADD             GET RIGHT TRTAB PTR        LDW1
         EX    R4,SETSTRTR              TRANSLATE TO RIGHT CHARSET LDW1
         LA    R15,36+1(R4,R1)                                     LDW1
         MVI   0(R15),C''''                                        LDW1
         BR    R8                       RETURN
         SPACE 1
CPMVC    MVC   0(0,R1),12(R13)          <<< EXECUTED >>>
SETSTRMV MVC   36(0,R1),0(R5)           << EXECUTED >>             LDW1
SETSTRTR TR    36(0,R1),0(R15)          << EXECUTED >>             LDW1
         SPACE 5
**********************************************************************
********************************  SETMSG  *************************LDW1
**********************************************************************
         SPACE 3
*  MOVE MSG AND HYPHENS TO CORRECT POS ON SCREEN, DEPENDING ON     LDW1
*  WHETHER IN FULLSCREEN MODE                                      LDW1
*        INPUT:  R1 POINTS TO CL20'MSG'                            LDW1
         SPACE 1
SETMSG   LH    R1,0(,R8)                GET MSG OFFSET             LDW1
         AR    R1,R12                   GET ADDR                   LDW1
SETMSGX  TM    FLAGS3,F3270             FULLSCREEN?                LDW5
         BZ    SETMSG1                  NO - SHORTER MSG           LDW3
         MVC   LINE19+27(20),0(R1)      MOVE IT TO CENTER          LDW1
         MVC   LINE19+17(9),=9C'='      MAKE IT FANCY              LDW1
         MVC   LINE19+48(9),=9C'='      BUT DON'T GET CARRIED AWAY LDW1
         B     2(,R8)                   RETURN PAST OFFSET         LDW1
         SPACE 1
SETMSG1  MVC   LINE19+23(20),0(R1)      MOVE IT TO LEFT OF CENTER  LDW1
         MVC   LINE19+17(3),=9C'='      MAKE IT FANCY              LDW1
         B     2(,R8)                   RETURN PAST OFFSET         LDW1
         SPACE 5
**********************************************************************
********************************  BOTCH  *****************************
**********************************************************************
         SPACE 3
*  DISPLAY ERROR MESSAGES
*  MOVE IN MSG AND HYPHENS AROUND IT TO ERROR MSG LINE ON SCREEN.
*  TRACE WILL BE DISABLED.  IF SYNTAX ERROR MSG IS TO BE DISPLAYED,
*  THE COLUMN IN QUESTION IS COMPUTED AND DISPLAYED WITH THE MSG.
*
*  R2 = PTR TO MESSAGE
*  R1 = PTR TO INVALID LOC IN EXPRESSION (IF APPLICABLE)
         SPACE 1
BOTCH    XR    15,15                    CLEAR R15
         IC    R15,0(,R2)               GET LENGTH
         CH    R15,=H'20'               SEE IF WE ARE USING MSG
         BH    BOTCH0                   IF NOT ASSUME LNTH 20
         MVC   TEMP2(20),BLANKS         CLEAR AN AREA              LDW1
         BCTR  R15,0                    DECREMENT FOR EXECUTE
         MVC   TEMP2(0),1(R2)           << EXECUTED >>             LDW1
         EX    15,*-6                   MOVE IN MSG
         LA    R2,TEMP2                 POINT TO MSG               LDW1
         SPACE 1
         CLC   INVEXP+1(16),TEMP2       IS THIS AN INV EXPR MSG?   LDW1
         BNE   BOTCH0                   NO - GO ON                 LDW1
*LDW1    LA    R3,TEMP2                 PT TO REPLY
         LA    R3,REP                   PT TO REPLY                LDW1
         SR    R1,R3                    GET OFFSET TO BAD HEX
         LA    R1,1(R1)                 MAKE THE OFFSET A COLUMN #
         CVD   R1,TEMP                  YES - GET OFFSET OF ERROR INTO
         UNPK  TEMP2+18(2),TEMP+6(2)    THE EXPRESSION AND         LDW1
         OI    TEMP2+19,C'0'            MOVE IT TO THE SCREEN      LDW1
         BCTR  R1,0                     GET CURSOR POSITION        LDW1
         STH   R1,CURPOS                SET IT                     LDW1
         SPACE 1
BOTCH0   LR    R1,R2                    GET MSG ADDR               LDW1
         LA    R8,NEWDSPNT-2            FAKE THE RETURN POINT      LDW1
         B     SETMSGX                  SPECIAL ENTRY PT           LDW1
         SPACE 5
**********************************************************************
********************************  EODAD  *****************************
**********************************************************************
         SPACE 3
*  END-OF-FILE ROUTINE                                             LDW1
*  IF EOF'S ARE NOT COUNTED AS BLOCKS (AS IN A PDS), THEN DISPLAY
*  END OF FILE;  OTHERWISE HOP THEM
         SPACE 2
EODAD    LR    R2,R8                    SAVE RET TO READ           LDW1
         BAL   R8,CLEAR                 CLEAR SCREEN
         MVC   LINE05,BLANKS            CLR TOP ERR MSG SO CAN SAY EOF
*  LENGTH OF EOF RECORD IS ALREADY SET                             LDW1
         MVC   LINE05+27(20),EOFMSG     TELL HIM END-OF-FILE       LDW1
         MVI   TTR+3,NOSEQRD            TURN OFF SEQ READ          LDW1
         CLI   EOFRET,YESEOF            EOF ALLOWED HERE?
         BE    NEW$DISP                 YES - SO EOF ALREADY       LDW1
         BR    R2                       NO - EXIT FROM READBLK (EOF)
*
*  THUS UNDER CERTAIN CIRCUMSTANCES EOF'S ARE COUNTED AS RECORDS.
*
         SPACE 5
**********************************************************************
*********************************  CHKPT  ****************************
**********************************************************************
         SPACE 2
CHKPT    TM    FLAGS2,MUSTZAP           BLOCK NEED A ZAP 1ST?
         BNOR  R8                       NO, LET COMMAND THRU
*LDW1    NI    FLAGS2,255-MUSTZAP       YES, WE TOLD HIM ONCE
*LDW1    LA    R2,=CL20'**** ZAP NEEDED ****' TELL HIM, IGNORE COMMAND
*LDW1    B     BOTCH                    HE CAN ALWAYS DO IT AGAIN
         CLC   REP,PREVREP              SAME CMD TWICE IN A ROW?   LDW4
         BER   R8                       YES - LET HIM DO IT        LDW4
         MVC   LINE19+11(58),=C'******** ENTER "ZAP" OR RE-ENTER PREVIO$
               US COMMAND ********'                                LDW4
         B     NEWDSPNT                 TELL HIM HE CAN'T LEAVE    LDW1
         SPACE 5
**********************************************************************
**********************************  KILL3270  *********************LDW1
**********************************************************************
         SPACE 2
KILL3270 TM    FLAGS3,FSMODE            FULL SCREEN MODE ON?       LDW5
         BNOR  R8                       NO - JUST RETURN           LDW1
         SPACE 1
         TPUT  CLR3270,CLR3270L,FULLSCR        CLEAR SCREEN        SDM5
         SPACE 1
         AIF   (&MVT).MVT04                                        LDW5
         STFSMODE  OFF                  TURN OFF FULLSCREEN MODE   LDW1
         SPACE 1
.MVT04   NI    FLAGS3,255-FSMODE        IT'S OFF NOW               LDW5
         BR    R8                       RETURN TO CALLER           LDW1
         TITLE 'ZAP --- CONSTANTS, DATA,FLAGS, ETC'
*%       PRINT NOGEN                                               LDW1
IOERRMSG DC    CL40' ***** I/O ERROR: XXXXXXXXXXXXXXX *****'
INVMEM   DC    CL20'MEMBER NOT FOUND'
WRITERR  MSGZ  'WRITE NOT ALLOWED'
EOFMSG   DC    CL20'*** END OF FILE ***'
ASCIIMSG MSGZ  'ASCII TRANSLATION'
ZCODEMSG MSGZ  'ZCODE TRANSLATION'
EBCDCMSG MSGZ  'EBCDIC TRANSLATION'
INVFMSG  MSGZ  'NO FORWARD CHAIN'
INVBMSG  MSGZ  'NO BACKWARD CHAIN'
INVEXP   MSGZ  'SYNTAX ERROR COL. '                                LDW1
LINMSG   MSGZ  'SCAN NOT IN EFFECT'
TABFULL  MSGZ  'DEFINE TABLE FULL'
REDEFMSG MSGZ  'SYMBOL REDEFINED'
LASTINV  MSGZ  'INVALID IN VTOC'
NOTVTOC  MSGZ  'DATASET NOT VTOC'                                  LDW1
DEFRESET MSGZ  'DEFINE TABLE RESET'
REC0INV  MSGZ  'RECORD 0 INVALID'
INVCOM   MSGZ  'INVALID COMMAND'
NOMCOM   MSGZ  'NOT PARTITIONED'
INVOPCOD MSGZ  'INVALID OP CODE '
INVDEC   MSGZ  'INVALID DECIMAL'
TTRSMALL DC    CL20'TTR < 000001 INVALID'                          LDW1
LENERR   MSGZ  'LENGTH INVALID'
NOTJQMSG MSGZ  'DATA SET NOT JOBQ'
STORMSG  DC    CL20'NOTE: NOT UPDATING'
BACKDUMP DC    CL20'REVERSE DUMP INVALID'                          LDW1
NOCSOUT  MSGZ  '  UNABLE TO RECORD'
DUMPWORK MSGZ  '  DUMP SUCCESSFUL'
NAMEMNF  MSGZ  'NAME INVALID'                                   *N*
LOGONMSG MSGZ  'LOGGING'                                           LDW1
NOMEMFND DC    CL20'*NO DIRECTORY ENTRY*'                          LDW1
BADEQUAL MSGZ  'INVALID SYMBOL'                                    LDW1
OUCH     MSGZ  'OUCH!!'                                            LDW1
         PRINT GEN                                                 LDW3
         SPACE 8    (EJECT)                                        LDW1
*        LITERAL POOL
         SPACE 2
         LTORG
         EJECT
*                                                                  LDW2
*  TABLE TO GENERATE VALID 3270 CHARS FROM 6 BIT CODELDW2
*                                                                  LDW2
TR3270   DC    X'40C1C2C3C4C5C6C7C8C94A4B4C4D4E4F'                 LDW2
         DC    X'50D1D2D3D4D5D6D7D8D95A5B5C5D5E5F'                 LDW2
         DC    X'6061E2E3E4E5E6E7E8E96A6B6C6D6E6F'                 LDW2
         DC    X'F0F1F2F3F4F5F6F7F8F97A7B7C7D7E7F'                 LDW2
         SPACE 2
*
*  HEX TO CHAR HEX AND CHAR TO HEX TRTAB
*
         DC    X'0A0B0C0D0E0F'          FOR CHAR TO HEX            LDW1
         DC    41C'.'                   WASTED SPACE               LDW1
NUMBERS  DC    C'0123456789ABCDEF'
TRHEX    EQU   *-256
N0       EQU   NUMBERS+0
N1       EQU   NUMBERS+1
N2       EQU   NUMBERS+2
N3       EQU   NUMBERS+3
N4       EQU   NUMBERS+4
N5       EQU   NUMBERS+5
N6       EQU   NUMBERS+6
N7       EQU   NUMBERS+7
N8       EQU   NUMBERS+8
N9       EQU   NUMBERS+9
         SPACE 2
*
*  DUMP FORMAT TRTAB (*** ASCII ***)
*
TRCHARA  DC    256C'.'
         ORG   TRCHARA+X'20'
         DC    C' !"#$%&&''()*+,-./0123456789:;<=>?'
         ORG   TRCHARA+X'40'
         DC    C'@ABCDEFGHIJKLMNOPQRSTUVWXYZ...._'
         ORG   TRCHARA+X'60'
         DC    X'79818283848586878889919293949596'
         ORG   TRCHARA+X'70'
         DC    X'979899A2A3A4A5A6A7A8A94B4F4B5F4B'
         ORG   TRCHARA+X'A0'
         DC    C' !"#$%&&''()*+,-./'
         DC    C'0123456789'
         DC    C':;<=>?'
         ORG   TRCHARA+X'C0'
         DC    C'@ABCDEFGHIJKLMNOPQRSTUVWXYZ...._'
         ORG   TRCHARA+X'E0'
         DC    X'79818283848586878889919293949596'
         ORG   TRCHARA+X'F0'
         DC    X'979899A2A3A4A5A6A7A8A94B4F4B5F4B'
         SPACE 3
*
*  DUMP FORMAT TRTAB (*** ZCODE ***)
*
TRCHARZ  DC    256C'.'
         ORG   TRCHARZ+X'18'
         DC    X'C0D0'
         ORG   TRCHARZ+X'25'
         DC    C'$'
         ORG   TRCHARZ+X'40'
         DC    C' ABCDEFGHIJKLMNOPQRSTUVWXYZ'
         DC    C'_ABCDEFGHIJKLMNOPQRSTUVWXYZ'
         DC    C'=0123456789'
         ORG   TRCHARZ+X'90'
         DC    C'+-'
         ORG   TRCHARZ+X'9E'
         DC    C'<'
         ORG   TRCHARZ+X'A0'
         DC    C'='
         ORG   TRCHARZ+X'A2'
         DC    C'>'
         ORG   TRCHARZ+X'A4'
         DC    C'-',X'5A'         EXCLAIM POINT
         ORG   TRCHARZ+X'B5'
         DC    C',?'
         ORG   TRCHARZ+X'C4'
         DC    C';:'
         ORG   TRCHARZ+X'F9'
         DC    C'#'
*        ORG   TRCHARZ+4
*        DC    C'$'
*        ORG   TRCHARZ+14
*        DC    C'??();/'
*        ORG   TRCHARZ+26
*        DC    C'+-*/*...?V<.=.>'
*        ORG   TRCHARZ+47
*        DC    C',?'
*        ORG   TRCHARZ+54
*        DC    C'Â¬'
*        ORG   TRCHARZ+61
*        DC    C'_'
*        ORG   TRCHARZ+82
*        DC    C'??'
*        ORG   TRCHARZ+86
*        DC    C'ABCDEFGHIJKLMNOPQRSTUVWXYZ-'
*        ORG   TRCHARZ+113
*        DC    C'ABCDEFGHIJKLMNOPQRSTUVWXYZ='
*        ORG   TRCHARZ+140
*        DC    C'0123456789.. '':'
         ORG   ,
         SPACE 3
*
*  DUMP FORMAT TRTAB (*** EBCDIC ***)
*
TRCHARE  DC    256C'.'
         ORG   TRCHARE+C' '
         DC    C' '
         ORG   TRCHARE+X'4A'            CENT SIGN
         DC    X'4A',C'.<(+|&&'
         ORG   TRCHARE+X'5A'            EXCLAMATION PT
         DC    X'5A',C'$*);Â¬-/'
         ORG   TRCHARE+C','
         DC    C',%_>?'
         ORG   TRCHARE+C':'
         DC    C':#@''=',X'7F'          DOUBLE QUOTE
         ORG   TRCHARE+X'81'
         DC    9AL1(*-TRCHARE)          LOWER CASE A-I
         ORG   TRCHARE+X'91'
         DC    9AL1(*-TRCHARE)          LOWER CASE J-R
         ORG   TRCHARE+X'A2'
         DC    8AL1(*-TRCHARE)          LOWER CASE S-Z
         ORG   TRCHARE+C'A'
         DC    9AL1(*-TRCHARE)          UPPER CASE A-I
         ORG   TRCHARE+C'J'
         DC    9AL1(*-TRCHARE)          UPPER CASE J-R
         ORG   TRCHARE+C'S'
         DC    8AL1(*-TRCHARE)          UPPER CASE S-Z
         ORG   TRCHARE+C'0'
         DC    10AL1(*-TRCHARE)         NUBERS
         ORG   ,
         SPACE 5                                                   MAS2
EDMASK   DC    X'402020202020202020202120'
*
DUMPOFFS DC    AL1(9,18,27,36,48,57,66,75)
         SPACE 2
MAXWIDTH DC    A((LINE19-LINE06-$I)/$I/2)                          LDW1
         SPACE 2
RECFMU   EQU   X'C0'                    RECFM=U
         SPACE 1
YESSYMB  EQU   X'FF'                    EXP LOOK AT SYMBOL TAB
NOSYMB   EQU   X'00'                    EXP LOOK AT SYMBOL TAB
         SPACE 1
YESTRACE EQU   X'00'                    TRACE IN EFFECT
NOTRACE  EQU   X'FF'                    NO TRACE
         SPACE 1
YESCONTL EQU   X'80'                    SCAN CONTINUE IS OK
YESCONTS EQU   X'40'                    S,X,O,N NO OPERANDS OK
YESCONTT EQU   X'20'                    SET NO OPERAND OK
         SPACE 1
YESSYN   EQU   X'FF'                    SYNAD I/O ERROR HAS OCCURRED
NOSYN    EQU   X'00'                    NO ERROR HAS OCCURRED
         SPACE 2
YESCSERR EQU   X'FF'                    CSOUT CANNOT ENQ IN THIS DS
NOCSERR  EQU   X'00'                    CSOUT HAS NO PROBLEMS
         SPACE 1
GOD      EQU   X'FF'                    ONLY HE CAN CHANGE HIS MIND
NOGOD    EQU   X'00'                    TOUGH BANANAS
         SPACE 1
YESEOF   EQU   X'FF'                    DO NOT IGNORE EOF'S
NOEOF    EQU   X'00'                    TREAT EOF'S AS DATA BLK
         SPACE 1
CHGIDR   EQU   X'FF'                    WE HAVE CHANGED THE IDR
NOCHGIDR EQU   X'00'                    WE HAVE NOT UPDATED IT YET
         SPACE 1
SEQREAD  EQU   X'01'                    READ NEXT RECORD           LDW1
NOSEQRD  EQU   X'00'                    READ THIS RECORD           LDW1
         SPACE 2
OLD      DC    F'1',A(HERALD)
HERALD   DC    H'10',H'0',CL6' ZAP: '
         SPACE 2
PTPBDC   PUTLINE  OUTPUT=(LINEDESC-TSDSECT,TERM,SINGLE,DATA),      LDW1$
               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),MF=L             LDW1
PTPBDCL  EQU   *-PTPBDC                                            LDW1
         SPACE 1
PGPBDC   PUTGET OUTPUT=(OLD,SINGLE,MODE),TERMGET=(EDIT,WAIT),          X
               TERMPUT=(ASIS,WAIT,NOHOLD,NOBREAK),MF=L
PGPBDCL  EQU   *-PGPBDC
         SPACE 3
CTL3270C DC    X'C3'                    WCC: RST KEB+RST MDT       SDM4
         DC    X'115D7F114040'          SPF/TCAM PREFIX            LDW1
         SPACE 1
END3270C DC    X'3C404000'              CLEAR WITH NULLS TO 1,1    SDM5
END3270M DC    X'11C1D113'              INSERT CURSOR AT 2,2       SDM5
         SPACE 1
CLR3270  DC    X'C3'                    WCC: RST KEB+RST MDT       SDM5
         DC    X'115D7E114040'          SPF/TCAM PREFIX (ADDR 1,1) LDW1
         DC    X'3C404000'              CLEAR WITH NULLS TO 1,1    LDW1
         DC    X'13'                    INSERT CURSOR AT TOP       LDW1
CLR3270L EQU   *-CLR3270                LENGTH                     SDM5
         SPACE 2
*  CONSTANTS FOR DISPLAY ROUTINE
DSPCON80 DC    F'-16'                   MASK FOR HIGH ORDER BITS   LDW1
         DC    F'15'                    MASK FOR LOW  ORDER BITS   LDW1
         DC    H'80'                    LINE LENGTH                LDW1
         DC    H'96'                    (HEX/SCREEN)/2             LDW1
         DC    H'16'                    HEX BYTES / LINE           LDW1
         DC    H'32'                    TWICE THE ABOVE            LDW1
         DC    AL1(7,12,12,17,18,23,23,28,30,35,35,40,41,46,46,51) LDW1
DISPTR80 DC    AL1(48)                  BLANK               +08    LDW1
         DC    AL1(16,17,18,19,48)      BYTES 01, 02        +09    LDW1
         DC    AL1(20,21,22,23,48,48)   BYTES 03, 04        +14    LDW1
         DC    AL1(24,25,26,27,48)      BYTES 05, 06        +20    LDW1
         DC    AL1(28,29,30,31,48,48,48)      07, 08        +25    LDW1
         DC    AL1(32,33,34,35,48)            09, 10        +32    LDW1
         DC    AL1(36,37,38,39,48,48)         11, 12        +37    LDW1
         DC    AL1(40,41,42,43,48)            13, 14        +43    LDW1
         DC    AL1(44,45,46,47)               15, 16        +48    LDW1
         DC    AL1(48,48,48,49)         '   |'              +52    LDW1
         DC    AL1(0,1,2,3,4,5,6,7)     FIRST 8 CHARS       +56    LDW1
         DC    AL1(8,9,10,11,12,13,14,15)  LAST 8 CHARS     +64    LDW1
         DC    AL1(49)                                      +72    LDW1
         SPACE 2
DSPCON40 DC    F'-8'                    MASK FOR HIGH ORDER BITS   LDW1
         DC    F'7'                     MASK FOR LOW  ORDER BITS   LDW1
         DC    H'40'                    LINE LENGTH                LDW1
         DC    H'48'                    (HEX/SCREEN)/2             LDW1
         DC    H'8'                     HEX BYTES / LINE           LDW1
         DC    H'16'                    TWICE THE ABOVE            LDW1
         DC    X'060B0B101116161B'      TABS FOR CARET ON SCREEN
*%       DC    8X'00'                   PADDING                    LDW1
DISPTR40 DC    AL1(16,17,18,19,48)      BYTES 01, 02        +08    LDW1
         DC    AL1(20,21,22,23,48,48)   BYTES 03, 04        +13    LDW1
         DC    AL1(24,25,26,27,48)      BYTES 05, 06        +19    LDW1
         DC    AL1(28,29,30,31)         BYTES 07, 08        +24    LDW1
         DC    AL1(48,48,49)            '  |'               +28    LDW1
         DC    AL1(0,1,2,3,4,5,6,7)     CHARACTERS          +31    LDW1
         DC    AL1(49)                  '|'                 +39    LDW1
*%       DC    34AL1(48)
         SPACE 2
CCWLIST  CCW   X'03',0,X'40',1          NOP FOR NOW                LDW1
         CCW   X'31',0,X'40',5          SEARCH ID EQ               LDW1
         CCW   X'08',0,X'00',0          TIC *-8                    LDW1
         CCW   X'1E',0,X'20',0          READ CKD                   LDW1
         SPACE 1
         CCW   X'31',0,X'40',5          SEARCH ID EQ               LDW1
         CCW   X'08',0,X'00',0          TIC *-8                    LDW1
         CCW   X'0D',0,X'20',0          WRITE KD                   LDW1
         SPACE 1
         CCW   X'16',0,X'20',0          READ R0                    LDW1
         SPACE 1
         CCW   X'16',0,X'70',1          READ R0 TO ORIENT          LDW1
         CCW   X'E9',0,X'40',8          SEARCH KEY EQ/HI MT        LDW1
         CCW   X'08',0,X'00',0          TIC *-8                    LDW1
         CCW   X'0E',0,X'00',8+256      READ KD                    LDW1
         SPACE 1
         CCW   X'31',0,X'40',5          SEARCH ID EQ               LDW1
         CCW   X'08',0,X'00',0          TIC *-8                    LDW1
         CCW   X'1D',0,X'20',0          WRITE CKD                  LDW1
         SPACE 2                                                   LDW3
PATCH    DC    200S(*)                                             LDW1
         SPACE 1
         OACDROP R12,R11,R10,R9                                     MVS
         TITLE 'ZAP --- EXP: EXPRESSION ANALYZER'
         SPACE 1
*        EXP: THIS ROUTINE WILL ANALYZE AN EXPRESSION PASSED TO IT
*        AND RETURN ITS VALUE CONCATENATED WITH A STARTING VALUE.
*
*        INPUT: R13 - SAVEAREA
*               R14 - RETURN ADDRESS
*                     IF EXPOPT IS ZERO - TABLE NOT SCANNED
*                     ELSE SYMBOL TABLE IS SCANNED.
*               R2  - STARTING VALUE OF '*'                        LDW1
*               R1  - ADDRESS OF EXPRESSION TO PARSE
*               R0  - LENGTH OF EXPRESSION TO PARSE
*        OUTPUT:R1  - RETURN CODE
*                     IF NEGATIVE: NO ERRORS DETECTED
*                     IF ZERO OR POSITIVE AN ERROR OCCURED AT ADDRESS
*                     GIVEN IN R1
*               R15 - IF NO ERROR, THE NEW VALUE CALCULATED.
         SPACE 1
*  THIS ROUTINE WAS WRITTEN BY DON WORTH.
         SPACE 1
*  MODIFIED BY LEONARD D. WOREN TO DO MULT & DIV    12-27-78       LDW1
         SPACE 1
         USING TSDSECT,R13
EXP      STM   R14,R1,EXPARMS+12        SAVE CALLER'S REGS ONE PLACE
         STM   R2,R12,12+(4*4)(R13)     SAVE REST IN OTHER PLACE
         LR    R12,R15                  GET BASE                   LDW1
         USING EXP,R12                                             LDW1
         LR    R4,R2                    ALWAYS BEGIN WITH *        LDW1
         ST    R2,EXPSTART              SAVE VALUE OF "*"          LDW1
         LR    R3,R1                    START SCAN
         BCTR  R3,0                     HE WILL ADD ONE FIRST
         LR    R2,R0                    BCT INDEX
*LDW1    XC    EXPFLAG(2),EXPFLAG       RESET FLAGS
         MVI   EXPFLAG+1,0              RESET FLAGS                LDW1
         LA    R2,1(R2)                 ALLOW FOR FIRST PASS
         ST    R1,GORF                  FIRST BAD SPOT
         B     EXPBACK                  START AFTER ITEM
         SPACE 1
*        SEE WHAT NEXT ITEM IS
         SPACE 1
EXPITEM  LTR   R2,R2                    ANYTHING LEFT?
         BP    EXPON                    YES
         ST    R4,EXPSTART              NEW STARTER
         OI    EXPPTR,X'80'             NO ERROR
         B     EXPRET                   RETURN
EXPON    CLI   0(R3),C' '               BLANK?
         BNE   EXPCHECK                 NO, WE CAN USE IT
EXPNEXT  LA    R3,1(R3)                 NEXT SPOT TO CHECK
         BCT   R2,EXPITEM               CONTINUE
         MVI   EXPFLAG+1,0              NOTHING FOR NEXT TIME
         B     EXPCONV                  WHEN AT END, USE LAST IF ANY
EXPCHECK ST    R3,GORF                  KEEP TRACK OF WHERE WE ARE
         CLI   0(R3),C'*'               CURRENT LOC OR MULT?
*LDW1    BE    EXPCURR                  YES, GO LOAD IT
         BE    EXPSTAR                  YES, GO DECIDE WHICH       LDW1
         CLI   0(R3),C'+'               ADD?
         BE    EXPADD                   YES
         CLI   0(R3),C'-'               SUBTRACT?
         BE    EXPSUB                   YES
         CLI   0(R3),C'.'               DECIMAL DONE?
         BE    EXPDEC                   YES
         CLI   0(R3),C'/'               DIVIDE?                    LDW1
         BE    EXPDIV                   YES                        LDW1
         OI    EXPFLAG+1,EXPEXOPR       EXPECTING OPERATOR NOW     LDW1
         SPACE 1
*        IF NO TERMINATOR IS FOUND, SAVE UP FOR LATER
         SPACE 1
         LA    R0,EXPWORK+8             POINT PAST IT
         CR    R0,R5                    TOO FAR?
         BNH   EXPERR                   YES
         MVC   0(1,R5),0(R3)            COPY IT TO WORKAREA
         LA    R5,1(R5)
         B     EXPNEXT                  CONTINUE
         SPACE 1
*        IF AN ERROR IS DETECTED, PASS BACK ADDR OF IT
         SPACE 1
EXPERR   MVC   EXPPTR(4),GORF           SAVE POINTER FOR RETURN
EXPRET   MVI   EXPOPT,NOSYMB            RESET NO SYMB TAB LOOKUP
         LM    R14,R1,EXPARMS+X'C'      GET RETURN REGS
         LM    R2,R12,12+(4*4)(R13)     RESTORE REST OF REGS FROM SAVE
         BR    R14
         SPACE 2
*        '*' WAS ENTERED, DECIDE IF CURRENT LOC OR MULTIPLY        LDW1
EXPSTAR  TM    EXPFLAG+1,EXPEXOPR       WHICH IS THIS?             LDW1
         BO    EXPMULT                  MULTIPLY.                  LDW1
         SPACE 1
*        USE CURRENT VALUE
         SPACE 1
EXPCURR  L     R15,EXPSTART             GET STARTING VALUE
         MVI   EXPFLAG+1,EXPEXOPR       EXPECTING OPERATOR NOW     LDW1
         B     EXPUSE                   AND GO USE IT
         SPACE 1
*        IF '+' WAS ENTERED, TERMINATE PREVIOUS AND SET FLAG
         SPACE 1
EXPADD   MVI   EXPFLAG+1,EXPFPLUS       INDICATE ADD NEXT TIME
         B     EXPCONV                  GO CONVERT IT
         SPACE 1
*        IF '-' WAS ENTERED, TERMINATE PREVIOUS AND SET FLAG
         SPACE 1
EXPSUB   MVI   EXPFLAG+1,EXPFMINS       INDICATE ADD NEXT TIME
         B     EXPCONV                  GO CONVERT IT
         SPACE 1
*        IF '*' WAS ENTERED, TERMINATE PREVIOUS AND SET FLAG       LDW1
         SPACE 1
EXPMULT  MVI   EXPFLAG+1,EXPFMULT       INDICATE MULT NEXT TIME    LDW1
         B     EXPCONV                  GO CONVERT IT              LDW1
         SPACE 1
*        IF '/' WAS ENTERED, TERMINATE PREVIOUS AND SET FLAG       LDW1
         SPACE 1
EXPDIV   MVI   EXPFLAG+1,EXPFDIV        INDICATE DIV NEXT TIME     LDW1
         B     EXPCONV                  GO CONVERT IT              LDW1
         SPACE 1
*        IF '.' WAS ENTERED, TERMINATE PREVIOUS AS DECIMAL
         SPACE 1
EXPDEC   OI    EXPFLAG,EXPFDEC          INDICATE DECIMAL THIS TIM
*        B     EXPCONV                  GO CONVERT IT
         SPACE 1
*        WHEN UP TO 8 CHARS SCANNED OUT, CONVERT THEM APPROPRIATELY
         SPACE 1
EXPCONV  LA    R15,EXPWORK+1            POINT TO START
         SR    R5,R15                   FIND EXECUTE LENGTH
         LR    R15,R5                   SAVE IT                    LDW1
         BNM   EXPCOK                   IF SOMETHINGS THERE, CONTINUE
         TM    EXPFLAG,EXPFTERM         SOMETHING EXPECTED?
         BZ    EXPBACK                  NO, IGNORE THIS TIME
         B     EXPERR                   OTHERWISE ITS NO GOOD
EXPCOK   MVC   DBLW(0),EXPWORK          <<<  EXECUTED  >>>
         MVI   DBLW,C' '
         MVC   DBLW+1(7),DBLW           CLEAR AN AREA
         EX    R15,EXPCOK               MOVE TO IT
         SPACE 1
*        IF SYMBOL TABLE SCAN REQUESTED, DO SO
         SPACE 1
         CLI   EXPOPT,NOSYMB            SCAN LABEL TABLE?
         BE    EXPNTAB                  NO, GO ON
         TM    EXPFLAG,EXPFDEC          DECIMAL?
         BO    EXPNTAB                  THEN CAN'T BE THIS
         L     R14,AIDEFTAB             POINT TO TABLE
EXPIDSCN CLI   0(R14),255               END OF TABLE?
         BE    EXPNTAB                  THEN WE DIDN'T FIND IT
         CLC   0(8,R14),DBLW            SEE IF THIS IS HIS LABEL
         BE    EXPGLAB                  YES, IT IS
         LA    R14,10(R14)              NEXT ENTRY IN TABLE
         B     EXPIDSCN                 GO ON
EXPGLAB  LH    R15,8(R14)               GET VALUE OF IT
         B     EXPUSE                   AND USE IT
         SPACE 1
*        VALIDITY CHECK FOR NUMERICS
         SPACE 1
EXPNTAB  LA    R0,1(R15)                GET LENGTH OF THINGY
         LA    R14,EXPWORK              FIND IT
EXPCCHK  CLI   0(R14),C'0'              IF ITS NUMERIC I ALWAYS LIKE IT
         BNL   EXPCGOOD                 GO
         TM    EXPFLAG,EXPFDEC          DECIMAL?
         BO    EXPERR                   THEN NO GOOD
         CLI   0(R14),C'A'              OTHERWISE NOT LESS THAN A
         BL    EXPERR                   GO
         CLI   0(R14),C'F'              OR GREATER THAN F
         BH    EXPERR                   GO
         IC    R1,0(R14)                GET IT
         AH    R1,EXPFUDGE              MAKE FA-FF
         STC   R1,0(R14)                REPLACE IT
EXPCGOOD LA    R14,1(R14)               NEXT
         BCT   R0,EXPCCHK               CONTINUE CHECKING
         SPACE 1
*        CONVERT DECIMAL
         SPACE 1
         TM    EXPFLAG,EXPFDEC          DECIMAL?
         BZ    EXPNDEC                  NO
EXPPACK  PACK  DBLW(8),EXPWORK(0)       <<< EXECUTED >>>
         EX    R15,EXPPACK              PACK IT
         CVB   R15,DBLW                 CONVERT IT
         B     EXPUSE                   AND USE IT
         SPACE 1
*        CONVERT FOR HEX
         SPACE 1
EXPNDEC  LA    R15,1(R15)               DO AN EXTRA CHAR
         EX    R15,EXPPACK              PACK IT
         LM    R14,R15,DBLW             GET OFFSET
         SRDL  R14,8                    SHIFT OUT BAD BYTE (FLIP)
*        B     EXPUSE                   GO USE IT
         SPACE 1
*        WHEN VALUE OBTAINED, ADD, SUB OR WHATEVER
         SPACE 1
EXPUSE   TM    EXPFLAG,EXPFPLUS         ADDING?
         BO    EXPUADD                  YES
         TM    EXPFLAG,EXPFMINS         SUBTRACTING?
         BO    EXPUSUB                  YES
         TM    EXPFLAG,EXPFMULT         MULTIPLYING?               LDW1
         BO    EXPUMULT                 YES                        LDW1
         TM    EXPFLAG,EXPFDIV          DIVIDING?                  LDW1
         BO    EXPUDIV                  YES                        LDW1
         LR    R4,R15                   ELSE, OVERLAY
         SPACE 1
EXPBACK  LA    R5,EXPWORK               START AGAIN
         MVC   EXPFLAG(1),EXPFLAG+1     NEW FLAGS
         MVI   EXPFLAG+1,0              NO MORE
         B     EXPNEXT                  SKIP LAST ONE
EXPUADD  AR    R4,R15
         B     EXPBACK                  GO ON
EXPUSUB  SR    R4,R15                   SUBTRACT
         B     EXPBACK                  GO
         SPACE 1
EXPUMULT LR    R5,R4                    GET INTO ODD REG           LDW1
         MR    R5-1,R15                 DO THE MULTIPLY            LDW1
         LR    R4,R5                    GET RESULT IN CORRECT REG  LDW1
         B     EXPBACK                  GO ON                      LDW1
         SPACE 1
EXPUDIV  LR    R5,R4                    GET INTO ODD REG           LDW1
         XR    R4,R4                    CLEAR FOR DIVIDE           LDW1
         LTR   R15,R15                  DIVIDE BY 0?               LDW1
         BZ    EXPERR                   YES - ERROR                LDW1
         DR    R5-1,R15                 DO THE MULTIPLY            LDW1
         LR    R4,R5                    GET RESULT IN CORRECT REG  LDW1
         B     EXPBACK                  GO ON                      LDW1
         SPACE 5
*
*  EXP'S DATA
*
         SPACE 1
EXPFUDGE DC    0H'0',XL2'0039'
EXPFPLUS EQU   X'80'                    ADD NEXT VALUE
EXPFMINS EQU   X'40'                    SUBTRACT NEXT VALUE
EXPFDEC  EQU   X'20'
EXPFMULT EQU   X'10'                    MULT NEXT VALUE            LDW1
EXPFDIV  EQU   X'08'                    DIV NEXT VALUE             LDW1
EXPEXOPR EQU   X'04'                    EXPECTING OPERATOR NEXT    LDW1
*  SOMETHING REQUIRED FLAG:
EXPFTERM EQU   EXPFPLUS+EXPFMINS+EXPFDEC+EXPFMULT+EXPFDIV          LDW1
         SPACE 5
         PRINT GEN
         LTORG
         SPACE 2
         DROP  ,                                                   LDW1
         EJECT ,                                                   LDW1
DCBMSK   DCB   MACRF=E,DDNAME=SYSLIB,DEVD=DA                       LDW1
         DC    5F'0'                    STUPID MACRO & SYSTEM      LDW1
DCBUL    EQU   *-DCBMSK
         SPACE 2
OPNMSG   DC    C'0ZAP009I CAW999.III HAS OPENED FOR INPUT '        LDW4
OPNMSGL  EQU   *-OPNMSG
         EJECT
*
*  COMMAND TABLE
*
COMTAB   DC    0F'0'                             * = NO HELP INFO
         DC    AL1(6),CL8'VERBOSE ',AL3(VERBOSE)
         DC    AL1(5),CL8'NOT3270 ',AL3(NOT3270)    %%TEMP%%     * LDW1
         DC    AL1(5),CL8'YES3270 ',AL3(YES3270)    %%TEMP%%     * LDW1
         DC    AL1(6),CL8'WHATMEM ',AL3(WHATMEM)                   LDW1
         DC    AL1(6),CL8'//DEBUG ',AL3(DIEFAST)                 * LDW1
         DC    AL1(6),CL8'LASTDS1 ',AL3(LASTDS1)                   LDW1
         DC    AL1(6),CL8'X X X X ',AL3(*)   ZAP SPACE           * LDW1
         DC    AL1(5),CL8'EBCDIC  ',AL3(EBCDIC)
         DC    AL1(5),CL8'ITRACE  ',AL3(ITRACE)
         DC    AL1(5),CL8'DISASM  ',AL3(DISASM)
         DC    AL1(5),CL8'LINE80  ',AL3(LINE80)                    LDW1
         DC    AL1(5),CL8'LINE40  ',AL3(LINE40)                    LDW1
**%%     DC    AL1(5),CL8'NEWLOG  ',AL3(NEWLOG)                  * LDW1
**%%     DC    AL1(5),CL8'FORMAT  ',AL3(FORMAT)                  * LDW1
         DC    AL1(4),CL8'NODEF   ',AL3(NODEF)
         DC    AL1(4),CL8'ASCII   ',AL3(ASCII)
         DC    AL1(4),CL8'FLOAT   ',AL3(FLOAT)
         DC    AL1(4),CL8'ZCODE   ',AL3(ZCODE)
         DC    AL1(4),CL8'WHERE   ',AL3(WHERE)
         DC    AL1(4),CL8'TERSE   ',AL3(TERSE)
         DC    AL1(4),CL8'EJECT   ',AL3(EJECT)
         DC    AL1(4),CL8'DUMPF   ',AL3(DUMPF)                     LDW3
         DC    AL1(4),CL8'DUMPT   ',AL3(DUMPT)
         DC    AL1(4),CL8'DISPC   ',AL3(DISPC)                     LDW1
         DC    AL1(4),CL8'DISPK   ',AL3(DISPK)                     LDW1
         DC    AL1(4),CL8'DISPD   ',AL3(DISPD)                     LDW1
         DC    AL1(3),CL8'BASE    ',AL3(BASE)                      LDW1
         DC    AL1(3),CL8'DUMP    ',AL3(DUMP)
         DC    AL1(3),CL8'NOTE    ',AL3(NOTE)
         DC    AL1(3),CL8'LAST    ',AL3(LAST)
         DC    AL1(3),CL8'HELP    ',AL3(HELPHELP)                * LDW1
         DC    AL1(3),CL8'NAME    ',AL3(NAME#)                      *N*
         DC    AL1(3),CL8'IDEF    ',AL3(IDEF)
         DC    AL1(3),CL8'SAVE    ',AL3(REPLACE)                 *
         DC    AL1(3),CL8'ZSYM    ',AL3(ZCODE)                   *
**%%     DC    AL1(3),CL8'VTOC    ',AL3(VTOCCMD)                 * LDW1
         DC    AL1(2),CL8'ASM     ',AL3(ASM)
         DC    AL1(2),CL8'CRT     ',AL3(CRT)
         DC    AL1(2),CL8'LOG     ',AL3(LOG)
         DC    AL1(2),CL8'ZAP     ',AL3(REPLACE)
         DC    AL1(2),CL8'END     ',AL3(END)                       LDW3
         DC    AL1(2),CL8'SET     ',AL3(SET)
         DC    AL1(2),CL8'ABS     ',AL3(ABS)                       JCJ1
**%%     DC    AL1(2),CL8'DSN     ',AL3(DSNCMD)                  * LDW1
         DC    AL1(1),CL8'WM      ',AL3(WHATMEM)                   LDW4
         AIF   (&MVS).MVS07                                        LDW1
         DC    AL1(1),CL8'NN      ',AL3(NN)
.MVS07   DC    AL1(1),CL8'DO      ',AL3(DO)
         DC    AL1(0),CL8'L       ',AL3(LOCATE)
         DC    AL1(0),CL8'S       ',AL3(STORE)
         DC    AL1(0),CL8'O       ',AL3(OR)
         DC    AL1(0),CL8'X       ',AL3(EXOR)
         DC    AL1(0),CL8'N       ',AL3(AND)
         DC    AL1(0),CL8'F       ',AL3(FIND)                      LDW1
         DC    AL1(0),CL8'>       ',AL3(FORWARD)
         DC    AL1(0),CL8'<       ',AL3(BACKWARD)
         DC    AL1(0),CL8'M       ',AL3(MEMBER#)
         DC    AL1(0),CL8'E       ',AL3(NAME#)                    *LPR*
         DC    AL1(0),CL8'B       ',AL3(BACK)
         DC    AL1(0),CL8'D       ',AL3(DISPLAY#)
         DC    AL1(0),CL8'V       ',AL3(INDIRECT)                  LDW1
         DC    AL1(0),CL8'T       ',AL3(TRACK)
         DC    AL1(0),CL8'R       ',AL3(RECORD)
         DC    AL1(0),CL8'P       ',AL3(POINT)
         DC    AL1(0),CL8'J       ',AL3(POINT$J)                   MAS2
         DC    AL1(0),CL8'U       ',AL3(UP)                        LDW1
         DC    AL1(0),CL8'=       ',AL3(EQUALS)
         DC    AL1(0),CL8'?       ',AL3(HELP)
         DC    AL1(0),CL8'H       ',AL3(HELP)                      LDW1
         DC    AL1(0),CL8'#       ',AL3(CALC)
         DC    AL1(0),CL8'W       ',AL3(WINDOW)
         DC    AL1(0),CL8'%       ',AL3(INDPOINT)                  LDW1
         DC    X'FF'
         TITLE 'STAXEXIT ----- STAX EXIT'
*
*  GIVEN PTR TO TSDSECT IN STAXLIST, TURN ON ATTENTION INDICATOR
*  AND RETURN QUICKLY
*
         SPACE 2
         USING STAXEXIT,R15                                        LDW1
STAXEXIT L     R3,8(,R1)                GET USADDR FIELD (R13)     LDW1
         USING TSDSECT,R3                                          LDW1
         LR    R2,R14                   SAVE RETURN ADDR
         TM    FLAGS2,ATTNHIT           ALREADY SET?               LDW5
         BNO   *+10                     NO - OK                    LDW1
         LA    R1,1000                  ABEND CODE                 LDW1
         SVC   13                       LET HIM OUT QUICK          LDW1
         OI    FLAGS2,ATTNHIT           INDICATE ATTN SIGNALED     LDW5
         OI    FLAGS3,RESHOWF           ATTN CLEARS THE SCREEN     LDW5
         POST  TSECB                    POST ATTN ECB
         XR    R15,R15                  RC=0 TO STAX
         BR    R2                       RETURN
         DROP  R15,R3                                              LDW1
         TITLE 'ZAP --- TSO PARSE DSECTS/CSECTS  -  PDL, PCL, PDE, ETC'
ZAP      CSECT
         PRINT NOGEN
PCL      IKJPARM DSECT=IKJPARMD
         AIF   (&MVS).MVS08                                        LDW1
         MNOTE 0,'*** USERID WILL NOT BE PREFIXED TO DSN ***'      LDW1
PDLDSN   IKJPOSIT DSNAME,PROMPT='DATA SET NAME'
         AGO   .MVT05                                              LDW1
.MVS08   ANOP                                                      LDW1
PDLDSN   IKJPOSIT DSNAME,USID,PROMPT='DATA SET NAME'               LDW1
.MVT05   ANOP                                                      LDW1
PDLVOL   IKJKEYWD
         IKJNAME 'VOLUME',SUBFLD=VOLUME
PDLALC   IKJKEYWD  DEFAULT=                                        LDW1
         IKJNAME  'ALLOCDSN',SUBFLD=PDLALCSF                       LDW1
CRTK     IKJKEYWD
         IKJNAME 'CRT'
NOT3270K IKJKEYWD DEFAULT=                                         LDW1
         IKJNAME 'NOT3270'                                         LDW1
LOGK     IKJKEYWD DEFAULT='LOG  '                                  LDW1
         IKJNAME 'LOG'
         IKJNAME 'NOLOG'                                           LDW1
NWK      IKJKEYWD DEFAULT='TERSE'
         IKJNAME 'VERBOSE'
         IKJNAME 'TERSE'
VOLUME   IKJSUBF
VOLVOL   IKJIDENT 'VOLUME SERIAL',FIRST=ALPHA,OTHER=ALPHANUM,MAXLNTH=6
PDLALCSF IKJSUBF
         AIF   (&MVS).MVS08B                                       LDW$
         MNOTE 0,'*** USERID WILL NOT BE PREFIXED TO ALLOCDSN ***' LDW$
PDLALCDS IKJPOSIT  DSNAME,PROMPT='NAME OF DATASET TO ALLOC'        LDW$
         AGO   .MVT05B                                             LDW$
.MVS08B  ANOP                                                      LDW$
PDLALCDS IKJPOSIT  DSNAME,USID,PROMPT='NAME OF DATASET TO ALLOC'   LDW4
.MVT05B  IKJENDP
         SPACE 2
         PRINT GEN
         SPACE 4                                                   LDW1
PDE      DSECT ,                        PARSE DESCRIPTOR ELEMENT
PDEPTR   DS    A                        TEXT PTR
PDELEN   DS    H                        LEN
PDEFLAG  DS    X                        FLAGS
PDEFPRES EQU   X'80'                    PARM PRESENT
         DS    X                        RESERVED
PDEPTR2  DS    A                                                   LDW1
PDELEN2  DS    H                                                   LDW1
PDEFLAG2 DS    X                                                   LDW1
         DS    X                                                   LDW1
PDEPTR3  DS    A                                                   LDW1
PDELEN3  DS    H                                                   LDW1
PDEFLAG3 DS    X                                                   LDW1
         DS    X                                                   LDW1
PDEL     EQU   *-PDE
         TITLE 'ZAP --- DSECT MASK EXPANSIONS'
         PRINT GEN
*LDW1    DCBD  DSORG=DA                 DCB EXPANSION
IHADCB   DSECT                                                     LDW1
         ORG   IHADCB+X'24'                                        LDW1
DCBRECFM DS    X                                                   LDW1
DCBEXLST DS    AL3                                                 LDW1
DCBDDNAM DS    CL8                                                 LDW1
         ORG   IHADCB+X'2C'                                        LDW1
*CBIFLGS DS    0X                                                  LDW1
DCBDEBAD DS    A                                                   LDW1
         SPACE 6    (EJECT)                                        LDW1
CVT      DSECT
*LDW1    CVT                            CVT EXPANSION
CVTPTR   EQU   16                                                  LDW1
         ORG   CVT+X'1C'                                           LDW1
CVTPCNVT DS    A                                                   LDW1
CVTPRLTV DS    A                                                   LDW1
         SPACE 6   (EJECT)                                         LDW1
UCB      DSECT
*LDW1    IEFUCBOB                       UCB EXPANSION
         ORG   UCB+X'1C'                                           LDW1
SRTEVOLI DS    CL6                                                 LDW1
         SPACE 6    (EJECT)                                        LDW1
*LDW1    DEBDS                          DEB EXPANSION
DEBDS    DSECT ,                                                   LDW1
         ORG   DEBDS+X'10'                                         LDW1
DEBNMEXT DS    C                        # OF EXTENTS               LDW1
         ORG   DEBDS+X'20'                                         LDW1
DEBUCBAD DS    F                                                   LDW1
         DS    H                                                   LDW1
DEBSTRCC DS    H                        STARTING CYLINDER          LDW1
         DS    H                                                   LDW1
DEBENDCC DS    H                        ENDING CYLINDER            LDW1
         EJECT
*DSCB    DSECT
TSDSECT  DSECT                          BACK TO THERE, MOMENTARILY LDW1
         ORG   LINE07                                              LDW1
DSCB     DS    0D                                                  LDW1
         IECSDSL1 1                     FORMAT 1 DSCB EXPANSION
         SPACE 1
         ORG   ,                                                   LDW1
         SPACE 2
         AIF   (&MVS).MVS09                                        LDW1
         EJECT
QMRCAR   DSECT                          QUEUE MANAGER RESIDENT AREA
         IEFQMRES
.MVS09   EJECT                                                     LDW1
WORKAREA DSECT
*LDW1    CSOUT MF=L,COUNT=YES
         DS    0D                   (+)
         DS    X,AL3                (+) FLAGS/ADDR OF LINE BUFFER
         DS    860X                 (+) REMAINING DATA
         SPACE 1
         DS    0D     (BUFFER)
LCSOUT   EQU   *-WORKAREA
         SPACE 6  (EJECT)                                          LDW1
ESDDATA  DSECT ,                        ESD DATA ENTRY              *N*
ESDDNAME DS    CL8                      ENTRY PT NAME OF 8X'00'     *N*
ESDDTYPE DS    X                        TYPE                        *N*
ESDDADDR DS    AL3                      LKED ADDR OF ENTRY PT       *N*
ESDDSEG  DS    AL1                      SEGMENT NUMBER              *N*
ESDDLEN  DS    AL3                      LENGTH OF ENTRY             *N*
ESDDL    EQU   *-ESDDATA                LENGTH ESD DATA ENTRY       *N*
         TITLE 'C S O U T -- URSA PROCESSOR PRINTING ROUTINE'
***********************************************************************
CSOUT    CSECT                                                        *
*        CSOUT: THIS ROUTINE WHEN CXCTLED TO OR CALLED BY AN URSA     *
*               PROCESSOR WILL ALLOCATE A PRINT FILE, WRITE OUTPUT    *
*               LINES INTO IT (OPTIONALLY WTOING THEM ALSO), AND      *
*               ENQUEUE THE FILE TO BE PRINTED BY THE MOVE SERVICE.   *
*               IT IS INVOKED BY THE CSOUT MACRO IN ONE OF THREE      *
*               TYPES OF CALLS:                                       *
*        INPUTS: R1 ==> CSAREA ADDRESS                                *
*                R2 ==> CSOUT WORKAREA ADDRESS                        *
*                                                                     *
*               CSOUT  OPN,VOLUME,TRKS,CALL=TYPE,MF=(TYPE,WORKAREA)   *
*                                                                     *
*               'OPN' REQUESTS THE FILE TO BE ALLOCATED AND OPENED.   *
*               'VOLUME' IS THE ADDRESS OF A 6 BYTE FIELD CONTAINING  *
*                        THE VOLUME NAME TO BE USED FOR THE FILE      *
*               'TRKS' IS THE ADDRESS OF A HALFWORD CONTAINING THE    *
*                        NUMBER OF TRACKS TO BE ALLOCATED             *
*               FOR CALL= 'TYPE' IS EITHER 'CXCTL' OR 'CALL'. IF      *
*               'CXCTL' IS SPECIFIED CSOUT IS INVOKED VIA CXCTL.      *
*               OTHERWISE IT IS VIA CALL.                             *
*               MF=(TYPE,WORKAREA) WHERE TYPE IS B (SET UP FOR CALL)  *
*                        OR E (SET UP FOR CALL AND CALL). 'WORKAREA'  *
*               IS THE ADDRESS OF A ??? BYTE AREA ALIGNED ON A        *
*               DOUBLE WORD TO BE USED BY CSOUT FOR WORK SPACE.       *
*                                                                     *
*               RETRN: R0 ==> 0 -- NORMALL, FILE OPEN, PUTS ACCEPTED  *
*                            Â¬0 -- ERROR RETURN FROM CSLOC/CSOPN      *
*                                                                     *
*               CSOUT  PUT,CALL=,MF=,WTO=OPTION                       *
*                                                                     *
*               WHERE WTO=OPTION MAY BE WTO=YES OR WTO=NO TO CAUSE    *
*                      THE LINE TO BE WTOED ALSO.                     *
*               THE LINE BUFFER IS PRINTED. (SEE BELOW FOR WORKAREA   *
*               DEFINITIONS)                                          *
*               OUTPUT: R0 ==> 0 NORMAL RETURN                        *
*                             Â¬0 I/O ERROR                            *
*                                                                     *
*               CSOUT  ENQ,BIN,COPIES,MF=,CALL=                       *
*                                                                     *
*               ENQUEUES THE FILE TO PRINT, RETURNS TO START STATE.   *
*               BIN IS ADDRESS OF 4 BYTE BIN NUMBER                   *
*               COPIES IS ADDRESS OF HALFWORD CONTAINING COPIES       *
*               MF AND CALL AS WITH OPN.                              *
*               OUTPUT: R0 ==> 0 NORMAL, DATA SET ENQUEUED TO PRINT   *
*                             Â¬0 ENQUEUE FAILED FOR SOME REASON       *
*                                                                     *
*               THE FIRST WORD OF THE WORKAREA CONTAINS THE ADDRESS   *
*               OF THE INTERNAL LINE BUFFER TO BE FILLED BY THE       *
*               CALLER EACH TIME HE DOES A PUT. IT IS SET AT 'OPN'    *
*               TIME. THE BUFFER IS CLEARED AFTER EACH CALL.          *
*                                                                     *
*        PROGRAMMER: DON D WORTH                                      *
*                                                                     *
*        ALTERED BY PCN FOR USE WITH TSO ZAP 1/30/77
*                                                                     *
*        MODIFIED BY LDW TO USE QSAM        12/26/78                  *
*                                                                     *
***********************************************************************
         SPACE 7
DATA     DSECT
OFLAGS   DS    0BL1
OPNCALL  EQU   X'80'                    THIS IS AN OPEN CALL
ENQCALL  EQU   X'40'                    THIS IS AN ENQUEUE CALL
PUTCALL  EQU   X'C0'                    THIS IS A PUT CALL (IF ZEROS)
DOWTO    EQU   X'20'                    ISSUE AS A WTO ALSO
OIOERROR EQU   X'04'                    AN I/O ERROR HAS OCCURED
SCRCALL  EQU   X'02'                    THIS IS A SCRATCH CALL
TRNCALL  EQU   X'01'                    THIS IS A TRUNC   CALL     LDW1
LINELOC  DS    A                        ADDRESS OF LINE BUFFER
*OVOLSER DS    A                        ADDRESS OF VOLUME NAME
*BINNO   EQU   OVOLSER                  ADDRESS OF BIN NUMBER
*SPACE   DS    A                        ADDRESS OF SPACE
*COPIES  EQU   SPACE                    ADDRESS OF COPIES
ODBLW    DS    D                        SCRATCH DOUBLE WORD
PAGE     DS    H                        PAGE COUNTER
LINE     DS    H                        LINE COUNTER
SAVEAREA DS    6F                       REGISTERS CHANGED GO HERE
RETREG   DS    F
         PRINT NOGEN
DCB      DCB   DDNAME=X,MACRF=PM,DSORG=PS,BLKSIZE=133,LRECL=133,   LDW1$
               RECFM=FBA,SYNAD=0
ODSN     DS    CL44
*OVOL    DS    CL6
WTOBUFF  DS    F                                                   LDW1
         ORG   *-1                      OVERLAY CC IN WTO PREFIX   LDW1
OBUF     DS    CL133                    BUFFER ITSELF              LDW1
         DS    XL4                      ROOM FOR ROUTCDE AND DESC  SDM1
TTLBUFF  DS    CL133                    BUFFER FOR TITLE LINE      LDW1
DATALEN  EQU   *-DATA
         PRINT GEN
         TITLE 'C S O U T -- MAIN ENTRY, DETERMINE CALL TYPE'
         SPACE 1
*        HOUSEKEEPING
         SPACE 1
CSOUT    CSECT
         USING TSDSECT,R13                                         LDW1
         TM    FLAGS2,LOGF              ARE WE LOGGING?
         BNOR  R14                      IF NOT RETURN
         LTR   R2,R2                    ANY WORKAREA?
         BZR   R14                      NO, ICKY
         STM   R9,R12,SAVEAREA-DATA(R2) SAVE SOME REGS
         ST    R14,RETREG-DATA(R2)      SAVE WHERE TO GO BACK
*LDW1    LR    R13,R1                   COPY TSDSECT PTR TO R13
         LR    R12,R15                  GET BASE REG
         LR    R10,R2                   GET WORKAREA ADDRESS
*LDW1    OACUSING TSDSECT,R13
         OACUSING DATA,R10                                          MVS
         OACUSING CSOUT,R12                                         MVS
         SPACE 1
*        DETERMINE CALL TYPE
         SPACE 1
         TM    OFLAGS,OPNCALL            OPEN?
         BO    OPEN                     YES, GO OPEN
         TM    OFLAGS,ENQCALL            ENQUEUE?
         BO    ENQUEUE                  YES
         TM    OFLAGS,SCRCALL            SCRATCH?
         BO    SCRATCH                  YES                        LDW1
         TM    OFLAGS,TRNCALL           TRUNCATE?                  LDW1
         BO    TRUNC                    YES                        LDW1
         B     PUTOUT                   NO, MUST BE PUT THEN       LDW1
         SPACE 1
*        WHEN DONE WITH WHATEVER, CLEAR LINE, AND PASS IT BACK
         SPACE 1
EXIT     MVC   OBUF,BLANKS              CLEAR LINE BEFORE RETURN   LDW1
         NI    OFLAGS,255-PUTCALL-DOWTO-TRNCALL  REMOVE CALL TYPE  LDW1
         LR    R0,R15                   GET RETURN CODE
         L     R14,RETREG               RESTORE RETURN REG
         LM    R9,R12,SAVEAREA          RESTORE OTHER REGS
         BR    R14                      RETURN TO CALLER
         TITLE 'C S O U T -- OPEN ROUTINE'
         SPACE 1
*        OPEN -- PREPARE FOR CSLOC, CREATE A DATASET NAME
         SPACE 1
OPEN     LA    R0,OBUF                  START IT OUT
         IC    R14,LINELOC              SAVE FLAGS
         ST    R0,LINELOC               STORE FIRST LINE ADDR
         STC   R14,LINELOC              RESTORE FLAGS
         MVC   ODSN(8),=CL8'ZAPLOG'     TRY ZAPLOG FIRST        .AFDSC.
         DEVTYPE ODSN,ODSN+8            SEARCH TIOT             .AFDSC.
         LTR   R15,R15                  IS ZAPLOG ALLOCATED     .AFDSC.
         BZ    NOSYSOUT                 YES, BYPASS ALLOC       .AFDSC.
         ALLOC SYSOUT='A',SPACE=(TRK,1,5,0,RLSE)                   LDW3
         BXH   R15,R15,EXIT             RETRUN WITH ERROR CODE
         MVC   ODSN(8),DA30DDN-DAPB30+DAPBAREA   COPY DDN
NOSYSOUT DS    0H                                                  LDW1
         XC    PAGE(4),PAGE             CLEAR PAGE AND LINE
         LA    R0,DCB                   POINT TO DCB
         ST    R0,ODBLW                 STORE IN DCB LIST
         MVI   ODBLW,X'8F'              MARK END OF LIST & OUTPUT
         MVC   DCB(DCBLEN),ODCBMSK      COPY IN MASK
         MVC   DCBDDNAM-IHADCB+DCB(8),ODSN COPY IN DDNAME          LDW3
         OPEN  MF=(E,ODBLW)
         TM    DCB+48,X'10'             SEE IF OPEN
         BO    RC00                     IF SO RETURN OK
         LA    R15,4                    IF NOT ERROR
         B     EXIT
         SPACE 5
TRUNC    TRUNC DCB                      WRITE OUT A SHORT BLOCK    LDW1
         SPACE 1
         B     RC00                     THAT WAS EASY              LDW1
         TITLE 'C S O U T -- PUT ROUTINE'
*        PUT -- CALCULATE LINE POSITION
         SPACE 1
PUTOUT   LH    R0,LINE                  GET LINE NUMBER            LDW1
         CLI   OBUF,C'1'                SKIP TO PAGE?              LDW1
         BE    PUTPAGE                  YES, FORCE PAGE SKIP
         CLI   OBUF,C'0'                DOUBLE SPACE?              LDW1
         BE    SKIP2                    YES
         CLI   OBUF,C'+'                SUPPRESS SKIP?             LDW1
         BE    SKIP0                    YES
         CLI   OBUF,C'-'                TRIPLE SPACE?              LDW1
         BE    SKIP3                    NO, ANYTHING ELSE IS ONE SPACE
         MVI   OBUF,C' '                ELSE FORCE SINGLE          LDW1
         B     SKIP1                    AND COUNT ONE
SKIP3    BCTR  R0,0
SKIP2    BCTR  R0,0
SKIP1    BCTR  R0,0
SKIP0    LTR   R0,R0                    ANYTHING LEFT ON PAGE?
         BNP   PUTPAGE                  NO, EJECT
         STH   R0,LINE                  SAVE NEW LINE COUNTER
         SPACE 1
*        PRINT THE LINE NOW
         SPACE 1
         PUT   DCB,OBUF                 DUMP OUT HIS LINE THEN     LDW1
         SPACE 1
*        IF WTOING, DO IT
         SPACE 1
         TM    OFLAGS,DOWTO              DO WTO?
         BZ    RC0                      NO, ALL DONE NOW
*SDM1    XC    WTOBUFF(4),WTOBUFF       GIVE LENGTH/MCS FLAGS
         MVC   WTOBUFF+2(2),=X'8000'    INDICATE ROUTCDE PRESENT   SDM1
         LA    R1,WTOBUFF+123+4         LAST POSSIBLE
         CLI   0(R1),C' '               END OF IT?
         BNE   *+8                      YES
         BCT   R1,*-8                   KEEP LOOKING
         MVC   1(4,R1),=X'00004080'     SET ROUTCDE=(2,9)          SDM2
         LA    R0,WTOBUFF-1             BEGINNING
         SR    R1,R0                    LENGTH
         BNP   RC0                      NULL
         STH   R1,WTOBUFF               SAVE FOR WTO
         WTO   MF=(E,WTOBUFF)           DO IT
RC0      TM    OFLAGS,OIOERROR           IOERROR?
         BZ    RC00                     NO
         NI    OFLAGS,255-OIOERROR       TURN OFF FLAG
         LA    R15,8                    INDICATE IT
         B     EXIT                     LEAVE
RC00     XR    R15,R15                  SAY ALL IS WELL
         B     EXIT                     THEN LEAVE
         EJECT
*        PUT OUT A TITLE IF AT TOP OF PAGE
         SPACE 1
PUTPAGE  MVI   WTOBUFF+3,C'-'           TRIPLE SPACE FROM TITLE
         MVC   LINE(2),=H'60'           RESET LINE COUNTER
         LH    R1,PAGE                  GET PAGE COUNTER
         LA    R1,1(R1)                 COUNT LAST PAGE
         STH   R1,PAGE                  SAVE FOR LATER
         CVD   R1,ODBLW                 CONVERT THE PAGE NUMBER
         MVC   TTLBUFF,TITMSK           MOVE IN THE MASK           LDW1
         ED    TTLBUFF+113(6),ODBLW+5    EDIT IN THE PAGE NUMBER   LDW1
         SR    R1,R1              ASK FOR CURRENT TIME
*        LINK  EP=OACNOW                GET CURRENT DATE/TIME      PCN
         CALL  OACNOW                   GET CURRENT DATE/TIME  .AFDSC.
*  NOTE: RETURNS A PARMLIST POINTED TO BY R1 WITH THE CURRENT DARE PCN
*         DATE AND TIME IN THE FORMS DESCRIBED IN THE 'NOWPARM'    PCN
*         DSECT BELOW.                                             PCN
         SPACE 1
         OACUSING NOWPARM,R1                                        MVS
         SPACE 1
         MVC   TTLBUFF+82(2),DAY        PICK UP DAY   (DD)         LDW1
         CLI   TTLBUFF+82,C'/'          HAD THE DAY BEEN SQUISHED  LDW1
         BNE   *+8                      NO - LEAVE IT             *VIC*
         MVI   TTLBUFF+82,C' '          YES - BLANK IT OUT         LDW1
         MVC   TTLBUFF+85(3),CHARDATE   PICK UP MONTH (MMM)        LDW1
         MVC   TTLBUFF+89(2),YEAR       PICK UP YEAR  (YY)         LDW1
         SPACE 1
*        MVC   TTLBUFF+96(8),TIME24     PICK UP TIME HH:MM:SS      LDW1
         MVC   TTLBUFF+96(5),TIME24     PICK UP TIME HH:MM      .AFDSC.
         SPACE 1
         OACDROP R1                                                 MVS
         FREEMAIN R,LV=(0),A=(1)        FREE OACNOW RESULTS     .AFDSC.
         SPACE 1
         PUT   DCB,TTLBUFF              GO DUMP THE TITLE          LDW1
         B     PUTOUT                   NOW TRY THAT AGAIN
         SPACE 1
*        SYNAD: AND I/O ERROR HAS OCCURED
         SPACE 1
OSYNAD   OI    OFLAGS,OIOERROR           SIGNAL ERROR
         BR    R14                      AND RETURN
         EJECT
         SPACE 1
NOWPARM  DSECT                          NOWSVC (SSVC0) PARMLIST   *VIC*
         SPACE 2
TIME24   DS    0CL12                    TIME 24-HR....HH:MM:SS PST*VIC*
TIME24HR DS    2C,C                     HH:                       *VIC*
TIME24MN DS    2C,C                     MM:                       *VIC*
TIME24SC DS    2C                       SS                        *VIC*
         DS    C                        BLANK                     *VIC*
TIME24TZ DS    3C                       PST OR PDT                *VIC*
         DS    2C                       BLANKS                    *VIC*
         SPACE 1
NUMDATE  DS    0CL8                     THE DATE: (M)M/(D)D/YY    *VIC*
MO       DS    2C,C                     (M)M/                     *VIC*
DAY      DS    2C,C                     (D)D/                     *VIC*
YEAR     DS    2C                       YY                        *VIC*
         DS    2C                       BLANKS                    *VIC*
         SPACE 1
WEEKDAY  DS    9C                       THE WEEKDAY               *VIC*
         DS    C                        BLANK                     *VIC*
         SPACE 1
CHARDATE DS    13C                      DATE: MMM(M) (D)D, 19YY   *VIC*
         DS    2C                       BLANKS                    *VIC*
         SPACE 1
TIME12   DS    0CL15                    TIME 12-HR...HH:MM:SS AM PST
TIME12HR DS    2C,C                     HH:                       *VIC*
TIME12MN DS    2C,C                     MM:                       *VIC*
TIME12SC DS    2C,C                     SS + BLANK                *VIC*
AMPM     DS    2C                       AM OR PM                  *VIC*
         DS    C                        BLANK                     *VIC*
TIME12TZ DS    3C                       PDT OR PST                *VIC*
         DS    2C                       BLANKS                    *VIC*
         SPACE 1
JULDATE  DS    0CL6                     THE DATE:  YY.DDD         *VIC*
JULYEAR  DS    2C,C                     YY.                       *VIC*
JULDAY   DS    3C                       DDD                       *VIC*
         SPACE 2
PARMLEN  EQU   *-NOWPARM                LEN OF PARMLIST (72)      *VIC*
CSOUT    CSECT                                                   *VIC*
         TITLE 'C S O U T -- ENQUEUE THE DATASET TO PRINT'
*        CLOSE THE OUTPUT DATA SET AND FIND MTABLE
         SPACE 1
ENQUEUE  LA    R0,DCB                   FIND DCB                   LDW1
         ST    R0,ODBLW                 SAVE IT
         MVI   ODBLW,X'80'              CLOSE JUST THIS ONE
         SPACE 1
         CLOSE MF=(E,ODBLW)             CLOSE THE DS
         SPACE 1
         CLC   ODSN(8),=CL8'ZAPLOG'     WAS ZAPLOG PRE-ALLOC    .AFDSC.
         BE    RC00                     YES, BYPASS UNALLOCATE  .AFDSC.
         SPACE 1                                                   LDW3
         FREE  DDNAME=ODSN,SYSOUT='A'   AND FREE IT
         SPACE 1
         B     RC00                     NOW RETURN TO CALLER
         EJECT ,                                                   LDW1
SCRATCH  LA    R0,DCB                   POINT TO DCB               LDW1
         ST    R0,ODBLW                 STORE IN LIST
         MVI   ODBLW,X'80'              MARK AS END OF LIST
         SPACE 1
         CLOSE MF=(E,ODBLW)             CLOSE IT
         CLC   ODSN(8),=CL8'ZAPLOG'     WAS ZAPLOG PRE-ALLOC    .AFDSC.
         BE    RC00                     YES, BYPASS UNALLOCATE  .AFDSC.
         SPACE 1
         FREE  DDNAME=ODSN,DISP=DELETE                             LDW1
         SPACE 1
         B     RC00                     RETURN
         TITLE 'C S O U T -- CONSTANTS'
         SPACE 1
*TITMSK  DC    CL133'1U C L A / O A C                         *** TSO Z
*              AP  SESSION RECORD          *** DD MMM YY *** HH:MM:SS *
*              ** PAGE _____'                                      LDW4
TITMSK   DC    CL133'1A F D S C                               --- TSO ZX
               AP  SESSION RECORD ---      *** DD MMM YY *** HH:MM *** X
                  PAGE _____'                                   .AFDSC.
         ORG   TITMSK+114
         DC    X'2020202120'
         ORG
         SPACE 1
*        DCB MASK
         SPACE 1
         PRINT NOGEN
ODCBMSK  DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,RECFM=FBA,LRECL=133,  X
               SYNAD=OSYNAD,BLKSIZE=4123,BUFNO=1                   LDW1
DCBLEN   EQU   *-ODCBMSK
         PRINT GEN
         SPACE 1
*        LITERAL POOL
         SPACE 1
         LTORG
         TITLE 'ZAP --- HELP FOR ZAP' (HLP)                        LDW1
ZAPHELP  CSECT
         DC    A(NUMHELPS)                                         LDW1
         DC    A(FIRST)                                            LDW1
         DC    AL1(0,0,0,0,0,0,0,0,0,0,0,0,0)    1                 LDW1
         DC    AL1(1,0,1,1,1,1,1,1,1,1,1,1,0)    2                 LDW2
         DC    AL1(0,0,1,1,1,1,1,1,0,0,0,0,0)    3                 LDW4
         DC    AL1(1,0,1,1,1,1,1,1,1,1,1,1,1)    4                 LDW1
         DC    AL1(0,0,1,1,1,1,1,1,1,0,0,0,0)    5                 LDW4
         DC    AL1(1,0,1,1,1,1,1,1,1,1,1,0,0)    6                 LDW3
         DC    AL1(1,0,1,1,1,1,1,1,1,1,1,0,1)    7                 LDW3
         DC    AL1(1,0,1,1,1,1,1,1,1,1,1,1,1)    8                 LDW1
         DC    AL1(1,0,1,1,1,1,1,1,1,1,1,1,1)    9                 LDW1
         AIF   (&MVS).MVS10                                        LDW1
         DC    AL1(1,0,1,1,1,1,1,1,1,1,1,1,0)    10                LDW4
         AGO   .MVT06                                              LDW1
.MVS10   DC    AL1(0,0,1,1,1,1,1,1,1,1,1,0,0)    10                LDW4
.MVT06   DC    AL1(0,0,1,1,1,1,1,1,1,1,0,0,0)    11                LDW4
         DC    AL1(1,1,1,1,1,1,1,1,1,1,1,1,1)    12                LDW1
         DC    AL1(1,0,1,1,1,1,1,1,1,1,1,1,1)    13                LDW2
         SPACE 2
FIRST    DC    0A(0)                                               LDW1
*
*  IMAGE # 1                                                       LDW1
*
         DC    CL40'                CONTENTS                '      LDW1
         DC    CL40'                                        '      LDW1
         DC    CL40'?1      - THIS SCREEN                   '      LDW2
         DC    CL40'?2, ?3  - GENERAL INFO                  '      LDW2
         DC    CL40'?4, ?5  - INPUT/OUTPUT COMMANDS         '      LDW2
         DC    CL40'?6      - SESSION CONTROL COMMANDS      '      LDW2
         DC    CL40'?7      - DUMP COMMANDS                 '      LDW2
         DC    CL40'?8      - BYTE COMMANDS                 '      LDW2
         DC    CL40'?9      - STRING COMMANDS               '      LDW2
         DC    CL40'?10, ?11- MISCELLANEOUS COMMANDS        '      LDW2
         DC    CL40'?12     - EXPLANATION OF SYMBOLS        '      LDW2
         DC    CL40'?13     - SAMPLE ZAP SESSION            '      LDW2
         DC    CL40'                                        '      LDW2
*
*  IMAGE # 2                                                       LDW1
*
         DC    CL40'              GENERAL INFO              '      LDW2
         DC    CL40'                                        '      LDW2
         DC    CL40'--OPERANDS ARE ENTERED IMMEDIATELY AFTER'      LDW2
         DC    CL40'THE COMMAND, WITH NO INTERVENING BLANKS.'      LDW2
         DC    CL40'--THE BLOCK IS READ INTO A WORK BUFFER, '      LDW2
         DC    CL40'WHERE YOU MODIFY IT.  WHEN YOU ENTER THE'      LDW2
         DC    CL40'"ZAP" COMMAND, THE BLOCK IS WRITTEN BACK'      LDW2
         DC    CL40'TO THE DATASET FROM THE BUFFER.  IF ANY '      LDW2
         DC    CL40'OTHER JOB OR USER HAS UPDATED THAT BLOCK'      LDW2
         DC    CL40'IN BETWEEN WHEN YOU FIRST DISPLAYED IT  '      LDW2
         DC    CL40'AND WHEN YOU "ZAPPED" IT, THE OTHER     '      LDW2
         DC    CL40'CHANGES WILL BE LOST.                   '      LDW2
         DC    CL40'                                        '      LDW2
*
*  IMAGE # 3                                                       LDW2
*
         DC    CL40'        GENERAL INFO (CONTINUED)        '      LDW2
         DC    CL40'                                        '      LDW2
         DC    CL40'--IF YOU MAKE CHANGES TO A BLOCK, TO GO '      LDW2
         DC    CL40'TO ANOTHER BLOCK YOU MUST EITHER "ZAP"  '      LDW2
         DC    CL40'THE BLOCK (RE-WRITE IT TO THE DATASET), '      LDW2
         DC    CL40'OR ENTER THE COMMAND TWICE IN A ROW     '      LDW4
         DC    CL40'WHICH WILL CAUSE YOU TO LEAVE THE       '      LDW4
         DC    CL40'CURRENT MODIFIED BLOCK.                 '      LDW4
         DC    CL40'                                        '      LDW4
         DC    CL40'                                        '      LDW4
         DC    CL40'                                        '      LDW2
         DC    CL40'                                        '      LDW2
         DC    CL40'                                        '      LDW2
*                                                                  LDW1
*  IMAGE # 4                                                       LDW1
*                                                                  LDW1
         DC    CL40'         INPUT/OUTPUT COMMANDS          '      LDW1
         DC    CL40'                                        '      LDW1
         DC    CL40'P<EXP> - POINT TO REC WHOSE TTR IS <EXP>'
         DC    CL40'P      - POINT TO BEGINNING OF DATA SET '
         DC    CL40'T<EXP> - POINT TO TRACK <EXP>, RECORD 1 '
         DC    CL40'T      - POINT TO NEXT TRACK, RECORD 1  '
         DC    CL40'R<EXP> - SHOW BLK <EXP> REL. TO CURRENT '       *N*
         DC    CL40'R      - POINT TO NEXT PHYSICAL RECORD  '       *N*
         DC    CL40'B      - POINT TO PREVIOUS RECORD       '       *N*
         DC    CL40'LAST   - POINT TO LAST RECORD (DS1LSTAR)'       *N*
         DC    CL40'LASTDS1- POINT TO LAST FMT1 IN VTOC     '      LDW1
         DC    CL40'ABS<EXP> - POINT TO REC WITH CCHHR = EXP'      JCJ1
         DC    CL40'%<EXP> - POINT TO TTR @ LOC <EXP> IN BLK'      LDW1
*
*  IMAGE # 5                                                       LDW1
*
         DC    CL40'       MORE INPUT/OUTPUT COMMANDS       '      LDW1
         DC    CL40'                                        '      LDW1
         DC    CL40'M<NAME>- FOR PDS, POINT TO MEMBER <NAME>'       *N*
         DC    CL40'M      - POINT TO START OF CURRENT MEMBR'      LDW4
         DC    CL40'NAME<N>- AFTER ''M'', SHOW ENTRY POINT <N>'     *N*
         DC    CL40'NAME   - SELECT ENTRY POINT NAMED MEMBER'      LDW1
         DC    CL40'E<N>   - SAME AS NAME<N>                '       *N*
         DC    CL40'E      - SAME AS NAME                   '       *N*
         DC    CL40'ZAP    - REPLACE BLOCK FROM CURRENT BUFF'
         DC    CL40'                                        '      LDW4
         DC    CL40'                                        '      LDW4
         DC    CL40'                                        '      LDW1
         DC    CL40'                                        '      LDW1
*
*  IMAGE # 6                                                       LDW1
*
         DC    CL40'        SESSION CONTROL COMMANDS        '      LDW1
         DC    CL40'                                        '      LDW1
         DC    CL40'LOG      - START LOGGING THIS SESSION   '
         DC    CL40'CRT      - SET WIDTH 4,4 AND VERBOSE    '
         DC    CL40'TERSE    - DO NOT DO AUTO WHERE         '
         DC    CL40'VERBOSE  - ALWAYS GIVE WHERE INFO       '
         DC    CL40'W<D>,<U> - SET WINDOW DOWN/UP SIZE(S)   '
         DC    CL40'WFULL    - SET SIZE TO URSA SCREEN SIZE '
         DC    CL40'LINE40, LINE80 - SET LINE LENGTH 40 | 80'      LDW3
         DC    CL40'NOTE<COMNT>-WRITE <COMNT> INTO LOG FILE '      LDW1
         DC    CL40'EJECT    - EJECT A PAGE IN THE LOG FILE '      LDW1
         DC    2CL40'                                        '     LDW3
*                                                                  LDW1
*  IMAGE # 7                                                       LDW1
*                                                                  LDW1
         DC    CL40'             DUMP COMMANDS              '      LDW1
         DC    CL40'                                        '      LDW1
         DC    CL40'DUMP       - DUMP ALL RECORDS IN THE    '
         DC    CL40'             DATA SET IN ABDUMP FORMAT  '
         DC    CL40'DUMPT<EXP> - DUMP TO TTR <EXP> FROM     '
         DC    CL40'             CURRENT RECORD             '
         DC    CL40'DUMPT      - DUMP CURRENT RECORD ONLY   '
         DC    CL40'DUMPF<EXP> - DUMP FOR <EXP> RECORDS FROM'
         DC    CL40'             CURRENT RECORD             '
         DC    CL40'DUMPF      - DUMP CURRENT RECORD        '
         DC    CL40'DUMPE      - DUMP CURRENT RECORD TO EOF '      LDW1
         DC    CL40'                                        '
         DC    CL40'EOF, I/O ERROR, AND END-OF-DS HALT DUMP '
*                                                                  LDW1
*  IMAGE # 8                                                       LDW1
*                                                                  LDW1
         DC    CL40'             BYTE COMMANDS              '      LDW1
         DC    CL40'                                        '      LDW1
         DC    CL40'D<EXP> - DISPLAY BYTE AT OFFSET <EXP>   '
         DC    CL40'<EXP>  - SAME AS D<EXP>                 '
         DC    CL40'D      - PAGE TO NEXT SCREEN (D+#SCREEN)'      LDW1
         DC    CL40'U      - PAGE TO PREV SCREEN (D-#SCREEN)'      LDW1
         DC    CL40'>      - GO FORWARD IN TRACE TABLE      '
         DC    CL40'<      - GO BACKWARD IN TRACE TABLE     '
         DC    CL40'EBCDIC - EBCDIC TRANSLATION (DEFAULT)   '
         DC    CL40'ASCII  - ASCII-8 TRANSLATION            '
         DC    CL40'ZCODE  - ZCODE TRANSLATION              '
         DC    CL40'=<LAB> - DEFINE <LAB> TO CURR LOCATION  '
         DC    CL40'NODEF  - CLEAR ALL DEFINED LABELS FROM ='
*                                                                  LDW1
*  IMAGE # 9                                                       LDW1
*                                                                  LDW1
         DC    CL40'             STRING COMMANDS            '      LDW1
         DC    CL40'                                        '      LDW1
         DC    CL40'S<STR>   - STORE <STR> AT CURRENT LOC   '
         DC    CL40'X<STR>   - EXCLUSIVE OR AT CURRENT LOC  '
         DC    CL40'O<STR>   - OR AT CURRENT LOC            '
         DC    CL40'N<STR>   - AND AT CURRENT LOC           '
         DC    CL40'SET<STR> - SET ENTIRE RECORD TO <STR>   '
         DC    CL40'           S,X,O,N,SET MAY BE ENTERED   '
         DC    CL40'           ALONE TO USE PREVIOUS <STR>  '
         DC    CL40'L<STR>   - LOOK FOR <STR> FROM NEXT BYTE'
         DC    CL40'L        - CONTINUE LOOKING FOR <STR>   '
         DC    CL40'F<STR>   - LIKE L<STR>, CONT''S PAST EOFS'     LDW1
         DC    CL40'F        - LIKE L, CONTINUES PAST EOFS  '      LDW1
*                                                                  LDW1
*  IMAGE # 10                                                      LDW1
*                                                                  LDW1
         DC    CL40'         MISCELLANEOUS COMMANDS         '      LDW1
         DC    CL40'                                        '      LDW1
         DC    CL40'END    - EXIT ZAP                       '
         DC    CL40'#<EXP> - FIND HEX/DECIMAL VALUE OF <EXP>'
         DC    CL40'FLOAT<F>-FIND FLOATING PT VALUE OF <F>  '
         DC    CL40'IDEF   - DISPLAY DEFINE LABEL TABLE     '
         DC    CL40'ITRACE - DISPLAY TRACE TABLE            '
         AIF   (&MVS).MVS11                                        LDW1
         DC    CL40'NN<EXP>- FOR JOBQ, FIND <EXP>TH RECORD  '
.MVS11   DC    CL40'?N     - VIEW NTH HELP DISPLAY (1-13)   '      LDW1
         DC    CL40'WHERE  - GIVE CURRENT LOCATION ETC.     '
         DC    CL40'ASM<OP> - GIVE OBJECT CODE FOR MNEMONIC '
         DC    CL40'DISASM<EXP> - DISASSEMBLE INSTR AT <EXP>'      LDW1
         AIF   (&MVT).MVT07                                        LDW1
         DC    CL40'                                        '      LDW1
.MVT07   DC    CL40'                                        '      LDW4
*
*  IMAGE # 11                                                      LDW1
*
         DC    CL40'      MORE MISCELLANEOUS COMMANDS       '      LDW1
         DC    CL40'                                        '      LDW1
         DC    CL40'WHATMEM- FIND DIR ENTRY CLOSEST TO REC *'      LDW4
         DC    CL40'WM       - SAME AS WHATMEM              '      LDW4
         DC    CL40'DO<CMD>  - EXECUTE TSO <CMD> AS AT READY'      LDW1
         DC    CL40'V<EXP>   - ADD CONTENTS OF 2 BYTES AT   '      LDW5
         DC    CL40'           <EXP> TO CURR VALUE OF LOC   '      LDW5
         DC    CL40'BASE<EXP>- ADD <EXP> TO BUFFER OFFSET   '      LDW1
         DC    CL40'           WHEN COMPUTING ADDR          '      LDW1
         DC    CL40'DISP<TYPE>-SET RECORD DISPLAY START POS '      LDW1
         DC    CL40'           <TYPE> IS COUNT | KEY | DATA '      LDW1
         DC    CL40'J<TTR>- RELATIVE TO BEGINING OF VOLUME  '      LDW5
         DC    CL40'                                        '      LDW5
*                                                                  LDW1
*  IMAGE # 12                                                      LDW1
*                                                                  LDW1
         DC    CL40'<EXP> IS COMPOSED OF OPERATORS (+,-,*,/)'      LDW1
         DC    CL40'      DEFINE SYMBOLS (''='' COMMAND) AND'
         DC    CL40'HEX OR DECIMAL CONSTANTS. THE FOLLOWING '
         DC    CL40'SYMBOLS ARE PREDEFINED: *=CURRENT OFFSET'
         DC    CL40'L=LOGICAL RECORD LENGTH, K=KEY LENGTH   '
         DC    CL40'BL=MAXIMUM BLOCK SIZE.                  '
         DC    CL40'<STR> MAY BE EITHER UP TO 16 CHARACTERS '
         DC    CL40'      ENCLOSED IN ANY DELIMITER, OR UP  '
         DC    CL40'      TO 16 HEX DIGITS, OR A DECIMAL VAL'
         DC    CL40'      ENDING WITH ''.'' (LENGTH 4 BYTES)  '
         DC    CL40'<LAB> MAY ANY 1 TO 8 CHARACTERS         '
         DC    CL40'<F>   IS ANY FLOATING POINT CONSTANT IN '
         DC    CL40'      INTERNAL FORM (IE: FORTRAN A FORM)'
*
*  IMAGE # 13                                                      LDW2
*
         DC    CL40'           SAMPLE ZAP SESSION           '      LDW2
         DC    CL40'                                        '      LDW2
         DC    CL40'ZAP LOAD   READY LEVEL COMMAND ENTERED  '      LDW2
         DC    CL40'MTEST      SELECT MEMBER "TEST"         '      LDW2
         DC    CL40'EFIRST     SELECT ENTRY POINT "FIRST"   '      LDW2
         DC    CL40'4C         GO TO OFFSET 4C IN RECORD    '      LDW2
         DC    CL40'S00        STORE 1 BYTE HEX             '      LDW2
         DC    CL40'+4         ADVANCE PTR 4 BYTES IN BLOCK '      LDW2
         DC    CL40'NFF0F      TURN OFF 1 NIBBLE            '      LDW2
         DC    CL40'ZAP        REWRITE THAT BLOCK           '      LDW2
         DC    CL40'R+3        GO TO 3RD BLOCK FROM HERE    '      LDW2
         DC    CL40'L/HELLO/   FIND SOME TEXT               '      LDW2
         DC    CL40'END        ALL DONE                     '      LDW2
         SPACE 3
NUMHELPS EQU   (*-FIRST)/40                                        LDW1
         TITLE 'ZAP --- ASMGASM --- OP CODE PARSE' (ASM)           LDW1
         SPACE 3
*
*  ASSEMBLE OR DISASSEMBLE.
*
         SPACE 2
ASMGASM  CSECT ,
         SPACE 1
         SAVE  (14,12),,*
         SPACE 1
         LR    R12,R15                  BASE
         USING ASMGASM,R12
         SPACE 2
         LTR   R1,R1                    ASM OR DISASM?
         BM    DISASMIT                 GUESS...                   LDW1
         EJECT
*  ASM  ---  R1 = PTR TO CL4'MNEUMONIC'
         SPACE 2
         LA    R2,OPCODES               TABLE
         L     R15,=A(OPEND-OPLEN)      END BXLE
         LA    R14,OPLEN                LENGTH
         SPACE 1
OPLOOP   CLC   0(4,R1),0(R2)            THIS ONE (KLUGE)
         BE    GOTOP                    YES
         BXLE  R2,R14,OPLOOP            TRY ALL POSSIBLES
         SPACE 1
BADRET   LA    R15,4                    INVALID OP CODE
         B     RETURN                   BYE
         SPACE 2
GOTOP    LA    R1,5(,R2)                POINT TO OP IN HEX
GOODRET  XR    R15,R15                  RC=0
         SPACE 1
RETURN   L     R14,12(,R13)             RESTORE R14  **** NOTE R0 NOT
         LM    R2,R12,12+16(R13)        REST REGS         RESTORED ****
         BR    R14                      BYE
         EJECT
*  DISASM  ---  R1 = PTR TO BUFF LOC OF OBJECT CODE
*               R0 = PTR TO OUTPUT BUFFER  (33 BYTES)
*               R2 = PTR TO 5 DOUBLEWORDS WORKAREA
*  OUTPUT:      R15= RC
*               R1 = INSTR LEN IF R15=0
         SPACE 2
DISASMIT LPR   R1,R1                    GET POS 1ST                LDW1
         LR    R7,R2                    SAVE WORK BASE
         LR    R9,R0                    SAVE OUTPUT BUFF PTR
         SPACE 3
JCJWORK  DSECT
DOUBLE   DS    D
DBL      DS    D                                                   LDW1
EDITWORK DS    6C                                                  LDW1
FLAGS    DS    X
         SPACE 3
ASMGASM  CSECT ,
         SPACE 2
         USING JCJWORK,R7
*
*  THIS ROUTINE WRITTEN BY JCJ 1/75
*
         SPACE 2
         MVC   DBL(8),0(R1)             ALIGN POSSIBLE INSTRUCTION LDW1
         LA    R6,DBL                   POINT TO INSTR             LDW1
         SPACE 2
***********************************************************************
*                                                                     *
* DISASSEM                                                            *
* RETURNS:                                                            *
*     R15 - LENGTH OF INSTRUCTION OR ZERO IF NON-VALID OPCODE         *
*     FILLED IN SCREEN BUFFER IF OPCODE WAS VALID                     *
*                                                                     *
*                                                                     *
* NOTE WE GO THROUGH SOME CONTORTIONS IN ORDER TO BE ABLE TO SPECIFY  *
* THE OPCODE FLAG FIELDS IN EBCDIC CHARACTER FORM (IMAGE-ENTERABLE).  *
*                                                                     *
***********************************************************************
         SPACE 2
         XR    R15,R15                  READY FOR IC
         XR    R2,R2                    CLEAR TRT REG
         TRT   0(1,R6),OPTAB            TRANSLATE THE OPCODE
         BZ    BADRET                   BRANCH IF NON-VALID OPCODE
         SPACE 2
         LA    R4,1                     GET F'1' FOR LATER
         SLR   R2,R4                    FIX FOR PROPER TABLE INDEX
         MH    R2,H6                    GET OFFSET INTO TABLE
         LA    R1,OPCODES(R2)           PNT TO PROPER MNENOMIC
         MVC   0(4,R9),0(R1)            MOVE IN MNENOMIC
         MVC   FLAGS(1),4(R1)           GET THE FLAG BYTE
         IC    R15,1(,R6)               GET THE REG BYTE
         LR    R2,R15                   GET IT IN R2 FOR LATER
         SPACE 1
* NOW CHECK IF IT IS AN EXTENDED MNENOMIC INSTRUCTION
         SPACE 1
         TM    FLAGS,X'04'              EXTENDED MNENOMIC FLAG ON?
         BZ    GETTYPE                  NO - GO ON WITH THE REST
         TM    FLAGS,X'02'              INDEX REG FLAG ON?
         BZ    GETMNE                   NO - GO GET THE MMENOMIC
         SPACE 2
* GETMNE RETURNS TO GETINST - WE DON'T CARE IF WE GO THROUGH THIS CODE
* FOR NON-MNENOMICS THOUGH
         SPACE 2
GETINST  CLI   1(R9),C'C'               GOT AN EXTENDED MNENOMIC?
         BNE   *+8                      YES - SKIP THE BIT RESET
         OI    FLAGS,X'02'              NO - FAKE OUT A RR(OR RX) TYPE
         SPACE 2
GETTYPE  CLC   0(4,R9),OPCODES          IS IT SPM?
         LA    R9,7(,R9)                INCREMENT LINE PNTR
         BNE   GETTYPE#                 NO - SKIP FLAG RESET/BRANCH
         MVI   FLAGS,C'<'               RESET FLAG FOR LATER TEST
         B     GETRR#                   AND GO PROCESS SPM
         SPACE 2
GETTYPE# TM    FLAGS,X'90'              IS LENGTH FOUR BYTES?
         BZ    GETRR                    NO - GET 2 BYTE INSTRUCTION
         BM    GETSS                    NO - GET 6 BYTE INSTRUCTION
         SPACE 2
*
* HAVE AN FOUR BYTE TYPE WHEN WE FALL THROUGH TO HERE
*
         SPACE 2
         CLI   FLAGS,C'M'  (GETRX)      DO WE WANT A REGISTER?
         BNH   RXDISP                   NO - GO GET DISP FIELD
         LR    R2,R15                   GET REG BYTE BACK
         SRDL  R2,4                     SHIFT TO GET FIRST REG
         BAL   R14,GETNUM               PUT CHAR VALUE IN SCREEN
         BAL   R14,COMMA                PUT IN A COMMA
         CLI   FLAGS,C'R'               TWO REGISTERS NEEDED?
         BNE   RXDISP                   NO - GET DISPLACEMENT
         SLDL  R2,4                     GET THE OTHER REG
         BAL   R14,GETNUM               AND PUT IT IN SCREEN
         BAL   R14,COMMA                MOVE IN A COMMA
RXDISP   BAL   R5,GETDISP               GET THE DISP FIELD
         TM    FLAGS,X'04'              NEED AN INDEX REG?
         BZ    RXNOIND                  NO - GET THE BASE ONLY
         SLDL  R2,4                     AND PICK UP THE INDEX REG
         BAL   R14,GETNUM               PUT IT IN SCREEN
         BAL   R14,COMMA                MOVE IN A COMMA
RXNOIND  BAL   R5,GETBASE               GET THE BASE BYTE
         CLI   FLAGS,C'L'               IMMEDIATE TYPE?
         BNE   DISLEAVE                 NO - LEAVE
         SPACE
* WE HAVE AN SI TYPE HERE
         SPACE
         MVC   0(3,R9),SICHAR           MOVE IN ,X'
         HEX   (3,R9),(1,R6),LEN=1,HEXTAB=HEXTAB,BYTE=C''''        LDW1
         B     DISLEAVE                 AND LEAVE
         SPACE 2
*
* TWO BYTE INSTRUCTIONS
*
GETRR    LR    R2,R15                   GET REG BYTE BACK
         CLI   FLAGS,C'+'               SVC?
         BE    RRSVC                    YES - GO PROCESS IT
         BL    MNENT                    EXTENDED MNENOMIC HERE
         SPACE 1
GETRR#   SRDL  R2,4                     GET FIRST REGISTER VALUE
         BAL   R14,GETNUM               MOVE IN THE CHAR VALUE
         CLI   FLAGS,C'<'               SPM INST?
         BE    DISLEAVE                 YES - LEAVE
         BAL   R14,COMMA                MOVE IN A COMMA
MNENT    XR    R2,R2                    ZERO PARM REG
         SLDL  R2,4                     GET OTHER REG
RRSVC    BAL   R14,GETNUM               MOVE IN THE CHAR AGAIN
         B     DISLEAVE                 GO AWAY
         SPACE 2
*
* THIS SECTION HANDLES 6 BYTE INSTRUCTIONS
*
         SPACE 2
GETSS    LR    R0,R2                    SAVE THE REG BYTE (LENGTH)
         BAL   R5,GETDISP               GEN FIRST DISPLACEMENT
         LR    R2,R0                    GET THE REG BYTE BACK
         TM    FLAGS,X'01'              ONLY ONE LENGTH FIELD?
         BO    *+8                      YES - SKIP THE REG SHIFT
         SRDL  R2,4                     GET THE FIRST LENGTH FIELD
         BAL   R14,GETNUMI              MOVE IN THE CHAR VALUE
         BAL   R14,COMMA                MOVE IN A COMMA
         BAL   R5,GETBASE               GET THE BASE FIELD
         BAL   R14,COMMA                MOVE IN A COMMA
         LH    R2,4(,R6)                GET SECOND DISP FIELD
         BAL   R5,GETDISP#              MOVE IT TO THE SCREEN
         TM    FLAGS,X'01'              SINGLE LENGTH?
         BO    SSL1                     YES - SKIP 2ND LEN PROCESSING
         SLDL  R2,4                     GET 2ND LENGTH
         BAL   R14,GETNUMI              AND MOVE IT TO SCREEN
         BAL   R14,COMMA                A DELIMITER OR TWO
SSL1     IC    R2,4(,R6)                GET SECOND BASE FIELD
         BAL   R5,GETBASE#              GET THE BASE IN SCREEN
         SPACE 2
DISLEAVE TM    FLAGS,X'10'              DO WE HAVE A BAD LENGTH?
         BZ    *+8                      NO - HOP OVER THE BIT RESET
         NI    FLAGS,255-X'40'          FIX FOR CORRECT LENGTH
         XR    R1,R1                    SET UP FOR IC
         IC    R1,FLAGS                 GET THE LENGTH
         SRL   R1,5                     WIPE OUT FLAG BITS  = LENGTH
         B     GOODRET                  EXIT OK
         SPACE 2
*
* EXTENDED MNENOMIC ROUTINE
*
         SPACE 2
GETMNE   SRDL  R2,4                     SHIFT TO CLEAR OUT REG NIBBLE
         MH    R2,H6                    INDEX INTO TABLE
         LA    R1,MNEOPS(R2)            PNT TO TABLE ENTRY
         MVC   0(3,R9),0(R1)            MOVE IN PRIMARY MNEMONIC
         SPACE 1
         CLI   3(R1),C' '               SECONDARY MNENOMIC PRESENT?
         BE    GETMNE#                  NO - CONTINUE ON
         SPACE 1
         MVC   5(3,R9),3(R1)            GET SECONDARY ONE
         LR    R14,R9                   SAVE CURR BUFFER PNTR
         AH    R9,H6                    AND UP WORK BUFFER PNTR
         SPACE 1
GETMNE#  TM    FLAGS,X'80'              NON 2 BYTE INSTRUCTION?
         BO    GETINST                  YES - LEAVE
         SPACE 1
         CLI   3(R1),C' '               TWO MNENOMICS NEEDED?
         BE    ONEMNE                   NO - SO DO ONE DUMMY...
         BAL   R5,RLOOP                 PUT IN A 'R' (RR TYPE)
         SPACE 1
ONEMNE   LR    R14,R9                   PNT TO CURR MNEMONIC
         LA    R5,GETINST               FAKE OUT A BAL AND RETURN
         SPACE 2
RLOOP    ALR   R14,R4                   PNT TO NEXT CHAR
         CLI   0(R14),C' '              A BLANK WAITING FOR 'R'?
         BNE   RLOOP                    NO - INCREMENT
         MVI   0(R14),C'R'              YES - PUT IN THE 'R'
         BR    R5                       AND GO HOME
         TITLE 'U T I L I T Y   R O U T I N E S'
*
* DISASSEMBLER BAL ROUTINES - USED TO SAVE BYTES HERE AND THERE
*
         SPACE 2
* THIS SECTION GETS THE BASE REG
         SPACE
GETBASE  IC    R2,2(,R6)                GET THE BASE
GETBASE# SRL   R2,4                     SHIFT OUT GARBAGE
         BAL   R14,GETNUM               GO MOVE TO SCREEN
         MVI   0(R9),C')'               PUT IN A R-PAREN
         ALR   R9,R4                    INCREMENT LINE PNTR
         BR    R5                       GO TO CALLER
         SPACE
* THIS SECTION GETS THE DISPLACEMENT FIELD
         SPACE
GETDISP  LH    R2,2(,R6)                LOAD THE DISPLACEMENT
GETDISP# N     R2,DISPMASK              WIPE OUT BASE BITS
         BAL   R14,GETNUM               DO THE MOVE TO SCREEN
         CLI   FLAGS,C'J'               IS IT SVCX OR DIAGNOSE?
         BE    DISLEAVE                 YES - GO AWAY
         MVI   0(R9),C'('               ELSE MOVE IN A L-PAREN
         ALR   R9,R4                    INCREMENT LINE PNTR
         BR    R5                       GO TO CALLER
         SPACE
COMMA    MVI   0(R9),C','               MOVE IN A COMMA
         ALR   R9,R4                    INCREMENT PNTR
         BR    R14                      GO TO CALLER
         SPACE 2
*
* THIS ROUTINE PUTS THE CHAR VALUE OF THE CONTENTS OF R2 INTO THE
* SCREEN(VIA R9) AND UPDATES R9 (POINT TO THE NEXT AVAILABLE POSITION)
*
         SPACE 2
GETNUMI  ALR   R2,R4                    INCREMENT FOR A LENGTH FIX
GETNUM   CVD   R2,DOUBLE                GET IT IN DECIMAL
         MVC   EDITWORK(6),EDITMASK     SET UP FOR EDIT
         LA    R15,EDITWORK+5           PNT TO END OF AREA
         LR    R1,R15                   SET UP R1 FOR EDMK
         EDMK  EDITWORK(6),DOUBLE+5     DO THE EDIT
         SR    R15,R1                   GET THE EXECUTE LENGTH
         EX    R15,NUMMOVE              MOVE THE VALUE TO THE SCREEN
         LA    R9,1(R15,R9)             UPDATE THE SCREEN PNTR
         XR    R2,R2                    ZERO OUR WORK REG
         BR    R14                      GO HOME
NUMMOVE  MVC   0(0,R9),0(R1)            <<< EXECUTED >>>
         TITLE 'D A T A'
DISPMASK DC    0F'0',XL4'00000FFF'
H6       DC    H'6'
EDITMASK DC    X'402020202120'
SICHAR   DC    C',X'''
         DC    C'0123456789ABCDEF'
HEXTAB   EQU   *-256
         SPACE 5
*        TITLE 'E X T E N D E D   M N E N O M I C   T A B L E'
         SPACE 2
MNEOPS   DC    CL6'NOP   '
         DC    CL6'BO    '
         DC    CL6'BH BP '
         DC    CL6'BC    '
         DC    CL6'BL BM '
         DC    CL6'BC    '
         DC    CL6'BC    '
         DC    CL6'BNEBNZ'
         DC    CL6'BE BZ '
         DC    CL6'BC    '
         DC    CL6'BC    '
         DC    CL6'BNLBNM'
         DC    CL6'BC    '
         DC    CL6'BNHBNP'
         DC    CL6'BNO   '
         DC    CL6'B     '
         TITLE 'O P C O D E   T R A N S L A T E   T A B L E'
*OPTAB   DC    X'0000000001020304050607000000000008090A0B0C0D0E0F'
*LDW1    DC    X'101112131415161718191A1B1C1D1E1F2021222324252627'
*LDW1    DC    X'28292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F'
*LDW1    DC    X'404142434400454647480000494A4B4C4D4E4F5051525354'
*LDW1    DC    X'55000000000000565758595A5B5C5D5E5F00000000000000'
*LDW1    DC    X'60616263646566676800696A6B6C6D6E6F70717273747576'
*LDW1    DC    X'7778797A7B7C7D7E7F000000808182830000000000000000'
*LDW1    DC    X'000000000000000000000000000000000000000000000000'
*LDW1    DC    X'00000000000000000000000000000000008485868788898A'
*LDW1    DC    X'000000008B8C8D8E00000000000000000000000000000000'
*LDW1    DC    X'008F9091000000009293949596970000'
         SPACE 4                                                   LDW1
OPTAB    DC    AL1(@00,@00,@00,@00,@04,@05,@06,@07)                LDW1
         DC    AL1(@08,@09,@0A,@00,@00,@00,@0E,@0F)                LDW1
         DC    AL1(@10,@11,@12,@13,@14,@15,@16,@17)                LDW1
         DC    AL1(@18,@19,@1A,@1B,@1C,@1D,@1E,@1F)                LDW1
         DC    AL1(@20,@21,@22,@23,@24,@25,@26,@27)                LDW1
         DC    AL1(@28,@29,@2A,@2B,@2C,@2D,@2E,@2F)                LDW1
         DC    AL1(@30,@31,@32,@33,@34,@35,@36,@37)                LDW1
         DC    AL1(@38,@39,@3A,@3B,@3C,@3D,@3E,@3F)                LDW1
         DC    AL1(@40,@41,@42,@43,@44,@45,@46,@47)                LDW1
         DC    AL1(@48,@49,@4A,@4B,@4C,@00,@4E,@4F)                LDW1
         DC    AL1(@50,@51,@00,@00,@54,@55,@56,@57)                LDW1
         DC    AL1(@58,@59,@5A,@5B,@5C,@5D,@5E,@5F)                LDW1
         DC    AL1(@60,@00,@00,@00,@00,@00,@00,@67)                LDW1
         DC    AL1(@68,@69,@6A,@6B,@6C,@6D,@6E,@6F)                LDW1
         DC    AL1(@70,@00,@00,@00,@00,@00,@00,@00)                LDW1
         DC    AL1(@78,@79,@7A,@7B,@7C,@7D,@7E,@7F)                LDW1
         DC    AL1(@80,@00,@82,@83,@84,@85,@86,@87)                LDW1
         DC    AL1(@88,@89,@8A,@8B,@8C,@8D,@8E,@8F)                LDW1
         DC    AL1(@90,@91,@92,@93,@94,@95,@96,@97)                LDW1
         DC    AL1(@98,@00,@00,@00,@9C,@9D,@9E,@9F)                LDW1
         DC    AL1(@00,@00,@00,@00,@00,@00,@00,@00)                LDW1
         DC    AL1(@00,@00,@00,@00,@AC,@AD,@AE,@AF)                LDW1
         DC    AL1(@00,@B1,@B2,@00,@00,@00,@B6,@B7)                LDW1
         DC    AL1(@00,@00,@BA,@BB,@00,@BD,@BE,@BF)                LDW1
         DC    AL1(@00,@00,@00,@00,@00,@00,@00,@00)                LDW1
         DC    AL1(@00,@00,@00,@00,@00,@00,@00,@00)                LDW1
         DC    AL1(@00,@D1,@D2,@D3,@D4,@D5,@D6,@D7)                LDW1
         DC    AL1(@00,@00,@00,@00,@DC,@DD,@DE,@DF)                LDW1
         DC    AL1(@00,@00,@00,@00,@00,@00,@00,@00)                LDW1
         DC    AL1(@00,@00,@00,@00,@00,@00,@00,@00)                LDW1
         DC    AL1(@F0,@F1,@F2,@F3,@00,@00,@00,@00)                LDW1
         DC    AL1(@F8,@F9,@FA,@FB,@FC,@FD,@00,@00)                LDW1
         TITLE 'O P C O D E   T A B L E'
*
* RR TYPE:
*    C'(',X'4D' - EXTENDED MNEMONIC
*    C'+',X'4E' - SVC       IMED
*    C'|',X'4F' - NORMAL RR TYPE
*    C'&',X'50' - SPM TYPE
*
* RX TYPE:
*    C'O',X'D6' - INDEX REGISTER USED   R1,D2(X2,B2)
*    C'M',X'D4' - EXTENDED MNENOMIC     D2(X2,B2)
*    C'L',X'D3' - SI TYPE               D1(B1),I2
*    C'J',X'D1' - DIAGNOSE,SVCX   IMED  I
*    C'K',X'D2' - DISP(BASE) TYPE       D1(B1)
*    C'R',X'D9' - BXLE,BXH,STM,LM       R1,R3,D2(B2)
*    C'Q',X'D8' - REG SHIFT TYPE        R1,D2(B2)
*
* SS TYPE:
*    C'S',X'E2' - TWO LENGTHS REQUIRED
*    C'T',X'E3' - ONLY ONE LENGTH
*
*
*  TABLE FORMAT:
*
*        CL4'MNEUMONIC',C'FLAG',X'OPCODE'
*
         PRINT NOGEN
OPCODES  DS    0C
@00      EQU   0                        FOR UNDEFINED OPCODES      LDW1
         OP    SPM,|,04
         OP    BALR,|,05
         OP    BCTR,|,06
         OP    BCR,'(',07
         OP    SSK,|,08
         OP    ISK,|,09
         OP    SVC,+,0A
         OP    MVCL,|,0E                                           LDW1
         OP    CLCL,|,0F                                           LDW1
         OP    LPR,|,10
         OP    LNR,|,11
         OP    LTR,|,12
         OP    LCR,|,13
         OP    NR,|,14
         OP    CLR,|,15
         OP    OR,|,16
         OP    XR,|,17
         OP    LR,|,18
         OP    CR,|,19
         OP    AR,|,1A
         OP    SR,|,1B
         OP    MR,|,1C
         OP    DR,|,1D
         OP    ALR,|,1E
         OP    SLR,|,1F
         OP    LPDR,|,20
         OP    LNDR,|,21
         OP    LTDR,|,22
         OP    LCDR,|,23
         OP    HDR,|,24
         OP    LRDR,|,25
         OP    MXR,|,26
         OP    MXDR,|,27
         OP    LDR,|,28
         OP    CDR,|,29
         OP    ADR,|,2A
         OP    SDR,|,2B
         OP    MDR,|,2C
         OP    DDR,|,2D
         OP    AWR,|,2E
         OP    SWR,|,2F
         OP    LPER,|,30
         OP    LNER,|,31
         OP    LTER,|,32
         OP    LCER,|,33
         OP    HER,|,34
         OP    LRER,|,35
         OP    AXR,|,36
         OP    SXR,|,37
         OP    LER,|,38
         OP    CER,|,39
         OP    AER,|,3A
         OP    SER,|,3B
         OP    MER,|,3C
         OP    DER,|,3D
         OP    AUR,|,3E
         OP    SUR,|,3F
         OP    STH,O,40
         OP    LA,O,41
         OP    STC,O,42
         OP    IC,O,43
         OP    EX,O,44
         OP    BAL,O,45
         OP    BCT,O,46
         OP    BC,M,47
         OP    LH,O,48
         OP    CH,O,49
         OP    AH,O,4A
         OP    SH,O,4B
         OP    MH,O,4C
         OP    CVD,O,4E
         OP    CVB,O,4F
         OP    ST,O,50
         OP    SVCX,J,51
         OP    N,O,54
         OP    CL,O,55
         OP    O,O,56
         OP    X,O,57
         OP    L,O,58
         OP    C,O,59
         OP    A,O,5A
         OP    S,O,5B
         OP    M,O,5C
         OP    D,O,5D
         OP    AL,O,5E
         OP    SL,O,5F
         OP    STD,O,60
         OP    MXD,O,67
         OP    LD,O,68
         OP    CD,O,69
         OP    AD,O,6A
         OP    SD,O,6B
         OP    MD,O,6C
         OP    DD,O,6D
         OP    AW,O,6E
         OP    SW,O,6F
         OP    STE,O,70
         OP    LE,O,78
         OP    CE,O,79
         OP    AE,O,7A
         OP    SE,O,7B
         OP    ME,O,7C
         OP    DE,O,7D
         OP    AU,O,7E
         OP    SU,O,7F
         OP    SSM,K,80
         OP    LPSW,K,82
         OP    DIAG,J,83
         OP    WRD,L,84
         OP    RDD,L,85
         OP    BXH,R,86
         OP    BXLE,R,87
         OP    SRL,Q,88
         OP    SLL,Q,89
         OP    SRA,Q,8A
         OP    SLA,Q,8B
         OP    SRDL,Q,8C
         OP    SLDL,Q,8D
         OP    SRDA,Q,8E
         OP    SLDA,Q,8F
         OP    STM,R,90
         OP    TM,L,91
         OP    MVI,L,92
         OP    TS,K,93
         OP    NI,L,94
         OP    CLI,L,95
         OP    OI,L,96
         OP    XI,L,97
         OP    LM,R,98
         OP    SIO,K,9C
         OP    TIO,K,9D
         OP    HIO,K,9E
         OP    TCH,K,9F
         OP    STNSM,L,AC                                          LDW1
         OP    STOSM,L,AD                                          LDW1
         OP    SIGP,R,AE                                           LDW1
         OP    MC,L,AF                                             LDW1
         OP    LRA,O,B1                                            LDW1
         OP    S370,K,B2                                           LDW1
         OP    STCTL,R,B6                                          LDW1
         OP    LCTL,R,B7                                           LDW1
         OP    CS,R,BA                                             LDW1
         OP    CDS,R,BB                                            LDW1
         OP    CLM,R,BD                                            LDW1
         OP    STCM,R,BE                                           LDW1
         OP    ICM,R,BF                                            LDW1
         OP    MVN,C,D1
         OP    MVC,C,D2
         OP    MVZ,C,D3
         OP    NC,C,D4
         OP    CLC,C,D5
         OP    OC,C,D6
         OP    XC,C,D7
         OP    TR,C,DC
         OP    TRT,C,DD
         OP    ED,C,DE
         OP    EDMK,C,DF
         OP    SRP,S,F0                                            LDW1
         OP    MVO,B,F1
         OP    PACK,B,F2
         OP    UNPK,B,F3
         OP    ZAP,B,F8
         OP    CP,B,F9
         OP    AP,B,FA
         OP    SP,B,FB
         OP    MP,B,FC
         OP    DP,B,FD
OPEND    EQU   *
OPLEN    EQU   6
         SPACE 3
         LTORG
         SPACE 3
         END
         TITLE '   O A C N O W   '
***********************************************************************
*                                                                     *
*        'OACNOW'                                                     *
*                                                                     *
***********************************************************************
         SPACE
*        WRITTEN BY. BILL GODFREY, PRC (PLANNING RESEARCH CORPORATION).
*        INSTALLATION. AIR FORCE DATA SERVICES CENTER, PENTAGON.
*        DATE WRITTEN. OCTOBER 1 1981.
*        DATE UPDATED.
*        ATTRIBUTES. REENTRANT.
*        DESCRIPTION.
*         THIS SUBPROGRAM FORMATS THE DATE AND TIME, THEN RETURNS
*         THE ADDRESS OF THE RESULTS IN REGISTER 1.
*
*         IT IS CALLED BY THE 'ZAP' TSO COMMAND FROM UCLA.
*         THIS VERSION OF 'OACNOW' WAS WRITTEN AT AFDSC/PENTAGON
*         AFTER WE INSTALLED THE ZAP COMMAND AND DISCOVERED THAT
*         'OACNOW' WAS MISSING.  THIS IS A VERSION OF THE 'JULSUB'
*         SUBPROGRAM MODIFIED TO CONFORM TO 'OACNOW' PROTOCOL.
*
*            INPUT - NONE (CALLER SET R1 TO ZERO, BUT WE IGNORE IT).
*
*            OUTPUT - REGISTER 1 POINTS TO:
*               +0  HH:MM:SS
*               +14  MM/DD/YY
*               +24  CL9'WEEKDAY'                      '
*               +34  MMM(M) (D)D, 19YY
*             REGISTER 0 CONTAINS LENGTH OF DATA POINTED TO BY REG 1.
*             CALLER SHOULD ISSUE FREEMAIN R,LV=(0),A=(1).
         SPACE
         MACRO
         STAMP
         LCLC  &ASMTIME
&ASMTIME SETC  '&SYSTIME'(1,5)
         DC    CL16' &SYSDATE &ASMTIME '
         MEND
         SPACE
OACNOW   CSECT
         USING *,R12
         B     @PROLOG-*(,15)
         DC    AL1(11),CL11'OACNOW'
         STAMP
@SIZE    DC    A(@DATAL)           LENGTH OF WORKAREA
@PROLOG  STM   14,12,12(13)
         LR    R12,15
         L     R0,@SIZE
         GETMAIN R,LV=(0)          GET SAVEAREA ADDRESS
         ST    13,4(,1)
         ST    1,8(,13)
         LR    13,1
         USING @DATA,R13
         SPACE
         LA    R0,RESULTL          GET LENGTH OF RESULTS
         GETMAIN R,LV=(0)          GET AREA FOR RESULTS
         ST    R1,RESULTA
         XC    DOUBLE,DOUBLE
         SLR   R14,R14             ZERO R14
         ST    R14,FRSTLAST
         ST    R14,TIMEB
         TIME  BIN
         ST    R0,TIMEB            SAVE TIME
         SLR   R0,R0
         STM   R0,R1,DOUBLE        SAVE DATE
         CVB   R1,DOUBLE
         ST    R1,JB
         L     R14,DOUBLE+4        SAVE 00YYDDDF
         LH    R1,DOUBLE+4         GET 00YY
         SLL   R1,16               GET 00YY0000
         SRL   R1,12               GET 00000YY0
         ST    R1,DOUBLE+4         STORE BACK 00000YY0
         OI    DOUBLE+7,X'0F'      SET SIGN
         CVB   R1,DOUBLE
         ST    R1,YYYYB
         CH    R1,=H'99'
         BH    *+8
         AH    R1,=H'1900'
         ST    R1,CENTB
         UNPK  YYYYC,DOUBLE+5(3)     SAVE YYYY CHAR
         MVC   YYC,YYYYC+2
*
         ST    R14,DOUBLE+4        RESTORE 00YYDDDF
         XC    DOUBLE(6),DOUBLE      00YYDDDF TO 0000DDDF
         OI    DOUBLE+7,X'0F'      SET SIGN
         UNPK  DDDC,DOUBLE+4(4)    SAVE DDD CHAR
         CVB   R1,DOUBLE           CONVERT DDD TO BINARY
         ST    R1,DDDB             SAVE DDD BINARY
         SPACE
         BAL   R9,TODD
         BAL   R9,TOMON
         BAL   R9,TOTIME
         BAL   R9,OUTPUT
         B     EXIT0
         SPACE
*              CONVERT JULIAN DATE TO MONTH-DAY-YEAR
*
*                 INPUT  - YYYYB AND DDDB   (ALSO YYC)
*
*                 OUTPUT - MMB AND DDB, MMC AND DDC, FRSTLAST
         SPACE
TODD     MVC   DPM(26),DAYSPMON
         TM    YYYYB+3,B'00000011' IS YEAR A MULTIPLE OF 4?
         BNZ   DPM365              NO - BRANCH
         CLC   YYC,=C'00'          DIVISIBLE BY 100?
         BNE   DPM366              NO - BRANCH
         L     R15,CENTB
         SLR   R14,R14
         D     R14,=F'400'
         LTR   R14,R14             EVENLY DIVISIBLE BY 400?
         BNZ   DPM365              NO - NOT A LEAP YEAR
DPM366   MVI   DPM+3,29            CHANGE FEB TO 29 DAYS
DPM365   EQU   *
         LA    R14,2               INDEX FOR DPM
         LR    R0,R14              INDEX INCREMENT
         L     R1,DDDB             DAY OF YEAR
DPMLOOP  CH    R1,DPM-2(R14)       DAY LESS THAN OR EQ ENTRY?
         BE    DPMEND              EQUAL - BRANCH
         BL    DPMWIN              LESS - BRANCH
         SH    R1,DPM-2(R14)       NO, SUBTRACT ENTRY FROM DAY
         ALR   R14,R0              ADD 2 TO INDEX
         B     DPMLOOP             LOOP
DPMEND   MVI   FRSTLAST+3,2        LAST DAY OF MONTH
         B     DPMCOMM
DPMWIN   CH    R1,=H'1'            FIRST OF MONTH?
         BNE   DPMCOMM             NO - BRANCH
         MVI   FRSTLAST+3,1        FIRST DAY OF MONTH
DPMCOMM  SRL   R14,1               HALVE INDEX TO GET MM
         ST    R1,DDB              SAVE DD BINARY
         CVD   R1,DOUBLE           CONVERT TO PACKED
         OI    DOUBLE+7,X'0F'      SET SIGN
         UNPK  DDC,DOUBLE+6(2)     SAVE DD CHAR
         ST    R14,MMB             SAVE MM BINARY
         CVD   R14,DOUBLE          CONVERT TO PACKED
         OI    DOUBLE+7,X'0F'      SET SIGN
         UNPK  MMC,DOUBLE+6(2)     SAVE MM CHAR
         MVI   SLASH1,C'/'
         MVI   SLASH2,C'/'
         BR    R9
         SPACE
*              CONVERT MONTH NUMBER TO MONTH NAME
*
*                 INPUT  - MMB     (ALSO DDC AND YYC FOR MOVE)
*
*                 OUTPUT - MONTH AND ALPHA
         SPACE
TOMON    L     R15,MMB
         MH    R15,=H'9'           MULT BY 9
         LA    R15,ALPHAMON-9(R15) ADDRESS OF ENTRY
         MVC   MONTH,0(R15)        SAVE PROSE MONTH
         MVC   ALPHA+2(3),0(R15)   SAVE ALPHA MONTH
         MVC   ALPHA(2),DDC
         MVC   ALPHA+5(2),YYC
         MVI   ALPHA+7,C' '
         BR    R9
         SPACE
*
*              CONVERT TIMEB TO TIMEC
*
*                 DIVIDE BY 10,10,10,6,10,6,10,6
*
TOTIME   L     R15,TIMEB
         LA    R6,10               INITIAL DIVISOR
         LA    R7,12               SET DIVISOR MASK
         LA    R8,32               SHIFT COUNT
DECLOOP  SR    R14,R14
         DR    R14,R6
         LR    R0,R14              SAVE REMAINDER
         SRDL  R0,4                SHIFT INTO R1
         SH    R8,=H'4'            DECREMENT SHIFT COUNT
         LTR   R15,R15             QUOTIENT ZERO?
         BZ    TOTIMX              YES - BRANCH
         CL    R8,=F'24'           IF COUNT LT 24
         BNL   DECLOOP             NO - BRANCH
         XR    R6,R7               10 TO 6 TO 10 ETC
         B     DECLOOP
TOTIMX   SRL   R1,0(R8)            SHIFT REMAINING BITS
         SRL   R1,4                GET 0HHMMSST
         ST    R1,DOUBLE
         OI    DOUBLE+3,X'0F'
         MVC   DOUBLE+6(10),=X'402120204B20204B2020'
         ED    DOUBLE+6(10),DOUBLE
         MVC   TIMEC,DOUBLE+8
         BR    R9
         SPACE
OUTPUT   L     R1,RESULTA
         MVI   0(R1),C' '          FILL
         MVC   1(RESULTL-1,R1),0(R1) WITH BLANKS
         MVC   00(08,R1),TIMEC     HH.MM.SS
         MVC   14(08,R1),MMC       MM/DD/YY
         MVC   24(09,R1),WEEKC     THURSDAY
         MVC   34(03,R1),MONTH     OCT
         BR    R9
         SPACE
EXIT0    L     R2,RESULTA          GET ADDRESS OF RESULTS
         L     R0,@SIZE            SET UP R0 FOR FREEMAIN
         LR    R1,R13              SET UP R1 FOR FREEMAIN
         L     R13,4(,R13)
         ST    R2,24(,R13)         LM WILL PUT A(RESULTS) IN R1
         LA    R2,RESULTL          GET LENGTH OF RESULTS
         ST    R2,20(,R13)         LM WILL PUT L'RESULTS IN R0
         FREEMAIN R,LV=(0),A=(1)
         LM    14,12,12(R13)
         SR    R15,R15
         BR    R14
         SPACE
************************************************************
*                                                          *
*        CONSTANTS                                         *
*                                                          *
************************************************************
         SPACE
DAYSPMON DC    H'31,28,31,30,31,30,31,31,30,31,30,31,999'
ALPHAMON DC    CL36'JANUARY  FEBRUARY MARCH    APRIL    '
         DC    CL36'MAY      JUNE     JULY     AUGUST   '
         DC    CL36'SEPTEMBEROCTOBER  NOVEMBER DECEMBER '
         DC    CL09'UNKNOWN  '
WEEKDAYS DC    CL36'SATURDAY SUNDAY   MONDAY   TUESDAY  '
         DC    CL27'WEDNESDAYTHURSDAY FRIDAY   '
WEEKBLNK EQU   WEEKDAYS+15         3 BLANKS
         LTORG
         SPACE
************************************************************
*                                                          *
*        DSECTS                                            *
*                                                          *
************************************************************
         SPACE
@DATA    DSECT
         DS    18F
DOUBLE   DS    D
WORK     DS    8C
SC       DS    0CL8
MMC      DS    CL2
SLASH1   DS    C
DDC      DS    CL2
SLASH2   DS    C
YYC      DS    CL2
YYYYC    DS    CL4
DDB      DS    F
MMB      DS    F
YYYYB    DS    F
CENTB    DS    F
DDDB     DS    F
JB       DS    F
SB       DS    F
WEEKB    DS    F
FRSTLAST DS    F
TIMEB    DS    F
TIMEC    DS    CL8
JC       DS    0CL5
         DS    CL2
DDDC     DS    CL3
MONTH    DS    CL9
ALPHA    DS    0CL8
         DS    CL2
MON      DS    CL3
         DS    CL2
         DS    CL1                 BLANK FILLER LAST BYTE OF ALPHA
WEEKC    DS    CL12
PROSE    DS    CL20
DPM      DS    13H
RESULTA  DS    F
RESULTL  EQU   72
         DS    0D
@DATAL   EQU   *-@DATA
         SPACE
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         END
