 CALC:  PROC OPTIONS(MAIN);
    /****************************************
    TSO CALCULATOR PROGRAM
    ****************************************/

    DFT RANGE(*) BIN FIXED;
    DCL NDSTACK(0:100) FLOAT(53) INIT((101)0), AR FLOAT(53) INIT(0),
         ORSTACK(0:100) INIT((101)0), OR_, ND_,
         (BUF, BUF2) INIT((120)' ') CHAR(120), CURSOR,
         PREV_OR BIT(1),
         LS BIN FIXED(31), /*TERMINAL LINESIZE*/
         I, J, K, OP_TYPE, OP_PRTY,
         (REGS(0:9) INIT((10)0), TEMP) FLOAT(53),
         TN CHAR(1), TNV CHAR(30) VAR,
         OVLY1(120) BIT(8) BASED(P_), OVLY2(120) BIT(8) BASED(Q_),
         BLANKS CHAR(120) INIT((120)' '),
         (END_FLAG, PRINT_ON, PRINT_KEYW, PRINT_PAREN)BIT(1) INIT('0'B),
         PRINTFLAGS(0:10) BIT(1) INIT((11)(1)'0'B),
         ATTN BIN FIXED(31) INIT(0),
      /* STAX ENTRY(BIN FIXED(31)) EXTERNAL, TCLEARQ ENTRY EXTERNAL,
         ASTAR ENTRY(BIN FIXED(31)) EXTERNAL, */ ASTATUS BIN FIXED(31),
        /* GTSIZE ENTRY(BIN FIXED(31)) EXTERNAL,                    */
         PRTY(0:20) INIT(-1,0,1,1,2,2,3,4,
              0,0,0,0,0,0,0,0,0,0,0,0,0);

    DCL (FLOAT, FIXED, AUTO, FORM_KEYW, FORM_PAREN) BIT(1) INIT('0'B);
    DCL TRACE BIT(1) INIT('0'B); /*FOR DEBUG TRACING*/
    DCL (F1, F2, FCOUNT, PREC, FRAC) BIN FIXED INIT(0);
    DCL #BUF CHAR(80) INIT((80)' ');


    DCL 1 FUNC BASED(F_),
         2 FNAME CHAR(8),
         2 FIRST_LINE PTR,
         2 NXT_FUNC PTR,
    1 LDATA BASED(L_),
         2 LINE CHAR(72),
         2 NXT_LINE PTR,
    1 GET_STACK(25),
         2 # FLOAT(53) INIT((25)0E0),
         2 EXEC_COUNT BIN FIXED,
         2 GF_ PTR,
         2 GL_ PTR,
    AREA AREA(10000) CTL,
    GET_ BIN FIXED,
    EXEC_LIST(25) BIT(1),
    NULL BUILTIN,
    (TPTR, TPTR2, TPTR3, FRST_FUNC) PTR;

    FRST_FUNC=NULL;
    GET_=1;
    GF_(1), GL_(1) = NULL;

    ON AREA CALL ERROR('75 UNABLE TO ALLOCATE SPACE FOR '||
         'NEW FUNCTION LINE.  USE ERASE TO RECOVER STORAGE.');


    /**************ERROR HANDLING**************/
    ON OFL CALL ERROR('10 RESULT OUT OF RANGE '||
         'OVERFLOW HAS OCCURRED.');
    ON ERROR BEGIN;
         ON ERROR SYSTEM;
         CALL ERROR('19 UNDETECTED ERROR, CAUSE IS UNKNOWN, CODE IS'||
              ONCODE());
         GOTO GET;
         END;
    ON UFL CALL ERROR('09 RESULT OUT OF RANGE '||
         'NUMBER < 10**-78 HAS CAUSED UNDERFLOW');
    ON CONV CALL ERROR('08 INVALID NUMBER '||TNV);
    ON SIZE CALL ERROR('17 NUMERICAL SIZE ERROR');
    ON ZDIV CALL ERROR('18 ATTEMPT TO DIVIDE BY ZERO');

    /*********SUBROUTINES********/

 TGET:  PROC(PROMPT);
    /*INPUT STACK MANAGER.
    GET_=1 CORRESPONDS TO TERMINAL INPUT.
    GET_>1 MEANS INPUT FROM AN IN-CORE LIST*/
    DCL PROMPT CHAR(*), I BIN FIXED;

 TGLOOP:
    IF ATTN>0 THEN GOTO ATTENTION;
    IF GET_=1 THEN DO; /*TERMINAL I/O*/
         #BUF=' ';  /*FORGET UNUSET RESPONSES TO '#'*/
         PUT EDIT(PROMPT||':') (A);
         GET EDIT(BUF) (COL(1),A(LS));
         OVLY1=OVLY1 | OVLY2;  /*CONVERT TO UPPER CASE*/
         RETURN;
         END;

    IF GL_(GET_)=NULL /*END OF FUNCTION*/
              THEN IF EXEC_COUNT(GET_)>0 THEN DO; /*RESTART*/
              EXEC_COUNT(GET_)=EXEC_COUNT(GET_)-1;
              GL_(GET_)=GF_(GET_)->FIRST_LINE;
              GOTO TGLOOP;
              END;
         ELSE DO; /*DON'T RESTART*/
              GET_=GET_-1;  /*POP GET STACK*/
              GOTO TGLOOP;
              END;
    BUF=GL_(GET_)->LINE; /*LINE TO BE RETURNED*/
    IF EXEC_LIST(GET_) THEN DO;
         DO I=72 TO 2 BY -1 WHILE(SUBSTR(BUF,I,1)=' ');
         END;
         CALL PUTLIST('  '||SUBSTR(BUF,1,I));
         END;
    GL_(GET_)=GL_(GET_)->NXT_LINE;
    END TGET;


    /*FUNCTION TO PICK UP NAME KEYWORD ON
         LEARN, EXEC, AND ERASE COMMANDS*/
 GETNAME:  PROC(STR,PTR);
    DCL STR CHAR(*) VAR, GNAME CHAR(9) VAR,
         I BIN FIXED, PTR PTR, TN CHAR(1);
 GLOOP:
    IF SUBSTR(BUF,CURSOR+1)=' ' THEN /*BLANK LINE*/
         CALL ERROR('35 MISSING FUNCTION NAME.');
    TN=NEXT;
    IF TN='-' THEN DO;
         CALL TGET('?');
         CURSOR=0;
         GOTO GLOOP;
         END;
    DO WHILE(TN=' ');  TN=NEXT;  END; /*SKIP BLANKS*/
    GNAME=TN;
    DO I=1 TO 8; /*SCAN UP TO 8 CHAR*/
    TN=NEXT;
    IF TN=' ' THEN GOTO ENLP;
    IF TN='''' & PRINT_KEYW THEN GOTO ENLP;
    IF TN=')' & PRINT_PAREN THEN DO;
         CURSOR=CURSOR-1;
         GOTO ENLP;
         END;
    GNAME=GNAME||TN;
    END;
    CALL ERROR('36 FUNCTION-NAME BEGINNING ' ||GNAME||
         ' IS LONGER THAN 8 CHARACTERS.');
 ENLP:
    STR=GNAME;  /*NAME EXTRACTED*/
    PTR=FRST_FUNC; /*NOW LOOK IT UP*/
    DO I=1 BY 1;
    IF PTR=NULL THEN RETURN; /*NOT FOUND*/
    IF ATTN>0 THEN GOTO ATTENTION;
    IF PTR->FNAME=STR THEN RETURN; /*FOUND*/
    PTR=PTR->NXT_FUNC;
    END;

    END GETNAME;

    /*GET NEXT CHARACTER ROUTINE*/
 NEXT:  PROC RETURNS (CHAR(1));
    CURSOR=CURSOR+1;
    IF GET_=1 THEN /*TERMINAL INPUT*/
         IF CURSOR>LS THEN GOTO ALLPOP;
         ELSE;
    ELSE IF CURSOR>72 THEN GOTO ALLPOP;
 LAST:  ENTRY RETURNS(CHAR(1));
    RETURN (SUBSTR(BUF,CURSOR,1));
    END NEXT;

    /*ERROR HANDLING*/
 ERROR:  PROC(STR);
    DCL STR CHAR(*);
    PRINTFLAGS='0'B; /*CLEAR PREVIOUS PRINT STATUS*/
    PRINT_KEYW, PRINT_PAREN, FORM_KEYW,
         FORM_PAREN='0'B;  /*CLEAR KEYWORD FLAGS*/
    #BUF=' ';  /*CLEAR UNUSED ENTRIES FOR '#'*/
    GET_=1; /*POP STACK TO TERMINAL I/O*/
    IF CURSOR<LS THEN DO;  PUT EDIT('$') (COL(CURSOR+2),A);
         PUT SKIP;  END;
    CALL PUTLIST('ERROR - CALC' || STR);
    GOTO GET;
    END ERROR;

    /*NUMBER CONVERSION...
         IF SWITCH=TRUE THEN RETURN FLOAT,
         ELSE RETURN FIXED*/
 NUM:  PROC(FIXED, FLOAT, SWITCH);
    DCL (ESW,PSW, SWITCH) BIT(1),
         FIXED BIN FIXED, FLOAT FLOAT(53),
         TN CHAR(1);
    TNV=' '||LAST;  ESW, PSW='0'B;  TN=NEXT; /*INITIALIZE*/
 LOOP:  /*SCAN DIGITS*/
    DO WHILE(TN>='0'&LENGTH(TNV)<28);  TNV=TNV||TN;
         IF CURSOR >= 72 THEN GOTO GETSTRING;
         TN=NEXT;
         IF ATTN>0 THEN GOTO ATTENTION;
         END;
    IF LENGTH(TNV)>27 THEN
         CALL ERROR('29 NUMBER'||TNV||' TOO LONG.');
    /*NON-DIGIT FOUND*/
    IF TN='E' THEN DO;  /*E-NOTATION?*/
         IF SWITCH THEN;  ELSE SIGNAL CONVERSION;  /*NOT FOR FIXED*/
         IF ESW THEN SIGNAL CONVERSION;  /*DOUBLE E*/
         TNV=TNV||TN;  TN=NEXT;
         IF TN='+' | TN='-' THEN DO; /*E+ OR E-*/
              TNV=TNV||TN;  TN=NEXT;
              END;
         ESW='1'B;  /*WE'VE FOUND AN E*/
         GOTO LOOP;  /*SCAN EXPONENT*/
         END;
    IF TN='.' THEN DO; /*DECIMAL POINT*/
         IF ESW THEN SIGNAL CONVERSION;  /*'.' IN EXPONENT*/
         IF PSW THEN SIGNAL CONVERSION;  /*SECOND '.'*/
         PSW='1'B;
              TNV=TNV||TN;  TN=NEXT;
              GOTO LOOP;  /*SCAN FRACTION*/
              END;
 GETSTRING:
    TNV=TNV||' ';
    IF SWITCH THEN GET STRING(TNV) LIST(FLOAT);
    ELSE GET STRING(TNV) LIST(FIXED);
    END NUM;

    /*PUSH AND POP ROUTINES FOR OPERAND STACK*/
 PUSHND:  PROC(X);
    DCL X FLOAT(53);
    PREV_OR='0'B;
    NDSTACK(ND_)=X;
    ND_=ND_+1;
    IF ND_>100 THEN CALL ERROR('12 INPUT TOO LONG'||
         ', PROBABLY TOO MANY OPERANDS');
    END PUSHND;

 POPND:  PROC RETURNS(FLOAT(53));
    IF ND_=1 THEN CALL ERROR('11 INVALID EXPRESSION'||
         ', ONE OR MORE OPERANDS MISSING');
    ND_=ND_-1;
    RETURN(NDSTACK(ND_));
    END POPND;

 PUSHOR:  PROC(OP);
    DCL OP BIN FIXED;
    PREV_OR='1'B;
    IF ORSTACK(OR_-1)>8 /*FUNCTION*/ THEN
         IF OP=8 /*(*/ THEN RETURN;
    ORSTACK(OR_)=OP;
    OR_=OR_+1;  PREV_OR='1'B;
    IF OR_>100 THEN CALL ERROR('13 INPUT TOO LONG'||
         ', TOO MANY OPERATORS OR TOO MANY PARENTHESES');
    END PUSHOR;

 POPOR:  PROC(OP);
    DCL OP BIN FIXED;
    IF OR_=1 THEN CALL ERROR('14 INVALID EXPRESSION'||
         ', ONE OR MORE OPERATORS OMITTED');
    OR_=OR_-1;
    OP=ORSTACK(OR_);
    END POPOR;

    /*ARITHMETIC EXECUTION ROUTINE*/
 EXEC:  PROC(OP);
    /*PERFORMS OP ON LAST OR LAST TWO NDSTACK
         ENTRIES AND LEAVES RESULT ON TOP OF
    NDSTACK.  OPERANDS ARE POPPED OFF
         NDSTACK AND DESTROYED*/
    DCL OP BIN FIXED, (T1, T2) FLOAT(53) INIT(0E0);
    DCL TYPE(0:20) LABEL;
    T2=POPND;
    IF OP < 7 THEN T1=POPND; /*BINARY OPERATOR*/
    IF OP=11|OP=12|OP=13 THEN /*NEGATIVE ARG TO LOG*/
         IF T2<=0 THEN CALL ERROR('20 ATTEMPT TO TAKE LOG OF ARG<=0.');
    IF OP=14 THEN /*NEGATIVE ARG TO SQRT*/
         IF T2<0 THEN CALL ERROR('21 ATTEMPT TO TAKE NEG SQRT');
    GOTO TYPE(OP);

 TYPE(8):
    GOTO RET;
 TYPE(0):  TYPE(1):  TYPE(19):  TYPE(20):
    CALL ERROR('16 PROGRAM ERROR');
 TYPE(2):  CALL PUSHND(T1+T2);  GOTO RET;
 TYPE(3):  CALL PUSHND(T1-T2);  GOTO RET;
 TYPE(4):  CALL PUSHND(T1/T2);  GOTO RET;
 TYPE(5):  CALL PUSHND(T1*T2);  GOTO RET;
 TYPE(6):  IF ABS(T1)<1E-20 THEN CALL PUSHND(0E0);
    ELSE IF T1>0 THEN CALL PUSHND(T1**T2);
    ELSE IF FLOOR(T1)=CEIL(T1) THEN
         IF MOD(T2,2)=0 THEN CALL PUSHND(ABS(T1)**T2);
         ELSE CALL PUSHND(-ABS(T1)**T2);
    ELSE CALL ERROR('31 ILLEGAL OPERATION '||T1||' ** ' ||
         T2);
    GOTO RET;
 TYPE(7):  CALL PUSHND(-T2);     GOTO RET;
 TYPE(9):  CALL PUSHND(SIN(T2));  GOTO RET;
 TYPE(10): CALL PUSHND(COS(T2));  GOTO RET;
 TYPE(11): CALL PUSHND(LOG10(T2));  GOTO RET;
 TYPE(12): CALL PUSHND(LOG(T2));  GOTO RET;
 TYPE(13):  CALL PUSHND(LOG2(T2));  GOTO RET;
 TYPE(14):  CALL PUSHND(SQRT(T2));  GOTO RET;
 TYPE(15):  CALL PUSHND(ABS(T2));  GOTO RET;
 TYPE(16):  CALL PUSHND(ATAN(T2));  GOTO RET;
 TYPE(17):  CALL PUSHND(TAN(T2));  GOTO RET;
 TYPE(18):  CALL PUSHND(FACT(T2));  GOTO RET;

 RET:
    END EXEC;


    /*******MAIN LINE PROGRAM********/
    ASTATUS=0; /* CALL ASTAR(ASTATUS); */ /*ALLOC SYSIN & SYSPRINT*/
    PUT SKIP EDIT(
    '* * * TSO CALCULATOR PROGRAM * * *',
    'FOR DIRECTIONS, TYPE ''HELP'', OR ''END'' TO QUIT') (A,SKIP);
    PUT SKIP;
    PRINT_ON='1'B;  /*PRINT ON IS THE DEFAULT*/

    P_=ADDR(BUF);  Q_=ADDR(BLANKS);
    /*CALL STAX(ATTN);  */ /*SET UP ATTN HANDLER*/
   /* CALL GTSIZE(LS);  */ /*GET TERMINAL LINESIZE*/
    /* IF LS>80 THEN DO;
         CALL PUTLIST('CALC61 LINESIZE(80) WILL BE USED.');         */
         LS=80;
        /* END;                                                     */
    GOTO GET;


 ATTENTION:  PRINTFLAGS='0'B;  GET_=1;
    ATTN=0;  /* CALL TCLEARQ;                                       */
    PRINT_KEYW, PRINT_PAREN, FORM_KEYW,
         FORM_PAREN='0'B;  /*CLEAR KEYWORD FLAGS*/
    #BUF=' ';  /*FORGET UNUSED RESPONSES TO '#'*/


 GET:
    IF ATTN>0 THEN GOTO ATTENTION;
    PREV_OR='0'B;  OR_, ND_ = 1;
 CONT:  /* CONTINUED LINE -- ENDS WITH A '-' */
    CURSOR=0;
    CALL TGET('?');  /*READ 'LS' CHAR*/
 PRESCAN:
    I=VERIFY(BUF,' ');
    IF I=0 THEN GOTO GET;  /*EMPTY LINE*/
    BUF=SUBSTR(BUF,I);  /*SKIP BLANKS*/
    IF SUBSTR(BUF,1,2)='H ' THEN DO;  /*HELP*/
         BUF=SUBSTR(BUF,3);
         CALL HELP;  GOTO GET;
         END;
    IF SUBSTR(BUF,1,5)='HELP ' THEN DO;
         BUF=SUBSTR(BUF,6);
         CALL HELP;  GOTO GET;
         END;



    IF SUBSTR(BUF,1,5)='LEARN' THEN DO;
         CURSOR=5;  /*PAST KEYWORD*/
         CALL GETNAME(TNV,TPTR); /*GET FUNC NAME*/
         IF TPTR=NULL THEN;  /*OK, FUNC IS NEW*/
         ELSE CALL ERROR('50 FUNCTION '||TNV||
         ' ALREADY EXISTS');
         IF LS>72 THEN CALL PUTLIST('CALC62 WARNING:  ONLY UP ' ||
              'TO 72 CHAR/LINE ALLOWED IN LEARN MODE.');
         IF ALLOCATION(AREA)=0 THEN ALLOCATE AREA;
         ALLOCATE FUNC IN(AREA); /*FUNCTION HEADER*/
         NXT_FUNC=FRST_FUNC;  FRST_FUNC=F_; /*LINK IN*/
         FNAME=TNV;  L_=NULL;  FIRST_LINE=NULL;
      LLOOP:
         IF ATTN>0 THEN GOTO ATTENTION;
         CALL TGET('L'); /*GET A LINE*/
         I=VERIFY(BUF,' ');
         IF I=0 THEN GOTO LLOOP; /*BLANK LINE*/
         IF SUBSTR(BUF,I,3)='END' /*END OF LEARN MODE*/
              THEN GOTO GET;
         TPTR=L_;
         ALLOCATE LDATA IN(AREA); /*STORE FOR THIS LINE*/
         NXT_LINE=NULL;  /*LINK IN*/
         IF TPTR=NULL THEN F_->FIRST_LINE=L_;
         ELSE TPTR->NXT_LINE=L_;
         L_->LINE=SUBSTR(BUF,1,72);
         GOTO LLOOP;
         END;


    IF SUBSTR(BUF,1,5)='ERASE' THEN DO;
         CURSOR=5;
         CALL GETNAME(TNV,TPTR);
         IF TPTR=NULL THEN CALL ERROR('36 FUNCTION '|| TNV ||
              ' NOT FOUND');
         L_=TPTR->FIRST_LINE;
         IF TPTR=FRST_FUNC THEN FRST_FUNC=TPTR->NXT_FUNC;
         ELSE DO;
              TPTR2=FRST_FUNC;
              DO I=1 TO 300;
              IF TPTR2->NXT_FUNC=TPTR THEN DO; /*PREV FOUND*/
                   TPTR2->NXT_FUNC=TPTR->NXT_FUNC;
                   GOTO DELETE_LINES;
                   END;
              IF ATTN>0 THEN GOTO ATTENTION;
              TPTR2=TPTR2->NXT_FUNC;
              IF TPTR2=NULL THEN SIGNAL ERROR;
              END;
              SIGNAL ERROR;
         DELETE_LINES:
              END;
         FREE TPTR->FUNC IN(AREA); /*FREE HEADER*/
         DO I=1 TO 300; /*DELETE REMAINDER.  SUPPRESS ATTN*/
         IF L_=NULL THEN DO;
              CALL PUTLIST('**ERASED**') ;
              GOTO GET;
              END;
         TPTR=L_->NXT_LINE;
         FREE L_->LDATA IN(AREA);
         L_=TPTR;
         END;

         SIGNAL ERROR;
         END;


    IF SUBSTR(BUF,1,2)='EX' THEN DO;
         IF SUBSTR(BUF,1,7)='EXECUTE' THEN CURSOR=7;
         ELSE IF SUBSTR(BUF,1,4)='EXEC' THEN CURSOR=4;
         ELSE CURSOR=2;
         CALL GETNAME(TNV,TPTR); /*LOOK UP FUNC NAME*/
         IF TPTR=NULL THEN CALL ERROR('38 FUNCTION '
              ||TNV||' NOT FOUND.');
         GET_=GET_+1;  /*PUSH FUNCTION ONTO GET STACK*/
         IF GET_>25 THEN CALL ERROR('39 FUNCTION RECURSION '
              ||'DEPTH EXCEEDED.');
         GF_(GET_)=TPTR;
         GL_(GET_)=TPTR->FIRST_LINE;  EXEC_COUNT(GET_)=0;
          EXEC_LIST(GET_)='0'B;
         DO WHILE(CURSOR<LS&GET_=1 | CURSOR<72&GET_>1);
         /******SCAN OTHER EXEC KEYWORDS******/
         TN=NEXT;
         IF SUBSTR(BUF,CURSOR,4)='LIST' THEN DO;
              EXEC_LIST(GET_)='1'B;  CURSOR=CURSOR+3;
              END;
         ELSE IF TN>='0' THEN DO;
              CALL NUM(I,TEMP,'0'B);
              EXEC_COUNT(GET_)=I-1;
              CURSOR=CURSOR-1;
              END;
         ELSE IF SUBSTR(BUF,CURSOR,5)='TIMES' THEN
              CURSOR=CURSOR+4;
         ELSE IF TN='-' & SUBSTR(BUF,CURSOR+1)=' ' THEN DO;
              CALL TGET('?');
              CURSOR=0;
              END;
         ELSE IF TN=' ' THEN;
         ELSE IF TN='#' THEN DO;
              CALL GET#(TEMP);
              EXEC_COUNT(GET_)=TEMP-1;
              END;
         ELSE CALL ERROR('50 UNKNOWN KEYWORD:  '||
              SUBSTR(BUF,CURSOR,5));
         END;
         GOTO GET;
         END;



 TOPLOOP:
    TN=NEXT;
 SYNLOOP:
    TN=LAST;
    DO WHILE(TN=' ');  TN=NEXT;        /*SKIP BLANKS*/
         IF ATTN>0 THEN GOTO ATTENTION;
         END;
    IF TRACE THEN CALL DUMP;
    IF TN='-' THEN
         IF SUBSTR(BUF,CURSOR+1)=' ' THEN GOTO CONT; /*CONTINUED LINE*/

    /*CHECK FOR DEBUG COMMANDS*/
    IF SUBSTR(BUF,CURSOR,6)='DUMPTR' THEN DO;
         CURSOR=CURSOR+5;
         TRACE='1'B;
         GOTO TOPLOOP;
         END;
    IF SUBSTR(BUF,CURSOR,4)='DUMP' THEN DO;
         CURSOR=CURSOR+3;
         CALL DUMP;
         GOTO TOPLOOP;
         END;
    IF SUBSTR(BUF,CURSOR,4)='UNTR' THEN DO;
         TRACE='0'B;
         CURSOR=CURSOR+3;
         GOTO TOPLOOP;
         END;


    IF PRINT_KEYW THEN DO; /*NOW PROCESSING PRINT COMMAND*/
         IF TN='(' THEN DO;
              IF PRINT_PAREN THEN CALL ERROR('25 DUPLICATE ''('' IN '||
                   'PRINT COMMAND');
              PRINT_PAREN='1'B;  GOTO TOPLOOP;
              END;
         IF PRINT_PAREN THEN
              IF TN=')' THEN DO; /*END OF PRINT COMMAND*/
                   PRINT_KEYW, PRINT_PAREN='0'B; /*RESET*/
                   GOTO TOPLOOP;
                   END;
              ELSE DO;
                   CALL SETFLAG;  /*DECODE THIS PRINT OPTION*/
                   GOTO TOPLOOP; /*FOR NEXT OPTION*/
                   END;
         CALL SETFLAG; /*NO PARENS, ONLY ONE OPTION*/
         PRINT_KEYW='0'B;  GOTO TOPLOOP;  /*END OF PRINT COMMAND*/
         END;
    IF FORM_KEYW THEN DO; /*NOW PROCESSING FORMAT COM*/
         IF TN='(' THEN DO;
              IF FORM_PAREN THEN CALL PUTLIST(
                   'CALC74 DUPLICATE ''('' IGNORED.');
              FORM_PAREN='1'B;
              END;
         ELSE IF TN=',' THEN; /*IGNORE COMMAS*/
         ELSE IF SUBSTR(BUF,CURSOR,2)='FX'
              THEN CALL CHKSET(1,1);
         ELSE IF SUBSTR(BUF,CURSOR,5)='FIXED'
              THEN CALL CHKSET(1,4);
         ELSE IF SUBSTR(BUF,CURSOR,3)='FLT'
              THEN CALL CHKSET(2,2);
         ELSE IF SUBSTR(BUF,CURSOR,5)='FLOAT'
              THEN CALL CHKSET(2,4);
         ELSE IF SUBSTR(BUF,CURSOR,4)='AUTO'
              THEN CALL CHKSET(3,3);
         ELSE IF TN>='0' THEN DO;
              IF FIXED THEN DO;
                   IF FCOUNT>=2 THEN CALL ERROR(
                        '75 TOO MANY ARGS FOR FIXED MODE.');
                   IF FCOUNT=1 THEN CALL NUM(F2,TEMP,'0'B);
                   ELSE CALL NUM(F1,TEMP,'0'B);
                   FCOUNT=FCOUNT+1;
                   END;
              ELSE IF FLOAT THEN DO;
                   IF FCOUNT>=1 THEN CALL ERROR(
                        '76 TOO MANY ARGS FOR FLOAT MODE.');
                   CALL NUM(F1,TEMP,'0'B);
                   FCOUNT=FCOUNT+1;
                   END;
              ELSE IF AUTO THEN CALL ERROR(
                   '77 NO ARGS ALLOWED FOR AUTO MODE.');
              ELSE FLOAT='1'B;  /*DEFAULT TO FLOAT MODE*/
              CURSOR=CURSOR-1;  /*BECAUSE OF CALL TO NUM*/
              END;
         ELSE IF TN=')' THEN DO;
              IF FLOAT THEN
                   IF FCOUNT>0 THEN DO;
                   PREC=F1+6;  FRAC=F1-1;
                   END;
                   ELSE DO;
                   PREC=22;  FRAC=15; /*FLOAT DEFAULTS*/
                   END;
              ELSE IF FIXED THEN
                   IF FCOUNT>=2 THEN DO;
                   PREC=F1+2;  FRAC=F2;
                   END;
                   ELSE IF FCOUNT=1 THEN DO;
                   PREC=F1+1;  FRAC=0;
                   END;
                   ELSE DO;
                   PREC=24;  FRAC=15; /*FIXED DEFAULTS*/
                   END;
              FORM_KEYW, FORM_PAREN='0'B; /*END OF COMMAND*/
              IF PREC<=0 | FRAC<0 | PREC<FRAC THEN DO;
                   PREC=1;  FRAC=1;  FIXED, FLOAT='0'B;
                   CALL ERROR('82 FORMAT OPERANDS ARE INVALID.  '||
                        'AUTO MODE RESUMED.');
                   END;
              END;
         ELSE CALL ERROR('81 SYMBOL '||TN||
              ' IS NOT VALID IN THE FORMAT COMMAND.');
         GOTO TOPLOOP; /*END OF THIS ITEM*/
         END;
    IF TN>='0' | TN='.' THEN DO;  /*NUMBER*/
         CALL NUM(I, TEMP, '1'B);
         CALL PUSHND(TEMP);
         GOTO SYNLOOP;
         END;
    IF TN='E' THEN DO;  /*CONSTANT 2.71828...*/
         IF SUBSTR(BUF,CURSOR,3)='END' THEN DO; /*OR 'END'*/
              PUT EDIT('CONFIRM ''END'':') (A);
              BUF2=BUF;  /*SAVE BUFFER*/
              GET EDIT(BUF) (COL(1), A(LS));
              OVLY1=OVLY1|OVLY2;  /*MAKE UPCASE*/
              IF INDEX(BUF,'END')>0 THEN
                   IF ND_= 1 THEN GOTO FINIS; /*JUST END*/
                   ELSE END_FLAG='1'B; /*END AFTER THIS EXPRESSION*/
              BUF=BUF2;  /*NOT END, RESTORE BUFFER*/
              CURSOR=CURSOR+2;  GOTO TOPLOOP;
              END;
         ELSE IF SUBSTR(BUF,CURSOR,2)='EX' THEN
              CALL ERROR('42 - UNRECOGNIZED KEYWORD ' ||
              '(''EXEC'' MUST BE ENTERED ON A NEW LINE).');
         ELSE IF SUBSTR(BUF,CURSOR,5)='ERASE' THEN
              CALL ERROR('43 - UNRECOGNIZED KEYWORD ' ||
              '(''ERASE'' MUST BE ENTERED ON A NEW LINE).');
         ELSE IF SUBSTR(BUF,CURSOR+1,1)<'A' |
              SUBSTR(BUF,CURSOR+1,1)='S' THEN
              CALL PUSHND(2.71828182845904E0);
         ELSE CALL ERROR('57 UNKNOWN KEYWORD '||
              SUBSTR(BUF,CURSOR,5));
         GOTO TOPLOOP;
         END;
    IF TN='P' THEN /*CONSTANT 3.14159...?*/ DO;
         TN=NEXT;
         IF TN='I' THEN DO;
              CALL PUSHND(3.14159265358979E0);
              GOTO TOPLOOP;
              END;
         ELSE IF TN='R' THEN DO; /*PRINT*/
              IF SUBSTR(BUF,CURSOR,4)='RINT' THEN
                   CURSOR=CURSOR+3; /*ADVANCE PAST PRINT KEYWORD*/
              PRINT_KEYW='1'B; /*FLAG NEED TO DECODE PRINT OPTIONS*/
              GOTO TOPLOOP;
              END;
         ELSE CALL ERROR('01 UNRECOGNIZED KEYWORD ''P'||
              SUBSTR(BUF,CURSOR,4)||'''');
         END;
    IF TN='A' THEN DO;
         IF SUBSTR(BUF,CURSOR,3)='ABS' THEN DO;
              CALL PUSHOR(15);
              CURSOR=CURSOR+2;
              END;
         ELSE IF SUBSTR(BUF,CURSOR,4)='ATAN' THEN DO;
              CALL PUSHOR(16);
              CURSOR=CURSOR+3;
              END;
         ELSE IF SUBSTR(BUF,CURSOR+1,1)<'A' |
              SUBSTR(BUF,CURSOR+1,1)='S' THEN
              CALL PUSHND(AR);  /*ACCUMULATOR*/
         ELSE CALL ERROR('58 UNKNOWN KEYWORD ' ||
              SUBSTR(BUF,CURSOR,5));
         GOTO TOPLOOP;
         END;
    IF TN='S' THEN DO;  /*SIN( OR S FOR STORE*/
         TN=NEXT;
         IF TN>='0' THEN DO;
              CALL NUM(I, TEMP, '0'B); /*GET REG #*/
              IF I>=0 & I<=9 THEN
                   IF ND_>1 THEN
                       REGS(I)=NDSTACK(ND_-1);
                   ELSE REGS(I)=AR;
              ELSE CALL ERROR('07 INVALID REGISTER #'||I);
              GOTO SYNLOOP;
              END;
         IF TN='I' THEN
              IF NEXT='N' THEN DO;
                        CALL PUSHOR(9);  /*SIN*/
                        GOTO TOPLOOP;
                        END;
         IF TN='Q' THEN
              IF SUBSTR(BUF,CURSOR-1,4)='SQRT' THEN DO;
                   CALL PUSHOR(14);
                   CURSOR=CURSOR+2;
                   GOTO TOPLOOP;
                   END;
         CALL ERROR('02 INVALID KEYWORD S' ||
              SUBSTR(BUF,CURSOR,4));
         END;
    IF TN='F' THEN DO;
         IF SUBSTR(BUF,CURSOR,4)='FACT' THEN DO;
              CURSOR=CURSOR+3;
              CALL PUSHOR(18);
              END;
         ELSE DO;
         IF SUBSTR(BUF, CURSOR, 6)='FORMAT' THEN CURSOR=CURSOR+5;
         ELSE IF SUBSTR(BUF, CURSOR,4)='FORM' THEN CURSOR=CURSOR+3;
         ELSE CALL ERROR('80 UNKNOWN KEYWORD '||SUBSTR(BUF,CURSOR,5));
         FORM_KEYW='1'B;  FORM_PAREN='0'B;
         FLOAT, FIXED, AUTO='0'B;
         F1, F2, FCOUNT=0;
         END;
         GOTO TOPLOOP;
         END;
    IF TN='C' THEN /*COS*/
         IF SUBSTR(BUF,CURSOR,3)='COS' THEN DO;
              CALL PUSHOR(10);  /*COS*/
              CURSOR=CURSOR+2;  GOTO TOPLOOP;
              END;
         ELSE CALL ERROR('03 UNRECOGNIZED KEYWORD ' ||
              SUBSTR(BUF,CURSOR,5));
    IF TN='R' THEN DO;  /*RECALL A REG*/
         IF SUBSTR(BUF,CURSOR,6)='REPEAT' THEN
              CALL ERROR('30 - UNRECOGNIZED KEYWORD ' ||
              '(''REPEAT'' IS NOT YET IMPLEMENTED.');
         TN=NEXT;
         IF TN<'0' THEN CALL ERROR('71 UNKNOWN KEYWORD, R'||
              SUBSTR(BUF,CURSOR,4));
         CALL NUM(I, TEMP, '0'B); /*GET REG #*/
         IF I>=0&I<=9 THEN CALL PUSHND(REGS(I));
         ELSE CALL ERROR('06 INVALID REGISTER #'||I);
         GOTO SYNLOOP;
         END;
    IF TN='L' THEN DO;  /*LOG OR LN*/
         IF SUBSTR(BUF,CURSOR,4)='LOG2' THEN DO;
              CALL PUSHOR(13);
              CURSOR=CURSOR+3;
              END;
         ELSE IF SUBSTR(BUF,CURSOR,2)='LN' THEN DO;
              CALL PUSHOR(12);
              CURSOR=CURSOR+1;
              END;
         ELSE IF SUBSTR(BUF,CURSOR,3)='LOG' THEN DO;
              CALL PUSHOR(11);
              CURSOR=CURSOR+2;
              END;
         ELSE IF SUBSTR(BUF,CURSOR,5)='LEARN' THEN
              CALL ERROR('41 - UNRECOGNIZED KEYWORD ' ||
              '(''LEARN'' MUST BE ENTERED ON A NEW LINE).');
         ELSE CALL ERROR('04 UNRECOGNIZED KEYWORD ' ||
              SUBSTR(BUF,CURSOR,5));
         GOTO TOPLOOP;
         END;
    IF TN='T' THEN   /*TAN*/
         IF SUBSTR(BUF,CURSOR,3)='TAN' THEN DO;
              CALL PUSHOR(17);
              CURSOR=CURSOR+2;
              GOTO TOPLOOP;
              END;
         ELSE CALL ERROR('21 UNRECOGNIZED KEYWORD:  ' ||
              SUBSTR(BUF,CURSOR,5));
    IF TN='H' THEN CALL ERROR('22 UNRECOGNIZED KEYWORD (' ||
         '''HELP'' MUST BE ENTERED ON A NEW LINE)');
    IF TN=')' THEN OP_TYPE=1;
    ELSE IF TN='(' THEN OP_TYPE=8;
    ELSE IF TN='/' THEN OP_TYPE=4;
    ELSE IF TN='*' THEN
         IF SUBSTR(BUF,CURSOR+1,1)='*' THEN DO;
              OP_TYPE=6;  CURSOR=CURSOR+1;
              END;
         ELSE OP_TYPE=5;
    ELSE IF TN='+' THEN
         IF PREV_OR | ND_=1 THEN GOTO TOPLOOP; /*IGNORE UNARY +*/
         ELSE OP_TYPE=2;
    ELSE IF TN='-' THEN
         IF PREV_OR | ND_=1 THEN OP_TYPE=7;  /*UNARY -*/
         ELSE OP_TYPE=3;
    ELSE IF TN='#' THEN DO;
         CALL GET#(TEMP);
         CALL PUSHND(TEMP);
         GOTO TOPLOOP;
         END;

    ELSE CALL ERROR('05 UNRECOGNIZED SYMBOL:  '||TN);
    OP_PRTY=PRTY(OP_TYPE);
    PREV_OR='1'B;
    GOTO PARSE;


 ALLPOP:  /*AT EOF*/
    OP_TYPE=0;
    IF PRINT_KEYW THEN PRINTFLAGS(10)='1'B;
    PRINT_KEYW, PRINT_PAREN='0'B;
    IF FORM_KEYW THEN CALL PUTLIST(
         'CALC79 INCOMPLETE FORMAT STATEMENT MAY CAUSE UNPREDICTABLE '||
         'RESULTS.');
    FORM_KEYW, FORM_PAREN='0'B;


 PARSE:
    IF OP_TYPE=0 THEN DO;  /*EOF*/
         DO WHILE(OR_>1);  /*POP ENTIRE STACK*/
         CALL POPOR(I);
         IF I>=8 THEN CALL PUTLIST(
              'CALC44 - MISSING '')'' INSERTED AT END OF LINE.') ;
         IF I=8 THEN;  ELSE CALL EXEC(I);
         IF ATTN>0 THEN GOTO ATTENTION;
         END;
         GOTO PRINT;  /*ALL DONE*/
         END;
    IF OR_=1 THEN DO;  /*STACK IS EMPTY*/
         IF OP_TYPE=1 /*')'*/ THEN CALL PUTLIST(
              'CALC85 UNBALANCED '')'' IGNORED.');
         ELSE CALL PUSHOR(OP_TYPE);
         GOTO TOPLOOP;
         END;
    IF OP_TYPE>=8 THEN DO; /*( OR FUNCTION(*/
         CALL PUSHOR(OP_TYPE);
         GOTO TOPLOOP;
         END;
    IF OP_TYPE=1 THEN DO; /*), REDUCE STACK*/
         CALL POPOR(I);
         DO WHILE(I<8&OR_>1); /*POP UNTIL NEXT ( OR EQUIV*/
         CALL EXEC(I);
         CALL POPOR(I);
         END;
         IF I>8 THEN CALL EXEC(I); /*FUNCTION*/
         ELSE IF I=8 THEN;
         ELSE IF OR_<=1 THEN DO; CALL PUTLIST(
           'CALC73 ONE OR MORE ''('' INSERTED AT BEGINNING OF LINE.');
           CALL EXEC(I);
           END;
         GOTO TOPLOOP;
         END;

    /*NOT A SPECIAL OPERATOR, DO NORMAL SHIFT OR
         REDUCE DEPENDING UPON OP PRTY*/

    DO WHILE(OR_>1 & PRTY(ORSTACK(OR_-1))>=OP_PRTY);
    CALL POPOR(I);  /*OP AT TOP OF STACK*/
    CALL EXEC(I);  /*REDUCE*/
    IF ATTN>0 THEN GOTO ATTENTION;
    END;
    CALL PUSHOR(OP_TYPE);  /*SHIFT*/
    GOTO TOPLOOP;


 PRINT:
    IF ND_ > 2 THEN CALL ERROR('15 INVALID EXPRESSION'||
         ', TOO MANY OPERANDS');
         /*OPERANDS LEFT ON STACK*/
    AR=NDSTACK(1);
    PRINTFLAGS(10)=PRINTFLAGS(10)|PRINT_ON;
    IF PRINTFLAGS(10) THEN CALL FORMAT('A', AR);
    DO I=0 TO 9;
    IF PRINTFLAGS(I) THEN
         CALL FORMAT('REG'||SUBSTR(CHAR(I),7), REGS(I));
    IF ATTN>0 THEN GOTO ATTENTION;
    END;
    PRINTFLAGS='0'B;
    IF END_FLAG THEN;  ELSE GOTO GET;
 FINIS:
    PUT LIST('* * * CALCULATOR END * * *');
 HELP:  PROC;
    DCL SW BIT(1) INIT('1'B);
    DCL I BIN FIXED, HTEXT (50) CHAR(68) VAR BASED(H_);
    I=VERIFY(BUF,' ');
    IF I=0 THEN GOTO GENERAL;
    BUF=SUBSTR(BUF,I);
    IF SUBSTR(BUF,1,3)='ALL' THEN DO;
         SW='0'B;
         GOTO GENERAL;
         END;
    IF SUBSTR(BUF,1,4)='SYN ' |
         SUBSTR(BUF,1,7)='SYNTAX ' THEN GOTO SYNTAX;
    IF SUBSTR(BUF,1,4)='COM ' |
         SUBSTR(BUF,1,9)='COMMANDS ' THEN GOTO COMMANDS;
    IF SUBSTR(BUF,1,5)='FUNC ' |
         SUBSTR(BUF,1,10)='FUNCTIONS ' THEN GOTO FUNCTIONS;
    IF SUBSTR(BUF,1,4)='END ' THEN DO;
         H_=ADDR(COMMANDSC(1));
         CALL PRINTHELP(HTEXT,3);
         END;
    ELSE IF SUBSTR(BUF,1,3)='PR '  |
         SUBSTR(BUF,1,6)='PRINT ' THEN DO;
         H_=ADDR(COMMANDSC(4));
         CALL PRINTHELP(HTEXT,13);
         END;
    ELSE IF SUBSTR(BUF,1,6)='LEARN ' THEN DO;
         H_=ADDR(COMMANDSC(28));
         CALL PRINTHELP(HTEXT,6);
         END;
    ELSE IF SUBSTR(BUF,1,5)='HELP ' | SUBSTR(BUF,1,2)='H ' THEN DO;
         H_=ADDR(COMMANDSC(17));
         CALL PRINTHELP(HTEXT,11);
         END;
    ELSE IF SUBSTR(BUF,1,6)='ERASE ' THEN DO;
         H_=ADDR(COMMANDSC(34));
         CALL PRINTHELP(HTEXT,2);
         END;
    ELSE IF SUBSTR(BUF,1,3)='EX '  |
         SUBSTR(BUF,1,5)='EXEC ' |
         SUBSTR(BUF,1,8)='EXECUTE ' THEN DO;
         H_=ADDR(COMMANDSC(36));
         CALL PRINTHELP(HTEXT,9);
         END;
    ELSE IF SUBSTR(BUF,1,2)='R ' THEN DO;
         H_=ADDR(COMMANDSC(45));
         CALL PRINTHELP(HTEXT,3);
         END;
    ELSE IF SUBSTR(BUF,1,2)='S ' THEN DO;
         H_=ADDR(COMMANDSC(48));
         CALL PRINTHELP(HTEXT,2);
         END;
    ELSE IF SUBSTR(BUF,1,2)='# ' THEN DO;
         H_=ADDR(COMMANDSC(50));
         CALL PRINTHELP(HTEXT,9);
         END;
    ELSE IF SUBSTR(BUF,1,2)='A ' THEN DO;
         H_=ADDR(COMMANDSC(59));
         CALL PRINTHELP(HTEXT,1);
         END;
    ELSE IF SUBSTR(BUF,1,2)='E ' THEN DO;
         H_=ADDR(COMMANDSC(60));
         CALL PRINTHELP(HTEXT,1);
         END;
    ELSE IF SUBSTR(BUF,1,3)='PI ' THEN DO;
         H_=ADDR(COMMANDSC(61));
         CALL PRINTHELP(HTEXT,1);
         END;
    ELSE IF SUBSTR(BUF,1,5)='FORM '  |
         SUBSTR(BUF,1,7)='FORMAT ' THEN DO;
         H_=ADDR(COMMANDSC(62));
         CALL PRINTHELP(HTEXT,9);
         END;
    ELSE
    CALL PUTLIST('CALC60 NO HELP AVAILABLE.  FOR MORE HELP '||
         'TYPE ''HELP''');
    RETURN;
 GENERAL:
    DCL GENERALC (8) CHAR(68) VAR STATIC INIT(
    'TSO CALCULATOR PROGRAM',
    'THE PROGRAM EVALUATES ARITHMETIC EXPRESSIONS USING THE',
    'OPERATORS +,-,* (MULTIPLY),/ (DIVIDE), AND ** (EXPONENTIATE)',
    'AND A NUMBER OF BUILTIN FUNCTIONS.  ALL ANSWERS ARE PLACED',
    'IN AN ACCUMULATOR CALLED ''A''.  THE CALCULATOR ALSO MAINTAINS',
    'TEN SCRATCH-PAD REGISTERS WHICH ARE ACCESSIBLE TO THE USER.',
    'FOR MORE INFORMATION TYPE ''HELP SYNTAX'', ''HELP COMMANDS'', ',
    '''HELP FUNCTIONS'', ''HELP SUBCOMMANDNAME'', OR ''HELP ALL''.') ;
    CALL PRINTHELP(GENERALC,8);
    IF SW THEN RETURN;
 SYNTAX:
    DCL SYNTAXC(14) CHAR(68) VAR STATIC INIT(
    'ENTER EXPRESSIONS IN THE USUAL MATHEMATICAL INFIX NOTATION',
    'WITH OR WITHOUT BLANKS SEPARATING THE OPERATORS AND OPERANDS',
    'WITH THE FOLLOWING EXCEPTIONS:',
    '  1.  DO NOT LEAVE BLANKS BETWEEN THE ''R'' AND ''S'' REGISTER',
    '      COMMANDS AND THEIR ASSOCIATED REGISTER NUMBERS.',
    '  2.  TO CONTINUE A LINE, END IT WITH A DASH (''-'') AND',
    '      CONTINUE ON THE NEXT LINE.  THE DASH WILL NOT BE',
    '      INTERPRETED AS A MINUS.',
    '      A LINE MAY BE BROKEN FOR CONTINUATION ANYWHERE THAT',
    '      A BLANK WOULD BE LEGAL.',
    '  3.  COMMANDS ''LEARN'', ''EXECUTE'', ''ERASE'', ',
    '      ''HELP'' AND ''END'' SHOULD BE TYPED ALONE ON NEW LINES',
    'FOR EXAMPLE, IF YOU TYPE ''2+3*4'', THE CALCULATOR WILL',
    'RESPOND ''A=14.00000000000''.');
    CALL PRINTHELP(SYNTAXC,14);
    IF SW THEN RETURN;
 COMMANDS:
    DCL COMMANDSC(70) CHAR(68) VAR STATIC INIT(
    'END -  END THE CALCULATOR SESSION.  NOTE:  THE PROGRAM WILL',
    '       REQUEST CONFIRMATION OF YOUR END COMMAND.',
    '       END IS ALSO USED TO TERMINATE A LEARN FUNCTION.',
    'PRINT - DETERMINES PRINTING OPTIONS.  ABBREVIATION:  ''PR''.',
    '        SYNTAX IS:  PRINT OPTION, OR,',
    '        PRINT (OPTION LIST)',
    '        WHERE THE OPTIONS ARE:',
    '        A -- PRINT THE A REGISTER',
    '        NUMBER BETWEEN 0 AND 9 -- PRINT THAT REGISTER',
    '        REGS -- PRINT ALL REGISTERS, 0-9',
    '        ON -- PRINT A AFTER EACH SUCCEEDING CALCULATION',
    '        OFF -- SUPPRESS PRINTING OF A AFTER CALCULATIONS',
    '        F -- PRINT CURRENT LIST OF LEARNED FUNCTIONS',
    '        ''FUNCTION-NAME'' -- PRINT THAT LEARNED FUNCTION.',
    '        DEFAULT IS PRINT ON.  ''OPTION LIST'' IS ONE OR MORE',
    '        OPTIONS SEPARATED BY BLANKS OR COMMAS',
    'HELP -  REQUEST INSTRUCTIONS ON CALCULATOR OPERATION.',
    '        ABBREVIATION:  ''H''.',
    '        HELP MAY BE ENTERED WITH NO OPERANDS FOR GENERAL',
    '        INFORMATION, OR WITH ONE OF THE FOLLOWING OPERANDS:',
    '        SYNTAX -- REQUESTS SYNTAX INFORMATION (ABBRV:  SYN)',
    '        COMMANDS -- REQUESTS DESCRIPTIONS OF ALL AVAILABLE',
    '        COMMANDS (ABBRV:  COM)',
    '        FUNCTIONS -- REQUESTS DESCRIPTIONS OF ALL BUILT-IN',
    '        FUNCTIONS (ABBRV:  FUNC)',
    '        SUBCOMMAND-NAME -- REQUESTS INFO. ON THAT COMMAND',
    '        ALL -- REQUESTS ALL AVAILABLE INFORMATION.',
    'LEARN - ACCEPT AND STORE A SERIES OF COMMANDS FOR',
    '        LATER EXECUTION.  SYNTAX IS:',
    '        LEARN FUNCTION-NAME',
    '        WHERE FUNCTION-NAME IS A 1 TO 8 CHARACTER NAME',
    '        BY WHICH YOU WILL IDENTIFY THE LEARNED FUNCTION.',
    '        TO TERMINATE LEARN MODE, TYPE ''END''.',
    'ERASE - ERASE A PREVIOUSLY LEARNED FUNCTION.  SYNTAX IS:',
    '        ERASE FUNCTION-NAME',
    'EXECUTE - EXECUTE A LEARNED FUNCTION.  SYNTAX IS:',
    '        EXECUTE FUNCTION-NAME OPTIONS',
    '        WHERE FUNCTION-NAME IS AS ABOVE AND AVAILABLE',
    '        OPTIONS ARE ''LIST'' WHICH PRINTS EACH LINE',
    '        OF THE FUNCTION AS IT IS EXECUTED, AND ''N TIMES''',
    '        WHICH CAUSES THE FUNCTION TO BE EXECUTED THAT',
    '        MANY TIMES (N IS ANY POSITIVE INTEGER).',
    '        DEFAULTS ARE 1 TIMES AND NO LISTING.',
    '        EXECUTE MAY BE ABBREVIATED AS ''EXEC'' OR ''EX''',
    'R - RECALL A REGISTER.  SYNTAX IS R FOLLOWED BY THE REG. #',
    '    NOTE:  R CAN BE USED AS AN OPERAND IN AN EXPRESSION, E.G.',
    '    ''2+R3''.',
    'S - STORE THE LATEST OPERAND (USUALLY ''A'') IN A REGISTER.',
    '    SYNTAX IS S FOLLOWED BY A REG. #',
    '# - REQUEST TERMINAL INPUT.  THIS SYMBOL MAY BE USED ',
    '    IN PLACE OF ANY ARITHMETIC OPERAND IN A LEARNED',
    '    FUNCTION.  IT SIGNIFIES THAT THE OPERAND WILL BE',
    '    ENTERED FROM THE TERMINAL DURING EXECUTION (THE',
    '    CALCULATOR WILL PROMPT YOU FOR THE OPERAND).',
    '    IN RESPONSE TO THE PROMPT YOU MAY ENTER A NUMBER OR',
    '    ANY OF THE SYMBOLS ''A'', ''E'', OR ''PI''.',
    '    NOTE THAT ''#'' IS VALID ONLY IN LEARNED FUNCTIONS',
    '    AND IS NOT ACCEPTED AS NORMAL TERMINAL INPUT.',
    'A - USE THE CURRENT ACCUMULATOR VALUE, E.G. 17*A',
    'E - THE BASE OF NATURAL LOGARITHMS, 2.71828182845904',
    'PI - TRIGONOMETRIC CONSTANT, 3.14159265358979',
    'FORMAT - FORCE PRINTING OF NUMBERS IN A SPECIFIED FORMAT.',
    '         ABBREVIATION:  FORM.',
    '         SYNTAX:  FORMAT(FIXED,N1,N2) TO SPECIFY FIXED POINT',
    '         REPRESENTATION WITH N1 DIGITS OF WHICH N2 ARE FRACTIONAL',
    '                  FORMAT(FLOAT,N1) TO SPECIFY FLOATING POINT',
    '         REPRESENTATION WITH N1 DIGITS',
    '                  FORMAT(AUTO) TO SPECIFY AUTOMATIC FORMATTING.',
    '        THE DEFAULT IS FORMAT(AUTO).  FIXED MAY BE TYPED AS ',
    '         ''FX'', FLOAT AS ''FLT''');
    DCL ALLCMDS (8) CHAR(68) VAR STATIC INIT(
    'AVAILABLE COMMANDS ARE - END, PRINT, HELP, LEARN, ERASE, ',
     'EXECUTE, FORMAT, R, AND S.  OTHER SYMBOLS WHICH MAY BE USED IN',
    'CALCULATIONS ARE ''A'', ''E'', ''PI'', AND ''#''.',
    'ALSO, ANY ARITHMETIC EXPRESSION USING NUMBERS, ',
    'PARENTHESES, +, -, *, /, **, OR THE BUILTIN FUNCTIONS',
    'IS VALID CALCULATOR INPUT.',
    'FOR MORE INFORMATION ON ANY OF THESE COMMANDS OR SYMBOLS,',
    'TYPE ''HELP'' WITH THE COMMAND/SYMBOL AS OPERAND.');
    CALL PRINTHELP(ALLCMDS,8);
    IF SW THEN RETURN;
    CALL PRINTHELP(COMMANDSC,70);
 FUNCTIONS:
    DCL FUNCTIONSC(11) CHAR(68) VAR STATIC INIT(
    'BUILT-IN FUNCTIONS -',
    'SIN(EXPRESSION) - TRIGONOMETRIC SINE.',
    'COS(EXPRESSION) - TRIGONOMETRIC COSINE.',
    'TAN(EXPRESSION) - TRIGONOMETRIC TANGENT=SIN/COS.',
    'ATAN(EXPRESSION) - ARCTANGENT.',
    'LOG(EXPRESSION) - COMMON LOGARITHM.',
    'LN(EXPRESSION) - NATURAL LOGARITHM.',
    'LOG2(EXPRESSION) - BASE 2 LOGARITHM.',
    'SQRT(EXPRESSION) - SQUARE ROOT.',
    'FACT(INTEGER EXPRESSION) - FACTORIAL.',
    'ABS(EXPRESSION) - ABSOLUTE VALUE')  ;
    CALL PRINTHELP(FUNCTIONSC,11);
    END HELP;

 PRINTHELP:  PROC(STRS, CNT);
    DCL (I, CNT) BIN FIXED, STRS(*) CHAR(68) VAR;
    DO I=1 TO CNT;
    IF ATTN>0 THEN GOTO ATTENTION;
     CALL PUTLIST(STRS(I));
    END;
    END PRINTHELP;




 FORMAT:  PROC(CH, X);
    DCL (I, J) BIN FIXED, CH CHAR(*), COPY_ZEROS BIT(1),
         NBUF CHAR(30) INIT((30)' '),
         VBUF CHAR(30) VAR INIT(''),
         X FLOAT(53) BIN, TN CHAR(1);
    IF FLOAT THEN PUT STRING(NBUF) EDIT(X) (E(PREC,FRAC));
    ELSE IF FIXED THEN PUT STRING(NBUF) EDIT(X) (F(PREC,FRAC));
    IF FLOAT|FIXED THEN DO; /*USER CONTROLLED FORMATTING*/
         I=VERIFY(NBUF,' ');  J=INDEX(SUBSTR(NBUF,I), ' ');
         CALL PUTLIST(CH||' = '||SUBSTR(NBUF, I, J-1));
         RETURN;
         END;
    IF ABS(X)<1E6 & ABS(X)>1E-3 THEN
         PUT STRING(NBUF) EDIT(X) (F(24,15));
    ELSE PUT STRING(NBUF) EDIT(X) (E(22,15));
    I=INDEX(NBUF, 'E');
    IF I>0 THEN DO;
         J=INDEX(SUBSTR(NBUF,I), ' ');
         VBUF=SUBSTR(NBUF,I,J-1);
         SUBSTR(NBUF, I)=' ';
         END;
    ELSE I=25;
    COPY_ZEROS='0'B;
    DO J=I TO 1 BY -1;
    TN=SUBSTR(NBUF, J, 1);
    IF TN=' ' THEN;
    ELSE IF TN='.' THEN DO;
         IF COPY_ZEROS THEN VBUF=TN||VBUF;
         COPY_ZEROS='1'B;
         END;
    ELSE IF TN='0' THEN
         IF COPY_ZEROS THEN VBUF=TN||VBUF;
         ELSE;
    ELSE DO;
         COPY_ZEROS='1'B;
         VBUF=TN||VBUF;
         END;
    END;

    CALL PUTLIST(CH||' = '||VBUF);
    END FORMAT;

 SETFLAG:  PROC;  /*DECODE & IMPLEMENT PRINT COMMAND OPTIONS*/
    IF TN=',' THEN DO;
         IF PRINT_PAREN THEN;
         ELSE CALL ERROR('27 INVALID CHAR, '','', IN PRINT COMMAND');
         END;
    ELSE IF SUBSTR(BUF,CURSOR,2)='ON' THEN DO;
         PRINT_ON='1'B;  CURSOR=CURSOR+1;
         END;
    ELSE IF SUBSTR(BUF,CURSOR,3)='OFF' THEN DO;
         PRINT_ON='0'B;  CURSOR=CURSOR+2;
         END;
    ELSE IF SUBSTR(BUF,CURSOR,4)='REGS' THEN DO;
         DO I=0 TO 9;  CALL FORMAT('REG'||SUBSTR(CHAR(I),7),REGS(I));
         IF ATTN>0 THEN GOTO ATTENTION;
              END;
         CURSOR=CURSOR+3;
         END;
    ELSE IF TN>='0' THEN DO;
         CALL NUM(I,TEMP,'0'B);  CURSOR=CURSOR-1;
         IF I>=0 & I<=9 THEN CALL FORMAT('REG'||SUBSTR(CHAR(I),7),
              REGS(I));
         ELSE CALL ERROR('28 INVALID REGISTER NUMBER,'||I);
         END;
    ELSE IF TN='A' THEN CALL FORMAT('A',AR);
    ELSE IF TN='F' THEN DO;  /*PRINT FUNC LIST*/
         TPTR=FRST_FUNC;
         IF TPTR=NULL THEN CALL PUTLIST('NO FUNCTIONS DEFINED.') ;
         ELSE CALL PUTLIST('**KNOWN FUNCTIONS**') ;
         DO I=1 TO 300;
         IF ATTN>0 THEN GOTO ATTENTION;
         IF TPTR=NULL THEN RETURN;
         CALL PUTLIST(TPTR->FNAME) ;  TPTR=TPTR->NXT_FUNC;
         END;
         END;
    ELSE IF TN='''' THEN DO;
         CALL GETNAME(TNV,TPTR);
         IF TPTR=NULL THEN CALL ERROR(
              '80 FUNCTION '||TNV||' IS NOT DEFINED.');
         CALL PUTLIST(TNV);
         TPTR=TPTR->FIRST_LINE;
         DO I=1 BY 1;
         IF ATTN>0 THEN GOTO ATTENTION;
         IF TPTR=NULL THEN DO;
              IF I=1 THEN CALL PUTLIST('FUNCTION IS NULL.');
              ELSE CALL PUTLIST('END OF FUNCTION.');
              RETURN;
              END;
         DO J=72 TO 2 BY -1 WHILE(SUBSTR(TPTR->LINE,J,1)=' ');
         END;
         PUT EDIT(I, '.  ',SUBSTR(TPTR->LINE,1,J)) (F(3),2 A);
         PUT SKIP;
         TPTR=TPTR->NXT_LINE;
         END;
         END;
    ELSE DO;
         PRINT_KEYW='0'B;
         IF PRINT_PAREN THEN DO;
         PRINT_PAREN='0'B;
         CALL ERROR('26 INVALID PRINT OPTION '||SUBSTR(BUF,CURSOR,4));
         END;
         PRINTFLAGS(10)='1'B;  /*AR IF NO OPTION SPECIFIED*/
         CURSOR=CURSOR-1;  /*BACKUP TO REREAD THIS CHAR*/
         END;
    END SETFLAG;

    /*GET AN IMMEDIATE OPERAND FOR A '#' IN AN EXEC FUNCTION*/

 GET#:  PROC(FLOATVAR);
    DCL FLOATVAR FLOAT(53) BIN, I BIN FIXED;
         IF GET_>1 THEN DO;
              BUF2=BUF;  /*SAVE BUFFER*/
              CALL GETINPUT(BUF);
              OVLY1=OVLY1|OVLY2;
              I=VERIFY(BUF,' ');
              IF I=0 THEN FLOATVAR=#(GET_);
              ELSE DO;
                   IF SUBSTR(BUF,I,1)='A' THEN
                        FLOATVAR=AR;
                   ELSE IF SUBSTR(BUF,I,1)='E' THEN
                        FLOATVAR=2.71828182845904E0;
                   ELSE IF SUBSTR(BUF,I,2)='PI' THEN
                        FLOATVAR=3.14159265358979E0;
                   ELSE IF SUBSTR(BUF,I,1)>='0' |
                        SUBSTR(BUF,I,1)='.' |
                        SUBSTR(BUF,I,1)='-' |
                        SUBSTR(BUF,I,1)='+' THEN DO;
                        TNV=SUBSTR(BUF,I,15); /*FOR CONV ON-UNIT*/
                        GET STRING(BUF) LIST(FLOATVAR);
                        END;
                   ELSE CALL ERROR('55 INVALID OPERAND '||
                        'ENTERED.');
                   #(GET_)=FLOATVAR;
                   END;
              END;
         ELSE CALL ERROR('51 SYMBOL ''#'' IS VALID ONLY ' ||
              'IN ''EXEC'' FUNCTIONS');
    BUF=BUF2;  /*RESTORE BUFFER*/
    END GET#;

  GETINPUT:  PROC(STR);
    DCL STR CHAR(120), (I, J) BIN FIXED;
    I=VERIFY(#BUF, ', ');  /*ANY INPUT LEFT?*/
    IF I=0 THEN DO;  /*NO*/
         PUT EDIT('ENTER ''#'':') (A);
         GET EDIT(#BUF) (COL(1), A(80));
         I=VERIFY(#BUF, ', ');  /*STILL EMPTY?*/
         IF I=0 THEN DO;  /*USE LAST ENTRY*/
              STR=#BUF;
              RETURN;
              END;
         END;
    #BUF=SUBSTR(#BUF,I);
    I=INDEX(#BUF, ' ');  J=INDEX(#BUF, ',');
    IF I=0 THEN I=J;
    IF J>0 THEN I=MIN(I,J);
    IF I=0 THEN DO;
         STR=#BUF;  #BUF=' ';
         END;
    ELSE DO;
         STR=SUBSTR(#BUF,1,I-1);  #BUF=SUBSTR(#BUF,I);
         END;
    END GETINPUT;


  CHKSET:  PROC(TYPE, LENGTH);  /*FOR DECIPHERING FORMAT KEYWORDS*/
    DCL (TYPE, LENGTH) BIN FIXED;
    IF FIXED|FLOAT|AUTO /*MODE ALREADY SPECIFIED*/
        THEN CALL PUTLIST('CALC78 REDUNDANT MODE DESIGNATOR IGNORED.');
    ELSE IF TYPE=1 THEN FIXED='1'B;
    ELSE IF TYPE=2 THEN FLOAT='1'B;
    ELSE IF TYPE=3 THEN AUTO='1'B;
    CURSOR=CURSOR+LENGTH;
    END CHKSET;



 DUMP:  PROC;  /*A DEBUGGING FEATURE*/
    /*IF USER ENTERS DUMP, THIS ROUTINE IS INVOKED.
    IF HE ENTERS DUMPTR, IT IS INVOKED AT EACH PASS
    THRU THE MAIN LOOP.
    IF HE ENTERS UNTR, THE TRACE IS TURNED OFF.
    NOTE THAT THESE COMMANDS ARE UNDOCUMENTED.*/
    PUT SKIP EDIT('DEBUG DUMP',
    'STATUS:', PRINT_KEYW, PRINT_PAREN,
    FORM_KEYW, FORM_PAREN,
    FLOAT, FIXED, AUTO,
    TRACE,
    LS, ASTATUS, ATTN,
    'PARSE:  ', PREV_OR, OR_, ORSTACK(OR_-1), ND_, NDSTACK(ND_-1),
    'FORMAT:  ', PREC, FRAC, FCOUNT, F1, F2,
    'INPUT:', GET_, CURSOR, TN, SUBSTR(BUF,1,LS-1))
    (A, SKIP, A, 4 B, X(1), 3 B, X(1),
    B, X(1), 3 F(3),
    SKIP, A, B, 3 F(3), E(22,15),
    SKIP, A, 5 F(4),
    SKIP, A, 2 F(3), X(2), A, SKIP, A);
    PUT SKIP;
    END DUMP;


 FACT:  PROC(X) RETURNS(BIN FLOAT(53));
    DCL (X, Y, Z INIT(1E0)) FLOAT(53) BIN;
    IF X<0E0 THEN CALL ERROR('86 ATTEMPT TO TAKE NEG FACTORIAL.');
    DO Y=2E0 TO FLOOR(X);
    Z=Z*Y;
    END;
    RETURN(Z);
    END FACT;


    /**********
    PRINTING PROTOCOL IS THAT THE CARRIAGE IS ALWAYS TO BE
    LEFT AT THE BEGINNING OF THE NEXT LINE TO AVOID SPURIOUS
    BLANK LINES INSERTED BY 'PUT SKIP EDIT' ETC.  THEREFORE,
    ALL PRINTING IS OF THE FORM 'PUT...;  PUT SKIP;'
    SUBROUTINE PUTLIST PROVIDES THIS SERVICE FOR ROUTINES
    WISHING TO PRINT MESSAGES CONSISTING OF A SINGLE
    CHARACTER STRING.
    **********/
 PUTLIST:  PROC(STR);
    DCL STR CHAR(*) VAR;
    PUT LIST(STR);  PUT SKIP;
    END PUTLIST;


    END CALC;
