LISTVTOC TITLE '** TSO LIST VTOC COMMAND ** '
***********************************************************************
*                                                                     *
*    NAME - LISTVTOC                                                  *
*                                                                     *
*    AUTHOR - TED BESTANI                                             *
*                                                                     *
*    PURPOSE - THIS IS A FULL-SCREEN COMMAND PROCESSOR THAT IS ONLY   *
*              INTENDED TO BE USED BY SYSTEMS PROGRAMMERS.  IT CHECKS *
*              FOR OPERATOR AUTHORITY.  IT DISPLAYS ALL DATASETS THAT *
*              ARE LISTED IN A PARTICULAR VTOC.                       *
*                                                                     *
*    ATTRIBUTES - NON-REUSABLE                                        *
*                                                                     *
*    REQUIREMENTS - LISTVTOC REQUIRES A 3270 DISPLAY STATION WITH AT  *
*                   LEAST 24 LINES.  IT WILL WORK ON LARGER TUBES,    *
*                   BUT DOES NOT REQUIRE THEM.                        *
*                                                                     *
*    MACROS USED - TGET, TPUT                                         *
*                                                                     *
***********************************************************************
         EJECT
         PRINT ON,NOGEN,NODATA
LISTVTOC CSECT
         STM   R14,R12,12(R13)         SAVE CALLERS REGISTERS
         BALR  R9,0                    WHERE ARE WE?
         USING *,R9                    TEMPORARY BASE REGISTER
         ST    R13,SAVEAREA+4          SAVE BACKWARD SA PTR
         LA    R8,SAVEAREA             GET SA ADDR
         ST    R8,8(R13)               SAVE FORWARD SA PTR
         LR    R13,R8                  COPY SA ADDR
         LA    R12,4095(R13)           BASE2 = BASE1 + 4095 +
         LA    R12,1(R12)                                     1
         LA    R11,4095(R12)           BASE3 = BASE2 + 4095 +
         LA    R11,1(R11)                                     1
         LA    R10,4095(R11)           BASE4 = BASE3 + 4095 +
         LA    R10,1(R10)                                     1
         USING SAVEAREA,R13,R12,R11,R10    PERMANENT BASE REGISTERS
         USING EXTRAREA,R4             ESTABLISH ADDRESSABILITY
         USING SCRNLINE,R7             ESTABLISH ADDRESSABILITY
         DROP  R9                      DROP TEMPORARY BASE REGISTER
         MVC   SAVECPPL(16),0(R1)      SAVE CP PARM LIST
         SPACE 1
         BAL   R9,DRIVER               INVOKE MAIN ROUTINE
         SPACE 1
         L     R13,SAVEAREA+4          GET ADDR OF CALLER'S SA
         LM    R14,R12,12(R13)         RESTORE REGISTERS
         LA    R15,0                   SET RC=0
         BR    R14                     GO HOME....
         SPACE 1
SAVEAREA DS    18F    PROGRAM MAIN SAVE AREA
SAVECPPL DS    0F     ** TSO COMMAND PROCESSOR PARAMETER LIST **
CPPLCBUF DS    A      ADDRESS OF COMMAND INPUT BUFFER
CPPLUPT  DS    A                 USER PROFILE TABLE
CPPLPSCB DS    A                 PROTECTED STEP CONTROL BLOCK
CPPLECT  DS    A                 ENVIRONMENT CONTROL TABLE
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         EJECT
***********************************************************************
*     THIS IS THE HIGHEST LEVEL WORK ROUTINE IN THE PROGRAM.  IT      *
*   DIRECTS THE FLOW OF CONTROL TO THE WORK ROUTINES.                 *
*     THE PROGRAM IS WRITTEN USING BASIC STRUCTURED PROGRAMMING. FLOW *
*   BETWEEN ROUTINES IS ACCOMPLISHED VIA REGISTER 9, WHICH IS ALWAYS  *
*   SAVED UPON ENTRY AND RESTORED BEFORE EXIT.                        *
***********************************************************************
         SPACE 2
DRIVER   DS    0H
         ST    R9,SAVE10
         B     BSAVE10
SAVE10   DC    F'-1'
         DC    CL8'DRIVER  '
BSAVE10  EQU   *
         SPACE 1
         L     R1,CPPLPSCB             ADDR OF THE PSCB
         TM    16(R1),X'80'            DOES USER HAVE OPERATOR AUTH?
         BO    GOWITHIT                YES, BYPASS ERROR MESSAGE
         TPUT  MSG1,L'MSG1             PUT OUT ERROR MESSAGE
         B     EXIT10                  EXIT COMMAND
GOWITHIT EQU   *
         GTTERM PRMSZE=PRMSZE,ALTSZE=ALTSZE,ATTRIB=ATTRIB
         L     R2,=A(ATTNRTN)          GET ADDR OF ATTN ROUTINE
         STAX  (R2)                    SET UP STAX QUEUE ELEMENT
         LTR   R15,R15                 GO OK?
         BZ    DRBYPERR                YES, BYPASS ERROR CODE
         TPUT  MSG6,L'MSG6             PUT OUT ERROR MESSAGE
         B     EXIT10                  GO HOME.....
DRBYPERR EQU   *
         BAL   R9,PARSEINP             PARSE INPUT COMMAND
         MVC   SC1VOLSR,VOLSER         COPY VOLSER & DEVTYP
         BAL   R9,GETDSCB4             GET FORMAT4 DSCB
         BAL   R9,DEVTYPER             FIGURE OUT DEVICE TYPE
         BAL   R9,GETDSCB1             READ THE VTOC
         BAL   R9,SORT                 SORT THE ENTRIES
         STFSMODE ON,INITIAL=YES       SET FULL SCREEN MODE ON
DRLOOPMN EQU   *
         BAL   R9,FORMATER             FORMAT EXTRACT DATA INTO SCREEN
         BAL   R9,TPUTMAIN             GO PAINT MAIN INPUT SCREEN
*        CLI   MESSAGE,C'3'            DID USER PRESS PF3? (IN FULLSCR)
*        BE    DRCLEAR                 GO TO DRIVER'S CLEAR/EXIT
*------> IF USER MOVED THE CURSOR WE WANT TO MOVE THE PAGE THERE
         CLC   MESSAGE+1(2),=XL2'5DC8' WHERE IT IS NORMALLY...
         BE    DRCSRNMV                CURSOR DIDN'T MOVE
*------> CODE ABOVE SHOULD BE A (BE) TO ACTIVATE SCREEN POSITIONING
         MVC   BUFFADDR,MESSAGE+1      MOVE THE CURSOR LANDING SPOT
         BAL   R9,TUBETORC             CONVERT TO ROW/COLUMN
         CLC   ROW,=CL2'05'            LESS THAN ROW 5?
         BL    DRCSRNMV                IGNORE REQUEST
         CLC   ROW,=CL2'22'            MORE THAN ROW 22?
         BH    DRCSRNMV                IGNORE REQUEST
         PACK  WORKDBLW,ROW            PACK THE ROW
         CVB   R6,WORKDBLW             MAKE IT HEX
         BCTR  R6,0                    NORMALIZE LINE NUMBER
         MH    R6,=H'80'               MULTIPLY LINE LENGTH
         LA    R7,SC1LN01              GET ORIGIN
         AR    R7,R6                   PTR TO START OF LINE
         PACK  WORKDBLW,SCLINENO       MOVE LINENO FOUND FROM SCREEN
         L     R4,EATBLFST             GET ORIGIN OF TABLE
         L     R5,EATBLAST             GET END OF TABLE
DRSRCH01 EQU   *
         CR    R4,R5                   END-OF-TABLE?
         BNL   DRCSRNMV                IGNORE REQUEST
         CP    WORKDBLW,EALINENO       IS IT THIS ENTRY?
         BE    DRSRCHFN                YES, GO TO FOUND
         LA    R4,EXTRLNTH(R4)         BUMP
         B     DRSRCH01                ITERATE
DRSRCHFN EQU   *
         ST    R4,EATBLNXT             SET NEW PTR
         ST    R4,EATBLTOP             SET NEW PTR
DRCSRNMV EQU   *
         CLI   MESSAGE,C'7'            DID USER PRESS PF7?
         BNE   DRNOTPB                 BYPASS PAGEBACK CODE
         L     R4,EATBLTOP             PTR TO NEXT ENTRY
         LA    R5,EXTRLNTH             GET LENGTH OF NODE
         MH    R5,=H'17'               GO BACK 17 LINES
         SR    R4,R5                   SUBTRACT 17 VOLUMES
         C     R4,EATBLFST             GONE TOO FAR?
         BNL   DRBYPTOO                OK, BYPASS RESET CODE
         L     R4,EATBLFST             RESET
DRBYPTOO EQU   *
         ST    R4,EATBLNXT             STORE NEW NEXT PTR (PAGEBACK)
DRNOTPB  EQU   *
         B     DRLOOPMN                MAIN DRIVER LOOP
DRCLEAR  EQU   *
         TPUT  CLSCREEN,12,FULLSCR     CLEAR SCREEN
         STLINENO MODE=OFF,LINE=1      SET FULL SCREEN MODE OFF
         SPACE 1
EXIT10   EQU   *
         L     R9,SAVE10
         BR    R9
         EJECT
***********************************************************************
*   THIS ROUTINE PARSES THE COMMAND INPUT                             *
***********************************************************************
         SPACE 2
PARSEINP DS    0H
         ST    R9,SAVE15
         B     BSAVE15
SAVE15   DC    F'-1'
         DC    CL8'PARSEINP'
BSAVE15  EQU   *
         SPACE 1
*--> GET THE INPUT PARAMETERS
         L     R2,CPPLCBUF             GET CBUF PTR
         LH    R3,0(R2)                GET LENGTH
         CH    R3,=H'13'               IS IT AT LEAST 13?
         BL    GETVOL                  NO, GO ASK FOR IT
         LA    R3,7(R2)                EARLIEST POINT TO START LOOKING
         LH    R5,0(R2)                COPY LENGTH
         SH    R5,=H'8'                PREFIX + 1 FOR EX
         EX    R5,PIEXOC               RAISE TO UPPER-CASE
PIEXOC   OC    0(0,R3),=CL50' '        RAISE TO UPPER-CASE
         LH    R4,0(R2)                PICK UP COMPLETE LENGTH
         SH    R4,=H'7'                KNOCK OFF PREFIX
PIFNDFLD EQU   *
         CLC   0(4,R3),=CL4'VOL('      FIND THE VOLUME QUALIFIER
         BE    PIFOUNDL                FOUND, GO PROCESS
         CLC   0(4,R3),=CL4'LEV('      FIND THE LEVEL QUALIFIER
         BE    PIFOUNDI                FOUND, GO PROCESS
         LA    R3,1(R3)                BUMP
         BCT   R4,PIFNDFLD             ITERATE
         CLI   VOLSER,C' '             WAS THE VOLSER FOUND?
         BE    GETVOL                  NO, GO ASK FOR IT
         B     EXIT15                  YES, EXIT
*------- ----- VOL(XXXXXX) ENTRY FOUND, PROCESS
PIFOUNDL EQU   *
         LA    R3,4(R3)                BUMP TO START OF VOLSER
         SH    R4,=H'4'                SUBTRACT FOR PREFIX
         LR    R5,R3                   SAVE VOLSER START ADDRESS
PIFNDPR1 EQU   *
         CLI   0(R3),C')'              REACHED THE END YET?
         BE    PIPR1FND                YEP, GO PROCESS
         LA    R3,1(R3)                BUMP
         BCT   R4,PIFNDPR1             ITERATE
         B     GETVOL                  GO ASK FOR INFORMATION
PIPR1FND EQU   *
         LR    R6,R3                   COPY ENDING ADDRESS
         SR    R6,R5                   LENGTH OF VOLSER
         BCTR  R6,0                    SUBTRACT 1 FOR EX
         EX    R6,PIEXMVC1             MOVE THE VOLSER
PIEXMVC1 MVC   VOLSER(1),0(R5)         MOVE THE VOLSER
         OC    VOLSER,=CL50' '         CHANGE IT TO UPPER CASE
         B     PIFNDFLD                GO TRY FOR LEVEL
*------- ----- LEV(XXXXXX) ENTRY FOUND, PROCESS
PIFOUNDI EQU   *
         LA    R3,4(R3)                BUMP TO START OF LEVEL
         SH    R4,=H'4'                SUBTRACT FOR PREFIX
         LR    R5,R3                   SAVE LEVEL START ADDRESS
PIFNDPR2 EQU   *
         CLI   0(R3),C')'              REACHED THE END YET?
         BE    PIPR2FND                YEP, GO PROCESS
         LA    R3,1(R3)                BUMP
         BCT   R4,PIFNDPR2             ITERATE
         B     GETVOL                  GO ASK FOR INFORMATION
PIPR2FND EQU   *
         LR    R6,R3                   COPY ENDING ADDRESS
         SR    R6,R5                   LENGTH OF LEVEL
         STH   R6,LEVELNTH             STORE LENGTH OF THE LEVEL
         BCTR  R6,0                    SUBTRACT 1 FOR EX
         EX    R6,PIEXMVC2             MOVE THE LEVEL
PIEXMVC2 MVC   LEVEL(1),0(R5)          MOVE THE LEVEL
         OC    LEVEL,=CL50' '          CHANGE IT TO UPPER CASE
         B     PIFNDFLD                GO TRY FOR VOLSER
*------- ----- NOT SUCCESSFUL THUS FAR, ASK USER FOR VOLSER
GETVOL   EQU   *
         TPUT  MSG5,L'MSG5             ASK FOR THE VOLSER
         TGET  VOLSER,6                READ IT
         LTR   R1,R1                   IS IT ZERO?
         BZ    GETVOL                  YES, GO ASK FOR IT AGAIN
         CH    R1,=H'6'                IS IT TOO BIG?
         BH    GETVOL                  YES, GO ASK FOR IT AGAIN
BYPTGETS EQU   *
         OC    VOLSER,=CL50' '         CHANGE IT TO UPPER CASE
         SPACE 1
EXIT15   EQU   *
         L     R9,SAVE15
         BR    R9
         EJECT
***********************************************************************
*     THIS ROUTINE OBTAINS THE FORMAT 4 DSCB                          *
***********************************************************************
         SPACE 2
GETDSCB4 DS    0H
         ST    R9,SAVE20
         B     BSAVE20
SAVE20   DC    F'-1'
         DC    CL8'GETDSCB4'
BSAVE20  EQU   *
         SPACE 1
         MVI   DSN,X'04'           INDICATE DSCB FORMAT 4
         MVC   DSN+1(43),DSN       PROPOGATE
         XC    DSCB4LST,DSCB4LST   CLEAR THE VOLUME LIST AREA
         OBTAIN OBLIST4            GET DSCB1
         LTR   R15,R15             CHECK RETURN CODE
         BZ    D4BYP01             IF OK, BYPASS
         ISK   0,0                 DIE RIGHT HERE
D4BYP01  EQU   *
         MVC   HICCHHR(5),DS4HPCHR     SAVE HIGH ADDRESS OF F1 DSCB
         MVC   VOLTKCYL(2),DS4DEVSZ+2  GET NUM OF TRKS/CYL
         MVC   VOLDSCTK+1(1),DS4DEVDT  GET NUM OF DSCBS PER TRK
         MVC   VOLF4CHR(4),DS4VTOCE+2  GET CCHH OF START OF VTOC
         MVI   VOLF4CHR+4,X'01'        F4 DSCB WAS FIRST REC (00)
         SPACE 1
EXIT20   EQU   *
         L     R9,SAVE20
         BR    R9
         EJECT
***********************************************************************
*     THIS ROUTINE FIGURES OUT THE DEVICE TYPE                        *
***********************************************************************
         SPACE 2
DEVTYPER DS    0H
         ST    R9,SAVE25
         B     BSAVE25
SAVE25   DC    F'-1'
         DC    CL8'DEVTYPER'
BSAVE25  EQU   *
         SPACE 1
         L     R15,CVTPTR          GET PTR TO THE CVT
         MVC   DSADCB,CVTDCB-CVT(R15)  SAVE OP SYS TYPE
         TM    DSADCB,DSADCBXA     IS IT MVS/XA
         BO    UCBCHKXA            UCB CHECK FOR XA
*------> MUST BE AN OLD PRE-XA SYSTEM, USE THE UCB CHAIN
         L     R2,16               GET CVT
         L     R2,40(R2)           GET UCBILK2
         XR    R3,R3               CLEAR WORK REGISTER
NOCATLP  EQU   *
         CLC   0(2,R2),=X'FFFF'    END OF LOOKUP TABLE?
         BE    VSBAD
         CLC   0(2,R2),=X'0000'    NULL ENTRY?
         BE    BUMPIX
         ICM   R3,B'0011',0(R2)    PICK UP PTR
         CLC   28(6,R3),VOLSER     THIS VOLSER?
         BE    MVDEVTYP            MOVE THE DEVICE TYPE
BUMPIX   EQU   *
         LA    R2,2(R2)            BUMP TO NEXT ENTRY
         B     NOCATLP             GO CHECK NEXT
*------------------------------------------------------------------
***>>>>>>----UCB SCAN SERVICE FOR MVS/SP1.2 AND ABOVE:-----<<<<<<***
** PARM: (100BYTE-WORK, 1BYTE-DEV-CLASS, 1WORD-UCB-PTR)           **
** RETURN CODES: R15 = 00-UCB RETURNED; 04-NO MORE UCBS           **
*------------------------------------------------------------------
UCBCHKXA EQU   *
         XC    DSXAWORK,DSXAWORK       ZERO OUT UCB WORKAREA
         LA    R1,DSXAWORK             ADDR OF UCB WORKAREA
         ST    R1,DSXAWA               STORE IT IN PARM LIST
         LA    R1,DSXACLAS             PTR TO DEV CLAS TO SEARCH
         ST    R1,DSXADEVT             STORE IN PARM LIST
         MVI   DSXACLAS,UCB3DACC       ONLY SEARCH DASD
         LA    R1,DSXAUCBP             AREA TO STORE UCB ADDR
         ST    R1,DSXAUCB              IN PARM LIST
         OI    DSXAUCB,X'80'           SIGNIFY END OF PARMLIST
UCBLOOP  EQU   *
         L     R15,CVTPTR
         ICM   R15,15,CVTUCBSC-CVT(R15) CVTUCBSC VALID?(IOSVSUCB)
         LA    R1,DSXALIST             PTR TO PARM LIST
         BALR  R14,R15                 BRANCH TO IT
         LTR   R15,R15                 GOT ONE?
         BNZ   VSBAD                   NO
         L     R8,DSXAUCBP GET ADR OF  UCB FROM PTR
         USING UCBCMSEG,R8
         CLI   UCBID,UCBSTND           IS ADDRESS VALID
         BNE   UCBLOOP                 NO
         CLI   UCBDVCLS,UCB3DACC       IS IT DASDI
         BNE   UCBLOOP                 NO   SKIP
         TM    UCBSTAT,UCBONLI         IS IT ONLINE
         BNO   UCBLOOP                 NO  SKIP
         TM    UCBSTAT,UCBCHGS         IS IT CHANGING STATUS
         BO    UCBLOOP                 YES SKIP
         CLC   28(6,R8),VOLSER         COMPARE VOLSER
         BNE   UCBLOOP                 DONT WANT
MVDEVTYP EQU   *
         MVC   DEVTYPE,18(R8)          MOVE DEVICE TYPE
         MVC   UCBNUM,13(R8)           MOVE UCB NUMBER
         B     FDEVICE0                GO GET THE DEVICE NAME
*------> CAN'T LOCATE THE CORRECT VOLUME, ERR MSG THEN ABANDON SHIP
VSBAD    EQU   *
         TPUT  MSG2,L'MSG2         ISSUE ERROR MESSAGE
         B     EXIT10              GO TO THE DRIVER'S EXIT
*------> FIND THE DEVICE TYPE IN THE TABLE AND GET THE TRK/CYL COUNT
FDEVICE0 EQU   *
         LA    R2,DEVTABLE
FDEVICE1 EQU   *
         CLC   0(2,R2),=X'0000'    END OF TABLE?
         BE    FDEVICE2                YES, CHECK UCB
         CLC   0(2,R2),DEVTYPE     IF SAME DEVICE CODE....
         BE    FDEVICE2
         LA    R2,10(R2)           BUMP TO NEXT ENTRY
         B     FDEVICE1
FDEVICE2 EQU   *
         MVC   SC1DNAME,4(R2)      MOVE NAME FROM TABLE
         SPACE 1
EXIT25   EQU   *
         L     R9,SAVE25
         BR    R9
         EJECT
***********************************************************************
*     THIS ROUTINE OBTAINS THE FORMAT 1 DSCB'S AND BUILDS THE TABLE   *
***********************************************************************
         SPACE 2
GETDSCB1 DS    0H
         ST    R9,SAVE30
         B     BSAVE30
SAVE30   DC    F'-1'
         DC    CL8'GETDSCB1'
BSAVE30  EQU   *
         SPACE 1
         L     R0,=A(EXTRLNTH)         SET FOR NODE LENGTH
         MH    R0,=AL2(300)            MAX NUMBER OF DATASETS
         GETMAIN R,LV=(R0),BNDRY=DBLWD GO GET SOME MEMORY
         LR    R4,R1                   COPY ORIGIN ADDRESS
         ST    R4,EATBLFST             STORE ORIGIN ADDRESS
         ST    R4,EATBLNXT             INITIALLY FIRST ENTRY
*------- ----- READ THROUGH THE VTOC SAVING DATA FROM ALL F1 DSCBS
         LA    R6,1
         LH    R8,VOLF4CHR         GET CYLINDER
         LH    R7,VOLF4CHR+2       GET HEAD
DSCBLOOP EQU   *
         LA    R6,1(R6)            BUMP RECORD PTR
         CH    R6,VOLDSCTK         TEST FOR LAST REC ON TRK
         BNH   VBSET               GO SET VTOCCHHR
         LA    R6,1                RESET R6 TO 1
         LA    R7,1(R7)            BUMP TRK COUNTER
         CH    R7,VOLTKCYL         PAST END OF CYL?
         BL    VBSET               GO SET VTOCCHHR
         SR    R7,R7               ELSE SET R7 TO TRK 0
         LA    R8,1(R8)            BUMP TO NEXT CYL
VBSET    EQU   *
         STH   R8,VTOCCHHR         SET...
         STH   R7,VTOCCHHR+2          UP...
         STC   R6,VTOCCHHR+4            VTOCCHHR
         CLC   VTOCCHHR(5),HICCHHR BEYOND HIGHEST DSCB ADDRESS?
         BH    AIEND
         OBTAIN OBLIST1            GO READ F1 DSCB
         LTR   R15,R15
         BZ    DSBYP01
         ISK   0,0                 CRAP OUT RIGHT HERE
DSBYP01  EQU   *
         CLI   DS1FMTID,X'F1'      IS IT A FORMAT 1 DSCB?
         BNE   DSCBLOOP
         LH    R1,LEVELNTH             GET LENGTH FOR EXECUTE
         LTR   R1,R1                   IS IT NON-ZERO?
         BZ    DSEXCLC1+6              YES, BYPASS DSN LEVEL CHECK
         BCTR  R1,0                    SUBTRACT ONE FOR THE EXECUTE
         EX    R1,DSEXCLC1             CHECK THE DSN LEVEL
         BNE   DSCBLOOP                NOT SAME, GO READ NEXT DSCB1
DSEXCLC1 CLC   LEVEL(1),DS1DSNAM       CHECK THE DSN LEVEL
*------- ----- SAVE THE CCHHR OF THE DSCB FOR THE DISPLAY
         MVC   EADSCB,VTOCCHHR     MOVE CCHHR OF DSCB
*------- ----- MOVE ALL OF THE FIELDS FROM THE F1 DSCB WE JUST FOUND
         MVC   EADSN,DS1DSNAM          MOVE DSNAME
*------- ----- IS THE RACF BIT TURNED ON?
         MVC   EARACF,=CL4'NONE'   SET DEFAULT
         TM    DS1DSIND,DS1IND40   RACF BIT TURNED ON?
         BNO   GDLRECL             NO, MOVE ON TO LRECL
         MVC   EARACF,=CL4'RACF'   SET RACF INDICATOR
*------- ----- GET THE LRECL
GDLRECL  EQU   *
         LH    R5,DS1LRECL         GET LRECL
         STH   R5,EALRECL
*------- ----- GET THE BLKSIZE
         LH    R5,DS1BLKL          GET BLKSIZE
         STH   R5,EABLKSIZ
*------- ----- GET THE KEY LENGTH
         MVC   EAKEYLEN,DS1KEYL    GET KEYLEN
*------- ----- GET THE RELATIVE KEY POSITION
         MVC   WORKDBLW(2),DS1RKP  GET OFFSET
         LH    R5,WORKDBLW
         STH   R5,EARKPOFF
*------- ----- FORMAT THE DSORG FIELD
         MVC   EADSORG,=CL2'?'     MOVE NOT FOUND INDICATOR
DSOK     EQU   *
         TM    DS1DSORG,X'80'      IS DSORG=IS?
         BNO   D1NOTIS
         MVC   EADSORG,=CL2'IS'
         B     D1TESTRF
D1NOTIS  EQU   *
         TM    DS1DSORG,X'40'      IS DSORG=PS?
         BNO   D1NOTPS
         MVC   EADSORG,=CL2'PS'
         B     D1TESTRF
D1NOTPS  EQU   *
         TM    DS1DSORG,X'20'      IS DSORG=DA?
         BNO   D1NOTDA
         MVC   EADSORG,=CL2'DA'
         B     D1TESTRF
D1NOTDA  EQU   *
         TM    DS1DSORG,X'02'      IS DSORG=PO?
         BNO   D1TESTRF
         MVC   EADSORG,=CL2'PO'
D1TESTRF EQU   *
         TM    DS1DSORG,X'01'      IS DSORG=U?
         BNO   D1NOTU
         MVC   EADSORG,=CL2'U '
D1NOTU   EQU   *
*------- ----- FORMAT THE RECFM FIELD
         LA    R5,EARECFM          POINT TO STORAGE ADDRESS
         TM    DS1RECFM,X'C0'      TEST FOR UNKNOWN RECFM
         BZ    RFT
         TM    DS1RECFM,X'40'      TEST FOR F RECFM
         BNZ   RFUORV
         MVI   0(R5),C'F'
         LA    R5,1(R5)            BUMP TO NEXT CHAR
         B     RFT
RFUORV   EQU   *
         TM    DS1RECFM,X'80'
         BZ    RFV
         MVI   0(R5),C'U'          OTHERWISE UNDEFINED
         LA    R5,1(R5)
         B     RFT
RFV      EQU   *
         MVI   0(R5),C'V'
         LA    R5,1(R5)
RFT      EQU   *
         TM    DS1RECFM,X'20'      TEST FOR T RECFM
         BZ    RFB
         MVI   0(R5),C'T'
         LA    R5,1(R5)
RFB      EQU   *
         TM    DS1RECFM,X'10'      TEST FOR B RECFM
         BZ    RFS
         MVI   0(R5),C'B'
         LA    R5,1(R5)
RFS      EQU   *
         TM    DS1RECFM,X'08'      TEST FOR S RECFM
         BZ    RFA
         MVI   0(R5),C'S'
         LA    R5,1(R5)
RFA      EQU   *
         TM    DS1RECFM,X'04'      TEST FOR A RECFM
         BZ    RFM
         MVI   0(R5),C'A'
         LA    R5,1(R5)
RFM      EQU   *
         TM    DS1RECFM,X'02'      TEST FOR M RECFM
         BZ    RFEND
         MVI   0(R5),C'M'
         LA    R5,1(R5)
RFEND    EQU   *
         AP    LINECNT,=PL1'1'     BUMP LINE NUMBER
         ZAP   EALINENO,LINECNT    COPY IT
         LA    R4,EXTRLNTH(R4)     BUMP TO NEXT ENTRY
         B     DSCBLOOP            ITERATE
AIEND    EQU   *
         ST    R4,EATBLAST         STORE PTR TO END OF TABLE
         SPACE 1
EXIT30   EQU   *
         L     R9,SAVE30
         BR    R9
         EJECT
***********************************************************************
*   THIS ROUTINE BUBBLE SORTS THEN RENUMBERS THE ENTRIES IN THE TABLE *
***********************************************************************
         SPACE 2
SORT     DS    0H
         ST    R9,SAVE40
         B     BSAVE40
SAVE40   DC    F'-1'
         DC    CL8'SORT    '
BSAVE40  EQU   *
         SPACE 1
         L     R3,EATBLFST             GET FIRST ADDRESS
         SP    LINECNT,=PL1'1'         DECREMENT FIRST TIME
SORTLP01 EQU   *
         LR    R4,R3                   GET CURRENT FIRST ADDRESS
         LA    R5,EXTRLNTH(R3)         GET NEXT TABLE ENTRY
SORTLP02 EQU   *
         C     R5,EATBLAST             REACHED THE END YET?
         BNL   NEXTPASS                YES, GO DECREMENT COUNTER
         CLC   EADSN,2(R5)             COMPARE DSN'S
         BH    SORTBIG                 B < A; GOTO SWAP
SORTINDX EQU   *
         LA    R5,EXTRLNTH(R5)         BUMP INDEX
         B     SORTLP02                ITERATE
SORTBIG  EQU   *
         XC    2(EXTRLNTH-2,R4),2(R5)  A <-- B --+
         XC    2(EXTRLNTH-2,R5),2(R4)  B <-- A   |-- LOGICAL SWAP
         XC    2(EXTRLNTH-2,R4),2(R5)  A <-- B --+
         B     SORTINDX                GO ITERATE
NEXTPASS EQU   *
         SP    LINECNT,=PL1'1'         DECREMENT
         BL    EXIT40                  JUST WENT NEGATIVE, EXIT
         LA    R3,EXTRLNTH(R3)         NEXT ENTRY
         B     SORTLP01                ITERATE
         SPACE 1
EXIT40   EQU   *
         L     R9,SAVE40
         BR    R9
         EJECT
***********************************************************************
*     THIS ROUTINE FORMATS THE DATA DERIVED IN THE EXTRACT ROUTINE    *
*   AND FORMATS IT INTO THE SCREEN THAT IS THEN PAINTED DURING THE    *
*   TPUTMAIN ROUTINE WHICH FOLLOWS.                                   *
***********************************************************************
         SPACE 2
FORMATER DS    0H
         ST    R9,SAVE50
         B     BSAVE50
SAVE50   DC    F'-1'
         DC    CL8'FORMATER'
BSAVE50  EQU   *
         SPACE 1
         L     R4,EATBLNXT             GET NEXT ADDRESS
         ST    R4,EATBLTOP             SAVE CURRENT TOP
         LA    R7,SC1LN05              GET ORIGIN IN SCREEN
         LA    R8,18                   18 LINES OF DATA PER SCREEN
FMTLOOP1 EQU   *
         C     R4,EATBLAST             END OF EXTRACT TABLE?
         BNL   FMTCLEAR                CLEAR REST OF SCREEN LINES
         MVI   0(R7),C' '              CLEAR FIRST BYTE
         MVC   1(79,R7),0(R7)          CLEAR THE REST OF THE LINE
         MVC   SCLINENO-1(4),=XL4'40202120' INSERT EDIT MASK
         ED    SCLINENO-1(4),EALINENO  EDIT IN THE LINE NUMBER
         MVC   SCDSN,EADSN             MOVE THE DSNAME
         CLI   EADSN+L'SCDSN,C' '      TRUNCATION OCCURRED?
         BE    FMTNTRNC                NOPE, BYPASS
         MVI   SCDSN+(L'SCDSN-1),C'>'  INDICATE TRUNCATION
FMTNTRNC EQU   *
         MVC   SCDSORG,EADSORG         MOVE THE DSORG
         MVC   SCRECFM,EARECFM         MOVE THE RECFM
         MVC   SCRACF,EARACF           MOVE THE RACF INDICATOR
*--> FMT THE DSCB/CCHHR
         UNPK  SCDSCB(11),EADSCB(6)    UNPACK
         MVC   SCDSCB+10(2),=CL2' '    GET RID OF SIGN
         TR    SCDSCB,HEXTR-X'F0'      MAKE DISPLAYABLE
*--> FMT THE LRECL
         LH    R1,EALRECL          GET LRECL
         CVD   R1,WORKDBLW
         MVC   SCLRECL,=XL7'4020206B202120'
         ED    SCLRECL,WORKDBLW+5
*--> FMT THE BLKSIZE
         LH    R1,EABLKSIZ         GET BLKSIZE
         CVD   R1,WORKDBLW
         MVC   SCBLKSIZ,=XL7'4020206B202120'
         ED    SCBLKSIZ,WORKDBLW+5
FMTNEXT  EQU   *
         LA    R7,80(R7)               BUMP TO NEXT SCREEN LINE
         LA    R4,EXTRLNTH(R4)         BUMP TO NEXT ENTRY
         BCT   R8,FMTLOOP1             ITERATE
         LA    R1,EXTRLNTH             GET LENGTH OF EXTRACT ENTRY
         SR    R4,R1                   SUBTRACT ONE ENTRY
         MVC   EATBLPRV,EATBLNXT       SAVE OLD ORIGIN PTR
         ST    R4,EATBLNXT             STORE NEW NEXT PTR
FMTCLEAR EQU   *
         LTR   R8,R8                   RUN OUT OF LINES YET?
         BZ    FMTEND                  YES, ENOUGH IS ENOUGH
         MVI   0(R7),C' '              CLEAR FIRST BYTE
         MVC   1(79,R7),0(R7)          CLEAR THE REST OF THE LINE
         LA    R7,80(R7)               BUMP TO NEXT LINE
         BCT   R8,FMTCLEAR             ITERATE
FMTEND   EQU   *
         SPACE 1
EXIT50   EQU   *
         L     R9,SAVE50
         BR    R9
         EJECT
***********************************************************************
*     THIS ROUTINE PAINTS THE INPUT SCREEN AND READS A RESPONSE FROM  *
*   THE TERMINAL.  UPON RETURN, REGISTER 1 WILL CONTAIN THE NUMBER    *
*   OF BYTES READ FROM THE TERMINAL.                                  *
***********************************************************************
         SPACE 2
TPUTMAIN DS    0H
         ST    R9,SAVE60
         B     BSAVE60
SAVE60   DC    F'-1'
         DC    CL8'TPUTMAIN'
BSAVE60  EQU   *
         SPACE 1
         LA    R2,ATRLST1B             ADDR OF ATTRIBUTE LIST
         ST    R2,ALISTPTR             STORE IN PTR AREA
         LA    R2,SCREEN1              ADDR OF ATTRIBUTE LIST
         ST    R2,ASCRNPTR             STORE IN PTR AREA
         LA    R2,SC1SUFIX             ADDR OF SUFFIX
         ST    R2,ASUFXPTR             STORE IN PTR AREA
         LA    R2,L'SC1SUFIX           GET LENGTH OF SUFFIX
         STC   R2,ASUFXPTR             STORE IN PTR AREA
         MVC   ASCRNSIZ,=F'1920'       STORE SIZE OF SCREEN
         BAL   R9,FULLSCR              GO DO DEMO SCREEN WORK
         LTR   R1,R1                   DID USER TYPE IN COMMAND?
         BZ    DRCLEAR                 YES, BYPASS CLEAR
         SPACE 1
EXIT60   EQU   *
         L     R9,SAVE60
         BR    R9
         EJECT
***********************************************************************
*   THIS ROUTINE BUILDS THE FINAL SCREEN, DOES A FULL SCREEN TPUT,    *
* A DUMMY TGET, AND CLEARS THE SCREEN.  THE MAJOR PART OF THE CODE    *
* IS THE BUILDING OF THE FINAL SCREEN.  THE ROUTINE HAS THREE INPUTS. *
* 'ASCRNPTR' POINTS TO A STANDARD 1920 BYTE SCREEN IMAGE WITH NO      *
* ATTRIBUTE CHARACTERS.  'ALISTPTR' CONTAINS THE ADDRESS OF THE       *
* ATTRIBUTE LIST THAT WE WILL USE THIS TIME AROUND.  'SCPREFIX' IS    *
* THE CONTROL STREAM WHICH IS TO BE PREFIXED ONTO THE FINAL SCREEN.   *
*   USING THE THREE INPUTS, A TPUT'ABLE FINAL SCREEN IS BUILT IN THE  *
* 'SCRBLD' AREA AT THE END OF THE PROGRAM.                            *
***********************************************************************
         SPACE 1
FULLSCR  DS    0H
         ST    R9,SAVE70
         B     BSAVE70
SAVE70   DC    F'-1'
         DC    CL8'FULLSCR '
BSAVE70  EQU   *
         SPACE 1
*--> INIT REGISTERS
         L     R2,ALISTPTR             GET PTR TO ATTRIBUTE LIST
         L     R3,0(R2)                GET END OF ATTRIBUTE LIST
         LA    R2,4(R2)                BUMP PAST END ADDRESS
         LA    R4,SCRBLD               GET ADDR OF BUILD AREA
         XR    R5,R5                   INIT LENGTH REGISTER
         L     R6,ASCRNPTR             GET ADDR OF INPUT SCREEN
         LR    R7,R6                   GET BEGINNING
         A     R7,ASCRNSIZ             ADD SIZE OF SCREEN TO GET END
*--> INSERT PREFIX
         MVC   0(L'SCPREFIX,R4),SCPREFIX   MOVE PREFIX
         LA    R4,L'SCPREFIX(R4)       BUMP PTR
         LA    R5,L'SCPREFIX(R5)       ADD LENGTH
*--> FLAG ATTRIBUTE BYTES FIRST
FSLOOP10 EQU   *
         CR    R2,R3                   END OF ATTRIBUTE LIST?
         BE    FSLOOP20                YES, END OF FLAGGING
         L     R8,0(R2)                GET ADDR OF NEXT ATTR BYTE
         MVI   0(R8),X'1D'             FLAG BYTE WITH A X'FF'
         LA    R2,4(R2)                GET NEXT ATTRIBUTE ADDR
         B     FSLOOP10                GO TRY NEXT
FSLOOP20 EQU   *
         L     R2,ALISTPTR             GET PTR TO ATTRIBUTE LIST
         LA    R2,4(R2)                BUMP PAST END ADDRESS
FSLOOP30 EQU   *
         CR    R6,R7                   INPUT SCREEN EXHAUSTED?
         BE    FSLOOP50                GO TPUT
         CLI   0(R6),X'1D'             IS THIS A FLAG?
         BE    FSLOOP40                YES, GO PROCESS
         MVC   0(1,R4),0(R6)           NO, MOVE THIS BYTE TO OUTPUT
         LA    R4,1(R4)                BUMP PTR TO OUTPUT SCREEN
         LA    R5,1(R5)                BUMP LENGTH OF OUTPUT
         LA    R6,1(R6)                BUMP TO NEXT INPUT BYTE
         B     FSLOOP30                GO TRY NEXT BYTE
FSLOOP40 EQU   *
         MVC   0(1,R4),0(R6)           MOVE FLAG TO OUTPUT
         MVC   1(1,R4),0(R2)           MOVE ATTR TO OUTPUT
         LA    R2,4(R2)                BUMP TO NEXT ATTR
         LA    R4,2(R4)                BUMP TWO BYTES IN OUTPUT
         LA    R5,2(R5)                BUMP LENGTH BY TWO
         LA    R6,1(R6)                BUMP TO NEXT INPUT BYTE
         B     FSLOOP30                GO TRY NEXT BYTE
FSEXMVC  MVC   0(0,R4),0(R8)           MOVE SUFFIX TO OUTPUT
FSLOOP50 EQU   *
         XR    R1,R1                   CLEAR REGISTER
         IC    R1,ASUFXPTR             GET LENGTH TO MOVE
         BCTR  R1,0                    SUBTRACT ONE FOR MVC
         L     R8,ASUFXPTR             ADDR OF SUFFIX
         EX    R1,FSEXMVC              MOVE THE SUFFIX TO OUTPUT
         AR    R4,R1                   BUMP LENGTH OF SUFFIX
         AR    R5,R1                   BUMP LENGTH OF SUFFIX
         LA    R4,1(R4)                RESTORE 1 BYTE FROM EX
         LA    R5,1(R5)                RESTORE 1 BYTE FROM EX
*--> TGET'S AND TPUT'S
         CLI   STAXSW,C'1'             HAVE WE BEEN INTERRUPTED?
         BE    FSINTRPT                YES, BYPASS THIS TPUT
FSREFRSH EQU   *
         TPUT  SCRBLD,(R5),FULLSCR     PAINT OUTPUT SCREEN
         TM    ATTRIB+3,X'01'          DOES THIS TUBE SUPPORT COLOR?
         BNO   NOCOLOR                 BRANCH AROUND COLORS
         TPUT  SC1COLOR,LSC1CLR,NOEDIT WRITE SPECIALTY COLORS
NOCOLOR  EQU   *
         TGET  MESSAGE,126,ASIS        GET DUMMY INPUT
         CLI   MESSAGE,C'3'            DID USER PRESS PF3?
         BE    DRCLEAR                 GO TO DRIVER'S CLEAR/EXIT
         CLI   MESSAGE,X'7D'           DID USER PRESS ENTER
         BE    FSREFRSH                RE-PAINT SCREEN
         CLI   STAXSW,C'1'             HAVE WE BEEN INTERRUPTED?
         BNE   EXIT70                  NO, CONTINUE
FSINTRPT EQU   *
         TPUT  CLSCREEN,12,FULLSCR     CLEAR SCREEN
         TPUT  MSG7,L'MSG7             SEND INTERRUPTED MESSAGE
         L     R13,SAVEAREA+4          GET ADDR OF SAVEAREA
         LM    R14,R12,12(R13)         RESTORE CALLERS REGISTERS
         LA    R15,4                   SET RC=4
         BR    R14                     RETURN TO CALLER
         SPACE 1
EXIT70   EQU   *
         L     R9,SAVE70
         BR    R9
         EJECT
***********************************************************************
*   THIS ROUTINE CALCULATES THE SCREEN ADDR'S FROM LINE START ADDRESS *
***********************************************************************
         SPACE 2
CALCADDR DS    0H
         ST    R9,SAVE100
         B     BSAVE100
SAVE100  DC    F'-1'
         DC    CL8'CALCADDR'
BSAVE100 EQU   *
         SPACE 1
*------> AT ENTRY, R8 MUST CONTAIN A PTR TO A VOLSER ON A SCREEN LINE
         LA    R7,SC1LN01              PICK UP ADDR OF START OF SCREEN
         SR    R8,R7                   GENERATE DISPLACEMENT
         CVD   R8,WORKDBLW             CONVERT TO DECIMAL
         DP    WORKDBLW,=PL2'80'       DIVIDE BY LINE LENGTH
         AP    WORKDBLW(6),=PL1'1'     VOLSER IS ON FOLLOWING LINE
         UNPK  ROW,WORKDBLW+4(2)       UNPACK
         OI    ROW+1,X'F0'             CLEAR SIGN NIBBLE
         MVC   COLUMN,=CL2'01'         SET UP COLUMN
         BAL   R9,RCTOTUBE             CONVERT ROW/COLUMN TO SCREEN ADR
         MVC   STARTADR,BUFFADDR       STARTING ADDRESS
         MVC   COLUMN,=CL2'26'         SET UP COLUMN
         BAL   R9,RCTOTUBE             CONVERT ROW/COLUMN TO SCREEN ADR
         MVC   ENDADDR,BUFFADDR        ENDING SCREEN ADDRESS
         SPACE 1
EXIT100  EQU   *
         L     R9,SAVE100
         BR    R9
         EJECT
***********************************************************************
*     THIS ROUTINE PROCESSES THE ROW/COLUMN TO BUFFER CONVERSION      *
***********************************************************************
         SPACE 2
RCTOTUBE DS    0H
         ST    R9,SAVE510
         B     BSAVE510
SAVE510  DC    F'-1'
         DC    CL8'RCTOTUBE'
BSAVE510 EQU   *
         SPACE 1
*--> USER WANTS A ROW/COLUMN TO BUFFER ADDRESS CONVERSION
         PACK  R327FLD1,ROW            PACK THE ROW NUMBER
         SP    R327FLD1,=PL1'1'        SUBTRACT 1
         MP    R327FLD1,=PL2'80'       NO, MULTIPLY BY 80
         PACK  R327FLD2,COLUMN         PACK THE COLUMN
         AP    R327FLD1,R327FLD2       ADD TO GET POSITION NUMBER
         SP    R327FLD1,=PL1'1'        SUBTRACT TO GET REL POSITION
         DP    R327FLD1,=PL2'64'       DIVIDE BY BASE 64
         ZAP   WORKDBLW,R327FLD1(2)    MOVE FOR CONVERSION
         CVB   R2,WORKDBLW             CONVERT FOR USE AS AN INDEX
         LA    R3,TABLE327             GET BASE ADDRESS
         AR    R3,R2                   ADD DISPLACEMENT TO BASE
         MVC   BUFFADDR+0(1),0(R3)     MOVE CHARACTERS FROM TABLE
         ZAP   WORKDBLW,R327FLD1+2(2)  MOVE FOR CONVERSION
         CVB   R2,WORKDBLW             CONVERT FOR USE AS AN INDEX
         LA    R3,TABLE327             GET BASE ADDRESS
         AR    R3,R2                   ADD DISPLACEMENT TO BASE
         MVC   BUFFADDR+1(1),0(R3)     MOVE CHARACTERS FROM TABLE
         SPACE 1
EXIT510  EQU   *
         L     R9,SAVE510
         BR    R9
         EJECT
***********************************************************************
*     THIS ROUTINE PROCESSES THE BUFFER TO ROW/COLUMN CONVERSION      *
***********************************************************************
         SPACE 2
TUBETORC DS    0H
         ST    R9,SAVE520
         B     BSAVE520
SAVE520  DC    F'-1'
         DC    CL8'TUBETORC'
BSAVE520 EQU   *
         SPACE 1
*--> USER WANTS A BUFFER ADDRESS TO ROW/COLUMN CONVERSION
         LA    R2,TABLE327             GET BASE ADDRESS OF TABLE
         LA    R3,64                   GET TABLE LENGTH
R3270510 EQU   *
         CLC   BUFFADDR(1),0(R2)       IS IT THIS POINT IN TABLE
         BE    R3270520                YES, BREAK OUT
         LA    R2,1(R2)                BUMP
         BCT   R3,R3270510             ITERATE
         ISK   0,0                     BUG, KILL IT RIGHT HERE
R3270520 EQU   *
         LA    R3,TABLE327             GET BASE ADDRESS OF TABLE
         SR    R2,R3                   GET OFFSET
         SLL   R2,6                    MULTIPLY BY 64
         CVD   R2,WORKDBLW             CONVERT TO DECIMAL
         ZAP   R327FLD1,WORKDBLW       PLACE IN SAFE-KEEPING
         LA    R2,TABLE327             GET BASE ADDRESS OF TABLE
         LA    R3,64                   GET TABLE LENGTH
R3270530 EQU   *
         CLC   BUFFADDR+1(1),0(R2)     IS IT THIS POINT IN TABLE
         BE    R3270540                YES, BREAK OUT
         LA    R2,1(R2)                BUMP
         BCT   R3,R3270530             ITERATE
         ISK   0,0                     BUG, KILL IT RIGHT HERE
R3270540 EQU   *
         LA    R3,TABLE327             GET BASE ADDRESS OF TABLE
         SR    R2,R3                   GET OFFSET
         CVD   R2,WORKDBLW             CONVERT TO DECIMAL
         AP    R327FLD1,WORKDBLW       ADD TO BASE
         DP    R327FLD1,=PL2'80'       NO, DIVIDE BY 80
         AP    R327FLD1+0(2),=PL1'1'   ADD 1 TO GET REAL ROW
         AP    R327FLD1+2(2),=PL1'1'   ADD 1 TO GET REAL COLUMN
         UNPK  ROW,R327FLD1(2)         RETURN THE ROW
         OI    ROW+1,X'F0'             CLEAR SIGN
         UNPK  COLUMN,R327FLD1+2(2)    RETURN THE COLUMN
         OI    COLUMN+1,X'F0'          CLEAR SIGN
         SPACE 1
EXIT520  EQU   *
         L     R9,SAVE520
         BR    R9
         EJECT
***********************************************************************
*           W O R K I N G   S T O R A G E   S E C T I O N             *
***********************************************************************
         SPACE 2
EATBLFST DS    F                       POINTER TO BGN OF EXTRACT TABLE
EATBLTOP DS    F                       POINTER TO TOP OF CURRENT SCREEN
EATBLAST DS    F                       POINTER TO END OF EXTRACT TABLE
EATBLPRV DS    F                       POINTER TO PREVIOUS SCREEN START
EATBLNXT DS    F                       POINTER TO NEXT ENTRY TO SHOW
MSG1     DC    CL36'COMMAND REQUIRES OPERATOR AUTHORITY'
MSG2     DC    CL27'VOLUME REQUESTED NOT FOUND'
MSG5     DC    CL32'PLEASE ENTER THE VOLSER DESIRED'
MSG6     DC    CL17'STAX MACRO FAILED'
MSG7     DC    CL19'COMMAND INTERRUPTED'
MESSAGE  DC    CL126' '                MESSAGE TO BE RECEIVED
LEVEL    DC    CL50' '                 LEVEL TO RESTRICT SEARCH TO
LEVELNTH DC    H'0'                    LENGTH OF THE LEVEL
PRMSZE   DS    CL2                     PRIMARY SCREEN SIZE
ALTSZE   DS    CL2                     SECONDARY SCREEN SIZE
ALTMOD3  EQU   X'20'                   TERMINAL = 3278/9 MOD 3
ATTRIB   DS    F                       TERMINAL ATTRIBUTES
LASTLNSW DC    CL1'0'                  LAST LINE PROCESSED SWITCH
DSADCB   DS    X                       OP SYS TYPE
DSADCBXA EQU   X'80'                   MVS/XA
STAXSW   DC    CL1'0'                  INTERRUPTED, YES/NO
LINECNT  DC    PL2'0'                  LINE NUMBER ON SCREEN
         SPACE 1
HEXTR    DC    CL16'0123456789ABCDEF'  TRANSLATE HEX TO CHAR
TRTALLOW DC    256XL1'FF'              TRT TABLE/ALLOWABLE CHARS
         ORG   TRTALLOW+C'0'           ALLOW 0-9
         DC    10XL1'00'                 CLEAR CHARS
         ORG
         SPACE 2
         LTORG                         LITERAL POOL
         EJECT
***********************************************************************
*      WORK AREAS FOR THE OBTAIN MACROS                               *
***********************************************************************
         SPACE 1
*--------CATALOG SEARCH MACRO
         DS    0D
DSN      DS    CL44
LOCLIST  CAMLST NAME,DSN,,VOLIST
         DS    0D
VOLIST   DS    256C
         DS    CL16 PROTECT
*--------VTOC DSCB 4 OBTAIN MACRO (VTOC DSCB)
UCBNUM   DS    CL3
DEVTYPE  DS    CL2
VOLSER   DC    CL6' '
OBLIST4  CAMLST SEARCH,DSN,VOLSER,DSCB4LST
         DS    0D
DSCB4LST DS    CL148
         ORG   DSCB4LST
         IECSDSL1 (4)
         ORG
*--------VTOC DSCB 1 OBTAIN MACRO (DATASET HEADER DSCB)
OBLIST1  CAMLST SEEK,VTOCCHHR,VOLSER,DSCB1LST
         DS    0D
DSCB1LST DS    CL148
         ORG   DSCB1LST
         PRINT ON,GEN,NODATA
         IECSDSL1 (1)
         PRINT ON,NOGEN,NODATA
         ORG
*--------VTOC DSCB 2 OBTAIN MACRO (ISAM DSCB)
OBLIST2  CAMLST SEEK,DSCB1LST+91,VOLSER,DSCB2LST
         DS    0D
DSCB2LST DS    CL148
*--------VTOC DSCB 3 OBTAIN MACRO (EXTENSION DSCB)
OBLIST3  CAMLST SEEK,DSCB1LST+91,VOLSER,DSCB3LST
         DS    0D
DSCB3LST DS    CL148
         DS    CL16 PROTECT THE DEVTABLE
         SPACE 3
***********************************************************************
*      WORK AREAS FOR THE VTOC READ ROUTINE                           *
***********************************************************************
         SPACE 1
VOLDSCTK DS    H                       # DSCB'S / TRK IN VTOC
VOLTKCYL DS    H                       TRKS / CYL ON THIS DEVICE
VOLF4CHR DS    CL5                     CCHHR OF START OF VTOC
HICCHHR  DS    CL5                     CCHHR OF LAST DSCB IN VTOC
VTOCCHHR DS    CL5                     WORK AREA FOR OBTAIN SEEK
         EJECT
***********************************************************************
*      WORK AREA FOR UCB SCAN ROUTINE (FROM TSUCBSCN)                 *
***********************************************************************
         SPACE 1
DSXALIST DS    0F                      PARMLIST FOR UCB
DSXAWA   DS    F                       %100-BYTE WORK AREA
DSXADEVT DS    F                       %DEV TYPE TO SEARCH
DSXAUCB  DS    F                       %UCB FULL WORD PTR
         DS    0D                      FOLLOWING MUST BE ALIGNED
DSXAWORK DS    CL100                   UCB WORK AREA
DSXAEUCB EQU   DSXAWORK+00,04          EMULATION CURR. UCB PTR
DSXAEILK EQU   DSXAWORK+04,04          EMULATION CVTILK2 ADDR
DSXACLAS DS    CL1                     DEVICE CLASS TO SEARCH
DSXAUCBP DS    F                       %UCB
******** ***** *********************** END OF UCB LOOKUP DSA
DSAEND   EQU  *                         LENGTH OF WORK
         EJECT
***********************************************************************
*               D E V I C E   N A M E   T A B L E                     *
***********************************************************************
         SPACE 1
DEVTABLE EQU   *
         DC    X'2006'
         DC    X'0008'
         DC    CL6'2305-1'
         DC    X'2007'
         DC    X'0008'
         DC    CL6'2305-2'
         DC    X'2009'
         DC    X'0013'
         DC    CL6'3330  '
         DC    X'200D'
         DC    X'0013'
         DC    CL6'3330-1'
         DC    X'200B'
         DC    X'001E'
         DC    CL6'3350  '
         DC    X'200E'
         DC    X'000F'
         DC    CL6'3380  '
         DC    X'0000'         ** MARKS END OF DEVICE TABLE **
         EJECT
***********************************************************************
*      WORK AREAS FOR 3270 ADDRESS CONVERSION ROUTINES                *
***********************************************************************
         SPACE 1
WORKDBLW DC    D'0'                    HEX/DECIMAL CONVERSION AREA
ROW      DS    CL2                     ROW
COLUMN   DS    CL2                     COLUMN
BUFFADDR DS    XL2                     3270 BUFFER ADDRESS
STARTADR DS    XL2                     3270 BUFFER ADDRESS: STARTING
ENDADDR  DS    XL2                     3270 BUFFER ADDRESS: ENDING
*--> WORK DATA ITEMS FOR 3270 TRANSLATION ROUTINE
R327FLD1 DS    F                       WORK AREA
R327FLD2 DS    F                       WORK AREA
*--> IBM 3270 BASE 64 ENCODING TABLE (IS THERE A ROUTINE SOMEWHERE?)
TABLE327 EQU   *
         DC    X'40C1C2C3C4C5C6C7C8C94A4B4C4D4E4F'
         DC    X'50D1D2D3D4D5D6D7D8D95A5B5C5D5E5F'
         DC    X'6061E2E3E4E5E6E7E8E96A6B6C6D6E6F'
         DC    X'F0F1F2F3F4F5F6F7F8F97A7B7C7D7E7F'
         EJECT
*--> THE FOLLOWING ARE USED BY THE 'FULLSCR' ROUTINE
CLSCREEN DC    XL12'C11140403C4040001140C113'
SCPREFIX DC    XL11'C11140403C404000114040'
         SPACE 1
ALISTPTR DC    A(0)                    PTR TO ACTIVE ATTR LIST
ASCRNPTR DC    A(0)                    PTR TO ACTIVE INPUT SCREEN
ASCRNSIZ DC    F'0'                    SIZE OF THE SCREEN INPUT
ASUFXPTR DC    A(0)                    LENGTH/PTR TO SUFFIX
         SPACE 1
ATRLST1B DS    0F
         DC    A(ATRLST1E)             END OF THIS LIST
         DC    AL1(ATR@PH)             PROTECT-HIGH / WHITE
         DC    AL3(SC1LN01+00)         FIRST BYTE OF SCREEN
         DC    AL1(ATR@PL)             PROTECT-LOW  / BLUE
         DC    AL3(SC1LN02+00)         FIRST BYTE OF SECOND LINE
         DC    AL1(ATR@PL)             PROTECT-LOW  / BLUE
         DC    AL3(SC1LN04+00)         FIRST BYTE OF FIFTH LINE
         DC    AL1(ATR@PL)             PROTECT-LOW  / BLUE
         DC    AL3(SC1LN24+00)         BEGINNING OF LAST LINE
         DC    AL1(ATR@PH)             PROTECT-HIGH / WHITE
         DC    AL3(SC1LN24+22)         BEGINNING OF PFK LIST
         DC    AL1(ATR@PL)             PROTECT-LOW  / BLUE
         DC    AL3(SC1LN24+56)         END OF PFK LIST
ATRLST1E EQU   *
         SPACE 1
ATR@PL   EQU   X'E4'                   PROTECT-LOW  / BLUE
ATR@PH   EQU   X'E8'                   PROTECT-HIGH / WHITE
ATR@UL   EQU   X'C4'                   UNPROT-LOW   / GREEN
ATR@UH   EQU   X'C8'                   UNPROT-HIGH  / RED
         EJECT
***********************************************************************
*  EXTENDED COLOR FIELDS FOR FULL CAPABILITY SCREENS                  *
***********************************************************************
         SPACE 1
SC1COLOR EQU   *
         DC    XL1'F1'                 WRITE COMMAND
         DC    XL1'C2'                 WCC - RELEASE KEYBOARD
*--> BACK-LIGHT THE TITLE LINE
         DC    XL16'1140C82903C0F841F442F311C1C71DE8'
*--> REVERSE VIDEO THE TITLE BLOCKS
         DC    XL16'11C2602903C0F841F242F111C36F1DE8'
*--> SET UP THE VOLSER
         DC    XL5'11C1C81DE4'
SC1VOLSR DC    CL6'XXXXXX'
         DC    XL16'11C1C82903C0F8410042F611C14F1DE8'
*--> SET UP THE DEVICE TYPE
         DC    XL5'1140401DE4'
SC1DNAME DC    CL6'XXXXXX'
         DC    XL16'1140402903C0F8410042F61140C71DE8'
ESC1CLR  EQU   *
LSC1CLR  EQU   ESC1CLR-SC1COLOR
         EJECT
***********************************************************************
*  THIS IS THE MAIN SCREEN                                            *
***********************************************************************
         SPACE 1
SCREEN1  EQU   *
SC1LN01  DC    CL40'                          T S O   V T O '
         DC    CL40'C   L I S T                             '
SC1LN02  DC    CL40' ---------------------------------------'
         DC    CL40'--------------------------------------- '
SC1LN03  DC    CL40' NUM  DATASET NAME                   ORG'
         DC    CL40'  RFM  LRECL  BLKSIZ  DSCB/CCHHR  RACF  '
SC1LN04  DC    CL40'                                        '
         DC    CL40'                                        '
SC1LN05  DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
SC1LN24  DC    CL40' --------------------   PF3=END  PF7=BAC'
         DC    CL40'K  PF8=FORWARD   ---------------------- '
SC1SUFIX DC    XL4'115DC813'
         SPACE 1
SCRBLD   DS    CL4096                  BUILD AREA FOR FINAL SCREEN
         EJECT
***********************************************************************
*  INTERRUPTION EXIT ROUTINE ---- STAX SERVICE ROUTINE                *
***********************************************************************
         SPACE 2
ATTNRTN  CSECT
         STM   R14,R12,12(R13)         SAVE CALLERS REGISTERS
         BALR  R12,R0                  SET UP BASE REGISTER
         DROP  R12                     DROP OLD BASE REGISTER
         USING *,R12                   SET UP NEW BASE REGISTER
         ST    R13,STAXSAVE+4          SAVEAREA BACKWARD PTR
         LA    R11,STAXSAVE            PICK UP OUR SAVEAREA ADDR
         ST    R11,8(R13)              SAVEAREA FORWARD PTR
         LR    R13,R11                 ESTABLISH NEW S/A PTR
         SPACE 1
         L     R3,STAXSWAD             GET ADDR OF SWITCH ADDR
         MVI   0(R3),C'1'              TURN SWITCH ON
         SPACE 1
         L     R13,STAXSAVE+4          PICK UP OLD S/A ADDR
         LM    R14,R12,12(R13)         RESTORE CALLERS REGISTERS
         LA    R15,0                   SET RC=0
         BR    R14                     RETURN TO CALLER
         SPACE 1
STAXSWAD DC    A(STAXSW)               ADDR OF INTERRUPT SWITCH
STAXSAVE DS    18F                     SAVE AREA FOR INTERRUPT RTN
         EJECT
***********************************************************************
*                     D S E C T S                                     *
***********************************************************************
         SPACE 2
         PRINT ON,NOGEN,NODATA
EXTRAREA DSECT
EALINENO DS    PL2                     LINE NUMBER (GENERATED)
EADSN    DS    CL44                    DSNAME
EALRECL  DS    CL2                     LRECL
EABLKSIZ DS    CL2                     BLKSIZE
EARKPOFF DS    CL2                     RKP (OFFSET)
EARECFM  DS    CL4                     RECFM
EADSORG  DS    CL2                     DSORG
EAKEYLEN DS    CL1                     KEYLEN
EADSCB   DS    CL5                     CCHHR OF DSCB
EARACF   DS    CL4                     RACF DEFINED?
EXTRLNTH EQU   *-EXTRAREA              LENGTH OF ENTRY
         SPACE 2
SCRNLINE DSECT
         DS    CL1
SCLINENO DS    CL3                     LINE NUMBER
         DS    CL2
SCDSN    DS    CL30                    DSNAME
         DS    CL2
SCDSORG  DS    CL2                     DATASET ORGANIZATION
         DS    CL2
SCRECFM  DS    CL3                     RECORD FORMAT
SCLRECL  DS    CL7                     LRECL
         DS    CL1
SCBLKSIZ DS    CL7                     BLKSIZE
         DS    CL2
SCDSCB   DS    CL10                    CCHHR OF DSCB
         DS    CL2
SCRACF   DS    CL4                     RACF?
         DS    CL2
         SPACE 2
         PRINT ON,NOGEN
         IEFUCBOB ,                    UCB
         CVT   DSECT=YES               CVT
         END   LISTVTOC
