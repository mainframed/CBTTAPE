         MACRO
         PGPB  &J,&DSECT=YES
         AIF   ('&DSECT' NE 'YES').L1
PGPB     DSECT
         AGO   .L2
.L1      ANOP
PGPB     DS    0F
.L2      ANOP
         SPACE 1
***********************************************************************
*    THE PUTGET PARAMETER BLOCK (PGPB) IS POINTED TO BY THE LIST      *
*    PASSED TO PUTGET. PUTGET USES IT FOR CONTROL AS WELL AS          *
*    RETURNING INFORMATION.                                           *
***********************************************************************
         SPACE 1
         DS    0F
         DS    CL12 .              INTERNAL TO GETLINE/PUTLINE
PGPBIBUF DS    A .                 PTR TO OBTAINED INPUT LINE
         MEND
         MACRO
         TSDMPL
         SPACE 1
***********************************************************************
*                                                                     *
*        (DMPL)    DAIR MESSAGE PARAMETER LIST.                       *
*                                                                     *
*        FUNCTION  THE ADDRESS OF THIS PARAMETER LIST IS PASSED IN    *
*                  REGISTER 1 BY THE INVOKER OF IKJEFF18 TO DIAGNOSE  *
*                  DAIR ERRORS AND PRINT APPROPRIATE MESSAGES.        *
*                                                                     *
***********************************************************************
         SPACE 1
DMPL     DS    0F .                DAIR MESSAGE PARAMETER LIST
DMPLDAPL DS    A .                 PTR TO THE DAPL ADDRESS
DMPLRC   DS    A .                 PTR TO THE DAIR RETURN CODE
DMPLMSG  DS    A .                 PTR TO A(IKJEFT02) IF LOADED
DMPLCALL DS    A .                 PTR TO THE CALLER NUMBER
DMPLCODE DS    0F .                R15 SAVE IS DAIR RETURN CODE
DMPLSAVE DS    3F .                REGISTER SAVEAREA FOR 15-1
DMPLL    EQU   *-DMPL .            LENGTH OF THE DMPL
         SPACE 1
         MEND
         MACRO
&LBL     TSDAIR &Z,&DAPB=,&SYNAD=,&ENTRY=
         GBLB   &TSDAIRE           WAS TSDAIRER ROUTINE GENERATED
&LBL     OACINNER  F=&DAPB,T=DAPLDAPB,OP=MA,COM='DAPB ADDR'
         LA    R1,DAPL
         AIF   ('&ENTRY' EQ '').NOENT
         $RXR  ,&ENTRY,15,A=       FROM REGISTER OR FULLWORD
         BALR  R14,R15
         AGO   .NOLINK
.NOENT   LINK  EP=IKJDAIR
.NOLINK  AIF   ('&SYNAD' EQ '').L1
         LTR   R15,R15
         BZ    TSD&SYSNDX+4
         LA    R0,&SYNAD
         L     R14,TSD&SYSNDX
         BR    R14
         AIF   ('&SYNAD' EQ '').L0
         AIF   (&TSDAIRE).L0
         TSDAIRER
.L0      ANOP
TSD&SYSNDX DC  A(TSDAIRER)
.L1      MEND
         MACRO
         $RXQ  &TARGET,&SEND,&LEN
         GBLB  &OMITTED
&OMITTED SETB  0
         AIF   ('&SEND' EQ '' ).NOSEND
         AIF   ('&SEND'(1,1) EQ '(').REGSEND
         AIF   ('&SEND'(1,1) EQ '''').QSEND
         MVC   &TARGET,&SEND
         AGO   .END
.REGSEND MVC   &TARGET,0&SEND
         AGO   .END
.QSEND   MVC   &TARGET,=CL&LEN&SEND
         AGO   .END
.NOSEND  MVC   &TARGET,=CL&LEN' '  NOT SPECIFIED
&OMITTED SETB  1                   OPERAND WAS OMMITTED
.END     ANOP
         MEND
         MACRO
         $MF   &MAP,&REG,&MF,&FAKE1,&SP=
.******* &MAP=MAPPING DSECT NAME
.******* &REG=REGISTER FOR ADDRESSIBILITY
.******* &MF=(L|B|E,AREA)
         GBLB  &OMITTED,&DROP
         LCLC  &AREA
&OMITTED SETB  0
&DROP    SETB  0                   DO NOT DROP REGISTER
         AIF   ('&MF' NE '').MFYES
&OMITTED SETB  1                   PARAMETER WAS OMMITTED
.MFYES   ANOP
&AREA    SETC  'DAPBAREA'
         AIF   ('&MF(2)' EQ '').USEAREA
&AREA    SETC  '&MF(2)'
.USEAREA AIF   ('&MF(1)' EQ 'E' OR '&MF(1)' EQ '').MF1OK
         AIF   ('&MF(1)' EQ 'B').MF1OK
         AIF   ('&MF(1)' EQ 'L').MF1OK
         MNOTE 4,'MF=&MF(1) IS AN INVALID TYPE, MF=E ASSUMED'
.MF1OK   $RXR   ,&AREA,&REG        MF=(L|B|E,AREA)
         USING  &MAP,&REG          ADDRESSIBILITY
&DROP    SETB  1                   DROP REGISTER
         MEND
         MACRO
&LABEL   FREE  &DDNAME=,&DSN=,&MEMBER=,&PREFIX=NO,                     X
               &FILE=,&DATASET=,                                       X
               &SYSOUT=,                                               X
               &JOBNAME=,                                              X
               &DISP=,&PERM=YES,                                       X
               &MF=,&SYNAD=
         GBLB  &OMITTED,&DROP
         LCLA  &PERMBIT
&PERMBIT SETA  0                   PERM = X'10'
         AIF   ('&PERM' NE 'YES').NOTPERM
&PERMBIT SETA  16                  =X'10'
.NOTPERM ANOP
&LABEL   DS    0H
         $MF   DAPB18,R15,&MF
         XC    DAPB18(DAPB18L),DAPB18   INITIALIZE DAIR BLOCK TO ZERO
         MVI   DA18CD+1,X'18'           DAIR ENTRY CODE FOR FREE
         $RXR  DA18PDSN,&DSN&DATASET,0  POINTER TO DSNAME
         $RXQ  DA18DDN,&DDNAME&FILE,8   DDNAME
         $RXQ  DA18JBNM,&JOBNAME,8      JOBNAME
         $RXQ  DA18SCLS,&SYSOUT,2       SYSOUT CLASS
         AIF   (&OMITTED).MEM
         MVI   DA18SCLS+1,C' '          BLANK 2ND BYTE OF OUTPUT CLASS
.MEM     $RXQ  DA18MNM,&MEMBER,8        MEMBER NAME
         AIF   ('&PREFIX' NE  'YES').NOPREF
         OI    DA18CTL,DA18UID+&PERMBIT PREFIX CHARGENO.USERID TO DSN
         AGO   .DISPOS
.NOPREF  AIF   ('&PERM' NE 'YES').DISPOS FREE PERM DATASET?
         OI    DA18CTL,&PERMBIT         FREE PERMANENTLY ALLOCATED DS
.DISPOS  AIF   (T'&DISP    EQ 'O').NODISP2
         AIF   ('&DISP'    NE 'KEEP').DELETE2
         MVI   DA18DPS2,DA18KEEP        DISP=(,KEEP)
         AGO   .DISP3
.DELETE2 AIF   ('&DISP'    NE 'DELETE').CATLG2
         MVI   DA18DPS2,DA18DEL         DISP=(,DELETE)
         AGO   .DISP3
.CATLG2  AIF   ('&DISP'    NE 'CATLG').UNCAT2
         MVI   DA18DPS2,DA18CAT         DISP=(,CATLG)
         AGO   .DISP3
.UNCAT2  AIF   ('&DISP'    NE 'UNCATLG').DISPBAD
         MVI   DA18DPS2,DA18UCAT        DISP=(,UNCATLG)
         AGO   .DISP3
.NODISP2 ANOP
*        DISPOSITION SPECIFIED WHEN ALLOCATED WILL BE USED.
         AGO   .DISP3
.DISPBAD ANOP
         MNOTE *,'*****************************************'
         MNOTE 12,'-- INVALID DISPOSITON, DISP= &DISP  '
         MNOTE *,'*****************************************'
         AGO   .END
.DISP3   AIF   ('&MF(1)' EQ 'B').ENDB
         AIF   ('&MF(1)' EQ 'L').END
         TSDAIR DAPB=(15),SYNAD=&SYNAD
         AGO   .END
.ENDB    ST    R15,DAPLDAPB
         LA    R1,DAPL
.END     AIF    (NOT &DROP).END1
         DROP  R15                 DROP ADDRESSIBLITY TO DAIR BLOCK
.END1    SPACE 1
         MEND
         MACRO
&NAME    TPUTX &BFF,&SIZE,&EDIT,&WAIT,&HOLD,&BRKI,&PRTY,&TJID=,        X
               &TJIDLOC=,&MF=I
         GBLA  &GETLENL
         GBLC  &$NFS
         LCLA  &K,&I,&BITS
         LCLA  &N,&MAXLEN
         LCLB  &ED,&WA,&HO,&BR,&PR
&$NFS    SETC  '&NAME'
&K       SETA  3                        NORMAL PLACE TO START SCAN
         AIF   ('&BFF' NE '').HAVEBFF
         MNOTE 8,'*** MESSAGE OR MESSAGE ADDR OMITTED.'
         MEXIT
.HAVEBFF AIF   ('&BFF'(1,1) NE '''').NOTQ
&K       SETA  K'&BFF-2                 LENGTH OF CHAR STRING
&N       SETA  2                        START AT FIRST TEXT CHAR
&MAXLEN  SETA  &K                       SET LENGTH OF CHAR STRING
.QLOOP   AIF   ('&BFF'(&N,2) NE '''''' AND '&BFF'(&N,2) NE '&&').QCONT
&K       SETA  &K-1                     ACCOUNT FOR DBLE CHAR
&N       SETA  &N+1                     FUDGE PAST
.QCONT   ANOP
&N       SETA  &N+1
         AIF   (&N LE &MAXLEN).QLOOP
&$NFS    LA    R0,&K                    GET STRING LENGTH
&$NFS    SETC  ''                       NAME FIELD SYMBOL DONE
         LA    R1,=C&BFF
&K       SETA  2                        ONLY ONE OPERAND FOR STRING
         AGO   .GOTPTRS
.NOTQ    ANOP
&$NFS    $RXR  ,&BFF,1                  LOAD BUFFER PTR
         $RXR  ,&SIZE,0                 LOAD BUFFER LENGTH
.GOTPTRS AIF   ('&TJID' EQ '' AND '&TJIDLOC' EQ '').NOTJID
         AIF   ('&TJID' EQ '').LOADTJ
&$NFS    $RXR  ,&TJID,14                GET TJID
         AGO   .ORTJ
.LOADTJ  ANOP
&$NFS    $RXR  ,&TJIDLOC,15             INDIRECT TJID
         LH    R15,0(,R15)              LOAD TJID
.ORTJ    SLL   R15,16                   TJID INTO TOP HALF
         OR    R0,R15                   ADD TO PARM REG 0
.NOTJID  ANOP
&I       SETA  &K                       FIRST OPERAND TO CHECK
.LOOP    AIF   (&I GT N'&SYSLIST).SETOP IF ALL ARE PROCESSED, JUMP OUT
         AIF   ('&SYSLIST(&I)' EQ 'EDIT').EDIT
         AIF   ('&SYSLIST(&I)' EQ 'ASIS').ASIS
         AIF   ('&SYSLIST(&I)' EQ 'CONTROL').CONTROL
         AIF   ('&SYSLIST(&I)' EQ 'FULLSCR').FULLS
         AIF   ('&SYSLIST(&I)' EQ 'WAIT').WAIT
         AIF   ('&SYSLIST(&I)' EQ 'NOWAIT').NOWAIT
         AIF   ('&SYSLIST(&I)' EQ 'NOHOLD').NOHOLD
         AIF   ('&SYSLIST(&I)' EQ 'HOLD').HOLD
         AIF   ('&SYSLIST(&I)' EQ 'NOBREAK').NOBREAK
         AIF   ('&SYSLIST(&I)' EQ 'BREAKIN').BREAKIN
         AIF   ('&SYSLIST(&I)' EQ 'HIGHP').HIGHP
         AIF   ('&SYSLIST(&I)' EQ 'LOWP').LOWP
         AIF   ('&SYSLIST(&I)' EQ 'R').NEXTI
         AIF   ('&SYSLIST(&I)'(1,4) EQ 'TJID').SETOP
         MNOTE 8,'INVALID OPTION &SYSLIST(&I) - IGNORED'
.NEXTI   ANOP
&I       SETA  &I+1                     INCREMENT COUNTER
         AGO   .LOOP                    GET NEXT OPTION IF ANY
.MUTEX   MNOTE 8,'MUTUALLY EXCLUSIVE KEYWORDS'
         AGO   .NEXTI
.FULLS   ANOP
&BITS    SETA  &BITS+3                  SET ASIS+CONTROL FOR FULL SCRN
         AGO   .EDIT                    MAKE IT MUTUALLY EXCLUSIVE
.ASIS    ANOP
&BITS    SETA  &BITS+1                  SET ASIS OPTION
         AGO   .EDIT                    MAKE IT MUTUALLY EXCLUSIVE
.CONTROL ANOP
&BITS    SETA  &BITS+2                  SET CONTROL OPTION
.EDIT    AIF   (&ED).MUTEX
&ED      SETB  1                        EDIT,ASIS OR CONTROL SET
         AGO   .NEXTI
.NOWAIT  ANOP
&BITS    SETA  &BITS+16                 SET NOWAIT OPTION
.WAIT    AIF   (&WA).MUTEX
&WA      SETB  1                        WAIT OR NOWAIT SET
         AGO   .NEXTI
.HOLD    ANOP
&BITS    SETA  &BITS+8                  SET HOLD OPTION
.NOHOLD  AIF   (&HO).MUTEX
&HO      SETB  1                        HOLD OR NOHOLD SET
         AGO   .NEXTI
.BREAKIN ANOP
&BITS    SETA  &BITS+4                  SET BREAKIN OPTION
.NOBREAK AIF   (&BR).MUTEX
&BR      SETB  1                        BREAKIN OR NOBREAK SET
         AGO   .NEXTI
.LOWP    ANOP
&BITS    SETA  &BITS+X'20'              FORCE LOW PRTY (EVEN IF KEY0)
.HIGHP   AIF   (&PR).MUTEX
&PR      SETB  1                        HIGHP OR LOWP SET
         AGO   .NEXTI
.SETOP   AIF   ('&BFF'(1,1) NE '(').NOTREG I MUST HAVE DONE LA
&$NFS    LA    R1,0(,R1)                MAKE HIGH BYTE 0
.NOTREG  AIF   (&BITS EQ 0).CALL
         LA    R15,&BITS                GET OPTIONS
         SLL   R15,24                   SHIFT TO TOP BYTE
         OR    R1,R15                   OR IN OPTIONS
.CALL    AIF   ('&MF' EQ 'I' OR '&MF' EQ 'B').CHK2
         MNOTE 4,'*** INVALID MF OPTION'
         MEXIT
.CHK2    AIF   ('&MF' EQ 'I').CALLIT
         MEXIT
.CALLIT  SVC   93                       ISSUE TPUT SVC
         MEND
         MACRO
&LBL     TSPARSE &Z,&PCL=,&CBUF=,&USER=,&SYNAD=,&ENTRY=,&MF=I
         GBLC  &$NFS
         LCLC  &IHBNX
&IHBNX   SETC  'IHB&SYSNDX'
&$NFS    SETC  '&LBL'
         AIF  (('&MF' NE 'I') AND ('&MF' NE 'E') AND ('&MF' NE 'L')).E1
        AIF (('&MF' EQ 'I') AND (('&PCL' EQ '') OR ('&CBUF' EQ ''))).E2
&$NFS    OACINNER F=&PCL,T=PPLPCL,OP=MA,COM='MOVE IN PCL ADDR'
&$NFS    OACINNER F=&CBUF,T=PPLCBUF,OP=MA,COM='MOVE IN CBUF ADDR'
&$NFS    OACINNER F=&USER,T=PPLUWA,OP=MA,COM='MOVE IN UWA ADDR'
         AIF   ('&MF' EQ 'L').DONE
&$NFS    LA    R1,PPL
&$NFS    SETC  ''
         AIF   ('&ENTRY' EQ '').NOENT
         $RXR  ,&ENTRY,15,A=            FROM REGISTER OR FULLWORD
         BALR  R14,R15
         AGO   .NOLINK
.NOENT   LINK  EP=IKJPARS
.NOLINK  AIF   ('&SYNAD' EQ '').DONE
         LTR   R15,R15
         BZ    &IHBNX+4
         LA    R0,&SYNAD
         L     R14,&IHBNX
         BR    R14
&IHBNX   DC    A(TSPARERR)
.DONE    AIF   ('&$NFS' EQ '').MEND
&$NFS    DS    0H                       DEFINE NAME
.MEND    MEXIT
.E1      MNOTE 12,'MF=&MF IS INVALID'
         AGO   .DONE
.E2      MNOTE 12,'PCL= AND CBUF= REQUIRED WITH MF=I'
         AGO   .DONE
         MEND
         MACRO
&LABEL   TSFIND &TYPE,&REG,&RG2
         LCLA   &KEY
&LABEL   L     &REG,CVTPTR              ADDRESS OF CVT
         USING CVT,&REG
         AIF   ('&TYPE' EQ 'CVT').END
         AIF   ('&REG' NE '0' AND '&REG' NE 'R0').CONT
.REG0    MNOTE 8,'REGISTER 0 IS NOT A VALID REGISTER'
         AGO   .END
.CONT    AIF   ('&TYPE' EQ 'TSCVT').TSCVT
         AIF   ('&TYPE' EQ 'TJB').TJB
         AIF   ('&TYPE' EQ 'TSB').TJB
         AIF   ('&TYPE' EQ 'TJBX').TJB
         AIF   ('&TYPE' EQ 'DSE').TJB
         AIF   ('&TYPE' EQ 'TJBL').TJBL
         AIF   ('&TYPE' EQ 'TJBTABLE').TJBTAB
         L     &REG,CVTTCBP             OLD/CURRENT
         DROP  &REG
         L     &REG,4(,&REG)            CURRENT TCB
         USING TCB,&REG
         AIF   ('&TYPE' EQ 'TCB').END
         AIF   ('&TYPE' EQ 'TCBFSA').TCBFSA
         AIF   ('&TYPE' EQ 'TIOT').TIOT
         AIF   ('&TYPE' EQ 'TJID').TJID
         AIF   ('&TYPE' EQ 'JSCB').JSCB
         AIF   ('&TYPE' EQ 'PBE').PSCB
         AIF   ('&TYPE' EQ 'PSCB').PSCB
         AIF   ('&TYPE' EQ 'UPT').PSCB
         AIF   ('&TYPE' EQ 'TAT').TAT
         AIF   ('&TYPE' EQ 'CCNUID').CCNUID
         DROP  &REG
         MNOTE 8,' &TYPE IS UNSUPPORTED'
         AGO   .END
.TIOT    L     &REG,TCBTIO              TCB.TIOT
         AGO   .END
.TCBFSA  L     &REG,TCBFSA              TCB.FSA
         AGO   .END
.JSCB    L     &REG,TCBJSCB             TCB.JSCB
         AGO   .END
.PSCB    L     &REG,TCBJSCB             TCB.JSCB
         DROP  &REG
         USING IEZJSCB,&REG
         L     &REG,JSCBPSCB            JSCB.PSCB
         AIF   ('&TYPE' EQ 'PSCB').END
         DROP  &REG
         USING PSCB,&REG
         AIF   ('&TYPE' EQ 'UPT').UPT
         L     &REG,PSCBU               PSCB.PBE
         AGO   .END
.UPT     L     &REG,PSCBUPT             PSCB.UPT
         AGO   .END
.TJID    L     &REG,TCBJSCB             TCB.JSCB
         DROP  &REG
         USING IEZJSCB,&REG
         LH    &REG,JSCBTJID            JSCB.TJID
         AGO   .END
.TSCVT   L     &REG,228(,&REG)          CVT.TSCVT
         AGO   .END
.TJBL    L     &REG,228(,&REG)          CVT.TSCVT
         LH    &REG,26(,&REG)           TSCVT.SZU
         AGO   .END
.TJBTAB  L     &REG,228(,&REG)          CVT.TSCVT
         L     &REG,0(,&REG)            TSCVT.TJB (TABLE BEGINNING)
         AGO   .END
.TJB     AIF   ('&RG2' NE '').TJB1
         MNOTE 8,'2ND REGISTER NOT SPECIFIED'
         AGO   .END
.TJB1    AIF   ('&RG2' NE '&REG').TJB2
.REQ     MNOTE 8,'2ND REGISTER EQUAL 1ST REGISTER'
         AGO   .END
.TJB2    AIF   ('&RG2' EQ '0' OR  '&RG2' EQ 'R0').REG0
         L     &RG2,CVTTCBP             OLD/CURRENT
         L     &RG2,4(,&RG2)            CURRENT TCB
         USING TCB,&RG2
         L     &RG2,TCBJSCB             TCB.JSCB
         DROP  &RG2
         USING IEZJSCB,&RG2
         LH    &RG2,JSCBTJID            JSCB.TJID
         DROP  &RG2
         L     &REG,228(,&REG)          CVT.TSCVT
         MH    &RG2,26(,&REG)           TSCVT.SZU
         L     &REG,0(,&REG)            TSCVT.TJB
         AIF   ('&TYPE' EQ 'TJBX').TJBX
         AIF   ('&TYPE' EQ 'TSB').TSB
         AIF   ('&TYPE' EQ 'DSE').DSE
         LA    &REG,0(&RG2,&REG)        USER'S TJB
         AGO   .END
.TJBX    L     &REG,8(&RG2,&REG)        TJB.TJBX
         AGO   .END
.TSB     L     &REG,0(&RG2,&REG)        TJB.TSB
         AGO   .END
.DSE     L     &REG,8(&RG2,&REG)        TJB.TJBX
         L     &REG,8(&REG)             TJBX.DSE
         AGO   .END
.TAT     ANOP
&KEY     SETA  1                        SEARCH FOR TAT
         AGO   .TAT1
.CCNUID  ANOP
&KEY     SETA  5                        SEARCH FOR CCNUID
.TAT1    AIF   ('&RG2' NE '').TAT2
         MNOTE 8,'2ND REGISTER NOT SPECIFIED'
         MEXIT
.TAT2    AIF   ('&RG2' EQ '&REG').REQ
         AIF   ('&RG2' EQ '0' OR  '&RG2' EQ 'R0').REG0
L&SYSNDX L     &RG2,TCBUSER             TCB.USER
L1&SYSNDX LA   &RG2,0(,&RG2)            CLEAR HIGH ORDER BYTE
         LTR   &RG2,&RG2                END TCB.USER CHAIN ?
         BZ    L2&SYSNDX                YES
         CLI   0(&RG2),&KEY             THE BLOCK WERE LOOKING FOR ?
         BE    LF&SYSNDX                YES
         L     &RG2,0(,&RG2)            STEP DOWN CHAIN
         B     L1&SYSNDX                SAME CHECKS ON THIS
L2&SYSNDX L    &REG,TCBOTC              TCB.OTC
         LTR   &REG,&REG                HIGHER TCB PRESENT ?
         BZ    LF&SYSNDX                NO, REG=0 INDICATES NOT FOUND
         TM    TCBTSFLG,TCBTSTSK        TCB.TSFLG = TCB.TSTSK
         BO    L&SYSNDX
LF&SYSNDX LTR  &REG,&RG2                TO RESULT REGISTER
         MNOTE *,'&REG =ADDRESS OF &TYPE OR 0, CC HAS BEEN SET'
.END     DROP  &REG
         MEND
         MACRO
         TSIOPL
         SPACE 1
***********************************************************************
*        THE I/O SERVICE ROUTINE PARAMETER LIST (IOPL) IS A LIST OF   *
*        FULLWORD ADDRESSES PASSED BY THE INVOKER OF ANY I/O SERVICE  *
*        ROUTINE TO THE APPROPRIATE SERVICE ROUTINE VIA REGISTER ONE. *
***********************************************************************
         SPACE 1
IOPL     DS    0A
IOPLUPT  DS    A .                      PTR TO UPT
IOPLECT  DS    A .                      PTR TO ECT
IOPLECB  DS    A .                      PTR TO USER'S ECB
IOPLIOPB DS    A .                      PTR TO THE I/O SRV RTN PARM BLK
IOPLL    EQU   *-IOPL
         SPACE 1
         MEND
         MACRO
         TSDAPL
         SPACE 1
***********************************************************************
*        THE DYNAMIC ALLOCATION INTERFACE ROUTINE (DAIR) PARAMETER    *
*        LIST (DAPL) IS A LIST OF ADDRESSES PASSED FROM THE INVOKER   *
*        TO DAIR VIA REGISTER 1.                                      *
***********************************************************************
         SPACE 1
DAPL     DS    0F
DAPLUPT  DS    A .                      PTR TO UPT
DAPLECT  DS    A .                      PTR TO ECT
DAPLECB  DS    A .                      PTR TO CP'S ECB
DAPLPSCB DS    A .                      PTR TO PSCB
DAPLDAPB DS    A .                      PTR TO DAIR PARAMETER BLOCK
DAPLL    EQU   *-DAPL
         SPACE 1
         MEND
         MACRO
         TSPPL
         SPACE 1
***********************************************************************
*        THE PARSE PARAMETER LIST (PPL) IS A LIST OF ADDRESSES        *
*        PASSED FROM THE INVOKER TO PARSE VIA REGISTER 1.             *
***********************************************************************
         SPACE 1
PPL      DS    0A
PPLUPT   DS    A .                      PTR TO UPT
PPLECT   DS    A .                      PTR TO ECT
PPLECB   DS    A .                      PTR TO CP'S ECB
PPLPCL   DS    A .                      PTR TO PCL
PPLANS   DS    A .                      PTR TO ANS PLACE
PPLCBUF  DS    A .                      PTR TO CMD BUFFER
PPLUWA   DS    A .                      PTR TO USER WORK AREA
*                                       (FOR VALIDITY CHECK ROUTINES)
PPLL     EQU   *-PPL
TSPARANS DS    F .                      PARSE RETURNS PTR TO PDL HERE
         SPACE 1
         MEND
         MACRO
         TSCPPL
         SPACE 1
***********************************************************************
*        THE COMMAND PROCESSOR PARAMETER LIST (CPPL) IS A LIST OF     *
*        ADDRESSES PASSED FROM THE TMP TO THE CP VIA REGISTER 1.      *
***********************************************************************
         SPACE 1
CPPL     DS    0A
CPPLCBUF DS    A .                      PTR TO COMMAND BUFFER
CPPLUPT  DS    A .                      PTR TO UPT
CPPLPSCB DS    A .                      PTR TO PSCB
CPPLECT  DS    A .                      PTR TO ECT
CPPLL    EQU   *-CPPL
         SPACE 1
         MEND
         MACRO
         $$ASM &M=(JAN,FEB,MAR,APR,MAY,JUN,JUL,AUG,SEP,OCT,NOV,DEC)
         GBLC  &$$DATE1,&$$DATE2,&$$ASM
         GBLC  &$$MM,&$$DD,&$$YY
         GBLC  &$$MONTH,&$$DAY,&$$YEAR
         LCLC  &D
         LCLA  &I
&D       SETC  '&SYSDATE'
         AIF   ('&D'(3,1) EQ '/').D1
&$$ASM   SETC  'G'
&$$YY    SETC  '&D'(1,2)                GET YEAR YY
&$$MONTH SETC  '&D'(3,3)                GET MONTH MMM
         AIF   (K'&D EQ 6).D2
&$$DD    SETC  '&D'(6,2)                GET DAY DD
         AGO   .D3
.D2      ANOP
&$$DD    SETC  '0'.'&D'(6,1)            GET DAY 0D
.D3      ANOP
&$$DATE1 SETC  '&$$DD&$$MONTH&$$YY'     SET DDMMMYY
.D3A     ANOP
&I       SETA  &I+1
         AIF   ('&$$MONTH' NE '&M(&I)').D3A  FIND MONTH NAME
&$$MM    SETC  '&I'
         AIF   (&I GT 9).D4
&$$MM    SETC  '0&I'
.D4      ANOP
&$$DATE2 SETC  '&$$MM/&$$DD/&$$YY'      SET MM/DD/YY
         AGO   .COMMON
.D1      ANOP
&$$DATE2 SETC  '&D'                     SET MM/DD/YY
&$$MM    SETC  '&D'(1,2)                GET MM
&$$DD    SETC  '&D'(4,2)                GET DD
&$$YY    SETC  '&D'(7,2)                GET YY
&$$MONTH SETC  '&M(&$$MM)'              GET MONTH MMM
&$$DATE1 SETC  '&$$DD&$$MONTH&$$YY'
&D       SETC  'ABCDEFGHI'
         AIF   (K'&D EQ 8).D5           ASMF OR SPASM
&$$ASM   SETC  'H'
         AGO   .COMMON
.D5      AIF   (K'&SYSTIME GT 5).D6
&$$ASM   SETC  'F'
         MEXIT
.D6      ANOP
&$$ASM   SETC  'S'
.COMMON  ANOP
&$$YEAR  SETC  '19&$$YY'                GET 19YY
         MEND
         MACRO
&NFS     $RXR  &TARGET,&SEND,&REG,&H,&A=A
         GBLB  &OMITTED
         GBLC  &$NFS
&OMITTED SETB  0
         AIF   ('&SEND' EQ '' ).NOSEND  NO SOURCE FIELD
         AIF   ('&SEND'(1,1) EQ '(').REGSEND SOURCE IS A REGISTER
&NFS     L&A   &REG,&SEND
&$NFS    SETC  ''
         AIF   ('&TARGET' EQ '').END    LEAVE IN REGISTER
         ST&H  &REG,&TARGET
         AGO   .END
.REGSEND AIF   ('&TARGET' NE '').RSTORE
         AIF   ('&SEND(1)' EQ '&REG').END
&NFS     LR    &REG,&SEND(1)
&$NFS    SETC  ''
         AGO   .END
.RSTORE  ANOP
&NFS     ST&H  &SEND(1),&TARGET
&$NFS    SETC  ''
         AGO   .END
.NOSEND  ANOP
&OMITTED SETB  1                        OPERAND WAS OMITTED
.END     MEND
         MACRO
&LBL     MSG   &C
         LCLA  &A
&A       SETA  K'&C
&A       SETA  &A-2
&LBL     DC    AL1(&A),CL&A.&C
         MEND
         MACRO
         REGEQU  &F=,&FR=,&PREFIX=R,&STARS=YES
         GBLC  &$REGS$(15),&R,&FF
         LCLA  &X
&R       SETC  '&PREFIX'
.RLOOP   ANOP
&X       SETA  &X+1
         AIF   (&X GT 15).GEN
         AIF   ('&$REGS$(&X)' EQ '').GEN
         AIF   ('&R' EQ '&$REGS$(&X)').NOGEN
         AGO   .RLOOP
.GEN     ANOP
&$REGS$(&X) SETC '&R'
         AIF   ('&STARS' NE 'YES').NOSTAR1
***********************************************************************
.NOSTAR1 ANOP
&R.0     EQU   0
&R.1     EQU   1
&R.2     EQU   2
&R.3     EQU   3
&R.4     EQU   4
&R.5     EQU   5                        *************
&R.6     EQU   6                        *  DEFINE   *
&R.7     EQU   7                        * SYMBOLIC  *
&R.8     EQU   8                        * REGISTERS *
&R.9     EQU   9                        *************
&R.10    EQU   10
&R.11    EQU   11
&R.12    EQU   12
&R.13    EQU   13
&R.14    EQU   14
&R.15    EQU   15
         AGO   .CONT11
.NOGEN   ANOP
******** REGEQU ALREADY CODED FOR THIS PREFIX, IGNORED ****************
.CONT11  AIF   ('&F&FR' EQ '').NOF
&X       SETA  0                        RE-INIT
&FF      SETC  '&F&FR'
.FLOOP   ANOP
&X       SETA  &X+1
         AIF   (&X GT 15).FGEN
         AIF   ('&$REGS$(&X)' EQ '').FGEN
         AIF   ('&FF' EQ '&$REGS$(&X)').NOGENF
         AGO   .FLOOP
.FGEN    ANOP
&$REGS$(&X) SETC '&FF'
         SPACE 1
&FF.0    EQU   0
&FF.2    EQU   2
&FF.4    EQU   4
&FF.6    EQU   6
.NOF     AIF   ('&STARS' NE 'YES').NOSTAR2
***********************************************************************
.NOSTAR2 SPACE
         AGO   .MEND
.NOGENF  ANOP
******** REGEQU F= ALREADY CODED FOR THIS PREFIX, IGNORED *************
.MEND    MEND
         MACRO
&LABEL   ALLOC &DDNAME=,&DSN=,&MEMBER=,                                X
               &FILE=,&DATASET=,&PASSWD=,                              X
               &PREFIX=NO,&DUMMY=NO,&PERM=YES,                         X
               &SYSOUT=,&FORM=,&PROG=,&ATRNAME=,                       X
               &UNIT=,&VOL=,                                           X
               &SPACE=,&DISP=,                                         X
               &MF=,&SYNAD=
         GBLB  &OMITTED,&DROP
         LCLC  &PER,&PRE,&DUM,&REL,&TYP
         LCLC  &SER,&SRE,&SUM,&SEL,&SYP
&LABEL   DS    0H
         AIF   (T'&SYSOUT NE 'O').SYSOUT
         AIF   ('&DSN' EQ '*' OR '&DATASET' EQ '*').TERMAL
         $MF   DAPB08,R15,&MF
         XC    DAPB08(DAPB08L),DAPB08   INITIALIZE DAIR BLOCK TO ZERO
         MVI   DA08CD+1,X'08'           DAIR ENTRY CODE FOR ALLOCATE
         $RXR  DA08PDSN,&DSN&DATASET,0  POINTER TO DATASET BUFFER
         $RXQ  DA08DDN,&DDNAME&FILE,8   DDNAME
         $RXQ  DA08UNIT,&UNIT,8         UNIT
         $RXQ  DA08SER,&VOL,8           VOLUME NAME
         AIF   (&OMITTED).MEMBER
         MVC   DA08SER+6(2),=CL2' '     CLEAR LAST 2 BYTES OF VOLUME
.MEMBER  $RXQ  DA08MNM,&MEMBER,8        MEMBER NAME
         $RXQ  DA08PSWD,&PASSWD,8       PASSWORD
         AIF   ('&DISP(1)' EQ 'OLD' AND '&SPACE(1)' NE '').SPACMSG
         AIF   ('&DISP(1)' EQ 'SHR' AND '&SPACE(1)' NE '').SPACMSG
         AIF   ('&SPACE' EQ '' ).NOSPACE
         AIF   ( '&SPACE(1)' EQ '' ).SPACE2
         AIF   ('&SPACE(1)' EQ 'TRK').TRK
         AIF   ('&SPACE(1)' EQ 'CYL').CYL
         $RXR  DA08BLK,&SPACE(1),0      AVERAGE BLOCK LENGTH
&TYP     SETC  'DA08ABKL'
&SYP     SETC  '+'
*        ALLOCATION BY AVERAGE BLOCK LENGTH.
         AGO   .SPACE2
.TRK     ANOP
&TYP     SETC  'DA08TRKS'
&SYP     SETC  '+'
*        ALLOCATION IN TRACKS.
         AGO   .SPACE2
.CYL     ANOP
&TYP     SETC  'DA08CYLS'
&SYP     SETC  '+'
*        ALLOCATION IN CYLINDERS.
         AGO   .SPACE2
.NOSPACE ANOP
         AGO   .DISP
.SPACE2  ANOP
         $RXR  DA08PQTY,&SPACE(2),0     PRIMARY SPACE ALLOCATION
         $RXR  DA08SQTY,&SPACE(3),0     SECONDARY QUANTITY
         $RXR  DA08DQTY,&SPACE(4),0     DIRECTORY QUANTITY
         AGO   .SKIP
.SPACMSG MNOTE *,'DISP=&DISP(1) SPECIFIED, SPACE PARAMETERS IGNORED'
.SKIP    AIF   ('&SPACE(5)' NE 'RLSE').DISP
&REL     SETC  'DA08RLSE'
*        RELEASE REQUESTED.
&SEL     SETC  '+'
.DISP    AIF   ('&PREFIX' NE  'YES').NOPREF
&PRE     SETC  'DA08UID'
*        PREFIX WITH CHARGENO.USERID. REQUESTED.
&SRE     SETC  '+'
.NOPREF  AIF   ('&PERM' NE 'YES').NOTPERM
&PER     SETC  'DA08PERM'
*        DATASET MUST BE SPECIFICALLY FREED.
&SER     SETC  '+'
.NOTPERM AIF   ('&DUMMY' NE 'YES').NODUMMY
&DUM     SETC  'DA08DMMY'
*        THIS IS A DUMMY DATASET.
&SUM     SETC  '+'
.NODUMMY ANOP
         AIF   ('&PRE' EQ ''  AND '&PER' EQ ''  AND '&REL' EQ ''       X
               AND '&DUM' EQ '' AND '&TYP' EQ '').NOCTL
         OI    DA08CTL,0&SYP&TYP&SER&PER&SEL&REL&SUM&DUM&SRE&PRE
.NOCTL   AIF   (T'&DISP EQ 'O').NODISP
         AIF   (T'&DISP(1) EQ 'O').NODISP1
         AIF   ('&DISP(1)' NE 'NEW').OLD1
         MVI   DA08DSP1,DA08NEW         DISP=NEW
         AGO   .DISP2
.OLD1    AIF   ('&DISP(1)' NE 'OLD').SHR1
         MVI   DA08DSP1,DA08OLD         DISP=OLD
         AGO   .DISP2
.SHR1    AIF   ('&DISP(1)' NE 'SHR').MOD1
         MVI   DA08DSP1,DA08SHR         DISP=SHR
         AGO   .DISP2
.MOD1    AIF   ('&DISP(1)' NE 'MOD').DISPBAD
         MVI   DA08DSP1,DA08MOD         DISP=MOD
         AGO   .DISP2
.NODISP1 ANOP
*        DEFAULT INITIAL DISPOSTION IS DISP=NEW.
.DISP2   AIF   (T'&DISP(2) EQ 'O').NODISP2
         AIF   ('&DISP(2)' NE 'KEEP').DELETE2
         MVI   DA08DPS2,DA08KEEP        DISP=(,KEEP)
         AGO   .DISP3
.DELETE2 AIF   ('&DISP(2)' NE 'DELETE').CATLG2
         MVI   DA08DPS2,DA08DEL         DISP=(,DELETE)
         AGO   .DISP3
.CATLG2  AIF   ('&DISP(2)' NE 'CATLG').UNCAT2
         MVI   DA08DPS2,DA08CAT         DISP=(,CATLG)
         AGO   .DISP3
.UNCAT2  AIF   ('&DISP(2)' NE 'UNCATLG').DISPBAD
         MVI   DA08DPS2,DA08UCAT        DISP=(,UNCATLG)
         AGO   .DISP3
.NODISP2 ANOP
*        DEFAULT FINAL DISPOSITION IS DISP=(,KEEP).
         AGO   .DISP3
.DISP3   AIF   (T'&DISP(3) EQ 'O').MF
         AIF   ('&DISP(3)' NE 'KEEP').DELETE3
         MVI   DA08DPS3,DA08KEP         DISP=(,,KEEP)
         AGO   .MF
.DELETE3 AIF   ('&DISP(3)' NE 'DELETE').CATLG3
         MVI   DA08DPS3,DA08DELE        DISP=(,,DELETE)
         AGO   .MF
.CATLG3  AIF   ('&DISP(3)' NE 'CATLG').UNCAT3
         MVI   DA08DPS3,DA08CATL        DISP=(,,CATLG)
         AGO   .MF
.UNCAT3  AIF   ('&DISP(3)' NE 'UNCATLG').DISPBAD
         MVI   DA08DPS3,DA08UNCT        DISP=(,,UNCATLG)
         AGO   .MF
.NODISP  ANOP
*        DEFAULT DISPOSITION IS DISP=(NEW,KEEP).
         AGO   .MF
.DISPBAD ANOP
         MNOTE  *,'********************************************'
         MNOTE  12,'-- INVALID DISPOSITON, EXPANSION TERMINATED'
         MNOTE  *,'********************************************'
         MEXIT
.MF      $RXQ  DA08ALN,&ATRNAME,8       ATTRIBUTE LIST NAME
         AIF   (&OMITTED).LBE
         OI    DA08CTL,DA08ATRL         ATTRIBUTE LIST SUPPLIED
         AGO   .LBE
.SYSOUT  $MF   DAPB30,R15,&MF
         XC    DAPB30(DAPB30L),DAPB30   INITIALIZE DAIR BLOCK TO ZERO
         MVI   DA30CD+1,X'30'           DAIR ENTRY CODE SYSOUT ALLOCATE
         $RXR  DA30PDSN,&DSN&DATASET,0  POINTER TO DATASET NAME
         $RXQ  DA30DDN,&DDNAME&FILE,8   DDNAME
         $RXQ  DA30UNIT,&UNIT,8         UNITNAME
         $RXQ  DA30SER,&VOL,8           VOLUME NAME
         AIF   (&OMITTED).PROG
         MVC   DA30SER+6(2),=CL2' '     CLEAR LAST 2 BYTES OF VOLUME
.PROG    $RXQ  DA30PGNM,&PROG,8         PROGRAM NAME
         AIF   (T'&SPACE EQ 'O').DISPS
         AIF   ('&SPACE(1)' EQ 'TRK').TRKS
         AIF   ('&SPACE(1)' EQ 'CYL').CYLS
         $RXR  DA30BLK,&SPACE(1),0      AVERAGE BLOCK LENGTH
&TYP     SETC  'DA30ABKL'
&SYP     SETC  '+'
*        ALLOCATION BY AVERAGE BLOCK LENGTH.
         AGO   .SPACE2S
.TRKS    ANOP
&TYP     SETC  'DA30TRKS'
&SYP     SETC  '+'
*        ALLOCATION IN TRACKS.
         AGO   .SPACE2S
.CYLS    ANOP
&TYP     SETC  'DA08CYLS'
&SYP     SETC  '+'
*        ALLOCATION IN CYLINDERS.
.SPACE2S $RXR  DA30PQTY,&SPACE(2),0     PRIMARY ALLOCATION QUANTITY
         $RXR  DA30SQTY,&SPACE(3),0     SECONDARY QUANTITY
         AIF   (T'&SPACE(4) EQ 'O').SPACE5S
        MNOTE *,'SPACE=, DIRECTORY QUANTITY INVALID FOR SYSOUT DATASET'
.SPACE5S AIF   ('&SPACE(5)' NE 'RLSE').DISPS
&REL     SETC  'DA30RLSE'
*        RELEASE REQUESTED.
&SEL     SETC  '+'
.DISPS   AIF   ('&PREFIX' NE  'YES').NOPREFS
&PRE     SETC  'DA30UID'
*        PREFIX WITH CHARGENO.USERID. REQUESTED.
&SRE     SETC  '+'
.NOPREFS AIF   ('&PERM' NE 'YES').NOTPERS
&PER     SETC  'DA30PERM'
*        DATASET MUST BE SPECIFICALLY FREED.
&SER     SETC  '+'
.NOTPERS AIF   ('&DUMMY' NE 'YES').NODUMMS
&DUM     SETC  'DA30DMMY'
*        THIS IS A DUMMY DATASET.
&SUM     SETC  '+'
.NODUMMS AIF   ('&PRE' EQ ''  AND '&PER' EQ ''  AND '&REL' EQ ''       X
               AND '&DUM' EQ '' AND '&TYP' EQ '').NOCTLS
         OI DA30CTL,&TYP&SER&PER&SEL&REL&SUM&DUM&SRE&PRE
.NOCTLS  $RXQ  DA30FORM,&FORM,4         FORM NUMBER
         $RXQ  DA30OCLS,&SYSOUT,2       SYSOUT CLASS
         AIF   (&OMITTED).CONT2
         MVI   DA30OCLS+1,C' '          CLEAR SECOND BYTE
         AGO   .CONT2
.TERMAL  $MF   DAPB1C,R15,&MF
         XC    DAPB1C(DAPB1CL),DAPB1C   INITIALIZE DAIR BLOCK TO ZERO
         MVI   DA1CCD+1,X'1C' DAIR ENTRY CODE FOR TERMINAL ALLOCATION
         AIF   ('&PERM' NE 'YES').NOPERMT
         OI    DA1CCTL,DA1CPERM    PERMANENTYLY ALLOCATED BIT
.NOPERMT $RXQ  DA1CDDN,&DDNAME&FILE,8   DDNAME
         $RXQ  DA1CALN,&ATRNAME,8       ATTRIBUTE LIST NAME
         AIF   (&OMITTED).LBE
         OI    DA1CCTL,DA1CATRL         ATTRIBUTE LIST SUPPLIED
         AGO   .LBE
.CONT2   $RXQ  DA30ALN,&ATRNAME,8       ATTRIBUTE LIST NAME
         AIF   (&OMITTED).LBE
         OI    DA30CTL,DA30ATRL         ATTRIBUTE LIST SUPPLIED
.LBE     AIF   ('&MF(1)' EQ 'B').ENDB
         AIF   ('&MF(1)' EQ 'L').ENDS
         TSDAIR DAPB=(15),SYNAD=&SYNAD
         AGO   .ENDS
.ENDB    ST    R15,DAPLDAPB
         LA    R1,DAPL
.ENDS    AIF   (NOT &DROP).END2S
         DROP  R15                 DROP ADDRESSIBILITY TO DAIR BLOCK
.END2S   SPACE 1
         MEND
         MACRO
&N       OP    &M,&F,&O
         GBLA  &#                                                  LDW1
         LCLC  &F$
&F$      SETC  '&F'
         AIF   ('&F'(1,1) NE '''').OK
&F$      SETC  '&F'(2,1)
.OK      ANOP
&#       SETA  &#+1                                                LDW1
@&O      EQU   &#                                                  LDW1
&N       DC    CL4'&M',C'&F$',X'&O'
         MEND
         MACRO
&NFS     STCMX &REG,&MASK,&ADDR,&BYTE=,&COPY=                      LDW1
&NFS     STCM  &REG,B'0111',&ADDR       DO IT RIGHT                LDW1
         MEND
         MACRO
&N       TSWORK &DUMMY
         EJECT
*        OLD CS DSECT SORTA.
         SPACE 1
TSOBITS  DS    0F,4X                    GUESS
GODFLAG  DS    X                        MOST USEFUL FLAG
CSALTFLG DS    X                        BITS
USERID   DS    0C'CPC013.LDW'           HANDLE FOR BOTH            LDW1
CSJOBNO  DS    CL6                      CHARGE NO
CSDOT    DC    C'.'                                                LDW1
CSINIT   DS    CL3                      UID
DDNALL   DS    CL8                      SAVE DDNAME TO FREE IT     -EU-
DISPCONS DS    0F                       DISPLAY CONSTANTS          LDW1
NOWMASK  DS    F'-8'                                               LDW1
BITMASK  DS    F'7'                                                LDW1
LINELEN  DS    H'40'                    LENGTH OF LINES TO USE     LDW1
SCRBYTES DS    H'96'                    (BYTES/SCREEN)/2           LDW1
LINEHEX  DS    H'16'                    NUMBER OF BYTES/LINE HEX   LDW1
LINEHEX2 DS    H'32'                    TWICE THE ABOVE            LDW1
BYTES    DS    16AL1                    TRTAB FOR CARET            LDW1
DISPCONL EQU   *-NOWMASK                LEN OF DISPLAY CONSTANTS   LDW1
         SPACE 1
*        ZAP'S DATA AREA FOR EXP.
         SPACE 1
GORF     DS    F                        SAVE AREA FOR PTR
EXPOPT   DS    X                        WHETHER TO SCAN LABLE TAB
DBLW     DS    D
EXPWORK  DS    D
EXPARMS  DS    0F                       'SAVEAREA' FOR 'EXP'
EXPFLAG  DS    3F
         DS    A
EXPSTART DS    A
         DS    F                        LENGTH
EXPPTR   DS    A
         SPACE 1
*        ZAP'S DATA AREA.
         SPACE 1
NOWSTUFF DS    0F                                                  LDW1
*        FOLLOWING 3 LINES *MUST*BE*TOGETHER*
OLDPOINT DS    H                        OFFSET INTO BUFFER
OFFSET   DS    F                        (OLDPOINT + BASEVAL)       LDW1
BASEVAL  DS    F                        BASE VALUE                 LDW1
NOWLEN   EQU   *-NOWSTUFF                                          LDW1
         SPACE 1
AIDEFTAB DS    A                        ADDR OF DEFINE TABLE
AITRCTAB DS    A                        ADDR OF TRACE TABLE        LDW1
AITREND  DS    A                        -> END OF TRACE TABLE      LDW1
FIRSTSCR DS    A                        ADDR OF FIRST SCREEN LOC
MAXSCR   DS    A                        ADDR OF END OF AVAIL SCR
ADDRWORK DS    F                        ADDRESS OF MSG AND WTO WORK
SIZEWORK DS    F                        SIZE OF MSG AND WTO WORK
CSOUTWK  EQU   ADDRWORK                 CSOUT WORKAREA IS FIRST
TEMPTRT  DS    XL256                    TEMP TRTAB FOR STRING ANAL
         SPACE 1
$L       EQU   79                       LENGTH OF DISPLAY LINE     LDW1
$I       EQU   81                       LINE INCREMENT (IN SCREEN) LDW1
SCREEN   EQU   *                                                   SDM5
CTL3270  DS    XL7                      WHERE THE 3270 STUFF GOES  LDW1
         DS    X'1D60'                  PROT NORMAL                SDM5
LINE01   DS    CL79,X'1DC8'             SCREEN BUFFER...           SDM5
LINE02   DS    CL79,X'1D60'             .                          LDW1
LINE03   DS    CL79,X'1DC8'             .                          LDW1
REP      DS    CL79,X'1DF8'             .                          LDW1
LINE05   DS    CL79,X'1D60'             .                          LDW1
LINE06   DS    CL79,X'1D60'             .                          LDW1
LINE07   DS    CL79,X'1D60'             .                          LDW1
LINE08   DS    CL79,X'1D60'             .                          LDW1
LINE09   DS    CL79,X'1D60'             .                          LDW1
LINE10   DS    CL79,X'1D60'             .                          LDW1
LINE11   DS    CL79,X'1D60'             .                          LDW1
LINE12   DS    CL79,X'1D60'             .                          LDW1
LINE13   DS    CL79,X'1D60'             .                          LDW1
LINE14   DS    CL79,X'1D60'             .                          LDW1
LINE15   DS    CL79,X'1D60'             .                          LDW1
LINE16   DS    CL79,X'1D60'             .                          LDW1
LINE17   DS    CL79,X'1D60'             .                          LDW1
LINE18   DS    CL79,X'1DF8'             .                          LDW1
LINE19   DS    CL79,X'1D60'             .                          LDW1
LINE20   DS    CL79,X'1D60'             .                          LDW1
LINE21   DS    CL79                     .                          SDM5
END3270  DS    XL8                      WHERE THE REST GOES        SDM5
SCREENL  EQU   *-SCREEN                 LENGTH OF SCREEN DATA      SDM5
REGS3270 DS    A(SCREEN,SCREENL)        TPUT FULLSCR REGS          SDM5
ASCRWORK DS    A(SCRWORK)               -> SCREEN WORK AREA        LDW2
AOLDSCR  DS    A(OLDSCR)                -> SCREEN SAVE AREA        SDM5
REPX     DS    CL(1+2+(3+79)*2)         REPLY BUFF FOR TGET ASIS   SDM1
PREVREP  DS    CL79                     THE PREVIOUS REPLY         LDW4
VERSION  DS    C'VERSION=V.MC DDMMMYY LDW'                         LDW1
CURPOS   DS    H                        CURSOR POSITION            LDW1
TERMSAVE DS    A                        SAVE FOR R14 IN PUTLINE    LDW1
LINEDESC DC    Y($L+4,0)                THE "OLD" FOR PUTLINE      LDW1
LINEBUFF DS    CL80                     PUTLINE'S BUFFER           LDW1
DSNAMEL  DS    H                        LENGTH OF DSN (44)
DSNAME   DS    CL44                     DSN
PASSWORD DS    CL8                      GUESS WHAT?                LDW1
DISPDSN  DS    CL44                     DISPLAYABLE DSN            LDW1
ALLDSNL  DS    H                        LENGTH OF DSN TO ALLOCATE  -EU-
ALLOCDSN DS    CL44                     DSN TO ALLOCATE            LDW1
         SPACE 1                                                   -EU-
ATIOT    DC    F'0'                                                -EU-
TDDNMSV  DC    F'0'                                                -EU-
REQAUT   DC    0F'0',BL1'00000000',AL3(MDL@IX),AL4(*-*)            -EU-
RQA      DC    XL1'0'                                              -EU-
REQAUTL  EQU   *-REQAUT                                            -EU-
CAPSFLG  DC    XL1'0'                                              -EU-
         SPACE 1                                                   -EU-
TTR      DS    F                        TTR OF BLK
*        THE LAST BYTE OF "TTR" IS USED FOR A SEQUENTIAL READ FLAG.
OLDTTR   DS    F                        TTR OF LAST STORE OR SET CMD
STOPDUMP DS    XL3                      TTR WHERE TO STOP DUMP
DSORG    DS    X                        DSORG OF CURRENT DATASET
DSORGPO  EQU   X'02'                    DSORG=PARTITIONED ORGANIZATION
         SPACE 1
IDEFAVAL DS    A                        1ST AVAL POSIT IN DEFINE TAB
ITRAVAL  DS    A                        1ST AVAIL TRACE TAB POSIT
CURRITR  DS    F                        CURRENT TRACE TABLE ENTRY PTR
         SPACE 1
TEMP     DS    2D                       WORK AREA
TEMP2    DS    5D                       WORK AREA
TRTABADD DS    A                        PTR TO TRTAB FOR DUMP DISPLAY
TRTXTAB  DS    A                        PTR TO TRTAB FOR STRING    -EU-
         SPACE 1
MIDLINE  DS    A                        CARET
WIDTHS   DS    0F                       FOR WINDOWS       |**********|
WIDTHD   DS    F                        FOR DOWN          |CONTIGUOUS|
WIDTHU   DS    F                        UP                |**********|
         SPACE 1
REALRDLN DS    H                        ACTUAL COMND READ LENGTH
READLEN  DS    H                        READLENGTH FROM TGET
TRACE    DS    X                        FLAG-TRACE IN EFFECT OR NOT
CONTINUE DS    X                        STORES, SCAN, SET IN EFFECT
IOERROR  DS    X                        FLAG-SYNAD I/O ERROR OR NOT
CPUTFLAG DS    X                        WHETHER CSOUT CAN ENQ OR NOT
EOFRET   DS    X                        IGNORE EOF'S?
ENQIT    DS    X                        WHETHER THERES ANYTHING TO ENQ
CHNGED   DS    X                        SET IF BUFFER NEEDS CHKPOINTING
IDRFLAG  DS    X                        WHETHER IDR WAS UPDATED OR NOT
         SPACE 1
FLAGS2   DS    X                        MISC FLAGS FOR TSO VERSION
MUSTZAP  EQU   X'80'                    BLK NOT REP, ENTER SAVE/EN
ATTNHIT  EQU   X'40'                    ATTN HIT SINCE LAST TGET   LDW5
SENSF    EQU   X'20'                    URSA OR SYS DS
LOGF     EQU   X'10'                    IN LOGGING STATE
NOWHEREF EQU   X'08'                    WHERE NOT NEEDED           SDM6
TERSEF   EQU   X'04'                    PERMANENTLY SUPPRESS WHERE SDM6
         SPACE 1
FLAGS3   DS    X                        CRT AND 3270 FLAGS         LDW2
RESHOWF  EQU   X'40'                    REFRESH WHOLE SCR NXT TPUT LDW2
NODISPF  EQU   X'20'                    DON'T DISP SCRN THIS TIME  SDM6
F3270    EQU   X'10'                    3270 OPTION ON             LDW5
FSMODE   EQU   X'08'                    FULLSCR MODE ACTIVE        LDW5
CRTF     EQU   X'04'                    CRT KEYWORD GIVEN          LDW5
         SPACE 1
         DS    X                        (UNUSED)                   LDW2
LOOKFOR  DS    H,CL16                   SCAN WORK AREA (LEN+STRING)
ZAPSTRNG DS    H,CL16                   S,X,O,N WORK AREA (LEN+STRING)
SETSTR   DS    H,CL16                   SET WORK AREA (LEN+STRING)
WKSTR    DS    CL16                     WORK STRING AREA           -EU-
         SPACE 1
ADDRCNT  DS    A                        ADDRESS OF RECORD COUNT    LDW1
ADDRKEY  DS    A                        ADDRESS OF RECORD KEY      LDW1
ADDRDATA DS    A                        ADDRESS OF RECORD DATA     LDW1
ADDRBUFF DS    A                        ONE OF THE ABOVE 3 ADDRS   LDW1
BUFFSIZE DS    H                        MAX BUFFER SIZE             *N*
KEYLEN   DS    H                        CURRENT KEY LENGTH          *N*
BLKLEN   DS    H                        ACTUAL BLOCK LENGTH AFT READ*N*
         SPACE 1
ESDID    DS    H                        ESD ID
MEMTTR   DS    XL3                      SAVE MEMBER'S TTR
TXTTTR   DS    XL3                      LOAD MOD'S FIRST TEXT BLK   *N*
CTL1TTR  DS    XL3                      TTR OF 1ST CTL REC OR 0    MAS2
TXTORIG  DS    F                        ORIG OF NXT TXT BLOCK      MAS2
MEMBER   DS    CL8                      MEMBER FOR PDS SEARCH
NAME     DS    CL8                      ENTRY NAME FOR EPA SEARCH   *N*
ENDTTR   DS    XL3                      TTR OF LAST BLK IN DATASET
LASTFMT1 DS    XL5                      CCHHR OF LAST FMT1 DSCB    LDW4
ESDTTR   DS    XL3                      START OF ESD               LDW1
         SPACE 1
DCBLIST  DS    F                        DCB PTR MF=L OPEN AND CLOSE
DSCBLIST EQU   TEMP2+16                                            LDW1
VOLSER   DS    CL6                      VOL=SER OF DSN
         SPACE 2
*TMPLIST  OACTMP MF=L                    FOR 'DO'                  -EU-
*TMPLISTL EQU   *-TMPLIST                LEN                       -EU-
         SPACE 2
*DCBU    DCB   MACRF=E,DDNAME=DDNAME,DEVD=DA                       LDW1
DCBU     DCB   MACRF=E,DDNAME=DDNAME,DEVD=DA                       LDW1
         DS    5F                       TURKEY SYSTEM (NEED 72 BYTELDW1
         SPACE 2                                                   LDW1
IOB      DC    X'42000000'              IOBFLAG                    LDW1
         DC    A(ECB)                   IOBECBA                    LDW1
CSW      DS    XL8                      IOBCSW                     LDW1
IOBCCWA  DC    A(CCWS,DCBU,0,0)         IOBCCWA,IOBDCBA,?,?        LDW1
MBBCCHHR DS    0XL8,XL3                 IOBSEEK                    LDW1
CCHHR    DS    XL5                      INTERESTING PART           LDW1
         SPACE 1                                                   LDW1
ECB      DS    A                        ECB FOR ECXP               LDW1
         SPACE 1
CCWS     DS    0D                       HANDLE FOR ALL CCWS        LDW1
CCW##R   CCW   X'16',0,X'70',1          READ R0 TO ORIENT          LDW1
CCW#R#S  CCW   X'31',CCHHR,X'40',5      SEARCH ID EQ               LDW1
CCW#R#T  CCW   X'08',*-8,X'00',0        TIC *-8                    LDW1
CCW#R#R  CCW   X'1E',*-*,X'20',*-*      READ CKD                   LDW1
         SPACE 1
CCW##W   DS    0D                                                  LDW1
CCW#W#S  CCW   X'31',CCHHR,X'40',5      SEARCH ID EQ               LDW1
CCW#W#T  CCW   X'08',*-8,X'00',0        TIC *-8                    LDW1
CCW#W#W  CCW   X'0D',*-*,X'00',*-*      WRITE KD                   LDW1
         SPACE 1
CCW##R0  CCW   X'16',*-*,X'20',*-*      READ R0                    LDW1
         SPACE 1
CCW##D   CCW   X'16',0,X'70',1          READ R0 TO ORIENT          LDW1
CCW#D#S  CCW   X'E9',NAME,X'40',8       SEARCH KEY EQ/HI MT        LDW1
CCW#D#T  CCW   X'08',*-8,X'00',0        TIC *-8                    LDW1
CCW#D#R  CCW   X'0E',*-*,X'00',8+256    READ KD                    LDW1
         SPACE 1
CCW##F   DS    0D                                                  LDW1
CCW#F#S  CCW   X'31',CCHHR,X'40',5      SEARCH ID EQ               LDW1
CCW#F#T  CCW   X'08',*-8,X'00',0        TIC *-8                    LDW1
CCW#F#W  CCW   X'1D',*-*,X'20',*-*      WRITE CKD                  LDW1
         SPACE 1
CCWL     EQU   *-CCWS                   LENGTH OF CCW PATTERNS     LDW1
         SPACE 2                                                   LDW1
*STAXLIST STAX 0,MF=L
STAXLIST STAX  0,MF=L
STAXL    EQU   *-STAXLIST
         SPACE 2
FLAGESD  DS    X                        FLAGS                       *N*
FESDTEXT EQU   X'80'                    NEXT BLOCK IS TEXT          *N*
         SPACE 2                                                   LDW1
PTPB     DS    0F,XL12                  FOR PUTLINE                LDW1
*        PGPB  DSECT=NO
         PGPB  DSECT=NO
         SPACE 2
EXLST    DS    A(JFCB)                  OBVIOUS                    LDW1
JFCB     DS    44F                      OBVIOUS                    LDW1
         SPACE 2                                                   -EU-
ICREP    DS    CL79                INTEGRAL COPY OF RESPONSE FIELD -EU-
BLANKS   DS    CL256                    CONSTANT FOR CLEARING      LDW1
         SPACE 2                                                   LDW3
IDEFTAB  DS    24XL10                   24 ENTRY DEFINE TABLE
ENDITAB  DS    X                        END OF TABLE (X'FF')
         SPACE 1
*        EACH ENTRY ABOVE IS OF THE FORM (8C,H),
*        CORRESPONDING TO 'SYMBOL,OFFSET'.
         SPACE 2
ITRTAB   DS    24XL5                    TRACE TABLE
ITREND   DS    X                        END OF TABLE (X'FF')
         SPACE 1
*        EACH ENTRY ABOVE IS OF THE FORM (3X,2X),
*        CORRESPONDING TO 'TTR,OFFSET'.
         SPACE 2
OLDSCR   DS    CL(21*$I)                SCREEN SAVE AREA           SDM5
SCRWORK  DS    CL(SCREENL+3*21)         JUST PARTS THAT CHANGED    LDW2
         SPACE 2
         MEND
         MACRO
&NFS     ENTR  &BASE=12,&BASE2=,&BASE3=,&BASE4=,                       X
               &SAVE=*,&REGS=(YES,R),&F=,                              X
               &USING=,&SECTYPE=CSECT,&GETMAIN=,&PARMREG=,&LPARM=,     X
               &SP=1,&ID=*,&EXIT=,&ADDRREG=,&LENREG=,&ENV=CALL,        X
               &RC=,&RCLOC=,&T=T,&PL=,&LOAD=,&SYMREG=,&DSECT=,         X
               &TSFAKE=,&PARSE=,&MACRO=,&PRINT=,&DATE=,&TIME=
         GBLB  &GDAIRM,&GPARSEM         TO AVOID DUPLICATES
         GBLB  &GDAIR,&GPARSE           DAIR OR PARSE LOADED
         LCLC  &BA$E,&$AVE,&Q,&NAME,&RCRC,&LR,&AR,&T$FAKE,&GET1,&GET2
         LCLC  &PARNAME
         LCLC  &IHBNX,&BLANK1,&BLANK2
         LCLC  &R0,&R1,&R2,&R3,&R12,&R13,&R14,&R15
         LCLA  &L,&X
         LCLB  &ENVTSO,&ENVCALL,&ENVCP,&ENVPLI,&ENVMVT,&ENVMVS
         LCLB  &FKCALL,&FKCP,&MVSCVT
         LCLB  &CSPL,&PARS,&DAIR,&IO,&MSG
&IHBNX   SETC  'IHB&SYSNDX'
&BLANK1  SETC  '        '
&BLANK2  SETC  '        '
&PARNAME SETC  ''
         AIF   ('&PRINT' NE 'NOGEN').PRINTOK
         AIF   ('&PRINT' NE '').PRINTOK
         MNOTE 4,'WHAT DOES PRINT=&PRINT MEAN???'
.PRINTOK AIF   ('&SYMREG' EQ '').NOSYMRG
         MNOTE 0,'SYMREG= IS UNSUPPORTED -- USE REGS='
.NOSYMRG AIF   ('&DSECT' EQ '').NOD$ECT
         MNOTE 4,'DSECT= IS UNSUPPORTED'
.NOD$ECT ANOP
&X       SETA  0
.ENVLOOP AIF   (N'&ENV EQ &X).ENVDONE
&X       SETA  &X+1
         AIF   ('&ENV(&X)' EQ 'TSO'  ).ENVTSO
         AIF   ('&ENV(&X)' EQ 'CALL' ).ENVCALL
         AIF   ('&ENV(&X)' EQ 'CP'   ).ENVCP
         AIF   ('&ENV(&X)' EQ 'TSOCP').ENVCP
         AIF   ('&ENV(&X)' EQ 'MVS'  ).ENVMVS
         AIF   ('&ENV(&X)' EQ 'MVT'  ).ENVMVT
         MNOTE 4,'ENV=&ENV(&X) IS INVALID -- IGNORED'
         AGO   .ENVLOOP
.ENVTSO  ANOP
&ENVTSO  SETB  1
         AGO   .ENVLOOP
.ENVCALL ANOP
&ENVCALL SETB  1
         AGO   .ENVLOOP
.ENVCP   ANOP
&ENVCP   SETB  1
&ENVTSO  SETB  1                        ENV=CP IMPLIES ENV=TSO
         AGO   .ENVLOOP
.ENVMVS  ANOP
&ENVMVS  SETB  1
         AGO   .ENVLOOP
.ENVMVT  ANOP
&ENVMVT  SETB  1
         AGO   .ENVLOOP
.ENVPLI  ANOP
&ENVPLI  SETB  1
         AIF   ('&BASE' NE '12' AND '&BASE' NE 'R12').ENVLOOP
         MNOTE 0,'WARNING : BASE=&BASE IS NOT COMPATIBLE WITH ENV=PLIX'
         AGO   .ENVLOOP
.ENVDONE AIF   (NOT &ENVCALL OR NOT &ENVCP).ENVOK1
        MNOTE 4,'ENV=(CALL,CP) MAY NOT BOTH BE GIVEN. "CALL" IGNORED.'
&ENVCALL SETB  0                        IGNORE IT
.ENVOK1  AIF   (NOT &ENVMVT OR NOT &ENVMVS).ENVOK2
         MNOTE 4,'MAKE UP YOUR MIND : ENV=MVT OR ENV=MVS, BUT NOT BOTH.X
                 MVT ASSUMED.'
&ENVMVS  SETB  0                        IGNORE IT
.ENVOK2  AIF   ('&TSFAKE' EQ '').NOFAKE
&T$FAKE  SETC  '&TSFAKE'
         AIF   ('&TSFAKE' NE 'YES').FAKENO
&T$FAKE  SETC  '&IHBNX.F'
.FAKENO  AIF   ('&PARMREG' NE '').OKFAKE0
         MNOTE 4,'*** PARMREG= MUST BE GIVEN IF TSFAKE= IS GIVEN. TSFAKX
               E=&TSFAKE IGNORED.'
         AGO   .NOFAKE
.OKFAKE0 AIF   (NOT &ENVCALL).NOFKCAL
&FKCALL  SETB  1
         AGO   .NOFAKE
.NOFKCAL AIF   (NOT &ENVCP).NOFKCP
&FKCP    SETB  1
         AGO   .NOFAKE
.NOFKCP  MNOTE 0,'WHAT TO FAKE?????'
.NOFAKE  ANOP
&$AVE    SETC  '&SAVE'                  INIT DEFAULT
&GET1    SETC  '&GETMAIN(1)'
&GET2    SETC  '&GETMAIN(2)'
         AIF   ('&MACRO' NE 'YES').OKGET2
         AIF   ('&GET1' NE '').OKGET1
&GET1    SETC  'TSDSECTL'               SET DEFAULT
.OKGET1  AIF   ('&GET2' NE '').OKGET2
&GET2    SETC  'TSDSECT'                SET DEFAULT
.OKGET2  AIF   ('&GETMAIN' EQ '').KEEPSAV
         AIF   ('&GETMAIN(1)' NE '').GMOK1
         AIF   ('&MACRO' EQ 'YES').GMOK1
         MNOTE 8,'GETMAIN= CODED INCORRECTLY. MACRO TERMINATED'
         MEXIT
.GMOK1   ANOP
&$AVE    SETC  ''                       NO SAVE AREA
.KEEPSAV AIF   ('&BASE4' EQ '').NOBASE4
         AIF   ('&BASE3' NE '').BASE3
         MNOTE 8,'*** BASE4 IGNORED, INVALID WITHOUT BASE3= ***'
.NOBASE4 AIF   ('&BASE3' EQ '').OKBASES
.BASE3   AIF   ('&BASE2' NE '').OKBASES
         MNOTE 8,'*** BASE3 IGNORED, INVALID WITHOUT BASE2= ***'
.OKBASES AIF   (('&GETMAIN' EQ '') AND ('&MACRO' NE 'YES')).OK1
         AIF   ('&SAVE'   EQ '*').OK1
         AIF   ('&SAVE'    EQ '').OK1
         MNOTE 12,'*** SAVE= MUTUALLY EXCLUSIVE WITH GETMAIN= AND/OR MA$
               CRO=YES. MACRO TERMINATED ***'
         MEXIT
.OK1     AIF   ('&NFS' NE '').GOTNAME
         MNOTE 12,'*** CSECT NAME OMMITTED ***'
.GOTNAME AIF   ('&SECTYPE' NE 'CSECT').NOCSECT
.DOCSECT ANOP
&NFS     CSECT                          ENTR -- 09/27/79 -- LDW
         AGO   .SECDONE
.NOCSECT AIF   ('&SECTYPE' NE 'DSECT').NODSECT
&NFS     DSECT                          ENTR -- 09/27/79 -- LDW
         AGO   .SECDONE
.NODSECT AIF   ('&SECTYPE' EQ 'NONE').SECNONE
         AIF   ('&SECTYPE' EQ 'ENTRY').ENTRY
       MNOTE 8,'*** SECTYPE=&SECTYPE IS INVALID, SECTYPE=CSECT ASSUMED'
         AGO   .DOCSECT
.ENTRY   ENTRY &NFS
.SECNONE ANOP
*        DEFINE NAME.
&NFS     DC    0D'0'                    ENTR -- 09/27/79 -- LDW
.SECDONE AIF   ('&REGS(1)' EQ '' AND '&REGS(2)' NE '').DOREGS
         AIF   ('&REGS(1)' EQ 'NO').NOREGS
         AIF   ('&REGS(2)' NE '').DOREGS
&Q       SETC  'R'
         AGO   .CONT1
.DOREGS  ANOP
&Q       SETC  '&REGS(2)'
.CONT1   ANOP                           WAS SPACE 1
&L       SETA  K'&Q
***********************************************************************
*        REGISTER EQUATES.                                            *
         REGEQU  PREFIX=&Q,FR=&F
         SPACE 1
.NOREGS  ANOP
&R0      SETC  '&Q'.'0'
&R1      SETC  '&Q'.'1'
&R2      SETC  '&Q'.'2'
&R3      SETC  '&Q'.'3'
&R12     SETC  '&Q'.'12'
&R13     SETC  '&Q'.'13'
&R14     SETC  '&Q'.'14'
&R15     SETC  '&Q'.'15'
&L       SETA  K'&REGS(2)
         AIF   (&ENVCP AND '&PL' NE '').NOGM2   WILL BE GENERATED LATER
         AIF   ('&GET2' EQ '').NOGM2
&GET2    DSECT
         DS    18F                      SAVE AREA
         AIF   ('&TSFAKE' NE 'YES' OR &ENVCP).NOFKY1
&T$FAKE  DS    A,2H,CL100               AREA FOR FAKE PARM FIELD
.NOFKY1  AIF   (NOT &ENVCP).NO$CPPL
         AIF   ('&PL' EQ '').NOTSECB
TSECB    DS    F
.NOTSECB SPACE 1
         TSCPPL
.NO$CPPL AIF   ('&LOAD' EQ '').NOLOAD1
&X       SETA  0
.LOADLP1 ANOP
&X       SETA  &X+1
&LOAD(&X) DS   A
         AIF   (&X LT N'&LOAD).LOADLP1
.NOLOAD1 SPACE 2
&NFS     CSECT                          RESUME
.NOGM2   AIF   ('&REGS(1)' EQ 'NO').REGBASE
         AIF   ('&BASE'(1,&L) EQ '&REGS(2)').REGBASE
&BA$E    SETC  '&Q&BASE'
         AGO   .CONT2
.REGBASE ANOP
&BA$E    SETC  '&BASE'
.CONT2   USING *,&R15                   TEMPORARY BASE
         B     &IHBNX.B                 AROUND GORF
         DROP  &R15                     DROP TEMP BASE
         OACUSING &NFS,&BA$E
         AIF   ('&ID(1)' EQ '*').IDSTAR
         AIF   ('&ID(1)' EQ '' ).IDSTAR
         AIF   ('&ID' EQ '*NONE*').DONEID
         ID    &ID(1),&ID(2),DATE=&DATE,TIME=&TIME
         AGO   .DONEID
.IDSTAR  ID    &NFS,&ID(2),DATE=&DATE,TIME=&TIME
.DONEID  AIF   ('&BASE2' EQ '').NOBASE2
&IHBNX.A DC    A(&NFS+4096)             SECOND BASE REGISTER
         AIF   ('&BASE3' EQ '').NOBASE2
&IHBNX.Z DC    A(&NFS+8192)             LET'S NOT GET CARRIED AWAY...
         AIF   ('&BASE4' EQ '').NOBASE2
&IHBNX.Q DC    A(&NFS+12288)            BUT THIS IS GETTING REDICULOUS
.NOBASE2 AIF   (('&$AVE' NE '*') OR ('&GET1' NE '')).NOSVSTR NO INL SA
&IHBNX.S DC    18F'0'                   SAVE AREA
&$AVE    SETC  '&IHBNX.S'
.NOSVSTR AIF   ('&TSFAKE' NE 'YES' OR &ENVCP OR '&GET2' NE '').NOFKY2
&T$FAKE  DC    A(0),2H'0',CL100' '      AREA FOR FAKE PARM FIELD
.NOFKY2  AIF   ('&GET1&GET2' EQ '').NOSPLEN  NO SP & LENGTH
         AIF   ('&BASE2' NE '').BASE2L
         DC    0A(0)                    ALIGNMENT
.BASE2L  ANOP                           DON'T NEED ALIGNMENT
&IHBNX.L DC    AL1(&SP),AL3(&GET1)      GETMAIN SP AND LENGTH
.NOSPLEN AIF   ('&EXIT' EQ '').NOEXIT
         SPACE 1
*=====================================================================*
&RCRC    SETC  '&RC(1)'
         AIF   ('&RC' NE '').OKRC1
&RCRC    SETC  '&R15'
.OKRC1   AIF   ('&RCLOC' EQ '').OKRC3
         AIF   ('&RC'    EQ '').OKRC2
         MNOTE 0,'*** RC= AND RCLOC= MUTUALLY EXCLUSIVE -- RC= IGNORED'
.OKRC2   ANOP
&RCRC    SETC  '&RCLOC'
.OKRC3   ANOP
&X       SETA  8-K'&RCRC                NUMBER OF BLANKS NEEDED
         AIF   (&X GT 0).OKRCL
&BLANK1  SETC  ''
         AGO   .CHAR8RC
.OKRCL   ANOP
&BLANK1  SETC  '&BLANK1'(1,&X)
.CHAR8RC ANOP
&X       SETA  8-K'&EXIT(1)             NUMBER OF BLANKS NEEDED
         AIF   (&X GT 0).OKEXITL
&BLANK2  SETC  ''
         AGO   .CHAR8EX
.OKEXITL ANOP
&BLANK2  SETC  '&BLANK2'(1,&X)
.CHAR8EX AIF   ('&RC' EQ '').MREGRC
         AIF   ('&RC'(1,1) EQ '(').MREGRC
         MNOTE *,'-- BRANCH TO "&EXIT" TO EXIT WITH RETURN CODE=&RCRC  X
                 &BLANK1   &BLANK2    *'
         AGO   .MRCCONT
.MREGRC  MNOTE *,'   BRANCH TO "&EXIT" TO EXIT WITH RETURN CODE IN &RCR$
               C &BLANK1   &BLANK2    *'
.MRCCONT ANOP
*=====================================================================*
&NAME    SETC  '&EXIT'
         AIF   ('&RCRC' NE '0').RCNOT0
&NAME    XR    &R15,&R15                SET RETURN CODE ZERO
&NAME    SETC  ''
         AGO   .HAVERC
.RCNOT0  AIF   ('&RCLOC' EQ '').NORCLOC RCLOC NOT GIVEN
         AIF   ('&GET2' EQ '').NORCUSE
         USING &GET2,&R13               IN CASE RCLOC IS IN DSECT
.NORCUSE AIF   (T'&RCLOC EQ 'F').RCLOCF
         AIF   (T'&RCLOC EQ 'H').RCLOCH
         MNOTE 0,'*** UNKNOWN TYPE FOR RCLOC=&RCLOC -- "F" ASSUMED'
.RCLOCF  ANOP
&NAME    L     &R15,&RCLOC              LOAD RETURN CODE
         AGO   .RCCOM1                  GO TO COMMON
.RCLOCH  ANOP
&NAME    LH    &R15,&RCLOC              LOAD RETURN CODE
.RCCOM1  AIF   ('&GET2' EQ '').RCCOM2
         DROP  &R13                     IN CASE RCLOC IS IN DSECT
         AGO   .RCCOM2                  GO TO COMMON
.NORCLOC AIF   ('&RC' EQ '').HAVERC     RC IS IN A REG
         AIF   ('&RC'(1,1) EQ '(').HAVERC    DITTO
&NAME    LA    &R15,&RCRC               LOAD RETURN CODE
.RCCOM2  ANOP                           COMMON POINT
&NAME    SETC  ''
.HAVERC  AIF   ('&GET1' EQ '').NOWORK1  NO DSA TO FREE
&NAME    LR    &R1,&R13                 COPY DSA PTR
&NAME    SETC  ''
.NOWORK1 ANOP
&NAME    L     &R13,4(,&R13)            DECHAIN SAVE AREAS
&NAME    SETC  ''
         AIF   ('&RC' EQ '').WORKE
         AIF   ('&RC'(1,1) NE '(').NOWORKE
.WORKE   AIF   ('&RCLOC' NE '').NOWORKE STORE R15
         AIF   ('&GET1' EQ '').RCNOT1   RC=(1) IS OK IF NO DYNAMIC AREA
         AIF   (('&RCRC' NE '&R1') AND ('&RCRC' NE '1')).RCNOT1
         MNOTE 4,'YOU TURKEY. RC=(R1) DOESN''T WORK RIGHT IF YOU HAVE AX
                DYNAMIC AREA'
         MNOTE 0,'... I HOPE YOU INSTALLED ZAP...'
.RCNOT1  ST    &RCRC,16(,&R13)          SET RETURN CODE
         AGO   .WASRGRC
.NOWORKE ST    &R15,16(,&R13)           SET RETURN CODE
.WASRGRC AIF   ('&GET1' EQ '').NOWRKE2  NO DSA TO FREE
         L     &R0,&IHBNX.L             PICK UP SP AND LENGTH
*        FREEMAIN  R,A=(1),LV=(0)       FREE THE DSA
         FREEMAIN  R,A=(1),LV=(0)
.NOWRKE2 LM    &R14,&R12,12(&R13)       RESTORE CALLERS REGS
         AIF   ('&T' NE 'T').BR14
         MVI   12(&R13),X'FF'           FLAG SAVEAREA AS INACTIVE
.BR14    BR    &R14                     RETURN TO CALLER
.NOEXIT  SPACE 1
*=====================================================================*
*    ENTRY CODE                                                       *
*=====================================================================*
&IHBNX.B STM   &R14,&R12,12(&R13)       SAVE CALLER'S REGS
         LR    &BA$E,&R15               LOAD BASE REGISTER
         AIF   ('&BASE2' EQ '').BASEFIN
         L     &BASE2,&IHBNX.A          LOAD SECOND BASE REGISTER
         OACUSING &NFS+4096,&BASE2
         AIF   ('&BASE3' EQ '').BASEFIN
         L     &BASE3,&IHBNX.Z          LOAD BASE3 FOR MLE,BMD,VIC
         OACUSING &NFS+8192,&BASE3
         AIF   ('&BASE4' EQ '').BASEFIN
         L     &BASE4,&IHBNX.Q          WHAT'S GOING ON HERE???
         OACUSING &NFS+12288,&BASE4
.BASEFIN AIF   (N'&USING LT 1).NOUSING
&X       SETA  1
.USINGLP OACUSING &USING(&X),&USING(&X+1)
&X       SETA  &X+2
         AIF   (&X LT N'&USING).USINGLP
.NOUSING ANOP
&AR      SETC  '&R14'                   SET DEFAULT FOR LENREG=
&LR      SETC  '&R15'                   SET DEFAULT FOR ADDRREG=
         AIF   (('&ADDRREG' EQ '') AND ('&LENREG' EQ '')).NO$AR
         AIF   (('&ADDRREG' NE '') AND ('&LENREG' NE '')).ARLR
         MNOTE 8,'ADDRREG= AND LENREG= MUST BOTH BE GIVEN'
.ARLR    ANOP
&AR      SETC  '&ADDRREG'
&LR      SETC  '&LENREG'
.NO$AR   AIF   ('&PARMREG' EQ '').NOPARMR
         LR    &PARMREG,&R1             SAVE PARM POINTER
.NOPARMR AIF   ('&LPARM' EQ '').NOLPARM
&NAME    L     &LPARM,0(,&R1)           PICK UP PARM POINTER
&NAME    SETC  ''
         AIF   (&ENVTSO).NOLPARM
         AIF   ('&ADDRREG' EQ '').NOLPARM
         LH    &LR,0(,&LPARM)           GET PARM LENGTH
         LA    &AR,2(,&LPARM)           POINT PAST LENGTH
.NOLPARM AIF   ('&GET1' EQ '').STATIC
&NAME    L     &R0,&IHBNX.L             PICK UP SP AND LENGTH
&NAME    SETC  ''
*        GETMAIN  R,LV=(0)              GET A WORKAREA (DSA)
         GETMAIN  R,LV=(0)
.USE1    ST    &R1,8(,&R13)             FORW CHAIN SAVE AREAS
         ST    &R13,4(,&R1)             BACK CHAIN SAVE AREAS
         LR    &R13,&R1                 GET NEW SAVE AREA ADDR
         AIF   ('&GET2' EQ '').CONT3
         OACUSING &GET2,&R13
         AGO   .CONT3
.STATIC  AIF   ('&PARMREG' NE '&R15').NOT15
&NAME    LA    &R1,&$AVE                GET SAVE AREA ADDR
&NAME    SETC  ''
         AGO   .USE1
.NOT15   LA    &R15,&$AVE               GET SAVE AREA ADDR
         ST    &R15,8(,&R13)            FORW CHAIN SAVE AREAS
         ST    &R13,4(,&R15)            BACK CHAIN SAVE AREAS
         LR    &R13,&R15                GET NEW SAVE AREA ADDR
.CONT3   AIF   ('&RCLOC' EQ '').CONT3B
         XC    &RCLOC,&RCLOC            INIT RCLOC TO ZERO
.CONT3B  SPACE 1
         AIF   (NOT &ENVCP).NMVCPPL
         MVC   CPPL(CPPLL),0(&PARMREG)  COPY CPPL TO SAFE PLACE
.NMVCPPL AIF   (&FKCALL OR &FKCP).FAKE$A
         AIF   ('&ADDRREG' EQ '').LOAD
         AIF   (&ENVTSO).FAKE$A
         L     &AR,0(,&PARMREG)         POINT TO PARM (LENGTH)
         LH    &LR,0(,&AR)              GET PARM LENGTH
         LA    &AR,2(,&AR)              POINT PAST LENGTH
         AGO   .INUSE
.FAKE$A  SPACE 2
*        DETERMINE WHETHER WE HAVE BEEN CALLED
*        AS A TSO CP OR THRU CALL.
         SPACE 1
         L     &R1,CVTPTR               CVTPTR
         USING CVT,&R1
         L     &R1,CVTTCBP              TCBWORDS
         DROP  R1
         L     &R1,4(,&R1)              TCB
         USING TCB,R1
*%%      TM    TCBTSFLG,TCBTSTSK        IS THIS TSO?                %%%
*%%      BNO   &IHBNX.C                 NO, SKIP                    %%%
         L     &R1,TCBJSCB              TCB.JSCB
         DROP  R1
         USING IEZJSCB,R1
         L     &R1,JSCBPSCB             JSCB.PSCB
         DROP  R1
         LA    &R0,0(,&R1)              CLEAR HIGH BYTE
         L     &R1,8(,&PARMREG)         POSSIBLE PSCB PTR
         LA    &R1,0(,&R1)              CLEAR HIGH BYTE
         TM    0(&PARMREG),X'80'        ONLY 1 PARM?
         BO    &IHBNX.E                 YES, // EXEC OR TSO CALL
         CR    &R0,&R1                  THIRD PARM -> PSCB?
         AIF   (('&ADDRREG' NE '') OR (&FKCALL)).SETCPR
         BE    &IHBNX.C                 YES, WERE CALLED AS A TSO CP
         AGO   .CONT5                   SKIP AROUND
.SETCPR  BNE   &IHBNX.E                 NO, NOT TSO CP
         SPACE 1
*        HAVE BEEN CALLED AS A CP.
         SPACE 1
         AIF   ('&ADDRREG' EQ '').NO$AR2
         L     &R1,0(,&PARMREG)         CBUF PTR
         LH    &LR,0(,&R1)              LENGTH OF CBUF
         LH    &AR,2(,&R1)              OFFSET TO FIRST NON-BLANK
         LA    &LR,0(&LR,&R1)           POINT PAST CBUF
         LA    &AR,4(&AR,&R1)           POINT TO FIRST NON-BLANK
         SR    &LR,&AR                  LENGTH OF PARMS
.NO$AR2  AIF   (&FKCALL).CONT4
         B     &IHBNX.C                 CONTINUE
         AGO   .CONT5
.CONT4   AIF   (NOT &FKCALL).NOFAKE1
         STH   &LR,&T$FAKE+4            SET FAKED LENGTH OF PARM
         LTR   &R1,&LR                  COPY LENGTH
         AIF   ('&TSFAKE(2)' EQ '').NOMXCK1
         CH    &R1,&TSFAKE(2)           PARM TOO BIG?
         BNH   *+L'*+4                  NO, OK
         LH    &R1,&TSFAKE(2)           TOO BIG, USE MAX
         LTR   &R15,&R15                TEST PARM LENGTH
.NOMXCK1 BNP   *+L'*+12                 SKIP IF NO PARM       >=====+
         BCTR  &R1,0                    -1 FOR EXECUTE              |
         EX    &R1,*+L'*                MOVE THE PARM TO WORKAREA   |
         MVC   &T$FAKE+6(*-*),0(&AR)    << EXECUTED >>              |
         LA    &R1,&T$FAKE+4            GET FAKE PARM ADDR    <=====+
         ST    &R1,&T$FAKE              STORE IT
         LA    &PARMREG,&T$FAKE         GET ADDR OF FAKED PARM
         MVI   &T$FAKE,X'80'            SET END OF LIST BIT
         B     &IHBNX.C                 CONTINUE
         AGO   .CONT5
.NOFAKE1 AIF   (NOT &FKCP).LOAD
.CONT5   SPACE 2
*        HAVE BEEN CALLED FROM BATCH, OR TSO CALL.
         SPACE 1
&IHBNX.E L     &AR,0(,&PARMREG)         POINT TO PARM LENGTH
         LH    &LR,0(,&AR)              GET LENGTH OF PARM
         LA    &AR,2(,&AR)              POINT PAST LENGTH
         AIF   (NOT &FKCP).NOFAKE2
*   CPPL=ADDR(CBUF,UPT,PSCB,ECT)
         LA    &R1,&T$FAKE              GET ADDR OF FAKE CBUF
         ST    &R1,CPPLCBUF             SET INTO CPPL                +0
         LR    &R1,&R0                  COPY PSCB ADDR
         ST    &R0,CPPLPSCB             SET INTO FAKE CPPL           +8
         MVC   CPPLUPT(4),52(&R1)       MOVE UPT ADDR INTO CPPL      +4
         L     &R1,48(,&R1)             PSCB.RLGB
         L     &R1,256(,&R1)            RLGB.ECT
         ST    &R1,CPPLECT              SET IN CPPL                 +12
         SPACE 1
*   CBUF=Y(CBUF_LEN,OFFSET_TO_NONBLANK),C'CMDNAME',C' ',C'OPERANDS'
         MVC   &T$FAKE+4(8),12(&R1)     MOVE CMD NAME TO CBUF
         MVI   &T$FAKE+4+8,C' '         PUT IN DELIMETER
         NI    28(&R1),X'7F'            TURN OFF "NO OPERANDS" BIT
         LTR   &LR,&LR                  ANY OPERANDS?
         BP    *+L'*+4                  YES, SKIP
         OI    28(&R1),X'80'            SET "NO OPERANDS" BIT IN ECT
         LA    &R1,8+1                  OFFSET TO FIRST NON-BLANK
         STH   &R1,&T$FAKE+2            SET IN FAKE CBUF
         LA    &R0,8+1+4(,&LR)          GET LENGTH OF CBUF
         STH   &R0,&T$FAKE              SET INTO FAKE CBUF
         AIF   ('&TSFAKE(2)' NE '').MAXCK
         LTR   &R1,&LR                  ANY OPERANDS?
         AGO   .NOMXCK2                 CONTINUE
.MAXCK   LR    &R1,&LR                  COPY PARM LENGTH
         CH    &R1,&TSFAKE(2)           PARM TOO BIG?
         BNH   *+L'*+4                  NO, OK
         LH    &R1,&TSFAKE(2)           TOO BIG, USE MAX
         LTR   &LR,&LR                  ANY OPERANDS?
.NOMXCK2 BNP   *+L'*+12                 NO, SKIP              >=====+
         BCTR  &R1,0                    -1 FOR EXECUTE              |
         MVC   &T$FAKE+4+8+1(0),0(&AR)  << EXECUTED >>              |
         EX    &R1,*-6                  MOVE THE PARM TO FAKE CBUF  |
         LA    &PARMREG,CPPL            POINT TO CPPL         <=====+
.NOFAKE2 SPACE 2
&NAME    SETC  '&IHBNX.C'
.LOAD    AIF   ('&LOAD' EQ '').NOLOAD
&X       SETA  1
.LOAD$LP AIF   ('&LOAD(&X)' EQ '').NOLOAD
         AIF   (NOT &ENVMVS).YESLOAD
&NAME    ENTR1I  &LOAD(&X),IKJPTGT,464
&NAME    ENTR1I  &LOAD(&X),IKJPUTL,444
&NAME    ENTR1I  &LOAD(&X),IKJGETL,348
&NAME    ENTR1I  &LOAD(&X),IKJPARS,524
&NAME    ENTR1I  &LOAD(&X),IKJDAIR,732
&NAME    ENTR1I  &LOAD(&X),IKJSTCK,472
&NAME    ENTR1I  &LOAD(&X),IKJSCAN,480
&NAME    ENTR1I  &LOAD(&X),IKJEHCIR,740
&NAME    ENTR1I  &LOAD(&X),IKJEHDEF,736
&NAME    ENTR1I  &LOAD(&X),IKJEFF02,976                            SDM
         AIF   (NOT &MVSCVT).YESLOAD    IT WAS NOT ONE OF THE ABOVE
&NAME    SETC  ''
.YESLOAD MNOTE *,'       LOAD  EPLOC==CL8''&LOAD(&X)'''
&NAME    LOAD  EPLOC==CL8'&LOAD(&X)'
&NAME    SETC  ''
.ADDRSAV ST    &R0,&LOAD(&X)
.SKIPASV SPACE 1
         AIF   ('&LOAD(&X)' NE 'IKJDAIR').NO$DAIR
&GDAIR   SETB  1                        DAIR LOADED
         AGO   .LOADNXT
.NO$DAIR AIF   ('&LOAD(&X)' NE 'IKJPARS').NO$PARS
&GPARSE  SETB  1                        PARSE WAS LOADED
&PARNAME SETC  'IKJPARS'
.NO$PARS ANOP
.LOADNXT ANOP
&X       SETA  &X+1
         AGO   .LOAD$LP
.NOLOAD  AIF   ('&PL' EQ '').NO$PL$1
&X       SETA  1
.PLLOOP  AIF   ('&PL(&X)' NE 'CSCAN').PL2
&CSPL    SETB  1
         AGO   .PLNEXT
.PL2     AIF   ('&PL(&X)' NE 'PARSE').PL3
&PARS    SETB  1
         AGO   .PLNEXT
.PL3     AIF   ('&PL(&X)' NE 'DAIR').PL4
&DAIR    SETB  1
         AGO   .PLNEXT
.PL4     AIF   ('&PL(&X)' NE 'IO').PL5
&IO      SETB  1
         AGO   .PLNEXT
.PL5     AIF   ('&PL(&X)' NE 'MESSAGE').PL6
&MSG     SETB  1
         AGO   .PLNEXT
.PL6     MNOTE 4,'PL=&PL(&X) UNKNOWN -- IGNORED'
.PLNEXT  ANOP
&X       SETA  &X+1
         AIF   (&X LE N'&PL).PLLOOP
.NO$PL$1 AIF   ('&PARSE(2)' EQ '').PLNOTM
&MSG     SETB  1
.PLNOTM  AIF   (NOT (&CSPL OR &PARS OR &DAIR OR &IO OR &MSG)).NOSETPL
&NAME    L     &R1,CPPLUPT              GET UPT PTR
&NAME    SETC  ''
         L     &R2,CPPLECT              GET ECT PTR
         LA    &R3,TSECB                GET ECB PTR
         SR    &R0,&R0                  GET A 0
         ST    &R0,TSECB                CLEAR ECB
         AIF   (NOT &CSPL).NOSETC
         STM   &R1,&R3,CSPL             INITIALIZE CSPL (UPT, ECT, ECB)
         ST    &R0,CSFLG                ZERO CSFLG
         LA    &R0,CSFLG
         ST    &R0,CSPLFLG
         LA    &R0,CSOA
         ST    &R0,CSPLOA
.NOSETC  AIF   (NOT &PARS).NOSETP
         STM   &R1,&R3,PPL              INITIALIZE PPL (UPT, ECT, ECB)
         LA    &R0,TSPARANS             PTR TO PARSE ANSWER PLACE
         ST    &R0,PPLANS
         ST    &R13,PPLUWA              PARSE USER WORK AREA PTR
         XC    TSPARANS(4),TSPARANS     AVOID DUPLICATE IKJRLSA
.NOSETP  AIF   (NOT &DAIR).NOSETD
         STM   &R1,&R3,DAPL             INITIALIZE DMPL (UPT, ECT, ECB)
         MVC   DAPLPSCB(4),CPPLPSCB
.NOSETD  AIF   (NOT &IO).NOSETI
         STM   &R1,&R3,IOPL             INITIALIZE IOPL (UPT, ECT, ECB)
.NOSETI  AIF   (NOT &MSG).NOSETM
         ST    &R3,MPLECB               INIT MPL ECB PTR
         LA    &R0,CPPL
         ST    &R0,MPLCPPL
         LA    &R0,MPLCSECT             PTR TO MSG CSECT
         ST    &R0,MPLCSECP
         XC    MPLSW(MPLZL),MPLSW       INITIALIZE REMAINING MPL TO 0
.NOSETM  ANOP
.NOSETPL AIF   ('&PARSE(1)' EQ '').NOPARSE
         SPACE 1
*        PARSE THE COMMAND LINE.
         SPACE 1
         MNOTE *,'       TSPARSE CBUF=(CPPLCBUF,I),PCL=(=V(&PARSE(1)),I$
               ),'
         MNOTE *,'               SYNAD=&PARSE(2),ENTRY=&PARNAME'
         TSPARSE  CBUF=(CPPLCBUF,I),PCL=(=V(&PARSE(1)),I),             X
               SYNAD=&PARSE(2),ENTRY=&PARNAME
&NAME    SETC  ''
         AIF   ('&PARSE(2)' EQ '').NOPARSE   NO ERROR ANALYSIS ROUTINE
&NAME    SETC  '&IHBNX.P'
         B     &NAME                    SKIP AROUND PARSE ERR ANALYSIS
         SPACE 1
*        PARSE ERROR ANALYSIS SUBROUTINE.
         SPACE 1
         TSPARERR
         SPACE 1
.NOPARSE AIF   ('&NAME' EQ '').NONAME
&NAME    DS    0H
.NONAME  ANOP
.INUSE   OACINUSE
         SPACE 1
         AIF   ('&PL' EQ '').MEND
         AIF   ('&GET2' NE '').PLOK2
         MNOTE 8,'*** PL= INVALID WITHOUT SECOND OPERAND OF GETMAIN='
         MEXIT
.PLOK2   EJECT
&GET2    DSECT
         DS    18F                      SAVE AREA
TSECB    DS    F                        ECB FOR TSO SERVICES
         SPACE 1
         TSCPPL
         AIF   ('&TSFAKE' NE 'YES').NOFAKED
         SPACE 1
&T$FAKE  DS    2H,CL256                 AREA FOR FAKE CBUF
         AIF   ('&PRINT' NE 'NOGEN').NOFAKED
         PRINT NOGEN                    SUPPRESS THE DSECTS
.NOFAKED AIF   (NOT &CSPL).NOTCSPL
         SPACE 1
         TSCSPL
.NOTCSPL AIF   (NOT &PARS).NOTPARS
         SPACE 1
         TSPPL
.NOTPARS AIF   (NOT &DAIR).NOTDAIR
         SPACE 1
         TSDAPL
DAPBAREA DS    22F                      AREA FOR DAIR PARAMETER BLOCK
         SPACE 1
         TSDMPL
.NOTDAIR AIF   (NOT &IO).NOTIO
         SPACE 1
         TSIOPL
.NOTIO   AIF   (NOT &MSG).NOTMSG
         SPACE 1
         TSMPL
.NOTMSG  AIF   ('&PRINT' NE 'NOGEN').NOTMSGX
         PRINT GEN
.NOTMSGX AIF   ('&LOAD' EQ '').NOLOAD2
         SPACE 1
&X       SETA  1
.NXTLOAD AIF   (&X GT N'&LOAD).NOLOAD2
&LOAD(&X) DS   A
&X       SETA  &X+1
         AGO   .NXTLOAD
.NOLOAD2 AIF   ('&MACRO' NE 'YES').NOMACRO
         SPACE 1
*        DYNAMIC STORAGE DEFINED BY USER TSWORK MACRO.
         SPACE 1
         TSWORK
         SPACE 1
&GET1    EQU   (((*-&GET2)+7)/8)*8      LNTH OF DYNAMIC AREA TO GETMAIN
         SPACE 1
.NOMACRO AIF   (NOT &DAIR).NODAPBS
         AIF   (&GDAIRM).NODAPBS
&GDAIRM  SETB  1
         AIF   ('&PRINT' NE 'NOGEN').GEN4
         PRINT NOGEN                    SAVE SOME PAPER
.GEN4    EJECT
         IKJDAP08
DAPB08L  EQU   *-DAPB08
         SPACE 2
         IKJDAP18
DAPB18L  EQU   *-DAPB18
         SPACE 2
         IKJDAP1C
DAPB1CL  EQU   *-DAPB1C
         SPACE 2
         IKJDAP30
DAPB30L  EQU   *-DAPB30
         AIF   ('&PRINT' NE 'NOGEN').NODAPBS
         PRINT GEN                      RESTORE
         SPACE 1
.NODAPBS ANOP
&NFS     CSECT
         SPACE 1
.MEND    MEND
         MACRO
&NFS     HEX   &TO,&FROM,&L,&LEN=,&HEXTAB=,&BYTE=C' ',&DIGITS=
         GBLC  &HEXTAB#
         LCLA  &LT                      UNPK "TO" LENGTH
         LCLA  &LF                      UNPK "FROM" LENGTH
         LCLA  &LTR                     TR "TO" LENGTH
         LCLA  &LL                      &LEN ONE WAY OR ANOTHER
         LCLC  &F1,&F2,&T1,&T2,&LX
&F1      SETC  '&FROM(1)'               FOR SHORTER STRING LATER
&F2      SETC  '&FROM(2)'               FOR SHORTER STRING LATER
&T1      SETC  '&TO(1)'                 FOR SHORTER STRING LATER
&T2      SETC  '&TO(2)'                 FOR SHORTER STRING LATER
&LX      SETC  '&L&LEN'                 GET LENGTH USING EITHER METHOD
         AIF   ('&LX' EQ '').DEFLEN     LENGTH WILL DEFAULT TO 4
&LL      SETA  &LX                      GET IT
         AGO   .OKLEN
.DEFLEN  ANOP
&LL      SETA  4                        SET THE DEFAULT LENGTH
.OKLEN   AIF   ('&HEXTAB' EQ '').OKHEX1
&HEXTAB# SETC  '&HEXTAB'
.OKHEX1  AIF   ('&HEXTAB#' NE '').OKHEX2
&HEXTAB# SETC  'HEXTAB'
.OKHEX2  ANOP
&LT      SETA  &LL*2
         AIF   ('&DIGITS' EQ '').OKDIGIT
&LT      SETA  &DIGITS
.OKDIGIT AIF   (N'&TO NE 2).TO1
         AIF   (N'&FROM NE 2).T2F1
&NFS     UNPK  &T1.(&LT+1,&T2),&F1.(&LL+1,&F2)
         TR    &T1.(&LT,&T2),&HEXTAB#
         MVI   &T1+&LT.(&T2),&BYTE
         AGO   .DONE
.T2F1    AIF   (N'&FROM NE 1).ERRF
&NFS     UNPK  &T1.(&LT+1,&T2),&FROM.(&LL+1)
         TR    &T1.(&LT,&T2),&HEXTAB#
         MVI   &T1+&LT.(&T2),&BYTE
         AGO   .DONE
.TO1     AIF   (N'&TO NE 1).ERRT
         AIF   (N'&FROM NE 2).T1F1
&NFS     UNPK  &TO.(&LT+1),&F1.(&LL+1,&F2)
         TR    &TO.(&LT),&HEXTAB#
         MVI   &TO+&LT,&BYTE
         AGO   .DONE
.T1F1    AIF   (N'&FROM NE 1).ERRF
&NFS     UNPK  &TO.(&LT+1),&FROM.(&LL+1)
         TR    &TO.(&LT),&HEXTAB#
         MVI   &TO+&LT,&BYTE
         AGO   .DONE
.ERRF    MNOTE 8,'ERROR IN "FROM" PARAMETER, MACRO TERMINATED'
         MEXIT
.ERRT    MNOTE 8,'ERROR IN "TO" PARAMETER, MACRO TERMINATED'
         MEXIT
.DONE    SPACE 1
         MEND
         MACRO
&NFS     ID    &ID,&OPT,&DATE=,&TIME=
         GBLC  &$$DATE1
         LCLC  &XDATE,&XTIME
         LCLA  &L
&L       SETA  K'&ID
         AIF   ('&OPT' EQ 'ASIS').ASIS
         AIF   ('&OPT' NE 'NODATE').DATE
.ASIS    ANOP
&NFS     DC    AL1(&L),C'&ID'
         MEXIT
.DATE    $$ASM
&XDATE   SETC  '&$$DATE1'
         AIF   ('&DATE' EQ '').OKDATE
&XDATE   SETC  '&DATE'                  USE WHAT HE WANTS
.OKDATE  ANOP
&L       SETA  &L+K'&XDATE+2
         AIF   ('&OPT' NE 'NOTIME').TIME
&NFS     DC    AL1(&L),C'&ID  &XDATE'
         MEXIT
.TIME    ANOP
&XTIME   SETC  '&SYSTIME'               DEFAULT TO CURRENT TIME
         AIF   ('&TIME' EQ '').OKTIME   HE DIDN'T SPECIFY, USE CURRENT
&XTIME   SETC  '&TIME'                  USE WHAT HE WANTS
.OKTIME  ANOP
&L       SETA &L+K'&XTIME+1             =1+8
         AIF   ('&OPT' NE '').BADOPT
&NFS     DC    AL1(&L),C'&ID  &XDATE &XTIME'
         MEXIT
.BADOPT  MNOTE 0,'*** (ID MACRO) OPT=&OPT IS INVALID, IGNORED.'
         MNOTE *,'(MUST BE NULL, "NOTIME", "NODATE", OR "ASIS")'
         MEND
         MACRO
         OACDROP &PARMS
         GBLC  &USELAB(16)        SAVED PROGRAM LABELS
         GBLC  &USEREG(16)        SAVED REGISTER TABLE
         LCLA  &UNDX,&II          USE INDICES,TEMP USAGE
         LCLA  &PNDX,&DNDX        INPUT PARM,DROP STRING INDICES
         LCLB  &GOTREG,&DROPALL   HAVE REGS TO DROP,DROP ALL TO DO
         LCLC  &R(4),&B(4)        REGS TO DROP,PREVIOUS BASES FOR REGS
         LCLC  &BLANKS            BLANKS TO PAD DROP LINE TO COMMENTS
&DROPALL SETB  ((N'&SYSLIST EQ 0) OR ('&PARMS' EQ '')) SET DROPALL FLAG
.LP#SYS  AIF   (&DROPALL).LP#SAV  BIF DROP ALL IN PROGRESS
         AIF   (&PNDX GE N'&SYSLIST).CK#DROP LOOP TIL DONE WITH REGS
&PNDX    SETA  &PNDX+1            UP THE COMMA/REG INDEX
&UNDX    SETA  0                  RE-INITIALIZE USE ARRAY INDEX
.LP#SAV  ANOP                     VALID DROP REG CHECK LOOP
&UNDX    SETA  &UNDX+1            UP THE USE ARRAY COUNT
         AIF   (&DROPALL).CK#ALL  BIF DROP ALL IN PROGRESS
         AIF   ('&USEREG(&UNDX)' EQ '&SYSLIST(&PNDX)').DROP#R BIF MATCH
         AIF   (&UNDX LT 16).LP#SAV LOOP FOR ALL ENTRIES IF NEEDED
         MNOTE 4,'REGISTER &SYSLIST(&PNDX) WAS NOT A USNGX OPERAND'
         AGO   .LP#SYS            CONTINUE
.CK#ALL  AIF   (&UNDX GT 16).CK#DROP BIF END OF SAVE TABLE/CHECK DROPS
         AIF   ('&USEREG(&UNDX)'  EQ '').LP#SAV BIF EMPTY SLOT
.DROP#R  AIF   (&DNDX EQ 0).DROP$R BIF NO PREVIOUS REGISTER/BASE
&R(&DNDX) SETC '&R(&DNDX)'.','    APPEND COMMA AFTER PREVIOUS REG
&B(&DNDX) SETC '&B(&DNDX)'.','    APPEND COMMA AFTER PREVIOUS BASE
.DROP$R  ANOP
&DNDX    SETA  &DNDX+1            UP THE DROP STRING INDEX
&R(&DNDX) SETC '&USEREG(&UNDX)'   GET PREVIOUS REGISTER
&B(&DNDX) SETC '&USELAB(&UNDX)'   GET PREVIOUS BASE
&USEREG(&UNDX) SETC ''            BLANK THE SAVE TABLE REG FIELD
&USELAB(&UNDX) SETC ''            BLANK THE SAVE TABLE BASE FIELD
         AIF   (&DNDX GE 4).DO#DR BIF DROP LINE FULL
&GOTREG  SETB  1                  SAY HAVE SOMETHING TO DROP
         AGO   .LP#SYS            GO CHECK FOR &SYSLIST/TABLE END
.CK#DROP AIF   (NOT &GOTREG).EXIT SKIP THE DROP IF NOTHING TO DO
.* NOTE THAT THIS MACRO ASSUMES OPERAND/COMMENT COLUMNS 16 AND 35.
.DO#DR   ANOP
&BLANKS  SETC  ' '                SET ONE BLANK IN CASE TOO LONG
&II      SETA  (35-16)-K'&R(1)-K'&R(2)-K'&R(3)-K'&R(4) BLANK COUNT
         AIF   (&II LE 1).DO$DR   BIF ONE BLANK CORRECT
&BLANKS  SETC  '                  '(1,&II) ELSE SET CORRECT NUMBER
.DO$DR   DROP  &R(1)&R(2)&R(3)&R(4)&BLANKS&B(1)&B(2)&B(3)&B(4)
&GOTREG  SETB  0                  NOTHING TO DROP
.DROP#CL AIF   (&DNDX EQ 0).LP#SYS BIF CLEARING DONE
&R(&DNDX) SETC ''                 BLANK REG FIELD
&B(&DNDX) SETC ''                 BLANK BASE FIELD
&DNDX    SETA  &DNDX-1            DECREMENT INDEX
         AGO   .DROP#CL           CONTINUE
.EXIT    MEND
         MACRO
&LABEL   OACINNER &DUMMY,&F=,&FO=+0,&T=,&TO=+0,&L=4,&OP=MA,            X
               &SETCC=NO,&RS=R0,&RT=R15,&COM=''
         GBLC  &OACNAME
         LCLC  &S,&SRC,&SRC1,&SRCT
         LCLB  &SRCI
         LCLC  &G,&TGT,&TGT1,&TGTT
         LCLB  &TGTI
         LCLC  &C,&COMM,&ARGS,&OPR,&LEN
         LCLA  &P
         LCLB &CC
         AIF   ('&F' EQ '').MEND
&CC      SETB  ('&SETCC' EQ 'YES')
&OACNAME SETC  '&LABEL'
&LEN     SETC  '&L'
&COMM    SETC  '&COM'(2,K'&COM-2) STRIP OFF QUOTES
&G       SETC  '&T'
.TGT     ANOP
&C       SETC  '&G'(1,1)          GET FIRST CHAR OF SOURCE
         AIF   ('&C' NE '(').TGTA MUST BE A FORM ADDRESS
         AIF   (K'&G LT 5).TGTR   MUST BE R FORM ADDRESS
&C       SETC  '&G'(K'&G-2,3)     GET LAST THREE CHARS
         AIF   ('&C' NE ',I)').TGTR MUST BE R FORM ADDRESS
&TGTI    SETB  1                  MARK AS INDIRECT
&G       SETC  '&G'(2,K'&G-4)     EXTRACT ADDRESS
         AGO   .TGT               GO PROCESS THAT
.TGTR    ANOP                     ADDRESS IS R FORM
         AIF   ('&TO' EQ '+0').TGTR1 CHECK FOR OFFSET
         MNOTE 4,'ENCOUNTERED OFFSET FROM (R) FORM ADDRESS'
         MNOTE 4,'WILL FORCE ADDRESS FORM'
&G       SETC  '0&G'              FORCE ADDR FORM
         AGO   .TGTA              IT IS ADDR FORM
.TGTR1   AIF   (NOT &TGTI).TGTR2
         MNOTE 4,'ENCOUNTERED INDIRECT FROM (R)'
         MNOTE 4,'WILL FORCE INDIRECT FROM 0(R)'
&G       SETC  '0&G'
         AGO   .TGTA              DO ADDRESS SCAN
.TGTR2   ANOP                     ITS REALLY (R) FORM
&TGTT    SETC  'R'                MARK TYPE
&TGT     SETC  '&G'(2,K'&G-2)     STRIP OFF PARENS
         AGO   .TGTEND
.TGTA    ANOP                     ADDRESS FORM
&C       SETC  '&G'(K'&G,1)       LOOK AT LAST CHAR
         AIF   ('&C' EQ ')').TGTAR IT IS A O(R) FORM ADDRESS
&TGTT    SETC  'A'
&TGT     SETC  '&G'
         AIF   ('&TO' EQ '+0').TGTEND
&TGT     SETC  '&G.&TO'
         AGO   .TGTEND
.TGTAR   ANOP                     ITS A 0(R) FORM ADDRESS
&P       SETA  K'&G               SCAN FOR THE LEFT PAREN
.TGTLP   AIF   (&P EQ 0).TGTSNTX
&C       SETC  '&G'(&P,1)
&P       SETA  &P-1
         AIF   ('&C' NE '(').TGTLP
&TGTT    SETC  'AR'
&TGT1    SETC  '&G'(&P+2,K'&G-&P+1) SAVE REG AND RIGHT PAREN
         AIF   ('&TO' NE '+0').TGTAR1
&TGT     SETC  '&G'(1,&P+1)
         AGO   .TGTEND
.TGTAR1  ANOP  MUST ADD OFFSETS
&TGT     SETC  '&G'(1,&P)
&TGT     SETC  '&TGT.&TO.('
         AGO   .TGTEND
.TGTSNTX MNOTE 12,'ILLEGAL SYNTAX: &T'
         MEXIT
.TGTEND  ANOP
&C       SETC  '&TGT  '(1,2)
         AIF   ('&C' NE '0+').TGTEND1
&TGT     SETC  '&TGT'(3,K'&TGT-2)
.TGTEND1 ANOP
&S       SETC  '&F'
.SRC     ANOP
&C       SETC  '&S'(1,1)          GET FIRST CHAR OF SOURCE
         AIF   ('&C' NE '(').SRCA MUST BE A FORM ADDRESS
         AIF   (K'&S LT 5).SRCR   MUST BE R FORM ADDRESS
&C       SETC  '&S'(K'&S-2,3)     GET LAST THREE CHARS
.* BREAK
         AIF   ('&C' NE ',I)').SRCR MUST BE R FORM ADDRESS
&SRCI    SETB  1                  MARK AS INDIRECT
&S       SETC  '&S'(2,K'&S-4)     EXTRACT ADDRESS
         AGO   .SRC               GO PROCESS THAT
.SRCR    ANOP                     ADDRESS IS R FORM
         AIF   ('&FO' EQ '+0').SRCR1 CHECK FOR OFFSET
         MNOTE 4,'ENCOUNTERED OFFSET FROM (R) FORM ADDRESS'
         MNOTE 4,'WILL FORCE ADDRESS FORM'
&S       SETC  '0&S'              FORCE ADDR FORM
         AGO   .SRCA              IT IS ADDR FORM
.SRCR1   AIF   (NOT &SRCI).SRCR2
         MNOTE 4,'ENCOUNTERED INDIRECT FROM (R)'
         MNOTE 4,'WILL FORCE INDIRECT FROM 0(R)'
&S       SETC  '0&S'
         AGO   .SRCA              DO ADDRESS SCAN
.SRCR2   ANOP                     ITS REALLY (R) FORM
&SRCT    SETC  'R'                MARK TYPE
&SRC     SETC  '&S'(2,K'&S-2)     STRIP OFF PARENS
         AGO   .SRCEND
.SRCA    ANOP                     ADDRESS FORM
&C       SETC  '&S'(K'&S,1)       LOOK AT LAST CHAR
         AIF   ('&C' EQ ')').SRCAR IT IS A O(R) FORM ADDRESS
&SRCT    SETC  'A'
&SRC     SETC  '&S'
         AIF   ('&FO' EQ '+0').SRCEND
&SRC     SETC  '&S.&FO'
         AGO   .SRCEND
.SRCAR   ANOP                     ITS A 0(R) FORM ADDRESS
&P       SETA  K'&S               SCAN FOR THE LEFT PAREN
.SRCLP   AIF   (&P EQ 0).SRCSNTX
&C       SETC  '&S'(&P,1)
&P       SETA  &P-1
         AIF   ('&C' NE '(').SRCLP
&SRCT    SETC  'A'
&SRC1    SETC  '&S'(&P+2,K'&S-&P+1) SAVE REG AND RIGHT PAREN
         AIF   ('&FO' NE '+0').SRCAR1
&SRC     SETC  '&S'
&SRC1    SETC  ''
         AGO   .SRCEND
.SRCAR1  ANOP  MUST ADD OFFSETS
&SRC     SETC  '&S'(1,&P)
&SRC     SETC  '&SRC.&FO.(&SRC1'
&SRC1    SETC  ''
         AGO   .SRCEND
.SRCSNTX MNOTE 12,'ILLEGAL SYNTAX: &F'
         MEXIT
.SRCEND  ANOP
&C       SETC  '&SRC  '(1,2)
         AIF   ('&C' NE '0+').SRCEND1
&SRC     SETC  '&SRC'(3,K'&SRC-2)
.SRCEND1 AIF   (NOT &TGTI).SIN    CHECK FOR TARGET INDIRECT
&ARGS    SETC  '&RT,&TGT.&TGT1'   BUILD OPERANDS AND COMMENT
         AIF   (K'&ARGS GE 18).TI1
&ARGS    SETC  '&ARGS                   '(1,18)
.TI1     ANOP
&ARGS    SETC  '&ARGS &COMM'      TACK ON THE COMMENTS
         AIF   (K'&ARGS GT 55).TI2 CHECK FOR OVERFLOW
&OACNAME L     &ARGS
&COMM    SETC  ''                 COMMENT ONLY ON FIRST LINE
         AGO   .TI3
.TI2     ANOP                     NO ROOM FOR COMMENT
&OACNAME L     &RT,&TGT.&TGT1
.TI3     ANOP
&OACNAME SETC  ''
&TGT     SETC  '0('               NEW TARGET
&TGT1    SETC  '&RT)'
&TGTT    SETC  'AR'               NEW TARGET TYPE
&TGTI    SETB  0
.SIN     AIF   (NOT &SRCI).OP     CHECK FOR SOURCE INDARECT
         AIF   ('&OP' EQ 'MA').SIMA SPECIAL CASE FOR MA, SRCI
         AIF   ('&OP' NE 'MAC').SIN1 MAC MAY ALSO BE SPECIAL
         AIF   ('&TGTT' EQ 'A' OR '&TGTT' EQ 'AR').SIMAC
.SIN1    ANOP
&ARGS    SETC  '&RS,&SRC'         BUILD OPERANDS AND COMMENT
         AIF   (K'&ARGS GE 18).SIN2
&ARGS    SETC  '&ARGS                   '(1,18)
.SIN2    ANOP
.* BREAK
&ARGS    SETC  '&ARGS &COMM'      TACK ON THE COMMENTS
         AIF   (K'&ARGS GT 55).SIN3 CHECK FOR OVERFLOW
&OACNAME L     &ARGS
&COMM    SETC  ''                 COMMENT ONLY ON FIRST LINE
         AGO   .SIN4
.SIN3    ANOP                     NO ROOM FOR COMMENT
&OACNAME L     &RS,&SRC
.SIN4    ANOP
&OACNAME SETC  ''
&SRC     SETC  '0(&RS)'           NEW SOURCE
&SRCT    SETC  'A'                NEW SOURCE TYPE
&SRCI    SETB  0
         AGO   .OP
.SIMA    ANOP
&SRCI    SETB  0
         AIF   ('&TGTT' EQ 'R').L GENERATE LOAD INSTRUCTION
         AGO   .MVC               MA SRCI IS A MVC
.SIMAC   ANOP                     MAC SRCI IS MVC AND MVI
         AIF   ('&TGTT' EQ 'AR').SIMACAR
&C       SETC  '&TGT.(4),&SRC'     A FORM TARGET
         AGO   .SIMAC1
.SIMACAR ANOP
&C       SETC  '&TGT.4,&TGT1,&SRC' AR FROM TARGET
.SIMAC1  ANOP
&ARGS    SETC  '&C'               BUILD ARGS AND COMMENT
         AIF   (K'&ARGS GE 18).SIMAC2
&ARGS    SETC  '&ARGS                   '(1,18)
.SIMAC2  ANOP
&ARGS    SETC  '&ARGS &COMM'      TACK ON THE COMMENTS
         AIF   (K'&ARGS GT 55).SIMAC3 CHECK FOR OVERFLOW
&OACNAME MVC   &ARGS
&COMM    SETC  ''                 COMMENT ONLY ON FIRST LINE
         AGO   .SIMAC4
.SIMAC3  ANOP                     NO ROOM FOR COMMENT
&OACNAME MVC   &C
.SIMAC4  ANOP
&OACNAME SETC  ''
         MVI   &TGT.&TGT1,0       CLEAR HIGH BYTE
&SRC     SETC  '&TGT,&TGT1'
         AIF   (&CC).OC
         MEXIT
.OP      ANOP
&C       SETC  '&TGTT'(1,1)
         AIF   ('&C' EQ 'R' AND '&SRCT' EQ 'R').OPRR   RR FORM INST
         AIF   ('&C' EQ 'R' AND '&SRCT' EQ 'A').OPRA
         AIF   ('&C' EQ 'A' AND '&SRCT' EQ 'R').OPAR
         AIF   ('&OP' EQ 'MA').LAST AA FORM
         AIF   ('&OP' EQ 'MAC').LAST LA ST
         AIF   ('&OP' EQ 'M').MVC
         AIF   ('&OP' EQ 'O').OC
         AIF   ('&OP' EQ 'X').XC
         AIF   ('&OP' EQ 'N').NC
         AIF   ('&OP' EQ 'CL').CLC
&LEN     SETC  '1'
         AIF   ('&OP' EQ 'MVI').MVI
         AIF   ('&OP' EQ 'OI').OI
         AIF   ('&OP' EQ 'XI').XI
         AIF   ('&OP' EQ 'NI').NI
         AIF   ('&OP' EQ 'CLI').CLI
         AIF   ('&OP' EQ 'TM').TM
.BADOP   MNOTE 12,'&OP IS UNSUPORTED WITH SUPPLIED ARGS'
         MEXIT
.OPRR    AIF   ('&OP' EQ 'MA').LR
         AIF   ('&OP' EQ 'MAC').LA
         AIF   ('&LEN' EQ '4').OPRR1
.RLENERR MNOTE 12,'INVALID LENGTH WITH R FORM ADDRESS'
         MEXIT
.OPRR1   AIF   ('&OP' EQ 'M').LR
         AIF   ('&OP' EQ 'O').OR
         AIF   ('&OP' EQ 'X').XR
         AIF   ('&OP' EQ 'N').NR
         AIF   ('&OP' EQ 'CL').CR
         AGO   .BADOP
.OPRA    AIF   ('&OP' EQ 'MA').LA
         AIF   ('&OP' EQ 'MAC').LA
         AIF   ('&OP' NE 'M').OPRA1
         AIF   ('&LEN' EQ '1').IC
.* BREAK
         AIF   ('&LEN' EQ '2').LH
         AIF   ('&LEN' EQ '4').L
         AGO   .RLENERR
.OPRA1   AIF   ('&LEN' EQ '4').OPRA4
         AIF   ('&LEN' NE '2').RLENERR
         AIF   ('&OP' EQ 'CL').CH
         AGO   .BADOP
.OPRA4   AIF   ('&OP' EQ 'O').O
         AIF   ('&OP' EQ 'X').X
         AIF   ('&OP' EQ 'N').N
         AIF   ('&OP' EQ 'CL').C
         AGO   .BADOP
.OPAR    AIF   ('&OP' EQ 'MA').ST
         AIF   ('&OP' EQ 'MAC').STMVI ST THEN MVI
         AIF   ('&OP' NE 'M').BADOP
         AIF   ('&LEN' EQ '1').STC
         AIF   ('&LEN' EQ '2').STH
         AIF   ('&LEN' EQ '4').ST
         AGO   .RLENERR
.LR      AIF   (&CC).LTR
         AIF   ('&TGT.&TGT1' NE '&SRC').LR1
         AIF   ('&OACNAME' EQ '').LR0
&OACNAME DC    0H'0'
         MEXIT
.LR1     ANOP
&OPR     SETC  'LR'
         AGO   .RR
.LTR     ANOP
&OPR     SETC  'LTR'
&CC      SETB  0
         AGO   .RR
.OR      ANOP
&OPR     SETC  'OR'
&CC      SETB  0
         AGO   .RR
.XR      ANOP
&OPR     SETC  'XR'
&CC      SETB  0
         AGO   .RR
.NR      ANOP
&OPR     SETC  'NR'
&CC      SETB  0
         AGO   .RR
.CR      ANOP
&OPR     SETC  'CR'
&CC      SETB  0
         AGO   .RR
.MVI     ANOP
&OPR     SETC  'MVI'
         AGO   .SI
.NI      ANOP
&OPR     SETC  'NI'
&CC      SETB  0
         AGO   .SI
.OI      ANOP
&OPR     SETC  'OI'
&CC      SETB  0
         AGO   .SI
.XI      ANOP
&OPR     SETC  'XI'
&CC      SETB  0
         AGO   .SI
.CLI     ANOP
&OPR     SETC  'CLI'
&CC      SETB  0
         AGO   .SI
.TM      ANOP
&OPR     SETC  'TM'
&CC      SETB  0
         AGO   .SI
.IC      ANOP
&OPR     SETC  'IC'
         AGO   .SR
.L       ANOP
&OPR     SETC  'L'
         AGO   .SR
.LH      ANOP
.* BREAK
&OPR     SETC  'LH'
         AGO   .SR
.LA      ANOP
&OPR     SETC  'LA'
&CC      SETB  0
&C       SETC  '&SRC'(1,2)
         AIF   ('&C' NE '0(').SR
         AIF   ('&OP' EQ 'MAC').SR
&SRC     SETC  '&SRC'(3,K'&SRC-3)
&SRCT    SETC  'R'
         AGO   .LR
.CH      ANOP
&OPR     SETC  'CH'
&CC      SETB  0
         AGO   .SR
.O       ANOP
&OPR     SETC  'O'
&CC      SETB  0
         AGO   .SR
.X       ANOP
&OPR     SETC  'X'
&CC      SETB  0
         AGO   .SR
.N       ANOP
&OPR     SETC  'N'
&CC      SETB  0
         AGO   .SR
.C       ANOP
&OPR     SETC  'C'
&CC      SETB  0
         AGO   .SR
.STC     ANOP
&OPR     SETC  'STC'
         AGO   .RS
.STH     ANOP
&OPR     SETC  'STH'
         AGO   .RS
.ST      ANOP
&OPR     SETC  'ST'
         AGO   .RS
.MVC     ANOP
&OPR     SETC  'MVC'
         AGO   .SS
.OC      ANOP
&OPR     SETC  'OC'
&CC      SETB  0
         AGO   .SS
.XC      ANOP
&OPR     SETC  'XC'
&CC      SETB  0
         AGO   .SS
.NC      ANOP
&OPR     SETC  'NC'
&CC      SETB  0
         AGO   .SS
.CLC     ANOP
&OPR     SETC  'CLC'
&CC      SETB  0
         AGO   .SS
.SI      ANOP
.RR      ANOP
.SR      ANOP
&ARGS    SETC  '&TGT.&TGT1,&SRC'
         AGO   .INSTGEN
.RS      ANOP
&ARGS    SETC  '&SRC,&TGT.&TGT1'
         AGO   .INSTGEN
.SS      AIF   ('&TGTT' EQ 'AR').SSAR
&ARGS    SETC  '&TGT.(&LEN),&SRC'
         AGO   .INSTGEN
.SSAR    ANOP
&ARGS    SETC  '&TGT.&LEN,&TGT1,&SRC'
.INSTGEN ANOP
&C       SETC  '&ARGS'            BUILD OPERANDS AND COMMENT
         AIF   (K'&C GE 18).INSTGN1
&C       SETC  '&C                   '(1,18)
.INSTGN1 ANOP
.* BREAK
&C       SETC  '&C &COMM'         TACK ON THE COMMENTS
         AIF   (K'&C GT 55).INSTGN2 CHECK FOR OVERFLOW
&OACNAME &OPR  &C
&COMM    SETC  ''                 COMMENT ONLY ON FIRST LINE
         AGO   .INSTGN3
.INSTGN2 ANOP                     NO ROOM FOR COMMENT
&OACNAME &OPR  &ARGS
.INSTGN3 ANOP
&OACNAME SETC  ''
         AIF   (&CC).INSTGN4      CHECK FOR SET CONDITION CODE
         MEXIT
.INSTGN4 AIF   ('&TGTT' EQ 'R').INSTGNR
&ARGS    SETC  '&ARGS'(1,K'&ARGS-K'&SRC) STRIP OFF OLD SRC
         CLC   &ARGS.&TGT.&TGT1
         MEXIT
.INSTGNR ANOP
         LTR   &TGT,&TGT
         MEXIT
.LAST    AIF   ('&OP' EQ 'MAC').LAST0
&C       SETC  '&SRC'(1,2)
         AIF   ('&C' NE '0(').LAST0
&SRC     SETC  '&SRC'(3,K'&SRC-3)
&SRCT    SETC  'R'
         AGO   .ST
.LAST0   ANOP
&ARGS    SETC  '&RS,&SRC'         BUILD OPERANDS AND COMMENT
         AIF   (K'&ARGS GE 18).LAST1
&ARGS    SETC  '&ARGS                   '(1,18)
.LAST1   ANOP
&ARGS    SETC  '&ARGS &COMM'      TACK ON THE COMMENTS
         AIF   (K'&ARGS GT 55).LAST2 CHECK FOR OVERFLOW
&OACNAME LA    &ARGS
&COMM    SETC  ''                 COMMENT ONLY ON FIRST LINE
         AGO   .LAST3
.LAST2   ANOP                     NO ROOM FOR COMMENT
&OACNAME LA    &RS,&SRC
.LAST3   ANOP
&OACNAME SETC  ''
         ST    &RS,&TGT.&TGT1
         MEXIT
.STMVI   ANOP
&ARGS    SETC  '&SRC,&TGT.&TGT1'  BUILD OPERANDS AND COMMENT
         AIF   (K'&ARGS GE 18).STMVI1
&ARGS    SETC  '&ARGS                   '(1,18)
.STMVI1  ANOP
&ARGS    SETC  '&ARGS &COMM'      TACK ON THE COMMENTS
         AIF   (K'&ARGS GT 55).STMVI2 CHECK FOR OVERFLOW
&OACNAME ST    &ARGS
&COMM    SETC  ''                 COMMENT ONLY ON FIRST LINE
         AGO   .STMVI3
.STMVI2  ANOP                     NO ROOM FOR COMMENT
&OACNAME ST    &SRC,&TGT.&TGT1
.STMVI3  ANOP
&OACNAME SETC  ''
         MVI   &TGT.&TGT1,0       CLEAR HIGH BYTE
         MEXIT
         AIF   (NOT &CC).MEND
&SRC     SETC  '&TGT.&TGT1'
&SRCT    SETC  'A'
&LEN     SETC  '4'
         AGO   .CLC
.MEND    MEND
         MACRO
         OACINUSE &DUMMY,&PRINT=
         GBLA  &OACPRTS
         GBLB  &OACPRTF
         GBLC  &OACPRT,&OACPRTG,&OACSTMX,&OACSTER
         GBLC  &OACNAME
         GBLC  &USELAB(16),&USEREG(16)  PGM LABELS,REGISTERS USED
         LCLA  &UCNT                    USE INDEX
         LCLB  &GOTREG                  WHETHER WE FOUND REGS IN USE
         AIF   ((T'&PRINT EQ 'O') AND                                  @
               (NOT &OACPRTF)).GO#USE   SKIP PUSH IF NOT NEEDED
         OACPRTPM PRINT=&PRINT
.GO#USE  SPACE 1
         MNOTE *,'THE FOLLOWING REGISTER(S) ARE IN USE:'
         SPACE 1
.USELOOP ANOP                           USED REGS LOOP
&UCNT    SETA  &UCNT+1                  UP THE USE INDEX
         AIF   ('&USEREG(&UCNT)' EQ '').CHKEND THIS ENTRY IN USE?
         MNOTE *,'       &USELAB(&UCNT),&USEREG(&UCNT)'
&GOTREG  SETB  1                        SAY WE FOUND SOMETHING
.CHKEND  AIF   (&UCNT LT 16).USELOOP    CHECK FOR END OF ARRAY
         AIF   (&GOTREG).FINI           LEAVE IF WE HAD REGS IN USE
         MNOTE *,'       *** NONE ****'
.FINI    SPACE 2
         AIF   ((T'&PRINT EQ 'O') AND                                  @
               (NOT &OACPRTF)).EXIT     SKIP POP IF NOT NEEDED
         POP   PRINT
.EXIT    MEND
         MACRO
         OACPRTPM &DUMMY,&PRINT=
.*
.*       SETS  VALUES OF &OACPRT AND &OACPRTS DEPENDING ON
.*       VALUES OF &OACPRTG, &OACPRTF, AND &PRINT
.*
.*       DOES  A PUSH PRINT AND A PRINT ON,GEN OR A
.*       PRINT OFF,NOGEN DEPENDING ON THE CALCULATED VALUE
.*       OF &OACPRT
.*
         GBLA  &OACPRTS
         GBLB  &OACPRTF
         GBLC  &OACPRT,&OACPRTG,&OACSTMX,&OACSTER
         GBLC  &OACNAME
&OACPRT  SETC  '&OACPRTG'
         AIF   (&OACPRTF).L4
         AIF   ('&PRINT' EQ '').L1DEF
         AIF   ('&PRINT' NE 'ALL' ).L1
&OACPRT  SETC  'ALL'
         AGO   .L4
.L1      AIF   ('&PRINT' NE 'SHORT').L2
.L1DEF   ANOP                     DEFAULT PRINT VALUE
&OACPRT  SETC  'SHORT'
         AGO   .L4
.L2      AIF   ('&PRINT' EQ 'NONE').L3
         MNOTE 4,'UNRECOGNIZABLE PRINT VALUE ''NONE'' USED'
.L3      ANOP
&OACPRT  SETC  'NONE'
.L4      ANOP
         PUSH  PRINT
         AIF   ('&OACPRT' NE 'ALL').L5
&OACPRTS SETA  99
         AGO   .L8
.L5      AIF   ('&OACPRT' NE 'SHORT').L6
&OACPRTS SETA  1
         AGO   .L8
.L6      AIF   ('&OACPRT' EQ 'NONE').L7
         MNOTE 4,'UNRECOGNIZABLE VALUE OF &OACPRTG ''NONE'' SET'
&OACPRTG SETC  'NONE'
&OACPRT  SETC  '&OACPRTG'
.L7      ANOP
         PRINT OFF,GEN
&OACPRTS SETA  1
.L8      MEND
         MACRO
&LBL     OACTMP &CMD=(0,0),&CBUF=,&PGM=,&PARM=,                        X
               &DCB=0,&TASKLIB=0,&CMDLIB=YES,                          X
               &EXEC=YES,&STACK=YES,&SCMD=NO,&STAX=YES,&CMDFAIL=MSG,   X
               &MF=I
         LCLA  &F,&F1,&A
         LCLC  &C
         LCLB  &CBF,&CBR,&CS,&CR1,&CR2,&PGF,&PGS,&PGR
         LCLB  &PRF,&PRS,&PRR,&HF,&HS,&HR
         LCLB  &DCBR,&DCB0,&TSKR
         LCLB  &STRS
         LCLB  &MFL,&MFI,&MFB,&MFE
         AIF   (('&LBL' EQ '') OR ('&MF' EQ 'L') ).L
&LBL     DS    0H
.L       AIF   ('&CBUF' EQ '').L1
&CBF     SETB  1
&F       SETA  X'80'
&C       SETC  '&CBUF'(1,1)
         AIF   ('&C' NE '(').L8
&CBR     SETB  1
         AGO   .L8
.L1      ANOP
&C       SETC  '&CMD(1)'(1,1)
         AIF   ('&C' NE '''').L2
&CS      SETB  1
&STRS    SETB  1
         AGO   .L4
.L2      AIF   ('&C' NE '(').L3
&CR1     SETB  1
.L3      ANOP
&C       SETC  '&CMD(2)'(1,1)
         AIF   ('&C' NE '(').L4
&CR2     SETB  1
.L4      AIF   ('&PGM' EQ '').L7A
&PGF     SETB  1
&F1      SETA  X'80'
&C       SETC  '&PGM'(1,1)
         AIF   ('&C' NE '''').L5
&PGS     SETB  1
&STRS    SETB  1
         AGO   .L6
.L5      AIF   ('&C' NE '(').L6
&PGR     SETB  1
.L6      AIF   ('&PARM' EQ '').L8
&PRF     SETB  1
&C       SETC  '&PARM'(1,1)
         AIF   ('&C' NE '''').L7
&PRS     SETB  1
&STRS    SETB  1
         AGO   .L8
.L7      AIF   ('&C' NE '(').L8
&PRR     SETB  1
         AGO   .L8
.L7A     AIF   ('&CMD(1)' NE '0').L8
         AIF   ('&MF(1)' EQ 'L').L8
         MNOTE 8,'CMD, CBUF, OR PGM MUST BE SPECIFIED'
         MEXIT
.L8      AIF   ('&DCB' NE 'ENV').L8A
&F       SETA  &F+X'40'
&DCB0    SETB  1
         AGO   .L9
.L8A     AIF   ('&DCB' NE '0').L8B
&DCB0    SETB  1
         AGO   .L9
.L8B     ANOP
&C       SETC  '&DCB'(1,1)
         AIF   ('&C' NE '(').L9
&DCBR    SETB  1
.L9      ANOP
&C       SETC  '&TASKLIB'(1,1)
         AIF   ('&C' NE '(').L10
&TSKR    SETB  1
.L10     AIF   ('&CMDLIB' NE 'NO').L11
&F       SETA  &F+X'20'
.L11     AIF   ('&EXEC'  NE 'NO').L12
&F       SETA  &F+X'10'
.L12     AIF   ('&STACK' NE 'NO').L13
&F       SETA  &F+X'02'
.L13     AIF   ('&SCMD' EQ 'NO').L14
&F       SETA  &F+X'08'
.L14     AIF   ('&STAX' NE 'NO').L15
&F       SETA  &F+X'04'
         AGO   .L17
.L15     AIF   ('&STAX' EQ 'YES').L17
&HF      SETB  1
&C       SETC  '&STAX'(1,1)
         AIF   ('&C' NE '''').L16
&HS      SETB  1
&STRS    SETB  1
         AGO   .L17
.L16     AIF   ('&C' NE '(').L17
&HR      SETB  1
.L17     AIF   ('&CMDFAIL' NE 'NOMSG').L18
&F       SETA  &F+X'01'
.L18     AIF   ('&MF' NE 'L').L19
&MFL     SETB  1
         AGO   .L23
.L19     AIF   ('&MF' NE 'I').L20
&MFI     SETB  1
         AGO   .L23
.L20     ANOP
&C       SETC  '&MF(1)'
         AIF   ('&C' NE 'B').L21
&MFB     SETB  1
         AGO   .L23
.L21     AIF   ('&C' NE 'E').L22
&MFE     SETB  1
         AGO   .L23
.L22     MNOTE 8,'UNRECOGNIZABE MF'
         MEXIT
.L23     AIF   (NOT &MFL).L37
         AIF   (NOT (&CBR OR &CR1 OR &CR2 OR &PGR OR &PRR OR &DCBR OR  X
               &TSKR)).L24
         MNOTE 8,'R FORM NOT ALOWED WITH MF=L'
         MEXIT
.L24     ANOP
&LBL     DS    0F                       FULLWORD ALIGNMENT
         DC    AL1(&F)                  FLAGS
         AIF   (NOT &DCB0).L25
         DC    AL3(0)                   DCB ADDR
         AGO   .L26
.L25     DC    AL3(&DCB)                DCB ADDR
.L26     AIF   (&PGF).L29
         AIF   (&CBF).L28
         AIF   (&CS).L27
         DC    AL1(&CMD(2))             CMD LNTH
         DC    AL3(&CMD(1))             CMD ADDR
         AGO   .L31
.L27     DC    AL1(L'TMPC&SYSNDX)       CMD LNTH
         DC    AL3(TMPC&SYSNDX)         CMD ADDR
         AGO   .L31
.L28     DC    AL4(&CBUF)               PTR TO CBUF
         AGO   .L31
.L29     AIF   (&PGS).L30
         DC    AL4(&PGM)                PGM NAME ADDR
         AGO   .L31
.L30     DC    AL4(TMPG&SYSNDX)         PGM NAME ADDR
.L31     DC    AL1(&F1)                 FLAGS
         DC    AL3(&TASKLIB)            TASKLIB
         AIF   (&PRF).L32
         DC    AL4(0)                   RETURN/COMPLETION CODE
         AGO   .L34
.L32     AIF   (&PRS).L33
         DC    AL4(&PARM)               PARM PTR/RETURN-COMPLETION CODE
         AGO   .L34
.L33     DC    AL4(TMPR&SYSNDX)         PARM PTR/RETURN-COMPLETION CODE
.L34     AIF   (&HF).L35
         DC    AL4(0)                   UNUSED HERALD FIELD
         AGO   .L38
.L35     AIF   (&HS).L36
         DC    AL4(&STAX)               HERALD/REPLY
         AGO   .L38
.L36     DC    AL4(TMPH&SYSNDX)         HERALD/REPLY
.L37     AIF   (NOT (&STRS OR &MFI)).L38
         B     TMPL&SYSNDX
.L38     AIF   (NOT &CS).L39
TMPC&SYSNDX DC C&CMD
.L39     AIF   (NOT &PGS).L40
TMPG&SYSNDX DC CL8&PGM                  PGM NAME
.L40     AIF   (NOT &PRS).L41
&A       SETA  K'&PARM
&A       SETA  &A-2
TMPR&SYSNDX DC 0F'0',XL1'80',AL3(TMPR&SYSNDX+6)
         DC    F'&A'
         DC    C&PARM
.L41     AIF   (NOT &HS).L42
&A       SETA  K'&STAX
&A       SETA  &A-2
TMPH&SYSNDX DC H'&A',C&STAX
.L42     AIF   (NOT &MFL).L43
         MEXIT
.L43     AIF   (NOT &MFI).L44
TMPT&SYSNDX DC 5F'0'                    CMD BLK FOR OACTMP
TMPL&SYSNDX LA 1,TMPT&SYSNDX GET TBL ADDR
         AGO   .L45A
.L44     AIF   (NOT &STRS).L45
TMPL&SYSNDX DS 0H
.L45     AIF   ('&MF(2)' EQ '(1)').L45A
         LA    1,&MF(2)                 GET TBL ADDR
.L45A    ANOP
         XC    0(20,1),0(1)             CLEAR TBL
.L46     AIF   (&DCBR).L47
         AIF   (&DCB0).L48
         LA    0,&DCB                   GET DCB ADDR
         ST    0,0(1)                   STORE IN TBL
         AGO   .L48
.L47     ST    &DCB(1),0(1)             STORE DCB ADDR
.L48     AIF   ('&F' EQ '0').L49
         MVI   0(1),&F                  MOVE IN FLAGS
.L49     AIF   (&PGF).L54
         AIF   (&CBF).L53A
         AIF   (&CS).L53
         AIF   (&CR1).L50
         LA    0,&CMD(1)                GET CMD ADDR
         ST    0,4(1)                   STORE IN LST
         AGO   .L51
.L50     ST    &CMD(1),4(1)
.L51     AIF   (&CR2).L52
         MVI   4(1),&CMD(2)             MOVE IN LNTH
         AGO   .L57
.L52     STC   &CMD(2),4(1)             STORE CMD LNTH
         AGO   .L57
.L53     LA    0,TMPC&SYSNDX            GET CMD ADDR
         ST    0,4(1)                   STORE IN TBL
         MVI   4(1),L'TMPC&SYSNDX       MOVE IN LNTH
         AGO   .L57
.L53A    AIF   (&CBR).L53B
         LA    0,&CBUF                  GET CBUF ADDR
         ST    0,4(1)                   STORE IN TBL
         AGO   .L57
.L53B    ST    &CBUF(1),4(1)            STORE CBUF ADDR
         AGO   .L57
.L54     AIF   (&PGS).L56
         AIF   (&PGR).L55
         LA    0,&PGM                   GET PGM NAME ADDR
         ST    0,4(1)                   STORE IN TABLE
         AGO   .L57
.L55     ST    &PGM(1),4(1)             STORE PGM NAME ADDR
         AGO   .L57
.L56     LA    0,TMPG&SYSNDX            GET PGM NAME ADDR
         ST    0,4(1)                   STORE IN TABLE
.L57     AIF   ('&TASKLIB' EQ '0').L59
         AIF   (&TSKR).L58
         LA    0,&TASKLIB               GET ADDR OF TSK DCB
         ST    0,8(1)                   STORE IN TAB
         AGO   .L59
.L58     ST    &TASKLIB(1),8(1)         STORE TSK DCB ADDR
.L59     AIF   ('&F1' EQ '0').L60
         MVI   8(1),&F1                 MOVE IN FLGS
.L60     AIF   (NOT &PRF).L63
         AIF   (&PRS).L62
         AIF   (&PRR).L61
         L     0,&PARM                  GET PARM ADDR
         ST    0,12(1)                  STORE IN TABLE
         AGO   .L63
.L61     ST    &PARM(1),12(1)           ST PRM ADDR IN TABLE
         AGO   .L63
.L62     LA    0,TMPR&SYSNDX            GET PARM ADDR
         ST    0,12(1)                  STORE IN TABLE
.L63     AIF   (NOT &HF).L67
         AIF   (&HS).L65
         AIF   (&HR).L64
         LA    0,&STAX                  GET HERALD ADDR
         ST    0,16(1)                  STORE IN TABLE
         AGO   .L67
.L64     ST    &STAX(1),16(1)           STORE HERALD ADDR
         AGO   .L67
.L65     LA    0,TMPH&SYSNDX            GET HERALD ADDR
         ST    0,16(1)                  STORE IN TBL
.L67     AIF   (&MFB).L68
         LINK  EP=OACTMP
.L68     MEND
         MACRO
         OACUSING &PARMS
         GBLC  &USELAB(16),&USEREG(16)  PGM LABELS,USE REGISTERS
         LCLA  &RCNT,&PNDX,&UNDX        # OF OPERANDS,PARM/USE INDICES
         LCLA  &TP1,&HOLE               TEMP WORK,1ST UNUSED SAVE ENTRY
         LCLB  &GOTREG                  WHETHER TO DO USING OR NOT
         LCLC  &CHR1,&CHR2,&C(16)       TEMPORARY WORK CHARS,COMMAS
         LCLC  &R(16),&S                REGS
         LCLC  &U,&V,&W                 R(15),C(16),R(16)
&PNDX    SETA  1                        SET UP PARM STRING INDEX
&RCNT    SETA  N'&SYSLIST               GET NUMBER OF OPERANDS
         AIF   (&RCNT LE 1).ERR01       TOO FEW INPUT PARAMETERS
         AIF   (&RCNT LE 17).SYS1#CK    CONTINUE IF LOW ENOUGH
         MNOTE 4,'TOO MANY INPUT PARAMETERS. ONLY 17 PROCESSED'
&RCNT    SETA  17                       SET MAX ALLOWABLE
.SYS1#CK ANOP
&S       SETC  '&SYSLIST(1)'            SET FOR SHORTER STRING BELOW
.COMLOOP ANOP
&PNDX    SETA  &PNDX+1                  INCREMENT INPUT STRING INDEX
&UNDX    SETA  0                        INITIALIZE USE INDEX
&HOLE    SETA  0                        INITIALIZE UNUSED ENTRY INDEX
.USELOOP AIF   ('&SYSLIST(&PNDX)' EQ '').CHK#END BR IF NULL STRING
&UNDX    SETA  &UNDX+1                  UP THE USE INDEX
         AIF   ('&USEREG(&UNDX)' EQ '&SYSLIST(&PNDX)').DO#USE PREVUSE?
         AIF   ((&HOLE NE 0) OR ('&USEREG(&UNDX)' NE '')).CHKEND
.* WE BRANCH TO CHKEND IF WE ALREADY HAVE A HOLE OR NO HOLE EXISTS HERE
&HOLE    SETA  &UNDX                    KEEP THE SAVE TABLE FREE INDEX
.CHKEND  AIF   (&UNDX LT 16).USELOOP    LOOP FOR ALL ENTRIES
&UNDX    SETA  &HOLE                    GET FREE ENTRY INDEX IN CASE
         AIF   (&HOLE NE 0).DO#USE1     BRANCH IF SPACE FOR ENTRY
         MNOTE 4,'OACUSING SAVE TABLE FULL. OPERAND TRUNCATED'
         AGO   .USINGGO                 GO DO JUST WHAT WE CAN
.DO#USE  ANOP
&CHR1    SETC  '********'(1,K'&SYSLIST(&PNDX)) STARS FOR THE REG
&CHR2    SETC  '****************'(1,K'&USELAB(&UNDX)) MAX 16 CHAR LABEL
         MNOTE *,'*********&CHR1*********************&CHR2'
         MNOTE *,'REGISTER &SYSLIST(&PNDX) PREVIOUSLY BASED ON &USELAB(@
               &UNDX)'
         MNOTE *,'*********&CHR1*********************&CHR2'
.DO#USE1 ANOP                           LOG THE REG USE HERE
&CHR1    SETC  '&SYSLIST(1)'            GET A DEFAULT LABEL
         AIF   (&PNDX EQ 2).SETLAB      IF FIRST REG, NO +NNNN TO ADD
&TP1     SETA  (&PNDX-2)*4096           ELSE GET ADDED AMOUNT
&CHR1    SETC  '&CHR1'.'+'.'&TP1'       APPEND THE +NN FOR EXTRA REGS
.SETLAB  ANOP                           MOVE IN THE SAVE LABELS HERE
&USELAB(&UNDX) SETC '&CHR1'             SET SAVE TABLE DATA
&USEREG(&UNDX) SETC '&SYSLIST(&PNDX)'   GET THE REG VALUE IN SAVEAREA
&R(&PNDX-1) SETC '&SYSLIST(&PNDX)'      GET THE REG VALUE FOR USING
&C(&PNDX-1) SETC ','                    AND A LEADING COMMA ALSO
&GOTREG  SETB  1                        SAY WE CAN DO USING
.CHK#END AIF   (&PNDX LT &RCNT).COMLOOP LOOP FOR ALL ENTRIES
.USINGGO AIF   (NOT &GOTREG).EXIT       NOW TELL ASSEMBLER IF WE CAN
&U       SETC  '&R(15)'                 SO WE HAVE A SHORTER STRING
&V       SETC  '&C(16)'                 SO WE HAVE A SHORTER STRING
&W       SETC  '&R(16)'                 SO WE HAVE A SHORTER STRING
         USING &S&C(1)&R(1)&C(2)&R(2)&C(3)&R(3)&C(4)&R(4)&C(5)&R(5)&C(6@
               )&R(6)&C(7)&R(7)&C(8)&R(8)&C(9)&R(9)&C(10)&R(10)&C(11)&R@
               (11)&C(12)&R(12)&C(13)&R(13)&C(14)&R(14)&C(15)&U&V&W
         MEXIT
.ERR01   MNOTE 4,'MISSING INPUT PARAMETERS'
.EXIT    MEND
