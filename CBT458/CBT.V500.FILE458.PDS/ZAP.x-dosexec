ZAP      TITLE 'ZAP --- DISPLAY AND MODIFY DATA-SETS --- TSO COMMAND.'
         PRINT OFF                                                 -EU-
         COPY  ZAPMAC                                              -EU-
         PRINT ON                                                  -EU-
***********************************************************************
*                                                                     *
*  THIS PROGRAM HAS BEEN THOROUGHLY TESTED, HOWEVER, NO               *
*  RESPONSIBILITY OF ANY KIND CAN BE ASSUMED FOR ITS RELIABLE OR      *
*  CORRECT OPERATION. THIS PROGRAM MAY NOT BE FURTHER DISTRIBUTED     *
*  WITHOUT THE WRITTEN PERMISSION OF THE AUTHORS.                     *
*                                                                     *
***********************************************************************
         SPACE 1
***********************************************************************
*                                                                     *
*        U C L A / O A C   ' Z A P '   T S O  C O M M A N D           *
*                                                                     *
***********************************************************************
*                                                                     *
* UPDATES :                                                           *
*                                                                     *
* 10/16/95 -EU-  - PFK5 ('L') CONTINUE CORRECTLY.                     *
*                                                                     *
* 10/04/95 -EU-  - SUPPORT PFK1 AS HELP AND PFK3 AS END-HELP (LIKE    *
*                  ISPF USERS ARE FAMILIAR).                          *
*                                                                     *
* 10/03/95 -EU-  - ADDED FREEMAIN OF "LCSOUT" WORK-AREA.              *
*                                                                     *
* 10/02/95 -EU-  - SOME CODING ERRORS CORRECTED.                      *
*                                                                     *
* 12/11/89 -EU-  - PREVENT DE-ALLOCATION OF PRE-ALLOCATED DATA-SETS.  *
*                                                                     *
* 06/26/89 -EU-  - ADD CAPS ON/OFF COMMAND TO DRIVE ON HOW HANDLE     *
*                  <STR> STRING COMMANDS.                             *
*                                                                     *
* 06/22/89 -EU-  - ADAPT L, F, S, X, O, N AND SET COMMANDS TO WORK    *
*                  WITH ASCII OR ZCODE MODE ALSO (<STR>).             *
*                                                                     *
* 06/04/88 -EU-  - ONLY MVS/XA VERSION                                *
*                                                                     *
* 06/21/84 -EU-  - SENSITIVE DATA-SET ACCESS CONTROLED FOR ONLY       *
*                  SYSTEM SUPPORT PEOPLE.                             *
*                  MOVE ALL MACROS IN MEMBER "ZAPMAC".                *
*                  FREE THE DATA-SET AT END, AND EVENTUALLY DEQUEUE   *
*                  THE "ALLOCDSN" NAME WHEN USED FOR VTOC ALLOCATION. *
*                                                                     *
* 10/02/81 AFDSC - MODS AT AFDSC/PENTAGON BY BILL GODFREY :           *
*                  SUPPORT PFK3 AS 'END'.                             *
*                  SUPPORT PFK5 AS 'L' (REPEAT LOCATE OR FIND).       *
*                  SUPPORT PFK7 AS 'U' (UP).                          *
*                  SUPPORT PFK8 AS 'D' (DOWN).                        *
*                  CHECK FOR PRE-ALLOCATED 'ZAPLOG' DD. THIS ALLOWS   *
*                  USER TO PUT THE LOG SOMEWHERE BESIDES SYSOUT(A).   *
*                  OACTMP MISSING. BYPASS INSERTED TO AVOID ABEND806. *
*                  OACNOW MISSING. WROTE OUR OWN VERSION.             *
*                  CALL INSTEAD OF LINK TO OACNOW.                    *
*                  FREEMAIN THE AREA RETURNED BY OUR OACNOW.          *
*                  SOURCE FOR OUR OACNOW APPENDED FOR BATCH ASSEMBLY. *
*                  CHANGE TITLE LINE ON LOG LISTING.                  *
*                                                                     *
* 12/18/80 MAS3 :  ASK AT EXIT IF ZAP LOG REQUIRED, DELETE IF 'NO'.   *
*                                                                     *
* 12/18/80 MAS2 :  NAME(E) COMMAND - FIND TEXT BLOCK BY ORIG IN       *
*                  PREVIOUS CONTROL RECORD (NOT JUST COUNTING BYTES). *
*                  ADD J COMMAND - 'P' RELATIVE TO VOLUME.            *
*                  FIX "INPUT DATA LOST" (TRCHARE HAS NO ORG AT END). *
*                  DELETE 'FCME' COMMAND.                             *
*                                                                     *
* 12/18/80 MAS1 :  REMOVE ALL &CCN CODE (NO MORE CCN/MVT).            *
*                  INCLUDE ZAPS --                                    *
*                    VSAPL ZCODE TABLE.                               *
*                    GTSIZE CODE TO ALLOW OTHER THAN 24 LINE SCREENS. *
*                                                                     *
* 12/27/79 LDW5 :  MODIFY FULLSCREEN FLAGS LOGIC (F3270 FSMODE).      *
*                  SIMPLIFY "DO" COMMAND CODE.                        *
*                  DELETE "RESHOW" COMMAND.                           *
*                  FIX "WINDOW" COMMAND BUG.                          *
*                  CHANGE VERSION TO 2.3.                             *
*                  CHANGE SENSITIVE DATASET CRITERIA FOR GIBRALTAR.   *
*                  MERGE "INITSHOW" FLAG INTO "RESHOWF".              *
*                  PRE-BLANK REPLY BUFFER AFTER PUTGET.               *
*                                                                     *
* 12/27/79 SDM6 :  FIX COMSCAN TO HANDLE ZERO LENGTH REPLIES RIGHT.   *
*                  FIX SHORT RESPONSE LOGIC FOR FULLSCR SUPPORT.      *
*                                                                     *
* 11/29/79 LDW4 :  FIX IDR & LOG USERID.                              *
*                  PAUSE 'F' AT DS1LSTAR.                             *
*                  ADD 'WM' ALIAS FOR WHATMEM COMMAND.                *
*                  MAKE JCJ HAPPY: SAME CMD TWICE IN A ROW WILL GET   *
*                    OUT OF A MODIFIED BLOCK WITHOUT "ZAP"ING IT      *
*                    ("NOZAP" COMMAND REMOVED).                       *
*                  CHANGE TO VERSION 2.2B.                            *
*                  CHANGE MESSAGE ID'S FROM CSM3XX TO ZAP0XX.         *
*                  FORCE LOG FOR ANY SYSN. DATASET.                   *
*                  CHANGE TITLE ON LOG FROM UCLA-CCN TO GIS.          *
*                  ADD USID TO ALLOCDSN PARSE ENTRY.                  *
*                  ROUND UP BY 50 BYTES THE SIZE OF THE GETMAIN'D BUF.*
*                  MOVE LASTDS1 TO ITS OWN FIELD.                     *
*                  DIDDLE CODE IN 'FORMAT' TO PREVENT 0C4'S.          *
*                                                                     *
* 11/28/79 SDM5 :  CHANGE LINE01 LENGTH TO NORMAL.                    *
*                  IMPROVE PARTIAL SCREEN DISPLAY CODE.               *
*                  IMPROVE TGET ASIS CODE.                            *
*                  MOVE BASE FROM R7 TO R9.                           *
*                                                                     *
* 11/27/79 SDM4 :  ELIMINATE 'UNLOCK KEYBOARD' FROM 3270 OUTPUT.      *
*                  FIX ERROR MESSAGE BLANKING BUG.                    *
*                  FIX HELP PROMPT FIELD CLEAR LENGTH BUG.            *
*                  FIX HELP PROMPT FIELD MDT BUG.                     *
*                                                                     *
* 11/09/79 SDM3 :  FIX INTERMITTENT 0C4 IN 'L' COMMAND.               *
*                                                                     *
* 09/26/79 SDM2 :  ADD ROUTCDE=9 (SECURITY) TO WTO.                   *
*                                                                     *
* 09/05/79 LDW3 :  DELETE ALL SSL CODE.                               *
*                                                                     *
* 08/07/79 SDM1 :  1) CHANGE TGET WHEN IN FULLSCREEN MODE TO ASIS.    *
*                  2) ADD ROUTCDE=2 (MASTER CONSOLE) TO WTO.          *
*                                                                     *
* 06/27/79 LDW2 :  1) CHANGE FULLSCREEN I/O TO ONLY TPUT CHANGED LINES*
*                  2) FIX BUG IN FULLSCREEN HELP.                     *
*                  3) ADD HELP INFO.                                  *
*                                                                     *
* 05/05/79 LDW1 :  THIS IS A MAJOR CLEANUP/REWRITE THAT KEPT MAINLY   *
*                    THE ORIGINAL FRAMEWORK, BUT ALMOST EVERYTHING    *
*                    WAS CHANGED SOMEWHAT.                            *
*        1) CHANGE ACCESS METHOD FROM BDAM TO EXCP.                   *
*        2) FIX SO "X" WORKS IF LOG IS ON.                            *
*        3) FIX SO "ZAP REQ'D" WORKS IF LOG OFF.                      *
*        4) CHANGE TPUT TO PUTLINE.                                   *
*        5) MAKE SINGLE ASSEMBLY.                                     *
*        6) INCLUDE CHAR FORM OF DATA AND ABS LOC IN LOG.             *
*        7) VARIOUS RE-ARRANGING TO CONSERVE PAPER.                   *
*        8) FULLSCREEN 3270 & SSL SUPPORT.                            *
*        9) JUST "M" GIVES SAME MEMBER AGAIN (NOT DIRECTORY).         *
*       10) DELETE LOGTEST MACRO, PUT CODE IN SUBROUTINE.             *
*       11) UPDATE IDR FOR ALL ENTRY POINTS SELECTED.                 *
*       12) MISC CODE CLEANUP, EG "BLANKS", EQU'S FOR TTR+3.          *
*       13) ADD DUMPE COMMAND TO DUMP CURRENT REC TO EOF.             *
*       14) ADD LINELEN=80 FEATURE/OPTION.                            *
*       15) DIDDLE BASE REGISTERS & ADD ONE.                          *
*       16) VTOC SUPPORT.                                             *
*       17) CHANGE CSOUT TO USE QSAM, LARGE BLKSIZE, FIX BUGS.        *
*       18) FIX EXPR HANDLER TO MULT/DIV.                             *
*       19) NEW CMDS:  WHATMEM, F, V, LASTDS1, U, DISP, %.            *
*       20) SET LOG DEFAULT, FIX SO DELETED IF UNUSED.                *
*       21) REDESIGN "CHKPT" OPERATION.                               *
*       22) USE 'HEX' MACRO.                                          *
*       23) FIX 15 NIBBLE HEX STRING BUG.                             *
*       24) ADD CONDITIONAL ASSEMBLY FOR MVT/MVS, SSL/NOSSL, CCN/Â¬CCN *
*                                                                     *
* 05/20/78 JCJ1 :  1) PROPAGATE LPR URSA ZAP FIXES TO TSO ZAP.        *
*                  2) PROPAGATE ABS COMMAND FROM URSA ZAP TO TSO ZAP. *
*                  3) FIX LOST SP 0 CORE AT EODAD BUG.                *
*                  4) FIX VERBOSE MODE MSG OVERLAY BUG.               *
*                                                                     *
* 12/20/75 VIC : ADD 'NAME' COMMAND TO LOCATE ENTRY POINTS/CSECTS  *N**
*                WITHIN LOAD MODULES.                              *N**
*                                                                     *
* 09/12/75 WDD :                                                      *
*        . GET USERID FOR ZAP UPDATE RECORD, ALLOW USERS TO USE ZAP.  *
*        . ALLOCATE DATASET PERM=NO, AND SET CORRECT DSNAME LENGTH.   *
*                                                                     *
***********************************************************************
         EJECT
*        POSSIBLE NEW FEATURES - BUGS - THINGS TO CHECK.
*        -----------------------------------------------
*  5) COMMAND STACKING.
* 17) ENQ ON SPZAPLIB/SYSVTOC/SYSCTLG (SPZAPLIB L'RNAME=44).
* 22) STORE TTR IN DEFINE TABLE, ADD P= COMMAND.
* 26) OFFSET COMMAND?
* 36) RECORD MAY BE > 32K BYTES... BUT O/S WON'T LET IT, SO NO PROBLEM.
* 45) EXP IS SCREWED.
* 46) SYSOUT ENQ LOG TO DEST C (DEST/BIN KEYWORDS?).
* 47) NOTE WHERE IDR'S ARE WHILE LOOKING FOR ENTRY POINT.
* 48) DO 256 READ COUNTS.
* 55) RN GOES TO NEXT TRACK IF CURR TRK DOESN'T HAVE N RECORDS.
* 63) OFFSET IN LOG WILL BE FISHY IF NOT ADJUSTED FOR DISPC/K/D.
* 71) AUTO "M" IF MEMBER GIVEN?
* 72) WSHORT & DELETE ALL 40 CHAR CODE?
* 74) DON'T POSITION CURSOR UNLESS RMOD.
* 76) MAKE HELP USE LONGER SCREEN LINES.
* 81) DON'T DISP COUNT AS PART OF REC, HAVE SET COUNT CMD.
* 82) USE 'MSG' FOR HELPS.
* 83) CHANGE TRAILING BLANKS TO NULLS AT DISPLAY TIME.
* 84) MOVE CSOUT MF=L TO TSDSECT.
* 85) "FORMAT" COMMAND.
* 86) SCAN OFF BLANKS BETWEEN COMMAND AND OPERAND.
* 87) FEOF COMMAND TO FIND NEXT EOF.
* 88) LC/UC COMMANDS.                                              LDW4
* 89) BLKSIZE 0 SHOULD USE DEVTYPE FOR BUFLEN (WHAT ABOUT TRK OFLO?)
         EJECT
**********************************************************************
*                                                                    *
* PROGRAM : ZAP (UNDER TSO)                                          *
* --------- THIS PROCESSOR IS RE-ENTRANT AND SERIALLY REUSABLE.      *
*                                                                    *
* PROGRAMMER : VIC TOLOMEI                                           *
* ------------ FOR FULL DOCUMENTATION OF COMMANDS AND SO ON,         *
*              SEE THE LISTING OF THE URSA VERSION IN BINDER         *
*              'URSA MISCELLANEOUS VOLUME 3'.                        *
*              WRITTEN FOR URSA : 5/22/73                            *
*              CHANGE TO TSO VERSION : 1/22/75                       *
*                                                                    *
**********************************************************************
         SPACE 1
**********************************************************************
*                                                                    *
*                               Z A P                                *
*                                                                    *
*  GENERAL ZAP OUTLINE :                                             *
*                                                                    *
*  THIS SERVICE WILL DISPLAY ANY TYPE OF DATA-SET (EXCLUDING ISAM)   *
*  IN DUMP FORMAT, ACCEPT VARIOUS DISPLAY FORMATTING AND MODIFYING   *
*  COMMANDS, AND APPLY INTERACTIVE CHANGES AS DOES IBM'S SERVICE     *
*  AID, IMASPZAP (SUPERZAP).                                         *
*  HARDCOPY LINES ARE PRINTED FOR ALL DATA SET MODIFICATIONS AND     *
*  'POTENTIAL MODIFICATIONS' (THOSE NOT YET APPLIED) AS WELL AS      *
*  COMMENTS AND DUMPED BLOCKS. THE FOLLOWING CONDITIONS CAUSE A      *
*  LINE TO BE WRITTEN INTO THE PRINT FILE : ACCESSING A DATA-SET,    *
*  'ZAPPING' A BLOCK, STORING IN THE BUFFER (S,X,O,N, OR SET),       *
*  SELECTING A MEMBER, CREATING A COMMENT, EJECTING A PAGE, OR       *
*  DUMPING A BLOCK OR BLOCKS. THE FILE WILL BE PRINTED ONLY IF AN    *
*  EXPLICIT DUMP, COMMENT, OR PERMANENT CHANGE IS MADE. THE FILE     *
*  IS ACTUALLY RELEASED FOR PRINTING UPON EXIT FROM THE DATA-SET.    *
*  IDR'S ARE UPDATED IN LOAD MODULE DATA-SETS IN THE FORMAT SUPERZAP *
*  USES (WITH 'TSO--III' AS THE ID DATA FIELD).                      *
*  END-OF-FILES MAY BE JUMPED TO VIEW DATA BEYOND UP TO THE EXTENT   *
*  OF THE DATA-SET (USEFUL IF AN INADVERTANT EOF WAS WRITTEN IN THE  *
*  MIDDLE OF A DATA-SET).                                            *
*                                                                    *
**********************************************************************
         EJECT
*  THE OLD SCREEN FORMAT WAS AS FOLLOWS :                          LDW1
         SPACE 1
*               ##########################################
*               # *MSG*  *TALK*  Z  A  P  *BULL*  *OUT* >#
*               #L'NOTHING'                              #
*               #ENTER VALID COMMAND ABOVE OR ? FOR HELP #
*               # ***** I/O ERROR: XXXXXXXXXXXXXXX ***** #
*               #000000  F1F2 F3F4  F5F6 F7F8  |12345678|#
*               #000008  F1F2 F3F4  F5F6 F7F8  |12345678|#
*               #000010 >F1F2 F3F4  F5F6 F7F8  |12345678|#
*               #000018  F1F2 F3F4  F5F6 F7F8  |12345678|#
*               #000020  F1F2 F3F4  F5F6 F7F8  |12345678|#
*               #000028  F1F2 F3F4  F5F6 F7F8  |12345678|#
*               #000030  F1F2 F3F4  F5F6 F7F8  |12345678|#
*               #000038  F1F2 F3F4  F5F6 F7F8  |12345678|#
*               #000040  F1F2 F3F4  F5F6 F7F8  |12345678|#
*               #000048  F1F2 F3F4  F5F6 F7F8  |12345678|#
*               #000050  F1F2 F3F4  F5F6 F7F8  |12345678|#
*               #000058  F1F2 F3F4  F5F6 F7F8  |12345678|#
*               #000060  F1F2 F3F4  F5F6 F7F8  |12345678|#
*               #        *****  SCAN MATCH  *****        #
*               #DSN: CPC013.LDW.SCREEN.SAMPLE OFF:  0010#
*               #TTR: 000001 CCHHR: 0022000301 LEN:   400#
*               ##########################################
         SPACE 1
*  THE NEW FORMAT IS AS FOLLOWS :                                  LDW1
*  (SOME BLANK COLUMNS HAVE BEEN OMITTED SO IT WILL FIT)           LDW1
         SPACE 1
*              *MSG*  *TALK*  Z  A  P  *BULL*  *OUT*                  >
*(TYPE HERE)
*ENTER VALID COMMAND ABOVE OR ? FOR HELP
*L'12345678'
*             ***** I/O ERROR: XXXXXXXXXXXXXXX *****
*00000  F1F2 F3F4  F5F6 F7F8  F9C1 C2C3  C4C5 C6F0   |123456789ABCDEF0|
*00010 >F1F2 F3F4  F5F6 F7F8  F9C1 C2C3  C4C5 C6F0   |123456789ABCDEF0|
*00020  F1F2 F3F4  F5F6 F7F8  F9C1 C2C3  C4C5 C6F0   |123456789ABCDEF0|
*00030  F1F2 F3F4  F5F6 F7F8  F9C1 C2C3  C4C5 C6F0   |123456789ABCDEF0|
*00040  F1F2 F3F4  F5F6 F7F8  F9C1 C2C3  C4C5 C6F0   |123456789ABCDEF0|
*00050  F1F2 F3F4  F5F6 F7F8  F9C1 C2C3  C4C5 C6F0   |123456789ABCDEF0|
*00060  F1F2 F3F4  F5F6 F7F8  F9C1 C2C3  C4C5 C6F0   |123456789ABCDEF0|
*00070  F1F2 F3F4  F5F6 F7F8  F9C1 C2C3  C4C5 C6F0   |123456789ABCDEF0|
*00080  F1F2 F3F4  F5F6 F7F8  F9C1 C2C3  C4C5 C6F0   |123456789ABCDEF0|
*00090  F1F2 F3F4  F5F6 F7F8  F9C1 C2C3  C4C5 C6F0   |123456789ABCDEF0|
*000A0  F1F2 F3F4  F5F6 F7F8  F9C1 C2C3  C4C5 C6F0   |123456789ABCDEF0|
*000B0  F1F2 F3F4  F5F6 F7F8  F9C1 C2C3  C4C5 C6F0   |123456789ABCDEF0|
*000C0  F1F2 F3F4  F5F6 F7F8  F9C1 C2C3  C4C5 C6F0   |123456789ABCDEF0|
*000D0  F1F2 F3F4  F5F6 F7F8  F9C1 C2C3  C4C5 C6F0   |123456789ABCDEF0|
*                    *****  SCAN MATCH  *****
*OFF: 0010 (    16) ADDR: 00010 (     16) DSN: CPC013.LDW.SCREEN.SAMPLE
*LEN: 0190 (   400) BASE: 00000 (      0) CCHHR: 0022003301 TTR: 000001
         EJECT
ZAP      START 0
         SPACE 1
ZAP     AMODE  24                                                  -EU-
ZAP     RMODE  24                                                  -EU-
         SPACE 1
F0       EQU   0
F2       EQU   2
F4       EQU   4
F6       EQU   6
F8       EQU   8
         SPACE 2
**********************************************************************
*                                                                    *
* REGISTERS USAGE : R0-R7...WORK REGS                                *
*                   R8......PRIMARY BAS REG                          *
*                   R9......FOURTH BASE REGISTER                     *
*                   R10.....THIRD BASE REGISTER                      *
*                   R11.....SECOND BASE REGISTER                     *
*                   R12.....FIRST BASE REGISTER (BASE FOR EXP)       *
*                   R13.....TS WORKAREA (SAVEAREA, 'CSAREA', ETC)    *
*                   R14.....WORK AND RET ADDR                        *
*                   R15.....WORK AND ENTRY POINT ADDR                *
*                                                                    *
**********************************************************************
         SPACE 2                                                   -EU-
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *  -EU-
*        AUTHORITY LEVELS DEFINITIONS.                          *  -EU-
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *  -EU-
         SPACE 1                                                   -EU-
LV0      EQU   0         REJECT LEVEL.                             -EU-
LV14     EQU   14        HIGH SENSITIVE LEVEL.                     -EU-
         SPACE 1                                                   -EU-
        $MDL@IX ,        MODULE LEVEL.                             -EU-
         EJECT
*ZAP     TSENTRY BASE=R12,SYMREG=NO,PL=(PARSE,DAIR,MESSAGE,IO),    LDW1X
               MACRO=YES,LOAD=(IKJPTGT,IKJPUTL)                    LDW1
ZAP      ENTR  PL=(PARSE,DAIR,IO),LOAD=(IKJPTGT,IKJPUTL),          LDW1X
               ENV=CP,TSFAKE=YES,MACRO=YES,PARMREG=R5,             LDW1X
               BASE=R12,BASE2=R11,BASE3=R10,BASE4=R9               LDW1
         EJECT                                                     LDW1
CSREG    EQU   13
*LDW1    LA    R11,4095(,R12)           BASE #2                    LDW1
*LDW1    LA    R11,1(,R11)                                         LDW1
*LDW1    LA    R10,4095(,R11)           BASE #3                    LDW1
*LDW1    LA    R10,1(,R10)                                         LDW1
*LDW1    LA    R9,4095(,R10)            BASE #4                    LDW1
*LDW1    LA    R9,1(,R10)                                          LDW1
         SPACE 2
         MVI   BLANKS,C' '              INIT                       LDW1
         MVC   BLANKS+1(L'BLANKS-1),BLANKS                         LDW1
         MVC   VERSION,BLANKS           INIT                       LDW1
         MVC   VERSION(12),=C'VERSION=2.3 '                        LDW5
         MVC   VERSION+13(7),ZAP+10     DATE                       LDW1
*MAS2    MVC   VERSION+21(3),=C'LDW'                               LDW1
         SPACE 1
         TSFIND  PSCB,R1                -> PSCB                    LDW1
         SPACE 1
         MVC   USERID(7),0(R1)          GET THE TSO USER ID        LDW1
         MVC   USERID+7(L'USERID-7),BLANKS   BLANK THE REST        LDW1
*%       MVC   LINELEN,=H'80'           DEFAULT LINE LENGTH        LDW1
         MVC   DISPCONS(DISPCONL),DSPCON80  CONSTANTS FOR LEN=80   LDW1
         MVC   CTL3270,CTL3270C         INIT 3270 CONTROL BYTES    LDW1
         MVC   END3270,END3270C         FINISH IT                  LDW1
         LA    R0,SCREENL               GET TPUT LENGTH            LDW2
         LA    R1,SCREEN                GET TPUT ADDR              SDM5
         STM   R0,R1,REGS3270           SAVE FOR FULLSCR TPUT      LDW1
         MVI   REGS3270+4,X'03'         SET FULLSCR TPUT FLAG      SDM5
         XC    CURPOS,CURPOS            CLEAR CURSOR POSITION      LDW1
         LA    R1,JFCB                  -> JFCB                    LDW1
         ST    R1,EXLST                                            LDW1
         MVI   EXLST,X'87'              CALL IT A JFCB             LDW1
         SPACE 1
         LA    R6,4095(,R13)            TEMP POINT TO EXTRA        LDW1
         USING TSDSECT+4095,R6                                     LDW1
         LA    R0,IDEFTAB                                          LDW3
         ST    R0,AIDEFTAB                                         LDW1
         LA    R1,ITRTAB                                           LDW1
         ST    R1,AITRCTAB                                         LDW1
         MVI   0(R1),X'FE'              SET TO INITIAL VALUE       LDW1
         MVC   1(120-1,R1),0(R1)        SET THE WHOLE THING        LDW1
         ST    R1,ITRAVAL               -> FIRST POS               LDW1
         ST    R1,CURRITR               -> CURRENT POS             LDW1
         MVI   ENDITAB,X'FF'            MARK THE END OF THE TABLE  LDW1
         MVI   ITREND,X'FF'             DITTO                      LDW1
         LA    R0,ITREND                POINT TO IT                LDW1
         ST    R0,AITREND               SAVE                       LDW1
         LA    R1,SCRWORK               -> WORK AREA               LDW2
         ST    R1,ASCRWORK              SAVE ADDR                  LDW2
         LA    R1,OLDSCR                -> SCREEN SAVE AREA        SDM5
         ST    R1,AOLDSCR               SAVE ADDRESS               SDM5
         DROP  R6                                                  LDW1
         L     R1,=A(DCBMSK)            GET ADDR OF PATTERN DCB    LDW1
         MVC   DCBU(DCBUL),0(R1)        SET UP DCB FOR INPUT       LDW1
         XC    IOB(40),IOB              INIT IOB                   LDW1
         MVI   IOB,X'42'                IOBFLAGS                   LDW1
         LA    R0,ECB                   -> EXCP ECB                LDW1
         ST    R0,IOB+4                                            LDW1
         LA    R0,DCBU                                             LDW1
         ST    R0,IOB+20                                           LDW1
         MVC   CCWS(CCWL),CCWLIST       INIT CCWS                  LDW1
         LA    R0,CCHHR                 PTR FOR SEARCH ID EQ       LDW1
         STCMX R0,B'0111',CCW#R#S+1,BYTE=31   SET ADDR             LDW1
         STCMX R0,B'0111',CCW#W#S+1,COPY=CCW#R#S+1     HERE TOO    LDW1
         STCMX R0,B'0111',CCW#F#S+1,COPY=CCW#R#S+1     HERE TOO    LDW1
         LA    R1,CCW#R#S               GET TIC ADDR               LDW1
         STCMX R1,B'0111',CCW#R#T+1,BYTE=08    SET IT              LDW1
         LA    R1,CCW#W#S               GET TIC ADDR               LDW1
         STCMX R1,B'0111',CCW#W#T+1,BYTE=08    SET IT              LDW1
         LA    R1,NAME                  -> KEY                     LDW1
         STCMX R1,B'0111',CCW#D#S+1,BYTE=E9    SET IT              LDW1
         LA    R1,CCW#D#S               GET TIC ADDR               LDW1
         STCMX R1,B'0111',CCW#D#T+1,BYTE=08   SET IT               LDW1
         LA    R1,CCW#F#S               GET TIC ADDR               LDW1
         STCMX R1,B'0111',CCW#F#T+1,BYTE=08   SET IT               LDW1
         MVI   FLAGS2,0                 INIT FLAGS                 LDW1
         MVI   FLAGS3,0                 INIT FLAGS                 LDW5
         SPACE 1                                                   LDW3
*        GUESS IF THIS IS A 3270.                                  LDW1
         SPACE 1                                                   LDW3
         GTSIZE
         LTR   R0,R0                    ANY LINES?        (ZAP)    MAS1
         BZ    *+L'*+12                 NO, NOT 3270      (ZAP)    MAS1
         CH    R1,=H'80'                80 COLUMNS?                LDW1
         BNE   *+L'*+4                  NO, NOT 3270               LDW1
         OI    FLAGS3,F3270+RESHOWF     24 LNS & 80 COLS ==> 3270  LDW5
         EJECT                                                     LDW1
*  PARSE THE INPUT LINE :
*
*        ZAP  'DSN'  VOL(VOLSER) CRT LOG TERSE/VERBOSE
         SPACE 1
         TSPARSE CBUF=(CPPLCBUF,I),PCL=(=V(PCL),I)
         SPACE 1
         BXLE  R15,R15,OKPARSE          IT'S OK
         LA    R1,=CL40'INVALID INPUT'  OOOPS
         B     CSIO#                    SHOW AND QUIT
OKPARSE  L     R7,TSPARANS              POINT TO PARSE BLOCK
         OACUSING IKJPARMD,R7           TEMP TO GET DSN AND VOL     MVS
         CLI   NWK+1,2                  SEE IF TERSE
         BNE   *+L'*+4                  IF NOT NO FLAG
         OI    FLAGS2,TERSEF            SUPRESS WHERE
         CLI   CRTK+1,1                 SEE IF CRT SPECIFIED
         BNE   *+L'*+4                  IF NOT DONT SET FLAG
         OI    FLAGS3,CRTF              IF SO SET FLAG             LDW5
         CLI   LOGK+1,1                 SEE IF LOG SPECIFIED
         BNE   *+L'*+4                  IF NOT NO LOG
         OI    FLAGS2,LOGF
         CLI   NOT3270K+1,1             NOT3270 SPECIFIED?         LDW1
         BNE   *+L'*+4                  NO, SKIP                   LDW1
         NI    FLAGS3,255-F3270         YES, TURN OFF FLAG         LDW5
         XC    WIDTHS(4+4),WIDTHS       DEFAULT = CARET LINE ONLY  LDW1
         TM    FLAGS3,F3270+CRTF        ANYTHING INTERESTING?      LDW5
         BZ    NOT$FULL                 NO, SKIP                   LDW3
         NI    FLAGS2,255-TERSEF        ANY OF THEM IMPLY VERBOSE  LDW5
         MVC   WIDTHD(4),MAXWIDTH       SO 'D' WORKS               LDW1
         MVC   WIDTHU(4),MAXWIDTH       DITTO                      LDW1
         SPACE 1
*        CHECK OUT THE USER. IF HE CAN'T GET IN, OR
*        CAN'T TOUCH THE DATA-SET, KICK HIM OUT.
         SPACE 1
NOT$FULL L     R1,PDEPTR-PDE+PDLDSN     POINT TO DSN SUPPLIED      LDW1
         LH    R15,PDELEN-PDE+PDLDSN    POINT TO ITS LEN (<= 45)
         STH   R15,DSNAMEL              SET DSNAME LENGTH         *WDD*
         BCTR  R15,0                    EX LEN
         MVC   DSNAME(44),BLANKS        CLEAR TARGET               LDW1
         MVC   VOLSER(6),BLANKS         BLANK VOL TOO
         MVC   PASSWORD(8),BLANKS       AND THE PASSWORD           LDW1
         MVC   DSNAME(0),0(R1)          << EXECUTED >>
         EX    R15,*-6                  MOVE PARSE DSN TO FULL TARGET
         MVC   DISPDSN,DSNAME           COPY FOR DISPLAYING        LDW1
         CLC   DSNAME(7),=CL7'SYSCTLG'  IS IT OS-CATALOG           JCJ1
         BE    SETSSTV                  IF YES MARK IT             -EU-
         CLC   DSNAME(8),=CL8'CATALOG.' IS IT OUR VSAM-CATALOG     -EU-
         BE    SETSSTV                  IF YES MARK IT             -EU-
         CLC   DSNAME(5),=CL5'UCAT.'    IS IT OUR VSAM-CATALOG     -EU-
         BNE   SETSSTV+L'SETSSTV        IF NOT LET IT BY           -EU-
SETSSTV  OI    FLAGS2,SENSF+LOGF        MARK AS SENSITIVE
         TM    PDLDSN+PDEFLAG3-PDE,PDEFPRES  PSWD PRESENT?         LDW1
         BNO   NOPASS                   NO                         LDW1
         L     R1,PDLDSN+PDEPTR3-PDE    -> PSWD                    LDW1
         LH    R15,PDLDSN+PDELEN3-PDE   LENGTH                     LDW1
         BCTR  R15,0                    -1 FOR EX                  LDW1
         MVC   PASSWORD(0),0(R1)        << EXECUTED >>             LDW1
         EX    R15,*-6                                             LDW1
NOPASS   TM    PDEFLAG-PDE+VOLVOL,PDEFPRES   ANY VOL SPEC?         LDW1
         BNO   NOVOL                    NO, BLANK (=DAIR CATALOG)
         L     R1,PDEPTR-PDE+VOLVOL     GET PTR TO VOL SER
         LH    R15,PDELEN-PDE+VOLVOL    YES, GET ITS LEN
         BCTR  R15,0                    GET EX LEN
         MVC   VOLSER(0),0(R1)          << EXECUTED >>
         EX    R15,*-6                  MOVE VOL SPEC TO VOLSER
NOVOL    MVC   ALLOCDSN,BLANKS          CLEAR FIELD                LDW1
         TM    PDEFLAG-PDE+PDLALCDS,PDEFPRES   GIVEN?              LDW1
         BNO   NOALCDSN                 NO, SKIP                   LDW1
         L     R1,PDEPTR-PDE+PDLALCDS   POINT TO DSN               LDW1
         LH    R15,PDELEN-PDE+PDLALCDS  GET LENGTH                 LDW1
         STH   R15,ALLDSNL              SET LENGTH FOR ALLOC       -EU-
         BCTR  R15,0                    -1 FOR EX                  LDW1
         MVC   ALLOCDSN(0),0(R1)        << EXECUTED >>             LDW1
         EX    R15,*-6                  MOVE IN DSN                LDW1
NOALCDSN CLC   =C'FORMAT4.DSCB',DSNAME  VTOC?                      LDW1
         BNE   NOTVTOCR
         MVC   DSNAMEL(2),=H'44'                                  *WDD*
         MVI   DSNAME,X'04'             YES, CHANGE DSN
         MVC   DSNAME+1(43),DSNAME      TO 44X'04'
         MVC   DISPDSN,BLANKS           RESET FIELD                LDW1
         MVC   DISPDSN(8),=C'VTOC FOR'  SHOW SOMETHING GOOD        LDW1
         MVC   DISPDSN+9(6),VOLSER      MOVE IN VOLUME NAME        LDW1
         OI    FLAGS2,SENSF+LOGF        MARK AS SENSITIVE          LDW1
         CLI   ALLOCDSN,C' '            ALLOCDSN GIVEN?            LDW1
         BNE   NOTVTOCR                 YES, VOLSER IS IMPLIED     LDW1
         CLI   VOLSER,C' '              CATALOG FOR VTOC?
         BE    BADDSN1                  YES, WHAT DOES THAT MEAN?
NOTVTOCR XC    REQAUT(REQAUTL),REQAUT                              -EU-
         MVC   REQAUT+1(3),=AL3(MDL@IX)                            -EU-
         LA    R1,RQA                                              -EU-
         ST    R1,REQAUT+4                                         -EU-
        $EACM  REQAUT                                              -EU-
         L     R1,CVTPTR                ADDRESS OF CVT             -EU-
         USING CVT,R1                                              -EU-
         L     R1,CVTTCBP               OLD/CURRENT                -EU-
         DROP  R1                                                  -EU-
         L     R1,4(,R1)                CURRENT TCB                -EU-
         USING TCB,R1                                              -EU-
         MVC   ATIOT,TCBTIO             ADDRESS OF TIOT            -EU-
         TM    FLAGS2,SENSF             SENSITIVE DATA-SET?        -EU-
         BZ    OKDSNUP                  NO                         -EU-
         L     R1,TCBJSCB               ADDRESS OF JSCB            -EU-
         DROP  R1                                                  -EU-
         USING IEZJSCB,R1                                          -EU-
         L     R1,JSCBPSCB              ADDRESS OF TSO PSCB        -EU-
         DROP  R1                                                  -EU-
         LTR   R1,R1                    ANY PSCB?                  -EU-
         BZ    BADDSN2                  NO, NOT A TSO SESSION      -EU-
         CLI   RQA,LV0                  AUTHORIZED?                -EU-
         BE    BADDSN3                  NO, NOT AUTHORIZED         -EU-
         SETAUTH                                                   -EU-
         OI    GODFLAG,GODAUTH          SET AUTHORIZED NOW         -EU-
OKDSNUP  OI    GODFLAG,GOD              ASSUME HE CAN UPDATE       LDW1
         L     R0,=A(256*L'TIOEDDNM)    ACQUIRE DD-NAMES AREA      -EU-
         GETMAIN R,LV=(0)               MAKE IT UNCONDITIONAL      -EU-
         ST    R1,TDDNMSV               SAVE STARTING ADDRESS      -EU-
         LA    R2,256                   MAX. NO. OF DD-NAMES       -EU-
         XR    R15,R15                  RETAIN ALL DD-NAMES TO     -EU-
         L     R14,ATIOT                PREVENT DE-ALLOC. OF       -EU-
         USING TIODSECT,R14             PRE-ALLOC. DS              -EU-
SCNRTN   CLC   TIOELNGH(4),=D'0'        END OF TIOT ?              -EU-
         BE    OKDSN5                   YES, CONTINUE          -EU-LDW1
         CLC   TIOEDDNM(L'TIOEDDNM),=CL8' '                        -EU-
         BE    *+L'*+24                                            -EU-
         BCT   R2,*+L'*+4                                          -EU-
         B     TOOMANY                                             -EU-
         MVC   0(L'TIOEDDNM,R1),TIOEDDNM                           -EU-
         LA    R1,L'TIOEDDNM(R1)                                   -EU-
         XC    0(L'TIOEDDNM,R1),0(R1)                              -EU-
         IC    R15,TIOELNGH                                        -EU-
         ALR   R14,R15                                             -EU-
         B     SCNRTN                                              -EU-
         DROP  R14                                                 -EU-
         SPACE 1                                                   LDW1
*        INVALID DSN OR INVALID ACCESS. SORRY.
         SPACE 1
BADDSN   LA    R1,=CL40'DATA-SET UNAVAILABLE OR NON-EXISTENT'
         B     CSIO#
BADDSN1  LA    R1,=CL40'MISSING DSNAME TO ALLOCATE VOLUME'         -EU-
         B     CSIO#                                               -EU-
BADDSN2  LA    R1,=CL40'THIS IS NOT A TSO SESSION RUNNING'         -EU-
         B     CSIO#                                               -EU-
BADDSN3  LA    R1,=CL40'UNAUTHORIZED DATA-SET ACCESS'              -EU-
         B     CSIO#                                               -EU-
BADDSN4  LA    R1,=CL40'OPEN FAILED (ERROR)'                       -EU-
         B     CSIO#                                               -EU-
BADDSN5  LA    R1,=CL40'NO EXTENT IN DATA-SET'                     -EU-
         B     CSIO#                                               -EU-
TOOMANY  LA    R1,=CL40'DD-NAMES TABLE OVERFLOW'                   -EU-
         B     CSIO#                                               -EU-
         SPACE 1
         DROP  R7                       NO NEED FOR IKJPARMD NOW
         EJECT
*        SET UP DEFAULTS AND INITIALS COND'S.
         SPACE 1
OKDSN5   DS    0H
*LDW1    LA    R2,=C'ATTN SIGNALED'     WHAT TO SAY WHEN HE DOES
*LDW1    LA    R3,13                    LENGTH
         XC    STAXLIST(STAXL),STAXLIST INITIALIZE STAX LIST
         L     R14,=A(STAXEXIT)         POINT TO STAX EXIT
*LDW1    STAX  (R14),OBUF=((R2),(R3)),USADDR=(R13),MF=(E,STAXLIST)
         STAX  (R14),USADDR=(R13),MF=(E,STAXLIST)                  LDW1
         TM    FLAGS3,CRTF              SEE IF CRT SPECIFIED       LDW5
         BNO   OKDSN5A                  IF NOT LEAVE WIDTH ASIS
         MVC   WIDTHS(8),=XL8'0000000400000004'
OKDSN5A  L     R1,=A(TRCHARE)           INITIALIZE PTR TO...   -EU-LDW1
         ST    R1,TRTABADD              TR TABLE (THE EBCDIC ONE)
         XC    TRTXTAB,TRTXTAB                                     -EU-
         LA    R1,LINE06                PT TO FIRST AVAIL SCREEN LOC
         ST    R1,FIRSTSCR              SAVE IT
         LA    R1,LINE19                PT TO LAST AVAIL SCREEN LOC
         ST    R1,MAXSCR                SAVE IT
         XC    LOOKFOR(3*18),LOOKFOR    CLEAR SCAN STRNG SAVE AREA LDW1
         XC    MEMTTR(3),MEMTTR         NO MEMBER YET
         XC    TXTTTR(3),TXTTTR         NO TEXT FOR MEMBER YET      *N*
         XC    ESDTTR(3),ESDTTR         NO ESD PTR YET             LDW1
         MVC   ESDID(2),=H'1'           ESDID DEFAULTS TO 1 FOR IBM
         MVI   CONTINUE,0               NO SCAN, STORES OR SETS YET
         MVI   CPUTFLAG,NOCSERR         CSOUT WILL WORK FOR SURE
         BAS   R8,CLEARDEF              INITIALIZE IDEF TABLE AND PTRS
         MVC   TTR(4),=XL4'00000100'    INITIALIZE TTRN= 00000100
         SPACE 2
*        ZAP --- OPEN AND INITIALIZE I/O FILE.
         SPACE 1
         LA    R2,DSNAMEL               SET DSN                    -EU-
         CLI   ALLOCDSN,C' '            ALLOC DSN GIVEN?           LDW3
         BE    GO$ALLOC                 NO, GO DO IT               LDW1
         LA    R2,ALLDSNL               CHANGE DSN                 -EU-
         SPACE 1
*        ALLOC THE FILE AND OPEN IT, UPDAT RIGHT OFF THE BAT.
*        *** OPEN IT FOR INPUT ***                                 LDW1
         SPACE 1
GO$ALLOC ALLOC DSN=(R2),VOL=VOLSER,DISP=(SHR,KEEP,KEEP),       *WDD-EU-X
               PERM=NO,PASSWD=PASSWORD                             LDW1
         SPACE 1
         BXH   R15,R15,BADDSN
         MVC   DDNALL(8),DA08DDN-DAPB08+DAPBAREA  SAVE DDNAME      -EU-
         OI    GODFLAG,GODALL           SET ALLOCATED              -EU-
         LA    R0,DCBU                  POINT TO DCB               LDW1
         ST    R0,DCBLIST               PUT IN OPEN/CLOSE LIST
         MVI   DCBLIST,X'80'            INPUT                      LDW1
         MVC   DCBDDNAM-IHADCB+DCBU(8),DDNALL     DDNAME           -EU-
         LA    R0,EXLST                 SET UP FOR RDJFCB          LDW1
         ST    R0,DCBEXLST+DCBU-IHADCB  SET IN DCB             -EU-LDW1
         RDJFCB  MF=(E,DCBLIST)         GET THE JFCB               LDW1
         L     R1,EXLST                 -> JFCB                    LDW1
         MVC   0(44,R1),DSNAME          MAYBE CHANGE THE DSN       LDW3
         OPEN  MF=(E,DCBLIST),TYPE=J    OPEN THE DATASET           LDW1
         TM    DCBU+48,X'10'            DID IT OPEN?
         BNO   BADDSN4                  NO DARN
         SPACE 1
*        GET VOLSER.
         SPACE 1
         L     R3,DCBDEBAD-IHADCB+DCBU  GET THE DEB PTR
         L     R3,(DEBBASND-DEBBASIC)+(DEBUCBAD-DEBDASD)(R3) UCB   -EU-
         MVC   VOLSER(6),SRTEVOLI-UCB(R3)  SAVE VOL=SER OF DATASET
         CLI   DSNAME,X'04'             VTOC?                      LDW1
         BNE   OKVOLSER                 NO, OK                     LDW1
         CLI   DISPDSN+9,C' '           HAVE THE VOL ALREADY?      LDW1
         BNE   OKVOLSER                 YES, SKIP                  LDW1
         MVC   DISPDSN+9(6),VOLSER      NO, FILL IT IN             LDW1
         SPACE 2
*        FIND THE LAST TTR FROM THE FORMAT 1 DSCB OF
*        THE DATA-SET, OBTAINED, CLEVERLY ENOUGH, BY
*        AN 'OBTAIN' (ASSUMING IT'S NOT A VTOC).
         SPACE 1
OKVOLSER XC    ENDTTR,ENDTTR            SAY NO LAST TTR FOR DEFAULT
         XC    DSCB(256),DSCB           CLEAR OUT DEFAULT DSCB
         MVI   DSORG,0                  SAY NOT PARTITIONED FOR NOW
*LDW1    CLI   DSNAME,X'04'             VTOC HERE?
*LDW1    BE    NOLAST                   YES, DS1LSTAR DOESN'T EXIST
*DSCBLIST CAMLST SEARCH,DSNAME,VOLSER,DSCB                         LDW1
         MVC   DSCBLIST(4),=AL1(193,0,0,0) MOVE IN OPTIONS
         LA    R14,DSNAME               DSNAME FOR OBTAIN
         LA    R15,VOLSER               PT TO VOLSER
         LA    R0,DSCB+44               DSCB BUFFER                LDW1
         STM   R14,R0,DSCBLIST+4        STORE ALL 3 POINTERS
         OBTAIN DSCBLIST                GET THE FMT1 DSCB
         BXLE  R15,R15,GETLTTR1         IF OK USE INFO
         SPACE 1
*LDW1    TPUTX 'OBTAIN FAILED'
*LDW1    B     END
OBTFAIL  LA    R1,=CL40'OBTAIN FAILED'  POINT TO MSG               LDW1
         B     CSIO#                    LEAVE                      LDW1
         SPACE 1
GOTVTOC  MVC   DS1BLKL,=H'96'           SET BLKSIZE OF VTOC        LDW1
         MVI   DS1KEYL,44               SET KEYLEN OF VTOC         LDW1
         MVI   DSORG,0                  NO DSORG                   LDW1
         MVC   LASTFMT1(5),DSCB+45      SAVE PTR TO LAST FMT1 USED LDW4
         B     NOLAST                   CONTINUE                   LDW1
         SPACE 1
GETLTTR1 DS    0H                                                  LDW1
         CLI   DSNAME,X'04'             VTOC?                      LDW1
         BE    GOTVTOC                  YES, GET INFO              LDW1
         MVC   DSORG(1),DS1DSORG        SAVE DSORG FOR M           LDW1
         MVC   ENDTTR,DS1LSTAR          SAVE IT                    LDW4
         CLI   DS1NOEPV,0               ANY EXTENTS?              *LPR*
         BE    BADDSN5                  NO, CAN'T ACCESS          *LPR*
         TM    DS1OPTCD,DS1OPTIC        YES, ICF DATA-SET?         -EU-
         BZ    NOLAST                   NO                         -EU-
         CLI   RQA,LV14                 YES, AUTHORIZED?           -EU-
         BL    BADDSN3                  NO, NOT AUTHORIZED         -EU-
         SETAUTH                                                   -EU-
         OI    GODFLAG,GODAUTH          SET AUTHORIZED NOW         -EU-
         SPACE 1
*        BUY BUFFER.                    (THIS CODE MOVED HERE BY LDW)
         SPACE 1
NOLAST   LH    R0,DS1BLKL               PICK IT UP                 LDW1
         LTR   R0,R0                    ZERO BLKSIZE (LIKE JOBQ)?
         BP    *+L'*+4                  NO, GO ON
         LH    R0,=AL2(20*1024)         USE 20K FOR DEFAULT IN CASE
         CH    R0,=H'264'               BELOW MIN (ESP PDS DIRECTORY)
         BNL   *+L'*+4                  NO, LEAVE BLKSIZE AS IS
         LH    R0,=H'264'               YES, SET MIN=PDS DIRECTORY SIZE
         MVI   KEYLEN,0                 CLEAR FOR COPY             LDW1
         MVC   KEYLEN+1(1),DS1KEYL      COPY KEYLEN                LDW1
         AH    R0,KEYLEN                ADD TO BUFFERSIZE
         AH    R0,=Y(8+1)               GET ROOM FOR COUNT         LDW1
         SPACE 1
*        THE +1 IS SO WILL ALWAYS HAVE RESIDUAL.                   LDW1
         SPACE 1
         LR    R1,R0                    COPY VALUE
         AH    R0,=AL2(LCSOUT)          WORKAREA SIZE
         STH   R1,BUFFSIZE              STORE AWAY FOR LATER USE
         STH   R1,CCW#R#R+6             SET FOR MAX READ           LDW1
         STH   R1,CCW##R0+6             DITTO FOR R0               LDW1
         AH    R0,=Y(57)           SO NO 0C4'S NEAR BUFF. END  -EU-LDW4
         SRL   R0,3                     ROUND UP TO DOUBLE-WORD    -EU-
         SLL   R0,3                                                -EU-
         ST    R0,SIZEWORK              SAVE AREA LENGTH           -EU-
*LDW1    XC    GETLIST(GETLISTL),GETLIST  FIX IT
*LDW1    GETMAIN  EC,LV=(0),A=ADDRWORK,MF=(E,GETLIST)
*LDW1    L     R1,ADDRWORK              GET ADDR OF CORE WE HOPE
*LDW1    BXLE  R15,R15,OKGETCS          IT WORKED
*LDW1    BAS   R8,CLOSE                 NO, CLOSE THE DATASET AND
*LDW1    LA    R1,=CL40'NOT ENOUGH CORE FOR BUFFERS'  POINT TO MSG
*LDW1    B     CSIO#                    ABOUT HIS MISFORTUNE, THEN...
         GETMAIN R,LV=(0)               MAKE IT UNCONDITIONAL      LDW1
         ST    R1,ADDRWORK              SAVE ADDR FOR LATER        LDW1
         AH    R1,=AL2(LCSOUT)          ADD WORKAREA SIZ TO PT TO BUFF
         ST    R1,ADDRCNT               SAVE ADDR OF COUNT         LDW1
         STCMX R1,B'0111',CCW#R#R+1,COPY=ADDRCNT+1                 LDW1
         STCMX R1,B'0111',CCW##R0+1,COPY=ADDRCNT+1                 LDW1
         STCMX R1,B'0111',CCW#F#W+1,COPY=ADDRCNT+1                 LDW1
         LA    R1,8(,R1)                -> KEY FIELD               LDW1
         ST    R1,ADDRKEY               SAVE ADDR OF KEY           LDW1
         ST    R1,ADDRBUFF              DEFAULT DISPLAY IS KEY     LDW1
         STCMX R1,B'0111',CCW#W#W+1,COPY=ADDRBUFF+1                LDW1
         STCMX R1,B'0111',CCW#D#R+1,COPY=ADDRBUFF+1                LDW1
         TM    FLAGS2,LOGF              ARE WE LOGGING?
         BNO   *+L'*+4                  IF NOT SKIP OPEN
         BAS   R8,OPENOUT               IF SO DO THE OPEN
         SPACE 1
*        GET FREE DEFINE TABLE SYMBOLS FOR
*        'LRECL', 'KEYLEN' AND 'BLKSIZE'.
         SPACE 1
         L     R3,AIDEFTAB              PT TO DEFINE TABLE
         MVI   0(R3),C'L'               GIVE SYMBOL 'L' FOR 'LRECL'
         MVC   8(2,R3),DS1LRECL         GET LRECL, PUT IN TAB
         MVC   10(2,R3),=C'BL'          GIVE 'BL' FOR BLKSIZE (MAX)
         MVC   18(2,R3),DS1BLKL         GET BLKSIZE, PUT IN TAB    LDW1
         MVI   20(R3),C'K'              GIVE 'K' FOR 'KEYLEN' SYMBOL
         MVC   28(2,R3),KEYLEN          GET KEYLEN AND PUT IN TABLE
         LA    R3,30(,R3)               UPDATE DEFINE TABLE PTR
         ST    R3,IDEFAVAL              SAVE IT AS PTR TO CURR ENTRY
         MVC   REP,BLANKS               CLEAR REPLY OUT            LDW1
         MVC   ICREP,REP                                           -EU-
         MVI   CAPSFLG,YESCAPS                                     -EU-
         MVC   LINE19,BLANKS            CLEAR ERR MSG PART OF SCRN LDW1
         XC    BASEVAL,BASEVAL          BASE = 0                   LDW1
         TM    FLAGS3,F3270             3270 MODE?                 LDW5
         BNO   NO$STFS                  NO, SKIP                   LDW1
         STFSMODE  ON,INITIAL=YES       START IT UP                LDW1
         OI    FLAGS3,FSMODE            IT'S ON, NOW               LDW5
         B     NEW$READ                 DON'T TPUT VERSION LINE    LDW5
NO$STFS  MVC   LINEBUFF(40),BLANKS      INIT                       LDW5
         MVC   LINEBUFF(L'VERSION),VERSION                         LDW1
         BAS   R14,PUTLINE$             SAY WHAT VERSION           LDW1
         SPACE 2
*        ZAP --- CREATE THE SCREEN DISPLAY AND GET COMMAND.
*        HERE IF A NEW BLOCK IS TO BE READ AND
*        THE SCREEN IS TO BE BUILT FROM IT.
         SPACE 1                                                   LDW1
NEW$READ XC    NOWSTUFF(NOWLEN-L'BASEVAL),NOWSTUFF RESET BUFF OFF  LDW1
         BAS   R8,READBLK               GET A BLK FROM DS (BDAM)
         B     NEW$DISP                 SKIP AROUND                LDW1
         SPACE 1
*        HERE IF BUILD SCREEN WITHOUT READING A NEW BUFFER IN.
         SPACE 1
NEWDSPNT MVI   TRACE,NOTRACE            SET FLAG                   LDW1
NEW$DISP BAS   R8,CLEAR                 CLEAR THE SCREEN
         OC    BLKLEN(2),BLKLEN         0 READ BEFORE?
         BZ    DISPLAY                  YES, THERE'S NOTHING TO DISP
         LH    R8,OLDPOINT              GET CARET OFFSET           LDW1
         N     R8,NOWMASK               GET HIGH PART              LDW1
         LR    R5,R8                    COPY                       LDW1
         SH    R8,SCRBYTES              BACK UP TO SCREEN START    LDW1
         BNM   *+L'*+2                  CONTINUE IF OK             LDW1
         XR    R8,R8                    SCR START = BLK START      LDW1
         A     R8,ADDRBUFF              GET ADDRESS INTO BUFFER
         A     R5,ADDRBUFF              GET DBLW ADDRESS INTO BUFFER
         L     R15,FIRSTSCR             PT TO FIRST AVAIL SCREEN POS
         SPACE 1
*        FORMAT ONE LINE OF SCREEN DISPLAY.
         SPACE 1
FORMAT   LR    R0,R8                    COPY BUFFER PTR            LDW1
         S     R0,ADDRBUFF              OFFSET INTO BUFFER FOR SCR LDW1
         ST    R0,TEMP                  SAVE FOR UNPK              LDW1
         HEX   (0,R15),TEMP+1,LEN=3,DIGITS=5,HEXTAB=TRHEX          LDW1
         MVC   TEMP(16),0(R8)           COPY CHAR FORM OF DATA     LDW1
         UNPK  TEMP2+00(14+1),TEMP+00(7+1)   BYTES 01-07           LDW1
         UNPK  TEMP2+14(14+1),TEMP+07(7+1)   BYTES 08-14           LDW1
         UNPK  TEMP2+28(04+1),TEMP+14(2+1)   BYTES 15-16           LDW1
         TR    TEMP2(32),TRHEX          MAKE EBCDIC                LDW1
         L     R1,TRTABADD              GET RIGHT TRTAB PTR        LDW4
         TR    TEMP(16),0(R1)           MAKE IT VALID CHARS        LDW4
         LR    R1,R0                    COPY BLK OFFSET            LDW1
         AH    R1,LINEHEX               GET NEXT OFFSET            LDW1
         SH    R1,BLKLEN                COMPUTE AMOUNT SHORT       LDW1
         BNP   FORMATOK                 SKIP IF THIS LINE FULL     LDW1
         LA    R14,TEMP2                -> AREA                    LDW1
         AH    R14,LINEHEX2             -> PAST END                LDW1
         LA    R2,0(R1,R1)              GET LENGTH OF HEX GARBAGE  LDW1
         SR    R14,R2                   -> GARBAGE HEX             LDW1
FMTBLANK MVC   0(0,R14),BLANKS          << EXECUTED >>             LDW1
         EX    R2,*-6                   BLANK THE GARBAGE HEX      LDW1
         SPACE 1
*        NOTE THAT TEMP2 IS LONG ENOUGH THAT BLANKING              LDW1
*        1 CHAR TOO MANY DOESN'T HURT ANYTHING.                    LDW1
         SPACE 1
         LA    R14,TEMP                 -> CHARS                   LDW1
         AH    R14,LINEHEX              -> PAST END                LDW1
         SR    R14,R1                   -> GARBAGE CHARS           LDW1
         BCTR  R1,0                     -1 FOR EX                  LDW1
         EX    R1,FMTBLANK              CHARS ALSO GET TREATMENT   LDW1
         SPACE 1
*ORMATOK MVC   08(4,R15),TEMP2+00       MOVE HEX TO SCREEN         LDW1
*        MVC   13(4,R15),TEMP2+04                                  LDW1
*        MVC   19(4,R15),TEMP2+08                                  LDW1
*        MVC   24(4,R15),TEMP2+12                                  LDW1
*        MVC   31(4,R15),TEMP2+16                                  LDW1
*        MVC   36(4,R15),TEMP2+20                                  LDW1
*        MVC   42(4,R15),TEMP2+24                                  LDW1
*        MVC   47(4,R15),TEMP2+28                                  LDW1
*        MVI   54(R15),C'|'             PUT IN DELIM               LDW1
*        MVC   55(16,R15),TEMP          MOVE CHARS                 LDW1
*        MVI   71(R15),C'|'             ENDING DELIM               LDW1
         SPACE 1
FORMATOK MVC   TEMP2+32(2),=C' |'       MOVE IN CONSTANTS FOR TR   LDW1
         CLI   LINELEN+1,40             WHICH ONE?                 LDW1
         BE    FORMAT40                 SHORT                      LDW1
         MVC   7(65,R15),DISPTR80       MOVE IN "TRANSLATE" TABLE  LDW1
         TR    7(65,R15),TEMP           DISTRIBUTE HEX TO SCREEN   LDW1
         B     FORMATXX                 CONTINUE                   LDW1
FORMAT40 MVC   7(32,R15),DISPTR40       MOVE IN SHORT TABLE        LDW1
         TR    7(32,R15),TEMP           DISTRIBUTE HEX TO SCREEN   LDW1
FORMATXX CR    R8,R5                    BUFF PTR = DATA PTR?       LDW1
         BNE   NO$CARET                 NO, SKIP CARET             LDW1
         LR    R1,R15                   COPY LINE ADDR             LDW1
         BCTR  R1,0                     BACK UP TO ATTR BYTE       LDW1
         MVI   0(R1),X'E8'              HIGH INTENSITY PROTECTED   LDW1
         LH    R1,OLDPOINT              GET CARET OFFSET           LDW1
         N     R1,BITMASK               GET LOW ORDER PART         LDW1
         LA    R3,BYTES(R1)             PT TO COLUMN OF SCRN       LDW1
         IC    R1,0(,R3)                GET SCREEN COL FOR CARET   LDW1
         LA    R14,0(R15,R1)            PT TO WHERE IT GOES        LDW1
         MVI   0(R14),C'>'              ASSUME EVEN                LDW1
         TM    OLDPOINT+1,1             IS IT?                     LDW1
         BNO   *+L'*+4                  YES, SKIP                  LDW1
         MVI   0(R14),C'<'              ODD POINTS THE OTHER WAY   LDW1
         ST    R14,MIDLINE              SAVE PTR TO CARET LINE     LDW1
NO$CARET AH    R8,LINEHEX               UPDATE BUFFER PTR          LDW1
         LA    R15,$I(,R15)             UPDATE SCREEN PTR          LDW1
         AH    R0,LINEHEX               NEXT OFFSET                LDW1
         CH    R0,BLKLEN                PAST END OF BLOCK?         LDW1
         BNL   DISPLAY                  YES, GO DISPLAY            LDW1
         C     R15,MAXSCR               OUT OF SCREEN?             LDW1
         BL    FORMAT                   NO, DO ANOTHER LINE        LDW1
         B     DISPLAY                  SKIP (WE WILL TRACE)       LDW1
DISPLYNT MVI   TRACE,NOTRACE            SET NOTRACE FLAG           LDW1
DISPLAY  MVI   TTR+3,NOSEQRD            TURN OFF SEQ READ          LDW5
         MVI   EOFRET,YESEOF            SAY EOF'S WILL BE RECOGNIZED
         TM    FLAGS3,F3270             FULLSCREEN?                LDW5
         BNO   *+L'*+8                  NO, SKIP                   LDW3
         NI    FLAGS2,255-NOWHEREF      YES, DON'T SUPPRESS WHERE  LDW1
         NI    FLAGS3,255-NODISPF       ... OR REDISPLAY           SDM6
         TM    FLAGS3,NODISPF           SUPPRESS REDISPLAY?        SDM6
         BO    NOTWHERE                 YES, GO DIRECT TO OUTPUT   SDM6
         TM    FLAGS2,NOWHEREF+TERSEF   SEE IF WHERE SUPPRESSED
         BNZ   NOTWHERE                 IF ON SUPPRESS IT
     MVC LINE03(40),=CL40'ENTER VALID COMMAND ABOVE OR ? FOR HELP' LDW1
         MVC   LINE03+72-L'VERSION(L'VERSION),VERSION              LDW1
         MVC   LINE03+61(7),ZAP+10      PUT IN THE ASM DATE        LDW1
WHEREAMI CLI   LINELEN+1,80             LONG LINES?                LDW1
         BE    WHERE80                  YES, FORMAT MORE INFO      LDW1
         MVC  LINE21+17(34),=C'TTR: XXXXXX CCHHR: XXXXXXXXXX LEN:' LDW1
         HEX   LINE21+36,CCHHR,LEN=5                               LDW1
         HEX   LINE21+22,TTR,LEN=3                                 LDW1
         MVC   LINE20+17(4),=C'DSN:'    MOVE IN MASK               LDW1
         MVC   LINE20+22(24),DISPDSN    SHOW THE DSNAME            LDW1
         MVC   LINE20+47(4),=C'OFF:'    MOVE IN MASK               LDW1
         HEX   LINE20+53,OLDPOINT,LEN=2 OFFSET                     LDW1
         MVC   LINE21+52(5),EDMASK+3    GET READY TO EDIT IN BLKLN LDW1
         LH    R1,BLKLEN                GET THE LENGTH READ        LDW1
         CVD   R1,TEMP                  CONV TO DECIMAL            LDW1
         ED    LINE21+51(6),TEMP+5      EDIT IT TO SCREEN          LDW1
         B     NOTWHERE                 CONTINUE                   LDW1
WHERE80  MVC   LINE20+00(4),=C'OFF:'                               LDW1
         LH    R15,OLDPOINT             GET OFFSET IN BUFFER       LDW1
         BAS   R14,NUMCONV              CONVERT IT                 LDW1
         MVC   LINE20+05(4),TEMP2+12+4  MOVE IN HEX PART           LDW1
         MVI   LINE20+10,C'('                                      LDW1
         MVC   LINE20+11(6),TEMP2+6     DECIMAL PART               LDW1
         MVC   LINE20+17(7),=C') ADDR:'                            LDW1
         L     R15,OFFSET               GET IT                     LDW1
         BAS   R14,NUMCONV              CONVERT                    LDW1
         MVC   LINE20+25(5),TEMP2+12+3  HEX PART                   LDW1
         MVI   LINE20+31,C'('                                      LDW1
         MVC   LINE20+32(8),TEMP2+4     DECIMAL PART               LDW1
         MVC   LINE20+40(6),=C') DSN:'                             LDW1
         MVC   LINE20+47($L-47),DISPDSN DSN                        LDW1
         MVC   LINE21+00(4),=C'LEN:'                               LDW1
         LH    R15,BLKLEN               GET LENGTH OF BLOCK        LDW1
         BAS   R14,NUMCONV              CONVERT                    LDW1
         MVC   LINE21+05(4),TEMP2+12+4  HEX PART                   LDW1
         MVI   LINE21+10,C'('                                      LDW1
         MVC   LINE21+11(6),TEMP2+6     DECIMAL PART               LDW1
         MVC   LINE21+17(7),=C') BASE:'                            LDW1
         L     R15,BASEVAL              BASE                       LDW1
         BAS   R14,NUMCONV              CONVERT                    LDW1
         MVC   LINE21+25(5),TEMP2+12+3  HEX PART                   LDW1
         MVI   LINE21+31,C'('                                      LDW1
         MVC   LINE21+32(8),TEMP2+4     DECIMAL PART               LDW1
         MVC   LINE21+40(8),=C') CCHHR:'                           LDW1
         UNPK  LINE21+49(10+1),CCHHR(5+1)                          LDW1
         TR    LINE21+49(10),TRHEX      MAKE IT EBCDIC             LDW1
         MVC   LINE21+59(5),=C' TTR:'                              LDW1
         HEX   LINE21+66,TTR,LEN=3                                 LDW1
NOTWHERE NI    FLAGS2,255-NOWHEREF      ENABLE WHERE LINE          LDW1
         BAS   R8,CSIO                  DISPLAY SCREEN JUST MADE   SDM6
         EJECT
*        ZAP --- COMMAND CHECKING AND EXECUTION.
*        FIND REPLY LENGTH AND COPY IT TO TEMP2.
         SPACE 1
COMSCAN  MVC   ICREP,REP                HANDLE A COPY              -EU-
         OC    REP,BLANKS               MAKE IT UPPER CASE         LDW1
         LH    R1,READLEN               GET READ LENGTH            SDM6
         LA    R1,REP(R1)               POINT TO LAST CHAR + 1     SDM6
COMGET   BCTR  R1,0                     DECREMENT POINTER          SDM6
         CLI   0(R1),C' '               END OF STRING?             SDM6
         BE    COMGET                   NO, GO TEST ANOTHER CHAR   SDM6
         LA    R0,REP-1                 GET LENGTH...              SDM6
         SR    R1,R0                    ... OF DATA                SDM6
         BNP   NEWDSPNT                 ZERO, IGNORE WITH NO TRACE SDM6
         STH   R1,REALRDLN              PHONY UP THE ACTUAL READ LEN
         MVC   TEMP2(40),REP            COPY START OF COMMAND      LDW1
         SPACE 1
*        (SOME ROUTINES MODIFY THE COMMAND IN TEMP2).              LDW1
*        SEE IF THE COMMAND IS IN THE COMMAND TABLE.
         SPACE 1
         LR    R0,R1                    GET THE TRUE READ LENGTH   LDW1
         XR    R1,R1                    CLEAR REG FOR IC'S
         L     R2,=A(COMTAB)            PT TO COMMAND TABLE        LDW1
         BAS   R14,*+L'*+4              SET LOOP ADDR & SKIP       LDW1
         LA    R2,12(,R2)               -> NEXT TABLE ENTRY        LDW1
         CLI   0(R2),X'FF'              END OF TABLE
         BE    EXPR                     YES, NOT IN TAB, AN EXPRESS?
         IC    R1,0(,R2)                NO, PICK UP LEN OF COMMAND
         EX    R1,COMCLC                COMMAND MATCH?
         BNER  R14                      NO, CHECK NEXT             LDW1
         L     R2,8(,R2)                PICK UP ROUTINE ADDR
         BCTR  R0,0                     COMPUTE LENGTH OF ...      LDW1
         SR    R0,R1                    ... REMAINING INPUT        LDW1
         LA    R1,TEMP2+1(R1)           -> START OF OPERANDS       LDW1
         BR    R2                       GO DO IT
         SPACE 1
*        NOTE : CC IS SET FOR OPERAND LENGTH = 0 OR Â¬=0.           LDW1
         SPACE 1
COMCLC   CLC   REP(0),1(R2)             << EXECUTED >>             LDW1
         SPACE 2
*        ZAP --- COMMAND EXECUTION --- EXPRESSION.
*        *****  NO COMMAND (EXPRESSION)  *****
         SPACE 1
EXPR     LA    R1,REP                   GET EXPRESSION PTR         LDW1
         LH    R0,REALRDLN              GET EXPRESSION LEN
PARSE    L     R15,OFFSET               GET '*' (CURRENT VALUE)    LDW1
         MVI   EXPOPT,YESSYMB           SAY 'LOOK AT THE SYMBOL TABLE'
         BAS   R8,CALLEXP               GO PARSE                   LDW1
         S     R15,BASEVAL              GET OFFSET IN BUFFER       LDW1
         BNM   SETPOINT                 IT'S NON-NEG, SO WE'RE OK  LDW1
SETPNT00 XR    R15,R15                  CAN'T HAVE NEGATIVE
         CLC   ADDRBUFF,ADDRCNT         DISPLAYING COUNT FIELD?    LDW1
         BNE   SETPOINT                 NO, OK                     LDW1
         LA    R15,8                    YES, PUT CARET AT KEY      LDW1
SETPOINT LH    R2,BLKLEN                GET BLKLENGTH              LDW1
         BCTR  R2,0                     -1 FOR COMPARE
         CR    R15,R2                   ARE WE STILL WITHIN THE BLK?
         BNH   *+L'*+2                  YES, WE'RE OK
         LR    R15,R2                   NO, MAKE IT THE END OF BLK
         STH   R15,OLDPOINT             SAVE OFFSET FOR CURR LOC
         A     R15,BASEVAL              RELOCATE IT                LDW1
         ST    R15,OFFSET               SAVE ADDR                  LDW1
         B     NEW$DISP                 GO DO IT
INVEXPER LA    R2,INVEXP                YES, SAY INVALID SYNTAX
         SPACE 1
*        NOTE : R1 WILL PT TO THE COLUMN OF THE ERROR.
         SPACE 1
         B     BOTCH                    AND GO TELL HIM WITH NO TRACE
         SPACE 2                        SPLIT HERE
*        ZAP --- COMMAND EXECUTION --- HELP, ?.
*        HELP (?, ?1, ?2, ?3, ?4, ?5, ?6, ?7, HELP, H, H1,...,H7)  LDW1
         SPACE 1
PFKHELP  MVC   LINE19,BLANKS            CLEAR THE ERROR MSG IF ANY -EU-
HELPHELP TM    FLAGS3,F3270             FULLSCREEN?                LDW5
         BZ    HELPALL                  NO, DO IT OLD WAY          LDW3
         XR    R3,R3                    HE WANTS HELP #1 ("HELP")  LDW2
         B     HELPOK                   AND PROCESS                LDW1
HELP     BNP   HELPHELP                 JUST "?" - GIVE HIM "?1"   LDW1
         TM    FLAGS3,F3270             FULLSCREEN?                LDW5
         BZ    HELPALL                  NO, DO IT OLD WAY          LDW3
         XR    R15,R15                  * = 0                      LDW1
         BAS   R8,CALLEXP               PARSE OPERAND              LDW1
         LTR   R3,R15                   GET THE ANSWER             LDW2
         BNP   INVEXPER                 NO GOOD                    LDW1
         BCTR  R3,0                     -1 FOR OFFSET              LDW2
         CH    R3,=H'15'                GREATER THAN 9?            LDW2
         BL    HELPOK                   NO, SKIP                   LDW1
         SH    R3,=H'6'                 EXP THOUGHT IT WAS HEX     LDW1
HELPOK   LA    R2,1+C'1'(,R3)           GET NEXT PROMPT            LDW1
         BAS   R8,CLEAR                 CLEAR THE SCREEN FIRST     LDW1
         CH    R3,=Y(13-1)              TOO BIG?                   LDW1
         BH    INVEXPER                 YES, BYE BYE               LDW1
         BL    *+L'*+4                  NO, USE IT, WE HAVE PROMPT LDW1
         LA    R2,C'1'                  AT END, WRAP TO BEGIN      LDW1
         LR    R1,R3                    COPY # TO BETTER REG       LDW1
         OI    REP-1,X'01'              SET THE MDT FLAG           SDM4
         MVC   REP,BLANKS               BLANK THE PROMPT           SDM4
         MVI   REP,C'?'                 SET UP PROMPT              LDW1
         STC   R2,REP+1                 DO IT                      LDW1
         CLI   REP+1,X'FA'              TOO BIG?                   LDW1
         BL    *+L'*+12 >==========+    NO, OK                     LDW1
         MVI   REP+1,C'1'          |    SET FIRST DIGIT            LDW1
         SH    R2,=H'10'           |    FIX OTHER DIGIT            LDW1
         STC   R2,REP+2            |    SET IT                     LDW1
         L     R2,=V(ZAPHELP)  <===+    POINT TO STUFF             LDW1
         MH    R1,=H'520'               * LENGTH OF EACH           LDW1
         A     R1,4(,R2)                POINT TO IMAGE             LDW1
         LA    R2,LINE06                FIRST SCREEN LINE FOR HELP LDW1
         LA    R14,$I                   BXLE INCR                  LDW1
         LA    R15,LINE18+20            LAST SCREEN LINE FOR HELP  LDW1
         LA    R0,40                    INCR FOR HELP              LDW1
         CLI   LINELEN+1,80             LONG LINES?                LDW1
         BNE   *+L'*+4                  NO, SKIP                   LDW1
         LA    R2,LINE06+17             YES, CENTER IT             LDW1
         MVC   0(40,R2),0(R1)           MOVE 1 LINE                LDW1
         AR    R1,R0                    INCR SOURCE PTR            LDW1
         BXLE  R2,R14,*-8               MOVE 520 BYTES             LDW1
         B     DISPLYNT                 GIVE HIM SCR (NOTRACE)     LDW1
         SPACE 1
*        *****  HELP (NON FULLSCREEN TERMINALS)  *****
         SPACE 1
HELPALL  OI    FLAGS3,NODISPF           DON'T REDISPLAY AT END     SDM5
         L     R2,=V(ZAPHELP)           POINT TO HELP              SDM6
         L     R3,0(,R2)                GET NUMBER OF LINES TO TPUT
         LA    R8,8(,R2)                -> INDICATOR BYTES         LDW1
         L     R2,4(,R2)                -> FIRST LINE              LDW1
HELPLOOP CLI   0(R8),0                  DUMP THIS LINE?            LDW1
         BE    HELPSKIP                 NO, SKIP IT                LDW1
         MVC   LINEBUFF(40),0(R2)       MOVE TO TEMP BUFFER        LDW1
         BAS   R14,PUTLINE$             PRINT IT                   LDW1
         TM    FLAGS2,ATTNHIT           SEE IF USER INTERRUPTED IT LDW5
         BO    HELPINT                  I DON'T BLAME HIM
HELPSKIP LA    R2,40(,R2)               POINT TO NEXT LINE         LDW1
         LA    R8,1(,R8)                NEXT INDICATOR BYTE        LDW1
         BCT   R3,HELPLOOP              GIVE HIM NEXT LINE
         B     DISPLYNT                 GO BACK TO USER            SDM6
HELPINT  NI    FLAGS2,255-ATTNHIT       TURN OFF INTERRUPT         LDW5
         B     DISPLYNT                 GO BACK TO USER            SDM6
         SPACE 2
*        ZAP --- COMMAND EXECUTION --- LOG, CRT, TERSE, VERBOSE, DISP.
*        ***** LOG
         SPACE 1
LOG      BAS   R8,LOGTEST               OPEN THE DS IF NOT OPEN    LDW1
         LA    R2,LOGONMSG              POINT TO MSG               LDW1
         B     BOTCH                    DISPLAY MSG                LDW1
         SPACE 1
*        ***** CRT
         SPACE 1
CRT      OI    FLAGS3,CRTF              SET FLAG                   LDW5
         MVC   WIDTHS(8),=XL8'0000000400000004' SET WIDTH
         NI    FLAGS2,255-TERSEF        SET VERBOSE MODE
         OI    FLAGS3,NODISPF           DON'T REDISPLAY            SDM6
         B     DISPLYNT                 GO BACK TO USER, NO TRACE  SDM6
         SPACE 1
*        ***** TERSE/VERBOSE
         SPACE 1
TERSE    OI    FLAGS2,TERSEF            SUPPRESS WHERE
         OI    FLAGS3,NODISPF           DON'T REDISPLAY            SDM6
         B     DISPLYNT                 GO BACK TO USER, NO TRACE  SDM6
VERBOSE  NI    FLAGS2,255-TERSEF        ALLOW WHERE
         OI    FLAGS3,NODISPF           DON'T REDISPLAY            SDM6
         B     DISPLYNT                 GO BACK TO USER, NO TRACE  SDM6
         SPACE 1
*        *****  DISP
         SPACE 1
DISPC    MVC   ADDRBUFF,ADDRCNT         -> COUNT                   LDW1
         LH    R14,CCW#W#W+6            GET KL+DL                  LDW1
         LA    R14,8(,R14)              INCLUDE LEN OF COUNT       LDW1
         STH   R14,BLKLEN               SET DISPLAY BLOCK LENGTH   LDW1
         LA    R15,8                    DISPLAY OFFSET             LDW1
         B     SETPOINT                 RE-DISPLAY NEAR TOP        LDW1
DISPK    MVC   ADDRBUFF,ADDRKEY         -> KEY                     LDW1
         MVC   BLKLEN,CCW#W#W+6         SET DISPLAY BLOCK LENGTH   LDW1
         B     SETPNT00                 RE-DISPLAY AT TOP          LDW1
DISPD    MVC   ADDRBUFF,ADDRDATA        -> DATA                    LDW1
         LH    R14,CCW#W#W+6            GET KL+DL                  LDW1
         SH    R14,KEYLEN               DON'T DISPLAY KEY          LDW1
         STH   R14,BLKLEN               SET DISPLAY BLOCK LENGTH   LDW1
         B     SETPNT00                 RE-DISPLAY AT TOP          LDW1
         SPACE 2
*        ZAP --- COMMAND EXECUTION --- END.                        LDW3
*        *****  END  *****
         SPACE 1
ENDPFK   MVC   REP,BLANKS
         MVC   REP(3),=C'END'
END      BAS   R8,CHKPT                 CHECK TO SEE IF ZAP REQ
         BAS   R8,KILL3270              TURN OFF 3270 MODE         LDW3
         BAS   R8,CLOSE                 CLOSE THE FILE IF ANY
         TM    GODFLAG,GODALL           ALLOCATED?                 -EU-
         BZ    ENDALL                   NO                         -EU-
         CLI   DSNAME,X'04'             WAS DSN CHANGED TO VTOC?   -EU-
         BE    SKPCHK                   YES, SKIP CHECK            -EU-
         L     R1,TDDNMSV               NO, CHECK TO PREVENT THE   -EU-
SCNCHK   CLC   0(L'TIOEDDNM,R1),=D'0'   DE-ALLOC. OF PRE-ALLOC. DS -EU-
         BE    SKPCHK                                              -EU-
         CLC   0(L'TIOEDDNM,R1),DDNALL                             -EU-
         BNE   *+L'*+8                                             -EU-
         NI    GODFLAG,255-GODALL       RESET                      -EU-
         B     ENDALL                                              -EU-
         LA    R1,L'TIOEDDNM(R1)                                   -EU-
         B     SCNCHK                                              -EU-
SKPCHK   FREE  DDNAME=DDNALL            FREE IT                    -EU-
         NI    GODFLAG,255-GODALL       RESET                      -EU-
         CLI   DSNAME,X'04'             WAS DSN CHANGED TO VTOC?   -EU-
         BNE   ENDALL                   NO, SKIP                   -EU-
         CLI   ALLOCDSN,C' '            YES, ALLOCDSN GIVEN?       -EU-
         BE    ENDALL                   NO, SKIP                   -EU-
         SPACE 1                                                   -EU-
*        THE ONLY WAY TO DEQUEUE THE "ALLOCDSN" NAME               -EU-
*        IS TO RE-ALLOCATE IT, AND THEN FREE IT.                   -EU-
         SPACE 1                                                   -EU-
         ALLOC DSN=ALLDSNL,VOL=VOLSER,DISP=(SHR,KEEP,KEEP),        -EU-X
               PERM=NO,PASSWD=PASSWORD                             -EU-
         BXH   R15,R15,ENDALL           SKIP IF ANYTHING WRONG     -EU-
         MVC   DDNALL(8),DA08DDN-DAPB08+DAPBAREA  GET DDNAME       -EU-
         FREE  DDNAME=DDNALL            FREE IT                    -EU-
ENDALL   ICM   R1,B'1111',TDDNMSV       DD-NAMES AREA ADDRESS      -EU-
         BZ    SKPFREE                                             -EU-
         L     R0,=A(256*L'TIOEDDNM)    DD-NAMES AREA LENGTH       -EU-
         FREEMAIN R,LV=(0),A=(1)                                   -EU-
SKPFREE  TM    GODFLAG,GODAUTH          WAS AUTHORIZED?            -EU-
         BZ    ENDXIT                   NO                         -EU-
         RESAUTH                                                   -EU-
         NI    GODFLAG,255-GODAUTH      RESET                      -EU-
ENDXIT   TM    FLAGS2,LOGF              SEE IF LOGGING
         BNO   EXITOUT                  IF NOT NO CLOSE
         L     R1,CSOUTWK               GET WORKAREA
         LTR   R1,R1                    IF ANY
         BZ    EXITOUT                  NONE, CAN'T BE OPEN THEN
         CLI   ENQIT,0                  WAS ANYTHING IMPORTANT SAID?
         BNE   EXITENQ                  YES, DO IT
EXITSCR  TPUTX 'ZAP LOG DELETED'                                   MAS3
         L     R1,CSOUTWK               @ CSOUT WORK AREA          MAS3
*LDW1    CSOUT SCR,MF=(E,(1)),CALL=CALL DELETE FILE
         MVI   0(R1),X'02'          (+) INDICATE SCRATCH
         LR    R2,R1                (+) COPY WORKAREA PTR
         L     R15,=V(CSOUT)        (+) POINT TO ROUTINE
         LR    R1,CSREG             (+) GET CSAREA PTR
         BASR  R14,R15              (+) CALL IT
         B     EXITOUT                  THEN LEAVE
EXITENQ  LA    R1,N5                    POINT TO DIGIT
         BAS   R8,SETLINE               SET UP A LINE
         B     EXITOUT                  NOT PRINTING?
         MVC   20(33,R2),=C'FILE CLOSED - PROCESSING COMPLETE'
         MVI   0(R2),C'-'               TRIPLE SPACE IT
         BAS   R8,CPUT                  DUMP IT
         TPUTX 'ZAP LOG REQUIRED? (YES,NO)',ASIS                   MAS3
         LM    R0,R1,REGS3270     SCREENL, @ SCREEN                MAS3
         LA    R1,0(,R1)          CLEAR TPUT FULSCR FLAG           MAS3
         O     R1,=X'80000000'    MAKE IT TGET                     MAS3
         TPUT  (1),(0),R          GET USER RESPONSE                MAS3
         LTR   R15,R15            CHECK RC FROM TGET               MAS3
         BNZ   EXITENQ1           GO ENQ IF ERROR ON INPUT         MAS3
         CH    R1,=H'2'           EXACTLY 2 CHARS OF INPUT?        MAS3
         BNE   EXITENQ1           BIF NOT 2 CHARS OF INPUT         MAS3
         OC    SCREEN(2),BLANKS   MAP TO UPPER CASE                MAS3
         CLC   SCREEN(2),=CL2'NO' EXACTLY 'NO'?                    MAS3
         BE    EXITSCR                                             MAS3
EXITENQ1 L     R1,CSOUTWK               RELOAD WORKAREA PTR
*LDW1    LA    R14,HISBIN
*LDW1    CSOUT ENQ,(14),=H'1',CALL=CALL,MF=(E,(1))
         MVI   0(R1),X'40'          (+) FLAG AS ENQUEUE CALL
*LDW1    ST    R14,4(,R1)           (+) STORE FIRST PARM
*LDW1    LA    R0,=H'1'             (+)
*LDW1    ST    R0,8(,R1)            (+) STORE SECOND PARM
         LR    R2,R1                (+) COPY WORKAREA PTR
         L     R15,=V(CSOUT)        (+) POINT TO ROUTINE
         LR    R1,CSREG             (+) GET CSAREA PTR
         BASR  R14,R15              (+) CALL IT
EXITOUT  ICM   R1,B'1111',ADDRWORK      "LCSOUT" WORK-AREA?        -EU-
         BZ    XQUIT                    NONE                       -EU-
         L     R0,SIZEWORK              GET HIS SIZE               -EU-
        FREEMAIN R,LV=(0),A=(1)         FREE IT                    -EU-
XQUIT    L     R13,4(,R13)              RESTORE THE REG STUPID     -EU-
         LM    R14,R12,12(R13)          RESTORE
         XR    R15,R15                  RC=0
         BR    R14                      BYE BYE
         SPACE 2
*        ZAP --- COMMAND EXECUTION --- EBCDIC, ASCII, ZCODE,
*                                      //DEBUG' LW
*        *****  EBCDIC  *****
         SPACE 1
EBCDIC   L     R1,=A(TRCHARE)           PICK UP PTR TO EBCDIC TRTAB-EU-
         LA    R2,EBCDCMSG              TELL HIM WHAT JUST HAPPENED
         XR    R15,R15                                             -EU-
EBCDIC#  ST    R1,TRTABADD              SAVE FOR LATER DISPLAYS
         ST    R15,TRTXTAB                                         -EU-
         OI    FLAGS2,NOWHEREF          SUPRESS WHERE
         B     BOTCH                    GO DO IT AND DISPLAY
         SPACE 1                                                   LDW1
*        *****  ASCII  *****
         SPACE 1
ASCII    L     R1,=A(IECTRASA)          PICK UP PTR TO ASCII TRTAB -EU-
         LA    R2,ASCIIMSG              TELL HIM WHAT JUST HAPPENED
         L     R15,=A(IECTSASA)                                    -EU-
         B     EBCDIC#                  GO FINISH THE JOB
         SPACE 1                                                   LDW1
*        *****  ZCODE  *****
         SPACE 1
ZCODE    L     R1,=A(TRCHARZ)           PICK UP PTR TO ZCODE TRTAB -EU-
         LA    R2,ZCODEMSG              SAY WHAT TYPE OF TRANS
         L     R15,=A(TRCHRZ)                                      -EU-
         B     EBCDIC#                  AND DO IT FROM NOW ON
         SPACE 1
*        *****  //DEBUG  *****
         SPACE 1
DIEFAST  BAS   R8,KILL3270              TURN OFF 3270 MODE         LDW1
         DC    X'00C1'                  "HALT..."                  LDW1
         LA    R2,OUCH                  PT TO MSG                  LDW1
         B     BOTCH                    RESUME IF "GO" FROM TEST   LDW1
         SPACE 2
*        ZAP --- COMMAND EXECUTION --- #, LAST, LASTDS1.           LDW1
*        *****  # (CALC)  *****
         SPACE 1
CALC     L     R15,OFFSET               GET '*' = CURRENT OFFSET   LDW1
         MVI   EXPOPT,YESSYMB           TELL HIM SCAN SYMB TAB
         BAS   R8,CALLEXP               PARSE & CHECK              LDW1
         MVC   LINE19+17(20),=CL20'CALCULATE VALUE:'    MOVE IN MASK
         BAS   R14,NUMCONV              CONVERT                    LDW1
         MVC   LINE19+34(12),TEMP2      DECIMAL PART               LDW1
         MVC   LINE19+48(8),TEMP2+12    HEX PART                   LDW1
         B     NEWDSPNT                 GIVE IT TO HIM
         SPACE 1
*        *****  LAST  *****
         SPACE 1
LAST     BAS   R8,CHKPT                 CHECK TO SEE IF ZAP REQ
         CLI   DSNAME,X'04'             IS THERE A LAST TTR (NOT VTOC)?
         LA    R2,LASTINV               PT TO MESSAGE IN CASE
         BE    BOTCH                    NO, TELL HIM               LDW1
         MVC   TTR(3),ENDTTR            PICK UP LAST TTR           LDW4
         B     NEW$READ                 GO GIVE IT TO HIM
         SPACE 1
*        *****  LASTDS1  *****                                     LDW1
         SPACE 1
LASTDS1  BAS   R8,CHKPT                 CHECK TO SEE IF ZAP REQ    LDW1
         CLI   DSNAME,X'04'             IS THIS THE VTOC?          LDW1
         LA    R2,NOTVTOC               PT TO MESSAGE IN CASE      LDW1
         BNE   BOTCH                    NO, TELL HIM               LDW1
         XC    DBLW,DBLW                CLEAR AREA FOR 'ABS'       LDW1
         SPACE 1
*        ASSUME VTOC IS 1 EXTENT ==> M=0.                          LDW1
         SPACE 1
         MVC   DBLW+3(5),LASTFMT1       SET CCHHR OF LAST FMT1     LDW1
         B     ABSGOT1                  GO FAKE AN 'ABS' COMMAND   LDW1
         SPACE 2
*        ZAP --- COMMAND EXECUTION --- D, U.                       LDW1
*        *****  D  *****
         SPACE 1
PFKDOWN  MVC   REP,BLANKS                                       .AFDSC.
         MVI   REP,C'D'                                         .AFDSC.
         MVC   LINE19,BLANKS            CLEAR THE ERROR MSG IF ANY -EU-
         XR    R0,R0                                            .AFDSC.
DISPLAY# BNZ   PARSE                    MORE THAN A 'D'            LDW1
         BAS   R8,DU$COM                GET # OF BYTES             LDW1
         AR    R15,R14                  WHERE TO POINT TO NOW (OFFSET)
         CH    R15,BLKLEN               PAST BLK?
         BL    SETPOINT                 NO, GO ON
         SRL   R14,1                    TRY HALF WAY THEN
         SR    R15,R14                  MAYBE NOW?
         CH    R15,BLKLEN               STILL ICKY?
         BNL   OFLOD                    YES, GIVE UP AND NEXT BLK
         LH    R15,BLKLEN               NO, PT TO END OF BLK + 1
         B     SETPOINT                 GO GIVE IT TO HIM
OFLOD    BAS   R8,CHKPT                 CHECK TO SEE IF ZAP REQ
         BAS   R8,READNBLK              GET THE NEX BLK            LDW1
         B     SETPNT00                 GO GIVE HIM OFFSET 0       LDW1
         SPACE 1
*        *****  U  *****                                           LDW1
         SPACE 1
PFKUP    MVC   REP,BLANKS                                       .AFDSC.
         MVI   REP,C'U'                                         .AFDSC.
         MVC   LINE19,BLANKS            CLEAR THE ERROR MSG IF ANY -EU-
         XR    R0,R0                                            ,AFDSC.
UP       BAS   R8,DU$COM                GET # OF BYTES             LDW1
         SR    R15,R14                  BACK UP                    LDW1
         BNM   SETPOINT                 USE IT IF OK               LDW1
         B     SETPNT00                 TOO FAR, USE 0             LDW1
DU$COM   L     R14,WIDTHD               GET # OF LINES BELOW       LDW1
         A     R14,WIDTHU               ADD NUMBER OF LINES ABOVE  LDW1
         LA    R14,1(,R14)              ADD CARET LINE             LDW1
         MH    R14,LINEHEX              GET # OF BYTES DISPLAYED   LDW1
         LH    R15,OLDPOINT             GET CURRENT OFFSET         LDW1
         BR    R8                       RETURN TO "D" OR "U"       LDW1
         SPACE 2
*        ZAP --- COMMAND EXECUTION --- =, NODEF.                   LDW1
*        *****  =  *****
         SPACE 1
EQUALS   BNP   INVEXPER                 ERROR IF JUST '='          LDW1
         LR    R7,R1                    -> STRING                  LDW1
         LR    R1,R0                    LENGTH                     LDW1
         BAS   R8,HEXCHECK              SEE IF VALID NUMBER        LDW1
         B     EQUALBAD                 CAN'T USE #'S FOR SYMBOLS  LDW1
         L     R4,IDEFAVAL              GET PTR TO 1ST AVAIL TABL POS
         CLI   0(R4),X'FF'              END OF TABLE?
         LA    R2,TABFULL               GET MSG ADDR IN CASE       LDW1
         BE    BOTCH                    NO ROOM...                 LDW1
         L     R3,AIDEFTAB              PT TO BEGINNING            LDW1
         SPACE 1
*        SEE IF THE SYMBOL IS ALREADY DEFINED.
         SPACE 1
ICLOOP   CR    R3,R4                    UP TO FIRST AVAIL POS YET?
         BNL   OKIDEF                   YES, NO DUPLICATE, SO DEFINE
         CLC   0(8,R3),REP+1            NO, SYMBOL ALREADY HERE?  LDW1
         BE    REDEF                    YES, SO REDEFINE IT
         LA    R3,10(,R3)               NO, PT TO NEXT SPOT IN TABLE
         B     ICLOOP                   KEEP GOING TILL OUT
REDEF    MVC   0(8,R3),REP+1            MOVE IN THE SYMBOL         LDW1
         MVC   8(2,R3),OFFSET+2         MOVE IN THE OFFSET         LDW1
         LA    R2,REDEFMSG              PT TO MSG SAYING REDEFINED SYM
         B     BOTCH                    DONT RESET FIRST AVAIL - LEAVE
OKIDEF   MVC   0(8,R4),REP+1            MOVE IN THE SYMBOL TO TAB  LDW1
*LDW1    MVC   8(2,R4),OLDPOINT         MOVE IN OFFSET INTO BLK
         MVC   8(2,R4),OFFSET+2         MOVE IN THE OFFSET         LDW1
         LA    R4,10(,R4)               POINT TO NEXT AVAIL
         ST    R4,IDEFAVAL              SAVE FOR NEXT TIME
         OI    FLAGS2,NOWHEREF          SUPRESS WHERE LINES
         B     NEWDSPNT                 DISPLAY (NOTRACE)
EQUALBAD LA    R2,BADEQUAL              PT TO MSG                  LDW1
         B     BOTCH                    MAS CAN'T COMPLAIN ANYMORE LDW1
         SPACE 1
*        *****  NODEF  *****
         SPACE 1
NODEF    BAS   R8,CLEARDEF              YES, LET HIM HAVE IT
         LA    R2,DEFRESET              TELL HIM WE RESET THE TABLE
         OI    FLAGS2,NOWHEREF          SUPRESS WHERE LINES
         B     BOTCH                    GO BACK TO DISPLAY (NOTRACE)
         SPACE 2
*        ZAP --- COMMAND EXECUTION --- IDEF.
*        *****  IDEF  *****
         SPACE 1
IDEF     BAS   R8,CLEAR                 CLEAR THE SCREEN
         MVC   LINE06(16),=C' SYMBOL   OFFSET'  MOVE MASK FOR COL 1
         MVC   LINE06+20(3*20-4),LINE06  MAKE 3 MORE COLUMNS       LDW1
         LA    R1,LINE08                PT TO DISPLAY              LDW1
         CLI   LINELEN+1,80             4 COLUMNS OK?              LDW1
         BE    *+L'*+10                 YES, LEAVE IT              LDW1
         MVC   LINE06+40($L-40),BLANKS  NO, KILL LAST 2            LDW1
         LA    R1,LINE07                PT TO DISPLAY              LDW1
         L     R2,IDEFAVAL              PT PAST LAST LOC TO FMT    LDW1
         L     R3,AIDEFTAB              PT TO TABLE                LDW1
         OI    FLAGS2,NOWHEREF          SUPRESS WHERE LINES
IDEFNEWL LA    R4,2                     ASSUME 2 COLUMNS           LDW1
         CLI   LINELEN+1,80             RIGHT?                     LDW1
         BNE   IFMTLOOP                 YES, OK                    LDW1
         AR    R4,R4                    NO, MAKE IT 4 COLUMNS      LDW1
IFMTLOOP CR    R3,R2                    DONE WITH FORMATTABLE STUFF?
         BNL   DISPLYNT                 YES, DISPLAY WITH NO TRACE
         MVC   0(8,R1),0(R3)            MOVE SYMBOL TO DISPLAY
         HEX   (11,R1),(8,R3),LEN=2     MOVE IN OFFSET             LDW1
         LA    R1,20(,R1)               UPDATE DISPLAY PTR
         LA    R3,10(R3)                UPDATE TABLE PTR
         BCT   R4,IFMTLOOP              DO ANOTHER                 LDW1
         LA    R1,$I-4*20(,R1)          INCREMENT A LITTLE MORE    LDW1
         CLI   LINELEN+1,80             WAS THAT ENOUGH MORE?      LDW1
         BE    IDEFNEWL                 YES, DO ANOTHER LINE       LDW1
         LA    R1,40(,R1)               NO, FIX IT                 LDW1
         B     IFMTLOOP                 KEEP UP THE GOOD WORK
         SPACE 2
*        ZAP --- COMMAND EXECUTION --- ITRACE.
*        *****  ITRACE  *****
         SPACE 1
ITRACE   L     R2,AITRCTAB              PT TO BEGINNING OF TABLE   LDW1
         OI    FLAGS2,NOWHEREF          SUPRESS WHERE LINES
         BAS   R8,CLEAR                 CLEAR THE SCREEN
         MVC   LINE06+1(11),=C' TTR   OFFS'   MOVE IN TITLE FOR COL 1
         MVC   LINE06+14(13*5-2),LINE06+1     MAKE 5 MORE COLUMNS  LDW1
         LA    R3,LINE08                FIRST AVAIL SCREEN POSIT   LDW1
         CLI   LINELEN+1,80             6 COLUMNS OK?              LDW1
         BE    NEWLINE                  YES, LEAVE IT              LDW1
         MVC   LINE06+40($L-40),BLANKS  NO, KILL LAST 2            LDW1
         LA    R3,LINE07                FIRST AVAIL SCREEN POSIT   LDW1
NEWLINE  LA    R4,3                     CNT FOR GOOD OFFSET DISP LOOP
         CLI   LINELEN+1,80             NEED 6 COLUMNS?            LDW1
         BNE   ITRFMTLP                 NO, LEAVE IT               LDW1
         AR    R4,R4                    YES, MAKE IT 6             LDW1
ITRFMTLP CLI   0(R2),X'FF'              END OF TABLE
         BE    DISPLYNT                 GO DISPLAY (NOTRACE & NO REBLD)
         HEX   (1,R3),(0,R2),LEN=3      MOVE IN TTR                LDW1
         HEX   (8,R3),(3,R2),LEN=2      MOVE IN OFFSET             LDW1
         C     R2,CURRITR               IS THIS THE CURRENT TRACE TAB
         BNE   *+L'*+4                  NO, GO ON WITH FORMATTING
         MVI   0(R3),C'>'               MOVE IN THE PTR TO CURR ENTRY
         LA    R3,13(R3)                UPDATE SCREEN PTR
         LA    R2,5(,R2)                UPDATE TABLE PTR
         BCT   R4,ITRFMTLP              DO IT THRICE (OR 6)
         LA    R3,$I-6*13(,R3)          MAKE UP FOR ODDBALL SCREEN LDW1
         CLI   LINELEN+1,80             6 COLUMNS?                 LDW1
         BE    NEWLINE                  YES, DO NEXT LINE          LDW1
         LA    R3,39(,R3)               MAKE UP FOR ODDBALL SCREEN
         B     NEWLINE                  DO IT ALL OVER
         SPACE 2
*        ZAP --- COMMAND EXECUTION --- >, <.
*        *****  >  *****
         SPACE 1
FORWARD  L     R3,ITRAVAL               PICK UP PTR TO NEXT TRACE
         MVI   TRACE,NOTRACE            DON'T TRACE > FOR PETE'S SAKE
         CLI   0(R3),X'FF'              END OF TABLE?
         BNE   *+L'*+4                  NO, NO PROBLEM
         L     R3,AITRCTAB              YES, SO WRAP TO TOP        LDW1
         CLI   0(R3),X'FE'              EXIST YET?                 LDW1
         LA    R2,INVFMSG               GET MSG ADDR IN CASE       LDW1
         BE    BOTCH                    NO - TELL HIM NO GOOD      LDW1
         LA    R2,5(,R3)                PT TO NEXT ONE AFTER THAT
         LR    R4,R2                    SAVE NEXT CURRENT ONE
         B     CARET                    FINISH ALL THE REST
         SPACE 1                                                   LDW1
*        *****  <  *****
         SPACE 1
BACKWARD MVI   TRACE,NOTRACE            DON'T TRACE A < EITHER
         L     R2,AITRCTAB              PT TO TRACE TABLE          LDW1
         L     R3,ITRAVAL               PT TO NEXT CURRENT ENTRY
         CR    R3,R2                    CURRENT ENTRY = FIRST ENTRY?
         BNE   *+L'*+4                  NO, NO PROBLEM (YET)
         L     R3,AITREND               YES, MUST LOOP TO TAB END  LDW1
         SH    R3,=H'5'                 BACKTRACK ONE ENTRY
         LR    R4,R3                    SAVE FOR LATER ITRAVAL
         CR    R3,R2                    IS THAT THE BEGINNING NOW?
         BNE   *+L'*+4                  NO, NO MORE WORRIES
         L     R3,AITREND               YES, WE LOOP TO ENDTAB     LDW1
         SH    R3,=H'5'                 BACKTRACK ONE ENTRY
         CLI   0(R3),X'FE'              DOES THAT ENTRY EXIST?     LDW1
         BNE   CARET                    YES, WE'RE OK
         LA    R2,INVBMSG               NO, TELL HIM SO AND
         B     BOTCH                    GO TELL HIM
         SPACE 1                                                   LDW1
*        DO THE CARET. IF LEAVING BLOCK, CHECK TO SEE OF BLK REPLACED.
         SPACE 1
CARET    CLC   TTR(3),0(R3)             NEW BLOCK NEEDED?
         BE    RDNOTNEC                 NO, DON'T BOTHER WITH CHECK
         BAS   R8,CHKPT                 YES, MAKE SURE THIS ONES OK
         MVC   TTR(3),0(R3)             NEW BLK, GET CORRECT TTR
         ST    R3,TEMP                  SAVE PTR TO THE ENTRY
         BAS   R8,READBLK               READ THE BLOCK IN
         L     R3,TEMP                  PICK UP THE PTR BACK
RDNOTNEC ST    R4,ITRAVAL               NEW TRACE TABLE PTR
         ST    R3,CURRITR               SAVE CURRENT TRACE TAB ENTRY
         MVC   TEMP(2),3(R3)            NOW GET OFFSET FROM TRACE TAB
         LH    R15,TEMP                 INTO RIGHT REG             LDW1
         B     SETPOINT                 GO FAKE A '+' COMMAND
         SPACE 2
*        ZAP --- COMMAND EXECUTION --- T, P, %.                    LDW1
*        *****  T  *****
         SPACE 1
TRACK    BAS   R8,CHKPT                 ANY ZAP NEEDED?
         LTR   R0,R0                    TEST OPERAND LENGTH        LDW1
         BNZ   MORET                    NOT JUST 'T'
         LH    R15,TTR                  JUST A T (T=T+1)
         LA    R15,1(R15)               POINT TO NEXT TRACK
         B     POSTRACK                 GO DO IT
MORET    LH    R15,TTR                  PICK UP '*' TRACK
         BAS   R8,CALLEXP               PARSE & CHECK              LDW1
         BM    TTRLT1                   NEGATIVE IS BAD            LDW1
POSTRACK STH   R15,TTR                  SAVE TRACK #
         MVI   TTR+2,X'01'              GIVE HIM REC=01
         B     NEW$READ                 READ AND DISPLAY
         SPACE 1                                                   LDW1
*        *****  P  *****
         SPACE 1
POINT    BAS   R8,CHKPT                 ANY ZAP NEEDED?
         LTR   R0,R0                    TEST OPERAND LENGTH        LDW1
         BNZ   MOREP                    MORE THAN P - GET TTR
         MVC   TTR(4),=XL4'00000100'    JUST 'P',GIVE HIM TTRN=00000100
         B     NEW$READ                 DO IT
MOREP    BAS   R6,TTRPARSE              GET THE TTR SPECIFIED      LDW1
         MVC   TTR(3),TEMP+1            MOVE IN TTR
         B     NEW$READ                 GO GET IT
         SPACE 1
*        *****  J  *****                                           MAS2
*        (TTR FROM BEGINING OF VOLUME - FOR JES HASPACE)           MAS2
         SPACE 1                                                   MAS2
POINT$J  BAS   R8,CHKPT                 ANY ZAP NEEDED?            MAS2
         LTR   R0,R0                    TEST OPERAND LENGTH        MAS2
         BNZ   POINT$J2                 MORE THAN P, GET TTR       MAS2
         MVC   TTR(4),=XL4'00000100'    JUST 'P',GIVE HIM TTRN=00000100
         B     NEW$READ                 DO IT                      MAS2
POINT$J2 BAS   R6,TTRPARSE              GET THE TTR SPECIFIED      MAS2
         MVC   TTR(3),TEMP+1            MOVE IN TTR                MAS2
POINT$J3 L     R14,DCBU+12              @ DEVICE CHAR TABLE ENTRY  MAS2
         L     R15,DCBU+44              @ DEB                      MAS2
         LH    R0,32+6(,R15)            1ST EXTENT CYL BEGIN       MAS2
         MH    R0,2(,R14)               * # OF TRKS/CYL            MAS2
         AH    R0,32+8(,R15)            + 1ST EXTENT TRK BEGIN     MAS2
         LH    R1,TTR                   GET TRACK SPECIFIED        MAS2
         SR    R1,R0                      ON VOLUME                MAS2
         STH   R1,TTR                       (FOR JES/VTOC TTRS)    MAS2
         B     NEW$READ                 GO GET IT                  MAS2
         SPACE 1
*        *****  %  *****                                           LDW1
         SPACE 1
INDPOINT LH    R15,OLDPOINT             GET BUFFER OFFSET          LDW1
         MVI   EXPOPT,YESSYMB           WANT SYM TAB LOOKUP        LDW1
         BAS   R8,CALLEXP               EVALUATE OPERAND           LDW1
         BM    INVEXPER                 NEG IS INVALID             LDW1
         LH    R0,BLKLEN                GET BLOCK LENGTH           LDW1
         SH    R0,=H'3'                 LAST POSSIBLE TTR          LDW1
         CR    R15,R0                   PAST END?                  LDW1
         BH    INVEXPER                 YES, ERROR                 LDW1
         A     R15,ADDRBUFF             GET ADDR IN BUFFER         LDW1
         BAS   R8,CHKPT                 CAN HE LEAVE?              LDW1
         MVC   TTR(3),0(R15)            SET NEW TTR                LDW1
         B     NEW$READ                 GO READ IT & DISPLAY       LDW1
         SPACE 2
*        ZAP --- COMMAND EXECUTION --- ABS.
*        *****  ABS *****
         SPACE 1
ABS      BAS   R8,CHKPT                 SEE IF HE CAN LEAVE
         LTR   R15,R0                   TEST OPERAND LENGTH        LDW1
         BNP   INVEXPER                 IT'S BAD                   LDW1
         CH    R15,=H'10'               CCHHR TOO LONG?
         BNH   *+L'*+4                  NO, OK
         LH    R15,=H'10'               YES, TRUNCATE
         EX    R15,ABSTR                TRANSLATE TO "HEX", NO EX LEN
         EX    R15,ABSPACK              GET 000CCHHR        NO EX LEN
         SPACE 1
*        FIND 'M'.
         SPACE 1
         L     R15,DCBDEBAD-IHADCB+DCBU GET DEB
         XR    R1,R1                    START WITH M=0
         XR    R0,R0                    FOR IC
         IC    R0,DEBNMEXT-DEBBASIC(,R15)    GET NUMBER OF EXTENTS -EU-
ABSLOOP  CLC   DBLW+3(4),(DEBBASND-DEBBASIC)+(DEBSTRCC-DEBDASD)(R15)
         BL    ABSNEXT                  NOT IN THIS EXTENT
         CLC   DBLW+3(4),(DEBBASND-DEBBASIC)+(DEBENDCC-DEBDASD)(R15)
         BNH   ABSGOT                   NOT IN THIS EXTENT
ABSNEXT  LA    R15,16(,R15)             NEXT EXTENT
         LA    R1,1(,R1)                NEXT 'M'
         BCT   R0,ABSLOOP               NEXT EXTENT
         BAS   R8,CLEAR                 CLEAR THE SCREEN FIRST     LDW1
         MVC   TTR(3),=X'FFFFFFFFFF'    SET UP A BAD TTR           LDW1
         MVC   CCHHR(5),=X'FFFFFFFFFF'  HERE TOO                   LDW1
         MVI   IOERROR,YESSYN           SAY "IOERROR"              LDW1
         XC    BLKLEN,BLKLEN            NOTHING TO DISPLAY         LDW1
         MVC   LINE05+17(40),IOERRMSG   MOVE IN MASK               LDW1
         MVC   LINE05+35(15),=CL15'NOT IN DATA-SET'                LDW1
         B     DISPLYNT                 GO SAY BOTCHED             LDW1
ABSGOT   STC   R1,DBLW                  SET 'M'
ABSGOT1  STM   R9,R12,56(R13)           SAVE REGS CONVERT KILLS
         L     R1,DCBDEBAD-IHADCB+DCBU  GET DEB AGAIN
         LA    R2,DBLW                  GET 'MBBCCHHR'
         LR    R3,R13                   SAVE R13 TOO
         L     R15,CVTPTR               CVT
         L     R15,CVTPRLTV-CVT(,R15)   GET ABS=>REL CONVERT
         BASR  R14,R15                  GO GET TTRZ
         LR    R13,R3                   RESTORE R13
         LM    R9,R12,56(R13)           RESTORE OTHER REGS
         ST    R0,TTR                   SAVE TTR
         B     NEW$READ                 GO READ/DISPLAY
ABSTR    TR    TEMP2+3(0),TRHEX         << EXECUTED >>             LDW1
ABSPACK  PACK  DBLW(9),TEMP2+3(0)       << EXECUTED >>
         SPACE 2
*        ZAP --- COMMAND EXECUTION --- B, R.                       LDW1
*        *****  B  *****
         SPACE 1
BACK     BAS   R8,CHKPT                 ANY ZAP NEEDED?
         MVI   EOFRET,NOEOF             TREAT EOF'S AS DATA BLKS
         XR    R15,R15                  CLEAR FOR IC               LDW1
         IC    R15,TTR+2                GET R                      LDW1
         SH    R15,=H'1'                BACK IT UP 1               LDW1
         B     RBACK                    GO CHECK IT                LDW1
         SPACE 1                                                   LDW1
*        *****  R  *****
         SPACE 1
RECORD   BAS   R8,CHKPT                 ANY ZAP NEEDED?
         CLI   DSORG,DSORGPO            ARE WE IN A PDS?
         BNE   *+L'*+4                  NO, TELL HIM ABOUT EOF'S
         MVI   EOFRET,NOEOF             YES, TREAT EOF'S AS DATA BLKS
         LTR   R0,R0                    TEST OPERAND LENGTH        LDW1
         BP    MORER                    NOT JUST 'R'
         MVI   TTR+3,SEQREAD            GO TO NEXT RECORD
         B     NEW$READ                 READ AND DISPLAY
MORER    XR    R15,R15                  CLEAR FOR IC
         IC    R15,TTR+2                GET CURRENT RECORD
         BAS   R8,CALLEXP               PARSE & CHECK              LDW1
RBACK    XR    R1,R1                    CLEAR FOR IC
         IC    R1,TTR+2                 GET CURRENT RECORD
         LR    R3,R15                   PRESERVE ABSOLUTE FOR BACK
         SR    R3,R1                    FIND OFFSET
         LR    R5,R15                   SAVE IT
*        R3 IS RELATIVE OFFSET
*        R5 IS ABSOLUTE VALUE
         BZ    NEW$READ                 IF STILL HERE, REREAD
         BM    RGOBACK                  IF NEGATIVE, BACK UP
         SPACE 1
*        OFFSET IS POSITIVE : READ FORWARD ENOUGH TIMES.
         SPACE 1
RGOFORW  MVI   EOFRET,YESEOF            WE WANT TO STOP AT EOF FOR +
         BAS   R8,READNBLK              READ NEXT BLOCK            LDW1
         CLI   IOERROR,YESSYN           WAS THERE AN I/O ERROR?
         BE    NEWDSPNT                 YES, CUT THIS OUT
         BCT   R3,RGOFORW               GO FORWARD
         B     NEW$READ                 WHEN DONE, DISPLAY IT
         SPACE 2
*        ZAP --- COMMAND EXECUTION --- R.                          LDW1
*        OFFSET IS NEGATIVE : READ BACKWARD ENOUGH TIMES.
         SPACE 1
RGOBACK  LTR   R5,R5                    WAS ABSOLUTE ON THIS TRACK?
         STC   R5,TTR+2                 ASSUME YES, SET NEW RECORD
         BP    NEW$READ                 YES, READ IT               LDW1
         SPACE 1
*        BACK UP A TRACK.
         SPACE 1
         LH    R0,TTR                   GET TRACK NUMBER
         BCTR  R0,0                     MINUS ONE
         LTR   R0,R0                    BACK TO ZERO?
         BNM   RCOUNT                   ITS GOOD, COUNT TRACK
         MVC   TTR(4),=XL4'00000100'    BACKED UP TOO FAR
         BAS   R8,SETMSG                MOVE MSG TO RIGHT PLACE    LDW1
         DC    Y(TTRSMALL+1-ZAP)        'TTR < 000001 INVALID' -EU-LDW1
         B     NEW$READ                 DISPLAY FIRST RECORD
RCOUNT   STH   R0,TTR                   SAVE FOR COUNT
         MVI   TTR+2,0                  IT WILL INCREMENT
         MVC   TEMP(3),TTR              SAVE TTR
BCKCNT   BAS   R8,READNBLK              GET A BLK                  LDW1
         CLC   TEMP(2),TTR              STILL THIS TRACK?
         BNE   RNEWTRK                  NO
         CLI   IOERROR,YESSYN           I/O ERROR?
         BE    NEWDSPNT                 GET OUTA HERE
         MVC   TEMP+2(1),TTR+2          SAVE THIS RECORD
         B     BCKCNT                   CONTINUE DOWN TRACK
RNEWTRK  MVC   TTR(2),TEMP              RESTORE PREVIOUS TRACK
         XR    R1,R1                    CLEAR FOR PICKUP
         IC    R1,TEMP+2                GET NUMBER OF RECS
         AR    R5,R1                    WE NOW ARE THIS FAR BACK
         B     RGOBACK                  GO SEE IF ITS ON THIS TRK
         SPACE 2                                                   -EU-
*        ZAP --- COMMAND EXECUTION --- CAPSON, CAPSOFF.            -EU-
         SPACE 1                                                   -EU-
CAPSON   MVI   CAPSFLG,YESCAPS          SET CAPS ON                -EU-
         LA    R2,CONMSG                TELL STATUS DONE           -EU-
         B     BOTCH                    GO BACK TO DISPLAY         -EU-
CAPSOFF  MVI   CAPSFLG,NOCAPS           SET CAPS OFF               -EU-
         LA    R2,COFFMSG               TELL STATUS DONE           -EU-
         B     BOTCH                    GO BACK TO DISPLAY         -EU-
         SPACE 2
*        ZAP --- COMMAND EXECUTION --- L, F.
         SPACE 1
PFKLOC   MVC   REP,BLANKS                                       .AFDSC.
         MVI   REP,C'L'                                         .AFDSC.
         MVC   LINE19,BLANKS            CLEAR THE ERROR MSG IF ANY -EU-
         XR    R0,R0                                            .AFDSC.
         STH   R0,REALRDLN              FAKE THE READ LENGTH       -EU-
         MVI   REALRDLN+1,1                                        -EU-
         SPACE 1
*        *****  F  *****
         SPACE 1
FIND     MVI   EOFRET,NOEOF             SET SO EOF'S COME BACK     LDW1
         SPACE 1
*        *****  L  *****
         SPACE 1
LOCATE   LTR   R3,R0                    TEST OPERAND LENGTH        LDW1
         BZ    LGO                      JUST L, GO CONTINUE        LDW1
         LR    R4,R1                    PT TO STRING               LDW1
         LA    R5,LOOKFOR               POINT TO STRING SAVEAREA
         BAS   R6,GETSTRNG              GET THE HEX OR CHAR STRING
         B     AROUND1
         SPACE 1
*        CONTINUE SCAN.
         SPACE 1
LGO      TM    CONTINUE,YESCONTL        CAN WE CONTINUE SCAN?
         LA    R2,LINMSG                ASSUME NO, PT TO MSG
         BNO   BOTCH                    NO, NO SCAN WAS STARTED    LDW1
         LH    R3,LOOKFOR               YES, GET THE SCAN LEN      LDW1
         SPACE 1
*        SET UP SCAN.
         SPACE 1
AROUND1  LA    R14,LOOKFOR              GET THE STRING ADDRESS     -EU-
         BAS   R8,STRCNV                GO APPLY CONVERSION        -EU-
         XR    R2,R2                    CLEAR REG FOR IC (WHAT ELSE?)
         IC    R2,WKSTR                 GET 1ST CHAR TO FIND   -EU-LDW1
         LA    R2,TEMPTRT(R2)           PT TO OFFSET IN TRTAB
         XC    TEMPTRT(256),TEMPTRT     CLEAR TRTAB
         MVI   0(R2),X'FF'              MOVE IN FF THERE
         OI    CONTINUE,YESCONTL        SAY HE CAN CONTINUE SCAN NOW
         LH    R1,OLDPOINT              GET CURRENT OFFSET         LDW1
         CLI   REALRDLN+1,1             JUST 'L' ENTERED?          LDW1
         BNE   *+L'*+4                  NO, START FROM HERE        LDW1
         LA    R1,1(,R1)                YES, START FROM NEXT BYTE  LDW1
         B     LOOK8                    GO ON
         SPACE 2
*        BLOCK SCAN LOOP.
         SPACE 1
LOOK7    XR    R1,R1                    RESET BUFFER PTR
LOOK8    A     R1,ADDRBUFF              PT TO OFFSET IN BUFFER
         BCTR  R1,0                     -1
         LH    R5,BLKLEN                GET BLK LENGTH
         A     R5,ADDRBUFF              PT TO END OF BLK
         SPACE 1
*        DO THE SCAN.
         SPACE 1
*SDM3    TRT   1(256,R1),TEMPTRT        IS 1ST CHAR THERE?
LOOKLOOP LR    R2,R5                    GET END                    SDM3
         SR    R2,R1                    COMPUTE LENGTH             SDM3
         SH    R2,=H'2'                 GET LENGTH OF REMAINDER    SDM3
         BM    TOOFAR                   NOT ENOUGH                 SDM3
         EX    R2,SCANTRT               FIND INTERESTING STRING    SDM3
         BZ    LOOK1                    NOT YET, KEEP TRYING
         CR    R1,R5                    YES, BUT IS IT PAST THE BLK?
         BNL   TOOFAR                   YES, SO GET A NEW ONE
         EX    R3,SCANCLC               NO, IS ALL OF IT THERE?
         BNE   LOOKLOOP                 NO, KEEP CHECKING
         MVC   LINE19+17(40),=CL40'        *****  SCAN MATCH  *****'
         S     R1,ADDRBUFF              YES, GET WHERE IT IS AND...
         LR    R15,R1                   INTO RIGHT REG             LDW1
         B     SETPOINT                 FAKE A '+' COMMAND TO IT
SCANTRT  TRT   1(0,R1),TEMPTRT          << EXECUTED >>             SDM3
SCANCLC  CLC   0(0,R1),WKSTR            << EXECUTED >>         -EU-LDW1
*SDM3    LA    R1,256(R1)               UPDATE TRT PTR TO BUFFER
LOOK1    N     R2,=XL4'FF'              GET CLEAN SINGLE BYTE      SDM3
         LA    R1,1(R1,R2)              SET LOCATION TO TRY AGAIN  SDM3
         CR    R1,R5                    PAST BLK?
         BL    LOOKLOOP                 NO, KEEP SCANNING
TOOFAR   BAS   R8,CHKPT                 ANY ZAP NEEDED?
TOOFAR2  BAS   R8,READNBLK              GET NEXT BLK FOR SCANNING  LDW1
         CLI   IOERROR,YESSYN           I/O ERROR?
         BE    NEWDSPNT                 YES, GET OUT
         CLI   DSNAME,X'04'             VTOC?                      LDW4
         BE    TOOFAR4                  YES, DIFFERENT CHECK       LDW4
         CLC   TTR(3),ENDTTR            HAVE WE ARRIVED?           LDW4
         BE    TOOFAR3                  YES, PAUSE                 LDW4
NOT2FAR  OC    BLKLEN,BLKLEN            ANYTHING HERE? (EOF IF 'F')LDW1
         BE    TOOFAR2                  NO, GET NEXT BLOCK         LDW1
         B     LOOK7                    GO SCAN IT THEN
TOOFAR3  MVC   LINE19+22(33),=C'*****  HOLDING AT DS1LSTAR  *****' LDW4
         B     SETPNT00                 DISP OFF 0, CURR BLK       LDW4
TOOFAR4  CLC   CCHHR(5),LASTFMT1        IS THIS THE LAST FMT1?     LDW4
         BNE   NOT2FAR                  NO, CONTINUE SCAN          LDW4
         MVC   LINE19+22(33),=C'*****  HOLDING AT LASTFMT1  *****' LDW4
         B     SETPNT00                 DISP OFF 0, CURR BLK       LDW4
         SPACE 2
*        ZAP --- COMMAND EXECUTION --- S, X, O, N.
*        *****  N  *****
         SPACE 1
AND      BAS   R2,SXON                  PT TO EX INSTR, GO DO IT   LDW1
         NC    0(0,R5),WKSTR            << EXECUTED >>      'N'-EU-LDW1
         SPACE 1
*        *****  O  *****
         SPACE 1
OR       BAS   R2,SXON                  PT TO EX INSTR, GO DO IT   LDW1
         OC    0(0,R5),WKSTR            << EXECUTED >>      'O'-EU-LDW1
         SPACE 1
*        *****  X  *****
         SPACE 1
EXOR     BAS   R2,SXON                  PT TO EX INSTR, GO DO IT   LDW1
         XC    0(0,R5),WKSTR            << EXECUTED >>      'X'-EU-LDW1
         SPACE 1
*        *****  S  *****
         SPACE 1
STORE    BAS   R2,SXON                  PT TO EX INSTR, GO DO IT   LDW1
         MVC   0(0,R5),WKSTR            << EXECUTED >>      'S'-EU-LDW1
         SPACE 2
*        ALLOW HIM TO USE PREVIOUS STRING IF HE JUST ENTERS
*        THE COMMAND WITH NO SUBSEQUENT STRING OPERAND.
         SPACE 1
SXON     ST    R2,0(,R13)               SAVE THE EX INSTR PTR
         LTR   R3,R0                    TEST OPERAND LENGTH        LDW1
         BP    SXONNEW#                 HAVE AN OPERAND - USE IT   LDW1
         SPACE 1
*        USE AN OLD STRING FOR S,X,O,N WITH NO OPERANDS.
         SPACE 1
         TM    CONTINUE,YESCONTS        JUST 'S'.  OLD STRING YET?
         BO    SXONNEW                  YES, GO ON
         B     INVEXPER                 SAY SYNTAX ERROR COL 2     LDW1
INVALCOM LA    R2,INVCOM                PT TO MSG                  LDW1
         B     BOTCH                    AND TELL HIM               LDW1
         SPACE 1
*        USE SPECIFIED STRING.
         SPACE 1
SXONNEW# LR    R4,R1                    POINT TO STRING OPERAND    LDW1
         LA    R5,ZAPSTRNG              POINT TO STRING WORK AREA
         BAS   R6,GETSTRNG              GET AL2(LEN),C'STRING'
         SPACE 1
*        AT THIS POINT, ZAPSTRNG CONTAINS
*        THE INFO NECESSARY TO STORE :
*        AL2(STRING_LENGTH),C'STRING'
         SPACE 1
SXONNEW  OC    BLKLEN(2),BLKLEN         ANYTHING TO CHANGE HERE?
         BZ    INVALCOM                 NO, TELL HIM               LDW1
         TM    GODFLAG,GOD              CAN HE EVER UPDATE?
         BO    LETSTORE                 YES, SO GO ON
         BAS   R8,SETMSG                MOVE MSG TO RIGHT PLACE    LDW1
         DC    Y(STORMSG-ZAP)           TELL HIM NOT UPDATING      LDW1
LETSTORE LA    R14,ZAPSTRNG             GET THE STRING ADDRESS     -EU-
         BAS   R8,STRCNV                GO APPLY CONVERSION        -EU-
         LH    R4,ZAPSTRNG              GET LEN                -EU-LDW1
         LH    R5,OLDPOINT              PT TO ZAPPED OFFSET
         SPACE 2                                                   LDW1
*        CHECK TO SEE IF STRING WILL FIT IN THE REMAINING
*        PART OF THE BLK WHERE HE IS POINTING.
         SPACE 1                                                   LDW1
         LH    R6,BLKLEN                GET LENGTH OF BLK
         SR    R6,R5                    GET LENGTH OF PIECE REMAINING
         CR    R6,R4                    IS IT SMALLER THAN THE STRING?
         LA    R2,LENERR                ASSUME STRING IS INVALID LENGTH
         BNH   BOTCH                    YES, SO GO TELL HIM        LDW1
*        STRING WILL FIT.
         A     R5,ADDRBUFF              PT TO ACTUAL ZAPPED DATA
         OI    CONTINUE,YESCONTS        SAY HE CAN DO 'SXON' NO OPRND
         LA    R1,N1                    MESSAGE NUMBER
         BAS   R8,SETLINE               SET UP THE LINE
         B     NOMSGEX                  NOT PRINTING
         CLI   CHNGED,0                 VIRGIN BUFFER?
         BNE   *+L'*+4                  NO, SINGLE SPACE
         MVI   0(R2),C'0'               ELSE, DOUBLE SPACE FIRST CHANGE
         MVC   31(16,R2),=C'OFFSET XXXX DATA'
******%% MVC   31(27,R2),=C'OFFSET XXXX ADDR XXXXX DATA'    SOMEDAY
         HEX   (38,R2),OLDPOINT,LEN=2   CONVERT OFFSET TO THE LINE LDW1
         LA    R1,48(R2)                POINT TO SPOT
         BAS   R8,SETSTRNG              CONVERT STRING TO LINE AS WAS
         MVC   104(5,R2),=C'CCHHR'      MOVE IN IDENTIFIER         LDW1
         HEX   (110,R2),CCHHR,LEN=5     GET THE CCHHR              LDW1
         BAS   R8,CPUT                                             LDW1
*LDW1    MVC   81(16,R2),=C'TO BE CHANGED TO'
*LDW1    LA    R1,81+16+1(R2)           NEXT STRING LOCATION
         LA    R1,N1                                               LDW1
         BAS   R8,SETLINE                                          LDW1
         EX    0,*                                                 LDW1
         MVC   20(10,R2),19(R2)         BLANK THE TTR THIS TIME    LDW1
         MVC   31(16,R2),=C'TO BE CHANGED TO'                      LDW1
         LA    R1,48(,R2)                                          LDW1
         L     R2,0(R13)                RESTORE EX INS PTR
         EX    R4,0(R2)                 CHANGE DATA IN BUFFER
         BAS   R8,SETSTRNG              RECORD THE CHANGE
         BAS   R8,CPUT                  PUT THE LINE
         MVI   CHNGED,255               MARK AS CHANGED FOR LATER
         OI    FLAGS2,MUSTZAP           BLK NEEDS A ZAP NOW
         MVC   OLDTTR(3),TTR            COPY FOR PRINTING
         B     NEWDSPNT                 THEN RETURN TO HIM         LDW1
NOMSGEX  L     R2,0(R13)                RESTORE EX INSTRUCTION PTR
         EX    R4,0(R2)                 MAKE THE APPROPRIATE CHANGE
         OI    FLAGS2,MUSTZAP           BLK NEEDS A ZAP NOW        LDW1
         B     NEWDSPNT                 GIVE IT TO HIM
         SPACE 2
*        ZAP --- COMMAND EXECUTION --- SET.
*        *****  SET  *****
         SPACE 1
SET      LTR   R3,R0                    TEST OPERAND LENGTH        LDW1
         BP    SETNEW#                  THERE IS ONE               LDW1
         SPACE 1
*        USE OLD STRING FOR SET NO OPERANDS.
         SPACE 1
         TM    CONTINUE,YESCONTT        IS THERE AN OLD ONE TO USE?
         BO    SETNEW                   YES, USE IT                LDW1
         B     INVEXPER                 INVALID SYNTAX COL 4       LDW1
         SPACE 1
*        USE SPECIFIED STRING.
         SPACE 1
SETNEW#  LR    R4,R1                    -> TO THE STRING OPERAND   LDW1
         LA    R5,SETSTR                WHERE TO SAVE THE INFO
         BAS   R6,GETSTRNG              GET AL2(LEN),C'STRING'
         SPACE 2                                                   LDW1
*        NOW SETSTR CONTAINS :
*        AL2(SET_LEN),C'SET_STRING'
         SPACE 1
SETNEW   OC    BLKLEN(2),BLKLEN         IS THERE ANYTHING TO SET?
         BZ    INVALCOM                 NO, SO DON'T AND TELL HIM
         TM    GODFLAG,GOD              CAN HE EVER UPDATE?
         BO    LETSET                   YES, WE HAVE NOTHING TO SAY
         BAS   R8,SETMSG                MOVE MSG TO RIGHT PLACE    LDW1
         DC    Y(STORMSG-ZAP)           TELL HIM NOT UPDATING      LDW1
LETSET   LA    R14,SETSTR               GET THE STRING ADDRESS     -EU-
         BAS   R8,STRCNV                GO APPLY CONVERSION        -EU-
         LH    R4,SETSTR                GET BCTR'D STRING LEN  -EU-LDW1
         LA    R5,WKSTR                 POINT TO STRING        -EU-LDW1
         LA    R1,N2                    MSG NUMBER
         BAS   R8,SETLINE               SET UP LINE
         B     NOSETMSG                 OOPS, NOT PRINTING
         CLI   CHNGED,0                 VIRGIN BUFFER?
         BNE   *+L'*+4                  NO, SINGLE SPACE
         MVI   0(R2),C'0'               ELSE, DOUBLE SPACE FIRST CHANGE
*LDW1    MVC   31(18,R2),=C'BLOCK TO BE SET TO'  MOVE TEXT
*LDW1    LA    R1,31+18+1(R2)           POINT WHERE IT GOES
         MVC   31(28,R2),=C'FOLLOWING BLOCK TO BE SET TO'          LDW1
         LA    R1,31+28+1(,R2)          POINT WHERE IT GOES        LDW1
         BAS   R8,SETSTRNG              CONVERT THE STRING
         BAS   R8,CPUT                  DUMP THE LINE NOW
         MVI   CHNGED,255               ITS CHANGED NOW
         MVC   OLDTTR(3),TTR            SAVE TTR
         IC    R7,ENQIT                 PRESERVE FLAG              LDW1
         BAS   R6,PREPDMPX              GET READY FOR THE DUMP     LDW1
         BAS   R6,DUMPER                DUMP THE BLOCK             LDW1
         STC   R7,ENQIT                 RESTORE FLAG               LDW1
         LH    R4,SETSTR                RESTORE LENGTH             LDW1
NOSETMSG OI    CONTINUE,YESCONTT        SAY HE CAN SET NO OPRND NOW
         OI    FLAGS2,MUSTZAP           BLK NEEDS A ZAP NOW        LDW1
         L     R5,ADDRBUFF              PT TO BUFFER
         XR    R8,R8                    CLEAR REM REG FOR DIVIDE
         LH    R7,BLKLEN                GET LEN OF BLK IN BUFFER
         LA    R1,1(R4)                 GET REAL STRING LENGTH
         DR    R8,R1                    HOW MANY STRINGS FIT IN BLK
         LTR   R7,R7                    BLK SHORTER THAN STRING?
         BZ    JUSTSPEW                 YES, JUST MOVE IN REMAINDER
         SPACE 1
*        R7 HAS BCT COUNT OF HOW MANY STRINGS CAN FIT
*        IN THIS PARTICULAR BLK, WHILE R8 HAS THE LENGTH
*        OF THE PIECE LEFT OVER.
         SPACE 1
SETLOOP  EX    R4,SETMVC                MOVE 1 STRING IN
         LA    R5,1(R4,R5)              UPDATE BUFFER PTR FOR NEXT
         BCT   R7,SETLOOP               FILL AS MUCH OF BUFFER AS CAN
JUSTSPEW LTR   R8,R8                    IS THERE A SMALL PIECE LEFT?
         BZ    NEWDSPNT                 NO, WE ARE ALL DONE
         BCTR  R8,0                     YES, GET EXECUTE LEN
         EX    R8,SETMVC                MOVE AS MUCH AS WILL FIT IN
         B     NEWDSPNT                 AND GO DISPLAY WHAT WE DID
SETMVC   MVC   0(0,R5),WKSTR            << EXECUTED >>         -EU-LDW1
         SPACE 2
*        ZAP --- COMMAND EXECUTION --- ZAP/SAVE.
*        *****  ZAP/SAVE  *****
         SPACE 1
REPLACE  CLI   IOERROR,YESSYN           WAS THERE AN I/O ERROR ON BLK?
         BE    WRTNONO                  YES, CAN'T ZAP THAT
         OC    BLKLEN(2),BLKLEN         NO, BUT IS THERE A BLK TO ZAP?
         BZ    WRTNONO                  NO, SO DON'T ZAP ALREADY
         TM    DCBLIST,X'0F'            UPDATING ALREADY?
         BNZ   THERE                    YES, CONTINUE
         TM    GODFLAG,GOD              CAN HE CHANGE FROM INPUT TO UP
         BZ    WRTNONO                  NO, TOUGH BEANS FOR HIM
         MVC   REP,BLANKS               CLEAR REPLY                LDW1
         MVC   REP(3),=C'ZAP'           RE-PROMPT THE RIGHT THING  LDW1
         CLOSE MF=(E,DCBLIST)           CLOSE THE DATASET SO THAT....
         MVI   DCBLIST,X'84'            WE CAN OPEN FOR UPDATE
         OPEN  MF=(E,DCBLIST),TYPE=J    THEN DO IT ALREADY         LDW1
         TM    DCBU+48,X'10'            OPEN?
         BO    THERE#                   YES, OK
         BCR   0,1                      DRAIN PIPELINE
         EX    0,*                      THIS BETTER NEVER HAPPEN
THERE#   TM    FLAGS2,LOGF              SEE IF LOGGING
         BNO   THERE                    IF NOT, THEN NO MSG
         L     R1,CSOUTWK               POINT TO WORK AREA
         LTR   R1,R1                    SEE IF THERE
         BZ    THERE                    IF NOT, NO MSG
         LA    R8,THERE                 GET RETURN ADDR
         ST    R8,DBLW                  STORE FOR SUBROUTINE
         B     OPENMSG                  GO WRITE THE MESSAGE
THERE    BAS   R8,WRITE                 WRITE THE BUFFER OUT
         CLI   IOERROR,YESSYN           I/O ERROR?
         BE    NEWDSPNT                 YES, IGNORE TELLING HIM OK
         MVI   CHNGED,0                 BUFFER HAS BEEN CHECKPOINTED
         NI    FLAGS2,255-MUSTZAP       BLK NO LONGER NEEDS ZAP
         SPACE 1
*        UPDATE THE IDR IF APPLICABLE.
*        IDR FOR SUPERZAP (AND THEREFORE ZAP)
*        TAKES THE FOLLOWING FORM :
*        BYTE  0.....'80' FOR ID
*        BYTE  1.....LENGTH OF IDR (USUALLY X'FA' = 250.)
*        BYTE  2.....WHO'S IDR IT IS (X'01' FOR SUPERZAP AND ZAP)
*        BYTE  3.....NUMBER OF 13-BYTE IDR DATA ENTRIES (BITS 2-7)
*        BYTES 4-16, 17-29,... IDR DATA ENTRY AS FOLLOWS :
*              BYTES 0-1 --- ESD ID (DEFAULT 1)
*              BYTES 2-4 --- DATE ('YYDDDF')
*              BYTES 5-12 -- INFO ('TSO--UUU, WHERE UUU=ZAPPER'S UID)
         SPACE 1
         CLI   DSORG,DSORGPO            IS THIS A PDS?
         BNE   FINZAP                   NO, FORGET THE IDR
         CLI   DCBRECFM-IHADCB+DCBU,RECFMU  IS THIS A LIBRARY?
         BNE   FINZAP                   NO, DON'T UPDATE THE 'IDR'
         CLI   IDRFLAG,CHGIDR           ALREADY UPDATED THIS IDR
         BE    FINZAP                   YES, DON'T DO IT AGAIN NOW
         MVC   0(3,R13),TTR             LET'S SAVE WHERE HE WAS FIRST
         OC    MEMTTR(3),MEMTTR         WAS THERE A 'M' COMMAND?
         BZ    ENDIDR                   NO, FORGET IT
         MVC   TTR(3),MEMTTR            PICK UP MEMBER PTR
         BAS   R8,READBLK               READ 1ST BLK OF MEMBER
IDRFIND  L     R1,ADDRBUFF              GET BUFFER PTR
         TM    0(R1),X'01'              CONTROL RECORD OF SOME SORT?
         BO    ENDIDR                   YES, WE ARE ALL DONE LOOKING
         CLI   0(R1),X'80'              IDR?
         BNE   NEWBLK                   NO, GET ANOTHER BLK
         TM    2(R1),X'01'              YES, BUT DONE BY SUPERZAP?
         BNO   NEWBLK                   NO, FORGET THIS ONE
         XR    R2,R2                    CLEAR WORK REG
         IC    R2,3(R1)                 PICK UP # OF IDR DATA ENTRIES
         LR    R4,R2                    SAVE IT FOR LATER
         N     R2,=XL4'0000003F'        WE JUST WANT BITS 2-7
         MH    R2,=H'13'                EACH ENTRY IS 13 BYTES LONG
         LA    R2,3(R2)                 IDR HDR IS 3 BYTES LONG
*        SO NOW R2 HAS AN OFFSET TO THE NEXT
*        AVAILABLE POSITION IN THE IDR.
         XR    R3,R3                    CLEAR WORK REG
         IC    R3,1(R1)                 PICK UP IDR LENGTH
         CR    R3,R2                    ARE WE AT END OF IDR?
         BH    UPDATIDR                 NO, SO UPDATE THE IDR
NEWBLK   MVI   EOFRET,NOEOF             TREAT EOF'S AS DATA BLKS
         BAS   R8,READNBLK              READ ON ANOTHER BLK        LDW1
         CLC   LINE05+27(20),EOFMSG     DID I HIT END OF FILE?     LDW1
         BE    ENDIDR                   YES, STOP THIS STUPID THING
         CLI   IOERROR,YESSYN           I/O ERROR?
         BE    ENDIDR                   YES, LEAVE
         B     IDRFIND                  NO, CHECK THIS BLK
UPDATIDR AR    R2,R1                    R2 PTS TO NEXT IDR SPOT
         LA    R4,1(R4)                 INCREMENT # OF IDR ENTRIES...
         STC   R4,3(R1)                 AND PUT IT BACK
         MVC   1(2,R2),ESDID            MOVE IN ESDID (IF ANY)
         TIME  ,                        GET THE DATE IN R1
         ST    R1,DBLW                  SAVE IT IN TEMP WORD
         MVC   3(3,R2),DBLW+1           MOVE YYDDDF TO IDR
         MVI   6(R2),C'/'               INDICATE TSO USERID        LDW4
         MVC   7(7,R2),USERID           MOVE IN THE CULPRIT        LDW4
         BAS   R8,WRITE                 GO WRITE THE RECORD BACK   LDW4
         CLI   IOERROR,YESSYN           I/O ERROR?
         BE    ENDIDR                   YES, SAY WE DIDN'T UPDATE
         MVI   IDRFLAG,CHGIDR           NO, SO WE DID UPDATE THE IDR
ENDIDR   LA    R1,N6                    ASSUME NOT UPDATED
         CLI   IDRFLAG,CHGIDR           WAS THE IDR UPDATED?
         BNE   *+L'*+4                  NO, WE WERE RIGHT
         LA    R1,N7                    DID UPDATE
         BAS   R8,SETLINE               SET UP OUTPUT LINE
         B     PUTBACK                  NO PRINT FILE, LEAVE
         MVI   0(R2),C'0'               DOUBLE SPACE
         MVC   20(25,R2),=C'IDR FOR CSECT NOT UPDATED'
         CLI   IDRFLAG,CHGIDR           WAS IT UPDATED?
         BNE   PUTITOUT                 NO, MSG IS OK
         MVC   34(3,R2),EDMASK+9        YES, SO GIVE ESDID          *N*
         LH    R0,ESDID                 GET ESDID (USUALLY)         *N*
         CVD   R0,DBLW                  IN DEC                      *N*
         ED    33(4,R2),DBLW+6          ESDID TO MSG                *N*
PUTITOUT BAS   R8,CPUT                  PUT MSG OUT
PUTBACK  CLC   TTR(3),0(R13)            HAS HE MOVED ANY?
         BE    FINZAP                   YES, DON'T BOTHER PUTTING BACK
         MVI   TTR+3,NOSEQRD            GET THE RIGHT ONE, NOT THE NEXT
         MVC   TTR(3),0(R13)            LET'S PUT HIM BACK WHERE HE WAS
         BAS   R8,READBLK               HE'LL NEVER KNOW WHAT HAPPENED
FINZAP   MVC   LINE19+17(40),=CL40'      *****  BLOCK REPLACED  *****'
         MVI   ENQIT,255                FORCE ENQ NOW THAT ITS ZAPPED
         LA    R1,N3                    MSG NUMBER
         BAS   R8,SETLINE               SETUP THE LINE
         B     NEWDSPNT                 NOT PRINTING
         MVC   31(14,R2),=C'BLOCK REPLACED'
         MVI   0(R2),C'0'               DOUBLE SPACE THIS ONE
         BAS   R8,CPUT                  DUMP THE LINE
*        TRUNCATE CURRENT LOG BLOCK, IN CASE OF SYSTEM/PROGRAM FAILURE.
         L     R2,CSOUTWK               IT'S GOTTA BE HERE         LDW1
         MVI   0(R2),X'01'              INDICATE TRUNC             LDW1
         BAS   R8,CPUTRUNC              TRUNCATE THIS LOG BLOCK    LDW1
         B     NEWDSPNT                 YES, DISPLAY WITH NO TRACE
WRTNONO  LA    R2,WRITERR               TELL HIM WRITE NOT ALLOWED
         MVC   REP,BLANKS               CLEAR OUT REPLY BUFF AND   LDW1
*                                       SO DON'T TEMPT HIM TO RE-'ZAP'
         B     BOTCH                    AND DISPLAY
         SPACE 2
*        ZAP --- COMMAND EXECUTION --- DISASM, ASM.                LDW1
*        *****  DISASM
         SPACE 1
DISASM   LH    R15,OLDPOINT             CURR OFFSET
         MVI   EXPOPT,YESSYMB           WANT SYM TAB LOOKUP
         BAS   R8,CALLEXP               PARSE & CHECK              LDW1
         BM    INVEXPER                 NEG IS BAD                 LDW1
         LH    R0,BLKLEN                GET LENGTH BLK
         SH    R0,=H'2'                 LAST POSS INSTRUCTION
         CR    R15,R0                   PAST END OF BLK?
         BH    INVEXPER
         A     R15,ADDRBUFF             GET ADDR IN BUFFER
         LNR   R1,R15                   NEG FOR 'DISASM'
         LA    R0,LINE19+24             GIVE HIM 33 BYTES TO WORK WITH
         LA    R2,TEMP2                 GIVE HIM SOME WORKAREA TOO
         L     R15,=V(ASMGASM)          POINT TO 'ASSEMBLER' HAR HAR
         BASR  R14,R15                  DISASSEMBLE IT
         LA    R2,INVOPCOD              ASSUME BOTCHUP
         BXH   R15,R15,BOTCH            YUP
         MVC   LINE19+17(7),=C'INSTR:'  NO, MOVE MASK
         B     NEWDSPNT                 AND SHOW IT OFF
         SPACE 1                                                   LDW1
*        *****  ASM
         SPACE 1
ASM      BNP   INVEXPER                 NO OPERAND - BAD           LDW1
         L     R15,=V(ASMGASM)          PT TO SUB
         BASR  R14,R15                  GET OBJECT
         LA    R2,INVOPCOD              ASSUME NO
         BXH   R15,R15,BOTCH
         MVC   LINE19+17(8),=C'OP CODE:'  MASK
         HEX   LINE19+27,(0,R1),LEN=1                              LDW1
         B     NEWDSPNT                 SHOW IT
         SPACE 2
*        ZAP --- COMMAND EXECUTION --- V, BASE.                    LDW1
*        *****  V  *****
         SPACE 1
INDIRECT LH    R15,OLDPOINT             * = CURRENT OFFSET         LDW1
         MVI   EXPOPT,YESSYMB           WANT SYM TAB LOOKUP        LDW1
         BAS   R8,CALLEXP               PARSE & CHECK              LDW1
         BM    INVEXPER                 NEG IS INVALID             LDW1
         LH    R0,BLKLEN                GET BLOCK LENGTH           LDW1
         SH    R0,=H'2'                 LAST POSSIBLE RDW          LDW1
         CR    R15,R0                   PAST END?                  LDW1
         BH    INVEXPER                 YES, BYE                   LDW1
         A     R15,ADDRBUFF             GET ADDR IN BUFFER         LDW1
         MVC   0(2,R13),0(R15)          REC LEN TO ALIGNED PLACE   LDW1
         LH    R15,0(,R13)              GET RECORD LENGTH          LDW1
         AH    R15,OLDPOINT             BUMP OFFSET                LDW1
         B     SETPOINT                 GO SET IT                  LDW1
*        DO WE WANT TO GO TO THE NEXT BLK IF NECESSARY?            LDW1
         SPACE 1
*        *****  BASE  *****                                        LDW1
         SPACE 1
BASE     L     R15,OFFSET               * = CURRENT OFFSET         LDW1
         MVI   EXPOPT,YESSYMB           WANT SYM TAB LOOKUP        LDW1
         BAS   R8,CALLEXP               PARSE & CHECK              LDW1
         ST    R15,BASEVAL              SET NEW BASE VALUE         LDW1
         AH    R15,OLDPOINT             ADD OLD BUFFER OFFSET      LDW1
         ST    R15,OFFSET               SET NEW OFFSET             LDW1
         B     NEWDSPNT                 GO SHOW IT OFF             LDW1
         SPACE 2
*        ZAP --- COMMAND EXECUTION --- DO.
*        *****  DO
         SPACE 1
DO       LTR   R3,R0                    TEST OPERAND LENGTH        LDW3
         BNP   INVEXPER                 ERROR
DOL      CLI   0(R1),C' '               SCAN OFF LEADING BLNKS
         BNE   DO1                      FOUND A NON BLNK
         LA    R1,1(R1)                 LOOK AT NXT CHAR
         BCT   R3,DOL                   - THE COUNT
         B     INVEXPER
DO1      LR    R2,R1                    PUT IN RIGHT REG
         BAS   R8,KILL3270              TURN OFF 3270 MODE IF ON   LDW3
         TPUTX 'THE "DO" COMMAND IS NOT IMPLEMENTED'            .AFDSC.
*        B     DO2                                          -EU-.AFDSC.
*        SPACE 1                                                   -EU-
*        XC    TMPLIST(TMPLISTL),TMPLIST CLEAR THE LIST            -EU-
*        TPUTX 'DOING'                                             -EU-
*        OACTMP CMD=((R2),(R3)),MF=(E,TMPLIST)  DO THE 'DO'        -EU-
*        BXH   R15,R15,DO2                                         -EU-
*        TPUTX 'DONE'                                              -EU-
*        SPACE 1                                                   -EU-
DO2      BAS   R8,TGET                  BRANCH ENTRY               LDW1
         B     COMSCAN                  PARSE COMMAND
         SPACE 2
*        ZAP --- COMMAND EXECUTION --- WHERE.
*        *****  WHERE
         SPACE 1
WHERE    MVI   TRACE,NOTRACE            DONT TRACE
         BAS   R8,CLEAR                 CLEAR SCREEN
         B     WHEREAMI                 FORMAT LINE                LDW1
         SPACE 1
*        *****  NOT3270  *****                                     LDW1
         SPACE 1
NOT3270  BAS   R8,KILL3270              TURN OFF 3270 MODE IF ON   LDW1
         NI    FLAGS3,255-F3270         TURN OFF FLAG              LDW5
         B     NEWDSPNT                 DISPLAY AGAIN, NOTRACE     LDW1
         SPACE 1
*        *****  YES3270  *****                                     LDW2
         SPACE 1
YES3270  OI    FLAGS3,F3270+RESHOWF     TELL THE WORLD             LDW5
         B     NEWDSPNT                 DISPLAY AGAIN, NOTRACE     LDW1
         SPACE 1
*        *****  LINE80  *****                                      LDW1
         SPACE 1
LINE80   MVC   DISPCONS(DISPCONL),DSPCON80  CONSTANTS FOR LEN=80   LDW1
         B     NEWDSPNT                 GO DISPLAY, NOTRACE        LDW1
         SPACE 1
*        *****  LINE40  *****                                      LDW1
         SPACE 1
LINE40   MVC   DISPCONS(DISPCONL),DSPCON40  CONSTANTS FOR LEN=40   LDW1
         B     NEWDSPNT                 GO DISPLAY, NOTRACE        LDW1
         SPACE 2
*        ZAP --- COMMAND EXECUTION --- W (WINDOW).
*        *****  W   (WINDOW)
         SPACE 1
WINDOW   BP    OKWIND                   GO PROCESS OPERANDS
         XC    WIDTHS(4+4),WIDTHS       ONLY 'W', SET DEFAULTS
         NI    FLAGS3,255-CRTF          TURN OFF CRT MODE          LDW1
         OI    FLAGS2,NOWHEREF          SUPRESS WHERE LINES
         B     NEWDSPNT                 AND QUIT
OKWIND   CLC   =C'FULL',REP+1           FULL WINDOW SPECIFIED?     LDW1
         BNE   OKWIND#                  NO, GO ON
         L     R6,MAXWIDTH              YES, SAY FULL              SDM6
         LR    R7,R6                    SAY FULL HERE TOO          SDM6
         B     WINDSAVE                 WE ARE DONE
OKWIND#  LM    R6,R7,WIDTHS             ASSUME WIND=CURR WIND      SDM6
         LR    R4,R0                    SAVE LEN OP(S)             SDM6
         LR    R5,R1                    SAVE PTR TO OPERANDS       SDM6
         SPACE 1
*        W<DOWN>,<UP>.
         SPACE 1
WINDLOOP CLI   0(R5),C','               END 1ST OP?                SDM6
         LA    R5,1(,R5)                ASSUME YES                 SDM6
         BE    *+L'*+4                  RIGHT, DO 1ST
         BCT   R4,WINDLOOP              TRY TRY                    SDM6
         SR    R0,R4                    LEN 1ST                    SDM6
         BZ    WIND2                    NO 1ST, DO 2ND
         BAS   R3,WINDEXP               PARSE, R1 SET, *=0         SDM6
         LR    R6,R15                   ALL OK, SAVE FOR <DOWN>    SDM6
WIND2    LR    R0,R4                    LEN LEFT = LEN 2ND (ALMOST)SDM6
         SH    R0,=H'1'                 -1 FOR COMMA (IF ANY)
         BNP   WINDSAVE                 NO 2ND OP, LEAVE ALONE
         LR    R1,R5                    SET OP PTR FOR EXP         SDM6
         BAS   R3,WINDEXP               GO PARSE 2                 SDM6
         LR    R7,R15                   ALL OK, SAVE <UP>          SDM6
WINDSAVE STM   R6,R7,WIDTHS             SAVE THE 2 WIDTHS          SDM6
         B     NEWDSPNT
WINDEXP  XR    R15,R15                  * = 0                      LDW1
         BAS   R8,CALLEXP               PARSE & CHECK              LDW1
         BM    INVEXPER                 NEG IS BAD                 LDW1
         CL    R15,MAXWIDTH             TOO BIG?                   LDW1
         BNHR  R3                       NO, RETURN                 SDM6
         B     INVEXPER                 YES, COMPLAIN              LDW1
         SPACE 2
*        ZAP --- COMMAND EXECUTION --- FLOAT.
*        *****  FLOAT
         SPACE 1
*        (ORIGINAL INTX SVCX 6 CODE WRITTEN BY STEVE SILVER.
*              MODIFIED FOR ZAP USE BY JCJ AND VIC
*              - IE : WE DON'T UNDERSTAND)
         SPACE 1
FLOAT    LTR   R2,R0                    TEST OPERAND LENGTH        LDW1
         BP    FLOAT$                   GO USE IT                  LDW1
         LH    R15,OLDPOINT             GET CURRENT OFFSET         LDW1
         LR    R14,R15                  COPY                       LDW1
         AH    R14,=H'8'                POINT PAST END OF OPERAND  LDW1
         CH    R14,BLKLEN               IN BLOCK?                  LDW1
         BNL   INVEXPER                 NO, ERROR                  LDW1
         A     R15,ADDRBUFF             -> OPERAND                 LDW1
         MVC   TEMP(8),0(R15)           GET IN ALIGNED PLACE       LDW1
         B     FLOAT#                   CONTINUE WITH IT           LDW1
FLOAT$   BCTR  R2,0                     GET EXECUTE LENGTH         LDW1
         CH    R2,=H'15'                WAS THE OPERAND TOO LONG?
         BH    LENERROR                 YES, TELL HIM AND QUIT
         LR    R7,R1                    POINT TO THE STRING        LDW1
         LA    R1,1(,R2)                PICK UP LENGTH OF STRING
         BAS   R8,HEXCHECK              IS IT VALID HEX?
         B     OKFLOAT                  YES, SO LET'S DO IT
         LR    R1,R7                    NO, POINT TO THE ERROR
         B     INVEXPER                 AND SAY SYNTAX ERROR
OKFLOAT  EX    R2,TRFLOAT               START TRANSLATE TO REAL HEX
         PACK  TEMP(8),TEMP2+5(15)      MAKE IT HONEST-TO-GOODNESS HEX
         MVN   TEMP+7(1),TEMP2+20       GET THE LAST NIBBLE TOO
FLOAT#   LD    F0,TEMP                  LOAD IT IN FLOAT REG 0     LDW1
         LA    R7,LINE19+36             PT TO START OF SCRN RESULT AREA
         SPACE 1
*        SET THE PROGRAM MASK TO MASK OUT FIX PT OFLO,
*        DEC OFLO, EXPON UNFLO, AND SIGNIFICANCE.
*        SAVE IT IN R6 TO RESET IT LATER.
         SPACE 1
         XR    R2,R2                    0 R2 FOR SPM
         BASR  R6,0                     SAVE PGM MASK FOR RESTORE
         SPM   R2                       0 THE PGM MASK (NO INTERR)
         MVI   16(R7),C'0'              ASSUME ANSWER IS 0
         AD    F0,=D'0'                 NORMALIZE BY ADDING 0
         LTDR  F0,F0                    CHECK THE SIGN
         BZ    CVFCI3                   ZERO (WE'RE ALMOST DONE)
         BP    CVFC00                   PLUS, GO ON
         LPDR  F0,F0                    MINUS, MAKE IT PLUS ...
         MVI   0(R7),C'-'               INSERT SIGN AND GO ON LIKE PLUS
CVFC00   LA    R7,1(R7)                 UPDATE OUTPUT PTR EITHER CASE
         CD    F0,=X'7FFFFFFFFFFFFF00'  DATA WILL CAUSE EXP OVERFLOW?
         BNH   *+L'*+4                  NO - SKIP PREVENT LOAD
         LD    F0,=X'7FFFFFFFFFFFFF00'  ELSE GET MAX ALLOWABLE
*        MAX ALLOWABLE IS X'7FFFFFFFFFFFFF00'
         MD    F0,=X'4110000000000010'  MULT BY FUDGE FACTOR
         SPACE 2
*        GENERATE THE NUMBER IN D-FORMAT.
         SPACE 1
         XR    R2,R2                    INITIALIZE EXPON REG
         LD    F4,=D'10'                SET F4 TO 10
         LD    F6,=D'1'                 SET F6 TO 1
         LD    F2,=X'401999999999999A'  SET F2 TO .1
         MVI   0(R7),C'.'               SET UP OUTPUT
         LA    R7,1(R7)                 INCREMENT LINE POINTER
         MVI   14(R7),C'D'              FORM THE OUTLINE OF EXPONENT
         MVI   15(R7),C'+'              MOVE IN EXPONENT SIGN
*        GET THE EXPONENT IN R2 (>=1).
CVFC1A   CDR   F0,F6                    SEE IF # < 1
         BL    CVFC2                    IF SO, GO TO NEXT PART
         DDR   F0,F4                    NO, DIVIDE BY 10
         LA    R2,1(R2)                 INCREMENT EXPONENT
         B     CVFC1A                   CONTINUE
*        GET THE EXPONENT (<.1).
CVFC2    CDR   F0,F2                    SEE IF >= .1
         BNL   CVFC3                    IF SO, GO TO NEXT PART
         BCTR  R2,0                     DECREMENT EXPONENT
         MDR   F0,F4                    MULT NUMBER BY 10
         B     CVFC2                    CONTINUE
*        GET EXPONENT SIGN.
CVFC3    LTR   R2,R2                    SEE IF EXPONENT +
         BNM   CVFC3A                   IF SO, SKIP CODE
         LPR   R2,R2                    MAKE IT PLUS BUT ...
         MVI   15(R7),C'-'              WRITE OUT A MINUS
CVFC3A   LA    R0,10                    DIVISER FOR BELOW
         SRDL  R2,32                    SET UP FOR DIVIDE
         DR    R2,R0                    DO THE DIVIDE
         LA    R2,C'0'(R2)              GET THE EBCDIC VALUE
         LA    R3,C'0'(R3)              GET THE EBCDIC VALUE
         STC   R2,17(R7)                AND STORE IT
         STC   R3,16(R7)                AND STORE IT
         LA    R0,14                    GET NUMBER OF DIGITS FOR BCT
         LD    F6,=X'4100000000000000'  LOAD F6 WITH UN-NORMALIZER
*        GET THE MANTISSA.
CVFC4    MDR   F0,F4                    MULT NUMBER BY 10
         AWR   F0,F6                    UN-NORMALIZE
         STD   F0,TEMP                  STORE RESULT
         XR    R4,R4                    ZERO FOR IC
         IC    R4,TEMP+1                GET FIRST HEX DIGIT
         SRA   R4,4                     KILL LOW NIBBLE (LAST HEX DIG)
         LA    R3,C'0'(R4)              CONVERT TO CHAR
         STC   R3,0(R7)                 MOVE RESULT TO OUTPUT
         XC    TEMP(8),TEMP             SET UP DBLW
         LA    R7,1(R7)                 POINT TO NEXT OUTPUT COL
         LTR   R4,R4                    IS R4 0?
         BZ    CVFC4#                   YES, WE HAVE NOTHING TO DO
         MVI   TEMP,X'41'               MAKE DBLW INTERNAL FLOATING PT
         SLL   R4,4                     MOVE NUMBER TO HIGH ORDR NIBBLE
         STC   R4,TEMP+1                AND MOVE IT TO DBLW
         SPACE 1
*        WE HAVE NOW BUILT A DBLW WHICH MAY CONTAIN D'0' THROUGH D'10'.
         SPACE 1
         SD    F0,TEMP                  SUBTRACT THE INTEGER PART
CVFC4#   BCT   R0,CVFC4                 DO TILL END
         B     CVFCI3                   CLEAN UP AND GO AWAY
         SPACE 1
*        IF NUMBER IS ZERO TO BEGIN WITH, THERE'S NOTHING TO DO BUT ...
         SPACE 1
         MVI   16(R7),C'0'              SET UP ZERO RESULT
         SPACE 1
*        RESTORE PROGRAM MASK TO WHAT IT WAS.
         SPACE 1
CVFCI3   SPM   R6                       RESET PROGRAM MASK
         MVC   LINE19+17(15),=CL15'FLOATING POINT:'
         B     NEWDSPNT                 RETURN TO CALLER
TRFLOAT  TR    TEMP2+5(0),TRHEX         << EXECUTED >>             LDW1
         SPACE 2
*        ZAP --- COMMAND EXECUTION --- DUMP, DUMPE, DUMPF.         LDW1
*        *****  DUMP, DUMPE  *****                                 LDW1
         SPACE 1
DUMP     BAS   R8,LOGTEST                                          LDW1
         BAS   R8,CHKPT                 SEE IF HE CAN LEAVE        LDW1
         CLI   CPUTFLAG,YESCSERR        CAN CSOUT ENQ NOW?
         BE    BADCSOUT                 NO, WHY BOTHER TO DUMP THEN?
         L     R7,=XL4'7FFFFFFF'        NUMBER OF BLOCKS TO READ (HAH)
         MVC   0(3,R13),TTR             SAVE WHERE WE ARE
         CLI   REP+4,C'E'               IS THIS REALLY DUMPE?      LDW1
         BE    PREPDMPF                 YES, DUMP FROM HERE        LDW1
         MVC   TTR(4),=XL4'00000100'    POINT TO BEGINNING OF DATA-SET
         B     PREPDMPF                 START DUMPING TILL END OF DS
         SPACE 1                                                   LDW1
*        *****  DUMPF  *****
         SPACE 1
DUMPF    BAS   R8,LOGTEST                                          LDW1
         BAS   R8,CHKPT                 SEE IF HE CAN LEAVE        LDW1
         CLI   CPUTFLAG,YESCSERR        CAN CSOUT ENQ IT TO PRINT?
         BE    BADCSOUT                 NO, SO WHY DUMP MAY I ASK?
         LH    R0,REALRDLN              GET LEN OF COMMAND
         SH    R0,=H'5'                 -5 FOR 'DUMPF' ACTUAL LEN
         BNZ   DUMPFOR                  HE GAVE AN OPERAND, PROCESS IT
JUSTDUMP LA    R7,1                     DUMP R* ONLY - R7 = # TO DUMP
         B     STARTDF                  ALL SET, START THE DUMP-FOR
         SPACE 1
*        PROCESS OPERAND OF DUMPF COMMAND (NUMBER OF BLOCKS TO DUMP).
         SPACE 1
DUMPFOR  XR    R15,R15                  LOAD *, CURRENT LOC FOR 'EXP'
         LA    R1,REP+5                 POINT TO OP. TO PARSE      LDW1
         BAS   R8,CALLEXP               GO PARSE                   LDW1
         BM    NOBACK                   NEG, WE CAN'T DUMP BACKWARDS
         BZ    INVEXPER                 ZERO, INVALID SYNTAX
         LR    R7,R15                   NUMBER OF BLOCKS TO DUMP
STARTDF  MVC   0(3,R13),TTR             SAVE WHERE WE ARE
PREPDMPF MVI   TTR+3,NOSEQRD            1ST BLK, READ IT BEFORE DUMP
DMPFLOOP BAS   R6,PREPDUMP              GET READY FOR THE DUMP
         BAS   R6,DUMPER                DUMP A BLOCK
         MVI   TTR+3,SEQREAD            SAY NEXT PASS, NOW READ BLK
         BCT   R7,DMPFLOOP              DO ALL THE BLOCKS HE WANTS
DUMPEND  MVC   TTR(3),0(R13)            PICK UP WHERE WE WERE
         MVI   TTR+3,NOSEQRD            DON'T PUT HIM IN NEXT BLOCK
         BAS   R8,READBLK               SO THAT HE'LL NEVER KNOW
         LA    R2,DUMPWORK              IT WORKED SO TELL HIM
         B     BOTCH                    DISPLAY (NOT REALLY A BOTCH)
         SPACE 2
*        ZAP --- COMMAND EXECUTION --- DUMPT.
*        *****  DUMPT  *****
         SPACE 1
DUMPT    BAS   R8,LOGTEST                                          LDW1
         BAS   R8,CHKPT                 SEE IF HE CAN LEAVE        LDW1
         CLI   CPUTFLAG,YESCSERR        CAN CSOUT ENQ TO PRINT?
         BE    BADCSOUT                 NO, DON'T BOTHER WITH DUMP
         LH    R0,REALRDLN              GET LEN OF READ
         SH    R0,=H'5'                 -5 FOR 'DUMPT' ACTUAL LEN
         BZ    JUSTDUMP                 NO OPERAND, JUST DUMP THIS BLK
         SPACE 1
*        PARSE OUT THE TTR OPERAND OF THE DUMPT COMMAND.
         SPACE 1
         LA    R1,REP+5                 POINT TO THE OPERAND       LDW1
         BAS   R6,TTRPARSE              GO PARSE (USE POINT'S RTN) LDW1
         CLC   TEMP+1(3),TTR            RESULT (TEMP+1) < CURRENT TTR?
         BNL   OKDUMPT                  NO, HIS WISH IS MY COMMAND
NOBACK   LA    R2,BACKDUMP              YES, WE CAN'T DUMP BACKWARDS
         B     BOTCH                    WHAT DOES HE THINK WE ARE?
OKDUMPT  MVC   STOPDUMP(3),TEMP+1       TTR TO STOP AT
         MVC   0(3,R13),TTR             SAVE WHERE WE ARE
         MVI   TTR+3,NOSEQRD            1ST BLK, READ 1ST BLK FOR DUMP
DMPTLOOP BAS   R6,PREPDUMP              NO, SO PREPARE TO DUMP
         BAS   R6,DUMPER                AND DUMP WHAT WE HAVE
         MVI   TTR+3,SEQREAD            NOW WE CAN READ SEQ BLKS
         CLC   TTR(3),STOPDUMP          ARE WE THERE OR PAST YET?
         BNL   DUMPEND                  YES, WE ARE ALL DONE THEN
         B     DMPTLOOP                 GO TILL WE ARE AT HIS TTR
         SPACE 2
*        ZAP --- COMMAND EXECUTION --- WHATMEM.                    LDW1
*        *****  WHATMEM  *****
         SPACE 1
WHATMEM  BAS   R8,CHKPT                 SEE IF HE CAN LEAVE        LDW1
         CLI   DSORG,DSORGPO            IS IT PARTITIONED?         LDW1
         LA    R2,NOMCOM                GET MSG ADDR IN CASE       LDW1
         BNE   BOTCH                    NO, ERROR                  LDW1
         MVC   0(3,R13),TTR             SAVE CURRENT TTR           LDW1
         XC    STOPDUMP(3),STOPDUMP     SAVE CLOSEST TTR HERE      LDW1
         XC    TTR(3),TTR               START AT BEGINNING OF DIR  LDW1
WHATLOOP BAS   R8,READNBLK              GET NEXT DIRECTORY BLOCK   LDW1
         CLI   IOERROR,YESSYN           DID IT WORK?               LDW1
         BE    NEWDSPNT                 NO, ABORT                  LDW1
         L     R3,ADDRDATA              -> BUFFER                  LDW1
         LH    R2,0(,R3)                BLK LEN USED               LDW1
         LA    R3,2(,R3)                -> REAL BEGIN LOC          LDW1
         BCTR  R2,0                     -1                         LDW1
         BCTR  R2,0                     AND -2 FOR REAL LEN USED   LDW1
WMLOOP2  CLC   0(4,R3),=XL4'FFFFFFFF'   END OF DIRECTORY?          LDW1
         BE    WMEND                    YES                        LDW1
         CLC   8(3,R3),0(R13)           THIS MEM PAST CURRENT LOC? LDW1
         BH    WMNEXT                   YES, TRY NEXT              LDW1
         CLC   8(3,R3),STOPDUMP         NO, HIGHER THAN PREVIOUS?  LDW1
         BL    WMNEXT                   NO, PREVIOUS IS CLOSER     LDW1
         MVC   STOPDUMP(3),8(R3)        SAVE THIS TTR              LDW1
         MVC   LINE19+35(8),0(R3)       SAVE MEMBER NAME           LDW1
WMNEXT   BAS   R8,NXTDIRNT              INCR TO NEXT ENTRY         LDW1
         BP    WMLOOP2                  CHECK NEXT                 LDW1
         B     WHATLOOP                 GET ANOTHER DIR BLK        LDW1
WMEND    MVC   TTR(3),0(R13)            RESTORE WHERE HE WAS       LDW1
         OC    STOPDUMP(3),STOPDUMP     DID I FIND ANYTHING?       LDW1
         BNZ   WMENDOK                  YES, DISPLAY IT            LDW1
         MVC   LINE19,BLANKS            RESET THE LINE             LDW1
         BAS   R8,SETMSG                MOVE IN MSG                LDW1
         DC    Y(NOMEMFND-ZAP)          'NONE FOUND'               LDW1
         B     WMDONE                   SKIP OTHER                 LDW1
WMENDOK  MVC   LINE19+17(17),=C'CLOSEST MEMBER IS'                 LDW1
         MVC   LINE19+44(6),=C'AT TTR'                             LDW1
         HEX   LINE19+51,STOPDUMP,LEN=3 GIVE HIM THE START         LDW1
WMDONE   BAS   R8,READBLK               PUT HIM BACK WHERE HE WAS  LDW1
         B     NEWDSPNT                 AND GO DISPLAY             LDW1
*        SEE NOTE AT END OF MLOOP2 (NEXT PAGE).                    LDW1
         SPACE 2
*        ZAP --- COMMAND EXECUTION --- M.
*        *****  M  *****
         SPACE 1
MEMBER#  BAS   R8,CHKPT                 NEED ZAP?
         CLI   DSORG,DSORGPO            IS IT PARTITIONED?
         LA    R2,NOMCOM                -> MSG IN CASE
         BNE   BOTCH                    THE DATASET ISNT PARTITIONED
         MVC   0(3,R13),TTR             SAVE TTR IN CASE NO FIND
         LTR   R0,R0                    TEST OPERAND LENGTH        LDW1
         BNP   JUSTM                    NONE, USE LAST MEM         LDW1
         MVC   MEMBER(8),REP+1          MOVE MEMBER TO FIELD       LDW1
         XC    TTR(3),TTR               POINT TO BEGINNING OF DIRECT -1
         SPACE 1
*        FIND THE MEMBER IN THE DIRECTORY.
*        READ A DIRECTORY BLOCK.
         SPACE 1
MLOOP    BAS   R8,READNBLK              GET NEXT BLK               LDW1
         CLI   IOERROR,YESSYN           I/O ERROR?
         BE    NEWDSPNT                 YES, GET OUT
         L     R3,ADDRKEY               GET BUFFER PTR             LDW1
         CLC   MEMBER,0(R3)             IN THIS BLOCK?             LDW1
         BH    MLOOP                    NO, GET NEXT               LDW1
         LH    R2,8+0(,R3)              GET BLK LEN USED           LDW1
         BCTR  R2,0                     -1
         BCTR  R2,0                     AND -2 FOR REAL LEN USED
         LA    R3,8+2(,R3)              POINT TO REAL BEGIN LOC    LDW1
         SPACE 1
*        MEMBER SCAN LOOP WITHIN BLK.
         SPACE 1
MLOOP2   CLC   0(4,R3),=XL4'FFFFFFFF'   END OF DIRECTORY?
         BNE   NOTEND                   NO, THERE'S MORE TO LOOK
MNF      MVC   TTR(3),0(R13)            PICK UP WHERE HE WAS
         BAS   R8,SETMSG                MOVE MSG TO RIGHT PLACE    LDW1
         DC    Y(INVMEM-ZAP)            SAY INV MEMBER (NOT FOUND) LDW1
         BAS   R8,READBLK               PUT HIM BACK WHERE HE WAS
         B     NEWDSPNT                 AND GO DISPLAY
         SPACE 1
*       NOTE : READBLK WILL RETURN ONLY IF THE USER IS NOT AT AN EOF
*              IF EOF, SYNAD==>EODAD==>DISPLAY GET EXECUTED, SO THE
*              MESSAGE MUST BE PRE-SET.
         SPACE 1
NOTEND   CLC   0(8,R3),MEMBER           MEMBER HERE?
         BE    FOUNDM                   YES, GO WORK ON IT
         BH    MNF                      IF PAST ALPHA SEQ GIVE UP *PCN*
         BAS   R8,NXTDIRNT              INCR TO NEXT ENTRY         LDW1
         BNP   MLOOP                    NEG, END BLK - READ ANOTHER
         B     MLOOP2                   MORE TO GO - KEEP LOOKING
FOUNDM   MVC   TTR(3),8(R3)             PICK UP MEMBER'S TTR
         MVC   MEMTTR(3),8(R3)          SAVE IT FOR LATER USE
         MVC   ESDID,=H'1'              RESET ESDID TO DEFAULT      *N*
         MVI   IDRFLAG,NOCHGIDR         HAVEN'T CHANGED IDR YET   *LPR*
         XC    TXTTTR(3),TXTTTR         ASSUME NOT A LOAD MOD       *N*
         XC    CTL1TTR(3),CTL1TTR       NO 1ST CTL REC YET         MAS2
         MVC   8(1,R13),11(R3)          FLAGS/LEN FROM DIR ENTRY   MAS2
         NI    8(R13),B'01100000'       # TTR'S IN USER DATA FILED MAS2
         CLI   8(R13),B'00100000'       AT LEAST ONE USER TTR?     MAS2
         BL    FOUNDM1                  BRANCH IF NOT LOAD MODULE  MAS2
         MVC   8(1,R13),11(R3)          FLAGS/LEN FROM DIR ENTRY   MAS2
         NI    8(R13),B'00011111'       # H-WORDS USER DATA        MAS2
         CLI   8(R13),12                AT LEAST 12 H-WORDS?       MAS2
         BL    FOUNDM1                  BRANCH IF NOT LOAD MODULE  MAS2
         CLI   DCBRECFM-IHADCB+DCBU,RECFMU   A LOAD MODULE?         *N*
         BNE   FOUNDM1                  NO, NO TEXT THEN            *N*
         MVC   TXTTTR(3),12(R3)         YES, SAVE 1ST TEXT BLK TTR  *N*
FOUNDM1  LA    R1,N0                    POINT TO PROPER NUMBER
         BAS   R8,SETLINE               SET UP LINE TO PUT
         B     NEW$READ                 NOT PRINTING, EXIT
         MVI   0(R2),C'0'               DOUBLE SPACE IT
         MVC   20(24,R2),=C'MEMBER XXXXXXXX SELECTED'
         MVC   27(8,R2),MEMBER          FILL IN THE MEMBER IN QUESTION
         BAS   R8,CPUT                  NOW DUMP THE LINE OUT
         B     NEW$READ                 GO DO IT
JUSTM    MVC   TTR(3),MEMTTR            RESTORE START OF MEMBER    LDW1
         B     NEW$READ                 GET IT                     LDW1
NXTDIRNT IC    R4,11(,R3)               GET INDICATORS             LDW1
         N     R4,=X'0000001F'          JUST # USER DATA HALFWORDS LDW1
         LA    R4,12(R4,R4)             ENTRY LENGTH               LDW1
         AR    R3,R4                    -> NEXT ENTRY              LDW1
         SR    R2,R4                    DECR LENGTH REMAINING      LDW1
         BR    R8                       RETURN WITH CC SET         LDW1
         SPACE 2
*        ZAP --- COMMAND EXECUTION --- NAME.                        *N*
*        *****  NAME  *****                                         *N*
         SPACE 1                                                    *N*
NAME#    BAS   R8,CHKPT                 NEED CHKPT?                 *N*
         OC    TXTTTR(3),TXTTTR         IS THERE ANY TEXT?          *N*
         BZ    NAMENFN#                 NO, CAN'T HAVE ESD'S THEN   *N*
         MVC   NAME(8),MEMBER           ASSUME CSECT IS MODULE    *LPR*
         LTR   R0,R0                    IS THERE AN ARGUMENT?      LDW1
         BNP   *+L'*+6                  NO, OK THEN                LDW1
         MVC   NAME(8),0(R1)            MOVE NAME TO FIELD         LDW1
         MVI   FLAGESD,0                NO FLAGS YET                *N*
         SPACE 1
*        FIND THE ESD'S FIRST.                                      *N*
         SPACE 1                                                    *N*
         MVC   0(3,R13),TTR             REMEMBER WHERE WE ARE NOW   *N*
         MVC   TTR(3),MEMTTR            START LOOKING AT BEGIN MEMB *N*
         BAS   R8,READBLK               GET 1ST BLK                 *N*
NAMEFIND L     R1,ADDRDATA              POINT TO RECORD            LDW1
         TM    0(R1),X'01'              CONTROL REC?                *N*
         BNO   NAMECHKE                 NO, POSSIBLE ESD OR SYM     *N*
NAMENFND CLC   TTR(3),0(R13)            NOT FOUND. HAVE WE MOVED?   *N*
         BE    NAMENFN#                 NO, NO RE-POSITION NECESSRY *N*
         MVI   TTR+3,NOSEQRD            YES, NO SEQUENTIAL READ     *N*
         MVC   TTR(3),0(R13)            RESET WHERE WE WERE         *N*
         BAS   R8,READBLK               PUT US BACK                 *N*
NAMENFN# LA    R2,NAMEMNF               'INVALID' MSG               *N*
         B     BOTCH                    OH WELL                     *N*
NAMECHKE CLI   0(R1),X'20'              ESD?                        *N*
         BE    NAMEESD                  YES, HAVE ONE, TRY IT       *N*
NAMEENXT MVI   EOFRET,NOEOF             EOF'S ARE DATA NOW          *N*
         BAS   R8,READNBLK              GET NEXT BLK               LDW1
         CLC   LINE05+27(20),EOFMSG     HIT EOF HERE?              LDW1
         BE    NAMENFND                 YES, NOT FOUND              *N*
         CLI   IOERROR,YESSYN           I/O ERROR                   *N*
         BE    NAMENFND                 YES, NOT FOUND              *N*
         B     NAMEFIND                 NONE, KEEP LOOKING          *N*
NAMEESD  LH    R15,6(,R1)               GET LEN ESD DATA THIS BLK   *N*
         LA    R1,8(,R1)                PT PAST ESD PREFIX TO DATA  *N*
         AR    R15,R1                   PT PAST LAST ESD DATA       *N*
         USING ESDDATA,R1               ESD ENTRIES                 *N*
NAMECHK  CR    R1,R15                   PAST END THIS BLK?          *N*
         BNL   NAMEENXT                 YES, NEXT ESD BLK           *N*
         CLC   ESDDNAME(8),NAME         NO, NAME MATCH?             *N*
         BE    NAMEGOT                  YES, WE MIGHT HAVE IT       *N*
NAMEBNXT LA    R1,ESDDL(,R1)            NEXT ENTRY IN BLK           *N*
         B     NAMECHK                  KEEP SCANNING BLK           *N*
         SPACE 1
*        THE ENTRY POINT EXISTS. FIND THE PLACE IN THE MODULE TEXT. *N*
         SPACE 1                                                    *N*
NAMEGOT  NI    ESDDTYPE,255-X'F0'       JUST WANT LOW NIBBLE        *N*
         CLI   ESDDTYPE,X'02'           EXT REF ENTRY (ER)?         *N*
         BE    NAMEBNXT                 YES, IGNORE, NEXT ENTRY     *N*
         CLI   ESDDTYPE,X'0A'           WEAK EXT REF? (WEX)?        *N*
         BE    NAMEBNXT                 YES, IGNORE, NEXT ENTRY     *N*
         L     R3,ESDDADDR-1            NO, GET LKED ADDR OF EP     *N*
         LA    R3,0(,R3)                GET RID OF TYPE BYTE        *N*
         DROP  R1                       NO MORE ENTRIES             *N*
         L     R15,ADDRDATA             PT TO ESD BLK PREFIX       LDW1
         LH    R14,4(,R15)              GET ESDID 1ST NTRY THIS BLK *N*
         LA    R15,8(,R15)              PT PAST PRFX TO 1ST ENTRY   *N*
         SR    R1,R15                   OFFSET MTHC ENTRY FROM PRFX *N*
         XR    R0,R0                    FOR DIVIDE                  *N*
         D     R0,=A(ESDDL)             GET ESDID REL THIS BLK      *N*
         AR    R1,R14                   GET ESDID MATCH ENTRY POINT *N*
         STH   R1,ESDID                 SAVE FOR IDR UPDATE         *N*
         MVI   TTR+3,NOSEQRD            NO MORE SEQ READ            *N*
         MVC   TTR(3),CTL1TTR           START AT 1ST CTL RECORD    MAS2
         OC    TTR(3),TTR               ANY 1ST CTL TTR?           MAS2
         BNZ   *+L'*+6                  YES, HAVE TTR 1ST CTL REC  MAS2
         MVC   TTR(3),MEMTTR            ELSE START AT MEMBER       MAS2
         BAS   R8,READBLK               GET ESD, CTL, IDR RECORD   MAS2
         NI    FLAGESD,255-FESDTEXT     NEXT BLK IS NOT TEXT       MAS2
NAME$L1  TM    FLAGESD,FESDTEXT         IS THIS TEXT BLOCK?        MAS2
         BO    NAME$T1                  BRANCH IF IS TEXT RECORD   MAS2
         L     R1,ADDRDATA              @ NON-TEXT RECORD          MAS2
         TM    0(R1),X'01'              CONTROL RECORD?            MAS2
         BZ    NAME$NX                  NOT CTL REC, TRY NEXT      MAS2
         OI    FLAGESD,FESDTEXT         NEXT BLK IS TEXT           MAS2
         OC    CTL1TTR(3),CTL1TTR       HAVE SAVED 1ST CTL TTR?    MAS2
         BNZ   *+L'*+6                                             MAS2
         MVC   CTL1TTR(3),TTR           SAVE TTR 1ST CTL REC       MAS2
         MVC   TXTORIG(4),8(R1)         LKED ORIG NXT BLK (TEXT)   MAS2
         MVI   TXTORIG,0                CLEAR HIGH BYTE            MAS2
NAME$NX  MVI   EOFRET,NOEOF             EOF'S ARE DATA              *N*
         BAS   R8,READNBLK              GET NEXT LOADMOD BLK       LDW1
         CLC   LINE05+27(20),EOFMSG     EOF?                       LDW1
         BE    NAMENFND                 OOPS, CAN'T HAPPEN          *N*
         B     NAME$L1                  CONTINUE SEARCH            MAS2
NAME$T1  NI    FLAGESD,255-FESDTEXT     NEXT BLK IS NOT TEXT       MAS2
         LR    R0,R3                    COPY ENTRY ORIGIN          MAS2
         S     R0,TXTORIG               ENTRY - TXT BLOCK ORIG?    MAS2
         BM    NAME$NX                  NOT IN NEXT TXT BLK        MAS2
         CH    R0,BLKLEN                OFFSET IN BLOCK = BLKLEN   MAS2
         BNL   NAME$NX                  NOT IN NEXT TXT BLK        MAS2
         SPACE 1                                                   LDW1
*        WE HAVE THE BLOCK AND OFFSET OF THE ENTRY POINT.           *N*
*        NOTIFY/DISPLAY.                                            *N*
         SPACE 1                                                    *N*
         MVI   TTR+3,NOSEQRD            NO MORE SEQ READS          MAS2
         LR    R3,R0                    OFFSET INTO BLOCK           *N*
         LA    R1,N8                    MSG/WTO                     *N*
         BAS   R8,SETLINE               SET IT UP                   *N*
         B     NAMEDONE                 NOT PRINTING                *N*
         MVI   0(R2),C'0'               DBL SPACE                   *N*
         MVC   20(24,R2),=C'MEMBER XXXXXXXX SELECTED'  FOR SPACE    *N*
         MVC   20(6,R2),=CL6'ENTRY'     MEMBER=ENTRY                *N*
         MVC   27(8,R2),NAME            MOVE ENTRY NAME IN          *N*
         BAS   R8,CPUT                  DO IT                       *N*
NAMEDONE LR    R15,R3                   GET OFFSET INTO BLOCK       *N*
         MVI   IDRFLAG,NOCHGIDR         HAVEN'T CHANGED IDR YET    LDW1
         B     SETPOINT                 SIMULATE A '+' COMMAND      *N*
         SPACE 2
*        ZAP --- COMMAND EXECUTION --- NOTE, EJECT.                MAS2
*        *****  NOTE  *****
         SPACE 1
NOTE     BAS   R8,LOGTEST                                          LDW1
         OI    FLAGS2,NOWHEREF          SUPRESS WHERE LINES
         L     R2,CSOUTWK               FIND WORKAREA
         LTR   R2,R2                    ANY THERE?
         BZ    BADCSOUT                 NO, TELL HIM SORRY         LDW1
         L     R2,0(,R2)                FIND THE NEXT LINE IMAGE
         MVC   1($L-4,R2),REP+4         COPY NOTATION TO BUFFER    LDW1
         MVI   ENQIT,255                FORCE IT TO BE ENQUEUED
         MVI   0(R2),C'0'               DOUBLE SPACE NOTES
         BAS   R8,CPUT                  DUMP THIS LINE NOW
         B     NEWDSPNT                 THEN CONTINUE ON MERRY WAY
BADCSOUT LA    R2,NOCSOUT               TELL HIM CAN'T ENQ
         B     BOTCH                    BYE
         SPACE 1                                                   LDW1
*        *****  EJECT  *****
         SPACE 1
EJECT    BAS   R8,LOGTEST                                          LDW1
         OI    FLAGS2,NOWHEREF          SUPRESS WHERE LINES
         L     R2,CSOUTWK               GET THE WORKAREA PTR
         LTR   R2,R2                    IS THERE ONE?
         BZ    BADCSOUT                 NO, GIVE UP ON THIS ENDEAVOR
         L     R2,0(R2)                 FIND THE NEXT LINE IMAGE
         MVI   0(R2),C'1'               PAGE EJECT
         MVI   ENQIT,255                FORCE ENQ TO PRINT
         BAS   R8,CPUT                  DO IT
         B     NEWDSPNT                 ALL DONE
         EJECT
*        ZAP --- UTILITY BAS ROUTINES.
         SPACE 1
*  ROUTINES INCLUDE :
*  ------------------
*  CLEAR........CLEAR SCREEN
*  READBLK......GET A DATA BLOCK
*  CALLEXP......CALL EXP TO PARSE EXPR, CHECK ERROR RETURNS        LDW1
*  HEXCHECK.....VALIDITY CHECK HEX
*  GETSTRNG.....VALIDITY CHECK AND PARSE HEX/CHAR STRING
*  NUMCONV......CONVERT A NUMBER TO HEX AND SIGNED DECIMAL         LDW1
*  CSIO.........PRIMARY SCREEN DISPLAY
*  CSIO#........SECONDARY SCREEN DISPLAY
*  PUTLINE......PUTLINE 1 LINE TO TERMINAL                         LDW1
*  TTRPARSE.....PARSE OUT SPECIFIED TTR
*  PREPDUMP.....PREPARE FOR DUMP - GET BLOCK, PRINT HEADER LINE
*  DUMPER.......DUMP A BLOCK IN DUMP FORMAT
*  CLEARDEF.....RESET DEFINE TABLE
*  CLOSE........CLOSE DATASET
*  WRITE........EXCP WRITE OUT A BLK
*  OPENMSG......GIVE PRINT FILE MSG OF DATASET OPEN
*  CPUT.........ENQ TO PRINT AN OUTPUT LINE
*  SETLINE......SET UP THE OUTPUT LINE FOR CPU
*  SETSTRNG.....CONVERT VARIOUS CONSTANTS FOR CPUT
*  SETMSG.......MOVE INFO MSG TO CORRECT PLACE ON SCREEN           LDW1
*  BOTCH........DISPLAY ERROR MESSAGES
*  EODAD........END OF FILE EXIT (SYNAD)
*  CHKPT........CHECK IF ZAP NEEDED.  IF SO IGNORE COMMAND PENDING
*  INIT3270.....TURN ON  3270 MODE CONSOLE I/O                     LDW1
*  KILL3270.....TURN OFF 3270 MODE CONSOLE I/O                     LDW1
         EJECT
* * * * * * * * CLEAR * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
*        CLEAR THE SCREEN BUFFER EXCEPT FOR ERROR AND I/O ERROR LINES.
         SPACE 1
CLEAR    LA    R15,LINE01-2             -> START                   SDM5
         LA    R0,3                     NUMBER OF LINES            SDM5
         BAS   R14,CLEARX               CLEAR 1-3                  SDM5
         LA    R15,LINE06-2             -> START                   LDW1
         LA    R0,13                    NUMBER OF LINES            LDW1
         BAS   R14,CLEARX               CLEAR 6-18                 LDW1
         LA    R15,LINE20-2             -> START                   LDW1
         LA    R0,2                     NUMBER OF LINES            LDW1
         BAS   R14,CLEARX               CLEAR 20-21                LDW1
         MVI   LINE02-1,X'C8'           UNPROT HIGH                LDW1
         XC    LINE02,LINE02            NULLS FOR THIS ONE         SDM5
         MVC   LINE05-2(2),=X'1DE8'     I/O ERRMSG LINE (PROT HIGH)SDM5
         MVC   LINE19-2(2),=X'1DE8'     AND OTHER ERRMSG LINE      SDM5
         MVC   REP-2(2),LINE02-2        UNPROT HIGH                LDW1
         BR    R8                       RETURN TO CALLER
         SPACE 1
*  X... ....  SET TO MAKE VALID CHAR                               LDW1
*  .1.. ....  MUST BE 1                                            LDW1
*  ..1. ....  PROT                                                 LDW1
*  ...1 ....  NUMERIC                                              LDW1
*  ..11 ....  AUTOSKIP                                             LDW1
*  .... 00..  DISPLAY / NOT SELECTOR PEN DETECTABLE                LDW1
*  .... 01..  DISPLAY / DETECTABLE                                 LDW1
*  .... 10..  HIGH INTENSITY / DETECTABLE                          LDW1
*  .... 11..  NO DISPLAY / NOT DETECTABLE                          LDW1
*  .... ..0.  MUST BE 0                                            LDW1
*  .... ...1  MDT FLAG                                             LDW1
         SPACE 1
CLEARX   MVC   0(2,R15),=X'1D60'        PROT AUTOSKIP LOW          LDW1
         MVC   2($L,R15),BLANKS         BLANK THE LINE             LDW1
         LA    R15,$I(,R15)             -> NEXT LINE               LDW1
         BCT   R0,CLEARX                CONTINUE                   LDW1
         BR    R14                      DONE THIS SECTION          LDW1
         SPACE 1
* * * * * * * * READBLK * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
*        EXCP READ A BLOCK (PHYSICAL RECORD) INCLUDING KEY (IF ANY).
*        IF TTR+3 CONTAINS A 1 (FLAG) THEN READ SEQUENTIALLY,
*        SIMULATING BSAM.
         SPACE 1
READNBLK MVI   TTR+3,SEQREAD            SET NEXT BLOCK FLAG        LDW1
READBLK  NI    FLAGS2,255-ATTNHIT       NO ATTN YET                LDW1
READBLK2 MVI   IOERROR,NOSYN            START WITH NO I/O ERROR
         ST    R8,DBLW                  SAVE RETURN ADDR           LDW1
         BAS   R8,CHKPT                 SEE IF HE CAN LEAVE        LDW1
         CLI   TTR+3,SEQREAD            DO BLOCK +1?
         BNE   READBLK#                 NO
         IC    R15,TTR+2                GET RECORD NO
         LA    R15,1(R15)               NEXT RECORD
         STC   R15,TTR+2                NEXT ONE
READBLK# MVC   LINE05,BLANKS            CLEAR I/O ERR MSG IF ANY   LDW1
         CLI   CHNGED,0                 BUFFER TAMPERED WITH W/O CHKPT?
         BE    NORDBMSG                 NO, ITS OK TO READ THEN
         MVI   CHNGED,0                 WELL IT'LL BE CLEAN NOW
         NI    FLAGS2,255-MUSTZAP       NEW BLOCK, NO ZAP NEEDED YET
         LA    R1,N4                    MSG NUMBER
*LDW1    ST    R8,DBLW                  SAVE FOR LATER
         BAS   R8,SETLINE               SETUP THE LINE
         B     NORDBMSG                 NOT PRINTING               LDW1
         MVC   31(18,R2),=C'BLOCK NOT REPLACED'
         MVI   0(R2),C'0'               DOUBLE SPACE
         HEX   (24,R2),OLDTTR,LEN=3     DIFF TTR THIS TIME         LDW1
         BAS   R8,CPUT                  DUMP THE LINE
NORDBMSG L     R8,DBLW                  RESTORE RET REG            LDW1
         XC    BLKLEN(2),BLKLEN         ASSUME NOTHING READ        LDW1
         LA    R15,CCW##R               -> CCW CHAIN               LDW1
         CLI   TTR+2,0                  R0?                        LDW1
         BNE   *+L'*+4                  NO, OK                     LDW1
         LA    R15,CCW##R0              READ R0                    LDW1
         ST    R15,IOBCCWA              SET IN IOB                 LDW1
         L     R0,TTR                   GIVE HIM THE TTRN          LDW1
         N     R0,=X'FFFFFF00'          MAKE IT A TTRN             LDW1
         L     R1,DCBDEBAD+DCBU-IHADCB  GIVE HIM THE DEB           LDW1
         LA    R2,MBBCCHHR              GIVE HIM A WORKAREA FOR IT LDW1
         STM   R8,R12,52(R13)           SAVE SOME REGISTERS        LDW1
         LR    R8,R13                   SAVE PTR TO SAVEAREA       LDW1
         L     R15,CVTPTR               CVT PTR                    LDW1
         L     R15,CVTPCNVT-CVT(,R15)   POINT TO THE ROUTINE       LDW1
         BASR  R14,R15                  GO DO IT                   LDW1
         LR    R13,R8                   RESTORE PTR TO SAVE AREA   LDW1
         LM    R8,R12,52(R13)           RESTORE THE DEAD REGS      LDW1
         LTR   R15,R15                  OUT OF DS?                 LDW1
         BNZ   EXCP42                   YES, DON'T BOTHER READING  LDW1
         IC    R1,CCHHR+4               GET "R"                    LDW1
         BCTR  R1,0                     -1 FOR SEARCH ID           LDW1
         STC   R1,CCHHR+4               SET BACK                   LDW1
         EXCP  IOB                                                 LDW1
         WAIT  ECB=ECB                                             LDW1
         MVC   CCHHR+4(1),TTR+2         RESTORE "R"                LDW1
         LH    R2,BUFFSIZE              GET BUFSIZ (MAX READ=BLKSI)LDW1
         SH    R2,CSW+6                 =AMOUNT READ               LDW1
         LR    R0,R2                    COPY 8+KL+DL               LDW1
         SH    R0,=H'8'                 GET KEYLEN+DATALEN         LDW1
         STH   R0,CCW#W#W+6             SAVE IT FOR LATER USE      LDW1
         L     R1,ADDRCNT               -> COUNT                   LDW1
         MVC   KEYLEN+1(1),5(R1)        SET UP KEYLEN              LDW1
         LH    R15,KEYLEN               GET KEYLEN                 LDW1
         LA    R0,8(R1,R15)             -> DATA                    LDW1
         ST    R0,ADDRDATA              SET ADDR OF DATA           LDW1
         CLC   ADDRBUFF,ADDRKEY         HOW MUCH DO WE DISPLAY?    LDW1
         BL    SAVE$LEN                 COUNT + KEY + DATA         LDW1
         BE    *+L'*+2                  KEY + DATA                 LDW1
         SR    R2,R15                   JUST DATA                  LDW1
         SH    R2,=H'8'                 NOT COUNT FIELD            LDW1
SAVE$LEN STH   R2,BLKLEN                SAVE IT FINALLY            LDW1
         SPACE 1
*        NOW CHECK THE READ, FINALLY...                            LDW1
         SPACE 1
         CLI   ECB,X'7F'                OK?                        LDW1
         BE    EXCPOK                                              LDW1
         CLI   ECB,X'42'                END OF EXTENT              LDW1
         BE    EXCP42                                              LDW1
         CLI   ECB,X'41'                PERM ERROR?                LDW1
         BE    EXCP41                                              LDW1
REALERR  LA    R1,=CL15' TYPE UNKNOWN  '  GET MSG ADDR             LDW1
EXCPERR  XR    R0,R0                    GET A ZERO                 LDW1
         STH   R0,BLKLEN                NOTHING WAS READ           LDW1
         STH   R0,CCW#W#W+6             AND NOTHING TO WRITE.      LDW1
EXCPERR$ MVI   IOERROR,YESSYN           AND IT WAS IN ERROR        LDW1
         MVC   LINE05+17(40),IOERRMSG   MOVE IN MASK               LDW1
         MVC   LINE05+35(15),0(R1)      MOVE IN ERROR MSG          LDW1
         MVI   TTR+3,NOSEQRD            TURN OFF SEQ READ FLAG     LDW1
         BR    R8                                                  LDW1
EXCP42   LA    R1,=CL15'NOT IN DATA-SET'  GET MSG ADDR             LDW1
         B     EXCPERR                                             LDW1
EXCP41   TM    CSW+4,X'01'              UNIT EXCEPTION?            LDW1
         BO    EODAD                    YES, EOF                   LDW1
         TM    IOB+3,X'08'              NRF?                       LDW1
         BNO   NOT$NRF                  NO                         LDW1
EXCP$NRF CLI   TTR+3,SEQREAD            NEXT BLOCK REQ?            LDW1
         LA    R1,=CL15'NO RECORD FOUND'  GET MSG ADDR IN CASE     LDW1
         BNE   EXCPERR                                             LDW1
         LH    R15,TTR                  GET TRACK                  LDW1
         LA    R15,1(,R15)              NEXT TRACK                 LDW1
         STH   R15,TTR                  SAVE IT                    LDW1
         MVI   TTR+2,1                  RECORD 1                   LDW1
         MVI   TTR+3,NOSEQRD            RESET SEQ READ FLAG        LDW1
         B     READBLK2                 GO REREAD                  LDW1
NOT$NRF  TM    CSW+5,X'40'              INCORRECT LENGTH?          LDW1
         BNO   REALERR                  NO, SOMETHING ELSE         LDW1
         LA    R1,=CL15'INCORR. LENGTH '  GET MSG ADDR             LDW1
         B     EXCPERR                  GO SAY INCORRECT LENGTH    LDW1
EXCPOK   L     R15,ADDRCNT              -> COUNT                   LDW1
         CLC   CCHHR(5),0(R15)          RIGHT RECORD?              LDW1
         BE    EXCPOK$                  YES, CONTINUE              LDW1
         LA    R1,=CL15'CCHHR INCORRECT'  GET MSG ADDR IN CASE     LDW1
         CLC   CCHHR(4),0(R15)          RIGHT CCHH?                LDW1
         BNE   EXCPERR$                 NO, ARRGH                  LDW1
         CLI   4(R15),1                 IS IT R1?                  LDW1
         BE    EXCP$NRF                 YES, IT'S REALLY NRF       LDW1
         B     EXCPERR$                 NO, ARRGH                  LDW1
EXCPOK$  MVI   TTR+3,NOSEQRD            TURN OFF SEQ READ FLAG     LDW1
         OC    CSW+6(2),CSW+6           ANY RESIDUAL?              LDW1
         LA    R1,=CL15'BLKLEN > BUFFSZ'   -> MSG IN CASE          LDW1
         BZ    EXCPERR$                 NO, ERROR                  LDW1
         TM    FLAGS2,ATTNHIT           WAS ATTN SIGNALED LATELY?  LDW5
         BNOR  R8                       NO, ALL DONE, RETURN BLK
         BAS   R8,CLEAR                 YES, CLEAR SCREEN
         MVC   LINE19+17(40),=CL40'         *****  HOLDING  ******'
         B     SETPNT00                 DISP OFF 0, CURR BLK       LDW1
         SPACE 1
* * * * * * * * CALLEXP * * * * * * * * * * * * * * * * * * * * *  LDW1
         SPACE 1
*        CALL EXP, CHECK ERROR RETURNS.                            LDW1
*              R1 -> STRING.                                       LDW1
*              R0  = LENGTH.                                       LDW1
*              R8  = RETURN ADDRESS.                               LDW1
*                    NOTE : CC IS SET ACCORDING RESULT'S SIGN.     LDW1
         SPACE 1
CALLEXP  LR    R2,R15                   COPY "*" VALUE             LDW1
         L     R15,=A(EXP)              -> ROUTINE                 LDW1
         BASR  R14,R15                  CALL IT                    LDW1
         LTR   R1,R1                    WORK?                      LDW1
         BNM   INVEXPER                 NO                         LDW1
         SLL   R1,1                     YES                        -EU-
         SRL   R1,1                     NEGATIVE BIT CLEARED       -EU-
         LTR   R15,R15                  SET CC                     LDW1
         BR    R8                       RETURN TO CALLER           LDW1
         SPACE 1
* * * * * * * * HEXCHECK  * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
*        VALIDITY CHECK FOR HEXADECIMAL, DECIMAL, OR CHARACTER.
*              R7 = POINTER TO STRING.
*              R1 = LENGTH OF STRING.
*              R8 = RETURN ADDRESS.
*                   NOTE : 0(R8)=GOOD HEX, 4(R8)=BAD HEX AT 0(R7).
*              R15 = 0 IF PURE DECIMAL UP TO EXIT, 4 IF HEX.
         SPACE 1
HEXCHECK XR    R15,R15                  ASSUME DECIMAL
HEXCHK   TM    0(R7),X'F0'              NUMBER?
         BO    OKHEX                    YES, ITS OK
         CLI   0(R7),C'A'               LESS THAN ALPHA?
         BL    4(R8)                    YES, MUST BE CHARACTER
         CLI   0(R7),C'F'               'F' OR SMALLER?
         BH    4(R8)                    NO, MUST BE CHARACTER
         LA    R15,4                    INDICATE HEX (NOT DECIMAL)
OKHEX    LA    R7,1(R7)                 SO FAR SO GOOD, UPDATE HEX PTR
         BCT   R1,HEXCHK                DO THE WHOLE STRING
         BR    R8                       WE'RE OK - ALL DONE
         SPACE 1
* * * * * * * * GETSTRNG  * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
*        PARSE OUT HEX OR CHARACTER STRING FOR S, X, O, N, L AND
*        SET COMMS. DETERMINE STRING LENGTH AND STRING ITSELF,
*        AND SAVE BOTH IN AREA.
*        IF DECIMAL - A FULLWORD IS STORED (< 2147483647.).
*        IF HEXADECIMAL - UP TO 16 DIGITS (DOUBLEWORD) MAY BE STORED.
*        IF CHARACTER - ANY DELIMITERS MAY SURROUND THE STRING EXCEPT
*                       STRING EXCEPT HEX DIGITS) AND UP TO 16 CHAR
*                       (2 DOUBLE-WORDS) MAY BE STORED.
*              R3 = ACTUAL LENGTH OF STRING TO BE PARSED.
*              R4 = PTR TO THE STRING ITSELF.
*              R5 = PTR TO STRING SAVEAREA (1ST BYTE = LEN).
         SPACE 1
GETSTRNG LA    R1,1                     LEN OF HEX TO BE CHECKED
         LR    R7,R4                    LOC OF HEX TO BE CHECKED
         BAS   R8,HEXCHECK              DO IT
         B     HEXSTR                   FIRST CHAR HEX - SO HEX STRING
         SPACE 1
*        CHARACTER STRING.
         SPACE 1
         CH    R3,=H'18'                STRING LONGER THAN 16 CHARS?
         BH    LENERROR                 YES, SAY LENGTH ERROR      LDW1
         XC    TEMPTRT(256),TEMPTRT     CLEAR OUT TRTAB
         XR    R1,R1                    CLEAR OUT WORK REG
         IC    R1,0(,R4)                GET DELIM FOR CHAR STRING
         STC   R1,TEMPTRT(R1)           PUT IT IN RIGHT PLACE IN TRTAB
         SH    R3,=H'2'                 GET ADJUST STRING LEN (DELIMS)
         BNP   LENERROR                 HE ENTERED S'' OR LESS - ERROR
DELIMTRT TRT   1(0,R4),TEMPTRT          << EXECUTED >>
         EX    R3,DELIMTRT              FIND THE OTHER DELIMITER
         LA    R2,=CL20'NO ENDING DELIMITER'   GET MSG ADDR IN CASE
         BZ    BOTCH                    NO, TELL HIM               LDW1
         LA    R3,1(,R4)                PT TO BEGINNING OF STRING
         SR    R1,R3                    GET STRING LEN (NO DELIMS)
         LR    R3,R1                    PUT IN RIGHT REG
         BCTR  R3,0
         LTR   R3,R3                    NULL INPUT?
         BM    LENERROR                 YES, SAY LENGTH ERROR
         LR    R1,R4                                               -EU-
         CLI   CAPSFLG,YESCAPS                                     -EU-
         BE    SKCAPS                                              -EU-
         LA    R0,TEMP2                                            -EU-
         SLR   R4,R0                                               -EU-
         LA    R4,ICREP(R4)                                        -EU-
SKCAPS   EX    R3,CHARMVC               MOVE STRING CHARS TO AREA  -EU-
         LR    R4,R1                                               -EU-
         B     FINSTR                   GO FINISH THE JOB
CHARMVC  MVC   2(0,R5),1(R4)            << EXECUTED >>             LDW1
LENERROR LA    R2,LENERR                YES, SAY LENGTH ERROR
         B     BOTCH                    GO TELL HIM
         SPACE 1
*        HEX STRING.
         SPACE 1
HEXSTR   CH    R3,=H'16'                HEX STRING LONGER THAN 16?
         BH    LENERROR                 YES, SAY LENGTH ERROR
         LR    R1,R3                    PUT IT IN RIGHT REG FOR CHECK
         LR    R7,R4                    POINT TO LOC TO CHECK
         BAS   R8,HEXCHECK              CHECK THE HEX
         B     OK1#                     ITS GOOD
         CLI   0(R7),C' '               IS IT HEX?
         BE    OK1#                     YES, GO DO IT
         CLI   0(R7),C'.'               DECIMAL?
         BE    DECMAYBE                 MAYBE SO
         LA    R2,=CL20'INVALID HEXADECIMAL'   IT'S BAD - PT TO MSG
         B     BOTCH                    TELL HIM
OK1#     TR    0(16,R4),TRHEX           YES, START TO CONVERT TO HEX
         CH    R3,=H'15'                IS THIS THE MAX CASE?
         BL    HEXPACK                  NO, DO JUST ENOUGH
         PACK  TEMP(5),0(9,R4)          PACK FIRST GROUP
         PACK  TEMP+4(5),8(9,R4)        PACK SECOND GROUP
         BH    HEX16                    SKIP IF 16 DIGITS          LDW1
         LM    R14,R15,TEMP             GET THE RESULT             LDW1
         SRDL  R14,4                    DOWN 1 NIBBLE              LDW1
         STM   R14,R15,TEMP             RESTORE IT CORRECTLY       LDW1
HEX16    LA    R3,7                     NUMBER OF BYTES (EX LEN)
         MVC   2(8,R5),TEMP             GET HEX                    LDW1
         B     FINSTR                   AND THEN RETURN TO CALLER
         SPACE 1
*        R3 IS NOT BCTRED BECAUSE WE NEED A FLIP BYTE ON THE END.
         SPACE 1
HEXPACK  PACK  TEMP(8),0(0,R4)          << EXECUTED >>
         EX    R3,HEXPACK               PACK TO MAKE REAL HEX
         LA    R3,1(,R3)                ROUND UP ...
         SRL   R3,1                     AND FIND NUMBER OF BYTES
         LA    R15,TEMP+7               POINT TO GORF BYTE
         SR    R15,R3                   POINT TO FIRST BYTE
         BCTR  R3,0                     GET EXECUTE LENGTH
MOVEHEX  MVC   2(0,R5),0(R15)           << EXECUTED >>             LDW1
         EX    R3,MOVEHEX               MOVE HEX TO OUTPUT LOCATION
FINSTR   STH   R3,0(,R5)                SAVE THE LEN IN SCAN AREA  LDW1
         BR    R6                       RET TO CALLER
         SPACE 1
*        DECIMAL STRING.
         SPACE 1
DECMAYBE BXLE  R15,R15,DECOK            IF REALLY DECIMAL - JUMP
         LA    R2,INVDEC                NO, TELL HIM SO BECAUSE...
         B     BOTCH                    ITS GOT A-F IN IT
DECOK    CH    R3,=H'10'                APPROACHING LEN ERR (BCTR'D)?
         BL    DECOK#                   NO, DON'T WORRY ABOUT IT
         CLC   0(11,R4),=C'2147483647.' TOO BIG FOR FULLWORD?
         BH    LENERROR                 YES, TELL HIM AND GET OUT
DECPACK  PACK  TEMP(8),0(0,R4)          << EXECUTE >>
DECOK#   LA    R0,1(R4)                 POINT TO STRING + 1 FOR TO....
         SR    R7,R0                    GET EXECUTE LENGTH
         EX    R7,DECPACK               PACK UP YOUR DECIMALS IN ...
*        COMMENT TYPE=CONTINUED         IN YOUR OLD DOUBLE WORD
         CVB   R1,TEMP                  AND CONVERT, CONVERT, CONVERT
         ST    R1,TEMP                  SAVE IN ALIGNED PLACE
         MVC   2(4,R5),TEMP             COPY TO OUTPUT STRING      LDW1
         MVI   1(R5),3                  EXECUTE LENGTH             LDW1
         BR    R6                       RETURN
         SPACE 1
* * * * * * * * NUMCONV * * * * * * * * * * * * * * * * * * * * *  LDW1
         SPACE 1
*              R15 = NUMBER TO BE CONVERTED.                       LDW1
*              R14 = RETURN ADDRESS.                               LDW1
*                    NUMBER IS CONVERTED TO 12 SIGNED DECIMAL      LDW1
*                    DIGITS AT TEMP2, AND TO HEX AT TEMP2+12       LDW1
*                    (8 CHARS).                                    LDW1
         SPACE 1
NUMCONV  ST    R15,TEMP                 SET FOR UNPK               LDW1
         UNPK  TEMP2+12(8+1),TEMP(4+1)                             LDW1
         TR    TEMP2+12(8),TRHEX        MAKE EBCDIC                LDW1
         CVD   R15,TEMP                 GET IN PACKED FORM         LDW1
         LA    R1,TEMP2+11              INIT LOC FOR FLOATING SIGN LDW1
         MVC   TEMP2(12),EDMASK         MOVE IN EDIT MASK          LDW1
         EDMK  TEMP2(12),TEMP+2         GET 11 DECIMAL DIGITS      LDW1
         LTR   R15,R15                  IS IT NEGATIVE?            LDW1
         BNMR  R14                      NO, ALL DONE               LDW1
         BCTR  R1,0                     YES, SO BACK UP AND...     LDW1
         MVI   0(R1),C'-'               ...PUT IN THE SIGN         LDW1
         BR    R14                      NOW DONE                   LDW1
         SPACE 1
* * * * * * * * CSIO  * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
*        MAIN SCREEN DISPLAY.
*        CREATE TRACE TABLE ENTRY IF NECESSARY.
*        DISPLAY WITH TPUTS FOR NOW.
         SPACE 1
CSIO     MVC   PREVREP,REP              SAVE FOR TWICE TEST        LDW4
         TM    TRACE,NOTRACE            TRACE FOR THIS GUY?
         BO    NOTRACIT                 NO, SO DONT
         SPACE 1
*        MAKE THE TRACE TABLE ENTRY.
         SPACE 1
         L     R1,ITRAVAL               PICK UP NEXT SPOT IN TABLE
         CLI   0(R1),X'FF'              END?
         BNE   MORETAB                  NO, THERE'S MORE
         L     R1,AITRCTAB              YES, START OVER AT TOP     LDW1
         ST    R1,ITRAVAL               AND RESET AVAIL POS PTR
MORETAB  MVC   0(3,R1),TTR              MOVE TTR TO TABLE
         MVC   3(2,R1),OLDPOINT         AND OFFSET TOO
         ST    R1,CURRITR               SAVE PTR TO CURR TRACE ENTRY
         LA    R1,5(,R1)                UPDATE AVAIL PTR
         ST    R1,ITRAVAL               SAVE IT
NOTRACIT MVI   TRACE,YESTRACE           MAKE IT TRACE AGAIN
         TM    FLAGS3,NODISPF           DISPLAY SUPPRESSED ?       SDM6
         BO    NOTSHORT                 YES, DON'T FIX STUFF TWICE SDM6
         CLI   LINELEN+1,80             SHORT LINES?               LDW1
         BE    NOTSHORT                 NO, OK AS IS               LDW1
         MVC   LINE01($L-17),LINE01+17  SHIFT INFO LINES OVER      SDM5
         MVC   LINE05($L-17),LINE05+17  SHIFT INFO LINES OVER      LDW1
         MVC   LINE19($L-17),LINE19+17  SHIFT INFO LINES OVER      LDW1
         MVC   LINE20($L-17),LINE20+17  SHIFT INFO LINES OVER      LDW1
         MVC   LINE21($L-17),LINE21+17  SHIFT INFO LINES OVER      LDW1
NOTSHORT TM    FLAGS3,F3270             FULLSCREEN?                LDW5
         BO    CSIO3270                 YES, GO TO HIS STUFF       SDM6
         TM    FLAGS3,NODISPF           DISPLAY SUPPRESSED ?       SDM6
         BO    TGET                     MAKE IT SIMPLE, STUPID     SDM6
         TM    FLAGS3,CRTF              CRT MODE?                  LDW5
         BZ    NOFORMFD                 NO, DON'T CLEAR THE SCREEN LDW1
         TPUTX =X'0C',1,CONTROL         CLEAR THE SCREEN           LDW1
NOFORMFD LA    R6,$I                    BXLE INCR                  LDW1
         LA    R1,LINE05                TPUT I/O ERROR MSG
         BAS   R14,PUTLINE              (IF ANY)                   LDW1
         L     R5,MIDLINE               ADDR OF CARET
         LTR   R5,R5                    ANY CARET (BLK DISPLAY?)
         BNZ   DOWINDOW                 YES, WINDOW SCREEN
         LA    R3,LINE06                NO, FULL SCR, BEGIN
         LA    R5,LINE18                END (BXLE)
         B     DUMPSCR                  DUMP IT
         SPACE 1
*        CREATE TSO SCREEN WINDOW. DEFAULT SIZE IS ONLY CARET LINE.
*        THE 'W' COMMAND CHANGES IT TILL NEXT 'W' COMMAND. LINES
*        ABOVE AND BELOW 'CARET' LINE ARE SPECIFIED. THIS ALLOWS
*        FEWER LINES FOR HARDCOPY TERMINALS. EG :
*        D,U ... U LINES ABOVE, CARET LINE, D LINES BELOW.
*        ,U .... U LINES ABOVE, CARET LINE, PREVIOUS D LINES BELOW.
*        D|D, .. PREVIOUS U LINE ABOVE, CARET LINE, D LINES BELOW.
         SPACE 1
DOWINDOW S     R5,FIRSTSCR              OFFSET TO SCREEN CARET
         XR    R4,R4                    DIVIDE
         DR    R4,R6                    LINE NUMBER CARET
         LR    R3,R5                    SAVE IT
         S     R3,WIDTHU                BACK UP 'U' LINES <UP>
         BNM   *+L'*+2                  SKIP IF OK
         XR    R3,R3                    TOO FAR, MAKE IT TOP OF BUFF
         A     R5,WIDTHD                GO DOWN 'D' LINES <DOWN>
*LDW1    L     R0,MAXWIDTH              MAX LINE NUM
*LDW1    BCTR  R0,0                     -1 FOR OFFSET
         LA    R0,(LINE19-LINE06)/2     GET MAX # OF LINES         LDW1
         CR    R5,R0                    BOTTOM TOO HIGH
         BNH   *+L'*+2                  NO
         LR    R5,R0                    YES, MAKE IT MAX LINE#
         MR    R2,R6                    GET OFFSET TO TOP LINE
         MR    R4,R6                    GET OFFSET TO BOTT LINE
         A     R3,FIRSTSCR              POINT TO TOP
         A     R5,FIRSTSCR              POINT TO BOTTOM
DUMPSCR  LR    R4,R6                    GET LENGTH IN BXLE REG
         SPACE 1
*        R3=BEGIN, R4=LEN, R5=END.
         SPACE 1
TPUTL    LR    R1,R3                    COPY LINE ADDR             LDW1
         BAS   R14,PUTLINE              PRINT IT IF NOT BLANK      LDW1
         BXLE  R3,R4,TPUTL
         LA    R2,LINE19                POSSIBLE MSGS BELOW WINDOW
         LA    R3,3                     3 LINES
TPUTL2   LR    R1,R2                    COPY LINE ADDR             LDW1
         BAS   R14,PUTLINE              PRINT IT IF NOT BLANK      LDW1
         AR    R2,R6                    DO ALL
         BCT   R3,TPUTL2
TGET     MVI   TSECB,0                  RESET ECB                  LDW1
         MVC   PGPB(PGPBDCL),PGPBDC     INIT PARM BLOCK
         NI    FLAGS2,255-ATTNHIT       RESET FLAG                 LDW1
         L     R15,IKJPTGT              ADDR OF LOADED PUTGET
         PUTGET PARM=PGPB,MF=(E,IOPL),ENTRY=(15)
         LA    R14,8                                               LDW1
         CR    R15,R14                                             LDW1
         BL    *+L'*+12 >============+                             LDW1
         BE    TGET                  |  ATTN, TRY AGAIN            LDW1
         EX    0,*                   |                             LDW1
         B     TGET                  |  RESUME IF TEST RESTARTS ME LDW1
         NI    FLAGS3,255-NODISPF <==+  STOP SUPPRESSING DISPLAY   SDM6
         L     R1,PGPBIBUF              POINT TO INPUT LINE
         LH    R15,0(,R1)               GET LENGTH OF BUFFER
         SH    R15,=H'4'                GET LENGTH OF REPLY
         STH   R15,READLEN              SAVE REPLY LNTH
         BZ    TGET1                    IF NO REPLY SKIP MOVE TO REPLY
         CH    R15,=Y($L)               COMPARE WITH MAX           LDW1
         BNH   TGET0                    OK
         LH    R15,=Y($L)               USE MAX                    LDW1
         STH   R15,READLEN              SAVE IT
TGET0    MVC   REP,BLANKS               PRE-BLANK THE BUFFER       LDW5
         BCTR  R15,0                    DECREMENT FOR EXECUTE
         MVC   REP(*-*),4(R1)           EXECUTED
         EX    R15,*-6                  MOVE IN THE REPLY
TGET1    LH    R15,0(,R1)               GET LNTH AGAIN
         LA    R0,1                     GET SP
         SLL   R0,24                    SHIFT INTO PLACE
         AR    R0,R15                   ADD IN LENGTH
         FREEMAIN R,LV=(0),A=(1)
         LH    R1,READLEN               GET REPLY LENGTH
         MVC   LINE19,BLANKS            CLEAR ERROR MSG IF ANY     LDW1
         XC    MIDLINE,MIDLINE          NO CARET LINE NOW
         BR    R8                       YES, PARSE IT
         SPACE 1                                                   LDW3
*        THIS HUNK OF CODE MOVE DOWN HERE                          SDM6
*        FROM SOMEWHERE IN "DISPLAY".                              SDM6
         SPACE 1                                                   LDW3
CSIO3270 TM    FLAGS3,FSMODE            IS FSMODE ON ?             LDW5
         BO    CSIOINIT                 YES, THAT'S GOOD           LDW5
         STFSMODE  ON                   SET 3270 FULLSCREEN MODE   LDW1
         OI    FLAGS3,FSMODE            IT'S ON NOW                LDW5
CSIOINIT MVC   LINE01,BLANKS            CLEAR THE TOPLINE          SDM6
         MVC   LINE01+33(7),=C'Z  A  P' MOVE TOPLINE               SDM5
         LA    R1,REP+$L-1              END OF REPROMPT BUFFER     SDM6
CSIOCLR  CLI   0(R1),C' '               TRAILING BLANK?            SDM5
         BNE   CSIOCLRX                 NO, LEAVE THE LOOP         SDM5
         MVI   0(R1),X'00'              CHANGE TO TRAILING NULL    SDM5
         BCT   R1,CSIOCLR               GO BACK AND CHECK AGAIN    SDM5
CSIOCLRX L     R2,AOLDSCR               -> SAVED LINE1             SDM6
         LA    R4,LINE01-2              -> CURRENT LINE1           SDM6
         TM    FLAGS3,RESHOWF           FULL SCREEN TPUT?          LDW5
         BNO   CSIOCHNG                 NO, PROCESS CHANGED LINES  LDW5
         LA    R3,L'OLDSCR              GET SAVE AREA LENGTH       SDM6
         LR    R5,R3                    COPY LENGTH FOR MVCL       SDM6
         MVCL  R2,R4                    SAVE INITIAL SCREEN IMAGE  SDM6
CSIOFULL LM    R0,R1,REGS3270           GET THE TPUT REGS          SDM5
         B     CSIOTPUT                 GO WRITE THE WHOLE SCREEN  SDM5
CSIOCHNG L     R3,ASCRWORK              -> WORK AREA               SDM5
         MVC   0(L'CTL3270,R3),CTL3270  COPY CONTROL INFO          SDM5
         LA    R3,L'CTL3270(,R3)        BUMP PTR                   SDM5
         XR    R5,R5                    INITIAL SCREEN ADDRESS     SDM5
         MVI   $I+2(R2),X'FE'           FORCE LINE02 MISMATCH      SDM5
         MVI   3*$I+2(R2),X'FE'         FORCE LINE04 MISMATCH      SDM5
         LA    R6,21                    NUMBER OF LINES TO TEST    SDM5
         BAS   R14,CSIOTMOD             GO CHECK ONE               LDW2
         BCT   R6,*-4                   CHECK ALL 21               SDM5
         MVC   0(L'END3270M,R3),END3270M MOVE IN ENDING CTL STUFF  SDM5
         LA    R0,L'END3270M(,R3)       GET END+1 ADDR             SDM5
         L     R1,ASCRWORK              -> START OF WORK AREA      LDW2
         SR    R0,R1                    GET LENGTH TO TPUT         LDW2
         BP    *+8                      CONTINUE IF OK             LDW2
         EX    0,*                      DIE IF LOGIC ERROR         LDW2
         ICM   R1,B'1000',=X'03'        GET FULLSCR TPUT FLAG      LDW2
CSIOTPUT TPUT  (1),(0),R                                           LDW1
         NI    FLAGS3,255-RESHOWF-NODISPF   REFRESH IS DONE        SDM6
         LA    R1,REPX                  BUFFER ADDR                LDW1
         ICM   R1,B'1000',=X'81'        MAKE IT A TGET ASIS        SDM1
         LA    R0,L'REPX                LENGTH OF INPUT BUFFER     LDW1
         TGET  (1),(0),R                                           SDM5
         NI    CTL3270,255-X'04'        CHANGE WCC TO NO ALARM     SDM4
         CLI   REPX,X'7D'               ENTER?                  .AFDSC.
         BE    NOTPFK                   YES, BYPASS PFK         .AFDSC.
         CLI   REPX,X'6E'               PA2?  (RESHOW?)            SDM1
         BE    CSIOFULL                 YES, GO DO IT              SDM6
         OI    REPX,X'30'               PFK 13-24 LIKE 1-12     .AFDSC.
         CLI   REPX,X'F5'               PF5? (L?)               .AFDSC.
         BE    PFKLOC                   YES, GO DO IT           .AFDSC.
         CLI   REPX,X'F8'               PF8? (D?)               .AFDSC.
         BE    PFKDOWN                  YES, GO DO IT           .AFDSC.
         CLI   REPX,X'F7'               PF7? (U?)               .AFDSC.
         BE    PFKUP                    YES, GO DO IT           .AFDSC.
         CLI   REPX,X'F1'               PF1? (H?)                  -EU-
         BE    PFKHELP                  YES, GO DO IT              -EU-
         CLI   REPX,X'F3'               PF3? (END?)             .AFDSC.
         BNE   NOTPFK                   NO                         -EU-
         CLI   REP,C'?'                 YES, BUT WAS IN HELP?      -EU-
         BNE   ENDPFK                   NO, GO DO IT               -EU-
         MVC   REP,BLANKS               YES, CLEAR REMEMBERED INPUT-EU-
         LA    R2,REP                   FORCE NULL INPUT           -EU-
         B     ASIS08                   AND GO BACK                -EU-
NOTPFK   LA    R2,REP                   THIS IS WHERE IT WILL GO   SDM5
         LA    R3,REPX+3                POINT SRC PAST CURSOR ADDR SDM1
         LA    R4,REPX-1(R1)            END OF REPLY DATA          SDM1
         CR    R3,R4                    TOO FAR?                   SDM5
         BH    ASIS08                   YES, NO DATA CAME IN       SDM5
         CLI   0(R3),X'11'              SBA SEQUENCE?              SDM5
         BE    ASIS02                   YES, SCREEN IS FORMATTED   SDM5
         OI    FLAGS3,RESHOWF           NO, FORCE FULL REWRITE     SDM5
ASIS02   CR    R3,R4                    TOO FAR?                   SDM1
         BH    ASIS08                   YES, NO DATA CAME IN       SDM1
         CLI   0(R3),X'11'              SBA SEQUENCE?              SDM5
         BNE   ASIS05                   NO, DON'T WORRY ABOUT IT   SDM5
         CLC   1(2,R3),=X'C1D1'         FIRST LINE INPUT?          SDM5
         BE    ASIS04                   YES, ALL'S COOL SO FAR     SDM5
         CLC   1(2,R3),=X'C3F1'         SECOND LINE INPUT?         SDM5
         BE    ASIS03                   YES, GO CLEAR REP          SDM5
         TPUTX '** SCREEN FORMAT ERROR **'   TOO BAD               SDM1
         B     CSIOFULL                 GIVE HIM BACK WHOLE SCREEN SDM6
ASIS03   MVC   REP,BLANKS               CLEAR REMEMBERED INPUT     SDM5
ASIS04   LA    R3,3(,R3)                SKIP THE SBA SEQUENCE      SDM5
         B     ASIS02                   AND TRY SOME MORE          SDM5
ASIS05   CLI   0(R3),C' '               LEADING BLANK?             SDM5
         BNE   ASIS06                   NO, FOUND DATA             SDM5
         LA    R3,1(,R3)                SKIP THE BLANK             SDM5
         B     ASIS02                   GO LOOK FOR MORE           SDM5
ASIS06   MVC   REP,BLANKS               FORCE CLEAR REPLY          SDM5
ASIS07   CR    R3,R4                    TOO FAR?                   SDM1
         BH    ASIS08                   YES, FILL IT UP NOW        SDM1
         CLI   0(R3),X'11'              SBA?                       SDM1
         BE    ASIS08                   YES, IGNORE THE 2ND LINE   SDM1
         MVC   0(1,R2),0(R3)            MOVE ONE MORE BYTE         SDM1
         LA    R2,1(,R2)                OK, UP THIS ONE            SDM1
         LA    R3,1(,R3)                AND THE FROM POINTER, TOO  SDM1
         B     ASIS07                   CONTINUE THIS TRAVESTY     SDM1
ASIS08   LA    R4,REP                   COMPUTE THE REAL           SDM1
         SR    R2,R4                      LENGTH OF THE REPLY      SDM1
         STH   R2,READLEN                   AND SAVE IT FOR LATER  SDM1
         MVC   LINE19,BLANKS            CLEAR THE ERROR MSG IF ANY LDW1
         BR    R8                       GO PARSE IT                LDW1
CSIOTMOD CLC   0($I,R2),0(R4)           DOES IT MATCH ?            SDM5
         BE    CSIONMOD                 YES, SKIP                  LDW2
         MVI   0(R3),X'11'              SBA                        SDM5
         LR    R0,R5                    COPY ADDRESS               SDM5
         STC   R0,2(,R3)                STORE LOW 8 BITS           SDM5
         NI    2(R3),B'00111111'        MAKE THAT LOW 6 BITS       SDM5
         SRL   R0,6                     DOWNSHIFT                  LDW2
         STC   R0,1(,R3)                STORE SOME MORE BITS       SDM5
         NI    1(R3),B'00111111'        MAKE THAT HIGH 6 BITS      SDM5
         TR    1(2,R3),TR3270           MAKE VALID CHARS           SDM5
         MVC   0($I,R2),0(R4)           UPDATE SAVED SCREEN        SDM5
         MVC   3($I,R3),0(R4)           MOVE IN NEW DATA           SDM5
         LA    R3,$I+3(,R3)             -> NEXT SCRWORK AREA       SDM5
CSIONMOD LA    R2,$I(,R2)               -> NEXT SCREEN LINE        SDM5
         LA    R4,$I(,R4)               -> NEXT SCREEN LINE        SDM5
         LA    R5,$I-1(,R5)             =NEXT SCREEN OFFSET        SDM5
         BR    R14                      RETURN TO ABOVE            LDW2
         SPACE 1
* * * * * * * * CSIO# * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
*        SECONDARY DISPLAY.
*        SHORT SCREEN MSGS.
*              R1 = ADDRESS OF BUFFER (40 BYTES ONLY).
         SPACE 1
CSIO#    MVC   LINEBUFF(40),0(R1)       COPY THE LINE              LDW1
         BAS   R8,KILL3270              TURN OFF 3270 MODE IF ON   LDW1
         NI    FLAGS3,255-F3270         TURN OFF THE FLAG          LDW1
         BAS   R14,PUTLINE$             PUT THE SHORT LINE         LDW1
         B     END                      QUIT THIS CP
         SPACE 1
* * * * * * * * PUTLINE * * * * * * * * * * * * * * * * * * * * *  LDW1
         SPACE 1                                                   LDW1
PUTLINE$ MVC   LINEDESC(4),=H'44,0'                                LDW1
         B     PUTLINEX                                            LDW1
PUTLINE  CLC   0($L,R1),BLANKS          BLANK LINE?                LDW1
         BER   R14                      YES, DON'T TPUT IT         LDW1
         MVC   LINEBUFF($L),0(R1)       COPY OUTPUT LINE           LDW1
         MVC   LINEDESC(4),=Y($L+4,0)   SET DESCRIPTOR WORD        LDW1
PUTLINEX TM    FLAGS2,ATTNHIT           STOP???                    LDW5
         BOR   R14                      YES.                       LDW1
         ST    R14,TERMSAVE             SAVE RETURN ADDR           LDW1
         MVC   PTPB(PTPBDCL),PTPBDC     INIT PARM BLOCK            LDW1
         LA    R0,LINEDESC              POINT TO O.L.D.            LDW1
         ST    R0,PTPB+4                SET ADDR IN PARM BLOCK     LDW1
         L     R15,IKJPUTL                                         LDW1
         MVI   TSECB,0                  RESET ECB                  LDW1
         PUTLINE  PARM=PTPB,MF=(E,IOPL),ENTRY=(15)                 LDW1
         LA    R14,4                                               LDW1
         CR    R15,R14                                             LDW1
         L     R14,TERMSAVE             RESTORE RETURN ADDR        LDW1
         BNHR  R14                                                 LDW1
         EX    0,*                                                 LDW1
         SPACE 1                                                   LDW1
* * * * * * * * TTRPARSE  * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
*        DETERMINES AND VALIDITY CHECKS TTR SPECIFIED.
*              R1 POINTS TO THE TTR.
*              R0 HAS ITS LENGTH.  OUTPUT IS IN TEMP+1(3)
*              OUTPUT IS IN TEMP+1(3).
         SPACE 1
TTRPARSE L     R15,TTR                  GET '*' = CURRENT TTR
         SRL   R15,8                    RIGHT JUSTIFY
         BAS   R8,CALLEXP               GO PARSE                   LDW1
         BNP   TTRLT1                   NOT POSITIVE IS INVALID    LDW1
         ST    R15,TEMP                 SAVE THE VALUE RETURNED    LDW1
         CLI   TEMP+3,0                 REC 0?                     LDW1
         BNZR  R6                       NO, GIVE IT
         LA    R2,REC0INV               YES, TELL HIM
         B     BOTCH                    WITH A MSG
TTRLT1   LA    R2,TTRSMALL              POINT TO ERROR MSG
         B     BOTCH                    DISPLAY ERROR STYLE
         SPACE 1
* * * * * * * * PREPDUMP  * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
*        THIS ROUTINE IS THE 'PREPROCESSOR' TO THE DUMPER. IT GETS
*        THE BLOCK TO BE DUMPED, PREPARES AND WRITES OUT THE BLOCK
*        HEADER LINE (WITH TTR, LENGTH, AND CCHHR), AND IF THERE IS
*        AN EOF OR I/O ERROR AT THE BLOCK, AND MESSAGE IS PUT OUT TO
*        THE RECORDING FILE AND THE 'BLOCK' IS NOT DUMPED.
*        RETURNS : 0(R6) - NORMAL RETURN WITH DUMP OF BLOCK TO FOLLOW.
*                  4(R6) - I/O ERROR OR EOF, RETURN WITH NO DUMP, OR
*                          EXIT FROM ENTIRE DUMPING LOOP IF I/O ERROR
*                          WAS 'OUT OF DATASET', MEANING THERE IS NO
*                          MORE DATA-SET, NO MORE EXTENT.
         SPACE 1
PREPDUMP MVI   EOFRET,NOEOF             SAY ALSO EOF'S ARE DATA BLOCKS
         BAS   R8,READBLK               GET THE BLOCK, SUCH AS IT IS
PREPDMPX TM    FLAGS2,LOGF              ARE WE LOGGING
         BNO   NEWDSPNT                 IF NOT FORGET THIS
         L     R2,CSOUTWK               POINT TO THE OUTPUT WORKAREA
         LTR   R2,R2                    IS THERE ONE?
         BZ    NEWDSPNT                 NO, FORGET THIS WHOLE THING
         L     R2,0(R2)                 GET ADDR IN REG
         MVC   1+0(40,R2),=C'LENGTH=XXXXX TTR=XXXXXX CCHHR=XXXXXXXXXX'
         LH    R1,BLKLEN                GET THE LENGTH OF THE BLK
         CVD   R1,TEMP                  PACKED DEC
         UNPK  1+7(5,R2),TEMP+5(3)      PUT LENGTH INTO MSG
         OI    1+11(R2),X'F0'           FIX FLIP BYTE
         HEX   (1+17,R2),TTR,LEN=3      CONVERT TTR                LDW1
         HEX   (1+30,R2),CCHHR,LEN=5    CONVERT CCHHR              LDW1
         MVI   0(R2),C'-'               TRIPLE SPACE BEFORE HDR PRINTED
         MVI   ENQIT,255                FORCE ENQ TO PRINT
         BAS   R8,CPUT#                 PUT OUT THE LINE
         CLI   IOERROR,YESSYN           I/O ERROR IN READ BEFORE?
         BE    OOPSDUMP                 YES, DON'T DUMP, JUST MSG
         CLC   LINE05+27(20),EOFMSG     NO, BUT WAS THERE AN EOF?  LDW1
         BNER  R6                       NO, RETURN NORMALLY AND DUMP
         SPACE 1
*        EITHER THE BLOCK HAS AN I/O ERROR WAS AN END-OF-FILE,
*        SO WE CANNOT DUMP. INSTEAD, PRINT OUT, IF POSSIBLE, THE
*        TYPE OF CONDITION WHICH HAS OCCURRED, AND RETURN BEYOND
*        DUMP CODE - 4(R6). IF THE I/O ERROR 'NOT IN DATA-SET' HAS
*        OCCURRED, THEN STOP THE PROCESS ALL TOGETHER. WE ARE AT
*        THE REAL END OF THE DATA-SET.
         SPACE 1
OOPSDUMP TM    FLAGS2,LOGF              ARE WE LOGGING      %%NEED%%
         BNO   NEWDSPNT                 IF NOT FORGET IT    %%THIS?%%
         L     R2,CSOUTWK               PT TO OUTPUT BUFFER PTR
         LTR   R2,R2                    AHA, IS THERE ONE, HE ASKS
         BZ    NEWDSPNT                 NOPE, TOUGH LUCK, FELLA
         L     R2,0(R2)                 GET ADDR OF BUFFER
         MVC   1+0(40,R2),LINE05+17     COPY EXACTLY WHAT IS ON THE SCR
         MVI   0(R2),C' '               CARRIAGE CONTROL
         MVI   ENQIT,255                FORCE ENQ
         BAS   R8,CPUT#                 WRITE IT OUT
         CLC   LINE05+35(15),=CL15'NOT IN DATA-SET'   END OF EXTENT?
         BE    NEW$DISP                 YES, GET OUT OF LOOP AND DISP
         CLC   LINE05+27(20),EOFMSG     WAS IT EOF?                LDW1
         BE    NEW$DISP                 YES, GET OUT AND DISPLAY LOC
         B     4(R6)                    NO, BUT DON'T DUMP THIS 'BLK'
         SPACE 1
* * * * * * * * DUMPER  * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
*        THIS ROUTINE DUMPS ANY SIZE BLOCK WHICH IS IN THE BUFFER TO
*        THE OUTPUT RECORDING FILE. THE HEX OFFSETS, THE ACTUAL HEX
*        DATA, AND THE TRANSLATION OF THAT DATA IS PRINTED OUT.
*        NOTE : (1) GARBAGE DATA IS NOT PRINTED.  THAT IS, DATA IS
*                   DISPLAYED ONLY UP TO THE LAST BYTE, AND NO FARTHER.
*               (2) TRANSLATED DATA IS EITHER IN EBCDIC OR IN ASCII
*                   TRANSLATION, DEPENDING ON WHICH COMMAND IS IN
*                   EFFECT AT THE TIME OF THE DUMP, 'EBCDIC' OR
*                   'ASCII'.
*               (3) THE 'PREPROCESSOR' ROUTINE 'PREPDUMP' MUST BE
*                   CALLED FIRST TO GET THE BLOCK, WRITE OUT THE BLOCK
*                   HEADER LINE, AND TO CHECK FOR SYNAD AND EODAD
*                   ON THE BLOCK.
         SPACE 1
DUMPER   L     R3,ADDRBUFF              PT TO INPUT BUFFER (THE BLOCK)
         ST    R6,TEMP2+20              SAVE RETURN BAS ADDR
         XR    R4,R4                    CLEAR REM REG FOR DIVIDE
         LH    R5,BLKLEN                GET LEN OF BLK
         D     R4,=F'32'                HOW MANY 4 DBLW LINES IN BLK
         SPACE 1
*        R4 HAS THE LENGTH OF THE OFLO 'SHORT' LINE. R5 HAS THE
*        NUMBER OF LINES TO DUMP OUT (THE NUMBER OR 1 SHORT).
         SPACE 1
         LTR   R4,R4                    IS THERE A SHORT LAST LINE?
         BZ    *+L'*+4                  NO, HAVE NUMBER OF LINES NOW
         LA    R5,1(R5)                 YES, CORRECT NUM OF LINES
         XC    TEMP(4),TEMP             INITIALIZE OFFSET COUNTER
DMPFMTLP TM    FLAGS2,LOGF              ARE WE LOGGING
         BNO   BADCSOUT
         L     R2,CSOUTWK               PT TO CSOUT OUTPUT BUFFER
         LTR   R2,R2                    IS THERE ONE?
         BZ    BADCSOUT                 NO, TELL HIM UNABLE TO RECORD
         L     R2,0(,R2)                YES, PICK UP BUFFER PTR
         MVI   0(R2),C' '               CARRIAGE CONTROL
         HEX   (1+0,R2),TEMP+1,LEN=3    GET OFFSET                 LDW1
         MVC   1+91(32,R2),0(R3)        MOVE DATA TO DUMP SECTION
         L     R15,TRTABADD             PICK UP CURRENT TRANSLATE TAB
         TR    1+91(32,R2),0(R15)       TRANSLATE IT IN PLACE
         MVI   1+90(R2),C'*'            MOVE IN DELIMITER
         MVI   1+123(R2),C'*'           MOVE IN DELIMITER
         SPACE 1
*        FORMAT THE LINE.
*        THE LINE IS COMPOSED OF 4 COMPLETE DOUBLE-WORDS. EACH
*        DOUBLE-WORD IS FORMATTED INTO FULLWORDS SEPARATED BY A BLANK,
*        AND EACH PAIR OF DOUBLE-WORDS IS SEPARATED BY 3 BLANKS. THUS
*        DUMPER LOOPS TWICE A LOOP OF 4 PASSES, ONE PER FULLWORD.
         SPACE 1
         LA    R14,1+9(R2)              POINT TO 1ST AVAIL LINE POS
         LA    R6,2                     BCT OUTER LOOP (2 PAIRS DBLW'S)
LINELP1  LA    R4,4                     BCT INNER LOOP (4 FULLWORDS)
LINELP2  HEX   (0,R14),(0,R3),LEN=4     GET ONE FULLWORD           LDW1
         LA    R3,4(,R3)                UPDATE INPUT BUFFER PTR
         LA    R14,9(,R14)              UPDATE OUTPUT LINE PTR
         BCT   R4,LINELP2               DO IT FOR 4 FULLWORDS
         LA    R14,3(,R14)              FOR NEXT PAIR OF DBLW'S, SPACE
         BCT   R6,LINELP1               DO IT FOR 2 PAIRS OF DBLW'S
         MVI   ENQIT,255                FORCE ENQ TO PRINT
         CH    R5,=H'1'                 LAST LINE NOW?
         BE    LASTLINE                 YES, CHECK FOR SHORT LAST LINE
         L     R15,TEMP                 NO, UPDATE OFFSET BY GETTING
         LA    R15,X'20'(R15)           IT IN THE REG, ADDING INCR,
         ST    R15,TEMP                 AND PUTTING IT BACK
         BAS   R8,CPUT#                 WRITE IT OUT
         BCT   R5,DMPFMTLP              DO ALL THE LINES EXCEPT LAST
         SPACE 1
*        LAST LINE ROUTINE.
*        IF THE LINE IS A SHORT LAST LINE, ONLY WRITE OUT
*        THE CORRECT AMOUNT OF DATA.
         SPACE 1
LASTLINE LH    R1,BLKLEN                GET LEN OF BLK
         N     R1,=F'31'                TURN OFF ALL BUT LOW ORDR BITS
         LTR   R1,R1                    ARE THERE ANY LOW ORDER BITS?
         BZ    BYELAST                  NO, FULL LAST LINE, DUMP IT
         SPACE 1
*        GET RID OF THE JUNK IN THE DUMP (TRANSLATED) PART FIRST.
         SPACE 1
         LA    R14,32-1-1               MAX WIDTH -1 FOR MVI -1 EX LEN
         SR    R14,R1                   GET LEN OF JUNK
         LA    R3,1+91(R2,R1)           POINT TO BEGINNING OF JUNK
         MVI   0(R3),C' '               KILL THE FIRST BYTE
         LTR   R14,R14                  ANY MORE STUFF TO BLANK?
         BM    *+L'*+4                  NO, GO ON AND FIX THE LINE NOW
         EX    R14,DMPBKMVC             KILL THAT JUNK
         XR    R0,R0                    CLEAR REM REG FOR DIVIDE
         D     R0,=F'4'                 HOW MANY FLWRD GRPS ARE THERE?
         SPACE 1
*        R0 HAS SLOPOVER WITHIN 1 FULLWORD, R1 HAS NUMBER
*        OF FULLWORDS ON THE LAST LINE.
         SPACE 1
         LA    R4,DUMPOFFS(R1)          POIN TO THE TAB TABLE OFFSET
         XR    R3,R3                    CLEAR REG FOR IC
         IC    R3,0(R4)                 GET THE TAB TO THE COLUMN
         SLL   R0,1                     *2 SLOPOVER FOR CHARACTER BYTES
         AR    R3,R0                    OFFSET TO FIRST GARBAGE CHAR
         LA    R4,86-1                  GET MAX LEN  OF LINE (-1 MVI)
         SR    R4,R3                    GET LEN OF GARBAGE TO BLANK
         LA    R3,1(R3,R2)              POINT TO 1ST GARBAGE BYTE
         MVI   0(R3),C' '               BLANK OUT AT LEAST ONE
         BCTR  R4,0                     GET EXECUTE LEN
         LTR   R4,R4                    IS THERE ANY MORE TO GET RID OF
         BM    BYELAST                  NO, GOOD BYE LAST LINE
DMPBKMVC MVC   1(0,R3),0(R3)            << EXECUTED >>
         EX    R4,DMPBKMVC              GET RID OF THE REST
BYELAST  BAS   R8,CPUT#                 WRITE OUT LAST LINE
         L     R6,TEMP2+20              RESTORE RET ADDR
         BR    R6                       RETURN TO CALLER
         SPACE 1
* * * * * * * * CLEARDEF  * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
*        RESET AND/OR INITIALIZE THE DEFINE TABLE.
         SPACE 1
CLEARDEF L     R2,AIDEFTAB              PT TO BEGINNING OF TABLE   LDW1
         ST    R2,IDEFAVAL              MAKE THAT THE 1ST AVAIL POSIT
         MVC   0(240,R2),BLANKS         CLEAR OUT THE TABLE ALSO   LDW1
         BR    R8                       RET TO CALLER
         SPACE 1
* * * * * * * * CLOSE * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
*        CLOSE THE DATA-SET.
         SPACE 1
CLOSE    TM    DCBU+48,X'10'            IS IT OPEN?
         BNOR  R8                       NO, WHY CLOSE THEN?
         CLOSE MF=(E,DCBLIST)           GOODBYE DATASET
         BR    R8                       RET TO CALLER
         SPACE 1
* * * * * * * * WRITE * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
WRITE    LA    R14,CCW##W               -> CCW CHAIN               LDW1
WRITE$GO ST    R14,IOBCCWA              SET IN IOB                 LDW1
         EXCP  IOB                                                 LDW1
         WAIT  ECB=ECB                                             LDW1
         CLI   ECB,X'7F'                                           LDW1
         BER   R8                                                  LDW1
         B     REALERR                                             LDW1
         SPACE 1
* * * * * * * * OPENMSG * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
*        IF WE MUST OPEN A DATA SET, CREATE A MESSAGE ABOUT IT.
         SPACE 1
LOGTEST  TM    FLAGS2,LOGF              ALREADY LOGGING?           LDW1
         BOR   R8                       YES, ALL DONE              LDW1
OPENOUT  ST    R8,DBLW                  SAVE FOR LATER
         L     R1,CSOUTWK               FIND CSOUT'S WORKAREA
         LTR   R1,R1                    ANY WORKAREA?
         BZR   R8                       NO, EXIT NOW
         OI    FLAGS2,LOGF              WE ARE NOW LOGGING         LDW1
*LDW1    CSOUT OPN,=CL6'SYSDA3',=H'10',CALL=CALL,MF=(E,(1))  (10,10)
         MVI   0(R1),X'80'          (+) FLAG AS OPEN CALL
*LDW1    LA    0,=CL6'SYSDA3'       (+)
*LDW1    ST    0,4(,R1)             (+) STORE FIRST PARM
*LDW1    LA    R0,=H'10'            (+)
*LDW1    ST    R0,8(,R1)            (+) STORE SECOND PARM
         LR    R2,R1                (+) COPY WORKAREA PTR
         L     R15,=V(CSOUT)        (+) POINT TO ROUTINE
         LR    R1,CSREG             (+) GET CSAREA PTR
         BASR  R14,R15              (+) CALL IT
         LTR   R0,R0                    ERROR?
         BZ    SAYOPEN                  NO
         NI    FLAGS2,255-LOGF          TURN OFF FLAG              LDW1
         LA    R1,=CL40'UNABLE TO ALLOCATE PRINT FILE'             LDW1
         BAS   R8,CSIO#                 DISPLAY IT
***  CSIO# DOESN'T RETURN ??????                                   LDW1
         XC    CSOUTWK,CSOUTWK (NOOUT)  NO MORE TRIES AT IT
         B     LOCRET                   RETURN TO CALLER
SAYOPEN  MVI   ENQIT,0                  MAYBE
         MVI   CHNGED,0                 VIRGIN BUFFER
         L     R1,CSOUTWK               POINT TO WORK AREA
OPENMSG  L     R1,0(R1)                 FIND LINE TO USE
         L     R15,=A(OPNMSG)           ADDRESSIBILITY
         MVC   0(OPNMSGL,R1),0(R15)
         CLI   DSNAME,X'04'             VTOC?
         BNE   *+L'*+4                  NO, INFORMATION ONLY
         MVI   7(R1),C'A'      (ACTION) MAKE OPR SIT UP AND TAKE NOTICE
*LDW4    MVC   9(6,R1),CSJOBNO (INFORM) CHARGE NUMBER...
*LDW4    MVC   16(3,R1),CSINIT          INITIALS
         MVC   9(L'USERID,R1),USERID    CULPRIT                    LDW4
         TM    DCBLIST,X'0F'            NOW, WAS IT OPEN FOR INPUT?
         BZ    DSNWTO                   YES, SO THERE'S NOTHING TO DO
         MVI   7(R1),C'A'               IF UPDATING, ACTION MSG
         MVC   35(6,R1),=CL6'UPDATE'    AND SAY UPDATE
DSNWTO   CLI   DSNAME,X'04'             VTOC HERE?
         MVC   42(44,R1),DISPDSN        MOVE IN DISPLAYABLE DSN    LDW1
         BE    WTOIT                    YES, VOLSER ALREADY SET   LDW1
         MVC   87(2,R1),=C'ON'          ADD                       *LPR*
         MVC   90(6,R1),VOLSER            VOLSER                  *LPR*
WTOIT    BAS   R8,CPUT                  DUMP THE LINE
LOCRET   L     R8,DBLW                  PICK UP RET ADDR
         BR    R8                       ALL OK - RETURN NORMALLY
         SPACE 1
* * * * * * * * CPUT  * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
*        PASS A LINE TO THE RECORDING SUBROUTINE.
*        ENTRY CPUT IS ENQUEUE TO PRINT WITH POSSIBLE WTO'S.
*        ENTRY CPUT# IS ENQUEUE BUT WITH NO WTO'S (FOR DUMP COMMANDS).
         SPACE 1
CPUT     TM    FLAGS2,LOGF              SEE IF LOGGING
         BNOR  R8                       IF NOT RETURN TO CALLER
         L     R2,CSOUTWK               GET WA ADDR
         LTR   R2,R2                    ANY THERE?
         BZR   R8                       NO, EXIT NOW
         MVI   0(R2),X'20'              SET INITIAL VALUE (WTO)
         TM    FLAGS2,SENSF             IS DS SYS OR URSA?
         BNO   CPUT#                    IF NOT NO WTO
         TM    GODFLAG,GOD              CAN HE EVER UPDATE?        LDW1
         BO    ISWTOCPT                 YES, DO THE WTO            LDW1
*    IF HE CAN NEVER UPDATE, DON'T WTO (USER LOOKING AT SYS1. DS). LDW1
CPUT#    L     R2,CSOUTWK               DUMP ENTRY - GET WORKAREA PTR
         MVI   0(R2),0                  DON'T ISSUE WTO
ISWTOCPT CLI   CPUTFLAG,YESCSERR        WAS THERE A CSOUT ENQ ERROR?
         BER   R8                       YES, ACT LIKE I ENQUEUED IT
CPUTRUNC LR    R1,CSREG                 GET CSAREA PTR             LDW1
         L     R15,=V(CSOUT)            FIND SUBROUTINE
         BASR  R14,R15                  CALL IT
         LTR   R0,R0                    DID IT WORK?
         BZR   R8                       YES, RETURN TO CALLER
         MVI   CPUTFLAG,YESCSERR        RECORD THAT THERE WAS AN ERROR
         B     BADCSOUT                 AND TELL THE USER OF HIS FATE
         SPACE 1
* * * * * * * * SETLINE * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
*        SET UP LINE FOR CPUT.
*        INPUT : R1 POINTS TO SINGLE MESSAGE NUMBER IN CHAR FORM.
*                R8 RETURN ADDRESS IF NOT PRINTING, +4 IF PRINTING.
*        OUTPT : R2 POINTS TO LINE.
         SPACE 1
SETLINE  TM    FLAGS2,LOGF              ARE WE LOGGING?
         BNOR  R8                       IF NOT RETURN
         L     R2,CSOUTWK               FIND WORKAREA
         LTR   R2,R2                    ANY THERE?
         BZR   R8                       NO, EXIT ERROR
         L     R2,0(,R2)                FIND THE LINE
         MVC   1(7,R2),=C'ZAP01XI'      MOVE IN MESSAGE NUMBER     LDW4
         MVC   6(1,R2),0(R1)            COPY CORRECT DIGIT
*LDW4    MVC   9(6,R2),CSJOBNO          FIRST PART OF JOBNO
*LDW4    MVC   15(08,R2),=C',XXX TTR'   REST OF MASK
*LDW4    MVC   16(3,R2),CSINIT          INITIALS
         MVC   9(L'USERID,R2),USERID    CULPRIT                    LDW4
         MVC   9+L'USERID+1(3,R2),=C'TTR'                          LDW4
         HEX   (24,R2),TTR,LEN=3        GET THIS TTR               LDW1
         B     4(R8)                    NOW RETURN TO CALLER
         SPACE 1
* * * * * * * * SETSTRNG  * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
*        CONVERT STRING FOR CPUTING.
*        INPUT : R1 POINTER TO OUTPUT LINE.
*                R8 RETURN ADDRESS.
*                R4 EXECUTE LENGTH OF STRING.
*                R5 ADDRESS OF DATA TO BE CONVERTED.
         SPACE 1
SETSTRNG UNPK  12(9,R13),0(5,R5)        CONVERT FIRST WORD
         UNPK  20(9,R13),4(5,R5)        CONVERT SECOND
         UNPK  28(9,R13),8(5,R5)        CONVERT THIRD
         UNPK  36(9,R13),12(5,R5)       CONVERT FOURTH AND LAST
         TR    12(32,R13),TRHEX         FIX UP HEX
         LTR   R4,R4                    ANY?
         BMR   R8                       NO, LEAVE IT BLANK
         LA    R15,1(R4,R4)             GET EXECUTE LENGTH OF HEX
         EX    R15,CPMVC                MOVE CONVERTED DATA
         MVI   35(R1),C''''                                        LDW1
         EX    R4,SETSTRMV              MOVE CHAR FORM TO BUFFER   LDW1
         L     R15,TRTABADD             GET RIGHT TRTAB PTR        LDW1
         EX    R4,SETSTRTR              TRANSLATE TO RIGHT CHARSET LDW1
         LA    R15,36+1(R4,R1)                                     LDW1
         MVI   0(R15),C''''                                        LDW1
         BR    R8                       RETURN
CPMVC    MVC   0(0,R1),12(R13)          << EXECUTED >>
SETSTRMV MVC   36(0,R1),0(R5)           << EXECUTED >>             LDW1
SETSTRTR TR    36(0,R1),0(R15)          << EXECUTED >>             LDW1
         SPACE 1
* * * * * * * * SETMSG  * * * * * * * * * * * * * * * * * * * * *  LDW1
         SPACE 1
*        MOVE MSG AND HYPHENS TO CORRECT POS ON SCREEN,            LDW1
*        DEPENDING ON WHETHER IN FULLSCREEN MODE.                  LDW1
*        INPUT : R1 POINTS TO CL20'MSG'.                           LDW1
         SPACE 1
SETMSG   LH    R1,0(,R8)                GET MSG OFFSET             LDW1
         AR    R1,R12                   GET ADDR                   LDW1
SETMSGX  TM    FLAGS3,F3270             FULLSCREEN?                LDW5
         BZ    SETMSG1                  NO, SHORTER MSG            LDW3
         MVC   LINE19+27(20),0(R1)      MOVE IT TO CENTER          LDW1
         MVC   LINE19+17(9),=9C'='      MAKE IT FANCY              LDW1
         MVC   LINE19+48(9),=9C'='      BUT DON'T GET CARRIED AWAY LDW1
         B     2(,R8)                   RETURN PAST OFFSET         LDW1
SETMSG1  MVC   LINE19+23(20),0(R1)      MOVE IT TO LEFT OF CENTER  LDW1
         MVC   LINE19+17(3),=9C'='      MAKE IT FANCY              LDW1
         B     2(,R8)                   RETURN PAST OFFSET         LDW1
         SPACE 1
* * * * * * * * BOTCH * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
*        DISPLAY ERROR MESSAGES.
*        MOVE IN MSG AND HYPHENS AROUND IT TO ERROR MSG LINE ON
*        SCREEN. TRACE WILL BE DISABLED. IF SYNTAX ERROR MSG IS
*        TO BE DISPLAYED, THE COLUMN IN QUESTION IS COMPUTED AND
*        DISPLAYED WITH THE MSG.
*              R2 = PTR TO MESSAGE.
*              R1 = PTR TO INVALID LOC IN EXPRESSION (IF APPLICABLE).
         SPACE 1
BOTCH    XR    R15,R15                  CLEAR R15
         IC    R15,0(,R2)               GET LENGTH
         CH    R15,=H'20'               SEE IF WE ARE USING MSG
         BH    BOTCH0                   IF NOT ASSUME LNTH 20
         MVC   TEMP2(20),BLANKS         CLEAR AN AREA              LDW1
         BCTR  R15,0                    DECREMENT FOR EXECUTE
         MVC   TEMP2(0),1(R2)           << EXECUTED >>             LDW1
         EX    R15,*-6                  MOVE IN MSG
         LA    R2,TEMP2                 POINT TO MSG               LDW1
         CLC   INVEXP+1(16),TEMP2       IS THIS AN INV EXPR MSG?   LDW1
         BNE   BOTCH0                   NO, GO ON                  LDW1
         LA    R3,TEMP2                 PT TO REPLY            -EU-LDW1
         CLR   R3,R1                    IS THIS AREA USED FOR SCAN?-EU-
         BNH   *+L'*+4                  YES                        -EU-
         LA    R3,REP                   NO, PT TO REPLY        -EU-LDW1
         SR    R1,R3                    GET OFFSET TO BAD HEX
         LA    R1,1(R1)                 MAKE THE OFFSET A COLUMN #
         CVD   R1,TEMP                  YES, GET OFFSET OF ERROR INTO
         UNPK  TEMP2+18(2),TEMP+6(2)    THE EXPRESSION AND         LDW1
         OI    TEMP2+19,C'0'            MOVE IT TO THE SCREEN      LDW1
         BCTR  R1,0                     GET CURSOR POSITION        LDW1
         STH   R1,CURPOS                SET IT                     LDW1
BOTCH0   LR    R1,R2                    GET MSG ADDR               LDW1
         LA    R8,NEWDSPNT-2            FAKE THE RETURN POINT      LDW1
         B     SETMSGX                  SPECIAL ENTRY PT           LDW1
         SPACE 1
* * * * * * * * EODAD * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
*        END-OF-FILE ROUTINE.                                      LDW1
*        IF EOF'S ARE NOT COUNTED AS BLOCKS (AS IN A PDS),
*        THEN DISPLAY END OF FILE. OTHERWISE HOP THEM.
         SPACE 1
EODAD    LR    R2,R8                    SAVE RET TO READ           LDW1
         BAS   R8,CLEAR                 CLEAR SCREEN
         MVC   LINE05,BLANKS            CLR TOP ERR MSG SO CAN SAY EOF
*        LENGTH OF EOF RECORD IS ALREADY SET.                      LDW1
         MVC   LINE05+27(20),EOFMSG     TELL HIM END-OF-FILE       LDW1
         MVI   TTR+3,NOSEQRD            TURN OFF SEQ READ          LDW1
         CLI   EOFRET,YESEOF            EOF ALLOWED HERE?
         BE    NEW$DISP                 YES, SO EOF ALREADY        LDW1
         BR    R2                       NO, EXIT FROM READBLK (EOF)
*        THUS UNDER CERTAIN CIRCUMSTANCES EOF'S ARE COUNTED AS RECORDS.
         SPACE 1
* * * * * * * * CHKPT * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
CHKPT    TM    FLAGS2,MUSTZAP           BLOCK NEED A ZAP 1ST?
         BNOR  R8                       NO, LET COMMAND THRU
*LDW1    NI    FLAGS2,255-MUSTZAP       YES, WE TOLD HIM ONCE
*LDW1    LA    R2,=CL20'**** ZAP NEEDED ****' TELL HIM, IGNORE COMMAND
*LDW1    B     BOTCH                    HE CAN ALWAYS DO IT AGAIN
         CLC   REP,PREVREP              SAME CMD TWICE IN A ROW?   LDW4
         BER   R8                       YES, LET HIM DO IT         LDW4
         MVC   LINE19+11(58),=C'******** ENTER "ZAP" OR RE-ENTER PREVIO$
               US COMMAND ********'                                LDW4
         B     NEWDSPNT                 TELL HIM HE CAN'T LEAVE    LDW1
         SPACE 1
* * * * * * * * KILL3270  * * * * * * * * * * * * * * * * * * * *  LDW1
         SPACE 1
KILL3270 TM    FLAGS3,FSMODE            FULL SCREEN MODE ON?       LDW5
         BNOR  R8                       NO, JUST RETURN            LDW1
         TPUT  CLR3270,CLR3270L,FULLSCR      CLEAR SCREEN          SDM5
         STFSMODE  OFF                  TURN OFF FULLSCREEN MODE   LDW1
         NI    FLAGS3,255-FSMODE        IT'S OFF NOW               LDW5
         BR    R8                       RETURN TO CALLER           LDW1
         SPACE 1                                                   -EU-
* * * * * * * * STRCNV  * * * * * * * * * * * * * * * * * * * * *  -EU-
*        STRING CONVERSION ROUTINE.                                -EU-
*              R8 = RETURN ADDRESS (LINK REGISTER).                -EU-
*              R14 = STRING ADDRESS.                               -EU-
         SPACE 1                                                   -EU-
STRCNV   LH    R1,0(R14)                GET STRING LENGTH          -EU-
         EX    R1,STRCNVM               TARGET OUTPUT STRING       -EU-
         ICM   R15,B'1111',TRTXTAB                                 -EU-
         BZR   R8                                                  -EU-
         EX    R1,STRCNVT               TRANSLATE STRING           -EU-
         BR    R8                       RETURN TO CALLER           -EU-
STRCNVM  MVC   WKSTR(*-*),2(R14)        <<EXECUTED>>               -EU-
STRCNVT  TR    WKSTR(*-*),0(R15)        <<EXECUTED>>               -EU-
         EJECT
*        ZAP --- CONSTANTS, DATA, FLAGS, ETC.
         SPACE 1
*%       PRINT NOGEN                                               LDW1
IOERRMSG DC    CL40' ***** I/O ERROR: XXXXXXXXXXXXXXX *****'
INVMEM   DC    CL20'MEMBER NOT FOUND'
WRITERR  MSG   'WRITE NOT ALLOWED'
EOFMSG   DC    CL20'*** END OF FILE ***'
CONMSG   MSG   '<STR> CAPS ON'                                     -EU-
COFFMSG  MSG   '<STR> CAPS OFF'                                    -EU-
ASCIIMSG MSG   'ASCII TRANSLATION'
ZCODEMSG MSG   'ZCODE TRANSLATION'
EBCDCMSG MSG   'EBCDIC TRANSLATION'
INVFMSG  MSG   'NO FORWARD CHAIN'
INVBMSG  MSG   'NO BACKWARD CHAIN'
INVEXP   MSG   'SYNTAX ERROR COL. '                                LDW1
LINMSG   MSG   'SCAN NOT IN EFFECT'
TABFULL  MSG   'DEFINE TABLE FULL'
REDEFMSG MSG   'SYMBOL REDEFINED'
LASTINV  MSG   'INVALID IN VTOC'
NOTVTOC  MSG   'DATASET NOT VTOC'                                  LDW1
DEFRESET MSG   'DEFINE TABLE RESET'
REC0INV  MSG   'RECORD 0 INVALID'
INVCOM   MSG   'INVALID COMMAND'
NOMCOM   MSG   'NOT PARTITIONED'
INVOPCOD MSG   'INVALID OP CODE '
INVDEC   MSG   'INVALID DECIMAL'
TTRSMALL MSG   'TTR < 000001 INVALID'                          -EU-LDW1
LENERR   MSG   'LENGTH INVALID'
NOTJQMSG MSG   'DATA SET NOT JOBQ'
STORMSG  DC    CL20'NOTE: NOT UPDATING'
BACKDUMP MSG   'REVERSE DUMP INVALID'                          -EU-LDW1
NOCSOUT  MSG   '  UNABLE TO RECORD'
DUMPWORK MSG   '  DUMP SUCCESSFUL'
NAMEMNF  MSG   'NAME INVALID'                                   *N*
LOGONMSG MSG   'LOGGING'                                           LDW1
NOMEMFND DC    CL20'*NO DIRECTORY ENTRY*'                          LDW1
BADEQUAL MSG   'INVALID SYMBOL'                                    LDW1
OUCH     MSG   'OUCH!!'                                            LDW1
         PRINT GEN                                                 LDW3
         SPACE 2
*        LITERAL POOL.
         SPACE 1
         LTORG
         EJECT
*        TABLE TO GENERATE VALID 3270 CHARS FROM 6 BIT CODELDW2.
         SPACE 1
TR3270   DC    X'40C1C2C3C4C5C6C7C8C94A4B4C4D4E4F'                 LDW2
         DC    X'50D1D2D3D4D5D6D7D8D95A5B5C5D5E5F'                 LDW2
         DC    X'6061E2E3E4E5E6E7E8E96A6B6C6D6E6F'                 LDW2
         DC    X'F0F1F2F3F4F5F6F7F8F97A7B7C7D7E7F'                 LDW2
         SPACE 2
*        HEX TO CHAR HEX AND CHAR TO HEX TRTAB.
         SPACE 1
         DC    X'0A0B0C0D0E0F'          FOR CHAR TO HEX            LDW1
         DC    41C'.'                   WASTED SPACE               LDW1
NUMBERS  DC    C'0123456789ABCDEF'
TRHEX    EQU   *-256
N0       EQU   NUMBERS+0
N1       EQU   NUMBERS+1
N2       EQU   NUMBERS+2
N3       EQU   NUMBERS+3
N4       EQU   NUMBERS+4
N5       EQU   NUMBERS+5
N6       EQU   NUMBERS+6
N7       EQU   NUMBERS+7
N8       EQU   NUMBERS+8
N9       EQU   NUMBERS+9
         SPACE 1                                                   MAS2
EDMASK   DC    X'402020202020202020202120'
         SPACE 1
DUMPOFFS DC    AL1(9,18,27,36,48,57,66,75)
         SPACE 1
MAXWIDTH DC    A((LINE19-LINE06-$I)/$I/2)                          LDW1
         SPACE 1
RECFMU   EQU   X'C0'                    RECFM=U
         SPACE 1
YESSYMB  EQU   X'FF'                    EXP LOOK AT SYMBOL TAB
NOSYMB   EQU   X'00'                    EXP LOOK AT SYMBOL TAB
         SPACE 1
YESTRACE EQU   X'00'                    TRACE IN EFFECT
NOTRACE  EQU   X'FF'                    NO TRACE
         SPACE 1
YESCONTL EQU   X'80'                    SCAN CONTINUE IS OK
YESCONTS EQU   X'40'                    S,X,O,N NO OPERANDS OK
YESCONTT EQU   X'20'                    SET NO OPERAND OK
         SPACE 1
YESSYN   EQU   X'FF'                    SYNAD I/O ERROR HAS OCCURRED
NOSYN    EQU   X'00'                    NO ERROR HAS OCCURRED
         SPACE 1
YESCSERR EQU   X'FF'                    CSOUT CANNOT ENQ IN THIS DS
NOCSERR  EQU   X'00'                    CSOUT HAS NO PROBLEMS
         SPACE 1
*GOD     EQU   X'FF'                    ONLY HE CAN CHANGE HIS MIND
*NOGOD   EQU   X'00'                    TOUGH BANANAS
GOD      EQU   X'01'                    ONLY HE CAN CHANGE HIS MIND-EU-
GODAUTH  EQU   X'02'                    SENSITIVE DATA-SET AUTH.   -EU-
GODALL   EQU   X'04'                    DATA-SET IS ALLOCATED      -EU-
         SPACE 1                                                   -EU-
YESCAPS  EQU   X'FF'                    CAPS ON                    -EU-
NOCAPS   EQU   X'00'                    CAPS OFF                   -EU-
         SPACE 1
YESEOF   EQU   X'FF'                    DO NOT IGNORE EOF'S
NOEOF    EQU   X'00'                    TREAT EOF'S AS DATA BLK
         SPACE 1
CHGIDR   EQU   X'FF'                    WE HAVE CHANGED THE IDR
NOCHGIDR EQU   X'00'                    WE HAVE NOT UPDATED IT YET
         SPACE 1
SEQREAD  EQU   X'01'                    READ NEXT RECORD           LDW1
NOSEQRD  EQU   X'00'                    READ THIS RECORD           LDW1
         SPACE 1
OLD      DC    F'1',A(HERALD)
HERALD   DC    H'10',H'0',CL6' ZAP: '
         SPACE 2
PTPBDC   PUTLINE  OUTPUT=(LINEDESC-TSDSECT,TERM,SINGLE,DATA),      LDW1X
               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),MF=L             LDW1
PTPBDCL  EQU   *-PTPBDC                                            LDW1
         SPACE 1
PGPBDC   PUTGET OUTPUT=(OLD,SINGLE,MODE),TERMGET=(EDIT,WAIT),          X
               TERMPUT=(ASIS,WAIT,NOHOLD,NOBREAK),MF=L
PGPBDCL  EQU   *-PGPBDC
         SPACE 2
CTL3270C DC    X'C3'                    WCC: RST KEB+RST MDT       SDM4
         DC    X'115D7F114040'          SPF/TCAM PREFIX            LDW1
         SPACE 1
END3270C DC    X'3C404000'              CLEAR WITH NULLS TO 1,1    SDM5
END3270M DC    X'11C1D113'              INSERT CURSOR AT 2,2       SDM5
         SPACE 1
CLR3270  DC    X'C3'                    WCC: RST KEB+RST MDT       SDM5
         DC    X'115D7E114040'          SPF/TCAM PREFIX (ADDR 1,1) LDW1
         DC    X'3C404000'              CLEAR WITH NULLS TO 1,1    LDW1
         DC    X'13'                    INSERT CURSOR AT TOP       LDW1
CLR3270L EQU   *-CLR3270                LENGTH                     SDM5
         SPACE 2
*        CONSTANTS FOR DISPLAY ROUTINE.
         SPACE 1
DSPCON80 DC    F'-16'                   MASK FOR HIGH ORDER BITS   LDW1
         DC    F'15'                    MASK FOR LOW  ORDER BITS   LDW1
         DC    H'80'                    LINE LENGTH                LDW1
         DC    H'96'                    (HEX/SCREEN)/2             LDW1
         DC    H'16'                    HEX BYTES / LINE           LDW1
         DC    H'32'                    TWICE THE ABOVE            LDW1
         DC    AL1(7,12,12,17,18,23,23,28,30,35,35,40,41,46,46,51) LDW1
DISPTR80 DC    AL1(48)                  BLANK               +08    LDW1
         DC    AL1(16,17,18,19,48)      BYTES 01, 02        +09    LDW1
         DC    AL1(20,21,22,23,48,48)   BYTES 03, 04        +14    LDW1
         DC    AL1(24,25,26,27,48)      BYTES 05, 06        +20    LDW1
         DC    AL1(28,29,30,31,48,48,48)      07, 08        +25    LDW1
         DC    AL1(32,33,34,35,48)            09, 10        +32    LDW1
         DC    AL1(36,37,38,39,48,48)         11, 12        +37    LDW1
         DC    AL1(40,41,42,43,48)            13, 14        +43    LDW1
         DC    AL1(44,45,46,47)               15, 16        +48    LDW1
         DC    AL1(48,48,48,49)         '   |'              +52    LDW1
         DC    AL1(0,1,2,3,4,5,6,7)     FIRST 8 CHARS       +56    LDW1
         DC    AL1(8,9,10,11,12,13,14,15)  LAST 8 CHARS     +64    LDW1
         DC    AL1(49)                                      +72    LDW1
         SPACE 1
DSPCON40 DC    F'-8'                    MASK FOR HIGH ORDER BITS   LDW1
         DC    F'7'                     MASK FOR LOW  ORDER BITS   LDW1
         DC    H'40'                    LINE LENGTH                LDW1
         DC    H'48'                    (HEX/SCREEN)/2             LDW1
         DC    H'8'                     HEX BYTES / LINE           LDW1
         DC    H'16'                    TWICE THE ABOVE            LDW1
         DC    X'060B0B101116161B'      TABS FOR CARET ON SCREEN
*%       DC    8X'00'                   PADDING                    LDW1
DISPTR40 DC    AL1(16,17,18,19,48)      BYTES 01, 02        +08    LDW1
         DC    AL1(20,21,22,23,48,48)   BYTES 03, 04        +13    LDW1
         DC    AL1(24,25,26,27,48)      BYTES 05, 06        +19    LDW1
         DC    AL1(28,29,30,31)         BYTES 07, 08        +24    LDW1
         DC    AL1(48,48,49)            '  |'               +28    LDW1
         DC    AL1(0,1,2,3,4,5,6,7)     CHARACTERS          +31    LDW1
         DC    AL1(49)                  '|'                 +39    LDW1
*%       DC    34AL1(48)
         SPACE 2
CCWLIST  CCW   X'03',0,X'40',1          NOP FOR NOW                LDW1
         CCW   X'31',0,X'40',5          SEARCH ID EQ               LDW1
         CCW   X'08',0,X'00',0          TIC *-8                    LDW1
         CCW   X'1E',0,X'20',0          READ CKD                   LDW1
         SPACE 1
         CCW   X'31',0,X'40',5          SEARCH ID EQ               LDW1
         CCW   X'08',0,X'00',0          TIC *-8                    LDW1
         CCW   X'0D',0,X'20',0          WRITE KD                   LDW1
         SPACE 1
         CCW   X'16',0,X'20',0          READ R0                    LDW1
         SPACE 1
         CCW   X'16',0,X'70',1          READ R0 TO ORIENT          LDW1
         CCW   X'E9',0,X'40',8          SEARCH KEY EQ/HI MT        LDW1
         CCW   X'08',0,X'00',0          TIC *-8                    LDW1
         CCW   X'0E',0,X'00',8+256      READ KD                    LDW1
         SPACE 1
         CCW   X'31',0,X'40',5          SEARCH ID EQ               LDW1
         CCW   X'08',0,X'00',0          TIC *-8                    LDW1
         CCW   X'1D',0,X'20',0          WRITE CKD                  LDW1
         EJECT                                                     LDW3
*        ZAP --- PATCH AREA.
         SPACE 1
PATCH    DC    128S(*)                                             LDW1
         SPACE 2
         OACDROP R12,R11,R10,R9                                     MVS
         EJECT
*        ZAP --- EXP : EXPRESSION ANALYZER.
         SPACE 1
*        EXP : THIS ROUTINE WILL ANALYZE AN EXPRESSION PASSED TO IT
*              AND RETURN ITS VALUE CONCATENATED WITH A STARTING VALUE.
*        INPUT : R13 - SAVE AREA.
*                R14 - RETURN ADDRESS.
*                      IF EXPOPT IS ZERO, TABLE NOT SCANNED,
*                      ELSE SYMBOL TABLE IS SCANNED.
*                R2  - STARTING VALUE OF '*'.                      LDW1
*                R1  - ADDRESS OF EXPRESSION TO PARSE.
*                R0  - LENGTH OF EXPRESSION TO PARSE.
*        OUTPUT : R1  - RETURN CODE.
*                       IF NEGATIVE : NO ERRORS DETECTED.
*                       IF ZERO OR POSITIVE AN ERROR OCCURED AT ADDRESS
*                       GIVEN IN R1.
*                 R15 - IF NO ERROR, THE NEW VALUE CALCULATED.
*
*        THIS ROUTINE WAS WRITTEN BY DON WORTH.
*        MODIFIED BY LEONARD D. WOREN TO DO MULT & DIV(12-27-78).  LDW1
         SPACE 1
         USING TSDSECT,R13
EXP      STM   R14,R1,EXPARMS+12        SAVE CALLER'S REGS ONE PLACE
         STM   R2,R12,12+(4*4)(R13)     SAVE REST IN OTHER PLACE
         LR    R12,R15                  GET BASE                   LDW1
         USING EXP,R12                                             LDW1
         LR    R4,R2                    ALWAYS BEGIN WITH *        LDW1
         ST    R2,EXPSTART              SAVE VALUE OF "*"          LDW1
         LR    R3,R1                    START SCAN
         BCTR  R3,0                     HE WILL ADD ONE FIRST
         LR    R2,R0                    BCT INDEX
*LDW1    XC    EXPFLAG(2),EXPFLAG       RESET FLAGS
         MVI   EXPFLAG+1,0              RESET FLAGS                LDW1
         LA    R2,1(R2)                 ALLOW FOR FIRST PASS
         ST    R1,GORF                  FIRST BAD SPOT
         B     EXPBACK                  START AFTER ITEM
         SPACE 1
*        SEE WHAT NEXT ITEM IS.
         SPACE 1
EXPITEM  LTR   R2,R2                    ANYTHING LEFT?
         BP    EXPON                    YES
         ST    R4,EXPSTART              NEW STARTER
         OI    EXPPTR,X'80'             NO ERROR
         B     EXPRET                   RETURN
EXPON    CLI   0(R3),C' '               BLANK?
         BNE   EXPCHECK                 NO, WE CAN USE IT
EXPNEXT  LA    R3,1(R3)                 NEXT SPOT TO CHECK
         BCT   R2,EXPITEM               CONTINUE
         MVI   EXPFLAG+1,0              NOTHING FOR NEXT TIME
         B     EXPCONV                  WHEN AT END, USE LAST IF ANY
EXPCHECK ST    R3,GORF                  KEEP TRACK OF WHERE WE ARE
         CLI   0(R3),C'*'               CURRENT LOC OR MULT?
*LDW1    BE    EXPCURR                  YES, GO LOAD IT
         BE    EXPSTAR                  YES, GO DECIDE WHICH       LDW1
         CLI   0(R3),C'+'               ADD?
         BE    EXPADD                   YES
         CLI   0(R3),C'-'               SUBTRACT?
         BE    EXPSUB                   YES
         CLI   0(R3),C'.'               DECIMAL DONE?
         BE    EXPDEC                   YES
         CLI   0(R3),C'/'               DIVIDE?                    LDW1
         BE    EXPDIV                   YES                        LDW1
         OI    EXPFLAG+1,EXPEXOPR       EXPECTING OPERATOR NOW     LDW1
         SPACE 1
*        IF NO TERMINATOR IS FOUND, SAVE UP FOR LATER.
         SPACE 1
         LA    R0,EXPWORK+8             POINT PAST IT
         CR    R0,R5                    TOO FAR?
         BNH   EXPERR                   YES
         MVC   0(1,R5),0(R3)            COPY IT TO WORKAREA
         LA    R5,1(R5)
         B     EXPNEXT                  CONTINUE
         SPACE 1
*        IF AN ERROR IS DETECTED, PASS BACK ADDRESS OF IT.
         SPACE 1
EXPERR   MVC   EXPPTR(4),GORF           SAVE POINTER FOR RETURN
EXPRET   MVI   EXPOPT,NOSYMB            RESET NO SYMB TAB LOOKUP
         LM    R14,R1,EXPARMS+X'C'      GET RETURN REGS
         LM    R2,R12,12+(4*4)(R13)     RESTORE REST OF REGS FROM SAVE
         BR    R14
         SPACE 1
*        '*' WAS ENTERED, DECIDE IF CURRENT LOC OR MULTIPLY.       LDW1
         SPACE 1
EXPSTAR  TM    EXPFLAG+1,EXPEXOPR       WHICH IS THIS?             LDW1
         BO    EXPMULT                  MULTIPLY.                  LDW1
         SPACE 1
*        USE CURRENT VALUE.
         SPACE 1
EXPCURR  L     R15,EXPSTART             GET STARTING VALUE
         MVI   EXPFLAG+1,EXPEXOPR       EXPECTING OPERATOR NOW     LDW1
         B     EXPUSE                   AND GO USE IT
         SPACE 1
*        IF '+' WAS ENTERED, TERMINATE PREVIOUS AND SET FLAG.
         SPACE 1
EXPADD   MVI   EXPFLAG+1,EXPFPLUS       INDICATE ADD NEXT TIME
         B     EXPCONV                  GO CONVERT IT
         SPACE 1
*        IF '-' WAS ENTERED, TERMINATE PREVIOUS AND SET FLAG.
         SPACE 1
EXPSUB   MVI   EXPFLAG+1,EXPFMINS       INDICATE ADD NEXT TIME
         B     EXPCONV                  GO CONVERT IT
         SPACE 1
*        IF '*' WAS ENTERED, TERMINATE PREVIOUS AND SET FLAG.      LDW1
         SPACE 1
EXPMULT  MVI   EXPFLAG+1,EXPFMULT       INDICATE MULT NEXT TIME    LDW1
         B     EXPCONV                  GO CONVERT IT              LDW1
         SPACE 1
*        IF '/' WAS ENTERED, TERMINATE PREVIOUS AND SET FLAG.      LDW1
         SPACE 1
EXPDIV   MVI   EXPFLAG+1,EXPFDIV        INDICATE DIV NEXT TIME     LDW1
         B     EXPCONV                  GO CONVERT IT              LDW1
         SPACE 1
*        IF '.' WAS ENTERED, TERMINATE PREVIOUS AS DECIMAL.
         SPACE 1
EXPDEC   OI    EXPFLAG,EXPFDEC          INDICATE DECIMAL THIS TIM
*        B     EXPCONV                  GO CONVERT IT
         SPACE 1
*        WHEN UP TO 8 CHARS SCANNED OUT, CONVERT THEM APPROPRIATELY.
         SPACE 1
EXPCONV  LA    R15,EXPWORK+1            POINT TO START
         SR    R5,R15                   FIND EXECUTE LENGTH
         LR    R15,R5                   SAVE IT                    LDW1
         BNM   EXPCOK                   IF SOMETHINGS THERE, CONTINUE
         TM    EXPFLAG,EXPFTERM         SOMETHING EXPECTED?
         BZ    EXPBACK                  NO, IGNORE THIS TIME
         B     EXPERR                   OTHERWISE ITS NO GOOD
EXPCOK   MVC   DBLW(0),EXPWORK          << EXECUTED >>
         MVI   DBLW,C' '
         MVC   DBLW+1(7),DBLW           CLEAR AN AREA
         EX    R15,EXPCOK               MOVE TO IT
         SPACE 1
*        IF SYMBOL TABLE SCAN REQUESTED, DO SO.
         SPACE 1
         CLI   EXPOPT,NOSYMB            SCAN LABEL TABLE?
         BE    EXPNTAB                  NO, GO ON
         TM    EXPFLAG,EXPFDEC          DECIMAL?
         BO    EXPNTAB                  THEN CAN'T BE THIS
         L     R14,AIDEFTAB             POINT TO TABLE
EXPIDSCN CLI   0(R14),255               END OF TABLE?
         BE    EXPNTAB                  THEN WE DIDN'T FIND IT
         CLC   0(8,R14),DBLW            SEE IF THIS IS HIS LABEL
         BE    EXPGLAB                  YES, IT IS
         LA    R14,10(R14)              NEXT ENTRY IN TABLE
         B     EXPIDSCN                 GO ON
EXPGLAB  LH    R15,8(R14)               GET VALUE OF IT
         B     EXPUSE                   AND USE IT
         SPACE 1
*        VALIDITY CHECK FOR NUMERICS.
         SPACE 1
EXPNTAB  LA    R0,1(R15)                GET LENGTH OF THINGY
         LA    R14,EXPWORK              FIND IT
EXPCCHK  CLI   0(R14),C'0'              IF ITS NUMERIC I ALWAYS LIKE IT
         BNL   EXPCGOOD                 GO
         TM    EXPFLAG,EXPFDEC          DECIMAL?
         BO    EXPERR                   THEN NO GOOD
         CLI   0(R14),C'A'              OTHERWISE NOT LESS THAN A
         BL    EXPERR                   GO
         CLI   0(R14),C'F'              OR GREATER THAN F
         BH    EXPERR                   GO
         IC    R1,0(R14)                GET IT
         AH    R1,EXPFUDGE              MAKE FA-FF
         STC   R1,0(R14)                REPLACE IT
EXPCGOOD LA    R14,1(R14)               NEXT
         BCT   R0,EXPCCHK               CONTINUE CHECKING
         SPACE 1
*        CONVERT DECIMAL.
         SPACE 1
         TM    EXPFLAG,EXPFDEC          DECIMAL?
         BZ    EXPNDEC                  NO
EXPPACK  PACK  DBLW(8),EXPWORK(0)       << EXECUTED >>
         EX    R15,EXPPACK              PACK IT
         CVB   R15,DBLW                 CONVERT IT
         B     EXPUSE                   AND USE IT
         SPACE 1
*        CONVERT FOR HEX.
         SPACE 1
EXPNDEC  LA    R15,1(R15)               DO AN EXTRA CHAR
         EX    R15,EXPPACK              PACK IT
         LM    R14,R15,DBLW             GET OFFSET
         SRDL  R14,8                    SHIFT OUT BAD BYTE (FLIP)
*        B     EXPUSE                   GO USE IT
         SPACE 1
*        WHEN VALUE OBTAINED, ADD, SUB OR WHATEVER.
         SPACE 1
EXPUSE   TM    EXPFLAG,EXPFPLUS         ADDING?
         BO    EXPUADD                  YES
         TM    EXPFLAG,EXPFMINS         SUBTRACTING?
         BO    EXPUSUB                  YES
         TM    EXPFLAG,EXPFMULT         MULTIPLYING?               LDW1
         BO    EXPUMULT                 YES                        LDW1
         TM    EXPFLAG,EXPFDIV          DIVIDING?                  LDW1
         BO    EXPUDIV                  YES                        LDW1
         LR    R4,R15                   ELSE, OVERLAY
         SPACE 1
EXPBACK  LA    R5,EXPWORK               START AGAIN
         MVC   EXPFLAG(1),EXPFLAG+1     NEW FLAGS
         MVI   EXPFLAG+1,0              NO MORE
         B     EXPNEXT                  SKIP LAST ONE
EXPUADD  AR    R4,R15
         B     EXPBACK                  GO ON
EXPUSUB  SR    R4,R15                   SUBTRACT
         B     EXPBACK                  GO
         SPACE 1
EXPUMULT LR    R5,R4                    GET INTO ODD REG           LDW1
         MR    R5-1,R15                 DO THE MULTIPLY            LDW1
         LR    R4,R5                    GET RESULT IN CORRECT REG  LDW1
         B     EXPBACK                  GO ON                      LDW1
         SPACE 1
EXPUDIV  LR    R5,R4                    GET INTO ODD REG           LDW1
         XR    R4,R4                    CLEAR FOR DIVIDE           LDW1
         LTR   R15,R15                  DIVIDE BY 0?               LDW1
         BZ    EXPERR                   YES, ERROR                 LDW1
         DR    R5-1,R15                 DO THE MULTIPLY            LDW1
         LR    R4,R5                    GET RESULT IN CORRECT REG  LDW1
         B     EXPBACK                  GO ON                      LDW1
         SPACE 2
*        EXP'S DATA.
         SPACE 1
EXPFUDGE DC    0H'0',XL2'0039'
EXPFPLUS EQU   X'80'                    ADD NEXT VALUE
EXPFMINS EQU   X'40'                    SUBTRACT NEXT VALUE
EXPFDEC  EQU   X'20'
EXPFMULT EQU   X'10'                    MULT NEXT VALUE            LDW1
EXPFDIV  EQU   X'08'                    DIV NEXT VALUE             LDW1
EXPEXOPR EQU   X'04'                    EXPECTING OPERATOR NEXT    LDW1
*        SOMETHING REQUIRED FLAG :
EXPFTERM EQU   EXPFPLUS+EXPFMINS+EXPFDEC+EXPFMULT+EXPFDIV          LDW1
         SPACE 2
         PRINT GEN
         LTORG
         SPACE 2
         DROP  ,                                                   LDW1
         EJECT ,                                                   LDW1
DCBMSK   DCB   MACRF=E,DDNAME=SYSLIB,DEVD=DA                       LDW1
         DC    5F'0'                    STUPID MACRO & SYSTEM      LDW1
DCBUL    EQU   *-DCBMSK
         SPACE 2
OPNMSG   DC    C'0ZAP009I CAW999.III HAS OPENED FOR INPUT '        LDW4
OPNMSGL  EQU   *-OPNMSG
         EJECT
*        COMMAND TABLE.
         SPACE 1
COMTAB   DC    0F'0'                             * = NO HELP INFO
         DC    AL1(6),CL8'VERBOSE ',AL3(VERBOSE)
         DC    AL1(6),CL8'CAPSOFF ',AL3(CAPSOFF)                   -EU-
         DC    AL1(5),CL8'CAPSON  ',AL3(CAPSON)                    -EU-
         DC    AL1(5),CL8'NOT3270 ',AL3(NOT3270)    %%TEMP%%     * LDW1
         DC    AL1(5),CL8'YES3270 ',AL3(YES3270)    %%TEMP%%     * LDW1
         DC    AL1(6),CL8'WHATMEM ',AL3(WHATMEM)                   LDW1
         DC    AL1(6),CL8'//DEBUG ',AL3(DIEFAST)                 * LDW1
         DC    AL1(6),CL8'LASTDS1 ',AL3(LASTDS1)                   LDW1
         DC    AL1(6),CL8'X X X X ',AL3(*)   ZAP SPACE           * LDW1
         DC    AL1(5),CL8'EBCDIC  ',AL3(EBCDIC)
         DC    AL1(5),CL8'ITRACE  ',AL3(ITRACE)
         DC    AL1(5),CL8'DISASM  ',AL3(DISASM)
         DC    AL1(5),CL8'LINE80  ',AL3(LINE80)                    LDW1
         DC    AL1(5),CL8'LINE40  ',AL3(LINE40)                    LDW1
**%%     DC    AL1(5),CL8'NEWLOG  ',AL3(NEWLOG)                  * LDW1
**%%     DC    AL1(5),CL8'FORMAT  ',AL3(FORMAT)                  * LDW1
         DC    AL1(4),CL8'NODEF   ',AL3(NODEF)
         DC    AL1(4),CL8'ASCII   ',AL3(ASCII)
         DC    AL1(4),CL8'FLOAT   ',AL3(FLOAT)
         DC    AL1(4),CL8'ZCODE   ',AL3(ZCODE)
         DC    AL1(4),CL8'WHERE   ',AL3(WHERE)
         DC    AL1(4),CL8'TERSE   ',AL3(TERSE)
         DC    AL1(4),CL8'EJECT   ',AL3(EJECT)
         DC    AL1(4),CL8'DUMPF   ',AL3(DUMPF)                     LDW3
         DC    AL1(4),CL8'DUMPT   ',AL3(DUMPT)
         DC    AL1(4),CL8'DISPC   ',AL3(DISPC)                     LDW1
         DC    AL1(4),CL8'DISPK   ',AL3(DISPK)                     LDW1
         DC    AL1(4),CL8'DISPD   ',AL3(DISPD)                     LDW1
         DC    AL1(3),CL8'BASE    ',AL3(BASE)                      LDW1
         DC    AL1(3),CL8'DUMP    ',AL3(DUMP)
         DC    AL1(3),CL8'NOTE    ',AL3(NOTE)
         DC    AL1(3),CL8'LAST    ',AL3(LAST)
         DC    AL1(3),CL8'HELP    ',AL3(HELPHELP)                * LDW1
         DC    AL1(3),CL8'NAME    ',AL3(NAME#)                      *N*
         DC    AL1(3),CL8'IDEF    ',AL3(IDEF)
         DC    AL1(3),CL8'SAVE    ',AL3(REPLACE)                 *
         DC    AL1(3),CL8'ZSYM    ',AL3(ZCODE)                   *
**%%     DC    AL1(3),CL8'VTOC    ',AL3(VTOCCMD)                 * LDW1
         DC    AL1(2),CL8'ASM     ',AL3(ASM)
         DC    AL1(2),CL8'CRT     ',AL3(CRT)
         DC    AL1(2),CL8'LOG     ',AL3(LOG)
         DC    AL1(2),CL8'ZAP     ',AL3(REPLACE)
         DC    AL1(2),CL8'END     ',AL3(END)                       LDW3
         DC    AL1(2),CL8'SET     ',AL3(SET)
         DC    AL1(2),CL8'ABS     ',AL3(ABS)                       JCJ1
**%%     DC    AL1(2),CL8'DSN     ',AL3(DSNCMD)                  * LDW1
         DC    AL1(1),CL8'WM      ',AL3(WHATMEM)                   LDW4
         DC    AL1(1),CL8'DO      ',AL3(DO)
         DC    AL1(0),CL8'L       ',AL3(LOCATE)
         DC    AL1(0),CL8'S       ',AL3(STORE)
         DC    AL1(0),CL8'O       ',AL3(OR)
         DC    AL1(0),CL8'X       ',AL3(EXOR)
         DC    AL1(0),CL8'N       ',AL3(AND)
         DC    AL1(0),CL8'F       ',AL3(FIND)                      LDW1
         DC    AL1(0),CL8'>       ',AL3(FORWARD)
         DC    AL1(0),CL8'<       ',AL3(BACKWARD)
         DC    AL1(0),CL8'M       ',AL3(MEMBER#)
         DC    AL1(0),CL8'E       ',AL3(NAME#)                    *LPR*
         DC    AL1(0),CL8'B       ',AL3(BACK)
         DC    AL1(0),CL8'D       ',AL3(DISPLAY#)
         DC    AL1(0),CL8'V       ',AL3(INDIRECT)                  LDW1
         DC    AL1(0),CL8'T       ',AL3(TRACK)
         DC    AL1(0),CL8'R       ',AL3(RECORD)
         DC    AL1(0),CL8'P       ',AL3(POINT)
         DC    AL1(0),CL8'J       ',AL3(POINT$J)                   MAS2
         DC    AL1(0),CL8'U       ',AL3(UP)                        LDW1
         DC    AL1(0),CL8'=       ',AL3(EQUALS)
         DC    AL1(0),CL8'?       ',AL3(HELP)
         DC    AL1(0),CL8'H       ',AL3(HELP)                      LDW1
         DC    AL1(0),CL8'#       ',AL3(CALC)
         DC    AL1(0),CL8'W       ',AL3(WINDOW)
         DC    AL1(0),CL8'%       ',AL3(INDPOINT)                  LDW1
         DC    X'FF'
         EJECT
*        STAXEXIT ----- STAX EXIT.
*              GIVEN PTR TO TSDSECT IN STAXLIST, TURN ON
*              ATTENTION INDICATOR AND RETURN QUICKLY.
         SPACE 1
         USING STAXEXIT,R15                                        LDW1
STAXEXIT L     R3,8(,R1)                GET USADDR FIELD (R13)     LDW1
         USING TSDSECT,R3                                          LDW1
         LR    R2,R14                   SAVE RETURN ADDR
         TM    GODFLAG,GODAUTH          WAS AUTHORIZED?            -EU-
         BZ    STAXXIT                  NO                         -EU-
         RESAUTH                                                   -EU-
         NI    GODFLAG,255-GODAUTH      RESET                      -EU-
STAXXIT  TM    FLAGS2,ATTNHIT           ALREADY SET?               LDW5
         BNO   *+L'*+6                  NO, OK                     LDW1
         LA    R1,1000                  ABEND CODE                 LDW1
         SVC   13                       LET HIM OUT QUICK          LDW1
         OI    FLAGS2,ATTNHIT           INDICATE ATTN SIGNALED     LDW5
         OI    FLAGS3,RESHOWF           ATTN CLEARS THE SCREEN     LDW5
         POST  TSECB                    POST ATTN ECB
         XR    R15,R15                  RC=0 TO STAX
         BR    R2                       RETURN
         DROP  R15,R3                                              LDW1
         EJECT
*        ZAP --- TRANSLATE TABLES ---
         SPACE 2
*        DUMP FORMAT TRTAB (*** ASCII ***).
*        (THIS IS A MODIFIED VERSION OF ASMTRTAB RASA,             -EU-
*        INTO WHICH ALL HEXADECIMAL VALUES LESS THAN X'3F'         -EU-
*        HAVE BEEN REPLACED BY A PERIOD CHARACTER X'4B')           -EU-
         SPACE 1
IECTRASA EQU   *  0 1 2 3 4 5 6 7 8 9 A B C D E F
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B' 0
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B' 1
         DC    X'404F7F7B5B6C507D4D5D5C4E6B604B61' 2
         DC    X'F0F1F2F3F4F5F6F7F8F97A5E4C7E6E6F' 3
         DC    X'7CC1C2C3C4C5C6C7C8C9D1D2D3D4D5D6' 4
         DC    X'D7D8D9E2E3E4E5E6E7E8E94AE05A5F6D' 5
         DC    X'79818283848586878889919293949596' 6
         DC    X'979899A2A3A4A5A6A7A8A9C06AD0A14B' 7
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B' 8
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B' 9
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B' A
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B' B
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B' C
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B' D
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B' E
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B' F
         SPACE 2                                                   -EU-
*        CONVERT STRING TRTAB (*** ASCII ***).                     -EU-
*        (THIS IS THE VERSION OF ASMTRTAB SASA)                    -EU-
         SPACE 1                                                   -EU-
IECTSASA EQU   *  0 1 2 3 4 5 6 7 8 9 A B C D E F
         DC    X'000102031A091A7F1A1A1A0B0C0D0E0F' 0
         DC    X'101112131A0A080018191A1A1C1D1E1F' 1
         DC    X'1A1A1A1A1A0A171B1A1A1A1A1A050607' 2
         DC    X'1A1A161A1A1A1A041A1A1A1A14151A1A' 3
         DC    X'201A1A1A1A1A1A1A1A1A5B2E3C282B21' 4
         DC    X'261A1A1A1A1A1A1A1A1A5D242A293B5E' 5
         DC    X'2D2F1A1A1A1A1A1A1A1A7C2C255F3E3F' 6
         DC    X'1A1A1A1A1A1A1A1A1A603A2340273D22' 7
         DC    X'1A6162636465666768691A1A1A1A1A1A' 8
         DC    X'1A6A6B6C6D6E6F7071721A1A1A1A1A1A' 9
         DC    X'1A7E737475767778797A1A1A1A1A1A1A' A
         DC    X'1A1A1A1A1A1A1A1A1A1A1A1A1A1A1A1A' B
         DC    X'7B4142434445464748491A1A1A1A1A5C' C
         DC    X'7D4A4B4C4D4E4F5051521A1A1A1A1A1A' D
         DC    X'5C1A535455565758595A1A1A1A1A1A1A' E
         DC    X'303132333435363738391A1A1A1A1A1A' F
         SPACE 2
*        DUMP FORMAT TRTAB (*** ZCODE ***).
         SPACE 1
TRCHARZ  DC    256C'.'
         ORG   TRCHARZ+X'18'
         DC    X'C0D0'
         ORG   TRCHARZ+X'25'
         DC    C'$'
         ORG   TRCHARZ+X'40'
         DC    C' ABCDEFGHIJKLMNOPQRSTUVWXYZ'
         DC    C'_ABCDEFGHIJKLMNOPQRSTUVWXYZ'
         DC    C'=0123456789'
         ORG   TRCHARZ+X'90'
         DC    C'+-'
         ORG   TRCHARZ+X'9E'
         DC    C'<'
         ORG   TRCHARZ+X'A0'
         DC    C'='
         ORG   TRCHARZ+X'A2'
         DC    C'>'
         ORG   TRCHARZ+X'A4'
         DC    C'-',X'5A'         EXCLAIM POINT
         ORG   TRCHARZ+X'B5'
         DC    C',?'
         ORG   TRCHARZ+X'C4'
         DC    C';:'
         ORG   TRCHARZ+X'F9'
         DC    C'#'
*        ORG   TRCHARZ+4
*        DC    C'$'
*        ORG   TRCHARZ+14
*        DC    C'??();/'
*        ORG   TRCHARZ+26
*        DC    C'+-*/*...?V<.=.>'
*        ORG   TRCHARZ+47
*        DC    C',?'
*        ORG   TRCHARZ+54
*        DC    C'Â¬'
*        ORG   TRCHARZ+61
*        DC    C'_'
*        ORG   TRCHARZ+82
*        DC    C'??'
*        ORG   TRCHARZ+86
*        DC    C'ABCDEFGHIJKLMNOPQRSTUVWXYZ-'
*        ORG   TRCHARZ+113
*        DC    C'ABCDEFGHIJKLMNOPQRSTUVWXYZ='
*        ORG   TRCHARZ+140
*        DC    C'0123456789.. '':'
         ORG   ,
         SPACE 2                                                   -EU-
*        CONVERT STRING TRTAB (*** ZCODE ***).                     -EU-
*        (THIS IS THE PREVIOUS TABLE IN REVERSE ORDER JUST         -EU-
*        BECAUSE I DIDN'T FOUND WHAT 'ZCODE' MEANS) MOINIL P.A.    -EU-
         SPACE 1                                                   -EU-
TRCHRZ   DC    256X'3F'                                            -EU-
         ORG   TRCHRZ+X'40'                                        -EU-
         DC    X'40'                                               -EU-
         ORG   TRCHRZ+X'4C'        <                               -EU-
         DC    X'9E'                                               -EU-
         ORG   TRCHRZ+X'4E'        +                               -EU-
         DC    X'90'                                               -EU-
         ORG   TRCHRZ+X'5A'        !$                              -EU-
         DC    X'A525'                                             -EU-
         ORG   TRCHRZ+X'5E'        ;                               -EU-
         DC    X'C4'                                               -EU-
         ORG   TRCHRZ+X'60'        -                               -EU-
         DC    X'91' OR X'A4'                                      -EU-
         ORG   TRCHRZ+X'6B'        ,                               -EU-
         DC    X'B5'                                               -EU-
         ORG   TRCHRZ+X'6D'        _>?                             -EU-
         DC    X'5BA2B6'                                           -EU-
         ORG   TRCHRZ+X'7A'        :#                              -EU-
         DC    X'C5F9'                                             -EU-
         ORG   TRCHRZ+X'7E'        =                               -EU-
         DC    X'76' OR X'A0'                                      -EU-
         ORG   TRCHRZ+X'81'        ABCDEFGHI                       -EU-
         DC    X'5C5D5E5F6061626364'                               -EU-
         ORG   TRCHRZ+X'91'        JKLMNOPQR                       -EU-
         DC    X'65666768696A6B6C6D'                               -EU-
         ORG   TRCHRZ+X'A2'        STUVWXYZ                        -EU-
         DC    X'6E6F707172737475'                                 -EU-
         ORG   TRCHRZ+X'C0'        {ABCDEFGHI                      -EU-
         DC    X'18414243444546474849'                             -EU-
         ORG   TRCHRZ+X'D0'        }JKLMNOPQR                      -EU-
         DC    X'194A4B4C4D4E4F505152'                             -EU-
         ORG   TRCHRZ+X'E2'        STUVWXYZ                        -EU-
         DC    X'535455565758595A'                                 -EU-
         ORG   TRCHRZ+X'F0'        0123456789                      -EU-
         DC    X'7778797A7B7C7D7E7F80'                             -EU-
         ORG   ,                                                   -EU-
         SPACE 2
*        DUMP FORMAT TRTAB (*** EBCDIC ***).
         SPACE 1
TRCHARE  DC    256C'.'
         ORG   TRCHARE+C' '
         DC    C' '
         ORG   TRCHARE+X'4A'            CENT SIGN
         DC    X'4A',C'.<(+|&&'
         ORG   TRCHARE+X'5A'            EXCLAMATION PT
         DC    X'5A',C'$*);Â¬-/'
         ORG   TRCHARE+C','
         DC    C',%_>?'
         ORG   TRCHARE+C':'
         DC    C':#@''=',X'7F'          DOUBLE QUOTE
         ORG   TRCHARE+X'81'
         DC    9AL1(*-TRCHARE)          LOWER CASE A-I
         ORG   TRCHARE+X'91'
         DC    9AL1(*-TRCHARE)          LOWER CASE J-R
         ORG   TRCHARE+X'A2'
         DC    8AL1(*-TRCHARE)          LOWER CASE S-Z
         ORG   TRCHARE+C'A'
         DC    9AL1(*-TRCHARE)          UPPER CASE A-I
         ORG   TRCHARE+C'J'
         DC    9AL1(*-TRCHARE)          UPPER CASE J-R
         ORG   TRCHARE+C'S'
         DC    8AL1(*-TRCHARE)          UPPER CASE S-Z
         ORG   TRCHARE+C'0'
         DC    10AL1(*-TRCHARE)         NUMBERS
         ORG   ,
         EJECT
*        ZAP --- TSO PARSE DSECTS/CSECTS  -  PDL, PCL, PDE, ETC...
         SPACE 1
ZAP      CSECT
         PRINT NOGEN
PCL      IKJPARM DSECT=IKJPARMD
PDLDSN   IKJPOSIT DSNAME,USID,PROMPT='DATA-SET NAME'               LDW1
PDLVOL   IKJKEYWD
         IKJNAME 'VOLUME',SUBFLD=VOLUME
PDLALC   IKJKEYWD  DEFAULT=                                        LDW1
         IKJNAME  'ALLOCDSN',SUBFLD=PDLALCSF                       LDW1
CRTK     IKJKEYWD
         IKJNAME 'CRT'
NOT3270K IKJKEYWD DEFAULT=                                         LDW1
         IKJNAME 'NOT3270'                                         LDW1
LOGK     IKJKEYWD DEFAULT='LOG  '                                  LDW1
         IKJNAME 'LOG'
         IKJNAME 'NOLOG'                                           LDW1
NWK      IKJKEYWD DEFAULT='TERSE'
         IKJNAME 'VERBOSE'
         IKJNAME 'TERSE'
VOLUME   IKJSUBF
VOLVOL   IKJIDENT 'VOLUME SERIAL',FIRST=ALPHA,OTHER=ALPHANUM,MAXLNTH=6
PDLALCSF IKJSUBF
PDLALCDS IKJPOSIT  DSNAME,USID,PROMPT='NAME OF DATA-SET TO ALLOC'  LDW4
         IKJENDP
         PRINT GEN
         SPACE 2                                                   LDW1
PDE      DSECT ,                        PARSE DESCRIPTOR ELEMENT
PDEPTR   DS    A                        TEXT PTR
PDELEN   DS    H                        LEN
PDEFLAG  DS    X                        FLAGS
PDEFPRES EQU   X'80'                    PARM PRESENT
         DS    X                        RESERVED
PDEPTR2  DS    A                                                   LDW1
PDELEN2  DS    H                                                   LDW1
PDEFLAG2 DS    X                                                   LDW1
         DS    X                                                   LDW1
PDEPTR3  DS    A                                                   LDW1
PDELEN3  DS    H                                                   LDW1
PDEFLAG3 DS    X                                                   LDW1
         DS    X                                                   LDW1
PDEL     EQU   *-PDE
         EJECT
*        ZAP --- DSECT MASK EXPANSIONS.
         SPACE 1
*IHADCB   DSECT ,                                             -EU- LDW1
*LDW1     DCBD  DSORG=DA                DCB EXPANSION         -EU-
*--- MACRO DCBD HAS BEEN INSERTED AT THE END --- - - - - - -  -EU-
*         ORG   IHADCB+X'24'                                       LDW1
*DCBRECFM DS    X                                                  LDW1
*DCBEXLST DS    AL3                                                LDW1
*DCBDDNAM DS    CL8                                                LDW1
*         ORG   IHADCB+X'2C'                                       LDW1
*DCBIFLGS DS    0X                                                 LDW1
*DCBDEBAD DS    A                                                  LDW1
         SPACE 2                                                   LDW1
*CVT      DSECT ,                                             -EU-
*LDW1     CVT                           CVT EXPANSION         -EU-
*--- MACRO CVT HAS BEEN INSERTED AT THE END --- - - - - - - - -EU-
*CVTPTR   EQU   16                                            -EU- LDW1
*         ORG   CVT+X'1C'                                     -EU- LDW1
*CVTPCNVT DS    A                                             -EU- LDW1
*CVTPRLTV DS    A                                             -EU- LDW1
         SPACE 2                                                   LDW1
*UCB      DSECT ,                                             -EU-
*LDW1     IEFUCBOB                      UCB EXPANSION         -EU-
*--- MACRO IEFUCBOB HAS BEEN INSERTED AT THE END --- - - - -  -EU-
*         ORG   UCB+X'1C'                                     -EU- LDW1
*SRTEVOLI DS    CL6                                           -EU- LDW1
         SPACE 2                                                   LDW1
*DEB      DSECT ,                                             -EU- LDW1
*LDW1     IEZDEB                        DEB EXPANSION         -EU-
*--- MACRO IEZDEB HAS BEEN INSERTED AT THE END --- - - - - -  -EU-
*         ORG   DEB+X'10'                                     -EU- LDW1
*DEBNMEXT DS    C                       # OF EXTENTS          -EU- LDW1
*         ORG   DEB+X'20'                                     -EU- LDW1
*DEBUCBAD DS    F                                             -EU- LDW1
*         DS    H                                             -EU- LDW1
*DEBSTRCC DS    H                       STARTING CYLINDER     -EU- LDW1
*         DS    H                                             -EU- LDW1
*DEBENDCC DS    H                       ENDING CYLINDER       -EU- LDW1
         EJECT
*DSCB    DSECT
TSDSECT  DSECT                          BACK TO THERE, MOMENTARILY LDW1
         ORG   LINE07                                              LDW1
DSCB     DS    0D                                                  LDW1
         IECSDSL1 (1)                   FORMAT 1 DSCB EXPANSION
         SPACE 1
         ORG   ,                                                   LDW1
         SPACE 2
WORKAREA DSECT
*LDW1    CSOUT MF=L,COUNT=YES
         DS    0D                   (+)
         DS    X,AL3                (+) FLAGS/ADDR OF LINE BUFFER
         DS    860X                 (+) REMAINING DATA
         SPACE 1
         DS    0D     (BUFFER)
LCSOUT   EQU   *-WORKAREA
         SPACE 2                                                   LDW1
ESDDATA  DSECT ,                        ESD DATA ENTRY              *N*
ESDDNAME DS    CL8                      ENTRY PT NAME OF 8X'00'     *N*
ESDDTYPE DS    X                        TYPE                        *N*
ESDDADDR DS    AL3                      LKED ADDR OF ENTRY PT       *N*
ESDDSEG  DS    AL1                      SEGMENT NUMBER              *N*
ESDDLEN  DS    AL3                      LENGTH OF ENTRY             *N*
ESDDL    EQU   *-ESDDATA                LENGTH ESD DATA ENTRY       *N*
         EJECT
*        C S O U T -- URSA PROCESSOR PRINTING ROUTINE.
         SPACE 1
***********************************************************************
CSOUT    CSECT                                                        *
*        CSOUT : THIS ROUTINE WHEN CXCTLED TO OR CALLED BY AN URSA    *
*                PROCESSOR WILL ALLOCATE A PRINT FILE, WRITE OUTPUT   *
*                LINES INTO IT (OPTIONALLY WTOING THEM ALSO), AND     *
*                ENQUEUE THE FILE TO BE PRINTED BY THE MOVE SERVICE.  *
*                IT IS INVOKED BY THE CSOUT MACRO IN ONE OF THREE     *
*                TYPES OF CALLS :                                     *
*  INPUTS : R1 ==> CSAREA ADDRESS                                     *
*           R2 ==> CSOUT WORKAREA ADDRESS                             *
*                                                                     *
*           CSOUT  OPN,VOLUME,TRKS,CALL=TYPE,MF=(TYPE,WORKAREA)       *
*                                                                     *
*                'OPN' REQUESTS THE FILE TO BE ALLOCATED AND OPENED.  *
*                'VOLUME' IS THE ADDRESS OF A 6 BYTE FIELD CONTAINING *
*                         THE VOLUME NAME TO BE USED FOR THE FILE.    *
*                'TRKS' IS THE ADDRESS OF A HALFWORD CONTAINING THE   *
*                         NUMBER OF TRACKS TO BE ALLOCATED.           *
*                FOR CALL= 'TYPE' IS EITHER 'CXCTL' OR 'CALL'. IF     *
*                'CXCTL' IS SPECIFIED CSOUT IS INVOKED VIA CXCTL.     *
*                OTHERWISE IT IS VIA CALL.                            *
*                MF=(TYPE,WORKAREA) WHERE TYPE IS B (SET UP FOR CALL) *
*                         OR E (SET UP FOR CALL AND CALL). 'WORKAREA' *
*                IS THE ADDRESS OF A ??? BYTE AREA ALIGNED ON A       *
*                DOUBLE WORD TO BE USED BY CSOUT FOR WORK SPACE.      *
*                                                                     *
*                RETURN : R0 ==> 0 - NORMAL, FILE OPEN, PUTS ACCEPTED *
*                               Â¬0 - ERROR RETURN FROM CSLOC/CSOPN    *
*                                                                     *
*           CSOUT  PUT,CALL=,MF=,WTO=OPTION                           *
*                                                                     *
*                WHERE WTO=OPTION MAY BE WTO=YES OR WTO=NO TO CAUSE   *
*                         THE LINE TO BE WTOED ALSO.                  *
*                THE LINE BUFFER IS PRINTED. (SEE BELOW FOR WORKAREA  *
*                DEFINITIONS)                                         *
*                OUTPUT : R0 ==> 0 NORMAL RETURN                      *
*                               Â¬0 I/O ERROR                          *
*                                                                     *
*           CSOUT  ENQ,BIN,COPIES,MF=,CALL=                           *
*                                                                     *
*                ENQUEUES THE FILE TO PRINT, RETURNS TO START STATE.  *
*                BIN IS ADDRESS OF 4 BYTE BIN NUMBER.                 *
*                COPIES IS ADDRESS OF HALFWORD CONTAINING COPIES.     *
*                MF AND CALL AS WITH OPN.                             *
*                OUTPUT : R0 ==> 0 NORMAL, DATA SET ENQUEUED TO PRINT *
*                               Â¬0 ENQUEUE FAILED FOR SOME REASON     *
*                                                                     *
*                THE FIRST WORD OF THE WORKAREA CONTAINS THE ADDRESS  *
*                OF THE INTERNAL LINE BUFFER TO BE FILLED BY THE      *
*                CALLER EACH TIME HE DOES A PUT. IT IS SET AT 'OPN'   *
*                TIME. THE BUFFER IS CLEARED AFTER EACH CALL.         *
*                                                                     *
*  PROGRAMMER : DON D WORTH                                           *
*               ALTERED BY PCN FOR USE WITH TSO ZAP (1/30/77)         *
*               MODIFIED BY LDW TO USE QSAM (12/26/78)                *
*                                                                     *
***********************************************************************
         SPACE 2
DATA     DSECT
OFLAGS   DS    0BL1
OPNCALL  EQU   X'80'                    THIS IS AN OPEN CALL
ENQCALL  EQU   X'40'                    THIS IS AN ENQUEUE CALL
PUTCALL  EQU   X'C0'                    THIS IS A PUT CALL (IF ZEROS)
DOWTO    EQU   X'20'                    ISSUE AS A WTO ALSO
OIOERROR EQU   X'04'                    AN I/O ERROR HAS OCCURED
SCRCALL  EQU   X'02'                    THIS IS A SCRATCH CALL
TRNCALL  EQU   X'01'                    THIS IS A TRUNC   CALL     LDW1
LINELOC  DS    A                        ADDRESS OF LINE BUFFER
*OVOLSER DS    A                        ADDRESS OF VOLUME NAME
*BINNO   EQU   OVOLSER                  ADDRESS OF BIN NUMBER
*SPACE   DS    A                        ADDRESS OF SPACE
*COPIES  EQU   SPACE                    ADDRESS OF COPIES
ODBLW    DS    D                        SCRATCH DOUBLE WORD
PAGE     DS    H                        PAGE COUNTER
LINE     DS    H                        LINE COUNTER
SAVEAREA DS    6F                       REGISTERS CHANGED GO HERE
RETREG   DS    F
         SPACE 1
         PRINT NOGEN
DCB      DCB   DDNAME=X,MACRF=PM,DSORG=PS,BLKSIZE=133,LRECL=133,   LDW1$
               RECFM=FBA,SYNAD=0
ODSN     DS    CL44
*OVOL    DS    CL6
WTOBUFF  DS    F                                                   LDW1
         ORG   *-1                      OVERLAY CC IN WTO PREFIX   LDW1
OBUF     DS    CL133                    BUFFER ITSELF              LDW1
         DS    XL4                      ROOM FOR ROUTCDE AND DESC  SDM1
TTLBUFF  DS    CL133                    BUFFER FOR TITLE LINE      LDW1
DATALEN  EQU   *-DATA
         SPACE 1
         PRINT GEN
         EJECT
*        C S O U T -- MAIN ENTRY, DETERMINE CALL TYPE.
         SPACE 1
*        HOUSEKEEPING.
         SPACE 1
CSOUT    CSECT
         USING TSDSECT,R13                                         LDW1
         TM    FLAGS2,LOGF              ARE WE LOGGING?
         BNOR  R14                      IF NOT RETURN
         LTR   R2,R2                    ANY WORKAREA?
         BZR   R14                      NO, ICKY
         STM   R9,R12,SAVEAREA-DATA(R2) SAVE SOME REGS
         ST    R14,RETREG-DATA(R2)      SAVE WHERE TO GO BACK
*LDW1    LR    R13,R1                   COPY TSDSECT PTR TO R13
         LR    R12,R15                  GET BASE REG
         LR    R10,R2                   GET WORKAREA ADDRESS
*LDW1    OACUSING TSDSECT,R13
         OACUSING DATA,R10                                          MVS
         OACUSING CSOUT,R12                                         MVS
         SPACE 1
*        DETERMINE CALL TYPE.
         SPACE 1
         TM    OFLAGS,OPNCALL           OPEN?
         BO    OPEN                     YES, GO OPEN
         TM    OFLAGS,ENQCALL           ENQUEUE?
         BO    ENQUEUE                  YES
         TM    OFLAGS,SCRCALL           SCRATCH?
         BO    SCRATCH                  YES                        LDW1
         TM    OFLAGS,TRNCALL           TRUNCATE?                  LDW1
         BO    TRUNC                    YES                        LDW1
         B     PUTOUT                   NO, MUST BE PUT THEN       LDW1
         SPACE 1
*        WHEN DONE WITH WHATEVER, CLEAR LINE, AND PASS IT BACK.
         SPACE 1
EXIT     MVC   OBUF,BLANKS              CLEAR LINE BEFORE RETURN   LDW1
         NI    OFLAGS,255-PUTCALL-DOWTO-TRNCALL  REMOVE CALL TYPE  LDW1
         LR    R0,R15                   GET RETURN CODE
         L     R14,RETREG               RESTORE RETURN REG
         LM    R9,R12,SAVEAREA          RESTORE OTHER REGS
         BR    R14                      RETURN TO CALLER
         EJECT
*        C S O U T -- OPEN ROUTINE.
         SPACE 1
*        OPEN -- PREPARE FOR CSLOC, CREATE A DATA-SET NAME.
         SPACE 1
OPEN     LA    R0,OBUF                  START IT OUT
         IC    R14,LINELOC              SAVE FLAGS
         ST    R0,LINELOC               STORE FIRST LINE ADDR
         STC   R14,LINELOC              RESTORE FLAGS
         MVC   ODSN(8),=CL8'ZAPLOG'     TRY ZAPLOG FIRST        .AFDSC.
         DEVTYPE ODSN,ODSN+8            SEARCH TIOT             .AFDSC.
         LTR   R15,R15                  IS ZAPLOG ALLOCATED     .AFDSC.
         BZ    NOSYSOUT                 YES, BYPASS ALLOC       .AFDSC.
         ALLOC SYSOUT='A',SPACE=(TRK,1,5,0,RLSE)                   LDW3
         BXH   R15,R15,EXIT             RETRUN WITH ERROR CODE
         MVC   ODSN(8),DA30DDN-DAPB30+DAPBAREA   COPY DDN
NOSYSOUT XC    PAGE(4),PAGE             CLEAR PAGE AND LINE        LDW1
         LA    R0,DCB                   POINT TO DCB
         ST    R0,ODBLW                 STORE IN DCB LIST
         MVI   ODBLW,X'8F'              MARK END OF LIST & OUTPUT
         MVC   DCB(DCBLEN),ODCBMSK      COPY IN MASK
         MVC   DCBDDNAM-IHADCB+DCB(8),ODSN COPY IN DDNAME          LDW3
         OPEN  MF=(E,ODBLW)
         TM    DCB+48,X'10'             SEE IF OPEN
         BO    RC00                     IF SO RETURN OK
         LA    R15,4                    IF NOT ERROR
         B     EXIT
TRUNC    TRUNC DCB                      WRITE OUT A SHORT BLOCK    LDW1
         B     RC00                     THAT WAS EASY              LDW1
         EJECT
*        C S O U T -- PUT ROUTINE.
         SPACE 1
*        PUT -- CALCULATE LINE POSITION.
         SPACE 1
PUTOUT   LH    R0,LINE                  GET LINE NUMBER            LDW1
         CLI   OBUF,C'1'                SKIP TO PAGE?              LDW1
         BE    PUTPAGE                  YES, FORCE PAGE SKIP
         CLI   OBUF,C'0'                DOUBLE SPACE?              LDW1
         BE    SKIP2                    YES
         CLI   OBUF,C'+'                SUPPRESS SKIP?             LDW1
         BE    SKIP0                    YES
         CLI   OBUF,C'-'                TRIPLE SPACE?              LDW1
         BE    SKIP3                    NO, ANYTHING ELSE IS ONE SPACE
         MVI   OBUF,C' '                ELSE FORCE SINGLE          LDW1
         B     SKIP1                    AND COUNT ONE
SKIP3    BCTR  R0,0
SKIP2    BCTR  R0,0
SKIP1    BCTR  R0,0
SKIP0    LTR   R0,R0                    ANYTHING LEFT ON PAGE?
         BNP   PUTPAGE                  NO, EJECT
         STH   R0,LINE                  SAVE NEW LINE COUNTER
         SPACE 1
*        PRINT THE LINE NOW.
         SPACE 1
         PUT   DCB,OBUF                 DUMP OUT HIS LINE THEN     LDW1
         SPACE 1
*        IF WTOING, DO IT.
         SPACE 1
         TM    OFLAGS,DOWTO             DO WTO?
         BZ    RC0                      NO, ALL DONE NOW
*SDM1    XC    WTOBUFF(4),WTOBUFF       GIVE LENGTH/MCS FLAGS
         MVC   WTOBUFF+2(2),=X'8000'    INDICATE ROUTCDE PRESENT   SDM1
         LA    R1,WTOBUFF+123+4         LAST POSSIBLE
         CLI   0(R1),C' '               END OF IT?
         BNE   *+L'*+4                  YES
         BCT   R1,*-8                   KEEP LOOKING
         MVC   1(4,R1),=X'00004080'     SET ROUTCDE=(2,9)          SDM2
         LA    R0,WTOBUFF-1             BEGINNING
         SR    R1,R0                    LENGTH
         BNP   RC0                      NULL
         STH   R1,WTOBUFF               SAVE FOR WTO
         WTO   MF=(E,WTOBUFF)           DO IT
RC0      TM    OFLAGS,OIOERROR          IO ERROR?
         BZ    RC00                     NO
         NI    OFLAGS,255-OIOERROR      TURN OFF FLAG
         LA    R15,8                    INDICATE IT
         B     EXIT                     LEAVE
RC00     XR    R15,R15                  SAY ALL IS WELL
         B     EXIT                     THEN LEAVE
         SPACE 1
*        PUT OUT A TITLE IF AT TOP OF PAGE.
         SPACE 1
PUTPAGE  MVI   WTOBUFF+3,C'-'           TRIPLE SPACE FROM TITLE
         MVC   LINE(2),=H'60'           RESET LINE COUNTER
         LH    R1,PAGE                  GET PAGE COUNTER
         LA    R1,1(R1)                 COUNT LAST PAGE
         STH   R1,PAGE                  SAVE FOR LATER
         CVD   R1,ODBLW                 CONVERT THE PAGE NUMBER
         MVC   TTLBUFF,TITMSK           MOVE IN THE MASK           LDW1
         ED    TTLBUFF+113(6),ODBLW+5   EDIT IN THE PAGE NUMBER    LDW1
         XR    R1,R1                    ASK FOR CURRENT TIME
         SPACE 1
*        LINK  EP=OACNOW                GET CURRENT DATE/TIME       PCN
         CALL  OACNOW                   GET CURRENT DATE/TIME   .AFDSC.
* NOTE : RETURNS A PARMLIST POINTED TO BY R1 WITH THE CURRENT       PCN
*        DATE AND TIME IN THE FORMS DESCRIBED IN THE 'NOWPARM'      PCN
*        DSECT BELOW.                                               PCN
         SPACE 1
         OACUSING NOWPARM,R1                                        MVS
         MVC   TTLBUFF+82(2),DAY        PICK UP DAY   (DD)         LDW1
         CLI   TTLBUFF+82,C'/'          HAD THE DAY BEEN SQUISHED  LDW1
         BNE   *+L'*+4                  NO, LEAVE IT              *VIC*
         MVI   TTLBUFF+82,C' '          YES, BLANK IT OUT          LDW1
         MVC   TTLBUFF+85(3),CHARDATE   PICK UP MONTH (MMM)        LDW1
         MVC   TTLBUFF+89(2),YEAR       PICK UP YEAR  (YY)         LDW1
*        MVC   TTLBUFF+96(8),TIME24     PICK UP TIME HH:MM:SS      LDW1
         MVC   TTLBUFF+96(5),TIME24     PICK UP TIME HH:MM      .AFDSC.
         OACDROP R1                                                 MVS
         FREEMAIN R,LV=(0),A=(1)        FREE OACNOW RESULTS     .AFDSC.
         PUT   DCB,TTLBUFF              GO DUMP THE TITLE          LDW1
         B     PUTOUT                   NOW TRY THAT AGAIN
         SPACE 1
*        SYNAD : AND I/O ERROR HAS OCCURED.
         SPACE 1
OSYNAD   OI    OFLAGS,OIOERROR          SIGNAL ERROR
         BR    R14                      AND RETURN
         EJECT
NOWPARM  DSECT                          NOWSVC (SSVC0) PARMLIST   *VIC*
         SPACE 1
TIME24   DS    0CL12                    TIME 24-HR....HH:MM:SS PST*VIC*
TIME24HR DS    2C,C                     HH:                       *VIC*
TIME24MN DS    2C,C                     MM:                       *VIC*
TIME24SC DS    2C                       SS                        *VIC*
         DS    C                        BLANK                     *VIC*
TIME24TZ DS    3C                       PST OR PDT                *VIC*
         DS    2C                       BLANKS                    *VIC*
         SPACE 1
NUMDATE  DS    0CL8                     THE DATE: (M)M/(D)D/YY    *VIC*
MO       DS    2C,C                     (M)M/                     *VIC*
DAY      DS    2C,C                     (D)D/                     *VIC*
YEAR     DS    2C                       YY                        *VIC*
         DS    2C                       BLANKS                    *VIC*
         SPACE 1
WEEKDAY  DS    9C                       THE WEEKDAY               *VIC*
         DS    C                        BLANK                     *VIC*
         SPACE 1
CHARDATE DS    13C                      DATE: MMM(M) (D)D, 19YY   *VIC*
         DS    2C                       BLANKS                    *VIC*
         SPACE 1
TIME12   DS    0CL15                    TIME 12-HR...HH:MM:SS AM PST
TIME12HR DS    2C,C                     HH:                       *VIC*
TIME12MN DS    2C,C                     MM:                       *VIC*
TIME12SC DS    2C,C                     SS + BLANK                *VIC*
AMPM     DS    2C                       AM OR PM                  *VIC*
         DS    C                        BLANK                     *VIC*
TIME12TZ DS    3C                       PDT OR PST                *VIC*
         DS    2C                       BLANKS                    *VIC*
         SPACE 1
JULDATE  DS    0CL6                     THE DATE:  YY.DDD         *VIC*
JULYEAR  DS    2C,C                     YY.                       *VIC*
JULDAY   DS    3C                       DDD                       *VIC*
         SPACE 2
PARMLEN  EQU   *-NOWPARM                LENTGH OF PARMLIST (72)   *VIC*
CSOUT    CSECT                                                    *VIC*
         EJECT
*        C S O U T -- ENQUEUE THE DATA-SET TO PRINT.
         SPACE 1
*        CLOSE THE OUTPUT DATA-SET AND FIND MTABLE.
         SPACE 1
ENQUEUE  LA    R0,DCB                   FIND DCB                   LDW1
         ST    R0,ODBLW                 SAVE IT
         MVI   ODBLW,X'80'              CLOSE JUST THIS ONE
         CLOSE MF=(E,ODBLW)             CLOSE THE DS
         CLC   ODSN(8),=CL8'ZAPLOG'     WAS ZAPLOG PRE-ALLOC    .AFDSC.
         BE    RC00                     YES, BYPASS UNALLOCATE  .AFDSC.
         FREE  DDNAME=ODSN,SYSOUT='A'   AND FREE IT
         B     RC00                     NOW RETURN TO CALLER
         EJECT ,                                                   LDW1
SCRATCH  LA    R0,DCB                   POINT TO DCB               LDW1
         ST    R0,ODBLW                 STORE IN LIST
         MVI   ODBLW,X'80'              MARK AS END OF LIST
         CLOSE MF=(E,ODBLW)             CLOSE IT
         CLC   ODSN(8),=CL8'ZAPLOG'     WAS ZAPLOG PRE-ALLOC    .AFDSC.
         BE    RC00                     YES, BYPASS UNALLOCATE  .AFDSC.
         FREE  DDNAME=ODSN,DISP=DELETE                             LDW1
         B     RC00                     RETURN
         EJECT
*        C S O U T -- CONSTANTS.
         SPACE 1
*TITMSK  DC    CL133'1U C L A / O A C                         *** TSO Z
*              AP  SESSION RECORD          *** DD MMM YY *** HH:MM:SS *
*              ** PAGE _____'                                      LDW4
TITMSK   DC    CL133'1A F D S C                               --- TSO ZX
               AP  SESSION RECORD ---      *** DD MMM YY *** HH:MM *** X
                  PAGE _____'                                   .AFDSC.
         ORG   TITMSK+114
         DC    X'2020202120'
         ORG
         SPACE 1
*        DCB MASK.
         SPACE 1
         PRINT NOGEN
ODCBMSK  DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,RECFM=FBA,LRECL=133,  X
               SYNAD=OSYNAD,BLKSIZE=4123,BUFNO=1                   LDW1
DCBLEN   EQU   *-ODCBMSK
         PRINT GEN
         SPACE 2
*        LITERAL POOL.
         SPACE 1
         LTORG
         EJECT
*        ZAP --- HELP FOR ZAP. (HLP)                               LDW1
         SPACE 1
ZAPHELP  CSECT
         DC    A(NUMHELPS)                                         LDW1
         DC    A(FIRST)                                            LDW1
         DC    AL1(0,0,0,0,0,0,0,0,0,0,0,0,0)    1                 LDW1
         DC    AL1(1,0,1,1,1,1,1,1,1,1,1,1,0)    2                 LDW2
         DC    AL1(0,0,1,1,1,1,1,1,0,0,0,0,0)    3                 LDW4
         DC    AL1(1,0,1,1,1,1,1,1,1,1,1,1,1)    4                 LDW1
         DC    AL1(0,0,1,1,1,1,1,1,1,1,1,1,1)    5                 LDW4
         DC    AL1(1,0,1,1,1,1,1,1,1,1,1,0,0)    6                 LDW3
         DC    AL1(1,0,1,1,1,1,1,1,1,1,1,0,1)    7                 LDW3
         DC    AL1(1,0,1,1,1,1,1,1,1,1,1,1,1)    8                 LDW1
         DC    AL1(1,0,1,1,1,1,1,1,1,1,1,1,1)    9                 LDW1
         DC    AL1(1,0,1,1,1,1,1,1,1,1,1,1,0)    10                LDW4
         DC    AL1(0,0,1,1,1,1,1,1,1,1,1,1,1)    11                LDW4
         DC    AL1(1,1,1,1,1,1,1,1,1,1,1,1,1)    12                LDW1
         DC    AL1(1,0,1,1,1,1,1,1,1,1,1,1,1)    13                LDW2
         SPACE 1
FIRST    DS    0F                                                  LDW1
         SPACE 1
*        IMAGE # 1.                                                LDW1
         SPACE 1
         DC    CL40'                CONTENTS                '      LDW1
         DC    CL40'                                        '      LDW1
         DC    CL40'?1       - THIS SCREEN                  '      LDW2
         DC    CL40'?2, ?3   - GENERAL INFORMATION          '      LDW2
         DC    CL40'?4, ?5   - INPUT/OUTPUT COMMANDS        '      LDW2
         DC    CL40'?6       - SESSION CONTROL COMMANDS     '      LDW2
         DC    CL40'?7       - DUMP COMMANDS                '      LDW2
         DC    CL40'?8       - BYTE COMMANDS                '      LDW2
         DC    CL40'?9       - STRING COMMANDS              '      LDW2
         DC    CL40'?10, ?11 - MISCELLANEOUS COMMANDS       '      LDW2
         DC    CL40'?12      - EXPLANATION OF SYMBOLS       '      LDW2
         DC    CL40'?13      - SAMPLE ZAP SESSION           '      LDW2
         DC    CL40'                                        '      LDW2
         SPACE 1
*        IMAGE # 2.                                                LDW1
         SPACE 1
         DC    CL40'              GENERAL INFO              '      LDW2
         DC    CL40'                                        '      LDW2
         DC    CL40'-- THE OPERANDS ARE ENTERED AFTER THE   '      LDW2
         DC    CL40'   COMMAND, WITH NO INTERVENING BLANKS. '      LDW2
         DC    CL40'-- THE BLOCK IS READ INTO A WORK BUFFER,'      LDW2
         DC    CL40'   WHERE YOU MODIFY IT. WHEN YOU ENTER A'      LDW2
         DC    CL40'   "ZAP" COMMAND, THE BLOCK IS WRITTEN  '      LDW2
         DC    CL40'   BACK TO THE DATA-SET FROM THE BUFFER.'      LDW2
         DC    CL40'   IF ANY OTHER JOB OR USER HAS UPDATED '      LDW2
         DC    CL40'   THAT BLOCK IN BETWEEN WHEN YOU FIRST '      LDW2
         DC    CL40'   DISPLAYED IT AND WHEN YOU "ZAPPED"   '      LDW2
         DC    CL40'   IT, THE OTHER CHANGES WILL BE LOST.  '      LDW2
         DC    CL40'                                        '      LDW2
         SPACE 1
*        IMAGE # 3.                                                LDW2
         SPACE 1
         DC    CL40'        GENERAL INFO (CONTINUED)        '      LDW2
         DC    CL40'                                        '      LDW2
         DC    CL40'-- IF YOU MAKE CHANGES TO A BLOCK, TO   '      LDW2
         DC    CL40'   GO TO ANOTHER BLOCK YOU MUST EITHER  '      LDW2
         DC    CL40'   "ZAP" THE BLOCK (RE-WRITE IT TO THE  '      LDW2
         DC    CL40'   DATA-SET), OR ENTER THE COMMAND TWICE'      LDW4
         DC    CL40'   IN A ROW WHICH WILL CAUSE YOU TO     '      LDW4
         DC    CL40'   LEAVE TO CURRENT MODIFIED BLOCK.     '      LDW4
         DC    CL40'                                        '      LDW4
         DC    CL40'                                        '      LDW4
         DC    CL40'                                        '      LDW2
         DC    CL40'                                        '      LDW2
         DC    CL40'                                        '      LDW2
         SPACE 1                                                   LDW1
*        IMAGE # 4.                                                LDW1
         SPACE 1                                                   LDW1
         DC    CL40'         INPUT/OUTPUT COMMANDS          '      LDW1
         DC    CL40'                                        '      LDW1
         DC    CL40'P<EXP> - POINT TO RECORD WHOSE TTR=EXP  '
         DC    CL40'P      - POINT TO BEGINNING OF DATA-SET '
         DC    CL40'T<EXP> - POINT TO TRACK <EXP>, RECORD 1 '
         DC    CL40'T      - POINT TO NEXT TRACK, RECORD 1  '
         DC    CL40'R<EXP> - SHOW BLOCK <EXP> RELATIVE TO   '       *N*
         DC    CL40'         CURRENT                        '       *N*
         DC    CL40'R      - POINT TO NEXT PHYSICAL RECORD  '       *N*
         DC    CL40'B      - POINT TO PREVIOUS RECORD       '       *N*
         DC    CL40'LAST   - POINT TO LAST RECORD (DS1LSTAR)'       *N*
         DC    CL40'LASTDS1- POINT TO LAST FORMAT 1 IN VTOC '      LDW1
         DC    CL40'ABS<EXP> - POINT TO REC. WITH CCHHR=EXP '      JCJ1
         SPACE 1
*        IMAGE # 5.                                                LDW1
         SPACE 1
         DC    CL40'       MORE INPUT/OUTPUT COMMANDS       '      LDW1
         DC    CL40'                                        '      LDW1
         DC    CL40'%<EXP> - POINT TO TTR @ LOC <EXP> IN    '      LDW1
         DC    CL40'         BLOCK                          '      LDW1
         DC    CL40'M<NAME>- FOR PDS, POINT TO MEMBER <NAME>'       *N*
         DC    CL40'M      - POINT TO START OF THE CURRENT  '      LDW4
         DC    CL40'         MEMBER                         '      LDW4
         DC    CL40'NAME<N>- AFTER ''M'', SHOW ENTRY POINT <N>'     *N*
         DC    CL40'NAME   - SELECT ENTRY POINT NAMED MEMBER'      LDW1
         DC    CL40'E<N>   - SAME AS NAME<N>                '       *N*
         DC    CL40'E      - SAME AS NAME                   '       *N*
         DC    CL40'ZAP    - REPLACE BLOCK FROM THE CURRENT '
         DC    CL40'         BUFFER                         '
         SPACE 1
*        IMAGE # 6.                                                LDW1
         SPACE 1
         DC    CL40'        SESSION CONTROL COMMANDS        '      LDW1
         DC    CL40'                                        '      LDW1
         DC    CL40'LOG      - START LOGGING THIS SESSION   '
         DC    CL40'CRT      - SET WIDTH 4,4 AND VERBOSE    '
         DC    CL40'TERSE    - DO NOT DO AUTO WHERE         '
         DC    CL40'VERBOSE  - ALWAYS GIVE WHERE INFO       '
         DC    CL40'W<D>,<U> - SET WINDOW DOWN/UP SIZE(S)   '
         DC    CL40'WFULL    - SET SIZE TO URSA SCREEN SIZE '
         DC    CL40'LINE40, LINE80 - SET LINE LENGTH 40 | 80'      LDW3
         DC    CL40'NOTE<COMNT>-WRITE <COMNT> INTO LOG FILE '      LDW1
         DC    CL40'EJECT    - EJECT A PAGE IN THE LOG FILE '      LDW1
         DC    2CL40'                                        '     LDW3
         SPACE 1                                                   LDW1
*        IMAGE # 7.                                                LDW1
         SPACE 1                                                   LDW1
         DC    CL40'             DUMP COMMANDS              '      LDW1
         DC    CL40'                                        '      LDW1
         DC    CL40'DUMP       - DUMP ALL RECORDS IN THE    '
         DC    CL40'             DATA-SET IN ABDUMP FORMAT  '
         DC    CL40'DUMPT<EXP> - DUMP TO TTR <EXP> FROM     '
         DC    CL40'             CURRENT RECORD             '
         DC    CL40'DUMPT      - DUMP CURRENT RECORD ONLY   '
         DC    CL40'DUMPF<EXP> - DUMP FOR <EXP> RECORDS FROM'
         DC    CL40'             CURRENT RECORD             '
         DC    CL40'DUMPF      - DUMP CURRENT RECORD        '
         DC    CL40'DUMPE      - DUMP CURRENT RECORD TO EOF '      LDW1
         DC    CL40'                                        '
         DC    CL40'EOF, I/O ERROR OR END-OF-DS : HALT DUMP '
         SPACE 1                                                   LDW1
*        IMAGE # 8.                                                LDW1
         SPACE 1                                                   LDW1
         DC    CL40'             BYTE COMMANDS              '      LDW1
         DC    CL40'                                        '      LDW1
         DC    CL40'D<EXP> - DISPLAY BYTE AT OFFSET <EXP>   '
         DC    CL40'<EXP>  - SAME AS D<EXP>                 '
         DC    CL40'D      - PAGE TO NEXT SCREEN (D+#SCREEN)'      LDW1
         DC    CL40'U      - PAGE TO PREV SCREEN (D-#SCREEN)'      LDW1
         DC    CL40'>      - GO FORWARD IN TRACE TABLE      '
         DC    CL40'<      - GO BACKWARD IN TRACE TABLE     '
         DC    CL40'EBCDIC - EBCDIC TRANSLATION (DEFAULT)   '
         DC    CL40'ASCII  - ASCII-8 TRANSLATION            '
         DC    CL40'ZCODE  - ZCODE TRANSLATION              '
         DC    CL40'=<LAB> - DEFINE <LAB> TO CURRENT LOC    '
         DC    CL40'NODEF  - CLEAR ALL DEFINED LABELS FROM ='
         SPACE 1                                                   LDW1
*        IMAGE # 9.                                                LDW1
         SPACE 1                                                   LDW1
         DC    CL40'            STRING COMMANDS             '      LDW1
         DC    CL40'                                        '      LDW1
         DC    CL40'S<STR>   - STORE <STR> AT CURRENT LOC   '
         DC    CL40'X<STR>   - EXCLUSIVE OR AT CURRENT LOC  '
         DC    CL40'O<STR>   - OR AT CURRENT LOC            '
         DC    CL40'N<STR>   - AND AT CURRENT LOC           '
         DC    CL40'SET<STR> - SET ENTIRE RECORD TO <STR>   '
         DC    CL40'           S,X,O,N,SET MAY BE ENTERED   '
         DC    CL40'           ALONE TO USE PREVIOUS <STR>  '
         DC    CL40'L<STR>   - LOOK FOR <STR> FROM NEXT BYTE'
         DC    CL40'L        - CONTINUE LOOKING FOR <STR>   '
         DC    CL40'F<STR>   - LIKE L<STR>, CONT''S PAST EOFS'     LDW1
         DC    CL40'F        - LIKE L, CONTINUES PAST EOFS  '      LDW1
         SPACE 1                                                   LDW1
*        IMAGE # 10.                                               LDW1
         SPACE 1                                                   LDW1
         DC    CL40'         MISCELLANEOUS COMMANDS         '      LDW1
         DC    CL40'                                        '      LDW1
         DC    CL40'END    - EXIT ZAP                       '
         DC    CL40'#<EXP> - FIND HEX/DECIMAL VALUE OF <EXP>'
         DC    CL40'FLOAT<F> - FIND FLOATING PT VALUE OF <F>'
         DC    CL40'IDEF   - DISPLAY DEFINE LABEL TABLE     '
         DC    CL40'ITRACE - DISPLAY TRACE TABLE            '
         DC    CL40'?N     - VIEW NTH HELP DISPLAY (1-13)   '      LDW1
         DC    CL40'WHERE  - GIVE CURRENT LOCATION ETC...   '
         DC    CL40'ASM<OP> - GIVE OBJECT CODE FOR MNEMONIC '
         DC    CL40'DISASM<EXP> - DISASSEMBLE INSTRUCTION   '      LDW1
         DC    CL40'         AT <EXP>                       '      LDW1
         DC    CL40'CAPSON/CAPSOFF - FOR STRING COMMANDS    '  -EU-LDW4
         SPACE 1
*        IMAGE # 11.                                               LDW1
         SPACE 1
         DC    CL40'      MORE MISCELLANEOUS COMMANDS       '      LDW1
         DC    CL40'                                        '      LDW1
         DC    CL40'WHATMEM  - FIND DIRECTORY ENTRY CLOSEST '      LDW4
         DC    CL40'           TO CURRENT RECORD            '      LDW4
         DC    CL40'WM       - SAME AS WHATMEM              '      LDW4
         DC    CL40'DO<CMD>  - EXECUTE TSO <CMD> AS AT READY'      LDW1
         DC    CL40'V<EXP>   - ADD CONTENTS OF 2 BYTES AT   '      LDW5
         DC    CL40'           <EXP> TO CURRENT VALUE OF LOC'      LDW5
         DC    CL40'BASE<EXP>- ADD <EXP> TO BUFFER OFFSET   '      LDW1
         DC    CL40'           WHEN COMPUTING ADDRESS       '      LDW1
         DC    CL40'DISP<TYPE> - SET RECORD DISPLAY START   '      LDW1
         DC    CL40'           POS. <TYPE> IS COUNT-KEY-DATA'      LDW1
         DC    CL40'J<TTR>   - REL. TO BEGINING OF VOLUME   '      LDW5
         SPACE 1                                                   LDW1
*        IMAGE # 12.                                               LDW1
         SPACE 1                                                   LDW1
         DC    CL40'<EXP> IS COMPOSED OF OPERATORS (+,-,*,/)'      LDW1
         DC    CL40'    DEFINE SYMBOLS (''='' COMMAND) AND    '
         DC    CL40'    HEX OR DEC CONSTANTS. THE FOLLOWING '
         DC    CL40'    SYMBOLS ARE PREDEFINED : * = CURRENT'
         DC    CL40'    OFFSET, L = LOGICAL RECORD LENGTH,  '
         DC    CL40'    K = KEY LENGTH, BL = MAX. BLKSIZE.  '
         DC    CL40'<STR> MAY BE EITHER UP TO 16 CHARACTERS '
         DC    CL40'    ENCLOSED IN ANY DELIMITER, OR UP    '
         DC    CL40'    TO 16 HEX DIGITS, OR A DECIMAL VALUE'
         DC    CL40'    ENDING WITH ''.'' (LENGTH 4 BYTES). '
         DC    CL40'<LAB> MAY ANY 1 TO 8 CHARACTERS.        '
         DC    CL40'<F>   IS ANY FLOATING POINT CONSTANT IN '
         DC    CL40'    INTERNAL FORM (IE : FORTRAN A FORM).'
         SPACE 1
*        IMAGE # 13.                                               LDW2
         SPACE 1
         DC    CL40'           SAMPLE ZAP SESSION           '      LDW2
         DC    CL40'                                        '      LDW2
         DC    CL40'ZAP LOAD   READY LEVEL COMMAND ENTERED  '      LDW2
         DC    CL40'MTEST      SELECT MEMBER "TEST"         '      LDW2
         DC    CL40'EFIRST     SELECT ENTRY POINT "FIRST"   '      LDW2
         DC    CL40'4C         GO TO OFFSET X''4C'' IN RECORD '    LDW2
         DC    CL40'S00        STORE ONE BYTE HEXADECIMAL   '      LDW2
         DC    CL40'+4         ADVANCE PTR 4 BYTES IN BLOCK '      LDW2
         DC    CL40'NFF0F      TURN OFF ONE NIBBLE          '      LDW2
         DC    CL40'ZAP        RE-WRITE THAT BLOCK          '      LDW2
         DC    CL40'R+3        GO TO THIRD BLOCK FROM HERE  '      LDW2
         DC    CL40'L/HELLO/   FIND SOME TEXT               '      LDW2
         DC    CL40'END        ALL DONE - EXIT ZAP          '      LDW2
         SPACE 2
NUMHELPS EQU   (*-FIRST)/40                                        LDW1
         EJECT
*        ZAP --- ASMGASM --- OP CODE PARSE. (ASM)                  LDW1
         SPACE 1
*        ASSEMBLE OR DISASSEMBLE.
         SPACE 1
ASMGASM  CSECT ,
         SAVE  (14,12),,*
         LR    R12,R15                  BASE
         USING ASMGASM,R12
         LTR   R1,R1                    ASM OR DISASM?
         BM    DISASMIT                 GUESS...                   LDW1
         SPACE 1
*        ASM  ---  R1 = PTR TO CL4'MNEMONIC'.
         SPACE 1
         LA    R2,OPCODES               TABLE
         L     R15,=A(OPEND-OPLEN)      END BXLE
         LA    R14,OPLEN                LENGTH
OPLOOP   CLC   0(4,R1),0(R2)            THIS ONE (KLUGE)
         BE    GOTOP                    YES
         BXLE  R2,R14,OPLOOP            TRY ALL POSSIBLES
BADRET   LA    R15,4                    INVALID OP CODE
         B     RETURN                   BYE
GOTOP    LA    R1,5(,R2)                POINT TO OP IN HEX
GOODRET  XR    R15,R15                  RC=0
RETURN   L     R14,12(,R13)             RESTORE R14  **** NOTE R0 NOT
         LM    R2,R12,12+16(R13)        REST REGS         RESTORED ****
         BR    R14                      BYE
         SPACE 1
*  DISASM  ---  R1 = PTR TO BUFF LOC OF OBJECT CODE
*               R0 = PTR TO OUTPUT BUFFER  (33 BYTES)
*               R2 = PTR TO 5 DOUBLEWORDS WORKAREA
*      OUTPUT : R15= RC
*               R1 = INSTR LEN IF R15=0
         SPACE 1
DISASMIT LPR   R1,R1                    GET POS 1ST                LDW1
         LR    R7,R2                    SAVE WORK BASE
         LR    R9,R0                    SAVE OUTPUT BUFF PTR
         SPACE 2
JCJWORK  DSECT
DOUBLE   DS    D
DBL      DS    D                                                   LDW1
EDITWORK DS    6C                                                  LDW1
FLAGS    DS    X
         SPACE 2
ASMGASM  CSECT ,
         USING JCJWORK,R7
         SPACE 1
*        THIS ROUTINE WRITTEN BY JCJ 1/75.
         SPACE 1
         MVC   DBL(8),0(R1)             ALIGN POSSIBLE INSTRUCTION LDW1
         LA    R6,DBL                   POINT TO INSTR             LDW1
         SPACE 1
***********************************************************************
* DISASSEM                                                            *
* RETURNS :                                                           *
*        R15 - LENGTH OF INSTRUCTION OR ZERO IF NON-VALID OPCODE.     *
*              FILLED IN SCREEN BUFFER IF OPCODE WAS VALID.           *
* NOTE : WE GO THROUGH SOME CONTORTIONS IN ORDER TO BE ABLE TO        *
*        SPECIFY THE OPCODE FLAG FIELDS IN EBCDIC CHARACTER FORM      *
*        (IMAGE-ENTERABLE).                                           *
***********************************************************************
         SPACE 1
         XR    R15,R15                  READY FOR IC
         XR    R2,R2                    CLEAR TRT REG
         TRT   0(1,R6),OPTAB            TRANSLATE THE OPCODE
         BZ    BADRET                   BRANCH IF NON-VALID OPCODE
         LA    R4,1                     GET F'1' FOR LATER
         SLR   R2,R4                    FIX FOR PROPER TABLE INDEX
         MH    R2,H6                    GET OFFSET INTO TABLE
         LA    R1,OPCODES(R2)           PNT TO PROPER MNENOMIC
         MVC   0(4,R9),0(R1)            MOVE IN MNENOMIC
         MVC   FLAGS(1),4(R1)           GET THE FLAG BYTE
         IC    R15,1(,R6)               GET THE REG BYTE
         LR    R2,R15                   GET IT IN R2 FOR LATER
         SPACE 1
*        NOW CHECK IF IT IS AN EXTENDED MNENOMIC INSTRUCTION.
         SPACE 1
         TM    FLAGS,X'04'              EXTENDED MNENOMIC FLAG ON?
         BZ    GETTYPE                  NO, GO ON WITH THE REST
         TM    FLAGS,X'02'              INDEX REG FLAG ON?
         BZ    GETMNE                   NO, GO GET THE MMENOMIC
         SPACE 1
*        GETMNE RETURNS TO GETINST - WE DON'T CARE IF WE GO THROUGH
*        THIS CODE FOR NON-MNENOMICS THOUGH.
         SPACE 1
GETINST  CLI   1(R9),C'C'               GOT AN EXTENDED MNENOMIC?
         BNE   *+L'*+4                  YES, SKIP THE BIT RESET
         OI    FLAGS,X'02'              NO, FAKE OUT A RR(OR RX) TYPE
GETTYPE  CLC   0(4,R9),OPCODES          IS IT SPM?
         LA    R9,7(,R9)                INCREMENT LINE PNTR
         BNE   GETTYPE#                 NO, SKIP FLAG RESET/BRANCH
         MVI   FLAGS,C'<'               RESET FLAG FOR LATER TEST
         B     GETRR#                   AND GO PROCESS SPM
GETTYPE# TM    FLAGS,X'90'              IS LENGTH FOUR BYTES?
         BZ    GETRR                    NO, GET 2 BYTE INSTRUCTION
         BM    GETSS                    NO, GET 6 BYTE INSTRUCTION
         SPACE 1
*        HAVE AN FOUR BYTE TYPE WHEN WE FALL THROUGH TO HERE.
         SPACE 1
         CLI   FLAGS,C'M'  (GETRX)      DO WE WANT A REGISTER?
         BNH   RXDISP                   NO, GO GET DISP FIELD
         LR    R2,R15                   GET REG BYTE BACK
         SRDL  R2,4                     SHIFT TO GET FIRST REG
         BAS   R14,GETNUM               PUT CHAR VALUE IN SCREEN
         BAS   R14,COMMA                PUT IN A COMMA
         CLI   FLAGS,C'R'               TWO REGISTERS NEEDED?
         BNE   RXDISP                   NO, GET DISPLACEMENT
         SLDL  R2,4                     GET THE OTHER REG
         BAS   R14,GETNUM               AND PUT IT IN SCREEN
         BAS   R14,COMMA                MOVE IN A COMMA
RXDISP   BAS   R5,GETDISP               GET THE DISP FIELD
         TM    FLAGS,X'04'              NEED AN INDEX REG?
         BZ    RXNOIND                  NO, GET THE BASE ONLY
         SLDL  R2,4                     AND PICK UP THE INDEX REG
         BAS   R14,GETNUM               PUT IT IN SCREEN
         BAS   R14,COMMA                MOVE IN A COMMA
RXNOIND  BAS   R5,GETBASE               GET THE BASE BYTE
         CLI   FLAGS,C'L'               IMMEDIATE TYPE?
         BNE   DISLEAVE                 NO, LEAVE
         SPACE 1
*        WE HAVE AN SI TYPE HERE.
         SPACE 1
         MVC   0(3,R9),SICHAR           MOVE IN ,X'
         HEX   (3,R9),(1,R6),LEN=1,HEXTAB=HEXTAB,BYTE=C''''        LDW1
         B     DISLEAVE                 AND LEAVE
         SPACE 1
*        TWO BYTE INSTRUCTIONS.
         SPACE 1
GETRR    LR    R2,R15                   GET REG BYTE BACK
         CLI   FLAGS,C'+'               SVC?
         BE    RRSVC                    YES, GO PROCESS IT
         BL    MNENT                    EXTENDED MNENOMIC HERE
GETRR#   SRDL  R2,4                     GET FIRST REGISTER VALUE
         BAS   R14,GETNUM               MOVE IN THE CHAR VALUE
         CLI   FLAGS,C'<'               SPM INST?
         BE    DISLEAVE                 YES, LEAVE
         BAS   R14,COMMA                MOVE IN A COMMA
MNENT    XR    R2,R2                    ZERO PARM REG
         SLDL  R2,4                     GET OTHER REG
RRSVC    BAS   R14,GETNUM               MOVE IN THE CHAR AGAIN
         B     DISLEAVE                 GO AWAY
         SPACE 1
*        THIS SECTION HANDLES 6 BYTE INSTRUCTIONS.
         SPACE 1
GETSS    LR    R0,R2                    SAVE THE REG BYTE (LENGTH)
         BAS   R5,GETDISP               GEN FIRST DISPLACEMENT
         LR    R2,R0                    GET THE REG BYTE BACK
         TM    FLAGS,X'01'              ONLY ONE LENGTH FIELD?
         BO    *+L'*+4                  YES, SKIP THE REG SHIFT
         SRDL  R2,4                     GET THE FIRST LENGTH FIELD
         BAS   R14,GETNUMI              MOVE IN THE CHAR VALUE
         BAS   R14,COMMA                MOVE IN A COMMA
         BAS   R5,GETBASE               GET THE BASE FIELD
         BAS   R14,COMMA                MOVE IN A COMMA
         LH    R2,4(,R6)                GET SECOND DISP FIELD
         BAS   R5,GETDISP#              MOVE IT TO THE SCREEN
         TM    FLAGS,X'01'              SINGLE LENGTH?
         BO    SSL1                     YES, SKIP 2ND LEN PROCESSING
         SLDL  R2,4                     GET 2ND LENGTH
         BAS   R14,GETNUMI              AND MOVE IT TO SCREEN
         BAS   R14,COMMA                A DELIMITER OR TWO
SSL1     IC    R2,4(,R6)                GET SECOND BASE FIELD
         BAS   R5,GETBASE#              GET THE BASE IN SCREEN
DISLEAVE TM    FLAGS,X'10'              DO WE HAVE A BAD LENGTH?
         BZ    *+L'*+4                  NO, HOP OVER THE BIT RESET
         NI    FLAGS,255-X'40'          FIX FOR CORRECT LENGTH
         XR    R1,R1                    SET UP FOR IC
         IC    R1,FLAGS                 GET THE LENGTH
         SRL   R1,5                     WIPE OUT FLAG BITS  = LENGTH
         B     GOODRET                  EXIT OK
         SPACE 1
*        EXTENDED MNENOMIC ROUTINE.
         SPACE 1
GETMNE   SRDL  R2,4                     SHIFT TO CLEAR OUT REG NIBBLE
         MH    R2,H6                    INDEX INTO TABLE
         LA    R1,MNEOPS(R2)            PNT TO TABLE ENTRY
         MVC   0(3,R9),0(R1)            MOVE IN PRIMARY MNEMONIC
         CLI   3(R1),C' '               SECONDARY MNENOMIC PRESENT?
         BE    GETMNE#                  NO, CONTINUE ON
         MVC   5(3,R9),3(R1)            GET SECONDARY ONE
         LR    R14,R9                   SAVE CURR BUFFER PNTR
         AH    R9,H6                    AND UP WORK BUFFER PNTR
GETMNE#  TM    FLAGS,X'80'              NON 2 BYTE INSTRUCTION?
         BO    GETINST                  YES, LEAVE
         CLI   3(R1),C' '               TWO MNENOMICS NEEDED?
         BE    ONEMNE                   NO, SO DO ONE DUMMY...
         BAS   R5,RLOOP                 PUT IN A 'R' (RR TYPE)
ONEMNE   LR    R14,R9                   PNT TO CURR MNEMONIC
         LA    R5,GETINST               FAKE OUT A BAS AND RETURN
RLOOP    ALR   R14,R4                   PNT TO NEXT CHAR
         CLI   0(R14),C' '              A BLANK WAITING FOR 'R'?
         BNE   RLOOP                    NO, INCREMENT
         MVI   0(R14),C'R'              YES, PUT IN THE 'R'
         BR    R5                       AND GO HOME
         EJECT
*        U T I L I T Y     R O U T I N E S.
         SPACE 1
*        DISASSEMBLER BAS ROUTINES - USED TO SAVE BYTES HERE AND THERE.
*        THIS SECTION GETS THE BASE REG.
         SPACE 1
GETBASE  IC    R2,2(,R6)                GET THE BASE
GETBASE# SRL   R2,4                     SHIFT OUT GARBAGE
         BAS   R14,GETNUM               GO MOVE TO SCREEN
         MVI   0(R9),C')'               PUT IN A R-PAREN
         ALR   R9,R4                    INCREMENT LINE PNTR
         BR    R5                       GO TO CALLER
         SPACE 1
*        THIS SECTION GETS THE DISPLACEMENT FIELD.
         SPACE 1
GETDISP  LH    R2,2(,R6)                LOAD THE DISPLACEMENT
GETDISP# N     R2,DISPMASK              WIPE OUT BASE BITS
         BAS   R14,GETNUM               DO THE MOVE TO SCREEN
         CLI   FLAGS,C'J'               IS IT SVCX OR DIAGNOSE?
         BE    DISLEAVE                 YES, GO AWAY
         MVI   0(R9),C'('               ELSE MOVE IN A L-PAREN
         ALR   R9,R4                    INCREMENT LINE PNTR
         BR    R5                       GO TO CALLER
COMMA    MVI   0(R9),C','               MOVE IN A COMMA
         ALR   R9,R4                    INCREMENT PNTR
         BR    R14                      GO TO CALLER
         SPACE 1
*        THIS ROUTINE PUTS THE CHAR VALUE OF THE CONTENTS OF
*        R2 INTO THE SCREEN (VIA R9) AND UPDATES R9 (POINT TO
*        THE NEXT AVAILABLE POSITION).
         SPACE 1
GETNUMI  ALR   R2,R4                    INCREMENT FOR A LENGTH FIX
GETNUM   CVD   R2,DOUBLE                GET IT IN DECIMAL
         MVC   EDITWORK(6),EDITMASK     SET UP FOR EDIT
         LA    R15,EDITWORK+5           PNT TO END OF AREA
         LR    R1,R15                   SET UP R1 FOR EDMK
         EDMK  EDITWORK(6),DOUBLE+5     DO THE EDIT
         SR    R15,R1                   GET THE EXECUTE LENGTH
         EX    R15,NUMMOVE              MOVE THE VALUE TO THE SCREEN
         LA    R9,1(R15,R9)             UPDATE THE SCREEN PNTR
         XR    R2,R2                    ZERO OUR WORK REG
         BR    R14                      GO HOME
NUMMOVE  MVC   0(0,R9),0(R1)            << EXECUTED >>
         EJECT
*        D A T A.
         SPACE 1
DISPMASK DC    0F'0',XL4'00000FFF'
H6       DC    H'6'
EDITMASK DC    X'402020202120'
SICHAR   DC    C',X'''
         DC    C'0123456789ABCDEF'
HEXTAB   EQU   *-256
         SPACE 2
*        E X T E N D E D   M N E N O M I C   T A B L E.
         SPACE 1
MNEOPS   DC    CL6'NOP   '
         DC    CL6'BO    '
         DC    CL6'BH BP '
         DC    CL6'BC    '
         DC    CL6'BL BM '
         DC    CL6'BC    '
         DC    CL6'BC    '
         DC    CL6'BNEBNZ'
         DC    CL6'BE BZ '
         DC    CL6'BC    '
         DC    CL6'BC    '
         DC    CL6'BNLBNM'
         DC    CL6'BC    '
         DC    CL6'BNHBNP'
         DC    CL6'BNO   '
         DC    CL6'B     '
         SPACE 2
*        O P C O D E   T R A N S L A T E   T A B L E.
         SPACE 1
*OPTAB   DC    X'0000000001020304050607000000000008090A0B0C0D0E0F'
*LDW1    DC    X'101112131415161718191A1B1C1D1E1F2021222324252627'
*LDW1    DC    X'28292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F'
*LDW1    DC    X'404142434400454647480000494A4B4C4D4E4F5051525354'
*LDW1    DC    X'55000000000000565758595A5B5C5D5E5F00000000000000'
*LDW1    DC    X'60616263646566676800696A6B6C6D6E6F70717273747576'
*LDW1    DC    X'7778797A7B7C7D7E7F000000808182830000000000000000'
*LDW1    DC    X'000000000000000000000000000000000000000000000000'
*LDW1    DC    X'00000000000000000000000000000000008485868788898A'
*LDW1    DC    X'000000008B8C8D8E00000000000000000000000000000000'
*LDW1    DC    X'008F9091000000009293949596970000'
         SPACE 1                                                   LDW1
OPTAB    DC    AL1(@00,@00,@00,@00,@04,@05,@06,@07)                LDW1
         DC    AL1(@08,@09,@0A,@0B,@00,@0D,@0E,@0F)            -EU-LDW1
         DC    AL1(@10,@11,@12,@13,@14,@15,@16,@17)                LDW1
         DC    AL1(@18,@19,@1A,@1B,@1C,@1D,@1E,@1F)                LDW1
         DC    AL1(@20,@21,@22,@23,@24,@25,@26,@27)                LDW1
         DC    AL1(@28,@29,@2A,@2B,@2C,@2D,@2E,@2F)                LDW1
         DC    AL1(@30,@31,@32,@33,@34,@35,@36,@37)                LDW1
         DC    AL1(@38,@39,@3A,@3B,@3C,@3D,@3E,@3F)                LDW1
         DC    AL1(@40,@41,@42,@43,@44,@45,@46,@47)                LDW1
         DC    AL1(@48,@49,@4A,@4B,@4C,@4D,@4E,@4F)            -EU-LDW1
         DC    AL1(@50,@51,@00,@00,@54,@55,@56,@57)                LDW1
         DC    AL1(@58,@59,@5A,@5B,@5C,@5D,@5E,@5F)                LDW1
         DC    AL1(@60,@00,@00,@00,@00,@00,@00,@67)                LDW1
         DC    AL1(@68,@69,@6A,@6B,@6C,@6D,@6E,@6F)                LDW1
         DC    AL1(@70,@00,@00,@00,@00,@00,@00,@00)                LDW1
         DC    AL1(@78,@79,@7A,@7B,@7C,@7D,@7E,@7F)                LDW1
         DC    AL1(@80,@00,@82,@83,@84,@85,@86,@87)                LDW1
         DC    AL1(@88,@89,@8A,@8B,@8C,@8D,@8E,@8F)                LDW1
         DC    AL1(@90,@91,@92,@93,@94,@95,@96,@97)                LDW1
         DC    AL1(@98,@00,@00,@00,@9C,@9D,@9E,@9F)                LDW1
         DC    AL1(@00,@00,@00,@00,@00,@00,@00,@00)                LDW1
         DC    AL1(@00,@00,@00,@00,@AC,@AD,@AE,@AF)                LDW1
         DC    AL1(@00,@B1,@B2,@00,@00,@00,@B6,@B7)                LDW1
         DC    AL1(@00,@00,@BA,@BB,@00,@BD,@BE,@BF)                LDW1
         DC    AL1(@00,@00,@00,@00,@00,@00,@00,@00)                LDW1
         DC    AL1(@00,@00,@00,@00,@00,@00,@00,@00)                LDW1
         DC    AL1(@00,@D1,@D2,@D3,@D4,@D5,@D6,@D7)                LDW1
         DC    AL1(@00,@00,@00,@00,@DC,@DD,@DE,@DF)                LDW1
         DC    AL1(@00,@00,@00,@00,@00,@00,@00,@00)                LDW1
         DC    AL1(@00,@00,@00,@00,@00,@00,@00,@00)                LDW1
         DC    AL1(@F0,@F1,@F2,@F3,@00,@00,@00,@00)                LDW1
         DC    AL1(@F8,@F9,@FA,@FB,@FC,@FD,@00,@00)                LDW1
         EJECT
*        O P C O D E   T A B L E.
         SPACE 1
* RR TYPE :
*    C'(',X'4D' - EXTENDED MNEMONIC
*    C'+',X'4E' - SVC       IMED
*    C'|',X'4F' - NORMAL RR TYPE
*    C'&',X'50' - SPM TYPE
*
* RX TYPE :
*    C'O',X'D6' - INDEX REGISTER USED   R1,D2(X2,B2)
*    C'M',X'D4' - EXTENDED MNENOMIC     D2(X2,B2)
*    C'L',X'D3' - SI TYPE               D1(B1),I2
*    C'J',X'D1' - DIAGNOSE,SVCX   IMED  I
*    C'K',X'D2' - DISP(BASE) TYPE       D1(B1)
*    C'R',X'D9' - BXLE,BXH,STM,LM       R1,R3,D2(B2)
*    C'Q',X'D8' - REG SHIFT TYPE        R1,D2(B2)
*
* SS TYPE :
*    C'S',X'E2' - TWO LENGTHS REQUIRED
*    C'T',X'E3' - ONLY ONE LENGTH
*
*  TABLE FORMAT :
*        CL4'MNEMONIC',C'FLAG',X'OPCODE'
         SPACE 1
         PRINT NOGEN
OPCODES  DS    0C
@00      EQU   0                        FOR UNDEFINED OPCODES      LDW1
         OP    SPM,|,04
         OP    BALR,|,05
         OP    BCTR,|,06
         OP    BCR,'(',07
         OP    SSK,|,08
         OP    ISK,|,09
         OP    SVC,+,0A
         OP    BSM,|,0B                                            -EU-
         OP    BASR,|,0D                                           -EU-
         OP    MVCL,|,0E                                           LDW1
         OP    CLCL,|,0F                                           LDW1
         OP    LPR,|,10
         OP    LNR,|,11
         OP    LTR,|,12
         OP    LCR,|,13
         OP    NR,|,14
         OP    CLR,|,15
         OP    OR,|,16
         OP    XR,|,17
         OP    LR,|,18
         OP    CR,|,19
         OP    AR,|,1A
         OP    SR,|,1B
         OP    MR,|,1C
         OP    DR,|,1D
         OP    ALR,|,1E
         OP    SLR,|,1F
         OP    LPDR,|,20
         OP    LNDR,|,21
         OP    LTDR,|,22
         OP    LCDR,|,23
         OP    HDR,|,24
         OP    LRDR,|,25
         OP    MXR,|,26
         OP    MXDR,|,27
         OP    LDR,|,28
         OP    CDR,|,29
         OP    ADR,|,2A
         OP    SDR,|,2B
         OP    MDR,|,2C
         OP    DDR,|,2D
         OP    AWR,|,2E
         OP    SWR,|,2F
         OP    LPER,|,30
         OP    LNER,|,31
         OP    LTER,|,32
         OP    LCER,|,33
         OP    HER,|,34
         OP    LRER,|,35
         OP    AXR,|,36
         OP    SXR,|,37
         OP    LER,|,38
         OP    CER,|,39
         OP    AER,|,3A
         OP    SER,|,3B
         OP    MER,|,3C
         OP    DER,|,3D
         OP    AUR,|,3E
         OP    SUR,|,3F
         OP    STH,O,40
         OP    LA,O,41
         OP    STC,O,42
         OP    IC,O,43
         OP    EX,O,44
         OP    BAL,O,45
         OP    BCT,O,46
         OP    BC,M,47
         OP    LH,O,48
         OP    CH,O,49
         OP    AH,O,4A
         OP    SH,O,4B
         OP    MH,O,4C
         OP    BAS,O,4D                                            -EU-
         OP    CVD,O,4E
         OP    CVB,O,4F
         OP    ST,O,50
         OP    SVCX,J,51
         OP    N,O,54
         OP    CL,O,55
         OP    O,O,56
         OP    X,O,57
         OP    L,O,58
         OP    C,O,59
         OP    A,O,5A
         OP    S,O,5B
         OP    M,O,5C
         OP    D,O,5D
         OP    AL,O,5E
         OP    SL,O,5F
         OP    STD,O,60
         OP    MXD,O,67
         OP    LD,O,68
         OP    CD,O,69
         OP    AD,O,6A
         OP    SD,O,6B
         OP    MD,O,6C
         OP    DD,O,6D
         OP    AW,O,6E
         OP    SW,O,6F
         OP    STE,O,70
         OP    LE,O,78
         OP    CE,O,79
         OP    AE,O,7A
         OP    SE,O,7B
         OP    ME,O,7C
         OP    DE,O,7D
         OP    AU,O,7E
         OP    SU,O,7F
         OP    SSM,K,80
         OP    LPSW,K,82
         OP    DIAG,J,83
         OP    WRD,L,84
         OP    RDD,L,85
         OP    BXH,R,86
         OP    BXLE,R,87
         OP    SRL,Q,88
         OP    SLL,Q,89
         OP    SRA,Q,8A
         OP    SLA,Q,8B
         OP    SRDL,Q,8C
         OP    SLDL,Q,8D
         OP    SRDA,Q,8E
         OP    SLDA,Q,8F
         OP    STM,R,90
         OP    TM,L,91
         OP    MVI,L,92
         OP    TS,K,93
         OP    NI,L,94
         OP    CLI,L,95
         OP    OI,L,96
         OP    XI,L,97
         OP    LM,R,98
         OP    SIO,K,9C
         OP    TIO,K,9D
         OP    HIO,K,9E
         OP    TCH,K,9F
         OP    STNSM,L,AC                                          LDW1
         OP    STOSM,L,AD                                          LDW1
         OP    SIGP,R,AE                                           LDW1
         OP    MC,L,AF                                             LDW1
         OP    LRA,O,B1                                            LDW1
         OP    S370,K,B2                                           LDW1
         OP    STCTL,R,B6                                          LDW1
         OP    LCTL,R,B7                                           LDW1
         OP    CS,R,BA                                             LDW1
         OP    CDS,R,BB                                            LDW1
         OP    CLM,R,BD                                            LDW1
         OP    STCM,R,BE                                           LDW1
         OP    ICM,R,BF                                            LDW1
         OP    MVN,C,D1
         OP    MVC,C,D2
         OP    MVZ,C,D3
         OP    NC,C,D4
         OP    CLC,C,D5
         OP    OC,C,D6
         OP    XC,C,D7
         OP    TR,C,DC
         OP    TRT,C,DD
         OP    ED,C,DE
         OP    EDMK,C,DF
         OP    SRP,S,F0                                            LDW1
         OP    MVO,B,F1
         OP    PACK,B,F2
         OP    UNPK,B,F3
         OP    ZAP,B,F8
         OP    CP,B,F9
         OP    AP,B,FA
         OP    SP,B,FB
         OP    MP,B,FC
         OP    DP,B,FD
OPEND    EQU   *
OPLEN    EQU   6
         SPACE 2
         LTORG
         SPACE 2
         CVT   DSECT=YES,LIST=YES                                  -EU-
         IKJTCB ,                                                  -EU-
         IEZJSCB ,                                                 -EU-
         DCBD  DSORG=DA                                            -EU-
TIODSECT DSECT ,                                                   -EU-
         IEFTIOT1 ,                                                -EU-
UCB      DSECT ,                                                   -EU-
         IEFUCBOB ,                                                -EU-
         IEZDEB LIST=YES                                           -EU-
         SPACE 2
         END
