QSP      TITLE '--- QUEUE/SP - JES2 V2.R2.L0 ---'
         SPACE 1
***********************************************************************
*                                                                     *
* THIS IS THE FAMOUS AND WELL KNOWN TSO COMMAND                       *
*                                                                     *
*        QQQQ       U    U      EEEEE       U    U      EEEEE         *
*       Q    Q      U    U      E           U    U      E             *
*       Q    Q      U    U      E           U    U      E             *
*       Q    Q      U    U      EEEE        U    U      EEEE          *
*       Q    Q      U    U      E           U    U      E             *
*       Q  Q Q      U    U      E           U    U      E             *
*        QQQQ        UUUU       EEEEEE       UUUU       EEEEEE        *
*            Q                                                        *
*                                                                     *
***********************************************************************
         SPACE 1
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
* CBT ORIGIN : EXTRACTED FROM CBT TAPE 84 JUN, FILE 149, ADDS BASED   *
*              ON CBT TAPE 85 FEB, FILE 153, AND CBT TAPE 87 FEB,     *
*              FILE 394. VERSION ADAPTED TO JES2 V2R2L0 MVS/XA 2.2.0  *
*              BY : MOINIL P.A. - J.R.C. - ISPRA ESTABLISHMENT        *
*                                 21020 ISPRA (VA), ITALY.            *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
* COMMAND SYNTAX : QSP ...SUB-COMMAND...                              *
*                  THE SUB-COMMAND WILL BE EXECUTED WHEN ENTERING.    *
*                  IF OMITED, THE STATUS OF ALL THE JOBS FOR THE      *
*                  CURRENT SESSION USER-ID (LOGON ID) IS DISPLAYED.   *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
* DEFAULT DATA-SETS NAMES ALLOCATIONS FOR :                           *
*        CHECKPOINT ---> DSNAME=SYS1.HASPCKPT                         *
*        SPOOL SPACE ---> DSNAME=SYS1.HASPACE                         *
* THIS MAY BE ALTERED AS FOLLOWS :                                    *
*        1. ALLOC F(JES2CKPT) DA(...) VOL(...) SHR                    *
*           QSP ...                                                   *
*           THIS ALLOWS :                                             *
*           THE USE OF A SPECIFIC CHECKPOINT DATA-SET,                *
*           THE ASSIGNMENT TO THE SPOOL SPACE DATA-SETS NAMES THE     *
*              SAME PREFIX AS THAT GIVEN FOR THE CHECKPOINT DATA-SET, *
*           AND THE CHECKPOINT DATA-SET IS NOT DE-ALLOCATED AT END.   *
*           I.E. : ALLOC F(JES2CKPT) DA('ALPHA.TESTJES') SHR          *
*                  SPOOL SPACE ---> DSNAME=ALPHA.HASPACE              *
*        2. ALLOC F(...) DA('SYS1.HASPCKPT') VOL(...) SHR             *
*           QSP ...                                                   *
*           THIS ALLOWS :                                             *
*           THE USE OF A SPECIFIC CHECKPOINT DATA-SET,                *
*           THE RETRIEVE FROM IT OF THE SPOOL DATA-SETS SPACES,       *
*           AND ALL DATA-SETS ARE DE-ALLOCATED AT END.                *
*           I.E. : ALLOC F(TESTCKPT) DA('BRAVO.TESTJES') SHR          *
*                  SPOOL SPACE ---> DSNAME=SYS1.HASPACE               *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
         SPACE 1
         PRINT OFF
         MACRO
&NAME    QCALL     &RTN,&R1,&R0,&ERRAD=
         LCLC  &L
&L       SETC  '&NAME'
         AIF   ('&R1' EQ '' OR '&R1' EQ '(R1)').R1OK2
         AIF   ('&R1'(1,1) EQ '(').R1REG
         AIF   ('&R1' EQ '0').R1Z
&L       LA    R1,&R1
         AGO   .R1OK1
.R1Z     ANOP
&L       XR    R1,R1
         AGO   .R1OK1
.R1REG   ANOP
&L       LR    R1,&R1(1)
.R1OK1   ANOP
&L       SETC  ''
.R1OK2   ANOP
         AIF   ('&R0' EQ '' OR '&R0' EQ '(R0)').R0OK2
         AIF   ('&R0'(1,1) EQ '(').R0REG
         AIF   ('&R0' EQ '0').R0Z
&L       LA    R0,&R0
         AGO   .R0OK1
.R0Z     ANOP
&L       XR    R0,R0
         AGO   .R0OK1
.R0REG   ANOP
&L       LR    R0,&R0(1)
.R0OK1   ANOP
&L       SETC  ''
.R0OK2   ANOP
         AIF   ('&RTN' EQ '' OR '&RTN' EQ '(R15)').R15OK2
         AIF   ('&RTN'(1,1) EQ '(').R15REG
&L       L     R15,=A(&RTN)        @ OF ROUTINE
         AGO   .R15OK1
.R15REG  ANOP
&L       LR    R15,&RTN(1)
.R15OK1  ANOP
&L       SETC  ''
.R15OK2  ANOP
&L       BASR  R14,R15
         AIF   ('&ERRAD' EQ '').EXIT
         BNZ   &ERRAD
.EXIT    MEND
         MACRO
&NAME    QSTART    &DUMMY
&NAME    STM   R14,R12,12(R13)     SAVE CALLERS REGS
         USING QCOMMON,R11         COMMON AREA BASE
         LR    R12,R13
         LA    R13,18*4(R13)       PUSH SAVE AREA STACK
         XC    0(18*4,R13),0(R13)  CLEAN NEW SAVE AREA
         ST    R13,8(R12)          CHAIN SAVE AREAS
         ST    R12,4(R13)
         LR    R12,R15             LOCAL BASE REGISTER
         USING &NAME,R12
         MEND
         MACRO
&NAME    QSTOP     &DUMMY
&NAME    L     R13,4(R13)          BACK TO PREVIOUS SAVE AREA
         LM    R2,R12,28(R13)      RESTORE REGISTERS 2-12
         L     R14,12(R13)         RESTORE REGISTER 14
         MVI   12(R13),X'FF'       SET RETURN INDICATOR
         LTR   R15,R15             SET CC ON RETURN CODE
         BR    R14                 RETURN TO CALLER
         MEND
         MACRO
&NAME    QBACK     &DUMMY
&NAME    L     R13,QFRSTSA         GO BACK TO MAIN MODULE
         LM    R14,R12,12(R13)     RESTORE REGS FROM 1ST SAVE AREA
         MVI   12(R13),X'FF'       SET RETURN INDICATOR
         BR    R10                 -> INTERRUPT HANDLER IN QUEUE
         MEND
         MACRO
&NAME    QTILT &MESSAGE,&LENGTH
         LCLA  &L
         LCLC  &N
&N       SETC  '&NAME'
         AIF   ('&MESSAGE' EQ '').SM
&N       LA    R1,=C&MESSAGE       @ OF MESSAGE
&N       SETC  ''
&L       SETA  K'&MESSAGE-2
         AIF   ('&LENGTH' EQ '').SL
         AGO   .TL
.SM      AIF   ('&LENGTH' EQ '').OK
.TL      ANOP
&L       SETA  &LENGTH
.SL      ANOP
&N       LA    R0,&L               LENGTH OF MESSAGE
&N       SETC  ''
.OK      ANOP
&N       L     R15,=A(TILT)        @ TILT ROUTINE
         BR    R15                 TILT, NEVER RETURN
         MEND
         MACRO
&NAME    ZIC   &REG,&ADDR
&NAME    XR    &REG,&REG
         IC    &REG,&ADDR
         MEND
         MACRO
&NAME    QSCT  &SCN,&IND,&CDE,&ADDR
         LCLA  &L
         LCLC  &I,&C
         AIF   ('&ADDR' EQ '').ERRA
         AIF   ('&SCN' EQ '').NULL
&L       SETA  K'&SCN
         AIF   (&L GT 2).ERRS
         AIF   ('&IND' EQ '').A
&I       SETC  '&IND'
         AGO   .B
.A       ANOP
&I       SETC  '0'
.B       AIF   ('&CDE' EQ '').C
&C       SETC  '&CDE'
         AGO   .D
.C       ANOP
&C       SETC  '0'
.D       ANOP
&NAME    DC    CL2'&SCN',AL1(&I,&C),A(&ADDR)
         MEXIT
.NULL    AIF   ('&IND' NE '').ERRI
         AIF   ('&CDE' NE '').ERRC
&NAME    DC    XL2'FF00',AL1(0,0),A(&ADDR)
         MEXIT
.ERRA    MNOTE 8,' SUB-COMMAND ADDRESS MISSING ***********************'
         MEXIT
.ERRS    MNOTE 8,' SUB-COMMAND NAME TOO LONG *************************'
         MEXIT
.ERRI    MNOTE 8,' INDICATOR(S) NOT ALLOWED **************************'
         MEXIT
.ERRC    MNOTE 8,' SUB-COMMAND CODE NOT ALLOWED **********************'
         MEND
         PRINT ON
         SPACE 1
QUEUE    START 0
         EJECT
         PRINT NOGEN
         COPY  $HASPGBL
         $HASPEQU
         SPACE 1
&MACSPLV SETC  '2'                 MACROS LIBRARY LEVEL
&VERSION SETC  'SP 2.2.0'          HASP VERSION
         SPACE 1
************************************************************* *
*                                                             *
*        THE VALUE OF THE VARIABLE BELOW CANNOT BE            *
*        DYNAMICALLY RETRIEVED, SO YOU MUST ADJUST            *
*        IT LOOKING IN THE HASPIRDA ASSEMBLY LIST.            *
*                                                             *
NCTETENT EQU   8                   NUMBER OF CKPT ENTRIES     * <======
*                                                             *
************************************************************* *
         SPACE 1
         $DAS
         $MIT
         $TAB
         $PCE
         IFGRPL ,        MVS ACB REQUEST PARAMETER LIST / $BUFFER
         $BUFFER
         $JQE
         $JOE
         $JOT
         $KIT
         $QSE
         $JCT
         $PDDB
         $IOT
         $CAT
         $HCT
         $LRC
         SPACE 1
         DROP ,                    DROP ALL JES REGS
         SPACE 1
         PRINT GEN
         TITLE '--- QUEUE/SP MISCELLANEOUS DEFINITIONS ---'
QUEUE    CSECT ,                   RESTORE MAIN CSECT
         SPACE 1
*---------------------------------------------------------------------*
*                                                                     *
* CURRENT REGISTER USAGE :                                            *
*                                                                     *
*  R0  - PARM                                                         *
*  R1  - PARM                                                         *
*  R11 - @ QUEUE COMMON AREA (QCOMMON)                                *
*  R12 - LOCAL PROGRAM BASE                                           *
*  R13 - STACK PTR (@ 72 BYTE SAVE AREA IN STACK)                     *
*  R14 - RETURN ADDRESS                                               *
*  R15 - LINKAGE                                                      *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
*---------------------------------------------------------------------*
*        AUTHORITY LEVELS DEFINITIONS.                                *
*---------------------------------------------------------------------*
         SPACE 1
LV15     EQU   15        PRIVILEGED LEVEL
LV12     EQU   12        AUTOMATIC MODE CONTROL LEVEL
LV10     EQU   10        WHEN LESS : REDUCED SERVICES LEVEL
LV0      EQU   0         REJECT LEVEL
         SPACE 1
QSP     $MDL@IX
         SPACE 1
*---------------------------------------------------------------------*
*        MISCELLANEOUS VALUES DEFINITION.                             *
*---------------------------------------------------------------------*
         SPACE 1
WASSZ    EQU   16*1024   WORK AREA SPACE SIZE
LDSSZ    EQU   256*1024  BLOCK ADDR TABLE SIZE FOR LISTDS
TDFLT    EQU   60*100    AUTOMATIC MODE DEFAULT TIME VALUE
         TITLE '--- QUEUE/SP -- MAINLINE MODULE ---'
         $XENT BASE=R12,LV=QWAREAL,SP=1,TYPE=RENT
         SPACE 1
*---     SET COMMON AREA                                           ---*
         SPACE 1
         LR    R2,R1               SAVE ENTRY ADDRESS
         LA    R11,0(,R13)
         LA    R5,18*4
         LR    R0,R11
         AR    R0,R5
         L     R1,=A(QCOMMONL)
         SR    R1,R5
         L     R14,=A(QCOMMON)
         AR    R14,R5
         LR    R15,R1
         MVCL  R0,R14              INITIALIZE COMMON
         USING QCOMMON,R11         ACCESS TO COMMON VECTOR TABLE
         SPACE 1
*---     CHECK USER AUTHORITY : SYSTEM, OPERATOR, ...              ---*
*---           THESE TESTS DON'T INCLUDE RACF PROTECTION ON        ---*
*---           DATA-SETS, WHICH IS CONTROLED AT OPEN TIME IF       ---*
*---           INSTALLED IN THE SYSTEM.                            ---*
         SPACE 1
         $TEW$EC REG=R2,TIOT=YES,NOTTSO=(,ONLY),MSG=PUTMSG,ERR=XBACK
         LA    R1,QXAUTH
         ST    R1,REQAUT+4
         $EACM REQAUT
         CLI   QXAUTH,LV0
         BE    NOTAUT
         MVC   SAVAUTH,QXAUTH      RETAIN ORIGINAL AUTHORITY
         SPACE 1
*---     CHECK CALLER TERMINAL                                     ---*
         SPACE 1
         GTSIZE ,                  GET SCREEN SIZE
         LTR   R0,R0               IS IT A SCREEN?
         BZ    NOTSCR              IF ZERO, NOT A SCREEN
         CH    R0,=H'24'           STANDARD NUMBER OF LINES?
         BL    NOTSTD              BRANCH IF LESS
         BE    TSTLNL              BRANCH IF YES
         CH    R1,=H'80'           STANDARD LINE LENGTH?
         BL    NOTSTD              BRANCH IF LESS
SETSSZ   ST    R0,SZSCRN           SAVE SCREEN SIZE
         ST    R1,SZLINE           SAVE LINE SIZE
         OI    SZSWTCH,SCRST       INDICATE SCREEN SIZE TO BE SET
         B     GASID
TSTLNL   CH    R1,=H'80'           STANDARD LINE LENGTH?
         BL    NOTSTD              BRANCH IF LESS
         BH    SETSSZ              BRANCH IF MORE
         SPACE 1
*---     OK, GET MY "ASID"                                         ---*
         SPACE 1
         USING PSA,R0              PSA ADDRESSABILITY
GASID    L     R3,PSAAOLD          CURRENT ASCB ADDRESS
         USING ASCB,R3             ASCB ADDRESSABILITY
         MVC   QASID,ASCBASID      GET MY ADDRESS SPACE IDENTIFIER
         DROP  R0,R3
         SPACE 1
*---     COMPLETE COMMON AREA INITIALIZATION                       ---*
         SPACE 1
         LR    R5,R11
         AL    R5,=A(QCOMMONL)
         ST    R5,QCWA             SET PTR TO SPACE WORK AREA
         LA    R5,2048(R11)
         LA    R5,2048(R5)
         USING QCOMMON+4096,R5
         LA    R1,QDISPLAY
         ST    R1,QVDSPL           SET PTR TO DISPLAY WORK AREA
         LA    R1,QCKPT
         ST    R1,QVCKPT           SET PTR TO CKPT WORK AREA
         LA    R1,QSNAP
         ST    R1,QVSNAP           SET PTR TO SNAP WORK AREA
         LA    R1,QPRINT
         ST    R1,QVPRINT          SET PTR TO HARDCOPY WORK AREA
         LA    R1,DAIRECB
         ST    R1,DAPLECB          SET PTR TO CP'S ECB
         LA    R1,HASPCKPT
         ST    R1,HDECB1+(DECDCBAD-DECB)     SET PTR TO DCB
         LA    R1,HASPACE
         ST    R1,HDECB2+(DECDCBAD-DECB)     SET PTR TO DCB
         LA    R1,QCDAD
         ST    R1,HDECB2+(DECRECPT-DECB)     SET PTR TO BLKREF
         LA    R1,QCOUT
         O     R1,QCOPEN
         ST    R1,QCOPEN           SET PTR TO DCB
         LA    R1,HASPCKPT
         O     R1,HOCKPT
         ST    R1,HOCKPT           SET PTR TO DCB
         LA    R1,INT#DCB
         O     R1,INT#RDJF
         ST    R1,INT#RDJF         SET PTR TO DCB
         LA    R1,INT#ELST
         O     R1,INT#DCB+(DCBEXLST-IHADCB)
         ST    R1,INT#DCB+(DCBEXLST-IHADCB)  SET PTR TO EXIT LIST
         LA    R1,INT#JFCB
         O     R1,INT#ELST
         ST    R1,INT#ELST         SET PTR TO JFCB READ AREA
         DROP  R5
         SPACE 1
*---     GET SAVE AREA STACK                                       ---*
         SPACE 1
GTSAS    L     R5,QGSASSZ          GET SAVE AREA STACK SIZE
         GETMAIN R,LV=(R5),SP=1    GET SAVE AREA STACK
         LA    R4,0(,R1)
         LR    R0,R4
         LR    R1,R5
         XR    R15,R15
         MVCL  R0,R14              ZERO STACK
         ST    R13,4(R4)           CHAIN WITH ENTRY SAVE AREA
         ST    R4,8(R13)
         LR    R13,R4              SET @ OF STACK
         ST    R13,QFRSTSA         INIT KLUDGE *******
         SPACE 1
*---     VTAM INITIALIZATION                                       ---*
         SPACE 1
         STFSMODE  ON,INITIAL=YES
         TM    SZSWTCH,SCRST       SCREEN SIZE TO BE SET?
         BZ    NOSCRS              BRANCH IF NOT
         STSIZE SIZE=80,LINE=24    SET STANDARD SCREEN SIZE
         OI    SZSWTCH,SCRRS       INDICATE SCREEN SIZE TO BE RESET
         SPACE 1
*---     JES2 DEPENDENT INITIALIZATION - INIT                      ---*
         SPACE 1
NOSCRS   QCALL INIT                INITIALIZE
         LA    R10,LOOP            INTERRUPTED RETURN ADDRESS
         L     R9,QVDSPL           @ DISPLAY WORK AREA
         USING QDISPLAY,R9
         SPACE 1
*---     READ JES2 CHECKPOINT FILE - CKPT                          ---*
         SPACE 1
LOOP     QCALL CKPT
         SPACE 1
*---     COMMAND LINE PARSE                                        ---*
         SPACE 1
         QCALL PARSE
         CLC   =C'E ',QSUBNAME     STOP?
         BE    EXIT                YES
         CLC   =C'EXIT ',QSUBNAME  STOP?
         BE    EXIT                YES
         CLC   =C'END ',QSUBNAME   STOP?
         BE    EXIT                YES
         CLC   =C'STOP ',QSUBNAME  STOP?
         BE    EXIT                YES
         SPACE 1
*---     CALL SUB-COMMAND MODULE SELECTED BY PARSE                 ---*
         SPACE 1
         MVC   QDHLINE,DUMMY       NO OUTPUT MESSAGE
         L     R15,QSUBCMD         ADDR OF SUBCMD FROM QCOMMON
         QCALL ,                   GO TO IT
         CLC   QDHLINE,DUMMY       WAS ANYTHING WRITTEN?
         BE    NO$DATA             NO - SKIP
         L     R1,=A(EMPTYDS)      POINT TO EMPTY DS MESSAGE
         CLC   QDHLINE,0(R1)       IS DATA-SET EMPTY?
         BE    NO$DATA             YES, SKIP
         TM    QDOVER,QESKIP       END OF DATA SKIP REQUESTED?
         BZ    SND$DATA            NO, SEND IT
         NI    QDOVER,255-QESKIP   OFF INDICATOR
         B     NO$DATA
SND$DATA QCALL DISPLAY,ENDDATA,80  MOVE TO SCREEN
NO$DATA  QCALL DISPLAY,,0          WRITE LAST SCRN, GET NEXT INPUT
         B     LOOP                DO IT AGAIN
CMDINV   MVC   QDHLINE,CINVMSG     SEND INVALID MSG
         B     NO$DATA
CMDUNK   MVC   QDHLINE,CUNKMSG     SEND UNKNOWN MSG
         B     NO$DATA
         SPACE 1
*---     CLEAN UP AND GO HOME                                      ---*
         SPACE 1
EXIT     MVC   QDSCREEN(CLEARL),CLEAR   SET CLEAR SEQUENCE
         TM    SZSWTCH,SCRRS       WAS SCREEN SIZE CHANGED?
         BZ    ENDCL               BRANCH IF NOT
         STSIZE SIZELOC=SZLINE,LINELOC=SZSCRN     RESTORE
         $FS   CC=EWA,MF=(I,QDSCREEN)
ENDCL    TPUT  QDSCREEN,CLEARL,FULLSCR,,HOLD CLEAR THE SCREEN
         STFSMODE  OFF             TELL VTAM WE'RE DONE
         SPACE 1
*---     CLOSE AND EVENTUALLY FREE HASPCKPT                        ---*
         SPACE 1
         L     R8,QVCKPT           LOAD BASE REG
         USING QCKPT,R8            BASE REG FOR CKPT WORK AREA
         CLOSE MF=(E,HOCKPT)       CLOSE
         MVI   DAIRFLAG,DFFREE+DFABORT  REQUEST FREE FUNCTION
         MVC   DAFRDDN(L'DAFRDDN),HASPCKPT+(DCBDDNAM-IHADCB)
*                                  DDNAME TO DAIR PARM AREA
         CLC   DAFRDDN,INT#DCB+(DCBDDNAM-IHADCB)
         BE    FR$SP
         QCALL ALLOCATE            FREE IT BY DDNAME
         SPACE 1
*---     CLOSE AND FREE HASPACE(S)                                 ---*
         SPACE 1
FR$SP    L     R1,QCSPOPNL
         CLOSE MF=(E,(1))          CLOSE
         L     R2,QCSPOPNL         -> TO FIRST DCB ADDRESS
LOOP$FR  L     R1,0(,R2)           GET A DCB ADDRESS
         MVC   DAFRDDN,DCBDDNAM-IHADCB(R1)
*                                  COPY DDNAME TO DAIR PARM AREA
         QCALL ALLOCATE            FREE IT BY DDNAME
         TM    0(R2),X'80'         WAS THIS THE LAST HASPACE DCB?
         LA    R2,4(,R2)           -> NEXT DCB ADDRESS IN CASE NOT
         BNO   LOOP$FR             NO - DO NEXT
         SPACE 1
*---     CLOSE HARDCOPY FILE IF ANY                                ---*
         SPACE 1
         TM    QHFREQ,QHCOPY       IS HARDCOPY ACTIVE?
         BZ    FREETRC             NO
         OI    QHFREQ,QHCLOSE      SAY CLOSE IT
         QCALL PRINT
         SPACE 1
*---     CLOSE TRACE FILE IF ANY                                   ---*
         SPACE 1
FREETRC  TM    QXSWXQ,OPTR         TRACE FILE IS OPENED?
         BZ    FREETSO             NO
         L     R1,QVSNAP           @ SNAP WORK AREA
         USING QSNAP,R1
         LA    R2,SNAPDCB
         DROP  R1
         CLOSE ((R2)),MF=(E,SNAPCL)
         SPACE 1
*---     FREE EVENTUALLY THE TSO WORK AREA                         ---*
         SPACE 1
FREETSO  L     R1,ATSOX            GET TSO WORK AREA ADDRESS
         LTR   R1,R1               WAS ACQUIRED?
         BZ    NOTSOC              NO, SKIP FREE
         LA    R0,TSOXEQL          LENGTH FOR FREEMAIN
         FREEMAIN R,LV=(0),A=(1)   FREE WORKING STORAGE
         SPACE 1
*---     FREE ALL OTHER WORK AREAS                                 ---*
         SPACE 1
NOTSOC   L     R4,QFRAR1           BLOCK ADDR TABLE FOR LISTDS
         L     R5,QFRSZ1           HIS LENGTH
         FREEMAIN R,A=(R4),LV=(R5),SP=1
         L     R4,QFRAR2           DECB WORK AREA FOR CKPT ROUTINE
         L     R5,QFRSZ2           HIS LENGTH
         FREEMAIN R,A=(R4),LV=(R5),SP=1
         L     R4,QFRAR3           BUFFERS FOR HASPCKPT & HASPACE(S)
         L     R5,QFRSZ3           HIS LENGTH
         FREEMAIN R,A=(R4),LV=(R5),SP=1
         L     R4,QFRAR4           DCB POOL FOR HASPACE(S)
         L     R5,QFRSZ4           HIS LENGTH
         FREEMAIN R,A=(R4),LV=(R5),SP=1
         SPACE 1
*---     FREE STACK AREA + COMMON AREA                             ---*
         SPACE 1
         L     R4,QFRSTSA          GET SAVE AREA STACK ADDRESS
         L     R5,QGSASSZ          GET SAVE AREA STACK SIZE
         FREEMAIN R,A=(R4),LV=(R5),SP=1
XBACK    LR    R13,R11
         $XRET CC=0,LV=QWAREAL,SP=1,TYPE=RENT
         SPACE 1
*---     SEND DIAGNOSTIC MESSAGES                                  ---*
         SPACE 1
NOTAUT   LA    R1,NAUTM
         B     SDMSG
NOTSCR   LA    R1,NSCRM
         B     SDMSG
NOTSTD   LA    R1,NSTDM
SDMSG    BAS   R14,PUTMSG
         B     XBACK
         EJECT
*---     CONSTANTS AND OTHER ODDITIES                              ---*
         SPACE 1
CLEAR    $FS   CC=EW,WCC=(AL,KBR,RMDT),SBA=(24,79),MF=L
         $FS   SBA=(1,1),RA=(1,1,00),MF=L
         $FS   SF=(INT,IC),MF=L
CLEARL   EQU   *-CLEAR
DUMMY    DC    CL79'    NO DATA IS AVAILABLE FOR YOUR REQUEST'
CINVMSG  DC    CL79'=== INVALID SUB-COMMAND ==='
CUNKMSG  DC    CL79'=== WHAT ?'
ENDDATA  $FS   SF=(PROT,INT),MF=L  HIGH INTENSITY, PROTECTED
         DC    CL76'                            *** END OF DATA ***'
         $FS   SF=(PROT),MF=L      NORMAL INTENSITY, PROTECTED
         SPACE 1
NAUTM    WTO   ' -> UNAUTHORIZED COMMAND.',                            X
               ROUTCDE=11,DESC=7,MF=L
NSCRM    WTO   ' -> QUEUE/SP RUN ONLY ON A SCREEN TERMINAL.',          X
               ROUTCDE=11,DESC=7,MF=L
NSTDM    WTO   ' -> QUEUE/SP WANT TO BE SCREEN SIZED 24 * 80.',        X
               ROUTCDE=11,DESC=7,MF=L
         SPACE 1
         LTORG
         SPACE 1
         DROP  R8,R9,R11,R12
         TITLE '--- QUEUE/SP -- INIT -- INITIALIZATION ROUTINES ---'
INIT     QSTART
         L     R9,QVCKPT           LOAD BASE REG
         USING QCKPT,R9            BASE REG FOR CKPT WORK
         L     R8,QVDSPL           LOAD BASE REG
         USING QDISPLAY,R8         BASE REG FOR DISPLAY WORK
         SPACE 1
*---     MOVE PARMS FROM CPPL TO DAPL                              ---*
         SPACE 1
         L     R2,#TSCPPL          ADDRESS OF CPPL
         USING CPPL,R2             ADDR OF CPPL IS IN R2
         MVC   DAPLUPT,CPPLUPT     USER PROFILE TABLE
         MVC   DAPLPSCB,CPPLPSCB   PROTECTED STORAGE CNTL BLK
         MVC   DAPLECT,CPPLECT     ENVIRONMENT CNTL TABLE
         SPACE 1
*---     LOCATE LOGON ID, SAVE FOR FUTURE REFERENCE                ---*
         SPACE 1
         L     R1,CPPLPSCB         -> PSCB
         USING PSCB,R1
         MVC   QLOGON(7+1),PSCBUSER     SAVE TSO USERID AND LENGTH
         MVC   QSTKEY(7),QLOGON    SET SEARCH KEY FOR 'ST'
         MVI   QSTKEY+7,C' '       FIX LAST BYTE
         DROP  R1
         SPACE 1
*---     MOVE COMMAND BUFFER TO REPLY BUFFER                       ---*
         SPACE 1
         L     R1,CPPLCBUF         ADDR OF COMMAND BUFFER
         DROP  R2                  DONE WITH THIS REGISTER
         LH    R3,0(,R1)           LENGTH OF COMMAND BUFFER
         LH    R4,2(,R1)           OFFSET TO FIRST DATA BYTE
         LA    R1,4(R1,R4)         FIRST DATA BYTE
         SR    R3,R4               SUBTRACT OFFSET FROM LENGTH
         SH    R3,=H'4'            SUBTRACT OVERHEAD
         SH    R3,=H'1'            IS LENGTH ZERO?
         BM    INT$SKIP            YES, SKIP IT
         EX    R3,OCBUF            TRANSLATE TO UPPER CASE
         XC    QDREPLY,QDREPLY     RESET THE REPLY LINE
         CH    R3,=Y(QDREPLYL-1)   IS LENGTH OVER MAX?
         BNH   *+L'*+4             NO, USE IT
         LA    R3,QDREPLYL-1       USE MAXIMUM LENGTH
         EX    R3,MVCBUF           MOVE THE DATA
         LA    R3,1(,R3)           INCREMENT TO TRUE LENGTH
         STH   R3,QDRLNG           STORE REPLY LENGTH
         OC    QDREPLY(2),QBLANK   UPPER CASE SUB-COMMAND
         L     R15,=A(P$TABLE)     START OF SUB-COMMANDS TABLE
INT$SCTB CLC   QDREPLY(2),0(R15)   THIS ONE?
         BE    INT$TSNR            YES
         LA    R15,L'P$TABLE(R15)  NO, NEXT ENTRY
         CLI   0(R15),X'FF'        IS THIS THE END OF TABLE?
         BNE   INT$SCTB            NO, TRY NEXT ENTRY
INT$SREQ OI    QDPRSW,QRPVCMD      YES, SET RESTORE SUB-COMMAND REQ
         B     INT$SKIP            DON'T SET TO REPROMPT
INT$TSNR TM    2(R15),FLNPR        NO REPROMPT?
         BO    INT$SREQ            YES, DON'T SET TO REPROMPT
         MVC   QDPROMPT,QDREPLY    NO, SAVE FOR REPROMPT
         MVC   QDRLNGP,QDRLNG      LENGTH FOR REPROMPT
         SPACE 1
*---     GETMAIN BLOCK ADDR TABLE FOR LISTDS                       ---*
         SPACE 1
INT$SKIP L     R3,QFRSZ1           LENGTH
         GETMAIN R,LV=(R3),SP=1
         ST    R1,QCSTART          STORE STARTING ADDR OF TABLE
         ST    R1,QFRAR1           STORE ADDRESS FOR FREE
         A     R1,QFRSZ1           END OF TABLE
         ST    R1,QCEND
         SPACE 1
*---------------------------------------------------------------------*
*                                                                     *
*        IF HASPCKPT ALREADY ALLOCATED USE IT                         *
*        AND USE HIS DATA-SET NAME PREFIX FOR HASPACE(S)              *
*        (THIS ALLOWS ALTERNATE CKPT OR TEST JES)                     *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
         RDJFCB MF=(E,INT#RDJF)    GET JFCB IF ANY
         LTR   R15,R15             ANY JFCB?
         BNZ   INT$CKTP            BRANCH IF NO JFCB, ALLOC CKPT
         LA    R15,INT#JFCB
         LA    R0,44
INT$CLP  CLI   0(R15),C'.'
         BE    INT$CLL
         LA    R15,1(,R15)
         BCT   R0,INT$CLP
         B     INT$CKTP
INT$CLL  LA    R1,INT#JFCB
         SR    R15,R1              LENGTH OF PREFIX
         BCTR  R15,0               GET EX LENGTH
         MVC   DSNSPACE+2(44),=CL44' '  BLANK OUT DSN
         EX    R15,INT$CMVC
         LA    R1,DSNSPACE+2+1(R15)
         MVC   0(8,R1),=C'.HASPACE'     FINISH SPACE NAME
         LA    R15,8+1(,R15)       HASPACE NAME LENGTH
         STH   R15,DSNSPACE        SAVE NAME LENGTH
         B     INT$CHAV            AND GO USE CKPT
INT$CMVC MVC   DSNSPACE+2(0),INT#JFCB   <<EXECUTED>>
         SPACE 1
*---     ALLOCATE HASPCKPT                                         ---*
         SPACE 1
INT$CKTP LA    R15,DSNCKPT         DSNAME FOR ALLOCATE
         ST    R15,DAALPDSN
         MVI   DAIRFLAG,DFALLOC+DFABORT REQUEST ALLOCATE FUNCTION
         QCALL ALLOCATE            ALLOCATE IT
         MVC   HASPCKPT+(DCBDDNAM-IHADCB)(L'DAALDDN),DAALDDN
*                                  GET DDNAME DAIR RETURNED
         SPACE 1
*---     OPEN HASPCKPT                                             ---*
         SPACE 1
INT$CHAV DEVTYPE HASPCKPT+(DCBDDNAM-IHADCB),IT#DEVTB,DEVTAB,RPS
*                                  GET CKPT DEV INFO
         L     R3,IT#DEVTB+4       MAX BLKSIZE FOR DEVICE
         STH   R3,HASPCKPT+(DCBBLKSI-IHADCB) SET IN CKPT DCB
         XR    R3,R3
         IC    R3,IT#DEVTB+3       UNIT TYPE INFO FOR TRKCALC
         L     R4,=A(X'01001000')  # OF 4K BLOCKS / TRK
         TRKCALC FUNCTN=TRKCAP,TYPE=(R3),RKDD=(R4),REGSAVE=YES,        1
               MF=(E,TRKLIST)
         ST    R0,IT#CKRT          SAVE # 4K BLK/TRK ON CKPT
         OPEN  MF=(E,HOCKPT)       OPEN HASPCKPT
         TM    HASPCKPT+(DCBOFLGS-IHADCB),DCBOFOPN     OPEN OK?
         BZ    IT$DIE1             NO, OPEN ERROR
         SPACE 1
*---     GETMAIN DECB WORK AREA FOR CKPT ROUTINE                   ---*
         SPACE 1
         XR    R2,R2
         IC    R2,HASPCKPT+(DCBNCP-IHADCB)   NCP VALUE FROM DCB
         MH    R2,=Y(HDECB1L)      * LENGTH OF EACH DECB
         LA    R2,7(R2)            ROUND TO 8 BYTE BOUNDARY
         SRL   R2,3
         SLL   R2,3
         ST    R2,QFRSZ2           STORE LENGTH FOR FREE
         GETMAIN R,LV=(R2),SP=1
         ST    R1,QCDECBPT         SAVE @ DECB WORK AREA FOR CKPT
         ST    R1,QFRAR2           STORE ADDRESS FOR FREE
         SPACE 1
*---     READ MASTER RECORD (RECORD 3)                             ---*
         SPACE 1
         L     R2,QCSTART          USE TABLE AREA FOR IOAREA
         ST    R2,QCMSA
         OI    SWCKPT,SWCKPTMR     ASK FOR MASTER RECORD ONLY
         QCALL CKPT                READ MASTER RECORD
         USING $SAVEBEG,R2         BASE REG FOR CHECKPOINT
         CLC   $HASPID,=CL4'JES2'  IS IT VALID HCT?
         BNE   IT$DIE2             NO, STOP HERE
         SPACE 1
*---     FIND KIT AREA IN MASTER RECORD                            ---*
         SPACE 1
         LH    R1,$QSEMAX          # OF QSE'S
         MH    R1,=Y(QSELEN)       * LENGTH OF EACH QSE
         LA    R3,$SAVEEND(R1)     @ OF CKPT EXT. INFO IN M.R.
         ST    R3,QCJQEXA          @ OF JQE EXTENSIONS
         AH    R3,$MAXEXSZ         MAX. SIZE OF EXTENSION
         LA    R0,DASEXLEN         COMPUTE
         MH    R0,$SPOLNUM           THE DAS EXTENSION
         ALR   R3,R0                   AREAS LENGTH
         ST    R3,IT#KITF          SAVE @ FIRST KIT
         LH    R0,=Y(KITLNGTH)     COMPUTE
         MH    R0,=Y(NCTETENT-1)     THE
         ALR   R3,R0                   @ OF LAST KIT
         ST    R3,IT#KITL          SAVE @ OF LAST KIT
         SPACE 1
*---     FIND DAS TABLE BLOCK #; # OF BLOCKS                       ---*
         SPACE 1
         L     R0,=CL4'DAS '       ID FOR DAS'S
         BAS   R14,IT$KITFD        SEARCH KIT FOR DAS SLOT
         B     IT$DIE3             BRANCH IF SYSTEM HAS NO DAS'S
         USING KIT,R1
         LH    R14,KITRECN         # OF BLOCKS OF DAS'S
         ST    R14,QCDASNUM        SAVE # BLOCKS OF DAS'S
         BAS   R14,IT$CKTTR        COMPUTE TTR OF DAS'S
         DROP  R1
         ST    R1,QCDASTTR         SAVE TTR OF DAS'S
         SPACE 1
*---     FIND JQE TABLE BLOCK #; # OF BLOCKS                       ---*
         SPACE 1
         L     R0,=CL4'JQE '       ID FOR JQE'S
         BAS   R14,IT$KITFD        SEARCH KIT FOR JQE SLOT
         B     IT$DIE4             BRANCH IF SYSTEM HAS NO JQE'S
         USING KIT,R1
         LH    R6,KITRECN          # OF BLOCKS OF JQE'S
         ST    R6,QCJQENUM         SAVE # BLOCKS OF JQE'S
         BAS   R14,IT$CKTTR        COMPUTE TTR OF JQE'S
         DROP  R1
         ST    R1,QCJQETTR         SAVE TTR OF JQE'S
         SPACE 1
*---     FIND JOE TABLE BLOCK #; # OF BLOCKS                       ---*
         SPACE 1
         L     R0,=CL4'JOE '       ID FOR JOE'S
         BAS   R14,IT$KITFD        SEARCH KIT FOR JOE SLOT
         B     IT$DIE5             BRANCH IF SYSTEM HAS NO JOE'S
         USING KIT,R1
         LH    R3,KITRECN          # OF BLOCKS OF JOE'S
         ST    R3,QCJOENUM         SAVE # OF BLOCKS OF JOE'S
         BAS   R14,IT$CKTTR        COMPUTE TTR OF JOE'S
         DROP  R1
         ST    R1,QCJOETTR         SAVE TTR OF JOE'S
         SPACE 1
*---     SAVE ALL SYSTEM ID'S IN COMPLEX                           ---*
         SPACE 1
         LH    R0,$QSEMAX          NUMBER OF QSE'S
         LA    R1,QSYSID           OUTPUT @ FOR SYSTEM ID'S
         LA    R15,$SAVEEND        @ 1ST QSE
         USING QSE,R15
IT$QSELP MVC   0(L'QSESID,R1),QSESID    SAVE SYSTEM ID
         TM    QSESTAT,QSELAST     LAST QSE?
         BO    *+L'*+12            YES
         LA    R1,L'QSYSID(,R1)
         LA    R15,QSELEN(,R15)
         BCT   R0,IT$QSELP
         DROP  R15
         SPACE 1
*---     COMPUTE HASPACE(S) BUFFER SIZE                            ---*
         SPACE 1
         LH    R5,$BUFSIZE         BLKSIZE FOR HASPACE(S)
         STH   R5,HASPACE+(DCBBLKSI-IHADCB)  STORE IN DCB
         STH   R5,HDECB2+(DECLNGTH-DECB)     STORE IN DECB
         LA    R5,63(R5)           PREPARE TO ROUND
         N     R5,=F'-64'          ROUND TO 64 BYTE BOUNDARY
         SPACE 1
*---     GETMAIN BUFFERS FOR HASPCKPT AND HASPACE(S)               ---*
         SPACE 1
         L     R6,$MASTERL         LENGTH OF MASTER RECORD
         LA    R6,4095(,R6)        ROUND UP TO 4K BOUNDARY
         N     R6,=F'-4096'
         L     R7,QCJQENUM         # OF JQE CKPT BLOCKS
         SLL   R7,12               LENGTH OF JQE CKPT AREA
         L     R8,QCJOENUM         # OF JOE CKPT BLOCKS
         SLL   R8,12               LENGTH OF JOE CKPT AREA
         LR    R14,R5              HASPACE(S) BUFFER SIZE
         MH    R14,=H'3'           3 BUFFERS
         AR    R14,R6              + ROUNDED MASTER RECORD
         AR    R14,R7              + JQE CKPT AREA
         AR    R14,R8              + JOE CKPT AREA
         LA    R4,256(,R14)        + SLOP
         LA    R4,7(R4)            ROUND TO 8 BYTE BOUNDARY
         SRL   R4,3
         SLL   R4,3
         ST    R4,QFRSZ3           STORE LENGTH FOR FREE
         GETMAIN R,LV=(R4),SP=1    GET STORAGE FOR BUFFERS
         ST    R1,QCMSA            @ MASTER CKPT RECORD
         ST    R1,QFRAR3           STORE ADDRESS FOR FREE
         AR    R1,R6               + ROUNDED LENGTH MASTER CKPT RECORD
         ST    R1,QCJQEA           @ JQE CKPT INFO
         LA    R15,BFPLEN(,R1)     BUMP PAST BUFFER ID
         ST    R15,QCJQEWA         @ JQE CKPT INFO (BASE TO OFFSET)
         AR    R1,R7               + LENGTH OF JQE CKPT INFO
         ST    R1,QCJOTA           @ JOE CKPT INFO
         LA    R15,BFPLEN(,R1)     BUMP PAST BUFFER ID
         ST    R15,QCJOTWA         @ JOE CKPT INFO (BASE TO OFFSET)
         AR    R1,R8               + LENGTH OF JOE CKPT INFO
         ST    R1,QCJCTA           @ JCT BUFFER
         AR    R1,R5               + SPOOL BUFFER SIZE
         ST    R1,QCIOTA           @ IOT BUFFER
         AR    R1,R5               + SPOOL BUFFER SIZE
         ST    R1,QCBLKA           @ DATA BUFFER BLOCK
         LA    R1,$JQHEADS-$SAVEBEG OFFSET TO JQE QUEUES IN MASTER REC
         A     R1,QCMSA            + @ MASTER RECORD
         ST    R1,QCJQHEAD         @ JQE'S QUEUES HEADS
         SPACE 1
*---     ALLOCATE AND OPEN HASPACE(S)                              ---*
         SPACE 1
         AR    R6,R2               USE TABLE AREA AFTER CHECKPOINT
         ST    R6,QCDASA           AS IOAREA TO READ IN DAS BLOCKS
         OI    SWCKPT,SWCKPTDA     SET DAS REQUEST ONLY
         QCALL CKPT                READ DAS BLOCKS
         LA    R3,BFPLEN(,R6)      BUMP PAST BUFFER ID
         USING DAS,R3              SET ADDRESSING
         LA    R4,DSNSPACE         DSNAME FOR ALLOCATE
         ST    R4,DAALPDSN
         LH    R4,$SPOLNUM         NUMBER OF SPOOL VOLUMES
         STH   R4,QSPOLNUM
         LA    R7,QCDCBL           LENGTH OF HASPACE DCB
         MR    R6,R4               COMPUTE LENGTH OF DCB POOL
         LR    R6,R4
         SLL   R6,2                COMPUTE LENGTH OF A LIST
         AR    R7,R6               + OPEN LIST SPACE
         AR    R7,R6               + DCB ADDR LIST SPACE
         AR    R7,R6               + # TRKS/CYL LIST SPACE
         LA    R7,7(R7)            ROUND TO 8 BYTE BOUNDARY
         SRL   R7,3
         SLL   R7,3
         ST    R7,QFRSZ4           STORE LENGTH FOR FREE
         GETMAIN R,LV=(R7),SP=1    GET SPACE FOR DCB POOL
         ST    R1,QFRAR4           STORE ADDRESS FOR FREE
         LR    R8,R1               @ OF OPEN LIST
         ST    R8,QCSPOPNL         SAVE ADDR OF OPEN LIST
         LA    R7,0(R8,R6)         @ OF DCB ADDR LIST
         ST    R7,QCSPDCBP         SAVE ADDR OF DCB ADDR LIST
         AR    R7,R6               @ OF # TRKS/CYL LIST
         ST    R7,QCSPNMTC         SAVE ADDR OF # TRKS/CYL LIST
         AR    R7,R6               @ OF DCB POOL
         XR    R6,R6               ACTUAL NUMBER OF SPOOL VOLUMES
         MVI   DAIRFLAG,DFALLOC+DFABORT REQUEST ALLOCATE FUNCTION
IT$SP1   TM    DASFLAG,DASEXSTS    DOES VOLUME EXIST?
         BZ    IT$SP2              NO, TRY NEXT
         TM    DASFLAG2,DASINACT   IS IT INACTIVE?
         BO    IT$SP2              YES, TRY NEXT
         LH    R15,DASNOTGE        # OF TRACKS IN EXTENT
         A     R15,QCTNUMTG        COMPUTE ACTIVE VOLUMES
         ST    R15,QCTNUMTG          TRACK GROUPS COUNT
         MVC   DAALUNIT,=CL8'SYSALLDA'  UNIT NAME FOR ALLOC
         MVC   DAALSER(L'DASVOLID),DASVOLID  VOLSER FOR ALLOC
         QCALL ALLOCATE            ALLOCATE IT
         MVC   0(QCDCBL,R7),HASPACE     MOVE PATTERN DCB TO POOL
         MVC   DCBDDNAM-IHADCB(L'DAALDDN,R7),DAALDDN
*                                  UPDATE THE DDNAME
         ST    R7,0(R8)            STORE DCB ADDR IN OPEN LIST
         DEVTYPE DCBDDNAM-IHADCB(,R7),IT#DEVTB,DEVTAB,RPS
*                                  GET HASPACE DEV INFO
         LR    R15,R6              DCB # TO R15 (ORIGIN 0)
         SLL   R15,2               * 4 FOR OFFSET INTO QCSPDCBP
         L     R14,QCSPDCBP
         ST    R7,0(R14,R15)       SAVE DCB ADDR FOR MTTR CONVERT
         LH    R0,IT#DEVTB+10      # OF TRACKS / CYLINDER
         L     R14,QCSPNMTC
         ST    R0,0(R14,R15)       SAVE # TRKS/CYL FOR THIS HASPACE
         LA    R7,QCDCBL(R7)       INCREMENT TO NEXT DCB
         LA    R8,4(R8)            NEXT ENTRY IN OPEN LIST
IT$SP2   LA    R3,DASSIZ(R3)       NEXT VOLUME
         DROP  R3                  KILL ADDRESSABILITY
         LA    R6,1(R6)            INCREASE COUNT BY ONE
         BCT   R4,IT$SP1           BRANCH IF MORE VOLUMES
         SH    R8,=H'4'            WE ARE ONE TOO FAR
         OI    0(R8),X'80'         MARK END OF OPEN LIST
         L     R1,QCSPOPNL
         OPEN  MF=(E,(1))          OPEN HASPACE(S)
         L     R2,QCSPOPNL
IT$SP3   L     R3,0(R2)            DCB ADDRESS
         TM    DCBOFLGS-IHADCB(R3),DCBOFOPN  OPEN OK?
         BZ    IT$DIE6             NO, OPEN ERROR
         TM    0(R2),X'80'         END OF OPEN LIST?
         BO    *+L'*+8             YES
         LA    R2,4(R2)            NEXT ENTRY IN OPEN LIST
         B     IT$SP3
         QSTOP
         EJECT
*---------------------------------------------------------------------*
*                                                                     *
*        IT$KITFD - FIND SELECTED KIT                                 *
*                                                                     *
*        ENTRY : R0  - CHAR ID STRING (CL4 IN REG)                    *
*                R14 - RETURN ADDRESS                                 *
*                                                                     *
*        EXIT :  R1 - @ OF KIT (IF RETURN 4(,R14); ELSE NOT FOUND)    *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
IT$KITFD L     R1,IT#KITF          @ FIRST KIT
         USING KIT,R1
IT$KITFL CL    R0,KITID
         BE    4(,R14)             BRANCH IF SELECTED KIT FOUND
         LA    R1,KITLNGTH(,R1)    @ NEXT KIT IF ANY
         C     R1,IT#KITL          @ LAST KIT
         BNH   IT$KITFL            BRANCH IF WAS NOT LAST KIT
         BR    R14                 BRANCH IF KIT NOT FOUND
         DROP  R1                  (KIT DSECT)
         SPACE 1
*---------------------------------------------------------------------*
*                                                                     *
*        IT$CKTTR - COMPUTE CKPT TTR OF GROUP OF BLOCKS FROM KITORG   *
*                                                                     *
*        ENTRY : R1  - @ KIT DSECT                                    *
*                R14 - RETURN ADDRESS                                 *
*                                                                     *
*        EXIT :  R1  - TTR0 OF THIS GROUP ON CKPT                     *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
         USING KIT,R1
IT$CKTTR L     R1,KITORG           GET ORIGIN IN BYTES OF THIS GROUP
         DROP  R1
         SRL   R1,12               ORG TO # OF BLOCKS
         XR    R0,R0
         LTR   R1,R1
         BZ    *+L'*+10
         D     R0,IT#CKRT          / # 4K BLOCKS/TRK ON CKPT DEVICE
         SLL   R1,8                POSITION TT IN R1
         OR    R1,R0               BUILD TTR IN R1
         AL    R1,=A(X'00000101')  SKIP 1ST TRK/RECORD ORIGIN 1
         SLL   R1,8                NOW TTR0
         BR    R14
         EJECT
*---------------------------------------------------------------------*
*        FORCE AN ABEND U.... FOR ANALYSIS                            *
*---------------------------------------------------------------------*
         SPACE 1
IT$DIE1  LA    R1,1                HASPCKPT OPEN ERROR ---------- U-001
         B     CRASHIN
IT$DIE2  LA    R1,2                NOT JES2 HCT ----------------- U-002
         B     CRASHIN
IT$DIE3  LA    R1,3                NO DAS'S QUEUE --------------- U-003
         B     CRASHIN
IT$DIE4  LA    R1,4                NO JQE'S QUEUE --------------- U-004
         B     CRASHIN
IT$DIE5  LA    R1,5                NO JOE'S QUEUE --------------- U-005
         B     CRASHIN
IT$DIE6  LA    R1,6                HASPACE(S) OPEN ERROR -------- U-006
CRASHIN  ABEND (1),DUMP
         SPACE 1
OCBUF    OC    0(*-*,R1),QBLANK    * EXECUTED * CMD TO UPPER CASE
MVCBUF   MVC   QDREPLY(*-*),0(R1)  * EXECUTED * CMD TO REPLY BUFFER
         SPACE 1
         LTORG
         SPACE 1
         DROP  R2,R8,R9,R11,R12
 TITLE '--- QUEUE/SP -- ALLOCATE -- DATA-SET ALLOCATION ROUTINE ---'
ALLOCATE QSTART
         L     R10,QVCKPT          @ OF DAIR WORK AREAS
         USING QCKPT,R10
         SPACE 1
*---     DETERMINE REQUESTED FUNCTION                              ---*
         SPACE 1
         TM    DAIRFLAG,DFALLOC    IS THE FUNCTION ALLOCATE?
         BO    ALLOC               YES, DO IT
         TM    DAIRFLAG,DFFREE     IS THE FUNCTION FREE?
         BZ    ALC$STOP            NO, PRETEND LIKE WE DID IT
         SPACE 1
*---     FREE DDNAME(W)                                            ---*
         SPACE 1
         XC    DAFRDARC(L'DAFRDARC+L'DAFRCTRC),DAFRDARC
         LA    R1,DAFRCD           LOAD ADDR OF FREE PARM LIST
         BAS   R2,CALLDAIR         CALL DAIR
         B     ALC$STOP            RETURN TO CALLER
         SPACE 1
*---     ALLOCATE DDNAME(W) DSNAME(X) SHR UNIT(Y) VOLUME(Z)        ---*
         SPACE 1
ALLOC    MVC   DAALDDN,QBLANK      BLANK THE DDNAME AREA
         XC    DAALDARC(L'DAALDARC+L'DAALCTRC),DAALDARC
         LA    R1,DAALCD           LOAD ADDR OF ALLOC PARM LIST
         BAS   R2,CALLDAIR         CALL DAIR - ALLOC THE DATA-SET
         SPACE 1
*---     RETURN TO CALLER                                          ---*
         SPACE 1
ALC$STOP QSTOP
         SPACE 1
*---     CALL DYNAMIC ALLOCATION INTERFACE ROUTINE (DAIR)          ---*
         SPACE 1
CALLDAIR ST    R1,DAPLDAPB         SET PARM LIST ADDR IN CALL LIST
         XC    DAIRECB,DAIRECB     CLEAR ECB
         CALLTSSR EP=IKJDAIR,MF=(E,DAPLUPT)
         LTR   R15,R15             IS RETURN CODE ZERO?
         BZR   R2                  YES, RETURN
         CH    R15,=H'28'          IS DATA-SET ALREADY FREE?
         BER   R2                  YES, RETURN
         TM    DAIRFLAG,DFABORT    ABORT REQUESTED?
         BO    DAIRFAIL            YES, DIAGNOSE FAILURE
         MVC   QDMSG(31),=CL31'---> UNABLE TO XXXX DATA-SET : '
         TM    DAIRFLAG,DFALLOC    IS THE FUNCTION ALLOCATE?
         BZ    *+L'*+10            NO
         MVC   QDMSG+15(4),=CL4'ALL.'   YES, SAY ALLOCATE
         B     *+L'*+6
         MVC   QDMSG+15(4),=CL4'FREE'   SAY FREE
         MVC   QDMSG+31(9),=CL9'RC=0000, '
         MVC   QDMSG+40(14),=CL14'DARC=X''0000'', '
         MVC   QDMSG+54(13),=CL13'CTRC=X''0000''.'
         CVD   R15,DAIRDWD         DISPLAY RC
         UNPK  DAIRDWD(5),DAIRDWD+5(3)
         OI    DAIRDWD+4,C'0'
         MVC   QDMSG+34(4),DAIRDWD+1
         L     R1,DAPLDAPB
         MVC   DAIRDWD+6(2),4(R1)  DISPLAY DARC
         UNPK  DAIRDWD(5),DAIRDWD+6(3)
         TR    DAIRDWD(4),HEXTAB-X'F0'
         MVC   QDMSG+47(4),DAIRDWD
         MVC   DAIRDWD+6(2),6(R1)  DISPLAY CTRC
         UNPK  DAIRDWD(5),DAIRDWD+6(3)
         TR    DAIRDWD(4),HEXTAB-X'F0'
         MVC   QDMSG+61(4),DAIRDWD
         LA    R1,QDMSG            ERROR MESSAGE
         LA    R0,67               ERROR MESSAGE LENGTH
         QTILT ,                   BACK WITH ERROR MESSAGE
         SPACE 1
*---     DAIR FAILURE PROCESSING                                   ---*
         SPACE 1
DAIRFAIL ST    R15,DFRETC          STORE RETURN CODE
         MVC   QDSCREEN(RESETL),RESET   SET CLEAR SEQUENCE
         TM    SZSWTCH,SCRRS       WAS SCREEN SIZE CHANGED?
         BZ    ENDFAIL             BRANCH IF NOT
         STSIZE SIZELOC=SZLINE,LINELOC=SZSCRN    RESTORE
         $FS   CC=EWA,MF=(I,QDSCREEN)
ENDFAIL  TPUT  QDSCREEN,RESETL,FULLSCR,,HOLD CLEAR THE SCREEN
         STFSMODE  OFF             TELL VTAM WE'RE DONE
         LA    R15,DFDASW          PREPARE DAIR FAILURE LIST
         ST    R15,DFIDP
         LA    R15,DFZERO
         ST    R15,DFJEFF02
         LA    R15,DFRETC
         ST    R15,DFRCP
         LA    R15,DAPLUPT
         ST    R15,DFDAPLP
         LA    R1,DFDAPLP
         LINK  EP=IKJEFF18         ERROR MESSAGE ROUTINE
         ST    R15,DFZERO          KEEP CC IN SAD
         TPUT  MESSAGE0,L'MESSAGE0 TELL THEM A SAD STORY
         L     R1,ATSOX            GET TSO WORK AREA ADDRESS
         LTR   R1,R1               WAS ACQUIRED?
         BZ    CRASHAL             NO, SKIP FREE
         LA    R0,TSOXEQL          LENGTH FOR FREEMAIN
         FREEMAIN R,LV=(0),A=(1)   FREE WORKING STORAGE
CRASHAL  ABEND 10,DUMP             DAIR FAILURE ----------------- U-010
         SPACE 1
MESSAGE0 DC    C'A MAJOR DISASTER HAS OCCURRED IN DAIR PROCESSING.'
RESET    $FS   CC=EW,WCC=(AL,KBR,RMDT),SBA=(24,79),MF=L
         $FS   SBA=(1,1),RA=(1,1,00),MF=L
         $FS   SF=(INT,IC),MF=L
RESETL   EQU   *-RESET
         SPACE 1
         LTORG
         SPACE 1
         DROP  R10,R11,R12
         TITLE '--- QUEUE/SP -- TILT -- ERROR MESSAGE ROUTINE ---'
*---------------------------------------------------------------------*
*                                                                     *
* TILT - ERROR MESSAGE ROUTINE                                        *
*                                                                     *
*        ENTRY : R0  - LENGTH OF ERROR MESSAGE                        *
*                R1  - ADDRESS OF ERROR MESSAGE                       *
*                R15 - @ TILT                                         *
*                                                                     *
*        EXIT : GO BACK TO MAIN MODULE.                               *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
TILT     QSTART
         L     R7,QVDSPL           @ DISPLAY WORK AREA
         USING QDISPLAY,R7
         NI    QDOVER,255-QAUTCMD  KILL ELIGIBLE AUTOMATIC MODE
         LR    R2,R1               @ ERROR MSG TEXT
         LR    R3,R0               LENGTH OF ERROR TEXT
         LA    R4,QDHLINE          ERROR MSG LINE
         LA    R5,L'QDHLINE        LENGTH OF ERROR MSG LINE
         DROP  R7
         CR    R3,R5               ERROR MSG TOO LONG?
         BNH   *+L'*+2             BRANCH IF ERROR MSG NOT TOO LONG
         LR    R3,R5               TRUNCATE ERROR MSG IF TOO LONG
         ICM   R3,B'1000',=C' '    PAD ERR MSG WITH BLANKS
         MVCL  R4,R2               MOVE ERROR MSG TO QDHLINE
TILT$L   QCALL DISPLAY,,0          DISPLAY ERROR MSG
         QBACK
         SPACE 1
         DROP  R11,R12
 TITLE '--- QUEUE/SP -- CKPT -- READ JES2 CHECKPOINT RECORDS ---'
*---------------------------------------------------------------------*
*                                                                     *
* CKPT - READ JES2 CHECKPOINT RECORDS ROUTINE                         *
*                                                                     *
*        PROCESSING SELECTED BY SWITCHES (SEE "SWCKPT").              *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
CKPT     QSTART
         L     R10,QVCKPT          @ CKPT WORK AREA
         USING QCKPT,R10
         TM    SWCKPT,SWCKPTDA     ONLY DAS RECORDS REQUESTED?
         BO    CKPTDAS             YES, GO DO IT
         SPACE 1
*---     REPOSITION AND READ MASTER RECORD                         ---*
         SPACE 1
         L     R2,QCMSA            ADDR OF IOAREA CKPT RECS
         POINT HASPCKPT,QCMSTTR    POINT TO MASTER RECORD
         READ  HDECB1,SF,,(R2),'S',MF=E READ MASTER RECORD
         CHECK HDECB1
         TM    SWCKPT,SWCKPTMR     ONLY M.R. REQUESTED?
         BZ    CKPTCNT             NO, CONTINUE
         NI    SWCKPT,255-SWCKPTMR YES, RESET REQUEST
         B     CKPTEX              EXIT
         SPACE 1
*---     REPOSITION AND READ DAS RECORDS                           ---*
         SPACE 1
CKPTDAS  NI    SWCKPT,255-SWCKPTDA RESET REQUEST
         LA    R2,QCDASA           @ PARM FOR CKPTRD
         BAS   R8,CKPTRD           READ DAS CKPT RECORDS
         B     CKPTEX              EXIT
         SPACE 1
*---     REPOSITION AND READ JQE RECORDS                           ---*
         SPACE 1
CKPTCNT  LA    R2,QCJQEA           @ PARM FOR CKPTRD
         BAS   R8,CKPTRD           READ JQE CKPT RECORDS
         SPACE 1
*---     REPOSITION AND READ JOE RECORDS                           ---*
         SPACE 1
         LA    R2,QCJOTA           @ PARM FOR CKPTRD
         BAS   R8,CKPTRD           READ JQE CKPT RECORDS
CKPTEX   QSTOP
         SPACE 1
*---------------------------------------------------------------------*
*                                                                     *
* CKPTRD - READ CKPT BLOCKS SUBROUTINE                                *
*                                                                     *
* ENTRY : R2 = @ +0 - @ BUFFER AREA                                   *
*                +4 - TTR OF 1ST BLOCK TO READ IN HASPCKPT            *
*                +8 - NUMBER OF BLOCKS TO READ (EACH 4K)              *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
CKPTRD   POINT HASPCKPT,4(,R2)     POINT TO 1ST BLOCK TO READ
         L     R3,0(,R2)           @ 1ST BUFFER
         L     R4,8(,R2)           # OF BLOCKS TO READ
         L     R5,=F'4096'         BLOCK LENGTH
CKPTRD1  LR    R6,R4               ASSUME CAN READ ALL BLOCKS AT ONCE
         XR    R0,R0
         IC    R0,HASPCKPT+(DCBNCP-IHADCB)   GET NCP ALLOWED
         CR    R6,R0
         BNH   *+L'*+2
         LR    R6,R0               LIMIT READ'S TO NCP MAX
         LR    R2,R6               COPY # OF READ/CHECKS TO DO
         L     R7,QCDECBPT         @ DECB WORK AREA
CKPTRD2  MVC   0(HDECB1L,R7),HDECB1     INIT DECB
         READ  (R7),SF,,(R3),(R5),MF=E  START A READ
         AR    R3,R5               BUMP READ BUFFER PTR
         LA    R7,HDECB1L(,R7)     BUMP DECB PTR
         BCT   R2,CKPTRD2
         LR    R2,R6               # OF READS JUST ISSUED
         L     R7,QCDECBPT         @ DECB WORK AREA
CKPTRD3  CHECK (R7)
         LA    R7,HDECB1L(,R7)     BUMP DECB PTR
         BCT   R2,CKPTRD3
         SR    R4,R6               DCR # BLOCKS JUST READ/CHECKED
         BNZ   CKPTRD1
         BR    R8                  RETURN IF ALL DONE
         DROP  R10
         SPACE 1
         LTORG
 TITLE '--- QUEUE/SP -- READSPC -- READ A BLOCK FROM HASPACE(S) ---'
READSPC  QSTART
         L     R10,QVCKPT          @ CKPT WORK AREA
         USING QCKPT,R10
         SPACE 1
*---------------------------------------------------------------------*
*                                                                     *
*        CONVERT MTTR TO MBBCCHHR                                     *
*                                                                     *
*        NOTE - THE INPUT TO THIS ROUTINE IS AS FOLLOWS :             *
*               QCTRAK CONTAINS THE MTTR                              *
*               R1 CONTAINS THE IOAREA ADDRESS                        *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
         LR    R2,R1               MOVE IOAREA ADDR TO R2
         ZIC   R3,QCTRAKM          RELATIVE DCB NUMBER
         CH    R3,QSPOLNUM         HIGHER THAN MAX POSSIBLE SPOOLS?
         BNL   RS$TILT             YES, ERROR, IT IS TOO LARGE
         SLL   R3,2                MULTIPLY BY 4
         MVC   QCDADR,QCTRAKR      MOVE RECORD NUMBER
         MVC   QCDADHH,QCTRAKTT    MOVE TRACK TO A HALFWORD BOUND
         LH    R5,QCDADHH          LOAD RELATIVE TRACK NUMBER
         L     R14,QCSPNMTC
         L     R15,0(R14,R3)       # TRKS/CYL FOR THIS HASPACE
         LTR   R15,R15             NONE?
         BZ    RS$DIV              YES, ERROR, BAD MTTR
         XR    R4,R4               CLEAR FOR DIVIDE
         DR    R5-1,R15            TT/(TRKS/CYL)-> TO TRK AND CYL
         STH   R4,QCDADHH          STORE HEAD NUMBER
         STH   R5,QCDADCC          STORE CYLINDER NUMBER
         L     R14,QCSPDCBP
         L     R3,0(R14,R3)        DCB ADDRESS
         LTR   R3,R3               NONE?
         BZ    RS$TILT             YES, ERROR, BAD MTTR (NO DCB)
         USING IHADCB,R3
         CLC   =C'XB',QSUBNAME     IS THIS HEXBLK?
         BNE   *+L'*+6             NO, SKIP
         MVC   DCBSYNAD,=A(HEXBLKER)    YES, SET SYNAD ADDRESS
         READ  HDECB2,DI,(R3),(R2),MF=E
         CHECK HDECB2
         MVC   DCBSYNAD,=A(1)      RESTORE NO SYNAD ADDRESS
         DROP  R3
RS$EXIT  QSTOP
RS$DIV   CLC   =C'XB',QSUBNAME     IS THIS HEXBLK?
         BNE   RS$TILT             NO, GO BLOW UP NORMALLY
         MVI   QSYNADFL,15         INDICATE ZERO DIVIDE
         B     RS$EXIT
RS$TILT  MVC   QDMSG(19),=CL19'*** INVALID MTTR : '
         UNPK  QDMSG+19(9),QCTRAK(5)
         TR    QDMSG+19(8),HEXTAB-X'F0'
         MVC   QDMSG+27(4),=CL4' ***'
         LA    R1,QDMSG
         LA    R0,31
         QTILT
         SPACE 1
         LTORG
         SPACE 1
         DROP  R10,R11,R12
 TITLE '--- QUEUE/SP -- PARSE -- COMMAND LINE PARSE ROUTINE ---'
PARSE    QSTART
         L     R10,QVDSPL          LOAD BASE REG
         USING QDISPLAY,R10        BASE REG FOR DISPLAY WORK AREA
         NI    QDFREQ,255-QDFSC-QDFSV-QDFRS
         SPACE 1
*---     PARSE SUB-COMMAND NAME                                    ---*
         SPACE 1
         LH    R2,QDRLNG           LENGTH OF REPLY LINE
         OC    QDREPLY,QBLANK      TRANSLATE TO UPPER CASE
         CLC   QDREPLY,QBLANK      IS THE ENTIRE REPLY BLANK?
         BE    LOOKUP              YES, DO LOOKUP
         MVC   P#OFFSET(4),=F'0'   ZERO THE OFFSET AND LENGTH
         MVC   FIELD,QBLANK        BLANK THE WORK FIELD
         MVC   QOFF0(12),P#OFFSET  INITIALIZE FIRST FIELD
         MVC   QOFF1(QOFFLR),QOFF0 INITIALIZE NEXT FIELDS
         LA    R6,QOFF4+12         ADDR PAST LAST FIELD
         LA    R5,QOFF0            ADDR OF FIRST SET OF FIELDS
         LA    R3,QDREPLY          FIRST BYTE OF REPLY LINE
NEXTFD   LA    R4,FIELD            FIRST BYTE OF WORK FIELD
BLANK    CLI   0(R3),C' '          IS THIS BYTE BLANK?
         BNE   P$FIRST             NO, START OF FIELD
         LA    R3,1(R3)            YES, SKIP IT
         BCT   R2,BLANK            TRY NEXT BYTE
         B     EMPTY               END OF REPLY LINE
P$FIRST  LH    R1,QDRLNG           REPLY LENGTH
         SR    R1,R2               COMPUTE OFFSET TO FIELD START
         STH   R1,P#OFFSET         STORE OFFSET
         LR    R1,R2               SAVE COUNT OF REMAINING BYTES
         LA    R0,L'FIELD          PREVENT TOO LONG TEXT MOVE
         B     CHAREX              CONTINUE
PARSE$LP CLI   0(R3),C' '          IS THIS BYTE BLANK?
         BE    LASTCH              YES, END OF FIELD
         LTR   R0,R0               NO, CAN BE MOVED?
         BZ    P$SKIP              NO
CHAREX   MVC   0(1,R4),0(R3)       MOVE BYTE TO SUB-NAME
         LA    R4,1(,R4)           INCREMENT
         BCTR  R0,0                DECREMENT
P$SKIP   LA    R3,1(,R3)           INCREMENT
         BCT   R2,PARSE$LP         TRY NEXT BYTE
LASTCH   SR    R1,R2               COMPUTE FIELD LENGTH
         CH    R1,=H'8'            IS LENGTH GREATER THAN 8?
         BNH   *+L'*+4             NO, USE IT
         LA    R1,8                YES, USE LENGTH OF EIGHT
         STH   R1,LENGTH           STORE FIELD LENGTH
EMPTY    MVC   0(12,R5),P#OFFSET   MOVE FIELD TO QCOMMON
         LTR   R2,R2               IS THE REMAINING LENGTH ZERO?
         BZ    LOOKUP              YES, DO THE TABLE LOOKUP
         MVC   P#OFFSET(4),=F'0'   ZERO OUT OFFSET AND LENGTH
         MVC   FIELD,QBLANK        BLANK THE WORK FIELD
         LA    R5,12(R5)           INCREMENT TO NEXT FIELD
         CR    R5,R6               WAS THAT THE LAST FIELD?
         BL    NEXTFD              NO, PROCESS NEXT FIELD
         SPACE 1
*---     LOOK UP THE MODULE ADDRESS FOR THE SUB-COMMAND            ---*
         SPACE 1
LOOKUP   CLI   QSUBNAME,C'X'       IS THIS A PRIVILEGED OPERATION?
         BE    SECRET              YES, CHECK FOR PASSWORD
LOOKUP2  LA    R2,P$TABLE          START OF SUB-COMMANDS TABLE
NEXT     CLC   0(2,R2),QSUBNAME    COMPARE FIRST TWO CHARACTERS
         BE    P$FOUND             THIS IS THE ONE
         LA    R2,L'P$TABLE(R2)    NEXT ENTRY
         CLI   0(R2),X'FF'         IS THIS THE END OF TABLE?
         BNE   NEXT                NO, TRY NEXT ENTRY
         LA    R2,P$TBUNK          UNKNOWN SUB-COMMAND
P$FOUND  MVC   QCODE(5),3(R2)      SUBCMD CODE AND COMMAND ADDRESS
         TM    2(R2),FLJID         IS PARM1 A <JOBID> ?
         BZ    P$STOP              NO, SKIP
         CLC   QPARM1,=CL8'*'      REQUEST PREVIOUS?
         BE    USE$PREV            YES, DON'T OVERLAY IT
         CLC   QPARM1,QBLANK       ANOTHER WAY TO DO THAT?
         BE    USE$PREV            YES, DON'T OVERLAY IT
         MVC   QJOBID(2+8),QLNG1   SAVE JOBID + LENGTH
USE$PREV MVC   QLNG1(2+8),QJOBID   RESTORE PREVIOUS
P$STOP   QSTOP
         SPACE 1
*---     CHECK AUTHORITY FOR X SUB-COMMANDS                        ---*
         SPACE 1
SECRET   CLI   QSUBNAME+1,C'P'     IS THIS THE PASSWORD?
         BE    PASSWD              YES, CHECK IT
         CLI   QXAUTH,LV15         IS THIS USER AUTHORIZED?
         BE    LOOKUP2             YES, PROCESS COMMAND
BOUNCE   LA    R2,P$TBEND          NO, INVALID
         B     P$FOUND             CONTINUE
PASSWD   CLC   QPARM1,=CL8'RESET'  DID THE USER SAY RESET?
         BNE   PASSWG              NO, LOOK FURTHER
         CLI   QXAUTH,LV15         IS THIS USER AUTHORIZED?
         BNE   BOUNCE              NO, REJECT
         MVC   QXAUTH,SAVAUTH      RESTORE ORIGINAL AUTHORITY
         QTILT '=== RESET DONE ==='
PASSWG   CLC   QPARM1,=CL8'PASSWORD'    DID THE USER SAY PASSWORD?
         BNE   BOUNCE              NO, REJECT
        PRINT  OFF
*       THE PURPOSE OF PASSWORDS IS TO ENTER SYSTEM AUTHORITY
*       UNDER ANY LOGON'ED USER-ID, ALLOWING ME TO ANALYZE
*       USER'S COMPLAINTS DIRECTLY FROM HIS SESSION (USER CAN'T
*       SEE IT BECAUSE IT IS UNVIEWABLE).
*       PASSWORDS ARE : "ARCHELAS" AND/OR "METAXAS" (MOINIL P.A.).
        PRINT  ON
         TPUT  WPASS,WPASSL,FULLSCR
         XC    RPASS,RPASS
         LA    R1,RPASS            REPLY ADDRESS
         TGET  (1),8
         OC    RPASS(L'RPASS),QBLANK
         XC    RPASS(4),RPASS+4
         CLC   RPASS(4),=XL4'040A022A'  IS THE PASSWORD CORRECT?
         BE    SETALTS             YES
         CLC   RPASS(4),=XL4'33040181'  IS THE PASSWORD CORRECT?
         BNE   BOUNCE              NO, REJECT
SETALTS  MVI   QXAUTH,LV15         AUTHORIZE USER
         QTILT '=== PASSWORD ACCEPTED ==='
         SPACE 1
WPASS    $FS   WCC=(RMDT),SBA=(24,80),MF=L
         $FS   SBA=(1,1),RA=(1,1,00),MF=L
         $FS   SF=(PROT,INT),MF=L
         $FS   TEXT='ENTER PASSWORD :',MF=L
         $FS   SF=(DARK,IC),MF=L
         $FS   SBA=(1,27),SF=(PROT),MF=L
WPASSL   EQU   *-WPASS
         SPACE 1
         LTORG
         SPACE 1
         DROP  R10,R11,R12
         SPACE 1
FLJID    EQU   X'01'               JOB-ID ARGUMENT
FLNPR    EQU   X'02'               NO REPROMPT
         SPACE 1
         DS    0D                  SUB-COMMANDS TABLE
P$TABLE  DS    0XL8                ------------------
         QSCT  +,,20,REPOS                   DOWN
         QSCT  -,,24,REPOS                   UP
         QSCT  :,,0,TSOCMD                   TSO COMMAND OR CLIST
         QSCT  @,,16,REPOS                   POSITION
         QSCT  AI,,16,SEARCH                 AVAIL INPUT
         QSCT  AO,,20,SEARCH                 AVAIL OUTPUT
         QSCT  B,,32,REPOS                   BOTTOM
         QSCT  BO,,32,REPOS                  BOTTOM
         QSCT  C,,12,REPOS                   COLUMN
         QSCT  CO,,12,REPOS                  COLUMN
         QSCT  D,,20,REPOS                   DOWN
         QSCT  DA,,4,SEARCH                  DISP ACTIVE
         QSCT  DD,FLJID,,DDNAME              LIST DDNAMES
         QSCT  DI,,8,SEARCH                  DISP INPUT
         QSCT  DJ,FLJID,36,SEARCH            DISP JOB
         QSCT  DL,,52,SEARCH                 DISP LOCAL OUTPUT
         QSCT  DO,,12,SEARCH                 DISP OUTPUT
         QSCT  DR,,56,SEARCH                 DISP REMOTE OUTPUT
         QSCT  DS,,40,SEARCH                 DISP SYS TASKS
         QSCT  DT,,32,SEARCH                 DISP TSO USERS
         QSCT  F,,4,REPOS                    FIND
         QSCT  FA,,4,REPOS                   FIND ALL
         QSCT  FI,,4,REPOS                   FIND
         QSCT  FT,,8,REPOS                   FIND TIME
         QSCT  H,FLNPR,0,HELP                HELP
         QSCT  HE,FLNPR,0,HELP               HELP
         QSCT  HI,,24,SEARCH                 HELD INPUT
         QSCT  HO,,28,SEARCH                 HELD OUTPUT
         QSCT  ID,,,IDCMD                    JES2 INITIATORS DISPLAY
         QSCT  JC,FLJID,,JCL                 LIST JCL
         QSCT  JL,FLJID,,JLOG                LIST JOBLOG
         QSCT  JM,FLJID,,JMSG                LIST JOBMSG
         QSCT  L,FLJID,,LIST                 LIST DATA-SET
         QSCT  LI,FLJID,,LIST                LIST DATA-SET
         QSCT  LP,FLJID,,LPDDB               LIST JOB PDDB'S
         QSCT  P,,,PRINT                     START/STOP HARDCOPY
         QSCT  PF,FLNPR,4,HELP               SET PF-KEYS
         QSCT  PL,FLNPR,16,HELP              LOAD PF-KEYS
         QSCT  PZ,FLNPR,8,HELP               RESET PF-KEYS
         QSCT  PR,,,PRINT                    START/STOP HARDCOPY
         QSCT  PS,FLNPR,12,HELP              SAVE PF-KEYS
         QSCT  QI,,44,SEARCH                 SUMMARY INPUT QUEUES
         QSCT  QO,,48,SEARCH                 SUMMARY OUTPUT QUEUES
         QSCT  SA,FLNPR,4,SAVEX              SAVE (IT USE LIST)
         QSCT  SL,FLJID,,SYSLOG              LIST SYSLOG
         QSCT  ST,,0,SEARCH                  STATUS
         QSCT  T,,28,REPOS                   TOP
         QSCT  TD,,4,TSOCMD                  DISPLAY TSO CMDS RC
         QSCT  TG,,,TGJU                     TRACK GROUPS JOBS USAGE
         QSCT  TO,,28,REPOS                  TOP
         QSCT  TS,,0,TSOCMD                  TSO COMMAND OR CLIST
         QSCT  U,,24,REPOS                   UP
         QSCT  UP,,24,REPOS                  UP
         QSCT  XB,,0,HEXBLK                  DISPLAY HASPACE BLOCK
         QSCT  XE,FLNPR,4,HEXBLK             SET DUMP EXT. FORMAT
         QSCT  XJ,FLJID,36,SEARCH            HEX JOE/JQE DISP
         QSCT  XL,FLJID,,LIST                LIST DATA-SET
         QSCT  XO,,,XOCMD                    DISPLAY JOES
         QSCT  XQ,,,XQCMD                    DISPLAY ALL JQES Q
         QSCT  XT,,,XTCMD                    SOME BLOCKS ...
         QSCT  YA,FLNPR,0,AUTOM              AUTOMATIC MODE ON
         QSCT  YT,,,SETTR                    TRACE FACILITIES
         QSCT  ZA,FLNPR,4,AUTOM              AUTOMATIC MODE OFF
P$TBEND  QSCT  ,,,CMDINV
P$TBUNK  QSCT  ,,,CMDUNK
         TITLE '--- QUEUE/SP -- DISPLAY -- 3270 DISPLAY ROUTINE ---'
*---------------------------------------------------------------------*
*                                                                     *
* DISPLAY - 3270 DISPLAY SUBROUTINE                                   *
*                                                                     *
*        ENTRY : R1 - @ OF TEXT                                       *
*                R0 - LENGTH OF TEXT                                  *
*                                                                     *
*        EXIT : QDOVER - FLAG SET IF SCREEN OVERFLOW                  *
*               QDMORE - *MORE*                                       *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
DISPLAY  QSTART
         USING QDISPLAY,R10
         L     R10,QVDSPL          @ OF DISPLAY WORK AREA
         STH   R0,QDMLNG           SET CALLERS LENGTH
         ST    R1,QDMSGA           AND TEXT ADDRESS
         SPACE 1
*---     CHECK FOR ROOM ON SCREEN                                  ---*
         SPACE 1
         NI    QDOVER,255-QOVPAGE  RESET INDICATOR
         MVC   QDMORE,QBLANK       BLANK THE OVERFLOW INDICATOR
         LH    R4,QDMLNG           LOAD MSG LENGTH
         CH    R4,=H'1680'         IS MSG LENGTH MORE THAN 1680?
         BH    RETURN              YES, GO AWAY
         LTR   R4,R4               IS MSG LENGTH ZERO?
         BZ    WRTSCR              YES, WRITE SCREEN
         MVC   QDMORE,=C'*MORE*'   INDICATE SCREEN OVERFLOW
         AH    R4,QDNEXT           ADD CURRENT LOCATION ON SCREEN
         CH    R4,=H'1680'         IS THERE ROOM ON THE SCREEN?
         BH    WRTSCR              NO, WRITE SCREEN
         SPACE 1
*---     MOVE THE MESSAGE TO THE SCREEN                            ---*
         SPACE 1
DSP2     LH    R7,QDMLNG           LOAD MESSAGE LENGTH
         LTR   R7,R7               IS MESSAGE LENGTH ZERO?
         BZ    RETURN              YES, RETURN
         LH    R4,QDNEXT           GET CURRENT SCREEN LINE NUMBER
         LR    R1,R4               SAVE LINE NUMBER
         LA    R4,QDLINE1(R4)      LOAD ADDRESS OF NEXT LINE
         L     R6,QDMSGA           LOAD ADDR OF MESSAGE
         LA    R5,80               LENGTH MUST BE MULTIPLE OF 80
DSP3     CR    R5,R7               IS 5 NOT LESS THAN 7?
         BNL   DSP4                YES, GO DO IT
         LA    R5,80(,R5)          INCR BY 80
         B     DSP3                TRY AGAIN
DSP4     AR    R1,R5               UPDATE LINE NUMBER
         STH   R1,QDNEXT           STORE LINE NUMBER
         ICM   R7,B'1000',=C' '    GET PAD CHAR
         LR    R1,R4               SAVE DESTINATION ADDRESS
         LR    R0,R5               SAVE DESTINATION LENGTH
         MVCL  R4,R6               MOVE THE MESSAGE TO THE SCREEN
         CLC   =A(ENDDATA),QDMSGA  IS THIS THE SPECIAL MESSAGE?
         BE    RETURN              YES, DON'T TRANSLATE
         TM    QDOVER,QTSKIP       SKIP TRANSLATE REQUESTED?
         BZ    DSP5                NO
         NI    QDOVER,255-QTSKIP   OFF INDICATOR
         B     DSP6
DSP5     TR    0(80,R1),D$TABLE    TRANSLATE OUT STRANGE CHARS
         LA    R1,80(,R1)          -> NEXT SCREEN LINE
         SH    R0,=H'80'           DECREMENT REMAINING LENGTH
         BP    DSP5                KEEP TRANSLATING
DSP6     TM    QDOVER,QPFORCE      FORCE PAGE REQUESTED?
         BO    WRTSCR              YES, WRITE SCREEN
RETURN   QSTOP
         SPACE 1
*---     WRITE A FULL SCREEN                                       ---*
         SPACE 1
WRTSCR   CLC   QDFINAL-L'QBLANK(L'QBLANK),QBLANK
*                                  LAST PART OF SCREEN BLANK?
         BNE   NORA                NO, DON'T BOTHER WITH RA
         LA    R1,QDFINAL-L'QBLANK -> FIRST CHAR TO CHECK
         BASR  R14,0               SET LOOP ADDR
         CLI   0(R1),C' '          FIND NON-BLANK?
         BNE   *+L'*+2             YES, EXIT LOOP
         BCTR  R1,R14              NO, KEEP LOOKING
         LA    R2,1(,R1)           POINT PAST LAST CHAR
         $FS   RA=(1,1,00),MF=(E,(R2))  SET RA TO TOP
         TM    QDOVER,QAUTOM+QAUTCMD    ELIGIBLE AUTOMATIC MODE?
         BNO   *+L'*+8             NO
         TM    QDPRSW,QAUTPIA      PRESERVE INPUT AREA?
         BO    TPUTK               YES
         MVC   0(QDSLNG,R2),QDFINAL     SET INPUT MANAGEMENT
         LA    R2,QDSLNG(R2)       POINT PAST LAST CHAR
TPUTR    $FS   WCC=(KBR,RMDT),MF=(I,QDSCRWCC)
         B     TPUT
NORA     LA    R2,QDPAST           POINT PAST LAST CHAR
         TM    QDOVER,QAUTOM+QAUTCMD    ELIGIBLE AUTOMATIC MODE?
         BNO   TPUTR               NO
         TM    QDPRSW,QAUTPIA      PRESERVE INPUT AREA?
         BZ    TPUTR               NO
         LA    R2,QDFINAL          POINT PAST LAST CHAR
*                                  ADD INPUT MANAGEMENT
TPUTK    $FS   WCC=(KBR),MF=(I,QDSCRWCC)
TPUT     LA    R3,QDSCREEN         LOAD ADDRESS OF SCREEN BUFFER
         TM    SZSWTCH,SCRST+SCRRS FIRST TPUT DONE?
         BNO   SNDWR               BRANCH IF YES
         $FS   CC=EW,MF=(I,(R3))   SET ERASE/WRITE
SNDWR    SR    R2,R3               COMPUTE TPUT LENGTH
         ICM   R3,B'1000',=X'03'   GET FULLSCREEN FLAG
         NI    QDPRSW,255-QAUTPIA  RESET
         TM    QHFREQ,QHCOPY       IS HARDCOPY ACTIVE?
         BZ    RESHOW              NO
         TM    QDOVER,QAUTOM+QAUTCMD    ELIGIBLE AUTOMATIC MODE?
         BO    RESHOW              YES
         QCALL HCOPY               HARDCOPY SCREEN
RESHOW   LR    R1,R3               GET THE ADDRESS
         LR    R0,R2               GET THE LENGTH
         TPUT  (1),(0),R           WRITE SCREEN
         TM    SZSWTCH,SCRST+SCRRS FIRST TPUT DONE?
         BNO   SNDGT               BRANCH IF YES
         $FS   CC=W,MF=(I,(R3))    RESTORE WRITE
         NI    SZSWTCH,255-SCRST   SET FIRST TPUT DONE
SNDGT    XC    PFREPLY,PFREPLY
         MVC   QDREPLY,QBLANK
         XC    TIMEVL,TIMEVL       RESET TIME COUNTER
         TM    QDOVER,QAUTOM+QAUTCMD    ELIGIBLE AUTOMATIC MODE?
         BO    SAUTOM              YES
         SPACE 1
*---     WAIT FOR REPLY                                            ---*
         SPACE 1
         TGET  PFREPLY,L'PFREPLY-3,ASIS NORMAL, WAIT FOR REPLY
         B     ANALRP
         SPACE 1
*---     START WAIT TIME AND THEN SEE IF ANY REPLY                 ---*
         SPACE 1
SAUTOM   ZEROKEY
         $NOSWAP QASID
         ST    R1,SRMCC
         CLI   SRMCC+3,0
         BNE   DIAG1
         STIMER  WAIT,,BINTVL=TIMESC,ERRET=TINTERR
         $OKSWAP QASID
         ST    R1,SRMCC
         RESETKEY
         CLI   SRMCC+3,0
         BNE   DIAG2
         TGET  PFREPLY,L'PFREPLY-3,ASIS,NOWAIT    NO WAIT REPLY
         LTR   R15,R15             ANY INPUT AVAILABLE?
         BZ    GETTEXT             YES
         CH    R15,=H'4'           NORMAL NOWAIT?
         BNE   GETTEXT             NO
         L     R1,TIMEVL           UPDATE TIME COUNTER
         A     R1,TIMESC
         CL    R1,TIMECT           NEXT PANEL TO SHOW?
         BNL   NXPANEL             YES
         ST    R1,TIMEVL
         B     SAUTOM
TINTERR  $OKSWAP QASID
         ST    R1,SRMCC
         RESETKEY
         CLI   SRMCC+3,0
         BNE   DIAG3
         NI    QDOVER,255-QAUTOM-QAUTCMD     OFF AUTOMATIC MODE
         OI    QDOVER,QDAMAGE      INDICATE DAMAGED CLOCKS
         MVC   PFTXT(3),=CL3'ZA'   AUTO OFF
         LA    R1,L'PFCODE+3
         B     STENTK
DIAG1    RESETKEY
         MVI   PFTXT+9,C'1'
         B     DIAGZA
DIAG2    MVI   PFTXT+9,C'2'
         B     DIAGZA
DIAG3    MVI   PFTXT+9,C'3'
DIAGZA   NI    QDOVER,255-QAUTOM-QAUTCMD     OFF AUTOMATIC MODE
         OI    QDOVER,QDAMAGE      FORCE DAMAGED CLOCKS
         MVC   PFTXT(9),=CL9'ZA SRMCC'  AUTO OFF + SWAP
         LA    R1,L'PFCODE+9
         B     STENTK
NXPANEL  TM    QXSWXQ,RQTR         TRACE REQUESTED?
         BZ    GOPANEL             NO
         L     R1,TIMEVLM
         A     R1,TIMECT
         CL    R1,TIMECTM          MAX. TIME REACHED?
         BL    GOPANEL             NO, CONTINUE
         QCALL TRACE,1             SNAP. USER CODE 001. -------- ID-001
GOPANEL  ST    R1,TIMEVLM
         LA    R1,3
         OI    QDPRSW,QAUTPIA      PRESERVE INPUT AREA
STENTK   MVI   PFCODE,X'7D'        SIMULATE ENTER KEY
         XR    R15,R15
         B     ANALRP
GETTEXT  NI    QDOVER,255-QAUTCMD  KILL ELIGIBILITY
         XC    TIMEVLM,TIMEVLM
         SPACE 1
*---     HANDLE THE REPLY                                          ---*
         SPACE 1
ANALRP   CLI   PFCODE,X'6E'        PA2? (RESHOW)
         BE    TCLEARQ             YES, GO FLUSH REST OF INPUT
         CH    R15,=H'12'          INPUT LONGER THAN BUFFER?
         BNE   NOCLEAR             NO, CONTINUE
TCLEARQ  LR    R4,R1               SAVE THE INPUT LENGTH
         TCLEARQ INPUT             CLEAR THE QUEUE
         LR    R1,R4               RESTORE THE INPUT LENGTH
         CLI   PFCODE,X'6E'        PA2? (RESHOW)
         BE    RESHOW              YES, RE-DISPLAY LAST SCREEN
NOCLEAR  LA    R4,QDLINE1          LOAD ADDRESS OF FIRST LINE
         LA    R5,1680             LOAD LENGTH OF SCREEN
         XR    R6,R6               NO SENDING FIELD NEEDED
         STH   R6,QDNEXT           STORE ZERO IN LINE NUMBER
         L     R7,=A(X'40000000')  FILL SCREEN WITH BLANKS
         MVCL  R4,R6               CLEAR THE SCREEN
         XC    QDTLINE,QDTLINE     CLEAR INPUT AREA ON SCREEN
         LA    R6,QDREPLY
         LA    R7,QDREPLYL         MAX. MOVE INSTR. LENGTH
         LH    R4,=Y(PFKNO)
         LA    R5,PFKTAB
SCANPFK  CLC   PFCODE(1),0(R5)     IS A PF-KEY ENTERED?
         BE    ENTPFK              YES
         LA    R5,L'PFKTAB(R5)     NO, LOOK TO NEXT
         BCT   R4,SCANPFK          LOOP UNTIL NO MORE
         XR    R5,R5               GO AS 'ENTER' KEY
         B     ENTKEY
ENTPFK   MVC   QDREPLY(L'PFKTAB-1),1(R5)     MOVE PF-KEY VALUE
         LA    R5,L'PFKTAB
         LA    R6,L'PFKTAB(,R6)
         LR    R7,R6
         BCTR  R7,0
CMPPFK   BCTR  R7,0
         CLI   0(R7),C' '
         BNE   *+L'*+6
         BCTR  R6,0
         BCT   R5,CMPPFK
         LA    R7,QDREPLYL         MAX. MOVE INSTR. LENGTH
         SR    R7,R5
ENTKEY   SH    R1,=H'3'
         BNP   NOTXT
         SH    R1,=H'3'
         BNP   NOTXT
         CLR   R1,R7               CONTROL MOVE LENGTH
         BNH   *+L'*+2
         LR    R1,R7               TRUNCATE IF TOO LONG
         BCT   R1,*+L'*+6
         MVC   0(*-*,R6),PFTXT     <<EXECUTED>>
         EX    R1,*-6
         LA    R5,1(R5,R1)
NOTXT    STH   R5,QDRLNG           STORE LENGTH OF REPLY
         TM    QDOVER,QPROMPT      WAS IT A REPROMPT?
         BZ    NPROMPT             NO
         NI    QDOVER,255-QPROMPT  RESET IT
         MVC   QDHLINE,QDHSAVE     RESTORE HEADING
         LTR   R5,R5               RESPONSE FROM USER?
         BNZ   INTER               YES, INTERRUPT PROCESSING
         MVC   QDREPLY,QDPROMPT    NO, SET LAST COMMAND IN REPLY AREA
         MVC   QDRLNG,QDRLNGP      SET LENGTH
         B     INTER               SIMULATE RESPONSE FROM USER
NPROMPT  LTR   R5,R5               RESPONSE FROM USER?
         BNZ   INTER               YES, INTERRUPT PROCESSING
         TM    QDPRSW,QRPVCMD      RESTORE SUB-COMMAND REQ?
         BZ    PROCEED             NO
         MVC   QDREPLY,QDPROMPT    YES, SET LAST COMMAND IN REPLY AREA
         MVC   QDRLNG,QDRLNGP      SET LENGTH
PROCEED  OI    QDOVER,QOVPAGE      INDICATE PAGE OVERFLOW
         NI    QDPRSW,255-QRPVCMD  RESET EVENTUAL RESTORE REQ
         TM    QDOVER,QPFORCE      FORCE PAGE REQUESTED?
         BZ    DSP2                NO, CONTINUE PROCESSING
         NI    QDOVER,255-QPFORCE  RESET FORCE PAGE INDICATOR
         B     RETURN
INTER    NI    QDOVER,255-QPFORCE  RESET FORCE PAGE INDICATOR
         NI    QDPRSW,255-QRPVCMD  RESET EVENTUAL RESTORE REQ
         CLI   QDREPLY,C'*'        REPROMPT REQUEST?
         BE    REPROMPT            YES, DO IT
         OC    QDREPLY(2),QBLANK   UPPER CASE SUB-COMMAND
         L     R15,=A(P$TABLE)     START OF SUB-COMMANDS TABLE
SCTAB    CLC   QDREPLY(2),0(R15)   THIS ONE?
         BE    TSNPR               YES
         LA    R15,L'P$TABLE(R15)  NO, NEXT ENTRY
         CLI   0(R15),X'FF'        IS THIS THE END OF TABLE?
         BNE   SCTAB               NO, TRY NEXT ENTRY
         B     SETRP               YES, GO SET TO REPROMPT
TSNPR    TM    2(R15),FLNPR        NO REPROMPT?
         BZ    SETRP               NO, GO SET TO REPROMPT
         OI    QDPRSW,QRPVCMD      YES, SET RESTORE SUB-COMMAND REQ
         B     RBACK               DON'T SET TO REPROMPT
SETRP    MVC   QDPROMPT,QDREPLY    SAVE REPLY IN CASE REPROMPT
         STH   R5,QDRLNGP          SAVE LENGTH FOR REPROMPT
RBACK    QBACK
REPROMPT MVC   QDTLINE,QDPROMPT    COPY LAST COMMAND
         OI    QDOVER,QPROMPT      SIGNAL IT
         MVC   QDHSAVE,QDHLINE     SAVE HEADING
         MVC   QDHLINE(L'QDHLINE),QBLANK     CLEAR HEADING
         B     WRTSCR              RE-DISPLAY THE LAST COMMAND
         EJECT
*        TABLE OF PRINTABLE CHARACTERS
         SPACE 1
D$TABLE  DC    256C'?'             TRANSLATE ALL GARBAGE TO '?'
         ORG   D$TABLE+C' '        BLANK
         DC    C' '
         ORG   D$TABLE+C''        CENT
         DC    C'.<(+|&&'
         ORG   D$TABLE+C'!'        EXCLAMATION
         DC    C'!$*);-/'
         ORG   D$TABLE+C''        BROKEN BAR
         DC    C',%_>?'
         ORG   D$TABLE+C'`'        ACCENT GRAVE
         DC    C'`:#@''="'
         ORG   D$TABLE+C'A'-X'40'
         DC    X'818283848586878889'
         ORG   D$TABLE+C'J'-X'40'
         DC    X'919293949596979899'
         ORG   D$TABLE+C'S'-X'40'
         DC    X'A2A3A4A5A6A7A8A9'
         ORG   D$TABLE+C'A'
         DC    C'ABCDEFGHI'
         ORG   D$TABLE+C'J'
         DC    C'JKLMNOPQR'
         ORG   D$TABLE+C'S'
         DC    C'STUVWXYZ'
         ORG   D$TABLE+C'0'
         DC    C'0123456789'
         ORG   D$TABLE+C'{'        LEFT BRACE
         DC    C'{'
         ORG   D$TABLE+C'}'        RIGHT BRACE
         DC    C'}'
         ORG   D$TABLE+C'~'        TILDE
         DC    C'~'
         ORG   D$TABLE+C'\'        BACKSLASH
         DC    C'\'
         ORG
         EJECT
         LTORG
         SPACE 1
         DROP  R10,R11,R12
         TITLE '--- QUEUE/SP -- TRACE -- SNAP ROUTINE ---'
*---------------------------------------------------------------------*
*                                                                     *
* TRACE - SNAP ROUTINE                                                *
*                                                                     *
*        ENTRY : R1  - USER CODE (SNAP ID NUMBER),                    *
*                      VALID CODE : 1 TO 255 (1 TO 127 = JUST ONCE).  *
*                R15 - @ SNAP                                         *
*                                                                     *
*        NOTE - THE FOLLOWING ALLOCATION IS NEEDED TO OBTAIN          *
*               THE SNAP DUMP :                                       *
*                                                                     *
*                    ALLOC F(SYSSNAP) SYSOUT(A)                       *
*                                                                     *
*               OR A PRE-ALLOCATED DATA-SET (THE CHARACTERISTICS      *
*               WILL BE FORCED RECFM=VBA,BLKSIZE=1632,LRECL=125)      *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
TRACE    QSTART
         L     R10,QVDSPL          @ DISPLAY WORK AREA
         USING QDISPLAY,R10
         L     R9,QVSNAP           @ SNAP WORK AREA
         USING QSNAP,R9
         TM    QXSWXQ,SKTR         TRACE FILE IN ERROR?
         BO    TRACE23             YES
         LTR   R7,R1               TEST AND SAVE ID NUMBER
         BNP   TRACE24             IGNORE IF ERRONEOUS
         CH    R1,=H'255'          ID IS VALID RANGE?
         BNL   TRACE24             IGNORE IF ERRONEOUS
         XR    R0,R0
         SLDL  R0,24
         SRL   R1,24
         LA    R4,SNAPIDT
         ALR   R4,R0
         LA    R3,X'80'
         SRL   R3,0(R1)
         EX    R3,TRACET           ID IS ACTIVE?
         BZ    TRACE10             NO, SKIP
         LA    R6,SNAPDCB
         USING IHADCB,R6
         TM    QXSWXQ,OPTR         TRACE FILE ALREADY OPENED?
         BO    TRACE3              YES
         L     R2,#TSTIOT            TIOT POINTER
         USING TIODSECT,R2
         XR    R1,R1
TRACE1   CLC   TIOELNGH(4),=F'0'
         BE    TRACE21
         CLC   TIOEDDNM(L'TIOEDDNM),DCBDDNAM
         BE    TRACE2
         IC    R1,TIOELNGH
         ALR   R2,R1
         B     TRACE1
         DROP  R2
TRACE2   OPEN  ((R6),OUTPUT),MF=(E,SNAPOP)
         TM    DCBOFLGS,DCBOFOPN   OPEN SUCCESSFULL?
         BZ    TRACE21             NO, OPEN ERROR
         OI    QXSWXQ,OPTR         SET TRACE FILE OPENED?
         L     R1,4(R11)           SET LIST
         L     R1,16(R1)
         ST    R1,SNAPLST          DISPLAY MODULE START + VERSION
         LA    R1,32(R1)
         ST    R1,SNAPLST+4
         OI    SNAPLST+4,X'80'
         LA    R1,HDQSP            SET HEADER
         ST    R1,SNAPHD
         OI    SNAPHD,X'80'
TRACE3   SNAP  DCB=(R6),TCB='S',ID=(R7),PDATA=(REGS,SPLS),             1
               LIST=SNAPLST,STRHDR=SNAPHD,MF=(E,SNAPCTL)
         LTR   R5,R15              TEST AND SAVE COMPLETION CODE
         BNZ   TRACE20             BRANCH IF SNAP ERROR
         CH    R7,=H'128'          IS IT A JUST ONCE ID?
         BNL   TRACE10             NO
         XR    R1,R1
         BCTR  R1,0
         XR    R1,R3
         EX    R1,TRACER           OFF TRACE ID
         OC    SNAPIDT,SNAPIDT     ANY OTHER ONE ACTIVE?
         BNZ   TRACE10             YES
         NI    QXSWXQ,255-RQTR     OFF TRACE REQUEST
TRACE10  XR    R15,R15             SET RC
TRACEX   QSTOP
TRACE20  CLOSE ((R6)),MF=(E,SNAPCL)
         B     TRACE22
         DROP  R6
TRACE21  LA    R5,2*16             SET OPEN ERROR (RC = X'20')
TRACE22  NI    QXSWXQ,255-RQTR-OPTR     OFF TRACE
         OI    QXSWXQ,SKTR         SET TRACE FILE IN ERROR
         XC    SNAPIDT,SNAPIDT     OFF ALL TRACE ID'S
         MVC   QDMSG(L'TRACEM),TRACEM
         STC   R5,QDMSG+L'TRACEM-5 SET RC IN MSG
         SRL   R5,4
         STC   R5,QDMSG+L'TRACEM-6
         NC    QDMSG+L'TRACEM-6(2),=XL2'0F0F'
         TR    QDMSG+L'TRACEM-6(2),HEXTAB
         CVD   R7,FMT@CONV         SET ID NUMBER IN MSG
         UNPK  QDMSG+13(3),FMT@CONV+6(2)
         OI    QDMSG+15,C'0'
         LA    R1,QDMSG
         LA    R0,L'TRACEM
         B     TRACE30
TRACE23  LA    R1,TRACED
         LA    R0,L'TRACED
         B     TRACE30
TRACE24  LA    R1,TRACEI
         LA    R0,L'TRACEI
TRACE30  LA    R4,QDLINE1          LOAD ADDRESS OF FIRST LINE
         LA    R5,1680             LOAD LENGTH OF SCREEN
         XR    R6,R6               NO SENDING FIELD NEEDED
         STH   R6,QDNEXT           STORE ZERO IN LINE NUMBER
         L     R7,=A(X'40000000')  FILL SCREEN WITH BLANKS
         MVCL  R4,R6               CLEAR THE SCREEN
         XC    QDTLINE,QDTLINE     CLEAR INPUT AREA ON SCREEN
         TM    QXSWXQ,NFTR         FULL SCREEN INHIBIT?
         BO    TRACE31             NO
         TPUT  (1),(0),R           ISSUE MESSAGE
         B     TRACE10
TRACE31  TM    QXSWXQ,MSTR         BACK MESSAGE?
         BO    TRACE32             YES
         QTILT
TRACE32  LA    R15,4               SET RC (R0-R1 MESSAGE PENDING)
         B     TRACEX
TRACET   TM    0(R4),*-*           <<EXECUTED>>
TRACER   NI    0(R4),*-*           <<EXECUTED>>
         SPACE 1
TRACEM   DC    C'--- TRACE ID-    REQUESTED, RC =    ---'
TRACED   DC    C'--- TRACE HAS BEEN DISABLED ---'
TRACEI   DC    C'--- INVALID TRACE ID REQUESTED ---'
HDQSP    DC    AL1(L'HDQSPT)
HDQSPT   DC    C'Q S P - DUMP OF WORK-AREAS (R11 = A.QCOMMON).'
         SPACE 1
         LTORG
         SPACE 1
         DROP  R9,R10,R11,R12
 TITLE '--- QUEUE/SP -- FINDJOB -- LOC. JQE, JCT, IOT BY JOB-ID ---'
FINDJOB  QSTART
         USING QCKPT,R10           BASE REG FOR CHECKPT WORK AREA
         L     R10,QVCKPT          LOAD BASE REG
         SPACE 1
*---     DETERMINE IF SEARCH IS BY JOB NUMBER OR JOB NAME          ---*
         SPACE 1
         LH    R1,QLNG1            LENGTH OF PARAMETER FIELD
         SH    R1,=H'1'            IS THE LENGTH ZERO?
         BM    FJ$TILT             YES, TILT
         CLI   QPARM1,C'0'         IS THE FIRST CHARACTER NUMERIC?
         BL    JOBNAME             NO, SEARCH BY JOB NAME
         LA    R15,QPARM1          POINT TO PARM
         BAS   R14,QNUMCONV        CONVERT IT
         BNE   FJ$TILT             TILT IF NOT NUMERIC
         LR    R5,R15              SAVE THE VALUE
         SPACE 1
*---     LOCATE JQE BY JOB NAME                                    ---*
         SPACE 1
JOBNAME  L     R2,QCJQHEAD         @ JQE'S QUEUES HEADS
         LA    R1,$JQTYPES         # OF QUEUES
NEXTJQT1 L     R3,0(,R2)
NEXTJQE1 N     R3,=A(X'00FFFFFF')  OFFSET TO JQE
         BZ    ENDJQE              BRANCH IF END OF QUEUE
         AL    R3,QCJQEWA          ADD BASE TO OFFSET
         USING JQE,R3              BASE REG FOR JQE
         CLI   QPARM1,C'0'         IS SEARCH BY JOB NUMBER?
         BL    CLCNAME             NO, SEARCH BY JOB NAME
         CH    R5,JQEJOBNO         IS THIS THE RIGHT JOB NUMBER?
         BNE   NOMATCH             NO, TRY NEXT JQE
         B     FJ$FOUND            YES, PROCESS IT
CLCNAME  CLC   QPARM1,JQEJNAME     IS THIS THE RIGHT JOB NAME?
         BE    FJ$FOUND            YES, PROCESS IT
NOMATCH  L     R3,JQENEXT          OFFSET OF NEXT JQE OR 0 MAS/SP3
         B     NEXTJQE1            LOOP
ENDJQE   LA    R2,$JQHEADL(,R2)    TRY NEXT QUEUE
         BCT   R1,NEXTJQT1         LOOP IF NOT LAST QUEUE
FJ$TILT  QTILT '*** JOB NAME OR NUMBER NOT FOUND OR INVALID ***'
         SPACE 1
*---     READ JCT AND IOT                                          ---*
         SPACE 1
FJ$FOUND ST    R3,QCJQECA          SAVE THE ADDRESS
         ICM   R1,B'1111',JQETRAK  DISK ADDR OF JCT
         BZ    FJ$NOJCT            BRANCH IF NO JCT
         STCM  R1,B'1111',QCTRAK   SET IT FOR READ
         TM    JQEFLAG3,JQE3SYSD   JQETRAK POINT TO IOT?
         BO    FJ$SYSDS            YES
         DROP  R3
         L     R3,QCJCTA           ADDR OF IOAREA FOR JCT
         LR    R1,R3               PARM FOR READSPC
         QCALL READSPC             READ HASPACE
         USING JCTSTART,R3         BASE REG FOR JCT
         CLC   JCTID,=CL4'JCT '    IS THIS A JCT?
         BNE   FJ$JCTER            BRANCH IF NOT VALID JCT
         MVC   QPJOBID,JCTJBKEY    JOB IDENTIFICATION
         MVC   QCTRAK,JCTIOT       DISK ADDR OF IOT
         DROP  R3
         L     R3,QCIOTA           @ IOT BUFFER AREA
         LR    R1,R3               PARM FOR READSPC
         QCALL READSPC             READ IOT
         USING IOTSTART,R3
         CLC   IOTID,=CL4'IOT '   IS THIS IOT?
         BNE   FJ$IOTER           BRANCH IF NOT IOT
         DROP  R3
STOP     QSTOP
FJ$NOJCT QTILT 'THIS JOB HAS NO JCT OR IOT'
FJ$SYSDS QTILT 'THIS IS A SYSTEM DS JOB'
FJ$JCTER QTILT 'INVALID JCT (BAD JCTID)'
FJ$IOTER QTILT 'INVALID IOT (BAD IOTID)'
         SPACE 1
         LTORG
         SPACE 1
         DROP  R10,R11,R12
 TITLE '--- QUEUE/SP -- FORMAT -- JQE AND JOE FORMAT ROUTINE ---'
*---------------------------------------------------------------------*
*                                                                     *
* FORMAT : FORMAT JOES OR JQES                                        *
*          OR DUMP HEX JOES OR JQES                                   *
*                                                                     *
*        ENTRY : R1 = 0 FORMAT JQE                                    *
*                R1 = 4 FORMAT JOE                                    *
*                R8 = @ JOE (IF JOE FORMAT REQUESTED)                 *
*                R9 = @ JQE                                           *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
FORMAT   QSTART
         L     R10,QVDSPL          LOAD BASE REG
         USING QDISPLAY,R10        BASE REG FOR DISPLAY WORK AREA
         USING JQE,R9              BASE REG FOR JQE DSECT
         USING JOE,R8              BASE REG FOR JOE DSECT
         CLI   QSUBNAME,C'X'       IS THE REQUEST FOR A HEX DUMP?
         BE    HEXDM               YES
         MVC   FCLEAR,QBLANK       CLEAR THE PRINT AREA
         MVC   FQUEUE(1),QCLASS    CLASS NAME
         CLI   QCLASS,(2+(2*36))
         BNL   *+L'*+6
         MVC   FQUEUE,QCLASSE
         MVC   QDHLINE,FMT#HEAD    REPORT HEADING
         LA    R15,JOEROUT         POINT TO REMOTE ID
         LTR   R1,R1               JQE OR JOE?
         BNZ   FMT$ROUT            JOE
         LA    R15,JQEPUNRT        POINT TO PUNCH ROUTE FIELD
         L     R14,QCMSA           @ MASTER CKPT RECORD
         LH    R14,$NODEID-$SAVEBEG(,R14)    THIS NODE ID
         SLL   R14,16              MAKE LOCAL ID
         CL    R14,0(,R15)         IS THIS LOCAL?
         BNE   FMT$ROUT            NO, GO FORMAT IT
         LA    R15,JQEPRTRT        POINT TO PRINT ROUTE FIELD
FMT$ROUT BAS   R14,FMT$RJE         GO DECODE DEST (ROUTE)
         TM    JQEFLAG1,JQE1BUSY   IS THE JOB EXECUTING?
         BZ    NOTBUSY             NO, SKIP THIS ROUTINE
         IC    R15,JQEFLAG1        GET SYSTEM NUMBER
         N     R15,=A(JQE1BUSY)    ZERO OUT UNWANTED BITS
         SLL   R15,3               MULTIPLY BY 8
         LA    R15,QSYSIDU(R15)    OBTAIN SYSTEM ID
         MVC   FSYSID,0(R15)       MOVE SYSTEM ID TO DISPLAY
NOTBUSY  LTR   R1,R1               IS REQUEST FOR JQE OR JOE?
         BZ    LISTJQE             JQE
         SPACE 1
*---     FORMAT JOE                                                ---*
         SPACE 1
         MVI   FQNAME,C'O'         MOVE IN NAME OF QUEUE
         CLI   JOEDEVID,X'0F'      EXTERNAL WRITER?
         BNE   *+L'*+6             NO, SKIP
         MVC   FDEV,=C'XWTR'       YES
         TM    JOEFLAG2,JOE2SLEC   IS THIS JOE SELECTABLE?
         BZ    *+L'*+4             YES, DON'T FLAG IT
         MVI   FHOLD,C'N'          NO, SAY SO
         SPACE 1
*---     NOTE THAT IF THE JOB IS TRULY ON THE EXTERNAL             ---*
*---     WRITER (AND NOT ALSO ON A REAL PRINTER),                  ---*
*---     THE ON-PRINTER & ON-PUNCH FLAGS WILL BE OFF.              ---*
         SPACE 1
         L     R0,JOERECCT         NUMBER OF PRINT LINES
         TM    JOEFLAG1,JOE1PRT+JOE1PUN PRINTING OR PUNCHING?
         BZ    FMT$LNCT            NO, SKIP
         MVC   FDEV,=C'INT.'       ASSUME IT WAS $I'D
         TM    JOEFLAG1,JOE1BUSY   BUT WAS IT INTERRUPTED?
         BZ    NOT$PRT             YES, OK
         TM    JOEFLAG1,JOE1PRT    IS IT PRINTING?
         BNO   *+L'*+4             NO, SKIP
         MVI   FDEV,C'#'           SHOW IT'S PRINTING
         TM    JOEFLAG1,JOE1PUN    IS IT PUNCHING?
         BNO   *+L'*+4             NO, SKIP
         MVI   FDEV,C'@'           SHOW IT'S PUNCHING
         XR    R15,R15
         ICM   R15,B'0011',JOEDEVID+1   GET PRINTER/PUNCH NUMBER
         CVD   R15,FMT@CONV        MAKE IT EBCDIC
         MVC   FMT@CONV(4),=XL4'40202120'
         ED    FMT@CONV(4),FMT@CONV+6
         MVC   FDEV+1(L'FDEV-1),FMT@CONV+1   SET DEVICE NUMBER
NOT$PRT  TM    JOEFLAG1,JOE1CKV    IS THE CKPT VALID
         BZ    FMT$LNCT            NO, SKIP IT
         S     R0,JOEWRECN         SUB RECS PRINTED FROM TOTAL
FMT$LNCT CVD   R0,FMT@CONV         CONVERT TO DECIMAL
         MVC   FLINES,ED5          PREPARE FOR EDIT
         C     R0,=F'99999'        TOO BIG?
         BH    FMT$LNC2            YES, DO IT THE OTHER WAY
         ED    FLINES,FMT@CONV+5   PRINT UPDATED LINE COUNT
         B     FMT$CHAR            FORMAT CHARACTERISTICS
FMT$LNC2 MVI   FLINES+5,C'K'       MAKE IT *1000
         ED    FLINES,FMT@CONV+4   GET JUST THE RIGHT AMOUNT
FMT$CHAR ZIC   R0,JOEPRIO          LOAD JOE PRIORITY
         CVD   R0,FMT@CONV         CONVERT TO DECIMAL
         MVC   FIELD(4),=XL4'40202120'  PREPARE FOR EDIT
         ED    FIELD(4),FMT@CONV+6 EDIT JQE PRIORITY
         MVC   FPRIO(L'FPRIO),FIELD+4-L'FPRIO
         L     R8,JOECHAR          OFFSET TO CHARACTERISTICS JOE
         N     R8,=A(X'00FFFFFF')  ANY CHAR-JOE?
         BZ    FMT$LIST            BRANCH IF NO CHAR-JOE
         AL    R8,QCJOTWA          ADD BASE TO OFFSET
         CLC   =CL8'STD ',JOEFORM  IS IT STANDARD?
         BE    *+L'*+6             YES, DON'T DISPLAY IT
         MVC   FFORM,JOEFORM       MOVE FORM NAME
         CLC   =C'****',JOEUCS     IS IT STANDARD?
         BE    *+L'*+6             YES, DON'T DISPLAY IT
         MVC   FUCS,JOEUCS         MOVE UCS NAME
         CLC   =C'****',JOEFCB     IS IT STANDARD?
         BE    *+L'*+6             YES, DON'T DISPLAY IT
         MVC   FFCB,JOEFCB         MOVE FCB NAME
         B     FMT$LIST            FORMAT REST OF LINE
         SPACE 1
*---     FORMAT JQE                                                ---*
         SPACE 1
LISTJQE  CLI   QCLASS,0            IS THIS THE TSO QUEUE?
         BE    LISTTSO             YES, DO IT
         CLI   QCLASS,4            IS THIS THE STC QUEUE?
         BE    LISTSTC             YES, DO IT
         CLI   QCLASS,8            IS THIS THE HELD OUTPUT QUEUE?
         BE    LISTHO              YES, DO IT
         MVI   FQNAME,C'I'         NAME OF QUEUE
         TM    JQEFLAG1,JQE1BUSY   IS THE JOB EXECUTING?
         BZ    *+L'*+4             NO, SKIP
         MVI   FQNAME,C'X'         NAME OF QUEUE
         MVC   QDHLINE+28(L'FMT#RLN),FMT#RLN MODIFY HEADING
         MVC   QDHLINE+42(L'FMT#RTI),FMT#RTI MODIFY HEADING
         DROP  R10
         L     R10,QVCKPT          LOAD BASE REG
         USING QCKPT,R10           BASE REG FOR CHECKPT WORK AREA
         MVC   QCTRAK,JQETRAK      DISK ADDR OF JCT
         L     R3,QCJCTA           ADDR OF IOAREA FOR JCT
         LR    R1,R3               PARM FOR READSPC
         QCALL READSPC             READ HASPACE
         DROP  R10
         L     R10,QVDSPL          RESTORE BASE REG
         USING QDISPLAY,R10        BASE REG FOR DISPLAY WORK AREA
         USING JCTSTART,R3         BASE REG FOR JCT
         CLC   JCTID,=CL4'JCT '    IS THIS A JCT?
         BNE   FM$JCTER            BRANCH IF NOT VALID JCT
         CLC   JCTJNAME,JQEJNAME   IS THIS JOB?
         BNE   FM$JOBER            BRANCH IF NOT MATCH
         L     R1,JCTESTLN         ESTIMATED LINES
         XR    R0,R0
         D     R0,=F'1000'         MAKE IT IN KILO
         CLI   QCODE,8             IS THIS A DI REQUEST?
         BNE   *+L'*+10            NO, SKIP
         LR    R2,R1               UPDATE TOTAL I/O
         A     R2,TOTLNES
         ST    R2,TOTLNES
         LA    R2,FLINES
         BAS   R14,FMT$EDIT
         L     R1,JCTETIME         ESTIMATED CPU TIME
         CLI   QCODE,8             IS THIS A DI REQUEST?
         BNE   *+L'*+10            NO, SKIP
         LR    R15,R1              UPDATE TOTAL CPU
         A     R15,TOTCPU
         ST    R15,TOTCPU
         LA    R15,FMT$FIO
         BAS   R14,FMT$CVD
         MVC   FCPU,=CL9'  0: 0: 0'
         MVC   FCPU+7(2),FIELD+2
         BAS   R14,FMT$CVD
         MVC   FCPU+4(2),FIELD+2
         LTR   R0,R1
         BNPR  R15
         BAS   R14,FMT$CVDE
         MVC   FCPU(3),FIELD+1
FMT$FIO  L     R1,JCTUSER0         ESTIMATED I/O
         LA    R1,0(R1)
         CLI   QCODE,8             IS THIS A DI REQUEST?
         BNE   *+L'*+10            NO, SKIP
         LR    R2,R1               UPDATE TOTAL I/O
         A     R2,TOTIO
         ST    R2,TOTIO
         LA    R2,FIO
         BAS   R14,FMT$EDIT
         AIF   ('&SYSPARM' NE 'CJS').CJS1
         CLI   JCTUSER1,0          ANY CJS NET-ID?                -CJS-
         BE    FMT$PRIO            NO, CONTINUE                   -CJS-
         MVC   FCJSID(L'FCJSID),JCTUSER1     TELL IT TO OPER      -CJS-
.CJS1    B     FMT$PRIO            CONTINUE
         DROP  R3
FMT$EDIT CVD   R1,FMT@CONV         CONVERT TO DECIMAL
         MVC   0(L'ED5,R2),ED5     PREPARE FOR EDIT
         C     R1,=F'99999'        TOO BIG?
         BH    FMT$EDK             YES, DO IT THE OTHER WAY
         ED    0(L'ED5,R2),FMT@CONV+5   EDIT EST. LINES
         BR    R14
FMT$EDK  MVI   5(R2),C'M'          MAKE IT MEGA
         ED    0(L'ED5,R2),FMT@CONV+4   GET JUST THE RIGHT AMOUNT
         BR    R14
FMT$CVD  LTR   R1,R1
         BNPR  R15
         C     R1,=F'60'
         BNL   FMT$RED
         LR    R0,R1
         XR    R1,R1
         B     FMT$CVDE
FMT$RED  XR    R0,R0
         D     R0,=F'60'
FMT$CVDE CVD   R0,FMT@CONV
         MVC   FIELD(4),=XL4'40202120'
         ED    FIELD(4),FMT@CONV+6
         BR    R14
FM$JCTER QTILT 'INVALID JCT (BAD JCTID)'
FM$JOBER QTILT 'WRONG JCT (BAD JOB NAME)'
LISTTSO  MVC   FQNAME,=CL4'TSU '   NAME OF QUEUE
         B     *+L'*+16            CONTINUE
LISTSTC  MVC   FQNAME,=CL4'SYS '   NAME OF QUEUE
         B     *+L'*+6             CONTINUE
LISTHO   MVC   FQNAME,=CL4'H/O '   NAME OF QUEUE
FMT$PRIO ZIC   R0,JQEPRIO          LOAD JQE PRIORITY
         SRL   R0,4                DIVIDE BY 16
         CVD   R0,FMT@CONV         CONVERT TO DECIMAL
         MVC   FIELD(4),=XL4'40202120'  PREPARE FOR EDIT
         ED    FIELD(4),FMT@CONV+6 EDIT JQE PRIORITY
         MVC   FPRIO(L'FPRIO),FIELD+4-L'FPRIO
FMT$LIST MVC   FMT@CONV(6),ED5
         ED    FMT@CONV(6),QCOUNT
         MVC   FCOUNT,FMT@CONV+6-L'FCOUNT
         MVC   FNAME,JQEJNAME      MOVE IN JOB NAME
         MVC   FJOBNO-1(6),ED5     PREPARE FOR EDIT
         LH    R0,JQEJOBNO         LOAD HASP JOB NUMBER
         CVD   R0,FMT@CONV         CONVERT TO DECIMAL
         ED    FJOBNO-1(6),FMT@CONV+5   EDIT HASP JOB NUMBER
         TM    JQEFLAG1,JQE1HLD2   HELD BECAUSE DUP JOB NAME?
         BNO   *+L'*+4             NO, SKIP
         MVI   FHOLD,C'D'          YES, FLAG IT
         TM    JQEFLAG1,JQE1HLDA   HOLD ALL?
         BNO   *+L'*+4             NO
         MVI   FHOLD,C'A'          INDICATE JOB HELD FOR HOLD ALL
         TM    JQEFLAG1,JQE1HLD1   THIS JOB HELD?
         BNO   *+L'*+4             NO, SKIP
         MVI   FHOLD,C'H'          YES, INDICATE IT
         QCALL DISPLAY,QDMSG,80    DISPLAY THE LINE
FMT$END  QSTOP
         SPACE 1
*---------------------------------------------------------------------*
*        TAKE HEX DUMPS                                               *
*---------------------------------------------------------------------*
         SPACE 1
HEXDM    TM    QDFREQ,QDFSC        POINTERS SET?
         BO    HEXSH               YES
         L     R2,QCWA             NO, BUILD AND SET BXLE POINTERS
         LA    R3,4
         ST    R3,QPTRSV
         AL    R2,=A(WASSZ)
         SLR   R2,R3
         ST    R2,QPTRSV+4
         SL    R2,=A(1020)
         ST    R2,QPTRSV+8
         MVI   0(R2),0
         OI    QDFREQ,QDFSC
HEXSH    MVC   QDHLINE,FMT#JN      REPORT HEADING
         MVC   QDHLINE+10(8),JQEJNAME   MOVE IN JOB NAME
         MVC   QDHLINE+32(6),=XL6'402020202120' PREPARE FOR EDIT
         LH    R0,JQEJOBNO         LOAD HASP JOB NUMBER
         CVD   R0,FMT@CONV         CONVERT TO DECIMAL
         ED    QDHLINE+32(6),FMT@CONV+5 EDIT HASP JOB NUMBER
         NI    QDFREQ,255-QDFRL    SET NORMAL
         LTR   R1,R1               REQUEST FOR JQE OR JOE?
         BZ    HEX                 JQE
         SPACE 1
*---     TAKE HEX DUMP OF JOE                                      ---*
         SPACE 1
         LA    R3,0(R8)            SET START ADDRESS TO DUMP
         LR    R15,R3
         SL    R15,QCJOTWA         SUBSTRACT BASE TO OFFSET
         ST    R15,XQDWD
         MVI   XQDWD,C'O'
         BAS   R14,HEXSCAN
         B     HEXPC
         MVC   QDMSG,QBLANK
         MVI   FHEXSP1,C':'
         UNPK  FMT@CONV(7),XQDWD+1(4)
         TR    FMT@CONV(6),HEXTAB-X'F0'
         MVC   FHEXRP1(L'FHEXRP1),FMT@CONV
         TM    JOETYPE,JOEFREE     FREE-JOE?
         BO    HEXOF               YES
         TM    JOETYPE,JOEWORK     WORK-JOE?
         BZ    HEXTS               NO
         MVC   FHEXNM1,=CL5'@-JOE' YES, SAY WORK-JOE
         MVC   FHEXNM2,=CL8'---> JQE'
         MVI   FHEXSP2,C':'
         TM    QDFREQ,QDFSV        INFO SAVED?
         BZ    *+L'*+10            NO
         MVC   JOEJQEB(3),QPTRSV+13     RESTORE INFO FOR DUMP
         OI    QDFREQ,QDFRS        SET RESET
         UNPK  FMT@CONV(7),JOEJQEB(4)
         TR    FMT@CONV(6),HEXTAB-X'F0'
         MVC   FHEXRP2(L'FHEXRP2),FMT@CONV
         LA    R2,0+((JOE1END-JOE)/4)*4 SET WORK-JOE LENGTH
         OC    JOECHARB,JOECHARB
         BZ    HEXOS
         MVC   FHEXNM3,=CL8'---> CHA'
         MVI   FHEXSP3,C':'
         UNPK  FMT@CONV(7),JOECHARB(4)
         TR    FMT@CONV(6),HEXTAB-X'F0'
         MVC   FHEXRP3(L'FHEXRP3),FMT@CONV
         B     HEXOS
HEXTS    TM    JOETYPE,JOECHARJ    CHARACTERISTICS JOE?
         BZ    HEXOF               NO
         MVC   FHEXNM1,=CL5'@-CHA' YES, SAY CHAR-JOE
         LA    R2,0+((JOE2END-JOE)/4)*4 SET CHAR-JOE LENGTH
         B     HEXOS
HEXOF    MVC   FHEXNM1,=CL5'@FREE' SAY FREE-JOE
         LA    R2,0+(JOESIZE/4)*4  SET JOE LENGTH
HEXOS    QCALL DISPLAY,QDMSG,80    DISPLAY LINE
         MVC   QDMSG,QBLANK
         QCALL HEXDUMP             PRINT JOE IN HEX
         TM    QDFREQ,QDFRS        RESET REQUESTED?
         BZ    HEXPC               NO
         MVC   JOEJQEB,=XL3'00'    RESTORE THIS JOE USED
HEXPC    TM    JOETYPE,JOEFREE     FREE-JOE?
         BO    HEX                 YES
         TM    JOETYPE,JOEWORK     WORK-JOE?
         BZ    HEX                 NO
         L     R8,JOECHAR          OFFSET TO CHARACTERISTICS JOE
         N     R8,=A(X'00FFFFFF')  ANY CHAR-JOE?
         BZ    HEX                 BRANCH IF NO CHAR-JOE
         LR    R15,R8
         AL    R8,QCJOTWA          ADD BASE TO OFFSET
         ST    R15,XQDWD
         MVI   XQDWD,C'O'
         BAS   R14,HEXSCAN
         B     HEX
         MVC   QDMSG,QBLANK
         TM    JOETYPE,JOEFREE     FREE-JOE?
         BO    *+L'*+8             YES
         TM    JOETYPE,JOECHARJ    NO, CHARACTERISTICS JOE?
         BO    *+L'*+10            YES
         MVC   FHEXNM1,=CL5'@-???' NO, WHAT'S THAT
         B     *+L'*+6
         MVC   FHEXNM1,=CL5'@-CHA' SAY CHAR-JOE
         MVI   FHEXSP1,C':'
         UNPK  FMT@CONV(7),XQDWD+1(4)
         TR    FMT@CONV(6),HEXTAB-X'F0'
         MVC   FHEXRP1(L'FHEXRP1),FMT@CONV
         QCALL DISPLAY,QDMSG,80    DISPLAY LINE
         MVC   QDMSG,QBLANK
         LA    R3,0(R8)            SET START ADDRESS TO DUMP
         LA    R2,0+((JOE2END-JOE)/4)*4 SET CHAR-JOE LENGTH
         QCALL HEXDUMP             PRINT CHAR-JOE IN HEX
         SPACE 1
*---     TAKE HEX DUMP OF JQE                                      ---*
         SPACE 1
HEX      NI    QDFREQ,255-QDFSV-QDFRS
         LA    R3,0(R9)            SET START ADDRESS TO DUMP
         LR    R15,R3
         SL    R15,QCJQEWA         SUBSTRACT BASE TO OFFSET
         ST    R15,XQDWD
         MVI   XQDWD,C'Q'
         BAS   R14,HEXSCAN
         B     FMT$END
         MVC   QDMSG,QBLANK
         MVC   FHEXNM1,=CL5'@-JQE'   SAY JQE
         MVI   FHEXSP1,C':'
         UNPK  FMT@CONV(7),XQDWD+1(4)
         TR    FMT@CONV(6),HEXTAB-X'F0'
         MVC   FHEXRP1(L'FHEXRP1),FMT@CONV
         OC    JQEJOEB,JQEJOEB
         BZ    HEXJQ
         MVC   FHEXNM2,=CL8'---> JOE'
         MVI   FHEXSP2,C':'
         UNPK  FMT@CONV(7),JQEJOEB(4)
         TR    FMT@CONV(6),HEXTAB-X'F0'
         MVC   FHEXRP2(L'FHEXRP2),FMT@CONV
HEXJQ    QCALL DISPLAY,QDMSG,80    DISPLAY LINE
         MVC   QDMSG,QBLANK
XLJQE    EQU   (JQEBLEN/4)*4
         LA    R2,XLJQE            SET LENGTH
         QCALL HEXDUMP             PRINT JQE IN HEX
         B     FMT$END             ALL DUMPED
         SPACE 1
*---------------------------------------------------------------------*
*                                                                     *
*        HEXSCAN - REMEMBER JQE/JOE ALREADY DUMPED                    *
*                                                                     *
*        ENTRY : XQDWD +0   = TYPE                                    *
*                XQDWD +1-3 = JQE/JOE RELATIVE ADDRESS                *
*                R4-R5-R6 = WORK REGISTERS                            *
*                R14 +0 = FOUND RETURN ADDRESS                        *
*                    +4 = NOT FOUND RETURN ADDRESS                    *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
HEXSCAN  LM    R4,R6,QPTRSV        GET POINTERS
HEXSCAN0 CLI   0(R6),0             ANY MORE?
         BE    HEXSCAN1            NO
         CLC   0(4,R6),XQDWD       YES, THIS ONE?
         BER   R14                 YES, ALREADY DUMPED
         BXLE  R6,R4,HEXSCAN0      NO, LOOP TO NEXT
         B     4(R14)              NOT FOUND
HEXSCAN1 MVC   0(4,R6),XQDWD       INSERT THIS ONE
         BXLE  R6,R4,*+L'*+4
         B     4(R14)
         MVI   0(R6),0
         B     4(R14)
         SPACE 1
*---------------------------------------------------------------------*
*                                                                     *
*        FMT$RJE - FORMAT REMOTE ID                                   *
*                                                                     *
*        ENTRY : R14 - RETURN ADDRESS                                 *
*                R15 - @ ROUTE FIELD (4 BYTES)                        *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
FMT$RJE  STM   R14,R12,12(R13)
         L     R14,QCMSA           @ MASTER CKPT RECORD
         LH    R14,$NODEID-$SAVEBEG(,R14)    THIS NODE ID
         SLL   R14,16              MAKE LOCAL ID
         CL    R14,0(,R15)         IS THIS LOCAL?
         BE    FMT$RJE9            BRANCH IF LOCAL ROUTING
         LA    R3,FREMOTE          @ OUTPUT FIELD FOR REMOTE ID
         LA    R0,C'R'             ASSUME IS REMOTE
         CLM   R14,B'1100',0(R15)  IS THIS MY NODE?
         BE    FMT$RJE3            BRANCH IF IS RNNN
         LA    R0,C'U'             ASSUME IS U TYPE
         XR    R14,R14
         CLM   R14,B'1100',0(R15)  IS THIS NODE 0?
         BE    FMT$RJE3            BRANCH IF IS UNNN
         SPACE 1
*---     NODE IS N###R### FORMAT                                   ---*
         SPACE 1
         LA    R0,C'N'             1ST ID IS N###
         LH    R1,0(,R15)          GET NODE ID
         BAS   R14,FMT$RJEC        CONVERT NODE ID
         SPACE 1
*--- NOTE : NODE IS N### FORMAT ONLY BECAUSE THERE IS
*---        NO ROOM IN THE NEW DEFINED OUTPUT LINE.
         SPACE 1
         B     FMT$RJE9            ONLY THE NODE ID
*        LA    R0,C'R'             RESET IS R###
FMT$RJE3 LH    R1,2(,R15)
         BAS   R14,FMT$RJEC        CONVERT OTHER ID
FMT$RJE9 LM    R14,R12,12(R13)
         BR    R14
FMT$RJEC CVD   R1,120(,R13)        CONVERT TO DEC
         MVC   128(6,R13),=XL6'402020202120' EDIT MASK
         LA    R1,128+5(,R13)
         LR    R2,R1
         EDMK  128(6,R13),120+5(R13)
         SR    R2,R1               LENGTH -1 OF NUMBER
         STC   R0,0(,R3)           SET TYPE ID
         EX    R2,FMT$RJEM
         LA    R3,1+1(R2,R3)       BUMP OUTPUT PTR
         BR    R14
FMT$RJEM MVC   1(0,R3),0(R1)       * EXECUTED *
         SPACE 1
ED5      DC    X'402020202021'
         AIF   ('&SYSPARM' NE 'CJS').CJS2
FMT#HEAD DC    CL79'QUEUE POS JOBNAME   JOB# PR  LINES EXEC H DEV  FORM1
                    FCB  UCS  RJE  CJS-NET'                       -CJS-
         AGO   .CJS3                                              -CJS-
.CJS2    ANOP
FMT#HEAD DC    CL79'QUEUE POS JOBNAME   JOB# PR  LINES EXEC H DEV  FORM1
                    FCB  UCS  RJE'
.CJS3    ANOP
FMT#JN   DC    CL79'JOBNAME : XXXXXXXX / JOBNUMBER : '
FMT#RLN  DC    C' REQ.L'
FMT#RTI  DC    C'   REQ.CPU     REQ.I    '
         SPACE 1
         LTORG
         SPACE 1
         DROP  R8,R9,R10,R11,R12
         TITLE '--- QUEUE/SP -- HEXDUMP -- DUMP HEX ROUTINE ---'
*---------------------------------------------------------------------*
*                                                                     *
* HEXDUMP : DISPLAY IN HEX A CONTROL BLOCK                            *
*                                                                     *
*        ENTRY : R2 = LENGTH OF BLOCK TO BE DUMPED                    *
*                R3 = ADDRESS OF BLOCK TO BE DUMPED                   *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
HEXDUMP  QSTART
         L     R10,QVDSPL          LOAD BASE REG
         USING QDISPLAY,R10        BASE REG FOR DISPLAY WORK AREA
         TM    QDFREQ,QDFRL        WHICH FORMAT?
         BO    HEXF1D              RELATIVE
         LA    R4,L'FHEXDATA-1     NORMAL
         LA    R5,4*8
HEXF0D   CLR   R2,R5
         BNL   HEXF0D1
         LR    R4,R2
         AR    R4,R2
         SRL   R2,2
         AR    R4,R2
         BCTR  R4,0
HEXF0D1  LR    R1,R3               GET ADDRESS TO DUMP
         UNPK  FMT@HEXW+00(14+1),00(7+1,R1)  BYTES 01-07
         UNPK  FMT@HEXW+14(14+1),07(7+1,R1)  BYTES 08-14
         UNPK  FMT@HEXW+28(14+1),14(7+1,R1)  BYTES 15-21
         UNPK  FMT@HEXW+42(14+1),21(7+1,R1)  BYTES 22-28
         UNPK  FMT@HEXW+56(14+1),28(7+1,R1)  BYTES 29-35
         TR    FMT@HEXW(70),TABLEP      MAKE IT PRINTABLE HEX
         MVC   FMT@LINE,QBLANK     CLEAR OUTPUT LINE
         MVC   FMT@LINE+00(08),FMT@HEXW+00   MOVE FIRST WORD
         MVC   FMT@LINE+09(08),FMT@HEXW+08   MOVE SECOND WORD
         MVC   FMT@LINE+18(08),FMT@HEXW+16   MOVE THIRD WORD
         MVC   FMT@LINE+27(08),FMT@HEXW+24   MOVE FOURTH WORD
         MVC   FMT@LINE+36(08),FMT@HEXW+32   MOVE FIFTH WORD
         MVC   FMT@LINE+45(08),FMT@HEXW+40   MOVE SIXTH WORD
         MVC   FMT@LINE+54(08),FMT@HEXW+48   MOVE SEVENTH WORD
         MVC   FMT@LINE+63(08),FMT@HEXW+56   MOVE EIGHTH WORD
         MVC   FHEXDATA(L'FHEXDATA),QBLANK   CLEAR OUTPUT LINE
         EX    R4,HEXF0DMV         COPY IT
         QCALL DISPLAY,QDMSG,80    DISPLAY THE LINE
         MVC   FHEXID(L'FHEXID),QBLANK
         TM    QDFREQ,QDFEX        WHICH FORMAT?
         BZ    HEXF0D3             NORMAL
         MVC   FMT@LINE,QBLANK     CLEAR OUTPUT LINE
         LA    R0,8
         LR    R14,R3
         LA    R15,FMT@LINE
HEXF0D2  MVC   0(1,R15),0(R14)
         MVC   2(1,R15),1(R14)
         MVC   4(1,R15),2(R14)
         MVC   6(1,R15),3(R14)
         LA    R14,4(R14)
         LA    R15,9(R15)
         BCT   R0,HEXF0D2
         TR    FMT@LINE,TABLECH
         MVC   FHEXDATA(L'FHEXDATA),QBLANK   CLEAR OUTPUT LINE
         EX    R4,HEXF0DMV         COPY IT
         QCALL DISPLAY,QDMSG,80    DISPLAY THE LINE
HEXF0D3  SR    R2,R5
         BNP   HEXDUMPE            ALL DUMPED
         AR    R3,R5               NEXT ADDRESS
         B     HEXF0D
HEXF0DMV MVC   FHEXDATA(*-*),FMT@LINE   <<EXECUTED>>
HEXF1D   L     R4,QCWA             USE THE WORK AREA
         USING IN,R3               BASE REG FOR RAW BLOCK
         USING OUT,R4              BASE REG FOR PRINTABLE LINES
         XR    R5,R5               START OFFSET AT ZERO
         TM    QDFREQ,QDFEX        WHICH FORMAT?
         BO    HEXF2D1             EXTENDED
HEXF1D1  MVC   OLINE1,QBLANK       BLANK THE WORK AREA
         LA    R1,8*8(R5)
         CLR   R1,R2
         BNH   HEXF1D2
         SR    R1,R2
         LA    R15,I8+L'I8
         SR    R15,R1
         BCTR  R1,0
         EX    R1,HEXF1DMV
HEXF1D2  MVC   O11,I1              MOVE RECORD TO PRINT LINE 1
         MVC   O12,I2
         MVC   O13,I3
         MVC   O14,I4
         MVC   O15,I5
         MVC   O16,I6
         MVC   O17,I7
         MVC   O18,I8
         MVC   OLINE2,OLINE1       COPY INTO LINE 2
         STH   R5,QNUMWORK         STORE OFFSET
         UNPK  HBOFFSET(5),QNUMWORK(3)  CONVERT TO HEX
         TR    HBOFFSET,TABLEP     TRANSLATE TO PRINTABLE
         MVI   HBOFFSET+4,C' '     CLEAR GARBAGE BYTE
         TR    ODATA1,TABLEU       TRANSLATE TO UPPER HEX
         TR    ODATA2,TABLEL       TRANSLATE TO LOWER HEX
         QCALL DISPLAY,OLINE1,160  DISPLAY THE LINES 1 AND 2
         LR    R1,R3               SAVE ADDR OF RECORD
HEXF1D3  LA    R3,8*8(R3)          NEXT RECORD
         LA    R5,8*8(R5)          INCREMENT TO NEXT OFFSET
         CLR   R5,R2               IS THIS THE END?
         BNL   HEXDUMPE            YES, GO HOME
         CLC   0(8*8,R1),0(R3)     THIS RECORD THE SAME AS PREV?
         BE    HEXF1D3             YES, SKIP IT
         B     HEXF1D1             PRINT NEXT RECORD
HEXF1DMV MVC   0(*-*,R15),QBLANK   <<EXECUTED>>
HEXF2D1  MVC   OLINE1,QBLANK       BLANK THE WORK AREA
         MVC   OLINE2,QBLANK
         MVC   OLINE3,QBLANK
         STH   R5,QNUMWORK         STORE OFFSET
         UNPK  HBOFFSET(5),QNUMWORK(3)  CONVERT TO HEX
         TR    HBOFFSET,TABLEP     TRANSLATE TO PRINTABLE
         MVI   HBOFFSET+4,C' '     CLEAR GARBAGE BYTE
         LA    R0,8*8
         LA    R1,8*8(R5)
         CLR   R1,R2
         BNH   HEXF2D2
         SR    R1,R2
         LA    R15,I8+L'I8
         SR    R15,R1
         BCTR  R1,0
         EX    R1,HEXF2DMV
         LR    R0,R2
         SR    R0,R5
HEXF2D2  MVC   O31,I1              MOVE RECORD TO PRINT LINE 3
         MVC   O32,I2
         MVC   O33,I3
         MVC   O34,I4
         MVC   O35,I5
         MVC   O36,I6
         MVC   O37,I7
         MVC   O38,I8
         TR    ODATA3,TABLECH      TRANSLATE TO CHARACTERS
         LA    R15,I1
         BAS   R14,HEXF2DR
         MVC   O11(*-*),FMT@HEXW+8 +0   <<EXECUTED>>
         MVC   O21(*-*),FMT@HEXW   +6   <<EXECUTED>>
         LA    R15,I2              +12
         BAS   R14,HEXF2DR
         MVC   O12(*-*),FMT@HEXW+8 +0   <<EXECUTED>>
         MVC   O22(*-*),FMT@HEXW   +6   <<EXECUTED>>
         LA    R15,I3              +12
         BAS   R14,HEXF2DR
         MVC   O13(*-*),FMT@HEXW+8 +0   <<EXECUTED>>
         MVC   O23(*-*),FMT@HEXW   +6   <<EXECUTED>>
         LA    R15,I4              +12
         BAS   R14,HEXF2DR
         MVC   O14(*-*),FMT@HEXW+8 +0   <<EXECUTED>>
         MVC   O24(*-*),FMT@HEXW   +6   <<EXECUTED>>
         LA    R15,I5              +12
         BAS   R14,HEXF2DR
         MVC   O15(*-*),FMT@HEXW+8 +0   <<EXECUTED>>
         MVC   O25(*-*),FMT@HEXW   +6   <<EXECUTED>>
         LA    R15,I6              +12
         BAS   R14,HEXF2DR
         MVC   O16(*-*),FMT@HEXW+8 +0   <<EXECUTED>>
         MVC   O26(*-*),FMT@HEXW   +6   <<EXECUTED>>
         LA    R15,I7              +12
         BAS   R14,HEXF2DR
         MVC   O17(*-*),FMT@HEXW+8 +0   <<EXECUTED>>
         MVC   O27(*-*),FMT@HEXW   +6   <<EXECUTED>>
         LA    R15,I8              +12
         BAS   R14,HEXF2DR
         MVC   O18(*-*),FMT@HEXW+8 +0   <<EXECUTED>>
         MVC   O28(*-*),FMT@HEXW   +6   <<EXECUTED>>
HEXF2D3  QCALL DISPLAY,OLINE1,240  DISPLAY THE LINE
         LR    R1,R3               SAVE ADDR OF RECORD
HEXF2D4  LA    R3,8*8(R3)          NEXT RECORD
         LA    R5,8*8(R5)          INCREMENT TO NEXT OFFSET
         CLR   R5,R2               IS THIS THE END?
         BNL   HEXDUMPE            YES, GO HOME
         CLC   0(8*8,R1),0(R3)     THIS RECORD THE SAME AS PREV?
         BE    HEXF2D4             YES, SKIP IT
         B     HEXF2D1             PRINT NEXT RECORD
HEXF2DMV MVC   0(*-*,R15),QBLANK   <<EXECUTED>>
         DROP  R3,R4
HEXF2DR  LTR   R0,R0
         BNP   HEXF2D3
         MVC   FMT@HEXW(8),0(R15)
         MVO   FMT@HEXW+8(9),FMT@HEXW(8)
         OC    FMT@HEXW(16),UPPERZ
         TR    FMT@HEXW(16),TABLEP
         LA    R15,8
         CLR   R0,R15
         BNL   *+L'*+2
         LR    R15,R0
         SR    R0,R15
         BCTR  R15,0
         EX    R15,0(R14)
         EX    R15,6(R14)
         B     12(R14)
HEXDUMPE QSTOP ,                   RETURN
         SPACE 1
*---     TABLE USED TO CONVERT TO UPPER HALF OF PRINTABLE HEX      ---*
         SPACE 1
TABLEU   DS    0CL256
UPPERZ   EQU   *                   TABLE FOR HEX CONVERT
* - - - - - - -> 0123456789ABCDEF <- *
         DC    C'0000000000000000'   0
         DC    C'1111111111111111'   1
         DC    C'2222222222222222'   2
         DC    C'3333333333333333'   3
         DC    C' 4444444444.<(+|'   4
         DC    C'&&5555555555$*);'  5
         DC    C'-/666666666,%_>?'   6
         DC    C'7777777777:#@''="'  7
         DC    C'8888888888888888'   8
         DC    C'9999999999999999'   9
         DC    C'AAAAAAAAAAAAAAAA'   A
         DC    C'BBBBBBBBBBBBBBBB'   B
         DC    C'CABCDEFGHICCCCCC'   C
         DC    C'DJKLMNOPQRDDDDDD'   D
         DC    C'EESTUVWXYZEEEEEE'   E
         DC    C'0123456789FFFFFF'   F
         SPACE 1
*---     TABLE USED TO CONVERT TO LOWER HALF OF PRINTABLE HEX      ---*
         SPACE 1
TABLEL   DS    0CL256
TABLEP   EQU   *-C'0'              TABLE FOR HEX UNCONVERT
* - - - - - - -> 0123456789ABCDEF <- *
         DC    C'0123456789ABCDEF'   0
         DC    C'0123456789ABCDEF'   1
         DC    C'0123456789ABCDEF'   2
         DC    C'0123456789ABCDEF'   3
         DC    C' 123456789A     '   4
         DC    C' 123456789A     '   5
         DC    C'  23456789A     '   6
         DC    C'0123456789      '   7
         DC    C'0123456789ABCDEF'   8
         DC    C'0123456789ABCDEF'   9
         DC    C'0132456789ABCDEF'   A
         DC    C'0123456789ABCDEF'   B
         DC    C'0         ABCDEF'   C
         DC    C'0         ABCDEF'   D
         DC    C'01        ABCDEF'   E
         DC    C'          ABCDEF'   F
         SPACE 1
*---     TABLE USED TO CONVERT TO PRINTABLE CHARACTERS             ---*
         SPACE 1
TABLECH  DS    0CL256
* - - - - - - -> 0123456789ABCDEF <- *
         DC    C'                '   0
         DC    C'                '   1
         DC    C'                '   2
         DC    C'                '   3
         DC    C'           .<(+|'   4
         DC    C'&&          $*);'  5
         DC    C'-/         ,%_>?'   6
         DC    C'          :#@''="'  7
         DC    C' ABCDEFGHI      '   8  LIST LOWER
         DC    C' JKLMNOPQR      '   9    ALPHA TO
         DC    C'  STUVWXYZ      '   A      UPPER ALPHA
         DC    C'                '   B
         DC    C' ABCDEFGHI      '   C
         DC    C' JKLMNOPQR      '   D
         DC    C'  STUVWXYZ      '   E
         DC    C'0123456789      '   F
         SPACE 1
         LTORG
         SPACE 1
         DROP  R10,R11,R12
         TITLE '--- QUEUE/SP -- HELP -- DISPLAY HELP ---'
*---------------------------------------------------------------------*
*                                                                     *
* HELP : HELP COMMAND ROUTINE (DISPLAY HELP INFORMATION)              *
* PFKS : CHANGE, RESET, SAVE OR LOAD PF-KEYS DEFINITIONS              *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
HELP     QSTART
         L     R9,QVCKPT           ADDR OF DAIR WORK AREAS
         USING QCKPT,R9            BASE REG FOR DAIR WORK AREAS
         L     R10,QVDSPL          ADDR OF DISPLAY WORK AREA
         USING QDISPLAY,R10        BASE REG FOR DISPLAY WORK AREA
         LH    R1,QCODEH           LOAD FUNCTION CODE INTO R1
         CH    R1,MAXHELP          IS THE FUNCTION SUPPORTED?
         BH    HELPBACK            NO, RETURN
         B     GETHELP(R1)         BRANCH TO ROUTINE
GETHELP  DS    0H
         B     HELPREQ                  0 OFFSET
         B     SETPF                    4
         B     RSPFK                    8
         B     LSPF                     12
         B     LSPF                     16
MAXHELP  DC    0H'0',AL2(*-GETHELP-4)
         SPACE 1
*---     SAVE OR LOAD THE PF-KEYS TO/FROM DATA-SET                 ---*
*---     NAME IS : USERID.QPARM1.QPARM2(QPARM3)                    ---*
*---     BY DEFAULT IS : USERID.SPF.PROF(QSPPROF)                  ---*
         SPACE 1
LSPF     CLI   QPARM1,C'0'         IS FIRST CHARACTER VALID?
         BL    LSPF1               YES
         QTILT '*** FIRST PART OF DSNAME INVALID ***'
LSPF1    CLI   QPARM2,C'0'         IS FIRST CHARACTER VALID?
         BL    LSPF2               YES
         QTILT '*** LAST PART OF DSNAME INVALID ***'
LSPF2    CLI   QPARM3,C'0'         IS FIRST CHARACTER VALID?
         BL    LSPF3               YES
         QTILT '*** MEMBER NAME INVALID ***'
LSPF3    MVC   DSNAME+2(44),QBLANK NO, BLANK THE DSNAME
         LA    R1,DSNAME           ADDRESS OF DSNAME
         CLI   QPARM1,C' '         DEFAULT TO BE USED?
         BE    *+L'*+8             YES
         CLI   QPARM1,C'-'         DEFAULT TO BE USED?
         BNE   LSPF10              NO
         MVC   DSNAME+2(3),=CL3'SPF'    YES, SET IT
         LH    R2,=H'3'            LENGTH OF FIRST PART
         B     LSPF11
LSPF10   MVC   DSNAME+2(8),QPARM1  FIRST PART OF DSNAME
         LH    R2,QLNG1            LENGTH OF QPARM1
LSPF11   LA    R1,2(R2,R1)         OFFSET INTO DSNAME
         MVI   0(R1),C'.'          SET SEPARATOR
         CLI   QPARM2,C' '         DEFAULT TO BE USED?
         BE    *+L'*+8             YES
         CLI   QPARM2,C'-'         DEFAULT TO BE USED?
         BNE   LSPF12              NO
         MVC   1(4,R1),=CL4'PROF'  YES, SET IT
         LA    R1,5(,R2)           LENGTH OF DSNAME
         B     LSPF13
LSPF12   MVC   1(8,R1),QPARM2      LAST PART OF DSNAME
         LA    R1,1(,R2)
         AH    R1,QLNG2            LENGTH OF DSNAME
LSPF13   STH   R1,DSNAME           STORE LENGTH OF DSNAME
         CLI   QPARM3,C' '         DEFAULT TO BE USED?
         BE    *+L'*+8             YES
         CLI   QPARM3,C'-'         DEFAULT TO BE USED?
         BNE   *+L'*+10            NO
         MVC   QCPFMEM,=CL8'QSPPROF'    YES, SET IT
         B     *+L'*+6
         MVC   QCPFMEM,QPARM3      MEMBER NAME
         MVC   DAALUNIT(DAAL$L),ALLOCPFK     SET ALLOCATE PARM LIST
         LA    R1,DSNAME           ADDRESS OF DSNAME
         ST    R1,DAALPDSN         STORE IN PARM LIST
         MVI   QCPFKSW,0           INITIAL RESET
         MVI   DAIRFLAG,DFALLOC    REQUEST ALLOCATE FUNCTION
         QCALL ALLOCATE            ALLOCATE IT
         OI    QCPFKSW,PFDAAL      SAY ALLOCATED
         TM    DAALDSO,DCBDSGPO    DSORG=PO?
         BO    LSPF20              YES, OK
         MVC   QDMSG(35),=CL35'*** DATA-SET IS NOT PARTITIONED ***'
         LA    R2,35
         B     LSPF46
LSPF20   MVC   QCPFKOP(1),HOCKPT   SET INPUT
         L     R1,=A(QCPFKPO)
         MVC   QCPFKPO(QCPFKPOL),0(R1)  INITIALIZE DCB
         MVC   QCPFKPO+(DCBDDNAM-IHADCB)(L'DAALDDN),DAALDDN
*                                  GET THE DDNAME RETURNED BY DAIR
         LA    R1,QCPFKPO
         ICM   R1,B'1000',QCPFKOP
         ST    R1,QCPFKOP          SET PTR TO DCB IN OPEN LIST
         ICM   R1,B'1000',QCPFKCL
         ST    R1,QCPFKCL          SET PTR TO DCB IN CLOSE LIST
         OPEN  MF=(E,QCPFKOP)      OPEN DATA-SET
         TM    QCPFKPO+(DCBOFLGS-IHADCB),DCBOFOPN OPEN OK?
         BZ    LSPF41              NO
         TM    QCPFKSW,PFRFERR     RECFM ERROR?
         BO    LSPF43              YES
         TM    QCPFKSW,PFLRERR     LRECL ERROR?
         BO    LSPF44              YES
         OI    QCPFKSW,PFDAOP      SAY OPENED
         L     R2,QCWA             USE WORK SPACE
         MVC   0(4,R2),=AL2(1,58)  AS BLDL PARM LIST
         MVC   4(8,R2),QCPFMEM
         XC    12(50,R2),12(R2)
         BLDL  QCPFKPO,(R2)
         LTR   R15,R15             COMPLETION CODE?
         BZ    LSPF22              OK
         CH    R15,=H'4'           IS IT MEMBER NOT FOUND?
         BE    LSPF21              YES
         MVC   QDMSG(37),=CL37'*** DATA-SET SEARCH ERROR :   /   ***'
         STC   R15,QDMSG+29
         SRL   R15,4
         STC   R15,QDMSG+28
         NC    QDMSG+28(2),=XL2'0F0F'
         TR    QDMSG+28(2),HEXTAB
         STC   R0,QDMSG+32
         SRL   R0,4
         STC   R0,QDMSG+31
         NC    QDMSG+31(2),=XL2'0F0F'
         TR    QDMSG+31(2),HEXTAB
         LA    R2,37
         B     LSPF45
LSPF21   CLI   QCODE,12            SAVE REQUESTED?
         BE    LSPF30              YES
         MVC   QDMSG(35),=CL35'*** MEMBER NOT FOUND :          ***'
         MVC   QDMSG+23(8),QCPFMEM
         LA    R2,35
         B     LSPF45
LSPF22   CLI   QCODE,12            SAVE REQUESTED?
         BNE   LSPF30              NO
         OI    QCPFKSW,PFDAIN      YES, DO IT IN PLACE
LSPF30   CLOSE MF=(E,QCPFKCL)      CLOSE DATA-SET
         MVI   DAIRFLAG,DFFREE     REQUEST FREE FUNCTION
         MVC   DAFRDDN,QCPFKPO+(DCBDDNAM-IHADCB)  GET THE DDNAME
         QCALL ALLOCATE            FREE IT BY DDNAME
         MVC   DAALUNIT(DAAL$L),ALLOCPFK     SET ALLOCATE PARM LIST
         MVC   DAALMNM,QCPFMEM     MEMBER NAME
         CLI   QCODE,12            SAVE REQUESTED?
         BNE   LSPF40              NO
         MVI   DAALDSP1,DA08OLD    YES, CHANGE TO OLD
         TM    QCPFKSW,PFDAIN      IN PLACE?
         BO    UPPF1               YES
         MVC   QCPFKOP(1),QCOPEN   NO, SET OUTPUT
         B     LSPF40+L'LSPF40
UPPF1    L     R1,=A(QCPFKOP)      SET UPDAT
         IC    R0,0(R1)
         STC   R0,QCPFKOP
         B     LSPF40+L'LSPF40
LSPF40   MVC   QCPFKOP(1),HOCKPT   SET INPUT
         NI    QCPFKSW,PFDAIN      RESET ALL UNLESS ...
         MVI   DAIRFLAG,DFALLOC    REQUEST ALLOCATE FUNCTION
         QCALL ALLOCATE            ALLOCATE IT
         OI    QCPFKSW,PFDAAL      SAY ALLOCATED
         L     R1,=A(QCPFKPS)
         MVC   QCPFKPS(QCPFKPSL),0(R1)  INITIALIZE DCB & DECB
         MVC   QCPFKPS+(DCBDDNAM-IHADCB)(L'DAALDDN),DAALDDN
*                                  GET THE DDNAME RETURNED BY DAIR
         LA    R1,QCPFKPS
         ST    R1,QCPDECB+8        SET PTR TO DCB IN DECB
         ICM   R1,B'1000',QCPFKOP
         ST    R1,QCPFKOP          SET PTR TO DCB IN OPEN LIST
         ICM   R1,B'1000',QCPFKCL
         ST    R1,QCPFKCL          SET PTR TO DCB IN CLOSE LIST
         OPEN  MF=(E,QCPFKOP)      OPEN DATA-SET
         TM    QCPFKPS+(DCBOFLGS-IHADCB),DCBOFOPN OPEN OK?
         BO    LSPF50              YES
LSPF41   TM    QCPFKSW,PFDAABN     ABEND HAS OCCURED?
         BO    LSPF42              YES
         MVC   QDMSG(27),=CL27'*** DATA-SET OPEN ERROR ***'
         LA    R2,27
         B     LSPF46
LSPF42   ICM   R2,B'1111',=CL4'OPEN'
         BAS   R14,LSPFSCC
         B     LSPF46
LSPF43   MVC   QDMSG(35),=CL35'*** DATA-SET : DCBRECFM INVALID ***'
         LA    R2,35
         B     LSPF45
LSPF44   MVC   QDMSG(34),=CL34'*** DATA-SET : DCBLRECL NOT 80 ***'
         LA    R2,34
LSPF45   CLOSE MF=(E,QCPFKCL)      CLOSE DATA-SET
LSPF46   MVI   QCPFKSW,0           RESET ALL
         MVC   DAFRDDN,DAALDDN     COPY DDNAME RETURNED BY DAIR
         MVI   DAIRFLAG,DFFREE     REQUEST FREE FUNCTION
         QCALL ALLOCATE            FREE IT BY DDNAME
         LR    R0,R2               ERROR MESSAGE LENGTH
         B     LSPFTILT
LSPF50   TM    QCPFKSW,PFRFERR     RECFM ERROR?
         BO    LSPF43              YES
         TM    QCPFKSW,PFLRERR     LRECL ERROR?
         BO    LSPF44              YES
         OI    QCPFKSW,PFDAOP      SAY OPENED
         LH    R0,QCPFKPS+(DCBBLKSI-IHADCB)
         LTR   R0,R0
         BP    *+L'*+4
         LH    R0,QCPFKPS+(DCBLRECL-IHADCB)
         L     R4,=A(PFKSVL)
         XR    R3,R3
         XR    R1,R1
LSPF51   CR    R4,R3
         BNH   LSPF52
         AR    R3,R0
         LA    R1,1(,R1)
         B     LSPF51
LSPF52   AR    R3,R0               ONE MORE FOR SECURITY
         CL    R3,=A(WASSZ)        WORK SPACE LARGE ENOUGH?
         BNH   LSPF53              YES
         MVC   QDMSG(35),=CL35'*** WORK SIZE (WASSZ) TOO SMALL ***'
         LA    R2,35
         B     LSPF45
LSPF53   L     R2,QCWA             USE WORK SPACE AS I/O AREA
         LR    R4,R2
         XR    R5,R5
         MVCL  R2,R4               ZEROES NEEDED AREA
         L     R2,QCWA
         TM    QCPFKSW,PFDAIN      IN PLACE?
         BO    UPPF2               YES
         CLI   QCODE,16            NO, LOAD REQUESTED?
         BNE   SVPF1               NO
         LA    R6,1(R1)            YES, CONTROL NUMBER OF RECORDS
UPPF2    LR    R4,R0
LDPF1    READ  QCPDECB,SF,,(R2),'S',MF=E     READ RECORDS
         CHECK QCPDECB
         TM    QCPFKSW,PFDAERR+PFDAABN  ERROR OR ABEND HAS OCCURED?
         BNZ   LSPFEND             YES
         TM    QCPFKSW,PFDAIN      IN PLACE?
         BO    UPPF3               YES
         AR    R2,R4               NO, BUMP POINTER
         BCT   R6,LDPF1            LOOP CONTROL
         B     LSPFEND             TRUNCATE HERE, WE ARE STILL ONE MORE
UPPF3    LR    R0,R4
         LR    R6,R2
         L     R2,QCWA
SVPF1    L     R3,=A(PFKTABL)
         LA    R4,PFKTAB
         LR    R5,R3
         MVCL  R2,R4               COPY PFK-TABLE TO AREA
         TM    QCPFKSW,PFDAIN      IN PLACE?
         BZ    SVPF2               NO
         LR    R2,R6               YES
         B     UPPF4
SVPF2    L     R2,QCWA
         LR    R3,R1
UPPF4    LR    R4,R0
SVPF3    WRITE QCPDECB,SF,,(R2),'S',MF=E     WRITE RECORDS
         CHECK QCPDECB
         TM    QCPFKSW,PFDAERR+PFDAABN  ERROR OR ABEND HAS OCCURED?
         BNZ   LSPFEND             YES
         AR    R2,R4               NO, BUMP POINTER
         TM    QCPFKSW,PFDAIN      IN PLACE?
         BO    LDPF1               YES
         BCT   R3,SVPF3
         B     LSPFEND
         CNOP  0,4
*        DCB EXIT ROUTINE          R2 -> R13 = AS OPEN ISSUED
         USING IHADCB,R1
LSPFEXT  TM    DCBRECFM,DCBRECF    TEST FIXED RECORDS
         BZ    *+L'*+8
         TM    DCBRECFM,DCBRECV
         BZ    *+L'*+6
         OI    QCPFKSW,PFRFERR     SAY RECFM ERROR
         BR    R14                 RETURN
         CLC   DCBLRECL,LSPFLR     TEST RECORD LENGTH
         BER   R14                 RETURN
         OI    QCPFKSW,PFLRERR     SAY LRECL ERROR
         BR    R14                 RETURN
         DROP  R1
LSPFLR   DC    H'80'               REQUESTED LRECL
LSPFXLS  DC    0F'0',XL1'05',AL3(LSPFEXT)
*        DC    XL1'91',AL3(LSPFABX)
         CNOP  0,4
*        SYNAD EXIT ROUTINE        R2 -> R13 = AS GET/PUT ISSUED
LSPFERR  STM   R13,R1,QCPFSV
         SYNADAF ACSMETH=BSAM
         MVC   QDMSG(78),50(R1)    GET MESSAGE TEXT
         SYNADRLS
         OI    QCPFKSW,PFDAERR     SAY ERROR OCCURED
         LM    R13,R1,QCPFSV
         BR    R14                 RETURN
         CNOP  0,4
*        DCB ABEND ROUTINE         R2 -> R13 = AS OPEN ... ISSUED
LSPFABX  TM    3(R1),B'00000100'   OPTION MASK = OK TO IGNORE?
         BO    *+L'*+6             YES
         NI    3(R1),B'11110001'   NO, IMMEDIATE ABEND
         BR    R14
         MVC   QCSCCRC(3),0(R1)    SAVE ABEND CODES
         OI    QCPFKSW,PFDAABN     SAY ABEND
         NI    3(R1),B'11110101'   OK TO IGNORE ONLY
         BR    R14                 RETURN
LSPFSCC  MVC   QDMSG(36),=CL36'*** DATA-SET      ABEND :    /   ***'
         STCM  R2,B'1111',QDMSG+13
         UNPK  QDMSG+26(3),QCSCCRC(2)
         TR    QDMSG+26(3),HEXTAB-X'F0'
         UNPK  QDMSG+30(3),QCSCCRC+2(2)
         TR    QDMSG+30(2),HEXTAB-X'F0'
         MVI   QDMSG+32,C' '
         LA    R2,36
         BR    R14
         CNOP  0,4
*        EODAD EXIT
LSPFEND  NI    QCPFKSW,255-PFDAOP  SAY CLOSED
         CLOSE MF=(E,QCPFKCL)      CLOSE DATA-SET
         NI    QCPFKSW,255-PFDAAL  SAY DE-ALLOCATED
         MVI   DAIRFLAG,DFFREE     REQUEST FREE FUNCTION
         MVC   DAFRDDN,QCPFKPS+(DCBDDNAM-IHADCB)  GET THE DDNAME
         QCALL ALLOCATE            FREE IT BY DDNAME
         TM    QCPFKSW,PFDAERR+PFDAABN  ERROR OR ABEND HAS OCCURED?
         BZ    LSPFOK              NO
         TM    QCPFKSW,PFDAABN     ABEND HAS OCCURED?
         BZ    LSPFERM             NO
         NI    QCPFKSW,255-PFDAABN RESET ABEND INDICATOR
         CLI   QCODE,12            SAVE WAS REQUESTED?
         BE    *+L'*+8             YES
         ICM   R2,B'1111',=CL4'LOAD'
         B     *+L'*+4
         ICM   R2,B'1111',=CL4'SAVE'
         BAS   R14,LSPFSCC
         LR    R0,R2               ERROR MESSAGE LENGTH
         B     LSPFTILT
LSPFERM  NI    QCPFKSW,255-PFDAERR RESET ERROR INDICATOR
         LA    R0,78               ERROR MESSAGE LENGTH
LSPFTILT LA    R1,QDMSG            ERROR MESSAGE
         QTILT ,                   BACK WITH ERROR MESSAGE
LSPFOK   CLI   QCODE,12            SAVE WAS REQUESTED?
         BE    SETPFDP             YES, GO DISPLAY PF-KEYS
         L     R14,QCWA            POINT TO KEYS DEFINITIONS
         B     RSPFK+L'RSPFK       GO STORE PF-KEYS
         SPACE 1
*---     RESET ALL PF-KEYS TO ORIGINAL VALUES                      ---*
         SPACE 1
RSPFK    L     R14,=A(PFKTAB)      POINT TO ORIGINAL DEFINITIONS
         LA    R15,PFKTAB          POINT TO TABLE ENTRY
         LH    R0,=Y(PFKNO)        NUMBER OF PFK'S
RSPFKL   CLC   0(1,R15),0(R14)     KEY MATCHES?
         BNE   *+L'*+6             NO
         MVC   1(L'PFKTAB-1,R15),1(R14) SET DEFINITION
         LA    R14,L'PFKTAB(R14)   POINT TO NEXT
         LA    R15,L'PFKTAB(R15)
         BCT   R0,RSPFKL           FILL ALL PFK'S
         B     SETPFDP             GO DISPLAY PF-KEYS
         SPACE 1
*---     SET A PF-KEY TO VALUE                                     ---*
         SPACE 1
SETPF    LH    R1,QLNG1            YES, LENGTH OF PFK-ID
         SH    R1,=H'1'            NOT SPECIFIED?
         BM    SETPFDP             NO, GO JUST DISPLAY PF-KEYS
         CLI   QPARM1,C'0'         YES, IS FIRST CHARACTER NUMERIC?
         BL    SETTILT             NO, TILT IF NOT NUMERIC
         LA    R15,QPARM1          POINT TO PFK NUMBER
         BAS   R14,QNUMCONV        CONVERT IT
         BNE   SETTILT             TILT IF NOT NUMERIC
         CH    R15,=Y(PFKNO)       VALID PFK NUMBER?
         BNH   SETPFOK             YES
SETTILT  QTILT '*** PFK NUMBER IS INVALID ***'
SETTILTX QTILT '*** PFK COMMAND TEXT MISSING ***'
SETPFOK  OC    QOFF2,QOFF2         COMMAND TEXT SUPPLIED?
         BZ    SETTILTX            NONE
         BCTR  R15,0               RELATIVE PFK NUMBER
         MH    R15,=Y(L'PFKTAB)    DISPLACEMENT IN PF-TABLE
         LA    R15,PFKTAB(R15)     POINT TO TABLE ENTRY
         LA    R14,QDREPLY         POINT TO REPLY AREA
         AH    R14,QOFF2           ADD OFFSET PAST PFK NUMBER
         MVC   1(L'PFKTAB-1,R15),0(R14) SET NEW DEFINITION
SETPFDP  MVC   QPARM1(3),=CL3'PFK' SPECIFY PF-KEYS DISPLAY
         SPACE 1
*---     DISPLAY HELP INFORMATION                                  ---*
         SPACE 1
HELPREQ  CLI   QPARM1,C' '         DID USER SPECIFY PANEL?
         BE    HELPALL             NO, ALL
         CLC   QPARM1(3),=CL3'PFK' DID USER SPECIFY PF-KEYS?
         BNE   *+L'*+4             NO
         MVI   QPARM1+1,C' '       YES, SET PF-KEYS PANEL
         LA    R5,QPARM1
         BAS   R6,HELPDSPP
         B     HELPEXIT
HELPALL  BAS   R5,HELPDSPL
         DC    CL2'Q '             QUEUE/SPOOL
         BAS   R5,HELPDSPL
         DC    CL2'QN'             QUEUE/SPOOL NOTES
         BAS   R5,HELPDSPL
         DC    CL2'J '             JOBS DATA-SETS
         BAS   R5,HELPDSPL
         DC    CL2'JN'             JOBS DATA-SETS NOTES
         BAS   R5,HELPDSPL
         DC    CL2'E '             EXTENDED SERVICES
         CLI   QXAUTH,LV12         IS THE USER AUTHORIZED?
         BL    HELPPFK             NO, SKIP
         BAS   R5,HELPDSPL
         DC    CL2'O '             OPERATOR SERVICES
         CLI   QXAUTH,LV15         IS THE USER PRIVILEGED?
         BL    HELPPFK             NO, SKIP
         BAS   R5,HELPDSPL
         DC    CL2'D '             PRIVILEGED
HELPPFK  BAS   R5,HELPDSPL
         DC    CL2'PN'             SET PF-KEYS SERVICES
         BAS   R5,HELPLAST
         DC    CL2'P '             PF-KEYS DISPLAY
HELPEXIT OI    QDOVER,QESKIP       REQ TO SKIP END OF DATA
HELPBACK QSTOP
         SPACE 1
HELPDSPL OI    QDOVER,QPFORCE      FORCE PAGE DISPLAY
HELPLAST LA    R6,2(R5)            SET RETURN
HELPDSPP L     R4,=V(QSPHELP)      HELP PANELS DATA
HELPSRCH CLC   0(2,R4),=XL2'0'     END OF VECTOR?
         BE    HELPERR             YES, UNEXISTANT
         CLC   0(2,R4),0(R5)       THIS PANEL?
         BE    HELPDFND            YES
         LA    R4,6(R4)            NO, BUMP TO NEXT IN VECTOR
         B     HELPSRCH            CONTINUE SEARCH
HELPDFND ICM   R1,B'1111',2(R4)    GET PANEL DATA ADDRESS
         MVC   QDHLINE,0(R1)       MOVE HEADING
         CLC   0(2,R4),=CL2'P '    PF-KEYS DISPLAY PANEL?
         BE    HELPIPFK            YES
         LH    R0,80(R1)           NO, GET LENGTH
         LA    R1,82(,R1)          SET PANEL ADDRESS
HELPSND  QCALL DISPLAY,(R1),(R0)   DISPLAY HELP PANEL
         BR    R6                  RETURN
HELPIPFK L     R2,QCWA             BUILD PF-KEYS PANEL
         LH    R3,80(R1)
         LA    R14,82(,R1)
         LR    R15,R3
         MVCL  R2,R14
         LH    R0,=Y(PFKNO)
         LA    R2,8(,R4)
         LA    R15,PFKTAB
HELPSPFK LH    R14,0(R2)
         AL    R14,QCWA
         MVC   0(L'PFKTAB-1,R14),1(R15)
         LA    R2,2(,R2)
         LA    R15,L'PFKTAB(R15)
         BCT   R0,HELPSPFK
         LH    R0,80(R1)           GET LENGTH
         L     R1,QCWA             SET PANEL ADDRESS
         B     HELPSND             GO DISPLAY PF-KEYS PANEL
HELPERR  NI    QDOVER,255-QPFORCE
         MVC   QDMSG(L'HELPMSG),HELPMSG
         MVC   QDMSG+L'HELPMSG-7(2),0(R5)
         LA    R1,QDMSG
         LA    R0,L'HELPMSG
         QTILT
HELPMSG  DC    C'=== UNEXISTANT HELP PANEL (  ) ==='
         SPACE 1
         DS    0F
ALLOCPFK DC    2CL8' '             UNIT & VOLSER
         DC    4F'0'               BLKSIZE / PRI / SEC / DIR
         DC    2CL8' '             MEMBER & PASSWORD
         DC    AL1(DA08SHR)        STAT=SHR
         DC    AL1(DA08KEEP)       DISP=KEEP
         DC    AL1(DA08KEP)        DISP=KEEP
         DC    AL1(DA08UID)        PREFIX_USERID TO DSNAME
         DC    F'0',CL8' '
         SPACE 1
         LTORG
         SPACE 1
         DROP  R9,R10,R11,R12
 TITLE '--- QUEUE/SP -- DDNAME -- LIST DDNMS && DSIDS FOR A JOB ---'
DDNAME   QSTART
         USING QCKPT,R10           BASE FOR CHECKPOINT WORK AREA
         L     R10,QVCKPT          LOAD BASE REG
         USING QDISPLAY,R9         BASE REG FOR DISPLAY WORK AREA
         L     R9,QVDSPL           LOAD BASE REG
         SPACE 1
*---     CALL FINDJOB TO LOCATE THE JQE, JCT, AND IOT              ---*
         SPACE 1
         QCALL FINDJOB             FIND THE JOB
         SPACE 1
*---     BUILD TABLE OF DSID'S AND RECORDS COUNTS                  ---*
         SPACE 1
         L     R6,QCSTART          -> TABLE AREA
         MVI   DDN@SW,0            HAVEN'T READ SPIN IOT YET
         L     R5,QCIOTA           -> IOT
         USING IOTSTART,R5
         MVC   PGMNAME(80),QBLANK  BLANK THE DISPLAY LINE
DD$IOTLP CLC   IOTID,=CL4'IOT'     WAS AN IOT READ FROM SPOOL?
         BNE   DD$TILTB            NO, ERROR
         CLC   QPJOBID,IOTJBKEY    IS THE IOT'S JOB KEY VALID?
         BNE   DD$TILTB            NO, ERROR
         LR    R4,R5               BASE OF IOT
         SL    R4,=A(IOTSTART-IOT) ADJUST FOR HEADER
         LR    R2,R4               COPY IT
         A     R4,IOTPDDBP         OFFSET BEYOND LAST PDDB
         A     R2,IOTPDDB          OFFSET TO FIRST PDDB IN IOT
         USING PDB,R2
DD$PDBLP LH    R1,PDBDSKEY         GET DSID
         LTR   R1,R1               IS IT 0?
         BZ    NXT$DSID            YES - IGNORE IT
         TM    PDBFLAG1,PDB1NSOT   NOT FOR SYSOUT?
         BZ    DD$SYOUT            NO - IT'S FOR SYSOUT
         CH    R1,=H'2'            IT IS 2 THRU 4?
         BL    DD$SYOUT            NO - OK
         CH    R1,=H'4'            IT IS 2 THRU 4?
         BNH   NXT$DSID            YES - IGNORE IT BECAUSE IT IS
*                                  MARKED 'NOT FOR SYSOUT' AND IS
*                                  THE JOBLOG, JOBMSG, OR JCL DS,
*                                  WHICH ARE DUPLICATED ON THE
*                                  SPIN IOT WITHOUT THE 'NOT FOR
*                                  SYSOUT' FLAG SET
DD$SYOUT MVI   0(R6),SW@FOUND      INDICATE FOUND
         CVD   R1,DDN@DWD          CONVERT TO PACKED
         OI    DDN@DWD+7,X'0F'     REMOVE SIGN
         UNPK  1(4,R6),DDN@DWD     MAKE IT PRINTABLE
         MVC   DSID,QBLANK         CLEAR DISPLAY FIELD
         CLC   =H'100',PDBDSKEY    A PROBLEM PROGRAM DATA-SET?
         BL    DD$PDBSV            YES - GO SAVE IT
         CLI   QXAUTH,LV10         AUTHORIZED USER?
         BL    *+L'*+6 >======+    NO - DON'T DISPLAY DSID
         MVC   DSID,1(R6)     I    YES - MOVE DSID TO PRINT LINE
         MH    R1,=H'6'  <====+    ENTRIES ARE 6 BYTES EACH
         LA    R1,DSIDTYPE-6(R1)   -> TYPE
         CLI   QXAUTH,LV10         AUTHORIZED USER?
         BNL   DD$AUTH1            YES - SHOW HIM EVERYTHING
         CLI   PDBDSKEY+1,1        INPUT JCL?
         BE    NXT$DSID            YES - DON'T SHOW IT
         CLI   PDBDSKEY+1,4        JOBLOG/JCL/JOBMSG?
         BH    NXT$DSID            NO - DON'T SHOW IT
DD$AUTH1 MVC   DSTYPE,0(R1)        MOVE IN SYSTEM DSTYPE
         TM    PDBFLAG1,PDB1HOLD   HELD DATA-SET?
         BNO   *+L'*+6 >======+    NO - SKIP
         MVC   HELD,=C'H-'    I    YES - INDICATE
         L     R0,PDBRECCT  <=+    GET RECORD COUNT
         CVD   R0,DDN@DWD          CONVERT TO PACKED
         MVC   RECORDS,=XL8'4020202020202120'     MOVE IN EDIT MASK
         ED    RECORDS,DDN@DWD+4
         BAS   R8,DDN$DISP         ADD THIS LINE TO SCREEN
         B     NXT$DSID            DON'T SAVE THIS ONE
DD$PDBSV MVC   0(1,R6),DDN@SW      SAVE SPIN INDICATOR
         TM    PDBFLAG1,PDB1HOLD   HELD DATA-SET?
         BNO   *+L'*+4             NO - SKIP
         OI    0(R6),SW@HELD       YES - REMEMBER THIS TIDBIT
         MVC   5(4,R6),PDBRECCT    SAVE RECORD COUNT
         LA    R6,9(,R6)           -> NEXT SLOT
         LA    R0,9(,R6)           -> THE ONE AFTER THE NEXT
         C     R0,QCEND            DOES THE NEXT ONE FIT?
         BL    NXT$DSID            YES - OK
         QTILT '*** TOO MANY DSIDS ***'
DD$TILTB QTILT '*** JOB HAS PURGED (OR IOT IS INVALID) ***'
NXT$DSID LA    R2,PDBLENG(,R2)     -> NEXT PDDB
         CR    R2,R4               PAST LAST PDDB?
         BL    DD$PDBLP            NO - DO NEXT
         L     R4,IOTIOTTR         DISK ADDR OF NEXT IOT
DD$RDIOT LTR   R4,R4               ANY MORE?
         BZ    DD$SPIOT            NO - TRY SPIN IOT
         BAS   R8,DDN$READ         READ THE IOT
         B     DD$IOTLP            PROCESS IT
DD$SPIOT L     R1,QCJCTA           -> JCT
         TM    DDN@SW,SW@SPIN      SPIN IOT SEARCHED ALREADY?
         BO    DD$OKIOT            YES - DONE READING IOT'S
         L     R4,JCTSPIOT-JCTSTART(,R1)     DISK ADDR OF SPIN IOT
         OI    DDN@SW,SW@SPIN      INDICATE SPIN IOT'S
         B     DD$RDIOT            GO READ THE SPIN IOT
DD$OKIOT MVI   0(R6),SW@END        SET END FLAG
         L     R4,JCTIOT-JCTSTART(,R1)  DISK ADDR OF IOT
         BAS   R8,DDN$READ         READ IOT
         DROP  R2,R5
         SPACE 1
*---     LOCATE PDDB NUMBER 5                                      ---*
         SPACE 1
         USING PDB,R2              BASE REG FOR PDDB
         L     R3,QCIOTA           LOAD BASE REG
         USING IOTSTART,R3         BASE REG FOR IOT
         CLC   IOTID,=CL4'IOT'     WAS AN IOT READ FROM SPOOL?
         BNE   DD$NONE             NO
         CLC   QPJOBID,IOTJBKEY    IS THE IOT'S JOB KEY VALID?
         BNE   DD$NONE             NO
         LR    R4,R3               BASE OF IOT
         SL    R4,=A(IOTSTART-IOT) ADJUST FOR HEADER
         LR    R2,R4               COPY IT
         A     R4,IOTPDDBP         OFFSET BEYOND LAST PDDB
         A     R2,IOTPDDB          OFFSET TO  FIRST PDDB IN IOT
         MVC   QPDSID,=H'0'        NULLIFY VALIDITY FOR LISTDS
FINDDS1  CLC   =H'5',PDBDSKEY      IS THIS THE DATA-SET?
         BE    FOUNDDS1            YES, CONTINUE
         LA    R2,PDBLENG(,R2)     NO, LOOK AT NEXT PDDB
         CR    R2,R4               PAST THE LAST PDDB?
         BL    FINDDS1             NO, TRY AGAIN
DD$NONE  QTILT '*** JOB DOES NOT HAVE DD TABLE ***'
FOUNDDS1 L     R4,PDBMTTR          DISK ADDR OF FIRST BLOCK
         L     R5,QCBLKA           ADDR OF DATA-SET BLOCK IOAREA
         MVC   QDMSG,QBLANK        BLANK OUT THE MESSAGE AREA
         B     DDNFIRST            PROCESS DATA-SET
         SPACE 1
*---     PROCESS DATA-SET                                          ---*
         SPACE 1
         USING BUFSTART,R5
DDNXTBLK L     R4,HDBNXTRK         DISK ADDR OF NEXT BLOCK
DDNFIRST LTR   R4,R4               IS THE DISK ADDR ZERO?
         BZ    DDN$END             YES, END OF DATA-SET
         BAS   R8,DDN$READ         READ A BLOCK
         CLC   QPJOBID,HDBJBKEY    DOES THE JOBID MATCH?
         BNE   DDN$END             NO, END OF DATA-SET
         CLC   HDBPDDBK,=H'5'      IS THE DSID 5?
         BNE   DDN$END             NO, END OF DATA-SET
         LA    R4,HDBSTART         ADDR OF FIRST RECORD IN BLOCK
         SPACE 1
*---     PROCESS RECORDS (SKIP SPANNED)                            ---*
         SPACE 1
         USING LRC,R4
NEXTREC1 CLI   LRCTLENG,ENDIND     IS LENGTH BYTE FF?
         BE    DDNXTBLK            YES, END OF BLOCK
         TM    LRCFLAG1,LRC1SPAN   IS THIS A SPANNED RECORD?
         BO    DDN$SPAN            YES, SKIP IT
         ZIC   R6,LRCTLENG         INSERT LENGTH
         TM    LRCTEXT+2,2         IS THIS AN EXEC RECORD?
         BO    EXEC                YES, PROCESS IT
         TM    LRCTEXT+2,4         IS THIS A DD RECORD?
         BO    DD                  YES, PROCESS IT
SKIPREC  LA    R4,LRCTEXT(R6)      INCREMENT TO NEXT RECORD
         B     NEXTREC1            PROCESS NEXT RECORD
DDN$SPAN LH    R6,LRCSEGL          LENGTH OF SEGMENT
         TM    LRCFLAG1,LRC1SBGN   IS THIS THE FIRST SEGMENT?
         BO    SPAN1ST1            YES, USE HEADER LENGTH OF 6
         LA    R4,LRCSTEXT(R6)     INCREMENT TO NEXT RECORD
         B     NEXTREC1            PROCESS NEXT RECORD
SPAN1ST1 LA    R4,LRCSFTXT(R6)     INCREMENT TO NEXT RECORD
         B     NEXTREC1            PROCESS NEXT RECORD
         SPACE 1
*---     PROCESS AN EXEC RECORD                                    ---*
         SPACE 1
EXEC     CLI   LRCTEXT+4,EXECK     IS THERE A STEPNAME?
         BNE   SKIPREC             NO, SKIP THIS RECORD
         ZIC   R1,LRCTEXT+6        LENGTH OF PROCSTEP/STEPNAME
         TM    LRCTEXT+3,X'20'     EXEC PROC=XXXX?
         BO    EXECPROC            YES, HANDLE IT
         SPACE 1
*---     ASSUME (FOR LACK OF KNOWLEDGE TO                          ---*
*---     THE CONTRARY) THAT IT'S PGM=                              ---*
         SPACE 1
         LA    R15,PROCSTEP        ASSUME IN PROC
         TM    LRCTEXT+3,X'08'     IN A PROC?
         BO    EXECINPR            YES, OK
         LA    R15,STEPNAME        POINT TO WHERE STEPNAME GOES
         MVC   PROCSTEP,=C'  N/A   '    INDICATE NO PROCSTEP NAME
         MVC   PROCNAME,=C' (NONE) '    THERE IS NO PROCEDURE IN EFFECT
EXECINPR MVC   0(8,R15),=C' (NONE) '    CLEAR IT
         MVC   PGMNAME,=C' (NONE) '     AND THIS TOO
         SH    R1,=H'1'            -1 FOR EX
         BM    *+L'*+10    >=======+    SKIP IF NO STEPNAME
         MVC   0(8,R15),QBLANK     I    CLEAR THE FIELD FIRST
         EX    R1,MVCSTEP          I    MOVE THE STEPNAME
         LA    R15,LRCTEXT+8(R1) <=+    POINT TO PGMNAME KEY
         CLI   0(R15),PGMEK        IS THIS THE PROGRAM NAME?
         BNE   SKIPREC             NO, DONE WITH THIS RECORD
         CLI   2(R15),X'83'        IS THIS PGM=*.STEP.DDNAME?
         BE    EXECSTAR            YES, HANDLE IT
         ZIC   R1,2(,R15)          GET PGMNAME LENGTH
         SH    R1,=H'1'            -1 FOR EX
         BM    SKIPREC             SKIP IF NONE
         MVC   PGMNAME,QBLANK      CLEAR THE FIELD
         EX    R1,MVCPGM           MOVE PGM NAME
         B     SKIPREC             CONTINUE PROCESSING
EXECSTAR MVC   PGMNAME,=C'*.DDNAME'     THE REAL WHOLE THING WON'T FIT
         B     SKIPREC             IGNORE THE REST OF THE RECORD
EXECPROC MVC   PROCSTEP,=C' (NONE) '    INIT FIELD
         MVC   STEPNAME,=C' (NONE) '    THIS ONE TOO
         MVC   PROCNAME,=C' (NONE) '    AND YET ANOTHER ONE
         MVC   PGMNAME,=C' (NONE) '     AND THIS TOO
         SH    R1,=H'1'            -1 FOR EX
         BM    *+L'*+10    >=======+    SKIP IF NONE
         MVC   STEPNAME,QBLANK     I    BLANK THE FIELD
         EX    R1,MVCPSTEP         I    MOVE STEPNAME
         LA    R15,LRCTEXT+8(R1) <=+    POINT TO PROCNAME OR NEXT UNIT
         CLI   LRCTEXT+5,2         ARE THERE 2 POSITIONAL UNITS?
         BE    EXECPR03            YES, GO PROCESS IT
         CLI   0(R15),PROCEK       EXPLICIT EXEC PROC= ?
         BNE   SKIPREC             NO, GET OUT
         LA    R15,2(,R15)         POINT TO PROCNAME LENGTH
EXECPR03 ZIC   R1,0(,R15)          GET PROCNAME LENGTH
         SH    R1,=H'1'            -1 FOR EX
         BM    SKIPREC             IGNORE IF NONE
         MVC   PROCNAME,QBLANK     BLANK THE FIELD
         EX    R1,MVCPROC          MOVE PROCNAME
         B     SKIPREC             DONE WITH THIS RECORD
         SPACE 1
*---     PROCESS DD RECORDS                                        ---*
         SPACE 1
DD       TM    LRCTEXT+3,X'30'     IS THIS A SYSIN OR SYSOUT DD?
         BZ    SKIPREC             NO, SKIP THE RECORD
         MVC   DDN,QBLANK          BLANK OUT THE DDNAME
         MVC   DSID,QBLANK         BLANK OUT THE DSID
         LA    R7,LRCTEXT+4        ADDR OF FIRST KEY
         LR    R8,R6               REMAINING LENGTH OF RECORD
         XR    R15,R15             CLEAR FOR IC
         XR    R14,R14             CLEAR FOR IC
         XR    R1,R1               CLEAR FOR IC
TRYFLD   CLI   0(R7),DDK           IS THIS THE DDNAME?
         BE    DDKEY               YES, PROCESS IT
         CLI   0(R7),DSNAMEK       IS THIS THE DSNAME?
         BE    DSKEY               YES, PROCESS IT
NEXTFLD  IC    R1,1(,R7)           NUMBER OF SUBFIELDS
         LA    R7,2(,R7)           UPDATE LOCATION
         SH    R8,=H'2'            REMAINING COUNT
         SR    R8,R1               REMAINING COUNT
         BNP   SKIPREC             RECORD IS EXHAUSTED
         LTR   R1,R1               ARE THERE ANY SUBFIELDS?
         BZ    TRYFLD              NO, TRY NEXT FIELD
LOOPFLD  TM    0(R7),X'80'         IS THIS A SUB-SUB-FIELD
         BZ    NOSUB               NO, CONTINUE
         NI    0(R7),X'7F'         CLEAR THE HEX 80 BIT
         IC    R14,0(,R7)          NUMBER OF SUB-SUB-FIELDS
         LA    R7,1(,R7)           UPDATE LOCATION
         SH    R8,=H'1'            REMAINING COUNT
         SR    R8,R14              REMAINING COUNT
         BNP   SKIPREC             RECORD IS EXHAUSTED
         AR    R1,R14              INCREASE NUMBER OF SUBFIELDS
         B     YESSUB              DECREMENT AND TRY AGAIN
NOSUB    IC    R15,0(,R7)          SUBFIELD LENGTH
         LA    R7,1(R15,R7)        ADD TO LOCATION
         SR    R8,R15              REMAINING COUNT
         BNP   SKIPREC             RECORD IS EXHAUSTED
YESSUB   BCT   R1,LOOPFLD          DO NEXT SUBFIELD
         B     TRYFLD              TRY NEXT FIELD
DDKEY    IC    R1,2(,R7)           LENGTH OF DDNAME
         LTR   R1,R1               IS THE LENGTH ZERO?
         BZ    NEXTFLD             YES, SKIP THE FIELD
         BCTR  R1,0                DECREMENT BY 1
         EX    R1,MVCDDN           MOVE THE DDNAME
         B     NEXTFLD             PROCESS NEXT FIELD
DSKEY    MVC   DSID,19(R7)         MOVE THE DSID
         MVC   DSTYPE,=C'*ERROR'   INIT FIELD
         TM    LRCTEXT+3,X'20'     SYSOUT?
         BNO   *+L'*+6             NO, SKIP
         MVC   DSTYPE,=C'SYSOUT'
         TM    LRCTEXT+3,X'10'     SYSIN?
         BNO   *+L'*+6             NO, SKIP
         MVC   DSTYPE,=C'SYSIN '
         TM    LRCTEXT+3,X'30'     BOTH?
         BNO   *+L'*+6             NO, SKIP
         MVC   DSTYPE,=C'ERROR*'
         DROP  R4,R5
         L     R1,QCSTART          -> DSID TABLE
         MVC   RECORDS,QBLANK      ASSUME WE WON'T FIND ANYTHING
         MVC   HELD,QBLANK         ...
DSID$LP  TM    0(R1),SW@END        HIT END OF TABLE?
         BO    NO$COUNT            YES, IT'S NOT HERE
         CLC   DSID,1(R1)          THIS IT?
         BE    DSID$GOT            YES
         LA    R1,9(,R1)           -> NEXT ENTRY
         B     DSID$LP
DSID$GOT L     R0,5(,R1)           GET RECORD COUNT
         CVD   R0,DDN@DWD          CONVERT TO PACKED
         TM    0(R1),SW@HELD       HELD DATA-SET?
         BNO   *+L'*+6             NO, SKIP
         MVC   HELD,=C'H-'         YES, INDICATE
         OI    0(R1),SW@FOUND      INDICATE THIS ONE'S BEEN USED
         MVC   RECORDS,=XL8'4020202020202120'     MOVE IN EDIT MASK
         ED    RECORDS,DDN@DWD+4
NO$COUNT BAS   R8,DDN$DISP         CALL DISPLAY FOR THIS LINE
         MVC   PROCSTEP,QBLANK     RESET
         MVC   STEPNAME,QBLANK           THESE
         MVC   PROCNAME,QBLANK                 FIELDS
         MVC   PGMNAME,QBLANK                         ...
         B     SKIPREC             PROCESS NEXT RECORD
         SPACE 1
*---     DISPLAY SPIN-IOT DSID'S AND NON-SPIN DSID'S THAT WEREN'T  ---*
*---     CLAIMED BY PREVIOUS CODE                                  ---*
         SPACE 1
DDN$END  MVC   PGMNAME(80),QBLANK  DON'T KNOW PGM NAMES ANYMORE
         L     R6,QCSTART          -> DSID TABLE
DD$SPLP  TM    0(R6),SW@END        END OF TABLE?
         BO    DDN$STOP            YES, FINALLY DONE
         TM    0(R6),SW@FOUND      ALREADY DISPLAYED?
         BO    DD$NXTDS            YES, SKIP IT NOW
         MVC   DSID,1(R6)          MOVE IN DSID
         MVC   DSTYPE,=C'*LOST*'   UNCLAIMED DATA-SET
         TM    0(R6),SW@SPIN       SPIN?
         BNO   *+L'*+6             NO, SKIP
         MVC   DSTYPE,=C'<SPIN>'   YES, SAY SO
         L     R0,5(,R6)           GET RECORD COUNT
         CVD   R0,DDN@DWD          CONVERT TO PACKED
         MVC   RECORDS,=XL8'4020202020202120'     MOVE IN EDIT MASK
         ED    RECORDS,DDN@DWD+4   PUT IN RECORD COUNT
         BAS   R8,DDN$DISP         MOVE LINE TO SCREEN
DD$NXTDS LA    R6,9(,R6)           -> NEXT DSID ENTRY
         B     DD$SPLP             FORMAT IT
         SPACE 1
*---     LEAVE THIS ROUTINE                                        ---*
         SPACE 1
DDN$STOP QSTOP
         SPACE 1
*---     READ A BLOCK FROM HASPACE                                 ---*
         SPACE 1
DDN$READ ST    R4,QCTRAK           STORE DISK ADDR
         LR    R1,R5               IOAREA ADDRESS
         QCALL READSPC             READ HASPACE
         BR    R8                  RETURN TO CALLER
         SPACE 1
*---     CALL DISPLAY TO ADD A LINE TO SCREEN                      ---*
         SPACE 1
DDN$DISP MVC   QDHLINE,DDN#HEAD    MOVE IN HEADING
         QCALL DISPLAY,QDMSG,80
         BR    R8                  RETURN TO MAINLINE
         SPACE 1
MVCPSTEP MVC   STEPNAME(*-*),10(R4)     << EXECUTED >>
MVCPROC  MVC   PROCNAME(*-*),1(R15)     << EXECUTED >>
MVCSTEP  MVC   0(*-*,R15),10(R4)        << EXECUTED >>
MVCPGM   MVC   PGMNAME(*-*),3(R15)      << EXECUTED >>
MVCDDN   MVC   DDN(*-*),3(R7)           << EXECUTED >>
DSIDTYPE DC    C'JCLIN JOBLOGJCL   JOBMSGJCLTXTSWA   '
DDN#HEAD DC    CL79'PROGRAM   PROCEDURE     STEPNAME  PROCSTEP   DDNAME1
                    DSID    DSTYPE  RECORDS'
         SPACE 1
         LTORG
         SPACE 1
         DROP  R2,R3,R9,R10,R11,R12
         TITLE '--- QUEUE/SP -- LPDDB -- LIST PDDB''S FOR A JOB ---'
LPDDB    QSTART
         CLI   QXAUTH,LV15         AUTHORIZED USER?
         BL    LP$TILTI            NO
         USING QCKPT,R10           BASE FOR CHECKPOINT WORK AREA
         L     R10,QVCKPT          LOAD BASE REG
         USING QDISPLAY,R9         BASE FOR DISPLAY WORK AREA
         L     R9,QVDSPL           LOAD BASE REG
         SPACE 1
*---     CALL FINDJOB TO LOCATE THE JQE, JCT, AND IOT              ---*
         SPACE 1
         QCALL FINDJOB             FIND THE JOB
         SPACE 1
*---     CHECK AND CONVERT THE PDDB ID NUMBER IF ANY               ---*
         SPACE 1
         LH    R1,QLNG2            LENGTH OF PDDB ID FIELD
         SH    R1,=H'1'            PDDB ID FIELD ZERO LENGTH?
         BM    LPSRCH              YES, PROCEED NORMALLY
         LA    R15,QPARM2          POINT TO PARM
         BAS   R14,QNUMCONV        CONVERT IT
         BNE   LP$TILTN            QUIT IF NOT NUMERIC
         LR    R6,R15              GET PDDB NUMBER
         SPACE 1
*---     FIND ALL OR SPECIFIED PDDB(S) FOR THIS JOB                ---*
         SPACE 1
LPSRCH   MVI   DDN@SW,0            HAVEN'T READ SPIN IOT YET
         L     R5,QCIOTA           -> IOT
         USING IOTSTART,R5
LPNXIOT  CLC   IOTID,=CL4'IOT'     WAS AN IOT READ FROM SPOOL?
         BNE   LP$TILTB            NO, ERROR
         CLC   QPJOBID,IOTJBKEY    IS THE IOT'S JOB KEY VALID?
         BNE   LP$TILTB            NO, ERROR
         LR    R4,R5               BASE OF IOT
         SL    R4,=A(IOTSTART-IOT) ADJUST FOR HEADER
         LR    R3,R4               COPY IT
         A     R4,IOTPDDBP         OFFSET BEYOND LAST PDDB
         A     R3,IOTPDDB          OFFSET TO FIRST PDDB IN IOT
         USING PDB,R3
LPLOOP   LH    R0,PDBDSKEY         GET DSID
         TM    PDBFLAG3,PDB3PLHD   IS IT A PLACE HOLDER PDDB?
         BO    LPNXPDB             YES, IGNORE IT
         CLI   QPARM2,C' '         WANT A SPECIFIED PDDB?
         BE    LPPALL              NO, ALL
         CR    R0,R6               FOUND RIGHT PDDB?
         BNE   LPNXPDB             NO, TRY NEXT ONE
         LA    R2,PDBLENG          LENGTH OF PDDB
         NI    QDFREQ,255-QDFRL    SET NORMAL
         MVC   FHEXID-1(L'FHEXID+2),=C' PDB : '   SAY WHAT IT IS
         MVC   QDHLINE,QBLANK      BLANK THE TITLE LINE
         QCALL HEXDUMP             PRINT PDDB IN HEX
         B     LPNXPDB             JUST IN CASE MULTIPLE PDDBS (SYSLOG)
         SPACE 1
LPPALL   MVC   QDMSG,QBLANK        BLANK OUT WORK LINE AREA
         CVD   R0,DDN@DWD          CONVERT TO DECIMAL
         MVC   LPDSID,=XL8'4020202020202120'
         ED    LPDSID,DDN@DWD+4    EDIT THE DSID
         MVC   LPFLAG1+1(2),=CL2'X'''
         UNPK  LPFLAG1+3(3),PDBFLAG1(2) HEX OF FLAG-1 BYTE
         TR    LPFLAG1+3(2),HEXTAB-X'F0'     MAKE PRINTABLE
         MVI   LPFLAG1+5,C''''
         L     R0,PDBRECCT         GET RECORDS COUNT
         CVD   R0,DDN@DWD          CONVERT TO DECIMAL
         MVC   LPRECCT,=XL8'4020202020202120'
         ED    LPRECCT,DDN@DWD+4   EDIT RECORDS COUNT
         MVC   LPCLASS,PDBCLASS    MOVE PDBCLASS
         UNPK  LPMTTR(L'LPMTTR+1),PDBMTTR(5) START MTTR
         TR    LPMTTR,HEXTAB-X'F0'      MAKE PRINTABLE
         MVI   LPMTTR+L'LPMTTR,C' '     CLEAR JUNK BYTE
         UNPK  LPMTTRL(L'LPMTTRL+1),PDBMTTRL(5)   LAST MTTR
         TR    LPMTTRL,HEXTAB-X'F0'     MAKE PRINTABLE
         MVI   LPMTTRL+L'LPMTTRL,C' '   CLEAR JUNK BYTE
         MVC   LPNPROC,PDBPNAME    SET PDDB PROC NAME
         MVC   LPNSTEP,PDBSNAME    SET PDDB STEP NAME
         MVC   LPNDDNM,PDBDDNAM    SET PDDB DD NAME
         MVC   QDHLINE,LPHEAD      SET HEADING LINE
         QCALL DISPLAY,QDMSG,80    ADD LINE TO SCREEN
LPNXPDB  LA    R3,PDBLENG(R3)      -> NEXT PDDB
         CR    R3,R4               PAST LAST PDDB?
         BL    LPLOOP              NO, DO NEXT
         L     R4,IOTIOTTR         DISK ADDR OF NEXT IOT
LPSPIN   LTR   R4,R4               IS THERE ANOTHER IOT?
         BZ    LPTRYS              NO, TRY SPIN IOT
         ST    R4,QCTRAK           STORE DISK ADDR
         LR    R1,R5               IOAREA ADDRESS
         QCALL READSPC             READ IOT FROM HASPACE
         B     LPNXIOT             PROCESS IT
LPTRYS   TM    DDN@SW,SW@SPIN      SPIN IOT SEARCHED ALREADY?
         BO    LPSTOP              YES, DONE
         OI    DDN@SW,SW@SPIN      INDICATE SPIN IOT
         L     R1,QCJCTA           -> JCT
         L     R4,JCTSPIOT-JCTSTART(,R1)     DISK ADDR OF SPIN IOT
         B     LPSPIN              SEARCH THE SPIN IOT CHAIN
LPSTOP   QSTOP ,                   GO BACK TO CALLER
         SPACE 1
LP$TILTI QTILT '=== NOT AVAILABLE TO YOU, SORRY ==='
LP$TILTN QTILT 'INVALID PDDB ID NUMBER SPECIFIED'
LP$TILTB QTILT '*** JOB HAS PURGED (OR IOT IS INVALID) ***'
         SPACE 1
LPHEAD   DC    CL79'   DS-ID FLAG-1   #-RECS CL  START<-MTTR->LAST  PRO1
               CNAME STEPNAME DD-NAME'
         SPACE 1
         LTORG
         SPACE 1
         DROP  R3,R5,R9,R10,R11,R12
         TITLE '--- QUEUE/SP -- JCL -- LIST THE JCL FOR A JOB ---'
JCL      QSTART
         SPACE 1
*---     CALL FINDJOB TO LOCATE THE JQE, JCT, AND IOT              ---*
         SPACE 1
         QCALL FINDJOB             FIND THE JOB
         SPACE 1
*---     ENSURE JOB NAME BEGINS WITH USER ID                       ---*
         SPACE 1
         L     R9,QCJCTA           ADDR OF JCT
         USING JCTSTART,R9         BASE REG FOR JCT
         IC    R2,QLOGONL          GET LENGTH OF USERID
         BCTR  R2,0                -1 FOR EX
         CLI   QXAUTH,LV10         IS THIS AN AUTHORIZED USER?
         BNL   *+L'*+8             YES, THE JOB NAME IS VALID
         EX    R2,JCL$CLC          IS THE JOB NAME VALID?
         BNE   J$TILT              NO, TILT
         SPACE 1
*---     CALL LISTDS TO LIST THE DATA-SET                          ---*
         SPACE 1
         MVC   QPOFFSET,=H'10'     PRINT OFFSET FOR EACH RECORD
         MVC   QPDSID,=H'3'        DSID OF DATA-SET TO BE PRINTED
         QCALL LISTDS
         QSTOP
J$TILT   QTILT '*** JOB NAME MUST BEGIN WITH USERID ***'
         SPACE 1
JCL$CLC  CLC   QLOGON(*-*),JCTJNAME     << EXECUTED >>
         SPACE 1
         LTORG
         SPACE 1
         DROP  R9,R11,R12
 TITLE '--- QUEUE/SP -- JLOG -- LIST THE JOBLOG MSGS FOR A JOB ---'
JLOG     QSTART
         USING QCKPT,R10           BASE REG FOR CKPT WORK AREA
         L     R10,QVCKPT          LOAD BASE REG
         SPACE 1
*---     CALL FINDJOB TO LOCATE THE JQE, JCT, AND IOT              ---*
         SPACE 1
         QCALL FINDJOB             FIND THE JOB
         SPACE 1
*---     ENSURE JOB NAME BEGINS WITH USER ID                       ---*
         SPACE 1
         L     R9,QCJCTA           ADDR OF JCT
         USING JCTSTART,R9         BASE REG FOR JCT
         IC    R2,QLOGONL          GET LENGTH OF USERID
         BCTR  R2,0                -1 FOR EX
         CLI   QXAUTH,LV10         IS THIS AN AUTHORIZED USER?
         BNL   *+L'*+8             YES, THE JOB NAME IS VALID
         EX    R2,JLOG$CLC         IS THE JOB NAME VALID?
         BNE   G$TILT              NO, TILT
         SPACE 1
*---     ONLY PROCESS JOB IF IT IS ON THE OUTPUT QUEUE             ---*
         SPACE 1
         L     R2,QCJQECA          ADDR OF JQE FOR THIS JOB
         USING JQE,R2              BASE REG FOR JQE
         CLI   JQETYPE,$HARDCPY    IS THE JOB ON THE OUTPUT QUEUE?
         BNE   JL$TILT             NO, INFORM THE USER
         SPACE 1
*---     CALL LISTDS TO LIST THE DATA-SET                          ---*
         SPACE 1
         MVC   QPOFFSET,=H'0'      PRINT OFFSET FOR EACH RECORD
         MVC   QPDSID,=H'2'        DSID OF DATA-SET TO BE PRINTED
         QCALL LISTDS
         QSTOP
G$TILT   QTILT '*** JOB NAME MUST BEGIN WITH USERID ***'
JL$TILT  QTILT '*** JOBLOG IS NOT AVAILABLE ***'
         SPACE 1
JLOG$CLC CLC   QLOGON(*-*),JCTJNAME     << EXECUTED >>
         SPACE 1
         LTORG
         SPACE 1
         DROP  R2,R9,R10,R11,R12
 TITLE '--- QUEUE/SP -- JMSG -- LIST THE SYSTEM MSGS FOR A JOB ---'
JMSG     QSTART
         SPACE 1
*---     CALL FINDJOB TO LOCATE THE JQE, JCT, AND IOT              ---*
         SPACE 1
         QCALL FINDJOB             FIND THE JOB
         SPACE 1
*---     ENSURE JOB NAME BEGINS WITH USER ID                       ---*
         SPACE 1
         L     R9,QCJCTA           ADDR OF JCT
         USING JCTSTART,R9         BASE REG FOR JCT
         IC    R2,QLOGONL          GET LENGTH OF USERID
         BCTR  R2,0                -1 FOR EX
         CLI   QXAUTH,LV10         IS THIS AN AUTHORIZED USER?
         BNL   *+L'*+8             YES, THE JOB NAME IS VALID
         EX    R2,JMSG$CLC         IS THE JOB NAME VALID?
         BNE   M$TILT              NO, TILT
         SPACE 1
*---     CALL LISTDS TO LIST THE DATA-SET                          ---*
         SPACE 1
         MVC   QPOFFSET,=H'0'      PRINT OFFSET FOR EACH RECORD
         MVC   QPDSID,=H'4'        DSID OF DATA-SET TO BE PRINTED
         QCALL LISTDS
         QSTOP
M$TILT   QTILT '*** JOB NAME MUST BEGIN WITH USERID ***'
         SPACE 1
JMSG$CLC CLC   QLOGON(*-*),JCTJNAME     << EXECUTED >>
         SPACE 1
         LTORG
         SPACE 1
         DROP  R9,R11,R12
 TITLE '--- QUEUE/SP -- LIST -- LIST A DS FROM SPOOL BY ID ---'
LIST     QSTART
         USING QCKPT,R10           BASE REG FOR CKPT WORK AREA
         L     R10,QVCKPT          LOAD BASE REG
         SPACE 1
*---     CALL FINDJOB TO LOCATE THE JQE, JCT, AND IOT              ---*
         SPACE 1
         QCALL FINDJOB             FIND THE JOB
         SPACE 1
*---     ENSURE JOB NAME BEGINS WITH USER ID                       ---*
         SPACE 1
         L     R9,QCJCTA           ADDR OF JCT
         USING JCTSTART,R9         BASE REG FOR JCT
         IC    R2,QLOGONL          GET LENGTH OF USERID
         BCTR  R2,0                -1 FOR EX
         CLI   QXAUTH,LV10         IS THIS AN AUTHORIZED USER?
         BNL   *+L'*+8             YES, THE JOB NAME IS VALID
         EX    R2,LIST$CLC         IS THE JOB NAME VALID?
         BNE   L$TILT1             NO, TILT
         SPACE 1
*---     CHECK AND CONVERT THE DATA-SET ID NUMBER                  ---*
         SPACE 1
         LH    R1,QLNG2            LENGTH OF DATA-SET ID FIELD
         SH    R1,=H'1'            DATA-SET ID FIELD ZERO LENGTH?
         BM    L$TILT              YES, QUIT
         LA    R15,QPARM2          POINT TO PARM
         BAS   R14,QNUMCONV        CONVERT IT
         BNE   L$TILT              QUIT IF NOT NUMERIC
         CLI   QSUBNAME,C'X'       'XL' COMMAND?
         BE    *+L'*+8             YES, SKIP NEXT VALIDITY CHECK
         CH    R15,=H'101'         DATA-SET ID LESS THAN 101?
         BL    L$TILT              YES, TILT
         STH   R15,QPDSID          STORE DATA-SET ID
         SPACE 1
*---     CHECK AND CONVERT THE PRINT OFFSET                        ---*
         SPACE 1
         MVC   QPOFFSET,=H'0'      DEFAULT TO ZERO
         LH    R2,QLNG3            LENGTH OF OFFSET FIELD
         SH    R2,=H'1'            OFFSET FIELD ZERO LENGTH?
         BM    L$CALIST            YES, USE ZERO OFFSET
         LA    R15,QPARM3          POINT TO PARM
         BAS   R14,QNUMCONV        CONVERT IT
         BNE   L$TILT              QUIT IF NOT NUMERIC
         STH   R15,QPOFFSET        STORE OFFSET
         SPACE 1
*---     CALL LISTDS TO LIST THE DATA-SET                          ---*
         SPACE 1
L$CALIST QCALL LISTDS
         QSTOP
L$TILT   QTILT '*** DATA-SET ID INVALID ***'
L$TILT1  QTILT '*** JOB NAME MUST BEGIN WITH USERID ***'
         SPACE 1
LIST$CLC CLC   QLOGON(*-*),JCTJNAME     << EXECUTED >>
         SPACE 1
         LTORG
         SPACE 1
         DROP  R9,R10,R11,R12
 TITLE '--- QUEUE/SP -- LISTDS -- LIST A DS FROM THE SPOOL PACK ---'
LISTDS   QSTART
         USING QCKPT,R10           BASE REG FOR CHECKPT WORK AREA
         L     R10,QVCKPT          LOAD BASE REG
         USING QDISPLAY,R9         BASE REG FOR DISPLAY WORK AREA
         L     R9,QVDSPL           LOAD BASE REG
         SPACE 1
*---     DETERMINE FUNCTION REQUESTED                              ---*
         SPACE 1
         CLI   QCODE,0             IS REQUEST FOR REPOSITIONING?
         BNE   LD$REPOS            YES, DO IT
         SPACE 1
*---     LOCATE PDDB FOR DATA-SET SPECIFIED IN QPDSID              ---*
         SPACE 1
         MVI   SWITCH,0            INITIALIZE SWITCH
         USING PDB,R2              BASE REG FOR PDDB
         L     R3,QCIOTA           LOAD BASE REG
         USING IOTSTART,R3         BASE REG FOR IOT
         LR    R5,R3               IOAREA FOR READ IOT BLOCK
NEXTIOT  CLC   IOTID,=CL4'IOT'     WAS AN IOT READ FROM SPOOL?
         BNE   LD$TILTB            NO, ERROR
         CLC   QPJOBID,IOTJBKEY    IS THE IOT'S JOB KEY VALID?
         BNE   LD$TILTB            NO, ERROR
         LR    R4,R3               BASE OF IOT
         SL    R4,=A(IOTSTART-IOT) ADJUST FOR HEADER
         LR    R2,R4               COPY IT
         A     R4,IOTPDDBP         OFFSET BEYOND LAST PDDB
         A     R2,IOTPDDB          OFFSET TO FIRST PDDB IN IOT
LD$DS$LP CLC   QPDSID,PDBDSKEY     IS THIS THE DATA-SET?
         BE    FOUNDDS2            YES, CONTINUE
LD$NXT   LA    R2,PDBLENG(R2)      NO, LOOK AT NEXT PDDB
         CR    R2,R4               HAVE WE PAST THE LAST PDDB?
         BL    LD$DS$LP            NO, TRY AGAIN
         L     R4,IOTIOTTR         DISK ADDR OF NEXT IOT
SPIN     LTR   R4,R4               IS THERE ANOTHER IOT?
         BZ    SPINIOT             NO, TRY THE SPIN IOT
         BAS   R8,LDS$READ         READ THE IOT
         B     NEXTIOT             SEARCH THE NEXT IOT
         USING JCTSTART,R1         BASE REG FOR JCT
SPINIOT  TM    SWITCH,SPINDONE     SPIN IOT SEARCHED YET?
         BO    LDS$TILT            YES, TILT
         OI    SWITCH,SPINDONE     SET SWITCH
         L     R1,QCJCTA           LOAD BASE REG
         L     R4,JCTSPIOT         DISK ADDR OF SPIN IOT
         DROP  R1
         B     SPIN                SEARCH THE SPIN IOT CHAIN
LDS$TILT MVC   QPDSID,=H'0'        INVALIDATE DSID
         TM    SWITCH,DSFOUND      IS DATA-SET FOUND?
         BO    LSTDSTOP            YES, DATA-SET WAS EMPTY
         QTILT '*** DATA-SET ID NOT FOUND ***'
LD$TILT2 QTILT '*** DATA-SET TABLE LIMITS EXCEEDED ***'
LD$TILTB QTILT '*** JOB HAS PURGED (OR IOT IS INVALID) ***'
FOUNDDS2 STM   R2,R5,QPTRSV        SAVE PTRS (EVENTUAL FURTHER USE)
         OI    SWITCH,DSFOUND      SET DATA-SET FOUND
         MVC   QCJNAME,QPARM1      SAVE THE JOB NAME
         MVC   QCDSNO,QPARM2       SAVE THE DATA-SET ID NUMBER
         MVC   QDHLINE,QCHLINE     MOVE IN HEADING LINE
         MVC   QCRECFM,PDBRECFM    RECORD FORMAT FOR SAVE
         MVC   QCLRECL,PDBLRECL    RECORD LENGTH FOR SAVE
         L     R4,PDBMTTR          DISK ADDR OF FIRST BLOCK
         L     R5,QCBLKA           ADDR OF DATA-SET BLOCK IOAREA
         L     R2,QCSTART          BEGINNING OF DISK ADDR TABLE
         ZAP   QCCREC,=P'0'        ZERO CURRENT RECORD NO
         MVC   QCCPTR,QCSTART      BEGIN OF TBL
         ZAP   QCHREC,=P'0'        ZERO HIGH REC NO
         MVC   QCHPTR,QCSTART      BEGIN OF TBL
         ZAP   QPREC,=P'1'         REPOSITION TO TOP OF DATA-SET
         LTR   R4,R4               IS THE DISK ADDR ZERO?
         BNZ   LDPRCSS             NO, PROCESS THE DATA-SET
         TM    SWITCH,SPINDONE     SPIN IOT SEARCHED YET?
         BO    LDS$END             YES, END OF DATA-SET SEARCH
         LM    R2,R5,QPTRSV        RESTORE SEARCH PTRS
         B     LD$NXT              SEARCH NEXT PDDB/IOT
         DROP  R2,R3
         SPACE 1
*---     PROCESS DATA-SET                                          ---*
         SPACE 1
         USING BUFSTART,R5
LDSNXTBL L     R4,HDBNXTRK         DISK ADDR OF NEXT BLOCK
LDSFIRST LTR   R4,R4               IS THE DISK ADDR ZERO?
         BZ    LDS$END             YES, END OF DATA-SET
LDPRCSS  ST    R4,0(R2)            STORE DISK ADDR IN TABLE
         BAS   R8,LDS$READ         READ A BLOCK
         CLC   HDBKEY,QPJOBID      DOES THE JOBID MATCH?
         BNE   LDS$END             NO, END OF DATA-SET
         MVC   4(4,R2),QCCREC      STORE CURRENT REC NUM IN TABLE
         ST    R2,QCCPTR           STORE CURRENT TABLE ADDR
         CP    QCCREC,QCHREC       IS CURRENT REC NO > HIGHEST?
         BNH   *+L'*+6             NO, SKIP
         MVC   QCHREC(8),QCCREC    REPLACE HI REC CNT AND PTR
         LA    R2,8(,R2)           INCREMENT TO NEXT TBL ENTRY
         C     R2,QCEND            IS THIS THE END OF TABLE?
         BNL   LD$TILT2            YES, TILT
         LA    R4,HDBSTART         ADDR OF FIRST RECORD IN BLOCK
         SPACE 1
*---     PROCESS RECORDS                                           ---*
         SPACE 1
         USING LRC,R4
NEXTREC2 CLI   LRCTLENG,ENDIND     IS LENGTH BYTE FF?
         BE    LDSNXTBL            YES, END OF BLOCK
         TM    LRCFLAG1,LRC1SPAN   IS THIS A SPANNED RECORD?
         BO    LDS$SPAN            YES, SKIP IT
         ZIC   R6,LRCTLENG         INSERT LENGTH
         LR    R7,R6               SAVE RECORD LENGTH
         LR    R1,R4               SAVE RECORD LOCATION
         TM    LRCFLAG1,LRC1CCTL   IS CARRIAGE CONTROL SPECIFIED?
         BZ    *+L'*+4             NO, CONTINUE
         LA    R1,1(,R1)           SKIP OVER CARRIAGE CONTROL
         TM    LRCFLAG1,LRC1INUL+LRC1ONUL    IS RECORD TO BE IGNORED?
         LR    R4,R1               UPDATE RECORD POINTER
         BNZ   SKIPREC2            YES, SKIP IT
         AP    QCCREC,=P'1'        ADD ONE TO CUR REC NO
         CP    QCCREC,QPREC        REACHED THE RECORD WE WANT?
         BL    SKIPREC2            NO, TRY NEXT RECORD
         CLI   QCODE,4             IS THE REQUEST FOR A FIND?
         BE    LDS$FIND            YES, DO IT
         CLI   QCODE,8             IS IT A FINDTIME REQUEST?
         BE    LD$FTIME            YES, DO IT
FINDOFF  AH    R1,QPOFFSET         ADD OFFSET TO START OF RECORD
         SH    R7,QPOFFSET         SUBTRACT OFFSET FROM LENGTH
         BNP   ZEROPRT             NO DATA LEFT IN RECORD
         CH    R7,=H'80'           IS RECORD BIGGER THAN 80 CHARS?
         BNH   LT80                NO, USE RECORD LENGTH
         LA    R7,80               YES, USE A LENGTH OF 80
LT80     QCALL DISPLAY,3(,R1),(R7)
         TM    QDOVER,QOVPAGE      WAS THERE A PAGE OVERFLOW?
         BNO   SKIPREC2            NO, SKIP
         ZAP   QPREC,QCCREC        UPDATE THE REPOSITION NUMBER
         MVC   HREC,EDIT           PATTERN FOR EDIT
         ED    HREC,QCCREC         EDIT RECORD NUMBER
SKIPREC2 LA    R4,LRCTEXT(R6)      INCREMENT TO NEXT RECORD
         B     NEXTREC2            PROCESS NEXT RECORD
LDS$SPAN LH    R6,LRCSEGL          LENGTH OF SEGMENT
         TM    LRCFLAG1,LRC1SBGN   IS THIS THE FIRST SEGMENT?
         BO    SPAN1ST2            YES, USE HEADER LENGTH OF 6
         LA    R4,LRCSTEXT(R6)     UPDATE RECORD POSITION
         B     NEXTREC2            PROCESS NEXT RECORD
SPAN1ST2 LA    R4,LRCSFTXT(R6)     UPDATE RECORD POSITION
         B     NEXTREC2            PROCESS NEXT RECORD
ZEROPRT  LA    R1,QBLANK           PRINT A BLANK
         LA    R7,1                LENGTH OF ONE
         B     LT80                PRINT THE RECORD
         DROP  R4,R5
LDS$END  CP    QCCREC,=P'0'        IS THE DATA-SET EMPTY
         BE    LSTDSTOP            YES, QUIT
         MVC   HEND,ENDLINE        TELL THEM THIS IS THE END
         MVC   HREND,EDIT          PATTERN FOR EDIT
         ED    HREND,QCCREC        LAST REC NO
         CLI   QCODE,32            WAS REQUEST FOR BOTTOM?
         BE    BOTTOM1             YES, BACK UP 20 LINES
         L     R1,=A(ENDDATA)
         QCALL DISPLAY,(R1),80     MOVE 'END OF DATA' TO SCREEN
         QCALL DISPLAY,,0          FLUSH THE SCREEN
         ZAP   QPREC,=P'1'         RECORD NUMBER 1
         MVC   QDHLINE,QCHLINE     BLANK THE TITLE LINE
         B     LD$TOP              START AT TOP OF DATA-SET
LSTDSTOP MVC   QDHLINE,EMPTYDS
         QSTOP
         SPACE 1
*---     BOTTOM OF DATA-SET                                        ---*
         SPACE 1
BOTTOM1  ZAP   QPREC,QCCREC        LAST RECORD NUMBER
         MVI   QCODE,0             AVOID A LOOP
         SP    QPREC,=P'19'        TOP OF PAGE
         BP    LD$REPOS            CONTINUE IF POSITIVE
         ZAP   QPREC,=P'1'         TOP OF DATA-SET
         SPACE 1
*---     REPOSITION TO REQUESTED RECORD NUMBER                     ---*
         SPACE 1
LD$REPOS MVC   QDHLINE,QCHLINE     MOVE IN HEADING LINE
         MVC   HREC,EDIT           PREPARE FOR EDIT
         ED    HREC,QPREC          EDIT RECORD NUMBER
         CP    QPREC,QCHREC        IS THE REQ NO > HIGHEST READ?
         BNL   LD$HI               YES, GO FROM HI
         CP    QPREC,QCCREC        IS THE REQ NO > CURRENT REC?
         BH    UP                  YES, GO FROM CURRENT
         CP    QPREC,=P'1'         IS REQ FOR TOP OF DATA-SET?
         BH    DOWN                NO, GO DOWN FROM CURRENT
LD$TOP   L     R2,QCSTART          START AT TOP
LDRESUME L     R4,0(R2)            LOAD DISK ADDR
         L     R5,QCBLKA           ADDR OF BLOCK IOAREA
         MVC   QCCREC,4(R2)        RESET CURRENT REC NO
         B     LDSFIRST            RESUME PROCESSING
LD$HI    L     R2,QCHPTR           START AT HIGHEST SO FAR
         B     DOWNLOOP            FIND CORRECT BLOCK
UP       L     R2,QCCPTR           CURRENT TABLE PTR
UPLOOP   CP    QPREC,12(4,R2)      IS THE NEXT ENTRY > REQ NO?
         BNH   LDRESUME            YES, PROCESS IT
         LA    R2,8(R2)            TRY NEXT ENTRY
         B     UPLOOP              AGAIN
DOWN     L     R2,QCCPTR           CURRENT TABLE PTR
DOWNLOOP CP    QPREC,4(4,R2)       IS THE ENTRY < REQ NO?
         BH    LDRESUME            YES, PROCESS IT
         SH    R2,=H'8'            TRY PREVIOUS ENTRY
         B     DOWNLOOP            AGAIN
         SPACE 1
*---     FIND MATCHING RECORD ROUTINE                              ---*
         SPACE 1
LDS$FIND LH    R3,QPLNG            LENGTH-1 OF COMPARE
         LR    R14,R6              LENGTH OF RECORD
         SR    R14,R3              NUMBER OF COMPARES
         BNP   SKIPREC2            RECORD IS TOO SMALL, SKIP IT
         LR    R15,R4              FIRST BYTE OF RECORD
FLOOP    EX    R3,LDS$CLC          DOES THE FIND DATA MATCH THE REC?
         BE    MATCH               YES, DISCONTINUE SEARCH
         LA    R15,1(R15)          INCREMENT TO NEXT BYTE
         BCT   R14,FLOOP           TRY NEXT BYTE
         B     SKIPREC2            SKIP THE RECORD, NO MATCH
MATCH    CLI   QSUBNAME+1,C'A'     IS THE REQUEST FOR A FINDALL?
         BE    FALL                YES, DO NOT DISABLE SEARCH
         MVI   QCODE,0             END THE SEARCH
         ZAP   QPREC,QCCREC        UPDATE THE REPOSITION NUMBER
FALL     MVC   HREC,EDIT           PREPARE FOR EDIT
         ED    HREC,QCCREC         EDIT RECORD NUMBER
         B     FINDOFF             CONTINUE
LDS$CLC  CLC   QPFIND(1),3(R15)    COMPARE PARM TO RECORD
         SPACE 1
*---     FIND THE RECORD WHICH IS GREATER THAN OR EQUAL TO TIME    ---*
         SPACE 1
LD$FTIME CLI   10(R4),C'.'         MVS/370 LOG TIME?
         BNE   *+L'*+10            NO
         CLC   QPARM1,8(R4)        YES, IS THIS THE TIME WE WANT?
         B     LD$FTBW
         CLI   27(R4),C':'         MVS/XA LOG TIME?
         BNE   *+L'*+10            NO
         CLC   QPARM4,25(R4)       YES, IS THIS THE TIME WE WANT?
         B     LD$FTBW
         CLI   30(R4),C':'         MVS/XA 2.2.0 LOG TIME?
         BNE   SKIPREC2            NO, SKIP IT
         CLC   QPARM4,28(R4)       YES, IS THIS THE TIME WE WANT?
LD$FTBW  BH    SKIPREC2            NO, SKIP IT
         B     MATCH               END THE SEARCH
         SPACE 1
*---     READ A BLOCK FROM HASPACE                                 ---*
         SPACE 1
LDS$READ ST    R4,QCTRAK           STORE DISK ADDR
         LR    R1,R5               IOAREA ADDRESS
         QCALL READSPC             READ HASPACE
         BR    R8                  RETURN TO CALLER
         SPACE 1
         LTORG
         SPACE 1
EMPTYDS  DC    CL79'*** DATA SET IS EMPTY ***'
ENDLINE  DC    C', END OF DATA. LAST REC #'
EDIT     DC    X'4020202020202021'
         DC    CL45' '
         SPACE 1
         DROP  R9,R10,R11,R12
 TITLE '--- QUEUE/SP -- REPOS -- DATA-SET REPOSITIONING ROUTINES ---'
REPOS    QSTART
         USING QCKPT,R10           BASE REG FOR CKPT WORK AREA
         L     R10,QVCKPT          LOAD BASE REG
         USING QDISPLAY,R9         BASE REG FOR DISPLAY WORK AREA
         L     R9,QVDSPL           LOAD BASE REG
         SPACE 1
*---     BRANCH TO PROPER ROUTINE                                  ---*
         SPACE 1
         CLC   QPDSID,=H'0'        IS THERE A VALID DATA-SET?
         BNE   GO                  YES, GO AHEAD
         QTILT '=== YOU ARE NOT PROCESSING A VALID DATA-SET ==='
GO       LH    R1,QCODEH           LOAD FUNCTION CODE
         CH    R1,=H'32'           IS THE FUNCTION SUPPORTED?
         BH    RP$STOP             NO, RETURN
         B     *+L'*(R1)           BRANCH TO ROUTINE
         B     RP$TILT                  0 OFFSET
         B     RP$FIND                  4
         B     RP$FTIME                 8
         B     COLUMN                   12
         B     AT                       16
         B     RP$PLUS                  20
         B     MINUS                    24
         B     RP$TOP                   28
         B     RP$BOTTM                 32
RP$TILT  QTILT '*** PARAMETER IS INVALID OR OMITTED ***'
         SPACE 1
*---     REPOSITION VERTICALLY                                     ---*
         SPACE 1
*---     SKIP FORWARD                                              ---*
         SPACE 1
RP$PLUS  BAS   R4,NUMERIC          VALIDATE PARAMETER
         AP    QPREC,QNUMWORK      ADD COUNT TO CURRENT RECORD
         B     RPRESUME            CALL LISTDS
         SPACE 1
*---     SKIP BACKWARD                                             ---*
         SPACE 1
MINUS    BAS   R4,NUMERIC          VALIDATE PARAMETER
         SP    QPREC,QNUMWORK      SUBTRACT COUNT FROM CURR REC
         BP    RPRESUME            CALL LISTDS IF RESULT POSITIVE
         SPACE 1
*---     TOP OF DATA-SET                                           ---*
         SPACE 1
RP$TOP   ZAP   QPREC,=P'1'         SET CURRENT RECORD TO TOP OF DS
         SPACE 1
*---     RESUME AT CURRENT RECORD                                  ---*
         SPACE 1
RPRESUME QCALL LISTDS
RP$STOP  QSTOP
         SPACE 1
*---     BOTTOM OF DATA-SET                                        ---*
         SPACE 1
RP$BOTTM ZAP   QPREC,=P'9999999'   SET CURRENT RECORD TO LARGEST
         B     RPRESUME            CALL LISTDS
         SPACE 1
*---     POSITION TO THIS RECORD                                   ---*
         SPACE 1
AT       BAS   R4,NUMERIC          VALIDATE PARAMETER
         ZAP   QPREC,QNUMWORK      INDICATE REPOSITION NO
         B     RPRESUME            CALL LISTDS
         SPACE 1
*---     CHECK THE PARMETER FOR VALID NUMERIC AND PACK IT          ---*
         SPACE 1
NUMERIC  LH    R1,QLNG1            LENGTH OF PARM
         SH    R1,=H'1'            IS THE COUNT FIELD ZERO?
         BM    RPRESUME            YES, RESUME FROM CURRENT POSIT
         LA    R15,QPARM1          POINT TO PARM
         BAS   R14,QNUMCONV        CONVERT IT
         BNE   RP$TILT             TILT IF NOT NUMERIC
         BR    R4                  RETURN
         SPACE 1
*---     REPOSITION HORIZONTALLY                                   ---*
         SPACE 1
COLUMN   BAS   R4,NUMERIC          VALIDATE PARAMETER
         CP    QNUMWORK,=P'255'    IS THE COUNT FIELD TOO BIG?
         BH    RP$TILT             YES, TILT
         SP    QNUMWORK,=P'1'      COLUMN RELATIVE TO ZERO
         BM    RP$TILT             INVALID, TILT
         CVB   R5,QNUMWORK         CONVERT TO BINARY
         STH   R5,QPOFFSET         STORE IN QPOFFSET
         B     RPRESUME            CALL LISTDS
         SPACE 1
*---     LOCATE SPECIFIC RECORD                                    ---*
         SPACE 1
RP$FIND  CLI   QSUBNAME+1,C'A'     IS THE REQUEST FOR FIND ALL?
         BE    *+L'*+6             YES, DO NOT UPDATE REC POINTER
         AP    QPREC,=P'1'         START SEARCH AT NEXT RECORD
         CLI   QPARM1,C' '         IS THERE A PARAMETER?
         BE    RPRESUME            NO, CONTINUE WITH PREV. FIND
         LA    R2,QDREPLY+QDREPLYL-1    END OF USER REPLY
         LA    R3,QDREPLYL-2       MAXIMUM LENGTH OF PARM
         SH    R3,QOFF1            OFFSET TO FIRST PARM
REPOS$LP CLC   0(1,R2),QPARM1      IS THIS THE DELIMITER?
         BE    RP$FOUND            YES, CONTINUE
         BCTR  R2,0                TRY THE PREVIOUS BYTE
         BCT   R3,REPOS$LP         IS THE LENGTH FIELD EXHAUSTED?
         B     RP$TILT             YES, TILT
RP$FOUND BCTR  R3,0                DECREMENT LENGTH BY 1
         LA    R2,QDREPLY+1        ADDR OF REPLY + 1
         AH    R2,QOFF1            ADDR OF FIRST BYTE OF PARM
         EX    R3,MVC              MOVE PARM TO QPFIND
         STH   R3,QPLNG            SAVE LENGTH-1 OF PARM
         B     RPRESUME            CALL LISTDS
MVC      MVC   QPFIND(1),0(R2)     MOVE PARM TO QPFIND
         SPACE 1
*---     REPOSITION IN SYSLOG DATA-SET BY TIME OF DAY              ---*
         SPACE 1
RP$FTIME CLI   QPARM1,C' '         IS THE PARM OMITTED?
         BE    RP$TILT             YES, TILT
         MVC   QPARM4,QPARM1       BUILD MVS/XA LOG TIME FORMAT
         MVI   QPARM4+2,C':'
         MVI   QPARM4+5,C':'
         B     RPRESUME            CALL LISTDS
         SPACE 1
         LTORG
         SPACE 1
         DROP  R9,R10,R11,R12
 TITLE '--- QUEUE/SP -- SAVE -- CREATE A COPY OF CURRENT DS ---'
SAVEX    QSTART
         USING QCKPT,R10           BASE REG FOR CHECKPT WORK AREA
         L     R10,QVCKPT          LOAD BASE REG
         USING QDISPLAY,R9         BASE REG FOR DISPLAY WORK AREA
         L     R9,QVDSPL           LOAD BASE REG
         SPACE 1
*---     ALLOCATE OUTPUT DATA-SET                                  ---*
         SPACE 1
         CLC   QPDSID,=H'0'        IS THERE A VALID DATA-SET?
         BE    SV$TILT1            NO, TELL THE USER
         MVC   DSNAME+2(44),QBLANK BLANK THE DSNAME
         MVC   DSNAME+2(8),QPARM1  FIRST PART OF DSNAME
         LA    R1,DSNAME           ADDR OF DSNAME
         ST    R1,DAALPDSN         STORE IN PARM LIST
         LH    R2,QLNG1            LENGTH OF QPARM1
         LA    R1,2(R2,R1)         OFFSET INTO DSNAME
         MVC   0(8,R1),=C'.OUTLIST'     LAST PART OF DSNAME
         LA    R1,8(,R2)           LENGTH OF DSNAME
         STH   R1,DSNAME           STORE LENGTH OF DSNAME
         CLI   QPARM2,C' '         ANY DISP?
         BNE   *+L'*+6             YES, USE IT
         MVC   QPARM2,=CL8'NEW'    NO, USE NEW
         MVC   DAALUNIT(DAAL$L),ALLOCNEW  REST OF DISP=NEW PARM LIST
         CLC   QPARM2,=CL8'NORLSE' NEW BUT NO RELEASE?
         BNE   *+L'*+10            NO, SKIP
         MVC   QPARM2,=CL8'NEW'    YES, CHANGE TO DISP=NEW
         MVI   DAALCTL,DA08TRKS+DA08UID TURN OFF RLSE BIT
         CLC   QPARM2,=CL8'NEW'    IS THIS DISP=NEW?
         BE    SAVE$ALC            YES, GO ALLOC
         MVC   DAALUNIT(DAAL$L),ALLOCOLD     NO, ASSUME OLD
         CLC   QPARM2,=CL8'OLD'    IS IT?
         BE    SAVE$ALC            YES
         MVI   DAALDSP1,DA08MOD    NO, CHANGE TO MOD
         CLC   QPARM2,=CL8'MOD'    IS IT?
         BNE   SV$TILT2            NO, COMPLAIN
SAVE$ALC MVI   DAIRFLAG,DFALLOC    REQUEST ALLOCATE FUNCTION
         QCALL ALLOCATE            ALLOCATE IT
         MVC   QCOUT+(DCBDDNAM-IHADCB)(L'DAALDDN),DAALDDN
*                                  GET THE DDNAME RETURNED BY DAIR
         CLC   QPARM2,=CL8'NEW'    WAS IT DISP=NEW?
         BNE   SV$OPEN             NO, GO OPEN
         MVC   QCOUT+(DCBRECFM-IHADCB)(1),QCRECFM
*                                  MOVE IN RECORD FORMAT
         NI    QCOUT+(DCBRECFM-IHADCB),DCBRECCC
*                                  TURN OFF EVERTHING BUT CCTL
         OI    QCOUT+(DCBRECFM-IHADCB),DCBRECF+DCBRECBR
*                                  SPECIFY FIXED BLOCKED RECORDS
         LH    R1,QCLRECL          RECORD LENGTH
         LTR   R1,R1               IS THE LRECL ZERO?
         BNZ   *+L'*+4             NO, SKIP
         LA    R1,133              YES, USE LRECL 133
         STH   R1,QCOUT+(DCBLRECL-IHADCB)    STORE LRECL
BIGGER   LR    R2,R1               UPDATE BLKSIZE
         AH    R1,QCOUT+(DCBLRECL-IHADCB)    ADD LRECL TO BLKSIZE
         CH    R1,=H'4096'         BLKSIZE GREATER THAN 4096?
         BL    BIGGER              NO, MAKE IT BIGGER
         STH   R2,QCOUT+(DCBBLKSI-IHADCB)    STORE BLKSIZE
SV$OPEN  XC    QCERR,QCERR         RESET ERROR INDICATOR
         OPEN  MF=(E,QCOPEN)
         OC    QCERR(2),QCERR      ABEND HAS BEEN ENTERED?
         BNZ   SV$TILT5            YES
         TM    QCOUT+(DCBOFLGS-IHADCB),DCBOFOPN   OPEN OK?
         BZ    SV$TILT3            NO, OPEN ERROR
         MVI   QCERR+3,ENDIND      SAY DATA-SET OPENED
         CLC   QPARM2,=CL8'NEW'    WAS IT DISP=NEW?
         BE    SV$START            YES, OK, START TO PROCESS
         MVC   BUFFER(1),QCRECFM   NO, CHECK RECORD FORMAT AND CC
         MVC   BUFFER+1(1),QCOUT+(DCBRECFM-IHADCB)
         NI    BUFFER,DCBRECF+DCBRECCC
         NI    BUFFER+1,DCBRECF+DCBRECCC
         CLC   BUFFER(1),BUFFER+1  RECORD FORMAT AND CC MATCH?
         BNE   SV$TILT4            NO, REJECT REQUEST
         SPACE 1
*---     REPOSITION DATA-SET TO TOP                                ---*
         SPACE 1
SV$START L     R4,QCSTART          TOP OF DATA-SET POINTER
         L     R4,0(R4)            DISK ADDR TOP OF DATA-SET
         L     R5,QCBLKA           IOAREA ADDRESS
         B     SV$FIRST            GO DO IT
         SPACE 1
*---     PROCESS DATA-SET                                          ---*
         SPACE 1
         USING BUFSTART,R5
SV$NXTBL L     R4,HDBNXTRK         DISK ADDR OF NEXT BLOCK
SV$FIRST LTR   R4,R4               IS THE DISK ADDR ZERO?
         BZ    SAVE$END            YES, END OF DATA-SET
         BAS   R8,SV$READ          READ A BLOCK
         CLC   HDBKEY,QPJOBID      DOES THE JOBID MATCH?
         BNE   SAVE$END            NO, END OF DATA-SET
         LA    R4,HDBSTART         ADDR OF FIRST RECORD IN BLOCK
         SPACE 1
*---     PROCESS RECORDS (SKIP SPANNED)                            ---*
         SPACE 1
         USING LRC,R4
NEXTREC3 CLI   LRCTLENG,ENDIND     IS LENGTH BYTE FF?
         BE    SV$NXTBL            YES, END OF BLOCK
         TM    LRCFLAG1,LRC1SPAN   SPANNED RECORD?
         BO    SV$SPAN             YES, SKIP IT
         ZIC   R6,LRCTLENG         INSERT LENGTH
         TM    LRCFLAG1,LRC1CCTL   IS CCTL SPECIFIED?
         BZ    *+L'*+4             NO, SKIP
         LA    R6,1(,R6)           INCREMENT LENGTH FOR CCTL
         TM    LRCFLAG1,LRC1INUL+LRC1ONUL    IS RECORD TO BE IGNORED?
         BNZ   SKIPREC3            YES, SKIP IT
         MVI   BUFFER,C' '         BLANK FIRST BYTE OF BUFFER
         MVC   BUFFER+1(L'BUFFER-1),BUFFER   BLANK THE BUFFER
         LR    R7,R6               DO NOT DESTROY R6
         SH    R7,=H'1'            IS LENGTH ZERO?
         BM    SKIPREC3            YES, SKIP RECORD
         EX    R7,MVCREC           MOVE RECORD TO BUFFER
         PUT   QCOUT,BUFFER
         OC    QCERR(2),QCERR      ABEND OR SYNAD HAS BEEN ENTERED?
         BNZ   SV$TILT5            YES
SKIPREC3 LA    R4,LRCTEXT(R6)      INCREMENT TO NEXT RECORD
         B     NEXTREC3            PROCESS NEXT RECORD
SV$SPAN  LH    R6,LRCSEGL          SEGMENT LENGTH
         TM    LRCFLAG1,LRC1SBGN   IS THIS THE FIRST SEGMENT?
         BO    SPAN1ST3            YES, USE LARGER HEADER SIZE
         LA    R4,LRCSTEXT(R6)     INCREMENT TO NEXT RECORD
         B     NEXTREC3            PROCESS NEXT RECORD
SPAN1ST3 LA    R4,LRCSFTXT(R6)     INCREMENT TO NEXT RECORD
         B     NEXTREC3            PROCESS NEXT RECORD
MVCREC   MVC   BUFFER(*-*),LRCTEXT <<EXECUTED>>
         DROP  R4,R5
         SPACE 1
*---     READ A BLOCK FROM HASPACE                                 ---*
         SPACE 1
SV$READ  ST    R4,QCTRAK           STORE DISK ADDR
         LR    R1,R5               IOAREA ADDRESS
         QCALL READSPC             READ HASPACE
         BR    R8                  RETURN TO CALLER
         SPACE 1
*---     CLOSE UP SHOP AND GO HOME                                 ---*
         SPACE 1
SAVE$END CLI   QCERR+2,ENDIND      MOD=NEW STATUS?
         BNE   SV$LEAVE            NO
         XR    R3,R3               YES, GET TIOT OFFSET
         LR    R2,R3
         ICM   R3,B'0011',QCOUT+(DCBTIOT-IHADCB)
         AL    R3,#TSTIOT
         USING TIOENTRY,R3
         ICM   R2,B'0111',TIOEFSRT GET UCB POINTER
         DROP  R3
         MVI   QCERR+1,72
         MVC   BUFFER(72),=CL72'*** DATA-SET HAS BEEN CREATED ON VOLUME1
                ??????, BUT IS NOT CATALOG''D ***'
         ZEROKEY
         USING UCBDSECT,R2
         CLI   UCBID,UCBSTND       TRUE UCB?
         BNE   *+L'*+6             NO
         MVC   BUFFER+40(6),UCBVOLI     YES, GET VOLUME
         DROP  R2
         RESETKEY
         MVI   QCERR+2,0           RESET MOD=NEW STATUS
         B     SV$TILT5
SV$LEAVE MVI   QCERR+3,0           RESET DATA-SET OPENED
         CLOSE MF=(E,QCOPEN)
         OC    QCERR(2),QCERR      ABEND HAS BEEN ENTERED?
         BNZ   SV$TILT5            YES
         MVI   DAIRFLAG,DFFREE     REQUEST FREE FUNCTION
         MVC   DAFRDDN,QCOUT+(DCBDDNAM-IHADCB)    GET THE DDNAME
         QCALL ALLOCATE            FREE IT BY DDNAME
         QCALL LISTDS              GO BACK TO LISTDS
         QSTOP
         SPACE 1
SV$TILT1 QTILT '=== YOU ARE NOT PROCESSING A VALID DATA-SET ==='
SV$TILT2 QTILT '*** INVALID DISP ***'
SV$TILT3 MVI   QCERR+1,27
         MVC   BUFFER(27),=CL27'*** DATA-SET OPEN ERROR ***'
         B     SV$TILTX
SV$TILT4 MVI   QCERR+1,43
         MVC   BUFFER(43),=CL43'*** RECORD FORMAT AND/OR CC DISCREPANCY1
                ***'
         B     SV$TILTX
SV$TILT5 CLI   QCERR+3,ENDIND
         BNE   SV$EXIT
SV$TILTX MVI   QCERR+3,0           RESET DATA-SET OPENED
         CLOSE MF=(E,QCOPEN)
SV$EXIT  MVI   DAIRFLAG,DFFREE     REQUEST FREE FUNCTION
         MVC   DAFRDDN,QCOUT+(DCBDDNAM-IHADCB)    GET THE DDNAME
         QCALL ALLOCATE            FREE IT BY DDNAME
         LH    R0,QCERR
         LA    R1,BUFFER
         QTILT ,
         SPACE 1
         CNOP  0,4
         USING IHADCB,R1
SV$DCBEX CLC   QPARM2,=CL8'MOD'    WAS IT DISP=MOD?
         BNER  R14                 NO, OK, LET'S GO
         OC    DCBBLKSI,DCBBLKSI   YES, IS MOD BEEING USED LIKE NEW?
         BNZ   R14                 NO, OK, TRUE MOD, LET'S GO
         LH    R2,QCLRECL          YES, COMPLETE DCB INFO
         LTR   R2,R2               IS THE LRECL ZERO?
         BNZ   *+L'*+4             NO, SKIP
         LA    R2,133              YES, USE LRECL 133
         STH   R2,DCBLRECL         STORE LRECL
         LR    R3,R2               UPDATE BLKSIZE
         AH    R2,DCBLRECL         ADD LRECL TO BLKSIZE
         CH    R2,=H'4096'         BLKSIZE GREATER THAN 4096?
         BL    *-10                NO, MAKE IT BIGGER
         STH   R3,DCBBLKSI         STORE BLKSIZE
         MVC   DCBRECFM,QCRECFM    MOVE IN RECORD FORMAT
         NI    DCBRECFM,DCBRECCC   TURN OFF EVERTHING BUT CCTL
         OI    DCBRECFM,DCBRECF+DCBRECBR     SPECIFY FIXED BLOCKED
         MVI   DCBDSORG,DCBDSGPS   SET DSORG=PS
         MVI   QCERR+2,ENDIND      SIGNAL MOD=NEW STATUS
         BR    R14                 AND GO BACK
         DROP  R1
         SPACE 1
         CNOP  0,4
SV$DCBSA SYNADAF ACSMETH=QSAM
         CLI   69(R1),C'*'         UNSIGNIFICANT MESSAGE?
         BE    SV$SYN3             YES
         CLI   8(R1),C' '          YES, BINARY INFORMATIONS?
         BE    SV$SYN1             NO
         UNPK  56(7,R1),9(4,R1)    YES
         TR    56(6,R1),HEXTAB-X'F0'
         MVI   62(R1),C','
         UNPK  63(5,R1),12(3,R1)
         TR    63(4,R1),HEXTAB-X'F0'
         MVI   67(R1),C','
         B     SV$SYN2
SV$SYN1  MVC   56(12,R1),8(R1)     MOVE BLANKS
SV$SYN2  MVC   BUFFER(72),56(R1)
         MVI   QCERR+1,72
         B     SV$SYN4
SV$SYN3  MVC   BUFFER(38),=CL38'*** SYNAD ERROR, BUT UNSIGNIFICANT ***'
         MVI   QCERR+1,38
SV$SYN4  SYNADRLS
         BR    R14                 GO BACK
         SPACE 1
         CNOP  0,4
SV$DCBAB TM    3(R1),X'04'         OK TO IGNORE AVAILABLE?
         BO    *+L'*+6             YES
         MVI   3(R1),0             NO, LET'S GO THE ABEND
         BR    R14
         MVC   BUFFER(26),=CL26'*** ABEND S     RC=    ***'
         UNPK  BUFFER+11(5),0(3,R1)
         MVC   BUFFER+14(2),=CL2' ('
         UNPK  BUFFER+19(3),2(2,R1)
         MVI   BUFFER+21,C')'
         MVI   QCERR+1,26
         MVI   3(R1),4             SET IGNORE ABEND CONDITION
         BR    R14
         SPACE 1
QCOLST   DC    0F'0',XL1'05',AL3(SV$DCBEX),XL1'91',AL3(SV$DCBAB)
         SPACE 1
         DS    0F
ALLOCNEW DC    2CL8' '             UNIT & VOLSER
         DC    F'0,10,50,0'        BLKSIZE / PRI / SEC / DIR
         DC    2CL8' '             MEMBER & PASSWORD
         DC    AL1(DA08NEW)        STAT=NEW
         DC    AL1(DA08CAT)        DISP=CATLG
         DC    AL1(DA08CATL)       DISP=CATLG
         DC    AL1(DA08TRKS+DA08UID+DA08RLSE)
*                                  TRKS + PREFIX_USERID + RLSE
         DC    F'0',CL8' '
         SPACE 1
ALLOCOLD DC    2CL8' '             UNIT & VOLSER
         DC    4F'0'               BLKSIZE / PRI / SEC / DIR
         DC    2CL8' '             MEMBER & PASSWORD
         DC    AL1(DA08OLD)        STAT=OLD
         DC    AL1(DA08KEEP)       DISP=KEEP
         DC    AL1(DA08KEP)        DISP=KEEP
         DC    AL1(DA08UID)        PREFIX_USERID TO DSNAME
         DC    F'0',CL8' '
         SPACE 1
         LTORG
         SPACE 1
         DROP  R9,R10,R11,R12
 TITLE '--- QUEUE/SP -- SEARCH -- JQE AND JOE SEARCH AND FORMAT ---'
SEARCH   QSTART
         L     R10,QVCKPT          @ CKPT WORK AREA
         USING QCKPT,R10
         USING JQE,R9              BASE REG FOR JQE DSECT
         USING JOE,R8              BASE REG FOR JOE DSECT
         SPACE 1
*---     BRANCH TO PROPER ROUTINE                                  ---*
         SPACE 1
         LH    R1,QCODEH           LOAD FUNCTION CODE INTO R1
         CH    R1,MAXSRCH          IS THE FUNCTION SUPPORTED?
         BH    SRCHEXIT            NO, RETURN
         OI    QDOVER,QAUTCMD      SET ELIGIBLE AUTOMATIC MODE
         B     GETSRCH(R1)         BRANCH TO ROUTINE
GETSRCH  DS    0H
         B     ST                       0 OFFSET
         B     DA                       4
         B     DI                       8
         B     AO                       12  REALLY 'DO' COMMAND
         B     AI                       16
         B     AO                       20
         B     HI                       24
         B     HO                       28
         B     DT                       32
         B     DJ                       36  ALSO 'XJ' COMMAND
         B     DS                       40
         B     QI                       44
         B     QO                       48
         B     DL                       52
         B     DL                       56  REALLY 'DR' COMMAND
MAXSRCH  DC    0H'0',AL2(*-GETSRCH-4)
         SPACE 1
*---------------------------------------------------------------------*
*                                                                     *
* STATUS : FIND ALL JOBS THAT MATCH LEVEL                             *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
ST       CLI   QPARM1,C'0'         IS FIRST CHARACTER NUMERIC?
         BL    ST0                 NO
         QTILT '*** YOU MUST SPECIFY JOB NAME OR PREFIX ***'
ST0      CLI   QPARM1,C'*'         DID USER SPECIFY LOGON LEVEL?
         BNE   ST1                 NO, SKIP
         MVC   QSTKEY(7),QLOGON    SET SEARCH KEY
         MVI   QSTKEY+7,C' '       FIX LAST BYTE
         B     ST2
ST1      CLI   QPARM1,C' '         DID USER SPECIFY LEVEL?
         BNE   *+L'*+6             YES, SKIP
ST2      MVC   QPARM1,QSTKEY       NO, USE LAST SEARCH KEY
         MVC   QSTKEY,QPARM1       SAVE SEARCH KEY
         BAS   R2,PARMLEN          DETERMINE PARM LENGTH
         SPACE 1
*---     SEARCH THE TSO QUEUE                                      ---*
         SPACE 1
         USING JQTDSECT,R1         BASE REG FOR JQT
DJ2      LH    R6,QLNG1            LENGTH OF COMPARE FOR LEVEL
         L     R1,QCJQHEAD         @ JQE'S QUEUES HEADS
         LA    R4,JQTTSU           ADDR OF TSO QUEUE
         MVI   QCLASS,0            INDICATE THIS IS THE TSO QUEUE
         BAS   R2,SRCHJQE          SEARCH THE QUEUE
         B     DJ3                 END OF QUEUE
         CLI   QPARM1,C'0'         IS FIRST CHARACTER NUMERIC?
         BL    *+L'*+8             NO
         CH    R5,JQEJOBNO         IS THIS THE RIGHT JOB NUMBER?
         B     *+L'*+4
         EX    R6,STCLC            IS THE JOB NAME EQUAL TO LEVEL?
         BNE   SKIPJQE             NO, SKIP THIS RECORD
         B     PRTJQE              PRINT THE RECORD
         SPACE 1
*---     SEARCH THE SYSTEM QUEUE                                   ---*
         SPACE 1
DJ3      L     R1,QCJQHEAD         @ JQE'S QUEUES HEADS
         LA    R4,JQTSTC           ADDR OF STC QUEUE
         MVI   QCLASS,4            INDICATE THIS IS THE STC QUEUE
         BAS   R2,SRCHJQE          SEARCH THE QUEUE
         B     DJ4                 END OF QUEUE
         CLI   QPARM1,C'0'         IS FIRST CHARACTER NUMERIC?
         BL    *+L'*+8             NO
         CH    R5,JQEJOBNO         IS THIS THE RIGHT JOB NUMBER?
         B     *+L'*+4
         EX    R6,STCLC            IS THE JOB NAME EQUAL TO LEVEL?
         BNE   SKIPJQE             NO, SKIP THIS RECORD
         B     PRTJQE              PRINT THE RECORD
         SPACE 1
*---     SEARCH FOR HELD OUTPUT                                    ---*
         SPACE 1
DJ4      L     R1,QCJQHEAD         @ JQE'S QUEUES HEADS
         LA    R4,JQTOUT           ADDR OF $OUTPUT QUEUE
         DROP  R1
         MVI   QCLASS,8            INDICATE THIS IS THE HELD OUT Q
         BAS   R2,SRCHJQE          SEARCH THE QUEUE
         B     ST3                 END OF QUEUE
         CLI   QPARM1,C'0'         IS FIRST CHARACTER NUMERIC?
         BL    *+L'*+8             NO
         CH    R5,JQEJOBNO         IS THIS THE RIGHT JOB NUMBER?
         B     *+L'*+4
         EX    R6,STCLC            IS THE JOB NAME EQUAL TO LEVEL?
         BNE   SKIPJQE             NO, SKIP THIS RECORD
         CLI   JQEHLDCT,0          ANY HELD DATA-SETS? (PART 1)
         BNE   PRTJQE              YES, PRINT THE RECORD
         TM    JQEHLDCT,X'F0'      ANY HELD DATA-SETS? (PART 2)
         BNZ   PRTJQE              YES, PRINT THE RECORD
         B     REJJQE              REJECT THE RECORD
         SPACE 1
*---     SEARCH INPUT QUEUES                                       ---*
         SPACE 1
ST3      MVI   QCLASS,192          START WITH CLASS A
ST4      BAS   R2,NEXTJQT          FIND NEXT QUEUE
         BAS   R2,SRCHJQE          SEARCH THE QUEUE
         B     ST4                 END OF QUEUE
         CLI   JQEFLAG1,0          IS THE JOB EXECUTING OR HELD?
         BNE   ST7                 YES, SPECIAL HANDLING
         CLI   QPARM1,C'0'         IS FIRST CHARACTER NUMERIC?
         BL    *+L'*+8             NO
         CH    R5,JQEJOBNO         IS THIS THE RIGHT JOB NUMBER?
         B     *+L'*+4
         EX    R6,STCLC            IS THE JOB NAME EQUAL TO LEVEL?
         BNE   SKIPJQE             NO, SKIP THIS RECORD
         B     PRTJQE              PRINT THE JQE
ST7      CLI   QPARM1,C'0'         IS FIRST CHARACTER NUMERIC?
         BL    *+L'*+8             NO
         CH    R5,JQEJOBNO         IS THIS THE RIGHT JOB NUMBER?
         B     *+L'*+4
         EX    R6,STCLC            IS THE JOB NAME EQUAL TO LEVEL?
         BNE   REJJQE              NO, SKIP THIS RECORD
         B     PRT2JQE             PRINT REC WITHOUT INCR COUNT
         SPACE 1
*---     SEARCH OUTPUT QUEUES                                      ---*
         SPACE 1
ST5      XR    R4,R4               SEARCH ALL OUTPUT CLASSES
         BAS   R2,THISJOT
         B     ST6S
ST6      BAS   R2,NEXTJOT          DETERMINE NEXT QUEUE
ST6S     BAS   R2,SRCHJOE          SEARCH A JOE QUEUE
         B     ST6                 END OF QUEUE
         CLI   QPARM1,C'0'         IS FIRST CHARACTER NUMERIC?
         BL    *+L'*+8             NO
         CH    R5,JQEJOBNO         IS THIS THE RIGHT JOB NUMBER?
         B     *+L'*+4
         EX    R6,STCLC            IS THE JOB NAME EQUAL TO LEVEL?
         BE    PRTJOE              YES, PRINT THE RECORD
         NI    QDFREQ,255-QDFSV-QDFRS
         B     SKIPJOE             SKIP THIS RECORD
         SPACE 1
*---     COMPARE USED TO CHECK LEVEL                               ---*
         SPACE 1
STCLC    CLC   QPARM1(*-*),JQEJNAME  IS THE JOB NAME EQUAL TO LEVEL?
         SPACE 1
*---------------------------------------------------------------------*
*                                                                     *
* DJ : FIND A SPECIFIC JOB                                            *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
DJ       CLI   QPARM1,C'0'         IS FIRST CHARACTER NUMERIC?
         BL    DJ0                 NO
         LH    R1,QLNG1            LENGTH OF PARAMETER FIELD
         SH    R1,=H'1'            IS THE LENGTH ZERO?
         BM    DJ$TILT1            YES, TILT
         LA    R15,QPARM1          POINT TO PARM
         BAS   R14,QNUMCONV        CONVERT IT
         BNE   DJ$TILT2            TILT IF NOT NUMERIC
         LR    R5,R15              SAVE THE VALUE
         B     DJ2                 USE THE STATUS ROUTINES
DJ$TILT1 QTILT '*** MISSING JOB NUMBER ***'
DJ$TILT2 QTILT '*** INVALID JOB NUMBER ***'
DJ0      CLI   QPARM1,C' '         DID USER SPECIFY JOB NAME?
         BE    DJ9                 NO, TILT
         MVC   QLNG1,=H'7'         COMPARE FOR 8 CHARACTERS
         B     DJ2                 USE THE STATUS ROUTINES
DJ9      QTILT '*** YOU MUST SPECIFY JOB NAME ***'
         SPACE 1
*---------------------------------------------------------------------*
*                                                                     *
* DI : PRINT ALL JOBS IN INPUT QUEUES                                 *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
DI       XC    TOTLNES,TOTLNES     RESET TOTAL COUNTERS
         XC    TOTCPU,TOTCPU
         XC    TOTIO,TOTIO
         CLI   QPARM1,C' '         DID USER SPECIFY CLASS?
         BNE   DI5                 YES, LIMIT TO ONE QUEUE
         SPACE 1
*---     SEARCH ALL QUEUES                                         ---*
         SPACE 1
         MVI   QCLASS,192          START WITH CLASS A
DI2      BAS   R2,NEXTJQT          DETERMINE NEXT QUEUE
         BAS   R2,SRCHJQE          SEARCH A JQE QUEUE
         B     DI2                 END OF QUEUE
         TM    JQEFLAG1,JQE1BUSY   IS THE JOB EXECUTING?
         BNZ   REJJQE              YES, REJECT IT
         B     PRTJQE              PRINT THE RECORD
         SPACE 1
*---     SEARCH ONLY ONE QUEUE                                     ---*
         SPACE 1
DI5      MVC   QCLASS,QPARM1       USER SPECIFIED CLASS
         BAS   R2,FINDJQT          FIND QUEUE
         BAS   R2,SRCHJQE          SEARCH THE QUEUE
         B     SRCHSTOP            END OF QUEUE
         TM    JQEFLAG1,JQE1BUSY   IS THE JOB EXECUTING?
         BNZ   REJJQE              YES, REJECT IT
         B     PRTJQE              PRINT THE RECORD
         SPACE 1
*---------------------------------------------------------------------*
*                                                                     *
* AI : PRINT JOBS IN INPUT QUEUES THAT ARE AVAILABLE FOR SELECTION    *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
AI       CLI   QPARM1,C' '         DID USER SPECIFY CLASS?
         BNE   AI5                 YES, LIMIT TO ONE QUEUE
         SPACE 1
*---     SEARCH ALL QUEUES                                         ---*
         SPACE 1
         MVI   QCLASS,192          START WITH CLASS A
AI2      BAS   R2,NEXTJQT          DETERMINE NEXT QUEUE
         BAS   R2,SRCHJQE          SEARCH A JQE QUEUE
         B     AI2                 END OF QUEUE
         CLI   JQEFLAG1,0          IS THE JOB BUSY OR HELD?
         BNE   REJJQE              YES, SKIP IT
         B     PRTJQE              PRINT THE RECORD
         SPACE 1
*---     SEARCH ONLY ONE QUEUE                                     ---*
         SPACE 1
AI5      MVC   QCLASS,QPARM1       USER SPECIFIED CLASS
         BAS   R2,FINDJQT          FIND QUEUE
         BAS   R2,SRCHJQE          SEARCH THE QUEUE
         B     SRCHSTOP            END OF QUEUE
         CLI   JQEFLAG1,0          IS THE JOB BUSY OR HELD?
         BNE   REJJQE              YES, SKIP IT
         B     PRTJQE              PRINT THE RECORD
         SPACE 1
*---------------------------------------------------------------------*
*                                                                     *
* AO : PRINT AVAILABLE JOBS IN THE OUTPUT QUEUE                       *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
AO       CLI   QPARM1,C' '         DID USER SPECIFY CLASS?
         BNE   AO5                 YES, LIMIT TO ONE QUEUE
         SPACE 1
*---     SEARCH ALL QUEUES                                         ---*
         SPACE 1
         XR    R4,R4               START WITH FIRST CLASS
         BAS   R2,THISJOT          START SEARCH
AO2S     BAS   R2,SRCHJOE          SEARCH A JQE QUEUE
         B     AO2                 END OF QUEUE
         B     PRTJOE              PRINT THE RECORD
AO2      BAS   R2,NEXTJOT          DETERMINE NEXT QUEUE
         B     AO2S
         SPACE 1
*---     SEARCH ONLY ONE QUEUE                                     ---*
         SPACE 1
AO5      MVC   QCLASS,QPARM1       USER SPECIFIED CLASS
         BAS   R2,FINDJOT          FIND QUEUE
         BAS   R2,SRCHJOE          SEARCH THE QUEUE
         B     AO5S                END OF QUEUE
         B     PRTJOE              PRINT THE RECORD
AO5S     BAS   R2,NEXTJOT          DETERMINE THE OTHER QUEUE
         BAS   R2,SRCHJOE          SEARCH A JQE QUEUE
         B     SRCHSTOP            END OF QUEUE
         B     PRTJOE              PRINT THE RECORD
         SPACE 1
*---------------------------------------------------------------------*
*                                                                     *
* DL : PRINT AVAILABLE JOBS IN THE OUTPUT QUEUE (LOCAL OR REMOTE)     *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
DL       CLI   QPARM1,C' '         DID USER SPECIFY CLASS?
         BNE   DL5                 YES, LIMIT TO ONE QUEUE
         SPACE 1
*---     SEARCH ALL QUEUES (LOCAL OR REMOTE)                       ---*
         SPACE 1
         LA    R4,1                START WITH FIRST CLASS
         CLI   QCODE,52            IS IT LOCAL REQUEST?
         BE    *+L'*+4             YES
         LA    R4,1(R4)            NO, REMOTE
         BAS   R2,THISJOT          START SEARCH
DL2S     BAS   R2,SRCHJOE          SEARCH A JQE QUEUE
         B     DL2                 END OF QUEUE
         B     PRTJOE              PRINT THE RECORD
DL2      LA    R4,2
         BAS   R2,NEXTJOT+L'NEXTJOT     DETERMINE NEXT QUEUE
         B     DL2S
         SPACE 1
*---     SEARCH ONLY ONE QUEUE (LOCAL OR REMOTE)                   ---*
         SPACE 1
DL5      MVC   QCLASS,QPARM1       USER SPECIFIED CLASS
         TR    QCLASS,CLASSTBL     DETERMINE OFFSET
         LH    R4,QCLASSH          LOAD TABLE OFFSET
         SLL   R4,1                TO A-Z,0-9 CLASSES
         CLI   QCODE,56            IS IT REMOTE REQUEST?
         BE    *+L'*+2             YES
         BCTR  R4,0                SUBTRACT 1
         BAS   R2,GETJOT           GET QUEUE
         BAS   R2,SRCHJOE          SEARCH THE QUEUE
         B     SRCHSTOP            END OF QUEUE
         B     PRTJOE              PRINT THE RECORD
         SPACE 1
*---------------------------------------------------------------------*
*                                                                     *
* HI : PRINT JOBS IN INPUT QUEUES THAT ARE HELD                       *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
HI       CLI   QPARM1,C' '         DID USER SPECIFY CLASS?
         BNE   HI5                 YES, LIMIT TO ONE QUEUE
         SPACE 1
*---     SEARCH ALL QUEUES                                         ---*
         SPACE 1
         MVI   QCLASS,192          START WITH CLASS A
HI2      BAS   R2,NEXTJQT          DETERMINE NEXT QUEUE
         BAS   R2,SRCHJQE          SEARCH A JQE QUEUE
         B     HI2                 END OF QUEUE
QUEHALL  EQU   JQE1HLDA+JQE1HLD1+JQE1HLD2
         TM    JQEFLAG1,QUEHALL    IS THE JOB HELD?
         BZ    REJJQE              NO, SKIP IT
         B     PRTJQE              PRINT THE RECORD
         SPACE 1
*---     SEARCH ONLY ONE QUEUE                                     ---*
         SPACE 1
HI5      MVC   QCLASS,QPARM1       USER SPECIFIED CLASS
         BAS   R2,FINDJQT          FIND QUEUE
         BAS   R2,SRCHJQE          SEARCH THE QUEUE
         B     SRCHSTOP            END OF QUEUE
         TM    JQEFLAG1,QUEHALL    IS THE JOB HELD?
         BZ    REJJQE              NO, SKIP IT
         B     PRTJQE              PRINT THE RECORD
         SPACE 1
*---------------------------------------------------------------------*
*                                                                     *
* HO : LIST ALL JOBS WITH HELD OUTPUT                                 *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
         USING JQTDSECT,R1         BASE REG FOR JQT
HO       L     R1,QCJQHEAD         @ JQE'S QUEUES HEADS
         LA    R4,JQTOUT           ADDR OF $OUTPUT QUEUE
         DROP  R1
         MVI   QCLASS,8            INDICATE THIS IS THE HELD OUT Q
         BAS   R2,SRCHJQE          SEARCH THE QUEUE
         B     SRCHSTOP            END OF QUEUE
         CLI   JQEHLDCT,0          ANY HELD DATA-SETS? (PART 1)
         BNE   PRTJQE              YES, PRINT THE RECORD
         TM    JQEHLDCT,X'F0'      ANY HELD DATA-SETS? (PART 2)
         BNZ   PRTJQE              YES, PRINT THE RECORD
         B     REJJQE              REJECT THE RECORD
         SPACE 1
*---------------------------------------------------------------------*
*                                                                     *
* DA : FIND ALL EXECUTING JOBS                                        *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
DA       MVI   QCLASS,192          START WITH CLASS A
DA2      BAS   R2,NEXTJQT          DETERMINE NEXT QUEUE
         BAS   R2,SRCHJQE          SEARCH THE QUEUE
         B     DA2                 END OF QUEUE
         TM    JQEFLAG1,JQE1BUSY   IS THE JOB EXECUTING?
         BZ    REJJQE              NO, REJECT IT
         B     PRTJQE              PRINT THE RECORD
         SPACE 1
*---------------------------------------------------------------------*
*                                                                     *
* DT : LIST ALL TSO USERS                                             *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
         USING JQTDSECT,R1         BASE REG FOR JQT
DT       L     R1,QCJQHEAD         @ JQE'S QUEUES HEADS
         LA    R4,JQTTSU           ADDR OF TSO QUEUE
         DROP  R1
         MVI   QCLASS,0            INDICATE THIS IS THE TSO Q
         BAS   R2,SRCHJQE          SEARCH THE QUEUE
         B     SRCHSTOP            END OF QUEUE
         B     PRTJQE              PRINT THE RECORD
         SPACE 1
*---------------------------------------------------------------------*
*                                                                     *
* DS : LIST ALL SYSTEM STARTED TASKS                                  *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
         USING JQTDSECT,R1         BASE REG FOR JQT
DS       L     R1,QCJQHEAD         @ JQE'S QUEUES HEADS
         LA    R4,JQTSTC           ADDR OF STC QUEUE
         DROP  R1
         MVI   QCLASS,4            INDICATE THIS IS THE STC QUEUE
         BAS   R2,SRCHJQE          SEARCH THE QUEUE
         B     SRCHSTOP            END OF QUEUE
         B     PRTJQE              PRINT THE RECORD
         SPACE 1
*---------------------------------------------------------------------*
*                                                                     *
* QI : SUMMARY OF ALL JOBS IN THE INPUT QUEUES                        *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
QI       MVI   QCLASS,192          START WITH CLASS A
         MVC   QDHLINE,QIHEADER    MOVE THE HEADING
QI1      BAS   R2,NEXTJQT          FIND NEXT QUEUE
         ZAP   QCOUNTE,=P'0'       ZERO COUNT FOR EXECUTING JOBS
         ZAP   QCOUNTA,=P'0'       ZERO COUNT FOR AWAITING JOBS
         ZAP   QCOUNTH,=P'0'       ZERO COUNT FOR HELD JOBS
         BAS   R2,SRCHJQE          SEARCH THE QUEUE
         B     QI4                 END OF QUEUE
         TM    JQEFLAG1,JQE1BUSY   IS THIS JOB EXECUTING?
         BZ    QI2                 NO, NEXT TEST
         AP    QCOUNTE,=P'1'       YES, BUMP COUNTER
         B     SKIPJQE             PROCESS NEXT JQE
QI2      TM    JQEFLAG1,QUEHALL    HELD JOB?
         BZ    QI3                 NO, NEXT TEST
         AP    QCOUNTH,=P'1'       YES, BUMP COUNTER
         B     SKIPJQE             PROCESS NEXT JQE
QI3      CLI   JQEFLAG1,0          IS THIS JOB AWAITING EXECUTION?
         BNE   SKIPJQE             NO, PROCESS NEXT JQE
         AP    QCOUNTA,=P'1'       YES, BUMP COUNTER
         B     SKIPJQE             PROCESS NEXT JQE
QI4      CLC   QCOUNT,=PL3'0'      IS THIS QUEUE EMPTY?
         BE    QI1                 YES, TRY NEXT QUEUE
         MVC   QDMSG,QBLANK
         MVC   QTCOUNT,=XL6'402020202120'
         ED    QTCOUNT,QCOUNTE
         MVC   QECOUNT,QTCOUNT+3   NO. OF EXECUTING JOBS
         MVC   QTCOUNT,=XL6'402020202120'
         ED    QTCOUNT,QCOUNTA
         MVC   QACOUNT,QTCOUNT+3   NO. OF AWAITING JOBS
         MVC   QTCOUNT,=XL6'402020202120'
         ED    QTCOUNT,QCOUNTH
         MVC   QHCOUNT,QTCOUNT+3   NO. OF HELD JOBS
         MVC   QTCOUNT,=XL6'402020202120'
         ED    QTCOUNT,QCOUNT      TOTAL NO. OF JOBS IN THIS QUEUE
         MVC   CLASS,QCLASS        MOVE IN QUEUE CLASS
         QCALL DISPLAY,QDMSG,80    DISPLAY THE LINE
         B     QI1                 PROCESS THE NEXT QUEUE
         SPACE 1
*---------------------------------------------------------------------*
*                                                                     *
* QO : SUMMARY OF ALL JOBS IN THE OUTPUT QUEUES                       *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
QO       XR    R4,R4               START WITH FIRST CLASS
         XC    TOTLNES,TOTLNES     RESET TOTAL COUNTER
         MVC   QDHLINE,QOHEADER    MOVE THE HEADING
         BAS   R2,THISJOT          START SEARCH
         B     QOS
QO1      BAS   R2,NEXTJOT          FIND NEXT QUEUE
QOS      ZAP   QCOUNTE,=P'0'       ZERO COUNT FOR EXECUTING JOBS
         ZAP   QCOUNTA,=P'0'       ZERO COUNT FOR AWAITING JOBS
         ZAP   QCOUNTH,=P'0'       ZERO COUNT FOR HELD JOBS
         XR    R5,R5               ACCUMULATOR FOR LINES COUNT
         ZAP   QCOUNT,=P'0'        ZERO THE QUEUE COUNT
QOC      BAS   R2,FIRSTJOE         SEARCH THE QUEUE
         B     QO2                 END OF QUEUE
         A     R5,JOERECCT         ADD UP COUNT OF RECS
         L     R14,QCMSA           @ MASTER CKPT RECORD
         LH    R14,$NODEID-$SAVEBEG(,R14)    THIS NODE ID
         SLL   R14,16              MAKE LOCAL ID
         CL    R14,JOEROUT         IS THIS LOCAL?
         BNE   QOR                 NO, IT IS REMOTE
         AP    QCOUNTA,=P'1'       YES, IT IS LOCAL
         B     QOA
QOR      AP    QCOUNTH,=P'1'       REMOTE
QOA      TM    JOEFLAG1,JOE1PRT    IS JOB PRINTING?
         BZ    SKIPJOE             NO, PROCESS NEXT JOE
         AP    QCOUNTE,=P'1'       YES, BUMP COUNTER
         B     SKIPJOE             PROCESS NEXT JOE
QO2      CLI   QCLASSE+1,C'>'      LAST QUEUE ID OF THIS CLASS?
         BE    QOP                 YES
         BAS   R2,NEXTJOT          FIND NEXT QUEUE
         B     QOC                 CONTINUE
QOP      CLC   QCOUNT,=PL3'0'      IS THIS QUEUE EMPTY?
         BE    QO1                 YES, TRY NEXT QUEUE
         MVC   QDMSG,QBLANK
         MVC   QTCOUNT,=XL6'402020202120'
         ED    QTCOUNT,QCOUNTE
         MVC   QECOUNT,QTCOUNT+3   NO. OF PRINTING JOBS
         MVC   QTCOUNT,=XL6'402020202120'
         ED    QTCOUNT,QCOUNTA
         MVC   QACOUNT,QTCOUNT+3   NO. OF LOCAL JOBS
         MVC   QTCOUNT,=XL6'402020202120'
         ED    QTCOUNT,QCOUNTH
         MVC   QHCOUNT,QTCOUNT+3   NO. OF REMOTE JOBS
         MVC   QTCOUNT,=XL6'402020202120'
         ED    QTCOUNT,QCOUNT      TOTAL NO. OF JOBS IN THIS QUEUE
         MVC   CLASS(1),QCLASSE    MOVE IN QUEUE CLASS
         CVD   R5,FMT@CONV         CONVERT RECORDS TO DECIMAL
         A     R5,TOTLNES          ADD UP TOTAL RECORDS
         ST    R5,TOTLNES          AND SAVE IT AWAY
         CP    FMT@CONV+2(6),=PL6'+99999'
         BH    QO3
         MVC   QTRECS(6),=XL6'402020202120'
         ED    QTRECS(L'QTRECS),FMT@CONV+5   TOTAL
         B     QO5
QO3      MVC   QTRECS-1(6),=XL6'402020202120'
         MVO   FMT@CONV,FMT@CONV(6)
         CP    FMT@CONV+2(6),=PL6'+99999'
         BH    QO4
         MVI   QTRECS+L'QTRECS-1,C'K'
         ED    QTRECS-1(L'QTRECS),FMT@CONV+5 TOTAL IN K
         B     QO5
QO4      MVO   FMT@CONV,FMT@CONV(6)
         MVI   QTRECS+L'QTRECS-1,C'M'
         ED    QTRECS-1(L'QTRECS),FMT@CONV+5 TOTAL IN M
QO5      QCALL DISPLAY,QDMSG,80    DISPLAY THE LINE
         B     QO1                 PROCESS THE NEXT QUEUE
         SPACE 1
*---     DETERMINE LENGTH OF LEVEL                                 ---*
         SPACE 1
PARMLEN  LA    R3,7                MAXIMUM LENGTH OF 8
         LA    R4,QPARM1+7         END OF FIELD
PARMLEN2 CLI   0(R4),C' '          IS THIS BYTE BLANK?
         BNE   PARMLEN3            NO, THIS IS THE LENGTH
         BCTR  R4,0                TRY PREVIOUS BYTE
         BCT   R3,PARMLEN2         LOOP
PARMLEN3 STH   R3,QLNG1            STORE THE LENGTH OF LEVEL
         BR    R2                  RETURN TO CALLER
         SPACE 1
*---     SEARCH A JQE QUEUE                                        ---*
         SPACE 1
SRCHJQE  ZAP   QCOUNT,=P'0'        ZERO THE QUEUE COUNT
         L     R9,0(R4)            LOAD FIRST JQE OFFSET
NEXTJQE2 N     R9,=A(X'00FFFFFF')  END OF QUEUE?
         BZR   R2                  BRANCH IF END OF QUEUE
         AL    R9,QCJQEWA          ADD BASE TO OFFSET
         B     4(R2)               DETERMINE ELIGIBILITY
PRTJQE   AP    QCOUNT,=P'1'        INCREMENT COUNT
PRT2JQE  XR    R1,R1               INDICATE THIS IS A JQE
         QCALL FORMAT              PRINT THE JQE IN R9
REJJQE   L     R9,JQENEXT          LOAD OFFSET TO NEXT JQE
         B     NEXTJQE2            GET THE NEXT JQE
SKIPJQE  AP    QCOUNT,=P'1'        INCREMENT COUNT
         B     REJJQE              CONTINUE
         SPACE 1
*---     SEARCH A JOE QUEUE                                        ---*
         SPACE 1
SRCHJOE  ZAP   QCOUNT,=P'0'        ZERO THE QUEUE COUNT
FIRSTJOE L     R8,0(R4)            LOAD FIRST JOE OFFSET
         N     R8,=A(X'00FFFFFF')  END OF QUEUE?
         BZR   R2                  YES, RETURN TO CALLER
         XC    PRIORITY(12),PRIORITY    ZERO OUT HIGHEST POINTERS
NEXTJOE  N     R8,=A(X'00FFFFFF')  END OF QUEUE?
         BZ    TESTJOE             BRANCH IF END, RET HIGHEST
         AL    R8,QCJOTWA          ADD BASE TO OFFSET
         L     R9,JOEJQE           OFFSET TO JQE
         N     R9,=A(X'00FFFFFF')  ANY POINTER?
         BZ    TRYJOE              BRANCH IF THIS JOE ALREADY USED
         AL    R9,QCJQEWA          ADD BASE TO OFFSET
         LA    R7,255              PRESET MAXIMUM PRIORITY
         TM    JQEPRIO,240         IS THIS JOB PRIORITY 15?
         BO    HIGHJOE             YES, PASS TO CALLER
         LA    R1,16               PRESET PRIORITY ONE
         CLI   JQETYPE,$HARDCPY    IS THE JOB EXECUTING?
         BNE   *+L'*+4             YES, USE PRIORITY ONE
         IC    R1,JQEPRIO          INSERT JQE PRIORITY
         IC    R7,JOEPRIO          INSERT JOE PRIORITY
         AR    R7,R1               ADD PRIORITIES
         SRL   R7,1                'CUZ HASP DOES IT, THAT'S WHY
HIGHJOE  C     R7,PRIORITY         THIS LESS THAN PREVIOUS HIGH?
         BL    TRYJOE              YES, TRY NEXT ONE
         STM   R7,R9,PRIORITY      NO, REPLACE PREVIOUS HIGH
TRYJOE   L     R8,JOENEXT          ADDR OF NEXT JOE
         B     NEXTJOE             TRY NEXT JOE
TESTJOE  LM    R7,R9,PRIORITY      LOAD ADDR OF HIGHEST JOE
         LTR   R8,R8               WAS THE QUEUE EMPTY?
         BZR   R2                  YES, END OF QUEUE
         CLI   QSUBNAME,C'X'       IS THE REQUEST FOR A HEX DUMP?
         BNE   *+L'*+10            NO
         MVC   QPTRSV+13(3),JOEJQEB     SAVE INFO FOR DUMP
         OI    QDFREQ,QDFSV
         MVC   JOEJQEB,=XL3'00'    INDICATE THIS JOE USED
         B     4(R2)               DETERMINE ELIGIBILITY
PRTJOE   LA    R1,4                INDICATE THIS IS A JOE
         AP    QCOUNT,=P'1'        INCREMENT COUNT
         QCALL FORMAT              PRINT THE JOE IN R8
         B     FIRSTJOE            GET THE NEXT JOE
SKIPJOE  AP    QCOUNT,=P'1'        INCREMENT COUNT
         B     FIRSTJOE            CONTINUE
         SPACE 1
*---     DETERMINE INPUT QUEUE                                     ---*
         SPACE 1
FINDJQT  TR    QCLASS,CLASSTBL     DETERMINE OFFSET
         LH    R4,QCLASSH          LOAD TABLE OFFSET
         BCTR  R4,0                SUBTRACT 1
         STH   R4,QCLASSH          RESTORE VALUE
         B     NEXTJQT2            CONTINUE
NEXTJQT  TR    QCLASS,CLASSTBL     DETERMINE OFFSET FROM 1ST CLASS
         LH    R4,QCLASSH          LOAD TABLE OFFSET
         CH    R4,=H'36'           IS THIS THE LAST QUEUE?
         BNL   NEXTJQT9            YES, GO HOME
NEXTJQT2 TR    QCLASS,NAMETBL      MOVE CLASS NAME TO QCLASS
         SLL   R4,2                * 4
         USING JQTDSECT,R1         BASE REG FOR JQT
         L     R1,QCJQHEAD         @ JQE'S QUEUES HEADS
         LA    R4,JQTCLSA(R4)      NEXT QUEUE
         DROP  R1
         BR    R2                  RETURN TO CALLER
NEXTJQT9 CLI   QCODE,0             IS THIS A STATUS REQUEST?
         BE    ST5                 YES, GO TO STATUS
         CLI   QCODE,36            IS THIS A DJ REQUEST?
         BNE   SRCHSTOP            NO, GO HOME
         B     ST5                 YES, GO TO STATUS
         SPACE 1
*---     DETERMINE OUTPUT QUEUE                                    ---*
         SPACE 1
FINDJOT  TR    QCLASS,CLASSTBL     DETERMINE OFFSET
         LH    R4,QCLASSH          LOAD TABLE OFFSET
         SLL   R4,1                TO A-Z,0-9 CLASSES
         BCTR  R4,0                SUBTRACT 1
THISJOT  STH   R4,QCLASSH
         B     GETJOT
NEXTJOT  LA    R4,1
         AH    R4,QCLASSH
         STH   R4,QCLASSH
GETJOT   CH    R4,=Y(1+(2*36))     IS THIS THE LAST QUEUE?
         BNL   SRCHSTOP            YES, GO HOME
         LR    R1,R4               COPY QUEUE ID
         SLL   R1,1                OFFSET OF QUEUE CHAR FORM
         LA    R1,SR#TAB1(R1)      @ OF QUEUE ID
         MVC   QCLASSE,0(R1)       RETURN QUEUE ID IN CHAR TOO
         SLL   R4,2                * 4 FOR OFFSET
         USING JOT,R1              BASE REG FOR JOT
         L     R1,QCJOTWA          LOAD ADDR OF JOT
         LA    R4,JOTRDYWQ(R4)     NEXT QUEUE
         DROP  R1
         BR    R2                  RETURN TO CALLER
         SPACE 1
*---     GO HOME                                                   ---*
         SPACE 1
SRCHSTOP CLI   QCODE,8             IS THIS A DI REQUEST?
         BE    DITEU0              YES, GET TOTALS
         CLI   QCODE,48            IS THIS A QO REQUEST?
         BNE   SRCHEXIT            NO, GO HOME
         L     R1,TOTLNES
         LTR   R1,R1
         BZ    SRCHEXIT
         L     R7,QVDSPL           LOAD BASE REG
         USING QDISPLAY,R7         BASE REG FOR DISPLAY WORK AREA
         MVC   FCLEAR,QBLANK       CLEAR THE PRINT AREA
         $FS   SF=(PROT,INT),MF=(I,FCLEAR)
         MVC   FQUEUE(QOTEUL),QOTEUS    SET IN FINAL TOTAL MSG
         CVD   R1,FMT@CONV         CONVERT TOTAL IN DECIMAL
         ED    FQUEUE+L'QOTEUS(L'QOTEUN),FMT@CONV+3    EDIT IT
         $FS   SF=(PROT),MF=(I,QDMSG+L'QDMSG-2)   NORMAL INT, PROT
         OI    QDOVER,QTSKIP       NO TRANSLATE
         QCALL DISPLAY,QDMSG,80    DISPLAY THE LINE
         OI    QDOVER,QESKIP       NO END OF DATA LINE
         DROP  R7
         B     SRCHEXIT            GO HOME
DITEU0   L     R7,QVDSPL           LOAD BASE REG
         USING QDISPLAY,R7         BASE REG FOR DISPLAY WORK AREA
         CLC   QDHLINE,DIDUMMY     WAS ANYTHING WRITTEN?
         BE    SRCHEXIT            NO, SKIP
         MVC   FCLEAR,QBLANK       CLEAR THE PRINT AREA
         $FS   SF=(PROT,INT),MF=(I,FCLEAR)
         L     R1,TOTLNES
         CVD   R1,FMT@CONV
         MVC   FLINES+1,=XL6'402020202120'
         CP    FMT@CONV+5(3),=PL3'+99999'
         BNH   DITEU1
         MVI   FLINES+6,C'M'
         ED    FLINES+1(L'FLINES),FMT@CONV+4 TOTAL LINES IN M
         B     DITEU2
DITEU1   ED    FLINES+1(L'FLINES),FMT@CONV+5 TOTAL LINES IN K
DITEU2   LA    R15,DITEU4
         L     R1,TOTCPU
         CL    R1,=A(999*60*60)
         BNH   DITEU3
         MVC   FCPU+1(9),=CL9'> 999 HRS'
         BR    R15
DITEU3   BAS   R14,DITEUCVD        TOTAL CPU
         MVC   FCPU+1(9),=CL9'  0: 0: 0'
         MVC   FCPU+8(2),FIELD+2
         BAS   R14,DITEUCVD
         MVC   FCPU+5(2),FIELD+2
         LTR   R0,R1
         BNPR  R15
         BAS   R14,DITEUCVE
         MVC   FCPU+1(3),FIELD+1
         BR    R15
DITEUCVD LTR   R1,R1
         BNPR  R15
         C     R1,=F'60'
         BNL   DITEUCVR
         LR    R0,R1
         XR    R1,R1
         B     DITEUCVE
DITEUCVR XR    R0,R0
         D     R0,=F'60'
DITEUCVE CVD   R0,FMT@CONV
         MVC   FIELD(4),=XL4'40202120'
         ED    FIELD(4),FMT@CONV+6
         BR    R14
DITEU4   L     R1,TOTIO
         CVD   R1,FMT@CONV
         MVC   FIO+1,=XL6'402020202120'
         CP    FMT@CONV+5(3),=PL3'+99999'
         BNH   DITEU5
         MVI   FIO+6,C'M'
         ED    FIO+1(L'FIO),FMT@CONV+4  TOTAL I/O IN M
         B     DITEU6
DITEU5   ED    FIO+1(L'FIO),FMT@CONV+5  TOTAL I/O IN K
DITEU6   MVC   FCOUNT(8),=CL8'TOTALS :'
         $FS   SF=(PROT),MF=(I,QDMSG+L'QDMSG-2)   NORMAL INT, PROT
         OI    QDOVER,QTSKIP       NO TRANSLATE
         QCALL DISPLAY,QDMSG,80    DISPLAY THE LINE
         OI    QDOVER,QESKIP       NO END OF DATA LINE
         DROP  R7
SRCHEXIT QSTOP
         SPACE 1
*---     TABLES FOR CLASS DETERMINATION                            ---*
         SPACE 1
NAMETBL  DC    C'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
CLASSTBL DC    192X'01'
         DC    X'00010203040506070809',7X'00'
         DC    X'0A0B0C0D0E0F101112',8X'00'
         DC    X'131415161718191A',6X'00'
         DC    X'1B1C1D1E1F2021222324',6X'00'
         SPACE 1
*---     OUTPUT QUEUE NAMES (SEE $JOT)                             ---*
         SPACE 1
SR#TAB1  DC    C'NT'               NETWORK QUEUE
         DC    C'A A>B B>C C>D D>E E>F F>G G>H H>I I>J J>K K>L L>M M>'
         DC    C'N N>O O>P P>Q Q>R R>S S>T T>U U>V V>W W>X X>Y Y>Z Z>'
         DC    C'0 0>1 1>2 2>3 3>4 4>5 5>6 6>7 7>8 8>9 9>'
         SPACE 1
QIHEADER DC    CL79'QUEUE   #JOBS  EXECUTING  WAITING   HELD'
QOHEADER DC    CL79'QUEUE   #JOBS   PRINTING    LOCAL  REMOTE   RECS.'
QOTEUS   DC    C'TOTAL RECORDS IN QUEUES SELECTED :'
QOTEUN   DC    X'402020204B2020204B202120'
QOTEUL   EQU   *-QOTEUS
DIDUMMY  DC    CL79'    NO DATA IS AVAILABLE FOR YOUR REQUEST'
         SPACE 1
         LTORG
         SPACE 1
         DROP  R8,R9,R10,R11,R12
 TITLE '--- QUEUE/SP -- SYSLOG -- LIST THE SYSTEM LOG DATA-SET ---'
SYSLOG   QSTART
         USING QCKPT,R10           BASE REG FOR CKPT WORK AREA
         L     R10,QVCKPT          LOAD BASE REG
         CLI   QXAUTH,LV10         AUTHORIZED?
         BL    SL$TILTI            NO
         SPACE 1
*---     CALL FINDJOB TO LOCATE THE JQE, JCT, AND IOT              ---*
         SPACE 1
         QCALL FINDJOB             FIND THE JOB
         SPACE 1
*---     CHECK JOB NAME EQUAL SYSLOG                               ---*
         SPACE 1
         L     R9,QCJCTA           ADDR OF IOAREA FOR JCT
         USING JCTSTART,R9         BASE REG FOR JCT
         CLC   JCTJNAME,=CL8'SYSLOG'    IS THIS SYSLOG?
         BNE   SL$TILT             NO, TILT
         SPACE 1
*---     DETERMINE NUMBER OF DATA-SETS FROM CURRENT DATA-SET       ---*
         SPACE 1
         LH    R3,JCTPDDBK         HIGHEST DATA-SET ID NUMBER
         LH    R1,QLNG2            LENGTH OF BACKUP PARM
         SH    R1,=H'1'            IS THE BACKUP PARM ZERO LENGTH?
         BM    SL$CALST            YES, SKIP
         CLI   QPARM2,C'-'         IS THERE A MINUS SIGN?
         BNE   *+L'*+4             NO, SKIP
         MVI   QPARM2,C'0'         CHANGE MINUS TO ZERO
         LA    R15,QPARM2          POINT TO PARM
         BAS   R14,QNUMCONV        CONVERT IT
         BNE   SL$TILT             QUIT IF NOT NUMERIC
         SR    R3,R15              BACK UP NUMBER OF DATA-SETS
         CH    R3,=H'101'          IS THE NUMBER LESS THAN 101?
         BL    SL$TILT             YES, TILT
         SPACE 1
*---     CALL LISTDS TO LIST THE DATA-SET                          ---*
         SPACE 1
SL$CALST STH   R3,QPDSID           STORE DATA-SET ID
         MVC   QPOFFSET,=H'0'      PRINT OFFSET ZERO
         QCALL LISTDS
         QSTOP
SL$TILT  QTILT '*** INVALID PARAMETER ***'
SL$TILTI QTILT '=== NOT AVAILABLE TO YOU, SORRY ==='
         SPACE 1
         LTORG
         SPACE 1
         DROP  R9,R10,R11,R12
         TITLE '--- QUEUE/SP -- TSOCMD -- TSO COMMAND OR CLIST ---'
TSOCMD   QSTART
         L     R10,QVDSPL          @ DISPLAY WORK AREA
         USING QDISPLAY,R10
         NI    QTSSW,255-CLTSO-CLSTX-CLSTP
         CLI   QCODE,0             TSO COMMAND/CLIST EXECUTION?
         BE    TC$CMD              YES
         CLC   QPARM1(5),=CL5'FULL '    FULL DISPLAY REQUESTED?
         BE    TSOCMD3             YES
         CLC   QPARM1(3),=CL3'ON ' SET ACTIVE?
         BE    TSOCMD2             YES
         CLC   QPARM1(4),=CL4'OFF '     SET INACTIVE?
         BE    TSOCMD1             YES
         CLI   QPARM1,C' '         DEFAULT OFF?
         BE    TSOCMD1             YES
         QTILT '=== INVALID DISPLAY REQUEST (ON/OFF) ==='
TSOCMD1  NI    QTSSW,255-RCTSO-FLTSO    OFF TSO RC DISPLAY
         QTILT '=== TSO COMMANDS R.C. DISPLAY OFF ==='
TSOCMD2  OI    QTSSW,RCTSO         ON TSO RC DISPLAY
         NI    QTSSW,255-FLTSO     OFF FULL TSO RC DISPLAY
         QTILT '=== TSO COMMANDS R.C. DISPLAY ON ==='
TSOCMD3  OI    QTSSW,RCTSO+FLTSO   ON FULL TSO RC DISPLAY
         QTILT '=== FULL TSO COMMANDS R.C. DISPLAY ON ==='
TC$CMD   CLC   QPARM1,QBLANK       ANYTHING TO DO?
         BNE   TC$CTL              YES, GO CONTROL
         QTILT '*** MISSING TSO COMMAND ***'
TC$CTL   CLI   QPARM1,C'%'         CLIST EXECUTION?
         BNE   TC$CTLS             NO, GO SCAN
         MVC   QPARM1(L'QPARM1-1),QPARM1+1   SHIFT NAME
         MVI   QPARM1+L'QPARM1-1,C' '
         LH    R1,QOFF1            ADJUST OFFSET
         LA    R1,1(R1)
         STH   R1,QOFF1
         LH    R1,QLNG1            ADJUST LENGTH
         BCTR  R1,0
         STH   R1,QLNG1
         OI    QTSSW,CLTSO         INDICATE CLIST
         B     TC$CMD
TC$CTLS  TM    QTSSW,CLTSO         IS IT A CLIST?
         BO    TC$XEQ              YES
         LA    R1,TC#TCMD          SCAN RESERVED COMMAND
TC$LOOP  CLC   0(L'TC#TCMD,R1),QPARM1   MATCH?
         BE    TC$KILL             YES, REJECT IT
         BL    TC$XEQ              NO MORE FURTHER, PROCESS IT
         LA    R1,L'TC#TCMD(R1)    BUMP TO NEXT
         CLI   0(R1),X'FF'         END OF TABLE?
         BNE   TC$LOOP             NO, CONTINUE
         B     TC$XEQ              YES, PROCESS IT
TC$KILL  MVC   QDMSG(L'TC#KILLS),TC#KILLS
         LA    R2,QDMSG+L'TC#KILLS
         MVC   0(L'TC#TCMD,R2),0(R1)
         LA    R2,L'TC#TCMD-1(R2)
         CLI   0(R2),C' '
         BNE   *+L'*+4
         BCT   R2,*-8
         MVC   1(L'TC#KILLE,R2),TC#KILLE
         LA    R1,QDMSG
         LA    R0,L'TC#KILLS+L'TC#KILLE+8
         QTILT
TC$XEQ   L     R9,ATSOX            TSO WORK AREA ADDRESS
         LTR   R9,R9               ALREADY ACQUIRED?
         BNZ   TSOCMX              YES
         LA    R0,TSOXEQL          SIZE FOR GETMAIN REQUEST
         GETMAIN R,LV=(0)
         LR    R9,R1
         ST    R9,ATSOX            SAVE ADDRESS
         USING TSOXEQ,R9
         SPACE 1
*---     TELL VTAM WE'RE DONE                                      ---*
         SPACE 1
TSOCMX   TPUT  TC#CLEAR,TC#CLL,FULLSCR,,HOLD      CLEAR THE SCREEN
         STFSMODE  OFF
         SPACE 1
         MVC   GTPBK(GTPBLN),GTPBL CLEAR GETLINE LIST
         MVC   ATTCH(ATTLN),ATTCHL CLEAR ATTACH LIST
         LA    R6,GTPBK            GETLINE PARM BLOCK
         USING GTPB,R6
         L     R5,DAPLECT          POINT TO ECT
         USING ECT,R5
         MVC   TSOPCMD,ECTPCMD     SAVE PRIMARY COMMAND NAME
         MVC   TSOSCMD,ECTSCMD     AND SECONDARY COMMAND NAME
         LA    R4,TSOCPPL          ADDRESS OF CPPL FOR COMMAND
         USING CPPL,R4
         MVC   CPPLUPT,DAPLUPT     COPY UPT POINTER
         MVC   CPPLPSCB,DAPLPSCB   COPY PSCB POINTER
         MVC   CPPLECT,DAPLECT     COPY ECT POINTER
         LA    R1,TSOXCMD          ADDRESS OF COMMAND BUFFER
         USING CMDBUF,R1
         LH    R14,QDRLNG          COMPUTE TSO COMMAND LENGTH
         SH    R14,QOFF1
         AH    R14,=H'4'
         STH   R14,CMDLEN          STORE COMMAND BUFFER LENGTH
         LA    R15,QDREPLY         COMPUTE TSO COMMAND ADDRESS
         AH    R15,QOFF1
         LA    R14,QDREPLYL        COMPUTE MOVE LENGTH
         SH    R14,QOFF1
         B     *+L'*+6
         MVC   CMDTEXT(*-*),0(R15) <<EXECUTED>>
         EX    R14,*-6             MOVE TSO COMMAND IN BUFFER
TSOSCAN  XC    CMDOFF,CMDOFF       CLEAR OFFSET TO SECOND OPERAND
         DROP  R1
         ST    R1,CPPLCBUF         SET BUFFER CB POINTER
         LA    R1,TSOCSPL          ADDRESS OF IKJSCAN PARM LIST
         USING CSPL,R1
         MVC   CSPLUPT,DAPLUPT     COPY UPT POINTER
         MVC   CSPLECT,DAPLECT     COPY ECT POINTER
         LA    R15,TSOXECB         ADDRESSS OF ECB
         ST    R15,CSPLECB
         XC    TSOXECB,TSOXECB     CLEAR ECB
         LA    R15,TSOXTCB         ADDRESSS OF FLAGS
         ST    R15,CSPLFLG
         XC    TSOXTCB,TSOXTCB     CLEAR FLAGS
         LA    R15,TSOCSOA         ADDRESSS OF OUTPUT AREA
         ST    R15,CSPLOA
         XC    TSOCSOA(8),TSOCSOA  CLEAR OUTPUT AREA
         MVC   CSPLCBUF,CPPLCBUF   COPY COMMAND BUFFER POINTER
         DROP  R1
         CALLTSSR EP=IKJSCAN       SCAN INPUT BUFFER
         XC    TSOXECB,TSOXECB     CLEAR ECB
         LA    R1,TSOCSOA          POINT TO OUTPUT AREA
         USING CSOA,R1
         L     R14,CSOACNM         POINTER TO COMMAND NAME
         ICM   R15,B'0011',CSOALNM LENGTH OF NAME
         BZ    TSONCMD             NONE, SKIP REST
         TM    CSOAFLG,CSOAQM+CSOANOC   Q.M. OR NO CMD?
         BNZ   TSONCMD             YES, SKIP REST
         BCTR  R15,0
         MVC   TSOBLNM,QBLANK      FILL WITH BLANKS
         B     *+L'*+6
         MVC   TSOBLNM(*-*),0(R14) <<EXECUTED>>
         EX    R15,*-6             MOVE COMMAND TO BLDL NAME
         TM    CSOAFLG,CSOABAD     BAD CMD NAME?
         BZ    TSOTX               NO
         ICM   R0,B'0111',=CL3'BAD'
         B     TSODIAG
TSOTX    CLC   TSOBLNM(2),=CL2'EX' EXEC COMMAND?
         BNE   TSOTVLD             NO
         TM    CSOAFLG,CSOAEXEC    IMPLICIT EXEC CMD NAME?
         BZ    TSOINVC             NO, INVALID
TSOTVLD  TM    CSOAFLG,CSOAVWP+CSOAVNP  VALID COMMAND?
         BNZ   TSOGCMD             YES
         DROP  R1
TSOINVC  ICM   R0,B'0111',=CL3'INV'
TSODIAG  MVC   TSOMSG(L'TC#DG),TC#DG    SEND DIAGNOSE
         STCM  R0,B'0111',TSOMSG+TC#DGER
         MVC   TSOMSG+L'TC#DG(L'TSOMSG-L'TC#DG),QBLANK
         L     R1,CPPLCBUF         POINT TO BUFFER
         USING CMDBUF,R1
         LH    R15,CMDLEN          LENGTH
         SH    R15,=H'4'
         CH    R15,=Y(L'TSOMSG-L'TC#DG)
         BNH   *+L'*+4
         LH    R15,=Y(L'TSOMSG-L'TC#DG)
         BCT   R15,*+L'*+6
         MVC   TSOMSG+L'TC#DG(*-*),CMDTEXT   <<EXECUTED>>
         EX    R15,*-6
         DROP  R1
         CLC   TSOMSG+L'TSOMSG-5(5),=CL5' '
         BE    *+L'*+6
         MVC   TSOMSG+L'TSOMSG-5(5),=CL5' ... '
         LA    R1,TSOMSG
         LA    R0,L'TSOMSG
         TPUT  (1),(0),R           ISSUE MESSAGE
         B     TSONCMD             SKIP REST
TSOGCMD  TM    QTSSW,FLTSO         FULL DISPLAY REQUESTED?
         BZ    TSOISPF             NO
         MVC   TSOMSG(L'TC#MSGH),TC#MSGH     SEND COMMAND IMAGE
         MVC   TSOMSG+16(6),=CL6'BUFFER'
         MVC   TSOMSG+L'TC#MSGH(L'TSOMSG-L'TC#MSGH),QBLANK
         L     R1,CPPLCBUF         POINT TO BUFFER
         USING CMDBUF,R1
         LH    R15,CMDLEN          LENGTH
         SH    R15,=H'4'
         CH    R15,=Y(L'TSOMSG-L'TC#MSGH)
         BNH   *+L'*+4
         LH    R15,=Y(L'TSOMSG-L'TC#MSGH)
         BCT   R15,*+L'*+6
         MVC   TSOMSG+L'TC#MSGH(*-*),CMDTEXT <<EXECUTED>>
         EX    R15,*-6
         DROP  R1
         CLC   TSOMSG+L'TSOMSG-5(5),=CL5' '
         BE    *+L'*+6
         MVC   TSOMSG+L'TSOMSG-5(5),=CL5' ... '
         LA    R1,TSOMSG
         LA    R0,L'TSOMSG
         TPUT  (1),(0),R           ISSUE MESSAGE
         SPACE 1
*---     WHEN RUNNING UNDER ISPF, THE FIRST TIME AN 'END' OR
*---     'TSO END' (QED) CLIST'S FINAL COMMAND IS ENCOUNTERED,
*---     IT WILL BE INTERCEPTED, AND TWO ADDITIONAL COMMANDS
*---     ('TERMINAL ...' AND 'ISPEXEC ...') ARE PLACED IN THE
*---     INTERNAL STACK. HERE WE SUPPRESS ALL 'END' OR 'TSO END'
*---     COMMANDS WITHOUT ANY TROUBLES FOR THE CLIST EXECUTION,
*---     BUT SO ELIMINATE UNDESIRABLE FAILURE MESSAGES.
*---     NOTE - THIS DOES'NT ALLOW ISPF COMMANDS RUN, IN FACT,
*---            AS SOON AS ONE IS DETECTED THE COMMAND (AND
*---            CLIST) IS ABORTED, UNLESS IT IS A VGET/VPUT, IN
*---            WHICH CASE THE COMMAND IS SKIPPED (GET A CHANCE
*---            TO TRY ISPF PROCEDURE CONTINUE, BECAUSE IT MAY
*---            BE JUST TO OBTAIN PANELS VALUES AND THUS WILL
*---            NOT DISTURB THE TSO PROCEDURE NORMAL EXECUTION).
         SPACE 1
TSOISPF  L     R1,CPPLCBUF         POINT TO BUFFER
         USING CMDBUF,R1
         LA    R15,CMDTEXT         POINT TO COMMAND TEXT
         LH    R14,CMDLEN          LENGTH
         SH    R14,=H'4'
         LA    R14,CMDTEXT-1(R14)  POINT TO COMMAND TEXT END
         DROP  R1
TSOISPF1 CLI   0(R15),C' '         ANALYZE
         BNE   TSOISPF2
         LA    R15,1(R15)
         B     TSOISPF1
TSOISPF2 CLC   0(4,R15),=CL4'END ' END COMMAND?
         BE    TSONCMD             YES, SKIP IT
         CLC   0(4,R15),=CL4'TSO ' TSO COMMAND (QED FORM)?
         BNE   TSOISPF3            NO
         LA    R15,4(R15)
         B     TSOISPF1
TSOISPF3 CLC   0(3,R15),=CL3'ISP'  ISPF FUNCTION?
         BNE   TSOANAL             NO
         CLC   0(8,R15),=CL8'ISPEXEC '  IS IT ISPEXEC?
         BNE   TSOISPF6            NO
         LA    R15,8(R15)
TSOISPF4 CLI   0(R15),C' '         LOOK FURTHER
         BNE   TSOISPF5
         CLR   R15,R14
         BNL   TSOISPF6
         LA    R15,1(R15)
         B     TSOISPF4
TSOISPF5 CLC   0(5,R15),=CL5'VGET '     IS IT VGET?
         BE    TSONCMD             YES, TRY TO CONTINUE (SKIP IT)
         CLC   0(5,R15),=CL5'VPUT '     IS IT VPUT?
         BE    TSONCMD             YES, TRY TO CONTINUE (SKIP IT)
TSOISPF6 LA    R1,TC#ISPF
         LA    R0,L'TC#ISPF
         TPUT  (1),(0),R           ISSUE MESSAGE
         OI    QTSSW,CLSTP         STOP PROCESSING
         B     TSONCMD             SKIP REST
         SPACE 1
TSOANAL  TM    QTSSW,CLTSO         IS IT A CLIST?
         BO    TSOCLST             YES
         CLC   TSOBLNM(2),=CL2'EX' IMPLICIT EXEC OF CLIST?
         BNE   TSONEX              NO
TSOCLST  NI    QTSSW,255-CLTSO
TSOSEX   OI    QTSSW,CLSTX         CLIST IN EXECUTION
         MVC   TSOBLNM,=CL8'EXEC'  SET MODULE NAME TO ATTACH
         L     R1,CPPLCBUF         POINT TO BUFFER
         USING CMDBUF,R1
         XC    CMDOFF,CMDOFF       CLEAR OFFSET FOR EXEC
         B     TSOATTCH            GO DO IT
         DROP  R1
TSONEX   MVC   TSOBLFF,=H'1'       ONE ENTRY IN LIST
         MVC   TSOBLLL,=H'12'      12 BYTES TO BE RETURNED
         XC    TSOBLTTR(L'TSOBLTTR+L'TSOBLLK),TSOBLTTR CLEAR REST
         BLDL  0,TSOBLDL           CHECK FOR MODULE PRESENT
         LTR   R15,R15             CHECK RETURN CODE
         BNZ   TSOSEX              NONE, MUST BE CLIST
TSOATTCH XC    TSOXECB,TSOXECB     CLEAR ECB
         MVC   ECTPCMD,TSOBLNM     FAKE PRIMARY COMMAND NAME
         MVC   ECTSCMD,QBLANK      AND SECONDARY COMMAND NAME
         LA    R1,TSOCPPL          ADDRESS OF CPPL
         LA    R2,TSOXECB          ADDRESSS OF ECB
         LA    R3,TSOBLNM          ADDRESSS OF COMMAND NAME
         LA    R15,ATTCH           ADDRESSS OF ATTACH BLOCK
         ATTACH EPLOC=(R3),ECB=(R2),SF=(E,(15)),MF=(E,(1))
         ST    R1,TSOXTCB          SAVE TCB ADDRESS
         WAIT  ECB=(R2)            WAIT FOR SUBTASK COMPLETION
         LA    R1,TSOXTCB          GET TCB ADDRESS
         DETACH (1)
         OC    TSOXECB+1(3),TSOXECB+1   ANY COMPLETION CODE?
         BZ    TSONCMD             NO
         TM    QTSSW,RCTSO         DISPLAY RC REQUESTED?
         BZ    TSONCMD             NO
         MVC   TSOMSG(L'TC#MSG),TC#MSG  SEND COMPLETION MESSAGE
         MVC   TSOMSG+25(8),TSOBLNM     GET COMMAND NAME
         UNPK  QNUMWORK(5),TSOXECB+1(3) GET SYSTEM CODE
         TR    QNUMWORK(3),HEXTAB-C'0'
         MVC   TSOMSG+36(3),QNUMWORK
         NI    TSOXECB+2,X'0F'     GET USER CODE
         LH    R1,TSOXECB+2
         CVD   R1,QNUMWORK
         UNPK  TSOMSG+41(4),QNUMWORK+5(3)
         OI    TSOMSG+44,C'0'
         LA    R1,TSOMSG
         LA    R0,L'TC#MSG
         TPUT  (1),(0),R           ISSUE MESSAGE
TSONCMD  TM    QTSSW,CLSTX         CLIST IN EXECUTION?
         BZ    TSODONE             NO, DONE
         ICM   R1,B'1111',GTPBIBUF GETLINE BUFFER?
         BZ    TSOGSTK             NO, SKIP
         USING CMDBUF,R1
         LH    R0,CMDLEN           LENGTH OF BUFFER
         DROP  R1
         ICM   R0,B'1000',=AL1(1)  SUBPOOL 1
         FREEMAIN R,LV=(0),A=(1)   FREE THE BUFFER
TSOGSTK  XC    TSOXECB,TSOXECB     CLEAR ECB
         LA    R1,TSOIOPL          GETLINE I/O PARM LIST
         L     R2,CPPLUPT          ADDRESS OF UPT
         LA    R3,TSOXECB          ADDRESSS OF ECB
         GETLINE PARM=(R6),UPT=(R2),ECT=(R5),ECB=(R3),MF=(E,(1))
         CH    R15,=H'16'          END OF INPUT (STACK-CLIST)?
         BE    TSODONE             YES, DONE
         TM    QXSWXQ,RQTR         TRACE REQUESTED?
         BZ    TSOSKIP             NO
         OI    QXSWXQ,NFTR+MSTR
         XC    TSORSV(2*4),TSORSV
         QCALL TRACE,2             SNAP. USER CODE 002. -------- ID-002
         BZ    *+L'*+4
         STM   R0,R1,TSORSV
         NI    QXSWXQ,255-NFTR-MSTR
TSOSKIP  TM    QTSSW,CLSTP         PROCESS STOP?
         BO    TSONCMD             YES, GO SKIP
         L     R1,GTPBIBUF         POINT TO INPUT BUFFER
         B     TSOSCAN             GO PROCESS NEXT
TSODONE  MVC   ECTPCMD,TSOPCMD     RESTORE PRIMARY COMMAND NAME
         MVC   ECTSCMD,TSOSCMD     AND SECONDARY COMMAND NAME
         DROP  R4,R5,R6
         SPACE 1
*---     TELL VTAM WE'RE BACK                                      ---*
         SPACE 1
         STFSMODE  ON
         OC    TSORSV(2*4),TSORSV  ANY MESSAGE PENDING?
         BNZ   TSOSMSG             YES
         QTILT '=== DONE ==='
TSOSMSG  LM    R0,R1,TSORSV
         XC    TSORSV(2*4),TSORSV
         QTILT
         SPACE 1
GTPBL    GETLINE MF=L
ATTCHL   ATTACH  SHSPV=78,SF=L     NEEDED TO PREVENT S305 ABENDS
         SPACE 1
TC#CLEAR $FS   WCC=(RMDT),SBA=(24,79),MF=L
         $FS   SBA=(1,1),RA=(1,1,00),MF=L
         $FS   SF=IC,MF=L
TC#CLL   EQU   *-TC#CLEAR
TC#MSG   DC    C'   ---> COMMAND FAILED :          (S   /U    ).'
TC#MSGH  EQU   TC#MSG,25
TC#DG    DC    C'   ===>     COMMAND : '
TC#DGER  EQU   8
TC#KILLS DC    C'COMMAND REJECTED - "'
TC#KILLE DC    C'" COMMAND NOT ACCEPTED UNDER QSP.        '
TC#ISPF  DC    C'SORRY, ISPF NOT SUPPORTED - IMMEDIATE STOP.'
TC#TCMD  DS    0CL8                MUST BE IN ALPHABETICAL ORDER
         DC    CL8'ACCOUNT'
         DC    CL8'AUTHC'
         DC    CL8'CALL'
         DC    CL8'E'
         DC    CL8'EDIT'
         DC    CL8'ISPF'
         DC    CL8'OPER'
         DC    CL8'PDF'
         DC    CL8'POF'
         DC    CL8'PUSE'
         DC    CL8'QED'
         DC    CL8'QSP'
         DC    CL8'SCHED'
         DC    CL8'SCHEDULE'
         DC    CL8'TEST'
         DC    CL8'TIME'
         DC    CL8'VCOREZAP'
         DC    CL8'VSM'
         DC    CL8'ZAP'
         DC    XL1'FF'             END OF TABLE INDICATOR
         SPACE 1
         LTORG
         SPACE 1
         DROP  R9,R10,R11,R12
         TITLE '--- QUEUE/SP -- XQ -- DISPLAY ALL JQES QUEUES ---'
XQCMD    QSTART
         CLI   QPARM1,C' '         SPECIFIC REQUEST?
         BE    XQ$QL0              NO
         CLI   QPARM1,C'0'         IS FIRST CHARACTER NUMERIC?
         BL    XQ$QF0              NO, ASSUME JOB NAME
         LH    R1,QLNG1            LENGTH OF PARAMETER FIELD
         SH    R1,=H'1'            IS THE LENGTH ZERO?
         BM    XQ$TILT1            YES, TILT
         LA    R15,QPARM1          POINT TO PARM
         BAS   R14,QNUMCONV        CONVERT IT
         BNE   XQ$TILT2            TILT IF NOT NUMERIC
         LR    R6,R15              SAVE THE VALUE
         B     XQ$QF0
XQ$TILT1 QTILT '*** MISSING JOB NUMBER ***'
XQ$TILT2 QTILT '*** INVALID JOB NUMBER ***'
XQ$QL0   L     R1,QVDSPL           @ DISPLAY WORK AREA
         USING QDISPLAY,R1
         MVC   QDHLINE,XQHEAD
         DROP  R1
XQ$QF0   L     R3,QCJQHEAD         @ JQE'S QUEUES HEADS
         LA    R2,$JQTYPES         # OF JQE QUEUE HEADS
XQ$QL1   LR    R4,R3               COPY @ CURRENT QUEUE HEAD
         SH    R4,=Y(JQENEXT-JQE)  MAKE LOOK LIKE JQE
         XR    R5,R5               INIT QUEUE POSITION ZERO
XQ$QL2   BAS   R14,NXT$JQE         TO NEXT JQE
         BZ    XQ$NQ               BRANCH IF NO NEXT JQE
         USING JQE,R4
         CLI   QPARM1,C' '         SPECIFIC REQUEST?
         BE    XQ$QL3              NO
         CLI   QPARM1,C'0'         IS FIRST CHARACTER NUMERIC?
         BL    XQ$QF1              NO, ASSUME JOB NAME
         CH    R6,JQEJOBNO         IS THIS THE RIGHT JOB NUMBER?
         B     XQ$QF1+L'XQ$QF1
XQ$QF1   CLC   QPARM1(8),JQEJNAME  IS THE JOB NAME EQUAL?
         BNE   XQ$QL2              NO, SKIP THIS
         XR    R1,R1               INDICATE THIS IS A JQE
         LR    R9,R4               SET R9
         QCALL FORMAT              PRINT THE JQE IN R9
         B     XQ$QL2
XQ$QL3   MVC   XQLINE,QBLANK
         CVD   R5,XQDWD
         MVC   XQLINE(4),=XL4'40202120'
         ED    XQLINE(4),XQDWD+6
         BAS   R14,CVQP$
         STCM  R1,15,XQLINE+6
         ST    R0,XQDWD
         MVI   XQDWD+4,X'04'
         UNPK  XQLINE+30(9),XQDWD(5)
         TR    XQLINE+30(8),HEXTAB-X'F0'
         MVC   XQLINE+13(8),JQEJNAME
         LH    R0,JQEJOBNO
         CVD   R0,XQDWD
         MVC   XQLINE+22(6),=XL6'402020202120'
         ED    XQLINE+22(6),XQDWD+5
         DROP  R4                  (JQE DSECT)
         QCALL DISPLAY,XQLINE,L'XQLINE
         B     XQ$QL2
XQ$NQ    LA    R3,4(,R3)           @ NEXT JQE QUEUE HEAD
         BCT   R2,XQ$QL1           BRANCH IF MORE QUEUES TO DO
         QSTOP
         SPACE 1
*---------------------------------------------------------------------*
*                                                                     *
*        NXT$JQE - CONTINUE 'JQENEXT' SEARCH                          *
*                                                                     *
*        ENTRY : R4  - @ PREVIOUS JQE (ONLY JQENEXT FIELD IS VALID)   *
*                R5  - JQE CHAIN POSITION                             *
*                R14 - RETURN ADDRESS                                 *
*                                                                     *
*        EXIT : CONDITION CODE SET -  0 - NO MORE JQE'S EXIST         *
*                                         (R4 = 0)                    *
*                                    0 - R4 = @ JQE                  *
*                                         (R5 INCREMENTED)            *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
         USING JQE,R4
NXT$JQE  L     R4,JQENEXT          VALUE FROM JQENEXT
         N     R4,=A(X'00FFFFFF')  IS ZERO IF NO NEXT JQE
         BZR   R14                 BRANCH IF NO NEXT JQE, CC 0, R4 = 0
         AL    R4,QCJQEWA          ADD BASE TO OFFSET
         LA    R5,1(,R5)           INCREMENT QUEUE POSITION
         BR    R14                 BRANCH IF JQE, CC 0, R4 = @ JQE
         DROP  R4
         SPACE 1
*---------------------------------------------------------------------*
*                                                                     *
*        CVQP$ - CONVERT JQEHEAD ADDRESS TO CHARACTER QUEUE ID        *
*                                                                     *
*        ENTRY : R3  - @ JQE QUEUE HEAD (IN MASTER RECORD)            *
*                R14 - RETURN ADDRESS                                 *
*                                                                     *
*        EXIT :  R0  - $QINDEX                                        *
*                R1  - 4 CHARACTER QUEUE ID                           *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
CVQP$    LA    R1,$JQHEADL(,R3)    OFFSET FOR $QINDEX
         S     R1,QCJQHEAD         SIMILAR LOOK UP
         LR    R0,R1               SET $QINDEX VALUE TO RETURN IT
         CH    R1,=Y(44)           SPECIAL QUEUE? (< QUEUE 'A')
         BL    CVQP$2              BRANCH IF SPECIAL ID
         SRL   R1,2                QUEUE HEAD NUMBER
         IC    R1,CVQP#TB1-(44/4)(R1)   GET QUEUE ID
         SLL   R1,24               ALIGN QUEUE ID
         ICM   R1,B'0111',QBLANK   AND BLANK REST
         BR    R14
CVQP$2   L     R1,CVQP#TB2(R1)     GET SPECIAL ID
         BR    R14                 BRANCH IF WITH ID
         SPACE 1
*        NOTE - SEE $QINDEX IN HASPTABS FOR MORE DETAILS.
         SPACE 1
XQHEAD   DC    CL79' POS  QUEUE  JNAME     JOBNO  $QINDEX  '
         SPACE 1
CVQP#TB1 DC    0F'0',64AL1(0)      DEFAULT ALL UNKNOWN
         ORG   CVQP#TB1
         DC    C'ABCDEFGHI'             A - I
         DC    C'JKLMNOPQR'             J - R
         DC    C'STUVWXYZ'              S - Z
         DC    C'0123456789'            0 - 9
         ORG
         SPACE 1
CVQP#TB2 DC    0F'0'
         DC    CL4'FREE'            0 - FREE
         DC    CL4'PURG'            1 - PURGE
         DC    CL4'HCPY'            2 - HARDCPY
         DC    CL4'OUT '            3 - OUTPUT
         DC    CL4'REC '            4 - RECEIVE
         DC    CL4'SETU'            5 - SETUP
         DC    CL4'XMIT'            6 - XMIT
         DC    CL4'IN  '            7 - INPUT
         DC    CL4'XEQ '            8 - XEQ
         DC    CL4'STC '            9 - STC
         DC    CL4'TSU '           10 - TSU
         SPACE 1
         LTORG
         SPACE 1
         DROP  R11,R12
         TITLE '--- QUEUE/SP -- XO -- DISPLAY/DUMP JOES ---'
XOCMD    QSTART
         USING JOE,R8
         USING JQE,R9
         CLI   QPARM1,C'0'         IS FIRST CHARACTER NUMERIC?
         BL    XO$QL0              NO, ASSUME JOB NAME
         LH    R1,QLNG1            LENGTH OF PARAMETER FIELD
         SH    R1,=H'1'            IS THE LENGTH ZERO?
         BM    XO$TILT1            YES, TILT
         LA    R15,QPARM1          POINT TO PARM
         BAS   R14,QNUMCONV        CONVERT IT
         BNE   XO$TILT2            TILT IF NOT NUMERIC
         LR    R5,R15              SAVE THE VALUE
         B     XO$QL1
XO$QL0   CLI   QPARM1,C' '         DID USER SPECIFY JOB NAME?
         BNE   XO$QL1              YES
         QTILT '*** YOU MUST SPECIFY JOB NAME ***'
XO$TILT1 QTILT '*** MISSING JOB NUMBER ***'
XO$TILT2 QTILT '*** INVALID JOB NUMBER ***'
XO$QL1   BAS   R2,XO$TJOT          SEARCH ALL OUTPUT CLASSES
         B     XO$QL3
XO$QL2   BAS   R2,XO$NJOT          DETERMINE NEXT QUEUE
XO$QL3   BAS   R2,XO$SJOE          SEARCH A JOE QUEUE
         B     XO$QL2              END OF QUEUE
         CLI   QPARM1,C'0'         IS FIRST CHARACTER NUMERIC?
         BL    *+L'*+8             NO
         CH    R5,JQEJOBNO         IS THIS THE RIGHT JOB NUMBER?
         B     *+L'*+6
         CLC   QPARM1(8),JQEJNAME  IS THE JOB NAME EQUAL?
         BNE   XO$KJOE             NO, SKIP THIS RECORD
         B     XO$PJOE             PRINT THE RECORD
XO$STOP  QSTOP
         SPACE 1
*---     DETERMINE OUTPUT QUEUE                                    ---*
         SPACE 1
XO$TJOT  XR    R4,R4               SEARCH ALL OUTPUT CLASSES
         STH   R4,QCLASSH
         B     XO$CJOT
XO$NJOT  LA    R4,1
         AH    R4,QCLASSH
         STH   R4,QCLASSH
XO$CJOT  CH    R4,=Y(1+(2*36))     IS THIS THE LAST QUEUE?
         BNL   XO$STOP             YES, GO HOME
         SLL   R4,2                * 4 FOR OFFSET
         USING JOT,R1              BASE REG FOR JOT
         L     R1,QCJOTWA          LOAD ADDR OF JOT
         LA    R4,JOTRDYWQ(R4)     NEXT QUEUE
         DROP  R1
         BR    R2                  RETURN TO CALLER
         SPACE 1
*---     SEARCH A JOE QUEUE                                        ---*
         SPACE 1
XO$SJOE  L     R8,0(R4)            LOAD FIRST JOE OFFSET
XO$NJOE  N     R8,=A(X'00FFFFFF')  END OF QUEUE?
         BZR   R2                  YES, RETURN TO CALLER
         AL    R8,QCJOTWA          ADD BASE TO OFFSET
         L     R9,JOEJQE           OFFSET TO JQE
         N     R9,=A(X'00FFFFFF')  ANY POINTER?
         BZ    XO$KJOE             BRANCH IF NO JQE
         AL    R9,QCJQEWA          ADD BASE TO OFFSET
         B     4(R2)               DETERMINE ELIGIBILITY
XO$PJOE  LA    R1,4                INDICATE THIS IS A JOE
         QCALL FORMAT              PRINT THE JOE IN R8
XO$KJOE  L     R8,JOENEXT          ADDR OF NEXT JOE
         B     XO$NJOE             TRY NEXT JOE
         SPACE 1
         LTORG
         SPACE 1
         DROP  R8,R9,R11,R12
         TITLE '--- QUEUE/SP -- AUTOM -- AUTOMATIC MODE CONTROL ---'
AUTOM    QSTART
         L     R10,QVDSPL          @ DISPLAY WORK AREA
         USING QDISPLAY,R10
         L     R9,QVSNAP           @ SNAP WORK AREA
         USING QSNAP,R9
         CLI   QXAUTH,LV12         IS THIS AN AUTHORIZED USER?
         BNL   AUTEST              YES, PROCESS IT
         QTILT '=== NOT AVAILABLE TO YOU, SORRY ==='
AUTEST   TM    QDOVER,QDAMAGE      DAMAGED CLOCKS?
         BZ    AUTRT               NO
         NI    SNAPIDT,B'10111111' OFF TRACE ID 1
         OC    SNAPIDT,SNAPIDT     ANY OTHER ONE ACTIVE?
         BNZ   *+L'*+4             YES
         NI    QXSWXQ,255-RQTR     OFF TRACE REQUEST
         CLC   QPARM1(6),=CL6'SRMCC'    SRM CC ERROR?
         BE    AUTSRM              YES
         QTILT '=== DISABLED FOR DAMAGED CLOCKS ==='
AUTSRM   MVC   QDMSG(L'AUT$SRM),AUT$SRM
         MVC   QDMSG+L'AUT$SRM-6(1),QPARM1+6
         LA    R1,QDMSG
         LA    R0,L'AUT$SRM
         QTILT
AUTRT    CLI   QCODE,0             SET MODE ON REQUEST?
         BE    AUTON               YES
         NI    QDOVER,255-QAUTOM   OFF AUTOMATIC MODE
         NI    SNAPIDT,B'10111111' OFF TRACE ID 1
         OC    SNAPIDT,SNAPIDT     ANY OTHER ONE ACTIVE?
         BNZ   *+L'*+4             YES
         NI    QXSWXQ,255-RQTR     OFF TRACE REQUEST
         QTILT '=== AUTOMATIC MODE OFF ==='
AUTON    LH    R1,QLNG1            LENGTH OF PARAMETER FIELD
         SH    R1,=H'1'            IS THE LENGTH ZERO?
         BM    AUTDEF              YES, SET DEFAULT
         LA    R15,QPARM1          POINT TO PARM
         BAS   R14,QNUMCONV        CONVERT IT
         BNE   AUDBGT              MAY BE BEBUG IF NOT NUMERIC
         C     R15,=A(5*60)        MORE THAN 5 MINUTES?
         BH    AUTILT              YES, TOO MUCH
         MH    R15,=H'100'
         B     AUTSET
AUDBGT   CLI   QPARM1,C'T'         IS TEST MODE REQUEST?
         BNE   AUTILT              TILT IF NOT
         CLI   QXAUTH,LV15         IS THIS AN AUTHORIZED USER?
         BL    AUTDEF              NO, BYPASS TRACE
         TM    QXSWXQ,SKTR         TRACE FILE IN ERROR?
         BO    AUTDEF              IGNORE
         OI    SNAPIDT,B'01000000' ON TRACE ID 1
         OI    QXSWXQ,RQTR         ON TRACE
         B     AUTDEF              AND SET DEFAULT
AUTILT   QTILT '*** INVALID INTERVAL TIME ***'
AUTDEF   L     R15,=A(TDFLT)       SET DEFAULT
AUTSET   ST    R15,TIMECT
         LH    R1,QLNG2            LENGTH OF PARAMETER FIELD
         SH    R1,=H'1'            IS THE LENGTH ZERO?
         BM    AUTOK               YES, SKIP
         CLI   QPARM2,C'T'         IS TEST MODE REQUEST?
         BNE   AUTOK               IGNORE IF NOT
         CLI   QXAUTH,LV15         IS THIS AN AUTHORIZED USER?
         BL    AUTOK               NO, BYPASS TRACE
         TM    QXSWXQ,SKTR         TRACE FILE IN ERROR?
         BO    AUTOK               IGNORE
         OI    SNAPIDT,B'01000000' ON TRACE ID 1
         OI    QXSWXQ,RQTR         ON TRACE
AUTOK    OI    QDOVER,QAUTOM       ON AUTOMATIC MODE
         QTILT '=== AUTOMATIC MODE ON ==='
AUT$SRM  DC    C'=== DISABLED FOR SRM CC (ERROR  ) ==='
         SPACE 1
         LTORG
         SPACE 1
         DROP  R9,R10,R11,R12
         TITLE '--- QUEUE/SP -- SETTR -- TRACE FACILITIES ---'
SETTR    QSTART
         L     R10,QVDSPL          @ DISPLAY WORK AREA
         USING QDISPLAY,R10
         L     R9,QVSNAP           @ SNAP WORK AREA
         USING QSNAP,R9
         CLI   QXAUTH,LV12         IS THIS AN AUTHORIZED USER?
         BNL   SETTR1              YES, PROCESS IT
SETTR0   QTILT '=== NOT AVAILABLE TO YOU, SORRY ==='
SETTR1   CLI   QPARM1,C'I'         INITIALIZE TRACE STATUS?
         BE    SETTR20             YES
         TM    QXSWXQ,SKTR         TRACE FILE IN ERROR?
         BO    SETTR10             YES
         CLI   QPARM1,C'S'         STOP ALL ID'S REQUEST?
         BNE   SETTR2              NO
         XC    SNAPIDT,SNAPIDT     RESET ALL
         NI    QXSWXQ,255-RQTR     OFF TRACE REQUEST
         QTILT '=== ALL TRACE ID''S OFF ==='
SETTR2   LH    R1,QLNG1            LENGTH OF PARAMETER FIELD
         SH    R1,=H'1'            IS THE LENGTH ZERO?
         BM    SETTR4              YES, SET DEFAULT
         LA    R15,QPARM1          POINT TO PARM
         BAS   R14,QNUMCONV        CONVERT IT
         BNE   SETTR3              NOT NUMERIC
         CH    R15,=H'1'           VALID ID-NUMBER?
         BL    SETTR3              NO
         CH    R15,=H'255'
         BNH   SETTR5              NO
SETTR3   QTILT '=== INVALID TRACE ID-NUMBER ==='
SETTR4   LH    R15,=H'1'           SET DEFAULT ID=1
SETTR5   XR    R14,R14
         SLDL  R14,24
         SRL   R15,24
         LA    R2,SNAPIDT
         ALR   R2,R14
         LA    R3,X'80'
         SRL   R3,0(R15)
         XR    R4,R4
         BCTR  R4,0
         XR    R4,R3
         CLC   QPARM2(3),=CL3'ON ' SET ACTIVE?
         BNE   SETTR6              NO
         EX    R3,SETTRS           YES, SET IT
         OI    QXSWXQ,RQTR         ON TRACE
         QTILT '=== REQUESTED TRACE ID ON ==='
SETTRS   OI    0(R2),*-*           <<EXECUTED>>
SETTR6   CLI   QPARM2,C' '         DEFAULT OFF?
         BE    SETTR7              YES
         CLC   QPARM2(4),=CL4'OFF '     SET INACTIVE?
         BNE   SETTR8              NO
SETTR7   EX    R4,SETTRC           YES, RESET IT
         OC    SNAPIDT,SNAPIDT     ANY OTHER ONE ACTIVE?
         BNZ   *+L'*+4             YES
         NI    QXSWXQ,255-RQTR     OFF TRACE REQUEST
         QTILT '=== REQUESTED TRACE ID OFF ==='
SETTRC   NI    0(R2),*-*           <<EXECUTED>>
SETTR8   QTILT '=== INVALID TRACE REQUEST (ON/OFF) ==='
SETTR10  QTILT '=== TRACE DISABLED DUE TO ERROR ==='
SETTR20  CLI   QXAUTH,LV15         IS THIS AN AUTHORIZED USER?
         BL    SETTR0              NO, REJECT IT
         TM    QXSWXQ,SKTR         TRACE FILE IN ERROR?
         BZ    SETTR21             NO
         MVI   QXSWXQ,0            RESET TRACE STATUS
         LR    R0,R9
         L     R1,=A(QSNAPL)
         L     R14,=A(QSNAP)
         LR    R15,R1
         MVCL  R0,R14
         QTILT '=== TRACE STATUS RE-INITIALIZED ==='
SETTR21  QTILT '=== TRACE IS STILL ENABLE ==='
         SPACE 1
         LTORG
         SPACE 1
         DROP  R9,R10,R11,R12
 TITLE '--- QUEUE/SP -- HEXBLK -- HEXADECIMAL DUMP OF A BLOCK ---'
HEXBLK   QSTART
         USING QCKPT,R10           BASE REG FOR CKPT WORK AREA
         L     R10,QVCKPT          LOAD BASE REG
         USING QDISPLAY,R9         BASE REG FOR DISPLAY WORK AREA
         L     R9,QVDSPL           LOAD BASE REG
         CLI   QCODE,0             IS IT THE 'XB' COMMAND?
         BE    HEXBLKD             YES
         CLC   QPARM1(3),=CL3'ON ' SET ACTIVE?
         BE    HEXBLK2             YES
         CLC   QPARM1(4),=CL4'OFF '     SET INACTIVE?
         BE    HEXBLK1             YES
         CLI   QPARM1,C' '         DEFAULT OFF?
         BE    HEXBLK1             YES
         QTILT '=== INVALID SET DUMP FORMAT (ON/OFF) ==='
HEXBLK1  NI    QDFREQ,255-QDFEX    RESET TO NORMAL
         QTILT '=== DUMP FORMAT RESET TO NORMAL ==='
HEXBLK2  OI    QDFREQ,QDFEX        SET EXTENDED
         QTILT '=== DUMP FORMAT SET TO EXTENDED ==='
         SPACE 1
*---     VALIDATE AND CONVERT BLOCK ADDRESS                        ---*
         SPACE 1
HEXBLKD  OI    QDFREQ,QDFRL        SET RELATIVE
         LH    R15,QLNG1           LENGTH OF USER PARM
         LTR   R15,R15             IS THE LENGTH ZERO?
         BNP   HB$TILT             YES, TILT
         CH    R15,=H'8'           IS THE LENGTH TOO BIG?
         BH    HB$TILT             YES, TILT
         LR    R14,R15             COPY THE LENGTH
         BCTR  R14,0               -1 FOR EX
         EX    R14,HB$TRT          ALL VALID CHARACTERS?
         BNZ   HB$TILT             NO, ABORT
         MVC   QNUMWORK,QPARM1     LEAVE THE ORIGINAL ALONE
         TR    QNUMWORK,TABLEH     CONVERT TO HEX
         EX    R15,HB$PACK         PACK INTO QCTRAK
         SPACE 1
*---     READ THE BLOCK FROM HASPACE                               ---*
         SPACE 1
         L     R3,QCBLKA           BLOCK IOAREA ADDR
         LH    R1,HASPACE+(DCBBLKSI-IHADCB)  BLKSIZE FROM DCB
         LR    R2,R1
         BCTR  R1,0                SUBTRACT 1
         N     R1,ROUND            ROUND TO PREV. 64 BYTE BOUNDARY
         AR    R1,R3               ADD BASE OF BUFFER
         MVC   0(64,R1),QBLANK     BLANK LAST 64 BYTES OF BUFFER
         LR    R1,R3               PARM FOR READSPC
         MVI   QSYNADFL,0          INIT FLAG
         QCALL READSPC             READ HASPACE
         CLI   QSYNADFL,0          WAS THERE AN ERROR?
         BNE   HB$IOERR            YES, SAY SO
         SPACE 1
*---     LIST THE BLOCK                                            ---*
         SPACE 1
         MVC   QDHLINE,QBLANK      BLANK THE TITLE LINE
         QCALL HEXDUMP             DUMP THE BLOCK
         QSTOP
         SPACE 1
*---     SYNAD EXIT                                                ---*
         SPACE 1
HEXBLKER MVI   QSYNADFL,255        SET SYNAD FLAG
         BR    R14                 RETURN TO READSPC VIA SYSTEM
         SPACE 1
*---     EXCEPTIONS AND RETURN                                     ---*
         SPACE 1
HB$TILT  QTILT '*** BLOCK ADDRESS WAS OMITTED OR INVALID ***'
HB$IOERR CLI   QSYNADFL,255        REAL SYNAD ERROR?
         BE    HB$SYNAD
         QTILT '*** NOT IN HASPACE(S) EXTENT ***'
HB$SYNAD QTILT '*** SYNAD ERROR ROUTINE ENTERED ***'
         SPACE 1
HB$PACK  PACK  QCTRAK(5),QNUMWORK(1)    BLOCK ADDRESS
HB$TRT   TRT   QPARM1(*-*),TABLEV  << EXECUTED >>
ROUND    DC    0F'0',X'0000FFC0'
         SPACE 1
*---     TABLE FOR HEX CONVERT                                     ---*
         SPACE 1
TABLEH   DC    CL193' '
         DC    X'0A0B0C0D0E0F',CL41' ',C'01234567890',CL6' '
         SPACE 1
*---     TABLE USED TO VERIFY HEX OPERAND                          ---*
         SPACE 1
TABLEV   DC    256X'FF'
         ORG   TABLEV+C'A'
         DC    6X'00'
         ORG   TABLEV+C'0'
         DC    10X'00'
         ORG
         SPACE 1
         LTORG
         SPACE 1
         DROP  R9,R10,R11,R12
         TITLE '--- QUEUE/SP -- XT -- DISPLAY SOME BLOCKS ... ---'
XTCMD    QSTART
         L     R10,QVDSPL          @ DISPLAY WORK AREA
         USING QDISPLAY,R10
         CLI   QXAUTH,LV10         IS THIS AN AUTHORIZED USER?
         BNL   XTCMD1              YES, PROCESS IT
         QTILT '=== NOT AVAILABLE TO YOU, SORRY ==='
XTCMD1   MVC   QDHLINE,QBLANK      BLANK THE TITLE LINE
         MVC   FCLEAR,QBLANK       CLEAR THE PRINT AREA
         NI    QDFREQ,255-QDFRL    SET NORMAL
         L     R8,#TSCPPL          GET CPPL ADDRESS
         LR    R3,R8
         LA    R2,4*4
         MVC   FHEXID(L'FHEXID),=CL5'CPPL'
         QCALL HEXDUMP             DUMP CPPL
         USING CPPL,R8
         L     R3,CPPLCBUF         GET COMMAND BUFFER ADDRESS
         LA    R2,84
         MVC   FHEXID(L'FHEXID),=CL5'CBUF'
         QCALL HEXDUMP             DUMP COMMAND BUFFER
         L     R3,CPPLECT          GET ECT ADDRESS
         LA    R2,12*4
         MVC   FHEXID(L'FHEXID),=CL5'ECT'
         QCALL HEXDUMP             DUMP ECT
         LA    R3,QCODEH-2         GET PARSE ADDRESSES
         LA    R2,68
         MVC   FHEXID(L'FHEXID),=CL5'QOFF'
         QCALL HEXDUMP             DUMP PARSE
         LA    R3,QDRLNG           GET REPLY ADDRES
         LA    R2,L'QDRLNG+QDREPLYL
         MVC   FHEXID(L'FHEXID),=CL5'RPLY'
         QCALL HEXDUMP             DUMP REPLY
         LA    R3,SRMCC            GET SRMCC ADDRES
         LA    R2,L'SRMCC
         MVC   FHEXID(L'FHEXID),=CL5'SRMCC'
         QCALL HEXDUMP             DUMP REPLY
         QSTOP                     RETURN
         SPACE 1
         LTORG
         SPACE 1
         DROP  R10,R11,R12
         TITLE '--- QUEUE/SP -- ID -- JES2 INITIATORS DISPLAY ---'
IDCMD    QSTART
         CLI   QXAUTH,LV12         AUTHORIZED USER?
         BL    ID$TILTI            NO
         SPACE 1
*---     FIND THE ACTIVE MAIN SUBSYSTEM AND JES2 PITS              ---*
         SPACE 1
         L     R2,CVTPTR           POINT TO CVT
         USING CVTMAP,R2
         L     R1,CVTJESCT         POINT TO JESCT
         DROP  R2
         USING JESCT,R1
         CLC   JESCTID,=CL4'JEST'
         BNE   ID$TILTN
         CLC   JESPJESN,=CL4'JES2'
         BNE   ID$TILTN
         L     R2,JESSSCT          POINT TO SSCT
         DROP  R1
         USING SSCT,R2
         CLC   SSCTID,=CL4'SSCT'
         BNE   ID$TILTN
         CLC   SSCTSNAM,=CL4'JES2'
         BNE   ID$TILTN
         L     R1,SSCTSSVT         POINT TO SSVT
         DROP  R2
         USING SSVT,R1
         ICM   R2,B'1111',SVTPIT   STARTING POINT OF PITS
         BZ    ID$TILTN            IGNORE IF NO PITS
         DROP  R1
         SPACE 1
*---     COLLECT ALL INFORMATION ABOUT PITS                        ---*
         SPACE 1
         L     R5,QCWA             USE WORK SPACE TO COLLECT
IDI#     EQU   0,2                      PIT ID
IDJ#     EQU   2,2                      JOB NUMBER
IDJN     EQU   4,8                      JOB NAME
IDST     EQU   12,1                     PIT STATUS
IDCL     EQU   13,36                    PIT CLASSES
IDLL     EQU   49                  LENGTH
        $TSWXA 31,EXPAND=ONLY
         USING PIT,R2
IDLOOP   MVC   IDI#(,R5),PITPATID  GET PIT ID
         MVC   IDST(,R5),PITSTAT   GET PIT STATUS
         MVC   IDCL(,R5),PITCLASS  GET PIT CLASSES
         XC    IDJ#(,R5),IDJ#(R5)
         MVC   IDJN(L'IDJN,R5),QBLANK
         ICM   R3,B'1111',PITSJB   POINT TO THE SJB
         BZ    IDNXPIT             NONE
         USING SJB,R3
         CLC   SJBID,=CL4'SJB'
         BNE   IDNXPIT
         L     R4,SJBJQOFF
         N     R4,=A(X'00FFFFFF')  OFFSET TO JQE
         BZ    IDNXPIT
         AL    R4,QCJQEWA          ADD BASE TO OFFSET
         USING JQE,R4
         CLC   JQEJNAME,SJBJOBNM   THIS JOB?
         BNE   IDNXPIT             NO
         MVC   IDJ#(,R5),JQEJOBNO  GET JOB NUMBER
         MVC   IDJN(,R5),JQEJNAME  GET JOB NAME
         DROP  R3,R4
IDNXPIT  LA    R5,IDLL(R5)         BUMP TO COLLECT NEXT IF ANY
         ICM   R2,B'1111',PITNEXT  POINT TO NEXT PIT
         BNZ   IDLOOP              ANOTHER ONE
         DROP  R2
        $TSWXA 24,EXPAND=ONLY
         LR    R4,R5               RETAIN END
         SPACE 1
*---     BUILD AND SEND THE MESSAGE(S) DESCRIBING THE PITS         ---*
         SPACE 1
         L     R5,QCWA             STARTING POINTER
         L     R10,QVDSPL          @ DISPLAY WORK AREA
         USING QDISPLAY,R10
         MVC   QDHLINE,IDINHD      MOVE IN THE HEADING
IDBMSG   MVC   QDMSG,QBLANK        BLANK THE LINE
         MVC   IDIN#,IDI#(R5)      MOVE IN PIT ID
         MVC   IDCLS,IDCL(R5)      SET CLASSES
         TM    IDST(R5),PITHOLDA+PITHOLD1   TEST FOR DRAINED
         BNZ   IDHPIT              YES
         TM    IDST(R5),PITHALTA+PITHALT1   TEST FOR HALTED
         BNZ   IDSPIT              YES
         MVC   IDSTAT,=CL8'ACTIVE' SET STATUS
         TM    IDST(R5),PITBUSY    TEST FOR BUSY
         BO    IDAPIT              YES
         MVC   IDSTAT,=CL8'INACTIVE'    SET STATUS
         B     IDSEND
IDHPIT   MVC   IDSTAT,=CL8'DRAINED'     SET STATUS
         TM    IDST(R5),PITBUSY    TEST FOR BUSY
         BZ    IDSEND              NO
         MVC   IDSTAT+5(3),=C'ING' SET STATUS
         B     IDAPIT
IDSPIT   MVC   IDSTAT,=CL8'HALTED' SET STATUS
         TM    IDST(R5),PITBUSY    TEST FOR BUSY
         BZ    IDSEND              NO
         MVC   IDSTAT+4(3),=C'ING' SET STATUS
IDAPIT   CLI   IDJN(R5),C' '       JOBNAME?
         BE    IDSEND              NONE
         MVC   IDJOBNM,IDJN(R5)    MOVE IN JOBNAME
         LA    R1,IDCLS+L'IDCLS-2
IDFILL   CLC   0(2,R1),=CL2' '
         BNE   IDSJNUM
         MVI   1(R1),C'-'
         BCTR  R1,0
         BCT   R1,IDFILL
IDSJNUM  XR    R0,R0
         ICM   R0,B'0011',IDJ#(R5) SET JOB NUMBER
         BZ    IDSEND              NONE
         CVD   R0,FMT@CONV
         MVC   IDJOB#,=XL6'402020202120'
         ED    IDJOB#,FMT@CONV+5
IDSEND   QCALL DISPLAY,QDMSG,80    ADD LINE TO SCREEN
         LA    R5,IDLL(R5)         BUMP TO NEXT IF ANY
         CLR   R5,R4               IS IT THE END?
         BL    IDBMSG              NO, CONTINUE
         QSTOP
ID$TILTI QTILT '=== NOT AVAILABLE TO YOU, SORRY ==='
ID$TILTN QTILT '*** NO INITIATORS TO DISPLAY ***'
         SPACE 1
IDINHD   DC    CL79'INIT   STATUS   CLASSES                            1
                  JOB-NAME   JOB#'
         SPACE 1
         LTORG
         SPACE 1
         DROP  R10,R11,R12
         TITLE '--- QUEUE/SP -- TGJU -- TRACK GROUPS JOBS USAGE ---'
TGJU     QSTART
         CLI   QXAUTH,LV12         AUTHORIZED USER?
         BL    TG$TILTI            NO
         L     R10,QVCKPT          @ CHECKPOINT WORK AREA
         USING QCKPT,R10
         L     R9,QVDSPL           @ DISPLAY WORK AREA
         USING QDISPLAY,R9
         XC    TGJQAR(L'TGJQAR),TGJQAR  CLEAR JQE AREA
         L     R1,=A(TGPSAR)       INITIALIZE
         MVC   TGPSAR,0(R1)        PRIME TRACK GROUPS ACCUMULATORS
         XC    TGTTGPS,TGTTGPS     CLEAR ACCUMULATORS
         XC    TGTJOBS,TGTJOBS
         L     R3,QCJQHEAD         @ JQE'S QUEUES HEADS
         SL    R3,=A(JQENEXT-JQE)
         LA    R4,$JQHEADL         SIZE OF EACH QUEUE HEAD
         LA    R5,($JQTYPES*$JQHEADL)-1(,R3)
TGNXQH   LR    R6,R3               POINT TO NEXT QHEAD
         USING JQE,R6
TGJQEL   L     R6,JQENEXT          GET CHAIN FIELD
         N     R6,=A(X'00FFFFFF')  OFFSET TO JQE
         BZ    TGSTQH              BRANCH IF END OF QUEUE
         AL    R6,QCJQEWA          ADD BASE TO OFFSET
         LH    R2,JQETGNUM         NUMBER OF TRACK GROUPS
         TM    JQEFLAG5,JQE5XUSD   USING JQE EXTENSION?
         BZ    TGJU1               NO
         AL    R2,QCJQEXA          COMPUTE ADDR OF EXTENSION
         LH    R2,$JEXTTGN(,R2)    TRACK GROUPS IN EXTENSION
TGJU1    LTR   R2,R2               ANY TGPS?
         BNP   TGJQEL              NONE, SKIP THIS JQE
         LR    R14,R2              NUMBER OF TRACK GROUPS
         A     R14,TGTTGPS         ADD TO ACCUMULATOR
         ST    R14,TGTTGPS
         LA    R14,1
         A     R14,TGTJOBS         BUMP TOTAL NUMBER OF JOBS
         ST    R14,TGTJOBS
         LA    R14,TGPSAR+L'TGPSAR-8    POINT TO LAST ENTRY
         LA    R15,(L'TGPSAR/8)    NUMBER OF ENTRIES
         LA    R1,8                SIZE OF AN ENTRY
TGJU2    CL    R2,0(R14)           COMPARE TRACK GROUPS WITH SLOT SIZE
         BNH   TGJU3               YES, INSERT IT HERE
         SLR   R14,R1              BACK UP TO PREVIOUS ENTRY
         BCT   R15,TGJU2           LOOP THROUGH ELEMENTS
         B     TGJU4               NONE, SKIP INCREMENT
TGJU3    LA    R15,1
         A     R15,4(,R14)         INCREMENT COUNT
         ST    R15,4(,R14)
TGJU4    LA    R14,TGJQAR+L'TGJQAR-8    POINT TO LAST ENTRY
         LA    R15,(L'TGJQAR/8)    NUMBER OF ENTRIES
         LA    R1,8                SIZE OF AN ENTRY
TGJU5    CL    R2,4(R14)           SEE IF NEW IS BIGGER
         BNL   TGJU6               YES, INSERT IT HERE
         SLR   R14,R1              BACK UP TO PREVIOUS ENTRY
         BCT   R15,TGJU5           LOOP THROUGH ELEMENTS
         B     TGJQEL              GO TRY NEXT JQE
TGJU6    BCTR  R15,0               DROP BY ONE
         SLL   R15,3               TIMES 8 (LENGTH OF ENTRY)
         BCTR  R15,0               DROP FOR EXECUTE
         LTR   R15,R15             TEST FOR VALID
         BNP   *+L'*+4             NO, JUST DO THE INSERT
         EX    R15,TGTMVC          MOVE ENTRIES DOWN
         ST    R6,0(,R14)          SAVE JQE ADDRESS
         ST    R2,4(,R14)          SAVE # OF TRACK GROUPS
         B     TGJQEL              TRY NEXT JQE
TGTMVC   MVC   TGJQAR(*-*),TGJQAR+8     SLIDE ENTRIES DOWN
TGSTQH   BXLE  R3,R4,TGNXQH        STEP TO NEXT QHEAD
         DROP  R6                  DROP OLD JQE REG
         LA    R2,TGJQAR+L'TGJQAR-8     POINT TO LAST ENTRY
         LA    R3,(L'TGJQAR/8)     NUMBER OF ENTRIES
         LA    R4,8                SIZE OF EACH ENTRY
         MVC   QDHLINE,TGJUHD      SET HEADER LINE
TGPJQE   L     R5,0(,R2)           JQE ADDRESS
         USING JQE,R5
         MVC   QDMSG,QBLANK        BLANK THE TEXT AREA
         LTR   R5,R5               ANY ADDRESS?
         BZ    TGPNJQE             NO, SKIP TRASH
         LH    R0,JQEJOBNO         GET JOB NUMBER
         CVD   R0,FMT@CONV         TO DECIMAL
         MVC   TGUJOBID,=XL6'402020202120'
         ED    TGUJOBID,FMT@CONV+5 EDIT JOB ID IN MESSAGE TEXT
         MVC   TGUJNAME,JQEJNAME   MOVE JOB NAME TO MESSAGE
         TM    JQEFLAG1,JQE1BUSY   IS JOB BUSY?
         BZ    TGPJQEN             NO
         IC    R1,JQEFLAG1         SYSTEM BUSY INDICATOR
         N     R1,=A(JQE1BUSY)
         SLL   R1,3                COMPUTE OFFSET INTO QSE TABLE
         LA    R1,QSYSIDU(R1)      ADDR OF SYSTEM BUSY
         MVC   TGUACT,0(R1)        INSERT INTO MESSAGE
         DROP  R5
TGPJQEN  L     R0,4(,R2)           NUMBER OF TRACK GROUPS
         CVD   R0,FMT@CONV         TO DECIMAL
         MVC   TGU#TGPS,=XL8'4020202020202120'
         ED    TGU#TGPS,FMT@CONV+4 EDIT IN MESSAGE
         LTR   R1,R0               TEST AND SAVE FOR DIVIDE
         BNP   TGJU10              SKIP IF NONE
         XR    R0,R0               CLEAR FOR DIVIDE
         MH    R1,=H'1000'
         L     R15,QCTNUMTG        NUMBER OF ACTIVE TRACK GROUPS
         DR    R0,R15              DIVIDE TO GET PERCENT OF TOTAL
TGJU10   CVD   R1,FMT@CONV         TO DECIMAL
         MVC   TGUTGPCT,=XL7'40202020214B20' EDIT MASK FOR % SPOOL
         ED    TGUTGPCT,FMT@CONV+5 SET % TO MESSAGE
TGPNJQE  L     R0,TGPSAR-TGJQAR(,R2)    TRACK GROUP ACCUMULATOR
         CL    R0,TGPSAR           IS THIS THE MAX VALUE?
         BNE   TGJU11              NO
         MVC   TGU$TGPS,=CL8'     MAX'  SET MORE REASONABLE VALUE
         B     TGJU12
TGJU11   CVD   R0,FMT@CONV         TO DECIMAL
         MVC   TGU$TGPS,=XL8'4020202020202120'
         ED    TGU$TGPS,FMT@CONV+4 EDIT IN MESSAGE TEXT
TGJU12   L     R0,TGPSAR-TGJQAR+4(,R2) NUMBER OF JOBS
         LTR   R1,R0               TEST AND SAVE FOR DIVIDE
         BNP   TGJU13              SKIP IF NONE
         CVD   R0,FMT@CONV         TO DECIMAL
         MVC   TGU$JOBS,=XL8'4020202020202120'
         ED    TGU$JOBS,FMT@CONV+4 EDIT IN MESSAGE TEXT
         XR    R0,R0               CLEAR FOR DIVIDE
         MH    R1,=H'1000'
         L     R15,TGTJOBS         GET TOTAL NUMBER OF JOBS
         DR    R0,R15              DIVIDE TO GET PERCENT OF TOTAL
         CVD   R1,FMT@CONV         TO DECIMAL
         MVC   TGU$PCT,=XL7'40202020214B20'  EDIT MASK FOR % SPOOL
         ED    TGU$PCT,FMT@CONV+5  SET % TO MESSAGE
TGJU13   QCALL DISPLAY,QDMSG,80    ADD LINE TO SCREEN
         SR    R2,R4               MOVE TO NEXT ENTRY
         BCT   R3,TGPJQE           PRINT ALL ENTRIES
         MVC   QDMSG,QBLANK        BLANK THE TEXT AREA
         $FS   SF=(PROT,INT),MF=(I,QDMSG)    HIGH INTENSITY, PROTECTED
         MVC   TGPTOTAL,=CL8'TOTAL :'
         L     R0,TGTTGPS          TOTAL NUMBER OF TRACK GROUPS
         CVD   R0,FMT@CONV         TO DECIMAL
         MVC   TGT#TGPS,=XL8'4020202020202120'
         ED    TGT#TGPS,FMT@CONV+4 EDIT IN MESSAGE
         LTR   R1,R0               TEST AND SAVE FOR DIVIDE
         BNP   TGJU20              SKIP IF NONE
         XR    R0,R0               CLEAR FOR DIVIDE
         MH    R1,=H'1000'
         L     R15,QCTNUMTG        NUMBER OF ACTIVE TRACK GROUPS
         DR    R0,R15              DIVIDE TO GET PERCENT OF TOTAL
TGJU20   CVD   R1,FMT@CONV         TO DECIMAL
         MVC   TGTTGPCT,=XL7'40202020214B20' EDIT MASK FOR % SPOOL
         ED    TGTTGPCT,FMT@CONV+5 SET % TO MESSAGE
         MVC   TGJTOTAL,=CL8'TOTAL :'
         L     R0,TGTJOBS          TOTAL NUMBER OF JOBS
         CVD   R0,FMT@CONV         TO DECIMAL
         MVC   TGT$JOBS,=XL8'4020202020202120'
         ED    TGT$JOBS,FMT@CONV+4 EDIT IN MESSAGE
         $FS   SF=(PROT),MF=(I,QDMSG+L'QDMSG-2)   NORMAL INT, PROT
         OI    QDOVER,QESKIP+QTSKIP     NO END OF DATA & NO TRANSLATE
         QCALL DISPLAY,QDMSG,80    ADD LINE TO SCREEN
         QSTOP
TG$TILTI QTILT '=== NOT AVAILABLE TO YOU, SORRY ==='
         SPACE 1
TGJUHD   DC    CL79'  JOB#  JOBNAME  #-TGPS      % EXEC            #-TG1
               PS  #-JOBS      %'
         SPACE 1
         LTORG
         SPACE 1
         DROP  R9,R10,R11,R12
         TITLE '--- QUEUE/SP -- PRINT -- START/STOP HARDCOPY ---'
PRINT    QSTART
         L     R10,QVDSPL          @ DISPLAY WORK AREA
         USING QDISPLAY,R10
         L     R9,QVPRINT          @ PRINT WORK AREA
         USING QPRINT,R9
         TM    QHFREQ,QHFAIL       IS HARDCOPY OPEN FAILED?
         BO    PRNFAIL             YES, BYPASS ALL
         TM    QHFREQ,QHCLOSE      IS HARDCOPY TO BE CLOSED?
         BO    PRNSTOP             YES, GO DO IT
         CLC   QPARM1(3),=CL3'OFF' IS PRINT OFF?
         BE    PRNSTP              YES, GO STOP IT
         CLC   QPARM1(2),=CL2'ON'  IS IT ON?
         BE    PRNSTR              YES, GO START IT
         CLI   QPARM1,C' '         NO PARM?
         BE    PRNSTP              YES, ASSUME STOP
         QTILT '=== INVALID PRINT COMMAND (ON/OFF) ==='
         SPACE 1
*---     ALLOCATE/OPEN AND START HARDCOPY PROCESS                  ---*
         SPACE 1
PRNSTR   TM    QHFREQ,QHCOPY       IS HARDCOPY ACTIVE?
         BZ    PRNALLOC            NO, START IT
         QTILT '=== HARDCOPY IS ALREADY ACTIVE ==='
         SPACE 1
*---     ALLOCATE / OPEN HARDCOPY                                  ---*
         SPACE 1
PRNALLOC LA    R1,P99RB            RELOCATE THE LIST ADDRESSES
         ST    R1,P99RBPTR              *
         OI    P99RBPTR,X'80'           *
         LA    R1,P99TUPL               *
         ST    R1,P99TXTPP              *
         LA    R1,P99TUKY1              *
         ST    R1,P99TUPL               *
         LA    R1,P99TUKY2              *
         ST    R1,P99TUPL+4             *
         LA    R1,P99TUKY3              *
         ST    R1,P99TUPL+8             *
         LA    R1,P99TUKY4              *
         ST    R1,P99TUPL+12            *
         OI    P99TUPL+12,X'80'         *
         SPACE 1
*---     PROCESS PARMS ...                                         ---*
         SPACE 1
         LH    R1,QLNG2            GET LENGTH OF SECOND PARM
         CH    R1,=H'1'            LENGTH OF ONE?
         BNE   PRNNSCHG            NO, NO CHANGE OF SYSOUT CLASS
         CLI   QPARM2,C'A'         IS IT ALPHA?
         BL    PRNNSCHG            NO, NO CHANGE OF SYSOUT CLASS
         MVC   P99SYSOC,QPARM2     MOVE IN PARM FOR SYSOUT CLASS
PRNNSCHG CLI   QPARM3,C' '         ANY DEST SPECIFIED
         BE    PRNNDEST
         MVC   P99DEST,QPARM3      MOVE IN DEST
         MVC   P99DESTL,QLNG3      MOVE IN LENGTH
         B     PRNDYALL
PRNNDEST MVC   P99TUPL+8(4),P99TUPL+12  OVERRIDE DEST= PARM
         SPACE 1
*---     DO THE ALLOCATION                                         ---*
         SPACE 1
PRNDYALL LA    1,P99RBPTR          ADDR OF PARM LIST FOR DYNALLOC
         DYNALLOC
         LTR   R15,R15             CHECK RETURN CODE?
         BNZ   PRNCANT             ERROR, CAN DO POST MESSAGE
         LA    R6,HCPYDCB          ADDRESS OF OUTPUT DCB
         USING IHADCB,R6           ADDRESSABILITY TO OUTPUT DCB
         MVC   DCBDDNAM,QBLANK
         ICM   R15,B'0011',P99DDNL
         BCT   R15,*+L'*+6
         MVC   DCBDDNAM(*-*),P99DDN     <<EXECUTED>>
         EX    R15,*-6             SET DDNAME
         OPEN  ((R6),OUTPUT),MF=(E,HCPYOP)   OPEN THE FILE
         TM    DCBOFLGS,DCBOFOPN   CHECK FOR SUCCESSFUL OPEN
         DROP  R6                  KILL DCB ADDRESSABILITY
         BZ    PRNBAD              BYPASS IF BAD OPEN
         OI    QHFREQ,QHCOPY       SET HARDCPY FILE AVAILABLE
         ZAP   QHPAGE#,=PL1'+0'    RESET PAGE NUMBER
         ZAP   QHLINE#,=PL2'+999'  RESET LINES COUNT
         MVC   QDMSG(L'PMSSTART),PMSSTART    MOVE START MSG
         MVC   QDMSG+PMSCLASS(L'PMSCLASS),P99SYSOC     SYSOUT CLASS
         MVC   QDMSG+PMSDEST(L'PMSDEST),P99DEST
         CLI   QDMSG+PMSDEST,C' '  ANY DEST?
         BNE   *+L'*+6
         MVC   QDMSG+PMSDEST(L'PMSDEST),=CL8'LOCAL'    SAY LOCAL
         LA    R0,L'PMSSTART
PRNMSG   LA    R1,QDMSG
         QTILT ,                   SEND MESSAGE
PRNBAD   NI    QHFREQ,255-QHCOPY   TURN OFF HARDCOPY FLAG
         OI    QHFREQ,QHFAIL       SET HARDCOPY OPEN FAILED FLAG
PRNFAIL  QTILT 'SORRY, ... HARDCOPY OPEN FAILED'
         SPACE 1
*---     FORMULATE TEXT FOR SVC99 ALLOCATE FAILURE                 ---*
         SPACE 1
PRNCANT  CLC   P99ERROR,=XL2'046C' WAS IT 'RMT NOT DEF TO JES2'?
         BE    PBADRMT             YES, POST MSG AND EXIT
         MVC   QDMSG,QBLANK        CLEAR OUT LINE
         MVC   QDMSG(L'PMSERR),PMSERR
         CVD   R15,QNUMWORK        CONVERT SVC 99 RETURN CODE
         MVC   QDMSG+PMSRC(L'PMSRC),=XL4'40202020'     TO DEC
         ED    QDMSG+PMSRC(L'PMSRC),QNUMWORK+6
         UNPK  QDMSG+PMSERC(L'PMSERC+1),P99ERROR(3)    ERR CODE
         TR    QDMSG+PMSERC(L'PMSERC),HEXTAB-X'F0'
         MVI   QDMSG+PMSERC+L'PMSERC,C' '
         UNPK  QDMSG+PMSINFO(L'PMSINFO+1),P99INFO(3)   INFO CODE
         TR    QDMSG+PMSINFO(L'PMSINFO),HEXTAB-X'F0'
         MVI   QDMSG+PMSINFO+L'PMSINFO,C' '
         LA    R0,L'PMSERR
         B     PRNMSG              GO SEND THE MESSAGE
PBADRMT  MVC   QDMSG(L'PMSNRMT),PMSNRMT MOVE IN NO SUCH REMOTE MSG
         MVC   QDMSG+PMSRMTN(L'PMSRMTN),QPARM3    RMT ASKED FOR
         LA    R0,L'PMSNRMT
         B     PRNMSG              GO SEND THE MESSAGE
         SPACE 1
*---     STOP HARDCOPY PROCESS AND FREE SYSOUT FILE                ---*
         SPACE 1
PRNSTP   TM    QHFREQ,QHCOPY       IS HARDCOPY ACTIVE?
         BO    PRNSTOP             YES
         QTILT '=== HARDCOPY IS ALREADY INACTIVE ==='
PRNSTOP  LA    R2,HCPYDCB          ADDRESS OF OUTPUT DCB
         CLOSE ((R2)),MF=(E,HCPYCL)     CLOSE OFF THE FILE
         FREEPOOL (R2)             FREE THE BUFFERS TOO
         TM    QHFREQ,QHCLOSE      WAS HARDCOPY TO BE CLOSED?
         BZ    PRNRST              NO
         QSTOP ,                   YES, EXIT
PRNRST   LR    R0,R9               RE-INITIALIZE
         L     R1,=A(QPRINTL)
         L     R2,=A(QPRINT)
         LR    R3,R1
         MVCL  R0,R2
         NI    QHFREQ,255-QHCOPY   TURN OFF HARDCOPY FLAG
         QTILT 'HARDCOPY STOPPED : SYSOUT FREED FOR PRINT.'
         SPACE 1
PMSSTART DC    C'HARDCOPY STARTED : SYSOUT= ,DEST=        '
PMSCLASS EQU   26,1
PMSDEST  EQU   33,8
PMSERR   DC    C'HARDCOPY ALL. ERR. : DARC=     INFO=     R15=    .'
PMSERC   EQU   26,4
PMSINFO  EQU   36,4
PMSRC    EQU   45,4
PMSNRMT  DC    C'HARDCOPY ERR. : REMOTE          UNDEFINED TO JES2.'
PMSRMTN  EQU   23,8
         SPACE 1
         LTORG
         SPACE 1
         DROP  R9,R10,R11,R12
         TITLE '--- QUEUE/SP -- HCOPY -- HARDCOPY ROUTINE ---'
HCOPY    QSTART
         L     R10,QVDSPL          @ DISPLAY WORK AREA
         USING QDISPLAY,R10
         L     R9,QVPRINT          @ PRINT WORK AREA
         USING QPRINT,R9
         SPACE 1
*---     GET DATE/TIME FOR HEADING                                 ---*
*---     SET HJDATE ... (YY.DDD  HH:MM:SS DAY MTH DD,19YY)         ---*
         SPACE 1
         TIME  DEC
         ST    R1,BINDATE          SAVE DATE FOR LATER
         SPACE 1
*---     FORMAT THE PRESENT TIME (AS SET BY THE OPERATOR)          ---*
         SPACE 1
         ST    R0,QNUMWORK         CONVERT PACKED TO DEC
         MVI   QNUMWORK+4,X'0F'
         UNPK  XQDWD(9),QNUMWORK(5)
         MVC   HTMEHRS,XQDWD       MOVE TIME TO MSG
         MVC   HTMMINS,XQDWD+2
         MVC   HTMSECS,XQDWD+4
         SPACE 1
*---     FORMAT TODAY'S DATE INTO THE OUTPUT MSG                   ---*
         SPACE 1
         MVC   XQDWD(4),BINDATE    MOVE DATE TO WORK AREA
         MVO   XQDWD+1(3),XQDWD(2) MAKE 00YYDDDS INTO 00000YYS
         UNPK  HCYR(2),XQDWD+2(2)  FORMAT YEAR
         XC    QNUMWORK,QNUMWORK
         MVC   QNUMWORK+4(4),XQDWD CONVERT YEAR TO BIN
         CVB   R0,QNUMWORK
         ST    R0,BINYEAR          AND SAVE
         TM    BINYEAR+3,X'03'     LEAP YEAR?
         BNZ   HMON1               NO
         MVI   HMONMSK+10,29       YES, CORRECT
HMON1    XC    QNUMWORK,QNUMWORK   CONVERT DAYS TO BIN
         MVC   QNUMWORK+6(2),BINDATE+2
         CVB   R2,QNUMWORK
         ST    R2,BINDAYS          SAVE FOR LATER
         XR    R1,R1
         LA    R15,11
HMON2    IC    R1,HMONMSK(R15)     COMPUTE MON AND DAY
         SR    R2,R1
         BNP   HMONOVR
         BCT   R15,HMON2
         B     *+L'*+2
HMONOVR  AR    R2,R1               CORRECT OVERDRAW
         CVD   R2,QNUMWORK         FORMAT DAY
         UNPK  HCDAYN(2),QNUMWORK+6(2)
         OI    HCDAYN+1,C'0'       FIX UP SIGN
         MH    R15,=Y(L'HMONTAB)   GET TABLE OFFSET
         LA    R15,HMONTAB(R15)    AND POINT AT MONTH
         MVC   HCMON(L'HCMON),0(R15)    MOVE IT TO THE MSG
         SPACE 1
*---     DAY OF WEEK                                               ---*
         SPACE 1
         L     R15,BINYEAR
         SH    R15,=H'69'
         BNP   HOUTT               MUST BE GREATER OR BAD
         XR    R14,R14             CLEAR DAY REG
         D     R14,=F'4'
         MH    R15,=H'5'
         AR    R14,R15
         A     R14,BINDAYS
         SRDA  R14,32
         D     R14,=F'7'           MODULO 7 FOR WEEK
         MH    R14,=Y(L'HDAYTAB)
         LA    R14,HDAYTAB(R14)    POINT AT TODAY
         MVC   HCDAY(L'HCDAY),0(R14)    INSERT IN MSG
         B     HMOVEJD
HOUTT    MVC   HCDAY(L'HCDAY),=CL3'???'
HMOVEJD  MVC   HJDATE,=XL7'4020204B202020'
         ED    HJDATE,BINDATE+1
         MVI   HJDATE,C'='
         MVC   QHUSER,QLOGON       MOVE IN USERID
         MVI   QHPAGS,C' '
         MVC   QHPAGE,QBLANK       CLEAR OUT PAGE FIELD
         MVI   QHHEAD1,C'0'        SET DOUBLE SPACE
         CP    QHLINE#,=PL2'+35'   EJECT TO BE SCHEDULED?
         BNH   HNOPAGE             NO, ... SKIP PAGE SETTING
         AP    QHPAGE#,=PL1'+1'    BUMP PAGE COUNT
         MVI   QHPAGS,C'/'
         MVC   QHPAGE,=XL6'402020202021'     MOVE IN MASK
         ZAP   QNUMWORK,QHPAGE#    MOVE INTO AREA
         ED    QHPAGE,QNUMWORK+5   EDIT IN PAGE NUMBER
         MVI   QHHEAD1,C'1'        SET EJECT
         ZAP   QHLINE#,=PL1'+0'    RESET LINES COUNT
HNOPAGE  PUT   HCPYDCB,QHHEAD1     PUT OUT TITLE LINE
         PUT   HCPYDCB,QHHEAD2     PUT OUT UNDERLINE
         AP    QHLINE#,=PL1'+3'    BUMP LINES COUNT
         MVC   QHLINE,QBLANK       RECONSTRUCT IMAGE OF
         MVC   QHLINE(12),=CL12'COMMAND ===>'     COMMAND LINE
         MVC   QHLINE+13(L'QDPROMPT),QDPROMPT     WITHOUT 3270
         OC    QHLINE+13(L'QDPROMPT),QBLANK       CONTROL CHARS
         PUT   HCPYDCB,QHDETAIL
         AP    QHLINE#,=PL1'+1'    BUMP LINES COUNT
         SPACE 1
*---     PUT OUT ENTIRE SCREEN OF DETAIL LINES                     ---*
         SPACE 1
         CLC   QDHLINE(L'QDHLINE),QBLANK
         BE    HNOHD
         MVC   QHLINE(L'QDHLINE),QDHLINE     MOVE HEADING LINE
         PUT   HCPYDCB,QHDETAIL    PRINT THE LINE
         AP    QHLINE#,=PL1'+1'    BUMP LINES COUNT
HNOHD    LA    R2,QDLINE1          SET SCAN REGISTERS
         LA    R5,QHLINE
HSCNEXT  LR    R3,R2
         LA    R4,L'QDLINE1
HSCLOOP  CLI   0(R2),X'1D'         IS IT A SF ORDER?
         BE    HTLNE               YES
         CLI   0(R2),X'11'         IS IT A SBA ORDER?
         BE    HTLNE               YES
         CLI   0(R2),X'3C'         IS IT A RA ORDER?
         BE    HTLNE               YES
         LA    R2,1(R2)            POINT TO NEXT CHAR IN LINE
         BCT   R4,HSCLOOP          CONTINUE THROUGH SCREEN
HTLNE    LR    R1,R2               COMPUTE LINE LENGTH
         SR    R1,R3
         BNP   HSCNONE
         MVC   QHLINE,QBLANK
         BCTR  R1,0
         EX    R1,HPLNE            MOVE LINE TO BUFFER
         PUT   HCPYDCB,QHDETAIL    PUT DETAIL LINE OUT
         AP    QHLINE#,=PL1'+1'    BUMP LINES COUNT
HSCNONE  LA    R5,QHLINE
         CLI   0(R2),X'1D'         WAS IT A SF ORDER?
         BNE   HTNULL              NO
         LA    R2,2(R2)            SKIP SF ORDER
         LA    R5,1(R5)            ADJUST NEXT MOVE DATA
         B     HSCNEXT             CONTINUE THROUGH SCREEN
HTNULL   CLI   0(R2),X'11'         WAS IT A SBA ORDER?
         BE    HTLEND              YES
         CLI   0(R2),X'3C'         WAS IT A RA ORDER?
         BNE   HSCNEXT             NO, CONTINUE THROUGH SCREEN
HTLEND   MVI   QHDETAIL,C'0'       DOUBLE SPACE
         MVC   QHLINE,QBLANK       BLANK LINE
         PUT   HCPYDCB,QHDETAIL    AND PRINT IT
         MVI   QHDETAIL,C' '       RESTORE TO SINGLE SPACE
         AP    QHLINE#,=PL1'+1'    BUMP LINES COUNT
         QSTOP ,                   RETURN
HPLNE    MVC   0(*-*,R5),0(R3)     <<EXECUTED>>
         SPACE 1
HDAYTAB  DS    0CL3
         DC    C'TUEWEDTHUFRISATSUNMON'
HMONTAB  DS    0CL3
         DC    C'DECNOVOCTSEPAUGJULJUNMAYAPRMARFEBJAN'
         SPACE 1
         LTORG
         SPACE 1
         DROP  R9,R10,R11,R12
         TITLE '--- QUEUE/SP COMMON AREA ---'
***********************************************************************
***********************************************************************
***                                                                 ***
***      QUEUE COMMAND - COMMON AREA DESCRIPTION                    ***
***                                                                 ***
***********************************************************************
***********************************************************************
         SPACE 1
QCOMMON  DS    0D                  START ON A DOUBLE-WORD BOUNDARY
         DC    18F'0'              COLD SAVE AREA
         SPACE 1
*---     NUMERIC CONVERT ROUTINE                                   ---*
         SPACE 1
         USING QCOMMON,R11
QNUMCONV MVC   QFZONES,QFZONE      INITIALIZE FIELD
         EX    R1,QMVZ             COPY THE ZONES
         CLC   QFZONES,QFZONE      ALL NUMERICS?
         BNER  R14                 NO, RETURN WITH CC SET TO 'NE'
         EX    R1,QPACK            PACK IT
         CVB   R15,QNUMWORK        GET IT IN BINARY
         BR    R14                 RETURN WITH CC SET TO 'EQ'
QMVZ     MVZ   QFZONES(*-*),0(R15) << EXECUTED >>
QPACK    PACK  QNUMWORK,0(*-*,R15) << EXECUTED >>
         DROP  R11
         EJECT
*---     VECTOR TABLE - ADDRESSES OF AREAS IN QCOMMON              ---*
         SPACE 1
QCWA     DC    A(0)                PTR TO SPACE WORK AREA
QVDSPL   DC    A(0)                PTR TO DISPLAY WORK AREA
QVCKPT   DC    A(0)                PTR TO CKPT WORK AREA
QVSNAP   DC    A(0)                PTR TO SNAP WORK AREA
QVPRINT  DC    A(0)                PTR TO HARDCOPY WORK AREA
QGSASSZ  DC    A(4096)             SAVE AREA STACK SIZE
QPTRSV   DC    4F'0'               SPARE POINTERS SAVE AREA
QFRSTSA  DC    A(0)                @ OF FIRST SAVE AREA
QCJQHEAD DC    A(0)                @ OF $JQHEADS IN MASTER RECORD
QCJQEXA  DC    A(0)                @ OF JQE EXTENSIONS
QCTNUMTG DC    F'0'                # OF TRACK GROUPS ON ACTIVE VOLUMES
QCMSA    DC    A(0)                @ OF MASTER RECORD
QCMSTTR  DC    0F'0',X'00000300'   TTR OF MASTRER CKPT RECORD
QCDASA   DC    A(0)    *ORDER*     @ DAS CKPT AREA
QCDASTTR DC    F'0'    *ORDER*     TTR OF 1ST DAS CKPT BLOCK
QCDASNUM DC    F'0'    *ORDER*     # OF DAS CKPT BLOCKS
QCJQEWA  DC    A(0)                @ JQE CKPT AREA (BASE TO OFFSET)
QCJQEA   DC    A(0)    *ORDER*     @ JQE CKPT AREA
QCJQETTR DC    F'0'    *ORDER*     TTR OF 1ST JQE CKPT BLOCK
QCJQENUM DC    F'0'    *ORDER*     # OF JQE CKPT BLOCKS
QCJOTWA  DC    A(0)                @ JOE CKPT AREA (BASE TO OFFSET)
QCJOTA   DC    A(0)    *ORDER*     @ JOE CKPT AREA
QCJOETTR DC    F'0'    *ORDER*     TTR OF 1ST JQE CKPT BLOCK
QCJOENUM DC    F'0'    *ORDER*     # OF JOE CKPT BLOCKS
QCJCTA   DC    A(0)                @ OF JCT BUFFER
QCIOTA   DC    A(0)                @ OF IOT BUFFER
QCBLKA   DC    A(0)                @ OF DATA-SET BLOCK BUFFER
         EJECT
*---     MISCELLANEOUS NUTS AND BOLTS                              ---*
         SPACE 1
QLOGON   DC    CL7' '              LOGON ID (PSCBUSER)
QLOGONL  DC    AL1(0)              LENGTH OF LOGON ID
QCLASSH  DC    0H'0',X'00'         HALFWORD BOUNDARY
QCLASS   DC    C' '                SEARCH CLASS
QCLASSE  DC    CL2' '              EXTERNAL CLASS
         CNOP  2,4
QCODEH   DC    0H'0',X'00'         HALFWORD BOUNDARY
QCODE    DC    X'00'               SEARCH FUNCTION CODE
QSUBCMD  DC    A(0)                ADDR OF CURRENT SUB-COMMAND
QOFF0    DC    H'0'                OFFSET TO SUB-COMMAND
QLNG0    DC    H'0'                LENGTH OF SUB-COMMAND
QSUBNAME DC    CL8' '              NAME OF SUB-COMMAND
QOFF1    DC    H'0'                OFFSET TO QPARM1
QLNG1    DC    H'0'                LENGTH OF QPARM1
QPARM1   DC    CL8' '              USER SUPPLIED PARAMETER #1
QOFF2    DC    H'0'
QLNG2    DC    H'0'
QPARM2   DC    CL8' '                                      #2
QOFF3    DC    H'0'
QLNG3    DC    H'0'
QPARM3   DC    CL8' '                                      #3
QOFF4    DC    H'0'
QLNG4    DC    H'0'
QPARM4   DC    CL8' '                                      #4
QOFFLR   EQU   *-QOFF1
QJOBID   DC    H'0',CL8' '         LAST JOBID (AND LENGTH)
QSTKEY   DC    CL8' '              SEARCH KEY FOR 'ST' SUBCMD
QXAUTH   DC    X'00'
QSYNADFL DC    X'00'               SYNAD ERROR ROUTINE FLAG BYTE
QBLANK   DC    CL80' '             80 BLANKS
SZLINE   DC    F'0'                LINE SIZE (LINE LENGTH)
SZSCRN   DC    F'0'                SCREEN SIZE (NUMBER OF LINES)
REQAUT   DC    0F'0',BL1'00000000',AL3(MDL@IX),AL4(*-*)
SAVAUTH  DC    X'00'
QXSWXQ   DC    X'00'          TRACE INDICATORS
OPTR     EQU   X'01'               TRACE FILE OPENED FLAG
RQTR     EQU   X'02'               TRACE REQUESTED FLAG
NFTR     EQU   X'04'               NOT FULL SCREEN FLAG
MSTR     EQU   X'08'               BACK ERROR MESSAGE FLAG
SKTR     EQU   X'10'               TRACE FILE IN ERROR FLAG
SZSWTCH  DC    X'00'          SCREEN SIZE INDICATORS
SCRST    EQU   X'01'               SCREEN SIZE TO BE SET
SCRRS    EQU   X'02'               SCREEN SIZE TO BE RESET
QTSSW    DC    X'00'          TSO CMDS INDICATORS
RCTSO    EQU   X'01'               DISPLAY TSO CMDS RC FLAG
FLTSO    EQU   X'02'               FULL DISPLAY TSO CMDS RC FLAG
CLTSO    EQU   X'10'               CLIST EXECUTION REQUEST FLAG
CLSTX    EQU   X'20'               CLIST IN EXECUTION FLAG
CLSTP    EQU   X'40'               STOP PROCESS FLAG
         EJECT
QNUMWORK DC    D'0'                CONVERT WORK AREA
QFZONE   DC    C'0'                USED TO CLEAR QFZONES
QFZONES  DC    C'00000000'         USED FOR NUMERIC CHECK
QCOUNT   DC    PL3'0'              NUMBER OF ELEMENTS IN QUEUE
QPJOBID  DC    XL4'0'              JOB ID FOR LISTDS
QPDSID   DC    H'0'                DATA-SET ID FOR LISTDS
QPOFFSET DC    H'0'                PRINT OFFSET FROM BEG. OF REC
QPREC    DC    PL4'0'              CURRENT RECORD COUNT
QPLNG    DC    H'0'                LEN OF COMPARE FIELD FOR FIND
QPFIND   DC    CL64' '             COMPARE FIELD FOR FIND
QSPOLNUM DC    H'0'                NUMBER OF SPOOL VOLUMES
QSYSIDU  DC    CL8'UNKNOWN '       SYSTEM ID TABLE START
QSYSID   DC    8CL8' '             SYSTEM ID TABLE
         SPACE 1
QASID    DC    H'0'                ADDRESS SPACE IDENTIFIER
SRMCC    DC    F'0'                SRM RETURNS INFORMATION
ATSOX    DC    A(0)                TSO COMMANDS WORK AREA
QFRAR1   DC    A(0)                BLOCK ADDR TABLE FOR LISTDS
QFRSZ1   DC    A(LDSSZ)            HIS LENGTH
QFRAR2   DC    A(0)                DECB WORK AREA FOR CKPT ROUTINE
QFRSZ2   DC    A(0)                HIS LENGTH
QFRAR3   DC    A(0)                BUFFERS FOR HASPCKPT & HASPACE(S)
QFRSZ3   DC    A(0)                HIS LENGTH
QFRAR4   DC    A(0)                DCB'S POOL FOR HASPACE(S)
QFRSZ4   DC    A(0)                HIS LENGTH
         SPACE 1
QCOUNTE  DC    PL3'0'
QCOUNTA  DC    PL3'0'
QCOUNTH  DC    PL3'0'
         SPACE 1
QDFREQ   DC    XL1'0'         DUMP FORMAT REQUESTS
QDFSC    EQU   X'80'               SCAN POINTERS SET
QDFSV    EQU   X'40'               SAVED INFO FOR DUMP
QDFRS    EQU   X'20'               RESET REQUEST
QDFEX    EQU   X'01'               EXTENDED
QDFRL    EQU   X'02'               RELATIVE
         SPACE 1
QHFREQ   DC    XL1'0'         HARDCOPY REQUESTS - STATUS
QHCOPY   EQU   X'80'               HARDCOPY ACTIVE
QHCLOSE  EQU   X'40'               CLOSE HARDCOPY
QHFAIL   EQU   X'20'               HARDCOPY OPEN FAILED
         EJECT
*---     DATA-SETS CONTROL BLOCKS                                  ---*
         SPACE 1
HASPCKPT DCB   DDNAME=JES2CKPT,DSORG=PS,MACRF=(RCP),RECFM=U,NCP=3
         SPACE 1
HASPACE  DCB   DDNAME=JES2ACE1,DSORG=DA,MACRF=(RIC),OPTCD=A,RECFM=F
QCDCBL   EQU   *-HASPACE           LENGTH OF HASPACE DCB
         SPACE 1
QCOUT    DCB   DDNAME=JES2SAVE,DSORG=PS,MACRF=(PM),                    1
               EXLST=QCOLST,SYNAD=SV$DCBSA
         SPACE 1
         READ  HDECB1,SF,*-*,,'S',MF=L
HDECB1L  EQU   *-HDECB1            LENGTH OF DECB FOR HASPCKPT
         SPACE 1
         READ  HDECB2,DI,*-*,,0,0,*-*,MF=L
         SPACE 1
QCOPEN   OPEN  (*-*,OUTPUT),MF=L
QCERR    DC    F'0'
         SPACE 1
HOCKPT   OPEN  (*-*),MF=L
         EJECT
INT#DCB  DCB    MACRF=E,DSORG=PS,DDNAME=JES2CKPT
         SPACE 1
INT#RDJF RDJFCB (*-*),MF=L
INT#ELST DC     0F'0',X'87',AL3(*-*)
INT#JFCB DC     0D'0',XL176'00'
         EJECT
*---     MISCELLANEOUS WORK AREAS
         SPACE 1
         $TEW$WA
TOTLNES  DC    F'0'                TOTAL LINES
TOTCPU   DC    F'0'                TOTAL CPU
TOTIO    DC    F'0'                TOTAL I/O
TIMESC   DC    A(2*100)            2.00 SEC SCAN INTERVAL
TIMEVL   DC    F'0'                TIME COUNTER
TIMECT   DC    A(TDFLT)            TIME COUNTER VALUE
TIMEVLM  DC    F'0'                MAX. TIME COUNTER
TIMECTM  DC    A(30*60*100)        MAX. TIME VALUE (30 MIN)
         SPACE 1
TRKLIST  TRKCALC MF=L
         EJECT
XQDWD    DS    0D
DDN@DWD  DC    D'0'
FMT@CONV DC    D'0'                CONVERT WORK DOUBLEWORD
IT#KITF  DC    A(0)                @ FIRST KIT AT INIT TIME
IT#KITL  DC    A(0)                @ LAST KIT AT INIT TIME
IT#DEVTB DC    6F'0'               CKPT DEVICE DEVTYPE INFO
IT#CKRT  DC    F'0'                4K BLOCKS/TRK ON CKPT DEVICE
PRIORITY DC    3F'0'
P#OFFSET DC    H'0'
LENGTH   DC    H'0'
FIELD    DC    CL8' '
RPASS    DC    CL8' '
         DS    0F
DSNCKPT  DC    H'13',CL44'SYS1.HASPCKPT'
DSNSPACE DC    H'12',CL44'SYS1.HASPACE'
DSNAME   DC    H'0',CL44' '
SWITCH   DC    X'0'
SPINDONE EQU   X'01'               SPIN IOT SEARCHED
DSFOUND  EQU   X'02'               DATA-SET FOUND
DDN@SW   DC    X'0'
SW@SPIN  EQU   X'01'               THIS IS A SPIN DSID
SW@FOUND EQU   X'02'               DSID FOUND IN PDDB 5
SW@HELD  EQU   X'04'               THIS IS A HELD DATA-SET
SW@END   EQU   X'80'               END OF TABLE INDICATOR
BUFFER   DC    CL256' '
XQLINE   DS    0CL80
FMT@LINE DC    CL80' '             HEX OUTPUT AREA
FMT@HEXW DC    CL71' '             HEX WORK AREA
HEXTAB   DC    CL16'0123456789ABCDEF'   HEX TABLE TRANSLATION
         SPACE 1
QLCOM    EQU   *-QCOMMON --------- USING LIMIT FOR QCOMMON -----------*
         EJECT
*---     DISPLAY WORK FIELDS                                       ---*
         SPACE 1
QDISPLAY DS    0D                  START OS DISPLAY WORK AREA
QDREPLYL EQU   66                  LENGTH OF REPLY AREA
PFREPLY  DS    0XL(6+QDREPLYL)
PFCODE   DC    XL6'0'
PFTXT    DC    XL(QDREPLYL)'0'
QDMSGA   DC    A(0)                ADDRESS OF MSG TO BE DISPLAYED
QDMLNG   DC    H'0'                MESSAGE LENGTH
         SPACE 1
QDMSG    DS    0CL80               AREA FOR BUILDING OUTPUT LINE
PGMNAME  DS    CL8
         DS    CL2
PROCNAME DS    CL8
         DS    CL6
STEPNAME DS    CL8
         DS    CL2
PROCSTEP DS    CL8
         DS    CL3
DDN      DS    CL8
         DS    CL3
DSID     DS    CL4
         DS    CL2
HELD     DS    CL2                 'H-' OR BLANK
DSTYPE   DS    CL6                 'SYSOUT' OR 'SYSIN'
RECORDS  DS    CL8
         ORG   QDMSG
         DS    CL1
QTYPE    DS    CL1
         DS    CL1
CLASS    DS    CL1
         DS    CL3
QTCOUNT  DS    CL6
         DS    CL7
QECOUNT  DS    CL3
         DS    CL6
QACOUNT  DS    CL3
         DS    CL5
QHCOUNT  DS    CL3
         DS    CL3
QTRECS   DS    CL6
         ORG   QDMSG
FCLEAR   DS    0CL80               FORMAT FOR QUEUE RECORDS
FQNAME   DS    0CL4,C              NAME OF QUEUE (I,X,O,TSU,SYS,H/O)
         DS    C
FQUEUE   DS    CL2                 CLASS NAME (IF FQNAME=I, X OR O)
         DS    C
FCOUNT   DS    CL4                 POSITION IN QUEUE
         DS    C
FNAME    DS    CL8                 JOB NAME
         DS    C
FJOBNO   DS    CL5                 JES2 JOB NUMBER
         DS    C
FPRIO    DS    CL2                 JOB PRIORITY
         DS    C
FLINES   DS    CL6                 NUMBER OF OUTPUT LINES
         DS    C
FSYSID   DS    CL4                 SYSTEM ID
         DS    C
FHOLD    DS    CL1                 JOB HOLD STATUS
         DS    C
FDEV     DS    CL4                 PRINTING
FCPU     EQU   FDEV+1,9            REQUESTED CPU TIME
         DS    C
FFORM    DS    CL8                 FORM NAME
         DS    C
FFCB     DS    CL4                 FCB NAME
FIO      EQU   FFCB,6              REQUESTED I/O
         DS    C
FUCS     DS    CL4                 UCS NAME
         DS    C
FREMOTE  DS    CL4                 REMOTE JOB (RJE)
         AIF   ('&SYSPARM' NE 'CJS').CJS4
         DS    C                                                  -CJS-
FCJSID   DS    CL8                 NET ID (CJS)                   -CJS-
.CJS4    ORG   QDMSG
         DS    C
FHEXNM1  DS    CL5
         DS    C
FHEXSP1  DS    CL1
         DS    C
FHEXRP1  DS    CL6
         DS    C
FHEXNM2  DS    CL8
         DS    C
FHEXSP2  DS    CL1
         DS    C
FHEXRP2  DS    CL6
         DS    C
FHEXNM3  DS    CL8
         DS    C
FHEXSP3  DS    CL1
         DS    C
FHEXRP3  DS    CL6
         ORG   QDMSG
         DS    C
FHEXID   DS    CL5
         DS    C
FHEXDATA DS    CL72
         ORG   QDMSG
LPDSID   DS    CL8
         DS    CL1
LPFLAG1  DS    CL6
         DS    CL1
LPRECCT  DS    CL8
         DS    CL2
LPCLASS  DS    CL1
         DS    CL2
LPMTTR   DS    CL8
         DS    CL1
LPMTTRL  DS    CL8
         DS    CL2
LPNPROC  DS    CL8
         DS    CL1
LPNSTEP  DS    CL8
         DS    CL1
LPNDDNM  DS    CL8
         ORG   QDMSG
         DS    C
IDIN#    DS    CL2                 PIT ID
         DS    CL3
IDSTAT   DS    CL8                 PIT STATUS
         DS    CL2
IDCLS    DS    CL36                PIT CLASSES
         DS    CL2
IDJOBNM  DS    CL8                 JOB NAME
         DS    C
IDJOB#   DS    CL6                 JOB NUMBER
         ORG   QDMSG
TGUJOBID DS    CL6                 JOB NUMBER
         DS    CL1
TGUJNAME DS    CL8                 JOB NAME
TGU#TGPS DS    CL8                 NUMBER OF TRACK GROUPS
TGUTGPCT DS    CL7                 % OF TOTAL TRACK GROUPS
         DS    CL1
TGUACT   DS    CL4                 ACTIVE SYSTEM NAME
         DS    CL10
TGU$TGPS DS    CL8                 NUMBER OF TRACK GROUPS
TGU$JOBS DS    CL8                 NUMBER OF JOBS W/TGPS
TGU$PCT  DS    CL7                 % OF JOBS
         ORG   QDMSG
         DS    XL2                 TO SET SF=(PROT,PROT)
         DS    CL6
TGPTOTAL DS    CL8                 'TOTAL : '
TGT#TGPS DS    CL8                 NUMBER OF TRACK GROUPS
TGTTGPCT DS    CL7                 % OF TOTAL TRACK GROUPS
         DS    CL15
TGJTOTAL DS    CL8                 'TOTAL : '
TGT$JOBS DS    CL8                 NUMBER OF JOBS W/TGPS
         ORG   QDMSG
         DC    CL80' '             SET OUTPUT LINE BUILD TO BLANKS
         SPACE 1
QDRLNG   DC    H'6'                REPLY LENGTH
QDREPLY  DC    CL(QDREPLYL)'STATUS'     TERMINAL USER REPLY
QDRLNGP  DC    H'6'                SAVE REPLY LENGTH
QDPROMPT DC    CL(QDREPLYL)'STATUS'     HIS PREVIOUS COMMAND
QDOVER   DC    X'00'               INDICATORS
QOVPAGE  EQU   X'01'               PAGE OVERFLOW INDICATOR
QPFORCE  EQU   X'02'               PAGE FORCE INDICATOR
QESKIP   EQU   X'04'               END OF DATA SKIP INDICATOR
QTSKIP   EQU   X'08'               TRANSLATE SKIP INDICATOR
QAUTOM   EQU   X'10'               AUTOMATIC DISPLAY
QAUTCMD  EQU   X'20'               AUTOMATIC DISPLAY ELIGIBILITY
QDAMAGE  EQU   X'40'               DAMAGED CLOCKS
QPROMPT  EQU   X'80'               REPROMPT HEADING LINE RESTORE
QDPRSW   DC    X'00'               INDICATORS
QAUTPIA  EQU   X'01'               PRESERVE INPUT AREA (AUTOMATIC)
QRPVCMD  EQU   X'02'               RESTORE PREVIOUS SUB-COMMAND
QDNEXT   DC    H'0'                CURRENT LINE NUMBER ON SCREEN
QDSCREEN $FS   CC=W,MF=L           DISPLAY SCREEN
QDSCRWCC $FS   WCC=(RMDT),SBA=(24,80),MF=L
         $FS   SBA=(1,1),MF=L
         SPACE 1
*---     NOTE : THE FIRST DISPLAY FIELD IS PROT                    ---*
*---            NORM FROM ATTR BYTE AT (2,80)                      ---*
         SPACE 1
         $FS   RA=(1,31,'-'),MF=L  RA TO (1,31) C'-'
         $FS   SF=(PROT,INT),MF=L  ATTR - PROT BRIGHT
         DC    C'QUEUE/SPOOL'      TITLE IN CENTER OF TOP LINE
         $FS   SF=(PROT),MF=L      ATTR - PROT NORM
         $FS   RA=(1,74,'-'),MF=L  RA TO (1,74) C'-'
         $FS   SF=(PROT,INT),MF=L  ATTR - PROT BRIGHT
QDMORE   DC    CL6' '              INDICATES MORE TO BE DISPLAYED
         DC    C'COMMAND ===>'     SHOW HIM WHERE TO TYPE
         $FS   SBA=(2,80),MF=L     SBA TO (2,80) - SKIP OVER INPUT
         $FS   SF=(PROT,INT),MF=L  ATTR - PROT BRIGHT
         SPACE 1
QDHLINE  DS    0CL79               HEADING LINE
         DS    CL34'JOB XXXXXXXX, DSID XXXXXXXX, REC #'
HREC     DS    CL8
HEND     DS    CL25', END OF DATA. LAST REC #'
HREND    DS    CL8
         ORG   QDHLINE
         DC    CL79' '             SET HEADING LINE TO BLANKS
         SPACE 1
         $FS   SF=(PROT),MF=L      ATTR - PROT NORM
QDLINE1  DC    CL80' '             FIRST MESSAGE LINE ON SCREEN
         DC    20CL80' '           NEXT 20 LINES
QDFINAL  $FS   SBA=(2,13),MF=L     SBA TO (2,13) - START OF INPUT
         $FS   SF=NORMAL,MF=L      ATTR - INPUT NORM
QDTLINE  DC    XL(QDREPLYL)'0'     INPUT AREA / LAST COMMAND
         $FS   SBA=(1,1),SF=(PT,IC),MF=L
*                                  PT TO FIRST INPUT FIELD; IC
*                                  (TCAM REQUIRES CURSOR AT END)
QDPAST   EQU   *                   POINTER TO PAST LAST CHAR
QDSLNG   EQU   *-QDFINAL           LENGTH OF INPUT MANAGEMENT
         SPACE 1
QDHSAVE  DC    CL79' '             SAVE HEADING LINE ON REPROMPT
         EJECT
QCPFKSW  DC    X'00'               PF-KEYS SWITCHES
PFDAAL   EQU   X'01'                    DATA-SET ALLOCATED
PFDAOP   EQU   X'02'                    DATA-SET OPENED
PFDAIN   EQU   X'04'                    DATA-SET UPDATE IN PLACE
PFDAERR  EQU   X'10'                    I/O ERROR (SYNAD ENTERED)
PFDAABN  EQU   X'20'                    DCB ABEND ENTERED
PFLRERR  EQU   X'40'                    LRECL ERROR (OPEN EXIT)
PFRFERR  EQU   X'80'                    RECFM ERROR (OPEN EXIT)
QCPFMEM  DC    CL8' '              PF-KEYS MEMBER NAME
         SPACE 1
*---     DEFAULT PF-KEYS DEFINITIONS                               ---*
         SPACE 1
PFKTAB   DS    0XL26
         DC    XL1'F1',CL25'H     '               PF1
         DC    XL1'F2',CL25'*     '               PF2
         DC    XL1'F3',CL25'E     '               PF3
         DC    XL1'F4',CL25'DA    '               PF4
         DC    XL1'F5',CL25'F     '               PF5
         DC    XL1'F6',CL25'DI    '               PF6
         DC    XL1'F7',CL25'-   21'               PF7
         DC    XL1'F8',CL25'+   21'               PF8
         DC    XL1'F9',CL25'DO    '               PF9
         DC    XL1'7A',CL25'CO   1'               PF10
         DC    XL1'7B',CL25'CO  41'               PF11
         DC    XL1'7C',CL25'ST    '               PF12
         DC    XL1'C1',CL25'H     '               PF13
         DC    XL1'C2',CL25'*     '               PF14
         DC    XL1'C3',CL25'E     '               PF15
         DC    XL1'C4',CL25'DA    '               PF16
         DC    XL1'C5',CL25'F     '               PF17
         DC    XL1'C6',CL25'DI    '               PF18
         DC    XL1'C7',CL25'-   21'               PF19
         DC    XL1'C8',CL25'+   21'               PF20
         DC    XL1'C9',CL25'DO    '               PF21
         DC    XL1'4A',CL25'CO   1'               PF22
         DC    XL1'4B',CL25'CO  41'               PF23
         DC    XL1'4C',CL25'ST    '               PF24
PFKTABL  EQU   *-PFKTAB
PFKNO    EQU   (PFKTABL/L'PFKTAB)
PFKSVL   EQU   ((PFKTABL+79)/80)*80
         SPACE 1
QCPFKOP  OPEN  (*-*,UPDAT),MF=L
QCPFKCL  CLOSE (*-*),MF=L
QCPFSV   DC    5F'0'               SYNAD SAVE AREA (R13-R1)
QCSCCRC  DC    F'0'                SAVE ABEND CODES
         SPACE 1
QCPFKPO  DCB   DDNAME=QSP$PFK,DSORG=PO,MACRF=(R),EXLST=LSPFXLS
QCPFKPOL EQU   *-QCPFKPO
QCPFKPS  DCB   DDNAME=QSP$PFK,DSORG=PS,MACRF=(R,W),                    1
               EXLST=LSPFXLS,SYNAD=LSPFERR,EODAD=LSPFEND
         READ  QCPDECB,SF,,,'S',MF=L
QCPFKPSL EQU   *-QCPFKPS
         SPACE 1
QLDIS    EQU   *-QDISPLAY -------- USING LIMIT FOR QDISPLAY ----------*
         EJECT
*---     CHECKPOINT WORK AREAS                                     ---*
         SPACE 1
QCKPT    DS    0D
QCDECBPT DC    A(0)                @ DECB WORK AREA FOR CKPT ROUTINE
         SPACE 1
QCJQECA  DC    A(0)                ADDR CURRENT JQE (SELECTED JOB)
QCTRAK   DS    0F                  DISK ADDR IN THE FORM MTTR
QCTRAKM  DC    XL1'0'              EXTENT NUMBER
QCTRAKTT DC    XL2'0'              ABSOLUTE TRACK NUMBER
QCTRAKR  DC    XL1'0'              RECORD NUMBER
         DC    X'0'                EXTRA SPACE NEEDED FOR HEX CONV
QCDAD    DS    0XL8                DISK ADDR IN THE FORM MBBCCHHR
QCDADM   DC    XL1'0'              EXTENT NUMBER
QCDADBB  DC    XL2'0'              BIN NUMBER
QCDADCC  DC    XL2'0'              CYLINDER NUMBER
QCDADHH  DC    XL2'0'              HEAD NUMBER
QCDADR   DC    XL1'0'              RECORD NUMBER
         DC    XL3'0'              DEAD SPACE TO GET BACK TO FW
         DS    0F
QCCREC   DC    PL4'0'              CURRENT RECORD NUMBER
QCCPTR   DC    A(0)                CURRENT TABLE ADDRESS
QCHREC   DC    PL4'0'              HIGHEST RECORD NUMBER
QCHPTR   DC    A(0)                HIGHEST TABLE ADDRESS
QCSTART  DC    A(0)                ADDRESS OF TABLE START
QCEND    DC    A(0)                ADDRESS OF TABLE END
QCHLINE  DS    0CL80               HEADING LINE FOR LISTDS
         DC    C'JOB '
QCJNAME  DC    CL8' '              JOB NAME
         DC    C'  DSID '
QCDSNO   DC    CL8' '              DATA-SET ID NUMBER
         DC    C'  REC #       1'
         DC    CL40' '
QCLRECL  DC    H'0'                LRECL FOR SAVE
QCRECFM  DC    XL1'0'              RECFM FOR SAVE
         SPACE 1
SWCKPT   DC    XL1'0'              CHECKPOINT SWITCHES PROCESSING
SWCKPTMR EQU   X'01'               READ MASTER RECORD ONLY
SWCKPTDA EQU   X'02'               READ DAS RECORDS ONLY
QCSPOPNL DC    F'0'                @ OF DCB OPEN LIST FOR HASPACE(S)
QCSPDCBP DC    F'0'                @ OF DCB PTRS INDEX BY M*4 (MTTR)
QCSPNMTC DC    F'0'                @ OF # TRK/CYL FOR HASPACE(S)
         EJECT
*---     DAIR WORK AREAS                                           ---*
*---     DATA-SET ALLOCATION FIELDS                                ---*
*---     (ADAPTED FROM SYS1.MACLIB (IKJDAPL,IKJDAP08,18))          ---*
         SPACE 1
DAIRDWD  DC    D'0'
DAIRECB  DC    F'0'                ECB USED BY DAIR
DAIRFLAG DC    XL1'0'              FLAGS FOR ALLOCATE SUBROUTINE
DFALLOC  EQU   X'80'                    ALLOCATE FUNCTION
DFFREE   EQU   X'40'                    FREE FUNCTION
DFABORT  EQU   X'01'                    FREE FUNCTION
         DC    XL3'0'              DEAD SPACE FOR ALLIGNMENT
         SPACE 1
*---     THE DYNAMIC ALLOCATION INTERFACE ROUTINE (DAIR)           ---*
*---     PARAMETER LIST (DAPL) IS A LIST OF ADDRESSES PASSED       ---*
*---     FROM THE INVOKER TO DAIR VIA REGISTER 1                   ---*
         SPACE 1
DAPLUPT  DC    A(0)                PTR TO UPT
DAPLECT  DC    A(0)                PTR TO ECT
DAPLECB  DC    A(0)                PTR TO CP'S ECB
DAPLPSCB DC    A(0)                PTR TO PSCB
DAPLDAPB DC    A(0)                PTR TO DAIR PARAMETER BLOCK
         SPACE 1
*---     DAIR FAILURE PARAMETER LIST                               ---*
         SPACE 1
DFDAPLP  DC    A(0)
DFRCP    DC    A(0)
DFJEFF02 DC    A(0)
DFIDP    DC    A(0)
         SPACE 1
DFRETC   DC    F'0'
DFZERO   DC    F'0'
DFDASW   DC    0H'0',X'0001'
         EJECT
*---     ALLOCATE DDNAME(W) DSNAME(X) SHR UNIT(Y) VOLUME(Z)        ---*
         SPACE 1
DAALCD   DS    0F                  ALLOCATE PARM. LIST
         DC    X'0008'             DAIR ENTRY CODE
DAALFLG  DC    XL1'0'              FLAGS SET BY DAIR
         DC    X'0'
DAALDARC DC    H'0'                DYN ALLOC RETURN CODE
DAALCTRC DC    H'0'                CATALOG RETURN CODE
DAALPDSN DC    A(0)                PTR TO DSN TO BE SRCHED IN DSE
DAALDDN  DC    CL8' '              DDNAME TO BE SEARCHED IN DSE
DAALUNIT DC    CL8' '              UNIT FOR SYS1.HASPCKPT
DAALSER  DC    CL8' '              VOLSER FOR SYS1.HASPCKPT
DAALBLK  DC    F'0'                DATA-SET AVERAGE REC LENGTH
DAALPQTY DC    F'0'                PRIMARY SPACE QUANTITY
DAALSQTY DC    F'0'                SECONDARY SPACE QUANTITY
DAALDQTY DC    F'0'                DIRECTORY BLOCK QUANTITY
DAALMNM  DC    CL8' '              MEMBER NAME
DAALPSWD DC    CL8' '              PASSWORD
DAALDSP1 DC    AL1(DA08SHR)        STATUS FLAGS - SHR
DAALDPS2 DC    AL1(DA08KEEP)       DATA-SET DISPOSITION - KEEP
DAALDPS3 DC    AL1(DA08KEP)        DATA-SET COND. DISP. - KEEP
DAALCTL  DC    X'00'               DAIR ACTION FLAGS
         DC    XL3'0'              RESERVED
DAALDSO  DC    XL1'0'              DSORG
DAALALN  DC    CL8' '              ATTR-LIST-NAME
DAAL$L   EQU   *-DAALUNIT
         SPACE 1
*---     FREE DDNAME(W)                                            ---*
         SPACE 1
DAFRCD   DS    0F                  FREE PARM. LIST
         DC    X'0018'             DAIR ENTRY CODE
DAFRFLG  DC    XL1'0'              FLAGS SET BY DAIR
         DC    X'0'
DAFRDARC DC    H'0'                DYNAMIC ALLOCATION RETURN CODE
DAFRCTRC DC    H'0'                CATALOG RETURN CODE AREA
DAFRPDSN DC    A(0)                PTR TO DSN TO BE SRCHED IN DSE
DAFRDDN  DC    CL8' '              DDNAME TO BE SEARCHED IN DSE
DAFRMNM  DC    CL8' '              MEMBER NAME
DAFRSCLS DC    CL2' '              SYSOUT CLASS DESIRED WHEN
*                                  UNALLOC'ING A SYSOUT DATA-SET
DAFRDPS2 DC    AL1(DA18KEEP)       DATA-SET DISPOSITION - KEEP
DAFRCTL  DC    AL1(DA18PERM)       FLAGS FOR SPECIAL DAIR PROC'ING
DAFRJBNM DC    CL8' '              IGNORED AS OF OS VS/2 RELEASE 2
         EJECT
*---     TRACK GROUPS JOBS USAGE WORK AREAS                        ---*
         SPACE 1
TGTTGPS  DC    F'0'                TOTAL TRACK GROUPS ALLOCATED
TGTJOBS  DC    F'0'                TOTAL NUMBER OF JOBS PROCESSED
TGJQAR   DC    XL(20*8)'0'         20 ENTRIES (JQEADDR, #TGPS)
TGPSAR   DS    0XL(20*8)           20 ENTRIES (# TGPS, # JOBS)
         DC    0F'0',XL4'7FFFFFFF',F'0'
         DC    F'150',F'0'
         DC    F'100',F'0'
         DC    F'80',F'0'
         DC    F'60',F'0'
         DC    F'50',F'0'
         DC    F'40',F'0'
         DC    F'30',F'0'
         DC    F'20',F'0'
         DC    F'15',F'0'
         DC    F'10',F'0'
         DC    F'9',F'0'
         DC    F'8',F'0'
         DC    F'7',F'0'
         DC    F'6',F'0'
         DC    F'5',F'0'
         DC    F'4',F'0'
         DC    F'3',F'0'
         DC    F'2',F'0'
         DC    F'1',F'0'
         SPACE 1
QLCKT    EQU   *-QCKPT ----------- USING LIMIT FOR QCKPT -------------*
         EJECT
*---     SNAP WORK AREAS                                           ---*
         SPACE 1
QSNAP    DS    0F
         SPACE 1
SNAPDCB  DCB   DSORG=PS,RECFM=VBA,MACRF=(W),                           1
               BLKSIZE=1632,LRECL=125,DDNAME=SYSSNAP
SNAPOP   OPEN  (*-*),MF=L
SNAPCL   CLOSE (*-*),MF=L
         SPACE 1
SNAPCTL  SNAP  MF=L
SNAPLST  DC    2F'0'
SNAPHD   DC    F'0'
         SPACE 1
SNAPIDT  DC    XL32'0'             SNAP ID ACTIVE TABLE
         SPACE 1
QSNAPL   EQU   *-QSNAP             SNAP WORK AREAS LENGTH
         SPACE 1
QLSNP    EQU   *-QSNAP ----------- USING LIMIT FOR QSNAP -------------*
         EJECT
*---     HARDCOPY WORK AREAS                                       ---*
         SPACE 1
QPRINT   DS    0F
         SPACE 1
P99RBPTR DC    A(*-*)              SVC 99 REQUEST BLOCK PTR
P99RB    DS    0F                  SVC 99 REQUEST BLOCK
         DC    AL1(P99RBLN)             RB LENGTH IN BYTES
P99VERB  DC    AL1(S99VRBAL)            VERB CODE (DSNAME ALL.)
P99FLAG1 DC    AL1(S99NOCNV+S99NOMNT,0) FLAGS 1
P99ERROR DC    XL2'0'                   ERROR CODE
P99INFO  DC    XL2'0'                   INFO CODE
P99TXTPP DC    A(*-*)                   POINTER TO TEXT UNIT PTRS
P99RSVD1 DC    XL4'0'                   RESERVED
P99FLAG2 DC    XL4'0'                   FLAGS 2
P99RBLN  EQU   *-P99RB                  RB LENGTH
P99TUPL  DS    0F                  TEXT UNIT POINTERS
         DC    A(*-*)                   SYSOUT
         DC    A(*-*)                   FREE AT CLOSE
         DC    A(*-*)                   LAST PARM IF NO DEST=
         DC    A(*-*)                   LAST PARM IF DEST= GIVEN
P99TUKY1 DC    AL2(DALSYSOU),AL2(1),AL2(1)
P99SYSOC DC    C'A'                     SYSOUT=A
P99TUKY2 DC    AL2(DALCLOSE),AL2(0)     UNALLOC AT CLOSE
P99TUKY3 DC    AL2(DALSUSER),AL2(1)     OPTIONAL : DEST=RMTXXX
P99DESTL DC    AL2(*-*)                 LENGTH OF DEST
P99DEST  DC    CL8' '                   DEST PARAMETER
P99TUKY4 DC    AL2(DALRTDDN),AL2(1)     DDNAME RETURN
P99DDNL  DC    AL2(8)                   LENGTH OF DDNAME
P99DDN   DC    CL8' '                   DDNAME
         SPACE 1
HCPYDCB  DCB   DDNAME=QSPHCOPY,DSORG=PS,MACRF=(PM),                    1
               RECFM=FA,LRECL=91,BLKSIZE=91
HCPYOP   OPEN  (*-*),MF=L
HCPYCL   CLOSE (*-*),MF=L
         SPACE 1
BINYEAR  DC    F'0'
BINDAYS  DC    F'0'
BINDATE  DC    F'0'
QHPAGE#  DC    PL3'+1'             PAGE NUMBER
QHLINE#  DC    PL3'+0'             LINES COUNT
HMONMSK  DC    AL1(31,30,31,30,31,31,30,31,30,31,28,31)
         SPACE 1
QHHEAD1  DC    CL1'1',CL10' '      ASA ON HEADING
         DC    CL23'QSP-HARDCOPY LOG  USER='
QHUSER   DC    CL7' ',CL2' '       FOR USERID
         DC    CL4'DATE'
HJDATE   DC    CL7' ',CL3' - '
HTMEHRS  DC    CL2' ',CL1':'
HTMMINS  DC    CL2' ',CL1':'
HTMSECS  DC    CL2' ',CL1' '
HCDAY    DC    CL3' ',CL1' '
HCMON    DC    CL3' ',CL1' '
HCDAYN   DC    CL2' ',CL3',19'
HCYR     DC    CL2' ',CL1' '
QHPAGS   DC    CL1' ',CL2'  '
QHPAGE   DC    CL6' '
         SPACE 1
QHHEAD2  DC    CL1' ',CL10' ',80C'-'
         SPACE 1
QHDETAIL DC    CL1' ',CL10' '      ASA CONTROL CHARACTER
QHLINE   DC    CL80' '             TO HOLD PRINT LINE
         SPACE 1
QPRINTL  EQU   *-QPRINT            HARDCOPY WORK AREAS LENGTH
         SPACE 1
QLPRT    EQU   *-QPRINT ---------- USING LIMIT FOR QPRINT ------------*
         SPACE 1
         CNOP  0,8
         SPACE 1
QCOMMONL EQU   *-QCOMMON --------- LENGTH OF COMMON AREA --------------
         SPACE 1
QWAREAL  EQU   QCOMMONL+WASSZ      ADD SPACE WORK AREA
         TITLE '--- QUEUE/SP -- MISCELLANEOUS DSECTS ---'
*---     TSO COMMANDS/CLIST WORK AREA                              ---*
         SPACE 1
TSOXEQ   DSECT
         SPACE 1
GTPBK    GETLINE MF=L
GTPBLN   EQU   *-GTPBK             LENGTH
         SPACE 1
ATTCH    ATTACH  SHSPV=78,SF=L     NEEDED TO PREVENT S305 ABENDS
ATTLN    EQU   *-ATTCH             LENGTH
         SPACE 1
TSOXTCB  DS    F                   TCB
TSOXECB  DS    F                   ECB
TSOCPPL  DS    4F                  CPPL
TSOIOPL  DS    4F                  GETLINE I/O PARM LIST
TSOCSPL  DS    6F                  IKJSCAN PARM LIST
TSOCSOA  DS    2F                  OUTPUT AREA FROM IKJSCAN
         SPACE 1
TSOBLDL  DS    0XL16               BLDL LIST
TSOBLFF  DS    H                   NUMBER OF ENTRIES IN LIST
TSOBLLL  DS    H                   LENGTH OF EACH ENTRY
TSOBLNM  DS    CL8                 MEMBER NAME
TSOBLTTR DS    XL3                 TTR OF MEMBER START
TSOBLLK  DS    XL1                 CONCATENATION NUMBER
         SPACE 1
TSORSV   DS    2F                  R0-R1 MESSAGE PENDING
TSOPCMD  DS    CL8                 PRIMARY COMMAND NAME
TSOSCMD  DS    CL8                 SECONDARY COMMAND NAME
TSOXCMD  DS    CL84                COMMAND BUFFER
TSOMSG   DS    CL78                MESSAGE BUFFER
         SPACE 1
         CNOP  0,8
TSOXEQL  EQU   *-TSOXEQ            LENGTH
         SPACE 1
CMDBUF   DSECT
CMDLEN   DS    H                   LENGTH, INCLUDES HEADER (+4)
CMDOFF   DS    H                   OFFSET TO NON-BLANK PAST CMD
CMDTEXT  DS    C                   FIRST TEXT BYTE
         SPACE 1
         EJECT
*---     INPUT WORK AREA                                           ---*
         SPACE 1
IN       DSECT
I1       DS    CL8
I2       DS    CL8
I3       DS    CL8
I4       DS    CL8
I5       DS    CL8
I6       DS    CL8
I7       DS    CL8
I8       DS    CL8
         SPACE 1
*---     OUTPUT WORK AREA                                          ---*
         SPACE 1
OUT      DSECT
OLINE1   DS    0CL80
HBOFFSET DS    CL4
         DS    CL2
ODATA1   DS    0CL74
O11      DS    CL8
         DS    C
O12      DS    CL8
         DS    CL2
O13      DS    CL8
         DS    C
O14      DS    CL8
         DS    CL2
O15      DS    CL8
         DS    C
O16      DS    CL8
         DS    CL2
O17      DS    CL8
         DS    C
O18      DS    CL8
OLINE2   DS    0CL80
         DS    CL6
ODATA2   DS    0CL74
O21      DS    CL8
         DS    C
O22      DS    CL8
         DS    CL2
O23      DS    CL8
         DS    C
O24      DS    CL8
         DS    CL2
O25      DS    CL8
         DS    C
O26      DS    CL8
         DS    CL2
O27      DS    CL8
         DS    C
O28      DS    CL8
OLINE3   DS    0CL80
         DS    CL6
ODATA3   DS    0CL74
O31      DS    CL8
         DS    C
O32      DS    CL8
         DS    CL2
O33      DS    CL8
         DS    C
O34      DS    CL8
         DS    CL2
O35      DS    CL8
         DS    C
O36      DS    CL8
         DS    CL2
O37      DS    CL8
         DS    C
O38      DS    CL8
         EJECT
JQTDSECT DSECT ,  - - - - - - SEE $QINDEX IN HASPTABS FOR MORE DETAILS
         SPACE 1
         ORG   JQTDSECT+8
JQTOUT   DC    A(0)
         SPACE 1
         ORG   JQTDSECT+32
JQTSTC   DC    A(0)
         SPACE 1
         ORG   JQTDSECT+36
JQTTSU   DC    A(0)
         SPACE 1
         ORG   JQTDSECT+40
JQTCLSA  DC    A(0)
         SPACE 1
         PRINT NOGEN
         SPACE 1
         $TEW$DS CVT=YES
         IHAPSA
         IHAASCB
UCBDSECT DSECT
         IEFUCBOB
         IKJECT
         IKJCSPL
         IKJCSOA
         IKJGTPB
         IKJDAP08
         IKJDAP18
         IEFVKEYS
         IEFZB4D0
         IEFZB4D2
         DCBD  DSORG=(PS,DA)
         IHADECB
         IEFJESCT TYPE=DSECT
         IEFJSCVT
         $PIT
         IEZDEB
         $SJB
         $TQE
         $XECB
         $SCAT
         $SVT
         $HFAME
         SPACE 1
         PRINT GEN
         SPACE 1
         END
