ZAP      TITLE '--- E T P S -- ETPSZAP - DATA-SET DISPLAY/MODIFY ---'
         PRINT OFF
         COPY  ETPS$O2A            "ETPS" SYSPARM SELECTION
         MACRO
&NAME   @CMD   &CN,&CA
         LCLA  &L
         AIF   ('&CN' NE '').A
         MNOTE 8,' COMMAND NAME MISSING **************************** '
         MEXIT
.A       AIF   ('&CA' NE '').B
         MNOTE 8,' COMMAND ADDRESS MISSING ************************* '
         MEXIT
.B       AIF   ('&CN'(1,1) NE '''').C
&L       SETA  K'&CN-2
         AIF   (&L GT 8).ERR
&NAME    DC    AL1(&L-1),CL8&CN,AL3(&CA)
         MEXIT
.C       ANOP
&L       SETA  K'&CN
         AIF   (&L GT 8).ERR
&NAME    DC    AL1(&L-1),CL8'&CN',AL3(&CA)
         MEXIT
.ERR     MNOTE 8,' COMMAND NAME TOO LONG (MAX.=8) ****************** '
         MEND
         MACRO
&NAME   @IML   &TX
         GBLA  &##
         LCLA  &L,&N,&M
         AIF   ('&TX' EQ 'END').J
&##      SETA  &##+1
         AIF   ('&TX' NE '').A
         MNOTE 8,' LINE IMAGE - TEXT MISSING *********************** '
         MEXIT
.A       ANOP
&N       SETA  1
&L       SETA  K'&TX
         AIF   ('&TX'(&N,1) EQ '''').B
         MNOTE 8,' TEXT - INITIAL QUOTE MISSING ******************** '
         MEXIT
.B       AIF   (&L LT 2).C
         AIF   ('&TX'(&L,1) EQ '''').D
.C       MNOTE 8,' TEXT - FINAL QUOTE MISSING ********************** '
         MEXIT
.D       AIF   (&L GT 2).E
&NAME    DC    XL1'80'
         MEXIT
.E       ANOP
&L       SETA  &L-1
&M       SETA  0
.F       ANOP
&N       SETA  &N+1
&M       SETA  &M+1
         AIF   (&M LE 60).G
         MNOTE 8,' TEXT TOO LONG (MAX. = 60) *********************** '
         MEXIT
.G       AIF   ('&TX'(&N,1) NE '''').I
&N       SETA  &N+1
         AIF   (&N GT &L).H
         AIF   ('&TX'(&N,1) EQ '''').F
.H       MNOTE 8,' QUOTE IN TEXT MUST BE DOUBLED ******************* '
         MEXIT
.I       AIF   (&N LT &L).F
&NAME    DC    AL1(&M-1),CL&M&TX
         MEXIT
.J       ANOP
&NAME    DC    XL1'FF'
.* ---> HELP LINES : FROM LINE 6 TO LINE 18 INCLUDED = 13.
         AIF   (&## LE 13).K
         MNOTE 8,' TOO MANY LINES IN THIS HELP IMAGE *************** '
.K       ANOP
&##      SETA  0
         MEND
         MACRO
&NAME   @HEX   &TO,&FROM,&L,&LEN=,&HEXTAB=,&BYTE=C' ',&DIGITS=
         GBLC  &HEXTAB#
         LCLA  &LT                 UNPK "TO" LENGTH
         LCLA  &LF                 UNPK "FROM" LENGTH
         LCLA  &LTR                TR "TO" LENGTH
         LCLA  &LL                 &LEN ONE WAY OR ANOTHER
         LCLC  &F1,&F2,&T1,&T2,&LX
&HEXTAB# SETC  'HEXTAB'
&F1      SETC  '&FROM(1)'          FOR SHORTER STRING LATER
&F2      SETC  '&FROM(2)'          FOR SHORTER STRING LATER
&T1      SETC  '&TO(1)'            FOR SHORTER STRING LATER
&T2      SETC  '&TO(2)'            FOR SHORTER STRING LATER
&LX      SETC  '&L&LEN'            GET LENGTH USING EITHER METHOD
         AIF   ('&LX' EQ '').DEFLEN LENGTH WILL DEFAULT TO 4
&LL      SETA  &LX                 GET IT
         AGO   .OKLEN
.DEFLEN  ANOP
&LL      SETA  4                   SET THE DEFAULT LENGTH
.OKLEN   AIF   ('&HEXTAB' EQ '').OKHEX1
&HEXTAB# SETC  '&HEXTAB'
.OKHEX1  AIF   ('&HEXTAB#' NE '').OKHEX2
&HEXTAB# SETC  'HEXTAB'
.OKHEX2  ANOP
&LT      SETA  &LL*2
         AIF   ('&DIGITS' EQ '').OKDIGIT
&LT      SETA  &DIGITS
.OKDIGIT AIF   (N'&TO NE 2).TO1
         AIF   (N'&FROM NE 2).T2F1
&NAME    UNPK  &T1.(&LT+1,&T2),&F1.(&LL+1,&F2)
         TR    &T1.(&LT,&T2),&HEXTAB#
         MVI   &T1+&LT.(&T2),&BYTE
         MEXIT
.T2F1    AIF   (N'&FROM NE 1).ERRF
&NAME    UNPK  &T1.(&LT+1,&T2),&FROM.(&LL+1)
         TR    &T1.(&LT,&T2),&HEXTAB#
         MVI   &T1+&LT.(&T2),&BYTE
         MEXIT
.TO1     AIF   (N'&TO NE 1).ERRT
         AIF   (N'&FROM NE 2).T1F1
&NAME    UNPK  &TO.(&LT+1),&F1.(&LL+1,&F2)
         TR    &TO.(&LT),&HEXTAB#
         MVI   &TO+&LT,&BYTE
         MEXIT
.T1F1    AIF   (N'&FROM NE 1).ERRF
&NAME    UNPK  &TO.(&LT+1),&FROM.(&LL+1)
         TR    &TO.(&LT),&HEXTAB#
         MVI   &TO+&LT,&BYTE
         MEXIT
.ERRF    MNOTE 8,' ERROR IN "FROM" PARAMETER *********************** '
         MEXIT
.ERRT    MNOTE 8,' ERROR IN "TO" PARAMETER ************************* '
         MEND
         MACRO
&NAME   @OP    &M,&F,&O
         GBLA  &#
         LCLC  &F$
&F$      SETC  '&F'
         AIF   ('&F'(1,1) NE '''').OK
&F$      SETC  '&F'(2,1)
.OK      ANOP
&#       SETA  &#+1
@&O      EQU   &#
&NAME    DC    CL4'&M',C'&F$',X'&O'
         MEND
         MACRO
        @SST   &DUMMY
SSTAB    DS    0F                  START SENSITIVE PREFIXES TABLE
         GBLA  &ZSSN
         GBLC  &ZSSE(1)
         LCLA  &L,&M,&N
         AIF   (&ZSSN EQ 0).B
&N       SETA  1
.A       AIF   (&N GT &ZSSN).B
&M       SETA  K'&ZSSE(&N)
&L       SETA  &M-1
         DC    AL1(&L),CL&M'&ZSSE(&N)'
&N       SETA  &N+1
         AGO   .A
.B       DC    XL1'FF'             END OF TABLE
         SPACE 1
         MEND
         COPY  ETPSMACS            "ETPS" MACROS
         COPY  ETPSDEFS            "ETPS" DEFINITIONS
         PRINT ON
ETPSZAP  START 0
         SPACE 1
ETPSZAP  AMODE 24
ETPSZAP  RMODE 24
        MIDENT
         EJECT
*------- ZAP SELECT DATA-SET PROCESS --------------------------------*
         PRINT GEN
         USING *,R12,R11
         USING SAVE2,R13      ************************** R13 ==> SAVE2
         USING SPLTAREA,R10   AT ENTRY : R10 MUST POINT TO "SPLTAREA"
         B     32(,R15)
         DC    CL28'  ETPSZAP  &SYSDATE &SYSTIME'
         PRINT &PRF
         STM   R14,R12,12(R13)     SAVE INPUT REGISTERS
         LR    R12,R15             SET PROGRAM BASE REGISTER 1
         LA    R3,1
         LA    R11,4*KB-1(R3,R12)  SET PROGRAM BASE REGISTER 2
         LR    R3,R10              SPLIT-SCREEN DSECT
         SH    R3,=Y(SPLITWRK-SAVE2) POINT TO SAVE2
         ST    R13,4(,R3)          STORE BACKWARD POINTER
         ST    R3,8(R13)           STORE FORWARD POINTER
         LR    R13,R3              SET DSECT BASE
         OI    ZAPPASS,C' '
         CLI   ZAPPASS,C' '        IS THERE A GIVEN PASSWORD?
         BNE   ZSCRBLD             YES
         MVC   ZAPPASS,USERPASS    ELSE SET IT TO LOGON PASSWORD
*- - - - BUILD ZAP SELECT ENTRY SCREEN
ZSCRBLD  L     R5,=A(ZAPSCR)
         L     R4,SCROWS1          NUMBER OF ROWS IN SCREEN 1
         LA    R3,TERMOUT+4        POINT TO FIRST LINE OF SCREEN 1
         CLI   SPLIT,2             AM I ON SCREEN 2
         BNE   ZSCRBLD1            NOPE, I'M ALL SET
         SLL   R4,2                MULTIPLY OFFSET BY 4
         LA    R3,TERMOUT+4(R4)    POINT TO ROW 1 OF SCREEN 2
         L     R4,SCROWS2          NUMBER OF ROWS IN SCREEN 2
ZSCRBLD1 NI    0(R3),255-EOS       CLEAR END-OF-SCREEN
         L     R2,0(,R5)           ADDRESS OF FROM FIELD
         L     R6,0(,R3)           ADDRESS OF "TO" FIELD
         XR    R1,R1
         IC    R1,0(,R2)           PICK UP LENGTH
         EX    R1,ZSCRMVL          MOVE IT
         CLC   ZAOFF1(10,R6),=CL10'FULLY-QUAL' DS-NAME?
         BNE   ZSCRBLD2            NO
         OI    ZAPDSNM,C' '
         CLI   ZAPDSNM,C' '        IS THERE A DATA-SET NAME SPECIFIED?
         BE    ZSCRBLD4            NO
         MVC   ZASCF1(L'ZAPDSNM,R6),ZAPDSNM COPY CURRENT DATA-SET NAME
         B     ZSCRBLD4            DO THE REST
ZSCRMVL  MVC   0(*-*,R6),0(R2)     <<EXECUTED>>
ZSCRBLD2 CLC   ZAOFF2(13,R6),=CL13'VOLUME SERIAL' VOL-SER?
         BNE   ZSCRBLD3            NO
         OC    ZAPVOL,=CL6' '
         CLI   ZAPVOL,C' '         IS THERE A VOL-SER SPECIFIED?
         BE    ZSCRBLD4            NO
         MVC   ZASCF2(L'ZASCF2,R6),ZAPVOL  COPY CURRENT VOL-SER
         B     ZSCRBLD4            DO THE REST
ZSCRBLD3 CLC   ZAOFF3(17,R6),=CL17'DATA-SET PASSWORD' PASSWORD?
         BNE   ZSCRBLD4            NO
         MVC   ZASCF3(L'ZASCF3,R6),ZAPPASS COPY CURRENT PASSWORD
         CLI   ZAPPASS,C' '        IS THERE A PASSWORD SPECIFIED?
         BE    ZSCRBLD4            NO
         MVC   ZAOFF4(L'ZAOFF4,R6),=CL3'(I)' SAY IN
         MVI   ZAOFF4-1(R6),X'05'  SET INTENS
ZSCRBLD4 TM    0(R5),EOL           END-OF-LIST?
         BO    ZSCRBLD5            YUP
         BCT   R4,*+L'*+4          END OF SCREEN ROWS?
         B     ZSCRBLD6            YUP
         LA    R5,4(R5)            BUMP TO NEXT PARM
         LA    R3,4(R3)            BUMP TO NEXT PARM
         B     ZSCRBLD1            KEEP LOOPING
ZSCRBLD5 BCT   R4,*+L'*+4          END OF SCREEN ROWS?
         BZ    ZSCRBLD6            YUP
         LA    R3,4(R3)            BUMP TO NEXT PARM
         L     R6,0(,R3)           ADDRESS OF "TO" FIELD
         NI    0(R3),255-EOS       CLEAR END-OF-SCREEN
         MVC   0(ZDUMMYL,R6),ZDUMMY MOVE IN A DUMMY ROW
         B     ZSCRBLD5            KEEP LOOPING
ZSCRBLD6 CLI   SPLIT,1             AM I IN SPLIT-SCREEN, SCREEN 1?
         BE    *+L'*+4             YES
         OI    0(R3),EOS           SET END-OF-SCREEN
         L     R15,=A(ZAPHLP)      HELP SCREEN
         ST    R15,HELPADD
         MVI   CURROW,CRZASC       CURSOR ROW
         MVI   CURCOL,CCZASC       CURSOR COLUMN
         L     R15,ARCOMM          GO COMMUNICATE
*- - - - ETPSCOMM PARM.LIST : NONE
        CALL   (15)
         LTR   R15,R15             BAD RC?
         BNZ   ZEXIT               YUP
         TM    COMMSW,PFKFLAG      IS IT A PF KEY/ATTN?
         BZ    ZACKINPT            NOPE, GO CHECK THE INPUT
         L     R2,TERMINPT         PICK UP AID ADDRESS
         CLI   0(R2),X'F3'         IS IT PF3?
         BE    ZEXIT               YUP, I'M DONE
         CLI   0(R2),X'C3'         IS IT PF15?
         BE    ZEXIT               YUP, I'M DONE
         CLI   0(R2),X'6C'         IS IT PA1?
         BE    ZEXIT               YUP, I'M DONE
         CLI   0(R2),X'6D'         IS IT "CLEAR"?
         BE    ZSCRBLD             YUP, RESHOW SCREEN
         CLI   0(R2),X'6E'         IS IT PA2?
         BE    ZSCRBLD             YUP, RESHOW SCREEN
         LA    R1,ZINVPFK
ZASTMSG  ST    R1,MSGADD
         B     ZSCRBLD             RESHOW SCREEN
*- - - - CHECK ENTERED ZAP SELECTIONS
ZACKINPT L     R5,TERMINPT+ZIZ1    PICK UP DS-NAME FIELD
         L     R6,TERMINPT+ZIZ2    PICK UP VOL-SER FIELD
         L     R7,TERMINPT+ZIZ3    PICK UP PASSWORD FIELD
         CLI   SPLIT,2             AM I ON SCREEN 2?
         BNE   ZACKINPC            NOPE
         L     R3,SCROWS1          PICK UP SIZE OF SCREEN 1
         SLL   R3,2                MULTIPLY BY 4
         L     R5,TERMINPT+ZIZ1(R3) PICK UP DS-NAME FIELD
         L     R6,TERMINPT+ZIZ2(R3) PICK UP VOL-SER FIELD
         L     R7,TERMINPT+ZIZ3(R3) PICK UP PASSWORD FIELD
ZACKINPC CLI   0(R5),0             DS-NAME ENTERED (OR CHANGED)?
         BNE   *+L'*+16            YES
         OI    ZAPDSNM,C' '
         CLI   ZAPDSNM,C' '        DS-NAME ALREADY IN?
         BNE   ZACVLSR             YES
         B     ZSCRBLD             ELSE RETRY THE SCREEN
         LA    R0,L'ZASCF1-1       LEFT JUSTIFY FIELD IF NEEDED
         CLI   ZASCF1(R5),C' '
         BNE   ZADSNMV
         MVC   ZASCF1(L'ZASCF1-1,R5),ZASCF1+1(R5)
         MVI   ZASCF1+L'ZASCF1-1(R5),C' '
         BCT   R0,*-18
         MVC   ZAPDSNM(L'ZAPDSNM),ZASCF1(R5)
         B     ZSCRBLD             RETRY THE SCREEN
ZADSNMV  MVI   ZAPDSNM,C' '        RESET DS-NAME FIELD
         MVC   ZAPDSNM+1(L'ZAPDSNM-1),ZAPDSNM
         LA    R0,L'ZAPDSNM        MAX. LENGTH FOR A DS-NAME
         LA    R14,ZASCF1(R5)      START ADDRESS FOR DSN LENGTH CALC
         XR    R15,R15             SET COUNTER
ZADSNLOP CLI   0(R14),C' '         BLANK IS END OF DSN?
         BE    ZADSNEND            GOT END
         CLI   0(R14),C'('         LEFT PAREN INDICATES MEMBER?
         BE    ZADSNEND            YES, GOT END
         LA    R14,1(R14)          BUMP ADDRESS
         LA    R15,1(R15)          BUMP COUNTER
         BCT   R0,ZADSNLOP         TEST NEXT BYTE IF ANY
         LA    R1,ZBADDSN          ELSE ERROR
         B     ZASTMSG
ZADSNEND BCT   R15,*+L'*+6         SUBTRACT 1
         MVC   ZAPDSNM(*-*),ZASCF1(R5) <<EXECUTED>>
         EX    R15,*-6
ZACVLSR  CLI   0(R6),0             VOL-SER ENTERED?
         BE    ZACPSWD             NO
         MVC   ZAPVOL,=CL6' '
         LA    R0,L'ZASCF2-1       LEFT JUSTIFY FIELD IF NEEDED
         CLI   ZASCF2(R6),C' '
         BNE   *+L'*+14
         MVC   ZASCF2(L'ZASCF2-1,R6),ZASCF2+1(R6)
         MVI   ZASCF2+L'ZASCF2-1(R6),C' '
         BCT   R0,*-18
         MVC   ZAPVOL(6),ZASCF2(R6) MOVE IN THE VOL-SER
ZACPSWD  CLI   0(R7),0             PASSWORD ENTERED?
         BE    ZAGOCHK             NO
         LA    R0,L'ZASCF3-1       LEFT JUSTIFY FIELD IF NEEDED
         CLI   ZASCF3(R7),C' '
         BNE   *+L'*+14
         MVC   ZASCF3(L'ZASCF3-1,R7),ZASCF3+1(R7)
         MVI   ZASCF3+L'ZASCF3-1(R7),C' '
         BCT   R0,*-18
         MVC   ZAPPASS(L'ZAPPASS),ZASCF3(R7) MOVE IN THE PASSWORD
ZAGOCHK  CLC   ZAPDSNM(5),=CL5'VTOC '
         BNE   ZAGOXEQ
         OC    ZAPVOL,=CL6' '
         CLI   ZAPVOL,C' '         IS THERE A VOL-SER SPECIFIED?
         BNE   *+L'*+8             YES, OK
         LA    R1,ZVLMISS          NO, MISSING
         B     ZASTMSG
         MVC   ZAPDSNM(12),=CL12'FORMAT4.DSCB'
ZAGOXEQ  MVI   ZAPLGDSN,C' '       CLEAR "LOG" DS-NAME
         MVC   ZAPLGDSN+1(L'ZAPLGDSN-1),ZAPLGDSN
         MVC   ZAPLGVOL(L'ZAPLGVOL),ZAPLGDSN CLEAR "LOG" VOL-SER
         L     R15,=A(ETPSXZAP)
*- - - - ETPSXZAP PARM.LIST : DS-NAME, VOL-SER, PASSWORD, LOG.DS-NAME,
*                             LOG.VOL-SER
        CALL   (15),(ZAPDSNM,ZAPVOL,ZAPPASS,ZAPLGDSN,ZAPLGVOL),VL,     X
               MF=(E,PARMVL)
         LTR   R15,R15             HOW COMPLETE?
         BZ    ZOKRST              OK
        XMESS  3010,R15            ERROR
         LA    R1,ZGMMSG
         ST    R1,MSGADD
ZOKRST   CLC   ZAPDSNM(12),=CL12'FORMAT4.DSCB'
         BNE   ZLGTST
         MVI   ZAPDSNM,C' '        CLEAR VTOC REQUEST
         MVC   ZAPDSNM+1(L'ZAPDSNM-1),ZAPDSNM
         MVC   ZAPVOL,=CL6' '
ZLGTST   CLI   ZAPLGDSN,C' '       IS THERE A "LOG" DS-NAME?
         BE    ZSCRBLD             NO
*- - - - BUILD ZAP LOG ENTRY SCREEN
         NI    ZLGSW,255-ZLGVIEW-ZLGDEL-ZLGALT RESET ALL
ZLGSBLD  L     R5,=A(ZLGSCR)
         L     R4,SCROWS1          NUMBER OF ROWS IN SCREEN 1
         LA    R3,TERMOUT+4        POINT TO FIRST LINE OF SCREEN 1
         CLI   SPLIT,2             AM I ON SCREEN 2
         BNE   ZLGSBLD1            NOPE, I'M ALL SET
         SLL   R4,2                MULTIPLY OFFSET BY 4
         LA    R3,TERMOUT+4(R4)    POINT TO ROW 1 OF SCREEN 2
         L     R4,SCROWS2          NUMBER OF ROWS IN SCREEN 2
ZLGSBLD1 NI    0(R3),255-EOS       CLEAR END-OF-SCREEN
         L     R2,0(,R5)           ADDRESS OF FROM FIELD
         L     R6,0(,R3)           ADDRESS OF "TO" FIELD
         XR    R1,R1
         IC    R1,0(,R2)           PICK UP LENGTH
         EX    R1,ZLGSMVL          MOVE IT
         CLC   ZLOFF1(8,R6),=CL8'LOG VIEW' VIEWING?
         BNE   ZLGSBLD2            NO
         TM    ZLGSW,ZLGVIEW       YES
         BO    *+L'*+10
         MVC   ZLSCF1(2,R6),=CL2'NO' SET "NO"
         B     ZLGSBLD3            DO THE REST
         MVC   ZLSCF1(3,R6),=CL3'YES' SET "YES"
         B     ZLGSBLD3            DO THE REST
ZLGSMVL  MVC   0(*-*,R6),0(R2)     <<EXECUTED>>
ZLGSBLD2 CLC   ZLOFF2(8,R6),=CL8'AND / OR' DELETE?
         BNE   ZLGSBLD3            NO
         TM    ZLGSW,ZLGDEL        YES
         BO    *+L'*+10
         MVC   ZLSCF2(2,R6),=CL2'NO' SET "NO"
         B     ZLGSBLD3            DO THE REST
         MVC   ZLSCF2(3,R6),=CL3'YES' SET "YES"
ZLGSBLD3 TM    0(R5),EOL           END-OF-LIST?
         BO    ZLGSBLD4            YUP
         BCT   R4,*+L'*+4          END OF SCREEN ROWS?
         B     ZLGSBLD5            YUP
         LA    R5,4(R5)            BUMP TO NEXT PARM
         LA    R3,4(R3)            BUMP TO NEXT PARM
         B     ZLGSBLD1            KEEP LOOPING
ZLGSBLD4 BCT   R4,*+L'*+4          END OF SCREEN ROWS?
         B     ZLGSBLD5            YUP
         LA    R3,4(R3)            BUMP TO NEXT PARM
         L     R6,0(,R3)           ADDRESS OF "TO" FIELD
         NI    0(R3),255-EOS       CLEAR END-OF-SCREEN
         MVC   0(ZDUMMYL,R6),ZDUMMY MOVE IN A DUMMY ROW
         B     ZLGSBLD4            KEEP LOOPING
ZLGSBLD5 CLI   SPLIT,1             AM I IN SPLIT-SCREEN, SCREEN 1?
         BE    *+L'*+4             YES
         OI    0(R3),EOS           SET END-OF-SCREEN
         L     R15,=A(ZLGHELP)     HELP SCREEN
         ST    R15,HELPADD
         TM    ZLGSW,ZLGALT        ALTERNATE POSITION?
         BO    *+L'*+12            YES
         MVI   CURROW,CRZLSC       CURSOR ROW
         MVI   CURCOL,CCZLSC       CURSOR COLUMN
         B     *+L'*+8
         MVI   CURROW,CRALSC       ALTERNATE CURSOR ROW
         MVI   CURCOL,CCALSC       ALTERNATE CURSOR COLUMN
         L     R15,ARCOMM          GO COMMUNICATE
*- - - - ETPSCOMM PARM.LIST : NONE
        CALL   (15)
         LTR   R15,R15             BAD RC?
         BNZ   ZEXIT               YUP
         TM    COMMSW,PFKFLAG      IS IT A PF KEY/ATTN?
         BZ    ZLCKINPT            NOPE, GO CHECK THE INPUT
         L     R2,TERMINPT         PICK UP AID ADDRESS
         CLI   0(R2),X'F3'         IS IT PF3?
         BE    ZLCKINPT            YUP, LIKE ENTER
         CLI   0(R2),X'C3'         IS IT PF15?
         BE    ZLCKINPT            YUP, LIKE ENTER
         CLI   0(R2),X'6C'         IS IT PA1?
         BE    ZSCRBLD             YUP, FORCE LIKE NO VIEW / NO DELETE
         CLI   0(R2),X'6D'         IS IT "CLEAR"?
         BE    ZLGSBLD             YUP, RESHOW SCREEN
         CLI   0(R2),X'6E'         IS IT PA2?
         BE    ZLGSBLD             YUP, RESHOW SCREEN
         LA    R1,ZINVPFK
ZLSTMSG  ST    R1,MSGADD
         B     ZLGSBLD             RESHOW SCREEN
*- - - - CHECK ENTERED ZAP LOG SELECTIONS
ZLCKINPT NI    ZLGSW,255-ZLGALT-ZLGPOC RESET ALTERNATE AND CHANGED
         L     R5,TERMINPT+ZLZ1    PICK UP VIEWING FIELD
         L     R6,TERMINPT+ZLZ2    PICK UP DELETE FIELD
         CLI   SPLIT,2             AM I ON SCREEN 2?
         BNE   ZLCKINPV            NOPE
         L     R3,SCROWS1          PICK UP SIZE OF SCREEN 1
         SLL   R3,2                MULTIPLY BY 4
         L     R5,TERMINPT+ZLZ1(R3) PICK UP VIEWING FIELD
         L     R6,TERMINPT+ZLZ2(R3) PICK UP DELETE FIELD
ZLCKINPV CLI   0(R5),0             VIEWING ENTERED (OR CHANGED)?
         BE    ZLCKINPD            NO
         OI    ZLGSW,ZLGPOC        YES, SAY PANEL OPTION CHANGED
         LA    R0,L'ZLSCF1-1       LEFT JUSTIFY FIELD IF NEEDED
         CLI   ZLSCF1(R5),C' '
         BNE   ZLSTVW
         MVC   ZLSCF1(L'ZLSCF1-1,R5),ZLSCF1+1(R5)
         MVI   ZLSCF1+L'ZLSCF1-1(R5),C' '
         BCT   R0,*-18
ZRSTVW   NI    ZLGSW,255-ZLGVIEW   RESET VIEW REQUEST
         B     ZLCKINPD
ZLSTVW   CLI   ZLSCF1(R5),C'N'
         BE    ZRSTVW
         CLI   ZLSCF1(R5),C'Y'
         BE    *+L'*+8
         LA    R1,ZINVOPT
         B     ZLSTMSG
         OI    ZLGSW,ZLGVIEW       SET VIEW REQUESTED
ZLCKINPD CLI   0(R6),0             DELETE ENTERED?
         BE    ZLGOCHK             NO
         OI    ZLGSW,ZLGPOC        YES, SAY PANEL OPTION CHANGED
         LA    R0,L'ZLSCF2-1       LEFT JUSTIFY FIELD IF NEEDED
         CLI   ZLSCF2(R6),C' '
         BNE   ZLSTDL
         MVC   ZLSCF2(L'ZLSCF2-1,R6),ZLSCF2+1(R6)
         MVI   ZLSCF2+L'ZLSCF2-1(R6),C' '
         BCT   R0,*-18
ZRSTDL   NI    ZLGSW,255-ZLGDEL    RESET DELETE REQUEST
         B     ZLGOCHK
ZLSTDL   CLI   ZLSCF2(R6),C'N'
         BE    ZRSTDL
         CLI   ZLSCF2(R6),C'Y'
         BE    *+L'*+12
         OI    ZLGSW,ZLGALT
         LA    R1,ZINVOPT
         B     ZLSTMSG
         OI    ZLGSW,ZLGDEL        SET VIEW REQUESTED
ZLGOCHK  TM    ZLGSW,ZLGPOC        ANY OPTION CHANGED?
         BO    ZLGSBLD             YES, RESHOW
         TM    ZLGSW,ZLGVIEW+ZLGDEL HOW SELECTION IS?
         BZ    ZMKEPT              NO VIEW / NO DELETE
         TM    ZLGSW,ZLGVIEW       VIEW REQUESTED?
         BZ    ZBROWOK             NO
         ICM   R15,B'1111',ARBROWSE YES, VERIFY BROWSE AVAILABLE?
         BNZ   ZBROWOK             YES, OK
        LOAD   EP=ETPSBROW,ERRET=ZLDBRERR
         ST    R0,ARBROWSE         LOADED, OK
*- - - - PROCESS THE ZAP LOG DATA-SET
ZBROWOK  L     R7,DYNWORKP         INITIALIZE DYNAMIC ALLOCATION WORK
         LR    R2,R7
         LH    R3,=Y(PARMLLEN)     LENGTH TO BE CLEARED
         LA    R14,*
         XR    R15,R15
         ICM   R15,B'1000',=CL8' '
         MVCL  R2,R14              CLEAR TO ALL BLANKS
         USING PARMLIST,R7
         MVC   DSNAME,ZAPLGDSN     DS-NAME
         MVC   DSVOLSER,ZAPLGVOL   VOL-SER
         MVC   DSSTATUS,=CL8'SHR'  SET DISP=SHR
         TM    ZLGSW,ZLGDEL        DELETE REQUESTED?
         BZ    *+L'*+12            NO
         MVC   DSNDISP,=CL8'UNCATLG' YES, SET DISP=(SHR,UNCATLG,KEEP)
         MVC   DSADISP,=CL8'KEEP'
         L     R4,ACOPDCB          PICK UP LIBRARY ADDRESS
         MVC   DDNAME(L'DDNAME),DCBDDNAM-IHADCB(R4) DDNAME
         MVC   0(ZSQDCBL,R4),ZSQDCB MOVE DCB SKELETON
         MVC   DCBDDNAM-IHADCB(L'DCBDDNAM,R4),DDNAME SET BACK DDNAME
         L     R15,ARDYNAM
*- - - - ETPSDYNA PARM.LIST : "DYNWORKP" ADDRESS
        CALL   (15),MF=(E,DYNWORKP)
         LTR   R15,R15             HOW COMPLETE?
         BZ    ZALLOK              OK
        XMESS  3008
         TM    ZLGSW,ZLGVIEW       VIEW REQUESTED?
         BZ    *+L'*+8             NO
         LA    R1,ZALVMSG          YES
         B     ZASTMSG             YUP - ALL DONE
         LA    R1,ZALUMSG
         B     ZASTMSG             YUP - ALL DONE
ZALLOK   TM    ZLGSW,ZLGVIEW       VIEW REQUESTED?
         BZ    ZFREEDS             NO
         LA    R2,ZAPLGDSN         YES
         LA    R3,=CL8' '
         L     R15,ARBROWSE
*- - - - ETPSBROW PARM.LIST : DCB, DS-NAME, MEMBER-NAME
        CALL   (15),((R4),(R2),(R3)),VL,MF=(E,PARMVL)
ZFREEDS  LR    R0,R7               INITIALIZE DYNAMIC ALLOCATION WORK
         LH    R1,=Y(PARMLLEN)     LENGTH TO BE CLEARED
         LA    R14,*
         XR    R15,R15
         ICM   R15,B'1000',=CL8' '
         MVCL  R0,R14              CLEAR TO ALL BLANKS
         MVI   DSNAME,0            INDICATE FREE REQUEST
         MVC   DSNAME+1(L'DSNAME-1),DSNAME
         MVC   DDNAME(L'DDNAME),DCBDDNAM-IHADCB(R4) DDNAME
         L     R15,ARDYNAM
*- - - - ETPSDYNA PARM.LIST : "DYNWORKP" ADDRESS
        CALL   (15),MF=(E,DYNWORKP)
         LTR   R15,R15             HOW COMPLETE?
         BZ    ZFREEOK             OK
        XMESS  3009
         TM    ZLGSW,ZLGVIEW       VIEW REQUESTED?
         BZ    *+L'*+8             NO
         LA    R1,ZFLVMSG          YES
         B     ZASTMSG             YUP - ALL DONE
         LA    R1,ZFLUMSG
         B     ZASTMSG             YUP - ALL DONE
ZFREEOK  TM    ZLGSW,ZLGDEL        DELETE REQUESTED?
         BO    ZDELDS              YES
ZMKEPT   LA    R1,ZLKMSG           NO, KEPT
         B     ZASTMSG
ZDELDS   LR    R2,R7               INITIALIZE DYNAMIC ALLOCATION WORK
         LH    R3,=Y(PARMLLEN)     LENGTH TO BE CLEARED
         LA    R14,*
         XR    R15,R15
         ICM   R15,B'1000',=CL8' '
         MVCL  R2,R14              CLEAR TO ALL BLANKS
         USING PARMLIST,R7
         MVC   DSNAME,ZAPLGDSN     DS-NAME
         MVC   DSVOLSER,ZAPLGVOL   VOL-SER
         MVC   DSSTATUS,=CL8'SHR'  SET DISP=SHR
         MVC   DSNDISP,=CL8'DELETE' SET DISP=(SHR,DELETE,DELETE)
         MVC   DSADISP,=CL8'DELETE'
         L     R4,ACOPDCB          PICK UP LIBRARY ADDRESS
         MVC   DDNAME(L'DDNAME),DCBDDNAM-IHADCB(R4) GET DDNAME FOR USE
         L     R15,ARDYNAM
*- - - - ETPSDYNA PARM.LIST : "DYNWORKP" ADDRESS
        CALL   (15),MF=(E,DYNWORKP)
         LTR   R15,R15             HOW COMPLETE?
         BZ    ZDLAOK              OK
        XMESS  3008
         LA    R1,ZALDMSG
         B     ZASTMSG             YUP - ALL DONE
ZDLAOK   LR    R0,R7               INITIALIZE DYNAMIC ALLOCATION WORK
         LH    R1,=Y(PARMLLEN)     LENGTH TO BE CLEARED
         LA    R14,*
         XR    R15,R15
         ICM   R15,B'1000',=CL8' '
         MVCL  R0,R14              CLEAR TO ALL BLANKS
         MVI   DSNAME,0            INDICATE FREE REQUEST
         MVC   DSNAME+1(L'DSNAME-1),DSNAME
         MVC   DDNAME(L'DDNAME),DCBDDNAM-IHADCB(R4) DDNAME
         L     R15,ARDYNAM
*- - - - ETPSDYNA PARM.LIST : "DYNWORKP" ADDRESS
        CALL   (15),MF=(E,DYNWORKP)
         LTR   R15,R15             HOW COMPLETE?
         BNZ   *+L'*+8             WITH ERROR
         LA    R1,ZLDMSG           OK
         B     ZASTMSG             YUP - ALL DONE
        XMESS  3009
         LA    R1,ZFLDMSG
         B     ZASTMSG             YUP - ALL DONE
         DROP  R7
ZLDBRERR STM   R0,R1,MESSPL        BROWSE IS UNAVAILABLE
        XMESS  99,R15
         LA    R1,ZBUMSG
         B     ZASTMSG             YUP - ALL DONE
*- - - - TERMINATE ZAP PROCESSING
ZEXIT    L     R13,4(R13)          PICK UP CALLING SAVE-AREA
         LM    R14,R12,12(R13)     RESTORE CALLING REGISTERS
         XR    R15,R15             SET RETRUN CODE
         BR    R14                 NORMAL RETURN
         SPACE 1
ZDUMMY   DC    AL1(ZDUMMYL-1),X'04',CL9' '
ZDUMMYL  EQU   *-ZDUMMY
ZBADDSN  MSG   'DS-NAME ERROR'
ZVLMISS  MSG   'VOLUME MISSING'
ZINVPFK  MSG   'INVALID PF-KEY'
ZLKMSG   MSG   'ZAP "LOG" KEPT'
ZGMMSG   MSG   'ZAP GETMAIN ERROR'
ZLDMSG   MSG   'ZAP "LOG" DELETED'
ZBUMSG   MSG   'BROWSE UNAVAILABLE'
ZFLVMSG  MSG   'FREE "LOG"/V FAILED'
ZFLUMSG  MSG   'FREE "LOG"/U FAILED'
ZFLDMSG  MSG   'FREE "LOG"/D FAILED'
ZALVMSG  MSG   'ALLOC "LOG"/V FAILED'
ZALUMSG  MSG   'ALLOC "LOG"/U FAILED'
ZALDMSG  MSG   'ALLOC "LOG"/D FAILED'
ZINVOPT  MSG   'INVALID OPTION (N/Y)'
         PRINT &PRS
        LTORG
         PRINT &PRF
ZSQDCB  DCB    DSORG=PS,MACRF=(GM,PM),DDNAME=DUMMY,EODAD=*-*,SYNAD=*-*
ZSQDCBL  EQU   *-ZSQDCB
         SPACE 1
         DROP  R10,R11,R12,R13
         EJECT
*- - - - ZAP ENTRY SCREEN
         CNOP  0,4
ZAPSCR   DC    A(ZAROW1)
         DC    A(ZAROW2)
CRZASC   EQU   (*-ZAPSCR)/4        CURSOR ROW ON LINE BELOW
ZIZ1     EQU   (*-ZAPSCR)+4        "TERMINPT" DISPLACEMENT
         DC    A(ZAROW3)
ZIZ2     EQU   (*-ZAPSCR)+4        "TERMINPT" DISPLACEMENT
         DC    A(ZAROW4)
         DC    A(LNEBLK)
ZIZ3     EQU   (*-ZAPSCR)+4        "TERMINPT" DISPLACEMENT
         DC    A(EML+ZAROW5)
         SPACE 1
ZAROW1   DC    AL1(ZAROW1L-1)
         DC    XL1'05',10CL1'-'    PROTECT, HIGH-LIGHT
         DC    CL19' ZAP - ENTRY PANEL ',50CL1'-'
ZAROW1L  EQU   *-ZAROW1
ZAROW2   DC    AL1(ZAROW2L-1)
         DC    XL1'05',CL30'ENTER/VERIFY PARAMETERS BELOW:'
         DC    XL1'04',CL1' '
ZAROW2L  EQU   *-ZAROW2
ZAROW3   DC    AL1(ZAROW3L-1)
ZAOFF1   EQU   (*-ZAROW3)+1,10
         DC    XL1'04',CL20'FULLY-QUALIFIED NAME',XL1'05',CL3'==>'
CCZASC   EQU   (*-ZAROW3)          CURSOR COLUMN ON FIELD BELOW
ZASCF1   EQU   (*-ZAROW3)+1,54     INPUT FIELD 1
         DC    XL1'02',CL54' '
ZAROW3L  EQU   *-ZAROW3
ZAROW4   DC    AL1(ZAROW4L-1)
ZAOFF2   EQU   (*-ZAROW4)+10,13
         DC    XL1'04',CL22'         VOLUME SERIAL'
         DC    XL1'05',CL3'==>'
ZASCF2   EQU   (*-ZAROW4)+1,6      INPUT FIELD 2
         DC    XL1'02',CL6' '
         DC    XL1'04',CL45'          (IF NOT CATALOGED)'
ZAROW4L  EQU   *-ZAROW4
ZAROW5   DC    AL1(ZAROW5L-1)
ZAOFF3   EQU   (*-ZAROW5)+6,17
         DC    XL1'04',CL22'     DATA-SET PASSWORD'
         DC    XL1'05',CL3'==>'
ZASCF3   EQU   (*-ZAROW5)+1,8      INPUT FIELD 3
         DC    XL1'03',CL8' '      NO DISPLAY
         DC    XL1'04',CL37'        (IF PASSWORD PROTECTED)'
ZAOFF4   EQU   (*-ZAROW5)+1,3
         DC    XL1'04',CL3'(N)',XL1'04',CL1' '
ZAROW5L  EQU   *-ZAROW5
LNEBLK   DC    AL1(LNEBLKL-1),XL1'04',CL9' ' SF = PROT
LNEBLKL  EQU   *-LNEBLK
         EJECT
*- - - - ZAP ENTRY HELP SCREEN
         CNOP  0,4
ZAPHLP   DC    A(ZAPHL1)
         DC    A(HLPENT)
         DC    A(ZAPHL2)
         DC    A(ZAPHL3)
         DC    A(ZAPHL4)
         DC    A(LNEBLK)
         DC    A(ZAPHL5)
         DC    A(ZAPHL6)
         DC    A(LNEBLK)
         DC    A(EML+ZAPHL7)
         SPACE 1
ZAPHL1   DC    AL1(ZAPHL1L-1)
         DC    XL1'05',10CL1'-'    PROTECT, HIGH-LIGHT
         DC    CL19' ZAP - ENTRY PANEL ',50CL1'-'
ZAPHL1L  EQU   *-ZAPHL1
*                ----+----1----+----2----+----3----+----4----+----5----
*              +----6----+----7----+----
ZAPHL2   DC    AL1(ZAPHL2L-1),XL1'05'
         DC    C'THE ZAP PANEL PROVIDES FOR ENTERING THE DATA-SET NAME,X
                WHICH MUST BE A'
ZAPHL2L  EQU   *-ZAPHL2
ZAPHL3   DC    AL1(ZAPHL3L-1),XL1'05'
         DC    C'    FULLY-QUALIFIED DS-NAME (NEVER DELIMITED BY QUOTESX
               ).'
ZAPHL3L  EQU   *-ZAPHL3
ZAPHL4   DC    AL1(ZAPHL4L-1),XL1'05'
         DC    C'    A SPECIFIC VOL-SER MAY ALSO BE ENTERED, AND A PASSX
               WORD.'
ZAPHL4L  EQU   *-ZAPHL4
ZAPHL5   DC    AL1(ZAPHL5L-1),XL1'05'
         DC    C'TO ACCESS A VOLUME VTOC, TYPE AS DATA-SET NAME THE WORX
               D "VTOC" AND FILL IN THE'
ZAPHL5L  EQU   *-ZAPHL5
ZAPHL6   DC    AL1(ZAPHL6L-1),XL1'05'
         DC    C'    VOLUME SERIAL NUMBER YOU WANT.'
ZAPHL6L  EQU   *-ZAPHL6
ZAPHL7   DC    AL1(ZAPHL7L-1),XL1'05'
         DC    C'PF3 RETURNS TO THE PRIMARY OPTION MENU PANEL.'
ZAPHL7L  EQU   *-ZAPHL7
HLPENT   DC    AL1(HLPENTL-1),XL1'01',CL1' ',XL1'05',CL7' '
HLPENTL  EQU   *-HLPENT
         EJECT
*- - - - ZAP LOG ENTRY SCREEN
         CNOP  0,4
ZLGSCR   DC    A(ZLROW1)
         DC    A(ZLROW2)
         DC    A(LNEBLK)
CRZLSC   EQU   (*-ZLGSCR)/4        CURSOR ROW ON LINE BELOW
ZLZ1     EQU   (*-ZLGSCR)+4        "TERMINPT" DISPLACEMENT
         DC    A(ZLROW3)
         DC    A(LNEBLK)
CRALSC   EQU   (*-ZLGSCR)/4        ALTERNATE CURSOR ROW ON LINE BELOW
ZLZ2     EQU   (*-ZLGSCR)+4        "TERMINPT" DISPLACEMENT
         DC    A(EML+ZLROW4)
         SPACE 1
ZLROW1   DC    AL1(ZLROW1L-1)
         DC    XL1'05',10CL1'-'    PROTECT, HIGH-LIGHT
         DC    CL23' ZAP - ENTRY LOG PANEL ',46CL1'-'
ZLROW1L  EQU   *-ZLROW1
ZLROW2   DC    AL1(ZLROW2L-1)
         DC    XL1'05',CL34'ENTER/VERIFY ZAP LOG REQUIREMENTS:'
         DC    XL1'04',CL1' '
ZLROW2L  EQU   *-ZLROW2
ZLROW3   DC    AL1(ZLROW3L-1)
ZLOFF1   EQU   (*-ZLROW3)+11,8
         DC    XL1'04',CL21'          LOG VIEWING',XL1'05',CL3'==>'
CCZLSC   EQU   (*-ZLROW3)          CURSOR COLUMN ON FIELD BELOW
ZLSCF1   EQU   (*-ZLROW3)+1,3      INPUT FIELD 1
         DC    XL1'02',CL3' ',XL1'04',C'(NO/N/YES/Y) '
ZLROW3L  EQU   *-ZLROW3
ZLROW4   DC    AL1(ZLROW4L-1)
ZLOFF2   EQU   (*-ZLROW4)+3,8
         DC    XL1'04',CL21'  AND / OR LOG DELETE',XL1'05',CL3'==>'
CCALSC   EQU   (*-ZLROW4)          ALTERNATE CURSOR COL. ON FIELD BELOW
ZLSCF2   EQU   (*-ZLROW4)+1,3      INPUT FIELD 2
         DC    XL1'02',CL3' ',XL1'04',C'(NO/N/YES/Y) '
ZLROW4L  EQU   *-ZLROW4
         EJECT
*- - - - ZAP LOG ENTRY HELP SCREEN
         CNOP  0,4
ZLGHELP  DC    A(ZLGHL1)
         DC    A(HLPENT)
         DC    A(ZLGHL2)
         DC    A(ZLGHL3)
         DC    A(LNEBLK)
         DC    A(ZLGHL4)
         DC    A(ZLGHL5)
         DC    A(ZLGHL6)
         DC    A(EML+ZLGHL7)
         SPACE 1
ZLGHL1   DC    AL1(ZLGHL1L-1)
         DC    XL1'05',10CL1'-'    PROTECT, HIGH-LIGHT
         DC    CL23' ZAP - LOG ENTRY PANEL ',46CL1'-'
ZLGHL1L  EQU   *-ZLGHL1
*                ----+----1----+----2----+----3----+----4----+----5----
*              +----6----+----7----+----
ZLGHL2   DC    AL1(ZLGHL2L-1),XL1'05'
         DC    C'THE ZAP LOG PANEL ALLOWS TO VIEW THE SESSION LOGGING DX
               ATA-SET (WHEN IT HAS'
ZLGHL2L  EQU   *-ZLGHL2
ZLGHL3   DC    AL1(ZLGHL3L-1),XL1'05'
         DC    C'    BEEN CREATED), AND / OR DELETE IT (IF NEEDED, ELSEX
                IT IS KEPT).'
ZLGHL3L  EQU   *-ZLGHL3
ZLGHL4   DC    AL1(ZLGHL4L-1),XL1'05'
         DC    C'THE ZAP LOG DATA-SET IS ALWAYS NAMED AS FOLLOWS:'
ZLGHL4L  EQU   *-ZLGHL4
ZLGHL5   DC    AL1(ZLGHL5L-1),XL1'05'
         DC    C'         <USER-ID>.ETPS.ZAPLOG.DYYDDD.THHMMSS.LIST'
ZLGHL5L  EQU   *-ZLGHL5
ZLGHL6   DC    AL1(ZLGHL6L-1),XL1'05'
         DC    C'    WHERE "YYDDD" IS THE YEAR AND SERIAL DAY, AND'
ZLGHL6L  EQU   *-ZLGHL6
ZLGHL7   DC    AL1(ZLGHL7L-1),XL1'05'
         DC    C'          "HHMMSS" IS THE TIME OF DAY.'
ZLGHL7L  EQU   *-ZLGHL7
         EJECT
*------- DISPLAY AND MODIFY DATA-SET --------------------------------*
*        AT ENTRY, R1 = A(PARM.LIST) -> (DS-NAME,
*                                        VOL-SER,
*                                        PASSWORD,
*                                        LOG.DS-NAME,
*                                        LOG.VOL-SER)
*                  AND R10 MUST POINT TO "SPLTAREA"
         SPACE 1
*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
* REGISTERS USAGE : R0-R7...WORK REGISTERS                           *
*                   R8......LOCAL LINK REGISTER                      *
*                   R9......TS WORK-AREA POINTER                     *
*                   R10.....3RD BASE REGISTER                        *
*                   R11.....2ND BASE REGISTER                        *
*                   R12.....1ST BASE REGISTER                        *
*                   R13....."ETPS" SAVE-AREA, ETC... POINTER         *
*                   R14.....WORK AND RETURN ADDRESS                  *
*                   R15.....WORK AND ENTRY POINT ADDRESS             *
*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
         SPACE 1
FPR0     EQU   0                   DEFINE FLOATING-POINT REGISTERS
FPR2     EQU   2
FPR4     EQU   4
FPR6     EQU   6
         SPACE 1
         CNOP  0,4
         USING *,R12,R11,R10
         USING SAVE3,R13      ************************** R13 ==> SAVE3
ETPSXZAP STM   R14,R12,12(R13)     SAVE INPUT REGISTERS
         LR    R12,R15             SET PROGRAM BASE REGISTER 1
         LA    R2,1
         LA    R11,4*KB-1(R2,R12)  SET PROGRAM BASE REGISTER 2
         LR    R7,R10              SPLIT-SCREEN DSECT
         USING SPLTAREA,R7
         LR    R3,R7
         LA    R10,4*KB-1(R2,R11)  SET PROGRAM BASE REGISTER 3
         SH    R3,=Y(SPLITWRK-SAVE3) POINT TO SAVE3
         ST    R13,4(,R3)          STORE BACKWARD POINTER
         ST    R3,8(R13)           STORE FORWARD POINTER
         LR    R13,R3              SET DSECT BASE
         LR    R2,R1               RETAIN PARM ADDRESS
         L     R9,=A(TSDSECTL)
        GETMAIN RC,LV=(R9)         GET LOCAL WORK-AREA
         LTR   R15,R15             HOW COMPLETE?
         BZ    *+L'*+14            OK
         L     R13,4(,R13)         ERROR
         ST    R15,16(R13)         SET ERROR RETURN CODE
         LM    R14,R12,12(R13)     RESTORE ALL REGISTERS
         BR    R14                 BYE BYE
         LR    R0,R1
         LR    R1,R9
         LR    R9,R0
         LA    R14,*
         XR    R15,R15
         MVCL  R0,R14              CLEAR ALL TO BINARY ZEROS
         USING TSDSECT,R9
         MVC   EYECATCH,=CL8'EXEC.ZAP'
         MVC   DDNALL,N#IN         DD-NAME'S TO BE USED
         MVC   DDPALL,N#PRINT
         DROP  R7
         ST    R7,ASPLTA           SAVE IT FOR TERMINAL COMMUNICATION
         LM    R3,R5,0(R2)         PICK UP FIRST THREE PARMS
*                                  R3=DS-NAME ADDRESS
*                                  R4=VOL-SER ADDRESS
*                                  R5=PASSWORD ADDRESS
         MVC   ZDSNME(L'ZDSNME),0(R3) GET THE DS-NAME
         MVC   ZVOLSER(L'ZVOLSER),0(R4) GET THE VOL-SER
         MVC   ZPSSWRD(L'ZPSSWRD),0(R5) GET THE PASSWORD
*                                  COPY LAST TWO PARMS ADDRESSES
         MVC   ZLGDSN(2*4),3*4(R2) "LOG" DS-NAME/VOL-SER ADDRESSES
         NI    ZLGVOL,255-VLB      CLEAR "VL" BIT
*- - - - DO INITIALIZATION.
         MVC   ZUSRID,USERID       GET THE USER-ID
         MVI   BLANKS,C' '
         MVC   BLANKS+1(L'BLANKS-1),BLANKS
         MVC   DISPDSN,ZDSNME      COPY FOR DISPLAYING
         CLI   TUBEDDNM,C'T'       TSO TERMINAL?
         BNE   *+L'*+4             NO
         OI    FLAGSX,RUNTSO       YES
         XC    CURPOS,CURPOS       CLEAR CURSOR POSITION
         LA    R1,JFCB             -> JFCB
         ST    R1,EXLST
         MVI   EXLST,VLB+X'07'     CALL IT A JFCB
         LA    R6,4095(,R9)        TEMPORARY POINT TO EXTRA
         USING TSDSECT+4095,R6
         LA    R0,IDEFTAB
         ST    R0,AIDEFTAB
         LA    R1,ITRTAB
         ST    R1,AITRCTAB
         MVI   0(R1),X'FE'         SET TO INITIAL VALUE
         MVC   1((24*L'ITRTAB)-1,R1),0(R1) SET THE WHOLE THING
         ST    R1,ITRAVAL          -> FIRST POS
         ST    R1,CURRITR          -> CURRENT POS
         MVI   ENDITAB,X'FF'       MARK THE END OF THE TABLE
         MVI   ITREND,X'FF'        DITTO
         LA    R0,ITREND           POINT TO IT
         ST    R0,AITREND          SAVE
         LA    R1,CSAREA           -> "CSOUT" WORK-AREA
         ST    R1,CSALOC           SET ADDRESS
         USING CSDATA,R1
         LA    R0,CSOBUFF          LINE ADDRESS
         ST    R0,CSLLOC           STORE IT
         MVC   CSOBUFF,BLANKS      AND CLEAR LINE BEFORE ANY USE
         DROP  R1
         LA    R0,WSCREEN          SCREEN BUFFER ADDRESS
         ST    R0,REGS3270         SET FOR COMMUNICATIONS
         DROP  R6
         L     R1,=A(DCBMSK)       GET ADDRESS OF PATTERN DCB
         MVC   DCBU(DCBUL),0(R1)   SET UP DCB FOR INPUT
         XC    ZIOB(IOBLEN),ZIOB   INIT. IOB
         MVI   ZIOB,IOBCMDCH+IOBUNREL IOBFLAGS
         LA    R0,ZECB             -> EXCP ECB
         STCM  R0,B'0111',ZIOB+(IOBECBPB-IOBSTDRD)
         LA    R0,DCBU
         STCM  R0,B'0111',ZIOB+(IOBDCBPB-IOBSTDRD)
         L     R1,=A(CCWLIST)      INIT. CCWS
         MVC   CCWS(CCWL),0(R1)
         LA    R0,CCHHR            POINTER FOR SEARCH ID EQ
         STCM  R0,B'0111',CCW#R#S+1 SET ADRRESS
         STCM  R0,B'0111',CCW#W#S+1 HERE TOO
         STCM  R0,B'0111',CCW#F#S+1 HERE TOO
         LA    R1,CCW#R#S          GET TIC ADDRESS
         STCM  R1,B'0111',CCW#R#T+1 SET IT
         LA    R1,CCW#W#S          GET TIC ADDRESS
         STCM  R1,B'0111',CCW#W#T+1 SET IT
         LA    R1,ZNAME            -> KEY
         STCM  R1,B'0111',CCW#D#S+1 SET IT
         LA    R1,CCW#D#S          GET TIC ADDRESS
         STCM  R1,B'0111',CCW#D#T+1 SET IT
         LA    R1,CCW#F#S          GET TIC ADDRESS
         STCM  R1,B'0111',CCW#F#T+1 SET IT
         MVC   WIDTHD(4),MAXWIDTH  SET WINDOW DOWN STANDARD VALUE
         MVC   WIDTHU(4),MAXWIDTH  SET WINDOW UP STANDARD VALUE
*- - - - CHECK WHICH KIND OF DATA-SET THE USER HAS SELECTED.
         L     R1,=A(SSTAB)        SENSITIVE PREFIXES TABLE
SSLOOP   CLI   0(R1),X'FF'
         BE    CHKVTOC             NO MORE
         XR    R15,R15
         IC    R15,0(R1)
         EX    R15,SSCHECK         IT IS THIS ONE?
         BE    STSNSF              IF YES MARK IT
         LA    R1,2(R1,R15)        ELSE BUMP TO NEXT
         B     SSLOOP
SSCHECK  CLC   ZDSNME(*-*),1(R1)   <<EXECUTED>>
CHKVTOC  CLC   ZDSNME(12),=CL12'FORMAT4.DSCB' VTOC?
         BNE   NOTVTOCR            NO
         MVI   ZDSNME,X'04'        YES, CHANGE DS-NAME TO ALL X'04'
         MVC   ZDSNME+1(L'ZDSNME-1),ZDSNME
         MVC   DISPDSN,BLANKS      RESET FIELD
         MVC   DISPDSN(8),=CL8'VTOC FOR' SHOW SOMETHING GOOD
         MVC   DISPDSN+9(6),ZVOLSER MOVE IN VOLUME NAME
STSNSF   OI    FLAGSX,SENSF        MARK AS SENSITIVE
NOTVTOCR OI    FLAGSG,GODUP        ASSUME HE CAN UPDATE
*- - - - SET UP DEFAULTS AND INITIALS COND'S.
         L     R1,=A(TRCHARE)      INITIALIZE POINTER TO...
         ST    R1,TRTABADD         TR TABLE (THE EBCDIC ONE)
         XC    TRTXTAB,TRTXTAB
         LA    R1,LINE06           POINT TO FIRST AVAIL SCREEN LOC
         ST    R1,FIRSTSCR         SAVE IT
         LA    R1,MSGLINE          POINT TO LAST AVAIL SCREEN LOC
         ST    R1,MAXSCR           SAVE IT
         XC    LOOKFOR(3*18),LOOKFOR CLEAR SCAN STRING WORK-AREA
         XC    MEMTTR,MEMTTR       NO MEMBER YET
         XC    TXTTTR,TXTTTR       NO TEXT FOR MEMBER YET
         XC    ESDTTR,ESDTTR       NO ESD POINTER YET
         MVC   ESDID(2),=H'1'      ESDID DEFAULTS TO 1 FOR IBM
         MVI   TCONT,0             NO SCAN, STORES OR SETS YET
         NI    FLAGSR,255-YESCSERR "CSOUT" WILL WORK FOR SURE
         BAL   R8,CLEARDEF         INITIALIZE IDEF TABLE AND PTRS
         MVC   TTR,=XL4'00000100' INITIALIZE TTRN
*- - - - ALLOCATE THE DATA-SET AND OPEN IT, UPDAT RIGHT OFF THE BAT.
         L     R2,DYNWORKP         INITIALIZE DYNAMIC ALLOCATION WORK
         LR    R0,R2
         LH    R1,=Y(PARMLLEN)     LENGTH TO BE CLEARED
         LA    R14,*
         XR    R15,R15
         ICM   R15,B'1000',BLANKS
         MVCL  R0,R14              CLEAR TO ALL BLANKS
         USING PARMLIST,R2
         MVC   DDNAME,DDNALL       DDNAME
         CLI   ZDSNME,X'04'        VTOC?
         BNE   ALLDSN              NO
         MVC   DSUNIT,=CL8'SYSALLDA' YES, SET UNIT= (A DIRECT ACCESS)
         MVC   DSSTATUS,=CL8'OLD ' SET DISP=OLD (JUST ALLOC. VOLUME)
         B     DODSALL
ALLDSN   MVC   DSNAME,ZDSNME       DS-NAME
         MVC   PASSWORD,ZPSSWRD    PASSWORD
         MVC   DSSTATUS,=CL8'SHR ' SET DISP=(SHR,KEEP,KEEP)
         MVC   DSNDISP,=CL8'KEEP '
         MVC   DSADISP,=CL8'KEEP '
DODSALL  MVC   DSVOLSER,ZVOLSER    VOL-SER
         DROP  R2
         L     R15,ARDYNAM
*- - - - ETPSDYNA PARM.LIST : "DYNWORKP" ADDRESS
        CALL   (15),MF=(E,DYNWORKP)
         LTR   R15,R15             HOW COMPLETE?
         BZ    OKDSN               OK
         CH    R15,=H'4'
         BNE   ERRDYN
         CL    R0,=A(X'17080000')
         BNE   ERRDYN
         LA    R1,NFDMSG           DS-NAME NOT FOUND (NOT ALLOCATED)
         B     XCSIO
ERRDYN  XMESS  3001                ERROR
         LA    R1,AZFMSG
         B     XCSIO
OKDSN    OI    FLAGSG,GODALL       SET ALLOCATED
         LA    R0,DCBU             POINT TO DCB
         ST    R0,DCBLIST          PUT IN OPEN/CLOSE LIST
         MVI   DCBLIST,VLB+0       MARK "VL" & INPUT
         MVC   DCBU+DCBDDNAM-IHADCB(L'DCBDDNAM),DDNALL DDNAME
         LA    R0,EXLST            SET UP FOR RDJFCB
         STCM  R0,B'0111',DCBU+DCBEXLSA-IHADCB SET IN DCB
        RDJFCB MF=(E,DCBLIST)      GET THE JFCB
         L     R1,EXLST            -> JFCB
         USING JFCDSECT,R1
         MVC   JFCBDSNM,ZDSNME     MAYBE CHANGE THE DSN
         CLI   JFCBDSNM,X'04'      VTOC?
         BNE   *+L'*+4             NO
         OI    JFCBTSDM,JFCNWRIT   YES, INHIBIT WRITE BACK
         DROP  R1
        OPEN   MF=(E,DCBLIST),TYPE=J OPEN THE DATA-SET
         TM    DCBU+DCBOFLGS-IHADCB,DCBOFOPN DID IT OPEN?
         BO    OKOPN               YES
         LA    R1,OZFMSG           NO
         B     XCSIO
*- - - - GET VOLUME SERIAL NUMBER.
OKOPN    OI    FLAGSG,GODOPN       SET OPENED
         XR    R3,R3
         ICM   R3,B'0111',DCBU+DCBDEBA-IHADCB GET THE DEB POINTER
         L     R3,(DEBBASND-DEBBASIC)+(DEBUCBAD-DEBDASD)(R3) UCB
         MVC   ZVOLSER(L'ZVOLSER),SRTEVOLI-UCB(R3) SAVE VOL=SER OF DS
         CLI   ZDSNME,X'04'        VTOC?
         BNE   OKVOLSER            NO, OK
         CLI   DISPDSN+9,C' '      HAVE THE VOL ALREADY?
         BNE   OKVOLSER            YES, SKIP
         MVC   DISPDSN+9(L'ZVOLSER),ZVOLSER NO, FILL IT IN
*- - - - FIND THE LAST TTR FROM THE FORMAT 1 DSCB OF THE DATA-SET,
*              OBTAINED, CLEVERLY ENOUGH, BY AN 'OBTAIN' (ASSUMING
*              IT'S NOT A VTOC).
OKVOLSER XC    ENDTTR,ENDTTR       SAY NO LAST TTR FOR DEFAULT
         XC    DSCB(256),DSCB      CLEAR OUT DEFAULT DSCB
         MVI   ZDSORG,0            SAY NOT PARTITIONED FOR NOW
         MVC   DSCBLIST(OBTLISTL),OBTLIST
         LA    R14,ZDSNME          DS-NAME FOR OBTAIN
         LA    R15,ZVOLSER         POINT TO VOL-SER
         LA    R0,DS1FMTID         DSCB BUFFER
         STM   R14,R0,DSCBLIST+4   STORE ALL 3 POINTERS
        OBTAIN DSCBLIST            GET THE FMT1 DSCB
         LTR   R15,R15             HOW COMPLETE?
         BZ    GETLTTR             IF OK, USE INFO
         LA    R1,OBTMSG           ELSE ERROR
         B     XCSIO
GETLTTR  CLI   ZDSNME,X'04'        VTOC?
         BE    GOTVTOC             YES, GET INFO
         MVC   VBLKSZ,DS1BLKL      NO, SET BLKSIZE OF DATA-SET
         MVC   VLRECL,DS1LRECL     SET LRECL OF DATA-SET
         XR    R0,R0
         IC    R0,DS1KEYL
         STH   R0,KEYLEN           SET KEY-LENGTH OF DATA-SET
         MVC   ZDSORG(1),DS1DSORG  SAVE DSORG FOR M
         MVC   ENDTTR,DS1LSTAR     SAVE IT
         CLI   DS1NOEPV,0          ANY EXTENTS?
         BNE   OKACC               YES
         LA    R1,DSNXMSG          NO, CAN'T ACCESS
         B     XCSIO
OKACC    TM    DS1OPTCD,DS1OPTIC   YES, ICF DATA-SET?
         BZ    NOLAST              NO
         TM    FLAGSX,SENSF        SENSITIVE DATA-SET?
         BO    NOLAST              YES
         OI    FLAGSX,SENSF        NO, MARK AS SENSITIVE
         B     NOLAST
GOTVTOC  MVC   VBLKSZ,=AL2((DS4END-DSCB)-L'DS1DSNAM) SET VTOC BLKSIZE
         LA    R0,L'DS1DSNAM
         STH   R0,KEYLEN           SET KEY-LENGTH OF VTOC
         MVI   ZDSORG,0            NO DSORG
         MVC   LASTFMT1(5),DS4HPCHR SAVE POINTER TO LAST FMT1 USED
NOLAST   LH    R0,VBLKSZ           PICK UP BLKSIZE
         LTR   R0,R0               IS IT ZERO (LIKE JOBQ)?
         BP    *+L'*+4             NO, GO ON
         LH    R0,=AL2(20*KB)      USE 20K FOR DEFAULT IN CASE
         CH    R0,=H'264'          BELOW MIN (ESP PDS DIRECTORY)
         BNL   *+L'*+4             NO, LEAVE BLKSIZE AS IS
         LH    R0,=H'264'          YES, SET MIN=PDS DIRECTORY SIZE
         AH    R0,KEYLEN           ADD TO BUFFER SIZE
         AH    R0,=Y(8+1)          GET ROOM FOR COUNT
*              THE +1 IS SO WILL ALWAYS HAVE RESIDUAL.
         LR    R1,R0               COPY VALUE
         STH   R1,BUFFSIZE         STORE AWAY FOR LATER USE
         STH   R1,CCW#R#R+6        SET FOR MAX READ
         STH   R1,CCW##R0+6        DITTO FOR R0
         AH    R0,=H'57'           SO NO 0C4'S NEAR BUFF. END
         SRL   R0,3                ROUND UP TO DOUBLE-WORD
         SLL   R0,3
         ST    R0,ZBUFFL           SAVE BUFFER AREA LENGTH
        GETMAIN R,LV=(0)           GET BUFFER AREA
         LTR   R15,R15             HOW COMPLETE?
         BZ    GOTBUFF             OK
        XMESS  3011,R15            ERROR
         LA    R1,GMBMSG
         B     XCSIO
GOTBUFF  ST    R1,ZBUFFA           SAVE BUFFER AREA ADDRESS FOR LATER
         ST    R1,ADDRCNT          SAVE ADDRESS OF COUNT
         STCM  R1,B'0111',CCW#R#R+1
         STCM  R1,B'0111',CCW##R0+1
         STCM  R1,B'0111',CCW#F#W+1
         LA    R1,8(,R1)           -> KEY FIELD
         ST    R1,ADDRKEY          SAVE ADDRESS OF KEY
         ST    R1,ADDRBUFF         DEFAULT DISPLAY IS KEY
         STCM  R1,B'0111',CCW#W#W+1
         STCM  R1,B'0111',CCW#D#R+1
*- - - - NOW CHECK OUT THE USER. IF HE CAN'T GET IN, OR
*              CAN'T TOUCH THE DATA-SET, KICK HIM OUT.
         TM    FLAGSX,SENSF        SENSITIVE DATA-SET?
         BZ    GETFDTS             NO
         TM    FLAGSX,RUNTSO       YES, TSO TERMINAL?
         BO    *+L'*+12            YES
         OI    FLAGSL,LOGFS        NO, LOGGING FORCED
         BAL   R8,LOGTEST          OPEN "LOG", WE MUST LOGGING
         B     GETFDTS
         TM    STATSW,SPCLFLG      USER HAS SPECIAL ATTRIBUTE?
         BO    GETFDTS             YES, OK
         NI    FLAGSG,255-GODUP    NO, KILL HE CAN UPDATE
*- - - - GET FREE DEFINE TABLE SYMBOLS FOR
*              'LRECL', 'KEY-LENGTH' AND 'BLKSIZE'.
GETFDTS  L     R3,AIDEFTAB         POINT TO DEFINE TABLE
         MVI   DEFSYM(R3),C'L'     GIVE SYMBOL 'L' FOR 'LRECL'
         MVC   DEFOFF(L'DEFOFF,R3),VLRECL GET LRECL, PUT IN TAB
         LA    R3,L'IDEFTAB(R3)    UPDATE DEFINE TABLE POINTER
         MVC   DEFSYM(2,R3),=CL2'BL' GIVE 'BL' FOR 'BLKSIZE' (MAX)
         MVC   DEFOFF(L'DEFOFF,R3),VBLKSZ GET BLKSIZE, PUT IN TAB
         LA    R3,L'IDEFTAB(R3)    UPDATE DEFINE TABLE POINTER
         MVI   DEFSYM(R3),C'K'     GIVE 'K' FOR KEY-LENGTH' SYMBOL
         MVC   DEFOFF(L'DEFOFF,R3),KEYLEN GET KEY-LENGTH, PUT IN TAB
         LA    R3,L'IDEFTAB(R3)    UPDATE DEFINE TABLE POINTER
         ST    R3,IDEFAVAL         SAVE IT AS POINTER TO CURR ENTRY
         MVC   REPLINE,BLANKS      CLEAR REPLY OUT
         MVC   ICREP,REPLINE
         MVI   CAPSFLG,YESCAPS
         MVC   MSGLINE,BLANKS      CLEAR ERR-MSG PART OF SCREEN
         XC    BASEVAL,BASEVAL     BASE = 0
*- - - - CREATE THE SCREEN DISPLAY AND GET COMMAND.
*              HERE IF A NEW BLOCK IS TO BE READ AND
*              THE SCREEN IS TO BE BUILT FROM IT.
NEW$READ XC    NOWSTUFF(NOWLEN-L'BASEVAL),NOWSTUFF RESET BUFFER OFF
         BAL   R8,READBLK          GET A BLOCK FROM DATA-SET (BDAM)
         B     NEW$DISP            SKIP AROUND
*- - - - HERE IF BUILD SCREEN WITHOUT READING A NEW BUFFER IN.
NEWDSPNT NI    FLAGSR,255-YESTRACE SET NOTRACE
NEW$DISP BAL   R8,CLEAR            CLEAR THE SCREEN
         OC    BLKLEN(2),BLKLEN    NO READ BEFORE?
         BZ    DISPLYT             YES, THERE'S NOTHING TO DISP
         LH    R8,OLDPOINT         GET CARET OFFSET
         N     R8,=F'-16'          GET HIGH PART
         LR    R5,R8               COPY
         SH    R8,=H'96'           BACK UP TO SCREEN START (6*16)
         BNM   *+L'*+2             CONTINUE IF OK
         XR    R8,R8               SCREEN START = BLOCK START
         A     R8,ADDRBUFF         GET ADDRESS INTO BUFFER
         A     R5,ADDRBUFF         GET DBLW ADDRESS INTO BUFFER
         L     R15,FIRSTSCR        POINT TO FIRST AVAIL SCREEN POS
*- - - - FORMAT ONE LINE OF SCREEN DISPLAY.
FORMAT   LR    R0,R8               COPY BUFFER POINTER
         S     R0,ADDRBUFF         OFFSET INTO BUFFER FOR SCREEN
         ST    R0,TEMP2            SAVE FOR UNPK
        @HEX   (0,R15),TEMP2+1,LEN=3,DIGITS=5
         MVC   TEMP2(16),0(R8)     COPY CHAR FORM OF DATA
         UNPK  TEMP3+00(14+1),TEMP2+00(7+1) BYTES 01-07
         UNPK  TEMP3+14(14+1),TEMP2+07(7+1) BYTES 08-14
         UNPK  TEMP3+28(04+1),TEMP2+14(2+1) BYTES 15-16
         TR    TEMP3(32),HEXTAB    MAKE EBCDIC
         L     R1,TRTABADD         GET RIGHT TRTAB POINTER
         TR    TEMP2(16),0(R1)     MAKE IT VALID CHARS
         LR    R1,R0               COPY BLK OFFSET
         AH    R1,=H'16'           GET NEXT OFFSET
         SH    R1,BLKLEN           COMPUTE AMOUNT SHORT
         BNP   FORMATOK            SKIP IF THIS LINE FULL
         LA    R14,TEMP3           -> AREA
         AH    R14,=H'32'          -> PAST END
         LA    R2,0(R1,R1)         GET LENGTH OF HEX GARBAGE
         SR    R14,R2              -> GARBAGE HEX
         EX    R2,FMTBLANK         BLANK THE GARBAGE HEX
*              NOTE THAT TEMP3 IS LONG ENOUGH THAT BLANKING
*              1 CHAR TOO MANY DOESN'T HURT ANYTHING.
         LA    R14,TEMP2           -> CHARS
         AH    R14,=H'16'          -> PAST END
         SR    R14,R1              -> GARBAGE CHARS
         BCTR  R1,0                -1 FOR EX
         EX    R1,FMTBLANK         CHARS ALSO GET TREATMENT
FORMATOK MVC   TEMP3+32(2),=CL2' |' MOVE IN CONSTANTS FOR TR
         MVC   7(DSPTRTL,R15),DSPTRT MOVE IN "TRANSLATE" TABLE
         TR    7(DSPTRTL,R15),TEMP2 DISTRIBUTE HEX TO SCREEN
         CLR   R8,R5               BUFFER POINTER = DATA POINTER?
         BNE   NO$CARET            NO, SKIP CARET
         LR    R1,R15              COPY LINE ADDRESS
         BCTR  R1,0                BACK UP TO ATTR BYTE
         MVI   0(R1),X'F8'         HIGH INTENSITY PROTECTED
         LH    R1,OLDPOINT         GET CARET OFFSET
         N     R1,=F'15'           GET LOW ORDER PART
         LA    R3,TBYTES(R1)       POINT TO COLUMN OF SCREEN
         IC    R1,0(,R3)           GET SCREEN COL FOR CARET
         LA    R14,0(R15,R1)       POINT TO WHERE IT GOES
         MVI   0(R14),C'>'         ASSUME EVEN
         TM    OLDPOINT+1,X'01'    IS IT?
         BZ    *+L'*+4             YES, SKIP
         MVI   0(R14),C'<'         ODD POINTS THE OTHER WAY
         ST    R14,MIDLINE         SAVE POINTER TO CARET LINE
NO$CARET AH    R8,=H'16'           UPDATE BUFFER POINTER
         LA    R15,$I(,R15)        UPDATE SCREEN POINTER
         AH    R0,=H'16'           NEXT OFFSET
         CH    R0,BLKLEN           PAST END OF BLOCK?
         BNL   DISPLYT             YES, GO DISPLAY
         CL    R15,MAXSCR          OUT OF SCREEN?
         BL    FORMAT              NO, DO ANOTHER LINE
         B     DISPLYT             SKIP (WE WILL TRACE)
FMTBLANK MVC   0(*-*,R14),BLANKS   <<EXECUTED>>
DISPLYNT NI    FLAGSR,255-YESTRACE SET NOTRACE
DISPLYT  MVI   TTR+3,NOSEQRD       TURN OFF SEQ READ
         OI    FLAGSR,YESEOF       SAY EOF'S WILL BE RECOGNIZED
         MVC   LINE03(40),=CL40'ENTER VALID COMMAND ABOVE OR ? FOR HELPX
                '
         MVC   LINE03+L'LINE03-24(24),=CL24'VERSION : ETPS &VNUM..&VMODX
                (&VIDT)'
WHEREAMI MVC   LINE20+00(4),=CL4'OFF:'
         LH    R15,OLDPOINT        GET OFFSET IN BUFFER
         BAL   R14,NUMCONV         CONVERT IT
         MVC   LINE20+05(4),TEMP3+12+4 MOVE IN HEX PART
         MVI   LINE20+10,C'('
         MVC   LINE20+11(6),TEMP3+6 DECIMAL PART
         MVC   LINE20+17(7),=CL7') ADDR:'
         L     R15,OFFSET          GET IT
         BAL   R14,NUMCONV         CONVERT
         MVC   LINE20+25(5),TEMP3+12+3 HEX PART
         MVI   LINE20+31,C'('
         MVC   LINE20+32(8),TEMP3+4 DECIMAL PART
         MVC   LINE20+40(6),=CL6') DSN:'
         MVC   LINE20+47($L-47),DISPDSN DATA-SET NAME
         MVC   LINE21+00(4),=CL4'LEN:'
         LH    R15,BLKLEN          GET LENGTH OF BLOCK
         BAL   R14,NUMCONV         CONVERT
         MVC   LINE21+05(4),TEMP3+12+4 HEX PART
         MVI   LINE21+10,C'('
         MVC   LINE21+11(6),TEMP3+6 DECIMAL PART
         MVC   LINE21+17(7),=CL7') BASE:'
         L     R15,BASEVAL         BASE
         BAL   R14,NUMCONV         CONVERT
         MVC   LINE21+25(5),TEMP3+12+3 HEX PART
         MVI   LINE21+31,C'('
         MVC   LINE21+32(8),TEMP3+4 DECIMAL PART
         MVC   LINE21+40(8),=CL8') CCHHR:'
         UNPK  LINE21+49(10+1),CCHHR
         TR    LINE21+49(10),HEXTAB MAKE IT EBCDIC
         MVC   LINE21+59(5),=CL5' TTR:'
        @HEX   LINE21+66,TTR,LEN=3
*- - - - DISPLAY SCREEN JUST MADE.
*              (CREATE TRACE TABLE ENTRY IF NECESSARY)
         MVC   PREVREP,REPLINE     SAVE FOR TWICE TEST
         TM    FLAGSR,YESTRACE     TRACE FOR THIS GUY?
         BZ    NOTRACIT            NO, SO DONT
*              MAKE THE TRACE TABLE ENTRY.
         L     R1,ITRAVAL          PICK UP NEXT SPOT IN TABLE
         CLI   0(R1),X'FF'         END?
         BNE   MORETAB             NO, THERE'S MORE
         L     R1,AITRCTAB         YES, START OVER AT TOP
         ST    R1,ITRAVAL          AND RESET AVAIL POS POINTER
MORETAB  MVC   ITRTTR(L'ITRTTR,R1),TTR MOVE TTR TO TABLE
         MVC   ITROFF(L'ITROFF,R1),OLDPOINT AND OFFSET TOO
         ST    R1,CURRITR          SAVE POINTER TO CURR TRACE ENTRY
         LA    R1,L'ITRTAB(R1)     UPDATE AVAIL POINTER
         ST    R1,ITRAVAL          SAVE IT
NOTRACIT OI    FLAGSR,YESTRACE     MAKE IT TRACE AGAIN
*              THIS HUNK OF CODE MOVE DOWN HERE
*              FROM SOMEWHERE IN "DISPLAY".
         MVI   LINE01,C'-'         BUILD THE TOPLINE
         MVC   LINE01+1(L'LINE01-1),LINE01
         MVC   LINE01+34(11),=CL11'  Z  A  P  '
         L     R0,REGS3270         CLEAR THE SCREEN BUFFER
         L     R1,=A(WSCREENL)
         LR    R4,R0               RETAIN SCREEN BUFFER START ADDRESS
         LA    R2,*
         XR    R3,R3
         MVCL  R0,R2
         TM    FLAGSX,RUNTSO       ARE WE RUNNING IN TSO?
         BZ    *+L'*+8             NO
         MVI   0(R4),X'27'         YES, SET TSO WRITE SEQUENCE
         LA    R4,1(R4)            BUMP BUFFER POINTER
         MVI   0(R4),X'7E'         ERASE-WRITE-ALTERNATE
         MVI   1(R4),X'C3'         WCC = RESET KB + RESET MDT
         LA    R4,2(R4)            BUMP BUFFER POINTER
         LA    R3,CTL3270          SBA'S ADDRESS TABLE
         LA    R2,NL3270           NUMBER OF SCREEN LINES TO BUILD
         LA    R1,LINE01-2         POINT TO FIRST LINE
SCLOOP   MVI   0(R4),X'11'         SET SBA ORDER
         MVC   1(L'CTL3270,R4),0(R3) SET ADDRESS OF THIS LINE
         MVC   1+L'CTL3270($I,R4),0(R1) COPY LINE
         LA    R1,$I(R1)           BUMP POINTER TO NEXT LINE
         LA    R4,$I+L'CTL3270(R4) POINT TO END OF LINE TEXT IN BUFFER
         LA    R0,$L               LINE TEXT LENGTH
         CLI   0(R4),C' '          ELIMINE FINAL BLANKS
         BNE   *+L'*+6
         BCTR  R4,0
         BCT   R0,*-10
         LA    R4,1(R4)            ADJUST BUFFER POINTER
         LA    R3,L'CTL3270(R3)    BUMP SBA POINTER
         BCT   R2,SCLOOP
         MVC   0(L'END3270,R4),END3270 FINISH IT
         LA    R4,L'END3270(R4)    BUMP BUFFER POINTER
         SL    R4,REGS3270         COMPUTE WRITE TUBE LENGTH
         ST    R4,REGS3270+4       STORE IT
IOFULL   LM    R0,R1,REGS3270      GET THE WRITE TUBE REGISTERS
         L     R10,ASPLTA          SET R10 = NEEDED ADDRESS
         OI    COMMSW,EXTSBP       SAY I PROCESS MYSELF
         L     R15,ARCOMM          GO COMMUNICATE
*- - - - ETPSCOMM PARM.LIST : NONE
        CALL   (15)
         NI    COMMSW,255-EXTSBP   RESET IMMEDIATELY
         LA    R10,2*KB(,R11)      RESTORE PROGRAM BASE REGISTER 3
         LA    R10,2*KB(,R10)
         B     *+L'*(R15)          HOW COMPLETE?
         B     IODONE               0 - OK
         B     IOWRER               4 - WRITE ERROR
         B     IORDER               8 - READ ERROR
         B     IOTPER              12 - TPUT ERROR
         B     IOTGER              16 - TGET ERROR
IOWRER  XMESS  3003
         LA    R1,IOWRMSG
         B     XCSIO
IORDER  XMESS  3004
         LA    R1,IORDMSG
         B     XCSIO
IOTPER  XMESS  3005,R0
         LA    R1,IOTPMSG
         B     XCSIO
IOTGER  XMESS  3006,R0
         LA    R1,IOTGMSG
         B     XCSIO
IODONE   LA    R15,L'REPX          MAX. INPUT BUFFER LENGTH
         CLR   R0,R15
         BNH   OKIODO
        XMESS  3007                RESPONSE IS TOO LONG...
         TM    FLAGSX,RUNTSO       TSO TERMINAL?
         BZ    *+L'*+2             NO
         DC    H'0'                YUP, TAKE AN S0C1 <------------ DUMP
         LA    R2,RTLMSG           POINT TO MESSAGE
         B     BOTCH               RESUME IF "GO" FROM TEST
OKIODO   LTR   R0,R0               IF 0 SET AT LEAST 1
         BP    *+L'*+4
         LA    R0,1
         LA    R14,REPX
         LR    R15,R0
         LR    R2,R1
         LR    R3,R0
         MVCL  R14,R2              MOVE RESPONSE IN BUFFER
         LR    R1,R0
         CLI   REPX,X'6C'          PA1? (CANCEL?)
         BE    CANEX               YUP, LEAVE IMMEDIATELY
         CLI   REPX,X'6D'          CLEAR? (RESHOW?)
         BE    IOFULL              YES, GO DO IT
         CLI   REPX,X'6E'          PA2? (RESHOW?)
         BE    IOFULL              YES, GO DO IT
         CLI   REPX,X'7D'          ENTER?
         BE    ENTKEY              YES, BYPASS PFK
         OI    REPX,X'30'          PFK 13-24 LIKE 1-12
         CLI   REPX,X'F1'          PF1-PF13? (H?)
         BE    PFKHELP             YES, GO DO IT
         CLI   REPX,X'F5'          PF5-PF17? (L?)
         BE    PFKLOC              YES, GO DO IT
         CLI   REPX,X'F7'          PF7-PF19? (U?)
         BE    PFKUP               YES, GO DO IT
         CLI   REPX,X'F8'          PF8-PF20? (D?)
         BE    PFKDOWN             YES, GO DO IT
         CLI   REPX,X'F3'          PF3-PF15? (END?)
         BE    PFKEND              YES, GO DO IT
         LA    R2,INVMSG           NO, IGNORE ANY OTHER, SET MESSAGE
         B     BOTCH               DISPLAY MESSAGE
PFKEND   CLI   REPLINE,C'?'        YES, BUT WAS IN HELP?
         BNE   ENDPFK              NO, GO DO IT
         MVC   REPLINE,BLANKS      YES, CLEAR REMEMBERED INPUT
         LA    R2,REPLINE          FORCE NULL INPUT
         B     ASIS6               AND GO BACK
ENTKEY   LA    R2,REPLINE          THIS IS WHERE IT WILL GO
         LA    R3,REPX+3           POINT SRC PAST CURSOR ADDRESS
         LA    R4,REPX-1(R1)       END OF REPLY DATA
ASIS1    CLR   R3,R4               TOO FAR?
         BH    ASIS6               YES, NO DATA CAME IN
         CLI   0(R3),X'11'         SBA SEQUENCE?
         BNE   ASIS4               NO, DON'T WORRY ABOUT IT
         CLC   1(2,R3),=XL2'C1D1'  FIRST LINE INPUT (2,1)?
         BE    ASIS3               YES, ALL'S COOL SO FAR
         CLC   1(2,R3),=XL2'C3F1'  SECOND LINE INPUT (4,1)?
         BE    ASIS2               YES, GO CLEAR REP LINE
         TM    FLAGSX,RUNTSO       TSO TERMINAL?
         BZ    *+L'*+2             NO
         DC    H'0'                YUP, TAKE AN S0C1 <------------ DUMP
         LA    R2,SFEMSG           POINT TO MESSAGE
         B     BOTCH               RESUME IF "GO" FROM TEST
ASIS2    MVC   REPLINE,BLANKS      CLEAR REMEMBERED INPUT
ASIS3    LA    R3,3(,R3)           SKIP THE SBA SEQUENCE
         B     ASIS1               AND TRY SOME MORE
ASIS4    CLI   0(R3),C' '          LEADING BLANK?
         BNE   *+L'*+8             NO, FOUND DATA
         LA    R3,1(,R3)           SKIP THE BLANK
         B     ASIS1               GO LOOK FOR MORE
         MVC   REPLINE,BLANKS      FORCE CLEAR REPLY
ASIS5    CLR   R3,R4               TOO FAR?
         BH    ASIS6               YES, FILL IT UP NOW
         CLI   0(R3),X'11'         SBA?
         BE    ASIS6               YES, IGNORE THE 2ND LINE
         MVC   0(1,R2),0(R3)       MOVE ONE MORE BYTE
         LA    R2,1(,R2)           OK, UP THIS ONE
         LA    R3,1(,R3)           AND THE FROM POINTER, TOO
         B     ASIS5               CONTINUE THIS TRAVESTY
ASIS6    LA    R4,REPLINE          COMPUTE THE REAL
         SR    R2,R4               LENGTH OF THE REPLY
         STH   R2,READLEN          AND SAVE IT FOR LATER
         MVC   MSGLINE,BLANKS      CLEAR THE ERR-MSG IF ANY
*------- COMMAND CHECKING AND EXECUTION. ----------------------------*
*              FIND REPLY LENGTH AND COPY IT TO TEMP3.
         MVC   ICREP,REPLINE       HANDLE A COPY
         OC    REPLINE,BLANKS      MAKE IT UPPER CASE
         LH    R1,READLEN          GET READ LENGTH
         LA    R1,REPLINE(R1)      POINT TO LAST CHAR + 1
         BCTR  R1,0                DECREMENT POINTER
         CLI   0(R1),C' '          END OF STRING?
         BE    *-6                 NO, GO TEST ANOTHER CHAR
         LA    R0,REPLINE-1        GET LENGTH...
         SR    R1,R0               ... OF DATA
         BNP   NEWDSPNT            ZERO, IGNORE WITH NO TRACE
         STH   R1,REALRDLN         PHONY UP THE ACTUAL READ LENGTH
         MVC   TEMP3(40),REPLINE   COPY START OF COMMAND
*              (SOME ROUTINES MODIFY THE COMMAND IN TEMP3).
*              SEE IF THE COMMAND IS IN THE COMMAND TABLE.
         LR    R0,R1               GET THE TRUE READ LENGTH
         XR    R1,R1               CLEAR REGISTER FOR IC'S
         L     R2,=A(COMTAB)       POINT TO COMMAND TABLE
         BAL   R14,*+L'*+4         SET LOOP ADDRESS & SKIP
         LA    R2,CMTBEL(,R2)      -> NEXT TABLE ENTRY
         CLI   CMTBL(R2),X'FF'     END OF TABLE
         BE    EXPR                YES, NOT IN TAB, AN EXPRESS?
         IC    R1,CMTBL(,R2)       NO, PICK UP LENGTH OF COMMAND
         EX    R1,COMCLC           COMMAND MATCH?
         BNER  R14                 NO, CHECK NEXT
         XR    R14,R14             CLEAR REGISTER FOR ICM'S
         ICM   R14,B'0111',CMTBA(R2) PICK UP COMMAND ADDRESS
         BCTR  R0,0                COMPUTE LENGTH OF ...
         SR    R0,R1               ... REMAINING INPUT
*              NOTE : CC IS SET FOR OPERAND LENGTH 0 OR NOT 0.
         LA    R1,TEMP3+1(R1)      -> START OF OPERANDS
         BR    R14                 GO DO IT
COMCLC   CLC   REPLINE(*-*),CMTBN(R2) <<EXECUTED>>
*- - - - EXPRESSION ***** NO COMMAND (EXPRESSION) *****          <===*
EXPR     LA    R1,REPLINE          GET EXPRESSION POINTER
         LH    R0,REALRDLN         GET EXPRESSION LENGTH
PARSE    L     R15,OFFSET          GET '*' (CURRENT VALUE)
         MVI   EXPOPT,YESSYMB      SAY 'LOOK AT THE SYMBOL TABLE'
         BAL   R8,CALLEXP          GO PARSE
         S     R15,BASEVAL         GET OFFSET IN BUFFER
         BNM   SETPOINT            IT'S NON-NEG, SO WE'RE OK
SETPNT00 XR    R15,R15             CAN'T HAVE NEGATIVE
         CLC   ADDRBUFF,ADDRCNT    DISPLAYING COUNT FIELD?
         BNE   SETPOINT            NO, OK
         LA    R15,8               YES, PUT CARET AT KEY
SETPOINT LH    R2,BLKLEN           GET BLOCK LENGTH
         BCTR  R2,0                -1 FOR COMPARE
         CLR   R15,R2              ARE WE STILL WITHIN THE BLK?
         BNH   *+L'*+2             YES, WE'RE OK
         LR    R15,R2              NO, MAKE IT THE END OF BLK
         STH   R15,OLDPOINT        SAVE OFFSET FOR CURR LOC
         A     R15,BASEVAL         RELOCATE IT
         ST    R15,OFFSET          SAVE ADDRESS
         B     NEW$DISP            GO DO IT
INVEXPER LA    R2,INVEXP           YES, SAY INVALID SYNTAX
*                                  AND GO TELL HIM WITH NO TRACE
*- - - - DISPLAY ERROR MESSAGES.
*              MOVE IN MESSAGE AND HYPHENS AROUND IT TO ERROR MESSAGE
*              LINE ON SCREEN. TRACE WILL BE DISABLED. IF SYNTAX ERROR
*              MESSAGE IS TO BE DISPLAYED, THE COLUMN IN QUESTION IS
*              COMPUTED AND DISPLAYED WITH THE MESSAGE.
*              R2 = POINTER TO MESSAGE.
*              R1 = POINTER TO THE COLUMN OF THE ERROR (ONLY WHEN
*                   INVALID LOC IN EXPRESSION).
BOTCH    XR    R15,R15             CLEAR R15
         IC    R15,0(,R2)          GET LENGTH
         CH    R15,=H'20'          SEE IF WE ARE USING MESSAGE
         BH    BOTCHX              IF NOT ASSUME LENGTH OF 20
         MVC   TEMP3(20),BLANKS    CLEAR AN AREA
         BCT   R15,*+L'*+6         DECREMENT FOR EXECUTE
         MVC   TEMP3(*-*),1(R2)    <<EXECUTED>>
         EX    R15,*-6             MOVE IN MESSAGE
         LA    R2,TEMP3            POINT TO MESSAGE
         CLC   INVEXP+1(16),TEMP3  IS THIS AN INV EXPR MSG?
         BNE   BOTCHX              NO, GO ON
         LA    R3,TEMP3            POINT TO COPY OF REPLY
         CLR   R3,R1               IS THIS AREA USED FOR SCAN?
         BNH   *+L'*+4             YES
         LA    R3,REPLINE          NO, POINT TO REPLY
         SR    R1,R3               GET OFFSET TO BAD HEX
         LA    R1,1(R1)            MAKE THE OFFSET A COLUMN #
         CVD   R1,TEMP2            YES, GET OFFSET OF ERROR INTO
         UNPK  TEMP3+18(2),TEMP2+6(2) THE EXPRESSION AND
         OI    TEMP3+19,C'0'       MOVE IT TO THE SCREEN
         BCTR  R1,0                GET CURSOR POSITION
         STH   R1,CURPOS           SET IT
BOTCHX   LR    R1,R2               GET MESSAGE ADDRESS
         LA    R8,NEWDSPNT-2       FAKE THE RETURN POINT
         B     SETMSGX             SPECIAL ENTRY POINT
*- - - - HELP.                                                   <===*
*              (?, ?1, ?2, ?3, ?4, ?5, ?6, ?7, HELP, H, H1,...,H7).
PFKHELP  MVC   MSGLINE,BLANKS      CLEAR THE ERR-MSG IF ANY
HELPHELP XR    R3,R3               HE WANTS HELP #1 ("HELP")
         B     HELPOK              AND PROCESS
HELP     BNP   HELPHELP            JUST "?" - GIVE HIM "?1"
         XR    R15,R15             * = 0
         BAL   R8,CALLEXP          PARSE OPERAND
         BNP   INVEXPER            NO GOOD
         LR    R3,R15              GET THE ANSWER
         BCTR  R3,0                -1 FOR OFFSET
         CH    R3,=H'15'           GREATER THAN 9?
         BL    HELPOK              NO, SKIP
         SH    R3,=H'6'            "EXP" THOUGHT IT WAS HEX
HELPOK   LA    R2,1+C'1'(,R3)      GET NEXT PROMPT
         CH    R3,=Y(NUMHLP-1)     TOO BIG?
         BH    INVEXPER            YES, BYE BYE
         BL    *+L'*+4             NO, USE IT, WE HAVE PROMPT
         LA    R2,C'1'             AT END, WRAP TO BEGIN
         BAL   R8,CLEAR            CLEAR THE SCREEN FIRST
         MVI   REPLINE-1,X'C9'     UNPROT HIGH MDT
         MVC   REPLINE,BLANKS      BLANK THE PROMPT
         MVI   REPLINE,C'?'        SET UP PROMPT
         STC   R2,REPLINE+1        DO IT
         CLI   REPLINE+1,X'FA'     TOO BIG?
         BL    *+L'*+12 >========+ NO, OK
         MVI   REPLINE+1,C'1'    | SET FIRST DIGIT
         SH    R2,=H'10'         | FIX OTHER DIGIT
         STC   R2,REPLINE+2      | SET IT
         LTR   R3,R3 <===========+
         BNP   *+L'*+4             SKIP IF NULL
         MH    R3,=Y(L'ZAPHELP)    * LENGTH OF EACH HELP IMAGE POINTER
         AL    R3,=A(ZAPHELP)      ADD START TABLE POINTER
         XR    R1,R1
         L     R2,0(R3)            POINT TO HELP IMAGE
         LA    R3,LINE06           FIRST SCREEN LINE FOR HELP
HELPFILL CLI   0(R2),X'FF'         END OF HELP IMAGE?
         BE    DISPLYNT            YES, GIVE HIM SCREEN (NOTRACE)
         CLI   0(R2),X'80'         NULL LINE?
         BNE   *+L'*+8             NO
         LA    R2,1(R2)            YES, SKIP TO NEXT
         B     *+L'*+12
         IC    R1,0(R2)            GET TEXT LENGTH OF THIS HELP LINE
         EX    R1,HELPMOVE         MOVE TEXT LINE (CENTERED)
         LA    R2,2(R1,R2)         INCREMENT SOURCE POINTER
         LA    R3,$I(R3)           INCREMENT TARGET POINTER
         B     HELPFILL
HELPMOVE MVC   ($L-LENHLL)/2(*-*,R3),1(R2) <<EXECUTED>>
*- - - - LOG, DISP.                                              <===*
LOG      OI    FLAGSL,LOGRQ        LOGGING REQUESTED
         BAL   R8,LOGTEST          OPEN THE DATA-SET IF NOT OPEN
         LA    R2,LOGMSG           POINT TO MESSAGE
         B     BOTCH               DISPLAY MESSAGE
DISPC    MVC   ADDRBUFF,ADDRCNT    -> COUNT
         LH    R14,CCW#W#W+6       GET KL+DL
         LA    R14,8(,R14)         INCLUDE LENGTH OF COUNT
         STH   R14,BLKLEN          SET DISPLAY BLOCK LENGTH
         LA    R15,8               DISPLAY OFFSET
         B     SETPOINT            RE-DISPLAY NEAR TOP
DISPK    MVC   ADDRBUFF,ADDRKEY    -> KEY
         MVC   BLKLEN,CCW#W#W+6    SET DISPLAY BLOCK LENGTH
         B     SETPNT00            RE-DISPLAY AT TOP
DISPD    MVC   ADDRBUFF,ADDRDATA   -> DATA
         LH    R14,CCW#W#W+6       GET KL+DL
         SH    R14,KEYLEN          DON'T DISPLAY KEY
         STH   R14,BLKLEN          SET DISPLAY BLOCK LENGTH
         B     SETPNT00            RE-DISPLAY AT TOP
*- - - - END.                                                    <===*
CANEX    LA    R1,CEXMSG           CANCEL MESSAGE
XCSIO    ST    R1,MSGADD           STORE MESSAGE ADDRESS
         B     XEND+L'XEND         AND SCRAMBLE EXIT
ENDPFK   MVC   REPLINE,BLANKS
         MVC   REPLINE(3),=CL3'END'
XEND     BAL   R8,CHKPT            CHECK TO SEE IF ZAP REQ
         TM    FLAGSG,GODOPN       DATA-SET OPENED?
         BZ    XFRDS               NO
        CLOSE  MF=(E,DCBLIST)      YES, CLOSE IT
         NI    FLAGSG,255-GODOPN
XFRDS    TM    FLAGSG,GODALL       DATA-SET ALLOCATED?
         BZ    ENDALL              NO
         L     R2,DYNWORKP         YES, INIT. DYNAMIC ALLOC. WORK-AREA
         LR    R0,R2
         LH    R1,=Y(PARMLLEN)     LENGTH TO BE CLEARED
         LA    R14,*
         XR    R15,R15
         ICM   R15,B'1000',BLANKS
         MVCL  R0,R14              CLEAR TO ALL BLANKS
         USING PARMLIST,R2
         MVC   DDNAME,DDNALL       DDNAME
         MVI   DSNAME,0            INDICATE FREE REQUEST
         MVC   DSNAME+1(L'DSNAME-1),DSNAME
         DROP  R2
         NI    FLAGSG,255-GODALL
         L     R15,ARDYNAM         FREE IT
*- - - - ETPSDYNA PARM.LIST : "DYNWORKP" ADDRESS
        CALL   (15),MF=(E,DYNWORKP)
         LTR   R15,R15             HOW COMPLETE?
         BZ    ENDALL              OK
        XMESS  3002                ERROR
         OC    MSGADD,MSGADD       STILL A MESSAGE IN?
         BNZ   ENDALL              YES
         LA    R1,FZFMSG           NO, SET THIS ONE
         ST    R1,MSGADD
ENDALL   LA    R1,5                MESSAGE NUMBER
         BAL   R8,SETLINE          SET UP A LINE
         B     XLEAVE              NOT LOGGING?
         MVC   20(32,R2),=CL32'LOG CLOSED - PROCESSING COMPLETE'
         MVI   0(R2),C'-'          TRIPLE SPACE IT
         BAL   R8,CPUT             OUTPUT IT
XLEAVE   L     R1,CSALOC           GET WORK-AREA POINTER
         L     R0,=XL4'FFFFFFFF'   (+) FLAG AS CLOSE CALL
         L     R15,=A(CSOUT)       (+) POINT TO ROUTINE
        CALL   (15)                (+) CALL IT
         LTR   R15,R15             HOW COMPLETE?
         BZ    *+L'*+14            OK
         OC    MSGADD,MSGADD       FAILED, STILL A MESSAGE IN?
         BNZ   *+L'*+4             YES
         ST    R1,MSGADD           NO, SET THIS ONE
         ICM   R1,B'1111',ZBUFFA   GET BUFFER AREA ADDRESS
         BZ    XQUIT               NONE
         L     R0,ZBUFFL           GET BUFFER AREA LENGTH
        FREEMAIN R,LV=(0),A=(1)    FREE BUFFER AREA
XQUIT    L     R0,=A(TSDSECTL)
         LR    R1,R9
        FREEMAIN R,LV=(0),A=(1)    FREE LOCAL WORK-AREA
         L     R13,4(,R13)         RESTORE ALL REGISTERS
         LM    R14,R12,12(R13)
         XR    R15,R15             RC=0
         BR    R14                 BYE BYE
*- - - - EBCDIC, ASCII, ZCODE.                                   <===*
EBCDIC   L     R1,=A(TRCHARE)      PICK UP POINTER TO EBCDIC TRTAB
         LA    R2,EBCDCMSG         TELL HIM WHAT JUST HAPPENED
         XR    R15,R15
EBCDIC#  ST    R1,TRTABADD         SAVE FOR LATER DISPLAYS
         ST    R15,TRTXTAB
         B     BOTCH               GO DO IT AND DISPLAY
ASCII    L     R1,=A(IECTRASA)     PICK UP POINTER TO ASCII TRTAB
         LA    R2,ASCIIMSG         TELL HIM WHAT JUST HAPPENED
         L     R15,=A(IECTSASA)
         B     EBCDIC#             GO FINISH THE JOB
ZCODE    L     R1,=A(TRCHARZ)      PICK UP POINTER TO ZCODE TRTAB
         LA    R2,ZCODEMSG         SAY WHAT TYPE OF TRANS
         L     R15,=A(TRCHRZ)
         B     EBCDIC#             AND DO IT FROM NOW ON
*- - - - *****  //DEBUG  *****                                   <===*
DIEFAST  TM    FLAGSX,RUNTSO       TSO TERMINAL?
         BZ    *+L'*+2             NO
         DC    H'0'                YUP, TAKE AN S0C1 <------------ DUMP
         LA    R2,OUCH             POINT TO MESSAGE
         B     BOTCH               RESUME IF "GO" FROM TEST
*- - - - # (CALC), LAST, LASTDS1.
CALC     L     R15,OFFSET          GET '*' = CURRENT OFFSET
         MVI   EXPOPT,YESSYMB      TELL HIM SCAN SYMBOL TABLE
         BAL   R8,CALLEXP          PARSE & CHECK
         MVC   MSGLINE+17(20),=CL20'CALCULATE VALUE:' MOVE IN MASK
         BAL   R14,NUMCONV         CONVERT
         MVC   MSGLINE+34(12),TEMP3 DECIMAL PART
         MVC   MSGLINE+48(8),TEMP3+12 HEX PART
         B     NEWDSPNT            GIVE IT TO HIM
LAST     BAL   R8,CHKPT            CHECK TO SEE IF ZAP REQ
         CLI   ZDSNME,X'04'        IS THERE A LAST TTR (NOT VTOC)?
         LA    R2,LASTINV          POINT TO MESSAGE IN CASE
         BE    BOTCH               NO, TELL HIM
         MVC   TTR(L'TTR-1),ENDTTR PICK UP LAST TTR
         B     NEW$READ            GO GIVE IT TO HIM
LASTDS1  BAL   R8,CHKPT            CHECK TO SEE IF ZAP REQ
         CLI   ZDSNME,X'04'        IS THIS THE VTOC?
         LA    R2,NOTVMSG          POINT TO MESSAGE IN CASE
         BNE   BOTCH               NO, TELL HIM
         XC    ZDBLW,ZDBLW         CLEAR AREA FOR 'ABS'
*              ASSUME VTOC IS 1 EXTENT ==> M=0.
         MVC   ZDBLW+3(L'LASTFMT1),LASTFMT1 SET CCHHR OF LAST FMT1
         B     ABSGOT1             GO FAKE AN 'ABS' COMMAND
*- - - - D, U.                                                   <===*
PFKDOWN  MVC   REPLINE,BLANKS
         MVI   REPLINE,C'D'
         MVC   MSGLINE,BLANKS      CLEAR THE ERR-MSG IF ANY
         XR    R0,R0
DISPLAY# BNZ   PARSE               MORE THAN A 'D'
         BAL   R8,DU$COM           GET # OF BYTES
         AR    R15,R14             WHERE TO POINT TO NOW (OFFSET)
         CH    R15,BLKLEN          PAST BLK?
         BL    SETPOINT            NO, GO ON
         SRL   R14,1               TRY HALF WAY THEN
         SR    R15,R14             MAY BE NOW?
         CH    R15,BLKLEN          STILL ICKY?
         BNL   *+L'*+8             YES, GIVE UP AND NEXT BLK
         LH    R15,BLKLEN          NO, POINT TO END OF BLK + 1
         B     SETPOINT            GO GIVE IT TO HIM
         BAL   R8,CHKPT            CHECK TO SEE IF ZAP REQ
         BAL   R8,READNBLK         GET THE NEXT BLOCK
         B     SETPNT00            GO GIVE HIM OFFSET 0
PFKUP    MVC   REPLINE,BLANKS
         MVI   REPLINE,C'U'
         MVC   MSGLINE,BLANKS      CLEAR THE ERR-MSG IF ANY
         XR    R0,R0
UP       BAL   R8,DU$COM           GET # OF BYTES
         SR    R15,R14             BACK UP
         BNM   SETPOINT            USE IT IF OK
         B     SETPNT00            TOO FAR, USE 0
DU$COM   L     R14,WIDTHD          GET # OF LINES BELOW
         A     R14,WIDTHU          ADD NUMBER OF LINES ABOVE
         LA    R14,1(,R14)         ADD CARET LINE
         MH    R14,=H'16'          GET # OF BYTES DISPLAYED
         LH    R15,OLDPOINT        GET CURRENT OFFSET
         BR    R8                  RETURN TO "D" OR "U"
*- - - - =, NODEF.                                               <===*
EQUALS   BNP   INVEXPER            ERROR IF JUST '='
         LR    R7,R1               -> STRING
         LR    R1,R0               LENGTH
         BAL   R8,HEXCHECK         SEE IF VALID NUMBER
         B     EQUALBAD            CAN'T USE #'S FOR SYMBOLS
         L     R4,IDEFAVAL         GET POINTER TO 1ST AVAIL TABLE POS
         CLI   0(R4),X'FF'         END OF TABLE?
         LA    R2,TABFULL          GET MESSAGE ADDRESS IN CASE
         BE    BOTCH               NO ROOM...
         L     R3,AIDEFTAB         POINT TO BEGINNING
*              SEE IF THE SYMBOL IS ALREADY DEFINED.
ICLOOP   CLR   R3,R4               UP TO FIRST AVAIL POS YET?
         BNL   OKIDEF              YES, NO DUPLICATE, SO DEFINE
         CLC   DEFSYM(L'DEFSYM,R3),REPLINE+1 NO, SYMBOL ALREADY HERE?
         BE    REDEF               YES, SO REDEFINE IT
         LA    R3,L'IDEFTAB(R3)    NO, POINT TO NEXT SPOT IN TABLE
         B     ICLOOP              KEEP GOING TILL OUT
REDEF    MVC   DEFSYM(L'DEFSYM,R3),REPLINE+1 MOVE IN THE SYMBOL
         MVC   DEFOFF(L'DEFOFF,R3),OFFSET+2 MOVE IN THE OFFSET
         LA    R2,REDEFMSG         PT TO MESSAGE SAYING REDEFINED SYM
         B     BOTCH               DONT RESET FIRST AVAIL - LEAVE
OKIDEF   MVC   DEFSYM(L'DEFSYM,R4),REPLINE+1 MOVE IN THE SYMBOL TO TAB
         MVC   DEFOFF(L'DEFOFF,R4),OFFSET+2 MOVE IN THE OFFSET
         LA    R4,L'IDEFTAB(R4)    POINT TO NEXT AVAIL
         ST    R4,IDEFAVAL         SAVE FOR NEXT TIME
         B     NEWDSPNT            DISPLAY (NOTRACE)
EQUALBAD LA    R2,BADEQUAL         POINT TO MESSAGE
         B     BOTCH               MAS CAN'T COMPLAIN ANYMORE
NODEF    BAL   R8,CLEARDEF         YES, LET HIM HAVE IT
         LA    R2,DEFRESET         TELL HIM WE RESET THE TABLE
         B     BOTCH               GO BACK TO DISPLAY (NOTRACE)
*- - - - IDEF.                                                   <===*
IDEF     BAL   R8,CLEAR            CLEAR THE SCREEN
         MVC   LINE06(16),=CL16' SYMBOL   OFFSET' MOVE MASK FOR COL 1
         MVC   LINE06+20(3*20-4),LINE06 MAKE 3 MORE COLUMNS
         LA    R1,LINE08           POINT TO DISPLAY
         L     R2,IDEFAVAL         POINT PAST LAST LOC TO FMT
         L     R3,AIDEFTAB         POINT TO TABLE
IDEFNEWL LA    R4,4                MAKE IT 4 COLUMNS
IFMTLOOP CLR   R3,R2               DONE WITH FORMATTABLE STUFF?
         BNL   DISPLYNT            YES, DISPLAY WITH NO TRACE
         MVC   0(L'DEFSYM,R1),DEFSYM(R3) MOVE SYMBOL TO DISPLAY
        @HEX   (11,R1),(DEFOFF,R3),LEN=2    MOVE IN OFFSET
         LA    R1,20(,R1)          UPDATE DISPLAY POINTER
         LA    R3,L'IDEFTAB(R3)    UPDATE TABLE POINTER
         BCT   R4,IFMTLOOP         DO ANOTHER
         LA    R1,$I-4*20(,R1)     INCREMENT A LITTLE MORE
         B     IDEFNEWL            AND DO ANOTHER LINE
*- - - - ITRACE.                                                 <===*
ITRACE   L     R2,AITRCTAB         POINT TO BEGINNING OF TABLE
         BAL   R8,CLEAR            CLEAR THE SCREEN
         MVC   LINE06+1(11),=CL11' TTR   OFFS' MOVE IN TITLE FOR COL 1
         MVC   LINE06+14(13*5-2),LINE06+1 MAKE 5 MORE COLUMNS
         LA    R3,LINE08           FIRST AVAIL SCREEN POSIT
NEWLINE  LA    R4,3                CNT FOR GOOD OFFSET DISP LOOP
         AR    R4,R4               YES, MAKE IT 6
ITRFMTLP CLI   0(R2),X'FF'         END OF TABLE
         BE    DISPLYNT            GO DISPLAY (NOTRACE & NO REBLD)
        @HEX   (1,R3),(ITRTTR,R2),LEN=3 MOVE IN TTR
        @HEX   (8,R3),(ITROFF,R2),LEN=2 MOVE IN OFFSET
         CL    R2,CURRITR          IS THIS THE CURRENT TRACE TAB
         BNE   *+L'*+4             NO, GO ON WITH FORMATTING
         MVI   0(R3),C'>'          MOVE IN THE POINTER TO CURR ENTRY
         LA    R3,13(R3)           UPDATE SCREEN POINTER
         LA    R2,L'ITRTAB(R2)     UPDATE TABLE POINTER
         BCT   R4,ITRFMTLP         DO IT THRICE (OR 6)
         LA    R3,$I-6*13(,R3)     MAKE UP FOR ODDBALL SCREEN
         B     NEWLINE             AND DO NEXT LINE
*- - - - >, <.                                                   <===*
FORWARD  L     R3,ITRAVAL          PICK UP POINTER TO NEXT TRACE
         NI    FLAGSR,255-YESTRACE DON'T TRACE > FOR PETE'S SAKE
         CLI   0(R3),X'FF'         END OF TABLE?
         BNE   *+L'*+4             NO, NO PROBLEM
         L     R3,AITRCTAB         YES, SO WRAP TO TOP
         CLI   0(R3),X'FE'         EXIST YET?
         LA    R2,INVFMSG          GET MESSAGE ADDRESS IN CASE
         BE    BOTCH               NO - TELL HIM NO GOOD
         LA    R2,L'ITRTAB(R3)     POINT TO NEXT ONE AFTER THAT
         LR    R4,R2               SAVE NEXT CURRENT ONE
         B     CARET               FINISH ALL THE REST
BACKWARD NI    FLAGSR,255-YESTRACE DON'T TRACE A < EITHER
         L     R2,AITRCTAB         POINT TO TRACE TABLE
         L     R3,ITRAVAL          POINT TO NEXT CURRENT ENTRY
         CLR   R3,R2               CURRENT ENTRY = FIRST ENTRY?
         BNE   *+L'*+4             NO, NO PROBLEM (YET)
         L     R3,AITREND          YES, MUST LOOP TO TAB END
         SH    R3,ITRTBL           BACK TRACK ONE ENTRY
         LR    R4,R3               SAVE FOR LATER ITRAVAL
         CLR   R3,R2               IS THAT THE BEGINNING NOW?
         BNE   *+L'*+4             NO, NO MORE WORRIES
         L     R3,AITREND          YES, WE LOOP TO ENDTAB
         SH    R3,ITRTBL           BACKTRACK ONE ENTRY
         CLI   0(R3),X'FE'         DOES THAT ENTRY EXIST?
         BNE   CARET               YES, WE'RE OK
         LA    R2,INVBMSG          NO, TELL HIM SO AND
         B     BOTCH               GO TELL HIM
*              DO THE CARET.
*              IF LEAVING BLOCK, CHECK TO SEE OF BLK REPLACED.
CARET    CLC   TTR(L'ITRTTR),ITRTTR(R3) NEW BLOCK NEEDED?
         BE    RDNOTNEC            NO, DON'T BOTHER WITH CHECK
         BAL   R8,CHKPT            YES, MAKE SURE THIS ONES OK
         MVC   TTR(L'ITRTTR),ITRTTR(R3) NEW BLK, GET CORRECT TTR
         ST    R3,TEMP2            SAVE POINTER TO THE ENTRY
         BAL   R8,READBLK          READ THE BLOCK IN
         L     R3,TEMP2            PICK UP THE POINTER BACK
RDNOTNEC ST    R4,ITRAVAL          NEW TRACE TABLE POINTER
         ST    R3,CURRITR          SAVE CURRENT TRACE TAB ENTRY
         MVC   TEMP2(L'ITROFF),ITROFF(R3) NOW GET OFFSET FROM TRACE TAB
         LH    R15,TEMP2           INTO RIGHT REGISTER
         B     SETPOINT            GO FAKE A '+' COMMAND
*- - - - T, P, J, %.                                             <===*
TRACK    BAL   R8,CHKPT            ANY ZAP NEEDED?
         LTR   R0,R0               TEST OPERAND LENGTH
         BNZ   MORET               NOT JUST 'T'
         LH    R15,TTR             JUST A T (T=T+1)
         LA    R15,1(R15)          POINT TO NEXT TRACK
         B     POSTRACK            GO DO IT
MORET    LH    R15,TTR             PICK UP '*' TRACK
         BAL   R8,CALLEXP          PARSE & CHECK
         BM    TTRLT1              NEGATIVE IS BAD
POSTRACK STH   R15,TTR             SAVE TRACK #
         MVI   TTR+2,X'01'         GIVE HIM REC=01
         B     NEW$READ            READ AND DISPLAY
POINT    BAL   R8,CHKPT            ANY ZAP NEEDED?
         LTR   R0,R0               TEST OPERAND LENGTH
         BNZ   MOREP               MORE THAN P - GET TTR
         MVC   TTR,=XL4'00000100'  JUST 'P',GIVE HIM TTRN
         B     NEW$READ            DO IT
MOREP    BAL   R6,TTRPARSE         GET THE TTR SPECIFIED
         MVC   TTR(L'TTR-1),TEMP2+1 MOVE IN TTR
         B     NEW$READ            GO GET IT
*              (TTR FROM BEGINING OF VOLUME - FOR JES HASPACE)
POINT$J  BAL   R8,CHKPT            ANY ZAP NEEDED?
         LTR   R0,R0               TEST OPERAND LENGTH
         BNZ   POINT$J1            MORE THAN P, GET TTR
         MVC   TTR,=XL4'00000100'  JUST 'P',GIVE HIM TTRN
         B     NEW$READ            DO IT
POINT$J1 BAL   R6,TTRPARSE         GET THE TTR SPECIFIED
         MVC   TTR(L'TTR-1),TEMP2+1 MOVE IN TTR
         XR    R14,R14
         ICM   R14,B'0111',DCBU+DCBDVTBA-IHADCB @ DEV.CHAR TABLE ENTRY
         XR    R15,R15
         ICM   R15,B'0111',DCBU+DCBDEBA-IHADCB @ DEB
         LH    R0,32+6(,R15)       1ST EXTENT CYL BEGIN
         MH    R0,2(,R14)          * # OF TRKS/CYL
         AH    R0,32+8(,R15)       + 1ST EXTENT TRK BEGIN
         LH    R1,TTR              GET TRACK SPECIFIED
         SR    R1,R0               ON VOLUME
         STH   R1,TTR              (FOR JES/VTOC TTRS)
         B     NEW$READ            GO GET IT
INDPOINT LH    R15,OLDPOINT        GET BUFFER OFFSET
         MVI   EXPOPT,YESSYMB      WANT SYMBOL TABLE LOOKUP
         BAL   R8,CALLEXP          EVALUATE OPERAND
         BM    INVEXPER            NEG IS INVALID
         LH    R0,BLKLEN           GET BLOCK LENGTH
         SH    R0,=H'3'            LAST POSSIBLE TTR
         CLR   R15,R0              PAST END?
         BH    INVEXPER            YES, ERROR
         A     R15,ADDRBUFF        GET ADDRESS IN BUFFER
         BAL   R8,CHKPT            CAN HE LEAVE?
         MVC   TTR(L'TTR-1),0(R15) SET NEW TTR
         B     NEW$READ            GO READ IT & DISPLAY
*- - - - ABS.                                                    <===*
ABS      BAL   R8,CHKPT            SEE IF HE CAN LEAVE
         LTR   R15,R0              TEST OPERAND LENGTH
         BNP   INVEXPER            IT'S BAD
         CH    R15,=H'10'          CCHHR TOO LONG?
         BNH   *+L'*+4             NO, OK
         LH    R15,=H'10'          YES, TRUNCATE
         EX    R15,ABSTR           TRANSLATE TO "HEX", NO EX LENGTH
         EX    R15,ABSPACK         GET 000CCHHR
*              FIND 'M'.
         XR    R15,R15
         ICM   R15,B'0111',DCBU+DCBDEBA-IHADCB GET DEB
         XR    R1,R1               START WITH M=0
         XR    R0,R0               FOR IC
         IC    R0,DEBNMEXT-DEBBASIC(,R15) GET NUMBER OF EXTENTS
ABSLOOP  CLC   ZDBLW+3(4),(DEBBASND-DEBBASIC)+(DEBSTRCC-DEBDASD)(R15)
         BL    ABSNEXT             NOT IN THIS EXTENT
         CLC   ZDBLW+3(4),(DEBBASND-DEBBASIC)+(DEBENDCC-DEBDASD)(R15)
         BNH   ABSGOT              NOT IN THIS EXTENT
ABSNEXT  LA    R15,16(,R15)        NEXT EXTENT
         LA    R1,1(,R1)           NEXT 'M'
         BCT   R0,ABSLOOP          NEXT EXTENT
         BAL   R8,CLEAR            CLEAR THE SCREEN FIRST
         MVC   TTR(L'TTR-1),=XL5'FFFFFFFFFF' SET UP A BAD TTR
         MVC   CCHHR(L'CCHHR),=XL5'FFFFFFFFFF' HERE TOO
         OI    FLAGSR,YESSYN       SAY "IOERROR"
         XC    BLKLEN,BLKLEN       NOTHING TO DISPLAY
         MVC   IOMLINE+17(40),IOERRMSG MOVE IN MASK
         MVC   IOMLINE+35(15),=CL15'NOT IN DATA-SET'
         B     DISPLYNT            GO SAY BOTCHED
ABSGOT   STC   R1,ZDBLW            SET 'M'
ABSGOT1  STM   R9,R12,20+R9*4(R13) SAVE REGS CONVERT KILLS
         XR    R1,R1
         ICM   R1,B'0111',DCBU+DCBDEBA-IHADCB GET DEB AGAIN
         LA    R2,ZDBLW            GET 'MBBCCHHR'
         LR    R3,R13              SAVE R13 TOO
         L     R15,CVTPTR          CVT
         L     R15,CVTPRLTV-CVT(,R15) GET ABS=>REL CONVERT
        CALL   (15)                GO GET TTRZ
         LR    R13,R3              RESTORE R13
         LM    R9,R12,20+R9*4(R13) RESTORE OTHER REGS
         ST    R0,TTR              SAVE TTR
         B     NEW$READ            GO READ/DISPLAY
ABSTR    TR    TEMP3+3(*-*),HEXTAB <<EXECUTED>>
ABSPACK  PACK  ZDBLW(9),TEMP3+3(0) <<EXECUTED>>
*- - - - B, R.                                                   <===*
BACK     BAL   R8,CHKPT            ANY ZAP NEEDED?
         NI    FLAGSR,255-YESEOF   TREAT EOF'S AS DATA BLKS
         XR    R15,R15             CLEAR FOR IC
         IC    R15,TTR+2           GET R
         SH    R15,=H'1'           BACK IT UP 1
         B     RBACK               GO CHECK IT
RECORD   BAL   R8,CHKPT            ANY ZAP NEEDED?
         CLI   ZDSORG,DCBDSGPO     ARE WE IN A PDS?
         BNE   *+L'*+4             NO, TELL HIM ABOUT EOF'S
         NI    FLAGSR,255-YESEOF   YES, TREAT EOF'S AS DATA BLKS
         LTR   R0,R0               TEST OPERAND LENGTH
         BP    MORER               NOT JUST 'R'
         MVI   TTR+3,SEQREAD       GO TO NEXT RECORD
         B     NEW$READ            READ AND DISPLAY
MORER    XR    R15,R15             CLEAR FOR IC
         IC    R15,TTR+2           GET CURRENT RECORD
         BAL   R8,CALLEXP          PARSE & CHECK
RBACK    XR    R1,R1               CLEAR FOR IC
         IC    R1,TTR+2            GET CURRENT RECORD
         LR    R3,R15              PRESERVE ABSOLUTE FOR BACK
         SR    R3,R1               FIND OFFSET
         LR    R5,R15              SAVE IT
*              R3 IS RELATIVE OFFSET, R5 IS ABSOLUTE VALUE.
         BZ    NEW$READ            IF STILL HERE, REREAD
         BM    RGOBACW             IF NEGATIVE, BACK UP
*              OFFSET IS POSITIVE : READ FORWARD ENOUGH TIMES.
RGOFORW  OI    FLAGSR,YESEOF       WE WANT TO STOP AT EOF FOR +
         BAL   R8,READNBLK         READ NEXT BLOCK
         TM    FLAGSR,YESSYN       WAS THERE AN I/O ERROR?
         BO    NEWDSPNT            YES, CUT THIS OUT
         BCT   R3,RGOFORW          GO FORWARD
         B     NEW$READ            WHEN DONE, DISPLAY IT
*              OFFSET IS NEGATIVE : READ BACKWARD ENOUGH TIMES.
RGOBACW  LTR   R5,R5               WAS ABSOLUTE ON THIS TRACK?
         STC   R5,TTR+2            ASSUME YES, SET NEW RECORD
         BP    NEW$READ            YES, READ IT
*              BACK UP A TRACK.
         LH    R0,TTR              GET TRACK NUMBER
         BCTR  R0,0                MINUS ONE
         LTR   R0,R0               BACK TO ZERO?
         BNM   RCOUNT              ITS GOOD, COUNT TRACK
         MVC   TTR,=XL4'00000100'  BACKED UP TOO FAR
         BAL   R8,SETMSG           MOVE MESSAGE TO RIGHT PLACE
         DC    Y(TTRSMALL+1-ETPSXZAP) 'TTR < 000001 INVALID'
         B     NEW$READ            DISPLAY FIRST RECORD
RCOUNT   STH   R0,TTR              SAVE FOR COUNT
         MVI   TTR+2,0             IT WILL INCREMENT
         MVC   TEMP2(L'TTR-1),TTR  SAVE TTR
BCKCNT   BAL   R8,READNBLK         GET NEXT BLOCK
         CLC   TEMP2(2),TTR        STILL THIS TRACK?
         BNE   RNEWTRK             NO
         TM    FLAGSR,YESSYN       I/O ERROR?
         BO    NEWDSPNT            GET OUTA HERE
         MVC   TEMP2+2(1),TTR+2    SAVE THIS RECORD
         B     BCKCNT              CONTINUE DOWN TRACK
RNEWTRK  MVC   TTR(2),TEMP2        RESTORE PREVIOUS TRACK
         XR    R1,R1               CLEAR FOR PICKUP
         IC    R1,TEMP2+2          GET NUMBER OF RECS
         AR    R5,R1               WE NOW ARE THIS FAR BACK
         B     RGOBACW             GO SEE IF ITS ON THIS TRK
*- - - - CAPSON, CAPSOFF.                                        <===*
CAPSON   MVI   CAPSFLG,YESCAPS     SET CAPS ON
         LA    R2,CONMSG           TELL STATUS DONE
         B     BOTCH               GO BACK TO DISPLAY
CAPSOFF  MVI   CAPSFLG,NOCAPS      SET CAPS OFF
         LA    R2,COFFMSG          TELL STATUS DONE
         B     BOTCH               GO BACK TO DISPLAY
*- - - - L, F.                                                   <===*
PFKLOC   MVC   REPLINE,BLANKS
         MVI   REPLINE,C'L'
         MVC   MSGLINE,BLANKS      CLEAR THE ERR-MSG IF ANY
         XR    R0,R0
         STH   R0,REALRDLN              FAKE THE READ LENGTH
         MVI   REALRDLN+1,1
FIND     NI    FLAGSR,255-YESEOF   SET SO EOF'S COME BACK
LOCATE   LTR   R3,R0               TEST OPERAND LENGTH
         BZ    LGO                 JUST L, GO CONTINUE
         LR    R4,R1               POINT TO STRING
         LA    R5,LOOKFOR          POINT TO STRING WORK-AREA
         BAL   R6,GETSTRNG         GET THE HEX OR CHAR STRING
         B     AROUND1
*              CONTINUE SCAN.
LGO      TM    TCONT,YESCONTL      CAN WE CONTINUE SCAN?
         LA    R2,LINMSG           ASSUME NO, POINT TO MESSAGE
         BZ    BOTCH               NO, NO SCAN WAS STARTED
         LH    R3,LOOKFOR          YES, GET THE SCAN LENGTH
*              SET UP SCAN.
AROUND1  LA    R14,LOOKFOR         GET THE STRING ADDRESS
         BAL   R8,STRCNV           GO APPLY CONVERSION
         XR    R2,R2               CLEAR REGISTER FOR IC (WHAT ELSE?)
         IC    R2,WKSTR            GET 1ST CHAR TO FIND
         LA    R2,TEMPTRT(R2)      POINT TO OFFSET IN TRTAB
         XC    TEMPTRT(256),TEMPTRT CLEAR TRTAB
         MVI   0(R2),X'FF'         MOVE IN FF THERE
         OI    TCONT,YESCONTL      SAY HE CAN CONTINUE SCAN NOW
         LH    R1,OLDPOINT         GET CURRENT OFFSET
         CLI   REALRDLN+1,1        JUST 'L' ENTERED?
         BNE   LOOKSC              NO, START FROM HERE
         LA    R1,1(,R1)           YES, START FROM NEXT BYTE
*              BLOCK SCAN LOOP.
LOOKSC   A     R1,ADDRBUFF         POINT TO OFFSET IN BUFFER
         BCTR  R1,0                -1
         LH    R5,BLKLEN           GET BLK LENGTH
         A     R5,ADDRBUFF         POINT TO END OF BLK
*              DO THE SCAN.
LOOKLOOP LR    R2,R5               GET END
         SR    R2,R1               COMPUTE LENGTH
         SH    R2,=H'2'            GET LENGTH OF REMAINDER
         BM    TOOFAR              NOT ENOUGH
         EX    R2,SCANTRT          FIND INTERESTING STRING
         BZ    LOOKT               NOT YET, KEEP TRYING
         CLR   R1,R5               YES, BUT IS IT PAST THE BLK?
         BNL   TOOFAR              YES, SO GET A NEW ONE
         EX    R3,SCANCLC          NO, IS ALL OF IT THERE?
         BNE   LOOKLOOP            NO, KEEP CHECKING
         MVC   MSGLINE+17(40),=CL40'        *****  SCAN MATCH  *****'
         S     R1,ADDRBUFF         YES, GET WHERE IT IS AND...
         LR    R15,R1              INTO RIGHT REGISTER
         B     SETPOINT            FAKE A '+' COMMAND TO IT
SCANTRT  TRT   1(*-*,R1),TEMPTRT   <<EXECUTED>>
SCANCLC  CLC   0(*-*,R1),WKSTR     <<EXECUTED>>
LOOKT    N     R2,=XL4'000000FF'   GET CLEAN SINGLE BYTE
         LA    R1,1(R1,R2)         SET LOCATION TO TRY AGAIN
         CLR   R1,R5               PAST BLK?
         BL    LOOKLOOP            NO, KEEP SCANNING
TOOFAR   BAL   R8,CHKPT            ANY ZAP NEEDED?
TOOFNXT  BAL   R8,READNBLK         GET NEXT BLOCK FOR SCANNING
         TM    FLAGSR,YESSYN       I/O ERROR?
         BO    NEWDSPNT            YES, GET OUT
         CLI   ZDSNME,X'04'        VTOC?
         BE    TOOFVTC             YES, DIFFERENT CHECK
         CLC   TTR(L'TTR-1),ENDTTR HAVE WE ARRIVED?
         BNE   NOTFAR              NO
         MVC   MSGLINE+22(33),=CL33'*****  HOLDING AT DS1LSTAR  *****'
         B     SETPNT00            DISP OFF 0, CURR BLK
TOOFVTC  CLC   CCHHR,LASTFMT1      IS THIS THE LAST FMT1?
         BNE   NOTFAR              NO, CONTINUE SCAN
         MVC   MSGLINE+22(33),=CL33'*****  HOLDING AT LASTFMT1  *****'
         B     SETPNT00            DISP OFF 0, CURR BLK
NOTFAR   OC    BLKLEN,BLKLEN       ANYTHING HERE? (EOF IF 'F')
         BE    TOOFNXT             NO, GET NEXT BLOCK
         XR    R1,R1               RESET BUFFER POINTER
         B     LOOKSC              GO SCAN IT THEN
*- - - - S, X, O, N.                                             <===*
AND      BAL   R2,SXON             POINT TO EX INSTR, GO DO IT
         NC    0(*-*,R5),WKSTR     <<EXECUTED>>
OR       BAL   R2,SXON             POINT TO EX INSTR, GO DO IT
         OC    0(*-*,R5),WKSTR     <<EXECUTED>>
EXOR     BAL   R2,SXON             POINT TO EX INSTR, GO DO IT
         XC    0(*-*,R5),WKSTR     <<EXECUTED>>
STORE    BAL   R2,SXON             POINT TO EX INSTR, GO DO IT
         MVC   0(*-*,R5),WKSTR     <<EXECUTED>>
*              ALLOW HIM TO USE PREVIOUS STRING IF HE JUST ENTERS
*              THE COMMAND WITH NO SUBSEQUENT STRING OPERAND.
SXON     ST    R2,TEMP1            SAVE THE EX INSTR POINTER
         LTR   R3,R0               TEST OPERAND LENGTH
         BP    SXONNEW#            HAVE AN OPERAND - USE IT
*              USE AN OLD STRING FOR S,X,O,N WITH NO OPERANDS.
         TM    TCONT,YESCONTS      JUST 'S'.  OLD STRING YET?
         BO    SXONNEW             YES, GO ON
         B     INVEXPER            SAY SYNTAX ERROR COL 2
INVALCOM LA    R2,INVCOM           POINT TO MESSAGE
         B     BOTCH               AND TELL HIM
*              USE SPECIFIED STRING.
SXONNEW# LR    R4,R1               POINT TO STRING OPERAND
         LA    R5,ZAPSTRNG         POINT TO STRING WORK-AREA
         BAL   R6,GETSTRNG         GET AL2(LEN),C'STRING'
*              AT THIS POINT, ZAPSTRNG CONTAINS THE INFO NECESSARY
*              TO STORE : AL2(STRING_LENGTH),C'STRING'
SXONNEW  OC    BLKLEN(2),BLKLEN    ANYTHING TO CHANGE HERE?
         BZ    INVALCOM            NO, TELL HIM
         TM    FLAGSG,GODUP        CAN HE EVER UPDATE?
         BO    LETSTORE            YES, SO GO ON
         BAL   R8,SETMSG           MOVE MESSAGE TO RIGHT PLACE
         DC    Y(STORMSG-ETPSXZAP) TELL HIM NOT UPDATING
LETSTORE LA    R14,ZAPSTRNG        GET THE STRING ADDRESS
         BAL   R8,STRCNV           GO APPLY CONVERSION
         LH    R4,ZAPSTRNG         GET LENGTH
         LH    R5,OLDPOINT         POINT TO ZAPPED OFFSET
*              CHECK TO SEE IF STRING WILL FIT IN THE REMAINING
*              PART OF THE BLK WHERE HE IS POINTING.
         LH    R6,BLKLEN           GET LENGTH OF BLK
         SR    R6,R5               GET LENGTH OF PIECE REMAINING
         CLR   R6,R4               IS IT SMALLER THAN THE STRING?
         LA    R2,LENERR           ASSUME STRING IS INVALID LENGTH
         BNH   BOTCH               YES, SO GO TELL HIM
*              STRING WILL FIT.
         A     R5,ADDRBUFF         POINT TO ACTUAL ZAPPED DATA
         OI    TCONT,YESCONTS      SAY HE CAN DO 'SXON' NO OPRND
         LA    R1,1                MESSAGE NUMBER
         BAL   R8,SETLINE          SET UP THE LINE
         B     NOMSGEX             NOT LOGGING
         CLI   CHNGED,0            VIRGIN BUFFER?
         BNE   *+L'*+4             NO, SINGLE SPACE
         MVI   0(R2),C'0'          ELSE, DOUBLE SPACE FIRST CHANGE
         MVC   30(16,R2),=CL16'OFFSET XXXX DATA'
        @HEX   (37,R2),OLDPOINT,LEN=2 CONVERT OFFSET TO THE LINE
         LA    R1,48(R2)           POINT TO SPOT
         BAL   R8,SETSTRNG         CONVERT STRING TO LINE AS WAS
         MVC   104(5,R2),=CL5'CCHHR' MOVE IN IDENTIFIER
        @HEX   (110,R2),CCHHR,LEN=5 GET THE CCHHR
         BAL   R8,CPUT
         LA    R1,1                MESSAGE NUMBER
         BAL   R8,SETLINE
         B     NOMSGEX             NOT LOGGING
         MVC   30(16,R2),=CL16'TO BE CHANGED TO'
         LA    R1,48(,R2)
         L     R2,TEMP1            RESTORE EX INSTRUCTION POINTER
         EX    R4,0(R2)            CHANGE DATA IN BUFFER
         BAL   R8,SETSTRNG         RECORD THE CHANGE
         BAL   R8,CPUT             PUT THE LINE
         MVI   CHNGED,255          MARK AS CHANGED FOR LATER
         OI    FLAGSX,MUSTZAP      BLOCK NEEDS A ZAP NOW
         MVC   OLDTTR(L'TTR-1),TTR COPY FOR PRINTING
         B     NEWDSPNT            THEN RETURN TO HIM
NOMSGEX  L     R2,TEMP1            RESTORE EX INSTRUCTION POINTER
         EX    R4,0(R2)            MAKE THE APPROPRIATE CHANGE
         OI    FLAGSX,MUSTZAP      BLOCK NEEDS A ZAP NOW
         B     NEWDSPNT            GIVE IT TO HIM
*- - - - SET.                                                    <===*
SET      LTR   R3,R0               TEST OPERAND LENGTH
         BP    SETNEW#             THERE IS ONE
*              USE OLD STRING FOR SET NO OPERANDS.
         TM    TCONT,YESCONTT      IS THERE AN OLD ONE TO USE?
         BO    SETNEW              YES, USE IT
         B     INVEXPER            INVALID SYNTAX COL 4
*              USE SPECIFIED STRING.
SETNEW#  LR    R4,R1               -> TO THE STRING OPERAND
         LA    R5,SETZSTR          WHERE TO SAVE THE INFO
         BAL   R6,GETSTRNG         GET AL2(LEN),C'STRING'
*              NOW SETZSTR CONTAINS : AL2(SET_LEN),C'SET_STRING'
SETNEW   OC    BLKLEN(2),BLKLEN    IS THERE ANYTHING TO SET?
         BZ    INVALCOM            NO, SO DON'T AND TELL HIM
         TM    FLAGSG,GODUP        CAN HE EVER UPDATE?
         BO    LETSET              YES, WE HAVE NOTHING TO SAY
         BAL   R8,SETMSG           MOVE MESSAGE TO RIGHT PLACE
         DC    Y(STORMSG-ETPSXZAP) TELL HIM NOT UPDATING
LETSET   LA    R14,SETZSTR         GET THE STRING ADDRESS
         BAL   R8,STRCNV           GO APPLY CONVERSION
         LH    R4,SETZSTR          GET BCTR'D STRING LENGTH
         LA    R5,WKSTR            POINT TO STRING
         LA    R1,2                MESSAGE NUMBER
         BAL   R8,SETLINE          SET UP LINE
         B     NOSETMSG            OOPS, NOT LOGGING
         CLI   CHNGED,0            VIRGIN BUFFER?
         BNE   *+L'*+4             NO, SINGLE SPACE
         MVI   0(R2),C'0'          ELSE, DOUBLE SPACE FIRST CHANGE
         MVC   30(28,R2),=CL28'FOLLOWING BLOCK TO BE SET TO'
         LA    R1,30+28+1(,R2)     POINT WHERE IT GOES
         BAL   R8,SETSTRNG         CONVERT THE STRING
         BAL   R8,CPUT             DUMP THE LINE NOW
         MVI   CHNGED,255          ITS CHANGED NOW
         MVC   OLDTTR(L'TTR-1),TTR SAVE TTR
         BAL   R6,PREPDMPX         GET READY FOR THE DUMP
         BAL   R6,DUMPER           DUMP THE BLOCK
         LH    R4,SETZSTR          RESTORE LENGTH
NOSETMSG OI    TCONT,YESCONTT      SAY HE CAN SET NO OPRND NOW
         OI    FLAGSX,MUSTZAP      BLK NEEDS A ZAP NOW
         L     R5,ADDRBUFF         POINT TO BUFFER
         XR    R8,R8               CLEAR REM REGISTER FOR DIVIDE
         LH    R7,BLKLEN           GET LENGTH OF BLK IN BUFFER
         LA    R1,1(R4)            GET REAL STRING LENGTH
         DR    R8,R1               HOW MANY STRINGS FIT IN BLK
         LTR   R7,R7               BLK SHORTER THAN STRING?
         BZ    JUSTSPEW            YES, JUST MOVE IN REMAINDER
*              R7 HAS BCT COUNT OF HOW MANY STRINGS CAN FIT
*              IN THIS PARTICULAR BLK, WHILE R8 HAS THE LENGTH
*              OF THE PIECE LEFT OVER.
SETLOOP  EX    R4,SETMVC           MOVE 1 STRING IN
         LA    R5,1(R4,R5)         UPDATE BUFFER POINTER FOR NEXT
         BCT   R7,SETLOOP          FILL AS MUCH OF BUFFER AS CAN
JUSTSPEW LTR   R8,R8               IS THERE A SMALL PIECE LEFT?
         BZ    NEWDSPNT            NO, WE ARE ALL DONE
         BCTR  R8,0                YES, GET EXECUTE LENGTH
         EX    R8,SETMVC           MOVE AS MUCH AS WILL FIT IN
         B     NEWDSPNT            AND GO DISPLAY WHAT WE DID
SETMVC   MVC   0(*-*,R5),WKSTR     <<EXECUTED>>
*- - - - ZAP/SAVE.                                               <===*
REPLACE  TM    FLAGSR,YESSYN       WAS THERE AN I/O ERROR ON BLK?
         BO    WRTNONO             YES, CAN'T ZAP THAT
         OC    BLKLEN(2),BLKLEN    NO, BUT IS THERE A BLK TO ZAP?
         BZ    WRTNONO             NO, SO DON'T ZAP ALREADY
         TM    DCBLIST,X'0F'       UPDATING ALREADY?
         BNZ   THERE               YES, CONTINUE
         TM    FLAGSG,GODUP        CAN HE CHANGE FROM INPUT TO UP
         BZ    WRTNONO             NO, TOUGH BEANS FOR HIM
         MVC   REPLINE,BLANKS      CLEAR REPLY
         MVC   REPLINE(3),=CL3'ZAP' RE-PROMPT THE RIGHT THING
        CLOSE  MF=(E,DCBLIST)      CLOSE THE DATA-SET SO THAT...
         MVI   DCBLIST,VLB+4       WE CAN OPEN FOR UPDATE
        OPEN   MF=(E,DCBLIST),TYPE=J THEN DO IT ALREADY
         TM    DCBU+DCBOFLGS-IHADCB,DCBOFOPN OPEN?
         BO    THERE#              YES, OK
         BCR   0,1                 DRAIN PIPELINE
         EX    0,*                 THIS BETTER NEVER HAPPEN
THERE#   TM    FLAGSL,LOGOPN       SEE IF LOGGING
         BZ    THERE               IF NOT, THEN NO MESSAGE
         BAL   R8,OPENMSG          GO WRITE THE MESSAGE
THERE    BAL   R8,WRITE            WRITE THE BUFFER OUT
         TM    FLAGSR,YESSYN       I/O ERROR?
         BO    NEWDSPNT            YES, IGNORE TELLING HIM OK
         MVI   CHNGED,0            BUFFER HAS BEEN CHECKPOINTED
         NI    FLAGSX,255-MUSTZAP  BLK NO LONGER NEEDS ZAP
*              UPDATE THE IDR IF APPLICABLE.
*              IDR FOR SUPERZAP (AND THEREFORE ZAP) TAKES THE
*              FOLLOWING FORM :
*                BYTE  0.....'80' FOR ID
*                BYTE  1.....LENGTH OF IDR (USUALLY X'FA' = 250.)
*                BYTE  2.....WHO'S IDR IT IS (X'01' FOR SUPERZAP AND
*                            AND ZAP)
*                BYTE  3.....NUMBER OF 13-BYTE IDR DATA ENTRIES (BITS
*                            2-7)
*                BYTES 4-16, 17-29,... IDR DATA ENTRY AS FOLLOWS :
*                  BYTES 0-1 --- ESD ID (DEFAULT 1)
*                  BYTES 2-4 --- DATE ('YYDDDF')
*                  BYTES 5-12 -- INFO ('TSO--UUU, WHERE UUU=ZAPPER'S
*                                UID)
         CLI   ZDSORG,DCBDSGPO     IS THIS A PDS?
         BNE   FINZAP              NO, FORGET THE IDR
         CLI   DCBU+DCBRECFM-IHADCB,DCBRECU IS THIS A LIBRARY?
         BNE   FINZAP              NO, DON'T UPDATE THE 'IDR'
         CLI   IDRFLAG,CHGIDR      ALREADY UPDATED THIS IDR
         BE    FINZAP              YES, DON'T DO IT AGAIN NOW
         MVC   TEMP1(L'TTR-1),TTR  LET'S SAVE WHERE HE WAS FIRST
         OC    MEMTTR,MEMTTR       WAS THERE A 'M' COMMAND?
         BZ    ENDIDR              NO, FORGET IT
         MVC   TTR(L'TTR-1),MEMTTR PICK UP MEMBER POINTER
         BAL   R8,READBLK          READ 1ST BLOCK OF MEMBER
IDRFIND  L     R1,ADDRBUFF         GET BUFFER POINTER
         TM    0(R1),X'01'         CONTROL RECORD OF SOME SORT?
         BO    ENDIDR              YES, WE ARE ALL DONE LOOKING
         CLI   0(R1),X'80'         IDR?
         BNE   NEWBLK              NO, GET ANOTHER BLK
         TM    2(R1),X'01'         YES, BUT DONE BY SUPERZAP?
         BZ    NEWBLK              NO, FORGET THIS ONE
         XR    R2,R2               CLEAR WORK REGISTER
         IC    R2,3(R1)            PICK UP # OF IDR DATA ENTRIES
         LR    R4,R2               SAVE IT FOR LATER
         N     R2,=XL4'0000003F'   WE JUST WANT BITS 2-7
         MH    R2,=H'13'           EACH ENTRY IS 13 BYTES LONG
         LA    R2,3(R2)            IDR HDR IS 3 BYTES LONG
*              SO NOW R2 HAS AN OFFSET TO THE NEXT
*              AVAILABLE POSITION IN THE IDR.
         XR    R3,R3               CLEAR WORK REGISTER
         IC    R3,1(R1)            PICK UP IDR LENGTH
         CLR   R3,R2               ARE WE AT END OF IDR?
         BH    UPDATIDR            NO, SO UPDATE THE IDR
NEWBLK   NI    FLAGSR,255-YESEOF   TREAT EOF'S AS DATA BLKS
         BAL   R8,READNBLK         READ ON ANOTHER BLOCK
         CLC   IOMLINE+27(20),EOFMSG DID I HIT END OF FILE?
         BE    ENDIDR              YES, STOP THIS STUPID THING
         TM    FLAGSR,YESSYN       I/O ERROR?
         BO    ENDIDR              YES, LEAVE
         B     IDRFIND             NO, CHECK THIS BLK
UPDATIDR AR    R2,R1               R2 PTS TO NEXT IDR SPOT
         LA    R4,1(R4)            INCREMENT # OF IDR ENTRIES...
         STC   R4,3(R1)            AND PUT IT BACK
         MVC   1(2,R2),ESDID       MOVE IN ESDID (IF ANY)
        TIME   ,                   GET THE DATE IN R1 (0CYYDDDF)
         ST    R1,ZDBLW            SAVE IT IN TEMPORARY WORD
         MVC   3(3,R2),ZDBLW+1     MOVE YYDDDF TO IDR
         MVI   6(R2),C'/'          INDICATE TSO USERID
         MVC   7(7,R2),ZUSRID      MOVE IN THE CULPRIT
         BAL   R8,WRITE            GO WRITE THE RECORD BACK
         TM    FLAGSR,YESSYN       I/O ERROR?
         BO    ENDIDR              YES, SAY WE DIDN'T UPDATE
         MVI   IDRFLAG,CHGIDR      NO, SO WE DID UPDATE THE IDR
ENDIDR   LA    R1,6                ASSUME NOT UPDATED
         CLI   IDRFLAG,CHGIDR      WAS THE IDR UPDATED?
         BNE   *+L'*+4             NO, WE WERE RIGHT
         LA    R1,7                DID UPDATE, MESSAGE NUMBER
         BAL   R8,SETLINE          SET UP OUTPUT LINE
         B     PUTBACK             NO "LOG" FILE, LEAVE
         MVI   0(R2),C'0'          DOUBLE SPACE
         MVC   20(25,R2),=CL25'IDR FOR CSECT NOT UPDATED'
         CLI   IDRFLAG,CHGIDR      WAS IT UPDATED?
         BNE   PUTITOUT            NO, MESSAGE IS OK
         MVC   34(3,R2),EDMASK+9   YES, SO GIVE ESDID
         LH    R0,ESDID            GET ESDID (USUALLY)
         CVD   R0,ZDBLW            IN DEC
         ED    33(4,R2),ZDBLW+6    ESDID TO MESSAGE
PUTITOUT BAL   R8,CPUT             PUT MESSAGE OUT
PUTBACK  CLC   TTR(L'TTR-1),TEMP1  HAS HE MOVED ANY?
         BE    FINZAP              YES, DON'T BOTHER PUTTING BACK
         MVI   TTR+3,NOSEQRD       GET THE RIGHT ONE, NOT THE NEXT
         MVC   TTR(L'TTR-1),TEMP1  LET'S PUT HIM BACK WHERE HE WAS
         BAL   R8,READBLK          HE'LL NEVER KNOW WHAT HAPPENED
FINZAP   MVC   MSGLINE+17(40),=CL40'      *****  BLOCK REPLACED  *****'
         LA    R1,3                MESSAGE NUMBER
         BAL   R8,SETLINE          SETUP THE LINE
         B     NEWDSPNT            NOT LOGGING
         MVC   30(14,R2),=CL14'BLOCK REPLACED'
         MVI   0(R2),C'0'          DOUBLE SPACE THIS ONE
         BAL   R8,CPUT             DUMP THE LINE
*              TRUNCATE CURRENT LOG BLOCK, IN CASE OF
*              SYSTEM/PROGRAM FAILURE.
         L     R1,CSALOC           IT'S GOTTA BE HERE
         LA    R0,1                (+) SET AS TRUNCATE CALL
         L     R15,=A(CSOUT)       (+) POINT TO ROUTINE
        CALL   (15)                (+) CALL IT
         B     NEWDSPNT            THEN DISPLAY WITH NO TRACE
WRTNONO  LA    R2,WRITERR          TELL HIM WRITE NOT ALLOWED
         MVC   REPLINE,BLANKS      CLEAR OUT REPLY BUFFER AND SO DON'T
*                                  TEMPT HIM TO RE-'ZAP'
         B     BOTCH               AND DISPLAY
*- - - - DISASM, ASM.                                            <===*
DISASM   LH    R15,OLDPOINT        CURR OFFSET
         MVI   EXPOPT,YESSYMB      WANT SYMBOL TABLE LOOKUP
         BAL   R8,CALLEXP          PARSE & CHECK
         BM    INVEXPER            NEG IS BAD
         LH    R0,BLKLEN           GET LENGTH BLK
         SH    R0,=H'2'            LAST POSS INSTRUCTION
         CLR   R15,R0              PAST END OF BLK?
         BH    INVEXPER
         A     R15,ADDRBUFF        GET ADDRESS IN BUFFER
         LNR   R1,R15              NEG FOR 'DISASM'
         LA    R0,MSGLINE+24       GIVE HIM 33 BYTES TO WORK WITH
         LA    R2,TEMP3            GIVE HIM SOME WORK-AREA TOO
         L     R15,=A(ASMGASM)     POINT TO 'ASSEMBLER' HAR HAR
        CALL   (15)                DISASSEMBLE IT
         LA    R2,INVOPCOD         ASSUME BOTCHUP
         LTR   R15,R15
         BNZ   BOTCH               YUP
         MVC   MSGLINE+17(7),=CL7'INSTR:' NO, MOVE MASK
         B     NEWDSPNT            AND SHOW IT OFF
ASM      BNP   INVEXPER            NO OPERAND - BAD
         L     R15,=A(ASMGASM)     POINT TO SUB
        CALL   (15)                GET OBJECT
         LA    R2,INVOPCOD         ASSUME NO
         LTR   R15,R15
         BNZ   BOTCH               YUP
         MVC   MSGLINE+17(8),=CL8'OP CODE:' MASK
        @HEX   MSGLINE+27,(0,R1),LEN=1
         B     NEWDSPNT            SHOW IT
*- - - - V, BASE.                                                <===*
INDIRECT LH    R15,OLDPOINT        * = CURRENT OFFSET
         MVI   EXPOPT,YESSYMB      WANT SYMBOL TABLE LOOKUP
         BAL   R8,CALLEXP          PARSE & CHECK
         BM    INVEXPER            NEG IS INVALID
         LH    R0,BLKLEN           GET BLOCK LENGTH
         SH    R0,=H'2'            LAST POSSIBLE RDW
         CLR   R15,R0              PAST END?
         BH    INVEXPER            YES, BYE
         A     R15,ADDRBUFF        GET ADDRESS IN BUFFER
         MVC   TEMP1(2),0(R15)     REC LENGTH TO ALIGNED PLACE
         LH    R15,TEMP1           GET RECORD LENGTH
         AH    R15,OLDPOINT        BUMP OFFSET
         B     SETPOINT            GO SET IT
*              DO WE WANT TO GO TO THE NEXT BLK IF NECESSARY?
BASE     L     R15,OFFSET          * = CURRENT OFFSET
         MVI   EXPOPT,YESSYMB      WANT SYMBOL TABLE LOOKUP
         BAL   R8,CALLEXP          PARSE & CHECK
         ST    R15,BASEVAL         SET NEW BASE VALUE
         AH    R15,OLDPOINT        ADD OLD BUFFER OFFSET
         ST    R15,OFFSET          SET NEW OFFSET
         B     NEWDSPNT            GO SHOW IT OFF
*- - - - WHERE.                                                  <===*
WHERE    NI    FLAGSR,255-YESTRACE DONT TRACE
         BAL   R8,CLEAR            CLEAR SCREEN
         B     WHEREAMI            FORMAT LINE
*- - - - WINDOW.                                                 <===*
*              W
*              WFULL
*              W<DOWN>,<UP>
WINDOW   BP    OKWIND              GO PROCESS OPERANDS
         XC    WIDTHS(4+4),WIDTHS  ONLY 'W', SET DEFAULTS
         B     NEWDSPNT            AND QUIT
OKWIND   CLC   REPLINE+1(4),=CL4'FULL' FULL WINDOW SPECIFIED?
         BNE   OKWIND#             NO, GO ON
         L     R6,MAXWIDTH         YES, SAY FULL
         LR    R7,R6               SAY FULL HERE TOO
         B     WINDSAVE            WE ARE DONE
OKWIND#  LM    R6,R7,WIDTHS        ASSUME WIND=CURR WIND
         LR    R4,R0               SAVE LENGTH OP(S)
         LR    R5,R1               SAVE POINTER TO OPERANDS
WINDLOOP CLI   0(R5),C','          END 1ST OP?
         LA    R5,1(,R5)           ASSUME YES
         BE    *+L'*+4             RIGHT, DO 1ST
         BCT   R4,WINDLOOP         TRY TRY
         SR    R0,R4               LENGTH 1ST
         BZ    *+L'*+6             NO 1ST, DO 2ND
         BAL   R3,WINDEXP          PARSE, R1 SET, *=0
         LR    R6,R15              ALL OK, SAVE FOR <DOWN>
         LR    R0,R4               LENGTH LEFT = LENGTH 2ND (ALMOST)
         SH    R0,=H'1'            -1 FOR COMMA (IF ANY)
         BNP   WINDSAVE            NO 2ND OP, LEAVE ALONE
         LR    R1,R5               SET OP POINTER FOR "EXP"
         BAL   R3,WINDEXP          GO PARSE 2
         LR    R7,R15              ALL OK, SAVE <UP>
WINDSAVE STM   R6,R7,WIDTHS        SAVE THE 2 WIDTHS
         B     NEWDSPNT
WINDEXP  XR    R15,R15             * = 0
         BAL   R8,CALLEXP          PARSE & CHECK
         BM    INVEXPER            NEGATIVE IS BAD
         CL    R15,MAXWIDTH        TOO BIG?
         BNHR  R3                  NO, RETURN
         B     INVEXPER            YES, COMPLAIN
*- - - - FLOAT.                                                  <===*
*              (ORIGINAL INTX SVCX 6 CODE WRITTEN BY STEVE SILVER.
*              MODIFIED FOR ZAP USE BY JCJ AND VIC
*              - IE : WE DON'T UNDERSTAND).
FLOAT    LTR   R2,R0               TEST OPERAND LENGTH
         BP    FLOAT$              GO USE IT
         LH    R15,OLDPOINT        GET CURRENT OFFSET
         LR    R14,R15             COPY
         AH    R14,=H'8'           POINT PAST END OF OPERAND
         CH    R14,BLKLEN          IN BLOCK?
         BNL   INVEXPER            NO, ERROR
         A     R15,ADDRBUFF        -> OPERAND
         MVC   TEMP2(8),0(R15)     GET IN ALIGNED PLACE
         B     FLOAT#              CONTINUE WITH IT
FLOAT$   BCTR  R2,0                GET EXECUTE LENGTH
         CH    R2,=H'15'           WAS THE OPERAND TOO LONG?
         BH    LENERROR            YES, TELL HIM AND QUIT
         LR    R7,R1               POINT TO THE STRING
         LA    R1,1(,R2)           PICK UP LENGTH OF STRING
         BAL   R8,HEXCHECK         IS IT VALID HEX?
         B     OKFLOAT             YES, SO LET'S DO IT
         LR    R1,R7               NO, POINT TO THE ERROR
         B     INVEXPER            AND SAY SYNTAX ERROR
OKFLOAT  EX    R2,TRFLOAT          START TRANSLATE TO REAL HEX
         PACK  TEMP2(8),TEMP3+5(15) MAKE IT HONEST-TO-GOODNESS HEX
         MVN   TEMP2+7(1),TEMP3+20 GET THE LAST NIBBLE TOO
FLOAT#   LD    FPR0,TEMP2          LOAD IT IN FLOAT REGISTER 0
         LA    R7,MSGLINE+36       POINT TO START OF SCREEN RESULT AREA
*              SET THE PROGRAM MASK TO MASK OUT FIX POINT OFLO,
*              DEC OFLO, EXPON UNFLO, AND SIGNIFICANCE.
*              SAVE IT IN R6 TO RESET IT LATER.
         XR    R2,R2               0 R2 FOR SPM
         BALR  R6,0                SAVE PGM MASK FOR RESTORE
         SPM   R2                  0 THE PGM MASK (NO INTERR)
         MVI   16(R7),C'0'         ASSUME ANSWER IS 0
         AD    FPR0,=D'0'          NORMALIZE BY ADDING 0
         LTDR  FPR0,FPR0           CHECK THE SIGN
         BZ    CVFCI3              ZERO (WE'RE ALMOST DONE)
         BP    CVFC00              PLUS, GO ON
         LPDR  FPR0,FPR0           MINUS, MAKE IT PLUS ...
         MVI   0(R7),C'-'          INSERT SIGN AND GO ON LIKE PLUS
CVFC00   LA    R7,1(R7)            UPDATE OUTPUT POINTER EITHER CASE
         CD    FPR0,=X'7FFFFFFFFFFFFF00' DATA WILL CAUSE EXP OVERFLOW?
         BNH   *+L'*+4             NO - SKIP PREVENT LOAD
         LD    FPR0,=X'7FFFFFFFFFFFFF00' ELSE GET MAX ALLOWABLE
*              MAX ALLOWABLE IS X'7FFFFFFFFFFFFF00'
         MD    FPR0,=X'4110000000000010' MULT BY FUDGE FACTOR
*              GENERATE THE NUMBER IN D-FORMAT.
         XR    R2,R2               INITIALIZE EXPON REGISTER
         LD    FPR4,=D'10'         SET FP-R4 TO 10
         LD    FPR6,=D'1'          SET FP-R6 TO 1
         LD    FPR2,=X'401999999999999A' SET FP-R2 TO .1
         MVI   0(R7),C'.'          SET UP OUTPUT
         LA    R7,1(R7)            INCREMENT LINE POINTER
         MVI   14(R7),C'D'         FORM THE OUTLINE OF EXPONENT
         MVI   15(R7),C'+'         MOVE IN EXPONENT SIGN
*              GET THE EXPONENT IN R2 (>=1).
CVFC1A   CDR   FPR0,FPR6           SEE IF # < 1
         BL    CVFC2               IF SO, GO TO NEXT PART
         DDR   FPR0,FPR4           NO, DIVIDE BY 10
         LA    R2,1(R2)            INCREMENT EXPONENT
         B     CVFC1A              CONTINUE
*              GET THE EXPONENT (<.1).
CVFC2    CDR   FPR0,FPR2           SEE IF >= .1
         BNL   CVFC3               IF SO, GO TO NEXT PART
         BCTR  R2,0                DECREMENT EXPONENT
         MDR   FPR0,FPR4           MULT NUMBER BY 10
         B     CVFC2               CONTINUE
*              GET EXPONENT SIGN.
CVFC3    LTR   R2,R2               SEE IF EXPONENT +
         BNM   CVFC3A              IF SO, SKIP CODE
         LPR   R2,R2               MAKE IT PLUS BUT ...
         MVI   15(R7),C'-'         WRITE OUT A MINUS
CVFC3A   LA    R0,10               DIVISER FOR BELOW
         SRDL  R2,32               SET UP FOR DIVIDE
         DR    R2,R0               DO THE DIVIDE
         LA    R2,C'0'(R2)         GET THE EBCDIC VALUE
         LA    R3,C'0'(R3)         GET THE EBCDIC VALUE
         STC   R2,17(R7)           AND STORE IT
         STC   R3,16(R7)           AND STORE IT
         LA    R0,14               GET NUMBER OF DIGITS FOR BCT
         LD    FPR6,=X'4100000000000000' LOAD FP-R6 WITH UN-NORMALIZER
*              GET THE MANTISSA.
CVFC4    MDR   FPR0,FPR4           MULT NUMBER BY 10
         AWR   FPR0,FPR6           UN-NORMALIZE
         STD   FPR0,TEMP2          STORE RESULT
         XR    R4,R4               ZERO FOR IC
         IC    R4,TEMP2+1          GET FIRST HEX DIGIT
         SRA   R4,4                KILL LOW NIBBLE (LAST HEX DIG)
         LA    R3,C'0'(R4)         CONVERT TO CHAR
         STC   R3,0(R7)            MOVE RESULT TO OUTPUT
         XC    TEMP2(8),TEMP2      SET UP DBLW
         LA    R7,1(R7)            POINT TO NEXT OUTPUT COL
         LTR   R4,R4               IS R4 0?
         BZ    CVFC4#              YES, WE HAVE NOTHING TO DO
         MVI   TEMP2,X'41'         MAKE DBLW INTERNAL FLOATING POINT
         SLL   R4,4                MOVE NUMBER TO HIGH ORDR NIBBLE
         STC   R4,TEMP2+1          AND MOVE IT TO DBLW
*              WE HAVE NOW BUILT A DBLW WHICH MAY CONTAIN D'0'
*              THROUGH D'10'.
         SD    FPR0,TEMP2          SUBTRACT THE INTEGER PART
CVFC4#   BCT   R0,CVFC4            DO TILL END
         B     CVFCI3              CLEAN UP AND GO AWAY
*              IF NUMBER IS ZERO TO BEGIN WITH, THERE'S NOTHING
*              TO DO BUT ...
         MVI   16(R7),C'0'         SET UP ZERO RESULT
*              RESTORE PROGRAM MASK TO WHAT IT WAS.
CVFCI3   SPM   R6                  RESET PROGRAM MASK
         MVC   MSGLINE+17(15),=CL15'FLOATING POINT:'
         B     NEWDSPNT            RETURN TO CALLER
TRFLOAT  TR    TEMP3+5(*-*),HEXTAB <<EXECUTED>>
*- - - - DUMP, DUMPE, DUMPF.                                     <===*
DUMP     OI    FLAGSL,LOGRQ        LOGGING REQUESTED
         BAL   R8,LOGTEST
         BAL   R8,CHKPT            SEE IF HE CAN LEAVE
         TM    FLAGSR,YESCSERR     "CSOUT" CAN RECORD?
         BO    BADCSOUT            NO, WHY BOTHER TO DUMP THEN?
         ICM   R7,B'1111',=XL4'7FFFFFFF' NUMBER OF BLOCKS TO READ (HAH)
         MVC   TEMP1(L'TTR-1),TTR  SAVE WHERE WE ARE
         CLI   REPLINE+4,C'E'      IS THIS REALLY DUMPE?
         BE    PREPDMPF            YES, DUMP FROM HERE
         MVC   TTR,=XL4'00000100'  POINT TO BEGINNING OF DATA-SET
         B     PREPDMPF            START DUMPING TILL END OF DS
DUMPF    OI    FLAGSL,LOGRQ        LOGGING REQUESTED
         BAL   R8,LOGTEST
         BAL   R8,CHKPT            SEE IF HE CAN LEAVE
         TM    FLAGSR,YESCSERR     "CSOUT" CAN RECORD?
         BO    BADCSOUT            NO, SO WHY DUMP MAY I ASK?
         LH    R0,REALRDLN         GET LENGTH OF COMMAND
         SH    R0,=H'5'            -5 FOR 'DUMPF' ACTUAL LENGTH
         BNZ   DUMPFOR             HE GAVE AN OPERAND, PROCESS IT
JUSTDUMP LA    R7,1                DUMP R* ONLY - R7 = # TO DUMP
         B     STARTDF             ALL SET, START THE DUMP-FOR
*              PROCESS OPERAND OF DUMPF COMMAND (NUMBER OF BLOCKS
*              TO DUMP).
DUMPFOR  XR    R15,R15             LOAD *, CURRENT LOC FOR 'EXP'
         LA    R1,REPLINE+5        POINT TO OPERAND TO PARSE
         BAL   R8,CALLEXP          GO PARSE
         BM    NOBACK              NEG, WE CAN'T DUMP BACKWARDS
         BZ    INVEXPER            ZERO, INVALID SYNTAX
         LR    R7,R15              NUMBER OF BLOCKS TO DUMP
STARTDF  MVC   TEMP1(L'TTR-1),TTR  SAVE WHERE WE ARE
PREPDMPF MVI   TTR+3,NOSEQRD       1ST BLK, READ IT BEFORE DUMP
DMPFLOOP BAL   R6,PREPDUMP         GET READY FOR THE DUMP
         BAL   R6,DUMPER           DUMP A BLOCK
         MVI   TTR+3,SEQREAD       SAY NEXT PASS, NOW READ BLK
         BCT   R7,DMPFLOOP         DO ALL THE BLOCKS HE WANTS
DUMPEND  MVC   TTR(L'TTR-1),TEMP1  PICK UP WHERE WE WERE
         MVI   TTR+3,NOSEQRD       DON'T PUT HIM IN NEXT BLOCK
         BAL   R8,READBLK          SO THAT HE'LL NEVER KNOW
         LA    R2,DUMPWMSG         IT WORKED SO TELL HIM
         B     BOTCH               DISPLAY (NOT REALLY A BOTCH)
DUMPT    OI    FLAGSL,LOGRQ        LOGGING REQUESTED
         BAL   R8,LOGTEST
         BAL   R8,CHKPT            SEE IF HE CAN LEAVE
         TM    FLAGSR,YESCSERR     "CSOUT" CAN RECORD?
         BO    BADCSOUT            NO, DON'T BOTHER WITH DUMP
         LH    R0,REALRDLN         GET LENGTH OF READ
         SH    R0,=H'5'            -5 FOR 'DUMPT' ACTUAL LENGTH
         BZ    JUSTDUMP            NO OPERAND, JUST DUMP THIS BLK
*              PARSE OUT THE TTR OPERAND OF THE DUMPT COMMAND.
         LA    R1,REPLINE+5        POINT TO THE OPERAND
         BAL   R6,TTRPARSE         GO PARSE (USE POINT'S RTN)
         CLC   TEMP2+1(L'TTR-1),TTR RESULT (TEMP2+1) < CURRENT TTR?
         BNL   OKDUMPT             NO, HIS WISH IS MY COMMAND
NOBACK   LA    R2,BACKDUMP         YES, WE CAN'T DUMP BACKWARDS
         B     BOTCH               WHAT DOES HE THINK WE ARE?
OKDUMPT  MVC   STOPDUMP(L'STOPDUMP),TEMP2+1 TTR TO STOP AT
         MVC   TEMP1(L'TTR-1),TTR  SAVE WHERE WE ARE
         MVI   TTR+3,NOSEQRD       1ST BLK, READ 1ST BLK FOR DUMP
DMPTLOOP BAL   R6,PREPDUMP         NO, SO PREPARE TO DUMP
         BAL   R6,DUMPER           AND DUMP WHAT WE HAVE
         MVI   TTR+3,SEQREAD       NOW WE CAN READ SEQ BLKS
         CLC   TTR(L'TTR-1),STOPDUMP ARE WE THERE OR PAST YET?
         BNL   DUMPEND             YES, WE ARE ALL DONE THEN
         B     DMPTLOOP            GO TILL WE ARE AT HIS TTR
*- - - - WHATMEM.                                                <===*
WHATMEM  BAL   R8,CHKPT            SEE IF HE CAN LEAVE
         CLI   ZDSORG,DCBDSGPO     IS IT PARTITIONED?
         LA    R2,NOMCOM           GET MESSAGE ADDRESS IN CASE
         BNE   BOTCH               NO, ERROR
         MVC   TEMP1(L'TTR-1),TTR  SAVE CURRENT TTR
         XC    STOPDUMP(3),STOPDUMP SAVE CLOSEST TTR HERE
         XC    TTR(L'TTR-1),TTR    START AT BEGINNING OF DIR
WHATLOOP BAL   R8,READNBLK         GET NEXT DIRECTORY BLOCK
         TM    FLAGSR,YESSYN       DID IT WORK?
         BO    NEWDSPNT            NO, ABORT
         L     R3,ADDRDATA         -> BUFFER
         LH    R2,0(,R3)           BLK LENGTH USED
         LA    R3,2(,R3)           -> REAL BEGIN LOC
         BCTR  R2,0                -1
         BCTR  R2,0                AND -2 FOR REAL LENGTH USED
WMLOOP2  CLC   0(4,R3),=XL4'FFFFFFFF' END OF DIRECTORY?
         BE    WMEND               YES
         CLC   8(3,R3),TEMP1       THIS MEM PAST CURRENT LOC?
         BH    WMNEXT              YES, TRY NEXT
         CLC   8(3,R3),STOPDUMP    NO, HIGHER THAN PREVIOUS?
         BL    WMNEXT              NO, PREVIOUS IS CLOSER
         MVC   STOPDUMP(L'TTR-1),8(R3) SAVE THIS TTR
         MVC   MSGLINE+35(8),0(R3) SAVE MEMBER NAME
WMNEXT   BAL   R8,NXTDIRNT         INCR TO NEXT ENTRY
         BP    WMLOOP2             CHECK NEXT
         B     WHATLOOP            GET ANOTHER DIR BLK
WMEND    MVC   TTR(L'TTR-1),TEMP1  RESTORE WHERE HE WAS
         OC    STOPDUMP(3),STOPDUMP DID I FIND ANYTHING?
         BNZ   WMENDOK             YES, DISPLAY IT
         MVC   MSGLINE,BLANKS      RESET THE LINE
         BAL   R8,SETMSG           MOVE IN MESSAGE
         DC    Y(NOMEMFND-ETPSXZAP) 'NONE FOUND'
         B     WMDONE              SKIP OTHER
WMENDOK  MVC   MSGLINE+17(17),=CL17'CLOSEST MEMBER IS'
         MVC   MSGLINE+44(6),=CL6'AT TTR'
        @HEX   MSGLINE+51,STOPDUMP,LEN=3 GIVE HIM THE START
WMDONE   BAL   R8,READBLK          PUT HIM BACK WHERE HE WAS
         B     NEWDSPNT            AND GO DISPLAY
*              SEE NOTE AT END OF MLOOP2 (NEXT PAGE).
*- - - - M.                                                      <===*
MEMBER#  BAL   R8,CHKPT            NEED ZAP?
         CLI   ZDSORG,DCBDSGPO     IS IT PARTITIONED?
         LA    R2,NOMCOM           -> MESSAGE IN CASE
         BNE   BOTCH               THE DATA-SET ISNT PARTITIONED
         MVC   TEMP1(L'TTR-1),TTR  SAVE TTR IN CASE NO FIND
         LTR   R0,R0               TEST OPERAND LENGTH
         BNP   JUSTM               NONE, USE LAST MEM
         MVC   ZMEMBER(8),REPLINE+1 MOVE MEMBER TO FIELD
         XC    TTR(L'TTR-1),TTR    POINT TO BEGINNING OF DIRECT -1
*              FIND THE MEMBER IN THE DIRECTORY.
*              READ A DIRECTORY BLOCK.
MLOOP    BAL   R8,READNBLK         GET NEXT BLOCK
         TM    FLAGSR,YESSYN       I/O ERROR?
         BO    NEWDSPNT            YES, GET OUT
         L     R3,ADDRKEY          GET BUFFER POINTER
         CLC   ZMEMBER,0(R3)       IN THIS BLOCK?
         BH    MLOOP               NO, GET NEXT
         LH    R2,8+0(,R3)         GET BLK LENGTH USED
         BCTR  R2,0                -1
         BCTR  R2,0                AND -2 FOR REAL LENGTH USED
         LA    R3,8+2(,R3)         POINT TO REAL BEGIN LOC
*              MEMBER SCAN LOOP WITHIN BLK.
MLOOP2   CLC   0(4,R3),=XL4'FFFFFFFF' END OF DIRECTORY?
         BNE   NOTEND              NO, THERE'S MORE TO LOOK
MNF      MVC   TTR(L'TTR-1),TEMP1  PICK UP WHERE HE WAS
         BAL   R8,SETMSG           MOVE MESSAGE TO RIGHT PLACE
         DC    Y(INVMEM-ETPSXZAP)  SAY INV MEMBER (NOT FOUND)
         BAL   R8,READBLK          PUT HIM BACK WHERE HE WAS
         B     NEWDSPNT            AND GO DISPLAY
*              NOTE : READBLK WILL RETURN ONLY IF THE USER IS NOT
*              AT AN EOF. IF EOF, SYNAD==>EODAD==>DISPLAY GET
*              EXECUTED, SO THE MESSAGE MUST BE PRE-SET.
NOTEND   CLC   0(8,R3),ZMEMBER     MEMBER HERE?
         BE    FOUNDM              YES, GO WORK ON IT
         BH    MNF                 IF PAST ALPHA SEQ GIVE UP
         BAL   R8,NXTDIRNT         INCR TO NEXT ENTRY
         BNP   MLOOP               NEG, END BLK - READ ANOTHER
         B     MLOOP2              MORE TO GO - KEEP LOOKING
FOUNDM   MVC   TTR(L'TTR-1),8(R3)  PICK UP MEMBER'S TTR
         MVC   MEMTTR(L'MEMTTR),8(R3) SAVE IT FOR LATER USE
         MVC   ESDID,=H'1'         RESET ESDID TO DEFAULT
         MVI   IDRFLAG,NOCHGIDR    HAVEN'T CHANGED IDR YET
         XC    TXTTTR,TXTTTR       ASSUME NOT A LOAD MOD
         XC    CTL1TTR,CTL1TTR     NO 1ST CTL REC YET
         MVC   TEMP1+3(1),11(R3)   FLAGS/LEN FROM DIR ENTRY
         NI    TEMP1+3,B'01100000' # TTR'S IN USER DATA FILED
         CLI   TEMP1+3,B'00100000' AT LEAST ONE USER TTR?
         BL    FOUNDM1             BRANCH IF NOT LOAD MODULE
         MVC   TEMP1+3(1),11(R3)   FLAGS/LEN FROM DIR ENTRY
         NI    TEMP1+3,B'00011111' # H-WORDS USER DATA
         CLI   TEMP1+3,12          AT LEAST 12 H-WORDS?
         BL    FOUNDM1             BRANCH IF NOT LOAD MODULE
         CLI   DCBU+DCBRECFM-IHADCB,DCBRECU A LOAD MODULE?
         BNE   FOUNDM1             NO, NO TEXT THEN
         MVC   TXTTTR(L'TXTTTR),12(R3) YES, SAVE 1ST TEXT BLK TTR
FOUNDM1  XR    R1,R1               MESSAGE NUMBER
         BAL   R8,SETLINE          SET UP LINE TO PUT
         B     NEW$READ            NOT LOGGING, EXIT
         MVI   0(R2),C'0'          DOUBLE SPACE IT
         MVC   20(24,R2),=CL24'MEMBER XXXXXXXX SELECTED'
         MVC   27(8,R2),ZMEMBER    FILL IN THE MEMBER IN QUESTION
         BAL   R8,CPUT             NOW DUMP THE LINE OUT
         B     NEW$READ            GO DO IT
JUSTM    MVC   TTR(L'TTR-1),MEMTTR RESTORE START OF MEMBER
         B     NEW$READ            GET IT
NXTDIRNT IC    R4,11(,R3)          GET INDICATORS
         N     R4,=XL4'0000001F'   JUST # USER DATA HALFWORDS
         LA    R4,12(R4,R4)        ENTRY LENGTH
         AR    R3,R4               -> NEXT ENTRY
         SR    R2,R4               DECR LENGTH REMAINING
         BR    R8                  RETURN WITH CC SET
*- - - - NAME.                                                   <===*
NAME#    BAL   R8,CHKPT            NEED CHKPT?
         OC    TXTTTR,TXTTTR       IS THERE ANY TEXT?
         BZ    NAMENFN#            NO, CAN'T HAVE ESD'S THEN
         MVC   ZNAME,ZMEMBER       ASSUME CSECT IS MODULE
         LTR   R0,R0               IS THERE AN ARGUMENT?
         BNP   *+L'*+6             NO, OK THEN
         MVC   ZNAME(L'ZNAME),0(R1) MOVE NAME TO FIELD
         MVI   FLAGESD,0           NO FLAGS YET
*              FIND THE ESD'S FIRST.
         MVC   TEMP1(L'TTR-1),TTR  REMEMBER WHERE WE ARE NOW
         MVC   TTR(L'TTR-1),MEMTTR START LOOKING AT BEGIN MEMB
         BAL   R8,READBLK          GET 1ST BLOCK
NAMEFIND L     R1,ADDRDATA         POINT TO RECORD
         TM    0(R1),X'01'         CONTROL REC?
         BZ    NAMECHKE            NO, POSSIBLE ESD OR SYM
NAMENFND CLC   TTR(L'TTR-1),TEMP1  NOT FOUND. HAVE WE MOVED?
         BE    NAMENFN#            NO, NO RE-POSITION NECESSRY
         MVI   TTR+3,NOSEQRD       YES, NO SEQUENTIAL READ
         MVC   TTR(L'TTR-1),TEMP1  RESET WHERE WE WERE
         BAL   R8,READBLK          PUT US BACK
NAMENFN# LA    R2,NAMEMNF          'INVALID' MESSAGE
         B     BOTCH               OH WELL
NAMECHKE CLI   0(R1),X'20'         ESD?
         BE    NAMEESD             YES, HAVE ONE, TRY IT
NAMEENXT NI    FLAGSR,255-YESEOF   EOF'S ARE DATA NOW
         BAL   R8,READNBLK         GET NEXT BLOCK
         CLC   IOMLINE+27(20),EOFMSG HIT EOF HERE?
         BE    NAMENFND            YES, NOT FOUND
         TM    FLAGSR,YESSYN       I/O ERROR
         BO    NAMENFND            YES, NOT FOUND
         B     NAMEFIND            NONE, KEEP LOOKING
NAMEESD  LH    R15,6(,R1)          GET LENGTH ESD DATA THIS BLK
         LA    R1,8(,R1)           POINT PAST ESD PREFIX TO DATA
         AR    R15,R1              POINT PAST LAST ESD DATA
         USING ESDDATA,R1          ESD ENTRIES
NAMECHK  CLR   R1,R15              PAST END THIS BLK?
         BNL   NAMEENXT            YES, NEXT ESD BLK
         CLC   ESDDNAME,ZNAME      NO, NAME MATCH?
         BE    NAMEGOT             YES, WE MIGHT HAVE IT
NAMEBNXT LA    R1,ESDDL(,R1)       NEXT ENTRY IN BLK
         B     NAMECHK             KEEP SCANNING BLK
*              THE ENTRY POINT EXISTS.
*              FIND THE PLACE IN THE MODULE TEXT.
NAMEGOT  NI    ESDDTYPE,255-X'F0'  JUST WANT LOW NIBBLE
         CLI   ESDDTYPE,X'02'      EXT REF ENTRY (ER)?
         BE    NAMEBNXT            YES, IGNORE, NEXT ENTRY
         CLI   ESDDTYPE,X'0A'      WEAK EXT REF? (WEX)?
         BE    NAMEBNXT            YES, IGNORE, NEXT ENTRY
         L     R3,ESDDADDR-1       NO, GET LKED ADDRESS OF EP
         LA    R3,0(,R3)           GET RID OF TYPE BYTE
         DROP  R1                  NO MORE ENTRIES
         L     R15,ADDRDATA        POINT TO ESD BLK PREFIX
         LH    R14,4(,R15)         GET ESDID 1ST NTRY THIS BLK
         LA    R15,8(,R15)         POINT PAST PRFX TO 1ST ENTRY
         SR    R1,R15              OFFSET MTHC ENTRY FROM PRFX
         XR    R0,R0               FOR DIVIDE
         D     R0,=A(ESDDL)        GET ESDID REL THIS BLK
         AR    R1,R14              GET ESDID MATCH ENTRY POINT
         STH   R1,ESDID            SAVE FOR IDR UPDATE
         MVI   TTR+3,NOSEQRD       NO MORE SEQ READ
         MVC   TTR(L'TTR-1),CTL1TTR START AT 1ST CTL RECORD
         OC    TTR(L'TTR-1),TTR    ANY 1ST CTL TTR?
         BNZ   *+L'*+6             YES, HAVE TTR 1ST CTL REC
         MVC   TTR(L'TTR-1),MEMTTR ELSE START AT MEMBER
         BAL   R8,READBLK          GET ESD, CTL, IDR RECORD
         NI    FLAGESD,255-FESDTEXT NEXT BLK IS NOT TEXT
NAME$L1  TM    FLAGESD,FESDTEXT    IS THIS TEXT BLOCK?
         BO    NAME$T1             BRANCH IF IS TEXT RECORD
         L     R1,ADDRDATA         @ NON-TEXT RECORD
         TM    0(R1),X'01'         CONTROL RECORD?
         BZ    NAME$NX             NOT CTL REC, TRY NEXT
         OI    FLAGESD,FESDTEXT    NEXT BLK IS TEXT
         OC    CTL1TTR,CTL1TTR     HAVE SAVED 1ST CTL TTR?
         BNZ   *+L'*+6
         MVC   CTL1TTR(L'TTR-1),TTR SAVE TTR 1ST CTL REC
         MVC   TXTORIG(4),8(R1)    LKED ORIG NXT BLK (TEXT)
         MVI   TXTORIG,0           CLEAR HIGH BYTE
NAME$NX  NI    FLAGSR,255-YESEOF   EOF'S ARE DATA
         BAL   R8,READNBLK         GET NEXT LOADMOD BLOCK
         CLC   IOMLINE+27(20),EOFMSG EOF?
         BE    NAMENFND            OOPS, CAN'T HAPPEN
         B     NAME$L1             CONTINUE SEARCH
NAME$T1  NI    FLAGESD,255-FESDTEXT NEXT BLK IS NOT TEXT
         LR    R0,R3               COPY ENTRY ORIGIN
         S     R0,TXTORIG          ENTRY - TXT BLOCK ORIG?
         BM    NAME$NX             NOT IN NEXT TXT BLK
         CH    R0,BLKLEN           OFFSET IN BLOCK = BLKLEN
         BNL   NAME$NX             NOT IN NEXT TXT BLK
*              WE HAVE THE BLOCK AND OFFSET OF THE ENTRY POINT.
*              NOTIFY/DISPLAY.
         MVI   TTR+3,NOSEQRD       NO MORE SEQ READS
         LR    R3,R0               OFFSET INTO BLOCK
         LA    R1,8                MESSAGE NUMBER
         BAL   R8,SETLINE          SET IT UP
         B     NAMEDONE            NOT LOGGING
         MVI   0(R2),C'0'          DOUBLE SPACE
         MVC   20(24,R2),=CL24'MEMBER XXXXXXXX SELECTED' FOR SPACE
         MVC   20(6,R2),=CL6'ENTRY' MEMBER=ENTRY
         MVC   27(L'ZNAME,R2),ZNAME MOVE ENTRY NAME IN
         BAL   R8,CPUT             DO IT
NAMEDONE LR    R15,R3              GET OFFSET INTO BLOCK
         MVI   IDRFLAG,NOCHGIDR    HAVEN'T CHANGED IDR YET
         B     SETPOINT            SIMULATE A '+' COMMAND
* - - -  NOTE, EJECT.                                            <===*
NOTE     OI    FLAGSL,LOGRQ        LOGGING REQUESTED
         BAL   R8,LOGTEST
         L     R2,CSLLOC           GET THE NEXT LINE IMAGE
         MVC   1($L-4,R2),REPLINE+4 COPY NOTATION TO BUFFER
         MVI   0(R2),C'0'          DOUBLE SPACE NOTES
         BAL   R8,CPUT             DUMP THIS LINE NOW
         B     NEWDSPNT            THEN CONTINUE ON MERRY WAY
BADCSOUT LA    R2,NOCSOUT          TELL HIM CAN'T RECORD
         B     BOTCH               BYE
EJECT    OI    FLAGSL,LOGRQ        LOGGING REQUESTED
         BAL   R8,LOGTEST
         L     R2,CSLLOC           GET THE NEXT LINE IMAGE
         MVI   0(R2),C'1'          PAGE EJECT
         BAL   R8,CPUT             DO IT
         B     NEWDSPNT            ALL DONE
         EJECT
*------- UTILITY ROUTINES. ------------------------------------------*
         SPACE 1
*  NAME     ... DESCRIPTION
*  ------------ ---------------------------------------------------
*  CALLEXP  ... CALL "EXP" TO PARSE EXPR, CHECK ERROR RETURNS
*  CHKPT    ... CHECK IF ZAP NEEDED (IF SO IGNORE COMMAND PENDING)
*  CLEAR    ... CLEAR SCREEN
*  CLEARDEF ... RESET DEFINE TABLE
*  CPUT     ... WRITE A "LOG" OUTPUT LINE (IF OPENED)
*  ... CPUTOP   FORCE OPEN OF "LOG" DATA-SET (AND WRITE)
*  DUMPER   ... DUMP A BLOCK IN DUMP FORMAT
*  GETSTRNG ... VALIDITY CHECK AND PARSE HEX/CHAR STRING
*  HEXCHECK ... VALIDITY CHECK HEX
*  LOGTEST  ... CHECK IF THE "LOG" MUST BE OPENED, AND
*  ... OPENMSG  OUTPUT MESSAGE OF "LOG" DATA-SET OPENED
*  NUMCONV  ... CONVERT A NUMBER TO HEX AND SIGNED DECIMAL
*  PREPDUMP ... PREPARE FOR DUMP - GET BLOCK, PRINT HEADER LINE
*  READBLK  ... GET A DATA BLOCK
*  SETLINE  ... SET UP LINE MESSAGE NUMBER FOR "CPUT"
*  SETMSG   ... MOVE INFO MESSAGE TO CORRECT PLACE ON SCREEN
*  SETSTRNG ... CONVERT VARIOUS CONSTANTS FOR "CPUT"
*  STRCNV   ... STRING CONVERSION
*  TTRPARSE ... PARSE OUT SPECIFIED TTR
*  WRITE    ... EXCP WRITE OUT A BLOCK
         EJECT
*------- CALLEXP.                                                <===*
*        CALL EXP, CHECK ERROR RETURNS.
*              R1 -> STRING.
*              R0  = LENGTH.
*              R8  = LINK RESGITER.
*                    NOTE : CC IS SET ACCORDING RESULT'S SIGN.
CALLEXP  LR    R2,R15              COPY "*" VALUE
         L     R15,=A(EXPANAL)     -> ROUTINE "EXP"
        CALL   (15)                CALL IT
         LTR   R1,R1               WORK?
         BNM   INVEXPER            NO
         SLL   R1,1                YES
         SRL   R1,1                NEGATIVE BIT CLEARED
         LTR   R15,R15             SET CC
         BR    R8                  RETURN TO CALLER
*------- CHKPT.                                                  <===*
*              CHECK IF ZAP NEEDED.
*              R8 = LINK REGISTER.
CHKPT    TM    FLAGSX,MUSTZAP      BLOCK NEED A ZAP 1ST?
         BZR   R8                  NO, LET COMMAND THRU
         CLC   REPLINE,PREVREP     SAME CMD TWICE IN A ROW?
         BER   R8                  YES, LET HIM DO IT
         MVC   MSGLINE+11(58),=CL58'******** ENTER "ZAP" OR RE-ENTER PRX
               EVIOUS COMMAND ********'
         B     NEWDSPNT            TELL HIM HE CAN'T LEAVE
*------- CLEAR.                                                  <===*
*        CLEAR THE SCREEN BUFFER EXCEPT FOR ERROR AND I/O ERROR LINES.
*              R8 = LINK REGISTER.
CLEAR    LA    R15,LINE01-2        -> START
         LA    R0,3                NUMBER OF LINES
         BAL   R14,CLEARX          CLEAR 1-3
         LA    R15,LINE06-2        -> START
         LA    R0,13               NUMBER OF LINES
         BAL   R14,CLEARX          CLEAR 6-18
         LA    R15,LINE20-2        -> START
         LA    R0,2                NUMBER OF LINES
         BAL   R14,CLEARX          CLEAR 20-21
         MVI   LINE01-1,X'F8'      PROT HIGH
         MVI   CMDLINE-1,X'C8'     UNPROT HIGH
         MVC   IOMLINE-2(2),=XL2'1DF8' I/O ERR.MSG LINE (PROT HIGH)
         MVC   MSGLINE-2(2),=XL2'1DF8' AND OTHER ERR.MSG LINE
         MVC   REPLINE-2(2),CMDLINE-2  UNPROT HIGH
         BR    R8                  RETURN TO CALLER
*        LOCAL ROUTINE (USED ONLY BY "CLEAR") - R14 = LINK REGISTER.
*              X... ....  SET TO MAKE VALID CHAR
*              .1.. ....  MUST BE 1
*              ..1. ....  PROT
*              ...1 ....  NUMERIC
*              ..11 ....  AUTOSKIP
*              .... 00..  DISPLAY / NOT SELECTOR PEN DETECTABLE
*              .... 01..  DISPLAY / DETECTABLE
*              .... 10..  HIGH INTENSITY / DETECTABLE
*              .... 11..  NO DISPLAY / NOT DETECTABLE
*              .... ..0.  MUST BE 0
*              .... ...1  MDT FLAG
CLEARX   MVC   0(2,R15),=XL2'1DF0' PROT AUTOSKIP LOW
         MVC   2($L,R15),BLANKS    BLANK THE LINE
         LA    R15,$I(,R15)        -> NEXT LINE
         BCT   R0,CLEARX           CONTINUE
         BR    R14                 DONE THIS SECTION
*------- CLEARDEF.                                               <===*
*        RESET AND/OR INITIALIZE THE DEFINE TABLE.
*              R8 = LINK REGISTER.
CLEARDEF L     R2,AIDEFTAB         POINT TO BEGINNING OF TABLE
         ST    R2,IDEFAVAL         MAKE THAT THE 1ST AVAIL POSIT
         LR    R0,R2
         LH    R1,=Y(24*L'IDEFTAB) LENGTH TO BE CLEARED
         LA    R14,*
         XR    R15,R15
         ICM   R15,B'1000',BLANKS
         MVCL  R0,R14              CLEAR OUT THE TABLE ALSO
         BR    R8                  BACK TO CALLER
*------- CPUT.                                                   <===*
*              CPUT = WRITE A "LOG" OUTPUT LINE (IF OPENED).
*              CPUTOP = FORCE OPEN OF "LOG" DATA-SET (AND THEN WRITE).
*              R8 = LINK REGISTER.
CPUT     TM    FLAGSL,LOGOPN       SEE IF LOGGING
         BZR   R8                  IF NOT RETURN TO CALLER
CPUTOP   TM    FLAGSR,YESCSERR     WAS THERE AN ERROR?
         BOR   R8                  YES, ACT LIKE I DO IT
         L     R1,CSALOC           GET WORK-AREA ADDRESS
         XR    R0,R0               (+) SET AS PUT CALL
         L     R15,=A(CSOUT)       (+) POINT TO ROUTINE
        CALL   (15)                (+) CALL IT
         B     *+L'*(R15)          DID IT WORK?
         B     0(R8)               YES, RETURN TO CALLER
         B     *+L'*+8             NO, ALLOC. OR OPEN ERROR
         OI    FLAGSR,YESCSERR     OR RECORD THAT THERE WAS AN ERROR
         B     BADCSOUT            AND TELL THE USER OF HIS FATE
         LR    R2,R1               PASS MESSAGE ADDRESS
         B     BOTCH               AND BYE
*------- DUMPER.                                                 <===*
*        DUMP A BLOCK IN DUMP FORMAT.
*              THIS ROUTINE DUMPS ANY SIZE BLOCK WHICH IS IN THE
*              BUFFER TO THE OUTPUT RECORDING FILE. THE HEX OFFSETS,
*              THE ACTUAL HEX DATA, AND THE TRANSLATION OF THAT IS
*              IS PRINTED OUT.
*              NOTE : (1) GARBAGE DATA IS NOT PRINTED. THAT IS, DATA
*                         IS DISPLAYED ONLY UP TO THE LAST BYTE, AND
*                         NO FARTHER.
*                     (2) TRANSLATED DATA IS EITHER IN EBCDIC OR IN
*                         ASCII TRANSLATION, DEPENDING ON WHICH
*                         COMMAND IS IN EFFECT AT THE TIME OF THE
*                         DUMP, 'EBCDIC' OR 'ASCII'.
*                     (3) THE 'PRE-PROCESSOR' ROUTINE 'PREPDUMP' MUST
*                         BE CALLED FIRST TO GET THE BLOCK, WRITE
*                         OUT THE BLOCK HEADER LINE, AND TO CHECK FOR
*                         SYNAD AND EODAD ON THE BLOCK.
*              R6 = LINK REGISTER.
DUMPER   L     R3,ADDRBUFF         POINT TO INPUT BUFFER (THE BLOCK)
         ST    R6,TEMP3+20         SAVE RETURN ADDRESS
         XR    R4,R4               CLEAR REM REGISTER FOR DIVIDE
         LH    R5,BLKLEN           GET LENGTH OF BLK
         D     R4,=F'32'           HOW MANY 4 DBLW LINES IN BLK
*              R4 HAS THE LENGTH OF THE OFLO 'SHORT' LINE. R5 HAS THE
*              NUMBER OF LINES TO DUMP OUT (THE NUMBER OR 1 SHORT).
         LTR   R4,R4               IS THERE A SHORT LAST LINE?
         BZ    *+L'*+4             NO, HAVE NUMBER OF LINES NOW
         LA    R5,1(R5)            YES, CORRECT NUM OF LINES
         XC    TEMP2(4),TEMP2      INITIALIZE OFFSET COUNTER
DMPFMTLP TM    FLAGSL,LOGOPN       ARE WE LOGGING
         BZ    BADCSOUT
         L     R2,CSLLOC           PICK UP BUFFER POINTER
         MVI   0(R2),C' '          CARRIAGE CONTROL
        @HEX   (1+0,R2),TEMP2+1,LEN=3 GET OFFSET
         MVC   1+91(32,R2),0(R3)   MOVE DATA TO DUMP SECTION
         L     R15,TRTABADD        PICK UP CURRENT TRANSLATE TAB
         TR    1+91(32,R2),0(R15)  TRANSLATE IT IN PLACE
         MVI   1+90(R2),C'*'       MOVE IN DELIMITER
         MVI   1+123(R2),C'*'      MOVE IN DELIMITER
*              FORMAT THE LINE. THE LINE IS COMPOSED OF 4 COMPLETE
*              DOUBLE-WORDS. EACH DOUBLE-WORD IS FORMATTED INTO
*              FULLWORDS SEPARATED BY A BLANK, AND EACH PAIR OF
*              DOUBLE-WORDS IS SEPARATED BY 3 BLANKS. THUS DUMPER
*              LOOPS TWICE A LOOP OF 4 PASSES, ONE PER FULLWORD.
         LA    R14,1+9(R2)         POINT TO 1ST AVAIL LINE POS
         LA    R6,2                BCT OUTER LOOP (2 PAIRS DBLW'S)
LINELP1  LA    R4,4                BCT INNER LOOP (4 FULLWORDS)
LINELP2 @HEX   (0,R14),(0,R3),LEN=4 GET ONE FULLWORD
         LA    R3,4(,R3)           UPDATE INPUT BUFFER POINTER
         LA    R14,9(,R14)         UPDATE OUTPUT LINE POINTER
         BCT   R4,LINELP2          DO IT FOR 4 FULLWORDS
         LA    R14,3(,R14)         FOR NEXT PAIR OF DBLW'S, SPACE
         BCT   R6,LINELP1          DO IT FOR 2 PAIRS OF DBLW'S
         CH    R5,=H'1'            LAST LINE NOW?
         BE    LASTLINE            YES, CHECK FOR SHORT LAST LINE
         L     R15,TEMP2           NO, UPDATE OFFSET BY GETTING
         LA    R15,X'20'(R15)      IT IN THE REG, ADDING INCR,
         ST    R15,TEMP2           AND PUTTING IT BACK
         BAL   R8,CPUT             WRITE IT OUT
         BCT   R5,DMPFMTLP         DO ALL THE LINES EXCEPT LAST
*              LAST LINE ROUTINE. IF THE LINE IS A SHORT LAST LINE,
*              ONLY WRITE OUT THE CORRECT AMOUNT OF DATA.
LASTLINE LH    R1,BLKLEN           GET LENGTH OF BLK
         N     R1,=F'31'           TURN OFF ALL BUT LOW ORDR BITS
         LTR   R1,R1               ARE THERE ANY LOW ORDER BITS?
         BZ    BYELAST             NO, FULL LAST LINE, DUMP IT
*              GET RID OF THE JUNK IN THE DUMP (TRANSLATED) PART FIRST.
         LA    R14,32-1-1          MAX WIDTH -1 FOR MVI -1 EX LENGTH
         SR    R14,R1              GET LENGTH OF JUNK
         LA    R3,1+91(R2,R1)      POINT TO BEGINNING OF JUNK
         MVI   0(R3),C' '          KILL THE FIRST BYTE
         LTR   R14,R14             ANY MORE STUFF TO BLANK?
         BM    *+L'*+4             NO, GO ON AND FIX THE LINE NOW
         EX    R14,DMPBKMVC        KILL THAT JUNK
         XR    R0,R0               CLEAR REM REGISTER FOR DIVIDE
         D     R0,=F'4'            HOW MANY FLWRD GRPS ARE THERE?
*              R0 HAS SLOPOVER WITHIN 1 FULLWORD, R1 HAS NUMBER OF
*              FULLWORDS ON THE LAST LINE.
         LA    R4,DUMPOFFS(R1)     POINT TO THE TAB TABLE OFFSET
         XR    R3,R3               CLEAR REGISTER FOR IC
         IC    R3,0(R4)            GET THE TAB TO THE COLUMN
         SLL   R0,1                *2 SLOPOVER FOR CHARACTER BYTES
         AR    R3,R0               OFFSET TO FIRST GARBAGE CHAR
         LA    R4,86-1             GET MAX LENGTH  OF LINE (-1 MVI)
         SR    R4,R3               GET LENGTH OF GARBAGE TO BLANK
         LA    R3,1(R3,R2)         POINT TO 1ST GARBAGE BYTE
         MVI   0(R3),C' '          BLANK OUT AT LEAST ONE
         BCTR  R4,0                GET EXECUTE LENGTH
         LTR   R4,R4               IS THERE ANY MORE TO GET RID OF
         BM    BYELAST             NO, GOOD BYE LAST LINE
         EX    R4,DMPBKMVC         GET RID OF THE REST
BYELAST  BAL   R8,CPUT             WRITE OUT LAST LINE
         L     R6,TEMP3+20         RESTORE RETURN ADDRESS
         BR    R6                  RETURN TO CALLER
DMPBKMVC MVC   1(*-*,R3),0(R3)     <<EXECUTED>>
*              THUS UNDER CERTAIN CIRCUMSTANCES EOF'S ARE COUNTED
*              AS RECORDS.
*------- GETSTRNG.                                               <===*
*        PARSE OUT HEX OR CHARACTER STRING FOR S, X, O, N, L AND
*              SET COMMS. DETERMINE STRING LENGTH AND STRING ITSELF,
*              AND SAVE BOTH IN AREA.
*              IF DECIMAL - A FULLWORD IS STORED (< 2147483647.).
*              IF HEXADECIMAL - UP TO 16 DIGITS (DOUBLE-WORD) MAY BE
*                               STORED.
*              IF CHARACTER - ANY DELIMITERS MAY SURROUND THE STRING
*                             EXCEPT STRING EXCEPT HEX DIGITS) AND
*                             UP TO 16 CHAR (2 DOUBLE-WORDS) MAY BE
*                             STORED.
*              R3 = ACTUAL LENGTH OF STRING TO BE PARSED.
*              R4 = POINTER TO THE STRING ITSELF.
*              R5 = POINTER TO STRING WORK-AREA (1ST BYTE = LEN).
*              R6 = LINK REGISTER.
GETSTRNG LA    R1,1                LENGTH OF HEX TO BE CHECKED
         LR    R7,R4               LOC OF HEX TO BE CHECKED
         BAL   R8,HEXCHECK         DO IT
         B     HEXSTR              FIRST CHAR HEX - SO HEX STRING
*              CHARACTER STRING.
         CH    R3,=H'18'           STRING LONGER THAN 16 CHARS?
         BH    LENERROR            YES, SAY LENGTH ERROR
         XC    TEMPTRT(256),TEMPTRT CLEAR OUT TRTAB
         XR    R1,R1               CLEAR OUT WORK REGISTER
         IC    R1,0(,R4)           GET DELIM FOR CHAR STRING
         STC   R1,TEMPTRT(R1)      PUT IT IN RIGHT PLACE IN TRTAB
         SH    R3,=H'2'            GET ADJUST STRING LENGTH (DELIMS)
         BNP   LENERROR            HE ENTERED S'' OR LESS - ERROR
         EX    R3,DELIMTRT         FIND THE OTHER DELIMITER
         LA    R2,=CL20'NO ENDING DELIMITER' GET MESSAGE ADDR. IN CASE
         BZ    BOTCH               NO, TELL HIM
         LA    R3,1(,R4)           POINT TO BEGINNING OF STRING
         SR    R1,R3               GET STRING LENGTH (NO DELIMS)
         LR    R3,R1               PUT IN RIGHT REGISTER
         BCTR  R3,0
         LTR   R3,R3               NULL INPUT?
         BM    LENERROR            YES, SAY LENGTH ERROR
         LR    R1,R4
         CLI   CAPSFLG,YESCAPS
         BE    SKCAPS
         LA    R0,TEMP3
         SLR   R4,R0
         LA    R4,ICREP(R4)
SKCAPS   EX    R3,CHARMVC          MOVE STRING CHARS TO AREA
         LR    R4,R1
         B     FINSTR              GO FINISH THE JOB
DELIMTRT TRT   1(*-*,R4),TEMPTRT   <<EXECUTED>>
CHARMVC  MVC   2(*-*,R5),1(R4)     <<EXECUTED>>
LENERROR LA    R2,LENERR           YES, SAY LENGTH ERROR
         B     BOTCH               GO TELL HIM
*              HEX STRING.
HEXSTR   CH    R3,=H'16'           HEX STRING LONGER THAN 16?
         BH    LENERROR            YES, SAY LENGTH ERROR
         LR    R1,R3               PUT IT IN RIGHT REGISTER FOR CHECK
         LR    R7,R4               POINT TO LOC TO CHECK
         BAL   R8,HEXCHECK         CHECK THE HEX
         B     OK1#                ITS GOOD
         CLI   0(R7),C' '          IS IT HEX?
         BE    OK1#                YES, GO DO IT
         CLI   0(R7),C'.'          DECIMAL?
         BE    DECMAYBE            MAY BE SO
         LA    R2,=CL20'INVALID HEXADECIMAL' IT'S BAD, POINT TO MESSAGE
         B     BOTCH               TELL HIM
OK1#     TR    0(16,R4),HEXTAB     YES, START TO CONVERT TO HEX
         CH    R3,=H'15'           IS THIS THE MAX CASE?
         BL    HEXPACK             NO, DO JUST ENOUGH
         PACK  TEMP2(5),0(9,R4)    PACK FIRST GROUP
         PACK  TEMP2+4(5),8(9,R4)  PACK SECOND GROUP
         BH    HEX16               SKIP IF 16 DIGITS
         LM    R14,R15,TEMP2       GET THE RESULT
         SRDL  R14,4               DOWN 1 NIBBLE
         STM   R14,R15,TEMP2       RESTORE IT CORRECTLY
HEX16    LA    R3,7                NUMBER OF BYTES (EX LEN)
         MVC   2(8,R5),TEMP2       GET HEX
         B     FINSTR              AND THEN RETURN TO CALLER
*              R3 IS NOT BCTRED BECAUSE WE NEED A FLIP BYTE ON THE END.
         PACK  TEMP2(8),0(0,R4)    <<EXECUTED>>
HEXPACK  EX    R3,*-6              PACK TO MAKE REAL HEX
         LA    R3,1(,R3)           ROUND UP ...
         SRL   R3,1                AND FIND NUMBER OF BYTES
         LA    R15,TEMP2+7         POINT TO GORF BYTE
         SR    R15,R3              POINT TO FIRST BYTE
         BCTR  R3,0                GET EXECUTE LENGTH
         EX    R3,MOVEHEX          MOVE HEX TO OUTPUT LOCATION
FINSTR   STH   R3,0(,R5)           SAVE THE LENGTH IN SCAN AREA
         BR    R6                  RETURN TO CALLER
MOVEHEX  MVC   2(*-*,R5),0(R15)    <<EXECUTED>>
*              DECIMAL STRING.
DECMAYBE BXLE  R15,R15,*+L'*+8     IF REALLY DECIMAL - JUMP
         LA    R2,INVDEC           NO, TELL HIM SO BECAUSE...
         B     BOTCH               ITS GOT A-F IN IT
         CH    R3,=H'10'           APPROACHING LENGTH ERR (BCTR'D)?
         BL    *+L'*+10            NO, DON'T WORRY ABOUT IT
         CLC   0(11,R4),=CL11'2147483647.' TOO BIG FOR FULLWORD?
         BH    LENERROR            YES, TELL HIM AND GET OUT
         LA    R0,1(R4)            POINT TO STRING + 1 FOR TO....
         SR    R7,R0               GET EXECUTE LENGTH
         EX    R7,DECPACK          PACK UP YOUR DECIMALS IN ...
         CVB   R1,TEMP2            AND CONVERT, CONVERT, CONVERT
         ST    R1,TEMP2            SAVE IN ALIGNED PLACE
         MVC   2(4,R5),TEMP2       COPY TO OUTPUT STRING
         MVI   1(R5),3             EXECUTE LENGTH
         BR    R6                  RETURN
DECPACK  PACK  TEMP2(8),0(0,R4)    <<EXECUTE>>
*------- HEXCHECK.                                               <===*
*        VALIDITY CHECK FOR HEXADECIMAL, DECIMAL, OR CHARACTER.
*              R7 = POINTER TO STRING.
*              R1 = LENGTH OF STRING.
*              R8 = LINK REGISTER.
*                   NOTE : 0(R8)=GOOD HEX, 4(R8)=BAD HEX AT 0(R7).
*              R15 = 0 IF PURE DECIMAL UP TO EXIT, 4 IF HEX.
HEXCHECK XR    R15,R15             ASSUME DECIMAL
HEXCHK   TM    0(R7),X'F0'         NUMBER?
         BO    OKHEX               YES, ITS OK
         CLI   0(R7),C'A'          LESS THAN ALPHA?
         BL    4(R8)               YES, MUST BE CHARACTER
         CLI   0(R7),C'F'          'F' OR SMALLER?
         BH    4(R8)               NO, MUST BE CHARACTER
         LA    R15,4               INDICATE HEX (NOT DECIMAL)
OKHEX    LA    R7,1(R7)            SO FAR SO GOOD, UPDATE HEX POINTER
         BCT   R1,HEXCHK           DO THE WHOLE STRING
         BR    R8                  WE'RE OK - ALL DONE
*------- LOGTEST, OPENMSG.                                       <===*
*              LOGTEST = CHECK IF WE MUST OPEN THE "LOG", AND THEN
*              OPENMSG = OUTPUT MESSAGE OF "LOG" DATA-SET OPENED.
*              R8 = LINK REGISTER.
LOGTEST  TM    FLAGSL,LOGOPN       ALREADY LOGGING?
         BOR   R8                  YES, ALL DONE
         TM    FLAGSL,LOGFS+LOGRQ  NO, WE MUST LOGGING?
         BZR   R8                  NO, ALL DONE
         MVI   CHNGED,0            VIRGIN BUFFER
OPENMSG  ST    R8,ZDBLW            SAVE FOR LATER
         L     R1,CSLLOC           -> LINE TO USE
         MVC   0(L'OPNMSG,R1),OPNMSG
         CLI   ZDSNME,X'04'        VTOC?
         BNE   *+L'*+4             NO, INFORMATION ONLY
         MVI   OPNMS1(R1),C'A' (ACTION) MAKE OP. SIT UP AND TAKE NOTICE
         TM    DCBLIST,X'0F'       NOW, WAS IT OPEN FOR INPUT?
         BZ    *+L'*+10            YES, SO THERE'S NOTHING TO DO
         MVC   OPNMS3(6,R1),=CL6'UPDATE' IF UPDATING, SAY UPDATE
         MVI   OPNMS1(R1),C'A'     ACTION MESSAGE
         MVC   OPNMS2(L'ZUSRID,R1),ZUSRID CULPRIT
         MVC   OPNMS4(44,R1),DISPDSN MOVE IN DISPLAYABLE DS-NAME
         CLI   ZDSNME,X'04'        VTOC HERE?
         BE    *+L'*+12            YES, VOL-SER ALREADY SET
         MVC   OPNMS5(2,R1),=CL2'ON' ADD
         MVC   OPNMS6(6,R1),ZVOLSER VOL-SER
         BAL   R8,CPUTOP           FORCE OPEN AND OUTPUT THE LINE
         L     R8,ZDBLW            PICK UP RETURN ADDRESS
         BR    R8                  ALL OK - RETURN NORMALLY
*------- NUMCONV.                                                <===*
*              R15 = NUMBER TO BE CONVERTED.
*              R14 = LINK REGISTER.
*                    NUMBER IS CONVERTED TO 12 SIGNED DECIMAL
*                    DIGITS AT TEMP3, AND TO HEX AT TEMP3+12
*                    (8 CHARS).
NUMCONV  ST    R15,TEMP2           SET FOR UNPK
         UNPK  TEMP3+12(8+1),TEMP2(4+1)
         TR    TEMP3+12(8),HEXTAB  MAKE EBCDIC
         CVD   R15,TEMP2           GET IN PACKED FORM
         LA    R1,TEMP3+11         INIT. LOC FOR FLOATING SIGN
         MVC   TEMP3(12),EDMASK    MOVE IN EDIT MASK
         EDMK  TEMP3(12),TEMP2+2   GET 11 DECIMAL DIGITS
         LTR   R15,R15             IS IT NEGATIVE?
         BNMR  R14                 NO, ALL DONE
         BCTR  R1,0                YES, SO BACK UP AND...
         MVI   0(R1),C'-'          ...PUT IN THE SIGN
         BR    R14                 NOW DONE
*------- PREPDUMP.                                               <===*
*        THIS ROUTINE IS THE 'PRE-PROCESSOR' TO THE DUMPER.
*              IT GETS THE BLOCK TO BE DUMPED, PREPARES AND WRITES
*              OUT THE BLOCK HEADER LINE (WITH TTR, LENGTH, AND
*              CCHHR), AND IF THERE IS AN EOF OR I/O ERROR AT THE
*              BLOCK, AND MESSAGE IS PUT OUT TO THE RECORDING FILE
*              AND THE 'BLOCK' IS NOT DUMPED.
*              R6 = LINK REGISTER.
*              RETURNS : 0(R6) - NORMAL RETURN WITH DUMP OF BLOCK
*                                TO FOLLOW.
*                        4(R6) - I/O ERROR OR EOF, RETURN WITH NO
*                                DUMP, OR EXIT FROM ENTIRE DUMPING
*                                LOOP IF I/O ERROR WAS 'OUT OF
*                                DATA-SET', MEANING THERE IS NO
*                                MORE DATA-SET, NO MORE EXTENT.
PREPDUMP NI    FLAGSR,255-YESEOF   SAY ALSO EOF'S ARE DATA BLOCKS
         BAL   R8,READBLK          GET THE BLOCK, SUCH AS IT IS
PREPDMPX TM    FLAGSL,LOGOPN       ARE WE LOGGING?
         BZ    NEWDSPNT            IF NOT FORGET THIS
         L     R2,CSLLOC           GET LINE ADDRESS
         MVC   1+0(40,R2),=CL40'LENGTH=XXXXX TTR=XXXXXX CCHHR=XXXXXXXXXX
               X'
         LH    R1,BLKLEN           GET THE LENGTH OF THE BLK
         CVD   R1,TEMP2            PACKED DEC
         UNPK  1+7(5,R2),TEMP2+5(3) PUT LENGTH INTO MESSAGE
         OI    1+11(R2),X'F0'      FIX FLIP BYTE
        @HEX   (1+17,R2),TTR,LEN=3 CONVERT TTR
        @HEX   (1+30,R2),CCHHR,LEN=5 CONVERT CCHHR
         MVI   0(R2),C'-'          TRIPLE SPACE BEFORE HDR PRINTED
         BAL   R8,CPUT             PUT OUT THE LINE
         TM    FLAGSR,YESSYN       I/O ERROR IN READ BEFORE?
         BO    OOPSDUMP            YES, DON'T DUMP, JUST MESSAGE
         CLC   IOMLINE+27(20),EOFMSG NO, BUT WAS THERE AN EOF?
         BNER  R6                  NO, RETURN NORMALLY AND DUMP
*              EITHER THE BLOCK HAS AN I/O ERROR WAS AN END-OF-FILE,
*              SO WE CANNOT DUMP. INSTEAD, PRINT OUT, IF POSSIBLE, THE
*              TYPE OF CONDITION WHICH HAS OCCURRED, AND RETURN BEYOND
*              DUMP CODE - 4(R6). IF THE I/O ERROR 'NOT IN DATA-SET'
*              HAS OCCURRED, THEN STOP THE PROCESS ALL TOGETHER. WE
*              ARE AT THE REAL END OF THE DATA-SET.
OOPSDUMP TM    FLAGSL,LOGOPN       ARE WE LOGGING
         BZ    NEWDSPNT            IF NOT FORGET IT
         L     R2,CSLLOC           GET ADDRESS OF BUFFER
         MVC   1+0(40,R2),IOMLINE+17 COPY EXACTLY WHAT IS ON THE SCREEN
         MVI   0(R2),C' '          CARRIAGE CONTROL
         BAL   R8,CPUT             WRITE IT OUT
         CLC   IOMLINE+35(15),=CL15'NOT IN DATA-SET' END OF EXTENT?
         BE    NEW$DISP            YES, GET OUT OF LOOP AND DISP
         CLC   IOMLINE+27(20),EOFMSG WAS IT EOF?
         BE    NEW$DISP            YES, GET OUT AND DISPLAY LOC
         B     4(R6)               NO, BUT DON'T DUMP THIS 'BLK'
*------- READBLK.                                                <===*
*        EXCP READ A BLOCK (PHYSICAL RECORD) INCLUDING KEY (IF ANY).
*              IF TTR+3 CONTAINS A 1 (FLAG) THEN READ SEQUENTIALLY,
*              SIMULATING BSAM.
*              R8 = LINK REGISTER (SAVED IN "ZDBLW").
READNBLK MVI   TTR+3,SEQREAD       SET NEXT BLOCK FLAG
READBLK  NI    FLAGSR,255-YESSYN   START WITH NO I/O ERROR
         ST    R8,ZDBLW            SAVE RETURN ADDRESS
         BAL   R8,CHKPT            SEE IF HE CAN LEAVE
         CLI   TTR+3,SEQREAD       DO BLOCK +1?
         BNE   READBLK#            NO
         IC    R15,TTR+2           GET RECORD NO
         LA    R15,1(R15)          NEXT RECORD
         STC   R15,TTR+2           NEXT ONE
READBLK# MVC   IOMLINE,BLANKS      CLEAR I/O ERR-MSG IF ANY
         CLI   CHNGED,0            BUFFER TAMPERED WITH W/O CHKPT?
         BE    NORDBMSG            NO, ITS OK TO READ THEN
         MVI   CHNGED,0            WELL IT'LL BE CLEAN NOW
         NI    FLAGSX,255-MUSTZAP  NEW BLOCK, NO ZAP NEEDED YET
         LA    R1,4                MESSAGE NUMBER
         BAL   R8,SETLINE          SETUP THE LINE
         B     NORDBMSG            NOT LOGGING
         MVC   30(18,R2),=CL18'BLOCK NOT REPLACED'
         MVI   0(R2),C'0'          DOUBLE SPACE
        @HEX   (24,R2),OLDTTR,LEN=3 DIFF TTR THIS TIME
         BAL   R8,CPUT             DUMP THE LINE
NORDBMSG L     R8,ZDBLW            RESTORE RETURN REGISTER
         XC    BLKLEN(2),BLKLEN    ASSUME NOTHING READ
         LA    R15,CCW##R          -> CCW CHAIN
         CLI   TTR+2,0             R0?
         BNE   *+L'*+4             NO, OK
         LA    R15,CCW##R0         READ R0
         STCM  R15,B'0111',ZIOB+(IOBSTRTB-IOBSTDRD) SET IN IOB
         L     R0,TTR              GIVE HIM THE TTRN
         N     R0,=XL4'FFFFFF00'     MAKE IT A TTRN
         XR    R1,R1
         ICM   R1,B'0111',DCBU+DCBDEBA-IHADCB GIVE HIM THE DEB
         LA    R2,ZIOB+(IOBSEEK-IOBSTDRD) GIVE HIM A WORK-AREA FOR IT
         STM   R8,R12,20+R8*4(R13) SAVE SOME REGISTERS
         LR    R8,R13              SAVE POINTER TO SAVE-AREA
         L     R15,CVTPTR          CVT POINTER
         L     R15,CVTPCNVT-CVT(,R15) POINT TO THE ROUTINE
        CALL   (15)                GO DO IT
         LR    R13,R8              RESTORE POINTER TO SAVE-AREA
         LM    R8,R12,20+R8*4(R13) RESTORE THE DEAD REGS
         LTR   R15,R15             OUT OF DS?
         BNZ   EXCP42              YES, DON'T BOTHER READING
         IC    R1,CCHHR+4          GET "R"
         BCTR  R1,0                -1 FOR SEARCH ID
         STC   R1,CCHHR+4          SET BACK
        EXCP   ZIOB
        WAIT   ECB=ZECB
         MVC   CCHHR+4(1),TTR+2    RESTORE "R"
         LH    R2,BUFFSIZE         GET BUFSIZ (MAX READ=BLKSI)
         SH    R2,ZIOB+(IOBCSW-IOBSTDRD)+5 = AMOUNT READ
         LR    R0,R2               COPY 8+KL+DL
         SH    R0,=H'8'            GET KEY-LENGTH + DATA-LENGTH
         STH   R0,CCW#W#W+6        SAVE IT FOR LATER USE
         L     R1,ADDRCNT          -> COUNT
         MVC   KEYLEN+1(1),5(R1)   SET UP KEY-LENGTH
         LH    R15,KEYLEN          GET KEY-LENGTH
         LA    R0,8(R1,R15)        -> DATA
         ST    R0,ADDRDATA         SET ADDRESS OF DATA
         CLC   ADDRBUFF,ADDRKEY    HOW MUCH DO WE DISPLAY?
         BL    SAVE$LEN            COUNT + KEY + DATA
         BE    *+L'*+2             KEY + DATA
         SR    R2,R15              JUST DATA
         SH    R2,=H'8'            NOT COUNT FIELD
SAVE$LEN STH   R2,BLKLEN           SAVE IT FINALLY
*              NOW CHECK THE READ, FINALLY...
         CLI   ZECB,ECBNORM        OK?
         BE    EXCPOK
         CLI   ZECB,ECBDAEA        END OF EXTENT
         BE    EXCP42
         CLI   ZECB,ECBPERR        PERM ERROR?
         BE    EXCP41
REALERR  LA    R1,=CL15' TYPE UNKNOWN  ' GET MESSAGE ADDRESS
EXCPERR  XR    R0,R0               GET A ZERO
         STH   R0,BLKLEN           NOTHING WAS READ
         STH   R0,CCW#W#W+6        AND NOTHING TO WRITE
EXCPERR$ OI    FLAGSR,YESSYN       AND IT WAS IN ERROR
         MVC   IOMLINE+17(40),IOERRMSG MOVE IN MASK
         MVC   IOMLINE+35(15),0(R1) MOVE IN ERROR MESSAGE
         MVI   TTR+3,NOSEQRD       TURN OFF SEQ READ FLAG
         BR    R8
EXCP42   LA    R1,=CL15'NOT IN DATA-SET' GET MESSAGE ADDRESS
         B     EXCPERR
EXCP41   TM    ZIOB+(IOBUSTAT-IOBSTDRD),IOBUSB7 UNIT EXCEPTION?
         BO    EODAD               YES, EOF
         TM    ZIOB+(IOBSENS1-IOBSTDRD),IOBS1B4 NRF?
         BZ    NOT$NRF             NO
EXCP$NRF CLI   TTR+3,SEQREAD       NEXT BLOCK REQ?
         LA    R1,=CL15'NO RECORD FOUND' GET MESSAGE ADDRESS IN CASE
         BNE   EXCPERR
         LH    R15,TTR             GET TRACK
         LA    R15,1(,R15)         NEXT TRACK
         STH   R15,TTR             SAVE IT
         MVI   TTR+2,1             RECORD 1
         MVI   TTR+3,NOSEQRD       RESET SEQ READ FLAG
         B     READBLK             GO REREAD
NOT$NRF  TM    ZIOB+(IOBCSTAT-IOBSTDRD),IOBCSB1 INCORRECT LENGTH?
         BZ    REALERR             NO, SOMETHING ELSE
         LA    R1,=CL15'INCORR. LENGTH ' GET MESSAGE ADDRESS
         B     EXCPERR             GO SAY INCORRECT LENGTH
EXCPOK   L     R15,ADDRCNT         -> COUNT
         CLC   CCHHR(L'CCHHR),0(R15) RIGHT RECORD?
         BE    EXCPOK$             YES, CONTINUE
         LA    R1,=CL15'CCHHR INCORRECT' GET MESSAGE ADDRESS IN CASE
         CLC   CCHHR(4),0(R15)     RIGHT CCHH?
         BNE   EXCPERR$            NO, ARRGH
         CLI   4(R15),1            IS IT R1?
         BE    EXCP$NRF            YES, IT'S REALLY NRF
         B     EXCPERR$            NO, ARRGH
EXCPOK$  MVI   TTR+3,NOSEQRD       TURN OFF SEQ READ FLAG
         OC    ZIOB+(IOBCSW-IOBSTDRD)+5(2),ZIOB+(IOBCSW-IOBSTDRD)+5 ANYX
                                   RESIDUAL?
         LA    R1,=CL15'BLKLEN > BUFFSZ'   -> MESSAGE IN CASE
         BZ    EXCPERR$            NO, ERROR
         BR    R8                  ALL DONE, RETURN BLOCK
*- - - - END-OF-FILE (EODAD EXIT).
*              IF EOF'S ARE NOT COUNTED AS BLOCKS (AS IN A PDS),
*              THEN DISPLAY END OF FILE. OTHERWISE HOP THEM.
EODAD    LR    R2,R8               SAVE RETURN TO READ
         BAL   R8,CLEAR            CLEAR SCREEN
         MVC   IOMLINE,BLANKS      CLR TOP ERR-MSG SO CAN SAY EOF
*              LENGTH OF EOF RECORD IS ALREADY SET.
         MVC   IOMLINE+27(20),EOFMSG TELL HIM END-OF-FILE
         MVI   TTR+3,NOSEQRD       TURN OFF SEQ READ
         TM    FLAGSR,YESEOF       EOF ALLOWED HERE?
         BO    NEW$DISP            YES, SO EOF ALREADY
         BR    R2                  NO, EXIT FROM READBLK (EOF)
*------- SETLINE.                                                <===*
*        SET UP LINE MESSAGE NUMBER FOR "CPUT".
*              INPUT : R1 IS THE SINGLE MESSAGE NUMBER IN CHAR. FORM.
*                      R8 = LINK REGISTER.
*                      RETURNS : 0(R8) - IF NOT LOGGING,
*                                4(R8) - IF LOGGING.
*              OUTPUT : R2 POINTS TO LINE (ONLY ON 4(R8) RETURN).
SETLINE  TM    FLAGSL,LOGOPN       ARE WE LOGGING?
         BZR   R8                  IF NOT RETURN
         L     R2,CSLLOC           GET THE LINE
         MVC   1(7,R2),=CL7'ZAP010I' MOVE IN MESSAGE NUMBER
         MVC   9(L'ZUSRID,R2),ZUSRID CULPRIT
         LTR   R1,R1               IS NUMBER 0?
         BNP   4(R8)               YES, OK
         STC   R1,6(R2)            BUILD DIGIT NUMBER
         OI    6(R2),C'0'
         CH    R1,=H'4'            IS TTR NEEDED?
         BH    4(R8)               NO, GO BACK TO CALLER
         MVC   18(3,R2),=CL3'TTR'
        @HEX   (22,R2),TTR,LEN=3   GET THIS TTR
         B     4(R8)               NOW RETURN TO CALLER
*------- SETMSG.                                                 <===*
*        MOVE MESSAGE AND HYPHENS TO CORRECT POSITION ON SCREEN.
*              INPUT : R1 = POINTS TO CL20'...MESSAGE...'.
*                      R8 = LINK REGISTER.
SETMSG   LH    R1,0(,R8)           GET MESSAGE OFFSET
         AR    R1,R12              GET ADDRESS
SETMSGX  MVC   MSGLINE+27(20),0(R1) MOVE IT TO CENTER
         MVC   MSGLINE+17(9),=9C'=' MAKE IT FANCY
         MVC   MSGLINE+48(9),=9C'=' BUT DON'T GET CARRIED AWAY
         B     2(,R8)              RETURN PAST OFFSET
*------- SETSTRNG.                                               <===*
*        CONVERT STRING FOR "CPUT".
*              INPUT : R1 = POINTER TO OUTPUT LINE.
*                      R4 = EXECUTE LENGTH OF STRING.
*                      R5 = ADDRESS OF DATA TO BE CONVERTED.
*                      R8 = LINK REGISTER.
SETSTRNG UNPK  TEMPW(9),0(5,R5)    CONVERT FIRST WORD
         UNPK  TEMPW+8(9),4(5,R5)  CONVERT SECOND
         UNPK  TEMPW+16(9),8(5,R5) CONVERT THIRD
         UNPK  TEMPW+24(9),12(5,R5) CONVERT FOURTH AND LAST
         TR    TEMPW(32),HEXTAB    FIX UP HEX
         LTR   R4,R4               ANY?
         BMR   R8                  NO, LEAVE IT BLANK
         LA    R15,1(R4,R4)        GET EXECUTE LENGTH OF HEX
         EX    R15,CPMVC           MOVE CONVERTED DATA
         MVI   35(R1),C''''
         EX    R4,SETSTRMV         MOVE CHAR FORM TO BUFFER
         L     R15,TRTABADD        GET RIGHT TRTAB POINTER
         EX    R4,SETSTRTR         TRANSLATE TO RIGHT CHARSET
         LA    R15,36+1(R4,R1)
         MVI   0(R15),C''''
         BR    R8                  RETURN
CPMVC    MVC   0(*-*,R1),TEMPW     <<EXECUTED>>
SETSTRMV MVC   36(*-*,R1),0(R5)    <<EXECUTED>>
SETSTRTR TR    36(*-*,R1),0(R15)   <<EXECUTED>>
*------- STRCNV.                                                 <===*
*        STRING CONVERSION ROUTINE.
*              R8 = LINK REGISTER.
*              R14 = STRING ADDRESS.
STRCNV   LH    R1,0(R14)           GET STRING LENGTH
         EX    R1,STRCNVM          TARGET OUTPUT STRING
         ICM   R15,B'1111',TRTXTAB
         BZR   R8
         EX    R1,STRCNVT          TRANSLATE STRING
         BR    R8                  RETURN TO CALLER
STRCNVM  MVC   WKSTR(*-*),2(R14)   <<EXECUTED>>
STRCNVT  TR    WKSTR(*-*),0(R15)   <<EXECUTED>>
*------- TTRPARSE.                                               <===*
*        DETERMINES AND VALIDITY CHECKS TTR SPECIFIED.
*              R1 = POINTS TO THE TTR.
*              R0 = HAS ITS LENGTH - OUTPUT IS IN TEMP2+1(3).
*              R6 = LINK REGISTER.
TTRPARSE L     R15,TTR             GET '*' = CURRENT TTR
         SRL   R15,8               RIGHT JUSTIFY
         BAL   R8,CALLEXP          GO PARSE
         BNP   TTRLT1              NOT POSITIVE IS INVALID
         ST    R15,TEMP2           SAVE THE VALUE RETURNED
         CLI   TEMP2+3,0           REC 0?
         BNZR  R6                  NO, GIVE IT
         LA    R2,REC0INV          YES, TELL HIM
         B     BOTCH               WITH A MESSAGE
TTRLT1   LA    R2,TTRSMALL         POINT TO ERROR MESSAGE
         B     BOTCH               DISPLAY ERROR STYLE
*------- WRITE.                                                  <===*
*        EXCP WRITE OUT A BLOCK.
*              R8 = LINK REGISTER.
WRITE    LA    R14,CCW##W          -> CCW CHAIN
         STCM  R14,B'0111',ZIOB+(IOBSTRTB-IOBSTDRD) SET IN IOB
        EXCP   ZIOB
        WAIT   ECB=ZECB
         CLI   ZECB,ECBNORM
         BER   R8
         B     REALERR
         EJECT
*------- CONSTANTS --------------------------------------------------*
         SPACE 1
OBTLIST CAMLST SEARCH,*-*,*-*,*-*
OBTLISTL EQU   *-OBTLIST
         DC    XL6'0A0B0C0D0E0F',41C'.' FOR CHAR TO HEX   |CONTIGUOUS|
         DC    CL16'0123456789ABCDEF'                     |CONTIGUOUS|
HEXTAB   EQU   *-256
         SPACE 1
EDMASK   DC    XL12'402020202020202020202120'
ITRTBL   DC    0H'0',AL2(L'ITRTAB)
DUMPOFFS DC    AL1(9,18,27,36,48,57,66,75)
MAXWIDTH DC    A((MSGLINE-LINE06-$I)/$I/2)
         SPACE 1
CTL3270  DC    XL2'4040'           SBA (1,1)
         DC    XL2'C150'               (2,1)
         DC    XL2'C260'               (3,1)
         DC    XL2'C3F0'               (4,1)
         DC    XL2'C540'               (5,1)
         DC    XL2'C650'               (6,1)
         DC    XL2'C760'               (7,1)
         DC    XL2'C8F0'               (8,1)
         DC    XL2'4A40'               (9,1)
         DC    XL2'4B50'               (10,1)
         DC    XL2'4C60'               (11,1)
         DC    XL2'4DF0'               (12,1)
         DC    XL2'4F40'               (13,1)
         DC    XL2'5050'               (14,1)
         DC    XL2'D160'               (15,1)
         DC    XL2'D2F0'               (16,1)
         DC    XL2'D440'               (17,1)
         DC    XL2'D550'               (18,1)
         DC    XL2'D660'               (19,1)
         DC    XL2'D7F0'               (20,1)
         DC    XL2'D940'               (21,1)
NL3270   EQU   (*-CTL3270)/L'CTL3270
END3270  DS    0XL4
         DC    XL3'11C1D1'         SBA (2,2)
         DC    XL1'13'             IC
         SPACE 1
*- - - - CONSTANTS FOR DISPLAY ROUTINE (TRTAB FOR CARET).
TBYTES   DC    AL1(7,12,12,17,18,23,23,28,30,35,35,40,41,46,46,51)
DSPTRT   DC    AL1(48)                  BLANK               +08
         DC    AL1(16,17,18,19,48)      BYTES 01, 02        +09
         DC    AL1(20,21,22,23,48,48)   BYTES 03, 04        +14
         DC    AL1(24,25,26,27,48)      BYTES 05, 06        +20
         DC    AL1(28,29,30,31,48,48,48)      07, 08        +25
         DC    AL1(32,33,34,35,48)            09, 10        +32
         DC    AL1(36,37,38,39,48,48)         11, 12        +37
         DC    AL1(40,41,42,43,48)            13, 14        +43
         DC    AL1(44,45,46,47)               15, 16        +48
         DC    AL1(48,48,48,49)         '   |'              +52
         DC    AL1(0,1,2,3,4,5,6,7)     FIRST 8 CHARS       +56
         DC    AL1(8,9,10,11,12,13,14,15)  LAST 8 CHARS     +64
         DC    AL1(49)                                      +72
DSPTRTL  EQU   *-DSPTRT            LENGTH
         SPACE 1
INVMEM   DC    CL20'MEMBER NOT FOUND    '
STORMSG  DC    CL20'NOTE: NOT UPDATING  '
EOFMSG   DC    CL20'*** END OF FILE *** '
NOMEMFND DC    CL20'*NO DIRECTORY ENTRY*'
IOERRMSG DC    CL40' ***** I/O ERROR: XXXXXXXXXXXXXXX ***** '
OPNMSG   DC    CL41'0ZAP009I XXXXXXXX HAS OPENED FOR INPUT '
OPNMS1   EQU   7,1                 (ACTION)
OPNMS2   EQU   9,8                 (USER-ID)
OPNMS3   EQU   33,6                (INPUT/UPDATE)
OPNMS4   EQU   40,44               (DATA-SET NAME)
OPNMS5   EQU   85,2                ("ON")
OPNMS6   EQU   88,6                (VOLUME)
LOGMSG   MSG   'LOGGING'
NAMEMNF  MSG   'NAME INVALID'
OBTMSG   MSG   'OBTAIN FAILED'
CONMSG   MSG   '<STR> CAPS ON'
INVMSG   MSG   'INVALID PK-KEY'
COFFMSG  MSG   '<STR> CAPS OFF'
LENERR   MSG   'LENGTH INVALID'
BADEQUAL MSG   'INVALID SYMBOL'
INVCOM   MSG   'INVALID COMMAND'
NOMCOM   MSG   'NOT PARTITIONED'
INVDEC   MSG   'INVALID DECIMAL'
LASTINV  MSG   'INVALID IN VTOC'
DUMPWMSG MSG   'DUMP SUCCESSFUL'
INVOPCOD MSG   'INVALID OP CODE'
REC0INV  MSG   'RECORD 0 INVALID'
INVFMSG  MSG   'NO FORWARD CHAIN'
REDEFMSG MSG   'SYMBOL REDEFINED'
NOCSOUT  MSG   'UNABLE TO RECORD'
NOTVMSG  MSG   'DATA-SET NOT VTOC'
WRITERR  MSG   'WRITE NOT ALLOWED'
ASCIIMSG MSG   'ASCII TRANSLATION'
ZCODEMSG MSG   'ZCODE TRANSLATION'
INVBMSG  MSG   'NO BACKWARD CHAIN'
TABFULL  MSG   'DEFINE TABLE FULL'
OZFMSG   MSG   'OPEN "ZAP" FAILED'
FZFMSG   MSG   'FREE "ZAP" FAILED'
INVEXP   MSG   'SYNTAX ERROR COL. '
IOTPMSG  MSG   'TSO-TPUT I/O ERROR'
IOTGMSG  MSG   'TSO-TGET I/O ERROR'
EBCDCMSG MSG   'EBCDIC TRANSLATION'
LINMSG   MSG   'SCAN NOT IN EFFECT'
DEFRESET MSG   'DEFINE TABLE RESET'
NFDMSG   MSG   'DATA-SET NOT FOUND'
AZFMSG   MSG   'ALLOC "ZAP" FAILED'
IORDMSG  MSG   'EXCP-READ I/O ERROR'
CEXMSG   MSG   'PA1 PRESSED = CANCEL'
IOWRMSG  MSG   'EXCP-WRITE I/O ERROR'
TTRSMALL MSG   'TTR < 000001 INVALID'
BACKDUMP MSG   'REVERSE DUMP INVALID'
DSNXMSG  MSG   'DATA-SET : NO EXTENT'
GMBMSG   MSG   'GETMAIN BUFFER ERROR'
         AIF   ('&TXV' NE 'EUROPE').SK1
OUCH     MSG   '... OUCH|||'
RTLMSG   MSG   'RESPONSE TOO LONG|||'
SFEMSG   MSG   'SCREEN FORMAT ERROR|'
         AGO   .SK2
.SK1     ANOP
OUCH     MSG   '... OUCH!!!'
RTLMSG   MSG   'RESPONSE TOO LONG!!!'
SFEMSG   MSG   'SCREEN FORMAT ERROR!'
.SK2     SPACE 1
*------- LITERAL POOL. ----------------------------------------------*
         PRINT &PRS
        LTORG
         SPACE 1
         DROP  R9,R10,R11,R12,R13
         EJECT
CCWLIST  CCW   X'03',0,X'40',1     NOP FOR NOW
         CCW   X'31',*-*,X'40',L'CCHHR SEARCH ID EQ
         CCW   X'08',*-*,X'00',0   TIC *-8
         CCW   X'1E',*-*,X'20',*-* READ CKD
         CCW   X'31',*-*,X'40',L'CCHHR SEARCH ID EQ
         CCW   X'08',*-*,X'00',0   TIC *-8
         CCW   X'0D',*-*,X'20',*-* WRITE KD
         CCW   X'16',*-*,X'20',*-* READ R0
         CCW   X'16',0,X'70',1     READ R0 TO ORIENT
         CCW   X'E9',*-*,X'40',L'ZNAME  SEARCH KEY EQ/HI MT
         CCW   X'08',*-*,X'00',0   TIC *-8
         CCW   X'0E',*-*,X'00',8+256 READ KD
         CCW   X'31',*-*,X'40',L'CCHHR SEARCH ID EQ
         CCW   X'08',*-*,X'00',0   TIC *-8
         CCW   X'1D',*-*,X'20',*-* WRITE CKD
CCWL     EQU   *-CCWLIST           LENGTH OF CCW PATTERNS
         PRINT &PRF
DCBMSK  DCB    MACRF=E,DDNAME=SYSLIB,DEVD=DA
         DC    5F'0'               STUPID MACRO & SYSTEM
DCBUL    EQU   *-DCBMSK            TURKEY SYSTEM (NEED 72 BYTES)
         SPACE 1
*------- COMMAND TABLE ----------------------------------------------*
CMTBL    EQU   0,1                 ELEMENT = COMMAND NAME LENGTH
CMTBN    EQU   1,8                           COMMAND NAME
CMTBA    EQU   9,3                           COMMAND ADDRESS
CMTBEL   EQU   12                  ELEMENT LENGTH
COMTAB   DS    0F                  START OF COMMANDS TABLE
        @CMD   WHATMEM,WHATMEM
        @CMD   //DEBUG,DIEFAST
        @CMD   CAPSOFF,CAPSOFF
        @CMD   LASTDS1,LASTDS1
        @CMD   CANCEL,CANEX
        @CMD   CAPSON,CAPSON
        @CMD   DISASM,DISASM
        @CMD   EBCDIC,EBCDIC
        @CMD   ITRACE,ITRACE
        @CMD   ASCII,ASCII
        @CMD   DISPC,DISPC
        @CMD   DISPD,DISPD
        @CMD   DISPK,DISPK
        @CMD   DUMPF,DUMPF
        @CMD   DUMPT,DUMPT
        @CMD   EJECT,EJECT
        @CMD   FLOAT,FLOAT
        @CMD   NODEF,NODEF
        @CMD   WHERE,WHERE
        @CMD   ZCODE,ZCODE
        @CMD   BASE,BASE
        @CMD   DUMP,DUMP
        @CMD   HELP,HELPHELP
        @CMD   IDEF,IDEF
        @CMD   LAST,LAST
        @CMD   NAME,NAME#
        @CMD   NOTE,NOTE
        @CMD   SAVE,REPLACE
        @CMD   ZSYM,ZCODE
        @CMD   ABS,ABS
        @CMD   ASM,ASM
        @CMD   CAN,CANEX
        @CMD   END,XEND
        @CMD   LOG,LOG
        @CMD   SET,SET
        @CMD   ZAP,REPLACE
        @CMD   WM,WHATMEM
        @CMD   <,BACKWARD
        @CMD   %,INDPOINT
        @CMD   >,FORWARD
        @CMD   ?,HELP
        @CMD   #,CALC
        @CMD   =,EQUALS
        @CMD   B,BACK
        @CMD   D,DISPLAY#
        @CMD   E,NAME#
        @CMD   F,FIND
        @CMD   H,HELP
        @CMD   J,POINT$J
        @CMD   L,LOCATE
        @CMD   M,MEMBER#
        @CMD   N,AND
        @CMD   O,OR
        @CMD   P,POINT
        @CMD   R,RECORD
        @CMD   S,STORE
        @CMD   T,TRACK
        @CMD   U,UP
        @CMD   V,INDIRECT
        @CMD   W,WINDOW
        @CMD   X,EXOR
        @CMD   'X X X X',INVEXPER  ZAP SPACE
         DC    XL1'FF'
         PRINT &PRS
*------- SENSITIVE PREFIXES TABLE -----------------------------------*
        @SST
*------- TRANSLATE TABLES -------------------------------------------*
         SPACE 1
         DS    0F
*- - - - DUMP FORMAT TRTAB (*** ASCII ***).
*        (THIS IS A MODIFIED VERSION OF ASMTRTAB RASA,
*        INTO WHICH ALL HEXADECIMAL VALUES LESS THAN X'3F'
*        HAVE BEEN REPLACED BY A PERIOD CHARACTER X'4B')
         SPACE 1
IECTRASA EQU   *  0 1 2 3 4 5 6 7 8 9 A B C D E F
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B' 0
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B' 1
         DC    X'404F7F7B5B6C507D4D5D5C4E6B604B61' 2
         DC    X'F0F1F2F3F4F5F6F7F8F97A5E4C7E6E6F' 3
         DC    X'7CC1C2C3C4C5C6C7C8C9D1D2D3D4D5D6' 4
         DC    X'D7D8D9E2E3E4E5E6E7E8E94AE05A5F6D' 5
         DC    X'79818283848586878889919293949596' 6
         DC    X'979899A2A3A4A5A6A7A8A9C06AD0A14B' 7
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B' 8
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B' 9
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B' A
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B' B
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B' C
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B' D
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B' E
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B' F
         SPACE 1
*- - - - CONVERT STRING TRTAB (*** ASCII ***).
*        (THIS IS THE VERSION OF ASMTRTAB SASA)
         SPACE 1
IECTSASA EQU   *  0 1 2 3 4 5 6 7 8 9 A B C D E F
         DC    X'000102031A091A7F1A1A1A0B0C0D0E0F' 0
         DC    X'101112131A0A080018191A1A1C1D1E1F' 1
         DC    X'1A1A1A1A1A0A171B1A1A1A1A1A050607' 2
         DC    X'1A1A161A1A1A1A041A1A1A1A14151A1A' 3
         DC    X'201A1A1A1A1A1A1A1A1A5B2E3C282B21' 4
         DC    X'261A1A1A1A1A1A1A1A1A5D242A293B5E' 5
         DC    X'2D2F1A1A1A1A1A1A1A1A7C2C255F3E3F' 6
         DC    X'1A1A1A1A1A1A1A1A1A603A2340273D22' 7
         DC    X'1A6162636465666768691A1A1A1A1A1A' 8
         DC    X'1A6A6B6C6D6E6F7071721A1A1A1A1A1A' 9
         DC    X'1A7E737475767778797A1A1A1A1A1A1A' A
         DC    X'1A1A1A1A1A1A1A1A1A1A1A1A1A1A1A1A' B
         DC    X'7B4142434445464748491A1A1A1A1A5C' C
         DC    X'7D4A4B4C4D4E4F5051521A1A1A1A1A1A' D
         DC    X'5C1A535455565758595A1A1A1A1A1A1A' E
         DC    X'303132333435363738391A1A1A1A1A1A' F
         SPACE 1
*- - - - DUMP FORMAT TRTAB (*** ZCODE ***).
         SPACE 1
TRCHARZ  DC    256C'.'
         ORG   TRCHARZ+X'18'
         DC    X'C0D0'
         ORG   TRCHARZ+X'25'
         DC    C'$'
         ORG   TRCHARZ+X'40'
         DC    C' ABCDEFGHIJKLMNOPQRSTUVWXYZ'
         DC    C'_ABCDEFGHIJKLMNOPQRSTUVWXYZ'
         DC    C'=0123456789'
         ORG   TRCHARZ+X'90'
         DC    C'+-'
         ORG   TRCHARZ+X'9E'
         DC    C'<'
         ORG   TRCHARZ+X'A0'
         DC    C'='
         ORG   TRCHARZ+X'A2'
         DC    C'>'
         ORG   TRCHARZ+X'A4'
         DC    C'-',X'5A'          EXCLAIM POINT
         ORG   TRCHARZ+X'B5'
         DC    C',?'
         ORG   TRCHARZ+X'C4'
         DC    C';:'
         ORG   TRCHARZ+X'F9'
         DC    C'#'
*        ORG   TRCHARZ+4
*        DC    C'$'
*        ORG   TRCHARZ+14
*        DC    C'??();/'
*        ORG   TRCHARZ+26
*        DC    C'+-*/*...?V<.=.>'
*        ORG   TRCHARZ+47
*        DC    C',?'
*        ORG   TRCHARZ+54
*        DC    C''
*        ORG   TRCHARZ+61
*        DC    C'_'
*        ORG   TRCHARZ+82
*        DC    C'??'
*        ORG   TRCHARZ+86
*        DC    C'ABCDEFGHIJKLMNOPQRSTUVWXYZ-'
*        ORG   TRCHARZ+113
*        DC    C'ABCDEFGHIJKLMNOPQRSTUVWXYZ='
*        ORG   TRCHARZ+140
*        DC    C'0123456789.. '':'
         ORG   ,
         SPACE 1
*- - - - CONVERT STRING TRTAB (*** ZCODE ***).
*        (THIS IS THE PREVIOUS TABLE IN REVERSE ORDER JUST
*        BECAUSE I DIDN'T FOUND WHAT 'ZCODE' MEANS) MOINIL P.A.
         SPACE 1
TRCHRZ   DC    256X'3F'
         ORG   TRCHRZ+X'40'
         DC    X'40'
         ORG   TRCHRZ+X'4C'        <
         DC    X'9E'
         ORG   TRCHRZ+X'4E'        +
         DC    X'90'
         ORG   TRCHRZ+X'5A'        !$
         DC    X'A525'
         ORG   TRCHRZ+X'5E'        ;
         DC    X'C4'
         ORG   TRCHRZ+X'60'        -
         DC    X'91' OR X'A4'
         ORG   TRCHRZ+X'6B'        ,
         DC    X'B5'
         ORG   TRCHRZ+X'6D'        _>?
         DC    X'5BA2B6'
         ORG   TRCHRZ+X'7A'        :#
         DC    X'C5F9'
         ORG   TRCHRZ+X'7E'        =
         DC    X'76' OR X'A0'
         ORG   TRCHRZ+X'81'        ABCDEFGHI
         DC    X'5C5D5E5F6061626364'
         ORG   TRCHRZ+X'91'        JKLMNOPQR
         DC    X'65666768696A6B6C6D'
         ORG   TRCHRZ+X'A2'        STUVWXYZ
         DC    X'6E6F707172737475'
         ORG   TRCHRZ+X'C0'        {ABCDEFGHI
         DC    X'18414243444546474849'
         ORG   TRCHRZ+X'D0'        }JKLMNOPQR
         DC    X'194A4B4C4D4E4F505152'
         ORG   TRCHRZ+X'E2'        STUVWXYZ
         DC    X'535455565758595A'
         ORG   TRCHRZ+X'F0'        0123456789
         DC    X'7778797A7B7C7D7E7F80'
         ORG   ,
         SPACE 1
*- - - - DUMP FORMAT TRTAB (*** EBCDIC ***).
         SPACE 1
TRCHARE  DC    256C'.'
         ORG   TRCHARE+C' '
         DC    C' '
         ORG   TRCHARE+X'4A'       CENT SIGN
         DC    X'4A',C'.<(+|&&'
         ORG   TRCHARE+X'5A'       EXCLAMATION POINT
         DC    X'5A',C'$*);-/'
         ORG   TRCHARE+C','
         DC    C',%_>?'
         ORG   TRCHARE+C':'
         DC    C':#@''=',X'7F'     DOUBLE QUOTE
         ORG   TRCHARE+X'81'
         DC    9AL1(*-TRCHARE)     LOWER CASE A-I
         ORG   TRCHARE+X'91'
         DC    9AL1(*-TRCHARE)     LOWER CASE J-R
         ORG   TRCHARE+X'A2'
         DC    8AL1(*-TRCHARE)     LOWER CASE S-Z
         ORG   TRCHARE+C'A'
         DC    9AL1(*-TRCHARE)     UPPER CASE A-I
         ORG   TRCHARE+C'J'
         DC    9AL1(*-TRCHARE)     UPPER CASE J-R
         ORG   TRCHARE+C'S'
         DC    8AL1(*-TRCHARE)     UPPER CASE S-Z
         ORG   TRCHARE+C'0'
         DC    10AL1(*-TRCHARE)    NUMERICS 0-9
         ORG   ,
         PRINT &PRF
         EJECT
*--- E X P A N A L --- EXPRESSION ANALYZER ("EXP") ------------------*
*              THIS ROUTINE WILL ANALYZE AN EXPRESSION PASSED TO IT  *
*              AND RETURN ITS VALUE CONCATENATED WITH A STARTING     *
*              VALUE. IF "EXPOPT" IS "NOSYMB", TABLE IS NOT SCANNED, *
*              ELSE SYMBOL TABLE IS SCANNED.                         *
*               INPUT : R0  - LENGTH OF EXPRESSION TO PARSE.         *
*                       R1  - ADDRESS OF EXPRESSION TO PARSE.        *
*                       R2  - STARTING VALUE OF '*'.                 *
*                       R13 - SAVE-AREA.                             *
*                       R14 - RETURN ADDRESS.                        *
*              OUTPUT : R1  - RETURN CODE.                           *
*                             IF NEGATIVE : NO ERRORS DETECTED.      *
*                             IF ZERO OR POSITIVE AN ERROR OCCURED   *
*                             AT ADDRESS GIVEN IN R1.                *
*                       R15 - IF NO ERROR, THE NEW VALUE CALCULATED. *
*--------------------------------------------------------------------*
         CNOP  0,4
         USING TSDSECT,R9
EXPANAL  STM   R14,R1,EXPARMS      SAVE CALLER'S REGS ONE PLACE
         STM   R2,R12,20+R2*4(R13) SAVE REST IN OTHER PLACE
         LR    R12,R15             GET BASE
         USING EXPANAL,R12
         LR    R4,R2               ALWAYS BEGIN WITH *
         ST    R2,EXPSTART         SAVE VALUE OF "*"
         LR    R3,R1               START SCAN
         BCTR  R3,0                HE WILL ADD ONE FIRST
         LR    R2,R0               BCT INDEX
         MVI   EXPFLAG+1,0         RESET FLAGS
         LA    R2,1(R2)            ALLOW FOR FIRST PASS
         ST    R1,GORF             FIRST BAD SPOT
         B     EXPBACK             START AFTER ITEM
*              SEE WHAT NEXT ITEM IS.
EXPITEM  LTR   R2,R2               ANYTHING LEFT?
         BP    EXPON               YES
         ST    R4,EXPSTART         NEW STARTER
         OI    EXPPTR,X'80'        NO ERROR
         B     EXPRET              RETURN
EXPON    CLI   0(R3),C' '          BLANK?
         BNE   EXPCHECK            NO, WE CAN USE IT
EXPNEXT  LA    R3,1(R3)            NEXT SPOT TO CHECK
         BCT   R2,EXPITEM          CONTINUE
         MVI   EXPFLAG+1,0         NOTHING FOR NEXT TIME
         B     EXPCONV             WHEN AT END, USE LAST IF ANY
EXPCHECK ST    R3,GORF             KEEP TRACK OF WHERE WE ARE
         CLI   0(R3),C'*'          CURRENT LOC OR MULT?
         BE    EXPSTAR             YES, GO DECIDE WHICH
         CLI   0(R3),C'+'          ADD?
         BE    EXPADD              YES
         CLI   0(R3),C'-'          SUBTRACT?
         BE    EXPSUB              YES
         CLI   0(R3),C'.'          DECIMAL DONE?
         BE    EXPDEC              YES
         CLI   0(R3),C'/'          DIVIDE?
         BE    EXPDIV              YES
         OI    EXPFLAG+1,EXPEXOPR  EXPECTING OPERATOR NOW
*              IF NO TERMINATOR IS FOUND, SAVE UP FOR LATER.
         LA    R0,EXPWORK+8        POINT PAST IT
         CLR   R0,R5               TOO FAR?
         BNH   EXPERR              YES
         MVC   0(1,R5),0(R3)       COPY IT TO WORK-AREA
         LA    R5,1(R5)
         B     EXPNEXT             CONTINUE
*              IF AN ERROR IS DETECTED, PASS BACK ADDRESS OF IT.
EXPERR   MVC   EXPPTR,GORF         SAVE POINTER FOR RETURN
EXPRET   MVI   EXPOPT,NOSYMB       SET NO SYMBOL TABLE LOOKUP
         LM    R14,R1,EXPARMS      GET RETURN REGS
         LM    R2,R12,20+R2*4(R13) RESTORE REST OF REGS FROM SAVE
         BR    R14
*              '*' WAS ENTERED, DECIDE IF CURRENT LOC OR MULTIPLY.
EXPSTAR  TM    EXPFLAG+1,EXPEXOPR  WHICH IS THIS?
         BO    EXPMULT             MULTIPLY
*              USE CURRENT VALUE.
EXPCURR  L     R15,EXPSTART        GET STARTING VALUE
         MVI   EXPFLAG+1,EXPEXOPR  EXPECTING OPERATOR NOW
         B     EXPUSE              AND GO USE IT
*              IF '+' WAS ENTERED, TERMINATE PREVIOUS AND SET FLAG.
EXPADD   MVI   EXPFLAG+1,EXPFPLUS  INDICATE ADD NEXT TIME
         B     EXPCONV             GO CONVERT IT
*              IF '-' WAS ENTERED, TERMINATE PREVIOUS AND SET FLAG.
EXPSUB   MVI   EXPFLAG+1,EXPFMINS  INDICATE ADD NEXT TIME
         B     EXPCONV             GO CONVERT IT
*              IF '*' WAS ENTERED, TERMINATE PREVIOUS AND SET FLAG.
EXPMULT  MVI   EXPFLAG+1,EXPFMULT  INDICATE MULT NEXT TIME
         B     EXPCONV             GO CONVERT IT
*              IF '/' WAS ENTERED, TERMINATE PREVIOUS AND SET FLAG.
EXPDIV   MVI   EXPFLAG+1,EXPFDIV   INDICATE DIV NEXT TIME
         B     EXPCONV             GO CONVERT IT
*              IF '.' WAS ENTERED, TERMINATE PREVIOUS AS DECIMAL.
EXPDEC   OI    EXPFLAG,EXPFDEC     INDICATE DECIMAL THIS TIM
*              WHEN UP TO 8 CHARS SCANNED OUT,
*              CONVERT THEM APPROPRIATELY.
EXPCONV  LA    R15,EXPWORK+1       POINT TO START
         SR    R5,R15              FIND EXECUTE LENGTH
         LR    R15,R5              SAVE IT
         BNM   EXPCOK+L'EXPCOK     IF SOMETHINGS THERE, CONTINUE
         TM    EXPFLAG,EXPFTERM    SOMETHING EXPECTED?
         BZ    EXPBACK             NO, IGNORE THIS TIME
         B     EXPERR              OTHERWISE ITS NO GOOD
EXPCOK   MVC   ZDBLW(*-*),EXPWORK  <<EXECUTED>>
         MVI   ZDBLW,C' '
         MVC   ZDBLW+1(7),ZDBLW    CLEAR AN AREA
         EX    R15,EXPCOK          MOVE TO IT
*              IF SYMBOL TABLE SCAN REQUESTED, DO SO.
         CLI   EXPOPT,NOSYMB       SCAN SYMBOL TABLE?
         BE    EXPNTAB             NO, GO ON
         TM    EXPFLAG,EXPFDEC     DECIMAL?
         BO    EXPNTAB             THEN CAN'T BE THIS
         L     R14,AIDEFTAB        POINT TO TABLE
EXPIDSCN CLI   0(R14),X'FF'        END OF TABLE?
         BE    EXPNTAB             THEN WE DIDN'T FIND IT
         CLC   DEFSYM(L'DEFSYM,R14),ZDBLW SEE IF THIS IS HIS LABEL
         BE    EXPGLAB             YES, IT IS
         LA    R14,L'IDEFTAB(R14)  NEXT ENTRY IN TABLE
         B     EXPIDSCN            GO ON
EXPGLAB  LH    R15,DEFOFF(R14)     GET VALUE OF IT
         B     EXPUSE              AND USE IT
*              VALIDITY CHECK FOR NUMERICS.
EXPNTAB  LA    R0,1(R15)           GET LENGTH OF THINGY
         LA    R14,EXPWORK         FIND IT
EXPCCHK  CLI   0(R14),C'0'         IF ITS NUMERIC I ALWAYS LIKE IT
         BNL   EXPCGOOD            GO
         TM    EXPFLAG,EXPFDEC     DECIMAL?
         BO    EXPERR              THEN NO GOOD
         CLI   0(R14),C'A'         OTHERWISE NOT LESS THAN A
         BL    EXPERR              GO
         CLI   0(R14),C'F'         OR GREATER THAN F
         BH    EXPERR              GO
         IC    R1,0(R14)           GET IT
         AH    R1,EXPFUDGE         MAKE FA-FF
         STC   R1,0(R14)           REPLACE IT
EXPCGOOD LA    R14,1(R14)          NEXT
         BCT   R0,EXPCCHK          CONTINUE CHECKING
*              CONVERT DECIMAL.
         TM    EXPFLAG,EXPFDEC     DECIMAL?
         BZ    EXPNDEC             NO
         EX    R15,EXPPACK         PACK IT
         CVB   R15,ZDBLW           CONVERT IT
         B     EXPUSE              AND USE IT
EXPPACK  PACK  ZDBLW(8),EXPWORK(0) <<EXECUTED>>
*              CONVERT FOR HEX.
EXPNDEC  LA    R15,1(R15)          DO AN EXTRA CHAR
         EX    R15,EXPPACK         PACK IT
         LM    R14,R15,ZDBLW       GET OFFSET
         SRDL  R14,8               SHIFT OUT BAD BYTE (FLIP)
*              WHEN VALUE OBTAINED, ADD, SUB OR WHATEVER.
EXPUSE   TM    EXPFLAG,EXPFPLUS    ADDING?
         BO    EXPUADD             YES
         TM    EXPFLAG,EXPFMINS    SUBTRACTING?
         BO    EXPUSUB             YES
         TM    EXPFLAG,EXPFMULT    MULTIPLYING?
         BO    EXPUMULT            YES
         TM    EXPFLAG,EXPFDIV     DIVIDING?
         BO    EXPUDIV             YES
         LR    R4,R15              ELSE, OVERLAY
EXPBACK  LA    R5,EXPWORK          START AGAIN
         MVC   EXPFLAG(1),EXPFLAG+1 NEW FLAGS
         MVI   EXPFLAG+1,0         NO MORE
         B     EXPNEXT             SKIP LAST ONE
EXPUADD  AR    R4,R15
         B     EXPBACK             GO ON
EXPUSUB  SR    R4,R15              SUBTRACT
         B     EXPBACK             GO
EXPUMULT LR    R5,R4               GET INTO ODD REGISTER
         MR    R5-1,R15            DO THE MULTIPLY
         LR    R4,R5               GET RESULT IN CORRECT REGISTER
         B     EXPBACK             GO ON
EXPUDIV  LR    R5,R4               GET INTO ODD REGISTER
         XR    R4,R4               CLEAR FOR DIVIDE
         LTR   R15,R15             DIVIDE BY 0?
         BZ    EXPERR              YES, ERROR
         DR    R5-1,R15            DO THE MULTIPLY
         LR    R4,R5               GET RESULT IN CORRECT REGISTER
         B     EXPBACK             GO ON
* - - -  EXP'S DATA.
EXPFUDGE DC    0H'0',XL2'0039'
         SPACE 1
         DROP  R9,R12
         EJECT
*--- C S O U T --- LOG PROCESS --------------------------------------*
*        CSOUT : THIS ROUTINE ALLOCATES A LOG FILE (DATA-SET, IF IT  *
*              IS NEEDED), AND WRITES OUTPUT LINES INTO IT.          *
*              NOTE : THE LINE BUFFER IS CLEARED AFTER EACH CALL.    *
*           INPUT : R1 ===> "CSOUT" WORK-AREA ADDRESS                *
*           THE SELECTION OF THE FUNCTION IS DONE BY THE REGISTER 0  *
*              (ZERO, POSITIVE OR NEGATIVE) :                        *
*           1. R0 ZERO : THE FILE IS ALLOCATED AND OPENED IF NEEDED, *
*                      THEN THE LINE BUFFER IS OUTPUTED.             *
*                   RETURN : R15 = 0 - OK                            *
*                                  4 - ALLOCATION OR OPEN ERROR      *
*                                      (R1 = MESSAGE ADDRESS)        *
*                                  8 - PUT ERROR                     *
*           2. R0 POSITIVE : THE CURRENT FILE BUFFER IS TRUNCATED.   *
*                   RETURN : R15 = 0 - OK (ALWAYS)                   *
*           3. R0 NEGATIVE : THE FILE IS CLOSED AND DE-ALLOCATED.    *
*                   RETURN : R15 = 0 - OK                            *
*                                  4 - DE-ALLOCATION ERROR           *
*                                      (R1 = MESSAGE ADDRESS)        *
*--------------------------------------------------------------------*
         CNOP  0,4
*- - - - MAIN ENTRY, HOUSEKEEPING.
         USING TSDSECT,R9
         USING *,R12
CSOUT    STM   R14,R12,12(R13)     SAVE REGISTERS
         LR    R12,R15             SET BASE REGISTER
         ST    R13,4(R1)           STORE BACKWARD POINTER
         ST    R1,8(R13)           STORE FORWARD POINTER
         LR    R11,R13             PREVIOUS WORK-AREA
         USING SAVE3,R11
         LR    R13,R1              GET WORK-AREA ADDRESS
         USING CSDATA,R13
         LTR   R0,R0               WHAT?
         BP    CSTRUNC             GO TRUNCATE
         BM    CSCLOSE             GO CLOSE
         TM    FLAGSL,LOGALL+LOGOPN IS DATA-SET ALLOCATED AND OPENED?
         BO    CSPUT               IF SO, GO PUT
*- - - - PREPARE FOR LOGGING, CREATE AND OPEN THE DATA-SET.
         L     R2,DYNWORKP         INITIALIZE DYNAMIC ALLOCATION WORK
         LR    R0,R2
         LH    R1,=Y(PARMLLEN)     LENGTH TO BE CLEARED
         LA    R14,*
         XR    R15,R15
         ICM   R15,B'1000',BLANKS
         MVCL  R0,R14              CLEAR TO ALL BLANKS
         USING PARMLIST,R2
         MVC   DDNAME,DDPALL       DDNAME
         MVC   DSNAME(L'ZUSRID),ZUSRID BUILD DS-NAME
         LA    R3,DSNAME+L'ZUSRID-1
         CLI   0(R3),C' '
         BNE   *+L'*+4
         BCT   R3,*-8
         MVC   1(14,R3),=CL14'.ETPS.ZAPLOG.D'
         LA    R3,15(R3)
         LA    R1,VUSWA            -> FORMAT DATE AND TIME WORK-AREA
         XC    0(FDTWAL,R1),0(R1)  CLEAR
         L     R15,ARFDTE          GET CURRENT DATE/TIME
*- - - - ETPSFDTE PARM.LIST : "FDTWA" ADDRESS
        CALL   (15)
         USING FDTWA,R1
         MVC   0(L'FXYY,R3),FXYY   SET YEAR (YY)
         MVC   0+L'FXYY(L'FXDDD,R3),FXDDD SET DAY (DDD)
         MVC   0+L'FXYY+L'FXDDD(2,R3),=CL2'.T'
         LA    R3,2+L'FXYY+L'FXDDD(R3)
         MVC   0(L'FTM,R3),FTM     SET TIME HHMMSS
         MVC   0+L'FTM(5,R3),=CL5'.LIST'
         DROP  R1
         MVC   DSUNIT,=CL8'&ZUNME'
         MVC   DSVOLSER,=CL6'&ZVLSR' VOL-SER
         MVC   DSALLOC,=CL5'&ZSPUN' SPACE UNIT (TRK/CYL)
         MVC   DSPRI,=CL6'&ZPRIQ'  PRIMARY QUANTITY
         MVC   DSSEC,=CL6'&ZSECQ'  SECONDARY QUANTITY
         MVI   DSRECFM1,C'F'       SET RECFM=FBA
         MVI   DSRECFM2,C'B'
         MVI   DSRECFM5,C'A'
         MVC   DSBLKSI,=CL5'3990 ' SET BLKSIZE
         MVC   DSLRECL,=CL5'133 '  SET LRECL
         MVC   DSSTATUS,=CL8'NEW ' SET DISP=(NEW,CATLG,CATLG)
         MVC   DSNDISP,=CL8'CATLG '
         MVC   DSADISP,=CL8'CATLG '
         L     R1,ZLGDSN           PASS BACK "LOG" DS-NAME
         MVC   0(L'DSNAME,R1),DSNAME COPY IT
         L     R1,ZLGVOL           PASS BACK "LOG" VOL-SER
         MVC   0(L'DSVOLSER,R1),DSVOLSER COPY IT
         DROP  R2
         L     R15,ARDYNAM
*- - - - ETPSDYNA PARM.LIST : "DYNWORKP" ADDRESS
        CALL   (15),MF=(E,DYNWORKP)
         LTR   R15,R15             HOW COMPLETE?
         BZ    CSALS               OK
        XMESS  3008                ERROR
         LA    R1,ALFMSG
         B     CSRSB
CSALS    OI    FLAGSL,LOGALL       SAY ALLOCATED
CSALL    XC    CSPGNO(4),CSPGNO    OK, CLEAR PAGE AND LINE
         LA    R0,CSODCB           POINT TO DCB
         ST    R0,CSDBLW           STORE IN DCB LIST
         MVI   CSDBLW,VLB+X'0F'    "VL" & OUTPUT
         MVC   CSODCB(ODCBLEN),ODCBMSK COPY IN MASK
         MVC   CSODCB+DCBDDNAM-IHADCB(L'DCBDDNAM),DDPALL COPY IN DDNAME
        OPEN   MF=(E,CSDBLW)
         TM    CSODCB+DCBOFLGS-IHADCB,DCBOFOPN SEE IF OPEN?
         BO    CSOPN               IF SO, GO PUT
         LA    R1,OLFMSG           ELSE IF NOT, ERROR
CSRSB    L     R15,ZLGDSN          ADDRESS TO PASS BACK "LOG" DS-NAME
         MVC   0(L'DSNAME,R15),BLANKS CLEAR IT
         L     R15,ZLGVOL          ADDRESS TO PASS BACK "LOG" VOL-SER
         MVC   0(L'DSVOLSER,R15),BLANKS CLEAR IT
         B     CSRC4
CSOPN    OI    FLAGSL,LOGOPN       SAY OPENED
*- - - - WRITE OUT A LINE.
CSPUT    LH    R0,CSLNNO           GET LINE NUMBER
         CLI   CSOBUFF,C'1'        SKIP TO PAGE?
         BE    CSPAGE              YES, FORCE PAGE SKIP
         CLI   CSOBUFF,C'0'        DOUBLE SPACE?
         BE    CSSKP2              YES
         CLI   CSOBUFF,C'+'        SUPPRESS SKIP?
         BE    CSSKP0              YES
         CLI   CSOBUFF,C'-'        TRIPLE SPACE?
         BE    CSSKP3              NO, ANYTHING ELSE IS ONE SPACE
         MVI   CSOBUFF,C' '        ELSE FORCE SINGLE
         B     CSSKP1              AND COUNT ONE
CSSKP3   BCTR  R0,0
CSSKP2   BCTR  R0,0
CSSKP1   BCTR  R0,0
CSSKP0   LTR   R0,R0               ANYTHING LEFT ON PAGE?
         BNP   CSPAGE              NO, EJECT
         STH   R0,CSLNNO           SAVE NEW LINE COUNTER
         NI    CSFLAGS,255-CSIOERR TURN OFF FLAG
        PUT    CSODCB,CSOBUFF      PRINT THE LINE NOW
         TM    CSFLAGS,CSIOERR     IO ERROR?
         BZ    CSRCOK              NO
         B     CSRC8
*- - - - PUT OUT A TITLE IF AT TOP OF PAGE.
CSPAGE   MVI   CSOBUFF,C'-'        TRIPLE SPACE FROM TITLE
         MVC   CSLNNO(2),=H'60'    RESET LINE COUNTER
         LH    R1,CSPGNO           GET PAGE COUNTER
         LA    R1,1(R1)            COUNT LAST PAGE
         STH   R1,CSPGNO           SAVE FOR LATER
         CVD   R1,CSDBLW           CONVERT THE PAGE NUMBER
         MVC   CSTBUFF,TMSK        MOVE IN THE MASK
         ED    CSTBUFF+TMSKPGN(L'TMSKPGN),CSDBLW+5 EDIT IT
         MVC   CSTBUFF+TMSKUSR(L'TMSKUSR),ZUSRID PICK UP USER-ID
         LA    R1,VUSWA            -> FORMAT DATE AND TIME WORK-AREA
         XC    0(FDTWAL,R1),0(R1)  CLEAR
         L     R15,ARFDTE          GET CURRENT DATE/TIME
*- - - - ETPSFDTE PARM.LIST : "FDTWA" ADDRESS
        CALL   (15)
         USING FDTWA,R1
         LTR   R15,R15             HOW COMPLETE?
         BNZ   *+L'*+12            ERROR, SKIP
         AIF   ('&TXV' NE 'EUROPE').SK3
         MVC   CSTBUFF+TMSKDAY(L'FXDD),FXDD PICK UP DAY (DD)
         MVC   CSTBUFF+TMSKDAY+3(L'FXMONTH),FXMONTH MONTH (MMM)
         MVC   CSTBUFF+TMSKDAY+7(L'FXYY),FXYY AND YEAR (YY)
         AGO   .SK4
.SK3     MVC   CSTBUFF+TMSKDAY+7(L'FXDD),FXDD PICK UP DAY (DD)
         MVC   CSTBUFF+TMSKDAY+3(L'FXMONTH),FXMONTH MONTH (MMM)
         MVC   CSTBUFF+TMSKDAY(L'FXYY),FXYY AND YEAR (YY)
.SK4     MVC   CSTBUFF+TMSKHOUR(L'FTHH),FTHH SET TIME HH:MM
         MVI   CSTBUFF+TMSKHOUR+L'FTHH,C':'
         MVC   CSTBUFF+TMSKHOUR+L'FTHH+1(L'FTMM),FTMM
         DROP  R1
         NI    CSFLAGS,255-CSIOERR TURN OFF FLAG
        PUT    CSODCB,CSTBUFF      PRINT THE TITLE
         TM    CSFLAGS,CSIOERR     IO ERROR?
         BZ    CSPUT               NO, NOW TRY THAT AGAIN
CSRC8    LA    R15,8               YES, INDICATE IT, RC=8
         B     CSEXIT              LEAVE
*- - - - WRITE OUT A SHORT BLOCK.
CSTRUNC  TM    FLAGSL,LOGOPN       SEE IF OPENED?
         BZ    CSRCOK              IF NOT, GO BACK AS WELL DONE
        TRUNC  CSODCB
         B     CSRCOK              THAT WAS EASY
*- - - - CLOSE AND DE-ALLOCATE THE OUTPUT DATA-SET.
CSCLOSE  TM    FLAGSL,LOGOPN       SEE IF OPENED?
         BZ    CSFREE              IF NOT, GO FREE IT
         LA    R0,CSODCB           FIND DCB
         ST    R0,CSDBLW           SAVE IT
         MVI   CSDBLW,VLB          CLOSE JUST THIS ONE
        CLOSE  MF=(E,CSDBLW)       CLOSE THE DS
         NI    FLAGSL,255-LOGOPN
CSFREE   TM    FLAGSL,LOGALL       SEE IF ALLOCATED?
         BZ    CSRCOK              IF NOT, GO BACK AS WELL DONE
         L     R2,DYNWORKP         INIT. DYNAMIC ALLOC. WORK-AREA
         LR    R0,R2
         LH    R1,=Y(PARMLLEN)     LENGTH TO BE CLEARED
         LA    R14,*
         XR    R15,R15
         ICM   R15,B'1000',BLANKS
         MVCL  R0,R14              CLEAR TO ALL BLANKS
         USING PARMLIST,R2
         MVC   DDNAME,DDPALL       DDNAME
         MVI   DSNAME,0            INDICATE FREE REQUEST
         MVC   DSNAME+1(L'DSNAME-1),DSNAME
         DROP  R2
         NI    FLAGSL,255-LOGALL
         L     R15,ARDYNAM         FREE IT
*- - - - ETPSDYNA PARM.LIST : "DYNWORKP" ADDRESS
        CALL   (15),MF=(E,DYNWORKP)
         LTR   R15,R15             HOW COMPLETE?
         BZ    CSRCOK              OK
        XMESS  3009                ERROR
         LA    R1,FLFMSG
CSRC4    L     R15,4(R13)          GET CALLER SAVE-AREA
         ST    R1,24(R15)          PASS MESSAGE ADDRESS
         LA    R15,4               SET RC=4
         B     CSEXIT
CSRCOK   XR    R15,R15             SAY ALL IS WELL, RC=0
*- - - - WHEN DONE WITH WHATEVER, CLEAR LINE, AND GO BACK.
CSEXIT   MVC   CSOBUFF,BLANKS      CLEAR LINE BEFORE RETURN
         L     R13,4(R13)          GET CALLER SAVE-AREA
         ST    R15,16(R13)         SET RETURN CODE
         LM    R14,R12,12(R13)     RESTORE ALL REGISTERS
         BR    R14                 RETURN TO CALLER
         CNOP  0,8
*------- SYNAD : AN I/O ERROR HAS OCCURED.
OSYNAD   OI    CSFLAGS,CSIOERR     SIGNAL ERROR
         BR    R14                 AND RETURN
         SPACE 1
*- - - - CONSTANTS.
TMSK     DS    0CL133
         DC    CL1'1',CL50'E T P S - ZAP SESSION RECORD'
         DC    CL7'USER : '
TMSKUSR  EQU   *-TMSK,8
         DC    CL22' ',CL7'****** '
TMSKDAY  EQU   *-TMSK,9
         AIF   ('&TXV' NE 'EUROPE').SK5
         DC    CL9'?? ??? YY'
         AGO   .SK6
.SK5     DC    CL9'YY ??? ??'
.SK6     DC    CL5' --- '
TMSKHOUR EQU   *-TMSK,5
         DC    CL18'HH:MM ****** PAGE '
TMSKPGN  EQU   *-TMSK-1,6
         DC    XL5'2020202120',CL9' '
         SPACE 1
ALFMSG   MSG   'ALLOC "LOG" FAILED'
OLFMSG   MSG   'OPEN "LOG" FAILED'
FLFMSG   MSG   'FREE "LOG" FAILED'
ODCBMSK DCB    DSORG=PS,MACRF=PM,DDNAME=XXXXXXXX,SYNAD=OSYNAD,BUFNO=1
ODCBLEN  EQU   *-ODCBMSK
         PRINT &PRS
*- - - - LITERAL POOL.
        LTORG
         SPACE 1
         DROP  R9,R11,R12,R13
         PRINT &PRF
         EJECT
*--- A S M G A S M --- ASSEMBLE OR DISASSEMBLE ----------------------*
*        THE SELECTION OF THE FUNCTION IS DONE BY THE REGISTER 1     *
*              POINTER (NEGATIVE OR NOT).                            *
*--------------------------------------------------------------------*
         CNOP  0,4
         USING *,R12
ASMGASM  STM   R14,R12,12(R13)     SAVE REGISTERS
         LR    R12,R15             SET BASE
         LTR   R1,R1               ASM OR DISASM?
         BM    DISASMIT            GUESS...
*- - - - ASM (ASSEMBLE).
*              INPUT : R1 = POINTER TO CL4'MNEMONIC'
*              OUTPUT : R1 = VALID HEX-OPCODE ADDRESS (IF R15=0) OR
*                            ZERO IF NON-VALID OPCODE.
*                       R15 = 0 - OK / 4 - ERROR
         L     R2,=A(OPCODES)      TABLE
         L     R15,=A(OPEND)       END BXLE
         LA    R14,L'OPCODES       LENGTH
OPLOOP   CLC   0(4,R1),0(R2)       THIS ONE (KLUGE)
         BE    GOTOP               YES
         BXLE  R2,R14,OPLOOP       TRY ALL POSSIBLES
BADRET   LA    R15,4               INVALID OP CODE
         XR    R1,R1               NULLIFY POINTER
         B     ASMXRET             BYE
GOTOP    LA    R1,5(,R2)           POINT TO OP IN HEX
GOODRET  XR    R15,R15             RC=0
ASMXRET  L     R14,12(,R13)        RESTORE R14 (NOTE R0 NOT)
         LM    R2,R12,20+R2*4(R13) RESTORE REGISTERS
         BR    R14                 BYE
*- - - - DISASM (DISASSEMBLE).
*              INPUT : R0 = POINTER TO OUTPUT BUFFER (33 BYTES)
*                      R1 = POINTER TO BUFFER LOC OF OBJECT CODE
*                      R2 = POINTER TO 5 DOUBLE-WORDS WORK-AREA
*              OUTPUT : R1 = LENGTH OF INSTRUCTION (IF R15=0) OR ZERO
*                            IF NON-VALID OPCODE. FILLED IN SCREEN
*                            BUFFER IF OPCODE WAS VALID.
*                       R15 = 0 - OK / 4 - ERROR
*              NOTE : WE GO THROUGH SOME CONTORTIONS IN ORDER TO BE
*                     ABLE TO SPECIFY THE OPCODE FLAG FIELDS IN
*                     EBCDIC CHARACTER FORM (IMAGE-ENTERABLE).
DISASMIT LPR   R1,R1               GET POS 1ST
         LR    R7,R2               SAVE WORK-BASE
         LR    R9,R0               SAVE OUTPUT BUFFER POINTER
         USING JCJWORK,R7
         MVC   JCJDW2(8),0(R1)     ALIGN POSSIBLE INSTRUCTION
         LA    R6,JCJDW2           POINT TO INSTR
         XR    R15,R15             READY FOR IC
         XR    R2,R2               CLEAR TRT REGISTER
         TRT   0(1,R6),OPTAB       TRANSLATE THE OPCODE
         BZ    BADRET              BRANCH IF NON-VALID OPCODE
         LA    R4,1                GET F'1' FOR LATER
         SLR   R2,R4               FIX FOR PROPER TABLE INDEX
         MH    R2,=Y(L'OPCODES)    GET OFFSET INTO TABLE
         L     R1,=A(OPCODES)      TABLE
         AR    R1,R2               POINT TO PROPER MNENOMIC
         MVC   0(4,R9),0(R1)       MOVE IN MNENOMIC
         MVC   JCJFLAGS(1),4(R1)   GET THE FLAG BYTE
         IC    R15,1(,R6)          GET THE REGISTER BYTE
         LR    R2,R15              GET IT IN R2 FOR LATER
*              NOW CHECK IF IT IS AN EXTENDED MNENOMIC INSTRUCTION.
         TM    JCJFLAGS,X'04'      EXTENDED MNENOMIC FLAG ON?
         BZ    GETTYPE             NO, GO ON WITH THE REST
         TM    JCJFLAGS,X'02'      INDEX REGISTER FLAG ON?
         BZ    GETMNE              NO, GO GET THE MMENOMIC
*              GETMNE RETURNS TO GETINST - WE DON'T CARE IF WE GO
*              THROUGH THIS CODE FOR NON-MNENOMICS THOUGH.
GETINST  CLI   1(R9),C'C'          GOT AN EXTENDED MNENOMIC?
         BNE   GETTYPE             YES, SKIP THE BIT RESET
         OI    JCJFLAGS,X'02'      NO, FAKE OUT A RR(OR RX) TYPE
GETTYPE  L     R14,=A(OPCODES)
         CLC   0(4,R9),0(R14)      IS IT SPM?
         LA    R9,7(,R9)           INCREMENT LINE PNTR
         BNE   GETTYPE#            NO, SKIP FLAG RESET/BRANCH
         MVI   JCJFLAGS,C'<'       RESET FLAG FOR LATER TEST
         B     GETRR#              AND GO PROCESS SPM
GETTYPE# TM    JCJFLAGS,X'90'      IS LENGTH FOUR BYTES?
         BZ    GETRR               NO, GET 2 BYTE INSTRUCTION
         BM    GETSS               NO, GET 6 BYTE INSTRUCTION
*              HAVE AN FOUR BYTE TYPE WHEN WE FALL THROUGH TO HERE.
         CLI   JCJFLAGS,C'M'       (GETRX) DO WE WANT A REGISTER?
         BNH   RXDISP              NO, GO GET DISP FIELD
         LR    R2,R15              GET REGISTER BYTE BACK
         SRDL  R2,4                SHIFT TO GET FIRST REGISTER
         BAL   R14,GETNUM          PUT CHAR VALUE IN SCREEN
         BAL   R14,COMMA           PUT IN A COMMA
         CLI   JCJFLAGS,C'R'       TWO REGISTERS NEEDED?
         BNE   RXDISP              NO, GET DISPLACEMENT
         SLDL  R2,4                GET THE OTHER REGISTER
         BAL   R14,GETNUM          AND PUT IT IN SCREEN
         BAL   R14,COMMA           MOVE IN A COMMA
RXDISP   BAL   R5,GETDISP          GET THE DISP FIELD
         TM    JCJFLAGS,X'04'      NEED AN INDEX REG?
         BZ    RXNOIND             NO, GET THE BASE ONLY
         SLDL  R2,4                AND PICK UP THE INDEX REGISTER
         BAL   R14,GETNUM          PUT IT IN SCREEN
         BAL   R14,COMMA           MOVE IN A COMMA
RXNOIND  BAL   R5,GETBASE          GET THE BASE BYTE
         CLI   JCJFLAGS,C'L'       IMMEDIATE TYPE?
         BNE   DISLEAVE            NO, LEAVE
*              WE HAVE AN SI TYPE HERE.
         MVC   0(3,R9),SICHAR      MOVE IN ,X'
        @HEX   (3,R9),(1,R6),LEN=1,HEXTAB=HXTB,BYTE=C''''
         B     DISLEAVE            AND LEAVE
*              TWO BYTE INSTRUCTIONS.
GETRR    LR    R2,R15              GET REGISTER BYTE BACK
         CLI   JCJFLAGS,C'+'       SVC?
         BE    RRSVC               YES, GO PROCESS IT
         BL    MNENT               EXTENDED MNENOMIC HERE
GETRR#   SRDL  R2,4                GET FIRST REGISTER VALUE
         BAL   R14,GETNUM          MOVE IN THE CHAR VALUE
         CLI   JCJFLAGS,C'<'       SPM INST?
         BE    DISLEAVE            YES, LEAVE
         BAL   R14,COMMA           MOVE IN A COMMA
MNENT    XR    R2,R2               ZERO PARM REGISTER
         SLDL  R2,4                GET OTHER REGISTER
RRSVC    BAL   R14,GETNUM          MOVE IN THE CHAR AGAIN
         B     DISLEAVE            GO AWAY
*              THIS SECTION HANDLES 6 BYTE INSTRUCTIONS.
GETSS    LR    R0,R2               SAVE THE REGISTER BYTE (LENGTH)
         BAL   R5,GETDISP          GEN FIRST DISPLACEMENT
         LR    R2,R0               GET THE REGISTER BYTE BACK
         TM    JCJFLAGS,X'01'      ONLY ONE LENGTH FIELD?
         BO    *+L'*+4             YES, SKIP THE REGISTER SHIFT
         SRDL  R2,4                GET THE FIRST LENGTH FIELD
         BAL   R14,GETNUMI         MOVE IN THE CHAR VALUE
         BAL   R14,COMMA           MOVE IN A COMMA
         BAL   R5,GETBASE          GET THE BASE FIELD
         BAL   R14,COMMA           MOVE IN A COMMA
         LH    R2,4(,R6)           GET SECOND DISP FIELD
         BAL   R5,GETDISP#         MOVE IT TO THE SCREEN
         TM    JCJFLAGS,X'01'      SINGLE LENGTH?
         BO    SSL1                YES, SKIP 2ND LENGTH PROCESSING
         SLDL  R2,4                GET 2ND LENGTH
         BAL   R14,GETNUMI         AND MOVE IT TO SCREEN
         BAL   R14,COMMA           A DELIMITER OR TWO
SSL1     IC    R2,4(,R6)           GET SECOND BASE FIELD
         BAL   R5,GETBASE#         GET THE BASE IN SCREEN
DISLEAVE TM    JCJFLAGS,X'10'      DO WE HAVE A BAD LENGTH?
         BZ    *+L'*+4             NO, HOP OVER THE BIT RESET
         NI    JCJFLAGS,255-X'40'  FIX FOR CORRECT LENGTH
         XR    R1,R1               SET UP FOR IC
         IC    R1,JCJFLAGS         GET THE LENGTH
         SRL   R1,5                WIPE OUT FLAG BITS  = LENGTH
         B     GOODRET             EXIT OK
*              EXTENDED MNENOMIC ROUTINE.
GETMNE   SRDL  R2,4                SHIFT TO CLEAR OUT REGISTER NIBBLE
         MH    R2,=Y(L'MNEOPS)     INDEX INTO TABLE
         L     R1,=A(MNEOPS)       TABLE
         AR    R1,R2               PNT TO TABLE ENTRY
         MVC   0(3,R9),0(R1)       MOVE IN PRIMARY MNEMONIC
         CLI   3(R1),C' '          SECONDARY MNENOMIC PRESENT?
         BE    GETMNE#             NO, CONTINUE ON
         MVC   5(3,R9),3(R1)       GET SECONDARY ONE
         LR    R14,R9              SAVE CURR BUFFER PNTR
         AH    R9,=Y(L'MNEOPS)     AND UP WORK BUFFER PNTR
GETMNE#  TM    JCJFLAGS,X'80'      NON 2 BYTE INSTRUCTION?
         BO    GETINST             YES, LEAVE
         CLI   3(R1),C' '          TWO MNENOMICS NEEDED?
         BE    ONEMNE              NO, SO DO ONE DUMMY...
         BAL   R5,RLOOP            PUT IN A 'R' (RR TYPE)
ONEMNE   LR    R14,R9              PNT TO CURR MNEMONIC
         LA    R5,GETINST          FAKE OUT A BAL AND RETURN
RLOOP    ALR   R14,R4              PNT TO NEXT CHAR
         CLI   0(R14),C' '         A BLANK WAITING FOR 'R'?
         BNE   RLOOP               NO, INCREMENT
         MVI   0(R14),C'R'         YES, PUT IN THE 'R'
         BR    R5                  AND GO HOME
         SPACE 1
*- - - - DISASSEMBLER ROUTINES (USED TO SAVE BYTES HERE AND THERE).
*              THIS ROUTINE GETS THE BASE REGISTER.
*              R5 = LINK REGISTER.
GETBASE  IC    R2,2(,R6)           GET THE BASE
GETBASE# SRL   R2,4                SHIFT OUT GARBAGE
         BAL   R14,GETNUM          GO MOVE TO SCREEN
         MVI   0(R9),C')'          PUT IN A R-PAREN
         ALR   R9,R4               INCREMENT LINE PNTR
         BR    R5                  GO TO CALLER
*              THIS ROUTINE GETS THE DISPLACEMENT FIELD.
*              R5 = LINK REGISTER.
GETDISP  LH    R2,2(,R6)           LOAD THE DISPLACEMENT
GETDISP# N     R2,DISPMASK         WIPE OUT BASE BITS
         BAL   R14,GETNUM          DO THE MOVE TO SCREEN
         CLI   JCJFLAGS,C'J'       IS IT SVCX OR DIAGNOSE?
         BE    DISLEAVE            YES, GO AWAY
         MVI   0(R9),C'('          ELSE MOVE IN A L-PAREN
         ALR   R9,R4               INCREMENT LINE PNTR
         BR    R5                  GO TO CALLER
*              THIS ROUTINE SETS A COMMA.
*              R14 = LINK REGISTER.
COMMA    MVI   0(R9),C','          MOVE IN A COMMA
         ALR   R9,R4               INCREMENT PNTR
         BR    R14                 GO TO CALLER
*              THIS ROUTINE PUTS THE CHAR VALUE OF THE CONTENTS OF
*              R2 INTO THE SCREEN (VIA R9) AND UPDATES R9 (POINT TO
*              THE NEXT AVAILABLE POSITION).
*              R14 = LINK REGISTER.
GETNUMI  ALR   R2,R4               INCREMENT FOR A LENGTH FIX
GETNUM   CVD   R2,JCJDW1           GET IT IN DECIMAL
         MVC   JCJEDIT,EDITMASK    SET UP FOR EDIT
         LA    R15,JCJEDIT+L'JCJEDIT-1 PNT TO END OF AREA
         LR    R1,R15              SET UP R1 FOR EDMK
         EDMK  JCJEDIT,JCJDW1+5    DO THE EDIT
         SR    R15,R1              GET THE EXECUTE LENGTH
         EX    R15,NUMMOVE         MOVE THE VALUE TO THE SCREEN
         LA    R9,1(R15,R9)        UPDATE THE SCREEN PNTR
         XR    R2,R2               ZERO OUR WORK REGISTER
         BR    R14                 GO HOME
NUMMOVE  MVC   0(*-*,R9),0(R1)     <<EXECUTED>>
         SPACE 1
*- - - - CONSTANTS.
DISPMASK DC    0F'0',XL4'00000FFF'
EDITMASK DC    XL6'402020202120'
SICHAR   DC    CL3',X'''
         DC    CL16'0123456789ABCDEF'
HXTB     EQU   *-256
         PRINT &PRS
*- - - - LITERAL POOL.
        LTORG
         SPACE 1
         DROP  R7,R12
*------- E X T E N D E D   M N E N O M I C   T A B L E --------------*
MNEOPS   DC    CL6'NOP   '
         DC    CL6'BO    '
         DC    CL6'BH BP '
         DC    CL6'BC    '
         DC    CL6'BL BM '
         DC    CL6'BC    '
         DC    CL6'BC    '
         DC    CL6'BNEBNZ'
         DC    CL6'BE BZ '
         DC    CL6'BC    '
         DC    CL6'BC    '
         DC    CL6'BNLBNM'
         DC    CL6'BC    '
         DC    CL6'BNHBNP'
         DC    CL6'BNO   '
         DC    CL6'B     '
         SPACE 1
*------- O P C O D E   T R A N S L A T E   T A B L E ----------------*
OPTAB    DC    AL1(@00,@00,@00,@00,@04,@05,@06,@07)
         DC    AL1(@08,@09,@0A,@0B,@00,@0D,@0E,@0F)
         DC    AL1(@10,@11,@12,@13,@14,@15,@16,@17)
         DC    AL1(@18,@19,@1A,@1B,@1C,@1D,@1E,@1F)
         DC    AL1(@20,@21,@22,@23,@24,@25,@26,@27)
         DC    AL1(@28,@29,@2A,@2B,@2C,@2D,@2E,@2F)
         DC    AL1(@30,@31,@32,@33,@34,@35,@36,@37)
         DC    AL1(@38,@39,@3A,@3B,@3C,@3D,@3E,@3F)
         DC    AL1(@40,@41,@42,@43,@44,@45,@46,@47)
         DC    AL1(@48,@49,@4A,@4B,@4C,@4D,@4E,@4F)
         DC    AL1(@50,@51,@00,@00,@54,@55,@56,@57)
         DC    AL1(@58,@59,@5A,@5B,@5C,@5D,@5E,@5F)
         DC    AL1(@60,@00,@00,@00,@00,@00,@00,@67)
         DC    AL1(@68,@69,@6A,@6B,@6C,@6D,@6E,@6F)
         DC    AL1(@70,@00,@00,@00,@00,@00,@00,@00)
         DC    AL1(@78,@79,@7A,@7B,@7C,@7D,@7E,@7F)
         DC    AL1(@80,@00,@82,@83,@84,@85,@86,@87)
         DC    AL1(@88,@89,@8A,@8B,@8C,@8D,@8E,@8F)
         DC    AL1(@90,@91,@92,@93,@94,@95,@96,@97)
         DC    AL1(@98,@00,@00,@00,@9C,@9D,@9E,@9F)
         DC    AL1(@00,@00,@00,@00,@00,@00,@00,@00)
         DC    AL1(@00,@00,@00,@00,@AC,@AD,@AE,@AF)
         DC    AL1(@00,@B1,@B2,@00,@00,@00,@B6,@B7)
         DC    AL1(@00,@00,@BA,@BB,@00,@BD,@BE,@BF)
         DC    AL1(@00,@00,@00,@00,@00,@00,@00,@00)
         DC    AL1(@00,@00,@00,@00,@00,@00,@00,@00)
         DC    AL1(@00,@D1,@D2,@D3,@D4,@D5,@D6,@D7)
         DC    AL1(@00,@00,@00,@00,@DC,@DD,@DE,@DF)
         DC    AL1(@00,@00,@00,@00,@00,@00,@00,@00)
         DC    AL1(@00,@00,@00,@00,@00,@00,@00,@00)
         DC    AL1(@F0,@F1,@F2,@F3,@00,@00,@00,@00)
         DC    AL1(@F8,@F9,@FA,@FB,@FC,@FD,@00,@00)
         SPACE 1
*------- O P C O D E   T A B L E ------------------------------------*
* TABLE FORMAT : CL4'MNEMONIC',CL1'FLAG',XL1'OPCODE'
*      RR TYPE : C'(',X'4D' - EXTENDED MNEMONIC
*                C'+',X'4E' - SVC       IMED
*                C'|',X'4F' - NORMAL RR TYPE
*                C'&',X'50' - SPM TYPE
*      RX TYPE : C'O',X'D6' - INDEX REGISTER USED   R1,D2(X2,B2)
*                C'M',X'D4' - EXTENDED MNENOMIC     D2(X2,B2)
*                C'L',X'D3' - SI TYPE               D1(B1),I2
*                C'J',X'D1' - DIAGNOSE,SVCX   IMED  I
*                C'K',X'D2' - DISP(BASE) TYPE       D1(B1)
*                C'R',X'D9' - BXLE,BXH,STM,LM       R1,R3,D2(B2)
*                C'Q',X'D8' - REGISTER SHIFT TYPE   R1,D2(B2)
*      SS TYPE : C'S',X'E2' - TWO LENGTHS REQUIRED
*                C'T',X'E3' - ONLY ONE LENGTH
         PRINT &PRF
OPCODES  DS    0XL6
@00      EQU   0                   FOR UNDEFINED OPCODES
        @OP    SPM,|,04
        @OP    BALR,|,05
        @OP    BCTR,|,06
        @OP    BCR,'(',07
        @OP    SSK,|,08
        @OP    ISK,|,09
        @OP    SVC,+,0A
        @OP    BSM,|,0B
        @OP    BASR,|,0D
        @OP    MVCL,|,0E
        @OP    CLCL,|,0F
        @OP    LPR,|,10
        @OP    LNR,|,11
        @OP    LTR,|,12
        @OP    LCR,|,13
        @OP    NR,|,14
        @OP    CLR,|,15
        @OP    OR,|,16
        @OP    XR,|,17
        @OP    LR,|,18
        @OP    CR,|,19
        @OP    AR,|,1A
        @OP    SR,|,1B
        @OP    MR,|,1C
        @OP    DR,|,1D
        @OP    ALR,|,1E
        @OP    SLR,|,1F
        @OP    LPDR,|,20
        @OP    LNDR,|,21
        @OP    LTDR,|,22
        @OP    LCDR,|,23
        @OP    HDR,|,24
        @OP    LRDR,|,25
        @OP    MXR,|,26
        @OP    MXDR,|,27
        @OP    LDR,|,28
        @OP    CDR,|,29
        @OP    ADR,|,2A
        @OP    SDR,|,2B
        @OP    MDR,|,2C
        @OP    DDR,|,2D
        @OP    AWR,|,2E
        @OP    SWR,|,2F
        @OP    LPER,|,30
        @OP    LNER,|,31
        @OP    LTER,|,32
        @OP    LCER,|,33
        @OP    HER,|,34
        @OP    LRER,|,35
        @OP    AXR,|,36
        @OP    SXR,|,37
        @OP    LER,|,38
        @OP    CER,|,39
        @OP    AER,|,3A
        @OP    SER,|,3B
        @OP    MER,|,3C
        @OP    DER,|,3D
        @OP    AUR,|,3E
        @OP    SUR,|,3F
        @OP    STH,O,40
        @OP    LA,O,41
        @OP    STC,O,42
        @OP    IC,O,43
        @OP    EX,O,44
        @OP    BAL,O,45
        @OP    BCT,O,46
        @OP    BC,M,47
        @OP    LH,O,48
        @OP    CH,O,49
        @OP    AH,O,4A
        @OP    SH,O,4B
        @OP    MH,O,4C
        @OP    BAS,O,4D
        @OP    CVD,O,4E
        @OP    CVB,O,4F
        @OP    ST,O,50
        @OP    SVCX,J,51
        @OP    N,O,54
        @OP    CL,O,55
        @OP    O,O,56
        @OP    X,O,57
        @OP    L,O,58
        @OP    C,O,59
        @OP    A,O,5A
        @OP    S,O,5B
        @OP    M,O,5C
        @OP    D,O,5D
        @OP    AL,O,5E
        @OP    SL,O,5F
        @OP    STD,O,60
        @OP    MXD,O,67
        @OP    LD,O,68
        @OP    CD,O,69
        @OP    AD,O,6A
        @OP    SD,O,6B
        @OP    MD,O,6C
        @OP    DD,O,6D
        @OP    AW,O,6E
        @OP    SW,O,6F
        @OP    STE,O,70
        @OP    LE,O,78
        @OP    CE,O,79
        @OP    AE,O,7A
        @OP    SE,O,7B
        @OP    ME,O,7C
        @OP    DE,O,7D
        @OP    AU,O,7E
        @OP    SU,O,7F
        @OP    SSM,K,80
        @OP    LPSW,K,82
        @OP    DIAG,J,83
        @OP    WRD,L,84
        @OP    RDD,L,85
        @OP    BXH,R,86
        @OP    BXLE,R,87
        @OP    SRL,Q,88
        @OP    SLL,Q,89
        @OP    SRA,Q,8A
        @OP    SLA,Q,8B
        @OP    SRDL,Q,8C
        @OP    SLDL,Q,8D
        @OP    SRDA,Q,8E
        @OP    SLDA,Q,8F
        @OP    STM,R,90
        @OP    TM,L,91
        @OP    MVI,L,92
        @OP    TS,K,93
        @OP    NI,L,94
        @OP    CLI,L,95
        @OP    OI,L,96
        @OP    XI,L,97
        @OP    LM,R,98
        @OP    SIO,K,9C
        @OP    TIO,K,9D
        @OP    HIO,K,9E
        @OP    TCH,K,9F
        @OP    STNSM,L,AC
        @OP    STOSM,L,AD
        @OP    SIGP,R,AE
        @OP    MC,L,AF
        @OP    LRA,O,B1
        @OP    S370,K,B2
        @OP    STCTL,R,B6
        @OP    LCTL,R,B7
        @OP    CS,R,BA
        @OP    CDS,R,BB
        @OP    CLM,R,BD
        @OP    STCM,R,BE
        @OP    ICM,R,BF
        @OP    MVN,C,D1
        @OP    MVC,C,D2
        @OP    MVZ,C,D3
        @OP    NC,C,D4
        @OP    CLC,C,D5
        @OP    OC,C,D6
        @OP    XC,C,D7
        @OP    TR,C,DC
        @OP    TRT,C,DD
        @OP    ED,C,DE
        @OP    EDMK,C,DF
        @OP    SRP,S,F0
        @OP    MVO,B,F1
        @OP    PACK,B,F2
        @OP    UNPK,B,F3
        @OP    ZAP,B,F8
        @OP    CP,B,F9
        @OP    AP,B,FA
        @OP    SP,B,FB
        @OP    MP,B,FC
        @OP    DP,B,FD
OPEND    EQU   *-L'OPCODES
         EJECT
*------- ZAP HELP PANELS --------------------------------------------*
         PRINT &PRF
ZAPHELP  DC    A(ZAPHP1)
         DC    A(ZAPHP2)
         DC    A(ZAPHP3)
         DC    A(ZAPHP4)
         DC    A(ZAPHP5)
         DC    A(ZAPHP6)
         DC    A(ZAPHP7)
         DC    A(ZAPHP8)
         DC    A(ZAPHP9)
         DC    A(ZAPHP10)
         DC    A(ZAPHP11)
         DC    A(ZAPHP12)
NUMHLP   EQU   (*-ZAPHELP)/L'ZAPHELP    NUMBER OF HELP PANELS
LENHLL   EQU   60        MAX. LENGTH OF A HELP LINE (AS IN @IML MACRO)
ZAPHP1   EQU   * - - - - - - - - - - - - - - - - - - - - - IMAGE # 1
*        ----+----1----+----2----+----3----+----4----+----5----+----6
  @IML  'CONTENTS :  ?1 - THIS SCREEN'
  @IML  '            ?2 - GENERAL INFORMATION'
  @IML  '            ?3 - INPUT/OUTPUT COMMANDS'
  @IML  '            ?4 - INPUT/OUTPUT COMMANDS (CONTINUED)'
  @IML  '            ?5 - SESSION CONTROL COMMANDS'
  @IML  '            ?6 - DUMP COMMANDS'
  @IML  '            ?7 - BYTE COMMANDS'
  @IML  '            ?8 - STRING COMMANDS'
  @IML  '            ?9 - MISCELLANEOUS COMMANDS'
  @IML  '           ?10 - MISCELLANEOUS COMMANDS (CONTINUED)'
  @IML  '           ?11 - EXPLANATION OF SYMBOLS'
  @IML  '           ?12 - SAMPLE ZAP SESSION'
  @IML  END
ZAPHP2   EQU   * - - - - - - - - - - - - - - - - - - - - - IMAGE # 2
  @IML  '                     GENERAL INFORMATION'
  @IML  '-- THE OPERANDS ARE ENTERED AFTER THE COMMAND, WITH NO'
  @IML  '   INTERVENING BLANKS.'
  @IML  '-- THE BLOCK IS READ INTO A WORK BUFFER, WHERE YOU MODIFY'
  @IML  '   IT. WHEN YOU ENTER A "ZAP" COMMAND, THE BLOCK IS WRITTEN'
  @IML  '   BACK TO THE DATA-SET FROM THE BUFFER. IF ANY OTHER JOB'
  @IML  '   OR USER HAS UPDATED THAT BLOCK IN BETWEEN WHEN YOU FIRST'
  @IML  '   DISPLAYED IT AND WHEN YOU "ZAPPED" IT, THE OTHER CHANGES'
  @IML  '   WILL BE LOST.'
  @IML  '-- IF YOU MAKE CHANGES TO A BLOCK, TO GO TO ANOTHER BLOCK'
  @IML  '   YOU MUST EITHER "ZAP" THE BLOCK (RE-WRITE IT TO THE'
  @IML  '   DATA-SET), OR ENTER THE COMMAND TWICE IN A ROW WHICH WILL'
  @IML  '   CAUSE YOU TO LEAVE TO CURRENT MODIFIED BLOCK.'
  @IML  END
ZAPHP3   EQU   * - - - - - - - - - - - - - - - - - - - - - IMAGE # 3
  @IML  '                   INPUT/OUTPUT COMMANDS'
  @IML  ''
  @IML  'P<EXP>      - POINT TO RECORD WHOSE TTR=EXP'
  @IML  'P           - POINT TO BEGINNING OF DATA-SET'
  @IML  'T<EXP>      - POINT TO TRACK <EXP>, RECORD 1'
  @IML  'T           - POINT TO NEXT TRACK, RECORD 1'
  @IML  'R<EXP>      - SHOW BLOCK <EXP> RELATIVE TO CURRENT'
  @IML  'R           - POINT TO NEXT PHYSICAL RECORD'
  @IML  'B           - POINT TO PREVIOUS RECORD'
  @IML  'LAST        - POINT TO LAST RECORD (DS1LSTAR)'
  @IML  'LASTDS1     - POINT TO LAST FORMAT 1 IN VTOC'
  @IML  END
ZAPHP4   EQU   * - - - - - - - - - - - - - - - - - - - - - IMAGE # 4
  @IML  '             INPUT/OUTPUT COMMANDS (CONTINUED)'
  @IML  ''
  @IML  'ABS<EXP>    - POINT TO REC. WITH CCHHR=EXP'
  @IML  '%<EXP>      - POINT TO TTR @ LOC <EXP> IN BLOCK'
  @IML  'M<NAME>     - FOR PDS, POINT TO MEMBER <NAME>'
  @IML  'M           - POINT TO START OF THE CURRENT MEMBER'
  @IML  'NAME<N>     - AFTER "M", SHOW ENTRY POINT <N>'
  @IML  'NAME        - SELECT ENTRY POINT NAMED MEMBER'
  @IML  'E<N>        - SAME AS NAME<N>'
  @IML  'E           - SAME AS NAME'
  @IML  'ZAP         - REPLACE BLOCK FROM THE CURRENT BUFFER'
  @IML  END
ZAPHP5   EQU   * - - - - - - - - - - - - - - - - - - - - - IMAGE # 5
  @IML  '                  SESSION CONTROL COMMANDS'
  @IML  ''
  @IML  'LOG         - START LOGGING THIS SESSION'
  @IML  'NOTE<COMNT> - WRITE A COMMENT <COMNT> INTO LOG FILE'
  @IML  'EJECT       - EJECT A PAGE IN THE LOG FILE'
  @IML  'W           - SET WINDOW SINGLE LINE DOWN/UP'
  @IML  'WFULL       - SET WINDOW DEFAULTS DOWN/UP SIZES'
  @IML  'W<D>,<U>    - SET WINDOW DOWN/UP SIZE(S)'
  @IML  'END         - TERMINATE, NORMAL EXIT OF ZAP / PFK 3-15'
  @IML  'CAN/CANCEL  - CANCEL, IMMEDIATE EXIT OF ZAP / PA1 KEY'
  @IML  END
ZAPHP6   EQU   * - - - - - - - - - - - - - - - - - - - - - IMAGE # 6
  @IML  '                       DUMP COMMANDS'
  @IML  ''
  @IML  'DUMP        - DUMP ALL RECORDS IN THE DATA-SET IN ABDUMP'
  @IML  '              FORMAT'
  @IML  'DUMPT<EXP>  - DUMP TO TTR <EXP> FROM CURRENT RECORD'
  @IML  'DUMPT       - DUMP CURRENT RECORD ONLY'
  @IML  'DUMPF<EXP>  - DUMP FOR <EXP> RECORDS FROM CURRENT RECORD'
  @IML  'DUMPF       - DUMP CURRENT RECORD'
  @IML  'DUMPE       - DUMP CURRENT RECORD TO EOF'
  @IML  ''
  @IML  '-- ON ANY EOF, I/O ERROR OR END-OF-DS : HALT DUMP '
  @IML  END
ZAPHP7   EQU   * - - - - - - - - - - - - - - - - - - - - - IMAGE # 7
  @IML  '                       BYTE COMMANDS'
  @IML  ''
  @IML  'D<EXP>      - DISPLAY BYTE AT OFFSET <EXP>'
  @IML  '<EXP>       - SAME AS D<EXP>'
  @IML  'D           - PAGE TO NEXT SCREEN (D+#SCREEN) / PFK 8-20'
  @IML  'U           - PAGE TO PREV SCREEN (D-#SCREEN) / PFK 7-19'
  @IML  '>           - GO FORWARD IN TRACE TABLE'
  @IML  '<           - GO BACKWARD IN TRACE TABLE'
  @IML  'EBCDIC      - EBCDIC TRANSLATION (DEFAULT)'
  @IML  'ASCII       - ASCII-8 TRANSLATION'
  @IML  'ZCODE       - ZCODE TRANSLATION'
  @IML  '=<LAB>      - DEFINE <LAB> TO CURRENT LOC'
  @IML  'NODEF       - CLEAR ALL DEFINED LABELS FROM ='
  @IML  END
ZAPHP8   EQU   * - - - - - - - - - - - - - - - - - - - - - IMAGE # 8
  @IML  '                      STRING COMMANDS'
  @IML  ''
  @IML  'S<STR>      - STORE <STR> AT CURRENT LOC'
  @IML  'X<STR>      - EXCLUSIVE OR AT CURRENT LOC'
  @IML  'O<STR>      - OR AT CURRENT LOC'
  @IML  'N<STR>      - AND AT CURRENT LOC'
  @IML  'SET<STR>    - SET ENTIRE RECORD TO <STR>'
  @IML  'L<STR>      - LOOK FOR <STR> FROM NEXT BYTE'
  @IML  'L           - CONTINUE LOOKING FOR <STR> / PFK 5-17'
  @IML  'F<STR>      - LIKE L<STR>, CONT''S PAST EOFS'
  @IML  'F           - LIKE L, CONTINUES PAST EOFS'
  @IML  ''
  @IML  '-- S,X,O,N,SET MAY BE ENTERED ALONE TO USE PREVIOUS <STR>'
  @IML  END
ZAPHP9   EQU   * - - - - - - - - - - - - - - - - - - - - - IMAGE # 9
  @IML  '                   MISCELLANEOUS COMMANDS'
  @IML  ''
  @IML  '#<EXP>      - FIND HEX/DECIMAL VALUE OF <EXP>'
  @IML  'FLOAT<F>    - FIND FLOATING POINT VALUE OF <F>'
  @IML  'IDEF        - DISPLAY DEFINE LABEL TABLE'
  @IML  'ITRACE      - DISPLAY TRACE TABLE'
  @IML  '?N          - VIEW NTH HELP DISPLAY (1-12)'
  @IML  'WHERE       - GIVE CURRENT LOCATION ETC...'
  @IML  'ASM<OP>     - GIVE OBJECT CODE FOR MNEMONIC'
  @IML  'DISASM<EXP> - DISASSEMBLE INSTRUCTION AT <EXP>'
  @IML  'CAPSON      - FOR STRING COMMANDS'
  @IML  'CAPSOFF     - FOR STRING COMMANDS'
  @IML  END
ZAPHP10  EQU   * - - - - - - - - - - - - - - - - - - - - - IMAGE # 10
  @IML  '             MISCELLANEOUS COMMANDS (CONTINUED)'
  @IML  ''
  @IML  'WHATMEM     - FIND DIRECTORY ENTRY CLOSEST TO CURRENT RECORD'
  @IML  'WM          - SAME AS WHATMEM              '
  @IML  'V<EXP>      - ADD CONTENTS OF 2 BYTES AT <EXP> TO CURRENT'
  @IML  '              VALUE OF LOC'
  @IML  'BASE<EXP>   - ADD <EXP> TO BUFFER OFFSET WHEN COMPUTING'
  @IML  '              ADDRESS'
  @IML  'DISP<TYPE>  - SET RECORD DISPLAY START POSITION, <TYPE> IS'
  @IML  '              IS COUNT-KEY-DATA'
  @IML  'J<TTR>      - REL. TO BEGINING OF VOLUME'
  @IML  END
ZAPHP11  EQU   * - - - - - - - - - - - - - - - - - - - - - IMAGE # 11
  @IML  '                   EXPLANATION OF SYMBOLS'
  @IML  ''
  @IML  '<EXP> IS COMPOSED OF OPERATORS (+,-,*,/), DEFINE SYMBOLS'
  @IML  '    (''='' COMMAND) AND HEX OR DEC CONSTANTS.'
  @IML  '    THE FOLLOWING SYMBOLS ARE PREDEFINED :'
  @IML  '    * = CURRENT OFFSET       L = LOGICAL RECORD LENGTH'
  @IML  '    K = KEY LENGTH           BL = MAX. BLKSIZE'
  @IML  '<STR> MAY BE EITHER UP TO 16 CHARACTERS ENCLOSED IN ANY'
  @IML  '    DELIMITER, OR UP TO 16 HEX DIGITS, OR A DECIMAL VALUE'
  @IML  '    ENDING WITH "." (LENGTH IS 4 BYTES).'
  @IML  '<LAB> MAY ANY 1 TO 8 CHARACTERS.'
  @IML  '<F> IS ANY FLOATING POINT CONSTANT IN INTERNAL FORM (IE :'
  @IML  '    40800000 IS .5 VALUE).'
  @IML  END
ZAPHP12  EQU   * - - - - - - - - - - - - - - - - - - - - - IMAGE # 12
  @IML  '                     SAMPLE ZAP SESSION'
  @IML  ''
  @IML  'ZAP LOAD    READY LEVEL COMMAND ENTERED'
  @IML  'MTEST       SELECT MEMBER "TEST"'
  @IML  'EFIRST      SELECT ENTRY POINT "FIRST"'
  @IML  '4C          GO TO OFFSET X''4C'' IN RECORD'
  @IML  'S00         STORE ONE BYTE HEXADECIMAL'
  @IML  '+4          ADVANCE POINTER 4 BYTES IN BLOCK'
  @IML  'NFF0F       TURN OFF ONE NIBBLE'
  @IML  'ZAP         RE-WRITE THAT BLOCK'
  @IML  'R+3         GO TO THIRD BLOCK FROM HERE'
  @IML  'L/HELLO/    FIND SOME TEXT'
  @IML  'END         ALL DONE - EXIT ZAP'
  @IML  END
         PRINT &PRS
         EJECT
ESDDATA  DSECT , ----------------- ESD DATA ENTRY --------------------
ESDDNAME DS    CL8                 ENTRY POINT NAME OF 8X'00'
ESDDTYPE DS    X                   TYPE
ESDDADDR DS    AL3                 LKED ADDRESS OF ENTRY POINT
ESDDSEG  DS    AL1                 SEGMENT NUMBER
ESDDLEN  DS    AL3                 LENGTH OF ENTRY
ESDDL    EQU   *-ESDDATA           LENGTH ESD DATA ENTRY
         SPACE 1
JCJWORK  DSECT , -----------------------------------------------------
JCJDW1   DS    D
JCJDW2   DS    D
JCJEDIT  DS    CL6
JCJFLAGS DS    XL1
         SPACE 1
CSDATA   DSECT , -----------------------------------------------------
         DS    18F                 SAVE-AREA OF "CSOUT"
CSDBLW   DS    D                   SCRATCH DOUBLE-WORD
CSODCB   DS    0F,XL(ODCBLEN)
CSPGNO   DS    H                   PAGE COUNTER
CSLNNO   DS    H                   LINE COUNTER
CSFLAGS  DS    XL1
CSIOERR  EQU   X'01'               AN I/O ERROR HAS OCCURED
CSOBUFF  DS    CL133               BUFFER ITSELF
CSTBUFF  DS    CL133               BUFFER FOR TITLE LINE
LCSOUT   EQU   (((*-CSDATA)+7)/8)*8
         SPACE 1
TSDSECT  DSECT , ----------------- DYNAMIC STORAGE DEFINITIONS -------
EYECATCH DS    CL8                 "EXEC.ZAP"
ZUSRID   DS    CL8                 USER-ID
DDNALL   DS    CL8                 SAVE DDNAME TO FREE IT
DDPALL   DS    CL8                 SAVE DDNAME TO FREE IT
FLAGSX   DS    XL1                 MISCELLANEOUS CONTROL FLAGS
RUNTSO   EQU   X'80'               WE ARE RUNNING IN TSO
SENSF    EQU   X'40'               SYSTEM DATA-SET
MUSTZAP  EQU   X'01'               BLOCK NOT REPLACED, ENTER SAVE/END
FLAGSG   DS    XL1                 "GOD" DATA-SET STATUS FLAGS
GODALL   EQU   X'80'               DATA-SET IS ALLOCATED
GODOPN   EQU   X'40'               DATA-SET IS OPENED
GODUP    EQU   X'01'               ONLY HE CAN CHANGE HIS MIND
FLAGSL   DS    XL1                 "LOG" DATA-SET STATUS FLAGS
LOGALL   EQU   X'80'               DATA-SET ALLOCATED
LOGOPN   EQU   X'40'               DATA-SET OPENED
LOGFS    EQU   X'08'               LOGGING FORCED
LOGRQ    EQU   X'04'               LOGGING REQUESTED
*- - - - ZAP'S DATA AREA FOR "EXP"
EXPOPT   DS    XL1                 WHETHER TO SCAN SYMBOL TABLE
YESSYMB  EQU   X'FF'               "EXP" LOOK AT SYMBOL TABLE
NOSYMB   EQU   X'00'               NO SYMBOL TABLE LOOK-UP
GORF     DS    F                   SAVE POINTER
ZDBLW    DS    D
EXPWORK  DS    D
EXPFLAG  DS    3F
EXPFPLUS EQU   X'80'               ADD NEXT VALUE
EXPFMINS EQU   X'40'               SUBTRACT NEXT VALUE
EXPFDEC  EQU   X'20'
EXPFMULT EQU   X'10'               MULT NEXT VALUE
EXPFDIV  EQU   X'08'               DIV NEXT VALUE
EXPEXOPR EQU   X'04'               EXPECTING OPERATOR NEXT
*              SOMETHING REQUIRED FLAG :
EXPFTERM EQU   EXPFPLUS+EXPFMINS+EXPFDEC+EXPFMULT+EXPFDIV
*                                  "EXP" SAVE REGISTERS
EXPARMS  DS    A                    "" -R14
EXPSTART DS    A                    "" -R15
         DS    F                    "" -R0 (LENGTH)
EXPPTR   DS    A                    "" -R1
*- - - - ZAP'S DATA AREA
NOWSTUFF DS    0F             FOLLOWING 3 LINES *MUST*BE*TOGETHER*
OLDPOINT DS    H                   OFFSET INTO BUFFER
OFFSET   DS    F                   (OLDPOINT + BASEVAL)
BASEVAL  DS    F                   BASE VALUE
NOWLEN   EQU   *-NOWSTUFF
AIDEFTAB DS    A                   ADDRESS OF DEFINE TABLE
AITRCTAB DS    A                   ADDRESS OF TRACE TABLE
AITREND  DS    A                   -> END OF TRACE TABLE
FIRSTSCR DS    A                   ADDRESS OF FIRST SCREEN LOC
MAXSCR   DS    A                   ADDRESS OF END OF AVAIL SCREEN
ASPLTA   DS    F                   ADDRESS OF "SPLTAREA"
ZBUFFA   DS    F                   BUFFER AREA ADDRESS
ZBUFFL   DS    F                   BUFFER AREA LENGTH
CSALOC   DS    F                   ADDRESS OF "CSOUT" WORK-AREA
CSLLOC   DS    A                   ADDRESS OF LINE BUFFER ("CSOBUFF")
TEMPTRT  DS    XL256               TEMPORARY TRTAB FOR STRING ANAL
$L       EQU   79                  LENGTH OF DISPLAY LINE
$I       EQU   81                  LINE INCREMENT (AS IN SCREEN)
         DS    XL2                 SCREEN LINES ...
LINE01   DS    CL79,XL2             -> 1
CMDLINE  DS    CL79,XL2             -> 2
LINE03   DS    CL79,XL2             -> 3
REPLINE  DS    CL79,XL2             -> 4
IOMLINE  DS    CL79,XL2             -> 5
LINE06   DS    CL79,XL2             -> 6
LINE07   DS    CL79,XL2             -> 7
LINE08   DS    CL79,XL2             -> 8
         DS    CL79,XL2             -> 9
         DS    CL79,XL2             -> 10
         DS    CL79,XL2             -> 11
         DS    CL79,XL2             -> 12
         DS    CL79,XL2             -> 13
         DS    CL79,XL2             -> 14
         DS    CL79,XL2             -> 15
         DS    CL79,XL2             -> 16
         DS    CL79,XL2             -> 17
         DS    CL79,XL2             -> 18
MSGLINE  DS    CL79,XL2             -> 19
LINE20   DS    CL79,XL2             -> 20
LINE21   DS    CL79                 -> 21
         DS    0D                  THEN ALIGN
         ORG   LINE07              BACK TO THERE, MOMENTARILY
         PRINT &PRF
DSCB     DS    0D
        IECSDSL1 (1)               FORMAT 1 DSCB EXPANSION
         ORG   DS1FMTID
        IECSDSL1 (4)               FORMAT 4 DSCB EXPANSION
         PRINT &PRS
         ORG   ,
REGS3270 DS    2A                  A(SCREEN,SCREENL)
REPX     DS    CL(1+2+(3+79)*2)    REPLY BUFFER (READ TUBE)
PREVREP  DS    CL79                THE PREVIOUS REPLY
CURPOS   DS    H                   CURSOR POSITION
ZDSNME   DS    CL44                DATA-SET NAME
ZPSSWRD  DS    CL8                 GUESS WHAT?
DISPDSN  DS    CL44                DISPLAYABLE DSN
TTR      DS    F                   TTR OF BLK
NOSEQRD  EQU   X'00'               READ THIS RECORD
SEQREAD  EQU   X'01'               READ NEXT RECORD
*        THE LAST BYTE OF "TTR" IS USED FOR A SEQUENTIAL READ FLAG
OLDTTR   DS    F                   TTR OF LAST STORE OR SET CMD
STOPDUMP DS    XL3                 TTR WHERE TO STOP DUMP
ZDSORG   DS    XL1                 DSORG OF CURRENT DATA-SET
IDEFAVAL DS    A                   1ST AVAL POSIT IN DEFINE TAB
ITRAVAL  DS    A                   1ST AVAIL TRACE TAB POSIT
CURRITR  DS    F                   CURRENT TRACE TABLE ENTRY POINTER
TEMPW    DS    9F                  WORK-AREA
TEMP1    DS    F                   WORK-AREA
TEMP2    DS    2D                  WORK-AREA
TEMP3    DS    5D                  WORK-AREA
DSCBLIST EQU   TEMP3+16,OBTLISTL
TRTABADD DS    A                   POINTER TO TRTAB FOR DUMP DISPLAY
TRTXTAB  DS    A                   POINTER TO TRTAB FOR STRING
MIDLINE  DS    A                   CARET
WIDTHS   DS    0F                  FOR WINDOWS            |CONTIGUOUS|
WIDTHD   DS    F                   FOR DOWN               |CONTIGUOUS|
WIDTHU   DS    F                   FOR UP                 |CONTIGUOUS|
ZLGDSN   DS    F                   "LOG" DATA-SET NAME ADDRESS
ZLGVOL   DS    F                   "LOG" VOL-SER ADDRESS
REALRDLN DS    H                   ACTUAL COMND READ LENGTH
READLEN  DS    H                   READ LENGTH FROM READ TUBE
FLAGSR   DS    XL1                 RUNNING STATUS FLAGS
YESTRACE EQU   X'80'               TRACE IN EFFECT
YESSYN   EQU   X'40'               SYNAD I/O ERROR HAS OCCURRED
YESCSERR EQU   X'20'               "CSOUT" HAD PROBLEMS
YESEOF   EQU   X'10'               DO NOT IGNORE EOF'S
*                                  ELSE, TREAT EOF'S AS DATA BLK
TCONT    DS    XL1                 STORES, SCAN, SET IN EFFECT
YESCONTL EQU   X'80'               SCAN CONTINUE IS OK
YESCONTS EQU   X'40'               S,X,O,N NO OPERANDS OK
YESCONTT EQU   X'20'               SET NO OPERAND OK
CAPSFLG  DS    XL1
YESCAPS  EQU   X'FF'               CAPS ON
NOCAPS   EQU   X'00'               CAPS OFF
CHNGED   DS    XL1                 SET IF BUFFER NEEDS CHKPOINTING
IDRFLAG  DS    XL1                 WHETHER IDR WAS UPDATED OR NOT
CHGIDR   EQU   X'FF'               WE HAVE CHANGED THE IDR
NOCHGIDR EQU   X'00'               WE HAVE NOT UPDATED IT YET
ZVOLSER  DS    CL6                 VOL=SER OF DSN
ZMEMBER  DS    CL8                 MEMBER FOR PDS SEARCH
ZNAME    DS    CL8                 ENTRY NAME FOR EPA SEARCH
LOOKFOR  DS    H,CL16              SCAN WORK-AREA (LEN+STRING)
ZAPSTRNG DS    H,CL16              S,X,O,N WORK-AREA (LEN+STRING)
SETZSTR  DS    H,CL16              SET WORK-AREA (LEN+STRING)
WKSTR    DS    CL16                WORK STRING AREA
ADDRCNT  DS    A                   ADDRESS OF RECORD COUNT
ADDRKEY  DS    A                   ADDRESS OF RECORD KEY
ADDRDATA DS    A                   ADDRESS OF RECORD DATA
ADDRBUFF DS    A                   ONE OF THE ABOVE 3 ADDRESSES
BUFFSIZE DS    H                   MAX BUFFER SIZE
KEYLEN   DS    H                   CURRENT KEY-LENGTH
VBLKSZ   DS    H                   VALUE OF DS1BLKL
VLRECL   DS    H                   VALUE OF DS1LRECL
BLKLEN   DS    H                   ACTUAL BLOCK LENGTH AFTER READ
ESDID    DS    H                   ESD ID
MEMTTR   DS    XL3                 SAVE MEMBER'S TTR
TXTTTR   DS    XL3                 LOAD MOD'S FIRST TEXT BLK
CTL1TTR  DS    XL3                 TTR OF 1ST CTL REC OR 0
ENDTTR   DS    XL3                 TTR OF LAST BLK IN DATA-SET
LASTFMT1 DS    XL5                 CCHHR OF LAST FMT1 DSCB
ESDTTR   DS    XL3                 START OF ESD
TXTORIG  DS    F                   ORIG OF NXT TXT BLOCK
DCBLIST  DS    F                   DCB POINTER MF=L OPEN AND CLOSE
DCBU     DS    0F,XL(DCBUL)
ZIOB     DS    0F,XL(IOBLEN)
CCHHR    EQU   ZIOB+(IOBCC-IOBSTDRD),5 INTERESTING PART
ZECB     DS    A                   ECB FOR ECXP
CCWS     DS    0D                  HANDLE FOR ALL CCWS
CCW##R   CCW   X'16',0,X'70',1     READ R0 TO ORIENT
CCW#R#S  CCW   X'31',*-*,X'40',*-* SEARCH ID EQ
CCW#R#T  CCW   X'08',*-*,X'00',0   TIC *-8
CCW#R#R  CCW   X'1E',*-*,X'20',*-* READ CKD
CCW##W   DS    0D
CCW#W#S  CCW   X'31',*-*,X'40',*-* SEARCH ID EQ
CCW#W#T  CCW   X'08',*-*,X'00',0   TIC *-8
CCW#W#W  CCW   X'0D',*-*,X'00',*-* WRITE KD
CCW##R0  CCW   X'16',*-*,X'20',*-* READ R0
CCW##D   CCW   X'16',0,X'70',1     READ R0 TO ORIENT
CCW#D#S  CCW   X'E9',*-*,X'40',*-* SEARCH KEY EQ/HI MT
CCW#D#T  CCW   X'08',*-*,X'00',0   TIC *-8
CCW#D#R  CCW   X'0E',*-*,X'00',8+256 READ KD
CCW##F   DS    0D
CCW#F#S  CCW   X'31',*-*,X'40',5   SEARCH ID EQ
CCW#F#T  CCW   X'08',*-*,X'00',0   TIC *-8
CCW#F#W  CCW   X'1D',*-*,X'20',*-* WRITE CKD
         SPACE 1
EXLST    DS    A                   OBVIOUS
JFCB     DS    44F                 OBVIOUS
FLAGESD  DS    XL1                 FLAGS
FESDTEXT EQU   X'80'               NEXT BLOCK IS TEXT
ICREP    DS    CL79                INTEGRAL COPY OF RESPONSE FIELD
BLANKS   DS    CL256               CONSTANT FOR CLEARING
*- - - - - - - - - - - - - - - - END OF "TSDSECT" BASE REGISTER - - -*
IDEFTAB  DS    24XL10              24 ENTRIES DEFINE TABLE
*        EACH ENTRY (SYMBOL,OFFSET) IS OF THE FORM (8C,2X) AS BELOW :
DEFSYM   EQU   0,8                 SYMBOL
DEFOFF   EQU   8,2                 OFFSET
ENDITAB  DS    XL1                 END OF TABLE (X'FF')
ITRTAB   DS    24XL5               TRACE TABLE
*        EACH ENTRY (TTR,OFFSET) IS OF THE FORM (3X,2X) AS BELOW :
ITRTTR   EQU   0,3                 TTR
ITROFF   EQU   3,2                 OFFSET
ITREND   DS    XL1                 END OF TABLE (X'FF')
         DS    0D                  REQUESTED ALIGNMENT
CSAREA   DS    (LCSOUT)X           "CSOUT" WORK-AREA
WSCREEN  DS    (2*KB)X             SCREEN BUFFER
WSCREENL EQU   *-WSCREEN           LENGTH
         SPACE 1
TSDSECTL EQU   (((*-TSDSECT)+7)/8)*8 LENGTH OF DYNAMIC AREA
         SPACE 1
        SPLTAREA
         SPACE 1
        MYSAVE
         SPACE 1
        PARMLIST
         SPACE 1
        FDATE
         EJECT
         PRINT &PRF
        CVT    DSECT=YES,LIST=YES
JFCDSECT DSECT
        IEFJFCBN LIST=YES
        DCBD  DSORG=(DA,PS),DEVD=DA
UCB      DSECT
        IEFUCBOB
        IEZIOB
        IEZDEB LIST=YES
        IHAECB
        IEFZB4D0
         PRINT GEN
         SPACE 1
         END
