//CSYSMASA JOB  ACCNT,MSGCLASS=A
/*ROUTE PRINT WYLBUR
//    EXEC ASMHCL,
//    PARM.LKED='RENT,REFR,LIST,XREF,SIZE=(168K,56K)'
         MACRO
&L       MSG   &P,&M
         LCLA  &A
&A       SETA  K'&M-2
&L       DC    AL1(&A,&P),CL&A&M
         MEND
         SPACE 1
*        COPY  EDIO
         MACRO
&LBL     EDIO  &OP,&OP1,&OP2,&ERRAD=,&MF=E
         LCLA  &A
         LCLB  &OW,&ORC,&ORN,&ORP,&ORF,&ORL,&ODLT
         LCLC  &L,&TO
&TO      SETC  ''
&L       SETC  '&LBL'
         AIF   ('&OP' NE '').HOP
         MNOTE *,'OPERATION NOT SPECIFIED'
         AGO   .DOOP1
.HOP     ANOP
&OW      SETB  ('&OP' EQ 'W')  WRITE
&ORC     SETB  ('&OP' EQ 'RC') READ CURRENT
&ORN     SETB  ('&OP' EQ 'RN') READ NEXT
&ORP     SETB  ('&OP' EQ 'RP') READ PREVIOUS
&ORF     SETB  ('&OP' EQ 'RF') READ FIRST
&ORL     SETB  ('&OP' EQ 'RL') READ LAST
&ODLT    SETB  ('&OP' EQ 'DLT') DELETE
         AIF   (&OW+&ORC+&ORN+&ORP+&ORF+&ORL+&ODLT NE 1).ERR1
&A       SETA  &OW*32+&ORC*0+&ORN*2+&ORP*1+&ORF*4+&ORL*5+&ODLT*16
.GEN1    ANOP
&L       MVI   IOLIST,&A       SET OPTION
&L       SETC  ''
.DOOP1   AIF   ('&OP1' NE '').HOP1
         MNOTE *,'OPERAND 1 OMMITTED'
&TO      SETC  '2'             CHANGE SUBROUTINE ENTRY
         AGO   .OP1OK
.HOP1    AIF   ('&OP1' EQ '(R1)').OP1OK
         AIF   ('&OP1'(1,1) EQ '(').OP1R
&L       LA    R1,&OP1         GET ADDR OF PARM 1
&L       SETC  ''
         AGO   .OP1OK
.OP1R    ANOP
&L       LR    R1,&OP1         GET PARM 1
&L       SETC  ''
.OP1OK   AIF   ('&OP2' NE '').HOP2
         MNOTE *,'OPERAND 2 OMMITTED'
         AGO   .OP2OK
.HOP2    AIF   ('&OP2'(1,1) EQ '(').OP2R
&L       LA    R14,&OP2        GET PARM 2
&L       SETC  ''
         ST    R14,IOLIST+8   SET PARM 2
         AGO   .OP2OK
.OP2R    ANOP
&L       ST    &OP2,IOLIST+8  SET PARM 2
&L       SETC  ''
.OP2OK   AIF   ('&MF' EQ 'B').MEXIT
&L       BAL   R14,UT$IO&TO    GO DO IO
         AIF   ('&ERRAD' EQ '').MEXIT
         BNZ   &ERRAD          BR IF ERROR
.MEXIT   MEXIT
.ERR1    MNOTE 12,'&OP IS NOT ONE OF W,RC,RN,RP,RF,RL,DLT'
         AGO   .GEN1
         MEND
         TITLE 'CCNEDFSE - TSO EDIT ''FULLSCR'' SUBCOMMAND'
***********************************************************************
*                                                                     *
*   F U L L S C R   --   EDIT SUBCOMMAND                              *
*                                                                     *
*                                                                     *
CCNEDFSE CSECT                                                        *
$        EQU   CCNEDFSE                                               *
*                                                                     *
*  FUNCTION --                                                        *
*                                                                     *
*  INPUT --                                                           *
*     REGISTER 1 CONTAINS THE ADDRESS OF THE EDIT COMMUNICATIONS AREA.*
*                                                                     *
*  OUTPUT--                                                           *
*     POSSIBLE RETURN CODES (IN REGISTER 15) ARE:                     *
*     ZERO --       SUBCOMMAND COMPLETED NORMALLY                     *
*     EIGHT --      RECOVERABLE ERROR OR ATTENTION OCCURRED.          *
*     TWELVE --     I/O ERROR IN THE WORK FILE                        *
*                                                                     *
*  EXTERNAL REFERENCES --                                             *
*     IKJEBELE --   EDIT LINE EDIT ROUTINE                            *
*     IKJEBEMS --   EDIT MESSAGE ROUTINE                              *
*     IKJEBEUT --   EDIT ACCESS METHOD INTERFACE                      *
*     IKJPTGT --    PUTGET SERVICE ROUTINE                            *
*     IKJPUTL --    PUTLINE SERVICE ROUTINE                           *
*                                                                     *
*  MACROS USED --                                                     *
*     FREEMAIN --   FREE GOTTEN WORKAREA                              *
*     GETMAIN --    GET CORE FOR WORKAREA                             *
*     IKJEBECA --   EDIT COMMUNICATIONS AREA DSECT                    *
*     IKJEBEMG --   CALLS EDIT MESSAGE ROUTINE (IKJEBEMS)             *
*     IKJEBEMI --   EDIT MESSAGE INSERT BLOCK                         *
*     IKJEBEML --   EDIT FIRST-LEVEL MESSAGE BLOCK                    *
*     IKJEBERT --   EDIT EXIT MACRO                                   *
*     IKJEBESH --   CALLS EDIT SERVICE ROUTINE IKJEBELE               *
*     IKJEBESV --   EDIT ENTRY MACRO                                  *
*     LINK --       LINKS TO FSE HELP ROUTINE                         *
*     PUTGET --     BUILDS PARMLIST AND LINKS TO PUTGET SERVICE RTN   *
*     PUTLINE --    BUILDS PARMLIST AND LINKS TO PUTLINE SERVICE RTN  *
*                                                                     *
*  EXITS --                                                           *
*     CONTROL IS RETURNED TO IKJEBEMA (CONTROLLER) IN ALL CASES       *
*                                                                     *
*  ATTRIBUTES --                                                      *
*     REENTRANT, REFRESHABLE, PROBLEM STATE, PROBLEM KEY.             *
*                                                                     *
*                                                                     *
*  WRITTEN BY -- MICHAEL STEIN AND CHRIS THOMAS                       *
*                OFFICE OF ACADEMIC COMPUTING                         *
*                UNIVERSITY OF CALIFORNIA, LOS ANGELES                *
*                PHONE:  213 - 825 - 7424                             *
*                                                                     *
*  COPYRIGHT --  THIS MODULE IS COPYRIGHTED BY THE REGENTS OF THE     *
*                UNIVERSITY OF CALIFORNIA, 1978,1979.  ALL RIGHTS ARE *
*                RESERVED.                                            *
*                                                                     *
*  WRITTEN --    07/03/78                                             *
*  UPDATED --    03/08/79 - MAS - ADD REPLICATE, DESTROY HARD TABS.   *
*                               - ADD FDELETE, RESTORE VERIFY FLAG    *
*                                                                     *
***********************************************************************
         TITLE 'CCNEDFSE - FULLSCR SUBCOMMAND - ENTRY CODE'
***********************************************************************
*                                                                     *
*                            ENTRY CODE                               *
*                                                                     *
***********************************************************************
         SPACE 1
         IKJEBESV  (14,12),T,CCNEDFSE/COPYRIGHT.1978-1979.UCLA
         USING  IKJEBECA,COMMREG        BASE REG FOR COMM AREA DSECT
         SPACE 1
         L     BASEREG,TRUEBASE         LOAD THE CORRECT BASE
         USING CCNEDFSE,BASEREG
*  ZERO OUT WORK AREA INCLUDING RETCDE
         XC    CASCWKA(256),CASCWKA     ZERO OUT THE WORKAREA
         XC    CASCWKA+256(80),CASCWKA+256   (CONTINUE)
         TCLEARQ INPUT                  FLUSH ANY EXTRA INPUT
         L     R14,=A(STAXEXIT)         POINT TO ATTN EXIT
         STAX  (R14),REPLACE=NO,        SET UP MY ATTN EXIT            +
               USADDR=(COMMREG),MF=(E,STAXPARM)
         L     R12,CCNWORD              @ MY PERM AREA IF EXISTS
         LTR   R12,R12                  DOES IT EXIST?
         BNZ   INT$HWRK                 BR IF HAVE PERM AREA
         SPACE 1
         GTSIZE
*  R15 - RC, R0 - LINES/SCREEN, R1 - COLUMNS / LINE
         LTR   R15,R15                  GTSIZE PARMS OK?
         BNZ   GTSZERR                  IF NOT, GIVE ERROR MSG
         L     R8,=X'03000000'          ASSUME DO TPUT FULLSCR
         LTR   R0,R0                    FULLSCR DEVICE?
         BP    INT$FST                  BIF FULLSCR DEVICE
         L     R8,=X'02000000'          DO TPUT CTL INSTEAD
         L     R4,CAPTIBFR              @ COMMAND INPUT BUFFER
         LA    R2,4                     CONSTANT OF 4
         AH    R2,2(,R4)                + OFFSET -> OFFSET + 4
         LA    R1,0(R2,R4)              @ OF INPUT
         SH    R2,0(,R4)                OFFSET + 4 - BUFFER LEN
         LCR   R2,R2                    TRUE LENGTH LEFT
         BAL   R14,SCAN                 INIT SCAN PTRS
         BAL   R14,SCANC                SCAN FOR OPERAND
         BNP   BADTERM                  IF NONE INVALID TERMINAL
         CLC   TEMPDW(4),=C'CRT '       WANT CRT MODE?
         BNE   BADTERM                  INVALID TERMINAL IF NOT
         LA    R0,24                    ASSUME 24 LINES
         LA    R1,80                    EACH 80 COLUMNS LONG
INT$FST  LR    R4,R0                    SAVE LINES
         LR    R5,R1                    AND COLS
         SPACE 1
*  XT#WORK LENGTH = XT#PFXL             (PREFIX)
*                 + LINES * COLS        (I/O SCREEN BUFFER)
*                 + LINES * 5           (SBA,ADR1,ADR2,SF,ATR)
*                 + LINES * 2 * 10      (SF,ATR * 10)
*                 + LINES * 16          (LN#LINE ENTRIES)
*  NOTE: XT#BUF MUST BE >= (IMC#WRKL) (USED AS WORK AREA)
         LA    R1,5+2*10(,R1)           FACTOR OUT LINES AMOUNT
         MR    R0,R1                    LINES * (COLS + FACTOR)
         CH    R1,=Y(IMC#WRKL)          ENOUGTH WORK AREA?
         BNL   *+8                      BIF LARGE ENOUGH
         LH    R1,=Y(IMC#WRKL)          FORCE TO WORK AREA MINIMUM
         LR    R7,R4                    LINES / SCREEN
         SLL   R7,4                     * LN#LINEL -> LN#LINE AREA LEN
         LA    R6,XT#PFXL(R7,R1)        TOTAL REQUIRED
         GETMAIN EC,LV=(R6),A=XWORKADR,SP=1,MF=(E,GETMFL)    GET IT
         BXH   R15,R15,NOCORE           BR IF NO CORE - ISSUE ERR MSG
         L     R12,XWORKADR             ADDR CORE JUST BOUGHT
         USING XT#WORK,R12
         XC    XT#WORK(256),XT#WORK     INIT PREFIX TO ZERO
         XC    XT#WORK+256(XT#PFXL-256),XT#WORK+256
         AR    R6,R12                   GET ADDR PAST END
         LA    R7,XT#BUF(R7)            POINT TO XT#BUF
* SET LINES, COLS, END ADDR+1, XT#BUF, TPUT FLAG
         STM   R4,R8,XT#SCRL            INIT XT#WORK FIELDS
         MVI   XT#TABC,X'5A'            SET DEFAULT TAB CHAR
         MVI   XT#TABTR+X'5A',1         SET TAB IN TRT TABLE
         MVI   XT#OMSGP+1,255           NO OLD MESSAGE TO OVERLAY
         MVI   XT#CUR+1,1               HOME CURSOR
         MVC   XT#DFT(4),=AL1(15,15,40,40) U,D,L,R DEFAULT VALUES
         OI    XT#CURSQ,X'80'           DON'T HAVE ROD1 POS CURSOR YET
         ST    R12,CCNWORD              SAVE ADDR PERM AREA
         MVI   XT#SEQL+3,7              ASSUME 6 DIGITS WILL WORK
         EDIO  RL,,BUF1                 READ LAST RECORD
         BNZ   INT$SEQ7                 BIF EMPTY FILE
         CLC   BUF1(4),=F'1000000'      6 DIGITS ENOUGHT?
         BL    INT$SEQ7                 BIF 6 DIGITS ENOUGTH
         MVI   XT#SEQL+3,9              ELSE USE 8 DIGITS + ATTR
INT$SEQ7 L     R8,=A(C$T)               @ OF TOP CODE
         BALR  R10,R8                   GO DO TOP COMMAND
         L     R1,=A(MSG#ENT)           @ ENTER MSG
         BAL   R14,MSG                  GO SET IT
         SPACE 1
INT$HWRK TM    XT#FLAG,XT#FSCR          ALREADY IN FULLSCREEN MODE?
         BO    INT$HW2                  BIF ALREADY IN FULLSCREEN MODE
         STFSMODE ON,INITIAL=YES        SET VTAM FULL SCREEN MODE
         BXH   R15,R15,INT$HW2          BIF NOT VTAM
         OI    XT#FLAG,XT#FVTAM         SET IS VTAM FLAG
INT$HW2  MVC   XT#SAVF,CACFLAG1         SAVE VERIFY FLAG
         NI    XT#SAVF,CAVRFYSW         ONLY SAVE VERIFY FLAG
         NI    CACFLAG1,255-CAVRFYSW    SET VERIFY = NO
         NI    XT#OPT,255-XT#FTAB       OFF MY TAB FLAG
         TM    CATABS,X'FF'             TABS ON?
         BZ    *+8                      BIF TABS OFF
         OI    XT#OPT,XT#FTAB           SET MY TABS FLAG
         TM    XT#FLAG,XT#FSCN          USE MY POSITION?
         BZ    INT$EPOS                 BIF NOT TO USE EDIT'S POS
         MVC   CACURNUM,XT#CNUM         USE IT
         NI    XT#FLAG,255-XT#FSCN      OFF USE MY POS FLAG
INT$EPOS LA    R3,XT#LINS               POINT TO FIRST LINE CTL ENTRY
         L     R4,XT#SCRL               NUMBER OF LINES
         USING LN#LINE,R3
INT$LIN  XC    LN#LINE(LN#LINEL),LN#LINE INIT TO ZERO
         MVC   LN#RIN(4),=Y(R$ICMD-$,R$OCMD-$) ASSUME CMD LINE
         CL    R4,XT#SCRL               LINES / SCREEN
         BE    INT$LNXT                 BR IF CMD LINE
         MVC   LN#RIN(4),=Y(R$IDAT1-$,R$ODAT1-$) DATA ROUTINES
         MVI   LN#FLAG,LN#FDAT          SET DATA LINE
         CH    R4,=H'1'                 LAST LINE? (STATUS LINE?)
         BH    INT$LNXT                 BR IF DATA LINE
         MVC   LN#RIN(4),=Y(R$IST-$,R$OST-$) STATUS ROUTINES
         MVI   LN#FLAG,0                NOT DATA LINE
INT$LNXT LA    R3,LN#LINEL(,R3)         TO NEXT ENTRY
         BCT   R4,INT$LIN               BUILD ALL LINE CTL
         OI    XT#FLAG,XT#FSS           FORCE SETSCRN CALL
         TITLE 'CCNEDFSE - FULLSCR SUBCOMMAND - FULLSCR CODE'
*  SCREEN SIZE: MOD1 - 480,   (12 LINES OF 40 CHARACTERS)
*               MOD2 - 1920,  (24 LINES OF 80 CHARACTERS)
*               MOD3 - 2560,  (32 LINES OF 80 CHARACTERS)  (3278)
*               MOD4 - 3440,  (43 LINES OF 80 CHARACTERS)  (3278)
*  3270 WRITE SEQUENCE ---
*    LOCAL  - WCC, (SBA, CUR1, CUR2, SF, ATTR, DATA)
*             (ALWAYS USE LOCAL SEQUENCE FROM TSO)
*    REMOTE - ESC, CMD, WCC, (SBA, CUR1, CUR2, SF, ATTR, DATA)
*
*  ESC - X'27'
*  CMD - X'F1' - WRITE (DEFAULT)        (CCW X'01')
*        X'F5' - ERASE/WRITE            (CCW X'05')
* WCC -  X... ....  - SET TO MAKE VALID CHAR
*        .1.. ....  - ALWAYS ONE
*        ..XX ....  - PRINTOUT FORMAT
*        .... 1...  - START PRINTER BIT
*        .... .1..  - SOUND ALARM
*        .... ..1.  - KEYBOARD RESTORE (RESET INPUT INHIBITED AND AID)
*        .... ...1  - RESET MDT BITS
* SBA - X'11' - SET BUFFER ADDRESS
* ATTRIBUTE CHAR ----
*        X... ....  - SET TO MAKE VALID CHAR
*        .1.. ....  - ALWAYS ONE
*        ..1. ....  - PROTECTED
*        ..11 ....  - AUTO SKIP (PROTECTED NUMERIC)
*        ...1 ....  - NUMERIC
*        .... 00..  - DISPLAY/NOT SELECTOR-PEN DETECTABLE
*        .... 01..  - DISPLAY/SELECTOR-PEN DETECTABLE
*        .... 10..  - INTENSIFIED DISPLAY/SELECTOR-PEN DETECT.
*        .... 11..  - NONDISPLAY,NONPRINT,NONDETECT.
*        .... ..0.  - RESERVED MUST BE 0
*        .... ...M  - 1 - FIELD MODIFIED/0 - NOT MODIFIED
*
* AID CODES: X'60' - UNSOLICITED READ   (READ MODIFIED)
*            X'E8' - PRINTER            (READ MODIFIED)
*            X'7D' - ENTER KEY          (READ MODIFIED)
*   X'F1' TO X'F9' - PF1 TO PF9         (READ MODIFIED)
*            X'7A' - PF10               (READ MODIFIED)
*            X'7B' - PF11               (READ MODIFIED)
*            X'7C' - PF12               (READ MODIFIED)
*            X'E6' - OPER ID CARD RDR   (READ MODIFIED)
*            X'7E' - SELECTOR-PEN       (READ MODIFIED)
*            X'6C' - PA1                (SHORT READ) (TSO ATTN)
*            X'6E' - PA2 (CNCL)         (SHORT READ)
*            X'6B' - PA3                (SHORT READ) (SPF RESHOW)
*            X'6D' - CLEAR KEY          (SHORT READ)
* (NO AID)   X'F0' - TEST REQ           (TEST REQUEST READ) X'016C6102'
*                                       FOLLOWED BY DATA (NO AID,CUR)
*                    (USED BY VTAM)
         EJECT ,
*  TPUT/TGET ---
*    R0 - TJID / LENGTH
*    R1 - FLAGS / BUFFER ADDRESS
*        1... ....  - TGET
*        .XX. ....  - RESERVED
*        ...1 ....  - NOWAIT
*        .... 1...  - HOLD
*        .... .1..  - BREAK
*        .... ..00  - EDIT
*        .... ..01  - ASIS
*        .... ..10  - CONTROL
*        .... ..11  - FULLSCR
* RETURN CODES --- TGET
* 00  - ALL OK, R1 = INPUT LENGTH
* 04  - NOWAIT AND NO INPUT WAS AVAILABLE
* 08  - ATTENTION INTERUPT OCCURED DURING TGET
* 0C  - BUFFER NOT LARGE ENOUGTH (NEXT TGET WILL GET NEXT CHUNK)
* 10  - INVALID PARMS
* 14  - TERMINAL DISCONNECTED
*              --- TPUT
* 00  - ALL OK
* 04  - NOWAIT AND NO BUFFERS AVAILABLE
* 08  - ATTENTION INTERUPT OCCURED DURING TPUT
* 0C  - TPUT WITH TJID REFUSED BY USER
* 10  - INVALID PARMS
* 14  - TERMINAL DISCONNECTED
*
*  EDIT UTILITY FILE ROUTINE PARMS:
*    0     - OPERATION REQUESTED
*       X'00' - READ SPECIFIED RECORD
*       X'01' - READ PREVIOUS RECORD
*       X'02' - READ NEXT RECORD
*       X'04' - READ FIRST RECORD
*       X'05' - READ LAST RECORD
*       X'10' - DELETE RECORD
*       X'20' - WRITE RECORD (OR ADD)
*
*    1 -  3 - UTILITY DCB ADDRESS
*    4 -  7 - RECORD KEY FOR READ/DELETE
*             RECORD ADDRESS FOR WRITE
*    8 - 12 - RECORD ADDRESS FOR READ
*
* RETURN CODES:
*    0 - OPERATION SUCCESSFUL
*    4 - RECORD DOES NOT EXIST (READ/DELETE)
*    8 - I/O ERROR (MESSAGE ALREADY ISSUED)
*   12 - INVALID LINE NUMBER
*
         EJECT ,
INFULL   TM    XT#FLAG,XT#FIMC          INSERT/MOVE/COPY PENDING?
         BZ    INF$NIMC                 BIF IF NONE
         L     R8,=A(IMCRTN)            @ INSERT/MOVE/COPY ROUTINE
         BALR  R10,R8                   GO DO IT
INF$NIMC CLC   XT#OMSGP,XT#SCRC+2       ANY MSG ON SCREEN?
         BNE   INF$CHGM                 BIF MSG TO CHANGE IT
         OC    XT@MSG,XT@MSG            ANY MESSAGE TO DISPLAY?
         BZ    *+8                      BIF NO MSG TO DISPLAY
INF$CHGM OI    LN#FLAG-LN#LINE+XT#LINS,LN#FCHG SET CHANGE FLAG
         TM    XT#FLAG,XT#FSS           SETSCRN CALL REQUIRED?
         BZ    INF$NSS                  BIF NO SETSCRN REQ
         L     R15,CACURNUM             GET EDIT CURRENT POSITION
         BAL   R10,SETSCRN              DO IT
         NI    XT#FLAG,255-XT#FSS       DON'T NEED IT NOW
INF$NSS  L     R2,XT@BUF
         MVI   0(R2),X'C3'              SET WCC
         LA    R2,1(,R2)                SKIP OVERT WCC
         TM    XT#FLAG,XT#FVTAM         VTAM?
         BO    INF$VTAM                 BIF VTAM
         MVC   0(3,R2),=X'115D7F'       SET TCAM FULL SCREEN CODE
         LA    R2,3(,R2)                SKIP OVERT TCAM PREFIX
INF$VTAM TM    XT#SET,LN#FCHG           RESHOW?
         BZ    INF$RS                   BR IF NOT RESHOW
         MVC   0(7,R2),=X'1140403C404000' CLEAR SCREEN TO NULLS
         LA    R2,7(,R2)                BUMP OUTPUT PTR
INF$RS   LA    R3,XT#LINS               LINE CTL TABLE ADDR
         USING LN#LINE,R3
         L     R4,XT#SCRL               LINES / SCREEN
         SPACE 1
INF$LP   OC    LN#FLAG(1),XT#SET        SET FLAGS
         OC    LN#FLAG(1),XT#CLR        AND CLEAR
         XC    LN#FLAG(1),XT#CLR        SOME TOO
         TM    LN#FLAG,LN#FCHG          LINE CHANGED?
         BZ    INF$NEXT                 BR IF NO WRITE REQUIRED
         NI    LN#FLAG,255-LN#FCHG      CLEAR CHANGED FLAG
         LA    R0,25(,R2)               5+20
         AL    R0,XT#SCRC               COLUMNS / LINE
         CL    R2,XT@END                ROOM LEFT FOR STUFF?
         BL    *+8                      BR IF ROOM LEFT
         EX    0,*                      DIE - XT#WORK TOO SMALL
         MVI   0(R2),X'11'              SET SBA
         L     R0,XT#SCRL               LINES / SCREEN
         SR    R0,R4                    GET CURRENT LINE NUMBER
         MH    R0,XT#SCRC+2             GET POSITION ON SCREEN
         BAL   R14,CV$POS               SET POSITION
         MVI   3(R2),X'1D'              SET SF
         MVI   4(R2),X'40'              AND DEFAULT ATTRIBUTE CHAR
         LH    R8,LN#ROUT               GET ROUTINE OFFSET
         AR    R8,BASEREG               GET ROUTINE ADDR
         BALR  R10,R8                   CALL OUTPUT ROUTINE
INF$NEXT LA    R3,LN#LINEL(,R3)         TO NEXT LINE CTL ENTRY
         BCT   R4,INF$LP                PROCESS ALL LINES
         DROP  R3                       (LN#LINE)
         SPACE 1
*---                SET CURSOR POSITION                            ---*
         LH    R0,XT#CUR                GET CURSOR POSITION
         OI    XT#CURSQ,X'80'           NO MORE SEQ NUM FOR CUR POS
         MVI   0(R2),X'11'              SET SBA
         BAL   R14,CV$POS               SET CURSOR POSITION CHARS
         MVI   3(R2),X'13'              INSERT CURSOR CHAR
         LA    R2,4(,R2)                SKIP OVER CURSOR POS
         L     R1,XT@BUF                OUTPUT STRING POSITION
         SR    R2,R1                    GET LENGTH TO TPUT
         LR    R0,R2                    LENGTH TO R0
         BAL   R14,SP$TPUT              TPUT FULLSCR IT
         OI    XT#FLAG,XT#FSCR          IN FULLSCR MODE NOW
*  NO EOF ON SCREEN YET, DON'T ERASE CMD LINE (SO FAR)
         NI    XT#FLAG,255-XT#FEOF-XT#FECMD
         XC    XT#SET(2),XT#SET         NO SET/CLEAR FLAGS LEFT
         XC    XT#CMDL,XT#CMDL          NO CMD ENTERED YET
         XC    XT@MSG,XT@MSG            NO MSG YET
         L     R1,XT@BUF                POINT TO INPUT BUFFER
         L     R0,XT@END                PAST INPUT BUFFER ADDR
         SR    R0,R1                    GET INPUT BUFFER LENGTH
         BAL   R14,SP$TGET              TGET ASIS
         MVI   XT#AID,X'6E'             FAKE PA2 IF ATTENTION
         CH    R15,=H'8'                ATTN DURING TGET?
         BE    INF$NPF                  PROCESS AS PA2 (RESHOW)
         BXH   R15,R15,FLUSH            GO FLUSH IF TGET ERROR
         NI    CAATTN,255-CAATTNIS      NO ATTENTION YET
         LTR   R5,R1                    CHECK INPUT LENGTH
         BNP   INFULL                   BR IF NO INPUT
         L     R15,XT@BUF               GET ADDR OF INPUT
         MVC   TEMPDW(7),0(R15)         COPY TO WORK AREA
         OC    TEMPDW(7),=CL8' '        TO UPPER CASE
         CLC   TEMPDW(3),=C'END'        NON 3277 END?
         BE    FLUSH                    BR TO LET HIM OUT
         CLC   TEMPDW+3(3),=C'END'      NON FORMATED SCREEN END?
         BE    FLUSH                    BR TO LET HIM OUT
         MVC   XT#AID,0(R15)            SAVE AID CHAR
         CLI   XT#AID,X'F1'             PFK 1 - 9?
         BNL   INF$KOK                  BIF PFK 1 - 9
         CLI   XT#AID,X'7A'             PFK 10 - 12 OR ENTER?
         BL    INF$NPF                  BIF NOT PFK 10 - 12
         CLI   XT#AID,X'7D'             PFK 10 - 12 OR ENTER?
         BNH   INF$KOK                  BIF PFK 10 - 12 OR ENTER
INF$NPF  OI    XT#SET,LN#FCHG           ALL OTHERS SET RESHOW
         CLI   XT#AID,X'6E'             PA2?
         BE    INFULL                   NO COMMAND OR INPUT IF RESHOW
         CLI   XT#AID,X'6B'             PA3? (SPF INTERCEPT RESHOW)
         BNE   INF$NFMT                 BIF NOT PA3, FORMAT ERROR
         B     INFULL                   NO COMMAND OR INPUT IF PA3
INF$KOK  CH    R5,=H'1'                 ONLY AID?
         BE    INFULL                   GO PROCESS ONLY AID
         CH    R5,=H'3'                 ONLY AID,CUR1,CUR2?
         BL    INF$NFMT                 INVALID INPUT
         L     R1,XT@BUF                POINT TO AID,CUR1,CUR2
         BAL   R14,CV$POSC              CONVERT CURSOR POSITION
         STH   R0,XT#CUR                SAVE CURSOR POSITION
         SH    R5,=H'4'                 - SBA,CUR1,CUR2, - 1
         BM    INF$CMD                  BIF NO INPUT BUT AID,CUR1,CUR2
         LA    R4,3(,R1)                POINT TO 1ST SBA
         STM   R4,R5,XT#IADR            SET ADR, LEN-1
INF$LP3  BAL   R10,FISCAN               SCAN FOR NEXT FIELD
         BZ    INF$CMD                  BR IF ALL INPUT DONE
         LH    R8,LN#RIN-LN#LINE(,R3)   OFFSET OF INPUT ROUTINE
         AR    R8,BASEREG               ADDR OF INPUT ROUTINE
         BALR  R10,R8                   TO INPUT ROUTINE
         B     INF$LP3                  AND CONTINUE
INF$NFMT L     R1,=A(MSG#NFMT)          SCREEN FORMAT ERROR
         BAL   R14,MSG                  GO SET MESSAGE
         B     INFULL                   GO WRITE MSG/REDISPLAY SCREEN
         EJECT ,
INF$CMD  LM    R1,R2,XT#CMDA            GET CMD ADDR/LEN
         CLC   XT#CUR,XT#SCRC+2         CURSOR ON 1ST LINE (CMD)
         BH    *+10                     BIF CURSOR NOT ON CMD LINE
         MVC   XT#CUR,=H'1'             HOME CURSOR IF ON CMD LINE
         BAL   R14,SCAN                 INIT SCAN PTRS
         CLI   XT#AID,X'7D'             ENTER KEY?
         BNE   INF$PFK                  BIF NOT ENTER, TRY PFK
         BAL   R14,SCANC                SCAN FOR CMD
         BZ    INF$TAB                  BR IF NO CMD
         BM    INF$ICMD                 BR IF INVALID CMD
         LM    R5,R7,=A(CMD#T,CMD#TL,CMD#TE) @, LEN ENT, @ LAST ENT
         BAL   R14,FIND                 GO FIND COMMAND ENTRY
         BE    INF$CFD
         L     R8,=A(STK#EDIT)          @ STACKING ROUTINE
         BALR  R10,R8                   SEE IF HE'LL BUY CMD
INF$ICMD L     R1,=A(MSG#ICMD)          @ INVALID COMMAND MSG
         BAL   R14,MSG                  GO SET IT
         B     INF$CCUR                 GO POSITION CURSOR
INF$PFK  LM    R5,R7,=A(PFK#T,PFK#TL,PFK#TE) FIND BXLE REGS
         MVC   TEMPDW(1),XT#AID         SET AID TO FIND
         BAL   R14,FIND                 FIND AID CODE
         BNE   INF$ICMD                 BIF AID NOT DEFINED
         LH    R5,2(,R5)                GET CMD ENTRY OFFSET
         AR    R5,BASEREG               POINT TO CMD ENTRY
INF$CFD  MVC   XT#CUR,=H'1'             HOME CURSOR VAL CMD
         CLI   9(R5),0                  NUMERIC OPERAND?
         BE    INF$CFD2                 BIF NO NUMERIC OPERAND
         BAL   R14,SCANN                GET NUMERIC OPERAND
         BP    INF$CFD2                 BIF GOT OPERAND
         SR    R15,R15                  CLEAR FOR IC(S)
         IC    R15,9(,R5)               GET XT#DFT OFFSET
         CH    R15,=H'128'              ANY DEFAULT?
         BE    INF$MNO                  BIF MISSING NUMERIC OPERAND
         IC    R15,XT#DFT-1(R15)        GET DEFAULT VALUE
INF$CFD2 LH    R8,10(,R5)               GET CMD RTN OFFSET
         AR    R8,BASEREG               @ CMD ROUTINE
         BALR  R10,R8                   CALL CMD ROUTINE
         OI    XT#FLAG,XT#FECMD         ERASE CMD SINCE IT WORKED
         OI    LN#FLAG-LN#LINE+XT#LINS,LN#FCHG SET CMD LINE CHG FLG
         B     INFULL
INF$MNO  L     R1,=A(MSG#MNO)           MISSING NUMERIC OPERAND
         BAL   R14,MSG                  SET IT
         B     INF$CCUR                 GO POSITION CURSOR
INF$MOPR L     R1,=A(MSG#MOPR)          MISSING OPERAND
         BAL   R14,MSG                  SET IT
         B     INF$CCUR                 GO POSITION CURSOR
INF$IOPR L     R1,=A(MSG#IOPR)          INVALID OPERAND
         BAL   R14,MSG                  SET IT
INF$CCUR L     R1,SV#SCANP              GET PREV SCAN PTR VALUE
         S     R1,XT#CMDA               GET OFFSET INTO CMD INPUT
         BM    INFULL                   DON'T CURSOR POSITION IF BAD
         LA    R1,1(,R1)                SKIP ATTR BYTE
         STH   R1,XT#CUR                POSITION CURSOR
         B     INFULL                   AND GO DO IT
         SPACE 1
INF$TAB  LH    R1,XT#CUR                GET CURSOR POSITION
         LR    R15,R1                   SAVE CURSOR POSITION
         SR    R0,R0                    CLEAR FOR DIVIDE
         D     R0,XT#SCRC               GET LINE #
         CL    R0,XT#SEQL               ON 1ST DATA ATTR BYTE?
         BNE   INFULL                   BIF NOT ON 1ST DATA ATTR BYTE
         CL    R1,XT#SCRL               VALID LINE NUMBER?
         BNL   INFULL                   BIF INVALID LINE
         SLL   R1,4                     OFFSET OF LN#LINE ENTRY
         LA    R1,XT#LINS(R1)           @ LN#LINE ENTRY
         USING LN#LINE,R1
         TM    LN#FLAG,LN#FDAT          DATA LINE?
         BZ    INFULL                   BIF NOT DATA LINE
         OI    LN#FLAG,LN#FNTAB+LN#FCHG DESTROY TABS ON THIS LINE
         LA    R15,1(,R15)              POSITION CURSOR PAST ATTR
         STH   R15,XT#CUR               SET NEW CURSOR POSITION
         B     INFULL                   AND CONTINUE
         DROP  R1                       (LN#LINE)
         EJECT ,
*  FISCAN - SCAN ASIS INPUT STREAM
*   'XT#IADR' - REMAINING INPUT STRING ADDRESS
*   'XT#ILEN' - REMAINING INPUT STRING LENGTH -1
*   'XT#LINS' - LINE CTL AREA (ONE LN#LNE ENTRY PER SCREEN LINE)
*   R10 - RETURN ADDR
*     ON EXIT:  R0  - CONVERTED FIELD POSITION
*               R1  - ADDRESS OF FIELD (AFTER ATTRIBUTE CHAR)
*               R2  - LENGTH OF FIELD  (ONLY DATA AFTER ATTRIBUTE)
*               R3  - ADDR LINE CTL ENTRY       (0 IF ERROR, CC SET)
*               R14 - OFFSET INTO LINE
*               R15 - LINE NUMBER
*   USES: R0, R1, R2, R3, R14, R15
         SPACE 1
FISCAN   LM    R15,R0,XT#IADR           INPUT ADDR, LENGTH LEFT - 1
         LA    R1,1(,R15)               COPY INPUT ADDR (SKIP SBA)
         LR    R2,R0                    COPY LEN -1
         BCTR  R2,0                     GET LEN-1 WITHOUT SBA
         LTR   R2,R2                    REALLY DATA THERE?
         BNP   FI$ERR                   RETURN, NO MORE INPUT
         CLI   0(R15),X'11'             START WITH SBA?
         BNE   FI$ERR1                  ERROR IF NOT
         LA    R14,255                  MAX TRT LENGTH -1
FI$PARSG CR    R14,R2                   MAX LEN :: LEN LEFT
         BL    *+6                      USE SMALLER (MAX)
         LR    R14,R2                   USE SMALLER (LEFT)
         EX    R14,FI$TRT               TRT 0(0,R1),FI#TRTAB
         BNZ   FI$SBAFD                 BR IF SBA FOUND
         LA    R1,1(R1,R14)             UPDATE SCAN PTR
         BCTR  R2,0                     GENERATE LENGTH
         SR    R2,R14                   SCANNED - 1
         BNM   FI$PARSG                 IF MORE LEFT CONTINUE
         SPACE 1
FI$SBAFD SR    R1,R15                   GET LENGTH OF FIELD DATA
         SR    R0,R1                    GET NEW LENGTH LEFT -1
         LR    R2,R1                    RETURN FIELD LENGTH
         LR    R1,R15                   RETURN FIELD ADDR
         AR    R15,R2                   POINT PAST FIELD
         SH    R2,=H'3'                 SBA,ADR,ADR?
         BM    FI$ERR1                  BR IF BAD INPUT (ZERO IS OK)
         STM   R15,R0,XT#IADR           SAVE UPDATED ADR, LEN-1
         BAL   R14,CV$POSC              GET POSITION OF FIELD
         LA    R1,3(,R1)                SKIP SBA,ADR1,ADR2
         LR    R15,R0                   COPY FIELD POSITION
         SR    R14,R14                  CLEAR FOR DIVIDE
         D     R14,XT#SCRC              / COLUMNS ON LINE
         LR    R3,R15                   COPY LINE NUMBER
         SLL   R3,4                     GET LN#LINE OFFSET
         LA    R3,XT#LINS(R3)           POINT TO LN#LINE ENTRY
         CL    R15,XT#SCRL              VALID LINE NUMBER?
         BLR   R10                      RETURN IF VALID
FI$ERR1  OI    XT#SET,LN#FCHG           FORMAT ERROR - FORCE RESHOW
         L     R1,=A(MSG#NFMT)          SCREEN FORMAT ERROR
         BAL   R14,MSG                  SET MSG
FI$ERR   SR    R3,R3                    SET CC, NO FIELD FOUND
         BR    R10                      AND RETURN
FI$TRT   TRT   0(0,R1),FI#TRTAB         * EXECUTED *
         SPACE 1
FI#TRTAB DC    0D'0',256X'00'
         ORG   FI#TRTAB+X'11'           ONLY STOP ON SBA
         DC    X'04'
         ORG   ,
         SPACE 2
*  MSG: SET MESSAGE ROUTINE
*    ENTRY:  R1 - @ OF AL1(MSG LEN, PRIORITY),C'MESSAGE'
*            R14 - RETURN ADDR
*            (USES 'TEMPDW2')
*  NOTE: IF PRIORITY IS ODD DOES NOT RETURN IF NEW MESSAGE SET,
*        INSTEAD GOES TO REBUILD SCREEN (AFTER SETTING MSG).
*
MSG      ST    R15,TEMPDW2              SAVE A REG
         L     R15,XT@MSG               GET ADDR OF PREVIOUS MSG IF ANY
         LTR   R15,R15                  ANY MESSAGE YET?
         BZ    MSG1
         CLC   1(1,R1),1(R15)           COMPARE PRIORITIES
         L     R15,TEMPDW2              RESTORE WORK REG
         BNHR  R14                      BIF NEW MSG NOT HIGHER PRTY
MSG1     ST    R1,XT@MSG                SET NEW MSG ADDR
         TM    1(R1),X'01'              REBUILD SCREEN REQUIRED?
         BZR   R14                      RETURN IF NO REBUILD REQUIRED
         B     INFULL                   GO REBUILD SCREEN
         EJECT ,
*  R0  - POSITION (0 -> 24*80)  (DESTROYED)
*  R2  - ADDR-1 TO PLACE ADR1,ADR2 CHARACTERS
*  R14 - RETURN ADDR
         SPACE 1
CV$POS   STC   R0,2(,R2)                SET SECOND CHAR
         SRL   R0,6                     GET FIRST CHAR
         STC   R0,1(,R2)                SET FIRST CHAR
         NC    1(2,R2),=X'3F3F'         CLEAN UP CHARS
         L     R15,=A(TAB3270)          @ FOLD TR TABLE
         TR    1(2,R2),0(R15)           MAKE VALID 3270 CHARS
         BR    R14                      AND RETURN
         SPACE 2
*  R0  - ON RETURN CONTAINS POSITION
*  R1  - ADDR-1 OF ADR,ADR2 CHARS
*  R14 - RETURN ADDR
*  R15 - (DESTROYED)
         SPACE 1
CV$POSC  IC    R0,1(,R1)                GET FIRST CHAR
         N     R0,=X'0000003F'          CLEAR GARBAGE
         IC    R15,2(,R1)               GET SECOND CHAR
         N     R15,=X'0000003F'         CLEAR GARBAGE
         SLL   R0,6                     SHIFT TO COMBINE
         OR    R0,R15                   COMBINE TO GET POSITION
         BR    R14                      RETURN
         SPACE 1
SP$TPUT  O     R1,XT#TPUTF              ADD FULLSCR OPTION (OR CTL)
         CL    R0,=F'2100'   *TEMP*   > TCAM BUFFER - FUDGE
******** BNH   *+8           *TEMP*   BIF <= TCAM BUFFER
         B     *+8           *TEMP*   (WAS BNH *+8 - CHECK NOT REQ
********                               WITH VTAM ON MVS)
         EX    0,*           *TEMP*   DIE IF > TCAM BUFFER
         B     *+8
SP$TGET  O     R1,=X'81000000'          MAKE IT A TGET ASIS
         ST    R14,TEMPDW               SAVE RETURN ADDR
         TPUT  (1),(0),R                DO TPUT OR TGET
         L     R14,TEMPDW               RESTORE RETURN ADDR
         BR    R14                      AND RETURN
         SPACE 1
         LTORG ,
         TITLE 'CCNEDFSE - FULLSCR SUBCOMMAND -- UTIO CODE'
UT$RD    ST    R14,TEMPDW               SAVE RETURN ADDR
         EDIO  RC,(R3),BUF1             READ CURRENT RECORD
         L     R14,TEMPDW               RESTORE RETRN ADDR
         LA    R1,BUF1+8                POINT TO RECORD DATA
         BNZR  R14                      RETURN IF ERROR
         LH    R0,BUF1+4                GET LENGTH FROM RDW
         TM    CACFLAG2,CARECFM         FIXED LENGTH RECORDS?
         BO    UT$RDFX                  BIF FIXED LENGTH RECORD
         LH    R0,CALRECL               MAX LENGTH (INCLUDING RDW)
         LR    R15,R0                   COPY MAX LENGTH
         SH    R15,BUF1+4               - THIS REC LENGTH
         BNP   UT$RDAB
         LA    R1,BUF1+4                @ BEGINING OF RECORD
         AH    R1,BUF1+4                POINT TO AREA TO BLANK
         MVI   0(R1),C' '               BLANK 1ST BYTE OF IT
         SH    R15,=H'2'                GET EX LENGTH OF REST
         BNP   UT$RDAB
         EX    R15,UT$RDMV              MVC 1(0,R1),0(R1)
UT$RDAB  LA    R1,BUF1+8                POINT TO RECORD ORIG
UT$RDFX  SH    R0,=H'4'                 - RDW LENGTH
         TM    CACFLAG1,CANONUM         LINE NUMBERED?
         BO    UT$RDNN                  BIF NONUM DATA SET
         SR    R15,R15                  CLEAR FOR IC
         IC    R15,CALENGTH             NUM SEQ LENGTH
         SR    R0,R15                   REAL DATA LENGTH
         CLI   CALINE,1                 SEQ NUM AT COL 1 (ORIG 1)
         BNE   *+6                      BIF SEQ NUM AT END OF REC
         AR    R1,R15                   SKIP SEQ NUMBER AT BEGINING
UT$RDNN  AL    R1,XT#XOFF               WINDOW OVER
         S     R0,XT#XOFF               LENGTH PAST EDGE OF WINDOW
         BP    *+6                      BR IF SOME IN WINDOW
         SR    R0,R0                    NO DATA HERE
         SR    R15,R15                  SET CC TO I/O RESULT
         BR    R14                      AND RETURN
UT$RDMV  MVC   1(0,R1),0(R1)            * EXECUTED *
         SPACE 1
*  R15 - FIRST KEY TO DISPLAY (TOP OF SCREEN)
SETSCRN  OI    XT#SET,LN#FCHG          FORCE SCREEN REFRESH
         LA    R3,XT#LINS              POINT TO FIRST LINE CTL
         USING LN#LINE,R3
         L     R4,XT#SCRL              NUMBER OF LINES
         ST    R15,NEWKEY              SET KEY FOR EDIO
         EDIO  RC,MF=B                 TRY READ CURRENT FIRST
SCR$LP   TM    LN#FLAG,LN#FDAT         DATA LINE?
         BZ    SCR$NXT                 SKIP IF NOT DATA LINE
         OI    LN#FLAG,LN#FVAL         ASSUME EXISTS
SCR$TRY2 EDIO  ,NEWKEY,BUF1            READ RECORD IF EXISTS
         BZ    SCR$VAL                 BR IF EXISTS
         CLI   IOLIST,0                WAS THAT READ CURENT?
         BNE   SCR$NRC                 BIF NOT READ CURRENT
         EDIO  RN,MF=B                 TRY READ NEXT THEN
         B     SCR$TRY2                AND GO TRY IT
SCR$NRC  NI    LN#FLAG,255-LN#FVAL     SET NON-EXISTANT
SCR$VAL  L     R15,BUF1                GET REAL RECORD KEY
         ST    R15,NEWKEY              SET FOR NEXT READ
         ST    R15,LN#PARM             SET FOR OUTPUT RTN
         EDIO  RN,MF=B                 SET TO READ NEXT
SCR$NXT  LA    R3,LN#LINEL(,R3)        TO NEXT LINE
         BCT   R4,SCR$LP               INIT ALL DATA LINES
         BR    R10                     AND RETURN
         DROP  R3                      (LN#LINE)
         SPACE 1
*  'UT$IO' AND 'UT$IO2' ARE CALLED BY THE EDIO MACRO
*    (UT$IO2 USED WHEN OPERAND 2 NOT SUPPLIED)
UT$IO    ST    R1,IOLIST+4             SET PARM 1 VALUE
UT$IO2   ST    R14,TEMPDW+4            SAVE RETURN ADDR
         MVC   IOLIST+1(3),CAPTCDCB+1  SET UTILITY DCB ADDR
         LA    R1,IOLIST               @ PARM LIST FOR I/O RTN
         LR    R0,COMMREG              COMM ADDR
         L     R15,CAPTUT              @ UTILITY I/O ROUTINE
         BALR  R14,R15                 GO TO THE I/O
         CH    R15,=H'8'               REAL I/O ERROR?
         BE    IOERROR                 BIF I/O ERROR
         LTR   R15,R15                 SET CC
         L     R14,TEMPDW+4            RESTORE RETURN ADDR
         BR    R14                     AND RETURN
         TITLE 'CCNEDFSE - FULLSCR SUBCOMMAND -- SCAN SUBROUTINES'
***********************************************************************
*                                                                     *
*  ALL RETURN TO R14; SCANC AND SCANN SET CONDITION CODE;             *
*  REGISTERS USED (MODIFIED): R0, R1, R2, R14, R15                    *
*  HIGH  |  POSITIVE - OPERAND FOUND                                  *
*  EQUAL |  ZERO     - OPERAND OMMITTED                               *
*  LOW   |  MINUS    - INVALID OPERAND (FOR TYPE)                     *
*                                                                     *
*                                                                     *
*   SCAN   - INIT SCAN BXH REGS, ON ENTRY R1 = ADDR, R2 = LEN         *
*   SCANC  - PLACES CHAR STR < 8 LONG IN TEMPDW AND TR TO UC          *
*   SCANN  - RETURNS NUMERIC VALUE IN R15                             *
*                                                                     *
* NOTE: SCAN/C ARE CALLED BEFORE XT#WORK EXISTS.                      *
*                                                                     *
***********************************************************************
         SPACE 1
         DROP  R12                      (XT#WORK)
SCAN     LA    R0,1                     BXH ICR
         XR    R2,R1                    SWAP R2 AND R1
         XR    R1,R2                    TO GET ADDR TO
         XR    R2,R1                    R2; LEN TO R1
         AR    R1,R2                    GET BXH LIMIT + 1
         BCTR  R1,0                     GET BXH LIMIT
         STM   R0,R2,SV#SCAN            SAVE SCAN PTRS
         BR    R14                      AND RETURN
         SPACE 1
SCANC    BAL   R15,SCANX                SKIP LEADING DELIM
         MVI   TEMPDW,C' '              INIT TO BLANKS
         MVC   TEMPDW+1(7),TEMPDW
         LR    R15,R2                   SAVE START ADDR
         BCTR  R2,0                     INIT FOR BXH
SCANC$L  BXH   R2,R0,SCANC$C            TO NEXT CHAR
         CLI   0(R2),C' '               DELIM? (BLANK)
         BE    SCANC$C                  BR IF DELIM
         CLI   0(R2),C'Z'               OR TOO HIGH?
         BNH   SCANC$L                  CONTINUE IF OK
SCANC$C  SR    R2,R15                   GET STRING LENGTH
         BZ    SCAN$RZ                  RETURN OMMITED IF NULL
         CH    R2,=H'8'                 STR TOO LONG?
         BH    SCAN$RM                  RETURN BAD IF TOO LONG
         BCTR  R2,0                     GET EX LEN
         EX    R2,SCANC$MV              MVC TEMPDW(0),0(R15)
         LA    R2,1(R2,R15)             NEW SCAN PTR
         L     R15,=A(UC#TAB)           @ OF TR TABLE
         TR    TEMPDW(8),0(R15)         TO UPPER CASE
         B     SCAN$RP                  AND EXIT, ALL OK
SCANC$MV MVC   TEMPDW(0),0(R15)         * EXECUTED *
         SPACE 1
SCANN    BAL   R15,SCANX                GO SKIP LEADING DELIM
         SR    R15,R15                  INIT NUMBER TO ZERO
         ST    R14,TEMPDW               SAVE RETURN ADDR
         SR    R14,R14                  CLEAR FOR IC
         BCTR  R2,0                     INIT FOR BXH
SCANN$L  BXH   R2,R0,SCANN$E            TO NEXT CHAR
         CLI   0(R2),C'0'               VALID DIGIT
         BL    SCANN$EC                 BIF NOT DIGIT - GO CHECK DELIM
         IC    R14,0(,R2)               GET DIGIT
         N     R14,=X'0000000F'         GET JUST NUMBER
         MH    R15,=H'10'               SCALE PREV SUM
         AR    R15,R14                  NEW NUMBER SO FAR
         B     SCANN$L                  AND CONTINUE
SCANN$EC L     R14,TEMPDW               RESTORE RETURN ADDR
         CLI   0(R2),C' '               VALID DELIM? (BLANK)
         BNE   SCAN$RM                  ERROR IF NOT VALID DELIM
SCANN$E  L     R14,TEMPDW               RESTORE RETURN ADDR
         SPACE 1
SCAN$RP  STM   R0,R2,SV#SCAN            SAVE NEW SCAN PTRS
         LTR   R0,R0                    SET CC POS (CON 1)
         BR    R14                      AND RETURN
         SPACE 1
SCAN$RZ  CR    R15,R15                  SET CC EQ = ZERO
         BR    R14                      AND RETURN
         SPACE 1
SCAN$RM  CLI   *,X'FF'                  SET CC LOW = MINUS
         BR    R14                      AND RETURN
         SPACE 1
SCANX    LM    R0,R2,SV#SCAN            GET SCAN VALUES
         BCTR  R2,0                     INIT FOR BXH
SCANX$L  BXH   R2,R0,SCAN$RZ            TO NXT CHAR / RET IF NONE
         CLI   0(R2),C' '               SKIP OVER DELIM
         BE    SCANX$L                  CONTINUE SKIPPING
         STM   R0,R2,SV#SCAN            UPDATE SCAN PTRS
         ST    R2,SV#SCANP              SAVE INCASE OF ERROR
         BR    R15                      LOCAL RETURN WHEN DONE
         SPACE 1
* R5,R7 - @, LEN END, @ LAST ENT
FIND     SR    R15,R15                  CLEAR FOR IC
FIND$L   IC    R15,0(,R5)               GET CMD EX LEN
         EX    R15,FIND$CLC             CLC TEMPDW(0),1(R5)
         BER   R14                      RETURN IF FOUND
         BXLE  R5,R6,FIND$L             CONTINUE SEARCH
         BR    R14                      RETURN NOT FOUND
FIND$CLC CLC   TEMPDW(0),1(R5)          * EXECUTED *
         USING XT#WORK,R12
         TITLE 'CCNEDFSE - FULLSCR SUBCOMMAND -- EXIT CODE'
***********************************************************************
*                                                                     *
*                         CLEAN UP AND EXIT                           *
*                                                                     *
***********************************************************************
         SPACE 1
EXIT     L     R1,CCNWORD               ADDR TO BE FREED
         LTR   R1,R1                    DOES XT#WORK EXIST?
         B     SKIPFRE1  *TEMP* (NEVER FREE XT#WORK)
         BZ    SKIPFRE1                 NO, SO SKIP FREEMAIN
         L     R0,XT@END-XT#WORK(,R1)   GET ADDR PAST END OF XT#WORK
         SR    R0,R1                    GET LENGTH OF XT#WORK
         O     R0,SPONE                 INDICATE SP=1
         XC    CCNWORD(4),CCNWORD       NO MORE XT#WORK
         FREEMAIN  R,LV=(0),A=(1)       FREE GOTTEN CORE
         SPACE 1
SKIPFRE1 STAX  ,                        REMOVE MY ATTENTION EXIT
         NI    CAATTN,255-CAATTNIS      OFF ATTEN FLAG
         L     R15,RETCODE              LOAD RETURN CODE
         IKJEBERT  (14,12),T,RC=(15)    STD TSO RETURN MACRO
         TITLE 'CCNEDFSE - FULLSCR SUBCOMMAND - MISC EXIT ROUTINES'
***********************************************************************
*                                                                     *
*                         MISC EXIT ROUTINES                          *
*                                                                     *
*  NOTE: RETCDE IS ZEROED AT ENTRY TO CCNEDFSE                        *
*                                                                     *
***********************************************************************
         SPACE 1
LVFULL   TM    XT#FLAG,XT#FSCR          IN FULLSCR MODE?
         BZR   R10                      IF NOT, DO NOTHING
         NI    XT#FLAG,255-XT#FSCR      RESET FULLSCR FLAG
         OI    CACFLAG2,CAMODMSG        PROMPT 'EDIT' AFTER RETURN
         TM    XT#FLAG,XT#FVTAM         VTAM FULLSCR MODE?
         BZ    LVFULLT                  BIF NOT VTAM (TCAM)
         STFSMODE OFF                   OFF VTAM FULLSCR MODE
         BR    R10                      AND RETURN
LVFULLT  LM    R0,R1,=A(LVF#CONL,LVF#CON)  ADR, LEN FOR TPUT
         BAL   R14,SP$TPUT              TPUT TO LEAVE FULLSCR
         BR    R10                      RETURN TO CALLER
         SPACE 3
IOERROR  LA    R15,12                   INDICATE 'DISASTER'
         ST    R15,RETCODE
         B     EXIT$ERR
         SPACE 3
NOCORE   BAL   R10,LVFULL               LEAVE FULLSCREEN MODE
         IKJEBEML  MF=(E,M312LIST)      ISSUE MESSAGE
*+++++   B     FLUSH
         SPACE 1
FLUSH    LA    R15,8                    INDICATE 'FLUSH STACK'
         ST    R15,RETCODE
         OC    CACFLAG1(1),XT#SAVF      RESTORE VERIFY FLAG
EXIT$ERR BAL   R10,LVFULL               LEAVE FULLSCR MODE
         B     EXIT                     AND EXIT
         SPACE 3
GTSZERR  LA    R14,GTSZINS              POINT TO NAME INSERT
         B     SYSERROR                 GO BUILD MESSAGE
         SPACE 3
PUTLERR  LA    R14,PUTLINS              POINT TO NAME INSERT
         B     SYSERROR                 GO BUILD MESSAGE
         SPACE 3
STCKERR  LA    R14,STCKINS              POINT TO NAME INSERT
         B     SYSERROR                 GO BUILD MESSAGE
         SPACE 3
PERROR   LA    R14,PARSINS              POINT TO NAME INSERT
SYSERROR MVC   MSGWORK1(12),M313LIST    INITIALIZE MESSAGE
         MVC   MSGWORK2(16),INS3131     INITIALIZE 1ST INSERT
         MVC   MSGWORK3(10),INS3132     INITIALIZE 2ND INSTERT
         MVC   MSGWORK2+5(1),0(R14)     MOVE LENGTH OF NAME INSERT
         MVC   MSGWORK2+8(8),1(R14)     MOVE NAME TO MESSAGE SEG
         LA    R1,MSGWORK2              ADDR OF 1ND INSERT  (M3131)
         ST    R1,MSGWORK1+8            CHAIN MSG TO 1ST
         LA    R1,MSGWORK3              ADDR OF 2ND INSERT  (M3132)
         ST    R1,MSGWORK2              CHAIN 1ST TO 2ND
         CVD   R15,TEMPDW               CONVERT RC TO DECIMAL
         UNPK  MSGWORK3+8(2),TEMPDW(8)  PUT RC INTO INSERT (M3132)
         OI    MSGWORK3+9,X'F0'         FIX UP ZONE BITS
         BAL   R10,LVFULL               LEAVE FULL SCREEN MODE
         IKJEBEML  M313,MF=(E,MSGWORK1) ISSUE MESSAGE
         B     FLUSH
         SPACE 3
BADTERM  PUTLINE  PARM=PTPB,OUTPUT=MSG#1,MF=(E,CATMPLST)
* CHECK ERRORS
         B     FLUSH                    QUIT
         TITLE 'CCNEDFSE - FULLSCR SUBCOMMAND - CONSTANTS'
***********************************************************************
*                                                                     *
*                          PROGRAM CONSTANTS                          *
*                                                                     *
***********************************************************************
         SPACE 1
TRUEBASE DC    A(CCNEDFSE)              BASEADDR WITH ZERO OFFSET
SPONE    DC    0F'0',X'01000000'        MASK TO INDICATE SUBPOOL ONE
PARSINS  DC    AL1(9),CL8'PARSE'        RTN NAME FOR MSG INSERT
PUTLINS  DC    AL1(11),CL8'PUTLINE'     RTN NAME FOR MSG INSERT
STCKINS  DC    AL1(9),CL8'STACK'        RTN NAME FOR MSG INSERT
GTSZINS  DC    AL1(10),CL8'GTSIZE'      RTN NAME FOR MSG INSERT
MSG#1    DC    F'1',A(*+4),AL2(L'MSG#1T+4,0)
MSG#1T   DC    C'FSE001 TERMINAL TYPE NOT SUPPORTED'
         SPACE 3
         LTORG
         TITLE 'CCNEDFSE - FULLSCR SUBCOMMAND - MESSAGE MACROS'
         SPACE 1
         PRINT GEN
         IKJEBEMI (312,313)
         SPACE 4
M312LIST IKJEBEML M312,,INS312,,MF=L
         SPACE 1
INS312   IKJEBEMG 0,M312IN1,'FULLSCR'
         SPACE 3
M313LIST IKJEBEML M313,M3131,,INS3131,MF=L
         SPACE 1
INS3131  IKJEBEMG INS3132,M3131IN1,'IKJ12345'
         SPACE 1
INS3132  IKJEBEMG 0,M3131IN2,'99'
         PRINT GEN
         EJECT
         DC    0D'0'
*  6 BIT CODE TO EBCDIC (3270 VALID CODES)
TAB3270  DC    X'40C1C2C3C4C5C6C7C8C94A4B4C4D4E4F'  (00,40,80,C0)
         DC    X'50D1D2D3D4D5D6D7D8D95A5B5C5D5E5F'  (10,50,90,D0)
         DC    X'6061E2E3E4E5E6E7E8E96A6B6C6D6E6F'  (20,60,A0,E0)
         DC    X'F0F1F2F3F4F5F6F7F8F97A7B7C7D7E7F'  (30,70,B0,F0)
         SPACE 1
*---   TRT TABLE FOR INVALID CHARACTERS (UC/LC)                    ---*
*                   0 1 2 3 4 5 6 7 8 9 A B C D E F
VAL#LC   DC    XL16'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'       0
         DC    XL16'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'       1
         DC    XL16'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'       2
         DC    XL16'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'       3
         DC    XL16'00FFFFFFFFFFFFFFFFFF000000000000'       4
         DC    XL16'00FFFFFFFFFFFFFFFFFF000000000000'       5
         DC    XL16'0000FFFFFFFFFFFFFFFF000000000000'       6
         DC    XL16'FFFFFFFFFFFFFFFFFF00000000000000'       7
         DC    XL16'FF000000000000000000FFFFFFFFFFFF'       8
         DC    XL16'FF000000000000000000FFFFFFFFFFFF'       9
         DC    XL16'FFFF0000000000000000FFFFFFFFFFFF'       A
         DC    XL16'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'       B
         DC    XL16'00000000000000000000FFFFFFFFFFFF'       C
         DC    XL16'00000000000000000000FFFFFFFFFFFF'       D
         DC    XL16'FFFF0000000000000000FFFFFFFFFFFF'       E
         DC    XL16'00000000000000000000FFFFFFFFFFFF'       F
         SPACE 1
*---   TRT TABLE FOR INVALID CHARACTERS (UC ONLY)                  ---*
*                   0 1 2 3 4 5 6 7 8 9 A B C D E F
VAL#UC   DC    XL16'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'       0
         DC    XL16'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'       1
         DC    XL16'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'       2
         DC    XL16'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'       3
         DC    XL16'00FFFFFFFFFFFFFFFFFF000000000000'       4
         DC    XL16'00FFFFFFFFFFFFFFFFFF000000000000'       5
         DC    XL16'0000FFFFFFFFFFFFFFFF000000000000'       6
         DC    XL16'FFFFFFFFFFFFFFFFFF00000000000000'       7
         DC    XL16'FF010101010101010101FFFFFFFFFFFF'       8
         DC    XL16'FF010101010101010101FFFFFFFFFFFF'       9
         DC    XL16'FFFF0101010101010101FFFFFFFFFFFF'       A
         DC    XL16'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'       B
         DC    XL16'00000000000000000000FFFFFFFFFFFF'       C
         DC    XL16'00000000000000000000FFFFFFFFFFFF'       D
         DC    XL16'FFFF0000000000000000FFFFFFFFFFFF'       E
         DC    XL16'00000000000000000000FFFFFFFFFFFF'       F
         SPACE 1
*---                TRANSLATE LOWER CASE TO UPPER CASE             ---*
*                   0 1 2 3 4 5 6 7 8 9 A B C D E F
UC#TAB   DC    XL16'6F6F6F6F6F6F6F6F6F6F6F6F6F6F6F6F'       0
         DC    XL16'6F6F6F6F6F6F6F6F6F6F6F6F6F6F6F6F'       1
         DC    XL16'6F6F6F6F6F6F6F6F6F6F6F6F6F6F6F6F'       2
         DC    XL16'6F6F6F6F6F6F6F6F6F6F6F6F6F6F6F6F'       3
         DC    XL16'406F6F6F6F6F6F6F6F6F4A4B4C4D4E4F'       4
         DC    XL16'506F6F6F6F6F6F6F6F6F5A5B5C5D5E5F'       5
         DC    XL16'60616F6F6F6F6F6F6F6F6A6B6C6D6E6F'       6
         DC    XL16'6F6F6F6F6F6F6F6F6F797A7B7C7D7E7F'       7
         DC    XL16'6FC1C2C3C4C5C6C7C8C96F6F6F6F6F6F'       8
         DC    XL16'6FD1D2D3D4D5D6D7D8D96F6F6F6F6F6F'       9
         DC    XL16'6F6FE2E3E4E5E6E7E8E96F6F6F6F6F6F'       A
         DC    XL16'6F6F6F6F6F6F6F6F6F6F6F6F6F6F6F6F'       B
         DC    XL16'C0C1C2C3C4C5C6C7C8C96F6F6F6F6F6F'       C
         DC    XL16'D0D1D2D3D4D5D6D7D8D96F6F6F6F6F6F'       D
         DC    XL16'6F6FE2E3E4E5E6E7E8E96F6F6F6F6F6F'       E
         DC    XL16'F0F1F2F3F4F5F6F7F8F96F6F6F6F6F6F'       F
         SPACE 1
ST#LIN   DC    C'----+----1----+----2----+----3----+----4'
         DC    C'----+----5----+----6----+----7----+----8'
         DC    C'----+----9----+---10----+---11----+---12'
         DC    C'----+---13----+---14----+---15----+---16'
         DC    C'----+---17----+---18----+---19----+---20'
         DC    C'----+---21----+---22----+---23----+---24'
         DC    C'----+---25----+'
         SPACE 1
* AL1(EX COMPARE LENGTH),CL8'CMD',X'FLAGS',Y(RTN OFFSET)
* FLAGS - OFFSET IN XT# OF VALUE IF ANY
CMD#T    DC    0H'0'                   ALIGN CMD TABLE
CMD#PF03 DC    AL1(07),CL8'END     ',X'00',Y(FLUSH-$)
CMD#TL   EQU   *-CMD#T                  ENTRY LENGTH
CMD#PF07 DC    AL1(07),CL8'UP      ',X'01',Y(C$U-$)
         DC    AL1(07),CL8'U       ',X'01',Y(C$U-$)
CMD#PF08 DC    AL1(07),CL8'DOWN    ',X'02',Y(C$D-$)
         DC    AL1(07),CL8'D       ',X'02',Y(C$D-$)
CMD#PF10 DC    AL1(07),CL8'LEFT    ',X'03',Y(C$L-$)
         DC    AL1(07),CL8'L       ',X'03',Y(C$L-$)
CMD#PF11 DC    AL1(07),CL8'RIGHT   ',X'04',Y(C$R-$)
         DC    AL1(07),CL8'R       ',X'04',Y(C$R-$)
         DC    AL1(07),CL8'POSITION',X'80',Y(C$P-$)
         DC    AL1(07),CL8'P       ',X'80',Y(C$P-$)
         DC    AL1(07),CL8'COL     ',X'80',Y(C$COL-$)
         DC    AL1(07),CL8'SEQ     ',X'80',Y(C$SEQ-$)
         DC    AL1(07),CL8'TOP     ',X'00',Y(C$T-$)
         DC    AL1(07),CL8'T       ',X'00',Y(C$T-$)
         DC    AL1(07),CL8'BOTTOM  ',X'00',Y(C$B-$)
         DC    AL1(07),CL8'B       ',X'00',Y(C$B-$)
CMD#PF01 DC    AL1(07),CL8'HELP    ',X'00',Y(C$HELP-$)
CMD#PF12 DC    AL1(07),CL8'HOME    ',X'00',Y(C$HOME-$)
         DC    AL1(07),CL8'TABC    ',X'00',Y(C$TABC-$)
         DC    AL1(07),CL8'TABS    ',X'00',Y(C$TABS-$)
         DC    AL1(07),CL8'TABH    ',X'00',Y(C$TABH-$)
         DC    AL1(07),CL8'NULLS   ',X'00',Y(C$NULLS-$)
         DC    AL1(07),CL8'FCOPY   ',X'00',Y(C$FCO-$)
         DC    AL1(07),CL8'FCO     ',X'00',Y(C$FCO-$)
         DC    AL1(07),CL8'FMOVE   ',X'00',Y(C$FMO-$)
         DC    AL1(07),CL8'FMO     ',X'00',Y(C$FMO-$)
         DC    AL1(07),CL8'FDELETE ',X'00',Y(C$FDEL-$)
         DC    AL1(07),CL8'FDEL    ',X'00',Y(C$FDEL-$)
CMD#TE   EQU   *-CMD#TL                 @ LAST TABLE ENTRY
         SPACE 1
PFK#T    DC    0H'0'
         DC    AL1(00),X'F1',Y(CMD#PF01-$)
PFK#TL   EQU   *-PFK#T
         DC    AL1(00),X'F3',Y(CMD#PF03-$)
         DC    AL1(00),X'F7',Y(CMD#PF07-$)
         DC    AL1(00),X'F8',Y(CMD#PF08-$)
         DC    AL1(00),X'7A',Y(CMD#PF10-$)
         DC    AL1(00),X'7B',Y(CMD#PF11-$)
         DC    AL1(00),X'7C',Y(CMD#PF12-$)
PFK#TE   EQU   *-PFK#TL
         SPACE 1
SEQ#T    DC    AL1(00),CL3'I  ',Y(SEQ$I-$)   @ FIRST TABLE ENTRY
SEQ#TL   EQU   *-SEQ#T                  LENGTH OF ONE ENTRY
         DC    AL1(00),CL3'D  ',Y(SEQ$D-$) DELETE
         DC    AL1(00),CL3'R  ',Y(SEQ$R-$) REPLICATE
SEQ#TE   EQU   *-SEQ#TL                 @ LAST TABLE ENTRY
         SPACE 1
LVF#CON  DC    X'C3115D7E114040'        LEAVE FULLSCR MODE
         DC    X'3C404000'                  ERASE SCREEN
         DC    X'1D40'                      SF,ATTR
         DC    X'1140C113'                  CURSOR TO FIRST FIELD DATA
LVF#CONL EQU   *-LVF#CON                    LENGTH OF STRING
         TITLE 'CCNEDFSE - FULLSCR SUBCOMMAND -- LINE ROUTINES'
         USING LN#LINE,R3
         USING R$ODAT1,R8               (LOCAL BASE)
*  R4 = XT#SCRL - LINE NUMBER
R$ODAT1  TM    LN#FLAG,LN#FVAL          VALID RECORD?
         BZ    ROD1$NV                  BIF NOT VALID RECORD
         CLC   LN#PARM,XT#CURSQ         CURSOR POSITION TO MY LINE?
         BNE   ROD1$NC                  BIF NO CURSOR POS HERE
         L     R1,XT#SCRL               GET LINES / SCREEN
         SR    R1,R4                    GET MY LINE NUMBER
         MH    R1,XT#SCRC+2             GET POS TO BEGINING OF LINE
         A     R1,XT#SEQL               + SEQ FIELD LENGTH
         LA    R1,1(,R1)                SKIP OVER DATA ATTR
         STH   R1,XT#CUR                POSITION CURSOR THERE.....
         SPACE 1
ROD1$NC  LA    R2,3(,R2)                SKIP SBA,ADR1,ADR2
         L     R7,XT#SCRC               COLUMNS / LINE
         L     R5,XT#SEQL               SEQUENCE FIELD LENGTH
         LTR   R6,R5                    COPY AND TEST
         BNP   ROD1$NS                  BR IF NO SEQ FIELD
         BCTR  R5,0                     SEQ NUMBER LENGTH (NO ATTR)
         BCTR  R5,0                     SEQ EX LEN
         L     R15,LN#PARM              GET RECORD NUMBER
         CVD   R15,TEMPDW               TO DEC
         SLL   R5,4                     TO POSITION FOR EX
         EX    R5,ROD1$UP               UNPK 2(0,R2),TEMPDW(8)
         SR    R7,R6                    - LEN OF SEQ FIELD
         AR    R2,R6                    + LEN OF SEQ FIELD
         OI    0(R2),C'0'               FIX ZONE IN LAST DIGIT
         LA    R2,1(,R2)                ACCOUNT FOR SF
         SPACE 1
ROD1$NS  BAL   R14,UT$RD                READ RECORD
         LA    R6,2                     TABS ORIG 1,ATTR BEFORE TAB POS
         A     R6,XT#XOFF               GET MY POSITION ON LINE
         LA    R5,=X'00'                ASSUME NO HARDWARE TABS
         TM    XT#OPT,XT#FTABH+XT#FTAB  HARDWARE TABS ON?
         BNO   ROD1$NT                  BIF TABS NOT ON
         TM    LN#FLAG,LN#FNTAB         NO TABS THIS LINE?
         BO    ROD1$NT                  BIF NO TABS THIS LINE
         LA    R5,CATABS+1              INIT TAB PTR
ROD1$NT  XC    LN#HTABM,LN#HTABM        NO TABS ON SCREEN YET
         NI    LN#FLAG,255-LN#FNTAB     CAN HAVE TABS NEXT TIME
         SPACE 1
ROD1$LP  LTR   R7,R7                    ROOM FOR NEW FIELD?
         BNPR  R10                      BR IF LINE ALREADY FULL
         MVC   0(2,R2),=X'1D40'         SET SF,ATTR
         BCTR  R7,0                     SPACE LEFT AFTER ATTR
         LTR   R15,R0                   COPY/TEST DATA LENGTH LEFT
         BNP   ROD1$ND                  BIF NO DATA LEFT
*  FIND NEXT HARDWARE TAB POSITION
ROD1$TLP SR    R14,R14                  CLEAR FOR IC
         IC    R14,0(,R5)               GET TAB POS ORIG 1
         LTR   R14,R14                  ANY TAB POSITION?
         BZ    ROD1$TNO                 BIF NO TAB POSITION
         SR    R14,R6                   DATA LEN TO TAB POS (ATTR)
         BNM   ROD1$THV                 BIF HAVE TAB POSITION
ROD1$TNX LA    R5,1(,R5)                TO NEXT TAB IN CATABS
         B     ROD1$TLP                 CONTINUE TAB SEARCH
ROD1$THV CR    R14,R15                  TAB POS :: DATA LEN LEFT
         BNL   ROD1$TNO                 BIF TAB PAST END OF RECORD
         ST    R1,TEMPDW                SAVE R1 FOR TEST
         AR    R1,R14                   POINT TO TAB POS IN DATA
         CLI   0(R1),C' '               BLANK AT TAB POSITION?
         L     R1,TEMPDW                RESTORE R1
         BNE   ROD1$TNX                 BIF NOT BLANK TO TRY NEXT TAB
         LR    R15,R14                  USE LENGTH TO TAB
         LA    R14,CATABS+1             GET TAB NUMBER ORIG
         SR    R14,R5                   GET - TAB NUMBER
         LCR   R14,R14                  GET BIT NUMBER
         ST    R5,TEMPDW                TEMP SAVE R5
         L     R5,=X'00008000'          GET A BIT
         SRL   R5,0(R14)                GENERATE THE BIT TO SET
         LH    R14,LN#HTABM             GO SET THE
         OR    R14,R5                   BIT
         STH   R14,LN#HTABM             OF TABS FORMATED ON SCREEN
         L     R5,TEMPDW                RESTORE R5
ROD1$TNO CR    R15,R7                   DATA SEG LEN :: LEN ON LINE
         BL    *+6                      USE LOWEST
         LR    R15,R7                   LEN LEFT ON LINE IS LOWEST
         BCTR  R15,0                    GET EX LEN
         LTR   R15,R15                  CHECK FOR ZERO LENGTH MOVE
         BM    ROD1$NDT                 BIF NO DATA TO MOVE
         EX    R15,ROD1$MV              MVC 2(0,R2),0(R1)
*---    TRT FOR INVALID CHARACTERS (OR LC)                         ---*
         STM   R1,R2,TEMPDW             SAVE REGS CLOBBERED BY TRT
ROD1$CCK L     R14,=A(VAL#UC)           ASSUME NOT ASIS MODE
         TM    CACFLAG1,CACAPS          UPPER CASE ONLY?
         BO    *+8                      BIF UPPER CASE ONLY
         L     R14,=A(VAL#LC)           USE LOWER CASE TABLE
         EX    R15,ROD1$TRT             TRT 2(0,R2),0(R14)
* R1,R2 ONLY CLOBBERED IF CC NOT ZERO
         BZ    ROD1$CKN                 BIF ALL VALID CHARS (NOW)
         MVI   0(R1),C'?'               FIX INVALID CHAR
         L     R1,=A(MSG#BADC)          ASSUME WAS BAD CHAR
         N     R2,=X'000000FE'          ZERO IF WAS LC
         BNZ   *+8                      BIF WAS BAD CHAR
         L     R1,=A(MSG#LOWC)          WAS LOWER CASE CHAR
         BAL   R14,MSG                  GO SET MSG
         LM    R1,R2,TEMPDW             RESTORE TRT CLOBBERED REGS
         MVI   1(R2),X'C8'              CHANGE TO HIGH INTENSITY
         B     ROD1$CCK                 AND GO CHECK AGAIN
ROD1$CKN TM    XT#OPT,XT#FNULS          NULLS ON?
         BZ    ROD1$NDT                 BIF NULLS OPTION OFF
         STM   R15,R3,12+4(R13)         SAVE SOME REGS
         L     R0,=F'-1'                BXH DCR
         LA    R1,1(,R2)                BXH LIMIT (@ DATA - 1)
         LA    R3,2(R15,R2)             BXH PTR (LEN-1+ADR-2+2)
         LR    R14,R3                   SAVE INITIAL PTR VALUE
ROD1$NU1 CLI   0(R3),C' '               SCAN TRAILING BLANKS
         BNE   *+8                      BIF NON BLANK FOUND
         BXH   R3,R0,ROD1$NU1           BIF MORE TO SCAN
         SR    R14,R3                   GET LENGTH OF TRAILING BLANKS
         BZ    ROD1$NU2                 BIF NO TRAILING BLANKS
         CH    R14,=H'5'                MANY TRAILING BLANKS?
         BH    ROD1$NU3                 BIF MANY (USE RA)
         BCTR  R14,0                    GET LENGTH - 1
         EX    R14,ROD1$NUX             XC 1(0,R3),1(R3)
ROD1$NU2 LM    R15,R3,12+4(R13)         RESTORE REGS
ROD1$NDT LA    R2,2+1(R2,R15)           SKIP SF,ATTR,DATA (LEN -1)
ROD1$NUD LA    R15,1+1(,R15)            +1 EX LEN, +1 FOR ATTR TAB
         SR    R0,R15                   GET NEW DATA LEN LEFT
         AR    R1,R15                   NEW POSITION IN RECORD
         LA    R7,1(,R7)                ALREADY COUNTED ATTR BYTE
         SR    R7,R15                   NEW LEN LEFT ON LINE
         AR    R6,R15                   NEW POSITION ON SCREEN
         B     ROD1$LP                  AND RETURN
         SPACE 1
ROD1$NU3 L     R0,XT#SCRL               LINES / SCREEN
         SR    R0,R4                    GET MY LINE NUMBER
         MH    R0,XT#SCRC+2             GET MY LINE POSITION
         A     R0,XT#SCRC               POSITION PAST MY LINE
         SR    R0,R7                    - SPACE LEFT ON LINE
         AH    R15,=H'1'                SPACE ON LINE FOR DATA + NULLS
         AR    R0,R15                   END POSITION FOR RA
         SR    R15,R14                  LEN -1 OF DATA WITHOUT NULLS
         LA    R2,2(R15,R2)             SKIP OVER DATA + ATTR BYTE
         BAL   R14,CV$POS               SET ADR1,ADR2 FOR RA
         MVI   0(R2),X'3C'              SET RA OPERATION
         MVI   3(R2),0                  REPEAT NULLS
         LA    R2,4(,R2)                SKIP OVER RA
         LM    R15,R1,12+4(R13)         RESTORE R15 - R1
         L     R3,12+8+4*R3(,R13)       AND R3
         B     ROD1$NUD                 AND CONTINUE
         SPACE 1
ROD1$ND  MVI   1(R2),X'E8'              PROT. HIGH INTENS. ATTR
         BCTR  R7,0                     GET EX LEN
         LTR   R7,R7                    LINE FULL AFTER ATTR?
         BM    ROD1$LF                  BIF LINE FULL AFTER ATTR
         EX    R7,ROD1$XC               XC 2(0,R2),2(R2) MAKE NULLS
         MVI   2(R2),C'|'               MARK RIGHT MARGIN
ROD1$LF  LA    R2,1+2(R2,R7)            SKIP SF,ATTR,NULLS
         BR    R10                      AND RETURN
ROD1$NV  TM    XT#FLAG,XT#FEOF          DISPLAYED EOF YET?
         BOR   R10                      JUST RETURN IF HAVE
         MVC   4(ROD1#EFL,R2),ROD1#EF   SET EOF MSG AFTER SBA,AD1,AD2
         LA    R2,ROD1#EFL+4(,R2)       PAST SBA,AD1,AD2 AND MSG
         MVI   0(R2),X'3C'              SET RA ORDER
         L     R0,XT#SCRL               LINES / SCREEN
         BCTR  R0,0                     LAST LINE
         MH    R0,XT#SCRC+2             POSITION OF LAST LINE
         BCTR  R0,0                     LAST CHAR BEFORE LAST LINE
         BAL   R14,CV$POS               SET RA ADDR1,ADDR2
         MVI   3(R2),0                  REPEAT NULLS
         LA    R2,4(,R2)                SKIP OVER RA
         OI    XT#FLAG,XT#FEOF          ONLY DO THIS ONCE PER SCREEN
         BR    R10
ROD1$UP  UNPK  2(0,R2),TEMPDW(8)        * EXECUTED *
ROD1$XC  XC    2(0,R2),2(R2)            * EXECUTED *
ROD1$MV  MVC   2(0,R2),0(R1)            * EXECUTED *
ROD1$TRT TRT   2(0,R2),0(R14)           * EXECUTED *
ROD1$NUX XC    1(0,R3),1(R3)            * EXECUTED *
         DROP  R3,R8                    (LN#LINE,R$ODAT1)
ROD1#EF  DC    X'E8'                    PROT. HIGH INTENS. ATTR
         DC    C'  <<END OF FILE>>'     MSG
ROD1#EFL EQU   *-ROD1#EF                LENGTH OF STRING
         EJECT ,
*  R1 = ADDR, R2 = LEN, R14 = POSITION ON LINE
         USING LN#LINE,R3
         USING R$IDAT1,R8               (LOCAL BASE)
R$IDAT1  OI    LN#FLAG,LN#FCHG          FORCE REWRITE OF LINE
         BCTR  R14,0                    TO DATA ORIG 0
         SL    R14,XT#SEQL              - SPACE USED BY SEQ FIELD
         BNM   RID1$DAT                 BR IF IN DATA FIELD
         BAL   R14,SCAN                 SCAN FOR COMMAND
         BAL   R14,SCANC                GET CMD IF ANY
         BNP   RID1$SN                  GO CHECK IF NUM
         LM    R5,R7,=A(SEQ#T,SEQ#TL,SEQ#TE) FIND PARMS
         BAL   R14,FIND                 FIND COMMAND
         BNER  R10                      RETURN IF INVALID
         LH    R5,4(,R5)                GET CMD OFFSET
         B     $(R5)                    GO TO CMD RTN
RID1$SN  BAL   R14,SCANN                GET NEW SEQ NUM
         BNPR  R10                      RETURN IF NO NUM
         L     R1,XT#SEQL               GET SEQ FIELD LENGTH
         SLL   R1,2                     * 4 FOR INDEX
         L     R1,RID1#SQ(R1)           GET 10**(SEQFL-1)
         SR    R4,R4                    CLEAR FOR DIVIDE
         L     R5,LN#PARM               GET CURRENT SEQ NUM
         DR    R4,R1                    GET NUM/(10**(SEQFL-1))
         MR    R4,R1                    GET INVISIBLE DIGITS ONLY
         AR    R15,R5                   ADD IN INVISIBLE DIGITS
         CL    R15,LN#PARM              JUST SAME SEQ NUM?
         BER   R10                      RETURN IF SAME
         ST    R15,NEWKEY               SAVE NEW KEY
         EDIO  RC,NEWKEY,BUF1           DOES NEW EXIST?
         BZR   R10                      RETURN IF EXISTS
         EDIO  RC,(R3),BUF1             READ CURRENT REC
         MVC   BUF1(4),NEWKEY           SET NEW KEY
         EDIO  W,BUF1                   ADD NEW RECORD
         EDIO  DLT,(R3)                 DELETE CUR RECORD
         MVC   LN#PARM(4),NEWKEY        SET KEY FOR DATA INPUT
         OI    XT#FLAG,XT#FSS           SET CALL SETSCRN FLAG
         BR    R10                      AND RETURN
SEQ$D    TM    LN#FLAG,LN#FVAL          VALID?
         BZR   R10                      RETURN IF NOT VALID
         EDIO  DLT,(R3)                 DELETE RECORD
         OI    XT#FLAG,XT#FSS           FORCE SETSCRN CALL
         BR    R10                      AND RETURN
SEQ$I    SR    R6,R6                    IS INSERT NOT REPLICATE
SEQ$IR   TM    LN#FLAG,LN#FVAL          VALID?
         BZR   R10                      RETURN IF NOT VALID
         BAL   R14,SCANN                GET NUM TO INSERT
         BNP   SEQ$IR1                  BIF NOT SPECIFIED
         LTR   R5,R15                   COPY / TEST NUMBER
         BNP   SEQ$IR1                  BIF NOT POSITIVE NUM
         C     R5,LN#PARM               INSERT NUM :: SEQ NUMBER
         BE    SEQ$IR1                  BIF HE FORGOT A BLANK
         L     R7,XT#SCRL               LINES / SCREEN
         SH    R7,=H'3'                 MAX INSERT ALLOWED
         CR    R5,R7                    VALID INSERT NUM?
         BL    *+8                      BIF VALID
SEQ$IR1  LA    R5,1                     ELSE INSERT ONLY 1
         OI    XT#FLAG,XT#FIMC          SET INSERT/MOVE/COPY FLAG
         STC   R5,LN#INNUM              SAVE NUMBER TO INSERT
         IC    R0,LN#FLAG               GET FLAG
         OR    R0,R6                    ADD REPLICATE IF REQUIRED
         STC   R0,LN#FLAG               SAVE NEW FLAG VALUE
         BR    R10                      AND RETURN
SEQ$R    LA    R6,LN#FREP               IS REPLICATE
         B     SEQ$IR
         EJECT ,
*   DATA INPUT ROUTINE:
*    R1  - INPUT DATA ADDR
*    R2  - INPUT DATA LENGTH
*    R3  - LN#LINE BASE
*    R8  - LOCAL BASE
*    R10 - RETURN ADDR
*    R14 - OFFSET ON DATA PART OF LINE
*  WORK REGS: R0,R1,R2,R4,R5,R6,R7,R14,R15
*
*  INPUT LINE LENGTH IS XT#SCRC-XT#SEQL-1
*
RID1$DAT LR    R7,R14                   SAVE LINE OFFSET (ORIG 0)
         OI    LN#FLAG,LN#FCHG          FORCE REWRITE OF LINE
         LR    R6,R1                    SAVE INPUT ADDR
         LR    R5,R2                    SAVE INPUT LENGTH
         BAL   R14,UT$RD                GO READ RECORD
         BNZR  R10                      IGNORE IF NO RECORD
*  R1 -  @ RECORD, R0 - DATA LENGTH (WINDOWED XT#XOFF)
         AR    R1,R7                    PT TO FIELD IN RECORD
         SR    R0,R7                    LENGTH LEFT IN RECORD
         BNPR  R10                      RETURN IF NOT IN RECORD
         L     R4,XT#SCRC               COLS / LINE
         S     R4,XT#SEQL               - SEQ FIELD LENGHT
         BCTR  R4,0                     - ATTR BYTE LENGTH
*  R4 - LENGTH OF INPUT DATA AREA
* FIND LENGTH OF THIS FIELD ON SCREEN (NEXT HARD TAB POS)
         ST    R5,TEMPDW                TEMP SAVE R5
         LH    R15,LN#HTABM             GET TAB EXISTS BIT MASK
         SLL   R15,16                   TO HIGH ORDER 16 BITS
         LA    R5,CATABS+1              POINT TO FIRST TAB
RID1$TLP ALR   R15,R15                  TEST TOP BIT/SHIFT LEFT 1
         BC    4,RID1$TNX               BIF NO CARRY, NOT ZERO
         BC    8,RID1$TNO               BIF NO CARRY, ZERO (NO TABS)
         SR    R14,R14                  CLEAR FOR IC
         IC    R14,0(,R5)               GET TAB POSITION (ORIG 1)
         BCTR  R14,0                    GET ORIG 0
         S     R14,XT#XOFF              WINDOW IT
         CR    R14,R7                   AFTER INPUT POSITION?
         BH    RID1$TFD                 BIF AFTER INPUT POSITION
RID1$TNX LA    R5,1(,R5)                TO NEXT TAB
         B     RID1$TLP                 CONTINUE TAB SEARCH
RID1$TFD SR    R14,R7                   GET LENGTH OF INPUT FIELD
         CR    R4,R14                   IS WINDOW SHORTER?
         BNH   *+6                      BIF WINDOW SHORTER (OR EQ)
         LR    R4,R14                   ELSE USE FIELD LENGTH
*---  PRE-BLANK INPUT FIELD AREA IN RECORD                         ---*
RID1$TNO MVI   0(R1),C' '               MAKE A BLANK
         SH    R4,=H'2'                 GET LEN LEFT -1 FOR EX
         BM    *+8                      BIF WAS ONLY ONE BLANK
         EX    R4,RID1$MVB              MVC 1(0,R1),0(R1)
*--- SCAN INPUT FOR SOFT TABS; MOVE DATA TO RECORD                 ---*
         L     R5,TEMPDW                RESTORE R5
         BCTR  R5,0                     GET EX LENGTH
         LR    R15,R1                   COPY RECORD ADDR
RID1$TSL LTR   R5,R5                    TEST INPUT LENGTH - 1 LEFT
         BM    RID1$UP                  BIF NO INPUT LEFT
         SR    R2,R2                    INIT FOR TRT
         LA    R1,1(R5,R6)              PAST LAST BYTE OF INPUT
*--- TRT MODIFIES R1 AND R2                                        ---*
         TM    XT#OPT,XT#FTABS+XT#FTAB  SOFT TABS ON?
         BNO   *+8                      DON'T TRT IF TABS NOT ON
         EX    R5,RID1$TRT              TRT 0(0,R6),XT#TABTR
         SR    R1,R6                    GET LENGTH SCANNED
         BZ    RID1$TNS                 BIF NONE SCANNED
         BCTR  R1,0                     GET EX LEN OF STUFF SCANNED
         EX    R1,RID1$MV               MVC 0(0,R15),0(R6)
         L     R14,=A(UC#TAB)           @ LC TO UC TR TABLE
         TM    CACFLAG1,CACAPS          TRANSLATE TO UC?
         BZ    *+8                      BR IF NO TRANS. REQUIRED
         EX    R1,RID1$TR               TR 0(0,R15),0(R14)
         LA    R1,1(,R1)                GET INPUT LENGTH BACK
RID1$TNS AR    R1,R2                    + 1 IF WAS TAB CHAR
         AR    R15,R1                   NEW POINTER INTO RECORD
         AR    R7,R1                    NEW POSITION ON SCREEN
         AR    R6,R1                    NEW POINTER INTO INPUT
         SR    R5,R1                    NEW LEN INPUT LEFT - 1
         LTR   R2,R2                    WAS THIS A TAB CHAR?
         BZ    RID1$UP                  BIF TAB CHAR
*---      SOFT TAB EXISTS IN INPUT                                 ---*
RID1$TS  LA    R1,CATABS+1              POINT TO FIRST TAB
RID1$TSS SR    R2,R2                    CLEAR FOR IC
         IC    R2,0(,R1)                GET NEXT TAB POSITION ORIG 1
         LTR   R2,R2                    ANY TAB?
         BZ    RID1$UP                  BIF MORE NO MORE TABS ON LINE
         BCTR  R2,0                     GET TAB ORIG 0
         S     R2,XT#XOFF               WINDOW TAB
         SR    R2,R7                    TAB POS :: CURRENT POS
         BNM   RID1$TSF                 BIF FOUND TAB POSITION
         LA    R1,1(,R1)                TO NEXT TAB POSITION
         B     RID1$TSS                 CONTINUE SEARCH
RID1$TSF AR    R7,R2                    TAB POSITION ON SCREEN
         AR    R15,R2                   TAB POSITION IN RECORD
         B     RID1$TSL                 AND CONTINUE
         SPACE 1
*---       ALL INPUT PROCESSED - UPDATE RECORD                     ---*
RID1$UP  TM    CACFLAG2,CARECFM         FIXED LENGTH RECORDS?
         BO    RID1$VFX                 BIF FIXED LENGTH
         LH    R2,CALRECL               MAX LEN (INCLUDING RDW)
         SH    R2,=H'4'                 - LENGTH OF RDW
         L     R0,=F'-1'                BXH DCR
         LA    R1,BUF1+7                BXH LIMIT (@ DATA - 1)
         SR    R15,R15                  CLEAR FOR IC
         TM    CACFLAG1,CANONUM         NONUM DATA SET?
         BO    *+8                      SKIP NEXT INS IF NONUM
         IC    R15,CALENGTH             GET SEQUENCE NUMBER LENGTH
         AR    R1,R15                   REAL DATA START
         SR    R2,R15                   REAL DATA LENGTH
         AR    R2,R1                    BXH PTR (LAST BYTE OF DATA)
RID1$VLP CLI   0(R2),C' '               SCAN OFF TRAILING BLANKS
         BNE   RID1$VNB                 BIF NON-BLANK FOUND
         BXH   R2,R0,RID1$VLP           CONTINUE BACK SCAN
         BCTR  R1,0                     IF ALL BLANKS LENGTH = 1
RID1$VNB SR    R2,R1                    GET LENGTH
         AH    R2,=H'4'                 ADD IN RDW LENGTH
         AR    R2,R15                   ADD IN SEQUENCE NUMBER LEN
         STH   R2,BUF1+4                SET LENGTH INTO RDW
RID1$VFX EDIO  W,BUF1                   UPDATE RECORD
         BR    R10                      AND RETURN
RID1$TRT TRT   0(0,R6),XT#TABTR         * EXECUTED *
RID1$MV  MVC   0(0,R15),0(R6)           * EXECUTED *
RID1$TR  TR    0(0,R15),0(R14)          * EXECUTED *
RID1$MVB MVC   1(0,R1),0(R1)            * EXECUTED *
         SPACE 1
* INDEXED BY XT#SEQL*4 - IS 10**(SEQL-1)
RID1#SQ  DC    F'1'          0 -> (NO SEQ FIELD)
         DC    F'1'          1 -> (ONLY ATTR)
         DC    F'10'         2 -> 10**1
         DC    F'100'        3 -> 10**2
         DC    F'1000'       4 -> 10**3
         DC    F'10000'      5 -> 10**4
         DC    F'100000'     6 -> 10**5
         DC    F'1000000'    7 -> 10**6
         DC    F'10000000'   8 -> 10**7
         DC    F'100000000'  9 -> 10**8
         DROP  R3,R8                    (LN#LINE,R$IDAT1)
         EJECT ,
         USING LN#LINE,R3
         USING R$OST,R8                 (LOCAL BASE)
R$OST    L     R7,XT#SCRC               COLUMNS
         L     R5,XT#SEQL               SEQ FIELD LENGTH
         L     R6,=A(ST#LIN)            LINE FORM ----+----1-----+---
         TM    CACFLAG1,CANONUM         NUMBERED DATASET?
         BO    ROST$NN                  BIF NOT NUMBERED
         CLI   CALINE,1                 SEQ NUM AT BEGINING OF REC?
         BNE   ROST$NN                  BIF SEQ FIELD AT END OF REC
         SR    R15,R15                  CLEAR FOR IC
         IC    R15,CALENGTH             GET NUM SEQ LENGTH
         AR    R6,R15                   SKIP SEQ FIELD IN REC
ROST$NN  AL    R6,XT#XOFF               WINDOW IT
         MVI   4(R2),X'F8'              SET AUTO SKIP ATTR INTENS
         LA    R2,5(,R2)                SKIP SBA,ADR1,ADR2,SF,ATTR
         BCTR  R5,0                     LEN OF SEQ FIELD -1
         LTR   R5,R5                    ANY SEQ FIELD?
         BM    *+8                      SKIP XC IF NONE
         EX    R5,ROST$XC               XC 0(0,R2),0(R2) NULL SEQ FLD
         LA    R2,1(R5,R2)              SKIP SEQ FIELD
         BCTR  R7,0                     SPACE FOR DATA ATTR
         BCTR  R7,0                     R5 HAS SEQ FLD LEN -1
         SR    R7,R5                    GET LENGTH LEFT ON LINE
         BNPR  R10                      RETURN IF LINE FULL
         LR    R15,R7                   COPY LENGTH
         LH    R0,CALRECL               GET MAX LRECL
         SH    R0,=H'4'                 - RDW LENGTH FOR VAR LEN RECS
         S     R0,XT#XOFF               - PART NOT DISPLAYED
         SR    R14,R14                  CLEAR FOR IC
         TM    CACFLAG1,CANONUM         LINE NUMBERED?
         BO    *+8                      BIF NONUM
         IC    R14,CALENGTH             GET LENGTH OF SEQ NUMBERS
         SR    R0,R14                   GET DATA LENGTH TO USE
         BNP   ROST$EZ                  GO ZERO,NONE LEFT (NO TABS TOO)
         CR    R15,R0                   LENGTH ON LINE :: MAX DATA LEN
         BNH   *+6                      BIF NOT OVER DATA LENGTH
         LR    R15,R0                   USE DATA LENGTH THEN
         BCTR  R15,0                    GET EX LEN LEFT
         EX    R15,ROST$MV              MVC 0(0,R2),0(R6)
         LA    R15,1(,R15)              GET REAL LENGTH BACK
         TM    CATABS,X'FF'             TABS ON?
         BZ    ROST$E                   GO EXIT IF TABS OFF
         L     R6,XT#XOFF               GET OFFSET VALUE
         LA    R14,CATABS+1             POINT TO FIRST TAB
ROST$TL  SR    R5,R5                    CLEAR FOR IC
         IC    R5,0(,R14)               GET TAB
         LTR   R5,R5                    ANY TAB HERE?
         BZ    ROST$E                   BIF END OF TAB TABLE
         BCTR  R5,0                     GET TAB ORIG 0
         SR    R5,R6                    GET OFFSET INTO DISPLAY
         BM    ROST$TN                  BIF BEFORE LEFT EDGE
         CR    R5,R15                   PAST RIGHT EDGE?
         BH    ROST$TN                  BIF PAST RIGHT EDGE
         AR    R5,R2                    POINT TO TAB POSITION
         MVC   0(1,R5),XT#TABC          SET TAB CHAR
ROST$TN  LA    R14,1(,R14)              TO NEXT TAB
         B     ROST$TL                  CONTINE PLACING TABS
ROST$EZ  SR    R15,R15                  STATUS NOT IN WINDOW
ROST$E   AR    R2,R15                   PAST STATUS INFO
         SR    R7,R15                   GET SPACE LEFT ON LINE
         BNPR  R10                      RETURN IF LINE FULL
         BCTR  R7,0                     GET EX LENGTH
         EX    R7,ROST$XC               XC 0(0,R2),0(R2) NULL OUT LINE
         LA    R2,1(R2,R7)              POINT PAST END OF LINE
         BR    R10                      AND RETURN
ROST$XC  XC    0(0,R2),0(R2)            * EXECUTED *
ROST$MV  MVC   0(0,R2),0(R6)            * EXECUTED *
         DROP  R3,R8                    (LN#LINE,R$OST)
         EJECT ,
R$IST    EX    0,0(,R8)    EX 0,*       NO INPUT ALLOWED
         SPACE 1
R$ICMD   STM   R1,R2,XT#CMDA            SAVE CMD ADDR/LEN
RIC$C2   BR    R10                      AND RETURN
         SPACE 2
*  THERE ARE ASSUMPTIONS THAT THE COMMAND LINE IS THE FIRST
*  LINE ON THE SCREEN (AND THERE IS ONLY ONE COMMAND LINE)
*  AND THAT OTHER LINES EXIST AFTER IT.
* POSSIBLE ACTIONS --
*  CMD - SET ATTRIBUTE TO MODIFIED (AND LEAVE OLD INPUT),
*        ERASE CMD AREA
*  MSG - OLD MSG POSITION < NEW MSG POSITION,
*        OLD MSG POSITION >= NEW MSG POSITION.
         SPACE 1
         USING LN#LINE,R3
         USING R$OCMD,R8
R$OCMD   TM    XT#SET,LN#FCHG           RESHOW SCREEN?
         BZ    *+8                      SKIP NEXT INS IN NOT RESHOW
         OI    XT#FLAG,XT#FECMD         FORCE ERASE CMD IF RESHOW
         SR    R5,R5                    ASSUME DON'T ERASE CMD LINE
         MVC   4(2,R2),=X'C111'     MODIFIED ATTR BYTE, NEXT OP SBA
         TM    XT#FLAG,XT#FECMD         ERASE CMD LINE?
         BZ    ROC$ER1                  BIF DON'T ERASE CMD LINE
         MVC   4(2,R2),=X'403C'     NORMAL ATTR BYTE, NEXT OP RA
         MVI   8(R2),0                  ERASE TO NULLS
         LA    R5,1                     EXTRA BYTE FOR RA
ROC$ER1  LA    R2,5(,R2)                POINT TO SBA OR RA
         L     R0,XT#SCRC               ASSUME NO NEW MSG (POS = SCRC)
         L     R7,XT@MSG                GET MSG PTR
         LTR   R7,R7                    ANY MSG TO WRITE?
         BZ    ROC$NM1                  BIF NO NEW MSW
         SR    R6,R6                    CLEAR FOR IC/CONSTANT
         IC    R6,0(,R7)                GET MESSAGE LENGTH
         LA    R15,1(,R6)               MSG LENGTH + ATTR LENGTH
         SR    R0,R15                   SCREEN POS FOR NEW MSG
ROC$NM1  CH    R0,XT#OMSGP              NEW MSG POS :: OLD MSG POS
         BNH   ROC$MNEW                 BIF NEW MSG OVERLAYS OLD MSG
         STH   R0,TEMPDW                TEMP SAVE NEW POS
         LH    R0,XT#OMSGP              GET OLD MSG POSITION
         BAL   R14,CV$POS               SET ADDR TO POS OR ERASE TO
         LA    R2,3(R5,R2)              SKIP RA OR SBA
* I AM NOW POSITIONED TO OLD MSG POSITION - ERASE TO NEW MSG POSITION
         MVI   0(R2),X'3C'              MAKE AN RA
         MVI   3(R2),0
         LA    R5,1                     ACCOUNT FOR EXTRA RA BYTE
         LH    R0,TEMPDW                GET NEW POSITION BACK
ROC$MNEW STH   R0,XT#OMSGP              WILL BE OLD POSITION NEXT TIME
         BAL   R14,CV$POS               SET RA OR SBA ADR1,ADR2
         LA    R2,3(R5,R2)              SKIP RA OR SBA
         LTR   R7,R7                    REALLY ANY NEW MSG?
         BZR   R10                      RETURN IF NO NEW MSG
         MVC   0(2,R2),=X'1DE8'         SET PROTECTED HIGH INTENS
         BCTR  R6,0                     GET MSG EX LENGTH
         EX    R6,ROC$MVC               MVC 2(0,R2),2(R7)
         LA    R2,2+1(R6,R2)            SKIP SF, ATTR, MSG
         BR    R10                      AND RETURN
ROC$MVC  MVC   2(0,R2),2(R7)            * EXECUTED *
         SPACE 2
         LTORG ,
*  CATABS  - 1ST BYTE IS FLAG - X'00' TABS OFF, X'FF' TABS ON
*         NEXT UP TO 10 TAB COLUMN NUMBERS (IN ORDER ORIG 1)
*         X'00' ENDING BYTE
*
*  CALRECL - CONTAINS MAXIUM LRECL FOR RECORD (INCLUDING RDW)
*            VALUE FOR TYPE ASM IS 84. (DEC)
*
*
        TITLE 'CCNEDFSE - FULLSCR SUBCOMMAND - COMMANDS'
         USING C$P,R8
C$P      ST    R15,NEWKEY               SET KEY FOR EDIO
         EDIO  RC,NEWKEY,BUF1           READ IT IF EXISTS
         BZ    C$P$EX                   BIF EXISTS
         EDIO  RN,NEWKEY,BUF1           ELSE READ NEXT
         BZ    C$P$EX                   BIF EXISTS
         EDIO  RP,NEWKEY,BUF1           ELSE USE PREVIOUS
C$P$EX   MVC   CACURNUM,NEWKEY          SET CURRENT KEY
         OI    XT#FLAG,XT#FSS           FORCE SETSCRN CALL
         BR    R10                      AND RETURN
         DROP  R8                       (C$P)
         SPACE 1
C$T      EDIO  RF,,BUF1                 READ FIRST
         MVC   CACURNUM,BUF1            SET NEW KEY
         OI    XT#FLAG,XT#FSS           SET CALL SETSCRN
         BR    R10                      AND RETURN
C$U      EDIO  RP,MF=B                  SET UP READ BACKWARDS
         B     C$D$DOIT-C$U(,R8)        TO COMMON RTN
C$D      EDIO  RN,MF=B                  SET UP READ FORWARDS
         B     C$D$DOIT-C$D(,R8)        TO COMMON RTN
C$D$DOIT BALR  R8,0                     GET COMMON BASE
         USING *,R8
         LTR   R5,R15                   TEST NUMBER TO BCT
         BP    *+8                      SKIP NEXT IF GOOD
         LA    R5,1                     USE 1 IF BAD
C$D$LP   TM    CAATTN,CAATTNIS          ATTENTION?
         BO    C$D$EX                   STOP LOOPING IF ATTEN
         EDIO  ,CACURNUM,BUF1           READ NEXT RECORD
         BNZ   C$D$CK                   BIF REC DOESN'T EXIST
         MVC   CACURNUM,BUF1            SET NEW KEY
         BCT   R5,C$D$LP                CONTINUE COUNTING
C$D$EX   OI    XT#FLAG,XT#FSS           FORCE SETSCRN CALL
         BR    R10                      AND RETURN
C$D$CK   CLI   IOLIST,2                 WAS OPERATION RN?
         BNE   C$D$EX                   DONE IF NOT
*--- RAN OFF END OF DATA SET --- DISPLAY LAST SCREEN
C$B      BALR  R8,0
         USING *,R8
         EDIO  RL,,BUF1                 READ LAST RECORD
         BNZR  R10                      BIF NO RECORDS
         MVC   CACURNUM,BUF1            SET START KEY
         L     R15,XT#SCRL              LINES / SCREEN
         SH    R15,=H'3'                DATA LINES / SCREEN
         SH    R8,=Y(C$B+2-C$U)         FIX UP BASE
         BR    R8                       AND GO UP
         DROP  R8                       (* LOCAL BASE)
         SPACE 1
C$L      LCR   R15,R15                  GO LEFT
C$R      BALR  R8,0                     GET COMMON BASE
         USING *,R8
         A     R15,XT#XOFF              GET NEW OFFSET VALUE
         BNM   *+6                      SKIP NEXT IF < 0
         SR    R15,R15                  USE ZERO IF TOO LOW
         LA    R14,254                  CONSTANT OF 254
         S     R14,XT#SCRC              - COLS / LINE
         A     R14,XT#SEQL              + SEQ FIELD
         CR    R15,R14                  NEW OFFSET :: MAX
         BNH   *+6                      SKIP NEXT IF < MAX
         LR    R15,R14                  USE MAX AS MAXIUM OFFSET
         ST    R15,XT#XOFF              SAVE NEW X OFFSET VALUE
         OI    XT#SET,LN#FCHG           SET REBUILD SCREEN
         BR    R10                      AND RETURN
         DROP  R8                       (C$L,C$R,*)
         SPACE 1
         USING C$COL,R8
C$COL    LTR   R15,R15                 LOOK OK?
         BNPR  R10                     IGNORE IF BAD
         BCTR  R15,0                   GET ORIG 0
         LA    R14,254                 MAX COL POSITION
         S     R14,XT#SCRC             - COLS / LINE
         A     R14,XT#SEQL             + SEQ FIELD LENGTH
         CR    R15,R14
         BHR   R10                      AND RETURN
         ST    R15,XT#XOFF             SET OFFSET VALUE
         OI    XT#SET,LN#FCHG          FORCE SCREEN REBUILD
         BR    R10                     AND REBUILD SCREEN
         DROP  R8                      (C$COL)
         SPACE 1
         USING C$SEQ,R8
C$SEQ    LTR   R15,R15                 LOOK OK?
         BMR   R10                     IGNORE IF BAD
         CH    R15,=H'9'               TOO BIG?
         BHR   R10                     IGNORE IF TOO BIG
         ST    R15,XT#SEQL             SET SEQ FIELD LEN
         OI    XT#SET,LN#FCHG          FORCE SCREEN REBUILD
         BR    R10                      AND CONTINUE
         DROP  R8                       (C$SEQ)
         SPACE 1
         USING C$HELP,R8
C$HELP   L     R4,SV#SCAN+4             SAVE OPERAND END ADR -1
         L     R3,SV#SCAN+8             AND OPERAND ADR
         BAL   R14,SCANC                FIND HELP OPERAND
         BNP   C$HELPF                  NO/INVALID OPERAND; TO FSE HELP
         CLC   TEMPDW(4),=C'FSE '       FSE HELP REQUESTED?
         BE    C$HELPF                  GO DO IT IF SO
         CLC   TEMPDW(8),=C'FULLSCR '   FSE HELP BY FULL NAME?
         BE    C$HELPF                  GO DO IT IF SO
         LA    R5,EDCMD#H               IS A HELP CMD FOR EDIT
         SR    R4,R3                    LEN -1 OF COMMAND LEFT
         MVC   TBUF1(8),1(R5)           SET COMMAND
         MVI   TBUF1+8,C' '             FOLLOWED BY BLANK
         MVC   TBUF1+8+1(255),0(R3)     AND OPERANDS
         LA    R3,TBUF1                 POINT TO COMMAND STRING
         LA    R4,8+1+1(,R4)            LENGTH OF COMMAND STRING
         L     R8,=A(STK#EDIT)          GET STACK ROUTINE ADDRESS
         B     STK#EDH-STK#EDIT(,R8)    GO TO INTERNAL ENTRY
C$HELPF  CLI   XT#BLDL+2+2+8+2,0        R OF TTR = 0?
         BNE   C$HELPL                  GO LINK IF NOT
         MVC   XT#BLDL(C#HELPBL),C#HELPB INIT BLDL LIST
         BLDL  0,XT#BLDL                BLDL MODULE
         BXH   R15,R15,0(R10)           RETURN IF NOT AVAILABLE
C$HELPL  L     R1,XT@BUF                ADDR WORK AREA FOR HELP RTN
         LA    R2,XT#BLDL+4             POINT TO NAME FOR LINK
         LA    R15,XT#LINK              SF PARM FOR LINK
         LINK  DE=(R2),SF=(E,(15))      GO DO IT
         OI    XT#FLAG,XT#FSS           MUST REFORMAT SCREEN
C$HOME   BR    R10                      AND RETURN
C#HELPB  DC    H'1',H'58'               1 ENTRY IN LIST, 58 BYTES LONG
         DC    CL8'CCNEDFSH'            HELP MODULE NAME
C#HELPBL EQU   *-C#HELPB                LENGTH OF INFO
         DROP  R8                       (C$HELP)
         SPACE 1
         USING C$TABC,R8
C$TABC   BAL   R14,SCANC                SCAN FOR OPERAND
         BZ    INF$MOPR                 BIF MISSING OPERAND
         BM    INF$IOPR                 BIF INVALID OPERAND
         CLI   TEMPDW+1,C' '            ONLY 1 CHAR LONG?
         BNE   INF$IOPR                 BIF IF > 1 CHAR LONG
         SR    R3,R3                    CLEAR FOR IC
         IC    R3,TEMPDW                GET NEW TAB CHARACTER
         STC   R3,XT#TABC               SAVE IT
         XC    XT#TABTR(256),XT#TABTR   CLEAN OUT TAB TRT TABLE
         LA    R3,XT#TABTR(R3)          POINT TO POSITION
         MVI   0(R3),1                  SET TRT STOP
         LA    R3,XT#LINS               @ FIRST LN#LINE
         L     R4,XT#SCRL               NUMBER OF LINES
         USING LN#LINE,R3
CTABC$L2 CLC   LN#ROUT,=Y(R$OST-$)      STATUS LINE?
         BNE   *+8
         OI    LN#FLAG,LN#FCHG          SET TO REWRITE IT
         LA    R3,LN#LINEL(,R3)         TO NEXT LN#LINE
         BCT   R4,CTABC$L2
         BR    R10                      AND RETURN
         DROP  R8,R3                    (C$TABC,LN#LINE)
         SPACE 1
C$NULLS  LA    R7,XT#FNULS+256          BIT + SET SCREEN FLAG
         B     CTABH$E-C$NULLS(,R8)     TO COMMON ROUTINE
C$TABS   LA    R7,XT#FTABS              GET FLAG TO SET
         B     CTABH$E-C$TABS(,R8)      TO COMMON ROUTINE
C$TABH   LA    R7,XT#FTABH+256          BIT + SET SCREEN FLAG
CTABH$E  BALR  R8,0                     GET COMMON BASE
         USING *,R8
         SR    R6,R6                    ASSUME YES OPERAND (SET)
         BAL   R14,SCANC                FIND OPERAND
         BNP   INF$MOPR                 BIF MISSING OPERAND
         CLC   TEMPDW(3),=C'ON '        SET IT?
         BE    CTABH$Y                  BIF ON (SET)
         BCTR  R6,0                     CHANGE TO CLEAR OPTION
         CLC   TEMPDW(4),=C'OFF '       OFF?
         BNE   INF$IOPR                 BIF INVALID OPERAND
CTABH$Y  IC    R0,XT#OPT                GET CURRENT OPTION
         XR    R0,R6                    FLIP IF TO BE CLEARED
         OR    R0,R7                    SET/CLEAR OPTION
         XR    R0,R6                    FLIP IF WAS CLEARED
         STC   R0,XT#OPT                SET NEW OPTION VALUES
         SRA   R7,8                     GET ONLY SET SCREEN FLAG
         BZR   R10                      RETURN IF NO SETSCREEN
         OI    XT#SET,LN#FCHG           SET ALL REWRITE FLAGS
         BR    R10                      AND RETURN
         DROP  R8                       (CTABH$E COMMON BASE)
        TITLE 'CCNEDFSE - FULLSCR SUBCOMMAND - STACK ROUTINE'
***********************************************************************
*                                                                     *
*                                   STACK ROUTINE                     *
*                                                                     *
***********************************************************************
         SPACE 1
         USING STK#EDIT,R8
STK#EDIT LM    R5,R7,=A(EDCMD#T,EDCMD#TL,EDCMD#TE)  CMD TABLE STUFF
         BAL   R14,FIND                 CHECK FOR VALID CMD
         BNER  R10                      EXIT IF NOT VALID
         SPACE 2
         LM    R3,R4,XT#CMDA            R3=A CMD,  R4=L'CMD LINE
STK#EDH  LA    R2,16+4(,R4)             LEN OF CMD + RDW
         LR    R6,R5                    SAVE CMD TABLE PTR
         TM    EDCMD#FL(R6),EDCMD#EX    RETURN TO FSE OR EXIT?
         BO    STK#GET                  DON'T RETURN
         LA    R2,STK#NAML(,R2)         RETURN. ADD LEN RDW + "FSE"
STK#GET  GETMAIN  EC,LV=(R2),A=TEMPDW,SP=78,MF=(E,GETMFL)
         BXH   R15,R15,NOCORE           QUIT W/MSG IF NO CORE
         L     R5,TEMPDW                @ GOTTEN CORE (LSD+STACK)
         LA    R14,16(,R5)              @ STACK
         LR    R15,R2                   RECFM=V + TOTAL LENGTH
         SH    R15,=H'16'               DON'T COUNT LSD LENGTH
         LR    R0,R14                   @ CURRENT CMD TO EXECUTE
         SR    R1,R1                    ZERO THE RESERVED WORD
         LA    R2,4(,R4)                L'CMD LINE + RDW
         SLL   R2,16                    MAKE LEN INTO RDW
         STM   R14,R2,0(R5)             STORE LSD + FIRST RDW
         BCTR  R4,0                     L'CMD LINE -1 FOR EX
         EX    R4,STK#MVC               MOVE CMD LINE INTO STACK
         LA    R15,1+4(R14,R4)          POINT PAST CMD/RDW
         TM    EDCMD#FL(R6),EDCMD#EX    RETURN TO FSE OR EXIT?
         BO    STK#STK1                 DON'T RETURN
         MVC   0(STK#NAML,R15),STK#NAME MOVE IN RDW + "FULLSCR"
         B     STK#STK2                 SKIP RESTORE OF VERIFY
STK#STK1 OC    CACFLAG1(1),XT#SAVF      RESTORE VERIFY FLAG
         SPACE 1
STK#STK2 STACK PARM=STPB,STORAGE=((R5),SOURCE),MF=(E,CATMPLST)
         LTR   R15,R15                  DID IT WORK?
         BNZ   STCKERR                  NO.  QUIT W/MSG.
         TM    EDCMD#FL(R6),EDCMD#SP    SAVE CACURNUM?
         BZ    STK#NSV                  BIF DON'T SAVE CURNUM
         MVC   XT#CNUM,CACURNUM         SAVE IT
         OI    XT#FLAG,XT#FSCN          SET FLAG TO USE IT
STK#NSV  TM    EDCMD#FL(R6),EDCMD#FS    DON'T LEAVE FULLSCR MODE?
         BO    EXIT                     BIF DON'T (STAY IN FULLSCR)
         BAL   R10,LVFULL               LEAVE FULLSCR MODE
         B     EXIT                     AND EXIT
         SPACE 1
         DROP  R8
         SPACE 4
STK#MVC  MVC   4(0,R14),0(R3)
STK#NAME DC    AL2(11,0),C'FULLSCR'
STK#NAML EQU   *-STK#NAME
EDCMD#T  DC    AL1(7),CL8'CHANGE',X'00'
EDCMD#TL EQU   *-EDCMD#T
         DC    AL1(7),CL8'C',X'00'
         DC    AL1(7),CL8'DELETE',X'60'
         DC    AL1(7),CL8'DEL',X'60'
         DC    AL1(7),CL8'END',X'80'
         DC    AL1(7),CL8'FORMAT',X'80'
         DC    AL1(7),CL8'FOR',X'80'
EDCMD#H  DC    AL1(7),CL8'HELP',X'80'
         DC    AL1(7),CL8'H',X'80'
         DC    AL1(7),CL8'INPUT',X'80'
         DC    AL1(1),CL8'I',X'80'
         DC    AL1(6),CL8'INSERT',X'80'
         DC    AL1(2),CL8'IN',X'80'
         DC    AL1(4),CL8'LIST',X'80'
         DC    AL1(1),CL8'L',X'80'
         DC    AL1(5),CL8'MERGE',X'00'
         DC    AL1(3),CL8'MER',X'00'
         DC    AL1(7),CL8'PROFILE',X'00'
         DC    AL1(4),CL8'PROF',X'00'
         DC    AL1(3),CL8'RUN',X'80'
         DC    AL1(1),CL8'R',X'80'
         DC    AL1(4),CL8'SAVE',X'00'
         DC    AL1(1),CL8'S',X'00'
         DC    AL1(4),CL8'SCAN',X'80'
         DC    AL1(5),CL8'SC',X'80'
         DC    AL1(6),CL8'TABSET',X'00'
         DC    AL1(3),CL8'TAB',X'00'
         DC    AL1(6),CL8'VERIFY',X'00'
         DC    AL1(1),CL8'V',X'00'
         DC    AL1(4),CL8'COPY',X'60'
         DC    AL1(2),CL8'CY',X'60'
         DC    AL1(2),CL8'DO',X'80'
         DC    AL1(3),CL8'EXS',X'00'
         DC    AL1(3),CL8'SEX',X'00'
         DC    AL1(7),CL8'FASTNUM',X'00'
         DC    AL1(4),CL8'FIND',X'00'
         DC    AL1(1),CL8'F',X'00'
         DC    AL1(6),CL8'MODIFY',X'00'
         DC    AL1(3),CL8'MOD',X'00'
         DC    AL1(1),CL8'M',X'00'
         DC    AL1(4),CL8'MOVE',X'60'
         DC    AL1(2),CL8'MV',X'60'
         DC    AL1(5),CL8'RENUM',X'00'
         DC    AL1(3),CL8'REN',X'00'
         DC    AL1(5),CL8'TEMP1',X'00'
         DC    AL1(2),CL8'T1',X'00'
         DC    AL1(5),CL8'UNNUM',X'00'
EDCMD#TE EQU   *-EDCMD#TL
EDCMD#FL EQU   EDCMD#TL-1
EDCMD#EX EQU   X'80'                    DON'T RETURN TO FSE (EXIT)
EDCMD#SP EQU   X'40'                    SAVE POS. OVER EDIT SUBCMD
EDCMD#FS EQU   X'20'                    DON'T LEAVE FULLSCR MODE
         SPACE 1
MSG#ENT  MSG   0,'FSE V1.3 04/12/79 (TEST)'
MSG#NFMT MSG   254,'SCREEN FORMAT ERROR'
MSG#ICMD MSG   0,'INVALID COMMAND'
MSG#MOPR MSG   0,'MISSING OPERAND'
MSG#IOPR MSG   0,'INVALID OPERAND'
MSG#MNO  MSG   0,'MISSING NUMERIC OPERAND'
MSG#BADC MSG   61,'INVALID CHARACTERS IN DATASET'
MSG#LOWC MSG   63,'LOWER CASE IN DATASET'
         TITLE 'CCNEDFSE - FULLSCR SUBCOMMAND - FMOVE/FCOPY'
*---------------------------------------------------------------------*
*                                                                     *
*  THE MOVE/COPY/DELETE COMMANDS JUST SAVE THE RECORD NUMBERS OF      *
*  THEIR OPERANDS.  ALL ACTIONS ARE DONE BY 'IMCRTN'.                 *
*   (INSERT/MOVE/COPY/DELETE)                                         *
*                                                                     *
*  NOTE:  THE SEQUENCE NUMBER MUST POINT TO RECORDS WHICH EXIST       *
*         ELSE THE SEQUENCE FIX UP WILL NOT WORK IF INSERT HAS        *
*         TO MOVE RECORDS AROUND.                                     *
*                                                                     *
*        R6 < 0 -> DELETE,  R6 = 0 -> MOVE, R6 > 0 -> COPY            *
*                                                                     *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
C$FDEL   LNR   R6,R8                    SET DELETE CMD
         B     C$FMOE-C$FDEL(,R8)       B TO COMMON CODE
C$FCO    LPR   R6,R8                    SET COPY CMD
         B     C$FMOE-C$FCO(,R8)        B TO COMMON CODE
C$FMO    SR    R6,R6                    SET MOVE CMD
C$FMOE   BALR  R8,0                     GET COMMON LOCAL BASE
         USING *,R8
         BAL   R14,SCANN                SCAN FOR L1
         BNP   INF$MNO                  BIF NO L1
         ST    R15,BUF1+400             SAVE L1
         EDIO  RC,BUF1+400,BUF1         TRY TO READ IT
         BZ    C$FMOL1                  BIF L1 EXISTS
         EDIO  RN                       ELSE READ NEXT (AND USE AS L1)
         BNZ   INF$IOPR                 INVALID IF OFF END OF FILE
C$FMOL1  L     R3,BUF1                  GET L1 VALUE
         LR    R4,R3                    AND DEFAULT L2
         L     R5,CACURNUM              AND DEFAULT L3
         BAL   R14,SCANN                SCAN FOR L3 (OR L2)
C$FMC1   BZ    C$FMCCK                  BIF NO L3 OR L2
         BP    C$FMC2
         LTR   R6,R6                    INVALID IF DELETE
         BM    INF$IOPR                 BIF DELETE AND NOT NUMBER
         BAL   R14,SCANC                SCAN FOR *
         BNP   INF$IOPR                 BIF IF INVALID OPERAND
         CLC   TEMPDW(2),=C'* '         ONLY * ?
         BNE   INF$IOPR                 BIF IF INVALID OPERAND
         B     C$FMCCK                  GO CHECK L1,L2,L3 VALUES
C$FMC2   LR    R5,R15                   SET L3
         LTR   R6,R6                    IS THIS DELETE?
         BM    C$FMCDEL                 BIF DELETE, IS L2, NO L3
         BAL   R14,SCANN                SCAN FOR L3 (PREV WAS L2)
         BNP   C$FMC1                   BIF NO L2
C$FMCDEL LR    R4,R5                    PREVIOUS WAS REALLY L2
         LR    R5,R15                   SAVE L3 (REAL ONE)
*  GET REAL RECORDS FOR L2 AND PERHAPS L3
C$FMCCK  XC    SV#SCANP,SV#SCANP        NO CURSOR POS IF ERROR MSG
         ST    R4,BUF1+400              SET KEY TO READ
         EDIO  RC                       SEE IF L2 EXISTS
         BZ    C$FML2                   BIF L2 EXISTS
         EDIO  RP                       ELSE READ PREVIOUS
         BNZ   INF$IOPR                 INVALID L2 IF BEFORE BEGINNING
C$FML2   L     R4,BUF1                  GET KEY OF L2
         LTR   R6,R6                    IS THIS DELETE?
         BM    C$FDELS                  BIF DELETE, SAVE OPERANDS
         ST    R5,BUF1+400              SET KEY TO READ
         ST    R5,XT#SEQX3              SAVE ORIG L3 TOO
         EDIO  RC                       TRY TO READ L3
         BZ    C$FML3
         SR    R5,R5                    ASSUME COPY TO
         BCTR  R5,0                     TOP OF DATA SET
         EDIO  RP                       ELSE READ PREVIOUS
         BNZ   C$FML3T                  BIF USE TOP OF DATA SET
C$FML3   L     R5,BUF1                  GET REAL VALUE OF L3
         SPACE 1
*  CHECK THAT L1 <= L2
C$FML3T  CR    R3,R4                    L1 :: L2
         BH    INF$IOPR                 BIF INVALID OPERANDS
*  CHECK THAT L3 < L1 OR L3 >= L2
         CR    R5,R3                    L3 :: L1
         BL    C$FMC3                   BIF OK
         CR    R5,R4                    L3 :: L2
         BL    INF$IOPR                 BIF INVALID
C$FMC3   STM   R3,R5,XT#SEQL1           SAVE L1,L2,L3
         MVI   XT#FMC,C'C'              ASSUME COPY
         LTR   R6,R6                    IS IT COPY?
         BNZ   *+8                      BIF COPY
         MVI   XT#FMC,C'M'              IT IS MOVE
C$FMRET  OI    XT#FLAG,XT#FIMC          PROVOKE IMC ROUTINE
         BR    R10                      AND RETURN
C$FDELS  CR    R3,R4                    L1 <= L2?
         BH    INF$IOPR                 BIF INVALID DELETE
         STM   R3,R4,XT#SEQL1           SAVE DELETE OPERANDS
         MVI   XT#FMC,C'D'              THIS IS DELETE...
         B     C$FMRET                  SET FLAG, RETURN
         DROP  R8                       (C$FMC LOCAL BASE)
 TITLE 'CCNEDFSE - FULLSCR SUBCOMMAND - INSERT/MOVE/COPY RTN - IMCRTN'
*---------------------------------------------------------------------*
*                                                                     *
*  IMCRTN: INSERT/MOVE/COPY/DELETE ROUTINE                            *
*                                                                     *
*   RECEIVES CONTROL FROM FSE MAINLINE AFTER ALL INPUT DATA HAS       *
*   BEEN EDITED.  (AT THIS POINT THE CONTENTS OF XT#BUF ARE NO        *
*   LONGER REQUIRED)  INSERTS ARE DONE ONE AT A TIME FROM THE         *
*   BOTTOM OF THE SCREEN TO THE TOP (TO AVOID RUNNING INTO            *
*   EACH OTHER).  ANY RE-NUMBERING CAUSED BY THE INSERTIONS           *
*   WILL NOT INTERFERE WITH OTHER INSERTIONS DUE TO THIS ORDER.       *
*   THE OPERANDS OF THE MOVE/COPY OR DELETE COMMAND WHICH IS          *
*   CURRENTLY PENDING (IF ANY) ARE ADJUSTED AS THE LOCAL RE-NUMBERING *
*   IS DONE TO MAINTAIN THE INTENT OF THE MOVE/COPY OR DELETE.        *
*                                                                     *
*   NOTE: THIS ROUTINE CHECKS 'CAATTN','CAATTNIS' FOR ATTENTIONS      *
*         AND WILL CLEAN UP QUICKLY AND RETURN IF POSTED.             *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
         USING IMCRTN,R8                IMCRTN LOCAL BASE
IMCRTN   ST    R10,RET#SAVE             SAVE RETURN TO MAINLINE ADDR
         L     R10,XT@BUF               GET ADDR OF XT#BUF (IMC#WRK)
         USING IMC#WRK,R10              WORK AREA BASE
         NI    XT#FLAG,255-XT#FIMC      OFF IMC CALL REQUIRED FLAG
         LA    R0,10
         CL    R0,CAINCRE               10 < INCREMENT?
         BL    IMC$SET2
         LA    R0,2                     ELSE TRY 2
         CL    R0,CAINCRE
         BL    IMC$SET2
         LA    R0,1                     ELSE USE 1 AS IMC#INC2
IMC$SET2 ST    R0,IMC#INC2
         MVC   IMC#INC1,CAINCRE         INIT INCREMENT
         SPACE 1
*---             FIRST PROCESS ALL INSERT/REPLICATES               ---*
         L     R4,XT#SCRL               LINES / SCREEN
         LR    R3,R4                    COPY LINES / SCREEN
         SLL   R3,4                     * LN#LINEL
         LA    R3,XT#LINS-LN#LINEL(R3)  POINT TO LAST LN#LINE ENTRY
         USING LN#LINE,R3
IMC$ILP1 TM    LN#FLAG,LN#FDAT          DATA LINE?
         BZ    IMC$INX                  BIF NOT DATA LINE
         SR    R6,R6                    CLEAR FOR IC
         IC    R6,LN#INNUM              NUM TO INSERT AFTER THIS LINE
         LTR   R6,R6                    ANY TO INSERT?
         BZ    IMC$INX                  BIF NONE TO INSERT HERE
         SPACE 1
*--- INSERT THE RECORDS; SPECIAL PROCESSING FOR CURSOR POSITION    ---*
         MVI   LN#INNUM,0               INSERT WILL BE DONE
         SR    R2,R2                    ASSUME DON'T SET CURSOR
         TM    XT#CURSQ,X'80'           HAVE SEQ NUM FOR CUR POS?
         BZ    IMC$IGO                  BIF IF DONE ALREADY
         LR    R1,R3                    COPY MY LN#LINE ADDR
         LA    R0,XT#LINS               @ 0TH LINE ENTRY
         SR    R1,R0                    GET LN#LINE OFFSET
         SRL   R1,4                     GET LINE NUMBER
         MH    R1,XT#SCRC+2             * LENGTH OF LINE
         CH    R1,XT#CUR                MY LINE BEFORE CURSOR?
         BNL   IMC$IGO                  BIF CURSOR BEFORE MY LINE
         AH    R1,XT#SCRC+2             TO NEXT LINE
         CH    R1,XT#CUR                NEXT LINE BEFORE CURSOR?
         BNH   IMC$IGO                  BIF CURSOR PAST MY LINE
         LA    R2,1                     SET CURSOR FLAG
* R5 - NUM TO INSERT; LN#PARM - SEQ NUM TO INSERT AFTER
***** VARIABLE LENGTH CHECK (USE LEN 1 RECORDS??)
IMC$IGO  EDIO  RC,(R3),IMC#BUF1         READ CURRENT RECORD
         BNZ   IMC$ERR                  BIF RECORD VANISHED
         TM    LN#FLAG,LN#FREP          REPLICATE?
         BO    IMC$REP                  BIF REPLICATE
         MVI   IMC#BUF1+8,C' '   BLANK OUT MAX LEN RECORD
         MVC   IMC#BUF1+9(256),IMC#BUF1+8
IMC$REP  NI    LN#FLAG,255-LN#FREP      OFF REPLICATE FLAG
         L     R5,LN#PARM               USE CURRENT KEY AS SEQ1
         MH    R6,IMC#INC1+2            GET N * INC1
         AR    R6,R5                    + SEQ1 -> SEQ2
         AH    R5,=H'1'                 USE LN#PARM + 1 AS SEQ1
         BAL   R7,IMC$PUSH              GO MAKE ROOM FOR INSERT
         BCTR  R5,0                     GET LN#PARM BACK
         SR    R6,R5                    GET N * INC1 BACK
IMC$ILP2 A     R5,IMC#INC1              PLACE FOR NEXT INSERT
         BCT   R2,*+8                   SET CURSOR?
         ST    R5,XT#CURSQ              SET SEQ NUMBER FOR CURSOR
         ST    R5,IMC#BUF1              SET SEQ NUMBER FOR ADD
         EDIO  W,IMC#BUF1               ADD NEW RECORD
         S     R6,IMC#INC1              ANY MORE TO INSERT?
         BP    IMC$ILP2                 BIF MORE TO INSERT
         OI    XT#FLAG,XT#FSS           FORCE SETSCRN CALL
         SPACE 1
IMC$INX  SH    R3,=Y(LN#LINEL)          TO PREVIOUS LN#LINE ENTRY
         BCT   R4,IMC$ILP1              DO INSERTS FOR EACH SCREENLINE
         DROP  R3                       (LN#LINE)
         SPACE 2
*---             PROCESS MOVE/COPY OR DELETE                       ---*
         CLI   XT#FMC,0                 ANY MOVE OR COPY PENDING?
         BE    IMC$RET                  BIF NO MOVE/COPY/DELETE PEND.
         OI    XT#FLAG,XT#FSS           FORCE SETSCRN CALL
         CLI   XT#FMC,C'D'              DELETE REQUIRED?
         BE    IMC$DEL                  BIF DELETE COMMAND
         SPACE 1
         L     R5,XT#SEQX3              GET ORIG L3 VALUE
         C     R5,XT#SEQL3              SAME VALUE AS L3?
         BE    IMC$MCX3                 BIF SAME, GO USE IT
         EDIO  RP,XT#SEQX3,IMC#BUF1     READ PREVIOUS IF ANY
         BZ    IMC$MCLC                 BIF PREV REC FOUND
         CLC   XT#SEQL3,=F'-1'          WAS IT TOP BEFORE?
         BE    IMC$MCX3                 BIF WAS TOP, USE X3
         B     IMC$MCL3                 ELSE USE L3
IMC$MCLC CLC   IMC#BUF1,XT#SEQL3        SAME RELATIVE POSITION?
         BE    IMC$MCX3                 BIF SAME, USE X3
IMC$MCL3 L     R5,XT#SEQL3              ELSE USE L3 AS INSERT POSITION
IMC$MCX3 EQU   *
         SPACE 1
*---              COUNT RECORDS TO MOVE OR COPY                   ---*
         MVC   NEWKEY,XT#SEQL1          SET STARTING SEQ NUMBER
         SR    R6,R6                    NO RECORDS SO FAR
         EDIO  RC,NEWKEY,IMC#BUF1       SEE IF FIRST RECORD EXISTS
         BZ    IMC$MCR1                 BIF FIRST RECORD EXISTS
         SPACE 1
IMC$MCL4 EDIO  RN                       READ NEXT RECORD
         BNZ   IMC$MCPH                 BIF NO NEXT RECORD
IMC$MCR1 CLC   IMC#BUF1(4),XT#SEQL2     PAST LIMIT OF MOVE/COPY?
         BH    IMC$MCPH                 BIF PAST MOVE/COPY LIMIT
         MVC   NEWKEY,IMC#BUF1          SET KEY FOR READ NEXT
         A     R6,IMC#INC1              SUM SPACE REQUIRED
         TM    CAATTN,CAATTNIS          ATTENTION?
         BZ    IMC$MCL4                 BIF NO ATTENTION
         B     IMC$RET                  ABORT MOVE/COPY IF ATTENTION
         SPACE 1
IMC$MCPH ST    R5,NEWKEY                SET TARGET KEY
         SR    R2,R2                    ASSUME NO RECORD AT TARGET LOC
         S     R6,IMC#INC1              - INC1 -> SPACE REQUIRED
         AR    R6,R5                    SPACE REQUIRED + SEQ1 -> SEQ2
         EDIO  RC                       READ TARGET TO IMC#BUF1
         BNZ   IMC$MCP2                 BIF NO RECORD THERE
         L     R2,IMC#INC1              SET FLAG, TO AFTER TARGET LOC
         AH    R5,=H'1'                 BUMP SEQ1 PAST TARGET
         AR    R6,R2                    BUMP SEQ2 TO MAKE ROOM
IMC$MCP2 BAL   R7,IMC$PUSH              PUSH RECORDS OUT OF WAY
         LTR   R2,R2                    DID TARGET EXIST?
         BZ    IMC$MCP3                 BIF TARGET DIDN'T EXIST
         BCTR  R5,0                     GET L3 BACK
         AR    R5,R2                    BUMP L3 PAST TARGET
IMC$MCP3 SR    R6,R5                    GET SPACE REQUIRED BACK
         A     R6,IMC#INC1              GET NUMBER * INC1 BACK
         EJECT ,
         EDIO  RC,XT#SEQL1,IMC#BUF1,ERRAD=IMC$ERR READ FIRST RECORD
         B     IMC$MCLX
         SPACE 1
IMC$MCLP EDIO  RN,NEWKEY,IMC#BUF1,ERRAD=IMC$ERR   READ FROM RECORD
IMC$MCLX MVC   NEWKEY,IMC#BUF1          SET KEY READ
         CLI   XT#FMC,C'M'              IS THIS MOVE?
         BNE   IMC$MNOT                 BIF NOT MOVE
         EDIO  DLT,NEWKEY,ERRAD=IMC$ERR DELETE SOURCE IF MOVE
         L     R0,NEWKEY                GET FROM SEQ NUMBER
         LR    R1,R5                    AND TO SEQ NUMBER
         BAL   R14,IMC$KCHG             NOTE KEY CHANGED R0 -> R1
         SPACE 1
IMC$MNOT ST    R5,IMC#BUF1              SET KEY FOR WRITE
         EDIO  W,IMC#BUF1               ADD THE RECORD
         A     R5,IMC#INC1              NEXT ADD SEQ NUMBER
         S     R6,IMC#INC1              ANY MORE TO MOVE/COPY?
         BP    IMC$MCLP                 BIF MORE TO DO
         SPACE 1
IMC$RET  MVI   XT#FMC,0                 NO MORE MOVE / COPY
         L     R10,RET#SAVE             RESTORE RETURN ADDR
         BR    R10                      AND RETURN TO MAIN LINE
         SPACE 1
IMC$DEL  MVC   NEWKEY,XT#SEQL1          INIT KEY TO START DEL AT
         EDIO  RC,MF=B                  START AT CURRENT KEY
         B     IMC$DEL2
         SPACE 1
IMC$DEL1 EDIO  RN,MF=B                  SET READ NEXT TYPE
IMC$DEL2 EDIO  ,NEWKEY,IMC#BUF1         READ RECORD
         BZ    IMC$DEL3                 BIF RECORD EXISTS
         CLI   IOLIST,0                 WAS THAT READ CURRENT?
         BE    IMC$DEL1                 BIF RC, TRY READ NEXT
         B     IMC$RET                  ELSE EOF, DONE
IMC$DEL3 CLC   IMC#BUF1,XT#SEQL2        RECORD <= L2?
         BH    IMC$RET                  BIF DELETE DONE
         MVC   NEWKEY,IMC#BUF1          SAVE KEY FOR READ NEXT
         EDIO  DLT,NEWKEY,ERRAD=IMC$ERR DELETE RECORD
         TM    CAATTN,CAATTNIS          ATTENTION?
         BZ    IMC$DEL1                 CONTINUE IF NO ATTENTION
         B     IMC$RET                  ABORT IF ATTENTION
         EJECT ,
*---------------------------------------------------------------------*
*  IMC$PUSH:  INTERNAL SUBROUTINE OF IMCRTN                           *
*   THIS ROUTINE PUSHES RECORDS DOWN IN THE FILE IF REQUIRED TO       *
*   MAKE ROOM FOR NEW RECORDS 'IMC' IS TO INSERT/MOVE/COPY.           *
*                                                                     *
* AT ENTRY:  R5       - SEQ1  (LOWER LIMIT TO PUSH FROM)              *
*                                                                     *
*            R6       - SEQ2  (UPPER LIMIT TO PUSH FROM)              *
*                                                                     *
*            R7       - RETURN ADDRESS                                *
*                                                                     *
*      ALL RECORDS BETWEEN SEQ1 TO SEQ2 INCLUSIVE ARE RELOCATED       *
*      TO SEQ2 + INC2 AND AFTER.  UPON RETURN THERE WILL BE NO        *
*      RECORDS BETWEEN SEQ1 THROUGH SEQ2 INCLUSIVE.                   *
*                                                                     *
*                                                                     *
*            IMC#INC2 - DISPLACED RECORD INCREMENT                    *
*                                                                     *
*                                                                     *
*    NOTE: 0 < IMC#INC2 <= IMC#INC1 <= CAINCRE                        *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
IMC$PUSH STM   R0,R7,IMC#PSAV           SAVE R0 - R7
*  R3 - REQUIRED SPACE
*  R5 - SEQ1
*  R6 - SEQ2
         SPACE 1
         SR    R3,R3                    INIT SPACE REQUIRED SO FAR
         ST    R5,NEWKEY                SET INITIAL KEY = SEQ1
         EDIO  RC,NEWKEY,BUF1           READ RECORD SEQ1 IF EXISTS
         BZ    IMC$PS1                  BIF FOUND SEQ1 RECORD
         SPACE 1
IMC$PLP1 EDIO  RN                       READ NEXT RECORD
         BNZ   IMC$PCK1                 BIF NO NEXT RECORD
IMC$PS1  L     R0,BUF1                  GET RECORD READ KEY X
         SR    R0,R6                    GET X - SEQ2
         BCTR  R0,0                     DON'T COUNT RECORD X OR SEQ2
         CR    R0,R3                    ENOUGH SPACE YET?
         BH    IMC$PCK2                 BIF HAVE ENOUGH SPACE
         A     R3,IMC#INC2              + SPACE FOR THIS RECORD
         MVC   NEWKEY,BUF1              SET NEWKEY FOR NEXT READ
         TM    CAATTN,CAATTNIS          ATTENTION?
         BZ    IMC$PLP1                 CONTINUE IF NO ATTENTION
         B     IMC$RET                  ABORT I/M/C IF ATTENTION
         SPACE 1
IMC$PCK1 EDIO  RC,MF=B                  WAS EOF, START AT LAST RECORD
         B     IMC$PCKX
IMC$PCK2 EDIO  RP,MF=B                  NOT EOF, START AT PREV RECORD
IMC$PCKX LTR   R3,R3                    ANY RELOCATION REQUIRED?
         BZ    IMC$PRET                 RETURN IF NONE REQUIRED
         SPACE 1
IMC$PLP2 MVC   NEWKEY,BUF1              SET KEY FOR EDIO
         EDIO  ,NEWKEY,BUF1             READ PREV OR CUR RECORD
         BNZ   IMC$PRET                 BIF NO PREVIOUS RECORD
         CL    R5,BUF1                  SEQ1 :: X
         BH    IMC$PRET                 BIF DONE
         EDIO  DLT,BUF1                 DELETE RECORD BEING RELOCATED
         L     R0,BUF1                  GET OLD KEY
         LR    R1,R3                    N * INC2
         AR    R1,R6                    + SEQ2
         ST    R1,BUF1                  SET NEW KEY FOR RECORD
         BAL   R14,IMC$KCHG             NOTE KEY CHANGE R0 -> R1
         CR    R1,R0                    CHECK NEW KEY > OLD KEY
         BH    *+8                      BIF ALL OK
         EX    0,*       *** LOGIC ERROR ***
         EDIO  W                        ADD RECORD WITH NEW KEY
         EDIO  RP,MF=B                  WILL READ PREVIOUS
         S     R3,IMC#INC2              GET PREV N * INC2
         TM    CAATTN,CAATTNIS          ATTENTION?
         BZ    IMC$PLP2                 CONTINUE IF NO ATTENTION
         B     IMC$RET                  ABORT I/M/C IF ATTENTION
         SPACE 1
IMC$PRET LM    R0,R7,IMC#PSAV           RESTORE R0 - R7
         BR    R7                       AND RETURN
         SPACE 1
IMC$ERR  EX    0,*          *** IMC LOGIC ERROR ***
         SPACE 1
*  IMC$KCHG - NOTE KEY CHANGE SUBROUTINE.
*    NOTES KEY CHANGE FROM R0 -> R1; USES R2; R15;
*    RETURNS TO R14.
         SPACE 1
IMC$KCHG LA    R15,XT#CNUM              ADDR OF FIRST SEQ NUMBER
         LA    R2,(XT#SEQL3-XT#CNUM+4)/4 NUMBER OF SEQUENCE NUMBERS
IMC$KCHL CL    R0,0(,R15)               IS THIS KEY CHANGING?
         BE    IMC$KCH1                 BIF THIS KEY CHANGED
IMC$KCHN LA    R15,4(,R15)              TO NEXT KEY
         BCT   R2,IMC$KCHL              CHECK THEM ALL
         BR    R14                      AND RETURN
IMC$KCH1 ST    R1,0(,R15)               CHANGE THE KEY
         B     IMC$KCHN                 AND CONTINUE SEARCH
         DROP  R8                       (IMCRTN)
         SPACE 2
STAXEXIT STM   R14,R12,12(R13)          SAVE REGS
         L     COMMREG,8(,R1)           GET PTR TO IKJEBECA (WORK AREA)
         POST  CAATTN,0                 POST ATTEN ECB
         LM    R14,R12,12(R13)          RESTORE REGS
         BR    R14                      AND RETURN
         TITLE 'CCNEDFSE - FULLSCR SUBCOMMAND - REGISTERS'
***********************************************************************
*                                                                     *
*                          REGISTER EQUATES                           *
*                                                                     *
***********************************************************************
         SPACE 1
*      REGISTER EQUATES
R0       EQU   0                        WORK
R1       EQU   1                        WORK
R2       EQU   2                        WORK
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
*R9      EQU   9                        COMMREG
R10      EQU   10
*R11     EQU   11                       BASEREG (MAIN PGM BASE)
R12      EQU   12
R13      EQU   13                       SAVE AREA PTR
R14      EQU   14                       BALR, WORK
R15      EQU   15                       BALR, RETCODE, WORK
         SPACE 3
*  IBM REGISTER EQUATES
PARMREG0 EQU   0                        PARAMETER POINTER
PARMREG1 EQU   1                        PARAMETER POINTER
COMMREG  EQU   9                        EDIT COMM AREA DSECT BASE
BASEREG  EQU   11                       PROGRAM BASE
SAVEREG  EQU   13                       SAVE AREA POINTER
RETREG   EQU   14                       RETURN TO CALLER
RETCDREG EQU   15                       RETURN CODE
         TITLE 'CCNEDFSE - FULLSCR SUBCOMMAND -- EDIT COMM DSECT'
         PRINT NOGEN                    SAVE SOME PAPER
         IKJEBECA                       COMM AREA DSECT DEF
         PRINT GEN
         SPACE 2
CCNWORD  EQU   CAINSAVE+16              * WORD VALID OVER SUBCOMMANDS *
         TITLE 'CCNEDFSE - FULLSCR SUBCOMMAND - WORKAREA DEF'
***********************************************************************
*                                                                     *
*                      FULLSCR WORKAREA DEFINITION                    *
*                                                                     *
***********************************************************************
         SPACE 1
         ORG   CASCWKA                  ORG AT EDIT-PROVIDED WORKAREA
         SPACE
TEMPDW   DC    D'0'                     TEMP DW FOR PACK/UNPACK
TEMPDW2  DC    D'0'                     2ND WORD DOUBLE WORD
IOLIST   DC    3F'0'                    IKJEBEUT PARM LIST (WORKDS I/O)
MSGWORK1 DC    4F'0'                    MSG SEGMENT WORKAREA
MSGWORK2 DC    4F'0'                    MSG SEGMENT WORKAREA
MSGWORK3 DC    4F'0'                    MSG SEGMENT WORKAREA
RETCODE  DC    F'0'
XWORKADR DC    F'0'                     POINTER TO GOTTEN CORE
GETMFL   GETMAIN EC,LV=256,A=XWORKADR,SP=1,MF=L
PTPB     PUTLINE  MF=L
STPB     STACK MF=L
SV#SCAN  DC    3A(0)                    SCAN BXH REGS SAVE AREA
SV#SCANP DC    A(0)                     PREV SCAN PTR FOR CUR POS
NEWKEY   DC    F'0'                     EDIO NEW KEY AREA
RET#SAVE DC    F'0'                     IMC MAINLINE RETURN ADDR SAVE
STAXPARM STAX  0,USADDR=0,REPLACE=NO,MF=L STAX PARM LIST
         SPACE 2
LEFTOVER EQU   CABFRPL-*                BYTES LEFT IN WORKAREA
LWORK    EQU   *-CASCWKA                LENGTH OF WORKAREA
         SPACE 4
BUF1     EQU   CABFRPL                  528 BYTES
TBUF1    EQU   CATEMPBF                 528 BYTES (TEMPORARY)
         EJECT
LN#LINE  DSECT                          LINE CONTROL ENTRY
LN#PARM  DC    F'0'                     RECORD NUMBER IF DATA LINE
LN#RIN   DC    Y(0)                     OFFSET OF INPUT ROUTINE
LN#ROUT  DC    Y(0)                     OFFSET OF OUTPUT ROUTINE
LN#FLAG  DC    X'00'                    FLAGS
LN#FCHG  EQU   X'80'                    CHANGE/FORCE WRITE LINE
LN#FNTAB EQU   X'40'                    USE TABS ON LINE
LN#FVAL  EQU   X'20'                    RECORD EXISTS
LN#FDAT  EQU   X'10'                    DATA LINE
LN#FREP  EQU   X'08'                    REPLICATE (NOT INSERT)
LN#INNUM DC    X'00'                    NUM RECS TO INSERT AFTER THIS
LN#HTABM DC    H'0'                     HARDWARE TAB BIT MASK
         DC    F'0'                     <RESERVED>
LN#LINEL EQU   *-LN#LINE                LENGTH OF ONE LINE ENTRY
         SPACE 4
XT#WORK  DSECT
XT#FLAG  DC    X'00'                    FLAGS
XT#FSS   EQU   X'80'                    CALL SETSCRN
XT#FSCN  EQU   X'40'                    SAVE CURNUM OVER EDIT SUBCMD
XT#FEOF  EQU   X'20'                    EOF MSG ALREADY ON SCREEN
XT#FECMD EQU   X'10'                    ERASE CMD LINE
XT#FIMC  EQU   X'08'                    INSERT/MOVE/COPY PENDING
XT#FVTAM EQU   X'04'                    VTAM TERMINAL
XT#FSCR  EQU   X'02'                    TERMINAL IN FULLSCR MODE
XT#SAVF  DC    X'00'                    CONTENTS OF CACFLAG1 ON ENTRY
XT#SET   DC    X'00'                    TO BE SET IN LN#FLAG
XT#CLR   DC    X'00'                    TO BE CLEARED IN LN#FLAG
XT#OPT   DC    X'00'                    OPTIONS
XT#FNULS EQU   X'08'
XT#FTABS EQU   X'04'                    USE SOFTWARE TABS IF XT#FTAB
XT#FTABH EQU   X'02'                    USE HARDWARE TABS IF XT#FTAB
XT#FTAB  EQU   X'01'                    TABS ON FLAG (SET FROM CATABS)
XT#SCRL  DC    F'0'                     LINES / SCREEN
XT#SCRC  DC    F'0'                     COLUMNS / LINE
XT@END   DC    A(0)                     ADDR PAST END OF XT#WORK
XT@BUF   DC    A(0)                     ADDR OF XT#BUF
XT#TPUTF DC    F'0'                     FULLSCR OR CTL FLAGS FOR TPUT
XT#XOFF  DC    F'0'                     X WINDOW OFFSET TO RIGHT
XT#SEQL  DC    F'0'                     SEQ FIELD LEN (INCLUDING ATTR)
XT#IADR  DC    A(0)                     ADDR INPUT LEFT
XT#ILEN  DC    F'0'                     LEN -1 OF INPUT LEFT
XT#CMDA  DC    A(0)                     ADDR OF CMD INPUT
XT#CMDL  DC    F'0'                     LENGTH OF CMD INPUT
XT@MSG   DC    A(0)                     @ MSG LEN-1, MSG TEXT
XT#DFT   DC    F'0'                     DEFAULT U,D,L,R OPERANDS
XT#CNUM  DC    F'0'                     SAVE AREA FOR CACURNUM
XT#CURSQ DC    F'0'                     REC SEQ # FOR CURSOR POS
XT#SEQL1 DC    F'0'                     IMC OPERANDS L1,L2,L3
XT#SEQL2 DC    F'0'                     FOR PENDING MOVE/COPY/DELETE
XT#SEQL3 DC    F'0'                     (-1 => BEGINING OF DATA SET)
XT#SEQX3 DC    F'0'                     ORIG VALUE OF L3
XT#CUR   DC    H'0'                     CURSOR POSITION
XT#OMSGP DC    H'0'                     OLD MSG POSITION
XT#AID   DC    X'00'                    AID FROM LAST TGET
XT#TABC  DC    CL1' '                   TAB CHARACTER
XT#FMC   DC    X'00'                    'M'|'C'|'D' MOVE/COPY/DELETE
XT#LINK  LINK  SF=L                     SF=L FORM LINK MACRO
XT#BLDL  DC    2H'0',CL8' ',XL50'00'    HELP BLDL ENTRY
XT#BLDLL EQU   *-XT#BLDL                LENGTH OF BLDL ENTRY
XT#TABTR DC    (256/8)D'0'              SOFT TAB TRT TABLE
         DC    0D'0'                    END ON DWD BOUNDARY
XT#PFXL  EQU   *-XT#WORK                FIXED LENGTH PREFIX LENGTH
         SPACE 1
XT#LINS  DC    0XL(LN#LINEL)'00'        ONE LINE FORMAT PER
*                                       LINE ON SCREEN
XT#BUF   DC    0X'00'                   TGET/TPUT BUFFER (FULLSCR)
         SPACE 1
*  NOTE: IMC#WRK IS OVERLAYED OVER XT#BUF.
IMC#WRK  DSECT ,                        INSERT/MOVE/COPY WORK AREA
IMC#PSAV DC    8F'0'                    IMC$OUT SAVE AREA R0 - R7
IMC#INC1 DC    F'0'                     MAIN INCREMENT
IMC#INC2 DC    F'0'                     DISPLACEMENT INCREMENT
IMC#BUF1 DC    ((4+4+256)/4)F'0'        I/O BUFFER
IMC#BUF2 DC    ((4+4+256)/4)F'0'        2ND I/O BUFFER
IMC#WRKL EQU   *-IMC#WRK                LENGTH OF WORK AREA
         SPACE 1
CCNEDFSE CSECT
         END
//*KED.SYSLMOD DD DISP=OLD,DSN=SYS1.AOACLPA,SPACE=,UNIT=
//LKED.SYSIN DD *
 IDENTIFY CCNEDFSE('CS01358')
 NAME     CCNEDFSE
//*
//C   EXEC PGM=COMPARE,
//  PARM='CCNEDFSE,CCNEDFSE'
//STEPLIB  DD DISP=SHR,DSN=SYS5.MSSLOAD
//SYSPRINT DD SYSOUT=*
//I1       DD DISP=(SHR,PASS),DSN=&&GOSET
//I2       DD DISP=SHR,DSN=SYS1.LPALIB
