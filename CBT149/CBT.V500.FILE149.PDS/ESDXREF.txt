//CSYSMASA JOB CSYSJCJ,MSGCLASS=J,NOTIFY=CSYSJCJ,COND=(0,NE)
/*JOBPARM ROOM=9917,TIME=999,LINES=999
// EXEC ASMHCL,PARM.ASM=BATCH,PARM.LKED='XREF,LET,LIST'
//ASM.SYSLIB DD
//           DD
//           DD DISP=SHR,DSN=SYS5.MSSMAC
//ASM.SYSIN  DD *
         MACRO
&NAME    MSG   &TEXT,&HAVELEN,&TYPE=CALL,&BALREG=,&MAXLEN=,&BALNAME=,  #
               &MSGNAME=,&DDNAME=,&RECFM=,&DCBNAME=,&FACTOR=
.*
.*********************************************************************.
.*                                                                   *.
.*  GENERATE OR FIND A MESSAGE, AND PRINT IT OUT.  SUPPLIES BAL      *.
.*  ROUTINE NECESSARY, AND MESSAGES.                                 *.
.*                                                                   *.
.*  TEXT            MSG TEXT - EITHER 'XXX' THE ACTUAL TEXT, OR      *.
.*                  XXX, THE ADDRESS OF THE TEXT (WITH DC CLNN       *.
.*                  IMPLICIT LENGTH)                                 *.
.*  HAVELEN         (RECFM=V ONLY).  IF 'HAVE', RDW ASSUMED TO BE    *.
.*                  ACCURATE.  IF OMMITTED, RDW FILLED IN BY         *.
.*                  BACKSCAN FOR NON-BLANK.                          *.
.*  TYPE            TYPE OF CALL:                                    *.
.*                       CALL...GENERATE (OR FIND) TEXT AND LENGTH,  *.
.*                              AND LINK TO PRINT ROUTINE (DEFAULT). *.
.*                       DCB....GENERATE THE MESSAGE DCB             *.
.*                       OPEN...OPEN THE PRINT FILE                  *.
.*                       CLOSE..CLOSE THE PRINT FILE                 *.
.*                       SET....VIEW GLOBALS                         *.
.*                       GEN....GENERATE THE PRINT BAL ROUTINE.      *.
.*                       TEXT...GENERATE THE MESSAGE WITH THE LENGTH *.
.*                              IN FRONT, FOR THE BAL ROUTINE.       *.
.*  BALREG          BAL AND RETURN REGISTER (DEFAULT = R10)          *.
.*  MAXLEN          THE MAXIMUM SIZE OF THE MESSAGE (SIZE OF         *.
.*                  THE BUFFER).  DEFAULT IS 133 BYTES.              *.
.*  BALNAME         NAME OF THE BAL ROUTINE TO BE GENERATED.         *.
.*                  DEFAULT IS 'MSG'.                                *.
.*  MSGNAME         NAME OF THE MESSAGE BUFFER.  DEFAULT IS          *.
.*                  'MSGBUF'                                         *.
.*  DDNAME          DD NAME FOR THE MESSAGE FILE.  DEFAULT SYSPRINT  *.
.*  RECFM           RECORD FORMAT.  DEFAULT FBA                      *.
.*  FACTOR          BLOCKING FACTOR (FULLTRK OR HALFTRK).            *.
.*  DCBNAME         NAME OF DCB      (DEFAULT MSGDCB)                *.
.*                                                                   *.
.*  VIC TOLOMEI - 4/74                                               *.
.*                                                                   *.
.*  UPDATES     - 6/77                                               *.
.*                                                                   *.
.*                                                                   *.
.*********************************************************************.
         GBLA  &GLKSIZE,&GAXLEN,&GAXEX,&NUMBER,&GRECL
         GBLB  &MSGGLOB,&MSGSET     WHETHER GLOBS HAVE BEEN SET ETC
         GBLC  &GBREG,&GMNAME,&GBNAME,&GBNAME#,&GBNAME$,&GBN,&GBNAME@
         GBLC  &GDNAME,&GECFM,&GCBNAME,&GACTOR
         LCLA  &LEN,&LIM,&COUNT
         LCLC  &LABBO,&LENLEN,&TEMP1,&TEMP2,&TEMP3
         AIF   (&MSGGLOB).NORESET       NO INIT GLOBALS
&GBREG   SETC  'R10'
&GBNAME  SETC  'MSG'
&GBN     SETC  'MSG'
&GBNAME# SETC  '&GBN'.'#'
&GBNAME$ SETC  '&GBN'.'$'
&GBNAME@ SETC  '&GBN'.'@'
&GMNAME  SETC  'MSGBUF'
&GDNAME  SETC  'SYSPRINT'
&GECFM   SETC  'FBA'
&GACTOR  SETC  'FULLTRK'
&GAXLEN  SETA  133
&GAXEX   SETA  &GAXLEN-1
&GRECL   SETA  &GAXLEN                  ASSUME 'F'
&GCBNAME SETC  'MSGDCB'
&NUMBER  SETA  0
.*
.*  PROCESS PARMS
.*
.NORESET AIF   ('&BALREG' EQ '').NOREG
&GBREG   SETC  '&BALREG'
.NOREG   AIF   ('&BALNAME' EQ '').NONAME
&GBNAME  SETC  '&BALNAME'
&GBN     SETC  '&BALNAME'(1,3)
&GBNAME# SETC  '&GBN'.'#'
&GBNAME$ SETC  '&GBN'.'$'
&GBNAME@ SETC  '&GBN'.'@'
.NONAME  AIF   ('&MSGNAME' EQ '').NOMSG
&GMNAME  SETC  '&MSGNAME'
.NOMSG   AIF   ('&DDNAME' EQ '').NODDNA
&GDNAME  SETC  '&DDNAME'
.NODDNA  AIF   ('&RECFM' EQ '').NORECF
&GECFM   SETC  '&RECFM'
         AIF   (('&GECFM'(1,1) EQ 'F' OR '&GECFM'(1,1) EQ 'V') AND K'&G#
               ECFM LE 3).NORECF        ITS OK
         MNOTE 8,'INVALID RECFM - &GECFM'
         MEXIT
.NORECF  AIF   ('&DCBNAME' EQ '').NODCBN
&GCBNAME SETC  '&DCBNAME'
.NODCBN  AIF   ('&FACTOR' EQ '').NOFACT
&GACTOR  SETC  '&FACTOR'
.NOFACT  AIF   ('&MAXLEN'  EQ '').NOMAXL
&GAXLEN  SETA  &MAXLEN
&GAXEX   SETA  &GAXLEN-1
&GRECL   SETA  &GAXLEN                  ASSUME 'F'
.NOMAXL  AIF   ('&GECFM'(1,1) EQ 'F').NOMAXL2  OK
&GRECL   SETA  &GAXLEN+4                RECFM=V
.NOMAXL2 ANOP
&GLKSIZE SETA  7294                     ASSUME FULLTRK
         AIF   ('&GACTOR' EQ 'FULLTRK').FULL    RIGHT
         AIF   ('&GACTOR' EQ 'HALFTRK').HALF       NO
         AIF   ('&GACTOR' EQ 'UNBLKED').UNBL       NO BLOCKING
         MNOTE 8,'INVALID BLOCKING FACTOR --- &GACTOR'
         MEXIT
.HALF    ANOP
&GLKSIZE SETA  3520                     HALFTRK NOW
         AGO   .FULL                    GET BLKSIZE NOW
.UNBL    ANOP
&GLKSIZE SETA  &GRECL                   UNBLOCKED, BLKSIZE=LRECL
.FULL    ANOP
&GLKSIZE SETA  (&GLKSIZE/&GRECL)*&GRECL   GET DCB=BLKSIZE MAYBE
         AIF   ('&GECFM'(1,1) EQ 'F').BLKTRK OK, RECFM=F
&GLKSIZE SETA &GLKSIZE+4                RECFM=V, BDW
         AIF   (&GLKSIZE LE 7294).BLKTRK FIT ON TRACK
&GLKSIZE SETA  &GLKSIZE-&GRECL          NO FIT, BACK UP 1 REC
.BLKTRK  ANOP
&MSGGLOB SETB  1                        NO MORE RESETTING
         AIF   (('&TYPE' EQ 'TEXT') OR ('&TYPE' EQ 'DCB')).NONAME$
         AIF   ('&NAME' EQ '').NONAME#
&NAME    DS    0H
.NONAME# AIF   ('&TYPE' EQ 'SET').SET   JUST SET AND VIEW
.NONAME$ AIF   (&MSGSET).NOSET
.SET     ANOP
&MSGSET  SETB  1                        NO MORE DEFAULT VIEWING
.*********************************************************************.
.*  TYPE=SET (OR FIRST ENTRY)                                        *.
.*********************************************************************.
         SPACE 1
         MNOTE *,'MSG MACRO GLOBAL PARAMETERS'
         MNOTE *,'  *** BAL REG ----- &GBREG'
         MNOTE *,'  *** BUFFER LEN -- &GAXLEN'
         AIF   ('&GECFM'(1,1) EQ 'F').FNAMES
         MNOTE *,'  *** BAL NAMES --- &GBNAME, &GBNAME#, &GBNAME$, &GBN#
               AME@'
         AGO   .GOON@
.FNAMES  MNOTE *,'  *** BAL NAMES --- &GBNAME, &GBNAME#, &GBNAME$'
.GOON@   MNOTE *,'  *** BUFFER NAME - &GMNAME'
         MNOTE *,'MSG MACRO DCB PARAMETERS'
         MNOTE *,'  *** DCBNAME ----- &GCBNAME'
         MNOTE *,'  *** DDNAME ------ &GDNAME'
         MNOTE *,'  *** RECFM ------- &GECFM'
         MNOTE *,'  *** LRECL ------- &GRECL'
         MNOTE *,'  *** BLKSIZE ----- &GLKSIZE'
         MNOTE *,'  *** BLOCKING ---- &GACTOR'
         SPACE 1
.*
.NOSET   AIF   ('&TYPE' EQ 'SET').MEND
         AIF   ('&TYPE' EQ 'GEN').GEN
         AIF   ('&TYPE' EQ 'DCB').DCB
         AIF   ('&TYPE' EQ 'OPEN').OPEN
         AIF   ('&TYPE' EQ 'CLOSE').CLOSE
         AIF   ('&TYPE' EQ 'CALL'  OR  '&TYPE' EQ 'TEXT').OKTYPE
         MNOTE 8,'INVALID MSG TYPE, &TYPE'
         MEXIT
.OKTYPE  AIF   ('&TYPE' NE 'CALL').GOON#
         AIF   (('&TEXT' NE '') AND ('&TEXT' NE '&GMNAME')).GOON#
         AIF   ('&HAVELEN' NE '' AND '&GECFM' EQ 'F').BADHAVE
         AIF   ('&GECFM'(1,1) EQ 'F').NORMBAL
         AIF   ('&HAVELEN' EQ '').VBAL
.CHKH    AIF   ('&HAVELEN'(1,1) EQ 'H').NORMBAL
.BADHAVE MNOTE 8,'INVALID LENGTH INDICATOR - &HAVELEN'
         MEXIT
.VBAL    BAL   &GBREG,&GBNAME@
         MEXIT
.NORMBAL BAL   &GBREG,&GBNAME#
         MEXIT
.GOON#   ANOP
         AIF   (('&TYPE' EQ 'CALL') AND ('&TEXT'(1,1) NE '''')).CALLBAL
         AIF   (('&TYPE' EQ 'TEXT') AND ('&TEXT'(1,1) NE '''')).BADTT
&LEN     SETA  K'&TEXT-2                TRIAL LENGTH OF TEXT = COUNT
&LIM     SETA  &LEN                     MAXIMUM LENGTH = MAX(&COUNT)
&COUNT   SETA  2                        OFFSET INTO TEXT
.*  ALLOW FOR DOUBLE QUOTES
.LOOP    AIF   (&COUNT GT &LIM).OUT
         AIF   ('&TEXT'(&COUNT,1) NE '''').GOON  NO QUOTE YET
&LEN     SETA  &LEN-1                   DECREMENT 'REMAINING' COUNTER
&COUNT   SETA  &COUNT+1                 INCREMENT POINTER FOR 1 QUOTE
.GOON    ANOP
&COUNT   SETA  &COUNT+1                 INCREMENT POINTER FOR THIS BYTE
         AGO   .LOOP                    GO TILL DONE WITH ALL TEXT
.OUT     ANOP                           ALL DONE
&LEN     SETA  &LEN-1                   EXECUTE LENGTH
         AIF   (&LEN LE &GAXEX).OKLEN   THE LENGTH IS OK
&COUNT   SETA  &LEN+1                   BACK TO REAL LENGTH (SCRATCH)
         MNOTE 8,'TEXT LENGTH (&COUNT) IS GREATER THAN MAX (&GAXLEN)'
         MEXIT
.OKLEN   AIF   ('&TYPE' EQ 'TEXT').TEXT# TYPE=TEXT
.*********************************************************************.
.*  TYPE=CALL ... CALL THE BAL ROUTINE WITH THE CORRECT MSG          *.
.*********************************************************************.
         AIF   ('&TEXT'(1,1) NE '''').CALLBAL
         LA    R15,=C&TEXT
         AIF   (&LEN NE 0).LA
         XR    R1,R1
         AGO   .BALL
.LA      LA    R1,&LEN
.BALL    BAL   &GBREG,&GBNAME$
         MEXIT
.CALLBAL ANOP
         AIF   ('&TEXT'(1,1) NE '(').NOTREG
         AIF   (('&TEXT(1)' EQ '15') OR ('&TEXT(1)' EQ 'R15')).BALBAL
         LR    R15,&TEXT
         AGO   .BALBAL                  AND PRINT
.NOTREG  LA    R15,&TEXT
.BALBAL  BAL   &GBREG,&GBNAME
         MEXIT
.*********************************************************************.
.*  TYPE=DCB  ... GEN THE DCB                                        *.
.*********************************************************************.
.DCB     ANOP
         SPACE 1
*DCBNAME DCB   DDNAME=DDNAME,MACRF=PM,RECFM=RECFM,LRECL=LRECL
*              BLKSIZE=BLKSIZE,DSORG=PS
         SPACE 1
&GCBNAME DCB   DDNAME=&GDNAME,MACRF=PM,RECFM=&GECFM,LRECL=&GRECL,      #
               BLKSIZE=&GLKSIZE,DSORG=PS
         MEXIT
.*******************************************************************.
.*  TYPE=OPEN                                                        *.
.********************************************************************.
.OPEN    ANOP
*        OPEN  (DCB,OUTPUT)             OPEN THE PRINT FILE
         OPEN  (&GCBNAME,OUTPUT)
         TM    &GCBNAME+48,X'10'
&NUMBER  SETA  &NUMBER+1
&LABBO   SETC  '&NUMBER'(1,2)
&LABBO   SETC  '&GBNAME$'.'&LABBO'
         BO    &LABBO
*        ABEND 1100 NO, ABEND NOW
         LA    R1,1100
*        ABEND (1)
         ABEND (1)
&LABBO   DS    0H
         MEXIT
.*********************************************************************.
.*  TYPE=CLOSE                                                       *.
.*********************************************************************.
.CLOSE   ANOP
         SPACE 1
*        CLOSE DCBNAME CLOSE THE OUTPUT FILE
         CLOSE &GCBNAME
         MEXIT
.*********************************************************************.
.*  TYPE=TEXT ... MAKE THE MSG                                       *.
.*********************************************************************.
.TEXT#   ANOP
         AIF   ('&NAME' NE '').OKTEXTN  NEED NAME
         MNOTE 8,'NAME FIELD REQ WITH TYPE=TEXT'
         MEXIT
.OKTEXTN DC    AL1(&LEN)
&NAME    DC    C&TEXT
         MEXIT
.BADTT   MNOTE 8,'WITH TYPE=TEXT, A QUOTED STRING MUST BE SUPPLIED'
         MEXIT
.*********************************************************************.
.*  TYPE=GEN ... GENERATE THE BAL ROUTINE TO PROCESS THE MESSAGES    *.
.*********************************************************************.
.GEN     ANOP
         SPACE 1
         AIF   ('&GECFM'(1,1) EQ 'V').VBA  RECFM=V NEEDS MORE
&GBNAME  BCTR  R15,0                    BACK UP TO GET LENGTH
         IC    R1,0(,R15)               GET EXECUTE LENGTH
         LA    R15,1(,R15)              FIX THE TEXT PTR
&GBNAME$ EX    R1,&GBN.MVC              MOVE THE MESSAGE TO BUFFER
*        PUT   DCB,BUFFER PRINT FIXED LENGTH MESSAGE
&GBNAME# PUT   &GCBNAME,&GMNAME         PRINT THE MESSAGE
         MVI   &GMNAME,C' '             CLEAR OUT THE MESSAGE BUFFER
         MVC   &GMNAME+1(&GAXEX),&GMNAME
         BR    &GBREG                   RETURN TO CALLER
         SPACE 1
&GBN.MVC MVC   &GMNAME.(0),0(R15)       <<< EXECUTED >>>
         SPACE 1
&GMNAME  DC    CL&GAXLEN' '             MESSAGE BUFFER
.LENLEN# ANOP                           FROM V
&LENLEN  SETC  '&GMNAME'(1,4)
&LENLEN  SETC  '&LENLEN'.'L'
&LENLEN  EQU   &GAXLEN                  LENGTH OF MSG BUFFER
         MEXIT
.*
.*  RECFM=V, WORRY ABOUT RDW
.*
.VBA     ANOP
&GBNAME  BCTR  R15,0                    BACK UP TO GET LENGTH
         XR    R1,R1                    FOR IC
         IC    R1,0(,R15)               GET EXECUTE LENGTH
         LA    R15,1(,R15)              FIX THE TEXT PTR
&GBNAME$ EX    R1,&GBN.MVC              MOVE THE MESSAGE TO BUFFER
&GBN.LEN LA    R1,1+4(,R1)              RECFM=V, MAKE RDW ACTUAL LENGTH
         STH   R1,&GBN.RDW              SAVE LENGTH IN RDW
*        PUT   DCB,BUFFER PRINT OUT THE RECFM=V MESSAGE
&GBNAME# PUT   &GCBNAME,&GBN.RDW        PRINT THE RECFM=V MESSAGE
         MVI   &GMNAME,C' '             CLEAR OUT THE MESSAGE BUFFER
         MVC   &GMNAME+1(&GAXEX),&GMNAME
         BR    &GBREG                   RETURN TO CALLER
         SPACE 1
&GBNAME@ LA    R1,&GMNAME+&GAXEX-1      POINT TO END OF BUFFER
         LA    R0,&GMNAME+2             WHERE TO STOP
&GBN.LP  CR    R0,R1                    STOP LOOKING YET?
         BE    &GBN.GOT                 YES, WE ARE DONE
         CLI   0(R1),C' '               NON-BLANK HERE?
         BNE   &GBN.GOT                 YES, WE HAVE LENGTH
         BCT   R1,&GBN.LP               FIND END OF BUFFER
         SPACE 1
&GBN.GOT LA    R0,&GMNAME               POINT TO BUFFER
         SR    R1,R0                    GET LENGTH OF RECFM V LINE
         B     &GBN.LEN                 AND SAVE IT
         SPACE 1
&GBN.MVC MVC   &GMNAME.(0),0(R15)       <<< EXECUTED >>>
         SPACE 1
&GBN.RDW DC    0F'0',AL2(0),AL2(0)      RDW FOR RECFM=V
&GMNAME  DC    CL&GAXLEN' '             MESSAGE BUFFER
&LENLEN  SETC  '&GMNAME'(1,4)
&LENLEN  SETC  '&LENLEN'.'L'
&LENLEN  EQU   &GAXLEN                  LENGTH OF MSG BUFFER
.MEND    MEND
ESDX TITLE 'E S D X R E F  --  FORM CROSS REFERENCE OF EXTERNAL NAMES'
*
*
ESDXREF  CSECT ,
*
*
*  ESDXREF
*
*
*
*  VIC TOLOMEI      9/77       CCN
*
*
*  GO THROUGH EVERY ESD OF ALL LOAD MODULES IN LIBRARY (LIBRARIES)
*  FROM ANY DD AND FORM A CROSS-REFERENCE OF ALL EXTERNAL SYMBOLS
*  BY MODULE NAME.
*
*  THIS ROUTINE USES SUBROUTINE "ESDREAD" TO READ IN ENTIRE TABLE
*  OF ESD'S FOR THE LIBRARY (LIBRARIES) ON ALL DD'S FOUND.
*
*  TABLE ENTRIES RETURNED ARE OF THE FORM:
*
*        CL8'AN_EXTERNAL_NAME_IN_THAT_MODULE',CL8'MODULE_NAME'
*
*
*  THE TABLE IS BUBBLE-SORTED, AND THE CROSS REFERENCE IS PRINTED
*  ON A PAGE OF SIZE (LINES):
*
PAGESIZE EQU   60
*
*
*  NOTE: THE TABLE IS PRINTED IN TWO WAYS -
*        1) SORTED BY ESD NAME
*        2) SORTED BY MODULE NAME (SIMILAR IN CONCEPT TO THE OUTPUT
*           FROM IMBMDMAP)
*
*
*  THE MAXIMUM NUMBER OF LIBRARY DD'S ALLOWED IN ONE RUN IS:
*
DDMAX    EQU   20
*
         TITLE 'E S D X R E F  --  INITIALIZE'
*
*  ESDXREF
*
         SPACE 2
ESDXREF  CSECT
         SAVE  (14,12),,*               SAVE CALLER'S REGS
         LR    R12,R15                  SET BASE REG
         OACUSING ESDXREF,R12           TELL THE WORLD
         LA    R15,SAVEAREA             POINT TO OUR SAVEAREA
         ST    R15,8(,R13)              LSA TO HIS
         ST    R13,4(,R15)              HSA TO MINE
         LR    R13,R15                  SET SAVEAREA PNTR
         OPEN  (MSGDCB,OUTPUT)          OPEN PRINT FILE
         TM    MSGDCB+48,X'10'          OPEN?
         LA    R1,100                   ABEND CODE IN CASE
         BO    *+6                      BIF OPEN
         SVC   13                       ELSE ABEND
         SPACE 3
*
*  REGISTER USAGE:
*
         SPACE 1
RTABE    EQU   R11                      TABLE ADDRESS       (BXLE)
RTABI    EQU   R10                      TABLE ENTRY LENGTH  (BXLE)
RTAB     EQU   R9                       TABLE END           (BXLE)
RBAL     EQU   R8                       BAL REG
RLEN     EQU   R8                       TABLE ENTRY LEN     (SORT TEMP)
RTABE$   EQU   R7                       TABLE ADDRESS       (SORT ONLY)
RTABI$   EQU   R6                       TABLE ENTRY LENGTH  (SORT ONLY)
RTAB$    EQU   R5                       TABLE END           (SORT ONLY)
RBUF     EQU   R7                       OUTPUT BUFFER PTR   (DUMP ONLY)
RBUFE    EQU   R6                       OUTPUT BUFFER ENDH  (DUMP ONLY)
RBALMSG  EQU   R4                       MSG BAL REG
RPARM    EQU   R3                       RETURN PARM REG FROM ESDREAD
         SPACE 6
*
*  SET UP OUTPUT FILE
*
         SPACE 1
         MSG   TYPE=SET,FACTOR=HALFTRK,RECFM=VBA,BALREG=RBALMSG
         TITLE 'E S D X R E F  --  BUILD THE DD TABLE'
*
*  BUILD THE DD (DSN) TABLE TO PASS TO ESDREAD
*
         SPACE 2
         LA    R15,DDTAB                FIND TABLE
         OACUSING PARMLIST,R15             TEMP BASE
         L     R1,16                    GET CVT
         L     R1,0(,R1)                GET NEW/OLD DISPATCHER DBLW
         L     R1,4(,R1)                GET OLD = MY TCB
         L     R1,12(,R1)               GET MY TIOT
         LA    R14,24                   OFFSET TO NEXT DDNAME
         SPACE 2
DDBLOOP  AR    R1,R14                   POINT TO NEXT DDNAME
         IC    R14,0(,R1)               GET ITS LENGTH
         LTR   R14,R14                  END OF TIOT?
         BZ    DDGOT                    YES, WE HAVE A TABLE
         CLC   4(4,R1),=C'XREF'         XREF DDNAME?
         BNE   DDBLOOP                  BIF NO - CHECK NEXT DDNAME
         SPACE 1
         C     R15,=A(DDTABE)           NO MORE ROOM IN DDNAME TABLE?
         BE    DDOFLO                   RIGHT, ARG
         MVC   PARMDD,4(R1)             NO, COPY TIOT DDNAME TO PARMLST
         LA    R15,PARML(,R15)          NEXT PARMLIST ENTRY
         B     DDBLOOP                  CONTINUE BUILDING PARMLIST
         SPACE 2
         OACDROP R15
         SPACE 2
         OACINUSE ,
         EJECT
*
*  BUILD TABLE BY PASSING DDNAMES TO ESDREAD
*
         SPACE 2
DDGOT    LA    R1,DDTAB                 GET PARMLIST
         SR    R15,R1                   GET LENGTH OF PARMLIST, ANY?
         BNP   BADDD                    NO, YICH
         XR    R14,R14                  YES, FOR DIVIDE
         D     R14,=A(PARML)            GET NUMBER OF PARM ENTRIES
         STH   R15,DDNUM                SAVE AS LINES TO NOT PRINT
         SPACE 2
         L     R15,=V(ESDREAD)          GET ROUTINE NAME
         BALR  R14,R15                  GO GET/BUILD THE TABLE
         SPACE 2
         LR    RPARM,R1                 SAVE RETURN PARM
         SPACE 2
         B     *+4(R15)                 WHAT HAPPENED
         B     GOTTABLE                 0  - OK, SORT THE TABLE
         B     BADDD                    4  - INVALID DD
         B     OFLO                     8  - OFLO IN TABLE
         B     IOERR                    12 - SYNAD
         B     IOERR                    16 - GETENTRY ERROR
         B     NOTFOUND                 20 - NOTHING FOUND
         SPACE 2
GOTTABLE LA    R0,TABLEENT              GET INCREMENT REG FOR BXLE
         ST    R0,4(,RPARM)             SINCE NO FREE TAB CLOBBER TOTLN
         TITLE 'E S D X R E F  --  SORT/PRINT THE TABLE BOTH WAYS'
*
*  SORT AND DUMP THE TABLE FIRST BY ESD NAME
*
         SPACE 2
         BAL   RBAL,SORTPRNT            SORT/PRINT THE TABLE BY ESD
         SPACE 5
*
*  REVERSE THE TABLE TO BE RESORTED BY MODULE NAME
*
         SPACE 2
         LM    RTAB,RTABE,0(RPARM)      SET NEW BXLE REGS
         SPACE 2
         OACUSING TABLED,RTAB
         OACINUSE ,
         SPACE 2
         SPACE 1
REVLOOP  LM    R14,R15,TABLEESD         GET ESDNAME
         LM    R0,R1,TABLEMOD           GET MODNAME
         STM   R14,R15,TABLEMOD         SWITCH
         STM   R0,R1,TABLEESD           ...
         BXLE  RTAB,RTABI,REVLOOP       CONTINUE
         SPACE 2
*
*  FORM AND DUMP THE TABLE FIRST BY MODULE NAME
*
         SPACE 2
         MVI   LINE+1,1                 RESET LINE COUNT TO EJECT PAGE
         MVC   WHICHOFF(11),=C'MODULE NAME'
         MVC   ONEOFF,=C'MOD'           SET NEW HDR
         MVC   TWOOFF,=C'ESD'           SET NEW HDR
         SPACE 1
         BAL   RBAL,SORTPRNT            SORT/PRINT THE TABLE BY MOD
         TITLE 'E S D X R E F  --  EXITS'
*
*  EXITS
*
         SPACE 2
DONE     MSG   '-=====   E S D X R E F   PROCESSING COMPLETED   ====='
         SPACE 2
******   STOP  CLOSE=MSGDCB,RC=0        BYE BYE, DON'T FREE TABLE
         CLOSE (MSGDCB)                 CLOSE MSG FILE
         L     R15,=V(PAR#SORT)         ADDR OF ESDSORT CNTL DATA
         LM    R0,R1,12(R15)            SIZE/LEN OF POSSIBLE CNTL TABLE
         LTR   R0,R0                    ANY WORKAREA?
         BZ    BYEBYE                   BIF NO
         FREEMAIN R,LV=(0),A=(1)        FREE SORT DATA TABLE
BYEBYE   L     R13,4(,R13)              CALLER'S SAVEAREA
         LM    R14,R12,12(R13)          RESTORE CALLER'S REGS
         XR    R15,R15                  SET RETCODE
         BR    R14                      RETURN TO CALLER
         EJECT
*
*  ERROR EXITS
*
         SPACE 2
BADDD    MSG   '-****  INVALID OR MISSING DD CARD(S)  ****'
         B     DONE
         SPACE 2
OFLO     MSG   '-****  OVERFLOW IN NAME TABLE, NEED MORE REGION  ****'
         B     GOTTABLE                 SORT WHAT WE HAVE
         SPACE 2
IOERR    MSG   '-****  I/O ERROR IN MEMBERS, OR I/O ERROR IN DIRECTORY #
                ****'
         B     DONE
         SPACE 2
NOTFOUND MSG   '-****  NO EXTERNAL NAMES FOUND  ****'
         B     DONE
         SPACE 2
DDOFLO   MSG   '-****  TOO MANY DDNAMES SPECIFIED  ****'
         B     DONE
         TITLE 'E S D X R E F  --  BAL ROUTINES'
***********************************************************************
*                                                                     *
*  SORTPRNT                                                           *
*                                                                     *
***********************************************************************
         SPACE 2
*
*  SORT THE TABLE
*
         SPACE 2
SORTPRNT ST    RBAL,0(,R13)             SAVE BAL REG
         L     R15,=V(ESDSORT)          ROUTINE EPA
         L     R1,=V(PAR#SORT)          ROUTINE PARMLIST
         BALR  R14,R15                  SORT TABLE
         SPACE 2
*
*  PRINT THE TABLE
*
         SPACE 2
         LM    RTAB,RTABE,0(RPARM)      SET TABLE BXLE REGS
         LA    RBUFE,TEMPBUF+TEMPBL-8   LAST MODNAME SLOT IN TEMP BUF
         B     DUMPNWST                 SET NEW NAME
         SPACE 2
DUMPLOOP CLC   TABLEESD,OLDNAME         IS THIS A NEW NAME NOW?
         BE    DUMPADMD                 NO, OLD ONE, KEEP ADDING MODS
DUMPBUF  BAL   RBAL,PRINT               YES, DUMP OLD PENDING BUFFER
DUMPNWST MVC   TEMPBUF(8),TABLEESD      SET NEW NAME IN BUFFER
DUMPCNTN LA    RBUF,TEMPBUF+INDENT      INDENT TO 1ST MODULE NAME
DUMPADMD CR    RBUF,RBUFE               IS THERE ROOM FOR ADDED MOD?
         BNH   DUMPCNCT                 YES, CONCATENATE ON END BUFFER
         BAL   RBAL,PRINT               NO, DUMP FULL BUFFER
         B     DUMPCNTN                 CONTINUE SAME ESD WITH NEW BUF
DUMPCNCT MVC   OLDNAME,TABLEESD         NOW NAME IS OLD, REMEMBER IT
         MVC   0(8,RBUF),TABLEMOD       SAVE THIS MODULE NAME
         LA    RBUF,8+1(RBUF)           NEXT SLOT FOR MODULE
         BXLE  RTAB,RTABI,DUMPLOOP      CONTINUE
         SPACE 2
         BAL   RBAL,PRINT               DUMP LAST BUFFER (MAYBE)
         L     RBAL,0(,R13)             RESTORE BAL REG
         BR    RBAL                     RETURN
         SPACE 2
         OACDROP RTAB
         EJECT
***********************************************************************
*                                                                     *
*  PRINT                                                              *
*                                                                     *
***********************************************************************
         SPACE 1
PRINT    LH    R0,LINE                  GET LINE NO
         BCT   R0,PRINTSAM              SAME PAGE
         LA    R1,1                     GET A 1
         AH    R1,PAGE                  GET NEW PAGE NO
         STH   R1,PAGE                  RESET
         CVD   R1,DBLW                  IN DEC
         MVC   PAGEOFF,=X'2020202120'   MASK FOR PAGE
         ED    PAGEOFF-1(6),DBLW+5      GET PAGE TO MSG
         SPACE 1
         MSG   PAGEMSG                  EJECT
         MSG   '0'                      DBL SPACE
         SPACE 1
         LA    R2,DDTAB                 GET DD/DSN TABLE
         OACUSING PARMLIST,R2              TEMP BASE
PRINTLP  MVC   DSNOFF,PARMDSN           COPY A DSN TO MSG
         MSG   DSNMSG                   SAY A DSN
         LA    R2,PARML(,R2)            NEXT ONE
         CLI   0(R2),0                  DONE?
         BNE   PRINTLP                  NO, NEXT MSG FOR NEXT DSN
         SPACE 1
         OACDROP R2
         SPACE 1
         MSG   HDRMSG                   TITLE
         MSG   UNLNMSG                  UNDERLINE
         MVI   MSGBUF,C'0'              DOUBLE SPACE FIRST TIME
         LA    R0,PAGESIZE-7            NEWPAGE, SET CTR (ALLOW HDR)
         SH    R0,DDNUM                 AND ALLOW DSN'S HEADER
         MVC   TEMPBUF(8),OLDNAME       NEW PAGE ALWAYS HAS A MODNAME
         SPACE 1
PRINTSAM STH   R0,LINE                  SAVE NEW LINE NO
         MVC   MSGBUF+1(MSGBL-1),TEMPBUF  SET REAL LINE NOW
         MSG   ,                        PRINT LINE
         SPACE 1
         MVC   TEMPBUF(TEMPBL),MSGBUF   BLANK TEMP BUFFER
         BR    RBAL                     RETURN TO "PRINT" CALLER
         EJECT
***********************************************************************
*                                                                     *
*  MSG                                                                *
*                                                                     *
***********************************************************************
         SPACE 2
         MSG   TYPE=GEN
         SPACE 2
         OACDROP R12
         TITLE 'E S D X R E F  --  DATA'
*
*  DATA
*
         SPACE 2
DBLW     DS    D                        TEMP
SAVEAREA DC    9D'0'                    PGM SAVEAREA
         SPACE 2
LINE     DC    H'1'                     LINE NO (ON LAST, EJECT PAGE)
PAGE     DC    H'0'                     PAGE NO (NONE YET)
         SPACE 2
OLDNAME  DC    CL8' '                   OLD ESD NAME FOR MATCHING
         SPACE 2
         PRINT NOGEN
         MSG   TYPE=DCB
         SPACE 2
PAGEMSG  MSG   '1=====   E S D X R E F   =====   UCLA/OAC EXTERNAL NAME#
                BY MODULE CROSS REFERENCE BY ESD NAME      =====   PAGE#
                XXXXX   =====',TYPE=TEXT
WHICHOFF EQU   PAGEMSG+85               OFFSET TO WHICH SORT THIS IS
PAGEOFF  EQU   PAGEMSG+112,5            OFFSET TO PAGENO
         SPACE 2
DSNMSG   MSG   ' LIBRARY SCANNED: 1234567890123456789012345678901234567#
               8901234',TYPE=TEXT
DSNOFF   EQU   DSNMSG+18,44             OFFSET TO DSN
         SPACE 2
HDRMSG   MSG   '-ESDNAME   MODNAME(S)',TYPE=TEXT
ONEOFF   EQU   HDRMSG+1,3               OFFSET TO TITLE 1
TWOOFF   EQU   HDRMSG+11,3              OFFSET TO TITLE 1
         SPACE 2
UNLNMSG  MSG   '+_______   __________',TYPE=TEXT
         SPACE 2
TEMPBL   EQU   MSGBL-1                  LEN TEMP BUFFER, NO CC
TEMPBUF  DC    (TEMPBL)C' '             TEMP BUILD BUFFER, NO CC
INDENT   EQU   10                       INDENT AFTER ESD NAME
         SPACE 2
         LTORG
         TITLE 'E S D X R E F  --  DSECTS'
*
*  TABLE
*
         SPACE 2
TABLED   DSECT ,                        TABLE ENTRY
TABLEESD DS    CL8                      ESD FOR THIS MODULE
TABLEMOD DS    CL8                      MODULE NAME
TABLEENT EQU   *-TABLED                 LENGTH
TABLELG2 EQU   4                        LOG 2 OF TABLE ENTRY LENGTH
         SPACE 5
*
*  PARMLIST
*
         SPACE 2
PARMLIST DSECT
PARMDD   DS    CL8                      DDNAME
PARMDSN  DS    CL44                     DSNAME
PARML    EQU   *-PARMLIST               LENGTH ENTRY
         SPACE 5
*
*  ACTUAL PARMLIST ALLOWING DDMAX DDNAMES/DSNAMES
*
         SPACE 2
ESDXREF  CSECT
         SPACE 1
DDTAB    DC    (DDMAX)XL(PARML)'00'     DDNAME/DSNAME TABLE
DDTABE   DC    X'00'                    LAST SPOT
         SPACE 1
DDNUM    DC    H'0'                     NUMBER DDNAMES FOUND
         SPACE 2
         OACREGS ,
         SPACE 2
         END
         MACRO
&N       GETENTRY &D,&L,&XFER=LINK,&MF=I
.*
.*  D - DDNAME (ADDR, REG, 'DDNAME')
.*  L - LIST (H'LEN',XL(LEN)) OR IF OMITTED LOCATE FORM ASSUMED
.*      (ENTRY ADDRESS RETURNED IN R1)
.*  XFER - LINK: LINK TO ROUTINE, BUILD LINK LIST
.*         ELSE: ADDR OF WORD WHERE EPA OF GETENTRY IS
.*               (EG: VCON, WORD WHERE LOAD (SVC6) EPA STORED, ETC).
.*
         LCLC  &NN
&NN      SETC  '&N'
         AIF   ('&XFER' NE '' OR '&MF' NE 'I').OKX
         MNOTE 8,'XFER= REQUIRED FOR MF=I'
         MEXIT
.OKX     AIF   ('&MF(1)' EQ 'B' OR '&MF(1)' EQ 'E').MFBE
         AIF   ('&MF' NE 'I').MFL
         AIF   ('&D' NE '').OKD
         MNOTE 8,'DDNAME OPERAND REQUIRED FOR MF=I'
         MEXIT
.OKD     CNOP  0,4
         AIF   ('&XFER' EQ 'LINK').PLUS32
&NN      BAL   1,*+16                   BRANCH AROUND LIST, TYPE=ADDR
         AGO   .SETNN
.PLUS32  ANOP
&NN      BAL   1,*+32                   BRANCH AROUND LIST, TYPE=LINK
.SETNN   ANOP
&NN      SETC  ''                       NO MORE NAME
         AGO   .INLINE                  OK, GO
.MFL     AIF   ('&MF' EQ 'L').INLINE    OK
.BADMF   MNOTE 8,'INVALID MF=&MF'
         MEXIT
.INLINE  ANOP
&NN      DC    A(0)                     RESERVED
         AIF   ('&D' NE '').D
.NODD    DC    A(0)                     DDNAME ADDRESS
         AGO   .L
.D       AIF   ('&D'(1,1) NE '''' AND '&D'(1,1) NE '(').DDACON
         AIF   ('&MF' EQ 'L').BADL
         AGO   .NODD                    MF=L, 'DD' OR (DD), A(0)
.DDACON  DC    A(&D)                    DDNAME ADDRESS
.L       AIF   ('&L' NE '').AL
         DC    A(0)                     INDICATE LOCATE LIST FORM
         AGO   .DONELST
.AL      AIF   ('&L'(1,1) NE '(').LA    LIST ADDR
         AIF   ('&MF' EQ 'I').OK1
.BADL    MNOTE 8,'INVALID OPERANDS WITH MF=L'
         MEXIT
.OK1     DC    A(0)                     LIST ADDRESS
         AGO   .DONELST
.LA      DC    A(&L)                    LIST ADDRESS
.DONELST AIF   ('&XFER' NE 'LINK').DONEIL ADDR NEED NO LIST
         DC    A(*+8)                   LINK EPLOC
         DC    A(0)                     LINK DCB
         DC    CL8'GETENTRY'            LINK EP
.DONEIL  AIF   ('&MF' EQ 'L').MEXIT     DONE
         AIF   ('&D' EQ '').DEND
         AIF   ('&D'(1,1) EQ '''').DQ   QUOTED
         AIF   ('&D'(1,1) NE '(').DEND  DONE DD
         ST    &D(1),4(,1)              SAVE DDNAME ADDRESS IN PARMLIST
         AGO   .DEND
.DQ      LA    0,=CL8&D                 GET DDNAME ADDRESS
         ST    0,4(,1)                  SAVE DDNAME ADDRESS IN LIST
.DEND    AIF   ('&L' EQ '').BAL
         AIF   ('&L'(1,1) NE '(').BAL   REG LIST
         ST    &L(1),8(,1)              SAVE LIST ADDRESS IN PARMLIST
.BAL     AIF   ('&MF(1)' NE 'E' OR '&XFER' NE 'LINK').GO
         LA    0,20(,1)                 GET EPLOC
         ST    0,12(,1)                 SAVE EPLOC IN LINK LIST
.GO      AIF   ('&XFER' EQ 'LINK').LINK
         AIF   ('&XFER'(1,1) EQ '(').REGXFER
         L     15,&XFER                 GET ROUTINE EPA
.BALR    BALR  14,15                    GO TO GETENTRY
         MEXIT
.REGXFER L     15,0&XFER                GET ROUTINE EPA
         AGO   .BALR                    GO
.LINK    LINK  MF=(E,(1)),SF=(E,12(,1))
.MEXIT   MEXIT
.MFBE    AIF   (N'&MF EQ 2).OKEB
         MNOTE 8,'LIST ADDRESS MISSING OR INVALID'
         MEXIT
.OKEB    ANOP
&NN      IHBINNRA &MF(2)
         AIF   ('&D' EQ '').NOD
         AIF   ('&D'(1,1) EQ '''').DQUOT
         AIF   ('&D'(1,1) EQ '(').DREG  REG DD
         LA    0,&D                     GET DDNAME ADDRESS
.ST      ST    0,4(,1)                  SAVE DDNAME ADDRESS IN PARMLIST
         AGO   .NOD
.DREG    ST    &D(1),4(,1)              SAVE DDNAME ADDRESS IN PARMLIST
         AGO   .NOD
.DQUOT   LA    0,=CL8&D                 GET DDNAME ADDRESS
         AGO   .ST
.NOD     AIF   ('&L' EQ '').NOL
         AIF   ('&L'(1,1) EQ '(').REGLEB
         LA    0,&L                     GET LIST ADDRESS
         ST    0,8(,1)                  SAVE LIST ADDRESS IN PARMLIST
         AGO   .NOL
.REGLEB  ST    &L(1),8(,1)              SAVE LIST ADDRESS IN PARMLIST
.NOL     AIF   ('&MF(1)' EQ 'E').BAL    GO
         MEND
         MACRO
&L       PDSLIST &TYPE=BLDL,&DSECT=YES
         LCLC  &P
         AIF   ('&L' NE '').OKLL
         MNOTE 8,'LABEL REQUIRED'
         MEXIT
.OKLL    AIF   (K'&L GE 3).OKL
&P       SETC  '&L'
         AGO   .START
.OKL     ANOP
&P       SETC  '&L'(1,3)
*
.START   AIF   ('&TYPE' EQ 'BLDL').BLDL
         AIF   ('&TYPE' EQ 'PDS').PDS
         MNOTE 8,'TYPE=&TYPE INVALID'
         MEXIT
.BLDL    ANOP
*  BLDL LIST, PDS DIRECTORY ENTRY AFTER BLDL
         AGO   .GO0
.PDS     ANOP
*  PDS LIST, PDS DIRECTORY ENTRY
.GO0     ANOP
*
         AIF   ('&DSECT' EQ 'YES').DSECT
&L       DS    0F
         AGO   .GO1
.DSECT   ANOP
&L       DSECT ,
.GO1     AIF   ('&TYPE' EQ 'PDS').NOPRFX
&P.COUNT DC    H'1' -                   NUMBER OF ENTRIES
&P.LEN   DC    AL2(&P.MLEN) -           LENGTH OF ENTRY
.NOPRFX  ANOP
         SPACE 1
&P.NAME  DC    CL8' ' -                 MODULE NAME
&P.MTTR  DC    XL3'00' -                TTR  OF MEMBER
         AIF   ('&TYPE' NE 'BLDL').NOBLDL
         SPACE 1
&P.CNCAT DC    X'00' -                  CONCATENATION NUMBER TTRC
&P.LIB   DC    X'00' -                  LIBRARY
&P.LINK  EQU   1 -                      MEMBER FOUND IN LINKLIB
&P.JOB   EQU   2 -                      MEMBER FOUND IN JOBLIB
.NOBLDL  SPACE 1
&P.IND   DC    X'00' -                  INDICATORS AND LENGTH
&P.INDA  EQU   X'80' -                  THIS MEMBER IS AN ALIAS
&P.FLEN  EQU   *-&P.NAME -              FIXED LENGTH
         SPACE 1
&P.TTTR  DC    XL3'00' -                TTR OF TEXT RECORD
         DC    X'00' -                  ZEROS
&P.NTTR  DC    XL3'00' -                TTR OF NOTE/SCTR LIST
&P.NOTEL DC    X'00' -                  # ENTRIES IN NOTE LIST
         SPACE 1
&P.ATTR1 DC    X'00' -                  ATTRIBUTES
&P.RENT  EQU   X'80' -                  REENTERABLE
&P.REUS  EQU   X'40' -                  REUSABLE
&P.OVLY  EQU   X'20' -                  OVERLAY
&P.TEST  EQU   X'10' -                  TESTRAN
&P.OL    EQU   X'08' -                  ONLY LOADABLE
&P.SCTR  EQU   X'04' -                  SCTR FORMAT
&P.EXEC  EQU   X'02' -                  EXECUTABLE
&P.NRLD  EQU   X'01' -                  NO RLD'S (1 TEXT BLK)
         SPACE 1
&P.ATTR2 DC    X'00' -                  ATTRIBUTES, 2ND BYTE
&P.LKEDF EQU   X'80' -                  LKED F LEVEL
&P.ORIG0 EQU   X'40' -                  ORIGIN IS 0
&P.EPA0  EQU   X'20' -                  EPA IS 0
&P.NRLD2 EQU   X'10' -                  NO RLD'S HERE
&P.NOREP EQU   X'08' -                  NO REPROCESSING OF THIS MODULE
&P.NOSYM EQU   X'04' -                  NO TESTRAN SYM RECORDS HERE
&P.CRLKF EQU   X'02' -                  MODULE CREATED BY LKED F LEVEL
&P.REFR  EQU   X'01' -                  MODULE IS REFRESHABLE
         SPACE 1
&P.SIZE  DC    AL3(0) -                 LENGTH OF MODULE
&P.SIZET DC    AL2(0) -                 LENGTH OF FIRST TEXT BLOCK
&P.EPA   DC    AL3(0) -                 ENTRY POINT ADDRESS
&P.ORIG  DC    AL3(0) -                 ORIGIN OF FIRST TEXT BLOCK
&P.BLEN  EQU   *-&P.NAME -              LENGTH OF BASIC SECTION
         SPACE 1
&P.MEPA  DC    AL3(0) -                 MODULE EPA
&P.ALIAS DC    CL8' ' -                 MEMBER OF WHICH THIS IS ALIAS
         SPACE 1
&P.RLEN  EQU   64-(*-&P.NAME) -         REMAINING LENGTH
         DC    (&P.RLEN)X'00' -         RESERVED
&P.MLEN  EQU   *-&P.NAME -              MAXIMUM ENTRY LENGTH
         MEND
ESDR     TITLE 'E S D R E A D  --  SUBROUTINE TO BUILD ESD TABLE'
*
ESDREAD  CSECT ,
*
*
*
*  ESDREAD
*
*
*
*  VIC TOLOMEI      9/77       CCN
*
*
*
*  GO THROUGH EVERY ESD OF ALL LOAD MODULES IN LIBRARY (LIBRARIES)
*  FIND ALL EXTERNAL SYMBOLS IN ALL PDS'S REPRESENTED BY PASSED DD'S.
*
*  THIS IS A SUBROUTINE BUYS AS MUCH OF A TABLE OF 16-BYTE ENTRIES
*  AS THE REGION WILL ALLOW, AND FILLS THIS TABLE WITH
*  EXTERNALNAME/MODULE MATCHES, IE:
*
*        CL8'AN_EXTERNAL_NAME_IN_THAT_MODULE',CL8'MODULE_NAME'
*
*  THIS TABLE IS RETURNED AS OUTPUT, AND THE CALLER IS
*  RESPONSIBLE TO FREE THE TABLE.
*
*
*  INPUT:      R1  => CL8'DD1',CL44,...,CL8'DDN',CL44,X'00'
*  OUTPUT:     R1  => A(TAB_ADDR),A(TAB_LEN),A(TAB_LAST)
*              DSNAMES FILLED IN EACH 44 BYTE INPUT AREA
*              R15 => 0 - SUCCESS (R1 IS VALID)
*                     4 - INVALID DDNAME
*                     8 - TABLE OVERFLOW
*                    12 - I/O ERROR ENCOUNTERED ON MEMBER INPUT
*                    16 - ERROR ON DIRECTORY INPUT
*                    20 - NO EXTERNAL NAMES FOUND
*
*
*  OVERHEAD ALLOWED IN REGION FOR OPEN ETC, NOT TO BE USED IN TABLE:
*
OVERHEAD EQU   10*1024                  10K
*
*
*  MACROS AND ROUTINES USED:
*
*        GETENTRY, GETMAIN, FREEMAIN, OPEN, CLOSE, RDJFCB, LOAD
*        DELETE, BEGIN, RETURN, READ, CHECK, POINT
*
         TITLE 'E S D R E A D  --  INITIALIZE'
*
*  ESDREAD
*
         SPACE 2
ESDREAD  CSECT
         SAVE  (14,12),,*               SAVE CALLER'S REGS
         LR    R12,R15                  SET BASE REG
         OACUSING ESDREAD,R12           ADDRESSIBILITY
         LA    R15,SAVEAREA             PNT TO PROGRAM SAVEAREA
         ST    R15,8(,R13)              LSA IN HIS
         ST    R13,4(,R15)              HAS IN MINE
         LR    R13,R15                  SET SAVEAREA PNTR
         SPACE 1
RTABE    EQU   R11                      TABLE END           (BXLE)
RTABI    EQU   R10                      TABLE ENTRY LENGTH  (BXLE)
RTAB     EQU   R9                       TABLE ADDRESS       (BXLE)
RESD     EQU   R8                       ESD BLK PTR
RLIST    EQU   R7                       GETENTRY LIST PTR
RRC      EQU   R6                       RETURN CODE
RDECB    EQU   R5                       MEMBER READ DECB
RPDS     EQU   R4                       PDS DIRECTORY ENTRY
RPARM    EQU   R3                       PARM PTR (CL8,CL44)
         TITLE 'E S D R E A D  --  GET AS BIG A TABLE AS POSSIBLE'
*
*  ATTEMPT TO GET AS MUCH TABLE AS POSSIBLE
*
         SPACE 1
         LR    RPARM,R1                 SAVE PARM PTR IN OK REG
         SPACE 1
         OACUSING PARMLIST,RPARM
         GETMAIN VC,MF=(E,CORELIST)     BUY OUT THE REGION
         SPACE 1
         FREEMAIN V,MF=(E,CORELIST)     FREE IT BEFORE WE DIE
         SPACE 1
         L     R0,TABLELEN              GET MAX POSSIBLE TABLE LEN
         SRL   R0,TABLELG2              ROUND DOWN TO NEAREST ENTRY
         SLL   R0,TABLELG2              ...
         SH    R0,=Y(OVERHEAD)          ALLOW OVERHEAD FOR OPEN ETC
         ST    R0,TABLELEN              SAVE NEW LENGTH FOR RETURN
         ST    R0,PAR#SORT+12           PASS WORKAREA SIZE TO ESDSORT
         GETMAIN R,LV=(0)               GET THE REAL TABLE NOW
         ST    R1,PAR#SORT+16           SAVE ADDR FOR FREE
         LR    RTABE,R1                 GET START TABLE ADDR
         XC    0(TABLEENT,R1),0(R1)     SET LOW SORT KEY TO ZEROS
         LA    RTAB,TABLEENT(,R1)       GET STARTING TABLE ADDRESS
         ST    RTAB,PAR#SORT            SET ADDR FOR ESDSORT
         ST    RTAB,TABLEADR            SET ADDR FOR MAINLINE EXTRACT
         SPACE 2
         A     RTABE,TABLELEN           POINT PAST END OF TABLE TO STOP
         LA    RTABI,TABLEENT           GET ENTRY LEN
         SR    RTABE,RTABI              SUBTRACT FOR ESDSORT KEY SLOT
         SR    RTABE,RTABI              GET BXLE END TABLE
         OACUSING TABLED,RTAB
         OACINUSE ,
         SPACE 1
         LA    RDECB,DECB               DECB FOREVER
         LA    RLIST,GETLIST            PTR TO GETENTRY LIST FOREVER
         CLI   0(RPARM),0               NULL PARM?
         BE    NONEFND                  YES, NONE FOUND
         TITLE 'E S D R E A D  --  OPEN A DD'
*
*  GET DDNAME AND OPEN FILE. FIND DSN.
*
         SPACE 2
DDLOOP   MVC   DCB+DCBDDNAM(8),PARMDD   SAVE IN MEMBER DCB
         SPACE 2
         GETENTRY (RPARM),MF=(B,(RLIST))  SAVE IN GETENTRY LIST TOO
         SPACE 2
         OPEN  MF=(E,DCBLIST)           OPEN THE INPUT LIBRARY
         SPACE 1
         TM    DCB+DCBOFLGS,X'10'       DID IT OPEN?
         BNO   BADDD                    NO, ARG
         RDJFCB MF=(E,DCBLIST)          GET JFCB FOR DSN
         SPACE 1
         BXH   R15,R15,BADDD            ARG
         SPACE 1
         TM    JFCB+JFCDSORG,JFCORGPO   IS THIS A PO DATASET?
         BNO   BADDD                    NO, ARG
         MVC   PARMDSN,JFCB             RETURN DSN TO CALLER
         TITLE 'E S D R E A D  --  GET A MEMBER'
*
*  GET A MEMBER FROM THE PDS
*
         SPACE 2
MEMLOOP  GETENTRY XFER=GETEPA,MF=(E,(RLIST))  GET A PDS ENTRY
         SPACE 1
         B     *+4(R15)                 WHAT HAPPENED
         B     POINT                    0 - ALL IS WELL
         B     CLOSE                    4 - ALL DONE, END DIR, NEXT
         B     GETERR                   8 - ERROR
         SPACE 2
POINT    LR    RPDS,R1                  SAVE PDS ENTRY PTR
         OACUSING PDSLIST,RPDS
         OACINUSE ,
         SPACE 2
         CLC   PDSMTTR,PDSTTTR          JUST TEXT? SAME TTR'S?
         BE    MEMLOOP                  YES, IGNORE THIS ENTRY
         MVC   TTRZ(3),PDSMTTR          GET MODULE TTR
         SPACE 2
         POINT DCB,TTRZ                 POINT TO 1ST MEMBER BLK
         TITLE 'E S D R E A D  --  FIND ESD''S'
*
*  FIND AN ESD
*
         SPACE 2
BLKLOOP  READ  (RDECB),SF,MF=E          GET A BLK
         SPACE 2
         LH    R2,DECB+6                GET MAX READ LENGTH WHILE WAIT
         SPACE 2
         CHECK (RDECB)                  TWIDDLE TWIDDLE
         SPACE 2
         L     R1,DECB+16               GET IOB
         SH    R2,14(,R1)               GET LENGTH READ
         CH    R2,=Y(ESDBUFL)           TOO LONG FOR ESD?
         BH    MEMLOOP                  YES, PAST ESD'S, NEXT MEMBER
         SPACE 2
*
*  DETERMINE WHAT TYPE OF BLOCK THIS IS
*
         SPACE 1
         XR    R1,R1                    FOR IC
         NI    ESDBUF,255-(X'08'+X'04') THESE ARE SUBTYPES
         IC    R1,ESDBUF                GET ID
         LA    R15,8-1                  NUMBER OF BITS TO SHIFT
         SPACE 1
IDLOOP   SRA   R1,1                     SHIFT A BIT OFF
         BZ    IDGOT                    WE HAVE IT
         BCT   R15,IDLOOP               CONTINUE
         SPACE 1
IDGOT    SLL   R15,2                    *4 FOR BRANCH VECTOR OFFSET
         B     *+4(R15)                 WHAT TYPE OF BLOCK
         B     MEMLOOP                  00 - X'80' - IDR    PAST ESD'S
         B     BLKLOOP                  04 - X'40' - SYM    IGNORE
         B     GOTESD                   08 - X'20' - CESD   WE HAVE IT
         B     MEMLOOP                  12 - X'10' - SC/XL  PAST ESD'S
         EX    0,*                      16 - X'08' - SUBTYPE CAN'T BE
         EX    0,*                      20 - X'04' - SUBTYPE CAN'T BE
         B     MEMLOOP                  24 - X'02' - RLD/CTLRLD PAST
         B     MEMLOOP                  28 - X'01' - CTL    PAST ESD'S
         SPACE 1
*  NOTE: THE 24 CASE INCLUDES BOTH X'03' (CONTROL RLD) AND X'02' (RLD)
         TITLE 'E S D R E A D  --  PROCESS AN ESD BLK'
*
*  WE HAVE AN ESD.  PROCESS ITS ENTRIES.
*
         SPACE 2
GOTESD   LA    RESD,ESDBUF+8            START OF ESD DATA
         LR    R0,RESD                  RE-GET FOR END
         AH    R0,ESDBUF+6              POINT PAST END OF BLK
         OACUSING ESDDATA,RESD
         OACINUSE ,
         SPACE 1
NAMELOOP CR    RESD,R0                  PAST END BLK?
         BNL   BLKLOOP                  YES, GET NEXT BLK
         NI    ESDDTYPE,255-X'F0'       NO, JUST WANT LOW NIBBLE
         CLI   ESDDTYPE,X'00'           SECTION DEFINITION (SD)?
         BE    NAMEGOT                  YES, WE HAVE A NAME
         CLI   ESDDTYPE,X'03'           LABEL REFERENCE (LR)?
         BE    NAMEGOT                  YES, WE HAVE A NAME
NAMENEXT LA    RESD,ESDDL(,RESD)        NEXT ESD ENTRY
         B     NAMELOOP                 CONTINUE THROUGH ESD BLK
         SPACE 3
*
*  WE HAVE AN ESD ENTRY (SECTION DEFINITION OR LABEL REFERENCE)
*
         SPACE 1
NAMEGOT  MVC   TABLEMOD,PDSNAME         SAVE MODULE NAME
         MVC   TABLEESD,ESDDNAME        SAVE EXTERNAL NAME
         BXLE  RTAB,RTABI,NAMENEXT      AND GET NEXT NAME
         B     OFLO                     ARG, TOO MUCH IN TABLE, OFLO
         SPACE 2
         OACDROP RPDS
         OACDROP RESD
         OACINUSE ,
         TITLE 'E S D R E A D  --  EXITS'
*
*  EXITS
*
         SPACE 2
CLOSE    CLOSE MF=(E,DCBLIST)           CLOSE A DD
         LA    RPARM,PARML(,RPARM)      NEXT DD/DSN
         CLI   0(RPARM),0               END PARMLIST?
         BNE   DDLOOP                   NO, CONTINUE
         SPACE 2
DONE     C     RTAB,PAR#SORT            DID WE FIND ANY EXTERNAL NAMES?
         BNH   NONEFND                  NO, ARG
         MVI   0(RTAB),X'FF'            SET LAST HIGH KEY...
         MVC   1(TABLEENT-1,RTAB),0(RTAB) ... FOR ESDSORT
         SR    RTAB,RTABI               YES, BACK UP TO RET BXLE END
         ST    RTAB,TABLEEND            SAVE BXLE END TABLE FOR RET
         ST    RTAB,PAR#SORT+8          LAST ENTRY TO ESDSORT
         XR    RRC,RRC                  RC=0
         SPACE 2
RETURN   TM    DCB+DCBOFLGS,X'10'       FILE STILL OPEN?
         BNO   DELETE                   NO, LEAVE
         CLOSE MF=(E,DCBLIST)           CLOSE THE FILE
         SPACE 2
DELETE   MVI   EXLST,0                  CLEAR FLAGS IN DSNAME RETURN
         SPACE 2
         L     R13,4(,R13)              RESTORE SA
         LA    R1,RETPARMS              SET RETURN PARMLIST
         LR    R15,RRC                  GET RETURN CODE
         L     R14,12(,R13)             RESTORE R14
         RETURN (2,12)                  RESTORE REST AND RETURN
         SPACE 2
         OACDROP RTAB
         OACINUSE ,
         EJECT
*
*  INVALID DD
*
         SPACE 1
BADDD    LA    RRC,4                    INVALID DD
         B     RETURN                   AND LEAVE
         SPACE 3
*
*  TABLE OFLO
*
         SPACE 1
OFLO     LA    RRC,8                    TABLE OFLO
         B     RETURN                   AND LEAVE
         SPACE 3
*
*  I/O ERROR IN MEMBER
*
         SPACE 1
SYNAD    LA    RRC,12                   SYNAD
         B     RETURN                   AND LEAVE
         SPACE 3
*
*  ERROR IN GETENTRY
*
         SPACE 1
GETERR   LA    RRC,16                   ERROR IN GETENTRY
         B     RETURN                   AND LEAVE
         SPACE 3
*
*  NO EXTERNAL NAMES FOUND
*
         SPACE 1
NONEFND  LA    RRC,20                   NONE FOUND
         B     RETURN                   AND LEAVE
         SPACE 2
         OACDROP R12
         OACINUSE ,
         TITLE 'E S D R E A D  --  DATA AND CONSTANTS'
*
*  DATA
*
         SPACE 2
DBLW     DS    D                        TEMP
SAVEAREA DC    18F'0'                   PROGRAM SAVEAREA
         SPACE 2
CORELIST GETMAIN VC,LA=LENGTHS,A=ADDRS,MF=L    GETMAIN/FREEMAIN LIST
         SPACE 1
LENGTHS  DS    0F                       LENGTH FOR VC GETMAIN
LENMIN   DC    X'00000008'              MIN LENGTH
LENMAX   DC    X'00FFFFF8'              MAX LENGTH
         SPACE 2
GETLIST  GETENTRY MF=L,XFER=            GETENTRY LIST
GETEPA   DC    V(GETENTRY)              GETENTRY EPA
         SPACE 2
ESDBUFL  EQU   248                      MAX SIZE ESD BUFFER
ESDBUF   DS    0F,(ESDBUFL)X            ESD BUFFER
JFCB     EQU   ESDBUF                   JFCB OVERLAY
JFCDSORG EQU   98                       OFFSET TO DSORG
JFCORGPO EQU   X'02'                    DSORG=PO
         EJECT
*
*  MORE DATA
*
         SPACE 2
DCBLIST  OPEN  DCB,MF=L                 OPEN/CLOSE LIST
         SPACE 1
         READ  DECB,SF,DCB,ESDBUF,ESDBUFL,MF=L DECB FOR RECFM=U READS
         SPACE 1
         PRINT NOGEN
DCB      DCB   DDNAME=*,DSORG=PS,MACRF=RP,                             #
               RECFM=U,SYNAD=SYNAD,EODAD=MEMLOOP,EXLST=EXLST
         SPACE 1
DCBDDNAM EQU   40                       OFFSET TO DD
DCBOFLGS EQU   48                       OFFSET TO FLAGS
         SPACE 2
TTRZ     DC    F'0'                     TTRZ FOR POINTS
         SPACE 2
EXLST    DC    0F'0',X'87',AL3(JFCB)
         SPACE 2
RETPARMS DS    0F                       RETURN PARMS
ADDRS    DS    0F                       ADDRS FOR VC GETMAIN
TABLEADR DC    A(0)                     +0  - START SORT ADDR
TABLELEN DC    F'0'                     +4  - TABLE LENGTH
TABLEEND DC    A(0)                     +8  - TABLE LAST
         SPACE 2
*  ----  PARMLIST TO ESDSORT + EXTRA WORD FOR TABLE FREE
*  ----  NOTE THERE MUST BE AN ENTRY OF 16X'00' BEFORE THE FIRST
*  ----  ADDRESS TO BE SORTED AND AN ENTRY OF 16X'FF' AFTER THE LAST
*  ----  ADDRESS TO BE SORTED.
         SPACE 2
         ENTRY PAR#SORT                 TELL ESDXREF WHERE WE ARE
         SPACE 2
PAR#SORT DS    0F                       PARMLIST TO ESDSORT
         DC    A(0)                     A(TABLE TO SORT)
         DC    A(TABLEENT)              F'ENTRY LENGTH'
         DC    A(0)                     A(LAST ENTRY)
         DC    A(0)         **CONTIG**  A(TOTAL WORKAREA SIZE)
PAR#ADDR DC    A(0)         **CONTIG**  REAL TABLE START ADDR
         SPACE 2
         LTORG
         TITLE 'E S D R E A D  --  DSECTS'
*
*  TABLE
*
         SPACE 2
TABLED   DSECT ,                        TABLE ENTRY
TABLEESD DS    CL8                      ESD FOR THIS MODULE
TABLEMOD DS    CL8                      MODULE NAME
TABLEENT EQU   *-TABLED                 LENGTH
TABLELG2 EQU   4                        LOG 2 OF TABLE ENTRY LENGTH
         SPACE 5
*
*  ESD DATA ENTRY
*
         SPACE 2
ESDDATA  DSECT ,                        ESD DATA ENTRY DSECT
ESDDNAME DS    CL8                      EXTERNAL NAME OR X'00'
ESDDTYPE DS    X                        TYPE
ESDDADDR DS    AL3                      LKED ADDR OF ENTRY PT
ESDDSEG  DS    X                        SEGMENT NUMBER
ESDDLEN  DS    AL3                      LENGTH THIS ENTRY PT
ESDDL    EQU   *-ESDDATA                LENGTH ESD DATA ENTRY
         SPACE 5
*
*  PARMLIST
*
         SPACE 2
PARMLIST DSECT
PARMDD   DS    CL8                      DDNAME
PARMDSN  DS    CL44                     DSNAME
PARML    EQU   *-PARMLIST               LENGTH ENTRY
         EJECT
         PRINT GEN
         SPACE 1
PDSLIST  PDSLIST TYPE=PDS
         SPACE 2
         OACREGS ,
         SPACE 2
         END
         MACRO
&L       PDSLIST &TYPE=BLDL,&DSECT=YES
         LCLC  &P
         AIF   ('&L' NE '').OKLL
         MNOTE 8,'LABEL REQUIRED'
         MEXIT
.OKLL    AIF   (K'&L GE 3).OKL
&P       SETC  '&L'
         AGO   .START
.OKL     ANOP
&P       SETC  '&L'(1,3)
*
.START   AIF   ('&TYPE' EQ 'BLDL').BLDL
         AIF   ('&TYPE' EQ 'PDS').PDS
         MNOTE 8,'TYPE=&TYPE INVALID'
         MEXIT
.BLDL    ANOP
*  BLDL LIST, PDS DIRECTORY ENTRY AFTER BLDL
         AGO   .GO0
.PDS     ANOP
*  PDS LIST, PDS DIRECTORY ENTRY
.GO0     ANOP
*
         AIF   ('&DSECT' EQ 'YES').DSECT
&L       DS    0F
         AGO   .GO1
.DSECT   ANOP
&L       DSECT ,
.GO1     AIF   ('&TYPE' EQ 'PDS').NOPRFX
&P.COUNT DC    H'1' -                   NUMBER OF ENTRIES
&P.LEN   DC    AL2(&P.MLEN) -           LENGTH OF ENTRY
.NOPRFX  ANOP
         SPACE 1
&P.NAME  DC    CL8' ' -                 MODULE NAME
&P.MTTR  DC    XL3'00' -                TTR  OF MEMBER
         AIF   ('&TYPE' NE 'BLDL').NOBLDL
         SPACE 1
&P.CNCAT DC    X'00' -                  CONCATENATION NUMBER TTRC
&P.LIB   DC    X'00' -                  LIBRARY
&P.LINK  EQU   1 -                      MEMBER FOUND IN LINKLIB
&P.JOB   EQU   2 -                      MEMBER FOUND IN JOBLIB
.NOBLDL  SPACE 1
&P.IND   DC    X'00' -                  INDICATORS AND LENGTH
&P.INDA  EQU   X'80' -                  THIS MEMBER IS AN ALIAS
&P.FLEN  EQU   *-&P.NAME -              FIXED LENGTH
         SPACE 1
&P.TTTR  DC    XL3'00' -                TTR OF TEXT RECORD
         DC    X'00' -                  ZEROS
&P.NTTR  DC    XL3'00' -                TTR OF NOTE/SCTR LIST
&P.NOTEL DC    X'00' -                  # ENTRIES IN NOTE LIST
         SPACE 1
&P.ATTR1 DC    X'00' -                  ATTRIBUTES
&P.RENT  EQU   X'80' -                  REENTERABLE
&P.REUS  EQU   X'40' -                  REUSABLE
&P.OVLY  EQU   X'20' -                  OVERLAY
&P.TEST  EQU   X'10' -                  TESTRAN
&P.OL    EQU   X'08' -                  ONLY LOADABLE
&P.SCTR  EQU   X'04' -                  SCTR FORMAT
&P.EXEC  EQU   X'02' -                  EXECUTABLE
&P.NRLD  EQU   X'01' -                  NO RLD'S (1 TEXT BLK)
         SPACE 1
&P.ATTR2 DC    X'00' -                  ATTRIBUTES, 2ND BYTE
&P.LKEDF EQU   X'80' -                  LKED F LEVEL
&P.ORIG0 EQU   X'40' -                  ORIGIN IS 0
&P.EPA0  EQU   X'20' -                  EPA IS 0
&P.NRLD2 EQU   X'10' -                  NO RLD'S HERE
&P.NOREP EQU   X'08' -                  NO REPROCESSING OF THIS MODULE
&P.NOSYM EQU   X'04' -                  NO TESTRAN SYM RECORDS HERE
&P.CRLKF EQU   X'02' -                  MODULE CREATED BY LKED F LEVEL
&P.REFR  EQU   X'01' -                  MODULE IS REFRESHABLE
         SPACE 1
&P.SIZE  DC    AL3(0) -                 LENGTH OF MODULE
&P.SIZET DC    AL2(0) -                 LENGTH OF FIRST TEXT BLOCK
&P.EPA   DC    AL3(0) -                 ENTRY POINT ADDRESS
&P.ORIG  DC    AL3(0) -                 ORIGIN OF FIRST TEXT BLOCK
&P.BLEN  EQU   *-&P.NAME -              LENGTH OF BASIC SECTION
         SPACE 1
&P.MEPA  DC    AL3(0) -                 MODULE EPA
&P.ALIAS DC    CL8' ' -                 MEMBER OF WHICH THIS IS ALIAS
         SPACE 1
&P.RLEN  EQU   64-(*-&P.NAME) -         REMAINING LENGTH
         DC    (&P.RLEN)X'00' -         RESERVED
&P.MLEN  EQU   *-&P.NAME -              MAXIMUM ENTRY LENGTH
         MEND
GET      TITLE 'G E T E N T R Y  --  GET PDS DIRECTORY ENTRIES'
*
GETENTRY CSECT
*
*  VIC TOLOMEI   -   SEPTEMBER 1977
*
*
*  THIS RE-ENTRANT SUBROUTINE IS TO GET DIRECTORY ENTRIES
*  ONE AT A TIME FROM A PDS OR CONCATENATED PDS'S ON ONE DD CARD.
*
*  AS INPUT TO THE ROUTINE R1 MUST POINT TO A 12-BYTE PARMLIST,
*  WHICH CAN BE SET UP BY THE "GETENTRY" MACRO:
*
*        +0    A(0)                     (WILL BE WORKAREA ADDRESS)
*        +4    A(DDNAME)
*        +8    A(PDSENTRY)
*              'PDSENTRY' IS THE ADDRESS OF THE STORAGE
*              WHERE THE DIRECTORY ENTRY IS TO BE COPIED.
*              THIS CORE MUST HAVE THE FOLLOWING FORM:
*              H'LENGTH OF ENTRY DESIRED',XL(LENGTH).
*              IF THIS ADDRESS IS 0, THEN "LOCATE MODE" IS
*              ASSUMED, AND THE ADDRESS OF THE DIRECTORY ENTRY
*              WILL BE RETURNED IN R1.
*
*  OUTPUT IS AS FOLLOWS:
*
*        R15 = 0  -  SUCCESS
*                    R1 = ADDR OF DIRECTORY ENTRY (LOCATE MODE) OR
*                         LIST FILLED IN
*                    R0 = LENGTH OF ENTRY RETURNED (R1 OR LIST)
*              4  -  END OF PDS(S)
*                    R1 = NUMBER OF DIRECTORY BLKS READ
*              8  -  OPEN OR I/O ERROR
*                    R1 = DIRECTORY BLK NUMBER AT TIME OF ERROR
*
*
*  THIS ROUTINE IS FULLY REENTRANT, REUSABLE AND REFRESHABLE
*
         EJECT
*
*  REGISTER USAGE:
*
         SPACE 1
         OACREGS ,
         SPACE 1
RWORK    EQU   R13                      REENTRANT WORKAREA
RBASE    EQU   R12                      BASE
RPARM    EQU   R11                      PARMLIST
RDCB     EQU   R10                      QSAM DCB
RLIST    EQU   R9                       RETURN LIST ADDRESS OR 0
RDIREND  EQU   R8                       DIRECTORY BLK END PTR
RDIR     EQU   R7                       DIRECTORY BLK PTR
RONE     EQU   R6                       CONSTANT 1
         TITLE 'G E T E N T R Y  --  INITIALIZE'
*
*  INITIALIZE
*
         SPACE 2
GETENTRY CSECT
         SAVE (14,12),,*
         SPACE 2
         LR    RBASE,R15                GET MY BASE
         OACUSING GETENTRY,RBASE        SET IT UP
         SPACE 1
         LR    RPARM,R1                 SAVE PARMLIST
         OACUSING PARM,RPARM            SET THAT UP
         L     RLIST,PARMLIST           GET POSSIBLE RETURN LIST PTR
         LA    RONE,1                   GET A 1
         L     R2,PARMWORK              GET POSSIBLE OLD WORKAREA
         LTR   R2,R2                    FIRST ENTRY, NO WORKAREA
         BNZ   CHKOPEN                  NO, CHECK IF OPEN YET
         SPACE 2
*
*  FIRST CALL, GET AND INITIALIZE WORKAREA
*
         SPACE 1
         LA    R0,WORKLEN               GET LENGTH WORKAREA TO BUY
         GETMAIN R,LV=(0)               GET IT
         LR    R2,R1                    SAVE ADDR TEMPORARILY
         OACUSING WORK,R2               TEMP
         XC    WORK(WORKLEN),WORK       CLEAR OUT WORKAREA FIRST
         ST    R2,PARMWORK              SAVE IN PARMLIST FOR NEXT CALL
         SPACE 1
         MVC   DCB(DCBL),DCBM           SET UP DCB
         L     R1,PARMDD                GET DDNAME ADDR
         MVC   DCB+DCBDDNAM(8),0(R1)    COPY REQUESTED DD OVER
         OACDROP R2
         EJECT
*
*  WITH A WORKAREA, CHAIN SA'S.  REOPEN DCB IF NECESSARY.
*
         SPACE 1
CHKOPEN  ST    R13,4(,R2)               SAVE CALLER'S SA (HSA)
         ST    R2,8(,R13)               LSA NOW
         LR    RWORK,R2                 SET WORKAREA/SAVAREA PTR
         OACUSING WORK,RWORK            BASE FOREVER
         SPACE 2
         LA    RDCB,DCB                 GET DCBADDR FOREVER
         LM    RDIR,RDIREND,ADIR        GET A(BEGIN,END) DIR BLK MAYBE
         TM    DCB+DCBOFLGS,X'10'       OPEN ALREADY?
         BO    NEXTENT                  YES, JUST GET NEXT DIR ENTRY
         ST    RDCB,DCBLIST             NO, SET UP DCB LIST  - DCB
         MVC   DCBLIST(1),DCBLISTM                           - FLAGS
         SPACE 1
         OPEN  MF=(E,DCBLIST)           OPEN UP THE DIRECTORY
         SPACE 1
         TM    DCB+DCBOFLGS,X'10'       OPEN?
         BNO   SYNAD                    NO, ARG, QUIT
         SPACE 2
         OACINUSE ,
         TITLE 'G E T E N T R Y  --  GET A DIRECTORY BLOCK'
*
*  GET A DIRECTORY BLOCK
*
         SPACE 1
GET      GET   (RDCB)                   GET A DIRECTORY BLK
         LR    R0,RONE                  GET A ONE
         A     R0,NUMBLKS               COUNT THIS BLOCK
         ST    R0,NUMBLKS               SAVE IT
         LA    RDIR,2(,R1)              SAVE PTR TO REAL BEGIN OF BLK
         OACUSING PDSENTRY,RDIR         SET BASE
         SPACE 2
         OACINUSE ,
         SPACE 2
         LR    RDIREND,R1               RE-GET PTR TO BEGIN OF BLK
         AH    RDIREND,0(,R1)           GET PTR TO END
         ST    RDIREND,ADIREND          SAVE END OF DIRECTORY NEXT CALL
 TITLE 'G E T E N T R Y  --  RETURN CURRENT ENTRY AND SET UP FOR NEXT'
*
*  FIND THE CURRENT ENTRY. RETURN IT IN SPECIFIED MANNER.
*  SET UP FOR NEXT ENTRY ALSO
*
         SPACE 2
NEXTENT  CR    RDIR,RDIREND             AT END OF BLK?
         BNL   GET                      YES, GET NEXT BLK
         CLI   PDSNAME,X'FF'            END OF DIRECTORY?
         BL    SETNEXT                  NO, SET UP NEXT ENTRY, LEAVE
         SPACE 1
         FEOV  (RDCB)                   YES, NEXT LIB IF ANY
         B     GET                      IF HERE, GET 1ST BLK NEXT LIB
         SPACE 2
SETNEXT  LR    R1,RDIR                  ASSUME "LOCATE" MODE
         IC    R2,PDSIND                GET INDICATORS
         SLL   R2,32-5                  JUST LEN NOW
         SRL   R2,32-6                  *2 FOR LEN IN BYTES
         LA    R2,PDSFLEN(,R2)          GET TOTAL LENGTH OF ENTRY
         LTR   RLIST,RLIST              RETURN LIST OR LOCATE?
         BZ    EXIT                     LOCATE, WE HAVE R1 QUIT WITH R0
         LH    R14,0(,RLIST)            GET REQUESTED LENGTH
         SR    R14,RONE                 GET EXECUTE LENGTH
         BM    SYNAD                    NO, SO WHAT CAN I DO?
         EX    R14,XC                   CLEAR HIS AREA, NOT PREFIX
         SR    R2,RONE                  GET EXECUTE LEN OF REAL ENTRY
         CR    R2,R14                   WHICH IS BIGGER, REQ OR REAL?
         BNH   *+6                      REQ, SO IT ALL CAN FIT
         LR    R2,R14                   REAL, SO TRUNCATE TO REQ
         EX    R2,MVC                   COPY ENTRY TO RETURN LIST
         XR    R1,R1                    NO RETURN LOCATE REG
         AR    R2,RONE                  RESTORE REAL LEN
         SPACE 2
EXIT     LR    R0,R2                    GET LENGTH OF ENTRY IN RET REG
         AR    RDIR,R0                  POINT TO NEXT ENTRY (MAYBE)
         ST    RDIR,ADIR                SAVE FOR NEXT CALL
         SPACE 2
         XR    R15,R15                  SUCCESS
         L     R13,4(,R13)              RESTORE SA FOR NORMAL RETURN
         SPACE 3
RETURN   L     R14,12(,R13)             RESTORE R14
         LM    R2,R12,28(R13)           RESTORE ALL BUT R15,R1 (R0)
         BR    R14                      RETURN TO CALLER WITH GOODIES
         TITLE 'G E T E N T R Y  --  EXITS'
*
*  EXITS
*
         SPACE 1
*
*  EODAD
*
EODAD    LA    R3,4                     END OF DATA, ALL DONE, RC=4
         SPACE 2
QUIT     TM    DCB+DCBOFLGS,X'10'       WAS DCB OPEN?
         BNO   NOCLOSE                  NO, DON'T CLOSE/FREEPOOL
         CLOSE MF=(E,DCBLIST)           CLOSE FILE
         SPACE 1
         FREEPOOL (RDCB)                FREE QSAM BUFFERS
         SPACE 1
NOCLOSE  LR    R1,RWORK                 GET WORKAREA
         L     R2,NUMBLKS               GET NUMBER OF BLKS
         L     R13,4(,R13)              RESTORE SA
         LA    R0,WORKLEN               GET LENGTH
         FREEMAIN R,LV=(0),A=(1)        FREE WORKAREA
         XC    PARMWORK,PARMWORK        CLEAR PTR IN PARMLIST
         LR    R1,R2                    RETURN NUMBER OF BLKS
         XR    R0,R0                    IN CASE
         LR    R15,R3                   RETURN CODE
         B     RETURN                   BYE BYE
         SPACE 3
*
*  SYNAD
*
SYNAD    LA    R3,8                     ERROR, RC=8
         B     QUIT                     GET OUTA HERE FAST
         TITLE 'G E T E N T R Y  --  DATA AND CONSTANTS'
*
*  EXECUTED INSTRUCTIONS
*
         SPACE 3
XC       XC    2(0,RLIST),2(RLIST)      << EXECUTED >>
MVC      MVC   2(0,RLIST),0(RDIR)       << EXECUTED >>
         SPACE 2
         OACDROP ,
         SPACE 2
         OACINUSE ,
         SPACE 3
*
*  DATA
*
         SPACE 2
         PRINT NOGEN
         SPACE 2
DCBM     DCB   DDNAME=*,MACRF=GL,DSORG=PS,EODAD=EODAD,                 #
               RECFM=F,BLKSIZE=256,LRECL=256,SYNAD=SYNAD
DCBL     EQU   *-DCBM                   LENGTH
         SPACE 2
         PRINT GEN
         SPACE 2
DCBLISTM OPEN  (0,INPUT),MF=L
         SPACE 2
         LTORG
         TITLE 'G E T E N T R Y  --  DSECTS'
*
*  WORKAREA DSECT
*
         SPACE 2
WORK     DSECT
SAVEAREA DS    18F                      SAVEAREA
ADIR     DS    A                        CURRENT DIR BLK PTR    |CONTIG|
ADIREND  DS    A                        CURRENT DIR BLK END    |CONTIG|
         SPACE 2
ENTLEN   DS    F                        LENGTH OF CURRENT ENT  |CONTIG|
ENTADDR  DS    A                        ADDR OF CURRENT ENTRY  |CONTIG|
         SPACE 2
DCB      DS    0F,(DCBL)X               REAL DCB
         SPACE 1
DCBDDNAM EQU   40                       OFFSET TO DDNAME (DCBD TOO BIG)
DCBOFLGS EQU   48                       OFFSET TO OPEN BITS
         SPACE 1
DCBLIST  DS    F
         SPACE 2
NUMBLKS  DC    F'0'                     NUMBER DIRECTORY BLKS
         SPACE 2
WORKLEN  EQU   *-WORK                   LENGTH WORKAREA
         SPACE 5
*
*  PARMLIST DSECT
*
         SPACE 2
PARM     DSECT
PARMWORK DS    A                        WORKAREA PTR (0 ON ENTRY)
PARMDD   DS    A                        DDNAME ADDRESS
PARMLIST DS    A                        ADDRESS OF RETURN LIST OR 0
         EJECT
PDSENTRY PDSLIST  TYPE=PDS
         SPACE 2
         END
         TITLE 'E S D S O R T   ---   SORT ESD/MOD ENTRIES'
ESDSORT  CSECT
***********************************************************************
*                                                                     *
*   SORT - SORT ESD/MOD ENTRIES (EACH 16 BYTES)                       *
*                                                                     *
* THIS ROUTINE USES A PARTITION EXCHANGE SORT,                        *
* SEE KNUTH VOL3, P 114 - P 123                                       *
*                                                                     *
*  AT ENTRY: R1 =  ADDR FOLLOWING PARM LIST:                          *
*     A(TABLE TO SORT) (NOTE @ TABLE - 1 ENTRY HAS KEY OF X'00')      *
*     A(ENTRY LENGTH)   CONSTANT OF 16                                *
*     A(LAST ENTRY)     (NOTE LAST ENTRY + 1 HAS KEY OF X'FF')        *
*     A(ENTIRE AREA LENGTH) (INCLUDES DUMMY KEYS ABOVE PLUS           *
*                            ANY EMPTY SPACE AT END OF TABLE)         *
*                                                                     *
*                                                                     *
*                                                                     *
*                                                                     *
*                                                                     *
*                                                                     *
***********************************************************************
         EJECT ,
*   REGISTER USAGE
*        EQU   R0                       (R0 - R3 USED TO SWAP RECORDS)
*        EQU   R1
*        EQU   R2
*        EQU   R3
         SPACE 1
RR1      EQU   R4                       (RR1 - RR4 RECORD KEY/DATA)
RR2      EQU   R5
RR3      EQU   R6
RR4      EQU   R7
         SPACE 1
RI       EQU   R8
RJ       EQU   R9
RICR     EQU   R10                      LENGTH OF ONE ENTRY
RSTACK   EQU   R11                      CUR STACK PTR
         SPACE 1
RL       EQU   R14                      LEFT PTR
RR       EQU   R15                      RIGHT PTR
         SPACE 1
         STM   R0,R15,REGSAVE-*(R15)    SAVE CALLERS REGS
         LR    R12,R15                  SET MY BASE
         USING ESDSORT,R12
         SPACE 1
         XC    CNTPART,CNTPART          NO PARTITIONS YET
         LM    R0,R3,0(R1)              GET SORT PARMS
         STM   R0,R3,SORTPARM           SAVE THEM
         SR    R0,R1                    REAL BEGIN OF CORE AREA
         ST    R0,@CORE                 SAVE @ CORE AREA
         AR    R3,R0                    @ PAST END OF CORE
         ST    R3,@STACKE               IS END OF STACK
         SR    R0,R2                    REAL BEGIN - @ LAST ENT
         LCR   R0,R0                    GET POSITIVE NUMBER
         SRL   R0,4                     GET NUMBER ENTRIES TO SORT
         CVD   R0,DWD                   TO DEC
         MVC   L#NUM(10),=X'40202020202020202120'
         ED    L#NUM(10),DWD+3          TO PRINT AREA
         AR    R2,R1                    PAST LAST ENTRY
         AR    R2,R1                    PAST DUMMY X'FF' AT END
         ST    R2,@STACK                INIT TOP OF STACK
         ST    R2,@STACKH               INIT HIGH WATER MARK
         SR    R3,R2                    GET STACK LENGTH
         SRL   R3,3                     NUMBER OF STACK ENTRIES
         CVD   R3,DWD
         MVC   L#STACK(10),=X'40202020202020202120'
         ED    L#STACK(10),DWD+3
         WTO   MF=(E,L#MSG1)            PRINT MSG1
         SPACE 1
         L     RSTACK,@STACK            INIT STACK PTR
         L     RL,SORTPARM              INIT LEFT PTR
         L     RR,SORTPARM+8            INIT RIGHT PTR
         L     RICR,SORTPARM+4          INIT ENTRY LENGTH
         EJECT ,
*---                SORT SUBFILE BETWEEN (RL,RR) INCLUSIVE         ---*
         SPACE 1
Q2       CL    RSTACK,@STACKH           HAVE NEW HIGH WATER MARK?
         BNH   *+8                      BR IF NOT
         ST    RSTACK,@STACKH           SAVE NEW HIGH WATER MARK
         CR    RL,RR                    ONLY ONE ENTRY?
         BE    Q8                       BR IF ONLY ONE ENTRY
         LR    R1,RR                    LOGIC SWAP OF R(L) AND
         SR    R1,RL                    RECORD BETWEEN RL AND RR
         SRL   R1,5                     KEEP ON RECORD BOUNDARY
         SLL   R1,4                     BACK TO OFFSET FROM RL
         AR    R1,RL                    POINT TO MID-REC
         LM    RR1,RR4,0(R1)            SAVE MID RECORD
         MVC   0(16,R1),0(RL)           SWAP RECORDS
         STM   RR1,RR4,0(RL)
         LR    RI,RL                    SET I = R FOR PARTITION
         LR    RJ,RR                    SET J = L + 1
         AR    RJ,RICR                  PLUS 1
         B     Q3                       GO PARTITION....
         EJECT ,
*---                MAIN PARTITION LOOP                            ---*
         SPACE 1
         CNOP  0,8                      (NOTE: FITS IN PIPLINE)
Q6       LM    R0,R3,0(RJ)              SWAP R(I) WITH R(J)
         MVC   0(16,RJ),0(RI)
         STM   R0,R3,0(RI)
         SPACE 1
Q3       AR    RI,RICR                  TO NEXT ENTRY
         CLC   0(16,RI),0(RL)           LESS THAN K?
         BL    Q3                       BR IF LESS
         SPACE 1
Q4       SR    RJ,RICR                  TO PREV ENTRY
         CLC   0(16,RJ),0(RL)           GREATER THAN K?
         BH    Q4                       BR IF GREATER
         SPACE 1
         CLR   RJ,RI                    RJ > RI
         BH    Q6                       BR TO SWAP K(J) WITH K(I)
         SPACE 1
*---               (END OF PIPELINE CODE)                          ---*
         EJECT ,
         MVC   0(16,RL),0(RJ)           SWAP R(L) AND R(J)
         STM   RR1,RR4,0(RJ)
         SPACE 1
*---                PUT ON STACK                                   ---*
         SPACE 1
         LA    R0,1                     COUNT PARTITION
         AL    R0,CNTPART
         ST    R0,CNTPART
         CL    RSTACK,@STACKE           HAVE SPACE ON STACK?
         BNL   SORTERR                  BR IF OUT OF STACK SPACE
         LR    R0,RR                    COMPUTE R-J
         SR    R0,RJ                    TO SEE WHICH PARTITION
         BZ    Q7LJM1                   GO SORT (L,J-1)
         LR    R1,RJ                    IS LARGER
         SR    R1,RL                    COMPUTE J-L
         BZ    Q7JP1R                   GO SORT (J+1,R)
         CR    R0,R1                    R-J :: J-L
         BL    Q7OTHER                  OTHER WAY
         LR    R0,RJ                    GET J+1
         AR    R0,RICR                  J+1
         LR    R1,RR                    (J+1,R)
         STM   R0,R1,0(RSTACK)          PLACE ON STACK
         LA    RSTACK,8(,RSTACK)        BUMP STACK PTR
         LR    RR,RJ                    SET R = J - 1
         SR    RR,RICR                  - 1
         B     Q2                       AND CONTINUE
Q7OTHER  LR    R0,RL                    GET (L,J-1)
         LR    R1,RJ                    J
         SR    R1,RICR                  -1
         STM   R0,R1,0(RSTACK)          PLACE (L,J-1) ON STACK
         LA    RSTACK,8(,RSTACK)
         LR    RL,RJ                    SET L = J + 1
         AR    RL,RICR                  J+1
         B     Q2                       AND CONTINUE
Q7LJM1   LR    RR,RJ                    GET RR = RJ - 1
         SR    RR,RICR
         B     Q2                       GO SORT (L,J-1)
Q7JP1R   LR    RL,RJ                    GET RL = RJ + 1
         AR    RL,RICR
         B     Q2                       GO SORT (J+1,R)
         SPACE 1
*---                TAKE OFF STACK                                 ---*
Q8       CL    RSTACK,@STACK            STACK EMPTY?
         BE    SORTDONE                 BR IF DONE
         SH    RSTACK,=H'8'             BACK TO LAST ENTRY
         LM    RL,RR,0(RSTACK)          GET PREV (L,R)
         B     Q2                       AND CONTINUE
         EJECT ,
SORTDONE L     R0,CNTPART
         CVD   R0,DWD
         MVC   L#PART(10),=X'40202020202020202120'
         ED    L#PART(10),DWD+3
         L     R0,@STACKH               HWM
         SL    R0,@STACK
         SRL   R0,3                     / STACK ENTRY LENGTH
         CVD   R0,DWD
         MVC   L#USED(10),=X'40202020202020202120'
         ED    L#USED(10),DWD+3
         WTO   MF=(E,L#MSG2)
         SPACE 1
         LM    R1,R3,SORTPARM           @ FIRST,LEN,@ LAST
         SR    R1,R2                    INCLUDE DUMMY X'00' ENT
CKLOOP   CLC   0(16,R1),16(R1)          CHECK ORDER CORRECT?
         BH    SORTBUG                  BRANCH IF BUG
         BXLE  R1,R2,CKLOOP             CHECK THEM ALL
         SPACE 1
         LM    R0,R15,REGSAVE           RESTORE REGS
         BR    R14                      AND RETURN
         SPACE 1
SORTBUG  LR    RR1,R1                   SAVE PTR TO SEQ ERROR
         WTO   'MAS002I (ESDSORT) - SORT SEQUENCE ERROR',ROUTCDE=(11)
         EX    0,*
         SPACE 1
SORTERR  WTO   'MAS001I (ESDSORT) - OUT OF STACK SPACE',ROUTCDE=(11)
         EX    0,*
         EJECT ,
DWD      DC    D'0'
         SPACE 1
REGSAVE  DC    16F'0'                   SAVE FOR CALLERS REGS
         SPACE 1
@CORE    DC    A(0)                     REAL BEGINING OF AREA
@STACK   DC    A(0)                     ADDR OF STACK
@STACKE  DC    A(0)                     STACK END + 1 STACK ENTRY
         SPACE 1
SORTPARM DC    4A(0)
         SPACE 1
@STACKH  DC    A(0)                     STACK HIGH WATER MARK
CNTPART  DC    F'0'                     PARTITION COUNT
L#MSG1   WTO   'MAS000I (ESDSORT) -XXXXXXXXXX ENTRIES,XXXXXXXXXX STACK +
               ENTRIES',ROUTCDE=(11),MF=L
L#NUM    EQU   L#MSG1+23
L#STACK  EQU   L#MSG1+42
         SPACE 1
L#MSG2   WTO   'MAS001I (ESDSORT) -XXXXXXXXXX PARTITIONS,XXXXXXXXXX STA+
               CK ENTRIES USED',ROUTCDE=(11),MF=L
L#PART   EQU   L#MSG2+23
L#USED   EQU   L#MSG2+45
         SPACE 1
         OACREGS ,
         SPACE 1
         END
//*KED.SYSLMOD DD DISP=OLD,SPACE=,DSN=SYS9.MSSLOAD
 ENTRY    ESDXREF
 IDENTIFY ESDXREF('CS01044')
 NAME     ESDXREF$
//
//ESDXREF  EXEC PGM=ESDXREF$
//STEPLIB  DD DISP=SHR,DSN=SYS9.MSSLOAD
//SYSPRINT DD SYSOUT=*
//SYSUDUMP DD SYSOUT=*
//XREF1    DD DISP=SHR,DSN=SYS9.MSSLOAD
