//CSYSMASA JOB MSGCLASS=A,NOTIFY=CSYSMAS,COND=(0,NE)
/*ROUTE PRINT WYLBUR
//ASM EXEC ASMHCL,
//  PARM.LKED='XREF,NCAL,LET,MAP,AC=1'
//ASM.SYSLIB DD
//           DD
//           DD DISP=SHR,DSN=SYS5.MSSMAC
 TITLE 'SALAVGE - COMMENTS - DASD RECOVER / ANALYZE / REPLACE'
*---------------------------------------------------------------------*
*                                                                     *
* SALVAGE - DASD RECOVER / ANALYZE / REPLACE                          *
*                                                                     *
*  HARDWARE (HDA) SALVAGE PROGRAM ---                                 *
*                                                                     *
*  *** BEWARE *** BEWARE *** BEWARE *** BEWARE *** BEWARE *** BEWARE  *
*                                                                     *
*   DO NOT USE THE "WRTSD" COMMAND UNLESS:                            *
*   1 - YOU KNOW WHAT OLTEP 3350PSC M3 & M5 OPTIONS ARE               *
*   2 - YOU UNDERSTAND 3350 SKIP DISPLACEMENT HARDWARE IMPLEMENTATION *
*                                                                     *
*   THIS PROGRAM CAN BE USED TO ASSIGN SKIP DISPLACEMENTS             *
*   BY "HAND" TO 3350'S.  THUS SKIP DISPLACEMENTS MAY BE              *
*   ASSIGNED TO TRACKS ON WHICH M5 WILL NOT FIND ERRORS.              *
*   IN SOME CASES THIS CAN BE FROM SEVERAL MONTHS OF LOGREC           *
*   DATA.  (THIS IS ESP USEFUL ON FIXED HEAD TRACKS).                 *
*                                                                     *
*   IT IS POSSIBLE TO CREATE A SITUATION IN WHICH REPLACING           *
*   THE HDA MAY BE THE FASTEST WAY OUT.                               *
*   (IF SKIP DISPLACEMENTS ARE LOST).                                 *
*                                                                     *
* OLTEP M3/M5 NOTE: OLTEP DOES NOT KNOW ABOUT ALT TRKS.               *
*   WHEN OLTEP REWRITES HOME ADDRESSES, HE MAKES THEM ALL PRIMARIES,  *
*   THUS YOU *MUST* RE-INIT THE PACK TO REWRITE THEM AGAIN.           *
*                                                                     *
*   THE "WRITE" COMMAND CAN WRITE RECORDS WITH COUNT FIELDS WHICH     *
*   DO NOT MATCH THE TRACK THAT THEY ARE ON.  MOST DUMP PROGRAMS      *
*   WILL THEN REFUSE TO DUMP THE DISK PACK.                           *
*                                                                     *
* NOTES: ORIGINAL PLAN WAS TO RECOVER DATA FROM TRACK                 *
*        AND SAVE IN "SAVE" FILE.  THIS CODE WAS NEVER WRITTEN.       *
*        IT IS SAFER TO USE FDRDSF OR EQUIV TO SAVE THE TRACK         *
*        IF POSSIBLE.  THUS SAVE FILE IS OPENED/CLOSED BUT NEVER      *
*        USED.                                                        *
*                                                                     *
*        ICKDSF R6 IS RUMORED TO SUPPORT SKIP DISPLACEMENTS           *
*        ON 3350'S, THUS SOME USES OF SALVAGE MAY SOON BE OBSOLETE.   *
*                                                                     *
*  MICHAEL STEIN                                                      *
*  OFFICE OF ACADEMIC COMPUTING                                       *
*  5628 MATH SCIENCES ADDITION                                        *
*  LOS ANGELES, CALIFORNIA 90024                                      *
*                                                                     *
*    OPTIONS:                                                         *
*             1. RESTART FROM SAVE FILE.                              *
*             2. DISPLAY / ALTER DATA ON TRACK.                       *
*             3. SCAN FOR ERRORS.                                     *
*             4. SCAN/TEST FOR ERRORS. (DESTROYS DATA - FORMAT WRITES)*
*                                                                     *
*                                                                     *
*    JCL (OR FILES TO ALLOCATE FOR TSO)                               *
*                                                                     *
*                                                                     *
*      //    EXEC   PGM=SALVAGE                                       *
*      //STEPLIB  DD DISP=SHR,DSN=???                                 *
*      //SAVE     DD  <SAVE FILE FOR THIS RUN>                        *
* THREE CHOICES FOR FOLLOWING CARD INDICATING VOLUME/UNIT TO FIX:     *
*    PROCESS BY DATASET:                                              *
*      //VOLUME   DD DISP=OLD,DSN=?????                               *
*    PROCESS BY UNIT ADDRESS: (CAN POINT TO ANY UNIT,                 *
*    (UNIT *MUST* BE ONLINE ON AN MVS SYSTEM...)                      *
*       NOT REQUIRED TO BE ONE TO PROCESS, IE: IF VOLUME LABEL BAD)   *
*      //VOLUME   DD DISP=OLD,DSN=     ,VOL=SER=????                  *
*                                                                     *
*      //SYSPRINT DD SYSOUT=A         (LRECL=133,RECFM=FBA)           *
*      //SYSIN    DD *                                                *
*        <CONTROL CARDS OR TSO INPUT>                                 *
*      //                                                             *
*                                                                     *
*---------------------------------------------------------------------*
         EJECT ,
*---------------------------------------------------------------------*
*                                                                     *
*   GENERAL RESTRICTIONS AND ASSUMPTIONS ---                          *
*    (THERE ARE SOME EXCEPTIONS TO THESE ASSUMPTIONS).                *
*     1. EACH TRACK HAS HOME ADDRESS ALREADY WRITTEN WITH THE         *
*        PHYSICAL SEEK ADDRESS OF THAT TRACK.                         *
*     2. EACH TRACK HAS STANDARD FORMAT RECORD ZERO WITH ZERO KEY     *
*        LENGTH AND EIGHT BYTE DATA LENGTH.  RECORD ZERO COUNT FIELD  *
*        CONTAINS LOGICAL TRACK ADDRESS.                              *
*     3. IF THE TRACK CONTAINS ANY OTHER RECORDS, THEY HAVE IDS       *
*        WHICH START WITH RECORD NUMBER ONE AND CONTINUE UP BY ONE.   *
*        ALL RECORD NUMBERS ON THE TRACK ARE UNIQUE AND IN ORDER.     *
*                                                                     *
*        NOTE: THIS DOES NOT REQUIRE THE CCHH PART OF THE RECORD IDS  *
*              OF RECORDS AFTER ZERO TO CONTAIN ANY SPECIFIC VALUE.   *
*                                                                     *
*                                                                     *
*   DEFECTIVE/ALTERNATE TRACKS ---                                    *
*     TRACK CONDITION CHECK (SENSE BIT) - CMD OTHER THAN              *
*         SEARCH HA, READ HA, READ R0 ON DEFECTIVE TRACK.             *
*                                                                     *
*                                                                     *
*     HA CONTAINS SEEK ADDRESS                     (PHYSICAL ADDRESS) *
*     R0 CONTAINS CCHH OF DEFECTIVE IF ALTERNATE,  (LOGICAL ADDRESS)  *
*                 CCHH OF ALTERNATE IF DEFECTIVE.                     *
*        CCHH IN COUNT FIELDS OF RECORDS ON REST                      *
*        OF TRACK MATCH CCHH OF R0.                (LOGICAL ADDRESS)  *
*                                                                     *
*  VM NOTES:                                                          *
*    VIRTUAL ADDRESS IS RELATIVE TO BEGINING OF MINIDISK.             *
*    (STARTS AT CYLINDER ZERO.)                                       *
*                                                                     *
*     HA CONTAINS PHYSICAL SEEK ADDRESS WHICH GETS                    *
*        CHANGED BY VM AFTER READ TO VIRTUAL ADDRESS.                 *
*     R0 CONTAINS VIRTUAL ADDRESS IF CONTROLLER IS NOT 3830,          *
*        ELSE R0 CONTAINS LOGICAL ADDRESS. (FOR CONTROLLER).          *
*     CCHH IN COUNT FIELDS OF RECORDS ON REST                         *
*        OF TRACK CONTAIN VIRTUAL ADDRESSES.                          *
*                                                                     *
*    VM PACKS (OR MINIDISKS) ONLY USE ALTERNATE TRACKS AS SUCH        *
*    ON DEVICES WHICH USE 3830 CONTROLLERS (WHERE THE CONTROLLER      *
*    DOES THE ALTERNATE TRACK RECOVERY.)                              *
*    EACH VM MINIDISK IS SOME INTEGER NUMBER OF CYLINDERS.            *
*                                                                     *
*    (WHY AREN'T THERE V=R MINIDISKS???)                              *
*                                                                     *
*---------------------------------------------------------------------*
         EJECT ,
*---------------------------------------------------------------------*
*                                                                     *
*   DEVICE CHARACTERISTICS                                            *
*                                                                     *
*    2321    -   NOT SUPPORTED  (DATA CELL)                           *
*    2311    -   ?                                                    *
*    2314    -                                                        *
*    2301    -   FILE MASK STRANGE (8 TRACKS/LOGICAL CYL)             *
*                READ COUNT STRANGE                                   *
*    2305-1  -   ?                                                    *
*    2305-2  -                                                        *
*    3330    -                                                        *
*    3330V   -   (SAME AS 3330)                                       *
*    3330-1  -   (3330 WITH MORE CYLINDERS)                           *
*    3350    -   (KNOWS WHAT DEVICE TYPE IT IS)                       *
*                (SENSE I/O TYPE)                                     *
*                                                                     *
*    (2311, 2314)    - TEND TO SEEK TO WRONG TRACK (CHECK HA)         *
*    (2305-1,2305-2) - HA NOT WRITTEN TO TRACK. (ALWAYS CORRECT)      *
*                    - ORIENT CMD (2305-1 ONLY)                       *
*                    - VARY SENSING CMD                               *
*      FILE MASK - 01.. .... - NO WRITE COMMANDS                      *
*                  10.. .... - WRITE DATA/KEY DATA ONLY               *
*                  00.. .... - ALL WRITE CMDS BUT WRITE HA / R0       *
*                  11.. .... - ALL WRITE CMDS ALLOWED                 *
*                  ..X. .... - <UNUSED>                               *
*                  ...0 0... - ALL SEEK COMMANDS                      *
*                  ...0 1... - SEEK CYL / HEAD ONLY                   *
*                  ...1 0... - SEEK HEAD ONLY                         *
*                  ...1 1... - NO SEEKS ALLOWED                       *
*                  .... .X.. - DIAGNOSTIC WRITE                       *
*                  .... ..0X - PERMIT COMMAND RETRY                   *
*                  .... ..01 - INTERUPT AFTER CMD RETRY (PCI FETCH)   *
*                  .... ..10 - INHIBIT COMMAND RETRY (2305 ONLY)      *
*                                                                     *
*    (3350)          - SKIP DISPLACEMENTS                             *
*                                                                     *
*       SKIP DISPLACEMENT MAPS ON CE CYLINDERS:                       *
*        CYL 0401 HEAD 0; EACH BLOCK ON TRK 7F8 LONG;                 *
*          MAY BE MORE THAN ONE BLOCK;                                *
*        'SDMAP' FOLLOWED BY 9 BYTES ENTRIES  CCH SD SD SD            *
*         ONLY TRACKS WITH NON-ZERO SKIP DISPLACEMENT ARE LISTED      *
*         CC OF X'FE00' AT END OF MAP (FOLLOWED BY ALL ZEROS)         *
*                                                                     *
* FIX LIST: 3375'S AND 3380'S COMPUTE MAX BLOCK DIFFERENTLY;          *
*           USE TRKCALC MACRO OR ???                                  *
*                                                                     *
*---------------------------------------------------------------------*
 TITLE 'SALAVGE - MACROS - DASD RECOVER / ANALYZE / REPLACE'
         MACRO
&LBL     RCALL &RTN,&R1,&R0,&ERRAD=
         LCLC  &L
&L       SETC  '&LBL'
         AIF   ('&R1' EQ '' OR '&R1' EQ '(R1)').R1OK2
         AIF   ('&R1'(1,1) EQ '(').R1REG
         AIF   ('&R1' EQ '0').R1Z
&L       LA    R1,&R1
         AGO   .R1OK1
.R1Z     ANOP
&L       SR    R1,R1
         AGO   .R1OK1
.R1REG   ANOP
&L       LR    R1,&R1(1)
.R1OK1   ANOP
&L       SETC  ''
.R1OK2   ANOP
         AIF   ('&R0' EQ '' OR '&R0' EQ '(R0)').R0OK2
         AIF   ('&R0'(1,1) EQ '(').R0REG
         AIF   ('&R0' EQ '0').R0Z
&L       LA    R0,&R0
         AGO   .R0OK1
.R0Z     ANOP
&L       SR    R0,R0
         AGO   .R0OK1
.R0REG   ANOP
&L       LR    R0,&R0(1)
.R0OK1   ANOP
&L       SETC  ''
.R0OK2   ANOP
&L       BALR  R10,R12                  TO RCALL
         DC    Y(&RTN-$)                OFFSET OF ROUTINE
         AIF   ('&ERRAD' EQ '').EXIT
         BNZ   &ERRAD
.EXIT    MEND
         SPACE 1
         MACRO
&LBL     DEVICE &NAME,&TYPE,&ALT=0,&CE=(0,0)
&LBL     DC     CL8'&NAME',XL1'&TYPE',XL17'00',Y(&ALT),Y&CE
         MEND
         SPACE 1
         MACRO
&LBL     SBIT  &FLD,&BYTE,&BIT,&MSG
         LCLA  &A
         AIF   ('&FLD' EQ 'CSW').CSW
&A       SETA  16                       SKIP CSW STATUS BITS
.CSW     ANOP
&A       SETA  &A+(&BYTE*8)+&BIT
&LBL     DC    AL1(&A),CL20&MSG
         MEND
         SPACE 1
         MACRO
&LBL     MSG  &M
         LCLA &A,&B
&A       SETA K'&M
&B       SETA &A-1
&LBL     DC   AL1(&B),CL&A&M
         MEND
 TITLE 'SALVAGE - TRACK IMAGE FORMAT DSECT'
* TRACK IMAGE FORMAT:
*  THERE ARE THREE SECTIONS TO THE TRACK IMAGE.
*   1. FIXED LENGTH PREFIX.
*       CONTAINS RDW
*   2. FIXED LENGTH RECORD INDEX.
*       CONTAINS ONE ENTRY FOR EACH OF 257 POSSIBLE RECORDS
*       ON THE TRACK (THE HOME ADDRESS IS THE FIRST).  THESE
*       ENTRIES ARE ADDRESSED BY (REC# * 16) + T#BASE.
*       THIS MAKES THE HOME ADDRESS RECORD -1.
*   3. KEY/DATA AREA (VARIABLE LENGTH).
*       THIS AREA IS POINTED TO BY 'T#ROFF'. IT ALWAYS CONTAINS
*       THE KEY FIRST, THEN THE DATA AREA. NOTE THAT THE KEY
*       MAY NOT BE VALID IF 'T#REFLG,T#RFKEY' IS ON
*       AND 'T#RSFLG,T#RFKEY' IS OFF.
         SPACE 1
T#       DSECT ,
T#RDW    DC    Y(0,0)                   RECORD DESCRIPTOR WORD
         SPACE 1
T#ENTRY  DC    0D'0'                    BEGINING OF ONE RECORD ENTRY
T#REFLG  DC    XL1'00'                  FIELD EXISTS FLAGS
T#RFCNT  EQU   X'80'                     COUNT FIELD
T#RFKEY  EQU   X'40'                     KEY FIELD
T#RFDATA EQU   X'20'                     DATA FIELD
T#RFHA   EQU   X'10'                     HOME ADDRESS
T#RFERR  EQU   X'01'                     PERM ERROR IN RECORD
T#RSFLG  DC    XL1'00'                  FIELD SAVED FLAGS
T#ROFF   DC    H'0'                     OFFSET OF KEY/DATA AREA
         DC    XL4'00'                  <RESERVED>
T#RCNT   DC    XL8'0000000000000000'    COUNT FIELD
T#RL     EQU   *-T#ENTRY
         SPACE 1
T#BASE   EQU   *                        ENTRY FOR RECORD 0
         ORG   *+T#RL*256               HA + 256 RECORDS
T#L      EQU   *-T#                     TOTAL HEADER LENGTH
 TITLE 'SALAVGE - GLOBALS - DASD RECOVER / ANALYZE / REPLACE'
*---------------------------------------------------------------------*
*
*   REGISTER USAGE:   R13 - STACK POINTER
*                     R12 - GLOBAL PROGRAM BASE
*                     R11 - LOCAL PROGRAM BASE
*                     R10 - LINKAGE REGISTER
*
*---------------------------------------------------------------------*
         SPACE 1
SALVAGE  CSECT                          START CSECT
$        EQU   SALVAGE                  BASE FOR OFFSETS (R12)
         USING SALVAGE,R12              GLOBAL BASE
         STM   R2,R11,12+4*R2(R13)      SAVE CALLERS R2 - R11
         SH    R13,=H'72'               BACK UP TO NEXT SAVE AREA
         LH    R11,0(,R10)              GET CALLED ROUTINE OFFSET
         AR    R11,R12                  @ CALLED ROUTINE
         CL    R13,G#STACK              STACK FULL?
         BNLR  R11                      BIF STACK NOT FULL
         EX    0,*                      ** STACK OVERFLOW **
         SPACE 1
RETM     LA    R15,4                    SET RETURN CODE
         LCR   R15,R15                  NEGATIVE RETURN CODE
         B     RET                      AND RETURN
RETNZ    LA    R15,4                    SET RETURN CODE
         B     RET                      AND RETURN
RETZ     SR    R15,R15                  SET RETURN CODE
RET      LA    R13,72(,R13)             STACK PTR BACK UP
         LM    R2,R11,12+4*R2(R13)      RESTORE REGISTERS
         LTR   R15,R15                  SET CONDITION CODE
         B     2(,R10)                  RETURN (SKIP OFFSET)
         SPACE 1
*  S$GET  -  RETURNS TO R10 AFTER GETTING NEXT INPUT RECORD AND
*            SETTING SCAN POINTERS.
*             (MUST UPPER CASE INPUT ***********)
*    CC:  ZERO - EOF HAS OCCURED;  NOT ZERO - NEW INPUT RECORD OBTAINED
*    (SKIPS COMMENT INPUT RECORDS)
*
*     DESTROYS:  R0, R1, R10, R14, R15.
         SPACE 1
S$GET    ST    R10,S#GETSAV             SAVE RETURN ADDR
         NI    S#GETFLG,255-S#FATTN     NO ATTEN YET
         TM    S#GETFLG,S#FEOF          EOF YET?
         BO    S$GETEOF                 BIF EOF ALREADY
S$GET2   GET   SYSIN,S#GETBUF           SET R1 TO ADDR OF INPUT RECORD
         LA    R15,S#GETBUF             @ INPUT RECORD
         LA    R1,S#GETBUF+71           @ LAST BYTE OF INPUT DATA
         LA    R0,1                     INIT CONSTANT FOR SCAN
         STM   R15,R1,S#SCNPTR          SAVE SCAN VALUES
         OC    S#GETBUF(72),=CL72' '    FORCE UPPER CASE
         TM    S#GETFLG,S#FECHO         ECHO INPUT?
         BZ    S$GETCK
         MVC   LINE+1(80),S#GETBUF      SET INPUT RECORD
         BAL   R10,S$PRINT              PRINT THE LINE
S$GETCK  CLI   S#GETBUF,C'*'            COMMENT?
         BE    S$GET2                   BIF COMMENT TO SKIP IT
S$GETE   L     R10,S#GETSAV             RESTORE RETURN ADDR
         BR    R10                      AND RETURN
S$GETEOF OI    S#GETFLG,S#FEOF          SET EOF FLAG
         SR    R15,R15                  SET CC EQUAL
         B     S$GETE                   AND GO RETURN
         SPACE 1
*  S$SCN - RETURNS TO R10 WITH:  CC SET TO LENGTH RETURNED;
*         IF LENGTH IS < 0 THEN NO MORE INPUT RECORD EXISTS.
*         IF LENGTH IS > 0 THEN R15 CONTAINS LENGTH,
*            R14 CONTAINS @ OF STRING.
*     (LENGTH ZERO CAN NOT OCCUR).
*    DESTROYS:  R0, R1, R10, R14, R15.
         SPACE 1
S$SCN    LM    R15,R1,S#SCNPTR          GET SCAN VALUES
S$SCN1   CR    R1,R15                   ANY INPUT LEFT? (SET CC)
         BLR   R10                      RETURN IF NO INPUT LEFT
         SPACE 1
S$SCNLP1 CLI   0(R15),C' '              SKIP LEADING BLANKS
         BNE   S$SCNFD1                 BIF NON-BLANK FOUND
         BXLE  R15,R0,S$SCNLP1          BIF STILL SKIPING BLANKS
         B     S$SCN1                   BIF NO MORE INPUT
         SPACE 1
S$SCNFD1 LR    R14,R15                  SAVE @ INPUT STRING
S$SCNLP2 CLI   0(R15),C' '              SKIP NON-BLANKS
         BE    *+8                      BIF BLANK FOUND
         BXLE  R15,R0,S$SCNLP2          BIF TO SCAN FOR BLANK
         ST    R15,S#SCNPTR             SAVE NEW SCAN PTR
         SR    R15,R14                  GET LENGTH SCANNED
         BR    R10                      AND RETURN
         SPACE 2
*  S$STR -  MOVES STRING TO DWD IF LENGTH <= 8
*           AFTER CALL TO S$SCN.
*       CC:  HIGH IF TOO LONG; ELSE STRING MOVED
         SPACE 1
S$STR    MVC   DWD(8),=CL8' '           INIT OUTPUT TO BLANKS
         CH    R15,=H'8'                STRING TOO LONG?
         BHR   R10                      BIF STRING TOO LONG
         BCTR  R15,0                    GET EX LENGTH
         EX    R15,S$STRMVC             MVC DWD(0),0(R14)
         BR    R10                      AND RETURN
S$STRMVC MVC   DWD(0),0(R14)            * EXECUTED *
         EJECT ,
*  S$HEX - CALLS S$SCN AND RETURNS HEX VALUE IN R0,R1.
*         RETURNS TO R10.
*  CC:  M - NO STRING,
*       Z - INVALID HEX STRING,
*       P - HAVE HEX VALUE
         SPACE 1
S$HEX    ST    R10,G#WORK               SAVE RETURN ADDR
         BAL   R10,S$SCN                GO GET SOME HEX
         L     R10,G#WORK               RESTORE RETURN ADDR
         BMR   R10                      BIF NO INPUT
         CH    R15,=H'16'               CHECK STRING LENGTH
         BH    S$HEXER                  BIF HEX STRING TOO LONG
         SR    R0,R0                    CLEAR FOR SLDL
         SR    R1,R1
         SR    R10,R10                  CLEAR FOR IC
S$HEXL   IC    R10,0(,R14)              GET CHARACTER
         SH    R10,=Y(C'0')             CONVERT 0 - 9
         BNM   S$HEXD                   BIF 0 - 9
         AH    R10,=Y(C'0'-C'A'+X'0A')  CONVERT A - F
         BM    S$HEXER                  BIF < C'A'
         CH    R10,=Y(X'0F')            > C'F'?
         BH    S$HEXER                  BIF > 'F'
S$HEXD   SLDL  R0,4                     MAKE ROOM FOR NEXT HEX DIGIT
         OR    R1,R10                   OR IN DIGIT
         LA    R14,1(,R14)              BUMP CHARACTER PTR
         BCT   R15,S$HEXL               SCAN ALL OF STRING
         LTR   R14,R14                  SET CC POSITIVE
S$HEXE   L     R10,G#WORK               RESTORE RETURN ADDR
         BR    R10                      AND RETURN
S$HEXER  SR    R15,R15                  SET CC ZERO (MISSING INPUT)
         B     S$HEXE                   AND GO RETURN
         SPACE 2
*  S$MSG - R1 = @ EX LEN, MSG
*    PRINTS MSG AND RETURNS
*
S$MSGMVC MVC   LINE+1(0),1(R1)          * EXECUTED *
S$MSG    SR    R15,R15                  CLEAR FOR IC
         IC    R15,0(,R1)               GET MSG LENGTH - 1
         EX    R15,S$MSGMVC             MVC LINE+1(0),1(R1)
*+++++++ B     S$PRINT                  GO PRINT MSG AND RETURN
         SPACE 1
*  S$PRINT  -   R10 - RETURN ADDRESS
*    PRINTS LINE AND BLANKS IT
*
S$PRINT  PUT   SYSPRINT,LINE
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         BR    R10
         SPACE 2
*   S$CLEAR;  S$MOVE  -  R0  - LENGTH TO CLEAR OR MOVE
*                        R1  - TO ADDRESS
*                        R15 - FROM ADDRESS
*                        R10 - RETURN ADDRESS
         SPACE 1
S$CLEAR  LTR   R0,R0                    ANY TO CLEAR?
         BNPR  R10                      RETURN IF NOTHING TO DO
         MVI   0(R1),0                  CLEAR FIRST BYTE
         LR    R15,R1                   SET FROM ADDRESS
         LA    R1,1(,R1)                BUMP TO POINTER
         BCTR  R0,0                     LENGTH LEFT TO CLEAR
         SPACE 1
S$MOVE   LTR   R0,R0                    ANY TO MOVE?
         BNPR  R10                      RETURN IF NONE
         LA    R14,256                  CONSTANT
S$MOVE1  CR    R0,R14                   ROOM FOR BIG MOVE?
         BNH   S$MOVE2                  BIF SMALL MOVE REQUIRED
         MVC   0(256,R1),0(R15)         MOVE SOME OF IT
         AR    R1,R14                   BUMP TO ADDRESS
         AR    R15,R14                  BUMP FROM ADDRESS
         SR    R0,R14                   LENGTH LEFT TO MOVE
         B     S$MOVE1
S$MOVE2  LR    R14,R0                   COPY LENGTH LEFT
         BCTR  R14,0                    GET EXECUTE LENGTH
         EX    R14,S$MOVE3              MVC 0(0,R1),0(R15)
         AR    R1,R0                    BUMP TO ADDRESS
         AR    R15,R0                   AND FROM ADDRESS
         BR    R10                      AND RETURN
S$MOVE3  MVC   0(0,R1),0(R15)           * EXECUTED *
         SPACE 2
S$CCWI   MVC   G#BUFPT,G#BUFIT          RE-INIT BUF AREA PTR
         MVC   G#CCWPT,G#CCWIT          RE-INIT CCW AREA PTR
         L     R2,G#CCWPT               INIT CCW PTR REG
         BR    R10
         SPACE 1
* S$CCWD - BUILD CCW (WITH DATA AREA RESERVED)
* S$CCW  - BUILD CCW (NO DATA AREA RESERVED)
*    R14,R15 - CCW OR PATTERN CCW TO BUILD
*    R2      - @ - 8 FOR THIS CCW
*    R10     - RETURN ADDRESS
*    R1      - WORK REG (CONTENTS DESTROYED)
         SPACE 1
S$CCWD   LR    R1,R15                   COPY LENGTH FROM PATTERN
         N     R1,=X'0000FFFF'          ONLY WANT LENGTH
         O     R14,G#BUFPT             DATA ADDRESS TO CCW
         A     R1,G#BUFPT              NEW DATA ADDRESS FOR NEXT TIME
         C     R1,G#BUFMX              OVER MAXIUM DATA ADDRESS?
         BHR   R10                      RETURN IF OUT OF SPACE
         ST    R1,G#BUFPT              SAVE NEW DATA PTR
         SPACE 1
S$CCW    CL    R2,G#CCWMX               ROOM FOR THIS CCW?
         BHR   R10                      BIF NO ROOM FOR CCW
         STM   R14,R15,8(R2)            SET CCW
         LA    R2,8(,R2)                TO NEXT CCW SPOT - 8
         BR    R10                      AND RETURN
         SPACE 2
*  S$DOIO -   R10 - RETURN ADDRESS; IOBSEEK CONTAINS CCHH
*    IF Â¬CE MODE SETS IOBSEEKM TO EXTENT CONTAINING CCHH IN IOBSEEK
*        (IF NO EXTENT CONTAINS CCHH USES ZERO)
*    IF CE MODE
*       SAVES CCHH (FOR FULL SEEK)
*       SETS IOBSEEK TO 1ST TRACK IN 1ST EXTENT
*       PREFIXES CHANNEL PROGRAM WITH FULL SEEK
*       ISSUES EXCP/WAIT
*       RESTORES IOBSEEK AND IOBCCWPT
*
         SPACE 1
S$DOIO   L     R1,DCBDEBAD-IHADCB+VOLUME GET @ DEB
         TM    S#GETFLG,S#FCE           CE MODE?
         BO    S$DOCE                   BIF CE MODE
         SR    R0,R0                    CLEAR FOR IC
         IC    R0,DEBNMEXT-DEBBASIC(,R1) GET NUMBER OF EXTENTS
         LR    R15,R0                   SAVE # OF EXTENTS
S$DOIOL  CLC   IOBSEEKB(6),DEBBINUM-DEBDASD+DEBBASND-DEBBASIC(R1)
         BL    S$DOION                  BIF BEFORE THIS EXTENT
         CLC   IOBSEEKC(4),DEBENDCC-DEBDASD+DEBBASND-DEBBASIC(R1)
         BNH   S$DOIOF                  BIF IN THIS EXTENT
S$DOION  LA    R1,DEBNMTRK+2-DEBDASD(,R1) TO NEXT EXTENT
         BCT   R0,S$DOIOL               TRY NEXT EXTENT
         LR    R0,R15                   ELSE USE EXTENT ZERO
S$DOIOF  SR    R15,R0                   GET EXTENT NUMBER
         STC   R15,IOBSEEKM             SET 'M' IN IOB
         EXCP  IOB                      START THE I/O
         WAIT  ECB=ECB                  WAIT FOR I/O TO FINISH
         CLI   ECB,X'7F'                SET CC TO I/O RESULT
         BR    R10                      AND RETURN
         SPACE 1
S$DOCE   MVC   G#CESEEK(8),IOBSEEK      SAVE CURRENT BBCCHH
         MVC   IOBSEEK+1(6),DEBBINUM-DEBDASD+DEBBASND-DEBBASIC(R1)
         MVI   IOBSEEKM,0               USE EXTENT ZERO
         L     R1,G#CCWIT               @ 1ST CCW - 8 (PFX CCW)
         LA    R14,G#CESEEK+1           @ BBCCHH FOR CE CYL
         ST    R14,0(,R1)               TO FULL SEEK CCW
         MVI   0(R1),X'07'              MAKE FULL SEEK
         MVC   4(4,R1),=X'40000006'      FINISH OFF SEEK
         ST    R1,IOBCCWPT              POINT TO CCW PREFIX
         EXCP  IOB
         WAIT  ECB=ECB                  WAIT FOR I/O TO FINISH
         MVC   IOBSEEK(8),G#CESEEK       RESTORE CALLERS SEEK ADDR
         L     R14,G#CCWIT                AND RESTORE
         LA    R14,8(,R14)                ORIG
         ST    R14,IOBCCWPT               CCW PTR
         CLI   ECB,X'7F'                SET CC TO I/O RESULT
         BR    R10                       AND RETURN
         SPACE 1
*  S$RETRY -  R10 - RETURN ADDRESS
*     CC HIGH IF OVER RETRY COUNT
S$RETRY  LA    R0,1                     ICR FOR RETRY
         AH    R0,G#TRY                 BUMP TRY COUNT
         STH   R0,G#TRY                 NEW TRY COUNT
         CH    R0,G#RETRY               OVER RETRY COUNT?
         BR    R10                      RETURN WITH CC SET
         SPACE 1
*  S$HEXCVT -  R10  - RETURN ADDRESS
*              R1   - @ OF STUFF TO CONVERT TO HEX (G#WORK)
S$HEXCVT UNPK  G#WORK(9),0(5,R1)        1ST WORD
         UNPK  G#WORK+8(9),4(5,R1)      2ND WORD
         TR    G#WORK(16),G#HEX         TO REAL HEX
         BR    R10                      AND RETURN
         SPACE 1
*  S$OPEN  -  R3  - @ OPEN LIST
*             R10 - RETURN ADDRESS
*
S$OPEN   LA    R2,99                    ABEND CODE FOR OPEN FAILED
         OPEN  MF=(E,(R3))              OPEN THE FILES
S$OPENL  L     R1,0(,R3)                GET A DCB ADDRES
         TM    48(R1),X'10'             DID THIS ONE OPEN?
         BZ    ABEND                    BIF OPEN FAILED
         LA    R3,4(,R3)                TO @ NEXT DCB ADDRESS
         LTR   R1,R1                    ANY MORE DCBS?
         BP    S$OPENL                  BIF MORE DCBS TO CHECK
         BR    R10                      RETURN, ALL OK
         SPACE 1
*  S$KEY0 / S$KEYNZ  - R10 - RETURN ADDRESS
*      REQUIRES PROGRAM BE RUNNING AUTHORIZED...
         SPACE 1
S$KEY0   MODESET KEY=ZERO               SET KEY ZERO
         BR    R10                      AND RETURN
         SPACE 1
S$KEYNZ  MODESET KEY=NZERO              BACK TO PROBLEM KEY
         BR    R10                      AND RETURN
         SPACE 1
*  ABEND - R2 = ABEND CODE
ABEND    CLOSE MF=(E,CLSPRT)            CLOSE SYSPRINT
         O     R2,=X'80000000'          SET DUMP FLAG
         LR    R1,R2                    SET ABEND CODE
         ABEND (1)                      AND ABEND WITH DUMP
         SPACE 1
G#CORE   DC    A(1)                     @ WORK AREA
G#COREL  DC    A(0)                     LENGTH OF AREA (TOTAL)
G#STACK  DC    A(0)                     @ STACK; END OF WORK
         SPACE 1
G#CCWIT  DC    A(0)                     @ CCW AREA - 8
G#CCWPT  DC    A(0)                     @ NEXT CCW - 8
G#CCWMX  DC    A(0)                     @ LAST CCW - 8
G#BUFIT  DC    A(0)                     @ BUFFER AREA
G#BUFPT  DC    A(0)                     @ NEXT AREA IN BUFFER
G#BUFMX  DC    A(0)                     @ LAST BYTE IN BUFFER
G#TRKIT  DC    A(0)                     @ TRACK AREA
G#TRKBS  DC    A(0)                     @ R0 ENTRY
G#TRKMX  DC    A(0)                     @ LAST BYTE IN TRACK AREA
G#RANGE  DC    F'0'                     END CCHH OF RANGE
         SPACE 1
OPNLST   OPEN  (SYSPRINT,(OUTPUT),SYSIN,(INPUT),                       +
               SAVE,(UPDAT)),MF=L
OPNVOL   OPEN  (VOLUME,(UPDAT)),MF=L
         SPACE 1
CLSPRT   OPEN  (SYSPRINT),MF=L
         SPACE 1
G#WORK   DC    10D'0'                   GLOBAL WORK AREA
DWD      DC    D'0'
S#GETSAV DC    A(1)                     S$GET SAVE WORD FOR R10
S#GETFLG DC    X'00'
S#FEOF   EQU   X'80'           (S$GET)  EOF HAS OCCURED
S#FECHO  EQU   X'40'           (S$GET)  ECHO INPUT TO SYSPRINT
S#FTSO   EQU   X'20'                    RUNNING ON TSO
S#FATTN  EQU   X'10'                    ATTENTION OCCURED (TSO ONLY)
S#FEXTS  EQU   X'02'                    FILE MSK/UCB ADR/1ST EXT SAVED
S#FCE    EQU   X'01'                    CE MODE
S#SCNPTR DC    A(1,1,0)   R15, R0, R1   SCAN POINTERS
         SPACE 1
G#DTUCB  DC    F'0'                     UCB DEVICE TYPE
G#DTSYS  DC    4F'0'                    DEVICE CHARACTERISTICS TABLE
G#DTSCYL EQU   G#DTSYS+00,2,C'H'        CYLINDERS / PACK
G#DTSTRK EQU   G#DTSYS+02,2,C'H'        TRACKS / CYLINDER
G#DTSTLN EQU   G#DTSYS+04,2,C'H'        MAXIUM TRACK LENGTH
G#DTSBO  EQU   G#DTSYS+06,1,C'X'        BLOCK OVERHEAD (NOT LAST)
G#DTSBOL EQU   G#DTSYS+07,1,C'X'        BLOCK OVERHEAD (LAST)
G#DTSBOH EQU   G#DTSYS+06,2,C'H'        HALFWORD BLOCK OVERHEAD
G#DTSBNK EQU   G#DTSYS+08,1,C'X'        KEY GAP SIZE (- IF NOT KEYED)
G#DTSFLG EQU   G#DTSYS+09,1,C'X'        FLAGS --
G#DTSFHO EQU   X'08'                     HALFWORD BLOCK OVERHEAD FMT
G#DTSFDC EQU   X'02'                     ON FOR 2321
G#DTSFTL EQU   X'01'                     TOLERANCE FACTOR REQUIRED
G#DTSTOL EQU   G#DTSYS+10,2,C'H'        TOLERANCE FOR ALL BUT LAST BLK
G#DTSRRO EQU   G#DTSYS+12,2,C'H'        R0 OVERHEAD FOR SECTOR CALC
G#DTSRSC EQU   G#DTSYS+14,1,C'X'        NUMBER OF SECTORS FOR DEVICE
G#DTSRDS EQU   G#DTSYS+15,1,C'X'        NUMBER OF DATA SECTORS
         SPACE 1
G#DTMY   DC    32X'00'                  MY DEVICE INFO
G#DTMALT EQU   G#DTMY+26,2,C'H'         1ST ALTERNATE TRACK CYLINDER
*                                       (ZERO IF NONE)
G#DTMCES EQU   G#DTMY+28,2,C'H'         START CE CYLINDER (0 IF NONE)
G#DTMCEE EQU   G#DTMY+30,2,C'H'         END CE CYLINDER   (0 IF NONE)
G#MAXBLK DC    F'0'                     MAX BLOCK SIZE ON TRACK
         SPACE 1
G#SDVMOD DC    X'00'                    ORIG FILE MASK
G#SUCBAD DC    Y(0)                     ORIG UCB ADDR OF 1ST EXTENT
G#SEXT1  DC    XL10'00'                 ORIG CCHHCCHHTT OF 1ST EXTENT
G#CESEEK DC    XL8'00'                  SAVE IOBSEEK FOR CE MODE
         SPACE 1
G#TRY    DC    H'0'                     TRY COUNT
G#RETRY  DC    H'10'                    MAXIUM RETRY COUNT
         SPACE 1
*  X'80' - ALLOW WRITES
*  X'40' - ALLOW AUTHORIZED COMMANDS
G#ALLOW  DC    X'00'                    ALLOWED COMMAND FLAGS
         SPACE 1
         CNOP  4,8
         DC    CL8'ECB/IOB'
ECB      DC    F'0'
IOB      DC    X'C200'                  DATA, CMD CHAIN, UNRELAGED
IOBSEN0  DC    X'00'                    SENSE BYTE 0
IOBSEN1  DC    X'00'                    SENSE BYTE 1
         DC    A(ECB)
IOBCSW   DC    XL8'00'
IOBCCWPT DC    A(1)                     @ CHANNEL PROGRAM
         DC    A(VOLUME,0,0)
IOBSEEK  DC    XL8'0000000000000000'    SEEK ADDRESS
IOBSEEKM EQU   IOBSEEK+0,1,C'X'         EXTENT INDEX
IOBSEEKB EQU   IOBSEEK+1,2,C'X'         BIN NUMBER
IOBSEEKC EQU   IOBSEEK+3,2,C'X'         CYLINDER NUMBER
IOBSEEKH EQU   IOBSEEK+5,2,C'X'         HEAD NUMBER
IOBSEEKR EQU   IOBSEEK+7,1,C'X'         RECORD NUMBER
         DC    C'IOBSEEK'
PHYCCHH  DC    F'0'                     PHYSICAL TRACK ADDRESS
LOGCCHH  DC    F'0'                     LOGICAL TRACK ADDRESS
         SPACE 1
S#GETBUF DC    CL80' '                  INPUT CONTROL RECORD
LINE     DC    CL133' '                 PRINT LINE
         SPACE 1
VOLEXT   DC    0F'0',X'87',AL3(V#JFCB)
PRTEXT   DC    0F'0',X'85',AL3(PRTEXIT)
         SPACE 1
PRTEXIT  OC    62(2,R1),62(R1)          ANY BLKSIZE SO FAR?
         BNZR  R14                      RETURN IF HAVE BLKSIZE
         MVC   62(2,R1),=AL2(4123)      SET FOR 3330
         BR    R14                      AND RETURN
         SPACE 1
         DC    C'0123456789ABCDEF'      INTERNAL TO HEX TRANSLATE
G#HEX    EQU   *-256
         SPACE 1
         LTORG ,
         SPACE 1
         PRINT NOGEN
VOLUME   DCB   DDNAME=VOLUME,DSORG=PS,MACRF=(E),EXLST=VOLEXT
         SPACE 1
SAVE     DCB   DDNAME=SAVE,DSORG=PS,MACRF=(E)
         SPACE 1
SYSPRINT DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA,  +
               EXLST=PRTEXT
         SPACE 1
SYSIN    DCB   DDNAME=SYSIN,DSORG=PS,MACRF=GM,LRECL=80,RECFM=FB,       +
               EODAD=S$GETEOF
         PRINT GEN
         SPACE 1
         EJECT ,
*  COMMAND TABLE
*    CL8'CMD',XL2'FLAGS',Y(ROUTINE OFFSET)
*       8000 - OPEN FILE IF NOT OPEN YET.
*       0080 - WRITE MUST BE ALLOWED
*       0040 - AUTHORIZATION MUST BE ALLOWED
*       0020 - HAR0 MUST BE ALLOWED
*
         SPACE 1
CMDTAB   DC    CL8'END     ',XL2'0000',Y(C$END-$,H#END-$)
CMDTABL  EQU   *-CMDTAB
         DC    CL8'HELP    ',XL2'0000',Y(C$HELP-$,H#HELP-$)
         DC    CL8'ECHO    ',XL2'0000',Y(C$ECHO-$,H#ECHO-$)
         DC    CL8'IMSK    ',XL2'8000',Y(C$IMSK-$,H#IMSK-$)
         DC    CL8'DEVTYPE ',XL2'8000',Y(DEVTYPE-$,H#DEVT-$)
         DC    CL8'CHECK   ',XL2'8000',Y(C$CHECK-$,H#CHECK-$)
         DC    CL8'READ    ',XL2'8000',Y(READ-$,H#READ-$)
         DC    CL8'PRTSD   ',XL2'8000',Y(C$PRTSD-$,H#PRTSD-$)
         DC    CL8'PRTSDA  ',XL2'8000',Y(C$PRTSDA-$,H#PRTSDA-$)
         DC    CL8'DISPTRK ',XL2'0000',Y(DISPTRK-$,H#DISPT-$)
         DC    CL8'REWRITE ',XL2'8080',Y(REWRITE-$,H#RW-$)
         DC    CL8'ALLOW   ',XL2'0000',Y(ALLOW-$,H#ALLOW-$)
         DC    CL8'VOLUME  ',XL2'0040',Y(C$VOL-$,H#VOL-$)
         DC    CL8'UNIT    ',XL2'0040',Y(C$UNIT-$,H#UNIT-$)
         DC    CL8'WRITE   ',XL2'8080',Y(C$WRITE-$,H#WRITE-$)
         DC    CL8'SCAN    ',XL2'8000',Y(C$SCAN-$,H#SCAN-$)
         DC    CL8'CE      ',XL2'8040',Y(C$CE1-$,H#CE1-$)
         DC    CL8'RESET   ',XL2'8000',Y(C$RESET-$,H#RESET-$)
         DC    CL8'WRTSD   ',XL2'80E0',Y(C$WRTSD-$,H#WRTSD-$)
         DC    CL8'WRTCK   ',XL2'8080',Y(C$WRTCK-$,H#WRTCK-$)
CMDTABE  EQU   *-CMDTABL
 TITLE 'SALAVGE - COMMANDS - DASD RECOVER / ANALYZE / REPLACE'
C$END    OI    S#GETFLG,S#FEOF          FAKE AN EOF HERE
         B     RETZ                     AND ALL DONE
         SPACE 1
C$ECHO   XI    S#GETFLG,S#FECHO         FLIP ECHO FLAG
         B     RETZ                     AND RETURN
         SPACE 1
         USING C$IMSK,R11
C$IMSK   XI    DCBIFLGS-IHADCB+VOLUME,DCBIFNE3 FLIP USE ERROR RECOVERY
         SPACE 1
M$IMSK   BALR  R11,0                    GET NEW BASE
         USING *,R11
         MVC   LINE+1(25),=C'IBM ERROR RECOVERY NOW ON'
         TM    DCBIFLGS-IHADCB+VOLUME,DCBIFNE3 ERROR RECOVERY ON?
         BZ    *+10                     BIF RECOVERY IS ON
         MVC   LINE+1+25-2(3),=C'OFF'
         BAL   R10,S$PRINT
         B     RETZ                     AND RETURN
         SPACE 1
         USING C$CHECK,R11
C$CHECK  RCALL RANGEI                   INIT RANGE FOR CHECK
         BNZ   RET                      BIF INVALID OR MISSING OPERAND
C$CHREAD RCALL READ                     GO READ TRACK
         BNZ   RET                      RETURN IF ANY ERROR
         RCALL RANGEN                   DONE?, TO NEXT TRACK
         BZ    C$CHREAD                 BIF NOT DONE, CONTINUE
         B     RET                      RETURN IF DONE
         DROP  R11
         SPACE 1
         USING C$PRTSDA,R11
C$PRTSDA MVI   C#PRTSDF,1              FLAG PRINT ALL SD'S
         B     C$PRTSD1
         USING C$PRTSD,R11
C$PRTSD  MVI   C#PRTSDF,0              FLAG ONLY NON-ZERO SD'S
C$PRTSD1 BALR  R11,0
         USING *,R11
         RCALL RANGEI                  INIT RANGE
         BNZ   RET
C$PRTSD2 RCALL RDSD                    READ SD
         BNZ   RET
         CLI   C#PRTSDF,0              PRINT IT?
         BNE   C$PRTSD3
         L     R3,IOBCCWPT             @ 1ST CCW
         L     R1,8+8(,R3)             @ FROM SENSE CCW
         OC    24-6(6,R1),24-6(R1)     SD ALL ZERO?
         BZ    C$PRTSD4                BIF ALL ZERO, DON'T PRINT
C$PRTSD3 RCALL PRTSD                   PRINT SD
C$PRTSD4 RCALL RANGEN                  TO NEXT TRACK IN RANGE
         BZ    C$PRTSD2                BIF STILL IN RANGE
         B     RETZ                     ELSE RETURN
C#PRTSDF DC    X'00'
         DROP  R11
         SPACE 1
         USING PRTSD,R11
PRTSD    L     R2,IOBCCWPT              @ CCWS
         MVC   LINE+1(5),=C'CCHH:'
         LA    R1,IOBSEEKC
         BAL   R10,S$HEXCVT
         MVC   LINE+7(8),G#WORK
         MVC   LINE+16(3),=C'HA:'
         L     R1,8(,R2)                @ FROM READ HA CCW
         BAL   R10,S$HEXCVT
         MVC   LINE+20(2),G#WORK        FLAG BYTE FROM HA
         MVC   LINE+23(8),G#WORK+2        CCHH FROM HA
         MVC   LINE+32(3),=C'SD:'
         L     R1,8+8(,R2)             @ FROM SENSE CCW
         LA    R1,24-6(,R1)            @ SD BYTES
         BAL   R10,S$HEXCVT
         MVC   LINE+36(4),G#WORK       2 SD BYTES
         MVC   LINE+41(4),G#WORK+4     2 MORE SD BYTES
         MVC   LINE+46(4),G#WORK+4+4   LAST 2 SD BYTES (FIRST ASSIGNED)
         BAL   R10,S$PRINT
         B     RETZ                     AND RETURN
         DROP  R11
         SPACE 1
         USING RDSD,R11
RDSD     MVC   IOBSEEKC(4),LOGCCHH      SET CCHH FOR TRACK
         TM    S#GETFLG,S#FATTN         ATTENTION?
         BO    RETM                     RIF ATTENTION, STOP NOW
         BAL   R10,S$CCWI               INIT CCW BUILDER
         LM    R14,R15,SD#CCWSS         SET SECTOR
         BAL   R10,S$CCWD
         MVI   0(R14),0                 MAKE SECTOR 0
         LM    R14,R15,SD#CCWHA         READ HA
         BAL   R10,S$CCWD
         LM    R14,R15,SD#CCWSN         SENSE (24 BYTES)
         BAL   R10,S$CCWD
         BAL   R10,S$DOIO               EXECUTE I/O
         BZ    RETZ                     RIF ALL OK
         RCALL IOERR                    PRINT ERROR STATUS
         B     RETM                      RETURN
         DROP  R11
SD#CCWSS CCW   X'23',0,X'40',1          SET SECTOR 0
SD#CCWHA CCW   X'1A',0,X'40',5          READ HA, CHAIN
SD#CCWSN CCW   X'04',0,X'00',24         SENSE (TO GET SKIP DISP)
         SPACE 1
         USING RANGEI,R11
** RANGEI - INIT LOGCCHH/G#RANGE CCHH CCHH FOR COMMANDS
**   RETURNS:   M - INVALID OR MISSING OPERAND    (MSG ISSUED)
**              Z - ALL SET
RANGEI   BAL   R10,S$HEX                GET TRACK ADDR TO CHECK
         BNP   RANGEI1                  RIF INVALID OR MISSING OPERAND
         ST    R1,LOGCCHH               SET LOGICAL CCHH
         ST    R1,G#RANGE                SAVE END OF RANGE
         BAL   R10,S$HEX                GET END ADDRESS
         BM    RETZ                     RIF NO SECOND OPERAND
         BZ    RANGEI1                  BIF INVALID STRING
         ST    R1,G#RANGE               SAVE END OF RANGE
         B     RETZ
RANGEI1  MVC   LINE+1(26),=C'INVALID OR MISSING OPERAND'
         BAL   R10,S$PRINT
         B     RETM
         DROP  R11
         SPACE 1
         USING RANGEN,R11
** RANGEN - TEST LOGCCHH IF RANGE EXCEEDED, BUMP TO NEXT TRACK
**   RETURN - Z - STILL IN EXTENT
**            M - NO MORE TRACKS
RANGEN   CLC   LOGCCHH,G#RANGE          DONE?
         BNL   RETM                     RETURN IF DONE
         LH    R1,LOGCCHH+2             GET HH
         LA    R1,1(,R1)                TO NEXT HEAD ADDR
         CH    R1,G#DTSTRK              COMPARE WITH TRKS/CYL
         BL    RANGEN1
         LH    R2,LOGCCHH
         LA    R2,1(,R2)                TO NEXT CYLINDER
         STH   R2,LOGCCHH               SET NEW CC
         SR    R1,R1                    NEW HH IS ZERO
RANGEN1  STH   R1,LOGCCHH+2             SET NEW HH
         B     RETZ                      AND RETURN ZERO
         DROP  R11
 TITLE 'SALVAGE - REWRITE COMMAND'
         USING REWRITE,R11
REWRITE  BAL   R10,S$CCWI               INIT CCW BUILDER
         L     R7,G#TRKBS               @ ENTRY FOR RECORD 0
         USING T#ENTRY,R7
         LA    R7,T#BASE                @ RECORD 1 ENTRY
         TM    T#RSFLG,T#RFCNT          HAVE COUNT FIELD?
         BZ    RW$ETRK                  BIF EMPTY TRACK
         LM    R14,R15,RW#SRCH          SEARCH ID EQ CCW PATTERN
         BAL   R10,S$CCWD               ADD CCW / RESERVE SPACE
         MVC   0(4,R14),LOGCCHH         INIT CCHH FOR SEARCH
         MVI   4(R14),0                 SEARCH FOR RECORD 0
         LR    R14,R2                   COPY @ LAST CCW
         O     R14,=X'08000000'         MAKE TIC *-8
         BAL   R10,S$CCW                BUILD TIC CCW
         SPACE 1
RW$LOOP  TM    T#RSFLG,T#RFCNT+T#RFKEY+T#RFDATA ANY RECORD HERE?
         BZ    RW$EOT
         LA    R14,T#RCNT               POINT TO COUNT FIELD
         O     R14,=X'1D000000'         MAKE WRITE COUNT KEY DATA
         L     R15,=X'80000008'         DATA CHAIN/COUNT LENGTH
         BAL   R10,S$CCW                BUILD WRITE CKD
         SR    R0,R0                    CLEAR FOR IC
         IC    R0,T#RCNT+5              GET KEY LENGTH
         L     R15,T#RCNT+4             AND DATA LENGTH
         N     R15,=X'0000FFFF'
         AR    R15,R0                   TOTAL KEY/DATA WRITE LENGTH
         BZ    RW$EOF                   BIF NO KEY OR DATA FIELDS
         O     R15,=X'40000000'         ADD COMMAND CHAIN FLAG
         LH    R14,T#ROFF               GET OFFSET OF KEY/DATA FIELDS
         A     R14,G#TRKIT              @ KEY / DATA FIELDS
         O     R14,=X'1D000000'         ADD CCW OP CODE
         BAL   R10,S$CCW                BUILD 2ND WRITE FOR RECORD
RW$NEXT  LA    R7,T#BASE                POINT TO NEXT RECORD ENTRY
         B     RW$LOOP                  AND CONTINUE
RW$EOF   XI    4(R2),X'C0'              CHAIN DATA OFF/CMD ON
         B     RW$NEXT
RW$EOT   MVI   4(R2),0                  OFF LAST CHAIN FLAG
         BAL   R10,S$DOIO               RE-WRITE THE TRACK
         BE    RETZ
         RCALL IOERR
         B     RETNZ
RW$ETRK  MVC   LINE+1(11),=C'EMPTY TRACK'
         BAL   R10,S$PRINT
         B     RETNZ
RW#SRCH  CCW   X'31',0,X'40',5          PATTERN SEARCH ID EQ
 TITLE 'SALVAGE - WRITE COMMAND'
         USING C$WRITE,R11
C$WRITE  BAL   R10,S$HEX                GET SEEK/SEARCH ID
         BNP   RETZ
         STM   R0,R1,IOBSEEK            SET BBCCHHR
         BAL   R10,S$CCWI               INIT CCW STUFF
         LM    R14,R15,C#WSRCID         SEARCH ID EQ
         BAL   R10,S$CCW                SET SEARCH ID CCW
         LR    R14,R2                   @ LAST CCW
         O     R14,=X'08000000'         MAKE TIC *-8
         BAL   R10,S$CCW                SET TIC *-8
         LM    R14,R15,C#WRTCKD         PATTERN WRITE COUNT KEY DATA
         BAL   R10,S$CCWD               SET AND GET COUNT AREA
         LR    R6,R14                   SAVE DATA ADDRESS
         BAL   R10,S$HEX                GET COUNT FIELD TO WRITE
         BNP   RETZ
         STM   R0,R1,G#WORK             SET TO CCW AREA
         MVC   0(8,R6),G#WORK
         BAL   R10,S$DOIO               GO START IT
         RCALL IOERR                    DO THIS TOO
         B     RETZ                     AND RETURN
         DROP  R11
         SPACE 1
C#WSRCID CCW   X'31',IOBSEEKC,X'40',5   SEARCH ID EQ
C#WRTCKD CCW   X'1D',0,0,8              PATTERN WRITE CKD
 TITLE 'SALVAGE - WRTCK COMMAND'
* WRTCK <CCHH> <OPT # RETRYES>
         USING C$WRTCK,R11
C$WRTCK  BAL   R10,S$HEX          GET CCHH
         BNP   WCK$INV            RIF INVALID
         LTR   R0,R0
         BNZ   WCK$INV
         ST    R1,LOGCCHH         SAVE LOGICAL CCHH
         LA    R9,10              ASSUME 10 TRIES
         BAL   R10,S$HEX          RETRY COUNT
         BNP   *+6                BIF NOT SPECIFIED
         LR    R9,R1               ELSE USE IT
         SPACE 1
*** WRITE TRACK WITH PATTERN
* R9  - # OF WRITE/READ TRIES TO MAKE
* R8  - PATTERN TABLE POINTER
WCK$RTR1 LA    R8,WCK#PAT         PATTERN TABLE
WCK$RTR2 L     R5,0(,R8)          TRY THIS PATTERN
         LA    R6,X'1D'           WRITE CKD
         RCALL WCK$BLD            WRITE THE TRACK
         BNZ   RETM               RIF ERROR ON WRITE
         L     R1,C#WCKPTR        @ WRITE CKD CCW FOR DATA FIELD
         LM    R0,R1,0(R1)        GET ADDRESS / LENGTH
         L     R14,G#TRKIT        @ TRACK IMAGE AREA
         LR    R15,R1
         MVCL  R14,R0             SAVE WRITTEN DATA
         L     R5,=X'FFFFFFFF'    REFILL BUFFER BEFORE READ
         LA    R6,X'1E'           READ CKD
         RCALL WCK$BLD            READ R1 FROM TRACK
*** CHECK PATTERN READ
         L     R1,C#WCKPTR        @ READ CKD CCW FOR DATA FIELD
         LA    R7,LINE+27         @ FOR OFFSET IN LINE
         LM    R2,R3,0(R1)        GET ADDRESS / LENGTH
         L     R4,G#TRKIT         @ TRACK IMAGE AREA
         LR    R5,R3               COPY LENGTH
         LR    R6,R3              SAVE ORIG COMPARE LENGTH
WCK$CLC  CLCL  R2,R4              SAME AS WRITTEN DATA?
         BE    WCK$EQ             BIF SAME DATA
         LR    R14,R6             ORIG COMPARE LENGTH
         SR    R14,R3             - LENGTH REMAINING = OFFSET OF ERROR
         ST    R14,DWD            SAVE OFFSET
         LA    R1,DWD
         BAL   R10,S$HEXCVT
         MVC   0(4,R7),G#WORK+4   OFFSET TO LINE
         LA    R7,5(,R7)          BUMP LINE PTR
         LR    R1,R8              @ PATTERN
         BAL   R10,S$HEXCVT
         MVC   LINE+1(8),=C'PATTERN:'
         MVC   LINE+9(8),G#WORK
         MVC   LINE+19(7),=C'OFFSET:'
         LA    R0,LINE+L'LINE-8
         CR    R7,R0
         BNH   WCK$NEQ
         BAL   R10,S$PRINT
         LA    R7,LINE+27
WCK$NEQ  LA    R0,1
         AR    R2,R0              SKIP OVER NON-COMPARING BYTE
         SR    R3,R0
         AR    R4,R0
         SR    R5,R0
         BP    WCK$CLC
WCK$EQ   LA    R0,LINE+27
         CR    R7,R0              LINE EMPTY?
         BE    *+8
         BAL   R10,S$PRINT
         TM    S#GETFLG,S#FATTN   ATTENTION?
         BO    RETM               RIF ATTENTION
         LA    R8,4(,R8)          BUMP PATTERN PTR
         CL    R8,=A(WCK#PATE)
         BNH   *+8
         LA    R8,WCK#PAT
         BCT   R9,WCK$RTR2
         B     RETZ
         SPACE 1
WCK$INV  MVC   LINE+1(15),=C'INVALID OPERAND'
         BAL   R10,S$PRINT
         B     RETM
         SPACE 1
WCK#PAT  DC    0F'0'
         DC    X'00000000'
         DC    X'FFFFFFFF'
         DC    X'AAAAAAAA'
         DC    X'55555555'
         DC    X'DB6DB6DB'
         DC    X'B6DB6DB6'
         DC    X'6DB6DB6D'
         DC    X'DB6DB6DB'
         DC    X'B6DB6DB6'
         DC    X'6DB6DB6D'
         DC    X'DB6DB6DB'
         DC    X'B6DB6DB6'
         DC    X'6DB6DB6D'
WCK#PATE EQU   *-4                @ OF LAST PATTERN
         SPACE 1
*  BUILD CCW'S FOR READ/WRITE OF MAX LENGTH BLOCK
*    R6 = CCW OP CODE (WRITE/READ CKD) = X'1D'/X'1E'
*    R5 = BUFFER FILL PATTERN
         USING WCK$BLD,R11
WCK$BLD  BAL   R10,S$CCWI         INIT CCW BUILDER
         LM    R14,R15,C#WCKSCH   PATTERN SEARCH ID EQ
         BAL   R10,S$CCWD         SEARCH ID EQ
         MVC   0(4,R14),LOGCCHH   SEARCH TARGET
         MVI   4(R14),0            IS RECORD 0
         LR    R14,R2
         O     R14,=X'08000000'   TIC *-8
         BAL   R10,S$CCW
         LR    R14,R6             COPY CCW OP-CODE (WRITE/READ CKD)
         SLL   R14,24
         L     R15,=X'80000008'   COUNT FIELD PART OF CCW, DATA CHAIN
         BAL   R10,S$CCWD         BUILD WRITE/READ CKD CCW
         MVC   0(4,R14),LOGCCHH   SET CCHH (FOR POSSIBLE WRITE)
         MVI   4(R14),1            IS RECORD 1
         MVI   5(R14),0            KEY LENGTH 0
         MVC   6(2,R14),G#MAXBLK+2 AND DATA LENGTH
         LR    R14,R6             COPY CCW OP-CODE (WRITE/READ CKD)
         SLL   R14,24
         L     R15,G#MAXBLK       MAX TRACK BLOCKSIZE
         BAL   R10,S$CCWD         BUILD WRITE/READ CKD CCW
         ST    R2,C#WCKPTR        SAVE @ CCW FOR CHECK
         ST    R5,G#WORK
WCK$BLD1 MVC   0(4,R14),G#WORK
         LA    R14,4(,R14)
         SH    R15,=H'4'
         BNM   WCK$BLD1
         MVC   IOBSEEKC(4),LOGCCHH INIT SEEK CCHH
         BAL   R10,S$DOIO         WRITE OR READ
         BE    RETZ
         RCALL IOERR
         B     RETNZ
         DROP  R11
C#WCKSCH CCW   X'31',0,X'40',5    SEARCH ID EQ
C#WCKPTR DC    A(1)               @ OF READ/WRITE DATA AREA CCW
 TITLE 'SALVAGE - WRTSD COMMAND'
* WRTSD <SD> <SD> <SD> <F> <CCHH>  <OPT R0 CCHH>
*  FILE ALREADY OPEN; FILE MASK ALLOWS WRITE HA/R0
*   (SHOULD READ BACK HA/R0?)
         USING C$WRTSD,R11
C$WRTSD  CLC   G#DTUCB+2(2),=X'200B' 3350?
         BNE   WSD$INV            BIF NOT 3350
         LA    R7,3               WANT 3 SD'S
         LA    R6,C#WSDWRK        OUTPUT @ FOR SD'S
WSD$SDL  BAL   R10,S$HEX          CONVERT 1 SD
         BNP   WSD$INV
         STM   R0,R1,G#WORK
         OC    G#WORK(6),G#WORK   ONLY 2 BYTES MAX OF SD
         BNZ   WSD$INV
         STH   R1,0(,R6)
         LA    R6,2(,R6)
         BCT   R7,WSD$SDL
         BAL   R10,S$HEX          CONVERT FLAG BYTE
         BNP   WSD$INV
         STM   R0,R1,G#WORK
         OC    G#WORK(7),G#WORK   ONLY ONE BYTE
         BNZ   WSD$INV
         STC   R1,C#WSDWRK+6      SAVE FLAG BYTE
         BAL   R10,S$HEX          CONVERT CCHH
         BNP   WSD$INV
         LTR   R0,R0              ALLOW 4 BYTES
         BNZ   WSD$INV
         ST    R1,LOGCCHH         SET LOGICAL CCHH
         MVC   C#WSDWRK+7(4),LOGCCHH COPY TO HA WORK AREA
         MVC   C#WSDR0(4),LOGCCHH  DEFAULT R0 TO SAME CCHH
         BAL   R10,S$HEX          OPT R0 CCHH
         BM    WSD$XR0
         BZ    WSD$INV
         LTR   R0,R0              ALLOW 4 BYTES
         BNZ   WSD$INV
         ST    R1,C#WSDR0         SET R0 CCHH
         SPACE 1
WSD$XR0  RCALL RDSD               READ CURRENT SD
         BNZ   RETM               RIF I/O ERROR
         RCALL PRTSD               AND PRINT THEM
         SPACE 1
         BAL   R10,S$CCWI         INIT CCW BUILDER
         LM    R14,R15,C#WSDSHA   @ SEARCH HA EQ CCW
         BAL   R10,S$CCWD         BUILD SEARCH HA EQ
         MVC   0(4,R14),C#WSDWRK+7 FILL IN TARGET CCHH
         LR    R14,R2             MAKE TIC *-8
         O     R14,=X'08000000'
         BAL   R10,S$CCW
         LM    R14,R15,C#WSDWHA   PATTERN WRITE HA
         BAL   R10,S$CCWD         BUILD WRITE HA
         MVC   0(11,R14),C#WSDWRK  DATA FOR WRITE HA
         LM    R14,R15,C#WSDWR0   PATTERN WRITE R0
         BAL   R10,S$CCWD
         XC    0(16,R14),0(R14)   INIT R0 TO ALL ZERO CCHHRKDD XXXXXXXX
         MVC   0(4,R14),C#WSDR0    FILL IN CCHH IN R0
         MVI   7(R14),X'08'        AND R0 DATA LENGTH
         MVC   IOBSEEKC(4),LOGCCHH SET CCHH FOR SEEK
         BAL   R10,S$DOIO         WRITE HA/R0
         RCALL IOERR
         B     RETZ
         SPACE 1
WSD$INV  MVC   LINE+1(35),=C'INVALID DEVICE TYPE, SD, F, OR CCHH'
         BAL   R10,S$PRINT
         B     RETM
         DROP  R11
         SPACE 1
C#WSDSHA CCW   X'39',0,X'40',4    SEARCH HA EQ
C#WSDWHA CCW   X'19',0,X'40',11   WRITE HA
C#WSDWR0 CCW   X'15',0,X'00',16   WRITE R0 (STD R0)
C#WSDR0  DC    F'0'               CCHH FOR R0 (DEFAULTS TO SAME AS HA)
C#WSDWRK DC    XL11'00'           SD,SD,SD,F,CCHH
 TITLE 'SALVAGE - RESET COMMAND'
*  RESET -- RESTORE DEB FILE MASK, UCB ADDRESS, AND FIRST EXTENT
*   NOTE: THIS IS BOTH A COMMAND ROUTINE AND A SUBROUTINE
         USING C$RESET,R11
C$RESET  NI    S#GETFLG,X'FF'-S#FCE     CLEAR CE MODE IF ON
         TM    G#ALLOW,X'40'            ALLOW AUTH?
         BZ    RETZ                     JUST RETURN IF NOT AUTH
         TM    S#GETFLG,S#FEXTS   FILE MSK/UCB ADR/1ST EXTENT SAVED?
         BZ    RETZ               RIF NOTHING TO RESTORE
         NI    S#GETFLG,X'FF'-S#FEXTS CLEAR SAVED INFO FLAG
         L     R4,DCBDEBAD-IHADCB+VOLUME @ DEB
         BAL   R10,S$KEY0               SET KEY ZERO
* RESTORE FILE MASK
         MVC   DEBDVMOD-DEBDASD+DEBBASND-DEBBASIC(1,R4),G#SDVMOD
* RESTORE ORGINAL UCB ADDRESS
         MVC   DEBUCBAD-DEBDASD+DEBBASND-DEBBASIC+2(2,R4),G#SUCBAD
* RESTORE FIRST EXTENT
         MVC   DEBSTRCC-DEBDASD+DEBBASND-DEBBASIC(10,R4),G#SEXT1
         BAL   R10,S$KEYNZ
         B     RETZ
         DROP R11                       (C$RESET)
         SPACE 1
* EXTSAVE - SAVE ORIG FILE MASK, UCB ADDRESS, FIRST EXTENT
         USING EXTSAVE,R11
EXTSAVE  TM    S#GETFLG,S#FEXTS   FILE MSK/UCB ADR/1ST EXTENT SAVED?
         BO    RETZ               RIF ALREADY SAVED
         L     R4,DCBDEBAD-IHADCB+VOLUME @ DEB
         MVC   G#SDVMOD(1),DEBDVMOD-DEBDASD+DEBBASND-DEBBASIC(R4)
         MVC   G#SUCBAD(2),DEBUCBAD-DEBDASD+DEBBASND-DEBBASIC+2(R4)
         MVC   G#SEXT1(10),DEBSTRCC-DEBDASD+DEBBASND-DEBBASIC(R4)
         OI    S#GETFLG,S#FEXTS   NOW HAVE SAVED INFO
         B     RETZ
         DROP R11
 TITLE 'SALVAGE - CE COMMANDS'
         USING C$CE1,R11
C$CE1    LH    R5,G#DTMCEE              CE END CYLINDER
         LTR   R5,R5                    ANY CE CYLINDERS?
         BZ    CE1$NONE                 BIF NO CE CYLINDERS EXIST
         SPACE 1
         L     R4,DCBDEBAD-IHADCB+VOLUME @ DEB
         BAL   R10,S$KEY0
* SET ONLY ALLOW CE CYLINDER SEEKS
         OI    DEBDVMOD-DEBDASD+DEBBASND-DEBBASIC(R4),X'04'
* ALLOW FULL SEEKS
         NI    DEBDVMOD-DEBDASD+DEBBASND-DEBBASIC(R4),X'FF'-X'18'
         BAL   R10,S$KEYNZ
         OI    S#GETFLG,S#FCE           SET NOW IS CE MODE
         B     RETZ
         SPACE 1
CE1$NONE MVC   LINE+1(L'CE1#MN),CE1#MN    NOT SUPPORTED
         BAL   R10,S$PRINT
         B     RETNZ                     AND RETURN ERROR
         DROP  R11                      C$CE1
CE1#MN   DC    C'CE CYLINDERS NOT SUPPORTED FOR THIS DEVICE'
 TITLE 'SALVAGE - HELP COMMAND'
         USING C$HELP,R11
C$HELP   BAL   R10,S$SCN                SCAN FOR OPERAND
         BNP   HL$LIST1                 BIF NO OPERAND
         BAL   R10,S$STR                GET OPERAND STRING
         BH    HL$LIST1                 BIF INVALID OPERAND
         BAL   R9,HL$SCAN               FIND COMMAND
         BH    HL$LIST1                 BIF OPERAND NOT FOUND
         CLC   DWD(8),0(R3)             THIS THE COMMAND?
         BNE   HL$NEXT
         SPACE 1
         LH    R4,12(,R3)               GET OFFSET OF HELP STRING
         AR    R4,R12                   @ HELP STRING
HL$HLOPL LR    R1,R4
         BAL   R10,S$MSG                PRINT HELP LINE
         SR    R1,R1
         IC    R1,0(,R4)
         LA    R4,1+1(R1,R4)            TO NEXT HELP LINE
         CLI   0(R4),X'FF'              END OF THE LINE?
         BNE   HL$HLOPL
         B     RETZ
         SPACE 1
HL$LIST1 LA    R4,HL#TAB                POINT TO TABLE
HL$LOOP1 LH    R1,2(,R4)                GET MSG OFFSET
         AR    R1,R12                   MAKE MSG ADDRESS
         BAL   R10,S$MSG                GO ISSUE IT
         BAL   R9,HL$SCAN               FIND COMMAND
HL$LOOP2 BH    HL$LIST2                 BIF NO MORE COMMANDS
         MVC   G#WORK(1),9(R3)          COPY CMD FLAGS
         NC    G#WORK(1),1(R4)          TEST ONLY THESE FLAGS
         CLC   G#WORK(1),0(R4)          THESE FLAGS MATCH?
         BNE   HL$NEXT                  SKIP IF MISMATCH
HL$SEL   BAL   R9,HL$PRT                PRINT COMMAND
         BAL   R9,HL$NEXT
         B     HL$LOOP2
         SPACE 1
HL$LIST2 BAL   R9,HL$FLUSH              FINISH UP LAST LINE
         LA    R4,4(,R4)                TO NEXT
         CLI   0(R4),X'FF'              END OF LIST?
         BNE   HL$LOOP1
         LA    R1,H#HELP
         BAL   R10,S$MSG
         B     RETZ                     AND RETURN
         SPACE 1
HL$SCAN  L     R3,=A(CMDTAB)
         LA    R6,LINE+1                INIT LINE PTR
         LA    R7,LINE+79-9             END OF LINE PTR
         SPACE 1
HL$NEXT  LA    R3,CMDTABL(,R3)          TO NEXT COMMAND
         CL    R3,=A(CMDTABE)           ALL COMMANDS DONE?
         BR    R9                       RETURN WITH CC SET
         SPACE 1
HL$PRT   CR    R6,R7                    LINE FULL
         BL    HL$PRTX
         BAL   R10,S$PRINT              PRINT SO FAR
         LA    R6,LINE+1
HL$PRTX  MVC   0(8,R6),0(R3)            COMMAND NAME TO LINE
         LA    R6,9(,R6)                BUMP OUTPUT PTR
         BR    R9                       AND RETURN
         SPACE 1
HL$FLUSH LA    R0,LINE+1                EMPTY LINE
         CR    R6,R0                    LINE EMPTY?
         BER   R9                       RETURN IF DONE
         BAL   R10,S$PRINT              ELSE PRINT LAST LINE
         BR    R9                       AND THEN RETURN
         DROP  R11                      (C$HELP)
         SPACE 1
HL#TAB   DC    0F'0'
         DC    XL2'00FF',Y(C#HLMSG1-$)
         DC    XL2'8080',Y(C#HLMSG2-$)
         DC    XL2'4040',Y(C#HLMSG3-$)
         DC    X'FF'                    END OF TABLE
         LTORG ,
         SPACE 1
C#HLMSG1 MSG   'SAFE COMMANDS --'
C#HLMSG2 MSG   '*** COMMANDS WHICH MAY DESTROY DATA ***'
C#HLMSG3 MSG   '*** COMMANDS REQUIRING AUTHORIZATION ***'
         SPACE 1
H#END    MSG   'END - EXIT SALVAGE'
         DC    X'FF'
H#HELP   MSG   'HELP - ENTER HELP <COMMAND> FOR MORE IMFORMATION'
         DC    X'FF'
H#ECHO   MSG   'ECHO - FLIP ECHO INPUT COMMANDS FLAG'
         DC    X'FF'
H#IMSK   MSG   'IMSK - FLIP USE IBM ERROR RECOVERY FLAG'
         DC    X'FF'
H#DEVT   MSG   'DEVTYPE - DEVICE TYPE / EXTENTS INFORMATION'
         DC    X'FF'
H#CHECK  MSG   'CHECK <START CCHH>  <END CCHH>'
         MSG   ' TRY READING TRACKS (END DEFAULTS TO START IF OMMITED)'
         DC    X'FF'
H#READ   MSG   'READ - READ TRACK LAST CHECKED (NO OPERAND)'
         DC    X'FF'
H#PRTSD  MSG   'PRTSD <START CCHH>  <END CCHH>'
         MSG   ' READ SKIP DISPLACMENT AND PRINT IF NON-ZERO'
         DC    X'FF'
H#PRTSDA MSG   'PRTSDA <START CCHH>  <END CCHH>'
         MSG   ' READ SKIP DISPLACMENT AND PRINT (ALL)'
         DC    X'FF'
H#DISPT  MSG   'DISPTRK <# LINES>'
         MSG   '  DISPLAY CURRENT TRACK IMAGE FROM STORAGE'
         MSG   '  OPERAND IS THE NUMBER OF LINES OF KEY/DATA TO DISPLAY*
               '
         DC    X'FF'
H#RW     MSG   'REWRITE - REWRITE TRACK IMAGE WITH WRITE CKD'
         MSG   '  THIS CAN LOOSE INFORMATION IF TRACK IMAGE IS NOT COMP*
               LETE'
         DC    X'FF'
H#ALLOW  MSG   'ALLOW <OPERAND>'
         MSG   ' ALLOWS NON-SAFE COMMANDS TO BE USED, OPERANDS ARE:'
         MSG   '    WRITE - ALLOW WRITE (CAN DESTROY DATA)'
         MSG   '    AUTH  - ALLOW ANY VOLUME / UNIT TO BE USED'
         DC    X'FF'
H#VOL    MSG   'VOLUME <VOLSER>'
         MSG   ' <VOLSER> SET AS TARGET, EXTENTS INCLUDE ENTIRE PACK'
         MSG   ' REQUIRES AUTHORIZATION AND GOOD VTOC/VOLUME LABEL'
         DC    X'FF'
H#UNIT   MSG   'UNIT <ADDR>'
         MSG   ' <ADDR> SET AS TARGET, EXTENTS INCLUDE ENTIRE PACK'
         MSG   ' REQUIRES AUTHORIZATION '
         DC    X'FF'
H#WRITE  MSG   'WRITE <SEARCH CCHHR> <COUNT FIELD>'
         MSG   ' WRITE CKD OF <COUNT FIELD> AFTER SEARCH ID EQ FOR SEAR*
               CH CCHHR'
         MSG   ' BLOCK WILL CONTAIN ZEROS IN KEY/DATA FIELDS IF ANY'
         MSG   ' **** REST OF TRACK WILL BE ERASED ****'
         DC    X'FF'
H#SCAN   MSG   'SCAN <START CYL> <END CYL>'
         MSG   ' READ CKD/SKIP/SLI SCAN OVER SPECIFIED AREA'
         MSG   ' BRIEF NOTE FOR ERRORS, DEFECTIVE/ALT TRACKS'
         MSG   ' TURNS OFF IBM ERROR RECOVERY'
         DC    X'FF'
H#CE1    MSG   'CEON'
         MSG   ' SET EXTENTS TO CE CYLINDERS'
         DC    X'FF'
H#RESET  MSG   'RESET'
         MSG   ' RESTORE DEB TO ORIGINAL STATE'
         MSG   ' (RESTORES FILE MASK, UCB ADDR, DEB EXTENTS)'
         DC    X'FF'
H#WRTSD  MSG   'WRTSD'
         MSG   ' WRTSD <SD> <SD> <SD> <F> <CCHH> <OPT R0 CCHH>'
         MSG   ' WRITE HA/R0 WITH SKIP DISPLACMENTS (3350 ONLY)'
         MSG   ' *** VERY UNSAFE COMMAND ***'
         DC    X'FF'
H#WRTCK  MSG   'WRTCK'
         MSG   ' WRTCK <CCHH> <OPT # RETRIES>'
         MSG   ' WRITE R1/READ BACK/COMPARE '
         DC    X'FF'
 TITLE 'SALVAGE - VOLUME / UNIT COMMANDS'
*   VOLUME/UNIT COMMANDS
C$UNIT   LA    R11,C$VOL-C$UNIT(,R11)   GET COMMON BASE
         USING C$VOL,R11
         MVI   V#FLAG+1,4               INDICATE UNIT ENTRY
         B     C$VOLX
         SPACE 1
C$VOL    MVI   V#FLAG+1,0               INDICATE VOLUME ENTRY
C$VOLX   BAL   R10,S$SCN                SCAN FOR VOLSER OR UNIT
         BNP   V$BOPR                   BIF NO OPERAND
         BAL   R10,S$STR                SET TO DWD
         BH    V$BOPR                   BIF > 8 CHARS
         SPACE 1
         CLOSE MF=(E,OPNVOL)            MAKE SURE IS CLOSED
         NI    G#ALLOW,255-X'80'        DON'T ALLOW WRITES YET
         RDJFCB MF=(E,OPNVOL)           GET JFCB OF VOLUME
         LA    R2,101                   ABEND CODE FOR RDJFCB FAILED
         BXH   R15,R15,ABEND            BIF RDJFCB FAILED
         MVI   V#JFCB,X'04'             SET FMT 4 NAME
         MVC   V#JFCB+1(43),V#JFCB
         OI    V#JFCB+52,X'08'          DON'T REWRITE JFCB
         MVI   OPNVOL,X'80'             FORCE OPEN FOR INPUT
         OPEN  MF=(E,OPNVOL),TYPE=J     OPEN VTOC
         TM    VOLUME+48,X'10'          DID IT OPEN?
         BZ    ABEND                    BIF OPENJ FAILED
         RCALL EXTSAVE                  SAVE ORIG EXTENTS
         OI    DCBIFLGS-IHADCB+VOLUME,DCBIFNE3 NO IBM ERROR RECOV
         SPACE 1
*  FIND UCB WITH SPECIFIED UNIT OR VOLUME AND CHANGE DEB TO
*   POINT TO IT.
*
         SPACE 1
         BAL   R10,V$UCBSCN             FIND A UCB
         B     V$NFND                   BIF UCB NOT FOUND
         USING UCBOB,R6                 BASE FOR UCB
         LH    R15,V#FLAG               GET SEARCH TYPE
         B     *+4(R15)                 TO CORRECT SEARCH
         B     V$VOLSCH                 BIF VOLUME SEARCH
*   IS UNIT SEARCH
         CLC   UCBNAME,DWD              THIS THE UCB?
         BNE   V$UCBNXT                 TRY NEXT IF NOT
         B     V$UCBFND
         SPACE 1
V$VOLSCH CLC   UCBVOLI,DWD              THIS THE VOLUME?
         BNE   V$UCBNXT
         SPACE 1
V$UCBFND L     R4,DCBDEBAD-IHADCB+VOLUME GET @ OF DEB
         BAL   R10,S$KEY0
         STH   R6,DEBUCBAD-DEBDASD+DEBBASND-DEBBASIC+2(,R4) SET @ UCB
         DROP  R6                       (UCBOB)
         BAL   R10,S$KEYNZ
         SPACE 1
*  GET DEVICE TYPE / CHARACTERISTICS / FULL TRACK BUFFER
         RCALL DEVTYPE,1                DEVTYPE, NO PRINTING
         SPACE 1
*  SET EXTENTS IN DEB TO ENTIRE VOLUME (INCLUDING ALT TRKS)
         XC    G#WORK(10),G#WORK        ZERO CCHHCCHHTT
         LH    R7,G#DTSCYL   CYLS / PACK
         LH    R5,G#DTSTRK   TRKS / CYL      0 2 4 6 8
         LR    R0,R7                    COPY CYLS / PACK
         BCTR  R0,0                     GET CYL EXTENT LIMIT
         STH   R0,G#WORK+4       TO CYL EXTENT LIMIT
         MR    R6,R5                    GET NUMBER OF TRKS IN EXTENT
         STH   R7,G#WORK+8
         BCTR  R5,0              GET HEAD EXTENT LIMIT
         STH   R5,G#WORK+6       TO HEAD EXTENT LIMIT
         BAL   R10,S$KEY0
         MVC   DEBSTRCC-DEBDASD+DEBBASND-DEBBASIC(10,R4),G#WORK
** ALLOW SEEK HEAD COMMANDS IN FILE MASK
         NI    DEBDVMOD-DEBDASD+DEBBASND-DEBBASIC(R4),X'FF'-X'08'
         BAL   R10,S$KEYNZ
         RCALL DEVTYPE,0                DEVTYPE WITH PRINTING
         B     RETZ                     AND RETURN
         SPACE 1
V$NFND   MVC   LINE+1(24),=C'VOLUME OR UNIT NOT FOUND'
         B     V$PRTRET                 GO PRINT MSG
         SPACE 1
V$BOPR   MVC   LINE+1(26),=C'INVALID OR MISSING OPERAND'
V$PRTRET BAL   R10,S$PRINT              PRINT ERROR MSG
         B     RETZ                     AND RETURN
         SPACE 1
*  SCAN UCBS; RETURN ALL DASD UCBS.
*    ON RETURN 0(R10)  - NO MORE UCBS
*              4(R10)  - R6 CONTAINS @ UCB
*   USES R5 OVER CALLS FOR UCB ADR TABLE PTR.
         SPACE 1
V$UCBSCN L     R1,CVTPTR                @ CVT
         L     R5,CVTILK2-CVTMAP(,R1)   GET @ UCB @ LIST
         SPACE 1
V$UCBNXT LH    R6,0(,R5)                GET @ OF UCB
         LA    R5,2(,R5)                TO NEXT UCB PTR
         N     R6,=X'0000FFFF'          MASK UCB ADDRESS
         BZ    V$UCBNXT                 BIF NO UCB THERE
         C     R6,=X'0000FFFF'          END OF UCB LIST?
         BER   R10                      BIF NO MORE UCBS
         USING UCBOB,R6
         CLI   UCBTBYT3,UCB3DACC        DASD DEVICE?
         BNE   V$UCBNXT                 BIF NOT DASD DEVICE
         B     4(,R10)                  BIF HAVE UCB ADDRESS
         DROP  R6                       (UCBOB)
         SPACE 1
V#FLAG   DC    H'0'      0 - VOLUME ENTRY, 4 - UNIT ENTRY
V#SAVE   DC    8D'0'                    VOLUME / UNIT SAVE AREA
V#JFCB   DC    XL176'00'                JFCB AREA
         LTORG ,
 TITLE 'SALVAGE - DEVTYPE ROUTINE'
*   IF R1 = 0 THEN PRINTS
*        VOLUME SERIAL / UNIT ADDRES / UNIT TYPE
*        EXTENTS IN DEB (HEX)
         SPACE 1
         USING DEVTYPE,R11
DEVTYPE  LR    R7,R1                    SAVE PARM
         L     R5,DCBDEBAD-IHADCB+VOLUME GET @ DEB
         L     R6,DEBUCBAD-DEBDASD+DEBBASND-DEBBASIC(,R5) @ UCB
         USING UCBOB,R6
         MVC   G#DTUCB(4),UCBTYP        COPY UCB DEVICE TYPE
         SPACE 1
         L     R15,CVTPTR               GET @ CVT
         L     R15,CVTZDTAB-CVTMAP(,R15) @ DEVICE CHAR. TABLE
         SR    R1,R1                    CLEAR FOR IC
         IC    R1,G#DTUCB+3             DEVICE TYPE BYTE
         IC    R1,0(R1,R15)             GET OFFSET OF TYPE INFO
         AR    R1,R15                   GET @ TYPE INFO
         MVC   G#DTSYS(4*4),0(R1)       COPY 4 WORDS OF DEVTYPE INFO
         SPACE 1
         LM    R15,R1,=A(DEVTAB,DEVTABL,DEVTABE)
DT$LP1   CLC   UCBTBYT4(1),8(R15)       THIS THE ENTRY?
         BE    DT$FND                   BIF NOT THE ENTRY
         BXLE  R15,R0,DT$LP1            CONTINUE SEARCH
DT$FND   MVC   G#DTMY(32),0(R15)        AND SAVE MY INFO TOO
         SR    R0,R0
         ICM   R0,B'0011',G#DTSTLN      MAXIUM TRACK LENGTH
         SR    R1,R1                    CLEAR FOR IC
         IC    R1,G#DTSBNK              KEY OVERHEAD
         AR    R0,R1                    + SPACE BACK NOT KEYED
         IC    R1,G#DTSBOL              OVERHEAD LAST BLOCK
         TM    G#DTSFLG,G#DTSFHO        HALFWORD OVERHEAD?
         BZ    *+8                      BIF NOT H-WORD OVERHEAD
         LH    R1,G#DTSBOH              GET H-WORD OVERHEAD
         SR    R0,R1                    - OVERHEAD FOR LAST BLOCK
         ST    R0,G#MAXBLK              SAVE MAX BLOCK ON TRACK
         SPACE 1
         LTR   R7,R7                    PRINT MESSAGE?
         BNZ   RETZ                     RETURN IF NO MSG REQUIRED
         MVC   LINE(6),=C'0UNIT '
         MVC   LINE+6(3),UCBNAME
         MVC   LINE+10(6),=C'VOLUME'
         MVC   LINE+17(6),UCBVOLI
         MVC   LINE+24(4),=C'TYPE'
         MVC   LINE+29(8),G#DTMY        SET DEVICE TYPE NAME
         LA    R1,G#DTSCYL              CYLS/PACK, TRKS/CYL
         BAL   R10,S$HEXCVT              + TRK LEN TO HEX
         MVC   LINE+38(7),=C'TRK/CYL'
         MVC   LINE+46(4),G#WORK+4
         MVC   LINE+51(9),=C'CYLINDERS'
         MVC   LINE+61(4),G#WORK
         MVC   LINE+66(8),=C'MAXBLOCK'
         L     R0,G#MAXBLK
         CVD   R0,DWD                   TO DECIMAL
         MVC   LINE+75(5),=X'2020202120'
         ED    LINE+74(6),DWD+5
         MVI   LINE+81,C'('
         LA    R1,G#MAXBLK+2
         BAL   R10,S$HEXCVT
         MVC   LINE+82(4),G#WORK
         MVI   LINE+86,C')'
         TM    S#GETFLG,S#FCE
         BZ    *+10
         MVC   LINE+88(9),=C'>CE MODE<'
         BAL   R10,S$PRINT
         DROP  R6                       (UCBOB)
         SPACE 1
         MVC   LINE+1(7),=C'EXTENTS'
         SR    R4,R4                    CLEAR FOR IC
         IC    R4,DEBNMEXT-DEBBASIC(,R5) NUMBER OF EXTENTS
         LA    R3,DEBBASND-DEBBASIC(,R5) @ 1ST EXTENT
DT$EXTLP LA    R1,DEBSTRCC-DEBDASD(,R3)  @ CCHH CCHH
         BAL   R10,S$HEXCVT             TO HEX
         MVC   LINE+10(8),G#WORK         CCHH STARTING
         MVC   LINE+19(8),G#WORK+8       CCHH ENDING
         LA    R1,DEBNMTRK-DEBDASD(,R3)  @ NUMBER OF TRACKS
         BAL   R10,S$HEXCVT             TO HEX
         MVC   LINE+28(4),G#WORK        SET NUMBER OF TRACKS
         BAL   R10,S$PRINT              PRINT ONE EXTENT
         LA    R3,DEBNMTRK+2-DEBDASD(,R3) TO NEXT EXTENT
         BCT   R4,DT$EXTLP              PRINT ALL EXTENTS
         B     RETZ                     AND RETURN
 TITLE 'SALVAGE - MAIN ENTRY / COMMAND PROCESSOR'
         ENTRY ENTRY                    ENTRY POINT
         USING ENTRY,R15
ENTRY    B     ENTRYX
         DROP  R15
         DC    AL1(ENTRYX-ENTRY-4)
         DC    C'SALVAGE/COPYRIGHT.1978.1980.UCLA'
ENTRYX   STM   R14,R12,12(R13)
         LR    R11,R15                  INIT LOCAL BASE
         USING ENTRY,R11
         LR    R12,R11                  INIT GLOBAL BASE
         SH    R12,=Y(ENTRY-SALVAGE)
         SPACE 1
         L     R3,=A(1024*200)          SIZE OF WORK AREA
         LR    R0,R3                    COPY LENGTH REQUIRED
         O     R0,=X'03000000'          ADD SUBPOOL
         GETMAIN R,LV=(0)               GET WORKAREA
         LA    R2,0(,R1)                CLEAR HIGH BYTE
         LR    R0,R3                    COPY LENGTH FOR CLEAR
         BAL   R10,S$CLEAR              GO CLEAR STORAGE
         LA    R4,0(R2,R3)              @ PAST END OF AREA
         LR    R15,R13                  SAVE @ CALLERS SAVE AREA
         SH    R4,=Y(1024)              LEAVE A 1K STACK
         LA    R13,1024-72(,R4)         POINT TO LAST ON STACK
         STM   R2,R4,G#CORE             @ START, LENGTH, @ STACK LIMIT
         SPACE 1
         LA    R5,8(,R2)                SKIP PFX CCW AREA
         ST    R5,IOBCCWPT              SET @ FIRST CCW
         SH    R5,=H'8'                 BACK UP 8 BYTES FOR CCWS
         SR    R6,R6                    DON'T INIT G#CCWPT
         LR    R7,R5                    COPY CCW AREA ADDR
         AH    R7,=Y((10*8+256*8)-1)    POINT TO CCW END ADDR
         STM   R5,R7,G#CCWIT            SET CCW AREA PTRS
         LA    R2,8+1(,R7)              POINT TO SPACE LEFT
         LR    R3,R4                    COPY @ SPACE LEFT
         SR    R3,R2                    GET LENGTH SPACE LEFT
         SRL   R3,4                     SPLIT AREA IN HALF
         SLL   R3,3                     IN DOUBLE WORDS
         ST    R2,G#BUFIT               SET BUFFER ADDR
         AR    R2,R3
         ST    R2,G#TRKIT               SET TRACK ADDR
         LA    R1,T#BASE-T#(,R2)        GET R0 ENTRY ADDRESS
         ST    R1,G#TRKBS               SAVE R0 ENTRY ADDRESS
         BCTR  R2,0
         ST    R2,G#BUFMX               SET BUFFER LIMIT
         AR    R2,R3
         ST    R2,G#TRKMX               SET TRACK LIMIT
         SPACE 1
         ST    R13,8(,R15)              CHAIN DOWN TO MINE
         ST    R15,4(,R13)               AND MINE UP TO HIS
         RCALL TRKINIT                  INIT TRACK SAVE AREA
         SPACE 1
         LA    R3,OPNLST                @ OPEN PARM LIST
         BAL   R10,S$OPEN               GO OPEN/CHECK OPENS WORKED
         STAX  C$ATTN,USADDR=(R12),MF=(E,C#ATTN) SET UP STAX
         BXH   R15,R15,*+8              BIF NOT TSO
         OI    S#GETFLG,S#FTSO          RUNNING ON TSO
         SPACE 1
CM$LOOP  BAL   R10,S$GET                GET A CONTROL RECORD
         BZ    CM$EOF                   BIF EOF
         BAL   R10,S$SCN                GET COMMAND
         BNP   CM$LOOP                  BIF BLANK INPUT RECORD
         BAL   R10,S$STR                SET CMD TO DWD
         BH    CM$INV                   BIF INVALID CMD
         LM    R5,R7,=A(CMDTAB,CMDTABL,CMDTABE) BXLE REGS
CM$SRCH  CLC   0(8,R5),DWD              THIS THE COMMAND?
         BE    CM$FND                   BIF COMMAND FOUND
         BXLE  R5,R6,CM$SRCH            CONTINUE SEARCH
CM$INV   MVC   LINE+1(19),=C'* INVALID COMMAND *'
         BAL   R10,S$PRINT              PRINT ERROR MSG
         B     CM$LOOP                  AND CONTINUE
CM$FND   MVC   G#WORK(1),G#ALLOW        COPY FLAGS HE HAS SET
         NC    G#WORK(1),9(R5)          ONLY REQUIRED FLAGS FOR CMD
         CLC   G#WORK(1),9(R5)          HE HAVE ALL REQUIRED FLAGS?
         BE    CM$CKOPN                 BIF HE KNOWS WHAT HE IS DOING
         SPACE 1
         LA    R1,CM#MSGNA              'COMMAND NOT ALLOWED,
         BAL   R10,S$MSG                   SEE HELP INFO'
         B     CM$LOOP
         SPACE 1
CM$CKOPN TM    8(R5),X'80'              FILE REQUIRED TO BE OPEN?
         BZ    CM$CALL                  BIF FILE STATUS NOT IMPORTANT
         TM    VOLUME+48,X'10'          FILE ALREADY OPEN?
         BO    CM$CALL                  BIF FILE IS OPEN
         LA    R3,OPNVOL                PARM FOR S$OPEN/OPEN
         BAL   R10,S$OPEN               OPEN IT
         RCALL EXTSAVE                  SAVE ORIG EXTENTS
         OI    DCBIFLGS-IHADCB+VOLUME,DCBIFNE3 NO IBM ERROR RECOV
         RCALL DEVTYPE,0                INIT TYPE INFO WITH MSG
CM$CALL  LH    R15,10(,R5)              GET OFFSET OF CMD ROUTINE
         RCALL CALL,0                   GO CALL IT (INDIRECTLY)
         B     CM$LOOP                  AND CONTINE
CM$EOF   RCALL C$RESET                  RESET DEB IF REQUIRED
         CLOSE MF=(E,OPNLST)
         CLOSE MF=(E,OPNVOL)
         L     R13,4(,R13)              RESTORE CALLERS SAVEAREA
         LM    R14,R12,12(R13)          AND HIS REGS
         SR    R15,R15                  RETURN CODE ZERO
         BR    R14                      AND RETURN
         SPACE 1
CM#MSGNA MSG   '*** COMMAND NOT ALLOWED, SEE HELP INFO'
         SPACE 1
CALL     AR    R15,R12                  RELOCATE ROUTINE ADDRESS
         LR    R11,R15                  SET ROUTINE BASE
         BR    R11                      AND GO TO ROUTINE
         SPACE 1
C$ATTN   L     R1,8(,R1)                GET @ OF $
         OI    S#GETFLG-$(R1),S#FATTN   SET ATTN OCCURED
         BR    R14                      AND RETURN
         SPACE 1
C#ATTN   STAX  0,USADDR=0,MF=L
 TITLE 'SALVAGE - ALLOW COMMAND'
         USING ALLOW,R11
ALLOW    BAL   R10,S$SCN                SCAN FOR OPERAND
         BNP   AL$INV                   BIF NO OPERAND
         BAL   R10,S$STR                GET STRING
         BH    AL$INV                   BIF STRING TOO LONG
         SPACE 1
         LM    R3,R5,=A(AL#TAB,AL#TABL,AL#TABE)
AL$LOOP  CLC   DWD,0(R3)                FIND ALLOW OPERAND
         BE    AL$FND                   BIF OPERAND FOUND
         BXLE  R3,R4,AL$LOOP            CONTINUE SEARCH
AL$INV   LA    R1,AL#MSGIN               ALLOW OPERAND NOT FOUND
         B     AL$RET                    AND GO ISSUE MSG
AL$FND   LH    R15,10(,R3)              GET OFFSET OF ROUTINE
         B     $(R15)                   TO ROUTINE
         SPACE 1
AL$AUTH  NOP   0                        IF WERE AUTHORIZED THEN
         B     AL$FND2                   MODESET WILL WORK, IF NOT...
**       BXLE  R15,R15,AL$FND2          BIF WORKED
AL$AUTHN LA    R1,AL#MSGAF              AUTH FAILED MSG
         B     AL$RET                   AND GO ISSUE IT
         SPACE 1
AL$WRITE TM    VOLUME+48,X'10'          IS FILE OPEN?
         BZ    AL$FND2                  CONTINUE IF NOT OPEN
         L     R6,DCBDEBAD-IHADCB+VOLUME @ DEB
         TM    DEBDVMOD-DEBDASD+DEBBASND-DEBBASIC(R6),X'C0' WRITE OK?
         BNM   AL$FND2                  BIF FMD WRITE ALLOWED
         TM    G#ALLOW,X'40'            AUTHORIZED?
         BZ    AL$AUTHN                 BIF NOT AUTHORIZED
         BAL   R10,S$KEY0               GET KEY 0
         NI    DEBDVMOD-DEBDASD+DEBBASND-DEBBASIC(R6),255-X'C0'
         BAL   R10,S$KEYNZ              ALLOW ALL WRT BUT HA/R0
         SPACE 1
AL$FND2  LH    R1,8(,R3)                GET OFFSET OF MSG
         AR    R1,R12                   @ OF MSG
         OC    G#ALLOW,12(R3)           ALLOW IT NOW
AL$RET   BAL   R10,S$MSG                ISSUE MSG
         B     RET                       AND RETURN
         SPACE 1
AL$HAR0  TM    VOLUME+48,X'10'          IS FILE OPEN?
         BZ    AL$FND2                  CONTINUE IF NOT OPEN
         L     R6,DCBDEBAD-IHADCB+VOLUME @ DEB
         TM    DEBDVMOD-DEBDASD+DEBBASND-DEBBASIC(R6),X'C0' HAR0 OK?
         BO    AL$FND2                  BIF WRITE HA/R0 ALLOWED
         TM    G#ALLOW,X'40'            AUTHORIZED?
         BZ    AL$AUTHN                 BIF NOT AUTHORIZED
         BAL   R10,S$KEY0               GET KEY 0
         OI    DEBDVMOD-DEBDASD+DEBBASND-DEBBASIC(R6),X'C0'
         BAL   R10,S$KEYNZ              ALLOW ALL WRT, INC HA/R0
         B     AL$FND2
         SPACE 1
AL#TAB   DC    0H'0',CL8'WRITE   ',Y(AL#MSGW-$,AL$WRITE-$),XL2'8000'
AL#TABL  EQU   *-AL#TAB
         DC    0H'0',CL8'AUTH    ',Y(AL#MSGA-$,AL$AUTH-$),XL2'4000'
         DC    0H'0',CL8'HAR0    ',Y(AL#MSGH-$,AL$HAR0-$),XL2'2000'
AL#TABE  EQU   *-AL#TABL
         SPACE 1
AL#MSGIN MSG   'INVALID OR MISSING OPERAND'
AL#MSGW  MSG   '*** WRITE NOW ALLOWED, DATA MAY BE DESTROYED'
AL#MSGA  MSG   '*** AUTHORIZED, VOLUMES MAY BE DESTROYED'
AL#MSGAF MSG   'NOT AUTHORIZED, COMMAND RESTRICTED'
AL#MSGH  MSG   '*** HA/R0 WRITE ALLOWED, SKIP DISPLACMENTS MAY BE LOST'
 TITLE 'SALVAGE - IOERR FORMAT ROUTINE'
*  ECB XX CSW XXXXXX XXXXXXXX SENSE XXXX IOBSEEK XXXXXXXXXXXXXXXX
*  CCW XXXXXXXX XXXXXXXX DATA XXXXXXXXXXXXXXXX
         SPACE 1
         USING IOERR,R11
IOERR    MVC   LINE+1(3),=C'ECB'
         LA    R1,ECB                   @ STUFF TO CONVERT
         BAL   R10,S$HEXCVT             TO HEX
         MVC   LINE+5(2),G#WORK         SET ECB
         MVC   LINE+8(3),=C'CSW'
         LA    R1,IOBCSW
         BAL   R10,S$HEXCVT
         MVC   LINE+12(6),G#WORK+2
         MVC   LINE+19(8),G#WORK+8
         MVC   LINE+28(5),=C'SENSE'
         LA    R1,IOBSEN0
         BAL   R10,S$HEXCVT
         MVC   LINE+34(4),G#WORK
         MVC   LINE+39(7),=C'IOBSEEK'
         LA    R1,IOBSEEK
         BAL   R10,S$HEXCVT
         MVC   LINE+47(16),G#WORK
         BAL   R10,S$PRINT
         L     R1,IOBCSW                GET ADDR OF CCW + 8
         N     R1,=X'00FFFFFF'          CLEAR HIGH BYTE / TEST
         BZ    RETZ
         SH    R1,=H'8'                 POINT TO CCW
         CL    R1,G#CCWIT
         BL    IOERRPT2
         CL    R1,G#CCWMX
         BH    IOERRPT2
         MVC   LINE+1(3),=C'CCW'
         BAL   R10,S$HEXCVT
         MVC   LINE+5(8),G#WORK
         MVC   LINE+14(8),G#WORK+8
         MVC   LINE+23(4),=C'DATA'
         L     R1,0(,R1)                GET DATA ADDRESS
         BAL   R10,S$HEXCVT
         MVC   LINE+28(16),G#WORK
IOERRPT2 BAL   R10,S$PRINT
         SPACE 1
         MVC   G#WORK(2),IOBCSW+4
         MVC   G#WORK+2(2),IOBSEN0
         LA    R6,LINE+1                OUTPUT PTR
         LR    R7,R6                    SAVE COPY OF LINE+1
         LA    R4,STBITTAB
IOERRST1 SR    R2,R2                    CLEAR FOR IC
         IC    R2,0(,R4)
         SRDL  R2,3                     GET BYTE OFFSET FROM BITS
         SRL   R3,29                    GET BIT NUMBER
         LA    R5,X'80'                 BIT ZERO
         SRL   R5,0(R3)                 GET BIT TO TEST
         LA    R2,G#WORK(R2)            POINT TO BYTE TO TEST
         EX    R5,IOERRTM               TM 0(R2),0
         BZ    IOERRST5
         LA    R0,LINE+133-20
         CR    R6,R0
         BNH   IOERRST2
         BAL   R10,S$PRINT
         LR    R6,R7                    POINT TO LINE+1
IOERRST2 MVC   0(20,R6),1(R4)           SET MSG
         LA    R6,20(,R6)
IOERRST3 CLI   0(R6),C' '
         BNE   IOERRST4
         BCT   R6,IOERRST3
IOERRST4 MVI   1(R6),C','
         LA    R6,2(,R6)                SKIP COMMA, BLANK
IOERRST5 LA    R4,21(,R4)               BUMP TO NEXT TABLE ENTRY
         CLI   0(R4),X'FF'              END OF TABLE?
         BNE   IOERRST1                 CONTINUE IF NOT END
         CR    R6,R7                    LINE EMPTY?
         BE    RETZ
         BAL   R10,S$PRINT
         B     RETZ
IOERRTM  TM    0(R2),0                  * EXECUTED *
         SPACE 1
*                       '12345678901234567890'
STBITTAB SBIT  CSW,00,0,'ATTENTION           '
         SBIT  CSW,00,1,'STATUS MODIFIER     '
         SBIT  CSW,00,2,'CONTROL UNIT END    '
         SBIT  CSW,00,3,'BUSY                '
         SBIT  CSW,00,4,'CHANNEL END         '
         SBIT  CSW,00,5,'DEVICE END          '
         SBIT  CSW,00,6,'UNIT CHECK          '
         SBIT  CSW,00,7,'UNIT EXECPTION      '
         SBIT  CSW,01,0,'PCI                 '
         SBIT  CSW,01,1,'INCORRECT LENGTH    '
         SBIT  CSW,01,2,'PROTECTION CHECK    '
         SBIT  CSW,01,3,'PROGRAM CHECK       '
         SBIT  CSW,01,4,'CH. DATA CHECK      '
         SBIT  CSW,01,5,'CH. CONTROL CHECK   '
         SBIT  CSW,01,6,'IFC CONTROL CHECK   '
         SBIT  CSW,01,7,'CHAINING CHECK      '
         SBIT  SEN,00,0,'COMMAND REJECT      '
         SBIT  SEN,00,1,'INTERV. REQUIRED    '
         SBIT  SEN,00,2,'BUS OUT PARITY CK   '
         SBIT  SEN,00,3,'EQUIPMENT CHECK     '
         SBIT  SEN,00,4,'DATA CHECK          '
         SBIT  SEN,00,5,'OVERRUN             '
         SBIT  SEN,00,6,'TRACK CONDITION CK  '
         SBIT  SEN,00,7,'SEEK CHECK          '
         SBIT  SEN,01,0,'COUNT AREA CHECK    '
         SBIT  SEN,01,1,'TRACK OVERRUN       '
         SBIT  SEN,01,2,'CYLINDER END        '
         SBIT  SEN,01,3,'INVALID SEQUENCE    '
         SBIT  SEN,01,4,'NO RECORD FOUND     '
         SBIT  SEN,01,5,'FILE PROTECTED      '
         SBIT  SEN,01,6,'MISSING ADR MARKER  '
         SBIT  SEN,01,7,'OVERFLOW INCOMPLETE '
         DC    X'FF'                    END OF TABLE
 TITLE 'SALVAGE - READ - TRACK READ ROUTINE'
*  READ - READ IN TRACK (LOGICAL ADDR IN LOGCCHH)
*       - IF READ HA / R0 FAILS THEN USE SPACE COUNT TO READ R1
*       - USE SPACE COUNT TO READ RECORDS AFTER RECORD WITH BAD
*         COUNT FIELDS???
* RETURN CODE:  Z - TRACK READ, NO ERRORS
*               P - TRACK READ, SOME ERRORS (R15 = NUMBER?)
*               M - FATAL ERROR
         SPACE 1
         USING READ,R11
READ     RCALL TRKINIT                  INITIALIZE TRACK IMAGE AREA
         MVC   PHYCCHH,LOGCCHH          INIT PHYSICAL ADDRESS
         MVC   IOBSEEKC(4),PHYCCHH      AND IOBSEEK ADDRESS
         USING T#ENTRY,R7               BASE FOR ENTRY
         SPACE 1
         XC    G#TRY,G#TRY              SET NO TRIES SO FAR
R$RETRY  BAL   R10,S$RETRY              TRY (AGAIN)
         BH    R$GIVEUP                 BIF TIME TO GIVE UP
         TM    S#GETFLG,S#FATTN         ATTENTION?
         BO    RETM                     RETURN IF ATTN (FATAL ERROR)
         SPACE 1
         L     R7,G#TRKIT               @ T#
         LA    R7,T#ENTRY-T#(,R7)       @ HA ENTRY
         BAL   R10,S$CCWI               INIT CCW BUILD
         LM    R14,R15,R#CCWHA          PATTERN READ HA CCW
         BAL   R10,S$CCWD               BUILD IT
         LA    R7,T#BASE                TO R0 ENTRY
         LM    R14,R15,R#CCWR0          PATTERN READ R0 CCW
         BAL   R10,S$CCWD               BUILD IT
         LM    R14,R15,R#CCWSHA         SEARCH HA EQ CCW
         BAL   R10,S$CCW                SET IT
         LR    R14,R2                   COPY *-8 FOR TIC
         O     R14,=X'08000000'         MAKE IT TIC
         BAL   R10,S$CCW                SET TIC *-8 CCW
         LA    R6,256                   NUMBER OF READ COUNT CCWS
         SPACE 1
R$LOOP1  LA    R7,T#BASE                TO NEXT RECORD ENTRY
         LM    R14,R15,R#CCWCNT         PATTERN READ COUNT CCW
         BAL   R10,S$CCWD               BUILD READ CNT CCW
         BH    R$BUFOUT                 BIF OUT OF SPACE
         BCT   R6,R$LOOP1               BUILD 256 READ COUNT CCWS
         LM    R14,R15,R#CCWNOP         ADD NOP AT END
         BAL   R10,S$CCW                SET NOP CCW AT END OF CHAIN
         SPACE 1
         BAL   R10,S$DOIO               GO DO THE I/O
         RCALL TRKSAVE                  SAVE INFO FROM CORRECT TRACK
         BM    RET                      BIF FATAL ERROR
         TM    IOBCSW+4,X'02'           UNIT CHECK?
         BZ    R$ERR1                   BIF > 255 RECORDS ON TRK
         TM    IOBSEN1,X'08'            NO RECORD FOUND?
         BO    R$READ2                  BIF WHAT I EXPECTED
R$CK2301 CLI   G#DTUCB+3,X'02'          2301 DRUM?
         BNE   R$ERR1                   BIF NOT DRUM
         CLI   ECB,X'7F'                ALL I/O OK?
         BE    R$READ2                  BIF I/O OK FOR DRUM
R$ERR1   RCALL IOERR                    PRINT RESULTS
         CLI   ECB,X'42'                EXTENT VIOLATION?
         BE    RETM                     BIF FATAL ERROR
         B     R$RETRY                  AND TRY AGAIN
         EJECT ,
R$READ2  XC    G#TRY,G#TRY              NO TRYS YET
R$RETRY2 BAL   R10,S$RETRY              TRY IT AGAIN
         BH    R$GIVEUP
         TM    S#GETFLG,S#FATTN         ATTENTION?
         BO    RETM                     RETURN IF ATTN (FATAL)
         SPACE 1
         BAL   R10,S$CCWI               INIT FOR CCW BUILD
         LM    R14,R15,R#CCWHA          PATTERN READ HA CCW
         BAL   R10,S$CCWD               SET READ HA CCW
***** FOLLOWING CODE MAY HANDLE EOF'S INCORRECTLY...
*****   (WILL NOT READ KEY FIELDS OF EOF; NOR R0 KEY)
         SPACE 1
         L     R7,G#TRKBS               @ RECORD 0 ENTRY
R$LOOP2  LA    R7,T#BASE                POINT TO RECORD 1 ENTRY
         TM    T#RSFLG,T#RFCNT          SAVED COUNT OF RECORD?
         BZ    R$EOT                    BIF END OF TRACK
         SR    R3,R3                    CLEAR FOR IC
         IC    R3,T#RCNT+5              GET KEY LENGTH
         L     R4,T#RCNT+4              GET DATA LENGTH
         N     R4,=X'0000FFFF'          ONLY WANT DATA LENGTH
         LM    R14,R15,R#CCWCNT         ASSUME EOF
         BZ    R$EOF2                   BIF IS EOF (DATA LENGTH ZERO)
         AR    R3,R4                    GET K + DD
         LM    R14,R15,R#CCWCKD         PATTERN READ CKD CCW
         AR    R15,R3                   SET LENGTH TO CCW
R$EOF2   BAL   R10,S$CCWD               BUILD READ CKD CCW
         BH    R$BUFOUT                 BIF OUT OF BUFFER ROOM
         B     R$LOOP2                  CONTINUE BUILDING READ CKD
         SPACE 1
R$EOT    LM    R14,R15,R#CCWNOP         ADD NOP AT END
         BAL   R10,S$CCW                ADD IT
         BAL   R10,S$DOIO               READ THE TRACK
         L     R15,G#CCWIT              @ 1ST CCW - 8
         L     R15,8(,R15)              @ HA FIELD
         CLC   1(4,R15),PHYCCHH         ON CORRECT TRACK?
         BNE   R$BSEEK                  BIF ON WRONG TRACK
         RCALL TRKSAVE                  SAVE ANY KEYS/DATA RECOVERED
         BM    RET                      RETURN IF FATAL ERROR
         CLI   ECB,X'7F'                ANY ERRORS?
         BE    R$RET                    GO RETURN IF WORKED OK
         RCALL IOERR                    ELSE PUBLISH ERROR
         B     R$RETRY2                 AND TRY AGAIN
         SPACE 1
R$GIVEUP MVC   LINE+1(20),=C'RETRY COUNT EXCEEDED'
         BAL   R10,S$PRINT              PRINT ERROR MSG
R$RET    LH    R15,G#TRY                GET TRY NUMBER
         BCTR  R15,0                    ONE TRY IS NORMAL
         B     RET                      AND RETURN
         SPACE 1
R$BUFOUT MVC   LINE+1(16),=C'BUFFER TOO SMALL'
         BAL   R10,S$PRINT
         B     RETM                     FATAL ERROR RETURN
         SPACE 1
R$BSEEK  MVC   LINE+1(17),=C'** SEEK ERROR, HA'
         LR    R1,R15                   @ HA
         BAL   R10,S$HEXCVT
         MVC   LINE+19(10),G#WORK       HA READ TO LINE
         MVC   LINE+30(7),=C'PHYCCHH'
         LA    R1,PHYCCHH
         BAL   R10,S$HEXCVT
         MVC   LINE+38(8),G#WORK
         BAL   R10,S$PRINT
         B     RETM                     FATAL ERROR
         SPACE 1
R#CCWHA  CCW   X'1A',0,X'40',5          PATTERN READ HA
R#CCWR0  CCW   X'16',0,X'40',16         PATTERN READ R0
R#CCWSHA CCW   X'39',PHYCCHH,X'40',4     SEARCH HA EQ CCW
R#CCWSC  CCW   X'0F',0,X'40',3          PATTERN SPACE COUNT
R#CCWCNT CCW   X'12',0,X'40',8          PATTERN READ COUNT
R#CCWCKD CCW   X'1E',0,X'40',8          PATTERN READ CKD
R#CCWNOP CCW   X'03',0,X'20',1          NO OPERATION CCW, SLI
         SPACE 1
         LTORG ,
 TITLE 'SALVAGE - C$SCAN  - FAST I/O ERROR SCAN'
*
         USING C$SCAN,R11
C$SCAN   BAL   R10,S$HEX                GET START CYL
         BNP   SC$MOP                   BIF NO START
         SLL   R1,16                    TO CYLINDER POSITION
         ST    R1,LOGCCHH               SET START CYL
         ST    R1,SC#END                DEFAULT END CYL
         BAL   R10,S$HEX                GET END CYL
         BM    SC$GO                    BIF NO END CYL
         BZ    SC$MOP                   BIF INVALID OPERAND
         SLL   R1,16                    TO CYL POSITION
         ST    R1,SC#END                SAVE END CYL
         SPACE 1
*  TURN OFF IBM ERROR RECOVERY SO I GET END OF CYLINDER
SC$GO    OI    DCBIFLGS-IHADCB+VOLUME,DCBIFNE3
         RCALL M$IMSK                   GO ISSUE MSG
         EJECT ,
**** CHANNEL PGM -  READ HA -> SC#HA
*                   SEARCH ID EQ -> SC#RID
*                   TIC *-8
*               (N) READ CKD MT/SLI/ 8 BYTES
*                   TIC TO 1ST READ CKD
*
         SPACE 1
SC$LP1   XC    IOBSEEK,IOBSEEK          INIT SEEK TO ZERO
         MVC   IOBSEEKC(4),LOGCCHH      SET CYL, ZERO TRK
         MVC   SC#RID(5),IOBSEEKC       SET SEARCH ARG CCHHR
         CLC   LOGCCHH(2),SC#END        DONE?
         BH    RET                      RETURN IF DONE
         SPACE 1
SC$LP2   TM    S#GETFLG,S#FATTN         ATTENTION?
         BO    RET                      RETURN IF ATTENTION
         BAL   R10,S$CCWI               INIT CCW BUILDER
         LM    R14,R15,SC#RHA           GET READ HA CCW
         BAL   R10,S$CCW                GO SET IT
         LM    R14,R15,SC#SIDEQ         SEARCH ID EQ CCW
         BAL   R10,S$CCW                GO SET IT
         LR    R14,R2                   INIT TIC *-8
         O     R14,=X'08000000'         MAKE TIC
         BAL   R10,S$CCW                SET TIC *-8
         LA    R6,8(,R2)                SAVE @ OF 1ST READ CKD
         LA    R5,20                    NUMBER OF READ CKD TO BUILD
SC$CCWLP LM    R14,R15,SC#RCKD          READ CKD MT/SLI/8
         BAL   R10,S$CCWD               GO BUILD IT
         MVC   0(8,R14),=8X'FF'         INIT COUNT FIELD
         BCT   R5,SC$CCWLP              BUILD ALL READ CKD
         LR    R14,R6                   @ 1ST READ CKD FOR TIC
         O     R14,=X'08000000'         MAKE TIC
         BAL   R10,S$CCW                SET TIC
         BAL   R10,S$DOIO               CHECK A CYLINDER (?)
         CLC   IOBSEEKC(4),SC#HA+1      CORRECT CYLINDER?
         BNE   SC$ERR                   BIF IF WRONG SEEK
         L     R5,IOBCSW                GET @+8 OF LAST CCW DONE
         LA    R5,0(,R5)                CLEAR HIGH BYTE
         SH    R5,=H'8'                 BACK UP 8 BYTES
         BNP   SC$ERR                   BIF INVALID CCW PTR IN CSW
         CR    R5,R6                    CSW PTR :: @ 1ST READ CKD
         BL    SC$ERR                   BIF NOT READ CKD ERROR
         CLI   ECB,X'41'                ERROR I WANT?
         BNE   SC$ERR                   BIF BAD I/O
         TM    IOBCSW+4,X'02'           UNIT CHECK?
         BO    SC$UNITC                 BIF UNIT CHECK
         TM    IOBCSW+4,X'01'           UNIT EXECPTION (EOF)?
         BZ    SC$ERR                   ERROR IF NOT EOF
         L     R1,0(,R5)                GET @ OF COUNT FIELD
         MVC   SC#RID(5),0(R1)          SET RESTART CCHH
         MVC   IOBSEEKH(2),SC#RID+2     AND SEEK HH
         B     SC$LP2                   AND GO RESTART
SC$UNITC CLC   IOBSEN0(2),=X'0020'      VALID END OF CYLINDER?
         BE    SC$NEXT                  BIF END OF CYLINDER ONLY
*        CLC   IOBSEN0(2),=X'0100'      TRACK CONDITION CHECK?
*        BE
SC$ERR   RCALL IOERR                    ELSE TELL ALL
         CLI   ECB,X'41'                I/O TYPE ERROR?
         BNE   RET                      RETURN IF NOT REAL ERROR
         SPACE 1
SC$NEXT  LA    R1,1                     GET LAST CYL DONE
         AH    R1,LOGCCHH               NEW CYLINDER NUMBER
         STH   R1,LOGCCHH               SET NEW CYL
         B     SC$LP1                   CONTINUE
         SPACE 1
SC$MOP   LA    R1,SC#OPMSG              INVALID / MISSING OPERAND
         BAL   R10,S$MSG                GO PRINT IT
         B     RETM                     AND RETURN
         SPACE 1
SC#RHA   CCW   X'1A',SC#HA,X'40',5      READ HA
SC#SIDEQ CCW   X'31',SC#RID,X'40',5     SEARCH ID EQ
SC#RCKD  CCW   X'9E',0,X'60',8          READ CKD MT, SLI, 8 BYTES
SC#END   DC    F'0'                     END CC00 FOR SCAN
SC#HA    DC    XL5'FFFFFFFFFF'          HA READ AREA
SC#RID   DC    XL5'FFFFFFFFFF'          SEARCH ID EQ ARG
SC#OPMSG MSG   'INVALID OR MISSING OPERAND'
         LTORG ,
 TITLE 'SALVAGE - DISPTRK - DISPLAY TRACK IMAGE'
*
         USING DISPTRK,R11
         USING T#ENTRY,R7
DISPTRK  BAL   R10,S$HEX                GET OPERAND IF ANY
         BNP   DT$GO
         LTR   R1,R1                    IF ZERO
         BNZ   *+6                      THEN MAKE MAX NUMBER
         BCTR  R1,0
         SLL   R1,4                     * 16 BYTES / LINE
         ST    R1,DT#LINES
DT$GO    L     R7,G#TRKIT               @ TRACK IMAGE AREA
         LA    R7,T#ENTRY-T#(,R7)       POINT TO HA ENTRY
         TM    T#RSFLG,T#RFHA           HAVE HA?
         BZ    DT$LOOP                  BIF HA NOT READ
         LA    R1,T#RCNT                POINT TO HA DATA
         BAL   R10,S$HEXCVT             HA DATA TO HEX
         MVC   LINE+1(2),=C'HA'         SET ID
         MVC   LINE+4(10),G#WORK        AND FCCHH
         BAL   R10,S$PRINT              PRINT HA INFO
         SR    R3,R3                    INIT RECORD NUMBER TO ZERO
         SPACE 1
DT$LOOP  TM    S#GETFLG,S#FATTN         ATTENTION?
         BO    RET                      RETURN IF ATTENTION
         LA    R7,T#BASE                TO NEXT RECORD ENTRY
         TM    T#RSFLG,T#RFCNT          HAVE COUNT FIELD?
         BZ    DT$KEY                   BIF NO COUNT FIELD
         MVC   LINE+1(6),=C'RECORD'
         CVD   R3,G#WORK
         MVC   LINE+7(4),=X'40202120'
         ED    LINE+7(4),G#WORK+6
         MVC   LINE+12(5),=C'COUNT'
         LA    R1,T#RCNT                POINT TO COUNT FIELD
         BAL   R10,S$HEXCVT
         MVC   LINE+18(16),G#WORK
         BAL   R10,S$PRINT
         SPACE 1
DT$KEY   TM    T#RSFLG,T#RFKEY          HAVE KEY FIELD?
         BZ    DT$DATA
         MVC   LINE+1(3),=C'KEY'
         BAL   R10,S$PRINT
         SR    R0,R0                    CLEAR FOR KEY LENGTH
         IC    R0,T#RCNT+5              GET KEY LENGTH
         LH    R1,T#ROFF                GET OFFSET OF KEY/DATA
         A     R1,G#TRKIT               @ KEY DATA
         CL    R0,DT#LINES
         BNH   *+8
         L     R0,DT#LINES
         RCALL HEXDISP,(R1),(R0),ERRAD=RET PRINT KEY
         SPACE 1
DT$DATA  TM    T#RSFLG,T#RFDATA         HAVE DATA FIELD?
         BZ    DT$NEXT
         MVC   LINE+1(4),=C'DATA'
         BAL   R10,S$PRINT
         SR    R1,R1                    CLEAR FOR IC
         IC    R1,T#RCNT+5              GET KEY LENGTH
         AH    R1,T#ROFF                + OFFSET TO KEY/DATA
         A     R1,G#TRKIT               @ DATA FIELD
         L     R0,T#RCNT+4              GET LENGTH OF DATA
         N     R0,=X'0000FFFF'
         CL    R0,DT#LINES
         BNH   *+8
         L     R0,DT#LINES
         RCALL HEXDISP,(R1),(R0),ERRAD=RET PRINT DATA
DT$NEXT  LA    R3,1(,R3)                TO NEXT RECORD NUMBER
         CH    R3,=H'255'               DONE ALL RECORDS?
         BNH   DT$LOOP
         B     RET
DT#LINES DC    A(1*16)                  MAX BYTES TO DISPLAY
 TITLE 'SALVAGE - TRACK IMAGE SAVE/INIT/GET ROUTINES'
*  TRKSAVE - SCAN CCW CHAIN AND SAVE RECOVERED DATA.
*   RETURN CODES:  Z - NO NEW INFORMATION SAVED
*                  P - NEW INFORMATION SAVED
*                  M - FATAL ERROR
*
*   R9 - ORIENTATION (RECORD # * 4) + FIELD ID + 4
*        (NO ORIENTATION < 0, HA - 0, R0 - 4)
*        (COUNT 0, KEY 1, DATA 2)
*   R8 - CONSTANT OF 8
*   R7 - BASE FOR T#ENTRY
*   R6 - @ CURRENT CCW
*   R5 - LENGTH FROM CURRENT CCW
*   R4 - ADDRESS FROM CURRENT CCW
*   R3 - FLAG - ANY NEW INFO SAVED
*    NOTE: THIS ROUTINE CAN BE CALLED MORE THAN ONCE.
*
*    THE CCW WHICH THE CSW-8 POINTS TO IS NOT PROCESSED BY THIS
*    ROUTINE, AS IT MAY HAVE HAD AN ERROR.  IF A NOP IS ADDED TO
*    THE END OF THE CHAIN IT WILL BE THE CCW IGNORED.  (ASSUMING NO
*    REAL I/O ERROR).
         SPACE 1
         USING TRKSAVE,R11
TRKSAVE  SR    R9,R9                    NO ORIENTATION
         BCTR  R9,0
         USING T#ENTRY,R7
         LA    R8,8                     CONSTANT
         SR    R3,R3                    NO NEW INFO YET
         L     R1,IOBCSW                GET CSW
         N     R1,=X'00FFFFFF'          ANY ADDR AT ALL?
         BZ    TS$DONE                  BIF NO CCW'S TO PROCESS
         SH    R1,=H'8'                 POINT TO LAST CCW
         ST    R1,TS#LCCW               SAVE LAST CCW ADDRESS
         L     R6,IOBCCWPT              @ FIRST CCW
         N     R6,=X'00FFFFFF'          CLEAN HIGH BYTE
         SPACE 1
TS$LOOP  C     R6,TS#LCCW               THIS CCW GET DONE OK?
         BNL   TS$DONE                  BIF CCW NOT DONE OK
         LM    R4,R5,0(R6)              GET ADDRESS/LENGTH FROM CCW
         TM    4(R6),X'80'              DATA CHAINING?
         BO    TS$ERCCW                 BIF INVALID CCW
         N     R5,=X'0000FFFF'          ONLY WANT LENGTH
         TM    4(R6),X'10'              SKIP?
         BZ    *+6                      BIF NOT SKIP
         SR    R5,R5                    IF SKIP THEN NO DATA
         SR    R15,R15                  CLEAR FOR IC
         IC    R15,0(,R6)               GET CCW OP CODE
         IC    R15,TS#OPTAB(R15)        LOOK UP CCW OP
         AR    R15,R15                  GET ROUTINE OFFSET
         B     TS$RHA(R15)              TO ROUTINE
         SPACE 1
TS$NCCW  TM    4(R6),X'40'              COMMAND CHAIN?
         BZ    TS$DONE                  BIF DONE
         AR    R6,R8                    BUMP TO NEXT CCW
         B     TS$LOOP                  AND COUTINUE
* CCW - READ HA
TS$RHA   SR    R9,R9                    ORIENT TO HOME ADDRESS
         BAL   R10,TS$SUBR              POINT TO HA AREA
         LA    R9,4                     ORIENT AFTER HOME ADDRESS
         TM    T#RSFLG,T#RFHA           HAVE HA YET?
         BO    TS$NCCW                  BIF ALREADY HAVE HA
         CH    R5,=H'5'                 DID IT GET WHOLE HA?
         BL    TS$ERS                   BIF SHORT READ
         MVC   T#RCNT(5),0(R4)          SAVE HOME ADDRESS
         OI    T#RSFLG,T#RFHA
         OR    R3,R8                    NOTE NEW INFO
         B     TS$NCCW                  AND CONTINUE
         SPACE 1
* CCW - SEARCH HA EQ  (MUST BE FOLLOWED BY TIC *-8)
TS$SHA   LA    R9,4                     ORIENT AFTER HA
         CLI   8(R6),X'08'              FOLLOWED BY TIC?
         BNE   TS$ERCCW                 BIF INVALID CCW
         ST    R6,G#WORK                SET ADDR OF SEARCH HA CCW
         CLC   G#WORK+1(3),9(R6)        TIC TO *-8?
         BNE   TS$ERCCW                 BIF INVALID TIC
         AR    R6,R8                    SKIP TIC CCW
         B     TS$NCCW                  CONTINUE IF OK
         SPACE 1
* CCW - SPACE COUNT
TS$SC    LTR   R9,R9                    UNORIENTED SPACE COUNT?
         BM    TS$SCU                   BIF UNORIENTED SPACE COUNT
         LA    R9,3(,R9)                ROUND UP TO NEXT COUNT FIELD
         N     R9,=X'00000FFC'          TO NEXT (OR THIS) COUNT FIELD
         LA    R9,1(,R9)                NOW AT KEY FIELD
         B     TS$NCCW                  AND GO DO NEXT CCW
TS$SCU   LA    R9,8                     ORIENT TO COUNT OF RECORD 1
         B     TS$NCCW
         SPACE 1
* CCW - SEARCH ID EQ
TS$SRCH  TM    4(R6),X'20'              SLI?
         BO    TS$ERCCW                 INVALID IF SLI
         SR    R15,R15                  CLEAR FOR IC
         IC    R15,4(,R4)               GET RECORD NUMBER OF SEARCH
         LR    R9,R15                   ASSUME SEARCH IS VALID
         SLL   R9,2                     SET NEW ORIENTATION
         LA    R9,1(,R9)                TO KEY FIELD
         CLI   8(R6),X'08'              IS NEXT CCW TIC?
         BNE   TS$ERCCW
         ST    R6,G#WORK                SAVE CCW ADDR
         CLC   G#WORK+1(3),9(R6)        IS IT TIC *-8?
         BNE   TS$ERCCW
         AR    R6,R8                    AND SKIP TIC CCW
         BAL   R10,TS$SUBR              FIND ENTRY OF SEARCH TARGET
         TM    T#RSFLG,T#RFCNT          DO I HAVE COUNT FIELD?
         BZ    TS$ERCCW                 INVALID IF NO COUNT FIELD
         CLC   T#RCNT(5),0(R4)          THIS THE RECORD?
         BE    TS$NCCW                  AND CONTINUE IF ALL OK
         B     TS$ERCCW                 BIF INVALID SEARCH
         SPACE 1
* CCW - READ R0
TS$R0    LA    R9,4                     ORIENT TO R0 COUNT FIELD
         MVI   TS#CCWOP,X'1E'           FAKE READ CKD
         B     TS$R0X                   AND PROCESS LIKE READ CKD
         SPACE 1
* CCW - READ <COUNT>/<KEY>/<DATA>
TS$RCCW  LTR   R9,R9                    UNORIENTED?
         BM    TS$EROR                  BIF UNORIENTED READ
         MVC   TS#CCWOP(1),0(R6)        INIT CCW OPCODE
         CH    R9,=H'5'                 ORIENTED TO R0 KEY?
         BNL   TS$R0X                   BIF AFTER R0 KEY FIELD
         LA    R9,8                     ELSE ORIENT TO RECORD 1
TS$R0X   TM    4(R6),X'20'              SLI?
         BO    TS$ERCCW                 INVALID IF SLI
         TM    TS#CCWOP,X'10'           DOES CCW PROCESS CNT?
         BZ    TS$RKEY                  BIF NO COUNT PROCESSED
         LA    R9,3(,R9)                FIND COUNT FIELD
         N     R9,=X'0000FFFC'
         LA    R9,1(,R9)                NOW PAST COUNT FIELD
TS$RTRY1 BAL   R10,TS$SUBR              FIND ENTRY
         CR    R5,R8                    AT LEAST COUNT FIELD READ?
         BL    TS$ERS                   BIF SHORT COUNT READ
         LR    R1,R9                    COPY ORIENTATION
         SRL   R1,2                     GET RECORD NUMBER + 1
         BCTR  R1,0                     GET RECORD NUMBER
         EX    R1,TS$CLI                CLI 4(R4),0 CORRECT RECORD?
         BE    TS$RROK                  BIF CORRECT RECORD
* 2301 DRUM WON'T GET NO REC FND ON READ COUNT....
         CLI   G#DTUCB+3,X'02'          2301 DRUM?
         BNE   TS$ERTF                  BIF INVALID TRACK FORMAT
         CLI   4(R4),X'01'              WRAP BACK TO RECORD 1?
         BNE   TS$ERTF                  BIF INVALID TRACK FORMAT
         LA    R9,8+1                   ORIENT AFTER REC 1 COUNT
         B     TS$RTRY1                 AND TRY AGAIN
TS$RROK  OI    T#REFLG,T#RFCNT          COUNT FIELD EXISTS
         MVC   T#RCNT,0(R4)             SAVE COUNT
         AR    R4,R8                    POINT PAST COUNT FIELD
         SR    R5,R8                    AND GET LENGTH LEFT
         TM    T#RSFLG,T#RFCNT          ALREADY HAVE COUNT?
         BZ    *+6                      BIF ALREADY HAVE COUNT
         OR    R3,R8                    NOTE NEW FIELD
         OI    T#RSFLG,T#RFCNT          AND HAVE SAVED COUNT
*--- RESERVE SPACE FOR KEY/DATA
         BAL   R10,TS$LEN               GET KEY/DATA LENGTH
         LTR   R0,R0                    KEY EXIST?
         BZ    *+8                      BIF NO KEY FIELD
         OI    T#REFLG,T#RFKEY          KEY EXISTS
         LTR   R14,R14                  DATA EXIST?
         BZ    *+8                      BIF NO DATA FIELD
         OI    T#REFLG,T#RFDATA         DATA EXISTS
         C     R1,G#TRKIT               SPACE ALREADY RESERVED?
         BNE   TS$RKEY                  BIF ALREADY RESERVED
         LH    R15,0(,R1)               GET LENGTH SO FAR FROM RDW
         AR    R15,R1                   POINT TO END SO FAR
         AR    R0,R14                   SUM KEY/DATA LENGTHS
         AR    R0,R15                   POINT AFTER NEW SPACE
         C     R0,G#TRKMX               WILL IT FIT?
         BH    TS$ERFL                  BIF OUT OF IMAGE AREA
         SR    R0,R1                    NEW LENGTH FOR RDW
         STH   R0,0(,R1)                SET NEW LEN IN RDW
         SR    R15,R1                   GET OFFSET OF AREA
         STH   R15,T#ROFF               SAVE OFFSET
         SPACE 1
TS$RKEY  TM    TS#CCWOP,X'08'           DOES CCW PROCESS KEY?
         BZ    TS$RDATA
         LA    R9,2(,R9)                FIND RECORD CONTAINING KEY
         N     R9,=X'0000FFFC'
         LA    R9,1+1(,R9)              NOW PAST KEY
         BAL   R10,TS$SUBR              FIND ENTRY
         TM    T#RSFLG,T#RFCNT          HAVE COUNT?
         BZ    TS$ERCCW                 BIF DON'T KNOW KEY LENGTH
         TM    T#REFLG,T#RFKEY          KEY FIELD EXIST?
         BZ    TS$RDATA                 BIF NO KEY
         BAL   R10,TS$LEN               GET ADR KEY AREA/LEN KEY
         CR    R5,R0                    HAVE ENTIRE KEY?
         BL    TS$ERS                   BIF SHORT KEY READ
         LR    R15,R4                   COPY FROM ADDR FOR MOVE
         AR    R4,R0                    BUMP ADDR PAST KEY CLEAR FOR IC
         SR    R5,R0                    LENGTH LEFT AFTER KEY
         BAL   R10,S$MOVE               MOVE KEY TO AREA
         TM    T#RSFLG,T#RFKEY          ALREADY HAVE KEY?
         BO    *+6
         OR    R3,R8                    NOTE NEW INFO
         OI    T#RSFLG,T#RFKEY
         SPACE 1
TS$RDATA TM    TS#CCWOP,X'04'           DOES CCW PROCESS DATA?
         BZ    TS$NCCW                  CONTINUE IF NOT
         LA    R9,1(,R9)                ORIENT TO DATA FIELD
         N     R9,=X'0000FFFC'
         LA    R9,3(,R9)                NOW PAST DATA FIELD
         BAL   R10,TS$SUBR              FIND ENTRY
         TM    T#RSFLG,T#RFCNT          HAVE COUNT FIELD?
         BZ    TS$ERCCW                 BIF DON'T KNOW DATA LENGTH
         TM    T#REFLG,T#RFDATA         DATA FIELD EXIST?
         BZ    TS$NCCW                  BIF NO DATA FIELD
         BAL   R10,TS$LEN               GET DATA ADDR/LEN
         AR    R1,R0                    SKIP KEY IN TO AREA
         CR    R5,R14                   HAVE ENTIRE DATA FIELD?
         BL    TS$ERS                   BIF SHORT DATA READ
         LR    R0,R14                   SET DATA LENGTH TO MOVE
         LR    R15,R4                   COPY FROM ADDR FOR MOVE
         BAL   R10,S$MOVE               MOVE DATA TO AREA
         TM    T#RSFLG,T#RFDATA         ALREADY HAVE DATA?
         BO    *+6
         OR    R3,R8                    NOTE NEW INFO
         OI    T#RSFLG,T#RFDATA
         B     TS$NCCW                  AND CONTINUE
TS$CLI   CLI   4(R4),0                  * EXECUTED *
         SPACE 1
TS$DONE  LR    R15,R3                   SET RETURN CODE
         B     RET                      AND RETURN
         SPACE 1
** TS$SUBR - FIND T#ENTRY OF CURRENT ORIENTATION
TS$SUBR  LTR   R7,R9                    ORIENTED?
         BM    TS$EROR                  BIF UNORIENTED
         N     R7,=X'0000FFFC'          GET TO RECORD ID
         SLL   R7,2                     GET (REC NUM + 1) * 16
         CL    R7,=A(257*16)            RECORD NUMBER VALID?
         BH    TS$EROR                  BIF INVALID RECORD NUMBER
         LA    R7,T#ENTRY-T#(,R7)       ACCOUNT FOR PREFIX
         A     R7,G#TRKIT               POINT TO ENTRY
         BR    R10                      AND RETURN
         SPACE 1
*  RETURN KEY LEN IN R0, DATA LEN IN R14
*  AND ADDRESS KEY/DATA AREA IN R1.
TS$LEN   SR    R0,R0                    CLEAR FOR IC
         IC    R0,T#RCNT+5              GET KEY LENGTH
         L     R14,T#RCNT+4             GET DATA LENGTH
         N     R14,=X'0000FFFF'
         LH    R1,T#ROFF                GET OFFSET OF KEY/DATA AREA
         A     R1,G#TRKIT               GET @ KEY/DATA AREA
         BR    R10                      AND RETURN
         SPACE 1
TS$ERS   MVC   LINE+1(10),=C'SHORT READ'
         B     TS$ERR
TS$EROR  MVC   LINE+1(17),=C'ORIENTATION ERROR'
         B     TS$ERR
TS$ERCCW MVC   LINE+1(11),=C'INVALID CCW'
TS$ERR   LR    R1,R6                    COPY CCW ADDR
         BAL   R10,S$HEXCVT             TO HEX
         MVC   LINE+20(16),G#WORK       CCW TO LINE
         B     TS$ERRRT
TS$ERFL  MVC   LINE+1(21),=C'TRACK IMAGE AREA FULL'
TS$ERRRT BAL   R10,S$PRINT              PRINT ERROR MSG
         LNR   R15,R8                   INDICATE FATAL ERROR
         B     RET                      AND RETURN CODE ZERO
TS$ERTF  MVC   LINE+1(32),=C'INVALID TRACK FORMAT, CNT FIELD:'
         LR    R1,R4                    @ COUNT FIELD
         BAL   R10,S$HEXCVT             COUNT TO HEX
         MVC   LINE+34(16),G#WORK
         B     TS$ERRRT                 IS FATAL ERROR
         DROP  R7                       (T#ENTRY)
         SPACE 1
TS#LCCW  DC    A(0)                     @ LAST CCW EXECUTED BY CHANNEL
TS#CCWOP DC    X'00'                    CURRENT CCW OPCODE
         SPACE 1
TS#OPTAB DC    256AL1((TS$ERCCW-TS$RHA)/2)
         ORG   TS#OPTAB+X'1A'           READ HA
         DC    AL1((TS$RHA-TS$RHA)/2)
         ORG   TS#OPTAB+X'12'           READ COUNT
         DC    AL1((TS$RCCW-TS$RHA)/2)
         ORG   TS#OPTAB+X'16'           READ R0
         DC    AL1((TS$R0-TS$RHA)/2)
         ORG   TS#OPTAB+X'06'           READ DATA
         DC    AL1((TS$RCCW-TS$RHA)/2)
         ORG   TS#OPTAB+X'0E'           READ KEY / DATA
         DC    AL1((TS$RCCW-TS$RHA)/2)
         ORG   TS#OPTAB+X'1E'           READ CKD
         DC    AL1((TS$RCCW-TS$RHA)/2)
         ORG   TS#OPTAB+X'31'           SEARCH ID EQ
         DC    AL1((TS$SRCH-TS$RHA)/2)
         ORG   TS#OPTAB+X'0F'           SPACE COUNT
         DC    AL1((TS$SC-TS$RHA)/2)
         ORG   TS#OPTAB+X'39'           SEARCH HA EQ
         DC    AL1((TS$SHA-TS$RHA)/2)
         ORG   ,
         EJECT ,
* TRKINIT - REINITIALIZE TRACK AREA
         USING TRKINIT,R11
TRKINIT  L     R9,G#TRKIT               GET @ AREA
         LR    R1,R9                    SET CLEAR ADDRESS
         LH    R8,=Y(T#L)               GET LENGTH TO CLEAR
         LR    R0,R8                    SET FOR CLEAR
         BAL   R10,S$CLEAR              GO CLEAR BASIC HEADER
         STH   R8,0(,R9)                INIT RDW
         OI    T#REFLG-T#(R9),T#RFHA    HA MUST EXIST
         B     RET                      AND RETURN
         SPACE 2
* TRKCHECK - CHECK IF HAVE ENTIRE TRACK
         USING TRKCHECK,R11
TRKCHECK L     R7,G#TRKIT               GET @ TRACK AREA
         LA    R7,T#ENTRY-T#(,R7)       @ HA ENTRY
         USING T#ENTRY,R7
         LA    R6,1+256                 HA + # RECORD ENTRIES
TC$LOOP  CLC   T#RSFLG,T#REFLG          HAVE ALL FIELDS WHICH EXIST?
         BNE   TC$RET
         LA    R7,T#BASE                POINT TO NEXT ENTRY
         BCT   R6,TC$LOOP
         B     RETZ
TC$RET   LR    R15,R7                   RET @ OF IMCOMPLETE ENTRY
         B     RET
 TITLE 'SALVAGE - HEX DISPLAY ROUTINE'
*    R0  - DATA LENGTH, R1 - DATA ADDRESS
*    FORMATS LINES AND PRINTS THEM.
*
         SPACE 1
         USING HEXDISP,R11
HEXDISP  LR    R9,R1                    COPY DATA ADDRESS
         LR    R8,R0                    COPY LENGTH LEFT
         SR    R7,R7                    INIT OFFSET TO ZERO
         LA    R6,16                    LENGTH LEFT ON LINE (HEX BYTES)
         SPACE 1
HD$LOOP  LTR   R8,R8                    ANY DATA LEFT TO DISPLAY?
         BNP   RETZ                     RETURN IF NO DATA LEFT
         TM    S#GETFLG,S#FATTN         ATTENTION?
         BO    RETM                     RETURN IF ATTENTION
         ST    R7,G#WORK                CONVERT DISPLAY
         UNPK  HD#ADR(7),G#WORK+1(4)    ADDRESS TO HEX;
         TR    HD#ADR,G#HEX
         MVI   HD#ADR+L'HD#ADR,C' '     WIPE OUT GARBAGE BYTE
         LR    R2,R6                    GET MIN(LENGTH LEFT,
         CR    R2,R8                            LENGTH ON LINE)
         BNH   *+6
         LR    R2,R8
         BCTR  R2,0                     GET EX LENGTH
         EX    R2,HD$DMVC               MVC HD#CHAR(0),0(R9)
         UNPK  G#WORK+1(15),HD#CHAR(8)  MAKE 32 HEX CHARS
         UNPK  G#WORK+15(15),HD#CHAR+7(8)
         UNPK  G#WORK+29(5),HD#CHAR+14(3)
         TR    G#WORK+1(32),G#HEX        MAKE REAL HEX
         TR    HD#CHAR,HD#VAL            FIX INVALID CHARS IF ANY
         MVI   HD#OR1,C'|'               ADD OR BARS
         MVI   HD#OR2,C'|'
         IC    R3,HD#LEN(R2)            GET PATTERN EX LEN TO USE
         EX    R3,HD$PATMV              MVC L#D0(0),HD#PAT
         EX    R3,HD$PATTR              TR  L#D0(0),W#WORK
**TEMP   L     R3,P#CARROT              GET CARROT DISPLAY ADDR
         B     HD$NEXT  ** TEMP **
         SR    R3,R7                    GET OFFSET TO CARROT
         BM    HD$NEXT                  BIF CARROT ON PREV LINE
         CR    R3,R2                    CARROT OFFSET :: LINE LEN - 1
         BH    HD$NEXT                  BIF NOT THIS LINE
         SR    R4,R4                    CLEAR FOR IC
         IC    R4,HD#CART(R3)           GET OFFSET FOR CARROT
         LA    R0,C'>'                  ASSUME EVEN ADDR
         N     R3,=F'1'                 TEST EVEN/ODD
         BZ    *+8                      BIF IS EVEN
         LA    R0,C'<'                  ELSE USE ODD CARROT
         STC   R0,HD#LINE(R4)           SET CARROT ON LINE
HD$NEXT  AR    R9,R6                    BUMP DATA PTR
         AR    R7,R6                    AND DISPLAY ADDR
         SR    R8,R6                    DCR DATA LEFT
         BAL   R10,S$PRINT              PRINT COMPLETE LINE
         B     HD$LOOP                  AND CONTINUE
         SPACE 1
HD$DMVC  MVC   HD#CHAR(0),0(R9)         * EXECUTED *
HD$VALTR TR    HD#CHAR(0),HD#VAL        * EXECUTED *
HD$PATMV MVC   HD#D0(0),HD#PAT          * EXECUTED *
HD$PATTR TR    HD#D0(0),G#WORK          * EXECUTED *
         SPACE 1
*                0 1 2 3 4 5 6 7 8 9 A B C D E F
HD#VAL   DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'  0
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'  1
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'  2
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'  3
         DC    X'404B4B4B4B4B4B4B4B4B4A4B4C4D4E4F'  4
         DC    X'504B4B4B4B4B4B4B4B4B5A5B5C5D5E5F'  5
         DC    X'604B4B4B4B4B4B4B4B4B6A6B6C6D6E6F'  6
         DC    X'4B4B4B4B4B4B4B4B4B797A7B7C7D7E7F'  7
         DC    X'4B8182838485868788894B4B4B4B4B4B'  8
         DC    X'4B9192939495969798994B4B4B4B4B4B'  9
         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'  A
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'  B
         DC    X'4BC1C2C3C4C5C6C7C8C94B4B4B4B4B4B'  C
         DC    X'4BD1D2D3D4D5D6D7D8D94B4B4B4B4B4B'  D
         DC    X'4B4BE2E3E4E5E6E7E8E94B4B4B4B4B4B'  E
         DC    X'F0F1F2F3F4F5F6F7F8F94B4B4B4B4B4B'  F
         SPACE 1
         ORG   LINE
HD#LINE  DC    CL1' '
HD#ADR   DC    CL6' ',CL3' '
HD#D0    DC    CL4' ',CL1' '
HD#D1    DC    CL4' ',CL1' '
HD#D2    DC    CL4' ',CL1' '
HD#D3    DC    CL4' ',CL1' '
         DC    CL2' '
HD#D4    DC    CL4' ',CL1' '
HD#D5    DC    CL4' ',CL1' '
HD#D6    DC    CL4' ',CL1' '
HD#D7    DC    CL4' ',CL1' '
         DC    CL3' '
HD#OR1   DC    CL1' '
HD#CHAR  DC    CL16' '
HD#OR2   DC    CL1' '
         ORG   ,
         SPACE 1
* PATTERN LENGTH-1 TO USE INDEXED BY DATA LEN -1
HD#LEN   DC    AL1(HD#D0+2-HD#D0-1)       0
         DC    AL1(HD#D0+4-HD#D0-1)       1
         DC    AL1(HD#D1+2-HD#D0-1)       2
         DC    AL1(HD#D1+4-HD#D0-1)       3
         DC    AL1(HD#D2+2-HD#D0-1)       4
         DC    AL1(HD#D2+4-HD#D0-1)       5
         DC    AL1(HD#D3+2-HD#D0-1)       6
         DC    AL1(HD#D3+4-HD#D0-1)       7
         DC    AL1(HD#D4+2-HD#D0-1)       8
         DC    AL1(HD#D4+4-HD#D0-1)       9
         DC    AL1(HD#D5+2-HD#D0-1)       A
         DC    AL1(HD#D5+4-HD#D0-1)       B
         DC    AL1(HD#D6+2-HD#D0-1)       C
         DC    AL1(HD#D6+4-HD#D0-1)       D
         DC    AL1(HD#D7+2-HD#D0-1)       E
         DC    AL1(HD#D7+4-HD#D0-1)       F
         SPACE 1
* CARROT POSITION ON LINE INDEXED BY DATA OFFSET ON LINE
HD#CART  DC    AL1(HD#D0-1-HD#LINE)       0
         DC    AL1(HD#D0+4-HD#LINE)       1
         DC    AL1(HD#D1-1-HD#LINE)       2
         DC    AL1(HD#D1+4-HD#LINE)       3
         DC    AL1(HD#D2-1-HD#LINE)       4
         DC    AL1(HD#D2+4-HD#LINE)       5
         DC    AL1(HD#D3-1-HD#LINE)       6
         DC    AL1(HD#D3+4-HD#LINE)       7
         DC    AL1(HD#D4-1-HD#LINE)       8
         DC    AL1(HD#D4+4-HD#LINE)       9
         DC    AL1(HD#D5-1-HD#LINE)       A
         DC    AL1(HD#D5+4-HD#LINE)       B
         DC    AL1(HD#D6-1-HD#LINE)       C
         DC    AL1(HD#D6+4-HD#LINE)       D
         DC    AL1(HD#D7-1-HD#LINE)       E
         DC    AL1(HD#D7+4-HD#LINE)       F
         SPACE 1
* MAPS DSECT OF LINE FOR TR INS
HD#PAT   DC    XL(HD#D7+5-HD#D0)'00'      INIT TO BLANKS
         ORG   HD#PAT
         DC    AL1(01,02,03,04)
         DC    AL1(0)
         DC    AL1(05,06,07,08)
         DC    AL1(0)
         DC    AL1(09,10,11,12)
         DC    AL1(0)
         DC    AL1(13,14,15,16)
         ORG   HD#PAT+HD#D4-HD#D0         TO SECOND HALF
         DC    AL1(17,18,19,20)
         DC    AL1(0)
         DC    AL1(21,22,23,24)
         DC    AL1(0)
         DC    AL1(25,26,27,28)
         DC    AL1(0)
         DC    AL1(29,30,31,32)
         ORG   ,
 TITLE 'SALVAGE - DEVICE TYPE TABLE'
         DC     0D'0'
DEVTAB   DEVICE 2301,02,ALT=0
DEVTABL  EQU    *-DEVTAB
         DEVICE 2311,01,ALT=200
         DEVICE 2314,08,ALT=200
         DEVICE 2305-1,06,ALT=0
         DEVICE 2305-2,07,ALT=0
         DEVICE 3330,09,ALT=404
         DEVICE 3330-1,0D,ALT=808
         DEVICE 3340,0A,ALT=0           STRANGE ALTS/CE
         DEVICE 3350,0B,ALT=555,CE=(1024,1024)
         DEVICE 3375,0C,ALT=0
DEVTABE  DEVICE 3380,0E,ALT=0
         DEVICE UNKNOWN,FF,ALT=0        DEFAULT DEVICE
         SPACE 1
         PRINT NOGEN
         OACREGS ,
*        PRINT GEN
         SPACE 1
CVT      DSECT ,
         CVT
         SPACE 1
         DCBD
         SPACE 1
         IEZDEB
         SPACE 1
UCB      DSECT ,
         IEFUCBOB
         SPACE 1
         END
//*KED.SYSLMOD DD DISP=SHR,DSN=SYS1.OACAPF,SPACE=,UNIT=
//LKED.SYSIN   DD *
  ENTRY ENTRY
  IDENTIFY SALVAGE('CS01431')
  NAME SALVAGE$(R)
//*
//C EXEC PGM=COMPARE,PARM='SALVAGE$,SALVAGE'
//STEPLIB DD DISP=SHR,DSN=SYS5.MSSLOAD
//I1      DD DISP=(SHR,PASS),DSN=&&GOSET
//I2      DD DISP=SHR,DSN=SYS1.OACAPF
//SYSPRINT DD SYSOUT=*
//
