MVSGPSVC TITLE 'MVS/XA GENERAL PURPOSE SVC   -   IGC0025B '
*        PRINT OFF,NOGEN
         MACRO
         PROLOG
*----------------------------------------------------------------------
*                                                                     *
*        NAME..........   MVSGPSVC (MVS GENERAL PURPOSE SVC)          *
*                                                                     *
*        FUNCTION......   MULTIFUCTION TYPE-3 USER SVC                *
*                         (SEE DESCRIPTION BELOW)                     *
*                                                                     *
*        ATTRIBUTES....   REENTRANT REUSEABLE                         *
*                                                                     *
*        MODE:.........   RMODE=24  AMODE=31   (MVS/XA COMPATIBLE)    *
*                                                                     *
*        DEPENDENCIES..   "IOSVSUCB" UCB SCAN SERVICE ROUTINE OF      *
*                         EITHER MVS SP1.3 OR SP2.1 (AND HIGHER)      *
*                         THIS DEPENDENCY MAY BE ELIMINATED FOR       *
*                         SYSTEMS PRIOR TO SP1.3 BY DROPPING THE      *
*                         UCB SCAN ROUTINE IF NOT NEEDED.             *
*                                                                     *
*----------------------------------------------------------------------
         SPACE 1
***********************************************************************
*                                                                     *
*        DESCRIPTION:                                                 *
*              PERFORM SEVERAL FUNCTIONS AS AN SVC WHICH ARE          *
*              CONTROLLED BY ENTRY POINT INDICATOR PASSED IN          *
*              R15.  THE TYPE OF FUNCTIONS CONTAINED HEREIN           *
*              ARE THOSE PECULIAR TO EITHER THE MACHINE OR THE        *
*              OPERATING SYSTEM WHICH HAVE A POSSIBILITY OF           *
*              FOR CHANGE.  BY INCLUDING THSES TYPE OF FUNCTIONS      *
*              IN A CENTRAL PLACE (HERE), WHEN CHANGES ARE REQUIRED   *
*              THEY MAY BE GLOBALLY CHANGED VIA A SINGLE CHANGE       *
*              (HERE).                                                *
*                                                                     *
*              ENTRY CODES ARE AS FOLLOWS:                            *
*              R15=1  - USER SVC TEST VIA LOAD AND BRANCH             *
*              R15=2  - DATE, DAY OF WEEK, TIME                       *
*              R15=3  - SET APF AUTHORIZATION                         *
*              R15=4  - RESET APF AUTHORIZATION                       *
*              R15=5  - SMFWTM                                        *
*              R15=6  - UCB LOOKUP (MVS/XA COMPATIBLE)                *
*              R15=7  - JCT LOOKUP (CURRENT ASID ONLY), TSUID INFO    *
*              R15=8  - JES JOBID ADDRESS                             *
*              R15=9  - JES INPUT DEVICE ADDRESS                      *
*              R15=10 - FULL SCREEN TPUT CLEAR                        *
*              R15=11 - CALENDAR TO JULIAN DATE CONVERT (FWW)         *
*              R15=12 - JULIAN TO CALENDAR DATE CONVERT (FWW)         *
*              R15=13 - JULIAN DATE DIFFERENCE CALCULATION (FWW)      *
*              R15=14 - UNUSED AT THIS TIME (A B)                     *
*              R15=15 - UNUSED AT THIS TIME (TEMP USE FOR RACF)       *
*              R15=16 - UNUSED AT THIS TIME (OPEN)                    *
*              R15=17 - UNUSED AT THIS TIME (OPEN)                    *
*              R15=18 - UNUSED AT THIS TIME (OPEN)                    *
*              R15=19 - UNUSED AT THIS TIME (OPEN)                    *
*                                                                     *
*        NOTE.                                                        *
*              BECAUSE WE ARE AN SVC, THERE IS NO NEED TO SAVE        *
*              THE USERS REGISTER (THE SYSTEM HAS ALREADY SAVED       *
*              THEM).  ALSO, CERTAIN REGISTERS HAVE BEEN PRIMED       *
*              FOR US AS FOLLOWS:                                     *
*                                                                     *
*              R0  = SAME AS WHEN SVC WAS ISSUED (AT ENTRY TO EXIT)   *
*              R1  = SAME AS WHEN SVC WAS ISSUED (AT ENTRY TO EXIT)   *
*              R2  = UNPREDICTABLE                                    *
*              R3  = CVT ADDRESS                                      *
*              R4  = TCB ADDRESS(CURRENT)                             *
*              R5  = SVRB ADDRESS (OURS)                              *
*              R6  = ENTRY POINT (OUR BASE REG)                       *
*              R7  = ASCB ADDRESS (CURRENT)                           *
*              R8  = UNPREDICTABLE                                    *
*              R9  = UNPREDICTABLE                                    *
*              R10 = UNPREDICTABLE                                    *
*              R11 = UNPREDICTABLE                                    *
*              R12 = UNPREDICTABLE                                    *
*              R13 = SAME AS WHEN SVC WAS ISSUED (AT ENTRY TO EXIT)   *
*              R14 = RETURN REGISTER (TO SVC RETURN HANDLER)          *
*              R15 = SAME AS WHEN SVC WAS ISSUED (AT ENTRY TO EXIT)   *
*                                                                     *
*              THIS ROUTINE IS LINKEDITED AS AN SVC (TYPE 3) TO       *
*              BE INCLUDED VIA 'MLPA' AT IPL TIME.  BECAUSE THIS      *
*              IS AN SVC, IT MUST REMAIN RE-ENTERABLE.                *
*                                                                     *
***********************************************************************
         MEND
         MACRO
         JCTGET
.*
.*       FIND OUR JCT (RELEASE DEPENDENT) DKM
.*
         GBLA  &I
&I       SETA  &SYSNDX
.*
         USING JESCT,R2
         USING SSCT,R5
         USING SSVT,R8
         USING SJB,R11
         SPACE 1
         LA    R15,16              ASSUME BADNESS, RC=16
         L     R2,CVTJESCT         ADDR OF JESCT FROM CVT
         CLC   JESCTID,=CL4'JEST'  VALIDATE CONTROL BLOCK
         BNER  R14                 INVALID, ERROR RETURN
         SPACE 1
         ICM   R5,15,JESSSCT       ADDR OF SSCT (1ST SSCT FROM JESCT)
JCT@&I   DS    0H
         BZR   R14                 INVALID ERROR RETURN, RC=16
         SPACE 1
         CLC   SSCTID,=CL4'SSCT'   VALIDATE CONTROL BLOCK
         BNER  R14                 INVALID, ERROR RETURN, RC=16
         CLC   SSCTSNAM,=CL4'JES2' CHECK FOR MATCHING SUBSYSTEM NAME
         BE    JCT#&I              YES, CONTINUE
         SPACE 1
         ICM   R5,15,SSCTSCTA      GET NEXT SUBSYSTEM SSCT
         B     JCT@&I              CHECK NEXT
         SPACE 3
JCT#&I   DS    0H
         ICM   R8,15,SSCTSUS2      ADDRESS OF SSVT FROM SSCT
         BZR   R14                 INVALID ERROR RETURN, RC=16
         USING HCCT,R8
         SPACE 1
         LA    R15,4               LIGHTEN UP A BIT ...
         ICM   R9,15,CCTHASP       CHECK IF HASP IS STILL UP
         BNZR  R4                  RETURN CODE = 4, EXIT
         ICM   R9,15,CCTHAVT       ADDRESS OF JES2 HAVT
         BNPR  R4                  NOT THERE, HASP NOT UP, RC=4
         USING PSA,R0              PSA ADDRESS
         L     R7,PSAAOLD          ADDRESS OF CURRENT ASCB
         LH    R15,ASCBASID        GET ASID FROM ASCB
         SLL   R15,2               MULTIPLY BY 4
         AR    R9,R15              ADDRESS OF OUR HAVT ENTRY
         SPACE 1
* ------------------------------------------------------------------- *
*        CHAIN TO THE SJB VIA THE HASB                                *
* ------------------------------------------------------------------- *
         ICM   R11,15,0(R9)        ADDRESS OF HASB FROM JES2 HAVT
         BNPR  R4                  NOT THERE, SPECIAL SYSTEM TASK
         USING HASB,R11            ESTABLISH ADDRESSABILITY
         CLC   HSBID,=C'HASB'      VALIDATE HASB
         BNER  R4                  INVALID, RETURN
         ICM   R11,15,HSBSJB       ADDRESS OF SJB FROM HASB
         DROP  R11                 DROP USING ON HSB
         BNPR  R4                  NOT THERE, SPECIAL SYSTEM TASK
         USING SJB,R11             ESTABLISH ADDRESSABILITY
         SPACE 1
         CLC   SJBID,=CL4'SJB'     VALIDATE SJB CONTROL BLOCK
         BNER  R14                 INVALID, RETURN
         SPACE 1
         ICM   R15,15,SJBSJB       ADDRESS OF DEPENDENT SJB
         BZ    JCTNB&I             NONE, NOT BATCH
         LR    R11,R15             INITIATOR'S DEPENDENT SJB
         SPACE 1
JCTNB&I  DS    0H
         L     R10,SJBJCT          JOBS JCT
         LA    R15,16              ONE MORE VALIDATION ...
         CLC   JCTID,=CL4'JCT '    VALID JCT??
         BNER  R14                 NO? OUTTA HERE...
         SR    R15,R15             SET HAPPY CAMPER MODE
         MEND
         EJECT
***********************************************************************
*                                                                     *
*        INITIAL ENTRY POINT (DRIVER FOR SUBROUTINES).                *
*        THIS ROUTINE CHECKS FOR A VALID ENTRY POINT INDICATOR        *
*        PASSED IN R15.  IF IT IS VALID, R6 IS SET TO THE             *
*        APPROPRIATE ENTRY POINT ADDRESS AND CONTROL IS PASSED        *
*        TO TO THE ROUTINE.  IF IT IS INVALID, IT MERELY RETURNS      *
*        TO THE CALLER VIA R14.                                       *
*                                                                     *
*        DATA AREAS REQUIRED BY A SINGLE ROUTINE SHOULD BE INCLUDED   *
*        AT THE END OF THAT ROUTINE (FOR ADDRESSABILIY REASONS).      *
*        THOSE THAT ARE USED BY MULTIPLE ROUTINES SHOULD BE INCLUDED  *
*        AT THE END OF THE LAST ROUTINE TO USE IT (OR AT THE END      *
*        OF THE CODE).  BY DOING THIS, EACH ROUTINE IS ALMOST         *
*        INDEPENDENT OF OTHER FUNCTIONS AND THUS MAY BE REMOVED       *
*        OR OTHERS ADDED WITH LITTLE CONCERN FOR DUPLICATION AND/OR   *
*        RELATIONAL DEPENDENCIES.                                     *
*                                                                     *
***********************************************************************
MVSGPSVC AMODE 31
MVSGPSVC RMODE ANY
MVSGPSVC CSECT
         USING MVSGPSVC,R6         USE R6 FOR CSECT BASE REGISTER
         USING CVT,R3    PERPETUAL USE R3 FOR CVT DSECT BASE REG
         USING TCB,R4    PERPETUAL USE R4 FOR TCB DSECT BASE REG
         USING ASCB,R7   PERPETUAL USE R7 FOR ASCB DSECT BASE REG
         LTR   R15,R15             CHECK FOR POSITIVE EP INDICATOR
         BNP   NOP                 IF NOT POSITIVE, GO TO NOP
         LA    R2,EPCNT            LOAD R2 WITH NO OF VALID EP'S
         CR    R15,R2              CHECK FOR VALID EP INDICATOR
         BH    NOP                 IF INVALID, GO TO NOP
         SLL   R15,2               MULTIPLY EP INDICATOR BY 4
         L     R6,EPTABLE-4(R15)   SET R6=A(ROUTINE ENTRY POINT)
         BR    R6                  GO TO APPROPRIATE ENTRY POINT
NOP      BR    R14                 RETURN TO SVC HANDLER
*
EPTABLE  DC    A(SVCTEST)      1   SVCTEST ROUTINE
         DC    A(TIME)         2   TIME ROUTINE
         DC    A(AUTHSET)      3   AUTHSET ROUTINE
         DC    A(AUTHRSET)     4   AUTHRSET ROUTINE
         DC    A(SMFWTM)       5   SMFWTM ROUTINE
         DC    A(UCBLOOK)      6   UCBLOOK ROUTINE
         DC    A(JCTLOOK)      7   JCTLOOK ROUTINE
         DC    A(JESJOBID)     8   JESJOBID ROUTINE
         DC    A(JESINDEV)     9   JESINDEV ROUTINE
         DC    A(CLEAR)       10   TSO CLEAR SCREEN ROUTINE
         DC    A(CALJUL)      11   DATE CONVERSION ROUTINE
         DC    A(JULCAL)      12   DATE CONVERSION ROUTINE
         DC    A(JULDIF)      13   DATE DIFFERENCE ROUTINE
         DC    A(NOP)         14   (UNUSED AT THIS TIME)
         DC    A(XACF)        15   (UNUSED AT THIS TIME)
         DC    A(NOP)         16   (UNUSED AT THIS TIME)
         DC    A(NOP)         17   (UNUSED AT THIS TIME)
         DC    A(NOP)         18   (UNUSED AT THIS TIME)
         DC    A(NOP)         19   (UNUSED AT THIS TIME)
EPCNT    EQU   (*-EPTABLE)/4       NUMBER OF VALID ENTRY POINTS
         LTORG
         DROP  R6                  DROP USE OF R6 BASE REGISTER
***********************************************************************
*                                                                     *
*        THE FOLLOWING ARE THE MVS GP SVC SUBROUTINES                 *
*                                                                     *
***********************************************************************
         EJECT
***********************************************************************
*                                                                     *
*        THIS ROUTINE SETS UP THE ENVIRONMENT TO TEST USER            *
*        WRITTEN SVC'S.  IN ORDER TO USE THIS FUNCTION, A DRIVER      *
*        PROGRAM MUST BE USED WHICH WILL POINT R1 AT A FOUR WORD      *
*        LIST WHICH CONTAINS THE ENTRY POINT OF THE PRELOADED SVC     *
*        MODULE FOLLOWED BY VALUES FOR R15/0/1 AS THEY SHOULD BE      *
*        AT ENTRY TO THE SVC.  THIS ROUTINE MERELY LOADS R6 WITH      *
*        WORD0, R15 WITH WORD1, R0 WITH WORD2, R1 WITH WORD3, AND     *
*        BRANCHES ON R6.                                              *
*                                                                     *
*        REGISTERS UPON ENTRY.                                        *
*              R0  = IGNORED                                          *
*              R1  = ADDRESS OF 4 WORD AREA, FULLWORD ALLIGNED        *
*                    A(BASE) A(PARM-R15) A(PARM-R1) A(PARM-R0)        *
*              R15 = 1                                                *
*                                                                     *
*        REGISTERS UPON RETURN.                                       *
*              R0  = DETERMINED BY SVC UNDER TEST                     *
*              R1  = DETERMINED BY SVC UNDER TEST                     *
*              R15 = DETERMINED BY SVC UNDER TEST                     *
*                                                                     *
***********************************************************************
SVCTEST  DS    0H                  SVCTEST ENTRY
         USING SVCTEST,R6          BASE FOR SUBROUTINE
         USING PSCB,R10            ESTABLISH ADDRESSABILITY
         USING IEZJSCB,R11         ESTABLISH ADDRESSABILITY
         L     R11,TCBJSCB         GET JSCB ADDRESS
         ICM   R15,15,ASCBTSB      GET TSB ADDRESS
         BZ    SVCTERR             NO TSB = BATCH, NOT SUPPORTED
         L     R10,JSCBPSCB        GET PSCB ADDRESS
         TM    PSCBATR1,X'80'      CHECK FOR OPER CAPABILITY
         BZ    SVCTERR             NO, INVALID REQUEST
         L     R6,0(R1)            SET UP BASE FOR TEST ROUTINE
         LM    R15,R1,4(R1)        SET UP R15,R0,R1 FOR TEST ROUTINE
         BR    R6                  BRANCH TO PRELOADED SVC
SVCTERR  L     R15,=F'-1'          SET RETURN CODE
         LR    R0,R15              COPY TO R0
         LR    R1,R15              AND  TO R1
         BR    R14                 AND GIVE IT TO HIM
         LTORG
         DROP  R10                 DROP DSECT ADDRESSABILITY
         DROP  R11                 DROP DSECT ADDRESSABILITY
         DROP  R6                  DROP USE OF R6 BASE REGISTER
         EJECT
***********************************************************************
*                                                                     *
*        THIS ROUTINE SUPPLIES THE REQUESTOR WITH THE DATE, DAY       *
*        OF WEEK, AND TIME.  IF THE CURRENT TIME IS NEEDED, REG1      *
*        UPON ENTRY MUST BE A POSITIVE ADDRESS AND POINT TO A 5       *
*        WORD AREA ALLIGNED ON A DOUBLEWORD.  IF TIME IS TO BE        *
*        OBTAINED FROM A PREVIOUS STCK INSTRUCTION, REG1 UPON         *
*        ENTRY MUST BE NEGATIVE AND ITS COMPLIMENT MUST POINT TO      *
*        A 7 WORD AREA ALLIGNED ON A DOUBLEWORD, THE FIRST 2          *
*        WORDS CONTAINING THE STCK DATA.  THE STORAGE AREA            *
*        POINTED TO BY REG1 IS CHECKED FOR VALIDITY AND               *
*        ALLIGNMENT.                                                  *
*                                                                     *
*        REGISTERS UPON ENTRY.                                        *
*        CURRENT TIME REQUEST.                                        *
*              R0  = UNUSED                                           *
*              R1  = ADDRESS OF 5 WORD AREA, DOUBLEWORD ALLIGNED      *
*              R15 = 2                                                *
*        STCK DATA SUPPLIED.                                          *
*              R0  = UNUSED                                           *
*              R1  = COMPLIMENT OF ADDRESS OF 7 WORD AREA,            *
*                    DOUBLEWORD ALLIGNED                              *
*              R15 = 2                                                *
*                                                                     *
*        REGISTERS UPON RETURN.                                       *
*        AREA VALID AND PROPERLY ALLIGNED.                            *
*              R0  = UNCHANGED                                        *
*              R1  = UNCHANGED                                        *
*              R15 = 0                                                *
*              RETURN AREA.                                           *
*                   +0 = MM/DD/YY    DATE                             *
*                   +8 = X           DAY OF WEEK OFFSET (0=MONDAY)    *
*                   +9 = HH.MM.SS.TH TIME                             *
*        AREA NOT VALID OR NOT PROPERLY ALLIGNED.                     *
*              R0  = UNCHANGED                                        *
*              R1  = UNCHANGED                                        *
*              R15 = 8                                                *
*              RETURN AREA.                                           *
*                   UNCHANGED                                         *
*                                                                     *
***********************************************************************
TIME     DS    0H                  TIME ENTRY
         USING TIME,R6             BASE FOR SUBROUTINE
         USING RBBASIC,R5          ESTABLISH ADDRESSABILITY
         USING TWORK,R15           ESTABLISH ADDRESSABILITY
TIME1000 LR    R8,R1               SET R8=A(PASSED AREA)
         LR    R15,R1              SET R15=A(ANSWER AREA)
         LTR   R8,R8               CHECK FOR NEGATIVE
         BNM   TIME1100            IF NOT NEGATIVE, GO TO TIME1100
         LCR   R8,R8               SET ADDRESS POSITIVE
         LA    R15,8(R8)           SET R15=A(ANSWER AREA)
TIME1100 SR    R9,R9               RESET R9 FOR DOUBLE SHIFT
         SRDL  R8,3                SHIFT FOR ALLIGNMENT TEST
         LTR   R9,R9               CHECK R9 FOR ANY BITS ON
         BNZ   TIMERT08            IF ANY ON, NOT ALLIGNED, GO TO 8 RT
         SRDL  R8,29               SHIFT REST FOR USE AS ADDRESS
         L     R5,RBLINK           SET R5=A(PREVIOUS RB)
         IC    R8,RBOPSW+1         SET R9=REQUESTOR'S PROTECT KEY
         SRL   R8,3                SHIFT OUT UNUSED BITS
         BAL   R2,TIME1900         LINK TO VALIDITY CHECK ROUTINE
         LA    R9,23(R15)          SET R8=A(LAST BYTE IN AREA)
         BAL   R2,TIME1900         LINK TO VALIDITY CHECK ROUTINE
         B     TIME2000            GO TO TIME2000
TIME1900 LRA   R9,0(R9)            LOAD REAL ADDRESS INTO R9
         BNZ   TIMERT08            IF INVALID, GO TO 8 RETURN
         LTR   R8,R8               CHECK FOR REQUESTOR IN KEY0
         BZR   R2                  IF KEY0, RETURN TO INVOKING AREA
         SRL   R9,4                SHIFT TO ZERO UNWANTED REAL BITS
         SLL   R9,4                RESTORE WITH BITS 28-31=0
         SR    R10,R10             RESET R10 FOR SUBSEQUENT ISK
         ISK   R10,R9              INSERT STORAGE KEY INTO R10
         SRL   R10,3               SHIFT OUT UNUSED BITS FOR COMPARE
         CR    R8,R10              CHECK FOR KEY MATCH
         BER   R2                  IF EQUAL, RETURN TO INVOKING AREA
         B     TIMERT08            IF NO MATCH, GO TO 8 RETURN
TIME2000 LCR   R8,R1               SET R8=0-R1
         BNM   TIME2110            IF NOT NEG, R1 NEG, GO TO TIME2110
TIME2100 STCK  TW00L08             STORE CLOCK IN TW00L08
         L     R8,CVTTZ            SET R8=CVTTZ, TIME ZONE DIFFERENTIAL
         B     TIME2120            GO TO TIME2120
TIME2110 MVC   TW00L08,0(R8)       MOVE PASSED STCK DATA TO TW00L08
         SR    R8,R8               SET R8=0, TIME ZONE DIFFERENTIAL
TIME2120 A     R8,TW00L04          ADD STCK DATA WORD 0 TO R8
         L     R9,TW04L04          SET R9=STCK DATA WORD 1
         SRDL  R8,12               SET R8,R9=TIME IN MICROSECONDS
         AL    R9,CTIF5000         ADD 5000 MSECS FOR ROUNDING
         BC    12,TIME2130         IF NO CARRY, GO TO TIME2130
         AH    R8,CTIH0001         ADD 1 TO R8 FOR CARRY
TIME2130 D     R8,CTIF060M         SET R8=REM MSECS, R9=MINS
         SR    R10,R10             RESET R10 FOR SUBSEQUENT DIVIDE
         LR    R11,R8              SET R8=REM MSECS
         D     R10,CTIF010K        SET R11=HSECS
         CVD   R11,TW00L08         CONVERT HSECS TO DECIMAL
         UNPK  TW16L04,TW00L08     UNPACK INTO BYTE 16
         MVC   TW15L02,TW16L02     MOVE SECS TO ANSWER AREA
         SR    R8,R8               RESET R8 FOR SUBSEQUENT DIVIDE
         D     R8,CTIF0060         SET R8=REM MINS, R9=HRS
         CVD   R8,TW00L08          CONVERT MINS TO DECIMAL
         UNPK  TW12L02,TW00L08     UNPACK MINS INTO ANSWER AREA
         SR    R8,R8               RESET R8 FOR SUBSEQUENT DIVIDE
         D     R8,CTIF0024         SET R8=REM HRS, R9=DAYS
         CVD   R8,TW00L08          CONVERT HRS TO DECIMAL
         UNPK  TW09L02,TW00L08     UNPACK HRS INTO ANSWER AREA
TIME2200 SR    R10,R10             RESET R10 FOR SUBSEQUENT DIVIDE
         LR    R11,R9              SET R11=DAYS
         D     R10,CTIF0007        SET R10=DAY OF WEEK OFFSET
         STC   R10,TW08L01         SAVE BINARY OFFSET IN ANSWER AREA
TIME2300 SH    R9,CTIH0365         SUBTRACT 365 DAYS FOR 1900
         BNM   TIME2310            IF NOT NEG, GO TO TIME2310
         AH    R9,CTIH0365         ADD 365 DAYS FOR 1900
         SLDL  R8,32               SET R8=JDAY-1, R9=00, YEAR
         B     TIME2340            GO TO TIME2340
TIME2310 SR    R8,R8               RESET R8 FOR SUBSEQUENT DIVIDE
         D     R8,CTIF1461         SET R8=JDAY (4YR), R9=4YR COUNT-1
         SLL   R9,2                SET R9=YR-1
         LA    R9,1(R9)            SET R9=YR
         LA    R12,3               SET R12=3, BCT COUNT
TIME2320 SH    R8,CTIH0365         SUBTRACT 1 YR'S DAYS
         BM    TIME2330            IF NEG, GO TO TIME2330
         LA    R9,1(R9)            INCREMENT R9, YR
         BZ    TIME2340            IF R8=0, GO TO TIME2340
         BCT   R12,TIME2320        GO BACK TO TIME2320 AT MOST 2 TIMES
         B     TIME2340            AFTER 2ND TIME, GO TO TIME2340
TIME2330 AH    R8,CTIH0365         ADD TO MAKE NEG POS
TIME2340 LA    R8,1(R8)            MAKE JDAY RELATIVE TO 1
         CVD   R9,TW00L08          CONVERT YR TO DECIMAL
         UNPK  TW06L02,TW06L02     UNPACK YEAR
         ICM   R11,3,TW06L02       SAVE UNPACKED YR IN R11
         LA    R12,TDTBLNLP        SET R12=A(NON-LEAP YEAR TABLE)
         SLL   R9,30               SHIFT OUT BITS 0-29
         LTR   R9,R9               CHECK FOR ANY REMAINING BITS
         BNZ   TIME2350            IF ANY LEFT, GO TO TIME2350
         LA    R12,TDTBLLP         SET R12=A(LEAP YEAR TABLE)
TIME2350 SR    R10,R10             RESET R10 FOR SUBSEQUENT IC'S
TIME2360 IC    R10,0(R9,R12)       SET R10=DA/MO FROM TABLE
         LA    R9,1(R9)            INCREMENT R9, MONTH
         SR    R8,R10              SUBTRACT DA/MO FROM R8 DA
         BP    TIME2360            IF STILL POS, GO TO TIME2360
         AR    R8,R10              ADD DA/MO TO MAKE POS
         CVD   R8,TW00L08          CONVERT DA TO DECIMAL
         UNPK  TW06L02,TW06L02     UNPACK DA
         ICM   R11,12,TW06L02      SAVE UNPACKED DA IN R11
         CVD   R9,TW00L08          CONVERT MO TO DECIMAL
         UNPK  TW00L02,TW06L02     UNPACK MO INTO ANSWER AREA
         STCM  R11,12,TW03L02      STORE DA INTO ANSWER AREA
         STCM  R11,3,TW06L02       STORE YR INTO ANSWER AREA
         MVZ   TW01L19,TW00L19     MOVE ALL F ZONES TO ANSWER AREA
         MVI   TW02L01,C'/'        MOVE '/' BETWEEN DATE MM DD
         MVI   TW05L01,C'/'        MOVE '/' BETWEEN DATE DD YY
         NI    TW08L01,X'0F'       AND OFF F ZONE
         MVI   TW11L01,C'.'        MOVE '.' BETWEEN TIME HH MM
         MVI   TW14L01,C'.'        MOVE '.' BETWEEN TIME MM SS
         MVI   TW17L01,C'.'        MOVE '.' BETWEEN TIME SS TH
TIMERT00 SR    R15,R15             SET RETURN CODE=0
         BR    R14                 RETURN TO SVC HANDLER
TIMERT08 LA    R15,8               SET RETURN CODE=8
         BR    R14                 RETURN TO SVC HANDLER
CTIF0007 DC    F'7'
CTIF0024 DC    F'24'
CTIF0060 DC    F'60'
CTIF1461 DC    F'1461'
CTIF5000 DC    F'5000'
CTIF010K DC    F'10000'
CTIF060M DC    F'60000000'
CTIH0001 DC    H'1'
CTIH0365 DC    H'365'
TDTBLLP  DC    AL1(31,29,31,30,31,30,31,31,30,31,30,31)
TDTBLNLP DC    AL1(31,28,31,30,31,30,31,31,30,31,30,31)
         LTORG
         DROP  R5                  DROP USE OF R5 DSECT BASE REGISTER
         DROP  R6                  DROP USE OF R6 BASE REGISTER
         DROP  R15                 DROP USE OF R15 DSECT BASE REGISTER
         EJECT
***********************************************************************
*                                                                     *
*        THIS ROUTINE WILL PROVIDE MODESET AUTHORIZATION.  IT IS      *
*        THEN THE USER'S RESPONSIBILITY TO ISSUE A MODESET MACRO      *
*        IN ORDER TO GAIN SUPERVISOR STATE OR KEY ZERO.  UPON         *
*        ENTRY REGISTER ONE MUST POINT TO THE CHARACTERS 'AUTH'.      *
*        FOR TIME SHARING USERS ONLY, THE ISSUER OF THE SVC           *
*        (CALLER) MUST EITHER HAVE OPER CAPABILITY OR RESIDE IN       *
*        THE LINK PACK AREA (OR MLPA).  THIS IS TO INSURE THAT        *
*        TSO USERS DO NOT ATTEMPT TO VIOLATE OUR SECURITY BY          *
*        INVOKING EITHER DIRECTLY OR UNDER TEST.                      *
*                                                                     *
*        REGISTERS UPON ENTRY.                                        *
*              R0  = UNUSED                                           *
*              R1  = ADDRESS 'AUTH' LITERAL                           *
*              R15 = 3                                                *
*                                                                     *
*        REGISTERS UPON RETURN.                                       *
*        R1 UPON ENTRY ==> C'AUTH' AND (USER HAS OPER OR NON TSO)     *
*              R0  = UNCHANGED                                        *
*              R1  = UNCHANGED                                        *
*              R15 = 0                                                *
*              JSCBOPTS, BIT 7 SET                                    *
*        R1 UPON ENTRY NOT ==> C'AUTH' OR INVALID TSO USER            *
*              R0  = UNCHANGED                                        *
*              R1  = UNCHANGED                                        *
*              R15 = 8                                                *
*              VIOLATION MESSAGE WRITTEN TO OPERATOR                  *
*                                                                     *
***********************************************************************
AUTHSET  DS    0H                  AUTHSET ENTRY
         USING WTO,R1              ESTABLISH ADDRESSABILITY
         USING RBBASIC,R5          ESTABLISH ADDRESSABILITY
         USING AUTHSET,R6          BASE FOR SUBROUTINE
         USING PSCB,R10            ESTABLISH ADDRESSABILITY
         USING IEZJSCB,R11         ESTABLISH ADDRESSABILITY
         USING TIOT,R12            ESTABLISH ADDRESSABILITY
         LR    R8,R0               SAVE R0 IN R8
         LR    R9,R1               SAVE R1 IN R9
         CLC   AUTH,0(R1)          CHECK FOR R1 POINTING AT 'AUTH'
         BNE   AUTSRT08            IF NOT, GO TO 8 RETURN
         L     R11,TCBJSCB         SET R11=A(JSCB)
         ICM   R15,15,ASCBTSB      SET R15=A(TSB)
         BZ    AUTSRT00            IF NOT TSO, GO TO 0 RETURN
         L     R10,JSCBPSCB        SET R10=A(PSCB)
         TM    PSCBATR1,X'80'      CHECK FOR OPER CAPABILITY
         BO    AUTSRT00            IF OPER, GO TO 0 RETURN
         L     R5,RBLINK           SET R5=A(PREVIOUS RB)
         L     R15,RBOPSW+4        GET INTERUPT ADDRESS FROM RB PSW
         TM    CVTDCB,X'80'        IS THIS MVS XA ?
         BO    AUTCHK01            YES, CHECK ADDRESS
AUTCHK00 LA    R15,0(R15)          CLEAR HIGH ORDER BYTE
         C     R15,CVTSHRVM        CHECK FOR REQ FROM CSA OR ABOVE
         BL    AUTSRT08            BELOW CSA, INVALID REQUEST
         B     AUTSRT00            ABOVE, ALLOW REQUEST
AUTCHK01 TM    RBOPSW+4,X'80'      EXECUTING IN 31 BIT MODE?
         BZ    AUTCHK00            NO, CHECK ADDRESS
         N     R15,MASK31          STIP HIGH ORDER BIT
         C     R15,CVTSHRVM        CHECK FOR REQ FROM CSA OR ABOVE
         BL    AUTSRT08            BELOW CSA, INVALID REQUEST
*        L     R10,CVTVSTGX        ADDRESS OF XA STG MAP
         L     R10,X'4AC'(R3)         ( COMPATIBILITY WITH SP1.3 )
*        USING CVTVSTGX,R10        ADDRESSABILITY
*        C     R15,CVTEMLPE        CHECK IF BEYOND EXTENDED MLPA
         C     R15,X'4C'(R10)         ( COMPATIBILITY WITH SP1.3 )
         BH    AUTSRT08            ABOVE EXTENDED MLPA, INVALID REQ
AUTSRT00 OI    JSCBOPTS,X'01'      SET MODESET AVAILABLE BIT
         SR    R15,R15             SET R15=0, RETURN CODE
         BR    R14                 RETURN TO SVC HANDLER
AUTSRT08 LA    R0,256              SET R0=256, GETMAIN LENGTH
         GETMAIN R,LV=(0)          GET STORAGE FOR WTO
         LR    R2,R1               SAVE AREA ADDRESS IN R2
         MVC   WTO(CAUWTOLN),CAUWTO    MOVE WTO DATA TO GOTTEN AREA
         L     R12,TCBTIO          SET R12=A(TIOT)
         MVC   WTOMSG+30(8),TIOCNJOB   MOVE JOBNAME TO WTOMSG
         WTO   MF=(E,(1))          ISSUE WTO
         LA    R0,256              SET R0=256, FREEMAIN LENGTH
         LR    R1,R2               SET R1=A(GOTTEN AREA)
         FREEMAIN R,LV=(0),A=(1)   FREE GOTTEN STORAGE
         LR    R0,R8               RESTORE ORIGINAL R0 FROM R8
         LR    R1,R9               RESTORE ORIGINAL R1 FROM R9
         LA    R15,8               SET R15=8, RETURN CODE
         BR    R14                 RETURN TO SVC HANDLER
CAUWTO   DC    0F'0',AL2(CAUWTOLN-4),XL2'8000' TEXT LENGTH, MCS CODES
         DC    CL50'SECURITY VIOLATION ATTEMPT BY XXXXXXXX - NOTIFY TE'
         DC    CL15'CHNICAL SUPPORT'
         DC    XL4'4000C080'       DESCRIPTOR CODES, ROUT CODES
CAUWTOLN EQU   *-CAUWTO
AUTH     DC    CL4'AUTH'
         DS    0F
MASK31   DC    X'7FFFFFFF'
MVSGPSVC CSECT
         LTORG
         DROP  R1                  DROP USE OF R1 BASE REGISTER
         DROP  R5                  DROP USE OF R5 BASE REGISTER
         DROP  R6                  DROP USE OF R6 BASE REGISTER
         DROP  R10                 DROP USE OF R10 BASE REGISTER
         DROP  R11                 DROP USE OF R11 BASE REGISTER
         DROP  R12                 DROP USE OF R12 BASE REGISTER
         EJECT
***********************************************************************
*                                                                     *
*        THIS ROUTINE WILL DISALLOW MODESET AUTHORIZATION.            *
*                                                                     *
*        REGISTERS UPON ENTRY.                                        *
*              R0  = UNUSED                                           *
*              R1  = UNUSED                                           *
*              R15 = 4                                                *
*                                                                     *
*        REGISTERS UPON RETURN.                                       *
*              R0  = UNCHANGED                                        *
*              R1  = UNCHANGED                                        *
*              R15 = 0                                                *
*              JSCBOPTS, BIT 7 RESET                                  *
*                                                                     *
***********************************************************************
AUTHRSET DS    0H                  AUTHRSET ENTRY
         USING AUTHRSET,R6         BASE FOR SUBROUTINE
         USING IEZJSCB,R11         ESTABLISH ADDRESSABILITY
         L     R11,TCBJSCB         SET R11=A(JSCB)
         NI    JSCBOPTS,X'FE'      RESET MODESET AVAILABLE BIT
         SR    R15,R15             SET R15=0, RETURN CODE
         BR    R14                 RETURN TO SVC HANDLER
         LTORG
         DROP  R6                  DROP USE OF R6 BASE REGISTER
         DROP  R11                 DROP USE OF R11 BASE REGISTER
         EJECT
***********************************************************************
*                                                                     *
*        THIS ROUTINE ISSUES THE SMFWTM (SMF WRITE MACRO) FOR A       *
*        SMF RECORD POINTED TO BY R1.  IT CAN BE USED BY ANY          *
*        MODULE WITHOUT HAVING TO BE AUTHORIZED TO OBTAIN             *
*        SUPERVISOR MODE.                                             *
*                                                                     *
*        REGISTERS UPON ENTRY.                                        *
*              R0  = UNUSED                                           *
*              R1  = ADDRESS OF SMF RECORD                            *
*              R15 = 5                                                *
*                                                                     *
*        REGISTERS UPON RETURN.                                       *
*              R0  = UNCHANGED                                        *
*              R1  = UNCHANGED                                        *
*              R15 = 0  WRITTEN WITHOUT ERROR                         *
*              R15 = 4  NOT WRITTEN, WOULD NOT FIT IN EMPTY D.S.      *
*              R15 = 8  NOT WRITTEN, RDW LENGTH LESS THAN 18          *
*              R15 = 16 NOT WRITTEN, MAN=NONE OR BOTH D.S. FULL       *
*              R15 = 20 NOT WRITTEN, IEFU83 SUPPRESSED WRITE          *
*                                                                     *
***********************************************************************
SMFWTM   DS    0H                  SMFWTM ENTRY
         USING SMFWTM,R6           BASE FOR SUBROUTINE
         LR    R8,R0               SAVE R0 IN R8
         LR    R9,R1               SAVE R1 IN R9
         SMFWTM (1)                WRITE SMF RECORD POINTED TO BY R1
         LR    R0,R8               RESTORE R0 FROM R8
         LR    R1,R9               RESTORE R1 FROM R9
         BR    R14                 RETURN TO SVC HANDLER
         LTORG
         DROP  R6                  DROP USE OF R6 BASE REGISTER
         EJECT
***********************************************************************
*                                                                     *
*        THIS ROUTINE SUPPLIES THE REQUESTOR WITH THE UCB             *
*        ADDRESS OF THE UCB WHOSE EBCDIC VALUE IS PASSED IN THE       *
*        LOW ORDER THREE BYTES OF R0.                                 *
*                                                                     *
*        REGISTERS UPON ENTRY.                                        *
*              R0  = EBCDIC UCB NAME ('.1A8' = X'..F1C1F8')           *
*              R1  = UNUSED                                           *
*              R15 = 6                                                *
*                                                                     *
*        REGISTERS UPON RETURN.                                       *
*        UCB FOUND.                                                   *
*              R0  = EBCDIC UCB NAME IN LOW ORDER 3 BYTES             *
*              R1  = ADDRESS OF UCB                                   *
*              R15 = 0                                                *
*        UCB NOT FOUND.                                               *
*              R0  = -1                                               *
*              R1  = -1                                               *
*              R15 = 8                                                *
*                                                                     *
***********************************************************************
UCBLOOK  DS    0H                  UCBLOOK ENTRY
         USING UCBLOOK,R6          BASE FOR SUBROUTINE
         USING UCBDSECT,R11        ESTABLISH ADDRESSABILITY
         USING UCBWORK,R13         ESTABLISH ADDRESSABILITY
         LR    R8,R0               SAVE R0 IN R8
         LR    R9,R1               SAVE R1 IN R9
         LR    R12,R14             SAVE R14 IN R12
         LA    R0,UCBWORKE-UCBWORK SET SIZE FOR GETMAIN
         GETMAIN R,LV=(0)          GET SOME STORAGE
         LR    R13,R1              ADDRESS OF UCBWORK TO BASE REG
         XC    UCBWORKS(UCBWORKE-UCBWORK),UCBWORK CLEAR WORK AREA
         LA    R1,UCBWORKS         ADDRESS OF WORK AREA FOR UCB SCAN
         ST    R1,UCBPARML         PLACE INTO PARM LIST
         LA    R1,UCBDEVCL         ADDRESS OF DEVICE CLASS (NULL)
         ST    R1,UCBPARML+4       PLACE INTO PARM LIST
         LA    R1,UCBADDR          ADDRESS OF RETURN FIELD
         ST    R1,UCBPARML+8       PLACE INTO PARM LIST
         OI    UCBPARML+8,128      SET HIGH ORDER BIT
*
*        SCAN EACH UCB VIA IOSVSUCB AND CHECK FOR REQUESTED NAME
*
UCBLOOP  EQU   *
         LA    R1,UCBPARML         PARAMETER LIST FOR IOSUCBSV
         L     R15,CVTUCBSC        UCB SERVICE ROUTINE ADDRESS
         BALR  R14,R15             CALL UCB SERVICE ROUTINE
         LTR   R15,R15             ANY UCB FOUND?
         BNZ   UCBERR              NO, REQUESTED NOT FOUND
         L     R9,UCBADDR          PICK UP UCB ADDR
         CLM   R8,7,13(R9)         RIGHT UCB ?
         BNE   UCBLOOP             NO - CHECK NEXT ENTRY
         SR    R10,R10             FOUND, RESET RETCODE
         B     UCBDONE             AND EXIT
UCBERR   L     R8,=F'-1'           NOT FOUND
         L     R9,=F'-1'           NOT FOUND
         LA    R10,8               NOT FOUND
UCBDONE  LA    R0,UCBWORKE-UCBWORK SET SIZE FOR GETMAIN
         LA    R1,UCBWORK          SET R1=A(GETMAIN AREA)
         FREEMAIN R,LV=(0),A=(1)   FREE GOTTEN STORAGE
         LR    R0,R8               RESTORE ORIGINAL R0 FROM R8
         LR    R1,R9               RESTORE ORIGINAL R1 FROM R9
         LR    R14,R12             RESTORE ORIGINAL R14 FROM R12
         LR    R15,R10             SET R15=RETURN CODE
         BR    R14                 RETURN TO SVC HANDLER
         LTORG
UCBDEVCL DC    XL1'00'             UCB DEVICE CLASS (ALL DEVICES)
UCBWORK  DSECT
UCBSAVE  DS    18F                 REG SAVE AREA FOR IOSVSUCB
UCBADDR  DS    F                   ADDRESS OF RETURNED UCB
UCBPARML DS    A                   IOSVSUCB PARM - ADDR OF UCBWORK
         DS    A                   IOSVSUCB PARM - ADDR OF DEVICE CLASS
         DS    A                   IOSVSUCB PARM - UCB ADDRESS POINTER
         DS    F                   IOSVSUCB RETURNED UCB ADDRESS
UCBWORKS DS    XL100               IOSVSUCB WORK AREA
UCBWORKE EQU   *                   END OF UCBWORK
MVSGPSVC CSECT
         DROP  R6                  DROP USE OF R6 BASE REGISTER
         DROP  R11                 DROP USE OF R11 DSECT BASE REGISTER
         EJECT
***********************************************************************
*                                                                     *
*        THIS ROUTINE WILL PROVIDE THE JCT ADDRESS FOR A JOB,         *
*        PROVIDE THE ADDRESS OF THE 7 BYTE TSO USER ID IF THE         *
*        JOB CARD CONTAINS A NOTIFY= PARAMETER, AND CHECKS FOR        *
*        THAT USER BEING LOGGED ON.                                   *
*                                                                     *
*        REGISTERS UPON ENTRY.                                        *
*              R0  = UNUSED                                           *
*              R1  = UNUSED                                           *
*              R15 = 7                                                *
*                                                                     *
*        REGISTERS UPON RETURN.                                       *
*        NOTIFY SPECIFIED, NOTIFY TSO USER LOGGED ON                  *
*              R0  = A(TSO TSU ID)                                    *
*              R1  = A(JCT)                                           *
*              R15 = 0                                                *
*        NOTIFY SPECIFIED, NOTIFY TSO USER NOT LOGGED ON              *
*              R0  = A(TSO TSU ID)                                    *
*              R1  = A(JCT)                                           *
*              R15 = 4                                                *
*        NOTIFY NOT SPECIFIED                                         *
*              R0  = 0                                                *
*              R1  = A(JCT)                                           *
*              R15 = 8                                                *
*        INVALID CONTROL BLOCK STRUCTURE (JCT NOT FOUND)              *
*              R0  = UNPREDICTABLE                                    *
*              R1  = UNPREDICTABLE                                    *
*              R15 = 16                                               *
*                                                                     *
***********************************************************************
JCTLOOK  DS    0H                  JCTLOOK ENTRY
         USING JCTLOOK,R6          BASE FOR SUBROUTINE
         USING ASVT,R12            ESTABLISH ADDRESSABILITY
         USING JCT,R10             ADDRESSABILITY ESTABLISHED IN $JCT
         JCTGET                    GET JCT ADDRESS
         CLI   JCTTSUID,X'00'      CHECK FOR NO NOTIFY
         BE    JCTLRT08            IF NULL, NONE, GO TO 8 RETURN
         L     R12,CVTASVT         SET R12=A(ASVT) FROM CVT
         L     R0,ASVTMAXU         SET R0=MAX # OF ASCB'S FROM ASVT
JCTL1100 ICM   R7,15,ASVTENTY      SET R7=A(ASCB) FROM ASVT
         BM    JCTL1200            IF NOT ASSIGNED, GO TO JCTL1200
         ICM   R1,15,ASCBTSB       SET R1=A(TSB) FROM ASCB
         BZ    JCTL1200            IF 0, NOT TSO, GO TO JCTL1200
         L     R15,ASCBJBNS        SET R15=A(JOBNAME) FROM ASCB
         CLC   JCTTSUID,0(R15)     CHECK FOR TSO USER LOGGED ON
         BE    JCTLRT00            IF LOGGED ON, GO TO JCTLRT00
JCTL1200 LA    R12,4(R12)          INCREMENT R12, ASVT DSECT BASE
         BCT   R0,JCTL1100         CONTINUE CHECKING AT JCTL1100
         B     JCTLRT04            USER NOT LOGGED ON, GO TO JCTLRT04
JCTLRT00 EQU   *
         LA    R0,JCTTSUID         SET R0=A(NOTIFY TSUID)
         LA    R1,JCTSTART         SET R1=A(JCT)
         SR    R15,R15             SET R15=0, RETURN CODE
         BR    R14                 RETURN TO SVC HANDLER
JCTLRT04 EQU   *
         LA    R0,JCTTSUID         SET R0=A(NOTIFY TSUID)
         LA    R1,JCTSTART         SET R1=A(JCT)
         LA    R15,4               SET R15=4, RETURN CODE
         BR    R14                 RETURN TO SVC HANDLER
JCTLRT08 SR    R0,R0               SET R0=0, NO NOTIFY
         LA    R1,JCTSTART         SET R1=A(JCT)
         LA    R15,8               SET R15=8, RETURN CODE
         BR    R14                 RETURN TO SVC HANDLER
         LTORG
         DROP  R6                  DROP USE OF R6 BASE REGISTER
         DROP  R10                 DROP USE OF R10 BASE REGISTER
         DROP  R12                 DROP USE OF R12 BASE REGISTER
         EJECT
***********************************************************************
*                                                                     *
*        THIS ROUTINE WILL PROVIDE THE ADDRESS OF THE EIGHT           *
*        CHARACTER SYSTEM JOBNAME IN REGISTER 0 (TIOT) AND THE        *
*        ADDRESS OF THE EIGHT CHARACTER JES JOBID IN REGISTER 1.      *
*                                                                     *
*        REGISTERS UPON ENTRY.                                        *
*              R0  = UNUSED                                           *
*              R1  = UNUSED                                           *
*              R15 = 8                                                *
*                                                                     *
*        REGISTERS UPON RETURN.                                       *
*              R0  = ADDRESS OF SYSTEM JOBNAME (TIOT)                 *
*              R1  = ADDRESS OF JES JOBID                             *
*              R15 = 0                                                *
*                                                                     *
*        INVALID CONTROL BLOCK STRUCTURE (JCT NOT FOUND)              *
*              R0  = UNPREDICTABLE                                    *
*              R1  = UNPREDICTABLE                                    *
*              R15 = 16                                               *
*                                                                     *
***********************************************************************
JESJOBID DS    0H                  JESJOBID ENTRY
         USING JESJOBID,R6         BASE FOR SUBROUTINE
         USING JCT,R10             ADDRESSABILITY ESTABLISHED IN $JCT
         JCTGET                    GET JCT ADDRESS
         L     R0,TCBTIO           SET R0=A(TIOT)
         LA    R1,JCTJOBID         SET R1=A(JES JOB NUMBER)
         SR    R15,R15             SET R15=0, RETURN CODE
         BR    R14                 RETURN TO SVC HANDLER
         LTORG
         DROP  R6                  DROP USE OF R6 BASE REGISTER
         DROP  R10                 DROP USE OF R10 BASE REGISTER
         EJECT
***********************************************************************
*                                                                     *
*        THIS ROUTINE WILL PROVIDE THE ADDRESS OF THE JES INPUT       *
*        DEVICE IN REGISTER 1.                                        *
*                                                                     *
*        REGISTERS UPON ENTRY.                                        *
*              R0  = UNUSED                                           *
*              R1  = UNUSED                                           *
*              R15 = 9                                                *
*                                                                     *
*        REGISTERS UPON RETURN.                                       *
*        REMOTE INPUT DEVICE.                                         *
*              R0  = UNCHANGED                                        *
*              R1  = ADDRESS OF JES INPUT DEVICE                      *
*              R15 = 0                                                *
*        NOT REMOTE INPUT DEVICE.                                     *
*              R0  = UNCHANGED                                        *
*              R1  = ADDRESS OF JES INPUT DEVICE                      *
*              R15 = 4                                                *
*        INVALID CONTROL BLOCK STRUCTURE (JCT NOT FOUND)              *
*              R0  = UNPREDICTABLE                                    *
*              R1  = UNPREDICTABLE                                    *
*              R15 = 16                                               *
*                                                                     *
***********************************************************************
JESINDEV DS    0H                  JESINDEV ENTRY
         USING JESINDEV,R6         BASE FOR SUBROUTINE
         USING JCT,R10             ADDRESSABILITY ESTABLISHED IN $JCT
         JCTGET                    GET JCT ADDRESS
         CLI   JCTINDEV,C'R'       CHECK FOR REMOTE INDEV
         BNE   JESIRT04            IF NOT, GO TO JESIRT04
         CLI   JCTINDEV+1,C'1'     CHECK FOR REMOTE INDEV
         BL    JESIRT04            IF NOT, GO TO JESIRT04
         CLI   JCTINDEV+2,C'.'     CHECK FOR REMOTE INDEV
         BE    JESIRT00            IF REMOTE, GO TO JESIRT00
         CLI   JCTINDEV+2,C'0'     CHECK FOR REMOTE INDEV
         BL    JESIRT04            IF NOT, GO TO JESIRT04
         CLI   JCTINDEV+3,C'.'     CHECK FOR REMOTE INDEV
         BE    JESIRT00            IF REMOTE, GO TO JESIRT00
         CLI   JCTINDEV+3,C'0'     CHECK FOR REMOTE INDEV
         BL    JESIRT04            IF NOT, GO TO JESIRT04
JESIRT00 LA    R1,JCTINDEV         SET R1=A(JES INPUT DEVICE)
         SR    R15,R15             SET R15=0, RETURN CODE
         BR    R14                 RETURN TO SVC HANDLER
JESIRT04 LA    R1,JCTINDEV         SET R1=A(JES INPUT DEVICE)
         LA    R15,4               SET R15=4, RETURN CODE
         BR    R14                 RETURN TO SVC HANDLER
         LTORG
         DROP  R6
         DROP  R10
         EJECT
***********************************************************************
*                                                                     *
*        THIS ROUTINE WILL ISSUE A FULL SCREEN TPUT TO BLANK OUT      *
*        THE ENTIRE SCREEN ON DISPLAY TERMINALS ONLY.  ALSO, IF       *
*        THE TERMINAL IS A DISPLAY DEVICE, A TCLEARQ IS ISSUED        *
*        TO STRIP OFF THE 'RESHOW' (PA2) THAT IS STACKED BY ISPF.     *
*                                                                     *
*        REGISTERS UPON ENTRY.                                        *
*              R0  = UNUSED                                           *
*              R1  = UNUSED                                           *
*              R15 = 10                                               *
*                                                                     *
*        REGISTERS UPON RETURN.                                       *
*              R0  = # LINES PER SCREEN                               *
*              R1  = # CHARACTERS PER LINE                            *
*              R15 = 0                                                *
*                                                                     *
***********************************************************************
CLEAR    DS    0H                  JESINDEV ENTRY
         USING CLEAR,R6            BASE FOR SUBROUTINE
         GTSIZE ,                  TEST FOR SCREEN TERMINAL
         LTR   R0,R0               BYPASS TPUT IF NOT
         BZ    CLEARE              NOT A TUBE, IGNORE REQUEST
         TPUT  CLEARD,CLEARL,FULLSCR,WAIT,HOLD CLEAR THE TUBE
         TCLEARQ INPUT             RESET INPUT STACK
         GTSIZE ,                  INITIALIZED R0/R1 SIZES
CLEARE   DS    0H                  JESINDEV ENTRY
         SR    R15,R15             SET R15=0, RETURN CODE
         BR    R14                 RETURN TO SVC HANDLER
         LTORG
CLEARD   DC    X'F1115D7E114040133CC75F003C4E7F003CD65F003C404000'
CLEARL   EQU   *-CLEARD      LENGTH OF TPUT
         LTORG
         DROP  R6                  DROP USE OF R6 BASE REGISTER
         EJECT
***********************************************************************
*                                                                     *
*        THIS ROUTINE WILL CONVERT A CALENDAR DATE IN THE FORMAT      *
*        OF 0MMDDYYS TO THE CORRESPONDING JULIAN DATE IN THE          *
*        FORMAT OF 00YYDDDF, AND RETURN THE DAY OF WEEK OFFSET        *
*        IN THE FORMAT OF 0000000O.  BOTH DATE FIELDS ARE IN          *
*        PACKED DECIMAL NOTATION AND THE DAY OF WEEK OFFSET IS        *
*        IN BINARY.  CALENDAR DATE IS PASSED IN R0, DAY OF WEEK       *
*        OFFSET IS RETURNED IN R0, AND JULIAN DATE IS RETURNED        *
*        IN R1.                                                       *
*                                                                     *
*        REGISTERS UPON ENTRY.                                        *
*              R0  = CALENDAR DATE IN PACKED FORMAT 0MMDDYYS          *
*              R1  = UNUSED                                           *
*              R15 = 11                                               *
*                                                                     *
*        REGISTERS UPON RETURN.                                       *
*        DATE PASSED IN R0 IS VALID.                                  *
*              R0  = DAY OF WEEK OFFSET IN BINARY FORMAT (0=MONDAY)   *
*              R1  = JULIAN DATE IN PACKED FORMAT 00YYDDDF            *
*              R15 = 0                                                *
*        DATE PASSED IN R0 IS INVALID.                                *
*              R0  = UNCHANGED                                        *
*              R1  = UNCHANGED                                        *
*              R15 = 4                                                *
*                                                                     *
***********************************************************************
         SPACE 1
CALJUL   DS    0H                  CALJUL ENTRY
         USING CALJUL,R6           BASE FOR SUBROUTINE
         USING TWORK,R13           ESTABLISH ADDRESSABILITY
CALJ1000 DS    0H
         LR    R8,R0               SAVE R0 IN R8
         LR    R9,R1               SAVE R1 IN R9
         LA    R0,24               SET R0=24, GETMAIN LENGTH
         GETMAIN R,LV=(0)          GET SOME STORAGE
         LR    R13,R1              SET R13=A(TWORK)
         ST    R8,TW08L04          STORE CALENDAR DATE IN TWORK
         TRT   TW08L04,CTRTAB3     CHECK FOR VALID PACKED FORMAT
         BC    12,CALJRT04         IF INVALID, GO TO CALJRT04
         LA    R1,X'80'            SET R1=X'80', CONSTANT
         NR    R1,R2               CHECK FOR LAST BYTE VALID
         BZ    CALJRT04            IF INVALID, GO TO CALJRT04
         CLI   TW08L01,X'01'       CHECK FOR XMM=(00M OR 01M)
         BH    CALJRT04            IF NOT, GO TO CALJRT04
         UNPK  TW12L06,TW08L04     UNPACK CALENDAR DATE AT
         OI    TW17L01,C'0'        FORCE F SIGN
         PACK  TW00L08,TW12L02     PACK MM
         CVB   R3,TW00L08          SET R3=BINARY MM
         LTR   R3,R3               CHECK FOR MM=0
         BZ    CALJRT04            IF 0, GO TO CALJRT04
         LA    R15,12              SET R15=12, CONSTANT
         CR    R3,R15              CHECK FOR MM GT 12
         BH    CALJRT04            IF GT, GO TO CALJRT04
         PACK  TW00L08,TW14L02     PACK DD
         CVB   R4,TW00L08          SET R4=BINARY DD
         LTR   R4,R4               CHECK FOR DD=0
         BZ    CALJRT04            IF 0, GO TO CALJRT04
         PACK  TW00L08,TW16L02     PACK YY
         CVB   R5,TW00L08          SET R5=BINARY YY
         LA    R1,CDTABNLP         SET R1=A(NON-LEAP YEAR TABLE)
         CLC   TW16L02,=CL2'00'    CHECK FOR 1900
         BE    CALJ1100            IF 1900, NOT LEAP, GO TO CALJ1100
         STC   R5,TW00L01          SET TW00L01=BINARY YY
         TM    TW00L01,X'03'       CHECK FOR NOT DIVISIBLE BY 4
         BNZ   CALJ1100            IF NOT, NOT LEAP, GO TO CALJ1100
         LA    R1,CDTABLP          SET R1=A(LEAP YEAR TABLE)
CALJ1100 LA    R15,0(R1,R3)        SET R15=A(MAX DAYS IN MONTH)
         CLM   R4,1,0(R15)         CHECK FOR VALID DD
         BH    CALJRT04            IF GT, INVALID, GO TO CALJRT04
         PACK  TW08L03,TW16L03     PACK YY INTO JULIAN FORMAT
         SLL   R3,1                SET R3=2*MM
         LA    R15,11(R1,R3)       SET R15=A(N(DAYS IN PREC MOS))-2
         ZAP   TW10L02,0(2,R15)    PACK DAYS INTO JULIAN FORMAT
         CVD   R4,TW00L08          CONVERT DD TO DECIMAL
         AP    TW10L02,TW00L08     ADD DD TO PRECEDING DAYS
         OI    TW11L01,X'0F'       FORCE F SIGN
         L     R9,TW08L04          SET R9=PACKED JULIAN DATE
         ZAP   TW00L08,TW10L02     SET TW00L08=PACKED JULIAN DDDF
         CVB   R4,TW00L08          SET R4=BINARY JULIAN DDD
         MVO   TW00L08,TW09L01     SET TW00L08=PACKED JULIAN YYF
         CVB   R5,TW00L08          SET R5=BINARY JULIAN YY
         LA    R2,365              SET R2=365, MULTIPLIER
         LR    R11,R5              SET R11=YY
         MR    R10,R2              SET R11=365*YY
         LTR   R10,R5              SET R10=YY
         BZ    *+6                 IF YY EQ 00, SKIP NEXT INSTRUCTION
         BCTR  R10,R0              SET R10=YY-1
         SRL   R10,2               SET R10=I((YY-1)/4)
         AR    R11,R10             SET R11=365*YY+I((YY-1)/4)
         AR    R11,R4              SET R11=365*YY+I((YY-1)/4)+DDD
         BCTR  R11,R0              SET R11=365*YY+I((YY-1)/4)+DDD-1
         LA    R2,7                SET R2=7, DIVISOR
         SR    R10,R10             SET R10=0, R11=DAYS-1
         DR    R10,R2              SET R10=R((DAYS-1)/7)
         LR    R8,R10              SET R8=DAY OF WEEK OFFSET
CALJRT00 SR    R10,R10             SET R10=0, RETURN CODE
         B     CALJRTXX            GO TO CALJRTXX
CALJRT04 LA    R10,4               SET R10=4, RETURN CODE
CALJRTXX LA    R0,24               SET R0=24, L'GETMAIN AREA
         LA    R1,TWORK            SET R1=A(GETMAIN AREA)
         FREEMAIN R,LV=(0),A=(1)   FREE GOTTEN STORAGE
         LR    R0,R8               RESTORE NEW/ORIGINAL R0 FROM R8
         LR    R1,R9               RESTORE NEW/ORIGINAL R1 FROM R9
         LR    R15,R10             SET R15=RETURN CODE
         BR    R14                 RETURN TO SVC HANDLER
         SPACE 1
         DROP  R6                  DROP USE OF R6 BASE REGISTER
         DROP  R13                 DROP USE OF R13 BASE REGISTER
         EJECT
***********************************************************************
*                                                                     *
*        THIS ROUTINE WILL CONVERT A JULIAN DATE IN THE FORMAT        *
*        OF 00YYDDDS TO THE CORRESPONDING CALENDAR DATE IN THE        *
*        FORMAT OF 0MMDDYYF, AND RETURN THE DAY OF WEEK OFFSET        *
*        IN THE FORMAT OF 0000000O.  BOTH DATE FIELDS ARE IN          *
*        PACKED DECIMAL NOTATION AND THE DAY OF WEEK OFFSET IS        *
*        IN BINARY.  JULIAN DATE IS PASSED IN R0, DAY OF WEEK         *
*        OFFSET IS RETURNED IN R0, AND CALENDAR DATE IS RETURNED      *
*        IN R1.                                                       *
*                                                                     *
*        REGISTERS UPON ENTRY.                                        *
*              R0  = JULIAN DATE IN PACKED FORMAT 00YYDDDS            *
*              R1  = UNUSED                                           *
*              R15 = 12                                               *
*                                                                     *
*        REGISTERS UPON RETURN.                                       *
*        DATE PASSED IN R0 IS VALID.                                  *
*              R0  = DAY OF WEEK OFFSET IN BINARY FORMAT (0=MONDAY)   *
*              R1  = CALENDAR DATE IN PACKED FORMAT 0MMDDYYF          *
*              R15 = 0                                                *
*        DATE PASSED IN R0 IS INVALID.                                *
*              R0  = UNCHANGED                                        *
*              R1  = UNCHANGED                                        *
*              R15 = 4                                                *
*                                                                     *
***********************************************************************
         SPACE 1
JULCAL   DS    0H                  JULCAL ENTRY
         USING JULCAL,R6           BASE FOR SUBROUTINE
         USING TWORK,R13           ESTABLISH ADDRESSABILITY
JULC1000 DS    0H
         LR    R8,R0               SAVE R0 IN R8
         LR    R9,R1               SAVE R1 IN R9
         LA    R0,24               SET R0=24, GETMAIN LENGTH
         GETMAIN R,LV=(0)          GET SOME STORAGE
         LR    R13,R1              SET R13=A(TWORK)
         ST    R8,TW08L04          STORE CALENDAR DATE IN TWORK
         TRT   TW08L04,CTRTAB3     CHECK FOR VALID PACKED FORMAT
         BC    12,JULCRT04         IF INVALID, GO TO JULCRT04
         LA    R1,X'80'            SET R1=X'80', CONSTANT
         NR    R1,R2               CHECK FOR LAST BYTE VALID
         BZ    JULCRT04            IF INVALID, GO TO JULCRT04
         CLI   TW08L01,X'00'       CHECK FOR XXYY=00YY
         BNE   JULCRT04            IF NOT, GO TO JULCRT04
         ZAP   TW00L08,TW10L02     CHECK FOR DDDS=000S
         BZ    JULCRT04            IF 0, GO TO JULCRT04
         OI    TW11L01,X'0F'       FORCE F SIGN ON JULIAN DATE
         LA    R15,CDTABNLP+13     SET R15=A(NON-LEAP YEAR TABLE)
         CLI   TW09L01,X'00'       CHECK FOR 1900
         BE    JULC1100            IF 1900, NOT LEAP, GO TO JULC1100
         TM    TW09L01,X'03'       CHECK FOR YY DIVISIBLE BY 4
         BNZ   JULC1100            IF NOT, GO TO JULC1100
         LA    R15,CDTABLP+13      SET R15=A(LEAP YEAR TABLE)
JULC1100 LA    R0,1                SET R0=1, BXLE INCREMENT
         LA    R1,12               SET R1=12, BXLE LIMIT
         LR    R2,R0               SET R2=1, BXLE START
JULC1110 CP    TW10L02,2(2,R15)    CHECK FOR DDD LE TABLE ENTRY
         BNH   JULC1200            IF LE, GO TO JULC1200
         LA    R15,2(R15)          SET R15=A(NEXT TABLE ENTRY)
         BXLE  R2,R0,JULC1110      CONTINUE AT JULC1110
         B     JULCRT04            INVALID DDD, GO TO JULCRT04
JULC1200 CVD   R2,TW00L08          CONVERT R2 MM TO DECIMAL
         UNPK  TW12L02,TW00L08     UNPACK MM
         SP    TW10L02,0(2,R15)    SET TW10L02=DD
         UNPK  TW14L02,TW10L02     UNPACK DD
         UNPK  TW16L03,TW09L02     UNPACK YY
         PACK  TW08L04,TW12L06     PACK MMDDYY
         L     R9,TW08L04          SET R9=PACKED CALENDAR DATE
         ST    R8,TW08L04          SET TW08L04=PACKED JULIAN DATE
         ZAP   TW00L08,TW10L02     SET TW00L08=PACKED JULIAN DDDF
         CVB   R4,TW00L08          SET R4=BINARY JULIAN DDD
         MVO   TW00L08,TW09L01     SET TW00L08=PACKED JULIAN YYF
         CVB   R5,TW00L08          SET R5=BINARY JULIAN YY
         LA    R2,365              SET R2=365, MULTIPLIER
         LR    R11,R5              SET R11=YY
         MR    R10,R2              SET R11=365*YY
         LTR   R10,R5              SET R10=YY
         BZ    *+6                 IF YY EQ 00, SKIP NEXT INSTRUCTION
         BCTR  R10,R0              SET R10=YY-1
         SRL   R10,2               SET R10=I((YY-1)/4)
         AR    R11,R10             SET R11=365*YY+I((YY-1)/4)
         AR    R11,R4              SET R11=365*YY+I((YY-1)/4)+DDD
         BCTR  R11,R0              SET R11=365*YY+I((YY-1)/4)+DDD-1
         LA    R2,7                SET R2=7, DIVISOR
         SR    R10,R10             SET R10=0, R11=DAYS-1
         DR    R10,R2              SET R10=R((DAYS-1)/7)
         LR    R8,R10              SET R8=DAY OF WEEK OFFSET
JULCRT00 SR    R10,R10             SET R10=0, RETURN CODE
         B     JULCRTXX            GO TO JULCRTXX
JULCRT04 LA    R10,4               SET R10=4, RETURN CODE
JULCRTXX LA    R0,24               SET R0=24, L'GETMAIN AREA
         LA    R1,TWORK            SET R1=A(GETMAIN AREA)
         FREEMAIN R,LV=(0),A=(1)   FREE GOTTEN STORAGE
         LR    R0,R8               RESTORE NEW/ORIGINAL R0 FROM R8
         LR    R1,R9               RESTORE NEW/ORIGINAL R1 FROM R9
         LR    R15,R10             SET R15=RETURN CODE
         BR    R14                 RETURN TO SVC HANDLER
         SPACE 1
         DROP  R6                  DROP USE OF R6 BASE REGISTER
         DROP  R13                 DROP USE OF R13 BASE REGISTER
         EJECT
***********************************************************************
*                                                                     *
*        THIS ROUTINE WILL COMPUTE THE DIFFERENCE IN DAYS             *
*        BETWEEN TWO JULIAN DATES.  THE DATES ARE PASSED IN R0        *
*        AND R1 AND ARE IN PACKED DECIMAL NOTATION WITH FORMAT        *
*        OF 00YYDDDS.  THE DIFFERENCE IS A BINARY NUMBER              *
*        RETURNED IN R1.                                              *
*                                                                     *
*        REGISTERS UPON ENTRY.                                        *
*              R0  = JULIAN DATE(1) IN PACKED FORMAT 00YYDDDS         *
*              R0  = JULIAN DATE(2) IN PACKED FORMAT 00YYDDDS         *
*              R15 = 13                                               *
*                                                                     *
*        REGISTERS UPON RETURN.                                       *
*        DATES PASSED IN R0 AND R1 ARE VALID.                         *
*              R0  = UNCHANGED                                        *
*              R1  = BINARY NUMBER OF DAYS DIFFERENCE                 *
*              R15 = 0                                                *
*        DATE(S) INVALID OR DATE1 GT DATE2.                           *
*              R0  = UNCHANGED                                        *
*              R1  = UNCHANGED                                        *
*              R15 = 4 -  DATE(1) INVALID                             *
*                    8 -  DATE(2) INVALID                             *
*                    12 - DATE(1) AND DATE(2) BOTH INVALID            *
*                    16 - DATE(1) GT DATE(2)                          *
*                                                                     *
***********************************************************************
         SPACE 1
JULDIF   DS    0H                  JULDIF ENTRY
         USING JULDIF,R6           BASE FOR SUBROUTINE
         USING TWORK,R13           ESTABLISH ADDRESSABILITY
JULD1000 DS    0H
         LR    R8,R0               SAVE R0 IN R8
         LR    R9,R1               SAVE R1 IN R9
         LA    R0,16               SET R0=16, GETMAIN LENGTH
         GETMAIN R,LV=(0)          GET SOME STORAGE
         LR    R13,R1              SET R13=A(TWORK)
         LR    R0,R8               SET R0=DATE(1)
         BAL   R11,JULD8000        LINK TO VALIDATE/COMPUTE ROUTINE
         LR    R3,R1               SET R3=DAYS IN CENTURY, DATE(1)
         LR    R10,R15             SET R10=RETURN CODE
         LR    R0,R9               SET R0=DATE(2)
         BAL   R11,JULD8000        LINK TO VALIDATE/COMPUTE ROUTINE
         LR    R4,R1               SET R4=DAYS IN CENTURY, DATE(2)
         SLL   R15,1               SET R15=RETURN CODE*2
         OR    R10,R15             OR SECOND RC INTO R10
         BNZ   JULDRTXX            IF EITHER NE 0, GO TO JULDRTXX
         SR    R4,R3               SET R4=DAYS DIFFERENCE
         BNM   JULDRT00            IF NOT MINUS, GO TO JULDRT00
         LA    R10,16              SET R10=16, RETURN CODE
         B     JULDRTXX            GO TO JULDRTXX
JULD8000 ST    R0,TW08L04          STORE CALENDAR DATE IN TWORK
         TRT   TW08L04,CTRTAB3     CHECK FOR VALID PACKED FORMAT
         BC    12,JULD8910         IF INVALID, GO TO JULD8910
         LA    R1,X'80'            SET R1=X'80', CONSTANT
         NR    R1,R2               CHECK FOR LAST BYTE VALID
         BZ    JULD8910            IF INVALID, GO TO JULD8910
         CLI   TW08L01,X'00'       CHECK FOR VALID 00YY
         BNE   JULD8910            IF INVALID, GO TO JULD8910
         OI    TW11L01,X'0F'       FORCE F SIGN ON DATE
         LA    R15,CDTABNLP+13+12*2    SET R15=A(DAYS/NON-LEAP YEAR)
         CLI   TW09L01,X'00'       CHECK FOR 1900
         BE    JULD8100            IF 1900 GO TO JUDL8100
         TM    TW09L01,X'03'       CHECK FOR YY DIVISIBLE BY 4
         BNZ   JULD8100            IF NOT, GO TO JUDL8100
         LA    R15,CDTABLP+13+12*2 SET R15=A(DAYS/LEAP YEAR)
JULD8100 CP    TW10L02,0(2,R15)    CHECK DDD GT MAX
         BH    JULD8910            IF GT, INVALID, GO TO JULD8910
         SR    R2,R2               SET R2=0, N(LEAP YEARS)
         MVI   TW07L01,X'0F'       MOVE F SIGN TO TW00L08
         MVO   TW00L08,TW09L01     MOVE YY TO 0000000000000YYF
         CVB   R1,TW00L08          SET R1=BINARY YY
         CLI   TW09L01,X'00'       CHECK FOR 1900
         BE    JULD8200            IF 1900, 0 LEAPS, GO TO JULD8200
         LR    R2,R1               SET R2=BINARY YY
         BCTR  R2,R0               SET R2=YY-1
         SRL   R2,2                SET R2=(YY-1)/4, N(LEAP YEARS)
JULD8200 ZAP   TW00L08,TW10L02     ZAP DDDF TO 000000000000DDDF
         CVB   R0,TW00L08          SET R0=BINARY DDD
         AR    R2,R0               SET R2=LEAPS+DDD
         LA    R15,365             SET R15=365, CONSTANT
         MR    R0,R15              SET R1=YY*365
         AR    R1,R2               SET R1=YY*365+DDD+LEAPS
JULD8900 SR    R15,R15             SET R15=0, RETURN CODE
         B     JULD8990            GO TO JULD8990
JULD8910 LA    R15,4               SET R15=4, RETURN CODE
JULD8990 BR    R11                 RETURN TO INVOKER
JULDRT00 LR    R9,R4               SET R9=BINARY DAYS DIFFERENCE
         SR    R10,R10             SET R10=0, RETURN CODE
JULDRTXX LA    R0,16               SET R0=16, L'GETMAIN AREA
         LA    R1,TWORK            SET R1=A(GETMAIN AREA)
         FREEMAIN R,LV=(0),A=(1)   FREE GOTTEN STORAGE
         LR    R0,R8               RESTORE ORIGINAL R0 FROM R8
         LR    R1,R9               RESTORE ORIGINAL R1 FROM R9
         LR    R15,R10             SET R15=RETURN CODE
         BR    R14                 RETURN TO SVC HANDLER
         SPACE 1
CTRTAB3  DC    10XL16'00000000000000000000010180800180',96XL1'01'
CDTABLP  DC    AL1(00,31,29,31,30,31,30,31,31,30,31,30,31)
         DC    PL2'000',PL2'031',PL2'060',PL2'091',PL2'121',PL2'152'
         DC    PL2'182',PL2'213',PL2'244',PL2'274',PL2'305',PL2'335'
         DC    PL2'366'
CDTABNLP DC    AL1(00,31,28,31,30,31,30,31,31,30,31,30,31)
         DC    PL2'000',PL2'031',PL2'059',PL2'090',PL2'120',PL2'151'
         DC    PL2'181',PL2'212',PL2'243',PL2'273',PL2'304',PL2'334'
         DC    PL2'365'
         SPACE 1
TWORK    DSECT
TW00L19  DS    0CL19
TW00L08  DS    0CL8
TW00L04  DS    0CL4
TW00L02  DS    0CL2
TW00L01  DS    CL1
TW01L19  DS    0CL19,CL1
TW02L01  DS    CL1
TW03L02  DS    0CL2,CL1
TW04L04  DS    0CL4,CL1
TW05L01  DS    CL1
TW06L02  DS    0CL2,CL1
TW07L01  DS    CL1
TW08L04  DS    0CL4
TW08L03  DS    0CL3
TW08L01  DS    CL1
TW09L02  DS    0CL2
TW09L01  DS    CL1
TW10L02  DS    0CL2,CL1
TW11L01  DS    CL1
TW12L06  DS    0CL6
TW12L02  DS    CL2
TW14L02  DS    0CL2
TW14L01  DS    CL1
TW15L02  DS    0CL2,CL1
TW16L04  DS    0CL4
TW16L03  DS    0CL3
TW16L02  DS    0CL2,CL1
TW17L01  DS    CL1
MVSGPSVC CSECT
         DROP  R6                  DROP USE OF R6 BASE REGISTER
         DROP  R13                 DROP USE OF R13 BASE REGISTER
         EJECT
***********************************************************************
*                                                                     *
*                                                                     *
XACF     DS    0H
         USING XACF,R6             BASE FOR SUBROUTINE
         USING RBBASIC,R5          ESTABLISH ADDRESSABILITY
         USING ASXB,R8             ESTABLISH ADDRESSABILITY
         USING ACEE,R10            ESTABLISH ADDRESSABILITY
         USING CDENTRY,R11         ESTABLISH ADDRESSABILITY
         L     R8,ASCBASXB         GET ASXB FROM ASCB
         ICM   R10,15,ASXBSENV     GET CALLERS ACEE
         BZR   R14                 RETURN IF NO ACEE
         CLC   ACEEACEE,=CL4'ACEE' IS IT REALLY AN ACEE?
         BNER  R14                 RETURN IF NO ACEE
         TM    ACEEFLG1,ACEERACF   IS CALLER RACF DEFINED?
         BZR   R14                 NO, IGNORE REQUEST
         L     R5,RBLINK           GET CALLERS RB ADDRESS
         L     R11,RBCDE           GET CALLERS CDE
         CLC   CDNAME(5),=CL5'CMNER'  CALLER RACF/SPF INTERFACE?
         BNER  R14                 NO, IGNORE REQUEST
         LR    R8,R0               COPY PARM REG
         LTR   R9,R1               COPY PARM REG
         BZ    XACFEND             ZERO, IGNORE REQUEST
         C     R8,CDENTPT          IS THIS REQUEST FOR SPECIAL?
         BNE   XACFBY              NO, NORMAL CALL
         ICM   R7,8,ACEEFLG1       SAVE ORIGINAL ACEE FLAG
*        OI    ACEEFLG1,ACEESPEC   TEMPORARILY ADD SPECIAL
XACFBY   DS    0H
         SVC   132                 INVOKE RACF SVC FOR CALLER
         C     R8,CDENTPT          WAS THIS REQUEST FOR SPECIAL?
         BNE   XACFEND             NO, NORMAL CALL
*        STCM  R7,8,ACEEFLG1       RESTORE ORIGINAL ACEE FLAG
         L     R8,=F'-1'           RESET KEY
XACFEND  DS    0H
         LR    R0,R8               RESTORE PARM REG
         LR    R1,R9               RESTORE PARM REG
         DROP  R11                 DROP USING REG
         DROP  R10                 DROP USING REG
         DROP  R8                  DROP USING REG
         DROP  R5                  DROP USING REG
         BR    R14                 AND RETURN WITH R15 = RETCODE
         LTORG
         DROP  R6                  DROP USE OF R6 BASE REGISTER
*
WTO      DSECT
WTOLNMCS DS    CL4
WTOMSG   DS    0CL252
MVSGPSVC CSECT
         EJECT
***********************************************************************
*                                                                     *
*        END OF MVS GP SVC SUBROUTINES                                *
*                                                                     *
*        DSECTS AND EQUATES FOR SYSTEM AREAS FOLLOW                   *
*                                                                     *
***********************************************************************
         PRINT NOGEN
         SPACE 1
         CVT   DSECT=YES           COMMUNICATION VECTOR TABLE
         SPACE 3
         IEFJESCT TYPE=DSECT       JOB ENTRY SUBSYSTEM COMMUNICATION
         SPACE 3
         IEFJSCVT                  SUBSYSTEM COMMUNICATION VECTOR TBL
         SPACE 3
         IEFJSSVT                  JES2 SSVT
         SPACE 3
         IHAASCB DSECT=YES         ADDRESS SPACE CONTROL BLOCK
         SPACE 3
         IHAASVT DSECT=YES         ADDRESS SPACE VECTOR TABLE
         SPACE 3
         IKJTCB DSECT=YES          TASK CONTROL BLOCK
         SPACE 3
         IEZJSCB                   JOB/STEP CONTROL BLOCK
         SPACE 3
         IKJPSCB                   PROTECT STEP CONTROL BLOCK
         SPACE 3
TIOT     DSECT                     TASK INPUT/OUTPUT TABLE
         IEFTIOT1
         SPACE 3
         $XECB                     HASP EXTENED ECB
         SPACE 3
UCBDSECT DSECT                     UNIT CONTROL BLOCK
         IEFUCBOB PREFIX=NO
         SPACE 3
         $SCAT                     HASP SYSOUT CLASS ATTRIBUTE TABLE
         SPACE 3
**       $SVT                      HASP SUBSYSTEM VECTOR TABLE
**       SPACE 3
         $HASB                     HOLY ALLMIGHTY SMOKES BLOCK
         SPACE 3
         $SJB                      HASP SUBSYSTEM JOB BLOCK
         SPACE 3
         $BUFFER                   HASP BUFFER
         SPACE 3
         $HCCT                     HOLY COW CONTROL TABLE
         SPACE 3
         $JCT                      HASP JOB CONTROL TABLE
         SPACE 3
         $TQE                      TEQUILLA ELEMENT. REQ'D BY HCCT
         SPACE 3
         $HFAME                    HALL OF FAME. REQ'D BY HCCT
         SPACE 3
         $HASPEQU                  JES2 GLOBAL EQUATES
         SPACE 3
         IFGRPL AM=VSAM            VSAM RPL
         SPACE 3
         IHAASXB                   ADDRSSS SPACE EXTENSION BLOCK
         SPACE 3
         IHAACEE                   ACESSOR ENVIRONMENT ELEMENT
         SPACE 3
         IHARB                     OS/VS REQUEST BLOCK
         SPACE 3
         IHACDE                    CONTENTS DIRECTORY ENTRY
         SPACE 3
         IHAPSA                    LOW CORE ...
         END
