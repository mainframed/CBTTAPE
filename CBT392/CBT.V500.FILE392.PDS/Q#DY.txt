         TITLE '--- QUEUE--DISPLAY -- 3270 DISPLAY ROUTINES ---'
*---------------------------------------------------------------------*
*                                                                     *
*   DISPLAY - DISPLAY CURRENT SCREEN BUFFER                           *
*                                                                     *
*   Updates:                                                          *
*      16Jul91  GLA  Fix handling of table display repositioning      *
*      15Mar91  LDW  Correct DD#MDL for 6 char DSIDs                  *
*      11Feb91  LDW  Move some ISPF stuff from QCOMMON to literals    *
*                    Use DY@CALLP instead of TBLST and VCALLST        *
*      01Feb91  LDW  Don't clear the screen for error messages        *
*      31Jan91  LDW  Integrate GLA fixes below, with minor fiddling:  *
*                       (Guy Albertelli really makes me look bad...   *
*                       he fixed all (?) my ancient bugs.)            *
*                    Rename QPRIMCMD macro to QNEWCMD                 *
*     (15Jan91) GLA  Ignore data in second input field if it was sent *
*     (17Apr90) GLA  Support ISPF =xxx commands in ISPF mode          *
*                    Fix command line length in VCOPYs                *
*     (06Jan89) GLA  Fix extra character left in header line          *
*     (15Nov89) GLA  Fix reprompt code for ISPF                       *
*     (20Sep89) GLA  Make blank command lines not real commands       *
*                    Handle reprompts better by setting MDT           *
*                    Fix cause of QQ1 error on both line and prim cmd *
*                    Don't ignore line commands wanting validation    *
*     (10Aug89) GLA  Adjust header line to be over correct columns    *
*                    Correct DY3 problem in non-ISPF version          *
*     (20Jul89) GLA  Change the interface for command issuance to     *
*                       hopefully eliminate DY3 and QQ1 errors after  *
*                       error messages                                *
*     (11Jul89) GLA  Add prompt support to ISPF code                  *
*     ( 5Jul89) GLA  Add CPU and Paging rate to non-ISPF display      *
*     (16Jun89) GLA  Fix addressability problem causing 0C4           *
*                    Add interface to support reexcution of           *
*                       stacked primary commands                      *
*     (22May89) GLA  Move things around for addressability            *
*     (28Mar89) GLA  Add support for ISPF BROWSE and Tables           *
*      08Feb87  LDW  Support command ring for RECALL                  *
*      17Jan87  LDW  Remove "*" subcommand;  misc other cleanup       *
*                    Remove "LC" macro usage                          *
*      04/23/86 LDW  FIX BUGS                                         *
*      03/31/86 LDW  RE-DESIGN 3278-5 SUPPORT (THIRD TRY!)            *
*                    USE NEW COMMON LOGIC ERROR ROUTINE               *
*      09/13/84 LDW  ALLOW FOR 24 PFKEYS IF "MODE PFK24"              *
*      01/19/84 LDW  ADD SUPPORT FOR 'COLS' SUBCOMMAND                *
*                    FIX BUG IN HEADER IF 'JESNEWS'                   *
*      01/17/84 LDW  FIX ASM ERROR CAUSED BY EXPANSION OF QDSCREEN    *
*      04/07/83 LDW  FIX LOOP CAUSED BY LEADING BLANK IN INPUT FIELD  *
*                    FIX GLITCH IN "RECALL" CAUSED BY VTAM BUG        *
*      03/15/83 LDW  PROCESS MULTIPLE INPUT FIELDS ON SCREEN          *
*                    CHANGE USING/DROP TO USNGX/DROPX                 *
*                    FIX TTY MODE OUTPUT                              *
*                    CHANGE "*" SUBCOMMAND TO "RECALL" ("RC")         *
*      02/03/83 LDW  ADD "* I" TO REPROMPT LAST INQUIRY SUBCOMMAND    *
*      01/19/83 LDW  ADD WORKLEN= TO QSTART TYPE=ENTRY                *
*      01/14/83 LDW  ADD REPROMPT TSO AND MVS                         *
*      01/12/83 LDW  MOVE STARKEYS FROM "PARSE"                       *
*      01/10/83 LDW  SQUEEZE OUT ATTR BYTES IN "DY$TTY"               *
*                    HANDLE TCAM10 RESHOW (PA3)                       *
*                    REDESIGN SCREEN BUFFER LOGIC SO THAT BUFF PTR IS *
*                       ONLY RESET WHEN FIRST LINE IS TO BE STORED IN *
*                       BUFFER (THIS IS SO THAT A MESSAGE FROM QTILT  *
*                       CAN BE WRITTEN LEAVING THE REST OF THE        *
*                       INTACT)                                       *
*                    SUPPORT Q2SHORT WHICH INDICATES THAT ONLY THE    *
*                       TOP 3 SCREEN LINES SHOULD BE WRITTEN          *
*      01/06/83 LDW  FIX CLEAR LOGIC                                  *
*      01/04/83 LDW  ADD WORKLEN=                                     *
*                    HANDLE REPOSITIONING SUBCOMMAND DIRECTLY         *
*      12/17/82 LDW  PUT IN SUPPORT FOR IMBEDDED ATTR BYTES IN LINE   *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 3
DISPLAY  QSTART  Q5,WORKLEN=DY@WORKL
         USNGX WORK,R13
         LA    R9,2048(,R12)            Setup second base reg
         LA    R9,2048(,R9)
         USNGX DISPLAY+4096,R9          setup using
         MVI   DY@FLAG,DY@IMM           SET FLAG TO "IMMEDIATE DISPLAY"
         XC    DY@CURS,DY@CURS          INDICATE DEFAULT CURSOR POS
         OI    QFLAG1,Q1PROFOK          INITIALIZATION PROFILE COMPLETE
         BAL   R8,DY$SETOP              BUILD TOP SCREEN LINES (MAYBE)
         BAL   R8,DY$SETTL              BUILD LINE OF DASHES
         B     DY$WRITE                 bypass code below <**********
*---  I specifically don't want the screen cleared on error messages
         TM    QFLAG2,Q2NEWSCR          Any lines on scr yet?
         BZ    DY$WRITE                 Yes,  then done
         TM    QFLAG2,Q2SHORT           Short req (validation)?
         BO    DY$WRITE                 Yes,  then done
         MVC   QDNEXT,QVLINE1           Set addr of 1st line
         XC    QDLINECT,QDLINECT        RESET LINE NUMBER
         NI    QFLAG2,255-Q2NEWSCR      RESET FLAG
         XC    QDENDPTR,QDENDPTR        KILL PTR TO IC AT END
         B     DY$WRITE                 GO WRITE SCREEN
         SPACE 3
***********************************************************************
*                                                                     *
*   SUBROUTINE TO SWITCH TO MOD 2 SCREEN SIZE                         *
*                                                                     *
***********************************************************************
DISP80   QSTART  TYPE=ENTRY
         CLI   QDCOLS+1,80              ALREADY CORRECT?
         BE    QSTOP                    YES - SKIP
         MVC   QD3270OP,QDERASE         INSURE ERASE WRITE NEXT
         MVI   QDCOLS+1,80              SET SCREEN WIDTH
         MVI   QDROWS+1,24-3            SET SCREEN LENGTH (USABLE)
         ZAP   QTPAGE,=P'21'            NUMBER OF USABLE ROWS
         ZAP   QTHALF,=P'10'            SAME FOR HALF A SCREEN
         ZAP   QTPAGEX,=P'20'           SAME AS ABOVE IF COLUMN ...
         ZAP   QTHALFX,=P'10'           ... INDICATOR BEING DISPLAYED
         OI    QTERMFLG,QTFSW2          TELL DISPLAY TO REBUILD HEADER
         NI    QTERMFLG,255-QTFSW5      RESET OTHER FLAG
         B     QSTOP                    RETURN TO CALLER
         SPACE 3
***********************************************************************
*                                                                     *
*   SUBROUTINE TO SWITCH TO MOD 5 SCREEN SIZE                         *
*                                                                     *
***********************************************************************
DISP132  QSTART  TYPE=ENTRY
         TM    QTERMFLG,QTFMOD5         MODEL 5?
         BZ    QSTOP                    NO - DON'T DO ANYTHING
         CLI   QDCOLS+1,132             ALREADY CORRECT?
         BE    QSTOP                    YES - SKIP
         MVC   QD3270OP,QDERASE         INSURE ERASE WRITE NEXT
         MVI   QDCOLS+1,132             SET SCREEN WIDTH
         MVI   QDROWS+1,27-3            SET SCREEN LENGTH (USABLE)
         ZAP   QTPAGE,=P'24'            NUMBER OF USABLE ROWS
         ZAP   QTHALF,=P'12'            SAME FOR HALF A SCREEN
         ZAP   QTPAGEX,=P'23'           SAME AS ABOVE IF COLUMN...
         ZAP   QTHALFX,=P'11'           ... INDICATOR IS DISPLAYED
         OI    QTERMFLG,QTFSW5          TELL DISPLAY TO REBUILD HEADER
         NI    QTERMFLG,255-QTFSW2      RESET OTHER FLAG
         B     QSTOP                    RETURN TO CALLER
         LTORG
         SPACE 3
*---------------------------------------------------------------------*
*                                                                     *
*   DISPADD - ADD A LINE TO SCREEN BUFFER, DISPLAY SCREEN IF FULL     *
*                                                                     *
*   ENTRY - LINE TO BE ADDED IN "QDMSG"                               *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 3
DISPADD  QSTART  TYPE=ENTRY
         LA    R9,2048(,R12)            Setup second base reg
         LA    R9,2048(,R9)
         XC    DY@TPTR,DY@TPTR          NO LINE CMD ELEMENT POINTER
         B     DY$ADD00                 CONTINUE
         SPACE 3
*---------------------------------------------------------------------*
*                                                                     *
*   DISPADDX - SAME FUNCTION AS DISPADD                               *
*                                                                     *
*   ENTRY - LINE TO BE ADDED IN "QDMSG"                               *
*         - R1 -> LINE COMMAND ELEMENT                                *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 3
DISPADDX QSTART  TYPE=ENTRY
         LA    R9,2048(,R12)            Setup second base reg
         LA    R9,2048(,R9)
         ST    R1,DY@TPTR               SAVE LINE CMD ELEMENT POINTER
         SPACE 1
DY$ADD00 MVI   DY@FLAG,0                SET FLAG TO "ADD MSG"
         XC    DY@CURS,DY@CURS          INDICATE DEFAULT CURSOR POS
         TM    QFLAG1,Q1IMMED           HERE ON "IMMEDIATE" COMMAND?
         BNO   DY$ADD01                 NO - SKIP
         NI    QFLAG1,255-Q1IMMED       RESET "IMMEDIATE COMMAND"
         L     R0,=C'DY1 '              SET LOGIC ERROR CODE
         L     R15,=V(LOGICERR)         -> ROUTINE
         BALR  R14,R15                  GO TO IT (NO RETURN)
***********************************************************************
*                                                                     *
*  QUICKIE DESCRIPTION OF "DISPLAY" LOGIC:                            *
*    (1) IF ROOM ON SCREEN FOR MESSAGE, MOVE IT IN AND RETURN         *
*    (2) IF NO ROOM, SHOW *MORE*, DISPLAY SCREEN, RESET POINTERS,     *
*        GO TO (1)                                                    *
***********************************************************************
         SPACE 1
***********************************************************************
*                                                                     *
*   CHECK FOR ROOM ON SCREEN                                          *
*                                                                     *
***********************************************************************
DY$ADD01 MVI   QDOVER,0                 RESET THE PAGE OVRFL INDICATOR
         TM    QTERMFLG,QTFSW2+QTFSW5   NEED TO SWITCH?
         BNZ   DY$ADD02                 YES - SKIP NEXT TEST
         TM    QFLAG2,Q2NEWSCR          THIS OUTPUT FOR LINE 1?
         BNO   DY$ADD03                 NO - SKIP
         SPACE 1
***********************************************************************
*                                                                     *
*   BUILD SCREEN HEADER IF NECESSARY AFTER MOD2 <-> MOD5 SIZE SWITCH  *
*                                                                     *
***********************************************************************
DY$ADD02 BAL   R8,DY$SETOP              BUILD TOP SCREEN LINES (MAYBE)
         BAL   R8,DY$SETTL              BUILD LINE OF DASHES
         MVC   QDNEXT,QVLINE1           SET ADDR OF FIRST OUTPUT LINE
         XC    QDLINECT,QDLINECT        RESET LINE NUMBER
         NI    QFLAG2,255-Q2NEWSCR      RESET FLAG
         XC    QDENDPTR,QDENDPTR        KILL PTR TO IC AT END
         SPACE 1
DY$ADD03 LH    R1,QDLINECT              GET CURRENT LINE COUNT
         LA    R1,1(,R1)                INCREMENT
         TM    QISFLAG1,QIS1ISPF        Using ISPF DM for screen?
         BO    DY$ADD3A                 yes, so handle different
         CH    R1,QDROWS                SCREEN BUFFER FULL?
         BH    DY$FULL                  YES - WRITE SCREEN.
DY$ADD3A STH   R1,QDLINECT              SAVE UPDATED LINE COUNT
         CH    R1,=H'1'                 IS THIS DATA LINE 1?
         BNE   DY$ADD04                 NO - SKIP
         OI    QFLAG1,Q1MVHDR           YES - REQUEST "MOVE HEADER"
         TM    QFLAG2,Q2LISTDS+Q2COLIND IN 'LISTDS' AND WANT COL IND?
         BNO   DY$ADD04                 NO - SKIP
         L     R4,QDNEXT                -> NEXT LINE LOC
         LH    R5,QDCOLS                GET LINE LENGTH
         BCTR  R5,0                     -1 FOR EX
         LA    R15,DY#SCALE             -> MY COLUMN SCALE
         AH    R15,QPOFFSET             ADD COL-1
         EX    R5,DY$SCMVC              MVC 0(*-*,R4),0(R15)
         LA    R4,1(R5,R4)              -> NEXT LINE LOC
         ST    R4,QDNEXT                UPDATE PTR TO NEXT LINE LOC
         MVI   QDLINECT+1,2             SET LINE COUNT
***********************************************************************
*                                                                     *
*   MOVE THE MESSAGE TO THE SCREEN                                    *
*                                                                     *
***********************************************************************
DY$ADD04 L     R4,QDNEXT                -> NEXT LINE LOCATION
         LH    R5,QDCOLS                GET LINE LENGTH
         AH    R5,QDATRNUM              ADD # OF ATTR BYTES IN LINE
         BCTR  R5,0                     -1 FOR EX
         TM    QISFLAG1,QIS1ISPF        Using ISPF DM for screen?
         BO    DY$A4ISP                 yes, so handle different
         EX    R5,DY$ADD                MVC 0(*-*,R4),QDMSG
         LA    R15,1(R5,R4)             -> NEXT LINE LOC
         ST    R15,QDNEXT               SAVE FOR NEXT TIME
         B     DY$ADD05                 handle line commands
***********************************************************************
*                                                                     *
*   MOVE THE MESSAGE TO THE SCREEN       ISPF MODE                    *
*                                                                     *
***********************************************************************
DY$A4ISP TM    QISFLAG1,QIS1TBOP        is table open?
         BO    DY$A4I1                  yes - skip create
***********************************************************************
*                                                                     *
*   DECIDE WHAT FORMAT TABLE LINES ARE FOR ISPF MODE DISPLAY          *
*                                                                     *
***********************************************************************
         LA    R3,FM#MDL                Assume it is a SEARCH
         CLC   QSUBCMD,=V(SEARCH)       did we come from SEARCH?
         BNE   DY$A4I2A                 no - so check others
         TM    QSCFLAG2,QSC2DJX         is this XJ?
         BO    DY$A4I2Z                 yes - use zz model
         CLC   QCODEH,=H'44'            is this DQ?
         BE    DY$A4I2Z                 yes - use zz model
         B     DY$A4I2                  otherwise use FM model
*
DY$A4I2A LA    R3,DD#MDL                Assume it is a DDNAME
         CLC   QSUBCMD,=V(DDNAME)       did we come from DDNAME?
         BE    DY$A4I2                  It is - Great
         LA    R3,DC#MDL                Assume it is a CPU
         CLC   QSUBCMD,=V(CPU)          did we come from CPU?
         BE    DY$A4I2                  It is - Great
*
DY$A4I2Z LA    R3,ZZ#MDL                Otherwise use simple
*
DY$A4I2  ST    R3,QMDLPT                save model address
         USNGX DY#MDL,R3
         L     R15,ISPLNK               get address of ISPLNK
         CALL  (15),(=CL8'TBCREATE',TBNAM,0,V8,=CL8'NOWRITE'),VL,      $
               MF=(E,DY@CALLP)
         L     R14,=V(ISPFERR)
         CH    R15,=H'20'               severe error???
         BL    *+6                      no skip call
         BALR  R15,R14                  tell about it
*
         L     R15,ISPLNK               get address of ISPLNK
         CALL  (15),(=CL8'VREPLACE',=CL8'QZVARS',=F'30',DY#MVAR),VL,   $
               MF=(E,DY@CALLP)          panel will set ZVARS from this
*
         L     R15,ISPLNK               get address of ISPLNK
         CALL  (15),(=CL8'VREPLACE',=CL8'QMDL',=F'80',DY#MLN),VL,      $
               MF=(E,DY@CALLP)          set model line
*
         OI    QISFLAG1,QIS1TBOP        mark table open
         DROPX R3
***********************************************************************
*                                                                     *
*   ISPF Table is now open so add line to it for display              *
*                                                                     *
***********************************************************************
DY$A4I1  LA    R3,1(,R5)                back out BCTR and move to mod
         LA    R1,QDMSG                 POINT AT LINES
*   R1 -> line to output
*   R3 == length of line to output (w/ attr bytes)
         LA    R7,VLEN8                 POINT AT LENGTH FIELDS
         LA    R6,V8VAR                 POINT AT STRUCTURE
         MVI   0(R6),C' '               BLANK OUT ALL VARS
         MVC   1(256,R6),0(R6)
         MVC   256+1(QF7+L'QF7-V8VAR-1-256,R6),256(R6)
*
*   save line command entry if any
*
         XC    DY@TRTAB(LCBELEN),DY@TRTAB  clear area
         LA    R15,DY@TRTAB             point at dummy
         OC    QDLCTBL,QDLCTBL          any line command table?
         BZ    DY$ILCE                  nope - leave as dummy
         OC    DY@TPTR,DY@TPTR          any input entry?
         BZ    DY$ILCE                  nope - leave as dummy
         L     R15,DY@TPTR              point at supplied entry
*
DY$ILCE  MVC   0(LCBELEN,R6),0(R15)     move in entry
         LR    R2,R6                    save lcb addr
         A     R6,0(,R7)                add in length
         LA    R7,4(,R7)                point to next entry
         USNGX LCBUFF,R2
         L     R15,LCBADDR1             get offset
         BAL   R8,DY$ILADR              update LCB address
         ST    R15,LCBADDR1             set addr of variable
         L     R15,LCBADDR2             get offset
         BAL   R8,DY$ILADR              update LCB address
         ST    R15,LCBADDR2             set addr of variable
         DROPX R2
*
*   if current model is ZZ then force all segments into first
*   variable
*
* at this point
*   r1 -> line to output
*   r3 == length of line to output (w/ attr bytes)
*   r6 -> first line variable to output to
*   r7 -> length array of each variable
*
         CLC   QMDLPT(4),=A(ZZ#MDL)     current model ZZ?
         BNE   DY$MFLD                  no so split by set fields
         SH    R3,QDATRNUM              get machine line length
         LA    R3,1(,R3)                get true line length
         C     R3,0(,R7)                check real len of field
         BNH   *+8
         L     R3,0(,R7)                get smaller length
*
DY$SF1   CLI   0(R1),X'1D'
         BE    DY$SF3
         MVC   0(1,R6),0(R1)            move in data
*
DY$SF2   LA    R1,1(,R1)                bump input pointer
         LA    R6,1(,R6)                bump output pointer
         BCT   R3,DY$SF1
         B     DY$TBADD                 go add line to table
*
DY$SF3   MVI   0(R6),C' '               put in blank for attr
         LA    R1,1(,R1)                bump input over start fld
         B     DY$SF2                   go and try again
*
*   multi-field model line, does number of attrs in input line
*         match number of fields in model?
*
DY$MFLD  DS    0H
         L     R2,QMDLPT                point at model info
         USNGX DY#MDL,R2
         CLC   QDATRNUM,DY#MCNT+2       compare field counts
         BE    DY$MFLDP                 yes - does match
         CLI   0(R1),X'1D'              IS FIRST BYTE A SF
         BNE   *+12     >=======+
         LA    R1,2(,R1)        |       BUMP PAST FIRST SF,ATTR
         SH    R3,=H'1'         |       CORRECT LENGTH
         SH    R3,QDATRNUM    <=+       get machine line length
         LA    R3,1(,R3)                get true line length
         LR    R15,R6                   temp output addr reg
         C     R3,0(,R7)                check real len of field
         BNH   DY$MF1
         L     R3,0(,R7)                get smaller length
*
DY$MF1   CLI   0(R1),X'1D'
         BE    DY$MF3
         MVC   0(1,R15),0(R1)           move in data
*
DY$MF2   LA    R1,1(,R1)                bump input pointer
         LA    R15,1(,R15)              bump output pointer
         BCT   R3,DY$MF1
         B     DY$MF4                   go add line to table
*
DY$MF3   MVI   0(R15),C' '              put in blank for attr
         LA    R1,1(,R1)                bump input over start fld
         B     DY$MF2                   go and try again
*
DY$MF4   LA    R14,DY#MLEN              point at field lengths
         LR    R15,R6                   get moving pointer
         A     R15,0(,R14)              skip first variable
         A     R6,0(,R7)                bump output string pointer
         LA    R15,1(,R15)              skip over attr loc
*
DY$MF5   LA    R7,4(,R7)                bump pointer
         LA    R14,4(,R14)              bump pointer
         L     R2,0(,R14)               get next len
         LTR   R2,R2                    all done?
         BZ    DY$TBADD                 yes - exit
         BCTR  R2,0                     get machine len
         EX    R2,DY$MMVC               move in data
         A     R6,0(,R7)                bump output var pointer
         LA    R15,2(R2,R15)            bump input string ptr
         B     DY$MF5                   keep going
         DROPX R2
*
*   now parse input line into table variables
*
DY$MFLDP CLI   0(R1),X'1D'              IS FIRST BYTE A SF?
         BNE   DY$ALP
         LA    R1,2(,R1)                BUMP PAST FIRST SF,ATTR
         SH    R3,=H'2'                 CORRECT LENGTH
*
DY$ALP   LR    R2,R1                    SET START ADDR
*
DY$LP    CLI   0(R2),X'1D'              IS THIS NEXT SF?
         BE    DY$LP1
         LA    R2,1(,R2)                BUMP INPUT ADDRESS
         BCT   R3,DY$LP
*
DY$LP1   SR    R2,R1                    GET LENGTH TO NEXT SF
         L     R5,0(,R7)                GET TRUE LENGTH
         LR    R15,R2                   GET LENGTH OF DATA TO MOVE
         CR    R15,R5                   IS IT TOO BIG?
         BNH   DY$LP2
         LR    R15,R5                   SET TO MAX IN FIELD
*
DY$LP2   BCTR  R15,0                    GET MACHINE LENGTH
         EX    R15,DY$IMVC              MOVE IN DATA
         LA    R6,0(R5,R6)              BUMP OUTPUT ADDRESS
         LA    R7,4(,R7)                MOVE LENGTH POINTER
         LA    R1,2(R2,R1)              BUMP INPUT ADDRESS
         LR    R2,R1                    GET START ADDR
         SH    R3,=H'2'                 ACCOUNT FOR SF,ATTR
         BP    DY$LP
         LA    R2,QLCBE                 POINT AT MY LCB BLOCK
         USNGX LCBUFF,R2
         ICM   R15,B'1111',LCBADDR1     Any value?
         BZ    *+10                     No - skip
         MVC   LCBFLD1,0(R15)           Move in orig data
         ICM   R15,B'1111',LCBADDR2     Any value?
         BZ    *+10                     No - skip
         MVC   LCBFLD2,0(R15)           Move in orig data
         DROPX R2                       LCBUFF
*
*  put in table
*
DY$TBADD L     R15,ISPLNK               -> ISPLINK
         CALL  (15),(=CL8'TBADD',TBNAM),VL,                            $
               MF=(E,DY@CALLP)
         L     R14,=V(ISPFERR)
         CH    R15,=H'20'               severe error???
         BL    *+6                      no - skip call
         BALR  R15,R14                  tell about it
         MVC   QDMSG,QBLANK             CLEAR THE MSG WORK AREA
         B     DY$NAUPD                 exit
         SPACE 2
DY$MMVC  MVC   0(0,R6),0(R15)           << executed >>
DY$IMVC  MVC   0(0,R6),0(R1)            << executed >>
         SPACE 2
***********************************************************************
*                                                                     *
*   Setup for possible line commands                                  *
*      R4 ->  line address                                            *
*      R5 ==  line length + number of attribute bytes                 *
*                                                                     *
***********************************************************************
DY$ADD05 MVC   QDMSG,QBLANK             CLEAR THE MSG WORK AREA
         OC    QDLCTBL,QDLCTBL          ANY LINE COMMANDS TABLE?
         BZ    DY$NAUPD                 NO - SKIP ARRAY UPDATE
         L     R15,DY@TPTR              GET SAVED POINTER
         LTR   R15,R15                  ANYTHING?
         BZ    DY$NAUPD                 NO - SKIP ARRAY UPDATE
         LH    R1,QDLINECT              GET CURRENT LINE COUNT
         BCTR  R1,0                     MAKE LINE COUNT ORIGIN 0
         MH    R1,=Y(LCBELEN)           OFFSET OF ARRAY ELEMENT
         AL    R1,QVLCBUF               -> ARRAY ELEMENT
         USNGX LCBUFF,R1
         MVC   0(LCBELEN,R1),0(R15)     SAVE THE ARRAY ELEMENT
         ICM   R0,B'1111',LCBADDR1      GET OFFSET OF FIRST INPUT FIELD
         BZ    *+10    >======+         SKIP IF NOT SUPPLIED
         AR    R0,R4          |         RELOCATE
         ST    R0,LCBADDR1    V         SAVE UPDATED ADDRESS
         ICM   R0,B'1111',LCBADDR2      GET OFFSET OF SECOND INPUT FLD
         BZ    *+10    >======+         SKIP IF NOT SUPPLIED
         AR    R0,R4          |         RELOCATE
         ST    R0,LCBADDR2    V         SAVE UPDATED ADDRESS
         DROPX R1                       LCBUFF
***********************************************************************
*                                                                     *
*   FINISH WITH ADD BY CHECKING IF NEW HEADER IS REQUESTED            *
*                                                                     *
***********************************************************************
DY$NAUPD XC    QDATRNUM,QDATRNUM        NOW NO ATTR BYTES IN LINE
         TM    QFLAG1,Q1MVHDR           "MOVE HEADER" REQUESTED?
         BNO   QSTOP                    NO - SO DON'T
         L     R1,QVHLINE               -> WHERE IT GOES
         LH    R5,QDCOLS                GET LINE LENGTH
         BCTR  R5,0                     get machine length
         BCTR  R5,0                     END OF THIS LINE HAS ATTR BYTE
         EX    R5,DY$MVHDR              MOVE IT TO SCREEN BUFFER
         NI    QFLAG1,255-Q1MVHDR       RESET FLAG
         TM    QISFLAG1,QIS1ISPF        Using ISPF DM for screen?
         BZ    QSTOP                    no - all done
         LA    R15,QDHLINE              Address of area
         AH    R15,QDCOLS                Plus number of cols
         BCTR  R15,0                    Go to last real column
         MVI   0(R15),C' '              set to blank
         LA    R15,ZZ#MDL               get addr of simple model
         C     R15,QMDLPT               see if simple is current
         BE    DY$ADJ                   yes, so adjust hdr
         LA    R15,DC#MDL               get addr of DC/CPU model
         C     R15,QMDLPT               see if this is current
         BNE   QSTOP                    no, so all done
*
DY$ADJ   LA    R5,1(,R5)                update count
         EX    R5,DY$MVHDR              move in data one way
         EX    R5,DY$MVHD1              move in data the other
         MVI   QDHLINE,C' '             blank out first char
         B     QSTOP                    RETURN TO CALLER
         SPACE 1
DY$SCMVC MVC   0(*-*,R4),0(R15)         << EXECUTED >>
DY$ADD   MVC   0(*-*,R4),QDMSG          << EXECUTED >>
DY$MVHDR MVC   0(*-*,R1),QDHLINE        << EXECUTED >>
DY$MVHD1 MVC   QDHLINE+1(*-*),0(R1)     << EXECUTED >>
***********************************************************************
*                                                                     *
*   WRITE A FULL SCREEN, WAIT FOR REPLY                               *
*                                                                     *
***********************************************************************
DY$FULL  LA    R15,QDTOP-8-7            -> AREA-LINELEN FOR ' *MORE'
         AH    R15,QDCOLS               -> AREA FOR ' *MORE*'
         MVC   0(7,R15),=C' *MORE*'     INDICATE SCREEN OVERFLOW
         SPACE 2
DY$WRITE TM    QISFLAG1,QIS1ISPF        in ISPF?
         BO    Q5ISPF2                  yes
         TM    QFLAG1,Q1MVHDR           "MOVE HEADER" REQUESTED?
         BNO   DY$NMVHD                 NO - SKIP
         L     R1,QVHLINE               -> WHERE IT GOES
         LH    R14,QDCOLS               GET LINE LENGTH
         BCTR  R14,0                    -1 FOR ATTR BYTE AT END OF LINE
         BCTR  R14,0                    -1 FOR EX
         EX    R14,DY$MVHDR             MVC 0(*-*,R1),QDHLINE
         NI    QFLAG1,255-Q1MVHDR       RESET FLAG
         SPACE 1
DY$NMVHD CLI   QDHLINE,C'*'             ERROR MESSAGE?
         BNE   DY$NALRM                 NO - SKIP
         TM    QMODE1,QM1BEEP           WANT NOISE?
         BNO   DY$NALRM                 NO - SKIP
         OI    QDWCC,X'04'              YES - SET "ALARM"
         SPACE 1
DY$NALRM TM    QSCFLAG1,QSC1JOB         NEED JOBID ON TOP LINE?
         BNO   DY$NOJOB                 NO - SKIP
         MVI   QDTOP,C' '
         MVC   QDTOP+1(L'QDHJOBID+1),QDHJOBID  'JOBNAMEX(JOBNNNNN) '
         SPACE 1
DY$NOJOB LA    R14,QDTOP-8-7-12         point at area
         AH    R14,QDCOLS               space over line
         MVC   0(13,R14),=C' C=XXX P=XXX ' set constant
         L     R1,16                    -> CVT
         TM    QMISCFLG,QMFMVSE         IS THIS MVS-XA?
         BNO   DY$NXA8                  no - skip
         L     R1,604(,R1)              -> RMCT
         L     R1,228(,R1)              -> OF RCT
***      A     R1,=A(56-64)             OFFSET FOR XA
         LH    R15,56(,R1)              get RCTCPUA FIELD
         LH    R0,66(,R1)
         B     DY$YXA8
*
DY$NXA8  DS    0H
         L     R1,604(,R1)              -> RMCT
         L     R1,228(,R1)              -> RCT
         LH    R15,64(,R1)              get RCTCPUA FIELD
         LH    R0,74(,R1)
*
DY$YXA8  DS    0H
***      LH    R15,64(,R1)              get RCTCPUA FIELD
         SRL   R15,4                    GET VALUE
         CVD   R15,QNUMWORK
         UNPK  3(3,R14),QNUMWORK(8)
         OI    5(R14),X'F0'
***      LH    R15,74(,R1)
         CVD   R0,QNUMWORK
         UNPK  9(3,R14),QNUMWORK(8)
         OI    11(R14),X'F0'
         SPACE 1
         L     R1,QVINPUT               -> input area on scr
         BCTR  R1,0                     -> to attribute byte
         MVI   0(R1),X'C8'              set to input, bright
         TM    QSCFLAG1,QSC1PMPT        PROMPT WITH LAST INPUT COMMAND?
         BNO   DY$NPMPT                 NO - SKIP
         NI    QSCFLAG1,255-QSC1PMPT    YES - RESET FLAG
         MVI   0(R1),X'C9'              set to input, bright,mdt
         MVC   1(QDREPLYL,R1),QDPROMPT  MOVE IN LAST COMMAND
         SPACE 1
DY$NPMPT TM    QTERMFLG,QTFTTY          IS TERMINAL A VIDEO?
         BO    DY$TTY                   NO - USE ALTERNATE ROUTINE
*--- SEE IF RA OR SBA SUFFIX ALREADY EXISTS IN BUFFER              ---*
         L     R1,QDENDPTR              -> PAST POSSIBLE IC AT END
         LR    R0,R1                    COPY PTR
         SH    R1,=H'4'                 BACK UP TO START OF SBA/IC SEQ
         LTR   R0,R0                    ANY?
         BNZ   DY$TPUT                  YES - ALL SET
         L     R15,QDNEXT               -> NEXT OUTPUT LOC
         CLC   QDLINECT,QDROWS          SCREEN FULL?
         BNE   DY$BSCAN                 NO - BACKSCAN FOR BLANKS
*--- LAST LINE OF SCREEN HAS DATA ON IT -- SEE IF ROOM FOR RA      ---*
         LR    R1,R15                   COPY PTR PAST LAST CHAR
         SH    R15,=H'4'                BACK UP
         CLC   0(4,R15),QBLANK          LAST 4 CHARS BLANK?
         BNE   DY$TPUT                  NO - LEAVE AS IS
         SPACE 2
*--- BACKSCAN FOR LAST NON-BLANK                                   ---*
DY$BSCAN BCTR  R15,0                    BACK UP TO LAST CHAR USED
         BALR  R14,0                    SET LOOP ADDR
         CLI   0(R15),C' '  <==+        FIND NON-BLANK?
         BNE   *+6     >=======|==+     YES - EXIT LOOP
         BCTR  R15,R14   >=====+  V     NO - KEEP LOOKING
         MVC   1(4,R15),=X'3C404000'    MOVE IN THE RA SEQUENCE
         LA    R1,1+4(,R15)             SKIP OVER IT
         SPACE 2
DY$TPUT  TM    QISFLAG1,QIS1ISPF        in ISPF?
         BO    Q5ISPF2                  yes
         BAL   R8,DY$SETCP              SET SBA/IC SEQUENCE
         ST    R1,QDENDPTR              -> SAVE PTR PAST IC
         SPACE 2
RESHOW   LA    R3,QDSCREEN              LOAD ADDRESS OF SCREEN BUFFER
         L     R2,QDENDPTR              -> LAST BYTE+1 OF STREAM
         SR    R2,R3                    COMPUTE TPUT LENGTH
         B     RESHOW01                 SKIP AROUND
         SPACE 1
RESHOW00 MVC   QD3270OP,QDERASE         SET WRITE OP TO ERASE WRITE
         TM    QTERMFLG,QTFVTAM         BUT IS IT A VTAM TERMINAL?
         BO    RESHOW01                 YES - ERASE WRITE IS OK
         MVI   QD3270OP,X'F1'           NO - TCAM REQUIRES NORMAL ...
*                                       ... WRITE TO KEEP BMD'S ...
*                                       ... ZAPPED TCAM FROM PUKING.
*---  IF ACF/TCAM SUPPORTS LARGER SCREEN SIZES, THE CODE ABOVE     ---*
*---  WILL PROBABLY NEED TO BE DISABLED.  I DON'T KNOW ANYTHING    ---*
*---  ABOUT ACF/TCAM...                                            ---*
RESHOW01 L     R1,QVINPUT               -> FIRST CHAR (BXH STOP ADDR)
         LA    R15,QDREPLYL-1(,R1)      -> END OF REPLY INPUT AREA
         SR    R0,R0                    BXH ...
         BCTR  R0,0                     ... DECREMENT
         SPACE 1
RESHOW02 CLI   0(R15),C' '              FIND END?
         BNE   RESHOW03                 YES - DISPLAY THE RESULT
         MVI   0(R15),X'00'             CHANGE TRAILING BLANK TO NULL
         BXH   R15,R0,RESHOW02          BACKSCAN THE WHOLE THING
         SPACE 1
RESHOW03 TM    QFLAG2,Q2SHORT           SHORT WRITE REQUESTED?
         BNO   TPUTFULL                 NO - GO DO FULL WRITE
         OI    DY@FLAG,DY@SHORT         in validation (short)
         NI    QFLAG2,255-Q2SHORT       RESET FLAG
         LA    R1,QDSCREEN              addressability probs
         MVC   DY@TEMP(256),0(R1)       COPY ENOUGH OF THE SCREEN...
         MVC   DY@TEMP+256(256),256(R1)       ...TO INSURE THAT WE ...
*                                          ... HAVE THE FIRST 3 LINES
         L     R1,QVLINE1               -> FIRST DATA LINE IN REAL BUFF
         SR    R1,R3                    COMPUTE OFFSET OF 1ST DATA LINE
         LA    R0,DY@TEMP               -> TPUT BUFFER FOR SHORT WRITE
         AR    R1,R0                    OFFSET OF 1ST DATA LINE IN ...
*                                       ... BUFFER FOR SHORT WRITE
         SH    R1,=H'2'                 BACK UP OVER TRAILING ATTR BYTE
         OC    DY@CURS,DY@CURS          ANY CURSOR POSITION SPECIFIED?
         BNZ   RESHOW04                 YES - USE IT
         LH    R14,QDCOLNOW             NO - PUT IT ON COL 14 OF LINE 2
         LA    R14,14-1(,R14)           ... USING LINE LENGTH OF LAST
         STH   R14,DY@CURS              ... SCREEN WRITTEN
         SPACE 1
RESHOW04 BAL   R8,DY$SETCP              SET SBA/IC SEQUENCE
         SR    R1,R0                    COMPUTE SHORT TPUT LENGTH
         LR    R15,R1                   MOVE LENGTH TO TEMP REG
         LR    R1,R0                    MOVE ADDR TO CORRECT REG
         LR    R0,R15                   MOVE LENGTH TO CORRECT REG
         B     TPUT$NOW                 GO DO IT
         SPACE 2
TPUTFULL LR    R1,R3                    GET THE ADDRESS
         LR    R0,R2                    GET THE LENGTH
         SPACE 2
TPUT$NOW ICM   R1,B'1000',=X'03'        GET FULLSCR FLAG
         TPUT  (1),(0),R                WRITE SCREEN
         MVI   QD3270OP,X'F1'           SET WRITE OPCODE TO STD WRITE
         MVC   QDCOLNOW,QDCOLS          SHOW CURRENT SCREEN LINE LENGTH
         LA    R14,DY@INPUT             -> INPUT BUFFER
         LA    R15,L'DY@INPUT           LENGTH
         L     R1,=X'40000000'          GET SOURCE LENGTH, PAD CHAR
         MVCL  R14,R0                   FILL INPUT BUFFER WITH BLANKS
         MVC   QDREPLY,QBLANK
         MVC   QERRMSG,QBLANK
         LA    R1,DY@INPUT              LOAD ADDRESS OF REPLY AREA
         LA    R0,L'DY@INPUT            LENGTH OF INPUT BUFFER
         SPACE 1
         TGET  (1),(0),ASIS             WAIT FOR REPLY
         CLI   DY@AID,X'6B'             PA3? (TCAM10 RESHOW)
         BNE   *+8                      NO - SKIP
         MVI   DY@AID,X'6E'             YES - CHANGE TO VTAM RESHOW
         LR    R4,R1                    SAVE THE INPUT LENGTH
         CH    R15,=H'8'                ATTN?
         BE    RESHOW00                 YES
         CLI   DY@AID,X'6E'             PA2? (RESHOW)
         BE    DY$TCLRQ                 YES - GO FLUSH REST OF INPUT
         SPACE 1
TGET$CHK NI    QDWCC,255-X'04'          RESET "ALARM"
         CH    R15,=H'12'               INPUT LONGER THAN BUFFER?
         BNE   DY$NOCLR                 NO. CONTINUE.
         SPACE 1
DY$TCLRQ TCLEARQ INPUT                  CLEAR THE QUEUE
         SPACE 1
         CLI   DY@AID,X'6E'             PA2? (RESHOW)
         BE    RESHOW00                 YES - RE-DISPLAY LAST SCREEN
         SPACE 2
DY$NOCLR OI    QFLAG2,Q2NEWSCR          INDICATE NEXT OUTPUT LINE IS 1
         L     R1,QVINPUT               -> INPUT AREA ON SCREEN
         XC    0(QDREPLYL,R1),0(R1)     CLEAR IT
         LA    R15,DY@INPUT(R4)         -> PAST LAST INPUT CHAR
         MVI   0(R15),X'11'             PUT IN PHONY ENDING TO STOP TRT
         CLI   DY@INPUT+3,X'11'         DOES INPUT START WITH SBA?
         BNE   DY$ERROR                 NO - SCREEN FORMAT ERROR
         XC    DY@TRTAB,DY@TRTAB        CLEAR TRTAB
         MVI   DY@TRTAB+X'11',4         SET TO STOP ON SBA
         MVC   DY@PCMD,QBLANK           NO PRIMARY COMMAND YET
         XC    DY@PCLEN,DY@PCLEN        ...
         LA    R3,DY@INPUT+3+1          -> FIRST TEXT CHARACTER
         SH    R4,=H'3'                 ACCOUNT FOR AID, CURPOS
* %%%    BNP   DY$PC$GO                 NO INPUT
         BNP   DY$LC$CZ                 see if old line cmds
*---  FIXED LENGTH TRT IS OK BECAUSE NO INPUT FIELD IS LONGER THAN ---*
*---  QDREPLY (66), AND WE WILL HIT THE EXTRA SBA PREVIOUSLY SET   ---*
*---  DOWN.                                                        ---*
         SR    R1,R1                    CLEAR FOR IC
DY$FLOOP TRT   2(80,R3),DY@TRTAB        FIND AN SBA
         BZ    DY$ERROR                 NONE???
         MVC   DY@FIELD,QBLANK          CLEAR WORK FIELD
         SR    R1,R3                    COMPUTE FIELD LENGTH
         SH    R1,=H'3'                 -1 FOR EX, -2 FOR LOC
         BM    *+8
         EX    R1,DY$FMVC               MOVE TO DY@FIELD
*---  LEFT JUSTIFY THE DATA IN DY@FIELD                            ---*
         CLC   DY@FIELD,QBLANK          ANYTHING HERE AT ALL?
         BE    DY$FNONE                 NO - SKIP
DY$FLEFT CLI   DY@FIELD,C' '            LEFT JUSTIFIED?
         BNE   DY$FNONE                 YES - CONTINUE
         MVC   DY@FIELD(L'DY@FIELD-1),DY@FIELD+1   NO - SHIFT IT OVER
         MVI   DY@FIELD+L'DY@FIELD-1,C' '  CLEAR THE OPENED UP HOLE
         B     DY$FLEFT                 KEEP SHIFTING
         SPACE 1
DY$FNONE LA    R1,1(,R1)                GET FIELD LENGTH
         NC    0(2,R3),=X'3F3F'         MAKE TWO 6-BIT BYTES
         SR    R14,R14                  CLEAR FOR IC
         IC    R14,0(,R3)               GET HIGH ORDER 6 BITS OF ADDR
         SLL   R14,6                    ADJUST
         SR    R15,R15                  CLEAR FOR IC
         IC    R15,1(,R3)               GET LOW ORDER 6 BITS OF ADDR
         OR    R15,R14                  GET FIELD LOCATION
         SR    R14,R14                  CLEAR FOR DIVIDE
         LH    R0,QDCOLS                GET LINE LENGTH
         DR    R14,R0                   COMPUTE LINE NUMBER
         CH    R15,=H'1'                SECOND SCREEN LINE?
*%%%     BNE   DY$FSEL                  NO - MUST BE A SELECT LINE
         BH    DY$FSEL                  NO - MUST BE A SELECT LINE
         STH   R1,DY@PCLEN              SAVE LENGTH OF PRIMARY COMMAND
         MVC   DY@PCMD,DY@FIELD         SAVE PRIMARY COMMAND
         CLC   DY@FIELD,QBLANK          IS LINE BLANK??
         BNE   DY$FNEXT                 NO - GO AND DO NEXT FLD
         XC    DY@PCLEN,DY@PCLEN        SET LEN = 0 FOR BLANK
         SPACE 2
DY$FNEXT LA    R3,3(R1,R3)              -> PAST SBA OF NEXT FIELD
         SR    R4,R1                    COMPUTE...
         SH    R4,=H'3'                 ... REMAINING LENGTH
         BP    DY$FLOOP                 PROCESS IT
         SPACE 2
*---  SEE IF ANY LINE COMMANDS PRESENT                             ---*
DY$LC$CZ TM    DY@FLAG,DY@SHORT         in validation??
         BO    DY$PC$GO                 yes - look at prim
         L     R2,QVLCBUF               -> LINE COMMAND BUFFER
         LA    R0,43-3                  NUMBER OF ARRAY ELEMENTS
         USNGX LCBUFF,R2
DY$LC$L1 CLI   LCBFLD1,C' '             ANYTHING HERE?
         BH    DY$LC$EX                 YES - GO CHECK IT
         LA    R2,LCBELEN(,R2)          -> NEXT BUFFER ARRAY ELEMENT
         BCT   R0,DY$LC$L1              KEEP LOOKING
*---  NO LINE COMMANDS ENTERED - EXECUTE PRIMARY COMMAND, IF ANY   ---*
         MVC   QDREPLY,DY@PCMD          NO - GET PRIMARY LINE CMD
         MVC   QDRLNG,DY@PCLEN          ... AND ITS LENGTH
         B     DY$PC$GO                 GO EXECUTE IT
         SPACE 1
         DROPX R2                       LCBUFF
         SPACE 1
DY$FMVC  MVC   DY@FIELD(*-*),2(R3)      << EXECUTED >>
         SPACE 3
*---  STORE LINE COMMANDS                                          ---*
DY$FSEL  LR    R0,R15                   COPY LINE NUMBER
         SH    R15,=H'3'                ADJUST - FIRST IS ON LINE 4
*                                       (R15 WAS ORIGIN 0)
         BM    DY$ERR2                  LOGIC ERROR
         MH    R15,=Y(LCBELEN)          OFFSET OF LINE CMD TABLE ENTRY
         AL    R15,QVLCBUF              -> CORRECT ARRAY ELEMENT
         USNGX LCBUFF,R15
         CH    R14,=H'1'                FIELD AT LEFT SIDE OF SCREEN?
         BE    DY$FCMD                  YES - MUST BE SUBCOMMAND NAME
         MVC   LCBFLD2,DY@FIELD         SET OPERAND IN LINE CMD TABLE
         OC    LCBFLD2,QBLANK           MAKE IT UPPER CASE
         ICM   R14,B'1111',LCBADDR2     GET OPERAND LOC IN SCREEN BUFF
         BZ    DY$FNEXT                 SKIP IF NOT SUPPLIED
         MVC   0(8,R14),DY@FIELD        OPRND TO SCREEN IN CASE RESHOW
         B     DY$FNEXT                 PROCESS NEXT INPUT FIELD
         SPACE 1
DY$FCMD  XC    LCBTPTR,LCBTPTR          CLEAR CMD TABLE ENTRY POINTER
         MVC   LCBFLD1,DY@FIELD         SET CMDNAME IN LINE CMD TABLE
         OC    LCBFLD1,QBLANK           MAKE IT UPPER CASE
         ICM   R14,B'1111',LCBADDR1     GET CMDNAME LOC IN SCREEN BUFF
         BZ    DY$FNEXT                 SKIP IF NOT SUPPLIED
         MVC   0(2,R14),DY@FIELD        CMD TO SCREEN IN CASE RESHOW
         B     DY$FNEXT                 PROCESS NEXT FIELD
         SPACE 1
         DROPX R15                      LCBUFF
         SPACE 2
DY$ERR2  L     R0,=C'DY2 '              SET LOGIC ERROR CODE
         L     R15,=V(LOGICERR)         -> ROUTINE
         BALR  R14,R15                  GO TO IT (NO RETURN)
         SPACE 2
DY$ERR3  L     R0,=C'DY3 '              SET LOGIC ERROR CODE
         L     R15,=V(LOGICERR)         -> ROUTINE
         BALR  R14,R15                  GO TO IT (NO RETURN)
         SPACE 3
*---  CHECK FOR PROBLEMS WITH LINE COMMANDS                        ---*
         USNGX LCBUFF,R2
DY$LC$EX OC    DY@PCLEN,DY@PCLEN        ANY PRIMARY COMMAND ENTERED?
         BNZ   DY$LC$E1                 YES - GENERATE ERROR MSG
         NI    DY@FLAG,255-DY@DCMD      NO DESTRUCTIVE CMD FOUND YET
*---  FIND THE LINE COMMAND TABLE ENTRY                            ---*
DY$LC$CK CLI   LCBFLD1,C' '             ANYTHING HERE?
         BNH   DY$LC$L3                 NO - SKIP THIS ENTRY
         L     R1,QDLCTBL               -> LINE CMD TABLE
         LTR   R1,R1                    ANY?
         BZ    DY$ERR3                  NO - ERROR
         SPACE 1
         USNGX LCTABLE,R1
DY$LC$L2 CLC   LCBFLD1,LCTCMDNM         THIS IT?
         BE    DY$LCGOT                 YES
         LA    R1,LCTELEN(,R1)          -> NEXT TABLE ENTRY
         CLI   0(R1),X'FF'              END OF TABLE?
         BNE   DY$LC$L2                 NO - KEEP LOOKING
         SPACE 1
*---  LINE COMMAND IS INVALID                                      ---*
DY$INVLC MVC   QDHLINE,QBLANK           CLEAR ERROR MSG AREA
         MVC   QDHLINE(33),=C'*** LINE COMMAND "XX" INVALID ***'
         MVC   QDHLINE+18(2),LCBFLD1    FILL IN BAD COMMAND NAME
         SPACE 1
*---  LINE COMMAND ERROR - SET CURSOR POSITION                     ---*
DY$LC$ER LA    R14,43                   COMPUTE LINE NUMBER ...
         SR    R14,R0                   ... OF BAD COMMAND
         MH    R14,QDCOLS               MAKE IT SCREEN POSITION
         LA    R14,1(,R14)              MAKE IT COLUMN 2
         STH   R14,DY@CURS              SAVE FOR COMPUTE
         OI    QFLAG1,Q1MVHDR           REQUEST "MOVE HEADER"
         B     DY$WRITE                 GO RE-WRITE THE SCREEN
         SPACE 1
DY$LCGOT TM    LCTFLAGS,LCTFPRIV        PRIV CMD?
         BNO   *+12     >========+      NO - OK
         TM    QXAUTH,QXAUTHX    |      PRIV USER?
         BZ    DY$INVLC          |      NO - SAY INVALID COMMAND
         ST    R1,LCBTPTR   <====+      SAVE IN LINE CMD BUFFER
         TM    LCTFLAGS,LCTFDCMD        IS THIS A DESTRUCTIVE COMMAND?
         BNO   DY$LC$L3                 NO - SKIP
         TM    DY@FLAG,DY@DCMD          ALREADY HIT DESTRUCTIVE CMD?
         BO    DY$LC$E2                 YES - CONFLICT
         OI    DY@FLAG,DY@DCMD          REMEMBER DESTRUCTIVE CMD FOUND
DY$LC$L3 LA    R2,LCBELEN(,R2)          -> NEXT BUFFER ARRAY ELEMENT
         BCT   R0,DY$LC$CK              CHECK ALL ELEMENTS
         SPACE 2
*---  RETURN TO MAINLINE TO EXECUTE LINE COMMANDS                  ---*
         QNEWCMD  LINE                  from dispaly
         SPACE 1
         DROPX R2,R1                    LCBUFF, LCTABLE
         SPACE 3
DY$LC$E1 MVC   QDHLINE,QBLANK           CLEAR ERROR MSG AREA
         MVC   QDHLINE(56),=C'*** PRIMARY AND LINE COMMANDS ARE MUTUALL$
               Y EXCLUSIVE ***'
         OI    QFLAG1,Q1MVHDR           REQUEST "MOVE HEADER"
         OI    QSCFLAG1,QSC1PMPT        reprompt
         MVC   QDPROMPT,DY@PCMD         set prompt as new prim
         B     DY$WRITE                 GO RE-WRITE THE SCREEN
         SPACE 2
DY$LC$E2 MVC   QDHLINE,QBLANK           CLEAR ERROR MSG AREA
         MVC   QDHLINE(29),=C'*** LINE COMMAND CONFLICT ***'
         B     DY$LC$ER                 GO SET UP FOR RE-WRITE
         SPACE 3
*  REGISTER USAGE:
*    R6 -> NEXT LOC IN QDREPLY
*    R5  - LENGTH CURRENTLY IN QDREPLY
*    R4  - LENGTH REMAINING IN INPUT STREAM
*    R1  - LOW NIBBLE OF AID
DY$PC$GO LH    R4,DY@PCLEN              GET LENGTH OF PRIMARY COMMAND
         LA    R6,QDREPLY               %%%
         XR    R5,R5                    INITIAL "LENGTH IN QDREPLY"
         LA    R15,QDREPLYL-1           GET LENGTH TO MOVE (EX LEN)
         IC    R1,DY@AID                GET AID
         N     R1,=X'0000000F'          EXTRACT PF-KEY NUMBER
         CH    R1,=H'12'
         BH    DY$ENTER                 "ENTER" KEY
         TM    QMODE1,QM1PFK24          24 UNIQUE PFKEYS IN USE?
         BNO   DY$PFK12                 NO - KEEP AS 1-12
         TM    DY@AID,B'00110000'       1-12 OR 13-24???
         BO    DY$PFK12                 1-12, OK AS IS
         LA    R1,12(,R1)               ADJUST FOR 13-24
DY$PFK12 CH    R1,=H'4'                 PF4/16 (PRINT = SPF RETURN)
         BNE   DY$NOTK4                 NO - CONTINUE
         CLI   DY@PCMD,C'='             DOES HE THINK HE'S IN SPF?
         BE    DY$ENTER                 YES - DON'T COMPOUND CONFUSION
DY$NOTK4 BCTR  R1,0                     ADJUST ORIGIN
         SLL   R1,6                     MULTIPLY BY 64
         A     R1,QVPFKEYS              -> THIS PFK COMMAND
         MVC   QDREPLY(64),0(R1)        MOVE PF-KEY VALUE
         LA    R5,64                    LENGTH NOW IN QDREPLY
         LA    R6,QDREPLY+3             SKIP OVER PF KEY COMMAND
         SH    R15,=H'3'                ADJUST LENGTH LEFT TO MOVE
*Y$ENTER SH    R4,=H'3' %%%             ADJUST REMAINING INPUT LENGTH
DY$ENTER LTR   R4,R4    %%%             ANY INPUT REMAINING?
         NOPR  0        %%%
         BZ    DY$NOTXT                 SKIP IF NO OPERAND TO PFKEY
         EX    R15,DY$TXMVC             MVC 0(*-*,R6),DY@PCMD
         OC    DY@PCMD,QBLANK           TURN ALL HEX ZEROES TO BLANKS
         CLC   DY@PCMD,QBLANK           ANYTHING BESIDES NULLS & BLNKS?
         BNE   DY$3TEXT                 YES - PROCESS
         SR    R4,R4                    NOTHING CURRENTLY IN QDREPLY
         B     DY$NOTXT                 CONTINUE
         SPACE 2
DY$3TEXT LA    R5,3                     LNTH IN QDREPLY BEFORE NEW TEXT
         SPACE 1
DY$NOTXT LA    R4,0(R5,R4)              COMPUTE LENGTH IN QDREPLY
         STH   R4,QDRLNG                STORE LENGTH OF REPLY
         LTR   R4,R4                    RESPONSE FROM USER?
         BNZ   DY$INTER                 YES. INTERRUPT PROCESSING.
         MVI   QDOVER,1                 INDICATE PAGE OVERFLOW
         BAL   R8,DY$SETTL              CLEAR THE SCREEN BUFFER
         TM    DY@FLAG,DY@IMM           WAS REQUEST FOR IMMED WRITE?
         BO    QSTOP                    YES - ALL DONE
         OI    QFLAG1,Q1MVHDR           REQUEST "MOVE HEADER"
         B     DY$ADD02                 NO - MOVE SAVED LINE TO SCREEN
         SPACE 2
DY$ERROR LA    R1,=C'*** SCREEN FORMAT ERROR ***'
         LA    R0,27                    MSG LENGTH
         SPACE 1
         TPUT  (1),(0),R
         B     RESHOW                   WRITE WHOLE SCREEN AGAIN
         SPACE 2
DY$INTER L     R8,QVSAVE                -> MY SAVE AREA
         MVC   0(QSAVE1L,R8),QSAVE1     MOVE FIRST PART
         MVC   QSAVE1L(QSAVE2L,R8),QSAVE2    SECOND PART
         IC    R5,DY@AID                SAVE AID
         QCALL PARSE                    PARSE THE INPUT
         CLM   R5,B'0001',=X'7D'        ENTER?
         BNE   DY$NOT7D                 NO - DON'T SAVE CMD IN RING BUF
         L     R15,QSUBCMD              GET SUBCOMMAND EPA
         CL    R15,=A(RECALL)           "RECALL" REQUEST?
         BE    DY$NOT7D                 YES - NEVER SAVE IN RING BUFFER
         LH    R14,QCMDNUM              GET CURRENT COMMAND NUMBER
         LA    R14,1(,R14)              INCREMENT
         STH   R14,QCMDNUM              SAVE UPDATED NUMBER
         STH   R14,QRETNUM              SET NUMBER OF COMMAND TO RECALL
         N     R14,=F'15'               COMPUTE NUMBER MODULE(16)
         MH    R14,=Y(QDREPLYL)         GET OFFSET INTO RING BUFFER
         AL    R14,QVRING               -> CURRENT SLOT IN RING
         MVC   0(QDREPLYL,R14),QDREPLY  SAVE CURRENT COMMAND IN RING
DY$NOT7D TM    QFLAG1,Q1IMMED           IMMEDIATE COMMAND?
         BO    DY$IMMED                 YES - GO EXECUTE IT
         SPACE 2
*---  A NEW PRIMARY COMMAND HAS BEEN ENTERED - CLEAR ALL LINE CMDS ---*
DY$ARRGH XC    QDLCTBL,QDLCTBL          NO LINE COMMANDS VALID NOW
         L     R15,QVLCBUF              -> LINE CMD BUFFER
         USNGX LCBUFF,R15
         LA    R0,43-3                  NUMBER OF ENTRIES TO CLEAR
DY$ARG01 XC    0(LCBELEN,R15),0(R15)    CLEAR AN ENTRY
         MVI   LCBTPTR,X'80'            INDICATE NOTHING HERE
         LA    R15,LCBELEN(,R15)        -> NEXT ENTRY
         BCT   R0,DY$ARG01              CLEAR ALL ENTRIES
         DROPX R15
         MVC   QDPROMPT,QDREPLY         SAVE REPLY IN CASE REPROMPT
         QNEWCMD  PRIMARY               from dispaly
         SPACE 2
DY$IMMED L     R15,QSUBCMD              GET SUBCOMMAND EPA
         CL    R15,=A(RECALL)           "RECALL" REQUEST?
         BE    RECALL                   YES - GO THERE
         QCALL (R15)                    INVOKE IMMEDIATE SUBCOMMAND
         TM    QFLAG1,Q1IMMED           DID SUBCMD RESET "IMMEDIATE"?
         BNO   DY$ARRGH                 YES - LET MAINLINE RE-INVOKE IT
         TM    QFLAG2,Q2REPOS           REPOSITIONING SUBCOMMAND?
         MVC   QSAVE1(QSAVE1L),0(R8)    RESTORE FIRST PART
         MVC   QSAVE2(QSAVE2L),QSAVE1L(R8)      SECOND PART
         BO    DY$REPOS                 YES (REPOSITIONING SUBCOMMAND)
         TM    QTERMFLG,QTFTTY          DISPLAY TERMINAL?
         BNO   RESHOW                   YES - DISPLAY SCREEN AGAIN
         B     DYTTYTG                  NO - GO BACK TO TTY INPUT
         SPACE 2
DY$REPOS TM    QFLAG2,Q2LISTDS          ARE WE IN LISTDS?
         BO    DY$LSTDS                 YES - OK
         L     R0,=C'DY4 '              SET LOGIC ERROR CODE
         L     R15,=V(LOGICERR)         -> ROUTINE
         BALR  R14,R15                  GO TO IT (NO RETURN)
         SPACE 1
*---  SIMULATE AN "RD" COMMAND (SORT OF)                           ---*
DY$LSTDS MVC   QSUBCMD,=V(LISTDS)       FAKE THE SUBCOMMAND ADDRESS
         MVI   QCODE,99                 INDICATE REPOSITIONING
         QNEWCMD  PRIMARY               from dispaly
         SPACE 2
         ENTRY RECALL
*ECALL   LA    R1,QDPROMPT              ASSUME REGULAR RECALL REQUEST
RECALL   CLI   QKEYWORD,C' '            RECALL LAST?
         BE    RECALL$1                 RIGHT - OK
         CLI   QKEYWORD+16,C' '         A SECOND KEYWORD?
         BNE   RECALLNO                 YES - NO GOOD
         LA    R1,QFINDCMD              ASSUME RECALL LAST FIND CMD
         CLI   QKEYWORD,C'F'            RECALL LAST FIND COMMAND?
         BE    RECALLGO                 YES
         LA    R1,QTSOCMD               ASSUME RECALL LAST TSO CMD
         CLI   QKEYWORD,C'T'            RECALL LAST TSO COMMAND?
         BE    RECALLGO                 YES
         LA    R1,QINQCMD               ASSUME RECALL LAST INQUIRY
         CLI   QKEYWORD,C'I'            RECALL LAST INQUIRY COMMAND?
         BE    RECALLGO                 YES
         LA    R1,QMVSCMD               ANYTHING ELSE MUST BE MVS
         B     RECALLGO                 CONTINUE
         SPACE 1
RECALL$1 LH    R1,QRETNUM               GET COMMAND NUMBER TO RECALL
         LR    R0,R1                    COPY FOR ADJUSTMENT
         SH    R0,=H'1'                 BACK UP FOR NEXT RECALL
         BNM   *+8                      SKIP IF NOT BACK TO START
         LH    R0,QCMDNUM               ELSE RESET BACK TO TOP
         STH   R0,QRETNUM               SAVE NBR OF NEXT CMD TO RECALL
         N     R1,=F'15'                COMPUTE NUMBER MODULE(16)
         MH    R1,=Y(QDREPLYL)          GET OFFSET INTO RING
         AL    R1,QVRING                -> COMMAND TO RECALL
         SPACE 1
RECALLGO MVC   QSAVE1(QSAVE1L),0(R8)    RESTORE FIRST PART
         MVC   QSAVE2(QSAVE2L),QSAVE1L(R8)      SECOND PART
         OI    QFLAG2,Q2SHORT           INDICATE SHORT WRITE
         TM    QTERMFLG,QTFTTY          DISPLAY TERMINAL?
         BO    DY$TTYPM                 NO - ALTERNATE ROUTINE
         L     R14,QVINPUT              -> INPUT AREA ON SCREEN
         MVC   0(QDREPLYL,R14),0(R1)    COPY LAST COMMAND
         B     RESHOW                   RE-DISPLAY SCREEN
         SPACE 1
RECALLNO MVC   QDHLINE,QBLANK           CLEAR ERROR MSG AREA
         MVC   QDHLINE(27),=C'*** CONFLICTING OPTIONS ***'
         SPACE 1
DY$TILT  L     R1,QVINPUT               -> INPUT AREA ON SCREEN
         MVC   0(QDREPLYL,R1),QDREPLY   MOVE IN LAST COMMAND
         OI    QFLAG1,Q1MVHDR           REQUEST "MOVE HEADER"
         B     DY$WRITE                 FAKE QTILT
         SPACE 3
*---  SUBROUTINE TO REBUILD TOP SCREEN LINE                        ---*
DY$SETTL LH    R15,QDCOLS               GET SCREEN WIDTH
         SH    R15,=H'9'                ADJUST FOR ' QUEUE -' & EXECUTE
         EX    R15,DY$MVTOP             RESET TOP LINE TO DASHES
         BR    R8                       RETURN TO CALLER
DY$MVTOP MVC   QDTOP(*-*),QDTOP-1       << EXECUTED >>
         SPACE 3
*---  SUBROUTINE TO GENERATE 3270 CURSOR POSITION SEQUENCE         ---*
DY$SETCP MVC   0(4,R1),=X'11000013'     PUT IN SBA/IC SEQUENCE
         LH    R14,DY@CURS              GET CURSOR POSITION
         XC    DY@CURS,DY@CURS          SET TO DEFAULT NEXT TIME
         LTR   R14,R14                  ANY?
         BNZ   *+12     >=======+       YES - OK
         LA    R14,14-1         |       NO - USE COL 14 ...
         AH    R14,QDCOLS       |       ... ON LINE 2
         SRDL  R14,6     <======+       GET LOW ORDER SIX BITS IN R15
         SRL   R15,32-6                 SHIFT TO LOW END OF REGISTER
         STC   R14,1(,R1)               SET DOWN HI ORDER 6 BITS
         STC   R15,2(,R1)               SET DOWN LO ORDER 6 BITS
         TR    1(2,R1),DY#T3270         TRANSLATE TO VALID 3270 CHARS
         LA    R1,4(,R1)                BUMP OUTPUT POINTER
         BR    R8                       RETURN TO CALLER
         SPACE 3
***********************************************************************
*                                                                     *
*   WRITE A FULL SCREEN, WAIT FOR REPLY      ISPF MODE                *
*                                                                     *
***********************************************************************
Q5ISPF2  EQU   *
         L     R1,16                    -> CVT
         TM    QMISCFLG,QMFMVSE         IS THIS MVS-XA?
         BNO   NOXA3                    no - skip
         L     R1,604(,R1)              -> RMCT
         L     R1,228(,R1)              -> RCT
***      A     R1,=A(56-64)   OFFSET FOR XA
         LH    R15,56(,R1)              LOAD RCTCPUA FIELD
         LH    R0,66(,R1)
         B     YXA3
NOXA3    DS    0H
         L     R1,604(,R1)              LOAD ADDR OF RMCT
         L     R1,228(,R1)              LOAD ADDR OF RCT
         LH    R15,64(,R1)              LOAD RCTCPUA FIELD
         LH    R0,74(,R1)
YXA3     DS    0H
***      LH    R15,64(,R1)              LOAD RCTCPUA FIELD
         SRL   R15,4                    GET VALUE
         CVD   R15,QNUMWORK
         UNPK  QCPU(3),QNUMWORK(8)
         OI    QCPU+2,X'F0'
***      LH    R15,74(,R1)
         CVD   R0,QNUMWORK
         UNPK  QDPR(3),QNUMWORK(8)
         OI    QDPR+2,X'F0'
         MVC   QDHISFID(18),=18C'-'     fill with dashes
         TM    QSCFLAG1,QSC1JOB         job id ok
         BZ    DY$IDH                   no so leave as dashes
         MVC   QDHISFID,QDHJOBID        set proper jobid
*
*
*
DY$IDH   L     R4,ISPLNK                -> ISPLINK
         TM    QISFLAG1,QIS1TBOP        is table open?
         BO    DY$DSPZ                  yes - skip create
         LR    R15,R4                   -> ISPLINK
         CALL  (15),(=CL8'TBCREATE',TBNAM,0,V8,=CL8'NOWRITE'),VL,      $
               MF=(E,DY@CALLP)
         L     R14,=V(ISPFERR)
         CH    R15,=H'20'               severe error???
         BL    *+6                      no - skip call
         BALR  R15,R14                  tell about it
         LA    R5,ZZ#MDL                Use simple for no adds
         USNGX DY#MDL,R5
         LA    R6,DY#MVAR               get address of ZVARS
*  define ZVARS value
         LR    R15,R4                   -> ISPLINK
         CALL  (15),(=CL8'VREPLACE',=CL8'QZVARS',=F'30',(R6)),VL,      $
               MF=(E,DY@CALLP)
         LA    R6,DY#MLN                get address of model line
*  define table line
         LR    R15,R4                   -> ISPLINK
         CALL  (15),(=CL8'VREPLACE',=CL8'QMDL',=F'80',(R6)),VL,        $
               MF=(E,DY@CALLP)
         OI    QISFLAG1,QIS1TBOP        mark table open
         DROPX R5
***********************************************************************
*                                                                     *
*        If we need to prompt, set cmd variable.                      *
*                                                                     *
***********************************************************************
DY$DSPZ  TM    QSCFLAG1,QSC1PMPT        PROMPT WITH LAST INPUT
         BNO   DY$DSPZA                 NO - SKIP
         NI    QSCFLAG1,255-QSC1PMPT    YES - RESET FLAG
         LA    R0,QDREPLYL              maximum length
         ST    R0,DY@VLEN               set for VCOPY
         LR    R15,R4                   -> ISPLINK
         CALL  (15),(=CL8'VREPLACE',=CL8'QRPMT',DY@VLEN,QDPROMPT),VL,  $
               MF=(E,DY@CALLP)
         L     R14,=V(ISPFERR)
         CH    R15,=H'20'               severe error???
         BL    *+6                      no - skip call
         BALR  R15,R14                  tell about it
***********************************************************************
*                                                                     *
*        Now set table to top and display.                            *
*                                                                     *
***********************************************************************
DY$DSPZA DS    0H                                             A-16JUL91
         OC    QTBDROW,QTBDROW          Any row to repos to?? A-16JUL91
         BNZ   DY$DSPZB                 Yes - go and do it    A-16JUL91
         LR    R15,R4                   -> ISPLINK
         CALL  (15),(=CL8'TBTOP',TBNAM),VL,                            $
               MF=(E,DY@CALLP)
         L     R14,=V(ISPFERR)
         CH    R15,=H'20'               severe error???
         BL    *+6                      no - skip call
         BALR  R15,R14                  tell about it
         B     DY$DSPZC                 continue w/ TBDISPL   A-16JUL91
DY$DSPZB DS    0H                                             A-16JUL91
         LR    R15,R4                                         A-16JUL91
         CALL  (15),(=CL8'TBSKIP',TBNAM, skip to right row    A-16JUL91$
               0,0,0,QTBDROW),VL,                             A-16JUL91$
               MF=(E,DY@CALLP)                                A-16JUL91
         L     R14,=V(ISPFERR)                                A-16JUL91
         CH    R15,=H'20'               severe error ???      A-16JUL91
         BL    *+6                      no - skip call        A-16JUL91
         BALR  R15,R14                  tell about it         A-16JUL91
DY$DSPZC DS    0H                                             A-16JUL91
         LR    R15,R4                   -> ISPLINK
         CALL  (15),(=CL8'TBDISPL',TBNAM,TBPNL),VL,                    $
               MF=(E,DY@CALLP)
         L     R14,=V(ISPFERR)
         CH    R15,=H'20'               severe error???
         BL    *+6                      no - skip call
         BALR  R15,R14                  tell about it
         ST    R15,DY@ITDRC
         NI    DY@FLAG,255-DY@ILNCD-DY@DCMD  no line & no dest yet
***********************************************************************
*                                                                     *
*        COPY IN THE ISPF VERB FOR "RETURN" TEST                      *
*                                                                     *
***********************************************************************
         LA    R0,8                     maximum length
         ST    R0,DY@VLEN               set for VCOPY
         LR    R15,R4
         CALL  (15),(=CL8'VCOPY',=CL8'ZVERB',DY@VLEN,QDREPLY,          $
               =CL8'MOVE'),VL,                                         $
               MF=(E,DY@CALLP)
         L     R14,=V(ISPFERR)
         CH    R15,=H'20'               severe error???
         BL    *+6                      no - skip call
         BALR  R15,R14                  tell about it
         MVC   DY@ZVERB,QDREPLY         save verb
***********************************************************************
*                                                                     *
*        COPY IN THE PRIMARY COMMAND VARIABLE                         *
*                                                                     *
***********************************************************************
         LA    R0,QDREPLYL              maximum length
         ST    R0,DY@VLEN               set for VCOPY
         LR    R15,R4                   -> ISPLINK
         CALL  (15),(=CL8'VCOPY',=CL8'ZCMD',DY@VLEN,QDREPLY,           $
               =CL8'MOVE'),VL,                                         $
               MF=(E,DY@CALLP)
         L     R14,=V(ISPFERR)
         CH    R15,=H'20'               severe error???
         BL    *+6                      no - skip call
         BALR  R15,R14                  tell about it
         LA    R6,QDREPLY               POINT AT REPLY
         L     R5,DY@VLEN               GET LENGTH OF REPLY
         STH   R5,QDRLNG                STORE LENGTH OF REPLY
***********************************************************************
*                                                                     *
*        IF A LINE COMMAND WAS SPECIFIED HANDLE IT                    *
*                                                                     *
***********************************************************************
DY$DSPZ1 LR    R15,R4                   -> ISPLINK
         MVC   DY@ISLN,=F'4'            set length
         CALL  (15),(=CL8'VCOPY',=CL8'ZTDSELS',DY@ISLN,DY@PCMD,        $
               =CL8'MOVE'),VL,                                         $
               MF=(E,DY@CALLP)
         L     R14,=V(ISPFERR)
         CH    R15,=H'20'               severe error???
         BL    *+6                      no - skip call
         BALR  R15,R14                  tell about it
         CLC   DY@PCMD(4),=CL4'0000'    selected entries zero?
         BE    DY$DSPZ2                 yes so none selected
         LA    R6,QLCBE                 point at LCB entry
         USNGX LCBUFF,R6
         ICM   R1,B'1111',LCBADDR1      any variable?
         BZ    DY$ILCB1                 no - skip mvc
         CLC   LCBFLD1,0(R1)            did value change?
         BE    DY$ILCA2                 no - go blank it
         MVC   LCBFLD1,0(R1)            save any value
         B     DY$ILCB1
*
DY$ILCA2 MVC   LCBFLD1,QBLANK           clear data
*
DY$ILCB1 ICM   R1,B'1111',LCBADDR2      any variable?
         BZ    DY$ILCEX                 no - skip mvc
         CLC   LCBFLD2,0(R1)            did value change?
         BE    DY$ILCB2                 no - go blank it
         MVC   LCBFLD2,0(R1)            save any value
         B     DY$ILCEX
*
DY$ILCB2 MVC   LCBFLD2,QBLANK           clear data
*
DY$ILCEX OC    QDRLNG,QDRLNG            ANY PRIME CMD ENTERED?
         BNZ   DY$LC$E1                 YES - GENERATE ERROR MSG
*---  FIND THE LINE COMMAND TABLE ENTRY
DY$ILCCK CLI   LCBFLD1,C' '             ANYTHING HERE?
         BNH   DY$ILCL3                 NO - SKIP THIS ENTRY
         L     R1,QDLCTBL               -> LINE CMD TABLE
         LTR   R1,R1                    ANY?
         BZ    DY$ERR3                  NO - ERROR
         SPACE 1
         USNGX LCTABLE,R1
DY$ILCL2 CLC   LCBFLD1,LCTCMDNM         THIS IT?
         BE    DY$ILCGT                 YES
         LA    R1,LCTELEN(,R1)          -> NEXT TABLE ENTRY
         CLI   0(R1),X'FF'              END OF TABLE?
         BNE   DY$ILCL2                 NO - KEEP LOOKING
         SPACE 1
*---  LINE COMMAND IS INVALID
DY$INVLI MVC   QDHLINE,QBLANK           CLEAR ERROR MSG AREA
         MVC   QDHLINE(33),=C'*** LINE COMMAND "XX" INVALID ***'
         MVC   QDHLINE+18(2),LCBFLD1    FILL IN BAD COMMAND NAME
         SPACE 1
*---  LINE COMMAND ERROR - SET CURSOR POSITION
DY$ILCER DS    0H
         OI    QFLAG1,Q1MVHDR           REQUEST "MOVE HEADER"
         B     DY$WRITE                 GO RE-WRITE THE SCREEN
         SPACE 2
DY$ILCE2 MVC   QDHLINE,QBLANK           CLEAR ERROR MSG AREA
         MVC   QDHLINE(29),=C'*** LINE COMMAND CONFLICT ***'
         B     DY$ILCER                 GO SET UP FOR RE-WRITE
         SPACE 1
DY$ILCGT TM    LCTFLAGS,LCTFPRIV        PRIV CMD?
         BNO   *+12     >========+      NO - OK
         TM    QXAUTH,QXAUTHX    |      PRIV USER?
         BZ    DY$INVLI          |      NO - SAY INVALID COMMAND
         ST    R1,LCBTPTR   <====+      SAVE IN LINE CMD BUFFER
         OI    DY@FLAG,DY@ILNCD         indicate line command
         TM    LCTFLAGS,LCTFDCMD        IS THIS A DEST. CMD?
         BNO   DY$ILCL3                 NO - SKIP
         TM    DY@FLAG,DY@DCMD          ALREADY HIT DEST. CMD?
         BO    DY$ILCE2                 YES - CONFLICT
         OI    DY@FLAG,DY@DCMD          REMEMBER DEST. CMD FOUND
         DROPX R6,R1
*---  put variables back
DY$ILCL3 LR    R15,R4                   -> ISPLINK
         CALL  (15),(=CL8'TBPUT',TBNAM),VL,                            $
               MF=(E,DY@CALLP)
         L     R14,=V(ISPFERR)
         CH    R15,=H'20'               severe error???
         BL    *+6                      no - skip call
         BALR  R15,R14                  tell about it
         CLC   DY@PCMD(4),=CL4'0001'    any left to process ?
         BNH   DY$DSPZ2                 no - all done
         LR    R15,R4                   -> ISPLINK
*---  get next selected
         CALL  (15),(=CL8'TBDISPL',TBNAM),VL,                          $
               MF=(E,DY@CALLP)
         L     R14,=V(ISPFERR)
         CH    R15,=H'20'               severe error???
         BL    *+6                      no - skip call
         BALR  R15,R14                  tell about it
         B     DY$DSPZ1                 go and reget
*
DY$DSPZ2 TM    DY@FLAG,DY@ILNCD         any line command occur?
         BZ    ISPF1A                   no - process primary
         SPACE 2                                              A-16JUL91
         LR    R15,R4                                         A-16JUL91
         MVC   DY@ISLN,=F'6'            set length            A-16JUL91
         CALL  (15),(=CL8'VCOPY',=CL8'ZTDTOP',                A-16JUL91$
               DY@ISLN,DY@PCMD,=CL8'MOVE'),VL,                A-16JUL91$
               MF=(E,DY@CALLP)                                A-16JUL91
         L     R14,=V(ISPFERR)                                A-16JUL91
         CH    R15,=H'20'               severe error???       A-16JUL91
         BL    *+6                      no - skip call        A-16JUL91
         BALR  R15,R14                  tell about it         A-16JUL91
         PACK  QNUMWORK,DY@PCMD(6)      convert to decimal    A-16JUL91
         CVB   R15,QNUMWORK             make binary           A-16JUL91
         ST    R15,QTBDROW              save it for TBSKIP    A-16JUL91
         SPACE 2
*---  RETURN TO MAINLINE TO EXECUTE LINE COMMANDS
         QNEWCMD  LINE                  from dispaly
         SPACE 2
*---  PROCESS THE PRIMARY COMMAND
ISPF1A   L     R15,DY@ITDRC             get rc from orig display
         CH    R15,=H'8'                WAS END OR RETURN CMD ENTERED?
         BNE   ISPF2                    nope
         CLC   DY@ZVERB,=CL8'RETURN'    is this a "RETURN" xit?
         BNE   ISPF1B                   no - treat as "END"
         MVC   QDREPLY(8),=CL8'RETURN'  yes - exit
         MVC   QDRLNG,=H'6'             fake up length
         B     ISPF2                    go and exit
*
ISPF1B   MVC   QDREPLY,=C'END'          YES - FAKE UP END
         MVC   QDRLNG,=H'3'             SET LENGTH
*
ISPF2    MVC   QERRMSG,QBLANK           blank out error line
         MVI   DY@AID,X'7D'             set to enter
         LH    R4,QDRLNG                get length of reply
         LTR   R4,R4                    any from user USER?
         BNZ   DY$INTER                 yes. interrupt current wk
         TM    DY@FLAG,DY@IMM           request for immed write?
         BO    QSTOP                    yes - all done
         OI    QFLAG2,Q2NEWSCR          flag as new screen
         B     DY$INTER                 continue processing
         SPACE 3
***********************************************************************
*                                                                     *
*   ROUTINE TO HANDLE TERMINAL I/O FOR NON-VIDEO DISPLAY TERMINALS    *
*                                                                     *
***********************************************************************
DY$TTY   TM    QDWCC,X'04'              ALARM?
         BNO   DY$TTY$2                 NO - SKIP
         LA    R1,=X'2F'                YES - GET VALUE FOR "BELL"
         LA    R0,1                     LENGTH
         ICM   R1,B'1000',=X'02'        SET "CONTROL"
         TPUT  (1),(0),R                RING HIS CHIMES
         SPACE 1
DY$TTY$2 L     R1,QVHLINE               -> HEADER LINE
         LH    R0,QDCOLS                LENGTH + 1
         BCTR  R0,0                     LENGTH
         TPUT  (1),(0),R
         TM    QMISCFLG,QMFATTN         ATTN PRESSED?
         BO    DYTTYTG                  YES - GO DIRECTLY TO TGET
         L     R6,QVLINE1               -> FIRST DATA LINE
         LH    R7,QDCOLS                LENGTH
         LH    R3,QDROWS                NUMBER
         LR    R5,R7                    COPY LINE LENGTH
         BCTR  R5,0                     GET EX LENGTH
         XC    DY@TRTAB,DY@TRTAB        INIT TRT TABLE TO ...
         MVI   DY@TRTAB+X'1D',4         ... STOP ON "START FIELD"
         MVI   DY@TRTAB+X'3C',8         ... AND "REPEAT TO ADDR"
         SPACE 2
DY$TTYLP EX    R5,DYTTYMVC              MOVE DATA TO OUR BUFFER
         LA    R15,0(R5,R6)             -> END OF LINE
         LR    R14,R5                   LENGTH TO TRT
         LA    R1,DY@LINE               -> START OF LINE
         MVI   TTY@BYTE,C' '            ASSUME WON'T FIND ANYTHING
         SPACE 1
DY$TRTLP EX    R14,DYTTYTRT             LOOK FOR SF OR RA
         BZ    DY$TTYTP                 NONE FOUND - GO PUT THE LINE
         MVC   TTY@BYTE,0(R1)           SAVE FOR END OF SCREEN TESTING
         CLI   0(R1),X'3C'              IS THIS THE TRAILING "RA"?
         BE    DY$TTYRA                 YES - SPECIAL HANDLING
*---  REMOVE THE ATTR BYTE FROM THE LINE                           ---*
         MVI   0(R1),C' '               KILL THE X'1D'
         LA    R1,1(,R1)                SKIP OVER IT
         LA    R14,DY@LINE(R5)          -> LAST CHAR OF LINE
         SR    R14,R1                   EXECUTE LENGTH TO SHIFT OVER
         LA    R15,1(,R15)              ADJUST END OF LINE POINTER
         LA    R6,1(,R6)                ALSO, FIX PTR TO NEXT SCRN LINE
         LR    R2,R15                   COMPUTE ADDRESS OF PART OF LINE
         SR    R2,R14                   ... AFTER THE ATTR BYTE
         EX    R14,DYTTYSHF             SHIFT REMAINDER OF LINE LEFT
         B     DY$TRTLP                 LOOK FOR NEXT ATTR BYTE
         SPACE 1
DYTTYMVC MVC   DY@LINE(*-*),0(R6)       << EXECUTED >>
DYTTYTRT TRT   0(*-*,R1),DY@TRTAB       << EXECUTED >>
DYTTYSHF MVC   0(*-*,R1),0(R2)          << EXECUTED >>
DYTTYCLC CLC   DY@LINE(*-*),QBLANK      << EXECUTED >>
         SPACE 1
*---  THE TRAILING "RA" SEQUENCE HAS BEEN FOUND.  REMOVE IT.       ---*
DY$TTYRA MVC   0(132,R1),QBLANK         CLEAR REST OF PRINT LINE
         SPACE 1
*---  FINALLY, TPUT THE LINE IF IT'S NON-BLANK                     ---*
DY$TTYTP EX    R5,DYTTYCLC              BLANK LINE?
         BE    DY$TTYSK                 YES - SKIP IT
         LA    R1,DY@LINE               -> OUTPUT LINE
         TPUT  (1),(R7)                 PUT OUT THE LINE
DY$TTYSK CLI   TTY@BYTE,X'3C'           END OF SCREEN? (RA)
         BE    DYTTYTG                  YES - ALL DONE WITH SCREEN BUFF
         TM    QMISCFLG,QMFATTN         ATTN PRESSED?
         BO    DYTTYTG                  YES - GO DIRECTLY TO TGET
         AR    R6,R7                    -> NEXT DATA LINE
         BCT   R3,DY$TTYLP              DO THE WHOLE SCREEN
         B     DYTTYTG                  AND REQUEST INPUT
         SPACE 2
DY$TTYPM LA    R0,QDREPLYL              GET LENGTH
         TPUT  (1),(0),R                PUT IT OUT
         B     DYTTYTG                  GET NEXT COMMAND
         SPACE 2
DYTTYTG  NI    QMISCFLG,255-QMFATTN     RESET IN CASE INTERRUPTED OUTPT
         SPACE 1
DYTTYTG2 LA    R1,=C'QUEUE: '
         LA    R0,7
         LA    R15,QDTOP-8-7            -> AREA-LINELEN FOR ' *MORE'
         AH    R15,QDCOLS               -> AREA FOR ' *MORE*'
         CLC   0(7,R15),=C' *MORE*'     IS THERE MORE?
         BNE   *+12                     NO - KEEP IT
         LA    R1,=C'*MORE* QUEUE: '
         LA    R0,14
         ICM   R1,B'1000',=X'01'        SET "ASIS"
         TPUT  (1),(0),R
         SPACE 1
         LA    R1,DY@TEXT               -> INPUT LOC
         LA    R0,QDREPLYL              MAX LENGTH
         ICM   R1,B'1000',=X'80'        SET "TGET"
         TGET  (1),(0),R
         MVC   DY@INPUT(6),=X'7D4040114040'  FAKE OUT 3270 AID, ADDR,
*                                            SBA, ADDR
         LA    R4,6(,R1)                FAKE LENGTH FOR ABOVE
         CH    R15,=H'8'                ATTN?
         BNE   TGET$CHK                 NO - PROCESS INPUT
         B     DYTTYTG2                 YES - READ AGAIN
***********************************************************************
*                                                                     *
*   Internal suboutine to update LCB offset to ISPF variable addr     *
*                                                                     *
*      on input   R1  ->   line address                               *
*                 R15 ==   offset from LCB entry                      *
*                 R7  ->   table of variable lengths                  *
*                 R6  ==   address of first variable                  *
*                                                                     *
***********************************************************************
DY$ILADR LTR   R15,R15                  is offset zero?
         BZR   R8                       yes - not needed
         AR    R15,R1                   add start of line
         SR    R14,R14                  counter
*
DY$IA1   CLI   0(R15),X'1D'             is this start field?
         BNE   *+8                      no
         LA    R14,1(,R14)              bump counter
         BCTR  R15,0                    bump addr down
         CR    R15,R1                   reached start?
         BNL   DY$IA1                   loop till at start
         SR    R15,R15                  clear reg
         LTR   R14,R14                  any start fields found?
         BZR   R8                       nope - skip everything
         BCT   R14,DY$IA2               get 0 relative
         B     DY$IA4                   if only 1 then at first
*
DY$IA2   SLL   R14,2                    times 4
*
DY$IA3   SH    R14,=H'4'                decrement offset
         A     R15,0(R14,R7)            add in length
         LTR   R14,R14                  any left to do?
         BP    DY$IA3
*
DY$IA4   AR    R15,R6                   add in offset
         BR    R8                       all done
***********************************************************************
*                                                                     *
*   SUBROUTINE TO BUILD TOP SCREEN LINES IF NECESSARY                 *
*                                                                     *
***********************************************************************
DY$SETOP TM    QTERMFLG,QTFSW2+QTFSW5   NEED TO SWITCH?
         BZR   R8                       NO - JUST RETURN TO CALLER
         BNO   *+8                      YES - CONTINUE
         EX    0,*                      CAN'T USE 'LOGICERR' HERE...
         NI    QTERMFLG,255-QTFSW2-QTFSW5  RESET REQUEST FLAGS
         MVI   QDERASE,X'F5'            ASSUME MOD 2, SET ERASE WRITE
         NI    QTERMFLG,255-QTFNOW5     ASSUME IN MOD 2 MODE
         CLI   QDROWS+1,24-3            MODEL 2?
         BE    *+12    >============+   YES - SKIP
         MVI   QDERASE,X'7E'        |   NO - USE ERASE WRITE ALTERNATE
         OI    QTERMFLG,QTFNOW5     |   AND REMEMBER WE ARE MOD 5 MODE
         MVC   QD3270OP,QDERASE  <==+   FORCE ERASE WRITE ON NEXT WRITE
         LA    R14,QDTOP+1-9            -> SECOND SCREEN LINE
         AH    R14,QDCOLS               ...
         MVC   0(14,R14),DY#CMD         'COMMAND ===>' & ATTR
         LA    R14,14(,R14)             -> INPUT AREA
         ST    R14,QVINPUT              SAVE ADDRESS
         XC    0(QDREPLYL,R14),0(R14)   CLEAR IT
         MVC   QDREPLYL(2,R14),=X'1DE8' ATTR - PROT BRIGHT
         MVC   QDREPLYL+2(132-80,R14),QBLANK CLEAR THE REST J.I.C.
         LH    R1,QDCOLS                GET SCREEN WIDTH
         SH    R1,=H'80'                ADJUST FOR MIN WIDTH
         LA    R14,QDREPLYL+2(R1,R14)   -> THIRD LINE (HEADER)
         ST    R14,QVHLINE              SAVE ADDRESS
         AH    R14,QDCOLS               -> FOURTH LINE (SORT OF)
         BCTR  R14,0                    ADJUST FOR ATTRIBUTE BYTE
         MVC   0(2,R14),=X'1D60'        ATTR - PROT NORM
         LA    R14,2(,R14)              -> FIRST DATA LINE
         ST    R14,QVLINE1              SAVE ADDRESS
         ST    R14,QDNEXT               SET ADDRESS OF NEXT DATA LINE
         LA    R0,QDSCREEN              -> START OF SCREEN BUFFER
         SR    R14,R0                   COMPUTE LENGTH OF FIXED AREA
         L     R1,=A(QDSCRLEN)          GET LENGTH OF WHOLE BUFFER
         SR    R1,R14                   COMPUTE LENGTH REMAINING
         ST    R1,QDCLEARL              SAVE LENGTH TO CLEAR
         BR    R8                       RETURN TO CALLER
***********************************************************************
*                                                                     *
*   MISCELLANY                                                        *
*                                                                     *
***********************************************************************
DY$TXMVC MVC   0(*-*,R6),DY@PCMD        << EXECUTED >>
         SPACE 1
DY#CMD   DC    C'Command ===>'
         DC    X'1DC8'                  ATTR - INPUT, BRIGHT
         SPACE 2
         ENTRY RC#KEYS
RC#KEYS  DC    CL8'F',CL8'FIND'
         DC    CL8'T',CL8'TSO'
         DC    CL8'I',CL8'INQ',CL8'INQUIRY'
*---  ANYTHING NOT ONE OF THE ABOVE WILL BE ASSUMED TO BE 'C'      ---*
         DC    CL8'C',CL8'CMD'          MVS/JES2
         DC    X'FF'                    END OF TABLE INDIC.
         SPACE 2
DY#SCALE DC    C'----+----1----+----2----+----3----+----4----+----5'
         DC    C'----+----6----+----7----+----8----+----9----+---10'
         DC    C'----+---11----+---12----+---13----+---14----+---15'
         DC    C'----+---16----+---17----+---18----+---19----+---20'
         DC    C'----+---21----+---22----+---23----+---24----+---25'
         DC    C'----+---26----+---27----+---28----+---29----+---30'
         DC    C'----+---31----+---32----+---33----+---34----+---35'
         DC    C'----+---36----+---37----+---38----+---39----+---40'
         SPACE 2
DY#T3270 DC    0D'0'
         DC    X'40C1C2C3C4C5C6C7C8C94A4B4C4D4E4F'
         DC    X'50D1D2D3D4D5D6D7D8D95A5B5C5D5E5F'
         DC    X'6061E2E3E4E5E6E7E8E96A6B6C6D6E6F'
         DC    X'F0F1F2F3F4F5F6F7F8F97A7B7C7D7E7F'
         SPACE 2
FM#MDL   DC    F'7'                     number of fields
         DC    F'2,18,5,3,5,32,8',F'0'
         DC    CL30'(QF1 QF2 QF3 QF4 QF5 QF6 QF7)'
 DC C'_Z @Z                 #Z    @Z  @Z    @Z                         $
                     _Z       '
*     y12y123456789112345678y12345y123y12345y12345678911234567892123456
*              789312y12345678'
*  'y' are real attributes for:
*          selection field (col 2)      input high
*          qname           (col 5)      output low
*          jobnumber       (col 23)     output high
*          rest            (col 29)     output low
*          device/args     (col 73)     input high
         SPACE 2
DD#MDL   DC    F'4'                     number of fields
***      DC    F'2,8,5,61',4F'0'
         DC    F'2,8,7,59',4F'0'
         DC    CL30'(QF1 QF2 QF3 QF4)'
*DC C'_Z @Z       #Z    @Z
 DC C'_Z @Z       #Z      @Z                                           $
                              '
*     y12y12345678y12345y1234567891123456789212345678931234567894123456
*              789412345678961'
*  'y' are real attributes for:
*          selection field (col 2)      input high
*          ddname          (col 5)      output low
*          datasetid       (col 23)     output high
*          rest            (col 29)     output low
         SPACE 2
DC#MDL   DC    F'6'                     number of fields
         DC    F'4,8,8,17,6,32',F'0,0'
         DC    CL30'(QF1 QF2 QF3 QF4 QF5 QF6)'
 DC C'@Z   #Z       @Z       @Z                #Z     @Z               $
                             '
*     y1234y123y12345678y12345y12345678911234567y123456y123456789112345
*              678921234567893'
*  'y' are real attributes for:
*          asid            (col 5)      output low
*          queue and type  (col 23)     output high
*          jobnumber       (col 23)     output high
*          jobname         (col 29)     output low
*          step & proc     (col 29)     output low
*          slots           (col 23)     output high
*          usage data      (col 29)     output low
         SPACE 2
ZZ#MDL   DC    F'1'                     number of fields
         DC    F'79',7F'0'
         DC    CL30'(QF1)'
 DC C'@Z                                                               $
                              '
*     y1234567891123456789212345678931234567894123456789512345678961234
*              567897123456789'
*  'y' are real attributes for:
*          other data      (col 2)      output low
         SPACE 2
         LTORG
         SPACE 3
         DROPX R13
         SPACE 3
         QCOMMON
         SPACE 2
DY#MDL   DSECT ,                        ISPF table model lines descript
DY#MCNT  DS    F                        number of fields
DY#MLEN  DS    8F                       length of each field
DY#MVAR  DS    CL30                     ZVARS string
DY#MLN   DS    CL80                     model line value
         SPACE 2
WORK     DSECT
         ORG   WORK+72
DY@TPTR  DS    A                        LINE CMD ELEMENT PTR PARM
DY@ITDRC DS    F                        rc from TBDISPL w/ panel
DY@ISLN  DS    F                        length of ZTDSELS var
DY@ZVERB DS    CL8                      ZVERB after TBDISPL w/
DY@CURS  DS    H                        RELATIVE CURSOR POSITION
DY@FLAG  DS    B
DY@IMM   EQU   X'80'                    ENTRY IS FOR IMMEDIATE DISPLAY
DY@DCMD  EQU   X'40'                    HIT DESTRUCTIVE BUFFER COMMAND
DY@ILNCD EQU   X'20'                    line command occured
DY@SHORT EQU   X'10'                    short write (in valid.)
DY@WORKL EQU   *-WORK
DY@VLEN  DS    F                        for VCOPY variable length
DY@CALLP DS    5A                       CALL MF=L area
TTY@BYTE DS    C
DY@DWD   DS    0D
DY@TRTAB DS    XL256
DY@TEMP  DS    0CL512                   AREA FOR SHORT WRITES
DY@LINE  DS    CL132                    OUT LINE WORK AREA FOR TTY
         DS    CL150                    SLOP AREA (SEE DY$TTY CODE)
         ORG   DY@TEMP+L'DY@TEMP
         DS    0D                       ALIGN REPLY AREA
DY@FIELD DS    CL(QDREPLYL)             WORK AREA TO EXTRACT 1 FIELD
DY@PCMD  DS    CL(QDREPLYL)             PRIMARY LINE COMMAND
DY@PCLEN DS    H                        ITS LENGTH
DY@INPUT DS    0CL(3+3+QDREPLYL+(3+2+3+8)*40)
DY@AID   DS    C
         DS    CL2                      CURSOR ADDRESS
         DS    C,CL2                    SBA, DATA ADDRESS
DY@TEXT  EQU   *                        INPUT DATA
         ORG   DY@INPUT+L'DY@INPUT
