         TITLE '--- QUEUE--INITIAL -- INITIALIZATION ROUTINES ---'
*---------------------------------------------------------------------*
*                                                                     *
*   INITIAL - Getmain and initialize all workareas, open all DCBs,    *
*             perform profile processing                              *
*                                                                     *
*   Updates:                                                          *
*      06Jun91  EMS  Update for SP420, and fix JES2 version check     *
*      26May91  LDW  VDEFINE QBRIFHDR                                 *
*      15Apr91  LDW  Fix previous update                              *
*      28Mar91  LDW  Don't use in-storage copy of checkpoint if       *
*                       CKPT() or DSN() specified unless JES() also   *
*      27Mar91  LDW  Allow QGLOBALS specification of dsn suffixes     *
*      10Feb91  LDW  Rewrite ISPF detection to support direct         *
*                       invocation under current releases of ISPF     *
*                    Move some data out of QCOMMON to here            *
*                    Use II@CALLP instead of TBLST and VCALLST        *
*      30Jan91  LDW  Integrate selected GLA updates as follows:       *
*     (02Aug90) GLA  Save addr of SVT/CCT for incore ckpt check       *
*     (10Jul90) GLA  Add code to initialize PC routines to allow      *
*                       easy access to in-core CKPT for 2.2 and 3.1   *
*     (15Nov89) GLA  Fix support for SP3.1.1 for previous releases.   *
*                    Add support for VERB TABLE variable.             *
*     (16Jun89) GLA  Fix XA 0C4 due to clobbered register.            *
*     (20Apr89) GLA  Fix JCT overlay on CKPT read. The setup of       *
*                       JCT address in the buffer was off by 4K.      *
*     (28Mar89) GLA  Add ISPF BROWSE & table support for ISPF V1.x    *
*                       through 2.3                                   *
*      29Jan91  LDW  Add QVPRNTWA to II#RELOC                         *
*      22Dec90  LDW  Use EQU for SYSTABLE entry length                *
*      27Nov90  EMS  Fix for longer dsn's                             *
*      16Jun90  LDW  Run (mostly) in AMODE31 now                      *
*      25Dec89  LDW  Q$xxx -> QZxxx:  CPPL, CVT, JESCT, PSCB, SSCT,   *
*                                     SSIB, UCB                       *
*      12Dec89  LDW  Use &@@OACFS for name of OACFSORT load module    *
*                    Pick up following updates from Doron 21Nov89:    *
*               DMS  Test &@@SYSP and &@@STAFF instead of hardcoded   *
*                    Make use of OACFSORT conditional on &@@OACFS     *
*                    Bypass KAC reference if &QLEVEL LT 8             *
*      23Nov89  LDW  Remove conditional assembly around Qxxx macros   *
*                    Remove prereq Q$PDDB                             *
*      05Jun89  LDW  Set QXSUPR and QXAPFENT if appropriate           *
*      25Apr89  EMS  SP311 changes, in core ckpt use                  *
*      17Apr89  LDW  Change Q$UCB to QUCB                             *
*      03Feb88  LDW  Adapt Jack Schudel's 2.2.0 mods for Lockheed's   *
*                       QUEUE to this QUEUE                           *
*       3Jun87  EMS  Add support for Starting/Draining Spool vols     *
*                       and better checking for invalid mttr's        *
*                    load OACFSORT                                    *
*                    getmain separate table for DDNAME cmd            *
*      13Feb87  LDW  Init QVRING                                      *
*                    Use table to relocate adcons in QCOMMON          *
*      17Jan87  LDW  Set QCNUMTGA = $NUMTG if QLEVEL < 5              *
*                    Misc cleanup                                     *
*      10Jan87  LDW  SP136:  Save $JQELEN, many changes in CKPT math  *
*                    Use CVT instead of CVTDSECT (for XA?)            *
*      04SEP86  LDW  USE DCB EXIT TO SET DEFAULT NCP                  *
*      25AUG86  LDW  FIX BUGS IN PREVIOUS UPDATE (SP130 BROKE)        *
*      17JUN86  LDW  SAVE INFO ON SECTIONS OF CKPT DATASET, TO ALLOW  *
*                       READING ONLY NECESSARY DATA                   *
*                    SET QMFMVSE IF RUNNING MVS/XA                    *
*                    ADD SECOND BASE REG (PUKE!)                      *
*      03JUN86  LDW  GETMAIN STORAGE FOR MULTIPLE HASPCKPT DECBS      *
*      03/30/86 LDW  RE-DESIGN 3278-5 SUPPORT (THIRD TRY!)            *
*                    STAX BLOCK MOVED FROM QCOMMON TO QUEUE LOCAL     *
*                       WORKAREA                                      *
*      08/30/84 LDW  GETMAIN A SCREEN BUFFER                          *
*                    SAVE ALL GETMAINED ADDRESSES AND LENGTHS         *
*      08/07/84 LDW  UPDATE FOR SP134 (DON'T COMPUTE QCPDDB1)         *
*      08/06/84 LDW  IF SP:  FOR HASPCKPT BLKSIZE, USE MAX FOR        *
*                       DEVICE, TO ACCOUNT FOR THE MASTER REC IN      *
*                       JES2/SP BEING LARGER THAN 4K                  *
*      06/05/84 LDW  UPDATES FOR SP133 FROM UF VERSION                *
*      04/20/84 EMS  FIX FOR QPROF RECFM=FB                           *
*      04/11/84 LDW  IOTDSECT -> IOTSTART                             *
*                    USING/DROP -> USNGX/DROPX                        *
*      04/10/84 LDW  SP133 COMPATIBILITY                              *
*      01/23/83 LDW  RELOCATE QHDCBA AND QHDECBA                      *
*      12/19/83 LDW  SET QCTGMLEN (FOR NEW 'SPACE' FEATURE)           *
*      10/30/83 LDW  FIX TEST FOR RECALL (WAS 'REPROMPT')             *
*      10/17/83 LDW  CORRECT SOME ADDREESSABILITY ERRORS CAUSED BY    *
*                       ENLARGING 'SYSTABLE'                          *
*      07/25/83 LDW  DON'T CALL ISPLINK UNLESS PARM STARTS WITH       *
*                       'ISPF'                                        *
*      04/19/83 LDW  FIX BUG IN ALLOCATING HASPACE IF JES2/SP         *
*      03/18/83 LDW  RELOCATE QVSTACK, QVSTACKC                       *
*                    MISC FIXES FOR ADDRESSABILITY                    *
*      03/01/83 LDW  RELOCATE QVLCBUF                                 *
*      02/04/83 LDW  SEE IF ISPLINK EXISTS BEFORE LINKING TO IT       *
*      02/03/83 LDW  TO SUPPORT 3380'S:  REMOVE DEVICE TABLE, USE     *
*                       DEVTYPE MACRO                                 *
*                    OTHER MISC CLEANUP DONE IN THIS AREA             *
*      02/02/83 LDW  CHANGE CONDITIONAL ASSEMBLY SO THAT IF SID TABLE *
*                       IS GENERATED CORRECTLY IF &QSIDNUM = 0        *
*      01/24/83 LDW  PICK UP LOCAL NODE ID FROM $SAVEAREA IF SP       *
*                    ADD $PDDB IN FRONT OF $IOT IF SP                 *
*      01/19/83 LDW  ADD OPTIONAL TRANSLATION OF SMF ID'S             *
*                    ADD ANOTHER TEMPORARY BASE FOR QCOMMON           *
*                    SET QTPAGEX, QTHALFX                             *
*                    REMOVE TESTAUTH (NOW IN NEW ROUTINE "APF")       *
*      01/14/83 LDW  ADD SP SUPPORT                                   *
*      01/04/83 LDW  CHECK FOR SPF ENVIRONMENT                        *
*                    RE-ENABLE MOD 5 SUPPORT                          *
*                    SET QSTDEFKY                                     *
*                    CHECK THAT CHKPT FILE IS THE ONE WE HAVE BEEN    *
*                       ASSEMBLED FOR                                 *
*                    USE NJE FIELD NAMES ($SVTONOD REPLACES $SVTOSYS) *
*                    FIX BUG:  REPROMPT WITH INVOCATION CMD IF BAD    *
*      12/10/82 LDW  ALLOW PROFILE COMMENTS AS '/*' OR ' /*'          *
*      10/28/82 LDW  SAVE SYSTEM ID OF SELECTED JES2 IN QSYSID(0)     *
*      10/14/82 EMS  ADD SUPPORT FOR RECFM V PROFILES                 *
*                    FIX BUG IN PROCESSING OF MULTIPLE QSE'S          *
*                    FIX BUG IN PARM PROCESSING                       *
*                    ONLY USE 1 MODEL DCB FOR BOTH PS AND PO PROFILES *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 3
INITIAL  QSTART  Q10,WORKLEN=II@WORKL
         LA    R8,4095(,R12)            SET UP SECOND...
         LA    R8,1(,R8)                ... BASE REGISTER
         USNGX INITIAL+4096,R8          COMPLETE THE TRAVESTY
         USNGX WORK,R13
         USNGX PSA,R0
         ST    R3,II@STAXA              SAVE ADDRESS OF STAX BLOCK
         MVI   II@FLAGS,0               INIT FLAGS
***********************************************************************
*                                                                     *
*   COPY AND INITIALIZE QCOMMON                                       *
*                                                                     *
***********************************************************************
         SPACE 1
*  AT ENTRY (FROM "QUEUE" MAINLINE), R11 -> "QCOMMON" CSECT, SO WE MUST
*  NOT STORE ANYTHING UNTIL AFTER WE HAVE CHANGED TO THE GETMAINED COPY
         L     R10,QGETMAIN             GET LENGTH OF QCOMMON
         GETMAIN  RU,LV=(R10),SP=44,BNDRY=PAGE  GET AN AREA FOR QCOMMON
         SPACE 1
* MOVE QCOMMON INTO WORKING STORAGE
         LR    R0,R11                   -> QCOMMON (SOURCE ADDR)
         LR    R14,R1                   -> GETMAIN AREA (DEST ADDR)
         LR    R11,R1                   ADDRESS NEW QCOMMON
         LR    R1,R10                   SOURCE LENGTH FOR MVCL
         LR    R15,R1                   DEST LENGTH
         MVCL  R14,R0                   COPY CSECT TO GETMAINED AREA
*  NOW MUST INITIALIZE ALL THE ADCONS IN IT
         MVC   QCCKPT,II#OPENI          INITIALIZE HASPCKPT OPEN LIST
         MVC   QCSAVE,II#OPENO          INITIALIZE HASPSAVE OPEN LIST
         MVC   QPPRNT,II#OPENO          INITIALIZE HASPPRNT OPEN LIST
         MVI   QHDCBA,X'80'             MARK END OF OPEN LIST
         LA    R1,II#RELOC              -> RELOCATION TABLE
II$RL$LP LH    R14,0(,R1)               GET OFFSET OF POINTER
         AR    R14,R11                  -> ADCON
         LH    R15,2(,R1)               GET OFFSET OF DATA
         AR    R15,R11                  -> VALUE
         STCM  R15,B'0111',1(R14)       STORE RELOCATED DATA POINTER
         LA    R1,4(,R1)                -> NEXT RELOCATION TABLE ENTRY
         CLI   0(R1),X'FF'              END OF TABLE?
         BNE   II$RL$LP                 NO - LOOP
         SPACE 3
         L     R1,4(,R13)               PREVIOUS SAVE AREA
         ST    R11,64(,R1)              UPDATE R11 IN PREVIOUS S.A.
         ST    R1,QFRSTSA               STORE @ FIRST S.A. IN QCOMMON
***********************************************************************
*                                                                     *
*  If called via the ISRQ module (from ISPF) the following            *
*     calling conventions will hold:                                  *
*       R2 (orig R1)  =  Address of parm list (but non-CPPL fmt)      *
*                           +0 = F'-1'   to distinguish from CPPL     *
*                           +4 = TLD address                          *
*                           +8 = address of 'ISPLINK'                 *
*                           +12= address of CPPL                      *
***********************************************************************
         CLC   =F'-1',0(R2)             did call come from 'ISRQ'
         BNE   VLDTSO                   if not then normal system call
         LA    R3,4(,R2)                point at "real" parms from ISRQ
         OI    QISFLAG1,QIS1ISPF        set called from ISPF flag
         MVC   BRWEPARM,0(R3)           save addr of TLD
         MVC   ISPLNK,4(R3)             save addr of ISPLINK program
         L     R2,8(,R3)                get address of CPPL
         B     IICPPLOK                 continue
         SPACE 1
VLDTSO   DS    0H
***********************************************************************
*                                                                     *
*   Check out whether we are APF authorized or SUPR mode, remember    *
*   for later.                                                        *
*                                                                     *
***********************************************************************
         TESTAUTH  FCTN=1               see if we are APF authorized
         SPACE 1
         LTR   R15,R15                  are we?
         BNZ   *+8                      no
         OI    QXAUTH,QXAPFENT          yes
         SPACE 2
***      TESTAUTH  FCTN=0,STATE=YES     see if we are SUPR mode
         SPACE 1
***      LTR   R15,R15                  are we?
***      BNZ   *+8                      no
***      OI    QXAUTH,QXSUPR            yes
*---  The TESTAUTH above results in abend S177.  Until this is
*---  resolved, do it a different way.
         L     R1,PSATOLD               -> TCB
         L     R1,0(,R1)                TCB.RBP
         N     R1,=X'00FFFFFF'          clean in case AMODE31
         TM    10(R1),X'E0'             RB.STAB1,RBFTP  PRB?
         BZ    *+8                      yes - can't be SUPR
         OI    QXAUTH,QXSUPR            assume SVRB
         SPACE 2
***********************************************************************
*                                                                     *
*   IF WE HAVE BEEN CALLED RATHER THEN INVOKED AS A CP,               *
*   PHONY UP A CPPL                                                   *
*                                                                     *
***********************************************************************
         USNGX CPPL,R2                  ADDR OF CPPL IS IN R2
         L     R1,PSATOLD               -> TCB
         L     R1,180(,R1)              -> JSCB
         L     R1,264(,R1)              -> PSCB
         TM    0(R2),X'80'              CALL?
         BO    II$CALL1                 YES - GO PHONY UP SOME STUFF
         CLM   R1,B'0111',CPPLPSCB+1    DOES IT LOOK ENOUGH LIKE CPPL?
         BE    IICPPLOK                 YES - DO IT FOR REAL
*  DARN.  IT'S CALL.  BUILD A PHONY CPPL.
II$CALL1 OI    II@FLAGS,II@FCALL        REMEMBER THAT THIS IS "CALL"
         LR    R4,R2                    PRESERVE PARM POINTER
         LA    R2,II@CPPL               CHANGE POINTER TO PHONY ONE
         XC    0(4*4,R2),0(R2)          ZERO IT FOR FUN
         ST    R1,CPPLPSCB              SET PSCB ADDRESS IN PHONY CPPL
         USNGX PSCB,R1
         MVC   CPPLUPT,PSCBUPT          UPT ADDRESS TO CPPL
         L     R1,PSCBRLGB              -> RELOGON BUFFER
         DROPX R1                       PSCB
         L     R1,256(,R1)              RLGB.ECT
         ST    R1,CPPLECT               SET ECT ADDRESS IN PHONY CPPL
***********************************************************************
*                                                                     *
*   MOVE PARMS FROM CPPL TO DAPL                                      *
*                                                                     *
***********************************************************************
IICPPLOK MVC   DAPLUPT,CPPLUPT          USER PROFILE TABLE
         MVC   DAPLPSCB,CPPLPSCB        PROTECTED STORAGE CNTL BLK
         MVC   DAPLECT,CPPLECT          ENVIRONMENT CNTL TABLE
***********************************************************************
*                                                                     *
*   LOCATE LOGON ID, SAVE FOR FUTURE REFERENCE                        *
*                                                                     *
***********************************************************************
         L     R1,CPPLPSCB              -> PSCB
         USNGX PSCB,R1
         MVC   QLOGON(7+1),PSCBUSER     SAVE TSO USERID AND LENGTH
         MVC   QSTKEY(7),QLOGON         SET SEARCH KEY FOR "ST"
         MVC   QSTDEFKY,QSTKEY          SET DEFAULT FOR "ST *"
         TM    &@@SYSP                  SYSTEMS PROGRAMMER?
         BNO   *+8                      NO - SKIP
         OI    QXAUTH,QXSYSP            YES - REMEMBER
         TM    &@@STAFF                 OPERATOR COMMAND AUTHORITY?
         BNO   *+8                      NO - SKIP
         OI    QXAUTH,QXOPER            YES - REMEMBER
         DROPX R1                       PSCB
         SPACE 3
         L     R1,PSATOLD               -> TCB
         L     R1,TCBJSCB-TCB(,R1)      -> JSCB
         L     R1,316(,R1)              -> SSIB  (JSCBSSIB-IEZJSCB)
         USNGX SSIB,R1
         MVC   QDEST,SSIBDEST           SAVE LOGON DEST
         MVC   QPDEST,SSIBDEST          SET DEFAULT PRINT DEST
         MVC   QJESNAME,SSIBSSNM        SAVE NAME OF JES2
         DROPX R1                       SSIB
         DROPX R0                       PSA
***********************************************************************
*                                                                     *
*   MOVE COMMAND BUFFER TO REPLY BUFFER                               *
*                                                                     *
***********************************************************************
         TM    II@FLAGS,II@FCALL        CP OR CALL?
         BNO   II$CP                    NOT CALL
         L     R4,0(,R4)                GET PARM ADDRESS
         LH    R3,0(,R4)                GET OPERAND LENGTH
         SH    R3,=H'1'                 DECR FOR EX
         BM    II$SKPRM                 SKIP IF NO OPERAND
         LA    R1,2(,R4)                -> PARM TEXT
         B     II$CALL2                 CONTINUE
II$CP    L     R1,CPPLCBUF              ADDR OF COMMAND BUFFER
         DROPX R2                       CPPL
         LH    R3,0(,R1)                LENGTH OF COMMAND BUFFER
         LH    R4,2(,R1)                OFFSET TO FIRST DATA BYTE
         LA    R1,4(R1,R4)              FIRST DATA BYTE
         SR    R3,R4                    SUBTRACT OFFSET FROM LENGTH
         SH    R3,=H'5'                 SUB OVERHEAD, PLUS 1 FOR EX
         BM    II$SKPRM                 SKIP IF LENGTH ZERO
II$CALL2 EX    R3,II$CMDOC              TRANSLATE TO UPPER CASE
II$CKPRM CLI   0(R1),C' '               LEADING BLANK?
         BNE   II$CKKEY                 NO, CHECK FOR KEYWORDS
         LA    R1,1(,R1)                -> NEXT BYTE
         BCT   R3,II$CKPRM              AND CHECK IT
         B     II$SKPRM                 IF NONE LEFT, CONTINUE INIT
         SPACE 1
II$CKKEY CLC   =C'ISPF',0(R1)           IS DIALOG MANGLER TO BE USED?
         BE    II$ISPF                  YES. SET FLAG.
         CLC   =C'JES(',0(R1)           IS REQUEST FOR SELECT JES NAME?
         BE    II$JESN                  YES. DO IT.
         CLC   =C'CKPT(',0(R1)          IS REQUEST FOR CKPT?
         BE    II$CKPT                  YES. DO IT.
         CLC   =C'DSN(',0(R1)           IS REQUEST FOR DSN PREFIX?
         BE    II$DSN                   YES. DO IT.
         MVC   QDREPLY,QBLANK           BLANK THE REPLY LINE
         CH    R3,=Y(QDREPLYL-1)        IS LENGTH OVER MAX?
         BNH   *+8                      NO. USE IT.
         LA    R3,QDREPLYL-1            USE MAXIMUM LENGTH
         EX    R3,II$MVC1               MOVE THE DATA
         MVC   QDPROMPT,QDREPLY         COPY TO THE PROMPT
         LA    R3,1(,R3)                INCREMENT TO TRUE LENGTH
         STH   R3,QDRLNG                STORE REPLY LENGTH
***********************************************************************
*                                                                     *
*   DETERMINE WHICH JES2 CHECKPOINT VOLSER AND PREFIX TO USE          *
*                                                                     *
***********************************************************************
II$SKPRM L     R1,CVTPTR                -> CVT
          AIF   (&@@SPLVL LT 130).II010  SKIP IF BIT NOT DEFINED
         TM    CVTDCB-CVT(R1),CVTMVSE   RUNNING MVS/XA?
         BZ    II$NOTXA                 NO - SKIP
         OI    QMISCFLG,QMFMVSE         YES - REMEMBER
         SL    R1,=A(32)                -> FIELD CVTPRODI
         CLC   1(4,R1),=C'BB22'         XA 2.2 or later?  JBB2220
         BL    II$NOTXA                 no - skip setting flag
         OI    QMISCFLG,QMFX22          yes - remember
II$NOTXA L     R1,CVTPTR                reload cvt pointer
.II010    ANOP
         L     R1,CVTJESCT-CVT(,R1)     -> JESCT
         L     R15,JESUNITS-JESCT(,R1)  -> SYSRES UCB
         USNGX UCBOB,R15
         LA    R1,SYSTABLE              -> SYSTEM TABLE
II$SYSLP CLC   UCBVOLI,0(R1)            COMPARE SYSRES VS. TABLE ENTRY
         BE    II$RES1                  FOUND ONE - GO CHECK JESNAME
         DROPX R15                      UCBOB
II$NXSYS LA    R1,SYSTBLL(,R1)          -> NEXT SYSTEM TABLE ENTRY
         CLI   0(R1),X'FF'              END OF TABLE?
         BNE   II$SYSLP                 NO - KEEP LOOKING
         LA    R1,SYSTABLE              NOT FOUND - USE FIRST ENTRY
         B     II$SAVE
II$RES1  CLC   QJESNAME,6(R1)           RIGHT JES2?
         BNE   II$NXSYS                 NO - KEEP LOOKING
*---  WE HAVE LOCATED A TABLE ENTRY FOR THIS SYSRES/JES2 COMBINATION
II$SAVE  CLI   QCKPTVOL,C' '            DID USER SPECIFY CKPT(XXXXXX)?
         BNE   *+10                     YES - USE THE ONE HE WANTS
         MVC   QCKPTVOL,10(R1)          SAVE CHKPT VOLSER
         CLI   QCKPTPFX,C' '            DID USER SPECIFY DSN(XXXXXX)?
         BNE   *+10                     YES - USE THE ONE HE WANTS
         MVC   QCKPTPFX,16(R1)          SET DSN PREFIX
***********************************************************************
*                                                                     *
*   LOCATE AND SAVE VARIOUS INFORMATION ABOUT THE SELECTED JES2       *
*                                                                     *
***********************************************************************
*  FIND SSCT FOR PRIMARY SUBSYSTEM
         L     R15,CVTPTR               -> CVT
         L     R15,CVTJESCT-CVT(,R15)   -> JESCT
         L     R15,JESSSCT-JESCT(,R15)  -> SSCT
         USNGX SSCT,R15
*  FIRST, SET LOCAL NODE FROM THE PRIMARY SUBSYSTEM, IF IT'S ACTIVE
          AIF   (&QLEVEL GE 9).II020
         L     R14,SSCTSSVT             -> SSVT
         USNGX SSVT,R14
          AIF   (&QLEVEL LT 8).II030
         L     R7,SVTKAC                -> KAC
          AGO   .II030
.II020    ANOP ,
         L     R14,SSCTSUS2             -> HCCT
         USNGX HCCT,R14
         L     R7,CCTKAC                -> KAC
         STM   R14,R1,II@REGS           %debug
         MVC   QDMSG(11),=C'>>> cctkac='   %debug
         HEX   QDMSG+11,CCTKAC,LEN=4,HEXTAB=QHEXTAB  %debug
         TPUTX QDMSG,19                 %debug
         MVC   QDMSG,QBLANK             %debug
         LM    R14,R1,II@REGS           %debug
.II030    ANOP ,
         LTR   R14,R14                  IS PRIMARY SYSTEM UP?
         BZ    II$PDOWN                 NO - SKIP
          AIF   (&QLEVEL GE 8).II031
         TM    $SVSID,X'80'             DOES IT APPEAR TO BE A VALID
*                                       SMF SYSTEM ID?
         BNO   II$PDOWN                 NO - SKIP
*---  FOR EXPLANATION OF THE CRUMMY TEST ABOVE, GO READ "FINDRJE"  ---*
          AGO   .II032
.II031    ANOP
         L     R1,SSCTSUSE              -> SSSM module MIT
         CLC   QJ2VERSN,0(R1)           QUEUE assembled for this JES2?
         BNE   II$PDOWN                 no - exit stage left
.II032    ANOP
         MVC   QCLNODE,$SVTONOD         SAVE OUR NODE NUMBER
         SPACE 1
*  NOW, FIND THE SSVT FOR THE SYSTEM WE ACTUALLY ARE INTERESTED IN
II$PDOWN CLC   SSCTSNAM,QJESNAME        DO WE WANT THE PRIMARY?
         BE    II$PRIM                  YES - SAVE OTHER INFO
         SPACE 1
II$SSCT  L     R15,SSCTSCTA             -> NEXT SSCT
         LTR   R15,R15                  END OF CHAIN?
         BZ    II$JNOK                  YES - CONTINUE WITH DEFAULTS
*                           FROM PRIMARY SUBSYS SINCE WE DIDN'T FIND
*                           THE DESIRED SECONDARY SUBSYSTEM
         CLC   SSCTSNAM,QJESNAME        IS THIS THE ONE WE WANT?
         BNE   II$SSCT                  NO - KEEP LOOKING
          AIF   (&QLEVEL GE 9).II050
         L     R14,SSCTSSVT             -> SSVT
         ST    R14,QSVT                 save for CKPT
          AIF   (&QLEVEL LT 8).II060
         L     R7,SVTKAC                -> KAC
          AGO   .II060
.II050    ANOP ,
         L     R14,SSCTSUS2             -> HCCT
         ST    R14,QCCT                 save for CKPT
         L     R7,CCTKAC                -> KAC
.II060    ANOP ,
         LTR   R14,R14                  IS THIS SYSTEM UP?
         BZ    II$JNOK                  NO - CONT WITH DFLT FROM PRIM
         MVC   QCLNODE,$SVTONOD         OUR NODE NUMBER
         SPACE 1
II$PRIM  MVC   QCOMCHAR,$SVCOMCH        SAVE THE COMMUNICATIONS CHAR
          AIF   ('&QALTCC' EQ '').II070
         MVC   QALTCHAR,&QALTCC
.II070    ANOP
         MVC   QSMFID(4),$SVSID         SAVE OUR SYSTEM ID
II$JNOK  ST    R15,QSSCT                SAVE SSCT ADDRESS
          AIF   (&QLEVEL LT 8).IINOPC
         EJECT
***********************************************************************
*                                                                     *
*   Check for incore checkpoint from JES2                             *
*                                                                     *
***********************************************************************
         LTR   R7,R7                    Any KAC?
         BZ    II$NKAC                  No - no in-core copy
         TM    II@FLAGS,II@JESNM        JES() specified?
         BNZ   II$ISUSE                 yes - ok to use in-storage ckpt
         TM    II@FLAGS,II@CKPT+II@DSN  CKPT() or DSN() specified?
         BNZ   II$NKAC                  yes - don't use in-storage ckpt
II$ISUSE EQU   *
         STM   R14,R1,II@REGS           %debug
         TPUTX '>>> ii$isuse'           %debug
         LM    R14,R1,II@REGS           %debug
         USNGX KAC,R7
***********************************************************************
*                                                                     *
*    Code to setup a PC routine - must run in supervisor state.       *
*                                                                     *
***********************************************************************
         LA    R1,4                     Check if authorized
         LNR   R1,R1                    Make conditional
         QCALL AUTHFUNC
         LTR   R15,R15                  Are we authorized
         BNZ   II$NKAC                  Nope cant use incore
         STM   R14,R1,II@REGS           %debug
         TPUTX '>>> auth for pc setup'  %debug
         LM    R14,R1,II@REGS           %debug
*%%% AUTHFUNC needs an option to do the following:
         MODESET KEY=ZERO,MODE=SUP      Get key=0
         TM    KACFLAG1,KAC1BADC+KAC1GONE
         BNZ   II$NKAC1                 No good in core copy
         TM    KACFLAG1,KAC1ECSA        In CSA
         BZ    II$NKAC1                 No good in core copy
         ST    R7,QKACA                 save address of KAC
*   GET A NON-SYSTEM LX
         LA    R2,1
         ST    R2,QPCLXCNT              REQUEST 1 LX
         SPACE 2
II$GLX   LXRES LXLIST=QPCLXL,RELATED=(II$FRLX,II$CONET)
         SPACE 3
*   CREATE PC ROUTINES
         L     R2,=V(CKPT$PC)           get address
          AIF   (&QLEVEL GE 9).IIPC3A
*
**       Build ET entry list
*
         LA    R3,QPCDESC               Point at list
         USNGX ETD,R3
         MVC   ETDNUM,=H'1'             Set number of elements
         LA    R3,ETDEND                Point at first element
         DROPX R3
         USNGX ETDELE,R3
         MVI   ETDEX,0                  Set index number
         MVI   ETDFLG,ETDSUP            Set flags
         ST    R2,ETDPRO2               Set address of routine
         OI    ETDPRO2,ETDAMODE         Set entry to 31 bit
         MVC   ETDAKM(4),=X'FFFFFFFF'   Set valid keys
         ST    R11,ETDPAR               Set latent parameter
         DROPX R3
          AGO   .IIPC3B
.IIPC3A   ANOP
         ETDEF TYPE=SET,ETEADR=QPCETD1,ROUTINE=(2),SSWITCH=NO,         $
               PARM1=(R11),                                            $
               STATE=SUPERVISOR,AKM=(0:15),EKM=(0:15),EK=0,PKM=OR
.IIPC3B   ANOP
II$CET1  ETCRE ENTRIES=QPCDESC,                                        $
               RELATED=(II$CONET,II$DISET,II$DESET)
*
         ST    R0,QPCTKVAL              SAVE RETURNED TOKEN
         SPACE 3
*  CREATE PC NUMBERS
         L     R2,QPCLXVAL              LX = PC# WITH EX OF 0
         LA    R2,0(,R2)                CONSTRUCT EX=0 PC#
         ST    R2,QPCCKPT               SAVE NUMBER
*        LA    R2,1(,R2)                CONSTRUCT EX=1 PC#
*        ST    R2,SERV2PC               SAVE NUMBER
         SPACE 3
*   ESTABLISH ACCESS
         LA    R2,1
         ST    R2,QPCTKCNT              SET COUNT OF ETS TO CONN
*
II$CONET ETCON TKLIST=QPCTKL,LXLIST=QPCLXL,                            $
               RELATED=(II$GLX,II$CET1)
***********************************************************************
*                                                                     *
*   Now compute some values and go to normal                          *
*                                                                     *
***********************************************************************
         OI    QKFLAG,QKFKAC            indicate good KAC
         L     R1,KACCLEN               get length of copy
         A     R1,KACCKPTA               less
         S     R1,KACMSTRA                 length of master rcd
         ST    R1,QCKMLEN               save length of incore
         DROPX R7                       KAC
II$NKAC1 DS    0H
         MODESET KEY=NZERO,MODE=PROB    Out of supervisor state
         LA    R1,8                     release authorization
         QCALL AUTHFUNC
         STM   R14,R1,II@REGS           %debug
         TPUTX '>>> ii$nkac1'           %debug
         LM    R14,R1,II@REGS           %debug
II$NKAC  DS    0H
         STM   R14,R1,II@REGS           %debug
         TPUTX '>>> ii$nkac'            %debug
         LM    R14,R1,II@REGS           %debug
.IINOPC   ANOP
         EJECT
***********************************************************************
*                                                                     *
*   SEE IF SPF DIALOG INTERFACE MODULE IS AVAILABLE                   *
*                                                                     *
***********************************************************************
          AIF   (&@@ISPF LT 230).IINIS1 skip if no ISPQRY
         CLC   ISPLNK,=F'0'             do we have ISPLINK address?
         BE    II$ISQRY                 no - go query ISPF
         OI    II@FLAGS,II@ISPF         yes - remember
         B     II$ISPGO                 skip ISPQRY
         SPACE 2
II$ISQRY LINK  EP=ISPQRY                check ISPF environment
*
         LTR   R15,R15                  valid ISPF environment?
         BNZ   II$NOSPF                 no - skip
         OI    II@FLAGS,II@ISPF         yes - remember
         OI    QISFLAG1,QIS1ISPF        set called from ISPF flag
*
         LOAD  EPLOC==CL8'ISPLINK'      find interface module
*
         ST    R0,ISPLNK                save address
*
          AGO   .IIXIS1
.IINIS1   ANOP
         TM    II@FLAGS,II@ISPF         WAS PARM=ISPF GIVEN?
         BNO   II$NOSPF                 NO - DON'T EVEN TRY
         L     R3,CVTPTR                -> CVT
         LM    R0,R1,=CL8'ISPLINK'      CL8'ISPLINK'
         L     R15,CVTLPDSR-CVTMAP(,R3) -> LPA SEARCH ROUTINE
         STM   R2,R11,II@REGS           save some regs
         BALR  R14,R15                  CALL IT
         B     II$ISPLP                 +0 ==> FOUND IN LPA
*                                       +4 ==> NOT FOUND
         LM    R2,R11,II@REGS           reload regs after LPA search
*---  DO BLDL FOR ISPLINK, TO AVOID TACKY 806 MESSAGE IF SPF IS    ---*
*---  NOT INSTALLED                                                ---*
         MVC   II@BLDL(4),=H'1,12'      SET NUMBER, LENGTH
         MVC   II@BLDLN,=CL8'ISPLINK'   SET MEMBER NAME
         SPACE 1
         BLDL  0,II@BLDL                TRY TO FIND ISPLINK
         SPACE 1
         LTR   R15,R15                  IS IT AVAILABLE?
         BNZ   II$NOSPF                 NO - SKIP
*
         LOAD  DE=II@BLDL+4             load ISPLINK
*
         ST    R0,ISPLNK                save address
         B     II$ISPGO                 continue
         SPACE 2
II$ISPLP LM    R2,R11,II@REGS           reload regs after LPA search
*
         LOAD  EPLOC==CL8'ISPLINK'      ask MVS where it is
*
         ST    R0,ISPLNK                save address
.IIXIS1   ANOP
         SPACE 2
II$ISPGO MVC   II@VLEN,=F'32'           set area length
         L     R15,ISPLNK               get address
         CALL  (15),(=CL8'VCOPY',=CL8'(ZENVIR)',II@VLEN,QPFIND,        $
               =CL8'MOVE'),VL,                                         $
               MF=(E,II@CALLP)
         LTR   R15,R15                  is var defined and no trunc?
         BZ    SP23A1       >========+  yes, so check version
         CH    R15,=H'16'            |  did trunc occur?
         BNE   II$XXSPF              |  no, so not found
SP23A1   CLC   QPFIND(4),=C'ISPF'  <=+  does variable look ok?
         BNE   II$XXSPF                 no - assume old ISPF
         CLC   QPFIND+5(3),=C'2.3'      is envir ISPF 2.3 or higher?
         BL    II$XXSPF                 no - is prior to version 2.3
         OI    QISFLAG1,QIS1V23         yes - remember version 2.3
         CLC   QPFIND+5(3),=C'3.2'      is envir ISPF 3.2 or higher?
         BL    II$XXSPF                 no - is prior to version 3.2
         OI    QISFLAG1,QIS1V32         yes - remember version 3.2
         SPACE 2
II$XXSPF CLC   BRWEPARM,=F'0'           do we have TLD address?
         BNE   II$NOSPF                 yes - ok
         TM    QISFLAG1,QIS1V32         no - do we need it?
         BNZ   II$NOSPF                 no - ok
         MVI   QISFLAG1,0               yes - can't use ISPF interface
         SPACE 1
         DROPX R15,R14                  SSCT, SSVT
***********************************************************************
*                                                                     *
*   Load OACFSORT quicksort routine                                   *
*                                                                     *
***********************************************************************
II$NOSPF DC    0H'0'
          AIF   ('&@@OACFS' EQ '').II080
         LOAD  EPLOC==CL8'&@@OACFS',ERRET=II$806  load sort routine
         ST    R0,QVSORT                save ptr to sort
.II080    ANOP
         B     II$BLKTB                 continue
         SPACE 1
II$806   L     R1,=A(II#MSG10)          -> msg
         TPUT  (1),L'II#MSG10           output it
         ABEND 90                       die
***********************************************************************
*                                                                     *
*   Obtain Block tables for LISTDS, and DDNAME                        *
*                                                                     *
***********************************************************************
II$BLKTB L     R0,QCSIZE                GET TABLE SIZE
         SPACE 1
         GETMAIN  RC,LV=(0),SP=1        TRY TO GET BLOCK ADDR TABLE
         SPACE 1
         LTR   R15,R15                  DID I GET IT?
         BNZ   II$SMALL                 NO - COMPLAIN AND LEAVE NO DUMP
         ST    R1,QCSTART               STORE STARTING ADDR OF TABLE
         L     R0,QDSIZE                GET TABLE SIZE
         SPACE 1
         GETMAIN  RC,LV=(0),SP=1        TRY TO GET BLOCK ADDR TABLE
         SPACE 1
         LTR   R15,R15                  DID I GET IT?
         BNZ   II$SMALL                 NO - COMPLAIN AND LEAVE NO DUMP
         ST    R1,QDSTART               STORE STARTING ADDR OF TABLE
***********************************************************************
*                                                                     *
*   ALLOCATE HASPCKPT                                                 *
*                                                                     *
***********************************************************************
         MVC   QDSNSPC+2(16),QBLANK     CLEAR DSN
         MVC   QDSNCKPT+2(17),QBLANK    CLEAR DSN
         LA    R1,QCKPTPFX              -> PREFIX
         LA    R14,QDSNSPC+2            -> DEST
         LA    R15,QDSNCKPT+2           -> DEST
         LA    R0,44                    MAX NUMBER OF CHARS TO MOVE
         SPACE 1
II$MVPFX MVC   0(1,R14),0(R1)           MOVE 1 CHAR OF PREFIX
         MVC   0(1,R15),0(R1)           ...
         LA    R14,1(,R14)              BUMP PTR
         LA    R15,1(,R15)              ...
         LA    R1,1(,R1)                -> NEXT CHAR OF PREFIX
         CLI   0(R1),C' '               END OF PREFIX?
         BH    II$MVPFX                 NO - CONTINUE
***      MVC   0(8,R14),=C'.HASPACE'    FINISH DSN
         MVC   0(L'II#HSSFX,R14),II#HSSFX  FINISH DSN
***      MVC   0(9,R15),=C'.HASPCKPT'   ...
         MVC   0(L'II#CKSFX,R15),II#CKSFX  ...
***      LA    R14,QDSNCKPT+2-9         COMPUTE LENGTH ...
***      SR    R15,R14                  ... OF HASPCKPT DSN
***      STH   R15,QDSNCKPT             SAVE FOR DAIR
***      BCTR  R15,0                    COMPUTE LENGTH OF HASPACE DSN
***      STH   R15,QDSNSPC              SAVE FOR DAIR
         MVC   QDSNCKPT,=H'44'          tell DAIR the length
         MVC   QDSNSPC,=H'44'           ...
         SPACE 1
         MVC   DA08SER(6),QCKPTVOL      MOVE IN HASPCKPT VOLSER
         LA    R15,QDSNCKPT             -> DSNAME FOR ALLOCATE
         ST    R15,DA08PDSN             SET IN DAIR BLOCK
         MVI   DAIRFLAG,X'08'           REQUEST ALLOCATE FUNCTION
          AIF   (&QLEVEL LT 8).II50A
***%%%   TM    QKFLAG,QKFKAC            Doing incore
***%%%   BO    II$KMST                  Yes so skip alloc
.II50A    ANOP
         QCALL ALLOCATE                 CALL DAIR
***********************************************************************
*                                                                     *
*   OPEN HASPCKPT, READ FIRST BLOCK OF CHECKPOINT                     *
*                                                                     *
***********************************************************************
         L     R3,QCCKPT                -> HASPCKPT DCB
         USNGX IHADCB,R3
          AIF   (&QLEVEL LT 4).II090
         DEVTYPE  DA08DDN,DVAREA,DEVTAB,RPS  GET DEVICE TYPE INFO
         SPACE 1
         L     R0,DVAMAXRC              MAX BLKSIZE FOR DEVICE
         STH   R0,DCBBLKSI              SET BLKSIZE IN CKPT DCB
.II090    ANOP
         MVC   DCBDDNAM,DA08DDN         GET DDNAME DAIR RETURNED
         LA    R1,II#EXLST              -> DCB EXIT LIST
         STCM  R1,B'0111',DCBEXLSA      SET INTO DCB
         BAL   R14,QAMODE24             change to AMODE 24
         SPACE 1
         OPEN  MF=(E,QCCKPT)            OPEN HASPCKPT
         SPACE 1
         BAL   R14,QAMODE31             resume AMODE 31
*  IT MIGHT BE NICE TO CHECK TO SEE THAT IT OPENED!!!!
          AIF   (&QLEVEL LT 4).II110
          AIF   (&QLEVEL LT 8).II100
         SPACE 1
*
*        FORMAT OF CHECKPOINT MASTER RECORD
*        $SAVEBEG - START OF HCT AREA
*                   ($SAVELEN LONG)
*        QSE1     - START OF QSE AREA
*                   (QSELEN*$QSEMAX)
*        $JQEEXT  - START OF JQE EXTENSION
*                   ($MAXEXSZ)
*        $DASEXT  - START OF DAS EXTENSIONS
*                   (DASEXLEN*$SPOLNUM)
*        $KITPTR  - POINTER TO CHECKPOINT INFO TABLES
*                   ($KITNUM*KITLNGTH)
*        $CTLB    - POINTER TO CHECKPT I/O CONTROL BYTES
*
         SPACE 1
.II100    ANOP
**??**?? LA    R2,DVATAB                -> DEVTYPE INFO FOR TRKCALC
         SR    R2,R2                    CLEAR FOR ICM
         ICM   R2,B'0111',DCBDVTBA      -> DEVTYPE INFO
         L     R4,=X'01001000'          # OF 4K BLOCKS/TRK
         XC    II@TRKCA(II@TRKCL),II@TRKCA  CLEAR MF=L AREA
         SPACE 1
         TRKCALC  FUNCTN=TRKCAP,DEVTAB=(R2),RKDD=(R4),REGSAVE=YES,     $
               MF=(E,II@TRKCA)
         SPACE 1
         ST    R0,II@CKRT               SAVE # 4K BLKS/TRK ON CKPT
.II110    ANOP
         SPACE 1
*---  GETMAIN DECB WORK AREA FOR CKPT ROUTINE                      ---*
         SR    R0,R0                    CLEAR FOR IC
         IC    R0,DCBNCP                GET NCP VALUE FROM DCB
*%%%     LTR   R0,R0                    ANYTHING THERE?
*%%%     BNZ   *+8                      YES - USE IT
*%%%     LA    R0,&QCHKNCP              NO - USE GENNED DEFAULT VALUE
         MH    R0,=Y(HDECB1L)           * LENGTH OF EACH DECB
         ST    R0,QLCKDECB              SAVE LENGTH FOR FREEMAIN
         ICM   R0,B'1000',=AL1(1)       SUBPOOL 1
         GETMAIN  R,LV=(0)
         ST    R1,QVCKDECB              SAVE ADDR (ALSO FOR FREEMAIN)
         TM    QKFLAG,QKFKAC            Doing incore?
         BO    II$KMST                  yes - skip disk READ
         BAL   R14,QAMODE24             change to AMODE 24
         SPACE 1
         POINT (R3),=FS8'3'             POINT PAST SYNC RECORDS TO REC3
         SPACE 1
         L     R1,QCDECB1               -> HASPCKPT DECB
         L     R2,QCSTART               USE TABLE AREA FOR IOAREA
         SPACE 1
         READ  (1),SF,,(R2),MF=E        READ FIRST RECORD
         SPACE 1
         L     R1,QCDECB1               -> HASPCKPT DECB
         SPACE 1
         CHECK (1)
         SPACE 1
         BAL   R14,QAMODE31             resume AMODE 31
         SPACE 3
         DROPX R3                       IHADCB
         USNGX $SAVEBEG,R2              BASE REG FOR CHECKPOINT
          AIF   (&QLEVEL LT 7).II120    %%%
          AIF   (&QLEVEL LT 8).II50B
         B     II$KMSTE                 skip over if using DASD
*
*
*
II$KMST  DS    0H                       Get Master from incore
         LA    R1,4                     Get authorized
         QCALL AUTHFUNC
         MODESET KEY=ZERO,MODE=SUP      Get key=0
         L     R2,QCSTART               get temp area
         L     R3,QCKMLEN               get length
         L     R1,QKACA                 get KAC address
         L     R0,KACMSTRA-KAC(,R1)     get master record
         LR    R1,R3
         MVCL  R2,R0                    move in master
         MODESET KEY=NZERO,MODE=PROB    Out of supervisor state
         LA    R1,8                     release authorization
         QCALL AUTHFUNC
         L     R2,QCSTART               reload table area for mstr
II$KMSTE DS    0H
.II50B    ANOP
         MVC   QCJQELEN,$JQELEN         SAVE JQE LENGTH
          AGO   .II130                  %%%
.II120    ANOP
         MVC   QCJQELEN,=Y(JQELNGTH)    SET JQE LENGTH
.II130    ANOP
          AIF   (&QLEVEL LT 4).II140
         MVC   QCLNODE,$NODEID          SAVE OUR LOCAL NODE NUMBER
.II140    ANOP
         CLC   =C'JES2',$HASPID         ID IN CORRECT PLACE?
         BE    II$HIDOK                 YES - CONTINUE
         L     R1,=A(II#MSG9)           -> MSG TEXT
         TPUT  (1),L'II#MSG9            'WRONG VERSION'
         ABEND 91
II$HIDOK DC    0H'0'
          AIF   (&QLEVEL LT 8).II150
***********************************************************************
*                                                                     *
*   Compute size of track group maps on ckpt                          *
*                                                                     *
***********************************************************************
         L     R5,$NUMTG                NUMBER OF TRACK GROUPS TOTAL
         LA    R5,7(,R5)                round up!!                *LDW*
         SRL   R5,3                     DIVIDE BY 8
         LR    R1,R5                    SAVE LENGTH OF TRACK GROUP MAP
         SLL   R1,1                     NUMBER OF BYTES * 2
         LA    R1,BFPLEN(,R1)           ADD BUFFER PREFIX
         LA    R1,4095(,R1)             PREPARE TO ROUND
         SRL   R1,12                    DIVIDE BY 4K
         STH   R1,QCTGML                NUMBER OF BLOCKS FOR TG MAPS
          AGO   .II250
.II150    ANOP
***********************************************************************
*                                                                     *
*   COMPUTE OFFSET TO FIRST PDDB IN IOT                               *
*                                                                     *
***********************************************************************
          AIF   (&QLEVEL GE 4).II160
         LH    R5,$NUMTGV               NUMBER OF TRK GROUPS PER VOLUME
         LA    R5,7(,R5)                ROUND UP TO MULTIPLE OF 8
         SRL   R5,3                     DIVIDE BY 8
         SR    R0,R0                    CLEAR FOR IC
         IC    R0,$NUMDA                NUMBER OF SPOOL VOLUMES
         MR    R4,R0                    LENGTH OF TRK GROUP MAP IN R5
         MH    R0,$NUMTGV               * number of trk grps/vol
         ST    R0,QCNUMTGA              save for later
          AGO   .II170
.II160    ANOP
         LH    R5,$NUMTG                NUMBER OF TRK GROUPS PER VOLUME
         LA    R5,7(,R5)                ROUND UP TO MULTIPLE OF 8
         SRL   R5,3                     DIVIDE BY 8
.II170    ANOP
         STH   R5,QCTGMLEN              SAVE LENGTH OF TRACK GROUP MAP
          AIF   (&QLEVEL GE 5).II180
         LA    R5,IOTTGMAP-IOTSTART+TGMAP-TGMDSECT+3(,R5)   OFFSET
         N     R5,=F'-4'                ROUND TO FULL WORD BOUNDARY
         ST    R5,QCPDDB1               SAVE OFFSET TO 1ST PDDB IN IOT
         SPACE 1
          AIF   (&QLEVEL LT 4).II240
         LH    R0,$NUMTG                GET TOTAL NUMBER OF TRK GROUPS
         ST    R0,QCNUMTGA              SAVE AS NUMBER OF ACT TRK GRPS
         SPACE 1
.II180    ANOP
***********************************************************************
*                                                                     *
*   COMPUTE SIZE OF DAS AREA ON CHECKPOINT                            *
*                                                                     *
***********************************************************************
          AIF   (&QLEVEL LT 7).II190
         LH    R15,$SPOLNUM             NUMBER OF SPOOL VOLUMES
         MH    R15,=Y(DASSIZ)           * SIZE OF EACH DAS
         QCBLKNUM  R15                  COMPUTE NUMBER OF CKPT RECORDS
         ST    R15,QCDASL               SAVE # OF BLOCKS FOR DAS
         L     R1,$NUMTG                NUMBER OF TRK GRPS PER VOLUME
         SRL   R1,3                     DIVIDE BY 8 = LEN OF TG MAP
.II190    ANOP
***********************************************************************
*                                                                     *
*   COMPUTE NUMBER OF TRACK GROUP MAPS ON CKPT                        *
*                                                                     *
***********************************************************************
          AIF   (&QLEVEL GE 7).II200
         LH    R1,QCTGMLEN              GET LENGTH OF TRACK GROUP MAP
.II200    ANOP
         AR    R1,R1                    NUMBER OF BYTES * 2
         QCBLKNUM  R1                   COMPUTE NUMBER OF CKPT RECORDS
         STH   R1,QCTGML                NUMBER OF BLOCKS FOR TG MAPS
*%%II%%1  ANOP
***********************************************************************
*                                                                     *
*   COMPUTE NUMBER OF JIX BLOCKS ON CKPT                              *
*                                                                     *
***********************************************************************
         LH    R5,$NUMJBNO              NUMBER OF JOB NUMBERS
         LA    R5,1(,R5)                PLUS 1 FOR HEADER
         AR    R5,R5                    TIMES LENGTH OF 2
         QCBLKNUM  R5                   COMPUTE NUMBER OF CKPT RECORDS
         STH   R5,QCJIXL                NUMBER OF BLOCKS FOR JIX
***********************************************************************
*                                                                     *
*   FIND KIT AREA IN MASTER RECORD                                    *
*                                                                     *
***********************************************************************
          AIF   (&QLEVEL GT 4).II210
         L     R3,$MASTERL              LENGTH OF MASTER RECORD
         AR    R3,R2                    -> PAST END OF MASTER RECORD
         SH    R3,=Y(KITLNGTH)          -> LAST KIT
         ST    R3,II@KITL               SAVE ADDR OF LAST KIT
         USNGX KITDSECT,R3
II$KIT1L CLC   KITORG,=F'0'             THIS FIRST KIT?
         BE    II$KIT1F
         SH    R3,=Y(KITLNGTH)          BACK UP ONE KIT
         B     II$KIT1L
         DROPX R3                       KITDSECT
II$KIT1F ST    R3,II@KITF               SAVE ADDR FIRST KIT
          AGO   .II230
.II210   ANOP
*  REFERENCE HASPIRDA
          AIF   (&QLEVEL GE 7).II220
         LA    R1,$SAVELEN(,R2)         -> FIRST QSE
         LA    R0,QSELEN                LENGTH OF A QSE
         MH    R0,$QSENO                TOTAL FOR ALL SYSTEMS
         AR    R1,R0                    -> FIRST DAS
         A     R1,=A(DASSIZ*$MAXDA)     -> FIRST KIT
         ST    R1,II@KITF               SAVE ADDR FIRST KIT
         AH    R1,=Y(KITLNGTH*(7-1))    -> LAST KIT   *KLUDGE*?
         ST    R1,II@KITL               SAVE ADDR LAST KIT
          AGO   .II230
.II220    ANOP
         LA    R1,$SAVELEN(,R2)         -> FIRST QSE
         LA    R0,QSELEN                LENGTH OF A QSE
         MH    R0,$QSENO                TOTAL FOR ALL SYSTEMS
         AR    R1,R0                    -> JQE EXTENSION AREA
         AH    R1,$MAXEXSZ              -> FIRST KIT
         ST    R1,II@KITF               SAVE ADDR FIRST KIT
         AH    R1,=Y(KITLNGTH*(8-1))    -> LAST KIT   *KLUDGE*?
         ST    R1,II@KITL               SAVE ADDR LAST KIT
.II230    ANOP
         SPACE 1
*---  FIND JQE TABLE BLOCK #; # OF BLOCKS                          ---*
         L     R0,=CL4'JQE '            ID FOR JQE'S
         BAL   R14,II$KITFD             SEARCH KIT FOR JQE SLOT
         EX    0,*                      DIE IF SYSTEM HAS NO JQE'S
         USNGX KITDSECT,R1
         LH    R6,KITRECN               # OF BLOCKS OF JOE'S
         ST    R6,QCJQENUM              SAVE # BLOCKS OF JQE'S
         BAL   R14,II$CKTTR             COMPUTE TTR OF JQE'S
         DROPX R1                       KITDSECT
         ST    R1,QCJQETTR              SAVE TTR OF JQE'S
         SPACE 1
*---  FIND JOE TABLE BLOCK #; # OF BLOCKS                          ---*
         L     R0,=CL4'JOE '            ID FOR JOE'S
         BAL   R14,II$KITFD             SEARCH KIT FOR JQE SLOT
         EX    0,*                      DIE IF SYSTEM HAS NO JQE'S
         USNGX KITDSECT,R1
         LH    R3,KITRECN               # OF BLOCKS OF JOE'S
         ST    R3,QCJOENUM              SAVE # OF BLOCKS OF JOE'S
         BAL   R14,II$CKTTR             COMPUTE TTR OF JOE'S
         DROPX R1                       KITDSECT
         ST    R1,QCJOETTR              SAVE TTR OF JOE'S
         SPACE 1
*%%%%%%%  AIF   (&QLEVEL LT 5).II%%2
.II240    ANOP
.II250    ANOP
         SPACE 1
***********************************************************************
*                                                                     *
*   OBTAIN SYSTEM ID'S FROM QSE'S                                     *
*                                                                     *
***********************************************************************
         LA    R15,$SAVEEND             -> FIRST QSE
         USNGX QSEDSECT,R15
         LA    R14,QSMFID               -> SYSTEM ID TABLE ZERO'TH ENT
         LH    R0,$QSENO                NUMBER OF MEMBERS IN THIS NODE
         SPACE 1
II$QSELP LA    R14,L'QSMFID(,R14)       -> NEXT SYSTEM ID TABLE ENTRY
         MVC   0(4,R14),QSESID          SAVE SYSTEM ID
         LA    R15,QSELEN(,R15)         -> NEXT QSE
         BCT   R0,II$QSELP              DO ALL QSE'S
         DROPX R15                      QSEDSECT
         SPACE 1
***********************************************************************
*                                                                     *
*   TRANSLATE SMF ID'S TO USER FRIENDLY NAMES                         *
*                                                                     *
***********************************************************************
         MVC   QSYSID(L'QSYSID*8),QSMFID  COPY THE WHOLE TABLE
         LA    R0,8                     NUMBER OF TABLE ENTRIES
         LA    R14,QSYSID               -> FIRST ONE
II$QSEL2 LA    R15,SMFTABLE             -> TRANSLATION TABLE
II$QSEL3 CLI   0(R15),X'FF'             END OF TABLE?
         BE    II$QSEN2                 YES - GIVE UP AND TRY NEXT ID
         CLC   0(4,R14),0(R15)          THIS IT?
         BNE   II$QSEN1                 NO - TRY NEXT TRANS TABLE ENTRY
         MVC   0(4,R14),4(R15)          YES - USE USER FRIENDLY NAME
         B     II$QSEN2                 AND PROCESS NEXT ID
II$QSEN1 LA    R15,8(,R15)              -> NEXT TRANSLATION TABLE ENTRY
         B     II$QSEL3                 KEEP LOOKING
II$QSEN2 LA    R14,L'QSYSID(,R14)       -> NEXT SMF ID TO TRANSLATE
         BCT   R0,II$QSEL2              DO IT
         SPACE 1
          AIF   (&QLEVEL GE 8).II310
***********************************************************************
*                                                                     *
*   COMPUTE NUMBER OF JQE BLOCKS ON CKPT                              *
*                                                                     *
***********************************************************************
         LH    R6,$MAXJOBS              NUMBER OF JQES
         LA    R6,1(,R6)                PLUS 1 FOR EYE-CATCHER
          AIF   (&QLEVEL GE 7).II260
         MH    R6,=AL2(JQELNGTH)        MULTIPLY BY LENGTH OF JQE
         QCBLKNUM  R6                   COMPUTE NUMBER OF CKPT RECORDS
          AGO   .II270
.II260    ANOP
         MH    R6,=Y(JQEBLEN+4)         MULTIPLY BY LENGTH OF JQE
*                                       ... ASSUMING 1 WORD FOR ...
*                                       ... SPOOLS USED MASK %%%%%
         QCBLKNUM  R6                   COMPUTE NUMBER OF CKPT RECORDS
***********************************************************************
*                                                                     *
*   COMPUTE NUMBER OF PST BLOCKS IN CKPT                              *
*                                                                     *
***********************************************************************
         LH    R15,$NUMJOES             NUMBER OF JOES
         QCBLKNUM  R15                  COMPUTE NUMBER OF CKPT RECORDS
         ST    R15,QCPSTL               SAVE                          
.II270    ANOP
***********************************************************************
*                                                                     *
*   COMPUTE NUMBER OF JOT BLOCKS IN CKPT                              *
*                                                                     *
***********************************************************************
         LH    R3,$NUMJOES              NUMBER OF JOES
*  I THINK CL DID THIS WRONG... <LDW>   %%%%
*%%       AIF   (&QLEVEL LT 7).II280
*%%      LA    R3,NJOTPRFX(,R3)         ADJUSTED LENGTH OF JOT PREFIX
.II280    ANOP
         MH    R3,=AL2(JOESIZE)         MULTIPLY BY LENGTH OF JOE
*  CL DIDN'T HAVE THIS INSTRUCTION:     %%%%
         LA    R3,JOTJOES-JOTDSECT(,R3) ADD LENGTH OF JOT PREFIX AREA
         QCBLKNUM  R3                   COMPUTE NUMBER OF CKPT RECORDS
***********************************************************************
*                                                                     *
*   COMPUTE TOTAL LENGTH OF QSES                                      *
*                                                                     *
***********************************************************************
         LA    R4,QSELEN                QSE LENGTH
         MH    R4,$QSEMAX               LENGTH TIMES NUMBER OF QSES
          AIF   (&QLEVEL GE 5).II300
          AIF   (&QLEVEL LT 4).II290
         ALR   R4,R5                    ADD ONE BYTE FOR EACH JIX BLOCK
***********************************************************************
*                                                                     *
*   COMPUTE NUMBER OF MSQ BLOCKS ON CKPT                              *
*                                                                     *
***********************************************************************
         LH    R1,$NUMRJE               NUMBER OF REMOTES
         MH    R1,=Y(3)                 TIMES LENGTH OF 3
         LA    R1,3(,R1)                PLUS HEADER LENGTH
         LA    R1,4095(,R1)             PREPARE TO ROUND
         SRL   R1,12                    DIVIDE BY 4096
         ALR   R4,R1                    ADD 1 BYTE FOR EACH BLOCK
***********************************************************************
*                                                                     *
*   COMPUTE NUMBER OF RSO BLOCKS ON CKPT                              *
*                                                                     *
***********************************************************************
         LH    R1,$NUMRJE               NUMBER OF REMOTES
         LA    R1,4095(,R1)             PREPARE TO ROUND
         SRL   R1,12                    DIVIDE BY 4096
         ALR   R4,R1                    ADD 1 BYTE FOR EACH BLOCK
***********************************************************************
*                                                                     *
*   COMPUTE NUMBER OF LCK BLOCKS ON CKPT                              *
*                                                                     *
***********************************************************************
*%%%%%   LH    R1,$NUMLCK               NUMBER OF LOAD CKPT ELEMENTS
         LA    R1,9*7                   NUMBER OF LOAD CKPT ELEMENTS
         MH    R1,=Y(LCKSIZE)           TIMES LENGTH OF EACH
         LA    R1,4095(,R1)             PREPARE TO ROUND
         SRL   R1,12                    DIVIDE BY 4096
         ALR   R4,R1                    ADD 1 BYTE FOR EACH BLOCK
.II290    ANOP
         ALR   R4,R6                    ADD ONE BYTE FOR EACH JQE BLOCK
         ALR   R4,R3                    ADD ONE BYTE FOR EACH JOT BLOCK
.II300    ANOP
.II310    ANOP
***********************************************************************
*                                                                     *
*   COMPUTE HASPACE BUFFER SIZE                                       *
*                                                                     *
***********************************************************************
         LH    R5,$BUFSIZE              BLKSIZE FOR HASPACE
         L     R1,QCDECB2               -> HASPACE DECB
         STH   R5,6(,R1)                STORE IN DECB
         STH   R5,QCHSBLK               SAVE IN QCOMMON
         LA    R5,63(,R5)               PREPARE TO ROUND
         N     R5,=F'-64'               ROUND TO 64 BYTE BOUNDARY
***********************************************************************
*                                                                     *
*   OBTAIN BUFFERS FOR HASPCKPT AND HASPACE                           *
*                                                                     *
***********************************************************************
         LR    R14,R5                   HASPACE BUFFER SIZE
         MH    R14,=H'3'                3 BUFFERS
          AIF   (&QLEVEL GE 8).II330
         LA    R1,1(R6,R3)              NUMBER OF BLOCKS IN CKPT DS
          AIF   (&QLEVEL LT 4).II320
         AH    R1,QCJIXL                ADD NUMBER OF JIX BLOCKS
          AIF   (&QLEVEL LT 5).II320
         AH    R1,QCTGML                ADD NUMBER OF TGM BLOCKS
          AIF   (&QLEVEL LT 7).II320
         A     R1,QCDASL                ADD NUMBER OF DAS BLOCKS      
         A     R1,QCPSTL                ADD NUMBER OF PST BLOCKS      
.II320    ANOP
          AGO   .II340
.II330    ANOP
         LH    R1,$CKRECN               number of 4K records
         LA    R1,1(,R1)                plus master record
         AH    R1,$CLRECN               plus number of change log recs
.II340    ANOP
         ST    R1,QCJOTL                STORE RECORD COUNT
         SLL   R1,12                    MULTIPLY BY 4096
          AIF   (&QLEVEL LT 4).II350
         L     R15,$MASTERL             GET LENGTH OF MASTER RECORD
         LA    R15,4095(,R15)           PREPARE TO ROUND
         SRL   R15,12                   ROUND TO 4K
         SLL   R15,12                   GET BACK AS MULT OF 4K
         ST    R15,QCSMLEN              SAVE FOR LATER
         AR    R1,R15    %%%???%%%      INCREMENT SIZE TO GETMAIN     
          AGO   .II360
.II350    ANOP
         MVC   QCSMLEN,=F'4096'         SET MASTER RECORD LENGTH
.II360    ANOP
         LA    R7,256(R1,R14)           ADD CKPT & HASPACE BFRS, SLOP
         ST    R7,QCKPTLEN              SAVE LENGTH FOR FREEMAIN
         GETMAIN  RU,LV=(R7),SP=1       OBTAIN BUFFERS
         ST    R1,QCJQTL                BUFFER FOR FIRST CKPT REC
          AIF   (&QLEVEL LT 8).II370
         TPUTX '>>> initial calling ckpt'  %debug
         MVC   QDMSG(11),=C'>>> (qkaca='   %debug
         HEX   QDMSG+11,QKACA,LEN=4,BYTE=C')',HEXTAB=QHEXTAB  %debug
         TPUTX QDMSG,20                 %debug
         MVC   QDMSG,QBLANK             %debug
         QCALL CKPT                     read ckpt data
         TPUTX '>>> initial back from ckpt'  %debug
         L     R1,QCJQTL                restore buffer address
         LA    R4,QSELEN                QSE length
         MH    R4,$QSEMAX               * number of QSEs
.II370    ANOP
          AIF   (&QLEVEL LT 7).II380
         LR    R14,R1                   COMPUTE ADDR OF JQE EXTENSION
         LA    R14,$SAVELEN(,R14)       ACCOUNT FOR CHECKPOINTED HCT
         AR    R14,R4                   ACCOUNT FOR QSE'S
         ST    R14,QCJQEXA              SAVE ADDR OF JQE EXTENSION
.II380    ANOP
          AIF   (&QLEVEL GT 3).II390
         AH    R1,=H'4096'              INCREMENT
          AGO   .II460
.II390    ANOP
         A     R1,QCSMLEN               ADD ROUNDED LENGTH OF MSTR REC
          AIF   (&QLEVEL LT 8).II400
*%%%     TM    QKFLAG,QKFKAC            If incore - no change blks
*%%%     BO    II$NOCKB
         LH    R15,$CLRECN              number of change log blks
         SLL   R15,12                   * 4k
         AR    R1,R15                   bump past change log
II$NOCKB DS    0H
*---
         LA    R15,=CL4'TGM'            -> pool id
         BAL   R14,II$CK$PI             check pool id
         ST    R0,QCTGMA                buffer for TGM blocks
*---
         LA    R15,=CL4'JIX'            -> pool id
         BAL   R14,II$CK$PI             check pool id
         ST    R0,QCJIXA                buffer for JIX blocks
*---
         LA    R15,=CL4'JQE'            -> pool id
         BAL   R14,II$CK$PI             check pool id
         ST    R0,QCJQTA                buffer for JQE blocks
*---
         LA    R15,=CL4'PST'            -> pool id
         BAL   R14,II$CK$PI             check pool id
         ST    R0,QCPSTA                buffer for PST blocks
*---
         LA    R15,=CL4'JOE'            -> pool id
         BAL   R14,II$CK$PI             check pool id
         ST    R0,QCJOTA                buffer for JOE blocks
*---
         LA    R15,=CL4'RSO'            -> pool id
         BAL   R14,II$CK$PI             check pool id
**       ST    R0,                      buffer for RSO blocks
*---
         LA    R15,=CL4'LCK'            -> pool id
         BAL   R14,II$CK$PI             check pool id
**       ST    R0,                      buffer for LCK blocks
*---
         LA    R15,=CL4'DAS'            -> pool id
         BAL   R14,II$CK$PI             check pool id
         ST    R0,QCDASA                buffer for DAS blocks
*---
          AGO   .II510
.II400    ANOP
          AIF   (&QLEVEL LT 5).II430
          AIF   (&QLEVEL GE 7).II410
         ST    R1,QCTGMA                BUFFER FOR TGM BLOCKS
          AGO   .II420
.II410    ANOP
         LA    R0,BFPLEN(,R1)           ADD BUFFER PREFIX
         ST    R0,QCDASA                BUFFER FOR DAS BLOCKS
         L     R15,QCDASL               NUMBER OF DAS BLOCKS
         SLL   R15,12                   * 4096
         AR    R1,R15                   INCREMENT
         LA    R0,BFPLEN(,R1)           ADD BUFFER PREFIX
         ST    R0,QCTGMA                BUFFER FOR TGM BLOCKS
.II420    ANOP
         LH    R15,QCTGML               NUMBER OF TGM BLOCKS
         SLL   R15,12                   * 4K
         AR    R1,R15                   INCREMENT
.II430    ANOP
          AIF   (&QLEVEL GE 7).II440
         ST    R1,QCJIXA                BUFFER FOR JIX BLOCKS
          AGO   .II450
.II440    ANOP
         LA    R0,BFPLEN(,R1)           ADD BUFFER PREFIX
         ST    R0,QCJIXA                BUFFER FOR JIX BLOCKS
.II450    ANOP
         LH    R15,QCJIXL               NUMBER OF JIX BLOCKS
         SLL   R15,12                   TIMES 4096
         AR    R1,R15                   INCREMENT
.II460    ANOP
          AIF   (&QLEVEL GE 7).II470
         ST    R1,QCJQTA                BUFFER FOR JQE BLOCKS
          AGO   .II480
.II470    ANOP
         LA    R0,BFPLEN(,R1)           ADD BUFFER PREFIX
         ST    R0,QCJQTA                BUFFER FOR JQE BLOCKS         
.II480    ANOP
         SLL   R6,12                    MULTIPLY BY 4096
         AR    R1,R6                    INCREMENT
          AIF   (&QLEVEL GE 7).II490
         ST    R1,QCJOTA                BUFFER FOR JOE BLOCKS
          AGO   .II500
.II490    ANOP
         LA    R0,BFPLEN(,R1)           ADD BUFFER PREFIX
         ST    R0,QCPSTA                BUFFER FOR PST BLOCKS
         L     R15,QCPSTL               NUMBER OF PST BLOCKS          
         SLL   R15,12                   TIMES 4096
         AR    R1,R15                   INCREMENT
         LA    R0,BFPLEN(,R1)           ADD BUFFER PREFIX
         ST    R0,QCJOTA                BUFFER FOR JOE BLOCKS
.II500    ANOP
         SLL   R3,12                    MULTIPLY BY 4096
         LA    R3,1(,R3)                add in other from above
         AR    R1,R3                    INCREMENT
.II510    ANOP
         ST    R1,QCJCTA                BUFFER FOR JCT
         AR    R1,R5                    INCREMENT
         ST    R1,QCIOTA                BUFFER FOR IOT
         AR    R1,R5                    INCREMENT
         ST    R1,QCBLKA                BUFFER FOR DATA BLOCKS
         LA    R1,$JQHEADS-$SAVEBEG     OFFSET TO FIRST JQE HEADER
         A     R1,QCJQTL                BASE OF FIRST CKPT REC
         ST    R1,QCJQHEAD              ADDR OF FIRST JQE HEADER
          AIF   (&QLEVEL LT 11).II511
         GETMAIN  RU,LV=(R5),SP=1
         ST    R1,QCJCTNJH              -> NJE sections
         ST    R5,QLJCTNJE              save for freemain
         MVC   QCJCTNJN,=H'1'           start with 1 buffer
.II511    ANOP
***********************************************************************
*                                                                     *
*   ALLOCATE AND OPEN HASPACE                                         *
*                                                                     *
***********************************************************************
         LA    R15,QDSNSPC              -> DSNAME FOR ALLOCATE
         ST    R15,DA08PDSN             SET IN DAIR BLOCK
          AIF   (&QLEVEL GE 8).II550
          AIF   (&QLEVEL GE 7).II540
          AIF   (&QLEVEL EQ 4).II520
         LA    R3,$SAVEEND(R4)          -> DA CKPT INFO IN MASTER REC
          AIF   (&QLEVEL GE 4).II530
         SR    R4,R4                    CLEAR FOR IC
         IC    R4,$NUMDA                MAXIMUM NUMBER OF SPOOL VOLUMES
          AGO   .II570
.II520    ANOP
         LH    R1,$QSENO                # OF QSE'S
         MH    R1,=Y(QSELEN)            * LENGTH OF EACH QSE
         AH    R1,$CKRECN               + TOTAL # 4K CKPT RECORDS
         LA    R3,$SAVEEND(R1)          -> DA CKPT INFO IN MASTER REC
.II530    ANOP
         LA    R4,$MAXDA                MAXIMUM NUMBER OF SPOOL VOLUMES
          AGO   .II570
.II540    ANOP
         L     R3,QCJQTL                -> IOAREA FOR CKPT RECORDS
         A     R3,QCSMLEN               -> DAS INFO AREA
         L     R1,QCDECB1               -> HASPCKPT DECB
         BAL   R14,QAMODE24             change to AMODE 24
         SPACE 1
         READ  (1),SF,,(R3),MF=E        READ DAS
         SPACE 1
         L     R1,QCDECB1               -> HASPCKPT DECB
         SPACE 1
         CHECK (1)
         SPACE 3
         BAL   R14,QAMODE31             resume AMODE 31
         LA    R3,BFPLEN(,R3)           SKIP OVER BUFFER PREFIX
          AGO   .II560
.II550    ANOP
         L     R3,QCDASA                -> DAS area
.II560    ANOP
         LH    R4,$SPOLNUM              NUMBER OF SPOOL VOLUMES ALLOWED
.II570    ANOP
*        LA    R7,QCDCBL                LENGTH OF HASPACE DCB
         LA    R7,QCDCBL+4+4+1          len of dcb + support tables
         MR    R7-1,R4                  COMPUTE LENGTH OF DCB POOL
         ST    R7,QLSPDCB               SAVE LENGTH FOR FREEMAIN
         GETMAIN  RU,LV=(R7),SP=1       OBTAIN DCB POOL
         ST    R1,QVSPDCB               SAVE ADDRESS FOR FREEMAIN
*        LR    R7,R1                    SAVE ADDR OF DCB POOL
*        LA    R5,QCSPOOLS-4            ADDR OF OPEN LIST
         ST    R1,QCEXTMAP              -> Extent map table
         MVI   0(R1),X'FF'              invalid entry
         MVC   1(*-*,R1),0(R1)          prop 1 byte
         EX    R4,*-6                   do it all (slop is ok)
         AR    R1,R4                    -> Open list
         LA    R1,3(,R1)                +3
         N     R1,=A(X'FFFFFFFC')       round down to fw
         ST    R1,QCSPOOLS              save it
         LR    R5,R1                    copy ptr
         LR    R7,R4                    copy number of entries
         SLL   R7,2                     * entry len
         AR    R1,R7                    -> tracks/cyl table
         ST    R1,QCTRKCYL
         AR    R7,R1                    -> DCB pool
         SH    R5,=H'4'                 Back up 1 entry
         SR    R6,R6                    ACTUAL NUMBER OF SPOOL VOLUMES
          AIF   (&QLEVEL GE 7).II580
         MVC   DA08SER(5),$SPOOL        PATTERN FOR VOLSER
.II580    ANOP
         DROPX R2                       $SAVEBEG
         SPACE 1
          AIF   (&QLEVEL GE 5).II590
II$SPL1  CLI   0(R3),0                  IS THIS VOLUME UNUSED?
         BE    II$SPL4                  YES. TRY NEXT.
         CLI   0(R3),X'FF'      %%%     WAS THIS VOLUME REMOVED?
         BE    II$SPL4          %%%     YES. TRY NEXT.
          AGO   .II600
.II590    ANOP
         USNGX DASDSECT,R3
II$SPL1  TM    DASFLAG,DASEXSTS         DOES VOLUME EXIST?
         BZ    II$SPL4                  NO - SKIP THIS ONE
         TM    DASFLAG2,DASINACT        IS IT INACTIVE?
         BO    II$SPL4                  YES - SKIP IT
          AIF   (&QLEVEL LT 5).II600
         LH    R15,DASNOTGE             NUMBER OF TRACKS IN EXTENT
         A     R15,QCNUMTGA             ACCUMULATE ACTIVE ...
         ST    R15,QCNUMTGA             ... TRACK GROUP COUNT
.II600    ANOP
         LA    R5,4(,R5)                -> NEXT ENTRY IN OPEN LIST
         MVC   DA08UNIT,=C'SYSALLDA'    MOVE UNIT NAME
          AIF   (&QLEVEL GE 7).II620
          AIF   (&QLEVEL GE 5).II610
         MVC   DA08SER+5(1),1(R3)       LAST DIGIT OF VOLSER
          AGO   .II630
.II610    ANOP
         MVC   DA08SER+5(1),DASVOLID+5  LAST DIGIT OF VOLSER
          AGO   .II630
.II620    ANOP
         MVC   DA08SER(6),DASVOLID      VOLSER OF THIS SPOOL VOLUME
.II630    ANOP
         LA    R6,1(,R6)                INCREASE COUNT BY ONE
         QCALL ALLOCATE                 CALL DAIR
         L     R1,=A(HASPACE)           -> PATTERN DCB
         MVC   0(QCDCBL,R7),0(R1)       MOVE PATTERN DCB TO POOL
         MVC   40(8,R7),DA08DDN         UPDATE THE DDNAME
         MVC   62(2,R7),QCHSBLK         SET THE BLKSIZE
         ST    R7,0(,R5)                STORE DCB ADDR IN OPEN LIST
*---  DETERMINE NUMBER OF TRKS/CYL FOR THIS DEVICE                 ---*
         DEVTYPE  DA08DDN,DVAREA,DEVTAB,RPS  GET DEVICE TYPE INFO
*        MVC   QCTRKCYL+2-QCSPOOLS(2,R5),DVATRK  SAVE TRKS/CYL
         LR    R15,R5                   copy dcb ptr
         S     R15,QCSPOOLS             get offset
         LR    R14,R15                  save for a sec
         A     R15,QCTRKCYL             -> correct entry
         MVC   2(2,R15),DVATRK          copy trks/cyl
         SRL   R14,2                    byte entry
          AIF   (&QLEVEL GE 5).II640
         LR    R15,R14                  copy for a sec
          AGO   .II650
.II640    ANOP ,
         XR    R15,R15                  clear
         IC    R15,DASEXTNO             get extent no
.II650    ANOP ,
         A     R15,QCEXTMAP             -> correct extent desc
         STC   R14,0(,R15)              set correct ext no.
         LA    R7,QCDCBL(,R7)           INCREMENT TO NEXT DCB
          AIF   (&QLEVEL GE 5).II660
II$SPL4  LA    R3,6(,R3)                NEXT VOLUME
          AGO   .II670
.II660    ANOP
II$SPL4  LA    R3,DASSIZ(,R3)           NEXT VOLUME
         DROPX R3                       DASDSECT
.II670    ANOP
         BCT   R4,II$SPL1               BRANCH IF MORE VOLUMES.
         OI    0(R5),X'80'              INDICATE END OF OPEN LIST
         BAL   R14,QAMODE24             change to AMODE 24
         L     R1,QCSPOOLS              -> open list
         OPEN  MF=(E,(1))               OPEN HASPACE
         BAL   R14,QAMODE31             resume AMODE 31
         TM    QISFLAG1,QIS1ISPF        are we in ispf ?
         BZ    QQNSPF1                  if not do terminal stuff
***********************************************************************
*                                                                     *
*        ISPF INITIALIZATION                                          *
*                                                                     *
***********************************************************************
*
**       DEFINE TABLE ROW VARIABLE
*
         L     R4,ISPLNK                -> ISPLINK
         LR    R15,R4                   stupid CALL macro
         CALL  (15),(=CL8'VDEFINE',V8,V8VAR,                           $
               =8CL8'CHAR',VLEN8,=CL8'LIST'),VL,                       $
               MF=(E,II@CALLP)
*
**       DEFINE PANEL HEADER LINE VARIABLE
*
         LR    R15,R4                   stupid CALL macro
         CALL  (15),(=CL8'VDEFINE',=C'(QDHLINE)',QDHLINE,              $
               =CL8'CHAR',=F'80'),VL,                                  $
               MF=(E,II@CALLP)
*
**       DEFINE PANEL ERROR LINE VARIABLE
*
         LR    R15,R4                   stupid CALL macro
         CALL  (15),(=CL8'VDEFINE',=CL8'(QERROR)',QERRMSG,             $
               =CL8'CHAR',=F'64'),VL,                                  $
               MF=(E,II@CALLP)
*
**       DEFINE PANEL CPU PERCENT VARIABLE
*
         LR    R15,R4                   stupid CALL macro
         CALL  (15),(=CL8'VDEFINE',=CL8'(QC)',QCPU,                    $
               =CL8'CHAR',=F'3'),VL,                                   $
               MF=(E,II@CALLP)
*
**       DEFINE PANEL DEMAND PAGING RATE VARIABLE
*
         LR    R15,R4                   stupid CALL macro
         CALL  (15),(=CL8'VDEFINE',=CL8'(QD)',QDPR,                    $
               =CL8'CHAR',=F'3'),VL,                                   $
               MF=(E,II@CALLP)
*
**       DEFINE ROWID VARIABLE
*
         LR    R15,R4                   stupid CALL macro
         CALL  (15),(=CL8'VDEFINE',=CL8'QROWID',QROWID,                $
               =CL8'FIXED',=F'4'),VL,                                  $
               MF=(E,II@CALLP)
*
**       DEFINE PANEL TOP LINE VARIABLE
*
         LR    R15,R4                   stupid CALL macro
         CALL  (15),(=CL8'VDEFINE',=CL8'QTITLE',QDHISFID,              $
               =CL8'CHAR',=F'18'),VL,                                  $
               MF=(E,II@CALLP)
*
**       define flag for LISTDS
*
         LR    R15,R4                   stupid CALL macro
         CALL  (15),(=CL8'VDEFINE',=CL8'QBRIFHDR',QBRIFHDR,            $
               =CL8'CHAR',=F'1'),VL,                                   $
               MF=(E,II@CALLP)
*
**       Set VERB TABLE action to SETVERB (for getting just
**       the parameters).
*
         LR    R15,R4                   stupid CALL macro
         CALL  (15),(=CL8'VREPLACE',=C'(QQACT)',                       $
               =F'8',=CL8'SETVERB'),VL,                                $
               MF=(E,II@CALLP)
*
         B     IISTAX                   go do stax processing
***********************************************************************
*                                                                     *
*   CHECK TERMINAL TYPE                                               *
*                                                                     *
***********************************************************************
QQNSPF1  DS    0H
         GTSIZE  ,
         SPACE 1
         LTR   R3,R0                    TEST NUMBER OF ROWS
         BP    II$TUBE1                 NON-ZERO IMPLIES TUBE
         OI    QTERMFLG,QTFTTY          ZERO ROWS -> TTY
         LA    R3,24                    FAKE NUMBER OF LINES
         CH    R1,=H'80'                TTY LINE LONG ENOUGH?
         BNL   II$SETSZ                 YES - OK
         L     R1,=A(II#MSG7)           -> MSG TEXT
         TPUT  (1),L'II#MSG7            LINE LENGTH MUST BE > 80 ...
         LA    R1,80                    SET LINE LENGTH
         B     II$SETSZ
         SPACE 2
II$TUBE1 CH    R1,=H'80'                MOD 2, 3, OR 4?
         BNE   II$TUBE2                 NO - SEE IF MOD 5
         CH    R3,=H'24'                MOD 2?
         BNH   II$SETSZ                 YES
         CH    R3,=H'43'                TOO MANY LINES FOR MOD 4???
         BH    II$TUBE3                 YES - ASSUME MOD 2
         MVI   QDERASE,X'7E'            MOD 3 OR 4 - USE ...
         MVI   QD3270OP,X'7E'           ... ERASE WRITE ALTERNATE
         B     II$SETSZ
         SPACE 1
II$TUBE2 CH    R1,=H'132'               MOD 5?
         BNE   II$TUBE3                 NO - FORCE MOD 2
         CH    R3,=H'27'                MOD 5?
         BNE   II$TUBE3                 NO - FORCE MOD 2
         NOP   *+8                      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
         OI    QTERMFLG,QTFMOD5         YES - SET FLAG
         SPACE 1
II$TUBE3 LA    R1,80                    SET LINE LENGTH
         LA    R3,24                    SET NUMBER OF LINES
         SPACE 1
II$SETSZ STH   R1,QDCOLS                SAVE SCREEN WIDTH
         STH   R3,QDLINES               SAVE SCREEN LENGTH
         LR    R15,R3                   COPY NUMBER OF SCREEN LINES
         SH    R15,=H'3'                ADJUST FOR FIXED OVERHEAD LINES
         STH   R15,QDROWS
         LR    R14,R15                  COPY NUMBER OF LINES / PAGE
         BCTR  R14,0                    SUBTRACT 1 FOR COLUMN INDICATOR
         CVD   R15,QNUMWORK             CONVERT NUMBER OF LINES / PAGE
         ZAP   QTPAGE,QNUMWORK
         CVD   R14,QNUMWORK             CONVERT NUMBER OF LINES / PAGE
         ZAP   QTPAGEX,QNUMWORK
         SRL   R15,1                    GET NUMBER LINES / HALF PAGE
         CVD   R15,QNUMWORK             CONVERT
         ZAP   QTHALF,QNUMWORK
         SRL   R14,1                    GET HALF PAGE SIZE IF COLS ON
         CVD   R14,QNUMWORK             CONVERT
         ZAP   QTHALFX,QNUMWORK
         LR    R0,R3                    COPY NUMBER OF SCREEN LINES
         LA    R1,12(,R1)               ADJUST LINE LEN FOR ATTR BYTES
         MR    R0,R1                    COMPUTE SCREEN BUFFER SIZE
         LA    R0,50(,R3)               ADJUST FOR 3270 CONTROL HEADER
         ST    R0,QLSCRBUF              SAVE LENGTH OF SCREEN BUFFER
         GETMAIN  RU,LV=(0),SP=1        BUY A SCREEN BUFFER
         ST    R1,QVSCRBUF              SAVE ADDRESS OF GOTTEN STORAGE
***********************************************************************
*                                                                     *
*   TELL VTAM WE'RE HERE                                              *
*                                                                     *
***********************************************************************
         STFSMODE  ON,INITIAL=YES
         SPACE 1
         CH    R15,=H'8'                VTAM TERMINAL?
         BE    *+8                      NO - SKIP
         OI    QTERMFLG,QTFVTAM         YES - SET FLAG
***********************************************************************
*                                                                     *
*   ENABLE ATTN EXIT                                                  *
*                                                                     *
***********************************************************************
IISTAX   DS    0H
         L     R1,II@STAXA              GET ADDRESS OF STAX BLOCK
         STAX  USADDR=(R11),MF=(E,(1))
         SPACE 1
         LTR   R2,R15                   DID IT WORK?
         BZ    IISTAXOK                 YES
         L     R1,=A(II#MSG8)           -> MSG TEXT
         TPUT  (1),L'II#MSG8            'UNABLE TO ESTABLISH STAX EXIT'
         ABEND 93
***********************************************************************
*                                                                     *
*   READ IN THE QUEUE PROFILE COMMANDS                                *
*                                                                     *
***********************************************************************
IISTAXOK LA    R0,II@DCB                -> PROFILE DCB AREA
         ST    R0,II@OPEN               SET UP OPEN LIST
         L     R1,=A(IIBSAM)            -> PATTERN DCB
         MVC   II@DCB(IIBSAML),0(R1)    GET BSAM DCB
         MVI   II@OPEN,X'80'            FLAG END OF LIST
         MVC   II@DECB(II#DECBL),II#DECB  INITIALIZE DECB
         L     R5,QCSTART               INIT COMMAND TABLE ADDR
         SR    R2,R2                    INDICATE NO "SYSPROC" FOUND YET
         L     R1,16                    -> CVT
         L     R1,0(,R1)                -> DISPATCH
         L     R1,4(,R1)                -> MY TCB
         L     R1,12(,R1)               -> MY TIOT
         SR    R0,R0                    CLEAR FOR IC
         LA    R1,24(,R1)               -> DEVICE SECTION
         SPACE 1
IITIOTLP CLC   =F'0',0(R1)              END OF TIOT?
         BE    IIPROF00                 YES
         CLC   4(8,R1),=CL8'SYSPROC'    CLIST LIBRARY?
         BE    IICLIST                  YES
         CLC   4(8,R1),=CL8'QPROF'      MY PROFILE DATASET?
         BE    IIQPROF                  YES
IITIOTNX IC    R0,0(,R1)                GET TIOT ENTRY LENGTH
         AR    R1,R0                    -> NEXT TIOT ENTRY
         B     IITIOTLP                 KEEP LOOKING
         SPACE 1
IICLIST  LR    R2,R1                    SAVE PTR
         B     IITIOTNX                 KEEP LOOKING FOR QPROF
         SPACE 1
IIQPROF  BAL   R14,QAMODE24             change to AMODE 24
         OPEN  MF=(E,II@OPEN)           OPEN IT
         BAL   R14,QAMODE31             resume AMODE 31
         TM    II@DCB+48,X'10'          DID IT OPEN?
         BNO   IIPARSE1                 NO - SKIP ALL, NO ERROR MSG
         B     IIPROFCK                 START READING
         SPACE 1
IIPROF00 LTR   R2,R2                    WAS SYSPROC FOUND?
         BZ    IIPARSE1                 NO - NO PROFILE EXISTS
         MVC   II@DCB+DCBDDNAM-IHADCB(8),=CL8'SYSPROC'
         MVI   II@DCB+DCBDSORG-IHADCB,DCBDSGPO   INDICATE PDS
         BAL   R14,QAMODE24             change to AMODE 24
         OPEN  MF=(E,II@OPEN)           OPEN IT
         BAL   R14,QAMODE31             resume AMODE 31
         TM    II@DCB+DCBOFLGS-IHADCB,DCBOFOPN  DID IT OPEN?
         BNO   IIPARSE1                 NO - SKIP ALL, NO ERROR MSG
         SPACE 1
         FIND  II@DCB,=CL8'QPROF',D     FIND MY MEMBER THERE
         LTR   R15,R15                  IS THERE ONE?
         BZ    IIPROFCK                 YES - GO READ PROFILE COMMANDS
IICLOSE  BAL   R14,QAMODE24             change to AMODE 24
         CLOSE MF=(E,II@OPEN)           CLOSE THE DCB
         BAL   R14,QAMODE31             resume AMODE 31
         B     IIPARSE1                 AND SKIP ALL THIS, NO ERROR MSG
         SPACE 2
***********************************************************************
*                                                                     *
*   READ THE PROFILE COMMANDS INTO MAIN STORAGE                       *
*                                                                     *
***********************************************************************
IIPROFCK TM    II@DCB+DCBRECFM-IHADCB,DCBRECU  RECFM U?
         BO    IICLOSE                  YES, TREAT AS INVALID
         BZ    IICLOSE                  NO, RECFM? EVEN STRANGER
         CLC   =H'255',II@DCB+DCBLRECL-IHADCB   LRECL OVER MAX?
         BL    IICLOSE                  YES, IGNORE IT
         LH    R6,II@DCB+DCBBLKSI-IHADCB  GET LEN OF BUFFER
         LA    R6,7(,R6)                +7
         SRL   R6,3                     /8
         SLL   R6,3                     *8 ROUNDED UP TO DWD
         AR    R6,R5                    -> START OF INT BUFFER
         ST    R6,II@CMNDS              SAVE START OF COMMANDS
         SPACE 1
IIPROFLP BAL   R14,QAMODE24             change to AMODE 24
         SPACE 1
         READ  II@DECB,SF,II@DCB,(R5),MF=E  READ A PROFILE BLOCK
         SPACE 1
         CHECK II@DECB                  WAIT FOR IT
         SPACE 1
         BAL   R14,QAMODE31             resume AMODE 31
         L     R1,II@DECB+16            -> IOB
         LH    R15,II@DCB+DCBBLKSI-IHADCB  GET BLKSIZE
         SH    R15,14(,R1)              MINUS RESIDUAL COUNT (IOBCSW+6)
         AR    R15,R5                   -> END OF BUFFER
         LR    R14,R5                   -> START OF BLOCK
         TM    II@DCB+DCBRECFM-IHADCB,DCBRECF  RECFM F?
         BZ    IIPROFV                  NO, GOTTA DO MORE WORK
IIPROFFP LH    R1,II@DCB+DCBLRECL-IHADCB  GET RECORD LEN
         BCTR  R1,0                     LEN TO MOVE -1
         STH   R1,0(,R6)                SAVE IN BUFFER
         EX    R1,IIPRFMVC              << MVC  2(*-*,R6),0(R14) >>
         LA    R14,1(R1,R14)            -> NEXT POS IN INPUT BUFFER
         LA    R6,3(R1,R6)              -> NEXT POS IN OUTPUT BUFF
         CR    R14,R15                  PAST END YET?
         BL    IIPROFFP                 NO, GET NEXT RECORD
         B     IIPROFLP                 READ NEXT BLOCK
         SPACE 2
IIPROFV  LA    R14,4(,R14)              -> BDW
IIPRFVP  LH    R1,0(,R14)               GET RDW LEN
         SH    R1,=H'5'                 LEN OF DATA-1 FOR EX
IIPRFV0  CLI   4(R14),C'0'              NUMERIC?
         BL    IIPRFVM                  NO, TREAT AS NORMAL
         LA    R14,1(,R14)              -> NEXT CHAR
         BCT   R1,IIPRFV0               AND TRY THE NEXT ONE
         B     IIPRFVP                  WHAT NONE LEFT? TRY NEXT
         SPACE 1
IIPRFVM  EX    R1,IIPRFMVV              << MVC 2(*-*,R6),4(R14) >>
         STH   R1,0(,R6)                SAVE IN BUFFER
         LA    R14,5(R1,R14)            -> NEXT INPUT RECORD
         LA    R6,3(R1,R6)              -> NEXT OUTPUT POS
         CR    R14,R15                  PAST END YET?
         BL    IIPRFVP                  NO, GET NEXT RECORD
         B     IIPROFLP                 READ NEXT BLOCK
         SPACE 2
*IIPEOF  BAL   R14,QAMODE24             change to AMODE 24
*---  Don't need to switch modes since the READ was done in AMODE 24
IIPEOF   CLOSE MF=(E,II@OPEN)           CLOSE PROFILE DCB
         BAL   R14,QAMODE31             resume AMODE 31
         XC    0(2,R6),0(R6)            ZERO LEN RECORD IS END
         L     R6,II@CMNDS              -> FIRST PROFILE SUBCOMMAND
         L     R2,QVSAVE                -> DISPLAY'S SAVE AREA
***********************************************************************
*                                                                     *
*   EXECUTE THE PROFILE COMMANDS.                                     *
*   NOTE THAT EXECUTION OF A NON-IMMEDIATE TYPE SUBCOMMAND WILL       *
*   TERMINATE THE PROFILE SEQUENCE.  ALSO, OTHER TURKEY THINGS LIKE   *
*   A "*" SUBCOMMAND WILL WREAK HAVOC.  LET THE BUYER BEWARE.         *
*                                                                     *
***********************************************************************
IIPROFL2 LH    R1,0(,R6)                GET LEN OF COMMAND
         LTR   R1,R1                    ANY LEFT?
         BZ    IIPEND                   NO, END IT ALL HERE
         CLI   2(R6),C'*'               COMMENT?
         BE    IIPNEXT                  YES - SKIP IT
         CLC   =C'/*',2(R6)             NEW STYLE COMMENT?
         BE    IIPNEXT                  YES - SKIP IT
         CLC   =C'/*',3(R6)             NEW STYLE COMMENT IN NEXT COL?
         BE    IIPNEXT                  YES - SKIP IT
         MVC   0(QSAVE1L,R2),QSAVE1     MOVE FIRST PART
         MVC   QSAVE1L(QSAVE2L,R2),QSAVE2    SECOND PART
         MVC   QDREPLY,QBLANK           CLEAR INPUT AREA
         CH    R1,=Y(QDREPLYL)          OVER MAX
         BL    IIPROF2M                 NO, MOVE THE COMMAND
         LH    R1,=Y(QDREPLYL)          MAX LEN OF COMMAND
         BCTR  R1,0                     -1 FOR EX
IIPROF2M EX    R1,II$MVC2               << MVC QDREPLY(0),2(R6) >>
         MVC   QDRLNG,=Y(QDREPLYL)      FAKE THE LENGTH
         QCALL PARSE                    PARSE THE INPUT
         TM    QFLAG1,Q1IMMED           IMMEDIATE COMMAND?
         BNO   QSTOP                    NO - GO TO MAINLINE
         L     R15,QSUBCMD              GET SUBCOMMAND EPA
         QCALL (R15)                    INVOKE IMMEDIATE SUBCOMMAND
         TM    QFLAG1,Q1IMMED           DID SUBCMD RESET "IMMEDIATE"?
         BNO   QSTOP                    YES - LET MAINLINE RE-INVOKE IT
         MVC   QSAVE1(QSAVE1L),0(R2)    RESTORE FIRST PART
         MVC   QSAVE2(QSAVE2L),QSAVE1L(R2)      SECOND PART
IIPNEXT  LH    R1,0(,R6)                -> LEN OF LAST PROF CMND
         LA    R6,3(R1,R6)              -> NEXT COMMAND
         OC    0(2,R6),0(R6)            ANY THERE?
         BNZ   IIPROFL2                 YES - CONTINUE
IIPEND   OI    QFLAG1,Q1PROFOK          PROFILE COMPLETE
***********************************************************************
*                                                                     *
*   PARSE THE INITIAL COMMAND                                         *
*                                                                     *
***********************************************************************
IIPARSE1 L     R2,QVSAVE                -> DISPLAY'S SAVE AREA
         MVC   0(QSAVE1L,R2),QSAVE1     MOVE FIRST PART
         MVC   QSAVE1L(QSAVE2L,R2),QSAVE2    SECOND PART
         MVC   QDPROMPT,QDREPLY         SET WHAT TO REPROMPT IF ERROR
         QCALL PARSE                    PARSE THE INPUT
         TM    QFLAG1,Q1IMMED           IMMEDIATE COMMAND?
         BNO   QSTOP                    NO - GO TO MAINLINE
         L     R15,QSUBCMD              GET SUBCOMMAND EPA
         CL    R15,=V(RECALL)           RECALL REQUEST?
         BE    II$JUNK                  YES - HE CAN'T DO THAT HERE
         QCALL (R15)                    INVOKE IMMEDIATE SUBCOMMAND
         TM    QFLAG1,Q1IMMED           DID SUBCMD RESET "IMMEDIATE"?
         BNO   QSTOP                    YES - LET MAINLINE RE-INVOKE IT
II$JUNK  MVC   QSAVE1(QSAVE1L),0(R2)    RESTORE FIRST PART
         MVC   QSAVE2(QSAVE2L),QSAVE1L(R2)      SECOND PART
         MVC   QDPROMPT,QDREPLY         SET WHAT TO REPROMPT IF ERROR
         B     QSTOP                    GO HOME
***********************************************************************
*                                                                     *
*   PROCESS REQUEST FOR DIFFERENT VOLSER ON SYS1.HASPCKPT             *
*                                                                     *
***********************************************************************
*
*** FORMAT - QUEUE CKPT(VOLSER)
*
*  R1 -> 'CKPT('
*  R3 -> LENGTH-1 OF WHOLE OPERAND
*
II$CKPT  MVC   QCKPTVOL,QBLANK          BLANK VOLSER FIELD
         LA    R15,QCKPTVOL             START OF VOLSER FIELD
         LA    R6,5(,R15)               -> END OF VOLSER FIELD
         SH    R3,=H'4'                 SUBTRACT OVERHEAD FROM LENGTH
         LA    R1,5(,R1)                -> FIRST OPERAND CHAR
II$CKP1  CLI   0(R1),C')'               IS THIS THE END OF SER FIELD?
         BE    II$CKPT2                 YES. PROCESS VOLSER NEXT.
         CR    R15,R6                   DID WE GO TOO FAR?
         BH    IIABORT2                 YES - GET OUT
         MVC   0(1,R15),0(R1)           MOVE ONE BYTE OF UNIT NAME
         LA    R15,1(,R15)              ADD 1 TO RECEIVING ADDR
         LA    R1,1(,R1)                ADD 1 TO SENDING ADDR
         BCT   R3,II$CKP1               BRANCH IF NOT EXHAUSTED.
         B     IIABORT2                 INVALID PARAMETERS.
II$CKPT2 CLI   QCKPTVOL,C' '            IS THERE A VOLSER?
         BE    IIABORT2                 NO - ERROR
         OI    II@FLAGS,II@CKPT         yes - remember it was specified
II$CKPT3 BCT   R3,*+8                   -1 FOR ')'
         B     II$SKPRM                 RESUME MAINLINE IF NO MORE PARM
         LA    R1,1(,R1)                -> NEXT PARM CHAR
         CLI   0(R1),C' '               FIND A NON-BLANK?
         BE    II$CKPT3                 YES - KEEP LOOKING
         BCT   R3,*+8                   -1 FROM COUNT
         B     II$SKPRM                 INPUT EXHAUSTED
         CH    R3,=H'5'                 ENOUGH LEFT TO BE INTERESTING?
         BL    II$SKPRM                 NO
**%%     BCTR  R3,0                     -1 FOR FINAL BLANK
         B     II$CKPRM                 YES - PROCESS
IIABORT2 L     R1,=A(II#MSG2)           -> MSG TEXT
         TPUT  (1),L'II#MSG2            TELL THE USER
         ABEND 97,DUMP                  QUIT
***********************************************************************
*                                                                     *
*   PROCESS REQUEST FOR DIFFERENT DSNAME PREFIX                       *
*                                                                     *
***********************************************************************
*
*** FORMAT - QUEUE DSN(PREFIX)
*
*  R1 -> 'DSN('
*  R3 -> LENGTH-1 OF WHOLE OPERAND
*
II$DSN   LA    R15,QCKPTPFX             -> START OF PREFIX FIELD
         LA    R6,44-1(,R15)            -> PREFIX IS MAX 44 CHARS
         SH    R3,=H'3'                 SUBTRACT OVERHEAD FROM LENGTH
         LA    R1,4(,R1)                -> FIRST OPERAND CHAR
II$DSN1  CLI   0(R1),C')'               IS THIS THE END OF THE PREFIX?
         BE    II$DSN2                  YES. MOVE IN REST OF DSNAME
         CR    R15,R6                   DID WE GO TOO FAR?
         BH    IIABORT3                 YES - GET OUT
         MVC   0(1,R15),0(R1)           MOVE ONE BYTE OF DSNAME
         LA    R15,1(,R15)              ADD 1 TO RECEIVING ADDR
         LA    R1,1(,R1)                ADD 1 TO SENDING ADDR
         BCT   R3,II$DSN1               BRANCH IF NOT EXHAUSTED.
         B     IIABORT3                 INVALID PARAMETERS.
II$DSN2  CLI   QCKPTPFX,C' '            IS THERE A PREFIX?
         BE    IIABORT3                 NO - ERROR
         OI    II@FLAGS,II@DSN          yes - remember it was specified
II$DSN3  BCT   R3,*+8                   -1 FOR ')'
         B     II$SKPRM                 RESUME MAINLINE IF NO MORE PARM
         LA    R1,1(,R1)                -> NEXT PARM CHAR
         CLI   0(R1),C' '               FIND A NON-BLANK?
         BE    II$DSN3                  YES - KEEP LOOKING
         CH    R3,=H'5'                 ENOUGH LEFT TO BE INTERESTING?
         BL    II$SKPRM                 NO
         BCTR  R3,0                     -1 FOR FINAL BLANK
         B     II$CKPRM                 YES - PROCESS
IIABORT3 L     R1,=A(II#MSG3)           -> MSG TEXT
         TPUT  (1),L'II#MSG3            TELL THE USER
         ABEND 96,DUMP                  QUIT
***********************************************************************
*                                                                     *
*   SET FLAG FOR ISPF DIALOG MANGLER                                  *
*                                                                     *
***********************************************************************
*
*  R1 -> 'ISPF'
*  R3 -> LENGTH-1 OF WHOLE OPERAND
*
II$ISPF  OI    II@FLAGS,II@ISPF         REMEMBER FOR LATER
         LA    R1,5(,R1)                -> PAST 'ISPF '
         SH    R3,=H'5'                 ADJUST REMAINING LENGTH
         BP    II$CKPRM                 GO FIND NEXT PARM ITEM
         B     II$SKPRM                 NONE LEFT - CONTINUE INIT
***********************************************************************
*                                                                     *
*   PROCESS REQUEST FOR NON-DEFAULT JES2 SUBSYSTEM                    *
*                                                                     *
***********************************************************************
*
*** FORMAT - QUEUE JES(NAME)
*
*  R1 -> 'JES('
*  R3 -> LENGTH-1 OF WHOLE OPERAND
*
II$JESN  MVC   QJESNAME(4),QBLANK       BLANK SUBSYSTEM NAME FIELD
         LA    R15,QJESNAME             -> START OF OUTPUT AREA
         LA    R6,4-1(,R15)             -> SUBSYS NAME IS MAX 4 CHARS
         SH    R3,=H'3'                 SUBTRACT OVERHEAD FROM LENGTH
         LA    R1,4(,R1)                -> FIRST OPERAND CHAR
II$JES1  CLI   0(R1),C')'               IS THIS THE END OF THE NAME?
         BE    II$JES2                  YES. DONE
         CR    R15,R6                   DID WE GO TOO FAR?
         BH    IIABORT4                 YES - GET OUT
         MVC   0(1,R15),0(R1)           MOVE ONE BYTE OF SUBSYS NAME
         LA    R15,1(,R15)              ADD 1 TO RECEIVING ADDR
         LA    R1,1(,R1)                ADD 1 TO SENDING ADDR
         BCT   R3,II$JES1               BRANCH IF NOT EXHAUSTED.
         B     IIABORT4                 INVALID PARAMETERS.
II$JES2  CLI   QJESNAME,C' '            IS THERE A NAME?
         BE    IIABORT4                 NO - ERROR
         OI    II@FLAGS,II@JESNM        yes - remember it was specified
II$JES3  BCT   R3,*+8                   -1 FOR ')'
         B     II$SKPRM                 RESUME MAINLINE IF NO MORE PARM
         LA    R1,1(,R1)                -> NEXT PARM CHAR
         CLI   0(R1),C' '               FIND A NON-BLANK?
         BE    II$JES3                  YES - KEEP LOOKING
         CH    R3,=H'5'                 ENOUGH LEFT TO BE INTERESTING?
         BL    II$SKPRM                 NO
         BCTR  R3,0                     -1 FOR FINAL BLANK
         B     II$CKPRM                 YES - PROCESS
IIABORT4 L     R1,=A(II#MSG4)           -> MSG TEXT
         TPUT  (1),L'II#MSG4            TELL THE USER
         ABEND 94,DUMP                  QUIT
***********************************************************************
*                                                                     *
*   UNSUPPORTED DEVICE TYPE. ABORT.                                   *
*                                                                     *
***********************************************************************
IIABORT  L     R1,=A(II#MSG1)           -> MSG TEXT
         TPUT  (1),L'II#MSG1            TELL THE USER
         ABEND 98,DUMP                  QUIT.
***********************************************************************
*                                                                     *
*   COULDN'T GET STORAGE FOR BLOCK ADDR TABLE                         *
*                                                                     *
***********************************************************************
II$SMALL L     R1,=A(II#MSG5)           -> MSG TEXT
         TPUT  (1),L'II#MSG5            TELL THE USER
         ABEND 95                       QUIT.
          AIF   (&QLEVEL LT 4).II690
          AIF   (&QLEVEL LT 8).II680
         EJECT ,
***********************************************************************
*                                                                     *
*  II$CK$PI - Check ckpt pool id for '**xxx  POOL**'                  *
*                                                                     *
* ENTRY: R15 -> CL4'id'                                               *
*        R1  -> checkpoint area to examine                            *
*        R14 - RETURN ADDRESS                                         *
*                                                                     *
***********************************************************************
         USING HDP,R1                   Control block Pool Header
II$CK$PI CLC   HDPID+0(2),=C'**'        first part correct?
         BNE   II$CK$P2                 nope
         CLC   HDPID+2(4),0(R15)        name part correct?
         BNE   II$CK$P2                 nope
         CLC   HDPID+6(7),=C' POOL**'   last part correct?
         BNE   II$CK$P2                 nope
         LA    R0,HDPLNGTH(,R1)         add buffer prefix
         ICM   R15,B'1111',HDPSIZE      size of area
         AR    R1,R15                   bump
         BR    R14                      return to mainline
         DROP  R1                       HDP
         SPACE 1
II$CK$P2 MVC   QDMSG(L'II#MSG11),II#MSG11  'Unable to locate xxxx pool'
         MVC   QDMSG+17(4),0(R15)       fill in pool id
         LA    R1,QDMSG                 -> address
         LA    R0,L'II#MSG11            length
         TPUT  (1),(0),R
         ABEND 89,DUMP
          AGO   .II700
.II680    ANOP
         EJECT ,
***********************************************************************
*                                                                     *
*  II$KITFD - FIND SELECTED KIT                                       *
*                                                                     *
* ENTRY: R0  - CHAR ID STRING (CL4 IN REG)                            *
*        R14 - RETURN ADDRESS                                         *
*                                                                     *
* EXIT:  R1  -> KIT (IF RETURN 4(,R14); ELSE NOT FOUND)               *
*                                                                     *
***********************************************************************
         SPACE 1
II$KITFD L     R1,II@KITF               -> FIRST KIT
         USNGX KITDSECT,R1
II$KITFL CL    R0,KITID
         BE    4(,R14)                  RETURN IF SELECTED KIT FOUND
         LA    R1,KITLNGTH(,R1)         -> NEXT KIT IF ANY
         C     R1,II@KITL               -> LAST KIT
         BNH   II$KITFL                 LOOP IF WAS NOT LAST KIT
         BR    R14                      RETURN IF KIT NOT FOUND
         DROPX R1                       KITDSECT
         SPACE 3
***********************************************************************
*                                                                     *
*  II$CKTTR - COMPUTE CKPT TTR OF GROUP OF BLOCKS FROM KITORG         *
*                                                                     *
* ENTRY: R1  - @ KITDSECT                                             *
*        R14 - RETURN ADDRESS                                         *
*                                                                     *
* EXIT:  R1  - TTR0 OF THIS GROUP ON CKPT                             *
*                                                                     *
***********************************************************************
         SPACE 1
         USNGX KITDSECT,R1
II$CKTTR L     R1,KITORG                GET ORI IN BYTES OF THIS GROUP
         DROPX R1
         SRL   R1,12                    ORG TO # OF BLOCKS
         SR    R0,R0
         D     R0,II@CKRT               / # 4K BLOCKS/TRK ON CKPT DEV
         SLL   R1,8                     POSITION TT IN R1
         OR    R1,R0                    BUILD TTR IN R1
         AL    R1,=X'00000101'          SKIP 1ST TRK/RECORD ORIGIN 1
         SLL   R1,8                     NOW TTR0
         BR    R14
.II690    ANOP
.II700    ANOP
         SPACE 3
         PUSH  USING
         DROP  ,
         SPACE 1
         USING *,R15
         USING IHADCB,R1
II#NCPEX CLI   DCBNCP,0                 NCP SPECIFIED?
         BNER  R14                      YES - USE IT
         MVI   DCBNCP,&QCHKNCP          NO - USE GENNED DEFAULT VALUE
         BR    R14                      RETURN TO OPEN
         SPACE 1
         POP   USING
         SPACE 3
         EJECT
***********************************************************************
*                                                                     *
*   MISCELLANY                                                        *
*                                                                     *
***********************************************************************
         LTORG ,
         SPACE 1
II$CMDOC OC    0(*-*,R1),QBLANK         TRANSLATE COMMAND TO UPPER CASE
II$MVC1  MVC   QDREPLY(*-*),0(R1)       MOVE DATA TO REPLY
II$MVC2  MVC   QDREPLY(*-*),2(R6)       MOVE DATA TO REPLY
IIPRFMVC MVC   2(*-*,R6),0(R14)         MOVE RECFM F DATA
IIPRFMVV MVC   2(*-*,R6),4(R14)         MOVE RECFM V DATA
         SPACE 2
*---  TABLE OF ADCONS IN QCOMMON TO BE RELOCATED IN GETMAINED AREA
II#RELOC DC    Y(QVSYSID-QCOMMON,QSYSID-QCOMMON)
         DC    Y(QVPFKEYS-QCOMMON,QPFKAREA-QCOMMON)
         DC    Y(QVTFD-QCOMMON,TFD-QCOMMON)
         DC    Y(QVSAVE-QCOMMON,QDSAVE-QCOMMON)
         DC    Y(QVLCBUF-QCOMMON,QDLCBUF-QCOMMON)
         DC    Y(QVSTACK-QCOMMON,QDSTACK-QCOMMON)
         DC    Y(QVSTACKC-QCOMMON,QDSTACK-QCOMMON)
         DC    Y(DAPLECB-QCOMMON,DAIRECB-QCOMMON)
         DC    Y(HDECB2+24-QCOMMON,QCDAD-QCOMMON)
         DC    Y(QCCKPT-QCOMMON,HASPCKPT-QCOMMON)
         DC    Y(HDECB1+8-QCOMMON,HASPCKPT-QCOMMON)
         DC    Y(QCSAVE-QCOMMON,HASPSAVE-QCOMMON)
         DC    Y(QPPRNT-QCOMMON,HASPPRNT-QCOMMON)
         DC    Y(QCDECB1-QCOMMON,HDECB1-QCOMMON)
         DC    Y(QCDECB2-QCOMMON,HDECB2-QCOMMON)
         DC    Y(QHDCBA-QCOMMON,HELPDCB-QCOMMON)
         DC    Y(QHDECBA-QCOMMON,HELPDECB-QCOMMON)
         DC    Y(QVPRNTWA-QCOMMON,QPRNTWA-QCOMMON)
         DC    Y(QVRING-QCOMMON,QCMDRING-QCOMMON)
         DC    X'FF'                    END OF TABLE INDICATOR
         SPACE 2
         ENTRY SMFTABLE                 SO I CAN FIND IT WITH "ZAP"
SMFTABLE DC    0D'0'
*  CL4'SMFID',CL4'ID_TO_DISPLAY'
&QI      SETA  0
.IILOOP1  AIF   (&QI GE &QSIDNUM).IIEND1  EXIT IF DONE
&QI      SETA  &QI+1                    BUMP SUBSCRIPT
         DC    CL8'&QSIDTBL(&QI)'
         SPACE 1
          AGO   .IILOOP1                LOOP
.IIEND1  DC    X'FF'                    END OF TABLE INDICATOR
         SPACE 2
         ENTRY SYSTABLE                 SO I CAN FIND IT WITH "ZAP"
SYSTABLE DC    0D'0'
*  CL6'SYSRES',CL4'JESN',CL6'CHKPTV',CL8'PREFIX'
&QI      SETA  0
.IILOOP2  ANOP
&QI      SETA  &QI+1                    BUMP SUBSCRIPT
         DC    CL60'&QSYSTBL(&QI)'
          AIF   (&QI NE 1).STNOT1       skip if not first table entry
SYSTBLL  EQU   *-SYSTABLE               length of an entry
.STNOT1   ANOP
         SPACE 1
          AIF   (&QI LT &QSYSNUM).IILOOP2  LOOP IF MORE
         DC    X'FF'                    END OF TABLE INDICATOR
         SPACE 3
II#OPENO OPEN  (0,OUTPUT),MF=L
         SPACE 1
II#OPENI OPEN  (0),MF=L
         SPACE 1
II#EXLST DC    X'85',AL3(II#NCPEX)      -> DCB EXIT TO SET NCP
         SPACE 1
         READ  II#DECB,SF,MF=L
         SPACE 1
II#DECBL EQU   *-II#DECB
         SPACE 3
         DROPX R13                      WORK
         SPACE 2
II#CKSFX DC    C'&QSFXCK'               '.HASPCKPT'
II#HSSFX DC    C'&QSFXHS'               '.HASPACE'
         SPACE 2
*                                                        ABEND CODES:
II#MSG1  DC    C'UNSUPPORTED DEVICE TYPE SPECIFIED FOR SPOOL'  98
II#MSG2  DC    C'INVALID PARAMETER SPECIFIED - CKPT(VOLSER)'   97
II#MSG3  DC    C'INVALID PARAMETER SPECIFIED - DSN(PREF)'      96
II#MSG4  DC    C'INVALID PARAMETER SPECIFIED - JES(NAME)'      94
II#MSG5  DC    C'UNABLE TO OBTAIN 64K OF STORAGE FOR BLOCK ADDR TABLE'
*                                                              95
II#MSG7  DC    C'LINE LENGTH MUST BE AT LEAST 80, WILL USE 80' --
II#MSG8  DC    C'*** UNABLE TO ESTABLISH STAX EXIT ***'        93
II#MSG9  DC    C'*** WRONG VERSION OF QUEUE COMMAND FOR THIS CHKPT ($HA$
               SPID = ''JES2'') ***'                          91
II#MSG10 DC    C'Sort routine (OACFSORT) load failure'         90
II#MSG11 DC    C'Unable to locate xxxx pool'                   89
         SPACE 6
HASPACE  DCB   DDNAME=HASPACE1,DSORG=DA,MACRF=(RIC),OPTCD=A,RECFM=F
         SPACE 2
QCDCBL   EQU   *-HASPACE                LENGTH OF HASPACE DCB
         SPACE 3
IIBSAM   DCB   DDNAME=QPROF,DSORG=PS,MACRF=(RP),EODAD=IIPEOF
         SPACE 2
IIBSAML  EQU   *-IIBSAM
         SPACE 6
WORK     DSECT
         ORG   WORK+72                  PAST MY SAVE AREA
II@STAXA DS    A                        ADDRESS OF STAX BLOCK
II@VLEN  DS    F                        length of area for VCOPY
II@CPPL  DS    4A                       PHONY CPPL
II@FLAGS DS    X                        MISC FLAG FOR INITIAL
II@FCALL  EQU   X'80'                    ENVIRONMENT IS CALL
II@ISPF   EQU   X'40'                    PARM=ISPF WAS SPECIFIED
II@JESNM  EQU   X'20'                    JES() was specified
II@CKPT   EQU   X'10'                    CKPT() was specified
II@DSN    EQU   X'08'                    DSN() was specified
          AIF   (&QLEVEL LT 4).IINOKIT
II@CKRT  DS    F                        4K BLOCKS/TRK ON CKPT DEVICE
II@KITF  DS    A                        -> FIRST KIT AT INIT TIME
II@KITL  DS    A                        -> LAST  KIT AT INIT TIME
.IINOKIT  ANOP
II@CMNDS DS    A                        -> START OF COMMANDS
II@OPEN  DS    A(II@DCB)                OPEN MF=L FOR PROFILE DCB
II@TTRZ  DS    XL4                      TTRZ
II@BLDL  DS    Y(1,12)
II@BLDLN DS    CL8'ISPLINK'             MEMBER TO READ
II@BLDLT DS    XL3,X                    TTR,Z OF MEMBER FOUND
         READ  II@DECB,SF,MF=L          PROFILE DECB
         SPACE 2
         DS    0F                       STUPID MACRO...
*  (THE DEBUGGING HANDBOOK DOCUMENTS THE FOLLOWING UNDER 'DVCT'!!!)
         IHADVA  DSECT=NO               MAP DEVTYPE OUTPUT
         SPACE 3
II@DCB   DS    XL100                    SPACE FOR PROFILE DCB
         ORG   II@DCB
II@TRKCA TRKCALC  MF=L
         SPACE 1
II@TRKCL EQU   *-II@TRKCA
         ORG   II@DCB+L'II@DCB          past end of dcb
II@WORKL EQU   *-WORK                   len of initial workarea
II@REGS  DS    (R11-R2+1)F              when calling LPA search
II@CALLP DS    6A                       CALL MF=L area
         SPACE 3
         QCOMMON
         QDCB
         SPACE 3
         Q$DAS
         Q$MIT
         Q$XECB
         Q$HDP
         Q$JOE
         Q$JOT
         Q$QSE
         Q$KAC
         Q$KIT
         Q$LCK
         Q$HCT
         Q$PDDB
         Q$IOT
         Q$TGM
         Q$JQE
         Q$SVT
         Q$HCCT
         QZCPPL
         QZPSA ,
         QZTCB ,
         QZCVT
         QZJESCT
         QZPSCB
         QZSSCT
         QZSSIB
         QZUCB
         QZIHAETD ,
