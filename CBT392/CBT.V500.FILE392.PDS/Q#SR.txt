         TITLE '--- QUEUE--SEARCH -- JQE AND JOE SEARCH AND FORMAT ---'
*---------------------------------------------------------------------*
*                                                                     *
*   SEARCH - Search for desired subset of JQE's and JOE's             *
*                                                                     *
*   Updates:                                                          *
*      20Dec91  LDW  Integrate GLA fixes below:                       *
*     (11Aug91) GLA  SP410 uses JOEUSER instead of JOEWTRID for       *
*                       userid of DEST (ie. XMIT command).            *
*      29Jun91  LDW  Fix for SP410 held output                        *
*      24May91  LDW/EMS  SP410 fixes                                  *
*      28Jan91  EMS  Update for SP410 (merged by LDW on 31Jan91)      *
*      30Jan91  LDW  Retrofit GLA fixes below:                        *
*     (15Jan91) GLA  Add support for new option to display OUTGRP     *
*     (22Jun90) GLA  Add "NJ" command to display NJE queues           *
*     (10Aug89) GLA  Search for both alias and true RJE id            *
*     (12Jul89) GLA  Fix bug in DO display, length of dest not set    *
*     (24Mar89) GLA  Expand DA to show all active jobs (inc output)   *
*      23May90  LDW  Add USER (U) operand to most status commands     *
*      25Dec89  LDW  Q$xxx -> QZxxx:  ACFJCB, ACFNJB, ACVALD, SSCT    *
*      23Nov89  LDW  Remove conditional assembly around Qxxx macros   *
*      09Jul89  LDW  Add PERCENT option for spool util of each job    *
*      22Mar89  EMS  Update for SP311                                 *
*      31Dec87  LDW  Re-install 19Aug87 update:                       *
*                    Upper case the jobname before compare            *
*      25Sep87  EMS  Allow wild char in dest parm '*'                 *
*      08Apr87  LDW  Display only all output with wtrid if DO W=ALL   *
*      25Jan87  LDW  Pass READSPC the JQE addr in case of CB ID error *
*      16Jan87  LDW  Fix bug in STTEST wtrname check                  *
*      12Jan87  LDW  SP1.3.6 updates                                  *
*                    Remove "LC" macro usage                          *
*      18OCT86  LDW  SUPPORT "DO W=XXX"                               *
*                    HAVE "STATUS" ALSO CHECK FOR MATCH ON WTRID      *
*      05OCT86  LDW  ADD 'WTRNAME'('W') KEYWORD TO "DO"/"AO"          *
*      17SEP86  LDW  FIX SO 'DI *' CORRECTLY DISPLAYS "I *"           *
*      08AUG86  EMS  FIX FOR ACF2 RELEASE PRE 4.1                     *
*      22JUN86  LDW  FIX BUGS IN "DO" DISPLAY                         *
*                    USE &@@ACF2 INSTEAD OF &QACF2                    *
*                    UPDATE FOR ACF2 RELEASE 4.1                      *
*      04/07/86 LDW  USE NEW COMMON LOGIC ERROR ROUTINE               *
*      03/31/86 LDW  RE-DESIGN 3278-5 SUPPORT (THIRD TRY!)            *
*      02/21/86 LDW  FIX JOE OUTPUT PRIORITY SELECTION FOR SP133      *
*      11/14/85 LDW  FIX KEYWORD OPERAND ANALYSIS FOR DN,DH,DA,DS,DT  *
*      12/05/84 LDW  ADD SYSAFF= (S=) SUPPORT TO DI/AI/HI ('S' ALIAS  *
*                       OF 'SPACE' DELETED)                           *
*                    SET QSC2DI FLAG FOR 'FORMAT'                     *
*                    COMBINE DI/AI/HI ROUTINES INTO ONE ROUTINE       *
*      06/25/84 LDW  DISPLAY 4 DIGITS IN ALL 'DQ' FIELDS              *
*      04/17/84 LDW  CHECK FOR DEFAULT DEST BEING IN THE LOCAL        *
*                       EQUIVALENCY TABLE, USE BLANKS IF SO           *
*      04/11/84 LDW  JCTDSECT -> JCTSTART                             *
*      04/10/84 LDW  SP133 UPDATES                                    *
*      03/27/84 LDW  CHANGE ACF2 SUPPORT OF JES2 SP13 TO ACF2 R314    *
*      01/19/84 LDW  ADD SUPPORT FOR COMMAND STACKING                 *
*                    ADD SECOND BASE REG (SAY WHAT?)                  *
*      01/01/84 LDW  ADD SUPPORT FOR &QJQEOWN FIELD                   *
*      12/20/83 LDW  ADD SUPPORT FOR 'SPACE' KEYWORD                  *
*      10/25/83 LDW  FIX ADDRESSIBILITY ERROR FOR NON-SP              *
*      07/19/83 LDW  ADD SUPPORT FOR &QLCLEQ TABLE                    *
*                    CHANGE USING/DROP TO USNGX/DROPX                 *
*      03/04/83 LDW  ADD 'ALL' AND 'TIME' OPERANDS TO "STATUS"        *
*      03/02/83 LDW  CHANGE 'QTILT *' TO USE QERRMSG                  *
*      02/08/83 LDW  ELIMINATE "DHX" - NOW HANDLED BY "DH /ALL"       *
*                    HAVE "XJ" SET QSC2DJX                            *
*      02/02/83 LDW  FIX BUG IN HANDLING LIST OF REMOTE OUTPUT QUEUES *
*      01/27/83 LDW  CORRECT QUEUE AND JOBNUMBER HANDLING FOR SP      *
*                       (SET QCLSNAME TO DISPLAYABLE CLASS NAME)      *
*      01/10/83 LDW  ADD SUMMARY (GRAND TOTAL) LINES IN "DQ"          *
*                    FIX BUGS IN PREVIOUS UPDATE (RESTORE USE OF      *
*                       "QCOUNT")                                     *
*                    CHANGE SOME DATA TO LOWER CASE                   *
*                    MISC OTHER CLEANUP                               *
*      01/07/83 LDW  ADD SP SUPPORT                                   *
*                    ADD SUPPORT FOR QSTDEFKY                         *
*                    ADD WORKLEN=                                     *
*                    DELETE SOME CODE WHICH BECAME SUPERFLUOUS        *
*                    CHANGE HEADERS AND SOME DATA TO LOWER CASE       *
*                    MOVE SOME COUNTERS FROM QCOMMON TO LOCAL:        *
*                       QCOUNT -> SR@TOTAL, QCOUNTE -> SR@EXEC,       *
*                       QCOUNTA -> SR@WAIT, QCOUNTH -> SR@HELD        *
*      01/03/83 LDW  ADJUST TO USE MODIFIED $JQT MACRO                *
*      12/17/82 LDW  ADD TSU AND STC QUEUES TO "DQ" DISPLAY           *
*                    FIX BUG IN COUNTING MISC QUEUE JOBS WAITING EXEC *
*                    ADD SUPPORT FOR RESERVED WORDS                   *
*      12/14/82 LDW  ADD "DN" SUBCOMMAND TO DISPLAY *ALL* JOBS        *
*                       (CHANGE "DHX" FROM CODE=52 TO 56, SINCE IT    *
*                       WILL EVENTUALLY BE DELETED)                   *
*      11/15/82 LDW  DON'T FORMAT FREE JQES ON THE PURGE QUEUE        *
*      10/21/82 LDW  CHANGE "HO" TO "DH", "XHO" TO "DHX"              *
*      08/26/82 LDW  DISPLAY ALL MISC QUEUES FOR ALL SUBCOMMANDS      *
*                    COMPUTE QUEUE POSITION CORRECTLY FOR "STATUS"    *
*                    FIX MINOR BUGS IN "DQ"                           *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 3
SEARCH   QSTART  Q20,WORKLEN=SR@WORKL,STACK=X'01'
         LA    R10,4095(,R12)           SET UP ...
         LA    R10,1(,R10)              ... SECOND BASE
         USNGX SEARCH+4096,R10          ARRRGH
         QCALL CKPT                     READ CHECKPOINT DATA
         QCALL DISP80                   SWITCH TO 3278-2 MODE IF 3278-5
         USNGX JQEDSECT,R9              BASE REG FOR JQE DSECT
         USNGX JOEDSECT,R8              BASE REG FOR JOE DSECT
         USNGX WORK,R13                 BASE REG FOR LOCAL WORK AREA
         MVC   SR@PARM1,QPARM1          SAVE CLASS LIST
         MVI   SR@JQNUM,0               CLEAR TOP BYTE
         MVI   SR@FLAG,0                INIT FLAGS
         MVI   SR@AFF,0                 INIT AFFINITY MASK
         MVC   SR@WTRID,QBLANK          CLEAR WTRNAME SAVE AREA
***********************************************************************
*                                                                     *
*   BRANCH TO PROPER ROUTINE                                          *
*                                                                     *
***********************************************************************
         LH    R1,QCODEH                LOAD FUNCTION CODE INTO R1
         CH    R1,=H'56'                Is the function code ok?
         BNH   *+8(R1)                  YES - BRANCH TO ROUTINE
         EX    0,*                      NO - QUEUE LOGIC ERROR
         B     ST                       0 OFFSET
         B     DA                       4
         B     DI                       8
         B     DO                       12
         B     AI                       16
         B     AO                       20
         B     HI                       24
         B     DH  (FORMERLY, "HO")     28
         B     DT                       32
         B     DJ                       36  ALSO "XJ" COMMAND
         B     DS                       40
         B     DQ                       44
         B     DEV                      48
         B     DN                       52
         B     NJ                       56
***********************************************************************
*                                                                     *
*   DJ - FIND A SPECIFIC JOB                                          *
*                                                                     *
***********************************************************************
DJ       MVC   QJOBID(2+8),QLNG1        SAVE JOBID & LENGTH
         BAL   R2,SR$STUP               ANALYZE 'S','T','U','P' opernds
         CLI   QKEYWORD,C'O'            want OUTGRP?
         BNE   *+8                      No - skip
         OI    QSCFLAG3,QSC3OUTG        indicate want OUTGRP
         CLC   =C'XJ',QSUBNAME          IS THIS "XJ"?
         BNE   DJ$01                    NO - SKIP
         OI    QSCFLAG2,QSC2DJX         YES - SET FLAG FOR "FORMAT"
         B     DJ$01                    USE THE STATUS ROUTINES
***********************************************************************
*                                                                     *
*   STATUS - FIND ALL JOBS THAT MATCH LEVEL                           *
*                                                                     *
***********************************************************************
ST       CLI   SR@PARM1,C' '            DID USER SPECIFY LEVEL?
         BNE   *+10                     YES - SKIP
         MVC   SR@PARM1,QSTKEY          NO - USE LAST SEARCH KEY
         CLC   =C'* ',SR@PARM1          SELF?
         BNE   *+10                     NO - SKIP
         MVC   SR@PARM1,QSTDEFKY        YES - GET DEFAULT SEARCH KEY
         MVC   QSTKEY,SR@PARM1          SAVE SEARCH KEY
*---  ANALYZE KEYWORDS                                             ---*
         LA    R15,QKEYWORD             -> FIRST KEYWORD SLOT
         LA    R0,16                    ENTRY LENGTH (BXLE INCR)
         LA    R1,QKEYLAST              -> PAST LAST KEYWORD SLOT
         SPACE 1
ST$KW$LP CLI   0(R15),C' '              ANY KEYWORD HERE?
         BE    ST$KW$OK                 NO - DONE WITH KEYWORDS
         CLI   0(R15),C'T'              WANT TIME INSTEAD OF CHARS?
         BE    ST$TIME                  YES - GO SET FLAG
         CLI   0(R15),C'U'              WANT userid INSTEAD OF rmt?
         BE    ST$USER                  YES - GO SET FLAG
         CLI   0(R15),C'P'              WANT percent INSTEAD OF LINES?
         BE    ST$PCT                   YES - GO SET FLAG
         CLI   0(R15),C'S'              WANT SPACE INSTEAD OF LINES?
         BE    ST$SPACE                 YES - GO SET FLAG
         CLI   0(R15),C'A'              WANT ALL JOBS FOR THIS USER?
         BE    ST$ALL                   YES - GO SET FLAG
         CLI   0(R15),C'O'              want OUTGRP?
         BE    ST$OUTG                  yes - go set flag
         L     R0,=C'SR1 '              SET LOGIC ERROR CODE
         L     R15,=V(LOGICERR)         -> ROUTINE
         BALR  R14,R15                  GO TO IT (NO RETURN)
ST$TIME  OI    QSCFLAG1,QSC1TIME        INDICATE WANT INP OR OUTP TIME
         B     ST$KWNXT                 PROCESS NEXT KEYWORD
ST$USER  OI    QSCFLAG3,QSC3USER        INDICATE WANT userid
         B     ST$KWNXT                 PROCESS NEXT KEYWORD
ST$PCT   OI    QSCFLAG1,QSC1PCT         INDICATE WANT SPOOL percent
         B     ST$KWNXT                 PROCESS NEXT KEYWORD
ST$SPACE OI    QSCFLAG1,QSC1SPC         INDICATE WANT SPOOL SPACE
         B     ST$KWNXT                 PROCESS NEXT KEYWORD
ST$ALL   OI    SR@FLAG,SR@FALLJ         INDICATE WANT ALL JOBS
         B     ST$KWNXT                 PROCESS NEXT KEYWORD
ST$OUTG  OI    QSCFLAG3,QSC3OUTG        indicate want OUTGRP
         B     ST$KWNXT                 process next keyword
ST$KWNXT BXLE  R15,R0,ST$KW$LP
ST$KW$OK EQU   *,4,C'I'
***********************************************************************
*  PREPARE SEARCH DATA                                                *
***********************************************************************
DJ$01    LA    R6,7                     MAXIMUM LENGTH OF 8
         LA    R15,SR@PARM1+7           -> END OF FIELD
DJ$02    CLI   0(R15),C' '              END OF SEARCH KEY?
         BNE   DJ$03                    YES - HAVE LENGTH
         BCTR  R15,0                    DECR LENGTH
         BCT   R6,DJ$02                 TRY PREVIOUS BYTE
DJ$03    LR    R1,R6                    GET LENGTH-1 OF PARM
         ICM   R6,B'1100',=X'EFEF'      INVALIDATE JOBNO FOR NOW
         CLI   QCODE,0                  IS THIS "STATUS"?
         BE    ST$00                    YES - SKIP
         LA    R15,SR@PARM1             GET ADDRESS OF PARM
         IC    R4,SR@PARM1              SAVE FIRST CHARACTER IN CASE
          AIF   (&QLEVEL GE 4).SR020
         SR    R0,R0                    ASSUME 'J' - SET BASE
         CLI   SR@PARM1,C'J'            IS IT?
         BE    DJ$04                    YES
         LH    R0,=H'10000'             ASSUME 'S' - SET BASE
         CLI   SR@PARM1,C'S'            IS IT?
         BE    DJ$04                    YES
         AR    R0,R0                    ASSUME 'T' - SET BASE (20000)
         CLI   SR@PARM1,C'T'            IS IT?
         BE    DJ$04                    YES
         SR    R0,R0                    NO - ASSUME NUMBER - RESET BASE
         B     DJ$05                    CONTINUE
          AGO   .SR040
.SR020    ANOP
         CLI   SR@PARM1,C'J'            IS IT JOB?
         BE    DJ$04                    YES
         CLI   SR@PARM1,C'S'            IS IT STC?
         BE    DJ$04                    YES
         CLI   SR@PARM1,C'T'            IS IT TSU?
         BNE   DJ$05                    NO - ASSUME NAME OR PURE NUMBER
.SR040    ANOP
DJ$04    MVI   SR@PARM1,C'0'            CHANGE J/S/T TO '0'
DJ$05    BAL   R14,QNUMCONV             CONVERT PARM TO BINARY
         BNE   DJ$06                    SKIP IF NOT NUMERIC
         LTR   R15,R15                  IS IT POSITIVE?
         BNP   DJ$06                    NO - TRY JOBNAME
         CH    R15,=H'9999'             IS IT IN RANGE?
         BH    DJ$06                    NO - TRY JOBNAME
          AIF   (&QLEVEL GE 4).SR060
         AR    R15,R0                   ADD BASE
.SR060    ANOP
         SLL   R15,16                   SHIFT TO TOP HALFWORD
         N     R6,=X'0000FFFF'          REMOVE FLAG
         OR    R6,R15                   SAVE JOBNO IN R6(0:15)
         B     DJ$07                    SKIP AROUND
DJ$06    STC   R4,SR@PARM1              RESTORE FIRST CHAR OF JOBNAME
DJ$07    CLI   QCODE,36                 DJ/XJ?
         BNE   *+8                      NO - SKIP
         IC    R6,=AL1(8-1)             YES - COMPARE FOR LENGTH OF 8
         B     DEV                      SKIP AROUND 'DN' KEYWORD CODE
DN       BAL   R2,SR$STUP               ANALYZE 'S','T','U','P' opernds
ST$00    EQU   *,4,C'I'
DEV      L     R4,QCJQHEAD              -> FIRST MISC QUEUE HEADER
         MVI   QCLASS,12                INDICATE THIS IS A MISC QUEUE
DJ$11    BAL   R2,SRCHJQE               SEARCH THE QUEUE
         B     DJ$12                    END OF QUEUE
         CLI   JQETYPE,$FREE            IS THIS A FREE JQE?
         BE    SKIPJQE                  YES - SKIP IT
         BAL   R14,STTEST               SEE IF WE WANT THIS JOB
         B     SKIPJQE                  NO. SKIP THIS RECORD.
         B     PRTJQE                   YES - PRINT THE RECORD
DJ$12    LA    R4,$JQHEADL(,R4)         -> NEXT QUEUE HEADER
         L     R1,QCJQHEAD              -> JQT
         LA    R0,JQTOUT-JQTDSECT(,R1)  -> HELD OUTPUT QUEUE HEADER
         CR    R4,R0                    NOW POINTING AT HELD OUTPUT Q?
         BNE   *+8                      NO - OK
         LA    R4,$JQHEADL(,R4)         YES - SKIP THEM (WILL DO LATER)
         LA    R0,JQTSTC-JQTDSECT(,R1)  -> FIRST NON-MISC QUEUE HEADER
         CR    R4,R0                    DONE ALL MISC QUEUES?
         BL    DJ$11                    NO - DO NEXT
***********************************************************************
* SEARCH THE TSO QUEUE                                                *
***********************************************************************
         L     R1,QCJQHEAD              LOAD ADDR OF JQT
         LA    R4,JQTTSU-JQTDSECT(,R1)  ADDR OF TSO QUEUE
         MVI   QCLASS,0                 INDICATE THIS IS THE TSO QUEUE
         BAL   R2,SRCHJQE               SEARCH THE QUEUE
         B     DJ$30                    END OF QUEUE
         BAL   R14,STTEST               SEE IF WE WANT THIS JOB
         B     SKIPJQE                  NO. SKIP THIS RECORD.
         B     PRTJQE                   YES - PRINT THE RECORD
***********************************************************************
* SEARCH THE SYSTEM QUEUE                                             *
***********************************************************************
DJ$30    L     R1,QCJQHEAD              LOAD ADDR OF JQT
         LA    R4,JQTSTC-JQTDSECT(,R1)  ADDR OF STC QUEUE
         MVI   QCLASS,4                 INDICATE THIS IS THE STC QUEUE
         BAL   R2,SRCHJQE               SEARCH THE QUEUE
         B     DJ$40                    END OF QUEUE
         BAL   R14,STTEST               SEE IF WE WANT THIS JOB
         B     SKIPJQE                  NO. SKIP THIS RECORD.
         B     PRTJQE                   YES - PRINT THE RECORD
***********************************************************************
*  SEARCH FOR HELD OUTPUT                                             *
***********************************************************************
DJ$40    MVI   QCLASS,8                 INDICATE THIS IS THE HELD OUT Q
          AIF  (&QLEVEL GE 11).SR120
         L     R1,QCJQHEAD              LOAD ADDR OF JQT
         LA    R4,JQTOUT-JQTDSECT(,R1)  ADDR OF $OUTPUT QUEUE
         BAL   R2,SRCHJQE               SEARCH THE QUEUE
         B     ST$30                    END OF QUEUE
*---  BOTH MIKE STEIN AND JACK SCHUDEL, WHEN THEY CHANGED THIS FOR ---*
*---  SP JES2, DID IT WRONG (EACH IN THEIR OWN WAY)                ---*
          AIF  (&QLEVEL GE 9).SR080
         LH    R0,JQEHLDCT              GET HELD DATASET COUNT
         N     R0,=X'0000FFF0'          GET RID OF JUNK
         BZ    REJJQE                   REJECT IF NO HELD DATASETS
          AGO  .SR100
.SR080    ANOP ,
         CLC   JQEHDSCT,=F'0'           check held dataset count
         BE    REJJQE                   reject if no held datasets
.SR100    ANOP ,
         BAL   R14,STTEST               SEE IF WE WANT THIS JOB
         B     SKIPJQE                  NO. COUNT & SKIP THIS RECORD.
         B     PRTJQE                   PRINT THIS RECORD
          AGO  .SR140
.SR120    ANOP ,
         L     R1,QCJOTA                load addr of JOT
         LA    R4,JOTHOLDQ-JOTDSECT(,R1)  -> held output queue
         BAL   R2,SRCHJOE               search the queue
         B     ST$30                 +0 END OF QUEUE
         BAL   R14,STTEST            +4 SEE IF WE WANT THIS JOB
         B     SKIPJOE               +0 NO. SKIP THIS RECORD.
         B     PRTJOE$H              +4 print the record
.SR140    ANOP ,
***********************************************************************
*  SEARCH INPUT QUEUES                                                *
***********************************************************************
ST$30    MVI   QCLASS,C'I'              INDICATE INPUT QUEUES
         MVI   SR@JQCLS,0               START WITH FIRST INPUT CLASS
ST$40    BAL   R2,NEXTJQT               FIND NEXT QUEUE
         BAL   R2,SRCHJQE               SEARCH THE QUEUE
         B     ST$40                    END OF QUEUE
         BAL   R14,STTEST               SEE IF WE WANT THIS JOB
         B     SKIPJQE                  NO. SKIP THIS RECORD.
         B     PRTJQE                   YES - PRINT THE JQE
***********************************************************************
*  SEARCH OUTPUT QUEUES                                               *
***********************************************************************
ST$50    MVI   QCLASS,C'O'              INDICATE OUTPUT QUEUES
         MVI   SR@JQCLS,0               START WITH FIRST OUTPUT CLASS
ST$60    BAL   R2,NEXTJOT               DETERMINE NEXT QUEUE
         BAL   R2,SRCHJOE               SEARCH A JQE QUEUE
         B     ST$60                    END OF QUEUE
         BAL   R14,STTEST               SEE IF WE WANT THIS JOB
         B     SKIPJOE                  NO. SKIP THIS RECORD.
         B     PRTJOE                   YES - PRINT THE RECORD
***********************************************************************
*  SUBROUTINE TO DETERMINE IF THIS JOB IS INTERESTING.                *
***********************************************************************
STTEST   CLI   QCODE,52                 IS THIS "DN"?
         BE    4(,R14)                  YES - RETURN TO "YES"
         CLI   QCODE,48                 IS THIS "DEV"?
         BE    DEVTEST                  YES
         CLM   R6,B'1100',JQEJOBNO      IS IT THE RIGHT JOB NUMBER?
         BE    4(,R14)                  YES - RETURN TO "YES"
         MVC   SR@JOBNM,JQEJNAME        copy jobname
         OC    SR@JOBNM,QBLANK          upper case it
         EX    R6,STCLC1                DOES NAME START WITH PREFIX?
         BE    4(,R14)                  YES - RETURN TO "YES"
         CLI   JQETYPE,$HARDCPY         IS THE JOB ON OUTPUT QUEUE?
         BNE   SR$NO$W1                 NO - SKIP
         CL    R8,=X'F0000000'          ANY JOE PTR?  (INVALIDATED)
         BE    SR$NO$W1                 NO - SKIP
         QNEXT R15,JOECHAR,NONE=SR$NO$W1  OFFSET TO CHARACTERISTICS JOE
         AL    R15,QCJOTA               ADD BASE TO OFFSET
         CLC   SR@PARM1,JOEWTRID-JOEDSECT(R15)  WTRNAME = SEARCH KEY?
         BE    4(,R14)                  YES - RETURN TO "YES"
          AIF   (&QLEVEL LT 11).SR160
         CLC   SR@PARM1,JOEUSER-JOEDSECT(R15)  USER = SEARCH KEY?
         BE    4(,R14)                  YES - RETURN TO "YES"
.SR160    ANOP
SR$NO$W1 EQU   *
          AIF   ('&@@QJOWN' EQ '').SR180
         EX    R6,STCLC5                SUBMITTOR'S ID START WITH PFX?
         BE    4(,R14)                  YES - RETURN TO "YES"
.SR180    ANOP
         TM    SR@FLAG,SR@FALLJ         WANT ALL JOBS CHECKED?
         BZR   R14                      NO - RETURN TO "NO"
*---  READ THE JCT FOR THIS JOB.  NOTE:  THIS WILL EFFECTIVELY     ---*
*---  CAUSE THE JCT FOR EVERY JOB IN THE SYSTEM TO BE READ...      ---*
*---  (MANY, MANY I/O REQUESTS)                                    ---*
         MVC   QCTRAK,JQETRAK           DISK ADDR OF JCT
         L     R1,QCJCTA                -> IOAREA FOR JCT
         MVC   QCCBID,=C'JCT '          SHOW WHAT WE WANT
         LR    R3,R14                   PRESERVE RETURN ADDR
         LR    R0,R9                    -> JQE
         QCALL READSPC                  READ HASPACE
         LR    R14,R3                   RESTORE RETURN ADDR
         L     R1,QCJCTA                -> IOAREA FOR JCT
         USNGX JCTSTART,R1
         EX    R6,STCLC2                DOES NOTIFY START WITH PREFIX?
         BE    4(,R14)                  YES - RETURN TO "YES"
          AIF   (&@@ACF2 EQ 0).SR240
         SPACE 2
*---  LOCATE THE ACF2 USER SECTION IN THE NETWORK JOB HEADER       ---*
*---  SEE ACF2.R314.ACFJES(ACF2X1) AT LABEL #ACFNJH1               ---*
*---  OR SKK PRIVATE MACRO ACF2LNJS                                ---*
         LH    R0,NJHLEN-NJHDSECT+JCTNJHDR  GET LENGTH OF NJH BLOCK
         SH    R0,=H'4'                 ADJUST LENGTH FOR THE PREFIX
         LA    R1,4+JCTNJHDR            -> FIRST SECTION
         DROPX R1                       JCTSTART
         USNGX NJHU,R1
         SPACE 1
SR$NJ$LP CLC   NJHUTYPE(6),SR#ACFID     IS THIS THE ACF2 USER SECTION?
         BE    SR$ACF2                  YES - CONTINUE
         SH    R0,NJHULEN               SUBTRACT LENGTH OF SECTION
         AH    R1,NJHULEN               -> NEXT SECTION
         LTR   R0,R0                    ANY MORE SECTIONS?
         BP    SR$NJ$LP                 YES - CHECK NEXT
         BR    R14                      NO - RETURN TO 'NO'
         DROPX R1                       NJHU
         SPACE 1
SR$ACF2  LA    R1,ACFNJVLD-ACFNJBLK(,R1)  -> ACVALD BLK IN JCB
         USNGX ACVALD,R1
          AGO   .SR220
          AIF   (&QLEVEL LT 4).SR200
         ICM   R0,B'1111',&ACF2JCT      OFFSET OF ACF2 USER AREA
         BZR   R14                      SKIP NEXT 2 TESTS IF NOT VALID
*---  THE FOLLOWING IS A KLUDGE.  THE REAL NUMBER SHOULD BE        ---*
*---  'BUFSTART-BUFDSECT', BUT IF I CODE A $BUFFER MACRO, IT WILL  ---*
*---  MESS UP USAGE OF $HQT, $IOT, AND $JCT.  THIS WILL HAVE TO BE ---*
*---  STRAIGHTENED OUT SOMETIME IN THE FUTURE, WHEN I FEEL LIKE IT.---*
         AR    R1,R0
         SH    R1,=Y(X'58')             -> ACF2 USER AREA
         DROPX R1                       JCTSTART
         USNGX #ACFJCTX,R1
.SR200    ANOP
         CLC   =C'ACFJ',JCTACFJ         IS IT ANY GOOD?
         BNER  R14                      NO - SKIP
.SR220    ANOP
         EX    R6,STCLC3                DID JOB RUN ON THIS USER'S LID?
         BE    4(,R14)                  YES - RETURN TO "YES"
         EX    R6,STCLC4                DID USER SUBMIT THIS JOB?
         BE    4(,R14)                  YES - RETURN TO "YES"
         DROPX R1                       #ACFJCTX OR ACVALD
         USNGX JCTSTART,R1              FOR EXECUTED CLC'S
.SR240    ANOP
         BR    R14                      NO - RETURN TO "NO"
         SPACE 1
*STCLC1  CLC   SR@PARM1(*-*),JQEJNAME   << EXECUTED >>
STCLC1   CLC   SR@PARM1(*-*),SR@JOBNM   << EXECUTED >>
STCLC2   CLC   SR@PARM1(*-*),JCTTSUID   << EXECUTED >>
         DROPX R1                       JCTSTART
          AIF   (&@@ACF2 EQ 0).SR280
          AIF   (&QLEVEL GT 3).SR260
         USNGX #ACFJCTX,R1
STCLC3   CLC   SR@PARM1(*-*),LIDLID     << EXECUTED >>
STCLC4   CLC   SR@PARM1(*-*),ACVSLID    << EXECUTED >>
         DROPX R1                       #ACFJCTX
          AGO   .SR280
.SR260    ANOP
         USNGX ACVALD,R1
STCLC3   CLC   SR@PARM1(*-*),ACVLID     << EXECUTED >>
STCLC4   CLC   SR@PARM1(*-*),ACVSLID    << EXECUTED >>
         DROPX R1                       ACVALD
.SR280    ANOP
          AIF   ('&@@QJOWN' EQ '').SR300
STCLC5   CLC   SR@PARM1(*-*),&@@QJOWN   << EXECUTED >>
.SR300    ANOP
         SPACE 2
DEVTEST  CLI   QCLASS,12                DOING MISC QUEUES?
         BE    DEV$JQE                  YES
         CLI   QCLASS,C'O'              DOING OUTPUT QUEUES?
         BNER  R14                      "NO"
         TM    JOEFLAG,$JOEBUSY         IS JOE ACTIVE?
         BZR   R14                      "NO"
         B     4(,R14)                  "YES"
DEV$JQE  TM    JQETYPE,$INPUT           READING?
         BNOR  R14                      "NO"
         B     4(,R14)                  "YES"
***********************************************************************
*                                                                     *
*   DQ - PRINT SUMMARY OF ALL JOBS IN THE INPUT/OUTPUT QUEUES         *
*                                                                     *
***********************************************************************
DQ       MVC   QDHLINE,=C'  Queue Class  Total Jobs   # Exec/Print    #$
                Waiting     # Held   Output Lines'
         CLI   SR@PARM1,C'I'            INPUT QUEUES ONLY?
         BE    DQI                      YES - SKIP MISC QUEUE DISPLAY
         CLI   SR@PARM1,C'O'            OUTPUT QUEUES ONLY?
         BE    DQO$00                   YES - SKIP INPUT QUEUE DISPLAY
***********************************************************************
*  SUMMARIZE THE MISCELLANEOUS QUEUES                                 *
***********************************************************************
         L     R4,QCJQHEAD              ADDR OF FIRST MISCELLANEOUS Q
         LA    R7,SR#MISC
         ZAP   SR@GRAND,=P'0'           INIT GRAND TOTALS
         ZAP   SR@TEXEC,=P'0'           ...
         ZAP   SR@TWAIT,=P'0'           ...
         ZAP   SR@THELD,=P'0'           ...
DQI$10   ZAP   SR@EXEC,=P'0'            ZERO COUNT FOR EXECUTING JOBS
         ZAP   SR@WAIT,=P'0'            ZERO COUNT FOR AWAITING JOBS
         ZAP   SR@HELD,=P'0'            ZERO COUNT FOR HELD JOBS
          AIF  (&QLEVEL LT 11).SR320
         CLC   SR#HOUT,0(R7)            PROCESSING HELD-OUTPUT?
         BE    DQI$40                   yes - skip it - it'll be done  $
                                           as an OUTPUT queue
.SR320    ANOP
         BAL   R2,SRCHJQE               SEARCH THE QUEUE
         B     DQI$30                   END OF QUEUE
          AIF  (&QLEVEL GE 11).SR360
         CLC   SR#HOUT,0(R7)            PROCESSING HELD-OUTPUT?
         BNE   DQI$11                   NO - SKIP FUNNY HELD-OUT TESTS
         CLI   SR@PARM1,C'X'            X OPTION GIVEN?
         BE    DQI$11                   YES - SKIP FUNNY HELD-OUT TESTS
          AIF  (&QLEVEL GE 9).SR340
         LH    R0,JQEHLDCT              GET HELD DATASET COUNT
         N     R0,=X'0000FFF0'          GET RID OF JUNK
         BZ    REJJQE                   IGNORE THE RECORD IF NONE HELD
          AGO  .SR360
.SR340    ANOP ,
         CLC   JQEHDSCT,=F'0'           check held dataset count
         BE    REJJQE                   ignore the record if none held
.SR360    ANOP ,
DQI$11   TM    JQEFLAGS,QUEBUSY         IS THIS JOB EXECUTING?
         BZ    DQI$12                   NO, NEXT TEST
         AP    SR@EXEC,=P'1'            YES, BUMP COUNTER
         B     DQI$20                   NEXT TEST
DQI$12   TM    JQEFLAGS,QUEHOLDA+QUEHOLD1+QUEHOLD2  IS THIS A HELD JOB?
         BZ    DQI$20                   NO, NEXT TEST
         AP    SR@HELD,=P'1'            YES, BUMP COUNTER
         B     SKIPJQE                  PROCESS NEXT JQE
DQI$20   TM    JQEFLAGS,QUEBUSY         IS THIS JOB EXECUTING?
         BNZ   SKIPJQE                  YES - PROCESS NEXT JQE
         AP    SR@WAIT,=P'1'            COUNT AN AWAITING EXECUTION JOB
         B     SKIPJQE                  PROCESS NEXT JQE
DQI$30   CP    QCOUNT,=P'0'             IS THIS QUEUE EMPTY?
         BE    DQI$40                   YES, TRY THE NEXT QUEUE
         MVC   SR@ATTR,=X'1D60'         SET OUTPUT, NORMAL
         MVI   QDATRNUM+1,1             NUMBER OF ATTR BYTES IN LINE
         MVC   CLSTYPE(L'SR#MISC),0(R7) SET QUEUE TYPE
         BAL   R2,SR$COUNT              # JOBS EX, AW EX, # HELD, TOTAL
         AP    SR@GRAND,QCOUNT          ACCUMULATE TOTAL JOBS IN QUEUE
         AP    SR@TEXEC,SR@EXEC         ACCUMULATE JOBS EXECUTING
         AP    SR@TWAIT,SR@WAIT         ACCUMULATE JOBS WAITING
         AP    SR@THELD,SR@HELD         ACCUMULATE JOBS HELD
         BAL   R14,QADDLINE             GO DISPLAY THIS LINE
DQI$40   LA    R7,L'SR#MISC(,R7)        -> NEXT MISC QUEUE TYPE DESCR
         LA    R4,$JQHEADL(,R4)         -> NEXT MISC QUEUE HEADER
         L     R1,QCJQHEAD              LOAD ADDR OF JQT
         LA    R0,JQTTSU-JQTDSECT(,R1)  -> LAST MISC QUEUE HEADER
         CR    R4,R0                    DONE WITH MISC QUEUES?
         BNH   DQI$10                   NO - DO NEXT
         ZAP   QCOUNT,SR@GRAND          GRAND TOTAL JOBS IN QUEUE
         ZAP   SR@EXEC,SR@TEXEC         TOTAL JOBS EXECUTING
         ZAP   SR@WAIT,SR@TWAIT         TOTAL JOBS WAITING
         ZAP   SR@HELD,SR@THELD         TOTAL JOBS HELD
         MVC   SR@ATTR,=X'1DE8'         SET OUTPUT, BRIGHT
         MVI   QDATRNUM+1,1             NUMBER OF ATTR BYTES IN LINE
         MVC   CLSTYPE(10),=C'Total Misc'
         BAL   R2,SR$COUNT              FORMAT TOTALS LINE
         BAL   R14,QADDLINE             DISPLAY THIS LINE
         BAL   R14,QADDLINE             PUT IN BLANK LINE
         CLI   SR@PARM1,C'M'            MISC QUEUES ONLY?
         BE    SPOOLUTL                 YES - GO DIRECTLY TO DISP %UTIL
***********************************************************************
*  SUMMARIZE ALL INPUT QUEUES                                         *
***********************************************************************
DQI      MVI   QCLASS,C'I'              INDICATE INPUT QUEUES
         MVI   SR@JQCLS,0               START WITH FIRST INPUT CLASS
         ZAP   SR@GRAND,=P'0'           INIT GRAND TOTALS
         ZAP   SR@TEXEC,=P'0'           ...
         ZAP   SR@TWAIT,=P'0'           ...
         ZAP   SR@THELD,=P'0'           ...
DQI$50   BAL   R2,NEXTJQT               FIND NEXT QUEUE
         ZAP   SR@EXEC,=P'0'            ZERO COUNT FOR EXECUTING JOBS
         ZAP   SR@WAIT,=P'0'            ZERO COUNT FOR AWAITING JOBS
         ZAP   SR@HELD,=P'0'            ZERO COUNT FOR HELD JOBS
         BAL   R2,SRCHJQE               SEARCH THE QUEUE
         B     DQI$80                   END OF QUEUE
         TM    JQEFLAGS,QUEBUSY         IS THIS JOB EXECUTING
         BZ    DQI$60                   NO, NEXT TEST
         AP    SR@EXEC,=P'1'            YES, BUMP COUNTER
         B     SKIPJQE                  PROCESS NEXT JQE
DQI$60   TM    JQEFLAGS,QUEHOLDA+QUEHOLD1+QUEHOLD2  IS THIS A HELD JOB?
         BZ    DQI$70                   NO, NEXT TEST
         AP    SR@HELD,=P'1'            YES, BUMP COUNTER
         B     SKIPJQE                  PROCESS NEXT JQE
DQI$70   TM    JQEFLAGS,QUEBUSY         IS THIS JOB AWAITING EXECUTION?
         BNZ   SKIPJQE                  NO, PROCESS NEXT JQE
         AP    SR@WAIT,=P'1'            YES, BUMP COUNTER
         B     SKIPJQE                  PROCESS NEXT JQE
DQI$80   CP    QCOUNT,=P'0'             IS THIS QUEUE EMPTY
         BE    DQI$50                   YES, TRY THE NEXT QUEUE
         MVC   SR@ATTR,=X'1D60'         SET OUTPUT, NORMAL
         MVI   QDATRNUM+1,1             NUMBER OF ATTR BYTES IN LINE
         MVC   CLSTYPE,=C'Input '       SET QUEUE TYPE
         MVC   CLASS,QCLSNAME           MOVE IN QUEUE CLASS
         BAL   R2,SR$COUNT              # JOBS EX, AW EX, # HELD, TOTAL
         AP    SR@GRAND,QCOUNT          ACCUMULATE TOTAL JOBS IN QUEUE
         AP    SR@TEXEC,SR@EXEC         ACCUMULATE JOBS EXECUTING
         AP    SR@TWAIT,SR@WAIT         ACCUMULATE JOBS WAITING
         AP    SR@THELD,SR@HELD         ACCUMULATE JOBS HELD
         BAL   R14,QADDLINE             GO DISPLAY THIS LINE
         B     DQI$50                   PROCESS THE NEXT QUEUE
DQI$90   ZAP   QCOUNT,SR@GRAND          GRAND TOTAL JOBS IN QUEUE
         ZAP   SR@EXEC,SR@TEXEC         TOTAL JOBS EXECUTING
         ZAP   SR@WAIT,SR@TWAIT         TOTAL JOBS WAITING
         ZAP   SR@HELD,SR@THELD         TOTAL JOBS HELD
         MVC   SR@ATTR,=X'1DE8'         SET OUTPUT, BRIGHT
         MVI   QDATRNUM+1,1             NUMBER OF ATTR BYTES IN LINE
         MVC   CLSTYPE(11),=C'Total Input'
         BAL   R2,SR$COUNT              FORMAT TOTALS LINE
         BAL   R14,QADDLINE             DISPLAY THIS LINE
***********************************************************************
*                                                                     *
*   DQ - PRINT SUMMARY OF ALL JOBS IN THE OUTPUT QUEUES               *
*                                                                     *
***********************************************************************
DQO      BAL   R14,QADDLINE             YES - PUT IN BLANK LINE
         CLI   SR@PARM1,C'I'            INPUT QUEUES ONLY?
         BE    SPOOLUTL                 YES - SKIP OUTPUT QUEUE DISPLAY
DQO$00   ZAP   SR@GRAND,=P'0'           INIT GRAND TOTALS
         ZAP   SR@TEXEC,=P'0'           ...
         ZAP   SR@TWAIT,=P'0'           ...
         ZAP   SR@THELD,=P'0'           ...
         XC    SR@LINES,SR@LINES        ...
          AIF   (&QLEVEL LT 11).SR380
         SR    R6,R6                    CLEAR LINE COUNT
         ZAP   SR@EXEC,=P'0'            ZERO COUNT FOR JOBS PRINTING
         ZAP   SR@WAIT,=P'0'            ZERO COUNT FOR AWAITING JOBS
         ZAP   SR@HELD,=P'0'            ZERO COUNT FOR HELD JOBS
         L     R1,QCJOTA                load addr of JOT
         LA    R4,JOTHOLDQ-JOTDSECT(,R1)  -> held output queue
         BAL   R2,SRCHJOE               SEARCH THE QUEUE
         B     DQH$80                +0 END OF QUEUE
         A     R6,JOERECCT           +4 ADD LINES FOR THIS ELEMENT
         TM    JOEFLAG,$JOEPRT+$JOEPUN  IS JOB PRINTING OR PUNCHING?
         BZ    DQH$20                   NO, SEE IF HELD
         AP    SR@EXEC,=P'1'            YES, BUMP COUNTER
         B     SKIPJOE                  PROCESS NEXT JOE
***DQH$20 TM   JOEFLAG,$JOEHOLD         HELD?
DQH$20   TM    JQEFLAGS,QUEHOLDA+QUEHOLD1+QUEHOLD2  HELD JOB?
         BNZ   DQH$30                   YES - COUNT IT
         AP    SR@WAIT,=P'1'            NO - COUNT 1 AVAILABLE
         B     SKIPJOE                  PROCESS NEXT JOE
DQH$30   AP    SR@HELD,=P'1'            COUNT 1 HELD
         B     SKIPJOE                  PROECESS NEXT JOE
DQH$80   CP    QCOUNT,=P'0'             QUEUE EMPTY?
         BE    DQO$01                   yes - do normal output queues
         MVC   SR@ATTR,=X'1D60'         SET OUTPUT, NORMAL
         MVI   QDATRNUM+1,1             NUMBER OF ATTR BYTES IN LINE
         MVC   CLSTYPE(11),=C'Held Output'
         BAL   R2,SR$COUNT              # JOBS EX, AW EX, # HELD, TOTAL
         MVC   QTLINES,=X'402020206B2020206B202120'
         CVD   R6,QNUMWORK              CONVERT LINES IN THIS CLASS
         ED    QTLINES,QNUMWORK+3
         AP    SR@GRAND,QCOUNT          ACCUMULATE TOTAL JOBS IN QUEUE
         AP    SR@TEXEC,SR@EXEC         ACCUMULATE JOBS EXECUTING
         AP    SR@TWAIT,SR@WAIT         ACCUMULATE JOBS WAITING
         AP    SR@THELD,SR@HELD         ACCUMULATE JOBS HELD
         A     R6,SR@LINES              ACCUMULATE PRINT LINES
         ST    R6,SR@LINES              ...
         BAL   R14,QADDLINE             GO DISPLAY THIS LINE
.SR380    ANOP
DQO$01   MVI   QCLASS,C'O'              INDICATE OUTPUT QUEUES
         MVI   SR@JQCLS,0               START WITH FIRST OUTPUT CLASS
DQO$10   BAL   R2,NEXTJOT               FIND NEXT QUEUE
         SR    R6,R6                    CLEAR LINE COUNT
         ZAP   SR@EXEC,=P'0'            ZERO COUNT FOR JOBS PRINTING
         ZAP   SR@WAIT,=P'0'            ZERO COUNT FOR AWAITING JOBS
         ZAP   SR@HELD,=P'0'            ZERO COUNT FOR HELD JOBS
         BAL   R2,SRCHJOE               SEARCH THE QUEUE
         B     DQO$80                   END OF QUEUE
         A     R6,JOERECCT              ADD LINES FOR THIS ELEMENT
         TM    JOEFLAG,$JOEPRT+$JOEPUN  IS JOB PRINTING OR PUNCHING?
         BZ    DQO$20                   NO, SEE IF HELD
         AP    SR@EXEC,=P'1'            YES, BUMP COUNTER
         B     SKIPJOE                  PROCESS NEXT JOE
***DQO$20 TM   JOEFLAG,$JOEHOLD         HELD?
DQO$20   TM    JQEFLAGS,QUEHOLDA+QUEHOLD1+QUEHOLD2  HELD JOB?
         BNZ   DQO$30                   YES - COUNT IT
         AP    SR@WAIT,=P'1'            NO - COUNT 1 AVAILABLE
         B     SKIPJOE                  PROCESS NEXT JOE
DQO$30   AP    SR@HELD,=P'1'            COUNT 1 HELD
         B     SKIPJOE                  PROECESS NEXT JOE
DQO$80   CP    QCOUNT,=P'0'             QUEUE EMPTY
         BE    DQO$10                   YES, TRY THE NEXT QUEUE
         MVC   SR@ATTR,=X'1D60'         SET OUTPUT, NORMAL
         MVI   QDATRNUM+1,1             NUMBER OF ATTR BYTES IN LINE
         MVC   CLSTYPE,=C'Output'       SET QUEUE TYPE
         MVC   CLASS,QCLSNAME           MOVE IN QUEUE CLASS
         BAL   R2,SR$COUNT              # JOBS EX, AW EX, # HELD, TOTAL
         MVC   QTLINES,=X'402020206B2020206B202120'
         CVD   R6,QNUMWORK              CONVERT LINES IN THIS CLASS
         ED    QTLINES,QNUMWORK+3
         AP    SR@GRAND,QCOUNT          ACCUMULATE TOTAL JOBS IN QUEUE
         AP    SR@TEXEC,SR@EXEC         ACCUMULATE JOBS EXECUTING
         AP    SR@TWAIT,SR@WAIT         ACCUMULATE JOBS WAITING
         AP    SR@THELD,SR@HELD         ACCUMULATE JOBS HELD
         A     R6,SR@LINES              ACCUMULATE PRINT LINES
         ST    R6,SR@LINES              ...
         BAL   R14,QADDLINE             GO DISPLAY THIS LINE
         B     DQO$10                   PROCESS NEXT QUEUE
SR$COUNT MVC   FTCOUNT,=X'402020202020' MOVE IN
         ED    FTCOUNT,SR@EXEC               NUMBER OF JOBS
         MVC   QECOUNT,FTCOUNT+2                       IN EXECUTION
         MVC   FTCOUNT,=X'402020202020' MOVE IN
         ED    FTCOUNT,SR@WAIT               NUMBER OF JOBS
         MVC   QACOUNT,FTCOUNT+2                   AWAITING EXECUTION
         MVC   FTCOUNT,=X'402020202020' MOVE IN
         ED    FTCOUNT,SR@HELD               NUMBER OF JOBS
         MVC   QHCOUNT,FTCOUNT+2                   IN HELD STATUS
         MVC   FTCOUNT,=X'402020202020' MOVE IN TOTAL NUMBER OF JOBS
         ED    FTCOUNT,QCOUNT                IN THIS QUEUE
         BR    R2                       RETURN TO CALLER
DQO$DONE ZAP   QCOUNT,SR@GRAND          GRAND TOTAL JOBS IN QUEUE
         ZAP   SR@EXEC,SR@TEXEC         TOTAL JOBS EXECUTING
         ZAP   SR@WAIT,SR@TWAIT         TOTAL JOBS WAITING
         ZAP   SR@HELD,SR@THELD         TOTAL JOBS HELD
         MVC   SR@ATTR,=X'1DE8'         SET OUTPUT, BRIGHT
         MVI   QDATRNUM+1,1             NUMBER OF ATTR BYTES IN LINE
         MVC   CLSTYPE(12),=C'Total Output'
         BAL   R2,SR$COUNT              FORMAT TOTALS LINE
         L     R6,SR@LINES              GET GRAND TOTAL OF PRINT LINES
         MVC   QTLINES,=X'402020206B2020206B202120'
         CVD   R6,QNUMWORK              CONVERT LINES IN THIS CLASS
         ED    QTLINES,QNUMWORK+3
         BAL   R14,QADDLINE             DISPLAY THIS LINE
         BAL   R14,QADDLINE             PUT IN BLANK LINE
***********************************************************************
*                                                                     *
*   FORMAT PERCENT SPOOL UTILIZATION                                  *
*                                                                     *
          AIF   (&QLEVEL GT 4).SR440
*   (FIND THE SSVT FOR THE SELECTED SUBSYSTEM)                        *
*                                                                     *
***********************************************************************
SPOOLUTL L     R2,QSSCT                 -> SSCT
         LTR   R2,R2                    VALID SUBSYSTEM?
         BZ    QSTOP                    NO - DON'T TRY FOR % UTIL
          AIF  (&QLEVEL GE 9).SR400
         L     R2,SSCTSSVT-SSCT(,R2)    -> SSVT
         USNGX SSVT,R2
          AGO  .SR420
.SR400    ANOP ,
         L     R2,SSCTSUS2-SSCT(,R2)    -> HCCT
         USNGX HCCT,R2
.SR420    ANOP ,
         LTR   R2,R2                    IS IT UP?
         BZ    QSTOP                    NO - DON'T TRY FOR % UTIL
         L     R1,$SVTGALC              GET ALLOCATED TRACK GROUPS
         MH    R1,=H'1000'              SCALE FOR PERCENT * 10
         SR    R0,R0                    CLEAR FOR DIVIDE
         D     R1-1,$SVTGTOT            DIVIDE BY TOTAL TRACK GROUPS
         DROPX R2
          AGO   .SR460
.SR440    ANOP
*                                                                     *
***********************************************************************
SPOOLUTL L     R2,QCJQTL                -> MASTER RECORD CHKPT AREA
         USNGX $SAVEBEG,R2
         L     R1,$TGALLOC              GET AVAIL TGS ALLOCATED
         M     R1-1,=F'1000'            SCALE FOR %*10
         D     R1-1,$TGTOTAL            DIVIDE BY TOTAL TGS AVAILABLE
         DROPX R2                       $SAVEBEG
.SR460    ANOP
         CVD   R1,QNUMWORK              CONVERT TO PACKED
         MVC   SR@ATTR,=X'1D60'         SET OUTPUT, NORMAL
         CH    R1,=H'800'               < 80% ?
         BL    *+8                      YES - OK
         MVI   SR@ATTR+1,X'E8'          NO - SET OUTPUT, BRIGHT
         MVC   QDMSG+16(PERCENTL),PERCENT  MOVE IN MESSAGE
         ED    QDMSG+16(7),QNUMWORK+5   FILL IN PERCENT
         MVI   QDATRNUM+1,2             NUMBER OF ATTR BYTES IN LINE
         BAL   R14,QADDLINE             DISPLAY THE LINE
         B     QSTOP                    ALL DONE
***********************************************************************
*                                                                     *
*   DI - PRINT ALL JOBS IN INPUT QUEUES                               *
*   AI - PRINT JOBS IN INPUT QUEUES THAT ARE AVAILABLE FOR SELECTION  *
*   HI - PRINT JOBS IN INPUT QUEUES THAT ARE HELD                     *
*                                                                     *
***********************************************************************
HI       OI    SR@FLAG,SR@FHI           REMEMBER IT'S "HI"
         B     *+8                      SKIP NEXT INSTR
AI       OI    SR@FLAG,SR@FAI           REMEMBER IT'S "AI"
DI       OI    QSCFLAG2,QSC2DI          TELL 'FORMAT' IT'S DI/AI/HI
         LA    R15,QKEYWORD             -> FIRST KEYWORD SLOT
         LA    R0,16                    ENTRY LENGTH (BXLE INCR)
         LA    R1,QKEYLAST              -> PAST LAST KEYWORD SLOT
         SPACE 1
DI$KW$LP CLI   0(R15),C' '              ANY KEYWORD HERE?
         BE    DI$KW$OK                 NO - DONE WITH KEYWORDS
         CLI   0(R15),C'T'              WANT TIME?
         BE    DI$TIME                  YES - GO SET FLAG
         CLI   0(R15),C'U'              WANT userid?
         BE    DI$USER                  YES - GO SET FLAG
         CLI   0(R15),C'P'              WANT percent?
         BE    DI$PCT                   YES - GO SET FLAG
         CLC   =C'SI',0(R15)            WANT SIZE?
         BE    DI$SPACE                 YES - GO SET FLAG
         CLC   =C'SP',0(R15)            WANT SPACE?
         BE    DI$SPACE                 YES - GO SET FLAG
         CLC   =C'S ',0(R15)            WANT SYSAFF?
         BE    DI$SYSAF                 YES - GO SET FLAG & SAVE IT
         CLC   =C'SY',0(R15)            WANT SYSAFF?
         BE    DI$SYSAF                 YES - GO SET FLAG & SAVE IT
         L     R0,=C'SR2 '              SET LOGIC ERROR CODE
         L     R15,=V(LOGICERR)         -> ROUTINE
         BALR  R14,R15                  GO TO IT (NO RETURN)
DI$TIME  OI    QSCFLAG1,QSC1TIME        INDICATE WANT INP OR OUTP TIME
         B     DI$KWNXT                 PROCESS NEXT KEYWORD
DI$USER  OI    QSCFLAG3,QSC3USER        INDICATE WANT userid
         B     DI$KWNXT                 PROCESS NEXT KEYWORD
DI$PCT   OI    QSCFLAG1,QSC1PCT         INDICATE WANT spool pct OF JOB
         B     DI$KWNXT                 PROCESS NEXT KEYWORD
DI$SPACE OI    QSCFLAG1,QSC1SPC         INDICATE WANT QUEUE SIZE OF JOB
         B     DI$KWNXT                 PROCESS NEXT KEYWORD
DI$SYSAF CLI   8(R15),C' '              ANY OPERAND?
         BE    DI$AFFER                 NO - ERROR
         CLI   8+4+1(R15),C' '          HOW LONG?
         BNE   DI$AFFER                 TOO LONG - ERROR
         CLC   =C'IND ',8(R15)          INDEPENDENT MODE?
         BE    DI$AFIND                 YES - SET FLAG
         CLI   8(R15),C'*'              CURRENT SYSTEM?
         BNE   *+10                     NO - SKIP
         MVC   8(4,R15),QSMFID          YES - CHANGE TO CURRENT SMFID
         LA    R14,1                    SET LOW BIT FOR SYSTEM#1
         L     R4,QVSYSID               -> ZERO'TH SYSTEM ID
DI$AFFLP LA    R4,8(,R4)                -> NEXT TABLE ENTRY
         CLC   0(4,R4),8(R15)           IS THIS THE RIGHT ONE?
         BE    DI$AFFOK                 YES - 'OR' IN THIS BIT
         SLL   R14,1                    NEXT SYSTEM ID
         CH    R14,=Y(X'80')            CHECKED ALL YET?
         BL    DI$AFFLP                 NO - KEEP LOOKING
DI$AFFER QTILT '*** INVALID SYSTEM AFFINITY SPECIFICATION ***',        $
               OPTIONS=REPROMPT
         B     DI$KWNXT                 PROCESS NEXT KEYWORD
DI$AFIND OI    SR@FLAG,SR@FIND+SR@FAFF  INDICATE INDEPENDENT MODE JOBS
         B     DI$KWNXT                 PROCESS NEXT KEYWORD
DI$AFFOK STC   R14,SR@BYTE              SET DOWN BYTE
         OC    SR@AFF,SR@BYTE           COMBINE WITH PREVIOUS BITS
         OI    SR@FLAG,SR@FAFF          INDICATE SYSAFF SELECTION
DI$KWNXT BXLE  R15,R0,DI$KW$LP
DI$KW$OK CLI   SR@PARM1,C' '            DID USER SPECIFY CLASS?
         BNE   DI$50                    YES. LIMIT TO ONE QUEUE.
***********************************************************************
*  SEARCH THE CONVERTER QUEUE                                         *
***********************************************************************
*  SHOULD WE SKIP THE CONVERTER QUEUE IF "AI"???
         L     R1,QCJQHEAD              LOAD ADDR OF JQT
         LA    R4,JQTCONV-JQTDSECT(,R1) ADDR OF CONVERTER QUEUE
         MVI   QCLASS,12                INDICATE THIS IS THE CONVERTR Q
         BAL   R2,SRCHJQE               SEARCH THE QUEUE
         B     DI$20                    END OF QUEUE
         B     PRTJQE                   PRINT THE RECORD
***********************************************************************
*  SEARCH ALL QUEUES                                                  *
***********************************************************************
DI$20    MVI   QCLASS,C'I'              INDICATE INPUT QUEUES
         MVI   SR@JQCLS,0               START WITH FIRST INPUT CLASS
DI$21    BAL   R2,NEXTJQT               DETERMINE NEXT QUEUE
         BAL   R2,SRCHJQE               SEARCH A JQE QUEUE
         B     DI$21                    END OF QUEUE
         TM    SR@FLAG,SR@FAI+SR@FHI    "AI" OR "HI"?
         BZ    PRTJQE                   NO, "DI" - PRINT THE RECORD
         TM    SR@FLAG,SR@FAI           "AI"?
         BO    SR$AI$10                 YES - SEE IF AVAILABLE JOB
*  MUST BE "HI" -- SEE IF HELD JOB
         TM    JQEFLAGS,QUEHOLDA+QUEHOLD1+QUEHOLD2  IS THE JOB HELD?
         BZ    REJJQE                   NO. SKIP IT.
         B     PRTJQE                   PRINT THE RECORD
*  "AI" -- SEE IF AVAILABLE FOR SELECTION
SR$AI$10 CLI   JQEFLAGS,0               IS THE JOB BUSY OR HELD?
         BNE   REJJQE                   YES. SKIP IT.
         B     PRTJQE                   PRINT THE RECORD
***********************************************************************
* SEARCH SPECIFIC QUEUES                                              *
***********************************************************************
DI$50    MVI   QCLASS,C'I'              INDICATE INPUT QUEUES
         MVC   SR@JQCLS,SR@PARM1        USER SPECIFIED CLASS
*  SHOULD WE SKIP THE CONVERTER QUEUE IF "AI"???
         CLI   SR@PARM1,C'*'            WANT CONVERTER QUEUE?
         BE    DI$60                    YES - DO IT
         BAL   R2,FIRSTJQT              FIND QUEUE
DI$70    BAL   R2,SRCHJQE               SEARCH THE QUEUE
         B     DI$80                    END OF QUEUE
         TM    SR@FLAG,SR@FAI+SR@FHI    "AI" OR "HI"?
         BZ    PRTJQE                   NO, "DI" - PRINT THE RECORD
         TM    SR@FLAG,SR@FAI           "AI"?
         BO    SR$AI$20                 YES - SEE IF AVAILABLE JOB
*  MUST BE "HI" -- SEE IF HELD JOB
         TM    JQEFLAGS,QUEHOLDA+QUEHOLD1+QUEHOLD2  IS THE JOB HELD?
         BZ    REJJQE                   NO. SKIP IT.
         B     PRTJQE                   PRINT THE RECORD
*  "AI" -- SEE IF AVAILABLE FOR SELECTION
SR$AI$20 CLI   JQEFLAGS,0               IS THE JOB BUSY OR HELD?
         BNE   REJJQE                   YES. SKIP IT.
         B     PRTJQE                   PRINT THE RECORD
DI$60    L     R1,QCJQHEAD              POINT TO JQT
         LA    R4,JQTCONV-JQTDSECT(,R1) POINT TO CONVERTER QUEUE
         MVI   QCLASS,12                INDICATE THIS IS THE CONVERTR Q
         B     DI$70                    GO FORMAT THIS QUEUE
DI$80    BAL   R2,NEXT$CLS              SELECT NEXT CLASS, IF ANY
         B     DI$50                    THERE WAS A NEXT - PROCESS IT
***********************************************************************
*                                                                     *
*   AO - PRINT AVAILABLE JOBS IN THE OUTPUT QUEUE FOR USER'S DEST     *
*   DO - PRINT ALL       JOBS IN THE OUTPUT QUEUE FOR USER'S DEST     *
*                                                                     *
***********************************************************************
DO       EQU   *,4,C'I'
AO       MVC   SR@DEST,QDEST            DEFAULT DEST IS LOGON DEST
         MVC   SR@DESTL,=Y(8-1)         len to compare
         CLC   SR@DEST,=CL8'LOCAL'      "LOCAL"
         BE    DO$LOCAL                 YES - MAKE IT BLANK
         CLI   SR@DEST,X'00'            IS IT HEX ZEROES?
         BNE   *+10                     NO - OK
         MVC   SR@DEST,QBLANK           YES - CHANGE TO BLANKS
*---  SEE IF DEFAULT NAME IS AN ALIAS FOR 'LOCAL'
         L     R15,=A(SR#LOCAL)         -> LOCAL EQUIVALENCE TABLE
DO$LCLCK CLI   0(R15),X'FF'             END OF TABLE?
         BE    DO$KW$CK                 yes - use dest as is
         CLC   SR@DEST,0(R15)           DEFAULT DEST IN TABLE?
         BE    DO$LOCAL                 YES - CHANGE TO BLANKS
         LA    R15,8(,R15)              -> NEXT TABLE ENTRY
         B     DO$LCLCK                 SEARCH WHOLE TABLE
DO$LOCAL MVC   SR@DEST,QBLANK           USE BLANK = LOCAL SEARCH DEST
*---  ANALYZE KEYWORDS                                             ---*
DO$KW$CK LA    R15,QKEYWORD             -> FIRST KEYWORD SLOT
         LA    R0,16                    ENTRY LENGTH (BXLE INCR)
         LA    R1,QKEYLAST              -> PAST LAST KEYWORD SLOT
         SPACE 1
DO$KW$LP CLI   0(R15),C' '              ANY KEYWORD HERE?
         BE    DO$KW$OK                 NO - DONE WITH KEYWORDS
         CLI   0(R15),C'W'              WANT WTRID INSTEAD OF FCB/UCS?
         BE    DO$WTRID                 YES - GO SET FLAG
         CLI   0(R15),C'F'              WANT FLASH INSTEAD OF NJE/RJE?
         BE    DO$FLASH                 YES - GO SET FLAG
         CLI   0(R15),C'T'              WANT O/P TIME INSTEAD OF CHARS?
         BE    DO$TIME                  YES - GO SET FLAG
         CLI   0(R15),C'U'              WANT userid instead of rmt?
         BE    DO$USER                  YES - GO SET FLAG
         CLI   0(R15),C'P'              WANT SPOOL pct INSTEAD OF LNES?
         BE    DO$PCT                   YES - GO SET FLAG
         CLI   0(R15),C'S'              WANT SPOOL SPC INSTEAD OF LNES?
         BE    DO$SPACE                 YES - GO SET FLAG
         CLI   0(R15),C'D'              WANT DIFFERENT DEST?
         BE    DO$DEST                  YES - GO SAVE IT
         CLI   0(R15),C'R'              WANT DIFFERENT DEST? (REMOTE)
         BE    DO$DEST                  YES - GO SAVE IT
         CLI   0(R15),C'O'              want OUTGRP?
         BE    DO$OUTG                  yes - go save it
         L     R0,=C'SR3 '              SET LOGIC ERROR CODE
         L     R15,=V(LOGICERR)         -> ROUTINE
         BALR  R14,R15                  GO TO IT (NO RETURN)
DO$WTRID OI    QSCFLAG3,QSC3WTRI        INDICATE WANT WRITER NAME
         MVC   SR@WTRID,8(R15)          SAVE WTRNAME IF ANY
         CLC   =C'ALL ',SR@WTRID        Want all and only wtrid stuff?
         BE    DO$KWNXT                 Yes - display it in "FORMAT"
         CLC   SR@WTRID,QBLANK          ANY WTRNAME SPECIFICATION?
         BE    DO$KWNXT                 NO - DO DISPLAY IT IN "FORMAT"
         XI    QSCFLAG3,QSC3WTRI        YES - NO NEED TO DISPLAY
         B     DO$KWNXT                 PROCESS NEXT KEYWORD
DO$FLASH OI    QSCFLAG3,QSC3FLSH        INDICATE WANT FORMS FLASH
         B     DO$KWNXT                 PROCESS NEXT KEYWORD
DO$TIME  OI    QSCFLAG1,QSC1TIME        INDICATE WANT OUTPUT TIME
         B     DO$KWNXT                 PROCESS NEXT KEYWORD
DO$USER  OI    QSCFLAG3,QSC3USER        INDICATE WANT userid
         B     DO$KWNXT                 PROCESS NEXT KEYWORD
DO$PCT   OI    QSCFLAG1,QSC1PCT         INDICATE WANT SPOOL percent
         B     DO$KWNXT                 PROCESS NEXT KEYWORD
DO$SPACE OI    QSCFLAG1,QSC1SPC         INDICATE WANT SPOOL SPACE
         B     DO$KWNXT                 PROCESS NEXT KEYWORD
DO$DEST  MVC   SR@DEST,8(R15)           SAVE REMOTE VALUE
DO$WC$CK LA    R14,SR@DEST+7            max len
         LA    R4,8-1                   len to scan (can't be all wild)
DO$WC$LP CLI   0(R14),C'*'              wild char?
         BE    DO$WC$GT                 yes - got one
         BCTR  R14,0                    -> prev char
         BCT   R4,DO$WC$LP              check all chars
         B     DO$KWNXT                 none - use full len
DO$WC$GT BCTR  R4,0                     -1 for ex.
         STH   R4,SR@DESTL              save len to compare
         B     DO$KWNXT                 PROCESS NEXT KEYWORD
DO$OUTG  OI    QSCFLAG3,QSC3OUTG        indicate want OUTGRP
         B     DO$KWNXT                 process next keyword
DO$KWNXT BXLE  R15,R0,DO$KW$LP
*---  DETERMINE IF DISPLAY IS ALL CLASSES, OR SPECIFIC LIST
DO$KW$OK CLI   SR@PARM1,C' '            DID USER SPECIFY CLASS?
         BNE   AO$40                    YES. LIMIT TO ONE QUEUE.
***********************************************************************
* SEARCH ALL QUEUES                                                   *
***********************************************************************
         MVI   QCLASS,C'O'              INDICATE OUTPUT QUEUES
         MVI   SR@JQCLS,0               START WITH FIRST OUTPUT CLASS
AO$20    BAL   R2,NEXTJOT               DETERMINE NEXT QUEUE
         BAL   R2,SRCHJOE               SEARCH A JOE QUEUE
         B     AO$20                    END OF QUEUE
         B     AO$70                    SEE IF WE WANT THIS JOB
***********************************************************************
* SEARCH SPECIFIC QUEUES                                              *
***********************************************************************
AO$40    MVI   QCLASS,C'O'              INDICATE OUTPUT QUEUES
         MVC   SR@JQCLS,SR@PARM1        USER SPECIFIED CLASS
         BAL   R2,FIRSTJOT              FIND QUEUE
AO$42    BAL   R2,SRCHJOE               SEARCH THE QUEUE
         B     AO$50                    END OF QUEUE
         B     AO$70                    SEE IF WE WANT THIS JOB
          AIF   (&QLEVEL GE 4).SR480
AO$50    BAL   R2,NEXT$CLS              SELECT NEXT CLASS, IF ANY
          AGO   .SR520
.SR480    ANOP
AO$50    CLI   QCLASS,C'R'              DID WE JUST SEARCH RMT QUEUE?
         BE    AO$51                    YES - DO NEXT OUTPUT CLASS
          AIF   (&QLEVEL LT 11).SR500
         CLI   QCLASS,C'U'              did we just search user queue?
         BE    AO$RMT                   yes - now do remote queue
         MVI   QCLASS,C'U'              INDICATE user OUTPUT QUEUES
         BAL   R2,NEXTJOT               ADVANCE TO user OUTPUT QUEUE
         B     AO$42                    SEARCH THE QUEUE
AO$RMT   EQU   *
.SR500    ANOP
         MVI   QCLASS,C'R'              INDICATE REMOTE OUTPUT QUEUES
         BAL   R2,NEXTJOT               ADVANCE TO REMOTE OUTPUT QUEUE
         B     AO$42                    SEARCH THE QUEUE
AO$51    BAL   R2,NEXT$CLS              SELECT NEXT CLASS, IF ANY
.SR520    ANOP
         B     AO$40                    THERE WAS A NEXT - PROCESS IT
***********************************************************************
*---  COMMON ROUTINE FOR AI/DI/AO/DO TO SELECT NEXT CLASS          ---*
***********************************************************************
NEXT$CLS MVC   SR@PARM1(L'SR@PARM1-1),SR@PARM1+1  SET UP GET NEXT CLASS
         MVI   SR@PARM1+L'SR@PARM1-1,C' ' CLEAR OPENED POSITION
         CLI   SR@PARM1,C' '            ANY MORE CLASSES GIVEN?
         BNER  R2                       YES - RETURN TO CALLER
         B     QSTOP                    NO - ALL DONE
***********************************************************************
*---  COMMON ROUTINE FOR AO/DO ALL CLASSES AND AO/DO SINGLE CLASS  ---*
***********************************************************************
AO$70    CLI   QCODE,12                 "DO"?
         BE    AO$80                    YES - SEE IF CORRECT DEST
         TM    JQEFLAGS,QUEHOLDA+QUEHOLD1+QUEHOLD2  NO ("AO") - HELD?
         BNZ   SKIPJOE                  YES - REJECT IT
*                                       NO - SEE IF CORRECT DEST
*---  SELECT ONLY JOBS FOR CORRECT WTRID, IF REQUESTED
AO$80    CLC   SR@WTRID,QBLANK          SELECT BY WTRNAME?
         BE    AO$82                    NO - SKIP
         QNEXT R15,JOECHAR,NONE=SKIPJOE OFFSET TO CHARACTERISTICS JOE
         AL    R15,QCJOTA               ADD BASE TO OFFSET
         CLC   =C'ALL ',SR@WTRID        Want all writerid output only?
         BNE   AO$81                    No - go check for correct wtrid
         CLI   JOEWTRID-JOEDSECT(R15),C' '  Yes - any wtrid?
         BE    SKIPJOE                  No - don't display this output
         B     PRTJOE                   Yes - display this one
AO$81    CLC   SR@WTRID,JOEWTRID-JOEDSECT(R15)  CORRECT WTRNAME?
         BNE   SKIPJOE                  NO - DON'T DISPLAY IT
*---  SELECT ONLY JOBS FOR THIS USER'S DEST, UNLESS HE SAID R=ALL
AO$82    CLC   =C'ALL ',SR@DEST         WANT ALL DESTS?
         BE    PRTJOE                   YES - DISPLAY THIS JOB
         LA    R1,JOEROUT               -> OUTPUT ROUTE FIELD
         QCALL FINDRJE                  CONVERT TO PRINTABLE
         LH    R15,SR@DESTL             len to compare
         CLC   0(*-*,R1),SR@DEST        IS THIS THE DEST HE WANTS?
         EX    R15,*-6                  check it all
         BE    PRTJOE                   YES - DISPLAY THIS JOB
         CLC   8(*-*,R1),SR@DEST        how about NnnnRnnn form?
         EX    R15,*-6                  check it all
         BE    PRTJOE                   yes - display this job
         CLI   SR@DEST,C' '             DOES HE WANT JOBS FOR CENTRAL?
         BNE   SKIPJOE                  NO - DON'T DISPLAY THIS JOB
*---  SEE IF THIS JOB HAS AN OUTPUT DESTINATION THAT IS EQU'D TO   ---*
*---  CENTRAL ('LOCAL')                                            ---*
         L     R15,=A(SR#LOCAL)         -> LOCAL EQUIVALENCE TABLE
AO$90    CLI   0(R15),X'FF'             END OF TABLE?
         BE    SKIPJOE                  YES - DON'T DISPLAY THIS JOB
         CLC   0(8,R15),0(R1)           THIS JOBS DEST IN TABLE?
         BE    PRTJOE                   YES - DISPLAY THIS JOB
         LA    R15,8(,R15)              -> NEXT TABLE ENTRY
         B     AO$90                    SEARCH WHOLE TABLE
***********************************************************************
*                                                                     *
*   NJ - LIST ALL JOBS IN NJE QUEUES                                  *
*                                                                     *
***********************************************************************
NJ       L     R1,QCJQHEAD              Load addr of JQT
         LA    R4,JQTRECV-JQTDSECT(,R1) Addr of $RECEIVE Queue
         MVI   QCLASS,12                Indicate this is misc Q
         BAL   R2,SRCHJQE               Search the queue
         B     NJ$10                    End of queue
         B     PRTJQE                   Print the record
NJ$10    L     R1,QCJQHEAD              Load addr of JQT
         LA    R4,JQTXMIT-JQTDSECT(,R1) Addr of $RECEIVE Queue
         MVI   QCLASS,12                Indicate this is misc Q
         BAL   R2,SRCHJQE               Search the queue
         B     QSTOP                    End of queue
         B     PRTJQE                   Print the record
***********************************************************************
*                                                                     *
*   DH - LIST ALL JOBS WITH HELD OUTPUT   (FORMERLY, "HO" SUBCMD)     *
*                                                                     *
***********************************************************************
DH       BAL   R2,SR$STUP               ANALYZE 'S','T','U','P' opernds
         LA    R1,QKEYWORD              -> FIRST KEYWORD SLOT
         LA    R14,16                   BXLE INCR
         LA    R15,QKEYLAST-16          BXLE END
DH$01    CLI   0(R1),C' '               ANY MORE KEYWORDS?
         BE    DH$02                    NO - CONTINUE
         CLI   0(R1),C'A'               DISPLAY ALL JOBS?
         BNE   *+8                      NO - SKIP
         OI    SR@FLAG,SR@FHALL         YES
         BXLE  R1,R14,DH$01             PROCESS ALL KEYWORDS
DH$02    MVI   QCLASS,8                 indicate this is the held o/p q
          AIF   (&QLEVEL GE 11).SR580
         OI    QSCFLAG1,QSC1DH          INDICATE THIS IS "DH"
         L     R1,QCJQHEAD              LOAD ADDR OF JQT
         LA    R4,JQTOUT-JQTDSECT(,R1)  ADDR OF $OUTPUT QUEUE
         BAL   R2,SRCHJQE               SEARCH THE QUEUE
         B     QSTOP                    END OF QUEUE
         TM    SR@FLAG,SR@FHALL         "ALL" KEYWORD GIVEN?
         BO    PRTJQE                   YES. PRINT THE RECORD
*---  BOTH MIKE STEIN AND JACK SCHUDEL, WHEN THEY CHANGED THIS FOR ---*
*---  SP JES2, DID IT WRONG (EACH IN THEIR OWN WAY)                ---*
          AIF  (&QLEVEL GE 11).SR560
          AIF  (&QLEVEL GE 9).SR540
         LH    R0,JQEHLDCT              GET HELD DATASET COUNT
         N     R0,=X'0000FFF0'          GET RID OF JUNK
         BNZ   PRTJQE                   PRINT THE REC IF HELD DATASETS
          AGO  .SR560
.SR540    ANOP ,
         CLC   JQEHDSCT,=F'0'           check held dataset count
         BNE   PRTJQE                   print the rec if held datasets
.SR560    ANOP ,
         B     REJJQE                   REJECT THE RECORD
          AGO   .SR600
.SR580    ANOP
         L     R1,QCJOTA                load addr of JOT
         LA    R4,JOTHOLDQ-JOTDSECT(,R1)  -> held output queue
         BAL   R2,SRCHJOE               search the queue
         B     QSTOP                 +0 end of queue
         B     PRTJOE$H              +4 print the record
.SR600    ANOP
***********************************************************************
*                                                                     *
*   DA - FIND ALL EXECUTING JOBS                                      *
*                                                                     *
***********************************************************************
DA       OI    QSCFLAG1,QSC1PGMR        REQUEST "FORMAT" TO DISP PGMR
         BAL   R2,SR$STUP               ANALYZE 'S','T','U','P' opernds
         MVI   QCLASS,C'I'              INDICATE INPUT QUEUES
         MVI   SR@JQCLS,0               START WITH FIRST INPUT CLASS
DA$20    BAL   R2,NEXTJQT               DETERMINE NEXT QUEUE
         BAL   R2,SRCHJQE               SEARCH THE QUEUE
         B     DA$20                    END OF QUEUE
         TM    JQEFLAGS,QUEBUSY         IS THE JOB EXECUTING?
         BNZ   PRTJQE                   yes - PRINT THE RECORD
         CLI   JQETYPE,$INPUT           this job on input queue?
         BE    PRTJQE                   yes - print the record
         CLI   JQETYPE,$RECEIVE         this job on receive queue?
         BE    PRTJQE                   yes - print the record
         B     REJJQE                   NO. REJECT IT.
DA$30    MVI   QCLASS,C'O'              INDICATE OUTPUT QUEUES
         MVI   SR@JQCLS,0               START WITH FIRST OUTPUT CLASS
DA$40    BAL   R2,NEXTJOT               DETERMINE NEXT QUEUE
         BAL   R2,SRCHJOE               SEARCH A JOE QUEUE
         B     DA$40                    END OF QUEUE
         TM    JOEFLAG,$JOEBUSY         IS THE JOB EXECUTING?
         BZ    SKIPJOE                  NO. REJECT IT.
         B     PRTJOE                   PRINT THE RECORD
***********************************************************************
*                                                                     *
*   DS - LIST ALL SYSTEM STARTED TASKS                                *
*                                                                     *
***********************************************************************
DS       OI    QSCFLAG1,QSC1PGMR        REQUEST "FORMAT" TO DISP PGMR
         BAL   R2,SR$STUP               ANALYZE 'S','T','U','P' opernds
         L     R1,QCJQHEAD              LOAD ADDR OF JQT
         LA    R4,JQTSTC-JQTDSECT(,R1)  ADDR OF STC QUEUE
         MVI   QCLASS,4                 INDICATE THIS IS THE STC QUEUE
         BAL   R2,SRCHJQE               SEARCH THE QUEUE
         B     QSTOP                    END OF QUEUE
         B     PRTJQE                   PRINT THE RECORD
***********************************************************************
*                                                                     *
*   DT - LIST ALL TSO USERS                                           *
*                                                                     *
***********************************************************************
DT       OI    QSCFLAG1,QSC1PGMR        REQUEST "FORMAT" TO DISP PGMR
         BAL   R2,SR$STUP               ANALYZE 'S','T','U','P' opernds
         L     R1,QCJQHEAD              LOAD ADDR OF JQT
         LA    R4,JQTTSU-JQTDSECT(,R1)  ADDR OF TSO QUEUE
         MVI   QCLASS,0                 INDICATE THIS IS THE TSO Q
         BAL   R2,SRCHJQE               SEARCH THE QUEUE
         B     QSTOP                    END OF QUEUE
         B     PRTJQE                   PRINT THE RECORD
***********************************************************************
*                                                                     *
*   ANALYZE 'S', 'T', 'U', and 'P' OPERANDS                           *
*                                                                     *
***********************************************************************
SR$STUP  LA    R1,QKEYWORD              -> FIRST KEYWORD SLOT
         LA    R14,16                   BXLE INCR
         LA    R15,QKEYLAST-16          BXLE END
SR$S$T$1 CLI   0(R1),C'T'               DISPLAY TIME?
         BNE   *+8                      NO - SKIP
         OI    QSCFLAG1,QSC1TIME        YES - SET FLAG FOR "FORMAT"
         CLI   0(R1),C'U'               DISPLAY userid?
         BNE   *+8                      NO - SKIP
         OI    QSCFLAG3,QSC3USER        YES - SET FLAG FOR "FORMAT"
         CLI   0(R1),C'P'               DISPLAY percent?
         BNE   *+8                      NO - SKIP
         OI    QSCFLAG1,QSC1PCT         YES - SET FLAG FOR "FORMAT"
         CLI   0(R1),C'S'               DISPLAY SPACE?
         BNE   *+8                      NO - SKIP
         OI    QSCFLAG1,QSC1SPC         YES - SET FLAG FOR "FORMAT"
         CLI   0(R1),C'O'               want OUTGRP?
         BNE   *+8                      No - skip
         OI    QSCFLAG3,QSC3OUTG        indicate want OUTGRP
         BXLE  R1,R14,SR$S$T$1          PROCESS ALL KEYWORDS
         BR    R2                       RETURN TO CALLER
***********************************************************************
*                                                                     *
*   SEARCH A JQE QUEUE                                                *
*                                                                     *
***********************************************************************
SRCHJQE  ZAP   QCOUNT,=P'0'             ZERO THE QUEUE COUNT
         L     R8,=X'F0000000'          INVALIDATE JOE PTR
         QNEXT R9,0(,R4)                LOAD FIRST JQE OFFSET
NEXTJQE  BZR   R2                       END OF QUEUE. RETURN.
         A     R9,QCJQTA                ADD BASE TO OFFSET
         TM    QSCFLAG2,QSC2DI          IS THIS DI/AI/HI?
         BZ    4(,R2)                   NO - DETERMINE ELIGIBILITY
         TM    SR@FLAG,SR@FAFF          SYSAFF SELECTION DESIRED?
         BZ    4(,R2)                   NO - DETERMINE ELIGIBILITY
         MVC   SR@BYTE,JQEFLAG2         COPY JOB'S AFFINITY
         NI    SR@BYTE,QUESYSAF         ISOLATE SYSAFF BITS
         TM    SR@FLAG,SR@FIND          WANT INDEPENDENT MODE JOBS?
         BNO   *+12     >==========+    NO - SKIP IND CHECK
         TM    JQEFLAG2,QUEINDAF   |    YES - IS JOB INDEPENDENT MODE?
         BNO   SKIPJQE             |    NO - SKIP IT
         CLI   SR@AFF,0   <========+    ANY NON-IND AFFINITY SPECIFIED?
         BZ    4(,R2)                   NO - DETERMINE ELIGIBILITY
         NC    SR@BYTE,SR@AFF           COMPARE DESIRED WITH ACTUAL
         BNZ   4(,R2)                   OK - DETERMINE ELIGIBILITY
         B     SKIPJQE                  NONE OF THOSE SELECTED - SKIP
         SPACE 3
PRTJQE   AP    QCOUNT,=P'1'             INCREMENT COUNT
         SR    R1,R1                    INDICATE THIS IS A JQE
         QCALL FORMAT                   PRINT THE JQE IN R9
         B     REJJQE                   CONTINUE
SKIPJQE  AP    QCOUNT,=P'1'             INCREMENT COUNT
REJJQE   L     R8,=X'F0000000'          INVALIDATE JOE PTR
         QNEXT R9,JQENEXT               LOAD OFFSET TO NEXT JQE
         B     NEXTJQE                  GET THE NEXT JQE
***********************************************************************
*                                                                     *
*   SEARCH A JOE QUEUE                                                *
*                                                                     *
***********************************************************************
SRCHJOE  ZAP   QCOUNT,=P'0'             ZERO THE QUEUE COUNT
FIRSTJOE QNEXT R8,0(,R4)                LOAD FIRST JOE OFFSET
         BZR   R2                       RETURN TO CALLER IF QUEUE EMPTY
         XC    SR@PRTY(12),SR@PRTY      ZERO OUT HIGHEST POINTERS
NEXTJOE  A     R8,QCJOTA                ADD BASE TO OFFSET
         QNEXT R9,JOEJQE                OFFSET TO JQE
         BZ    TRYJOE                   THIS JOE ALREADY USED. TRY NEXT
         A     R9,QCJQTA                ADD BASE TO OFFSET
          AIF   (&QLEVEL GT 4).SR620
         LA    R7,255                   PRESET MAXIMUM PRIORITY
         TM    JQEPRIO,240              IS THIS JOB PRIORITY 15?
         BO    HIGHJOE                  YES. PASS TO CALLER.
         LA    R1,16                    PRESET PRIORITY ONE
         CLI   JQETYPE,$HARDCPY         IS THE JOB EXECUTING?
         BNE   *+8                      YES. USE PRIORITY ONE.
         IC    R1,JQEPRIO               INSERT JQE PRIORITY
         IC    R7,JOEPRIO               INSERT JOE PRIORITY
         AR    R7,R1                    ADD PRIORITIES
         SRL   R7,1                     'CUZ HASP DOES IT, THAT'S WHY
          AGO   .SR640
.SR620    ANOP
         LH    R7,JOEPRIO               GET NEW FORMAT JOE PRIORITY
*??????? SRL   R7,4                     JUSTIFY IT CORRECTLY
.SR640    ANOP
HIGHJOE  C     R7,SR@PRTY               THIS LESS THAN PREVIOUS HIGH?
         BL    TRYJOE                   YES. TRY NEXT ONE.
         STM   R7,R9,SR@PRTY            NO. REPLACE PREVIOUS HIGH.
TRYJOE   QNEXT R8,JOENEXT               ADDR OF NEXT JOE
         BNZ   NEXTJOE                  TRY NEXT JOE
*---  END OF QUEUE.  PASS HIGHEST TO CALLER                        ---*
         LM    R7,R9,SR@PRTY            LOAD ADDR OF HIGHEST JOE
         LTR   R8,R8                    WAS THE QUEUE EMPTY?
         BZR   R2                       YES. END OF QUEUE.
          AIF   (&QLEVEL GE 4).SR660
         MVC   JOEJQE,=H'0'             INDICATE THIS JOE USED
          AGO   .SR680
.SR660    ANOP
         MVC   JOEJQEB,=FL3'0'          INDICATE THIS JOE USED
.SR680    ANOP
         B     4(,R2)                   DETERMINE ELIGIBILITY
          AIF   (&QLEVEL LT 11).SR700
PRTJOE$H MVC   QCLSNAME(1),JOECURCL     set held o/p class name ...
         MVI   QCLSNAME+1,C' '          ... for 'FORMAT'
.SR700    ANOP
PRTJOE   LA    R1,4                     INDICATE THIS IS A JOE
         AP    QCOUNT,=P'1'             INCREMENT COUNT
         QCALL FORMAT                   PRINT THE JOE IN R9
         B     FIRSTJOE                 GET THE NEXT JOE
SKIPJOE  AP    QCOUNT,=P'1'             INCREMENT COUNT
         B     FIRSTJOE                 CONTINUE
***********************************************************************
*                                                                     *
*   DETERMINE INPUT QUEUE                                             *
*                                                                     *
***********************************************************************
FIRSTJQT IC    R15,SR@JQCLS             SAVE CLASS NAME IN CASE INVALID
         TR    SR@JQCLS,CLASSTBL        DETERMINE CLASS NUMBER
         LH    R4,SR@JQNUM              PICK IT UP
         CLI   SR@JQCLS,X'FF'           INVALID CLASS SPECIFIED?
         BNE   NEXTJQT1                 NO - CONTINUE
BADCLASS MVC   QERRMSG(25),=C'*** CLASS ''?'' INVALID ***'
         STC   R15,QERRMSG+11           FILL IN INVALID CLASS NAME
         QTILT *,OPTIONS=REPROMPT
NEXTJQT  LH    R4,SR@JQNUM              LOAD CLASS NUMBER
         CH    R4,=H'36'                IS THIS THE LAST CLASS?
         BNL   NEXTJQT9                 YES. GO HOME.
         LA    R4,1(,R4)                INCREMENT TO NEXT CLASS
         STH   R4,SR@JQNUM              SAVE NEW CLASS NUMBER
         BCTR  R4,0                     MAKE IT ORIGIN 0
NEXTJQT1 LA    R1,NAMETBL(R4)           -> PRINTABLE CLASS
         MVC   QCLSNAME(1),0(R1)        AND CREATE DISPLAYABLE ...
         MVI   QCLSNAME+1,C' '          ... CLASS NAME
         MH    R4,=Y($JQHEADL)          MULTIPLY BY LENGTH OF Q HEADER
         L     R1,QCJQHEAD              LOAD ADDR OF JQT
         LA    R4,JQTCLSA-JQTDSECT(R4,R1)  NEXT QUEUE
         BR    R2                       RETURN TO CALLER
*%%% SOMEDAY, AFTER WE SUPPORT VARIABLE SIZE LOCAL WORKAREAS, CHANGE
*%%% THE FOLLOWING KLUDGE TO USE A STORED RETURN ADDR
NEXTJQT9 CLI   QCODE,0                  IS THIS A STATUS REQUEST?
         BE    ST$50                    YES. GO TO STATUS.
         CLI   QCODE,36                 IS THIS A DJ REQUEST?
         BE    ST$50                    YES. GO TO STATUS.
         CLI   QCODE,44                 IS THIS DQ?
         BE    DQI$90                   YES - RETURN TO HIM
         CLI   QCODE,48                 IS THIS DEV?
         BE    ST$50                    YES - RETURN TO HIM
         CLI   QCODE,52                 IS THIS DN?
         BE    ST$50                    YES - RETURN TO HIM
         CLI   QCODE,4                  IS THIS DA?
         BE    DA$30                    YES - RETURN TO HIM
         B     QSTOP                    NO. GO HOME.
***********************************************************************
*                                                                     *
*   DETERMINE OUTPUT QUEUE                                            *
*                                                                     *
***********************************************************************
FIRSTJOT IC    R15,SR@JQCLS             SAVE CLASS NAME IN CASE INVALID
         TR    SR@JQCLS,CLASSTBL        DETERMINE CLASS NUMBER
         LH    R4,SR@JQNUM              PICK IT UP
         MH    R4,=Y(JOT@OQN)           account for queues per class
         LA    R4,JOT@XQN(,R4)          account for dump & network q's
         CLI   SR@JQCLS,X'FF'           INVALID CLASS SPECIFIED?
         BNE   NEXTJOT1                 NO - PROCESS
         B     BADCLASS                 YES - GIVE ERROR MESSAGE
NEXTJOT  LH    R4,SR@JQNUM              LOAD CLASS NUMBER
         CH    R4,=Y(JOT@XQN+36*JOT@OQN)  IS THIS THE LAST QUEUE?
         BNL   NEXTJOT9                 YES - END LOOP
NEXTJOT1 LA    R0,1(,R4)                INCREMENT
         STH   R0,SR@JQNUM              SAVE UPDATED VALUE
          AIF   (&QLEVEL GE 4).SR720
         LA    R1,NAMETBL(R4)           -> PRINTABLE CLASS NAME
         MVC   QCLSNAME(1),0(R1)        SET FOR 'FORMAT'
         MVI   QCLSNAME+1,C' '          ...
         MH    R4,=Y($JQHEADL)          MULTIPLY BY LENGTH OF Q HEADER
         L     R1,QCJOTA                LOAD ADDR OF JOT
         LA    R4,JOTCLSQ-JOTDSECT(R4,R1)  NEXT QUEUE
          AGO   .SR740
.SR720    ANOP
         LR    R1,R4                    get relative queue number
         AR    R1,R1                    output class names are 2 char
         LA    R1,OUTCLASS(R1)          -> PRINTABLE CLASS NAME
         MVC   QCLSNAME,0(R1)           SET FOR 'FORMAT'
         MH    R4,=Y($JQHEADL)          MULTIPLY BY LENGTH OF Q HEADER
         L     R1,QCJOTA                LOAD ADDR OF JOT
         LA    R4,JOTRDYWQ-JOTDSECT(R4,R1)  NEXT QUEUE
.SR740    ANOP
         BR    R2                       RETURN TO CALLER
NEXTJOT9 CLI   QCODE,44                 IS THIS DQ?
         BE    DQO$DONE                 YES - SHOW SPOOL UTILIZATION
         B     QSTOP                    NO - GO HOME.
***********************************************************************
*                                                                     *
*   TABLES FOR CLASS DETERMINATION                                    *
*                                                                     *
***********************************************************************
NAMETBL  DC    C'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
          AIF   (&QLEVEL GT 6).SR760
          AIF   (&QLEVEL LT 4).SR820
OUTCLASS DC    C'DP'                    DUMP QUEUE
         DC    C'NT'                    NETWORK QUEUE
          AGO   .SR780
.SR760    ANOP
OUTCLASS DC    C'NT'                    NETWORK QUEUE
.SR780    ANOP
*---  DISPLAY '>' AFTER CLASSNAME IF REMOTE OUTPUT QUEUE           ---*
*---  IDEA COURTESY OF MIKE STEIN                                  ---*
          AIF   (&QLEVEL GE 11).SR800
         DC    C'A A>'                  LOCAL A, REMOTE A
         DC    C'B B>C C>D D>E E>F F>G G>H H>I I>J J>K K>L L>M M>N N>'
         DC    C'O O>P P>Q Q>R R>S S>T T>U U>V V>W W>X X>Y Y>Z Z>'
         DC    C'0 0>1 1>2 2>3 3>4 4>5 5>6 6>7 7>8 8>9 9>'
          AGO   .SR820
.SR800    ANOP
*---  DISPLAY '<' AFTER CLASSNAME IF user OUTPUT QUEUE             ---*
         DC    C'A A<A>'                LOCAL A, user A, REMOTE A
         DC    C'B B<B>C C<C>D D<D>E E<E>F F<F>G G<G>H H<H>I I<I>'
         DC    C'J J<J>K K<K>L L<L>M M<M>N N<N>O O<O>P P<P>Q Q<Q>'
         DC    C'R R<R>S S<S>T T<T>U U<U>V V<V>W W<W>X X<X>Y Y<Y>'
         DC    C'Z Z<Z>0 0<0>1 1<1>2 2<2>3 3<3>4 4<4>5 5<5>6 6<6>'
         DC    C'7 7<7>8 8<8>9 9<9>'
.SR820    ANOP
CLASSTBL DC    256X'FF'
         ORG   CLASSTBL+C'A'
         DC    AL1(00,01,02,03,04,05,06,07,08)
         ORG   CLASSTBL+C'J'
         DC    AL1(09,10,11,12,13,14,15,16,17)
         ORG   CLASSTBL+C'S'
         DC    AL1(18,19,20,21,22,23,24,25)
         ORG   CLASSTBL+C'0'
         DC    AL1(26,27,28,29,30,31,32,33,34,35)
         ORG   ,
***********************************************************************
*                                                                     *
*   MISCELLANEOUS GARBAGE                                             *
*                                                                     *
***********************************************************************
SR#ACFID DC    B'11100000',B'00000001',C'ACF2'  TYPE, MOD, ID
         SPACE 2
SR#MISC  DC    CL9'Purge'
SR#HOUT  DC    CL9'Held-Out'            $HARDCPY
         DC    CL9'Await-Out'           $OUTPUT
          AIF   (&QLEVEL GT 6).SRMISC1
          AIF   (&QLEVEL LT 4).SRMISC1
         DC    CL9'$DUMPQ'
.SRMISC1  ANOP
         DC    CL9'$RECEIVE'
         DC    CL9'$SETUP'
         DC    CL9'$XMIT'
         DC    CL9'Reading'             $INPUT
         DC    CL9'Converter'           $XEQ
          AIF   (&QLEVEL GE 4).SRMISC2
         DC    CL9'$DUMMY'
.SRMISC2  ANOP
         DC    CL9'SYS Tasks'
         DC    CL9'TSO Users'
         SPACE 2
PERCENT  DC    X'40202021204B20',C'%'
         DC    X'1D60'                  OUTPUT, NORMAL
         DC    C'Spool Utilization'
PERCENTL EQU   *-PERCENT
         SPACE 2
         LTORG
         SPACE 2
         ENTRY DA#KEYS,DI#KEYS,DO#KEYS,DH#KEYS,ST#KEYS,DN#KEYS,DJ#KEYS
         SPACE 1
DA#KEYS  DC    CL8'T       ',CL8'TIME    '
          AIF   ('&@@QJOWN' EQ '').SRKEY1  USER not available
         DC    CL8'U       ',CL8'USER    ',CL8'USERID  '
.SRKEY1   ANOP
         DC    CL8'P       ',CL8'PERCENT ',CL8'PCT     '
         DC    CL8'S       ',CL8'SPACE   ',CL8'SIZE    '
         DC    X'FF'                    END OF TABLE INDICATOR
         SPACE 1
DI#KEYS  DC    CL8'T       ',CL8'TIME    '
          AIF   ('&@@QJOWN' EQ '').SRKEY2  USER not available
         DC    CL8'U       ',CL8'USER    ',CL8'USERID  '
.SRKEY2   ANOP
         DC    CL8'P       ',CL8'PERCENT ',CL8'PCT     '
         DC    CL8'SIZE    ',CL8'SPACE   '
         DC    CL8'S       ',CL8'SYSAFF  '
         DC    X'FF'                    END OF TABLE INDICATOR
         SPACE 1
DO#KEYS  DC    CL8'T       ',CL8'TIME    '
          AIF   ('&@@QJOWN' EQ '').SRKEY3  USER not available
         DC    CL8'U       ',CL8'USER    ',CL8'USERID  '
.SRKEY3   ANOP
         DC    CL8'P       ',CL8'PERCENT ',CL8'PCT     '
         DC    CL8'S       ',CL8'SPACE   ',CL8'SIZE    '
         DC    CL8'R       ',CL8'RMT     ',CL8'REMOTE  '
         DC    CL8'D       ',CL8'DEST    '
         DC    CL8'F       ',CL8'FLASH   '
         DC    CL8'W       ',CL8'WTRNAME '
         DC    CL8'O       ',CL8'OUT     '
         DC    X'FF'                    END OF TABLE INDICATOR
         SPACE 1
DH#KEYS  DC    CL8'T       ',CL8'TIME    '
          AIF   ('&@@QJOWN' EQ '').SRKEY4  USER not available
         DC    CL8'U       ',CL8'USER    ',CL8'USERID  '
.SRKEY4   ANOP
         DC    CL8'P       ',CL8'PERCENT ',CL8'PCT     '
         DC    CL8'S       ',CL8'SPACE   ',CL8'SIZE    '
         DC    CL8'A       ',CL8'ALL     '
         DC    X'FF'                    END OF TABLE INDICATOR
         SPACE 1
DN#KEYS  DC    CL8'T       ',CL8'TIME    '
          AIF   ('&@@QJOWN' EQ '').SRKEY5  USER not available
.SRKEY5   ANOP
         DC    CL8'U       ',CL8'USER    ',CL8'USERID  '
         DC    CL8'P       ',CL8'PERCENT ',CL8'PCT     '
         DC    CL8'S       ',CL8'SPACE   ',CL8'SIZE    '
         DC    CL8'O       ',CL8'OUT     '
         DC    X'FF'                    END OF TABLE INDICATOR
         SPACE 1
ST#KEYS  DC    CL8'T       ',CL8'TIME    '
          AIF   ('&@@QJOWN' EQ '').SRKEY6  USER not available
         DC    CL8'U       ',CL8'USER    ',CL8'USERID  '
.SRKEY6   ANOP
         DC    CL8'P       ',CL8'PERCENT ',CL8'PCT     '
         DC    CL8'S       ',CL8'SPACE   ',CL8'SIZE    '
         DC    CL8'A       ',CL8'ALL     '
         DC    CL8'O       ',CL8'OUT     '
         DC    X'FF'                    END OF TABLE INDICATOR
         SPACE 1
DJ#KEYS  DC    CL8'T       ',CL8'TIME    '
          AIF   ('&@@QJOWN' EQ '').SRKEY7  USER not available
         DC    CL8'U       ',CL8'USER    ',CL8'USERID  '
.SRKEY7   ANOP
         DC    CL8'S       ',CL8'SPACE   ',CL8'SIZE    '
         DC    CL8'P       ',CL8'PERCENT ',CL8'PCT     '
         DC    CL8'O       ',CL8'OUT     '
         DC    X'FF'                    END OF TABLE INDICATOR
         SPACE 2
SR#LOCAL DS    0CL8                     LOCAL ROUTE EQUIVALENCE TABLE
         @GLOBALC  QUEUE,LCLEQ
         DC    X'FF'                    END OF TABLE INDICATOR
         SPACE 2
WORK     DSECT
         ORG   WORK+72                  SKIP OVER SAVE AREA
SR@PARM1 DS    CL8
SR@DEST  DS    CL8
SR@WTRID DS    CL8
SR@LINES DS    F                        GRAND TOTAL LINES
SR@DESTL DS    H                        len -1 to compare dest for
SR@GRAND DS    PL3                      TOTAL NUMBER OF JOBS IN QUEUES
SR@TEXEC DS    PL3                      TOTAL NUMBER OF JOBS EXEC
SR@TWAIT DS    PL3                      TOTAL NBR OF JOBS WAITING
SR@THELD DS    PL3                      TOTAL NUMBER OF JOBS HELD
*   FIELD QCOUNT IN QCOMMON IS USED FOR TOTAL NUMBER OF JOBS / THIS Q
SR@EXEC  DS    PL3                      NUMBER OF JOBS EXEC / THIS Q
SR@WAIT  DS    PL3                      NBR OF JOBS WAITING / THIS Q
SR@HELD  DS    PL3                      NUMBER OF JOBS HELD / THIS Q
SR@AFF   DS    B                        AFFINITY MASK
SR@FLAG  DS    B
SR@FHALL EQU   X'80'                    'ALL' OPERAND GIVEN ON "DH"
SR@FALLJ EQU   X'40'                    'ALL' OPERAND GIVEN ON "ST"
SR@FAFF  EQU   X'20'                    SYSAFF= OPERAND ON DI/AI/HI
SR@FIND  EQU   X'10'                    SYSAFF=IND SPECIFIED
SR@FAI   EQU   X'02'                    SUBCOMMAND IS "AI"
SR@FHI   EQU   X'01'                    SUBCOMMAND IS "HI"
SR@JQNUM DS    0H,X                     CURRENT CLASS NUMBER
SR@JQCLS DS    C                        USER SUPPLIED CLASS NAME
SR@WORKL EQU   *-WORK
SR@PRTY  DS    3F
SR@JOBNM DS    CL8                      work area to upper case jobname
SR@BYTE  DS    B
         SPACE 3
         DROPX R10,R9,R8,R13
         SPACE 3
         QCOMMON
         ORG   QDMSG
SR@ATTR  DS    XL2
         DS    C
CLSTYPE  DS    CL6
         DS    CL2
CLASS    DS    CL2
         DS    CL4
FTCOUNT  DS    CL6
         DS    CL11
QECOUNT  DS    CL4
         DS    CL10
QACOUNT  DS    CL4
         DS    CL8
QHCOUNT  DS    CL4
         DS    CL4
QTLINES  DS    CL12
         SPACE 3
         Q$JQE
         Q$JOE
         Q$JOT
         Q$JQT
         Q$SVT
         Q$HCCT
         Q$HCT
         Q$JCT
         Q$NHD
         QZACFJCB
         QZACFNJB  ,                    GEN ACFNJBLK
         QZACVALD  ,                    GEN ACVALD
         QZSSCT
