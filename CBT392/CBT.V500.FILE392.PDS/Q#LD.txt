         TITLE '--- QUEUE--LISTDS -- LIST A DS FROM THE SPOOL PACK ---'
         LCLB  &LD#DBG                  %%%
&LD#DBG  SETB  0                        %%%
*---------------------------------------------------------------------*
*                                                                     *
*   LISTDS - Display selected dataset from job on spool               *
*                                                                     *
*   Entry - Dsid in "QPDSID"                                          *
*                                                                     *
*   Updates:                                                          *
*      29Sep91  LDW  Yet another try to fix NS over empty datasets    *
*                       in ISPF mode                                  *
*      22Sep91  LDW  Change BRIF to use recfm=V/VA/VM instead of U    *
*                    Kludge BRIF for lrecl=0                          *
*                    Always pass CC to BRIF so user can control it    *
*                       via DISPLAY CC/NOCC browse command            *
*                    Add second base register (sigh)                  *
*      29Jun91  LDW  Fix bug in handling of empty dataset under       *
*                       ISPF V3R2                                     *
*      26May91  LDW  Rewrite ISPF header line rebuild logic           *
*      15Mar91  LDW  Handle subcommands for BRIF under ISPF V3R2      *
*                       (QQ xxx is no longer required)                *
*                    Display page and line number under BRIF          *
*      12Mar91  LDW  Fix length allowed for VCOPY of ZPARM            *
*      11Feb91  LDW  Move some ISPF data from QCOMMON to local area   *
*                    Specify custom panel on BRIF invocation          *
*                    Use local buffer instead of GETMAIN              *
*      05Feb91  LDW  If running under ISPF 3.2, at EOF in read        *
*                       routine, instead of rc=8, set rc=4 to         *
*                       indicate "temporary EOF"                      *
*                    Add jobid to BRIF header line                    *
*                    Simplify logic above LD$NOCC                     *
*      01Feb91  LDW  Since we now run all AMODE31, remove mode        *
*                       switching in ISPF interface code GLA          *
*                    Integrate GLA fixes below:                       *
*     (15Jan91) GLA  Correct setting of QCLRECL under ISPF            *
*     (21Sep90) GLA  Change access to TFD for addressability          *
*     (02Aug90) GLA  Fix loop in LISTDS on purged job                 *
*     (24Jan90) GLA  Fix handleing of Q cmd from BROWSE               *
*     (15Nov89) GLA  Add support for VERB TABLE variable              *
*     (20Sep89) GLA  Fix BROWSE header line                           *
*     (05Jul89) GLA  Flip out of model 5 mode on empty dataset        *
*                    If ISPF browsing open but empty ds, give msg     *
*     (16Jun89) GLA  Fix multiple max support for BROWSE              *
*     (29Mar89) GLA  Implement ISPF BROWSE support                    *
*      18Mar90  LDW  Make it so that NIP msgs pass the format check   *
*      10Mar90  LDW  Correct the check for continuation & MLWTO lines *
*                       in SYSLOG                                     *
*      31Dec89  LDW  Add square brackets to translate table (CHARTAB) *
*      23Nov89  LDW  Remove unneeded Q$IOT, Q$JCT                     *
*      05Apr88  EMS  Update for bi-modal syslog (370/XA 2.2.0)        *
*                    Update FT command for XA syslog                  *
*      03Apr88  LDW  Fix misc bugs in 20Feb88 Update                  *
*      20Feb88  LDW  Implement field selection for SYSLOG             *
*       9Aug87  EMS  Fix FA command w/mode FANUM                      *
*                    Change layout of heading line per LDW            *
*                    add "PAGE" command                               *
*      16Jul87  EMS  Fix for ***end of data*** on top line            *
*                    Add stepname/ddname to title                     *
*                    Update for GETPDDB routine                       *
*      21May87  EMS  Update for JESNEWS (1.3.4)                       *
*                    Use Getrec routine                               *
*                    Change title to include page no/line             *
*      21Mar87  LDW  Fix for DSID = 0 (from RSCS)                     *
*      03/31/86 LDW  RE-DESIGN 3278-5 SUPPORT (THIRD TRY!)            *
*      08/09/84 LDW  UPDATE FOR SP134 (USE IOTPDDB INSTEAD OF         *
*                       QCPDDB1)                                      *
*      07/16/84 LDW  IF SEARCH UNSUCCESSFUL, SAY SO, RATHER THAN      *
*                       JUST 'END OF DATA'                            *
*      04/11/84 LDW  JCTDSECT -> JCTSTART, IOTDSECT -> IOTSTART       *
*                    USING/DROP -> USNGX/DROPX                        *
*      01/23/84 LDW  FIX MORE BUGS IN "MODE PAGE" (SOMEDAY...)        *
*      07/05/83 LDW  FIX TO SAY "DATASET IS EMPTY" INSTEAD OF "DSID   *
*                       NOT FOUND" IF PDB1NULL IS SET                 *
*                    SHOW DSID IN "DATASET IS EMPTY" MSG              *
*      05/12/83 LDW  CHECK FOR PDB1NULL AND IGNORE PDDB               *
*      03/02/83 LDW  CHANGE 'QTILT *' TO USE QERRMSG                  *
*      01/19/83 LDW  SET AND USE QTPAGEX, QTHALFX                     *
*      01/03/83 LDW  SET Q2LISTDS                                     *
*                    DON'T CHANGE SCREEN SIZE IF ALREADY CORRECT      *
*                    ADD WORKLEN=                                     *
*      12/20/82 LDW  CHANGE QTILT REPRMPT=YES TO OPTIONS=REPROMPT     *
*      12/08/82 LDW  USE $LRC DSECT                                   *
*      10/28/82 LDW  FIX A LOT OF THE BUGS IN "MODE PAGE"             *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 3
LISTDS   QSTART  Q15,WORKLEN=LD@WORKL
         USNGX WORK,R13                 BASE REG FOR LOCAL WORK
         LA    R9,4095(,R12)            setup second ...
         LA    R9,1(,R9)                ... base register
         USNGX LISTDS+4096,R9           sigh
         MVI   LD@FLAGS,0               INITIALIZE FLAGS
         OI    QFLAG2,Q2LISTDS          TELL THE WORLD WHERE WE ARE
         OI    QSCFLAG1,QSC1JOB         PUT THE JOBID IN QDTOP
         QCALL DISP132                  CHANGE TO WIDE SCREEN (MAYBE)
          AGO   .LDJUNK1                %%%%%
         MVC   QDHLINE(L'LDHMLINE),LDHMLINE  MOVE IN HEADER LINE
         OI    QFLAG1,Q1MVHDR           REQUEST "MOVE HEADER"
         MVC   LDHDSID,QDHDSID          AND FILL IN DSID
         LH    R1,QPOFFSET              GET CURRENT COLUMN NUMBER
         LA    R1,1(,R1)                IT'S ORIGIN 0
         CVD   R1,QNUMWORK
         OI    QNUMWORK+7,X'0F'         REMOVE SIGN
         UNPK  LDHCOL,QNUMWORK          PUT COLUMN NUMBER IN HEADER
.LDJUNK1  ANOP                          %%%%%
***********************************************************************
*                                                                     *
*   DETERMINE FUNCTION REQUESTED                                      *
*                                                                     *
***********************************************************************
         CLI   QCODE,0                  IS REQUEST FOR REPOSITIONING?
         BNE   LD$REPOS                 YES. DO IT.
***********************************************************************
*                                                                     *
*   LOCATE PDDB FOR DATASET SPECIFIED IN QPDSID                       *
*                                                                     *
***********************************************************************
         MVI   QGPFLAG,QPFDIR           req specific dsid
         QCALL GETPDDB                  get req pddb
         LTR   R2,R1                    copy to correct reg
         BL    LD$EMPTY                 if null
         USNGX PDBDSECT,R2              BASE REG FOR PDDB
LD$FOUND MVC   QCRECFM,PDBRECFM         RECORD FORMAT FOR SAVE
         MVC   QCLRECL,PDBLRECL         RECORD LENGTH FOR SAVE
         MVI   QDLINECT,0               init to zero
          AIF   (&QLEVEL LT 5).LD010
         TM    PDBFLAG3,PDBLNCTF        valid linect?
         BZ    *+10                     no, skip update
         MVC   QDLINECT,PDBLINCT        set line count
         MVC   QSTEPNAM,PDBSNAME        set stepname
         MVC   QDDNAME,PDBDDNAM         and ddname
.LD010    ANOP ,
*        L     R4,QCSTART               BEGINNING OF DISK ADDR TABLE
*        MVC   0(4,R4),PDBMTTR
*        ZAP   QCHREC,=P'0'             ZERO HIGH REC NO
*        MVC   QCHPTR,QCSTART           BEGIN OF TBL
         MVI   QCRFLAG,QRFINIT          request initialization
         MVC   QCGRMTTR,PDBMTTR         set starting mttr
         DROPX R2                       PDBDSECT
         TM    QISFLAG1,QIS1ISPF        are we in ISPF?
         BZ    LD$FIRST                 process dataset
***********************************************************************
*                                                                     *
*        Read the first data block to insure that dataset is not      *
*        empty                                                        *
*                                                                     *
***********************************************************************
         SR    R4,R4                    tell GETREC to read first rec
         QCALL GETREC                   get
         TM    QCRFLAG,QRFERR+QRFEOF    error reading blk, or eof?
         BNZ   LD$EMPTY                 yes - say it's empty %%%%%%%%
*%%??    LTR   R4,R4                    is the disk addr zero?
*%%??    BZ    LD$EMPTY                 yes - it's empty
***********************************************************************
*                                                                     *
*        SETUP ISPF/PDF BROWSE INTERFACE                              *
*                                                                     *
***********************************************************************
*
**       SETUP FIRST ENTRY IN TABLE
*
         ST    R13,BRWSAVE              SAVE CURRENT SAVEAREA PTR
         ST    R4,0(,R2)                SAVE TTR OF FIRST BLOCK
         MVC   4(4,R2),QCCREC           RECORD NUMBER IN BLOCK
         L     R15,ISPLNK               CALL ISPF INTERFACE
         CALL  (15),(=C'VREPLACE',=C'(QQACT) ',=F'26',                 $
               =CL26'SELECT CMD(%QCQQ         )'),                     $
               VL,MF=(E,LD@CALLP)
*
**       SEE IF WE CAN USE IBM DEFINED INTERFACE
*
         TM    QISFLAG1,QIS1V23         ARE WE V2.3 OR HIGHER?
         BZ    QISPF22                  NO - USE KULTZY DCB IFACE
***********************************************************************
*                                                                     *
**       ISPF V2.3 OR HIGHER - BRIF INTERFACE                         *
*                                                                     *
***********************************************************************
*
**       FORMAT HEADER TO IDENTIFY FILE
*
         MVC   BRWHDR,QBLANK
         MVC   BRWHDR(8),QJOBNAME       move in jobname
         LA    R15,BRWHDR+7             -> last char
LD$ISLP1 CLI   0(R15),C' '              blank?
         BNE   *+8                      no, done
         BCT   R15,LD$ISLP1             yes, try prev
         MVI   1(R15),C'('              delimeter
         MVC   2(8,R15),QEXTJBID        move in jobid
         OC    5(5,R15),=C'00000'       convert blanks to zeroes
         MVI   10(R15),C')'             delimiter
         MVI   11(R15),C'/'             delimeter
         LA    R15,12(,R15)             -> last char
***      MVI   1(R15),C'/'              delimeter
***      LA    R15,2(,R15)              -> last char
          AIF   (&QLEVEL LT 5).LD020
         MVC   0(8,R15),QSTEPNAM        set stepname
         LA    R15,7(,R15)              -> last char
*
LD$ISLP2 CLI   0(R15),C' '              blank?
         BNE   *+8                      no, done
         BCT   R15,LD$ISLP2             yes, try prev
         MVI   1(R15),C'/'              delimeter
         MVC   2(8,R15),QDDNAME         and ddname
         LA    R15,2+7(,R15)            -> last char
*
LD$ISLP3 CLI   0(R15),C' '              blank?
         BNE   *+8                      no, done
         BCT   R15,LD$ISLP3             yes, try prev
         LA    R15,1(,R15)              bump
*
.LD020    ANOP ,
         MVI   0(R15),C'('              delimeter
         LA    R15,1(,R15)              bump
          AIF  (&QLEVEL GE 9).LD030
         LH    R1,QPDSID                GET DSID NUMBER
          AGO   .LD040
.LD030    ANOP
         ICM   R1,B'1111',QPDSID        DSID NUMBER
.LD040    ANOP
         CVD   R1,QNUMWORK              MAKE DECIMAL
         MVC   LD@STPDD(8),=XL8'4020202020202120'
         LA    R1,LD@STPDD+7            set for edmk
         EDMK  LD@STPDD(8),QNUMWORK+4   put in number
         LA    R14,LD@STPDD+8           get length of string
         SR    R14,R1
         BCTR  R14,0                    get machine length
         EX    R14,LD$ISMVC             MVC 0(*-*,R15),0(R1)  move dsid
         LA    R15,1(R14,R15)           bump past dsid
         MVI   0(R15),C')'              and closing paren
         LH    R2,QCLRECL               GET RECORD LENGTH
         LTR   R2,R2                    anything?
         BP    *+8                      yes - use it
         LH    R2,=H'32760'             no - use max allowed
         ST    R2,LD@BRLR               SAVE LENGTH IN FULL WORD
         ST    R11,LD@BRQC              SAVE ADDR OF QCOM
         MVC   QDHLINE,QBLANK           clear hdr line
         MVI   QBRIFHDR,C'R'            request hdr line rebuild
         L     R15,ISPLNK               CALL ISPF INTERFACE
         CALL  (15),(=C'CONTROL ',=C'ERRORS  ',=C'RETURN  '),          $
               VL,MF=(E,LD@CALLP)
         L     R15,ISPLNK               CALL ISPF INTERFACE
         TM    QSCFLAG3,QSC3EDIT        want edit instead of browse?
         BNZ   LD$EDIF                  yes
         LA    R2,=C'V '                assume no cc
         TM    QCRECFM,DCBRECCA         asa control characters?
         BZ    *+8                      no - skip
         LA    R2,=C'VA '               yes - change recfm for BRIF
         TM    QCRECFM,DCBRECCM         mch control characters?
         BZ    *+8                      no - skip
         LA    R2,=C'VM '               yes - change recfm for BRIF
*
*
         CALL  (15),(=C'BRIF',BRWHDR,(R2),LD@BRLR,=A(ISPF23RD),        $
               =A(LD$BRIFC),LD@BRQC,=CL8'QPBRO'),                      $
               VL,MF=(E,LD@CALLP)
*
         B     LD$BREND
*
*
*
LD$EDIF  CALL  (15),(=C'EDIF ',BRWHDR,  data name                      $
               =C'SPOOL ',              profile name                   $
               =C'V ',LD@BRLR,          rec-format, rec-len            $
               =A(LD$ED$RD),=A(LD$ED$WR),  read-routine, write-routine $
               0,LD@BRQC,               cmd-routine, dialog-data       $
               0,0,                     edit-len, panel-name           $
               =C'QCEDIMAC'),           macro name                     $
               VL,MF=(E,LD@CALLP)
*
*
LD$BREND LR    R2,R15                   SAVE RETURN CODE
         L     R15,ISPLNK               CALL ISPF INTERFACE
         CALL  (15),(=C'CONTROL ',=C'ERRORS  ',=C'CANCEL  '),          $
               VL,MF=(E,LD@CALLP)
         B     LD$ISEND                 ALL DONE SO EXIT
LD$ISMVC MVC   0(*-*,R15),0(R1)         << executed >>
         EJECT
***********************************************************************
*                                                                     *
**       ENTRY CODE FOR ISPF V1.X AND V2.0->V2.2                      *
*                                                                     *
***********************************************************************
QISPF22  L     R8,BRWEPARM              POINT AT TLD
         USNGX TLD,R8
         L     R7,ISRNM                 POINT TO ISR SERVICE TABLE
         USNGX ISRNAME,R7
*
**       NOW DETERMINE IF ISPF VERSION 1 OR 2
*
         NI    QISFLAG1,255-QIS1V2      SET VERSION 2 FLAG OFF
         L     R1,ISRCBR                GET ADDRESS
         CLC   =C'ISRCBR',5(R1)         IS THIS ISPF V1?
         BE    HAVEISR                  YES
         S     R7,=F'4'                 BACK UP BY 4 FOR V2
         OI    QISFLAG1,QIS1V2          SET V2 FLAG ON
         L     R1,ISRCBR                GET ADDRESS BACK
         CLC   =C'ISRCBR',5(R1)         IS THIS ISPF V2?
         BE    HAVEISR                  YES
         EX    0,*                      ***UNKNOWN ISPF LEVEL****
*
HAVEISR  L     R6,ISPNM                 POINT TO ISP SERVICE TABLE
         USNGX ISPNAME,R6
*
**       INITIALIZE BROWSE SERVICES
*
         L     R15,ISRCBS               GET MODULE ADDR
         CALL  (15),((R8),BRWCBTP),VL,MF=(E,LD@CALLP)
*
**       CLEAR AND FORMAT TFD
*
         L     R3,QVTFD                 Get addr of TFD
         XC    0(208,R3),0(R3)          CLEAR IT
         MVC   0(4,R3),=C'TFD:'         SET EYEBALL
         MVI   5(R3),X'7E'              SET FLAGS
         MVI   6(R3),X'80'              SAY OPENED BY CDO
         LA    R1,TFDMENUP              POINT AT VARIABLES
         ST    R1,64(,R3)               SAVE POINTER
         LA    R1,TFDDCB                POINT AT DCB
         ST    R1,68(,R3)               SAVE POINTER
         LA    R1,TFDDSN                POINT AT DSN
         ST    R1,128(,R3)              SAVE POINTER
         LH    R1,QCLRECL               GET MAX RECORD LENGTH
         LA    R1,4(,R1)                ALLOW FOR RDW
         CH    R1,=H'252'               IS IT TOO BIG?
         BL    *+8                      NO - SKIP
         LA    R1,252                   SET MAX LENGTH
         STH   R1,40(,R3)               SET RECORD LENGTH
         MVC   42(2,R3),=AL2(256)       SET BLKSIZE
         MVI   48(R3),DCBRECV           MARK AS 'RECFM=V'
         MVI   49(R3),X'40'             SET DSORG=PS
         MVC   50(2,R3),=X'2400'        SET MACRF=(R)
         MVI   52(R3),X'08'             SET STATUS
         MVI   53(R3),X'08'             SET DISP
         LA    R1,LD@BUF                GET LINE BUFFER ADDRESS
         ST    R1,24(,R3)               SET BUFFER A ADDRESS
*
**       FILL IN DCB CODES
*
         LA    R2,TFDDCB                POINT AT DCB
         XC    0(92,R2),0(R2)           CLEAR
         USNGX IHADCB,R2
         ST    R11,DCBDEBAD             ADDR OF OUR SAVE AREAS
         MVC   DCBMACRF,=X'2400'        SET MACRF=(R)
         MVI   DCBRECFM,DCBRECV         MARK AS 'RECFM=V'
         MVC   DCBLRECL,40(R3)          SET LRECL
         MVC   DCBBLKSI,=AL2(256)       SET BLKSIZE
         MVC   DCBREAD(4),=A(LSDSREAD)  set READ routine address
         MVC   DCBCHECK(4),=A(LSDSCHCK) set CHECK routine address
         MVC   DCBPOINT(4),=A(LSDSPNT)  set POINT routine address
         TM    QISFLAG1,QIS1V2          IS THIS V2 OF ISPF
         BNO   ISPFV1              NOPE - SKIP V2 CODE AND DO it hard
*
**       PROCSSSING FOR ISPF VERSION 2
*
         LA    R1,TFDDSN                POINT AT DSN
         ST    R1,132(,R3)              SAVE POINTER
         ST    R1,136(,R3)              SAVE POINTER
         ST    R1,140(,R3)              SAVE POINTER
         L     R2,BRWCBTP               GET BROWSE TABLE PTR
         MVC   709(8,R2),=C'ISRBROBF'   SET MENU NAME
         MVC   717(8,R2),=CL8' '        SET BLANKS
         XC    144(4,R2),144(R2)
         MVI   616(R2),X'01'            SET DATASET NUMBER
         MVC   TFDDSN+2(27),=CL27'JOB 12345678, DSID 12345678'
         MVC   TFDDSN+2+4(8),QPARM1     SET JOBNAME
          AIF   (&QLEVEL GE 9).LD050
         LH    R1,QPDSID                GET DSID NUMBER
          AGO   .LD060
.LD050    ANOP
         ICM   R1,B'1111',QPDSID        DSID NUMBER
.LD060    ANOP
         CVD   R1,QNUMWORK              MAKE DECIMAL
         MVC   TFDDSN+2+4+8+7(8),=XL8'4020202020202120'  PATTERN
         ED    TFDDSN+2+4+8+7(8),QNUMWORK+4  PUT IN NUMBER
         MVC   TFDDSN(2),=H'27'         LENGTH OF DSN
         B     CBR                      GO AND DO BROWSE
*
**       PROCSSSING FOR ISPF VERSION 1
*
ISPFV1   DS    0H
*
**       SET OFF BROWSE RECURSIVE FLAG
*
         NI    TLD+237,X'FF'-X'04'
*
**       CALL ISPCMSG TO FORMAT SCREEN HEADER
*
CMSG     L     R15,ISPCMSG
         CALL  (15),((R8),=C'B003',=F'2',BRWHDR,=F'72',                $
               TFDDSN+2,BRWMEM,BRWSTAMP),VL,MF=(E,LD@CALLP)
*
**       INITIALIZE CBT FOR SCROLL HANDLER
*
         L     R2,BRWCBTP               POINT AT COMMON BROWSE TABLE
         L     R2,8(,R2)                POINT AT EXTENSION
         MVC   0(8,R2),=CL8'ISRBROB'    SET MENU
         LA    R1,BRWHDR                POINT AT HEADER
         ST    R1,8(,R2)                SAVE HEADER POINTER
         MVC   12(4,R2),=F'72'          SET HEADER LENGTH
*
**       FORMAT HEADER TO IDENTIFY FILE
*
*                               123456789112345678921234567
         MVC   BRWHDR(27),=CL27'JOB 12345678, DSID 12345678'
         MVC   BRWHDR+4(8),QPARM1       SET JOBNAME
          AIF  (&QLEVEL GE 9).LD070
         LH    R1,QPDSID                GET DSID NUMBER
          AGO   .LD080
.LD070    ANOP
         ICM   R1,B'1111',QPDSID        DSID NUMBER
.LD080    ANOP
         CVD   R1,QNUMWORK              MAKE DECIMAL
         MVC   BRWHDR+4+8+7(8),=XL8'4020202020202120'  PATTERN
         ED    BRWHDR+4+8+7(8),QNUMWORK+4  PUT IN NUMBER
*
**       CALL COMMON BROWSE SERVICE VERSION 1 AND 2
*
CBR      L     R15,ISRCBR               GET PROWSE ENTRY PONIT
         L     R2,QVTFD                 Point at TFD
         CALL  (15),((R8),(R2),BRWCBTP),VL,MF=(E,LD@CALLP)
         L     R2,ISRRET                GET RETURN CODE
*
**       CALL COMMON BROWSE CLEANUP
*
CBC      L     R15,ISRCBC               GET PROWSE ENTRY PONIT
         CALL  (15),((R8),BRWCBTP),VL,MF=(E,LD@CALLP)
*
*
*
LD$ISEND OI    QISFLAG1,QIS1BRCP        mark BROWSE complete
         TM    LD@FLAGS,LD@BRCMD        do we have a new subcommand?
         BNZ   *+10                     yes - don't kill it
         XC    QDRLNG,QDRLNG            no - kill previous subcommand
         TM    QISFLAG1,QIS1V32         running under ISPF V3.2?
         BNZ   LD$ISE32                 yes - skip VREPLACE
         L     R15,ISPLNK               CALL ISPF INTERFACE
         CALL  (15),(=C'VREPLACE',=C'(QQACT) ',=F'8',=CL8'SETVERB'),   $
               VL,MF=(E,LD@CALLP)       Reset VERB TABLE action
LD$ISE32 LTR   R2,R2                    ANY ERROR?
         BNZ   LD$EMPTY                 yes - issue EMPTY DS message
***********************************************************************
*                                                                     *
*        Copy in the Q command variable if set                        *
*                                                                     *
***********************************************************************
*%%% first should check fif ZVERB is 'RETURN' and if so
*%%% dummy up 'EXIT' command.
*%%% if not then get QCMD and see if Q command entered
         LA    R0,32                    maximum length
         ST    R0,LD@VLEN               set for VCOPY
         L     R15,ISPLNK
         CALL  (15),(=CL8'VCOPY',=CL8'QCMD',LD@VLEN,QDREPLY,           $
               =CL8'MOVE'),VL,                                         $
               MF=(E,LD@CALLP)
         L     R0,LD@VLEN               GET LENGTH OF REPLY
         STH   R0,QDRLNG                STORE LENGTH OF REPLY
         OI    LD@FLAGS,LD@BRCMD        remember we have a new subcmd
         L     R15,ISPLNK
         CALL  (15),(=CL8'VERASE',=CL8'QCMD'),VL,                      $
               MF=(E,LD@CALLP)
         CLC   =C'QQ',QDREPLY           Is this proper flag?
         BNE   QSTOP                    nope - done
         LA    R0,QDREPLYL              maximum length
         ST    R0,LD@VLEN               set for VCOPY
         L     R15,ISPLNK
         CALL  (15),(=CL8'VCOPY',=CL8'ZPARM',LD@VLEN,QDREPLY,          $
               =CL8'MOVE'),VL,                                         $
               MF=(E,LD@CALLP)
         L     R0,LD@VLEN               GET LENGTH OF REPLY
         STH   R0,QDRLNG                STORE LENGTH OF REPLY
         B     QSTOP                    all done
         DROPX R6,R7,R8,R2
         EJECT
***********************************************************************
*                                                                     *
*   PROCESS DATASET                                                   *
*                                                                     *
***********************************************************************
LD$FIRST BAL   R14,LD$HEAD              fill in header stuff
LD$TOP   EQU   LD$FIRST,,C'I'           Same as above
         MVI   QBRIFHDR,C' '            header line built
         TM    QISFLAG1,QIS1ISPF        Are we in ISPF?
         BZ    *+10                     no - don't move header line now
         MVC   QDHLINE(L'LDHMLINE),LDHMLINE  MOVE IN HEADER LINE
         MVC   LDHREC,=CL8'1'           Set record nbr in header
         MVC   LDHPAGEN,=CL8'1'         and Page nbr in header
         MVC   LDHLINEN,=CL8'1'         and Line nbr in header
         XR    R4,R4                    set to first record
         TM    QISFLAG1,QIS1ISPF        Are we in ISPF?
         BZ    LD$NXREC                 no - don't shift header
         MVC   QDHLINE(LDHPAGEL),LDHPAGET  shift page and line nbr
         MVC   QDHLINE+LDHPAGEL(L'QDHLINE-LDHPAGEL),QBLANK  clear rest
         SPACE 1
LD$NXREC QCALL GETREC                   get next record
         TM    QCRFLAG,QRFERR           any error reading blk?
         BO    LD$RERR                  YES - handle it
         LTR   R4,R4                    IS THE DISK ADDR ZERO?
         BZ    LD$END                   YES. END OF DATASET.
***********************************************************************
*                                                                     *
*   PROCESS RECORDS                                                   *
*                                                                     *
***********************************************************************
         USNGX LRCDSECT,R4
         LR    R7,R6                    SAVE RECORD LENGTH
         LR    R10,R4                   SAVE RECORD LOCATION
         MVC   LD@BYTE1,LRCFLAG1        SAVE FLAG BYTE
         DROPX R4                       LRCDSECT
         TM    QMODE1,QM1PAGE           IN PAGE DISPLAY MODE?
         BNO   LD$NOPG1                 NO - SKIP
         B     LD$NOPG1                 %%%%%% until page mode works
         CP    QCCPAGE,QPPAGE           Reached the record we want?
         BL    LD$NXREC                 NO, try next record.
         CP    QCCLINE,QPLINE           Reached the record we want?
         BL    LD$NXREC                 NO, try next record.
         B     LD$PGCOM                 Yes, use it
LD$NOPG1 CP    QCCREC,QPREC             REACHED THE RECORD WE WANT?
         BL    LD$NXREC                 NO. TRY NEXT RECORD.
LD$PGCOM CLI   QCODE,4                  IS THE REQUEST FOR A FIND?
         BE    LD$FIND                  YES. DO IT.
         CLI   QCODE,8                  IS IT A FINDTIME REQUEST?
         BE    LD$FTIME                 YES. DO IT.
         SPACE 1
LD$FIOFF CLC   =C'JOBLOG',QDHDSID       IS THIS THE JOBLOG?
         BNE   LD$NOTJL                 NO - OK
*  THE FOLLOWING WILL USUALLY BE RECORD 3 OF AN INPUT QUEUE JOB.
         CLC   =C'******** JOB DELETED BY JES2 OR CANCELLED BY OPERATOR$
                BEFORE EXECUTION ********',4(R10)   JES2 being STUPID?
         BNE   LD$NOTJL
         B     LD$END                   YES - TERMINATE JOBLOG DISPLAY
*  ACTUALLY, THE CHECK ABOVE IS INCORRECT.  WHAT IT REALLY SHOULD BE IS
*  A CHECK TO SEE IF THE JOB IS ON AN OUTPUT QUEUE.  IF SO, THEN THE
*  JOB HAS BEEN CANCELLED OFF OF THE INPUT QUEUE, AND WE SHOULD DISPLAY
*  THE JOBLOG.  BUT, I DON'T KNOW AT THE MOMENT AN EASY WAY TO CHECK
*  THE JOB BEING ON THE OUTPUT QUEUE, SO THIS WILL HAVE TO DO.  IT'S
*  STILL A WHOLE LOT BETTER THAN IT WAS.  (IT WOULD NEVER LET YOU LOOK
*  AT THE JOBLOG FOR AN EXECUTING JOB.)
         SPACE 1
***      QTILT '*** JOBLOG IS EMPTY ***'
LD$NOTJL TM    QMODE1,QM1PAGE           IN PAGE DISPLAY MODE?
         BNO   LD$NOPG2                 NO - SKIP
         TM    LD@BYTE1,LRC1CCTL        CARRIAGE CONTROL SPECIFIED?
         BNO   LD$NOCC                  no - skip
         CLI   3(R10),C'0'              ASA Double space?
         BE    LD$SPC2                  YES - DO IT
         CLI   3(R10),C'-'              ASA Triple space?
         BE    LD$SPC3                  YES - DO IT
         CLI   3(R10),C'1'              ASA new page?
         BNE   LD$NOPG2                 NO - NOTHING STANDARD - SKIP
         CP    QPREC,=P'1'              IS THIS TOP OF DATASET?
         BE    LD$NOPG2                 YES - SKIP SEPARATOR LINE
         BAL   R14,QADDLINE             PUT OUT A BLANK LINE
*ems     AP    QPREC,=P'1'              BUMP RECORD COUNT
         MVI   QDMSG,C'='               BUILD A ...
         MVC   QDMSG+1(L'QDMSG-1),QDMSG ... SEPARATOR ...
         MVC   QDMSG+30(13),=C' END OF PAGE '   ... LINE
         BAL   R14,QADDLINE             PUT OUT SEPARATOR LINE
         BAL   R14,QADDLINE             put out blank line
         B     LD$NOPG2                 and output data line
*ems     AP    QPREC,=P'1'              BUMP RECORD COUNT
         SPACE 1
LD$SPC3  BAL   R14,QADDLINE             PUT OUT BLANK LINE
*ems     AP    QPREC,=P'1'              BUMP RECORD COUNT
         SPACE 1
LD$SPC2  BAL   R14,QADDLINE             PUT OUT BLANK LINE
*ems     AP    QPREC,=P'1'              BUMP RECORD COUNT
         SPACE 2
LD$NOPG2 TM    LD@BYTE1,LRC1CCTL        is carriage control specified?
         BZ    LD$NOCC                  NO. CONTINUE.
         TM    QMODE1,QM1LCC            YES. DOES HE WANT TO SEE IT?
         BNZ   LD$NOCC                  yes - display it
         TM    QISFLAG1,QIS1ISPF        Are we in ISPF?
         BNZ   LD$NOCC                  yes - always pass the CC
*  This might need to be based on the release of PDF, but I don't
*  remember when the DISP CC/NOCC command showed up...
         BCTR  R7,0                     no - decrement length
         LA    R10,1(,R10)              ... and skip over it
LD$NOCC  EQU   *
         TM    QFLAG3,Q3SYSLOG          is this the SYSLOG command?
         BZ    LD$NOTSL                 no - skip
         CLI   QSLFLDS,0                any fields selected?
         BZ    LD$NOTSL                 no - skip
         LA    R1,LD@REC                -> start of rebuild area
***      CLC   QBLANK(40),2+3(R10)      is this a cont or mlwto line?
*---  Check for blank timestamp
         CLC   QBLANK(11),25+3(R10)     cont, mlwto, or nip line?
         BE    LD$SLXA                  yes - reformat it (assume XA)
         CLI   7+3(R10),C'.'            pre SP 2.2.0 syslog?
         BE    LD$SL370                 yes, older format
         CLI   27+3(R10),C':'           bizarre line?  (huh?)
         BNE   LD$NOTSL                 yes - don't futz with it
         CLI   30+3(R10),C':'           bizarre line?  (huh?)
         BE    LD$SLXA                  no - use it
*
LD$SLXA  TM    QSLFLDS,QSLFLIND         want indicators?
         BZ    *+4+6+4                  no - skip
         MVC   0(2,R1),=AL1(1,2)        yes
         LA    R1,2(,R1)
*
         TM    QSLFLDS,QSLFLRTC         want route codes?
         BZ    *+4+6+4                  no - skip
         MVC   0(7,R1),=AL1(3,4,5,6,7,8,9)  yes
         LA    R1,7(,R1)
*
         TM    QSLFLDS,QSLFLIND+QSLFLRTC  either ind or rtc selected?
         BZ    *+4+4+4  *diff offset*   no - skip
         MVI   0(R1),0                  yes - select a blank
         LA    R1,1(,R1)
*
         TM    QSLFLDS,QSLFLSID         want system id?
         BZ    *+4+6+4                  no - skip
         MVC   0(9,R1),=AL1(11,12,13,14,15,16,17,18,0)  yes
         LA    R1,9(,R1)
*
         TM    QSLFLDS,QSLFLDAT         want date?
         BZ    *+4+6+4                  no - skip
         MVC   0(6,R1),=AL1(20,21,22,23,24,0)  yes
         LA    R1,6(,R1)
*
         TM    QSLFLDS,QSLFLTIM         want time?
         BZ    *+4+6+4                  no - skip
         MVC   0(12,R1),=AL1(26,27,28,29,30,31,32,33,34,35,36,0)
         LA    R1,12(,R1)
*
         TM    QSLFLDS,QSLFLJID         want jobid?
         BZ    *+4+6+4                  no - skip
         MVC   0(9,R1),=AL1(38,39,40,41,42,43,44,45,0)  yes
         LA    R1,9(,R1)
*
         TM    QSLFLDS,QSLFLRFL         want request flags?
         BZ    *+4+6+4                  no - skip
         MVC   0(9,R1),=AL1(47,48,49,50,51,52,53,54,0)  yes
         LA    R1,9(,R1)
*
         L     R15,=A(LD#SLTXA)         select columns 56-130
         MVC   0(75,R1),0(R15)
         XC    75(300-130,R1),75(R1)    pad with blanks
         B     LD$SLCOM                 back to common code
         SPACE 1
LD$SL370 CLI   10+3(R10),C'.'           more time?
         BNE   LD$NOTSL                 no, treat it normal
         TM    QSLFLDS,QSLFLRTC         want route codes?
         BZ    *+4+6+4                  no - skip
         MVC   0(5,R1),=AL1(1,2,3,4,0)  yes
         LA    R1,5(,R1)
*
         TM    QSLFLDS,QSLFLTIM         want time?
         BZ    *+4+6+4                  no - skip
         MVC   0(9,R1),=AL1(6,7,8,9,10,11,12,13,0)  yes
         LA    R1,9(,R1)
*
         TM    QSLFLDS,QSLFLJID         want jobid?
         BZ    *+4+6+4                  no - skip
         MVC   0(9,R1),=AL1(15,16,17,18,19,20,21,22,0)  yes
         LA    R1,9(,R1)
*
         L     R15,=A(LD#SLT37)         select columns 24-130
         MVC   0(106,R1),0(R15)
         XC    106(300-130,R1),106(R1)  pad with blanks
         SPACE 1
LD$SLCOM MVC   LD@SLREC,QBLANK          blank the target area
         BCTR  R7,0                     -1 for ex
         EX    R7,LD$MVCSL              mvc ld@slrec+1(*-*),3(r10)
         TR    LD@REC(200),LD@SLREC
         TR    LD@REC+200(100),LD@SLREC
*
         LA    R10,LD@REC-3             -> rebuilt record to display
         LA    R7,L'LD@REC              and length
LD$NOTSL EQU   *
         AH    R10,QPOFFSET             Add offset to start of record
         SH    R7,QPOFFSET              SUBTRACT OFFSET FROM LENGTH
         BNP   LD$DISP                  NO DATA LEFT IN RECORD.
         TM    QISFLAG1,QIS1ISPF        Are we in ISPF?
         BO    LD$DISP                  If so then leave alone
         CH    R7,QDCOLS                IS RECORD BIGGER THAN 80 CHARS?
         BNH   *+8                      NO. USE RECORD LENGTH.
         LH    R7,QDCOLS                YES. USE A LENGTH OF 80.
         BCTR  R7,0                     -1 FOR EX
         LA    R10,3(,R10)              OFFSET PAST REC HDR
         EX    R7,LD$MVC                MOVE RECORD TO DISPLAY LINE
         L     R1,=A(CHARTAB)           get address of table
         EX    R7,LD$TR                 TRANSLATE OUT UNPRINTABLE CHARS
         CLC   =C'FA',QSUBNAME          IS THIS FINDALL?
         BNE   LD$DISP                  NO - SKIP
         TM    QMODE1,QM1FANUM          WANT NUMBERS FOR FINDALL?
         BNO   LD$DISP                  NO - SKIP
         LA    R1,QDMSG-8
         AH    R1,QDCOLS                -> LAST 8 CHARS OF SCREEN LINE
         MVC   0(8,R1),LD#EDIT          Set edit mask
         ED    0(8,R1),QCCREC           Move in current record no.
LD$DISP  TM    QISFLAG1,QIS1ISPF        ARE WE IN ISPF?????
         BZ    NISPF2                   NOPE - CONTINUE NORMALLY
***********************************************************************
*                                                                     *
*        MOVE LINE BACK TO BROWSE  FOR ISPF V1.X -> V2.2              *
*                                                                     *
*              R7  ===  LENGTH                                        *
*              R10+3 ->  DATA                                         *
*                                                                     *
***********************************************************************
         LA    R10,3(,R10)              UPDATE TO REAL LINE
         L     R8,4(,R13)               GET ORIG R13
         L     R8,12+4+4+4(,R8)         GET DECB ADDRESS (R1 ON ENTRY)
         TM    QISFLAG1,QIS1V23         IS THIS ISPF V2.3?
         BO    QISPF23A                 YES - HANDLE
          AIF   (&LD#DBG).LDJUNK2  %%%  if dbg, need the addressibility
         USNGX DECSDECB,R8              SETUP ADDRESSABILITY FOR DECB
         L     R15,DECAREA              POINT TO AREA
         CH    R7,=H'248'               max line supported
         BNH   *+8     >=====+          length ok
         LA    R7,248        |          set to max
         LA    R14,5(,R7) <==+          get RDW
         STH   R14,4(R15)               set RDW
         XC    6(2,R15),6(R15)          CLEAR REST OF RDW
         LA    R14,4(R14)               get BDW
         STH   R14,0(R15)               set BDW
         XC    2(2,R15),2(R15)          CLEAR REST OF BDW
         BCTR  R7,0                     -1 for EX
         EX    R7,RECMOVE               move in data
         AP    QPREC,=P'1'              SET NEXT ENTRY TO NEXT RECORD
         B     SETIOB                   ALL DONE
         DROPX R8
.LDJUNK2  ANOP                          %%%%%
RECMOVE  MVC   8(*-*,R15),0(R10)        << executed >>
***********************************************************************
*                                                                     *
*        MOVE LINE BACK TO BROWSE  FOR ISPF V2.3 -> ??                *
*                                                                     *
*              R7  ===  LENGTH                                        *
*              R8  -->  READ ROUTINE PARM LIST                        *
*              R10 -->  DATA                                          *
*                                                                     *
***********************************************************************
QISPF23A LA    R15,LD@BUF               POINT TO MY BUFFER
         L     R2,0(,R8)                GET ADDR OF VARIABLE
         ST    R15,0(,R2)               SET POINTER IN LINE VARIABLE
         L     R2,4(,R8)                GET ADDR OF VARIABLE
         CH    R7,=H'256'               max line supported
         BNH   *+8      >=====+         length ok
         LA    R7,256         |         set to max
         ST    R7,0(,R2)  <===+         SET LENGTH IN PARM LIST
         SL    R15,=F'8'                ADJUST FOR MVC OPERAND
         BCTR  R7,0                     -1 for EX
         EX    R7,RECMOVE               MOVE IN DATA
         L     R15,4(,R13)              NOW SET THE CORRECT RETURN CD
         XC    12+4(4,R15),12+4(R15)    SET TO 0
         B     LSDSCKXT                 NOW EXIT
***********************************************************************
*                                                                     *
*        MOVE LINE TO DISPLAY FOR NATIVE SCREEN CONTROL               *
*                                                                     *
*              QDMSG has DATA                                         *
*                                                                     *
***********************************************************************
NISPF2   BAL   R14,QADDLINE
         TM    QDOVER,1                 WAS THERE A PAGE OVERFLOW?
         BNO   LD$NXREC                 NO. SKIP.
         ZAP   QPREC,QCCREC             UPDATE THE REPOSITION NUMBER
         ZAP   QPPAGE,QCCPAGE           set to current page
         ZAP   QPLINE,QCCLINE           set to current line (cc)
         ZAP   QPLINEA,QCCLINEA         set to current line (abs)
         BAL   R14,LD$HEAD              insert heading
         B     LD$NXREC                 and get next record
         SPACE 1
*---  Error on block read
LD$RERR  ZAP   QCHREC,=P'0'             clear high rec on err
         ZAP   QCCREC,=P'0'             clear current rec on err
*                                       Handle rest like eof
         SPACE 1
LD$END   TM    QISFLAG1,QIS1ISPF        are we in ispf?
         BO    LSDSCKEF                 yes - return to CHECK
         CP    QCCREC,=P'0'             IS THE DATASET EMPTY?
         BE    LD$EMPTY                 YES. QUIT.
         CP    QPREC,QCCREC             REQUESTED POS > END?
         BH    LD$BOTTM                 YES - FORCE HIM TO "BOTTOM"
*%%%     CLC   =C'TT70710',QLOGON       ME?
*%%%     BNE   *+4+6+6+6                NO - SKIP FOR NOW %%%%%%%%%%%
*%%%     MVC   LDHEND,ENDLINE           TELL THEM THIS IS THE END
*%%%     MVC   LDHREND,LD#EDIT          PATTERN FOR EDIT
*%%%     ED    LDHREND,QCCREC           LAST REC NO
         CLI   QCODE,32                 WAS REQUEST FOR BOTTOM?
         BE    LD$BOTTM                 YES. BACK UP 20 LINES.
         CLI   QCODE,4                  IS THE REQUEST FOR A FIND?
         BE    LD$NOPE                  YES - SAY WE DIDN'T FIND IT
         CLC   QDLINECT,QDROWS          is screen full?
         BE    LD$DISPF                 no, repos to last screen
LD$DEND  L     R1,=V(ENDDATA)           -> "END OF DATA" MSG
         MVC   QDMSG(80),0(R1)
         BAL   R14,QADDLINE             MOVE "END OF DATA" TO SCREEN
LD$DISPF QCALL DISPLAY                  FLUSH THE SCREEN
*LDW*    ZAP   QPREC,=P'1'              RECORD NUMBER 1
*LDW*    B     LD$TOP                   START AT TOP OF DATASET
         B     LD$REPOS                 JUST STAY RIGHT HERE      *LDW*
LD$NOPE  CLI   QSUBNAME+1,C'A'          IS THE REQUEST FOR A FINDALL?
         BNE   LD$NOPE2                 NO - SAY 'NOT FOUND'
         TM    LD@FLAGS,LD@FOUND        DID WE FIND ANYTHING?
         BO    LD$DEND                  YES - JUST SHOW END OF DATA
LD$NOPE2 MVC   QERRMSG(26),=C'*** STRING NOT FOUND --> '''
         LH    R1,QPLNG                 GET LENGTH-1 OF SEARCH STRING
         CH    R1,=H'53'                TOO LONG?
         BNH   *+8                      NO - OK
         LH    R1,=H'53'                YES - USE MAX
         EX    R1,LD$NOPEM              FILL IN THE SEARCH STRING
         CLC   QPLNG,=H'53'             ENOUGH ROOM FOR ENDING QUOTE?
         BNL   LD$NOPE3                 NO - SO DON'T PUT IT IN
         LA    R1,QERRMSG+26+1(R1)      -> WHERE ENDING QUOTE GOES
         MVI   0(R1),C''''              PUT IT IN
LD$NOPE3 MVC   QDPROMPT,QFINDCMD        AND PROMPT WITH WHOLE FIND CMD
         QTILT *,OPTIONS=REPROMPT
LD$NOPEM MVC   QERRMSG+26(*-*),QPFIND   << EXECUTED >>
LD$EMPTY MVC   QDHLINE,QBLANK           CLEAR THE MSG AREA
         MVC   QDHLINE(11),=C'*** DATASET'
         MVC   QDHLINE+12(8),QDHDSID    SHOW THE DSID
         MVC   QDHLINE+21(12),=C'IS EMPTY ***'
**LDW**  XC    QPDSID,QPDSID            MAKE USER SPECIFY A NEW DATASET
**LDW**  NI    QFLAG2,255-Q2VALIDS      NULLIFY VALIDITY FOR LISTDS
         QCALL DISP80
         B     QSTOP
LD$MVC   MVC   QDMSG(*-*),0(R10)        << EXECUTED >>
LD$MVCSL MVC   LD@SLREC+1(*-*),3(R10)   << EXECUTED >>
LD$TR    TR    QDMSG(*-*),0(R1)         << EXECUTED >>
***********************************************************************
*                                                                     *
*   BOTTOM OF DATASET                                                 *
*                                                                     *
***********************************************************************
LD$BOTTM XR    R4,R4                    zero
         BCTR  R4,0                     negative
         QCALL GETREC                   get last record in dataset
         TM    QCRFLAG,QRFERR           any error reading blk?
         BO    LD$RERR                  YES - handle it
         ZAP   QPREC,QCHREC             LAST RECORD NUMBER
         MVI   QCODE,0                  AVOID A LOOP
         TM    QISFLAG1,QIS1ISPF        are we in ISPF?
         BO    LSDSCKEF                 yes - return last record
         LA    R1,QTPAGE                ASSUME COLUMN INDICATOR OFF
         TM    QFLAG2,Q2COLIND          ON?
         BNO   *+8                      NO - OK
         LA    R1,QTPAGEX               YES - USE ALTERNATE NUMBER
         SP    QPREC,0(L'QTPAGE,R1)     POINT TO TOP OF "BOTTOM PAGE"
         AP    QPREC,=P'2'              FUDGE FACTOR
         BNP   LD$TOP                   go to top if not positive
         B     LD$SETR                  go to record
***********************************************************************
*                                                                     *
*   REPOSITION TO REQUESTED RECORD NUMBER                             *
*                                                                     *
***********************************************************************
LD$LAST  OI    LD@FLAGS,LD@MORE         restore saved position
         SPACE 1
LD$REPOS CLI   QCODE,64                 page command?
         BE    LD$SETR                  yes, do it
         CP    QPREC,=P'9999999'        is req for bottom.
         BE    LD$BOTTM                 YES. GO FROM HI.
         CP    QPREC,=P'1'              IS REQ FOR TOP OF DATASET?
         BNH   LD$TOP                   YES, DO IT.
LD$SETR  XR    R4,R4                    R4 negative tells GETREC to ...
         BCTR  R4,0                     ... start at rec nbr in QPREC
         QCALL GETREC                   get record to set page/line no
         TM    QCRFLAG,QRFERR           any error reading blk?
         BO    LD$RERR                  YES - handle it
         LTR   R4,R4                    any record exists?
         BZ    LD$END                   no - end of data
         CLI   QCODE,64                 "PAGE"
         BNE   *+8                      no, continue
         MVI   QCODE,0                  reset
         ZAP   QPREC,QCCREC             update starting record no
         ZAP   QPPAGE,QCCPAGE           set to current page
         ZAP   QPLINE,QCCLINE           set to current line (cc)
         ZAP   QPLINEA,QCCLINEA         set to current line (abs)
         BAL   R14,LD$HEAD              insert headings
         XR    R4,R4                    zero
         BCTR  R4,0                     SPECIFIC REC NO
         B     LD$NXREC                 GO TO IT.
          AIF   (&LD#DBG).LDJUNK3  %%%  if dbg, need the addressibility
***********************************************************************
*                                                                     *
**       POINT AT IOB AND SET RESIDUAL LENGTH IN IOB                  *
*                                                                     *
***********************************************************************
SETIOB   L     R8,4(,R13)               GET ORIG R13
         L     R8,12+4+4+4(,R8)         GET DECB ADDRESS (ORIG R1)
         USNGX DECSDECB,R8              SETUP ADDRESSABILITY FOR DECB
         L     R1,DECAREA               POINT AT BUFFER
         LA    R15,256                  SET BUFFER LENGTH
         SH    R15,0(,R1)               GET RESIDUAL LENGTH
         LA    R1,BRWIOB                POINT AT IOB
         ST    R1,DECIOBPT              SAVE POINTER
         STH   R15,14(,R1)              SET RESIDUAL COUNT
         B     LSDSCKXT                 ALL DONE
         DROPX R8
.LDJUNK3  ANOP                          %%%%%
***********************************************************************
*                                                                     *
**       SIGNAL EOF SINCE BEYOND LAST LINE TO BROWSE                  *
*                                                                     *
***********************************************************************
LSDSCKEF L     R8,4(,R13)               GET ORIG R13
         L     R8,12+4+4+4(,R8)         GET DECB ADDRESS (ORIG R1)
         TM    QISFLAG1,QIS1V23         IS THIS ISPF V2.3?
         BZ    QISPF22B                 NOPE - SKIP 2.3 CODE
*
**       FOR BRIF (ISPF V2.3) INTERFACE, RETURN MAX RECORD
**       NUMBER AND A RETURN CODE OF 8.  If running under ISPF V3R2,
**       set return code 4 instead to indicate temporary EOF.  If using
**       EDIF, set a return code of 8.  BRIF doesn't support rc=4.
*
         OI    QMISCFLG,QMFRMAX         set need to reset max
         ZAP   QNUMWORK,QCHREC          GET CURRENT (MAX) RECORD
         CVB   R1,QNUMWORK              MAKE IT BINARY
         L     R15,8(,R8)               GET VARIABLE ADDRESS
         ST    R1,0(,R15)               SET MAXIMUM RECORD NUMBER
         LA    R15,LD@BUF               POINT TO MY BUFFER
         L     R2,0(,R8)                GET ADDRESS OF VARIABLE
         ST    R15,0(,R2)               SAVE ADDRESS
         L     R2,4(,R8)                GET ADDRESS OF VARIABLE
         ST    R7,0(,R2)                SAVE LENGTH OF LAST RECORD
         L     R15,4(,R13)              GET ORIGINAL SAVE AREA
         TM    QSCFLAG3,QSC3EDIT        using EDIF?
         BNZ   LD$EDRC8                 yes - set rc=8 for EOF
         MVC   12+4(4,R15),=F'4'        set "temporary EOF" rc
         TM    QISFLAG1,QIS1V32         IS THIS ISPF V3.2?
         BNZ   LSDSCKXT                 yes - quit
LD$EDRC8 MVC   12+4(4,R15),=F'8'        SET 'MAX REACHED' RETURN CODE
         B     LSDSCKXT                 AND QUIT
*
**       FOR ISPF V1.X -> V2.2 USING THE DCB INTERFACE
**       SETUP SO THE THE DCBEODAD ADDRESS IS CALLED
**       ON RETURN
*
         USNGX DECSDECB,R8              SETUP ADDRESSABILITY FOR DECB
QISPF22B L     R1,DECDCBAD              POINT AT DCB
         L     R1,DCBEODAD-IHADCB(,R1)  GET EOD ADDR
         L     R15,4(,R13)              GET OLD SAVEAREA POINTER
         ST    R1,12(,R15)              SAVE RETURN ADDRESS
         DROPX R8
***********************************************************************
*                                                                     *
**       EXIT FROM CHECK                                              *
*                                                                     *
***********************************************************************
LSDSCKXT L     R13,4(,R13)              GET OLD SAVEAREA POINTER
         LM    R14,R12,12(R13)          RESTORE REGISTER
LSDSCKND BR    R14                      exit
***********************************************************************
*                                                                     *
*   FIND MATCHING RECORD ROUTINE                                      *
*                                                                     *
***********************************************************************
LD$FIND  LH    R3,QPLNG                 LENGTH-1 OF COMPARE
         LR    R15,R6                   GET RECORD LENGTH
         BCTR  R15,0                    -1 FOR EX
         EX    R15,LD$COPY              COPY RECORD TO WORK AREA
         OC    LD@REC(132),QBLANK       UPPER CASE FIRST PART
         OC    LD@REC+132(132),QBLANK   DITTO SECOND PART
         LR    R14,R6                   LENGTH OF RECORD
         SR    R14,R3                   NUMBER OF COMPARES
         BNP   LD$NXREC                 RECORD IS TOO SMALL. SKIP IT.
         LA    R15,LD@REC               FIRST BYTE OF RECORD
         CLC   QOFFE,=H'0'              END RANGE FOR FIND SPECIFIED ?
         BE    LD$FLOOP                 NO. BYPASS RANGE FOR FIND
         AH    R15,QOFFS                YES. START ADDR FOR FIND
         LH    R14,QOFFE                END ADDR FOR FIND
         SH    R14,QOFFS                VALID RANGE ?
         BP    LD$FLOOP                 YES. CONTINUE PROCESSING
         EX    0,*                      %%% CHECKED IN "REPOS" %%%
         QTILT '*** ERROR IN COLUMN SPECIFICATION ***'
LD$FLOOP EX    R3,LD$CLC                DOES FIND DATA MATCH THE REC?
         BE    LD$MATCH                 YES. DISCONTINUE SEARCH.
         LA    R15,1(,R15)              INCREMENT TO NEXT BYTE
         BCT   R14,LD$FLOOP             TRY NEXT BYTE
         B     LD$NXREC                 SKIP THE RECORD. NO MATCH.
LD$MATCH OI    LD@FLAGS,LD@FOUND        REMEMBER WE FOUND A MATCH
         TM    LD@FLAGS,LD@FPREC        been here yet?
         BO    LD$FALL                  yes, don't fall through
         OI    LD@FLAGS,LD@FPREC        now been here
         ZAP   QPREC,QCCREC             UPDATE THE REPOSITION NUMBER
         ZAP   QPPAGE,QCCPAGE           set to current page
         ZAP   QPLINE,QCCLINE           set to current line (cc)
         ZAP   QPLINEA,QCCLINEA         set to current line (abs)
         CLI   QSUBNAME+1,C'A'          IS THE REQUEST FOR A FINDALL?
         BE    LD$FALL                  YES. DO NOT DISABLE SEARCH.
         MVI   QCODE,0                  END THE SEARCH
LD$FALL  BAL   R14,LD$HEAD              insert heading
         B     LD$FIOFF                 CONTINUE
LD$COPY  MVC   LD@REC(*-*),3(R4)        << EXECUTED >>
LD$CLC   CLC   QPFIND(*-*),0(R15)       << EXECUTED >>
***********************************************************************
*                                                                     *
*   FIND THE RECORD WHICH IS GREATER THAN OR EQUAL TO TIME            *
*                                                                     *
***********************************************************************
LD$FTIME CLI   7(R4),C' '               old format syslog?
         BNE   LD$FTXA                  no, must be new format
         CLI   10(R4),C'.'              contain time?
         BE    LD$FT370                 yes, do it
         B     LD$NXREC                 no, skip it.
LD$FTXA  CLI   27+3(R4),C':'            does this record have time?
         BNE   LD$NXREC                 no, skip it.
         CLI   30+3(R4),C':'            make sure enough time left
         BNE   LD$NXREC                 no, skip it.
         MVI   QPARM1+2,C':'            force correct syntax
         CLI   QPARM1+5,C' '            any value here?
         BE    *+8                      no, skip update
         MVI   QPARM1+5,C':'            force correct syntax
         CLC   QPARM1,28(R4)            is this the time we want?
         BH    LD$NXREC                 no. skip it.
         B     LD$MATCH                 end the search
LD$FT370 CLI   13(R4),C'.'              does this record have time?
         BNE   LD$NXREC                 NO. SKIP IT.
         MVI   QPARM1+2,C'.'            force correct syntax
         CLI   QPARM1+5,C' '            any value here?
         BE    *+8                      no, skip update
         MVI   QPARM1+5,C'.'            force correct syntax
         CLC   QPARM1,8(R4)             IS THIS THE TIME WE WANT?
         BH    LD$NXREC                 NO. SKIP IT.
         B     LD$MATCH                 END THE SEARCH
***********************************************************************
*                                                                     *
*   SET PAGE HEADING                                                  *
*                                                                     *
***********************************************************************
LD$HEAD  TM    QISFLAG1,QIS1ISPF        are we in ISPF?
         LR    R2,R14                   %%%%%
         BZ    LD$HEAD1                 no - go build header
          AIF   (NOT &LD#DBG).LDNDBG1   %%%%%
         TPUTX '>>> LD$HEAD (QDHLINE follows)'  %%%%%
         TPUTX QDHLINE,L'QDHLINE        %%%%%
         LR    R14,R2                   %%%%%
.LDNDBG1  ANOP                          %%%%%
         CLI   QBRIFHDR,C'R'            need to build header?
         BNER  R14                      no - do it once per screen
         MVI   QBRIFHDR,C' '            reset the flag
LD$HEAD1 DS    0H                       %%%%%%
          AIF   (NOT &LD#DBG).LDNDBG2   %%%%%
         TPUTX '>>> LD$HEAD - build'    %%%%%
         LR    R14,R2                   %%%%%
.LDNDBG2  ANOP                          %%%%%
         MVC   QDHLINE(L'LDHMLINE),LDHMLINE  MOVE IN HEADER LINE
         OI    QFLAG1,Q1MVHDR           REQUEST "MOVE HEADER"
         MVC   LDHDSID,QDHDSID          AND FILL IN DSID
         LH    R1,QPOFFSET              GET CURRENT COLUMN NUMBER
         LA    R1,1(,R1)                IT'S ORIGIN 0
         CVD   R1,QNUMWORK
         OI    QNUMWORK+7,X'0F'         REMOVE SIGN
         UNPK  LDHCOL,QNUMWORK          PUT COLUMN NUMBER IN HEADER
          AIF  (&QLEVEL LT 5).LD090
         MVI   LD@STPST,C'X'            stopper for bctr loop
         MVC   LD@STPDD,QBLANK          clear field
         MVC   LD@STPDD(8),QSTEPNAM     set stepname
         LA    R15,LD@STPDD+7           -> last char
LD$HBLP  CLI   0(R15),C' '              blank?
         BNE   *+8                      no, done
         BCT   R15,LD$HBLP              yes, try prev
         MVI   1(R15),C'/'              delimeter
         MVC   2(8,R15),QDDNAME         and ddname
         CLC   =C'/ ',LD@STPDD          just a separator?
         BNE   *+8                      no, leave it
         MVI   LD@STPDD,C' '            yes, clear it
         L     R1,=A(CHARTAB)           get table address
         TR    LD@STPDD,0(R1)           translate to printable
         MVC   LDHSTPDD,LD@STPDD        copy to print area
.LD090    ANOP ,
         MVC   LD@EDITW,LD#EDIT         prepare for edit
         LA    R1,LD@EDIT+7             -> end of field
         EDMK  LD@EDIT,QPREC            edit record no.
         MVC   LDHREC,0(R1)             move in record number
          AIF   (NOT &LD#DBG).LDNDBG3   %%%%%
         TPUTX 'QPREC=',ASIS            %%%%%
         TPUTX LDHREC,L'LDHREC          %%%%%
.LDNDBG3  ANOP                          %%%%%
         MVC   LD@EDITW,LD#EDIT
         LA    R1,LD@EDIT+7             -> end of field
         EDMK  LD@EDIT,QPPAGE           and page
         MVC   LDHPAGEN,0(R1)           move in page number
          AIF   (NOT &LD#DBG).LDNDBG4   %%%%%
         TPUTX 'QPPAGE=',ASIS           %%%%%
         TPUTX LDHPAGEN,L'LDHPAGEN      %%%%%
.LDNDBG4  ANOP                          %%%%%
         LA    R15,QPLINE               cc  line
         TM    QMODE1,QM1PAGE
         BNZ   *+4+4
         LA    R15,QPLINEA              abs line
         MVC   LD@EDITW,QBLANK          clear field
         MVC   LD@EDIT(4),=X'40202120'  set edit mask
         LA    R1,LD@EDIT+3             -> end of field
         EDMK  LD@EDIT(4),0(R15)        edit number
         MVC   LDHLINEN,0(R1)           insert it
          AIF   (NOT &LD#DBG).LDNDBG5   %%%%%
         TPUTX 'QPLINE=',ASIS           %%%%%
         TPUTX LDHLINEN,L'LDHLINEN      %%%%%
         TPUTX QDHLINE,L'QDHLINE        %%%%%
.LDNDBG5  ANOP                          %%%%%
         TM    QISFLAG1,QIS1ISPF        Are we in ISPF?
         BZR   R14                      no - just return
         MVC   QDHLINE(LDHPAGEL),LDHPAGET  shift page and line nbr
         MVC   QDHLINE+LDHPAGEL(L'QDHLINE-LDHPAGEL),QBLANK  clear rest
          AIF   (NOT &LD#DBG).LDNDBG6   %%%%%
         TPUTX QDHLINE,L'QDHLINE        %%%%%
         LR    R14,R2                   %%%%%
.LDNDBG6  ANOP                          %%%%%
         BR    R14                      and return
         EJECT
***********************************************************************
*                                                                     *
*   MISCELLANY                                                        *
*                                                                     *
***********************************************************************
         LTORG ,
LD#EDIT  DC    X'4020202020202120',CL8' '
LDHMLINE DC    CL80' '
         ORG   LDHMLINE
          AIF  (&QLEVEL LT 5).LD100
         DC    C'ssssssss/dddddddd',C' '
.LD100    ANOP ,
         DC    C'DSID xxxxxxxx  Col nnn '
         DC    C'Rec xxxxxxxx '
LDHLPAGE DC    C'Page xxxxxxxx Line xxx'
         ORG   ,
         SPACE 2
LD#SLTXA DC    75AL1(56+*-LD#SLTXA)
LD#SLT37 DC    106AL1(24+*-LD#SLT37)
         SPACE 2
         PUSH  USING
         DROP  ,
         EJECT
***********************************************************************
*                                                                     *
*        READ MACRO CODE                                              *
*                                                                     *
*        INPUT                                                        *
*              R1  -->  DECB                                          *
*                                                                     *
***********************************************************************
LSDSREAD DS    0H
*
**       DO NOTHING HERE, LEAVE ALL WORK FOR
**       CHECK ROUTINE
*
         BR    R14
         EJECT
***********************************************************************
*                                                                     *
*        POINT/NOTE MACRO CODE                                        *
*                                                                     *
*        INPUT                                                        *
*              R1  -->  DCB                                           *
*              R0  -->  TTRN IF POINT ENTRY (+4)                      *
*                                                                     *
*        OUTPUT                                                       *
*              R1  ===  TTRN IF NOTE ENTRY (+0)                       *
*                                                                     *
*                                                                     *
***********************************************************************
         USING LSDSPNT,R15              SETUP TEMP ADDRESSABILITY
LSDSPNT  DS    0H
         B     LSDSNOT                  +0 ENTRY IS NOTE SO HANDLE
*                                       +4 ENTRY IS POINT
         DROP  R15
*
**       DO POINT
**             FOR US THE TTR IS REALLY THE RELATIVE RECORD
**             NUMBER OF THE LINE IN THE SPOOL FILE.
**             SO JUST CONVERT IT AND SAVE IT IN QPREC.
*
         STM   R14,R12,12(R13)          SAVE REGISTERS
         LR    R12,R15                  SETUP BASE REGISTER
         USING LSDSPNT,R12              SETUP ADDRESSABILITY
         LR    R5,R1                    SAVE DCB POINTER
         USING IHADCB,R5                SETUP ADDRESSABILITY
         L     R11,DCBDEBAD             POINT AT COMMON VECTOR TABLE
         USING QCOMMON,R11              SETUP ADDRESSABILITY
         LR    R15,R0                   MOVE POINTER
         L     R1,0(,R15)               GET THE TTRN
         SRL   R1,8                     GET TTR (REALLY REC #)
         CVD   R1,QNUMWORK              CONVERT IT
         ZAP   QPREC,QNUMWORK           SET DESIRED RECORD #
         LM    R14,R12,12(R13)          RESTORE REGISTERS
         SR    R15,R15                  SET RETURN CODE
         BR    R14                      exit
         DROP  ,                        KILL ADDRESSABILITY
         SPACE 3
*
**       DO NOTE
**             IN THIS CASE RETURN THE CURRENT RECORD NUMBER
**             AS THE TTR.  BROWSE IS SO DEVICE INDEPENDENT
**             HE'LL NEVER NOTICE.
*
LSDSNOT  STM   R14,R12,12(R13)          SAVE REGISTERS
         LR    R12,R15                  SETUP BASE REGISTER
         USING LSDSPNT,R12              SETUP ADDRESSABILITY
         LR    R5,R1                    SAVE DCB POINTER
         USING IHADCB,R5                SETUP ADDRESSABILITY
         L     R11,DCBDEBAD             POINT AT COMMON VECTOR TABLE
         USING QCOMMON,R11              SETUP ADDRESSABILITY
         ZAP   QNUMWORK,QCCREC          GET CURRENT RECORD #
         CVB   R1,QNUMWORK              MAKE IT BINARY
         SLL   R1,8                     MAKE LOOK LIKE TTRN
LSDSNOTX ST    R1,12+4+4+4(R13)         SAVE VALUE
         LM    R14,R12,12(R13)          RESTORE REGISTERS
         SR    R15,R15                  CLEAR RETURN CODE
         BR    R14                      exit
         DROP  ,
         EJECT
***********************************************************************
*                                                                     *
*        ISPF V2.3 BROWSE INTERFACE READ ROUTINE                      *
*                                                                     *
*        INPUT                                                        *
*     R1  -->  +0  -->  F'0'  -  TO BE SET TO POINT AT DATA LINE      *
*              +4  -->  F'0'  -  TO BE SET TO LENGTH OF LINE          *
*              +8  -->  F'L'  -  THE REQUESTED LINE NUMBER            *
*              +12 -->  A(QCOMMON) - ADDRESS PASSED FROM BRIF         *
*                                                                     *
***********************************************************************
ISPF23RD STM   R14,R12,12(R13)          SAVE REGISTERS
         LR    R12,R15                  SETUP BASE REGISTER
         USING ISPF23RD,R12             SETUP ADDRESSABILITY
         LR    R8,R1                    SAVE PARM LIST POINTER
         L     R11,12(,R8)              POINT AT COMMON VECTOR TABLE
         L     R11,0(,R11)              POINT AT COMMON VECTOR TABLE
         USING QCOMMON,R11              SETUP ADDRESSABILITY   **ORIG**
         LR    R15,R13                  SAVE OLD SAVE AREA
         L     R13,BRWSAVE              GET SAVE AREA ON INPUT
         AH    R13,2(,R13)              ** see QCALL code in QCOMMON **
         ST    R15,4(,R13)              SAVE OLD POINTER
         ST    R13,8(,R15)              SAVE NEW POINTER
         USING WORK,R13                 SETUP ADDRESSABILITY   **ORIG**
         L     R2,QCCPTR                SET TO CURRENT TABLE POINTER
         L     R1,8(,R8)                GET DESIRED RECORD NUMBER
         L     R1,0(,R1)                GET DESIRED RECORD NUMBER
         CVD   R1,QNUMWORK              GET IT IN DECIMAL
         ZAP   QPREC,QNUMWORK           SET DESIRED RECORD NUMBER
          AIF   (NOT &LD#DBG).LDNDBG7   %%%%%
         TPUTX '>>> ISPF23RD  desired record number =',ASIS    %%%%%%
         UNPK  QNUMWORK,QPREC           %%%%%
         OI    QNUMWORK+7,C'0'          %%%%%
         TPUTX QNUMWORK,8               %%%%%
.LDNDBG7  ANOP                          %%%%%
*---  The )PROC section of the panel sets QBRIFHDR to 'R' to
*---  indicate that it should be rebuilt for the next panel display.
*---  This way it contains info describing the top line of the display.
         TM    QISFLAG1,QIS1V32         running under ISPF V3.2?
         BNZ   I23RD$RP                 yes - skip this kludge
         TM    QMISCFLG,QMFRMAX         need to reset max ind?
         BZ    I23RD$RP                 no so go and use main
         L     R1,4(,R13)               get prev r13 (entry here)
         L     R1,4(,R1)                get r13 on entry to bird
         L     R1,12+12(,R1)            get r1 on entry to bird
         L     R1,4(,R1)                get browse parm list
         MVC   X'68'(4,R1),=F'100000000'  set max number
         NI    X'24D'(R1),255-X'20'     turn off max set
         NI    QMISCFLG,255-QMFRMAX     reset indicator
*
I23RD$RP DC    0H'0'
         L     R9,=A(LISTDS+4096)       and second base
         L     R12,=A(LISTDS)           GET ORIG BASE ADDR
         B     LD$REPOS-LISTDS(,R12)    GO AND REPOSITION
         EJECT
         DROP  ,
***********************************************************************
*                                                                     *
*        CHECK MACRO CODE - USED BY ISPF V1.X -> V2.2                 *
*                                                                     *
*        INPUT                                                        *
*              R1  -->  DECB                                          *
*                                                                     *
***********************************************************************
LSDSCHCK STM   R14,R12,12(R13)          SAVE REGISTERS
         LR    R12,R15                  SETUP BASE REGISTER
         USING LSDSCHCK,R12             SETUP ADDRESSABILITY
         LR    R8,R1                    SAVE DECB POINTER
         USING DECSDECB,R8              SETUP ADDRESSABILITY
         MVI   DECSDECB,X'7F'           POST IT
         L     R15,DECDCBAD             POINT AT DCB
         L     R11,DCBDEBAD-IHADCB(,R15)  POINT AT COMMON VECTOR TABLE
         DROP  R8
         USING QCOMMON,R11              SETUP ADDRESSABILITY   **ORIG**
         USING WORK,R13                 SETUP ADDRESSABILITY   **ORIG**
         LR    R15,R13                  SAVE OLD SAVE AREA
         L     R13,BRWSAVE              GET SAVE AREA ON INPUT
         AH    R13,2(,R13)              ** see QCALL code in QCOMMON **
         ST    R15,4(,R13)              SAVE OLD POINTER
         ST    R13,8(,R15)              SAVE NEW POINTER
         L     R2,QCCPTR                SET TO CURRENT TABLE POINTER
***********************************************************************
*                                                                     *
*   RESET EOF INDICATOR SO MAX WILL ALWAYS FIND NEW END               *
*                                                                     *
***********************************************************************
         L     R1,BRWCBTP               GET COMMON BROWSE TABLE
         TM    QISFLAG1,QIS1V2          IS THIS ISPF VERSION 2?
         BNO   NOTIS2                   no - SKIP V2 CODE
         NI    589(R1),X'DF'            SET EOF INDICATOR OFF *      *
         MVC   104(4,R1),=F'100000000'  SET ORIG RECORD COUNT
         B     DNIS2                    SKIP VERSION 1 CODE
         SPACE 2
NOTIS2   NI    621(R1),X'DF'            SET EOF INIDCATOR OFF
         MVC   140(4,R1),=F'100000000'  SET ORIG RECORD COUNT
         SPACE 2
DNIS2    L     R9,=A(LISTDS+4096)       and second base
         L     R12,=A(LISTDS)           GET ORIG BASE ADDR
         B     LD$REPOS-LISTDS(,R12)    GO AND REPOSITION
***********************************************************************
*                                                                     *
*   EDIF read routine                                                 *
*                                                                     *
*        INPUT                                                        *
*     R1  -->  +0  -->  F'0'  -  TO BE SET TO POINT AT DATA LINE      *
*              +4  -->  F'0'  -  TO BE SET TO LENGTH OF LINE          *
*              +8  -->  F'c'  -  request code:  0=next rec, 1=first   *
*              +12 -->  A(QCOMMON) - ADDRESS PASSED FROM EDIF         *
*                                                                     *
***********************************************************************
LD$ED$RD STM   R14,R12,12(R13)          SAVE REGISTERS
         LR    R12,R15                  copy base register
         USING LD$ED$RD,R12             SETUP ADDRESSABILITY
         LR    R8,R1                    SAVE PARM LIST POINTER
         L     R11,12(,R8)              POINT AT COMMON VECTOR TABLE
         L     R11,0(,R11)              POINT AT COMMON VECTOR TABLE
         USING QCOMMON,R11              SETUP ADDRESSABILITY   **ORIG**
         LR    R15,R13                  SAVE OLD SAVE AREA
         L     R13,BRWSAVE              GET SAVE AREA ON INPUT
         AH    R13,2(,R13)              ** see QCALL code in QCOMMON **
         ST    R15,4(,R13)              SAVE OLD POINTER
         ST    R13,8(,R15)              SAVE NEW POINTER
         USING WORK,R13                 SETUP ADDRESSABILITY   **ORIG**
         L     R2,QCCPTR                SET TO CURRENT TABLE POINTER
         L     R1,8(,R8)                -> request code
         L     R1,0(,R1)                GET DESIRED RECORD NUMBER
         LTR   R1,R1                    is it a "next rec" request?
         BZ    *+10                     yes - continue
         ZAP   QPREC,=P'0'              no - set to first rec
         AP    QPREC,=P'1'              increment record number
          AIF   (NOT &LD#DBG).LDNDBG8   %%%%%
         TPUTX '>>> LD$ED$RD  desired record number =',ASIS    %%%%%%
         UNPK  QNUMWORK,QPREC           %%%%%
         OI    QNUMWORK+7,C'0'          %%%%%
         TPUTX QNUMWORK,8               %%%%%
.LDNDBG8  ANOP                          %%%%%
         L     R9,=A(LISTDS+4096)       and second base
         L     R12,=A(LISTDS)           GET ORIG BASE ADDR
         B     LD$REPOS-LISTDS(,R12)    and go do it
***********************************************************************
*                                                                     *
*   EDIF write routine                                                *
*                                                                     *
***********************************************************************
LD$ED$WR SR    R15,R15                  pretend that it worked
         BR    R14                      and just return
*%%%  Future??  setmsg 'no can do' and rc=16
         POP   USING
***********************************************************************
*                                                                     *
*   MISCELLANY                                                        *
*                                                                     *
***********************************************************************
* TABLE OF PRINTABLE CHARACTERS
         ENTRY CHARTAB
CHARTAB  DC    256C'?'                  TRANSLATE ALL GARBAGE TO '?'
*LDW*    ORG   CHARTAB+X'00'            funny blanks
*LDW*    DC    C' '
         ORG   CHARTAB+C' '             BLANK
         DC    C' '
         ORG   CHARTAB+C''             CENT
         DC    C'.<(+|&&'
         ORG   CHARTAB+C'!'             EXCLAMATION
         DC    C'!$*);-/'
         ORG   CHARTAB+C''             BROKEN BAR
         DC    C',%_>?'
         ORG   CHARTAB+C'`'             ACCENT GRAVE
         DC    C'`:#@''="'
         ORG   CHARTAB+C'A'-X'40'
         DC    X'818283848586878889'
         ORG   CHARTAB+C'J'-X'40'
         DC    X'919293949596979899'
         ORG   CHARTAB+C'S'-X'40'
         DC    X'A2A3A4A5A6A7A8A9'
         ORG   CHARTAB+X'AD'            left square bracket
         DC    X'AD'
         ORG   CHARTAB+X'BD'            right square bracket
         DC    X'BD'
         ORG   CHARTAB+C'A'
         DC    C'ABCDEFGHI'
         ORG   CHARTAB+C'J'
         DC    C'JKLMNOPQR'
         ORG   CHARTAB+C'S'
         DC    C'STUVWXYZ'
         ORG   CHARTAB+C'0'
         DC    C'0123456789'
         ORG   CHARTAB+C'{'             LEFT BRACE
         DC    C'{'
         ORG   CHARTAB+C'}'             RIGHT BRACE
         DC    C'}'
         ORG   CHARTAB+C'~'             TILDE
         DC    C'~'
         ORG   CHARTAB+C'\'             BACKSLASH
         DC    C'\'
         ORG   ,
         SPACE 3
***********************************************************************
*                                                                     *
*        ISPF V3.2 BROWSE INTERFACE COMMAND ROUTINE                   *
*                                                                     *
*        INPUT (Only when invoked under ISPF V3R2)                    *
*     R1  -->  +0  -->  F'10' - Recursive Browse                      *
*                  -->  F'20' - A command not recognized by Browse    *
*              +4  -->  A(QCOMMON) - Address passed from BRIF         *
*                                    (This is not documented except   *
*                                     in the Cobarf example.)         *
*                                                                     *
***********************************************************************
LD$BRIFC STM   R14,R12,12(R13)          SAVE REGISTERS
         LR    R12,R15                  SETUP BASE REGISTER
         USING LD$BRIFC,R12             SETUP ADDRESSABILITY
         L     R15,4(,R1)               -> second parm
         L     R11,0(,R15)              get second parm (@ QCOMMON)
         USING QCOMMON,R11              SETUP ADDRESSABILITY   **ORIG**
         LR    R15,R13                  SAVE OLD SAVE AREA
         L     R13,BRWSAVE              GET SAVE AREA ON INPUT
         AH    R13,2(,R13)              ** see QCALL code in QCOMMON **
         ST    R15,4(,R13)              SAVE OLD POINTER
         ST    R13,8(,R15)              SAVE NEW POINTER
         USING WORK,R13                 SETUP ADDRESSABILITY   **ORIG**
         TM    QISFLAG1,QIS1V32         running under ISPF V3.2?
         BZ    LD$BRIF4                 no - just return
         L     R15,0(,R1)               -> first parm
         CLC   =F'20',0(R15)            is it "cmd not recognized"?
         BE    LD$BRCMD                 yes - go process it
*---  Must be recursive browse
*
LD$BRIF4 L     R13,4(,R13)              dechain save areas
         RETURN  (14,12),RC=4           tell ISPF/PDF to process
*
*
*---  Copy the command from ZCMD
LD$BRCMD LA    R0,QDREPLYL              maximum length
         ST    R0,LD@VLEN               set for VCOPY
         L     R15,ISPLNK
         CALL  (15),(=CL8'VCOPY',=CL8'ZCMD',LD@VLEN,QDREPLY,           $
               =CL8'MOVE'),VL,                                         $
               MF=(E,LD@CALLP)
         L     R0,LD@VLEN               GET LENGTH OF REPLY
         STH   R0,QDRLNG                STORE LENGTH OF REPLY
         L     R1,BRWSAVE               -> LISTDS's work area
         OI    LD@FLAGS-WORK(R1),LD@BRCMD remember we have a new subcmd
*---  Set ZCMD to END to cause browse to terminate
         L     R15,ISPLNK               CALL ISPF INTERFACE
         CALL  (15),(=C'VREPLACE',=C'(ZCMD) ',=F'3',=CL8'END'),        $
               VL,MF=(E,LD@CALLP)
*
         L     R13,4(,R13)              dechain save areas
         LM    R14,R12,12(R13)          restore browse's registers
         SR    R0,R0                    set rc
         BR    R14                      return to browse
         SPACE 2
         LTORG ,
         SPACE 3
WORK     DSECT
         ORG   WORK+72                  SKIP OVER SAVE AREA
LD@VLEN  DS    F                        length for VCOPY
LD@BRLR  DS    F                        lrecl for BRIF
LD@BRQC  DS    A                        -> QCOMMON for BRIF exits
LD@CALLP DS    8A                       CALL MF=L area
LD@FLAGS DS    B
LD@SPIN  EQU   X'80'                    SPIN IOTS HAVE BEEN SEARCHED
LD@NULL  EQU   X'40'                    MATCHING PDDB FOUND W/ PDB1NULL
LD@FOUND EQU   X'20'                    MATCHING RECORD FOUND
LD@MORE  EQU   X'10'                    hanging more msg
LD@FPREC EQU   X'08'                    qprec has been set by find
LD@BRCMD EQU   X'04'                    have subcmd when exiting BROWSE
LD@BYTE1 DS    C                        FLAG BYTE OF RECORD
LD@STPST DC    C'X'                     stopper char
LD@STPDD DS    C'ssssssss/dddddddd'     stepname/ddname
LD@EDITW DS    CL16                     edit and mark workarea
LD@EDIT  EQU   LD@EDITW,8,C'C'          edit len
LD@BUF   DS    CL256                    BROWSE buffer
LD@WORKL EQU   *-WORK
LD@SLREC DS    CL131                    workarea for syslog records
LD@REC   DS    CL300
         SPACE 3
         DROPX R13                      WORK
         SPACE 3
         QCOMMON
         ORG   QDHLINE
          AIF  (&QLEVEL LT 5).LD110
LDHSTPDD DC    C'ssssssss/dddddddd',C' '
.LD110    ANOP ,
         DS    C'DSID '
LDHDSID  DS    CL8
         DS    C'  Col '
LDHCOL   DS    CL3,C
         DS    C'Rec '
LDHREC   DS    CL8
LDHPAGET DS    C' Page '
LDHPAGEN DS    CL8
         DS    C' Line '
LDHLINEN DS    CL4
LDHPAGEL EQU   *-LDHPAGET
         SPACE 3
         Q$LRC
         Q$PDDB
         QZDCBD  ,
         IHADECB ,
         EJECT
*
**       DEFINE POINTERS IN TLD DSECT
*
TLD      DSECT
         ORG   TLD+16
ISRRET   DS    F
         ORG   TLD+52
ISPNM    DS    F
         ORG   TLD+64
ISRNM    DS    F
*
**       DEFINE ACCESS LIST FOR ISP NAMES
*****
*****            FOR ISPF VERSION 2 THE OFFSET IS 4 TOO BIG
*****            CODE HAS BEEN ADDED TO FIX THIS DYNAMICALLY
*****
*
ISPNAME  DSECT
         ORG   ISPNAME+184
ISPCMSG  DS    F
*
**       DEFINE ACCESS LIST FOR ISR NAMES
*****
*****            FOR ISPF VERSION 2 THE OFFSET IS 4 TOO BIG
*****            CODE HAS BEEN ADDED TO FIX THIS DYNAMICALLY
*****
*
ISRNAME  DSECT
         ORG   ISRNAME+32
ISRCBC   DS    F
         ORG   ISRNAME+48
ISRCBR   DS    F
         ORG   ISRNAME+52
ISRCBS   DS    F
*
         INUSE ,
         DROPX ,
