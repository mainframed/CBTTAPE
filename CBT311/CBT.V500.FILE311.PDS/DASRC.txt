./ ADD NAME=$$README 0100-01266-01266-1821-00095-00095-00000-DAVE
 Source library - David Alcock's various apps - Library 1 of 2

 The contents of this file are FREEWARE. Use at your own risk. It
 is provided for your enjoyment and neither David Alcock or his
 employer provides any warranty for their use.  I'd like to hear how
 they work on your system:

    David Alcock :: dave@planetmvs.com

    This package may be obtained at:
    http://www.planetmvs.com/freeware/dasrc.zip

 Package contents:

 - DA.SOURCE - fixed block lrecl 80 library  <------------- This file
   (in zip file as DASRC.XMI)
 - DA.SOURCEV - variable block library
   (in zip file as DASRCV.XMI)

 Note:
 - Some of these programs date back to when I was learning assembler
   and are NOT state-of-the-art assembler code BUT they remain useful
   over 10 years later.
 - Others like DA$ASMHA have very dense code with long ugly labels
   and you really need a machete to cut thru the jungle. Maybe I
   learned a lesson here?

 =====================================================================

 F i l e   C o n t e n t s . . . . . . . . . . . . . . . . . . . . . .

 Member   Description
 ------   -----------
 $$README Text: this file

 #EREP    Doc: Brief startup information for the EREP application

 $ASM     JCL: Sample job to assemble the DA$ programs

 I$EREP   ISPF: ISPF panels for the EREP application

 DA$ASMHA Batch: Assembler H analysis program
 DA$BRODC Batch: SYS1.BRODCAST analysis
 DA$DISKR Batch: Disk Reporter (volume space among other things)
 DA$IDC   Batch: IDCAMS post processing (with no extra I/O)
 DA$PDSR  Batch: PDS report program
 DA$PDSRT Exec:  Processes a DA$PDSR "flatout" file to relink a module
                 if a CSECT is found. See X$PDSRP for sample job.
 DA$SPF2D Batch: Convert an ISPF panel to 3270 Data Stream.  Use to
                 prototype 3270 screens in ISPF.
 DA$W4TCP Batch: Waits for IBM's TCP/IP to come active;

 DA$ENQS  TSOCP: Enqueue display program

 DA$EREP  ISPF: Called by the R$EREP REXX exec to read the LOGREC
                ACCDEV file and create ISPF table entries
 DA$WDATE ISPF: Julian and Gregorian Date conversions
 DA#WDATE ISPF: Panels needed by DA$WDATE (IEBUPDTE format)

 DA$DATE  Subroutine: Date routine
 DA$MXD   Subroutine: Mini-Hex-Dump routine

 DA#DATE  Macro: DSECTs and Equates for the DA$DATE subroutine
 DA#MXD   Macro: DSECTs and Equates for the DA$MXD subroutine
 DA#COBOL Macro: Mapping macro for COBOL eyecatchers

 DA#ENTER Macro: Entry housekeeping (not ESA)
 DA#EYEC  Macro: Create O/S eyecatcher
 DA#LEAVE Macro: Exit housekeeping (not ESA)
 DA#REGS  Macro: Generate register equates
 DA#SMODE Macro: Change addressing modes
 DA#STR   Macro: Generate a Pascal-like string
 DA#TSOS  Macro: TSO Support
 DA#Z00   Macro: Inner - Locate operand
 DA#Z01   Macro: Inner - Generate a label
 DA#Z02   Macro: Inner - Generate a test and branch
 DA#Z04   Macro: Inner - Generate a parameter list
 DA#Z05   Macro: Inner - Generate a branch

 X$ASMHA1 JCL: Sample job to execute the DA$ASMHA program (MVS macros)
 X$ASMHA2 JCL: Sample job to execute the DA$ASMHA program (misc)
 X$BRODC1 JCL: Sample job to execute the DA$BRODC program (report only)
 X$BRODC2 JCL: Sample job to execute the DA$BRODC program (lost mail)
 X$BRODC3 EXEC: Sample Rexx exec to show lost mail
 X$DISKR  JCL: Sample job to execute the DA$DISKR program
 X$IDC    JCL: Sample job to execute the DA$IDC   program
 X$PDSR   JCL: Sample job to execute the DA$PDSR  program
 X$PDSRP  JCL: Sample job to show using the FLATOUT option of DA$PDSR
               to relink a module if the PL/I date routine is found.
 X$SPF2D  JCL: Sample job to execute the DA$SPF2D program
 X$EREP   JCL: Sample job to get LOGREC data ready for the EREP ISPF
               application (program DA$EREP and rexx R$EREP)
 =====================================================================

 May the SOURCE be with you...Obi Wan
./ ADD NAME=$ASM     0102-01266-02289-2351-00162-00178-00000-DALCOCK
//* -- PUT JOB CARD HERE --
//*
//* SEE LINES MARKED WITH "<-" WHICH MIGHT NEED MODIFICATION
//*********************************************************************
//***                                                               ***
//**  SUBROUTINES THAT MIGHT BE LINKED IN LATER                      **
//***                                                               ***
//*********************************************************************
//*
//** ASSEMBLE AND LINK THE DA$DATE PROGRAM
//*
//DA$DATE  EXEC HLASMCL,
//         PARM.C='ASA,SIZE(MAX,ABOVE),NOXREF,BATCH,NORXREF',
//         PARM.L='MAP,RENT,REUS'
//C.SYSLIB DD
//         DD DISP=SHR,DSN=SYS1.MODGEN
//         DD DISP=SHR,DSN=IBMUSER.DA.SOURCE
//C.SYSIN  DD DISP=SHR,DSN=IBMUSER.DA.SOURCE(DA$DATE)
//L.SYSLMOD DD DISP=SHR,DSN=IBMUSER.DA.LOAD(DA$DATE)
//*
//** ASSEMBLE AND LINK THE DA$MXD PROGRAM
//*
//DA$MXD   EXEC HLASMCL,
//         PARM.C='ASA,SIZE(MAX,ABOVE),NOXREF,BATCH,NORXREF',
//         PARM.L='MAP,RENT,REUS'
//C.SYSLIB DD
//         DD DISP=SHR,DSN=SYS1.MODGEN
//         DD DISP=SHR,DSN=IBMUSER.DA.SOURCE
//C.SYSIN  DD DISP=SHR,DSN=IBMUSER.DA.SOURCE(DA$MXD)
//L.SYSLMOD DD DISP=SHR,DSN=IBMUSER.DA.LOAD(DA$MXD)
//*********************************************************************
//***                                                               ***
//**  STAND ALONE PROGRAMS                                           **
//***                                                               ***
//*********************************************************************
//*
//** ASSEMBLE AND LINK DA$ADATA - HLASM ADATA
//*
//DA$ADATA EXEC HLASMCL,
//         PARM.C='ASA,SIZE(MAX,ABOVE),NOXREF,BATCH,NORXREF',
//         PARM.L='MAP,RENT,REUS'
//C.SYSLIB DD
//         DD DISP=SHR,DSN=SYS1.MODGEN
//         DD DISP=SHR,DSN=IBMUSER.DA.SOURCE
//*        DD DISP=SHR,DSN=SYS1.SASMMAC1  <- HLASM MACROS
//*        DD DISP=SHR,DSN=ASM.SASMMAC1   <- HLASM MACROS
//C.SYSIN  DD DISP=SHR,DSN=IBMUSER.DA.SOURCE(DA$ADATA)
//L.SYSLMOD DD DISP=SHR,DSN=IBMUSER.DA.LOAD
//*
//** ASSEMBLE AND LINK DA$BRODC - SYS1.BRODCAST ANALYSIS
//*
//DA$BRODC EXEC HLASMCL,
//         PARM.C='ASA,SIZE(MAX,ABOVE),NOXREF,BATCH,NORXREF',
//         PARM.L='MAP,RENT,REUS'
//C.SYSLIB DD
//         DD DISP=SHR,DSN=SYS1.MODGEN
//         DD DISP=SHR,DSN=IBMUSER.DA.SOURCE
//C.SYSIN  DD DISP=SHR,DSN=IBMUSER.DA.SOURCE(DA$BRODC)
//L.SYSLMOD DD DISP=SHR,DSN=IBMUSER.DA.LOAD(DA$BRODC)
//*
//** ASSEMBLE AND LINK DA$ENQS - WHOHAS ENQUEUE
//*
//DA$ENQS EXEC HLASMCL,
//         PARM.C='ASA,SIZE(MAX,ABOVE),NOXREF,BATCH,NORXREF',
//         PARM.L='MAP,RENT,REUS'
//C.SYSLIB DD
//         DD DISP=SHR,DSN=SYS1.MODGEN
//         DD DISP=SHR,DSN=IBMUSER.DA.SOURCE
//C.SYSIN  DD DISP=SHR,DSN=IBMUSER.DA.SOURCE(DA$ENQS)
//L.SYSLMOD DD DISP=SHR,DSN=IBMUSER.DA.LOAD
//*
//** ASSEMBLE AND LINK DA$EREP - EREP ISPF APPLICATION
//*
//DA$EREP EXEC HLASMCL,
//         PARM.C='ASA,SIZE(MAX,ABOVE),NOXREF,BATCH,NORXREF',
//         PARM.L='MAP,RENT,REUS'
//C.SYSLIB DD
//         DD DISP=SHR,DSN=SYS1.MODGEN
//         DD DISP=SHR,DSN=IBMUSER.DA.SOURCE
//C.SYSIN  DD DISP=SHR,DSN=IBMUSER.DA.SOURCE(DA$EREP)
//L.SYSLMOD DD DISP=SHR,DSN=IBMUSER.DA.LOAD(DA$EREP)
//*L.SISPLOAD DD DISP=SHR,DSN=ISP.SISPLOAD     <- ISPF LOAD LIB
//L.SISPLOAD DD DISP=SHR,DSN=SYS1.ISP.SISPLOAD   <- ISPF LOAD LIB
//*
//** ASSEMBLE AND LINK DA$SPF2D - ISPF TO 3270 DATASTREAM
//*
//DA$SPF2D EXEC HLASMCL,
//         PARM.C='ASA,SIZE(MAX,ABOVE),NOXREF,BATCH,NORXREF',
//         PARM.L='MAP,RENT,REUS'
//C.SYSLIB DD
//         DD DISP=SHR,DSN=SYS1.MODGEN
//         DD DISP=SHR,DSN=IBMUSER.DA.SOURCE
//C.SYSIN  DD DISP=SHR,DSN=IBMUSER.DA.SOURCE(DA$SPF2D)
//L.SYSLMOD DD DISP=SHR,DSN=IBMUSER.DA.LOAD(DA$SPF2D)
//*
//** ASSEMBLE AND LINK DA$IDC - IDCAMS driver/enhancements
//*
//DA$IDC  EXEC HLASMCL,
//         PARM.C='ASA,SIZE(MAX,ABOVE),NOXREF,BATCH,NORXREF',
//         PARM.L='MAP,RENT,REUS'
//C.SYSLIB DD
//         DD DISP=SHR,DSN=SYS1.MODGEN
//         DD DISP=SHR,DSN=IBMUSER.DA.SOURCE
//C.SYSIN  DD DISP=SHR,DSN=IBMUSER.DA.SOURCE(DA$IDC)
//L.SYSLMOD DD DISP=SHR,DSN=IBMUSER.DA.LOAD(DA$IDC)
//*
//** ASSEMBLE AND LINK DA$PDSR - PDS REPORTER
//*
//DA$PDSR EXEC HLASMCL,
//         PARM.C='ASA,SIZE(MAX,ABOVE),NOXREF,BATCH,NORXREF',
//         PARM.L='MAP,RENT,REUS'
//C.SYSLIB DD
//         DD DISP=SHR,DSN=SYS1.MODGEN
//         DD DISP=SHR,DSN=IBMUSER.DA.SOURCE
//C.SYSIN  DD DISP=SHR,DSN=IBMUSER.DA.SOURCE(DA$PDSR)
//L.SYSLMOD DD DISP=SHR,DSN=IBMUSER.DA.LOAD(DA$PDSR)
//*
//** ASSEMBLE AND LINK DA$ASMHA - ASSEMBLER H SYSPRINT SCRAPER
//**
//** NOTE: THE IEFSD095 (IBM BLOCK LETTER ROUTINE) IS OPTIONAL. YOU
//**       WILL GET A LINK EDIT RC = 8 BUT THE PROGRAM WILL EXECUTE
//**       WITHOUT IT.
//*
//DA$ASMHA EXEC HLASMCL,
//         PARM.C='ASA,SIZE(MAX,ABOVE),NOXREF,BATCH,NORXREF',
//         PARM.L='MAP,RENT,REUS'
//C.SYSLIB DD
//         DD DISP=SHR,DSN=SYS1.MODGEN
//         DD DISP=SHR,DSN=IBMUSER.DA.SOURCE
//C.SYSIN  DD DISP=SHR,DSN=IBMUSER.DA.SOURCE(DA$ASMHA)
//L.SYSLMOD DD DISP=SHR,DSN=IBMUSER.DA.LOAD
//*.AOSB0   DD DISP=SHR,DSN=SYS1.AOSB0   OPTIONAL: IEFSD095
//*.AOSB0   DD DISP=SHR,DSN=IBMUSER.OS390R10.SYS1.AOSB0
//L.SYSUDUMP DD SYSOUT=*
//*
//** ASSEMBLE AND LINK DA$DISKR - DASD VOLUME REPORTER
//**
//** NOTE: THE IEFSD095 (IBM BLOCK LETTER ROUTINE) IS OPTIONAL. YOU
//**       WILL GET A LINK EDIT RC = 8 BUT THE PROGRAM WILL EXECUTE
//**       WITHOUT IT.
//*
//DA$DISKR EXEC HLASMCL,
//         PARM.C='ASA,SIZE(MAX,ABOVE),NOXREF,BATCH,NORXREF',
//         PARM.L='MAP,RENT,REUS'
//C.SYSLIB DD
//         DD DISP=SHR,DSN=SYS1.MODGEN
//         DD DISP=SHR,DSN=IBMUSER.DA.SOURCE
//C.SYSIN  DD DISP=SHR,DSN=IBMUSER.DA.SOURCE(DA$DISKR)
//L.SYSLMOD DD DISP=SHR,DSN=IBMUSER.DA.LOAD
//*.AOSB0   DD DISP=SHR,DSN=SYS1.AOSB0   OPTIONAL: IEFSD095
//L.AOSB0   DD DISP=SHR,DSN=IBMUSER.OS390R10.SYS1.AOSB0
//*
//** ASSEMBLE AND LINK DA$WDATE - DATE CONVERSION ISPF APPLICATION
//*
//DA$WDATE EXEC HLASMCL,
//         PARM.C='ASA,SIZE(MAX,ABOVE),NOXREF,BATCH,NORXREF',
//         PARM.L='MAP,RENT,REUS'
//C.SYSLIB DD
//         DD DISP=SHR,DSN=SYS1.MODGEN
//         DD DISP=SHR,DSN=IBMUSER.DA.SOURCE
//C.SYSIN  DD DISP=SHR,DSN=IBMUSER.DA.SOURCE(DA$WDATE)
//L.SYSLMOD DD DISP=SHR,DSN=IBMUSER.DA.LOAD
./ ADD NAME=$CHANGES 0103-01266-02289-1515-00044-00032-00000-DALCOCK
 History of changes - not maintained religiously

 2002-07-18  - DA$W4TCP - Removed from DA.SOURCE.  This is now a standalone
                          program.  It doesn't use the DA macros and doesn't
                          need to be included in this package.  It is
                          available as new program name WAIT4TCP at:

               http://www.planetmvs.com/freeware/wait4tcp.html

 2002-07-10  - DA$PDSRR - Add exec to show using the flatout file to
                          invoke the disassembler to find instruction
                          usage.
 2002-07-10  - X$PDSRR  - Add sample job to show using DA$PDSRR

 2001-09-23  - DA$PDSR  - Small //FLATOUT enhancements
 2001-09-21  - DA$PDSRT - Added exec to DA.SOURCE
 2001-09-21  - X$PDSRP  - Added job stream to DA.SOURCE

 2001-04-23  - DA$IDC   - Added program to DA.SOURCE
 2001-04-23  - *all*    - Added disclaimer

 2000-09-09  - DA$ADATA - Added support for HLASM R3; Removed dep. on
                          my DA$DATE date routine;
 2000-09-09  - DA$DISKR - See modifications history in module;
 2000-09-09  - DA$W4TCP - New program added - wait for a TCP/IP stack
                          to start;
 2000-09-09  - DA#EYEC  - Default to new Time format of standard;
 2000-09-09  - *all*    - Consistent eyecatchers and version variable
                          was added to all programs; Other misc
                          standardization was performed.
 2000-09-09  - $ASM     - Added DA$W4TCP; Added parm for fast asm;

 1999-12-30  - DA$EREP  - Updated for four digit dates (cosmetic)
 1999-09-09  - DA$DATE  - Added ISO date output option
 1999-09-09  - DA$WDATE - New application: Date Conversions

 Opps: Not all changes/updates were logged here!

 21-JUN-1997 - DA$EREP  - Removed Guide/SPF macro library requirement

 02-JAN-1997 - DA$BRODC - Added utility to DA.SOURCE
 02-JAN-1997 - DA$PDSR  - See comments in member
 02-JAN-1997 - $ASM     - Some comments were in error

./ ADD NAME=##EREP   0100-01266-01266-1821-00104-00104-00000-DAVE
NOTE TO DAVE: ADD SDWA FORMATTING, HERE A SAMPLE FROM AN EREP OUTPUT:

HEXADECIMAL DUMP
  HEADER
  +000    40831820    00000000    0098357F    03244239    | C.......Q."....|
  +010    D8110491    90210000                            |Q..J....        |

  JOBNAME
  +000    D7C3C9E2    F8F1F3C4                            |PCIS813D        |

  SDWA BASE
  +000    00000C60    84878000    00000000    00000000    |...-DG..........|
  +010    00000000    00000000    84000000    84878000    |........D...DG..|
  +020    00AFE084    0300E202    02B43000    00000000    |..\D..S.........|
  +030    000000F8    0142B418    01532EE8    00001000    |...8.......Y....|
  +040    00000000    00000000    02C5EA88    00B1DC00    |.........E.H....|
  +050    8142B97C    00000004    00000000    00000000    |A..@............|
  +060    00000000    00000000    040C1000    814559CC    |............A...|
  +070    0002000D    00000000    040C0000    00FF9A88    |...............H|
  +080    0002000D    00000000    84000000    84878000    |........D...DG..|
  +090    00AFE084    0300E202    02B43000    00000000    |..\D..S.........|
  +0A0    000000F8    0142B418    01532EE8    00001000    |...8.......Y....|
  +0B0    00000000    00000000    02C5EA88    00B1DC00    |.........E.H....|
  +0C0    8142B97C    00000004    00000000    00000000    |A..@............|
  +0D0    00000000    00000000    00000000    00000000    |................|
  +0E0    00000000    00000000    040A0001    00000041    |................|
  +0F0    00000000    00FBFAFC    00000000    00800000    |................|
  +100    00000000    00000000    00000000    00000000    |................|
  +110    00000000    00000000    00000000    00000000    |................|
  +120    012C211E    D5E4C3D3    C5E4E240    C9C5C3E5    |....NUCLEUS IECV|
  +130    C5E7E2D4    C9C5C3E5    C5E7C6D9    00FBFAA8    |EXSMIECVEXFR...Y|
  +140    00000000    00000000    00000000    00000000    |................|
  +150    00000000    00000000    00000000    00000000    |................|
  +160    00000000    00000000    00000000    FFFF0006    |................|
  +170    00FBFDF8    00C0012C    0000012C    00000000    |...8.{..........|
  +180    00000000    00000000    00000000    0001DFC7    |...............G|
  +190    00FFE093                                        |..\L            |

  VARIABLE RECORDING AREA (SDWAVRA)

  +000    KEY: 38     LENGTH: 04
  +002    08780878                                        |....            |

  +006    KEY: 10     LENGTH: 18
  +008    00B00500    80083D12    00000000    80010040    |............... |
  +018    00FFC380    00AFE054                            |..C...\.        |

  +020    KEY: 00     LENGTH: 00

  +022    KEY: 12     LENGTH: 38
  +024    00F37FF0    000C8720    00ABA6BC    00ABBE88    |.3"0..G...W....H|
  +034    00000000    00000000    00000000    00000000    |................|
  +044    00000000    80400001    00000000    00000000    |..... ..........|
  +054    80083D12    00000000                            |........        |

  +05C    KEY: 00     LENGTH: 00

  +05E    KEY: 00     LENGTH: 00

  +060    KEY: 00     LENGTH: 00

  +062    KEY: 00     LENGTH: 00

  SDWA FIRST RECORDABLE EXTENSION (SDWARC1)
  +000    E2C3F1C3    F6C5E7C3    D740E2E3    D6D9C1C7    |SC1C6EXCP STORAG|
  +010    C540D4C1    D5C1C7C5    D94B4040    F0F961F1    |E MANAGER.  09/1|
  +020    F961F9F5    40C8C2C2    F6F6F0F1    00000004    |9/95 HBB6601....|
  +030    C9C5C3E5    C5E7C6D9    F5F7F5F2    00000001    |IECVEXFR5752....|
  +040    00000201    00000000    00000000    00FF9A88    |...............H|
  +050    00B00500    80083D12    00000000    80010040    |............... |
  +060    00FFC380    00AFE054    00000000    00000000    |..C...\.........|
  +070    00000000    0000012C    00ABBE88    00181610    |...........H....|
  +080    0A0D18CE    18FB180C    00EA1580    2D15007F    |..............."|
  +090    84878000    00000004    5FB1EE40    2D15007F    |DG......Â¬.. ..."|
  +0A0    32F6DDC0    00C0012C    0000012C    71919B00    |.6.{.{.......J..|
  +0B0    00000000    2D15007F    00000000    00000000    |......."........|
  +0C0    00000000    00000000    047B3253    2D15007F    |.........#....."|
  +0D0    DF8F191E    7F7A7008    00AFB01F    00000000    |....":..........|
  +0E0    00000000    00000000    00000000    00000000    |................|
  +0F0    00000000    00000000    00000000    00000000    |................|
  +100    00000000    00000000    00000000    00000000    |................|
  +110    80AFA03C    00000000    00AFB01F    00000000    |................|
  +120    00000000    00000000    00000000    00000000    |................|
  +130    00000000    00000000    00000000    00000000    |................|
  +140    00000000    00000000    00000000    00000000    |................|
  +150    80AFA03C    00000000    71919B00    00000000    |.........J......|
  +160    00000000    00000000    32F6DF00    00000000    |.........6......|
  +170    00000000    00000000    00000000    00000000    |................|
  +180    00000000    00000000    00000000    00000000    |................|
  +190    00000000    00000000    00000000    00000000    |................|
  +1A0    00000000    7F7A7008    00000000    00000000    |....":..........|
  +1B0    00000000    00000000    00000000    00000000    |................|
  +1C0    C3E2E6F1    40404040                            |XYZ1            |

  SDWA SECOND RECORDABLE EXTENSION (SDWARC2)
  +000    00000000    00000000    00000000    00000000    |................|

  SDWA THIRD RECORDABLE EXTENSION (SDWARC3)
  +000    00000000    00000000    00000000    00000000    |................|
  +010    00000000    00000000    00000000    00000000    |................|

  ERRORID
  +000    211E0041    012C0001    DFC7                    |.........G      |

./ ADD NAME=#DASD    0100-01266-01266-1821-00064-00064-00000-DAVE
Message: 5
   Date: Mon, 22 Jan 2001 19:49:06 +0100 (CET)
   From: "Axel Schwarzer -shw.AXP-" <SchwarzerA@messe-duesseldorf.de> Subject: R

my latest version of the dasd gemetries is this:
---8<---
                          Track     Tracks/  Cylinders/   Volume
Disk                     Capacity  Cylinder    Volume    Capacity
-----------------------  --------  --------  ----------  --------
3330    model I           13,030      19        404        100 M
3330    model II          13,030      19        808        200 M
3350                      19,069      30        555        317 M
3375                      35,616      12        959        409 M
3380    single density    47,476      15        885        630 M
3380    double density    47,476      15      1,770      1,260 M
3380    triple density    47,476      15      2,655      1,890 M


                             CKD DEVICES

              DATA   ALT    TRK/   BYTES/    BYTES/         BYTES/
DISK TYPE     CYLS  CYLS    CYL    TRACK       CYL         MODULE
------------ -----  ----  ------  -------  --------  -------------
2305-1          48     6      8    14,136   113,088      5,428,224
2305-2          96    12      8    14,660   117,280     11,258,880
2311           200     2     10     3,625    36,250      7,250,000
2314           200     3     20     7,294   145,880     29,176,000
3330-1         404     7     19    13,030   247,570    100,018,280
3330-11        808     7     19    13,030   247,570    200,036,560
3340-35        348     1     12     8,368   100,416     34,944,768
3340-70        696     2     12     8,368   100,416     68,889,536
3350           555     5     30    19,069   572,070    317,498,850
3375           959     1     12    35,616   427,392    409,868,928
3380 A/B/D/J   885     1     15    47,476   712,140    630,243,900
3380 E        1770     2     15    47,476   712,140  1,260,487,800
3380 K        2655     3     15    47,476   712,140  1,890,731,700
EMC338OK+     3339     3     15    47,476   712,140  2,377,835,460
EMC338OK++    3993     3     15    47,476   712,140  2,843,575,020
3390-1        1113     1     15    56,664   849,960    946,005,480
3390-2        2226     1     15    56,664   849,960  1,892,010,960
3390-3        3339     1     15    56,664   849,960  2,838,016,440
3390-9       10017     3     15    56,664   849,960  8,514,049,320
9345-1        1440     0     15    46,456   696,840  1,003,449,600
9345-2        2156     0     15    46,456   696,840  1,502,387,040


                            FBA DEVICES

              BYTES/  BLOCKS/   BLOCKS/     BLOCKS/        BYTES/
DISK TYPE     BLOCK    TRACK   CYLINDER   ACTUATOR      ACTUATOR
------------  ------  -------  --------  ----------  ------------
3310             512       32       352     125,664    64,339,968
3370-Al/BI       512       62       744     558,000   285,696,000
3370-A2/B2       512       62       744     712,752   364,929,024
9332-200         512       73       292     360,036   184,338,432
9332-400         512       73       292     360,036   184,338,432
9332-600         512       73       292     554,800   284,057,600
9335             512       71       426     804,714   412,013,568
9336-10          512       63       315     920,115   471,098,880
9336-20/25       512      111       777   1,672,881   856,515,072
---8<---


Mit freundlichem Gruss/Kind regards
./ ADD NAME=#EREP    0100-01266-01266-1821-00017-00017-00000-DAVE
Here is a brief documentation on getting the EREP/LOGREC application
up and running:

- Assemble and link DA$EREP to your load library via $ASM member
  The module DA$DATE is needed and is also assembled via $ASM job.

- Copy userid.DA.SOURCEV(LRS) to your variable blocked SYSPROC
  or SYSEXEC dataset.

- Unload the IEBUPDTE panel source to a panel library. A sample
  job is in the X$EREPU member

- Modify and run member X$EREP to copy LOGREC data from your
  active LOGREC datasets and your saved LOGREC data (if any)
  to a file we can process.

- Invoke the application: LRS DSN 'your.logrec.accdev.file'
./ ADD NAME=DA$ADATA 0101-02289-02289-1533-00958-00951-00000-DALCOCK
DA$ADATA TITLE 'ASMADATA Bootstrap program for REXX ADATA support'
* =================================================================== *
*
*  Name = DA$ADATA
*
*  Author = David Alcock :: dave@planetmvs.com
*
*  Purpose = Build the REXX versions of the ASMADATA DSECTs as a
*            "bootstrap" for further SYSADATA development in REXX.
*
*            Print hex dump of SYSADATA records to aid in the
*            development in REXX
*
*  Files:
*  - SYSPRINT - Utility messages
*  - REXXOUT  - Rexx variable output
*  - SYSADATA - Input SYSADATA file
*
*  Programs called:
*  - DA$MXD...Mini-Hex-Dump
*
*  Non-Standard Macro Usage:
*  - DA#STR   - Generate a string array with byte length (-1)
*  - DA#SMODE - Change addressing mode to and from 24/31
*  - DA$MXD   - Equates and DSECTs for DA$MXD subroutine
*
* Disclaimer: This program is FREEWARE.  Use at your own risk.  It
*             is provided for your enjoyment and neither David
*             Alcock or his employer provides any warranty for it's
*             use.  I'd like to hear how it works on your system.
*
*             This software is not in the public domain but is
*             available free of charge and with source code
*             provided.  It is copyright 2001+ by David Alcock
*             All rights reserved.
*
*  Limitations:
*  - High Level Assembler Macro library: hlq.SASMMAC1
*
*    Note: If you don't have the HLASM 1.3.0 maclib available, you
*    will need to edit the ASMADATA below to remove the new keywords
*    that are not in your relese yet.
*
*  - Tied to internal format of vendor files, must verify at when
*    maintenance and release changes occur.
*  - Program must be assembled with Assembler H or higher
*
* =================================================================== *
         SPACE 2
&DAVER   SETC  '1.7'
*======================================================================
*
*             M o d i f i c a t i o n   H i s t o r y
*
* Person     Date       Ver Description
* ---------- ---------- --- -------------------------------------------
* DGAlcock   2002-10-16 1.7 Added HLASM V4 support;
* DGAlcock   2000-09-09 1.6 Removed DA$DATE date routine dependencies;
* DGAlcock   2000-04-01 1.5 HLASM v3 support;
*                           Remove my Entry & exit housekeeping macs;
*
*======================================================================
         EJECT ,
         PRINT NOGEN
*
** Dave's DSECTs
*
         DA#MXD ,                         Mini-Hex dump routine
*
** IBM dsects and equates
*
         DCBD  DSORG=PS,DEVD=DA           Data Control Block
         CVT  DSECT=YES,LIST=NO           MVS Comm. Vector Table
         YREGS ,                          Register equates
         PRINT GEN
*
** HLASM DSECTs
**
** Delete lines if not on latest HLASM maclib
*
      ASMADATA PRINT=GEN,JID=YES,OPT=YES,ESD=YES,SOURCE=YES,    V1.1.0 @       X
               SRCERR=YES,DCDS=YES,MACH=YES,SYM=YES,XREF=YES,   V1.1.0 @
               USING=YES,RLD=YES,MXREF=YES,STATS=YES,           V1.1.0 @
               MXREFX=YES,OUTPUT=YES,USER=YES,AID=YES,          V1.2.0 @
               COMPUNIT=YES,DCDSX=YES,                          V1.2.0 @
               RXREF=YES,                                       V1.3.0 @
               AOPT=YES                                         V1.4.0
*
** Map the T_RT table
*
TRT        DSECT ,
TRT_ID     DS    CL6
TRT_VALUE  DS    XL2
TRT_DESC   DS    XL2
TRT_CL     EQU   *-TRT
TRT_COUNT  DS    XL4
TRTL       EQU   *-TRT
*
** Convert assembly date from format "YYYYMMDD" to "YYYY-MM-DD"
*
         LCLC  &ASMDATE
&ASMDATE SETC  '&SYSDATC'(1,4).'-'.'&SYSDATC'(5,2).'-'.'&SYSDATC'(7,2)
         EJECT
***********************************************************************
***
**       Initialization
***
***********************************************************************
         SPACE 2
DA$ADATA CSECT ,
DA$ADATA AMODE 24
DA$ADATA RMODE 24
*
** Standard O/S eyecatcher
*
AD_EC    B    AD_ECL(0,R15)             Bump past EyeCatcher
         DC   AL1(AD_ECE-AD_ECV)        Length of eyecatcher
AD_ECV   DC   C'DA$ADATA '
AD_ECD   DC   C'&ASMDATE'
         DC   C' '
AD_ECT   DC   C'&SYSTIME'
         DC   C' V&DAVER '
         DC   C'Utility: Process HLASM SYSADATA for REXX bootstrap'
AD_ECE   EQU  *
         DS   0H
AD_ECL   EQU  *-AD_EC
*
** Standard ESA entry housekeeping code
*
         BAKR  R14,0                    Save registers
         LAE   R12,0(R15,0)             Get base register
         LAE   R11,2048(,R12)           Set up for second base reg
         LA    R11,2048(,R11)           Locate 4096 past R12
         LAE   R10,2048(,R11)           Set up for third base reg
         LA    R10,2048(,R10)           Locate 4096 past R11
         USING DA$ADATA,R12,R11,R10     Set module base
         SAC   0
         SYSSTATE ASCENV=P
         EREG  R0,R1
*
** Obtain Dynamic Save Area
*
         STORAGE OBTAIN,LENGTH=DSAL,LOC=BELOW Obtain storage
         LR    R13,R1                   Point to Save Area
*
         LR    R14,R13                  To: Address
         L     R15,=A(DSAL)             To: Length
         SLR   R1,R1                    From: Set length and pad
         MVCL  R14,R0                   Zero out area
*
         MVC   4(4,R13),=C'F1SA'        Indicate stack SA
         USING DSA,R13                  Get addressibility to area
*
         BAS   R9,Get_Current_Time_Date Get time and date for rpts
*
** Initlialize record table
*
         LA    R0,T_RTN+1                 Set number in table
         LA    R1,T_RT                    Locate constants table
         LA    R14,X_RT                   Locate variable table
IRT$L    EQU   *
         MVC   0(TRT_CL,R14),0(R1)        Move constants part
         LA    R1,TRT_CL(R1)              Bump to next entry
         LA    R14,TRTL(R14)              Bump to next entry
         BCT   R0,IRT$L
*
** Open the messages file
*
         LA    R3,SYSPRINT
         MVC   0(C_DCBOL,R3),C_DCBO       Copy in DCB constant
         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'SYSPRINT'
         MVC   PARMLIST(C_LSTOL),C_LSTO   Copy in OPEN parm list
         OPEN  ((3),(OUTPUT)),            Open the file                @
               MF=(E,PARMLIST)
         MVI   PSR_LC,99                  Force heading on first record
*
         BAS   R14,FORMAT_MESSAGE         Format the message
         MVC   0(MSG0L,R15),MSG0          Get message
         LA    R15,MSG0L+1(R15)           Bump past text
         MVC   0(L'AD_ECD,R15),AD_ECD
         LA    R15,L'AD_ECD+1(R15)
         MVC   0(L'AD_ECT,R15),AD_ECT
         LA    R15,L'AD_ECT(R15)
         MVC   0(2,R15),=C').'
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message on SYSPRINT
         BAS   R14,CLEAR_RECOUT           Clear recout to blanks
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message on SYSPRINT
*
** Open the output REXX file
*
         DEVTYPE =CL8'REXXOUT',DOUBLE     Get DD allocation info
         LTR   R15,R15                    Is FILE=REXXOUT allocated?
         BNZ   I$ROND                     No, leave
         LA    R3,REXXOUT                 Locate DCB work area
         MVC   0(C_DCBOL,R3),C_DCBO       Copy in DCB constant
         NI    DCBRECFM-IHADCB(R3),255-DCBRECCA  Not ASA!!!
         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'REXXOUT'
         MVC   PARMLIST(C_LSTOL),C_LSTO   Copy in OPEN parm list
         OPEN  ((3),(OUTPUT)),            Open the file                @
               MF=(E,PARMLIST)
         LTR   R15,R15
         BNZ   I$ROE
*
         MVI   RECOUT,C' '
         MVC   RECOUT+1(133-1),RECOUT
         LA    R15,RECOUT
         MVC   0(C_HDR1L,R15),C_HDR1
         PUT   REXXOUT,RECOUT
*
         LA    R15,RECOUT
         MVC   0(C_HDR2L,R15),C_HDR2
         PUT   REXXOUT,RECOUT
*
         LA    R15,RECOUT
         MVI   0(R15),C' '
         MVC   1(C_HDR2L,R15),0(R15)
         MVC   0(C_HDR3L,R15),C_HDR3
         LA    R15,C_HDR3L+1(R15)
         MVC   0(L'AD_ECD,R15),AD_ECD
         LA    R15,L'AD_ECD+1(R15)
         MVC   0(2,R15),=C'at'
         LA    R15,3(R15)
         MVC   0(L'AD_ECT,R15),AD_ECT
         PUT   REXXOUT,RECOUT
*
         LA    R15,RECOUT
         MVI   0(R15),C' '
         MVC   1(70,R15),0(R15)
         MVC   0(C_HDR4L,R15),C_HDR4
         LA    R15,C_HDR4L+1(R15)
         MVC   0(L'X_DATE,R15),X_DATE
         LA    R15,L'X_DATE+1(R15)
         MVC   0(2,R15),=C'at'
         LA    R15,3(R15)
         MVC   0(L'X_TIME,R15),X_TIME
         LA    R15,L'X_TIME+1(R15)
         PUT   REXXOUT,RECOUT
         LA    R15,RECOUT
         MVI   0(R15),C' '
         MVC   1(70,R15),0(R15)
         MVC   0(C_HDR5L,R15),C_HDR5
         PUT   REXXOUT,RECOUT
         B     I$ROX
I$ROE    EQU   *
         BAS   R14,FORMAT_MESSAGE         Format the message
         MVC   0(MSG4L,R15),MSG4          Get message
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message on SYSPRINT
I$ROND   EQU   *
         OI    X_FLAG1,$XF1_NRO
I$ROX    EQU   *
*
** Open_SYSADATA_File
*
OPEN_SYSADATA_FILE EQU *
         DEVTYPE =CL8'SYSADATA',DOUBLE    Get DD allocation info
         LTR   R15,R15                    Is FILE=SYSADATA allocated?
         BNZ   OSIF$ND                    No, leave
         LA    R3,SYSADATA                Locate DCB work area
         MVC   0(C_DCBIL,R3),C_DCBI       Copy in DCB constant
         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'SYSADATA' Insert DDNAME
         LA    R1,PSF$EOF
         STCM  R1,B'0111',DCBEODAD-IHADCB+1(R3) Insert EOF routine
*
         MVC   PARMLIST(C_LSTIL),C_LSTI   Get input parm list
         OPEN  ((3),(INPUT)),             Open BKLID file              @
               MF=(E,PARMLIST)            ..with parm list
         LTR   R15,R15                    Good open?
         BZ    OSIF$X                     No, gripe about it
         BAS   R14,FORMAT_MESSAGE         Format the message
         MVC   0(MSG2L,R15),MSG2          Get message
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message on SYSPRINT
         B     EXIT
OSIF$ND  EQU   *
         BAS   R14,FORMAT_MESSAGE         Format the message
         MVC   0(MSG3L,R15),MSG3          Get message
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message on SYSPRINT
         MVI   X_MAXCC,20
         B     EXIT
OSIF$X   EQU   *
         EJECT
***********************************************************************
***
**       Process the SYSADATA file
***
***********************************************************************
         SPACE 2
PROCESS_SYSADATA_FILE EQU *
PSF$L    EQU   *
         GET   SYSADATA                   Get record
         LR    R8,R1                      Save address of Record
         SLR   R7,R7                      Clear register
         ICM   R7,B'0011',0(R8)           Get record length
*
         L     R1,PSF_RECR                Get count
         LA    R1,1(R1)                   Increment by 1
         ST    R1,PSF_RECR                Save it
*
** Save trivia about number of records found
*
         LA    R2,X_RT
         LA    R3,T_RTN
PSF$LRL  EQU   *
         CLC   ADATA_RECTYPE-ASMADATA(2,R8),TRT_VALUE-TRT(R2) Match?
         BE    PSF$LRLF
         LA    R2,TRTL(R2)
         BCT   R3,PSF$LRL
PSF$LRLF EQU   *
         SLR   R1,R1
         ICM   R1,B'1111',TRT_COUNT-TRT(R2)
         LA    R1,1(R1)
         STCM  R1,B'1111',TRT_COUNT-TRT(R2)
*
** Print Mini-Hex Dump of record
*
         TM    X_FLAG1,$XF1_NMXD          Have routine?
         BO    PSF$LMX                    No, continue
         ICM   R1,B'1111',EP_DA$MXD       Have routine?
         BNZ   PSF$LMS                    Yes, continue
         ICM   R0,B'1111',=V(DA$MXD)      Linked into us?
         BNZ   PSF$LMLX                   Yes, use it
         LOAD  EPLOC==CL8'DA$MXD',ERRET=PSF$LME No, load it
         OI    X_FLAG1,$XF1_LDA$MXD       Say we had to load it
PSF$LMLX DS    0H
         ST    R0,EP_DA$MXD               Save entry point
         B     PSF$LMS                    ..and continue
PSF$LME  EQU   *
         OI    X_FLAG1,$XF1_NMXD          Never had it, Never will
         B     PSF$LMX                    Continue
PSF$LMS  EQU   *
         BAS   R14,CLEAR_RECOUT
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message on SYSPRINT
*
         BAS   R14,FORMAT_MESSAGE         Format the message
         MVC   0(MSG80L,R15),MSG80        Get message
         LA    R15,MSG80L(R15)            Bump past it
         UNPK  0(5,R15),TRT_VALUE-TRT(3,R2)
         MVZ   0(4,R15),=8X'00'
         TR    0(4,R15),=C'0123456789ABCDEF'
         LA    R15,4(R15)
         MVC   0(3,R15),=C''' -'
         LA    R15,4(R15)
         SLR   R1,R1
         ICM   R1,B'0011',TRT_DESC-TRT(R2)
         AR    R1,R12
         SLR   R14,R14
         IC    R14,0(R1)
         EX    R14,PSF$LMM
         LA    R15,2(R14,R15)             Bump past record type
*
         CLC   ADATA_RECTYPE-ASMADATA(2,R8),T_RTSRC+(TRT_VALUE-TRT)
         BE    PSF$LMSN$SRC
         CLC   ADATA_RECTYPE-ASMADATA(2,R8),T_RTSYM+(TRT_VALUE-TRT)
         BE    PSF$LMSN$SYM
         CLC   ADATA_RECTYPE-ASMADATA(2,R8),T_RTXREF+(TRT_VALUE-TRT)
         BE    PSF$LMSN$XREF
         B     PSF$LMSNX
PSF$LMSN$SRC EQU *
         ICM   R1,B'1111',ADSRC_STMT-ASMADATA(R8)
         B     PSF$LMSNP
PSF$LMSN$SYM EQU *
         ICM   R1,B'1111',ADSYM_STMT-ASMADATA(R8)
         B     PSF$LMSNP
PSF$LMSN$XREF EQU *
         ICM   R1,B'1111',ADXREF_STMT-ASMADATA(R8)
PSF$LMSNP EQU  *
         MVC   0(19,R15),=C'- Statement-Number='
         LA    R15,19(R15)
         BAS   R9,EDITFWF
PSF$LMSNX EQU *
         L     R1,PSF_RECR                Get count
         MVC   0(17,R15),=C' - Record-Number='
         LA    R15,17(R15)
         BAS   R9,EDITFWF
*
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message on SYSPRINT
*
         XC    W_DA$MXD(CMXDL),W_DA$MXD Initialize parm area
         LR    R15,R8                     Locate area to print
         SLR   R0,R0                      Clear register
         ICM   R0,B'0011',0(R8)           Get length of record
         LA    R1,RECOUT+1+9+MSG81L+1     Locate output record
         STM   R15,R1,W_DA$MXD+CMXD_ADDRESS-CMXD Data, Length, Output
         MVC   W_DA$MXD+CMXD_OUTPUTL-CMXD(2),=AL2(133)   Longer
PSF$LML  EQU   *
         BAS   R14,FORMAT_MESSAGE         Format the message
         MVC   0(MSG81L,R15),MSG81        Get message
         LA    R1,W_DA$MXD                Locate work area
         L     R15,EP_DA$MXD              -> DA$MXD E.P.A.
         BASSM R14,R15                    Call DA$MXD
         LR    R6,R15                     Save return code
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message on SYSPRINT
         LTR   R6,R6                      Any more lines to do...
         BNZ   PSF$LML                    Thank you: May I have another
         B     PSF$LMX
PSF$LMM  MVC   0(0,R15),1(R1)
PSF$LMX  EQU   *
.PSFMXDX ANOP  ,
*
** Branch to routines for this record type
*
         CLC   ADATA_RECTYPE-ASMADATA(2,R8),T_RTSYM+(TRT_VALUE-TRT)
         BE    PSF$SYM
         CLC   ADATA_RECTYPE-ASMADATA(2,R8),T_RTSRC+(TRT_VALUE-TRT)
         BE    PSF$SRC
         B     PSF$L
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Source record
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
PSF$SRC  EQU   *
         BAS   R14,FORMAT_MESSAGE         Format the message
         MVC   0(MSG82L,R15),MSG82        Get message
         LA    R15,MSG82L(R15)            Bump past it
         MVC   0(L'ADSRC_RECORD,R15),ADSRC_RECORD-ASMADATA(R8)
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message on SYSPRINT
         B     PSF$L
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Symbol record
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
PSF$SYM  EQU   *
         TM    X_FLAG1,$XF1_NRO       REXXOUT available
         BO    PSF$L                  No, skip this code
         MVI   RECOUT,C' '
         MVC   RECOUT+1(133-1),RECOUT
         LA    R15,RECOUT
         MVC   0(2,R15),=C'o_'
         LA    R15,2(R15)
         SLR   R14,R14
         ICM   R14,B'0011',ADSYM_NAME_LEN-ASMADATA(R8)
         BCTR  R14,0
         EX    R14,PSFSYM$M
         LA    R15,2(R14,R15)
         MVI   0(R15),C'='
         LA    R15,2(R15)
         LR    R4,R15
         LA    R5,9(R15)
         ICM   R1,B'1111',ADSYM_LOCTR-ASMADATA(R8)
         BAS   R9,EDITFWF
         LR    R15,R5
         MVC   0(2,R15),=C'/*'
         LA    R15,3(R15)
         MVC   0(2,R15),=C'x'''
         LA    R15,2(R15)
         UNPK  0(9,R15),ADSYM_LOCTR-ASMADATA(5,R8)
         MVZ   0(8,R15),=8X'00'
         TR    0(8,R15),=C'0123456789ABCDEF'
         MVI   8(R15),X'7D'
         LA    R15,10(R15)
         MVC   0(2,R15),=C'*/'
         PUT   REXXOUT,RECOUT
*
         MVI   RECOUT,C'l'              Make it "l_name" from "o_name"
         LR    R15,R4                   Get output location
         MVI   0(R15),C' '
         MVC   1(32,R15),0(R15)
         SLR   R1,R1
         ICM   R1,B'0011',ADSYM_BYTE_LEN-ASMADATA(R8)
         BAS   R9,EDITFWF
         PUT   REXXOUT,RECOUT
*
         B     PSF$L
*
PSFSYM$M MVC   0(0,R15),ADSYM_NAME-ASMADATA(R8)
*
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** End of file on SYSADATA file
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
PSF$EOF  EQU   *
*
** Print stats
*
         BAS   R14,CLEAR_RECOUT           Clear recout to blanks
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message on SYSPRINT
         LA    R2,X_RT
         LA    R3,T_RTN+1
PSF$ERL  EQU   *
         BAS   R14,FORMAT_MESSAGE         Format the message
         MVC   0(MSG10L,R15),MSG10        Get message
         LA    R15,MSG10L(R15)            Bump past it
         SLR   R1,R1
         ICM   R1,B'1111',TRT_COUNT-TRT(R2)
         BAS   R14,EDIT15                 Edit it to message
         LA    R15,16(R15)
         MVI   0(R15),C'-'
         LA    R15,2(R15)
         SLR   R1,R1
         ICM   R1,B'0011',TRT_DESC-TRT(R2)
         AR    R1,R12
         SLR   R14,R14
         IC    R14,0(R1)
         EX    R14,PSF$EM
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message on SYSPRINT
         LA    R2,TRTL(R2)
         BCT   R3,PSF$ERL
         B     PSF$ERLX
PSF$EM   MVC   0(0,R15),1(R1)
PSF$ERLX EQU   *
         EJECT
***********************************************************************
***
**       Termination section
***
***********************************************************************
         SPACE 2
EXIT     EQU   *
         BAS   R14,CLEAR_RECOUT           Clear recout to blanks
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message on SYSPRINT
         BAS   R14,FORMAT_MESSAGE         Format the message
         MVC   0(MSG99L,R15),MSG99        Get message
         LA    R15,MSG99L+1(R15)          Bump past it
         SLR   R1,R1                      Clear register to zeros
         IC    R1,X_MAXCC                 Get maximum condition code
         BAS   R9,EDITFWF                 Edit it to message
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message on SYSPRINT
         BAS   R14,CLEAR_RECOUT           Clear recout to blanks
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message on SYSPRINT
*
** Delete loaded routines
*
         TM    X_FLAG1,$XF1_LDA$MXD       Did we load it?
         BNO   X$MXDX                     No, continue
         ICM   R0,B'1111',EP_DA$MXD       Did we load it
         BZ    X$MXDX                     No, continue
         DELETE EPLOC==CL8'DA$MXD'        Delete module
X$MXDX   EQU   *
*
** Close the files
*
         LA    R3,SYSPRINT
         MVC   PARMLIST(C_CLSL),C_CLS     Move in CLOSE parameter list
         CLOSE ((3)),MF=(E,PARMLIST)      Close file
         LA    R3,REXXOUT
         MVC   PARMLIST(C_CLSL),C_CLS     Move in CLOSE parameter list
         CLOSE ((3)),MF=(E,PARMLIST)      Close File
         LA    R3,SYSADATA
         MVC   PARMLIST(C_CLSL),C_CLS     Move in CLOSE parameter list
         CLOSE ((3)),MF=(E,PARMLIST)      Close File
*
** Return to caller
*
         LR    R2,R13                     Get storage address
         SLR   R3,R3
         IC    R3,X_MAXCC
         STORAGE RELEASE,LENGTH=DSAL,ADDR=(R2) Release storage
         LR    R15,R3                     Set return code
         PR    ,                          Return to caller
         EJECT
***********************************************************************
***
**       Misc Internal subroutines
***
***********************************************************************
         SPACE 2
*
** Get Current Time and Date
*
Get_Current_Time_Date ds 0h
*-Obtain the time via the STCK instruction and format it
         STCK  STCKCONI                   Get current time stamp
*-Adjust for GMT time. Based on SYS1.V2R5M0.SHASSRC(HASCSRIC)
         LM    R2,R3,STCKCONI      Get it
         L     R5,CVTPTR           Get CVT addressability
         L     R5,CVTEXT2-CVT(,R5)  Get address of extension
         LM    R14,R15,CVTLDTO-CVTXTNT2(R5)  Time zone diff
         LM    R6,R7,CVTLSO-CVTXTNT2(R5)  Get leap seconds
         ALR   R3,R15              Add low order time offset
         BC    12,GCTD$NOV         Branch if no overflow
         AL    R2,=F'1'            Carry the 1
GCTD$NOV ALR   R2,R14              Add high order words
         SLR   R3,R7               Subtract low-order leap seconds
         BC    3,GCTD$NOB          Branch if no borrow
         BCTR  R2,0                Subtract one for borrow
GCTD$NOB SLR   R2,R6               Subtract high-order leap seconds
         STM   R2,R3,STCKCONI      Save adjusted time stamp
*-Convert the time stamp from the STCK instruction
         STCKCONV STCKVAL=STCKCONI,       Convert this TOD Stamp       @
               CONVVAL=STCKCONO,          ..Into these date/time areas @
               TIMETYPE=DEC,              ..Output time format         @
               DATETYPE=YYYYMMDD,         ..Output Date format         @
               MF=(E,PARMLIST)
         LTR   R15,R15                    STCKCONV worked?
         BNZ   GCTD$ES                    Failed, ABEND me
*-Format the returned time
         UNPK  DOUBLE2(9),STCKCONO(5)
         MVZ   DOUBLE2(8),=8X'00'
         TR    DOUBLE2(8),=C'0123456789ABCDEF'
         UNPK  DOUBLE2+8(9),STCKCONO+4(5)
         MVZ   DOUBLE2+8(8),=8X'00'
         TR    DOUBLE2+8(8),=C'0123456789ABCDEF'
         MVI   DOUBLE2+16,C' '
*
         MVC   X_TIME(2),DOUBLE2
         MVI   X_TIME+2,C':'
         MVC   X_TIME+3(2),DOUBLE2+2
         MVI   X_TIME+5,C':'
         MVC   X_TIME+6(2),DOUBLE2+4
*-Format the returned date
         UNPK  DOUBLE2(9),STCKCONO+8(5)
         MVZ   DOUBLE2(8),=8X'00'
         TR    DOUBLE2(8),=C'0123456789ABCDEF'
         UNPK  DOUBLE2+8(9),STCKCONO+8+4(5)
         MVZ   DOUBLE2+8(8),=8X'00'
         TR    DOUBLE2+8(8),=C'0123456789ABCDEF'
         MVI   DOUBLE2+16,C' '
*                                         0123456789   01234567
         MVC   X_DATE(4),DOUBLE2         "CCYY      " "CCYYmmdd"
         MVI   X_DATE+4,C'-'             "CCYY-     "
         MVC   X_DATE+5(2),DOUBLE2+4     "CCYY-MM   " "ccyyMMdd"
         MVI   X_DATE+7,C'-'             "CCYY-MM-  "
         MVC   X_DATE+8(2),DOUBLE2+6     "CCYY-MM-DD" "ccyymmDD"
         B     GCTD$X
GCTD$ES  DS    0H
         MVC   X_TIME(8),=CL11'notavail'
         MVC   X_DATE(11),=CL11'notavail'
GCTD$X   DS    0H
         BSM   0,R9
*
** Edit full word in Register 1 flush at location in Register 15
** INPUT: R1 - Register to print
**        R15 - Address to put number
*
EDITFWF  EQU   *
         LTR   R1,R1                      Check for zero
         BZ    EDITFWF0                   Yes, save cpu time
         CVD   R1,DOUBLE                  No, convert to packed
         LA    R1,DOUBLE2+14              Locate Sig digit
         MVC   DOUBLE2(15),EDITFWFP       Move in edit pattern
         EDMK  DOUBLE2(15),DOUBLE+2       Edit and save place
         LA    R14,DOUBLE2+16             Locate last possible byte + 1
         SR    R14,R1                     Length = end - start
         BCTR  R14,0                      Decrement for EX
         EX    R14,EDITFWFM               Move edit number to output
         LA    R15,0(R14,R15)             Bump pointer past number
         MVI   0(R15),C' '                Insert space after number
         BSM   0,R9                       Return to caller
EDITFWFM MVC   0(0,R15),0(R1)
EDITFWFP DC    X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'
EDITFWF0 DS    0H
         MVI   0(R15),C'0'                Insert zero
         LA    R15,1(R15)                 Bump past zero
         BSM   0,R9                       Return to caller
*
**  EDIT FULLWORD
**   INPUT:  R1  ADDRESS OF FULLWORD
**   OUTPUT: R15 ADDRESS OF OUTPUT (4 BYTES)
*
EDITFW4  DS    0H
         CVD   R1,DOUBLE             GET IN DECIMAL
         MVC   0(4,R15),=X'40,20,20,20'
         ED    0(4,R15),DOUBLE+6     FORMAT PERCENTAGE
         OI    3(R15),C'0'           ENSURE NUMERICS
         BSM   0,R14
*
** Edit number
** INPUT:  R1 - VALUE TO EDIT
**         R15 - ADDRESS TO PUT PATTERN
*
EDIT15   DS    0H
         CVD   R1,DOUBLE                  Convert to packed
         MVC   0(15,R15),EDITP15          Get edit pattern
         ED    0(15,R15),DOUBLE+2         Edit number
         OI    14(R15),C'0'               Ensure zero
         BSM   0,R14                      Return to caller
EDITP15  DC    X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'
         DS    0H
*
** Point Register 15 to the first blank in a string
** Input:  R0  - Maximum length of the string
**         R15 - String
** Output: R15 - First space in the string
*
LOCATE_FIRST_SPACE EQU *
         CLI   0(R15),C' '                Blank?
         BE    LFS$X                      Yes, leave
         LA    R15,1(R15)                 No, bump to next byte
         BCT   R0,LOCATE_FIRST_SPACE      ..Repeat
LFS$X    EQU   *
         BSM   0,R14                      Return to caller
*
** Format RECOUT for message
*
FORMAT_MESSAGE EQU *
         LA    R15,RECOUT
         MVI   0(R15),C' '
         MVC   1(L'RECOUT-1,R15),0(R15)
         LA    R15,1(R15)                 Bump past FBA byte
         MVC   0(8,R15),5(R12)            "DA$ADATA" from DA#ENTER
         MVI   8(R15),C'-'
         LA    R15,8+1(R15)
         BSM   0,R14
*
** Print record on file=SYSPRINT
*
PRINT_SYSPRINT_RECORD EQU *
         ST    R9,PSR_RA                  Save return address
         CLI   PSR_LC,55
         BNH   PSR$HX
*
         BAS   R14,CLEAR_HEADREC
         MVI   0(R15),C'1'
         LA    R15,1(R15)
         MVC   0(8,R15),AD_ECV            Get name from module eyecatr
         LA    R0,8
         BAS   R14,LOCATE_FIRST_SPACE
         MVC   1(20,R15),=C'- Utility messages -'
         LA    R15,1+20+1(R15)            Bump past it
         L     R1,CVTPTR                  Locate to CVT
         MVC   0(L'CVTSNAME,R15),CVTSNAME-CVTMAP(R1)
         LA    R0,L'CVTSNAME              Set length of field
         BAS   R14,LOCATE_FIRST_SPACE     Look for first space
         MVI   1(R15),C'-'                Insert delimiter
         LA    R15,1+1+1(R15)             Bump past it
         MVC   0(L'X_DATE,R15),X_DATE
         LA    R15,L'X_DATE+1(R15)
         MVC   0(L'X_TIME,R15),X_TIME
         LA    R15,L'X_TIME+1(R15)
         MVC   0(6,R15),=C'- Page'        Insert text
         LA    R15,7(R15)                Bump past it
         L     R1,PSR_PC                  Get page count
         LA    R1,1(R1)                   Increment
         ST    R1,PSR_PC                  SAVE IT
         BAS   R9,EDITFWF                 Edit the page number
         PUT   SYSPRINT,HEADREC           Print heading record
*
         BAS   R14,CLEAR_HEADREC
         PUT   SYSPRINT,HEADREC
         MVI   PSR_LC,0
PSR$HX   EQU   *
         SLR   R1,R1
         IC    R1,PSR_LC                  Get line count
         LA    R1,1(R1)                   Increment by 1
         STC   R1,PSR_LC                  Save line count
         PUT   SYSPRINT,RECOUT            Print record
*
         L     R9,PSR_RA                  Get return address
         BSM   0,R9                       Return to caller
*
** Clear heading record to blanks
*
CLEAR_HEADREC EQU *
         LA    R15,HEADREC                Locate output record
         MVI   0(R15),C' '                Get Blank
         MVC   1(L'HEADREC-1,R15),0(R15) ..Propagate it
         BSM   0,R14                      Return to caller
*
** CLEAR RECOUT TO BLANKS
*
CLEAR_RECOUT EQU *
         LA    R15,RECOUT                 Locate output Record
         MVI   0(R15),C' '                Get blank
         MVC   1(L'RECOUT-1,R15),0(R15)   ..Propagate it
         LA    R15,1(R15)                 Bump past FBA byte
         BSM   0,R14                      Leave
         EJECT
***********************************************************************
***
**       Data Constants
***
***********************************************************************
         SPACE 2
MSG0     DC    C'00I Execution begins. (Program assembled:'
MSG0L    EQU   *-MSG0
MSG2     DC    C'02E Open failed to SYSADATA file'
MSG2L    EQU   *-MSG2
MSG3     DC    C'03E Required file not allocated: '
MSG3SL   EQU   *-MSG3
         DC    C'SYSADATA'
MSG3L    EQU   *-MSG3
MSG4     DC    C'04W Open failed to REXXOUT file, proceding without it'
MSG4L    EQU   *-MSG4
*
MSG10    DC    C'04I Number of records:'
MSG10L   EQU   *-MSG10
*
MSG80    DC    C'80I Record dump of type=x',X'7D'
MSG80L   EQU   *-MSG80
MSG81    DC    C'81I'
MSG81L   EQU   *-MSG81
MSG82    DC    C'82I Source record: '
MSG82L   EQU   *-MSG82
*
MSG99    DC    C'99I Execution ends. Maximum condition code was'
MSG99L   EQU   *-MSG99
*
** Misc constants
*
C_HDR1   DC    C'/*'
C_HDR1L  EQU   *-C_HDR1
*
C_HDR2   DC    C' | This Rexx code was created by program DA$ADATA'
C_HDR2L  EQU   *-C_HDR2
*
C_HDR3   DC    C' | which was assembled on'
C_HDR3L  EQU   *-C_HDR3
*
C_HDR4   DC    C' | This output created on'
C_HDR4L  EQU   *-C_HDR4
*
C_HDR5   DC    C' */'
C_HDR5L  EQU   *-C_HDR5
*
** Macro copies
*
         PRINT NOGEN
C_CLS    CLOSE (*-*),MF=L
C_CLSL   EQU   *-C_CLS
C_LSTI   OPEN  (*-*,(INPUT)),MF=L
C_LSTIL  EQU   *-C_LSTI
C_LSTO   OPEN  (*-*,(OUTPUT)),MF=L
C_LSTOL  EQU   *-C_LSTO
C_DCBO   DCB   DDNAME=C_DCBO,                                          @
               DSORG=PS,MACRF=PM,RECFM=FBA,LRECL=133
C_DCBOL  EQU   *-C_DCBO
C_DCBI   DCB   DDNAME=C_DCBI,                                          @
               DSORG=PS,MACRF=GL,EODAD=*-*,RECFM=VB
C_DCBIL  EQU   *-C_DCBI
*
         PRINT DATA
*
** ASMADATA record type table
*
T_RT       DS 0H
T_RTJID    DC CL6'JID   ',AL2(ADATA_RECJID,TRD_JID-DA$ADATA)
T_RTOPT    DC CL6'OPT   ',AL2(ADATA_RECOPT,TRD_OPT-DA$ADATA)
T_RTESD    DC CL6'ESD   ',AL2(ADATA_RECESD,TRD_ESD-DA$ADATA)
T_RTSRC    DC CL6'SOURCE',AL2(ADATA_RECSOURCE,TRD_SOURCE-DA$ADATA)
T_RTSRCERR DC CL6'SRCERR',AL2(ADATA_RECSRCERR,TRD_SRCERR-DA$ADATA)
T_RTDCDS   DC CL6'DCDS  ',AL2(ADATA_RECDCDS,TRD_DCDS-DA$ADATA)
T_RTDCDSX  DC CL6'DCDSX ',AL2(ADATA_RECDCDSX,TRD_DCDSX-DA$ADATA)
T_RTMACH   DC CL6'MACH  ',AL2(ADATA_RECMACH,TRD_MACH-DA$ADATA)
T_RTRLD    DC CL6'RLD   ',AL2(ADATA_RECRLD,TRD_RLD-DA$ADATA)
T_RTSYM    DC CL6'SYM   ',AL2(ADATA_RECSYM,TRD_SYM-DA$ADATA)
T_RTXREF   DC CL6'XREF  ',AL2(ADATA_RECXREF,TRD_XREF-DA$ADATA)
T_RTMXREF  DC CL6'MXREF ',AL2(ADATA_RECMXREF,TRD_MXREF-DA$ADATA)
T_RTMXREFX DC CL6'MXREFX',AL2(ADATA_RECMXREFX,TRD_MXREFX-DA$ADATA)
T_RTOUTPUT DC CL6'OUTPUT',AL2(ADATA_RECOUTPUT,TRD_OUTPUT-DA$ADATA)
T_RTUSER   DC CL6'USER  ',AL2(ADATA_RECUSER,TRD_USER-DA$ADATA)
T_RTUSING  DC CL6'USING ',AL2(ADATA_RECUSING,TRD_USING-DA$ADATA)
T_RTSTATS  DC CL6'STATS ',AL2(ADATA_RECSTATS,TRD_STATS-DA$ADATA)
T_RTAID    DC CL6'AID   ',AL2(ADATA_RECAID,TRD_AID-DA$ADATA)
T_RTCOMP   DC CL6'COMPUN',AL2(ADATA_RECCOMPUNIT,TRD_COMPUN-DA$ADATA)
           AIF (NOT D'ADATA_RECRXREF).TRTRXREFX
T_RTRXREF  DC CL6'RXREF ',AL2(ADATA_RECRXREF,TRD_RXREF-DA$ADATA)
.TRTRXREFX ANOP ,
           AIF (NOT D'ADATA_RECAOPT).TRTAOPTX
T_RTRAOPT  DC CL6'AOPT  ',AL2(ADATA_RECAOPT,TRD_AOPT-DA$ADATA)
.TRTAOPTX  ANOP ,
T_RTN      EQU   (*-T_RT)/TRT_CL
           DC CL6'??????',AL2(0,TRD_UNK-DA$ADATA)
T_RTL      EQU   (*-T_RT)
           PRINT NODATA
*
*
TRD_JID    DA#STR 'Job Identification record'
TRD_OPT    DA#STR 'Options record'
TRD_ESD    DA#STR 'External Symbol Dictionary record'
TRD_SOURCE DA#STR 'Source record'
TRD_SRCERR DA#STR 'Source Error record'
TRD_DCDS   DA#STR 'DC/DS record'
TRD_DCDSX  DA#STR 'DC/DS Extension'
TRD_MACH   DA#STR 'Machine Instruction record'
TRD_RLD    DA#STR 'Relocation Dictionary record'
TRD_SYM    DA#STR 'Symbol record'
TRD_XREF   DA#STR 'Symbol and Literal Cross Reference record'
TRD_MXREF  DA#STR 'Macro and Copy Code Source Catalog record'
TRD_MXREFX DA#STR 'Macro and Copy Code Cross Reference'
TRD_USER   DA#STR 'User data'
TRD_USING  DA#STR 'USING Map record'
TRD_STATS  DA#STR 'Assembly Statistics record'
TRD_OUTPUT DA#STR 'Output File Information'
TRD_AID    DA#STR 'ADATA Identification'
TRD_COMPUN DA#STR 'Compilation unit Start/End'
TRD_RXREF  DA#STR 'Register Cross Reference'
TRD_AOPT   DA#STR 'Options File Information'
TRD_UNK    DA#STR 'Unknown record type'
*
** Literals
*
LTORG    EQU   *
         LTORG ,
LTORGL   EQU   *-LTORG
         DS    0D
*
** Determine length left addressible in main (DA$ADATA) CSECT
*
#DA$ADATA EQU  *-DA$ADATA                 Bytes used
#DA$ADATA_LEFT EQU (4096*3)-#DA$ADATA     Bytes left
         EJECT
***********************************************************************
***
**       GETMAINed work area
***
***********************************************************************
           SPACE 2
DSA        DSECT ,
           DS    18F                      Register Save Area
PARMLIST   DS    10F                      Parameter list for calls
DOUBLE     DS    D                        DOUBLE WORD WORK AREA
DOUBLE2    DS    2D                       DOUBLE WORD WORK AREA
*                                         Execution stuff
PSF_RECR   DS    F
*                                         Execution stuff
X_MAXCC    DS    X                        ..Maximum CC
X_FLAG1    DS    B'00000000'              ..Flag 1
$XF1_NMXD        EQU B'10000000'            ..No Mini-Hex-Dump routine
$XF1_NRO         EQU B'01000000'            ..No REXXOUT
$XF1_LDA$MXD     EQU B'00100000'            ..Loaded DA#MXD?
*
** Get_Current_Time_Date fields
*
         DS    0D
STCKCONI DS    D
STCKCONO DS    CL16
X_TIME   DC    C'hh:mm:ss'
X_DATE   DC    C'ccyy-mm-dd'
*
** DCBs and other file fields
*
SYSADATA   DS    XL(C_DCBIL)              SYSADATA file
SYSPRINT   DS    XL(C_DCBOL)              Messages file
REXXOUT    DS    XL(C_DCBOL)              Report file
*
RECOUT     DS    CL133                    RECOUT
           DS    CL133                    "BOB" says we need slack
HEADREC    DS    CL133                    Heading record
           DS    CL133                    "BOB" says we need slack
           DS    0F                       Print_Sysprint_Record
PSR_RA     DS    F                        ..Return Address
PSR_PC     DS    F                        ..Page Count
PSR_LC     DS    X                        ..Line Count
           DS    0F                       Entry Points
EP_DA$MXD  DS    F                        ..DA$MXD
           DS    0F
W_DA$MXD   DS    XL(CMXDL)                DA$MXD work area
*
#XRTL      EQU   (T_RTL*TRTL)             Generate length of table
X_RT       DS    XL(#XRTL)                Table
*
** End of the Dynamic Save Area
*
           DS    0D                       Align DBL word for FREEMAIN
DSAL       EQU   *-DSA
         END ,
***********************************************************************
***
**        Linkage editor cards - ASM.PARM='BATCH,...'
***
***********************************************************************
         SPACE 2
 PUNCH ' ENTRY   DA$ADATA          '      Entry point
 PUNCH ' INCLUDE SYSLMOD(DA$MXD)  '       Subroutine: Mini-Hex-Dump
 PUNCH ' NAME    DA$ADATA(R)       '      Name of load module
         END ,
./ ADD NAME=DA$ASMHA 0100-01266-01266-1821-04390-04390-00000-DAVE
DA$ASMHA TITLE 'Assembler H Analysis'
***********************************************************************
***                                                                 ***
** Name: DA$ASMHA                                                    **
**                                                                   **
** Author = David Alcock :: dave@planetmvs.com
**                                                                   **
** Written: 1 September 1989                                         **
**                                                                   **
** Attributes: Reentrant, Reusable, Non-Authorized                   **
**                                                                   **
** Purpose: Assembler-H analysis - This program reads the output     **
**          of the IEV90 (Assembler H) and provides these functions: **
**                                                                   **
**          o Create Data Area Handbook - inspired by Lionel Dyck's  **
**            DAHANDBK program.  DA$ASMHA handles symbolics longer   **
**            than 8 characters and instructions that are not in     **
**            the standard columns.  IBM has started to use          **
**            labels longer than 8 characters with TSO/E V1.4,       **
**            'SYS1.MACLIB(IKJEESCB)'.  The handbook is in the       **
**            format of the MVS debugging handbooks and is in these  **
**            output types:                                          **
**                                                                   **
**            o Text                                                 **
**            o DCF (not tested since 1990)                          **
**                                                                   **
**          o PASS3: Analysis of code:                               **
**            o Detect subtle errors                                 **
**            o Detect use of obsolete interfaces (Future)           **
**            o Remove sequence numbers - Allow comments to be       **
**              written on hardcopy without skip.                    **
**                                                                   **
** Parameters on the EXEC card:                                      **
** - NAMEL=x........Length of label (name) field in Data Area        **
**                  Handbook.  Defaults to 8. It should be specified **
**                  as one more than you want. For example, NAMEL=11 **
**                  for labels from 1-10.                            **
** - ASMPARM(x,y)...Parameters to be passed to IEV90 when doing      **
**                  inline assembles                                 **
** - SYSTEM(title)..Title of application system? DCF only?           **
** - ADDR=01234567..Starting address.  As the program listing is     **
**                  being printed, the address will increment based  **
**                  on the starting address.  You could use this     **
**                  while debugging to make a SYSUDUMP reading easier**
**                  by getting the execution EPA and the assembler   **
**                  listing would match the dump                     **
** - Flags:                                                          **
**   - ASM..........Invoke the IEV90 assembler (see ASMPARM())       **
**   - DEBUGS.......Debugging messages short (Consise)               **
**   - DEBUGF.......Debugging messages full (Verbose)                **
**   - NOLOGO.......Do not invoke the IBM BLOCK letter routine       **
**   - NOCDASH......Bypass a dash at the beginning of a comment      **
**   - REMOVESQ.....Remove Sequence numbers                          **
**   - DCF..........Create DCF output                                **
**     - NOBOX........Do not put box on DCF output                   **
**     - BODYONLY.....DCF: only print the body                       **
**                                                                   **
** External Programs:                                                **
** o IEFSD095...IBM block letter routine (optional)                  **
** o IEV90......With the PARM='ASM,ASMPARM()" option: invoke IBM's   **
**              Assembler H                                          **
** o DA$DATE....Date routine                                         **
** o DA$MXD.....Mini-Hex-Dump routine                                **
**                                                                   **
** Non-IBM assembler MACROs:                                         **
** o DA#ENTER...Entry housekeeping                                   **
** o DA#LEAVE...Termination housekeeping                             **
** o DA#EYEC....Build standard O/S module eyecatcher                 **
**              (invoked by the DA#ENTER)                            **
** o DA#REGS....Define registers (invoked by DA#ENTER)               **
** o DA#DATE....Equates and DSECTs for the date routine              **
** o DA#MXD.....Equates and DSECTs for the mini-hex-dump routine     **
**                                                                   **
* Disclaimer: This program is FREEWARE.  Use at your own risk.  It
*             is provided for your enjoyment and neither David
*             Alcock or his employer provides any warranty for it's
*             use.  I'd like to hear how it works on your system.
*
*             This software is not in the public domain but is
*             available free of charge and with source code
*             provided.  It is copyright 2001+ by David Alcock
*             All rights reserved.
**                                                                   **
** Restrictions:                                                     **
** o Assembler H (for both assembling and processing)                **
** o DCF option: Requires DCF, Data Composition Facility and Book-   **
**   Master for interpretation of output.                            **
** o Assembler control instructions not supported:                   **
**   ICTL, OPSYN                                                     **
**                                                                   **
** Note:                                                             **
** o Terms based on GC26-4037 "Assembler H V2 Language Reference":   **
**   NAME     OPERATION OPERAND            REMARKS                   **
**   -------- --------- ---------------    ------------------------  **
**   OPENFLS  OPEN      (SYSIN,(INPUT))    Open input file           **
**                                                                   **
** ----------------------------------------------------------------- **
**                                                                   **
** Enhancement queue:                                                **
** o Create COBOL, IPCS, PL1 and SAS code from DSECTs                **
** o Source Pretty Printing (half-implemented)                       **
** o DCF is old hat, HTML is king!!!!!  circa 1996                   **
**                                                                   **
**   This enhancement queue will probably never be implemented       **
**   because the Assembler H has been replaced with HLASM and it     **
**   has the ADATA output file which is FAR superior to this         **
**   "Screen Scraper" technology....David Alcock 13-NOV-1996         **
***                                                                 ***
***********************************************************************
         SPACE 2
&DAVER   SETC  '1.4'
***********************************************************************
***
**           M o d i f i c a t i o n   H i s t o r y
**
** Person     Date        Ver Description
** ---------- ----------- --- ----------------------------------------
** D Alcock   13-NOV-1996 1.4 Added Label overflow code to print msgs
**                            17 and 18; Detect Trailer records and
**                            ignore them;
** D Alcock   06-NOV-1996 1.3 Renamed to DA$ASMHA
** D Alcock   08-JAN-1991 1.2 Added better DCF formating; BAL STMT
**                            suppression in Data Area Hand Books;
** D Alcock   25-JUL-1990 1.1 Completed DCF/BookMaster output creation;
** D Alcock   01-SEP-1989 1.0 Initial program created;
**
***
***********************************************************************
         EJECT ,
DA$ASMHA DA#ENTER 'V&DAVER Utility: Assembler H output analysis',      @
               RENT=YES,                  Indicate we want GETMAIN     @
               LV=WORKDSL,                Length of GETMAIN            @
               BASE=(12,11,10)            Obtain some base registers
         USING WORKDS,R13                 Addressability to work area
         ST    R1,R1SAVE                  Save parameter list address
         EJECT ,
***********************************************************************
***                                                                 ***
**       Initialization Section                                      **
***                                                                 ***
***********************************************************************
         SPACE 2
*
** Load external routines needed
*
         ICM   R0,B'1111',=V(DA$DATE)     DA$DATE linked into us?
         BNZ   I$DA$DATEX                 Yes
         LA    R8,=CL8'DA$DATE'           No, get name
         LOAD  EPLOC=(8),ERRET=E$LOAD     ....and try to load it
         OI    X_FLAG2,$XF2_DDATE         Turn on flag
I$DA$DATEX EQU *
         ST    R0,EP_DA$DATE
*
** Set the current date and time for report headings
*
         MVC   X_ODGEUR11(C_ODGEUR11L),C_ODGEUR11
         MVC   X_OTIMES11(C_OTIMES11L),C_OTIMES11
         DA#SMODE 31                      Must be in 31 bit mode
         L     R15,EP_DA$DATE             Locate EPA of R$DATE routine
         CALL  (15),(X_ODGEUR11,X_OTIMES11),VL,MF=(E,PARMLIST)
         DA#SMODE 24                      Back to 24 bit mode
*
** Open SYSPRINT file for Global messages
*
         LA    R1,WA_FWA_SYSPRINT         Locate file work area
         L     R14,=V(RAA$DATA)
         LA    R15,C_SYSPRINT-RAA$DATA(R14)
         LA    R8,C_SYSPRINTN-RAA$DATA(R14)
         BAS   R14,OPEN_FILE_WORK_AREA    Open the file
*
** Print starting message
*
         BAS   R9,FORMAT_MESSAGE          Format Message
         MVC   0(MSG1L,R15),MSG1-RAA$DATA(R1)
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message
*
         BAS   R14,CLEAR_RECOUT           Clear record to blanks
         BAS   R9,PRINT_SYSPRINT_RECORD   Print blank line
         EJECT
***********************************************************************
***                                                                 ***
**       Parse parameter card                                        **
***                                                                 ***
***********************************************************************
         SPACE 2
PARSE_PARAMETER_CARD EQU *
#PPC_NAMEL EQU 8-1
         LA    R1,#PPC_NAMEL
         ST    R1,PPC_NAMEL
         MVI   PPC_CCC,C'!'               Set default Comment Cntl Char
*
** Locate the parameter card from the EXEC card
*
         L     R1,R1SAVE                  Get address of parameter addr
         L     R1,0(R1)                   Get address of parameter
         SLR   R6,R6                      Zero register
         ICM   R6,B'0011',0(R1)           Get length of parameter
         BZ    PPC$X                      None, continue
         LA    R7,2(R1)                   Locate past length halfword
         BAS   R9,FORMAT_MESSAGE          Format message
         MVC   0(MSG105L,R15),MSG105-RAA$DATA(R1)
         LA    R15,MSG105L+1(R15)         Bump past it
         LR    R1,R6                      Get length
         BCTR  R1,0                       Decrement by 1
         EX    R1,PPC$PRMM                Move parameter to message
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message
         B     PPC$DLMX                   Test first parameter
PPC$PRMM MVC   0(0,R15),0(R7)             Get parameter
*
** Test for valid delimiter between operands
*
PPC$DLM  EQU   *
         CLI   0(R7),C','                 Valid delimiter?
         BE    PPC$DLME                   No, print error message
         CLI   0(R7),C' '                 Valid delimiter?
         BNE   PPC$DLMX                   Yes, continue
         LA    R7,1(R7)                   Bump to next byte
         BCT   R6,PPC$DLM                 Find next non-blank
         B     PPC$X                      Leave
PPC$DLMG EQU   *
         LA    R7,1(R7)                   Bump past delimiter
         BCTR  R6,0                       Decrement count
         LTR   R6,R6                      End?
         BZ    PPC$END                    Yes, continue
PPC$DLME EQU   *
         LA    R7,1(R7)                   Bump past delimiter
         BCTR  R6,0                       Decrement count
         LTR   R6,R6                      End?
         BZ    PPC$END                    Yes, continue
PPC$DLMX EQU   *
*
** Process keywords into program flags. Generate an OI instruction to
** turn on flag:
**
** OI   PPC_FLAG1,$PPC_F1NOLOGO   -   If PARM=NOLOGO
*
         LA    R3,T_PFLAGSN               Get number of entries
         L     R2,=V(RAA$DATA)
         LA    R2,T_PFLAGS-RAA$DATA(R2)   Locate flag
PPC$FL   EQU   *
         SLR   R14,R14                    Clear register
         IC    R14,TPF_NAMEL-TPF(R2)      Get length of operand
         CR    R14,R6                     Room in parse area for flag?
         BH    PPC$FLB                    No, continue
         EX    R14,PPC$FLC                Match?
         BE    PPC$FLX                    Yes, continue
PPC$FLB  EQU   *
         LA    R2,TPFL(R2)                Bump to next entry
         BCT   R3,PPC$FL                  ..Process it
         B     PPC$FX                     Continue: not a flag
PPC$FLC  CLC   TPF_NAME-TPF(0,R2),0(R7)
PPC$FOI  OI    *-*,4
PPC$FLX  EQU   *
         MVC   DOUBLE(4),PPC$FOI          Get Instruction
         MVC   DOUBLE+1(1),TPF_FLAG-TPF(R2)    Set flag
         MVC   DOUBLE+2(2),TPF_OFFSET-TPF(R2) Get offset
         OI    DOUBLE+2,X'D0'             Register 13/WORKDS
*The next few instructions can be uncommented and used for debugging
*MVC WTOMSG+8+10(8),TPF_NAME-TPF(R2)
*UNPK WTOMSG+8+19(9),DOUBLE(5)
*MVZ  WTOMSG+8+19(8),ZEROS
*TR   WTOMSG+8+19(8),HEXTABLE
*MVI  WTOMSG+8+19+8,C'='
*WTOMSG WTO 'R$PDSANL: xxxxxxxx xxxxxxxx=Instruction'
         LA    R15,0                      Set up for EX
         EX    R15,DOUBLE                 Execute: OI field,flag
PPC$FLDL EQU   *
         CLI   0(R7),C' '                 Valid Delimiter?
         BE    PPC$DLM
         CLI   0(R7),C','                 Valid Delimiter?
         BE    PPC$DLM
         LA    R7,1(R7)                   Bump past extra byte
         BCT   R6,PPC$FLDL                Process next one
         B     PPC$X                      End of the Parameter string
*
PPC$FX   EQU   *
*
** Maximum name length for Data Area Hand Books
*
PPC$NAME EQU   *
         CLC   0(6,R7),=C'NAMEL='
         BNE   PPC$NAMEX                  No, continue
         LA    R7,6(R7)                   Bump past "NAMEL="
         SH    R6,=H'6'                   Decrement for length
         LTR   R6,R6                      Check out length
         BZ    PPC$OERR                   Zero, leave
         LA    R1,DOUBLE                  Locate output
         LA    R14,4                      Set max
         SLR   R15,R15                    Set count
PPC$NAMEL EQU  *
         MVC   0(1,R1),0(R7)              Move input byte
         LA    R7,1(R7)                   Bump to next input byte
         LA    R1,1(R1)                   Bump to next output byte
         BCTR  R14,0                      Decrement max count
         LTR   R14,R14                    Check for overflow...
         BZ    PPC$NAMELX                 Yes, continue
         LA    R15,1(R15)                 Increment count
         CLI   0(R7),C','                 Found delimiter?
         BE    PPC$NAMELX                 Yes, leave
         BCT   R6,PPC$NAMEL               Process next byte
PPC$NAMELX EQU *
         BCTR  R15,0                      Decrement for later
         EX    R15,PPC$NAMEP              Save count
         CVB   R1,DOUBLE2                 Convert it to binary
         LTR   R1,R1                      Zero?
         BZ    PPC$OERR                   I can't take a joke
         BCTR  R1,0                       Decrement for EX
         ST    R1,PPC_NAMEL               Save it
         BCTR  R6,0                       Decrement count
         LTR   R6,R6                      Check count
         BZ    PPC$END                    Zero, at end of parameter
         BM    PPC$END                    Zero, at end of parameter
         B     PPC$DLM                    Process next option
PPC$NAMEP PACK DOUBLE2(8),DOUBLE(0)
PPC$NAMEX EQU  *
*
** Assembler Parameter (when we invoke it)
*
PPC$AP   EQU   *
         CLC   0(8,R7),=C'ASMPARM('
         BNE   PPC$APX
         OI    PPC_FLAG1,$PPC_F1ASM       Turn on option !!!!!!!!!!
         LA    R7,8(R7)                   Bump past "ASMPARM="
         SH    R6,=H'8'                   Decrement for length
         LTR   R6,R6                      Check out length
         BZ    PPC$OERR                   Zero, leave
         LA    R1,PPC_ASMPARM+2           Locate output
         LA    R14,L'PPC_ASMPARM-3        Set max
         SLR   R15,R15                    Set count
PPC$APL  EQU   *
         MVC   0(1,R1),0(R7)              Move input byte
         LA    R7,1(R7)                   Bump to next input byte
         LA    R1,1(R1)                   Bump to next output byte
         LA    R15,1(R15)                 Increment count
         BCTR  R14,0                      Decrement max count
         LTR   R14,R14                    Check for overflow...
         BZ    PPC$APLX                   Yes, continue
         CLI   0(R7),C')'                 Found delimiter?
         BE    PPC$APLX                   Yes, leave
         BCT   R6,PPC$APL                 Process next byte
PPC$APLX EQU   *
         STC   R15,PPC_ASMPARM+1          Save count
         LA    R7,1(R7)                   Bump past ")"
         SH    R6,=H'2'                   Decrement count
         LTR   R6,R6                      Check count
         BZ    PPC$END                    Zero, at end of parameter
         BM    PPC$END                    Zero, at end of parameter
         B     PPC$DLM                    Process next option
PPC$APX EQU    *
*
** System
*
PPC$TL   EQU   *
         CLC   0(7,R7),=C'SYSTEM('
         BNE   PPC$TLX
         LA    R7,7(R7)                   Bump past "SYSTEM("
         SH    R6,=H'7'                   Decrement for length
         LTR   R6,R6                      Check out length
         BZ    PPC$OERR                   Zero, leave
         LA    R1,PPC_TITLE+1             Locate output
         LA    R14,L'PPC_TITLE-1          Set max length
         SLR   R15,R15                    Set count
PPC$TLL  EQU   *
         MVC   0(1,R1),0(R7)              Move input byte
         LA    R7,1(R7)                   Bump to next input byte
         LA    R1,1(R1)                   Bump to next output byte
         LA    R15,1(R15)                 Increment count
         BCTR  R14,0                      Decrement max count
         LTR   R14,R14                    Check for overflow...
         BZ    PPC$TLLX                   Yes, continue
         CLI   0(R7),C')'                 Found delimiter?
         BE    PPC$TLLX                   Yes, leave
         BCT   R6,PPC$TLL                 Process next byte
PPC$TLLX EQU   *
         BCTR  R15,0                      Decrement for later EX
         STC   R15,PPC_TITLE              Save count
         LA    R7,1(R7)                   Bump past ")"
         SH    R6,=H'2'                   Decrement count
         LTR   R6,R6                      Check count
         BZ    PPC$END                    Zero, at end of parameter
         BM    PPC$END                    Zero, at end of parameter
         B     PPC$DLM                    Process next option
PPC$TLX EQU    *
*
** Starting address to enhance Assembly listing
*
PPC$ADDR EQU   *
         CLC   0(5,R7),=C'ADDR='
         BNE   PPC$ADDRX
         LA    R7,5(R7)                   Bump past "ADDR="
         SH    R6,=H'5'                   Decrement for length
         LTR   R6,R6                      Check out length
         BZ    PPC$OERR                   Zero, leave
         LA    R1,PARMLIST                Output location
         LA    R14,8                      Set max
         SLR   R15,R15                    Set count
PPC$ADDRL EQU  *
         MVC   0(1,R1),0(R7)              Move input byte
         LA    R7,1(R7)                   Bump to next input byte
         LA    R1,1(R1)                   Bump to next output byte
         LA    R15,1(R15)                 Increment count
         BCTR  R14,0                      Decrement max count
         LTR   R14,R14                    Check for overflow...
         BZ    PPC$ADDRLX                 Yes, continue
         CLI   0(R7),C','                 Found delimiter?
         BE    PPC$ADDRLX                 Yes, leave
         BCT   R6,PPC$ADDRL               Process next byte
PPC$ADDRLX EQU *
         CH    R15,=H'8'
         BNE   PPC$OERR
         LA    R0,4                       Input length / 2
         LA    R1,PPC_ADDR                Locate output hex value str
         LA    R15,PARMLIST               Get input location
         BAS   R8,HEXTRAN                 Convert to hex
         OI    PPC_FLAG1,$PPC_F1ADDR
*
         BCTR  R6,0                       Decrement count
         LTR   R6,R6                      Check count
         BZ    PPC$END                    Zero, at end of parameter
         BM    PPC$END                    Zero, at end of parameter
         B     PPC$DLM                    Process next option
PPC$ADDRX EQU  *
*
** Parameter in error: isolate it, note position and continue
*
PPC$OERR EQU   *
         SLR   R1,R1                      CLEAR OUT REGISTER
         ICM   R1,B'0011',PPC_COL         GET PREVIOUS PARM ERR COLUMN
         BNZ   PPC$GNUM                   YES, GO INCREMENT NUMBER
         L     R1,R1SAVE                  GET ADDR OF ADDR OF PARM
         L     R1,0(R1)                   NOW GET ADDRESS OF PARM
         LH    R1,0(R1)                   GET LENGTH OF PARM
         SR    R1,R6                      SUBTRACT FROM CURRENT LOC
         LA    R1,1(R1)                   Make offset from 1 not zero
         STH   R1,PPC_COL                 SAVE LOCATION OF ERROR
PPC$GNUM EQU   *
         LH    R1,PPC_NUM                 GET NUMBER OF ERRORS IN PARM
         LA    R1,1(R1)                   INCREMENT BY 1
         STH   R1,PPC_NUM                 SAVE FOR LATER
PPC$RR   EQU   *
         CLI   0(R7),C','                 HIT A COMMA YET?
         BE    PPC$BRK                    YES, LEAVE
         LA    R7,1(R7)                   BUMP TO NEXT BYTE
         BCT   R6,PPC$RR                  TEST IT OUT
         B     PPC$END                    END OF PARMS...
PPC$BRK  EQU   *
         LA    R7,1(R7)                   BUMP PAST COMMA
         LTR   R6,R6                      TEST FOR ZERO LENGTH
         BZ    PPC$END                    YES, END RIGHT NOW
         BCT   R6,PPC$DLMX                NO, LETS TEST SOME MORE
*
** End of parameters found
*
PPC$END  EQU   *
         SLR   R1,R1                      Clear register
         ICM   R1,B'0011',PPC_NUM         Get number of parm errors
         BZ    PPC$X                      None, continue
*
         MVI   X_MAXCC,20                 Set max condition code
         BAS   R9,FORMAT_MESSAGE          Format message
         MVC   0(MSG106L,R15),MSG106-RAA$DATA(R1)
         LA    R15,MSG105L+1(R15)         Bump past it
         L     R8,R1SAVE                  Get address of parameter addr
         L     R8,0(R8)                   Get address of parameter
         LH    R14,0(R8)                  Get length of parameter
         BCTR  R14,0                      Decrement by 1
         LA    R7,C_NUMBER-RAA$DATA(R1)   Locate numbers
         EX    R14,PPC$PRMM               Move parameter to message
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message
*
         BAS   R9,FORMAT_MESSAGE          Format message
         MVC   0(MSG107L,R15),MSG107-RAA$DATA(R1)
         LA    R15,MSG107L(R15)           Bump past it
         LH    R1,PPC_NUM                 Get number
         BAS   R9,EDITFWF                 Edit number
         MVC   0(30,R15),=C', first one in error at column'
         LA    R15,31(R15)                Bump past text
         LH    R1,PPC_COL                 Get column number
         BAS   R9,EDITFWF                 Edit it
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message
         B     EXIT
*
** Common Exit from Parse_Parameter_Card
*
PPC$X    EQU   *
         EJECT ,
***********************************************************************
***                                                                 ***
**       Invoke assembler                                            **
***                                                                 ***
***********************************************************************
         SPACE 2
INVOKE_ASSEMBLER EQU *
         MVC   RAR_IDD(8),=CL8'SYSUT1'    Set default
         TM    PPC_FLAG1,$PPC_F1ASM
         BNO   IA$X
*
** Is Assembler input file allocated?
*
         L     R8,=V(RAA$DATA)            -> RAA$DATA
         LA    R7,C_APIDD-RAA$DATA(R8)    Locate input DD name
         DEVTYPE (7),DOUBLE               Get file information
         LTR   R15,R15                    Allocated?
         BZ    IA$TDDX                    No, continue
         BAS   R9,FORMAT_MESSAGE          Format Message
         MVC   0(MSG12L,R15),MSG12-RAA$DATA(R1)
         MVC   MSG12L(8,R12),C_APIDD-RAA$DATA(R8)
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message
         MVI   X_MAXCC,20
         B     EXIT
IA$TDDX  EQU   *
*
** Attach the assembler
*
         LA    R9,DOUBLE                  Locate Event Control Block
         XC    0(4,R9),0(R9)              Clear Event control Block
         L     R14,=V(RAA$DATA)           -> RAA$DATA
         MVC   PARMLIST(C_ATCL),C_ATC-RAA$DATA(R14)
*
         LA    R1,RAR_DPNAMEA             Assembler Parameter List area
         LA    R14,PPC_ASMPARM            -> Option list
         ST    R14,0(R1)                  Save
         LA    R14,C_APDD-RAA$DATA(R8)    -> DDNAME list
         ST    R14,4(R1)                  Save
         OI    4(R1),X'80'                Set end of list
*
         ATTACH EPLOC==CL8'IEV90',        Attach Assembler             @
               ECB=(9),                   ..Event Control Block        @
               SF=(E,PARMLIST)            ..Attach Execute form
         ST    R1,DOUBLE2                 Save TCB address
*
         WAIT  ECB=DOUBLE                 Wait for Assembler
         DETACH DOUBLE2                   Detach Assembler
*
** Print status of call to assembler
*
         BAS   R9,FORMAT_MESSAGE          Format Message
         MVC   0(MSG8L,R15),MSG8-RAA$DATA(R1)
         LA    R15,MSG8L(R15)             Bump past it
         UNPK  0(7,R15),DOUBLE+1(4)
         MVZ   0(6,R15),=X'00,00,00,00,00,00,00,00'
         TR    0(6,R15),=C'0123456789ABCDEF'
         MVI   6(R15),C' '
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message
*
         BAS   R14,CLEAR_RECOUT           Clear record to blanks
         BAS   R9,PRINT_SYSPRINT_RECORD   Print blank line
         MVC   RAR_IDD(8),C_APIDD-RAA$DATA(R8)
*
         CLC   DOUBLE+1(3),=X'00,00,04'   Assembler successful?
         BNH   IA$X
         MVI   X_MAXCC,20
         B     EXIT
*
** Exit from Invoke_Assembler
*
IA$X     EQU   *
         EJECT
***********************************************************************
***                                                                 ***
**       Read Assembler records                                      **
***                                                                 ***
***********************************************************************
         SPACE 2
READ_ASSEMBLER_RECORD EQU *
*
** Open input assembler file (SYSUT1 or ASMPRINT)
*
         LA    R3,SYSUT1                  Locate DCB
         MVC   0(C_DCBIL,R3),C_DCBI       Copy in DCB constant
         MVC   DCBDDNAM-IHADCB(8,R3),RAR_IDD
         LA    R1,RAR$EOF                 Locate end of file location
         STCM  R1,B'0111',DCBEODAD-IHADCB+1(R3) Insert into DCB
*
         LA    R15,SYSUT1_EXLST           LOCATE OUR EXLST
         STCM  R15,B'0111',DCBEXLST-IHADCB+1(R3) SAVE INTO DCB
*
         LA    R14,SYSUT1_JFCB            Locate JFCB return area
         ST    R14,SYSUT1_EXLST           Save into JFCB area
         OI    SYSUT1_EXLST,X'07'         Indicate JFCB return
*
         LA    R1,E$OPENA                 LOCATE OUR DCB ABEND ROUTINE
         ST    R1,SYSUT1_EXLST+4          PUT INTO EXLST
         OI    SYSUT1_EXLST+4,X'11'       DCB EXIT
         OI    SYSUT1_EXLST+4,X'80'       END OF LIST
         XC    CO_OPENC(4),CO_OPENC       CLEAR OPEN-ABEND CODE
*
         MVC   PARMLIST(C_RDJFCBL),C_RDJFCB
         RDJFCB ((3),(INPUT)),MF=(E,PARMLIST)
*
         MVC   PARMLIST(C_LSTIL),C_LSTI   COPY IN OPEN PARM LIST
         OPEN  ((3),(INPUT)),TYPE=J,                                   @
               MF=(E,PARMLIST)            OPEN DCB
         BAS   R9,CHECK_OPEN              CHECK OPEN
*
** Print message showing type
*
         BAS   R9,FORMAT_MESSAGE          Format Message
         MVC   0(MSG11L,R15),MSG11-RAA$DATA(R1)
         LA    R15,MSG11L(R15)            Bump past it
         LA    R8,SYSUT1_JFCB
         MVC   0(44,R15),JFCBDSNM-INFMJFCB(R8)
         LA    R0,44
         BAS   R14,LOCATE_FIRST_SPACE
         TM    JFCBIND1-INFMJFCB(R8),JFCPDS
         BNO   RAR$IS1POX
         MVI   0(R15),C'('
         MVC   1(8,R15),JFCBELNM-INFMJFCB(R8) Get member name
         LA    R0,9                       Length of "(member  "
         BAS   R14,LOCATE_FIRST_SPACE
         MVI   0(R15),C')'
         LA    R15,1(R15)
RAR$IS1POX EQU *
         MVC   0(4,R15),=C', as'
         LA    R15,5(R15)
         CLI   DCBLRECL-IHADCB+1(R3),80   80 byte source input?
         BE    RAR$IS1S
         MVC   0(7,R15),=C'listing'
         B     RAR$IS1X
RAR$IS1S EQU   *
         MVC   0(6,R15),=C'source'
         OI    X_FLAG1,$XF1_SRC
RAR$IS1X EQU   *
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message
*
** Open optional PASS3 file
*
         TM    X_FLAG1,$XF1_SRC           Source?
         BO    RAR$IP3X                   Yes, bypass open of PASS3
         LA    R8,=CL8'PASS3'             Locate file name
         DEVTYPE (8),DOUBLE               Get file information
         LTR   R15,R15                    Allocated?
         BNZ   RAR$IP3X                   No, continue
         OI    X_FLAG1,$XF1_PASS3         Yes, turn on flag
*
         LA    R3,PASS3                   Locate DCB area
         MVC   0(C_DCBOL,R3),C_DCBO       Copy in DCB constant
         MVC   DCBDDNAM-IHADCB(8,R3),0(R8)
         LA    R1,SYSUT1                  Locate input asm file
         MVC   DCBLRECL-IHADCB(2,R3),=AL2(133)
         MVC   DCBBLKSI-IHADCB(2,R3),=AL2(1330)
         MVC   DCBRECFM-IHADCB(1,R3),DCBRECFM-IHADCB(R1)
*
         LA    R15,PASS3_EXLST            LOCATE OUR EXLST
         STCM  R15,B'0111',DCBEXLST-IHADCB+1(R3) SAVE INTO DCB
         LA    R1,E$OPENA                 LOCATE OUR DCB ABEND ROUTINE
         ST    R1,PASS3_EXLST             PUT INTO EXLST
         OI    PASS3_EXLST,X'11'          DCB EXIT
         OI    PASS3_EXLST,X'80'          END OF LIST
         XC    CO_OPENC(4),CO_OPENC       CLEAR OPEN-ABEND CODE
*
         MVC   PARMLIST(C_LSTOL),C_LSTO   Get open Parameter List
         OPEN  ((3),(OUTPUT)),            Open the file                @
               MF=(E,PARMLIST)
         BAS   R9,CHECK_OPEN              CHECK OPEN
RAR$IP3X EQU   *
*
** Open optional INDEX file
*
         TM    PPC_FLAG2,$PPC_F2DCF       Document Composition Fac?
         BO    RAR$IINDEXX                Yes, no need for index
         TM    X_FLAG1,$XF1_SRC           Source?
         BO    RAR$IINDEXX                Yes, no Data-Area-HandBook
         LA    R8,C_INDEX+1               Locate file name
         DEVTYPE (8),DOUBLE               Get file information
         LTR   R15,R15                    Allocated?
         BNZ   RAR$IINDEXX                No, continue
         OI    X_FLAG1,$XF1_INDEX         Yes, turn on flag
*
         LA    R0,INDEXAL                 No, get length of area
         GETMAIN R,LV=(0)                 Obtain storage
         STM   R0,R1,INDEX_AREA           Save address and length
*
         LA    R1,INDEXA_FWA-INDEXA(R1)   Locate file work area
         LA    R15,C_INDEXD               Description string
         BAS   R14,OPEN_FILE_WORK_AREA    Open the file
*
         L     R1,INDEX_AREA+4            Locate Index Area
         LA    R15,INDEXA_RH1-INDEXA(R1)  Locate our title line
         LA    R1,INDEXA_FWA-INDEXA(R1)   Locate File work area
         ST    R15,FWA_RH1A-FWA(R1)       Save it
         BAS   R14,CR$CLEAR               Clear area to blanks
*
         L     R1,INDEX_AREA+4            Locate Index Area
         LA    R15,INDEXA_RH2-INDEXA(R1)  Locate our title line
         LA    R1,INDEXA_FWA-INDEXA(R1)   Locate File work area
         ST    R15,FWA_RH2A-FWA(R1)       Save it
         BAS   R14,CR$CLEAR               Clear area to blanks
         MVC   INDEX_NUM+1-INDEX(3,R15),=C'Num'
         MVC   INDEX_NAME-INDEX(04,R15),=C'Name'
         MVC   INDEX_PAGE-INDEX(04,R15),=C'Page'
*
         L     R15,=V(RAA$DATA)           -> Data CSECT
         LA    R15,C_DASHLINE-RAA$DATA(R15) Locate dashes
         ST    R15,FWA_RH3A-FWA(R1)       Save it
RAR$IINDEXX EQU *
*
** Open optional REPORT file
*
         LA    R8,=CL8'REPORT'            Locate file name
         DEVTYPE (8),DOUBLE               Get file information
         LTR   R15,R15                    Allocated?
         BNZ   RAR$IRPTX                  No, continue
         OI    X_FLAG1,$XF1_REPORT        Yes, turn on flag
*
         LA    R1,WA_FWA_REPORT           Locate file work area
         LA    R15,RAR_DHB_DESC           Description string
         TM    X_FLAG1,$XF1_SRC
         BNO   RAR$IRPT_SRCX
         LA    R15,C_SRC
RAR$IRPT_SRCX EQU *
         MVC   0(C_DAHANDBKDL,R15),C_DAHANDBKD
         BAS   R14,OPEN_FILE_WORK_AREA    Open the file
*
         TM    X_FLAG1,$XF1_SRC
         BO    RAR$IRPTX
         OI    X_FLAG1,$XF1_DHB           Turn on Data Hand Book flag
         LA    R1,WA_FWA_REPORT           Locate file work area
         LA    R15,DAHANDBK_RH1           Locate our title line
         ST    R15,FWA_RH1A-FWA(R1)       Save it
         BAS   R14,CR$CLEAR               Clear area to blanks
         MVC   DHBR_OFFD-DHBR(16,R15),=C'---- Offset ----'
*
         LA    R15,DAHANDBK_RH2           Locate our title line
         ST    R15,FWA_RH2A-FWA(R1)       Save it
         BAS   R14,CR$CLEAR               Clear area to blanks
         MVC   DHBR_OFFD+1-DHBR(07,R15),=C'Decimal'
         MVC   DHBR_OFFX-DHBR(03,R15),=C'Hex'
         MVC   DHBR_TYPE-DHBR(04,R15),=C'Type'
         MVC   DHBR_LEN+2-DHBR(06,R15),=C'Length'
         MVC   DHBR_NAME-DHBR(04,R15),=C'Name'
         LA    R15,DHBR_NAME-DHBR(R15)
         A     R15,PPC_NAMEL
         MVC   3(11,R15),=C'Description'
*
         L     R15,=V(RAA$DATA)           -> Data CSECT
         LA    R15,C_DASHLINE-RAA$DATA(R15) Locate dashes
         ST    R15,FWA_RH3A-FWA(R1)       Save it
*
         LA    R1,132-4                   Get length of record
         S     R1,PPC_NAMEL               - length of name
         SH    R1,=AL2(DHBR_NAME-DHBR)    - rest of record
         ST    R1,RAR_DHB_DESCL           Max amount for description
RAR$IRPTX EQU  *
*
** Load Block letter routine (if available)
**
** IEFSD095 - IBM: In 'SYS1.AOSD0'
**
** Note: This routine is not essential and will be bypassed if program
**       can not be located.
*
         TM    PPC_FLAG1,$PPC_F1NOLOGO    Need Logos?
         BO    RAR$ID095X                 Nope
         ICM   R0,B'1111',=V(IEFSD095)    IEFSD095 linked into us?
         BNZ   RAR$ID095X                 Yes, continue
         BAS   R14,CLEAR_RECOUT
         BAS   R9,PRINT_SYSPRINT_RECORD   Print blank line
         BAS   R9,FORMAT_MESSAGE          Format Message
         MVC   0(MSG5L,R15),MSG5-RAA$DATA(R1)
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message
*
         BAS   R14,CLEAR_RECOUT           Clear record to blanks
         BAS   R9,PRINT_SYSPRINT_RECORD   Print blank line
RAR$ID095X EQU *
*
** DCF initializations
*
         TM    PPC_FLAG2,$PPC_F2BODYONLY  Body Only?
         BO    RAR$IDCFX                  No, continue
         TM    PPC_FLAG2,$PPC_F2DCF       DCF?
         BNO   RAR$IDCFX                  No, continue
*
         L     R8,=V(RAA$DCF)             -> RAA$DCF CSECT
         LA    R1,RAA$DCF_HEADER-RAA$DCF(R8) Locate heading
         BAS   R14,PRINT_DCF_STRINGS      Print all strings
RAR$IDCFX EQU *
*
** Misc initializations
*
         BAS   R14,RAR$RSETF              Reset fields
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**       Read Assembler record                                       **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
*
** Read record
*
RAR$L    EQU   *
         GET   SYSUT1                     Get input record
         LR    R5,R1                      Save address
*
         MVI   RAR_TYPE,0                 Reset type
*
** Increment record count
*
         L     R1,RAR_CNTIREC             Get current count
         LA    R1,1(R1)                   Increment it
         ST    R1,RAR_CNTIREC             Save count
*
** Source pre-processing
*
         TM    X_FLAG1,$XF1_SRC           Source input?
         BNO   RAR$PP_SRCX                No, continue
         LR    R15,R5                     Save input record location
         LA    R5,RAR_SRC_REC             Locate new fake record
         MVI   0(R5),C' '                 Get blank
         MVC   1(L'RAR_SRC_REC-1,R5),0(R5) ..Propagate it
         MVC   AHSD_SOURCE-AHS(80,R5),0(R15)  Get input record
         L     R1,RAR_CNTIREC             Get record count
         CVD   R1,DOUBLE                  Make packed
         MVC   AHSD_STMT+2-AHS(3,R5),EDITP15F+1
         ED    AHSD_STMT+1-AHS(4,R5),DOUBLE+6
         MVC   RAR_SRC_DPFLAG1(1),RAR_DPFLAG1
RAR$PP_SRCX EQU *
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**       Debugging                                                   **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
*
** Print Dash line
*
         TM    PPC_FLAG1,$PPC_F1DEBUGS    Debugging short?
         BNO   RAR$DB1UX                  No, skip record echo
         L     R15,=V(RAA$DATA)           -> Data CSECT
         MVC   RECOUT(133),C_DASHLINE-RAA$DATA(R15)
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message
RAR$DB1UX EQU *
*
** Print input record hex dump format
*
         TM    PPC_FLAG1,$PPC_F1DEBUGF    Debugging full mode?
         BNO   RAR$DB1FX                  No, skip hex dump
*
         TM    X_FLAG1,$XF1_NMXD          Determined not available?
         BO    RAR$DB1FX                  Yes, continue
         TM    X_FLAG2,$XF2_DMXD          Loaded DA$MXD already?
         BO    RAR$DB1RX                  Yes, continue
         ICM   R0,B'1111',=V(DA$MXD)      DA$MXD linked into us?
         BNZ   RAR$DB1LX                  Yes, use it
         LA    R8,=CL8'DA#MXD'            -> Name of routine
         LOAD  EPLOC=(8),ERRET=RAR$DB1RE  Load into V/S
         OI    X_FLAG2,$XF2_DMXD          Turn on flag
RAR$DB1LX DS   0H
         ST    R0,EP_DA$MXD               Save address
         B     RAR$DB1RX                  Continue
RAR$DB1RE EQU  *
         OI    X_FLAG1,$XF1_NMXD          Turn on flag
         BAS   R9,FORMAT_MESSAGE          Format Message
         MVC   0(MSG99L,R15),MSG99-RAA$DATA(R1)
         MVC   MSG99L(8,R15),0(R8)
         MVC   MSG99L+8(34,R15),=C', no hex dumps will be performed'
         BAS   R9,PRINT_SYSPRINT_RECORD
         B     RAR$DB1FX
RAR$DB1RX EQU  *
*
         BAS   R14,CLEAR_RECOUT           Clear record to blanks
         BAS   R9,PRINT_SYSPRINT_RECORD   Print blank line
*
         BAS   R14,CLEAR_RECOUT           Clear record to blanks
         MVC   0(22,R15),=C'+ Dump of input record'
         LA    R15,23(R15)
         L     R1,RAR_CNTIREC             Get record number
         BAS   R9,EDITFWF                 Edit it
         MVC   0(14,R15),=C', in buffer at'
         LA    R15,15(R15)
         ST    R5,DOUBLE
         UNPK  0(9,R15),DOUBLE(5)
         MVZ   0(8,R15),=X'00,00,00,00,00,00,00,00'
         TR    0(8,R15),=C'0123456789ABCDEF'
         LA    R15,8(R15)
         MVI   0(R15),C':'                Insert colon
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message
*
         LA    R3,WA_FWA_SYSPRINT         Locate File-Work-Area
*
         XC    PARMLIST(CMXDL),PARMLIST   Initialize area
         LR    R15,R5                     Locate input record
         LA    R1,SYSUT1                  Locate DCB
         LH    R0,DCBLRECL-IHADCB(R1)     Get LRECL
         LA    R1,RECOUT+3                Get output location
         STM   R15,R1,PARMLIST+CMXD_ADDRESS-CMXD Data, Length, Output
         MVC   PARMLIST+CMXD_OUTPUTL-CMXD(2),=AL2(132)
RAR$DB1L EQU   *
         BAS   R14,CLEAR_RECOUT           Clear record to blanks
         LA    R1,PARMLIST                Locate work area
         L     R15,EP_DA$MXD              -> DA$MXD E.P.A.
         BASSM R14,R15                    Call DA$MXD
         LR    R8,R15                     Save return code
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message
         LTR   R8,R8                      Any more lines to do...
         BNZ   RAR$DB1L                   Thank you: May I have another
RAR$DB1FX EQU  *
*
** Print input record in charater
*
         TM    PPC_FLAG1,$PPC_F1DEBUGS    Debugging short?
         BNO   RAR$DB1SX                  No, skip record echo
         BAS   R14,CLEAR_RECOUT           Clear record to blanks
         MVI   0(R15),C'>'
         LA    R15,2(R15)
         MVC   0(121-1,R15),1(R5)
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message
RAR$DB1SX EQU  *
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**       Parse for record type                                       **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
         CLI   AHS_CC-AHS(R5),X'8B'       Werid FBM thang?
         BE    RAR$LX
*
         CLC   AHSI_IEVMSGP-AHS(6,R5),=C'   IEV'
         BE    RAR$IEV
*
         CLC   AHST_PAGELIT-AHS(4,R5),=C'PAGE'
         BE    RAR$TITLE
*
         CLC   AHSH_LOC-AHS(3,R5),=C'LOC'
         BE    RAR$HEAD
*
         CLI   AHSD_STMT+4-AHS(R5),C'0'
         BNL   RAR$DATA
         CLI   AHSD_MACEXP-AHS(R5),C'+'
         BE    RAR$DATA
*
** End of processing
*
RAR$LX   EQU   *
         TM    X_FLAG1,$XF1_DHB           Doing Data Book Handbook?
         BNO   RAR$LXDHBX                 No, continue
         BAS   R14,RAR$DHB                Yes, do routine
RAR$LXDHBX EQU *
         TM    X_FLAG1,$XF1_SRC
         BNO   RAR$LXSRCX                 No, continue
         BAS   R14,RAR$SRC                Yes, do routine
RAR$LXSRCX EQU *
         TM    X_FLAG1,$XF1_PASS3         Doing Data Book Handbook?
         BNO   RAR$LXP3X                  No, continuen
         BAS   R14,RAR$PASS3              Yes, do routine
RAR$LXP3X EQU  *
         TM    RAR_DPFLAG1,$RARDPF1_CONT  Continutation card
         BO    RAR$LXRFX                  Yes, no reset...
         BAS   R14,RAR$RSETF              Reset fields
RAR$LXRFX EQU  *
         B     RAR$L                      Read next record
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**       Data/Assembler Instruction record                           **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
RAR$DATA  EQU  *
         MVI   RAR_TYPE,$RART_DATA       Indicate we get instructions
*
** Debugging message
*
         TM    PPC_FLAG1,$PPC_F1DEBUGS    Debugging short?
         BNO   RAR$DDB1X                  No, skip type found
         BAS   R14,CLEAR_RECOUT           Clear record to blanks
         MVC   0(23,R15),=C'# Record type detected:'
         LA    R15,24(R15)
         MVC   0(4,R15),=C'Data'          Get type
         TM    RAR_FLAG2,$RARF2_TRAILER   Trailer record?
         BNO   RAR$DDB1P                  No, continue
         MVC   5(9,R15),=C'(trailer)'
RAR$DDB1P EQU  *
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message
RAR$DDB1X EQU  *
         TM    RAR_FLAG2,$RARF2_TRAILER   Trailer record?
         BO    RAR$LX                     Yes, skip it
*
** Continuation initialization
*
         NI    RAR_DPFLAG1,255-$RARDPF1_PCONT Ensure flag is off
         TM    RAR_DPFLAG1,$RARDPF1_CONT  Previous line continued?
         BNO   RAR$DCONTS
         OI    RAR_DPFLAG1,$RARDPF1_PCONT Set flag
RAR$DCONTS EQU *
         NI    RAR_DPFLAG1,255-$RARDPF1_CONT Ensure flag is off
         CLI   AHSD_CONT-AHS(R5),C' '     This line continued?
         BE    RAR$DCONTX                 No, move on
         OI    RAR_DPFLAG1,$RARDPF1_CONT  This line is continued
RAR$DCONTX EQU *
*
** Get the current location
*
         CLI   AHSD_LOC-AHS(R5),C'0'      Numeric location?
         BL    RAR$DLOCX                  No, skip it
         LA    R15,RAR_DPLOCCP            Locate input hex char string
         MVC   0(2,R15),=C'00'            Ensure leading zeros
         MVC   RAR_DPLOCC(6),AHSD_LOC-AHS(R5)
         LA    R0,4                       Input length / 2
         LA    R1,RAR_DPLOCX              Locate output hex value str
         BAS   R8,HEXTRAN                 Make right
RAR$DLOCX EQU *
*
** Get address 2
*
         XC    RAR_DPADDR2X(4),RAR_DPADDR2X  Zero field
         CLI   AHSD_ADDR2-AHS(R5),C'0'    Numeric Address 2?
         BL    RAR$DADDR2X                No, skip it
         LA    R15,RAR_DPADDR2CP          Locate input hex char string
         MVC   0(3,R15),=C'000'           Insert leading zeros
         MVC   RAR_DPADDR2C(5),AHSD_ADDR2-AHS(R5)
         LA    R0,4                       Input length / 2
         LA    R1,RAR_DPADDR2X            Locate output hex value str
         BAS   R8,HEXTRAN                 Make right
RAR$DADDR2X EQU *
*
** Set up for parse
*
         LA    R2,AHSD_SOURCE-AHS(R5)     Locate assembler source
         LA    R3,L'AHSD_SOURCE           Get length of source
         CLC   0(2,R2),=C'.*'             Macro comment?
         BE    RAR$DCOMX                  Yes, go straight to inc
         CLI   0(R2),C'*'                 Comment record?
         BE    RAR$DCOM                   Yes, process it for dir.
*
** Trap the NAME field (if any)
*
         TM    RAR_DPFLAG1,$RARDPF1_PCONT Previous line continued?
         BNO   RAR$DC1X                   No, move on
         LA    R2,15(R2)                  Bump to Operand field
         SH    R3,=H'15'                  Decrement counter
         B     RAR$DPOPR                  Bump to operand
RAR$DC1X EQU   *
         CLI   0(R2),C' '                 Got a "NAME"
         BE    RAR$DPNX                   No, continue
         L     R4,RAR_DPNAMEA             Locate output field
         MVI   0(R4),C' '
         MVC   1(L'RAR_DPNAME-1,R4),0(R4)
         LA    R0,63                      Maximum length
         BAS   R14,RAR$DENDF              Locate end of field
RAR$DPNLX EQU  *
         LA    R14,RAR_DPNAME             Locate start
         SR    R4,R14                     Length = End - Beginning
         BCTR  R4,0                       Decrement by 1
         STH   R4,RAR_DPNAMEL             Save length
RAR$DPNX EQU   *
*
** Locate the OPERATION field
**
** Note: We will *assume* that the operation field is not continued...
*
         BAS   R14,RAR$DNEXTF             Locate next field
         LTR   R3,R3                      At wits end?
         BZ    RAR$DPX                    Yes, leave
*
         L     R4,RAR_DPOPTA              Locate current location
         LR    R0,R3                      Maximum length
         BAS   R14,RAR$DENDF              Locate end of field
         ST    R4,RAR_DPOPTA              Save current location
         LA    R15,RAR_DPOPT              Locate beginning
         SR    R4,R15                     Length = End - Beginning
         BCTR  R4,0                       Decrement by 1
         STH   R4,RAR_DPOPTL              Save length
RAR$DPOTX EQU *
*
** Trap the OPERAND field
*
RAR$DPOPR EQU *
         TM    RAR_DPFLAG1,$RARDPF1_PCONT Previous line continued?
         BNO   RAR$DPOPRCX                No, move on
         TM    RAR_DPFLAG1,$RARDPF1_OPERAND In operand mode?
         BNO   RAR$DPOPRX                 No, remaining must be rem.
         B     RAR$DPOPRS                 Don't remove blanks...
RAR$DPOPRCX EQU *
         BAS   R14,RAR$DNEXTF             Locate next field
         LTR   R3,R3                      At wits end?
         BZ    RAR$DPX                    Yes, leave
RAR$DPOPRS EQU *
         L     R4,RAR_DPOPRA              Locate current location
         LR    R0,R3                      Maximum length
         OI    RAR_DPFLAG1,$RARDPF1_OPERAND Turn on operand flag
         BAS   R14,RAR$DENDF              Locate end of field
         ST    R4,RAR_DPOPRA              Save current location
         LA    R15,RAR_DPOPR              Locate beginning
         SR    R4,R15                     Length = End - Beginning
         BCTR  R4,0                       Decrement by 1
         STH   R4,RAR_DPOPRL              Save length
         LTR   R3,R3                      Check length
         BZ    RAR$DPX                    Zero, field is continued
         BM    RAR$DPX                    Minus: field is continued
RAR$DPOPRX EQU *
         NI    RAR_DPFLAG1,255-$RARDPF1_OPERAND
*
** Trap the REMARKS field
*
         BAS   R14,RAR$DNEXTF             Locate next field
         LTR   R3,R3                      At wits end?
         BZ    RAR$DPX                    Yes, leave
*
         TM    PPC_FLAG1,$PPC_F1NOCDASH   Eliminate leading dash?
         BNO   RAR$DRCDX                  No, continue
         CLC   0(2,R2),=C'- '             Leading dash?
         BNE   RAR$DRCDX                  No, continue
         LA    R2,1(R2)                   Bump past it
         BCTR  R3,0                       Decrement length
         LTR   R3,R3                      Anything left?
         BZ    RAR$DPX                    No, continue
         BAS   R14,RAR$DNEXTF             Locate next field
         LTR   R3,R3                      At wits end?
         BZ    RAR$DPX                    Yes, leave
RAR$DRCDX EQU  *
*
         L     R1,RAR_CNTREMARK           Get current count
         LA    R1,1(R1)                   Increment it
         ST    R1,RAR_CNTREMARK           Save count
*
         LA    R15,AHSD_CONT-1-AHS(R5)    Locate last possible
         LR    R0,R3                      Maximum length
         BAS   R14,LOCATE_LAST_NSPACE     Locate end of field
         SR    R15,R2                     Length = End - Beginning
         L     R4,RAR_DPREMARKA           Get current locaiton
         TM    PPC_FLAG1,$PPC_F1STRIPC    Strip IBM change status?
         BO    RAR$DPRC                   Yes, continue
*
         EX    R15,RAR$DPRM               Append remark
         LA    R4,1(R15,R4)               Bump past it
         B     RAR$DPRX
RAR$DPRM MVC   0(0,R4),0(R2)              ** Executed **
RAR$DPRC EQU   *
         LA    R14,1(R15)                 Get length + 1
RAR$DPRCL EQU  *
* - - - - - - - - - - - - - - - - - - - - Strip Change ID - - - - - *
         CLI   0(R2),C'#'                 Pound sign?
         BE    RAR$DPRCL$AL               No, continue
         CLI   0(R2),C'@'                 At sign?
         BNE   RAR$DPRCLB                 No, continue
RAR$DPRCL$AL EQU *
         CLI   0(R2),C' '                 End yet?
         BE    RAR$DPRCLB                 Yes, continue
         LA    R2,1(R2)                   No, bump past byte
         BCTR  R15,0                      Decrement Length count
         BCT   R14,RAR$DPRCL$AL           Decrement loop count
         B     RAR$DPRX                   Found end of the line
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
RAR$DPRCLB EQU *
         MVC   0(1,R4),0(R2)              Move current byte
         LA    R2,1(R2)                   Bump to next input byte
         LA    R4,1(R4)                   Decrement length
         BCT   R14,RAR$DPRCL              Process next byte
RAR$DPRX EQU   *
         LH    R1,RAR_DPREMARKL           Get Previous length
         AR    R15,R1                     Add to current
         LA    R15,1(R15)                 Append space (length)
         MVI   0(R4),C' '                 Append space (value)
         LA    R4,1(R4)                   Append space for multi-lines
         STH   R15,RAR_DPREMARKL          Save total length
         ST    R4,RAR_DPREMARKA           Save it
RAR$DPX  EQU   *                          Parsing complete!!!!!!!
*
** Check for unbalanced quotes
*
         TM    RAR_DPFLAG1,$RARDPF1_CONT  This line continued?
         BO    RAR$DCCX                   No, continue on
         TM    RAR_DPFLAG1,$RARDPF1_QUOTE Trailing quote?
         BNO   RAR$DCCX                   No, its cool
         BAS   R9,FORMAT_MESSAGE          Format Message
         MVC   0(MSG10L,R15),MSG10-RAA$DATA(R1)
         LA    R15,MSG10L+1(R15)          Bump past it
         L     R1,RAR_CNTIREC             Get rel. record number
         BAS   R9,EDITFWF                 Edit it
         MVC   0(9,R15),=C', at STMT'
         MVC   9(L'AHSD_STMT,R15),AHSD_STMT-AHS(R5)
         BAS   R9,PRINT_SYSPRINT_RECORD   Print record
         NI    RAR_DPFLAG1,255-$RARDPF1_QUOTE
RAR$DCCX EQU   *
*
** Debugging: Show what we got
*
RAR$DDB2 EQU   *
         TM    PPC_FLAG1,$PPC_F1DEBUGS    Debugging short?
         BNO   RAR$DDB2X                  No, continue
         BAS   R14,CLEAR_RECOUT           Clear record to blanks
         MVI   0(R15),C'+'
         LA    R15,2(R15)
*
         CLI   RAR_DPNAME,0
         BE    RAR$DDB2NX
         MVC   0(5,R15),=C'Name('
         LA    R15,5(R15)
         LH    R14,RAR_DPNAMEL
RAR$DDB2M MVC  0(0,R15),RAR_DPNAME
         EX    R14,RAR$DDB2M
         LA    R15,1(R14,R15)
         MVI   0(R15),C')'
         LA    R15,2(R15)
RAR$DDB2NX EQU *
*
         CLI   RAR_DPOPT,0
         BE    RAR$DDB2OTX
         MVC   0(10,R15),=C'Operation('
         LA    R15,10(R15)
         LH    R14,RAR_DPOPTL
         MVC   0(0,R15),RAR_DPOPT
         EX    R14,*-6
         LA    R15,1(R14,R15)
         MVI   0(R15),C')'
         LA    R15,2(R15)
RAR$DDB2OTX EQU *
*
         CLI   RAR_DPOPR,0
         BE    RAR$DDB2ORX
         MVC   0(8,R15),=C'Operand('
         LA    R15,8(R15)
         LH    R14,RAR_DPOPRL
         CH    R14,=H'60'
         BNH   RAR$DDB2OR
         LA    R14,60
RAR$DDB2OR EQU *
         MVC   0(0,R15),RAR_DPOPR
         EX    R14,*-6
         LA    R15,1(R14,R15)
         MVI   0(R15),C')'
         LA    R15,2(R15)
RAR$DDB2ORX EQU *
*
         CLI   RAR_DPREMARK,C' '
         BE    RAR$DDB2RX
         MVC   0(8,R15),=C'Remarks('
         LA    R15,8(R15)
         LH    R14,RAR_DPREMARKL
         CH    R14,=H'60'
         BNH   RAR$DDB2R
         LA    R14,60
RAR$DDB2R EQU *
         MVC   0(0,R15),RAR_DPREMARK
         EX    R14,*-6
         LA    R15,1(R14,R15)
         MVI   0(R15),C')'
         LA    R15,2(R15)
RAR$DDB2RX EQU *
*
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message
RAR$DDB2X EQU  *
*
** Full Debugging stuff
*
         TM    PPC_FLAG1,$PPC_F1DEBUGF    Debugging Full?
         BNO   RAR$DDB3X                  No, continue
         BAS   R14,CLEAR_RECOUT           Clear record to blanks
         MVI   0(R15),C'+'
         LA    R15,2(R15)
*
         MVC   0(4,R15),=C'LOC('
         LA    R15,4(R15)
         MVC   0(L'AHSD_LOC,R15),AHSD_LOC-AHS(R5)
         LA    R15,L'AHSD_LOC(R15)
         MVI   0(R15),C')'
         LA    R15,2(R15)
*
         MVC   0(5,R15),=C'OBJ1('
         LA    R15,5(R15)
         MVC   0(L'AHSD_OBJ1,R15),AHSD_OBJ1-AHS(R5)
         LA    R15,L'AHSD_OBJ1(R15)
         MVI   0(R15),C')'
         LA    R15,2(R15)
*
         MVC   0(5,R15),=C'OBJ2('
         LA    R15,5(R15)
         MVC   0(L'AHSD_OBJ2,R15),AHSD_OBJ2-AHS(R5)
         LA    R15,L'AHSD_OBJ2(R15)
         MVI   0(R15),C')'
         LA    R15,2(R15)
*
         MVC   0(5,R15),=C'OBJ3('
         LA    R15,5(R15)
         MVC   0(L'AHSD_OBJ3,R15),AHSD_OBJ3-AHS(R5)
         LA    R15,L'AHSD_OBJ3(R15)
         MVI   0(R15),C')'
         LA    R15,2(R15)
*
         MVC   0(6,R15),=C'ADDR1('
         LA    R15,6(R15)
         MVC   0(L'AHSD_ADDR1,R15),AHSD_ADDR1-AHS(R5)
         LA    R15,L'AHSD_ADDR1(R15)
         MVI   0(R15),C')'
         LA    R15,2(R15)
*
         MVC   0(6,R15),=C'ADDR2('
         LA    R15,6(R15)
         MVC   0(L'AHSD_ADDR2,R15),AHSD_ADDR2-AHS(R5)
         LA    R15,L'AHSD_ADDR2(R15)
         MVI   0(R15),C')'
         LA    R15,2(R15)
*
         MVC   0(5,R15),=C'CONT('
         LA    R15,5(R15)
         MVC   0(L'AHSD_CONT,R15),AHSD_CONT-AHS(R5)
         LA    R15,L'AHSD_CONT(R15)
         MVI   0(R15),C')'
         LA    R15,2(R15)
*
         MVC   0(7,R15),=C'SEQNUM('
         LA    R15,7(R15)
         MVC   0(L'AHSD_SEQNUM,R15),AHSD_SEQNUM-AHS(R5)
         LA    R15,L'AHSD_SEQNUM(R15)
         MVI   0(R15),C')'
         LA    R15,2(R15)
*
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message
RAR$DDB3X EQU  *
*
** Starting and ending label processing
*
         CLI   RAR_DPNAME,0               Name/Label present?
         BE    RAR$D_CCNX                 No, skip checking
         LH    R1,RAR_DPNAMEL             Get length of name/label
         LA    R1,1(R1)                   Increment to add space at end
         CLI   RAR_SNAME,0                Start label present?
         BE    RAR$D_CCN_SLX              No, continue
         TM    RAR_FLAG1,$RARF1_NPROC     Processing now?
         BNO   RAR$D_CCN_SLX              No, forget 'bout it
         EX    R1,RAR$D_CCN_SLC           Name/Label match?
         BNE   RAR$D_CCN_SLX              No, continue
         NI    RAR_FLAG1,255-$RARF1_NPROC Turn off "No Processing" flag
         OI    RAR_FLAG1,$RARF1_SNAME     Indicate we just saw it
         B     RAR$D_CCNX                 If a Start, can't be 'else
RAR$D_CCN_SLC CLC RAR_DPNAME(0),RAR_SNAME
RAR$D_CCN_ELC CLC RAR_DPNAME(0),RAR_ENAME
*
RAR$D_CCN_SLX EQU *
         CLI   RAR_ENAME,0                Start label present?
         BE    RAR$D_CCN_ELX              No, continue
         EX    R1,RAR$D_CCN_ELC           Name/Label match?
         BNE   RAR$D_CCN_ELX              No, continue
         OI    RAR_FLAG1,$RARF1_NPROC     Turn on "No Processing" flag
         OI    RAR_FLAG1,$RARF1_ENAME     Indicate we just saw it
RAR$D_CCN_ELX EQU *
RAR$D_CCNX EQU *
*
** DSECT processing
*
         CLC   RAR_DPOPT(C_DSECTL),C_DSECT
         BNE   RAR$DDX
*        TM    X_FLAG1,$XF1_SRC
*        BNO   RAR$DDSX
*        ICM   R0,B'1111',RAR_DPLOCX      Same DSECT
*        BNZ   RAR$DDX                    Yes, they're playing games
RAR$DDSX EQU   *
         BAS   R14,RAR$PM17               Print Message 17 if needed
         OI    RAR_FLAG1,$RARF1_DSECT     Set in DSECT mode
         NI    RAR_FLAG1,255-$RARF1_CSECT Can't be in CSECT mode...
*
         LA    R8,C_DSECT
         B     RAR$DMSG7
RAR$DDX  EQU   *
*
** CSECT processing
*
         CLC   RAR_DPOPT(C_CSECTL),C_CSECT
         BNE   RAR$DCX
         BAS   R14,RAR$PM17               Print Message 17 if needed
         OI    RAR_FLAG1,$RARF1_CSECT     Set in CSECT mode
         NI    RAR_FLAG1,255-$RARF1_DSECT Can't be in DSECT mode...
         MVC   RAR_CSECT(8),=8C' '        Ensure trailing blanks
         CLI   RAR_DPNAME,0               Got a label/name?
         BE    RAR$DCX                    No, skip it
         LH    R14,RAR_DPNAMEL            Get length of field
         LA    R1,8                       Get max length
         CR    R14,R1                     Okay?
         BNH   RAR$DCN                    Yes, continue
         LR    R14,R1                     No, set truncated
RAR$DCN  EQU   *
         EX    R14,RAR$DCM                Move in CSECT Name
         ST    R14,DOUBLE
         LA    R8,C_CSECT
RAR$DMSG7 EQU  *
         BAS   R14,RAR$PM17               Print Message 17 if needed
         BAS   R9,FORMAT_MESSAGE          Format Message
         MVC   0(MSG7L,R15),MSG7-RAA$DATA(R1)
         LA    R15,MSG7L(R15)             Bump past it
         MVC   0(5,R15),0(R8)             Get type: DSECT or CSECT
         MVI   5(R15),C':'                Insert delimiter
         LH    R14,RAR_DPNAMEL            Obtain length
         EX    R14,RAR$DM7M               Move in CSECT/DSECT name
         BAS   R9,PRINT_SYSPRINT_RECORD   Print record
RAR$DCX  EQU   *
*
** End card
*
         CLC   RAR_DPOPT(C_ENDL),C_END    End card?
         BNE   RAR$DENDX
         NI    RAR_FLAG1,255-$RARF1_DSECT
         NI    RAR_FLAG1,255-$RARF1_CSECT
RAR$DENDX EQU  *
*
** End of RAR$DATA processing
*
RAR$DATAX EQU  *
         B     RAR$LX
RAR$DCM  MVC   RAR_CSECT(0),RAR_DPNAME    ** Executed **
RAR$DM7M MVC   7(0,R15),RAR_DPNAME        ** Executed **
*
** Print message 17 if needed
*
RAR$PM17 DS    0H
         ICM   R0,B'1111',RAR_LOVER       Any overflows?
         BZ    RAR$PM17X                  No, continue
         ST    R14,RAR_LOVERR             Save return address
         BAS   R9,FORMAT_MESSAGE          Format Message
         MVC   0(MSG17L,R15),MSG17-RAA$DATA(R1)
         LA    R15,MSG17L+1(R15)          Bump past message
         ICM   R1,B'1111',RAR_LOVER       Get count
         BAS   R9,EDITFWF                 Edit the count
         MVC   1(18,R15),=C'times, max length:' Get trailing text
         LA    R15,1+18+1(R15)            Bump past text
         LH    R1,RAR_LOVERLC             Get count
         BAS   R9,EDITFWF                 Edit the count
         BAS   R9,PRINT_SYSPRINT_RECORD   Print record
         XC    RAR_LOVER(4),RAR_LOVER     Reset Line Overflow
         XC    RAR_LOVERLC(2),RAR_LOVERLC Reset length
         L     R14,RAR_LOVERR             Get return address
RAR$PM17X DS  0H
         BSM   0,R14
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Data: Comment                                                     **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
RAR$DCOM EQU   *
         CLC   1(1,R2),PPC_CCC            Our special symbol?
         BNE   RAR$DCOMX                  No, continue
         CLI   2(R2),C' '                 Space after cntl char?
         BNE   RAR$DCOMX                  No, must not be ours...
*
         LA    R2,3(R2)                   Bump past "*! "
         SH    R3,=H'3'                   Decrement count
         BAS   R14,RAR$DNEXTF             Locate first field
         LTR   R3,R3                      Found it
         BNZ   RAR$DC_FNZ                 Yes, continue
*
         BAS   R9,FORMAT_MESSAGE          Format Message
         MVC   0(MSG6L,R15),MSG6-RAA$DATA(R1) Get message
         LA    R15,MSG6L+1(R15)           Bump past it
         L     R1,RAR_CNTIREC             Get rel. record number
         BAS   R9,EDITFWF                 Edit it
         MVC   0(9,R15),=C', at STMT'
         MVC   9(L'AHSD_STMT,R15),AHSD_STMT-AHS(R5)
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message
         B     RAR$DCOMX                  Continue
RAR$DC_FNZ EQU  *
         STM   R2,R3,RAR_DCREGS           Save registers
         LA    R0,L'TDC_VERB              Get max length of verb
         LA    R4,RAR_DCVERB              Locate output area
         MVI   0(R4),C' '                 Clear to blank
         MVC   1(L'RAR_DCVERB,R4),0(R4)    ..Propagate 'em
         BAS   R14,RAR$DENDF              Trap verb
         LA    R15,RAR_DCVERB+1           Locate start (+1 for EX)
         SR    R4,R15                     Length = end - start
*
** Search thru "Comment Directive" verb table for match
*
         L     R1,=V(RAA$DATA)            -> Data CSECT
         LA    R1,T_COMDIR-RAA$DATA(R1)   Locate table
         LA    R0,T_COMDIRN               Get number in table
RAR$DC_TCDL EQU *
         CLM   R4,B'0001',TDC_VERBL-TDC(R1) Verb length match?
         BNE   RAR$DC_TCDLB               No, continue
         EX    R4,RAR$DC_TCDC             Verb value match?
         BE    RAR$DC_TCDLX               Yes, continue
RAR$DC_TCDLB EQU *
         LA    R1,TDCL(R1)                Bump past entry
         BCT   R0,RAR$DC_TCDL             Process it
*
** Verb not found, gripe about it
*
         BAS   R9,FORMAT_MESSAGE          Format Message
         MVC   0(MSG13L,R15),MSG13-RAA$DATA(R1) Get message
         LA    R15,MSG13L+1(R15)          Bump past it
         L     R1,RAR_CNTIREC             Get rel. record number
         BAS   R9,EDITFWF                 Edit it
         MVC   0(9,R15),=C', at STMT'
         MVC   9(L'AHSD_STMT,R15),AHSD_STMT-AHS(R5)
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message
         B     RAR$DCOMX
RAR$DC_TCDC    CLC TDC_VERB-TDC(0,R1),RAR_DCVERB
RAR$DC_TCDLM   MVC 0(0,R15),0(R1)
*
** Invalid or missing operand
*
RAR$DC_IOPER EQU *
         BAS   R9,FORMAT_MESSAGE          Format Message
         MVC   0(MSG14L,R15),MSG14-RAA$DATA(R1) Get message
         LA    R15,MSG14L+1(R15)          Bump past it
         MVC   0(L'TDC_VERB,R15),RAR_DCVERB Move in verb
         LA    R0,L'TDC_VERB              Get length of verb
         BAS   R14,LOCATE_FIRST_SPACE     Locate first space
         MVC   1(9,R15),=C'on record'     Get text
         LA    R15,1+9+1(R15)             Bump past it
         L     R1,RAR_CNTIREC             Get rel. record number
         BAS   R9,EDITFWF                 Edit it
         MVC   0(9,R15),=C', at STMT'
         MVC   9(L'AHSD_STMT,R15),AHSD_STMT-AHS(R5)
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message
         B     RAR$DCOMX
*
** Found entry: Get routine address, find operand (if any), print
** message, and branch to the routine
*
RAR$DC_TCDLX EQU *
         SLR   R8,R8                      Clear register
         ICM   R8,B'0011',TDC_ROUTINE-TDC(R1) Get routine offset
         AR    R8,R12                     Calc routine address
         BAS   R14,RAR$DNEXTF             Locate next field
*
         BAS   R9,FORMAT_MESSAGE          Format Message
         MVC   0(MSG9L,R15),MSG9-RAA$DATA(R1)
         LA    R15,MSG9L+1(R15)           Bump past it
         L     R1,RAR_DCREGS              Get address
         L     R14,RAR_DCREGS+4           Get length
         BCTR  R14,0                      Decrement
         EX    R14,RAR$DC_TCDLM           Move line to message
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message
*
         BR    R8
*
** DSECT header
*
RAR$DC_DSECTH EQU *
         TM    X_FLAG1,$XF1_DSECTHO       Overflow?
         BO    RAR$DC_DHOF                Yes, we can't take a joke
         LTR   R3,R3                      Check out length
         BZ    RAR$DC_IOPER               Zero: end of record
         ICM   R8,B'1111',RAR_DCDSECTHC   -> Data area
         BNZ   RAR$DC_DHS                 We got it, continue
         L     R0,=F'32760'               Get some memory
         GETMAIN R,LV=(0)                 Obtain storage
         STM   R0,R1,RAR_DCDSECTH         Save length and address
         LR    R8,R1
RAR$DC_DHS EQU *
         LR    R4,R8                      Locate output area
         MVI   0(R4),C' '                 Get blank
         MVC   1(DSHL-1,R4),0(R4)         ..Propagate it
         LA    R0,L'DSH_NAME              Get length to trap
         BAS   R14,RAR$DENDF              Trap label
         BAS   R14,RAR$DNEXTF             Locate next field
         LTR   R3,R3                      Any thing left?
         BZ    RAR$DC_DHOX                No, blanks is all...
         LR    R15,R2                     Get current location
         AR    R15,R3                     Locate the end
         LR    R0,R3                      Get length left
         BAS   R14,LOCATE_LAST_NSPACE     Backup to last space
         SR    R15,R2                     Length = End - Start
         LA    R0,L'DSH_DCFCODE-1         Get length to trap
         CR    R15,R0                     Too much?
         BNH   RAR$DC_DHOS                No, continue
         LA   R15,L'DSH_DCFCODE-1         Get length to trap
RAR$DC_DHOS EQU *
RAR$DC_DHOM MVC DSH_DCFCODE-DSH(0,R8),0(R2)
         EX     R15,RAR$DC_DHOM           Move operand to area
RAR$DC_DHOX EQU *
         LA    R8,DSHL(R8)                Bump to next entry
         L     R1,RAR_DCDSECTH+4          Get start of area
         A     R1,RAR_DCDSECTH            Get length of area
         BCTR  R1,0                       Locate last byte of area
         CR    R8,R1                      Are we about to run out?
         BH    RAR$DC_DHOE                Yes, gripe about it
         ST    R8,RAR_DCDSECTHC           Save current
         B     RAR$DCOMX                  Continue
RAR$DC_DHOE EQU *
         OI    X_FLAG1,$XF1_DSECTHO       Turn on overflow flag
*
         BAS   R9,FORMAT_MESSAGE          Format Message
         MVC   0(MSG15L,R15),MSG15-RAA$DATA(R1)
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message
*
RAR$DC_DHOF EQU *
         BAS   R9,FORMAT_MESSAGE          Format Message
         MVC   0(MSG16L,R15),MSG16-RAA$DATA(R1) Get message
         LA    R15,MSG16L+1(R15)          Bump past it
         L     R1,RAR_CNTIREC             Get rel. record number
         BAS   R9,EDITFWF                 Edit it
         MVC   0(9,R15),=C', at STMT'
         MVC   9(L'AHSD_STMT,R15),AHSD_STMT-AHS(R5)
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message
         B     RAR$DCOMX
*
** Start name (label)
*
RAR$DC_SNAME EQU *
         LTR   R3,R3                      Check out length
         BZ    RAR$DC_IOPER               Zero: end of record
         LA    R0,L'RAR_SNAME             Get max length of area
         LA    R4,RAR_SNAME               Locate it
         MVI   0(R4),C' '                 Get blank
         MVC   1(L'RAR_SNAME-1,R4),0(R4)   ..Propagate it
         BAS   R14,RAR$DENDF              Trap label
         OI    RAR_FLAG1,$RARF1_NPROC     Turn on no-processing flag
         B     RAR$DCOMX
*
** End name (label)
*
RAR$DC_ENAME EQU *
         LTR   R3,R3                      Check out length
         BZ    RAR$DC_IOPER               Zero: end of record
         LA    R0,L'RAR_ENAME             Get max length of area
         LA    R4,RAR_ENAME               Locate it
         MVI   0(R4),C' '                 Get blank
         MVC   1(L'RAR_ENAME-1,R4),0(R4)   ..Propagate it
         BAS   R14,RAR$DENDF              Trap label
*
** Common exit from RAR$DCOM processing
*
RAR$DCOMX EQU *
         MVI   RAR_TYPE,$RART_DATAC       Change our mind: comment
         L     R1,RAR_CNTCOMMENT
         LA    R1,1(R1)
         ST    R1,RAR_CNTCOMMENT
         B     RAR$DPX
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**       Data Handbook                                               **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
RAR$DHB   EQU  *
         ST    R14,RAR_DHB_RA             Save return address
*
         TM    RAR_DPFLAG1,$RARDPF1_CONT  Current line continued?
         BO    RAR$DHBX                   Yes, don't have all info...
         CLI   RAR_TYPE,$RART_DATA        Data line?
         BNE   RAR$DHBX                   No, leave
*
         CLC   RAR_DPOPT(C_ENDL),C_END    End card?
         BE    RAR$DHBX                   Yes, skip it
         CLC   RAR_DPOPT(C_EJECTL),C_EJECT
         BE    RAR$DHBX                   Yes, skip it
         CLC   RAR_DPOPT(C_SPACEL),C_SPACE
         BE    RAR$DHBX                   Yes, skip it
         CLC   RAR_DPOPT(C_ORGL),C_ORG    ORG card?
         BE    RAR$DHBX                   Yes, skip it
         TM    RAR_FLAG1,$RARF1_DSECT     In DSECT mode?
         BNO   RAR$DHBX                   No, skip data handbook...
*
** Format the field with common fields
*
         BAS   R14,CLEAR_RECOUT           Clear recout to blanks
*
         CLI   RAR_DPNAME,0               Have a value?
         BE    RAR$DHB$NX                 No, skip it
         LH    R14,RAR_DPNAMEL            Get length of field
         L     R1,PPC_NAMEL               Get max length
*        AH    R1,=H'1'                   It's one less...
         CR    R14,R1                     Okay?
         BNH   RAR$DHB$N                  Yes, continue
         CH    R14,RAR_LOVERLC            No, check out max length
         BL    RAR$DHB$LOC                It's within the highest known
         STH   R14,RAR_LOVERLC            Save new higher
RAR$DHB$LOC DS 0H
         CH    R14,RAR_LOVERLT            No, check out max length
         BL    RAR$DHB$LOT                It's within the highest known
         STH   R14,RAR_LOVERLT            Save new higher
RAR$DHB$LOT DS 0H
         LR    R14,R1                     No, set truncated
         LA    R1,DHBR_NAME-DHBR(R15)     Locate to start of name
         A     R1,PPC_NAMEL               Bump to end
         MVI   1(R1),C'*'                 Indicate truncated...
         L     R0,RAR_LOVER               Get current count
         AH    R0,=H'1'                   Increment by one
         ST    R0,RAR_LOVER               Save new count
RAR$DHB$N EQU  *
         EX    R14,RAR$DHB$NM
RAR$DHB$NX EQU *
*
         CLI   RAR_DPREMARK,C' '          Have a value?
         BE    RAR$DHB$DX                 No, skip it
         LH    R14,RAR_DPREMARKL          Get length of field
         LA    R1,RAR_DHB_DESCL           Get max length
         CR    R14,R1                     Okay?
         BNH   RAR$DHB$D                  Yes, continue
         LR    R14,R1                     No, set truncated
RAR$DHB$D EQU  *
         LA    R1,DHBR_NAME-DHBR(R15)     Locate start of name
         A     R1,PPC_NAMEL               Add length of name
         EX    R14,RAR$DHB$DM             Move remark to area
RAR$DHB$DX EQU *
*
** Offset/Location
*
         CLC   RAR_DPOPT(C_EQUL),C_EQU    Equate?
         BE    RAR$DHBLNX                 Yes, skip it
*
         L     R1,RAR_DPLOCX
         CVD   R1,DOUBLE
         MVC   DHBR_OFFD-DHBR(8,R15),EDITP15F
         ED    DHBR_OFFD-DHBR(8,R15),DOUBLE+4
         OI    DHBR_OFFD+7-DHBR(R15),C'0' Ensure numeric if zero
*
         LA    R14,DHBR_OFFX-DHBR(R15)    Locate output for hex offset
         MVI   0(R14),C'('                Hex prefix
         LA    R14,1(R14)                 Bump past it
         LA    R1,RAR_DPLOCC              Locate hex character string
         LA    R0,L'RAR_DPLOCC-1          Get length
RAR$DHB$O1L EQU *
         CLI   0(R1),C'0'                 Leading zero?
         BNE   RAR$DHB$O2L                Yes,ignore it
         LA    R1,1(R1)
         BCT   R0,RAR$DHB$O1L
         B     RAR$DHB$O2LX
RAR$DHB$O2L EQU *
         MVC   0(1,R14),0(R1)             No, we need the puppy
         LA    R14,1(R14)                 Bump to next output byte
         LA    R1,1(R1)                   Bump to next input byte
         BCT   R0,RAR$DHB$O2L             ..Process next byte
RAR$DHB$O2LX  EQU *
         MVC   0(1,R14),0(R1)             No, we need the puppy
         MVI   1(R14),C')'                Attach hex suffix
RAR$DHBLNX EQU *
*
** Data type checking
*
         CLC   RAR_DPOPT(C_DSECTL),C_DSECT
         BE    RAR$DHB$DSE
         CLC   RAR_DPOPT(C_EQUL),C_EQU
         BE    RAR$DHB$EQU
         CLC   RAR_DPOPT(C_DCL),C_DC
         BE    RAR$DHBT
         CLC   RAR_DPOPT(C_DSL),C_DS
         BE    RAR$DHBT
*
** Isn't something we know about...
*
         L     R1,=V(RAA$DATA)
         LA    R1,T_BALSTMT-RAA$DATA(R1)  Locate ignore table
         LA    R0,T_BALSTMTN              Get length
RAR$DHB$BSXL EQU *
         CLC   0(8,R1),RAR_DPOPT          Match?
         BE    RAR$DHBX  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         LA    R1,8(R1)                   Bump to next entry
         BCT   R0,RAR$DHB$BSXL            Try it
*
         MVC   DHBR_TYPE-DHBR(8,R15),=C'BAL STMT'
         MVI   DHBR_OFFD-DHBR(R15),C' '
         MVC   DHBR_OFFD+1-DHBR(L'DHBR_OFFD-1,R15),DHBR_OFFD-DHBR(R15)
         MVI   DHBR_OFFX-DHBR(R15),C' '
         MVC   DHBR_OFFX+1-DHBR(L'DHBR_OFFX+1,R15),DHBR_OFFX-DHBR(R15)
* Note: Put Operation on DHBR_LEN which is not used for "BAL STMT"
         LH    R14,RAR_DPOPTL             Get length of field
         LA    R1,L'DHBR_LEN              Get max length
         CR    R14,R1                     Okay?
         BNH   RAR$DHB$BSL                Yes, continue
         LR    R14,R1                     No, set truncated
         MVI   DHBR_LEN+L'DHBR_LEN-DHBR(R15),C'<'
RAR$DHB$BSL    EQU *
         EX    R14,RAR$DHB$BSM            Move out operand field
         B     RAR$DHBTX
RAR$DHB$NM  MVC   DHBR_NAME-DHBR(0,R15),RAR_DPNAME
RAR$DHB$DM  MVC   3(0,R1),RAR_DPREMARK
RAR$DHB$BSM MVC   DHBR_LEN-DHBR(0,R15),RAR_DPOPT   ** Executed **
*
** DSECT
*
RAR$DHB$DSE EQU *
         MVC   DHBR_TYPE-DHBR(10,R15),T_OPRTST+(TOPRT_NAME-TOPRT)
         MVI   RAR_DHB_DESCC,C' '
         MVC   RAR_DHB_DESCC+1(L'RAR_DHB_DESCC-1),RAR_DHB_DESCC
         SLR   R1,R1                      Clear register
         IC    R1,C_DAHANDBKD             Get length of prefix
         SLR   R14,R14                    Clear register
         ICM   R14,B'0011',RAR_DPNAMEL    Get length of DSECT name
         BNZ   RAR$DHB$DSED               Go with it bozo
         MVC   RAR_DHB_DESCC(7),=C'Unknown'
         LA    R1,7(R1)                   Bump past it
         B     RAR$DHB$DSEDX
RAR$DHB$DSED EQU *
         L     R15,RAR_DPNAMEA            Get address of DSECT name
         EX    R14,RAR$DHB$DSEDM          Move DSECT name out
         LA    R14,1(R14)
RAR$DHB$DSEDX EQU *
         AR    R1,R14                     Increment length
         STC   R1,RAR_DHB_DESC            Save length of Desc string
*
         TM    RAR_FLAG1,$RARF1_NPROC     Doing any work now?
         BO    RAR$DHB$DSEDLX             No, continue
*
         TM    PPC_FLAG2,$PPC_F2DCF       DCF mode?
         BNO   RAR$DHB$DSE_DCFX
         BAS   R14,CLEAR_DHB_RECORD
         ICM   R0,B'1111',RAR_DHB_DSECTC
         BZ    RAR$DHB$DSE_DCF1X
         MVC   RAR_DHB_DREC(8),=C':etable.'
         BAS   R14,PUT_DCF_RECORD
RAR$DHB$DSE_DCF1X EQU *
         BAS   R14,CLEAR_DHB_RECORD       Clear record
         LA    R15,RAR_DHB_DREC           Locate start of record
         MVI   0(R15),C'.'                Get dot
         MVI   1(R15),C'*'                Get comment ID
         MVC   2(69,R15),1(R15)           ..Propagate it
         BAS   R14,PUT_DCF_RECORD         Print delimiter line
         BAS   R14,CLEAR_DHB_RECORD       Clear record
*
         MVC   RAR_DHB_DREC(4),=C':h1.'
         MVC   RAR_DHB_DREC+4(L'RAR_DHB_DESCC-1),RAR_DHB_DESCC
         BAS   R14,PUT_DCF_RECORD
*
         MVC   RAR_DHB_DREC(4),=C':i1.'
         BAS   R14,PUT_DCF_RECORD
*
         ICM   R8,B'1111',RAR_DCDSECTH+4  -> Entries
         BZ    RAR$DHB$DSE_DHLX           None, leave
RAR$DHB$DSE_DHL EQU *
         CLC   DSH_NAME-DSH(63,R8),RAR_DHB_DESCC  Match?
         BNE   RAR$DHB$DSE_DHLB           No, continue
*
         CLC   RAR_DHB_DREC(4),=C':i1.'   First time?
         BNE   RAR$DHB$DSE_DHLS           No, continue
         BAS   R14,CLEAR_DHB_RECORD       Clear record
         MVC   RAR_DHB_DREC(15),=C':dl tsize=25mm.'
         BAS   R14,PUT_DCF_RECORD
RAR$DHB$DSE_DHLS EQU *
*
         BAS   R14,CLEAR_DHB_RECORD       Clear record
         MVC   RAR_DHB_DREC(L'DSH_DCFCODE),DSH_DCFCODE-DSH(R8)
         BAS   R14,PUT_DCF_RECORD
RAR$DHB$DSE_DHLB EQU *
         LA    R8,DSHL(R8)                Bump to next entry
         C     R8,RAR_DCDSECTHC           At end?
         BNH   RAR$DHB$DSE_DHL            No, process next one
*
         CLC   RAR_DHB_DREC(4),=C':i1.'   First time?
         BE    RAR$DHB$DSE_DHLX           No, continue
         BAS   R14,CLEAR_DHB_RECORD       Clear record
         MVC   RAR_DHB_DREC(5),=C':edl.'
         BAS   R14,PUT_DCF_RECORD
RAR$DHB$DSE_DHLX EQU *
*
         L     R1,=V(RAA$DCF)             -> DCF data CSECT
         LA    R1,RAA$DCF_NDSECT-RAA$DCF(R1) Locate New DSECT stuff
         BAS   R14,PRINT_DCF_STRINGS      Print 'em
         BAS   R14,CLEAR_DHB_RECORD       Leave things blank
RAR$DHB$DSE_DCFX EQU *
*
         L     R14,RAR_DHB_DSECTC         Get current count
         LA    R14,1(R14)                 Increment by 1
         ST    R14,RAR_DHB_DSECTC         Save it
*
         LA    R0,1                       Generate 1
         L     R14,RAR_DHB_DSECTC         Get DSECT count
         CR    R14,R0                     Processing first DSECT?
         BE    RAR$DHB$DSEDLX             Yes, skip underline
         TM    PPC_FLAG2,$PPC_F2DCF       DCF mode?
         BO    RAR$DHB$DSE_PRDX
* Print previous record
         BAS   R14,RAR$DHB$PPREC          Print previous record
* Print dash line
         LA    R1,WA_FWA_REPORT           Locate File-Work-Area
         L     R15,=V(RAA$DATA)           Locate Data CSECT
         LA    R15,C_DASHLINE-RAA$DATA(R15) Locate dash line
         LR    R0,R15                     Locate output record
         L     R15,=V(RAA$PRT)            -> RAA$PRT CSECT
         BALR  R14,R15                    Call the print routine
* Mark previous record
RAR$DHB$DSE_PRDX EQU *
         MVI   RAR_DHB_PREC,0             Set initialize
RAR$DHB$DSEDLX EQU *
*
         LA    R1,WA_FWA_REPORT           Locate File-Work-Area
         OI    FWA_FLAG1-FWA(R1),$FWA_F1RDESC  Reset description str
         MVI   FWA_LINECNT-FWA(R1),99     Force heading
*
         TM    PPC_FLAG2,$PPC_F2DCF       DCF mode?
         BO    RAR$DHB$DSEDHLX            Yes, leave
         ICM   R8,B'1111',RAR_DCDSECTH+4  -> DSECT header table
         BZ    RAR$DHB$DSEDHLX            None, leave
         NI    X_FLAG1,255-$XF1_RHPROC
*
RAR$DHB$DSEDHL EQU *
         CLC   DSH_NAME-DSH(63,R8),RAR_DHB_DESCC  Match?
         BNE   RAR$DHB$DSEDHLB            No, continue
*
         MVC   DOUBLE(3),DSH_DCFCODE-DSH(R8) Grap control directive
         OC    DOUBLE+1(2),=C'  '         Ensure uppercase for compare
         CLC   DOUBLE(3),=C':DT'          Term?
         BE    RAR$DHB$DSEDHL_DT
         CLC   DOUBLE(3),=C':DD'          Description?
         BE    RAR$DHB$DSEDHL_DD
         CLC   DOUBLE(3),=C'.SP'          Need a space?
         BE    RAR$DHB$DSEDHL_SP
*
         BAS   R14,CLEAR_DHB_RECORD       Clear record to blanks
         MVC   RAR_DHB_DREC+20(L'DSH_DCFCODE),DSH_DCFCODE-DSH(R8)
         B     RAR$DHB$DSEDHL_PRT
*
RAR$DHB$DSEDHL_SP EQU *
         BAS   R14,CLEAR_DHB_RECORD       Clear record to blanks
         B     RAR$DHB$DSEDHL_PRT
*
RAR$DHB$DSEDHL_DD EQU *
         MVC   RAR_DHB_DREC+20(L'DSH_DCFCODE-4),DSH_DCFCODE+4-DSH(R8)
*
RAR$DHB$DSEDHL_PRT EQU *
         LA    R1,WA_FWA_REPORT           Locate File-Work-Area
         LA    R0,RAR_DHB_DREC            Locate output record
         L     R15,=V(RAA$PRT)            -> RAA$PRT CSECT
         BALR  R14,R15                    Call the print routine
         B     RAR$DHB$DSEDHLB
*
RAR$DHB$DSEDHL_DT EQU *
         TM    X_FLAG1,$XF1_RHPROC        Processed Reports Head yet?
         BO    RAR$DHB$DSEDHL_DTS         Yes, continue
         OI    X_FLAG1,$XF1_RHPROC        Turn on flag
         LA    R1,WA_FWA_REPORT           Locate File-Work-Area
         OI    FWA_FLAG1-FWA(R1),$FWA_F1NORH   No reports heading
*
         BAS   R14,CLEAR_DHB_RECORD       Clear record
         LA    R1,WA_FWA_REPORT           Locate File-Work-Area
         LA    R0,RAR_DHB_DREC            Locate output record
         L     R15,=V(RAA$PRT)            -> RAA$PRT CSECT
         BALR  R14,R15                    Call the print routine
RAR$DHB$DSEDHL_DTS EQU *
         BAS   R14,CLEAR_DHB_RECORD       Clear record
         MVC   RAR_DHB_DREC+1(19),DSH_DCFCODE+4-DSH(R8)
*
RAR$DHB$DSEDHLB EQU *
         LA    R8,DSHL(R8)                Bump to next entry
         C     R8,RAR_DCDSECTHC           At end?
         BNH   RAR$DHB$DSEDHL             No, process next one
*
         TM    X_FLAG1,$XF1_RHPROC        Processed Reports Headings?
         BNO   RAR$DHB$DSEDHLX            No, leave
         BAS   R14,CLEAR_DHB_RECORD       Clear record
         LA    R1,WA_FWA_REPORT           Locate File-Work-Area
         LA    R0,RAR_DHB_DREC            Locate output record
         L     R15,=V(RAA$PRT)            -> RAA$PRT CSECT
         BALR  R14,R15                    Call the print routine
         LA    R1,WA_FWA_REPORT           Locate File-Work-Area
         LA    R0,RAR_DHB_DREC            Locate output record
         L     R15,=V(RAA$PRT)            -> RAA$PRT CSECT
         BALR  R14,R15                    Call the print routine
*
         LA    R1,WA_FWA_REPORT           Locate File-Work-Area
         OI    FWA_FLAG1-FWA(R1),$FWA_F1PRTRH  Need Report heading...
         NI    FWA_FLAG1-FWA(R1),255-$FWA_F1NORH Need report heading...
RAR$DHB$DSEDHLX EQU *
*
         TM    X_FLAG1,$XF1_INDEX         Index file available...
         BNO   RAR$DHB$DSEIX              No, continue
         L     R15,INDEX_AREA+4
         LA    R15,INDEXA_RECOUT-INDEXA(R15) Locate output record
         BAS   R14,CR$CLEAR               Clear recout to blanks
*
         LA    R14,INDEX_NAME-INDEX(R15)  Locate name area
         MVI   0(R14),C'.'                Get dots
         MVC   1(L'INDEX_NAME-1,R14),0(R14) ..propagate it
         SLR   R14,R14                    Clear register
         ICM   R14,B'0011',RAR_DPNAMEL    Get length of DSECT name
         BNZ   RAR$DHB$DSEID              Go with it bozo
         MVC   RAR_DHB_DESCC(7),=C'Unknown'
         LA    R1,7(R1)                   Bump past it
         B     RAR$DHB$DSEIDX
RAR$DHB$DSEID EQU *
         L     R1,RAR_DPNAMEA             Get address of DSECT name
         EX    R14,RAR$DHB$DSEIDM         Move DSECT name out
RAR$DHB$DSEIDX EQU *
         L     R14,RAR_DHB_DSECTC         Save it
         CVD   R14,DOUBLE
         MVC   INDEX_NUM-INDEX(4,R15),EDITP15F
         ED    INDEX_NUM-INDEX(4,R15),DOUBLE+6
*
         LA    R15,INDEX_PAGE-INDEX(R15)  Locate output location
         LA    R14,WA_FWA_REPORT          -> Data Handbook file area
         ICM   R1,B'1111',FWA_PAGECNT-FWA(R14) Get page count
         LA    R1,1(R1)                   Always starts on next page #
         BAS   R9,EDITFWF                 Edit page count
         L     R1,INDEX_AREA+4            Locate Index Area
         LA    R0,INDEXA_RECOUT-INDEXA(R1) Locate output record
         LA    R1,INDEXA_FWA-INDEXA(R1)   Locate File-Work-Area
         L     R15,=V(RAA$PRT)            -> RAA$PRT CSECT
         BALR  R14,R15                    Call the print routine
RAR$DHB$DSEIX EQU *
         B     RAR$DHBTX
RAR$DHB$DSEDM    MVC   RAR_DHB_DESCC(0),0(R15)    ** Executed **
RAR$DHB$DSEIDM   MVC   INDEX_NAME-INDEX(0,R15),0(R1)
*
** Equate
*
RAR$DHB$EQU  EQU *
         CLI   RAR_DPOPR,0                Have a value?
         BE    RAR$DHBTX                  No, skip it
*
         LA    R14,RAR_DHB_PREC+1         Locate previous record
         CLC   DHBR_TYPE-DHBR(10,R14),T_OPRTX+(TOPRT_NAME-TOPRT)
         BNE   RAR$DHB$EQUHX              No, continue
         MVC   DHBR_TYPE-DHBR(10,R14),T_OPRTB+(TOPRT_NAME-TOPRT)
*
         MVI   DHBR_LEN+7-DHBR(R14),C'1'  Assume 1!!!!!!
RAR$DHB$EQUHX EQU *
*
         CLC   RAR_DPOPR(2),=X'5C,00'     "EQU *"?
         BE    RAR$DHBTX                  Yes, skip it
         CLC   RAR_DPOPR(2),=X'5C,60'     "EQU *-" ?
         BE    RAR$DHB$EQUE               Yes, skip Bitstr, get len
         CLC   AHSD_ADDR2-AHS(3,R5),=C'000' Value is one byte?
         BNE   RAR$DHB$EQUE               No, continue
         LA    R15,AHSD_ADDR2+3-AHS(R5)   Locate value
         LA    R0,1                       Input length / 2
         LA    R1,DOUBLE                  Locate output hex value str
         BAS   R8,HEXTRAN                 Make right
         LA    R15,RECOUT+1               Reset R15
         LA    R14,DHBR_TYPE-DHBR(R15)    Locate bit string output
         MVI   0(R14),C'.'                Get unused
         MVC   1(9-1,R14),0(R14)          ..Propagate it
         TM    DOUBLE,X'80'
         BNO   RAR$DHB$E80X
         MVI   0(R14),C'1'
RAR$DHB$E80X EQU *
         TM    DOUBLE,X'40'
         BNO   RAR$DHB$E40X
         MVI   1(R14),C'1'
RAR$DHB$E40X EQU *
         TM    DOUBLE,X'20'
         BNO   RAR$DHB$E20X
         MVI   2(R14),C'1'
RAR$DHB$E20X EQU *
         TM    DOUBLE,X'10'
         BNO   RAR$DHB$E10X
         MVI   3(R14),C'1'
RAR$DHB$E10X EQU *
         LA    R14,4(R14)
         MVI   0(R14),C' '
         LA    R14,1(R14)
         TM    DOUBLE,X'08'
         BNO   RAR$DHB$E08X
         MVI   0(R14),C'1'
RAR$DHB$E08X EQU *
         TM    DOUBLE,X'04'
         BNO   RAR$DHB$E04X
         MVI   1(R14),C'1'
RAR$DHB$E04X EQU *
         TM    DOUBLE,X'02'
         BNO   RAR$DHB$E02X
         MVI   2(R14),C'1'
RAR$DHB$E02X EQU *
         TM    DOUBLE,X'01'
         BNO   RAR$DHB$E01X
         MVI   3(R14),C'1'
RAR$DHB$E01X EQU *
         CLC   RAR_DPOPR(2),=C'B'''       Bitstrings?
         BE    RAR$DHBTX                  Yes, already got em
* Note: Put operand on DHBR_LEN which is not used for equates
         LH    R14,RAR_DPOPRL             Get length of field
         LA    R1,L'DHBR_LEN              Get max length
         CR    R14,R1                     Okay?
         BNH   RAR$DHB$EQU$EL             Yes, continue
         LR    R14,R1                     No, set truncated
RAR$DHB$EQU$EL EQU *
         EX    R14,RAR$DHB$EQUEM          Move out operand field
         B     RAR$DHBTX                  Continue
* Note: Put operand on DHBR_TYPE, it's value is more than 255
RAR$DHB$EQUE  EQU *
         LH    R14,RAR_DPOPRL             Get length of field
         LA    R1,L'DHBR_TYPE+L'DHBR_LEN  Get max length
         CR    R14,R1                     Okay?
         BNH   RAR$DHB$EQUEN              Yes, continue
         LR    R14,R1                     No, set truncated
RAR$DHB$EQUEN EQU *
         EX    R14,RAR$DHB$EQUENM         Move out operand field
*
         L     R1,RAR_DPADDR2X            Get value
         CVD   R1,DOUBLE                  Make packed
         MVC   DHBR_LEN-DHBR(8,R15),EDITP15F
         ED    DHBR_LEN-DHBR(8,R15),DOUBLE+4
         B     RAR$DHBTX
RAR$DHB$EQUEM   MVC   DHBR_LEN-DHBR(0,R15),RAR_DPOPR   ** Executed **
RAR$DHB$EQUENM  MVC   DHBR_TYPE-DHBR(0,R15),RAR_DPOPR  ** Executed **
RAR$DHBTDM      MVC   DHBR_LEN-DHBR(0,R15),RAR_DPOPR   ** Executed **
*
** Bump past numeric quanity in operand, i e "DS   5F" or "DS 10C'A'"
*
RAR$DHBT EQU   *
         LA    R14,RAR_DPOPR              Locate start
         LH    R0,RAR_DPOPRL              Get length of operand
RAR$DHBNL EQU  *
         CLI   0(R14),C'0'                Numeric/Quanity?
         BL    RAR$DHBNLX
         LA    R14,1(R14)                 Bump past number byte
         BCT   R0,RAR$DHBNL
RAR$DHBNLX EQU *
*
** Search thru table for "DC" and "DS" operations
*
         LA    R1,T_OPRT                  Locate table
         LA    R0,T_OPRTE                 Get number of entries
RAR$DHBTL EQU  *
         CLC   TOPRT_VAL-TOPRT(1,R1),0(R14)  Match?
         BE    RAR$DHBTLX                 Yes, continue
         LA    R1,TOPRTL(R1)              No, Bump to next entry
         BCT   R0,RAR$DHBTL               ..Continue
RAR$DHBTLX EQU *
         CLC   RAR_DPOPT(C_DSL),C_DS      Ensure "DS 0x"
         BNE   RAR$DHBTDX                 No, undefined
         CLI   RAR_DPOPR,C'0'             Dup?
         BNE   RAR$DHBTDX
         CLC   RAR_DPOPR+1(2),=X'C8,00'   "DS 0H"
         BE    RAR$DHBTD
         CLC   RAR_DPOPR+1(2),=X'C6,00'   "DS 0F"
         BE    RAR$DHBTD
         CLC   RAR_DPOPR+1(2),=X'C4,00'   "DS 0D"
         BE    RAR$DHBTD
         CLC   RAR_DPOPR+1(2),=X'E7,00'   "DS 0X" Rare...
         BE    RAR$DHBTD
         CLC   RAR_DPOPR+1(2),=X'C3,00'   "DS 0C" Rare...
         BNE   RAR$DHBTDX
RAR$DHBTD EQU *
         LH    R14,RAR_DPOPRL             Get length
         EX    R14,RAR$DHBTDM             Move alignment to length
         LA    R1,T_OPRTA                 Locate our entry
RAR$DHBTDX EQU *
         MVC   DHBR_TYPE-DHBR(10,R15),TOPRT_NAME-TOPRT(R1)
*
RAR$DHBTPR EQU *
         CLC   RAR_DHB_POPT(C_EQUL),C_EQU Previous one an Equate?
         BE    RAR$DHBTX                  Yes, continue
         LA    R14,RAR_DHB_PREC+1         Locate previous record
         CLC   DHBR_TYPE-DHBR(8,R14),=C'BAL STMT'  Valid guy?
         BE    RAR$DHBTX                  No, continue
         L     R1,RAR_DPLOCX              Get current location
         S     R1,RAR_DHB_PLOCX           Length = curr - Prev
         CLI   DHBR_LEN-DHBR(R14),C' '    Check for Alignment
         BNE   RAR$DHBTX                  Field is in use...
         CVD   R1,DOUBLE                  Make packed
         MVC   DHBR_LEN-DHBR(8,R14),EDITP15F
         ED    DHBR_LEN-DHBR(8,R14),DOUBLE+4
RAR$DHBTX EQU  *
*
** Print previous record and save current record
*
         BAS   R14,RAR$DHB$PPREC          Print previous record
*
         TM    PPC_FLAG1,$PPC_F1DEBUGS    Debugging short?
         BNO   RAR$DHB$PRX                No, continue
         LA    R1,WA_FWA_SYSPRINT         Locate File-Work-Area
         LA    R0,RAR_DHB_PREC            Locate output record
         L     R15,=V(RAA$PRT)            -> RAA$PRT CSECT
         BALR  R14,R15                    Call the print routine
RAR$DHB$PRX EQU *
         MVC   RAR_DHB_PREC(133),RECOUT   Save current record
         MVC   RAR_DHB_PLOCX(4),RAR_DPLOCX Save current location
         MVC   RAR_DHB_POPT(8),RAR_DPOPT   Save current operation
*
** Common exit from Data-Book-Handbook routine
*
RAR$DHBX EQU   *
         L     R14,RAR_DHB_RA             Get return address
         BSM   0,R14
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Print previous DHB record                                         **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
RAR$DHB$PPREC  EQU *
         ST    R14,RAR_DHB_PPRRA          Save return address
*
         CLI   RAR_DHB_PREC,0             Have a previous record?
         BE    RAR$DHB$PPRECX             No, continue
*
         TM    RAR_FLAG1,$RARF1_ENAME     Just got End Name
         BO    RAR$DHB$PPREC_ENAME        Yes, process previous one
*
         TM    RAR_FLAG1,$RARF1_NPROC     Processing just now?
         BO    RAR$DHB$PPRECX             No, leave
*
         TM    RAR_FLAG1,$RARF1_SNAME     Just got Start Name
         BO    RAR$DHB$PPREC_SNAME        Yes, ignore this one
*
** End_Name processing
*
         B     RAR$DHB$PPREC_ENAMEX
RAR$DHB$PPREC_ENAME EQU *
         NI    RAR_FLAG1,255-$RARF1_ENAME
RAR$DHB$PPREC_ENAMEX EQU *
*
** Document Composition Facility support
*
         TM    PPC_FLAG2,$PPC_F2DCF       DCF?
         BNO   RAR$DHB$PPREC_DCFX         No, continue
         L     R8,=V(RAA$DCF)
         LA    R7,RAR_DHB_PREC+1          Locate output record
*
         BAS   R14,CLEAR_DHB_RECORD
         MVC   RAR_DHB_DREC(L'RAA$DCF_ROW),RAA$DCF_ROW-RAA$DCF(R8)
         BAS   R14,PUT_DCF_RECORD
*
         BAS   R14,CLEAR_DHB_RECORD
         MVC   RAR_DHB_DREC(3),=C':c.'    New row
         LA    R1,L'DHBR_OFFD-1           Length of offset (Dec)
         LR    R15,R1                     Get it for loop control
         LA    R14,DHBR_OFFD-DHBR(R7)     Locate start of value
RAR$DHB$PPREC_DCFODL EQU *                Remove left justification
         CLI   0(R14),C' '                Start of string
         BNE   RAR$DHB$PPREC_DCFODLX      Yes, leave
         LA    R14,1(R14)                 No, bump to next byte
         BCTR  R1,0                           Decrement length
         BCT   R15,RAR$DHB$PPREC_DCFODL       process next byte
RAR$DHB$PPREC_DCFODLX EQU *
         EX    R1,RAR$DHB$PPREC_DCFODM
         BAS   R14,PUT_DCF_RECORD
*
         MVI   RAR_DHB_DREC+3,C' '
         MVC   RAR_DHB_DREC+4(L'DHBR_OFFD-1),RAR_DHB_DREC+3
         MVC   RAR_DHB_DREC+3(L'DHBR_OFFX),DHBR_OFFX-DHBR(R7)
         BAS   R14,PUT_DCF_RECORD
*
         MVI   RAR_DHB_DREC+3,C' '
         MVC   RAR_DHB_DREC+4(L'DHBR_OFFX-1),RAR_DHB_DREC+3
         MVC   RAR_DHB_DREC+3(L'DHBR_TYPE),DHBR_TYPE-DHBR(R7)
         BAS   R14,PUT_DCF_RECORD
*
         MVI   RAR_DHB_DREC+3,C' '
         MVC   RAR_DHB_DREC+4(L'DHBR_TYPE-1),RAR_DHB_DREC+3
         LA    R1,L'DHBR_LEN-1            Length of value
         LR    R15,R1                     Get it for loop control
         LA    R14,DHBR_LEN-DHBR(R7)      Locate start of value
RAR$DHB$PPREC_DCFLNL EQU *                Remove left justification
         CLI   0(R14),C' '                Start of string
         BNE   RAR$DHB$PPREC_DCFLNLX      Yes, leave
         LA    R14,1(R14)                 No, bump to next byte
         BCTR  R1,0                           Decrement length
         BCT   R15,RAR$DHB$PPREC_DCFLNL       process next byte
RAR$DHB$PPREC_DCFLNLX EQU *
         EX    R1,RAR$DHB$PPREC_DCFODM    Move value in
         BAS   R14,PUT_DCF_RECORD
*
         MVI   RAR_DHB_DREC+3,C' '
         MVC   RAR_DHB_DREC+4(L'DHBR_LEN-1),RAR_DHB_DREC+3
         L     R8,PPC_NAMEL
         LA    R1,8(R1)
         EX    R8,RAR$DHB$PPREC_DCFN1M
         BAS   R14,PUT_DCF_RECORD
*
         CLC   RAR_DPOPT(C_DSECTL),C_DSECT DSECT card?
         BE    RAR$DHB$PPREC_DCFIX        Yes, already have index...
         CLI   RAR_DHB_DREC+3,C' '        Have something?
         BE    RAR$DHB$PPREC_DCFIX        No, continue
         MVC   RAR_DHB_DREC+1(3),=C'i2.'
         EX    R8,RAR$DHB$PPREC_DCFN2M
         BAS   R14,PUT_DCF_RECORD
         MVC   RAR_DHB_DREC(3),=C':c.'
RAR$DHB$PPREC_DCFIX EQU *
*
         MVI   RAR_DHB_DREC+3,C' '
         MVC   RAR_DHB_DREC+4(63),RAR_DHB_DREC+3
         L     R14,RAR_DHB_DESCL          Get max length
         LA    R1,DHBR_NAME-DHBR(R7)      Locate start of name
         A     R1,PPC_NAMEL               Add length of name
         EX    R14,RAR$DHB$PPREC_DCFRM
         BAS   R14,PUT_DCF_RECORD
         B     RAR$DHB$PPRECX             Leave
*
** Executed instructions
*
RAR$DHB$PPREC_DCFN1M  MVC RAR_DHB_DREC+3(0),DHBR_NAME-DHBR(R7)
RAR$DHB$PPREC_DCFN2M  MVC RAR_DHB_DREC+4(0),DHBR_NAME-DHBR(R7)
RAR$DHB$PPREC_DCFRM   MVC RAR_DHB_DREC+3(0),3(R1)
RAR$DHB$PPREC_DCFODM  MVC RAR_DHB_DREC+3(0),0(R14)
*
RAR$DHB$PPREC_DCFX EQU *
*
** Print regular (non-DCF) output
*
         LA    R1,WA_FWA_REPORT           Locate File-Work-Area
         LA    R0,RAR_DHB_PREC            Locate output record
         L     R15,=V(RAA$PRT)            -> RAA$PRT CSECT
         BALR  R14,R15                    Call the print routine
         B     RAR$DHB$PPRECX
*
** Turn off flag for Start_Name processing
*
RAR$DHB$PPREC_SNAME EQU *
         NI    RAR_FLAG1,255-$RARF1_SNAME
*
** Return to caller
*
RAR$DHB$PPRECX EQU *
         L     R14,RAR_DHB_PPRRA          Save return address
         BSM   0,R14
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**       Source Pretty printing                                      **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
RAR$SRC  EQU   *
         ST    R14,RAR_SRC_RA
*
** We are just echoing source now...
*
         LA    R1,WA_FWA_REPORT           Locate File-Work-Area
         LA    R0,RAR_SRC_REC             Locate output record
         L     R15,=V(RAA$PRT)            -> RAA$PRT CSECT
         BALR  R14,R15                    Call the print routine
*
** Common exit from RAR$SRC processing
*
RAR$SRCX EQU   *
         L     R14,RAR_SRC_RA
         BSM   0,R14
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**       Pass 3 analysis                                             **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
RAR$PASS3 EQU  *
         ST    R14,RAR_P3_RA              Save return address
*
** Print "PASS3" in Block Letters
*
         TM    PPC_FLAG1,$PPC_F1NOLOGO    Need Logos?
         BO    RAR$P3LX                   No, continue
         L     R1,RAR_CNTIREC             Get count
         CH    R1,=H'1'                   First time
         BH    RAR$P3LX                   No, skip header
         BAS   R14,CLEAR_RECOUT           Clear recout to blanks
         MVI   RECOUT,X'8B'               FBM: Top of form
         PUT   PASS3,RECOUT               Print blank line
*
         MVI   RECOUT,X'09'               FBM byte for single space
         LA    R7,PASS3                   Locate DCB
         LA    R8,C_PASS3                 Get string
         BAS   R14,BLOCK_LETTERS          Print string
*
         BAS   R14,CLEAR_RECOUT           Clear recout to blanks
         MVI   RECOUT,X'09'               Single spaceing
         PUT   PASS3,RECOUT
         PUT   PASS3,RECOUT
         PUT   PASS3,RECOUT
         LA    R15,RECOUT+1
         MVC   0(C_PASS3NL,R15),C_PASS3N
         LA    R15,C_PASS3NL+1(R15)
         MVC   0(8,R15),5(R12)            Get "DA$ASMHA"
         PUT   PASS3,RECOUT
*
         TM    PPC_FLAG1,$PPC_F1ADDR      Address mode?
         BNO   RAR$P3LAX
         BAS   R14,CLEAR_RECOUT           Clear recout to blanks
         MVI   RECOUT,X'09'               Single spaceing
         PUT   PASS3,RECOUT
         PUT   PASS3,RECOUT
         LA    R15,RECOUT+1
         MVC   0(C_ADDRL,R15),C_ADDR
         LA    R15,C_ADDRL+1(R15)
         UNPK  0(9,R15),PPC_ADDR(5)
         MVZ   0(8,R15),=X'00,00,00,00,00,00,00,00'
         TR    0(8,R15),=C'0123456789ABCDEF'
         MVI   8(R15),C' '
         PUT   PASS3,RECOUT
RAR$P3LAX EQU *
*
         BAS   R14,CLEAR_RECOUT           Clear recout to blanks
         MVI   RECOUT,X'09'               Single spaceing
         PUT   PASS3,RECOUT
         PUT   PASS3,RECOUT
         MVI   RECOUT,X'8B'               Top of page
         PUT   PASS3,RECOUT
RAR$P3LX EQU   *
*
** Copy input record to our area
*
         BAS   R14,CLEAR_RECOUT
         MVC   RECOUT(121),0(R5)          Get record we can modify
*
** Process the data/instruction record
*
         CLI   RAR_TYPE,$RART_DATAC       Data record Comment?
         BE    RAR$P3D                    No, continue
         CLI   RAR_TYPE,$RART_DATA        Data record?
         BNE   RAR$P3DX                   No, continue
RAR$P3D  EQU   *
         TM    PPC_FLAG1,$PPC_F1RSEQNUM   Remove sequence numbers?
         BNO   RAR$P3DSNX                 No, continue
         LA    R14,RECOUT+AHSD_SEQNUM-AHS Locate sequence number
         MVI   0(R14),C' '                Get blank
         MVC   1(8-1,R14),0(R14)          ..Propagate it
RAR$P3DSNX EQU *
         TM    PPC_FLAG1,$PPC_F1ADDR      Address mode?
         BNO   RAR$P3DAX
         MVC   RECOUT+1+8+1(120),1(R5)    "x00000000x"
         CLI   RAR_DPLOCCP,0
         BE    RAR$P3DAL
         TM    RAR_FLAG1,$RARF1_ADDRE     Stopped doing addresses?
         BO    RAR$P3DAL                  Yes, continue
*
         CLC   RAR_DPOPT(C_CSECTL),C_CSECT
         BNE   RAR$P3DCX
         TM    RAR_FLAG1,$RARF1_ADDRC     First CSECT?
         BNO   RAR$P3DCS                  Yes, continue
         OI    RAR_FLAG1,$RARF1_ADDRE     Stop making sense
         B     RAR$P3DAL                  Yes, continue
RAR$P3DCS EQU  *
         OI    RAR_FLAG1,$RARF1_ADDRC
RAR$P3DCX EQU  *
*
         L     R1,PPC_ADDR
         A     R1,RAR_DPLOCX
         ST    R1,DOUBLE
         UNPK  RECOUT+1(9),DOUBLE(5)
         MVZ   RECOUT+1(8),=X'00,00,00,00,00,00,00,00'
         TR    RECOUT+1(8),=C'0123456789ABCDEF'
         MVI   RECOUT+1+8,C' '
         B     RAR$P3DAX
RAR$P3DAL EQU  *
         MVI   RECOUT+1,C' '
         MVC   RECOUT+1+1(8),RECOUT+1
         B     RAR$P3DAX
RAR$P3DAX EQU  *
*
         CLI   RAR_TYPE,$RART_DATAC       Data record Comment?
         BE    RAR$P3X                    Yes, That's all folks...
*
         CLC   RAR_DPOPT(C_STL),C_ST      ST instruction?
         BNE   RAR$P3D$STX                No, continue
         CLC   AHSD_OBJ1-AHS(2,R5),=C'50' ST instruction?
         BNE   RAR$P3D$STX                No, continue
         CLI   AHSD_OBJ1+3-AHS(R5),C'0'   Off register 0?
         BNE   RAR$P3D$STX                No, leave
         CLI   AHSD_OBJ2-AHS(R5),C'0'     Off register 0?
         BE    RAR$P3D$MLCM               Yes, Low Core Message
RAR$P3D$STX EQU *
*
         CLC   RAR_DPOPT(C_MVCL),C_MVC    MVC instruction?
         BNE   RAR$P3D$MVCX               No, continue
         CLC   AHSD_OBJ1-AHS(2,R5),=C'D2' MVC instruction?
         BNE   RAR$P3D$MVCX               No, continue
         CLI   AHSD_OBJ2-AHS(R5),C'0'     Off Register 0?
         BE    RAR$P3D$MLCM               Yes, Low Core Message
RAR$P3D$MVCX EQU *
*
         CLC   RAR_DPOPT(C_BL),C_B        Branch
         BE    RAR$P3D$BC15               Yes, perform check
         CLC   RAR_DPOPT(C_BCL),C_BC      Branch
         BNE   RAR$P3D$BC15X              No, continue
RAR$P3D$BC15  EQU *
         CLC   AHSD_OBJ1-AHS(2,R5),=C'47' BC instruction?
         BNE   RAR$P3D$BC15X              No, continue
         CLI   AHSD_OBJ2-AHS(R5),C'0'     Off Register 0?
         BE    RAR$P3D$BLCM               Yes, Low Core Message
RAR$P3D$BC15X EQU *
*
         B     RAR$P3X                    Leave
RAR$P3DX EQU   *
*
** Process the Heading record
*
         CLI   RAR_TYPE,$RART_HEADING
         BNE   RAR$P3HLX
*
         MVI   RECOUT,X'09'
         LA    R1,RECOUT                  Locate start of record
         TM    PPC_FLAG1,$PPC_F1ADDR      Address mode?
         BNO   RAR$P3HAX
         MVC   RECOUT+1+8+1(120),1(R5)
         MVC   RECOUT+1(9),=C'Address  '
         LA    R1,RECOUT+1+8              Locate past "xAddress  "
RAR$P3HAX EQU  *
*
         LA    R14,AHSH_BLANKS-AHS(R1)    Locate "(DA$ASMHA Vx.xx.x)"
         MVI   0(R14),C'('                Prefix  0....+....1....+..
         MVC   1(8,R14),5(R12)            Get "DA$ASMHA"
         MVC   10(7,R14),X'18'(R12)       Get "Vx.x.xx"
         MVI   17(R14),C')'               Suffix
         MVC   AHSH_LOC-1-AHSH(6,R1),=C'Offset'
         MVC   AHSH_OBJECT+1-AHSH(10,R1),=C'bject Code'
         MVC   AHSH_SOURCE+2-AHSH(15,R1),=C'ource Statement'
         PUT   PASS3,RECOUT               Print the record
*
         BAS   R14,CLEAR_RECOUT           Clear output record to blanks
         MVI   RECOUT,X'09'               Single space
         LA    R1,RECOUT                  Locate start of record
         TM    PPC_FLAG1,$PPC_F1ADDR      Address mode?
         BNO   RAR$P3HAUX
         MVI   RECOUT+1,C'-'
         MVC   RECOUT+2(7),RECOUT+1
         LA    R1,RECOUT+1+8              Locate past "xAddress  "
RAR$P3HAUX EQU *
         MVI   AHSH_LOC-1-AHSH(R1),C'-'
         MVC   AHSH_LOC-AHSH(5,R1),AHSH_LOC-1-AHSH(R1)
#P3OBJL  EQU   L'AHSH_OBJECT
         MVI   AHSH_OBJECT-AHSH(R1),C'-'
         MVC   AHSH_OBJECT+1-AHSH(#P3OBJL-2,R1),AHSH_OBJECT-AHSH(R1)
         MVI   AHSH_ADDR-AHSH(R1),C'-'
         MVC   AHSH_ADDR+1-AHSH(4,R1),AHSH_ADDR-AHSH(R1)
         MVI   AHSH_ADDR+6-AHSH(R1),C'-'
         MVC   AHSH_ADDR+7-AHSH(4,R1),AHSH_ADDR+6-AHSH(R1)
         MVI   AHSH_STMT-AHSH(R1),C'-'
         MVC   AHSH_STMT+1-AHSH(L'AHSH_STMT-3,R1),AHSH_STMT-AHSH(R1)
         MVI   AHSH_SOURCE-1-AHSH(R1),C'-'
         MVC   AHSH_SOURCE-AHSH(AHSH_SRCL,R1),AHSH_SOURCE-1-AHSH(R1)
RAR$P3HLX EQU  *
*
** Common Exit from PASS3 processing
*
RAR$P3X  EQU   *
         PUT   PASS3,RECOUT               Print the record
         L     R14,RAR_P3_RA              Save return address
         BSM   0,R14
*
** Format our IEV messages
*
RAR$P3D$FM EQU *
         PUT   PASS3,RECOUT               Print the record
         BAS   R14,CLEAR_RECOUT
         MVI   RECOUT,X'09'               Single space it
         LA    R15,AHSI_MSG-AHS-1(R15)
         L     R1,=V(RAA$DATA)
         MVC   0(L'MSGP3XX,R15),MSGP3XX-RAA$DATA(R1)
         LA    R15,L'MSGP3XX+2(R15)
         BSM   0,R9
*
** Possible modification of low core (R0)...
*
RAR$P3D$MLCM EQU *
         BAS   R9,RAR$P3D$FM              Format Message
         MVC   0(MSGP300L,R15),MSGP300-RAA$DATA(R1)
         B     RAR$P3X
*
** Possible Branch to low core (R0)...
*
RAR$P3D$BLCM EQU *
         BAS   R9,RAR$P3D$FM              Format Message
         MVC   0(MSGP301L,R15),MSGP301-RAA$DATA(R1)
         B     RAR$P3X
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Locate end of current field                                       **
**                                                                   **
** Input: R0 has max length                                          **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
RAR$DENDF EQU  *
*
** Full Debugging: Show current byte being processed
*
 TM    PPC_FLAG1,$PPC_F1DEBUGF
 BNO   RAR$DEF$DB1X
 ST    R0,DOUBLE
 ST    R14,DOUBLE+4
 BAS   R14,CLEAR_RECOUT           Clear record to blanks
 MVI   0(R15),C'+'
 LA    R15,2(R15)
 MVC   0(1,R15),0(R2)
 MVC   1(5,R15),=C'=Byte'
 BAS   R9,PRINT_SYSPRINT_RECORD
 L     R0,DOUBLE
 L     R14,DOUBLE+4
RAR$DEF$DB1X EQU *
*
** Double quote check
*
         TM    RAR_DPFLAG1,$RARDPF1_QUOTE Quote mode?
         BNO   RAR$DEFQX                  No, continue
         CLI   0(R2),X'7D'                Ending Quote?
         BNE   RAR$DEFB                   No, bump past it
         CLI   1(R2),X'7D'                Double quote?
         BNE   RAR$DEFQO1                 No,continue
         BCTR  R3,0                       Decrement by 1
         LA    R2,1(R2)                   Bump past first one and
         B     RAR$DEFB                   then bump past second one
RAR$DEFQO1 EQU *
*
** Full Debugging: Note that we turned quote mode off
*
 TM    PPC_FLAG1,$PPC_F1DEBUGF
 BNO   RAR$DEF$DB2X
 ST    R0,DOUBLE
 ST    R14,DOUBLE+4
 BAS   R14,CLEAR_RECOUT           Clear record to blanks
 MVI   0(R15),C'+'
 LA    R15,2(R15)
 MVC   0(27,R15),=C'Note: Quote mode turned off'
 BAS   R9,PRINT_SYSPRINT_RECORD
 L     R0,DOUBLE
 L     R14,DOUBLE+4
RAR$DEF$DB2X EQU *
         NI    RAR_DPFLAG1,255-$RARDPF1_QUOTE
         B     RAR$DEFB
RAR$DEFQX EQU *
*
** Check for starting quote
*
         CLI   0(R2),X'7D'                Single Quote?
         BNE   RAR$DEFQCX                 No, continue
         TM    RAR_DPFLAG1,$RARDPF1_OPERAND Special Operand stuff?
         BNO   RAR$DEFQC                  No, continue
         LR    R15,R2                     Get current location
         BCTR  R15,0                      Backup one
         CLI   0(R15),C'L'                Doing a "L'field"
         BE    RAR$DEFB                   Yes, skip quote proc.
RAR$DEFQC EQU *
*
** Full Debugging: Note that we turned quote mode on
*
 TM    PPC_FLAG1,$PPC_F1DEBUGF
 BNO   RAR$DEF$DB3X
 ST    R0,DOUBLE
 ST    R14,DOUBLE+4
 BAS   R14,CLEAR_RECOUT           Clear record to blanks
 MVI   0(R15),C'+'
 LA    R15,2(R15)
 MVC   0(26,R15),=C'Note: Quote mode turned on'
 BAS   R9,PRINT_SYSPRINT_RECORD
 L     R0,DOUBLE
 L     R14,DOUBLE+4
RAR$DEF$DB3X EQU *
         OI    RAR_DPFLAG1,$RARDPF1_QUOTE Turn on flag
         B     RAR$DEFB                   Continue
RAR$DEFQCX EQU *
*
** Check for end of field when not in quote mode...
*
         CLI   0(R2),C' '                 Blank?
         BE    RAR$DEFX                   Yes, leave
*
** Bump to next byte
*
RAR$DEFB EQU   *
         MVC   0(1,R4),0(R2)              Save byte
         LA    R4,1(R4)                   Bump past it
         LA    R2,1(R2)                   No, skip to next byte
         BCTR  R3,0                       Decrement total count
         LTR   R3,R3                      Hit end?
         BZ    RAR$DEFE                   Yes, error
         BCT   R0,RAR$DENDF               No, process next byte
*
** Field extends past end of source statement, it will be continued
** on next line...
*
RAR$DEFE EQU *
*
** End of processing
*
RAR$DEFX EQU *
         BSM   0,R14
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**       Bump past extra spaces until we get to next field           **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
RAR$DNEXTF EQU *
         CLI   0(R2),C' '                 Blank?
         BNE   RAR$DNEXTFX                No, found next guy...
         LA    R2,1(R2)                   Bump to next byte
         BCT   R3,RAR$DNEXTF              Process it
RAR$DNEXTFX EQU *
         BSM   0,R14
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**       Title card                                                  **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
RAR$TITLE EQU  *
         L     R14,=V(RAA$DATA)
         CLC   AHST_TITLE-AHS(C_XREFL,R5),C_XREF-RAA$DATA(R14)
         BE    RAR$TITLE$TM
         CLC   AHST_TITLE-AHS(C_DXREFL,R5),C_DXREF-RAA$DATA(R14)
         BE    RAR$TITLE$TM
         CLC   AHST_TITLE-AHS(C_RLDL,R5),C_RLD-RAA$DATA(R14)
         BNE   RAR$TITLE$TMX
RAR$TITLE$TM DS 0H
         OI    RAR_FLAG2,$RARF2_TRAILER   Turn on flag
RAR$TITLE$TMX DS 0H
         MVI   RAR_TYPE,$RART_TITLE
*  Could save title and CSECT name...
         TM    PPC_FLAG1,$PPC_F1DEBUGS    Debugging short?
         BNO   RAR$LX
         BAS   R14,CLEAR_RECOUT           Clear record to blanks
         MVC   0(23,R15),=C'# Record type detected:'
         LA    R15,24(R15)
         MVC   0(5,R15),=C'Title'
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message
         B     RAR$LX                     Read next record
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**       Heading card                                                **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
RAR$HEAD EQU   *
         MVI   RAR_TYPE,$RART_HEADING
         TM    PPC_FLAG1,$PPC_F1DEBUGS    Debugging short?
         BNO   RAR$LX
         BAS   R14,CLEAR_RECOUT           Clear record to blanks
         MVC   0(23,R15),=C'# Record type detected:'
         LA    R15,24(R15)
         MVC   0(7,R15),=C'Heading'
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message
         B     RAR$LX                     Read next record
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**       IEV message card                                            **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
RAR$IEV  EQU   *
         MVI   RAR_TYPE,$RART_IEVMSG
         BAS   R14,CLEAR_RECOUT           Clear record to blanks
         MVC   0(AHSI_MSGL,R15),AHSI_MSG-AHS(R5)
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message
         B     RAR$LX                     Read next record
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**       Reset fields                                                **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
RAR$RSETF EQU  *
         ST    R14,DOUBLE
*
         LA    R14,RAR_DPI                To: Address
         LA    R15,RAR_DPIL               To: Length
         SLR   R1,R1                      From: Set length to zero
         MVCL  R14,R0
*
         LA    R1,RAR_DPNAME
         MVI   0(R1),0
         XC    RAR_DPNAMEL(2),RAR_DPNAMEL
         ST    R1,RAR_DPNAMEA
         LA    R1,RAR_DPOPT
         MVI   0(R1),0
         ST    R1,RAR_DPOPTA
         LA    R1,RAR_DPOPR
         MVI   0(R1),0
         ST    R1,RAR_DPOPRA
         LA    R1,RAR_DPREMARK
         MVI   0(R1),C' '
         ST    R1,RAR_DPREMARKA
*
         L     R14,DOUBLE
         BSM   0,R14
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**       End of file on SYSUT1                                       **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
RAR$EOF  EQU   *
         BAS   R14,RAR$PM17               Print Message 17 if needed
*
** Close any open files
*
         LA    R3,SYSUT1
         BAS   R9,CLOSE_FILE
         EJECT
***********************************************************************
***                                                                 ***
**       Termination Section                                         **
***                                                                 ***
***********************************************************************
         SPACE 2
EXIT     EQU   *
*
** Print previous record and save current record
*
         TM    X_FLAG1,$XF1_REPORT        Doing Data HandBook?
         BNO   X$DHBX                     No, continue
         CLI   RAR_DHB_PREC,0             Have a previous record?
         BE    X$DHBX                     No, continue
         BAS   R14,RAR$DHB$PPREC          Print previous record
*
         BAS   R14,CLEAR_RECOUT           Clear record to blanks
         BAS   R9,PRINT_SYSPRINT_RECORD   Print blank line
         BAS   R9,FORMAT_MESSAGE          Format Message
         MVC   0(MSG20L,R15),MSG20-RAA$DATA(R1)
         LA    R15,MSG20L+1(R15)          Bump past it
         L     R1,RAR_DHB_DSECTC          Get DSECT count
         BAS   R9,EDITFWF                 Edit it
         MVC   0(7,R15),=C' DSECTs'
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message
*
         ICM   R1,B'0011',RAR_LOVERLT     Have a total overflow?
         BZ    X$OVERX                    No, leave
         BAS   R14,CLEAR_RECOUT           Clear record to blanks
         BAS   R9,PRINT_SYSPRINT_RECORD   Print blank line
         BAS   R9,FORMAT_MESSAGE          Format Message
         MVC   0(MSG18L,R15),MSG18-RAA$DATA(R1)
         LA    R15,MSG18L+1(R15)          Bump past it
         LH    R1,RAR_LOVERLT             Get total overflow?
         BAS   R9,EDITFWF                 Edit it
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message
X$OVERX  DS    0H
*
         TM    PPC_FLAG2,$PPC_F2DCF       DCF mode?
         BO    X$DHB$DCF
* Print dash line
         LA    R1,WA_FWA_REPORT           Locate File-Work-Area
         L     R15,=V(RAA$DATA)           Locate Data CSECT
         LA    R15,C_DASHLINE-RAA$DATA(R15) Locate dash line
         LR    R0,R15                     Locate output record
         L     R15,=V(RAA$PRT)            -> RAA$PRT CSECT
         BALR  R14,R15                    Call the print routine
         B     X$DHBX
*
X$DHB$DCF EQU  *
         BAS   R14,CLEAR_DHB_RECORD
         MVC   RAR_DHB_DREC(8),=C':etable.'
         BAS   R14,PUT_DCF_RECORD
*
         TM    PPC_FLAG2,$PPC_F2BODYONLY  DCF body only?
         BO    X$DHBX                     yes, skip end of document
*
         L     R8,=V(RAA$DCF)             -> RAA$DCF CSECT
         LA    R1,RAA$DCF_TRAILER-RAA$DCF(R8) Locate heading
         BAS   R14,PRINT_DCF_STRINGS      Print all strings
X$DHBX   EQU   *
*
** Print ending message
*
         BAS   R14,CLEAR_RECOUT           Clear record to blanks
         BAS   R9,PRINT_SYSPRINT_RECORD   Print blank line
*
         BAS   R9,FORMAT_MESSAGE          Format Message
         MVC   0(MSG4L,R15),MSG4-RAA$DATA(R1)
         LA    R15,MSG4L+1(R15)           Bump past it
         L     R1,RAR_CNTIREC             Get number of records
         BAS   R9,EDITFWF                 Edit it
         MVI   0(R15),C' '                Fix hex 0 byte
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message
*
         BAS   R14,CLEAR_RECOUT           Clear record to blanks
         BAS   R9,PRINT_SYSPRINT_RECORD   Print blank line
         BAS   R9,FORMAT_MESSAGE
         MVC   0(MSG2L,R15),MSG2-RAA$DATA(R1)
         LA    R15,MSG2L+1(R15)           Bump past it
         SLR   R1,R1                      Clear register
         IC    R1,X_MAXCC                 Get max condition code
         BAS   R9,EDITFWF                 Edit it
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message
*
         BAS   R14,CLEAR_RECOUT           Clear record to blanks
         BAS   R9,PRINT_SYSPRINT_RECORD   Print blank line
*
** Close any open files
*
         LA    R3,WA_FWA_SYSPRINT         Locate File-Work-Area
         LA    R3,FWA_DCB-FWA(R3)         Locate DCB
         BAS   R9,CLOSE_FILE              Close the file
*
         LA    R3,PASS3                   Locate DCB
         BAS   R9,CLOSE_FILE              Close the file
*
         LA    R3,WA_FWA_REPORT           Locate File-Work-Area
         LA    R3,FWA_DCB-FWA(R3)         Locate DCB
         BAS   R9,CLOSE_FILE              Close the file
*
** Release INDEX resources
*
         TM    X_FLAG1,$XF1_INDEX         Yes, turn on flag
         BNO   X$INDEXX
*
         L     R3,INDEX_AREA+4            Locate index area
         LA    R3,INDEXA_FWA-INDEXA(R3)   Locate File-Work-Area
         LA    R3,FWA_DCB-FWA(R3)         Locate DCB
         BAS   R9,CLOSE_FILE              Close the file
*
         LM    R0,R1,INDEX_AREA           Get Length and address
         FREEMAIN R,LV=(0),A=(1)          Free the storage
X$INDEXX EQU   *
*
** Delete LOADed modules
*
         TM    X_FLAG2,$XF2_DDATE         Did we load it?
         BNO   X$DA$DATEX                 No, don't need to delete it
         ICM   R0,B'1111',EP_DA$DATE
         BZ    X$DA$DATEX
         DELETE EPLOC==CL8'DA$DATE'
X$DA$DATEX EQU *
         TM    X_FLAG2,$XF2_DMXD          Did we load it?
         BNO   X$DA$MXDX                  No, don't need to delete it
         ICM   R0,B'1111',EP_DA$MXD
         BZ    X$DA$MXDX
         DELETE EPLOC==CL8'DA$MXD'
X$DA$MXDX EQU *
*
** Release any storage still left around
*
         LM    R0,R1,RAR_DCDSECTH         Save length and address
         LTR   R0,R0                      Any storage?
         BZ    X$DCDSX                    No, continue
         FREEMAIN R,LV=(0),A=(1)          Release storage
X$DCDSX  EQU   *
*
** Return to caller
*
X$LEAVE  EQU   *
         SLR   R15,R15                    Clear register
         IC    R15,X_MAXCC                Get max condition code
         DA#LEAVE RC=(15)                 Return to caller
         EJECT ,
***********************************************************************
***                                                                 ***
**       Generate some errors for PASS3 to detect                    **
***                                                                 ***
***********************************************************************
         SPACE 2
         B     14                         Branch to low core (S0C1)
         MVC   0(8),MSG1-RAA$DATA(R1)     Modify Low core (S0C4)
         ST    14,0                       Modify Low core (S0C4)
         EJECT
***********************************************************************
***                                                                 ***
**       Error routines                                              **
***                                                                 ***
***********************************************************************
         SPACE 2
*
** Routine could not be loaded
**
** Input: R8 points to 8 byte module name
*
E$LOAD   EQU   *
         BAS   R9,FORMAT_MESSAGE          Format Message
         MVC   0(MSG99L,R15),MSG99-RAA$DATA(R1)
         MVC   MSG99L(8,R15),0(R8)
         BAS   R9,PRINT_SYSPRINT_RECORD
         B     X$LEAVE
*
** Fileo open error: input: R3 - DCB
*
E$FOPEN  EQU   *
         LR    R2,R15                     SAVE RETURN CODE
*
         BAS   R9,FORMAT_MESSAGE          Format Message
         MVC   0(MSG3L,R15),MSG3-RAA$DATA(R1)
         LA    R15,MSG3L+1(R15)
         MVC   0(8,R15),DCBDDNAM-IHADCB(R3) GET DDNAME
         LA    R0,L'DCBDDNAM              MAX LENGTH OF DDNAME
         BAS   R14,LOCATE_FIRST_SPACE     LOCATE FIRST SPACE
*
         LR    R1,R2                      GET OPEN RETURN CODE
         LTR   R1,R1                      OPEN RC=0
         BZ    EFO$OX                     YES, DONT PRINT RC=0
         MVC   0(10,R15),=C', OPEN RC='   TEXT
         LA    R15,10(R15)                BUMP PAST TEXT
         BAS   R9,EDITFWF                 EDIT IT
EFO$OX   EQU   *
*
         ICM   R1,B'1111',CO_OPENC        GET OPEN ABEND CODE
         BZ    EFO$CX                     NONE, MOVE ON
         N     R1,=A(X'FFF0FF00')         TURN OFF UNNEEDED BITS
         MVC   0(9,R15),=C', ABEND S'     TEXT
         LA    R15,9(R15)                 BUMP PAST IT
         ST    R1,DOUBLE                  SAVE ABEND CODE
         UNPK  0(9,R15),DOUBLE(5)                   ---+
         MVZ   0(8,R15),=X'00,00,00,00,00,00,00,00'    | BINARY TO HEX
         TR    0(8,R15),=C'0123456789ABCDEF'        ---+
         MVI   3(R15),C'-'                MOVE IN DASH
         LA    R15,6(R15)
         MVI   0(R15),C' '
         MVI   1(R15),C' '
EFO$CX   EQU   *
         BAS   R9,PRINT_SYSPRINT_RECORD
         B     EXIT
*
** DCB ABEND exit routine: GC26-4013 MVS/XA DATA ADMINISTRATION GUIDE
**                         CHAPTER 7.
*
E$OPENA  EQU   *
         L     R2,0(R1)                   GET ABEND CODE
         ST    R2,CO_OPENC                SAVE ABEND CODE
         MVI   3(R1),4                    IGNORE ABEND
         BSM   0,R14                      RETURN TO IOS
         EJECT ,
***********************************************************************
***                                                                 ***
**  Print "Strings" from RAA$DCF CSECT to report file                **
**                                                                   **
**       Input: R1 has address of table                              **
***                                                                 ***
***********************************************************************
         SPACE 2
PRINT_DCF_STRINGS EQU *
         ST    R14,PDS_RA                 Save return address
         STM   R8,R9,PDS_REGS             Save registers
         LR    R8,R1                      Locate input string
         LA    R9,RAR_DHB_DREC            Locate output location
PDT$L    EQU   *
         BAS   R14,CLEAR_DHB_RECORD       Clear record to blanks
         SLR   R1,R1                      Clear register
         IC    R1,0(R8)                   Get length of string
         EX    R1,PDT$LM                  Move string to recout
*
         L     R15,=V(RAA$DCF)            -> DCF data CSECT
*
** Exception: stitle
*
         LA    R14,RAA$DCF_HSTITLE-RAA$DCF(R15) Locate to string
         CR    R14,R8                     At ':title stitle='
         BNE   PDT$LSTX                   No, continue
         MVI   14(R9),X'7D'               Get starting quote
         LA    R15,15(R9)                 Locate output location
         BAS   R14,PDT$TITLE              Insert Title line
         MVI   0(R15),X'7D'               Ending quote
         MVI   1(R15),C'.'                Ending dot
         B     PDT$LB                     Continue
PDT$LSTX EQU   *
*
** Exception: GDOC
*
         LA    R14,RAA$DCF_HGDOC-RAA$DCF(R15) Locate to string
         CR    R14,R8                     At ':GDOC"
         BNE   PDT$LGDX                   No, continue
         MVI   10(R9),X'7D'               Get starting quote
         LA    R15,11(R9)                 Locate output location
         BAS   R14,PDT$TITLE              Insert Title line
         L     R14,=V(RAA$DCF)            -> DCF data CSECT
         MVC   1(RAA$DCF_HDHBL-1,R15),RAA$DCF_HDHB+1-RAA$DCF(R14)
         LA    R15,1+RAA$DCF_HDHBL-1(R15) Bump past it
         MVI   0(R15),X'7D'               Ending quote
         B     PDT$LB                     Continue
PDT$LGDX EQU   *
*
** Exception: date
*
         LA    R14,RAA$DCF_HDATE-RAA$DCF(R15) Locate to string
         CR    R14,R8                     At ':date."
         BNE   PDT$LHDX                   No, continue
         MVC   6(11,R9),X_ODGEUR11_STR
         B     PDT$LB                     Continue
PDT$LHDX EQU   *
*
** Exception: title
*
         LA    R14,RAA$DCF_HTITLE-RAA$DCF(R15)
         CR    R14,R8                     Title?
         BNE   PDT$LTX                    No, continue
         LR    R15,R9                     Locate output location
         BAS   R14,PDT$TITLE              Insert Title line
         B     PDT$LB                     Continue
PDT$LTX  EQU   *
*
** Exception: frame=
*
         LA    R14,RAA$DCF_NDBOX-RAA$DCF(R15) Locate to string
         CR    R14,R8                     At "Frame="
         BNE   PDT$LBOXX                  No, continue
         TM    PPC_FLAG2,$PPC_F2NBOX      Option specified?
         BNO   PDT$LBOXX
         MVC   13(4,R9),=C'none'          Make it "frame=none"
         B     PDT$LB
PDT$LBOXX EQU  *
*
** Exception: cwidth
*
         LA    R14,RAA$DCF_HCW1-RAA$DCF(R15) Locate to string
         CR    R14,R8                     At CWIDTH?
         BE    PDT$LCW                    No, continue
         LA    R14,RAA$DCF_HCW2-RAA$DCF(R15) Locate to string
         CR    R14,R8                     At CWIDTH?
         BNE   PDT$LCWX                   No, continue
PDT$LCW  EQU   *
         CLC   PPC_NAMEL+2(2),=AL2(#PPC_NAMEL) Default or lower?
         BNH   PDT$LCWX                   Yes, leave
         MVI   27(R9),C'5'                Make name field longer
         MVI   30(R9),C'5'                Make name field longer
PDT$LCWX EQU   *
*
** Bump to past this string to next one
*
PDT$LB   EQU   *
         SLR   R1,R1                      Clear register
         IC    R1,0(R8)                   Restore length of string
         LA    R8,2(R1,R8)                Bump past string
         BAS   R14,PUT_DCF_RECORD         Print the record
         CLI   0(R8),X'FF'                End of records
         BNE   PDT$L                      No, continue
*
** Return to caller
*
         LM    R8,R9,PDS_REGS             Restore registers
         L     R14,PDS_RA                 Get return address
         BSM   0,R14                      Return to caller
*
PDT$LM   MVC   0(0,R9),1(R8)
PDT$TTM  MVC   0(0,R15),PPC_TITLE+1
*
** Move title to output line at R15
*
PDT$TITLE EQU *
         ST    R14,DOUBLE                 Save return address
         SLR   R14,R14                    Clear register
         ICM   R14,B'0001',PPC_TITLE      Get length of title
         BNZ   PDT$TM                     Have one?
         MVC   0(4,R15),=C'Misc'          Don't know what we have
         LA    R15,5(R15)                 Bump past it
         B     PDT$TMX                    Leave
PDT$TM   EQU   *
         EX    R14,PDT$TTM                Move title to output
         LA    R15,1(R14,R15)             Bump past it
PDT$TMX  EQU   *
         L     R14,DOUBLE                 Get return address
         BSM   0,R14                      Return to caller
         EJECT
***********************************************************************
***                                                                 ***
**       MISC Internal subroutines                                   **
***                                                                 ***
***********************************************************************
         SPACE 2
*
** Put DCF record to file
*
PUT_DCF_RECORD EQU *
         ST    R14,DOUBLE                 Save return address
         LA    R1,WA_FWA_REPORT           Locate File work area
*
         L     R14,FWA_PAGECNT-FWA(R1)    Get current count
         LA    R14,1(R14)
         ST    R14,FWA_PAGECNT-FWA(R1)    Get current count
*
         LA    R1,FWA_DCB-FWA(R1)         Locate DCB
         PUT   (1),RAR_DHB_DREC           Put record on file
         L     R14,DOUBLE                 Get return address
         BSM   0,R14                      Return to caller
*
** Close a file
** Input: R3 - Address of the DCB to close
*
CLOSE_FILE EQU *
         TM    DCBOFLGS-IHADCB(R3),DCBOFOPN Is it OPEN?
         BNO   CF$X                       No, ignore it
         MVC   PARMLIST(C_CLOSEL),C_CLOSE Initialize Parameter List
         CLOSE ((3)),MF=(E,PARMLIST)      Close it
CF$X     EQU   *
         BSM   0,R9                       Return to caller
*
** Format message
*
FORMAT_MESSAGE EQU *
         L     R1,=V(RAA$DATA)
         LA    R15,WA_FWA_SYSPRINT
         LA    R15,FWA_DCB-FWA(R15)
         TM    DCBOFLGS-IHADCB(R15),DCBOFOPN IS IT OPEN?
         BO    FM$RO                      YES, FORMAT NORMAL MESSAGE
         LA    R15,RECOUT                 LOCATE MESSAGE WORK AREA
         MVC   0(C_WTOL,R15),C_WTO-RAA$DATA(R1)
         LA    R15,4(R15)                 BUMP PAST WTO FLAGS
         B     FM$ROX                     MOVE PAST SYSPRINT MESSAGE
FM$RO    EQU   *
         BAS   R14,CLEAR_RECOUT           CLEAR RECOUT TO BLANKS
FM$ROX   EQU   *
         MVC   0(8,R15),5(R12)            Move in "DA$ASMHA"
         MVI   8(R15),C'-'
         LA    R15,9(R15)                 Bump past "DA$ASMHA-"
         BSM   0,R9
*
** Check open of file
**
** Input: R15 - Open Return Code
**        R3  - Address of DCB
**        CO_OPENC - ABEND code from Exit-List
*
CHECK_OPEN EQU *
         LTR   R15,R15                    CHECK OPEN RETURN CODE
         BNZ   E$FOPEN                    NOT GOOD: PRINT ERROR
         TM    DCBOFLGS-IHADCB(R3),DCBOFOPN IS IT OPEN?
         BNO   E$FOPEN                    NO, PRINT ERROR MESSAGES
         ICM   R1,B'1111',CO_OPENC        GET OPEN-ABEND CODE
         BNZ   E$FOPEN                    YES, NO ABEND CODE...
         BSM   0,R9
*
** POINT REGISTER 15 TO FIRST BLANK IN STRING
** INPUT:  R0  - MAXIMUM LENGTH OF STRING
**         R15 - STRING
** OUTPUT: R15 - FIRST SPACE IN STRING
*
LOCATE_FIRST_SPACE EQU *
         CLI   0(R15),C' '
         BE    FS$EXIT
         LA    R15,1(R15)
         BCT   R0,LOCATE_FIRST_SPACE
FS$EXIT  EQU   *
         BSM   0,R14
*
** Trim the trailing blanks from a string
** Input:  R0  - Maximum length of string
**         R15 - Last byte in string
** Output: R15 - Last non-space in string
*
LOCATE_LAST_NSPACE EQU *
         CLI   0(R15),C' '                Blank?
         BNE   LNS$X                      No, found last non-space
         BCTR  R15,0                      Backup one
         BCT   R0,LOCATE_LAST_NSPACE      Repeat
LNS$X    EQU   *
         BSM   0,R14                      Return to caller
*
** Print record on SYSPRINT
*
PRINT_SYSPRINT_RECORD EQU *
** Check for WTO processing if SYSPRINT is not open
         LA    R1,WA_FWA_SYSPRINT         Locate File-Work-Area
         LA    R14,FWA_DCB-FWA(R1)        Locate DCB
         TM    DCBOFLGS-IHADCB(R14),DCBOFOPN Open?
         BO    PSR$WTOX                   Yes, do file services
*
         SLR   R14,R14
         IC    R14,FWA_LINECNT-FWA(R1)
         LA    R14,1(R14)
         STC   R14,FWA_LINECNT-FWA(R1)
         CLI   FWA_LINECNT-FWA(R1),50
         BNH   PSR$WTOS
         LA    R1,RECOUT                  LOCATE WTO MESSAGE
         WTO   ,MF=(E,(1))                ..ISSUE IT
         BAS   R9,FORMAT_MESSAGE          Format Message
         MVC   0(MSG98L,R15),MSG98-RAA$DATA(R1)
         WTO   ,MF=(E,RECOUT)
         DC    A(0)                       Force S0C1 ABEND
PSR$WTOS EQU   *
         LA    R1,RECOUT                  LOCATE WTO MESSAGE
         WTO   ,MF=(E,(1))                ..ISSUE IT
         BSM   0,R9
PSR$WTOX EQU   *
*
         LA    R0,RECOUT                  Locate output record
         L     R15,=V(RAA$PRT)            -> RAA$PRT CSECT
         BALR  R14,R15                    Call the print routine
PSR$X    EQU   *
         BSM   0,R9                       Return to caller
*
** Open file in FWA area
**
** Input: R1 - FWA area
**        R15 - Description string address or none
**        R8 - DDNAME
*
OPEN_FILE_WORK_AREA EQU *
         ST    R14,OFWA_RA                Save return address
*
   XC    FWA_INIT-FWA(FWA_INITL,R1),FWA_INIT-FWA(R1)
         MVI   FWA_LINECNT-FWA(R1),99     Force heading
         MVC   FWA_STRTLIT-FWA(4,R1),=CL4'FWA'
         MVC   FWA_DCBLIT-FWA(4,R1),=CL4'DCB'
         MVC   FWA_ENDLIT-FWA(4,R1),=CL8'END FWA'
         MVC   FWA_DDNAME-FWA(8,R1),0(R8)
         ST    R15,FWA_DESC-FWA(R1)       Save string
         LA    R15,X_ODGEUR11             Locate date string structure
         ST    R15,FWA_DATE-FWA(R1)       Save it
         LA    R15,X_OTIMES11             Locate date string structure
         ST    R15,FWA_TIME-FWA(R1)       Save it
*
         LA    R3,FWA_DCB-FWA(R1)         Locate DCB area
         MVC   0(C_DCBOL,R3),C_DCBO       Copy in DCB constant
*
         TM    PPC_FLAG2,$PPC_F2DCF       DCF mode?
         BNO   OFWA$RX
         CLC   0(8,R8),=CL8'REPORT'       Report file?
         BNE   OFWA$RX
         NI    DCBRECFM-IHADCB(R3),255-DCBRECCA  Turn off ANSI...
OFWA$RX  EQU   *
*
         MVC   DCBDDNAM-IHADCB(8,R3),0(R8)
         LA    R15,133                    Set LRECL
         STH   R15,DCBLRECL-IHADCB(R3)    Save it
*
         LA    R15,FWA_EXLST-FWA(R1) Locate EXLST
         STCM  R15,B'0111',DCBEXLST-IHADCB+1(R3) Save it
         LA    R15,E$OPENA                Locate DCB ABEND routine
         ST    R15,FWA_EXLST-FWA(R1) PUT INTO EXLST
         OI    FWA_EXLST-FWA(R1),X'11'+X'80'
         XC    CO_OPENC(4),CO_OPENC       Clear code
*
         MVC   PARMLIST(C_LSTOL),C_LSTO   Get open Parameter List
         OPEN  ((3),(OUTPUT)),            Open the file                @
               MF=(E,PARMLIST)
*
         L     R14,OFWA_RA                Get return address
         BSM   0,R14                      Return to caller
*
**       EDIT FULLWORD (FLUSH TO R15)
**       R1 --> INPUT:REGISTER TO PRINT
**       R15 --> OUTPUT: ADDRESS WHERE OUTPUT IS TO BE PUT
*
EDITFWF  EQU   *
         LTR   R1,R1                      CHECK FOR 0
         BZ    EDITFWF0                   YES, PUT ZERO
         CVD   R1,DOUBLE                  NO, CONVERT TO PACKEC
         LA    R1,DOUBLE2+14              LOCATE SIG DIGIT
         MVC   DOUBLE2(15),EDITP15
EF$EDMK  EQU   *
         EDMK  DOUBLE2(15),DOUBLE+2       EDIT AND SAVE PLACE
         LA    R14,DOUBLE2+16             LOCATE LAST POSSIBLE BYTE + 1
         SR    R14,R1                     LENGTH = END - START
         BCTR  R14,0                      DECREMENT FOR EX
         EX    R14,EF$OM                  MOVE EDIT NUMBER TO OUTPUT
         LA    R15,0(R14,R15)             BUMP POINTER PAST NUMBER
         MVI   0(R15),C' '                Fix byte
         BSM   0,R9                       RETURN TO CALLER
EF$OM    MVC   0(0,R15),0(R1)
EDITFWF0 EQU   *
         MVI   0(R15),C'0'                PUT IN ZERO
         LA    R15,1(R15)                 BUMP POINTER PAST ZERO
         BSM   0,R9                       RETURN TO CALLER
*
**       EDIT FULLWORD (FLUSH TO R15) WITHOUT COMMAS
**       R1 --> INPUT:REGISTER TO PRINT
**       R15 --> OUTPUT: ADDRESS WHERE OUTPUT IS TO BE PUT
*
EDITNCF  EQU   *
         LTR   R1,R1                      CHECK FOR 0
         BZ    EDITNCF0                   YES, PUT ZERO
         CVD   R1,DOUBLE                  NO, CONVERT TO PACKEC
         LA    R1,DOUBLE2+7               LOCATE SIG DIGIT
         MVC   DOUBLE2(8),EDITP15F
         EDMK  DOUBLE2(8),DOUBLE+4        EDIT AND SAVE PLACE
         LA    R14,DOUBLE2+9              LOCATE LAST POSSIBLE BYTE + 1
         SR    R14,R1                     LENGTH = END - START
         BCTR  R14,0                      DECREMENT FOR EX
         EX    R14,ENCFM                  MOVE EDIT NUMBER TO OUTPUT
         LA    R15,0(R14,R15)             BUMP POINTER PAST NUMBER
         BSM   0,R9                       RETURN TO CALLER
ENCFM    MVC   0(0,R15),0(R1)
EDITNCF0 EQU   *
         MVI   0(R15),C'0'                PUT IN ZERO
         LA    R15,1(R15)                 BUMP POINTER PAST ZERO
         BSM   0,R9                       RETURN TO CALLER
*
** Clear heading record to blanks
*
CLEAR_DHB_RECORD EQU *
         LA    R15,RAR_DHB_DREC           Locate output record
         B     CR$CLEAR
CLEAR_RECOUT  EQU *
         LA    R15,RECOUT                 Locate output record
CR$CLEAR EQU   *
         MVI   0(R15),C' '                Get Blank
         MVC   1(L'RECOUT-1,R15),0(R15)  ..Propagate it
         LA    R15,1(R15)
         BSM   0,R14                      Return to caller
*
** Convert a hex string from character to binary value
** For example: From CL8'3020100E' to X'3020100E'
**
** Input: R0 - Length of output string (input / 2)
**        R1 - Output location
**        R15 - Input location
*
HEXTRAN EQU *
 STM   R3,R6,DOUBLE2                      Save registers
HT$MT EQU *
 MVI   0(R1),0                            Zero output byte
 LA    R4,1                               Offset for first hex char
 LA    R5,2                               Number of Nibbles in a byte
HT$CL EQU *
 L     R6,=V(RAA$DATA)                    -> Data CSECT
 LA    R6,T_HEX-RAA$DATA(R6)              Locate Hex table
 LA    R3,T_HEXE                          Number of entries in table
HT$C1L EQU *
 CLC   0(1,R6),0(R15)                     Match?
 BE    HT$C1LX                            Yes, move on
 LA    R6,3(R6)                           No, bump to next byte
 BCT   R3,HT$C1L                          Repeat
 B     HT$X                               Character not valid
HT$C1LX EQU *
 LA    R6,0(R4,R6)                        Bump to bitstring
 OC    0(1,R1),0(R6)                      Turn on bits for this nibble
 LA    R4,1(R4)                           Increment for next nibble
 LA    R15,1(R15)                         Bump to the next input byte
 BCT   R5,HT$CL                           Do next hex nibble in byte
 LA    R1,1(R1)                           Bump to next output byte
 BCT   R0,HT$MT                           ..do it
 SLR   R15,R15                            Clear register: success
HT$X EQU *
 LM    R3,R6,DOUBLE2                      Restore registers
 BSM   0,R8                               Return to caller
         EJECT
***********************************************************************
***                                                                 ***
**        Print Big letters via IEFSD095                             **
**                                                                   **
**        Input: R8 points to a string                               **
**               R7 points to the DCB to print on                    **
***                                                                 ***
***********************************************************************
         SPACE 2
BLOCK_LETTERS EQU *
         ICM   R15,B'1111',=V(IEFSD095)
         BZ    BL$X
         ST    R14,BL_RA                  Save return address
*
** Fix the string
*
         SLR   R1,R1                      Clear register
         IC    R1,0(R8)                   Get string length
         LA    R1,1(R1)                   Increment by 1
         XC    BL_LEN(3),BL_LEN           Fix first 3 bytes of fullword
         STC   R1,BL_LEN+3                Save length for IEFSD095
         LA    R8,1(R8)
*
** Call IEFSD095 until all lines are printed
*
         LA    R1,1
         ST    R1,BL_LINEC              GET LINE COUNTER FOR LOOP INDEX
         LA    R1,RECOUT+12+5           OUTPUT LOC (5 CENTER, 12 SLANT)
         ST    R1,BL_ADDR               Save location
BL$LP    DS    0H
         MVI   RECOUT+1,C' '
         MVC   RECOUT+2(131),RECOUT+1
*
         L     R5,BL_ADDR
         L     R15,=V(IEFSD095)           Locate routine: IEFSD095
         CALL  (15),                             Call IEFSD095         @
               ((8),BL_LINEC,(5),BL_LEN),        ..Parameters          @
               VL,MF=(E,PARMLIST)                ..Parm list/VL
         PUT   (7),RECOUT                 Print record on file=REPORT
*
         L     R1,BL_ADDR
         BCTR  R1,0                       Decrement for slant
         ST    R1,BL_ADDR
*
         L     R1,BL_LINEC
         LA    R1,1(R1)                   Increment line counter
         ST    R1,BL_LINEC
*
         CH    R1,=H'12'                  End of the line?
         BNH   BL$LP                      Nope, do next line
         L     R14,BL_RA                  Save return address
*
** Common exit from Block_Letter routine
*
BL$X     EQU   *
         BSM   0,R14
         EJECT
***********************************************************************
***                                                                 ***
**       Constants                                                   **
***                                                                 ***
***********************************************************************
         SPACE 2
EDITP15  DC    X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'
EDITP15F DC    X'40,20,20,20,20,20,20,20,20,20,20,20,20,20,20'
*
** Copy/Constants
*
C_LSTI   OPEN  (*-*,(INPUT)),MF=L
C_LSTIL  EQU   *-C_LSTI
C_LSTO   OPEN  (*-*,(OUTPUT)),MF=L
C_LSTOL  EQU   *-C_LSTO
C_CLOSE  CLOSE (*-*),MF=L
C_CLOSEL EQU   *-C_CLOSE
C_RDJFCB RDJFCB (*-*,(INPUT)),MF=L
C_RDJFCBL EQU *-C_RDJFCB
*
         PRINT NOGEN
C_DCBI   DCB   DDNAME=C_DCB,                                           @
               DSORG=PS,MACRF=GL,EODAD=*-*,RECFM=FBM
C_DCBIL  EQU   *-C_DCBI
C_DCBO   DCB   DDNAME=C_DCBO,                                          @
               DSORG=PS,MACRF=PM,RECFM=FBA
C_DCBOL  EQU   *-C_DCBO
         PRINT GEN
C_ODDOW9   DA#DATE DPE,OPREFIX=C_ODDOW9,OSTR=NO,                       @
               OSTRL=$DA#DATE_ODDOW9,OTYPE=$DA#DATE_ODDOW
C_ODGEUR11 DA#DATE DPE,OPREFIX=C_ODGEUR11,OSTR=NO,                     @
               OSTRL=$DA#DATE_ODGEUR11,OTYPE=$DA#DATE_ODGEUR
C_OTIMES11 DA#DATE DPE,OPREFIX=C_OTIMES11,OSTR=NO,                     @
               OSTRL=$DA#DATE_OTIMES11,OTYPE=$DA#DATE_OTIMES
*
** Some strings
*
C_NOTITLE   DA#STR 'Data Area Handbooks'
C_SRC       DA#STR 'Assembler Source listing for'
C_DAHANDBKD DA#STR 'Data Area Handbook for '
C_INDEX     DA#STR 'INDEX   '
C_INDEXD    DA#STR 'Index of Data Handbook DSECTs'
C_PASS3N    DC  C'Note: The following listing was processed by'
C_PASS3NL   EQU *-C_PASS3N
C_ADDR      DC  C'Note: Performing Address processing based on offset/'
            DC  C'LOC in program starting at'
C_ADDRL     EQU *-C_ADDR
C_PASS3     DA#STR 'PASS 3'
*
** Assembler checking: we put a hex zero on the end to ensure that
** "DS" does not match for "DSECT". If you know what I mean and I
** think you do...
*
C_DS     DC    C'DS',X'00'
C_DSL    EQU   *-C_DS
C_DC     DC    C'DC',X'00'
C_DCL    EQU   *-C_DC
C_EQU    DC    C'EQU',X'00'
C_EQUL   EQU   *-C_EQU
C_ORG    DC    C'ORG',X'00'
C_ORGL   EQU   *-C_ORG
C_END    DC    C'END',X'00'
C_ENDL   EQU   *-C_END
C_EJECT  DC    C'EJECT',X'00'
C_EJECTL EQU   *-C_EJECT
C_SPACE  DC    C'SPACE',X'00'
C_SPACEL EQU   *-C_SPACE
C_DSECT  DC    C'DSECT',X'00'
C_DSECTL EQU   *-C_DSECT
C_CSECT  DC    C'CSECT',X'00'
C_CSECTL EQU   *-C_CSECT
C_ST     DC    C'ST',X'00'
C_STL    EQU   *-C_ST
C_MVC    DC    C'MVC',X'00'
C_MVCL   EQU   *-C_MVC
C_B      DC    C'B',X'00'
C_BL     EQU   *-C_B
C_BC     DC    C'BC',X'00'
C_BCL    EQU   *-C_BC
*
** Operand type
*
T_OPRT   EQU   *
         DC    C'A',CL10'Address'
T_OPRTX  DC    C'X',CL10'Hex'
T_OPRTB  DC    C'B',CL10'Bitstring'
         DC    C'F',CL10'Fixed'
         DC    C'V',CL10'VCON EPA'
         DC    C'Z',CL10'Zoned'
         DC    C'P',CL10'Packed'
         DC    C'H',CL10'Binary'
         DC    C'D',CL10'DBL Word'
         DC    C'C',CL10'Character'
         DC    C'Y',CL10'Y-type adr'
T_OPRTST DC    C'0',CL10'Structure'
T_OPRTE  EQU   (*-T_OPRT)/TOPRTL
         DC    C' ',CL10'Unknown'
T_OPRTA  DC    C'0',CL10'Alignment'
*
** Literals
*
         LTORG ,
         DS    0D
         DROP  R10,R11,R12,R13
         EJECT
***********************************************************************
***                                                                 ***
**       Print routine                                               **
***                                                                 ***
***********************************************************************
         SPACE 2
RAA$PRT  DA#ENTER 'PRINT ROUTINE FOR DA$ASMHA',RSA=(1)
         USING FWA,R13                    Locate work area
         LR    R7,R0                      Get record to print
         LA    R8,FWA_DCB                 Locate DCB
*
         TM    FWA_FLAG1,$FWA_F1PRTRH     Do report headings now?
         BO    NPR$RH1                    Yes, continue
*
         CLI   0(R7),C'1'                 Heading line?
         BE    NPR$HEAD                   Yes, ignore line count check
         CLI   FWA_LINECNT,53             Heading needed?
         BNH   NPR$DETAIL                 No, continue
*
** Heading
*
NPR$HEAD EQU   *
         MVI   FWA_LINECNT,0              Reset line count
* Skip a line for online viewing ease...
         ICM   R1,B'1111',FWA_PAGECNT     Get page count
         BZ    NPR$HC1X                   Zero skip it
         PUT   (8),FWA_RT2                Print SYSPRINT record
NPR$HC1X EQU   *
*
         ICM   R15,B'1111',FWA_PGL        Get page number location
         BNZ   NPR$PG                     Yes, continue
         LA    R15,FWA_RT2                Locate title line
         MVI   0(R15),C' '                Get blank
         MVC   1(L'FWA_RT1-1,R15),0(R15) .. Propagate it
         LA    R15,FWA_RT1                Locate title line
         MVI   0(R15),C' '                Get blank
         MVC   1(L'FWA_RT1-1,R15),0(R15) .. Propagate it
         MVI   0(R15),C'1'                Top of page
         LA    R15,1(R15)
*
         CLC   FWA_DDNAME(8),=CL8'REPORT'
         BE    NPR$PNX
         MVC   0(8,R15),=CL8'DA$ASMHA'
         LA    R15,8+1(R15)
         MVC   0(2,R15),=C'--'            Insert delimiter
         LA    R15,2+1(R15)
NPR$PNX  EQU   *
*
         LA    R1,FWA_RT1                 Locate beginning
         LR    R14,R15                    Get current location
         SR    R14,R1                     Offset = end - start
         STC   R14,FWA_DESCO              Save description offset
         ICM   R14,B'1111',FWA_DESC       -> Description
         BZ    NPR$DX                     None, skip it
         SLR   R1,R1                      Clear register
         IC    R1,0(R14)                  Get length of string
         EX    R1,NPR$DM                  Move description out
*        LA    R15,2(R1,R15)              Bump past it
NPR$DX   EQU   *
*
         LA    R15,FWA_RT1+132-11-3-11-3-5-4-1
         ICM   R14,B'1111',FWA_DATE       Get date address
         BZ    NPDA#DATEX
         SLR   R1,R1
         IC    R1,DA#DATED_STRL-DA#DATED(R14)
         BCTR  R1,0
         EX    R1,NPR$DATM
         LA    R15,2(R1,R15)
         MVC   0(2,R15),=C'--'
         LA    R15,2+1(R15)
NPDA#DATEX EQU *
*
         ICM   R14,B'1111',FWA_TIME       Get date address
         BZ    NPR$TIMEX
         SLR   R1,R1
         IC    R1,DA#DATED_STRL-DA#DATED(R14)
         BCTR  R1,0
         EX    R1,NPR$TIMM
         LA    R15,2(R1,R15)
         MVC   0(2,R15),=C'--'
         LA    R15,2+1(R15)
NPR$TIMEX EQU  *
*
         MVC   0(4,R15),=C'Page'          Insert text
         LA    R15,5(R15)                 Bump past it
         ST    R15,FWA_PGL                Save output location
NPR$PG   EQU   *
         L     R1,FWA_PAGECNT             Get page count
         LA    R1,1(R1)                   Increment by 1
         ST    R1,FWA_PAGECNT             Save page count
         CVD   R1,FWA_TIME
         UNPK  0(4,R15),FWA_TIME+6(2)
         OI    3(R15),C'0'
         MVI   FWA_RT2,C' '
         MVC   FWA_RT2+1(8-1),FWA_RT2
*
         TM    FWA_FLAG1,$FWA_F1RDESC     Reset description?
         BNO   NPR$RDSSX                  No, continue
         NI    FWA_FLAG1,255-$FWA_F1RDESC Turn off flag
         LA    R15,FWA_RT1                Get title line address
         SLR   R1,R1                      Clear register
         IC    R1,FWA_DESCO               Get description offset
         AR    R15,R1                     Locate description output
         MVI   0(R15),C' '                Get spaces
         MVC   1(79,R15),0(R15)           ..Propagate it
         ICM   R14,B'1111',FWA_DESC       -> Description
         BZ    NPR$RDSSX                  None, skip it
         SLR   R1,R1                      Clear register
         IC    R1,0(R14)                  Get length of string
         EX    R1,NPR$RDSM                Move description out
NPR$RDSSX EQU *
*
         PUT   (8),FWA_RT1
         PUT   (8),FWA_RT2
*
NPR$RH1  EQU   *
         NI    FWA_FLAG1,255-$FWA_F1PRTRH Ensure that flag is off
         TM    FWA_FLAG1,$FWA_F1NORH      No report headings?
         BO    NPR$DETAIL                 Yes, skip report headings
         ICM   R3,B'1111',FWA_RH1A        Locate Heading line 1
         BZ    NPR$RH1X                   None, leave
         LR    R15,R3                     Locate FBA byte
         BAS   R14,NPR$INC_LC             Increment line count
         PUT   (8),(3)                    Print record
NPR$RH1X EQU   *
*
         ICM   R3,B'1111',FWA_RH2A        Locate Heading line 1
         BZ    NPR$RH2X                   None, leave
         LR    R15,R3                     Locate FBA byte
         BAS   R14,NPR$INC_LC             Increment line count
         PUT   (8),(3)                    Print record
NPR$RH2X EQU   *
*
         ICM   R3,B'1111',FWA_RH3A        Locate Heading line 1
         BZ    NPR$RH3X                   None, leave
         LR    R15,R3                     Locate FBA byte
         BAS   R14,NPR$INC_LC             Increment line count
         PUT   (8),(3)                    Print record
NPR$RH3X EQU   *
*
** Print detail record
*
NPR$DETAIL EQU *
         L     R1,FWA_REC                 Get record count
         LA    R1,1(R1)                   Increment by one
         ST    R1,FWA_REC                 Save record count
*
         LR    R15,R7                     Locate record
         BAS   R14,NPR$INC_LC             Increment line count
         CLI   0(R7),C'1'                 Heading being forced?
         BNE   NPR$D                      No, continue
         MVI   0(R7),C' '                 Yes, already at Top-of-Page
NPR$D    EQU   *
         PUT   (8),(7)                    Print record
*
** Common exit from RAA$PRT
*
NPR$X    EQU   *
         DA#LEAVE ,
NPR$DM   MVC   0(0,R15),1(R14)            ** Executed **
NPR$DATM MVC   0(0,R15),DA#DATED_STR-DA#DATED(R14)
NPR$TIMM MVC   0(0,R15),DA#DATED_STR-DA#DATED(R14)
NPR$RDSM MVC   0(0,R15),1(R14)            ** Executed **
*
** Increment Line count
**
** Input: R15 - Record to check
*
NPR$INC_LC EQU *
         SLR   R1,R1                      Clear register
         IC    R1,FWA_LINECNT             Obtain line count
         CLI   0(15),C'+'
         BE    NPR$ILCX
         CLI   0(15),C'-'
         BE    NPR$ILC3
         CLI   0(15),C'0'
         BE    NPR$ILC2
         B     NPR$ILC1
NPR$ILC3 EQU   *
         LA    R1,1(R1)
NPR$ILC2 EQU   *
         LA    R1,1(R1)
NPR$ILC1 EQU   *
         LA    R1,1(R1)
NPR$ILCX EQU   *
         STC   R1,FWA_LINECNT             Save line count
         BSM   0,R14                      Return to caller
*
** Literals in RAA$PRT
*
         LTORG ,
         DS    0D
         DROP  R12,R13
         EJECT
***********************************************************************
***                                                                 ***
**       Data CSECT                                                  **
***                                                                 ***
***********************************************************************
         SPACE 2
RAA$DATA CSECT ,
*
** Messages
*
MSG1     DC    C'001I Execution begins.'
MSG1L    EQU   *-MSG1
MSG2     DC    C'002I Execution complete. Maximum condition code was'
MSG2L    EQU   *-MSG2
MSG3     DC    C'003E File could not be opened:'
MSG3L    EQU   *-MSG3
MSG4     DC    C'004I Number of input Assembler records read:'
MSG4L    EQU   *-MSG4
MSG5     DC    C'005W Block letters can not be printed, IEFSD095 is '
         DC    C'not available'
MSG5L    EQU   *-MSG5
MSG6     DC    C'006W Missing verb on what appeared to be a '
         DC    C'DA$ASMHA assembler comment on record'
MSG6L    EQU   *-MSG6
MSG7     DC    C'007I Processing '
MSG7L    EQU   *-MSG7
MSG8     DC    C'008I Assembler RC='
MSG8L    EQU   *-MSG8
MSG9     DC    C'009I Control Statement:'
MSG9L    EQU   *-MSG9
MSG10    DC    C'010E Unbalanced quotes found on record'
MSG10L   EQU   *-MSG10
MSG11    DC    C'011I Processing input DSN='
MSG11L   EQU   *-MSG11
MSG12    DC    C'012E Missing required DDNAME='
MSG12L   EQU   *-MSG12
MSG13    DC    C'013E Invalid DA$ASMHA comment directive verb on '
         DC    C'record'
MSG13L   EQU   *-MSG13
MSG14    DC    C'014E Invalid or missing operand for verb='
MSG14L   EQU   *-MSG14
MSG15    DC    C'015E DSECT header table has overflowed'
MSG15L   EQU   *-MSG15
MSG16    DC    C'016W DSECT header entry ignored, no room in table '
         DC    C'on record'
MSG16L   EQU   *-MSG16
MSG17    DC    C'017W > The label area overflowed'
MSG17L   EQU   *-MSG17
MSG18    DC    C'018I The maximum label overflow length was'
MSG18L   EQU   *-MSG18
*
MSG20    DC    C'020I Data Area Handbooks were generated for'
MSG20L   EQU   *-MSG20
*
MSG98    DC    C'098E Maximum WTO records printed, '
         DC    C'S0C1 ABEND scheduled'
MSG98L   EQU   *-MSG98
MSG99    DC    C'099E Program needed for execution could not be '
         DC    C'loaded, Name='
MSG99L   EQU   *-MSG99
MSG105   DC    C'105I Parameter:'
MSG105L  EQU   *-MSG105
MSG106   DC    C'106I'
MSG106L  EQU   *-MSG106
MSG107   DC    C'107E Number of parameters in error='
MSG107L  EQU   *-MSG107
*
MSGP3XX  DC   C'IEV$P3 ** Warning **'
MSGP300  DC   C'Possible modification of low core detected'
MSGP300L EQU  *-MSGP300
MSGP301  DC   C'Possible branch to low core detected'
MSGP301L EQU  *-MSGP301
C_DASHLINE DC   C' ',132C'-'
C_ATC    ATTACH EPLOC=*-*,SF=L
C_ATCL   EQU   *-C_ATC
*
C_WTO    WTO   '                                                       @
                                                                       @
                       ',                                              @
               ROUTCDE=(11,14),MCSFLAG=HRDCPY,MF=L
C_WTOL   EQU   *-C_WTO
C_NUMBER DC    C'....+....1....+....2....+....3....+....4....+....5'
         DC    C'....+....6....+....7....+....8....+....9....+....0'
         DC    C'....+....1....+....2....+....3....+....4....+....5'
*
** Checks for trailing messages area
*
C_RLD    DC    C'                                        R'
         DC    C'ELOCATION DICTIONARY'
C_RLDL   EQU   *-C_RLD
C_XREF   DC    C'                                    C'
         DC    C'ROSS REFERENCE'
C_XREFL  EQU   *-C_XREF
C_DXREF  DC    C'                         D'
         DC    C'IAGNOSTIC CROSS REFERENCE AND ASSEMBLER SUMM'
C_DXREFL EQU   *-C_DXREF
*
** Some strings
*
C_SYSPRINT  DA#STR 'Command statements and output'
C_SYSPRINTN DC  CL8'SYSPRINT'
C_DHBN      DC  C'Note: The following report was created by'
C_DHBNL     EQU *-C_DHBN
C_DHBL1     DA#STR '  DATA'
C_DHBL2     DA#STR 'HANDBOOK'
*
** Assembler H parameters
*
         DS    0H
C_APDD   DC    AL2(C_APDDL)
C_APDDS  EQU   *                          DD entries
         DC    CL8'ASMLIN'                1
         DC    XL8'00'                    2
         DC    XL8'00'                    3
         DC    CL8'ASMLIB'                4
         DC    CL8'ASMIN'                 5
C_APIDD  DC    CL8'ASMPRINT'              6
         DC    CL8'ASMPUNCH'              7
         DC    CL8'ASMUT1'                8
         DC    XL8'00'                    9
         DC    XL8'00'                    10
         DC    XL8'00'                    11
         DC    CL8'ASMTERM'               12
C_APDDL EQU    *-C_APDDS
*
** Parse flags
**
** Note: If there is a keyword like ASM and a parameter like ASMPARM
**       you must check for the trailing " " or "," or get conflicts
*
T_PFLAGS EQU   *
  DC      AL1($PPC_F1ASM,3),CL8'ASM     ',AL2(PPC_FLAG1-WORKDS)
  DC      AL1($PPC_F1ASM,3),CL8'ASM,    ',AL2(PPC_FLAG1-WORKDS)
  DC AL1($PPC_F2BODYONLY,4),CL8'BODYO   ',AL2(PPC_FLAG2-WORKDS)
  DC AL1($PPC_F2BODYONLY,7),CL8'BODYONLY',AL2(PPC_FLAG2-WORKDS)
  DC      AL1($PPC_F2DCF,2),CL8'DCF     ',AL2(PPC_FLAG2-WORKDS)
  DC   AL1($PPC_F1DEBUGS,5),CL8'DEBUGS  ',AL2(PPC_FLAG1-WORKDS)
  DC   AL1($PPC_F1DEBUGF,5),CL8'DEBUGF  ',AL2(PPC_FLAG1-WORKDS)
  DC   AL1($PPC_F1NOLOGO,5),CL8'NOLOGO  ',AL2(PPC_FLAG1-WORKDS)
  DC  AL1($PPC_F1NOCDASH,6),CL8'NOCDASH ',AL2(PPC_FLAG1-WORKDS)
  DC     AL1($PPC_F2NBOX,3),CL8'NOBOX   ',AL2(PPC_FLAG2-WORKDS)
  DC  AL1($PPC_F1RSEQNUM,7),CL8'REMOVESQ',AL2(PPC_FLAG1-WORKDS)
  DC   AL1($PPC_F1STRIPC,5),CL8'STRIPCHG',AL2(PPC_FLAG1-WORKDS)
T_PFLAGSN EQU   (*-T_PFLAGS)/TPFL
*
** Comment directive verb table
*
T_COMDIR EQU   *
         DC    AL1(0,4),CL8'SNAME   ',AL2(RAR$DC_SNAME-DA$ASMHA)
         DC    AL1(0,4),CL8'ENAME   ',AL2(RAR$DC_ENAME-DA$ASMHA)
         DC    AL1(0,5),CL8'DSECTH  ',AL2(RAR$DC_DSECTH-DA$ASMHA)
T_COMDIRN EQU  (*-T_COMDIR)/TDCL
*
** HEX TABLE FORMAT:
**   C'0'         - CHARACTER THAT WE ARE CONVERTING
**   B'11110000'  - FIRST NIBBLE OF BYTE
**   B'00001111'  - LAST NIBBLE OF BYTE
*
T_HEX    EQU   *
         DC    C'0',B'00000000',B'00000000'
         DC    C'1',B'00010000',B'00000001'
         DC    C'2',B'00100000',B'00000010'
         DC    C'3',B'00110000',B'00000011'
         DC    C'4',B'01000000',B'00000100'
         DC    C'5',B'01010000',B'00000101'
         DC    C'6',B'01100000',B'00000110'
         DC    C'7',B'01110000',B'00000111'
         DC    C'8',B'10000000',B'00001000'
         DC    C'9',B'10010000',B'00001001'
         DC    C'A',B'10100000',B'00001010'
         DC    C'B',B'10110000',B'00001011'
         DC    C'C',B'11000000',B'00001100'
         DC    C'D',B'11010000',B'00001101'
         DC    C'E',B'11100000',B'00001110'
         DC    C'F',B'11110000',B'00001111'
T_HEXE   EQU   ((*-T_HEX)/(1+1+1))
*
** Basic Assembler Language (BAL) statements to ignore while
** printing Data Area Handbooks
*
T_BALSTMT EQU  *
          DC   8X'00'
          ORG  *-8
          DC   C'USING'
          ORG  ,
*
          DC   8X'00'
          ORG  *-8
          DC   C'CNOP'
          ORG  ,
T_BALSTMTN EQU *-T_BALSTMT
*
** End of RAA$DATA CSECT
*
 DS 0D
 EJECT ,
***********************************************************************
***                                                                 ***
**       DCF data CSECT                                              **
***                                                                 ***
***********************************************************************
         SPACE 2
RAA$DCF  CSECT ,
*
** Misc stuff for DCF
*
RAA$DCF_ROW    DC    C':row split=yes refid=element.'
*
** DCF header
*
RAA$DCF_HEADER EQU *
 DA#STR '.DF F12 TYPE(''ITC AVANT GARDE GOTHIC '' 12) '
 DA#STR '    CODEPAGE T1GI0361'
 DA#STR '.DF F7  TYPE(''ITC AVANT GARDE GOTHIC '' 7) '
 DA#STR '    CODEPAGE T1GI0361'
RAA$DCF_HGDOC DA#STR ':gdoc sec='
 DA#STR ':prolog.'
 DA#STR ':docprof ldrdots=yes'
 DA#STR '         layout=1'
 DA#STR '         justify=yes'
 DA#STR '         rhrfrule=bottom.'
RAA$DCF_HSTITLE DA#STR ':title stitle='
RAA$DCF_HTITLE  DA#STR '*'
RAA$DCF_HDHB DA#STR 'Data Area Handbooks'
 DA#STR ':etitle.'
RAA$DCF_HDATE DA#STR ':date.'
 DA#STR ':address.'
 DA#STR ':aline.<<Your Name here>>'
 DA#STR ':eaddress.'
 DA#STR ':eprolog.'
 DA#STR ':frontm.'
 DA#STR ':tipage.'
 DA#STR ':notices.'
 DA#STR 'This document was created using DA$ASMHA, Assembler Analysis'
 DA#STR 'program, Document Composition Facility and IBM Publishing'
 DA#STR 'Systems Bookmaster'
 DA#STR ':enotices.'
 DA#STR ':body.'
 DA#STR '.bf f7'
 DA#STR '.ll 7i'
 DA#STR '.pm .5i'
 DA#STR '.*'
 DA#STR '.** Define table'
 DA#STR '.*'
 DA#STR ':rdef id=header'
 DA#STR '      concat=yes'
RAA$DCF_HCW1 DA#STR '      cwidths=''2* 2* 2* 2* 2* 6*'' '
 DA#STR '      align=''r r l r l l''.'
 DA#STR ':rdef id=element'
 DA#STR '      concat=yes'
RAA$DCF_HCW2 DA#STR '      cwidths=''2* 2* 2* 2* 2* 6*'' '
 DA#STR '      align=''r r l r l l''.'
 DA#STR '.*'
 DA#STR '.** Rows for this table'
 DA#STR '.*'
 DC  X'FF'
*
** DCF trailer
*
RAA$DCF_TRAILER EQU *
 DA#STR ':backm.'
 DA#STR ':index.'
 DA#STR ':egdoc.'
 DC  X'FF'
*
** New DSECT found
*
RAA$DCF_NDSECT EQU *
 DA#STR '.*'
 DA#STR '.** Create table for new DSECT'
 DA#STR '.*'
 DA#STR ':table refid=element'
 DA#STR '       width=page'
RAA$DCF_NDBOX DA#STR '       frame=box'
 DA#STR '       split=yes.'
 DA#STR ':thd refid=header.'
 DA#STR ':c.Decimal'
 DA#STR ':c.Hex'
 DA#STR ':c.Type'
 DA#STR ':c.Length'
 DA#STR ':c.Name'
 DA#STR ':c.Description'
 DA#STR ':ethd.'
 DC  X'FF'
 DS  0D
 EJECT ,
***********************************************************************
***                                                                 ***
**              Dynamic Save Area                                    **
***                                                                 ***
***********************************************************************
                SPACE 2
WORKDS          DSECT ,
WORKRSA         DS    18F                Register Save Area
SUBRSA          DS    18F                Register Save Area for subs
R1SAVE          DS    F                  R1 at entry (parameter)
DOUBLE          DS    D                  Double word
DOUBLE2         DS    2D                 Double work (2)
PARMLIST        DS    256X               Parameter List for calls
                DS    0F                 Entry Point
EP_DA$DATE      DS    F                  ..DA$DATE
EP_DA$MXD       DS    F                  ..DA#MXD
*                                         Print_DCF_Strings
PDS_RA          DS    F                   ..Return address
PDS_REGS        DS    2F                  ..Saved registers
                DS    0F                 Parse_Parameter_Card
PPC_COL         DS    H                  ..Column in error
PPC_NUM         DS    H                  ..Number of errors
PPC_NAMEL       DS    F                  ..Name length of DHBs
PPC_ADDR        DS    F                  ..Address
PPC_FLAG1       DS    B'00000000'        ..Flag 1
$PPC_F1DEBUGF   EQU   B'11000000'          ..Debug Full?
$PPC_F1DEBUGS   EQU   B'01000000'          ..Debug Short?
$PPC_F1RSEQNUM  EQU   B'00100000'          ..Remove Sequence Numbers?
$PPC_F1STRIPC   EQU   B'00010000'          ..Ignore Change status?
$PPC_F1NOLOGO   EQU   B'00001000'          ..No logo?
$PPC_F1NOCDASH  EQU   B'00000100'          ..No leading comment dash?
$PPC_F1ADDR     EQU   B'00000010'          ..Address mode
$PPC_F1ASM      EQU   B'00000001'          ..Assemble?
PPC_FLAG2       DS    B'00000000'        ..Flag 2
$PPC_F2DCF      EQU   B'10000000'          ..Document Comp. Fac.?
$PPC_F2BODYONLY EQU   B'11000000'          ..DCF Body only?
$PPC_F2NBOX     EQU   B'00100000'          ..No box on DCF table?
PPC_CCC         DS    C'!'               ..Comment Control Character
*
PPC_ASMPARM     DS    CL120'xxPARMS'     ..Assembler parameters
PPC_TITLE       DS    CL65'xTitle...'    ..Title
                DS    0F                 OPEN_FILE_WORK_AREA
OFWA_RA         DS    F                  ..Return address
                DS    0F                 Check_Open
CO_OPENC        DS    F                  ..ABEND code from OPEN
                DS    0F                 Read_Assembler_Record
RAR_IDD         DS    CL8'SYSUT1'        ..Input DDNAME
RAR_CNTIREC     DS    F                  ..Input Record count
RAR_CNTREMARK   DS    F                  ..Remark count
RAR_CNTCOMMENT  DS    F                  ..Comment line count
RAR_CSECT       DS    CL8                ..CSECT
RAR_SNAME       DS    CL64               ..Start Label
RAR_ENAME       DS    CL64               ..End Label
                DS    0F                 ..Line Overflow
RAR_LOVER       DS    F                    ..Count
RAR_LOVERR      DS    F                    ..MSG17 Return Address
RAR_LOVERLC     DS    H                    ..Max length (Current)
RAR_LOVERLT     DS    H                    ..Max length (Total)
*
RAR_FLAG1       DS    B'00000000'        ..Flag 1
$RARF1_DSECT    EQU   B'10000000'          ..DSECT mode?
$RARF1_CSECT    EQU   B'01000000'          ..CSECT mode?
$RARF1_DATA     EQU   B'00100000'          ..Data line?
$RARF1_ADDRC    EQU   B'00010000'          ..PASS3 Address?
$RARF1_ADDRE    EQU   B'00001000'          ..PASS3 Address stopped?
$RARF1_NPROC    EQU   B'00000100'          ..Not processing now?
$RARF1_SNAME    EQU   B'00000010'          ..Just did Start Name?
$RARF1_ENAME    EQU   B'00000001'          ..Just did End Name?
RAR_FLAG2       DS    B'00000000'        ..Flag 2
$RARF2_TRAILER  EQU   B'10000000'          ..Trailer record?
*
RAR_TYPE        DS    X                  ..Type of record
$RART_DATA      EQU   1                    ..Data (instruction)
$RART_DATAC     EQU   2                    ..Data (comment)
$RART_TITLE     EQU   3                    ..Title
$RART_HEADING   EQU   4                    ..Heading
$RART_IEVMSG    EQU   5                    ..IEVxxx message
                DS    0F                 ..Data Parse
RAR_DPNAMEA     DS    F                    ..Name address
RAR_DPOPTA      DS    F                    ..Operation address
RAR_DPOPRA      DS    F                    ..Operand address
RAR_DPREMARKA   DS    F                    ..Remark address
*
RAR_DPI         EQU   *
RAR_DPNAME      DS    CL64                 ..Name
RAR_DPOPT       DS    CL64                 ..Operation
RAR_DPOPR       DS    CL256                ..Operand
RAR_DPADDR2CP   DS    CL3                  ..Address 2 (prefix)
RAR_DPADDR2C    DS    CL5                  ..Address 2
RAR_DPADDR2X    DS    XL4                  ..Address 2 (Hex value)
RAR_DPLOCCP     DS    CL2                  ..Location (character)
RAR_DPLOCC      DS    CL6                  ..Location (character)
RAR_DPLOCX      DS    XL4                  ..Location (hex value)
RAR_DPNAMEL     DS    H                    ..Name length
RAR_DPOPTL      DS    H                    ..Operation length
RAR_DPOPRL      DS    H                    ..Operand length
RAR_DPREMARKL   DS    H                    ..Remark length
*
RAR_DPFLAG1     DS    B'00000000'          ..Flag 1
$RARDPF1_CONT   EQU   B'10000000'            ..Current line cont?
$RARDPF1_PCONT  EQU   B'01000000'            ..Prev. line continued?
$RARDPF1_QUOTE  EQU   B'00100000'            ..Quote mode?
$RARDPF1_OPERAND EQU  B'00010000'            ..Operand?
RAR_DPIL        EQU   *-RAR_DPI
                DS    0F                  ..Data comment
RAR_DCDSECTH    DS    2F                    ..Area length and address
RAR_DCDSECTHC   DS    F                     ..Area current loc
RAR_DCVERB      DS    XL(L'TDC_VERB)        ..Verb
RAR_DCREGS      DS    2F                    ..Addr, Len of dir
                DS    0F                  ..Data-HandBook
RAR_DHB_DREC    DS    CL133                 ..DCF record
RAR_DHB_PREC    DS    CL133                 ..Previous Record
RAR_DHB_POPT    DS    CL8                   ..Previous Operation
                DS    0F
RAR_DHB_DESCL   DS    F                     ..Description length
RAR_DHB_PPRRA   DS    F
RAR_DHB_PLOCX   DS    F                     ..Previous location hex
RAR_DHB_DSECTC  DS    F                     ..DSECT count
RAR_DHB_RA      DS    F                     ..Return address
RAR_DHB_DESC    DS    XL(C_DAHANDBKDL)      ..Description area
RAR_DHB_DESCC   DS    CL63                  ..DSECT name
                DS    0F                  ..Source
RAR_SRC_RA      DS    F                     ..Return address
RAR_SRC_REC     DS    CL133                 ..Record
RAR_SRC_DPFLAG1 DS    X                     ..Save of RAR_DPFLAG1
*                                         ..Pass3
RAR_P3_RA       DS    F                     ..Return Address
RAR_P3PLOC      DS    CL6                   ..Return Address
*
RECOUT          DS    CL133               Output record location
                DS    CL133               Slack if we get carried away
DAHANDBK_RH1    DS    CL133               Output record location
DAHANDBK_RH2    DS    CL133               Output record location
*
INDEX_AREA      DS    2F                  Index storage area
                DS    0F                  Block Letters:
BL_LEN          DS    F                   ..Length
BL_ADDR         DS    F                   ..Address
BL_LINEC        DS    F                   ..Line Count
BL_RA           DS    F                   ..Return Address
                DS    0H                  Global Execution stuff
X_FLAG1         DS    B'00000000'         ..Flag 1
$XF1_REPORT     EQU   B'10000000'         ..REPORT file?
$XF1_PASS3      EQU   B'01000000'         ..PASS3 file?
$XF1_INDEX      EQU   B'00100000'         ..Index file?
$XF1_SRC        EQU   B'00010000'         ..Source file?
$XF1_DHB        EQU   B'00001000'         ..Data Area HandBook?
$XF1_DSECTHO    EQU   B'00000100'         ..DSECT Header table overflw?
$XF1_RHPROC     EQU   B'00000010'         ..Processed Report headings?
$XF1_NMXD       EQU   B'00000001'         ..MXD routine is not avail?
X_FLAG2         DS    B'00000000'         ..Flag 2
$XF2_DDATE      EQU   B'10000000'         ..Delete DA$DATE?
$XF2_DMXD       EQU   B'01000000'         ..Delete DA$MXD?
X_MAXCC         DS    X                   ..Maximum condition code
X_LASTCC        DS    X                   ..Last condition code
                DS    0F
X_ODGEUR11     DA#DATE DPE,OPREFIX=X_ODGEUR11,OSTR=YES,                @
               OSTRL=$DA#DATE_ODGEUR11,OTYPE=$DA#DATE_ODGEUR
X_OTIMES11     DA#DATE DPE,OPREFIX=X_OTIMES11,OSTR=YES,                @
               OSTRL=$DA#DATE_OTIMES11,OTYPE=$DA#DATE_OTIMES
*
** DCBs
*
                DS    0D
PASS3           DS    XL(C_DCBOL)
PASS3_EXLST     DS    F
SYSUT1          DS    XL(C_DCBIL)
SYSUT1_EXLST    DS    2F
SYSUT1_JFCB     DS    XL176
*
                DS    0D
WA_FWA_SYSPRINT DS    XL(FWAL)
                DS    0D
WA_FWA_REPORT   DS    XL(FWAL)
*
RAR_DPREMARK    DS    CL1024               ..Remark
                DS    0D
WORKDSL         EQU   *-WORKDS            Length of WORKDS area
         EJECT
***********************************************************************
***                                                                 ***
**       Program DSECTs and equates                                  **
***                                                                 ***
***********************************************************************
         SPACE 2
*
** Data HandBook - Report output map
*
DHBR         DSECT ,
DHBR_OFFD    DS    CL8
             DS    CL2
DHBR_OFFX    DS    C'(0000)'
             DS    CL3
DHBR_TYPE    DS    CL10
             DS    CL3
DHBR_LEN     DS    CL8'Length'
             DS    CL3
DHBR_NAMET   DS    C
DHBR_NAME    EQU   *
DHBRL        EQU   *-DHBR
*
** Index output
*
INDEX        DSECT ,
INDEX_NUM    DS    CL4
             DS    C
INDEX_NAME   DS    CL50
INDEX_PAGE   DS    CL12
             DS    0D
INDEXL       EQU   *-INDEX
*
** Index Area
*
INDEXA          DSECT ,
INDEXA_RH1      DS    CL133               Output record location
INDEXA_RH2      DS    CL133               Output record location
INDEXA_RECOUT   DS    CL133
                DS    0D
INDEXA_FWA      DS    XL(FWAL)            File work area
INDEXAL         EQU   *-INDEXA
*
** Assembler H SYSPRINT mapping
*
AHS            DSECT ,
AHS_CC         DS    X                    Printer Control Character
AHS_VAR        EQU   *
*
 ORG AHS_VAR
AHSI           EQU   *
AHSI_IEVMSGP   DS    C'   IEV'            Message ID
AHSI_MSG       EQU   *-3                  Locate "IEV'
AHSI_IEVMSGID  DS    C'000'               Message number
               DS    C' *** '
AHSI_TYPE      DS    C'ERROR'             Type: ERROR, MNOTE, etc
               DS    C' ***  '
AHSI_MSGTEXT   DS    XL(AHSI_MSGTEXTL)
AHSI_MSGTEXTL  EQU   121-(AHSI_MSGTEXT-AHS)
AHSI_MSGL      EQU   *-AHSI_MSG
AHSIL          EQU   *-AHS
 ORG ,
*
 ORG AHS_VAR
AHST           EQU   *
AHST_LABEL     DS    CL8                  Label from TITLE statement
               DS    C
AHST_TITLE     DS    CL100                Operand from TITLE statement
               DS    CL2
AHST_PAGELIT   DS    C'PAGE'              Page literal
AHST_PAGENUM   DS    C'    1'             Page Number
AHSTL          EQU   *-AHS
 ORG ,
*
 ORG AHS_VAR
AHSH           EQU   *
               DS    C'  '
AHSH_LOC       DS    C'LOC  '
               DS    C
AHSH_OBJECT    DS    C'OBJECT CODE    '
AHSH_ADDR      DS    C'ADDR1 ADDR2 '
AHSH_STMT      DS    C' STMT  '
AHSH_SOURCE    DS    C'SOURCE STATEMENT '
AHSH_BLANKS    DS    CL36
AHSH_ASMNLIT   DS    C'ASM '
AHSH_ASMNVAL   DS    C'H '
AHSH_ASMVLIT   DS    C'V '
AHSH_ASMVVAL   DS    C'02 '
AHSH_TIME      DS    C'HH.MM '
AHSH_SRCL      EQU   *-AHSH_SOURCE
AHSH_DATE      DS    C'MM/DD/YY'
AHSHL          EQU   *-AHS
 ORG ,
*
 ORG AHS_VAR
AHSD           EQU   *
AHSD_LOC       DS    CL6
               DS    C
AHSD_OBJ1      DS    CL4
               DS    C
AHSD_OBJ2      DS    CL4
               DS    C
AHSD_OBJ3      DS    CL4
               DS    C
AHSD_ADDR1     DS    CL5
               DS    C
AHSD_ADDR2     DS    CL5
               DS    C
AHSD_STMT      DS    CL5
AHSD_MACEXP    DS    C
AHSD_SOURCE    DS    CL71
AHSD_CONT      DS    CL1
AHSD_SEQNUM    DS    CL8
AHSL           EQU   *-AHS
 ORG
*
** Table - Operand Type mapping
*
TOPRT          DSECT ,
TOPRT_VAL      DS    C
TOPRT_NAME     DS    CL10
TOPRTL         EQU   *-TOPRT
*
** File Work Area
*
FWA            DSECT ,
FWA_RSA        DS    18F                  Register Save Area
FWA_STRTLIT    DS    CL4'FWA '            Literal (for debugging)
FWA_DDNAME     DS    CL8                  DDNAME (for debugging)
FWA_LENGTH     DS    F                    Length of this area
FWA_INIT       EQU   *                    Initialize area:
FWA_TIME       DS    F                    DA$DATE Time address
FWA_DATE       DS    F                    DA$DATE Date address
FWA_DESC       DS    F                    Description string address
FWA_PAGECNT    DS    F                    Page Count
FWA_RH1A       DS    F                    Heading line 1 or zero
FWA_RH2A       DS    F                    Heading line 2 or zero
FWA_RH3A       DS    F                    Heading line 2 or zero
FWA_PGL        DS    F                    Place to put page number
FWA_REC        DS    F                    Number of detail records
FWA_FLAG1      DS    B'00000000'          Flag 1
$FWA_F1BLKLINE EQU   B'10000000'          ..Last record a blank line
$FWA_F1RDESC   EQU   B'01000000'          ..Reset Description str?
$FWA_F1NORH    EQU   B'00100000'          ..No report heading?
$FWA_F1PRTRH   EQU   B'00010000'          ..Do report heading?
FWA_DESCO      DS    X                    Description offset
FWA_INITL      EQU   *-FWA_INIT           Length to initialize
FWA_LINECNT    DS    X                    Line Count on page
*
FWA_RT1        DS    CL133                Title line 1
FWA_RT2        DS    CL133                Title line 2
               DS    0F
FWA_EXLST      DS    F                    Exit list
FWA_DCBLIT     DS    C'DCB '              Exit list
FWA_DCB        DS    XL(C_DCBOL)          DCB area
FWA_ENDLIT     DS    C'FWA END '          Exit list
               DS    0D
FWAL           EQU   *-FWA
*
** Map RAR_DCDSECTH entries
*
DSH           DSECT ,
DSH_NAME      DS    CL63                  DSECT name
DSH_DCFCODE   DS    CL69                  DCF code
DSHL          EQU   *-DSH
*
** Table of comment directives mapping
*
TDC           DSECT ,
              DS    X                     Reserved (alignment)
TDC_VERBL     DS    X                     Verb length
TDC_VERB      DS    CL8'verb'             Verb
TDC_ROUTINE   DS    XL2                   Routine address
TDCL          EQU   *-TDC                 Flag value
*
** T_PFLAG mapping
*
TPF           DSECT ,
TPF_FLAG      DS    X                     Flag value
TPF_NAMEL     DS    X                     Name length
TPF_NAME      DS    CL8                   Name value
TPF_OFFSET    DS    XL2                   Offset to field in WORKDS
TPFL          EQU   *-TPF
         EJECT
***********************************************************************
***                                                                 ***
**       DSECTs                                                      **
***                                                                 ***
***********************************************************************
         SPACE 2
         PRINT NOGEN
         DCBD  DSORG=PS,DEVD=DA           Data Control Block
         IEFJFCBN LIST=YES                Job File Control Block
         DA#DATE ,                        Date routine
         DA#MXD ,                         Hex Dump routine
         END
         EJECT
***********************************************************************
***                                                                 ***
**        Linkage editor cards - ASM.PARM='BATCH,...'                **
***                                                                 ***
***********************************************************************
         SPACE 2
 PUNCH ' ENTRY   DA$ASMHA          '      Entry point
 PUNCH ' INCLUDE AOSB0(IEFSD095)   '      Subroutine: block letters
 PUNCH ' INCLUDE SYSLMOD(DA$DATE)  '      Subroutine: Date routine
 PUNCH ' INCLUDE SYSLMOD(DA$MXD)   '      Subroutine: Mini-Hex-Dump
 PUNCH ' NAME    DA$ASMHA(R)       '      Name of load module
         END ,
./ ADD NAME=DA$BRODC 0100-01266-01266-1821-01672-01672-00000-DAVE
DA$BRODC  TITLE  'SYS1.BRODCAST analysis'
***********************************************************************
***
** Name:  DA$BRODC
**
** Author = David Alcock :: dave@planetmvs.com
**
** Purpose = Report on usage of SYS1.BRODCAST
**
**           Optionally: Can put all messages for a given user to
**           a //IEBUPDTE file to be used by the LOSTMAIL exec when
**           you are reformatting SYS1.BRODCAST.  See member X$BRODC
**           for sample job to save SYS1.BRODCAST mail and member
**           Y$BRODC for LOSTMAIL rexx exec.
**
** Attributes: Reentrant, non-authorized
**
** Requirements: Assembler H or higher
**
** Non-IBM macros:
** - DA#ENTER...Entry housekeeping
** - DA#LEAVE...Exit  housekeeping
** - DA#SMODE...Change addressing modes
** - DA#EYEC....Generate module eyecatcher (invoked by DA#ENTER)
**              which generates these fields:
**              - DA$BRODC_ECNAME - "DA$BRODC"
**              - DA$BRODC_ECDATE - Date of assembly: 06-MAR-1962
**              - DA$BRODC_ECTIME - Time of assembly: 19:02
** - DA#REGS....Equate Registers (invoked by DA#ENTER)
**
* Disclaimer: This program is FREEWARE.  Use at your own risk.  It
*             is provided for your enjoyment and neither David
*             Alcock or his employer provides any warranty for it's
*             use.  I'd like to hear how it works on your system.
*
*             This software is not in the public domain but is
*             available free of charge and with source code
*             provided.  It is copyright 2001+ by David Alcock
*             All rights reserved.
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
**
** ACF2 LIDS support:
**
**   To use the ACF2 maclib, set the &ACF2 var to 1
**
**   Even if you don't have ACF2 or have access to it's sequential
**   LIDS file, you could create a variable block file with just
**   these fields:
**
**   - Standard VB RDW
**   - USERID for 8 bytes
**   - Filler for 4 bytes
**   - User's name for 20 bytes
**   - Phone number (or other info here) for at least 12 bytes
**
**   Associating a user name and phone number with a userid makes
**   the index file more usable.
**
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
**
** Sample JCL:
**
**   //JUSTDOIT EXEC PGM=DA$BRODC
**   //SYSPRINT DD SYSOUT=*
**   //MAIL     DD SYSOUT=*
**   //INDEX    DD SYSOUT=*
**   //BRODCAST DD DISP=SHR,DSN=SYS1.BRODCAST
**   //BKLIDS   DD DISP=SHR,DSN=ACF.PRI.BKLIDS  ** optional **
**   //IEBUPDTE DD SYSOUT=* -or- to a file      ** optional **
***
***********************************************************************
         SPACE 2
&DAVER   SETC  '1.4'
***********************************************************************
***
**           M o d i f i c a t i o n   H i s t o r y
**
** Person     Date        Ver Description
** ---------- ----------- --- -----------------------------------------
** DGAlcock   02-JAN-1999 1.4 Packaged for Internet distribution;
** DGAlcock   19-FEB-1994 1.3 Added optional IEBUPDTE file
**                            for writing mail to file for easy
**                            loading into a PDS; Renamed from
**                            BRODSCAN to DA$BRODC;
** DGAlcock   15-SEP-1994 1.2 Added optional BKLIDS dataset for
**                            getting programmer name from the ACF2
**                            BKLIDS file;
** DGAlcock   10-AUG-1994 1.1 Added message about top message
**                            user; Divisional/company totals;
**                            Message type Totals; Threshold on INDEX
**                            output added; Added percentages;
** DGAlcock   05-SEP-1986 1.0 Initial program written;
***
***********************************************************************
         EJECT
*
** Globals
*
         GBLB  &ACF2
         GBLC  &BCINDEX
&BCINDEX SETC  '10'
#BCINDEX EQU   10
#BKUSERS EQU   20000                        Number of BKLIDS records
&ACF2    SETB  0                            1=Use_ACF2_Macro 0=Don't
         EJECT ,
DA$BRODC DA#ENTER 'V&DAVER Utility: SYS1.BRODCAST usage reporting',    @
               RENT=YES,                    We want getmained area     @
               LV=DSAL,                     Length of getmained area   @
               BASE=(12,11)                 Base registers
         USING DSA,R13                      Addressability to work area
         EJECT ,
***********************************************************************
***                                                                 ***
**       Initialization                                              **
***                                                                 ***
***********************************************************************
         SPACE 2
         MVC   DSA_LIT1(8),DA$BRODC_ECNAME
         MVC   DSA_LIT2(8),=CL8'DSA'
         MVC   FLAG_LIT(4),=C'FLAG'       Set for dumps
*
** Obtain storage for division/company tables and initialize them
*
         LA    R6,256                     Number of possible characters
         MH    R6,=H'4'                   Each entry in table
         LA    R6,8(R6)                   Add length of eyecatcher
         LR    R0,R6                      Save length of table
         GETMAIN RU,LV=(0)                Obtain storage
         STM   R0,R1,X_CUSERS             Save length and address
         LR    R14,R1                     To: Address
         LR    R15,R6                     To: Length
         SLR   R1,R1                      From: Set length and pad
         MVCL  R14,R0                     Zero out table area
         L     R1,X_CUSERS+4              Get address of table
         MVC   0(8,R1),=CL8'CO-USERS'     Eyecatcher for dump reading
*
         LR    R0,R6                      Get length
         GETMAIN RU,LV=(0)                Obtain storage
         STM   R0,R1,X_CMSGS              Save length and address
         LR    R14,R1                     To: Address
         LR    R15,R6                     To: Length
         SLR   R1,R1                      From: Set length and pad
         MVCL  R14,R0                     Zero out table area
         L     R1,X_CMSGS+4               Get address of table
         MVC   0(8,R1),=CL8'CO-MSGS'      Eyecatcher for dump reading
         EJECT
***********************************************************************
***                                                                 ***
**       Open files                                                  **
***                                                                 ***
***********************************************************************
         SPACE 2
*
** Open SYSPRINT file
*
         LA    R3,SYSPRINT                LOCATE WRKFILE1 DCB WORK AREA
         MVC   0(C_DCBOL,R3),C_DCBO       COPY IN DCB CONSTANT
         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'SYSPRINT'
*
         LA    R15,SYSPRINT_EXLST         LOCATE OUR EXLST
         STCM  R15,B'0111',DCBEXLST-IHADCB+1(R3) SAVE INTO DCB
         LA    R1,E$OPENA                 LOCATE OUR DCB ABEND ROUTINE
         ST    R1,SYSPRINT_EXLST          PUT INTO EXLST
         OI    SYSPRINT_EXLST,X'11'       <- DCB EXIT
         OI    SYSPRINT_EXLST,X'80'       <- END OF LIST
         XC    CO_CODE(4),CO_CODE         CLEAR OPEN-ABEND CODE
*
         LA    R1,133                     LRECL=133
         STH   R1,DCBLRECL-IHADCB(R3)     SAVE LRECL
         MVC   PARMLIST(C_LSTOL),C_LSTO   COPY IN OPEN PARM LIST
         OPEN  ((3),(OUTPUT)),                                         @
               MF=(E,PARMLIST)            OPEN WRKFILE1 DCB
         BAS   R9,CHECK_OPEN              CHECK OPEN
*
         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX
         MVC   0(MSG1L,R15),MSG1
         LA    R15,MSG1L+1(R15)
         MVC   0(7,R15),=C'started'
         LA    R15,8(R15)
         MVC   0(MSG1ASML,R15),MSG1ASM
         LA    R15,MSG1ASML+1(R15)
         MVC   0(L'DA$BRODC_ECDATE,R15),DA$BRODC_ECDATE
         LA    R15,L'DA$BRODC_ECDATE+1(R15)
         MVC   0(L'DA$BRODC_ECTIME,R15),DA$BRODC_ECTIME
         BAS   R9,PRINT_SYSPRINT_RECORD
         BAS   R14,CLEAR_RECOUT           CLEAR RECOUT TO BLANKS
         BAS   R9,PRINT_SYSPRINT_RECORD
*
         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX
         MVC   0(MSG3L,R15),MSG3
         BAS   R9,PRINT_SYSPRINT_RECORD
*
** Open mail file for actual mail data
*
         LA    R3,MAIL                    LOCATE WRKFILE1 DCB WORK AREA
         MVC   0(C_DCBOL,R3),C_DCBO       COPY IN DCB CONSTANT
         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'MAIL'
*
         LA    R15,MAIL_EXLST             LOCATE OUR EXLST
         STCM  R15,B'0111',DCBEXLST-IHADCB+1(R3) SAVE INTO DCB
         LA    R1,E$OPENA                 LOCATE OUR DCB ABEND ROUTINE
         ST    R1,MAIL_EXLST              PUT INTO EXLST
         OI    MAIL_EXLST,X'11'           <- DCB EXIT
         OI    MAIL_EXLST,X'80'           <- END OF LIST
         XC    CO_CODE(4),CO_CODE         CLEAR OPEN-ABEND CODE
*
         LA    R1,133                     LRECL=133
         STH   R1,DCBLRECL-IHADCB(R3)     SAVE LRECL
         MVC   PARMLIST(C_LSTOL),C_LSTO   COPY IN OPEN PARM LIST
         OPEN  ((3),(OUTPUT)),                                         @
               MF=(E,PARMLIST)            OPEN WRKFILE1 DCB
         BAS   R9,CHECK_OPEN              CHECK OPEN
*
** Open index file
*
         LA    R3,INDEX                   LOCATE WRKFILE1 DCB WORK AREA
         MVC   0(C_DCBOL,R3),C_DCBO       COPY IN DCB CONSTANT
         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'INDEX'
*
         LA    R15,INDEX_EXLST            LOCATE OUR EXLST
         STCM  R15,B'0111',DCBEXLST-IHADCB+1(R3) SAVE INTO DCB
         LA    R1,E$OPENA                 LOCATE OUR DCB ABEND ROUTINE
         ST    R1,INDEX_EXLST             PUT INTO EXLST
         OI    INDEX_EXLST,X'11'          <- DCB EXIT
         OI    INDEX_EXLST,X'80'          <- END OF LIST
         XC    CO_CODE(4),CO_CODE         CLEAR OPEN-ABEND CODE
*
         LA    R1,133                     LRECL=133
         STH   R1,DCBLRECL-IHADCB(R3)     SAVE LRECL
         MVC   PARMLIST(C_LSTOL),C_LSTO   COPY IN OPEN PARM LIST
         OPEN  ((3),(OUTPUT)),                                         @
               MF=(E,PARMLIST)            OPEN WRKFILE1 DCB
         BAS   R9,CHECK_OPEN              CHECK OPEN
*
** Open input file
*
         MVC   BRODCAST_DECB(C_DECBL),C_DECB Initialize DECB
*
         LA    R3,BRODCAST                Locate DCB
         MVC   0(C_DCBFIL,R3),C_DCBFI     COPY IN DCB CONSTANT
         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'BRODCAST'
*
         LA    R15,BRODCAST_EXLST         LOCATE OUR EXLST
         STCM  R15,B'0111',DCBEXLST-IHADCB+1(R3) SAVE INTO DCB
         LA    R1,E$OPENA                 LOCATE OUR DCB ABEND ROUTINE
         ST    R1,BRODCAST_EXLST          PUT INTO EXLST
         OI    BRODCAST_EXLST,X'11'       <- DCB EXIT
         OI    BRODCAST_EXLST,X'80'       <- END OF LIST
         XC    CO_CODE(4),CO_CODE         CLEAR OPEN-ABEND CODE
*
         LA    R1,E$OPENS                 LOCATE SYNAD ERROR
         STCM  R1,B'0111',DCBSYNAD-IHADCB+1(R3) INSERT INTO DCB
*
         MVC   PARMLIST(C_LSTIL),C_LSTI   COPY IN OPEN PARM LIST
         OPEN  ((3),(INPUT)),                                          @
               MF=(E,PARMLIST)            OPEN WRKFILE1 DCB
         BAS   R9,CHECK_OPEN              CHECK OPEN
         EJECT
***********************************************************************
***                                                                 ***
**       Open optional IEBUPDTE file                                 **
***                                                                 ***
***********************************************************************
         SPACE 2
OPEN_IEBUPDTE_FILE EQU *
*
** Is the file allocated in the JCL?
*
         DEVTYPE =CL8'IEBUPDTE',DOUBLE
         LTR   R15,R15
         BNZ   OIF$X
*
** Open the file for output
*
         LA    R3,IEBUPDTE                LOCATE WRKFILE1 DCB WORK AREA
         MVC   0(C_DCBOL,R3),C_DCBO       COPY IN DCB CONSTANT
         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'IEBUPDTE'
*
         LA    R15,IEBUPDTE_EXLST         LOCATE OUR EXLST
         STCM  R15,B'0111',DCBEXLST-IHADCB+1(R3) SAVE INTO DCB
         LA    R1,E$OPENA                 LOCATE OUR DCB ABEND ROUTINE
         ST    R1,IEBUPDTE_EXLST          PUT INTO EXLST
         OI    IEBUPDTE_EXLST,X'11'       <- DCB EXIT
         OI    IEBUPDTE_EXLST,X'80'       <- END OF LIST
         XC    CO_CODE(4),CO_CODE         CLEAR OPEN-ABEND CODE
*
         LA    R1,80                      LRECL=80
         STH   R1,DCBLRECL-IHADCB(R3)     SAVE LRECL
         MVC   PARMLIST(C_LSTOL),C_LSTO   COPY IN OPEN PARM LIST
         OPEN  ((3),(OUTPUT)),                                         @
               MF=(E,PARMLIST)            OPEN WRKFILE1 DCB
         BAS   R9,CHECK_OPEN              CHECK OPEN
         OI    FLAG1,$F1_IEBUPDTE         Turn on flag
*
         BAS   R9,FORMAT_MESSAGE          Format message
         MVC   0(MSG13L,R15),MSG13        Move in message text
         BAS   R9,PRINT_SYSPRINT_RECORD   Print record
*
** Common exit from Open_IEBUPDTE_file
*
OIF$X    EQU   *
         EJECT
***********************************************************************
***                                                                 ***
**       Open optional ACF2 BKLIDS file                              **
***                                                                 ***
***********************************************************************
         SPACE 2
READ_BKLIDS_FILE EQU *
*
** Is the file allocated in the JCL?
*
         DEVTYPE =CL8'BKLIDS',DOUBLE
         LTR   R15,R15
         BNZ   RBF$X
*
** open the file for input
*
         LA    R3,BKLIDS                  LOCATE WRKFILE1 DCB WORK AREA
         MVC   0(C_DCBIL,R3),C_DCBI       COPY IN DCB CONSTANT
         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'BKLIDS'
*
         LA    R15,BKLIDS_EXLST           LOCATE OUR EXLST
         STCM  R15,B'0111',DCBEXLST-IHADCB+1(R3) SAVE INTO DCB
         LA    R1,E$OPENA                 LOCATE OUR DCB ABEND ROUTINE
         ST    R1,BKLIDS_EXLST            PUT INTO EXLST
         OI    SYSPRINT_EXLST,X'11'       <- DCB EXIT
         OI    SYSPRINT_EXLST,X'80'       <- END OF LIST
         XC    CO_CODE(4),CO_CODE         CLEAR OPEN-ABEND CODE
*
         LA    R2,RBF$EOF                 Locate End-of-File
         STCM  R2,B'0111',DCBEODAD-IHADCB+1(R3) Insert into DCB
*
         MVC   PARMLIST(C_LSTIL),C_LSTI   COPY IN OPEN PARM LIST
         OPEN  ((3),(INPUT)),                                          @
               MF=(E,PARMLIST)            OPEN WRKFILE1 DCB
         BAS   R9,CHECK_OPEN              CHECK OPEN
*
         L     R1,C_BKUSRC                Get number to read in
         MH    R1,=AL2(BKLEL)             Get number to read in
         LA    R1,BKLHL(R1)               Add for header
         LR    R0,R1
         GETMAIN RU,LV=(0),LOC=(ANY,ANY)  Obtain storage
         STM   R0,R1,RBF_VS               Save length and address
         LR    R8,R1                      Get start of table
         DA#SMODE 31                      Get into 31 bit mode
         MVC   BKLH_ID-BKLH(8,R8),=CL8'BKLIDST'
         LA    R8,BKLHL(R8)               Start of entries
         L     R9,C_BKUSRC                Set number of users
         SLR   R6,R6                      Get number used
*
** Read records
*
RBF$RR   EQU   *
         DA#SMODE 24                      Get into 24 bit mode
         GET   BKLIDS
         LR    R7,R1                      Save address
         DA#SMODE 31                      Get into 31 bit mode
         MVC   BKLE_USER-BKLE(L'LIDLID,R8),LIDLID-LIDREC+4(R7)
         MVC   BKLE_NAME-BKLE(L'LIDNAME,R8),LIDNAME-LIDREC+4(R7)
         MVC   BKLE_PHONE-BKLE(L'LIDPHONE,R8),LIDPHONE-LIDREC+4(R7)
         LA    R6,1(R6)                   Increment count
         LA    R8,BKLEL(R8)
         BCT   R9,RBF$RR
*
         DA#SMODE 24                      Get into 24 bit mode
         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX
         MVC   0(MSG12L,R15),MSG12
         LA    R15,MSG12L+1(R15)
         L     R1,C_BKUSRC
         BAS   R9,EDITFWF
         MVC   1(9,R15),=C'were used'
         BAS   R9,PRINT_SYSPRINT_RECORD
         SLR   R9,R9                      Number unused is zero
*
** End of file on BKLids file
*
RBF$EOF  EQU   *
         ST    R6,RBF_USERC               Get number users
*
         LA    R3,BKLIDS                  Locate DCB
         BAS   R9,CLOSE_FILE              Close file
*
** Exit from Read_BKLids_File processing
*
RBF$X    EQU   *
         EJECT
***********************************************************************
***                                                                 ***
**       Process header                                              **
***                                                                 ***
***********************************************************************
         SPACE 2
*
** Read header record
*
         BAS   R9,READ_RECORD
         MVC   UI_RRUI(3),BDS_HDR_RRUI-BDS_HDR(R2) SAVE ADDR OF USERIDS
         MVC   BM_RRN(3),BDS_HDR_RRN-BDS_HDR(R2)   SAVE ADDR OF BROD
         L     R1,BDS_HDR_TBLKS-BDS_HDR(R2) GET NUMBER OF BLOCKS
         ST    R1,X_TRECS                 Save count
*
** Print header eyecatcher
*
         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX
         MVC   0(MSG10L,R15),MSG10        GET MESSAGE
         LA    R15,MSG10L(R15)            BUMP PAST MESSAGE
         MVC   0(L'BDS_HDR_EYEC,R15),BDS_HDR_EYEC-BDS_HDR(R2)
         BAS   R9,PRINT_SYSPRINT_RECORD   PRINT MESSAGE
         EJECT
***********************************************************************
***                                                                 ***
**       Process BRODCAST messages (if any)                          **
***                                                                 ***
***********************************************************************
         SPACE 2
BRODCAST_MESSAGES EQU *
BM$L     EQU   *
         MVC   BRODCAST_BLKN(3),BM_RRN    GET NOTICE RELATIVE RECORD
         BAS   R9,READ_RECORD             READ RECORD
*
         LA    R14,BRODCAST_DECB          LOCATE DECB
         L     R1,DECKYADR-DECB(R14)      -> KEY ADDRESS
         CLI   0(R1),X'00'                KEY = USERID INDEX?
         BNE   BM$LX                      NO, LEAVE
*
** LOOP THROUGH NOTICES FOR THE NOTICE DIRECTORY RECORD
*
         MVC   BM_REC(129),0(R2)          SAVE NOTICE DIRECTORY RECORD
         LA    R8,BM_REC                  POSITION TO BEGINNING OF REC
BM$NL    EQU   *
         CLI   0(R8),X'7F'                END OF THE RECORD
         BE    BM$NLX                     YES, LEAVE
*
         CLI   BDS_BM_NUM-BDS_BM(R8),X'80' IS BRODCAST MESSAGE IN USE?
         BNL   BM$NLB                     NO, MOVE ON
*
         MVC   BRODCAST_BLKN(3),BDS_BM_RR-BDS_BM(R8)
         BAS   R9,READ_RECORD             READ RECORD
*
         BAS   R14,CLEAR_RECOUT           CLEAR RECOUT TO BLANKS
         LA    R15,RECOUT+1               LOCATE RECOUT
         MVC   0(5,R15),=C'*BC*-'         BRODCAST MESSAGE
         LA    R15,5(R15)                 BUMP PAST IT
         SLR   R1,R1                      CLEAR REGISTER
         ICM   R1,B'0011',BDS_BM_NUM-BDS_BM(R8) GET THE BRODCAST NUMBER
         BAS   R9,EDITFWF                 EDIT IT
*
         MVC   RECOUT+9(125),1(R2)        MOVE MESSAGE TO PRINT LINE
*        OC    RECOUT+9(125),=CL125' '    MAKE UPPERCASE
*
         BAS   R9,PRINT_MAIL_RECORD       PRINT LINE
BM$NLB   EQU   *
         LA    R8,BDS_BM_LEN(R8)          BUMP TO NEXT ENTRY
         B     BM$NL                      NO, PROCESS NEXT ENTRY
BM$NLX   EQU   *
*
** BUMP TO NEXT MESSAGE
*
         SLR   R1,R1                      CLEAR REGISTER
         ICM   R1,B'0111',BM_RRN          GET RELATIVE RECORD NUMBER
         LA    R1,1(R1)                   INCREMENT BY 1
         STCM  R1,B'0111',BM_RRN          SAVE FOR LATER
         B     BM$L                       DO NEXT NOTICE RECORD
*
** COMMON EXIT FROM BRODCAST MESSAGES PROCESSING
*
BM$LX    EQU   *
         EJECT
***********************************************************************
***                                                                 ***
**       Process USERID chains (index)                               **
***                                                                 ***
***********************************************************************
         SPACE 2
UI$LOOP  EQU   *
*
** READ RECORD
*
         MVC   BRODCAST_BLKN(3),UI_RRUI
         BAS   R9,READ_RECORD
*
** CHECK TYPE
*
         LA    R14,BRODCAST_DECB          LOCATE DECB
         L     R1,DECKYADR-DECB(R14)      -> KEY ADDRESS
         CLI   0(R1),X'01'                KEY = USERID INDEX?
         BNE   UI$X                       NO, LEAVE
*
** PRINT USERIDS
*
         MVC   UI_REC(129),0(R2)          SAVE RECORD FOR PROCESSING
         LA    R7,UI_REC                  LOCATE RECORD
         LA    R8,9                       NUMBER OF USERIDS ON RECORD
UI$PUL   EQU   *
         CLC   BDS_UID_NAME-BDS_UID(7,R7),=X'00,00,00,00,00,00,00'
         BE    UI$PUB
         BAS   R9,PRINT_USER_RECORDS      PRINT USERID RECORDS
UI$PUB   EQU   *
         LA    R7,BDS_UID_LEN(R7)
         BCT   R8,UI$PUL
*
** ADVANCE TO NEXT USERID RECORD
*
         SLR   R1,R1
         ICM   R1,B'0111',UI_RRUI         GET ADDRESS OF FIRST RECORD
         LA    R1,1(R1)                   ITS RELATIVE TO ZERO
         STCM  R1,B'0111',UI_RRUI         SAVE FOR READ_RECORD
         B     UI$LOOP
*
** USERID LOOP EXIT
*
UI$X     EQU   *
         EJECT
***********************************************************************
***                                                                 ***
**       REPORT ON DATASET COMPOSITION                               **
***                                                                 ***
***********************************************************************
         SPACE 2
REPORT_DATASET_COMPOSITION EQU *
         MVC   RDC_T(C_RTABL),C_RTAB      INITIALIZE TABLE
         L     R8,X_TRECS                 Get total records in file
         BCTR  R8,0                       SKIP FIRST RECORD
         LA    R7,1                       START ON FIRST RECORD
RDC$L    EQU   *
         STCM  R7,B'0111',BRODCAST_BLKN   SAVE BLOCK NUMBER
         BAS   R9,READ_RECORD             READ RECORD
         LA    R14,BRODCAST_DECB          LOCATE DECB
         L     R1,DECKYADR-DECB(R14)      -> KEY ADDRESS
         LA    R0,C_RTABN                 NUMBER OF ENTRIES IN TABLE
         LA    R14,RDC_T                  LOCATE TABLE
RDC$TL   EQU   *
         CLC   0(1,R1),RTAB_TYPE-RTAB(R14) TEST TYPE
         BE    RDC$TLX                    FOUND, UPDATE COUNT
         LA    R14,RTABL(R14)             BUMP TO NEXT ENTRY
         BCT   R0,RDC$TL                  TRY IT OUT
         L     R1,RDC_UNK                 GET UNKNOWN COUNT
         LA    R1,1(R1)                   INCREMENT BY 1
         ST    R1,RDC_UNK                 SAVE FOR LATER
         LA    R14,BRODCAST_DECB          LOCATE DECB
         L     R2,DECBAREA-DECB(R14)      LOCATE THE DATA
*
         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX
         MVC   0(MSG11L,R15),MSG11        GET MESSAGE
         LA    R15,MSG11L(R15)            LOCATE PAST IT
         LA    R14,BRODCAST_DECB          LOCATE DECB
         L     R14,DECKYADR-DECB(R14)     -> KEY ADDRESS
         SLR   R1,R1                      CLEAR REGISTER
         IC    R1,0(R14)                  GET KEY TYPE
         BAS   R9,CONHEX                  EDIT IT
         BAS   R9,PRINT_SYSPRINT_RECORD   PRINT MESSAGE ON SYSPRINT
*
*        BAS   R9,DUMPREC                 DUMP RECORD
         B     RDC$LB                     BUMP TO NEXT RECORD
RDC$TLX  EQU   *
         SLR   R1,R1                      CLEAR REGISTER
         ICM   R1,B'0111',1(R14)          GET ENTRY COUNT
         LA    R1,1(R1)                   INCREMENT BY 1
         STCM  R1,B'0111',1(R14)          SAVE ENTRY COUNT
RDC$LB   EQU   *
         LA    R7,1(R7)                   BUMP RECORD COUNT
         BCT   R8,RDC$L                   ..DO ALL RECORDS
         EJECT
***********************************************************************
***                                                                 ***
**        Termination                                                **
***                                                                 ***
***********************************************************************
         SPACE 2
EXIT     EQU   *
         TM    FLAG1,$F1_OPENE            File open error
         BO    X$PEMSG                    Yes, continue
*
** Misc totals
*
         BAS   R14,CLEAR_RECOUT           CLEAR RECOUT TO BLANKS
         BAS   R9,PRINT_SYSPRINT_RECORD
         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX
         MVC   0(MSG2L,R15),MSG2          GET MESSAGE
         LA    R15,MSG2L+1(R15)           BUMP PAST MESSAGE
         MVC   0(7,R15),=C'Trivia:'
         BAS   R9,PRINT_SYSPRINT_RECORD   PRINT MESSAGE
*
         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX
         MVC   0(MSG2L,R15),MSG2          GET MESSAGE
         LA    R15,MSG2L+1(R15)           BUMP PAST MESSAGE
         MVC   0(20,R15),=CL20'Users defined-------'
         LA    R15,20(R15)                BUMP PAST TEXT
         L     R1,X_UCOUNT                GET COUNT
         BAS   R14,EDITD15                EDIT USER COUNT
         BAS   R9,PRINT_SYSPRINT_RECORD   PRINT MESSAGE
*
         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX
         MVC   0(MSG2L,R15),MSG2          GET MESSAGE
         LA    R15,MSG2L+1(R15)           BUMP PAST MESSAGE
         MVC   0(20,R15),=CL20'Most messages queued'
         LA    R15,20(R15)                BUMP PAST TEXT
         MVC   0(8,R15),=8C'-'
         MVC   8(7,R15),PUR_HUSERN        Get user with the most cake
         LA    R15,15(R15)
*
         SLR   R0,R0                       Clear even register
         L     R1,PUR_HUSERC               Get count of notices
         M     R0,=F'10000'                Magnify it
         SLR   R0,R0                       Clear even register
         D     R0,X_TRECS                  Calculate percentage
         CVD   R1,DOUBLE                   Save it
         MVC   0(7,R15),=X'40,20,21,20,4B,20,20' Get edit pattern
         ED    0(7,R15),DOUBLE+5           Edit percentage
         MVI   7(R15),C'%'                 Add suffix
         LA    R15,7+1+2(R15)              Bump past percentage stuff
*
         MVC   0(8,R15),=C'Messages'      Insert text for 2nd column
         LA    R15,8(R15)                 Bump past it
         L     R1,PUR_HUSERC              Get message count
         BAS   R14,EDITD15                Edit count
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message
*
         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX
         MVC   0(MSG2L,R15),MSG2          GET MESSAGE
         LA    R15,MSG2L+1(R15)           BUMP PAST MESSAGE
         MVC   0(20,R15),=CL20'Total blocks--------'
         LA    R15,20(R15)                BUMP PAST TEXT
         L     R1,X_TRECS                 Get total records in file
         BAS   R14,EDITD15                EDIT USER COUNT
         BAS   R9,PRINT_SYSPRINT_RECORD   PRINT MESSAGE
         L     R1,RDC_UNK                 GET UNKNOWN COUNT
*
** Print record totals
*
         BAS   R14,CLEAR_RECOUT           CLEAR RECOUT TO BLANKS
         BAS   R9,PRINT_SYSPRINT_RECORD
         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX
         MVC   0(MSG2L,R15),MSG2          GET MESSAGE
         LA    R15,MSG2L+1(R15)           BUMP PAST MESSAGE
         MVC   0(14,R15),=C'Record totals:'
         BAS   R9,PRINT_SYSPRINT_RECORD   PRINT MESSAGE
*
         LA    R7,C_RTABN                 NUMBER OF ENTRIES IN TABLE
         LA    R8,RDC_T                   LOCATE TABLE
X$PRT    EQU   *
         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX
         MVC   0(MSG2L,R15),MSG2          GET MESSAGE
         LA    R15,MSG2L+1(R15)           BUMP PAST MESSAGE
         MVC   0(20,R15),RTAB_TEXT-RTAB(R8) GET MESSAGE FROM TABLE
         LA    R15,20(R15)                BUMP PAST TEXT
*
         CLI   RTAB_TYPE-RTAB(R8),X'03'   User records?
         BNE   X$PRTUX                    Nope, continue
         SLR   R1,R1                      Clear register
         ICM   R1,B'0111',1(R8)           Save user message count
         ST    R1,X_UMSGS                 Save number of user messages
X$PRTUX  EQU   *
*
         SLR   R1,R1                      CLEAR REGISTER
         ICM   R1,B'0111',RTAB_COUNT-RTAB(R8) GET ENTRY COUNT
         BAS   R14,EDITD15                EDIT ENTRY COUNT
*
         SLR   R0,R0                      Clear even register
         SLR   R1,R1                      Clear odd register
         ICM   R1,B'0111',RTAB_COUNT-RTAB(R8) Get number
         M     R0,=F'10000'               Magnify it
         SLR   R0,R0                      Clear even register
         D     R0,X_TRECS                 Calculate percentage
         CVD   R1,DOUBLE                  Save it
         MVC   0(7,R15),=X'40,20,21,20,4B,20,20' Get edit pattern
         ED    0(7,R15),DOUBLE+5          Edit percentage
         MVI   7(R15),C'%'                Add suffix
*
         BAS   R9,PRINT_SYSPRINT_RECORD   PRINT MESSAGE
         LA    R8,RTABL(R8)               BUMP TO NEXT ENTRY
         BCT   R7,X$PRT                   TRY IT OUT
*
         ICM   R1,B'1111',RDC_UNK         Get unknown record count
         BZ    X$UNKX                     None?
         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX
         MVC   0(MSG2L,R15),MSG2          GET MESSAGE
         LA    R15,MSG2L+1(R15)           BUMP PAST MESSAGE
         MVC   0(20,R15),=CL20'Unknown records-----'
         LA    R15,20(R15)                BUMP PAST TEXT
         L     R1,RDC_UNK                 GET COUNT
         BAS   R14,EDITD15                EDIT USER COUNT
         BAS   R9,PRINT_SYSPRINT_RECORD   PRINT MESSAGE
X$UNKX   EQU   *
*
** Message types
*
         L     R6,X_UMSGS                 Get total user message count
         BAS   R14,CLEAR_RECOUT           CLEAR RECOUT TO BLANKS
         BAS   R9,PRINT_SYSPRINT_RECORD
         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX
         MVC   0(MSG2L,R15),MSG2          GET MESSAGE
         LA    R15,MSG2L+1(R15)           BUMP PAST MESSAGE
         MVC   0(14,R15),=C'Message types:'
         BAS   R9,PRINT_SYSPRINT_RECORD   PRINT MESSAGE
*
         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX
         MVC   0(MSG2L,R15),MSG2          GET MESSAGE
         LA    R15,MSG2L+1(R15)           BUMP PAST MESSAGE
         MVC   0(20,R15),=CL20'> $HASP165/Notify---'
         LA    R15,20(R15)                BUMP PAST TEXT
         L     R1,PUR_$HASP165            GET COUNT
         SR    R6,R1                      Subtract for this type
         BAS   R14,EDITD15                EDIT USER COUNT
         BAS   R9,PRINT_SYSPRINT_RECORD
*
         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX
         MVC   0(MSG2L,R15),MSG2          GET MESSAGE
         LA    R15,MSG2L+1(R15)           BUMP PAST MESSAGE
         MVC   0(20,R15),=CL20'> $HASP549/Mail-----'
         LA    R15,20(R15)                BUMP PAST TEXT
         L     R1,PUR_$HASP549            GET COUNT
         SR    R6,R1                      Subtract for this type
         BAS   R14,EDITD15                EDIT USER COUNT
         BAS   R9,PRINT_SYSPRINT_RECORD
*
         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX
         MVC   0(MSG2L,R15),MSG2          GET MESSAGE
         LA    R15,MSG2L+1(R15)           BUMP PAST MESSAGE
         MVC   0(20,R15),=CL20'> DMTAXM104I/VM-----'
         LA    R15,20(R15)                BUMP PAST TEXT
         L     R1,PUR_DMTAXM104I          GET COUNT
         SR    R6,R1                      Subtract for this type
         BAS   R14,EDITD15                EDIT USER COUNT
         BAS   R9,PRINT_SYSPRINT_RECORD
*
         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX
         MVC   0(MSG2L,R15),MSG2          GET MESSAGE
         LA    R15,MSG2L+1(R15)           BUMP PAST MESSAGE
         MVC   0(20,R15),=CL20'> Other-------------'
         LA    R15,20(R15)                BUMP PAST TEXT
         LR    R1,R6                      GET COUNT
         BAS   R14,EDITD15                EDIT USER COUNT
         BAS   R9,PRINT_SYSPRINT_RECORD
*
** Print company/division statistics
*
         BAS   R14,CLEAR_RECOUT           CLEAR RECOUT TO BLANKS
         BAS   R9,PRINT_SYSPRINT_RECORD
         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX
         MVC   0(MSG2L,R15),MSG2          GET MESSAGE
         LA    R15,MSG2L+1(R15)           BUMP PAST MESSAGE
         MVC   0(15,R15),=C'Company totals:'
         BAS   R9,PRINT_SYSPRINT_RECORD   PRINT MESSAGE
*
         L     R5,X_CUSERS+4              Locate table
         LA    R5,8(R5)                   Bump past eyecatcher
         L     R6,X_CMSGS+4               Locate table
         LA    R6,8(R6)                   Bump past eyecatcher
         LA    R7,C'A'                    Start with first possible
         LR    R14,R7                     Get starting entry
         MH    R14,=H'4'                  Calculate offset
         AR    R5,R14                     Locate to first entry
         AR    R6,R14                     Locate to first entry
X$CL     EQU   *
         ICM   R8,B'1111',0(R5)           Get count for this company
         BZ    X$CLB
         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX
         MVC   0(MSG2L,R15),MSG2          GET MESSAGE
         LA    R15,MSG2L+1(R15)           BUMP PAST MESSAGE
         MVC   0(20,R15),=CL20'> _ users-----------'
         STC   R7,2(R15)                  Save company code
         LA    R15,20(R15)                BUMP PAST TEXT
         LR    R1,R8                      GET COUNT
         BAS   R14,EDITD15                Edit count
*
         SLR   R0,R0                       Clear even register
         L     R1,0(R5)                    Get count of notices
         M     R0,=F'10000'                Magnify it
         SLR   R0,R0                       Clear even register
         D     R0,X_TRECS                  Calculate percentage
         CVD   R1,DOUBLE                   Save it
         MVC   0(7,R15),=X'40,20,21,20,4B,20,20' Get edit pattern
         ED    0(7,R15),DOUBLE+5           Edit percentage
         MVI   7(R15),C'%'                 Add suffix
         LA    R15,7+1+2(R15)
*
         MVC   0(8,R15),=C'Messages'      Insert text for 2nd column
         LA    R15,8(R15)                 Bump past it
         L     R1,0(R6)                   Get message count
         BAS   R14,EDITD15                Edit count
*
         SLR   R0,R0                       Clear even register
         L     R1,0(R6)                    Get count of notices
         M     R0,=F'10000'                Magnify it
         SLR   R0,R0                       Clear even register
         D     R0,X_UCOUNT                 Calculate percentage
         CVD   R1,DOUBLE                   Save it
         MVC   0(7,R15),=X'40,20,21,20,4B,20,20' Get edit pattern
         ED    0(7,R15),DOUBLE+5           Edit percentage
         MVI   7(R15),C'%'                 Add suffix
*
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message
X$CLB    EQU   *
         LA    R5,4(R5)                   Bump to next entry
         LA    R6,4(R6)                   Bump to next entry
         LA    R7,1(R7)                   Bump to next company
         CH    R7,=H'256'                 At the end of the table yet
         BL    X$CL
*
         LM    R0,R1,X_CUSERS             Get table length, address
         FREEMAIN R,LV=(0),A=(1)          Free table
         LM    R0,R1,X_CMSGS              Get table length, address
         FREEMAIN R,LV=(0),A=(1)          Free table
*
         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX
         MVC   0(MSG2L,R15),MSG2          GET MESSAGE
         LA    R15,MSG2L+1(R15)           BUMP PAST MESSAGE
         MVC   0(20,R15),=CL20'Total---------------'
         LA    R15,20(R15)                BUMP PAST TEXT
         L     R1,X_UCOUNT                GET COUNT
         BAS   R14,EDITD15                Edit count
         LA    R15,7+1+2(R15)             Locate past number
         MVC   0(8,R15),=C'Messages'      Insert text for 2nd column
         LA    R15,8(R15)                 Bump past it
         L     R1,X_UMSGS                 Get messages
         BAS   R14,EDITD15                Edit count
         BAS   R9,PRINT_SYSPRINT_RECORD   Print message
*
** Print "ENDED" Message
*
X$PEMSG  EQU   *
         BAS   R14,CLEAR_RECOUT           CLEAR RECOUT TO BLANKS
         BAS   R9,PRINT_SYSPRINT_RECORD
         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE
         MVC   0(MSG1L,R15),MSG1
         LA    R15,MSG1L+1(R15)
         MVC   0(5,R15),=C'ended'
         BAS   R9,PRINT_SYSPRINT_RECORD
*
** Free BKLids table (if any)
*
         LM    R0,R1,RBF_VS               Get table length and address
         LTR   R0,R0                      Any table to free?
         BZ    X$RBFX                     No, continue
         FREEMAIN RU,LV=(0),A=(1)         Release storage
X$RBFX   EQU   *
*
** Close files
*
         FREEDBUF BRODCAST_DECB,D,BRODCAST FREE I/O BUFFER
         LA    R3,BRODCAST
         BAS   R9,CLOSE_FILE
         LA    R3,MAIL
         BAS   R9,CLOSE_FILE
         LA    R3,INDEX
         BAS   R9,CLOSE_FILE
         LA    R3,SYSPRINT
         BAS   R9,CLOSE_FILE
         LA    R3,IEBUPDTE
         BAS   R9,CLOSE_FILE
*
** Return to caller
*
         DA#LEAVE ,                       Exit housekeeping
         EJECT
***********************************************************************
***                                                                 ***
**       ERROR ROUTINES                                              **
***                                                                 ***
***********************************************************************
         SPACE 2
*
** FILE OPEN ERROR: INPUT: R3 - DCB
*
E$SYNAD  EQU   *
         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE
         MVC   0(MSG9L,R15),MSG9          GET MESSAGE
         LA    R15,MSG9L+1(R15)           BUMP PAST MESSAGE
         L     R1,X_RECI                  GET NUMBER
         BAS   R9,EDITFWF                 EDIT IT
         BAS   R9,PRINT_SYSPRINT_RECORD   PRINT MESSAGE ON SYSPRINT
         B     EXIT
*
** FILE OPEN ERROR: INPUT: R3 - DCB
*
E$FOPEN  EQU   *
         OI    FLAG1,$F1_OPENE
         LR    R2,R15                     SAVE RETURN CODE
*
         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE
         MVC   0(MSG5L,R15),MSG5          GET MESSAGE
         LA    R15,MSG5L(R15)             BUMP PAST MESSAGE
         MVC   0(8,R15),DCBDDNAM-IHADCB(R3) GET DDNAME
         LA    R0,L'DCBDDNAM              MAX LENGTH OF DDNAME
         BAS   R14,FIRSTSPC               LOCATE FIRST SPACE
*
         LR    R1,R2                      GET OPEN RETURN CODE
         LTR   R1,R1                      OPEN RC=0
         BZ    EFO$OX                     YES, DONT PRINT RC=0
         MVC   0(10,R15),=C', OPEN RC='   TEXT
         LA    R15,10(R15)                BUMP PAST TEXT
         BAS   R9,EDITFWF                 EDIT IT
         BCTR  R15,0                      BACKUP OVER SPACE
EFO$OX   EQU   *
*
         ICM   R1,B'1111',CO_CODE         GET OPEN ABEND CODE
         BZ    EFO$CX                     NONE, MOVE ON
         N     R1,=A(X'FFF0FF00')         TURN OFF UNNEEDED BITS
         MVC   0(9,R15),=C', ABEND S'     TEXT
         LA    R15,9(R15)                 BUMP PAST IT
         ST    R1,DOUBLE                  SAVE ABEND CODE
         UNPK  0(9,R15),DOUBLE(5)                   ---+
         MVZ   0(8,R15),=X'00,00,00,00,00,00,00,00'    | BINARY TO HEX
         TR    0(8,R15),=C'0123456789ABCDEF'        ---+
         MVI   3(R15),C'-'                MOVE IN DASH
         LA    R15,6(R15)
         MVI   0(R15),C' '
         MVI   1(R15),C' '
EFO$CX   EQU   *
         BAS   R9,PRINT_SYSPRINT_RECORD   PRINT MSG5 ON SYSPRINT
         B     EXIT
*
** DCB ABEND EXIT ROUTINE: GC26-4013 MVS/XA DATA ADMINISTRATION GUIDE
**                         CHAPTER 7.
*
E$OPENA  EQU   *
         L     R2,0(R1)                   GET ABEND CODE
         ST    R2,CO_CODE                 SAVE ABEND CODE
         MVI   3(R1),4                    IGNORE ABEND
         BSM   0,R14                      RETURN TO IOS
*
** SYNAD ERROR ROUTINE
*
E$OPENS  EQU   *
         PRINT GEN
         STM  R12,R14,EOS_REGS
*
         SYNADAF ACSMETH=BDAM
*
         LR    R2,R13                    SAVE ADDRESS OF SAVE AREA
         L     R13,4(R13)                RESTORE save area
         MVC   EOS_MSG(78),50(R1)        GET MESSAGE FROM IOS
         LR    R13,R2                    RESTORE SAVEAREA FROM SYNADAF
*
         SYNADRLS ,
*
         LM   R12,R14,EOS_REGS
         BSM  0,R14
         EJECT
***********************************************************************
***                                                                 ***
**       PRINT USERID RECORDS                                        **
**       INPUT: R7 POINTS TO A USERID ENTRY (BDS_UID)                **
***                                                                 ***
***********************************************************************
         SPACE 2
PRINT_USER_RECORDS EQU *
         ST    R9,PUR_RA                  SAVE RETURN ADDRESS
*
         L     R1,X_UCOUNT                GET USER COUNT
         LA    R1,1(R1)                   INCREMENT COUNT
         ST    R1,X_UCOUNT                SAVE USER COUNT
*
** Any mail for this user?
*
         XC    PUR_MCNT(4),PUR_MCNT       CLEAR MAIL COUNT
         CLC   BDS_UID_FIRST-BDS_UID(3,R7),=X'00,00,00'
         BE    PUR$LX                     ZEROS: NO MAIL FOR THIS GUY
*
** Locate first mail address
*
         MVC   BRODCAST_BLKN(3),BDS_UID_FIRST-BDS_UID(R7)
         B     PUR$LCX                    BRANCH PAST FIRST/LAST CHECK
*
** LOOP THRU USERID'S MAIL
*
PUR$L    EQU   *
*        CLC   BRODCAST_BLKN(3),BDS_UID_LAST-BDS_UID(R7) Last?
*        BE    PUR$LX                     YES, LEAVE
PUR$LCX  EQU   *
         L     R1,PUR_MCNT                GET MAIL COUNT
         LA    R1,1(R1)                   INCREMENT COUNT
         ST    R1,PUR_MCNT                SAVE MAIL COUNT
*
         BAS   R9,READ_RECORD             READ USERID'S MAIL BY REL REC
*
         BAS   R14,CLEAR_RECOUT           CLEAR RECORD
         LA    R15,RECOUT+1               LOCATE PAST FBA BYTE
         MVC   0(7,R15),BDS_UID_NAME-BDS_UID(R7) GET USERID
         LA    R15,8(R15)                 BUMP PAST IT
         SLR   R1,R1                      CLEAR REGISTER
         IC    R1,BDS_MAIL_TEXTL-BDS_MAIL(R2)   GET LENGTH OF MAIL
         EX    R1,PUR$LMME                MOVE MAIL TO PRINT LINE
         BAS   R9,PRINT_MAIL_RECORD       PRINT LINE
*                                     0....+....1....+....2....+
* Save trivia about Notify messages: "hh.mm.ss JOB##### $HASP165"
*
         CLI   BDS_MAIL_TEXT-BDS_MAIL+2(R2),C'.' Looks a JES2 message?
         BNE   PUR$LMJX                   Nope, continue
         CLC   BDS_MAIL_TEXT-BDS_MAIL+18(8,R2),=C'$HASP549'
         BE    PUR$LMM                    Yes, continue
         CLC   BDS_MAIL_TEXT-BDS_MAIL+18(8,R2),=C'$HASP165'
         BNE   PUR$LMJX                   Nope, continue
         L     R1,PUR_$HASP165            Get count
         LA    R1,1(R1)                   Increment it
         ST    R1,PUR_$HASP165            Save it
         B     PUR$LMJX
PUR$LMM  EQU   *
         L     R1,PUR_$HASP549            Get count
         LA    R1,1(R1)                   Increment it
         ST    R1,PUR_$HASP549            Save it
         B     PUR$LMJX
PUR$LMJX EQU   *
         CLI   BDS_MAIL_TEXT-BDS_MAIL+18(R2),C'D'
         BNE   PUR$LMX
         CLC   BDS_MAIL_TEXT-BDS_MAIL+18(10,R2),=C'DMTAXM104I'
         BNE   PUR$LMX                    Yes, continue
         L     R1,PUR_DMTAXM104I
         LA    R1,1(R1)
         ST    R1,PUR_DMTAXM104I
PUR$LMX  EQU   *
*
         L     R1,X_CMSGS+4               Get address of table
         LA    R1,8(R1)                   Bump past header
         SLR   R14,R14                    Clear register
         IC    R14,BDS_UID_NAME-BDS_UID(R7) Get division/co
         MH    R14,=H'4'                  Length of each entry
         AR    R1,R14                     Locate to fullword for comp.
         L     R15,0(R1)                  Get company/division count
         LA    R15,1(R15)                 Increment count by 1
         ST    R15,0(R1)                  Save company/division count
*
** Any more?
*
         MVC   BRODCAST_BLKN(3),BDS_MAIL_NEXT-BDS_MAIL(R2) -> Mail
         CLC   BRODCAST_BLKN(3),=X'00,00,00' ZERO?
         BNE   PUR$L                      NO, PROCESS IT
*
** Print number of mail messages on index file
*
PUR$LX   EQU   *
*
         CLC   PUR_HUSERC(4),PUR_MCNT     Higher?
         BH    PUR$IHUX                   No, continue
         MVC   PUR_HUSERC(4),PUR_MCNT     Save new count
         MVC   PUR_HUSERN(7),BDS_UID_NAME-BDS_UID(R7) Save user name
PUR$IHUX EQU   *
*
         L     R1,X_CUSERS+4              Get address of table
         LA    R1,8(R1)                   Bump past header
         SLR   R14,R14                    Clear register
         IC    R14,BDS_UID_NAME-BDS_UID(R7) Get division/co
         MH    R14,=H'4'                  Length of each entry
         AR    R1,R14                     Locate to fullword for comp.
         L     R15,0(R1)                  Get company/division count
         LA    R15,1(R15)                 Increment count by 1
         ST    R15,0(R1)                  Save company/division count
*
         L     R1,PUR_MCNT                Get count
         C     R1,=AL4(#BCINDEX)          Under threshold?
         BL    PUR$IRX                    Yep, ignore it
         BAS   R14,CLEAR_RECOUT
         LA    R15,RECOUT+1
         L     R1,PUR_MCNT
         CVD   R1,DOUBLE                  CONVERT TO PACKED
         MVC   0(15,R15),EDITP15          GET EDIT PATTERN
         ED    0(15,R15),DOUBLE+2         EDIT
         LTR   R1,R1
         BNZ   PUR$IX
         MVI   14(R15),C'0'
PUR$IX   EQU   *
         LA    R15,16(R15)
*
         SLR   R0,R0                       Clear even register
         L     R1,PUR_MCNT                 Get count of notices
         M     R0,=F'10000'                Magnify it
         SLR   R0,R0                       Clear even register
         D     R0,X_TRECS                  Calculate percentage
         CVD   R1,DOUBLE                   Save it
         MVC   0(7,R15),=X'40,20,21,20,4B,20,20' Get edit pattern
         ED    0(7,R15),DOUBLE+5           Edit percentage
         MVI   7(R15),C'%'                 Add suffix
         LA    R15,9(R15)
         MVC   0(7,R15),BDS_UID_NAME-BDS_UID(R7)
         LA    R15,9(R15)
*
         ICM   R9,B'1111',RBF_VS+4         Get table address
         BZ    PUR$IRP
         ICM   R0,B'1111',RBF_USERC        Get user count
         BZ    PUR$IRP
         DA#SMODE 31                      Get into 31 bit mode
         LA    R9,BKLHL(R9)                Bump past header
         ICM   R0,B'1111',RBF_USERC        Get user count
PUR$IRUL EQU   *
         CLC   BKLE_USER-BKLE(7,R9),BDS_UID_NAME-BDS_UID(R7)
         BE    PUR$IRUF
         LA    R9,BKLEL(R9)
         BCT   R0,PUR$IRUL
         B     PUR$IRUX
PUR$IRUF EQU   *
         MVC   0(L'BKLE_NAME,R15),BKLE_NAME-BKLE(R9)
         LA    R15,L'BKLE_NAME+3(R15)
         MVC   0(6,R15),=C'Phone:'
         MVC   7(L'BKLE_PHONE,R15),BKLE_PHONE-BKLE(R9)
PUR$IRUX EQU   *
         DA#SMODE 24                      Get into 24 bit mode
*
PUR$IRP  EQU   *
         BAS   R9,PRINT_INDEX_RECORD
PUR$IRX  EQU   *
*
** Common exit from PRINT_USER_RECORDS processing
*
PUR$X    EQU   *
         L     R9,PUR_RA                  RESTORE RETURN ADDRESS
         BSM   0,R9
*
PUR$LMME MVC   0(0,R15),BDS_MAIL_TEXT-BDS_MAIL(R2)  *** EXECUTED ***
         EJECT
***********************************************************************
***                                                                 ***
**       Read a record from the BRODCAST dataset                     **
***                                                                 ***
***********************************************************************
         SPACE 2
READ_RECORD EQU *
         ST    R9,RR_RA                   SAVE RETURN ADDRESS
*
         L     R1,X_RECI                  GET INPUT RECORD COUNT
         LA    R1,1(R1)                   INCREMENT RECORD COUNT
         ST    R1,X_RECI                  SAVE INPUT RECORD COUNT
*
** FREE THE BUFFER (DON'T DO THE FIRST TIME THRU)
*
         LA    R15,1                      FIRST RECORD = 1
         CR    R1,R15                     FIRST RECORD?
         BE    RR$IO                      YES, MOVE ON
         FREEDBUF BRODCAST_DECB,D,BRODCAST FREE I/O BUFFER
RR$IO    EQU   *
*
** READ RECORD BY BRODCAST_BLKN
*
         LA    R3,BRODCAST_DECB
         LA    R4,BRODCAST
         LA    R5,BRODCAST_BLKN
         READ  (3),DI,(4),'S','S','S',(5),MF=E
         CHECK (3)
*
** CHECK FOR SYNAD ERRORS
*
         CLI   EOS_MSG,X'00'              GOT A SYNAD MESSAGE?
         BE    RR$SNDX                    NO, MOVE ON
         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE
         MVC   0(MSG8L,R15),MSG8          GET YSLOGUTL MESSAGE
         LA    R15,MSG8L+1(R15)           BUMP AROUND IT
         MVC   0(78,R15),EOS_MSG          GET SYNAD ERROR MESSAGE
         BAS   R9,PRINT_SYSPRINT_RECORD
         B     E$SYNAD                    TURN SYNAD MESSAGE OFF
RR$SNDX  EQU   *
*
** LOCATE THE RECORD
*
         L     R2,DECBAREA-DECB(R3)       LOCATE THE DATA
*
         L     R9,RR_RA                   GET RETURN ADDRESS
         BSM   0,R9
         EJECT
***********************************************************************
***                                                                 ***
**       Misc internal subroutines                                   **
***                                                                 ***
***********************************************************************
         SPACE 2
*
** Close file
**
** Input: R3 points to DCB
*
CLOSE_FILE EQU *
         TM    DCBOFLGS-IHADCB(R3),DCBOFOPN Is file open?
         BNO   CF$X
         MVC   PARMLIST(C_CLOSEL),C_CLOSE
         CLOSE ((3)),MF=(E,PARMLIST)      Close it
CF$X     EQU   *
         BSM   0,R9
*
** CHECK OPEN OF FILE
** INPUT: R15 - OPEN RC
**        R3  - ADDRESS OF DCB
**        CO_CODE - ABEND CODE FROM EXLST
*
CHECK_OPEN EQU *
         LTR   R15,R15                    CHECK OPEN RETURN CODE
         BNZ   E$FOPEN                    NOT GOOD: PRINT ERROR
         TM    DCBOFLGS-IHADCB(R3),DCBOFOPN IS IT OPEN?
         BNO   E$FOPEN                    NO, PRINT ERROR MESSAGES
         ICM   R1,B'1111',CO_CODE         GET OPEN-ABEND CODE
         BNZ   E$FOPEN                    YES, NO ABEND CODE...
         BSM   0,R9
*
** FORMAT MESSAGE
*
FORMAT_MESSAGE EQU *
         LA    R15,SYSPRINT               LOCATE GLOBAL MESSAGES DCB
         TM    DCBOFLGS-IHADCB(R15),DCBOFOPN IS IT OPEN?
         BO    FM$RO                      YES, FORMAT NORMAL MESSAGE
         LA    R15,RECOUT                 LOCATE MESSAGE WORK AREA
         MVC   0(C_WTOL,R15),C_WTO        MOVE WTO TO RECOUT
         LA    R15,4(R15)                 BUMP PAST WTO FLAGS
         B     FM$ROX                     MOVE PAST SYSPRINT MESSAGE
FM$RO    EQU   *
         BAS   R14,CLEAR_RECOUT           CLEAR RECOUT TO BLANKS
         LA    R15,RECOUT+1               LOCATE RECOUT
FM$ROX   EQU   *
         MVC   0(MSGPL,R15),MSGP          GET MESSAGE PREFIX
         LA    R15,MSGPL(R15)             BUMP PAST MESSAGE PREFIX
         BSM   0,R9
*
** POINT REGISTER 15 TO FIRST BLANK IN STRING
** INPUT:  R0  - MAXIMUM LENGTH OF STRING
**         R15 - STRING
** OUTPUT: R15 - FIRST SPACE IN STRING
*
FIRSTSPC EQU   *
         CLI   0(R15),C' '
         BE    FS$EXIT
         LA    R15,1(R15)
         BCT   R0,FIRSTSPC
FS$EXIT  EQU   *
         BSM   0,R14
*
** CONVERT R1 TO A HEX STRING - FULL 8 BYTES
** INPUT: R1 = NUMBER TO CONVERT
** OUTPUT: R15 - ADDRESS TO PUT 8 BYTE LITERAL
*
HEXSTR8  EQU   *
         ST    R1,DOUBLE                  SAVE NUMBER
         UNPK  0(9,R15),DOUBLE(5)
         MVZ   0(8,R15),=X'00,00,00,00,00,00,00,00'
         TR    0(8,R15),=C'0123456789ABCDEF'
         LA    R15,8(R15)
         MVI   0(R15),C' '
         BSM   0,R9
*
** CONVERT NUMBER TO HEX STRING, IGNORE LEADING ZEROS
** INPUT: R1 = NUMBER TO CONVERT
** OUTPUT: R15 - PAST LAST BYTE OF HEX STRING
*
CONHEX   EQU   *
         MVI   0(R15),X'7D'               INSERT TICK
         LA    R15,1(R15)                 BUMP PAST TICK
         ST    R1,DOUBLE                  SAVE NUMBER
         UNPK  DOUBLE2(9),DOUBLE(5)
         MVZ   DOUBLE2(8),=X'00,00,00,00,00,00,00,00'
         TR    DOUBLE2(8),=C'0123456789ABCDEF'
         LA    R0,6                       MAX SKIP OF LEADING ZEROS
         LA    R1,8                       MAX LENGTH OF STRING
         LA    R14,DOUBLE2                LOCATE HEX STRING
CH$LOOP1 EQU   *
         CLI  0(R14),C'0'                 LEADING ZERO?
         BNE  CH$LOOP2                    NO, GET OUT OF LOOP
         LA   R14,1(R14)                  YES, BUMP PAST THIS BOZO
         SH   R1,=H'1'                    DECREMENT COUNTER
         BCT  R0,CH$LOOP1                 ..TRY NEXT BYTE
CH$LOOP2 EQU  *
         MVC  0(1,R15),0(R14)             MOVE TO OUTPUT LOCATION
         LA   R15,1(R15)                  BUMP UP (OUTPUT)
         LA   R14,1(R14)                  BUMP UP (INPUT)
         BCT  R1,CH$LOOP2                 ..GET NEXT BYTE
CH$LOOPX EQU  *
         MVI   0(R15),X'7D'               INSERT TICK
         LA    R15,1(R15)                 BUMP PAST TICK
         BSM   0,R9
*
**       EDIT FULLWORD (FLUSH TO R15)
**       R1 --> INPUT:REGISTER TO PRINT
**       R15 --> OUTPUT: ADDRESS WHERE OUTPUT IS TO BE PUT
*
EDITFWF  EQU   *
         LTR   R1,R1                      CHECK FOR 0
         BZ    EDITFWF0                   YES, PUT ZERO
         CVD   R1,DOUBLE                  NO, CONVERT TO PACKEC
         LA    R1,DOUBLE2+14              LOCATE SIG DIGIT
         MVC   DOUBLE2(15),EDITP15
         EDMK  DOUBLE2(15),DOUBLE+2       EDIT AND SAVE PLACE
         LA    R14,DOUBLE2+16             LOCATE LAST POSSIBLE BYTE + 1
         SR    R14,R1                     LENGTH = END - START
         BCTR  R14,0                      DECREMENT FOR EX
         EX    R14,EDITFWFM               MOVE EDIT NUMBER TO OUTPUT
         LA    R15,1(R14,R15)             BUMP POINTER PAST NUMBER
         MVI   0(R15),C' '
         BSM   0,R9                       RETURN TO CALLER
EDITFWFM MVC   0(0,R15),0(R1)
EDITFWF0 DS    0H
         MVI   0(R15),C'0'                PUT IN ZERO
         LA    R15,2(R15)                 BUMP POINTER PAST ZERO
         BSM   0,R9                       RETURN TO CALLER
*
** DUMP RECORD
** INPUT: R2 - ADDRESS OF RECORD TO DUMP
**        BRODCAST_BLKN - BLOCK ID
*
DUMPREC  EQU   *
 AGO .DRX
         ST    R9,RA_DR                   SAVE RETURN ADDRESS
         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX
         MVC   0(MSG7L,R15),MSG7          GET MESSAGE
         LA    R15,MSG7L(R15)             LOCATE PAST IT
         SLR   R1,R1                      CLEAR REGISTER
         ICM   R1,B'0111',BRODCAST_BLKN   GET BLOCK NUMBER
         BAS   R9,EDITFWF                 EDIT IT
         BCTR  R15,0                      BACKUP ONE
         MVC   0(2,R15),=C'):'            GET SUFFIX
         BAS   R9,PRINT_SYSPRINT_RECORD   PRINT MESSAGE ON SYSPRINT
*
         MVC   MXD_LEN(2),=AL2(16)        INITIALIZE MINIXDMP LENGTH
         XC    MXD_OFF(2),MXD_OFF         INITIALIZE MINIXDMP OFFSET
         LA    R4,8                       16 * 6 = 96
         LR    R3,R2                      MOVE IN ADDRESS OF RECORD
DR$L     EQU   *                               -
         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX
         MVC   0(MSG6L,R15),MSG6          GET MESSAGE
         LA    R5,MSG6L+1(R15)            LOCATE PAST IT
         LINK  EP=MINIXDMP,               LINK TO MINI-HEX-DUMP PGM    @
               PARAM=(MXD_LEN,(3),(5),MXD_OFF),                        @
               MF=(E,PARMLIST)
         BAS   R9,PRINT_SYSPRINT_RECORD   PRINT MESSAGE ON SYSPRINT
         LA    R3,16(R3)                  BUMP TO NEXT ENTRY
         BCT   R4,DR$L                    ..DO IT
*
         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX
         MVC   0(MSG6L,R15),MSG6          GET MESSAGE
         LA    R5,MSG6L+1(R15)            LOCATE PAST IT
         MVC   MXD_LEN(2),=AL2(1)         INITIALIZE MINIXDMP LENGTH
         LINK  EP=MINIXDMP,               LINK TO MINI-HEX-DUMP PGM    @
               PARAM=(MXD_LEN,(3),(5),MXD_OFF),                        @
               MF=(E,PARMLIST)
         BAS   R9,PRINT_SYSPRINT_RECORD   PRINT MESSAGE ON SYSPRINT
*
         L     R9,RA_DR                   RESTORE RETURN ADDRESS
.DRX ANOP ,
         BSM   0,R9
*
** EDIT WITH DASHED PRECEEDING
** INPUT: R1 - NUMBER TO EDIT
**        R15 - WHERE TO PUT OUTPUT
*
EDITD15  EQU   *
         CVD   R1,DOUBLE                  CONVERT TO PACKED
         MVC   0(15,R15),EDITP15          GET EDIT PATTERN
         MVI   0(15),C'-'                 LEADING DASHES
         ED    0(15,R15),DOUBLE+2         EDIT
         LTR   R1,R1
         BNZ   EDITD15X
         MVI   14(R15),C'0'
EDITD15X EQU   *
         LA    R15,15(R15)                BUMP PAST NUMBER
         BSM   0,R14                      RETURN
*
** CLEAR RECOUT TO BLANKS
*
CLEAR_RECOUT EQU *
         MVI   RECOUT,C' '
         MVC   RECOUT+1(L'RECOUT-1),RECOUT
         BSM   0,R14
*
** PRINT RECORD ON MAIL FILE
*
PRINT_MAIL_RECORD EQU *
         PUT   MAIL,RECOUT
         TM    FLAG1,$F1_IEBUPDTE         Doing IEBUPDTE?
         BNO   PMR$X
         CLI   RECOUT+1,C'*'              Special case?
         BE    PMR$X                      Yes, skip it
         CLC   RECOUT+1(7),PMR_LAST       Same guy?
         BE    PMR$PIR                    Yes, continue
         MVI   RECOUTS,C' '               Get blank
         MVC   RECOUTS+1(79),RECOUTS      and propagate it
         MVC   RECOUTS(12),=C'./ ADD NAME=' Get IEBUPDTE control card
         MVC   RECOUTS+12(7),RECOUT+1     Get new userid
         PUT   IEBUPDTE,RECOUTS           Put record
         MVC   PMR_LAST(7),RECOUT+1       Save for next time
PMR$PIR  EQU   *
         CLI   RECOUT+9,C'.'              Conflict with IEBUPDTE?
         BNE   PMR$PIRC
         MVI   RECOUT+9,C'!'              Well it has a dot in it!
PMR$PIRC EQU   *
         PUT   IEBUPDTE,RECOUT+9          "_USERID._msg"
         LA    R15,RECOUT+9+80            Bump past 80 byte record
         CLC   0(133-80-9,R15),=CL80' '   Any more?
         BE    PMR$X
         SH    R15,=AL2(13)
         MVC   0(13,R15),=C'(Continued): '
         MVI   RECOUTS,C' '
         MVC   RECOUTS+1(11+7),RECOUTS    Just enough...
         PUT   IEBUPDTE,(R15)             Put out that second line
PMR$X    EQU   *
         BSM   0,R9
*
** PRINT RECORD ON index file
*
PRINT_INDEX_RECORD EQU *
         PUT   INDEX,RECOUT
         BSM   0,R9
*
** PRINT RECORD ON SYSPRINT FILE
*
PRINT_SYSPRINT_RECORD EQU *
         LA    R1,SYSPRINT
         TM    DCBOFLGS-IHADCB(R1),DCBOFOPN IS IT OPEN?
         BO    PRTS$FP
         LA    R1,RECOUT                  LOCATE WTO
         WTO   ,MF=(E,(1))                ISSUE IT
         B     PRTS$X                     LEAVE
PRTS$FP  EQU   *
         PUT   SYSPRINT,RECOUT
PRTS$X   EQU   *
         BSM   0,R9
         EJECT
***********************************************************************
***                                                                 ***
**       Constants                                                   **
***                                                                 ***
***********************************************************************
         SPACE 2
MSGP     DC    C'BRSC'
MSGPL    EQU   *-MSGP
MSG1     DC    C'001I System BRODCAST analyze utility'
MSG1L    EQU   *-MSG1
MSG1ASM  DC    C'- Assembled:'
MSG1ASML EQU   *-MSG1ASM
MSG2     DC    C'002I'      TRIVIA
MSG2L    EQU   *-MSG2
MSG3     DC    C'003I Users with more than &BCINDEX messages '
         DC    C'will be written to the INDEX file'
MSG3L    EQU   *-MSG3
MSG4     DC    C'004I --'
MSG4L    EQU   *-MSG4
MSG5     DC    C'005E Open failed to DDNAME='
MSG5L    EQU   *-MSG5
MSG6     DC    C'006I'
MSG6L    EQU   *-MSG6
MSG7     DC    C'007I Dump of record, Block-number('
MSG7L    EQU   *-MSG7
MSG8     DC    C'008E SYNAD Error:'
MSG8L    EQU   *-MSG8
MSG9     DC    C'009E I/O Error while reading record number'
MSG9L    EQU   *-MSG9
MSG10    DC    C'010I'
MSG10L   EQU   *-MSG10
MSG11    DC    C'011W Unknown record type found, X'
MSG11L   EQU   *-MSG11
MSG12    DC    C'012E Overflow on BKLIDS table, only first'
MSG12L   EQU   *-MSG12
MSG13    DC    C'013I Writing mail records to IEBUPDTE file'
MSG13L   EQU   *-MSG13
*
EDITP15  DC    X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'
*
C_LSTI   OPEN  (*-*,(INPUT)),MF=L
C_LSTIL  EQU   *-C_LSTI
C_LSTO   OPEN  (*-*,(OUTPUT)),MF=L
C_LSTOL  EQU   *-C_LSTO
C_CLOSE  CLOSE (*-*),MF=L
C_CLOSEL EQU   *-C_CLOSE
*
         PRINT GEN
         DS    0D
C_DECB   READ  C_DECBC,DI,*-*,'S','S','S',*-*,MF=L
C_DECBL  EQU   *-C_DECB
         PRINT NOGEN
C_DCBFI  DCB   DDNAME=C_DCB,                                           @
               DSORG=DA,MACRF=RISC,OPTCD=R,BLKSIZE=129,                @
               RECFM=F,BUFNO=2,KEYLEN=1,BUFL=130
C_DCBFIL EQU   *-C_DCBFI
C_DCBO   DCB   DDNAME=C_DCBO,                                          @
               DSORG=PS,MACRF=PM,RECFM=FBA
C_DCBOL  EQU   *-C_DCBO
C_DCBI   DCB   DDNAME=C_DCBI,                                          @
               DSORG=PS,MACRF=GL,EODAD=*-*,RECFM=VB
C_DCBIL  EQU   *-C_DCBI
         DS    0D
C_WTO    WTO   '                                                       @
                                                                       @
                       ',                                              @
               ROUTCDE=(11,14),MCSFLAG=HRDCPY,MF=L
C_WTOL   EQU   *-C_WTO
         PRINT GEN
C_RTAB   EQU   *
         DC    X'00',X'00,00,00',CL20'Notice--------------'
         DC    X'01',X'00,00,00',CL20'USERID index--------'
         DC    X'02',X'00,00,00',CL20'BRODCAST------------'
         DC    X'03',X'00,00,00',CL20'User message--------'
         DC    X'04',X'00,00,00',CL20'Header--------------'
         DC    X'05',X'00,00,00',CL20'System--------------'
         DC    X'FF',X'00,00,00',CL20'Free----------------'
C_RTABL  EQU   *-C_RTAB
C_RTABN  EQU   C_RTABL/RTABL
*
** Literals used in program
*
         DS    0F
         DC    CL8'BKUSERMC'          Literal for easy zapping
C_BKUSRC DC    AL4(#BKUSERS)          Max number of users considered
*
** Literals used in program
*
         LTORG ,
         DS    0D                     End of DA$BRODC CSECT
*
** Calculate length of code available in CSECT
*
DA$BRODCL EQU *-DA$BRODC              Length used
DA$BRODCF EQU (4096*2)-DA$BRODCL      Length available
         EJECT
***********************************************************************
***                                                                 ***
**       GETMAINed work area                                         **
***                                                                 ***
***********************************************************************
 SPACE 2
DSA            DSECT ,
               DS    18F                  Register Save Area
DSA_LIT1       DS    CL8'DA#BRODC'        Literal for dumps
DSA_LIT2       DS    CL8' DSA'            Literal for dumps
DOUBLE         DS    D                    Double word work area
DOUBLE2        DS    2D                   Double word work area * 2
PARMLIST       DS    10F                  Parameter list for calls
RECOUT         DS    CL133                Output record area
RECOUTS        DS    CL133                Slack
               DS    0F                   E$OPENS
EOS_REGS       DS    18F                  ..Register Save Area
EOS_MSG        DS    CL78                 ..Message from SYNAD
*                                         Print_Mail_Record
PMR_LAST       DS    CL7                  ..Last userid
               DS    0F                   EXECUTION
X_RECI         DS    F                    ..SYNAD ERROR COUNT
X_UCOUNT       DS    F                    ..Userid count
X_UMSGS        DS    F                    ..User message count
X_TRECS        DS    F                    ..Total records in file
X_CUSERS       DS    2F                   ..Company/division users
X_CMSGS        DS    2F                   ..Company/division msgs
               DS    0F                   Check_Open
CO_CODE        DS    F                    ..ABEND code
               DS    0F                   Read_BKLIDS_File
RBF_VS         DS    2F                   ..Notify
RBF_USERC      DS    F                    ..Number of users in table
               DS    0F                   Print_User_Records
PUR_$HASP165   DS    F                    ..Notify
PUR_$HASP549   DS    F                    ..Mail
PUR_DMTAXM104I DS    F                    ..VM
PUR_HUSERC     DS    F                    ..Highest user Count
PUR_HUSERN     DS    CL8                  ..Highest user Name
PUR_MCNT       DS    F                    ..Mail number
PUR_RA         DS    F                    ..Return address
               DS    0F                   Report_Dataset_Composition
RDC_UNK        DS    F                    ..UNKNOWN
RDC_T          DS    XL(C_RTABL)          ..Table
               DS    0F                   Read_Records
RR_RA          DS    F                    ..Return address
*                                         BrodCAST_Messages
BM_RRN         DS    XL3                  ..Relative record
BM_REC         DS    CL129                ..Record saved
*                                         Userid_Loop
UI_RRUI        DS    XL3                  ..Relative record
UI_REC         DS    CL129                ..Record saved
*
** File data areas
*
               DS    0D
BKLIDS         DS    XL(C_DCBIL)
BKLIDS_EXLST   DS    F
               DS    0D
SYSPRINT       DS    XL(C_DCBOL)
SYSPRINT_EXLST DS    F
               DS    0D
INDEX          DS    XL(C_DCBOL)
INDEX_EXLST    DS    F
               DS    0D
IEBUPDTE       DS    XL(C_DCBOL)
IEBUPDTE_EXLST DS    F
               DS    0D
STUFFED        DS    XL(C_DCBOL)
STUFFED_EXLST  DS    F
               DS    0D
MAIL           DS    XL(C_DCBOL)
MAIL_EXLST     DS    F
               DS    0D                   Brodcast (input)
BRODCAST       DS    XL(C_DCBFIL)         ..DCB
BRODCAST_EXLST DS    F                    ..Exit List
BRODCAST_DECB  DS    XL(C_DECBL)          ..DECB for random
BRODCAST_BLKN  DS    F                    ..Record number
*
FLAG_LIT       DS    C'FLAG'              Literal for dumps
FLAG1          DS    B'00000000'          Flag 1
$F1_OPENE      EQU   B'10000000'          ..Open file failed
$F1_IEBUPDTE   EQU   B'01000000'          ..Have a IEBUPDTE file?
               DS    0D
DSAL           EQU   *-DSA
 EJECT ,
***********************************************************************
***                                                                 ***
**       Internal DSECTs                                             **
***                                                                 ***
***********************************************************************
 SPACE 2
*
** BRODCAST dataset
*
BDS_HDR        DSECT ,                    HEADER
               DS    XL1                  ..FILLER
BDS_HDR_RRN    DS    XL3                  ..RELATIVE RECORD: NOTICES
               DS    XL1                  ..FILLER
BDS_HDR_RRUI   DS    XL3                  ..RELATIVE RECORD: UID INDEX
BDS_HDR_TBLKS  DS    F                    ..TOTAL BLOCKS IN DATASET
BDS_HDR_SL     EQU   *-BDS_HDR            ..Length to save
               DS    XL2
BDS_HDR_EYEC   DS    C' SYS1.BRODCAST DATA SET LEVEL 2'
*
BDS_BM         DSECT ,                    BRODCAST MESSAGE
BDS_BM_NUM     DS    XL2                  ..NUMBER
BDS_BM_RR      DS    XL3                  ..RELATIVE RECORD
BDS_BM_LEN     EQU   *-BDS_BM             ..LENGTH OF NOTICE ENTRY
*
BDS_UID        DSECT ,                    USERID
BDS_UID_NAME   DS    CL7                  ..NAME
BDS_UID_FIRST  DS    XL3                  ..RELATIVE RECORD: FIRST MSG
BDS_UID_LAST   DS    XL3                  ..RELATIVE RECORD: LAST MSG
BDS_UID_LEN    EQU   *-BDS_UID            ..LENGTH OF USERID ENTRY
*
BDS_MAIL       DSECT ,                    MAIL
BDS_MAIL_TEXTL DS    X                    ..LENGTH OF MSG TEXT
BDS_MAIL_TEXT  DS    CL125                ..LITERAL MESSAGE TEXT
BDS_MAIL_NEXT  DS    XL3                  ..RELATIVE RECORD: NEXT MAIL
*
** Record Table
*
RTAB       DSECT ,
RTAB_TYPE  DS    X
RTAB_COUNT DS    XL3
RTAB_TEXT  DS    CL20
RTABL      EQU   *-RTAB
*
** BKLIDS Table
*
BKL        DSECT ,
BKLH       EQU   *
BKLH_ID    DS    CL8'BKLIDST'
BKLHL      EQU   *-BKLH
*
BKLE       EQU   *
BKLE_USER  DS    XL(L'LIDLID)
BKLE_NAME  DS    XL(L'LIDNAME)
BKLE_PHONE DS    XL(L'LIDPHONE)
BKLEL      EQU   *-BKLE
         EJECT ,
***********************************************************************
***                                                                 ***
**       External DSECTs                                             **
***                                                                 ***
***********************************************************************
         SPACE 2
         PRINT NOGEN
         DCBD  DSORG=PS,DEVD=DA           ** DATA CONTROL BLOCK      **
         PRINT GEN
         IHADECB ,                        ** DATA EVENT CONTROL BLK  **
*
** If we have the ACF2 macro library use it, otherwise create our own
*
         AIF   (&ACF2).DSACF2             Do we have the ACF2 mac lib?
LIDREC   DSECT ,                          Our own simulated layout:
LIDLID   DS    CL8                        ..Userid
         DS    XL4                        ..Unused by us
LIDNAME  DS    CL20                       ..Programmer name
LIDPHONE DS    CL12                       ..Phone number
         AGO   .DSACF2X
.DSACF2  ANOP  ,
         LIDREC ,
.DSACF2X ANOP  ,
         END
./ ADD NAME=DA$COBR  0100-01266-01266-1821-01539-01539-00000-DAVE
DA$COBR  TITLE 'COBOL compile setting reporting'
***********************************************************************
***                                                                 ***
** Name: DA$COBR                                                     **
**                                                                   **
** Author: David Alcock :: dave@planetmvs.com                        **
**                                                                   **
**         Portions of this program were taken verbatim from:        **
**         - PGM=COMPILE written by Roland Schiradin (Systematics    **
**           Service GmbH, Hamburg Germany) - COBOL/370 & VS COBOL II**
**         - PGM=COBFMT written by Rex Widmer - taken from CBT file  **
**           200 - ANSI COBOL & OS/VS COBOL                          **
**                                                                   **
** Note: Roland kept updating his version and this has stagnated.    **
**       Look on http://www.cbttape.org/ for his latest analyzer.    **
**                                                                   **
** Written: 12 February 1997                                         **
**                                                                   **
** Attributes: Reentrant, Reusable, Non-Authorized                   **
**                                                                   **
** Purpose: This program loads a module and tries to report on the   **
**          settings as found in the module for compile options.     **
**                                                                   **
**  Non-IBM assembler MACROs:                                        **
**  o DA#COBOL...Mapping macro for the COBOL eyecatcher              **
**  o DA#ENTER...Entry housekeeping                                  **
**  o DA#LEAVE...Termination housekeeping                            **
**  o DA#EYEC....Build standard O/S module eyecatcher                **
**               (invoked by the DA#ENTER)                           **
**  o DA#REGS....Define registers (invoked by DA#ENTER)              **
**  o DA#SMODE...Change addressing mode (24 or 31)                   **
**  o STRING.....String handling routine - You need file 183 of the  **
**               CBT to assemble this program.                       **
*
* Disclaimer: This program is FREEWARE.  Use at your own risk.  It
*             is provided for your enjoyment and neither David
*             Alcock or his employer provides any warranty for it's
*             use.  I'd like to hear how it works on your system.
*
*             This software is not in the public domain but is
*             available free of charge and with source code
*             provided.  It is copyright 2001+ by David Alcock
*             All rights reserved.
**                                                                   **
***********************************************************************
         SPACE 2
&DAVER   SETC  '1.1'
***********************************************************************
***                                                                 ***
**           M o d i f i c a t i o n   H i s t o r y                 **
**                                                                   **
** Person     Date        Description                                **
** ---------- ----------- ------------------------------------------ **
** D Alcock   24-FEB-1997 V1.1 Made COBOL DSECTs an external macro for
**                        easy sharing;
** D Alcock   12-FEB-1997 V1.0 Took code from Roland Schiradin's
**                        COMPILE program:
**                        - Removed DB2 macro (not used in code);
**                        - Remove inline STRING macro, use most
**                          current one (maybe not really needed
**                          but why not be on latest one).
**                        - VERSION macro not available here,
**                          probably a only builds a module
**                          eyecatcher so it was commented out.
**                        - Storage macro gets buffer above the
**                          line, bad news for QSAM
**                        - Do a "STRING GENERATE" for this
**                          level of the STRING macro
**                        Incorporated some of the COBREAD/COBFMT
**                        code from CBT tape file #200 for ANSI and
**                        OS/VS COBOL analysis
***
***********************************************************************
         EJECT ,
***********************************************************************
***                                                                 ***
**       External DSECTs                                             **
***                                                                 ***
***********************************************************************
         SPACE 2
         PRINT NOGEN
         CVT DSECT=YES,LIST=NO            Commuications Vector Table
         DCBD  DSORG=PS,DEVD=DA           Data Control Block
         IKJCPPL ,                        IBM: Cmd Processor Parm List
         IHAPSA ,                         Prefixed Save Area
         IKJTCB DSECT=YES,LIST=NO         Task Control Block
         IEFTIOT1 ,                       Task Input/Output Table
         IKJIOPL ,                        Input/Output Parameter List
#IOPL    EQU   *-IOPL
         IEZBITS ,                        BIT0 - BIT7
         PRINT GEN
         DA#COBOL ,                       Map COBOL eyecatcher
         EJECT
***********************************************************************
***                                                                 ***
**       Entry housekeeping and initializations                      **
***                                                                 ***
***********************************************************************
         SPACE 2
         EJECT ,
DA$COBR  DA#ENTER 'V&DAVER Utility: COBOL program analysis',           @
               RENT=YES,                  Indicate we want GETMAIN     @
               LV=DSAL,                   Length of GETMAIN            @
               BASE=(12,11)               Obtain some base registers
         USING DSA,R13                    Addressability to work area
*        ST    R1,R1SAVE
         MVC   PGMNAME(8),=C'TEMPNAME'    Set default
         EJECT ,
***********************************************************************
***                                                                 ***
**       Process input parameters from CBUF or O/S parameter         **
**                                                                   **
** Note: We are expecting only a parm of the program name to         **
**       process.                                                    **
***                                                                 ***
***********************************************************************
         SPACE 2
PROCESS_PARAMETER EQU *
 TM    CPPLCBUF-CPPL(R1),X'80'            Was this command called?
 BNO   PP$NC                              No, need to look at CBUF
*
** We were called, it has a Batch type parameter list
*
 L     R2,0(R1)                           Get address of parm
 SLR   R3,R3                              Clear register
 ICM   R3,B'0011',0(R2)                   Get length of parm
 BZ    PP$X                               None, leave
 LA    R2,2(R2)                           Bump past parm length HW
 B     PP$PARSE                           Parse the input
*
** Invoked from the command line in TSO as a command processor
*
PP$NC EQU   *
 OI    X_FLAG1,$XF1_PL                    We need to do PUTLINEs
 LA    R15,79+4                           79 is width + PUTLINE header
 STH   R15,RECOUTH                        Save length
 MVC   PM_PBLK(C_PBLKL),C_PBLK            Initialize IOPL
 LA    R14,PM_IOPL                        Locate it
 MVC   IOPLUPT-IOPL(4,R14),CPPLUPT-CPPL(R1) Fill in UPT pointer
 MVC   IOPLECT-IOPL(4,R14),CPPLECT-CPPL(R1) Fill in ECT pointer
 LA    R15,PM_ECB                         Locate ECB
 ST    R15,IOPLECB-IOPL(R14)              Fill it in
*
 L     R2,CPPLCBUF-CPPL(R1)               Locate Command Buffer
 SLR   R3,R3                              Clear register
 ICM   R3,B'0011',0(R2)                   Get total CBUF length
 SLR   R0,R0                              Clear register
 ICM   R0,B'0011',2(R2)                   Get total Command name length
 LA    R15,4                              Length of header
 AR    R2,R15                             Bump past header
 SR    R3,R15                             Decrement for header length
 AR    R2,R0                              Bump past Command length
 SR    R3,R0                              Length of data
*
** Look thru command buffer/parameter for our commands
** Input: R2 - Address of command-buffer/Parameter
**        R3 - Length of command-buffer/Parameter
*
PP$PARSE EQU *
 LTR   R3,R3                              Check out length
 BZ    PP$X                               Length = Zero: Leave
 BM    PP$X                               Length < Zero: Leave
 BAS   R14,PP$UC                          Make input uppercase
*
** Copy the first parm to the program name
*
 LA    R15,PGMNAME                        Locate the program name (out)
 MVC   0(8,R15),BLANKS                    Pad with blanks
 LA    R14,8                              Length to consider
PP$PL DS 0H
 MVC   0(1,R15),0(R2)                     Get a byte
 LA    R15,1(R15)                         Bump to next output byte
 BCTR  R14,0                              Decrement length
 LTR   R14,R14                            Okay?
 BZ    PP$X                               No, hit the end...
 LA    R2,1(R2)                           Yes, bump to next input byte
 BCT   R3,PP$PL                           ..and try it out
*-Other parms could be gathered here or do multiple members
 B     PP$X
*
** Make input uppercase
** Input: R3 - Length (Do not modify this register!!)
**        R2 - Address (Do not modify this register!!)
*
PP$UC EQU *
 LR    R0,R3                              Get length of Data
 LR    R1,R2                              Get address of Data
PP$UCL EQU *
 OI    0(R1),C' '                         Make it upper case
 LA    R1,1(R1)                           Bump past it
 BCT   R0,PP$UCL                          ..do next byte
 BSM   0,R14                              Return to caller
*
** Common exit from Process_Parameter
*
PP$X EQU *
         EJECT
***********************************************************************
***                                                                 ***
**       Getting started                                             **
***                                                                 ***
***********************************************************************
         SPACE 2
         STRING 'COBOL module analysis is starting',INTO=RECOUT
         BAS   R14,PRINT_MSG              Print starting message
*
** Load the progamm
*
         LOAD  EPLOC=PGMNAME,ERRET=E$LOAD Load program
         ST    R0,ADR_PGMNAME             Save the address
         OI    X_FLAG1,$XF1_LOAD          Set that we loaded it
*
** Write load information to SYSPRINT
*
         STRING 'Program Name=',PGMNAME,                               @
               ' was loaded into storage at EPA=',(ADR_PGMNAME,,X),    @
               INTO=RECOUT
         BAS   R14,PRINT_BLINE_MSG
*
** Determine if the type of program is COBOL/370 or VS COBOL II
*
         DA#SMODE 31                      Get into 31 bit addr mode
         L     R4,ADR_PGMNAME             Get EPA of module
*
         CLC   CEE_EYECATCHER-COBOL_370_DSECT(4,R4),C_COBOL370
         BE    COBOL_370
         CLC   C2_EYECATCHER-COBOL_2_DSECT(4,R4),=CL4' C2 '
         BE    COBOL_2
         CLC   X'14'(4,R4),=CL4'ANS4'     ANSI (Ancient) COBOL?
         BE    COBOL_ANSI
         CLC   X'14'(4,R4),=CL4'VSR1'     OS/VS COBOL?
         BE    COBOL_OSVS                 Yes, got a live one
*
         STRING 'Can not established the program language',INTO=RECOUT
         BAS   R14,PRINT_MSG
         LA    R15,8                      Set the return code
         B     EXIT                       Leave
*
** Load of program failed, gripe about it and leave
*
E$LOAD DS 0H
         STRING 'Error during load of program=',PGMNAME,INTO=RECOUT
         BAS   R14,PRINT_MSG
         LA    R15,12
         EJECT
***********************************************************************
***                                                                 ***
**       Termination of program                                      **
***                                                                 ***
***********************************************************************
         SPACE 2
EXIT DS 0H
         LR    R2,R15                     Save return code
         DA#SMODE 24                      Get into 24 bit mode
*
** Delete the module
*
         TM    X_FLAG1,$XF1_LOAD          Did we load it?
         BNO   X$DELX
         DELETE EPLOC=PGMNAME             Delete from memory
X$DELX   DS    0H
*
** Print ending message
*
         STRING '============ Termination ===========================',*
               '=============================================',        @
               INTO=RECOUT
         BAS   R14,PRINT_BLINE_MSG
         STRING 'COBOL module analysis is Ending',INTO=RECOUT
         BAS   R14,PRINT_BLINE_MSG        Print ending message
*
** Close SYSPRINT (if open)
*
         TM    X_FLAG1,$XF1_SPO           SysPrint Open?
         BO    X$CLOSEX                   No, don't need close
         LA    R3,SYSPRINT                Locate DCB
         MVC   PARMLIST(C_CLSL),C_CLS     Move in CLOSE parameter list
         CLOSE ((3)),MF=(E,PARMLIST)      Close file
X$CLOSEX DS    0H
*
** Exit housekeeping
*
         LR    R15,R2                    Get return code
         DA#LEAVE RC=(15)                Return to caller
         EJECT
***********************************************************************
***                                                                 ***
**       Older COBOLs                                                **
***                                                                 ***
***********************************************************************
         SPACE 2
COBOL_ANSI DS 0H
         STRING '============ Info ==================================',*
               '=============================================',        @
               INTO=RECOUT
         BAS   R14,PRINT_BLINE_MSG
         STRING 'Program ',PGMNAME,' is ANSI COBOL',INTO=RECOUT
         BAS   R14,PRINT_BLINE_MSG
         B     COBOL_OLD
COBOL_OSVS DS 0H
         STRING '============ Info ==================================',*
               '=============================================',        @
               INTO=RECOUT
         BAS   R14,PRINT_BLINE_MSG
         STRING 'Program ',PGMNAME,' is OS/VS COBOL',INTO=RECOUT
         BAS   R14,PRINT_BLINE_MSG
         OI    X_FLAG1,$XF1_VS            Turn on flag
COBOL_OLD DS 0H
         L     R5,60(,R4)                 Get TGT pointer
*        ST    R5,TGTPTR                  SAVE FOR OTHER USAGE
*        ST    R4,INIT1PTR                SAVE FOR OTHER USAGE
         CLC   X'1BC'(8,R5),=CL8'SYSOUT  ' Check for good TGT
         BNE   NOTTGT                     Doesn't look good...
*
         MVC   RECOUT(79),BLANKS          Move in blanks
         LA    R15,RECOUT                 Locate output location
         MVC   0(8,R15),=C'Options:'      Insert text
         LA    R15,9(R15)                 Bump past text
*
*        SET FLAGS IN DETAIL PRINT LINE  -
*        BASED UPON THE SWITCH WORD IN THE TGT
*
*        SWITCH BIT MEANINGS - SOURCE COBOL COMPILER PLM
*         BYTE 1  BIT 0 MASK X'80'  USED BY ON SIZE ERROR
*         BYTE 1  BIT 1 MASK X'40'  USED BY READY TRACE VERB
*         BYTE 1  BIT 2 MASK X'20'  INITIALIZATION FLAG
*         BYTE 1  BIT 3 MASK X'10'  MAIN PROGRAM FLAG
*         BYTE 1  BIT 4 MASK X'08'  SYMDUMP FLAG
*         BYTE 1  BIT 5 MASK X'04'  FLOW FLAG
*         BYTE 1  BIT 6 MASK X'02'  STATE FLAG / REUSED AT RUN TIME
*         BYTE 1  BIT 7 MASK X'01'  OPTIMIZATION FLAG
*         BYTE 2  BIT 0 MASK X'80'  RESERVED
*         BYTE 2  BIT 1 MASK X'40'  USED BY CALL AND CANCEL
*         BYTE 2  BIT 2 MASK X'20'  EXEC TIME STATE FLAG
*         BYTE 2  BIT 3 MASK X'10'  TEST ATTRIBUTE FLAG
*         BYTE 2  BIT 4 MASK X'08'  QUOTE IS APOST FLAG
*         BYTE 2  BIT 5 MASK X'04'  SPECIAL SYMDUMP USAGE
*         BYTE 2  BIT 6 MASK X'02'  LONG TGT FLAG, ALWAYS 1 FOR V4 / VS
*         BYTE 2  BIT 7 MASK X'01'  Q-ROUTINE USAGE
*         BYTE 3  BIT 0 MASK X'80'  NORES FLAG, SET TO 0 FOR RES OPTION
*         BYTE 3  BIT 1 MASK X'40'  ENDJOB WAS SPECIFIED
*         BYTE 3  BIT 2 MASK X'20'  OBJECT COMPUTER 370 SPECIFIED
*         BYTE 3  BIT 3 MASK X'10'  Q-ROUTINE FLAG
*         BYTE 3  BIT 4 MASK X'08'  COUNT OPTION - VS
*         BYTE 3  BIT 5 MASK X'04'  TRACE VERB IS PRESENT
*         BYTE 3  BIT 6 MASK X'02'  SYNADAF USAGE
*         BYTE 3  BIT 7 MASK X'01'  UNUSED BIT
*         BYTE 4  DEC POINT IS COMMA BYTE
*                 C',' IF SPECIFIED, ELSE C'.'
         EJECT
         TM    X'48'(R5),X'08' IS IT SYMDUMP
         BZ    X01
         MVC   0(4,R15),=C'SYMD'
         LA    R15,5(R15)
X01      DS    0H
         SPACE 1
         TM    X'48'(R5),X'04' IS IT FLOW
         BZ    X02
         MVC   0(4,R15),=C'FLOW'
         LA    R15,5(R15)
X02      DS    0H
         SPACE 1
         TM    X'48'(R5),X'02' IS IT STATE
         BZ    X03
         MVC   0(5,R15),=C'STATE'
         LA    R15,6(R15)
X03      DS    0H
         SPACE 1
         TM    X'49'(R5),X'10' IS IT TEST
         BZ    X04
         MVC   0(4,R15),=C'TEST'
         LA    R15,5(R15)
X04      DS    0H
         SPACE 1
         TM    X'4A'(R5),X'80' IS IT RESIDENT
         BO    X05
         MVC   0(3,R15),=C'RES'
         LA    R15,4(R15)
X05      DS    0H
         SPACE 1
         TM    X'4A'(R5),X'40' IS IT ENDJOB
         BZ    X06
         MVC   0(6,R15),=C'ENDJOB'
         LA    R15,7(R15)
X06      DS    0H
         TM    X'4A'(R5),X'20' IS IT OBJECT 370
         BZ    X07
         MVC   0(6,R15),=C'OBJ370'
         LA    R15,7(R15)
X07      DS    0H
         SPACE 1
         TM    X'48'(R5),X'01' IS IT COBOL OPTIMISED
         BZ    X08
         MVC   0(6,R15),=C'COBOPT'
         LA    R15,7(R15)
X08      DS    0H
         CLC   X'48'(6,R4),=CL6'CAPEX'  IS IT CAPEX OPTIMISED ?
         BNE   CAPEXX
         MVC   0(5,R15),=C'CAPEX'
         LA    R15,6(R15)
CAPEXX   DS    0H
         TM    X_FLAG1,$XF1_VS     VS COBOL II?
         BNO   NOTVS
         TM    X'4A'(R5),X'08'     SEE IF COUNT WAS SPECIFIED
         BZ    X09                 NO COUNT OPTION
         MVC   0(5,R15),=C'COUNT'  PUT IT IN MSG
         LA    R15,6(R15)
X09      DS    0H
         TM    X'4A'(R5),X'04'     WAS TRACE VERB IN PGM
         BZ    X10                  NO, DO NOT FLAG IT ON LISTING
         MVC   0(5,R15),=C'TRACE'  PUT IT IN MSG
         LA    R15,6(R15)
NOTVS    DS    0H
X10      DS    0H
DONEFMT  DS    0H
         BAS   R14,PRINT_BLINE_MSG
         LA    R15,0
         NI    X_FLAG1,255-$XF1_VS
         B     EXIT
*
*        UNABLE TO FIND THE TASK GLOBAL TABLE  -
*
NOTTGT   DS    0H
         STRING 'Program ',PGMNAME,' failed the TGT (Task Global',     @
               'Table) test',INTO=RECOUT
         BAS   R14,PRINT_BLINE_MSG
         LA    R15,8
         NI    X_FLAG1,255-$XF1_VS
         B     EXIT
         EJECT
***********************************************************************
***                                                                 ***
**       COBOL/370 program                                           **
***                                                                 ***
***********************************************************************
         SPACE 2
COBOL_370 DS 0H
         USING COBOL_370_DSECT,R4
         MVI   LE_SWITCH,C'1'
         MVC   LE_VERS,CEE_VERS
         MVC   LE_REL,CEE_REL
         MVC   LE_MOD,CEE_MOD
         MVC   LE_PGM_NAME,CEE_PGM_NAME
         MVC   LE_COMP_DAY,CEE_COMP_DAY
         MVC   LE_COMP_MONTH,CEE_COMP_MONTH
         MVC   LE_COMP_YEAR,CEE_COMP_YEAR
         MVC   LE_COMP_HOURS,CEE_COMP_HOURS
         MVC   LE_COMP_MIN,CEE_COMP_MIN
         MVC   LE_COMP_SEC,CEE_COMP_SEC
         MVC   LE_DATA_STATEMENTS,CEE_DATA_STATEMENTS
         MVC   LE_PROC_LINES,CEE_PROC_LINES
         MVC   LE_STATUS_BYTE_01,CEE_STATUS_BYTE_01
         MVC   LE_STATUS_BYTE_02,CEE_STATUS_BYTE_02
         MVC   LE_STATUS_BYTE_03,CEE_STATUS_BYTE_03
         MVC   LE_STATUS_BYTE_04,CEE_STATUS_BYTE_04
         MVC   LE_STATUS_BYTE_05,CEE_STATUS_BYTE_05
         MVC   LE_STATUS_BYTE_06,CEE_STATUS_BYTE_06
         MVC   LE_STATUS_BYTE_07,CEE_STATUS_BYTE_07
         MVC   LE_STATUS_BYTE_08,CEE_STATUS_BYTE_08
         MVC   LE_STATUS_BYTE_09,CEE_STATUS_BYTE_09
         MVC   LE_STATUS_BYTE_10,CEE_STATUS_BYTE_10
         MVC   LE_STATUS_BYTE_11,CEE_STATUS_BYTE_11
         MVC   LE_STATUS_BYTE_12,CEE_STATUS_BYTE_12
         MVC   LE_STATUS_BYTE_13,CEE_STATUS_BYTE_13
         MVC   LE_STATUS_BYTE_14,CEE_STATUS_BYTE_14
         MVC   LE_STATUS_BYTE_15,CEE_STATUS_BYTE_15
         MVC   LE_STATUS_BYTE_16,CEE_STATUS_BYTE_16
         MVC   LE_STATUS_BYTE_17,CEE_STATUS_BYTE_17
         MVC   LE_STATUS_BYTE_18,CEE_STATUS_BYTE_18
         MVC   LE_STATUS_BYTE_19,CEE_STATUS_BYTE_19
         MVC   LE_STATUS_BYTE_20,CEE_STATUS_BYTE_20
         MVC   LE_STATUS_BYTE_21,CEE_STATUS_BYTE_21
         MVC   LE_STATUS_BYTE_22,CEE_STATUS_BYTE_22
         MVC   LE_STATUS_BYTE_23,CEE_STATUS_BYTE_23
         MVC   LE_STATUS_BYTE_24,CEE_STATUS_BYTE_24
         MVC   LE_STATUS_BYTE_25,CEE_STATUS_BYTE_25
         DROP  R4
         B     LE370_INFO
*============================================================*
*  VS COBOL II program                                       *
*============================================================*
COBOL_2 DS 0H
         USING COBOL_2_DSECT,R4
         MVI   LE_SWITCH,C'2'
         MVC   LE_VERS,C2_VERS
         MVC   LE_REL,C2_REL
         MVC   LE_MOD,C2_MOD
         MVC   LE_PGM_NAME,C2_PGM_NAME
         MVC   LE_COMP_DAY,C2_COMP_DAY
         MVC   LE_COMP_MONTH,C2_COMP_MONTH
         MVC   LE_COMP_YEAR,C2_COMP_YEAR
         MVC   LE_COMP_HOURS,C2_COMP_HOURS
         MVC   LE_COMP_MIN,C2_COMP_MIN
         MVC   LE_COMP_SEC,C2_COMP_SEC
         MVC   LE_DATA_STATEMENTS,C2_DATA_STATEMENTS
         MVC   LE_PROC_LINES,C2_PROC_LINES
         MVC   LE_STATUS_BYTE_01,C2_STATUS_BYTE_01
         MVC   LE_STATUS_BYTE_02,C2_STATUS_BYTE_02
         MVC   LE_STATUS_BYTE_03,C2_STATUS_BYTE_03
         MVC   LE_STATUS_BYTE_04,C2_STATUS_BYTE_04
         MVC   LE_STATUS_BYTE_05,C2_STATUS_BYTE_05
         MVC   LE_STATUS_BYTE_06,C2_STATUS_BYTE_06
         MVC   LE_STATUS_BYTE_07,C2_STATUS_BYTE_07
         MVC   LE_STATUS_BYTE_08,C2_STATUS_BYTE_08
         MVC   LE_STATUS_BYTE_09,C2_STATUS_BYTE_09
         MVC   LE_STATUS_BYTE_10,C2_STATUS_BYTE_10
         MVC   LE_STATUS_BYTE_11,C2_STATUS_BYTE_11
         MVC   LE_STATUS_BYTE_12,C2_STATUS_BYTE_12
         MVC   LE_STATUS_BYTE_13,C2_STATUS_BYTE_13
         MVC   LE_STATUS_BYTE_14,C2_STATUS_BYTE_14
         MVC   LE_STATUS_BYTE_15,C2_STATUS_BYTE_15
         MVC   LE_STATUS_BYTE_16,C2_STATUS_BYTE_16
         MVC   LE_STATUS_BYTE_17,C2_STATUS_BYTE_17
         MVC   LE_STATUS_BYTE_18,C2_STATUS_BYTE_18
         MVC   LE_STATUS_BYTE_19,C2_STATUS_BYTE_19
         MVC   LE_STATUS_BYTE_20,C2_STATUS_BYTE_20
         MVC   LE_STATUS_BYTE_21,C2_STATUS_BYTE_21
         MVC   LE_STATUS_BYTE_22,C2_STATUS_BYTE_22
         MVC   LE_STATUS_BYTE_23,C2_STATUS_BYTE_23
         MVC   LE_STATUS_BYTE_24,C2_STATUS_BYTE_24
         MVC   LE_STATUS_BYTE_25,C2_STATUS_BYTE_25
         DROP  R4
         B     LE370_INFO
LE370_INFO DS  0H
         STRING '============ Info ==================================',*
               '=============================================',        @
               INTO=RECOUT
         BAS   R14,PRINT_BLINE_MSG
         STRING 'Program ',PGMNAME,' is COBOL/370 Version ',LE_VERS,   @
               ' Release ',LE_REL,' Mod-Level ',LE_MOD,INTO=RECOUT
         CLI   LE_SWITCH,C'1'
         BE    JUMP_AROUND
         STRING 'Program ',PGMNAME,' is VS COBOL II Version ',LE_VERS, @
               ' Release ',LE_REL,' Mod-Level ',LE_MOD,INTO=RECOUT
JUMP_AROUND DS 0H
         BAS   R14,PRINT_BLINE_MSG
         STRING '============ Timestamps ============================',*
               '=============================================',        @
               INTO=RECOUT
         BAS   R14,PRINT_BLINE_MSG
         STRING 'Compiled program name ',LE_PGM_NAME,INTO=RECOUT
         BAS   R14,PRINT_MSG
         STRING 'Date: ',LE_COMP_DAY,'.',LE_COMP_MONTH,'.',            *
               LE_COMP_YEAR,' Time: ',LE_COMP_HOURS,':',LE_COMP_MIN,   *
               ':',LE_COMP_SEC,INTO=RECOUT
         BAS   R14,PRINT_BLINE_MSG
         STRING '============ Statistics ============================',*
               '=============================================',        @
               INTO=RECOUT
         BAS   R14,PRINT_BLINE_MSG
         STRING 'Number of data items  : ',(LE_DATA_STATEMENTS,F,R7B), *
               INTO=RECOUT
         BAS   R14,PRINT_MSG
         STRING 'Number of instructions: ',(LE_PROC_LINES,F,R7B),      *
               INTO=RECOUT
         BAS   R14,PRINT_BLINE_MSG
         STRING '============ Options in effect =====================',*
               '=============================================',        @
               INTO=RECOUT
         BAS   R14,PRINT_BLINE_MSG
         MVC   RECOUT,BLANKS
         MVC   RECOUT+1(6),=CL6'ADV'
         TM    LE_STATUS_BYTE_01,ADV
         BO    LE_370_01
         MVC   RECOUT+1(6),=CL6'NOADV'
LE_370_01 DS 0H
         MVC   RECOUT+8(6),=CL6'APOST'
         TM    LE_STATUS_BYTE_01,APOST
         BO    LE_370_02
         MVC   RECOUT+8(6),=CL6'QUOTE'
LE_370_02 DS 0H
         MVC   RECOUT+16(9),=CL9'DATA(31)'
         TM    LE_STATUS_BYTE_01,DATA31
         BO    LE_370_03
         MVC   RECOUT+16(9),=CL9'DATA(24)'
LE_370_03 DS 0H
         MVC   RECOUT+25(6),=CL6'DECK'
         TM    LE_STATUS_BYTE_01,DECK
         BO    LE_370_04
         MVC   RECOUT+25(6),=CL6'NODECK'
LE_370_04 DS 0H
         MVC   RECOUT+33(6),=CL6'DUMP'
         TM    LE_STATUS_BYTE_01,DUMP
         BO    LE_370_05
         MVC   RECOUT+33(6),=CL6'NODUMP'
LE_370_05 DS 0H
         MVC   RECOUT+40(8),=CL8'DYNAM'
         TM    LE_STATUS_BYTE_01,DYNAM
         BO    LE_370_06
         MVC   RECOUT+40(8),=CL8'NODYNAM'
LE_370_06 DS 0H
         MVC   RECOUT+51(10),=CL10'FASTSRT'
         TM    LE_STATUS_BYTE_01,FASTSRT
         BO    LE_370_07
         MVC   RECOUT+51(10),=CL10'NOFASTSRT'
LE_370_07 DS 0H
         MVC   RECOUT+62(8),=CL8'FDUMP'
         TM    LE_STATUS_BYTE_01,FDUMP
         BO    LE_370_08
         MVC   RECOUT+62(8),=CL8'NOFDUMP'
LE_370_08 DS 0H
         BAS   R14,PRINT_MSG
         MVC   RECOUT,BLANKS
         MVC   RECOUT+1(6),=CL6'LIB'
         TM    LE_STATUS_BYTE_02,LIB
         BO    LE_370_11
         MVC   RECOUT+1(6),=CL6'NOLIB'
LE_370_11 DS 0H
         MVC   RECOUT+8(7),=CL7'LIST'
         TM    LE_STATUS_BYTE_02,LIST
         BO    LE_370_12
         MVC   RECOUT+8(7),=CL7'NOLIST'
LE_370_12 DS 0H
         MVC   RECOUT+16(9),=CL9'MAP'
         TM    LE_STATUS_BYTE_02,MAP
         BO    LE_370_13
         MVC   RECOUT+16(9),=CL9'NOMAP'
LE_370_13 DS 0H
         MVC   RECOUT+25(6),=CL6'NUM'
         TM    LE_STATUS_BYTE_02,NUM
         BO    LE_370_14
         MVC   RECOUT+25(6),=CL6'NONUM'
LE_370_14 DS 0H
         MVC   RECOUT+33(6),=CL6'OBJ'
         TM    LE_STATUS_BYTE_02,OBJ
         BO    LE_370_15
         MVC   RECOUT+33(6),=CL6'NOOBJ'
LE_370_15 DS 0H
         MVC   RECOUT+40(8),=CL8'OFFSET'
         TM    LE_STATUS_BYTE_02,OFFSET
         BO    LE_370_16
         MVC   RECOUT+40(8),=CL8'NOOFFSET'
LE_370_16 DS 0H
         MVC   RECOUT+51(10),=CL10'OPTIMIZE'
         TM    LE_STATUS_BYTE_02,OPTIMIZE
         BO    LE_370_17
         MVC   RECOUT+51(10),=CL10'NOOPTIMIZE'
LE_370_17 DS 0H
         MVC   RECOUT+62(17),=CL17'DDNAME(no default)'
         TM    LE_STATUS_BYTE_02,DDNAME
         BO    LE_370_18
         MVC   RECOUT+62(17),=CL17'DDNAME(default)'
LE_370_18 DS 0H
         BAS   R14,PRINT_MSG
         MVC   RECOUT,BLANKS
         MVC   RECOUT+1(15),=CL15'NUMPROC(MIG)'
         TM    LE_STATUS_BYTE_05,NUMPROCM
         BO    LE_370_21
LE_370_21A DS 0H
         MVC   RECOUT+1(15),=CL15'NUMPROC(PFD)'
         TM    LE_STATUS_BYTE_03,NUMPROC
         BO    LE_370_21
         MVC   RECOUT+1(15),=CL15'NUMPROC(NOPFD)'
LE_370_21 DS 0H
         MVC   RECOUT+16(7),=CL7'RENT'
         TM    LE_STATUS_BYTE_03,RENT
         BO    LE_370_22
         MVC   RECOUT+16(7),=CL7'NORENT'
LE_370_22 DS 0H
         MVC   RECOUT+25(6),=CL6'RES'
         TM    LE_STATUS_BYTE_03,RES
         BO    LE_370_23
         MVC   RECOUT+25(6),=CL6'NORES'
LE_370_23 DS 0H
         MVC   RECOUT+33(6),=CL6'SEQ'
         TM    LE_STATUS_BYTE_03,SEQUENCE
         BO    LE_370_24
         MVC   RECOUT+33(6),=CL6'NOSEQ'
LE_370_24 DS 0H
         MVC   RECOUT+40(12),=CL12'SIZE(MAX)'
         TM    LE_STATUS_BYTE_03,SIZE
         BO    LE_370_25
         MVC   RECOUT+40(12),=CL12'SIZE(value)'
LE_370_25 DS 0H
         MVC   RECOUT+51(9),=CL9'SOURCE'
         TM    LE_STATUS_BYTE_03,SOURCE
         BO    LE_370_26
         MVC   RECOUT+51(9),=CL9'NOSOURCE'
LE_370_26 DS 0H
         MVC   RECOUT+62(10),=CL10'SSRANGE'
         TM    LE_STATUS_BYTE_03,SSRANGE
         BO    LE_370_27
         MVC   RECOUT+62(10),=CL10'NOSSRANGE'
LE_370_27 DS 0H
         MVC   RECOUT+72(8),=CL8'TERM'
         TM    LE_STATUS_BYTE_03,TERM
         BO    LE_370_28
         MVC   RECOUT+72(8),=CL8'NOTERM'
LE_370_28 DS 0H
         BAS   R14,PRINT_MSG
         MVC   RECOUT,BLANKS
         MVC   RECOUT+1(8),=CL8'TEST'
         TM    LE_STATUS_BYTE_04,TEST
         BO    LE_370_31
         MVC   RECOUT+1(8),=CL8'NOTEST'
LE_370_31 DS 0H
         MVC   RECOUT+8(10),=CL11'TRUNC(BIN)'
         TM    LE_STATUS_BYTE_05,TRUNCB
         BO    LE_370_33
         MVC   RECOUT+8(10),=CL11'TRUNC(STD)'
         TM    LE_STATUS_BYTE_04,TRUNC
         BO    LE_370_33
         MVC   RECOUT+8(10),=CL11'TRUNC(OPT)'
LE_370_33 DS 0H
         MVC   RECOUT+25(8),=CL8'VBREF'
         TM    LE_STATUS_BYTE_04,VBREF
         BO    LE_370_34
         MVC   RECOUT+25(8),=CL8'NOVBREF'
LE_370_34 DS 0H
         MVC   RECOUT+33(6),=CL6'XREF'
         TM    LE_STATUS_BYTE_04,XREF
         BO    LE_370_35
         MVC   RECOUT+33(6),=CL6'NOXREF'
LE_370_35 DS 0H
         MVC   RECOUT+40(6),=CL6'ZWB'
         TM    LE_STATUS_BYTE_04,ZWB
         BO    LE_370_36
         MVC   RECOUT+40(6),=CL6'NOZWB'
LE_370_36 DS 0H
         MVC   RECOUT+51(7),=CL7'NAME'
         TM    LE_STATUS_BYTE_04,NAME
         BO    LE_370_37
         MVC   RECOUT+51(7),=CL7'NONAME'
LE_370_37 DS 0H
         MVC   RECOUT+62(8),=CL8'CMPR2'
         TM    LE_STATUS_BYTE_04,CMPR2
         BO    LE_370_38
         MVC   RECOUT+62(8),=CL8'NOCMPR2'
LE_370_38 DS 0H
         BAS   R14,PRINT_MSG
         MVC   RECOUT,BLANKS
         MVC   RECOUT+1(11),=CL11'NUMCLASS'
         TM    LE_STATUS_BYTE_05,NUMCLASS
         BO    LE_370_41
         MVC   RECOUT+1(11),=CL11'NONUMCLASS'
LE_370_41 DS 0H
         CLI   LE_SWITCH,C'1'   COBOL/370
         BE    LE_370_42
         MVC   RECOUT+1(11),=CL11'NUMCLS'
         TM    LE_STATUS_BYTE_05,NUMCLASS
         BO    LE_370_42
         MVC   RECOUT+1(11),=CL11'NONCLS'
LE_370_42 DS 0H
         MVC   RECOUT+16(7),=CL7'DBCS'
         TM    LE_STATUS_BYTE_05,DBCS
         BO    LE_370_43
         MVC   RECOUT+16(7),=CL7'NODBCS'
LE_370_43 DS 0H
         MVC   RECOUT+25(6),=CL6'AWO'
         TM    LE_STATUS_BYTE_05,AWO
         BO    LE_370_45
         MVC   RECOUT+25(6),=CL6'NOAWO'
LE_370_45 DS 0H
         CLI   LE_SWITCH,C'1'                  Cobol/370
         BNE   LE_370_48                       no, jump around
         MVC   RECOUT+33(9),=CL9'EVENTS'       n/a COBOL/2
         TM    LE_STATUS_BYTE_05,EVENTS
         BO    LE_370_46
         MVC   RECOUT+33(9),=CL9'NOEVENTS'
LE_370_46 DS 0H
         MVC   RECOUT+40(11),=CL11'CURRENCY'   n/a COBOL/2
         TM    LE_STATUS_BYTE_05,CURRENCY
         BO    LE_370_48
         MVC   RECOUT+40(11),=CL11'NOCURRENCY'
LE_370_48 DS 0H
         BAS   R14,PRINT_MSG
         MVC   RECOUT,BLANKS
         MVC   RECOUT+1(40),=CL40'User supplied reserved word list'
         TM    LE_STATUS_BYTE_04,USERW
         BO    LE_370_49
  MVC   RECOUT+1(40),=CL40'Installation default reserved word list'
LE_370_49 DS 0H
         BAS   R14,PRINT_BLINE_MSG
         STRING '============ Additional information ================',*
               '=============================================',        @
               INTO=RECOUT
         BAS   R14,PRINT_MSG
         STRING '============ about DATA DIVISION    ================',*
               '=============================================',        @
               INTO=RECOUT
         BAS   R14,PRINT_BLINE_MSG
         STRING 'Program use no QSAM or SAM access method',INTO=RECOUT
         TM    LE_STATUS_BYTE_06,BIT0
         BNO   LE_370_51
         STRING 'Program use QSAM or SAM access',INTO=RECOUT
LE_370_51 DS 0H
         BAS   R14,PRINT_MSG
         STRING 'Program use no VSAM sequential files',INTO=RECOUT
         TM    LE_STATUS_BYTE_06,BIT1
         BNO   LE_370_52
         STRING 'Program use VSAM sequential files',INTO=RECOUT
LE_370_52 DS 0H
         BAS   R14,PRINT_MSG
         STRING 'Program use no VSAM indexed files',INTO=RECOUT
         TM    LE_STATUS_BYTE_06,BIT2
         BNO   LE_370_53
         STRING 'Program use VSAM indexed files',INTO=RECOUT
LE_370_53 DS 0H
         BAS   R14,PRINT_MSG
         STRING 'Program use no VSAM rba files',INTO=RECOUT
         TM    LE_STATUS_BYTE_06,BIT3
         BNO   LE_370_54
         STRING 'Program use VSAM rba files',INTO=RECOUT
LE_370_54 DS 0H
         BAS   R14,PRINT_MSG
         STRING 'Program use no CODE-SET (ASCII files)',INTO=RECOUT
         TM    LE_STATUS_BYTE_06,BIT4
         BNO   LE_370_55
         STRING 'Program use CODE-SET (ASCII files)',INTO=RECOUT
LE_370_55 DS 0H
         BAS   R14,PRINT_MSG
         STRING 'Program use no spanned records',INTO=RECOUT
         TM    LE_STATUS_BYTE_06,BIT5
         BNO   LE_370_56
         STRING 'Program use spanned receords',INTO=RECOUT
LE_370_56 DS 0H
         BAS   R14,PRINT_MSG
         STRING 'Program has no picture G (DBCS) items',INTO=RECOUT
         TM    LE_STATUS_BYTE_06,BIT6
         BNO   LE_370_57
         STRING 'Program has picture G (DBCS) items',INTO=RECOUT
LE_370_57 DS 0H
         BAS   R14,PRINT_MSG
         STRING 'Program has no OCCURS DEPENDING ON items',INTO=RECOUT
         TM    LE_STATUS_BYTE_06,BIT7
         BNO   LE_370_58
         STRING 'Program has OCCURS DEPENDING ON items',INTO=RECOUT
LE_370_58 DS 0H
         BAS   R14,PRINT_MSG
         STRING 'Program has no SYNCHRONIZED clause',INTO=RECOUT
         TM    LE_STATUS_BYTE_07,BIT0
         BNO   LE_370_59
         STRING 'Program has SYNCHRONIZED clause',INTO=RECOUT
LE_370_59 DS 0H
         BAS   R14,PRINT_MSG
         STRING 'Program has no JUSTIFIED clause',INTO=RECOUT
         TM    LE_STATUS_BYTE_07,BIT1
         BNO   LE_370_60
         STRING 'Program has JUSTIFIED clause',INTO=RECOUT
LE_370_60 DS 0H
         BAS   R14,PRINT_MSG
         STRING 'Program has no POINTER items',INTO=RECOUT
         TM    LE_STATUS_BYTE_07,BIT2
         BNO   LE_370_61
         STRING 'Program has POINTER items',INTO=RECOUT
LE_370_61 DS 0H
         BAS   R14,PRINT_MSG
         STRING 'Program has no complex ODO clause',INTO=RECOUT
         TM    LE_STATUS_BYTE_07,BIT3
         BNO   LE_370_62
         STRING 'Program has complex ODO clause',INTO=RECOUT
LE_370_62 DS 0H
         BAS   R14,PRINT_MSG
         STRING 'Program has no external floating-point items',        @
               INTO=RECOUT
         TM    LE_STATUS_BYTE_07,BIT4
         BNO   LE_370_63
         STRING 'Program has external floating-point items',INTO=RECOUT
LE_370_63 DS 0H
         CLI   LE_SWITCH,C'1'                  Cobol/370
         BNE   LE_370_64                       no, jump around
         BAS   R14,PRINT_MSG
         STRING 'Program has no procedure-pointer items',INTO=RECOUT
         TM    LE_STATUS_BYTE_07,BIT6          n/a cobol/2
         BNO   LE_370_64
         STRING 'Program has procedure-pointer items',INTO=RECOUT
LE_370_64 DS 0H
         BAS   R14,PRINT_BLINE_MSG
         STRING '============ Additional information    =============',*
               '=============================================',        @
               INTO=RECOUT
         BAS   R14,PRINT_MSG
         STRING '============ about ENVIROMENT DIVISION =============',*
               '=============================================',        @
               INTO=RECOUT
         BAS   R14,PRINT_BLINE_MSG
         STRING 'Program use no FILE-STATUS clause',INTO=RECOUT
         TM    LE_STATUS_BYTE_08,BIT0
         BNO   LE_370_66
         STRING 'Program use FILE-STATUS clause',INTO=RECOUT
LE_370_66 DS 0H
         BAS   R14,PRINT_MSG
         STRING 'Program use no RERUN clause in I/O-control',          @
               INTO=RECOUT
         TM    LE_STATUS_BYTE_08,BIT1
         BNO   LE_370_67
         STRING 'Program has RERUN clause in I/O-control',INTO=RECOUT
LE_370_67 DS 0H
         BAS   R14,PRINT_MSG
         STRING 'Program use no UPSI switches',INTO=RECOUT
         TM    LE_STATUS_BYTE_08,BIT2
         BNO   LE_370_68
         STRING 'Program use UPSI switches',INTO=RECOUT
LE_370_68 DS 0H
         BAS   R14,PRINT_BLINE_MSG
         STRING '============ Additional information    =============',*
               '=============================================',        @
               INTO=RECOUT
         BAS   R14,PRINT_MSG
         STRING '============ about PROCEDURE DIVISION  =============',*
               '=============================================',        @
               INTO=RECOUT
         BAS   R14,PRINT_BLINE_MSG
         STRING 'Following statements in control (check Y/N):',        @
               INTO=RECOUT
         BAS   R14,PRINT_MSG
         MVC   RECOUT,BLANKS
         MVC   RECOUT+1(6),=CL6'Accept'
         MVI   RECOUT+15,C'N'
         TM    LE_STATUS_BYTE_09,BIT0
         BNO   LE_370_69
         MVI   RECOUT+15,C'Y'
LE_370_69 DS 0H
         MVC   RECOUT+18(3),=CL3'Add'
         MVI   RECOUT+32,C'N'
         TM    LE_STATUS_BYTE_09,BIT1
         BNO   LE_370_70
         MVI   RECOUT+32,C'Y'
LE_370_70 DS 0H
         MVC   RECOUT+35(5),=CL5'Alter'
         MVI   RECOUT+49,C'N'
         TM    LE_STATUS_BYTE_09,BIT2
         BNO   LE_370_71
         MVI   RECOUT+49,C'Y'
LE_370_71 DS 0H
         MVC   RECOUT+52(4),=CL4'Call'
         MVI   RECOUT+66,C'N'
         TM    LE_STATUS_BYTE_09,BIT3
         BNO   LE_370_72
         MVI   RECOUT+66,C'Y'
LE_370_72 DS 0H
         MVC   RECOUT+69(6),=CL6'Cancel'
         MVI   RECOUT+83,C'N'
         TM    LE_STATUS_BYTE_09,BIT4
         BNO   LE_370_73
         MVI   RECOUT+83,C'Y'
LE_370_73 DS 0H
         MVC   RECOUT+86(5),=CL5'CLose'
         MVI   RECOUT+100,C'N'
         TM    LE_STATUS_BYTE_09,BIT7
         BNO   LE_370_74
         MVI   RECOUT+100,C'Y'
LE_370_74 DS 0H
         BAS   R14,PRINT_MSG
         MVC   RECOUT,BLANKS
         MVC   RECOUT+1(7),=CL7'Compute'
         MVI   RECOUT+15,C'N'
         TM    LE_STATUS_BYTE_10,BIT0
         BNO   LE_370_75
         MVI   RECOUT+15,C'Y'
LE_370_75 DS 0H
         MVC   RECOUT+18(6),=CL6'Delete'
         MVI   RECOUT+32,C'N'
         TM    LE_STATUS_BYTE_10,BIT2
         BNO   LE_370_76
         MVI   RECOUT+32,C'Y'
LE_370_76 DS 0H
         MVC   RECOUT+35(7),=CL7'Display'
         MVI   RECOUT+49,C'N'
         TM    LE_STATUS_BYTE_10,BIT4
         BNO   LE_370_77
         MVI   RECOUT+49,C'Y'
LE_370_77 DS 0H
         MVC   RECOUT+52(6),=CL6'Divide'
         MVI   RECOUT+66,C'N'
         TM    LE_STATUS_BYTE_10,BIT5
         BNO   LE_370_78
         MVI   RECOUT+66,C'Y'
LE_370_78 DS 0H
         MVC   RECOUT+69(11),=CL11'End-Perform'
         MVI   RECOUT+83,C'N'
         TM    LE_STATUS_BYTE_11,BIT1
         BNO   LE_370_79
         MVI   RECOUT+83,C'Y'
LE_370_79 DS 0H
         MVC   RECOUT+86(5),=CL5'Enter'
         MVI   RECOUT+100,C'N'
         TM    LE_STATUS_BYTE_11,BIT2
         BNO   LE_370_80
         MVI   RECOUT+100,C'Y'
LE_370_80 DS 0H
         BAS   R14,PRINT_MSG
         MVC   RECOUT,BLANKS
         MVC   RECOUT+1(5),=CL5'Entry'
         MVI   RECOUT+15,C'N'
         TM    LE_STATUS_BYTE_11,BIT3
         BNO   LE_370_81
         MVI   RECOUT+15,C'Y'
LE_370_81 DS 0H
         MVC   RECOUT+18(4),=CL4'Exit'
         MVI   RECOUT+32,C'N'
         TM    LE_STATUS_BYTE_11,BIT4
         BNO   LE_370_82
         MVI   RECOUT+32,C'Y'
LE_370_82 DS 0H
         MVC   RECOUT+35(5),=CL5'Go to'
         MVI   RECOUT+49,C'N'
         TM    LE_STATUS_BYTE_11,BIT6
         BNO   LE_370_83
         MVI   RECOUT+49,C'Y'
LE_370_83 DS 0H
         MVC   RECOUT+52(2),=CL2'If'
         MVI   RECOUT+66,C'N'
         TM    LE_STATUS_BYTE_11,BIT7
         BNO   LE_370_84
         MVI   RECOUT+66,C'Y'
LE_370_84 DS 0H
         MVC   RECOUT+69(10),=CL10'Initialize'
         MVI   RECOUT+83,C'N'
         TM    LE_STATUS_BYTE_12,BIT0
         BNO   LE_370_85
         MVI   RECOUT+83,C'Y'
LE_370_85 DS 0H
         MVC   RECOUT+86(7),=CL7'Inspect'
         MVI   RECOUT+100,C'N'
         TM    LE_STATUS_BYTE_12,BIT2
         BNO   LE_370_86
         MVI   RECOUT+100,C'Y'
LE_370_86 DS 0H
         BAS   R14,PRINT_MSG
         MVC   RECOUT,BLANKS
         MVC   RECOUT+1(5),=CL5'Merge'
         MVI   RECOUT+15,C'N'
         TM    LE_STATUS_BYTE_12,BIT3
         BNO   LE_370_88
         MVI   RECOUT+15,C'Y'
LE_370_88 DS 0H
         MVC   RECOUT+18(4),=CL4'Move'
         MVI   RECOUT+32,C'N'
         TM    LE_STATUS_BYTE_12,BIT4
         BNO   LE_370_89
         MVI   RECOUT+32,C'Y'
LE_370_89 DS 0H
         MVC   RECOUT+35(8),=CL8'Multiply'
         MVI   RECOUT+49,C'N'
         TM    LE_STATUS_BYTE_12,BIT5
         BNO   LE_370_90
         MVI   RECOUT+49,C'Y'
LE_370_90 DS 0H
         MVC   RECOUT+52(4),=CL4'Open'
         MVI   RECOUT+66,C'N'
         TM    LE_STATUS_BYTE_12,BIT6
         BNO   LE_370_91
         MVI   RECOUT+66,C'Y'
LE_370_91 DS 0H
         MVC   RECOUT+69(7),=CL7'Perform'
         MVI   RECOUT+83,C'N'
         TM    LE_STATUS_BYTE_12,BIT7
         BNO   LE_370_92
         MVI   RECOUT+83,C'Y'
LE_370_92 DS 0H
         MVC   RECOUT+86(4),=CL4'Read'
         MVI   RECOUT+100,C'N'
         TM    LE_STATUS_BYTE_13,BIT0
         BNO   LE_370_93
         MVI   RECOUT+100,C'Y'
LE_370_93 DS 0H
         BAS   R14,PRINT_MSG
         MVC   RECOUT,BLANKS
         MVC   RECOUT+1(7),=CL7'Release'
         MVI   RECOUT+15,C'N'
         TM    LE_STATUS_BYTE_13,BIT2
         BNO   LE_370_94
         MVI   RECOUT+15,C'Y'
LE_370_94 DS 0H
         MVC   RECOUT+18(6),=CL6'Return'
         MVI   RECOUT+32,C'N'
         TM    LE_STATUS_BYTE_13,BIT3
         BNO   LE_370_95
         MVI   RECOUT+32,C'Y'
LE_370_95 DS 0H
         MVC   RECOUT+35(7),=CL7'Rewrite'
         MVI   RECOUT+49,C'N'
         TM    LE_STATUS_BYTE_13,BIT4
         BNO   LE_370_96
         MVI   RECOUT+49,C'Y'
LE_370_96 DS 0H
         MVC   RECOUT+52(6),=CL6'Search'
         MVI   RECOUT+66,C'N'
         TM    LE_STATUS_BYTE_13,BIT5
         BNO   LE_370_97
         MVI   RECOUT+66,C'Y'
LE_370_97 DS 0H
         MVC   RECOUT+69(3),=CL3'Set'
         MVI   RECOUT+83,C'N'
         TM    LE_STATUS_BYTE_13,BIT7
         BNO   LE_370_98
         MVI   RECOUT+83,C'Y'
LE_370_98 DS 0H
         MVC   RECOUT+86(4),=CL4'Sort'
         MVI   RECOUT+100,C'N'
         TM    LE_STATUS_BYTE_14,BIT0
         BNO   LE_370_99
         MVI   RECOUT+100,C'Y'
LE_370_99 DS 0H
         BAS   R14,PRINT_MSG
         MVC   RECOUT,BLANKS
         MVC   RECOUT+1(5),=CL5'Start'
         MVI   RECOUT+15,C'N'
         TM    LE_STATUS_BYTE_14,BIT1
         BNO   LE_370_100
         MVI   RECOUT+15,C'Y'
LE_370_100 DS 0H
         MVC   RECOUT+18(4),=CL4'Stop'
         MVI   RECOUT+32,C'N'
         TM    LE_STATUS_BYTE_14,BIT2
         BNO   LE_370_101
         MVI   RECOUT+32,C'Y'
LE_370_101 DS 0H
         MVC   RECOUT+35(6),=CL6'String'
         MVI   RECOUT+49,C'N'
         TM    LE_STATUS_BYTE_14,BIT3
         BNO   LE_370_102
         MVI   RECOUT+49,C'Y'
LE_370_102 DS 0H
         MVC   RECOUT+52(4),=CL4'Subtract'
         MVI   RECOUT+66,C'N'
         TM    LE_STATUS_BYTE_14,BIT4
         BNO   LE_370_103
         MVI   RECOUT+66,C'Y'
LE_370_103 DS 0H
         MVC   RECOUT+69(8),=CL8'Unstring'
         MVI   RECOUT+83,C'N'
         TM    LE_STATUS_BYTE_14,BIT7
         BNO   LE_370_104
         MVI   RECOUT+83,C'Y'
LE_370_104 DS 0H
         MVC   RECOUT+86(3),=CL3'Use'
         MVI   RECOUT+100,C'N'
         TM    LE_STATUS_BYTE_15,BIT0
         BNO   LE_370_105
         MVI   RECOUT+100,C'Y'
LE_370_105 DS 0H
         BAS   R14,PRINT_MSG
         MVC   RECOUT,BLANKS
         MVC   RECOUT+1(5),=CL5'Write'
         MVI   RECOUT+15,C'N'
         TM    LE_STATUS_BYTE_15,BIT1
         BNO   LE_370_106
         MVI   RECOUT+15,C'Y'
LE_370_106 DS 0H
         MVC   RECOUT+18(4),=CL4'Continue'
         MVI   RECOUT+32,C'N'
         TM    LE_STATUS_BYTE_15,BIT2
         BNO   LE_370_107
         MVI   RECOUT+32,C'Y'
LE_370_107 DS 0H
         MVC   RECOUT+35(7),=CL7'End-Add'
         MVI   RECOUT+49,C'N'
         TM    LE_STATUS_BYTE_15,BIT3
         BNO   LE_370_108
         MVI   RECOUT+49,C'Y'
LE_370_108 DS 0H
         MVC   RECOUT+52(7),=CL7'End-Call'
         MVI   RECOUT+66,C'N'
         TM    LE_STATUS_BYTE_15,BIT4
         BNO   LE_370_109
         MVI   RECOUT+66,C'Y'
LE_370_109 DS 0H
         MVC   RECOUT+69(11),=CL11'End-Compute'
         MVI   RECOUT+83,C'N'
         TM    LE_STATUS_BYTE_15,BIT5
         BNO   LE_370_110
         MVI   RECOUT+83,C'Y'
LE_370_110 DS 0H
         MVC   RECOUT+86(10),=CL10'End-Delete'
         MVI   RECOUT+100,C'N'
         TM    LE_STATUS_BYTE_15,BIT6
         BNO   LE_370_111
         MVI   RECOUT+100,C'Y'
LE_370_111 DS 0H
         BAS   R14,PRINT_MSG
         MVC   RECOUT,BLANKS
         MVC   RECOUT+1(10),=C'End-Divide'
         MVI   RECOUT+15,C'N'
         TM    LE_STATUS_BYTE_15,BIT7
         BNO   LE_370_112
         MVI   RECOUT+15,C'Y'
LE_370_112 DS 0H
         MVC   RECOUT+18(11),=C'End-Evaluate'
         MVI   RECOUT+32,C'N'
         TM    LE_STATUS_BYTE_16,BIT0
         BNO   LE_370_113
         MVI   RECOUT+32,C'Y'
LE_370_113 DS 0H
         MVC   RECOUT+35(6),=C'End-If'
         MVI   RECOUT+49,C'N'
         TM    LE_STATUS_BYTE_16,BIT1
         BNO   LE_370_114
         MVI   RECOUT+49,C'Y'
LE_370_114 DS 0H
         MVC   RECOUT+52(11),=CL11'End-Muliply'
         MVI   RECOUT+66,C'N'
         TM    LE_STATUS_BYTE_16,BIT2
         BNO   LE_370_115
         MVI   RECOUT+66,C'Y'
LE_370_115 DS 0H
         MVC   RECOUT+69(8),=CL8'End-Read'
         MVI   RECOUT+83,C'N'
         TM    LE_STATUS_BYTE_16,BIT3
         BNO   LE_370_116
         MVI   RECOUT+83,C'Y'
LE_370_116 DS 0H
         MVC   RECOUT+86(10),=CL10'End-Return'
         MVI   RECOUT+100,C'N'
         TM    LE_STATUS_BYTE_16,BIT4
         BNO   LE_370_117
         MVI   RECOUT+100,C'Y'
LE_370_117 DS 0H
         BAS   R14,PRINT_MSG
         MVC   RECOUT,BLANKS
         MVC   RECOUT+1(11),=C'End-Rewrite'
         MVI   RECOUT+15,C'N'
         TM    LE_STATUS_BYTE_16,BIT5
         BNO   LE_370_118
         MVI   RECOUT+15,C'Y'
LE_370_118 DS 0H
         MVC   RECOUT+18(10),=C'End-Search'
         MVI   RECOUT+32,C'N'
         TM    LE_STATUS_BYTE_16,BIT6
         BNO   LE_370_119
         MVI   RECOUT+32,C'Y'
LE_370_119 DS 0H
         MVC   RECOUT+35(9),=C'End-Start'
         MVI   RECOUT+49,C'N'
         TM    LE_STATUS_BYTE_16,BIT7
         BNO   LE_370_120
         MVI   RECOUT+49,C'Y'
LE_370_120 DS 0H
         MVC   RECOUT+52(10),=CL10'End-String'
         MVI   RECOUT+66,C'N'
         TM    LE_STATUS_BYTE_17,BIT0
         BNO   LE_370_121
         MVI   RECOUT+66,C'Y'
LE_370_121 DS 0H
         MVC   RECOUT+69(13),=CL13'End-Substract'
         MVI   RECOUT+83,C'N'
         TM    LE_STATUS_BYTE_17,BIT1
         BNO   LE_370_122
         MVI   RECOUT+83,C'Y'
LE_370_122 DS 0H
         MVC   RECOUT+86(12),=CL12'End-Unstring'
         MVI   RECOUT+100,C'N'
         TM    LE_STATUS_BYTE_17,BIT2
         BNO   LE_370_123
         MVI   RECOUT+100,C'Y'
LE_370_123 DS 0H
         BAS   R14,PRINT_MSG
         MVC   RECOUT,BLANKS
         MVC   RECOUT+1(9),=C'End-Write'
         MVI   RECOUT+15,C'N'
         TM    LE_STATUS_BYTE_17,BIT3
         BNO   LE_370_124
         MVI   RECOUT+15,C'Y'
LE_370_124 DS 0H
         MVC   RECOUT+18(10),=C'Goback'
         MVI   RECOUT+32,C'N'
         TM    LE_STATUS_BYTE_17,BIT4
         BNO   LE_370_125
         MVI   RECOUT+32,C'Y'
LE_370_125 DS 0H
         MVC   RECOUT+35(9),=C'Evaluate'
         MVI   RECOUT+49,C'N'
         TM    LE_STATUS_BYTE_17,BIT5
         BNO   LE_370_126
         MVI   RECOUT+49,C'Y'
LE_370_126 DS 0H
         MVC   RECOUT+52(7),=CL7'Service'
         MVI   RECOUT+66,C'N'
         TM    LE_STATUS_BYTE_17,BIT7
         BNO   LE_370_127
         MVI   RECOUT+66,C'Y'
LE_370_127 DS 0H
         BAS   R14,PRINT_MSG
         STRING '====================================================',*
               '=============================================',        @
               INTO=RECOUT
         BAS   R14,PRINT_BLINE_MSG
         STRING 'Procedure has no hexadecimal literals',INTO=RECOUT
         TM    LE_STATUS_BYTE_21,BIT0
         BNO   LE_370_128
         STRING 'Procedure include hexadecimal literals',INTO=RECOUT
LE_370_128 DS 0H
         BAS   R14,PRINT_MSG
         STRING 'No altered GO TO',INTO=RECOUT
         TM    LE_STATUS_BYTE_21,BIT1
         BNO   LE_370_129
         STRING 'Program contains altered GO TO',INTO=RECOUT
LE_370_129 DS 0H
         BAS   R14,PRINT_MSG
         STRING 'No I/O error declarative',INTO=RECOUT
         TM    LE_STATUS_BYTE_21,BIT2
         BNO   LE_370_130
         STRING 'I/O error declarative',INTO=RECOUT
LE_370_130 DS 0H
         BAS   R14,PRINT_MSG
         STRING 'No Label declarative',INTO=RECOUT
         TM    LE_STATUS_BYTE_21,BIT3
         BNO   LE_370_131
         STRING 'Label declarative',INTO=RECOUT
LE_370_131 DS 0H
         BAS   R14,PRINT_MSG
         STRING 'No debugging declarative',INTO=RECOUT
         TM    LE_STATUS_BYTE_21,BIT4
         BNO   LE_370_132
         STRING 'Debugging declarative',INTO=RECOUT
LE_370_132 DS 0H
         STRING 'No program segmentation',INTO=RECOUT
         BAS   R14,PRINT_MSG
         TM    LE_STATUS_BYTE_21,BIT5
         BNO   LE_370_133
         STRING 'Programm segmentation',INTO=RECOUT
LE_370_133 DS 0H
         BAS   R14,PRINT_MSG
         STRING 'No Open Extend',INTO=RECOUT
         TM    LE_STATUS_BYTE_21,BIT6
         BNO   LE_370_134
         STRING 'Open Extend',INTO=RECOUT
LE_370_134 DS 0H
         BAS   R14,PRINT_MSG
         STRING 'No exit program',INTO=RECOUT
         TM    LE_STATUS_BYTE_21,BIT7
         BNO   LE_370_135
         STRING 'Exit Program',INTO=RECOUT
LE_370_135 DS 0H
         BAS   R14,PRINT_MSG
         STRING 'No call literal',INTO=RECOUT
         TM    LE_STATUS_BYTE_22,BIT0
         BNO   LE_370_136
         STRING 'Call literal (static?), see options',INTO=RECOUT
LE_370_136 DS 0H
         BAS   R14,PRINT_MSG
         STRING 'No call identifier',INTO=RECOUT
         TM    LE_STATUS_BYTE_22,BIT1
         BNO   LE_370_137
         STRING 'Call identifier',INTO=RECOUT
LE_370_137 DS 0H
         BAS   R14,PRINT_MSG
         STRING 'No call on overflow',INTO=RECOUT
         TM    LE_STATUS_BYTE_22,BIT2
         BNO   LE_370_138
         STRING 'Call on overflow',INTO=RECOUT
LE_370_138 DS 0H
         BAS   R14,PRINT_MSG
         STRING 'No call length of',INTO=RECOUT
         TM    LE_STATUS_BYTE_22,BIT3
         BNO   LE_370_139
         STRING 'Call length of',INTO=RECOUT
LE_370_139 DS 0H
         BAS   R14,PRINT_MSG
         STRING 'No call address of',INTO=RECOUT
         TM    LE_STATUS_BYTE_22,BIT4
         BNO   LE_370_140
         STRING 'Call address',INTO=RECOUT
LE_370_140 DS 0H
         BAS   R14,PRINT_MSG
         STRING 'No close reel/unit',INTO=RECOUT
         TM    LE_STATUS_BYTE_22,BIT5
         BNO   LE_370_141
         STRING 'Close reel/unit',INTO=RECOUT
LE_370_141 DS 0H
         BAS   R14,PRINT_MSG
         STRING 'No exponentiation used',INTO=RECOUT
         TM    LE_STATUS_BYTE_22,BIT6
         BNO   LE_370_142
         STRING 'Exponentiation used',INTO=RECOUT
LE_370_142 DS 0H
         BAS   R14,PRINT_MSG
         STRING 'No floating point items used',INTO=RECOUT
         TM    LE_STATUS_BYTE_22,BIT7
         BNO   LE_370_143
         STRING 'Floating point items used',INTO=RECOUT
LE_370_143 DS 0H
         BAS   R14,PRINT_MSG
         LA    R15,0
         B     EXIT
         EJECT
***********************************************************************
***                                                                 ***
**       Print message on SYSPRINT or via PUTLINE (TSO c.p.)         **
***                                                                 ***
***********************************************************************
         SPACE 2
PRINT_BLINE_MSG DS 0H
         OI    X_FLAG1,$XF1_BLKL          Need a blank line
*
** Print message on output medium
*
PRINT_MSG EQU *
         ST    R14,PM_RA                  Save return address
         TM    X_FLAG1,$XF1_PL            PUTLINE?
         BO    PM$XF1_PL                  Yes, do it
         TM    X_FLAG1,$XF1_SPO           Have we opened the file yet?
         BO    PM$PUTR                    Yes, continue
         LA    R3,SYSPRINT                Locate DCB
         MVC   0(C_DCBOL,R3),C_DCBO       Copy in DCB constant
         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'SYSPRINT'
         MVC   PARMLIST(C_LSTOL),C_LSTO   Copy in OPEN parm list
         OPEN  ((3),(OUTPUT)),            Open the file                @
               MF=(E,PARMLIST)
         OI    X_FLAG1,$XF1_SPO
PM$PUTR  DS    0H
         DA#SMODE 24                      Get into 24 bit address mode
         TM    X_FLAG1,$XF1_BLKL          Need a Blank line?
         BNO   PM$PR1                     Yes, do it
         PUT   SYSPRINT,BLANKS            Print a blank line
PM$PR1   DS    0H
         PUT   SYSPRINT,RECOUT            Print the message
         DA#SMODE 31
         NI    X_FLAG1,255-$XF1_BLKL      Turn off the flag
         L     R14,PM_RA                  Get return address
         BSM   0,R14                      Return to caller
PM$XF1_PL EQU *
         TM    X_FLAG1,$XF1_BLKL          Need a Blank line?
         BNO   PM$PL1                     No, continue
         PUTLINE PARM=PM_PBLK,                                         @
               OUTPUT=(BLANKL,TERM,SINGLE,DATA),                       @
               MF=(E,PM_IOPL)
PM$PL1   DS    0H
         PUTLINE PARM=PM_PBLK,                                         @
               OUTPUT=(RECOUTH,TERM,SINGLE,DATA),                      @
               MF=(E,PM_IOPL)
         NI    X_FLAG1,255-$XF1_BLKL      Turn off the flag
         L     R14,PM_RA                  Get return address
         BSM   0,R14                      Return to caller
         EJECT
***********************************************************************
***                                                                 ***
**       Constants                                                   **
***                                                                 ***
***********************************************************************
         SPACE 2
BLANKL   DC    AL2(4+1,0)         Full word PUTLINE header
BLANKS   DC    CL255' '           just blanks
*
C_COBOL370 DC X'00',C'CEE'                   COBOL/370 ?  X'00C3C5C5'
*
         PRINT NOGEN
C_PBLK   PUTLINE MF=L
C_PBLKL  EQU   *-C_PBLK
C_LSTO   OPEN  (*-*,(OUTPUT)),MF=L
C_LSTOL  EQU   *-C_LSTO
C_CLS    CLOSE (*-*),MF=L
C_CLSL   EQU   *-C_CLS
C_DCBO   DCB   DDNAME=C_DCBO,                                          @
               DSORG=PS,MACRF=PM,RECFM=FB,LRECL=80
C_DCBOL  EQU   *-C_DCBO
         PRINT GEN
*
** Literals
*
LTORG    EQU   *
         LTORG ,
LTORGL   EQU   *-LTORG
         DS    0D
*
** Generate STRING constants and CSECT
*
         STRING GENERATE
         EJECT
***********************************************************************
***                                                                 ***
**       Dynamic Save Area                                           **
***                                                                 ***
***********************************************************************
         SPACE 2
DSA                 DSECT
                    DS    18F   Register Save Area
PGMNAME             DS    CL8   Pgmname from the parmlist
ADR_PGMNAME         DS    F     Save entry-point Application PGM
                    DS    0F
SYSPRINT            DS    XL(C_DCBOL)
                    DS    0F
PARMLIST            DS    8F
*
** Program information
*
LE_SWITCH           DS    CL1   Switch for COBOL/370 or COBOL/2
LE_PGM_NAME         DS CL8  name of programm
LE_COMP_YEAR        DS CL4  year of compilation
LE_COMP_MONTH       DS CL2  month of compilation
LE_COMP_DAY         DS CL2  day of compilation
LE_COMP_HOURS       DS CL2  hours of compilation
LE_COMP_MIN         DS CL2  minutes of compilation
LE_COMP_SEC         DS CL2  seconds of compilation
LE_VERS             DS CL2  version
LE_REL              DS CL2  release
LE_MOD              DS CL2  modification level
LE_STATUS_BYTE      DS    0C   signature bytes
LE_STATUS_BYTE_01   DS X    status byte
LE_STATUS_BYTE_02   DS X    status byte
LE_STATUS_BYTE_03   DS X    status byte
LE_STATUS_BYTE_04   DS X    status byte
LE_STATUS_BYTE_05   DS X    status byte
LE_STATUS_BYTE_06   DS X    status byte
LE_STATUS_BYTE_07   DS X    status byte
LE_STATUS_BYTE_08   DS X    status byte
LE_STATUS_BYTE_09   DS X    status byte
LE_STATUS_BYTE_10   DS X    status byte
LE_STATUS_BYTE_11   DS X    status byte
LE_STATUS_BYTE_12   DS X    status byte
LE_STATUS_BYTE_13   DS X    status byte
LE_STATUS_BYTE_14   DS X    status byte
LE_STATUS_BYTE_15   DS X    status byte
LE_STATUS_BYTE_16   DS X    status byte
LE_STATUS_BYTE_17   DS X    status byte
LE_STATUS_BYTE_18   DS X    status byte
LE_STATUS_BYTE_19   DS X    status byte
LE_STATUS_BYTE_20   DS X    status byte
LE_STATUS_BYTE_21   DS X    status byte
LE_STATUS_BYTE_22   DS X    status byte
LE_STATUS_BYTE_23   DS X    status byte
LE_STATUS_BYTE_24   DS X    status byte
LE_STATUS_BYTE_25   DS X    status byte
LE_COBOL_SIGNAT     DS X    cobol signature level
LE_DATA_STATEMENTS  DS XL4  number of data items
LE_PROC_LINES       DS XL4  number of proc statements
*
** Misc fields
*
          DS    0F
*                                         Print_Message
PM_RA     DS    F                         ..Return Address
PM_IOPL   DS    XL(#IOPL)                 ..Input/Output Parm List
PM_PBLK   DS    XL(C_PBLKL)               ..PUTLINE block
PM_ECB    DS    F                         ..Input/Output Parm List
*
X_FLAG1   DC    B'00000000'               X_FLAG1 byte
$XF1_PL   EQU   B'10000000'               ..PUTLINE
$XF1_BLKL EQU   B'01000000'               ..Need a blank line
$XF1_SPO  EQU   B'00100000'               ..File open yet?
$XF1_VS   EQU   B'00010000'               ..VS COBOL II?
$XF1_LOAD EQU   B'00001000'               ..Did we load program?
          DS    0H
RECOUTH   DS    XL4                       Header
RECOUT    DS    CL256                     Record output area
          DS    0D
DSAL      EQU   *-DSA
          END
./ ADD NAME=DA$DATE  0100-01266-01266-1821-02148-02148-00000-DAVE
* =================================================================== *
*
* Name: DA$DATE
*
* Author = David Alcock :: dave@planetmvs.com
*
* Purpose: Date routine
*          o Multiple input date/time formats
*          o Multiple output date/time formats
*          o Calendar processing
*
*          This routine processes an input parameter list that
*          may consist of multiple input and output date and time
*          formats. A most current version of the date is kept up
*          to date based on the input received.  If an output type
*          is found and no input found, the current date and time
*          is used.  Some example parameter lists:
*
*             PARM=(output-julian,output-standard-time)
*
*             PARM=(input-gregorian,input-time,output-gregorian,
*                   output-standard-time,output-calendar,
*                   input-julian(newday!),output-gregorian)
*
*          As it processes the parameters, the input time and date
*          will be altered.
*
* Warning: Now that we have the nice IBM-supplied date routines
*          for assembler programs: STCKCONV and CONVTOD, why use a
*          date routine like this one?  This program is used by my
*          older programs before STCKCONV and CONVTOD.
*
* Disclaimer: This program is FREEWARE.  Use at your own risk.  It
*             is provided for your enjoyment and neither David
*             Alcock or his employer provides any warranty for it's
*             use.  I'd like to hear how it works on your system.
*
*             This software is not in the public domain but is
*             available free of charge and with source code
*             provided.  It is copyright 2001+ by David Alcock
*             All rights reserved.
*
* Non-IBM assembler MACROs:
* o DA#DATE....Equates and DSECTs for the date routine
* o DA#ENTER...Entry housekeeping
* o DA#LEAVE...Termination housekeeping
* o DA#EYEC....Build standard O/S module eyecatcher
*              (invoked by the DA#ENTER)
* o DA#REGS....Define registers (invoked by DA#ENTER)
*
* =================================================================== *
         SPACE 2
&DAVER   SETC  '2.4'
* =================================================================== *
*
*           M o d i f i c a t i o n   H i s t o r y
*
* Person     Date        Description
* ---------- ----------- ------------------------------------------
* DGAlcock   15-SEP-1999 2.4 Use STCKCON macro for TOD time stamps;
* DGAlcock   09-SEP-1999 2.3 Added year windowing based on 1950;
* DGAlcock   07-SEP-1999 2.2 Added input  ISO date format: ccyy-mm-dd;
* DGAlcock   09-MAY-1997 2.1 Added output ISO date format: ccyy-mm-dd;
* DGAlcock   05-MAY-1997 2.0 Added complete leap year calculation
*                        (100 and 400 tests);
* DGAlcock   23-FEB-1987 1.0 Initial program created;
*
* =================================================================== *
         EJECT ,
*
** External DSECTS
*
         DA#DATE ,                        Map our DSECT and equates
         PRINT NOGEN
         CVT   DSECT=YES,LIST=NO          MVS CVT
         PRINT GEN
         EJECT ,
***********************************************************************
***
**       Entry housekeeping
***
***********************************************************************
         SPACE 2
DA$DATE  DA#ENTER 'V&DAVER Subroutine: Ubiquitous Date routine',       @
               LV=DSAL,RENT=YES,          GETMAIN area and length      @
               AMODE=31,RMODE=ANY,        Any where in V/S             @
               BASE=(12,11)               Base registers
 USING DSA,R13                            Get addressability to area
 LR    R2,R1                              Save Address of parms
 EJECT
***********************************************************************
***
**       Process parameters
**
**       T_ROUT table is mapped by the TR DSECT
***
***********************************************************************
 SPACE 2
I$L EQU *
 ST    R2,I_LA                            Save Current loop Address
 ICM   R8,B'1111',0(R2)                   Load address of string
 BZ    EXIT                               LEAVE if parm entry = 0...
 USING DA#DATED,R8                        Map the input parameter
 LA    R8,0(R8)                           Zero high order bit (if any)
* Note: R8 is a "Global" register - do not change outside of "I$"
*
** Check table for routine address - input paramter
*
 LA    R4,T_ROUT                          Locate table
 LA    R5,T_ROUTE                         Number of entries in table
I$LRL EQU *
 CLC   TR_TYPE-TR(2,R4),DA#DATED_TYPE     Match?
 BE    I$LRLX                             Yes, branch to the routine
 LA    R4,8(R4)                           Bump to next entry
 BCT   R5,I$LRL                           ..and process it
*
** Invalid parameter entry - type not in table
*
I$INVALID_TYPE EQU *
 MVI   DA#DATED_FLAG,$DA#DATE_EITYPE      Invalid parm indication
 B     I$LB                               Ignore entry: not in table
*
** Found entry in table - Invoke the routine
*
I$LRLX EQU *
 BAS   R9,LOCATE_STRING                   Get output string addr: R15
 L     R14,TR_ROUT-TR(R4)                 Locate routine address
 BR    R14                                Do the routine
 B     I$LB                               Now - Check the return code
*
** Bump to next parameter entry
*
I$LB EQU *                                -> Return here after routine
 L     R2,I_LA                            Get loop address
 TM    0(R2),B'10000000'                  X'80' means end of list...
 BO    EXIT                               Yes, leave
 LA    R15,4                              Length of each parameter ptr
 AR    R2,R15                             Bump to next parameter ptr
 B     I$L                                ..Process next one
*
** Complete output: Calculate length of output string
** Input: R15 - Points to the last byte in the string + 1
*
I$UPDATE_LENGTH EQU *
 DA#DATE STRLEN                           Calcuate string length
 B     I$LB                               Process next parameter
*
** Invalid length for input field found, - set result/return code
*
I$INVALID_STRLT EQU *
 MVI   S_TIME,$DA#DATE_INVALID            Indicate time was invalid
 B     I$INVALID_STR                      Move on
I$INVALID_STRLD EQU *
 MVI   S_JDATE,$DA#DATE_INVALID           Indicate date was invalid
I$INVALID_STRL EQU *
 MVI   DA#DATED_FLAG,$DA#DATE_EISTRL      Set: invalid string length
 B     I$LB
*
** Invalid input string found
*
I$INVALID_STRT EQU *
 MVI   S_TIME,$DA#DATE_INVALID            Indicate time was invalid
 B     I$INVALID_STR                      Move on
I$INVALID_STRD EQU *
 MVI   S_JDATE,$DA#DATE_INVALID           Indicate date was invalid
I$INVALID_STR  EQU *
 MVI   DA#DATED_FLAG,$DA#DATE_EISTR       Set: invalid string
 B     I$LB
*
** No Saved entry found
*
I$NO_SAVED_ENTRY EQU *
 MVI   DA#DATED_FLAG,$DA#DATE_ENOSAVE     Set flag
 B     I$LB
 EJECT
***********************************************************************
***
**                 Common exit from DA#DATE
***
***********************************************************************
 SPACE 2
EXIT EQU *
 DA#LEAVE ,                               Exit housekeeping
 EJECT ,
***********************************************************************
***
**       Routine branch table
***
***********************************************************************
 SPACE 2
 PRINT DATA
T_ROUT EQU *
*
** Date/Time stuff
*
 DC AL2($DA#DATE_ODISO,0),AL4(OUTPUT_DATE_ISO)
 DC AL2($DA#DATE_ODGUS,0),AL4(OUTPUT_DATE_GREGORIAN)
 DC AL2($DA#DATE_ODGEUR,0),AL4(OUTPUT_DATE_GREGORIAN)
 DC AL2($DA#DATE_ODJUL,0),AL4(OUTPUT_DATE_JULIAN)
 DC AL2($DA#DATE_ODCAL,0),AL4(OUTPUT_DATE_CALENDAR)
 DC AL2($DA#DATE_ODCALND,0),AL4(OUTPUT_DATE_CALENDAR)
 DC AL2($DA#DATE_ODDOW,0),AL4(OUTPUT_DATE_DOW)
 DC AL2($DA#DATE_ODMONTHN,0),AL4(OUTPUT_DATE_MONTHN)
 DC AL2($DA#DATE_OTIMEM,0),AL4(OUTPUT_TIME_MILITARY)
 DC AL2($DA#DATE_OTIMES,0),AL4(OUTPUT_TIME_STANDARD)
*
 DC AL2($DA#DATE_IDGUS,0),AL4(INPUT_DATE_GREGORIAN)
 DC AL2($DA#DATE_IDISO,0),AL4(INPUT_DATE_ISO8601)
 DC AL2($DA#DATE_IDJULP,0),AL4(INPUT_DATE_JULIAN_PACKED)
 DC AL2($DA#DATE_IDJULC,0),AL4(INPUT_DATE_JULIAN_CHARACTER)
 DC AL2($DA#DATE_ITDEC,0),AL4(INPUT_TIME_DECIMAL)
 DC AL2($DA#DATE_ITBIN,0),AL4(INPUT_TIME_BINARY)
 DC AL2($DA#DATE_ITIMES,0),AL4(INPUT_TIME_CHAR_STANDARD)
 DC AL2($DA#DATE_ITIMEM,0),AL4(INPUT_TIME_CHAR_MILITARY)
 DC AL2($DA#DATE_ISTMPC,0),AL4(INPUT_TIMESTAMP_CHARACTER)
 DC AL2($DA#DATE_ISTMPV,0),AL4(INPUT_TIMESTAMP_VALUE)
*
** End of Table
*
T_ROUTE EQU (*-T_ROUT)/4
 DS    0H
 PRINT NODATA
 EJECT ,
***********************************************************************
***
**       Misc Internal Subroutines
***
***********************************************************************
         SPACE 2
LOCATE_STRING EQU *
 DA#DATE STRLOC
 BSM 0,R9
*
** Point to first blank in string (if any)
** Input:  R0  - Length of string
**         R15 - String
** Output: R15 - First space in string
*
LOCATE_FIRST_SPACE EQU *
         CLI   0(R15),C' '
         BE    LFS$X
         LA    R15,1(R15)
         BCT   R0,LOCATE_FIRST_SPACE
LFS$X    EQU   *
         BSM   0,R14
*
** Suppress Leading Zeroes, (Will leave last zero)
**
** Input: R0  - Length of field
**        R1  - Address of input
**        R15 - Address to put output
*
SUPLZ     EQU   *
          SH    R0,=H'1'                  Decrement count by 1
SLZ$L     EQU   *
          CLI   0(R1),C'0'                Zero?
          BNE   SLZ$LX                    No, move rest to output
          LA    R1,1(R1)                  Skip this byte
          BCT   R0,SLZ$L                  ..process next one
          MVC   0(1,R15),0(R1)            Move last byte to output
          LA    R15,1(R15)                Bump past it
          BR    R14                       Return to caller
SLZ$LX    EQU   *
          AH    R0,=H'1'                  Increment count
SLZ$RL    EQU   *
          MVC   0(1,R15),0(R1)            Move byte to output
          LA    R1,1(R1)                  Bump input
          LA    R15,1(R15)                Bump output
          BCT   R0,SLZ$RL                 ..process next byte
          BSM   0,R14                     Return to caller
*
** Clear output string to blanks
** Input: R15 - address of string- ** Do not modify **
*
CLEAR_STRING EQU *
 SLR   R1,R1                              Zero out register
 IC    R1,DA#DATED_STRL                   Get output length
 BCTR  R1,0                               Decrement for EX
 BCTR  R1,0                               Decrement for MVC +1 stuff
 MVI   0(R15),C' '                        Move in blank
 MVC   1(0,R15),0(R15)                    ** Executed **
 EX    R1,*-6                             ..Propagate blank
 BSM   0,R9
*
** Convert a hex string from character
** For example: From CL8'3020100E' to X'3020100E'
**
** Input: R0 - Length of output string (input / 2)
**        R1 - Output location
**        R15 - Input location
*
HEXTRAN EQU *
 STM   R3,R6,PARMLIST                     Save registers
HT$MT EQU *
 MVI   0(R1),0                            Zero output byte
 LA    R4,1                               Offset for first hex char
 LA    R5,2                               Number of Nibbles in a byte
HT$CL EQU *
 LA    R6,T_HEX                           Locate Hex table
 LA    R3,T_HEXE                          Number of entries in table
HT$C1L EQU *
 CLC   0(1,R6),0(R15)                     Match?
 BE    HT$C1LX                            Yes, move on
 LA    R6,3(R6)                           No, bump to next byte
 BCT   R3,HT$C1L                          Repeat
 B     HT$X                               Character not valid
HT$C1LX EQU *
 LA    R6,0(R4,R6)                        Bump to bitstring
 OC    0(1,R1),0(R6)                      Turn on bits for this nibble
 LA    R4,1(R4)                           Increment for next nibble
 LA    R15,1(R15)                         Bump to the next input byte
 BCT   R5,HT$CL                           Do next hex nibble in byte
 LA    R1,1(R1)                           Bump to next output byte
 BCT   R0,HT$MT                           ..do it
 SLR   R15,R15                            Clear register: success
HT$X EQU *
 LM    R3,R6,PARMLIST                     Save registers
 BSM   0,R9
*
** HEX TABLE FORMAT:
**   C'0'         - CHARACTER THAT WE ARE CONVERTING
**   B'11110000'  - FIRST NIBBLE OF BYTE
**   B'00001111'  - LAST NIBBLE OF BYTE
*
T_HEX    EQU   *
         DC    C'0',B'00000000',B'00000000'
         DC    C'1',B'00010000',B'00000001'
         DC    C'2',B'00100000',B'00000010'
         DC    C'3',B'00110000',B'00000011'
         DC    C'4',B'01000000',B'00000100'
         DC    C'5',B'01010000',B'00000101'
         DC    C'6',B'01100000',B'00000110'
         DC    C'7',B'01110000',B'00000111'
         DC    C'8',B'10000000',B'00001000'
         DC    C'9',B'10010000',B'00001001'
         DC    C'A',B'10100000',B'00001010'
         DC    C'B',B'10110000',B'00001011'
         DC    C'C',B'11000000',B'00001100'
         DC    C'D',B'11010000',B'00001101'
         DC    C'E',B'11100000',B'00001110'
         DC    C'F',B'11110000',B'00001111'
T_HEXE   EQU   ((*-T_HEX)/(1+1+1))
 EJECT ,
***********************************************************************
***
**              Input Gregorian date processing
**
**   Enhancement queue:
**   - Add European support...
***
***********************************************************************
 SPACE 2
INPUT_DATE_GREGORIAN EQU *
*
** Check for lengths
*
 CLI   DA#DATED_STRL,$DA#DATE_IDGUS12
 BE    IDG$F12
 CLI   DA#DATED_STRL,$DA#DATE_IDGUS10
 BE    IDG$F10
 CLI   DA#DATED_STRL,$DA#DATE_IDGUS8
 BE    IDG$F8
 CLI   DA#DATED_STRL,$DA#DATE_IDGUS6
 BE    IDG$F6
*
 B     I$INVALID_STRLD            Branch to invalid length code
*
** Field in format: "MMM DD, CCYY"
*                    012345678
IDG$F12 EQU *
 LA    R1,T_MONTH                         Locate month table
 LA    R0,T_MONTHE                        Get number of entries
 MVC   DOUBLE(3),0(R15)                   Get the month
 OC    DOUBLE(3),=CL3' '                  Make uppercase
IDG$F12L EQU *
 MVC   DOUBLE+3(3),TM_NAME-TM(R1)         Get table entry month
 OC    DOUBLE+3(3),=CL3' '                Make uppercase
 CLC   DOUBLE(3),DOUBLE+3                 Month match?
 BE    IDG$F12LX                          Yes, move on
 LA    R1,TML(R1)                         Bump to next month entry
 BCT   R0,IDG$F12L                        Repeat
 B     I$INVALID_STRD                     Month not in table...
IDG$F12LX EQU *
 LA    R2,TM_NUMC-TM(R1)                  Locate month
 LA    R3,4(R15)                          Make day of month
 LA    R4,8(R15)                          Locate century
 B     IDG$X                              Field location complete
*
** Field in format: "MM/DD/CCYY"
*                    012345678
IDG$F10 EQU *
 LA    R2,0(R15)                          Locate month
 LA    R3,3(R15)                          Locate day of month
 LA    R4,6(R15)                          Locate century
 B     IDG$X                              Field location complete
*
** Field in format: "MM/DD/YY"
*                    012345678
IDG$F8 EQU *
 LA    R2,0(R15)                          Locate month
 LA    R3,3(R15)                          Locate day of month
 LA    R4,W_CCYY                          Locate YYYY area
*MVC   0(2,R4),=C'19'                     Move in 19
 MVC   2(2,R4),6(R15)                     Get year
 BAS   R14,PERFORM_YEAR_WINDOW            Get a good century
 B     IDG$X                              Field location complete
*
** Field in format: MMDDYY
*                   012345
IDG$F6 EQU *
 LA    R2,0(R15)                          Locate month
 LA    R3,2(R15)                          Locate day of month
 LA    R4,W_CCYY                          Locate YYYY area
*MVC   0(2,R4),=C'19'                     Move in 19
 MVC   2(2,R4),4(R15)                     Get year
 BAS   R14,PERFORM_YEAR_WINDOW            Get a good century
*
** Ensure that the input is valid numeric
*
IDG$X  EQU *
 LA    R1,W_GDATE                         Locate "MMDDCCYY" field
 MVC   0(2,R1),0(R2)                      ==>     MM
 MVC   2(2,R1),0(R3)                      ==>       DD
 MVC   4(4,R1),0(R4)                      ==>         CCYY
*
 LA    R2,0(R1)                           Reset MM location
 LA    R3,2(R1)                           Reset DD location
 LA    R4,4(R1)                           Reset CCYY location
*
 LA    R0,8                               Length to check
 BAS   R14,ENSURE_NUMERICS                Ensure numerics
 LTR   R15,R15                            All okay?
 BNZ   I$INVALID_STRD                     Nope, move on
*
** Call conversion routines until S_JDATE has "CCYYDDDF"
*
 LA    R6,PARMLIST+20                     Output location for DOY
 BAS   R9,RETURN_DAY_OFTHE_YEAR           Get Day of the year
*
 LA    R3,1(R6)                           Locate "DDD"
*Note: R4 still points to "CCYY"
 LA    R6,S_JDATE                         Output addr for julian date
 BAS   R9,RETURN_JULIAN_PACKED            Change character to packed
 B     I$LB                               Return address
 EJECT ,
***********************************************************************
***
**              Input Gregorian date in ISO 8601 format
**
**              Format: ccyy-mm-dd
***
***********************************************************************
 SPACE 2
INPUT_DATE_ISO8601 DS 0H
*
** Check for lengths
*
 CLI   DA#DATED_STRL,$DA#DATE_IDISO10
 BE    IDI$F10
*
 B     I$INVALID_STRLD            Branch to invalid length code
*
** Field in format: "CCYY-MM-DD"
*                    012345678
IDI$F10 EQU *
 LA    R2,5(R15)                          Locate month
 LA    R3,8(R15)                          Locate day of month
 LA    R4,0(R15)                          Locate century
*B     IDI$X                              Field location complete
*
** Ensure that the input is valid numeric
*
IDI$X  EQU *
 LA    R1,W_GDATE                         Locate "MMDDCCYY" field
 MVC   0(2,R1),0(R2)                      ==>     MM
 MVC   2(2,R1),0(R3)                      ==>       DD
 MVC   4(4,R1),0(R4)                      ==>         CCYY
*
 LA    R2,0(R1)                           Reset MM location
 LA    R3,2(R1)                           Reset DD location
 LA    R4,4(R1)                           Reset CCYY location
*
 LA    R0,8                               Length to check
 BAS   R14,ENSURE_NUMERICS                Ensure numerics
 LTR   R15,R15                            All okay?
 BNZ   I$INVALID_STRD                     Nope, move on
*
** Call conversion routines until S_JDATE has "CCYYDDDF"
*
 LA    R6,PARMLIST+20                     Output location for DOY
 BAS   R9,RETURN_DAY_OFTHE_YEAR           Get Day of the year
*
 LA    R3,1(R6)                           Locate "DDD"
*Note: R4 still points to "CCYY"
 LA    R6,S_JDATE                         Output addr for julian date
 BAS   R9,RETURN_JULIAN_PACKED            Change character to packed
 B     I$LB                               Return address
 EJECT ,
***********************************************************************
***
**                Input System Time Stamp
***
***********************************************************************
 SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
**        System time stamp - input is double word value
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 SPACE 2
INPUT_TIMESTAMP_VALUE EQU *
 CLI   DA#DATED_STRL,$DA#DATE_ISTMPV8     Correct length?
 BNE   I$INVALID_STRLD                    Invalid?
 MVC   DOUBLE(8),0(R15)                   Get value
*
 LA    R3,DOUBLE                          Locate input time stamp value
 LA    R5,S_TIME                          Locate output time
 LA    R6,S_JDATE                         Locate output date
 BAS   R9,CONVERT_TIMESTAMP               Convert Time stamp
 LTR   R15,R15                            Ensure STCKCON worked ok
 BNZ   I$INVALID_STRLD                    No, gripe about it
 B     I$LB
 SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
**        System time stamp - input in character format
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 SPACE 2
INPUT_TIMESTAMP_CHARACTER EQU *
 CLI   DA#DATED_STRL,$DA#DATE_ISTMPC16    Correct length?
 BNE   I$INVALID_STRLD                    Invalid?
*
 MVC   DWA(16),0(R15)                     Get the input string
 OC    DWA(16),=CL16' '                   Ensure uppercase
*
** Convert the character string to the true value
*
 LA    R1,DOUBLE                          Locate output double word
 LA    R15,DWA                            Locate input hex characters
 LA    R0,8                               Length of input string / 2
 BAS   R9,HEXTRAN                         Translate to hex value
 BXH   R15,R15,I$INVALID_STRD             Check for invalid string
*
 LA    R3,DOUBLE                          Locate input time stamp value
 LA    R5,S_TIME                          Locate output time
 LA    R6,S_JDATE                         Locate output date
 BAS   R9,CONVERT_TIMESTAMP               Convert Time stamp
 LTR   R15,R15                            Ensure STCKCON worked ok
 BNZ   I$INVALID_STRLD                    No, gripe about it
 B     I$LB
 EJECT
***********************************************************************
***
**       Input Julian (IBM) date processing
***
***********************************************************************
 SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
**    Input julian date - Packed format
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 SPACE 2
INPUT_DATE_JULIAN_PACKED EQU *
 CLI   DA#DATED_STRL,$DA#DATE_IDJULP3     yydddF ?
 BE    IDJULP3                            move on
 CLI   DA#DATED_STRL,$DA#DATE_IDJULP4     ccyydddF ?
 BNE   I$INVALID_STRLD                    Invalid?
 MVC   S_JDATE(4),0(R15)                  Move in Input PL4'ccyyddd'
 B     I$LB
IDJULP3  EQU   *
 MVI   S_JDATE,0                          Set century byte to zero
 MVC   S_JDATE+1(3),0(R15)                Move in Input PL3'yyddd'
 B     IDJ$X                              Ensure valid julian date
 SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
**          Input Julian Date - Character format
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 SPACE 2
INPUT_DATE_JULIAN_CHARACTER EQU *
*
** Check length
*
 CLI   DA#DATED_STRL,$DA#DATE_IDJULC5     YYDDD    - 62065
 BE    IDJC$5
 CLI   DA#DATED_STRL,$DA#DATE_IDJULC6     YY.DDD   - 62.064
 BE    IDJC$6
 CLI   DA#DATED_STRL,$DA#DATE_IDJULC7     CCYYDDD  - 1962064
 BE    IDJC$7
 CLI   DA#DATED_STRL,$DA#DATE_IDJULC8     CCYY.DDD - 1962.064
 BE    IDJC$8
 B     I$INVALID_STRLD                    Branch to invalid length code
*
** Julian character format: "YYDDD"
*                            01234
IDJC$5 EQU *
 LA    R3,2(R15)                          Locate "DDD"
 LA    R4,DOUBLE                          Locate work location
*MVC   0(2,R4),=C'19'                     Default for century
 MVC   2(2,R4),0(R15)                     Move in YY
 BAS   R14,PERFORM_YEAR_WINDOW            Get a good century
 B     IDJC$X
*
** Julian character format: "YY.DDD"
*                            0123
IDJC$6 EQU *
 LA    R3,3(R15)                          Locate "DDD"
 LA    R4,DOUBLE                          Locate year location
*MVC   0(2,R4),=C'19'                     Make it this century
 MVC   2(2,R4),0(R15)                     Move in YYDDD
 BAS   R14,PERFORM_YEAR_WINDOW            Get a good century
 B     IDJC$X
*
** Julian character format: "CCYYDDD"
*                            01234
IDJC$7 EQU *
 LA    R3,4(R15)                          Locate "DDD"
 LA    R4,0(R15)                          Locate "CCYY"
 B     IDJC$X
*
** Julian character format: "CCYY.DDD"
*                            012345
IDJC$8 EQU *
 LA    R3,5(R15)                          Locate "DDD"
 LA    R4,0(R15)                          Locate "CCYY"
*
** Exit from Input_Date_Julian_Character
*
IDJC$X EQU *
 LA    R1,PARMLIST                        Locate work area
 MVC   0(4,R1),0(R4)                      Move in "CCYY"
 MVC   4(3,R1),0(R3)                      Move in "DDD"
 LA    R0,7                               Length to check
 BAS   R14,ENSURE_NUMERICS                Ensure numerics
 LTR   R15,R15                            All okay?
 BNZ   I$INVALID_STRD                     Nope, move on
*
 LA    R6,S_JDATE                         Output location
 BAS   R9,RETURN_JULIAN_PACKED            Convert value
 SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
**               Ensure that the input date is correct
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 SPACE 2
IDJ$X EQU *
 LA    R3,S_JDATE                         Locate packed Julian date
 BAS   R9,ENSURE_VALID_JULIAN             Ensure the number is valid
 LTR   R15,R15                            Valid?
 BZ    I$LB                               Yes, move on
 B     I$INVALID_STRD                     Leave
 EJECT ,
***********************************************************************
***
**       Input Time
***
***********************************************************************
 SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
**    Input time character - Standard - based on a 12 hour clock
**                           with AM or PM appended
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 SPACE 2
INPUT_TIME_CHAR_STANDARD EQU *
 MVI   DOUBLE,C'0'                       Get zero
 MVC   DOUBLE+1(7),DOUBLE                ..Propagate it
*
 CLI   DA#DATED_STRL,$DA#DATE_ITIMES14
 BE    ITCS$14
 CLI   DA#DATED_STRL,$DA#DATE_ITIMES11
 BE    ITCS$11
 CLI   DA#DATED_STRL,$DA#DATE_ITIMES8
 BE    ITCS$8
 CLI   DA#DATED_STRL,$DA#DATE_ITIMES6
 BE    ITCS$6
 CLI   DA#DATED_STRL,$DA#DATE_ITIMES5
 BNE   I$INVALID_STRLD                    No, invalid
*
ITCS$5 EQU *                              HHMMa to HHMM0000 A
 MVC   DOUBLE(4),0(R15)
 MVC   DWA(1),4(R15)
 B     ITCS$CONVERT
ITCS$6 EQU *                              HH:MMa to HHMM0000 A
 MVC   DOUBLE(2),0(R15)
 MVC   DOUBLE+2(2),3(R15)
 MVC   DWA(1),5(R15)
 B     ITCS$CONVERT
ITCS$8 EQU *                              HH:MM am to HHMM0000 A
 MVC   DOUBLE(2),0(R15)
 MVC   DOUBLE+2(2),3(R15)
 MVC   DWA(1),6(R15)
 B     ITCS$CONVERT
ITCS$11 EQU *                             HH:MM:SS am to HHMMSS00 A
 MVC   DOUBLE(2),0(R15)
 MVC   DOUBLE+2(2),3(R15)
 MVC   DOUBLE+4(2),6(R15)
 MVC   DWA(1),9(R15)
 B     ITCS$CONVERT
ITCS$14 EQU *                             HH:MM:SS.th am to HHMMSSTH A
 MVC   DOUBLE(2),0(R15)
 MVC   DOUBLE+2(2),3(R15)
 MVC   DOUBLE+4(2),6(R15)
 MVC   DOUBLE+6(2),9(R15)
 MVC   DWA(1),12(R15)
*B     ITCS$CONVERT
*
** Need to convert hours based on AM or PM
*
ITCS$CONVERT EQU *
 OI    DWA,C' '                           Convert xM to uppercase
 CLI   DWA,C'P'                           PM?
 BNE   ITC$CONVERT                        No: AM or assume that it is
 LA    R0,2                               Get length of input time
 LA    R1,DOUBLE                          Locate input time area
 BAS   R14,ENSURE_NUMERICS                Ensure its all valid nums
 LTR   R15,R15                            Valid?
 BNZ   I$INVALID_STRD                     No, gripe about it
 PACK  DWA(8),DOUBLE(2)                   Make packed
 CVB   R1,DWA                             Make hour binary
 AH    R1,=H'12'                          Add 12 to make it military
 CVD   R1,DWA                             Convert back to packed
 UNPK  PARMLIST(4),DWA+6(2)               Convert packed to zoned
 OI    PARMLIST+3,C'0'                    Fix sign byte
 MVC   DOUBLE(2),PARMLIST+2               Move hours to output area
 B     ITC$CONVERT
 SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
**    Input time character - Miltary - based on a 24 hour clock
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 SPACE 2
INPUT_TIME_CHAR_MILITARY EQU *
 MVI   DOUBLE,C'0'                       Get zero
 MVC   DOUBLE+1(7),DOUBLE                ..Propagate it
 CLI   DA#DATED_STRL,$DA#DATE_ITIMEM11
 BE    ITCM$11
 CLI   DA#DATED_STRL,$DA#DATE_ITIMEM8
 BE    ITCM$8
 CLI   DA#DATED_STRL,$DA#DATE_ITIMEM6
 BE    ITCM$6
 CLI   DA#DATED_STRL,$DA#DATE_ITIMEM5
 BE    ITCM$5
 CLI   DA#DATED_STRL,$DA#DATE_ITIMEM4
 BNE   I$INVALID_STRLD                    No, invalid
ITCM$4 EQU *                              HHMM to HHMM0000
 MVC   DOUBLE(4),0(R15)
 B     ITC$CONVERT
ITCM$5 EQU *                              HH:MM to HHMM0000
 MVC   DOUBLE(2),0(R15)
 MVC   DOUBLE+2(2),3(R15)
 B     ITC$CONVERT
ITCM$6 EQU *                              HHMMSS to HHMMSS00
 MVC   DOUBLE(6),0(R15)
 B     ITC$CONVERT
ITCM$8 EQU *                              HH:MM:SS to HHMMSS00
 MVC   DOUBLE(2),0(R15)
 MVC   DOUBLE+2(2),3(R15)
 MVC   DOUBLE+4(2),6(R15)
 B     ITC$CONVERT
ITCM$11 EQU *                             HH:MM:SS.th to HHMMSSTH
 MVC   DOUBLE(2),0(R15)
 MVC   DOUBLE+2(2),3(R15)
 MVC   DOUBLE+4(2),6(R15)
 MVC   DOUBLE+6(2),9(R15)
*B     ITC$CONVERT
 SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
**    Input time character - Convert DOUBLE from character to
**                           TIME DEC (binary)
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 SPACE 2
ITC$CONVERT EQU *
 LA    R0,8                               Get length of input time
 LA    R1,DOUBLE                          Locate input time area
 BAS   R14,ENSURE_NUMERICS                Ensure its all valid nums
 LTR   R15,R15                            Valid?
 BNZ   I$INVALID_STRD                     No, gripe about it
*
 LA    R1,S_TIME                          Locate output area
 LA    R15,DOUBLE                         Locate input hex characters
 LA    R0,4                               Length of input string / 2
 BAS   R9,HEXTRAN                         Translate to hex value
 B     I$LB                               Done!
 SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
**    Input time Decimal - like from "TIME DEC" macro
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 SPACE 2
INPUT_TIME_DECIMAL EQU *
 CLI   DA#DATED_STRL,$DA#DATE_ITDEC4      HHMMSSTH ?
 BNE   I$INVALID_STRLD                    No, invalid
 MVC   S_TIME(4),0(R15)                   Move in Input X'HHMMSSTH'
 B     I$LB                               Leave
 SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
**        Time in binary - Seconds from midnight?
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 SPACE 2
INPUT_TIME_BINARY EQU *
         CLI   DA#DATED_STRL,$DA#DATE_ITBIN4
         BNE   I$INVALID_STRLT            Invalid?
         L     R5,0(R15)                  Get Time in R5
* Note: This code was liberated from Skip Abadie's BDATE program
         SLR   R4,R4                      CLEAR REMAINDER
         D     R4,=F'100'                 EXTRACT 1/100 SEC
         CVD   R4,DOUBLE                  MAKE DEC IN WORK AREA
         ZAP   DWA(5),DOUBLE              ACCUMULATE 1/100 SECS
         SR    R4,R4                      CLEAR REMAINDER
         D     R4,=F'60'                  EXTRACT SECONDS
         MH    R4,=H'100'                 SHIFT LEFT 2 POSITIONS
         CVD   R4,DOUBLE                  MAKE DEC IN WORK AREA
         AP    DWA(5),DOUBLE              BUILD SECONDS
         SR    R4,R4                      CLEAR REMAINDER
         D     R4,=F'60'                  EXTRACT MINUTES
         MH    R4,=H'10000'               SHIFT LEFT 4 POSITIONS
         CVD   R4,DOUBLE                  MAKE DEC IN WORK AREA
         AP    DWA(5),DOUBLE              BUILD MINUTES
         M     R4,=F'1000000'             MOVE LEFT 6 POSITIONS
         CVD   R5,DOUBLE                  EXTRACT HOURS IN WORK AREA
         AP    DWA(5),DOUBLE              BUILD HOURS
         LM    R2,R3,DWA                  Get time generated
         SLDA  R2,4                       It's four bits off...
         ST    R2,S_TIME                  Save the time to current loc
         B     I$LB                       Leave
 EJECT
***********************************************************************
***
**                Output Calendar processing
***
***********************************************************************
 SPACE 2
OUTPUT_DATE_CALENDAR EQU *
 BAS   R9,D$CHK                           Check date
 BAS   R9,LOCATE_STRING                   Locate output location
 LR    R5,R15                             Save output location
*
** Get month entry for this Gregorian Date
*
 PACK  DOUBLE(8),W_GDATE(2)               Pack the month "MMddccyy"
 CVB   R2,DOUBLE                          Make month binary
 PACK  DOUBLE(8),W_GDATE+4(4)             Pack the Year: "mmddCCYY"
 CVB   R4,DOUBLE                          Make Year binary
 BAS   R14,RETURN_MONTH_ENTRY             Get month entry
 LR    R6,R15                             Save address of month entry
*
** Clear area to blanks
*
 CLI   DA#DATED_STRL,$DA#DATE_ODCALV      Hex value
 BE    ODCAL$CLRV                         Yes, do it
 MVI   0(R5),C' '                         Move in blanks
 MVC   1($DA#DATE_ODCALC-1,R5),0(R5)      ..propagate it
*
 MVC   1(9,R5),TM_NAME-TM(R6)            Move in month Name
 MVC   $DA#DATE_ODCALC_WEEKL-4(4,R5),W_GDATE+4 Move in CCYY
 LA    R5,$DA#DATE_ODCALC_WEEKL(R5)       Bump to next "Week"
*
 MVC   0(C_HEADL,R5),C_HEAD               Move in heading line
 LA    R5,$DA#DATE_ODCALC_WEEKL(R5)       Bump to next "Week"
 B     ODCAL$CLRX                         Move on
ODCAL$CLRV EQU *
 MVI   0(R5),0                            Move in zero
 MVC   1($DA#DATE_ODCALV-1,R5),0(R5)      ..propagate it
ODCAL$CLRX EQU *
*
** Calculate the first day of the month and locate starting output
** location
*
 LA    R2,W_GDATE+0                       Locate "MM" in "MMDDCCYY"
 LA    R3,=C'01'                          Based on first day of month
 LA    R4,W_GDATE+4                       Locate "CCYY" in "MMDDCCYY"
 BAS   R9,RETURN_DOW                      Return the day of the week
*
 SLR   R1,R1                              Clear register
 IC    R1,TD_NUM-TD(R15)                  Get DOW number (start w/Sun)
 CLI   DA#DATED_STRL,$DA#DATE_ODCALV      Hex value
 BE    ODCAL$DSOX                         Yes, skip multiply
 MH    R1,=AL2($DA#DATE_ODCALC_DATEEL)    Offset for first day of month
ODCAL$DSOX EQU *
 AR    R5,R1                              Locate in output area
*
** Get number of days in month
*
 SLR   R1,R1                              Clear register
 IC    R1,TM_DIM-TM(R6)                   Get Days-in-Month
 CLI   DA#DATED_STRL,$DA#DATE_ODCALV      Hex value
 BE    ODCAL$VX                           Yes, finish up
 MH    R1,=AL2($DA#DATE_ODCALC_DATEEL)    Offset for first day of month
 BCTR  R1,0                               Decrement for EX
 EX    R1,ODCAL$MM                        Move numbers to output area
*
** Place "**" in the day of the month
*
 CLC   DA#DATED_TYPE(2),=AL2($DA#DATE_ODCALND)
 BE    CAL$X                              Yes...
 PACK  DOUBLE(8),W_GDATE+2(2)             Pack the month "mmDDccyy"
 CVB   R15,DOUBLE                         Make month binary
 BCTR  R15,0                              Decrement by 1
 MH    R15,=AL2($DA#DATE_ODCALC_DATEEL)   Offset for first day of month
 AR    R15,R5                             Locate day entry
 MVC   1(2,R15),=C'**'                    Move in placemark
CAL$X EQU *
 B    I$LB                                Return to loop
ODCAL$MM MVC   0(0,R5),C_MONTHC
*
** Hex value processing exit
** R1 has number of days
*
ODCAL$VX EQU *
 BCTR R1,0                                Decrement for EX
 EX   R1,ODCAL$VM                         Move in table
 B    I$LB                                Return to loop
ODCAL$VM MVC  0(0,R5),C_MONTHV
 EJECT
***********************************************************************
***
**                Output ISO Date processing
**
** Date format proposed by the International Standards Organization
** (ISO):
**
**   - The order in which year, month and day are expressed:
**     Year, then month, then day.
**
**   - The manner in which the three numbers, when written, are set
**     off from each other: The "-" sign is used to separate them.
**
**   - Whether the numbers less than 10 are written with a leading
**     zero:  Yes; for example the third is expressed as "03".
***
***********************************************************************
 SPACE 2
OUTPUT_DATE_ISO DS 0H
 BAS   R9,D$CHK                           Check date
 BAS   R9,LOCATE_STRING                   Locate output location
 BAS   R9,CLEAR_STRING                    Clear output to blanks
*
** Check length
*
 CLI   DA#DATED_STRL,$DA#DATE_ODISO10
 BE    ODI$S
 B     I$INVALID_STRL
*
**                   01234567       0123456789
** Convert W_GDATE ("mmddccyy") to "ccyy-mm-dd"
*
ODI$S  DS 0H                              "ccyy-mm-dd"
 MVC   0(4,R15),W_GDATE+4                 Get "ccyy"
 MVI   4(R15),C'-'
 MVC   5(2,R15),W_GDATE                   Move in month
 MVI   7(R15),C'-'
 MVC   8(2,R15),W_GDATE+2                 Move in day of the month
 LA    R15,10(R15)                        Bump past "ccyy-mm-dd"
 B     I$UPDATE_LENGTH                    Now, complete the length
 EJECT
***********************************************************************
***
**                Output Gregorian Date processing
***
***********************************************************************
 SPACE 2
OUTPUT_DATE_GREGORIAN EQU *
 BAS   R9,D$CHK                           Check date
 BAS   R9,LOCATE_STRING                   Locate output location
 BAS   R9,CLEAR_STRING                    Clear output to blanks
*
** Check length
*
 CLI   DA#DATED_STRL,$DA#DATE_ODGUS29
 BNL   ODG$F29
 CLI   DA#DATED_STRL,$DA#DATE_ODGUS23
 BNL   ODG$F23
 CLI   DA#DATED_STRL,$DA#DATE_ODGUS18
 BNL   ODG$F18
 CLI   DA#DATED_STRL,$DA#DATE_ODGEUR11   ODGUS12/ODGEUR11 are similiar
 BNL   ODG$F12
 CLI   DA#DATED_STRL,$DA#DATE_ODGUS10
 BNL   ODG$F10
 CLI   DA#DATED_STRL,$DA#DATE_ODGUS8T
 BE    ODG$F8T
 CLI   DA#DATED_STRL,$DA#DATE_ODGUS8
 BNL   ODG$F8
 CLI   DA#DATED_STRL,$DA#DATE_ODGUS6
 BNL   ODG$F6
 B     I$INVALID_STRL
*
** Output: "DayOfWeek, Month DD CCYY" (US)
**          or "DayofWeek DD Month CCYY" (European)
*
ODG$F29 EQU    *
*
** Output: "DOW, Month DD CCYY" (US) Â¦ "DOW, DD Month CCYY" (European)
*
ODG$F23 EQU    *
 ST    R15,PARMLIST                       Save output location
 LA    R2,W_GDATE+0                       Locate "MM" in "MMDDCCYY"
 LA    R3,W_GDATE+2                       Locate "DD" in "MMDDCCYY"
 LA    R4,W_GDATE+4                       Locate "CCYY" in "MMDDCCYY"
 BAS   R9,RETURN_DOW                      Return the day of the week
 LR    R1,R15                             Get T_DOW entry
 L     R15,PARMLIST                       Get output location
*
 CLI   DA#DATED_STRL,$DA#DATE_ODGUS29     Short form of DOW?
 BL    ODG$F23D                           Yes, move on
 SLR   R14,R14                            Clear register
 IC    R14,TD_NAMEL-TD(R1)                Get name length
 MVC   0(0,R15),TD_NAME-TD(R1)            ** Executed **
 EX    R14,*-6                            Move in day of the week
 LA    R15,1(R14,R15)                     Bump past it
 B     ODG$F23C
ODG$F23D EQU *
 MVC   0(3,R15),TD_NAME-TD(R1)            Move in Day of week (3 char)
 OC    0(3,R15),=CL3' '                   Ensure uppercase
 LA    R15,3(R15)                         Bump past it
ODG$F23C EQU *
 MVI   0(R15),C','                        Insert a comma
 LA    R15,2(R15)                         Bump past comma
ODG$F23CX EQU *
*
** Output: "Month DD CCYY" (US) Â¦  "DD month CCYY" (European)
*
ODG$F18 EQU    *
*
** Output: "MMM-DD-CCYY" (US) Â¦ "DD-MMM-CCYY" (European)
*
ODG$F12 EQU    *
 CLC   DA#DATED_TYPE(2),=AL2($DA#DATE_ODGEUR) European format?
 BNE   ODG$F12EDX                         No, move on
 MVC   0(2,R15),W_GDATE+2                 Get day of the month
 MVI   2(R15),C'-'                        Fix
 LA    R15,3(R15)                         Bump past it
*
ODG$F12EDX EQU *
 PACK  DOUBLE(8),W_GDATE(2)               Pack the month "MMddccyy"
 CVB   R2,DOUBLE                          Make month binary
 PACK  DOUBLE(8),W_GDATE+4(4)             Pack the Year: "mmddCCYY"
 CVB   R4,DOUBLE                          Make Year binary
 ST    R15,PARMLIST                       Save location
 BAS   R14,RETURN_MONTH_ENTRY             Return the month entry
 LR    R1,R15                             Get month entry
 L     R15,PARMLIST                       Get location
*
 CLI   DA#DATED_STRL,$DA#DATE_ODGUS18     Only need 3 characters?
 BL    ODG$F12T                           Yes, move on
 SLR   R14,R14                            Clear register
 IC    R14,TM_NAMEL-TM(R1)                Get month length
 MVC   0(0,R15),TM_NAME-TM(R1)            ** Executed **
 EX    R14,*-6                            Move in Month name
 LA    R15,1(R14,R15)                     Bump past it
 CLC   DA#DATED_TYPE(2),=AL2($DA#DATE_ODGEUR) European format?
 BNE   ODG$F12MD                          No, don't need dash
 MVI   0(R15),C'-'                        Insert a dash
ODG$F12MD EQU *
 LA    R15,1(R15)                         Bump past it
 CLC   DA#DATED_TYPE(2),=AL2($DA#DATE_ODGEUR) European format?
 BE    ODG$F10Y                           Yes, don't need Date again
 B     ODG$F12D                           Move on
ODG$F12T EQU *
 MVC   0(3,R15),TM_NAME-TM(R1)            Move in month name
 OC    0(3,R15),=CL3' '                   Ensure uppercase
 CLI   DA#DATED_STRL,$DA#DATE_ODGUS18     Need dash?
 BH    ODG$F18DL                          No, move on
 MVI   3(R15),C'-'                        Fix
ODG$F18DL EQU *
 CLC   DA#DATED_TYPE(2),=AL2($DA#DATE_ODGEUR) European format?
 BNE   ODG$F12EMX                         No, move on
 LA    R15,4(R15)                         Bump past "MMM "
 B     ODG$F10Y                           Do year now
ODG$F12EMX EQU *
 LA    R15,4(R15)                         Bump past "MMM "
ODG$F12D EQU *
 MVC   0(2,R15),W_GDATE+2                 Get day of the month
 LA    R15,3(R15)                         Bump past month
 CLI   DA#DATED_STRL,$DA#DATE_ODGUS18     Need comma?
 BL    ODG$F12DD                          No, move on
 CLC   DA#DATED_TYPE(2),=AL2($DA#DATE_ODGEUR) European format?
 BE    ODG$F10Y                           Yes, move on
 BCTR  R15,0                              Backup over extra space
 MVI   0(R15),C','                        Insert a comma
 LA    R15,2(R15)                         Bump past comma
 B     ODG$F10Y
ODG$F12DD EQU *
 BCTR  R15,0                              Backup over extra space
 MVI   0(R15),C'-'                        Insert a comma
 LA    R15,1(R15)                         Bump past comma
 B     ODG$F10Y
*
** Output: "MM/DD/CCYY" (US) Â¦ "DD/MM/CCYY" (European)
*
ODG$F10 EQU *
*
** Output: "MM/DD/YY" (US) Â¦ "DD/MM/YY" (European)
*
ODG$F8 EQU *
 CLC   DA#DATED_TYPE(2),=AL2($DA#DATE_ODGEUR) European format?
 BNE   ODG$F8EX                           No, do US
 MVC   0(2,R15),W_GDATE+2                 Move in day of the month
 LA    R15,2(R15)                         Bump past it
 MVI   0(R15),C'/'                        Slash
 MVC   1(2,R15),W_GDATE                   Move in month
 B     ODG$F8UX                           Move on
ODG$F8EX EQU *
 MVC   0(2,R15),W_GDATE                   Move in month
 LA    R15,2(R15)                         Bump past it
 MVI   0(R15),C'/'                        Slash
 MVC   1(2,R15),W_GDATE+2                 Move in day of the month
ODG$F8UX EQU *
 MVI   3(R15),C'/'                        Insert delimiter
 LA    R15,4(R15)                         Bump past "/xx/"
*
 CLI   DA#DATED_STRL,$DA#DATE_ODGUS8      Doing mm/dd/yy code?
 BNH   ODG$F8Y                            Yes, get the year
ODG$F10Y EQU *
 MVC   0(2,R15),W_GDATE+4                 Get two byte century
 LA    R15,2(R15)                         Bump past the century
ODG$F8Y EQU    *
 MVC   0(2,R15),W_GDATE+6                 Move in year - "MMDDCCYY"
 LA    R15,2(R15)                         Bump to Past year
 B     I$UPDATE_LENGTH                    Now, complete the length
*
** Output: "MMDDCCYY" (US) Â¦ "DDMMCCYY" (European)
*
ODG$F8T EQU    *
 CLC   DA#DATED_TYPE(2),=AL2($DA#DATE_ODGEUR) European format?
 BE    ODG$F8TE                           Yes, do year now
 MVC   0(8,R15),W_GDATE                   Move "MMDD"
 LA    R15,8(R15)                         Bump past it
 B     I$UPDATE_LENGTH                    Now, complete the length
*
ODG$F8TE EQU *
 MVC   0(2,R15),W_GDATE+2                 Get DD
 MVC   2(2,R15),W_GDATE                   Get MM
 MVC   4(4,R15),W_GDATE+4                 Get CCYY
 LA    R15,8(R15)                         Bump past it
 B     I$UPDATE_LENGTH                    Now, complete the length
*
** Output: "MMDDYY" (US) "DDMMYY" (European)
*
ODG$F6 EQU     *
 CLC   DA#DATED_TYPE(2),=AL2($DA#DATE_ODGEUR) European format?
 BE    ODG$F6E                            Yes, do year now
 MVC   0(4,R15),W_GDATE                   Move "MMDD"
 MVC   4(2,R15),W_GDATE+6                 Get "YY" from "MMDDCCYY"
 LA    R15,6(R15)                         Bump past it
 B     I$UPDATE_LENGTH                    Now, complete the length
*
ODG$F6E EQU *
 MVC   0(2,R15),W_GDATE+2                 Get DD
 MVC   2(2,R15),W_GDATE                   Get MM
 MVC   4(2,R15),W_GDATE+6                 Get YY
 LA    R15,6(R15)                         Bump past it
 B     I$UPDATE_LENGTH                    Now, complete the length
 EJECT ,
***********************************************************************
***
**       Julian (IBM) processing
***
***********************************************************************
 SPACE 2
OUTPUT_DATE_JULIAN EQU *
 BAS   R9,D$CHK                           Check the date
 BAS   R9,LOCATE_STRING                   Locate output location
 BAS   R9,CLEAR_STRING                    Clear output to blanks
 CLI   DA#DATED_STRL,$DA#DATE_ODJUL8
 BNL   ODJ$F8
 CLI   DA#DATED_STRL,$DA#DATE_ODJUL6
 BNL   ODJ$F6
 CLI   DA#DATED_STRL,$DA#DATE_ODJUL5
 BNL   ODJ$F5
 CLI   DA#DATED_STRL,$DA#DATE_ODJUL3
 BNL   ODJ$F3
 B     I$INVALID_STRL                     Branch to invalid length code
*
** Output: CCYY.DDD
*
ODJ$F8 EQU *
 LA    R1,S_JDATE                         Locate century input area
 MVC   0(2,R15),W_GDATE+4                 Get two century: "MMDDCCYY"
 LA    R15,2(R15)                         Bump past the century
*
** Output: YY.DDD
*
ODJ$F6 EQU *
* We need edit pattern that works every time here!!!!!
 MVC   DWA(7),=X'40,20,20,4B,20,20,20'    Move in edit pattern
 ED    DWA(7),S_JDATE+1                   Edit the julian date
 OI    DWA+1,X'F0'       <-| 00.xxx and | Ensure no leading spaces
 OI    DWA+2,X'F0'      <--| 00.001 fail| Ensure no leading spaces
 MVI   DWA+3,C'.'      <---| without    | Ensure dot
 OI    DWA+4,X'F0'    <----| this       | Ensure no leading spaces
 OI    DWA+5,X'F0'   <-----| kludge!    | Ensure no leading spaces
ODJ$F6KX EQU *
 MVC   0(6,R15),DWA+1                     Move number to output addr
 LA    R15,6(R15)                         Bump past it
 B     I$UPDATE_LENGTH                    Now, complete the length
*
** Output: YYDDD
*
ODJ$F5 EQU *
 UNPK  0(5,R15),S_JDATE+1(3)              Unpack to zoned from packed
 OI    4(R15),C'0'                        Fix sign byte
 LA    R15,5(R15)                         Bump past it
 B     I$UPDATE_LENGTH                    Now, complete the length
*
** Output: DDD
*
ODJ$F3 DS  0H
 UNPK  0(3,R15),S_JDATE+2(2)              Unpack to zoned from packed
 OI    2(R15),C'0'                        Fix sign byte
 LA    R15,3(R15)                         Bump past it
 B     I$UPDATE_LENGTH                    Now, complete the length
 EJECT
***********************************************************************
***
**                Output Day of the week
***
***********************************************************************
 SPACE 2
OUTPUT_DATE_DOW EQU *
 BAS   R9,D$CHK                           Check date
 BAS   R9,LOCATE_STRING                   Locate output location
 BAS   R9,CLEAR_STRING                    Clear output to blanks
*
 ST    R15,PARMLIST                       Save output location
 LA    R2,W_GDATE+0                       Locate "MM" in "MMDDCCYY"
 LA    R3,W_GDATE+2                       Locate "DD" in "MMDDCCYY"
 LA    R4,W_GDATE+4                       Locate "CCYY" in "MMDDCCYY"
 BAS   R9,RETURN_DOW                      Return the day of the week
 LR    R1,R15                             Get T_DOW entry
 L     R15,PARMLIST                       Get output location
*
** "DayOfWeek"
*
 CLI   DA#DATED_STRL,$DA#DATE_ODDOW9      Short form of DOW?
 BL    ODD$3                              Yes, move on
 SLR   R14,R14                            Clear register
 IC    R14,TD_NAMEL-TD(R1)                Get name length
 MVC   0(0,R15),TD_NAME-TD(R1)            ** Executed **
 EX    R14,*-6                            Move in day of the week
 LA    R15,1(R14,R15)                     Bump past it
 B     I$UPDATE_LENGTH                    Now, complete the length
*
** "DOW"
*
ODD$3    EQU *
 CLI   DA#DATED_STRL,$DA#DATE_ODDOW3      Shorter form of Dow?
 BL    ODD$1                              Yes, move on
 MVC   0(3,R15),TD_NAME-TD(R1)            Move in Day of week (3 char)
 OC    0(3,R15),=CL3' '                   Make uppercase
 LA    R15,3(R15)                         Bump past it
 B     I$UPDATE_LENGTH                    Now, complete the length
*
** Number representation of day of week
*
ODD$1 EQU *
 MVC   0(1,R15),TD_NUM-TD(R1)             Get day of the week
 LA    R15,1(R15)                         Bump past the number
 B     I$UPDATE_LENGTH                    Now, complete the length
 EJECT
***********************************************************************
***
**                Output Month Name
***
***********************************************************************
 SPACE 2
OUTPUT_DATE_MONTHN EQU *
 BAS   R9,D$CHK                           Check date
 BAS   R9,LOCATE_STRING                   Locate output location
 BAS   R9,CLEAR_STRING                    Clear output to blanks
*
** Get the month name
*
 PACK  DOUBLE(8),W_GDATE(2)               Pack the month "MMddccyy"
 CVB   R2,DOUBLE                          Make month binary
 PACK  DOUBLE(8),W_GDATE+4(4)             Pack the Year: "mmddCCYY"
 CVB   R4,DOUBLE                          Make Year binary
 ST    R15,PARMLIST                       Save location
 BAS   R14,RETURN_MONTH_ENTRY             Return the month entry
 LR    R1,R15                             Get month entry
 L     R15,PARMLIST                       Get location
*
** Long version: "September"
*
 CLI   DA#DATED_STRL,$DA#DATE_ODMONTHN9   Only need 3 characters?
 BL    ODM$3                              Yes, move on
 SLR   R14,R14                            Clear register
 IC    R14,TM_NAMEL-TM(R1)                Get month length
 MVC   0(0,R15),TM_NAME-TM(R1)            ** Executed **
 EX    R14,*-6                            Move in Month name
 LA    R15,2(R14,R15)                     Bump past it
 B     I$UPDATE_LENGTH                    Now, complete the length
*
** Short version: "SEP"
*
ODM$3 EQU *
 MVC   0(3,R15),TM_NAME-TM(R1)            Move in day of the month
 OC    0(3,R15),=CL3' '                   Ensure uppercase
 B     I$UPDATE_LENGTH                    Now, complete the length
 EJECT ,
***********************************************************************
***
**               Output time processing
***
***********************************************************************
 SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
**                Military time: 00:00 - 23:59
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 SPACE 2
OUTPUT_TIME_MILITARY EQU *
         BAS   R9,T$CHK                   Check the time
         BAS   R9,LOCATE_STRING           Locate output location
         BAS   R9,CLEAR_STRING            Clear output to blanks
         CLI   DA#DATED_STRL,$DA#DATE_OTIMEM11
         BNL   OTM$F5
         CLI   DA#DATED_STRL,$DA#DATE_OTIMEM8
         BNL   OTM$F5
         CLI   DA#DATED_STRL,$DA#DATE_OTIMEM6C
         BNL   OTM$F6C
         CLI   DA#DATED_STRL,$DA#DATE_OTIMEM5
         BNL   OTM$F5
         B     I$INVALID_STRL             Branch to invalid length code
OTM$F5   EQU   *                          HH:MM
         MVC   0(2,R15),W_TIMEM           Move in HH
         MVI   2(R15),C':'                Insert :
         MVC   3(2,R15),W_TIMEM+2         Move in MM
         LA    R15,5(R15)                 Bump past HH:MM
         CLI   DA#DATED_STRL,$DA#DATE_OTIMEM5 Want more?
         BNH   I$UPDATE_LENGTH            No, move on
OTM$F8   EQU   *                          HH:MM:SS
         MVI   0(R15),C':'                Insert :
         MVC   1(2,R15),W_TIMEM+4         Move in SS
         LA    R15,3(R15)                 Bump past :SS
         CLI   DA#DATED_STRL,$DA#DATE_OTIMEM8 Want more?
         BNH   I$UPDATE_LENGTH            Want more?
OTM$F11  EQU   *                          HH:MM:SS.TH
         MVI   0(R15),C'.'                Insert .
         MVC   1(2,R15),W_TIMEM+6         Move in th
         LA    R15,3(R15)                 Bump past .th
         B     I$UPDATE_LENGTH            Now, complete the length
OTM$F6C  EQU   *                          HHMMSSth
         MVC   0(8,R15),W_TIMEM           Move in complete string
         LA    R15,8(R15)                 Bump past it
         B     I$UPDATE_LENGTH            Now, complete the length
 SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
**        Standard time: 12:00 - 11:59 AM / 12:00 - 11:59 PM
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 SPACE 2
OUTPUT_TIME_STANDARD EQU *
         BAS   R9,T$CHK                   Check the time
*
         LA    R3,W_TIMEM                 Locate Military time area
         BAS   R9,T$RETURN_STIME          Get W_SHOUR, W_STYPE
*
         BAS   R9,LOCATE_STRING           Locate output location
         BAS   R9,CLEAR_STRING            Clear output to blanks
         CLI   DA#DATED_STRL,$DA#DATE_OTIMES5 Minimum length check
         BL    I$INVALID_STRL             Branch to invalid length code
OTS$F5   EQU   *                          HH:MM
         MVC   0(2,R15),W_SHOUR           Move in HH
         MVI   2(R15),C':'                Insert :
         MVC   3(2,R15),W_TIMEM+2         Move in MM
         LA    R15,5(R15)                 Bump past HH:MM
         CLI   DA#DATED_STRL,$DA#DATE_OTIMES5 Want more?
         BNH   I$UPDATE_LENGTH            No, move on
         CLI   DA#DATED_STRL,$DA#DATE_OTIMES8 Want more?
         BNH   OTS$FT                     Want more?
         MVI   0(R15),C':'                Insert :
         MVC   1(2,R15),W_TIMEM+4         Move in SS
         LA    R15,3(R15)                 Bump past :SS
         CLI   DA#DATED_STRL,$DA#DATE_OTIMES11 More?
         BNH   OTS$FT                     Want more?
         MVI   0(R15),C'.'                Insert .
         MVC   1(2,R15),W_TIMEM+6         Move in th
         LA    R15,3(R15)                 Bump past .th
OTS$FT   EQU   *
         MVC   1(2,R15),W_STYPE           Move in type: AM or PM
         LA    R15,3(R15)                 Bump past type
         B     I$UPDATE_LENGTH            Now, complete the length
         EJECT
***********************************************************************
***
**       Misc date internal subroutines
***
***********************************************************************
 SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
**   Return Month entry and return leap year
**
**   Input: R2 - Month in binary
**          R4 - Year in binary (including century)
**
**   Output: R0  - 0 if leap year Â¦ Â¬0 if not
**           R15 - T_MONTH entry address
**
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 SPACE 2
RETURN_MONTH_ENTRY EQU *
 BAS   R15,RETURN_LEAP_YEAR               Check if this is a leap year
*=> R0 will have 0 for leap year or Â¬0 for non-Leap year
*
** Locate month entry, correct for leap year
*
 LR    R1,R2                              Get month
 BCTR  R1,0                               Decrement by 1
 MH    R1,=AL2(TML)                       Calculate offset in table
 LA    R15,T_MONTH                        Locate table
 AR    R15,R1                             Locate table entry
*
 LTR   R0,R0                              Leap year?
 BNZ   RME$X                              Nope, move on
 MVC   W_MONTHE(TML),0(R15)               Move in Entry
 LA    R15,W_MONTHE                       Locate entry
 CLI   TM_NUM-TM(R15),2                   February?
 BNE   RME$FX                             Nope, move on
 MVI   TM_DIM-TM(R15),29                  Feb has 29 days in leap year
 B     RME$X                              Finished...leave
RME$FX EQU *
 CLI   TM_NUM-TM(R15),1                   January?
 BE    RME$X                              Yes, move on
 SLR   R1,R1                              Clear register
 LH    R1,TM_PDAYS-TM(R15)                Get previous number of days
 LA    R1,1(R1)                           Increment for Feb 29...
 STH   R1,TM_PDAYS-TM(R15)                Save previous number of days
RME$X  EQU *
 BSM   0,R14                              Return to caller
 SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
**                  Return Leap year indication in R0
**
**   Input: R4 - CCYY ... year in binary w/Century -- Ex. 1962
**
**   Output: R0 will have 0 for leap year or Â¬0 for non-Leap year
**
** Tested with 1900 (not a leap year) and 2000 (is a leap year) and
** a few other known leap years like 1992, 1994, 2004, etc.
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 SPACE 2
RETURN_LEAP_YEAR EQU *
 SLR   R0,R0                              Clear register
 LR    R1,R4                              Get year
 D     R0,=F'4'                           Divide by 4 for leap year
 LTR   R0,R0                              Evenly divisable?
 BNZ   RLY$X                              No, all bets are off
*-At this point, the year IS divisable by 4 so it still looks like a
* a leap year, but let's check out the 100 test.
 SLR   R0,R0                              Clear reg for divide
 LR    R1,R4                              Get year back
 D     R0,=F'100'                         Divide by 100
 LTR   R0,R0                              Evenly divisable by 100?
 BNZ   RLY$0                              No, it's a leap year for sure
*-At this point, the year IS divisable by 4 and 100, if it is divisable
* by 400 it's a leap year
 SLR   R0,R0                              Clear reg for divide
 LR    R1,R4                              Get year back
 D     R0,=F'400'                         Do 400 test
 B     RLY$X                              Leave, results in R0
RLY$0  DS 0H
 SLR   R0,R0                              Failed 100 test: a leap year
RLY$X  DS 0H
 BSM   0,R15                              Return to caller
 SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
**        Convert Julian date (character) to Packed
**
**    Input: R3 - Address of Z'DDD' - Day of the year
**           R4 - Address of Z'CCYY' - Year w/century
**           R6 - Address of X'ccyydddF' (output)
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 SPACE 2
RETURN_JULIAN_PACKED EQU *
 MVC   DWA(2),2(R4)                       Move in YY
 MVC   DWA+2(3),0(R3)                     Move in DDD
 PACK  0(4,R6),DWA(5)                     Make YYDDD packed
*
CJCP$CENT EQU *
 CLC   0(2,R4),=C'19'                     1900-1999?
 BE    CJCP$C0
 CLC   0(2,R4),=C'20'                     2000-2099?
 BE    CJCP$C1
 CLC   0(2,R4),=C'21'                     2100-2199?
 BE    CJCP$C2
CJCP$C0 EQU *
 MVI   0(R6),X'00'                        1900-1999 = Century 0
 BSM   0,R9
CJCP$C1 EQU *
 MVI   0(R6),X'01'                        2000-2099 = Century 1
 BSM   0,R9
CJCP$C2 EQU *
 MVI   0(R6),X'02'                        2100-2199 = Century 2
 BSM   0,R9
 SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
**           Ensure Numerics
**
**            Input: R1 - Numeric input string address
**                   R0 - Numeric input string length
**            Output: R15 - 0 if valid or Â¬= 0 if not
**
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 SPACE 2
ENSURE_NUMERICS EQU *
 LA    R15,1                              Set return code
EN$L EQU *
 CLI   0(R1),C'0'
 BL    EN$X
 CLI   0(R1),C'9'
 BH    EN$X
 LA    R1,1(R1)
 BCT   R0,EN$L
 SLR   R15,R15
EN$X EQU *
 BSM   0,R14
 SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
**           Ensure valid Julian Packed date
**
**              Byte 1 - Century indicator: Hex 0-2
**              Byte 2-3 Packed number: PL3'YYDDD'
**
**            Input: R3 - Packed Julian date
**            Output: R15 - 0 if valid or Â¬= 0 if not
**
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 SPACE 2
ENSURE_VALID_JULIAN EQU *
 LA    R15,1                              Set return code
*
** Check century and sign bytes
*
 CLI   0(R3),X'02'                        Only Century 0-2 valid...
 BH    EVJ$X                              It's invalid
*
 TM    3(R3),X'0C'                        Valid sign?
 BO    EVJ$VSX                            Yes, move on
 TM    3(R3),X'0F'                        Valid sign?
 BNO   EVJ$X                              Nope, move on
EVJ$VSX EQU *
*
** Check for valid packed numbers: 0-9 only, skip check of sign byte
*
 UNPK  DOUBLE(7),1(4,R3)                       **
 MVZ   DOUBLE(6),=X'00,00,00,00,00,00,00,00'   *** Hex convert
 TR    DOUBLE(6),=C'0123456789ABCDEF'          **
 LA    R1,DOUBLE                          Locate hex EBCDIC area
 LA    R0,5                               Length to check
EVJ$VPNL EQU *
 CLI   0(R1),C'0'                         Valid numeric?
 BL    EVJ$X                              Nope, invalid
 CLI   0(R1),C'9'                         Valid numeric?
 BH    EVJ$X                              Nope, invalid
 LA    R1,1(R1)                           Bump to next byte
 BCT   R0,EVJ$VPNL                        Repeat
*
** Get the year in binary and Leap year indicator
*
 BAS   R14,RETURN_YEAR                    Get CCYY in R4
 BAS   R15,RETURN_LEAP_YEAR               Check if this is a leap year
*=> R0 will have 0 for leap year or Â¬0 for non-Leap year
*
** Obtain the day of the year in binary
*                                                -----DOUBLE-----
 XC    DOUBLE(8),DOUBLE                   Clear: 0000000000000000
 MVC   DOUBLE+6(2),2(R3)                  Get:   000000000000DDDF
 CVB   R1,DOUBLE                          Make day of year binary
*
** Check for valid number of days in the year
*
 LA    R15,365                            Default number of days
 LTR   R0,R0                              Leap year?
 BNZ   EVJ$LYX                            Nope, move on
 LA    R15,1(R15)                         Set max number of days to 366
EVJ$LYX EQU *
 CR    R1,R15                             Input date more than max?
 BH    EVJ$X                              Yes, its invalid
 SLR   R15,R15                            Clear register
EVJ$X  EQU *
 BSM   0,R9
 SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
**    Return the Day-of-the-Year from Gregorian date
**
**    Input: R2 - Input Month                   ZL2'03'
**           R3 - Input Day of month            ZL2'06'
**           R4 - Input Year (with century)     ZL4'1962
**           R6 - Output Day-of-Year            ZL4'0065'
**
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 SPACE 2
RETURN_DAY_OFTHE_YEAR EQU *
 STM   R2,R4,PARMLIST                     Save parameter values
*
** Ensure that the month and day-of-month meet min. requirements
*
 CLC   0(2,R2),=C'00'                     Validate Month
 BE    I$INVALID_STRD
 CLC   0(2,R2),=C'12'                     Validate month
 BH    I$INVALID_STRD
*
 CLC   0(2,R3),=C'00'                     Validate Day of the month
 BE    I$INVALID_STRD
 CLC   0(2,R3),=C'31'                     Validate Day of the month
 BH    I$INVALID_STRD
*
** Locate the month entry for this month
*
 PACK  DOUBLE(8),0(2,R2)                  Convert month to packed
 CVB   R2,DOUBLE                          Convert from packed to binary
 PACK  DOUBLE(8),0(4,R4)                  Convert year to packed
 CVB   R4,DOUBLE                          Convert from packed to binary
*
 BAS   R14,RETURN_MONTH_ENTRY             Locate month entry
*=> R15 points to T_MONTH entry...
*
 SLR   R0,R0                              Clear register
 IC    R0,TM_DIM-TM(R15)                  Obtain days in month
*
 L     R3,PARMLIST+4                      Get input Day-Of-Month addr
 PACK  DOUBLE(8),0(2,R3)                  Convert day to packed
 CVB   R1,DOUBLE                          Convert from packed to binary
*
 CR    R1,R0                              Check days in month...
 BH    I$INVALID_STRD                     Too high, leave
*
** Save the date into output
*
 SLR   R0,R0                              Clear register
 LH    R0,TM_PDAYS-TM(R15)                Obtain Previous days in year
 AR    R1,R0                              Add current day to prev. days
*
 CVD   R1,DOUBLE                          Convert Day of the year
 UNPK  0(4,R6),DOUBLE+6(2)                Make it zoned: 00DDD
 OI    3(R6),C'0'                         Fix sign byte
*
 LM    R2,R4,PARMLIST                     Save parameter values
 BSM   0,R9
 SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
**       Process the time stamp value to output time & date
**
**   Input: R3 - Input double word value
**          R5 - Output time: F
**          R6 - Output Date: X'CCYYDDDF'
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 SPACE 2
CONVERT_TIMESTAMP EQU *
*
** Use the STCKCON macro if we are on a MVS 4.1 system or higher
*
         L     R1,CVTPTR
         TM    CVTOSLV0-CVTMAP(R1),CVTH4410
         BNO   CT$OLD
         MVC   PARMLIST(C_STCKL),C_STCK
         STCKCONV STCKVAL=(3),            Convert TOD                  @
               CONVVAL=DWA,               ..Output Time and date       @
               TIMETYPE=DEC,              ..Output time format         @
               DATETYPE=YYYYDDD,          ..Output Date format         @
               MF=(E,PARMLIST)
         LTR   R15,R15
         BNZ   CT$X
         L     R1,DWA+8                   Get "0yyyyddd"
         SLL   R1,4                       Make it "yyyyddd0"
         O     R1,=X'0000000F'            Make it "yyyydddF"
         CLM   R1,B'1000',=X'19'
         BE    CT$Y19
         CLM   R1,B'1000',=X'20'
         BE    CT$Y20
         CLM   R1,B'1000',=X'21'
         BE    CT$Y21
*-Invalid century, use x'00'
CT$Y19   DS    0H
         ICM   R1,B'1000',=X'00'          CC=00 for 19
         B     CT$YX
CT$Y20   DS    0H
         ICM   R1,B'1000',=X'01'          CC=01 for 20
         B     CT$YX
CT$Y21   DS    0H
         ICM   R1,B'1000',=X'02'          CC=02 for 21
CT$YX    DS    0H
         ST    R1,0(R6)                   Save Julian date "ccyydddF"
         MVC   0(4,R5),DWA                Save Time
CT$X     DS    0H
         BSM   0,R9
*
** Here we do the TOD conversion ourself.
**
** There's a bug with this code: it only does HH:MM - need SS:TH...
*
CT$OLD   DS    0H
         LM    R0,R1,0(R3)                Load value into work regs
         SRDL  R0,12                      Align to micro seconds
         D     R0,=A(1000*1000*60)        R1 = MM
         SR    R0,R0
         D     R0,=F'60'                  R1 = HH
         STCM  R0,B'0001',1(R5)           Save MM
         SR    R0,R0
         D     R0,=F'24'                  R1 = DD
         STCM  R0,B'0001',0(R5)           Save HH
*
** NOW DO DATE
*
         SR    R0,R0
         D     R0,=A(365*4+1)             # DAYS BETWEEN LEAPS
         LR    R15,R1                     R15 = # 4 YEAR INTERVALS
         AH    R0,=H'2'                   DAYS RELATIVE TO 1
         CH    R0,=H'366'                 MORE THAN 1 YEAR
         BH    TS$01                      YES, DO IT
         SR    R1,R1                      INIT YEAR COUNTER
         B     TS$02
TS$01    EQU   *
         LR    R1,R0                      R1 = DAYS SINCE JAN 1 OF LEAP
         SH    R1,=H'367'                 ALLOW FOR LEAP YEAR
         SR    R0,R0
         D     R0,=F'365'                 R1 = YEARS R0=DAYS
         AH    R1,=H'1'                   ADD BACK IN LEAP YEAR
         AH    R0,=H'1'                   ADD BACK IN DAY
TS$02    EQU   *
         SLL   R15,2                      # OF YEARS BEFORE THESE 4
         AR    R1,R15                     ADD THEM TO YEARS IN PERIOD
         STCM  R1,B'0001',1(R6)           SAVE YEAR
         STCM  R0,B'0011',2(R6)           SAVE DAYS
*
         SLR   R0,R0                      CLEAR REGISTER
         IC    R0,1(R6)                   R0 = 00,00,00,YY
         MH    R0,=H'1000'                R0 = 00,YY,00,00
         AH    R0,2(R6)                   R0 = 00,YY,DD,DD
         CVD   R0,DOUBLE                  CONVERT TO PACKED DECIMAL
         MVC   0(4,R6),DOUBLE+4           Save as packed
*
** Time is in Binary, make it packed and save into current time
*
         SLR   R1,R1                      CLEAR REG
         IC    R1,0(R5)                   GET HH
         MH    R1,=H'1000'                R1 = 00,HH,00,00
         SLR   R14,R14                    CLEAR REG
         IC    R14,1(R5)                  GET MM
         MH    R14,=H'10'                 R14=00,00,MM,00
         AR    R1,R14                     R1= 00,HH,MM,00
         CVD   R1,DOUBLE                  DOUBLE=00,00,00,00,HH,MM,0B
         MVC   0(2,R5),DOUBLE+5
*
         SLR   R15,R15
         BSM   0,R9
 SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
**     Date check: IF S_JDATE is zero, seed it with current date
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 SPACE 2
D$CHK EQU *
 CLI   S_JDATE,$DA#DATE_INVALID           Invalid Input Date?
 BE    I$LB                               Yes, skip output processing
*
 CLC   S_JDATE(4),=X'00,00,00,00'         Zero?
 BNE   D$CHKTMX                           No, move on
 TIME  ,                                  Get current time/date
 ST    R1,S_JDATE                         Save date
D$CHKTMX EQU *
*
** Convert the Julian date to Gregorian
*
 ST    R9,PARMLIST+20                     Save return address
 LA    R3,S_JDATE                         Locate the current date
 LA    R6,W_GDATE                         Locate output gregorian date
 BAS   R9,D$RETURN_GREGORIAN_DATE         Return the Gregorian Date
 L     R9,PARMLIST+20                     Get return address
*
** Return to caller
*
D$CHKX EQU *
 BSM   0,R9                               Return to caller
 SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
**  Return Day-of-the-Week table entry
**
**  Input: R2 - ZL2'03'     - Month
**         R3 - ZL2'06'     - Day
**         R4 - ZL4'1962'   - Year
**
**  Output: R15 - T_DOW entry address
**
**        N = D + 2M + 3(M+1)/5 + Y + Y/4 - Y/100 + Y/400 + 2
**
**        WHERE M = 3-14 (JAN,FEB ARE 13,14 OF Y-1)
**              N/7 LEAVES REMAINDER 0-6, 0 INDICATING SATURDAY
**
**  Note: this was "liberated" from CBT tape, file 316
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 SPACE 2
RETURN_DOW EQU *
 PACK DOUBLE(8),0(2,R2)
 CVB  R14,DOUBLE
**
 PACK DOUBLE(8),0(2,R3)
 CVB  R1,DOUBLE
**
 PACK DOUBLE(8),0(4,R4)
 CVB  R15,DOUBLE
*
         CH    R14,=H'2'           JAN OR FEB?
         BH    WEEKMMOK
         BE    WEEKFEB
         LA    R14,13              SET M=13
         B     WEEKYMIN
WEEKFEB  LA    R14,14              SET M=14
WEEKYMIN BCTR  R15,0               SET Y = Y-1
WEEKMMOK LR    R0,R14              COPY M
         ALR   R0,R0               GET 2M
         ALR   R1,R0               SET N = N + 2M
         LR    R0,R15              SAVE REDEFINED Y
         SPACE
         LA    R14,1(,R14)         GET M+1
         MH    R14,=H'3'           GET 3(M+1)
         SRDL  R14,32              SHIFT INTO R15, ZERO R14
         D     R14,=F'5'           GET 3(M+1)/5 IN R15
         ALR   R1,R15              SET N = N + 3(M+1)/5
         SPACE
         LR    R15,R0              GET Y
         ALR   R1,R15              SET N = N + Y
         SLR   R14,R14             ZERO R14
         D     R14,=F'4'           GET Y/4
         ALR   R1,R15              SET N = N + Y/4
         SPACE
         LR    R15,R0              GET Y
         SLR   R14,R14             ZERO R14
         D     R14,=F'100'         GET Y/100
         SLR   R1,R15              SET N = N - Y/100
         SPACE
         LR    R15,R0              GET Y
         SLR   R14,R14             ZERO R14
         D     R14,=F'400'         GET Y/400
         ALR   R1,R15              SET N = N + Y/400
         LA    R15,2               GET 2
         ALR   R1,R15              SET N = N + 2
         SLR   R0,R0               ZERO R0
         D     R0,=F'7'            SET N = N/7
*
         MH    R0,=AL2(TDL)        Calculate offset of entry in table
         LA    R15,T_DOW           Point to table
         AR    R15,R0              Point to name
         LR    R14,R0              Save day of the week
         BSM   0,R9                Return to caller
 SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
**   Return Gregorian date from Julian (packed)
**
**   Input: R3 - Address of input field: "X'00YYDDDF"
**          R6 - Address of output field: CL8'MMDDCCYY'
**
**   Enhancement queue:
**   - Recognize the special julian dates: 99000 98000 99365...
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 SPACE 2
D$RETURN_GREGORIAN_DATE EQU *
 ST    R3,PARMLIST                        Save input date address
 ST    R9,PARMLIST+4                      Save return address
*
** Get the year and place into the output area
*
 BAS   R14,RETURN_YEAR                    Return CCYY in R4
 CVD   R4,DOUBLE                          Convert to Packed
 UNPK  4(4,R6),DOUBLE+5(3)                Convert to Zoned
 OI    4+3(R6),C'0'                       Fix sign byte
*
** Convert 'DDDF in X'cc,yy,DD,DF' to binary
*                                                0 1 2 3  4 5 6 7
 XC    DOUBLE(8),DOUBLE                   Clear: 00000000 00000000
 MVC   DOUBLE+6(2),2(R3)                  Get:   00000000 0000DDDF
 CVB   R3,DOUBLE                          Make day of year binary
*
** Loop thru month table entries for this Day-of-Year
*
 LA    R2,1                               Locate month entry
D$RGDL EQU *
 BAS   R14,RETURN_MONTH_ENTRY             Return Month entry: R2 & R4
*=> R15 has month entry...
 CLM   R3,B'0011',TM_PDAYS-TM(R15)        Check out previous days
 BNH   D$RGDLX                            Less, current month is good
 LA    R2,1(R2)                           Bump to next entry
 B     D$RGDL                             Repeat
*
** Calculate the Day in the month and move it and Month number
*
D$RGDLX EQU *
 BCTR  R2,0                               Decrement to previous month
 BAS   R14,RETURN_MONTH_ENTRY             Return Month entry: R2 & R4
 SH    R3,TM_PDAYS-TM(R15)                Day of the month = DOY - prev
 CVD   R3,DOUBLE                          Make Day-of-month packed
 UNPK  2(2,R6),DOUBLE+6(2)                Unpack it into zoned decimal
 OI    2+1(R6),C'0'                       Fix sign byte
*
 MVC   0(2,R6),TM_NUMC-TM(R15)            Move in MM
*
** Return to caller
*
 L     R3,PARMLIST
 L     R9,PARMLIST+4
 BSM   0,R9
 SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
**          Return the CCYY in R4
**
**    Input: R3 - Packed Julian date        (Address)
**    Output: R4 - CCYY in binary format    (Value)
**
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 SPACE 2
RETURN_YEAR EQU *
*
** Process the Year
*
 SLR   R0,R0                              Clear register
 SLR   R1,R1                              Clear register
 IC    R1,1(R3)                           Year: 00YYDDDF -> 000000YY-R1
 SLA   R1,4                               Move over: 00000YY0
 STM   R0,R1,DOUBLE                       Save: "00000000 00000YY0"
 OI    DOUBLE+7,X'0F'                     Make: "00000000 00000YYF"
 CVB   R0,DOUBLE                          Convert the year to binary
*
** Process the Century
*
 LA    R4,19                              Default century: 0 = 1900
 SLR   R15,R15                            Clear register
 IC    R15,0(R3)                          Get century offset
 AR    R4,R15                             Century = 19 + offset
 MH    R4,=H'100'                         Each century has 100 years...
*
** Add the Century to the Year to complete the number; return to caller
*
 AR    R4,R0                              Add in year: ex. 1962
*
 BSM   0,R14
 SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
**      Convert Time (TIME DEC format) to Zoned decimal
**
**      Input: R3 - Address of input time (FW)
**      Output: R5 - Address of output time (ZL8)
**
**    Note: S_TIME is a packed field without a sign byte, we will
**          shift it over 4 bits and insert a sign byte...
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 SPACE 2
T$RETURN_MTIME EQU *
 SLR  R0,R0                               Clear register
 L    R1,0(R3)                            Get time
 SLDA R0,4                                Shift over for sign
 STM  R0,R1,DOUBLE                        Put into work location
 OI   DOUBLE+7,X'0F'                      Insert sign byte
 UNPK 0(8,R5),DOUBLE+3(5)                 Convert to zoned decimal
 OI   7(R5),C'0'                          Fix sign byte
 BSM  0,R14                               Return to caller
 SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
**            Convert Military time to Standard
**
**      Input: R3 - Address of input time - ZL8'MMHHSSTH'
**
**      Output: W_STYPE - AM or PM
**              W_SHOUR - Hour adjusted (if needed)
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 SPACE 2
T$RETURN_STIME EQU *
 MVC   W_SHOUR(2),0(R3)                   Set default hour
 MVC   W_STYPE(2),=CL2'AM'                Set default type
*
 CLC   0(2,R3),=CL2'12'                   Is this 12:00 - 12:59?
 BE    TGS$PM                             Yes, just change AM to PM
 CLC   0(2,R3),=CL2'13'                   Is it past 13:00:00?
 BL    TGS$X                              No, its okay
*
 PACK  DOUBLE(3),0(2,R3)                  Convert hour to packed
 SP    DOUBLE(3),=PL3'12'                 Make time standard
 UNPK  W_SHOUR(2),DOUBLE(3)               Convert hour to zoned
 OI    W_SHOUR+1,C'0'                     Fix sign byte
TGS$PM EQU *
 MVC   W_STYPE(2),=CL2'PM'                Set to PM
TGS$X EQU *
 BSM   0,R9
 SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
**       Set "S_TIME" if no value is found
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 SPACE 2
T$CHK    EQU   *
 CLI   S_TIME,$DA#DATE_INVALID            Invalid Input time?
 BE    I$LB                               Yes, skip output processing
*
 CLC   S_TIME(4),=X'00,00,00,00'          Have a Time value?
 BNE   T$CHKTMX                           Yes, move on
 TIME  ,                                  Get current time
 ST    R0,S_TIME                          Save time for later
T$CHKTMX EQU *
 LA    R3,S_TIME                          Input time area
 LA    R5,W_TIMEM                         Output time area
 BAS   R14,T$RETURN_MTIME                 Convert S_TIME to W_TIMEM
T$CHKX EQU *
 BSM   0,R9                               Return to caller
 SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
** Year windowing
**
** Input: R4 points to "xxYY" which we will fill in with a century.
** This routine will only work in the 1900-2099 as is.
**
** For example: 00 becomes 2000, 50 becomes 2050 - 00-50 are 2000-2050
**              51 becomes 1951, 99 becomes 1999 - 51-99 are 1951-1999
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 SPACE 2
PERFORM_YEAR_WINDOW DS 0H
         CLC   2(2,R4),=C'50'
         BH    PYW1900
         MVC   0(2,R4),=C'20'
         BSM   0,R14
PYW1900  DS    0H
         MVC   0(2,R4),=C'19'
         BSM   0,R14
 EJECT ,
***********************************************************************
***
**       Gregorian/Julian/Dow tables
***
***********************************************************************
         SPACE 2
*
** Day of Week table -- Mapped by the TD DSECT
*
T_DOW    EQU   *
         DC    AL1(6,5,7,0,7),CL9'Saturday '
         DC    AL1(0,5,6,0,5),CL9'Sunday   '
         DC    AL1(1,5,5,1,5),CL9'Monday   '
         DC    AL1(2,4,4,2,6),CL9'Tuesday  '
         DC    AL1(3,3,3,3,8),CL9'Wednesday'
         DC    AL1(4,2,2,4,7),CL9'Thursday '
         DC    AL1(5,1,1,5,5),CL9'Friday   '
T_DOWE   EQU   (*-T_DOW)/TDL
*
** Month table -- Mapped by the TM DSECT
*
T_MONTH EQU *
 DC AL1(01),AL1(31),AL2(000),AL1(6),CL9'January  ',CL2'01'
 DC AL1(02),AL1(28),AL2(031),AL1(7),CL9'February ',CL2'02'
 DC AL1(03),AL1(31),AL2(059),AL1(4),CL9'March    ',CL2'03'
 DC AL1(04),AL1(30),AL2(090),AL1(4),CL9'April    ',CL2'04'
 DC AL1(05),AL1(31),AL2(120),AL1(2),CL9'May      ',CL2'05'
 DC AL1(06),AL1(30),AL2(151),AL1(3),CL9'June     ',CL2'06'
 DC AL1(07),AL1(31),AL2(181),AL1(3),CL9'July     ',CL2'07'
 DC AL1(08),AL1(31),AL2(212),AL1(5),CL9'August   ',CL2'08'
 DC AL1(09),AL1(30),AL2(243),AL1(8),CL9'September',CL2'09'
 DC AL1(10),AL1(31),AL2(273),AL1(6),CL9'October  ',CL2'10'
 DC AL1(11),AL1(30),AL2(304),AL1(7),CL9'November ',CL2'11'
 DC AL1(12),AL1(31),AL2(334),AL1(7),CL9'December ',CL2'12'
T_MONTHE EQU (*-T_MONTH)/TML
 DC AL1(13),AL1(0),AL2(365)               Last entry
 EJECT
***********************************************************************
***
**       Data constants
***
***********************************************************************
 SPACE 2
*
** Calendar constants
*
C_MONTHV DC    AL1(01,02,03,04,05,06,07,08,09,10)
         DC    AL1(11,12,13,14,15,16,17,18,19,20)
         DC    AL1(21,22,23,24,25,26,27,28,29,30)
         DC    AL1(31)
*
C_MONTHC DC    C' 01 02 03 04 05 06 07 08 09 10'
         DC    C' 11 12 13 14 15 16 17 18 19 20'
         DC    C' 21 22 23 24 25 26 27 28 29 30'
         DC    C' 31'
*
C_HEAD   DC    C' Su Mo Tu We Th Fr Sa'
C_HEADL  EQU   *-C_HEAD
*
C_STCK   STCKCONV MF=L
C_STCKL  EQU   *-C_STCK
*
** Literals in program
*
 LTORG ,
 DS    0D                                 End of DA#DATE CSECT
 EJECT
***********************************************************************
***
**       GETMAINed work area
***
***********************************************************************
 SPACE 2
DSA      DSECT ,
         DS    18F                        Register Save Area
*                                         Input Loop
I_LA     DS    F                          ..Addr. of current parm ent.
*
** Fields to be save past entry processing
*
         DS    0F                         Save
S_TIME   DS    F                          ..Time of day: TIME DEC form.
S_JDATE  DS    F                          ..Julian date: TIME DEC form.
*
** Misc work areas
*
DOUBLE   DS    D                          Double word work area
DWA      DS    2D                         Double word work area 2
PARMLIST DS    10F                        Parameter List
*
** Time/Date fields
*
W_TIMEM  DS    CL8'HHMMSSTH'              Current time
W_SHOUR  DS    CL2'HH'                    Hour the day: standard
W_STYPE  DS    CL2'AM'                    Type: AM or PM
W_GDATE  DS    CL8'MMDDCCYY'              Gregorian date (US)
W_CCYY   DS    C'CCYY'                    Full 4 byte year
W_MONTHE DS    XL(TML)                    Leap year month entry
         DS    0D                         Alignment for FREEMAIN
DSAL     EQU   *-DSA
 EJECT ,
***********************************************************************
***
**       DSECTs and equates
***
***********************************************************************
 SPACE 2
*
** T_ROUT table mapping DSECT
*
TR       DSECT ,
TR_TYPE  DS    XL2                        Type of call
         DS    X                          - not used
TR_ROUTN DS    C                          Routine Name or 0 if main
TR_ROUT  DS    F                          Routine address for type
*
** Map of T_MONTH
*
TM       DSECT ,
TM_NUM   DS    X                          ..Month number (Binary)
TM_DIM   DS    X                          ..Days in month
TM_PDAYS DS    XL2                        ..Days previous to month
TM_NAMEL DS    X                          ..Month name length
TM_NAME  DS    CL9                        ..Month name
TM_NUMC  DS    CL2                        ..Month number (Character)
TML      EQU   *-TM                       Length of entry
*
** Map of T_DOW
*
TD       DSECT ,
TD_NUM   DS    X                          ..Number of week - Start=sun
TD_FWWD  DS    X                          ..First week - Working days
TD_FWSUB DS    X                          ..First week - Subtract
TD_LWWD  DS    X                          ..Last week - Working days
TD_NAMEL DS    X                          ..Length of DOW Name
TD_NAME  DS    CL9                        ..Length of DOW Name
TDL      EQU   *-TD
 END   ,
./ ADD NAME=DA$DISKR 0100-01266-01266-1821-06679-06679-00000-DAVE
DA$DISKR TITLE 'Disk Reporter Utility'
* =================================================================== *
*
*  Name: DA$DISKR - Disk Reporter Utility
*
*  Author: David Alcock :: dave@planetmvs.com
*
*  Purpose: Reports on disk usage:
*           o Scan all online DISK ucbs and report on utilization
*           o Optionally report on all datasets found on a volume
*
*           ===> See HELP text at label HELPTEXT for more info
*
* Attributes: Reentrant, Reusable, Non-Authorized | Authorized
*
* Disclaimer: This program is FREEWARE.  Use at your own risk.  It
*             is provided for your enjoyment and neither David
*             Alcock or his employer provides any warranty for it's
*             use.  I'd like to hear how it works on your system.
*
*             This software is not in the public domain but is
*             available free of charge and with source code
*             provided.  It is copyright 2001+ by David Alcock
*             All rights reserved.
*
* CSECTs used:
* o Internal:
*   o DA$DISKR - Main CSECT
*   o DRU$OPTS - Options
*   o DRU$CON1 - Constants CSECT #1
*   o DRU$ESTA - Estae routine
*   o DRU$PPC  - Parse Parameter Card
*   o DRU$RVOL - Reset headings
*   o DRU$ALCV - Dynamically allocate volumes
*   o DRU$ROPR - Reset headings for operations report
*   o DRU$PRR  - Print Report Record
*   o DRU$PSR  - Print SYSPRINT record
*   o DRU$BLET - Print Big letters
*   o DRU$HELP - Print help information for PARM=HELP
*
* External Programs:
* o Ours:
*   o DA$DATE....Date routine
*   o DA$MXD.....Mini-Hex-Dump routine
* o IBM:
*   o IEFEB4UV...Unit verification
*   o IDCSS01....Cache (LISTDATA) API
*   o IEFSD095...IBM Block (big) Letter routine
*
* Non-IBM assembler MACROs:
* o DA#DATE....Equates and DSECTs for the date routine
* o DA#MXD.....Equates and DSECTs for the mini-hex-dump routine
* o DA#SMODE...Change addressing mode to/from 24 bit/31 bit
* o DA#STR.....Create Pascal-like string with length byte (-1)
*
*  Limitations:
*  o Assembler H or higher
*  o MVS/ESA v3 and higher
*  o SYS1.AOSB0 is needed at link time to resolve the _OPTIONAL_
*    IEFSD095 (big letter) routine;
*  o APF Authorization limitations:
*    o Lack of authorization does not stop the majority of options
*      and will not cause ABENDs since the TESTAUTH macro is used.
*    o Needed for following functions
*      o Node checking for RACF group verification (VTOCRPT)
*      o Cached volume detection
*
*  Enhancement queue:
*  o Convert from using DA$DATE to CONVTOD
*  o Parse: UCB= HEXDUMP NOHEADING
*  o Release buffers at close of datasets
*  o DASD CONFIG section is for operations report, need user report
*    %USED on DASD LIST
*  o Sort DASD list by free space
*  o Add in DSN DASD space calcuations
*
*  o ds1pdse is a pdse ds1pdse+ds1pdsex is a hfs
*
*  o SMS stats:
*    o 5 of 100 (5%) of online volumes are SMS-indicated
*    o 1 of 3 (33%) of selected volumes are SMS-indicated
* =================================================================== *
         SPACE 2
         LCLC  &DAVER
&DAVER   SETC  '2.1'
* =================================================================== *
* Note: PARM=DATAONLY is not complete!
*
*             M o d i f i c a t i o n   H i s t o r y
*
* Person     Date        Description
* ---------- ----------- ---------------------------------------------
* D.Alcock   2000-01-29  V2.1:
*                        - Put Total Tracks for volume in Report;
*                        - Calculate total tracks free for volume;
*                        - Use inline ESA entry/exit housekeeping code
*                          instead of homegrown (home groan) macros;
*                        - Remove non-working subchannel/chpid code;
* D.Alcock   25-JUN-1998 V2.0:
*                        - Moved Print_Sysprint_Record and Print_
*                          Report_Record to separate CSECTs;
*                        - Message prefix is now "DRU" not "DA$DISKR-"
*                          DRU = Disk Reporter Utility;
*                        - Eliminate VATDEF during merge;
*                        - Added PARM=HELP: print help info;
*                        - Added PARM=NOSYSP: Bypass System Profile
*                        - Added PARM=NOPIC: Bypass Star Trek Pic;
*                        - Print silly Star Trek "ASCII" picture
*                          at startup in //SYSPRINT;
*                        - Started DATAONLY option for //REPORT
*                          and //VTOCRPT ** Incomplete!! **;
*                        - Re-enable System Profile by moving it
*                          to a separate CSECT;
*                        - Change &ASMDATE to ISO format;
* D.Alcock   19-FEB-1998 Corrected S0C4 with PSM (Print Sort MSG)
*                        option;
* D.Alcock   29-DEC-1997 &ASMDATE changed to ISO standard;
* D.Alcock   06-OCT-1997 Added support for using the UCBSCAN macro
*                        so we can see Dynamic UCBs and 4 digit
*                        UCBs;  All code was changed to use 4 digit
*                        UCBs (UCBCHAN used instead of UCBNAME);
* D.Alcock   18-MAR-1997 Corrected CVAF/BSAM bug;  Added check for
*                        LSPACE failure and printing message;
* D.Alcock   17-MAR-1997 Added RPTBDSN parm; Added CATCHK to reduce
*                        overhead; Added SMSMCHK parm for migrating
*                        to SMS;  Started multiple date formats;
* D.Alcock   15-MAR-1997 Added PARM= processing and volume prefix
*                        option; Changed to use lower case hex;
* D.Alcock   13-MAR-1997 Renamed to DA$DISKR and macros converted;
* D.Alcock   07-JUL-1994 Changed all "*-6" executed instructions
*                        from in-line to out-of-path labels; Print
*                        assemble and link date at startup;
* D.Alcock   09-APR-1994 Added $$NOAPF DDNAME check; S0C4 ABEND in
*                        IDCSS01 prompted this check;
* D.Alcock   24-JAN-1985 Initial program created;
* =================================================================== *
         EJECT
***********************************************************************
***
**       Set the DFP/DFSMS and O/S maclib levels to variables
***
***********************************************************************
         SPACE 2
         GBLC  &DMACLIB                   DFP/DFSMS maclib version
&DMACLIB SETC  'PRE-DFP'                  Start out at ancient level
         GBLC  &IHADFARELS                IHADFA sets to system level
*-If you aren't at DFP maclib, comment out "IHADFA"
         IHADFA ,                         Data Facilities Area
         AIF   (NOT D'DFA).SMSX           Have IHADFA?
         AIF   (D'DFADFSMS).SMSSTRT       At DFSMS 1.1?
*-DFP maclib checks
&DMACLIB SETC  'DFP'
         AIF   (NOT D'DFASMS).SMSX
&DMACLIB SETC  'DFP 310'
         AIF   (NOT D'DFAPDSE).SMSX
&DMACLIB SETC  'DFP 320'
         AIF   (NOT D'DFAVOLSN).SMSX
&DMACLIB SETC  'DFP 330'
         AIF   (NOT D'DFAVOLSN).SMSX
&DMACLIB SETC  'DFP 331'
         AIF   (NOT D'DFARECAL).SMSX
&DMACLIB SETC  'DFP 332'
         AGO   .SMSX
*-As stated in the "DFSMS/MVS 1.3 DFSMSdfp Advanced Services" manual,
* the IHADFA macro did not always set &IHADFARELS (but they could
* in the future), so attempt to deterimine prior release levels.
.SMSSTRT ANOP  ,
         AIF   ('&IHADFARELS' NE '').SMSSET   Already have SMS level?
&IHADFARELS SETC '01010100'               Start at DFSMS 1.1
         AIF   (NOT D'DFADEEXT).SMSSET    At DFSMS 1.2?
&IHADFARELS SETC '01010200'               Up to DFSMS 1.2
.SMSSET  ANOP  ,                          Set level
&DMACLIB SETC  'DFSMS/MVS &IHADFARELS'    Set DFP/DFSMS maclib level
.SMSX    ANOP  ,
*
         CVT   DSECT=YES,LIST=NO,PREFIX=YES MVS CVT
*-Attempt to identify the MVS maclib level
         GBLC  &MMACLIB                   MVS maclib version
         AIF   (NOT D'CVTH6606).MMR6X
&MMACLIB SETC  'OS/390 R6 or higher'
         AGO   .MMX
.MMR6X   ANOP    ,
         AIF   (NOT D'CVTH6605).MMR5X
&MMACLIB SETC  'OS/390 R5'
         AGO   .MMX
.MMR5X   ANOP    ,
         AIF   (NOT D'CVTJ6604).MMR4X
&MMACLIB SETC  'OS/390 R4'
         AGO   .MMX
.MMR4X   ANOP    ,
         AIF   (NOT D'CVTH6603).MMR3X
&MMACLIB SETC  'OS/390 R3'
         AGO   .MMX
.MMR3X   ANOP    ,
         AIF   (NOT D'CVTJ6602).MMR2X
&MMACLIB SETC  'OS/390 R2'
         AGO   .MMX
.MMR2X   ANOP    ,
         AIF   (NOT D'CVTH6601).MMR1X
&MMACLIB SETC  'OS/390 R1'
         AGO   .MMX
.MMR1X   ANOP    ,
         AIF   (NOT D'CVTJ5522).MM522X
&MMACLIB SETC  'MVS 5.2.2'
         AGO   .MMX
.MM522X  ANOP    ,
         AIF   (NOT D'CVTH5520).MM520X
&MMACLIB SETC  'MVS 5.2.0'
         AGO   .MMX
.MM520X  ANOP  ,
         AIF   (NOT D'CVTH5510).MM510X
&MMACLIB SETC  'MVS 5.1.0'
         AGO   .MMX
.MM510X  ANOP  ,
         AIF   (NOT D'CVTH4430).MM430X
&MMACLIB SETC  'MVS 4.3.0'
         AGO   .MMX
.MM430X  ANOP  ,
         AIF   (NOT D'CVTJ4422).MM422X
&MMACLIB SETC  'MVS 4.2.2'
         AGO   .MMX
.MM422X  ANOP  ,
         AIF   (NOT D'CVTH4420).MM420X
&MMACLIB SETC  'MVS 4.2.0'
         AGO   .MMX
.MM420X  ANOP  ,
         AIF   (NOT D'CVTH4410).MM410X
         AGO   .MMX
&MMACLIB SETC  'MVS 4.1.0'
.MM410X  ANOP  ,
         AIF   (NOT D'CVTJ3313).MM313X
&MMACLIB SETC  'MVS 3.1.3'
         AGO   .MMX
.MM313X  ANOP  ,
         AIF   (NOT D'CVTJ3311).MM311X
&MMACLIB SETC  'MVS 3.1.1'
         AGO   .MMX
.MM311X  ANOP  ,
         AIF   (NOT D'CVTH3310).MM310X
&MMACLIB SETC  'MVS 3.1.0'
         AGO   .MMX
.MM310X  ANOP  ,
&MMACLIB SETC  'Pre-MVS3.1.0'             ..Default to pre-MVS3.1.0
.MMX     ANOP  ,
         EJECT
***********************************************************************
***
**       External Dsects
***
***********************************************************************
         SPACE 2
         PRINT GEN
         IECDDCE ,                        DASD Class Extension
         EJECT ,
         LSPACE MF=(D,DATA)               LSPACE data mapping
         EJECT ,
         LSPACE MF=(D,MSG)                LSPACE msg mapping
         EJECT ,
         IECSDSL1 (1,2,3,4,5,6)           DSCB
         EJECT ,
         ICVAFPL ,                        CVPL - CVAF macros
         EJECT ,
         ICVAFBFL ,                       CVAF Buffer lists
         EJECT ,
         IEFUCBOB PREFIX=YES              Unit control block
         PRINT NOGEN
         EJECT ,
         IHAPSA ,                         Prefixed Save Area
         IHASDWA ,                        System Diagnostic Work Area
         IEZJSCB ,                        Job Step Control Block
         IEFJSSIB ,                       Sub System ID block
         IKJTCB DSECT=YES,LIST=NO         Task control block
         DCBD DEVD=DA,DSORG=PS            Data Control Block
         IHADECB ,                        Data Event Control Block
         IEFZB4D0 ,                       SVC 99 - RB
         IEFZB4D2 ,                       SVC 99 - Text Equates
         IEFJFCBN ,                       Job File Control block
         IEESMCA ,                        SMF Control Area
         IEFJESCT ,                       JES control Table
         IEFJSCVT ,                       SubSystem Control Table
         IEFJSSVT ,                       SubSystem Vector Table
*        ICHPRCVT ,                       RACF CVT
         IKJCPPL ,                        Command Proc Parm list
         AIF   (NOT D'CVTH4410).MECVTX    Have a ECVT in MACLIB?
         IHAECVT DSECT=YES                Extended CVT
.MECVT   ANOP  ,
         YREGS ,                          Expand R0-R15 (registers)
*
** Our macros
*
         DA#DATE ,                        Date Routine
         DA#MXD ,                         Mini-hex dump routine
         PRINT GEN
*
** Using the official ASMH/HLASM distinction trick, simulate the
** SYSVER and SYSDATEC variables of HLASM when assembled under
** ASMH...Taken from Gilbert Saint-flour's SHOWMVS.
*
         LCLA  &ASMH_HLASM
         AIF   (T'&ASMH_HLASM EQ 'N').ASMH1X
&SYSVER  SETC  'ASMH'
&SYSDATC SETC  '20'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)
         AIF   ('&SYSDATC' LT '20500000').ASMH1X
&SYSDATC SETC  '19'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)
.ASMH1X  ANOP
*-Convert assembly date from SYSDATC format "YYYYMMDD" to "YYYY-MM-DD"
         LCLC  &ASMDATE
&ASMDATE SETC  '&SYSDATC'(1,4).'-'.'&SYSDATC'(5,2).'-'.'&SYSDATC'(7,2)
         EJECT
***********************************************************************
***
**       Program initialization
***
***********************************************************************
         SPACE 2
DA$DISKR CSECT ,
DA$DISKR AMODE 31
DA$DISKR RMODE ANY
*
** Standard O/S eyecatcher
*
DRU_EC   B    DRU_ECL(0,R15)            Bump past EyeCatcher
         DC   AL1(DRU_ECE-DRU_ECV)      Length of eyecatcher
DRU_ECV  DC   C'DA$DISKR &ASMDATE &SYSTIME V&DAVER '
         DC   C'Utility: DASD Usage Reporter'
DRU_ECE  EQU  *
         DS   0H
DRU_ECL  EQU  *-DRU_EC
*
** Standard ESA entry housekeeping code
*
         BAKR  R14,0                    Save registers
         LAE   R12,0(R15,0)             Get base register
         LAE   R11,2048(,R12)           Set up for second base reg
         LA    R11,2048(,R11)           Locate 4096 past R12
         LAE   R10,2048(,R11)           Set up for third base reg
         LA    R10,2048(,R10)           Locate 4096 past R11
         USING DA$DISKR,R12,R11,R10     Set module base
*
** Obtain Dynamic Save Area
*
         STORAGE OBTAIN,LENGTH=DSAL,LOC=BELOW Obtain storage
         LR    R13,R1                   Point to Save Area
*
         LR    R14,R13                  To: Address
         L     R15,=A(DSAL)             To: Length
         SLR   R1,R1                    From: Set length and pad
         MVCL  R14,R0                   Zero out area
*
         MVC   4(4,R13),=C'F1SA'        Indicate stack SA
         USING DSA,R13                  Get addressibility to area
*
** Set Default options
*
         MVI   PSR_LC,99                  Force heading on 1st rec
*
** Set DDNAMEs - This needs to be changed back to dynamic allocations
*
         L     R14,=V(DRU$OPTS)           Locate options CSECT
         MVC   DDN_WF1(8),OP_WF1-OP(R14)  LRECL=512
         MVC   DDN_WF2(8),OP_WF2-OP(R14)  LRECL=512
         MVC   DDN_WF3(8),OP_WF3-OP(R14)  LRECL=512
         MVC   DDN_WF4(8),OP_WF4-OP(R14)  LRECL=80
         MVC   DDN_WF5(8),OP_WF5-OP(R14)  LRECL=121
         MVC   DDN_VAT(8),OP_VAT-OP(R14)  LRECL=80
*
** Doing VTOC report?
*
         DEVTYPE =CL8'VTOCRPT',DOUBLE     Get VTOCRPT information
         LTR   R15,R15                    Is it allocated?
         BNZ   I$VRX                      No, continue
         OI    FLAG_X1,$FX1_VTOC          Turn on flag
I$VRX    EQU   *
*
** Invoke the parse routine
*
*        MVI   PPC_DATEF,$PPC_DFEGREG    Date format is Eur Greg
         L     R8,=V(DRU$PPC)             Locate CSECT
         BASSM R9,R8                      Invoke the parse routine
         EJECT
***********************************************************************
***                                                                 ***
**       Act upon options found                                      **
***                                                                 ***
***********************************************************************
         SPACE 2
*
** Test for APF authorization and set flag if on
*
         TESTAUTH FCTN=1                  Test APF authorization
         LTR   R15,R15                    Are we authorized?
         BNZ   I$APFX                     No, continue
         OI    FLAG_X1,$FX1_APF           Yes, set flag
I$APFX   EQU   *
*
** Load routines to be used for life of job
*
         LOAD  EPLOC==CL8'IEFEB4UV',ERRET=I$EB4UVX
         ST    R0,EP_EB4UV
I$EB4UVX EQU   *
         ICM   R0,B'1111',=V(DA$MXD)
         BNZ   I$MXDL
         LOAD  EPLOC==CL8'DA$MXD',ERRET=I$MXDX
         OI    FLAG_X2,$FX2_LMXD
I$MXDL   DS    0H
         ST    R0,EP_DA$MXD
I$MXDX   EQU   *
         ICM   R0,B'1111',=V(DA$DATE)
         BNZ   I$DATEL
         LOAD  EPLOC==CL8'DA$DATE',ERRET=I$DATEX
         OI    FLAG_X2,$FX2_LDATE
I$DATEL  DS    0H
         ST    R0,EP_DA$DATE
I$DATEX  EQU   *
*
         TM    FLAG_X1,$FX1_APF           APF authorized?
         BNO   I$SS01X                    No, continue
         TM    PPC_FLAG2,$PPC_F2NAUTH     Doing authorized stuff?
         BNO   I$SS01X                    No, continue
         LOAD  EPLOC==CL8'IDCSS01',ERRET=I$SS01X
         ST    R0,EP_SS01
I$SS01X  EQU   *
*
** Open Messages file
*
         LA    R3,SYSPRINT                Locate DCB work area
         L     R1,=V(DRU$CON1)
         MVC   0(C_DCBOL,R3),C_DCBO-DRU$CON1(R1)
         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'SYSPRINT'
         MVC   PARMLIST(C_LSTOL),C_LSTO-DRU$CON1(R1)
         OPEN  ((3),(OUTPUT)),MF=(E,PARMLIST)
*
** Print starting message
*
         TIME  BIN
         ST    R0,DOUBLE
         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks
         MVC   0(MSG1L,R15),MSG1-DRU$CON1(R1)  Get message
         LA    R15,MSG1L+1(R15)           Bump past the message
         MVC   0(MSG1AL,R15),MSG1A-DRU$CON1(R1)
         LA    R15,MSG1AL(R15)
         L     R1,DOUBLE
         BAS   R14,CONVERT_BINARY_TIME
         LA    R15,10(R15)
*
         TM    FLAG_X1,$FX1_APF           APF authorized?
         BNO   I$MSG1APX
         MVC   0(5,R15),=CL5'(APF)'
         LA    R15,6(R15)
I$MSG1APX EQU  *
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
         BAS   R14,CLEAR_RECOUT           Clear record to blanks
*
         L     R7,=V(DRU$CON1)            Locate constants CSECT
         TM    PPC_FLAG2,$PPC_F2NOPIC
         BNO   I$PICS
         LA    R7,NO_PICTURE-DRU$CON1(R7) Locate text strings
         B     I$PICL
I$PICS   DS    0H
         LA    R7,STARTUP_PICTURE-DRU$CON1(R7) Locate Startup picture
I$PICL   DS    0H
         LA    R15,RECOUT+5               Locate output area
         SLR   R14,R14                    Clear register for IC
         IC    R14,0(R7)                  Obtain length of messsage - 1
         EX    R14,I$PICM                 Move string to message area
         LA    R7,2(R14,R7)               Bump past this string
         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record
         BAS   R14,CLEAR_RECOUT           Clear record to blanks
         CLC   0(2,R7),=X'FFFFFFFF'       At end of strings?
         BNE   I$PICL                     No, continue
         B     I$PICX
I$PICM   MVC   0(0,R15),1(R7)
I$PICX   DS    0H
         BAS   R14,PRINT_SYSPRINT_RECORD  Print another blank line
*
         BAS   R14,CLEAR_RECOUT           Clear string area to blanks
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
*
** Print parm card if any
*
         BAS   R14,FORMAT_MESSAGE         Format message
         MVC   0(MSG30L,R15),MSG30-DRU$CON1(R1)
         LA    R15,MSG30L+1(R15)          Bump past it
         ICM   R1,B'1111',PPC_CB+4        Get address of parameter
         BZ    I$PPCX
         ICM   R14,B'1111',PPC_CB         Get Lenght of parameter
         BCTR  R14,0                      Decrement by 1
         EX    R14,I$PPCPM                Move parameter to message
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
*
** Print Errors in parm card
*
         SLR   R1,R1                      Clear register
         ICM   R1,B'0011',PPC_NUM         Get number of parm errors
         BZ    I$PPCX                     None, continue
*
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG31L,R15),MSG31-DRU$CON1(R1) Move in message
         LA    R15,MSG31L+1(R15)          Bump past it
         LH    R1,PPC_COL                 Get parameter column
         LA    R1,1(R1)                   Start from 1 not zero
         BAS   R9,EDITFWF                 Print column number
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
*
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG32L,R15),MSG32-DRU$CON1(R1) Move in message
         LA    R15,MSG32L+1(R15)          Bump past it
         LH    R1,PPC_NUM                 Get number of parm errors
         BAS   R9,EDITFWF                 Print it
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
*
         MVI   MAXCC,20
         B     EXIT
I$PPCPM  MVC   0(0,R15),0(R1)
I$PPCX   DS    0H
         BAS   R14,CLEAR_RECOUT           Clear record to blanks
         BAS   R14,PRINT_SYSPRINT_RECORD Print the record
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**       Print the DFSMS (if under DFSMS), DFP and MVS BCP levels
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG63L,R15),MSG63-DRU$CON1(R1) Move in message
         LA    R15,MSG63L+1(R15)          Bump past it
*
** Insert "DF/SMS level" (if we are executing on a system with DFSMS)
** into message
*
         MVC   G_DFSMSLVL(5),=C'N/A  '
         L     R2,CVTPTR                  -> CVT
         L     R2,CVTDFA-CVTMAP(R2)       -> Data Facilities Area
         AIF   ('&IHADFARELS' LT '01010100').RELSX .at DFSMS/MVS 1.1?
         CLC   DFARELS-DFA(4,R2),=8X'00'  Pre-DFSMS/MVS?
         BE    I$SMSLX                    Yes, skip
         MVC   G_DFARELS(4),DFARELS-DFA(R2) Save DFSMS/MVS level info
         LA    R4,DFAVER-DFA(R2)          Locate to version
         LA    R5,L'DFAVER+L'DFARLSE+L'DFAMOD Length to consider
         L     R1,=V(DRU$CON1)
         MVC   0(L'MSG63B,R15),MSG63B-DRU$CON1(R1)
         LA    R15,L'MSG63B+1(R15)
         ST    R15,PARMLIST
I$SMSLL  DS    0H
         SLR   R1,R1                      Get ready for Insert
         IC    R1,0(R4)                   Get value
         BAS   R9,EDITFWF                 Edit it flush
         MVI   0(R15),C'.'                Insert delimiter
         LA    R15,1(R15)                 Bump past delimiter
         LA    R4,1(R4)                   Bump to next value
         BCT   R5,I$SMSLL                 ..Try it out
         L     R1,PARMLIST
         MVC   G_DFSMSLVL(5),0(R1)        Save level
         BCTR  R15,0
         MVI   0(R15),C' '
         LA    R15,1(R15)
         MVI   0(R15),C'-'
         LA    R15,2(R15)                 Locate past it
I$SMSLX  DS    0H
.RELSX ANOP ,
*
** Insert "DFP level" into message
*
         L     R1,=V(DRU$CON1)
         MVC   0(L'MSG63D,R15),MSG63D-DRU$CON1(R1)
         LA    R15,L'MSG63D+1(R15)
         UNPK  DOUBLE2(5),DFAREL-DFA(3,R2)
         MVZ   DOUBLE2(4),=8X'00'
         TR    DOUBLE2(4),=C'0123456789ABCDEF'
         MVC   0(1,R15),DOUBLE2
         MVI   1(R15),C'.'
         MVC   2(1,R15),DOUBLE2+1
         MVI   3(R15),C'.'
         MVC   4(1,R15),DOUBLE2+2
         MVC   G_DFPLVL(5),0(R15)          Save DFP level for later
         LA    R15,6(R15)
*
** Insert "MVS BCP level" into message
*
         L     R1,=V(DRU$CON1)            Locate constants CSECT
         MVC   0(L'MSG63E,R15),MSG63E-DRU$CON1(R1)
         LA    R15,L'MSG63E+1(R15)
         L     R1,CVTPTR                  -> CVT
         LA    R0,CVTLEVL+L'CVTLEVL-CVTFIX Length of CVT prefix
         SR    R1,R0                      -> Backup to start of Prefix
         MVC   G_BCPLEVEL(L'CVTPRODN),CVTPRODN-CVTFIX(R1)
         MVC   0(L'CVTPRODN,R15),G_BCPLEVEL
*
         BAS   R14,PRINT_SYSPRINT_RECORD  Print message
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**       Authorization
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
*
** Print authorization message
*
         TM    FLAG_X1,$FX1_APF           Running authorized?
         BNO   I$AUTHTX                   No, continue
         TM    PPC_FLAG2,$PPC_F2NAUTH     Don't use authorized stuff
         BNO   I$AUTHTX                   No, continue
         NI    FLAG_X1,255-$FX1_APF       Turn off authorized fuctions
         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks
         MVC   0(MSG24L,R15),MSG24-DRU$CON1(R1) Get message
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
         B     I$AUTHMX                   Bump past auth check
I$AUTHTX EQU   *
*
** Print authorization message
*
         TM    FLAG_X1,$FX1_APF           Running authorized?
         BO    I$AUTHMX                   No, continue
         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks
         MVC   0(MSG20L,R15),MSG20-DRU$CON1(R1) Get message
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
*
         BAS   R14,CLEAR_RECOUT           Clear string area to blanks
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
I$AUTHMX EQU   *
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**       Print help information
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
*
** Print help information if requested
*
         TM    PPC_FLAG2,$PPC_F2HELP
         BNO   I$HELPX
         LA    R0,SUBRSA
         L     R15,=V(DRU$HELP)
         BASR  R14,R15
I$HELPX  DS    0H
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**       Check out the MVS level
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
*
** Use the UCBSCAN macro if executing on a MVS v4.2.2 system or higher
*
         CLC   G_BCPLEVEL(5),=C'SP4.2.2'  Under the weather?
         BL    I$UCBSX                    Yes, use CVTUCBSC
         OI    FLAG_X1,$FX1_UCBSCAN       Use UCBSCAN macro
I$UCBSX  DS    0H
*
** Act on CVTUCBSC flag
*
         TM    PPC_FLAG2,$PPC_F2CVTUS     User wants old service?
         BNO   I$UCVTUSX                  No, continue
         CLC   G_BCPLEVEL(5),=C'SP5.2'    Under
         BL    I$UCVTUSX                  No, problem
         NI    FLAG_X1,255-$FX1_UCBSCAN   Use UCBSCAN macro
         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks
         MVC   0(MSG36L,R15),MSG36-DRU$CON1(R1) Get message
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
*
         BAS   R14,CLEAR_RECOUT           Clear string area to blanks
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
I$UCVTUSX DS   0H
         EJECT
***********************************************************************
***                                                                 ***
**       Scan thru DASD UCB's and save online ones into work file    **
***                                                                 ***
***********************************************************************
         SPACE 2
*
** Open work file for system Configuration information
*
         LA    R3,WRKFILE1                Locate DCB work area
         L     R1,=V(DRU$CON1)
         MVC   0(C_DCBOL,R3),C_DCBO-DRU$CON1(R1)
         MVC   DCBDDNAM-IHADCB(8,R3),DDN_WF1 Move in DDNAME
         MVC   PARMLIST(C_LSTOL),C_LSTO-DRU$CON1(R1)
         OPEN  ((3),(OUTPUT)),MF=(E,PARMLIST)
*
** Obtain DASD Device count table
*
#DDCEN   EQU   64
         LA    R0,DDC_HL+((#DDCEN+1)*DDC_EL)
         GETMAIN R,LV=(0)                Obtain table
         STM   R0,R1,SDU_DDC             Save length and address
         MVC   DDC_HID-DDC_H(8,R1),=CL8'DASD-DC' Set eyecatcher
         MVI   DDC_HL(R1),X'FF'          Set end of table
*
** Create ESTAE exit for UCB processing
*
         SPACE 2
         L     R14,=V(DRU$CON1)           -> DRU$CON1
         MVC   PARMLIST(C_ESTAEL),C_ESTAE-DRU$CON1(R14)
*
         STM   R10,R12,RSEP_R10           Save base registers
         LA    R8,RSEP                    Locate parameters
         L     R9,=V(DRU$ESTA)            Locate routine
         ESTAE (9),CT,                    Create new ESTAE             @
               PARAM=((8)),               ..Parameter passed to rout.  @
               MF=(E,PARMLIST)            ..Parameter list
         XC    RSEP_RETRYO(2),RSEP_RETRYO Reset retry address
         SPACE 2
**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
** Scan through DASD UCBs
**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         SPACE 2
*
** Start of DASD UCB loop
*
         LA    R8,WRKREC                  Locate output record
         SLR   R7,R7                      Zero DASD count
         MVI   SDU_DEVT,UCB3DACC          Only process DASD Devices
         XC    SDU_WA(L'SDU_WA),SDU_WA  Clear workarea to binary zeros
         LA    R2,SDU_UA                Keep address of UCB returned
         ST    R2,SDU_UCB                 Get address of UCB
         LA    R1,256
         STH   R1,SDU_DCELEN
*
SDU$L    DS    0H
         TM    FLAG_X1,$FX1_UCBSCAN       Use UCBSCAN macro?
         BO    SDU$LUSS                   Yes, continue
         L     R15,CVTPTR                 ->  CVT
         L     R15,CVTUCBSC-CVTMAP(R15)   ->  Scan service address
         CALL  (15),                      Call UCB scan service        @
               (SDU_WA,SDU_DEVT,SDU_UCB), ..Parameters                 @
               VL,MF=(E,PARMLIST)         ..Parm list
         LTR   R15,R15                    End of DASD UCBs?
         BNZ   SDU$LX                     Yes, leave
         L     R2,SDU_UCB                 Get address of UCB
         B     SDU$LUSX                   Continue
****
SDU$LUSS DS    0H
         UCBSCAN COPY,                  Get UCB copy                   @
               WORKAREA=SDU_WA,         ..Work area                    @
               UCBAREA=SDU_UA,          ..UCB area                     @
               CMXTAREA=SDU_CMXT,       ..CMXT area                    @
               UCBPAREA=SDU_UCBP,       ..UCB Prefix                   @
               DCEAREA=SDU_DCE,         ..DCE area                     @
               DCELEN=SDU_DCELEN,       ..DCE length                   @
               DYNAMIC=YES,             ..Get all UCBs                 @
               RANGE=ALL,               ..Yes these too                @
               DEVCLASS=DASD,           ..Only DASD devices though     @
               RETCODE=SDU_RETCODE,     ..Return RC here               @
               RSNCODE=SDU_RSNCODE,     ..Return Reason code here      @
               MF=(E,PARMLIST)
         LTR   R15,R15                  Check return code
         BZ    SDU$LUSX                 Okay, continue
         C     R15,=F'4'                End of UCB's?
         BE    SDU$LX                   Yes, leave
*
         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks
         MVC   0(MSG37L,R15),MSG37-DRU$CON1(R1)
         LA    R15,MSG37L(R15)            Bump past message
         UNPK  0(5,R15),UCBCHAN-UCBOB(3,R2)
         MVZ   0(4,R15),=8X'00'
         TR    0(4,R15),=C'0123456789ABCDEF'
         LA    R15,4(R15)
         MVC   0(5,R15),=C', RC='
         LA    R15,5(R15)
         UNPK  0(9,R15),SDU_RETCODE(5)
         MVZ   0(8,R15),=8X'00'
         TR    0(8,R15),=C'0123456789ABCDEF'
         LA    R15,8(R15)
         MVC   0(6,R15),=C', RSN='
         LA    R15,6(R15)
         UNPK  0(9,R15),SDU_RSNCODE(5)
         MVZ   0(8,R15),=8X'00'
         TR    0(8,R15),=C'0123456789ABCDEF'
*        LA    R15,8(R15)
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
         B     SDU$L
SDU$LUSX DS    0H
*
** UCB check
*
         TM    UCBSTAT-UCBOB(R2),UCBONLI  Is it online?
         BNO   SDU$STAT$OFF               No, get next one
         CLC   UCBVOLI-UCBOB(6,R2),=8X'00' Valid volser?
         BE    SDU$STAT$OFFV              No, ignore it
         L     R1,SDU_CON                 Get current count of online
         LA    R1,1(R1)                   Increment count
         ST    R1,SDU_CON                 Save count
         B     SDU$STATX                  Continue
SDU$STAT$OFFV DS 0H
         TM    PPC_FLAG2,$PPC_F2DEBUG     Flag on?
         BNO   SDU$STAT$OFF               No, continue
         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks
         MVC   0(MSG38L,R15),MSG38-DRU$CON1(R1)
         MVC   MSG38L(4,R15),WD_UCB-WD(R8)
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
SDU$STAT$OFF EQU *
         L     R1,SDU_COFF                Get current count of online
         LA    R1,1(R1)                   Increment count
         ST    R1,SDU_COFF                Save count
         B     SDU$L                      Skip this puppy
SDU$STATX EQU *
         LA    R7,1(R7)                   Increment online DASD count
*
** Do we need to process this volume?
*
         CLI   PPC_VPREFIXL,$PPC_NOCHK    Don't check volume prefix?
         BE    SDU$VOLCM                  Yes, skip check
         SLR   R1,R1                      Clear reg for IC
         IC    R1,PPC_VPREFIXL            Get volume length
         EX    R1,SDU$VOLCC               Match?
         BNE   SDU$L                      No, bypass volume
SDU$VOLCM DS   0H
         L     R1,SDU_CMATCH              Get current match count
         LA    R1,1(R1)                   Increment count
         ST    R1,SDU_CMATCH              Save count
         B     SDU$VOLCX
SDU$VOLCC CLC  UCBVOLI-UCBOB(0,R2),PPC_VPREFIX
SDU$VOLCX DS   0H
*
** Initialization for this record
*
         MVI   0(R8),0                    Get hex zeros
         MVC   1(132,R8),0(R8)            ..Propagate them
         MVC   WD_VER-WD(4,R8),DRU_ECV+9 Get "vV.M'
*
** UCB information
*
         MVC   WD_VOLS-WD(6,R8),UCBVOLI-UCBOB(R2)  Volume serial
         UNPK  WD_UCB-WD(5,R8),UCBCHAN-UCBOB(3,R2)
         MVZ   WD_UCB-WD(4,R8),=8X'00'
         TR    WD_UCB-WD(4,R8),=C'0123456789ABCDEF'
*
         MVC   RSEP_VOL(6),UCBVOLI-UCBOB(R2)       Volume serial
         MVC   RSEP_UCB(4),WD_UCB-WD(R8)
*
** Save the System name in case the work file is being read by
** another program to merge fields from different systems
*
         L     R15,CVTPTR                 ->  CVT
         MVC   WD_SNAME-WD(8,R8),CVTSNAME-CVTMAP(R15) Save system
*
** Get UCB mount status
*
         MVC   WD_SMNT-WD(3,R8),=C'   '
         TM    UCBSTAB-UCBOB(R2),UCBBSTR  Pack usage = Storage?
         BO    SDU$CU0                    Yes, move on
         TM    UCBSTAB-UCBOB(R2),UCBBPUB  Pack usage = Public?
         BO    SDU$CU1                    Yes, Move on
         MVC   WD_SMNT-WD(3,R8),=C'PRI'
         B     SDU$CUX
SDU$CU0  DS    0H
         MVC   WD_SMNT-WD(3,R8),=C'STR'
         B     SDU$CUX
SDU$CU1  DS    0H
         MVC   WD_SMNT-WD(3,R8),=C'PUB'
SDU$CUX  DS    0H
*
** Get device type
*
         ICM   R15,B'1111',EP_EB4UV       Routine loaded?
         BZ    SDU$DTX                    No, leave
*
         LA    R1,SDU$DTE-DA$DISKR        Locate retry offset
         STH   R1,RSEP_RETRYO             Save retry address
         MVC   RSEP_FUNC(8),=CL8'IEFEB4UV' Set reason
*
         LA    R1,PARMLIST+8              Locate our input parm
         MVI   0(R1),0                    Get zeroes
         MVC   1(19,R1),0(R1)             ..propagate them
         MVC   8(4,R1),UCBTYP-UCBOB(R2)   Get device type
* Note: IEFEB4UV returns RC=4 when X'3030200E' but 0 if X'3010200E'
 MVI 8+1(R1),X'10'  Why do I have to do this? #@($*&#@($*&#$@
         DA#SMODE 31                      Get into 31 bit mode
         CALL  (15),                      Call unit verification       @
               (PARMLIST+8,=X'2000'),     ..Unit table, flags          @
               VL,MF=(E,PARMLIST)         ..Parameter area
         DA#SMODE 24                      Get back to 24 bit mode
         LTR   R15,R15                    Check return code
         BNZ   SDU$DTRCE                  uh oh
         MVI   WD_DEVTL-WD(R8),4-1        Assume "3380" length
         MVC   WD_DEVT-WD(8,R8),PARMLIST+8 Get device type returned
         MVC   WD_DEVTA-WD(8,R8),PARMLIST+8 Get device type returned
         B     SDU$DTX                    Continue
SDU$DTRCE EQU  *
         LR    R5,R15                     Save return code
         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks
         MVC   0(MSG7L,R15),MSG7-DRU$CON1(R1)
         LA    R15,MSG7L(R15)             Bump past the message
         LR    R1,R5                      Get the return code
         BAS   R9,EDITFWF                 Edit the return code
         MVC   0(6,R15),=C', UCB='        Text
         LA    R15,6(R15)
         UNPK  0(5,R15),UCBCHAN-UCBOB(3,R2)
         MVZ   0(4,R15),=8X'00'
         TR    0(4,R15),=C'0123456789ABCDEF'
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
         B     SDU$DTX
SDU$DTE  DS    0H
         XC    RSEP_RETRYO(2),RSEP_RETRYO Reset retry address
         BAS   R14,SDU$UCBE               Call error routine
         MVI   WD_DEVTL-WD(R8),1-1
         MVI   WD_DEVT-WD(R8),C'?'
         MVI   WD_DEVTA-WD(R8),C'?'
SDU$DTX  EQU   *
*-Note: I've taken out this code for two reasons (18-MAR-1997):
*------ 1) Claim back more room in the main CSECT
*------ 2) I wonder how useful this is or if it actually works right
 AGO .SYSVTOCX
*
** Issue ENQ for SYSVTOC, Don't get hung up on one volume.
** You can only ENQ on "SYS" stuff when you are authorized or ABEND
*
         TM    FLAG_X1,$FX1_APF           APF authorized?
         BNO   SDU$ENQX                   No, continue
*
         LA    R1,SDU$ENQE-DA$DISKR       Locate retry offset
         STH   R1,RSEP_RETRYO             Save retry address
         MVC   RSEP_FUNC(8),=CL8'ENQ-VTOC' Set reason
*
         XC    DOUBLE(4),DOUBLE           Set retry count to zero
         LA    R9,UCBVOLI-UCBOB(R2)       Locate Volume name
SDU$ENQL EQU   *
         L     R1,=V(DRU$CON1)
         MVC   PARMLIST(C_ENQL),C_ENQ-DRU$CON1(R1) Get parm list
         ENQ   (=CL8'SYSVTOC',(9),S,6,SYSTEM),RET=TEST,                @
               MF=(E,PARMLIST)
         LTR   R15,R15                    Check return code
         BZ    SDU$ENQX                   Zero, its okay to proceed
         L     R1,DOUBLE                  Get current retry count
         LA    R1,1(R1)                   Increment by one
         CH    R1,=H'5'                   Hit maximun tries yet?
         BH    SDU$ENQF                   Yes, can't get to volume now
         ST    R1,DOUBLE                  Save retry count
         STIMER WAIT,BINTVL==F'0500'      Wait a bit
         B     SDU$ENQL                   Try again
SDU$ENQF EQU   *
         LR    R5,R15                     Save return code
         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks
         MVC   0(MSG2L,R15),MSG2-DRU$CON1(R1)
         LA    R15,MSG2L(R15)             Bump past the message
         LR    R1,R5                      Get the return code
         BAS   R9,EDITFWF                 Edit the return code
         MVC   0(6,R15),=C', UCB='        Text
         LA    R15,6(R15)
         UNPK  0(5,R15),UCBCHAN-UCBOB(3,R2)
         MVZ   0(4,R15),=8X'00'
         TR    0(4,R15),=C'0123456789ABCDEF'
         LA    R15,4(R15)
         MVC   0(9,R15),=C', Volume='     Text
         MVC   9(6,R15),UCBVOLI-UCBOB(R2) Move in UCB address
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
         B     SDU$ENQX
SDU$ENQE DS    0H
         XC    RSEP_RETRYO(2),RSEP_RETRYO Reset retry address
         BAS   R14,SDU$UCBE               Call error routine
SDU$ENQX EQU  *
.SYSVTOCX ANOP ,
*
** Issue the LSPACE SVC for volume space information
*
         LA    R1,SDU$LSPCE-DA$DISKR      Locate retry offset
         STH   R1,RSEP_RETRYO             Save retry address
         MVC   RSEP_FUNC(8),=CL8'LSPACE'  Set reason
*
         L     R1,=V(DRU$CON1)
         MVC   PARMLIST(C_LSPCL),C_LSPC-DRU$CON1(R1)
         LA    R9,WD_LSPCD-WD(R8)         Locate LSPACE Data ret. area
         LA    R3,WD_F4DSCB-WD(R8)        Locate F4DSCB area
         MVC   0(C_LSPCDLL,R9),C_LSPCDL-DRU$CON1(R1)
        LSPACE UCB=(2),                   Obtain DASD space infor      @
               F4DSCB=(3),                ..F4DSCB                     @
               DATA=(9),                  ..Data return area           @
               MF=(E,PARMLIST)            ..Execute from here
         LTR   R15,R15                    Successful?
         BZ    SDU$LSPCX                  Yes, move on
*-If first LSPACE fails, Do another one to get the EBCDIC info
         OI    WD_FLAG1-WD(R8),$WDF1_NLSPC Set NO LSPACE info
         LR    R5,R15                     Save return code
         L     R1,=V(DRU$CON1)
         MVC   PARMLIST(C_LSPCL),C_LSPC-DRU$CON1(R1)
         LA    R9,PARMLIST+C_LSPCL        Locate past parameter list
        LSPACE UCB=(2),                   Obtain DASD space infor      @
               MSG=(9),                   ..Data return area           @
               MF=(E,PARMLIST)            ..Execute from here
         MVC   WD_LSPCD-WD(L'LSPMTEXT,R8),0(R9)
*
         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks
         MVC   0(MSG6L,R15),MSG6-DRU$CON1(R1)
         LA    R15,MSG6L(R15)             Bump past the message
         LR    R1,R5                      Get the return code
         BAS   R9,EDITFWF                 Edit the return code
         MVC   0(6,R15),=C', UCB='        Text
         LA    R15,6(R15)
         UNPK  0(5,R15),UCBCHAN-UCBOB(3,R2)
         MVZ   0(4,R15),=8X'00'
         TR    0(4,R15),=C'0123456789ABCDEF'
         LA    R15,4+1(R15)               Bump past UCB
         MVI   0(R15),C'-'                Insert delimiter
         MVC   2(L'LSPMTEXT,R15),PARMLIST+C_LSPCL
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
         B     SDU$LSPCX
SDU$LSPCE DS   0H
         XC    RSEP_RETRYO(2),RSEP_RETRYO Reset retry address
         BAS   R14,SDU$UCBE               Call error routine
SDU$LSPCX EQU  *
** - - - - - - - - - - - - - - - - - - -  Print areas for debugging
*-When you want a quick way to see the F4DSCB and LSPACE, then
*-comment the next line.  You do this in development only!
         AGO   .DF4LSX
*
         MVI   RECOUT,C' '
         MVC   RECOUT+1(132),RECOUT
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
*
         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks
         MVC   0(MSG19L,R15),MSG19-DRU$CON1(R1)
         MVC   MSG19L+1(6,R15),=C'F4DSCB'
         LA    R15,MSG19L+1+6(R15)
         MVC   0(6,R15),=C', UCB='        Text
         LA    R15,6(R15)
         UNPK  0(5,R15),UCBCHAN-UCBOB(3,R2)
         MVZ   0(4,R15),=8X'00'
         TR    0(4,R15),=C'0123456789ABCDEF'
         LA    R15,4(R15)
         MVC   0(9,R15),=C', Volume='     Text
         MVC   9(6,R15),UCBVOLI-UCBOB(R2) Move in UCB address
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
         MVI   RECOUT,C' '
         MVC   RECOUT+1(132),RECOUT
*
         XC    CMXD_WA(CMXDL),CMXD_WA
         LA    R15,WD_F4DSCB-WD(R8)       Locate area to print
         LA    R0,L'WD_F4DSCB             Get length to dump
         LA    R1,RECOUT+8                Locate output record
         STM   R15,R1,CMXD_WA+CMXD_ADDRESS-CMXD Data, Length, Output
         MVC   CMXD_WA+CMXD_OUTPUTL-CMXD(2),=AL2(133-14)
SDU$PDAL1 EQU  *
         LA    R1,CMXD_WA                 Locate work area
         L     R15,EP_DA$MXD              -> DA$MXD E.P.A.
         BASSM R14,R15                    Call DA$MXD
         STC   R15,CMXD_RC                Save return code
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
         CLI   CMXD_RC,0                  Any more lines to do...
         BNE   SDU$PDAL1                  Thank you: May I have another
*
         MVI   RECOUT,C' '
         MVC   RECOUT+1(132),RECOUT
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
*
         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks
         MVC   0(MSG19L,R15),MSG19-DRU$CON1(R1)
         MVC   MSG19L+1(12,R15),=C'LSpace(Data)'
         LA    R15,MSG19L+1+12(R15)
         MVC   0(6,R15),=C', UCB='        Text
         LA    R15,6(R15)
         UNPK  0(5,R15),UCBCHAN-UCBOB(3,R2)
         MVZ   0(4,R15),=8X'00'
         TR    0(4,R15),=C'0123456789ABCDEF'
         LA    R15,4(R15)
         MVC   0(9,R15),=C', Volume='     Text
         MVC   9(6,R15),UCBVOLI-UCBOB(R2) Move in UCB address
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
         MVI   RECOUT,C' '
         MVC   RECOUT+1(132),RECOUT
*
         XC    CMXD_WA(CMXDL),CMXD_WA
         LA    R15,WD_LSPCD-WD(R8)        Locate area to print
         LA    R0,L'WD_LSPCD              Get length to dump
         LA    R1,RECOUT+8                Locate output record
         STM   R15,R1,CMXD_WA+CMXD_ADDRESS-CMXD Data, Length, Output
         MVC   CMXD_WA+CMXD_OUTPUTL-CMXD(2),=AL2(133-14)
SDU$PDAL2 EQU  *
         LA    R1,CMXD_WA                 Locate work area
         L     R15,EP_DA$MXD              -> DA$MXD E.P.A.
         BASSM R14,R15                    Call DA$MXD
         STC   R15,CMXD_RC                Save return code
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
         CLI   CMXD_RC,0                  Any more lines to do...
         BNE   SDU$PDAL2                  Thank you: May I have another
*
         MVI   RECOUT,C' '
         MVC   RECOUT+1(132),RECOUT
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
SDU$PDAX DS    0H
.DF4LSX  ANOP  ,
** - - - - - - - - - - - - - - - - - - -  Print areas for debugging
*
** Calculate VTOC size
*
         TM    WD_FLAG1-WD(R8),$WDF1_NLSPC  NO LSPACE info?
         BO    SDU$VSZX                   Yes, don't have a F4DSCB
         LA    R5,DS4VTOCE-DS4IDFMT(R3)   Locate VTOC extent
         SLR   R0,R0                      Clear register
         SLR   R1,R1                      Clear register
         SLR   R15,R15                    Clear register
         ICM   R0,B'0011',2(R5)           Start Cylinder
         ICM   R1,B'0011',4(R5)           Start Track
         MH    R0,DS4DEVSZ+2-DS4IDFMT(R3) Convert to tracks
         ALR   R0,R1                      Relative track
         ICM   R1,B'0011',6(R5)           End Cylinder
         ICM   R15,B'0011',8(R5)          End Track
         MH    R1,DS4DEVSZ+2-DS4IDFMT(R3) Convert to tracks
         ALR   R1,R15                     Relative track
         SLR   R1,R0                      Tracks -1
         LA    R1,1(R1)                   Adjust
         STCM  R1,B'0011',WD_VTOCT-WD(R8) Save VTOC size in tracks
SDU$VSZX DS    0H
*
** Test for indexed VTOCS, must be after LSPACE for accuracy.
**
**  IF (The LSPACE SVC was not issued)
**     and (The DASD has not been referenced by anybody since IPL)
**     THEN (CVAFTST will not show Indexed VTOC even if it is)
*
         LA    R1,SDU$IVE-DA$DISKR        Locate retry address
         STH   R1,RSEP_RETRYO             Save retry address
         MVC   RSEP_FUNC(8),=CL8'CVAFTST' Set reason
*
         CVAFTST UCB=(2)                  Test for indexed VTOC
         CH    R15,=H'8'                  Check return code
         BNE   SDU$IVX                    Not indexed, move on
         OI    WD_FLAG1-WD(R8),$WDF1_IVTOC
         B     SDU$IVX
SDU$IVE  DS    0H
         XC    RSEP_RETRYO(2),RSEP_RETRYO Reset retry address
         BAS   R14,SDU$UCBE               Call error routine
SDU$IVX  DS    0H
*
** Cached volume information
*
*-Note: Removed on 18-MAR-1997 - This code hasn't been executed in
*-      Many years, put back and test...
 AGO .CACHEX
         LA    R1,SDU$CVE-DA$DISKR        Locate retry address
         STH   R1,RSEP_RETRYO             Save retry address
         MVC   RSEP_FUNC(8),=CL8'IDCSS01' Set reason
*
*        CLI   UCBTBYT4-UCBOB(R2),X'0E'   3380?
*        BNE   SDU$CVX
         SLR   R1,R1
         ICM   R1,B'0111',UCBEXTP-UCBOB(R2) -> UCB extension
         BZ    SDU$CVX
         ICM   R1,B'1111',UCBCLEXT-UCBCMEXT(R1)
         BZ    SDU$CVX
         TM    DCEFEAT1-DCE(R1),DCECACHE  Cached controller?
         BNO   SDU$CVX                    No, volume can't be cached
         OI    WD_FLAG1-WD(R8),$WDF1_CACHEC Cached Controller...
         TM    FLAG_X1,$FX1_APF           APF authorized?
         BNO   SDU$CVX                    No, avoid error
         ICM   R15,B'1111',EP_SS01        -> IDCSS01
         BZ    SDU$CVX                    Not available, continue
*
         LA    R1,PARMLIST                Parameter list for IDCSS01
         XC    0(4,R1),0(R1)              Clear word 1 to zeros
         LA    R14,DOUBLE                 Locate return code area
         ST    R14,8(R1)                  Save as word 3
         LA    R14,PARMLIST+20            Locate SSGARGL
         ST    R14,4(R1)                  Save as word 2
         LA    R14,WD_VOLS-WD(R8)
         ST    R14,12(R1)                 Into SSGAVOL
         LA    R14,UCBTYP-UCBOB(R2)
         ST    R14,16(R1)                 Into SSGUNIT
         OI    28(R1),B'01000000'         SSGOPT,SSGRSS SubSys Status
         BALR  R14,R15
*
         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks
         MVC   0(MSG19L,R15),MSG19-DRU$CON1(R1)
         MVC   MSG19L+1(17,R15),=C'SSGARGL (IDCSS01)'
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
*
         XC    CMXD_WA(CMXDL),CMXD_WA
         LA    R15,PARMLIST+20            Locate area to print
         LA    R0,32                      Get length to dump
         LA    R1,RECOUT+14               Locate output record
         STM   R15,R1,CMXD_WA+CMXD_ADDRESS-CMXD Data, Length, Output
         MVC   CMXD_WA+CMXD_OUTPUTL-CMXD(2),=AL2(133-14)
SDU$CVDL EQU   *
         LA    R1,CMXD_WA                 Locate work area
         L     R15,EP_DA$MXD              -> DA$MXD E.P.A.
         BASSM R14,R15                    Call DA$MXD
         STC   R15,CMXD_RC                Save return code
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
         CLI   CMXD_RC,0                  Any more lines to do...
         BNE   SDU$CVDL                   Thank you: May I have another
*
         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks
         MVC   0(MSG19L,R15),MSG19-DRU$CON1(R1)
         MVC   MSG19L+1(16,R15),=C'Buffer (IDCSS01)'
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
*
         XC    CMXD_WA(CMXDL),CMXD_WA Initialize parm area
         LA    R15,PARMLIST+20            Locate area to print
         L     R15,24(R15)                SSGOADR Address
         L     R0,20(R5)                  SSGOLN Length
         LA    R1,RECOUT+14               Locate output record
         STM   R15,R1,CMXD_WA+CMXD_ADDRESS-CMXD Data, Length, Output
         MVC   CMXD_WA+CMXD_OUTPUTL-CMXD(2),=AL2(133-14)
SDU$CVBL EQU   *
         LA    R1,CMXD_WA                 Locate work area
         L     R15,EP_DA$MXD              -> DA$MXD E.P.A.
         BASSM R14,R15                    Call DA$MXD
         STC   R15,CMXD_RC                Save return code
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
         CLI   CMXD_RC,0                  Any more lines to do...
         BNE   SDU$CVBL                   Thank you: May I have another
*
         B     SDU$CVX
SDU$CVE  DS    0H
         XC    RSEP_RETRYO(2),RSEP_RETRYO Reset retry address
         BAS   R14,SDU$UCBE               Call error routine
SDU$CVX  DS    0H
.CACHEX  ANOP  ,
*
** Get device type information
*
         LA    R1,SDU$DTS-DA$DISKR        Locate retry offset
         STH   R1,RSEP_RETRYO             Save retry address
         MVC   RSEP_FUNC(8),=CL8'DEVTYPE' Set reason
         L     R1,=V(DRU$CON1)
         MVC   PARMLIST(C_DTYPEL),C_DTYPE-DRU$CON1(R1)
         LA    R3,WD_DTAREA-WD(R8)        Locate device type
       DEVTYPE ,((3),24),                 Obtain device information    @
               UCBLIST=(SDU_UCB,1),       ..By this UCB                @
               MF=(E,PARMLIST)            ..Execute from here
         LTR   R15,R15                    Check return code
         BZ    SDU$DTS                    Okay?
         LR    R5,R15                     Save return code
         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks
         MVC   0(MSG5L,R15),MSG5-DRU$CON1(R1)
         LA    R15,MSG5L(R15)             Bump past the message
         LR    R1,R5                      Get the return code
         BAS   R9,EDITFWF                 Edit the return code
         MVC   0(6,R15),=C', UCB='        Text
         LA    R15,6(R15)
         UNPK  0(5,R15),UCBCHAN-UCBOB(3,R2)
         MVZ   0(4,R15),=8X'00'
         TR    0(4,R15),=C'0123456789ABCDEF'
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
         MVC   8(4,R3),=AL2(885+1,15)     Assume 3380 single
SDU$DTS  EQU   *
         XC    RSEP_FUNC(8),RSEP_FUNC
*
** Nickname lookup
*
         L     R1,=V(DRU$OPTS)            Locate options CSECT
         LA    R1,OP_TDASDT-OP(R1)        Locate DASD Type table
         LA    R0,OP_TDASDTE              Get number of entries
SDU$DTNL EQU   *
         CLC   OPTDT_NAME-OPTDT(8,R1),WD_DEVT-WD(R8)
         BNE   SDU$DTNLB
         CLC   OPTDT_CYLS-OPTDT(2,R1),8(R3) Cylinders match
         BNE   SDU$DTNLB
* Note: Following code *Assumes* 4 byte name, example: 3380 to 3380K
         MVC   WD_DEVT+4-WD(1,R8),OPTDT_TYPE-OPTDT(R1)
         B     SDU$DTNLX
SDU$DTNLB EQU  *
         LA    R1,OPTDTL(R1)              Bump to next entry
         BCT   R0,SDU$DTNL                ..Process it
SDU$DTNLX EQU  *
*
** Save count of device type
*
         L     R14,SDU_DDC+4              Get table length
         LA    R14,DDC_HL(R14)            Bump past the header
         LA    R0,#DDCEN                  Max number
SDU$DDCL EQU   *
         CLI   0(R14),X'FF'               End of table?
         BE    SDU$DDCN                   Yes, new guy
         CLC   DDC_ENAME-DDC_E(8,R14),WD_DEVT-WD(R8)  Match?
         BE    SDU$DDCU                   Yes, update count
         LA    R14,DDC_EL(R14)            No, bump to next entry
         BCT   R0,SDU$DDCL                    and process it
         TM    FLAG_X2,$FX2_DDCO          Overflow?
         BO    SDU$DDCX                   Yes, continue
         OI    FLAG_X2,$FX2_DDCO          Overflow!
         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks
         MVC   0(MSG29L,R15),MSG29-DRU$CON1(R1) Get message
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
         B     SDU$DDCX
SDU$DDCN EQU  *
         MVC   DDC_ENAME-DDC_E(8,R14),WD_DEVT-WD(R8)  Get device name
         LA    R1,1                                   Get count of 1
         STCM  R1,B'1111',DDC_ECOUNT-DDC_E(R14)       Save count
         MVI   DDC_EL(R14),X'FF'              Set new end
         B     SDU$DDCX
SDU$DDCU EQU   *
         ICM   R1,B'1111',DDC_ECOUNT-DDC_E(R14)       Get count
         LA    R1,1(R1)                               Increment by 1
         STCM  R1,B'1111',DDC_ECOUNT-DDC_E(R14)       Save count
SDU$DDCX EQU   *
*
** Locate the UCB prefix for some channel trivia
*
         LR    R14,R2                     Address of the UCB
         LA    R15,UCBCMSEG-UCBPXST       Length of offset to prefix
         SR    R14,R15                    -> UCB prefix
*-->     MVC   WD_CHPID-WD(8,R8),UCBCHPID-UCBPXST(R14)
*
** Print the record on the work file
*
         PUT   WRKFILE1,WRKREC            Kick out record
*
** Hex dump of input
*
         TM    PPC_FLAG2,$PPC_F2DEBUG     Flag on?
         BNO   SDU$WDX                    No skip debugging
         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks
         MVC   0(MSG19L,R15),MSG19-DRU$CON1(R1)
         MVC   MSG19L+1(17,R15),=C'Work Area for UCB'
         LA    R15,MSG19L+1+17+1(R15)
         UNPK  0(5,R15),UCBCHAN-UCBOB(3,R2)
         MVZ   0(4,R15),=8X'00'
         TR    0(4,R15),=C'0123456789ABCDEF'
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
*
         XC    CMXD_WA(CMXDL),CMXD_WA
         LA    R15,WRKREC                 Locate area to print
         LA    R0,WDL                     Get length to dump
         LA    R1,RECOUT+14               Locate output record
         STM   R15,R1,CMXD_WA+CMXD_ADDRESS-CMXD Data, Length, Output
         MVC   CMXD_WA+CMXD_OUTPUTL-CMXD(2),=AL2(133-14)
SDU$WDDL EQU   *
         LA    R1,CMXD_WA                 Locate work area
         L     R15,EP_DA$MXD              -> DA$MXD E.P.A.
         BASSM R14,R15                    Call DA$MXD
         STC   R15,CMXD_RC                Save return code
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
         CLI   CMXD_RC,0                  Any more lines to do...
         BNE   SDU$WDDL                   Thank you: May I have another
SDU$WDX  EQU   *
*
** End of the loop
*
         B     SDU$L                      ..process the next UCB
         SPACE 2
**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
** Entered ESTAE routine for a UCB
**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         SPACE 2
SDU$UCBE DS    0H
         ST    R14,SDU_UCBERA             Save return address
*
** Print error message
*
         L     R2,SDU_UCB                 Get address of UCB
         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks
         MVC   0(MSG27L,R15),MSG27-DRU$CON1(R1)
         UNPK  MSG27UCB-MSG27(5,R15),UCBCHAN-UCBOB(3,R2)
         MVZ   MSG27UCB-MSG27(4,R15),=8X'00'
         TR    MSG27UCB-MSG27(4,R15),=C'0123456789ABCDEF'
         MVI   MSG27D-MSG27(R15),C'-'
         MVC   MSG27VOL-MSG27(6,R15),UCBVOLI-UCBOB(R2)
         MVC   MSG27ID-MSG27(8,R15),RSEP_FUNC
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
*
** Print error message
*
         L     R14,SDU_UCBERA             Get return address
         BSM   0,R14                      Return to caller
         SPACE 2
**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
** End of the DASD UCBs
**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         SPACE 2
SDU$LX   DS    0H
         ST    R7,G_DASD                  Save DASD count
*
** Turn off ESTAE
*
         XC    RSEP_RETRYO(2),RSEP_RETRYO Reset retry address
         ESTAE 0                          Turn off ESTAE exit
*
** Close the work file
*
         LA    R3,WRKFILE1                Locate the work file
         BAS   R9,CLOSE_FILE              Close file
*
** Print some mindless trivia
*
         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks
         MVC   0(MSG28L,R15),MSG28-DRU$CON1(R1)  Get message
         LA    R15,MSG28L(R15)            Bump past message
         L     R1,SDU_CON                 Get online DASD count
         BAS   R9,EDITFWF                 Edit it
         MVC   0(10,R15),=C', Offline='   Insert text
         LA    R15,10(R15)                Bump past it
         L     R1,SDU_COFF                Get the offline count
         BAS   R9,EDITFWF                 Edit the return code
         MVC   0(8,R15),=C', Total='
         LA    R15,8(R15)
         L     R1,SDU_CON                 Get the online DASD count
         A     R1,SDU_COFF                Add in offline ones
         BAS   R9,EDITFWF                 Edit the return code
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
*
** Look at the number of volumes matched
*
         CLI   PPC_VPREFIXL,$PPC_NOCHK    Don't check volume prefix?
         BE    SDU$MCX                    Yes, skip message
         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks
         MVC   0(MSG33L,R15),MSG33-DRU$CON1(R1)  Get message
         LA    R15,MSG33L+1(R15)          Bump past message
         L     R1,SDU_CMATCH              Get current match count
         BAS   R9,EDITFWF                 Edit the return code
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
         ICM   R1,B'1111',SDU_CMATCH      Hey, wait a second
         BNZ   SDU$MCX                    whew, looks okay
         MVI   MAXCC,8                    Set a bad cond code
         B     EXIT                       ..and leave
SDU$MCX  DS    0H
         EJECT
***********************************************************************
***                                                                 ***
**       Process VATDEF card (ESA or higher)                         **
***                                                                 ***
***********************************************************************
         SPACE 3
         MVC   PVC_IPLUSE(3),=C'PUB'
         MVC   PVC_SYSUSE(3),=C'PUB'
         MVC   PARMLIST+200(6),=C'PUBLIC('
         MVI   PARMLIST+200+6,C' '
         MVC   PARMLIST+207(7),PARMLIST+200
*
** Open VATLST
*
         LA    R3,WRKFILE4                Locate DCB work area
         L     R1,=V(DRU$CON1)
         MVC   0(C_DCBIL,R3),C_DCBI-DRU$CON1(R1)
         MVC   DCBDDNAM-IHADCB(8,R3),DDN_VAT  Get DDNAME
         MVC   PARMLIST(C_LSTIL),C_LSTI-DRU$CON1(R1)
*
         LA    R2,PVC$EOF                 Locate END-OF-FILE area
         STCM  R2,B'0111',DCBEODAD-IHADCB+1(R3) Insert into DCB
*
         OPEN  ((3),(INPUT)),             Open the file                @
               MF=(E,PARMLIST)
*
** Read first record
*
         GET   (3)                        Read record (address in R1)
*
         LA    R0,72-7                    Set max search limit
         LR    R14,R1
PVC$VDL  EQU   *
         CLI   0(R14),C' '                Blank?
         BNE   PVC$VDLX                   No, continue
         LA    R14,1(R14)                 Bump to next byte
         BCT   R0,PVC$VDL                 Process it
         B     PVC$EOF                    End of statement found
PVC$VDLX EQU   *
         CLC   0(7,R14),=C'VATDEF '       VATDEF card?
         BNE   PVC$EOF                    Yes, leave
         MVC   PVC_VATDEF(72),0(R1)       Save card for later
         LA    R14,7(R14)                 Bump past "VATDEF"
PVC$BL   EQU   *
         CLI   0(R14),C','                Delimiter?
         BE    PVC$BLB                    Yes, continue
         CLI   0(R14),C' '                Delimiter?
         BNE   PVC$BLX                    No, check for operand
PVC$BLB  EQU   *
         LA    R14,1(R14)                 Bump to next byte
         BCT   R0,PVC$BL                  Process it
         B     PVC$EOF                    End of card...
PVC$BLX  EQU   *
         CLC   0(7,R14),=C'IPLUSE('       IPLUSE operand?
         BE    PVC$IPL
         CLC   0(7,R14),=C'SYSUSE('       SYSUSE operand?
         BE    PVC$SYS
PVC$ERR  EQU   *
         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks
         MVC   0(MSG22L,R15),MSG22-DRU$CON1(R1) Get message
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
         B     PVC$EOF
PVC$IPL  EQU   *
         LA    R15,PVC_IPLUSE             Locate output field
         LA    R1,PARMLIST+200
         B     PVC$ATTR
PVC$SYS  EQU   *
         LA    R15,PVC_SYSUSE             Locate output field
         LA    R1,PARMLIST+207
PVC$ATTR EQU   *
         LA    R14,7(R14)                 Bump past "xxxUSE("
         SH    R0,=H'7'                   Decrement counter
         CLC   0(7,R14),=C'PUBLIC)'
         BE    PVC$APUB
         CLC   0(8,R14),=C'PRIVATE)'
         BE    PVC$APRI
         CLC   0(8,R14),=C'STORAGE)'
         BNE   PVC$ERR
         MVC   0(3,R15),=C'STR'
         MVC   0(7,R1),=C'STORAGE)'
         LA    R14,8(R14)                 Bump past "STORAGE)"
         SH    R0,=AL2(8-1)               Decrement counter - 1
         B     PVC$AX
PVC$APUB EQU   *
         MVC   0(3,R15),=C'PUB'
         MVC   0(6,R1),=C'PUBLIC)'
         MVI   6(R1),C' '
         LA    R14,7(R14)                 Bump past "PUBLIC)"
         SH    R0,=AL2(7-1)               Decrement counter - 1
         B     PVC$AX
PVC$APRI EQU   *
         MVC   0(3,R15),=C'PRI'
         MVC   0(7,R1),=C'PRIVATE)'
         LA    R14,8(R14)                 Bump past "PRIVATE)"
         SH    R0,=AL2(8-1)               Decrement counter - 1
PVC$AX   EQU   *
         BCT   R0,PVC$BL
*
** End of file
*
PVC$EOF  EQU   *
*
         LA    R3,WRKFILE4
         BAS   R9,CLOSE_FILE              Close file
*
         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks
         MVC   0(MSG21L,R15),MSG21-DRU$CON1(R1) Get message
*        MVC   MSG21T-MSG21(6,R15),=C'VATLST'
         MVC   MSG21A-MSG21(7,R15),PARMLIST+200
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
*
         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks
         MVC   0(MSG21L,R15),MSG21-DRU$CON1(R1) Get message
         MVC   MSG21T-MSG21(6,R15),=C'SYSTEM'
         MVC   MSG21A-MSG21(7,R15),PARMLIST+207
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
*
         BAS   R14,CLEAR_RECOUT           Clear string area to blanks
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
         EJECT
***********************************************************************
***                                                                 ***
**       Merge the VATLST with SYSTEM:                               **
**       WRKFILE4 - Sorted VATLST         (Input)                    **
**       WRKFILE2 - Sorted System Config  (Input)                    **
**       WRKFILE1 - Merged System/VATLST  (Output)                   **
***                                                                 ***
***********************************************************************
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Sort the System UCB information by Volume                         **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         LA    R1,PARMLIST+16             Locate sort string
         MVI   0(R1),7                    Set length (-1)
         MVC   1(8,R1),=C'1,6,CH,A'       Get sort string
         MVC   SF_SORTIN(8),DDN_WF1       Sort Input file
         MVC   SF_SORTOUT(8),DDN_WF2      Sort Output file
*
         BAS   R14,SORT_FILE              Sort WRKFILE1 by volser
         LTR   R15,R15
         BNZ   EXIT
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**       Sort VATLST into WRKFILE4                                   **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
         LA    R1,PARMLIST+16             Locate sort string
         MVI   0(R1),7                    Set length (-1)
         MVC   1(8,R1),=C'1,6,CH,A'       Get sort string
         MVC   SF_SORTIN(8),DDN_VAT        Sort Input file
         MVC   SF_SORTOUT(8),DDN_WF4      Sort Output file
*
         BAS   R14,SORT_FILE              Sort VATLST by VOLSER
         LTR   R15,R15
         BNZ   EXIT
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**       Initialize files for VATLST/System Configuration merge      **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
*
** OPEN sorted VATLST file (input)
*
         LA    R3,WRKFILE4                Locate DCB work area
         L     R1,=V(DRU$CON1)
         MVC   0(C_DCBIL,R3),C_DCBI-DRU$CON1(R1)
         MVC   DCBDDNAM-IHADCB(8,R3),DDN_WF4  Get DDNAME
         MVC   PARMLIST(C_LSTIL),C_LSTI-DRU$CON1(R1)
*
         LA    R2,MVS$VEOF                Locate END-OF-FILE area
         STCM  R2,B'0111',DCBEODAD-IHADCB+1(R3) Insert into DCB
*
         OPEN  ((3),(INPUT)),             Open the file                @
               MF=(E,PARMLIST)
*
** Open system configuration file (INPUT)
*
         LA    R3,WRKFILE2                Locate DCB work area
         L     R1,=V(DRU$CON1)
         MVC   0(C_DCBIL,R3),C_DCBI-DRU$CON1(R1)
         MVC   DCBDDNAM-IHADCB(8,R3),DDN_WF2 Move in DDname
         MVC   PARMLIST(C_LSTIL),C_LSTI-DRU$CON1(R1)
*
         LA    R2,MVS$SEOF                End of File address
         STCM  R2,B'0111',DCBEODAD-IHADCB+1(R3) Insert into DCB
*
         OPEN  ((3),(INPUT)),             Open file                    @
               MF=(E,PARMLIST)
*
** Open merged file (output)
*
         LA    R3,WRKFILE1                Locate DCB work area
         L     R1,=V(DRU$CON1)
         MVC   0(C_DCBOL,R3),C_DCBO-DRU$CON1(R1)
         MVC   DCBDDNAM-IHADCB(8,R3),DDN_WF1 Move in DDNAME
         MVC   PARMLIST(C_LSTOL),C_LSTO-DRU$CON1(R1)
         OPEN  ((3),(OUTPUT)),            Open DCB                     @
               MF=(E,PARMLIST)
*
** Create table
*
         TM    FLAG_X1,$FX1_VTOC          Doing VTOC processing?
         BNO   MVS$IVX                    No, continue
         L     R0,G_DASD                  Get number of DASD
         MH    R0,=AL2(VIL)               Calculate length of table
       GETMAIN R,LV=(0)                   Obtain Storage
         STM   R0,R1,PV_VIT               Save Length and Address
         LR    R8,R1                      Save table address
MVS$IVX  EQU   *
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**        Merge System configuration and VATLST                      **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
MVS$LOOP DS    0H
         BAS   R9,MVS$R4                  Read WRKFILE4 - VATLST
         BAS   R9,MVS$R2                  Read WRKFILE2 - System config
*
** Check for match
*
MVS$DEC  DS    0H
         CLC   WD_VOLS-WD(6,R2),VL_VOLS-VL(R3) Match?
         BE    MVS$COMB                   Yes, combine records...
         BH    MVS$RV                     Need another system record
*
** DASD volume is on the system but is not in the VATLST
*
         LA    R14,WRKREC                 To: address
         LA    R15,WDL                    To: length
         LR    R0,R2                      From: Address
         LA    R1,WDL                     From: length
         MVCL  R14,R0                     Move record
*
         MVC   WRKREC+WD_VMNT-WD(3),PVC_IPLUSE
         LA    R15,WRKREC+WD_DESC-WD      Locate description
         MVI   0(R15),C' '                Get blank
         MVC   1(L'WD_DESC-1,R15),0(R15)  Insert blanks
         BAS   R9,MVS$W1                  Write current record
         BAS   R9,MVS$R2                  Read WRKFILE2 - SYSTEM
         B     MVS$DEC                    Go compare them
*
** VATLST record is not a ONLINE DASD volume
*
MVS$RV   DS    0H
         BAS   R9,MVS$IVAT                Increment VATLST
         BAS   R9,MVS$R4                  READ WRKFILE4 - VATLST
         B     MVS$DEC                    COMPARE RECORDS
*
** Combine the system configuration record with the VATLST
*
MVS$COMC CLC   WD_DEVT-WD(0,R15),VL_DEVT-VL(R3) VATLST device
*
MVS$COMB DS    0H
         LA    R14,WRKREC                 To: Address
         LA    R15,WDL                    To: Length
         LR    R0,R2                      From: Address
         LA    R1,WDL                     From: Length
         MVCL  R14,R0                     Move record
*
         LA    R15,WRKREC                 Locate merged record
         SLR   R1,R1                      Clear register
         IC    R1,WD_DEVTL-WD(R15)        Get device type
         EX    R1,MVS$COMC                Match?
         BE    MVS$COMB_DTX               Device types match!
         BAS   R14,FORMAT_MESSAGE
         MVC   0(MSG8L,R15),MSG8-DRU$CON1(R1)
         LA    R15,MSG8L(R15)             Bump past the message
         MVC   0(6,R15),WD_VOLS-WD(R2)    Move in volume name
         LA    R15,6(R15)                 Bump past it
         MVC   0(8,R15),=C') - UCB='      Move in text
         LA    R15,8(R15)                 Bump past it
         MVC   0(8,R15),WD_DEVT-WD(R2)    Move in UCB device type
         LA    R0,8                       Generate length of Deviec typ
         BAS   R14,LOCATE_FIRST_SPACE     Locate first space
         MVC   0(9,R15),=C', VATLST='     Insert text
         LA    R15,9(R15)                 Bump past it
         MVC   0(8,R15),VL_DEVT-VL(R3)    Move in VATLST device type
         BAS   R14,PRINT_SYSPRINT_RECORD Print the warning message
         LA    R15,WRKREC                 Locate merged record
MVS$COMB_DTX EQU *
         MVC   WD_DESC-WD(L'WD_DESC,R15),VL_DESC-VL(R3) Description
*
         MVC   WD_VMNT-WD(3,R15),=C'   '
         CLI   VL_USE-VL(R3),VL_USE0      Pack usage = Storage?
         BE    MVS$CU0                    Yes, move on
         CLI   VL_USE-VL(R3),VL_USE1      Pack usage = Public?
         BE    MVS$CU1                    Yes, Move on
         MVC   WD_VMNT-WD(3,R15),=C'PRI'
         B     MVS$CUX
MVS$CU0  DS    0H
         MVC   WD_VMNT-WD(3,R15),=C'STR'
         B     MVS$CUX
MVS$CU1  DS    0H
         MVC   WD_VMNT-WD(3,R15),=C'PUB'
MVS$CUX  DS    0H
         CLC   WD_VMNT-WD(3,R15),WD_SMNT-WD(R15) VATLST match system
         BE    MVS$CUCX                   Yes, move on
         L     R1,G_VATMNT                No, Get count
         LA    R1,1(R1)                       Increment it by one
         ST    R1,G_VATMNT                    Save count for later
MVS$CUCX DS    0H
         BAS   R9,MVS$W1                  Write record
         B     MVS$LOOP                   Go get record
*
** VATLST increment routine: Save unused VATLST entry into table
** Note: the first invocation will force a GETMAIN for the table...
*
MVS$IVAT DS    0H
         ICM   R1,B'1111',MVS_IV_VSC      Get current storage location
         BNZ   MVS$IVGX                   We have one, move on
         L     R0,=A(4096*IV_LEN)         Max DASD volumes * Entry len
         GETMAIN R,LV=(0)                 Obtain storage
         ST    R0,MVS_IV_VSL              Save length obtained
         ST    R1,MVS_IV_VSA              Save address of storage
MVS$IVGX DS    0H
         L     R14,MVS_IV_NUM             Obtain Count
         LA    R14,1(R14)                 Increment by 1
         ST    R14,MVS_IV_NUM             Save count
         MVC   IV_VOL-IV(L'IV_VOL,R1),VL_VOLS-VL(R3)   Move in volser
         LA    R1,IV_LEN(R1)              Bump to next entry
         ST    R1,MVS_IV_VSC              Save into table
         BSM   0,R9
*
** Write WRKFILE1 - Merged system configuration/VATLST file
*
MVS$W1   DS    0H
         TM    FLAG_X1,$FX1_VTOC          Doing VTOC processing?
         BNO   MVS$W1VX                   No, continue
         STCM  R8,B'1111',WRKREC+WD_VIT-WD Save VTOC Info table entry
         LA    R8,VIL(R8)                  Bump to next entry
MVS$W1VX EQU   *
*
         PUT   WRKFILE1,WRKREC             Put record on file
         BSM   0,R9
*
** Read WRKFILE2 - Sorted system configuration file
*
MVS$R2   DS    0H
         GET   WRKFILE2                   Get Record
         LR    R2,R1                      Save record address
         BSM   0,R9
*
** Read WRKFILE4 - Sorted VATLST file
*
MVS$R4   DS    0H
         GET   WRKFILE4                   Get Record
         CLC   0(6,R1),=C'VATDEF'         VATDEF?
         BE    MVS$R4                     Yes, skip it
         LR    R3,R1                      Save record address
         BSM   0,R9
*
** End of file for VATLST, echo remaining system to merged record
*
MVS$VEOF DS 0H
         OI    FLAG_R,$FX1_VEOF           Vatlst End of file flag
         TM    FLAG_R,$FX1_SEOF           System Config at EOF?
         BO    MVS$MEOF                   Yes, leave
MVS$VEL  DS    0H
         BAS   R9,MVS$R2                  Read system record
*
         LA    R14,WRKREC                 To: Address
         LA    R15,WDL                    To: Length
         LR    R0,R2                      From: Address
         LA    R1,WDL                     From: Length
         MVCL  R14,R0                     Move record
*
         LA    R15,WRKREC+WD_DESC-WD      Locate description
         MVI   0(R15),C' '                Get blank
         MVC   1(L'WD_DESC-1,R15),0(R15)  Insert blanks
         BAS   R9,MVS$W1                  Write record
         B     MVS$VEL                    Read next record
*
** End of file for System, Save unused VATLST entries
*
MVS$SEOF DS    0H
         OI    FLAG_R,$FX1_SEOF           System End of file flag
         TM    FLAG_R,$FX1_VEOF           VATLST at EOF?
         BO    MVS$MEOF                   Yes, leave
MVS$SEL  DS    0H
         BAS   R9,MVS$R4                  Read VATLST record
         BAS   R9,MVS$IVAT                Save record into table
         B     MVS$SEL                    Read next record
*
** All records read from VATLST and system file, close WORK FILES
*
MVS$MEOF DS    0H
*
         LA    R3,WRKFILE1
         BAS   R9,CLOSE_FILE              Close file
         LA    R3,WRKFILE2
         BAS   R9,CLOSE_FILE              Close file
         LA    R3,WRKFILE4
         BAS   R9,CLOSE_FILE              Close file
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**  Print mount differences                                          **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
         ICM   R2,B'1111',G_VATMNT        Get VATLST-system mount
         BZ    MVS$MMX                    Zero, move on
         BAS   R14,FORMAT_MESSAGE         Clear output record to blanks
         MVC   0(MSG3L,R15),MSG3-DRU$CON1(R1)
         LA    R15,MSG3L+1(R15)           Bump past it
         LR    R1,R2                      Get the difference count
         BAS   R9,EDITFWF                 Edit the number
         MVC   1(7,R15),=C'volumes'       Message suffix
         BAS   R14,PRINT_SYSPRINT_RECORD Print the record
MVS$MMX  DS    0H
         SPACE 3
**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
** Print VATLST entries that are not in use
**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         SPACE 2
*
** See if we have any VATLST entries to print
*
         ICM   R3,B'1111',MVS_IV_VSA      Get VATLST table address
         BZ    MVS$PVX                    Not there, leave
         ICM   R4,B'1111',MVS_IV_VSC      Get current location
         BZ    MVS$PVX                    Not there, leave
*
** Print "Following" message
*
         BAS   R14,CLEAR_RECOUT           Clear string area to blanks
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
*
         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks
         MVC   0(MSG12L,R15),MSG12-DRU$CON1(R1)
         LA    R15,MSG12L+1(R15)          Bump past prefix
         L     R1,MVS_IV_NUM              Get number
         BAS   R9,EDITFWF                 Edit it
         L     R1,=V(DRU$CON1)
         MVC   0(MSG12AL,R15),MSG12A-DRU$CON1(R1)
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
*
** Loop through table printing entries on SYSPRINT
*
         LA    R15,IV_LEN                 Length of table entry
         SR    R3,R15                     Backup for loop logic
         SR    R4,R15                     Stop on the last entry...
MVS$PVML DS    0H
         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks
         MVC   0(MSG12L,R15),MSG12-DRU$CON1(R1)
         LA    R5,MSG12L+1(R15)           Locate offset to start
         ST    R5,PV_DECB                 Save output location
         LA    R6,#VATLSTE                Number of entries across
MVS$PVLL DS    0H
         LA    R3,IV_LEN(R3)              Bump to next entry (Input)
         CR    R3,R4                      Are we at the end
         BH    MVS$PVLX                   Yes, leave
         MVC   0(6,R5),IV_VOL-IV(R3)      Move in VOLSER
         MVI   6(R5),C','                 Insert comma
         LA    R5,8(R5)                   Bump to next entry (Output)
         BCT   R6,MVS$PVLL                Do next entry
* Next 3 instructions are to keep dangling "volser, +" if last one...
         LA    R1,IV_LEN(R3)              Bump to next entry (Input)
         CR    R1,R4                      Are we at the end
         BH    MVS$PVME                   Yes, leave
         MVI   1(R5),C'+'                 Indicate there's more commin'
         BAS   R14,PRINT_SYSPRINT_RECORD Print record
         B     MVS$PVML                   Refresh line
*
** End of the table found, Print last record (if anything on it)
*
MVS$PVLX DS    0H
         L     R1,PV_DECB                 Get output location
         CLI   0(R1),C' '                 Anything on last line?
         BE    MVS$PVMX                   No, move on
MVS$PVME EQU   *
         SH    R5,=H'2'                   Backup to last comma
         MVI   0(R5),C' '                 Rub out comma
         BAS   R14,PRINT_SYSPRINT_RECORD Print last detail record
MVS$PVMX DS    0H
*
** Free the table's storage
*
         L     R0,MVS_IV_VSL              Save length obtained
         L     R1,MVS_IV_VSA              Save address of storage
         FREEMAIN R,LV=(0),A=(1)          Free the storage
*
** Common exit from PrintVATLST processing
*
MVS$PVX  DS    0H
         EJECT
***********************************************************************
***                                                                 ***
**        Process the VTOCs                                          **
***                                                                 ***
***********************************************************************
         SPACE 2
PROCESS_VTOCS EQU *
         TM    FLAG_X1,$FX1_VTOC          Doing VTOC processing?
         BNO   PV$X                       No, continue
*
         BAS   R14,CLEAR_RECOUT           Clear string area to blanks
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
*
         TIME  BIN
         STM   R0,R1,PV_STOD              Save start time and date
*
** OPEN Merged file (INPUT)
*
         LA    R3,WRKFILE1                Locate DCB work area
         L     R1,=V(DRU$CON1)            Locate constant CSECT
         MVC   0(C_DCBIL,R3),C_DCBI-DRU$CON1(R1) Initialize DCB
         MVC   DCBDDNAM-IHADCB(8,R3),DDN_WF1 Move in DDNAME
         MVC   PARMLIST(C_LSTIL),C_LSTI-DRU$CON1(R1) Initialize parm
         LA    R2,PV$LX                   Locate End-of-File routine
         STCM  R2,B'0111',DCBEODAD-IHADCB+1(R3) Save EOF routine in DCB
         OPEN  ((3),(INPUT)),MF=(E,PARMLIST) Open the file
*
** Allocate VTOC output list
*
         LA    R3,WRKFILE2                Locate DCB work area
         L     R1,=V(DRU$CON1)            Locate constant CSECT
         MVC   0(C_DCBOL,R3),C_DCBO-DRU$CON1(R1)  Initialize DCB
         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'WRKFILE2' Set DDNAME
         MVC   PARMLIST(C_LSTOL),C_LSTO-DRU$CON1(R1) Initialize parm
         OPEN  ((3),(OUTPUT)),MF=(E,PARMLIST) Open file
*
** Initialize for RDJFCB processing
*
         LA    R1,PV_EXLST                Locate the Exit list
         LA    R14,E$OPENA                Locate DCB ABEND exit
         ST    R14,4(R1)                  Insert into EXLST
         OI    4(R1),X'11'                Set as DCB ABEND exit
         LA    R14,PV_JFCB                Locate JFCB return area
         ST    R14,0(R1)                  Save into EXLST
         OI    0(R1),X'87'                Set for JFCB + End of list
         SPACE 2
**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
** Initialize for new volume record:
** o Read record
** o Locate VTOC information table and initialize it
** o Dynamically allocate the volume
**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
PV$L     DS    0H
         GET   WRKFILE1                   Get input record
         LR    R2,R1                      Save address of record
         XC    PV_DCOUNT(4),PV_DCOUNT     Reset count
*
** Print that we are processing a new volume
*
         TIME  BIN
         ST    R0,DOUBLE                  Save time
         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks
         MVC   0(MSG40L,R15),MSG40-DRU$CON1(R1)
         MVC   MSG40UCB-MSG40(L'WD_UCB,R15),WD_UCB-WD(R2)
         MVC   MSG40VOL-MSG40(L'WD_VOLS,R15),WD_VOLS-WD(R2)
         LA    R15,MSG40L(R15)            Bump past the message
         L     R1,DOUBLE
         BAS   R14,CONVERT_BINARY_TIME    " hh:mm:ss"
         LA    R15,9(R15)                 Bump past " hh:mm:ss"
         MVC   1(8,R15),=C'- number'
         LA    R15,1+8+1(R15)
         L     R1,PV_VCOUNT               Get current count
         LA    R1,1(R1)
         ST    R1,PV_VCOUNT               Save new count
         BAS   R9,EDITFWF
         MVC   1(2,R15),=C'of'
         LA    R15,1+2+1(R15)
         L     R1,SDU_CMATCH              Get total match count
         BAS   R9,EDITFWF
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
*
** Dynamically allocate the volume
*
         LA    R14,WD_DEVTA-WD(R2)        Locate device type
         LA    R15,WD_VOLS-WD(R2)         Locate the volume
         L     R8,=V(DRU$ALCV)            Locate CSECT
         BASSM R9,R8                      Allocate volume
*=> DOUBLE2 has returned DDNAME, R15 has RC from SVC 99/DYNALLOC
         ICM   R8,B'1111',WD_VIT-WD(R2)   Locate VTOC info Table entry
         XC    0(VIL,R8),0(R8)            Clear table entry
         L     R1,DOUBLE2                 Locate DDNAME
         MVC   VI_DDN-VI(8,R8),0(R1)      Save DDNAME
         MVC   VI_SER-VI(6,R8),WD_VOLS-WD(R2) Get volume serial
         LTR   R15,R15                    Volume allocated?
         BZ    PV$LIX                     Yes, continue
*
** Dynamic Allocation to volume failed, print error message
*
         LR    R5,R15                     Save return code
         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks
         MVC   0(MSG15L,R15),MSG15-DRU$CON1(R1)
         LA    R15,MSG15L(R15)            Bump past the message
         LR    R1,R5                      Get the return code
         BAS   R9,EDITFWF                 Edit the return code
         MVC   0(9,R15),=C', Volume='     Text
         MVC   9(6,R15),WD_VOLS-WD(R2)    Move in volume
         LA    R15,9(R15)
         LA    R0,6
         BAS   R14,LOCATE_FIRST_SPACE
         MVC   0(11,R15),=C', S99ERROR='
         LA    R15,11(R15)
         LA    R14,HEADREC                Get address of work area
         UNPK  0(5,R15),S99ERROR-S99RB(3,R14)
         MVZ   0(4,R15),=8X'00'
         TR    0(4,R15),=C'0123456789ABCDEF'
         LA    R15,4(R15)
         MVC   0(10,R15),=C', S99INFO='
         LA    R15,10(R15)
         UNPK  0(5,R15),S99INFO-S99RB(3,R14)
         MVZ   0(4,R15),=8X'00'
         TR    0(4,R15),=C'0123456789ABCDEF'
         LA    R15,4(R15)
         MVI   0(R15),C' '
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
         B     PV$L
*
** Common exit from Initialization processing
*
PV$LIX   EQU   *
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Open the VTOC for processing                                      **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
*
** Initialize the VTOC DCB
*
         LA    R3,WRKFILE3                Locate DCB work area
         L     R1,=V(DRU$CON1)            Locate constants CSECT
         MVC   0(C_DCBVL,R3),C_DCBV-DRU$CON1(R1) Initialize DCB
         L     R1,DOUBLE2                 Locate returned DDNAME
         MVC   DCBDDNAM-IHADCB(8,R3),0(R1) Save it for volume access
         LA    R1,PV_EXLST                Locate for Exit list
         STCM  R1,B'0111',DCBEXLST-IHADCB+1(R3) SAVE INTO DCB
         LA    R1,PV$LVX                  Locate End-of-File routine
         STCM  R1,B'0111',DCBEODAD-IHADCB+1(R3) Save into DCB
         XC    E_OPENA_CODE(4),E_OPENA_CODE  Reset code
*
** Perform a Read_Job_File_Control_Block
*
         L     R1,=V(DRU$CON1)            Locate cons
         MVC   PARMLIST(C_RDJFCBL),C_RDJFCB-DRU$CON1(R1)
         RDJFCB ((3),(INPUT)),MF=(E,PARMLIST) Read the JFCB
         LTR   R15,R15                    Test RC
         BZ    PV$LRJX                    Okay move on
         LR    R5,R15                     Save return code
         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks
         MVC   0(MSG16L,R15),MSG16-DRU$CON1(R1)
         LA    R15,MSG16L(R15)            Bump past the message
         LR    R1,R5                      Get the return code
         BAS   R9,EDITFWF                 Edit the return code
         MVC   0(9,R15),=C', Volume='     Text
         MVC   9(6,R15),WD_VOLS-WD(R2)    Move in volume
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
         B     PV$L
PV$LRJX  EQU   *
         LA    R1,PV_JFCB
         MVI   JFCBDSNM-INFMJFCB(R1),X'04'
         MVC   JFCBDSNM+1-INFMJFCB(43,R1),JFCBDSNM-INFMJFCB(R1)
*        MVC   JFCBVOLS-INFMJFCB(6,R1),WD_VOLS-WD(R2)
         OI    JFCBTSDM-INFMJFCB(R1),JFCNWRIT
*
** Open the file
*
         L     R1,=V(DRU$CON1)
         MVC   PARMLIST(C_LSTIL),C_LSTI-DRU$CON1(R1)
         OPEN  ((3),(INPUT)),TYPE=J,MF=(E,PARMLIST)
         ICM   R0,B'1111',E_OPENA_CODE    Get open ABEND code
         BNZ   PV$OPENE
         LTR   R15,R15                    Test RC
         BZ    PV$LOX                     Okay move on
PV$OPENE EQU   *
         LR    R5,R15                     Save return code
         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks
         MVC   0(MSG17L,R15),MSG17-DRU$CON1(R1)
         LA    R15,MSG17L(R15)            Bump past the message
         LR    R1,R5                      Get the return code
         BAS   R9,EDITFWF                 Edit the return code
         ICM   R1,B'1111',E_OPENA_CODE    Get open ABEND code
         BZ    PV$OEAX
         N     R1,=A(X'FFF0FF00')         TURN OFF UNNEEDED BITS
         MVC   0(9,R15),=C', ABEND S'     TEXT
         LA    R15,9(R15)                 BUMP PAST IT
         ST    R1,DOUBLE                  SAVE ABEND CODE
         UNPK  0(9,R15),DOUBLE(5)                   ---+
         MVZ   0(8,R15),=8X'00'                        | BINARY TO HEX
         TR    0(8,R15),=C'0123456789ABCDEF'        ---+
         MVI   3(R15),C'-'                MOVE IN DASH
         LA    R15,6(R15)
PV$OEAX  EQU   *
         MVC   0(9,R15),=C', Volume='     Text
         MVC   9(6,R15),WD_VOLS-WD(R2)    Move in volume
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
         B     PV$L
*
** Processing for this volume has ended, close VTOC file
*
PV$LVX   EQU   *
         TM    WD_FLAG1-WD(R2),$WDF1_CVAFF CVAF failed?
         BO    PV$LVCVX                   Yes, skip free
         TM    WD_FLAG1-WD(R2),$WDF1_IVTOC Indexed VTOC?
         BNO   PV$LVCVX                   No, dont free indexed stuff
         CVAFDIR ACCESS=RLSE,BUFLIST=0,IXRCDS=NOKEEP,MF=(E,PV_CVPL)
PV$LVCVX DS    0H
*        Note: R3 has DCB address
         BAS   R9,CLOSE_FILE              Close file
         TM    PPC_FLAG1,$PPC_F1VERB      Verbose mode?
         BNO   PV$LVXVX
*-Print elasped time and dataset count
PV$LVXVX DS    0H
         B     PV$L                       Next record
*
** Common exit from Open processing
*
PV$LOX   EQU   *
         TM    WD_FLAG1-WD(R2),$WDF1_IVTOC Indexed VTOC?
         BNO   PV$LNILS                   No, do Non-Indexed READ
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**       Indexed VTOC support                                        **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks
         MVC   0(MSG41L,R15),MSG41-DRU$CON1(R1)
         MVC   MSG41T-MSG41(4,R15),=C'CVAF'
         MVC   MSG41V-MSG41(6,R15),WD_VOLS-WD(R2)
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
*
** Initialize for Indexed VTOC processing
*
         LA    R1,PV_CVPL                 Locate CVPL
         L     R14,=V(DRU$CON1)
         MVC   0(C_CVPLL,R1),C_CVPL-DRU$CON1(R14)
         SLR   R14,R14                    Clear register
         ICM   R14,B'0111',DCBDEBA-IHADCB(R3) Get DEB address from DCB
         ST    R14,CVDEB-CVPL(R1)         Save DEB address
*
         LA    R14,PV_BAREA               Locate buffer area
         ST    R14,CVBUFL-CVPL(R1)        Save it in CVPL
         XC    0(BFLHLN,R14),0(R14)       Clear area
         MVI   BFLHKEY-BFLHDR(R14),BFLHDSCB DSCBs to be read w/Buf list
         MVI   BFLHNOE-BFLHDR(R14),1      Set number to retrieve
*
         LA    R14,BFLHLN(R14)            Locate to entry location
         XC    0(BFLELN,R14),0(R14)       Clear area
         LA    R15,WRKREC+PVR_DSCB-PVR    Locate DSCB area
         ST    R15,BFLEBUF-BFLE(R14)      Save DSCB return area
         LA    R15,140                    Get length of DSCB
         STC   R15,BFLELTH-BFLE(R14)      Save length
*
** Read next indexed VTOC record
*
PV$LCSL  EQU   *
       CVAFSEQ MF=(E,PV_CVPL)             Access the VTOC
         MVI   PV_CVPL+CVFCTN-CVPL,CVSEQGT Make ACCESS=GT
         LTR   R15,R15                    Test RC
         BZ    PV$LD                      Okay move on
         CH    R15,=H'4'                  Right RC for CVSTAT?
         BNE   PV$LCSN4                   No, error...
         CLI   PV_CVPL+CVSTAT-CVPL,STAT032 End of data
         BE    PV$LVX                     Yes, leave
PV$LCSN4 EQU   *
         LR    R9,R15                     Save return code
         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks
         MVC   0(MSG18L,R15),MSG18-DRU$CON1(R1)
         LA    R15,MSG18L(R15)            Bump past the message
         LR    R1,R9                      Get the return code
         BAS   R9,EDITFWF                 Edit the return code
         MVC   0(9,R15),=C', CVSTAT='     Text
         LA    R15,9(R15)                 Bump past it
         SLR   R1,R1                      Clear register
         IC    R1,PV_CVPL+CVSTAT-CVPL     Get status byte
         BAS   R9,EDITFWF                 Edit the return code
         MVC   0(9,R15),=C', Volume='     Text
         MVC   9(6,R15),WD_VOLS-WD(R2)    Move in volume
         LA    R15,9+6(R15)
         MVC   0(8,R15),=C', DSCB #'
         LA    R15,8(R15)
         ICM   R1,B'1111',PV_DCOUNT       Get current DSCB count
         LA    R1,1(R1)
         BAS   R9,EDITFWF                 Edit the return code
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
         ICM   R1,B'1111',PV_DCOUNT       Get current DSCB count
         BNZ   PV$LVX                     Not on the first one, give up
*- or do we have to give up?????????
         OI    WD_FLAG1-WD(R2),$WDF1_CVAFF Set that CVAF failed
 SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Read Non-Index VTOC with BSAM                                     **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
 SPACE 2
PV$LNILS EQU   *
         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks
         MVC   0(MSG41L,R15),MSG41-DRU$CON1(R1)
         MVC   MSG41T-MSG41(4,R15),=C'BSAM'
         MVC   MSG41V-MSG41(6,R15),WD_VOLS-WD(R2)
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
*
         LA    R1,PV_DECB
         L     R14,=V(DRU$CON1)
         MVC   0(C_DECBL,R1),C_DECB-DRU$CON1(R14)
         ST    R3,DECDCBAD-DECB(R1)       Save DCB address
         LA    R14,WRKREC+PVR_DSCB-PVR    Locate DSCB return area
         ST    R14,DECAREA-DECB(R1)       Set DSCB return area
PV$LNIL  EQU   *
         LA    R1,PV_DECB                 Locate DECB
         READ  (1),SF,MF=E                Read next VTOC record
         LA    R1,PV_DECB                 Locate DECB
         CHECK (1)                        Wait for I/O to complete
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**  Process the DSCB returned to us                                  **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
PV$LD    EQU   *
         L     R1,PV_DCOUNT
         LA    R1,1(R1)
         ST    R1,PV_DCOUNT
*
** Check the format type
*
         LA    R5,WRKREC+PVR_DSCB-PVR    Locate to DSCB returned
*
         CLI   DS1FMTID-IECSDSL1(R5),C'1' Format 1 DSCB?
         BE    PV$LDF1
         CLI   IECSDSF2-IECSDSL2(R5),C'2' Format 2 DSCB?
         BE    PV$LDF2
         CLI   DS3FMTID-IECSDSL3(R5),C'3' Format 3 DSCB?
         BE    PV$LDF3
         CLI   DS4IDFMT-IECSDSL4(R5),C'4' Format 4 DSCB?
         BE    PV$LDF4
         CLI   DS5FMTID-IECSDSL5(R5),C'5' Format 5 DSCB?
         BE    PV$LDF5
         CLI   DS6FMTID-IECSDSL6(R5),C'6' Format 6 DSCB?
         BNE   PV$LDFX
         L     R1,VI_F6-VI(R8)
         LA    R1,1(R1)
         ST    R1,VI_F6-VI(R8)
         B     PV$LDFX
*
** Format 1
*
PV$LDF1  EQU   *
         L     R1,VI_F1-VI(R8)
         LA    R1,1(R1)
         ST    R1,VI_F1-VI(R8)
*
         TM    PPC_FLAG2,$PPC_F2ORU       Only RECFM=U?
         BNO   PV$LD1RUX                  No, take all of them
         TM    DS1RECFM-IECSDSL1(R5),DS1RECFU  RECFM=U?
         BNO   PV$LDFX                         No, skip this one
         TM    PPC_FLAG2,$PPC_F2OLL       Only Load Libraries?
         BNO   PV$LD1RUX                  No, take all of them
         TM    DS1DSORG-IECSDSL1(R5),DS1DSGPO  DSORG=PO?
         BNO   PV$LDFX                         No, skip this one
PV$LD1RUX DS   0H
*
         LA    R4,WRKREC                  Locate start of record
         MVC   PVR_UCB-PVR(4,R4),WD_UCB-WD(R2)
         MVC   PVR_VOLS-PVR(6,R4),WD_VOLS-WD(R2)
         MVI   PVR_CAT-PVR(R4),C' '       Set default value
*
         TM    PPC_FLAG1,$PPC_F1CATC      Skip catalog check?
         BNO   PV$LD1CX                   Yes, skip out of here
         L     R1,=V(DRU$CON1)
         MVC   PARMLIST(C_LOCATEL),C_LOCATE-DRU$CON1(R1)
         ST    R5,PARMLIST+4              Save into parmeter list
         LA    R1,WORKAREA                Locate the work area
         ST    R1,PARMLIST+12             Save into parmeter list
         LOCATE PARMLIST                  Is the Data set catalogued?
         LTR   R15,R15                    Well?
         BNZ   PV$LD1CU                   Nope, move on
         CLC   PVR_VOLS-PVR(6,R4),WORKAREA+6 Volume match?
         BE    PV$LD1CX                   Yes, its okay
PV$LD1CU EQU   *
         MVI   PVR_CAT-PVR(R4),C'Y'       Not Catalogued flag
         L     R1,VI_UNCAT-VI(R8)
         LA    R1,1(R1)
         ST    R1,VI_UNCAT-VI(R8)
PV$LD1CX EQU   *
*
         CLC   0(12,R5),=C'SYS1.VTOCIX.'
         BNE   PV$LD1IXX
         CLC   12(6,R5),PVR_VOLS-PVR(R4)  SYS1.VTOCIX.xxxxxx
         BE    PV$LD1IXX
         CLC   13(6,R5),PVR_VOLS-PVR(R4)  SYS1.VTOCIX.Vxxxxxx
         BE    PV$LD1IXX
         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks
         MVC   0(MSG9L,R15),MSG9-DRU$CON1(R1) Get message
         LA    R15,MSG9L(R15)             Bump past message
         MVC   0(6,R15),PVR_VOLS-PVR(R4)  Insert volume
         MVC   6(6,R15),=C', DSN='        Insert text
         MVC   6+6(44,R15),0(R5)          Get Dataset name
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
PV$LD1IXX EQU  *
         CLC   0(11,R5),=C'SYS1.VVDS.V'
         BNE   PV$LD1VVX
         CLC   11(6,R5),PVR_VOLS-PVR(R4)
         BE    PV$LD1VVX
         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks
         MVC   0(MSG9L,R15),MSG9-DRU$CON1(R1)
         LA    R15,MSG9L(R15)             Bump past message
         MVC   0(6,R15),PVR_VOLS-PVR(R4)  Insert volume
         MVC   6(6,R15),=C', DSN='        Insert text
         MVC   6+6(44,R15),0(R5)          Get Dataset name
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
PV$LD1VVX EQU  *
*
         LA    R15,PVR_DSORG-PVR(R4)
         TM    DS1DSORG-IECSDSL1(R5),DS1DSGIS
         BO    PV$LDDIS
         TM    DS1DSORG-IECSDSL1(R5),DS1DSGPS
         BO    PV$LDDPS
         TM    DS1DSORG-IECSDSL1(R5),DS1DSGDA
         BO    PV$LDDDA
         TM    DS1DSORG-IECSDSL1(R5),DS1DSGPO
         BO    PV$LDDPO
         TM    DS1DSORG+1-IECSDSL1(R5),DS1ORGAM
         BO    PV$LDDAM
         L     R1,VI_UN-VI(R8)
         LA    R1,1(R1)
         ST    R1,VI_UN-VI(R8)
         B     PV$LDDX
PV$LDDAM EQU   *
         MVC   0(2,R15),=C'AM'
         L     R1,VI_AM-VI(R8)
         LA    R1,1(R1)
         ST    R1,VI_AM-VI(R8)
         B     PV$LDDX
PV$LDDIS EQU   *
         MVC   0(2,R15),=C'IS'
         L     R1,VI_IS-VI(R8)
         LA    R1,1(R1)
         ST    R1,VI_IS-VI(R8)
         B     PV$LDDX
PV$LDDPO EQU   *
         MVC   0(2,R15),=C'PO'
         LA    R15,2(R15)
         L     R1,VI_PO-VI(R8)
         LA    R1,1(R1)
         ST    R1,VI_PO-VI(R8)
         B     PV$LDDCU
PV$LDDPS EQU   *
         MVC   0(2,R15),=C'PS'
         LA    R15,2(R15)
         L     R1,VI_PS-VI(R8)
         LA    R1,1(R1)
         ST    R1,VI_PS-VI(R8)
         B     PV$LDDCU
PV$LDDDA EQU   *
         MVC   0(2,R15),=C'DA'
         LA    R15,2(R15)
         L     R1,VI_DA-VI(R8)
         LA    R1,1(R1)
         ST    R1,VI_DA-VI(R8)
*        B     PV$LDDCU
PV$LDDCU EQU   *
         TM    DS1DSORG-IECSDSL1(R5),DS1DSGIS
         BNO   PV$LDDX
         MVI   0(R15),C'U'
*        B     PV$LDDX
PV$LDDX  EQU   *
         PUT   WRKFILE2,WRKREC
         ICM   R8,B'1111',WD_VIT-WD(R2)   Locate VTOC info Table entry
         B     PV$LDFX
*
** Format 2
*
PV$LDF2  EQU   *
         L     R1,VI_F2-VI(R8)
         LA    R1,1(R1)
         ST    R1,VI_F2-VI(R8)
         B     PV$LDFX
*
** Format 3
*
PV$LDF3  EQU   *
         L     R1,VI_F3-VI(R8)
         LA    R1,1(R1)
         ST    R1,VI_F3-VI(R8)
         B     PV$LDFX
*
** Format 4
*
PV$LDF4  EQU   *
         L     R1,VI_F4-VI(R8)
         LA    R1,1(R1)
         ST    R1,VI_F4-VI(R8)
         B     PV$LDFX
*
** Format 5
*
PV$LDF5  EQU   *
         L     R1,VI_F5-VI(R8)
         LA    R1,1(R1)
         ST    R1,VI_F5-VI(R8)
*>       B     PV$LDFX                    Fall into PV$LDFX!!!!!!!!!!!
*
** End of format processing
*
PV$LDFX  EQU   *
         TM    WD_FLAG1-WD(R2),$WDF1_CVAFF CVAF failed?
         BO    PV$LNIL                    Yes, do BSAM not CVAF
         TM    WD_FLAG1-WD(R2),$WDF1_IVTOC Indexed VTOC?
         BNO   PV$LNIL                    No, do Non-Indexed READ
         B     PV$LCSL                    Do next CVAFSEQ read
**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
** End of file on input merged volume file
**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
PV$LX    DS    0H
*
** Close the files
*
         LA    R3,WRKFILE1
         BAS   R9,CLOSE_FILE              Close file
         LA    R3,WRKFILE2
         BAS   R9,CLOSE_FILE              Close file
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**        Print trivia about elasped time reading vtoc               **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
         TIME  BIN
         STM   R0,R1,PV_ETOD              Save end time and date
         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks
         MVC   0(MSG34L,R15),MSG34-DRU$CON1(R1)
         LA    R15,MSG34L(R15)            Bump past the message
         L     R1,PV_STOD
         BAS   R14,CONVERT_BINARY_TIME    " hh:mm:ss"
         LA    R15,9(R15)                 Bump past " hh:mm:ss"
         MVC   1(8,R15),=C'ended at'
         LA    R15,1+8(R15)
         L     R1,PV_ETOD
         BAS   R14,CONVERT_BINARY_TIME    " hh:mm:ss"
*-Need elapsed time here
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**  Initialize for VTOCRPT processing                                **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
*
** Set up title for VTOC listing
*
         LA    R1,C_STVL
         ST    R1,PRR_TITLE               Set title
*
** Open VTOCRPT file
*
         LA    R3,REPORT                  Locate DCB work area
         L     R1,=V(DRU$CON1)
         MVC   0(C_DCBOL,R3),C_DCBO-DRU$CON1(R1)
         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'VTOCRPT'
         MVC   PARMLIST(C_LSTOL),C_LSTO-DRU$CON1(R1)
         OPEN  ((3),(OUTPUT)),            OPEN file                    @
               MF=(E,PARMLIST)
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**        Create DSN list by Volume                                  **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
         TM    PPC_FLAG2,$PPC_F2DO        Dataonly?
         BO    PV$DLSH
*
** Print "DSN LIST" "BY VOL" in big letters
*
         LA    R1,C_DSNLV                 Data Set List by Volume
         ST    R1,PRR_STITLE              Set subtitle
         MVI   PRR_LC,99                  Start on new page
*
         LA    R1,W_RH2
         MVI   0(R1),C' '
         MVI   1(R1),C'*'
         MVC   2(132-1,R1),1(R1)
         LA    R1,W_RH3
         MVI   0(R1),C' '
         MVC   1(133-1,R1),0(R1)
         LA    R1,W_RH4
         MVI   0(R1),C' '
         MVC   1(133-1,R1),0(R1)
*
         L     R14,=V(DRU$CON1)
         LA    R1,C_BLDL-DRU$CON1(R14)    Locate string
         LA    R0,BLETRSA
         L     R15,=V(DRU$BLET)
         BASR  R14,R15
*
         BAS   R14,CLEAR_RECOUT           Clear recout to blanks
         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT
         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT
*
         L     R14,=V(DRU$CON1)
         LA    R1,C_BLBV-DRU$CON1(R14)    Locate string
         LA    R0,BLETRSA
         L     R15,=V(DRU$BLET)
         BASR  R14,R15
*
         BAS   R14,CLEAR_RECOUT           CLEAR RECOUT
         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT
         MVI   RECOUT,C'*'                GET DASH
         MVC   RECOUT+1(132-1),RECOUT ..PROPAGATE IT
         MVI   RECOUT,C' '                FBA BYTE
         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT
*
         L     R8,=V(DRU$RVOL)            Locate CSECT
         BASSM R9,R8                      Reset heading lines
PV$DLSH  DS    0H
*
** Sort the VTOC records by DSN
*
         LA    R1,PARMLIST+16             Locate sort string
         MVI   0(R1),7+11                 Set length (-1)
         MVC   1(8,R1),=C'1,6,CH,A'       Get sort string
         MVC   1+8(11,R1),=C',11,44,CH,A'
         MVC   SF_SORTIN(8),DDN_WF2       Sort Input file
         MVC   SF_SORTOUT(8),DDN_WF3      Sort Output file
*
         BAS   R14,SORT_FILE              Sort by volume
         LTR   R15,R15                    Successful?
         BNZ   PV$DLVX                    No, skip report
*
** OPEN sorted VTOC file
*
         LA    R3,WRKFILE3                LOCATE DCB WORK AREA
         L     R1,=V(DRU$CON1)
         MVC   0(C_DCBIL,R3),C_DCBI-DRU$CON1(R1)
         MVC   DCBDDNAM-IHADCB(8,R3),DDN_WF3  GET DDNAME
         MVC   PARMLIST(C_LSTIL),C_LSTI-DRU$CON1(R1)
         LA    R1,PV$DLVLX                Locate for End-of-File
         STCM  R1,B'0111',DCBEODAD-IHADCB+1(R3) SAVE INTO DCB
         OPEN  ((3),(INPUT)),MF=(E,PARMLIST)
         XC    LASTVOLP(6),LASTVOLP
*
** Process record from sorted file
*
PV$DLVL  EQU   *
         GET   WRKFILE3                   Get record
         LR    R4,R1                      Save record location
*
         CLI   LASTVOLP,0                 First time thru?
         BE    PV$DLVLV                   Yes, do volume start
         CLC   PVR_VOLS-PVR(6,R4),LASTVOLP  Match?
         BE    PV$DLVLVX                  Yes, move on
         BAS   R14,PV$DLVT
         MVI   PRR_LC,99                  Start on new page
PV$DLVLV EQU   *
         XC    PV_DECB(4),PV_DECB         Clear Dataset Count
         MVC   LASTVOLP(6),PVR_VOLS-PVR(R4) Save new volume group
PV$DLVLVX EQU  *
         L     R1,PV_DECB
         LA    R1,1(R1)
         ST    R1,PV_DECB
*
         BAS   R9,VTOC_DETAIL_RECORD      Format Detail record
         BAS   R14,PRINT_REPORT_RECORD    Print report
**
         L     R1,PV_TCOUNT               Get current count
         LA    R1,1(R1)                   Increment by 1
         ST    R1,PV_TCOUNT               Save new count
**
         LA    R1,PVR_DSCB-PVR(R4)
         CLI   DS1SMSFG-IECSDSL1(R1),0    SMS flags set?
         BE    PV$DLSMSX                  No, continue
         L     R1,PV_SCOUNT
         LA    R1,1(R1)
         ST    R1,PV_SCOUNT
         TM    PPC_FLAG1,$PPC_F1SMSMC     Doing SMS check?
         BNO   PV$DLSMSX                  No, continue
         TM    PPC_FLAG1,$PPC_F1VERB      Verbose mode?
         BNO   PV$DLSMSX
         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks
         MVC   0(MSG35L,R15),MSG35-DRU$CON1(R1)
         UNPK  MSG35F-MSG35(3,R15),DS1SMSFG-IECSDSL1(2,R8)
         MVZ   MSG35F-MSG35(2,R15),=8X'00'
         TR    MSG35F-MSG35(2,R15),=C'0123456789ABCDEF'
         MVI   MSG35F+2-MSG35(R15),C' '
         MVC   MSG35V-MSG35(6,R15),PVR_VOLS-PVR(R4)
         LA    R15,MSG35L(R15)            Bump past the message
         MVC   0(44,R15),PVR_DSCB-PVR(R4)
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
PV$DLSMSX DS   0H
**
         B     PV$DLVL                    Read next record
*
** Close Sorted VTOC file
*
PV$DLVLX EQU   *
         BAS   R14,PV$DLVT
         LA    R3,WRKFILE3
         BAS   R9,CLOSE_FILE              Close file
         B     PV$DLVX
*
** Print trailer message
*
PV$DLVT  EQU   *
         ST    R14,PV_DECB+4              Save return address
         TM    PPC_FLAG2,$PPC_F2DO        Dataonly?
         BO    PV$DLVTX
         MVI   RECOUT+1,C'-'
         MVC   RECOUT+2(132-1),RECOUT+1
         MVI   RECOUT,C' '
         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT
         BAS   R14,CLEAR_RECOUT
         L     R1,=V(DRU$CON1)
         MVC   1(L'C_NUMV,R15),C_NUMV-DRU$CON1(R1)
         LA    R15,1+31+1(R15)
         L     R1,PV_DECB
         BAS   R9,EDITFWF
         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT
PV$DLVTX DS    0H
         L     R14,PV_DECB+4              Get return address
         BSM   0,R14                      Return to caller
*
** Common exit from DSN-list-by-Volume processing
*
PV$DLVX  EQU   *
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**        Create DSN list by Dataset                                 **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
         TM    PPC_FLAG1,$PPC_F1RDSN      Do report by Dsname as well
         BNO   PV$RDSNX                   No, leave
*
** Obtain table for node report
*
         L    R14,=V(DRU$OPTS)            Locate options table
         LH   R0,OP_NODES-OP(R14)         Get number of nodes
         MH   R0,=H'9'                    Length of entries
         GETMAIN R,LV=(0)                 Obtain Storage
         STM   R0,R1,PV_CVPL              Save length and address
         MVI   0(R1),X'FF'                End of table
         AR    R1,R0                      Locate to end of table
         SH    R1,=H'10'                  Back up for last entry
         ST    R1,PV_CVPL+8               Save end of table
*
** Print "DSN LIST" "BY DSN" in big letters
*
         MVI   PRR_LC,99                  Start on new page
         LA    R1,C_DSNLD                 Data Set List by Volume
         ST    R1,PRR_STITLE              Set subtitle
         XC    PRR_PC(4),PRR_PC           Reset Page count
*
         LA    R1,W_RH2
         MVI   0(R1),C' '
         MVI   1(R1),C'*'
         MVC   2(132-1,R1),1(R1)
         LA    R1,W_RH3
         MVI   0(R1),C' '
         MVC   1(133-1,R1),0(R1)
         LA    R1,W_RH4
         MVI   0(R1),C' '
         MVC   1(133-1,R1),0(R1)
         BAS   R14,CLEAR_RECOUT           CLEAR RECOUT
         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT
*
         L     R14,=V(DRU$CON1)
         LA    R1,C_BLDL-DRU$CON1(R14)    Locate string
         LA    R0,BLETRSA
         L     R15,=V(DRU$BLET)
         BASR  R14,R15
         BAS   R14,CLEAR_RECOUT           CLEAR RECOUT
         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT
         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT
*
         L     R14,=V(DRU$CON1)
         LA    R1,C_BLBD-DRU$CON1(R14)    Locate string
         LA    R0,BLETRSA
         L     R15,=V(DRU$BLET)
         BASR  R14,R15
*
         BAS   R14,CLEAR_RECOUT           CLEAR RECOUT
         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT
         MVI   RECOUT,C'*'                GET DASH
         MVC   RECOUT+1(132),RECOUT ..PROPAGATE IT
         MVI   RECOUT,C' '                FBA BYTE
         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT
         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT
*
         L     R8,=V(DRU$RVOL)            Locate CSECT
         BASSM R9,R8                      Reset heading lines
*
** Sort the VTOC records by DSN
*
         LA    R1,PARMLIST+16             Locate sort string
         MVC   0(11,R1),=C',11,44,CH,A'
         MVI   0(R1),9                    Set length (-1)
         MVC   SF_SORTIN(8),DDN_WF2       Sort Input file
         MVC   SF_SORTOUT(8),DDN_WF3      Sort Output file
*
         BAS   R14,SORT_FILE              Sort by DSN
         LTR   R15,R15                    Successful?
         BNZ   PV$DLDX                    No, skip report
*
** OPEN sorted VTOC file
*
         LA    R3,WRKFILE3                LOCATE DCB WORK AREA
         L     R1,=V(DRU$CON1)
         MVC   0(C_DCBIL,R3),C_DCBI-DRU$CON1(R1)
         MVC   DCBDDNAM-IHADCB(8,R3),DDN_WF3  GET DDNAME
         MVC   PARMLIST(C_LSTIL),C_LSTI-DRU$CON1(R1)
         LA    R1,PV$DLDLX                Locate for End-of-File
         STCM  R1,B'0111',DCBEODAD-IHADCB+1(R3) SAVE INTO DCB
         OPEN  ((3),(INPUT)),MF=(E,PARMLIST)
*
** Process record from sorted file
*
PV$DLDL  EQU   *
         GET   WRKFILE3                   Get record
         LR    R4,R1                      Save record location
         BAS   R9,VTOC_DETAIL_RECORD      Format Detail record
         BAS   R14,PRINT_REPORT_RECORD    Print report
*
         BAS   R9,PV$NODE
         B     PV$DLDL                    Read next record
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Process for nodes                                                 **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
PV$NODE  EQU   *
         LA    R15,PVR_DSCB-PVR(R4)       Locate Dataset name
*
** The Easy way out
*
         CLI   PV_CVPL+8,X'FF'            Maxed out on table?
         BE    PV$NX                      Yes, skip node check
         CLC   PV_CVPL+12(8),0(R15)       Same as last one?
         BE    PV$NX                      Yes, skip it
         MVC   PV_CVPL+12(8),0(R15)       Save for next DSN check
*
** Get length of this node
*
         SLR   R14,R14                    Clear count
PV$NL    EQU   *
         CLI   0(R15),C'.'                End of first node?
         BE    PV$NLX                     Yes, continue
         CLI   0(R15),C' '                End of single node DSN
         BE    PV$NLX                     Yes, continue
         LA    R14,1(R14)                 Increment node length
         LA    R15,1(R15)                 Bump to next byte
         CH    R14,=H'8'                  Max?
         BNH   PV$NL                      No, move on
PV$NLX   EQU   *
         BCTR  R14,0                      Decrement for EX
         L     R1,PV_CVPL+4               Locate node table
*
** Find match in table
*
PV$NML   EQU   *
         CLI   0(R1),X'FF'                End of node table?
         BE    PV$NEND                    Yes, append this one there
         CLM   R14,B'0001',0(R1)          Compare lengths
         BNE   PV$NMLB                    No match, bump to next one
         EX    R14,PV$NMLC                Match?
         BE    PV$NX                      Yes, already in table
PV$NMLB  EQU   *
         SLR   R15,R15                    Clear register
         IC    R15,0(R1)                  Get length of this entry
         LA    R1,1+1(R15,R1)             Bump to next entry
         C     R1,PV_CVPL+8               End of table?
         BE    PV$MAX                     Yes, we are maxed, dude
         B     PV$NML                     Process next entry
PV$NMLC  CLC   1(0,R1),PVR_DSCB-PVR(R4)   ** Executed **
*
** Maxed out, table too small
*
PV$MAX   EQU   *
         MVI   PV_CVPL+8,X'FF'            Set flag
         B     PV$NX                      We are outa here
*
** End of table, append current node to it
*
PV$NEND  EQU   *
         STC   R14,0(R1)                  Save node length
         EX    R14,PV$NENDM               Save node value
         LA    R1,1+1(R14,R1)             Bump to next entry
         MVI   0(R1),X'FF'                Set end of table
*
** Common exit from PV$NODE processing
*
PV$NX    EQU   *
         BSM   0,R9
PV$NENDM MVC   1(0,R1),PVR_DSCB-PVR(R4)   ** Executed **
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Close Sorted VTOC file                                            **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
PV$DLDLX EQU   *
         LA    R3,WRKFILE3
         BAS   R9,CLOSE_FILE              Close file
PV$DLDX  EQU   *
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**       Print the nodes found                                       **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
PV$NODE_PRINT EQU *
         LA    R1,C_NODE
         ST    R1,PRR_TITLE               Set title
         XC    PRR_STITLE(4),PRR_STITLE   Clear sub-title address
         MVI   PRR_LC,99                  Start on new page
         BAS   R14,CLEAR_RH               Clear report headings
*
** Print the node table
*
         MVI   PV_CVPL+20,0               Footer check
         L     R5,PV_CVPL+4               Locate to generic entries
         LA    R3,RECOUT+129              Locate output
         LA    R2,10                      Length
PV$NPL   EQU   *
         BAS   R14,CLEAR_RECOUT           Clear output record
         LA    R4,6(R15)                  Locate output
PV$NPLLL EQU   *
         SLR   R1,R1                      Clear output register
         IC    R1,0(R5)                   Get this codes value length
*
         LR    R15,R4                     Save output
         BXLE  R4,R2,PV$NPLB
         BAS   R14,PRINT_REPORT_RECORD    Print current record
         B     PV$NPL
*
PV$NPLB1 MVC   1(0,R15),1(R5)             ** Executed **
PV$NPLB2 MVC   DOUBLE2+1(0),1(R5)         Get Job Name
PV$NPLB  EQU   *
         EX    R1,PV$NPLB1                Move code to output line
         EX    R1,PV$NPLB2                Move code to output line
         LA    R5,1+1(R1,R5)              Locate to next entry
         LA    R1,1(R1)                   Increment for true length
         STC   R1,DOUBLE2                 Save length of group
         ST    R15,DOUBLE                 Save address of output area
*
         TM    FLAG_X1,$FX1_APF           APF authorized?
         BNO   PV$NPLLRX                  No, avoid S684 ABEND
 B     PV$NPLLRX
 AGO .RACF1X
         LA    R1,32                      Get length of WKAREA
         ST    R1,PARMLIST                Save it
         MVC   PARMLIST+32(C_RLOCL),C_RLOC Initialize Parameter List
         ICHEINTY LOCATE,TYPE='GRP',      Locate Userid                @
               ENTRY=DOUBLE2,             ..UserID Location            @
               WKAREA=PARMLIST,           ..Return area (not used)     @
               MF=(E,PARMLIST+32)         ..Execute from here
.RACF1X ANOP ,
         LTR   R15,R15                    Check return code
         BZ    PV$NPLLRX                  Okay, leave
         L     R15,DOUBLE                 Locate output location
         MVI   0(R15),C'*'                Indicate no RACF group
         MVI   PV_CVPL+20,X'FF'           Indicate that we need footer
PV$NPLLRX EQU  *
*
         CLI   0(R5),X'FF'                End of input record?
         BNE   PV$NPLLL                   No, process next line
         BAS   R14,PRINT_REPORT_RECORD    Print current record
*
** Check for footer
*
 AGO .RACFFX
         CLI   PV_CVPL+20,X'FF'           Indicate that we need footer
         BNE   PV$NPFX
         BAS   R14,CLEAR_RECOUT
         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT
         MVC   RECOUT+1(C_NODERFL),C_NODERF
         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT
.RACFFX ANOP ,
PV$NPFX  EQU   *
*
** End of table
*
         LM    R0,R1,PV_CVPL              Get length and address
      FREEMAIN R,LV=(0),A=(1)             Free Storage
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**  Close VTOCRPT file                                               **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
PV$RDSNX DS    0H
         LA    R3,REPORT
         BAS   R9,CLOSE_FILE              Close file
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**  Common exit from Process_Volume processing                       **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
PV$X     EQU   *
         EJECT
***********************************************************************
***                                                                 ***
**       Print summary page for DASD CONFIGURATION section           **
***                                                                 ***
***********************************************************************
         SPACE 2
         L     R14,=V(DRU$CON1)           Locate constants CSECT
         LA    R1,C_STDC-DRU$CON1(R14)
         ST    R1,PRR_TITLE               Set title
         LA    R1,C_SUM-DRU$CON1(R14)
         ST    R1,PRR_STITLE              Set subtitle
         BAS   R14,CLEAR_RH               Clear Report headings
         MVI   PRR_LC,99                  Start on new page
         XC    PRR_PC(4),PRR_PC           Reset Page count
*
** Open REPORT file
*
         LA    R3,REPORT                  Locate DCB work area
         L     R1,=V(DRU$CON1)            Locate constants CSECT
         MVC   0(C_DCBOL,R3),C_DCBO-DRU$CON1(R1) Initialize DCB
         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'REPORT' Get DDNAME
         MVC   PARMLIST(C_LSTOL),C_LSTO-DRU$CON1(R1) Initialize parm
         OPEN  ((3),(OUTPUT)),MF=(E,PARMLIST) Open file
*
         TM    PPC_FLAG3,$PPC_F3NSYSP
         BO    DC$SYSPX
         LA    R0,SUBRSA
         L     R15,=V(DRU$SYSP)
         BASR  R14,R15
DC$SYSPX DS    0H
         EJECT
***********************************************************************
***                                                                 ***
**   Create DASD Usage page, showing volume "groups" and cylinders   **
***                                                                 ***
***********************************************************************
         SPACE 2
         LA    R1,C_DU
         ST    R1,PRR_STITLE              Set subtitle
*
         MVI   PRR_LC,99                  Start on new page
         BAS   R14,CLEAR_RH               Clear Report headings
*
** Sub heading line 3
*
         LA    R15,W_RH3                  Locate work heading 2
         MVI   0(R15),C'-'                FBA byte: skip some lines
         L     R1,=V(DRU$CON1)
         MVC   DU_GROUP-DU(5,R15),C_DU_GROUP-DRU$CON1(R1)
         MVC   DU_NUM-DU(6,R15),C_DU_NUM-DRU$CON1(R1)
         MVC   DU_TTRK-DU+3(12,R15),C_DU_TTRK-DRU$CON1(R1)
         MVC   DU_ATRK-DU+4(16,R15),C_DU_ATRK-DRU$CON1(R1)
         MVC   DU_FTRK-DU+9(12,R15),C_DU_FTRK-DRU$CON1(R1) '
*
*
** Sub heading line 4
*
         LA    R15,W_RH4                  Locate work heading 2
         MVI   DU_GROUP-DU(R15),C'-'
         MVC   DU_GROUP+1-DU(DU_GROUPL-1,R15),DU_GROUP-DU(R15)
         MVI   DU_NUM-DU(R15),C'-'
         MVC   DU_NUM+1-DU(5,R15),DU_NUM-DU(R15)
         MVI   DU_TTRK-DU(R15),C'-'
         MVC   DU_TTRK+1-DU(14,R15),DU_TTRK-DU(R15)
         MVI   DU_ATRK-DU(R15),C'-'
         MVC   DU_ATRK+1-DU(DU_ATRKL-1,R15),DU_ATRK-DU(R15)
         MVI   DU_FTRK-DU(R15),C'-'
         MVC   DU_FTRK+1-DU(DU_FTRKL-1,R15),DU_FTRK-DU(R15)
*
** Open Merged file (input)
*
         LA    R3,WRKFILE1                Locate DCB work area
         L     R1,=V(DRU$CON1)
         MVC   0(C_DCBIL,R3),C_DCBI-DRU$CON1(R1)
         MVC   DCBDDNAM-IHADCB(8,R3),DDN_WF1  Get DDNAME
         MVC   PARMLIST(C_LSTIL),C_LSTI-DRU$CON1(R1)
         LA    R1,DU$EOF                  Locate EODAD
         STCM  R1,B'0111',DCBEODAD-IHADCB+1(R3) Save into DCB
         OPEN  ((3),(INPUT)),             Open file                    @
               MF=(E,PARMLIST)
*
** Initlialize
*
         SLR   R6,R6                      Clear register
         L     R14,=V(DRU$OPTS)           Locate options CSECT
         IC    R6,OP_VOLP-OP(R14)         Get Volume prefix length
         BCTR  R6,0                       Decrement by one
         XC    DU_WGVOLC(4),DU_WGVOLC
         XC    DU_WGFTRK(4),DU_WGFTRK
         XC    DU_WGTTRK(4),DU_WGTTRK
         XC    DU_TF1(4),DU_TF1
         XC    DU_TUC(4),DU_TUC
         XC    LASTVOLP(5),LASTVOLP
         SPACE 2
**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
** Read records
**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         SPACE 2
DU$LOOP  DS    0H
         GET   WRKFILE1                   Get input record
         LR    R3,R1                      Save input location
*
** Compares for Volume prefix
*
         EX    R6,DU$LVPC                 Volumes prefix match?
         BE    DU$UPDT                    Yes, update current stuff
         CLC   LASTVOLP(5),=8X'00'        First time?
         BE    DU$INIT                    Yes, don't kick record out
*
** Print a detail record for the current group
*
         BAS   R9,DU$PRT                  Print detail record
*
** Initialize for next group
*
DU$INIT  DS    0H
         XC    DU_WGVOLC(4),DU_WGVOLC
         XC    DU_WGFTRK(4),DU_WGFTRK
         XC    DU_WGTTRK(4),DU_WGTTRK
         EX    R6,DU$INITM                Move in Volume prefix
*
** Update count for this group
*
DU$UPDT  DS    0H
         L     R1,DU_WGVOLC               Get group volume count
         LA    R1,1(R1)                   Increment by 1
         ST    R1,DU_WGVOLC               Save Group volume count
*
         LA    R15,WD_LSPCD-WD(R3)        Locate numeric field
         ICM   R1,B'1111',LSPDTCYL-LSPDRETN(R15)  Cylinders free
         LA    R14,WD_F4DSCB-WD(R3)       Locate F4DSCB
         MH    R1,DS4DEVSZ+2-DS4IDFMT(R14) Convert cylinders to Tracks
         A     R1,LSPDTTRK-LSPDRETN(R15)  Add tracks
         L     R0,DU_WGFTRK               Get Total group
         AR    R0,R1                      Add this entry
         ST    R0,DU_WGFTRK               Save Group total
DU$FTRKX DS    0H
*
** Process VTOC information
*
         ICM   R14,B'1111',WD_VIT-WD(R3)
         BZ    DU$VITX
         ICM   R1,B'1111',VI_UNCAT-VI(R14)
         BZ    DU$VUCX
         L     R0,DU_TUC                  Get uncatalogued count
         AR    R0,R1                      Add for this volume
         ST    R0,DU_TUC                  Save running total
DU$VUCX  EQU   *
         ICM   R1,B'1111',VI_F1-VI(R14)   Get number of datasets (F1)
         BZ    DU$VITX
         L     R0,DU_TF1                  Get uncatalogued count
         AR    R0,R1                      Add for this volume
         ST    R0,DU_TF1                  Save running total
DU$VITX  EQU   *
.VITX ANOP ,
*
** Add Tracks
*
DU$TRKF  DS    0H
         L     R15,DU_WGTTRK              Get Total group
         SLR   R1,R1                      Clear register
         ICM   R1,B'0011',WD_DTAREA+8-WD(R3) Get number of cylinders
         BCTR  R1,0                       Remove Alternate Cylinder
         LA    R14,WD_F4DSCB-WD(R3)       Locate F4DSCB
         MH    R1,DS4DEVSZ+2-DS4IDFMT(R14) Convert Cyls to Tracks
         AR    R15,R1                     Add cylinders for this device
         ST    R15,DU_WGTTRK              Save Group total
         B     DU$LOOP
         SPACE 2
**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
** End of file on merged input
**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         SPACE 2
DU$EOF   DS    0H
*
** Close work file
*
         LA    R3,WRKFILE1
         BAS   R9,CLOSE_FILE              Close file
*
** Print last detail record
*
         BAS   R9,DU$PRT                  Print detail record
*
** Print "under-line" line
*
         BAS   R14,CLEAR_RECOUT           Clear output record to blanks
         LA    R15,RECOUT
         MVI   DU_NUM-DU(R15),C'-'
         MVC   DU_NUM+1-DU(5,R15),DU_NUM-DU(R15)
         MVI   DU_TTRK-DU(R15),C'-'
         MVC   DU_TTRK+1-DU(14,R15),DU_TTRK-DU(R15)
         MVI   DU_ATRK-DU(R15),C'-'
         MVC   DU_ATRK+1-DU(DU_ATRKL-1,R15),DU_ATRK-DU(R15)
         MVI   DU_FTRK-DU(R15),C'-'
         MVC   DU_FTRK+1-DU(DU_FTRKL-1,R15),DU_FTRK-DU(R15)
         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT
*
** Print Grand total line
*
         BAS   R14,CLEAR_RECOUT           Clear output record to blanks
         LA    R8,RECOUT                  Locate output record
*
         L     R1,DU_WTVOLC
         CVD   R1,DOUBLE
         MVC   DU_NUM-DU(6,R8),=X'40,20,20,20,20,20'
         ED    DU_NUM-DU(6,R8),DOUBLE+5
*
         L     R1,DU_WTTTRK               Get Total
         LA    R15,DU_TTRK-DU(R8)         Locate output location
         BAS   R14,EDIT15                 Edit number
*
         L     R14,DU_WTTTRK              Get Total number
         L     R1,DU_WTFTRK               Get Free number
         LA    R15,DU_FTRKP-DU(R8)        Locate output location
         BAS   R9,EDITPER                 Edit percentage
         MVI   DU_FTRKP-DU+4(R8),C'%'     Insert Percentage sign
*
         L     R1,DU_WTATRK               Get Allocated tracks
         LA    R15,DU_FTRK-DU(R8)         Locate output location
         BAS   R14,EDIT15                 Edit number
*
         L     R1,DU_WTFTRK               Get Free Tracks
         LA    R15,DU_FTRK-DU(R8)         Locate output location
         BAS   R14,EDIT15                 Edit number
*
         L     R1,DU_WTTTRK               Get Group Total tracks
         L     R0,DU_WTFTRK               Get Free
         SR    R1,R0                      Calculate Allocated trk.
         LR    R7,R1                      Save number
         LA    R15,DU_ATRK-DU(R8)         Locate output location
         BAS   R14,EDIT15                 Edit number
*
         L     R14,DU_WTTTRK              Get Total number
         LR    R1,R7                      Get Free number
         LA    R15,DU_ATRKP-DU(R8)        Locate output location
         BAS   R9,EDITPER                 Edit percentage
         MVI   DU_ATRKP-DU+4(R8),C'%'     Insert Percentage sign
*
         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT
         B     DU$X
         SPACE 2
**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
** Executed instructions
**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         SPACE 2
DU$LVPC  CLC   LASTVOLP(0),WD_VOLS-WD(R3) ** Executed **
DU$INITM MVC   LASTVOLP(0),WD_VOLS-WD(R3) ** Executed **
DU$PRTM  MVC   DU_GROUP-DU(0,R8),LASTVOLP  ** Executed **
         SPACE 2
**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
** Print detail record for DASD usage
**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         SPACE 2
DU$PRT   DS    0H
         ST    R9,RA$DUPRT                Save return address
*
         BAS   R14,CLEAR_RECOUT           Clear output record to blanks
         LA    R8,RECOUT                  Locate output record
*
         EX    R6,DU$PRTM
         L     R14,G_DASD                 Get Total number of DASD
         L     R1,DU_WGVOLC               Get Group volume count
         LA    R15,DU_GROUPP-DU(R8)
         BAS   R9,EDITPER                 Edit percentage
         MVI   DU_GROUPPP-DU(R8),C'%'
*
         L     R1,DU_WGVOLC               Get Group volume count
         L     R0,DU_WTVOLC               Get Total volume count
         AR    R0,R1                      Add Group + Total
         ST    R0,DU_WTVOLC               Save Total
         CVD   R1,DOUBLE                  Make packed
         MVC   DU_NUM-DU(6,R8),=X'40,20,20,20,20,20' Move in edit zones
         ED    DU_NUM-DU(6,R8),DOUBLE+5   Edit it
*
         L     R1,DU_WGFTRK               Get group Free tracks
         L     R0,DU_WTFTRK               Get Total Free tracks
         AR    R0,R1                      Add Group + Total
         ST    R0,DU_WTFTRK               Save Total
         LA    R15,DU_FTRK-DU(R8)         Locate output location
         BAS   R14,EDIT15                 Edit number
*
         L     R14,DU_WGTTRK              Get Total number
         L     R1,DU_WGFTRK               Get Free number
         LA    R15,DU_FTRKP-DU(R8)        Locate output location
         BAS   R9,EDITPER                 Edit percentage
         MVI   DU_FTRKP-DU+4(R8),C'%'     Insert Percentage sign
*
         L     R1,DU_WGTTRK               Get Group Total Tracks
         L     R0,DU_WTTTRK               Get Total Total tracks
         AR    R0,R1                      Add Group + Total
         ST    R0,DU_WTTTRK               Save Total
         LA    R15,DU_TTRK-DU(R8)         Locate output location
         BAS   R14,EDIT15                 Edit number
*
         L     R1,DU_WGTTRK               Get Group Total tracks
         L     R0,DU_WGFTRK               Get Free tracks
         SR    R1,R0                      Calculate Allocated trk.
         LR    R7,R1                      Save number
         LA    R15,DU_ATRK-DU(R8)         Locate output location
         BAS   R14,EDIT15                 Edit number
*
         L     R14,DU_WGTTRK              Get Total number
         LR    R1,R7                      Get Free number
         LA    R15,DU_ATRKP-DU(R8)        Locate output location
         BAS   R9,EDITPER                 Edit percentage
         MVI   DU_ATRKP-DU+4(R8),C'%'     Insert Percentage sign
*
         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT
*
         L     R9,RA$DUPRT                Get return address
         BSM   0,R9                       Return to caller
         AGO   .SKIPSN
         SPACE 2
**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
** Print special notes
**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         SPACE 2
*
** Print uncatalogued dataset count
*
         ICM   R1,B'1111',DU_TUC
         BZ    DU$PUCX
         BAS   R14,CLEAR_RECOUT
         MVI   RECOUT,C'-'
         MVC   14(5,R15),=C'Note:'
         MVC   20(9,R15),=C'There are'
         LA    R15,20+9+1(R15)
         L     R1,DU_TUC
         BAS   R9,EDITFWF
         MVC   1(21,R15),=C'uncatalogued datasets'
         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT
DU$PUCX  EQU   *
*
** Print total dataset
*
         ICM   R1,B'1111',DU_TF1
         BZ    DU$PF1X
         BAS   R14,CLEAR_RECOUT
         MVC   14(5,R15),=C'Note:'
         MVC   20(9,R15),=C'There are'
         LA    R15,20+9+1(R15)
         L     R1,DU_TF1
         BAS   R9,EDITFWF
         MVC   1(14,R15),=C'total datasets'
         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT
DU$PF1X  EQU   *
.SKIPSN  ANOP  ,
**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
** Exit from DASD usage
**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
DU$X     DS    0H
         EJECT
***********************************************************************
***                                                                 ***
**   Print Dasd type summary total                                   **
***                                                                 ***
***********************************************************************
         SPACE 2
         LA    R1,C_DT
         ST    R1,PRR_STITLE              Set subtitle
*
         MVI   PRR_LC,99                  Start on new page
         BAS   R14,CLEAR_RH               Clear Report headings
*
** Sub heading line 3
*
         LA    R15,W_RH3                  Locate work heading 2
         MVI   0(R15),C'-'                FBA byte: skip some lines
         MVC   DT_NAME-DT(4,R15),=C'Type'
         MVC   DT_COUNT-DT(5,R15),=C'Count'
*
** Sub heading line 4
*
         LA    R15,W_RH4                  Locate work heading 2
         MVI   DT_NAME-DT(R15),C'-'
         MVC   DT_NAME+1-DT(L'DT_NAME-1,R15),DT_NAME-DT(R15)
         MVI   DT_COUNT-DT(R15),C'-'
         MVC   DT_COUNT+1-DT(L'DT_COUNT-1,R15),DT_COUNT-DT(R15)
*
** Loop thru table
*
         L     R8,SDU_DDC+4               Obtain address
         LA    R8,DDC_HL(R8)              Bump past header
         LA    R7,#DDCEN                  Get max number of entries
DTR$L    EQU   *
         CLI   0(R8),X'FF'                End?
         BE    DTR$END
         BAS   R14,CLEAR_RECOUT
         MVC   DT_NAME-DT(8,R15),DDC_ENAME-DDC_E(R8)
         L     R1,DDC_ECOUNT-DDC_E(R8)    Get count
         LA    R15,DT_COUNT-DT(R15)       Locate to output area
         BAS   R9,EDITFWF                 Edit total device count
         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT
         LA    R8,DDC_EL(R8)              Bump to next entry
         BCT   R7,DTR$L                   Continue
DTR$END  EQU   *
         LM    R0,R1,SDU_DDC              Get length and address
         FREEMAIN R,LV=(0),A=(1)          Free table
DTR$X    EQU   *
         EJECT
***********************************************************************
***                                                                 ***
**       PRINT "DASD Configuration Report" BY VOLSER                 **
***                                                                 ***
***********************************************************************
         SPACE 2
         TM    PPC_FLAG1,$PPC_F1RBOTH     Do both reports?
         BO    DCR$VS                     Yes, continue
         TM    PPC_FLAG1,$PPC_F1RUCB      Do report by UCB?
         BO    DCR$US                     Yes, skip volume
DCR$VS   DS    0H
*
** Reset headings for DASD Configuration Report by volume
*
         LA    R1,C_DCRV
         L     R8,=V(DRU$ROPR)            Locate CSECT
         BASSM R9,R8                      Reset heading lines
*
** OPEN MERGED FILE (INPUT)
*
         LA    R3,WRKFILE1                LOCATE DCB WORK AREA
         L     R1,=V(DRU$CON1)
         MVC   0(C_DCBIL,R3),C_DCBI-DRU$CON1(R1)
         MVC   DCBDDNAM-IHADCB(8,R3),DDN_WF1  GET DDNAME
         MVC   PARMLIST(C_LSTIL),C_LSTI-DRU$CON1(R1)
         LA    R2,DCR$FX1_VEOF            LOCATE VOLUME EODAD
         STCM  R2,B'0111',DCBEODAD-IHADCB+1(R3) SAVE INTO DCB
         OPEN  ((3),(INPUT)),                                          @
               MF=(E,PARMLIST)            OPEN DCB
**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
** READ THE MERGED FILE AND CREATE DCR BY VOLSER
**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         OI    FLAG_R,$DCRV               SET: DASD CONFIG BY VOLUME
DCR$VL   DS    0H
         GET   WRKFILE1                   GET INPUT RECORD
         LR    R2,R1                      SAVE INPUT LOCATION
         BAS   R9,RPTDT                   FORMAT REPORT DETAIL LINE
         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT
         B     DCR$VL                     NEXT RECORD
**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
** END OF FILE FOR WORK FILE 1
**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
DCR$FX1_VEOF DS 0H
         NI    FLAG_R,255-$DCRV           TURN OFF DASD CONFIG - VOLUME
*
** Print Dash line after report
*
         MVI   RECOUT,C'-'
         MVC   RECOUT+1(132),RECOUT
         MVI   RECOUT,C' '
         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT
*
** Close the work file
*
         LA    R3,WRKFILE1
         BAS   R9,CLOSE_FILE
         EJECT
***********************************************************************
***                                                                 ***
**       PRINT "DASD Configuration Report" BY UCB                    **
***                                                                 ***
***********************************************************************
         SPACE 2
         TM    PPC_FLAG1,$PPC_F1RUCB      Do report by UCB?
         BNO   DCR$UX                     No, continue
DCR$US   DS    0H
*
** Sort the work file by "AC" (ASCII) to get hexidecmial UCB order
*
         LA    R1,PARMLIST+16             Locate sort string
         MVI   0(R1),7                    Set length (-1)
         MVC   1(8,R1),=C'7,4,AC,A'
         MVC   SF_SORTIN(8),DDN_WF1       Sort Input file
         MVC   SF_SORTOUT(8),DDN_WF2      Sort Output file
*
         BAS   R14,SORT_FILE              SORT WRKFILE1 BY UCB
         LTR   R15,R15
         BNZ   DCR$UX
*
** Reset headings for DASD Configuration Report by volume
*
         L     R1,=V(DRU$CON1)
         LA    R1,C_DCRC-DRU$CON1(R1)
         L     R8,=V(DRU$ROPR)            Locate CSECT
         BASSM R9,R8                      Reset heading lines
*
** OPEN MERGED FILE (INPUT)
*
         LA    R3,WRKFILE2                LOCATE DCB WORK AREA
         L     R1,=V(DRU$CON1)
         MVC   0(C_DCBIL,R3),C_DCBI-DRU$CON1(R1)
         MVC   DCBDDNAM-IHADCB(8,R3),DDN_WF2  GET DDNAME
         MVC   PARMLIST(C_LSTIL),C_LSTI-DRU$CON1(R1)
         LA    R2,DCR$UEOF                LOCATE VOLUME EODAD
         STCM  R2,B'0111',DCBEODAD-IHADCB+1(R3) SAVE INTO DCB
         OPEN  ((3),(INPUT)),                                          @
               MF=(E,PARMLIST)            OPEN DCB
         SPACE 2
**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
** READ THE MERGED FILE AND CREATE DCR BY UCB
**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         SPACE 2
         OI    FLAG_R,$DCRU               SET: DASD CONFIG BY VOLUME
DCR$UL   DS    0H
         GET   WRKFILE2                   GET INPUT RECORD
         LR    R2,R1                      SAVE INPUT LOCATION
         BAS   R9,RPTDT                   FORMAT REPORT DETAIL LINE
*
         CLC   LASTCHAN(1),WD_UCB+1-WD(R2)  SAME "CHANNEL"?
         BE    DCR$UP                     YES, MOVE ON
         CLI   LASTCHAN,X'00'             FIRST TIME THRU LOOP?
         BE    DCR$UCU                    YES, NO NEED FOR DOUBLE SPACE
         MVI   RECOUT,C'0'                DOUBLE SPACE BEFORE CHANNEL
DCR$UCU  DS    0H
         MVC   LASTCHAN(1),WD_UCB+1-WD(R2)  Reset CHANNEL control break
DCR$UP   DS    0H
         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT
         B     DCR$UL                     NEXT RECORD
**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
** END OF FILE FOR WORK FILE 2
**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
DCR$UEOF DS    0H
         NI    FLAG_R,255-$DCRU           TURN OFF DASD CONFIG - UCB
*
** Close the work file
*
         LA    R3,WRKFILE2
         BAS   R9,CLOSE_FILE              Close file
*
** Print Dash line after report
*
         MVI   RECOUT,C'-'
         MVC   RECOUT+1(132),RECOUT
         MVI   RECOUT,C' '
         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT
DCR$UX   EQU   *       ***  End of need of sorted file by UCB ***
         EJECT
***********************************************************************
***                                                                 ***
**       Termination section                                         **
***                                                                 ***
***********************************************************************
         SPACE 2
EXIT     DS    0H
*
** Print trivia from VTOC reporting
*
         TM    FLAG_X1,$FX1_VTOC          Look at the vtocs?
         BNO   X$VTOCX                    No, continue
         BAS   R14,CLEAR_RECOUT           Clear string area to blanks
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
*
         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks
         MVC   0(MSG61L,R15),MSG61-DRU$CON1(R1)
         LA    R15,MSG61L+1(R15)          Bump past the message
         L     R1,PV_TCOUNT               Get SMS count
         BAS   R9,EDITFWF                 Edit the return code
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
*
         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks
         MVC   0(MSG60L,R15),MSG60-DRU$CON1(R1)
         LA    R15,MSG60L+1(R15)          Bump past the message
         L     R1,PV_SCOUNT               Get SMS count
         BAS   R9,EDITFWF                 Edit the return code
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
X$VTOCX  DS    0H
*
** Print ending message
*
         BAS   R14,CLEAR_RECOUT           Clear string area to blanks
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
*
         TIME  BIN
         LR    R5,R0
         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks
         MVC   0(MSG1L,R15),MSG1-DRU$CON1(R1)
         LA    R15,MSG1L+1(R15)           Bump past the message
         MVC   0(MSG1BL,R15),MSG1B-DRU$CON1(R1)
         LA    R15,MSG1BL+1(R15)          Bump past it
         SLR   R1,R1                      Get the return code
         IC    R1,MAXCC
         BAS   R9,EDITFWF                 Edit the return code
         MVC   0(7,R15),=C', Time:'
         LA    R15,7(R15)
         LR    R1,R5                      Get time
         BAS   R14,CONVERT_BINARY_TIME
         BAS   R14,PRINT_SYSPRINT_RECORD Print message
*
** Delete storage
*
         LM    R0,R1,PV_VIT               Save Length and Address
         LTR   R0,R0                      Any length?
         BZ    X$VITX                     No, move on
      FREEMAIN R,LV=(0),A=(1)             Free storage
X$VITX   EQU   *
*
** Delete modules loaded
*
         ICM   R1,B'1111',EP_EB4UV
         BZ    X$EB4UVX
         DELETE EPLOC==CL8'IEFEB4UV'
X$EB4UVX EQU   *
         ICM   R1,B'1111',EP_SS01
         BZ    X$SS01X
         DELETE EPLOC==CL8'IDCSS01'
X$SS01X  EQU   *
         TM    FLAG_X2,$FX2_LMXD          Loaded DA$MXD?
         BNO   X$MXDX                     No, continue
         ICM   R0,B'1111',EP_DA$MXD
         BZ    X$MXDX
         DELETE EPLOC==CL8'DA$MXD'
X$MXDX   EQU   *
         TM    FLAG_X2,$FX2_LDATE         Loaded DA$DATE?
         BNO   X$DATEX                    No, continue
         ICM   R0,B'1111',EP_DA$DATE
         BZ    X$DATEX
         DELETE EPLOC==CL8'DA$DATE'
X$DATEX  EQU   *
*
** Close global files
*
         LA    R3,SYSPRINT
         BAS   R9,CLOSE_FILE              Close file
*
         LA    R3,REPORT
         BAS   R9,CLOSE_FILE              Close file
*
** Free resources and terminate
*
         LR    R2,R13                     Get storage address
         SLR   R3,R3
         IC    R3,MAXCC
         STORAGE RELEASE,LENGTH=DSAL,ADDR=(R2) Release storage
         LR    R15,R3                     Set return code
         PR    ,                          Return to caller
         EJECT ,
***********************************************************************
***                                                                 ***
**       Error routines                                              **
***                                                                 ***
***********************************************************************
         SPACE 2
*
** DCB ABEND EXIT ROUTINE: GC26-4013 MVS/XA DATA ADMINISTRATION GUIDE
**                         CHAPTER 7.
*
E$OPENA  EQU   *
         L     R2,0(R1)                   GET ABEND CODE
         ST    R2,E_OPENA_CODE            SAVE ABEND CODE
         MVI   3(R1),4                    IGNORE ABEND
         BSM   0,R14                      RETURN TO IOS
         EJECT
***********************************************************************
***                                                                 ***
**       Format report detail line                                   **
**       Input R2: Points to work file input record                  **
***                                                                 ***
***********************************************************************
         SPACE 2
RPTDT    DS    0H
         BAS   R14,CLEAR_RECOUT           CLEAR RECOUT TO BLANKS
         LA    R3,RECOUT                  LOCATE RECOUT
*
** MASS MERGE
*
         MVC   OR_UCB-OR(4,R3),WD_UCB-WD(R2)      UCB NAME (ADDRESS)
         MVC   OR_VOLS-OR(6,R3),WD_VOLS-WD(R2)    VOL SER
         TM    WD_FLAG1-WD(R2),$WDF1_IVTOC
         BNO   RDT$IVX
         MVI   OR_IVTOC-OR(R3),C'I'               Indexed VTOC = I
RDT$IVX  EQU   *
         TM    WD_FLAG1-WD(R2),$WDF1_CACHEC       Cached Controller?
         BNO   RDT$CVX
         MVI   OR_CACHE-OR(R3),C'C'               Cached..
         TM    WD_FLAG1-WD(R2),$WDF1_CACHEV       Cached Volume?
         BNO   RDT$CVX
         MVI   OR_CACHE+1-OR(R3),C'C'             Only know bout cntrlr
RDT$CVX  EQU   *
         MVC   OR_VMNT-OR(3,R3),WD_VMNT-WD(R2)    Mount status
         MVC   OR_SMNT-OR(3,R3),WD_SMNT-WD(R2)    Mount status
         MVC   OR_DESC-OR(40,R3),WD_DESC-WD(R2)   Description of use
         MVC   OR_DEVT-OR(8,R3),WD_DEVT-WD(R2)    Device type
*
** VTOC stuff
*
         TM    WD_FLAG1-WD(R2),$WDF1_NLSPC       Have LSPACE info
         BO    RDT$VTOCX
         SLR   R1,R1
         ICM   R1,B'0011',WD_VTOCT-WD(R2)        Get VTOC size
         CVD   R1,DOUBLE                         Convert it to packed
         MVC   OR_VTOCT-OR(4,R3),=X'40,20,20,20' Get edit pattern
         ED    OR_VTOCT-OR(4,R3),DOUBLE+6        Edit the number
         OI    OR_VTOCT+3-OR(R3),C'0'
*
         LA    R14,WD_LSPCD-WD(R2)               Locate LSPACE data
         ICM   R0,B'1111',LSPDF0S-LSPDRETN(R14)  Get Free DSCBs
         CVD   R0,DOUBLE                         Convert it to packed
         MVC   OR_VTOCF-2-OR(6,R3),=X'40,20,20,20,20,20'
         ED    OR_VTOCF-2-OR(6,R3),DOUBLE+5
         OI    OR_VTOCF+3-OR(R3),C'0'
*
         LA    R14,WD_F4DSCB-WD(R2)              Locate F4DSCB
         MVI   DOUBLE,0                   Fix first byte of half word
         MVC   DOUBLE+1(1),DS4DEVDT-DS4IDFMT(R14) Get # of DSCBs: Trk
         MH    R1,DOUBLE                         Calculate # of DSCBs
         ST    R1,DOUBLE                         Save for divide
         SR    R1,R0                             Get used count
         SLR   R0,R0                             Clear register
         LTR   R1,R1                             Any value?
         BZ    RDT$VTOCX                         No, avoid SC09
         M     R0,=F'100'                        Make right for percent
         D     R0,DOUBLE                         Get free percent
         CVD   R1,DOUBLE                         Make packed
         MVC   OR_VTOCP-1-OR(4,R3),=X'40,20,20,20'
         ED    OR_VTOCP-1-OR(4,R3),DOUBLE+6
         OI    OR_VTOCP+2-OR(R3),C'0'
         MVI   OR_VTOCP+3-OR(R3),C'%'
*                                         Edit the total tracks free
         LA    R14,WD_F4DSCB-WD(R2)       Locate F4DSCB
         SLR   R1,R1
         ICM   R1,B'0011',DS4DSCYL-DS4IDFMT(R14) Get total Cylinders
         MH    R1,DS4DEVSZ+2-DS4IDFMT(R14) Convert cylinders to Tracks
         ST    R1,PARMLIST                Save total tracks
         LA    R15,WORKAREA               Locate temp. output
         BAS   R14,EDIT15                 Edit number
         MVC   OR_TTRKS-OR(10,R3),WORKAREA+5 Move out free space
*                                         Edit the total tracks free
         LA    R14,WD_LSPCD-WD(R2)        Locate LSPACE data
         L     R0,LSPDTTRK-LSPDRETN(R14)  Tracks Free
         L     R1,LSPDTCYL-LSPDRETN(R14)  Cylinders Free
         LA    R14,WD_F4DSCB-WD(R2)       Locate F4DSCB
         MH    R1,DS4DEVSZ+2-DS4IDFMT(R14) Convert cylinders to Tracks
         AR    R1,R0                      Total Free = Cyls + Trks
         ST    R1,PARMLIST+4              Save free tracks
         LA    R15,WORKAREA               Locate temp. output
         BAS   R14,EDIT15                 Edit number
         MVC   OR_FTRKS-OR(10,R3),WORKAREA+5 Move out free space
*
         ST    R9,PARMLIST+8              Save return address
         L     R14,PARMLIST               Get Total number
         L     R1,PARMLIST+4              Get Free number
         LA    R15,OR_FTRKP-1-OR(R3)        Locate output location
         BAS   R9,EDITPER                 Edit percentage
         MVI   OR_FTRKP-OR+3(R3),C'%'     Insert Percentage sign
         L     R9,PARMLIST+8              Restore return address
         B     RDT$VTOCX
RDT$VTOCE EQU *
         MVC   OR_VTOC-OR(OR_VTOCL,R3),WD_LSPCD+7-WD(R2) Get message
RDT$VTOCX EQU *
*
** Return to caller
*
         BSM   0,R9
         EJECT
***********************************************************************
***                                                                 ***
**        Format VTOC detail record                                  **
**                                                                   **
**        Input: R4 points to PVR                                    **
***                                                                 ***
***********************************************************************
         SPACE 2
VTOC_DETAIL_RECORD EQU *
         LA    R8,PVR_DSCB-PVR(R4)
*
         BAS   R14,CLEAR_RECOUT
         LA    R15,RECOUT+1
         MVC   DLR_DSN-DLR(44,R15),PVR_DSCB-PVR(R4)
         MVC   DLR_VOLS-DLR(6,R15),PVR_VOLS-PVR(R4)
         MVC   DLR_CAT-DLR(1,R15),PVR_CAT-PVR(R4)
         MVC   DLR_DSORG+2-DLR(3,R15),PVR_DSORG-PVR(R4)
*
** Format the Creation and Last Reference dates
*
         LA    R15,DLR_CDATE-DLR(R15)
         LA    R1,DS1CREDT-IECSDSL1(R8)
         BAS   R14,CONVDATE
         LA    R15,RECOUT+1+DLR_UDATE-DLR
         LA    R1,DS1REFD-IECSDSL1(R8)
         BAS   R14,CONVDATE
         LA    R15,RECOUT+1
*
** RECFM
*
         LA    R14,DLR_RECFM+2-DLR(R15)
         TM    DS1RECFM-IECSDSL1(R8),DS1RECFU
         BO    VDR$RU
         TM    DS1RECFM-IECSDSL1(R8),DS1RECFF
         BO    VDR$RF
         TM    DS1RECFM-IECSDSL1(R8),DS1RECFV
         BNO   VDR$RX
         MVI   0(R14),C'V'
         LA    R14,1(R14)
         B     VDR$RCB
VDR$RU   EQU   *
         MVI   0(R14),C'U'
         LA    R14,1(R14)
         B     VDR$RX
VDR$RF   EQU   *
         MVI   0(R14),C'F'
         LA    R14,1(R14)
*        B     VDR$RCB
VDR$RCB  EQU   *
         TM    DS1RECFM-IECSDSL1(R8),DS1RECFB
         BNO   VDR$RCA
         MVI   0(R14),C'B'
         LA    R14,1(R14)
VDR$RCA  EQU   *
         TM    DS1RECFM-IECSDSL1(R8),DS1RECFA
         BNO   VDR$RAX
         MVI   0(R14),C'A'
         LA    R14,1(R14)
         B     VDR$RX
VDR$RAX  EQU   *
         TM    DS1RECFM-IECSDSL1(R8),DS1RECFS
         BNO   VDR$RSX
         MVI   0(R14),C'S'
         LA    R14,1(R14)
         B     VDR$RX
VDR$RSX  EQU   *
         TM    DS1RECFM-IECSDSL1(R8),DS1RECMC
         BNO   VDR$RX
         MVI   0(R14),C'M'
         LA    R14,1(R14)
VDR$RX   EQU   *
*
** LRECL
*
         LH    R1,DS1LRECL-IECSDSL1(R8)   Obtain LRECL
         CVD   R1,DOUBLE
         MVC   DLR_LRECL-1-DLR(6,R15),=X'40,20,20,20,20,20'
         ED    DLR_LRECL-1-DLR(6,R15),DOUBLE+5
         OI    DLR_LRECL+4-DLR(R15),C'0'
*
** Block Size
*
         LH    R1,DS1BLKL-IECSDSL1(R8)    Obtain BLKSIZE
         CVD   R1,DOUBLE
         MVC   DLR_BLKSIZE-1-DLR(6,R15),=X'40,20,20,20,20,20'
         ED    DLR_BLKSIZE-1-DLR(6,R15),DOUBLE+5
         OI    DLR_BLKSIZE+4-DLR(R15),C'0'
*
** SMS byte
*
         UNPK  DLR_SMS-DLR(3,R15),DS1SMSFG-IECSDSL1(2,R8)
         MVZ   DLR_SMS-DLR(2,R15),=8X'00'
         TR    DLR_SMS-DLR(2,R15),=C'0123456789ABCDEF'
         MVI   DLR_SMS+3-DLR(R15),C' '
*
** Common Exit from VTOC_Detail_Record
*
VDR$X    EQU   *
         BSM   0,R9
         EJECT
***********************************************************************
***                                                                 ***
**       Misc Internal Subroutines                                   **
***                                                                 ***
***********************************************************************
         SPACE 2
*
** Increment Line count
**
** Input: RECOUT - FBA byte
**        R1 - current line count (to be incremented)
*
INC_LC   EQU   *
         CLI   RECOUT,C'+'
         BE    ILCX
         CLI   RECOUT,C'-'
         BE    ILC3
         CLI   RECOUT,C'0'
         BE    ILC2
         B     ILC1
ILC3     EQU   *
         LA    R1,1(R1)
ILC2     EQU   *
         LA    R1,1(R1)
ILC1     EQU   *
         LA    R1,1(R1)
ILCX     EQU   *
         BSM   0,R14
*
** Close file in R3
*
CLOSE_FILE EQU *
         TM    DCBOFLGS-IHADCB(R3),DCBOFOPN Is it OPEN?
         BNO   CF$X                       No, ignore it
         L     R1,=V(DRU$CON1)
         MVC   PARMLIST(C_CLOSEL),C_CLOSE-DRU$CON1(R1)
         CLOSE ((3)),MF=(E,PARMLIST)      Close it
CF$X     DS    0H
         BSM   0,R9
*
** Print message on file SYSPRINT
*
PRINT_REPORT_RECORD EQU *
         ST    R14,PRR_RA                 Save return address
*
         LA    R0,PRRRSA                  Locate work area
         LA    R1,RECOUT   (assumed)      Locate record to print
         L     R15,=V(DRU$PRR)            Locate sysprint routine
         BASR  R14,R15                    Print Sysprint Record
*
         L     R14,PRR_RA                 Get return address
         BSM   0,R14                      Return to caller
*
** Print message on file SYSPRINT
*
PRINT_SYSPRINT_RECORD EQU *
         ST    R14,PSR_RA                 Save return address
*
         LA    R0,PSRRSA                  Locate work area
         LA    R1,RECOUT   (assumed)      Locate record to print
         L     R15,=V(DRU$PSR)            Locate sysprint routine
         BASR  R14,R15                    Print Sysprint Record
*
         L     R14,PSR_RA                 Get return address
         BSM   0,R14                      Return to caller
*
** Clear heading record to blanks
*
CLEAR_HEADREC EQU *
         LA    R15,HEADREC                Locate output record
         MVI   0(R15),C' '                Get Blank
         MVC   1(L'HEADREC-1,R15),0(R15) ..Propagate it
         L     R1,=V(DRU$CON1)            -> Constants CSECTs
         BSM   0,R14                      Return to caller
*
** Clear report headings
*
CLEAR_RH EQU   *
         LA    R15,W_RH2                  Locate work heading 2
         MVI   0(R15),C' '                Get Blank
         MVC   1(133-1,R15),0(R15)        ..Propagate it
         LA    R15,W_RH3                  Locate work heading 2
         MVI   0(R15),C' '                Get Blank
         MVC   1(133-1,R15),0(R15)        ..Propagate it
         LA    R15,W_RH4                  Locate work heading 2
         MVI   0(R15),C' '                Get Blank
         MVC   1(133-1,R15),0(R15)        ..Propagate it
         BSM   0,R14
*
** Initialize message
**
** Output:
** R15 - Output area on line
** R1 - address of constants CSECT
*
FORMAT_MESSAGE EQU *
         LA    R15,RECOUT                 Locate record output area
         MVI   0(R15),C' '                Move in blank
         MVC   1(132,R15),0(R15)          ..Propagate it
         LA    R15,1(R15)                 Bump past FBA byte
         MVC   0(3,R15),=C'DRU'           Get Message prefix
         LA    R15,3(R15)                 Bump past "DA$DISKR-"
         L     R1,=V(DRU$CON1)            -> Constants CSECTs
         BSM   0,R14                      Return to caller
*
**       EDIT FULLWORD (FLUSH TO R15)
**       R1 --> INPUT:REGISTER TO PRINT
**       R15 --> OUTPUT: ADDRESS WHERE OUTPUT IS TO BE PUT
*
EDITFWF  EQU   *
         LTR   R1,R1                      CHECK FOR 0
         BZ    EDITFWF0                   YES, PUT ZERO
         CVD   R1,DOUBLE                  NO, CONVERT TO PACKEC
         LA    R1,DOUBLE2+14              LOCATE SIG DIGIT
         MVC   DOUBLE2(15),EDITP15
         EDMK  DOUBLE2(15),DOUBLE+2       EDIT AND SAVE PLACE
         LA    R14,DOUBLE2+16             LOCATE LAST POSSIBLE BYTE + 1
         SR    R14,R1                     LENGTH = END - START
         BCTR  R14,0                      DECREMENT FOR EX
         EX    R14,EDITFWFM               MOVE EDIT NUMBER TO OUTPUT
         LA    R15,0(R14,R15)             BUMP POINTER PAST NUMBER
         MVI   0(R15),C' '
         BSM   0,R9                       RETURN TO CALLER
EDITFWFM MVC   0(0,R15),0(R1)
EDITFWF0 EQU   *
         MVI   0(R15),C'0'                PUT IN ZERO
         LA    R15,1(R15)                 BUMP POINTER PAST ZERO
         BSM   0,R9                       RETURN TO CALLER
*
** Convert Date from X'YY,DD,DD' to output date format
** - C'CCYY.DDD' .... Julian
** - C'dd-mmm-ccyy'.. European Gregorian
** - C'CCYY-mm-dd' .. ISO standard
**
** Input: R1  - Address of X'yy,dd,dd'
** Output: R15 - Address to put output date
*
CONVDATE EQU  *
         CLI   0(R1),X'00'               YEAR = ZEROS?
         BE    CVD$X                     YES, DONT EVEN BOTHER
         CLI   PPC_DATEF,$PPC_DFEGREG    Date format is Eur Greg?
         BE    CVD$EG                    Yes, do it
* cli ppc_datef,$ppc_dfiso
* be  cvd$iso
*-Julian: 'ccyy.ddd'
         SLR   R0,R0                     ----+
         ICM   R0,B'0001',0(R1)              |
         AH    R0,=H'1900'                   |
         CVD   R0,DOUBLE                     |  FORMAT YEAR
         UNPK  0(4,R15),DOUBLE+5(3)          |
         OI    3(R15),C'0'               ----+
*
         SLR   R0,R0                     ----+
         ICM   R0,B'0011',1(R1)              |
         CVD   R0,DOUBLE                     |  FORMAT DAY
         UNPK  5(3,R15),DOUBLE+6(2)          |
         OI    7(R15),C'0'               ----+
*
         MVI   4(R15),C'.'
         B     CVD$X
*-European Gregorian: 'dd-mmm-ccyy'
CVD$EG   DS    0H
* need to convert yydddd in binary to "00yydddf"
 UNPK 0(7,R15),0(4,R1)
 MVZ  0(6,R15),=8X'00'
 TR   0(6,R15),=C'0123456789ABCDEF'
 MVI  6(R15),C' '
 B    CVD$X
         ST    R14,DOUBLE                 Save return address
         L     R14,=V(DRU$CON1)           Locate constants CSECT
         MVC   W_IDJULP4(C_IDJULP4L),C_IDJULP4-DRU$CON1(R14)
         MVI   W_IDJULP4_STR,0
         MVC   W_IDJULP4_STR+1(3),0(R1)
         MVC   W_ODGEUR11A(C_ODGEUR11AL),C_ODGEUR11A-DRU$CON1(R14)
         ST    R15,W_ODGEUR11A_STR
         DA#SMODE 31                      Must be in 31 bit mode
         L     R15,EP_DA$DATE             Locate EPA of R$DATE routine
         CALL  (15),(W_IDJULP4,W_ODGEUR11A),                           @
               VL,MF=(E,PARMLIST)
         DA#SMODE 24                      Back to 24 bit mode
         L     R14,DOUBLE
CVD$X    DS    0H
         BSM   0,R14
*
** CONVERT BINARY TIME TO PRINT
** INPUT: R1  - TIME TO CONVERT
**        R15 - OUTPUT LOCATION
*
CONVERT_BINARY_TIME EQU *
         SLR   R0,R0                      CLEAR REGISTER
         D     R0,=F'100'                 DIVIDE OUT 100THS OF SECOND
         SLR   R0,R0                      CLEAR REGISTER
         D     R0,=F'60'                  DIVIDE OUT SECONDS
         CVD   R0,DOUBLE                  CONVERT SECONDS TO PACKED
         UNPK  6(3,R15),DOUBLE+6(2)       SAVE SECONDS
         OI    6+2(R15),C'0'              FIX SIGN BYTE
         MVI   6(R15),C':'                COLON
         SLR   R0,R0                      CLEAR REGISTER
         D     R0,=F'60'                  DIVIDE OUT MINUTES
         CVD   R0,DOUBLE                  CONVERT MINUTES TO PACKED
         UNPK  3(3,R15),DOUBLE+6(2)       SAVE MINUTES
         OI    3+2(R15),C'0'              FIX SIGN BYTE
         MVI   3(R15),C':'                COLON
         CVD   R1,DOUBLE                  CONVERT MINUTES TO PACKED
         UNPK  0(3,R15),DOUBLE+6(2)       SAVE HOURS
         OI    0+2(R15),C'0'              FIX SIGN BYTE
         MVI   0(R15),C' '                LEADING SPACE
         BSM   0,R14                      Return to caller
*
** POINT REGISTER 15 TO FIRST BLANK IN STRING
** INPUT:  R0  - MAXIMUM LENGTH OF STRING
**         R15 - STRING
** OUTPUT: R15 - FIRST SPACE IN STRING
*
LOCATE_FIRST_SPACE EQU *
         CLI   0(R15),C' '
         BE    LFS$X
         LA    R15,1(R15)
         BCT   R0,LOCATE_FIRST_SPACE
LFS$X    EQU   *
         BSM   0,R14
*
** CONVERT R1 TO A HEX STRING - FULL 8 BYTES
** INPUT: R1 = NUMBER TO CONVERT
** OUTPUT: R15 - ADDRESS TO PUT 8 BYTE LITERAL
*
HEXSTR8  DS    0H
         ST    R1,DOUBLE                  SAVE NUMBER
         UNPK  0(9,R15),DOUBLE(5)
         MVZ   0(8,R15),=8X'00'
         TR    0(8,R15),=C'0123456789ABCDEF'
         LA    R15,8(R15)
         MVI   0(R15),C' '
         BSM   0,R9
*
** Check number to ensure its numeric
*
CHKNUM   DS    0H
         CLI   0(R15),C'0'                Min number?
         BL    CN$INV                     No, its invalid
         CLI   0(R15),C'9'                Max number?
         BH    CN$INV                     No, its invalid
         LA    R15,1(R15)                 Bump to next one
         BCT   R0,CHKNUM                  Check number
         BSM   0,R14
CN$INV   DS    0H
         SLR   R15,R15
         BSM   0,R14
*
** EDIT PERCENTAGE
**  INPUT:  R14 DIVISOR
**          R1 DIVIDEND
**  OUTPUT: R15 ADDRESS OF OUTPUT (4 BYTES)
*
EDITPER  DS    0H
         C     R1,=8X'00'
         BE    EDITFW4               Continue
EP$DB0CX EQU   *
         SLR   R0,R0                 CLEAR REGISTER
         M     R0,=F'100'
         SLR   R0,R0                 CLEAR REGISTER
         DR    R0,R14                DIVIDE IT
         SRL   R14,1
         CR    R0,R14                IS ROUNDING NEEDED ?
         BL    *+8                   BRANCH IF NOT
         AH    R1,=H'1'
* NOTE: FALL THRU INTO EDITFW4 INTERNAL SUBROUTINE...
*
**  EDIT FULLWORD
**   INPUT:  R1  ADDRESS OF FULLWORD
**   OUTPUT: R15 ADDRESS OF OUTPUT (4 BYTES)
*
EDITFW4  DS    0H
         CVD   R1,DOUBLE             GET IN DECIMAL
         MVC   0(4,R15),=X'40,20,20,20'
         ED    0(4,R15),DOUBLE+6     FORMAT PERCENTAGE
         OI    3(R15),C'0'           ENSURE NUMERICS
         BSM   0,R9
*
** Edit number
** INPUT:  R1 - VALUE TO EDIT
**         R15 - ADDRESS TO PUT PATTERN
*
EDIT15   DS    0H
         CVD   R1,DOUBLE                  Convert to packed
         MVC   0(15,R15),EDITP15          Get edit pattern
         ED    0(15,R15),DOUBLE+2         Edit number
         OI    14(R15),C'0'               Ensure zero
         BSM   0,R14                      Return to caller
*
** EDIT WITH DASH FILL FROM LEFT TO RIGHT (15 BYTES)
** INPUT:  R1 - VALUE TO EDIT
**         R15 - ADDRESS TO PUT PATTERN
*
EDITD15  DS    0H
         CVD   R1,DOUBLE                  CONVERT TO PACKED
         MVC   0(15,R15),EDITP15          GET EDIT PATTERN
         MVI   0(15),C'-'                 LEADING DASHES
         ED    0(15,R15),DOUBLE+2         EDIT
         LTR   R1,R1                      DID HE FIND ANYTHING TO EDIT?
         BNZ   EDITD15X                   YES, MOVE ON
         MVI   14(R15),C'0'               NO, LEAVE A ZERO
EDITD15X DS    0H
         BSM   0,R9                       RETURN
*
** Clear recout to blanks
*
CLEAR_RECOUT EQU *
         LA    R15,RECOUT                 Locate output record
         MVI   0(R15),C' '                Get blank
         MVC   1(132,R15),0(R15)          ..propagate it
         BSM   0,R14                      Leave
         EJECT
***********************************************************************
***                                                                 ***
**       Sort file specified on sort statement at RECOUT             **
**                                                                   **
**       Input: R1 has sort string                                   **
**              SF_SORTIN  - DDNAME of input file                    **
**              SF_SORTOUT - DDNAME of output file                   **
***                                                                 ***
***********************************************************************
         SPACE 2
SORT_FILE DS   0H
         ST    R14,RA$SORT_FILE           Save return address
*
** Create SORT control card string
*
         BAS   R14,CLEAR_RECOUT           Clear string area to blanks
         LA    R15,RECOUT+3               Locate SORT statement start
         MVC   0(13,R15),=C'SORT FIELDS=(' Text
         LA    R15,13(R15)                Bump past it
         SLR   R14,R14                    Clear register
         IC    R14,0(R1)                  Get length
         EX    R14,SF$MSF                 Move in sort fields
         LA    R15,1(R14,R15)             Bump past sort fields
         MVC   0(16,R15),=C') OPTION SORTIN=' Text
         LA    R15,16(R15)                Bump past it
         MVC   0(8,R15),SF_SORTIN         WRKFILE1 DDNAME
         LA    R0,8                       Max length of DDNAMe
         BAS   R14,LOCATE_FIRST_SPACE     Locate the first space
*
         MVC   0(9,R15),=C',SORTOUT='     Text
         LA    R15,9(R15)                 Bump past it
         MVC   0(8,R15),SF_SORTOUT        WRKFILE2 DDNAME
         LA    R0,8                       Max length of DDNAME
         BAS   R14,LOCATE_FIRST_SPACE     Locate the first space
*
         LR    R5,R15                     Save location on record
         DEVTYPE =CL8'SORTWK01',DOUBLE    User specified files for us?
         LTR   R15,R15                    Have at least one?
         BZ    SF$DSWX                    Yes, continue
         LR    R15,R5                     Get location on record
         MVC   0(11,R15),=C',DYNALLOC=('  Text
         LA    R15,11(R15)                Bump past it
         L     R14,=V(DRU$OPTS)           Locate options CSECT
         MVC   0(8,R15),OP_SRTUNIT-DRU$OPTS(R14)
         LA    R0,8                       Max length of DDNAME
         BAS   R14,LOCATE_FIRST_SPACE     Locate the first space
         MVC   0(3,R15),=C',3)'           Text
         LA    R15,3(R15)                 Bump past it
SF$DSWX EQU    *
*
         MVC   0(8,R15),=C',MSGDDN='      Text
         LA    R15,8(R15)                 Bump past it
         MVC   0(8,R15),DDN_WF5           Sort message DDNAME
         LA    R0,8                       Max length of DDNAME
         BAS   R14,LOCATE_FIRST_SPACE     Locate the first space
*
** Calculate length of the sort control statement and fix parameter lst
*
         LA    R15,1(R15)                 Add for ending space
         LA    R14,RECOUT+2               Beginning of sort statement
         SR    R15,R14                    Length = End - Beginning
         STCM  R15,B'0011',RECOUT         Save length of sort statement
*
         SLR   R5,R5                      Set pseudo return code
         LA    R1,SF_PARM                 Locate parameter list
         LA    R15,RECOUT                 Locate control statements
         ST    R15,0(R1)                  Save it into parm list
         MVC   4(4,R1),=X'FFFFFFFF'       Set end of list
*
** Attach the sort
*
         LA    R9,SF_ECB                  Locate Event Control Block
         XC    0(4,R9),0(R9)              Clear Event control Block
         L     R14,=V(DRU$CON1)           -> DRU$CON1
         MVC   PARMLIST(C_ATCL),C_ATC-DRU$CON1(R14)
*
         ATTACH EPLOC==CL8'SORT',         Attach Sort                  @
               ECB=(9),                   ..Event Control Block        @
               SF=(E,PARMLIST)            ..Attach Execute form
         ST    R1,SF_TCB                  Save TCB address
*
         WAIT  ECB=SF_ECB                 Wait for Sort to complete
         DETACH SF_TCB                    Detach Sort
*
         CLC   SF_ECB+1(3),=8X'00'        Sort successful?
         BNE   SF$ERR                     No, error!
         TM    PPC_FLAG1,$PPC_F1PSM       Print Sort messages?
         BO    SF$ECHO                    Yes, echo the output
         B     SF$EX                      No, leave
SF$ERR   DS    0H
         MVI   MAXCC,20
*
** Echo the SORT results to our SYSPRINT
*
SF$ECHO  EQU   *
         BAS   R14,CLEAR_RECOUT
         BAS   R14,PRINT_SYSPRINT_RECORD Print the record
         BAS   R14,FORMAT_MESSAGE         Clear output record to blanks
         MVC   0(MSG4L,R15),MSG4-DRU$CON1(R1)
         LA    R15,MSG4L(R15)             Bump past it
         UNPK  0(9,R15),SF_ECB(5)
         MVZ   0(8,R15),=8X'00'
         TR    0(8,R15),=C'0123456789ABCDEF'
         MVI   8(R15),C' '
         BAS   R14,PRINT_SYSPRINT_RECORD Print the record
*
         LA    R3,WRKFILE5                Locate DCB work area
         L     R1,=V(DRU$CON1)
         MVC   PARMLIST(C_LSTIL),C_LSTI-DRU$CON1(R1)
         MVC   0(C_DCBIL,R3),C_DCBI-DRU$CON1(R1)
         MVC   DCBDDNAM-IHADCB(8,R3),DDN_WF5  Get DDNAME
         OI    DCBRECFM-IHADCB(R3),DCBRECCA   Turn on ASA
         LA    R1,SF$SYNAD
         STCM  R1,B'0111',DCBSYNAD+1-IHADCB(R3)
         LA    R2,SF$ELX                  Locate END-OF-FILE area
         STCM  R2,B'0111',DCBEODAD-IHADCB+1(R3) Insert into DCB
         OPEN  ((3),(INPUT)),MF=(E,PARMLIST)
         MVI   RECOUT+1,C'-'
         MVC   RECOUT+2(131),RECOUT+1
         BAS   R14,PRINT_SYSPRINT_RECORD Print the record
         MVI   RECOUT+121,C' '
         MVC   RECOUT+122(11),RECOUT+121
*
SF$EL    EQU   *
         GET   WRKFILE5                   Get SORTMSG record
         TM    FLAG_X1,$FX1_SYNAD         Hit a SYNAD error?
         BO    SF$SERR                    Yes, leave
         MVC   RECOUT+1(120),1(R1)        Move SORTMSG record
         BAS   R14,PRINT_SYSPRINT_RECORD Issue it
         B     SF$EL
*
SF$SERR  EQU   *
         BAS   R14,FORMAT_MESSAGE         Clear output record to blanks
         MVC   0(MSG23L,R15),MSG23-DRU$CON1(R1)
         LA    R15,MSG23L+1(R15)
         MVC   0(78,R15),WORKAREA
         BAS   R14,PRINT_SYSPRINT_RECORD Print the record
*
SF$ELX   EQU   *
         MVI   RECOUT+1,C'-'
         MVC   RECOUT+2(131),RECOUT+1
         BAS   R14,PRINT_SYSPRINT_RECORD Print the record
         BAS   R14,CLEAR_RECOUT
         BAS   R14,PRINT_SYSPRINT_RECORD Print the record
*
         LA    R3,WRKFILE5
         BAS   R9,CLOSE_FILE
SF$EX    EQU   *
*
** Common exit from Sort_File
*
SF$X     EQU   *
         LR    R15,R5                     SORT successful?
         L     R14,RA$SORT_FILE           Get return address
         BSM   0,R14                      Return to caller
SF$MSF   MVC   0(0,R15),1(R1)             Get fields
*
** SYNAD error routine for reading SORTMSG
*
SF$SYNAD EQU   *
         STM   R12,R14,PARMLIST
         SYNADAF ACSMETH=QSAM
*
         MVC   WORKAREA(78),50(R1)      Save error message
         OI    FLAG_X1,$FX1_SYNAD       Turn on flag
*
         SYNADRLS ,
*
         LM    R12,R14,PARMLIST
         BR    R14
         EJECT
***********************************************************************
***                                                                 ***
**       Data Constants                                              **
***                                                                 ***
***********************************************************************
         SPACE 2
*
EDITP15  DC    X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'
*
C_DSNLV  DC    AL1(C_DSNLVL/2)
C_DSNLVS DA#STR 'By Volume'
C_DSNLVL EQU   *-C_DSNLV-3
*
C_DSNLD  DC    AL1(C_DSNLDL/2)
C_DSNLDS DA#STR 'By Data Set Name'
C_DSNLDL EQU   *-C_DSNLD-3
*
C_NODE   DC    AL1(C_NODEL/2)
C_NODES  DA#STR  'NODE list'
C_NODEL  EQU   *-C_NODE-3
*
C_DCRV   DC    AL1(C_DCRVL/2)
C_DCRVS  DA#STR  'DASD list by Volume'
C_DCRVL  EQU   *-C_DCRV-3
*
 AGO .RACF2X
C_NODERF DC    C'Note: "*" nodes have no RACF group'
C_NODERFL EQU  *-C_NODERF
*
C_RLOC   ICHEINTY LOCATE,TYPE='USR',MF=L
C_RLOCL  EQU   *-C_RLOC
.RACF2X ANOP ,
*
C_DU     DC    AL1(C_DUL/2)
C_DUS    DA#STR  'DASD Usage'
C_DUL    EQU   *-C_DU-3
*
C_DT     DC    AL1(C_DTL/2)
C_DTS    DA#STR  'Device Type Summary'
C_DTL    EQU   *-C_DT-3
*
*
C_STVL   DC    AL1(C_STVLL/2)
C_STVLS  DA#STR 'VTOC LISTING'
C_STVLL  EQU   *-C_STVL-3
*
** Literals
*
LTORG    DS    0F
         LTORG ,
LTORGL   EQU   *-LTORG
         DS    0D
*
** Calculate room used and left in main CSECT
*
#DA$DISKR EQU  *-DA$DISKR                 Length of CSECT
#DA$DISKR_LEFT EQU (3*4096)-#DA$DISKR     Bytes free in CSECT
         EJECT
***********************************************************************
***                                                                 ***
**       GETMAINed work area                                         **
***                                                                 ***
***********************************************************************
             SPACE 2
DSA          DSECT ,
             DS    18F                    Register Save area
SUBRSA       DS    18F                    Register Save Area 4 subs
BLETRSA      DS    18F                    Register Save Area 4 DRU$BLET
PSRRSA       DS    18F                    Register Save Area 4 DRU$PSR
PRRRSA       DS    18F                    Register Save Area 4 DRU$PRR
PARMLIST     DS    XL256                  Parameter list
             DS    0D
DOUBLE       DS    D                      Double word work area
DOUBLE2      DS    2D                     Double word work area * 2
E_OPENA_CODE DS    F                      E$OPENA - Code
*                                         Merge: VATLST, System config
MVS_IV_VSL   DS    F                      ..IncVATLST - Table Length
MVS_IV_VSA   DS    F                      ..IncVATLST - Table Address
MVS_IV_VSC   DS    F                      ..IncVATLST - Table Cur. Loc.
MVS_IV_NUM   DS    F                      ..Number in table
*                                         Return Address
RA$DUPRT     DS    F                      ..DU$PRT
RA$SORT_FILE DS    F                      ..SORT_FILE
*                                         Big Letters:
BL_LEN       DS    F                      ..Length
BL_ADDR      DS    F                      ..Address
BL_LINEC     DS    F                      ..Line Count
BL_RA        DS    F                      ..Return Address
*                                         DASD Usage
*                                         ..Group
DU_WGVOLC    DS    F                      ..Volume count
DU_WGFTRK    DS    F                      ..Free tracks
DU_WGTTRK    DS    F                      ..Total tracks
*                                         ..Total
DU_WTVOLC    DS    F                      ..Volume count
DU_WTTTRK    DS    F                      ..Total tracks
DU_WTATRK    DS    F                      ..Allocated tracks
DU_WTFTRK    DS    F                      ..Free tracks
*
DU_TF1       DS    F                      ..F1DSCB
DU_TUC       DS    F                      ..Uncatalogued datasets
*                                         Entry point
EP_EB4UV     DS    F                      ..IEFEB4UV
EP_SS01      DS    F                      ..IDCSS01
EP_DA$MXD    DS    F                      ..DA$MXD
EP_DA$DATE   DS    F                      ..DA$DATE
*                                         Process_Volume
PV_VIT       DS    2F                     ..VTOC Information Table
PV_EXLST     DS    2F                     ..Exit List
PV_VCOUNT    DS    F                      ..Volume count
PV_SCOUNT    DS    F                      ..SMS count
PV_TCOUNT    DS    F                      ..Total datasets
PV_DCOUNT    DS    F                      ..DSCB count for volume
PV_STOD      DS    2F                     ..Start time and date
PV_ETOD      DS    2F                     ..End time and date
PV_JFCB      DS    XL(JFCBLGTH)           ..JFCB area
PV_CVPL      DS    XL(C_CVPLL)            ..CVAF - VTOC acess
PV_BAREA     DS    XL(#BUFLST)            ..CVAFSEQ buffer list
PV_DECB      DS    XL(C_DECBL)            ..DECB area
             DS    0F                     Scan_DASD_UCBs:
SDU_UCB      DS    F                      ..Returned UCB address
SDU_RETCODE  DS    XL4                    ..RC
SDU_RSNCODE  DS    XL4                    ..Reason
SDU_WA       DS    XL100                  ..Workarea
             DS    0F
SDU_UA       DS    XL48                   ..UCB area
             DS    0F
SDU_CMXT     DS    XL32                   ..CMXT area
             DS    0F
SDU_UCBP     DS    XL48                   ..UCB prefix
             DS    0F
SDU_DCE      DS    XL256                  ..DCE area
SDU_DCELEN   DS    XL2                    ..DCE length
SDU_DEVT     DS    CL1                    ..Device class
             DS    0F                     Search DASD_UCBs
SDU_CMATCH   DS    F                      ..Count: Volume matched
SDU_COFF     DS    F                      ..Count: Offline
SDU_CON      DS    F                      ..Count: Online
SDU_UCBERA   DS    F                      ..Return address
SDU_DDC      DS    2F                     ..DDC table length, address
             DS    0F                     Parse_Parameter_Card
PPC_RA       DS    F                      ..Return Address
PPC_CB       DS    2F                     ..Command Buffer len,addr
PPC_NUM      DS    H                      ..Number of parms in error
PPC_COL      DS    H                      ..Column of first error
*-DATEF is not set via a parm yet.
PPC_DATEF    DS    X                      ..Date format
$PPC_DFJUL   EQU   X'00'                    ..Julian       1962.056
$PPC_DFISO   EQU   X'01'                    ..US Gregorian 1962-03-06
$PPC_DFEGREG EQU   X'02'                    ..Eur. Greg.   06-MAR-1997
$PPC_NOCHK   EQU   255                    ..Length byte if no check
PPC_VPREFIXL DS    X                      ..Volume prefix length
PPC_VPREFIX  DS    CL6' '                 ..Volume prefix
PPC_FLAG1    DS    B'00000000'            ..Flag 1
$PPC_F1VERB  EQU   B'10000000'              ..Verbose
$PPC_F1RUCB  EQU   B'01000000'              ..Report by UCB also?
$PPC_F1RBOTH EQU   B'01100000'              ..Report by both UCB+Volume
$PPC_F1PSM   EQU   B'00010000'              ..Print Sort Messages?
$PPC_F1SMSMC EQU   B'00001000'              ..SMS migration check?
$PPC_F1CATC  EQU   B'00000100'              ..Catalog check?
$PPC_F1RDSN  EQU   B'00000010'              ..Report by DSN also?
PPC_FLAG2    DS    B'00000000'            ..Flag 2
$PPC_F2DEBUG EQU   B'10000000'              ..Debug mode?
$PPC_F2NAUTH EQU   B'01000000'              ..Don't try auth stuff?
$PPC_F2CVTUS EQU   B'00100000'              ..Use CVTUS?
$PPC_F2ORU   EQU   B'00010000'              ..Only RECFM=U?
$PPC_F2OLL   EQU   B'00011000'              ..Only RECFM=U & PDS?
$PPC_F2DO    EQU   B'00000100'              ..DATAONLY for VTOCRPT?
$PPC_F2HELP  EQU   B'00000010'              ..Help wanted?
$PPC_F2NOPIC EQU   B'00000001'              ..No picture at startup?
PPC_FLAG3    DS    B'00000000'            ..Flag 3
$PPC_F3NSYSP EQU   B'10000000'              ..No System Profile?
             DS    0F                     Heading management
PRR_TITLE    DS    F                      ..Report title
PRR_STITLE   DS    F                      ..Report Sub-Title
PRR_PC       DS    F                      ..Report page count
PRR_LC       DS    X                      ..Sysprint Line count
*                                         Process VATDEF card
PVC_VATDEF   DS    CL72                   ..VATDEF card
PVC_IPLUSE   DS    CL3' '                 ..IPLUSE
PVC_SYSUSE   DS    CL3' '                 ..SYSUSE
*                                         DD Names
DDN_WF1      DS    CL8                    ..WRKFILE1
DDN_WF2      DS    CL8                    ..WRKFILE2
DDN_WF3      DS    CL8                    ..WRKFILE3
DDN_WF4      DS    CL8                    ..WRKFILE4 (LRECL=80)
DDN_VAT      DS    CL8                    ..VATLST
DDN_WF5      DS    CL8                    ..Sort Messages
*
** DCB areas
*
             DS    0F                     DCB areas
WRKFILE1     DS    XL(C_DCBIL)            ..WORK FILE 1
WRKFILE2     DS    XL(C_DCBIL)            ..WORK FILE 2
WRKFILE3     DS    XL(C_DCBIL)            ..WORK FILE 3
WRKFILE4     DS    XL(C_DCBIL)            ..WORK FILE 4
WRKFILE5     DS    XL(C_DCBIL)            ..WORK FILE 5
REPORT       DS    XL(C_DCBOL)            ..REPORT
             DS    0F                     Print_SYSPRINT_Record
SYSPRINT     DS    XL(C_DCBOL)            ..SYSPRINT
PSR_RA       DS    F                      ..Return address
PSR_PC       DS    F                      ..Sysprint Page count
PSR_LC       DS    X                      ..Line count on page
             DS    0F                     Print_Report_Record:
PRR_RA       DS    F                      ..Return address
             DS    0F                     Global variables
G_DASD       DS    F                      ..Online DASD count
G_VATMNT     DS    F                      ..Number: VATLST-UCB mount
G_BCPLEVEL   DS    XL(L'CVTPRODN)         ..BCP Product Name
G_DFARELS    DS    XL(L'DFARELS)          ..DFSMS/MVS level (binary)
G_DFSMSLVL   DS    CL5'1.3.0'             ..DFSMS/MVS level (Character)
G_DFPLVL     DS    CL5'3.3.2'             ..DFP level
*
** Work areas
*
HEADREC      DS    CL133                  Heading record
             DS    0D
CMXD_WA      DS    XL(CMXDL)
CMXD_RC      DS    X
*                                         Sort_File
SF_ECB       DS    F                      ..Event Control Block
SF_TCB       DS    F                      ..Task Control Block
SF_PARM      DS    3F                     ..Parameter List
SF_SORTIN    DS    CL8                    ..SORTIN ddname
SF_SORTOUT   DS    CL8                    ..SORTOUT ddname
SF_EXIT15    DS    XL4                    ..Exit 15 address
SF_TYPE      DS    C                      ..Type for Exit 15
SF_LRECL     DS    C'80'                  ..LRECL for Exit 15
*
** DA$DISKR ESTAE parameters
*
RSEP         DS    0D                     DRU$ESTA parameters
RSEP_R10     DS    F                      ..Base register (10)
RSEP_R11     DS    F                      ..Base register (11)
RSEP_R12     DS    F                      ..Base register (12)
RSEP_RETRYO  DS    H                      ..Retry routine offset
RSEP_UCB     DS    CL4                    ..UCB
RSEP_VOL     DS    CL6                    ..Volume
RSEP_FUNC    DS    CL8                    ..ID of function
RSEP_WTO     DS    XL(C_WTOL)             ..WTO work area
             DS    0D                     Alignment
*
** DA#DATE work areas
*
W_ODDOW9     DA#DATE DPE,OPREFIX=W_ODDOW9,                             @
               OSTR=YES,OSTRL=$DA#DATE_ODDOW9
W_ODJUL8     DA#DATE DPE,OPREFIX=W_ODJUL8,                             @
               OSTR=YES,OSTRL=$DA#DATE_ODJUL8
W_ODGEUR11   DA#DATE DPE,OPREFIX=W_ODGEUR11,                           @
               OSTR=YES,OSTRL=$DA#DATE_ODGEUR11
W_OTIMES8    DA#DATE DPE,OPREFIX=W_OTIMES8,                            @
               OSTR=YES,OSTRL=$DA#DATE_OTIMES8
W_IDJULP4    DA#DATE DPE,OPREFIX=W_IDJULP4,OSTR=YES,                   @
               OSTRL=$DA#DATE_IDJULP4
W_ODGEUR11A  DA#DATE DPE,OPREFIX=W_ODGEUR11A,OSTR=YES,OSTRL=4
W_ODDOW3A    DA#DATE DPE,OPREFIX=W_ODDOW3A,OSTR=YES,OSTRL=4
*
** Flags
*
FLAG_R       DS    B'00000000'            ..REPORT
$DCRV        EQU   B'10000000'            ....DASD CONFIG RPT BY VOLS
$DCRU        EQU   B'01000000'            ....DASD CONFIG RPT BY UCB
FLAG_X1      DS    B'00000000'            ..Execution flag
$FX1_SYSPRT  EQU   B'10000000'            ....SYSPRINT file error
$FX1_VEOF    EQU   B'01000000'            ....VATLST End-of-file
$FX1_SEOF    EQU   B'00100000'            ....Sys config end-of-file
$FX1_APF     EQU   B'00010000'            ....APF Authorization?
$FX1_SYNAD   EQU   B'00001000'            ....SYNAD error?
$FX1_VTOC    EQU   B'00000100'            ....VTOC processing?
$FX1_UCBSCAN EQU   B'00000010'            ....Use UCBSCAN?
*open----->  EQU   B'00000001'            ....
FLAG_X2      DS    B'00000000'            ..Execution flag 2
$FX2_DDCO    EQU   B'10000000'            ....DDC table overflow
$FX2_LDATE   EQU   B'01000000'            ....Loaded DA$DATE?
$FX2_LMXD    EQU   B'00100000'            ....Loaded DA$MXD?
MAXCC        DS    X                      Maximum Condition code
*
LASTVOLP     DS    CL5                    Last volume (control break)
LASTCHAN     DS    CL1                    Last channel (control break)
*
** Output records
*
W_RH2        DS    CL133                  Report heading 2
W_RH3        DS    CL133                  Report heading 3
W_RH4        DS    CL133                  Report heading 4
*
RECOUT       DS    XL(WDL)                Output record
WRKREC       DS    XL(WDL)                Work record
             DS    0D
WORKAREA     DS    XL265                  Work area
             DS    0D
DSAL         EQU   *-DSA
             EJECT ,
***********************************************************************
***                                                                 ***
**       Constants CSECT                                             **
***                                                                 ***
***********************************************************************
         SPACE 2
DRU$CON1 CSECT ,
DRU$CON1 AMODE 24
DRU$CON1 RMODE 24
*
** Standard O/S eyecatcher
*
CON1_EC  B    CON1_ECL(0,R15)           Bump past EyeCatcher
         DC   AL1(L'CON1_ECV)           Length of eyecatcher
CON1_ECV DC   C'DRU$CON1 -- Constant CSECT #1'
         DS   0H
CON1_ECL EQU  *-CON1_EC
*
** Messages
*
MSG1     DC    C'01I Execution'
MSG1L    EQU   *-MSG1
MSG1A    DC    C'Begins. Time:'
MSG1AL   EQU   *-MSG1A
MSG1B    DC    C'Ends. Maximum condition code was'
MSG1BL   EQU   *-MSG1B
*
MSG2     DC    C'02E ENQ to VTOC failed, RC='
MSG2L    EQU   *-MSG2
MSG3     DC    C'03I VATLST and system mounts differ on'
MSG3L    EQU   *-MSG3
MSG4     DC    C'04I Sort completed with ECB='
MSG4L    EQU   *-MSG4
MSG5     DC    C'05E DEVTYPE failure: assuming 3380D, RC='
MSG5L    EQU   *-MSG5
MSG6     DC    C'06E LSPACE failed, RC='
MSG6L    EQU   *-MSG6
MSG7     DC    C'07E IEFEB4UV failed, RC='
MSG7L    EQU   *-MSG7
MSG8     DC    C'08W Device types do not match on volume('
MSG8L    EQU   *-MSG8
MSG9     DC    C'09W Name not consistent on volume='
MSG9L    EQU   *-MSG9
MSG10    DC    C'10I UCB disassociated from subchannel: ('
MSG10L   EQU   *-MSG10
MSG12    DC    C'12I'
MSG12L   EQU   *-MSG12
MSG12A   DC    C' VATLST entries are unused:'
MSG12AL  EQU   *-MSG12A
MSG15    DC    C'15E DYNALLOC to volume failed, RC='
MSG15L   EQU   *-MSG15
MSG16    DC    C'16E RDJFCB failed, RC='
MSG16L   EQU   *-MSG16
MSG17    DC    C'17E OPEN failed, RC='
MSG17L   EQU   *-MSG17
MSG18    DC    C'18E CVAFSEQ failed, RC='
MSG18L   EQU   *-MSG18
MSG19    DC    C'19I Dump of'
MSG19L   EQU   *-MSG19
MSG20    DC    C'20W Runing unauthorized, some functions disabled'
MSG20L   EQU   *-MSG20
MSG21    DC    C'21I IEA168I '
MSG21T   DC    C'VATLST default use attribute of '
MSG21A   DC    C'PRIVATE used'
MSG21L   EQU   *-MSG21
MSG22    DC    C'22I Format error found in VATDEF statement'
MSG22L   EQU   *-MSG22
MSG23    DC    C'23I Read of SORTMSG failed:'
MSG23L   EQU   *-MSG23
MSG24    DC    C'24I Found $$NOAPF DDNAME, turning off authorized '
         DC    C'function processing'
MSG24L   EQU   *-MSG24
MSG25    EQU   *-*                        Reserved for ESTAE routine
MSG26    DC    C'DA$DISKR-026I '
         DC    C'Attempting retry after ABEND: UCB='
MSG26UCB DC    C'xxxx'
         DC    C', volume='
MSG26VOL DC    C'vvvvvv'
         DC    C' - function='
MSG26ID  DC    8C'?'
MSG26L   EQU   *-MSG26
MSG27    DC    C'27E ABEND occurred while processing ('
MSG27UCB DC    C'xxxx'
MSG27D   DC    C'-'
MSG27VOL DC    C'vvvvvv)'
         DC    C' function='
MSG27ID DC     8C'?'
MSG27L   EQU   *-MSG27
MSG28    DC    C'28I Number of DASD UCBs Online='
MSG28L   EQU   *-MSG28
MSG29    DC    C'29W Overflow found in DASD device count table'
MSG29L   EQU   *-MSG29
MSG30    DC    C'30I Parameter:'
MSG30L   EQU   *-MSG30
MSG31    DC    C'30E First invalid parm at column:'
MSG31L   EQU   *-MSG31
MSG32    DC    C'31E Number of invalid parms:'
MSG32L   EQU   *-MSG32
MSG33    DC    C'33I Number of volumes matched:'
MSG33L   EQU   *-MSG33
MSG34    DC    C'34I VTOC processing started at'
MSG34L   EQU   *-MSG34
MSG35    DC    C'35I SMS flag byte='
MSG35F   DC    C'xx '
         DC    C'- volume='
MSG35V   DC    C'volume'
         DC    C', dsn='
MSG35L   EQU   *-MSG35
MSG36    DC    C'36W Warning: Not all DASD UCBs will be shown if '
         DC    C'defined dynamic or above the line'
MSG36L   EQU   *-MSG36
MSG37    DC    C'37E UCBSCAN macro failed for UCB='
MSG37L   EQU   *-MSG37
MSG38    DC    C'38I UCBVOLI all zeros: Skipping UCB='
MSG38L   EQU   *-MSG38
*
MSG40    DC    C'40I Processing UCB='
MSG40UCB DS    XL(L'WD_UCB)
         DC    C' volume='
MSG40VOL DS    XL(L'WD_VOLS)
         DC    C' at'
MSG40L   EQU   *-MSG40
MSG41    DC    C'41I > VTOC will be read using '
MSG41T   DC    C'BSAM'
         DC    C' for volume '
MSG41V   DC    C'volume'
MSG41L   EQU   *-MSG41
*
MSG60    DC    C'60I Datasets with SMS indicators: '
MSG60L   EQU   *-MSG60
MSG61    DC    C'61I Total number of datasets:     '
MSG61L   EQU   *-MSG61
MSG62    DC    C'062I Help information for DA$DISKR:'
MSG62L   EQU   *-MSG62
MSG63    DC    C'63I '
MSG63A   DC    C'Level of'
MSG63L   EQU   *-MSG63
MSG63B   DC    C'DFSMS/MVS:'
MSG63D   DC    C'DFP:'
MSG63E   DC    C'- BCP:'
*
C_MSGS   DC    C'M e s s a g e s'
C_SYSID  DC    C'SYSID:'
C_DU_GROUP DC C'Group'
C_DU_NUM   DC C'Number'
C_DU_TTRK  DC C'Total Tracks'
C_DU_ATRK  DC C'Allocated Tracks'
C_DU_FTRK  DC C'Free  Tracks'
C_NUMV     DC C'Number of datasets on volume is'
*
C_DCRC   DC    AL1(C_DCRCL/2)
C_DCRCS  DA#STR  'DASD list by Channel'
C_DCRCL  EQU   *-C_DCRC-3
C_STDC   DC    AL1(C_STDCL/2)
C_STDCS  DA#STR  'DASD Configuration'
C_STDCL  EQU   *-C_STDC-3
*
C_SUM    DC    AL1(C_SUML/2)
C_SUMS   DA#STR  'Summary'
C_SUML   EQU   *-C_SUM-3
*
C_BLDC1  DA#STR '  DASD  '
C_BLDC2  DA#STR ' CONFIG '
C_BLDL   DA#STR 'DSN LIST'
C_BLBV   DA#STR ' BY VOL '
C_BLBD   DA#STR ' BY DSN '
*
** DA#DATE constants
*
C_ODDOW9   DA#DATE DPE,OPREFIX=C_ODDOW9,OSTR=NO,                       @
               OSTRL=$DA#DATE_ODDOW9,OTYPE=$DA#DATE_ODDOW
C_ODJUL8   DA#DATE DPE,OPREFIX=C_ODJUL8,OSTR=NO,                       @
               OSTRL=$DA#DATE_ODJUL8,OTYPE=$DA#DATE_ODJUL
C_ODGEUR11 DA#DATE DPE,OPREFIX=C_ODGEUR11,OSTR=NO,                     @
               OSTRL=$DA#DATE_ODGEUR11,OTYPE=$DA#DATE_ODGEUR
C_OTIMES8  DA#DATE DPE,OPREFIX=C_OTIMES8,OSTR=NO,                      @
               OSTRL=$DA#DATE_OTIMES8,OTYPE=$DA#DATE_OTIMES
C_IDJULP4  DA#DATE DPE,OPREFIX=C_IDJULP4,OSTR=NO,                      @
               OSTRL=$DA#DATE_IDJULP4,OTYPE=$DA#DATE_IDJULP
C_ODGEUR11A DA#DATE DPE,OPREFIX=C_ODGEUR11A,                           @
               OSTR=NO,OFLAG=$DA#DATE_ADDR,                            @
               OSTRL=$DA#DATE_ODGEUR11,OTYPE=$DA#DATE_ODGEUR
C_ODDOW3A  DA#DATE DPE,OPREFIX=C_ODDOW3A,                              @
               OSTR=NO,OFLAG=$DA#DATE_ADDR,                            @
               OSTRL=$DA#DATE_ODDOW3,OTYPE=$DA#DATE_ODDOW
*
** I/O constatns
*
C_LSTI   OPEN  (*-*,(INPUT)),MF=L
C_LSTIL  EQU   *-C_LSTI
C_LSTO   OPEN  (*-*,(OUTPUT)),MF=L
C_LSTOL  EQU   *-C_LSTO
         PRINT NOGEN
         READ  C_DECB,SF,*-*,*-*,'S',MF=L
C_DECBL  EQU   *-C_DECB
C_CLOSE  CLOSE (*-*),MF=L
C_CLOSEL EQU   *-C_CLOSE
*
C_RDJFCB RDJFCB (*-*),MF=L
C_RDJFCBL EQU  *-C_RDJFCB
*
** Constant DCBs
*
C_DCBI   DCB   DDNAME=C_DCBI,                                          @
               DSORG=PS,MACRF=GL,RECFM=FB,EODAD=*-*
C_DCBIL  EQU   *-C_DCBI
C_DCBV   DCB   DDNAME=C_DCBV,                                          @
               DSORG=PS,MACRF=R,RECFM=F,BLKSIZE=96,KEYLEN=44
C_DCBVL  EQU   *-C_DCBV
C_DCBO   DCB   DDNAME=C_DCBO,                                          @
               DSORG=PS,MACRF=PM
C_DCBOL  EQU   *-C_DCBO
*
** LSPACE
*
C_LSPC   LSPACE MF=L
C_LSPCL  EQU   *-C_LSPC
C_LSPCDL LSPACE MF=(L,DATA)               LSPACE data mapping
C_LSPCDLL EQU  *-C_LSPCDL
*
** Misc
*
C_CVPL   CVAFSEQ DEB=*-*,BUFLIST=*-*,                                  @
               IXRCDS=KEEP,                                            @
               ACCESS=GTEQ,                                            @
               MF=L
C_CVPLL  EQU   *-C_CVPL
*
C_ATC    ATTACH EPLOC=*-*,SF=L
C_ATCL   EQU   *-C_ATC
*
C_LOCATE CAMLST NAME,*-*,,*-*
C_LOCATEL EQU  *-C_LOCATE
*
C_DTYPE  DEVTYPE ,(*-*,24),UCBLIST=(*-*,*-*),MF=L
C_DTYPEL EQU   *-C_DTYPE
*
C_ESTAE  ESTAE *-*,CT,TERM=NO,MF=L
C_ESTAEL EQU   *-C_ESTAE
*
C_ENQ    ENQ   (*-*,*-*,S,6,SYSTEM),RET=TEST,MF=L
C_ENQL   EQU   *-C_ENQ
*
C_WTO    WTO   '                                                       @
                                                                       @
                       ',                                              @
               ROUTCDE=(11,14),MCSFLAG=HRDCPY,MF=L
C_WTOL   EQU   *-C_WTO
*
** Startup picture
**
** Author of this "ASCII" art is unknown.
*
STARTUP_PICTURE DS 0H
 DA#STR ' '
 DA#STR '              ________*________     The Disk Report Utility - @
               v&DAVER'
 DA#STR '____________  \_______________/'
 DA#STR '\__________/      / /               Freeware! written by David@
                Alcock'
 DA#STR '     __\ \_______/ /__ '
 DA#STR '     \_______________/              Assembled on &ASMDATE. at @
               &SYSTIME using:'
 DA#STR ' '
 DA#STR '        DASD Space:                 - &DMACLIB. MACLIBs'
 DA#STR '     The Final Frontier             - &MMACLIB. MACLIBs'
 DC  X'FFFF'
*
* That silliness deserves some more:
* ---------------------------------
*
* Star Trek XVII - The search for DASD space.
* To boldy go where no DASD report utility has gone before!
*
* DASD Space: The final frontier. 0 bytes free.
*
* Dammit Jim! I'm a doctor not a DASD storage admistrator.
*
* Spock: Are you out of your Vulcan mind?
*
* Data: "It's a Singer". Captain Picard: "Make it sew".
*
NO_PICTURE DS 0H
 DA#STR 'The Disk Report Utility - v&DAVER'
 DA#STR ' '
 DA#STR 'Freeware! written by David Alcock'
 DA#STR ' '
 DA#STR 'Assembled on &ASMDATE. at &SYSTIME using:'
 DA#STR ' '
 DA#STR '- &DMACLIB. MACLIBs'
 DA#STR '- &MMACLIB. MACLIBs'
 DA#STR ' '
 DC  X'FFFF'
         DS    0D
         EJECT ,
***********************************************************************
***                                                                 ***
**       Options CSECT                                               **
***                                                                 ***
***********************************************************************
           SPACE 2
DRU$OPTS   CSECT ,
DRU$OPTS   AMODE 24
DRU$OPTS   RMODE 24
*
OP         EQU   *
*
** Standard O/S eyecatcher
*
OPTS_EC  B    OPTS_ECL(0,R15)           Bump past EyeCatcher
         DC   AL1(L'OPTS_ECV)           Length of eyecatcher
OPTS_ECV DC   C'DRU$OPTS -- Options'
         DS   0H
OPTS_ECL EQU  *-OPTS_EC
*
*
           DC    C'NODES='
OP_NODES   DC    H'4096'
*
           DC    C'VOLPRFX='
OP_VOLP    DC    X'04'
*
           DC    C'SRTUNIT='
OP_SRTUNIT DC    CL8'SYSDA'
*
           DC    C'DDNAMES='
OP_WF1     DC    CL8'WRKFILE1'
OP_WF2     DC    CL8'WRKFILE2'
OP_WF3     DC    CL8'WRKFILE3'
OP_WF4     DC    CL8'WRKFILE4'
OP_WF5     DC    CL8'WRKFILE5'
OP_VAT     DC    CL8'VATLST'
*
OP_TDASDT  EQU   *
           DC    CL8'3380',C'E',AL2(1770+1)
           DC    CL8'3380',C'K',AL2(2655+1)
OP_TDASDTE EQU   (*-OP_TDASDT)/OPTDTL
*
OPL        EQU   *-OP
           DS    0D
*
** Map OP_TDASDT
*
OPTDT       DSECT   ,
OPTDT_NAME  DS   CL8'3380'                Name returned from IEFEB4UV
OPTDT_TYPE  DS   C                        Type
OPTDT_CYLS  DS   XL2                      Number of cylinders
OPTDTL      EQU  *-OPTDT
         EJECT
***********************************************************************
***                                                                 ***
**        Reset headings for VTOC listing                            **
***                                                                 ***
***********************************************************************
         SPACE 2
DRU$RVOL CSECT ,
DRU$RVOL AMODE 24
DRU$RVOL RMODE 24
         USING DRU$RVOL,R8                Set base register for CSECT
*
** Standard O/S eyecatcher
*
RVOL_EC  B    RVOL_ECL(0,R8)            Bump past EyeCatcher
         DC   AL1(L'RVOL_ECV)           Length of eyecatcher
RVOL_ECV DC   C'DRU$RVOL -- Reset Headings for VTOC listings'
         DS   0H
RVOL_ECL EQU  *-RVOL_EC
*
         MVI   PRR_LC,99                  Start on new page
         LA    R1,C_STVL
         ST    R1,PRR_TITLE               Set title
         BAS   R14,CLEAR_RH               Clear Report headings
*
         LA    R15,W_RH2+1                Locate work heading 2
         MVC   DLR_VOLS-DLR(6,R15),=C'Volume'
         TM    PPC_FLAG1,$PPC_F1CATC
         BNO   RV$NC1X
         MVC   DLR_CAT-1-DLR(3,R15),=C'NOT'
RV$NC1X  DS    0H
         MVC   DLR_CDATE-DLR(24,R15),=C'-------- Dates ----------'
*        MVC   DLR_ATYPE-DLR(23,R15),=C'----- Allocation ------'
*
         LA    R15,W_RH3+1                Locate work heading 2
         MVC   DLR_DSN-DLR(13,R15),=C'Data Set Name'
         MVC   DLR_VOLS-DLR(6,R15),=C'Serial'
         TM    PPC_FLAG1,$PPC_F1CATC
         BNO   RV$NC2X
         MVC   DLR_CAT-1-DLR(3,R15),=C'CAT'
RV$NC2X  DS    0H
         MVC   DLR_DSORG-DLR(5,R15),=C'DSORG'
         MVC   DLR_RECFM-DLR(5,R15),=C'RECFM'
         MVC   DLR_LRECL-DLR(5,R15),=C'LRECL'
         MVC   DLR_BLKSIZE-DLR(5,R15),=C'BLKSZ'
         MVC   DLR_CDATE-DLR(7,R15),=C'Created'
         MVC   DLR_UDATE-DLR(8,R15),=C'Last Ref'
*        MVC   DLR_ATYPE-DLR(4,R15),=C'Type'
*        MVC   DLR_SEC-DLR(5,R15),=C' Prim'
*        MVC   DLR_PRI-DLR(5,R15),=C'  Sec'
*        MVC   DLR_USED-DLR(5,R15),=C' Used'
         MVC   DLR_SMS-DLR(3,R15),=C'SMS'
*
         LA    R15,W_RH4                  Locate work heading 2
         MVI   0(R15),C'-'                Get Blank
         MVC   1(133-1,R15),0(R15)        ..Propagate it
         MVI   0(R15),C' '                Get Blank
         BSM   0,R9
         LTORG ,
         DS    0D
         DROP  R8
         EJECT
***********************************************************************
***                                                                 ***
**           Dynamically Allocate volume                             **
**                                                                   **
**     Input: R14 - Unit literal                                     **
**            R15 - Volume Serial literal                            **
***                                                                 ***
***********************************************************************
         SPACE 2
DRU$ALCV CSECT ,
DRU$ALCV AMODE 24
DRU$ALCV RMODE 24
         USING DRU$ALCV,R8                Set base register for CSECT
*
** Standard O/S eyecatcher
*
ALCV_EC  B    ALCV_ECL(0,R8)            Bump past EyeCatcher
         DC   AL1(L'ALCV_ECV)           Length of eyecatcher
ALCV_ECV DC   C'DRU$ALCV -- Dynamically Allcoate Volume'
         DS   0H
ALCV_ECL EQU  *-ALCV_EC
*
         STM   R14,R15,DOUBLE2+4          Save address of unit & Volume
*
** Format pointers
*
         SPACE 1
         LA    R4,HEADREC                 Get address of work area
         ST    R4,DOUBLE                  Save address
         OI    DOUBLE,S99RBPND            Indicate last one
         XC    0(S99RBEND-S99RB,R4),0(R4) Clear Request Block area
         MVI   S99RBLN-S99RB(R4),S99RBEND-S99RB Length of REQUEST BLK
         LA    R5,S99RBEND-S99RB(R4)      Locate Text Units Pointers
         ST    R5,S99TXTPP-S99RB(R4)      STORE ADDR OF Text Unit PTRs
         LA    R6,20(R5)    5*4=20        Bump past Text pointers
         MVI   S99VERB-S99RB(R4),S99VRBAL    Verb = ALLOCATE
***                                                               ***
*** The address of each of the text Units will be stored in the   ***
*** request block text PTR area as they are being defined,        ***
*** Active registers are: R5 - Address in text unit pointers      ***
***                       R6 - Address in text unit define area   ***
***                                                               ***
         SPACE 2
***-(1)---------------------------------- DDNAME=
         ST    R6,0(R5)                     Save Address of Text Unit
         LA    R5,L'S99TUPTR(R5)            Bump to next entry
*
         LA    R14,DALRTDDN                 Generate Key Value
         STH   R14,S99TUKEY-S99TUNIT(R6)    Store Key
         LA    R14,1                        Number of entries
         STH   R14,S99TUNUM-S99TUNIT(R6)    Store Number
         LA    R14,8                        Length of First Entry
         STH   R14,S99TULNG-S99TUNIT(R6)    Store Length
         LA    R1,S99TUPAR-S99TUNIT(R6)     Locate DDNAME
         ST    R1,DOUBLE2                   Save Addr: Returned DDNAME
*
         LA    R6,S99TUPAR-S99TUNIT+8(R6)   Bump past this Text Unit
***-(2)---------------------------------- DISP=
         ST    R6,0(R5)                     Save Address of Text Unit
         LA    R5,L'S99TUPTR(R5)            Bump to next entry
*
         LA    R14,DALSTATS                 Generate Key Value
         STH   R14,S99TUKEY-S99TUNIT(R6)    Store Key
         LA    R14,1                        Number of entries
         STH   R14,S99TUNUM-S99TUNIT(R6)    Store Number
         LA    R14,1                        Length of First Entry
         STH   R14,S99TULNG-S99TUNIT(R6)    Store Length
         MVI   S99TUPAR-S99TUNIT(R6),8      DISP=SHR
*
         LA    R6,S99TUPAR-S99TUNIT+2(R6)   Bump past this Text Unit
***-(3)---------------------------------- UNIT=
         ST    R6,0(R5)                     Save Address of Text Unit
         LA    R5,L'S99TUPTR(R5)            Bump to next entry
*
         LA    R14,DALUNIT                  Generate Key Value
         STH   R14,S99TUKEY-S99TUNIT(R6)    Store Key
         LA    R14,1                        Number of entries
         STH   R14,S99TUNUM-S99TUNIT(R6)    Store Number
         LA    R14,8                        Length of First Entry
         STH   R14,S99TULNG-S99TUNIT(R6)    Store Length
         L     R1,DOUBLE2+4                 Get address of Unit
         MVC   S99TUPAR-S99TUNIT(8,R6),0(R1) Save unit
*
         LA    R6,S99TUPAR-S99TUNIT+8(R6)   Bump past this Text Unit
***-(4)---------------------------------- DSN=
         ST    R6,0(R5)                     Save Address of Text Unit
         LA    R5,L'S99TUPTR(R5)            Bump to next entry
*
         LA    R14,DALDSNAM                 Generate Key Value
         STH   R14,S99TUKEY-S99TUNIT(R6)    Store Key
         LA    R14,1                        Number of entries
         STH   R14,S99TUNUM-S99TUNIT(R6)    Store Number
         LA    R14,12                       Length of First Entry
         STH   R14,S99TULNG-S99TUNIT(R6)    Store Length
         MVC   S99TUPAR-S99TUNIT(12,R6),=C'FORMAT4.DSCB'
*
         LA    R6,S99TUPAR-S99TUNIT+12(R6)  Bump past this Text Unit
***-(5,LAST)----------------------------- VOLUME=
         ST    R6,0(R5)                     Save Address of Text Unit
         OI    S99TUPTR-S99TUPL(R5),S99TUPLN End of parm indication
*
         LA    R14,DALVLSER                 Generate Key Value
         STH   R14,S99TUKEY-S99TUNIT(R6)    Store Key
         LA    R14,1                        Number of entries
         STH   R14,S99TUNUM-S99TUNIT(R6)    Store Number
         LA    R14,6                        Length of First Entry
         STH   R14,S99TULNG-S99TUNIT(R6)    Store Length
         L     R1,DOUBLE2+8                 Get address of volume
         MVC   S99TUPAR-S99TUNIT(6,R6),0(R1)
***-------------------------------------- Complete and make request
         LA    R1,DOUBLE                  Get address of Request BLK
         DYNALLOC ,                       Invoke SVC 99
AV$X     EQU   *
         BSM   0,R9                       Return to caller
         LTORG ,
         DS    0D
         DROP  R8
         EJECT
***********************************************************************
***                                                                 ***
**        Reset headings for Operations report                       **
** Input: R1 - points to 12 byte literal for Status line literal
***                                                                 ***
***********************************************************************
         SPACE 2
DRU$ROPR CSECT ,
DRU$ROPR AMODE 24
DRU$ROPR RMODE 24
         USING DRU$ROPR,R8                Set base register for CSECT
*
** Standard O/S eyecatcher
*
RPOR_EC  B    RPOR_ECL(0,R8)            Bump past EyeCatcher
         DC   AL1(L'RPOR_ECV)           Length of eyecatcher
RPOR_ECV DC   C'DRU$RPOR -- Reset headings for operations report'
         DS   0H
RPOR_ECL EQU  *-RPOR_EC
*
         ST    R1,PRR_STITLE              Set subtitle
         MVI   PRR_LC,99                  Start on new page
         BAS   R14,CLEAR_RH               Clear Report headings
*
** Format Report Heading 2
*
         LA    R15,W_RH2
         MVC   OR_VOLS-OR(6,R15),=C'Volume'
         MVC   OR_DEVT-OR(6,R15),=C'Device'
         MVC   OR_VMNT-OR-1(6,R15),=C'VATLST'
         MVC   OR_SMNT-OR(3,R15),=C'UCB'
         MVC   OR_TRKS-OR(26,R15),=C'--------- Tracks ---------'
         MVC   OR_VTOC-OR(18,R15),=C'------ VTOC ------'
*
** Format Report Heading 3
*
         LA    R15,W_RH3
         MVC   OR_UCB-OR(3,R15),=C'UCB'
         MVC   OR_VOLS-OR(6,R15),=C'Serial'
         MVC   OR_DEVT-OR(4,R15),=C'Type'
         MVC   OR_VMNT-OR(3,R15),=C'MNT'
         MVC   OR_SMNT-OR(3,R15),=C'MNT'
         MVC   OR_FTRKS-OR(10,R15),=C'      Free'
         MVC   OR_TTRKS-OR(10,R15),=C'     Total'
         MVC   OR_VTOCP-OR(4,R15),=C'Used'
         MVI   OR_IVTOC-OR(R15),C'I'
         MVC   OR_VTOCT-OR(4,R15),=C'Size'
         MVC   OR_VTOCF-OR(4,R15),=C'DSCB'
         MVC   OR_DESC-OR(23,R15),=C'Description from VATLST'
*
** Format Report Heading line 4
*
         LA    R15,W_RH4
         MVI   0(R15),C'-'
         MVC   1(L'W_RH4-1,R15),0(R15)
         MVI   0(R15),C' '                Fix FBA byte
*
** Return to caller
*
         BSM   0,R9
*
** Data Constants
*
         LTORG ,
         DS    0D
         DROP  R8
         EJECT
***********************************************************************
***                                                                 ***
**       Parse parameter card                                        **
**                                                                   **
**       Note: This has been moved to a seperate CSECT to save       **
**             data area in main CSECT.                              **
***                                                                 ***
***********************************************************************
         SPACE 2
DRU$PPC  CSECT ,
DRU$PPC  AMODE 31
DRU$PPC  RMODE ANY
         USING DRU$PPC,R8                 Set base register for CSECT
*
** Standard O/S eyecatcher
*
PPC_EC   B    PPC_ECL(0,R8)             Bump past EyeCatcher
         DC   AL1(L'PPC_ECV)            Length of eyecatcher
PPC_ECV DC    C'DRU$PPC  -- Parse Parameter Card'
         DS   0H
PPC_ECL EQU   *-PPC_EC
*
         ST    R9,PPC_RA                  Save Return Address
         SPACE 2
PARSE_PARAMETER_CARD EQU *
*
** Set defaults
*
         MVI   PPC_VPREFIXL,$PPC_NOCHK    All volumes
*
** See what register 1 has on input to this program
*
         EREG  R1,R1                      Get CPPL/parameter address
         TM    CPPLCBUF-CPPL(R1),X'80'    Was this command called?
         BNO   PPC$NC                     No, need to look at CBUF
*
** We were called, it has a Batch type (EXEC) parameter
*
         L     R7,0(R1)                   Get address of parm
         SLR   R6,R6                      Clear register
         ICM   R6,B'0011',0(R7)           Get length of parm
         BZ    PPC$X                      None, leave
         LA    R7,2(R7)                   Bump past parm length HW
         B     PPC$PARSE                  Parse the input
*
** We were not called, we are a "TSO Command Processor"
*
PPC$NC   EQU   *
         L     R7,CPPLCBUF-CPPL(R1)       Locate Command Buffer
         SLR   R6,R6                      Clear register
         ICM   R6,B'0011',0(R7)           Get total CBUF length
         SLR   R0,R0                      Clear register
         ICM   R0,B'0011',2(R7)           Get total Command name length
         LA    R15,4                      Length of header
         AR    R7,R15                     Bump past header
         SR    R6,R15                     Decrement for header length
         AR    R7,R0                      Bump past Command length
         SR    R6,R0                      Length of data
*
** Look thru command buffer/parameter for our commands
** Input: R7 - Address of command-buffer/Parameter
**        R6 - Length of command-buffer/Parameter
*
PPC$PARSE EQU *
         STM   R6,R7,PPC_CB               Save length and address
         B     PPC$DLMX                   Test first parameter
PPC$PRMM MVC   0(0,R15),0(R7)             Get parameter
PPC$FLC  CLC   TPF_NAME-TPF(0,R2),0(R7)
*
** Test for valid delimiter between operands
*
PPC$DLM  EQU   *
         CLI   0(R7),C' '                 Valid delimiter?
         BE    PPC$DLMS                   Yes, continue
         CLI   0(R7),C','                 Valid delimiter?
         BNE   PPC$OERR                   No, print error message
PPC$DLMS EQU   *
         LA    R7,1(R7)                   Bump past delimiter
         BCTR  R6,0                       Decrement count
         LTR   R6,R6                      End?
         BZ    PPC$END                    Yes, continue
PPC$DLMX EQU   *
*
** Process keywords into program flags. Generate an OI instruction to
** turn on flag:
**
** OI   PPC_FLAG1,$PPC_F1XDUMP    -   If PARM=HEXDUMP
*
         LA    R3,T_PFLAGSN               Get number of entries
         LA    R2,T_PFLAGS                Locate flag table
PPC$FL   EQU   *
         SLR   R14,R14                    Clear register
         IC    R14,TPF_NAMEL-TPF(R2)      Get length of operand
         CR    R14,R6                     Room in parse area for flag?
         BH    PPC$FLB                    No, continue
         EX    R14,PPC$FLC                Match?
         BE    PPC$FLX                    Yes, continue
PPC$FLB  EQU   *
         LA    R2,TPFL(R2)                Bump to next entry
         BCT   R3,PPC$FL                  ..Process it
         B     PPC$FX                     Continue: not a flag
PPC$FOI  OI    *-*,4
PPC$FLX  EQU   *
         MVC   DOUBLE(4),PPC$FOI          Get Instruction
         MVC   DOUBLE+1(1),TPF_FLAG-TPF(R2)    Set flag
         MVC   DOUBLE+2(2),TPF_OFFSET-TPF(R2) Get offset
         OI    DOUBLE+2,X'D0'             Register 13/DSA
*The next few instructions can be uncommented and run for debugging
*MVC WTOMSG+8+10(8),TPF_NAME-TPF(R2)
*UNPK WTOMSG+8+19(9),DOUBLE(5)
*MVZ  WTOMSG+8+19(8),ZEROS
*TR   WTOMSG+8+19(8),HEXTABLE
*MVI  WTOMSG+8+19+8,C'='
*WTOMSG WTO 'R$PDSANL: xxxxxxxx xxxxxxxx=Instruction'
         LA    R15,0                      Set up for EX
         EX    R15,DOUBLE                 Execute: OI field,flag
         LA    R14,1(R14)                 Increment after EX
         AR    R7,R14                     Bump past known length
         SR    R6,R14                     Subtract from total
         LTR   R6,R6                      Check out length
         BZ    PPC$X                      Zero, leave
         BM    PPC$X                      Zero, leave
PPC$FLDL EQU   *
         CLI   0(R7),C' '                 Valid Delimiter?
         BE    PPC$DLMS
         CLI   0(R7),C','                 Valid Delimiter?
         BE    PPC$DLMS
         LA    R7,1(R7)                   Bump past extra byte
         BCT   R6,PPC$FLDL                Process next one
         B     PPC$X                      End of the Parameter string
PPC$FX   EQU   *
*
** Volume prefix
*
PPC$VOLP EQU   *
         CLC   0(7,R7),=C'VOLUME='
         BNE   PPC$VOLPX
         LA    R7,7(R7)                   Bump past "VOLUME="
         SH    R6,=H'7'                   Decrement for length
         LTR   R6,R6                      Check out length
         BZ    PPC$OERR                   Zero, leave
         LA    R1,PPC_VPREFIX             Locate output
         MVI   0(R1),C' '
         MVC   1(L'PPC_VPREFIX-1,R1),0(R1)
         LA    R14,8                      Set max
         SLR   R15,R15                    Set count
PPC$VOLPL EQU  *
         MVC   0(1,R1),0(R7)              Move input byte
         LA    R7,1(R7)                   Bump to next input byte
         LA    R1,1(R1)                   Bump to next output byte
         LA    R15,1(R15)                 Increment count
         BCTR  R14,0                      Decrement max count
         LTR   R14,R14                    Check for overflow...
         BZ    PPC$VOLPLX                 Yes, continue
         CLI   0(R7),C','                 Found delimiter?
         BE    PPC$VOLPLX                 Yes, leave
         BCT   R6,PPC$VOLPL               Process next byte
PPC$VOLPLX EQU *
         BCTR  R15,0                      Decrement for later
**
         LA    R14,PPC_VPREFIX            Locate start of VOLPname
         AR    R14,R15                    Locate last character
         CLI   0(R14),C'*'                Generic?
         BE    PPC$VOLPG                  Yes, continue
         CLI   0(R14),C'/'                Generic?
         BNE   PPC$VOLPGX                 No, continue
PPC$VOLPG EQU  *
         BCTR  R15,0                      Decrement for generic byte
         MVI   0(R14),C' '                Not so fast, Louie
PPC$VOLPGX EQU *
**
         STC   R15,PPC_VPREFIXL           Save count
         BCTR  R6,0                       Decrement count
         LTR   R6,R6                      Check count
         BZ    PPC$END                    Zero, at end of parameter
         BM    PPC$END                    Zero, at end of parameter
         B     PPC$DLM                    Process next option
PPC$VOLPX EQU  *
*
** Parameter in error: isolate it, note position and continue
*
PPC$OERR EQU   *
         SLR   R1,R1                      CLEAR OUT REGISTER
         ICM   R1,B'0011',PPC_COL         GET PREVIOUS PARM ERR COLUMN
         BNZ   PPC$GNUM                   YES, GO INCREMENT NUMBER
         EREG  R1,R1                      GET ADDR OF ADDR OF PARM
         L     R1,0(R1)                   NOW GET ADDRESS OF PARM
         LH    R1,0(R1)                   GET LENGTH OF PARM
         SR    R1,R6                      SUBTRACT FROM CURRENT LOC
         LA    R1,1(R1)                   Make offset from 1 not zero
         STH   R1,PPC_COL                 SAVE LOCATION OF ERROR
PPC$GNUM EQU   *
         LH    R1,PPC_NUM                 GET NUMBER OF ERRORS IN PARM
         LA    R1,1(R1)                   INCREMENT BY 1
         STH   R1,PPC_NUM                 SAVE FOR LATER
PPC$RR   EQU   *
         CLI   0(R7),C','                 HIT A COMMA YET?
         BE    PPC$BRK                    YES, LEAVE
         LA    R7,1(R7)                   BUMP TO NEXT BYTE
         BCT   R6,PPC$RR                  TEST IT OUT
         B     PPC$END                    END OF PARMS...
PPC$BRK  EQU   *
         LA    R7,1(R7)                   BUMP PAST COMMA
         LTR   R6,R6                      TEST FOR ZERO LENGTH
         BZ    PPC$END                    YES, END RIGTH NOW
         BCT   R6,PPC$DLMX                NO, Let's test some more
*
** End of parameters found
*
PPC$END  EQU   *
*
** Common Exit from Parse_Parameter_Card
*
PPC$X    EQU   *
         L     R9,PPC_RA                  Get return address
         BSM   0,R9                       Return to caller
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**       Constants                                                   **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
         LTORG ,                          Literals
*
** Parse flags (mapped by TPF DSECT)
*
T_PFLAGS EQU   *
         DC   AL1($PPC_F1VERB,4-1),CL8'VERBOSE ',AL2(PPC_FLAG1-DSA)
         DC    AL1($PPC_F1PSM,6-1),CL8'PRTSORTM',AL2(PPC_FLAG1-DSA)
         DC    AL1($PPC_F1PSM,3-1),CL8'PSM     ',AL2(PPC_FLAG1-DSA)
         DC    AL1($PPC_F1PSM,3-1),CL8'PRTSMSG ',AL2(PPC_FLAG1-DSA)
         DC   AL1($PPC_F1RUCB,6-1),CL8'RPTBYUCB',AL2(PPC_FLAG1-DSA)
         DC  AL1($PPC_F1RBOTH,5-1),CL8'RPTBOTH ',AL2(PPC_FLAG1-DSA)
         DC  AL1($PPC_F1SMSMC,5-1),CL8'SMSMCHK ',AL2(PPC_FLAG1-DSA)
         DC   AL1($PPC_F1CATC,4-1),CL8'CATCHK  ',AL2(PPC_FLAG1-DSA)
         DC   AL1($PPC_F1RDSN,6-1),CL8'RPTBYDSN',AL2(PPC_FLAG1-DSA)
         DC  AL1($PPC_F2DEBUG,5-1),CL8'DEBUG   ',AL2(PPC_FLAG2-DSA)
         DC  AL1($PPC_F2NAUTH,6-1),CL8'NOAUTH  ',AL2(PPC_FLAG2-DSA)
         DC  AL1($PPC_F2NAUTH,5-1),CL8'NAUTH   ',AL2(PPC_FLAG2-DSA)
         DC  AL1($PPC_F2CVTUS,5-1),CL8'CVTUCBSC',AL2(PPC_FLAG2-DSA)
         DC    AL1($PPC_F2ORU,8-1),CL8'ONLYRECU',AL2(PPC_FLAG2-DSA)
         DC    AL1($PPC_F2OLL,8-1),CL8'ONLYLLIB',AL2(PPC_FLAG2-DSA)
         DC     AL1($PPC_F2DO,8-1),CL8'DATAONLY',AL2(PPC_FLAG2-DSA)
         DC   AL1($PPC_F2HELP,4-1),CL8'HELP    ',AL2(PPC_FLAG2-DSA)
         DC  AL1($PPC_F2NOPIC,4-1),CL8'NOPIC   ',AL2(PPC_FLAG2-DSA)
         DC  AL1($PPC_F3NSYSP,4-1),CL8'NOSYSP  ',AL2(PPC_FLAG3-DSA)
T_PFLAGSN EQU   (*-T_PFLAGS)/TPFL
         DS    0D                         End CSECT on double word
*
** Calculate length of module
*
#DRU$PPC EQU   *-DRU$PPC
#DRU$PPC_LEFT EQU 4096-#DRU$PPC
         DROP  R8                         Drop base of DRU$PPC
*
** T_PFLAG mapping
*
TPF           DSECT ,
TPF_FLAG      DS    X                     Flag value
TPF_NAMEL     DS    X                     Name length
TPF_NAME      DS    CL8                   Name value
TPF_OFFSET    DS    XL2                   Offset to field in DSA
TPFL          EQU   *-TPF
         DROP  R13,R12,R11,R10
         EJECT ,
***********************************************************************
***                                                                 ***
**       ESTAE routine - Handle ABENDs while processing              **
**                                                                   **
**              \\//////      ________________                       **
**              \\    |      /                \                      **
**              \(_  x|     /  Bloooeeahhh!!! |                      **
**              \    __)  _/__________________/                      **
**            __/   _\ ,. .                                          **
**           /     /  .%:. * .                                       **
**          |  |   |   . ;>, $  '                                    **
**          |  |   |    .=.~@ .  &                                   **
**          UUUU---|   :?. ;. .Â¬#  .   Â¬                             **
**          |      |    < * '   .   ,  *                             **
***                                                                 ***
***********************************************************************
         SPACE 2
         PRINT GEN
DRU$ESTA CSECT ,
DRU$ESTA AMODE 31
DRU$ESTA RMODE ANY
*
** Standard O/S eyecatcher
*
EST_EC   B     EST_ECL(0,R15)           Bump past EyeCatcher
         DC    AL1(EST_ECE-EST_ECV)     Length of Eyecatcher
EST_ECV  DC    C'DRU$ESTA -- ESTAE routine'
EST_ECE  EQU   *
         DS    0H
EST_ECL  EQU   *-EST_EC
*
** Standard ESA entry housekeeping
*
         BAKR  R14,0                    Save regs
         LAE   R12,0(R15,0)             Get base register
         USING DRU$ESTA,R12             Get addressibility
         SAC   0
         SYSSTATE ASCENV=P
*
** Register input parameters
** R0 - Code:
**      - 0  ... Active I/O has be Quiesced and is restorable
**      - 4  ... Active I/O has been halted and is not restorable
**      - 8  ... No active I/O at ABEND Time
**      - 12 ... an SDWA was not obtained
**      - 16 ... No I/O processing was performed
** R1 - IF R0 Â¬= 12 THEN it has SDWA ELSE ABEND code
*
         CH    R0,=H'12'                  SDWA present?
         BE    RSE$X                      No, just leave
         LR    R2,R1                      Save SDWA address
*
** Perform retry if possible
*
         L     R4,SDWAPARM-SDWA(R2)       Locate RSEP
         SLR   R3,R3                      Clear register
         ICM   R3,B'0011',RSEP_RETRYO-RSEP(R4) Get retry address
         BZ    RSE$X                      Not there, give up
         A     R3,RSEP_R12-RSEP(R4)       Locate to routine
         MVC   SDWASR12-SDWA(4,R2),RSEP_R12-RSEP(R4)
         MVC   SDWASR11-SDWA(4,R2),RSEP_R11-RSEP(R4)
         MVC   SDWASR10-SDWA(4,R2),RSEP_R10-RSEP(R4)
*
         L     R1,=V(DRU$CON1)
         MVC   RSEP_WTO-RSEP(C_WTOL,R4),C_WTO-DRU$CON1(R1)
         LA    R15,RSEP_WTO+4-RSEP(R4)
         MVC   0(MSG26L,R15),MSG26-DRU$CON1(R1)
         MVC   MSG26UCB-MSG26(4,R15),RSEP_UCB-RSEP(R4)
         MVC   MSG26VOL-MSG26(6,R15),RSEP_VOL-RSEP(R4)
         MVC   MSG26ID-MSG26(8,R15),RSEP_FUNC-RSEP(R4)
         LA    R1,RSEP_WTO-RSEP(R4)
         WTO   ,MF=(E,(1))                Issue WTO
*
         SETRP WKAREA=(2),                Set Return Parameters        @
               RETADDR=(3),               ..Return Address             @
               RETREGS=YES,               ..Reset regs using SDWASRSV  @
               RC=4                       ..Retry using RETADDR
*
** Return to RTM emtpy handed - No recovery is being attempted
*
RSE$X    DS    0H
         PR    ,                          ESA exit housekeeping instr.
*
** Constants
*
         LTORG ,                          Literals
         DS    0D                         End CSECT on double word
         DROP  R12
         EJECT
***********************************************************************
***
**   Print Report Record
***
***********************************************************************
         SPACE 2
DRU$PRR  CSECT ,
DRU$PRR  AMODE 24
DRU$PRR  RMODE 24
*
** Standard O/S eyecatcher
*
PRR_EC   B    PRR_ECL(0,R15)              Bump past EyeCatcher
         DC   AL1(L'PRR_ECV)              Length of eyecatcher
PRR_ECV  DC   C'DRU$PRR  -- Print Report Record'
         DS   0H
PRR_ECL  EQU  *-PRR_EC
*
         BAKR  R14,0                      Save registers
         LAE   R12,0(R15,0)               Get base register
         USING DRU$PRR,R12                Set module base
         SAC   0
         SYSSTATE ASCENV=P
         EREG  R0,R1                      Restore Registers 0 and 1
         LR    R13,R0                     Save input RSA
         LR    R10,R1                     Save input record address
         USING PRRRSA,R13
*
** Checking
*
         TM    PPC_FLAG2,$PPC_F2DO        Dataonly?
         BO    PRR$HP                     Yes, skip heading lines
PRR$VRCX DS    0H
         CLI   PRR_LC,47
         BNH   PRR$HX
*-Need a new heading, update the time and date
         L     R1,=V(DRU$CON1)
         MVC   W_ODJUL8(C_ODJUL8L),C_ODJUL8-DRU$CON1(R1)
         MVC   W_ODDOW9(C_ODDOW9L),C_ODDOW9-DRU$CON1(R1)
         MVC   W_ODGEUR11(C_ODGEUR11L),C_ODGEUR11-DRU$CON1(R1)
         MVC   W_OTIMES8(C_OTIMES8L),C_OTIMES8-DRU$CON1(R1)
         DA#SMODE 31
         ICM   R15,B'1111',EP_DA$DATE
         CALL  (15),                                                   @
               (W_ODGEUR11,W_OTIMES8,W_ODJUL8,W_ODDOW9),               @
               VL,MF=(E,PARMLIST)
         DA#SMODE 31
*-Format the report heading
*
         BAS   R14,PRR$CLEAR_HEADREC
         MVI   0(R15),C'1'
         LA    R15,HEADREC+(133/2)        Locate middle of record
         L     R1,PRR_TITLE               Get title
         SLR   R14,R14                    Clear register
         IC    R14,0(R1)                  Get centering
         SR    R15,R14                    Backup to center this guy
         SLR   R14,R14                    Clear register
         IC    R14,1(R1)                  Get length of string
         EX    R14,PRR$MOVE               Move string to record
         PUT   REPORT,HEADREC
*
         BAS   R14,PRR$CLEAR_HEADREC
         MVI   0(R15),C'0'
         LA    R15,HEADREC+(133/2)        Locate middle of record
         ICM   R1,B'1111',PRR_STITLE      Get subtitle
         BZ    PRR$STX
         SLR   R14,R14                    Clear register
         IC    R14,0(R1)                  Get centering
         SR    R15,R14                    Backup to center this guy
         SLR   R14,R14                    Clear register
         IC    R14,1(R1)                  Get length of string
         EX    R14,PRR$MOVE               Move string to record
         PUT   REPORT,HEADREC
PRR$STX  EQU   *
*
         BAS   R14,PRR$CLEAR_HEADREC
         MVI   0(R15),C'0'
         MVC   1(8,R15),=CL8'DA$DISKR'    Get program name
         MVC   1+8+1(6,R15),C_SYSID-DRU$CON1(R1)
         L     R14,CVTPTR                 ->  CVT
         MVC   1+8+1+6+1(L'CVTSNAME,R15),CVTSNAME-CVTMAP(R14)
         MVC   125(4,R15),=CL4'Page'      Insert text
         L     R1,PRR_PC                  GET PAGE COUNT
         LA    R1,1(R1)                   INCREMENT
         ST    R1,PRR_PC                  SAVE IT
         CVD   R1,DOUBLE                  CONVERT TO PACKED DEC
         MVC   129(4,R15),=X'40,20,20,20' GET EDIT PATTERN
         ED    129(4,R15),DOUBLE+6        EDIT TO ZONED
         PUT   REPORT,HEADREC
*
         BAS   R14,PRR$CLEAR_HEADREC
         MVC   1(11,R15),W_ODGEUR11_STR
*        MVC   1+11+1(9,R15),W_ODDOW9_STR
         MVC   116(8,R15),W_ODJUL8_STR
         MVC   125(8,R15),W_OTIMES8_STR
         PUT   REPORT,HEADREC
*
         BAS   R14,PRR$CLEAR_HEADREC
         PUT   REPORT,HEADREC
         PUT   REPORT,W_RH2
         PUT   REPORT,W_RH3
         PUT   REPORT,W_RH4
         MVI   PRR_LC,0
PRR$HX   EQU   *
         SLR   R1,R1
         IC    R1,PRR_LC                  Get line count
         BAS   R14,PRR$INC_LC             Increment line count
         STC   R1,PRR_LC                  Save line count
PRR$HP   EQU   *
         PUT   REPORT,RECOUT              Print record
*
** Exit
*
         SLR   R15,R15
         PR    ,                          Return to caller
*
PRR$MOVE MVC   0(0,R15),2(R1)             ** Executed **
*
** Increment line count
*
PRR$INC_LC EQU *
         CLI   0(R10),C'+'
         BE    PRR$ILCX
         CLI   0(R10),C'-'
         BE    PRR$ILC3
         CLI   0(R10),C'0'
         BE    PRR$ILC2
         B     PRR$ILC1
PRR$ILC3 EQU   *
         LA    R1,1(R1)
PRR$ILC2 EQU   *
         LA    R1,1(R1)
PRR$ILC1 EQU   *
         LA    R1,1(R1)
PRR$ILCX EQU   *
         BSM   0,R14
*
** Clear heading record to blanks
*
PRR$CLEAR_HEADREC EQU *
         LA    R15,HEADREC                Locate output record
         MVI   0(R15),C' '                Get Blank
         MVC   1(L'HEADREC-1,R15),0(R15) ..Propagate it
         L     R1,=V(DRU$CON1)            -> Constants CSECTs
         BSM   0,R14                      Return to caller
*
** Literals and end of DRU$PRR routine
*
         LTORG ,                          Literals in DRU$PRR
         DS    0D                         End of DRU$PRR
         DROP  R12
         DROP  R13
         EJECT
***********************************************************************
***
**   Print SYSPRINT Record
***
***********************************************************************
         SPACE 2
DRU$PSR  CSECT ,
DRU$PSR  AMODE 24
DRU$PSR  RMODE 24
*
** Standard O/S eyecatcher
*
PSR_EC   B    PSR_ECL(0,R15)              Bump past EyeCatcher
         DC   AL1(L'PSR_ECV)              Length of eyecatcher
PSR_ECV  DC   C'DRU$PSR  -- Print SYSPRINT Record'
         DS   0H
PSR_ECL  EQU  *-PSR_EC
*
         BAKR  R14,0                      Save registers
         LAE   R12,0(R15,0)               Get base register
         USING DRU$PSR,R12                Set module base
         SAC   0
         SYSSTATE ASCENV=P
         EREG  R0,R1                      Restore Registers 0 and 1
         LR    R13,R0                     Save input RSA
         LR    R10,R1                     Save input record address
         USING PSRRSA,R13
*
** Heading needed?
*
         CLI   PSR_LC,50
         BNH   PSR$HX
*-Need a new heading, update the time and date
         L     R1,=V(DRU$CON1)
         MVC   W_ODJUL8(C_ODJUL8L),C_ODJUL8-DRU$CON1(R1)
         MVC   W_ODDOW9(C_ODDOW9L),C_ODDOW9-DRU$CON1(R1)
         MVC   W_ODGEUR11(C_ODGEUR11L),C_ODGEUR11-DRU$CON1(R1)
         MVC   W_OTIMES8(C_OTIMES8L),C_OTIMES8-DRU$CON1(R1)
         DA#SMODE 31
         ICM   R15,B'1111',EP_DA$DATE
         CALL  (15),                                                   @
               (W_ODGEUR11,W_OTIMES8,W_ODJUL8,W_ODDOW9),               @
               VL,MF=(E,PARMLIST)
         DA#SMODE 31
*-Format the report heading
         BAS   R14,PSR$CLEAR_HEADREC
         MVI   0(R15),C'1'
         MVC   59(L'C_MSGS,R15),C_MSGS-DRU$CON1(R1)
         PUT   SYSPRINT,HEADREC
*
         BAS   R14,PSR$CLEAR_HEADREC
         MVI   0(R15),C'0'
         MVC   1(8,R15),=CL8'DA$DISKR'    Get program name
         MVC   1+8+1(6,R15),C_SYSID-DRU$CON1(R1)
         L     R14,CVTPTR                 ->  CVT
         MVC   1+8+1+6+1(L'CVTSNAME,R15),CVTSNAME-CVTMAP(R14)
         MVC   125(4,R15),=CL4'Page'      Insert text
         L     R1,PSR_PC                  GET PAGE COUNT
         LA    R1,1(R1)                   INCREMENT
         ST    R1,PSR_PC                  SAVE IT
         CVD   R1,DOUBLE                  CONVERT TO PACKED DEC
         MVC   129(4,R15),=X'40,20,20,20' GET EDIT PATTERN
         ED    129(4,R15),DOUBLE+6        EDIT TO ZONED
         PUT   SYSPRINT,HEADREC
*
         BAS   R14,PSR$CLEAR_HEADREC
         MVC   1(11,R15),W_ODGEUR11_STR
*        MVC   1+11+1(9,R15),W_ODDOW9_STR
         MVC   116(8,R15),W_ODJUL8_STR
         MVC   125(8,R15),W_OTIMES8_STR
         PUT   SYSPRINT,HEADREC
*
         BAS   R14,PSR$CLEAR_HEADREC
         PUT   SYSPRINT,HEADREC
         MVI   PSR_LC,0
PSR$HX   EQU   *
*-Print the detail line
         SLR   R1,R1
         IC    R1,PSR_LC                  Get line count
         BAS   R14,PSR$INC_LC             Increment line count
         STC   R1,PSR_LC                  Save line count
         PUT   SYSPRINT,RECOUT            Print record
*
** Exit
*
         SLR   R15,R15
         PR    ,                          Return to caller
*
** Increment line count
*
PSR$INC_LC EQU *
         CLI   0(R10),C'+'
         BE    PSR$ILCX
         CLI   0(R10),C'-'
         BE    PSR$ILC3
         CLI   0(R10),C'0'
         BE    PSR$ILC2
         B     PSR$ILC1
PSR$ILC3 EQU   *
         LA    R1,1(R1)
PSR$ILC2 EQU   *
         LA    R1,1(R1)
PSR$ILC1 EQU   *
         LA    R1,1(R1)
PSR$ILCX EQU   *
         BSM   0,R14
*
** Clear heading record to blanks
*
PSR$CLEAR_HEADREC EQU *
         LA    R15,HEADREC                Locate output record
         MVI   0(R15),C' '                Get Blank
         MVC   1(L'HEADREC-1,R15),0(R15) ..Propagate it
         L     R1,=V(DRU$CON1)            -> Constants CSECTs
         BSM   0,R14                      Return to caller
*
** Literals and end of DRU$PSR routine
*
         LTORG ,                          Literals in DRU$PSR
         DS    0D                         End of DRU$PSR
         DROP  R12
         DROP  R13
         EJECT
***********************************************************************
***
**   Print System Profile at beginning of //REPORT
**
**-------------------------  System Profile  -------------------------*
*|                                                                    |
*|  O/S----------------MVS SP4.3.0    FMID-------------------JBBxxxx  |
*|  O/S------------OS/390_01.02.00    FMID-------------------JBB6602  |
*|  DF/SMS-------------------1.3.0    DFP----------------------3.3.2  |
*|  System Name---------------XYZ1    SMF ID--------------------XYZ1  |
*|                                                                    |
**--------------------------------------------------------------------*
***
***********************************************************************
         SPACE 2
*
** "System Profile" equates
*
@START   EQU   32                         ..STARTING LOCATION ON LINE
@TEXT1   EQU   @START+3                   ..TEXT LOCATION 1
@VALUE1E EQU   @START+33                  ..VALUE LOCATION END 1
@TEXT2   EQU   @START+37                  ..TEXT LOCATION 2
@VALUE2E EQU   @START+67                  ..VALUE LOCATION END 2
*
** Start of CSECT
*
DRU$SYSP CSECT ,
DRU$SYSP AMODE 24
DRU$SYSP RMODE 24
*
** Standard O/S eyecatcher
*
SYSP_EC  B    SYSP_ECL(0,R15)             Bump past EyeCatcher
         DC   AL1(L'SYSP_ECV)             Length of eyecatcher
SYSP_ECV DC   C'DRU$SYSP -- Print System Profile'
         DS   0H
SYSP_ECL EQU  *-SYSP_EC
*
         BAKR  R14,0                      Save registers
         LAE   R12,0(R15,0)               Get base register
         USING DRU$SYSP,R12               Set module base
         SAC   0
         SYSSTATE ASCENV=P
         EREG  R0,R1                      Restore Registers 0 and 1
         LR    R13,R0                     Save input RSA
         LR    R10,R1                     Save input record address
         USING SUBRSA,R13
*
** Print "DASD CONFIG" in big letters
*
         LA    R1,W_RH2
         MVI   0(R1),C' '
         MVI   1(R1),C'*'
         MVC   2(132-1,R1),1(R1)
         LA    R1,W_RH3
         MVI   0(R1),C' '
         MVC   1(133-1,R1),0(R1)
         LA    R1,W_RH4
         MVI   0(R1),C' '
         MVC   1(133-1,R1),0(R1)
         BAS   R14,SYSP$CLEAR_RECOUT      CLEAR RECOUT
         BAS   R14,SYSP$PRR               Print record on file=REPORT
*
         L     R14,=V(DRU$CON1)
         LA    R1,C_BLDC1-DRU$CON1(R14)    Locate string
         LA    R0,BLETRSA
         L     R15,=V(DRU$BLET)
         BASR  R14,R15
*
         BAS   R14,SYSP$CLEAR_RECOUT      CLEAR RECOUT
         BAS   R14,SYSP$PRR               Print record on file=REPORT
         BAS   R14,SYSP$PRR               Print record on file=REPORT
*
         L     R14,=V(DRU$CON1)
         LA    R1,C_BLDC2-DRU$CON1(R14)    Locate string
         LA    R0,BLETRSA
         L     R15,=V(DRU$BLET)
         BASR  R14,R15
*
         BAS   R14,SYSP$CLEAR_RECOUT      Clear recout to blanks
         BAS   R14,SYSP$PRR               Print record on file=REPORT
         MVI   RECOUT,C'*'                Get star
         MVC   RECOUT+1(132),RECOUT       ..Propagate it
         MVI   RECOUT,C' '                Set FBA byte
         BAS   R14,SYSP$PRR               Print record on file=REPORT
*
** Skip a couple of lines
*
         BAS   R14,SYSP$CLEAR_RECOUT      Clear recout
         MVI   RECOUT,C'0'                Skip a couple of lines
         BAS   R14,SYSP$PRR               Print record on file=REPORT
*
** PRINT " *-------------  System Profile  --------------*"
*
         BAS   R14,SYSP$CLEAR_RECOUT      Clear recout to blanks
         MVI   RECOUT,C'-'                FBA: skip 3 lines
         LA    R15,RECOUT+@START          LOCATE PAST FBA BYTE
         MVC   0(2,R15),=C'*-'            CORNER
         LA    R15,1(R15)                 BUMP PAST IT
         MVC   1(24,R15),0(R15)           PROPAGATE DASH
         LA    R15,25+2(R15)              BUMP PAST DASHES
         MVC   0(14,R15),=C'System Profile' BOX TITLE
         LA    R15,14+2(R15)              BUMP PAST BOX TITLE
         MVI   0(R15),C'-'                GET DASH
         MVC   1(24,R15),0(R15)           PROPAGATE DASHES
         LA    R15,25(R15)                BUMP PAST DASHES
         MVI   0(R15),C'*'                RIGHT CORNER
         BAS   R14,SYSP$PRR               Print record on file=REPORT
*
** PRINT " |                                             |"
*
         BAS   R14,SYSP$CLEAR_RECOUT      CLEAR RECOUT TO BLANKS
         LA    R15,RECOUT+@START          LOCATE AT STARTING LOCATION
         MVI   0(R15),C'|'                LEFT
         MVI   69(R15),C'|'               RIGHT
         BAS   R14,SYSP$PRR               Print record on file=REPORT
*
** PRINT " |  O/S----MVS SPx.x.x   FMID--------JBB2125 |"
** PRINT " |  O/S-OS/390 01.02.00  FMID--------JBBxxxx |"
*
         BAS   R9,SYSP$IREC               INITIALIZE LINE
         MVC   RECOUT+@TEXT1(3),=C'O/S'
         MVC   RECOUT+@TEXT2(4),=C'FMID'
*
         L     R1,CVTPTR                -> CVT
         TM    CVTDCB-CVTMAP(R1),CVTOSEXT CVTOSLVL okay?
         BNO   SYSP$MVS                 No, ancient system!
         AIF   (NOT D'CVTOS390).SYSPO31 Have OS/390 stuff?
         TM    CVTOSLV1-CVTMAP(R1),CVTOS390 OS/390?
         BO    SYSP$OS390               Yes, format name and release
.SYSPO31 ANOP  ,
SYSP$MVS DS    0H
         LA    R0,CVTLEVL-CVTPROD+L'CVTLEVL Offset back to product lvl
         SR    R1,R0                    Locate product level
         LA    R2,PARMLIST
         MVC   0(4,R2),=C'MVS '
         MVC   4(8,R2),CVTPRODN-CVTPROD(R1)  Get "SPx.x.x "
         LA    R3,4+8                   Length of "MVS SPx.x.x "
         B     SYSP$OS390X
SYSP$OS390 DS  0H
         AIF   (NOT D'CVTOS390).SYSPO32 Have OS/390 stuff?
         DA#SMODE 31                    The ECVT is above the line
         L     R1,CVTPTR                -> CVT
         L     R1,CVTECVT-CVTMAP(R1)    -> ECVT
         LA    R15,PARMLIST
         MVC   0(L'ECVTPNAM,R15),ECVTPNAM-ECVT(R1)
         LA    R0,L'ECVTPNAM
         BAS   R14,SYSP$LOCATE_FIRST_SPACE
         MVI   0(R15),C'_'
         LA    R15,1(R15)
         MVC   0(2,R15),ECVTPVER-ECVT(R1) Get Version
         MVI   2(R15),C'.'
         MVC   3(2,R15),ECVTPREL-ECVT(R1) Get Release
         MVI   5(R15),C'.'
         MVC   6(2,R15),ECVTPMOD-ECVT(R1) Get Modification
         LA    R15,8(R15)                 bump past "01.02.00"
         LA    R2,PARMLIST                Locate start of "name v.r.m"
         LR    R3,R15                     Locate end of v.r.m
         SR    R3,R2                      Length = end - start
         DA#SMODE 24                    Get back, joe!
.SYSPO32 ANOP  ,
SYSP$OS390X DS 0H
*-At this point R2="name level" and R3 has the length
         LA    R15,RECOUT+@VALUE1E        LOCATE END OF VALUE ONE
         SR    R15,R3                     BACKUP TO STRING START
         BAS   R9,SYSP$RITEJUST           RIGHT JUSTIFY STRING
*
         LA    R15,RECOUT+@VALUE2E        LOCATE END OF VALUE ONE
         L     R1,CVTPTR
         LA    R0,CVTLEVL-CVTPROD+L'CVTLEVL Offset back to product lvl
         SR    R1,R0                    Locate product level
         LA    R3,L'CVTPRODI              GET LENGTH OF STRING
         SR    R15,R3                     BACKUP TO STRING START
         LA    R2,CVTPRODI-CVTPROD(R1)    ADDRESS OF STRING
         BAS   R9,SYSP$RITEJUST           RIGHT JUSTIFY STRING
         BAS   R14,SYSP$PRR               Print record on file=REPORT
*
** PRINT " |  DF/SMS----------1.3.0  DFP-----------3.3.2 |"
*
         BAS   R9,SYSP$IREC               INITIALIZE LINE
         MVC   RECOUT+@TEXT1(6),=C'DF/SMS'
         MVC   RECOUT+@TEXT2(3),=C'DFP'
*
         LA    R2,G_DFSMSLVL              Locate DF/SMS level
         LA    R15,RECOUT+@VALUE1E        LOCATE END OF VALUE ONE
         LA    R3,L'G_DFSMSLVL            GET LENGTH OF STRING
         SR    R15,R3                     BACKUP TO STRING START
         BAS   R9,SYSP$RITEJUST           RIGHT JUSTIFY STRING
*
         LA    R15,RECOUT+@VALUE2E        LOCATE END OF VALUE ONE
         LA    R3,L'G_DFPLVL              GET LENGTH OF STRING
         SR    R15,R3                     BACKUP TO STRING START
         LA    R2,G_DFPLVL                Locate DFP level
         BAS   R9,SYSP$RITEJUST           RIGHT JUSTIFY STRING
         BAS   R14,SYSP$PRR               Print record on file=REPORT
*
** PRINT " |  System Name--DavesBox  SMF ID---------DAVE |"
*
         BAS   R9,SYSP$IREC               INITIALIZE LINE
         MVC   RECOUT+@TEXT1(11),=C'System Name'
         MVC   RECOUT+@TEXT2(6),=C'SMF ID'
*
         L     R2,CVTPTR                  -> CVT
         LA    R2,CVTSNAME-CVTMAP(R2)     Locate System Name
         LA    R15,RECOUT+@VALUE1E        LOCATE END OF VALUE ONE
         LA    R3,L'CVTSNAME              GET LENGTH OF STRING
         SR    R15,R3                     BACKUP TO STRING START
         BAS   R9,SYSP$RITEJUST           RIGHT JUSTIFY STRING
*
         LA    R15,RECOUT+@VALUE2E        LOCATE END OF VALUE ONE
         LA    R3,L'SMCASID               GET LENGTH OF STRING
         SR    R15,R3                     BACKUP TO STRING START
         L     R2,CVTPTR                  -> CVT
         L     R2,CVTSMCA-CVTMAP(R2)      -> SMCA
         LA    R2,SMCASID-SMCABASE(R2)    Locate System ID
         BAS   R9,SYSP$RITEJUST           RIGHT JUSTIFY STRING
         BAS   R14,SYSP$PRR               Print record on file=REPORT
*
** PRINT " |                                             |"
*
         BAS   R14,SYSP$CLEAR_RECOUT      CLEAR RECOUT TO BLANKS
         LA    R15,RECOUT+@START          LOCATE AT STARTING LOCATION
         MVI   0(R15),C'|'                LEFT
         MVI   69(R15),C'|'               RIGHT
         BAS   R14,SYSP$PRR               Print record on file=REPORT
*
** PRINT " *---------------------------------------------*"
*
         BAS   R14,SYSP$CLEAR_RECOUT      CLEAR RECOUT TO BLANKS
         LA    R15,RECOUT+@START          LOCATE STARTING LOCATION
         MVC   0(2,R15),=C'*-'            LEFT CORNER
         LA    R15,1(R15)                 BUMP PAST STAR
         MVC   1(67,R15),0(R15)           PROPAGATE DASH
         LA    R15,68(R15)                BUMP PAST DASHES
         MVI   0(R15),C'*'                RIGHT CORNER
         BAS   R14,SYSP$PRR               Print record on file=REPORT
*
** Exit
*
         SLR   R15,R15
         PR    ,                          Return to caller
*
** Print SYSPRINT Record
*
SYSP$PRR DS    0H
         ST    R14,PRR_RA                 Save return address
         LA    R0,PRRRSA                  Locate work area
         LA    R1,RECOUT                  Locate record to print
         L     R15,=V(DRU$PRR)            Locate sysprint routine
         BASR  R14,R15                    Print Sysprint Record
         L     R14,PRR_RA                 Get return address
         BSM   0,R14                      Return to caller
*
** Clear output record to blanks
*
SYSP$CLEAR_RECOUT  DS 0H
         LA    R15,RECOUT                 Locate output record
         MVI   0(R15),C' '                Get Blank
         MVC   1(133-1,R15),0(R15)        ..Propagate it
         BSM   0,R14                      Return to caller
*
** RIGHT JUSTIFY A STRING
** INPUT: R15 ADDRESS TO PUT STRING
**        R2  ADDRESS OF STRING
**        R3  LENGTH OF STRING
** OUTPUT: STRING WILL BE RIGHT JUSTIFIED AT ADDRESS OF R15
*
SYSP$RITEJUST DS 0H
         SLR   R0,R0                      CLEAR COUNTER
         LR    R1,R3                      GET LENGTH TO WORK REG
         LR    R14,R2                     GET ADDRESS TO WORK REG
SYSP$RJ$CSL DS 0H
         CLI   0(R14),C' '                SPACE?
         BNE   SYSP$RJ$CSB                NO, MOVE ON
         AH    R0,=H'1'                   INCREMENT COUNTER
SYSP$RJ$CSB DS 0H
         LA    R14,1(R14)                 BUMP TO NEXT BYTE
         BCT   R1,SYSP$RJ$CSL             ..DO IT
         LR    R1,R0                      GET NUM OF BLANKS
         LA    R14,0(R1,R15)              PLACE TO PUT STRING
         LR    R1,R3                      GET LENGTH
         SR    R1,R0                      NUMBER OF NON-BLANKS
         BCTR  R1,0                       DECREMENT FOR EX
         EX    R1,SYSP$RJ$CSM             RIGHT JUSTIFY STRING
         BSM   0,R9                       RETURN TO CALLER
SYSP$RJ$CSM MVC 0(0,R14),0(R2)            ** EXECUTED **
*
** Initialize System Profile record
*
SYSP$IREC DS 0H
         BAS   R14,SYSP$CLEAR_RECOUT      Clear recout to blanks
         LA    R15,RECOUT+@START          STARTING LOCATION ON LINE
         MVI   0(R15),C'|'                LEFT
         MVI   69(R15),C'|'                    RIGHT
         LA    R15,RECOUT+@TEXT1          BUMP TO TEXT LOCATION 1
         MVI   0(R15),C'-'                GET DASH
         MVC   1(29,R15),0(R15)           ..PROPAGATE IT
         LA    R15,RECOUT+@TEXT2          BUMP TO TEXT LOCATION 2
         MVI   0(R15),C'-'                GET DASH
         MVC   1(29,R15),0(R15)           ..PROPAGATE IT
         BSM   0,R9                       RETURN
*
** EDIT WITH DASH FILL FROM LEFT TO RIGHT (15 BYTES)
** INPUT:  R1 - VALUE TO EDIT
**         R15 - ADDRESS TO PUT PATTERN
*
SYSP$EDITD15 DS 0H
         CVD   R1,DOUBLE                  CONVERT TO PACKED
         MVC   0(15,R15),SYSP$EDITP15     GET EDIT PATTERN
         MVI   0(15),C'-'                 LEADING DASHES
         ED    0(15,R15),DOUBLE+2         EDIT
         LTR   R1,R1                      DID HE FIND ANYTHING TO EDIT?
         BNZ   SYSP$EDITD15X              YES, MOVE ON
         MVI   14(R15),C'0'               NO, LEAVE A ZERO
SYSP$EDITD15X DS 0H
         BSM   0,R9                       RETURN
SYSP$EDITP15 DC X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'
*
** POINT REGISTER 15 TO FIRST BLANK IN STRING
** INPUT:  R0  - MAXIMUM LENGTH OF STRING
**         R15 - STRING
** OUTPUT: R15 - FIRST SPACE IN STRING
*
SYSP$LOCATE_FIRST_SPACE DS 0H
         CLI   0(R15),C' '
         BE    SYSP$LFS$X
         LA    R15,1(R15)
         BCT   R0,SYSP$LOCATE_FIRST_SPACE
SYSP$LFS$X DS  0H
         BSM   0,R14
*
** Literals and end of DRU$SYSP routine
*
         LTORG ,                          Literals in DRU$SYSP
         DS    0D                         End of DRU$SYSP
         DROP  R12
         DROP  R13
         EJECT
***********************************************************************
***                                                                 ***
**        Print Big letters via IEFSD095                             **
**                                                                   **
**        Input: R1 points to a string                               **
***                                                                 ***
***********************************************************************
         SPACE 2
DRU$BLET CSECT ,
DRU$BLET AMODE 24
DRU$BLET RMODE 24
*
** Standard O/S eyecatcher
*
BLET_EC  B    BLET_ECL(0,R15)             Bump past EyeCatcher
         DC   AL1(L'BLET_ECV)             Length of eyecatcher
BLET_ECV DC   C'DRU$BLET -- Print Big Letters'
         DS   0H
BLET_ECL EQU  *-BLET_EC
*
         BAKR  R14,0                      Save registers
         LAE   R12,0(R15,0)               Get base register
         USING DRU$BLET,R12               Set module base
         SAC   0
         SYSSTATE ASCENV=P
         EREG  R0,R1                      Restore Registers 0 and 1
         LR    R13,R0                     Save input RSA
         LR    R8,R1                      Save input to print
         USING BLETRSA,R13
*
         ICM   R15,B'1111',=V(IEFSD095)
         BZ    BL$X
*
** Fix the string
*
         SLR   R1,R1                      Clear register
         IC    R1,0(R8)                   Get string length
         LA    R1,1(R1)                   Increment by 1
         XC    BL_LEN(3),BL_LEN           Fix first 3 bytes of fullword
         STC   R1,BL_LEN+3                Save length for IEFSD095
         LA    R8,1(R8)
*
** Print 'DASD LIST' in big slant letters
*
         LA    R1,1
         ST    R1,BL_LINEC              GET LINE COUNTER FOR LOOP INDEX
         LA    R1,RECOUT+12+5           OUTPUT LOC (5 CENTER, 12 SLANT)
         ST    R1,BL_ADDR               Save location
BL$LP    DS    0H
         BAS   R14,BL$CLEAR_RECOUT        Clear RECOUT to blanks
*
         L     R5,BL_ADDR
         L     R15,=V(IEFSD095)           Locate routine: IEFSD095
         CALL  (15),                             Call IEFSD095         @
               ((8),BL_LINEC,(5),BL_LEN),        ..Parameters          @
               VL,MF=(E,PARMLIST)                ..Parm list/VL
         BAS   R14,BL$PRR                 Print record on file=REPORT
*
         L     R1,BL_ADDR
         BCTR  R1,0                       Decrement for slant
         ST    R1,BL_ADDR
*
         L     R1,BL_LINEC
         LA    R1,1(R1)                   Increment line counter
         ST    R1,BL_LINEC
*
         CH    R1,=H'12'                  End of the line?
         BNH   BL$LP                      Nope, do next line
*
** Common exit from Big_Letter routine
*
BL$X     EQU   *
         PR    ,
*
** Print SYSPRINT Record
*
BL$PRR   DS    0H
         ST    R14,PRR_RA                 Save return address
         LA    R0,PRRRSA                  Locate work area
         LA    R1,RECOUT                  Locate record to print
         L     R15,=V(DRU$PRR)            Locate sysprint routine
         BASR  R14,R15                    Print Sysprint Record
         L     R14,PRR_RA                 Get return address
         BSM   0,R14                      Return to caller
*
** Clear output record to blanks
*
BL$CLEAR_RECOUT  DS 0H
         LA    R15,RECOUT                 Locate output record
         MVI   0(R15),C' '                Get Blank
         MVC   1(133-1,R15),0(R15)        ..Propagate it
         BSM   0,R14                      Return to caller
*
** Literals and end of DRU$BLET routine
*
         LTORG ,                          Literals in DRU$BLET
         DS    0D                         End of DRU$BLET
         DROP  R12
         DROP  R13
         EJECT ,
***********************************************************************
***
**       Help me - Help me - I've been hyp-mo-tized
**
** This routine prints the help information.  The Pascal-like
** strings make the bulk of the input.  There are a few attribute
** bytes which are used instead of a usual string length:
**
** - FF ... End of help information
** - FE ... Print a blank line
** - FD ... Print the translator table
** - FC ... Print the Linkage Editor/Binder Translator table
**
** Help information - We are trying to keep this information
** under 80 columns for good TSO viewing.  It is printed when this
** program is executed with PARM='HELP'.
***
***********************************************************************
         SPACE 2
DRU$HELP CSECT ,
DRU$HELP AMODE 24
DRU$HELP RMODE 24
*
** Standard O/S eyecatcher
*
HLP_EC   B    HLP_ECL(0,R15)            Bump past EyeCatcher
         DC   AL1(L'HLP_ECV)            Length of eyecatcher
HLP_ECV  DC   C'DRU$HELP -- Help Information'
         DS   0H
HLP_ECL  EQU  *-HLP_EC
*
** Entry Housekeeping
*
         BAKR  R14,0                    Save registers
         LAE   R12,0(R15,0)             Get base register
         USING DRU$HELP,R12             Set module base
         SAC   0
         SYSSTATE ASCENV=P
         EREG  R0,R1
         LR    R13,R0
         USING SUBRSA,R13                 Locate to data area
         SPACE 2
*
** Print initial messages
*
         BAS   R14,HELP$CLEAR_RECOUT      Clear record to blanks
         BAS   R14,HELP$PSR               Print the record
*
         BAS   R14,HELP$FORMAT_MESSAGE   Initialize the message area
         MVC   0(MSG62L,R15),MSG62-DRU$CON1(R1) Move in message
         BAS   R14,HELP$PSR               Print the record
*
** Loop thru help text
*
         LA    R3,HELPTEXT                Locate start of text
HELP$L   DS    0H
         BAS   R14,HELP$CLEAR_RECOUT      Clear record to blanks
*-Blank line
         CLI   0(R3),X'FE'                Blank line?
         BNE   HELP$LM                    No, continue
         BAS   R14,HELP$PSR               Print the record
         LA    R3,1(R3)                   Bump past attribute character
         B     HELP$L
HELP$LM  DS    0H
*-Print special info here
**       CLI   0(R3),X'FD'                Translators?
**       BNE   HELP$TTX                   No, continue
*-Print string
         LA    R15,RECOUT+1               Bump past prefix and 'xxxI '
         SLR   R14,R14                    Clear register
         IC    R14,0(R3)                  Obtain length of messsage - 1
         EX    R14,HELP$MVE               Move string to message area
         LA    R3,2(R14,R3)               Bump past this string
         BAS   R14,HELP$PSR               Print record
*-End of table
         CLI   0(R3),X'FF'                End of table?
         BNE   HELP$L                     No, process next string
*
         BAS   R14,HELP$CLEAR_RECOUT      Clear record to blanks
         BAS   R14,HELP$PSR               Print the record
         B     HELP$X                     Continue
*
HELP$MVE MVC   0(0,R15),1(R3)
*
** Common exit from HELP processing
*
HELP$X   DS    0H
         PR    ,                          Return to caller
*
** Print SYSPRINT Record
*
HELP$PSR DS    0H
         ST    R14,PSR_RA                 Save return address
         LA    R0,PSRRSA                  Locate work area
         LA    R1,RECOUT                  Locate record to print
         L     R15,=V(DRU$PSR)            Locate sysprint routine
         BASR  R14,R15                    Print Sysprint Record
         L     R14,PSR_RA                 Get return address
         BSM   0,R14                      Return to caller
*
** Clear output record to blanks
*
HELP$CLEAR_RECOUT  DS 0H
         LA    R15,RECOUT                 Locate output record
         MVI   0(R15),C' '                Get Blank
         MVC   1(133-1,R15),0(R15)        ..Propagate it
         BSM   0,R14                      Return to caller
*
** Initialize message
**
** Output: R1 has DRU$CON1
*
HELP$FORMAT_MESSAGE DS 0H
         LA    R15,RECOUT
         MVI   0(R15),C' '
         MVC   1(133-1,R15),0(R15)
         LA    R15,1(R15)
         MVC   0(3,R15),=C'DRU'           Move in message prefix
         LA    R15,3(R15)
         L     R1,=V(DRU$CON1)            -> DRU$CON1 CSECT
         BSM   0,R14
*
** Literals for the DRU$HELP CSECT
*
         LTORG ,
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**       Help text area
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
HELPTEXT DS    0H
 DC  X'FE'                                Skip a line
*
** General information
*
 DA#STR 'DA$DISKR is a utility that will create reports about your '
 DA#STR 'DASD farm'
*
** Sample JCL
*
 DC  X'FE'                                Skip a line
 DA#STR 'It can be invoked via the following JCL:'
 DC  X'FE'                                Skip a line
 DA#STR '//stepname EXEC PGM=DA$DISKR,PARM=''options'' '
 DA#STR '//VATLST   DD DISP=SHR,DSN=SYS1.PARMLIB(VATLST00)'
 DA#STR '//*'
 DA#STR '//SYSPRINT DD SYSOUT=*,DCB=(LRECL=133,BLKSIZE=133,RECFM=FA)'
 DA#STR '//REPORT   DD SYSOUT=*,DCB=(LRECL=133,BLKSIZE=1330,RECFM=FBA)'
 DA#STR '//VTOCRPT  DD SYSOUT=*,DCB=(LRECL=133,BLKSIZE=1330,RECFM=FBA)'
 DA#STR '//SYSUDUMP DD SYSOUT=*'
 DA#STR '//*'
 DA#STR '//WRKFILE1 DD DISP=(,PASS),DSN=&&WRKFILE1,UNIT=SYSDA,'
 DA#STR '//            DCB=(LRECL=512,BLKSIZE=5120,RECFM=FB),'
 DA#STR '//            SPACE=(CYL,(5,5))'
 DA#STR '//WRKFILE2 DD DISP=(,PASS),DSN=&&WRKFILE2,UNIT=SYSDA,'
 DA#STR '//            DCB=(LRECL=512,BLKSIZE=5120,RECFM=FB),'
 DA#STR '//            SPACE=(CYL,(20,20))'
 DA#STR '//WRKFILE3 DD DISP=(,PASS),DSN=&&WRKFILE3,UNIT=SYSDA,'
 DA#STR '//            DCB=(LRECL=512,BLKSIZE=5120,RECFM=FB),'
 DA#STR '//            SPACE=(CYL,(20,20))'
 DA#STR '//WRKFILE4 DD DISP=(,PASS),DSN=&&WRKFILE4,UNIT=SYSDA,'
 DA#STR '//            DCB=(LRECL=80,BLKSIZE=80,RECFM=FB),'
 DA#STR '//            SPACE=(CYL,(5,5))'
 DA#STR '//WRKFILE5 DD DISP=(,PASS),DSN=&&WRKFILE5,UNIT=SYSDA,'
 DA#STR '//            DCB=(LRECL=121,BLKSIZE=1210,RECFM=FBA),'
 DA#STR '//            SPACE=(CYL,(5,5))'
 DC  X'FE'                                Skip a line
 DC  X'FE'                                Skip a line
 DA#STR ' Note: If you don''t want a VTOC report, simply comment out'
 DA#STR '       the //VTOCRPT JCL statement'
*
** Pair-A-Meters
*
 DC  X'FE'                                Skip a line
 DC  X'FE'                                Skip a line
 DA#STR 'The following options can be specified on the parm card '
 DA#STR '(PARM="option,option")'
 DC  X'FE'                                Skip a line
 DA#STR 'CATCHK   - Perform check to see if dataset is catalogued'
 DC  X'FE'                                Skip a line
 DA#STR 'CVTUCBSC - Use the older UCB scan method even though we are '
 DA#STR '           executing on a system that can use the new way.'
 DA#STR '           This is not recommended: no dynamic or 4 digit '
 DA#STR '           UCBs will be found'
 DC  X'FE'                                Skip a line
 DA#STR 'DATAONLY - Reports only have data line items: no headings or'
 DA#STR '           footings'
 DC  X'FE'                                Skip a line
 DA#STR 'DEBUG    - Show some debugging information'
 DC  X'FE'                                Skip a line
 DA#STR 'HELP     - Print help information for using this utility'
 DC  X'FE'                                Skip a line
 DA#STR 'NAUTH    - Do not use facility that require authorization'
 DA#STR '           if we are able to do do'
 DC  X'FE'                                Skip a line
 DA#STR '           Alias: NOAUTH'
 DC  X'FE'                                Skip a line
 DA#STR 'NOPIC    - Don''t display picture at startup'
 DC  X'FE'                                Skip a line
 DA#STR 'NOSYSP   - Don''t print System Profile at the beginning of '
 DA#STR '           the //REPORT file output'
 DC  X'FE'                                Skip a line
 DA#STR 'ONLYLLIB - Only process Load Libraries'
 DC  X'FE'                                Skip a line
 DA#STR 'ONLYRECU - Only process RECFM=U libraries'
 DC  X'FE'                                Skip a line
 DA#STR 'PRTSMSG  - Print sort messages (usually only printed when the'
 DA#STR '           SORT has a bad RC or ABEND)'
 DC  X'FE'                                Skip a line
 DA#STR '           Alias: PRTSORTM and PSM'
 DC  X'FE'                                Skip a line
 DA#STR 'RPTBOTH  - Print DASD report by UCB and DSN'
 DC  X'FE'                                Skip a line
 DA#STR 'RPTBYDSN - Print report by DSN'
 DC  X'FE'                                Skip a line
 DA#STR 'RPTBYUCB - Print report by UCB'
 DC  X'FE'                                Skip a line
 DA#STR 'SMSMCHK '
 DC  X'FE'                                Skip a line
 DA#STR 'VERBOSE '
 DC  X'FE'                                Skip a line
 DC  X'FE'                                Skip a line
 DA#STR 'DASD Configuration Report field source:'
 DC  X'FE'                                Skip a line
 DA#STR 'o UCB.............UCB:   UCBCHAN'
 DA#STR 'o Volume_Serial...UCB:   UCBVOLI'
 DA#STR 'o Device_Type.....IEFEB4UV and internal nickname table'
 DA#STR 'o Tracks_Free.....LSPACE: LSPDTTRK LSPDTCYL'
 DA#STR 'o Tracks_Total....DSCB4: DS4DSCYL * DS4STRK'
 DA#STR '                  (Other programs subtract the VTOC'
 DA#STR '                  and other overhead areas)'
 DA#STR 'o VTOC_size.......DSCB4: DS4VTOEC w/DS4DEVSZ calcs'
 DA#STR 'o VTOC_DSCB.......DSCB4: DS4DEVDT'
*
** End of HELP CSECT
*
 DC  X'FE'                                Skip a line
 DA#STR 'End of Help.'
 DC  X'FF'
*
** End of DRU$HELP
*
         DROP  R12,R13
         DS  0D
         EJECT
***********************************************************************
***                                                                 ***
**        DA$DISKR DSECTs                                            **
***                                                                 ***
***********************************************************************
         SPACE 2
*
** Work DASD area
*
WD           DSECT ,
WD_VOLS      DS    CL6                    Volume serial
WD_UCB       DS    CL4                    UCB address
WD_SNAME     DS    CL8                    System name from CVTSNAME
WD_VER       DS    CL4'V1.0'              DA$DISKR Version.Release
WD_DEVTL     DS    X                      Device type length
WD_DEVT      DS    CL8                    Device type
WD_DEVTA     DS    CL8                    Device type for allocation
WD_FLAG1     DS    B'00000000'            Flag 1
$WDF1_NLSPC  EQU   B'10000000'            ..No LSPACE information
$WDF1_IVTOC  EQU   B'01000000'            ..Indexed VTOC?
$WDF1_CACHEC EQU   B'00100000'            ..Cached controller?
$WDF1_CACHEV EQU   B'00010000'            ..Cached volume?
$WDF1_CVAFF  EQU   B'00001000'            ..CVAF failed?
WD_VTOCT     DS    XL2                    Number of tracks in VTOC
WD_UCBT      DS    CL4                    UCB type
WD_VMNT      DS    CL3                    Mount status (VATLST)
WD_SMNT      DS    CL3                    Mount status (SYSTEM)
WD_CHPID     DS    CL8                    Channel path id
WD_VIT       DS    XL4                    VTOC info Table entry
             DS    0F
WD_LSPCD     DS    XL(C_LSPCDLL)          LSPACE SVC Data information
WD_F4DSCB    DS    XL(#F4DSCBL)           Format 4 DSCB
WD_DESC      DS    CL40                   Description
             DS    0D                     Get aligned
WD_DTAREA    DS    XL24                   Device type macro return
WDL          EQU   *-WD
*
** Process_VTOC / VTOC Information
*
DDC          DSECT ,
DDC_H        EQU   *
DDC_HID      DC    CL8'DASD-DC'
DDC_HL       EQU   *-DDC_H
DDC_E        EQU   *                     Entry
DDC_ENAME    DS    CL8'3380K'            ..Device type
DDC_ECOUNT   DS    XL4                   ..Count
DDC_EL       EQU   *-DDC_E
*
** Process_VTOC / VTOC Information
*
VI           DSECT ,
VI_SER       DS    CL6                    Volume name
VI_FLAG1     DS    B'00000000'            Flag 1
VI_FLAG2     DS    B'00000000'            Flag 2
VI_DDN       DS    CL8                    DDNAME used to access it
*                                         DSCB counts:
VI_F0        DS    F                      ..Format 0 (free)
VI_F1        DS    F                      ..Format 1
VI_F2        DS    F                      ..Format 2
VI_F3        DS    F                      ..Format 3
VI_F4        DS    F                      ..Format 4
VI_F5        DS    F                      ..Format 5
VI_F6        DS    F                      ..Format 6
*                                         RECFM counts:
VI_PS        DS    F                      ..Physically Sequential
VI_DA        DS    F                      ..Direct Access
VI_PO        DS    F                      ..Partitioned Organization
VI_IS        DS    F                      ..ISAM
VI_AM        DS    F                      ..VSAM
VI_UN        DS    F                      ..UnKnown
*                                         Misc:
VI_UNCAT     DS    F                      ..Un-Catalogued Datasets
VIL          EQU   *-VI
*
** Process_VTOC Records
*
PVR          DSECT ,
PVR_VOLS     DS    CL6
PVR_UCB      DS    CL4
PVR_CAT      DS    C' '
PVR_DSCB     DS    CL140
PVR_DSORG    DS    CL3' '
PVRL         EQU   *-PVR
*
** VATLST Description
*
VL          DSECT ,
VL_VOLS     DS    CL6                     VOLSER
            DS    CL1                     ,
VL_MNT      DS    CL1                     MOUNT ATTRIBUTE
VL_MNT0     EQU   X'F0'                   ..PERMANENTLY RESIDENT
VL_MNT1     EQU   X'F1'                   ..RESERVED
            DS    CL1                     ,
VL_USE      DS    CL1                     DEFAULT MOUNTING OF VOLUME
VL_USE0     EQU   X'F0'                   ..STORAGE
VL_USE1     EQU   X'F1'                   ..PUBLIC
VL_USE2     EQU   X'F2'                   ..PRIVATE
            DS    CL1                     ,
VL_DEVT     DS    CL8                     DEVICE TYPE
            DS    CL1                     ,
VL_MSG      DS    CL1                     N
            DS    CL1                     FILLER
VL_DESC     DS    CL40                    DESCRIPTION OF USE
*
** Operations Report
*
OR       DSECT ,
         DS    CL1                        FBA BYTE
OR_UCB   DS    CL4                        UCB
         DS    CL1
OR_VOLS  DS    CL6                        Volume Serial
         DS    CL1
OR_DEVT  DS    CL8                        Device Type
         DS    CL1
OR_VMNT  DS    CL3                        Mount status (VATLST)
         DS    CL3
OR_SMNT  DS    CL3                        Mount status (system)
         DS    CL2
OR_TRKS  EQU   *                          Tracks
OR_FTRKP DS    CL4                        ..Percent free
OR_FTRKS DS    CL10                       ..Number
         DS    CL2
OR_TTRKS DS    CL10                       ..Total
         DS    CL2
OR_VTOC  EQU   *                          VTOC
OR_VTOCP DS    CL4                        ..Percent used
         DS    CL2
OR_IVTOC DS    CL1                        Indexed VTOC indication
         DS    CL1
OR_VTOCT DS    CL4                        ..Size
         DS    CL2
OR_VTOCF DS    CL4                        ..Free DSCBs
OR_VTOCL EQU   *-OR_VTOC
         DS    CL2
OR_CACHE DS    CL2                        Cached volume?
         DS    CL1
OR_DESC  DS    CL40                       VATLST description
*
** VTOC output
*
VR       DSECT ,
VR_DSN   DS    CL44                       Dataset name
         DS    C
VR_UCB   DS    CL4
         DS    C
VR_VOLS  DS    CL3
         DS    C
VR_CDATE DS    C'06 MAR 1989'
         DS    C
VR_DSORG DS    CL4
         DS    C
VR_ALLOC DS    CL4
         DS    C
VR_PRI   DS    CL4
         DS    C
VR_SEC   DS    CL4
         DS    C
VR_RECFM DS    CL4
VRL      EQU   *-VR
*
** Increment VATLST
*
IV       DSECT ,
IV_VOL   DS    CL6                        Volume
IV_LEN   EQU   *-IV                       Length of entry
*
** DASD Usage
*
DT       DSECT ,
         DS    CL21
DT_NAME  DS    CL8                        Name (3380, 3380K, 3390, etc)
         DS    CL4
DT_COUNT DS    CL5
*
** DASD Usage
*
DU       DSECT ,
         DS    CL21
DU_GROUP DS    CL6                        VOLUME GROUP
         DS    C
DU_GROUPP  DS  CL4
DU_GROUPPP DS  C'%'
DU_GROUPL EQU  *-DU_GROUP                 VOLUME GROUP
         DS    CL5                        FILLER
DU_NUM   DS    CL6                        NUMBER IN GROUP
         DS    CL5                        FILLER
DU_TTRK  DS    CL15                       TOTAL tracks
         DS    CL5                        FILLER
DU_FTRK  EQU   *                          FREE Tracks
DU_FTRKN DS    CL15                       ..NUMBER
         DS    CL1                        ..FILLER
DU_FTRKP DS    CL4                        ..PERCENTAGE
         DS    C
DU_FTRKL EQU   *-DU_FTRK
         DS    CL5                        FILLER
DU_ATRK  EQU   *                          Allocated Tracks
DU_ATRKN DS    CL15                       ..NUMBER
         DS    CL1                        ..FILLER
DU_ATRKP DS    CL4                        ..PERCENTAGE
         DS    C
DU_ATRKL EQU   *-DU_ATRK
DUL      EQU   *-DU
*
** Dataset List Record
*
DLR         DSECT ,
DLR_DSN     DS   CL44
            DS   C
DLR_VOLS    DS   CL6
            DS   CL3
DLR_CAT     DS   C
            DS   CL3
DLR_DSORG   DS   CL5
            DS   CL2
DLR_RECFM   DS   CL5
            DS   CL2
DLR_LRECL   DS   CL5
            DS   CL2
DLR_BLKSIZE DS   CL5
            DS   CL2
DLR_CDATE   DS   C'dd-mmm-ccyy'
            DS   CL2
DLR_UDATE   DS   C'dd-mmm-ccyy'
            DS   CL2
DLR_SMS     DS   CL3
            DS   CL1
DLR_ATYPE   DS   CL5
            DS   CL1
DLR_SEC     DS   CL5
            DS   CL1
DLR_PRI     DS   CL5
            DS   CL1
DLR_USED    DS   CL5
DLRL        EQU  *-DLR
*
** Misc Equates
*
#VATLSTE EQU   12                         Number: unused VATLST across
*
#BUFLST  EQU   BFLHLN+BFLELN              Set length of buffer area
#F4DSCBL EQU   DS4END-IECSDSL4            Generate length of F4DSCB
         END ,
         EJECT
***********************************************************************
***                                                                 ***
**        Linkage editor cards - ASM.PARM='BATCH,...'                **
***                                                                 ***
***********************************************************************
         SPACE 2
 PUNCH ' ENTRY   DA$DISKR         '       Entry point
 PUNCH ' INCLUDE AOSB0(IEFSD095)  '       IBM big letter routine
 PUNCH ' INCLUDE SYSLMOD(DA$MXD)  '       Our Minx-Hex-Dump routine
 PUNCH ' INCLUDE SYSLMOD(DA$DATE) '       Our Date routine
 PUNCH ' SETCODE AC(1)            '       Authorization helps (ENQ)
 PUNCH ' NAME    DA$DISKR(R)      '       Name of load module
         END ,
./ ADD NAME=DA$ENQS  0100-01266-01266-1821-00938-00938-00000-DAVE
***********************************************************************
***
** Name: DA$ENQS
**
** Author = David Alcock :: dave@planetmvs.com
**
** Purpose: This is a TSO command processor that displays enqueue
**          information for the given RNAME and QNAME.
**
** Syntax: WHOHAS RNAME QNAME
**
**         For example:
**
**         WHOHAS 'SYS1.PARMLIB'     /* Defaults QNAME to SYSDSN */
**         WHOHAS * SPFUSER          /* Show TSO users in ISPF   */
**
** Jobname field has the following formats:
** - "XYZ     >LLA     " - On system "XYZ", jobname LLA has resource
** - "TSU01234-IBMUSER " - On executing system, jobid TSU01234 has
**                         the resource.
** - "ASID0021-LLA     " - On executing system, jobname LLA (which
**                         has no JES jobnumber (or JSAB control
**                         block available) holds the resource.
*
* Disclaimer: This program is FREEWARE.  Use at your own risk.  It
*             is provided for your enjoyment and neither David
*             Alcock or his employer provides any warranty for it's
*             use.  I'd like to hear how it works on your system.
*
*             This software is not in the public domain but is
*             available free of charge and with source code
*             provided.  It is copyright 2001+ by David Alcock
*             All rights reserved.
**
** Attributes: Reentrant, Reusable, Non-Authorized
**
** Non-IBM assembler MACROs:
** o DA#TSOS....TSO services: parsing and messages
** o DA#ENTER...Entry housekeeping
** o DA#LEAVE...Termination housekeeping
** o DA#EYEC....Build standard O/S module eyecatcher
**              (invoked by the DA#ENTER)
** o DA#REGS....Define registers (invoked by DA#ENTER)
***
***********************************************************************
         EJECT
&DAVER   SETC  '1.2'
***********************************************************************
***
**            M o d i f i c a t i o n   H i s t o r y
**
**  Person        Date         Description
**  ------------  -----------  ----------------------------------------
**  D.Alcock      17-DEC-1998  V1.2:
**                             - Use JSAB to get the JOBID;  This
**                               change means we can only execute on
**                               a MVS version 4 or higher system;
**                             - Use LOCACSB macro correctly;
**                             - Check for Enqueues from other systems
**                               and handle them correctly;
**                             - Handle 4 digit UCBs; (Not tested!)
**  D.Alcock      28-MAY-1998  V1.1:
**                             - MSG1 lines up by having the job
**                               field always 12 characters long;
**                             - Change *-6 Execute instructions from
**                               inline to outline;
**  D.Alcock      13-NOV-1996  V1.0 - Renamed from WHOHAS to DA$ENQS
***
***********************************************************************
         SPACE 2
*
** IBM DSECTs
*
 ISGRIB ,                                 GRS - Resource map
 PRINT NOGEN
 IHASDWA ,                                System Diagnostic Work Area
 IRAOUCB ,                                Resource manager User C.B.
 IEECHAIN ,                               CSCB
 IEZJSCB ,                                Job Step Control Block
 CVT   DSECT=YES,LIST=NO                  Communications Vector Table
 IHAPSA ,                                 Prefixed Save Area
 IHAASCB ,                                Address Space Control Block
 IHAASXB ,                                Address Space Extension Block
 IAZJSAB ,                                Job Schedular
 IHAASSB ,                                Address Space Sec Block
 IEFUCBOB PREFIX=YES                      Unit Control Block
 IKJEFLWA ,                               Logon Work area
 IKJEFFGF GFDSECT=YES                     IKJEFF19 GNRLFAIL
 IKJPSCB ,                                Protected Step Control Block
 IKJTCB DSECT=YES,LIST=NO                 Task Control Block
 IKJUPT ,                                 User Profile Table
 IKJCPPL ,                                Command Processor Parm List
#CPPL  EQU *-CPPL                         ..Length of CPPL
 IKJIOPL ,                                Input/Output Parameter Block
#IOPL  EQU *-IOPL
 IKJPPL ,                                 Parse Parameter List
#PPL   EQU *-PPL
 IKJECT ,                                 Enviornment Control Table
 IKJPTPB ,                                PUTLINE Parm Block
*
** Dave's DSECTs
*
 PRINT GEN
 DA#TSOS ,                                TSO parse, PUTLINE, etc.
*-Convert assembly date from SYSDATC format "YYYYMMDD" to "YYYY-MM-DD"
         LCLC  &ASMDATE
&ASMDATE SETC  '&SYSDATC'(1,4).'-'.'&SYSDATC'(5,2).'-'.'&SYSDATC'(7,2)
 EJECT ,
***********************************************************************
***                                                                 ***
**               Initialization Section                              **
***                                                                 ***
***********************************************************************
         EJECT
DA$ENQS  DA#ENTER 'V&DAVER TSO CMD: Who has an enqueue',               @
               RENT=YES,LV=DSAL,                                       @
               AMODE=31,RMODE=ANY
 USING DSA,R13
 ST    R1,R1SAVE                          Save the address of CPPL
         SPACE 2
*
** CPPL, PUTLINE, and PARSE Initialization
*
 LA    R2,X'05'(R12)                      Locate program name DA$ENQS
 DA#TSOS INIT,WA_DA#TSOS,                 Initialize CPPL, PUTLINE...  @
               CPPL=R1SAVE,               ..CPPL                       @
               PCL==V(WHOHASP),           ..Parse area                 @
               PNAME=(R2),PNAMEL=6,       ..Program name Addr,length   @
               ERRET=X$TSOX
*
** Ensure we are on a MVS version 4 system or higher
*
 L     R1,CVTPTR
 TM    CVTOSLV0-CVTMAP(R1),CVTH4410
 BO    I$MVS4X
*MVI   MAXCC,$SEVERE                      Set return code
 DA#TSOS PRTMSG,WA_DA#TSOS,MSG=MSG10
I$MVS4X DS 0H
 EJECT ,
***********************************************************************
***                                                                 ***
**           Parse for fields                                        **
***                                                                 ***
***********************************************************************
 SPACE 2
*
** Set Defaults
*
 OI    FLAG_X1,$ENQCON                    Looking for ENQ conflicts
*
 MVI   GQS_RNAMEL,0                       Set to binary zero
 MVI   GQS_RNAME,0                        Set first byte to zero
 MVC   GQS_RNAMEI(4),=AL2(0,MSG1RNME)     Get message insert
*
 MVC   GQS_QNAMEI(4),=AL2(4+8,MSG1QNME)   Get message insert
 MVC   GQS_QNAME(8),=8C' '                Set field to zero
*
** Retrieve the QNAME
*
 DA#TSOS PDE2STR,WA_DA#TSOS,NAME=PDE_QNAME,OUTPUT=GQS_QNAME
 LTR   R14,R14                            Check length of QNAME
 BZ    P$QNAMEX                           None...
 NI    FLAG_X1,255-$ENQCON                Turn off flag
P$QNAMEX EQU *
*
** Retrieve the RNAME
*
 DA#TSOS PDE2STR,WA_DA#TSOS,NAME=PDE_RNAME,OUTPUT=GQS_RNAME
 LTR   R14,R14                            Check length of RNAME
 BZ    P$RNAMEX                           None...
 NI    FLAG_X1,255-$ENQCON                Turn off flag
 CLI   GQS_QNAME,C' '                     Got a QNAME
 BNE   P$RNQX                             Yes, continue
 MVC   GQS_QNAME(8),T_ENQCON              Move in "SYSDSN"
P$RNQX EQU *
 BAS   R9,FORMAT_DATASET_NAME             Format dataset name
P$RNAMEX EQU *
*
** Enqueue Conflict processing
*
 TM    FLAG_X1,$ENQCON                    Enqueue processing?
 BNO   P$ENQCONX                          Nope, move on
 LA    R1,T_ENQCON                        Locate Enqueue Conflict Table
 ST    R1,GQS_ECTLOC                      Save location
 MVC   GQS_QNAME(8),0(R1)                 Move in first QNAME
*
 XC    GQS_ECCNT(4),GQS_ECCNT             Clear Enqueue Conflict count
P$ENQCONX EQU *
 EJECT ,
***********************************************************************
***                                                                 ***
**       Invoke GRS scan facilities to locate this guy               **
***                                                                 ***
***********************************************************************
 SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**    Initialization for GQSCAN services                             **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
*
** Obtain a work area
*
#GQS_LEN EQU   16384                      Area length is 16K
 GETMAIN R,LV=#GQS_LEN                    Obtain area for GQSCAN
 ST    R0,GQS_VSL                         Save Area length
 ST    R1,GQS_VSA                         Save Area address
*
** Initialize registers and fields
*
 SLR   R2,R2                              Clear register
 IC    R2,GQS_RNAMEL                      Get length of RNAME
*
 MVC   INS$JOB(4),=AL2(4+17,MSG1JOB)      Fix PUTLINE message header
 MVC   INS$ST(4),=AL2(4+3,MSG1ST)         Fix PUTLINE message header
 MVC   INS$ACT(4),=AL2(0,MSG1ACT)         Fix PUTLINE message header
 SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**   Process the request                                             **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
 SPACE 2
GQS$ECLOOP EQU *
 XC    GQS_TOKEN(4),GQS_TOKEN             Clear Token
*
 MVC   GQS_QNAMEI(2),=AL2(4+8)            Reset full length
 LA    R15,GQS_QNAMEI                     Locate field
 BAS   R9,TRIM_TRAILING_BLANKS            Trim trailing blanks
*
GQS$LOOP EQU   *
 AGO .E1X
*
** Establish ESATE exit for GQSCAN S90A abends
*
 MVC   PARMLIST(C_ESTAEL),C_ESTAE         Initialize ESATE param. list
 L     R0,=V(WHOHASE)                     Locate ESTAE routine
 LA    R1,E$ESTAE                         Locate error routine
 ST    R1,GQS_PARMS                       Save it
 ST    R13,GQS_PARMS+4                    Save our Register Save Area
 LA    R6,GQS_PARMS                       Locate our parm address
 ESTAE (0),PARAM=((6)),                   Establish ESTAE for GQSCAN   @
               MF=(E,PARMLIST)
.E1X ANOP ,
*
** Make inquiry into GRS via GQSCAN
*
 L     R6,GQS_VSA                         Locate Area address
 MVC   PARMLIST(C_GQSL),C_GQS             Initialize GQSCAN parm list
 GQSCAN AREA=((R6),#GQS_LEN),                                          @
               SCOPE=ALL,                                              @
               TOKEN=GQS_TOKEN,                                        @
               RESNAME=(GQS_QNAME,GQS_RNAME,(R2),GENERIC),             @
               MF=(E,PARMLIST)
*
** Save Return Code from GQSCAN execution
*
 ST    R0,GQS_RIB                         Save RIB | RIBE length
 ST    R1,GQS_RIBN                        Number of RIBs in area
 STC   R15,GQS_RC                         Save return code
 AGO .E2X
*
** Remove our ESTAE routine
*
 ESTAE 0                                  Remove ESTAE
.E2X ANOP ,
*
** Check valid Return codes
*
 CLI   GQS_RC,0                           Everything okay?
 BE    GQS$OK                             Yep, move on
 CLI   GQS_RC,8                           Everything okay?
 BE    GQS$OK                             Yep, move on
 TM    FLAG_X1,$ENQCON                    Checking enqueue Conflicts?
 BO    GQS$ECLOOPX                        Yes, skip error message...
 B     E$GQSCAN                           Error: QNAME/RNAME not found
GQS$OK EQU *
*
** Dump the RIB
*
*DA#TSOS KWCHK,NAME=KWDUMP,ERRET=GQS$DRIBX
*LA    R9,RIBEND-RIB                      Generate length of RIB
*CALL,SUB=HEXDUMP,PARAM=((6),(9),C_RIB),MF=(E,PARMLIST)
GQS$DRIBX EQU *
 SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**   Process the Resource Information Block - Extent                 **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
 SPACE 2
GQS$RIBL EQU   *
*
** Locate the first RIBE in the RIB
*
 LR    R7,R6                              RIB locate starting point
 SLR   R1,R1                              Clear register
 ICM   R1,B'0011',GQS_RIB                 Get length of RIB
 AR    R7,R1                              Locate RIBE
 AH    R7,RIBVLEN-RIB(R6)                 ..past the variable area
 L     R8,RIBNRIBE-RIB(R6)                Number of RIBE for RIB
GQS$RIBEL EQU  *
*
** Dump the RIBE (if option on)
*
* KWCHK,NAME=KWDUMP,ERRET=GQS$DRIBEX
*LH    R9,GQS_RIBE                        Get length of RIBE
*CALL,SUB=HEXDUMP,PARAM=((7),(9),C_RIBE),MF=(E,PARMLIST)
GQS$DRIBEX EQU *
*
** Check for ENQ conflict
*
 TM    FLAG_X1,$ENQCON                    Checking only conflicts?
 BNO   GQS$RIBCX                          Nope, move on
*
 CLC   RIBNTWE-RIB(4,R6),=X'00,00,00,00'  Waiting exclusive?
 BNE   GQS$RIBC                           Yes, move on
 CLC   RIBNTWS-RIB(4,R6),=X'00,00,00,00'  Waiting shared?
 BE    GQS$RIBB                           Nope, skip this guy
GQS$RIBC  EQU *
 L     R1,GQS_ECCNT                       Get count
 LA    R1,1(R1)                           Increment by 1
 ST    R1,GQS_ECCNT                       Save count
GQS$RIBCX EQU *
*
** Complete detail line
*
 MVC   INS$JOB+4(17),=17C' '
 ICM   R1,B'1111',RIBEUCB-RIBE(R7)        Get UCB address
 BZ    GQS$JOBN                           None, we have job info
 LA    R15,INS$JOB
 MVC   0(4,R15),=C'UCB:'
 LA    R15,5(R15)
 UNPK  0(5,R15),UCBCHAN-UCBOB(3,R1)      Get UCB name
 MVZ   0(4,R15),=8X'00'                  Get UCB name
 TR    0(4,R15),=C'0123456789ABCDEF'     Get UCB name
 MVI   4(R15),C' '
 MVC   5(6,R15),UCBVOLI-UCBOB(R1)        Move in volume serial
 B     GQS$JOBNX
GQS$JOBN EQU *
 L     R1,CVTPTR
 CLC   RIBESYSN-RIBE(8,R7),CVTSNAME-CVTMAP(R1)
 BNE   GQS$JOBNS
 LOCASCB ASID=RIBEASID-RIBE(R7)           Locate Address Space C.B.
 LTR   R15,R15                            Find it?
 BNZ   GQS$JOBNR
 L     R14,ASCBASSB-ASCB(,R1)             -> ASSB
 ICM   R14,B'1111',ASSBJSAB-ASSB(R14)     -> JSAB
 BZ    GQS$JOBNR                          No JSAB?
 CLC   JSABJBID-JSAB(8,R14),=8X'00'       Have a JES jobnumber?
 BE    GQS$JOBNR                          No, continue
 MVC   INS$JOB+4+0(8),JSABJBID-JSAB(R14)  Get jobid
 MVI   INS$JOB+4+8,C'-'                   Insert dash
 MVC   INS$JOB+4+9(8),RIBEJBNM-RIBE(R7)   Move in Job Name
 B     GQS$JOBNX
GQS$JOBNS EQU *
 MVC   INS$JOB+4(8),RIBESYSN-RIBE(R7)
 MVI   INS$JOB+4+8,C'>'
 MVC   INS$JOB+4+9(8),RIBEJBNM-RIBE(R7)   Move in Job Name
 B     GQS$JOBNX
GQS$JOBNR EQU *
 MVC   INS$JOB+4+0(4),=C'ASID'
 UNPK  INS$JOB+4+4(5),RIBEASID-RIBE(3,R7)
 MVZ   INS$JOB+4+4(4),=8X'00'
 TR    INS$JOB+4+4(4),=C'0123456789ABCDEF'
 MVI   INS$JOB+4+8,C'-'                   Insert dash
 MVC   INS$JOB+4+9(8),RIBEJBNM-RIBE(R7)   Move in Job Name
GQS$JOBNX EQU *
*
 TM    RIBERFLG-RIBE(R7),RIBETYPE
 BO    GQS$STS
 MVC   INS$ST+4(3),=C'EXC'
 B     GQS$STX
GQS$STS EQU *
 MVC   INS$ST+4(3),=C'SHR'
GQS$STX EQU *
*
 TM    RIBESFLG-RIBE(R7),RIBESTAT
 BO    GQS$ACTH
 MVC   INS$ACT(2),=AL2(4+10)
 MVC   INS$ACT+4(10),=C'is waiting'
 B     GQS$ACTX
GQS$ACTH EQU *
 MVC   INS$ACT(2),=AL2(4+5)
 MVC   INS$ACT+4(5),=C'holds'
GQS$ACTX EQU *
*
** Get the returned RNAME from the generic request
*
 SLR   R1,R1
 IC    R1,RIBRNMLN-RIB(R6)
 BCTR  R1,0
 EX    R1,GQS$XM1
 LA    R1,5(R1)
 STH   R1,GQS_RNAMEI
*
 DA#TSOS PRTMSG,WA_DA#TSOS,MSG=(MSG1,                                 @@
               INS$JOB,INS$ACT,GQS_QNAMEI,INS$ST,GQS_RNAMEI)
*
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**   Any more work to do                                             **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
GQS$RIBB EQU *
*
** Any more RIBEs
*
 SLR   R1,R1                              Clear register
 ICM   R1,B'0011',GQS_RIBE                Get length of RIBE
 AR    R7,R1                              Bump to end of RIBE
 BCT   R8,GQS$RIBEL                       Do next one
*
** Any more RIBs
*
 LR    R6,R7                              Set address of next RIB
*
 L     R1,GQS_RIBN                        Get number of RIBs left
 BCTR  R1,0                               Decrement by one
 ST    R1,GQS_RIBN                        Get number of RIBs left
 LTR   R1,R1                              Check out number
 BNZ   GQS$RIBL                           It not over yet, Fly Boy
*
** More RIBs than could fit in the area?
*
 CLI   GQS_RC,X'08'                       More stuff?
 BE    GQS$LOOP                           Yes, do it
*
** Enqueue Conflict processing
*
 TM    FLAG_X1,$ENQCON                    Doing Enqueue Conflicts
 BNO   GQS$X                              Nope, end of the line bubba
GQS$ECLOOPX EQU *
 L     R1,GQS_ECTLOC                      Get location in the table
 LA    R1,8(R1)                           Bump to next one
 CLI   0(R1),X'FF'                        At the end of the table?
 BE    GQS$X                              Yes, bye bye
 ST    R1,GQS_ECTLOC                      Save current location in tab.
 MVC   GQS_QNAME(8),0(R1)                 Set QNAME
 B     GQS$ECLOOP                         Do some more
 SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**   Common Exit from GQSCAN processing                              **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
 SPACE 2
GQS$X EQU *
*
** Free the GQS area
*
 L     R0,GQS_VSL                         Get area length
 L     R1,GQS_VSA                         Get area address
 FREEMAIN R,LV=(0),A=(1)                  Free the area
*
** Check ENQ conficts count: Did we catch anything?
*
 TM    FLAG_X1,$ENQCON                    Processing ENQ conflicts
 BNO   GQS$XECX                           Nope, move on
 CLC   GQS_ECCNT(4),=X'00,00,00,00'       Find anything?
 BNE   GQS$XECX                           Yes, move on
 DA#TSOS PRTMSG,WA_DA#TSOS,MSG=MSG2
*MVI   MAXCC,$WARN                        Set condition code
GQS$XECX EQU *
 EJECT ,
***********************************************************************
***                                                                 ***
**       Termination section                                         **
***                                                                 ***
***********************************************************************
 SPACE 2
EXIT EQU *
*
** Terminate TSO stuff
*
X$TSOX EQU *
 DA#TSOS TERM,WA_DA#TSOS
*
** Return to caller
*
 DA#LEAVE ,
 EJECT
***********************************************************************
***                                                                 ***
**       Error routines                                              **
***                                                                 ***
***********************************************************************
 SPACE 2
*
** Error from GQSCAN execution
*
E$GQSCAN EQU *
*
 CLC   GQS_QNAME(8),=CL8'SYSDSN'          Is this for QNAME=SYSDSN?
 BNE   EGQS$SDX
 CLI   GQS_RC,4                           Normal not enqueued?
 BNE   EGQS$SDX
 MVC   INS$JOB+4(12),=CL12'No job'
 MVC   INS$ACT(2),=AL2(4+5)
 MVC   INS$ACT+4(5),=C'holds'
 MVC   INS$ST+4(3),=C'   '
*-Since MSG9 is a clone of MSG1, we can use the same insert offsets
 DA#TSOS PRTMSG,WA_DA#TSOS,MSG=(MSG9,                                 @@
               INS$JOB,INS$ACT,GQS_QNAMEI,INS$ST,GQS_RNAMEI)
 B     GQS$X                              Free the Work area
EGQS$SDX DS 0H
*
 SLR   R1,R1                              Clear register
 IC    R1,GQS_RC                          Obtain the return code
 DA#TSOS EDITR1,OUTPUT=INS$RC,MF=(E,PARMLIST)
 MVC   INS$RC+2(2),=AL2(MSG3RC)           Fix offset
*
 BAS   R9,FIND_GQSCAN_ERROR               Find error, return in R8
*
 DA#TSOS PRTMSG,WA_DA#TSOS,MSG=(MSG3,INS$RC,(8))
* Note: We could print the QNAME/RNAME here...
*MVI   MAXCC,$SEVERE                      Set return code
 B     GQS$X                              Free the Work area
*
** Error: GQSCAN abended, ABEND code in GQS_PARM+4
*
E$ESTAE EQU *
*ESTAE 0                                  Remove ESTAE
*MVI   MAXCC,$SEVERE                      Set return code
 DA#TSOS PRTMSG,WA_DA#TSOS,MSG=MSG8
 B     GQS$X                              Free GETMAINed area
 EJECT ,
***********************************************************************
***                                                                 ***
**        Find GQSCAN error                                          **
**                                                                   **
**        Input: GQS_RC                                              **
**        Output: R8 - address of description insert                 **
***                                                                 ***
***********************************************************************
         SPACE 2
FIND_GQSCAN_ERROR EQU   *
 LA    R0,T_GQSE                         Number of entries
 LA    R1,T_GQS                          Locate table
FGE$LOOP EQU   *
 CLC   GQS_RC(1),1(R1)                   Return code match?
 BE    FGE$LOOPX                         Yes, leave loop
 LA    R1,2+2+4(R1)                      No, bump to next entry
 BCT   R0,FGE$LOOP                       ..do it
 LA    R8,GQS002                         Move in default
 BSM   0,R9                              Return to caller
FGE$LOOPX EQU  *
 L     R8,2+2(R1)                        Load description address
 BSM   0,R9                              Return to caller
*
**  Table
*
T_GQS    EQU   *
         DC    AL2(4,0),AL4(GQS001)
         DC    AL2(8,0),AL4(GQS002)
         DC    AL2(12,0),AL4(GQS003)
         DC    AL2(16,0),AL4(GQS004)
         DC    AL2(20,0),AL4(GQS005)
T_GQSE   EQU   ((*-T_GQS)/(2+2+4))
*
GQS001   DC    AL2(GQS001L,MSG3DESC)
         DC    C'No resources matched your request'
GQS001L EQU    *-GQS001
*
GQS002   DC    AL2(GQS002L,MSG3DESC)
         DC    C'See manual "SPL: System Macros" -'
         DC    C'dependent on application'
GQS002L EQU    *-GQS002
*
GQS003   DC    AL2(GQS003L,MSG3DESC)
         DC    C'Encountered an abnormal situaltion while processing'
GQS003L EQU    *-GQS003
*
GQS004   DC    AL2(GQS004L,MSG3DESC)
         DC    C'Invalid SYSNAME was specified as input to GQSCAN'
GQS004L EQU    *-GQS004
*
GQS005   DC    AL2(GQS005L,MSG3DESC)
         DC    C'Information returned by GQSCAN not complete'
GQS005L EQU    *-GQS005
 DS 0H
 EJECT ,
***********************************************************************
***                                                                 ***
**       Misc Internal Subroutines                                   **
***                                                                 ***
***********************************************************************
 SPACE 2
*
** Trim trailing blanks from an insert
**
** Input: R15 - points to a message insert with full length
*
TRIM_TRAILING_BLANKS EQU *
 DA#TSOS TRIM,MF=(E,(15))               Trim trailing blanks
 BSM   0,R9
         EJECT
***********************************************************************
***                                                                 ***
**        Format Dataset name                                        **
**                                                                   **
**        Input: R14 has RNAME - 1                                   **
***                                                                 ***
***********************************************************************
         SPACE 2
FORMAT_DATASET_NAME EQU *
*
** Check for enqueues which have a RNAME that is a Dataset
*
 CLC   GQS_QNAME(6),TE_SYSD               SYSDSN?
 BE    FDN$S
 CLC   GQS_QNAME(7),TE_SPFE               SYSEDIT?
 BE    FDN$S
 CLC   GQS_QNAME(6),TE_SPFD               SPFDSN?
 BNE   FDN$X
*
** Startup
*
FDN$S EQU *
 EX    R14,FDN$XM1                        Save copy of RNAME/DSN
 LA    R2,GQS_RNAME                       Locate beg
 MVI   0(R2),C' '                         Move in blank
 MVC   1(44-1,R2),0(R2)                   ..propagate it
 CLI   PARMLIST,X'7D'                     Begins with a quote?
 BE    FDN$Q                              Yes, do quote code
*
** Unquoted dataset needs prefix added to beginning
*
 DA#TSOS GETCPPL,WA_DA#TSOS,WRKREG=1      -> CPPL
 L     R1,CPPLUPT-CPPL(R1)                -> UPT
 SLR   R15,R15                            Clear register
 IC    R15,UPTPREFL-UPT(R1)               Obtain prefix length
 BCTR  R15,0                              Decrement for EX
 EX    R15,FDN$XM2                        Move prefix to RNAME
 LA    R2,1(R15,R2)                       Bump past prefix
 MVI   0(R2),C'.'                         Insert a dot
 EX    R14,FDN$XM3                        Move unprefixed part out
 AR    R14,R15                            Add prefix + suffix
 LA    R14,1+1(R14)                       Add: EX + "."
 B     FDN$C
*
** Handle quoted dataset name
*
FDN$Q EQU *
 SH    R14,=AL2(2)                        Remove for both quotes...
 EX    R14,FDN$XM4                        Move unquoted RNAME/DSN
*
** Common code: ensure that dataset exists
*
FDN$C EQU *
 LR    R3,R14                             Save RNAME length
 MVC   PARMLIST(C_LOCATEL),C_LOCATE       Move in parameter list
 LA    R1,GQS_RNAME                       Locate the Data Set Name
 ST    R1,PARMLIST+4                      Save into parmeter list
 LA    R1,W_CAMLST                        Locate the work area
 ST    R1,PARMLIST+12                     Save into parmeter list
 LOCATE PARMLIST                          Is the Data set catalogued?
 LTR   R15,R15                            Well?
 BZ    FDN$CX                             Nope, move on
 DA#TSOS PRTMSG,WA_DA#TSOS,MSG=MSG7
FDN$CX EQU *
 LR    R14,R3                             Restore RNAME length
*
** Exit: Save RNAME length fields
*
FDN$X EQU *
 LA    R14,1(R14)                         Increment for EX
 STC   R14,GQS_RNAMEL                     Save length
 LA    R14,4(R14)                         Add length of message insert
 STH   R14,GQS_RNAMEI                     Set length of Message insert
 BSM   0,R9                               Return to caller
 EJECT ,
***********************************************************************
***                                                                 ***
**       Data Constants                                              **
***                                                                 ***
***********************************************************************
         SPACE 2
GQS$XM1  MVC   GQS_RNAME(0),RIBEND-RIB(R6)
FDN$XM1  MVC   PARMLIST(0),GQS_RNAME
FDN$XM2  MVC   0(0,R2),UPTPREFX-UPT(R1)
FDN$XM3  MVC   1(0,R2),PARMLIST
FDN$XM4  MVC   0(0,R2),PARMLIST+1
*
MSG1     DC    AL2(MSG1L,0)
MSG1S    EQU   *
         DC    C'WHOHAS-01I '
MSG1JOB  EQU   *-MSG1S
         DC    C' '
MSG1ACT  EQU   *-MSG1S
         DC    C' '
MSG1QNME EQU   *-MSG1S
         DC    C' '
MSG1ST   EQU   *-MSG1S
         DC    C': '
MSG1RNME EQU   *-MSG1S
         DC    C' '
MSG1L    EQU   *-MSG1
*
MSG2     DC    AL2(MSG2L,0)
         DC    C'WHOHAS-02I '
         DC    C'There are no ENQ conflicts!'
MSG2L    EQU   *-MSG2
*
MSG3     DC    AL2(MSG3L,0)
MSG3S    EQU   *
         DC    C'WHOHAS-03E '
         DC    C'GQSCAN error: RC='
MSG3RC   EQU   *-MSG3S
         DC    C', '
MSG3DESC EQU   *-MSG3S
         DC    C' '
MSG3L    EQU   *-MSG3
*
MSG7     DC    AL2(MSG7L,0)
         DC    C'WHOHAS-07W '
         DC    C'Data set is not catalogued'
MSG7L    EQU   *-MSG7
*
MSG8     DC    AL2(MSG8L,0)
         DC    C'WHOHAS-08I '
         DC    C'GQSCAN abend occurred processing your request'
MSG8L    EQU   *-MSG8
*
MSG9     DC    AL2(MSG9L,0)
MSG9S    EQU   *
         DC    C'WHOHAS-09E '
MSG9JOB  EQU   *-MSG9S
         DC    C' '
MSG9ACT  EQU   *-MSG9S
         DC    C' '
MSG9QNME EQU   *-MSG9S
         DC    C' '
MSG9ST   EQU   *-MSG9S
         DC    C': '
MSG9RNME EQU   *-MSG9S
         DC    C' '
MSG9L    EQU   *-MSG9
*
MSG10    DC    AL2(MSG10L,0)
         DC    C'WHOHAS-10E '
         DC    C'This system is not at MVS version 4 or higher'
MSG10L   EQU   *-MSG10
*
*
** Copy code
*
C_RIB    DC    AL1(C_RIBL-2),C'RIB'
C_RIBL   EQU   *-C_RIB
C_RIBE   DC    AL1(C_RIBEL-2),C'RIBE'
C_RIBEL  EQU   *-C_RIBE
C_LOCATE CAMLST NAME,*-*,,*-*
C_LOCATEL EQU  *-C_LOCATE
*
C_ESTAE ESTAE  MF=L
C_ESTAEL EQU   *-C_ESTAE
*
C_GQS   GQSCAN AREA=(*-*,*-*),                                         @
               SCOPE=ALL,                                              @
               TOKEN=*-*,                                              @
               RESNAME=(*-*,*-*,*-*),                                  @
               MF=L
C_GQSL  EQU    *-C_GQS
*
** Literals used in program
*
 LTORG ,
 EJECT ,
***********************************************************************
***                                                                 ***
**       Table of QNAME to use for ENQ conflicts                     **
***                                                                 ***
***********************************************************************
 SPACE 2
T_ENQCON EQU   *
TE_SYSD  DC    CL8'SYSDSN'
TE_SPFE  DC    CL8'SPFEDIT '
TE_SPFD  DC    CL8'SPFDSN  '
         DC    CL8'SYSIEA01'
         DC    CL8'SYSIEFSD'
         DC    CL8'SYSIEWLP'
         DC    CL8'SYSIGGV1'
         DC    CL8'SYSIGGV2'
         DC    CL8'SYSIKJBC'
         DC    CL8'SYSIKJUA'
         DC    CL8'SYSSMF01'
         DC    CL8'SYSVSAM'
         DC    CL8'SYSVTOC'
         DC    CL8'SYSZCAXW'
         DC    CL8'SYSZCOMM'
         DC    CL8'SYSZJES2'
         DC    CL8'SYSZJWTP'
         DC    CL8'SYSZOPEN'
         DC    CL8'SYSZPCCB'
         DC    CL8'SYSZRPLW'
         DC    CL8'SYSZSIPS'
         DC    CL8'SYSZSMF1'
         DC    CL8'SYSZTIOT'
         DC    CL8'SYSZVARY'
         DC    CL8'SYSZVOLS'
         DC    CL8'SYSZWTOR'
         DC    X'FF'                      End of the table
         DS    0D
 EJECT
***********************************************************************
***                                                                 ***
**       PARSE descriptors                                           **
***                                                                 ***
***********************************************************************
 SPACE 2
WHOHASP CSECT ,
WHOHASP AMODE 31
WHOHASP RMODE ANY
WHOHASP IKJPARM ,
PDE_RNAME IKJIDENT 'RNAME',                                            @
               MAXLNTH=255,FIRST=ANY,OTHER=ANY,                        @
               HELP=('The RNAME to use to inquire GRS')
PDE_QNAME IKJIDENT 'QNAME',                                            @
               MAXLNTH=8,FIRST=ANY,OTHER=ANY
*
** Keyword: TYPE
*
KWDUMP   IKJKEYWD ,
$KWDUMP  EQU   1
         IKJNAME 'DUMP'
 SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**                 End of Parse definitions                          **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
 SPACE 2
 IKJENDP ,
 EJECT ,
***********************************************************************
***                                                                 ***
**       GETMAINed work area                                         **
***                                                                 ***
***********************************************************************
 SPACE 2
DSA      DSECT ,
         DS    18F                        Register Save Area
R1SAVE   DS    F                          R1 (CPPL) on entry
WA_DA#TSOS DS  XL(DA#TSOSDL)              CPPL/PUTLINE/PARSE code
*
** Misc fields
*
           DS 0D
DOUBLE     DS D
DWA        DS 2D
PARMLIST   DS XL(C_GQSL)                  Parameter list area
*
** GQSCAN areas
*
           DS  0F                         Virtual Storage obtained
GQS_VSA    DS  F                          ..Address
GQS_VSL    DS  F                          ..Length
GQS_PARMS  DS  2F                         Parameter area for ESTAE
GQS_TOKEN  DS  F                          Token
GQS_RIB    DS  H                          Length of RIB
GQS_RIBE   DS  H                          Length of RIBE
GQS_RIBN   DS  F                          Number of RIBs in area
GQS_ECCNT  DS  F                          ENQ Conflict: Count
GQS_ECTLOC DS  F                          ENQ Conflict: Table location
*
GQS_QNAMEI DS  XL4                        QName PUTLINE message insert
GQS_QNAME  DS  CL8                        QName literal
*
GQS_RNAMEI DS  XL4                        RName PUTLINE message insert
GQS_RNAME  DS  CL255                      RNAME literal
GQS_RNAMEL DS  X                          RNAME length
*
GQS_RC     DS  X                          GQSCAN return code
*
** Execution Flags
*
FLAG_X1  DS    B'00000000'                Flag: Execution 1
$ENQCON  EQU   B'10000000'                ..Enqueue Conflict checks?
*
** Message inserts
*
INS$JOB   DS  XL36
INS$ST    DS  XL36
INS$ACT   DS  XL36
INS$RC    DS  XL36
*
           DS 0D
W_CAMLST   DS XL265
           DS 0D
DSAL     EQU   *-DSA                      Reset addressiblity
         EJECT ,
***********************************************************************
***                                                                 ***
**           ESTAE exit for GQSCAN ABENDS                            **
***                                                                 ***
***********************************************************************
 SPACE 2
WHOHASE CSECT ,
WHOHASE AMODE 31
WHOHASE RMODE ANY
 USING WHOHASE,R15
*
** Standard O/S Module Eyecatcher
*
 B     WHOHASE_ECX
 DC    AL1(WHOHASE_ECL)
WHOHASE_EC   EQU *
 DC    C'WHOHASE  &ASMDATE. &SYSTIME. V&DAVER ESTAE_ROUTINE'
WHOHASE_ECL EQU *-WHOHASE_EC
WHOHASE_ECX DS   0H
*
** Can we attempt retry?
*
 CH    R0,=H'12'                          SDWA present?
 BE    WHOHASE_ABEND                      Nope, leave
 TM    SDWAERRD-SDWA(R1),SDWACLUP         Can we perform retry?
 BC    1,WHOHASE_ABEND                    Nope, leave
*
** Attempt retry
*
 L     R3,SDWAPARM-SDWA(R1)               Get Parameters
 L     R13,4(R3)                          Get WHOHAS RSA
*LM    R10,R12,XXXXXXX_RSA_R10-XXXXXXX_RSA(R13) Restore registers
 L     R4,SDWAABCC-SDWA(R1)               Get ABEND code
 ST    R4,4(R3)                           Save it for later use
 L     R4,0(R3)                           Get retry address
 SETRP RC=4,RETADDR=(4),RECORD=NO
 BSM   0,R14
*
** Continue with ABEND
*
WHOHASE_ABEND EQU *
 SETRP RC=0
 BSM   0,R14
*
** Literals for WHOHASE
*
 LTORG ,
 END ,
 EJECT
***********************************************************************
***                                                                 ***
**       Linkage editor cards                                        **
***                                                                 ***
***********************************************************************
 SPACE 2
 PUNCH ' ENTRY   DA$ENQS         '        Entry point
 PUNCH ' ALIAS   WHOHAS          '        Alias
 PUNCH ' NAME    DA$ENQS(R)      '        Name of load module
 END ,
./ ADD NAME=DA$EREP  0100-01266-01266-1821-02210-02210-00000-DAVE
DA$EREP  TITLE 'EREP (LOGREC) ISPF application - ACCIN to ISPF table'
* =================================================================== *
*
* Name: DA$EREP
*
* Author = David Alcock :: dave@planetmvs.com
*
* Purpose: This program is part of an ISPF application to display
*          Software LOGREC entries in an ISPF table for easy
*          perusal.  This makes it very easy to invoke EREP to
*          get a report on a particular LOGREC entry.
*
*          This program must be invoked by a CLIST or EXEC that:
*          - Allocates file ACCIN to the reduced LOGREC file
*          - Creates table LRSTABLE and passes its name to us
*          - Creates table SUMTABLE and passes its name to us
*          - Creates table STATABLE and passes its name to us
*          - And most important - displays the result!
*
* Reference: GC28-1378 EREP User's Guide
*            GC28-1670 MVS/ESA SYS1.LOGREC Error Recording
*
* Disclaimer: This program is FREEWARE.  Use at your own risk.  It
*             is provided for your enjoyment and neither David
*             Alcock or his employer provides any warranty for it's
*             use.  I'd like to hear how it works on your system.
*
*             This software is not in the public domain but is
*             available free of charge and with source code
*             provided.  It is copyright 2001+ by David Alcock
*             All rights reserved.
*
*  Programs called:
*  - DA$DATE....Date routine
*  - ISPLINK....ISPF interface module
*
*  Non-Standard Macro Usage:
*  - DA#ENTER...Entry Housekeeping
*  - DA#LEAVE...Exit Housekeeping
*  - DA#EYEC....Create module eyecatcher (invoked by DA#ENTER)
*  - DA#REGS....Generate register equates (invoked by DA#ENTER)
*  - DA#STR.....Generate a string array with byte length (-1)
*  - DA#DATE....Equates used invoking the DA#DATE date routine
*  - DA#MXD.....Mini-Hex-Dump routine DSECTs and equates
*
* Limitations:
* - MVS EREP format. The Software entries are mapped by IHAHDR
*   which IBM doesn't put into SYS1.MACLIB or SYS1.MODGEN.  We
*   are left to hardcode our own SFT DSECT (from EREP manual).
* - Assemble with Assembler H, HLASM or higher
*
*
* =================================================================== *
         SPACE 2
&DAVER   SETC  '2.3'
*======================================================================
*
*             M o d i f i c a t i o n   H i s t o r y
*
* Person      Date       Description
* ----------  ---------- ----------------------------------------------
* Dave Alcock 2000-03-02 v2.3:
*                        - Fix edit pattern for LRSDATEJ for sig dig;
*                        - Count number of recs with 1900 century;
* Dave Alcock 2000-01-05 v2.2:
*                        - Added Date windowing code for the bad
*                          EREP records that IBM is creating;
* Dave Alcock 2000-01-04 v2.1:
*                        - Added Debugging code (output to //DA$EREP);
*                        - Added new base register 10;
* Dave Alcock 1999-12-29 v2.0:
*                        - Use ISO date format CCYY-MM-DD
*                        - DA$DATE subroutine needs to be 1999-09-09 or
*                          better (has ISO ccyy-mm-dd support);
* Dave Alcock 1997-06-21 Removed Guide/SPF macro requirement;
* Dave Alcock 1996-11-11 Removed code that read SYS1.LOGREC (It wasn't
*                        fully implemented anyway);
* Dave Alcock 1995-11-11 Added external CPU table support;
* Dave Alcock 1993-10-30 Added support to read SYS1.LOGREC;
* Dave Alcock 1991-09-25 Rewritten to seperate installation code,
*                        made Reentrant, 31 bit addressibility,
*                        create stats table, Add X'4C' symptom
*                        record processing;
*======================================================================
         SPACE 2
*
** IBM DSECTs
*
         PRINT NOGEN
         DCBD  DSORG=PS,DEVD=DA           Data Control Block
         IKJTSVT ,                        TSO Vector Table
         CVT   DSECT=YES,LIST=NO          Communications Vector Table
         PRINT GEN
         EJECT ,
         ADSR  ,                          Symptom String
         EJECT ,
         IHALRB ,                         Logrec Buffer map (hardware)
         EJECT ,
         IHASDWA ,                        System Diagnostic Work Area
*
** Non-IBM DSECTs
*
         DA#DATE ,                        Date routine
         DA#MXD ,                         Mini-Hex-Dump
*
** Misc Equates
*
#MAXMOD  EQU   2048                       Maximum modules in Summary
#MAXCPUN EQU   128                        Maximum CPUs to count
#STATUSL EQU   500                        Update status - lrstable
#STATUSS EQU   100                        Update status - sumtable
#MAXCPUS EQU   256                        Maximum CPU Serial numbers
         EJECT ,
*
** Entry housekeeping code
*
DA$EREP  DA#ENTER 'V&DAVER Subroutine: Process EREP records',          @
               AMODE=31,RMODE=ANY,        ..Residency                  @
               BASE=(12,11,10),           ..Base registers             @
               LV=DSAL,RENT=YES           ..Dynamic Save Area
         USING DSA,R13                    Get addressability
         EJECT ,
***********************************************************************
***
**       Misc initializations
***
***********************************************************************
         SPACE 2
*
** Load external modules
*
         ICM   R0,B'1111',=V(DA$DATE)     Is it linked into us?
         BNZ   I$DATES                    Yes, use it
         LA    R8,=CL8'DA$DATE'           Locate module name
         LOAD  EPLOC=(8),ERRET=I$DATEX    Load it
         OI    FLAG2,$F2LDATE             Indicate we loaded it
I$DATES  EQU   *
         ST    R0,EP_DA$DATE              Save entry point address
I$DATEX  EQU   *
*
         ICM   R0,B'1111',=V(DA$MXD)      Is it linked into us?
         BNZ   I$MXDS                     Yes, use it
         LA    R8,=CL8'DA$MXD'            Locate module name
         LOAD  EPLOC=(8),ERRET=I$MXDX     Load it
         OI    FLAG2,$F2LMXD              Indicate we loaded it
I$MXDS   EQU   *
         ST    R0,EP_DA$MXD               Save entry point address
I$MXDX   EQU   *
*
         ICM   R0,B'1111',=V(ISPLINK)     Is it linked into us?
         BNZ   I$ISPLS                    Yes, use it
         LA    R8,=CL8'ISPLINK'           Locate module name
         LOAD  EPLOC=(8),ERRET=I$ISPLE    Load it
         OI    FLAG2,$F2LISPL             Indicate we loaded it
         B     I$ISPLS
I$ISPLE  DS    0H
 ABEND 1
I$ISPLS  DS    0H
         ST    R0,EP_ISPLINK              Save entry point address
I$ISPLX  EQU   *
*
** Obtain storage for Unknown record count
*
         LA    R0,256*4                   Set length of table
         GETMAIN R,LV=(0)                 Obtain storage
         STM   R0,R1,URCT_ST              Save length and address
         LR    R14,R1                     To: Address
         LR    R15,R0                     To: Length
         SLR   R1,R1                      From: Set length and pad
         MVCL  R14,R0                     Zero out table
*
** Obtain storage for CPU count table
*
         LA    R0,#MAXCPUN*CPUCL          Set length of table
         GETMAIN R,LV=(0)                 Obtain storage
         STM   R0,R1,CPUC_ST              Save length and address
         MVI   0(R1),X'FF'                Set end of table
         AR    R1,R0                      Locate end of storage area
         SH    R1,=AL2(CPUCL)             Backup to last entry
         BCTR  R1,0                       Backup 1
         ST    R1,CPUC_END                Save it
*
** Misc inits
*
         MVC   PAR_SDAT(10),=10X'FF'        Ensure first check works
*
** Define row variables for LRSTABLE and obtain table name
*
*->      VDEFINE '(LRSTIME)',LRSTIME,CHAR,11,MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VDEFINE',       Define variable              @
               =C'(LRSTIME)',             ..Name                       @
               LRSTIME,                   ..Location                   @
               =CL8'CHAR',                ..Format                     @
               =F'11'),                   ..Length                     @
               VL,MF=(E,PARMLIST)         ..Execute from here
*->      VDEFINE '(LRSDATEJ)',LRSDATEJ,CHAR,6,MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VDEFINE',       Define variable              @
               =C'(LRSDATEJ)',            ..Name                       @
               LRSDATEJ,                  ..Location                   @
               =CL8'CHAR',                ..Format                     @
               =F'6'),                    ..Length                     @
               VL,MF=(E,PARMLIST)         ..Execute from here
*->      VDEFINE '(LRSDATEG)',LRSDATEG,CHAR,8,MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VDEFINE',       Define variable              @
               =C'(LRSDATEG)',            ..Name                       @
               LRSDATEG,                  ..Location                   @
               =CL8'CHAR',                ..Format                     @
               =F'10'),                   ..Length                     @
               VL,MF=(E,PARMLIST)         ..Execute from here
*->      VDEFINE '(LRSDAY)',LRSDAY,CHAR,3,MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VDEFINE',       Define variable              @
               =C'(LRSDAY)',              ..Name                       @
               LRSDAY,                    ..Location                   @
               =CL8'CHAR',                ..Format                     @
               =F'3'),                    ..Length                     @
               VL,MF=(E,PARMLIST)         ..Execute from here
*->      VDEFINE '(LRSBTIME)',LRSBTIME,FIXED,4,MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VDEFINE',       Define variable              @
               =C'(LRSBTIME)',            ..Name                       @
               LRSBTIME,                  ..Location                   @
               =CL8'FIXED',               ..Format                     @
               =F'4'),                    ..Length                     @
               VL,MF=(E,PARMLIST)         ..Execute from here
*->      VDEFINE '(LRSBDATE)',LRSBDATE,FIXED,4,MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VDEFINE',       Define variable              @
               =C'(LRSBDATE)',            ..Name                       @
               LRSBDATE,                  ..Location                   @
               =CL8'FIXED',               ..Format                     @
               =F'4'),                    ..Length                     @
               VL,MF=(E,PARMLIST)         ..Execute from here
*->      VDEFINE '(LRSDAYN)',LRSDAYN,FIXED,1,MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VDEFINE',       Define variable              @
               =C'(LRSDAYN)',             ..Name                       @
               LRSDAYN,                   ..Location                   @
               =CL8'FIXED',               ..Format                     @
               =F'1'),                    ..Length                     @
               VL,MF=(E,PARMLIST)         ..Execute from here
*->      VDEFINE '(LRSTYPE)',LRSTYPE,CHAR,8,MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VDEFINE',       Define variable              @
               =C'(LRSTYPE)',             ..Name                       @
               LRSTYPE,                   ..Location                   @
               =CL8'CHAR',                ..Format                     @
               =F'8'),                    ..Length                     @
               VL,MF=(E,PARMLIST)         ..Execute from here
*->      VDEFINE '(LRSJOBN)',LRSJOBN,CHAR,8,MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VDEFINE',       Define variable              @
               =C'(LRSJOBN)',             ..Name                       @
               LRSJOBN,                   ..Location                   @
               =CL8'CHAR',                ..Format                     @
               =F'8'),                    ..Length                     @
               VL,MF=(E,PARMLIST)         ..Execute from here
*->      VDEFINE '(LRSCOMP)',LRSCOMP,CHAR,8,MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VDEFINE',       Define variable              @
               =C'(LRSCOMP)',             ..Name                       @
               LRSCOMP,                   ..Location                   @
               =CL8'CHAR',                ..Format                     @
               =F'8'),                    ..Length                     @
               VL,MF=(E,PARMLIST)         ..Execute from here
*->      VDEFINE '(LRSCSCT)',LRSCSCT,CHAR,8,MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VDEFINE',       Define variable              @
               =C'(LRSCSCT)',             ..Name                       @
               LRSCSCT,                   ..Location                   @
               =CL8'CHAR',                ..Format                     @
               =F'8'),                    ..Length                     @
               VL,MF=(E,PARMLIST)         ..Execute from here
*->      VDEFINE '(LRSREAS)',LRSREAS,CHAR,8,MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VDEFINE',       Define variable              @
               =C'(LRSREAS)',             ..Name                       @
               LRSREAS,                   ..Location                   @
               =CL8'CHAR',                ..Format                     @
               =F'8'),                    ..Length                     @
               VL,MF=(E,PARMLIST)         ..Execute from here
*->      VDEFINE '(LRSCPU)',LRSCPU,CHAR,8,MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VDEFINE',       Define variable              @
               =C'(LRSCPU)',              ..Name                       @
               LRSCPU,                    ..Location                   @
               =CL8'CHAR',                ..Format                     @
               =F'8'),                    ..Length                     @
               VL,MF=(E,PARMLIST)         ..Execute from here
*->      VDEFINE '(LRSSEQN)',LRSSEQN,CHAR,5,MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VDEFINE',       Define variable              @
               =C'(LRSSEQN)',             ..Name                       @
               LRSSEQN,                   ..Location                   @
               =CL8'CHAR',                ..Format                     @
               =F'5'),                    ..Length                     @
               VL,MF=(E,PARMLIST)         ..Execute from here
*->      VDEFINE '(LRSDESC)',LRSDESC,CHAR,256,MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VDEFINE',       Define variable              @
               =C'(LRSDESC)',             ..Name                       @
               LRSDESC,                   ..Location                   @
               =CL8'CHAR',                ..Format                     @
               =F'256'),                  ..Length                     @
               VL,MF=(E,PARMLIST)         ..Execute from here
*->      VCOPY '(LRSTABLE)',=F'8',LRSTABLE,MOVE,MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VCOPY',         Service: VCOPY               @
               =C'(LRSTABLE)',            ..Name                       @
               =F'8',                     ..Length                     @
               LRSTABLE,                  ..Location                   @
               =CL8'MOVE'),               ..Type: Move or copy         @
               VL,MF=(E,PARMLIST)         ..Execute from here
*
** ZENVIR on TSO:   "ISPF 4.5MVS     BATCH"
** ZENVIR in Batch: "ISPF 4.5MVS     BATCH"
**                   0....+....1....+....2....
*
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VCOPY',         Service: VCOPY               @
               =C'(ZENVIR)',              ..Name                       @
               =F'32',                    ..Length                     @
               ZENVIR,                    ..Location                   @
               =CL8'MOVE'),               ..Type: Move or copy         @
               VL,MF=(E,PARMLIST)         ..Execute from here
         EJECT
***********************************************************************
***
**       Initialize CPU table
**
** The next step is to getmain a table and merge the entries from
** the internal and external tables.
***
***********************************************************************
         SPACE 2
INITIALIZE_CPU_TABLE EQU *
*
** Locate internal table
*
         L     R15,=V(CPUS)               Locate CPUs CSECT
         LA    R15,8(R15)                 Bump past eyecatcher
         ST    R15,CPUS_ST+4              Save address of internal
*
** See if the external table is available, verify that it looks
** valid and save address for later
*
*->      VCOPY '(DA#LRSC)',DA#LRSCL,DA#LRSCA,LOCATE,MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VCOPY',         Service: VCOPY               @
               =C'(DA#LRSC)',             ..Name                       @
               DA#LRSCL,                  ..Length                     @
               DA#LRSCA,                  ..Location                   @
               =CL8'LOCATE'),             ..Type: Move or copy         @
               VL,MF=(E,PARMLIST)         ..Execute from here
         ICM   R14,B'1111',DA#LRSCA       Have a variable address?
         BZ    ICT$X                      No, give up
         ICM   R15,B'1111',DA#LRSCL       Have a variable length?
         BZ    ICT$X                      No, give up
         CH    R15,=AL2(8+CPUSNL+4)       Minimum length?
         BZ    ICT$TE                     Nope, leave
         CLC   0(8,R14),=CL8'CPUS4LRS'    Looks like our variable?
         BNE   ICT$X                      Nope.
         LA    R14,8(R14)                 Bump past header
         SH    R15,=H'8'                  Decrement for header length
ICT$L    EQU   *
         CLC   0(4,R14),=X'FF,FF,FF,FF'   Ending?
         BE    ICT$LOK                    Yes, looks good
         LA    R14,CPUSNL(R14)            No, bump to next entry
         SH    R15,=AL2(CPUSNL)           Decrement length of entry
         LTR   R15,R15                    Any length left?
         BNZ   ICT$L                      Yes, continue
ICT$TE   EQU   *
* Note: we could put something here to let the user know that the
* table looks invalid
         B     ICT$X                      No, give up
ICT$LOK  EQU   *
         L     R1,DA#LRSCA                Locate variable again
         LA    R1,8(R1)                   Bump past header
         ST    R1,CPUS_ST+4               Save address for override
*
** Common exit from Initialize_CPU_Table processing
*
ICT$X    EQU   *
         EJECT
***********************************************************************
***
**       Open files
***
***********************************************************************
         SPACE 2
*
** Open the (required) input ACCIN file
*
         LA    R3,ACCIN                   Locate DCB work area
         MVC   0(C_DCBIL,R3),C_DCBI       Initialize DCB area
         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'ACCIN'    Get DDNAME
         MVC   ACCINE(C_DCBIEL),C_DCBIE    Initialize DCBE
         LA    R14,ACCINE
         ST    R14,DCBDCBE-IHADCB(R3)     Save DCBE ptr in DCB
         OI    DCBBFALN-IHADCB(R3),DCBH1+DCBH0 Indicate DCBE is there
         MVC   PARMLIST(C_LSTIL),C_LSTI   Initialize parameter list
         OPEN  ((3),(INPUT)),MODE=31,MF=(E,PARMLIST) Open ACCIN
*
** Open the (optional) output debug file (DD=DA$EREP) if allocated
*
         DEVTYPE =CL8'DA$EREP',DOUBLE     Is file allocated?
         LTR   R15,R15
         BNZ   OF$DBX
         LA    R3,DEBUGOUT                Locate DCB work area
         MVC   0(C_DCBOL,R3),C_DCBO       Initialize DCB area
         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'DA$EREP'  Get DDNAME
         MVC   DEBUGOUE(C_DCBOEL),C_DCBOE    Initialize DCBE
         LA    R14,DEBUGOUE
         ST    R14,DCBDCBE-IHADCB(R3)     Save DCBE ptr in DCB
*        OI    DCBBFALN-IHADCB(R3),DCBH1+DCBH0 Indicate DCBE is there
         MVC   PARMLIST(C_LSTOL),C_LSTO   Initialize parameter list
         OPEN  ((3),(OUTPUT)),MODE=31,MF=(E,PARMLIST) Open Debug file
         OI    FLAG2,$F2DEBUG
         DEVTYPE =CL8'DA$EREPD',DOUBLE    Is file allocated?
         LTR   R15,R15
         BNZ   OF$DBX
         OI    FLAG2,$F2DUMP              Dump records to //DA$EREP
OF$DBX   DS    0H
         EJECT
***********************************************************************
***
**       Process all ACCIN records
***
***********************************************************************
         SPACE 2
PROCESS_ACCIN_RECORD EQU *
*
** Read record from ACCIN file
*
PAR$RR   EQU   *
         GET   ACCIN                      Get record from //ACCIN
         LR    R2,R1                      Save Software record
         LA    R3,ESRSFT-ESR(R2)          Locate SFT part of rec.
*
         L     R1,PAR_RECNUM              Physical Record number
         LA    R1,1(R1)                   Add one (duh)
         ST    R1,PAR_RECNUM              Save it
*
** Initialize row fields
*
         MVI   LRSTROW,C' '               Get blank
         MVC   LRSTROW+1(LRSTROWL-1),LRSTROW ..Propagate it
         MVI   LRSDESC,C' '               Get blank
         MVC   LRSDESC+1(L'LRSDESC-1),LRSDESC ..Propagate it
         MVC   LRSBTIME(4),SFTTIME-SFT(R3)
         MVC   LRSBDATE(4),SFTDATE-SFT(R3)
*
** Date Windowing code to correct for IBM's creating EREP records
** after 1999-12-31 which are 1900 instead of 2000
*
         MVI   CENT1900,C' '
         CLC   LRSBDATE(4),=X'0065001F'       Below 1965?
         BH    PAR$DWX
         MVI   LRSBDATE,X'01'                 Make it 2000
*-Non-essential code for trivial pursuits
         L     R1,PAR_C1900
         LA    R1,1(R1)
         ST    R1,PAR_C1900
         MVI   CENT1900,C'*'
PAR$DWX  DS    0H
*
** Time - HH:MM:SS.th
*
*->      TM    SFTTIME+3-SFT(R3),B'00001111'  Looks right?
*->      BNO   PAR$TEX
         MVC   LRSTIME-1(12),=X'F021207A20207A20204B2020'
         ED    LRSTIME-1(12),SFTTIME-SFT(R3)
PAR$TEX  EQU   *
*
** Date - YY.DDD and optional DayOfWeek and gregorian date
*
*->      TM    SFTDATE+3-SFT(R3),B'00001111'  Looks right?
*->      BNO   PAR$DEX
         MVC   LRSDATEJ-1(7),=X'F021204B202020'
         ED    LRSDATEJ-1(7),LRSBDATE+1
*        MVI   LRSDATEJ+2,C'.'            "yy.ddd"
PAR$DEX  EQU   *
*
         ICM   R15,B'1111',EP_DA$DATE     Date routine available?
         BNZ   PAR$GD                     Yes, continue
PAR$DB   EQU   *
         MVC   LRSDATEG(3),=C'N/A'        Indicate that no Greg. date
         MVC   LRSDAY(3),=C'N/A'          Indicate that no Day of week
         B     PAR$GDX                    Continue
PAR$GD   EQU   *
*
         TM    LRSBDATE+0,B'10100000' X'A0'          ! Julian format
         BO    PAR$DB                                ! Julian format
         TM    LRSBDATE+0,B'00001010' X'0A'          ! Julian format
         BO    PAR$DB                                ! Julian format
         TM    LRSBDATE+1,B'10100000' X'A0'          ! Julian format
         BO    PAR$DB                                ! Julian format
         TM    LRSBDATE+1,B'00001010' X'0A'          ! Julian format
         BO    PAR$DB                                ! Julian format
         TM    LRSBDATE+2,B'10100000' X'A0'          ! Julian format
         BO    PAR$DB                                ! Julian format
         TM    LRSBDATE+2,B'00001010' X'0A'          ! Julian format
         BO    PAR$DB                                ! Julian format
         TM    LRSBDATE+3,B'10100000' X'A0'          ! Julian format
         BO    PAR$DB                                ! Julian format
         TM    LRSBDATE+3,B'00001010' X'0A'          ! Julian format
         BNO   PAR$DB                                ! Julian format
*
         MVC   W_IDJULP4A(C_IDJULP4AL),C_IDJULP4A Initialize parm
         LA    R1,LRSBDATE                Locate input julian date
         ST    R1,W_IDJULP4A_STR          Save it
         MVC   W_ODISO10A(C_ODISO10AL),C_ODISO10A Initialize parm
         LA    R1,LRSDATEG                Locate output area
         ST    R1,W_ODISO10A_STR          Save it
         MVC   W_ODDOW3A(C_ODDOW3AL),C_ODDOW3A Initialize parm
         LA    R1,LRSDAY                  Locate output area
         ST    R1,W_ODDOW3A_STR           Save it
         MVC   W_ODDOW1A(C_ODDOW1AL),C_ODDOW1A Initialize parm
         LA    R1,LRSDAYN                 Locate output area
         ST    R1,W_ODDOW1A_STR           Save it
*
         L     R15,EP_DA$DATE             Locate EPA of DA$DATE
         CALL  (15),(W_IDJULP4A,W_ODISO10A,W_ODDOW3A,W_ODDOW1A),       @
               VL,MF=(E,PARMLIST)
PAR$GDX  EQU   *
*
** Change CPU serial number to a name for ease of use
*
         UNPK  LRSCPU(7),SFTSER-SFT(4,R3)       >
         MVZ   LRSCPU(6),=8X'00'                >> Hex convert
         TR    LRSCPU(6),=C'0123456789ABCDEF'   >
*
         ICM   R15,B'1111',CPUS_ST+4      Have CPU information?
         BZ    PAR$CPUE                   No, insert number
PAR$CPUL EQU   *
         CLC   LRSCPU(6),CPUSNS-CPUSN(R15) Serial match?
         BE    PAR$CPUF                   Yes, continue
         LA    R15,CPUSNL(R15)            No, try next entry
         CLC   0(4,R15),=X'FF,FF,FF,FF'   End of table?
         BNE   PAR$CPUL                   No, try it out
PAR$CPUE EQU   *                          123456x
         MVI   LRSCPU+6,C' '              Fix byte after UNPK
         B     PAR$CPUT
PAR$CPUF EQU   *
         MVC   LRSCPU(8),CPUSNN-CPUSN(R15) Get name from table
PAR$CPUT EQU   *
*
** Add new CPU count entry or find existing entry for this CPU
*
         L     R5,CPUC_ST+4               Locate CPU Count table
PAR$CPUTL EQU  *
         CLI   0(R5),X'FF'                End of table?
         BE    PAR$CPUTI                  Yes, new guy
         CLC   CPUCN-CPUC(8,R5),LRSCPU    Match?
         BE    PAR$CPUTX                  Yes, we have good entry
         LA    R5,CPUCL(R5)               No, bump to next one
         C     R5,CPUC_END                About to overflow
         BL    PAR$CPUTL                  No, continue
         SH    R5,=AL2(CPUCL)             Backup to last entry
         MVC   CPUCN-CPUC(8,R5),=CL8'*Error*' Mark as invalid!
         OI    FLAG1,$F1CPUCO             Indicate overflag
         B     PAR$CPUTX                  and count no mo'
PAR$CPUTI EQU  *
         XC    0(CPUCL,R5),0(R5)          Clear storage
         MVC   CPUCN-CPUC(8,R5),LRSCPU    Move in CPU
         MVI   CPUCL(R5),X'FF'            Mark next entry as end
PAR$CPUTX EQU  *                          R5 now has CPUC entry...
*
** Update total count for this CPU
*
         SLR   R1,R1
         ICM   R1,B'0011',CPUCTOTL-CPUC(R5) Get total count
         LA    R1,1(R1)                     Increment by one
         STCM  R1,B'0011',CPUCTOTL-CPUC(R5) Save total count
*
** Determine record type
*
         SLR   R1,R1                      Clear register for count
         CLI   SFTKEY1-SFT(R3),X'40'
         BE    PAR$ABN
         CLI   SFTKEY1-SFT(R3),X'42'
         BE    PAR$PI
*        CLI   SFTKEY1-SFT(R3),X'44'
*        BE    PAR$RST
*        CLI   SFTKEY1-SFT(R3),X'48'
*        BE    PAR$MCH
         CLI   SFTKEY1-SFT(R3),X'4C'
         BE    PAR$SYM
         CLI   SFTKEY1-SFT(R3),X'4F'
         BE    PAR$LOST
         CLI   SFTKEY1-SFT(R3),X'50'
         BE    PAR$IPL
         CLI   SFTKEY1-SFT(R3),X'80'
         BE    PAR$EOD
         CLI   SFTKEY1-SFT(R3),X'81'
         BE    PAR$EOD81
         CLI   SFTKEY1-SFT(R3),X'84'
         BE    PAR$EOD84
*-Here are some "new" ones that I don't handle well yet
         CLI   SFTKEY1-SFT(R3),X'30'
         BE    PAR$OBR
         CLI   SFTKEY1-SFT(R3),X'71'
         BE    PAR$MIH
         CLI   SFTKEY1-SFT(R3),X'90'
         BE    PAR$SVC91
         CLI   SFTKEY1-SFT(R3),X'91'
         BE    PAR$MDR
*
PAR$IGNORE DS  0H
         SLR   R1,R1                      Clear register
         IC    R1,SFTKEY1-SFT(R3)         Get record type
         L     R14,URCT_ST+4              Locate table
         MH    R1,=H'4'                   Get offset of entry
         AR    R1,R14                     Locate entry
         L     R15,0(R1)                  Get current count
         LA    R15,1(R15)                 Increment by 1
         ST    R15,0(R1)                  Save current count
         B     PAR$RR
*
** Symptom record
*
PAR$SYM  EQU   *
         ICM   R1,B'0011',CPUCSYM-CPUC(R5)   Get current count
         LA    R1,1(R1)                      Increment by 1
         STCM  R1,B'0011',CPUCSYM-CPUC(R5)   Save new count
         MVC   LRSTYPE(7),=C'SYMPTOM'        Indicate type
*
         LA    R4,SFTHEADE-SFT(R3)           Locate ADSR
         CLC   ADSRID-ADSR(2,R4),=C'SR'      Have a valid ADSR ID?
         BNE   PAR$SYME                      No, leave
*
         SLR   R1,R1                         Clear register
         ICM   R1,B'0011',ADSRCSO-ADSR(R4)   Get offset of ADSRCMPS
         BZ    PAR$SYM_CSOX                  None!
         AR    R1,R4                         Locate ADSRCMPS
         CLI   ADSRCDSC-ADSRCMPS(R1),0       Have a Text description?
         BE    PAR$SYM_CDSCX                 No, continue
         MVC   LRSDESC(L'ADSRCDSC),ADSRCDSC-ADSRCMPS(R1)
PAR$SYM_CDSCX EQU *
*
         CLI   ADSRPRID-ADSRCMPS(R1),0       Have a Problem ID?
         BE    PAR$SYM_PRIDX                 No, continue
         MVC   LRSCOMP(L'LRSCOMP),ADSRPRID-ADSRCMPS(R1)
PAR$SYM_PRIDX EQU *
*
         CLI   ADSRPTF-ADSRCMPS(R1),0        Have a PTF?
         BE    PAR$SYM_PTF                   No, continue
         MVC   LRSCSCT(L'LRSCSCT),ADSRPTF-ADSRCMPS(R1)
PAR$SYM_PTF EQU *
*
         CLI   ADSRSSID-ADSRCMPS(R1),0       Have a SubSystem?
         BE    PAR$SYM_SSIDE                 No, continue
         MVC   LRSJOBN(L'LRSJOBN),ADSRSSID-ADSRCMPS(R1)
         B     PAR$SYM_SSIDX                 Thru...
PAR$SYM_SSIDE EQU *
         LA    R14,T_CID                     Get table address
         LA    R15,T_CIDN                    Get length of table
PAR$SYM_SSIDL EQU *
         CLC   ADSRCID-ADSRCMPS(9,R1),TCID_ID-TCID(R14) Match?
         BNE   PAR$SYM_SSIDB                         No, continue
         MVC   LRSJOBN(L'LRSJOBN),TCID_NM-TCID(R14)  Yes, get name
         B     PAR$SYM_SSIDX                 Continue
PAR$SYM_SSIDB  EQU *
         LA    R14,TCIDL(R14)                Bump to next entry
         BCT   R15,PAR$SYM_SSIDL             and process it
         MVC   LRSJOBN(8),ADSRCID-ADSRCMPS(R1)  Not in table...
PAR$SYM_SSIDX EQU *
*
PAR$SYM_CSOX  EQU *
* Note: Could access the ADSRDBO, ADSROSA and ADSRRONA here...
         B    PAR$SYMX
PAR$SYME EQU  *
         MVC  LRSDESC(19),=C'Invalid ADSR found!'
PAR$SYMX EQU  *
         B     PAR$TADD
*
** ABEND
*
PAR$ABN  EQU   *
         ICM   R1,B'0011',CPUCABN-CPUC(R5) Get current count
         LA    R1,1(R1)                    Increment by 1
         STCM  R1,B'0011',CPUCABN-CPUC(R5) Save new count
         MVC   LRSTYPE(5),=C'ABEND'
         B     PAR$SDWA
*
** Program Interrupt
*
PAR$PI   EQU   *
         ICM   R1,B'0011',CPUCPI-CPUC(R5) Get current count
         LA    R1,1(R1)                   Increment by 1
         STCM  R1,B'0011',CPUCPI-CPUC(R5) Save new count
         MVC   LRSTYPE(7),=C'PROGINT'
         B     PAR$SDWA
*
** Lost record
*
PAR$LOST EQU   *
         ICM   R1,B'0011',CPUCLOST-CPUC(R5)  Get current count
         LA    R1,1(R1)                      Increment by 1
         STCM  R1,B'0011',CPUCLOST-CPUC(R5)  Save new count
         MVC   LRSTYPE(7),=C'LOSTREC'     Set type
         SLR   R1,R1                      Clear register
         IC    R1,RCBLCNT-SFT(R3)         Get number of lost records
         LA    R15,LRSREAS                Locate output field
         MVC   0(2,R15),=C'N='            Insert text
         LA    R15,2(R15)                 Bump past it
         BAS   R9,EDITFWF                 Edit the number
         B     PAR$TADD                   Continue
*
** IPL performed
*
PAR$IPL  EQU   *
         ICM   R1,B'0011',CPUCIPL-CPUC(R5)   Get current count
         LA    R1,1(R1)                      Increment by 1
         STCM  R1,B'0011',CPUCIPL-CPUC(R5)   Save new count
         MVC   LRSTYPE(3),=C'IPL'
*
         CLI   IPLSYSID-SFT(R3),0         Null?
         BE    PAR$ISX                    Yes, leave
         LA    R1,T_IPLS                  Locate table
         LA    R0,T_IPLSN                 Number in table
PAR$ISL  EQU   *
         CLC   0(1,R1),IPLSYSID-SFT(R3)   Match?
         BE    PAR$ISF                    Yes, continue
         LA    R1,1+8(R1)                 No, bump to next one
         BCT   R0,PAR$ISL                 Process next entry
         UNPK  LRSCSCT(3),IPLSYSID-SFT(2,R3)
         MVZ   LRSCSCT(2),=8X'00'
         TR    LRSCSCT(2),=C'0123456789ABCDEF'
         MVC   LRSCSCT+2(4),=C'=SID'      Insert text
         B     PAR$ISX                    Leave
PAR$ISF  EQU   *
         MVC   LRSCSCT(8),1(R1)
PAR$ISX  EQU   *
*
         LA    R1,T_IPLR                  Locate table
         LA    R0,T_IPLRN                 Number in table
PAR$IRL  EQU   *
         CLC   TIPLRR-TIPLR(2,R1),IPLREAS-SFT(R3)  Reason match?
         BE    PAR$IRF                    Yes, continue
         LA    R1,TIPLRL(R1)              No, bump to next one
         BCT   R0,PAR$IRL                 Process next entry
         UNPK  LRSCOMP(3),IPLREAS-SFT(2,R3)
         MVZ   LRSCOMP(2),=8X'00'
         TR    LRSCOMP(2),=C'0123456789ABCDEF'
         MVC   LRSCOMP+2(5),=C'=REAS'     Insert text
         B     PAR$IRMX
PAR$IRF  EQU   *
         MVC   LRSCOMP(8),TIPLRC-TIPLR(R1)  Move in Comp
PAR$IRMX EQU   *
         SLR   R14,R14                    Clear register
         ICM   R14,B'0011',TIPLRD-TIPLR(R1) Get offset
         AR    R14,R1                     Locate description string
         SLR   R15,R15                    Clear register
         IC    R15,0(R14)                 Get length of string
         CH    R15,=AL2(L'LRSDESC)        Too long?
         BNH   PAR$IRDL                   No, continue
         LA    R15,L'LRSDESC              Yes, set to max length
PAR$IRDL EQU   *
         BCTR  R15,0                      Decrement for EX
         EX    R15,PAR$IRM                Move description out
         B     PAR$TADD
PAR$IRM  MVC   LRSDESC(0),1(R14)          Move description out
*
** EOD
*
PAR$EOD81 EQU  *
         MVC   LRSTYPE+3(4),=C'-NRS'      Non-Restartable
         B     PAR$EOD
PAR$EOD84 EQU  *
         MVC   LRSTYPE+3(4),=C'-RWS'      Restartable Wait State
PAR$EOD  EQU   *
         MVC   LRSTYPE(3),=C'EOD'
         ICM   R1,B'0011',CPUCZEOD-CPUC(R5)  Get current count
         LA    R1,1(R1)                      Increment by 1
         STCM  R1,B'0011',CPUCZEOD-CPUC(R5)  Save new count
*
         LH    R1,ESRRDW-ESR(R2)             Get length of record
         LA    R14,SFTHEADE-SFT+(ESRSFT-ESR) Get length without ext.
         CR    R1,R14                        Have an extension?
         BNH   PAR$TADD                      No, continue
*
         UNPK  LRSREAS(9),EODWSC-SFT(5,R3)
         MVZ   LRSREAS(8),=8X'00'
         TR    LRSREAS(8),=C'0123456789ABCDEF'
         B     PAR$TADD
*
** MIH
*
PAR$MIH  DS    0H
         MVC   LRSTYPE(3),=C'MIH'
         MVC   LRSTYPE(3),=C'MDR'
         B     PAR$IGNORE
*
** OBR
*
PAR$OBR  DS    0H
         MVC   LRSTYPE(3),=C'OBR'
         BAS   R14,PAR$DBE              Print Debugging (if batch)
         B     PAR$IGNORE
*
** SVC 91
*
PAR$SVC91 DS   0H
         MVC   LRSTYPE(5),=C'SVC91'
         BAS   R14,PAR$DBE              Print Debugging (if batch)
         B     PAR$IGNORE
*
** MDR
*
PAR$MDR  DS    0H
         MVC   LRSTYPE(3),=C'MDR'
         BAS   R14,PAR$DBE              Print Debugging (if batch)
         B     PAR$IGNORE
*
** SDWA processing for software records
*
PAR$SDWA EQU   *
         MVC   LRSJOBN(8),SFTJOBID-SFT(R3)
         LA    R4,SFTSDWA-SFT(R3)         Locate SDWA (SFT only)
*
         UNPK  LRSREAS(9),SDWAABCC-SDWA(5,R4)
         MVZ   LRSREAS(8),=8X'00'
         TR    LRSREAS(8),=C'0123456789ABCDEF'
*
         MVC   LRSCOMP(8),SDWAMODN-SDWA(R4)
         MVC   LRSCSCT(8),SDWACSCT-SDWA(R4)
*
         TM    SFTSW2-SFT(R3),X'20'       Is there an ErrorID?
         BNO   PAR$EIX                    No, continue
         SLR   R1,R1                      Clear register
         ICM   R1,B'0011',ESRRDW-ESR(R2)  Get length of record
         AR    R1,R2                      Locate to end of record
         S     R1,=AL4(L'ESRERROR)        Backup to error ID
         SLR   R14,R14                    Clear register
         ICM   R14,B'0011',ESRESEQ-ESRERROR(R1) Get Sequence number
         CVD   R14,DOUBLE                 Convert to packed
         MVC   LRSSEQN-1(6),=X'F02020202020' Get edit pattern
         ED    LRSSEQN-1(6),DOUBLE+5      Edit number
PAR$EIX  DS    0H
*
** Format the SDWA VRA area
*
         TM    SDWADPVA-SDWA(R4),SDWAEBC  VRA in EBCDIC?
         BNO   PAR$SVX                    No, continue
         LA    R15,SFTSDWA-SFT(R3)        Locate SDWA
         TM    SDWADPVA-SDWA(R4),SDWAVRAM In IHAVRA format?
         BNO   PAR$SVOF                   No, continue
         LA    R15,SDWARA-SDWA(R4)        Locate IHAVRA area
         SLR   R1,R1                      Clear register
         ICM   R1,B'0001',VRALEN-VRAMAP(R15) Get length of VRADAT
         BZ    PAR$SVX                    None, leave
         LA    R15,VRADAT-VRAMAP(R15)     Locate data area
         B     PAR$SVD                    Continue
PAR$SVDM MVC   LRSDESC(0),0(R15)          Move data to desc. area
PAR$SVOF EQU   *
         SLR   R1,R1                      Clear register
         ICM   R1,B'0001',SDWAURAL-SDWA(R4) Get length of VRA
         BZ    PAR$SVX                    None, leave
         LA    R15,SDWAVRA-SDWA(R4)       Bump to variable area
PAR$SVD  EQU   *
         LA    R14,L'LRSDESC              Get max length of area
         CR    R1,R14                     Fits?
         BNH   PAR$SVDL                   Yes, continue
         LA    R1,L'LRSDESC               No, set to length of area
PAR$SVDL EQU   *
         BCTR  R1,0                       Decrement for EX
         EX    R1,PAR$SVDM                Move VRA to description
PAR$SVX  EQU   *
*
** Save summary information into in-core table
*
         ICM   R1,B'1111',SUMT_ST+4       Locate Summary table
         BNZ   PAR$SUML                   Already obtained, continue
         L     R0,=AL4(#MAXMOD*SUMTROWL)  Set length of table
         GETMAIN R,LV=(0)                 Obtain storage
         STM   R0,R1,SUMT_ST              Save length and address
         MVI   0(R1),X'FF'                Set end of table
         AR    R1,R0                      Locate end of storage area
         BCTR  R1,0                       Backup 1
         SH    R1,=AL2(SUMTROWL)          Backup to last entry
         ST    R1,SUMT_END                Save it
         L     R1,SUMT_ST+4               Locate Summary table
         B     PAR$SUMA                   Add first entry
PAR$SUML EQU   *
         CLI   0(R1),X'FF'                At end of table
         BE    PAR$SUMA                   Yes, add new entry...
* Check for a "Component/Module - CSECT" - Reason match
         CLC   SUMMOD-SUMTROW(1,R1),LRSCOMP
         BNE   PAR$SUMB
         CLC   SUMMOD+1-SUMTROW(7,R1),LRSCOMP+1
         BNE   PAR$SUMB
         CLC   SUMCSCT-SUMTROW(1,R1),LRSCSCT
         BNE   PAR$SUMB
         CLC   SUMCSCT+1-SUMTROW(7,R1),LRSCSCT+1
         BNE   PAR$SUMB
         CLC   SUMREAS-SUMTROW(1,R1),LRSREAS
         BNE   PAR$SUMB
         CLC   SUMREAS+1-SUMTROW(7,R1),LRSREAS+1
         BNE   PAR$SUMB
*
         ICM   R15,B'1111',SUMCOUNT-SUMTROW(R1) Get count
         LA    R15,1(R15)                       Increment by 1
         STCM  R15,B'1111',SUMCOUNT-SUMTROW(R1) Save new count
         CLC   LRSDATEG(L'LRSDATEG),SUMSDATG-SUMTROW(R1)
         BNL   PAR$SSDX
         MVC   SUMSDATG-SUMTROW(L'SUMSDATG,R1),LRSDATEG
         MVC   SUMSDATD-SUMTROW(L'SUMSDATD,R1),LRSDAY
PAR$SSDX EQU   *
         CLC   LRSDATEG(L'LRSDATEG),SUMEDATG-SUMTROW(R1)
         BL    PAR$SEDX                         No, continue
         MVC   SUMEDATG-SUMTROW(L'SUMEDATG,R1),LRSDATEG
         MVC   SUMEDATD-SUMTROW(L'SUMEDATD,R1),LRSDAY
PAR$SEDX EQU   *
         B     PAR$SUMX                   We are finished with summary
*
PAR$SUMB EQU   *
         LA    R1,SUMTROWL(R1)            Bump to next entry
         C     R1,SUMT_END                End of table?
         BL    PAR$SUML                   No, continue
         OI    FLAG1,$F1SUMTO             Yes, set overflow flag
         B     PAR$SUMX                   Continue
*
PAR$SUMA EQU   *                          Add new entry to table
         XC    0(SUMTROWL,R1),0(R1)       Clear table entry
         MVC   SUMMOD-SUMTROW(L'SUMMOD,R1),LRSCOMP
         MVC   SUMCSCT-SUMTROW(L'SUMCSCT,R1),LRSCSCT
         MVC   SUMREAS-SUMTROW(L'SUMREAS,R1),LRSREAS
         MVC   SUMSDATG-SUMTROW(L'SUMSDATG,R1),LRSDATEG
         MVC   SUMSDATD-SUMTROW(L'SUMSDATD,R1),LRSDAY
         MVC   SUMEDATG-SUMTROW(L'SUMEDATG,R1),LRSDATEG
         MVC   SUMEDATD-SUMTROW(L'SUMEDATD,R1),LRSDAY
         MVI   SUMCOUNT+L'SUMCOUNT-1-SUMTROW(R1),1
         MVI   SUMTROWL(R1),X'FF'         Set new end of table
PAR$SUMX EQU   *
*
** Add entry to table
*
PAR$TADD EQU   *
         OC    LRSCOMP(8),=CL8' '         Ensure uppercase
         OC    LRSCSCT(8),=CL8' '         Ensure uppercase
*->      TBADD LRSTABLE,MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'TBADD',         Service: TBADD               @
               LRSTABLE),                 ..Table name                 @
               VL,MF=(E,PARMLIST)         ..Execute from here
         LTR   R15,R15
         BZ    PAR$TADDX
 ST R15,DOUBLE
 UNPK DEBUGMSG(9),DOUBLE(5)
 MVZ  DEBUGMSG(8),=8X'00'
 TR   DEBUGMSG(8),=C'0123456789ABCDEF'
 LA   R1,DEBUGMSG+8
 MVC  0(8,R15),=C'=TBADD: '
 LA   R15,8(R15)
 MVC  0(60,R15),LRSTROW
 TPUT DEBUGMSG,78
PAR$TADDX DS   0H
         BAS   R14,PAR$DBE             Print Debugging messages
*
** Save start and end dates of Logrec entries
**
** We only care about the ones we write out via TBADD...
*
         CLC   LRSDATEG(L'LRSDATEG),PAR_SDAT
         BNL   PAR$SDX
         MVC   PAR_SDAT(L'LRSDATEG),LRSDATEG
         MVC   PAR_SDAT+10(3),LRSDAY      Save Day of week
**
         TM    FLAG2,$F2DEBUG             Debugging?
         BNO   PAR$DBSX                   No, skip this code
         LA    R15,DEBUGMSG               Locate message area
         MVI   0(R15),C' '                Get blank
         MVC   1(132,R15),0(R15)          ..and propagate it
         MVC   0(30,R15),=C'This is the start date record:'
         MVC   32(L'PAR_SDAT,R15),PAR_SDAT
         PUT   DEBUGOUT,DEBUGMSG
PAR$DBSX DS    0H
**
PAR$SDX  EQU   *
         CLC   LRSDATEG(L'LRSDATEG),PAR_EDAT
         BL    PAR$EDX
         MVC   PAR_EDAT(L'LRSDATEG),LRSDATEG
         MVC   PAR_EDAT+10(3),LRSDAY      Save Day of week
PAR$EDX  EQU   *
*
** Display logo screen with current row information to let user
** know that we are doing something - at regular intervals...
*
         L     R1,PAR_TCNT                Get total add count
         LA    R1,1(R1)                   Increment by 1
         ST    R1,PAR_TCNT                Save total count
*
         CLI   ZENVIR+16,C'B'             Batch?
         BE    PAR$TACX                   Yes, skip this nonsense
*
         SLR   R0,R0                      Clear register
         D     R0,=AL4(#STATUSL)          Divide by display increment
         LTR   R0,R0                      Evenly?
         BNZ   PAR$TACX                   No, continue
         BAS   R9,INITIALIZE_LOGO_VARIABLES  Initialize to blanks
         LA    R15,STATUS                 Locate status line
*                           ....+....1....+....2....+....3....+.
         MVC   0(35,R15),=C'Reading LOGREC file - record number'
         LA    R15,36(R15)                Bump past text
         L     R1,PAR_TCNT                Get current count
         BAS   R9,EDITFWF                 Edit the number
*
         LA    R15,INFO1
         MVC   0(5,R15),=C'Time:'
         LA    R15,6(R15)
         MVC   0(L'LRSTIME,R15),LRSTIME
         LA    R15,L'LRSTIME+2(R15)
         MVC   0(5,R15),=C'Date:'
         LA    R15,6(R15)
         MVC   0(L'LRSDATEJ,R15),LRSDATEJ
         LA    R15,L'LRSDATEJ+1(R15)
         MVC   0(L'LRSDAY,R15),LRSDAY
         LA    R15,L'LRSDAY+1(R15)
         MVC   0(L'LRSDATEG,R15),LRSDATEG
         LA    R15,L'LRSDATEG+2(R15)
         MVC   0(5,R15),=C'Type:'
         LA    R15,6(R15)
         MVC   0(L'LRSTYPE,R15),LRSTYPE
         LA    R15,L'LRSTYPE+2(R15)
         MVC   0(4,R15),=C'CPU:'
         LA    R15,5(R15)
         MVC   0(L'LRSCPU,R15),LRSCPU
         LA    R15,L'LRSCPU+2(R15)
*
         LA    R15,INFO2
         MVC   0(L'LRSCOMP,R15),LRSCOMP
         LA    R15,L'LRSCOMP+2(R15)
         MVC   0(L'LRSCSCT,R15),LRSCSCT
         LA    R15,L'LRSCSCT+2(R15)
         MVC   0(L'LRSREAS,R15),LRSREAS
         LA    R15,L'LRSREAS+2(R15)
         MVC   0(L'LRSCOMP,R15),LRSCOMP
         LA    R15,L'LRSCOMP+2(R15)
*
         MVC   INFO3(L'INFO3),LRSDESC
*
*->      CONTROL DISPLAY,LOCK,MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'CONTROL',       Service: CONTROL             @
               =CL8'DISPLAY',             ..display                    @
               =CL8'LOCK'),               ..LOCK it                    @
               VL,MF=(E,PARMLIST)         ..Execute from here
*->      DISPLAY PANEL='LRS$LOGO',MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'DISPLAY',       Service: DISPLAY             @
               =CL8'LRS$LOGO'),           ..Panel name                 @
               VL,MF=(E,PARMLIST)         ..Execute from here
PAR$TACX EQU   *
*
** When we see the current date for the first time, save the
** row number for fast locate to the current date
*
         CLC   PAR_LDTV(4),LRSBDATE       Already seen this one?
         BE    PAR$RR                     Yes, continue
         MVC   PAR_LDTV(4),LRSBDATE       Save Date
         MVC   PAR_LDTR(4),PAR_TCNT       Save row number
         B     PAR$RR                     Continue
*
** Print Debugging message
*
PAR$DBE  DS    0H
         TM    FLAG2,$F2DEBUG             Debugging?
         BNO   PAR$DBEX                       No, skip this code!
         ST    R14,PAR_DBERA                  Save return address
*
         MVI   DEBUGMSG,C' '
         MVC   DEBUGMSG+1(132),DEBUGMSG
         PUT   DEBUGOUT,DEBUGMSG
*
         LA    R15,DEBUGMSG
         MVC   0(5,R15),=C'Date:'
         LA    R15,6(R15)
         MVC   0(L'LRSDATEG,R15),LRSDATEG
         LA    R15,L'LRSDATEG+1(R15)
         MVC   0(L'LRSDAY,R15),LRSDAY
         LA    R15,L'LRSDAY+1(R15)
#DBOFF   EQU   6+L'LRSDATEG+1+L'LRSDAY+1
         MVC   0(1,R15),CENT1900
         LA    R15,2(R15)
         MVC   0(4,R15),=C'Job:'
         LA    R15,5(R15)
         MVC   0(L'LRSJOBN,R15),LRSJOBN
         LA    R15,L'LRSJOBN+1(R15)
*-More here
         PUT   DEBUGOUT,DEBUGMSG
         MVI   DEBUGMSG,C' '
         MVC   DEBUGMSG+1(132),DEBUGMSG
         LA    R15,DEBUGMSG
         MVC   0(5,R15),=C'Time:'
         LA    R15,6(R15)
         MVC   0(L'LRSTIME,R15),LRSTIME
         LA    R15,L'LRSTIME+1(R15)
         LA    R15,DEBUGMSG+#DBOFF+1
         MVC   0(5,R15),=C'Comp:'
         LA    R15,6(R15)
         MVC   0(L'LRSCOMP,R15),LRSCOMP
         LA    R15,L'LRSCOMP+1(R15)
         MVC   0(5,R15),=C'Type:'
         LA    R15,6(R15)
         UNPK  0(3,R15),SFTKEY1-SFT(2,R3)
         MVZ   0(2,R15),=8X'00'
         TR    0(2,R15),=C'012345678ABCDEF'
         MVI   2(R15),C'/'
         LA    R15,3(R15)
         MVC   0(L'LRSTYPE,R15),LRSTYPE
         LA    R15,L'LRSTYPE+1(R15)
*-More here
         PUT   DEBUGOUT,DEBUGMSG
*
         TM    FLAG2,$F2DUMP              Dump
         BNO   PAR$DBDX
         MVI   DEBUGMSG,C' '
         MVC   DEBUGMSG+1(132),DEBUGMSG
         PUT   DEBUGOUT,DEBUGMSG
         LA    R15,DEBUGMSG
         MVC   0(21,R15),=C'Dump of record number'
         LA    R15,22(R15)
         L     R1,PAR_RECNUM              Get record number
         BAS   R9,EDITFWF
         MVC   1(5,R15),=C'Type='
         LA    R15,1+5(R15)
         UNPK  0(3,R15),SFTKEY1-SFT(2,R3)
         MVZ   0(2,R15),=8X'00'
         TR    0(2,R15),=C'012345678ABCDEF'
         MVI   2(R15),C'/'
         MVC   3(L'LRSTYPE,R15),LRSTYPE
         PUT   DEBUGOUT,DEBUGMSG
*
         XC    PARMLIST(CMXDL),PARMLIST   Initialize area
         LR    R15,R2                     Locate LOGREC record
         SLR   R0,R0
         ICM   R0,B'0011',0(R2)           Get length of Record
 SH    R0,=H'4' Fudge(BOZO)
         LA    R1,DEBUGMSG
         STM   R15,R1,PARMLIST+CMXD_ADDRESS-CMXD Data, Length, Output
PAR$DBEL DS    0H
         LA    R1,PARMLIST                Locate work area
         L     R15,EP_DA$MXD              -> DA$MXD E.P.A.
         BALR  R14,R15                    Call DA$MXD
         LR    R8,R15                     Save return code
         PUT   DEBUGOUT,DEBUGMSG          Print record
         LTR   R8,R8                      Any more lines to do...
         BNZ   PAR$DBEL                   Thank you: May I have another
PAR$DBDX DS    0H
         L     R14,PAR_DBERA              Get return address
PAR$DBEX DS    0H
         BSM   0,R14
*
** End of file on ACCIN file
*
PAR$EOF  EQU   *
         LA    R3,ACCIN                   Locate DCB
         MVC   PARMLIST(C_CLOSEL),C_CLOSE Initialize parameter list
         CLOSE ((3)),MODE=31,MF=(E,PARMLIST)  Close file
*
         FREEPOOL ACCIN                   Free buffer pool
*
** Create TSO variable with row number of latest date
*
         LA    R14,=C'LRSCDROW'           Locate variable name
         ST    R14,CTV_NAMEP              Save it
         LA    R14,8                      Set variable name length
         ST    R14,CTV_NAMEL              Save it
*
         LA    R15,CCL_LINE               Locate variable area
         L     R1,PAR_LDTR                Get row number
         BAS   R9,EDITNCF                 Edit the row number
         LA    R14,CCL_LINE               Get start
         SR    R15,R14                    Length = end - start
*
         LA    R1,CCL_LINE                Locate value
         LR    R0,R15                     Get length of value
         BAS   R9,CREATE_TSO_VARIABLE     Create TSO variable
         EJECT ,
***********************************************************************
***
** Create ISPF summary table from in-core summary table entries
***
***********************************************************************
         SPACE 2
CREATE_SUMMARY_TABLE EQU *
*
** Define row variables for SUMTABLE and obtain it's name
*
*->      VDEFINE '(SUMMOD)',SUMMOD,CHAR,8,MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VDEFINE',       Define variable              @
               =C'(SUMMOD)',              ..Name                       @
               SUMMOD,                    ..Location                   @
               =CL8'CHAR',                ..Format                     @
               =F'8'),                    ..Length                     @
               VL,MF=(E,PARMLIST)         ..Execute from here
*->      VDEFINE '(SUMCSCT)',SUMCSCT,CHAR,8,MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VDEFINE',       Define variable              @
               =C'(SUMCSCT)',             ..Name                       @
               SUMCSCT,                   ..Location                   @
               =CL8'CHAR',                ..Format                     @
               =F'8'),                    ..Length                     @
               VL,MF=(E,PARMLIST)         ..Execute from here
*->      VDEFINE '(SUMREAS)',SUMREAS,CHAR,8,MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VDEFINE',       Define variable              @
               =C'(SUMREAS)',             ..Name                       @
               SUMREAS,                   ..Location                   @
               =CL8'CHAR',                ..Format                     @
               =F'8'),                    ..Length                     @
               VL,MF=(E,PARMLIST)         ..Execute from here
*->      VDEFINE '(SUMSDATE)',SUMSDATE,CHAR,12,MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VDEFINE',       Define variable              @
               =C'(SUMSDATE)',            ..Name                       @
               SUMSDATE,                  ..Location                   @
               =CL8'CHAR',                ..Format                     @
               =F'14'),                   ..Length                     @
               VL,MF=(E,PARMLIST)         ..Execute from here
*->      VDEFINE '(SUMEDATE)',SUMEDATE,CHAR,12,MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VDEFINE',       Define variable              @
               =C'(SUMEDATE)',            ..Name                       @
               SUMEDATE,                  ..Location                   @
               =CL8'CHAR',                ..Format                     @
               =F'14'),                   ..Length                     @
               VL,MF=(E,PARMLIST)         ..Execute from here
*->      VDEFINE '(SUMCOUNT)',SUMCOUNT,FIXED,4,MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VDEFINE',       Define variable              @
               =C'(SUMCOUNT)',            ..Name                       @
               SUMCOUNT,                  ..Location                   @
               =CL8'FIXED',               ..Format                     @
               =F'4'),                    ..Length                     @
               VL,MF=(E,PARMLIST)         ..Execute from here
*
*->      VCOPY '(SUMTABLE)',=F'8',SUMTABLE,MOVE,MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VCOPY',         Service: VCOPY               @
               =C'(SUMTABLE)',            ..Name                       @
               =F'8',                     ..Length                     @
               SUMTABLE,                  ..Location                   @
               =CL8'MOVE'),               ..Type: Move or copy         @
               VL,MF=(E,PARMLIST)         ..Execute from here
*
** Create ISPF table entries from in-core entries
*
         L     R2,SUMT_ST+4               Locate table
CST$L    EQU   *
         CLI   0(R2),X'FF'                End of table?
         BE    CST$X                      Yes, leave
         MVC   SUMMOD(L'SUMMOD),SUMMOD-SUMTROW(R2)
         MVC   SUMCSCT(L'SUMCSCT),SUMCSCT-SUMTROW(R2)
         MVC   SUMREAS(L'SUMREAS),SUMREAS-SUMTROW(R2)
         MVC   SUMSDATE(L'SUMSDATE),SUMSDATE-SUMTROW(R2)
         MVI   SUMSDATS,C' '
         MVC   SUMEDATE(L'SUMEDATE),SUMEDATE-SUMTROW(R2)
         MVI   SUMEDATS,C' '
         MVC   SUMCOUNT(L'SUMCOUNT),SUMCOUNT-SUMTROW(R2)
*
         L     R1,CST_TCNT              Get total add count
         LA    R1,1(R1)                 Increment by 1
         ST    R1,CST_TCNT              Save total count
         SLR   R0,R0                    Clear register
         D     R0,=AL4(#STATUSS)        Divide by display increment
         LTR   R0,R0                    Evenly?
         BNZ   CST$TACX                 No, continue
         BAS   R9,INITIALIZE_LOGO_VARIABLES
         LA    R15,STATUS
*                           ....+....1....+....2....+....3..
         MVC   0(32,R15),=C'Processing Summary record number'
         LA    R15,33(R15)
         L     R1,CST_TCNT
         BAS   R9,EDITFWF
*
         LA    R15,INFO1
         MVC   0(L'SUMMOD,R15),SUMMOD
         LA    R15,L'SUMMOD+2(R15)
         MVC   0(L'SUMCSCT,R15),SUMCSCT
         LA    R15,L'SUMCSCT+2(R15)
         MVC   0(L'SUMREAS,R15),SUMREAS
         LA    R15,L'SUMREAS+2(R15)
         LA    R15,INFO3
         MVC   0(L'SUMSDATE,R15),SUMSDATE
         LA    R15,L'SUMSDATE+2(R15)
         MVC   0(L'SUMEDATE,R15),SUMEDATE
         LA    R15,L'SUMEDATE+2(R15)
*
         CLI   ZENVIR+16,C'B'             Batch?
         BE    CST$TACX                   Yes, skip this nonsense
*->      CONTROL DISPLAY,LOCK,MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'CONTROL',       Service: CONTROL             @
               =CL8'DISPLAY',             ..display                    @
               =CL8'LOCK'),               ..LOCK it                    @
               VL,MF=(E,PARMLIST)         ..Execute from here
*->      DISPLAY PANEL='LRS$LOGO',MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'DISPLAY',       Service: DISPLAY             @
               =CL8'LRS$LOGO'),           ..Panel name                 @
               VL,MF=(E,PARMLIST)         ..Execute from here
CST$TACX EQU   *
*->      TBADD SUMTABLE,MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'TBADD',         Service: TBADD               @
               SUMTABLE),                 ..Table name                 @
               VL,MF=(E,PARMLIST)         ..Execute from here
*
         LA    R2,SUMTROWL(R2)            Bump to next entry
         C     R2,SUMT_END                End of table?
         BL    CST$L                      No, continue
*
** Free Summary table
*
CST$X    EQU   *
         LM    R0,R1,SUMT_ST              Get length and address
         LTR   R0,R0
         BZ    CST$SUMX
         FREEMAIN R,LV=(0),A=(1)          Free storage
CST$SUMX EQU   *
         EJECT ,
***********************************************************************
***
**       Process the CPU count entries into CLIST/REXX variables
***
***********************************************************************
         SPACE 2
CREATE_CPU_LINES EQU *
         L     R2,CPUC_ST+4               Locate CPU count table
*
** Create TSO variable LRSRANGE
*
         BAS   R14,CCL$CLO                Clear CCL_LINE
         MVC   0(23,R4),=C'LOGREC entries start on'
         LA    R4,24(R4)                  Bump past text
         MVC   0(3,R4),PAR_SDAT+10        Get day of week
         MVC   3+1(10,R4),PAR_SDAT        Get gregorian Date
         LA    R4,3+1+10+1(R4)             Bump past it
         MVC   0(10,R4),=C'and end on'    Insert more text
         LA    R4,11(R4)                  Bump past it
         MVC   0(3,R4),PAR_EDAT+10        Get day of week
         MVC   3+1(10,R4),PAR_EDAT        Get gregorian Date
*
         LA    R14,=C'LRSRANGE'           Locate variable name
         ST    R14,CTV_NAMEP              Save it
         LA    R14,8                      Set variable name length
         ST    R14,CTV_NAMEL              Save it
         LA    R1,CCL_LINE                Locate value
         LA    R0,L'CCL_LINE              Get length of value
         BAS   R9,CREATE_TSO_VARIABLE     Create TSO variable
*
** Create table title lines
*
         BAS   R14,CCL$CLO                Clear CCL_LINE
         MVC   0(C_CLT1L,R4),C_CLT1       Get title line 1
         BAS   R9,CCL$NEWROW              Create new variable
         BAS   R14,CCL$CLO                Clear CCL_LINE
         MVC   0(C_CLT2L,R4),C_CLT2       Get title line 2
         BAS   R9,CCL$NEWROW              Create new variable
         BAS   R14,CCL$CLO                Clear CCL_LINE
         MVC   0(C_CLT3L,R4),C_CLT3       Get title line 3
         BAS   R9,CCL$NEWROW              Create new variable
*
         LA    R1,LRSTROW                 Locate total work area
         XC    0(CPUCL,R1),0(R1)          Clear area
         MVC   CPUCN-CPUC(8,R1),=CL8'Total'
         MVI   CPUCL(R1),X'FF'            Set end of "table"
*
CCL$L    EQU   *
         CLI   0(R2),X'FF'                End of table?
         BE    CCL$CLE                    Yes, continue
CCL$LLST EQU   *
         BAS   R14,CCL$CLO                Clear CCL_LINE to blanks
         MVC   0(8,R4),CPUCN-CPUC(R2)     Get CPU name
         LA    R4,8+1(R4)                 Bump past CPU name
*
         LA    R0,CPUCCSN                 Get number of count fields
         LA    R1,CPUCCS-CPUC(R2)         Locate start of count fields
         SLR   R14,R14                    Clear total
         LA    R5,LRSTROW                 Locate total work area
         LA    R5,CPUCCS-CPUC(R5)         Locate to count fields
CCL$CL   EQU   *
         SLR   R15,R15                    Clear register
         ICM   R15,B'0011',0(R1)          Get entry number
         SLR   R9,R9                      Clear register
         ICM   R9,B'0011',0(R5)           Get total value
         AR    R9,R15                     Add for this CPU
         STCM  R9,B'0011',0(R5)           Save new total
         AR    R14,R15                    Add to total count
         CVD   R15,DOUBLE                 Convert to packed
         MVC   2(6,R4),=X'40,20,20,20,20,20' Get edit pattern
         ED    2(6,R4),DOUBLE+5           Edit total
         OI    2+5(R4),C'0'               Ensure a zero
         LA    R4,2+6+1(R4)               Bump to next output area
         LA    R1,2(R1)                   Bump to next input entry cnt
         LA    R5,2(R5)                   Bump to next input total cnt
         BCT   R0,CCL$CL                  Process next count field
*
         BAS   R9,CCL$NEWROW              Create new variable
         LA    R2,CPUCL(R2)               Bump to next one
         C     R2,CPUC_END                At end of table
         BL    CCL$L                      Process next CPU entry
*
CCL$CLE  EQU   *
         TM    FLAG1,$F1CPUCT             Already did totals?
         BO    CCL$CLEX                   Yes, leave
         OI    FLAG1,$F1CPUCT             Turn on flag
         LA    R2,LRSTROW                 Locate total work area
         BAS   R14,CCL$CLO                Clear CCL_LINE
         MVC   0(C_CLT3L,R4),C_CLT3       Get title line 3
         BAS   R9,CCL$NEWROW              Create new variable
         B     CCL$LLST                   Do last line
CCL$CLEX EQU   *
*
** Print unsupported record count
*
         BAS   R14,CCL$CLO                Clear CCL_LINE
         BAS   R9,CCL$NEWROW              Create new variable
         L     R8,URCT_ST+4               Locate table
         LA    R7,0                       Set type
         LA    R6,256                     Number of records
CCL$URL  EQU   *
         ICM   R5,B'1111',0(R8)           Get count for record type
         BZ    CCL$URLB
         BAS   R14,CCL$CLO                Clear CCL_LINE
*                          ....+....1....+....2....+....3....
         MVC   0(34,R4),=C'Unsupported (other) record type X'''
         LA    R4,34(R4)
         STC   R7,DOUBLE
         UNPK  0(3,R4),DOUBLE(2)
         MVZ   0(2,R4),=8X'00'
         TR    0(2,R4),=C'0123456789ABCDEF'
         LA    R4,2(R4)
         MVC   0(10,R4),=C''' occurred'
         LR    R1,R5
         LA    R15,11(R4)
         BAS   R9,EDITFWF
         LA    R4,1(R15)
         MVC   0(5,R4),=C'times'
         BAS   R9,CCL$NEWROW
CCL$URLB EQU   *
         LA    R8,4(R8)                   Bump to next entry
         LA    R7,1(R7)                   Increment record type count
         BCT   R6,CCL$URL                 Try it on for size
*
** Print number of records with 1900 century (if any)
*
         ICM   R1,B'1111',PAR_C1900
         BZ    CCL$BDX
         BAS   R14,CCL$CLO                Clear CCL_LINE
         BAS   R9,CCL$NEWROW              Create new variable
         MVC   0(36,R4),=C'Number of records with 1900 century:'
         LA    R15,37(R4)                 Locate output loc for EDITFWF
         L     R1,PAR_C1900               Get records with bad century
         BAS   R9,EDITFWF
*        LA    R4,1(R15)
         BAS   R9,CCL$NEWROW
CCL$BDX  DS    0H
*
** Print "footer" lines
*
         BAS   R14,CCL$CLO                Clear CCL_LINE
         BAS   R9,CCL$NEWROW              Create new variable
         BAS   R14,CCL$CLO                Clear CCL_LINE
         TM    FLAG1,$F1CPUCO             Have a CPUC overflow
         BNO   CCL$COCX                   No, continue
         MVC   0(C_OVERL,R4),C_OVER       Get overflow line
         MVC   C_OVERL(4,R4),=C'CPUC'     Set table name
         BAS   R9,CCL$NEWROW              Create new variable
CCL$COCX EQU   *
         TM    FLAG1,$F1CPUSO             Have a CPUC overflow
         BNO   CCL$COSX                   No, continue
         MVC   0(C_OVERL,R4),C_OVER       Get overflow line
         MVC   C_OVERL(4,R4),=C'CPUS'     Set table name
         BAS   R9,CCL$NEWROW              Create new variable
CCL$COSX EQU   *
         TM    FLAG1,$F1SUMTO             Have a SUMT overflow
         BNO   CCL$COSTX                  No, continue
         MVC   0(C_OVERL,R4),C_OVER       Get overflow line
         MVC   C_OVERL(4,R4),=C'SUMT'     Set table name
         BAS   R9,CCL$NEWROW              Create new variable
CCL$COSTX EQU  *
         B     CCL$X
*
** Clear CCL_LINE to blanks
*
CCL$CLO  EQU   *
         LA    R4,CCL_LINE                Locate output area
         MVI   0(R4),C' '                 Get blank
         MVC   1(L'CCL_LINE-1,R4),0(R4)   ..propagate it
         BSM   0,R14
*
** Add new row to stats table
*
CCL$NEWROW EQU  *
         TM    FLAG1,$F1CCLV              Handled variables yet?
         BO    CCL$NRVX                   Yes, continue
         OI    FLAG1,$F1CCLV              Set flag
*->      VDEFINE '(LINE)',CCL_LINE,CHAR,80,MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VDEFINE',       Define variable              @
               =C'(LINE)',                ..Name                       @
               CCL_LINE,                  ..Location                   @
               =CL8'CHAR',                ..Format                     @
               =F'80'),                   ..Length                     @
               VL,MF=(E,PARMLIST)         ..Execute from here
*->      VCOPY '(STATABLE)',=F'8',CCL_TBLN,MOVE,MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VCOPY',         Service: VCOPY               @
               =C'(STATABLE)',            ..Name                       @
               =F'8',                     ..Length                     @
               CCL_TBLN,                  ..Location                   @
               =CL8'MOVE'),               ..Type: Move or copy         @
               VL,MF=(E,PARMLIST)         ..Execute from here
CCL$NRVX EQU   *
*->      TBADD CCL_TBLN,MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'TBADD',         Service: TBADD               @
               CCL_TBLN),                 ..Table name                 @
               VL,MF=(E,PARMLIST)         ..Execute from here
         BSM   0,R9
*
** Free CPU count table
*
CCL$X    EQU   *
         LM    R0,R1,CPUC_ST              Get length and address
         FREEMAIN R,LV=(0),A=(1)          Free storage
         LM    R0,R1,URCT_ST              Get length and address
         FREEMAIN R,LV=(0),A=(1)          Free storage
         EJECT ,
***********************************************************************
***
**       Termination section
***
***********************************************************************
         SPACE 2
EXIT     EQU   *
*
** Close DEBUGOUT DCB (if open)
*
*        TM    FLAG2,$F2DEBUG             Debugging?
         LA    R3,DEBUGOUT                Locate DCB
         TM    DCBOFLGS-IHADCB(R3),DCBOFOPN
         BNO   X$DBX
         MVC   PARMLIST(C_CLOSEL),C_CLOSE Initialize parameter list
         CLOSE ((3)),MODE=31,MF=(E,PARMLIST)  Close file
         FREEPOOL DEBUGOUT                Free buffer pool
X$DBX    DS    0H
*
** Delete modules from memory
*
         TM    FLAG2,$F2LDATE             Did we load it?
         BNO   X$DATEX                    No, leave
         ICM   R0,B'1111',EP_DA$DATE      -> Program Loaded?
         BZ    X$DATEX                    No, continue
         DELETE EPLOC==CL8'DA$DATE'       Delete from V/S
X$DATEX  EQU   *
*
         TM    FLAG2,$F2LMXD              Did we load it?
         BNO   X$MXDX                     No, leave
         ICM   R0,B'1111',EP_DA$MXD       -> Program Loaded?
         BZ    X$MXDX                     No, continue
         DELETE EPLOC==CL8'DA$MXD'        Delete from V/S
X$MXDX   EQU   *
*
         TM    FLAG2,$F2LISPL             Did we load it?
         BNO   X$ISPLX                    No, leave
         ICM   R0,B'1111',EP_ISPLINK      -> Program Loaded?
         BZ    X$ISPLX                    No, continue
         DELETE EPLOC==CL8'ISPLINK'       Delete from V/S
X$ISPLX  EQU   *
*
** Exit housekeeping
*
         DA#LEAVE ,                       Exit housekeeping
         EJECT ,
***********************************************************************
***
**       Misc Internal subroutines
***
***********************************************************************
         SPACE 2
*
** Initialize LOGO variables to blanks and VDEFINE them if first time
*
INITIALIZE_LOGO_VARIABLES EQU *
         TM    FLAG1,$F1LOGOV             VDEFINEd vars yet?
         BO    ILV$VDX                    Yes, continue
         OI    FLAG1,$F1LOGOV             Say we done did it
*
*->      VDEFINE '(INFO1)',INFO1,CHAR,80,MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VDEFINE',       Define variable              @
               =C'(INFO1)',               ..Name                       @
               INFO1,                     ..Location                   @
               =CL8'CHAR',                ..Format                     @
               =F'80'),                   ..Length                     @
               VL,MF=(E,PARMLIST)         ..Execute from here
*
*->      VDEFINE '(INFO2)',INFO2,CHAR,80,MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VDEFINE',       Define variable              @
               =C'(INFO2)',               ..Name                       @
               INFO2,                     ..Location                   @
               =CL8'CHAR',                ..Format                     @
               =F'80'),                   ..Length                     @
               VL,MF=(E,PARMLIST)         ..Execute from here
*
*->      VDEFINE '(INFO3)',INFO3,CHAR,80,MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VDEFINE',       Define variable              @
               =C'(INFO3)',               ..Name                       @
               INFO3,                     ..Location                   @
               =CL8'CHAR',                ..Format                     @
               =F'80'),                   ..Length                     @
               VL,MF=(E,PARMLIST)         ..Execute from here
*
*->      VDEFINE '(INFO4)',INFO4,CHAR,80,MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VDEFINE',       Define variable              @
               =C'(INFO4)',               ..Name                       @
               INFO4,                     ..Location                   @
               =CL8'CHAR',                ..Format                     @
               =F'80'),                   ..Length                     @
               VL,MF=(E,PARMLIST)         ..Execute from here
*
*->      VDEFINE '(STATUS)',STATUS,CHAR,80,MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VDEFINE',       Define variable              @
               =C'(STATUS)',              ..Name                       @
               STATUS,                    ..Location                   @
               =CL8'CHAR',                ..Format                     @
               =F'80'),                   ..Length                     @
               VL,MF=(E,PARMLIST)         ..Execute from here
ILV$VDX  EQU   *
         MVI   INFO1,C' '
         MVC   INFO1+1(INFOM1L-1),INFO1
         MVI   INFO3,C' '
         MVC   INFO3+1(INFOM3L-1),INFO3
         BSM   0,R9
*
** Edit full word in Register 1 flush at location in Register 15
** INPUT: R1 - Register to print
**        R15 - Address to put number
*
EDITFWF  EQU   *
         LTR   R1,R1                      CHECK FOR 0
         BZ    EDITFWF0                   YES, PUT ZERO
         CVD   R1,DOUBLE                  NO, CONVERT TO PACKEC
         LA    R1,DOUBLE2+14              LOCATE SIG DIGIT
         MVC   DOUBLE2(15),EDITP15
         EDMK  DOUBLE2(15),DOUBLE+2       EDIT AND SAVE PLACE
         LA    R14,DOUBLE2+16             LOCATE LAST POSSIBLE BYTE + 1
         SR    R14,R1                     LENGTH = END - START
         BCTR  R14,0                      DECREMENT FOR EX
         EX    R14,EDITMOV                MOVE EDIT NUMBER TO OUTPUT
         LA    R15,0(R14,R15)             BUMP POINTER PAST NUMBER
         MVI   0(R15),C' '
         BSM   0,R9                       Return to caller
EDITMOV  MVC   0(0,R15),0(R1)
EDITP15  DC    X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'
EDITFWF0 DS    0H
         MVI   0(R15),C'0'                Insert zero
         LA    R15,1(R15)                 Bump past zero
         BSM   0,R9                       Return to caller
*
**       EDIT FULLWORD (FLUSH TO R15) WITHOUT COMMAS
**       R1 --> INPUT:REGISTER TO PRINT
**       R15 --> OUTPUT: ADDRESS WHERE OUTPUT IS TO BE PUT
*
EDITNCF  EQU   *
         LTR   R1,R1                      Check for zero
         BZ    EDITNCF0                   YES, PUT ZERO
         CVD   R1,DOUBLE                  NO, CONVERT TO PACKEC
         LA    R1,DOUBLE2+7               LOCATE SIG DIGIT
         MVC   DOUBLE2(8),EDITP15F
         EDMK  DOUBLE2(8),DOUBLE+4        EDIT AND SAVE PLACE
         LA    R14,DOUBLE2+9              LOCATE LAST POSSIBLE BYTE + 1
         SR    R14,R1                     LENGTH = END - START
         BCTR  R14,0                      DECREMENT FOR EX
         EX    R14,ENCFM                  MOVE EDIT NUMBER TO OUTPUT
         LA    R15,0(R14,R15)             BUMP POINTER PAST NUMBER
         BSM   0,R9                       RETURN TO CALLER
ENCFM    MVC   0(0,R15),0(R1)
EDITP15F DC    X'40,20,20,20,20,20,20,20,20,20,20,20,20,20,20'
EDITNCF0 DS    0H
         MVI   0(R15),C'0'                PUT IN ZERO
         LA    R15,1(R15)                 BUMP POINTER PAST ZERO
         BSM   0,R9                       RETURN TO CALLER
*
** Create TSO variable
**
** Input: R0 - Length of CLIST variable
**        R1 - Address of CLIST variable
**        The name and name length should already be set in CTV_NAMEx
*
CREATE_TSO_VARIABLE EQU *
         STM   R0,R1,CTV_VALUEL           Save value length and address
         XC    DOUBLE(4),DOUBLE           Reset token
         L     R15,CVTPTR                 -> CVT
         L     R15,CVTTVT-CVTMAP(R15)     -> TSVT
         L     R15,TSVTVACC-TSVT(,R15)    -> CLIST Variable routine
         CALL  (15),                      Call Variable routine        @
               (=A(TSVEUPDT),             ..Add/Update variable        @
               CTV_NAMEP,                 ..Pointer to variable name   @
               CTV_NAMEL,                 ..Length of variable name    @
               CTV_VALUEP,                ..Pointer to variable value  @
               CTV_VALUEL,                ..Length of variable value   @
               DOUBLE),                   ..Token (not used by us)     @
               VL,MF=(E,PARMLIST)         ..Variable list and execute
         BSM   0,R9
         EJECT ,
***********************************************************************
***
**       Constants
***
***********************************************************************
         SPACE 2
*
** Component ID table (mapped by TCID DSECT)
*
T_CID    EQU   *
         DC    CL9'5752SC1CM',CL8'RTM2    '
         DC    CL9'566528901',CL8'VTAM/XA '
         DC    CL9'568508501',CL8'VTAM/ESA'
T_CIDN   EQU   (*-T_CID)/TCIDL
*
** IPL device information
*
T_IPLS   EQU   *
         DC    X'10',CL8'Processr'
         DC    X'20',CL8'DASD'
         DC    X'30',CL8'Other'
         DC    X'40',CL8'Tape'
         DC    X'50',CL8'Card/Prt'
         DC    X'60',CL8'MICR/OCR'
         DC    X'70',CL8'TeleProc'
         DC    X'80',CL8'GrafDisp'
         DC    X'90',CL8'IBM SCP'
         DC    X'91',CL8'IBM PP'
T_IPLSN  EQU   (*-T_IPLS)/(1+8)
T_IPLSU  DC    X'00',CL8'Unknown'         Unknown type...
*
** IPL reasons and their descriptions in string format
*
T_IPLR   EQU   *
         DC    AL2(C_IPLDF-*,$IPLDF),CL8'Default '
         DC    AL2(C_IPLNM-*,$IPLNM),CL8'Normal  '
         DC    AL2(C_IPLIE-*,$IPLIE),CL8'CE notRQ'
         DC    AL2(C_IPLIM-*,$IPLIM),CL8'CE Req  '
         DC    AL2(C_IPLME-*,$IPLME),CL8'Media   '
         DC    AL2(C_IPLUN-*,$IPLUN),CL8'Unknown '
         DC    AL2(C_IPLOP-*,$IPLOP),CL8'Operatn '
         DC    AL2(C_IPLUP-*,$IPLUP),CL8'UserProg'
         DC    AL2(C_IPLEN-*,$IPLEN),CL8'Env     '
         DC    AL2(C_IPLCE-*,$IPLCE),CL8'CESYS   '
T_IPLRN  EQU   (*-T_IPLR)/(TIPLRL)
         DC    AL2(C_IPLZZ-*,000000),CL8'Unknown!'
*
C_IPLZZ  DA#STR 'Unknown IPL reason, need to update program'
C_IPLNM  DA#STR 'Normal system initialization'
C_IPLIE  DA#STR 'IBM hardware/programming problem, CE/PSR not required'
C_IPLIM  DA#STR 'IBM hardware/programming problem, CE/PSR required'
C_IPLME  DA#STR 'An IBM hardware unit failed because of a faulty or dam@
               aged media'
C_IPLUN  DA#STR 'An undetermied hardare or software failure'
C_IPLOP  DA#STR 'An operator error or prcedure problem'
C_IPLUP DA#STR 'A program other than an IBM-supplied control program or@
                programming product failed'
C_IPLEN DA#STR 'A failure other than hardware/software or operational c@
               aused system to be restarted (power, A/C, etc.)'
C_IPLCE  DA#STR 'System restart at CE/PSR request to correct a problem'
C_IPLDF DA#STR 'Operator replied "U" or entered a null line to message @
               IFB010D (normal IPL)'
*
** Title lines for statistics ISPF screen
**
** The C_CLTx title fields must match the order of CPUCCS - CPUCCSN
*
C_CLT1   DC    CL8'        ',C' '
         DC    CL8'        ',C' '
         DC    CL8'        ',C' '
         DC    CL8' Program',C' '
         DC    CL8'    Lost',C' '
         DC    CL8'        ',C' '
         DC    CL8' Symptom',C' '
         DC    CL8'        ',C' '
C_CLT1L  EQU   *-C_CLT1
C_CLT2   DC    CL8'CPU     ',C' '
         DC    CL8'     IPL',C' '
         DC    CL8'   ABEND',C' '
         DC    CL8'Interupt',C' '
         DC    CL8'  Record',C' '
         DC    CL8'     EOD',C' '
         DC    CL8' Records',C' '
         DC    CL8'   Total',C' '
C_CLT2L  EQU   *-C_CLT2
C_CLT3   DC    CL8'--------',C' '
         DC    CL8'--------',C' '
         DC    CL8'--------',C' '
         DC    CL8'--------',C' '
         DC    CL8'--------',C' '
         DC    CL8'--------',C' '
         DC    CL8'--------',C' '
         DC    CL8'--------',C' '
C_CLT3L  EQU   *-C_CLT3
C_OVER   DC    C'Warning: LRSOFTLG table overflow: '
C_OVERL  EQU   *-C_OVER
*
** Misc copy constants
*
C_CLOSE  CLOSE (*-*),MODE=31,MF=L
C_CLOSEL EQU   *-C_CLOSE
C_LSTI   OPEN  (*-*,(INPUT)),MODE=31,MF=L
C_LSTIL  EQU   *-C_LSTI
C_LSTO   OPEN  (*-*,(OUTPUT)),MODE=31,MF=L
C_LSTOL  EQU   *-C_LSTO
*
C_DCBI   DCB   DDNAME=C_DCBI,                                          @
               BUFNO=20,BUFL=7000,                                     @
               DSORG=PS,MACRF=GL,EODAD=*-*
C_DCBIL  EQU   *-C_DCBI
C_DCBIE  DCBE  RMODE31=BUFF,EODAD=PAR$EOF
C_DCBIEL EQU   *-C_DCBIE
*
C_DCBO   DCB   DDNAME=C_DCBO,                                          @
               DCBE=C_DCBOE,                                           @
               DSORG=PS,MACRF=PM,LRECL=133,RECFM=F
C_DCBOL  EQU   *-C_DCBO
C_DCBOE  DCBE  RMODE31=NONE
C_DCBOEL EQU   *-C_DCBOE
*
C_ISTMPV8A DA#DATE DPE,OPREFIX=C_ISTMPV8A,                             @
               OSTR=NO,OFLAG=$DA#DATE_ADDR,                            @
               OSTRL=$DA#DATE_ISTMPV8,OTYPE=$DA#DATE_ISTMPV
C_IDJULP4A DA#DATE DPE,OPREFIX=C_IDJULP4A,                             @
               OSTR=NO,OFLAG=$DA#DATE_ADDR,                            @
               OSTRL=$DA#DATE_IDJULP4,OTYPE=$DA#DATE_IDJULP
C_ODISO10A DA#DATE DPE,OPREFIX=C_ODISO10A,                             @
               OSTR=NO,OFLAG=$DA#DATE_ADDR,                            @
               OSTRL=$DA#DATE_ODISO10,OTYPE=$DA#DATE_ODISO
C_ODDOW3A  DA#DATE DPE,OPREFIX=C_ODDOW3A,                              @
               OSTR=NO,OFLAG=$DA#DATE_ADDR,                            @
               OSTRL=$DA#DATE_ODDOW3,OTYPE=$DA#DATE_ODDOW
C_ODDOW1A  DA#DATE DPE,OPREFIX=C_ODDOW1A,                              @
               OSTR=NO,OFLAG=$DA#DATE_ADDR,                            @
               OSTRL=$DA#DATE_ODDOW1,OTYPE=$DA#DATE_ODDOW
C_OTIMEM11A DA#DATE DPE,OPREFIX=C_OTIMEM11A,                           @
               OSTR=NO,OFLAG=$DA#DATE_ADDR,                            @
               OSTRL=$DA#DATE_OTIMEM11,OTYPE=$DA#DATE_OTIMEM
C_ODJUL6A  DA#DATE DPE,OPREFIX=C_ODJUL6A,                              @
               OSTR=NO,OFLAG=$DA#DATE_ADDR,                            @
               OSTRL=$DA#DATE_ODJUL6,OTYPE=$DA#DATE_ODJUL
*
         LTORG ,
         DS    0D                         End of CSECT
         EJECT ,
***********************************************************************
***
**       Installation dependent - Match CPU serials to names
**
**       Note: It's easier to use the external method of putting
**             all serial numbers in the REXX exec that invokes us;
**
**       Must match mapping DSECT CPUSN
***
***********************************************************************
         SPACE 2
CPUS     CSECT ,
         DC    CL8'CPUSNLRS'              Internal eyecatcher name
*
         DC    C'123456',CL8'NAMEHERE'
         DC    C'123456',CL8'NAMEHERE'
         DC    C'123456',CL8'NAMEHERE'
*
         DC    X'FF,FF,FF,FF'             Last entry - must be here!
         DS    0D                         End of CPUS CSECT
         EJECT ,
***********************************************************************
***
**       Dynamic Save Area
***
***********************************************************************
         SPACE 2
DSA      DSECT ,
         DS    18F                        Register Save Area
FLAG1    DS    B'00000000'                Flag 1
$F1CPUCT EQU   B'10000000'                ..CPU Count totals done?
$F1CPUCO EQU   B'01000000'                ..CPU Count table overflow?
$F1CPUSO EQU   B'00100000'                ..CPU Serial table overflow?
$F1SUMTO EQU   B'00010000'                ..SUMT table overflow?
$F1LOGOV EQU   B'00001000'                ..VDEFINEd LOGO vars?
$F1CCLV  EQU   B'00000100'                ..CCL - Variables yet?
FLAG2    DS    B'00000000'                Flag 2
$F2LDATE EQU   B'10000000'                ..Loaded DA$DATE?
$F2LISPL EQU   B'01000000'                ..Loaded ISPLINK?
$F2LMXD  EQU   B'00100000'                ..Loaded DA$MXD?
$F2DEBUG EQU   B'00010000'                ..Debugging output?
$F2DUMP  EQU   B'00001000'                ..Debugging output?
CENT1900 DS    C' '                       Wrong century
         DS    0D
DOUBLE2  DS    2D                         Double word work area * 2
DOUBLE   DS    D                          Double word work area
PARMLIST DS    XL(CMXDL)                  Parameter list for calls
*
ACCIN    DS    XL(C_DCBIL)                ACCIN DCB work area
ACCINE   DS    XL(C_DCBIEL)               ACCIN DCBE work area
DEBUGOUT DS    XL(C_DCBOL)                DEBUGOUT DCB work area
DEBUGOUE DS    XL(C_DCBOEL)               DEBUGOUT DCBE work area
         DS    0F                         Entry_Point
EP_DA$DATE DS  F                          ..DA$DATE
EP_ISPLINK DS  F                          ..ISPLINK
EP_DA$MXD  DS  F                          ..DA$MXD
*                                         CPU serial number table
CPUS_ST  DS    2F                         ..Length, Address
*                                         CPU Count table
CPUC_ST  DS    2F                         ..Length, Address
CPUC_END DS    F                          ..End of table
DA#LRSCA DS    F
DA#LRSCL DS    F
*                                         Unsupport_Record_Count Table
URCT_ST  DS    2F                         ..Length, Address
*                                         Summary Table
SUMT_ST  DS    2F                         ..Length, Address
SUMT_END DS    F                          ..End of table
         DS    0F                         Process_ACCIN_Records
PAR_RECNUM DS  F                          ..Physical Record number
PAR_C1900  DS  F                          ..Bad Dates
PAR_LDTV DS    F                          ..Last date Value
PAR_LDTR DS    F                          ..Last Date Row number
PAR_TCNT DS    F                          ..Total add count
PAR_DBERA DS   F                          ..Debug Entry Return Addr
PAR_SDAT DS    CL10,CL3                   ..Starting date in ACCIN
PAR_EDAT DS    CL10,CL3                   ..Ending date in ACCIN
         DS    0F                         Create_Summary_Table
CST_TCNT DS    F                          ..Total TBADD count
         DS    0F                         Create_CPU_Lines
CCL_TBLN DS    CL8                        ..Table name
CCL_LINE DS    CL80                       ..Line
           DS    0F                       Create_TSO_Variable
CTV_NAMEL  DS    F                        ..CLIST var name length
CTV_NAMEP  DS    F                        ..Pointer to CLIST Var name
CTV_VALUEL DS    F                        ..Value length
CTV_VALUEP DS    F                        ..Value pointer
*
ZENVIR   DS    CL32'ISPF 4.5MVS     TSO'  ZENVIR (IBM Env. var)
*
** LRS table variables
*
LRSTABLE DS    CL8                        Table name
*
LRSBTIME DS    XL4                        Binary Time for sorts
LRSBDATE DS    XL4                        Binary Date for sorts
LRSTROW  DS    0F                         Table row
         DS    C                          ..Slack byte for edit pattern
LRSDATEJ DS    CL6'yy.ddd'                ..Julian date
         DS    C                          ..Slack byte for edit pattern
LRSTIME  DS    CL11'hh:mm:ss.th'          ..Time of day
LRSDATEG DS    CL10'ccyy-mm-dd'           ..Gregorian date
LRSDAY   DS    CL3'sun'                   ..Day of the week
LRSDAYN  DS    C'0'                       ..Day of the week as number
LRSTYPE  DS    CL8                        ..Type of record
LRSJOBN  DS    CL8                        ..Jobname (if software)
LRSCOMP  DS    CL8                        ..Component or module
LRSCSCT  DS    CL8                        ..CSECT
LRSREAS  DS    CL8                        ..Reason
         DS    C                          ..Slack byte
LRSSEQN  DS    CL5                        ..Logrec file sequence
LRSCPU   DS    CL8                        ..CPU name or serial number
LRSTROWL EQU   *-LRSTROW
LRSDESC  DS    CL256                      ..Description of record
*
** Summary Table variables
*
SUMTABLE DS    CL8                        Table name
*
* Note: Labels from SUMTROW thru SUMTROWL map both ISPF variables
*       and each entry in GETMAINed table SUMT_ST. Otay!
*
SUMTROW  EQU   *                          Table row
SUMMOD   DS    CL8                        ..Module name
SUMCSCT  DS    CL8                        ..CSECT
SUMREAS  DS    CL8                        ..Reason
SUMSDATE DS    0CL14                      ..Start date
SUMSDATG DS    C'1999-12-31'                ..Gregorian date
SUMSDATS DS    C' '                         ..Space
SUMSDATD DS    C'FRI'                       ..Day of week
SUMEDATE DS    0CL14                      ..End Date
SUMEDATG DS    C'2000-01-01'                ..Gregorian date
SUMEDATS DS    C' '                         ..Space
SUMEDATD DS    C'SAT'                       ..Day of week
SUMCOUNT DS    CL4                        ..Number of matches
SUMTROWL EQU   *-SUMTROW
*
INFO1    DS    CL80
INFO2    DS    CL80
INFOM1L  EQU   *-INFO1
INFO3    DS    CL80
INFO4    DS    CL80
STATUS   DS    CL80
INFOM3L  EQU   *-INFO3
*
** Date routine areas
*
         DS    0F
W_ISTMPV8A     DA#DATE DPE,OPREFIX=W_ISTMPV8A,OSTR=YES,OSTRL=4
W_IDJULP4A     DA#DATE DPE,OPREFIX=W_IDJULP4A,OSTR=YES,OSTRL=4
W_ODISO10A     DA#DATE DPE,OPREFIX=W_ODISO10A,OSTR=YES,OSTRL=4
W_ODDOW3A      DA#DATE DPE,OPREFIX=W_ODDOW3A,OSTR=YES,OSTRL=4
W_ODDOW1A      DA#DATE DPE,OPREFIX=W_ODDOW1A,OSTR=YES,OSTRL=4
W_OTIMEM11A    DA#DATE DPE,OPREFIX=W_OTIMEM11A,OSTR=YES,OSTRL=4
W_ODJUL6A      DA#DATE DPE,OPREFIX=W_ODJUL6A,OSTR=YES,OSTRL=4
*
DEBUGMSG DS    CL256    BOZO - Delete me
TREC     DS    XL4
         DS    CL256
TRECS    DS    XL256
         DS    0D                         Alignment for FREEMAIN
DSAL     EQU   *-DSA
         EJECT ,
***********************************************************************
***
**       Internal program DSECTs
***
***********************************************************************
         SPACE 2
*
** Map T_IPLR table
*
TCID     DSECT ,
TCID_ID  DS    CL9'5665DAVEA'
TCID_NM  DS    CL8'Author'
TCIDL    EQU   *-TCID
*
** Map T_IPLR table
*
TIPLR    DSECT ,
TIPLRD   DS    AL2(*-*)                   Offset of Description string
TIPLRR   DS    CL2'NM'                    Reason
TIPLRC   DS    CL8'Normal'                Component
TIPLRL   EQU   *-TIPLR
*
** CPU Serial Number Table mapping
*
CPUC     DSECT ,
CPUCN    DS    CL8'Name'                  Name of CPU
CPUCCS   EQU   *
CPUCIPL  DS    XL2                        Number of IPL records
CPUCABN  DS    XL2                        Number of Abend records
CPUCPI   DS    XL2                        Number of ProgInt records
CPUCLOST DS    XL2                        Number of Lost records
CPUCZEOD DS    XL2                        Number of Z EOD records
CPUCSYM  DS    XL2                        Number of Symptom records
CPUCTOTL DS    XL2                        Total for this CPU
CPUCCSN  EQU   (*-CPUCCS)/2
CPUCL    EQU   *-CPUC
*
** CPU Serial Number Table mapping
*
CPUSN    DSECT ,
CPUSNS   DS    CL6'012345'                Serial number
CPUSNN   DS    CL8'Name'                  Name of CPU (alias)
CPUSNL   EQU   *-CPUSN
         EJECT ,
***********************************************************************
***
**       External DSECTs
***
***********************************************************************
         SPACE 2
*
** EREP Software Record
*
ESR      DSECT ,
ESRRDW   DS    XL4                        Variable block RDW
ESRSFT   EQU   *                          Logrec Buffer map (hardware)
*
ESRERROR DS    0XL10                      RTM Generated Error ID
ESRESEQ  DS    XL2                        Sequence number
ESRECPU  DS    XL2                        CPU Idenitifer
ESREASID DS    XL2                        ASID
ESRETOD  DS    XL4                        Time stamp
*
** Software Error (SFT) Record format
** Copied from GC28-1378-4 EREP User's Guide
*
SFT      DSECT ,
SFTKEY1  DS    X                          Class/Source
SFTKEY2  DS    X                          System/release level
SFTSMS   DS    X                          Record-independent switches
SFTSW2   DS    X                          Record-dependent switch 1
         DS    X                          Reserved
         DS    X                          Reserved
SFTRCDCT DS    X                          Record Count
         DS    X                          Reserved
SFTDATE  DS    XL4                        Date
SFTTIME  DS    XL4                        Time
SFTCPUID DS    0CL8                       CPU identification
SFTVER   DS    X                          ..Machine version code
SFTSER   DS    XL3                        ..CPU Serial number
SFTMOD   DS    XL2                        ..CPU module number
         DS    XL2                        ..Reserved
SFTHEADE EQU   *
SFTJOBID DS    CL8                        Jobname if not short record
SFTSDWA  EQU   *                          System Diagnostic work area
*
** EOD
*
         ORG   SFTHEADE                   Locate to end of header
EODXL    DS    XL4                        Length of user data
EODWSC   DS    XL4                        Wait state code
EODUSERD DS    CL32                       User data
         ORG   ,
*
** Lost record
*
         ORG   SFTHEADE                   Locate to end of header
RCBLCNT  DS    X                          Number of records lost
         ORG   ,
*
** System Initalization Record
*
         ORG   SFTHEADE                   Locate to end of header
IPLSYSID DS    X                          Device type or program that
*                                         caused restart
         DS    XL3                        Not used for IPL record
IPLREAS  DS    XL2                        Reason for IPL
$IPLNM   EQU   C'NM'                      ..Normal
$IPLIE   EQU   C'IE'                      ..IBM hardware/prog. problem
$IPLIM   EQU   C'IM'                      ..IBM hardware/prog. problem
$IPLME   EQU   C'ME'                      ..Media
$IPLUN   EQU   C'UN'                      ..Unknown
$IPLOP   EQU   C'OP'                      ..An unknown hard or sofware
$IPLUP   EQU   C'UP'                      ..User program
$IPLEN   EQU   C'EN'                      ..Environmental
$IPLCE   EQU   C'CE'                      ..CE/PSR has system
$IPLDF   EQU   C'DF'                      ..Default
IPLCHNM  DS    XL2                        Channel Map
IPLCHAN  DS    XL8                        Not used in 370XA
         ORG   ,
*
** SYS1.LOGREC - Header Record
**
** Copied from GC28-1670-02 MVS/ESA SP V4 SYS1.LOGREC Error Recording
*
HR          DSECT ,
HR_CLASRC   DS    XL2                     Header record identifier
HR_LOWLIMIT DS    XL4                     Address of low extent
HR_UPLIMIT  DS    XL4                     Address of high extent
HR_MSGCNT   DS    X                       Count of LOGREC Full msgs
HR_RESTART  DS    XL7                     Address of record entry
HR_BYTSREM  DS    XL2                     Remaining bytes on track
HR_TRKCAP   DS    XL2                     Total bytes on track
HR_LASTTR   DS    XL7                     Address of last track written
HR_TRKSPER  DS    XL2                     Highest addressable track
HR_EWMCNT   DS    XL2                     Warning count
HR_DEVCODE  DS    X                       Device Code
HR_EWMTRK   DS    XL4                     Early warning message track
HR_EWMSW    DS    X                       Switch byte:
$HR$EWMSWF  EQU   B'10000000'             ..90% full
HR_SFTYBYTS DS    X                       Check byte - should be 1
#HR$SFTYBYTS EQU  1                       Must be 1 for validity
HRL         EQU   *-HR
*
** SYS1.LOGREC - Time Stamp Record
**
** Copied from GC28-1670-02 MVS/ESA SP V4 SYS1.LOGREC Error Recording
*
TSR         DSECT ,
TSR_CLASRC  DS    X                       Class/Source:
$TSR$CLASRC EQU   B'10000011'             ..Time Stamp Record
TSR_OPSYS   DS    X                       System/Release Record
TSR_SW1     DS    B'00000000'             Record switch 1
TSR$SW1_MR  EQU   B'10000000'             ..More records follow
TSR$SW1_TOD EQU   B'01000000'             ..Time of Day Instruction
TSR$SW1_RT  EQU   B'00100000'             ..Record truncated
TSR$SW1_XA  EQU   B'00010000'             ..Created by SP 2, 3, 4 etc
TSR$SW1_TME EQU   B'00001000'             ..TIME macro used
TSR_SW2     DS    B'00000000'             Record switch 2
TSR_SW3     DS    B'00000000'             Record switch 3
TSR_SW4     DS    B'00000000'             Record switch 4
            DS    XL2
TSR_DATE    DS    XL4                     Date of IPL
TSR_TIME    DS    XL4                     System time
TSR_VERNO   DS    X                       Machine version code
TSR_CPUSER  DS    XL3                     Central Processor Serial
TSR_CPUMOD  DS    XL2                     CPU model
TSR_MCELLNG DS    XL2
            DS    XL16
TSRL        EQU   *-TSR
         END   ,
         EJECT
***********************************************************************
***
**        Linkage editor cards - ASM.PARM='BATCH,...'
***
***********************************************************************
         SPACE 2
 PUNCH ' ENTRY   DA$EREP          '       Entry point
 PUNCH ' INCLUDE SYSLMOD(DA$DATE) '       Subroutine: Date routine
 PUNCH ' INCLUDE SYSLMOD(DA$MXD)  '       Subroutine: Date routine
 PUNCH ' INCLUDE SISPLOAD(ISPLINK) '      Subroutine: ISPF interface
 PUNCH ' NAME    DA$EREP(R)       '       Name of load module
         END ,
./ ADD NAME=DA$IDC   0100-01266-01266-1821-02587-02587-00000-DAVE
DA$IDC   TITLE 'IDCAMS Post Processing Utility'
* =================================================================== *
*
* Name: DA$IDC
*
* Author: David Alcock
*         dave@planetmvs.com
*
* Purpose: Enhanced IDCAMS print program.  DA$IDC invokes IDCAMS and
*          gets control for each record printed on SYSPRINT. This
*          allows us to reformat without any additional I/O. Sweet!
*
*          This program is a "Screen Scraper" - Use at your own risk.
*          This program is a "Screen Scraper" - Use at your own risk.
*          This program is a "Screen Scraper" - Use at your own risk.
*          This program is a "Screen Scraper" - Use at your own risk.
*
*          Here are some examples of the enhanced lines:
*
*          - Translate DEVTYPE hex string to the generic name:
*            X'3010200E' to 3380
*          - Creation date given in Gregorian (ISO) format:
*            CREATION---------1991.011
*            Sunday.........1991-01-11       <- New line
*          - Time stamp changed to human form:
*                 X'A548B2C2CA6A1612'
*            GMT: 1992-02-22 00:14 AM        <- New line
*
*          To make the IDCAMS listing easier to read on SDSF, We
*          will use real blank lines when we see ANSI control chars.
*          2001-04-23: I see I have some ANSI code ripped out via
*                      an AGO around it.  Do find on BOZO
*
*          If the RECAP DD statement is allocated, then a "RECAP"
*          of a LISTCAT listing is written.  You might want to make
*          the SYSPRINT file DUMMY and just get the Recap in some
*          cases.
*
* Disclaimer: This program is FREEWARE.  Use at your own risk.  It
*             is provided for your enjoyment and neither David
*             Alcock or his employer provides any warranty for it's
*             use.  I'd like to hear how it works on your system.
*
*             This software is not in the public domain but is
*             available free of charge and with source code
*             provided.  It is copyright 2001+ by David Alcock
*             All rights reserved.
*
* Dependencies: Assembler H or higher
*
* Limitations: Dependent on IDCAMs format, to maximize performance
*              the columns are hardcoded (via DSECT). Some IDCAMS
*              verbs require APF authorization. If those are
*              needed, this program must be linked AC=1 into
*              an APF authorized library.
*
* Reference: GC26-4019 MVS/XA Access Method Services
*            Appendix D. Invoking Access Method Services from a
*                        problem program.
*
* Non-IBM External programs:
* o DA$DATE....Date routine
* o DA$MXD.....Mini-Hex-Dump routine
*
* Non-IBM assembler MACROs:
* o DA#ENTER...Entry housekeeping
* o DA#LEAVE...Termination housekeeping
* o DA#EYEC....Build standard O/S module eyecatcher
*              (invoked by the DA#ENTER)
* o DA#REGS....Define registers (invoked by DA#ENTER)
* o DA#DATE....Equates and DSECTs for the date routine
* o DA#MXD.....Equates and DSECTs for the mini-hex-dump routine
* o DA#SMODE...Change addressing mode to/from 24 bit/31 bit
*
* CSECTs used:
* o Internal:
*   o DA$IDC.....Main CSECT
*   o IDC$IOR....IDCAMS I/O routine
*   o IDC$RCP....Recap of IDCAMS listing
*   o IDC$PRR....Pring Report Record
*   o IDC$ERR....Error Processing
* o External:
*   o DA$MXD.....Mini-Hex-Dump routine
*   o DA$DATE....Date routine
*
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
* E n h a n c e m e n t   I d e a s
*
*  An enterprising person could add the following enhancements:
*  - Add a line with the UCB for DASD
*    VOLSER------------SYSRES   <- IBM
*    UCB/VOLSER---xxxx/SYSRES   <- Changed
*
*  - Call TMS for tape volsers via the CA API:
*    CJOB------------YSM001DP  STEPNAME--------DUMPSMF   <- New line
*    LRECL--------------32756  BLKSIZE-----------32760   <- New line
*
* =================================================================== *
         EJECT
&IDCVER  SETC  '2.2'
* =================================================================== *
*
*             M o d i f i c a t i o n   H i s t o r y
*
* 2001-06-12 -- David Alcock -- V2.2:
* - Instead of overlaying the Device Type, I now add another line:
*   > IBM:  DevType------X'78048083'   (Modified for Mix case)
*   > Dave: Unit Name---------3590-1   (Added after this line)
* - Check for device type of "00000000" and bypass IEFEB4UV call
*
* 2001-04-23 -- David Alcock -- V2.1:
* - Changed Creation date to format: 'DayOfWeek.....ccyy-mm-dd'
*   from:                            'Creation-------DOW dd-MM'
* - Changed all gregorian dates from dd-mm-ccyy to ccyy-mm-dd (ISO)
* - Indicate that the timestamp value is GMT.
*
* 07-MAY-1998 -- David Alcock -- V2.0:
* - Renamed to DA$IDC and changed to use DA* macros
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
* 22-FEB-1992 -- David Alcock -- V1.5
* - Added creation date to gregorian
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
* 05-APR-1991 -- David Alcock -- V1.4
* - Changed SNAP to DA#MXD;
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
* 15-MAR-1991 -- David Alcock -- V1.3
* - Added check for valid input IDCAMS records;
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
* 24-JAN-1989 -- David Alcock -- V1.2
* - MVS 2.2 support (GDG output change
* - DATA/INDEX cluster support
* - ERROR report processing
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
* 03-OCT-1988 -- David Alcock -- V1.1
* - Changed EDT device string from hard-
* - coded lookup to IEFEB4UV.
* - Added TimeStamp date conversion
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
* 15-SEP-1986 -- David Alcock -- V1.0
* - Initial program 5-SEP-1986
* =================================================================== *
         EJECT
***********************************************************************
***
**       External DSECTs
***
***********************************************************************
         SPACE 2
*
** IBM's Macros
*
         PRINT NOGEN
         CVT   DSECT=YES,LIST=NO          Communications Vector Table
         IEFUCBOB ,                       Unit Control Block
         DCBD  DSORG=PS,DEVD=DA           Data Control Block
         IEFJFCBN ,                       Job File Control Block
         IHAPSA ,                         Prefixed Save Area
         IEFTIOT1 ,                       Task I/O Table
         IKJTCB DSECT=YES,LIST=NO         Task Control Table
         IECSDSL1 (1)                     F1 Data Set Control Block
*
** David Alcock's Macros
*
         DA#DATE ,                        Date routine
         DA#MXD ,                         Hex Dump routine
         PRINT GEN
         EJECT
***********************************************************************
***
**       Initialization
***
***********************************************************************
         SPACE 2
         EJECT
DA$IDC   DA#ENTER 'IDCAMS POST PROCESSING',                            @
               RENT=YES,                    Indicate GETMAIN required  @
               LV=DSAL                      Lenght of GETMAIN
         USING DSA,R13                      Addressability to work area
*
** Misc Initializations
*
         ST    R1,IDC_PARM                Save R1 on entry
         ST    R12,EP_DA$IDC              Save our EPA for routines
         MVC   FLAG_LIT(4),=C'FLAG'       Set literal for debugging
*
** Load routines to be used for life of job
*
         LA    R8,N_EB4UV
         LOAD  EPLOC=(8),ERRET=E$LOAD
         ST    R0,EP_IEFEB4UV
*
         ICM   R0,B'1111',=V(DA$DATE)     Linked into us
         BNZ   I$LDARS
         LA    R8,N_DA$DATE
         LOAD  EPLOC=(8),ERRET=E$LOAD
         OI    FLAG1,$F1_LDA#DATE
I$LDARS  DS    0H
         ST    R0,EP_DA$DATE
*
** Set the current date and time for IDC$PRR
*
         MVC   PRR_ODISO10(C_ODISO10L),C_ODISO10
         MVC   PRR_OTIMES11(C_OTIMES11L),C_OTIMES11
         DA#SMODE 31                      Must be in 31 bit mode
         L     R15,EP_DA$DATE             Locate EPA of Date routine
         CALL  (15),(PRR_ODISO10,PRR_OTIMES11),VL,MF=(E,PARMLIST)
         DA#SMODE 24                      Back to 24 bit mode
         EJECT
***********************************************************************
***
**       Ensure that files are allocated
***
***********************************************************************
         SPACE 2
*
** Ensure that SYSIN is allocated
*
         LA    R8,=CL8'SYSIN'             DDNAME TO CHECK
         BAS   R9,CHECKDD                 ENSURE IT IS ALLOCATED
         BXH   R15,R15,E$DD               Do error routine if not...
*
** Ensure that SYSPRINT is allocated
*
         LA    R8,=CL8'SYSPRINT'          DDNAME TO CHECK
         BAS   R9,CHECKDD                 ENSURE IT IS ALLOCATED
         BXH   R15,R15,E$DD               Do error routine if not...
*
** Check for DATAONLY (No Heading) DD statement
*
         LA    R8,=CL8'DATAONLY'          DDNAME TO CHECK
         BAS   R9,CHECKDD                 ENSURE IT IS ALLOCATED
         BXH   R15,R15,I$NHX              WAS IT ALLOCATED?
         OI    FLAG1,$F1_DATAO            NO HEADING WANTED
I$NHX    EQU   *
*
** Check for $$DEBUG
*
         LA    R8,=CL8'$$DEBUG'           DDNAME to check
         BAS   R9,CHECKDD                 Allocated?
         BXH   R15,R15,I$DBX              No, continue
*
         ICM   R0,B'1111',=V(DA$MXD)      Linked into us?
         BNZ   I$LMXDRS                   Yes, continue
         LA    R8,N_DA$MXD                Locate =CL8'DA#MXD'
         LOAD  EPLOC=(8),ERRET=E$LOAD     Load module into storage
         OI    FLAG1,$F1_LDA#MXD          Turn on flag
I$LMXDRS DS    0H
         ST    R0,EP_DA$MXD               Save address
         OI    FLAG1,$F1_DEBUG            Turn on flag
I$DBX    EQU   *
         EJECT
***********************************************************************
***
**        Error report initialization
***
***********************************************************************
         SPACE 2
*
** Check for ERROR report
*
         LA    R8,=CL8'ERROR'             DDNAME to check
         BAS   R9,CHECKDD                 ENSURE IT IS ALLOCATED
         BXH   R15,R15,I$REX              DDNAME=ERROR ALLOCATED?
         OI    FLAG1,$F1_ERROR            TURN ON FLAG
*
         LA    R1,99                      GET LINE COUNT
         STC   R1,ERR_RLC                 FORCE HEADING ON FIRST PRINT
I$REX    EQU   *
         EJECT
***********************************************************************
***
**       Recap processing initialization
***
***********************************************************************
         SPACE 2
INITIALIZE_RECAP EQU *
*
** Check for RECAP DD statement
*
         LA    R8,=CL8'RECAP'             DDNAME TO CHECK
         BAS   R9,CHECKDD                 ENSURE IT IS ALLOCATED
         BXH   R15,R15,IR$X               DDNAME=RECAP ALLOCATED?
         OI    FLAG1,$F1_RECAP            TURN ON FLAG
*
         LA    R1,99                      GET LINE COUNT
         STC   R1,RCP_RLC                 FORCE HEADING ON FIRST PRINT
*
         MVI   RCP_TBL,0                  Ensure initialization
*
** Common exit from INITIALIZE_RECAP processing
*
IR$X     EQU   *
         EJECT
***********************************************************************
***
**       Invoke IDCAMS
***
***********************************************************************
         SPACE 2
*
** SET UP I/O ROUTINE PARAMETERS
*
         LA    R1,1                      NUMBER OF GROUPS
         ST    R1,IDC_ION                SAVE NUMBER
         LA    R1,C_IDCDD                LOCATE DDNAME STRING
         ST    R1,IDC_IODD               SAVE ADDRESS INTO LIST
         L     R1,=V(IDC$IOR)            LOCATE I/O ROUTINE ADDRESS
         ST    R1,IDC_IOR                SAVE FOR LATER
         ST    R13,IDC_IOUD              SAVE ADDRESS OF DSA
         LA    R3,IDC_IOL                LOCATE IO LIST
*
** PAGE NUMBERS
*
         LA    R1,3                      GET PARM FROM JCL
         STCM  R1,B'0011',IDC_PL         SAVE PAGE NUMBER LENGTH
         MVC   IDC_PNUM(3),=C'100'       STARTING PAGE NUMBER
*
** INVOKE IDCAMS
*
         LINK  EPLOC=N_IDCAMS,           CALL IDCAMS                   @
               PARAM=(IDC_PARM,=H'00',IDC_P,(3)),                      @
               VL=1,MF=(E,PARMLIST)
         LR    R2,R15                     Save return code
         EJECT
***********************************************************************
***
**       Termination section
***
***********************************************************************
         SPACE 2
EXIT     EQU   *
*
** Delete routines that have been loaded
*
         TM    FLAG1,$F1_LDA#DATE         Loaded DA#DATE?
         BNO   X$DATEX                    No, continue
         ICM   R1,B'1111',EP_DA$DATE      GET ROUTINE ADDRESS
         BZ    X$DATEX                    NONE, MOVE ON
         DELETE EPLOC=N_DA$DATE           DELETE IT
X$DATEX  DS    0H
*
         TM    FLAG1,$F1_LDA#MXD          Loaded DA#MXD?
         BNO   X$MXDX                     No, continue
         ICM   R1,B'1111',EP_DA$MXD       GET ROUTINE ADDRESS
         BZ    X$MXDX                     NONE, MOVE ON
         DELETE EPLOC=N_DA$MXD            DELETE IT
X$MXDX   DS    0H
*
         ICM   R1,B'1111',EP_IEFEB4UV     GET ROUTINE ADDRESS
         BZ    X$EB4UVX                   NONE, MOVE ON
         DELETE EPLOC=N_EB4UV             DELETE IT
X$EB4UVX EQU   *
*
** Return to caller
*
         LR    R15,R2                     GET IDCAMS RETURN CODE
         DA#LEAVE RC=(15)                 EXIT STAGE LEFT
         EJECT
***********************************************************************
***
**       Error routines
***
***********************************************************************
         SPACE 2
*
** Module could not be loaded
*
E$LOAD   EQU   *
         BAS   R9,FORMWTO                 Format the WTO
         MVC   0(MSG1L,R15),MSG1          Move message to WTO area
         MVC   MSG1L(8,R15),0(R8)         Move in module name
         LA    R1,RCP_WA                  Locate WTO
         WTO   ,MF=(E,(1))                Issue WTO
         B     EXIT                       Leave
*
** DDNAME not found, R8 points to 8 byte DDNAME
*
E$DD     EQU   *
         BAS   R9,FORMWTO                 Format the WTO
         MVC   0(MSG2L,R15),MSG2          Move message to WTO area
         LA    R15,MSG2L(R15)             Bump past message
         MVC   0(8,R15),0(R8)             Move in DDNAME
         LA    R1,RCP_WA                  Locate WTO
         WTO   ,MF=(E,(1))                Issue WTO
         B     EXIT
         EJECT
***********************************************************************
***
**       Misc internal subroutines
***
***********************************************************************
         SPACE 2
*
** Edit full word in Register 1 flush at location in Register 15
** INPUT: R1 - Register to print
**        R15 - Address to put number
*
EDITFWF  EQU   *
         LTR   R1,R1                      Check for 0
         BZ    EDITFWF0                   Yes, put zero
         CVD   R1,DOUBLE                  No, convert to packec
         LA    R1,DOUBLE2+14              Locate sig digit
         MVC   DOUBLE2(15),EDITFWFP
         EDMK  DOUBLE2(15),DOUBLE+2       Edit and save place
         LA    R14,DOUBLE2+16             Locate last possible byte + 1
         SR    R14,R1                     Length = end - start
         BCTR  R14,0                      Decrement for ex
         EX    R14,EDITFWFM               Move edit number to output
         LA    R15,0(R14,R15)             Bump pointer past number
         MVI   0(R15),C' '
         BSM   0,R9                       Return to caller
EDITFWFM MVC   0(0,R15),0(R1)
EDITFWFP DC    X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'
EDITFWF0 DS    0H
         MVI   0(R15),C'0'                Put in zero
         LA    R15,1(R15)                 Bump pointer past zero
         BSM   0,R9                       Return to caller
*
** FORMAT THE WTO AND INSERT MESSAGE PREFIX
*
FORMWTO  EQU   *
         LA    R15,RCP_WA                 LOCATE WTO
         MVC   0(C_WTOL,R15),C_WTO        MOVE IN WTO CONSTANTS
         LA    R15,4(R15)                 BUMP PAST HEADER BYTES
         MVC   0(6,R15),DA$IDC_ECNAME     Get "DA$IDC" from DA#ENTER
         LA    R15,6(R15)                 Bump past it
         BSM   0,R9
*
** ENSURE THAT DDNAME POINTED TO BY R8 IS ALLOCATED
*
CHECKDD  EQU   *
         DEVTYPE (8),DOUBLE2              TEST IT
         BSM   0,R9                       RETURN TO CALLER
*
** POINT REGISTER 15 TO FIRST BLANK IN STRING
** INPUT:  R0  - MAXIMUM LENGTH OF STRING
**         R15 - STRING
** OUTPUT: R15 - FIRST SPACE IN STRING
*
LOCATE_FIRST_SPACE EQU *
         CLI   0(R15),C' '
         BE    LFS$X
         LA    R15,1(R15)
         BCT   R0,LOCATE_FIRST_SPACE
LFS$X    EQU   *
         BSM   0,R14
         EJECT
***********************************************************************
***
**       Constants
***
***********************************************************************
         SPACE 2
MSG1     DC    C'-01E Required module could not be loaded, Name='
MSG1L    EQU   *-MSG1
MSG2     DC    C'-02E File not allocated, DD='
MSG2L    EQU   *-MSG2
*
*
N_IDCAMS DC    CL8'IDCAMS'                Mr. ID CAMS
N_DA$MXD DC    CL8'DA$MXD'                Mini-Hex-Dump routine
N_DA$DATE DC   CL8'DA$DATE'               Date Conversion routine
N_EB4UV  DC    CL8'IEFEB4UV'              EDT Verification
EDITP15  DC    X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'
*
** Copy constants
*
C_ODISO10 DA#DATE DPE,OPREFIX=C_ODISO10,OSTR=NO,                       @
               OSTRL=$DA#DATE_ODISO10,OTYPE=$DA#DATE_ODISO
C_OTIMES11 DA#DATE DPE,OPREFIX=C_OTIMES11,OSTR=NO,                     @
               OSTRL=$DA#DATE_OTIMES11,OTYPE=$DA#DATE_OTIMES
*
C_IDCDD  DC    CL10'DDSYSPRINT'
         DS    0D
C_WTO    WTO   '                                                       @
                                                                       @
                      ',                                               @
               ROUTCDE=(11,14),MCSFLAG=HRDCPY,MF=L
C_WTOL   EQU   *-C_WTO
*
** Literals used in DA$IDC
*
         LTORG ,
         DS    0D
         EJECT ,
***********************************************************************
***
**       DA$IDC -- IDC$IOR --- I/O SUBROUTINE
**
**       Input Parameter list:
**       +0 .. User parameter - DSA address
**       +4 .. I/O flags
**       +8 .. IOINFO
***
***********************************************************************
         SPACE 2
         DROP  R13,R12
IDC$IOR  DA#ENTER 'I/O ROUTINE'
         L     R11,0(R1)                  Get address of DSA
         USING DSA,R11                    Addressibility
*
* Note: The DA#ENTER macro leaves trash in the high order byte of R13
*       which causes 31-bit sensitive programs like IEFEB4UV to S0C4.
         LA    R13,0(R13)                 Clear high order byte
*
**       R3 -- IOFLAGs
**       R4 -- IOINFO
*
         LM    R3,R4,4(R1)                Get 2nd & 3rd parameters
         CLI   IOF_B1-IOF(R3),$IOF_O      OPEN request?
         BE    IOR$OPEN
         CLI   IOF_B1-IOF(R3),$IOF_C      CLOSE Request?
         BE    IOR$CLS
         CLI   IOF_B1-IOF(R3),$IOF_P      PUT Request?
         BE    IOR$PUT
*
** Common exit from I/O routine
*
IOR$X    EQU   *
         DA#LEAVE ,
         EJECT
***********************************************************************
***
**       IDC$IOR --- Open SYSPRINT FILE
***
***********************************************************************
         SPACE 2
IOR$OPEN EQU   *
*
** Open SYSPRINT DCB
*
         LA    R5,SYSPRINT                LOCATE DCB WORK AREA
         MVC   0(C_DCBVOL,R5),C_DCBVO     COPY IN DCB CONSTANT
         MVC   DCBDDNAM-IHADCB(8,R5),=CL8'SYSPRINT'
*
         LA    R1,IOR_JFCBX               Locate exit list
         STCM  R1,B'0111',DCBEXLST-IHADCB+1(R5) Save into DCB
         LA    R14,IOR_JFCB               Locate JFCB return area
         ST    R14,0(R1)                  Save into JFCB area
         OI    0(R1),X'87'                TURN ON JFCB + END-OF-LIST
*
         LA    R6,PARMLIST                LOCATE PARM LIST
         MVC   0(C_RJFCBL,R6),C_RJFCB     COPY IN READ-JOB-FILE-C.B.
         RDJFCB ((5),(OUTPUT)),           READ JFCB                    @
               MF=(E,(6))
         LTR   R15,R15                    TEST RESULT OF READ JFCB
         BZ    IOR$OJF                    OKAY: MOVE ON
         LA    R0,125                     LRECL
         LA    R1,629                     BLKSIZE
         B     IOR$OJFX                   LEAVE
*
IOR$OJF  EQU   *
         LA    R14,IOR_JFCB               LOCATE JOB-FILE-CONTROL-BLK
         SLR   R0,R0                      CLEAR REGISTER
         ICM   R0,B'0011',JFCLRECL-INFMJFCB(R14) GET LRECL FROM JCL
         BNZ   IOR$OJLX                   WE HAVE SOMETHING, MOVE ON
         LA    R0,125                     SET DEFAULT LRECL
IOR$OJLX EQU   *
         SLR   R1,R1                      CLEAR REGISTER
         ICM   R1,B'0011',JFCBLKSI-INFMJFCB(R14) GET BLKSIZE FROM JCL
         BNZ   IOR$OJBX                   WE HAVE SOMETHING, MOVE ON
         LA    R1,629                     SET DEFAULT BLKSIZE
IOR$OJBX EQU   *
*
IOR$OJFX EQU   *
*
         STCM  R0,B'0011',DCBLRECL-IHADCB(R5) INSERT LRECL
         STCM  R1,B'0011',DCBBLKSI-IHADCB(R5) INSERT BLKSIZE
         MVC   PARMLIST(C_LSTOL),C_LSTO   COPY IN OPEN PARM LIST
         OPEN  ((5),(OUTPUT)),                                         @
               MF=(E,PARMLIST)
*
** OPEN RECAP FILE (IF FLAG IS SET)
*
         TM    FLAG1,$F1_RECAP
         BNO   IOR$ORX
         LA    R5,RECAP                   LOCATE DCB WORK AREA
         MVC   0(C_DCBOL,R5),C_DCBO       COPY IN DCB CONSTANT
         MVC   DCBDDNAM-IHADCB(8,R5),=CL8'RECAP'
         MVC   PARMLIST(C_LSTOL),C_LSTO   COPY IN OPEN PARM LIST
         OPEN  ((5),(OUTPUT)),                                         @
               MF=(E,PARMLIST)
IOR$ORX  EQU   *
*
** Open ERROR file (if flag is set)
*
         TM    FLAG1,$F1_ERROR
         BNO   IOR$OEX
         LA    R5,ERROR                   LOCATE DCB WORK AREA
         MVC   0(C_DCBOL,R5),C_DCBO       COPY IN DCB CONSTANT
         MVC   DCBDDNAM-IHADCB(8,R5),=CL8'ERROR'
         MVC   PARMLIST(C_LSTOL),C_LSTO   COPY IN OPEN PARM LIST
         OPEN  ((5),(OUTPUT)),                                         @
               MF=(E,PARMLIST)
IOR$OEX  EQU   *
*
** Open $$DEBUG file (if flag is set)
*
         TM    FLAG1,$F1_DEBUG            Debugging mode?
         BNO   IOR$OSX                    No, continue
         LA    R5,$$DEBUG                 Locate DCB area
         MVC   0(C_DCBOL,R5),C_DCBO       Initialize DCB
         MVC   DCBDDNAM-IHADCB(8,R5),=CL8'$$DEBUG'
         MVC   PARMLIST(C_LSTOL),C_LSTO   Initialize Parameter List
         OPEN  ((5),(OUTPUT)),MF=(E,PARMLIST)
*
         MVI   $$DEBUGR,C' '
         MVC   $$DEBUGR+1(L'$$DEBUGR-1),$$DEBUGR
         LA    R15,$$DEBUGR+1
         L     R1,EP_DA$IDC
#IOR$OL  EQU   DA$IDC_ECL-(DA$IDC_ECNAME-DA$IDC)
         MVC   0(#IOR$OL,R15),DA$IDC_ECNAME-DA$IDC(R1)
         LA    R15,#IOR$OL+1(R15)
         MVC   0(17,R15),=C'-- $$DEBUG output'
         PUT   $$DEBUG,$$DEBUGR
         MVI   $$DEBUGR,C' '
         MVC   $$DEBUGR+1(L'$$DEBUGR-1),$$DEBUGR
         PUT   $$DEBUG,$$DEBUGR
IOR$OSX  EQU   *
*
** Common Exit from IOR$OPEN
*
IOR$OX   EQU   *
         B     IOR$X
         EJECT
***********************************************************************
***
**       IDC$IOR --- PUT SYSPRINT record
***
***********************************************************************
         SPACE 2
IOR$PUT  EQU   *
         MVI   FLAGP1,0                   Initialize put flag
*
         L     R4,0(R4)                   Locate record
         BAS   R14,CLRRECV                Clear out record area
         LA    R15,2                      Length of record length
         SR    R4,R15                     Locate record length
*
** Initialize record from input IDCAMS
*
         SLR   R1,R1                      Clear register
         ICM   R1,B'0011',0(R4)           Get length of record
         BZ    IOR$RCM                    Zero?
         BNM   IOR$RCMX                   Minus?
IOR$RCM  EQU   *
         LA    R1,1                       Must be at least one
IOR$RCMX EQU   *
         BCTR  R1,0                       Decrement for EX
         EX    R1,IOR$RECM                Move record
         LA    R1,4+1(R1)                 Add back 1 and for RDW
         STCM  R1,B'0011',RECOUTV         Save length of record
*
** Dump input record if option is on
*
         TM    FLAG1,$F1_DEBUG
         BNO   IOR$SBX
         MVI   $$DEBUGR,C' '
         MVC   $$DEBUGR+1(L'$$DEBUGR-1),$$DEBUGR
         MVC   $$DEBUGR+1(IOR_DBGL),IOR_DBG Get message
         PUT   $$DEBUG,$$DEBUGR           Locate print routine
*
         BAS   R9,IOR$DUMP_RECOUT         Dump recout
IOR$SBX  EQU   *
*
** Process the Device type string - give it meaning
*
         LA    R1,RECOUT+8                VSAM type location
         BAS   R9,P$DevType               Process for Device type
         LA    R1,RECOUT+37               Non-VSAM type location
         BAS   R9,P$DevType               Process for Device type
*
         LA    R1,RECOUT+37               Non-VSAM type location
         BAS   R9,P$CDATE                 Process for Creation date
*
         LA    R1,RECOUT+37               Non-VSAM type location
         BAS   R9,P$EDATE                 Process for Expiration date
*
         LA    R1,RECOUT+71               Time Stamp location (VSAM)
         BAS   R9,P$TIMEST                Process for Time Stamp
*
         LA    R1,RECOUT                  Title starting location
         BAS   R9,P$TITLE                 Process for Title
*
         TM    FLAGP1,$FP1_DEL            Delete (don't print record)?
         BO    IOR$PRTX                   Yes, continue
*
** Make listing easier to read on SDSF.  Change FBA to real spacing
** (triple space)
*
 AGO .BOZO
         CLI   RECOUT,C'-'                Skipping a line?
         BNE   IOR$FBADX
         MVC   RECOUTS(RECOUTVL),RECOUTV  Save record
         MVC   RECOUTV(5),=X'00,05,00,00,40'  RDW+C' '
         LA    R5,SYSPRINT                DCB
         LA    R6,RECOUTV                 Record to print
         PUT   (5),(6)                    Print record
         MVC   RECOUTS(RECOUTVL),RECOUTV  Save record
         MVC   RECOUTV(5),=X'00,05,00,00,40'  RDW+C' '
         LA    R5,SYSPRINT                DCB
         LA    R6,RECOUTV                 Record to print
         PUT   (5),(6)                    Print record
         MVC   RECOUTV(RECOUTVL),RECOUTS  Reset record
         MVI   RECOUT,C' '                Change spacing
IOR$FBADX EQU  *
.BOZO ANOP ,
*
** Make listing easier to read on SDSF.  Change FBA to real spacing
** (double space)
*
         CLI   RECOUT,C'0'                Skipping a line?
         BNE   IOR$FBA0X
         MVC   RECOUTS(RECOUTVL),RECOUTV  Save record
         MVC   RECOUTV(5),=X'00,05,00,00,40'  RDW+C' '
         LA    R5,SYSPRINT                DCB
         LA    R6,RECOUTV                 Record to print
         PUT   (5),(6)                    Print record
         MVC   RECOUTV(RECOUTVL),RECOUTS  Reset record
         MVI   RECOUT,C' '                Change spacing
IOR$FBA0X EQU  *
*
** Print the record
*
         LA    R5,SYSPRINT                DCB
         LA    R6,RECOUTV                 Record to print
         PUT   (5),(6)                    Print record
IOR$PRTX EQU   *
*
** Debugging stuff
*
         TM    FLAG1,$F1_DEBUG            Debugging mode?
         BNO   IOR$SAX                    No, continue
         MVI   $$DEBUGR,C' '              Get blank
         MVC   $$DEBUGR+1(L'$$DEBUGR-1),$$DEBUGR ..Propagate it
         TM    FLAGP1,$FP1_ADD            Adding record?
         BO    IOR$SAA                    No, continue
         TM    FLAGP1,$FP1_DEL            Deleting record?
         BO    IOR$SAD                    No, continue
         TM    FLAGP1,$FP1_MOD            Modified the record?
         BNO   IOR$SAN                    No, continue
         LA    R15,$$DEBUGR+1             Locate record
         MVC   0(IOR_DBGL,R15),IOR_DBG    Move in message
         MVC   IOR_DBGA-IOR_DBG(6,R15),=C'after ' Change it
         PUT   $$DEBUG,$$DEBUGR           Locate print routine
*
         BAS   R9,IOR$DUMP_RECOUT         Dump record after mod
         B     IOR$SANX                   Continue
*
IOR$SAA  EQU   *                 ....+....1....+....2....+..
         LA    R15,$$DEBUGR+1             Locate record
         MVC   0(IOR_DBGB,R15),IOR_DBG    Move in message
         MVC   IOR_DBGA-IOR_DBG(6,R15),=C'added:' Change it
         PUT   $$DEBUG,$$DEBUGR           Locate print routine
*
         BAS   R9,IOR$DUMP_RECOUT         Dump record after mod
         B     IOR$SANX                   Continue
*
IOR$SAD  EQU   *                 ....+....1....+....2....+..
         MVC   $$DEBUGR+1(22),=C'*** Record deleted ***'
         PUT   $$DEBUG,$$DEBUGR           Locate print routine
         B     IOR$SANX                   Continue
*
IOR$SAN  EQU   *                 ....+....1....+....2....+..
         MVC   $$DEBUGR+1(27),=C'*** Record not modified ***'
         PUT   $$DEBUG,$$DEBUGR           Locate print routine
IOR$SANX EQU   *
         MVI   $$DEBUGR,C' '
         MVC   $$DEBUGR+1(L'$$DEBUGR-1),$$DEBUGR
         PUT   $$DEBUG,$$DEBUGR           Locate print routine
         PUT   $$DEBUG,IOR_DASH           Print dash line
IOR$SAX  EQU   *
*
** Call RECAP if option is on
*
         TM    FLAG1,$F1_RECAP            Option on?
         BNO   IOR$PRX                    No, continue
         L     R15,=V(IDC$RCP)            Locate routine
         CALL  (15),                      Call it                      @
               ((11)),                    ..DSA address                @
               MF=(E,PARMLIST)            ..Execution parms
IOR$PRX  EQU   *
*
** Common exit from IOR$PUT processing
*
IOR$PX   EQU   *
         B     IOR$X                      LEAVE
*
IOR$RECM MVC   RECOUT(0),2(R4)            ** EXECUTED **
         EJECT ,
***********************************************************************
***
**       Dump complete RECOUT to $$DEBUG file
***
***********************************************************************
         SPACE 2
IOR$DUMP_RECOUT EQU *
         XC    $$DEBUGW(CMXDL),$$DEBUGW   Initialize area
         LA    R15,RECOUTV                Locate record
         LA    R0,RECOUTVL                Get length of record
         LA    R1,$$DEBUGR+1              Locate output area
         STM   R15,R1,$$DEBUGW+CMXD_ADDRESS-CMXD Data, Length, Output
         MVC   $$DEBUGW+CMXD_OUTPUTL-CMXD(2),=AL2(133)
IOR$DRL  EQU   *
         MVI   $$DEBUGR,C' '
         MVC   $$DEBUGR+1(L'$$DEBUGR-1),$$DEBUGR
         LA    R1,$$DEBUGW                Locate work area
         L     R15,EP_DA$MXD              -> DA#MXD E.P.A.
         BASSM R14,R15                    Call DA#MXD
         LR    R8,R15                     Save return code
         PUT   $$DEBUG,$$DEBUGR           Locate print routine
         LTR   R8,R8                      Any more lines to do...
         BNZ   IOR$DRL                    Thank you, May I have another
*
         MVI   $$DEBUGR,C' '
         MVC   $$DEBUGR+1(L'$$DEBUGR-1),$$DEBUGR
         PUT   $$DEBUG,$$DEBUGR           Print blank record
         BSM   0,R9
         EJECT
***********************************************************************
***
**       IDC$IOR --- CLOSE SYSPRINT
***
***********************************************************************
         SPACE 2
IOR$CLS  EQU   *
*
** Recap termination
*
IOR$CRT  EQU   *
         TM    FLAG1,$F1_RECAP            Recap done?
         BNO   IOR$CRTX                   No, move on
         BAS   R14,CLRRECV                INIT RECORD
         LA    R15,1+9(R15)               Bump past FBA+"IDC0002I "
         MVI   RECOUT,C'1'                Set FBA
         MVC   0(IOR_M3L,R15),IOR_M3      Get message
         LA    R15,IOR_M3L(R15)           Bump past it
         BAS   R9,PRINTREC                Print record
*
         LA    R2,RCP_TBL
         LA    R4,RCP_TBLT                Locate total entry
IOR$CRTL EQU   *
         BAS   R9,CLRRECV                 Clear record
         LA    R15,10(R15)                Bump to data location
         MVI   0(R15),C'-'                Set fill character
         MVC   1(11,R15),0(R15)           ..Propagate it
         SLR   R1,R1                      Clear register
         IC    R1,RT_TYPEL-RT(R2)         Get type length
         MVC   0(0,R15),RT_TYPE-RT(R2)    ** Executed **
         EX    R1,*-6                     Move to output line
         LA    R14,1(R1,R15)              Locate past last byte
         MVI   0(R14),C' '                Insert space
         LA    R15,12(R15)                Bump past type
*
         SLR   R1,R1                      Clear register
         ICM   R1,B'0111',RT_CNT-RT(R2)   Get count
         CR    R2,R4                      Doing total entry?
         BE    IOR$CRTT                   Yes, don't change total total
         SLR   R14,R14                    Clear register
         ICM   R14,B'0111',RT_CNT-RT(R4)  Get total count
         AR    R14,R1                     Add entry to total count
         STCM  R14,B'0111',RT_CNT-RT(R4)  Save total count
IOR$CRTT EQU   *
*
         CVD   R1,DOUBLE                  Convert to packed
         MVC   0(15,R15),IOR_EP15         Get edit pattern
         MVI   0(R15),X'60'               Change fill character
         ED    0(15,R15),DOUBLE+2         Edit it
         OI    14(R15),C'0'               Ensure zero
         LA    R15,16(R15)                Bump past output number
         BAS   R9,PRINTREC                Print it
         LA    R2,RTL(R2)                 Bump to next entry
         CR    R2,R4
         BNH   IOR$CRTL                   No, do next entry
IOR$CRTX EQU   *
*
** Close SYSPRINT file
*
         LA    R5,SYSPRINT                Locate DCB
         MVC   PARMLIST(C_CLOSEL),C_CLOSE Initialize parameter list
         CLOSE ((5)),MF=(E,PARMLIST)
*
** Close RECAP file
*
         TM    FLAG1,$F1_RECAP            RECAP TURNED ON?
         BNO   IOR$CRX                    NO, MOVE ON
*
         CLI   RO_NAME-RO(R6),C' '        ANYTHING LEFTOVER?
         BNE   IOR$CRC                    NO, MOVE ON
         PUT   RECAP,RCP_REC              PRINT RECORD
*
IOR$CRC  EQU   *
         LA    R5,RECAP                   LOCATE DCB
         MVC   PARMLIST(C_CLOSEL),C_CLOSE GET PARM LIST
         CLOSE ((5)),                                                  @
               MF=(E,PARMLIST)
IOR$CRX  EQU   *
*
** Close error file
*
         TM    FLAG1,$F1_ERROR            ERROR file option on?
         BNO   IOR$CEX                    No, continue
         LA    R5,ERROR                   Locate DCB
         MVC   PARMLIST(C_CLOSEL),C_CLOSE Get parameter list
         CLOSE ((5)),                     Close ERROR file             @
               MF=(E,PARMLIST)            ..w/Parameter list
IOR$CEX  EQU   *
*
** Close debug file
*
         TM    FLAG1,$F1_DEBUG            Option on?
         BNO   IOR$CSX                    No, continue
         LA    R5,$$DEBUG                 Locate DCB
         MVC   PARMLIST(C_CLOSEL),C_CLOSE Get parameter list
         CLOSE ((5)),                     Close ERROR file             @
               MF=(E,PARMLIST)            ..w/Parameter list
IOR$CSX  EQU   *
*
** Common exit from IOR$CLS
*
IOR$CX   EQU   *
         B     IOR$X
         EJECT
***********************************************************************
***
**       IDC$IOR --- Misc subroutines
***
***********************************************************************
         SPACE 2
*
** Print RECOUT/RECOUTV on file SYSPRINT
** Input: R15 - last character on line
*
PRINTREC EQU   *
         LA    R1,RECOUTV
         SR    R15,R1
         STH   R15,0(R1)
         PUT   SYSPRINT,RECOUTV
         BSM   0,R9
*
** INITIALIZE VARIABLE RECORD
*
CLRRECV  EQU   *
         XC    RECOUTV(4),RECOUTV         CLEAR RDW
         LA    R15,RECOUT                 LOCATE RECOUT BEGINNING
         MVI   0(R15),C' '                GET SPACE
         MVC   1(L'RECOUT-1,R15),0(R15)   ..PROPAGATE IT
         BSM   0,R14
*
**       EDIT FULLWORD (FLUSH TO R15)
**       R1 --> INPUT:REGISTER TO PRINT
**       R15 --> OUTPUT: ADDRESS WHERE OUTPUT IS TO BE PUT
*
IOR$EDITFWF EQU *
         LTR   R1,R1                      CHECK FOR 0
         BZ    IOR$EDITFWF0               YES, PUT ZERO
         CVD   R1,DOUBLE                  NO, CONVERT TO PACKEC
         LA    R1,DOUBLE2+14              LOCATE SIG DIGIT
         MVC   DOUBLE2(15),IOR_EP15
         EDMK  DOUBLE2(15),DOUBLE+2       EDIT AND SAVE PLACE
         LA    R14,DOUBLE2+16             LOCATE LAST POSSIBLE BYTE + 1
         SR    R14,R1                     LENGTH = END - START
         BCTR  R14,0                      DECREMENT FOR EX
         MVC   0(0,R15),0(R1)
         EX    R14,*-6                    MOVE EDIT NUMBER TO OUTPUT
         LA    R15,1(R14,R15)             BUMP POINTER PAST NUMBER
         BSM   0,R9                       RETURN TO CALLER
IOR$EDITFWF0 EQU *
         MVI   0(R15),C'0'                PUT IN ZERO
         LA    R15,2(R15)                 BUMP POINTER PAST ZERO
         BSM   0,R9                       RETURN TO CALLER
*
** Process Title line
**
** R1 - points to expected location for "1IDCAMS  SYSTEM...
**
**       ---7----+----8----+----9----+----0----+----1---
**  IBM: TIME: 19:08:09        04/23/01     PAGE    100
**  Me:  Time: 19:08:09   ccyy-04-23        Page    100
*
P$TITLE  EQU   *
         CLC   0(7,R1),=C'1IDCAMS'        Title record?
         BNE   PT$X                       No, leave
         TM    FLAG1,$F1_HEADING          Headings Printed?
         BNO   PT$H                       No, continue
         OI    FLAGP1,$FP1_DEL            Yes, delete this heading
         B     PT$X                       ..and leave
PT$H     EQU   *
         OI    FLAG1,$F1_HEADING          Headings Printed!!!!
         OI    FLAGP1,$FP1_MOD            Yes, we modified the record
         MVC   10(14,R1),=C'ystem Services' Make mixed case
         MVC   25(L'PT_LIT,R1),PT_LIT
*-Here we transform the '     mm/dd/yy' to ISO: 'ccyy-mm-dd   '
         CLI   91(R1),C'/'                Looks good?
         BNE   PT$DX
         CLI   94(R1),C'/'                Still looking good?
         BNE   PT$DX
         CLI   97(R1),C' '                Looks like a 2 digit date?
         BNE   PT$DX
* Note: this is date windowing code!  It will fail unmodified in 2063
         CLC   95(2,R1),=C'62'            looks like a 19xx date?
         BH    PT$D19
         MVC   84(2,R1),=C'20'            Looks like the 21st century
         B     PT$D19X
PT$D19   DS    0H
         MVC   84(2,R1),=C'19'            Looks like the 20th century
PT$D19X  DS    0H
         MVC   86(2,R1),95(R1)            Move year over
         MVI   88(R1),C'-'
         MVI   91(R1),C'-'
         MVC   94(3,R1),=C'   '           Blank out "/yy"
PT$DX    DS    0H
*
         CLC   67(4,R1),=C'TIME'
         BNE   PT$TX
         MVC   68(3,R1),=C'ime'
PT$TX    DS    0H
*
         CLC   102(4,R1),=C'PAGE'
         BNE   PT$PGX
         MVC   103(3,R1),=C'age'
PT$PGX   DS    0H
*
PT$X     EQU   *
         BSM   0,R9
PT_LIT   DC    C'- Processed by DA$IDC v&IDCVER'
*
** Process Expiration date
**
** R1 - points to expected location for "Expiration------1992.011"
*
P$EDATE  DS    0H
         CLC   0(11,R1),=C'EXPIRATION-'   Expiration date?
         BNE   PED$X                      No, leave
         MVC   1(9,R1),=C'xpiration'      Make mixed case
* Note: we could check for 99.365 here and print NEVER here...
         OI    FLAGP1,$FP1_MOD            Yes, we modified the record
PED$X    EQU   *                          No, leave
         BSM   0,R9
*
** Process Creation date
**
** R1 - points to expected location for "CREATION--------1992.011"
**
** Older code did this:                 "Creation------SUN 11-JAN"
** Newer code does this:                "dayofweek ... ccyy-mm-dd"
*
P$CDATE  EQU   *
         CLC   0(10,R1),=C'CREATION--'    Creation?
         BNE   PCD$X                      No, leave
         MVC   1(7,R1),=C'reation'        Make mixed case
         OI    FLAGP1,$FP1_ADD            Say we are adding a record
         ST    R1,DOUBLE                  Save output location
*
         MVC   W_IDJULC8(C_IDJULC8L),C_IDJULC8 Set date input code
         MVC   W_IDJULC8_STR(8),16(R1)    Get Julian date
         CLI   W_IDJULC8_STR,C'-'         Have century?
         BNE   PCD$CX                     Yes, continue
         MVC   W_IDJULC8_STR(2),=C'19'    Assume century is 19
PCD$CX   EQU   *
*
         LA    R5,SYSPRINT                Locate DCB
         LA    R6,RECOUTV                 Record to print
         PUT   (5),(6)                    Print record asis
*
         BAS   R14,CLRRECV                Clear record
*
         L     R15,DOUBLE                 Locate output area
         MVC   W_ODDOWA(C_ODDOW9AL),C_ODDOW9A Initialize input code
         ST    R15,W_ODDOWA_STR           Move in output location ptr
         LA    R15,14(R15)                Bump to place for ccyy-mm-dd
         MVC   W_ODISOA(C_ODISO10AL),C_ODISO10A
         ST    R15,W_ODISOA_STR           Move in output location ptr
         DA#SMODE 31                      Must be in 31 bit mode
         L     R15,EP_DA$DATE             Locate EPA of Date routine
         CALL  (15),(W_IDJULC8,W_ODDOWA,W_ODISOA),                     @
               VL,MF=(E,PARMLIST)
         DA#SMODE 24                      Back to 24 bit mode
*-Insert dots between Day of the week and the ISO date
         L     R15,DOUBLE                 Locate output area
         LA    R15,6(R15)                 "Monday" Shortest day of week
         LA    R0,8                       "Monday........ccyy-mm-dd"
PCD$DL   DS    0H
         CLI   0(R15),C' '                Blank?
         BNE   PCD$DLB                    Nope...
         MVI   0(R15),C'.'                Yep, replace with dot
PCD$DLB  DS    0H
         LA    R15,1(R15)
         BCT   R0,PCD$DL
*-Complete output line
         L     R15,DOUBLE                 Locate Time stamp location
         LA    R15,24(R15)                Bump past output stuff
         LA    R1,RECOUTV                 Locate beginning of record
         SR    R15,R1                     Length = end - beginning
         STH   R15,RECOUTV                Save length
PCD$X    EQU   *
         BSM   0,R9                       Return to caller
*
** Process Time Stamp
**
** R1 - points to expected location for "X'................'"
*
P$TIMEST EQU   *
         CLC   0(2,R1),=X'E7,7D'          "X'"
         BNE   PTS$X                      No, leave
         CLC   2(16,R1),=16C'0'           All zeros?
         BE    PTS$X                      Yes, why bother...
         OI    FLAGP1,$FP1_ADD            Say we are adding a record
*
         LA    R15,2(R1)                  Bump to hex string
         ST    R15,DOUBLE                 Save output location
         MVC   W_ISTMPC16(C_ISTMPC16L),C_ISTMPC16  Get timestamp
         MVC   W_ISTMPC16_STR(16),0(R15)  Move in number
*
         LA    R5,SYSPRINT                Locate DCB
         LA    R6,RECOUTV                 Record to print
         PUT   (5),(6)                    Print record asis
*
         BAS   R14,CLRRECV                CLEAR RECORD
         L     R15,DOUBLE                 Locate Time stamp location
         SH    R15,=H'7'                  Backup to start
         MVC   0(4,R15),=C'GMT:'
         LA    R15,5(R15)
         MVC   W_ODISOA(C_ODISO10AL),C_ODISO10A
         ST    R15,W_ODISOA_STR           Set pointer to output area
         MVC   W_OTIMESA(C_OTIMES8AL),C_OTIMES8A
         LA    R15,10+1(R15)              Bump past it
         ST    R15,W_OTIMESA_STR          Set pointer to output area
         DA#SMODE 31                      Must be in 31 bit mode
         L     R15,EP_DA$DATE             Locate EPA of Date routine
         CALL  (15),(W_ISTMPC16,W_ODISOA,W_OTIMESA),                   @
               VL,MF=(E,PARMLIST)
         DA#SMODE 24                      Back to 24 bit mode
*
         L     R15,DOUBLE                 Locate Time stamp location
         LA    R15,11+1+8(R15)            Bump past output stuff
         LA    R1,RECOUTV                 Locate beginning of record
         SR    R15,R1                     Length = end - beginning
         STH   R15,RECOUTV                Save length
PTS$X    EQU   *
         BSM   0,R9                       Return to caller
*
** Process Device Type
**
** R1 - points to expected location for "DEVTYPE---"
*
P$DevType DS 0H
         CLC   0(10,R1),=C'DEVTYPE---'    Device type?
         BNE   PDT$X                      No, leave
         MVC   0(10,R1),=C'DevType---'    Make easier on the IIs
         CLC   15(8,R1),=C'00000000'      Migrated?
         BE    PDT$Migrated               Yes, skip translate
*-Output IBM line
         OI    FLAGP1,$FP1_ADD            We're adding a record
         ST    R1,DOUBLE                  Save output location
         MVC   DT_VALUE(8),15(R1)         Save hex string

         LA    R5,SYSPRINT                Locate DCB
         LA    R6,RECOUTV                 Record to print
         PUT   (5),(6)                    Print record asis
*-Call IBM program that converts a device type to a unit name
         LA    R1,PARMLIST+8              Locate Unit table area
         MVI   0(R1),0                    Get hex zero
         MVC   1(20-1,R1),0(R1)           ..Propagate them
         LA    R1,8(R1)                   Locate output location
         LA    R0,4                       Output length
         LA    R15,DT_VALUE               Locate device type hex string
         BAS   R8,HEXTRAN                 Translate to hex value
         BXH   R15,R15,PDT$X              Leave if invalid hex string
         DA#SMODE 31                      Get into 31 bit mode
         L     R15,EP_IEFEB4UV            Locate EPA of IEFEB4UV
         CALL  (15),                      Call unit verification       @
               (PARMLIST+8,=X'2000'),     ..Unit table, flags          @
               VL,MF=(E,PARMLIST)         ..Parameter area
         DA#SMODE 24                      Get back to 24 bit mode
         ST    R15,DOUBLE+4               Save Return code (BXH trashs)
         BXH   R15,R15,PDT$ERR            Leave if could not translate
*-Create a new line with translated unit name
         BAS   R14,CLRRECV                Clear record
         L     R15,DOUBLE                 Locate "DEVTYPE----"
         MVC   0(9,R15),=C'Unit Name'
         MVI   9(R15),C'-'                Get dash
         MVC   10(15,R15),9(R15)          and propagate it
         LA    R15,24-8(R15)              Locate to place to put string
         LA    R6,PARMLIST+8              Point to translate Devtype
         LA    R7,8                       Set length of string
         BAS   R14,RIGHT_JUSTIFY          Right justify the string
         B     PDT$RDW                    Complete RDW Header
*-IBM's IEFEB4UV got a bad RC, print that on output.
PDT$ERR  DS    0H
         BAS   R14,CLRRECV                Clear record
         L     R15,DOUBLE                 LOCATE THE ORIGINAL STRING
         MVC   0(12,R15),=C'IEFEB4UV rc='
         LA    R15,12(R15)
         UNPK  0(9,R15),DOUBLE+4(5)
         MVZ   0(8,R15),=8X'00'
         TR    0(8,R15),=C'0123456789ABCDEF'
         MVI   8(R15),C' '
PDT$RDW  DS    0H                         Need good RDW for line
         L     R15,DOUBLE                 Locate original output loc
         LA    R15,24(R15)                Bump past output stuff
         LA    R1,RECOUTV                 Locate beginning of record
         SR    R15,R1                     Length = end - beginning
         STH   R15,RECOUTV                Save length
         B     PDT$X
*-The device type is "00000000" which usually means migrated
PDT$Migrated DS 0H
         OI    FLAGP1,$FP1_MOD            We modified the record
*-Common Exit from P$DevType processing
PDT$X    DS    0H
         BSM   0,R9                       Return to caller
*
** RIGHT JUSTIFY A STRING
** INPUT: R15 ADDRESS TO PUT STRING
**        R6  ADDRESS OF STRING
**        R7  LENGTH OF STRING
** OUTPUT: STRING WILL BE RIGHT JUSTIFIED AT ADDRESS OF R15
*
RIGHT_JUSTIFY EQU *
         ST    R14,RJ_RA                  SAVE RETURN ADDRESS
         SLR   R0,R0                      CLEAR COUNTER
         LR    R1,R7                      GET LENGTH TO WORK REG
         LR    R14,R6                     GET ADDRESS TO WORK REG
RJ$CSL   EQU   *
         CLI   0(R14),C' '                SPACE?
         BNE   RJ$CSB                     NO, MOVE ON
         AH    R0,=H'1'                   INCREMENT COUNTER
RJ$CSB   EQU   *
         LA    R14,1(R14)                 BUMP TO NEXT BYTE
         BCT   R1,RJ$CSL                  ..DO IT
         CR    R7,R0                      IS STRING ALL BLANKS?
         BE    RJ$EXIT                    YES, LEAVE
         LR    R1,R0                      GET NUM OF BLANKS
         LA    R14,0(R1,R15)              PLACE TO PUT STRING
         LR    R1,R7                      GET LENGTH
         SR    R1,R0                      NUMBER OF NON-BLANKS
         BCTR  R1,0                       DECREMENT FOR EX
         EX    R1,RJ$MOVE                 RIGHT JUSTIFY STRING
RJ$EXIT  EQU   *
         L     R14,RJ_RA                  GET RETURN ADDRESS
         BSM   0,R14                      RETURN TO CALLER
RJ$MOVE  MVC   0(0,R14),0(R6)             ** EXECUTED **
*
** Convert a hex string from character
** For example: From CL8'3020100E' to X'3020100E'
**
** Input: R0 - Length of output string (input / 2)
**        R1 - Output location
**        R15 - Input location
*
HEXTRAN  DS    0H
         STM   R3,R6,HT_SAVEREGS          Save registers
HT$MT    EQU   *
         MVI   0(R1),0                    Zero output byte
         LA    R4,1                       Offset for first hex char
         LA    R5,2                       Number of Nibbles in a byte
HT$CL    EQU   *
         LA    R6,T_HEX                   Locate Hex table
         LA    R3,T_HEXE                  Number of entries in table
HT$C1L   EQU   *
         CLC   0(1,R6),0(R15)             Match?
         BE    HT$C1LX                    Yes, move on
         LA    R6,3(R6)                   No, bump to next byte
         BCT   R3,HT$C1L                  Repeat
         B     HT$X                       Character not valid
HT$C1LX EQU    *
         LA    R6,0(R4,R6)                Bump to bitstring
         OC    0(1,R1),0(R6)              Turn on bits for this nibble
         LA    R4,1(R4)                   Increment for next nibble
         LA    R15,1(R15)                 Bump to the next input byte
         BCT   R5,HT$CL                   Do next hex nibble in byte
         LA    R1,1(R1)                   Bump to next output byte
         BCT   R0,HT$MT                   ..do it
         SLR   R15,R15                    Clear register: success
HT$X     EQU   *
         LM    R3,R6,HT_SAVEREGS          Restore registers
         BSM   0,R8
         EJECT
***********************************************************************
***
**       IDC$IOR --- Constants
***
***********************************************************************
         SPACE 2
IOR_M3   DC    C'The number of entries from Recap processing:'
IOR_M3L  EQU   *-IOR_M3
IOR_DASH DC    C' ',132C'-'
*
IOR_EP15 DC    X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'
*
IOR_DBG  DC    C'Dump of IDCAMS record '
IOR_DBGB EQU   *-IOR_DBG
IOR_DBGA DC    C'before'
         DC    C' modification:'
IOR_DBGL EQU *-IOR_DBG
*
C_ISTMPC16 DA#DATE DPE,OPREFIX=C_ISTMPC16,OSTR=NO,                     @
               OSTRL=$DA#DATE_ISTMPC16,OTYPE=$DA#DATE_ISTMPC
C_IDJULC8  DA#DATE DPE,OPREFIX=C_IDJULC8,OSTR=NO,                      @
               OSTRL=$DA#DATE_IDJULC8,OTYPE=$DA#DATE_IDJULC
C_ODDOW3A  DA#DATE DPE,OPREFIX=C_ODDOW3A,                              @
               OSTR=NO,OFLAG=$DA#DATE_ADDR,                            @
               OSTRL=$DA#DATE_ODDOW3,OTYPE=$DA#DATE_ODDOW
C_ODDOW9A  DA#DATE DPE,OPREFIX=C_ODDOW9A,                              @
               OSTR=NO,OFLAG=$DA#DATE_ADDR,                            @
               OSTRL=$DA#DATE_ODDOW9,OTYPE=$DA#DATE_ODDOW
C_ODISO10A DA#DATE DPE,OPREFIX=C_ODISO10A,                             @
               OSTR=NO,OFLAG=$DA#DATE_ADDR,                            @
               OSTRL=$DA#DATE_ODISO10,OTYPE=$DA#DATE_ODISO
C_OTIMES8A DA#DATE DPE,OPREFIX=C_OTIMES8A,                             @
               OSTR=NO,OFLAG=$DA#DATE_ADDR,                            @
               OSTRL=$DA#DATE_OTIMES8,OTYPE=$DA#DATE_OTIMES
*
C_CLOSE  CLOSE (*-*),MF=L
C_CLOSEL EQU   *-C_CLOSE
*
C_LSTO   OPEN  (*-*,(OUTPUT)),MF=L
C_LSTOL  EQU   *-C_LSTO
*
C_DCBVO  DCB   DDNAME=C_DCBVO,                                         @
               DSORG=PS,MACRF=(PM),RECFM=VBA
C_DCBVOL EQU   *-C_DCBVO
C_DCBO   DCB   DDNAME=C_DCBO,                                          @
               DSORG=PS,MACRF=(PM),RECFM=FBA,LRECL=133
C_DCBOL  EQU   *-C_DCBO
*
         DS    0D
C_RJFCB  RDJFCB (*-*,(INPUT)),MF=L
C_RJFCBL EQU   *-C_RJFCB
*
** HEX TABLE FORMAT:
**   C'0'         - CHARACTER THAT WE ARE CONVERTING
**   B'11110000'  - FIRST NIBBLE OF BYTE
**   B'00001111'  - LAST NIBBLE OF BYTE
*
T_HEX    EQU   *
         DC    C'0',B'00000000',B'00000000'
         DC    C'1',B'00010000',B'00000001'
         DC    C'2',B'00100000',B'00000010'
         DC    C'3',B'00110000',B'00000011'
         DC    C'4',B'01000000',B'00000100'
         DC    C'5',B'01010000',B'00000101'
         DC    C'6',B'01100000',B'00000110'
         DC    C'7',B'01110000',B'00000111'
         DC    C'8',B'10000000',B'00001000'
         DC    C'9',B'10010000',B'00001001'
         DC    C'A',B'10100000',B'00001010'
         DC    C'B',B'10110000',B'00001011'
         DC    C'C',B'11000000',B'00001100'
         DC    C'D',B'11010000',B'00001101'
         DC    C'E',B'11100000',B'00001110'
         DC    C'F',B'11110000',B'00001111'
T_HEXE   EQU   ((*-T_HEX)/(1+1+1))
*
** Literals used in IDC$IOR
*
         LTORG ,
         DS    0D
         DROP  R11,R12                    DROP REGISTER USED
         EJECT
***********************************************************************
***
**       DA$IDC -- IDC$RCP -- RECAP
***
***********************************************************************
         SPACE 2
IDC$RCP  DA#ENTER 'RECAP OF IDCAMS LISTING'
         L     R11,0(R1)                  GET ADDRESS OF PROGRAM PARMS
         USING DSA,R11                    ADDRESSIBLITY TO WORK AREA
*
** INITIALIZE RECORD ADDRESS/LENGTH REGISTERS
*
         LA    R4,RECOUT                  LOCATE RECORD
         SLR   R5,R5                      CLEAR REGISTER
         ICM   R5,B'0011',RECOUTV         GET LENGTH OF RECORD
         SH    R5,=H'4'                   DECREMENT FOR L'RDW
*
** Initialize routine table if not done already
*
         CLI   RCP_TBL,0                  Table initialized?
         BNE   RCP$TIX                    Yes, move on
         LA    R15,RCP_TBL                Locate work area table
         LA    R1,T_TYPE                  Locate constant table
         LA    R0,T_TYPEN                 Get number of entries
RCP$TIL  EQU   *
         MVC   0(T_TYPEL,R15),0(R1)       Move in entry
         LA    R15,RTL(R15)               Bump to next output entry
         LA    R1,T_TYPEL(R1)             Bump to next input entry
         BCT   R0,RCP$TIL                 Repeat
         MVC   RCP_TBLT(1+5),T_TYPET      Move in total entry
*
         LA    R14,RCP_REC+RO_VOLS-RO     Locate starting location
         ST    R14,RCP_OVSC               Save as current entry
         LA    R14,RCP_REC+L'RCP_REC-8    Locate to last possible
         ST    R14,RCP_OVSE               Save it
RCP$TIX  EQU   *
*
** Search routine table for this record
*
RCP$TCHK EQU   *
         LA    R1,RCP_TBL                 Locate type table
         LA    R0,T_TYPEN                 Number of entries in table
RCP$TL   EQU   *
         SLR   R3,R3                      Clear register
         IC    R3,RT_TYPEL-RT(R1)         Get length of this entry
         CLC   RT_TYPE-RT(0,R1),RECOUT+1  ** Executed **
         EX    R3,*-6                     Type match?
         BE    RCP$TFND                   Yes, leave
         LA    R1,RTL(R1)                 Bump to next entry
         BCT   R0,RCP$TL                  Repeat
*
** New type not found, do current routine
*
         ICM   R14,B'1111',RCP_TBLC       Get current table entry
         BZ    RCP$X                      None, at beginning of listing
         LA    R6,RCP_REC                 Locate output record
         L     R14,RT_IROUT-RT(R14)       Locate input routine
         BSM   0,R14                      Perform it
*
** Found entry in table, execute the routine
*
RCP$TFND EQU   *
         ST    R1,RCP_TBLN                Save next entry
         LA    R6,RCP_REC                 Locate output record
         ICM   R14,B'1111',RCP_TBLC       Get current table entry
         BZ    RCP$TFPX                   None, first time thru
         L     R14,RT_OROUT-RT(R14)       Locate output entry
         BSM   0,R14                      Execute the routine
RCP$TFPX EQU   *
         LA    R6,RCP_REC                 Locate output record
         MVI   0(R6),C' '                 Insert blank
         MVC   1(L'RCP_REC-1,R6),0(R6)    ..Propagate blank
*
         L     R1,RCP_TBLN                Save next entry
         ST    R1,RCP_TBLC                Save as current
         MVC   RO_TYPE-RO(11,R6),RT_TYPE-RT(R1) Get entry type
*
         SLR   R15,R15                    Clear register
         ICM   R15,B'0111',RT_CNT-RT(R1)  Get count
         LA    R15,1(R15)                 Increment by 1
         STCM  R15,B'0111',RT_CNT-RT(R1)  Save count
*
         LA    R14,RCP_REC+RO_VOLS-RO     Locate starting location
         ST    R14,RCP_OVSC               Save as current entry
*
         L     R14,RT_IROUT-RT(R1)        Locate input routine
         BSM   0,R14                      Perform it
*
** Common exit from module IDC$RCP
*
RCP$X    EQU   *
         DA#LEAVE RC=0,RENT=NO
         EJECT
***********************************************************************
***
**       IDC$RCP --- AIX
***
***********************************************************************
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**    Input processing
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
RCP$IAI  EQU   *
*
** Lines to consider
*
         CLC   IL_MFBAL(3,R4),T_TYPEA+1   "AIX"
         BE    RCP$SENT                   Yes, save it
         B     RCP$X                      Dont process this one
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Output processing
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
RCP$OAI  EQU   *
         B     RCP$PENT
         EJECT
***********************************************************************
***
**       IDC$RCP --- Alias
***
***********************************************************************
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**    Input processing
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
RCP$IA   EQU   *
*
** Lines to consider
*
         CLC   IL_MFBAL(5,R4),T_TYPEA+1   "ALIAS"
         BE    RCP$SENT                   Yes, save it
         CLC   IL_MOPTL(7,R4),=C'USERCAT'
         BE    RCP$IAU                    Yes, save it
         B     RCP$X                      Dont process this one
*
** UserCatalog
*
RCP$IAU  EQU   *
         LA    R1,RO_CAT-RO(R6)          Locate output area
         B     RCP$SENTT                  Get User Catalog name
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Output processing
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
RCP$OA   EQU   *
         B     RCP$PENT
         EJECT
***********************************************************************
***
**       IDC$RCP --- Cluster
***
***********************************************************************
         SPACE 2
*
** Map RCP_WA
*
C_DATA   EQU   0,44
C_INDEX  EQU   44,44
C_L      EQU   44+44
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**    Input processing
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
RCP$IC   EQU   *
*
** Lines to consider
*
         CLC   IL_MFBAL(7,R4),T_TYPEC+1   "CLUSTER"
         BE    RCP$ICE                    Yes, save it
         CLC   IL_MOPTL(4,R4),T_TYPED+1   "DATA"
         BE    RCP$ICD                    Yes, save it
         CLC   IL_MOPTL(4,R4),T_TYPEI+1   "INDEX"
         BE    RCP$ICI                    Yes, save it
         B     RCP$X                      Dont process this one
*
** Cluster name
*
RCP$ICE  EQU   *
         MVI   RCP_WA,C' '                Set to blank
         MVC   RCP_WA+1(C_L-1),RCP_WA     ..propagate
         LA    R1,RCP_WA+C_DATA           Locate data output area
         B     RCP$SENT                   Save it
*
** Data entry
*
RCP$ICD  EQU   *
         LA    R1,RCP_WA+C_DATA           Locate data output area
         B     RCP$SENTT                  Save it
*
** Index entry
*
RCP$ICI  EQU   *
         LA    R1,RCP_WA+C_INDEX          Locate index output area
         B     RCP$SENTT                  Save it
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Output processing
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
RCP$OC   EQU   *
         B     RCP$PENT
         EJECT
***********************************************************************
***
**       IDC$RCP --- Data component of Cluster
***
***********************************************************************
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**    Input processing
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
RCP$ID   EQU   *
*
** Lines to consider
*
         CLC   IL_MFBAL(4,R4),T_TYPED+1   "DATA"
         BE    RCP$SENT                   Yes, save it
         CLC   IL_MOPTL(6,R4),=C'VOLSER'
         BE    RCP$MVSL                   Yes, save it
         CLC   IL_MOPTL(7,R4),=C'DEVTYPE'
         BE    RCP$MDTL                   Yes, save it
         B     RCP$X                      Dont process this one
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Output processing
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
RCP$OD   EQU   *
         B     RCP$PENT
         EJECT
***********************************************************************
***
**       IDC$RCP --- Index component of Cluster
***
***********************************************************************
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**    Input processing
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
RCP$II   EQU   *
*
** Lines to consider
*
         CLC   IL_MFBAL(5,R4),T_TYPEI+1   "INDEX"
         BE    RCP$SENT                   Yes, save it
         CLC   IL_MOPTL(6,R4),=C'VOLSER'
         BE    RCP$MVSL                   Yes, save it
         CLC   IL_MOPTL(7,R4),=C'DEVTYPE'
         BE    RCP$MDTL                   Yes, save it
         B     RCP$X                      Dont process this one
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Output processing
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
RCP$OI   EQU   *
         B     RCP$PENT
         EJECT
***********************************************************************
***
**       IDC$RCP --- Non-VSAM processing
***
***********************************************************************
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**    Input processing
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
RCP$INV  EQU   *
*
** Lines in NONVSAM output to consider
*
         CLC   IL_MFBAL(7,R4),T_TYPENV+1  "NONVSAM"
         BE    RCP$SENT
         CLC   IL_MOPTL(6,R4),=C'VOLSER'
         BE    RCP$DDT
         B     RCP$X
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Output processing
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
RCP$ONV  EQU   *
         B     RCP$PENT
         EJECT
***********************************************************************
***
**       IDC$RCP --- GDG BASE
***
***********************************************************************
         SPACE 2
*
** Map RCP_WA for GDG processing
*
G_COUNT  EQU   0,4
G_LIMIT  EQU   4,4
G_ATTR1  EQU   8,10
G_ATTR2  EQU   18,10
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**    Input processing
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
RCP$IG   EQU   *
*
** Lines to consider
*
         CLC   IL_MFBAL(3,R4),T_TYPEG+1   "GDG BASE"
         BE    RCP$IGE                    Yes, save it
         CLC   IL_MOPTL(7,R4),T_TYPENV+1  "NONVSAM"
         BE    RCP$IGNV                   Get count
         CLC   IL_MOPTL(5,R4),=C'LIMIT'   Limit?
         BE    RCP$IGL                    Yes, process it
         B     RCP$X                      Dont process this one
*
** Entry
*
RCP$IGE  EQU   *
         LA    R1,RCP_WA
         XC    G_COUNT(4,R1),G_COUNT(R1)
         B     RCP$SENT                   Yes, save it
*
** Limit/Attribute processing
*
RCP$IGL  EQU   *
         MVC   RCP_WA+G_ATTR1(10),IL_GATTR1L(R4)
         MVC   RCP_WA+G_ATTR2(10),IL_GATTR2L(R4)
         LA    R15,IL_GLMTL(R4)           Locate input string
         LA    R14,3                      Set string length
         LA    R1,RCP_WA+G_LIMIT          Locate output location
         BAS   R9,TRAPNUM                 Trap "Limit------------xxx"
         B     RCP$X
*
** Count entries
*
RCP$IGNV EQU   *
         L     R14,RCP_WA+G_COUNT         Get count
         LA    R14,1(R14)                 Increment by 1
         ST    R14,RCP_WA+G_COUNT         Save count
         B     RCP$X                      Continue
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Output processing
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
RCP$OG   EQU   *
         LA    R15,RO_DEVT-RO(R6)         Locate past "GDG "
         MVC   0(6,R15),=C'COUNT='
         LA    R15,6(R15)
         L     R1,RCP_WA+G_COUNT          Get count
         CVD   R1,DOUBLE
         UNPK  0(4,R15),DOUBLE+6(2)
         OI    3(R15),C'0'
*
         LA    R15,RO_VOLS-RO(R6)
         MVC   0(6,R15),=C'LIMIT='
         LA    R15,6(R15)
         L     R1,RCP_WA+G_LIMIT          Get count
         CVD   R1,DOUBLE
         UNPK  0(4,R15),DOUBLE+6(2)
         OI    3(R15),C'0'
*
         LA    R15,RO_VOLS+12-RO(R6)
         MVC   0(11,R15),=C'Attributes:'
         LA    R15,11+1(R15)
         MVC   0(10,R15),RCP_WA+G_ATTR1
         LA    R15,10+1(R15)
         MVC   0(10,R15),RCP_WA+G_ATTR2
         B     RCP$PENT
         EJECT
***********************************************************************
***
**       IDC$RCP --- Page Space
***
***********************************************************************
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**    Input processing
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
RCP$IPS  EQU   *
*
** Lines to consider
*
         CLC   IL_MFBAL(9,R4),T_TYPEPS+1  "PAGESPACE"
         BE    RCP$SENT                   Yes, save it
         CLC   IL_MOPTL(6,R4),=C'VOLSER'
         BE    RCP$MVSL                   Yes, save it
         CLC   IL_MOPTL(7,R4),=C'DEVTYPE'
         BE    RCP$MDTL                   Yes, save it
         B     RCP$X                      Dont process this one
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Output processing
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
RCP$OPS  EQU   *
         B     RCP$PENT
         EJECT
***********************************************************************
***
**       IDC$RCP --- Path
***
***********************************************************************
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**    Input processing
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
RCP$IP   EQU   *
*
** Lines to consider
*
         CLC   IL_MFBAL(4,R4),T_TYPEP+1   "PATH"
         BE    RCP$SENT                   Yes, save it
         B     RCP$X                      Dont process this one
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Output processing
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
RCP$OP   EQU   *
         B     RCP$PENT
         EJECT
***********************************************************************
***
**       IDC$RCP --- Space
***
***********************************************************************
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**    Input processing
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
RCP$IS   EQU   *
*
** Lines to consider
*
         CLC   IL_MFBAL(5,R4),T_TYPES+1   "SPACE"
         BE    RCP$SENT                   Yes, save it
         B     RCP$X                      Dont process this one
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Output processing
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
RCP$OS   EQU   *
         B     RCP$PENT
         EJECT
***********************************************************************
***
**       IDC$RCP --- User Catalog
***
***********************************************************************
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**    Input processing
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
RCP$IU   EQU   *
*
** Lines to consider
*
         CLC   IL_MFBAL(10,R4),T_TYPEU+1  "USERCATALOG"
         BE    RCP$SENT                   Yes, save it
         CLC   IL_MOPTL(6,R4),=C'VOLSER'
         BE    RCP$DDT
         B     RCP$X                      Dont process this one
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Output processing
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
RCP$OU   EQU   *
         B     RCP$PENT
         EJECT
***********************************************************************
***
**       IDC$RCP --- Internal subroutines
***
***********************************************************************
         SPACE 2
*
** Save Device Type
*
RCP$MDTL EQU   *
         MVC   RO_DEVT-RO(11,R6),IL_MDTL(R4) Get device type
         LA    R0,11                      Length of string
         LA    R15,RO_DEVT-RO(R6)         Locate string
         BAS   R14,RCP$ROD                Rub out dashes
         B     RCP$X
*
** "VOLSER---------xxxxxx    DEVTYPE-----X'3010200E" type records
*
RCP$DDT  EQU   *
         CLI   RO_DEVT+L'RO_DEVT-1-RO(R6),C' ' Have a device type yet?
         BNE   RCP$DDTX                   Yes, skip it
         MVC   RO_DEVT-RO(11,R6),IL_DDT(R4) Get device type
         LA    R0,11                      Get length of string
         LA    R15,RO_DEVT-RO(R6)         Locate string
         BAS   R14,RCP$ROD                Rub out them dashes
RCP$DDTX EQU   *
*=> Fall into RCP$DVS...  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
** Save volser
*
RCP$DVS  EQU   *
         LA    R1,IL_DVS(R4)              Locate volser (input)
         B     RCP$SVS
RCP$MVSL EQU   *
         LA    R1,IL_MVSL(R4)             Locate volser (input)
RCP$SVS  EQU   *
         LM    R14,R15,RCP_OVSC           Get Current output location
         CR    R14,R15                    Compare with last possible
         BH    RCP$SVSE                   Error, at end of the line
         MVC   0(6,R14),0(R1)             Get volume serial
         LA    R14,6+1(R14)               Bump past it
         ST    R14,RCP_OVSC               Save current location
         B     RCP$X                      Leave
RCP$SVSE EQU   *
         MVI   RCP_REC+L'RCP_REC-5,C'+'   Indicate truncation
         B     RCP$X                      Leave
*
** Print entry information
*
RCP$PENT EQU   *
*
         TM    FLAG1,$F1_DATAO            Headings wanted?
         BO    RCP$PEHX                   No, skip heading stuff
         L     R15,=V(IDC$PRR)            Locate print routine
         CALL  (15),                      Call it                      @
               ((11),                     ..DSA address                @
               RECAP,                     ..DCB                        @
               RCP_RLC,                   ..Line count                 @
               RCP_RPC,                   ..Page count                 @
               RCP_TITLE),                ..Title                      @
               MF=(E,PARMLIST)            ..Execute here
RCP$PEHX EQU   *
         PUT   RECAP,RCP_REC              Print record
         TM    FLAG1,$F1_ERROR            Error processing?
         BNO   RCP$TFPX                   No, continue
*
         LR    R1,R11                     Get address of DSA
         L     R15,=V(IDC$ERR)            -> Locate Error routine
         BALR  R14,R15                    Execute it
         B     RCP$TFPX                   Continue
*
** Save entry name into RO_NAME
*
RCP$SENT EQU   *
         LA    R1,RO_NAME-RO(R6)          Locate output location
RCP$SENTT EQU  *
         LR    R15,R4                     Locate start of record
         LA    R15,0(R5,R15)              Locate the end
         LA    R14,IL_MNAML(R4)           Bump to start of name
         SR    R15,R14                    Length of name = end - beg.
         MVC   0(0,R1),0(R14)             ** EXECUTED **
         EX    R15,*-6                    Move Entry to output area
         B     RCP$X
*
** Trap number from "-----10"  like dill
** Input: R14 - Length of "-----10"
**        R15 - Address of "-----10" string
**        R1 - Output full word number
**
** Note: This routine does not check for trailing blanks, you must hit
**       right on!!!
*
TRAPNUM  EQU   *
         CLI   0(R15),C'-'                Dash?
         BNE   TRAPNUMX                   No, at number!
         LA    R15,1(R15)                 Yes, Skip it
         BCT   R14,TRAPNUM                     Repeat for next byte
         XC    0(4,R1),0(R1)              Invalid number, set to zero
         BSM   0,R9                       Return to caller
TRAPNUMX EQU   *
         BCTR  R14,0                      Decrement for EX
         PACK  DOUBLE(8),0(0,R15)         ** Executed **
         EX    R14,*-6                    Convert zoned to packed
         CVB   R15,DOUBLE                 Convert packed to Binary
         ST    R15,0(R1)                  Save Number
         BSM   0,R9                       Return to caller
*
**       EDIT FULLWORD (FLUSH TO R15)
**       R1 --> INPUT:REGISTER TO PRINT
**       R15 --> OUTPUT: ADDRESS WHERE OUTPUT IS TO BE PUT
*
RCP$EFWF EQU   *
         LTR   R1,R1                      CHECK FOR 0
         BZ    RCP$EF0                    YES, PUT ZERO
         CVD   R1,DOUBLE                  NO, CONVERT TO PACKEC
         LA    R1,DOUBLE2+14              LOCATE SIG DIGIT
         MVC   DOUBLE2(15),RCPEP15
         EDMK  DOUBLE2(15),DOUBLE+2       EDIT AND SAVE PLACE
         LA    R14,DOUBLE2+16             LOCATE LAST POSSIBLE BYTE + 1
         SR    R14,R1                     LENGTH = END - START
         BCTR  R14,0                      DECREMENT FOR EX
         MVC   0(0,R15),0(R1)
         EX    R14,*-6                    MOVE EDIT NUMBER TO OUTPUT
         LA    R15,1(R14,R15)             BUMP POINTER PAST NUMBER
         BSM   0,R9                       RETURN TO CALLER
RCP$EF0  EQU   *
         MVI   0(R15),C'0'                PUT IN ZERO
         LA    R15,2(R15)                 BUMP POINTER PAST ZERO
         BSM   0,R9                       RETURN TO CALLER
*
** POINT REGISTER 15 TO FIRST BLANK IN STRING
** INPUT:  R0  - MAXIMUM LENGTH OF STRING
**         R15 - STRING
** OUTPUT: R15 - FIRST SPACE IN STRING
*
RCP$FS   EQU   *
         CLI   0(R15),C' '
         BE    RCP$FSX
         LA    R15,1(R15)
         BCT   R0,RCP$FS
RCP$FSX  EQU   *
         BSM   0,R14
*
** POINT REGISTER 15 TO FIRST BLANK IN STRING
** INPUT:  R0  - MAXIMUM LENGTH OF STRING
**         R15 - STRING
** OUTPUT: R15 - FIRST SPACE IN STRING
*
RCP$FNS  EQU   *
         CLI   0(R15),C' '
         BNE   RCP$FNSX
         LA    R15,1(R15)
         BCT   R0,RCP$FNS
RCP$FNSX EQU   *
         BSM   0,R14
*
** RUB OUT LEADING DASH
** INPUT: R0 LENGTH OF STRING
**        R15: ADDRESS OF STRING
*
RCP$ROD  EQU   *
         CLI   0(R15),C'-'                DASH?
         BNE   RCP$RODX                   NO, MOVE ON
         MVI   0(R15),C' '                YES, STRIP IT
         LA    R15,1(R15)                 BUMP TO NEXT BYTE
         BCT   R0,RCP$ROD                 ..AND DO IT TO IT
RCP$RODX EQU   *
         BSM   0,R14
         EJECT
***********************************************************************
***
**       IDC$RCP --- Constants
***
***********************************************************************
           SPACE 2
RCPEP15    DC    X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'
RCP_TITLE  DC    AL1(RCP_TITLEL-2),C'Recap of IDCAMS listing'
RCP_TITLEL EQU   *-RCP_TITLE
*
** Type table
*
         PRINT DATA
         DS    0F
T_TYPE   EQU   *
T_TYPEAI DC    AL1(03-1),CL11'AIX        ',AL4(RCP$IAI,RCP$OAI)
T_TYPEA  DC    AL1(05-1),CL11'ALIAS      ',AL4(RCP$IA,RCP$OA)
T_TYPEC  DC    AL1(07-1),CL11'CLUSTER    ',AL4(RCP$IC,RCP$OC)
T_TYPED  DC    AL1(04-1),CL11'DATA       ',AL4(RCP$ID,RCP$OD)
T_TYPEG  DC    AL1(03-1),CL11'GDG        ',AL4(RCP$IG,RCP$OG)
T_TYPEI  DC    AL1(05-1),CL11'INDEX      ',AL4(RCP$II,RCP$OI)
T_TYPENV DC    AL1(07-1),CL11'NONVSAM    ',AL4(RCP$INV,RCP$ONV)
T_TYPEPS DC    AL1(09-1),CL11'PAGESPACE  ',AL4(RCP$IPS,RCP$OPS)
T_TYPEP  DC    AL1(04-1),CL11'PATH       ',AL4(RCP$IP,RCP$OP)
T_TYPES  DC    AL1(05-1),CL11'SPACE      ',AL4(RCP$IS,RCP$OS)
T_TYPEU  DC    AL1(11-1),CL11'USERCATALOG',AL4(RCP$IU,RCP$OU)
T_TYPEN  EQU   ((*-T_TYPE)/T_TYPEL)       Number of entries
T_TYPEL  EQU   1+11+4+4                   Length of constant table ent
T_TYPER  EQU   T_TYPEN*RTL                Table length
*
T_TYPET  DC    AL1(05-1),C'TOTAL'
         PRINT NODATA
*
** IDC$RCP Literals
*
         LTORG ,
         DS    0D
         EJECT
***********************************************************************
***
**       Print Report (RECAP or ERROR) Record
***
***********************************************************************
         SPACE 2
         DROP  R11,R12
IDC$PRR  DA#ENTER 'PRINT REPORT RECORD',RENT=NO
         LM    R2,R6,0(R1)
         USING DSA,R2
*
** R2 = DSA area
** R3 = DCB
** R4 = Line count byte
** R5 = Page count fullword
** R6 = Title String
*
         EJECT ,
*
** Do we need a heading line
*
         SLR   R1,R1                      CLEAR REGISTER
         IC    R1,0(R4)                   GET LINE COUNT
         CH    R1,=H'56'                  MAX ON PAGE YET?
         BL    PRR$TX                     NO, LEAVE
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**    Print title / heading lines
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
*
** Initialize record area
*
         LA    R15,PRR_REC                Locate record
         MVI   0(R15),C' '                Clear it
         MVC   1(L'PRR_REC-1,R15),0(R15) ..Propagate it
         MVI   0(R15),C'1'                Set FBA byte for Top-Of-Page
         LA    R15,1(R15)                 Bump past FBA byte
*
** Get program name from DA#ENTER macro eyecatcher
*
         L     R1,EP_DA$IDC               Locate DA$IDC EPA
         MVC   0(8,R15),DA$IDC_ECNAME-DA$IDC(R1)
         LA    R15,8+1(R15)               Bump past it
*
** Print this file's title string
*
         MVI   0(R15),C'-'
         LA    R15,2(R15)
         SLR   R1,R1
         IC    R1,0(R6)
         MVC   0(0,R15),1(R6)
         EX    R1,*-6
         LA    R15,2(R1,R15)
         MVI   0(R15),C'-'                Insert Delimiter
         LA    R15,2(R15)                 Bump past it
*
** Get time and date
*
         SLR   R1,R1
         IC    R1,PRR_ODISO10_STRL
         BCTR  R1,0
         MVC   0(0,R15),PRR_ODISO10_STR
         EX    R1,*-6
         LA    R15,2(R1,R15)
         MVI   0(R15),C'-'
         LA    R15,2(R15)
*
         SLR   R1,R1
         IC    R1,PRR_OTIMES11_STRL
         BCTR  R1,0
         MVC   0(0,R15),PRR_OTIMES11_STR
         EX    R1,*-6
         LA    R15,2(R1,R15)
*
** Page number
*
         MVC   0(6,R15),=C'- Page'
         LA    R15,7(R15)
*
         L     R1,0(R5)                   GET PAGE COUNT
         LA    R1,1(R1)                   INCREMENT PAGE COUNT
         ST    R1,0(R5)                   SAVE PAGE COUNT
         BAS   R9,PRR_EDITFWF
         MVI   0(R15),C' '
*
** Print title line
*
         PUT   (3),PRR_REC
*
** Print heading lines
*
         LA    R15,PRR_REC                LOCATE RECORD
         MVI   0(R15),C' '                Clear it
         MVC   1(L'PRR_REC-1,R15),0(R15)  ..Propagate it
         MVI   PRR_REC,C'0'               SKIP A COUPLE OF LINES
         CLI   1(R6),C'R'
         BE    PRR$TH1R
         MVC   RO_NAME-RO(19,R15),=C'E n t r y   N a m e'
         MVC   RO_TYPE-RO(20,R15),=C'Description of Error'
         B     PRR$TH1P
PRR$TH1R EQU   *
         MVC   RO_NAME-RO(19,R15),=C'E n t r y   N a m e'
         MVC   RO_TYPE-RO(10,R15),=C'Entry type'
         MVC   RO_DEVT-RO(11,R15),=C'Device type'
         MVC   RO_VOLS-RO(13,R15),=C'Volume Serial'
         MVC   RO_CAT-RO(7,R15),=C'Catalog'
PRR$TH1P EQU   *
         PUT   (3),PRR_REC
*
         LA    R15,PRR_REC                LOCATE RECORD
         MVI   0(R15),C'-'                Clear it
         MVC   1(L'PRR_REC-1,R15),0(R15)  ..Propagate it
         MVI   0(R15),C' '                Clear it
         PUT   (3),PRR_REC
*
         SLR   R1,R1                      CLEAR LINE COUNT
PRR$TX   EQU   *
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**       Termination - return to caller
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
         LA    R1,1(R1)                   Increment line count
         STC   R1,0(R4)                   Save line count
         DA#LEAVE RENT=NO                 Return to caller
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**       IDC$PRR - Misc internal Subroutines
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
*
**       EDIT FULLWORD (FLUSH TO R15)
**       R1 --> INPUT:REGISTER TO PRINT
**       R15 --> OUTPUT: ADDRESS WHERE OUTPUT IS TO BE PUT
*
PRR_EDITFWF EQU *
         LTR   R1,R1                      CHECK FOR 0
         BZ    PRR_EDITFWF0               YES, PUT ZERO
         CVD   R1,DOUBLE                  NO, CONVERT TO PACKEC
         LA    R1,DOUBLE2+14              LOCATE SIG DIGIT
         MVC   DOUBLE2(15),PRR_EDITP15
         EDMK  DOUBLE2(15),DOUBLE+2       EDIT AND SAVE PLACE
         LA    R14,DOUBLE2+16             LOCATE LAST POSSIBLE BYTE + 1
         SR    R14,R1                     LENGTH = END - START
         BCTR  R14,0                      DECREMENT FOR EX
         MVC   0(0,R15),0(R1)
         EX    R14,*-6                    MOVE EDIT NUMBER TO OUTPUT
         LA    R15,1(R14,R15)             BUMP POINTER PAST NUMBER
         BSM   0,R9                       RETURN TO CALLER
PRR_EDITFWF0 EQU *
         MVI   0(R15),C'0'                PUT IN ZERO
         LA    R15,1(R15)                 BUMP POINTER PAST ZERO
         BSM   0,R9                       RETURN TO CALLER
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**       IDC$PRR - Constants
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
PRR_EDITP15  DC X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'
*
** Literals
*
         LTORG ,                          Literal used in IDC$PRR
         DS    0D
         DROP  R2,R12                     DSA=R2  IDC$PRR=R12
         EJECT
***********************************************************************
***
**       Error processing
***
***********************************************************************
         SPACE 2
IDC$ERR  DA#ENTER 'ERROR PROCESSING'
         LR    R11,R1                     Get address of DSA
         USING DSA,R11                    Addressibility
         LA    R10,RCP_REC                Locate input record
*
** Process based on input type
*
         CLC   RO_TYPE-RO(5,R10),=C'NONVSAM'
         BE    ERR$NV
*
** Common exit from IDC$ERR
*
ERR$X    EQU   *
         DA#LEAVE ,
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**   Process the dataset
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
ERR$NV   EQU   *
*
** Ensure DASD device
*
         CLI   RO_VOLS-RO(R10),C'0'       Tape volume?
         BL    ERR$NVD                    Yes, leave
         B     ERR$X                      Do checking
*
** Obtain F1DSCB
*
ERR$NVD  EQU   *                          DASD/DSCB checking
*
         MVC   PARMLIST(VTOCLOCL),VTOCLOC Initialize VTOC CAMLST area
         LA    R1,RO_NAME-RO(R10)
         ST    R1,PARMLIST+4
*
         LA    R1,RO_VOLS-RO(R10)         Default: Volume from IDCAMS
         CLC   0(6,R1),=C'MIGRAT'         HSM got this one?
         BNE   ERR$NVDOX                  No, continue
*
         CLC   0(6,R1),=C'******'         SYSRES indirect?
         BNE   ERR$NVDVX                  No, continue
         L     R1,CVTPTR                  -> CVT
         L     R1,CVTSYSAD-CVTMAP(,R1)    -> System Res UCB
         LA    R1,UCBVOLI-UCBOB(R1)       Locate IPL volume
ERR$NVDVX EQU *
         ST    R1,PARMLIST+8              Save Volume location
*
         LA    R1,ERR_F1DSCB              Locate DSCB
         ST    R1,PARMLIST+12             Save it
         OBTAIN PARMLIST                  Locate F1-DSCB for dataset
         LTR   R15,R15                    Found?
         BZ    ERR$NVDOX                  Yes, do some checking
*
         BAS   R14,ERR$CREC               Clear record
         MVC   0(13,R15),=C'Catalogued to'
         LA    R15,14(R15)
         MVC   0(6,R15),RO_VOLS-RO(R10)
         LA    R15,7(R15)
         MVC   0(25,R15),=C'but does not reside there'
         BAS   R9,ERR$PREC
         B     ERR$NVDX
ERR$NVDOX EQU  *
         LA    R2,ERR_F1DSCB              Locate F1DSCB
*
** Check for Secondary extents in a RECFM=U PDS
*
         TM    DS1RECFM-DS1FMTID(R2),DS1RECFU  RECFM=U
         BNO   ERR$NVDDUX                 No, continue
*
         CLC   DS1SCAL3-DS1FMTID(3,R2),=X'00,00,00'
         BE    ERR$NVDDUX
         BAS   R14,ERR$CREC               Clear record
         MVC   0(ERR_W1L,R15),ERR_W1      Get message
         BAS   R9,ERR$PREC                Clear record
ERR$NVDDUX EQU *
*
** Check for Expiration date
*
         CLC   DS1EXPDT-DS1FMTID(3,R2),=X'00,00,00'
         BE    ERR$NVDDEX
         BAS   R14,ERR$CREC               Clear record
         MVC   0(ERR_W2L,R15),ERR_W2      Get message
         BAS   R9,ERR$PREC                Clear record
ERR$NVDDEX EQU *
ERR$NVDX EQU   *                          End of DSCB checking
         B     ERR$X
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**    Misc internal subroutines
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
*
** Clear record area and set R15 to start of description
*
ERR$CREC EQU   *
         LA    R15,ERR_REC
         MVI   0(R15),C' '
         MVC   1(L'ERR_REC-1,R15),0(R15)
         MVC   ERR_REC+1(44),RO_NAME-RO(R10)
         LA    R15,1+RO_ERRS-RO(R15)
         BSM   0,R14
*
** Print record
*
ERR$PREC EQU   *
         TM    FLAG1,$F1_DATAO            Headings wanted?
         BO    ERR$PRHX                   No, skip heading stuff
         L     R15,=V(IDC$PRR)            Locate print routine
         CALL  (15),                      Call it                      @
               ((11),                     ..DSA address                @
               ERROR,                     ..DCB                        @
               ERR_RLC,                   ..Line count                 @
               ERR_RPC,                   ..Page count                 @
               ERR_TITLE),                ..Title                      @
               MF=(E,PARMLIST)            ..Execute here
ERR$PRHX EQU   *
         PUT   ERROR,ERR_REC
         BSM   0,R9
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**    Data areas for IDC$ERR
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
VTOCLOC  CAMLST SEARCH,*-*,*-*,*-*
VTOCLOCL EQU   *-VTOCLOC
*
ERR_TITLE DC   AL1(ERR_TITLEL-2),C'Error report'
ERR_TITLEL EQU *-ERR_TITLE
*
ERR_W1   DC    C'Load library allocated with secondary extents'
ERR_W1L  EQU   *-ERR_W1
ERR_W2   DC    C'Expiration date for disk data set'
ERR_W2L  EQU   *-ERR_W2
*
** Literals
*
         LTORG ,
         DS    0D
         EJECT
***********************************************************************
***
**       Getmained Work area - Shared between all CSECTs/Programs
***
***********************************************************************
              SPACE 2
DSA           DSECT ,
WORKRSA       DS    18F                   Register Save Area
PARMLIST      DS    20F                   Parameter List for calls
DOUBLE2       DS    2D                    Double word work area * 2
DOUBLE        DS    2D                    Double word work area
*                                         Entry point
EP_DA$DATE    DS    F                     ..DA#DATE
EP_IEFEB4UV   DS    F                     ..IEFEB4UV
EP_DA$IDC     DS    F                     ..DA$IDC
EP_DA$MXD     DS    F                     ..DA$IDC
*                                         Right_Justify
RJ_RA         DS    F                     ..Return address
              DS    0F                    IDCAMS
IDC_PARM      DS    F                     ..R1 ON ENTRY (JCL PARM)
IDC_IOL       EQU   *                     ..I/O LIST
IDC_ION       DS    F'1'                  ..NUMBER OF FW FOLLOWING
IDC_IODD      DS    F                     ..DDNAME STRING
IDC_IOR       DS    F                     ..ROUTINE
IDC_IOUD      DS    F                     ..ROUTINE
IDC_P         EQU   *                     ..PAGE NUMBER
IDC_PL        DS    AL2(L'IDC_PNUM)       ..LENGTH
IDC_PNUM      DS    CL3'100'              ..NUMBER
*
** Input/Output Record areas
*
              DS    0H
RECOUTV       DS    XL4                   Variable record RDW
RECOUT        DS    CL133                 Data area
RECOUTVL      EQU   *-RECOUTV
RECOUTS       DS    XL(RECOUTVL)          Save record
*
** Debug work areas
*
              DS    0F
$$DEBUGW      DS    XL(CMXDL)             DA#MXD work area
$$DEBUG       DS    XL(DCBLNGQS)          DCB area
$$DEBUGR      DS    CL133                 Output record area
*
** Date routine work areas
*
              DS    0F
W_ODDOWA      DA#DATE DPE,OPREFIX=W_ODDOWA,                            @
               OSTR=YES,OFLAG=$DA#DATE_ADDR,OSTRL=4
W_ODISOA      DA#DATE DPE,OPREFIX=W_ODISOA,                            @
               OSTR=YES,OFLAG=$DA#DATE_ADDR,OSTRL=4
W_OTIMESA     DA#DATE DPE,OPREFIX=W_OTIMESA,                           @
               OSTR=YES,OFLAG=$DA#DATE_ADDR,OSTRL=4
W_IDJULC8     DA#DATE DPE,OPREFIX=W_IDJULC8,OSTR=YES,                  @
               OSTRL=$DA#DATE_IDJULC8,OTYPE=$DA#DATE_IDJULC
W_ISTMPC16    DA#DATE DPE,OPREFIX=W_ISTMPC16,OSTR=YES,                 @
               OSTRL=$DA#DATE_ISTMPC16,OTYPE=$DA#DATE_ISTMPC
*
** Print Routine
*
PRR_ODISO10   DA#DATE DPE,OPREFIX=PRR_ODISO10,OSTR=YES,                @
               OSTRL=$DA#DATE_ODISO10,OTYPE=$DA#DATE_ODISO
PRR_OTIMES11  DA#DATE DPE,OPREFIX=PRR_OTIMES11,OSTR=YES,               @
               OSTRL=$DA#DATE_OTIMES11,OTYPE=$DA#DATE_OTIMES
PRR_REC       DS    CL133                 Output record
              DS    0F                    Recap area
RCP_OVSC      DS    F                     ..Output Volser - Current
RCP_OVSE      DS    F                     ..Output Volser - Last
RCP_TBL       DS    XL(T_TYPER)           ..Table for routines
RCP_TBLT      DS    XL(RTL)               ..Total entry
RCP_TBLC      DS    F                     ..Current entry
RCP_TBLN      DS    F                     ..Next entry (temp)
RCP_WA        DS    XL256                 ..Work area
RCP_REC       DS    CL133                 ..Output record
RCP_RPC       DS    F                     ..Page count
RCP_RLC       DS    X                     ..Line count
              DS    0F                    Error
ERR_RPC       DS    F                     ..Page count
ERR_RLC       DS    X                     ..Line count
ERR_REC       DS    CL133                 ..output record
ERR_F1DSCB    DS    CL140                 .. F1DSCB w/DSNAME
              DS    0F                    I/O routine
IOR_JFCBX     DS    F                     ..JFCB EXLST
IOR_JFCB      DS    CL176                 ..JFCB area
              DS    0F
HT_SAVEREGS   DS    4F                    Save regs for HEXTRAN
DT_VALUE      DS    CL8'78048083'         Device Type hex string
DT_FILESEQ    DS    CL4'---1'             File sequence
*
SYSPRINT      DS    XL(DCBLNGQS)          DCB area
RECAP         DS    XL(DCBLNGQS)          DCB area
ERROR         DS    XL(DCBLNGQS)          DCB area
*
** Flags
*
FLAG_LIT     DS    C'FLAG'                Literal for dumps
FLAG1        DS    B'00000000'            Execution flag 1
$F1_RECAP    EQU   B'10000000'            ..RECAP report?
$F1_ERROR    EQU   B'01000000'            ..Error report?
$F1_DATAO    EQU   B'00100000'            ..No heading?
$F1_DEBUG    EQU   B'00010000'            ..Debugging mode?
$F1_HEADING  EQU   B'00001000'            ..Printed first IDCAMS head?
$F1_LDA#DATE EQU   B'00000100'            ..Loaded DA#DATE?
$F1_LDA#MXD  EQU   B'00000010'            ..Loaded DA#MXD?
FLAGP1       DS    B'00000000'            IOR (processing) flag 1
$FP1_MOD     EQU   B'10000000'            ..Modified record?
$FP1_ADD     EQU   B'01000000'            ..Added record?
$FP1_DEL     EQU   B'00100000'            ..Delete record?
             DS    0D                     Alignment for FREEMAIN
DSAL         EQU   *-DSA                  Length of DSECT area
         EJECT
***********************************************************************
***
**       Internal DSECTs
***
***********************************************************************
         SPACE 2
*
** IDC$IOR --- IDCAMS I/O FLAG MAP
*
IOF      DSECT ,                          I/O FLAGS
IOF_B1   DS    X                          ..BYTE 1
$IOF_O   EQU   X'00'                        ..OPEN
$IOF_C   EQU   X'04'                        ..CLOSE
$IOF_G   EQU   X'08'                        ..GET
$IOF_P   EQU   X'0C'                        ..PUT
IOF_B2   DS    X                          ..BYTE 2
$IOF_OI  EQU   B'10000000'                  ..OPEN FOR INPUT
$IOF_OO  EQU   B'01000000'                  ..OPEN FOR OUTPUT
$IOF_OFI EQU   B'00100000'                  ..INFO HAS ADDR(DDNAME)
$IOF_OFO EQU   B'00010000'                  ..INFO HAS ADDR(DSN)
IOF_B3   DS    X                          ..BYTE 2
IOF_B4   DS    X                          ..BYTE 2
*
** IDC$RCP --- RECAP TYPE TABLE MAP
*
RT       DSECT ,                          Routine table
RT_TYPEL DS    X                          ..Type length
RT_TYPE  DS    CL11                       ..Type literal
RT_IROUT DS    A                          ..Input Routine
RT_OROUT DS    A                          ..Output routine
RT_OFF   DS    X                          ..Offset in print record
RT_CNT   DS    XL3                        ..Count
RTL      EQU   *-RT                       Length of entry
*
** IDC$RCP --- RECAP REPORT DETAIL LINE MAP
*
RO       DSECT
         DS    CL1
RO_NAME  DS    CL44
         DS    CL1
RO_ERRS  EQU   *
RO_TYPE  DS    CL11
         DS    CL2
RO_DEVT  DS    CL11
         DS    CL2
RO_VOLS  DS    CL61
RO_CAT   EQU   RO_VOLS+15
RO_ERRL  EQU   *-RO_ERRS
         EJECT
***********************************************************************
***
**       IDCAMS LISTING DSECTS
***
***********************************************************************
         SPACE 2
IL       DSECT ,
*
** MISC FIELDS (COMMON TO MULIPLE TYPES)
*
IL_MVS   DS    C'0       VOLSER------------'
IL_MVSL  EQU   *-IL_MVS
IL_MDT   DS    C'0       DEVTYPE------'
IL_MDTL  EQU   *-IL_MDT
IL_MFBA  DS    C'0'                       FBA BYTE
IL_MFBAL EQU   *-IL_MFBA
IL_MNAM  DS    C'0       XXXXXX---'
IL_MNAML EQU   *-IL_MNAM
IL_MOPT  DS    C'0       '
IL_MOPTL EQU   *-IL_MOPT
*
** GDG SPECIFIC
*
IL_GN    DS    C'0   '
IL_GNL   EQU   *-IL_GN
IL_GLMT  DS    C'0'
         DS    CL7' '
         DS    C'LIMIT----------------'
IL_GLMTL EQU   *-IL_GLMT
         DS    C'123'
         DS    C'     '
IL_GATTR1L EQU *-IL_GLMT
         DS    CL10'SCRATCH'
         DS    CL4' '
IL_GATTR2L EQU *-IL_GLMT
         DS    CL10'   NOEMPTY'
*
** NON-VSAM SPECIFIC
*
IL_D     DS    C'0       '
         DS    C'VOLSER------------'
IL_DVS   EQU   *-IL_D
         DS    C'123456'
         DS    C'     '
         DS    C'DEVTYPE------'
IL_DDT   EQU   *-IL_D
         DS    C'X"12345678"'
         DS    C'     '
         DS    C'FSEQN---------------'
IL_DFS   EQU   *-IL_D
         DS    C'1234'
         END
         EJECT
***********************************************************************
***
**        Linkage editor cards - ASM.PARM='BATCH,...'
***
***********************************************************************
         SPACE 2
 PUNCH ' ENTRY   DA$IDC'                  Entry point
 PUNCH ' SETCODE AC(1)'                   APF Authorization
 PUNCH ' INCLUDE SYSLMOD(DA$DATE)'        Subroutine: Date routine
 PUNCH ' INCLUDE SYSLMOD(DA$MXD)'         Subroutine: Mini-Hex-Dump
 PUNCH ' NAME    DA$IDC(R)'               Name of load module
         END ,
./ ADD NAME=DA$MXD   0100-01266-01266-1821-00507-00507-00000-DAVE
DA$MXD   TITLE 'Mini-Hex-Dump routine'
***********************************************************************
***
** Name: DA$MXD - External subroutine
**
*  Author = David Alcock :: dave@planetmvs.com
**
** Date: 02-MAR-1985
**
** Purpose: Produce a mini Hex dump one line at time, varying output
**          length based on input.
**
** Attributes: Reentrant, Reusable, Runs above the line
*
* Disclaimer: This program is FREEWARE.  Use at your own risk.  It
*             is provided for your enjoyment and neither David
*             Alcock or his employer provides any warranty for it's
*             use.  I'd like to hear how it works on your system.
*
*             This software is not in the public domain but is
*             available free of charge and with source code
*             provided.  It is copyright 2001+ by David Alcock
*             All rights reserved.
*
** Non-IBM assembler MACROs:
** o DA#ENTER...Entry housekeeping
** o DA#LEAVE...Termination housekeeping
** o DA#EYEC....Build standard O/S module eyecatcher
**              (invoked by the DA#ENTER)
** o DA#REGS....Define registers (invoked by DA#ENTER)
** o DA#MXD.....Equates and DSECTs for the mini-hex-dump routine
**
** Input: CMXD DSECT (Expanded with DA#MXD MACRO). The minuimum
**        input is CMXD_ADDRESS CMXD_LENGTH and CMXD_OUTPUT with
**        the assumption of 80 byte output. Callers executing in
**        24 bit mode should invoke via BASSM.
***
***********************************************************************
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*  Sample program to invoke DA$MXD
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*TESTIT   DA#ENTER 'SAMPLE DA$MXD INVOCATION'
*         XC    WORKA(CMXDL),WORKA
*         MVC   WORKA+CMXD_ADDRESS-CMXD(12),=A(DATA,DATAL,OUTPUT)
**-> OPT: MVC   WORKA+CMXD_OUTPUTL-CMXD(2),=AL2(132)
*LOOP     EQU   *
*         LA    R1,WORKA                   LOCATE WORK AREA
*         LINK  EP=DA$MXD                  CALL DA$MXD
*         LR    R2,R15                     SAVE RETURN CODE
*         TPUT  OUTPUT,L'OUTPUT            PRINT HEX DUMP LINE
*         LTR   R2,R2                      CHECK RETURN CODE
*         BNZ   LOOP                       NEED ANOTHER LINE
*         DA#LEAVE RC=0                    LEAVE
*WORKA    DS    XL(CMXDL)                  WORK AREA
*DATA     DC    X'00,00,00,00,11,11,11,11,22,22,22,22,33,33,33,33'
*         DC    C'0123456789ABCDEF'
*         DC    C'DDDDAAAAVVVVEEEE'
*         DC    C'LASTONE'
*DATAL    EQU   *-DATA
*OUTPUT   DC    CL132' '
*         LTORG ,                            LITERALS
*         DA#MXD ,                           MAP DSECT
*         END   ,
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         EJECT ,
&DAVER   SETC  '1.4'
         SPACE 2
***********************************************************************
***
**           M o d i f i c a t i o n   H i s t o r y
**
** Person     Date        Ver Description
** ---------- ----------- --- ---------------------------------------
** D Alcock   2000-01-04  1.4 Added version
** D Alcock   28-APR-1997 1.3 Converted CMXD_OFFSET to fullword;
** D Alcock   13-NOV-1996 1.2 Renamed to DA$MXD;
** D Alcock   11-MAR-1991 1.1 Added CAPs support for character dumps;
** D Alcock   02-MAR-1985 1.0 Initial program written
***
***********************************************************************
         EJECT ,
DA$MXD   DA#ENTER 'V&DAVER Subroutine: Mini-Hex-Dump',                 @
               RSA=(R1),                Work area in R1                @
               AMODE=31,RMODE=ANY       Any where in V/S
         USING CMXD,R13                 Get addressability to DSA
         EJECT ,
***********************************************************************
***                                                                 ***
**              Master control                                       **
***                                                                 ***
***********************************************************************
 SPACE 2
MINI_HEX_DUMP EQU *
 LM    R4,R5,CMXD_ADDRESS                 Get address and length
*
** Next line?
*
 TM    W_FLAG1,$W_F1NEXT                  Next line?
 BNO   MXD$FIRST                          No, first time thru
 LM    R5,R7,W_REGS                       Get registers
 B     MXD$START
*
** First time initialization and calculations
*
MXD$FIRST EQU *
 MVC   CMXD_LIT(4),=C'CMXD'               Set literal for dumps
*
 ICM   R0,B'1111',CMXD_TRTAB              User specified trans table?
 BNZ   MXD$FTX                            Yes, continue
 TM    CMXD_FLAG1,$CMXD_F1CAPS            Only caps?
 BNO   MXD$FTL                            No, continue
 LA    R1,TRANTABU                        Table with no lower case
 B     MXD$FTLX                           Continue
MXD$FTL EQU *
 LA    R1,TRANTAB                         Get address of default table
MXD$FTLX EQU *
 ST    R1,CMXD_TRTAB                      Save it for later
MXD$FTX EQU *
*
 CLC   CMXD_OUTPUTL(2),ZEROS              Output length there?
 BNE   MXD$FOLX                           Yes, continue
 MVI   CMXD_OUTPUTL+1,80                  Default to 80
 MVC   W_CHARL(2),TO_DEF+TO_CHARL-TO      Set default length (16)
 B     MXD$OX                             Leave
MXD$FOLX EQU *
 LA    R0,T_OUTN                          Get number in table
 LA    R1,T_OUT                           Get address in table
 LH    R14,CMXD_OUTPUTL                   Get output length
 TM    CMXD_FLAG1,$CMXD_F1ADDR            Address?
 BNO   MXD$OL                             No, continue
 SH    R14,=H'9'                          Subtract length
MXD$OL EQU *
 CLM   R14,B'0011',TO_MAXLEN-TO(R1)       Maximum length?
 BH    MXD$OLX                            Fits, use it
 LA    R1,TOL(R1)                         Bump to next one
 BCT   R0,MXD$OL                          Continue
 L     R15,CMXD_OUTPUT                    -> output area
 MVC   0(32,R15),=C'DA$MXD: ERROR IN CMXD_OUTPUTL'
 SLR   R15,R15                            Indicate no more coming
 B     EXIT                               Leave
MXD$OLX EQU *
 MVC   W_CHARL(2),TO_CHARL-TO(R1)         Set to new character length
MXD$OX EQU *
*
 SLR   R6,R6                              Clear register
 LR    R7,R5                              Get total length
 LH    R15,W_CHARL                        Number of bytes to process
 DR    R6,R15                             Calculate the number of lines
*
** Start of hex dump activity
**
** R6 - Number of bytes on last line
** R7 - Number of full lines
*
MXD$START EQU *
 LTR   R7,R7                              Any full lines?
 BZ    SHORT_LINE                         No, move on
 EJECT ,
***********************************************************************
***                                                                 ***
**              Print complete lines                                 **
***                                                                 ***
***********************************************************************
 SPACE 2
FULL_LINE_LOOP EQU *
 BAS   R14,INITIALIZE_LINE                Initialize the line
*
** Format hex area (4 fullwords)
*
 LH    R0,W_CHARL                         Get length to process
 SRL   R0,2                               Divide by 4 to get # of FWs
 LR    R1,R4                              Locate input bytes
 BAS   R14,FORMAT_HEX_FULLWORDS           Full_Word_Line_Dump
*
** Translate character portion
*
 LH    R14,W_CHARL                        Get number of bytes
 BAS   R9,TRANSLATE_CHARACTERS
*
** Bump to next area
*
FLL$B EQU *
 AH    R4,W_CHARL                         Bump past to next 16 bytes
 SH    R5,W_CHARL                         Decrement total length
*
 L     R1,CMXD_ADDRESS                    Get current address
 AH    R1,W_CHARL                         Add for length just done
 ST    R1,CMXD_ADDRESS                    New address for next time
*
 L     R1,CMXD_OFFSET                     Get current offset
 AH    R1,W_CHARL                         Add for length just done
 ST    R1,CMXD_OFFSET                     Save for next time thru
*
 BCT   R7,FLL$NEXT                        Do next one
*
** End of full line loops, if no more signal it
*
 LTR   R5,R5                              Any more work to do?
 BNZ   FLL$NEXT                           Yes, print remaining bytes
 SLR   R15,R15
 B     EXIT                               Leave
*
** Perform next line
*
FLL$NEXT EQU *
 OI    W_FLAG1,$W_F1NEXT                  Next line mode
 STM   R5,R7,W_REGS                       Get registers
 LA    R15,4                              Set MORE return code
 B     EXIT
 EJECT ,
***********************************************************************
***                                                                 ***
**        Print hex dump lines which are less than a full one        **
***                                                                 ***
***********************************************************************
 SPACE 2
SHORT_LINE EQU *
 BAS   R14,INITIALIZE_LINE                Initialize hex line
*
** Format line
*
 ST    R15,DOUBLE
 LH    R1,W_CHARL                         Get character length
 SRL   R1,2                               Divide by 4 for number of FWs
 MH    R1,=H'9'                           Get length of hex area
 AR    R15,R1                             Bump past hex area
 LR    R14,R5                             Get number of characters
 BAS   R9,TRANSLATE_CHARACTERS            Translate characters
 L     R15,DOUBLE
*
** Calculate number of fullwords to print - into R7
*
 SLR   R6,R6                              Clear register
 LR    R7,R5                              Get total bytes left
 LA    R14,4                              Number of full words
 DR    R6,R14                             Calculate the number of lines
*
** Format the fullwords
*
 LTR   R7,R7                              Full words to do?
 BZ    SL$RBL                             No, less than 4 bytes left
 LR    R1,R4                              Locate input
 LR    R0,R7                              Get number of fullwords
 BAS   R14,FORMAT_HEX_FULLWORDS           Full_Word_Line_Dump
*
 MH    R7,=H'4'                           Calculate Total FW byte count
 LA    R4,0(R7,R4)                        Bump past what we just did
 SR    R5,R7                              Decrement the total count
*
** Format leftover bytes (less than 4)
**
** R5 - total length left  should be less than 4
** R4 - Address of remaining bytes
*
 LTR   R5,R5                              Any more to do?
 BZ    SL$PLL                             None, leave
SL$RBL EQU *
 UNPK  0(3,R15),0(2,R4)                   **
 MVZ   0(2,R15),ZEROS                     *** Hex convert
 TR    0(2,R15),HEXSTR                    **
 LA    R4,1(R4)                           Bump past input byte
 LA    R15,2(R15)                         Bump past output byte
 BCT   R5,SL$RBL                          ..repeat
 MVI   0(R15),C' '                        Fix byte
SL$PLL EQU *
*
** Common exit
*
SL$X EQU *
 SLR   R15,R15                            Last line...
 EJECT ,
***********************************************************************
***                                                                 ***
**       Common exit                                                 **
***                                                                 ***
***********************************************************************
 SPACE 2
EXIT EQU *
 DA#LEAVE RC=(15)                        Return to caller
 EJECT ,
***********************************************************************
***                                                                 ***
**            Initialize output line                                 **
***                                                                 ***
***********************************************************************
 SPACE 2
INITIALIZE_LINE EQU *
 L     R15,CMXD_OUTPUT                    Locate CHAR start location
*
 TM    CMXD_FLAG1,$CMXD_F1ADDR            Address wanted?
 BNO   IL$ADDRX                           No, continue
 UNPK  0(9,R15),CMXD_ADDRESS(5)           **
 MVZ   0(8,R15),ZEROS                     *** Hex convert
 TR    0(8,R15),HEXSTR                    **
 MVI   8(R15),C' '                        Fix corrupted byte
 LA    R15,9(R15)                         Bump past address
IL$ADDRX EQU *
*
 TM    CMXD_FLAG1,$CMXD_F1MOFF            Want max offset?
 BO    IL$MAX                             Yes, continue
 CLC   CMXD_LENGTH(4),=AL4(256)
 BNH   IL$O256
 CLC   CMXD_LENGTH(4),=AL4(32768)
 BNH   IL$OHW
*
IL$MAX DS 0H
 MVI   0(R15),C'+'                        Indicate we are an offset
 UNPK  1(9,R15),CMXD_OFFSET(5)            **
 MVZ   1(8,R15),ZEROS                     *** Hex convert
 TR    1(8,R15),HEXSTR                    **
 MVI   1+8(R15),C' '                      Fix corrupted byte
 LA    R15,8+2(R15)                       Past "+0000"
 B     IL$OX
*
IL$O256 DS 0H
 MVI   0(R15),C'+'                        Indicate we are an offset
 UNPK  1(3,R15),CMXD_OFFSET+3(2)          **
 MVZ   1(2,R15),ZEROS                     *** Hex convert
 TR    1(2,R15),HEXSTR                    **
 MVI   1+2(R15),C' '                      Fix corrupted byte
 LA    R15,2+2(R15)                       Past "+00"
 B     IL$OX
*
IL$OHW DS 0H
 MVI   0(R15),C'+'                        Indicate we are an offset
 UNPK  1(5,R15),CMXD_OFFSET+2(3)          **
 MVZ   1(4,R15),ZEROS                     *** Hex convert
 TR    1(4,R15),HEXSTR                    **
 MVI   1+4(R15),C' '                      Fix corrupted byte
 LA    R15,4+2(R15)                       Past "+0000"
IL$OX  DS 0H
*
 LH    R1,W_CHARL                         Get character length
 SRL   R1,2                               Divide by 4 for number of FWs
 MH    R1,=H'9'                           Get length of hex area
 AH    R1,=H'2'                           Add for "*" characters
 AH    R1,W_CHARL                         Add in characters
 MVI   0(R15),C' '                        Get blank
 EX    R1,IL$CLEAR                        Set output area to blanks
*
 BSM   0,R14                              Return
IL$CLEAR MVC   1(0,R15),0(R15)            Propagate blanks
 EJECT ,
***********************************************************************
***                                                                 ***
**                 Full Word Line Dump                               **
**                                                                   **
**         Input: R0 - Number of Fullwords                           **
**                R1 - Address of Fullwords (input)                  **
**                R15 - Address to put output                        **
**                                                                   **
**    Note: The extra "MVC" before the "UNPK" has to be done or a    **
**          S0C4 can occur if the area to be dumped is at the        **
**          last 4 bytes. (It ** only misses by 1 byte)              **
***                                                                 ***
***********************************************************************
 SPACE 2
FORMAT_HEX_FULLWORDS EQU *
 MVC   DOUBLE(4),0(R1)                    Move full word to be dumped
 UNPK  0(9,R15),DOUBLE(5)                 **
 MVZ   0(8,R15),ZEROS                     *** Hex convert
 TR    0(8,R15),HEXSTR                    **
 MVI   8(R15),C' '                        Fix that last byte
 LA    R15,9(R15)                         Bump past this hex string
 LA    R1,4(R1)                           Bump to next full word
 BCT   R0,FORMAT_HEX_FULLWORDS            Repeat as necessary
 BSM   0,R14                              Return
 EJECT ,
***********************************************************************
***                                                                 ***
**               Translate character portion                         **
**                                                                   **
**  Input: R14 - Length                                              **
**         R15 - Output location on line                             **
**         R4  - Address of character                                **
***                                                                 ***
***********************************************************************
 SPACE 2
TRANSLATE_CHARACTERS EQU *
 MVI   0(R15),C'*'                        Insert our delimiter
 BCTR  R14,0                              Decrement by 1 for EX
 EX    R14,TC$MOVEC                       Move in the characters
 L     R1,CMXD_TRTAB                      -> Translate table
 EX    R14,TC$TRAN                        Translate the characters
 AH    R15,W_CHARL                        Bump past characters
 MVI   1(R15),C'*'                        Insert ending
 BSM   0,R9
*
TC$TRAN  TR    1(0,R15),0(R1)
TC$MOVEC MVC   1(0,R15),0(R4)
 EJECT ,
***********************************************************************
***                                                                 ***
**              Error routines                                       **
***                                                                 ***
***********************************************************************
 SPACE 2
E$ EQU *
 SLR   R15,R15
 B     EXIT
 EJECT ,
***********************************************************************
***                                                                 ***
**                     C o n s t a n t s                             **
***                                                                 ***
***********************************************************************
 SPACE 2
*
** Constants
*
ZEROS    DC    8X'00'                  Zeros
HEXSTR   DC    C'0123456789ABCDEF'     Hex convert table
*
** Character translate table (with lower case)
*
TRANTAB  DC    256C'.'
         ORG   TRANTAB+C' '
         DC    C' '
         ORG   TRANTAB+C'$'
         DC    C'$'
         ORG   TRANTAB+C'#'
         DC    C'#'
         ORG   TRANTAB+C'@'
         DC    C'@'
*
         ORG   TRANTAB+C'a'
         DC    C'abcdefghi'
         ORG   TRANTAB+C'j'
         DC    C'jklmnopqr'
         ORG   TRANTAB+C's'
         DC    C'stuvwxyz'
*
         ORG   TRANTAB+C'A'
         DC    C'ABCDEFGHI'
         ORG   TRANTAB+C'J'
         DC    C'JKLMNOPQR'
         ORG   TRANTAB+C'S'
         DC    C'STUVWXYZ'
*
         ORG   TRANTAB+C'0'
         DC    C'0123456789'
         ORG   ,
*
** Character translate table (with no lower case)
*
TRANTABU DC    256C'.'
         ORG   TRANTABU+C' '
         DC    C' '
         ORG   TRANTABU+C'$'
         DC    C'$'
         ORG   TRANTABU+C'#'
         DC    C'#'
         ORG   TRANTABU+C'@'
         DC    C'@'
*
         ORG   TRANTABU+C'A'
         DC    C'ABCDEFGHI'
         ORG   TRANTABU+C'J'
         DC    C'JKLMNOPQR'
         ORG   TRANTABU+C'S'
         DC    C'STUVWXYZ'
*
         ORG   TRANTABU+C'0'
         DC    C'0123456789'
         ORG   ,
*
** Output table
*
T_OUT    EQU   *
         DC    AL2(32,#TO32)        120
TO_DEF   DC    AL2(16,#TO16)         80
         DC    AL2(8,#TO8)           40
T_OUTN   EQU   (*-T_OUT)/TOL
*
#TO8     EQU   ((8/4)*9)+8+2
#TO16    EQU   ((16/4)*9)+16+2
#TO32    EQU   ((32/4)*9)+32+2
*
** Literals
*
 LTORG ,
 DS    0D
 EJECT ,
***********************************************************************
***                                                                 ***
**       Passed Dynamic Save Area                                    **
***                                                                 ***
***********************************************************************
 SPACE 2
 DA#MXD ,                                 Generate work area
 ORG   CMXD_VAR                           Locate to our variable area
            DS    0D
DOUBLE      DS    D                       Double word work area
SL_HEXS     DS    F
W_REGS      DS    3F                      Registers save passed invoc.
W_CHARL     DS    H                       Character/processing length
W_FLAG1     DS    X                       Flag 1
$W_F1NEXT   EQU   B'10000000'             ..Processing next line?
 ORG ,
*
** Map T_OUT table
*
TO          DSECT ,
TO_CHARL    DS    XL2
TO_MAXLEN   DS    XL2
TOL         EQU   *-TO
 END ,
./ ADD NAME=DA$PDSR  0101-01344-02221-1557-12915-12907-00000-DALCOCK
DA$PDSR  TITLE 'The PDS Report Utility'


* Note: PARM=CALLRACF doesn't work yet.  It gets
*       icheinty locate rc=00000030


* =================================================================== *
*
* Name: DA$PDSR
*
* Author = David Alcock :: dave@planetmvs.com
*
* Purpose: PDS (Partitioned Data Set) reporting
*          See text at label HELPTEXT for more information *OR*
*          execute this program with PARM='HELP'
*
* Attributes: Reentrant, Reusable, NonAuthorized (except for RACF call)
*
* Requirements:
* o MVS/ESA and higher
* o Assembler H and higher
* o Some functions require DFSMS/MVS. We test for the level of
*   DF/SMS at assembly (look at DSECTs) and execution (look at
*   various control blocks).
*
* Non-IBM External programs:
* o DA$DATE....Date routine
* o DA$MXD.....Mini-Hex-Dump routine
*
* Non-IBM assembler MACROs:
* o DA#ENTER...Entry housekeeping
* o DA#LEAVE...Termination housekeeping
* o DA#EYEC....Build standard O/S module eyecatcher
*              (invoked by the DA#ENTER)
* o DA#REGS....Define registers (invoked by DA#ENTER)
* o DA#DATE....Equates and DSECTs for the date routine
* o DA#MXD.....Equates and DSECTs for the mini-hex-dump routine
* o DA#SMODE...Change addressing mode to/from 24 bit/31 bit
* o DA#STR.....Create Pascal-like string with length byte (-1)
*
* Reference: SC26-4916 DFSMS/MVS Program Management
*            LY26-3902 MVS/XA Linkage Editor Logic (old)
*
* CSECTs used:
* o Internal:
*   o DA$PDSR  - Main CSECT
*   o PDSR$APF - APF library check
*   o PDSR$RBF - Read BKLIDS file
*   o PDSR$PRR - Print Report Record
*   o PDSR$PSR - Print SYSPRINT Record
*   o PDSR$MSG - Messages
*   o PDSR$C1  - Constants CSECT 1
*   o PDSR$C2  - Constants CSECT 2
*   o PDSR$TRT - Translator and LKED Tables
*   o PDSR$HLP - Help Information
*   o PDSR$DA  - Dynamic Allocation
*   o PDSR$LMF - Load Module formating
*   o PDSR$IS  - ISPF Stats formating
*   o PDSR$DSP - Dataset Summary Processing
*   o PDSR$PPC - Parse Parameter Card and SYSIN
*   o PDSR$IVC - Ignore Vendor CSECTs
*   o PDSR$EC  - Eyecatcher formatter
*   o PDSR$COC - COBOL CICS verification
*   o PDSRCM   - Binder API reports
*   o PDSRCMC  - Constants CSECT for PDSRCM
*   o PDSRCMFM - FLATOUT member processing
*   o PDSRCMM  - Msg Exit for PDSRCM
* o External (optionally linked into us):
*   o DA$DATE  - Date routine
*   o DA$MXD   - Mini-Hex Dump
*
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
* Basic Logic:
*
*  Initialization: open files, init Binder API, etc.
*  |
*  |  Loop thru DDNAMEs and/or LNKLST and/or LPALST for PDSes
*  |  |
*  |  |  Open Partitioned Datasets
*  |  |  |
*  |  |  |  Process each member in the directory
*  |  |  |  |
*  |  |  |  | > Non-DFSMS: Look at IDR information
*  |  |  |  | > DFSMS: Invoke the Binder API for each member
*  |  |  |  |   and put output to //TRANRPT, //HISTRPT, etc.
*  |  |  |  |
*  |  |  |  Print report line about member information to //REPORT
*  |  |  |
*  |  |  Close PDS file
*  |  |
*  |  Print summary (next release of DA$PDSR)
*  |
*  Terminate: Term Binder API, close files, return to caller
*
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*   E n h a n c e m e n t   I d e a s
*
* o Extend EDITNCF and PDSRCM_EDITNCF to do a full 16 byte edit
*   pattern and not just the 8
* o Need to check #G_MAXFILES somewhere prudent
* o PDSR$DA could be changed to regular call not base 8
* o Module sizes in report need to be 8 bytes instead of 6.
* o Correct "Totals" report header at the bottom of load libs.
* o Convert julian date to gregorian in Translater/history reports
* o File space information
* o Create an ESTAE to gain control back if we aren't lucky in
*   processing a member;
* =================================================================== *
         EJECT ,
&DAVER SETC    '2.7'
* =================================================================== *
*
*             M o d i f i c a t i o n   H i s t o r y
*
* 2002-08-09 -- David Alcock -- V2.7:
* - Eliminated unrequested lines in //REPORT for PARM=DATAONLY;
*
* 2001-09-23 -- David Alcock -- V2.6:
* - Add module link date to //FLATOUT output record for module rec.
* - Added heading line so to document the level of DA$PDSR used.
*   --> Incompatiblity in Flatout output (from 2.5)
*   --> 1) Inserted Link Date "DATE: value" before "ATTR:"
*   --> 2) Added new type "H" for heading line showing DA$PDSR info
*   --> If proessing FLATOUT output, you will need to allow for these
*
* 2000-09-10 -- David Alcock -- V2.5:
* - Added Processing of BKLIDS file (this associates a full name
*   with a userid). This is used in the ISPF stats process only.
*   Although the BKLIDS is an CA-ACF2 maintained sequential file,
*   any shop can create a sequential file with the same fields
*   to associate a userid with a name.
* - Added preliminary support for PARM=CALLRACF to do calls to RACF for
*   each userid for ISPF statistics.  This code currently hasn't been
*   observed to work fully because I only have access to an ACF2
*   system.  I also need to do the following:
*   - Save user information that RACF passes to us so as to cut
*     I/O to RACF database.  Should be saved into BKL control block...
*   - See if RACROUTE extract might be better - RACF manual says so...
*
* 10-NOV-1998 - ??-???-1998 -- David Alcock -- V2.4:
* - Eliminate message for GETN/RC4/RSN8300800 if flag EODC not on;
*
* 05-AUG-1998 -- David Alcock -- V2.3:
* - Test for RC=4 and 83000801 for GETN call for CA-PDSMAN $$$SPACE
*   member loops;
* - Fix MSG999 TIME=00:00:00 to show correct time;
*
* 30-MAR-1998 - 03-APR-1998 -- David Alcock -- V2.2:
* - Added vendor CSECT total counting and printing by category
* - Added time on start and end messages
* - Added option: NOEAGLE for people who don't want to see it or use
*   a different code page that doesn't have the same characters.
* - Added Ensure_Printable_Member routine to PDSRCM and PDSRCMM
* - IVCSECTx enhancements:
*   - List Vendor CSECTs
*   - Added option NVENDORL for those who don't want list
*   - Cache BLDL hits for less I/O
*   - Statistics are printed at termination about IVC processing
*
* 26-MAR-1998 - 30-MAR-1998 -- David Alcock -- V2.1:
* - Added IVCSECTx (Ignore Vendor CSECT) options:
*   - IVCSECTS (Stats) - ignore when doing trivia (stats)
*   - IVCSECTF (Full) - ignore when doing translator, zap and user rpt
*   A //IVCSECT DD concatenation can be used to augment the internal
*   vendor table with all known vendor csects.  CEE.SCEELKED has a LOT
*   of squirelly CSECT names of LE/370 vendor CSECTS.
* - Moved Load module (report line)  formating to separate CSECT
*   PDSR$LMF to free room in main CSECT. Freed: 1048 bytes (418 hex)
* - Bruce Leland sent me his latest Translator ID table!!!!
* - Fix S0C4 because CSECT name for $Private was too long when the
*   number > 99 - the $Private CSECTs are now $Priv#1-$Priv#9999. This
*   allows DA$PDR to process EOY.SEOYLOAD at OS/390 v1r2 level now!
*   Highest I've seen so far is $Priv#196;
* - CA-Endevor leaves "footprints" in load modules:
*   - For each CSECT, footprints are kept in a IDRU
*   - For the whole load module, footprints are kept in a IDRZ
*   I now accept RC=4 on the Binder API and proceed when the Binder API
*   complains about the IDRU CA-Endevor errors, for example:
*   "IEW2520W 4706 IDRZ IMAGE FFF1 DOES NOT CONTAIN A VALID ESD ID..."
* - Fix trialing binary zero for ISO date format in heading line
* - Detect $Private CSECTs in PDSRCM$M_TRAN (IDL) routine.
* - Added message CM18 so we know who the Binder is talking about.
* - Fix bug in PDSRCM_DUMPE (Dump entry) routine where the area string
*   wasn't being saved.
*
* 09-MAR-1998 -- David Alcock -- V2.0:
* - Start version numbering at 2.0
* - Dataset summary added to the end of the //REPORT file
* - Added EDITNCF routine for editing reg 1 flush without commas
* - Show Oldest CSECT found in library
* - Show Dataset allocations by track
* - Added DA$PDSR mascot to SYSPRINT: the PDS Eagle (author unknown)
*
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
* Person     Date        Description
* ---------- ----------- --------------------------------------------
* 02-FEB-1998 D Alcock   Insert first 256 bytes of CSECT to FLATOUT;
*                        Moved member DA$PDSRC inline; Removed option
*                        CSDUMP (use AMASPZAP instead); Eyecatcher
*                        report will get ALL CSECTs if using Binder
*                        API (not just main); CSECT name added to
*                        ECRPT output line;
* 19-JAN-1998 D Alcock   Add detection of OS/390 v2.3 and v2.4 mac;
* 10-JAN-1998 D Alcock   Move ISPF stats formating to separate CSECT
*                        PDSR$IS to save room in main CSECT; Started
*                        FLATOUT file code;  Misc code improvements
*                        with USINGS;
* 29-DEC-1997 D Alcock   Fix S0C4 at OS/390 r2 with SWA=ABOVE;
*                        &ASMDATE changed to ISO standard;
* 15-MAY-1997 D Alcock   Fixed Binder info for pre-DFSMS 1.3; Fixed
*                        missing "*Unknown" for first compiler not
*                        known in TranRpt; Added DUMPBLDL option;
*                        Renamed DIRENT option to DUMPDIRE and moved
*                        moved output to SYSPRINT (from REPORT);
* 09-MAY-1997 D Alcock   Added DATE=US/EUR/ISO operand; Removed USDATE
*                        operand; Added ISO date processing;
* 08-MAY-1997 D Alcock   Better handling of CSECT names over the
*                        current report field length of 10; Detect
*                        $Private sections and create a good name
*                        (rather than binary) and append a count; Use
*                        class name format based on SMS level;
* 03-MAY-1997 D Alcock   Parse option from SYSIN;  Added NOSYSIN;
*                        Added date and time to translator and history
*                        report headings; Added CSECT count to load
*                        module report; Call IGWASMS; Added dynamic
*                        APFLST for MVS 4.3 and higher; Always print
*                        DFP level (even if DFSMS/MVS);
* 29-APR-1997 D Alcock   Added TEXT load module processing using the
*                        Binder API - option CSDUMP= added; Added
*                        TSOVIEW option; Restructuring;
* 25-APR-1997 D Alcock   Added a debugging mode to the Binder API
*                        message exit (CSECT PDSRCMM) and added DFSMS
*                        version checking;
* 23-APR-1997 D Alcock   Added OPEN/BLDL/CLOSE for DCB=PO for LOAD and
*                        PDSRCM processing; Added DCB/DirEnt
*                        processing to PDSRCM; Use fancier message
*                        wrapping to PDSRCM/MSGEXIT; Use CSVQUERY when
*                        on MVS 4.3 and higher; Moved Eye- catcher
*                        format and Help routines to separate CSECTS
*                        to save code area in main CSECT;
* 22-APR-1997 D Alcock   Moved STARTD to Init and ENDD to Term to
*                        aid performance; FINDMEM=member added;
*                        Option=ONLYFIND added; Option=NOSMS added;
* 21-APR-1997 D Alcock   Removed CESD and IDR$TRN code; Correct
*                        S0C3 for MEMXREF and CHKDUP;  Added hex
*                        dump of Binder API control blocks;
* 15-APR-1997 D Alcock   Added History report (dd=HISTRPT);
* 14-APR-1997 D Alcock   Added program PDSRCM which uses the IBM
*                        DFSMS/MVS Binder API to process CSECTS; Added
*                        Translator report (dd=TRANRPT);
* 16-MAR-1997 D Alcock   Moved parm parse routine to separate
*                        CSECT; Added time to MSG20;
* 13-MAR-1997 D Alcock   Fix endless loop if invalid parm is given;
*                        Remove PARM=APFLST; Corrected duplicate
*                        ZAPRPT flag; Added CPPL parameter call;
* 24-FEB-1997 D Alcock   Added: COBCRPT - COBOL CICS report;
* 12-DEC-1996 D Alcock   Misc fixes to ZAPRPT; Removed some dead
*                        via AGO/ANOP for CESD and IDR$TRN; Check
*                        for Length of 0 in Eyecatcher; Added
*                        Translator list in PARM=HELP;
* ??-DEC-1996 D Alcock   Added hexstring translate to lower;
* 25-NOV-1996 D Alcock   Renamed to DA$PDSR; Check for dynamic
*                        APFLST (Support will be added later);
*                        Corrected a few bugs;
* 20-FEB-1991 D Alcock   Added: ECRPT - Eye Catcher Report;
* 08-JAN-1991 D Alcock   Added: ZAPRPT - AMASPZAP report;
* 16-MAR-1990 D Alcock   Added: APFLST; CHKDUP; LNKLST; LPALST;
*                        HELP; NODETAIL; MEMXREF; DUMPDSCB
* 15-APR-1985 D Alcock   Original program written;
* =================================================================== *
         SPACE 2
*
** Installation customization
*
#BKUSERS EQU   20000                        Number of BKLIDS records
&ACF2    SETB  0                            1=Use_ACF2_Macro 0=Don't
         EJECT
***********************************************************************
***
**       Set the DFP/DFSMS and O/S maclib levels to variables
***
***********************************************************************
         SPACE 2
         GBLC  &DMACLIB                   DFP/DFSMS maclib version
&DMACLIB SETC  'PRE-DFP'                  Start out at ancient level
         GBLC  &IHADFARELS                IHADFA sets to system level
*-If you aren't at DFP maclib, comment out "IHADFA"
         IHADFA ,                         Data Facilities Area
         AIF   (NOT D'DFA).SMSX           Have IHADFA?
         AIF   (D'DFADFSMS).SMSSTRT       At DFSMS 1.1?
*-DFP maclib checks
&DMACLIB SETC  'DFP'
         AIF   (NOT D'DFASMS).SMSX
&DMACLIB SETC  'DFP 310'
         AIF   (NOT D'DFAPDSE).SMSX
&DMACLIB SETC  'DFP 320'
         AIF   (NOT D'DFAVOLSN).SMSX
&DMACLIB SETC  'DFP 330'
         AIF   (NOT D'DFAVOLSN).SMSX
&DMACLIB SETC  'DFP 331'
         AIF   (NOT D'DFARECAL).SMSX
&DMACLIB SETC  'DFP 332'
         AGO   .SMSX
*-As stated in the "DFSMS/MVS 1.3 DFSMSdfp Advanced Services" manual,
* the IHADFA macro did not always set &IHADFARELS (but they could
* in the future), so attempt to deterimine prior release levels.
.SMSSTRT ANOP  ,
         AIF   ('&IHADFARELS' NE '').SMSSET   Already have SMS level?
&IHADFARELS SETC '01010100'               Start at DFSMS 1.1
         AIF   (NOT D'DFADEEXT).SMSSET    At DFSMS 1.2?
&IHADFARELS SETC '01010200'               Up to DFSMS 1.2
.SMSSET  ANOP  ,                          Set level
&DMACLIB SETC  'DFSMS/MVS &IHADFARELS'    Set DFP/DFSMS maclib level
.SMSX    ANOP  ,
*
         CVT   DSECT=YES,LIST=NO,PREFIX=YES MVS CVT
*-Attempt to identify the MVS maclib level
         GBLC  &MMACLIB                   MVS maclib version
         AIF   (NOT D'CVTJ6604).MMO24X
&MMACLIB SETC  'OS/390 v2.4 or higher'
         AGO   .MMX
.MMO24X  ANOP    ,
         AIF   (NOT D'CVTH6603).MMO23X
&MMACLIB SETC  'OS/390 v2.3'
         AGO   .MMX
.MMO23X  ANOP    ,
         AIF   (NOT D'CVTJ6602).MMO12X
&MMACLIB SETC  'OS/390 v1.2'
         AGO   .MMX
.MMO12X  ANOP    ,
         AIF   (NOT D'CVTH6601).MMO11X
&MMACLIB SETC  'OS/390 v1.1'
         AGO   .MMX
.MMO11X  ANOP    ,
         AIF   (NOT D'CVTJ5522).MM522X
&MMACLIB SETC  'MVS 5.2.2'
         AGO   .MMX
.MM522X  ANOP    ,
         AIF   (NOT D'CVTH5520).MM520X
&MMACLIB SETC  'MVS 5.2.0'
         AGO   .MMX
.MM520X  ANOP  ,
         AIF   (NOT D'CVTH5510).MM510X
&MMACLIB SETC  'MVS 5.1.0'
         AGO   .MMX
.MM510X  ANOP  ,
         AIF   (NOT D'CVTH4430).MM430X
&MMACLIB SETC  'MVS 4.3.0'
         AGO   .MMX
.MM430X  ANOP  ,
         AIF   (NOT D'CVTJ4422).MM422X
&MMACLIB SETC  'MVS 4.2.2'
         AGO   .MMX
.MM422X  ANOP  ,
         AIF   (NOT D'CVTH4420).MM420X
&MMACLIB SETC  'MVS 4.2.0'
         AGO   .MMX
.MM420X  ANOP  ,
         AIF   (NOT D'CVTH4410).MM410X
         AGO   .MMX
&MMACLIB SETC  'MVS 4.1.0'
.MM410X  ANOP  ,
         AIF   (NOT D'CVTJ3313).MM313X
&MMACLIB SETC  'MVS 3.1.3'
         AGO   .MMX
.MM313X  ANOP  ,
         AIF   (NOT D'CVTJ3311).MM311X
&MMACLIB SETC  'MVS 3.1.1'
         AGO   .MMX
.MM311X  ANOP  ,
         AIF   (NOT D'CVTH3310).MM310X
&MMACLIB SETC  'MVS 3.1.0'
         AGO   .MMX
.MM310X  ANOP  ,
&MMACLIB SETC  'PRE-MVS3.1.0'             ..Default to pre-MVS3.1.0
.MMX     ANOP  ,
         EJECT ,
***********************************************************************
***
**       External DSECTs
***
***********************************************************************
         SPACE 2
         IHAPDS PDSBLDL=NO                PDS Directory entry
         PRINT NOGEN
         IHAPSA ,                         Prefixed Save Area
         IEFTIOT1 ,                       Task I/O Table
         IKJTCB DSECT=YES,LIST=NO         Task Control Block
         IEFJFCBN LIST=YES                Job File Control Block
         IEFUCBOB LIST=YES                Unit Control Block
         DCBD   DSORG=PO,DEVD=DA          Data Control Block
         IEZDEB ,                         Data Extent Block
         IECSDSL1 (1)                     DSCB - Format 1
         IHADECB ,                        Data Event Control Block
         IEFZB4D0 ,                       SVC 99 - RB
         IEFZB4D2 ,                       SVC 99 - Text Equates
         IEFZB505 LOCEPAX=YES             EPA mapping for SWAREQ
         IEFQMIDS ,                       Equates for SWA requests
         IEFJESCT ,                       JES Communications Table
         IEESMCA ,                        SMF Control Area
         IKJCPPL ,                        Command Processor parm list
         AIF   (NOT D'CVTH4430).DSM43X    At the right MVS level?
CSVQRY$  DSECT ,
         CSVQUERY PLISTVER=0,MF=(L,CSVQRY) CSVQuery parmlist
         CSVAPFAA ,                       Dynamic APF
.DSM43X ANOP ,
*
** Non-IBM macros
*
         DA#DATE ,                        Date Routine
         DA#MXD ,                         Hex Dump routine
         DA#COBOL ,                       Map COBOL eyecatchers
*
** Copied from debugging handbook - IBM in their wisdom does not give
** us the mapping DSECT
*
LLTCOUNT EQU   X'04'                      Number of Datasets in LNKLST
LLTENTRY EQU   X'08'                      Offset to first entry
*
LPATCNT  EQU   X'04'                      Number of Datasets in LPALST
LPATNTRY EQU   X'08'                      Offset to first entry
*
** If we have the ACF2 macro library use it, otherwise create our own
*
         AIF   (&ACF2).DSACF2             Do we have the ACF2 mac lib?
LIDREC   DSECT ,                          Our own simulated layout:
LIDLID   DS    CL8                        ..Userid
         DS    XL4                        ..Unused by us
LIDNAME  DS    CL20                       ..Programmer name
         AGO   .DSACF2X
.DSACF2  ANOP  ,
         LIDREC ,
.DSACF2X ANOP  ,
*
** BKLIDS Table
*
BKL        DSECT ,
BKLH       EQU   *
BKLH_ID    DS    CL8'BKLIDST'           ID for dumps
BKLH_LEN   DS    XL4                    Length of area obtained
BKLH_USERC DS    XL4                    Number of users we have
BKLH_DCB   DS    XL(C_DCBVIL)           DCB for BKLIDS
BKLHL      EQU   *-BKLH
*
BKLE       EQU   *
BKLE_USER  DS    XL(L'LIDLID)
BKLE_NAME  DS    XL(L'LIDNAME)
BKLEL      EQU   *-BKLE
         EJECT
***********************************************************************
***
**       Set misc internal assembly variables
***
***********************************************************************
         SPACE 2
*
** Using the official ASMH/HLASM distinction trick, simulate the
** SYSVER and SYSDATEC variables of HLASM when assembled under
** ASMH...Taken from Gilbert Saint-flour's SHOWMVS.
*
         LCLA  &ASMH_HLASM
         AIF   (T'&ASMH_HLASM EQ 'N').ASMH1X
&SYSVER  SETC  'ASMH'
&SYSDATC SETC  '20'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)
         AIF   ('&SYSDATC' LT '20500000').ASMH1X
&SYSDATC SETC  '19'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)
.ASMH1X  ANOP
*-Convert assembly date from SYSDATC format "YYYYMMDD" to "YYYY-MM-DD"
         LCLC  &ASMDATE
&ASMDATE SETC  '&SYSDATC'(1,4).'-'.'&SYSDATC'(5,2).'-'.'&SYSDATC'(7,2)
         PRINT GEN
*
** Global Program equates
*
#G_MAXFILE  EQU   999                     Maximum number of files
*Fix label: FOR_LIBN when 999 (#MAXFILE) is more than 3 digits
            SPACE 2
#G_ORPHANS  EQU   1000                    Number of orphans per PDS
         EJECT
***********************************************************************
***
**       Entry Housekeeping and misc initializations
***
***********************************************************************
         SPACE 2
         EJECT ,
DA$PDSR  DA#ENTER 'V&DAVER Utility: PDS reporting',                    @
               RENT=YES,                  Indicate we need GETMAIN     @
               LV=WORKDSL,                Length of GETMAIN            @
               BASE=(12,11,10)            Base Registers
         USING WORKDS,R13                 Addressibility to work area
         ST    R1,PPC_R1ENTRY             Save parameter address
         MVC   SUBRSA+4(4),=C'F1SA'       Fix up RSA
*
** Load/locate external programs
*
         ICM   R0,B'1111',=V(DA$DATE)     Have DA$DATE linked in?
         BNZ   I$DATES                    Yes, save address
         LA    R8,=CL8'DA$DATE'           Locate module name
         LOAD  EPLOC=(8),ERRET=E$LOAD     Load it
         OI    W_FLAG1,$W_F1LRDATE        We loaded it, alright!
I$DATES  DS    0H
         ST    R0,EP_DA$DATE              Save entry point address
*
#MXDWIDE EQU   132-(MSGPREL+8)            Length of output area
         ICM   R0,B'1111',=V(DA$MXD)      Have DA$MXD linked in?
         BNZ   I$MXDS                     Yes, save address
         LA    R8,=CL8'DA$MXD'            Locate module name
         LOAD  EPLOC=(8),ERRET=E$LOAD     Load it
         OI    W_FLAG1,$W_F1LRMXD         We loaded it, alright!
I$MXDS   DS    0H
         ST    R0,EP_DA$MXD               Save entry point address
*
** Invoke the parse routine for the parm='options' field
*
         LA    R0,#PPC_OPTION_PARM        Option = Parse PARM='option'
         LA    R1,SUBRSA                  Locate subroutine RSA
         L     R15,=V(PDSR$PPC)           Locate CSECT
         BASR  R14,R15                    Invoke the parse routine
*
** Get the current date and time for report headings
*
         L     R1,=V(PDSR$C1)             -> Constants CSECT
         MVC   W_ODGEUR11(C_ODGEUR11L),C_ODGEUR11-PDSR$C1(R1)
         TM    PPC_IFLAG1,$PPC_IF1DATEISO ISO format?
         BO    I$CDISO
         TM    PPC_IFLAG1,$PPC_IF1DATEUS  United States format?
         BNO   I$CDISOX                   Use default of "European"
         MVI   W_ODGEUR11_TYPE+1,$DA#DATE_ODGUS Make Gregorian US
         MVI   W_ODGEUR11_STRL,$DA#DATE_ODGUS10 Set length
         B     I$CDISOX
I$CDISO  DS    0H
         MVI   W_ODGEUR11_TYPE+1,$DA#DATE_ODISO Make ISO
         MVI   W_ODGEUR11_STRL,$DA#DATE_ODISO10 Set length
         MVI   W_ODGEUR11_STR+10,C' '     Fix trailing zero to blank
I$CDISOX DS    0H
         MVC   W_OTIMES8(C_OTIMES8L),C_OTIMES8-PDSR$C1(R1)
         DA#SMODE 31                      Must be in 31 bit mode
         L     R15,EP_DA$DATE             Locate EPA of DA$DATE routine
         CALL  (15),(W_ODGEUR11,W_OTIMES8),VL,MF=(E,PARMLIST)
         DA#SMODE 24                      Back to 24 bit mode
*
** Open the messages file
*
         LA    R3,SYSPRINT                Locate DCB work area
         L     R1,=V(PDSR$C1)             -> Constants
         MVC   0(C_DCBOL,R3),C_DCBO-PDSR$C1(R1)
         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'SYSPRINT'
         MVC   PARMLIST(C_LSTOL),C_LSTO-PDSR$C1(R1)
         BAS   R14,SET_ABEND_EXIT         Set up ABEND exit
         OPEN  ((3),(OUTPUT)),MF=(E,PARMLIST)
         LA    R8,=CL8'SYSPRINT'          Locate file
         BAS   R14,CHECK_OPEN_ABEND       Check for Abend
         LA    R1,255                     Get excessive count
         STC   R1,PSR_LC                  ..Force heading
         MVC   PSRAREA+4(4),=C'F1SA'      Fix up RSA
*
         TIME  BIN                        Get the time
         ST    R0,DOUBLE                  Save for later
         BAS   R14,FORMAT_MESSAGE         Initialize message area
         MVC   0(MSG1L,R15),MSG1-PDSR$MSG(R1) Move in message
         LA    R15,MSG1L(R15)             Bump past the message
         L     R1,DOUBLE                  Get the time
         BAS   R14,CONVERT_BINARY_TIME    " hh:mm:ss"
         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record
*
         BAS   R14,CLEAR_RECOUT           Clear record to blanks
         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record
*
         L     R7,=V(PDSR$C2)             Locate constants CSECT
         TM    PPC_FLAG5,$PPC_F5NOEAGLE
         BNO   I$EAGLES
         LA    R7,NO_PICTURE-PDSR$C2(R7)  Locate text strings
         B     I$EAGLEL
I$EAGLES DS    0H
         LA    R7,EAGLE_PICTURE-PDSR$C2(R7) Locate eagle picture
I$EAGLEL DS    0H
         LA    R15,RECOUT+14              Locate output area
         SLR   R14,R14                    Clear register for IC
         IC    R14,0(R7)                  Obtain length of messsage - 1
         EX    R14,I$EAGLEM               Move string to message area
         LA    R7,2(R14,R7)               Bump past this string
         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record
         BAS   R14,CLEAR_RECOUT           Clear record to blanks
         CLC   0(2,R7),=X'FFFFFFFF'       At end of strings?
         BNE   I$EAGLEL                   No, continue
         B     I$EAGLEX
I$EAGLEM MVC   0(0,R15),1(R7)
I$EAGLEX DS    0H
         BAS   R14,PRINT_SYSPRINT_RECORD  Print another blank line
*
** Obtain dataset summary table
*
#IDSUM   EQU   DSUMHL+(#G_MAXFILE*DSUMEL) Calc length of area
         L     R0,=AL4(#IDSUM)            Get length of area
         GETMAIN RU,LV=(0)                Obtain storage
         ST    R1,PP_DSUMA                Save address
         MVC   DSUMH_NAME-DSUMH(4,R1),=C'DSUM'     Set eyecatcher
         ST    R0,DSUMH_LEN-DSUMH(R1)     Save length of area
         XC    DSUMH_I-DSUMH(DSUMH_IL,R1),DSUMH_I-DSUMH(R1)
         LA    R14,DSUMHL(R1)             Locate to first entry
         ST    R14,DSUMH_CURR-DSUMH(R1)   Set current entry
*
** Obtain orphan table
**
** Note: Have not added ORPHANS=xxxx as parameter yet...
*
         L     R0,=AL4(#G_ORPHANS*ORPTL)  Get length of area
         GETMAIN RU,LV=(0),LOC=(ANY,ANY)  Obtain storage
         STM   R0,R1,PP_OT                Save length and address
         A     R1,=AL4(1000*ORPTL)        Locate past it
         SH    R1,=AL2(ORPTL-1)           Backup to last entry
         ST    R1,PP_OTLE                 save it
*
** Print Parm card information
*
         L     R7,PPC_R1ENTRY             -> Parameter pointer
         L     R7,0(R7)                   Get parameter
         SLR   R8,R8                      Clear register
         ICM   R8,B'0011',0(R7)           Get length of passed parm
         BZ    I$PEX                      None, leave
*
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG2L,R15),MSG2-PDSR$MSG(R1) Move in message
         LA    R15,MSG2L(R15)             Bump past it
         BCTR  R8,0                       Decrement for EX
         EX    R8,I$MPRM                  Move parameter to message
         LA    R15,1(R8,R15)              Bump past it
         MVI   0(R15),X'7D'               Insert ending tick
         BAS   R14,PRINT_SYSPRINT_RECORD
*
         SLR   R1,R1                      Zero out register
         ICM   R1,B'0011',PPC_NUM         Get number of parms errors
         BZ    I$PESI                     None, leave
*
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(4,R15),MSG3-PDSR$MSG(R1) Move in message ID
         LA    R15,MSG2L(R15)
         L     R1,=V(PDSR$C1)
         MVC   0(90,R15),C_COLS-PDSR$C1(R1)
         BAS   R14,PRINT_SYSPRINT_RECORD
*
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG3L,R15),MSG3-PDSR$MSG(R1) Move in message
         LA    R15,MSG3L+1(R15)           Bump past it
         LH    R1,PPC_COL                 Get parameter column
         LA    R1,1(R1)                   Start from 1 not zero
         BAS   R9,EDITFWF                 Print column number
         BAS   R14,PRINT_SYSPRINT_RECORD  Print message
I$PESI   DS    0H
         TM    PPC_FLAG4,$PPC_F4NOSYSIN   User doesn't want SYSIN?
         BO    I$PESIX                    Yes, leave
I$PESIL  DS    0H
         LA    R0,#PPC_OPTION_SYSIN       Option = Parse SYSIN
         LA    R1,SUBRSA                  Locate subroutine RSA
         L     R15,=V(PDSR$PPC)           Locate CSECT
         BASR  R14,R15                    Invoke the parse routine
         CH    R15,=AL2(#PPC_RC_EOF)      End of SYSIN
         BNE   I$PESIL                    No, try another
*
I$PESIX  DS    0H
         ICM   R1,B'0011',PPC_NUM         Get number of parms errors
         BZ    I$PEX                      None, leave
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG4L,R15),MSG4-PDSR$MSG(R1) Move in message
         LA    R15,MSG4L+1(R15)           Bump past it
         LH    R1,PPC_NUM                 Get number of parm errors
         BAS   R9,EDITFWF                 Print it
         TM    PPC_IFLAG1,$PPC_IF1DATEERR
         BNO   I$MPRMDX
         L     R1,=V(PDSR$MSG)
         MVC   1(MSG4AL,R15),MSG4A-PDSR$MSG(R1) Move in message
I$MPRMDX DS    0H
         BAS   R14,PRINT_SYSPRINT_RECORD  Print message
         MVI   MAXCC,$SEVERE              Set maximum condition code
         B     EXIT
I$MPRM   MVC   0(0,R15),2(R7)
I$MDDP   MVC   0(0,R15),PPC_DDP
I$PEX    DS    0H
         BAS   R14,CLEAR_RECOUT           Clear record to blanks
         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**       Print the DFSMS (if under DFSMS), DFP and MVS BCP levels
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG48L,R15),MSG48-PDSR$MSG(R1) Move in message
         LA    R15,MSG48L+1(R15)          Bump past it
*
** Insert "DF/SMS level" (if we are executing on a system with DFSMS)
** into message
*
         L     R2,CVTPTR                  -> CVT
         L     R2,CVTDFA-CVTMAP(R2)       -> Data Facilities Area
         AIF   ('&IHADFARELS' LT '01010100').RELSX .at DFSMS/MVS 1.1?
         CLC   DFARELS-DFA(4,R2),ZEROS    Pre-DFSMS/MVS?
         BE    I$SMSLX                    Yes, skip
         MVC   W_DFARELS(4),DFARELS-DFA(R2) Save DFSMS/MVS level info
         OI    W_FLAG1,$W_F1DFSMS         We are DFSMS/MVS!
         ST    R15,DOUBLE2                Save current location
         BAS   R14,OBTAIN_PDSRCMD         Obtain work area
         L     R15,DOUBLE2                Restore current location
         L     R1,=V(PDSR$MSG)            Locate constants CSECT
         MVC   0(L'MSG48B,R15),MSG48B-PDSR$MSG(R1)
         LA    R15,L'MSG48B+1(R15)
         LA    R4,DFAVER-DFA(R2)          Locate to version
         LA    R5,L'DFAVER+L'DFARLSE+L'DFAMOD Length to consider
I$SMSLL  DS    0H
         SLR   R1,R1                      Get ready for Insert
         IC    R1,0(R4)                   Get value
         BAS   R9,EDITFWF                 Edit it flush
         MVI   0(R15),C'.'                Insert delimiter
         LA    R15,1(R15)                 Bump past delimiter
         LA    R4,1(R4)                   Bump to next value
         BCT   R5,I$SMSLL                 ..Try it out
         BCTR  R15,0
         MVI   0(R15),C' '
         LA    R15,1(R15)
*
         L     R1,=V(PDSR$MSG)            Locate constants CSECT
         TM    PPC_FLAG4,$PPC_F4NOSMS     No SMS processing?
         BNO   I$SMSLYX                   No, continue
         NI    W_FLAG1,255-$W_F1DFSMS     Don't use DFSMS services
         OI    W_FLAG1,$W_F1NOSMS         Might be useful to know later
         MVC   0(L'MSG48C,R15),MSG48C-PDSR$MSG(R1) Move in message
         LA    R15,L'MSG48C+1(R15)        Locate past it
I$SMSLYX DS    0H
         MVI   0(R15),C'-'
         LA    R15,2(R15)                 Locate past it
I$SMSLX  DS    0H
.RELSX ANOP ,
*
** Insert "DFP level" into message
*
         MVC   0(L'MSG48D,R15),MSG48D-PDSR$MSG(R1)
         LA    R15,L'MSG48D+1(R15)
         UNPK  DOUBLE2(5),DFAREL-DFA(3,R2)
         MVZ   DOUBLE2(4),ZEROS
         TR    DOUBLE2(4),HEXTABLE
         MVC   0(1,R15),DOUBLE2
         MVI   1(R15),C'.'
         MVC   2(1,R15),DOUBLE2+1
         MVI   3(R15),C'.'
         MVC   4(1,R15),DOUBLE2+2
         LA    R15,6(R15)
I$DFPLX  DS    0H
*
** Insert "MVS BCP level" into message
*
         L     R1,=V(PDSR$MSG)            Locate constants CSECT
         MVC   0(L'MSG48E,R15),MSG48E-PDSR$MSG(R1)
         LA    R15,L'MSG48E+1(R15)
         L     R1,CVTPTR                  -> CVT
         LA    R0,CVTLEVL+L'CVTLEVL-CVTFIX Length of CVT prefix
         SR    R1,R0                      -> Backup to start of Prefix
         MVC   0(L'CVTPRODN,R15),CVTPRODN-CVTFIX(R1)
         MVC   W_BCPLEVEL(L'CVTPRODN),CVTPRODN-CVTFIX(R1)
*
         BAS   R14,PRINT_SYSPRINT_RECORD  Print message
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**       Initialization for Ignore_Vendor_CSECT
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
         TM    PPC_FLAG5,$PPC_F5IVCSECTS
         BNO   I$IVCX
         LA    R0,#IVC_INIT
         LA    R1,SUBRSA
         L     R15,=V(PDSR$IVC)
         BASR  R14,R15
I$IVCX   DS    0H
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**       If PARM=CALLRACF, we better be authorized
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
         TM    PPC_FLAG5,$PPC_F5CALLRACF  Call RACF?
         BNO   I$CRX                      Nope, Continue
         TESTAUTH FCTN=1                  Test APF authorization
         LTR   R15,R15                    Are we authorized?
         BZ    I$CRX                      Yes, continue
         NI    PPC_FLAG5,255-$PPC_F5CALLRACF Turn off option
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG8L,R15),MSG8-PDSR$MSG(R1) Move in message
         BAS   R14,PRINT_SYSPRINT_RECORD  Print message
I$CRX    EQU   *
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**       Print help information if requested
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
         TM    PPC_FLAG2,$PPC_F2HELP
         BNO   I$HELPX
         LA    R1,SUBRSA
         L     R15,=V(PDSR$HLP)
         BASR  R14,R15
I$HELPX  DS    0H
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**       Check for mutually exclusive options
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
*
** CHKDUP and MEMXREF
*
         TM    PPC_FLAG1,$PPC_F1CHKDUP    Check for Duplicates?
         BNO   I$CDX                      No, continue
         TM    PPC_FLAG1,$PPC_F1MEMXREF   Member XREF?
         BNO   I$CDX                      No, continue
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG7L,R15),MSG7-PDSR$MSG(R1) Move in message
         LA    R15,MSG7L+1(R15)           Bump past message
         L     R14,=V(PDSR$PPC)
         MVC   0(6,R15),TPF_CHKDUP+1-PDSR$PPC(R14)
         MVC   8(7,R15),TPF_MEMXREF+1-PDSR$PPC(R14)
         BAS   R14,PRINT_SYSPRINT_RECORD  Print message
         MVI   MAXCC,$SEVERE              Set maximum condition code
         TM    PPC_FLAG1,$PPC_F1SIMULATE  Simulate mode?
         BNO   EXIT                       No, leave right now
I$CDX    DS    0H
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**       Print criteria
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG5L,R15),MSG5-PDSR$MSG(R1) Move in message
         LA    R15,MSG5L(R15)             Bump past message
         SLR   R14,R14                    Clear register
         IC    R14,PPC_DDPL               Get length of DD prefix
         EX    R14,I$MDDP                 Move DD prefix out
         LA    R15,1(R14,R15)             Bump past it
         MVI   0(R15),C'"'                Insert delimiter
         BAS   R14,PRINT_SYSPRINT_RECORD  Print record
         EJECT ,
***********************************************************************
***
**  Misc report file opens
**
**  NOTE: This code needs to be reworked and standardized.
**        Dave_Alcock@31Jan1998
***
***********************************************************************
         SPACE 2
*
** Open the ECRPT file if option is set
*
         TM    PPC_FLAG3,$PPC_F3ECRPT     Need report?
         BNO   I$ECRX                     No, continue
         LA    R3,ECRPT                   Locate DCB work area
         L     R1,=V(PDSR$C1)             -> Constants
         MVC   0(C_DCBOL,R3),C_DCBO-PDSR$C1(R1)
         MVC   DCBDDNAM-IHADCB(8,R3),C_DD_ECRPT-PDSR$C1(R1)
         MVC   PARMLIST(C_LSTOL),C_LSTO-PDSR$C1(R1)
         BAS   R14,SET_ABEND_EXIT         Set up ABEND exit
         OPEN  ((3),(OUTPUT)),MF=(E,PARMLIST)
         L     R8,=V(PDSR$C1)             -> Constants
         LA    R8,C_DD_ECRPT-PDSR$C1(R8)  Locate DDNAME=ZAPRPT
         BAS   R14,CHECK_OPEN_ABEND       Check for Abend
         AIF   ('&IHADFARELS' LT '01010100').IECX
         TM    W_FLAG1,$W_F1DFSMS         DFSMS/MVS?
         BNO   I$ECRX                     No, continue
         BAS   R14,OBTAIN_PDSRCMD         Obtain work area
.IECX    ANOP  ,
I$ECRX   EQU   *
*
** Open the ZAPRPT file if option is set
*
         TM    PPC_FLAG3,$PPC_F3ZAPRPT   Need Zap report
         BNO   I$ZRX
         TM    W_FLAG1,$W_F1DFSMS         DFSMS/MVS?
         BO    I$ZRSMS                    Yes, continue
         LA    R3,ZAPRPT                  Locate DCB work area
         L     R1,=V(PDSR$C1)             -> Constants
         MVC   0(C_DCBOL,R3),C_DCBO-PDSR$C1(R1)
         MVC   DCBDDNAM-IHADCB(8,R3),C_DD_ZAPRPT-PDSR$C1(R1)
         MVC   PARMLIST(C_LSTOL),C_LSTO-PDSR$C1(R1)
         BAS   R14,SET_ABEND_EXIT         Set up ABEND exit
         OPEN  ((3),(OUTPUT)),MF=(E,PARMLIST)
         L     R8,=V(PDSR$C1)             -> Constants
         LA    R8,C_DD_ZAPRPT-PDSR$C1(R8) Locate DDNAME=ZAPRPT
         BAS   R14,CHECK_OPEN_ABEND       Check for Abend
         B     I$ZRX
I$ZRSMS  DS    0H
         BAS   R14,FORMAT_MESSAGE         Initialize message area
         MVC   0(MSG51L,R15),MSG51-PDSR$MSG(R1) Move in message
         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record
         OI    PPC_FLAG4,$PPC_F4HISTR
         NI    PPC_FLAG3,255-$PPC_F3ZAPRPT  Turn off Zap report
I$ZRX    DS    0H
*
** Initialization if Translator report is needed
*
         TM    PPC_FLAG4,$PPC_F4TRANR     Need report?
         BNO   I$TRANRRX                  No, continue
         TM    W_FLAG1,$W_F1NOSMS         Using DFSMS services?
         BO    I$TRANRNS                  No, skip
         L     R8,=V(PDSR$C1)             -> Constants
         LA    R8,C_DD_TRANRPT-PDSR$C1(R8) Locate =CL8'TRANRPT'
         DEVTYPE (R8),DOUBLE              Get file information
         LTR   R15,R15
         BNZ   I$TRANRE
*
         AIF   ('&IHADFARELS' LT '01010100').TRANRN
         BAS   R14,OBTAIN_PDSRCMD          Obtain work area
         OI    PDSRCMD_FLAG1-PDSRCMD(R1),$PDSRCMD_F1TRAN
         B     I$TRANRRX
         AGO   .TRANRX
.TRANRN ANOP   ,
         BAS   R14,FORMAT_MESSAGE         Initialize message area
         MVC   0(MSG50L,R15),MSG50-PDSR$MSG(R1) Move in message
         L     R1,=V(PDSR$C1)
         MVC   MSG50T-MSG50(4,R15),C_DD_TRANRPT-PDSR$C1(R1)
         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record
         MVI   MAXCC,8
         B     EXIT
.TRANRX ANOP   ,
*
I$TRANRNS DS 0H
         BAS   R14,FORMAT_MESSAGE         Initialize message area
         MVC   0(MSG52L,R15),MSG52-PDSR$MSG(R1) Move in message
         L     R1,=V(PDSR$C1)
         MVC   MSG52T-MSG52(7,R15),C_DD_TRANRPT-PDSR$C1(R1)
         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record
         B     I$TRANRRX
*
I$TRANRE DS 0H
         BAS   R14,FORMAT_MESSAGE         Initialize message area
         MVC   0(MSG49L,R15),MSG49-PDSR$MSG(R1) Move in message
         LA    R15,MSG49L(R15)
         L     R1,=V(PDSR$C1)
         MVC   0(8,R15),C_DD_TRANRPT-PDSR$C1(R1)
         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record
         MVI   MAXCC,8
         B     EXIT
I$TRANRRX DS 0H
*
** Initialization if History report is needed
*
         TM    PPC_FLAG4,$PPC_F4HISTR     Need report?
         BNO   I$HISTRRX                  No, continue
         TM    W_FLAG1,$W_F1NOSMS         Using DFSMS services?
         BO    I$HISTRNS                  No, skip
         L     R8,=V(PDSR$C1)             -> Constants
         LA    R8,C_DD_HISTRPT-PDSR$C1(R8) Locate =CL8'TRANRPT'
         DEVTYPE (R8),DOUBLE              Get file information
         LTR   R15,R15
         BNZ   I$HISTRE
*
         AIF   ('&IHADFARELS' LT '01010100').HISTRN
         BAS   R14,OBTAIN_PDSRCMD          Obtain work area
         OI    PDSRCMD_FLAG1-PDSRCMD(R1),$PDSRCMD_F1HIST
         B     I$HISTRRX
         AGO   .HISTRX
.HISTRN ANOP   ,
         BAS   R14,FORMAT_MESSAGE         Initialize message area
         MVC   0(MSG50L,R15),MSG50-PDSR$MSG(R1) Move in message
         L     R1,=V(PDSR$C1)
         MVC   MSG50T-MSG50(4,R15),C_DD_HISTRPT-PDSR$C1(R1)
         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record
         MVI   MAXCC,8
         B     EXIT
.HISTRX ANOP   ,
*
I$HISTRNS DS 0H
         BAS   R14,FORMAT_MESSAGE         Initialize message area
         MVC   0(MSG52L,R15),MSG52-PDSR$MSG(R1) Move in message
         L     R1,=V(PDSR$C1)
         MVC   MSG52T-MSG52(7,R15),C_DD_HISTRPT-PDSR$C1(R1)
         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record
         B     I$HISTRRX
*
I$HISTRE DS 0H
         BAS   R14,FORMAT_MESSAGE         Initialize message area
         MVC   0(MSG49L,R15),MSG49-PDSR$MSG(R1) Move in message
         LA    R15,MSG49L(R15)
         L     R1,=V(PDSR$C1)
         MVC   0(8,R15),C_DD_HISTRPT-PDSR$C1(R1)
         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record
         MVI   MAXCC,8
         B     EXIT
I$HISTRRX DS 0H
*
** After all PDSRCM functions have been found, initialize PDSRCM
*
         AIF   ('&IHADFARELS' LT '01010100').RCMIX
*
         ICM   R1,B'1111',A_PDSRCMD+4     Locate area
         BZ    I$PDSRCM$X                 None, PDSRCM not needed
         LA    R15,W_ODGEUR11
         ST    R15,PDSRCMD_DATE-PDSRCMD(R1)
         LA    R15,W_OTIMES8
         ST    R15,PDSRCMD_TIME-PDSRCMD(R1)
         MVI   PDSRCMD_CALLT-PDSRCMD(R1),$PDSRCMD_CT_INIT
         MVC   PDSRCMD_DFARELS-PDSRCMD(L'W_DFARELS,R1),W_DFARELS
*
         LA    R14,SUBRSA
         ST    R14,PDSRCMD_SUBRSAP-PDSRCMD(R1)
*
         L     R15,=V(PDSRCM)             Locate routine
         BASR  R14,R15                    Initialize
         LTR   R15,R15
         BZ    I$PDSRCM$X
         MVI   MAXCC,8
         B     EXIT
I$PDSRCM$X DS  0H
.RCMIX   ANOP  ,
*
** Open the COBCRPT file if option is set
*
         TM    PPC_FLAG3,$PPC_F3COBCRPT   Need report?
         BNO   I$CCRX                     No, continue
         LA    R3,COBCRPT                 Locate DCB work area
         L     R1,=V(PDSR$C1)             -> Constants
         MVC   0(C_DCBOL,R3),C_DCBO-PDSR$C1(R1)
         MVC   DCBDDNAM-IHADCB(8,R3),C_DD_COBCRPT-PDSR$C1(R1)
         MVC   PARMLIST(C_LSTOL),C_LSTO-PDSR$C1(R1)
         BAS   R14,SET_ABEND_EXIT         Set up ABEND exit
         OPEN  ((3),(OUTPUT)),MF=(E,PARMLIST)
         L     R8,=V(PDSR$C1)             -> Constants
         LA    R8,C_DD_COBCRPT-PDSR$C1(R8) Locate DDNAME=COBCRPT
         BAS   R14,CHECK_OPEN_ABEND       Check for Abend
I$CCRX   EQU   *
         EJECT ,
***********************************************************************
***
**       Check for Duplicates / Member XREF --- Initialization
***
***********************************************************************
         SPACE 2
CHECK_FOR_DUPLICATES_INITIALIZATION EQU *
         TM    PPC_FLAG1,$PPC_F1MEMXREF   Member Cross reference?
         BO    CFDI$S                     Yes, do it
         TM    PPC_FLAG1,$PPC_F1CHKDUP    Check for duplicates?
         BNO   CFDI$X                     No, continue
CFDI$S   EQU   *
*
** Ensure that needed files are allocated
*
         LA    R8,=CL8'WRKFILE1'
         BAS   R7,CFDI$FA
         LA    R8,=CL8'WRKFILE2'
         BAS   R7,CFDI$FA
         LA    R8,=CL8'WRKFILE3'
         BAS   R7,CFDI$FA
         CLI   MAXCC,$SEVERE              All files there?
         BE    EXIT                       No, we can't take a joke
*
** Open sort input file
*
         LA    R3,WRKFILE1                Locate DCB work area
         L     R1,=V(PDSR$C1)             -> Constants
         MVC   0(C_DCBOL,R3),C_DCBO-PDSR$C1(R1)
         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'WRKFILE1'
         LA    R1,SORTRECL
         STH   R1,DCBLRECL-IHADCB(R3)
         MH    R1,=H'100'
         STH   R1,DCBBLKSI-IHADCB(R3)
         MVC   PARMLIST(C_LSTOL),C_LSTO-PDSR$C1(R1)
         OPEN  ((3),(OUTPUT)),MF=(E,PARMLIST)
         B     CFDI$X
*
** Subroutine: Ensure that file in R8 is allocated
*
CFDI$FA  EQU   *
         DEVTYPE (R8),DOUBLE              Get file information
         LTR   R15,R15                    File allocated?
         BZ    CFDI$FAX                   Yes, continue
*
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG82L,R15),MSG82-PDSR$MSG(R1) Move in message
         MVC   MSG82L+1(8,R15),0(R8)      Get DDNAME
         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record
         MVI   MAXCC,$SEVERE
CFDI$FAX EQU   *
         BSM   0,R7
*
** Common exit from Check_For_Duplicate_Initialization
*
CFDI$X   EQU   *
         EJECT
***********************************************************************
***
**       Process all DDNAMES which match the prefix
***
***********************************************************************
         SPACE 2
PROCESS_PDS EQU *
*
** Locate TIOT
*
         L     R9,PSATOLD-PSA             -> TCB
         L     R9,TCBTIO-TCB(,R9)         -> TIOT
         LA    R9,TIOENTRY-TIOT1(R9)      Locate first DD entry
         OI    PP_FLAG1,$PP_F1TIOT        In TIOT processing mode
         B     PP$TIOTS                   Start right
*
** Process TIOT entry
*
PP$TIOT  EQU   *
         AR    R9,R8                      Bump to next DD entry
PP$TIOTS EQU   *
         SLR   R8,R8                      Set register to zero
         ICM   R8,B'0001',TIOELNGH-TIOENTRY(R9) Get length of entry
         BZ    PP$TIOTX                   None, end of the TIOT
         LA    R15,PP_PDDN                Locate previous DDNAME
         CLI   TIOEDDNM-TIOENTRY(R9),C' ' Blank DDNAME
         BE    PP$TIOTC                   Yes, use previous
         MVC   PP_PDDN(8),TIOEDDNM-TIOENTRY(R9) Save DDNAME
         MVC   PP_PDDN+8(8),=CL8' '       Blank out concaten stuff
         XC    PP_CCCNT(4),PP_CCCNT       Clear concatenation count
         LA    R15,TIOEDDNM-TIOENTRY(R9)  Locate DDNAME to check
PP$TIOTC EQU   *
         SLR   R14,R14                    Clear register
         IC    R14,PPC_DDPL               Get length of DD prefix
         EX    R14,PP$TIOTZ               DDNAME Match?
         BNE   PP$TIOT                    No, bump to next DD
         MVC   PP_ADDN(8),TIOEDDNM-TIOENTRY(R9) Save DDNAME
         B     PP$INIT
PP$TIOTZ CLC   PPC_DDP(0),0(R15)
PP$TIOTX DS    0H
         NI    PP_FLAG1,255-$PP_F1TIOT    Turn off flag
         ICM   R1,B'1111',PP_NLIBS        Any files meet prefix req?
         BNZ   PP$TIOTXX                  Yes, continue
         BAS   R14,FORMAT_MESSAGE         Initialize message area
         MVC   0(MSG18L,R15),MSG18-PDSR$MSG(R1) Move in message
         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record
PP$TIOTXX EQU  *
*
** LNKLST processing
*
PP$LNKLST EQU *
         TM    PPC_FLAG2,$PPC_F2LNKLST    Need to do this one?
         BNO   PP$LNKLSTX                 No, continue
         OI    PP_FLAG1,$PP_F1LNKLST      Turn on flag
         L     R1,=V(PDSR$PPC)            -> Constants CSECT
         LA    R7,TPF_LNKLST+1-PDSR$PPC(R1)
         L     R8,CVTPTR                  -> CVT
         L     R8,CVTLLTA-CVTMAP(R8)      -> LNKLST datasets
         L     R9,LLTCOUNT(R8)            Obtain number of entries
         LA    R8,LLTENTRY(R8)            Locate first entry in list
         BAS   R14,PP$LST_INIT
PP$LNKLST_L EQU *
         LA    R1,AREAJFCB
         MVC   JFCBDSNM-INFMJFCB(44,R1),1(R8)
         XC    JFCBVOLS-INFMJFCB(6,R1),JFCBVOLS-INFMJFCB(R1)
         B     PP$INIT                    Continue
PP$LNKLST_LB EQU *
         LA    R8,45(R8)                  Locate next name in list
         BCT   R9,PP$LNKLST_L             Process it
         NI    PP_FLAG1,255-$PP_F1LNKLST  Turn off flag
PP$LNKLSTX EQU *
*
** LPALST processing
*
PP$LPALST EQU *
         TM    PPC_FLAG2,$PPC_F2LPALST    Need to do this one?
         BNO   PP$LPALSTX                 No, continue
         OI    PP_FLAG1,$PP_F1LPALST      Turn on flag
         DA#SMODE 31                      Get into 31 bit mode
         L     R1,=V(PDSR$PPC)            -> Constants CSECT
         LA    R7,TPF_LPALST+1-PDSR$PPC(R1)
         L     R8,CVTPTR                  -> CVT
         L     R8,CVTSMEXT-CVTMAP(R8)     -> CVT storage extension
         L     R8,CVTEPLPS-CVTVSTGX(R8)   -> E-PLPA start
         L     R9,LPATCNT(R8)             Number of entries
         LA    R8,LPATNTRY(R8)            Locate first entry
         DA#SMODE 24                      Get into 24 bit mode
         BAS   R14,PP$LST_INIT            Initialize for list
         DA#SMODE 31                      Get into 31 bit mode
PP$LPALST_L EQU *
         LA    R1,AREAJFCB
         MVC   JFCBDSNM-INFMJFCB(44,R1),1(R8)
         XC    JFCBVOLS-INFMJFCB(6,R1),JFCBVOLS-INFMJFCB(R1)
         DA#SMODE 24                      Get into 24 bit mode
         B     PP$INIT                    Continue
PP$LPALST_LB EQU *
         DA#SMODE 31                      Get into 31 bit mode
         LA    R8,45(R8)                  Locate next name in list
         BCT   R9,PP$LPALST_L             Process it
         DA#SMODE 24                      Get into 24 bit mode
         NI    PP_FLAG1,255-$PP_F1LPALST  Turn off flag
PP$LPALSTX EQU *
         B     PP$X                       End of the line
*
** Intialize fields for access
*
PP$INIT  EQU   *
         XC    PPD_CLR(PPD_CLRL),PPD_CLR  Clear fields
         XC    SR_INIT(SR_INITL),SR_INIT  Initialize area for new PDS
         MVI   PRR_TITLE1,0               Initialize
         MVI   PRR_TITLE2,0               Initialize
         STM   R8,R9,PP_REGS              Save registers
*
** Dataset summary - get ready for this new dataset
*
         L     R1,PP_DSUMA                Get address of area
         L     R14,DSUMH_NUM-DSUMH(R1)    Get current count
         LA    R14,1(R14)                 Bump to next one
         ST    R14,DSUMH_NUM-DSUMH(R1)    Save current count
*
         L     R14,DSUMH_CURR-DSUMH(R1)   Get current entry
         MVI   0(R14),C' '
         MVC   1(DSUMEL,R14),0(R14)
*
** Fix up the DDNAME for concatenated/xxxLST files
*
         TM    PP_FLAG1,$PP_F1TIOT        TIOT mode?
         BNO   PP$ADD                     No, do it
         CLI   PP_ADDN,C' '               Concatenated DDNAME?
         BNE   PP$ADDNX                   No, continue
PP$ADD   EQU   *
         LA    R15,PP_PDDN                Locate DDNAME
         LA    R0,8                       Max length of DDNAME
PP$ADDNL EQU   *
         CLI   0(R15),C' '                End of DDNAME
         BE    PP$ADDNLX                  Yes, continue
         CLI   0(R15),C'('                Start of concaten stuff
         BE    PP$ADDNLX                  Yes, continue
         LA    R15,1(R15)                 Bump to next byte
         BCT   R0,PP$ADDNL                Process it
PP$ADDNLX EQU *
         MVC   0(2,R15),=C'(+'            Insert concaten stuff
         LA    R15,2(R15)                 Bump past it
         L     R1,PP_CCCNT                Get concatenation count
         LA    R1,1(R1)                   Increment by 1
         ST    R1,PP_CCCNT                Save concatenation count
         BAS   R9,EDITFWF                 Edit the number
         MVI   0(R15),C')'                Insert suffix
PP$ADDNX EQU   *
*
** Print that we are processing the DDNAME
*
         BAS   R14,CLEAR_RECOUT           Initialize the message area
         BAS   R14,PRINT_SYSPRINT_RECORD
         BAS   R14,PRINT_SYSPRINT_RECORD
*
         TIME  BIN
         ST    R0,DOUBLE
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG20L,R15),MSG20-PDSR$MSG(R1) Move in message
         LA    R15,MSG20L+1(R15)
         MVC   0(16,R15),PP_PDDN
         LA    R0,16
         BAS   R14,LOCATE_FIRST_SPACE
         MVC   1(10,R15),=C'started at'
         LA    R15,1+10(R15)
         L     R1,DOUBLE
         BAS   R14,CONVERT_BINARY_TIME    " hh:mm:ss"
*        LA    R15,10(R15)                Bump past " hh:mm:ss "
         BAS   R14,PRINT_SYSPRINT_RECORD
*
** Get the JFCB for this file
*
         TM    PP_FLAG1,$PP_F1TIOT        TIOT entry?
         BNO   PP$JFCBX
         L     R14,PP_TIOTEA              Locate TIOT entry
         BAS   R9,LOCATE_JFCB             Locate the JFCB
         LTR   R15,R15                    Found it?
         BNZ   PP$JFCBS                   Yes, continue
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG33L,R15),MSG33-PDSR$MSG(R1) Move in message
         LA    R15,MSG33L(R15)            Bump past it
         BAS   R14,PRINT_SYSPRINT_RECORD  Print message
         MVI   LASTCC,$SEVERE             Set Condition Code
         B     PP$PRTCC
PP$JFCBS EQU   *
         DA#SMODE 31                      JFCB may be above the line
         MVC   AREAJFCB(JFCBLGTH),0(R15)  Retrieve copy of JFCB
         DA#SMODE 24                      Back to 24 bit mode
PP$JFCBX EQU   *
*
** Perform a locate for file
*
PP$LOCATE EQU *
         TM    PP_FLAG1,$PP_F1TIOT        TIOT file
         BO    PP$LOCATEX                 Yes, we already have volser
*
         L     R1,=V(PDSR$C1)             -> PDSR$C1 Csect
         MVC   PARMLIST(C_LOCATEL),C_LOCATE-PDSR$C1(R1)
         LA    R1,AREAJFCB+JFCBDSNM-INFMJFCB Locate DSN
         ST    R1,PARMLIST+4              Save into parmeter list
         LA    R1,W_AREA                  Locate the work area
         ST    R1,PARMLIST+12             Save into parmeter list
         LOCATE PARMLIST                  Get catalogue information
         ST    R15,W_AREA                 Save return code
         CLI   AREAJFCB+JFCBVOLS-INFMJFCB,0 Need Volume Serial?
         BNE   PP$LOCATEX                 No, continue
         LTR   R15,R15                    Catalogued?
         BZ    PP$LOCATE_OK               Yes, continue
*
         LR    R8,R15                     Save return code
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG39L,R15),MSG39-PDSR$MSG(R1) Move in message
         LA    R15,MSG39L(R15)            Bump past it
         LR    R1,R8                      Get SVC 99 Return Code
         BAS   R9,EDITFWF                 Edit it
         MVC   0(6,R15),=C', DSN='
         MVC   6(44,R15),AREAJFCB+JFCBDSNM-INFMJFCB
         BAS   R14,PRINT_SYSPRINT_RECORD  Print error message
         MVI   LASTCC,$SEVERE             Set last condition code
         B     PP$PRTCC                   Process next guy
*
PP$LOCATE_OK EQU *
         MVC   AREAJFCB+JFCBVOLS-INFMJFCB(6),W_AREA+6
PP$LOCATEX EQU *
*
** Print Volume and Dataset name
*
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG21L,R15),MSG21-PDSR$MSG(R1) Move in message
         LA    R15,MSG21L(R15)            Bump past message
         MVC   0(6,R15),AREAJFCB+JFCBVOLS-INFMJFCB Get Volume
         LA    R15,6(R15)                 Bump past volume serial
         MVC   0(6,R15),=C', DSN='        Insert text
         LA    R15,6(R15)                 Bump past it
         MVC   0(44,R15),AREAJFCB+JFCBDSNM-INFMJFCB Get DSN
         ICM   R0,B'1111',W_AREA          LOCATE RC=0?
         BNZ   PP$M21_UCX                 No, continue
         CLC   W_AREA+6(6),AREAJFCB+JFCBVOLS-INFMJFCB Volumes match?
         BE    PP$M21_UCX                 No, continue
         LA    R0,44                      Max length
         BAS   R14,LOCATE_FIRST_SPACE     Locate first space in DSN
         MVC   0(15,R15),=C', catalogued to' Insert text
         LA    R15,15+1(R15)              Bump past it
         MVC   0(6,R15),W_AREA+6          Get catalogued version
         LA    R15,6(R15)                 Bump past it
PP$M21_UCX EQU *
         BAS   R14,PRINT_SYSPRINT_RECORD  Print error message
*
** Dynamically allocate the file
*
         TM    PP_FLAG1,$PP_F1TIOT        Processing the TIOT?
         BNO   PP$DA                      No, must do DYNALLOC
         ICM   R1,B'1111',PP_CCCNT        Get concatenation count
         BZ    PP$DASDC                   None, no need to allocate
PP$DA    EQU   *
         MVI   DOUBLE2,#PDSR$DA$ADSN      Indicate allocate by DSNAME
         L     R8,=V(PDSR$DA)             Locate CSECT
         BASSM R9,R8                      Allocate volume
         LTR   R15,R15                    Did we allocate the file?
         BNZ   PP$DAE                     No, gripe 'bout it
         L     R1,DOUBLE2                 Get Addr: Returned DDNAME
         MVC   PP_ADDN(8),0(R1)           Get allocated DDNAME
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG38L,R15),MSG38-PDSR$MSG(R1) Move in message
         LA    R15,MSG38L+1(R15)          Bump past it
*
         TM    PP_FLAG1,$PP_F1TIOT        TIOT mode?
         BNO   PP$DASRCX
         MVC   0(MSG38CL,R15),MSG38C-PDSR$MSG(R1) Move in message
         LA    R15,MSG38CL+1(R15)          Bump past it
PP$DASRCX EQU  *
         MVC   0(7,R15),=C'DDNAME='
         LA    R15,7(R15)
         MVC   0(8,R15),PP_ADDN           Get returned DDNAME
         LA    R15,9(R15)                 Bump past it
         BAS   R14,PRINT_SYSPRINT_RECORD  Print message
         B     PP$DASDCX
PP$DAE   EQU   *
         LR    R8,R15                     Save return code
         MVC   AREADSCB(2),S99ERROR-S99RB(R4) Save error code
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG34L,R15),MSG34-PDSR$MSG(R1) Move in message
         LA    R15,MSG34L(R15)            Bump past it
         LR    R1,R8                      Get SVC 99 Return Code
         BAS   R9,EDITFWF                 Edit it
         MVC   0(7,R15),=C', INFO='       Set verbage
         LA    R15,7(R15)                 Bump past it
         UNPK  0(5,R15),AREADSCB(3)       **
         MVZ   0(4,R15),ZEROS             *** Hex convert INFO
         TR    0(4,R15),HEXTABLE          **
         MVI   4(R15),C' '                Fix byte
         BAS   R14,PRINT_SYSPRINT_RECORD  Print message
         MVI   LASTCC,$SEVERE             Set Condition Code
         B     PP$PRTCC
*
** Check for unsupported file types
*
PP$DASDC EQU   *
         DEVTYPE PP_ADDN,DOUBLE           Get file information
         CLC   DOUBLE(8),ZEROS            DUMMY?
         BE    PP$DUM                     Yes, print error
         CLC   DOUBLE(8),=X'00,00,01,01,00,00,7F,F8' TSO?
         BE    PP$TSO                     Yes, print error
         CLC   DOUBLE(4),=X'00,00,01,02,00,00,7F,F8' SYSIN/SYSOUT?
         BNE   PP$DUMX                    No, continue
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG27L,R15),MSG27-PDSR$MSG(R1) Move in message
         BAS   R14,PRINT_SYSPRINT_RECORD
         MVI   LASTCC,$WARN
         B     PP$NEXT
PP$TSO   EQU   *
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG29L,R15),MSG29-PDSR$MSG(R1) Move in message
         BAS   R14,PRINT_SYSPRINT_RECORD
         MVI   LASTCC,$WARN
         B     PP$NEXT
PP$DUM   EQU   *
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG28L,R15),MSG28-PDSR$MSG(R1) Move in message
         BAS   R14,PRINT_SYSPRINT_RECORD
         MVI   LASTCC,$WARN
         B     PP$NEXT
PP$DUMX EQU    *
*
** Ensure that file is on a DASD device - DEVTYPE returned UCBTYP in
** first fullword of DOUBLE
*
         TM    DOUBLE+2,UCB3DACC          Direct Access Device?
         BO    PP$DASDCX                  Yes, continue
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG43L,R15),MSG43-PDSR$MSG(R1) Move in message
         BAS   R14,PRINT_SYSPRINT_RECORD
         MVI   LASTCC,$WARN
         B     PP$NEXT
PP$DASDCX EQU *
*
** Create the DCB to read the directory
*
         LA    R3,SYSLIB                  Locate DCB work area
         L     R1,=V(PDSR$C1)
         MVC   0(C_DCBDL,R3),C_DCBD-PDSR$C1(R1)
         MVC   DCBDDNAM-IHADCB(8,R3),PP_ADDN Get DDNAME
*
         LA    R1,PPD$X                   Locate for End-of-File (BSAM)
         STCM  R1,B'0111',DCBEODAD-IHADCB+1(R3) Save into DCB
         BAS   R14,SET_ABEND_EXIT         Set up ABEND exit
*
** Obtain format 1 DSCB
*
         L     R1,=V(PDSR$C1)             -> PDSR$C1 Csect
         MVC   PARMLIST(C_VTOCSL),C_VTOCS-PDSR$C1(R1)
         LA    R14,AREAJFCB               -> JFCB
         LA    R1,JFCBDSNM-INFMJFCB(R14)  Locate Data set Name
         ST    R1,PARMLIST+4
         LA    R1,JFCBVOLS-INFMJFCB(R14)  Locate Volume Serial
         ST    R1,PARMLIST+8
         LA    R1,AREADSCB                Locate return area for DSCB
         ST    R1,PARMLIST+12
         OBTAIN PARMLIST                  Locate F1-DSCB for dataset
         LTR   R15,R15                    Successfull?
         BZ    PP$DSCB1X                  Yes, continue
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG23L,R15),MSG23-PDSR$MSG(R1) Move in message
         LA    R15,MSG23L(R15)            Bump past it
         MVC   0(6,R15),AREAJFCB+JFCBVOLS-INFMJFCB
         BAS   R14,PRINT_SYSPRINT_RECORD  Print message
         MVI   LASTCC,$SEVERE             Fix condition code
         B     PP$NEXT                    Bump to next dataset
PP$DSCB1X EQU *
*
** Dump DSCB
*
         TM    PPC_FLAG2,$PPC_F2DUMPDSCB  Option on?
         BNO   PP$DDSCBX                  No, continue
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG45L,R15),MSG45-PDSR$MSG(R1) Move in message
         BAS   R14,PRINT_SYSPRINT_RECORD  Issue error message
         XC    W_AREA(CMXDL),W_AREA       Initialize area
         LA    R15,AREADSCB               Locate directory entry
         LA    R0,L'AREADSCB              Get length of directory ent.
         LA    R1,RECOUT+MSGPREL+8        "RPA045I > "
         STM   R15,R1,W_AREA+CMXD_ADDRESS-CMXD  Data, Length, Output
         LA    R1,DS1FMTID-IECSDSF1       First field past DSN
         ST    R1,W_AREA+CMXD_OFFSET-CMXD Set starting offset
         TM    PPC_FLAG4,$PPC_F4TSOVIEW   TSO viewing?
         BO    PP$DDSCBL
         MVC   W_AREA+CMXD_OUTPUTL-CMXD(2),=AL2(#MXDWIDE)
PP$DDSCBL EQU  *
         LA    R1,W_AREA                  Locate work area
         L     R15,EP_DA$MXD              -> DA$MXD E.P.A.
         BASSM R14,R15                    Call DA$MXD
         LR    R8,R15                     Save return code
         BAS   R14,PRINT_SYSPRINT_RECORD  Locate print routine
         LTR   R8,R8                      Any more lines to do...
         BNZ   PP$DDSCBL                  Thank you: May I have another
PP$DDSCBX EQU *
*
** Validate Dataset organization as Partitioned Data Set (PDS)
*
         LA    R1,AREADSCB                Locate DSCB
         TM    DS1DSORG-DS1FMTID(R1),DS1DSGPO PDS?
         BO    PP$POX                     Yes, continue
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG24L,R15),MSG24-PDSR$MSG(R1) Move in message
         BAS   R14,PRINT_SYSPRINT_RECORD  Issue error message
         MVI   LASTCC,$WARN               Set condition code
         B     PP$NEXT                    Process next file
PP$POX   EQU   *
*
** Check for RECFM type and start ISPF processing for RECFM not U
*
         TM    DS1RECFM-DS1FMTID(R1),DS1RECFU Load Library
         BO    PP$RFU                     Yes, do it
*
         OI    PPD_FLAG1,$PPD_F1ISPF      Set flag
         MVI   SR_FLAG1,$PPD_F1ISPF       ISPF type...
*
         CLI   PRR_IHEAD1,0               First time through here?
         BNE   PP$RFX                     No, continue
         LA    R0,#IS_HEADINGS            Option: Create headings
         LA    R1,SUBRSA                  Locate subroutine RSA
         L     R15,=V(PDSR$IS)            Locate CSECT
         BASR  R14,R15                    Invoke the parse routine
*-Read in BKLIDS file
         TM    PPD_FLAG1,$PPD_F1RBF       Already did this?
         BO    PP$RFX                     Yep, continue
         LA    R1,SUBRSA                  Locate subroutine RSA
         L     R15,=V(PDSR$RBF)           Read BKLIDS file
         BASR  R14,R15                    Call routine
         OI    PPD_FLAG1,$PPD_F1RBF       Set flag
         B     PP$RFX
*
** Set up for this new load library
*
PP$RFU   EQU   *
         AIF   ('&IHADFARELS' LT '01010100').RCMNX
         ICM   R8,B'1111',A_PDSRCMD+4     Locate area
         BZ    PP$RFU$CMX                 None
*
         LA    R1,AREAJFCB+JFCBDSNM-INFMJFCB  Locate DSNAME
         ST    R1,PDSRCMD_DSNAME-PDSRCMD(R8)
         LA    R1,AREAJFCB+JFCBVOLS-INFMJFCB  Locate volser
         ST    R1,PDSRCMD_VOLSER-PDSRCMD(R8)
*
         LA    R1,PP_ADDN
         LA    R0,L'PP_ADDN-1
         LA    R14,1
PP$RFU$CM$ILL DS 0H
         CLI   0(R1),C' '
         BE    PP$RFU$CM$ILLX
         LA    R14,1(R14)
         LA    R1,1(R1)
         BCT   R0,PP$RFU$CM$ILL
PP$RFU$CM$ILLX DS 0H
         STH   R14,PDSRCMD_INCLLIB-PDSRCMD(R8)
         MVC   PDSRCMD_INCLLIB+2-PDSRCMD(8,R8),PP_ADDN
*
         LR    R1,R8                      Locate work area
         MVI   PDSRCMD_CALLT-PDSRCMD(R1),$PDSRCMD_CT_LIBS Set option
         L     R15,=V(PDSRCM)             Locate routine
         BASR  R14,R15                    Call routine
PP$RFU$CMX DS  0H
.RCMNX   ANOP  ,
*
         L     R1,=V(PDSR$C1)
         LA    R3,PPD_PODCB               Locate DCB
         MVC   0(C_DCBPOL,R3),C_DCBPO-PDSR$C1(R1)
         MVC   DCBDDNAM-IHADCB(8,R3),PP_ADDN Get DDNAME
         MVC   PARMLIST(C_LSTIL),C_LSTI-PDSR$C1(R1)
         OPEN  ((3),(INPUT)),             Open the directory           @
               MF=(E,PARMLIST)            ..Parameter List
***>     LTR   R15,R15
***>     BZ    ....
*
         OI    PPD_FLAG1,$PPD_F1LOAD
         OI    W_FLAG1,$W_F1LOADLIB
         MVI   SR_FLAG1,$PPD_F1LOAD       Load library type
*
         L     R1,=V(PDSR$C1)
         MVC   PLM_DECB(C_DECBML),C_DECBM-PDSR$C1(R1)
*
         LA    R0,#LMF_HEADINGS           Option: Create headings
         LA    R1,SUBRSA                  Locate subroutine RSA
         L     R15,=V(PDSR$LMF)           Locate CSECT
         BASR  R14,R15                    Invoke the parse routine
*
** Perform check to see if this library is APF authorized
**
** At MVS 4.3 and higher, datasets in the LPALST do not have to be
** in the APFLST at IPL time.  Before MVS 4.3, datasets could only
** get into the LPALST by being in the APFLST. If we find a dataset
** in the LPALST that is not in the APFLST:
**
** - We will consider that the library is authorized for processing
**   sake.
** - We will print a warning message for systems before MVS 4.3.
*
         LA    R1,SUBRSA                  Locate subroutine RSA
         L     R15,=V(PDSR$APF)           Locate CSECT
         BASR  R14,R15                    Call routine
         TM    PPD_FLAG1,$PPD_F1APF       Was it APF authorized?
         BO    PP$RFMSG                   No, continue
         TM    PP_FLAG1,$PP_F1LPALST      Processing the LPALST?
         BNO   PP$RFX                     No, leave
         OI    PPD_FLAG1,$PPD_F1APF       LPALST is always APF...
*-Should get here for one or both of these reasons:
* -The LPALST dataset was removed from the APFLST after the IPL by
*  Omegamon (or other non-IBM program) or via SETPROG
* -On MVS 4.3 and higher and dataset is in LPALST and not APFLST
*  and was considered APF authorized for NIP processing so let's
*  don't brag about it.
         CLC   W_BCPLEVEL(5),=C'SP4.3'    At MVS 4.3 or higher?
         BNL   PP$RFX                     Yes, skip warning message
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG58L,R15),MSG58-PDSR$MSG(R1) Move in message
         BAS   R14,PRINT_SYSPRINT_RECORD  Print message
         B     PP$RFX
PP$RFMSG DS    0H
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG57L,R15),MSG57-PDSR$MSG(R1) Move in message
         BAS   R14,PRINT_SYSPRINT_RECORD  Print message
PP$RFX   DS    0H
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**  Open and process the library
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
*
** Increment library count
*
         L     R1,PP_NLIBS                Get number of libraries
         LA    R1,1(R1)                   Increment by 1
         ST    R1,PP_NLIBS                Save for later
*
** Open directory
*
         L     R1,=V(PDSR$C1)
         MVC   PARMLIST(C_LSTIL),C_LSTI-PDSR$C1(R1)
         LA    R3,SYSLIB
         OPEN  ((3),(INPUT)),MF=(E,PARMLIST)
         BAS   R14,PP$CHECK_OPEN_ABEND    Check for Abend
*
** Print dataset allocation information
**
** The code to get the allocated number of tracks was
** modeled after a 24-Sep-1997 post on comp.lang.asm370
** by Steve Myers (smyers@popmail.voicenet.com) - Thanks Steve.
*
         SLR   R0,R0
         SLR   R14,R14
         L     R1,DCBDEBAD-IHADCB(R3)
         IC    R0,DEBNMEXT-DEBBASIC(R1)
         LA    R1,DEBBASND-DEBBASIC(R1)
PP$ATRKL DS    0H
         AH    R14,DEBNMTRK-DEBDASD(R1)
         LA    R1,DEBDASDE-DEBDASD(R1)
         BCT   R0,PP$ATRKL
         ST    R14,PPD_TRKA               Save num of allocate tracks
*
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG62L,R15),MSG62-PDSR$MSG(R1) Move in message
         LA    R15,MSG62L(R15)
         L     R1,PPD_TRKA
         BAS   R9,EDITNCF                 Edit it
*
         MVC   0(7,R15),=C', used='
         LA    R15,7(R15)
         LA    R14,AREADSCB               Locate DSCB
         LH    R1,DS1LSTAR-DS1FMTID(R14)  Load tracks used
         N     R1,=X'0000FFFF'            Turn off high order bytes
         AH    R1,=H'1'                   Fludge upwards.
         BAS   R9,EDITNCF                 Edit it
*
         MVC   0(10,R15),=C', extents='
         LA    R15,10(R15)
         LA    R14,AREADSCB               Locate DSCB
         SR    R1,R1
         IC    R1,DS1NOEPV-DS1FMTID(R14)  Get extents
         BAS   R9,EDITNCF                 Edit # of extents for file
*
         BAS   R14,PRINT_SYSPRINT_RECORD  Issue error message
*
** Open Library for member processing
*
         LA    R3,SYSMEM                  Locate Member DCB
         L     R1,=V(PDSR$C1)
         MVC   0(C_DCBML,R3),C_DCBM-PDSR$C1(R1)
         MVC   DCBDDNAM-IHADCB(8,R3),PP_ADDN
         MVC   PARMLIST(C_LSTIL),C_LSTI-PDSR$C1(R1)
         BAS   R14,SET_ABEND_EXIT         Set up ABEND exit
         OPEN  ((3),(INPUT)),MF=(E,PARMLIST)
         BAS   R14,PP$CHECK_OPEN_ABEND    Check for Abend
*
** Obtain buffer for Member read
*
         LA    R1,SYSMEM                  -> DCB
         ICM   R0,B'1111',PP_PDSBUF       Get length of previous buffer
         BZ    PP$OB                      No buffer available...
         CH    R0,DCBBLKSI-IHADCB(R1)     Got enough?
         BNL   PP$OBX                     Yes, use it
         L     R1,PP_PDSBUF+4             Get buffer length and address
         FREEMAIN R,LV=(0),A=(1)          Free PDS buffer
PP$OB    EQU   *
         LA    R1,SYSMEM                  -> DCB
         SLR   R0,R0                      Zero register
         ICM   R0,B'0011',DCBBLKSI-IHADCB(R1) Obtain blocksize
         GETMAIN R,LV=(0)                 Request storage for buffer
         STM   R0,R1,PP_PDSBUF            Save length and address
PP$OBX   EQU   *
*
** Initialize fields
*
         MVC   PP_OTCP(4),PP_OT+4         Set first entry of table
*
** Open the report file
*
         TM    W_FLAG1,$W_F1REPORT        Report file opened?
         BO    PP$REPORTX                 Yes, continue
         OI    W_FLAG1,$W_F1REPORT        Report file opened?
         LA    R3,REPORT                  Locate DCB work area
         L     R1,=V(PDSR$C1)
         MVC   0(C_DCBOL,R3),C_DCBO-PDSR$C1(R1)
         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'REPORT'
         MVC   PARMLIST(C_LSTOL),C_LSTO-PDSR$C1(R1)
         BAS   R14,SET_ABEND_EXIT         Set up ABEND exit
         OPEN  ((3),(OUTPUT)),MF=(E,PARMLIST)
         LA    R8,=CL8'REPORT'            Locate file
         BAS   R14,CHECK_OPEN_ABEND       Check for Abend
         LA    R1,255                     Get excessive count
         STC   R1,PRR_LC                  ..force heading
PP$REPORTX EQU *
*
** Simulate mode
**
** We do everything, including open, but do not process the directory
*
         TM    PPC_FLAG1,$PPC_F1SIMULATE  Stimulate mode?
         BNO   PP$OSIMX                   Yes, continue
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG44L,R15),MSG44-PDSR$MSG(R1) Move in message
         BAS   R14,PRINT_SYSPRINT_RECORD  Print message
         B     PP$CLOSE
PP$OSIMX EQU   *
*
** Initialize report line count and process the PDS directory
*
         LA    R1,99                      Set excessive count
         STC   R1,PRR_LC                  Force new heading
         BAS   R14,PROCESS_PDS_DIRECTORY  Process the PDS directory
*
** Close PDS files
*
PP$CLOSE  EQU   *
         LA    R3,SYSMEM
         TM    DCBOFLGS-IHADCB(R3),DCBOFOPN Is file open?
         BNO   PP$CSMX
         L     R1,=V(PDSR$C1)
         MVC   PARMLIST(C_CLOSEL),C_CLOSE-PDSR$C1(R1)
         CLOSE ((3)),MF=(E,PARMLIST)      Close it
PP$CSMX  EQU   *
         LA    R3,SYSLIB
         TM    DCBOFLGS-IHADCB(R3),DCBOFOPN Is file open?
         BNO   PP$CSLX
         L     R1,=V(PDSR$C1)
         MVC   PARMLIST(C_CLOSEL),C_CLOSE-PDSR$C1(R1)
         CLOSE ((3)),MF=(E,PARMLIST)      Close it
PP$CSLX  EQU   *
         LA    R3,PPD_PODCB               Locate the DCB
         TM    DCBOFLGS-IHADCB(R3),DCBOFOPN Is file open?
         BNO   PP$CSPX
         L     R1,=V(PDSR$C1)
         MVC   PARMLIST(C_CLOSEL),C_CLOSE-PDSR$C1(R1)
         CLOSE ((3)),MF=(E,PARMLIST)      Close the file
PP$CSPX  EQU   *
*
** Simulate mode
*
         TM    PPC_FLAG1,$PPC_F1SIMULATE  Stimulate mode?
         BO    PP$NEXT                    Yes, skip stats
*
** Check for APF library error
*
         ICM   R1,B'1111',PPD_NAPF
         BZ    PP$APFX
         BAS   R14,FORMAT_MESSAGE
         MVC   0(MSG31L,R15),MSG31-PDSR$MSG(R1) Move in message
         LA    R15,MSG31L+1(R15)
         L     R1,PPD_NAPF
         BAS   R9,EDITFWF
         L     R1,=V(PDSR$MSG)
         MVC   1(MSG31AL,R15),MSG31A-PDSR$MSG(R1) Move in message
         TM    PP_FLAG1,$PP_F1LNKLST      Processing the LNKLST?
         BNO   PP$APFPM                   Yes, bypass: all are auth
         LA    R15,1+MSG31AL+1(R15)
         MVC   0(MSG31BL,R15),MSG31B-PDSR$MSG(R1) Move in message
PP$APFPM EQU   *
         BAS   R14,PRINT_SYSPRINT_RECORD
PP$APFX  EQU   *
*
** Print directory block information
*
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG22L,R15),MSG22-PDSR$MSG(R1) Move in message
         LA    R15,MSG22L+1(R15)          Bump past it
         L     R1,PPD_DIRBLKS             Number of members
         S     R1,PPD_DIRBLKSU            - Unused = Used
         BAS   R9,EDITFWF                 Edit it
         MVC   1(6,R15),=C'out of'        Insert text
         LA    R15,1+6+1(R15)             Bump past it
         L     R1,PPD_DIRBLKS             Number of members
         BAS   R9,EDITFWF                 Edit it
         BAS   R14,PRINT_SYSPRINT_RECORD  Print it
*
** Print number of members
*
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG26L,R15),MSG26-PDSR$MSG(R1) Move in message
         TM    PPD_FLAG1,$PPD_F1LOAD      Processed a Load Library?
         BNO   PP$NMF                     No, need flush EDITFWF
*-Following two lines commented out on 14-APR-1997
****     TM    PPC_FLAG1,$PPC_F1CSECT     CSECT mode?
*****    BO    PP$NML                     No, move on
PP$NMF   EQU   *
         LA    R15,MSG26L+1(R15)          Bump past it
         L     R1,PPD_NMEM                Number of members
         BAS   R9,EDITFWF                 Edit it
         TM    PPD_FLAG1,$PPD_F1LOAD      Processed a Load Library?
*-Whatever are we doing here - I need to spend some more time here...
         BO    PP$NM_LWEX    (WhatEver)   Yes, CSECT mode...
         B     PP$NM_LEX                  No, ISPF mode...
PP$NML   EQU   *
         LA    R15,MSG26SL(R15)           Bump to start
         L     R1,PPD_NMEM                Number of members
         CVD   R1,DOUBLE                  Convert number to packed
         MVC   0(6,R15),=X'40,20,20,20,20,20'
         ED    0(6,R15),DOUBLE+5
         OI    0(R15),C'0'
         LA    R15,PPTTR_COUNTE-PPTTR(R15) Bump past number
PP$NM_LWEX DS 0H
*
         ICM   R1,B'1111',PPD_NEX         Get number of Non-Execute m.
         BZ    PP$NM_LNEXX
         L     R14,=V(PDSR$C1)            -> Constants CSECT
         MVC   0(L'C_NMNE,R15),C_NMNE-PDSR$C1(R14)
         LA    R15,L'C_NMNE(R15)
         BAS   R9,EDITFWF
PP$NM_LNEXX EQU *
*
         ICM   R1,B'1111',PPD_NLERR       Get number of Load Errors
         BZ    PP$NM_LEX
         L     R14,=V(PDSR$C1)
         MVC   0(L'C_NMLE,R15),C_NMLE-PDSR$C1(R14)
         LA    R15,14(R15)
         BAS   R9,EDITFWF
PP$NM_LEX EQU *
         BAS   R14,PRINT_SYSPRINT_RECORD
*
         L     R1,PP_TMEM                Get total number of members
         A     R1,PPD_NMEM               Add total for this library
         ST    R1,PP_TMEM                Save total
*
** Print the number of COBOL CICS errors we found
*
         TM    PPD_FLAG1,$PPD_F1LOAD      Processed a Load Library?
         BNO   PP$COBCNX                  No, skip this
         TM    PPC_FLAG3,$PPC_F3COBCRPT   Doing it?
         BNO   PP$COBCNX                  No, continue
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG47L,R15),MSG47-PDSR$MSG(R1) Move in message
         LA    R15,MSG47L+1(R15)          Bump past it
         L     R1,PPD_NUMCOBCE            Number of std eye catchers
         BAS   R9,EDITFWF                 Edit number
         BAS   R14,PRINT_SYSPRINT_RECORD  Print record
PP$COBCNX DS   0H
*
** Print the number of standard Eyecatchers we found
*
         TM    PPD_FLAG1,$PPD_F1LOAD      Processed a Load Library?
         BNO   PP$ECNX                    No, skip this
         TM    PPC_FLAG3,$PPC_F3ECRPT     Doing it?
         BNO   PP$ECNX                    No, continue
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG42L,R15),MSG42-PDSR$MSG(R1) Move in message
         LA    R15,MSG42L+1(R15)          Bump past it
         L     R1,PPD_NUMEC               Number of std eye catchers
         BAS   R9,EDITFWF                 Edit number
         BAS   R14,PRINT_SYSPRINT_RECORD  Print record
PP$ECNX  DS    0H
*
** Print trivia that the binder found
*
         AIF   ('&IHADFARELS' LT '01010100').RCMLEX
         TM    PPD_FLAG1,$PPD_F1LOAD      Processed a Load Library?
         BNO   PP$TRTX                    No, skip this
         ICM   R1,B'1111',A_PDSRCMD+4     Locate area
         BZ    PP$TRTX                    Looks like don't need it
         MVI   PDSRCMD_CALLT-PDSRCMD(R1),$PDSRCMD_CT_LIBE Set option
         L     R15,=V(PDSRCM)             Locate routine
         BASR  R14,R15                    Call routine
PP$TRTX  DS    0H
.RCMLEX  ANOP  ,
*
** Print the number of zapped modules found (only pre-DFSMS/MVS)
*
         TM    PPD_FLAG1,$PPD_F1LOAD      Processed a Load Library?
         BNO   PP$ZAPNX                   No, skip this
         TM    W_FLAG1,$W_F1DFSMS         We are DFSMS/MVS!
         BO    PP$ZAPNX                   No, continue
         TM    PPC_FLAG3,$PPC_F3ZAPRPT    Doing it?
         BNO   PP$ZAPNX                   No, continue
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG46L,R15),MSG46-PDSR$MSG(R1) Move in message
         LA    R15,MSG46L+1(R15)          Bump past it
         L     R1,PPD_NUMZAP              Number of std eye catchers
         BAS   R9,EDITFWF                 Edit number
         BAS   R14,PRINT_SYSPRINT_RECORD  Print record
PP$ZAPNX DS    0H
*
** Process aliases found
*
         ICM   R8,B'1111',PPD_NALIAS      Get number of aliases
         BZ    PP$PALX                    None, continue
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG35L,R15),MSG35-PDSR$MSG(R1) Move in message
         LA    R15,MSG35L+1(R15)          Bump past it
         LR    R1,R8                      Get number of aliases
         BAS   R9,EDITFWF                 Edit number
         BAS   R14,PRINT_SYSPRINT_RECORD  Print record
         CLC   PP_OT+4(4),PP_OTCP         Any orphans found?
         BE    PP$PALX                    No, continue
         L     R7,PP_OT+4                 Get first entry address
PP$PALL  EQU   *
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG36L,R15),MSG36-PDSR$MSG(R1) Move in message
         LA    R15,MSG36L+1(R15)          Bump past it
         DA#SMODE 31                      Get into 31 bit mode
         MVC   0(8,R15),ORPT_ANAME-ORPT(R7) Get alias name
         BAS   R14,ENSURE_PRINTABLE_MEMNAME Ensure good member name
         LA    R0,#EPML                   Max length of member name
*-If it is flush, then they don't line up! Changed on 25-NOV-1996
*        BAS   R14,LOCATE_FIRST_SPACE     Locate first space
         LA    R15,8(R15)
         MVC   1(7,R15),=C'at TTR='
         LA    R15,1+7(R15)               Bump past it
         UNPK  0(7,R15),ORPT_ATTR-ORPT(4,R7)
         MVZ   0(6,R15),ZEROS
         TR    0(6,R15),HEXTABLE
         LA    R15,6(R15)                 Bump past TTR
         MVC   0(9,R15),=C' alias of'     Insert Text
         LA    R15,10(R15)                Bump past it
         MVC   0(8,R15),ORPT_RNAME-ORPT(R7) Get real member name
         BAS   R14,ENSURE_PRINTABLE_MEMNAME Ensure good member name
         LA    R0,#EPML                   Bump past it
*-If it is flush, then they don't line up! Changed on 25-NOV-1996
*        BAS   R14,LOCATE_FIRST_SPACE     Locate first Space
         LA    R15,8(R15)
         CLC   ORPT_RTTR-ORPT(3,R7),ZEROS Really-out-there orphan?
         BE    PP$PALB                    Yes, supposed to be diff.
         CLC   ORPT_ATTR-ORPT(3,R7),ORPT_RTTR-ORPT(R7) Match?
         BE    PP$PALB                    Yes, skip it
         LA    R0,8                       Max length of member name
         BAS   R14,LOCATE_FIRST_SPACE     Locate first space
         MVC   1(7,R15),=C'at TTR='
         LA    R15,1+7(R15)               Bump past it
         UNPK  0(7,R15),ORPT_RTTR-ORPT(4,R7)
         MVZ   0(6,R15),ZEROS
         TR    0(6,R15),HEXTABLE
         LA    R15,6(R15)                 Bump past TTR
         L     R1,=V(PDSR$C1)
         MVC   0(L'C_PPTTR,R15),C_PPTTR-PDSR$C1(R1)
PP$PALB  EQU   *
         LA    R7,ORPTL(R7)               Bump to next entry
         DA#SMODE 24                      Get back into 24 bit mode
         BAS   R14,PRINT_SYSPRINT_RECORD  print message
         C     R7,PP_OTCP                 Hit max?
         BL    PP$PALL                    No, process next one
*
         BAS   R14,CLEAR_RECOUT           Initialize the message area
         BAS   R14,PRINT_SYSPRINT_RECORD  Print blank line
PP$PALX  EQU   *
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Print footing information on report file
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
         TM    PPC_FLAG1,$PPC_F1DATONLY   Do report footing?
         BO    PP$FOOTX                   No, move on
         TM    PPC_FLAG1,$PPC_F1NODET     Do detail records?
         BO    PP$FOOTX                   No, move on
         ICM   R1,B'1111',PPD_NMEM        Any Members?
         BZ    PP$FOOTX                   No, continue
         NI    PPD_FLAG1,255-$PPD_F1NEWHEAD
*
** Print delimiter line
*
         MVI   RECOUT+1,C'-'              Get dash
         MVC   RECOUT+2(131),RECOUT+1     ..Propagate it
         BAS   R14,PRINT_REPORT_RECORD
*
** Print totals line
*
         BAS   R14,CLEAR_RECOUT
         LA    R15,RECOUT+1
         TM    PPD_FLAG1,$PPD_F1LOAD      Load library?
         BNO   PP$FT_SPF                  No, ISPF thang
*
*-Commented out this code which doesn't print a valid totals length
*-for the load library. Need to find out what is zeroing out PPD_SIZE
*-for load libraries (ispf seems to be fine). 29-apr-1997
 AGO .LENERRX
         UNPK  DET_LSIZE-2-DET(9,R15),PPD_SIZE(5)
         MVZ   DET_LSIZE-2-DET(8,R15),ZEROS
         TR    DET_LSIZE-2-DET(8,R15),HEXTABLE
         MVI   DET_LSIZE+6-DET(R15),C' '
         BAS   R14,PRINT_REPORT_RECORD
.LENERRX ANOP ,
         B     PP$FT_SPFX                 No, ISPF thang
PP$FT_SPF EQU *
         MVC   DETMEM-DET(7,R15),=C'Totals:'
         L     R1,PPD_SIZE
         CVD   R1,DOUBLE
         MVC   DET_ISIZE-DET(6,R15),=X'40,20,20,20,20,20'
         ED    DET_ISIZE-DET(6,R15),DOUBLE+5
         L     R1,PPD_IINIT
         CVD   R1,DOUBLE
         MVC   DET_IINIT-DET(6,R15),=X'40,20,20,20,20,20'
         ED    DET_IINIT-DET(6,R15),DOUBLE+5
         L     R1,PPD_IMODL
         CVD   R1,DOUBLE
         MVC   DET_IMODL-DET(6,R15),=X'40,20,20,20,20,20'
         ED    DET_IMODL-DET(6,R15),DOUBLE+5
         BAS   R14,PRINT_REPORT_RECORD
PP$FT_SPFX EQU *
*
** Print number of members
*
         BAS   R14,CLEAR_RECOUT
         BAS   R14,PRINT_REPORT_RECORD
         L     R1,=V(PDSR$MSG)
         LA    R15,RECOUT+1
         MVC   0(L'MSG26NOM,R15),MSG26NOM-PDSR$MSG(R1)
         LA    R15,L'MSG26NOM+1(R15)
         L     R1,PPD_NMEM
         BAS   R9,EDITFWF
         BAS   R14,PRINT_REPORT_RECORD
PP$FOOTX EQU *
 SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**  Bump to next file to process
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
 SPACE 2
PP$NEXT  EQU   *
*
** Dataset summary - get ready for the next dataset
*
         SLR   R0,R0                      R0 is not currently used
         LA    R1,SUBRSA                  Locate subroutine RSA
         L     R15,=V(PDSR$DSP)           Locate CSECT
         BASR  R14,R15                    Invoke the parse routine
*
** Free Dynamically allocated File
*
         TM    PP_FLAG1,$PP_F1TIOT        TIOT file?
         BNO   PP$FDAF                    No, always free it
         ICM   R1,B'1111',PP_CCCNT        Get concatenation count
         BZ    PP$NFDDX                   Not zero, skip check
PP$FDAF  EQU   *
         MVI   DOUBLE2,#PDSR$DA$FDD       Indicate free by DDNAME
         L     R8,=V(PDSR$DA)             Locate CSECT
         BASSM R9,R8                      Allocate volume
         LTR   R15,R15                    Did we allocate the file?
         BZ    PP$NFDDX                   No, gripe 'bout it
         LR    R8,R15                     Save return code
         MVC   AREADSCB(2),S99ERROR-S99RB(R4) Save error code
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG37L,R15),MSG37-PDSR$MSG(R1) Move in message
         LA    R15,MSG37L(R15)            Bump past it
         MVC   0(8,R15),PP_ADDN           Get returned DDNAME
         LA    R15,8(R15)                 Bump past it
         MVC   0(5,R15),=C', RC='         Insert text
         LA    R15,5(R15)                 Bump past text
         LR    R1,R8                      Get DYNALLOC return code
         BAS   R9,EDITFWF                 Edit it
         MVC   0(8,R15),=C', Error='      Insert text
         UNPK  8(5,R15),AREADSCB(3)
         MVZ   8(4,R15),ZEROS
         TR    8(4,R15),HEXTABLE
         MVI   8+4(R15),C' '
         BAS   R14,PRINT_SYSPRINT_RECORD  Print message
PP$NFDDX EQU   *
*
** Print Last condition code
*
PP$PRTCC EQU   *
         BAS   R14,FORMAT_MESSAGE         Initialize RECOUT to blanks
         MVC   0(MSG90L,R15),MSG90-PDSR$MSG(R1) Move in message
         LA    R15,MSG90L+1(R15)          Bump past it
         SLR   R1,R1                      Clear register
         IC    R1,LASTCC                  Get condition code
         BAS   R9,EDITFWF                 Edit it
         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record
         CLC   MAXCC(1),LASTCC            Need to put higher c.c.
         BH    PP$LCCX                    No, move on
         MVC   MAXCC(1),LASTCC            Save condition code
PP$LCCX  EQU   *
         MVI   LASTCC,0                   Reset condition code
*
** Print a blank line
*
         BAS   R14,CLEAR_RECOUT           Clear record to blanks
         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record
*
** Locate to next file to process
*
         LM    R8,R9,PP_REGS              Restore registers
         TM    PP_FLAG1,$PP_F1TIOT        TIOT mode?
         BO    PP$TIOT                    Yes, continue
         TM    PP_FLAG1,$PP_F1LNKLST      LNKLST mode?
         BO    PP$LNKLST_LB               Yes, continue
         TM    PP_FLAG1,$PP_F1LPALST      LPALST mode?
         BO    PP$LPALST_LB               Yes, continue
         B     PP$X                       Leave (Should not happen)
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**  Misc subroutines for Process_PDS
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
*
** Print Message 19 - R8 has type of processing
*
PP$LST_INIT EQU *
         ST    R14,PP_REGS                Save return address
         ST    R9,PP_REGS+4               Save register
*
         BAS   R14,CLEAR_RECOUT           Clear record to blanks
         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record
*
         BAS   R14,FORMAT_MESSAGE         Initialize message area
         MVC   0(MSG19L,R15),MSG19-PDSR$MSG(R1) Move in message
         LA    R15,MSG19L+1(R15)          Bump past it
         MVC   0(6,R15),0(R7)             Get "LNK/LPA"
         MVC   6(L'MSG19N,R15),MSG19N-PDSR$MSG(R1)
         LA    R15,6+L'MSG19N+1(R15)      Bump past it
         L     R1,PP_REGS+4               Get number in list
         BAS   R9,EDITFWF                 Edit it
         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record
*
         XC    AREAJFCB(L'AREAJFCB),AREAJFCB
         MVC   PP_PDDN(6),0(R7)           Get type
         MVC   PP_PDDN+6(2),=C'  '        Ensure trailing blank
         MVC   PP_ADDN(8),=CL8' '         Blank it out
         MVC   PP_PDDN+8(8),=CL8' '       Blank it out
         L     R1,=F'-1'                  Start out as "+0"
         ST    R1,PP_CCCNT                Get concatenation count
*
         L     R9,PP_REGS+4               Restore register
         L     R14,PP_REGS                Save return address
         BSM   0,R14
*
** Check for open abend
*
PP$CHECK_OPEN_ABEND EQU *
         CLC   OX_CODE(4),ZEROS           Open failed?
         BNE   PP$COAS                    Yes, forget it
         LTR   R15,R15                    Open okay?
         BNZ   PP$COAS                    Yes, move on
         BSM   0,R14
PP$COAS  EQU   *
         ST    R15,DOUBLE                 Save OPEN return code
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG41L,R15),MSG41-PDSR$MSG(R1) Move in message
         LA    R15,MSG41L+1(R15)          Bump past it
         LA    R8,PP_ADDN                 Locate DDNAME
         BAS   R14,FORMAT_OPEN_ABEND_MSG  Format error msg
         BAS   R14,PRINT_SYSPRINT_RECORD  Print message
         MVI   LASTCC,20                  Set Condition code
         B     PP$CLOSE
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**  Common exit from Process_TIOT_Entries
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
PP$X     EQU   *
         BAS   R14,CLEAR_RECOUT           Clear record to blanks
         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record
*
** Print error message about APF
*
         TM    W_FLAG1,$W_F1APFLSTD       Did we find error?
         BNO   PP$APFEX                   No, continue
         BAS   R14,FORMAT_MESSAGE         Initialize RECOUT to blanks
         MVC   0(MSG91L,R15),MSG91-PDSR$MSG(R1) Move in message
         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record
PP$APFEX DS    0H
*
** Print LNKLST information
*
         TM    PPC_FLAG2,$PPC_F2LNKLST    Need to do this one?
         BNO   PP$LLTX                    No, continue
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG63L,R15),MSG63-PDSR$MSG(R1) Move in message
         LA    R15,MSG63L+1(R15)          Bump past it
         L     R1,PP_DSUMA                Locate area
         L     R1,DSUMH_LLE-DSUMH(R1)     Get number of LNKLST extents
         BAS   R9,EDITFWF                 Edit it
         BAS   R14,PRINT_SYSPRINT_RECORD  Print message
PP$LLTX  DS    0H
*
** Print number of libraries processed
*
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG998L,R15),MSG998-PDSR$MSG(R1) Move in message
         LA    R15,MSG998L+1(R15)         Bump past it
         L     R1,PP_NLIBS                Get number of libraries
         BAS   R9,EDITFWF                 Edit it
         MVC   0(20,R15),=C', members processed:' Add text
         LA    R15,20+1(R15)              Bump past it
         L     R1,PP_TMEM                 Get total members
         BAS   R9,EDITFWF                 Edit it
         BAS   R14,PRINT_SYSPRINT_RECORD  Print message
*
** If we are doing find member processing, print totals
*
         SPACE 2
         TM    PPC_IFLAG1,$PPC_IF1FMG     Was it generic?
         BO    PP$FMG
         CLI   PPC_FML,0                  Doing find member checking?
         BE    PP$FMX                     No, leave
PP$FMG   DS    0H
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG54L,R15),MSG54-PDSR$MSG(R1) Move in message
         MVC   MSG54N-MSG54(8,R15),PPC_FM Get member name
         ICM   R0,B'1111',PP_FMCOUNT      Get count
         BZ    PP$FM0
         LA    R15,MSG54L(R15)
         LR    R1,R0
         BAS   R9,EDITFWF
         MVC   1(5,R15),=C'times'
         B     PP$FM0X
PP$FM0   DS    0H
         MVC   MSG54E-MSG54(4,R15),=C'not '
         LA    R15,MSG54E+4-MSG54(R15)
         MVC   0(5,R15),MSG54E-PDSR$MSG(R1)
PP$FM0X  DS    0H
         BAS   R14,PRINT_SYSPRINT_RECORD  Print message
PP$FMX   DS    0H
         EJECT ,
***********************************************************************
***
**       Check for Duplicates / Member Cross references
***
***********************************************************************
         SPACE 2
CHECK_FOR_DUPLICATES EQU *
         TM    PPC_FLAG1,$PPC_F1MEMXREF   Member Cross reference?
         BO    CFD$S                      Yes, do it
         TM    PPC_FLAG1,$PPC_F1CHKDUP    Check for duplicates?
         BNO   CFD$X                      No, continue
CFD$S    EQU   *
*
** Close input sort file
*
         LA    R3,WRKFILE1
         L     R1,=V(PDSR$C1)
         MVC   PARMLIST(C_CLOSEL),C_CLOSE-PDSR$C1(R1)
         CLOSE ((3)),MF=(E,PARMLIST)      Close it
*
         TM    PPC_FLAG1,$PPC_F1SIMULATE  Simulate mode?
         BO    CFD$X                      Yes, skip this
*
** Print starting message
*
         BAS   R14,CLEAR_RECOUT           Clear record to blanks
         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG70L,R15),MSG70-PDSR$MSG(R1) Move in message
         LA    R15,MSG70L+1(R15)
         TM    PPC_FLAG1,$PPC_F1CHKDUP    Check for duplicates
         BO    CFD$M70D                   Yes, do duplicate
         TM    PPC_FLAG1,$PPC_F1MEMXREF   Member XREF?
         BO    CFD$M70C                   Yes, do cross reference
         MVI   0(R15),C'?'                Say what
         LA    R15,2(R15)
         B     CFD$M70M
CFD$M70C EQU   *
         MVC   0(MSG70BL,R15),MSG70B-PDSR$MSG(R1)
         LA    R15,MSG70BL+1(R15)
         B     CFD$M70M
CFD$M70D EQU   *
         MVC   0(MSG70AL,R15),MSG70A-PDSR$MSG(R1)
         LA    R15,MSG70AL+1(R15)
CFD$M70M EQU   *
         MVC   0(7,R15),=C'started'
         BAS   R14,PRINT_SYSPRINT_RECORD  Print message
CFD$M70X EQU   *
*
** Sort the input file (WRKFILE1) into the output file (WRKFILE2)
*
         LA    R1,C_SFCFD                 Locate sort fields string
         BAS   R14,SORT_FILE              Sort WRKFILE1 by Key
         LTR   R15,R15                    Okay?
         BZ    CFD$SORTX                  Yes, continue
         MVI   MAXCC,$SEVERE              No, set max condition code
         B     EXIT                       Leave
CFD$SORTX EQU  *
*
** Correct headings
*
*
         LA    R15,PRR_IHEAD1+1           Locate heading record
         USING DET,R15
         L     R1,=V(PDSR$C2)             -> Constants CSECT
         USING PDSR$C2,R1
         MVC   DET_IMULT(DET_IMULTL),C_BLANKS
         MVC   DET_IDD(9),C_DET_IDD
         MVC   DET_IVOL(6),C_DET_IVOL
         MVC   DET_IDSN(13),C_DET_IDSN
         LA    R15,PRR_IHEAD2+1           Locate heading record
         MVC   DET_IMULT(DET_IMULTL),C_BLANKS
         MVC   DET_IDD(L'DET_IDD),C_DASHS+1
         MVC   DET_IVOL(L'DET_IVOL),C_DASHS+1
         MVC   DET_IDSN(DET_IDSNL),C_DASHS+1
*
         LA    R15,PRR_LHEAD1+1           Locate heading record
         MVC   DET_LMULT(DET_LMULTL),C_BLANKS
         LA    R15,PRR_LHEAD2+1           Locate heading record
         MVC   DET_LMULT(DET_LMULTL),C_BLANKS
         MVC   DET_LDD(6),C_DET_LDD
         MVC   DET_LVOL(6),C_DET_LVOL
         MVC   DET_LDSN(13),C_DET_LDSN
         LA    R15,PRR_LHEAD3+1           Locate heading record
         MVC   DET_LMULT(DET_LMULTL),C_BLANKS
         MVC   DET_LDD(L'DET_LDD),C_DASHS+1
         MVC   DET_LVOL(L'DET_LVOL),C_DASHS+1
         MVC   DET_LDSN(DET_LDSNL),C_DASHS+1
         DROP  R1,R15
*
** Open the sorted file
*
         LA    R3,WRKFILE2                Locate DCB work area
         L     R1,=V(PDSR$C1)
         MVC   0(C_DCBIL,R3),C_DCBI-PDSR$C1(R1)
         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'WRKFILE2' Get DDNAME
         MVC   PARMLIST(C_LSTIL),C_LSTI-PDSR$C1(R1)
         LA    R2,CFD$LX                  Locate END-OF-FILE area
         STCM  R2,B'0111',DCBEODAD-IHADCB+1(R3) Insert into DCB
         OPEN  ((3),(INPUT)),MF=(E,PARMLIST)
*
** Process the sorted file
*
         XC    CFD_MEMBER(8),CFD_MEMBER   Initialize control break
         XC    CFD_NUM(4),CFD_NUM         Clear number of duplicates
         MVI   CFD_RECOUT,255             Hadn't printed a thing yet
         MVI   CFD_TYPE,0                 Set type
         MVI   CFD_FIRST,0                First time?
         MVI   PRR_LC,255                 Force heading
         MVI   PRR_TITLE1,0               Initialize
         MVI   PRR_TITLE2,0               Initialize
CFD$L    EQU   *
         GET   WRKFILE2                   Get input record
         LR    R2,R1                      Save address of record
*MVC RECOUT(133),RECOUT-SORTREC(R2)
*BAS R14,PRINT_SYSPRINT_RECORD
*
         TM    PPC_FLAG1,$PPC_F1MEMXREF   Member Cross reference?
         BO    CFD$LMEMX                  Yes, print record asis
         CLI   CFD_MEMBER,0               First time thru?
         BE    CFD$LI                     Yes, initialize for member
         CLC   CFD_MEMBER(8),RECOUT+1+(DETMEM-DET)-SORTREC(R2)
         BNE   CFD$LI                     New member to worry about
*
         L     R1,CFD_NUM                 Get current number
         LA    R1,1(R1)                   Increment by 1
         ST    R1,CFD_NUM                 Save number
*
         CLI   CFD_RECOUT,0               Printed previous record?
         BE    CFD$LPRX                   Yes, continue
*
         CLI   CFD_FIRST,0                Feel like the first time?
         BE    CFD$LFX                    Yes, don't need delimiter
         NI    PPD_FLAG1,255-$PPD_F1NEWHEAD
         MVI   RECOUT,C' '                Fill in FBA byte
         MVI   RECOUT+1,C'='
         MVC   RECOUT+2(L'RECOUT-2),RECOUT+1
         BAS   R14,PRINT_REPORT_RECORD    Print report record
CFD$LFX  EQU   *
         MVI   CFD_FIRST,1                Set flag
         LA    R6,CFD_RECOUT              Locate previous record
         BAS   R7,CFD$LOC                 Fill in location
         BAS   R14,PRINT_REPORT_RECORD    Print report record
CFD$LPRX EQU   *
         MVC   CFD_MEMBER(8),RECOUT+1+(DETMEM-DET)-SORTREC(R2)
CFD$LMEMX EQU  *
         LR    R6,R2                      Locate fields for CFD$LOC
         BAS   R7,CFD$LOC                 Fill in location
         BAS   R14,PRINT_REPORT_RECORD    Print current record
         MVI   CFD_RECOUT,0               Printed previous record
         MVI   CFD_FIRST,1                Feel like the first time
         B     CFD$L
*
CFD$LI   EQU   *
         MVC   CFD_MEMBER(8),RECOUT+1+(DETMEM-DET)-SORTREC(R2)
         MVC   CFD_RECOUT(SORTRECL),0(R2)
         B     CFD$L
*
** Fill in location
*
CFD$LOC  EQU   *
         MVC   RECOUT(133),RECOUT-SORTREC(R6)   Fix output record
         MVC   PPD_FLAG1(1),SR_FLAG1-SORTREC(R6) Set flag for print
*
         TM    PPC_FLAG1,$PPC_F1MEMXREF   Member XREF?
         BO    CFD$LPF1M
         OI    PPD_FLAG1,$PPD_F1CHKDUP    We are in duplicate process
         B     CFD$LPF1MX
CFD$LPF1M EQU *
         OI    PPD_FLAG1,$PPD_F1MEMXREF   We are doing member XREF
CFD$LPF1MX EQU *
*
         CLI   CFD_TYPE,0                 First time?
         BE    CFD$LOCHX                  Yes, normal headings will do
         CLC   CFD_TYPE(1),SR_FLAG1-SORTREC(R6)
         BE    CFD$LOCHX                  Yes, continue
         OI    PPD_FLAG1,$PPD_F1NEWHEAD   Need new headings
CFD$LOCHX EQU *
         MVC   CFD_TYPE(1),SR_FLAG1-SORTREC(R6) Fill in type
         LA    R15,RECOUT+1               Locate output record
*
         L     R1,=V(PDSR$C2)             -> Constants CSECT
         TM    PPD_FLAG1,$PPD_F1ISPF      ISPF?
         BO    CFD$LOCI                   Yes, continue
         MVC   DET_LMULT-DET(DET_LMULTL,R15),C_BLANKS-PDSR$C2(R1)
         MVC   DET_LDD-DET(16,R15),SR_DDNAME-SORTREC(R6)
         MVC   DET_LVOL-DET(6,R15),SR_VOLSER-SORTREC(R6)
         MVC   DET_LDSN-DET(44,R15),SR_DSN-SORTREC(R6)
         MVI   DET_LMULTD-DET(R15),C'|'
         BSM   0,R7
CFD$LOCI EQU   *
         MVC   DET_IMULT-DET(DET_IMULTL,R15),C_BLANKS-PDSR$C2(R1)
         MVC   DET_IDD-DET(16,R15),SR_DDNAME-SORTREC(R6)
         MVC   DET_IVOL-DET(6,R15),SR_VOLSER-SORTREC(R6)
         MVC   DET_IDSN-DET(44,R15),SR_DSN-SORTREC(R6)
         MVI   DET_IMULTD-DET(R15),C'|'
         BSM   0,R7
*
** End of file
*
CFD$LX   EQU   *
         LA    R3,WRKFILE3
         L     R1,=V(PDSR$C1)
         MVC   PARMLIST(C_CLOSEL),C_CLOSE-PDSR$C1(R1)
         CLOSE ((3)),MF=(E,PARMLIST)      Close it
*
         LA    R3,WRKFILE2
         L     R1,=V(PDSR$C1)
         MVC   PARMLIST(C_CLOSEL),C_CLOSE-PDSR$C1(R1)
         CLOSE ((3)),MF=(E,PARMLIST)      Close it
*
** Print number of duplicates found
*
         TM    PPC_FLAG1,$PPC_F1MEMXREF   Member XREF?
         BO    CFD$M71X                   Yes, continue
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG71L,R15),MSG71-PDSR$MSG(R1) Move in message
         LA    R15,MSG71L+1(R15)          Bump past it
         L     R1,CFD_NUM                 Get number of duplicates
         BAS   R9,EDITFWF                 Edit it
         MVC   1(6,R15),=C'out of'        Insert text
         LA    R15,1+6+1(R15)             Bump past it
         L     R1,PP_TMEM                 Get total members
         BAS   R9,EDITFWF                 Edit it
         BAS   R14,PRINT_SYSPRINT_RECORD
CFD$M71X EQU   *
*
** Common exit from Check_For_Duplicates
*
CFD$X    EQU   *
         EJECT
***********************************************************************
***
**       Print Dataset summary
***
***********************************************************************
         SPACE 2
PRINT_DATASET_SUMMARY DS 0H
*
** Initialize
*
         L     R2,PP_DSUMA                Save length and address
         TM    PPC_Flag1,$PPC_F1DATONLY   Data only?
         BO    PDS$X                      Yes, skip this
         L     R3,DSUMH_NUM-DSUMH(R2)     Get total number
         LA    R4,DSUMHL(R2)              Locate to first entry
         OI    W_FLAG2,$W_F2PDSUM+$W_F2PDSUM1  Flags needed for report
         MVC   PRR_LC(2),=H'9999'         Force heading
         MVI   PRR_TITLE1,0               Indicate first time
*
** Loop through the Dataset entries
*
PDS$L    DS    0H
         MVI   RECOUT+1,C' '              Get space
         MVC   RECOUT+2(131),RECOUT+1     ..Propagate it
         MVC   RECOUT+1(DSUMEL),0(R4)
         BAS   R14,PRINT_REPORT_RECORD
         LA    R4,DSUMEL(R4)
         BCT   R3,PDS$L
*
         MVI   RECOUT+1,C'-'              Get dash
         MVC   RECOUT+2(DSUMEL-1),RECOUT+1 ..Propagate it
         BAS   R14,PRINT_REPORT_RECORD
*
         MVI   RECOUT+1,C' '              Get space
         MVC   RECOUT+2(DSUMEL-1),RECOUT+1     ..Propagate it
         LA    R4,RECOUT+1
         L     R1,DSUMH_CNTTRKA-DSUMH(R2) Get total
         CVD   R1,DOUBLE                  Convert number to packed
         MVC   DSUME_TRKA-DSUME(6,R4),=X'40,20,20,20,20,20'
         ED    DSUME_TRKA-DSUME(6,R4),DOUBLE+5
         L     R1,DSUMH_CNTTRKU-DSUMH(R2) Get total
         CVD   R1,DOUBLE                  Convert number to packed
         MVC   DSUME_TRKU-DSUME(6,R4),=X'40,20,20,20,20,20'
         ED    DSUME_TRKU-DSUME(6,R4),DOUBLE+5
         L     R1,DSUMH_CNTMEM-DSUMH(R2)  Get total
         CVD   R1,DOUBLE                  Convert number to packed
         MVC   DSUME_MEMBERS-DSUME(6,R4),=X'40,20,20,20,20,20'
         ED    DSUME_MEMBERS-DSUME(6,R4),DOUBLE+5
         L     R1,DSUMH_NUM-DSUMH(R2)     Get library count
         LA    R15,DSUME_DSN-DSUME(R4)    Locate to output area
         BAS   R9,EDITFWF                 Edit library count
         BAS   R14,PRINT_REPORT_RECORD
*
** Free the Dataset Summary data area
*
PDS$X    DS    0H
         LR    R1,R2                      Get address of area
         L     R0,DSUMH_LEN-DSUMH(R1)     Get length of area
         FREEMAIN R,LV=(0),A=(1)          Then free the area
         EJECT
***********************************************************************
***
**       Termination Section
***
***********************************************************************
         SPACE 2
EXIT     EQU   *
*
** Call PDSR$IVC for termination
*
         TM    PPC_FLAG5,$PPC_F5IVCSECTS
         BNO   X$IVCX
         LA    R0,#IVC_TERM
         LA    R1,SUBRSA
         L     R15,=V(PDSR$IVC)
         BASR  R14,R15
X$IVCX   DS    0H
*
** Call PDSRCM for termination
*
         AIF   ('&IHADFARELS' LT '01010100').RCMXX
         ICM   R1,B'1111',A_PDSRCMD+4     Locate area
         BZ    X$PDSRCM$X                 None, PDSRCM not needed
         MVI   PDSRCMD_CALLT-PDSRCMD(R1),$PDSRCMD_CT_TERM
         L     R15,=V(PDSRCM)             Locate routine
         BASR  R14,R15                    Initialize
         LM    R0,R1,A_PDSRCMD            Get length and address
         FREEMAIN R,LV=(0),A=(1)          Then free the area
X$PDSRCM$X DS  0H
.RCMXX   ANOP  ,
*
** Free APFLST table for MVS 4.3 and higher using Dynamic type
*
         LM    R0,R1,APF_DYN              Get area length and address
         LTR   R0,R0                      Anything to free?
         BZ    X$APFX                     No, continue
         FREEMAIN RU,LV=(0),A=(1)         Release storage
X$APFX   EQU   *
*
** Free BKLids table (if any)
*
         ICM   R1,B'1111',RBF_PTR         Table obtained
         BZ    X$RBFX                     No, continue
         L     R0,BKLH_LEN-BKLH(R1)       Yes, get length and...
         FREEMAIN RU,LV=(0),A=(1)         Release storage
X$RBFX   EQU   *
*
** Free Alias table
*
         LM    R0,R1,PP_OT                Get table length and address
         LTR   R0,R0                      Any table to free?
         BZ    X$ATX                      No, continue
         FREEMAIN RU,LV=(0),A=(1)         Release storage
X$ATX    EQU   *
*
** Free Translator table
*
         LM    R0,R1,PP_TT                Get table length and address
         LTR   R0,R0                      Any table to free?
         BZ    X$TTX                      No, continue
         FREEMAIN RU,LV=(0),A=(1)         Release storage
X$TTX    EQU   *
*
** Free I/O buffer if allocated
*
         LM    R0,R1,PP_PDSBUF            Get buffer length and address
         LTR   R0,R0                      Any buffer to free?
         BZ    X$PPDBX                    No, continue
         FREEMAIN R,LV=(0),A=(1)          Release storage
X$PPDBX  EQU   *
*
** Print ending message on //SYSPRINT: MAX condition code and time
*
         TM    SYSPRINT+(DCBOFLGS-IHADCB),DCBOFOPN Is file open?
         BNO   X$MSGX
         BAS   R14,CLEAR_RECOUT           Clear record to blanks
         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record
         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record
*
         TIME  BIN                        Get the time
         ST    R0,SF_RA                   Save for later
         BAS   R14,FORMAT_MESSAGE         Initialize RECOUT to blanks
         MVC   0(MSG999L,R15),MSG999-PDSR$MSG(R1) Move in message
         LA    R15,MSG999L+1(R15)         Bump past it
         SLR   R1,R1                      Clear register
         IC    R1,MAXCC                   Get condition code
         BAS   R9,EDITFWF                 Edit it
         MVC   0(7,R15),=C', Time:'
         LA    R15,7(R15)
         L     R1,SF_RA                   Get the time
         BAS   R14,CONVERT_BINARY_TIME    " hh:mm:ss"
         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record
X$MSGX   EQU   *
*
** Print "End of Report" on //REPORT
*
         TM    PPC_Flag1,$PPC_F1DATONLY   Data only?
         BO    X$RPTX                     Yes, skip this
         TM    REPORT+(DCBOFLGS-IHADCB),DCBOFOPN Is file open?
         BNO   X$RPTX                     No, continue
         BAS   R14,CLEAR_RECOUT           Clear record to blanks
         BAS   R14,PRINT_REPORT_RECORD    Print the record
         MVC   RECOUT+1(14),=C'End of Report.'
         BAS   R14,PRINT_REPORT_RECORD    Print the record
X$RPTX   DS    0H
*
** Close files
*
         LA    R3,ZAPRPT
         BAS   R9,CLOSE_FILE
         LA    R3,ECRPT
         BAS   R9,CLOSE_FILE
         LA    R3,COBCRPT
         BAS   R9,CLOSE_FILE
         LA    R3,REPORT
         BAS   R9,CLOSE_FILE
         LA    R3,SYSPRINT
         BAS   R9,CLOSE_FILE
*
** Delete modules from memory
*
         TM    W_FLAG1,$W_F1LRDATE        Did we get loaded?
         BNO   X$DATEX                    No, bummer dude!
         ICM   R0,B'1111',EP_DA$DATE      -> Program Loaded?
         BZ    X$DATEX                    No, continue
         DELETE EPLOC==CL8'DA$DATE'       Delete from V/S
X$DATEX EQU    *
         TM    W_FLAG1,$W_F1LRMXD         Did we get loaded?
         BNO   X$MXDUMPX                  No, bummer dude!
         ICM   R0,B'1111',EP_DA$MXD       -> Program Loaded?
         BZ    X$MXDUMPX                  No, continue
         DELETE EPLOC==CL8'DA$MXD'        Delete from V/S
X$MXDUMPX EQU  *
*
** Return to caller with the maximum condition code
*
         SLR   R15,R15                    Get ready for IC
         IC    R15,MAXCC                  Get maximum condition code
X$LEAVE  EQU   *
         DA#LEAVE RC=(15)                 Return to caller
         EJECT
***********************************************************************
***
**       Error routines
***
***********************************************************************
         SPACE 2
*
** Error: Required load module not found, execution not possible
**
** Input: R8 - 8 byte program name
*
E$LOAD   EQU   *
         LA    R1,RECOUT                  Locate WTO work area
         L     R14,=V(PDSR$C1)            -> Constants CSECT
         MVC   0(C_WTOL,R1),C_WTO-PDSR$C1(R14) Initialize WTO
         LA    R15,4(R1)                  Bump past WTO flags
         BAS   R14,FM$PRE                 Get message prefix
         MVC   0(MSG80L,R15),MSG80-PDSR$MSG(R1) Move in message
         MVC   MSG80L+1(8,R15),0(R8)      Get module name
         WTO   ,MF=(E,RECOUT)             Issue WTO message
         LA    R15,20                     Set condition code
         B     X$LEAVE
*
** Error: Open of global file (SYSPRINT or REPORT failed)
**
** Input: R8 - 8 file name
*
E$OPENG  EQU   *
         ST    R15,DOUBLE                 Save return code
         CLI   0(R8),C'S'                 SYSPRINT file?
         BNE   EOG$SI                     Yes, initialize reg msg
         LA    R1,RECOUT                  Locate WTO work area
         L     R14,=V(PDSR$C1)            -> Constants CSECT
         MVC   0(C_WTOL,R1),C_WTO-PDSR$C1(R14) Initialize WTO
         LA    R15,4(R1)                  Bump past WTO flags
         BAS   R14,FM$PRE                 Get message prefix
         B     EOG$SIX
EOG$SI   EQU   *
         BAS   R14,FORMAT_MESSAGE         Initialize message
EOG$SIX  EQU   *
         MVC   0(MSG83L,R15),MSG83-PDSR$MSG(R1) Move in message
         LA    R15,MSG83L(R15)            Bump past it
         BAS   R14,FORMAT_OPEN_ABEND_MSG  Format OPEN error msg
         CLI   0(R8),C'S'                 SYSPRINT file?
         BNE   EOG$ST                     No, regular message
         WTO   ,MF=(E,RECOUT)             Issue WTO message
         MVI   MAXCC,$SEVERE
         B     EXIT
EOG$ST   EQU   *
         BAS   R14,PRINT_SYSPRINT_RECORD
         MVI   MAXCC,$SEVERE
         B     EXIT
*
** DCB ABEND Exit routine: GC26-4013 MVS/XA Data Administration Guide
**                         Chapter 7.
*
E$OPEN   EQU   *
         L     R2,0(R1)                  Get ABEND code
         ST    R2,OX_CODE                Save ABEND code
         MVI   3(R1),4                   Ignore ABEND (for now...)
         BSM   0,R14                     Return to IOS
         EJECT
***********************************************************************
***
**       Process the PDS directory
***
***********************************************************************
         SPACE 2
PROCESS_PDS_DIRECTORY EQU *
         ST    R14,PPD_RA                 Save our return address
*
** Read directory block
*
PPD$GET  EQU   *
         GET   SYSLIB                     Read directory Block
*
** Count directory blocks
*
         L     R14,PPD_DIRBLKS            Get directory block count
         LA    R14,1(R14)                 Increment by 1
         ST    R14,PPD_DIRBLKS            Save it
*
         TM    PPD_FLAG2,$PPD_F2BLKCNT    Just counting blocks?
         BNO   PPD$GDBX                   No, continue
         L     R14,PPD_DIRBLKSU           Get directory block count
         LA    R14,1(R14)                 Increment by 1
         ST    R14,PPD_DIRBLKSU           Save it
         B     PPD$GET                    Get next one
PPD$GDBX EQU   *
*
** Calculate End-of-block
*
         SLR   R14,R14                    Clear register
         ICM   R14,B'0011',0(R1)          Get length of used portion
         LA    R15,0(R14,R1)              Locate end of block
         ST    R15,PPD_EOB                Save for later
         LA    R2,2(R1)                   Bump past length halfword
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**       Process member
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
PPD$MEM  EQU   *
         CLC   0(8,R2),=8X'FF'            End of directory?
         BNE   PPD$LASTX                  No, continue
         OI    PPD_FLAG2,$PPD_F2BLKCNT    Turn on flag
         B     PPD$GET
PPD$LASTX EQU  *
*
** Calculate length of Directory entry
*
         MVC   DOUBLE(1),PDS2INDC-PDS2(R2) Get indicator byte
         NI    DOUBLE,B'00011111'         Turn off unneeded bits
         SLR   R1,R1                      Clear register
         IC    R1,DOUBLE                  Get value
         SLL   R1,1                       Times 2 for user halfwords
         AH    R1,=AL2(PDS2USRD-PDS2)     Add Length of fixed section
         STH   R1,PPD_DIRENTL             Save length of entry
         SPACE 3
*
** If we are doing find member processing see if in library
*
         TM    PPC_IFLAG1,$PPC_IF1FMG     Was it generic?
         BO    PPD$FMG
         CLI   PPC_FML,0                  Doing find member checking?
         BE    PPD$FMX                    No, leave
PPD$FMG  DS    0H
         SLR   R1,R1                      Clear for IC
         IC    R1,PPC_FML                 Get length
         EX    R1,PPD$FMC                 Match?
         BNE   PPD$FMNM                   No, continue
         L     R1,PP_FMCOUNT              Get count
         LA    R1,1(R1)                   Add 1
         ST    R1,PP_FMCOUNT              Save count
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG53L,R15),MSG53-PDSR$MSG(R1) Move in message
         MVC   MSG53N-MSG53(8,R15),PDS2NAME-PDS2(R2)
         BAS   R14,PRINT_SYSPRINT_RECORD  Print message
         B     PPD$FMX
PPD$FMC  CLC   PPC_FM(0),PDS2NAME-PDS2(R2)
PPD$FMNM DS    0H                         No match on member
         TM    PPC_FLAG4,$PPC_F4ONLYF     Only processing FINDMEMs?
         BO    PPD$MB                     Yes, skip this member
PPD$FMX  DS    0H
*
** Initialize record and place member name on it
*
         BAS   R14,CLEAR_RECOUT           Clear for record
         MVC   1+DETMEM-DET(8,R15),PDS2NAME-PDS2(R2)
         L     R1,=V(PDSR$C2)             -> PDSR$C2 CSECT
         TR    1+DETMEM-DET(8,R15),C_TRTABM-PDSR$C2(R1)
*
** Get TTR Information
*
         UNPK  1+DETADDR-DET(7,R15),PDS2TTRP-PDS2(4,R2)
         MVZ   1+DETADDR-DET(6,R15),ZEROS
         TR    1+DETADDR-DET(6,R15),HEXTABLE
         MVI   1+DETADDR-DET+6(R15),C' '
*
** Increment member count
*
         L     R1,PPD_NMEM                Get current number
         LA    R1,1(R1)                   Increment by 1
         ST    R1,PPD_NMEM                Save it
 SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**   Skip a line between systems (First 3 characters)
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
 SPACE 2
         TM    PPC_FLAG1,$PPC_F1NOBREAK   No breaks?
         BO    PPD$NBX                    Yes, skip processing
         CLC   PPD_LSYS(3),ZEROS          First time thru?
         BE    PPD$NB                     Yes, initialize
         CLC   PPD_LSYS(3),PDS2NAME-PDS2(R2) Last system?
         BE    PPD$NBX                    Yes, continue
         MVI   RECOUT,C'0'                Skip a line...
PPD$NB   EQU   *
         MVC   PPD_LSYS(3),PDS2NAME-PDS2(R2) Initialize for this system
PPD$NBX  EQU   *
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**  ISPF processing
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
PPD$ISPF EQU   *
         TM    PPD_FLAG1,$PPD_F1ISPF      Need ISPF stats?
         BNO   PPD$ISPFX                  No, continue
*
         LA    R0,#IS_FORMAT              Option: Format ISPF stats
         LA    R1,SUBRSA                  Locate subroutine RSA
         L     R15,=V(PDSR$IS)            Locate CSECT
         BASR  R14,R15                    Invoke the parse routine
         B     PPD$MPRT
PPD$ISPFX EQU *
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Perform a BLDL to get the PDS directory entry
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
*
** Perform the BLDL
*
         NI    PPD_FLAG1,255-$PPD_F1BLDLF
         XC    PPD_PDS(PPD_PDSL),PPD_PDS  Clear to zeros
         MVC   PPD_PDS_FF(2),=AL2(1)      Number of members found
         MVC   PPD_PDS_LL(2),=AL2(PPD_PDS_ENTRYL) Move in entry length
         MVC   PPD_PDS_ENTRY+(PDS2NAME-PDS2)(8),PDS2NAME-PDS2(R2)
         LA    R3,PPD_PODCB               Locate DCB
         BLDL  (3),PPD_PDS                Perform BLDL
         LR    R3,R15                     Save BLDL return code
*
         TM    PPC_FLAG2,$PPC_F2DUMPBLDL  Option on?
         BNO   PPD$BLDLDX                 No, continue
         MVC   SLACKR(133),RECOUT         Save current record
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG60L,R15),MSG60-PDSR$MSG(R1) Move in message
         MVC   MSG60N-MSG60(8,R15),PDS2NAME-PDS2(R2)
         BAS   R14,PRINT_SYSPRINT_RECORD  Issue error message
         XC    W_AREA(CMXDL),W_AREA       Initialize area
         LA    R15,PPD_PDS                Locate PDS BLDL return area
         LA    R0,PPD_PDSL                Get length of area
         LA    R1,RECOUT+MSGPREL+8        "DA$PDSR-000I    "
         STM   R15,R1,W_AREA+CMXD_ADDRESS-CMXD  Data, Length, Output
         TM    PPC_FLAG4,$PPC_F4TSOVIEW   TSO viewing?
         BO    PPD$BLDLDL
         MVC   W_AREA+CMXD_OUTPUTL-CMXD(2),=AL2(#MXDWIDE)
PPD$BLDLDL DS 0H
         LA    R1,W_AREA                  Locate work area
         L     R15,EP_DA$MXD              -> DA$MXD E.P.A.
         BASSM R14,R15                    Call DA$MXD
         LR    R8,R15                     Save return code
         BAS   R14,PRINT_SYSPRINT_RECORD  Locate print routine
         LTR   R8,R8                      Any more lines to do...
         BNZ   PPD$BLDLDL                 Thank you: May I have another
         MVC   RECOUT(133),SLACKR         Restore record
PPD$BLDLDX DS 0H
*
         LTR   R3,R3                      Successful?
         BZ    PPD$BLDLO                  Yes, continue
         OI    PPD_FLAG1,$PPD_F1BLDLF     BLDL failed!!!!!
*
         MVC   SLACKR(133),RECOUT         Save current record
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG55L,R15),MSG55-PDSR$MSG(R1) Move in message
         LA    R15,MSG55L+1(R15)          Bump past it
         MVC   0(8,R15),PDS2NAME-PDS2(R2) Get member name
         LA    R0,8                       Length of member name
         BAS   R14,LOCATE_FIRST_SPACE     Locate first space
         MVC   0(5,R15),=C', RC='         Insert text
         LA    R15,5(R15)                 Bump past it
         LR    R1,R3                      Get RC
         BAS   R9,EDITFWF                 Edit it
         BAS   R14,PRINT_SYSPRINT_RECORD  Print message
         MVC   RECOUT(133),SLACKR         Restore record
*
         AIF   ('&IHADFARELS' LT '01010100').RCMBDX
         ICM   R8,B'1111',A_PDSRCMD+4
         BZ    PPD$BLDLX
         NI    PDSRCMD_FLAG1-PDSRCMD(R8),255-$PDSRCMD_F1DCB
.RCMBDX  ANOP  ,
         B     PPD$BLDLX
*
PPD$BLDLO DS   0H
         AIF   ('&IHADFARELS' LT '01010100').RCMBOX
         ICM   R8,B'1111',A_PDSRCMD+4
         BZ    PPD$BLDLX
         OI    PDSRCMD_FLAG1-PDSRCMD(R8),$PDSRCMD_F1DCB
         LA    R1,PPD_PODCB               Locate DCB
         ST    R1,PDSRCMD_DCBPTR-PDSRCMD(R8)
         LA    R1,PPD_PDS_ENTRY           Locate Directory entry
         ST    R1,PDSRCMD_DEPTR-PDSRCMD(R8)
PPD$BLDL_UDX DS 0H
.RCMBOX  ANOP  ,
PPD$BLDLX DS   0H
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Translator/history reports via PDSRCM
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
         AIF   ('&IHADFARELS' LT '01010100').RCMMX
         ICM   R8,B'1111',A_PDSRCMD+4
         BZ    PPD$CM$CSX
         OI    PPD_FLAG2,$PPD_F2NBLINFO    Default that we need it
         ST    R2,PDSRCMD_PDS2-PDSRCMD(R8) Save PDS member location
*
** Get member name into the proper format: AL2(length),C'name'
*
         LA    R1,PDS2NAME+1-PDS2(R2)
         LA    R0,L'PDS2NAME-1
         LA    R14,1
PPD$CM$MNL DS  0H
         CLI   0(R1),C' '
         BE    PPD$CM$MNLX
         LA    R14,1(R14)
         LA    R1,1(R1)
         BCT   R0,PPD$CM$MNL
PPD$CM$MNLX DS 0H
         STH   R14,PDSRCMD_MODNAME-PDSRCMD(R8)
         MVC   PDSRCMD_MODNAME+2-PDSRCMD(8,R8),PDS2NAME-PDS2(R2)
         MVC   PDSRCMD_ALIAS-PDSRCMD(2,R8),=C'  '
         TM    PDS2INDC-PDS2(R2),PDS2ALIS
         BNO   PPD$CM$ALIASX
         MVC   PDSRCMD_ALIAS-PDSRCMD(2,R8),=C'-A'
PPD$CM$ALIASX DS 0H
*
** Call PDSRCM to produce the report(s)
*
         MVI   PDSRCMD_CALLT-PDSRCMD(R8),$PDSRCMD_CT_MEM
         LR    R1,R8
         L     R15,=V(PDSRCM)
         BASR  R14,R15
*
** Update the REPORT fields on the current output record for this
** member with information gleaned from PDSRCM.
*
         ICM   R8,B'1111',A_PDSRCMD+4     Locate area
         LA    R15,RECOUT+1
*
         ICM   R1,B'1111',PDSRCMD_CSECTS-PDSRCMD(R8)
         BZ    PPD$CM$CSCX
         CVD   R1,DOUBLE
         MVC   DET_LCSECT+2-DET(6,R15),=X'40,20,20,20,20,20'
         ED    DET_LCSECT+2-DET(6,R15),DOUBLE+5
PPD$CM$CSCX DS 0H
*
         L     R1,PDSRCMD_MZAPCNT-PDSRCMD(R8)
         CVD   R1,DOUBLE
         MVC   DET_LZAP-DET(4,R15),EDPAT4 Get edit pattern
         ED    DET_LZAP-DET(4,R15),DOUBLE+6 Edit zap count
*
         ICM   R8,B'1111',PDSRCMD_BINDER-PDSRCMD(R8)
         BZ    PPD$CM$CSX
         NI    PPD_FLAG2,255-$PPD_F2NBLINFO
         USING IDB_ENTRY,R8
         TM    PPC_FLAG4,$PPC_F4NTRANID          Don't translate PID?
         BO    PPD$CM$CSTLX                      Yes, just insert PID
         L     R1,=V(PDSR$TRT)                   Locate CSECT
         LA    R1,T_LINKT-PDSR$TRT(R1)           Locate table
         LA    R0,T_LINKTN                       Get number of entries
PPD$CM$CSTL DS 0H
         CLC   IDB_BINDER_ID(L'TLT_ID),TLT_ID-TLT(R1)  PID match?
         BE    PPD$CM$CSTLF                      Yes, continue
         LA    R1,TLTL(R1)                       No, bump to next entry
         BCT   R0,PPD$CM$CSTL                    ..and process it
PPD$CM$CSTLX DS 0H
         MVC   DET_LTNAME-DET(10,R15),IDB_BINDER_ID Insert PID
         B     PPD$CM$CSTX                       Continue
PPD$CM$CSTLF DS 0H
         MVC   DET_LTNAME-DET(L'TLT_NAME,R15),TLT_NAME-TLT(R1)
PPD$CM$CSTX DS 0H
*
         LA    R14,DET_LTD_DATE-DET(R15)
         ST    R14,EJ_ODGEUR11A_STR
         LA    R14,IDB_DATE_BOUND
         ST    R14,W_IDJULC7_STR
         LA    R14,RECOUT+1+DET_LTD_DOW-DET
         ST    R14,EJ_ODDOW3A_STR
         L     R1,=V(PDSR$C1)
         MVC   W_IDJULC7(C_IDJULC7L),C_IDJULC7-PDSR$C1(R1)
         MVC   EJ_ODDOW3A(C_ODDOW3AL),C_ODDOW3A-PDSR$C1(R1)
         MVC   EJ_ODGEUR11A(C_ODGEUR11AL),C_ODGEUR11A-PDSR$C1(R1)
         TM    PPC_IFLAG1,$PPC_IF1DATEISO ISO format?
         BO    PPD$CM$CSTE$CDISO
         TM    PPC_IFLAG1,$PPC_IF1DATEUS  United States format?
         BNO   PPD$CM$CSTE$CDISOX         Use default of "European"
         MVI   EJ_ODGEUR11A_TYPE+1,$DA#DATE_ODGUS Make Gregorian US
         MVI   EJ_ODGEUR11A_STRL,$DA#DATE_ODGUS10 Set length
         B     PPD$CM$CSTE$CDISOX
PPD$CM$CSTE$CDISO DS 0H
         MVI   EJ_ODGEUR11A_TYPE+1,$DA#DATE_ODISO Make ISO
         MVI   EJ_ODGEUR11A_STRL,$DA#DATE_ODISO10 Set length
PPD$CM$CSTE$CDISOX DS 0H
         DA#SMODE 31                      Must be in 31 bit mode
         L     R15,EP_DA$DATE             Locate EPA of DA$DATE routine
         CALL  (15),(W_IDJULC7,EJ_ODGEUR11A,EJ_ODDOW3A),               @
               VL,MF=(E,PARMLIST)
         LTR   R15,R15
         BZ    PPD$CM$CSTEJX
         MVC   DET_LTD_DATE-DET(4,R15),IDB_DATE_BOUND Get "ccyy"
         MVI   DET_LTD_DATE+4-DET(R15),C'.'
         MVC   DET_LTD_DATE+5-DET(3,R15),IDB_DATE_BOUND+4
PPD$CM$CSTEJX DS 0H
         DA#SMODE 24                      Back to 24 bit mode
*
         DROP  R8
PPD$CM$CSX DS  0H
.RCMMX   ANOP  ,
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Issue an MVS LOAD against the module:
** - EyeCatcher report
** - COBOL CICS report
** - Ensure executable modules
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
         TM    PPC_FLAG3,$PPC_F3LOADMOD
         BNO   PPD$NLOAD
*
** Load the module into storage
*
         LA    R8,SYSLIB                  Locate DCB
         TM    PPD_FLAG1,$PPD_F1BLDLF     BLDL failed?
         BO    PPD$LOAD_EP                Yes, can't use BLDL dir ent
         LOAD  DE=PPD_PDS_ENTRY,          Load module into V/S         @
               DCB=(8),                   ..Only use the one from here @
               ERRET=PPD$LE00             ..Catch LOAD errors
         B     PPD$LOAD_EPX
PPD$LOAD_EP DS    0H
         LOAD  EPLOC=PDS2NAME-PDS2(R2),   Load module into V/S         @
               DCB=(8),                   ..Only use the one from here @
               ERRET=PPD$LE00             ..Catch LOAD errors
PPD$LOAD_EPX DS 0H
         LR    R9,R0                      Save EPA of module
*
** Determine the length of the module
*
         AIF   (NOT D'CVTH4430).CSVQ1X
         L     R14,CVTPTR
         TM    CVTOSLV0-CVTMAP(R14),CVTH4430 ESA 4.3 or higher?
         BO    PPD$CSVQ                   Yes, always do CSVQUERY...
.CSVQ1X  ANOP  ,
         ICM   R1,B'1000',ZEROS           Turn off authorization bit
         SLR   R0,R0                      Clear register for divide
         M     R0,=F'8'                   Multiply to get length in dw
         LR    R8,R1                      Save length
         B     PPD$CSVQX                  and leave
PPD$CSVQ DS    0H
         AIF   (NOT D'CVTH4430).CSVQ2X
         ST    R9,DOUBLE2
         CSVQUERY INADDR=DOUBLE2,         Get module info by addr      @
               OUTLENGTH=DOUBLE,          ..Get length to here         @
               MF=(E,PARMLIST)            ..Execute parmlist
         LTR   R15,R15
         BZ    PPD$CSVQO
         LR    R3,R15
         MVC   SLACKR(L'RECOUT),RECOUT    Save current record
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG56L,R15),MSG56-PDSR$MSG(R1) Move in message
         LA    R15,MSG56L+1(R15)          Bump past it
         MVC   0(8,R15),PDS2NAME-PDS2(R2) Get member name
         LA    R0,8                       Length of member name
         BAS   R14,LOCATE_FIRST_SPACE     Locate first space
         MVC   0(5,R15),=C', RC='         Insert text
         LA    R15,5(R15)                 Bump past it
         LR    R1,R3                      Get RC
         BAS   R9,EDITFWF                 Edit it
         BAS   R14,PRINT_SYSPRINT_RECORD  Print message
         MVC   RECOUT(L'RECOUT),SLACKR
         LA    R1,4
         ST    R1,DOUBLE
PPD$CSVQO DS   0H
         L     R8,DOUBLE                  Obtain module length
.CSVQ2X  DS    0H
PPD$CSVQX DS   0H
*
** COBOL CICS report processing
*
         TM    PPC_FLAG3,$PPC_F3COBCRPT   Doing it?
         BNO   PPD$LCOBCX                 No, continue
         LA    R15,SLACKR                 Locate to output record
         BAS   R14,CR$PTR                 Clear recout to blanks
         LA    R3,SLACKR                  Locate output record
*-R2=PDS R3=Output R8=Module Length R9=Module start
         L     R15,=V(PDSR$COC)           Locate routine
         BASR  R14,R15
         CLI   COBCR_ERROR-COBCR(R3),C'E' Found an error?
         BNE   PPD$LCOBCX                 No, continue
         MVC   COBCR_MEMBER-COBCR(8,R3),PDS2NAME-PDS2(R2)
         TM    PDS2INDC-PDS2(R2),PDS2ALIS Alias?
         BNO   PPD$LCOBC_AX
         MVC   COBCR_ALIAS-COBCR(2,R3),=C'-A'
PPD$LCOBC_AX DS 0H
* Note: The WORKDS area went over 4096 bytes so we have to do this
*       kludgy code to reference SLACKR+55
         LA    R1,SLACKR                  Locate to last field
         LA    R1,55(R1)
         MVC   0(44,R1),AREAJFCB+JFCBDSNM-INFMJFCB Get DSN
*
         ICM   R1,B'1111',PPD_NUMCOBCE    Get current number
         BNZ   PPD$LCOBCB
* Note: The WORKDS area went over 4096 bytes so we have to do this
*       kludgy code to reference SLACKR2
         LA    R4,SLACKR                  Locate to last field
         LA    R4,L'SLACKR(R4)            Locate to next field
*
         MVI   0(R4),C' '                 Get blank
         MVC   1(132,R4),0(R4)            ..Propagate it
         L     R3,=V(PDSR$C2)             -> PDSR$C2 CSECT
         MVC   1(C_COBCDL,R4),C_COBCD-PDSR$C2(R3)
         PUT   COBCRPT,(4)                Put out record
         MVI   0(R4),C' '                 Get blank
         MVC   1(132,R4),0(R4)            ..Propagate it
         PUT   COBCRPT,(4)                Put out record
         L     R1,PPD_NUMCOBCE            Get current number
PPD$LCOBCB DS 0H
         LA    R1,1(R1)                   Increment by 1
         ST    R1,PPD_NUMCOBCE            Save new number
         PUT   COBCRPT,SLACKR             Put out record
PPD$LCOBCX DS 0H
*
** Eye-Catcher report processing
*
         TM    W_FLAG1,$W_F1DFSMS         We are DFSMS/MVS?
         BO    PPD$LECX                   Yes, we do this in PDSRCM
         TM    PPC_FLAG3,$PPC_F3ECRPT     Doing it?
         BNO   PPD$LECX                   No, continue
         LA    R1,SUBRSA                  Locate to work area
         LA    R3,SLACKR                  Locate output record
         LA    R0,0                       No CSECT - Main module
*-R0=CSECT R1=SUBRSA R2=PDS2 R3=Output R8=Module Length R9=Module start
         L     R15,=V(PDSR$EC)            Locate routine
         BASR  R14,R15                    Call Eyecatcher routine
         PUT   ECRPT,SLACKR               Put out record
PPD$LECX DS    0H
*
** Delete the module from storage
*
         DELETE EPLOC=PDS2NAME-PDS2(R2)
         B     PPD$NLOAD
*
** Error: Module could not be loaded
*
PPD$LE00 EQU   *
         ST    R1,PPD_ABEND               Save ABEND code
         ST    R15,PPD_ABENDR             Save reason code
         L     R1,PPD_NLERR               ----+
         LA    R1,1(R1)                       | Increment counter
         ST    R1,PPD_NLERR               ----+
         OI    PPD_FLAG2,$PPD_F2LOADERR Indicate load error
PPD$NLOAD EQU  *
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**   Load Module TTR, EPA, size and attributes
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
         LA    R0,#LMF_FORMAT             Option: Create headings
         LA    R1,SUBRSA                  Locate subroutine RSA
         L     R15,=V(PDSR$LMF)           Locate CSECT
         BASR  R14,R15                    Invoke the parse routine
*
** Process the member
*
         MVC   PPD_TTR(3),PDS2TTRP-PDS2(R2) Save TTR address for point
         TM    W_FLAG1,$W_F1DFSMS         Are we DFSMS/MVS?
         BNO   PPD$LOADS                  No, always do it
         TM    PPD_FLAG2,$PPD_F2NBLINFO
         BO    PPD$LOADS                  No, always do it
         CLC   W_DFARELS(4),=X'01010100'  DFSMS/MVS?
         BH    PPD$LOADX                  Yes, use DFSMS always
PPD$LOADS DS   0H
         BAS   R14,PROCESS_LOAD_MODULE    Process the member
PPD$LOADX EQU  *
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Call for flatout processing - need member record
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
         TM    PPC_FLAG4,$PPC_F4FLATOUT   Doing //FLATOUT processing?
         BNO   PPD$FOX
         LA    R0,#FLATOUT_Member         Invocation: Member
         LA    R1,SUBRSA                  Locate subroutine RSA
         L     R15,=V(PDSRCMFM)           Locate CSECT
         BASR  R14,R15                    Invoke the flatout routine
PPD$FOX  DS    0H
 SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Check for SYNAD (I/O) errors while reading the member
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
 SPACE 2
         TM    PPD_FLAG2,$PPD_F2SYNAD     Error found on SYSMEM file?
         BNO   PPD$SYNADX                 No, continue
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG25L,R15),MSG25-PDSR$MSG(R1) Move in message
         LA    R15,MSG25L(R15)            Bump past message
         MVC   0(8,R15),PDS2NAME-PDS2(R2) Get member name
         LA    R0,8                       Max length of member
         BAS   R14,LOCATE_FIRST_SPACE     Locate first space in name
         MVI   0(R15),C':'                Insert delimiter
         MVC   2(78,R15),SYNADMSG         Get SYNAD error message
         BAS   R14,PRINT_SYSPRINT_RECORD  Print message
         MVI   LASTCC,$SEVERE             Set condition code
PPD$SYNADX EQU *
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Print the report detail record
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
PPD$MPRT EQU   *
*
** Duplicate and Member XREF processing
*
         TM    PPC_FLAG1,$PPC_F1MEMXREF   Member XREF?
         BO    PPD$MPRT_CFDS              Yes, do it
         TM    PPC_FLAG1,$PPC_F1CHKDUP    Check for duplicates?
         BNO   PPD$MPRT_CFDX              No, continue
PPD$MPRT_CFDS  EQU *
         CLI   SR_INIT,0                  Already filled in common?
         BNE   PPD$MPRT_CFDKX             Yes, continue
         MVC   SR_DDNAME(16),PP_PDDN
         MVC   SR_DSN(44),AREAJFCB+(JFCBDSNM-INFMJFCB)
         MVC   SR_VOLSER(6),AREAJFCB+(JFCBVOLS-INFMJFCB)
         MVC   SR_NLIB(2),PP_NLIBS+2      Fill in library number
PPD$MPRT_CFDKX EQU *
         MVI   RECOUT,C' '                Make FBA byte space
         MVC   SR_MEMBER(8),RECOUT+1+(DETMEM-DET)  Get member name
         PUT   WRKFILE1,SORTREC           Put record out
PPD$MPRT_CFDX  EQU *
*
** Just print record?
*
         TM    PPC_FLAG1,$PPC_F1NODET     Printing detail records?
         BO    PPD$MPRT_NDX               No, continue
         BAS   R14,PRINT_REPORT_RECORD    Print detail line
PPD$MPRT_NDX EQU *
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Directory dump
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
         TM    PPC_FLAG2,$PPC_F2DUMPDIRE  Printing Directory entry?
         BNO   PPD$DIREX                  No, continue
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG61L,R15),MSG61-PDSR$MSG(R1) Move in message
         BAS   R14,PRINT_SYSPRINT_RECORD  Issue error message
*
         XC    W_AREA(CMXDL),W_AREA       Initialize area
         LR    R15,R2                     Locate directory entry
         LH    R0,PPD_DIRENTL             Get length of directory ent.
         LA    R1,RECOUT+MSGPREL+8        "DA$PDSR-000I    "
         STM   R15,R1,W_AREA+CMXD_ADDRESS-CMXD  Data, Length, Output
         TM    PPC_FLAG4,$PPC_F4TSOVIEW   TSO viewing?
         BO    PPD$DIREL
         MVC   W_AREA+CMXD_OUTPUTL-CMXD(2),=AL2(#MXDWIDE)
PPD$DIREL EQU  *
         LA    R1,W_AREA                  Locate work area
         L     R15,EP_DA$MXD              -> DA$MXD E.P.A.
         BASSM R14,R15                    Call DA$MXD
         LR    R8,R15                     Save return code
         BAS   R14,PRINT_SYSPRINT_RECORD  Locate print routine
         LTR   R8,R8                      Any more lines to do...
         BNZ   PPD$DIREL                  Thank you: May I have another
PPD$DIREX EQU  *
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Check for member name with non-Standard characters
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
         LA    R15,SLACKR                 Locate slack area
         MVC   0(8,R15),PDS2NAME-PDS2(R2) Get member name
         MVI   8(R15),C' '                Ensure delimiter is not there
         BAS   R14,ENSURE_PRINTABLE_MEMNAME Ensure good member name
         CLI   8(R15),C'/'                Found an invalid member name?
         BNE   PPD$UPRTX                  No, continue
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG40L,R15),MSG40-PDSR$MSG(R1) Move in message
         LA    R15,MSG40L+1(R15)          Bump past it
         MVC   0(#EPML,R15),SLACKR        Get whole string
         LA    R15,#EPML+1(R15)           bump past it
         MVC   0(7,R15),=C'at TTR='       Insert verbage
         LA    R15,7(R15)                 Bump past it
         UNPK  0(7,R15),PDS2TTRP-PDS2(4,R2) |
         MVZ   0(6,R15),ZEROS               |> Hex convert
         TR    0(6,R15),HEXTABLE            |
         MVI   6(R15),C' '                Fix byte after convert
         BAS   R14,PRINT_SYSPRINT_RECORD  Print message
PPD$UPRTX EQU  *
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Check for Load error
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
         TM    PPD_FLAG2,$PPD_F2LOADERR
         BNO   PDD$MPLEX
         BAS   R14,FORMAT_MESSAGE         Initialize the message area
         MVC   0(MSG30L,R15),MSG30-PDSR$MSG(R1) Move in message
         LA    R15,MSG30L(R15)
         MVC   0(8,R15),PDS2NAME-PDS2(R2)
         LA    R0,8
         BAS   R14,LOCATE_FIRST_SPACE
         MVC   0(9,R15),=C', ABEND=S'
         LA    R15,9(R15)
         UNPK  0(4,R15),PPD_ABEND+2(3)
         MVZ   0(4,R15),ZEROS
         TR    0(4,R15),HEXTABLE
         LA    R15,3(R15)
         MVC   0(16,R15),=C', Reason code is'
         LA    R15,17(R15)
         UNPK  0(9,R15),PPD_ABENDR(5)
         MVZ   0(8,R15),ZEROS
         TR    0(8,R15),HEXTABLE
         MVI   8(R15),C' '
         BAS   R14,PRINT_SYSPRINT_RECORD
         MVI   LASTCC,$WARN
         NI    PPD_FLAG2,255-$PPD_F2LOADERR
PDD$MPLEX EQU  *
 SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Bump to next member/PDS directory block
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
 SPACE 2
PPD$MB   EQU   *
         AH    R2,PPD_DIRENTL             Locate to next entry
         C     R2,PPD_EOB                 End of block?
         BL    PPD$MEM                    No, process next member
         B     PPD$GET                    Yes, read next directory blk
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**       Common Exit from Process_PDS_Directory
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
PPD$X    EQU   *
         L     R14,PPD_RA                 Get return address
         BSM   0,R14                      Leave
         EJECT
***********************************************************************
***
**                     Process Load Module
***
***********************************************************************
         SPACE 2
PROCESS_LOAD_MODULE EQU *
         ST    R14,PLM_RA                 Save return address
*
** Read module record
*
         POINT SYSMEM,PPD_TTR             POINT TO PDS DATA BLOCK
PLM$READ EQU   *
         LA    R1,PLM_DECB                Locate DECB
         XC    DECSDECB-DECB(4,R1),DECSDECB-DECB(R1) Clear ECB
*
         L     R4,PP_PDSBUF+4
         READ  (1),SF,                    GET LOAD MODULE RECORD       @
               SYSMEM,(4),'S',MF=E
         CHECK PLM_DECB                   CHECK FOR ERRORS
*
         TM    PPD_FLAG2,$PPD_F2SYNAD
         BO    PLM$X                      YES, MOVE ON
*
** Check for record type
*
         CLI   0(R4),B'10000000'          CSECT ID record (IDR)?
         BE    IDRREC
*        CLI   0(R4),B'00100000'          CESD?
*        BE    CESD
         TM    0(R4),1                    Is record before a text one?
         BNO   PLM$READ                   No, read next block
*
** End of member found
*
PLM$X    EQU   *
         L     R14,PLM_RA                 Get return address
         BSM   0,R14                      Return to caller
         EJECT ,
***********************************************************************
***
**       CSECT Identification record: IDR
***
***********************************************************************
         SPACE 2
IDRREC   EQU   *
*
** What kind of IDR record?
*
         TM    2(R4),B'00000010'          Linkage Editor?
         BO    IDR$LNK                    Yes, try it out
*
         TM    W_FLAG1,$W_F1DFSMS         Are we DFSMS/MVS?
         BNO   IDR$CX                     No, read other types
         TM    PPD_FLAG2,$PPD_F2NBLINFO   Doing binder/lked info?
         BO    IDR$LX
         CLC   W_DFARELS(4),=X'01010100'  DFSMS/MVS?
         BH    IDR$LX                     Yes, skip other types
IDR$CX   DS    0H
*
         TM    2(R4),B'00000001'          AMASPZAP?
         BO    IDR$ZAP
IDR$LX   DS    0H
         B     PLM$READ                   GET NEXT BLOCK
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** AMASPZAP record
**
**  +--------------------------+     +-------------------------+
**  | 85/07/30    Z5091001     |     | 88/02/11    NO IDENT    |
**  | ......e..Z5091001....... |     | ......h..NO IDENT...... |
**  | 8F0000821EFFFFFFF0000000 |     | 8F0000802DD4CCCDE000000 |
**  | 0A110551F950910010000000 |     | 0A110E84F56094553000000 |
**  +--------------------------+     +-------------------------+
**
**  ......i..Z5181406..i.|Z5183260..i.|Z5186377..i.|Z5186135.. ...
**  8F0002811EFFFFFFF02834EFFFFFFF03834EFFFFFFF00834EFFFFFFF00 ...
**  0A1F0990F951814060E92F951832600D92F951863770992F9518613509 ...
**
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
IDR$ZAP  EQU   *
         SLR   R14,R14                    Clear register
         IC    R14,3(,R4)                 Get number of zaps
         N     R14,=F'63'                 Turn off unneeded bits
         LTR   R14,R14                    Still more than 0
         BZ    PLM$READ                   No, ignore it
         CVD   R14,DOUBLE                 Change to packed decimal
         LA    R1,RECOUT+1                Locate output line
         MVC   DET_LZAP-DET(4,R1),EDPAT4  Get edit pattern
         ED    DET_LZAP-DET(4,R1),DOUBLE+6 Edit zap count
*
** Count total number of modules that have been zapped
*
         L     R1,PPD_NUMZAP              Get current number
         LA    R1,1(R1)                   Increment by 1
         ST    R1,PPD_NUMZAP              Save new number
*
** Zap report - Print member name, date and data if option is set.
*
         TM    PPC_FLAG3,$PPC_F3ZAPRPT    Zap report?
         BNO   PLM$READ                   No, process next record
         LR    R8,R14                     Get count
         LA    R7,5(R4)                   Locate first entry
IDR$ZAPL EQU   *
*-Clear the output record and get the member name
         MVI   SLACKR,C' '                Get Blank
         MVC   SLACKR+1(132),SLACKR       Propagate blank
         LA    R15,SLACKR
         MVC   1(8,R15),PDS2NAME-PDS2(R2) Move in record
         LA    R15,1+8+1(R15)             Bump past member area
*-Output the zap date
         MVC   0(10,R15),=C'Zapped on:'
         LA    R15,11(R15)
         MVI   EJ_IDJULP4_STR,0           This century = 19
         MVC   EJ_IDJULP4_STR+1(3),IDRZAPE_DATE-IDRZAPE(R7)
         ST    R15,EJ_ODDOW3A_STR         Save output area for DOW
         LA    R15,3+1(R15)               Bump past Day of the week
         ST    R15,EJ_ODGEUR11A_STR       Save output area for Greg
         BAS   R9,EDIT_JULIAN             Edit Julian to output
         L     R15,EJ_ODGEUR11A_STR       Get start of Gregorian Date
         LA    R15,11(R15)                Bump past it
         MVC   0(4,R15),=X'40,20,20,20'   Get edit pattern for DOY
         ED    0(4,R15),IDRZAPE_DATE+1-IDRZAPE(R7)
         MVI   0(R15),C'.'
         OI    1(R15),C'0'
         OI    2(R15),C'0'
         LA    R15,5(R15)                 Bump past " DDD "
*-Output the AMASPZAP Data field if found
         MVC   0(5,R15),=C'Data:'
         LA    R15,5(R15)
         LA    R7,IDRZAPE_NAME-IDRZAPE(R7) Locate start of name
IDR$ZAPIL EQU  *
         MVC   0(1,R15),0(R7)             Move byte
         LA    R15,1(R15)                 Bump to next output byte
         LA    R7,1(R7)                   Bump to next input byte
         CLI   0(R7),X'40'                End of name?
         BNL   IDR$ZAPIL                  Yes, continue
         LA    R7,1(R7)                   Bump past zero byte
*-Print record
         PUT   ZAPRPT,SLACKR              Print record
*-Try next zap entry
         BCT   R8,IDR$ZAPL                Do next zap entry
         B     PLM$READ                   Process next record
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Linkage editor record
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
IDR$LNK  EQU   *
         TM    15+2(R4),X'0F'             Ends with valid packed sign?
         BNO   IDR$INVALID_LINKDATE       No, gripe about it
*
** Search for this linkage editor in translator table
*
         LA    R15,RECOUT+1
         TM    PPC_FLAG4,$PPC_F4NTRANID          Don't translate PID?
         BO    IDR$LNK$CSTLX                     Yes, just insert PID
         L     R1,=V(PDSR$TRT)                   Locate CSECT
         LA    R1,T_LINKT-PDSR$TRT(R1)           Locate table
         LA    R0,T_LINKTN                       Get number of entries
IDR$LNK$CSTL DS 0H
         CLC   3(8,R4),TLT_ID-TLT(R1)            PID match?
         BE    IDR$LNK$CSTLF                     Yes, continue
         LA    R1,TLTL(R1)                       No, bump to next entry
         BCT   R0,IDR$LNK$CSTL                   ..and process it
IDR$LNK$CSTLX DS 0H
         MVC   DET_LTNAME-DET(10,R15),3(R4)      Insert PID
         B     IDR$LNK$CSTX                      Continue
IDR$LNK$CSTLF DS 0H
         MVC   DET_LTNAME-DET(L'TLT_NAME,R15),TLT_NAME-TLT(R1)
IDR$LNK$CSTX DS 0H
*
** Format the link date
*
IDR$LNK_DATE EQU *
         MVI   EJ_IDJULP4_STR,0           This century = 19
         MVC   EJ_IDJULP4_STR+1(3),15(R4) Get "YYDDDF"
         LA    R1,RECOUT+1+DET_LTD_DATE-DET
         ST    R1,EJ_ODGEUR11A_STR
         LA    R1,RECOUT+1+DET_LTD_DOW-DET
         ST    R1,EJ_ODDOW3A_STR
         BAS   R9,EDIT_JULIAN             Edit Julian to output
         B     PLM$READ                   Process next one
*
** Link date is invalid or missing
*
IDR$INVALID_LINKDATE EQU *
 L     R1,=V(PDSR$C2)                     -> Constant CSECT
 MVC RECOUT+1+DET_LTD_DATE-DET(L'DET_LTD_DATE),C_BLANKS+1-PDSR$C2(R1)
 MVC RECOUT+1+DET_LTD_DATE-DET+3(9),=C'-Missing-'
 B     PLM$READ                           Read next record
 SPACE 2
         EJECT
***********************************************************************
***
**       Sort file WRKFILE1 into WRKFILE2 based on Sort field
**
**       Input: R1 has sort field string
***
***********************************************************************
         SPACE 2
SORT_FILE DS   0H
         ST    R14,SF_RA                  Save return address
*
** Create SORT control card string
*
         BAS   R14,CLEAR_RECOUT           Clear string area to blanks
         LA    R15,RECOUT+3               Locate SORT statement start
         MVC   0(13,R15),=C'SORT FIELDS=(' Text
         LA    R15,13(R15)                Bump past it
         SLR   R14,R14                    Clear register
         IC    R14,0(R1)                  Get length
         EX    R14,SF$MSF                 Move in sort fields
         LA    R15,1(R14,R15)             Bump past sort fields
         MVC   0(16,R15),=C') OPTION SORTIN=' Text
         LA    R15,16(R15)                Bump past it
         MVC   0(8,R15),=CL8'WRKFILE1'    WRKFILE1 DDNAME
         LA    R0,8                       Max length of DDNAMe
         BAS   R14,LOCATE_FIRST_SPACE     Locate the first space
*
         MVC   0(9,R15),=C',SORTOUT='     Text
         LA    R15,9(R15)                 Bump past it
         MVC   0(8,R15),=CL8'WRKFILE2'    WRKFILE2 DDNAME
         LA    R0,8                       Max length of DDNAME
         BAS   R14,LOCATE_FIRST_SPACE     Locate the first space
*
         LR    R5,R15                     Save location on record
         DEVTYPE =CL8'SORTWK01',DOUBLE    User specified files for us?
         LTR   R15,R15                    Have at least one?
         BZ    SF$DSWX                    Yes, continue
         LR    R15,R5                     Get location on record
         MVC   0(11,R15),=C',DYNALLOC=('  Text
         LA    R15,11(R15)                Bump past it
         MVC   0(8,R15),PPC_WUNIT
         LA    R0,8                       Max length of DDNAME
         BAS   R14,LOCATE_FIRST_SPACE     Locate the first space
         MVC   0(3,R15),=C',3)'           Text
         LA    R15,3(R15)                 Bump past it
*
         MVC   0(8,R15),=C',MSGDDN='      Text
         LA    R15,8(R15)                 Bump past it
         MVC   0(8,R15),=CL8'WRKFILE3'    Sort message DDNAME
         LA    R0,8                       Max length of DDNAME
         BAS   R14,LOCATE_FIRST_SPACE     Locate the first space
         LR    R5,R15
SF$DSWX EQU    *
*
** Calcluate the length of the SORT control statement generated
*
         LA    R14,RECOUT+1               Locate Beginning
         SR    R5,R14                     Length = End - Beginning
         STCM  R5,B'0011',RECOUT          Save length of SORT statement
*
** Invoke the SORT
*
         SLR   R5,R5                      Set pseudo return code
         LA    R1,PARMLIST                Locate parameter list
         LA    R15,RECOUT                 Locate control statements
         ST    R15,0(R1)                  Save it into parm list
         MVC   4(4,R1),=X'FFFFFFFF'       Set end of list
         LINK  EP=SORT,ERRET=SF$LINKE     Link to sort
         LTR   R15,R15                    Okay?
         BNZ   SF$ERR                     Yes, leave
         DEVTYPE =CL8'SORTDIAG',DOUBLE    Get file information
         LTR   R15,R15                    File allocated?
         BZ    SF$ECHO                    Yes, user wants sort info
         B     SF$X                       No, clean sort: leave
*
** Error routines
*
SF$ERR   EQU   *
         LR    R5,R15                     Save return code from Sort
         BAS   R14,CLEAR_RECOUT           Clear record to blanks
         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record
*
         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks
         MVC   0(MSG81L,R15),MSG81-PDSR$MSG(R1) Move in message
         LA    R15,MSG81L+1(R15)          Bump past it
         MVC   0(3,R15),=C'RC='           Move in Text
         LA    R15,3(R15)                 Bump past it
         LR    R1,R5                      Get RC
         BAS   R9,EDITFWF                 Edit it
         BAS   R14,PRINT_SYSPRINT_RECORD  Print sysprint record
         B     SF$ECHO                    Yes, leave
SF$LINKE EQU   *
         ST    R1,DOUBLE                  Save ABEND code
         ST    R15,DOUBLE+4               Save reason code
         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks
         MVC   0(MSG81L,R15),MSG81-PDSR$MSG(R1) Move in message
         LA    R15,MSG81L+1(R15)          Bump past it
         MVC   0(6,R15),=C'ABEND='        Move in Text
         LA    R15,6(R15)                 Bump past it
         LA    R1,DOUBLE                  Point to ABEND code Fullword
         BAS   R9,FORMAT_ABEND            Format the ABEND code
         MVC   0(9,R15),=C', Reason='     Insert text
         LA    R15,9(R15)                 Bump past it
         UNPK  0(9,R15),DOUBLE+4(5)
         MVZ   0(8,R15),ZEROS
         TR    0(8,R15),HEXTABLE
         BAS   R14,PRINT_SYSPRINT_RECORD  Print sysprint record
         LA    R5,20                      Set our return code to NZERO
*
** Echo the sort messages to SYSPRINT
*
SF$ECHO  EQU   *
         BAS   R14,CLEAR_RECOUT           Clear record to blanks
         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record
         L     R1,=V(PDSR$C2)             -> Constants CSECT
         MVC   RECOUT(133),C_EQUALS-PDSR$C2(R1)
         MVC   RECOUT+132-C_SFSTRTL(C_SFSTRTL),C_SFSTRT-PDSR$C1(R1)
         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record
*
         LA    R3,WRKFILE3                Locate DCB work area
         L     R1,=V(PDSR$C1)
         MVC   0(C_DCBIL,R3),C_DCBI-PDSR$C1(R1)
         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'WRKFILE3'
         MVC   PARMLIST(C_LSTIL),C_LSTI-PDSR$C1(R1)
         LA    R2,SF$ELX                  Locate END-OF-FILE area
         STCM  R2,B'0111',DCBEODAD-IHADCB+1(R3) Insert into DCB
         OPEN  ((3),(INPUT)),MF=(E,PARMLIST)
         BAS   R14,CLEAR_RECOUT
SF$EL    EQU   *
         GET   WRKFILE3
         MVC   RECOUT+1(120),1(R1)
         BAS   R14,PRINT_SYSPRINT_RECORD
         B     SF$EL
SF$ELX   EQU   *
         LA    R3,WRKFILE3
         L     R1,=V(PDSR$C1)
         MVC   PARMLIST(C_CLOSEL),C_CLOSE-PDSR$C1(R1)
         CLOSE ((3)),MF=(E,PARMLIST)      Close it
*
         L     R1,=V(PDSR$C2)             -> Constants CSECT
         MVC   RECOUT(133),C_EQUALS-PDSR$C2(R1)
         MVC   RECOUT+132-C_SFENDL(C_SFENDL),C_SFEND-PDSR$C1(R1)
         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record
*
         BAS   R14,CLEAR_RECOUT           Clear record to blanks
         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record
SF$EX    EQU   *
*
** Common exit from Sort_File
*
SF$X     EQU   *
         LR    R15,R5                     Get return code from Sort
         L     R14,SF_RA                  Get return address
         BSM   0,R14                      Return to caller
*
** Executed instructions
*
SF$MSF   MVC   0(0,R15),1(R1)             Get fields
         EJECT
***********************************************************************
***
**       MISC Internal Subroutines
***
***********************************************************************
         SPACE 2
*
** Close file
**
** Input: R3 points to DCB
*
CLOSE_FILE EQU *
         TM    DCBOFLGS-IHADCB(R3),DCBOFOPN Is file open?
         BNO   CF$X
         L     R1,=V(PDSR$C1)
         MVC   PARMLIST(C_CLOSEL),C_CLOSE-PDSR$C1(R1)
         CLOSE ((3)),MF=(E,PARMLIST)      Close it
CF$X     EQU   *
         BSM   0,R9
*
** Edit full word in Register 1 flush at location in Register 15
** with no commas
**
** INPUT: R1 - Register to print
**        R15 - Address to put number
*
EDITNCF  EQU   *
         LTR   R1,R1                      CHECK FOR 0
         BZ    EDITNCF0                   YES, PUT ZERO
         CVD   R1,DOUBLE                  NO, CONVERT TO PACKEC
**
 LA    R1,DOUBLE2+7               LOCATE SIG DIGIT
 MVC   DOUBLE2(8),EDITNCFP
 EDMK  DOUBLE2(8),DOUBLE+4        EDIT AND SAVE PLACE
 LA    R14,DOUBLE2+9              LOCATE LAST POSSIBLE BYTE + 1
**
*        LA    R1,DOUBLE2+14              LOCATE SIG DIGIT
*        MVC   DOUBLE2(15),EDITNCFP
*        EDMK  DOUBLE2(15),DOUBLE+2        EDIT AND SAVE PLACE
*        LA    R14,DOUBLE2+16             LOCATE LAST POSSIBLE BYTE + 1
         SR    R14,R1                     LENGTH = END - START
         BCTR  R14,0                      DECREMENT FOR EX
         EX    R14,EDITNCFM               MOVE EDIT NUMBER TO OUTPUT
         LA    R15,0(R14,R15)             BUMP POINTER PAST NUMBER
         MVI   0(R15),C' '
         BSM   0,R9                       RETURN TO CALLER
EDITNCFM MVC   0(0,R15),0(R1)
EDITNCFP DC    X'40,20,20,20,20,20,20,20,20,20,20,20,20,20,20'
EDITNCF0 DS    0H
         MVI   0(R15),C'0'                PUT IN ZERO
         LA    R15,1(R15)                 BUMP POINTER PAST ZERO
         BSM   0,R9                       RETURN TO CALLER
*
** Edit full word in Register 1 flush at location in Register 15
** INPUT: R1 - Register to print
**        R15 - Address to put number
*
EDITFWF  EQU   *
         LTR   R1,R1                      Check for 0
         BZ    EDITFWF0                   Yes, put zero
         CVD   R1,DOUBLE                  No, convert to packec
         LA    R1,DOUBLE2+14              Locate sig digit
         MVC   DOUBLE2(15),EDITFWFP
         EDMK  DOUBLE2(15),DOUBLE+2       Edit and save place
         LA    R14,DOUBLE2+16             Locate last possible byte + 1
         SR    R14,R1                     Length = end - start
         BCTR  R14,0                      Decrement for ex
         EX    R14,EDITFWFM               Move edit number to output
         LA    R15,0(R14,R15)             Bump pointer past number
         MVI   0(R15),C' '
         BSM   0,R9                       Return to caller
EDITFWFM MVC   0(0,R15),0(R1)
EDITFWFP DC    X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'
EDITFWF0 DS    0H
         MVI   0(R15),C'0'                Put in zero
         LA    R15,1(R15)                 Bump pointer past zero
         BSM   0,R9                       Return to caller
*
** CONVERT BINARY TIME TO PRINT
** INPUT: R1  - TIME TO CONVERT
**        R15 - OUTPUT LOCATION
*
CONVERT_BINARY_TIME EQU *
         SLR   R0,R0                      Clear register
         D     R0,=F'100'                 Divide out 100ths of second
         SLR   R0,R0                      Clear register
         D     R0,=F'60'                  Divide out seconds
         CVD   R0,DOUBLE                  Convert seconds to packed
         UNPK  6(3,R15),DOUBLE+6(2)       Save seconds
         OI    6+2(R15),C'0'              Fix sign byte
         MVI   6(R15),C':'                Colon
         SLR   R0,R0                      Clear register
         D     R0,=F'60'                  Divide out minutes
         CVD   R0,DOUBLE                  Convert minutes to packed
         UNPK  3(3,R15),DOUBLE+6(2)       Save minutes
         OI    3+2(R15),C'0'              Fix sign byte
         MVI   3(R15),C':'                Colon
         CVD   R1,DOUBLE                  Convert minutes to packed
         UNPK  0(3,R15),DOUBLE+6(2)       Save hours
         OI    0+2(R15),C'0'              Fix sign byte
         MVI   0(R15),C' '                Leading space
         BSM   0,R14                      Return to caller
*
** Point Register 15 to the first blank in a string
** Input:  R0  - Maximum length of the string
**         R15 - String
** Output: R15 - First space in the string
*
LOCATE_FIRST_SPACE EQU *
         CLI   0(R15),C' '                Blank?
         BE    LFS$X                      Yes, leave
         LA    R15,1(R15)                 No, bump to next byte
         BCT   R0,LOCATE_FIRST_SPACE      ..Repeat
LFS$X    EQU   *
         BSM   0,R14                      Return to caller
*
** Obtain PDSRCMD data area
*
         AIF   ('&IHADFARELS' LT '01010100').RCMOX
OBTAIN_PDSRCMD DS 0H
         ST    R14,DOUBLE                 Save return address
         ICM   R1,B'1111',A_PDSRCMD+4     Get address of area
         BNZ   OPRC$X                     Already have it, leave
         LA    R0,PDSRCMDL                Need to get it, get length
         GETMAIN R,LV=(0)                 Obtain area below the line
         STM   R0,R1,A_PDSRCMD            Save length and address
         LA    R14,PSRAREA                Locate work area for SYSPRINT
         ST    R14,PDSRCMD_PSRAREA-PDSRCMD(R1) Save it for later
OPRC$X   DS    0H
         L     R14,DOUBLE                 Get return address
         BSM   0,R14                      Return to caller
.RCMOX   ANOP  ,
*
** Format common part of Open ABEND message
**
** Input: R8 has DDNAME
**        DOUBLE - RC from OPEN
**        OX_CODE - OPEN abend code
*
FORMAT_OPEN_ABEND_MSG EQU *
         ST    R14,FOAM_RA                Save return code
         MVC   0(8,R15),0(R8)             Get DD name
         LA    R0,8                       Set DD name length
         BAS   R14,LOCATE_FIRST_SPACE     Find first space
         CLC   DOUBLE(4),ZEROS
         BE    FOAM$RCX
         MVC   0(5,R15),=C', RC='         Get return code text
         LA    R15,5(R15)                 Bump past it
         L     R1,DOUBLE                  Get RC from OPEN
         BAS   R9,EDITFWF                 Edit it
FOAM$RCX EQU   *
         CLC   OX_CODE(4),ZEROS           Did we ABEND?
         BE    FOAM$CX                    No, continue
         MVC   0(9,R15),=C', ABEND=S'     Insert text
         LA    R15,9(R15)                 Bump past it
         UNPK  DOUBLE2(9),OX_CODE(5)      >
         MVZ   DOUBLE2(8),ZEROS           >> Hex translate
         TR    DOUBLE2(8),HEXTABLE        >
         MVC   0(6,R15),DOUBLE2           Get "AAARRR" ABEND/RETURN C.
         MVI   3(R15),C'-'                Insert dash
FOAM$CX  EQU   *
         L     R14,FOAM_RA                Get return code
         BSM   0,R14                      Return to caller
*
** Format ABEND
** Input: R1 - ABEND code
**        R15 - Output for formated ABEND
*
FORMAT_ABEND EQU *
         SLR   R14,R14                    Clear register
         ICM   R14,B'0011',1(R1)          Get ABEND code
         SRA   R14,4                      Clear out user ABEND nibble
         LTR   R14,R14                    Anything there?
         BZ    FA$U                       No, this is a user ABEND
         MVI   0(R15),C'S'                Indicate System ABEND
         UNPK  1(5,R15),1(3,R1)
         MVZ   1(4,R15),ZEROS
         TR    1(4,R15),HEXTABLE
         MVI   4(R15),C' '                Fix byte after hex trans
         LA    R15,4(R15)                 Bump past "S###"
         B     FA$X                       Leave
FA$U     EQU   *
         SLR   R14,R14                    Clear register
         ICM   R14,B'0011',2(R1)          Get User ABEND
         CVD   R14,DOUBLE2                Make number packed
         MVI   0(R15),C'U'                Indicate User ABEND
         UNPK  1(4,R15),DOUBLE2+5(3)      Make number zoned
         OI    1+3(R15),C'0'              Fix Sign byte
         LA    R15,5(R15)                 Bump past "U####"
FA$X     EQU   *
         BSM   0,R9
*
** Initialize message
**
** Output: R1 has PDSR$MSG
*
FORMAT_MESSAGE DS 0H
         LA    R15,RECOUT
         MVI   0(R15),C' '
         MVC   1(L'RECOUT-1,R15),0(R15)
         LA    R15,1(R15)
FM$PRE   DS    0H
         L     R1,=V(PDSR$MSG)            -> PDSR$MSG CSECT
         MVC   0(7,R15),5(R12)            Move in "DA$PDSR"
         MVI   7(R15),C'-'                Insert dash
         LA    R15,MSGPREL(R15)           Bump past "DA$PDSR-"
         BSM   0,R14
MSGPREL  EQU   7+1                        "DA$PDSR-"
*
** Edit input Julian to output area
**
** Keep in sync with IS$EDIT_JULIAN: use same code!!!!!!
*
EDIT_JULIAN EQU *
         L     R1,=V(PDSR$C1)
         MVC   EJ_IDJULP4(C_IDJULP4L),C_IDJULP4-PDSR$C1(R1)
         MVC   EJ_ODGEUR11A(C_ODGEUR11AL),C_ODGEUR11A-PDSR$C1(R1)
         TM    PPC_IFLAG1,$PPC_IF1DATEISO ISO format?
         BO    EJ$CDISO
         TM    PPC_IFLAG1,$PPC_IF1DATEUS  United States format?
         BNO   EJ$CDISOX                  Use default of "European"
         MVI   EJ_ODGEUR11A_TYPE+1,$DA#DATE_ODGUS Make Gregorian US
         MVI   EJ_ODGEUR11A_STRL,$DA#DATE_ODGUS10 Set length
         B     EJ$CDISOX
EJ$CDISO DS 0H
         MVI   EJ_ODGEUR11A_TYPE+1,$DA#DATE_ODISO Make ISO
         MVI   EJ_ODGEUR11A_STRL,$DA#DATE_ODISO10 Set length
EJ$CDISOX DS 0H
         MVC   EJ_ODDOW3A(C_ODDOW3AL),C_ODDOW3A-PDSR$C1(R1)
         DA#SMODE 31                      Must be in 31 bit mode
         L     R15,EP_DA$DATE             Locate EPA of DA$DATE routine
         CALL  (15),(EJ_IDJULP4,EJ_ODGEUR11A,EJ_ODDOW3A),              @
               VL,MF=(E,PARMLIST)
         DA#SMODE 24                      Back to 24 bit mode
         BSM   0,R9
*
** Edit fullword
**  INPUT:  R1  ADDRESS OF FULLWORD
**  OUTPUT: R15 ADDRESS OF OUTPUT (12 BYTES)
*
EDITFW12 EQU   *
         CVD   R1,DOUBLE
         MVC   0(12,R15),=X'40,20,20,20,6B,20,20,20,6B,20,20,20'
         ED    0(12,R15),DOUBLE+3
         BSM   0,R9
*
** Set up Abend exit into DCB at R3
*
SET_ABEND_EXIT EQU *
         LA    R15,OX_EXLST               Locate our EXLST
         STCM  R15,B'0111',DCBEXLST-IHADCB+1(R3)  Save into DCB
         LA    R1,E$OPEN                  Locate our DCB abend routine
         ST    R1,OX_EXLST                Place into EXLST
         OI    OX_EXLST,X'11'             <- DCB exit
         OI    OX_EXLST,X'80'             <- End of list
         XC    OX_CODE(4),OX_CODE         Clear the open abend code
         BSM   0,R14
*
** Check for open abend
*
CHECK_OPEN_ABEND EQU *
         CLC   OX_CODE(4),ZEROS           Open failed?
         BNE   E$OPENG                    Yes, forget it
         LTR   R15,R15                    Open okay?
         BNZ   E$OPENG                    Yes, move on
         BSM   0,R14
*
** Ensure that member (or any 8 byte area) has only valid characters
**
** Input: R15 - 8 byte member name with 18 bytes for hex conversion
**
** Note: We save R2 because TRT *DESTROYS* R2
*
ENSURE_PRINTABLE_MEMNAME EQU *
         ST    R14,EPM_REGS               Save return address
         ST    R2,EPM_REGS+4              Save this register (TRT)
         L     R1,=V(PDSR$C2)             -> Constants CSECT
         TRT   0(8,R15),C_TABPRT-PDSR$C2(R1) Valid characters only?
         BZ    EPM$X                      Yes, leave
         MVI   8(R15),C'/'                Insert delimiter
         UNPK  9(9,R15),0(5,R15)          >>
         MVZ   9(8,R15),ZEROS             >>> Convert first 4 bytes
         TR    9(8,R15),HEXTABLE          >>
         UNPK  9+8(9,R15),4(5,R15)        <<
         MVZ   9+8(8,R15),ZEROS           <<< Convert last 4 bytes
         TR    9+8(8,R15),HEXTABLE        <<
         MVI   9+8+8(R15),C' '            Fix last byte
         L     R1,=V(PDSR$C2)             -> Constants CSECT
         TR    0(8,R15),C_TRTABM-PDSR$C2(R1) Translate to valid...
EPM$X    EQU   *
         L     R2,EPM_REGS+4              Restore this register
         L     R14,EPM_REGS               Get return address
         BSM   0,R14                      Return to caller
#EPML    EQU   8+1+16                     Length of total area
*
** Print record on file SYSPRINT
*
PRINT_REPORT_RECORD EQU *
         TM    W_FLAG2,$W_F2PDSUM         Print Dataset Summary
         BO    PRR$SIMCX
         TM    PPC_FLAG1,$PPC_F1SIMULATE  Stimulate mode?
         BO    PRR$SIMX                   Yes, leave
PRR$SIMCX DS   0H                         Only for simulate exit
         ST    R14,PRR_RA                 Save return address
*
         LA    R1,SUBRSA                  Locate register save area
         L     R15,=V(PDSR$PRR)           Locate sysprint routine
         BASR  R14,R15                    Print Sysprint Record
*
         L     R14,PRR_RA                 Get return address
PRR$SIMX EQU   *                          Only for simulate exit
         BSM   0,R14                      Return to caller
*
** Print record on file SYSPRINT
*
PRINT_SYSPRINT_RECORD EQU *
         ST    R14,PSR_RA                 Save return address
*
         LA    R0,PSRAREA                 Locate work area
         LA    R1,RECOUT   (assumed)      Locate record to print
         L     R15,=V(PDSR$PSR)           Locate sysprint routine
         BASR  R14,R15                    Print Sysprint Record
*
         L     R14,PSR_RA                 Get return address
         BSM   0,R14                      Return to caller
*
** Clear output record to blanks
*
CLEAR_RECOUT  EQU *
         LA    R15,RECOUT                 Locate output record
CR$PTR   EQU   *
         MVI   0(R15),C' '                Get Blank
         MVC   1(L'RECOUT-1,R15),0(R15)   ..Propagate it
         BSM   0,R14                      Return to caller
         EJECT ,
***********************************************************************
***
**              Locate the JFCB from the TIOT entry
**
**  Starting with MVS 2.2 fields in the SWA must be located with the
**  IEFQMREQ or SWAREQ macros.  Fields such as the TIOEJFCB have a SVA
**  (SWA_Virtual_Address) which can not be considered the Virtual
**  Storage address but an index to be used in locating the control
**  Block.
**
**     Note: The SWAREQ macro will only execute/expand on a MVS
**               2.2 system or higher.
**
**     Input: R14 - TIOT entry
**
**     Output: R15 - JFCB address
**             or 0 if the JFCB could not be found...
***
***********************************************************************
 SPACE 2
LOCATE_JFCB EQU *
         DA#SMODE 31                      Must be in 31 bit mode
         LA    R1,W_AREA                  Locate start of EPA
         ST    R1,DOUBLE                  Save address
         XC    0(L'SWAEPAX,R1),0(R1)      Clear area to zeros
         MVC   SWVA-ZB505(3,R1),TIOEJFCB-TIOENTRY(R14) Get SVA
         MVI   SWBLKID-ZB505(R1),SWJFCBID Indicate we need JFCB
         L     R15,=V(PDSR$C1)            Locate constants area
         MVC   PARMLIST(C_SWAREQL),C_SWAREQ-PDSR$C1(R15)
        SWAREQ FCODE=RL,                  Locate JFCB                  @
               EPA=DOUBLE,                ..EPA pointer                @
               UNAUTH=YES,                ..Unauthorized acess         @
               MF=(E,PARMLIST)            ..Execute from here
         LTR   R15,R15                    Successful?
         BNZ   LJ$SWAE                    No, branch to error
         LA    R1,W_AREA                  Locate start of EPA
         L     R15,SWBLKPTR-ZB505(R1)     Locate the control Block
         B     LJ$X                       Return to caller
LJ$SWAE  DS    0H
         SLR   R15,R15                    Indicate no JFCB
LJ$X     DS    0H
         DA#SMODE 24                      Get back to 24 bit mode
         BSM   0,R9                       Return to caller
         EJECT ,
***********************************************************************
***
**       SYNAD Error routine for member reads
***
***********************************************************************
         SPACE 2
SMSYNAD  EQU   *
         STM   R12,R14,PARMLIST
         SYNADAF ACSMETH=BPAM
*
         MVC   SYNADMSG(78),50(R1)      Save error message
         OI    PPD_FLAG2,$PPD_F2SYNAD   Turn on flag
*
         SYNADRLS ,
*
         LM    R12,R14,PARMLIST
         BR    R14
         EJECT
***********************************************************************
***
**       Constants
***
***********************************************************************
         SPACE 2
         DS    0F
ZEROS    DC    X'00,00,00,00,00,00,00,00'
HEXTABLE DC    C'0123456789abcdef'
EDPAT4   DC    X'40,20,20,20'
C_CLDSN  DC    AL1(7),C'DATASET'
C_SFCFD  DA#STR '1,10,CH,A'
*
** Literals - To get more room, more of these LTORG values could
**            be moved to one of the constants CSECTs
*
         PRINT DATA
LTORG    LTORG ,
LTORGL   EQU   *-LTORG
         PRINT NODATA
*
** Calculate length of main CSECT
*
         DS    0D                         End on double word boundry
DA$PDSRL EQU   *-DA$PDSR                  Length of program
DA$PDSRB EQU   (3*4096)-DA$PDSRL          Bytes left addressable
         DS    0D
         DROP  R13,R12,R11,R10
         EJECT
***********************************************************************
***
**   APF library check
**
**   See if the current library is APF authorized by setting the
**   flag PPD_FLAG1,$PPD_F1APF on
**
** Question: Would it be less overhead in MVS 4.3 and higher to
**           just do a REQUEST=QUERY for each dataset instead of
**           obtaining the full list and then looking at it each
**           time?
***
***********************************************************************
         SPACE 2
PDSR$APF CSECT ,
PDSR$APF AMODE 24
PDSR$APF RMODE 24
*
** Standard O/S eyecatcher
*
APF_EC         B    APF_ECL(0,R15)         Bump past EyeCatcher
               DC   AL1(L'APF_ECLIT)       Length of eyecatcher
APF_ECLIT      DC   C'PDSR$APF - APF library check'
               DS   0H
APF_ECL        EQU  *-APF_EC
*
         BAKR  R14,0                      Save registers
         LAE   R12,0(R15,0)               Get base register
         USING PDSR$APF,R12               Set module base
         SAC   0
         SYSSTATE ASCENV=P
         EREG  R0,R1                      Restore Registers 0 and 1
         LR    R13,R1                     Get register save area
         USING SUBRSA,R13
*
** If at MVS ESA SP4.3.0 or higher, we might have a dynamic list
*
         L     R3,CVTPTR                  -> CVT
         L     R3,CVTAUTHL-CVTMAP(R3)     -> Authorized Library Table
         CLC   W_BCPLEVEL(5),=C'SP4.3'    At MVS/ESA 4.3 or higher
         BL    APF$43B                    No, continue
         C     R3,=X'7FFFF001'            Dynamic APF?
         BNE   APF$43O                    No, it's static
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** We are at MVS ESA SP4.3.0 or higher, and we have a dynamic list
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
         AIF   (NOT D'CVTH4430).APF43E    .MVS 4.3 or higher maclib?
         DA#SMODE 31
         TM    W_FLAG1,$W_F1APFDYN        Did we already get it?
         BO    APF$DYNOK
         OI    W_FLAG1,$W_F1APFDYN        Turn on flag that we did
#APFEL EQU L'APFEDSNAME+(APFEDSNAME-APFE)+12  entry len + slack
#APFL  EQU 4096*#APFEL                    Length to get
 L     R0,=AL4(#APFL)                     Get length to acquire
 GETMAIN RU,LV=(0),LOC=(ANY,ANY)
 STM   R0,R1,APF_DYN                      Save Length Address
*
 LR    R4,R1                              Locate to output location
 LA    R5,APF_DYN                         Locate length we got
 CSVAPF REQUEST=LIST,                     Get the APF List             @
               ANSAREA=(4),ANSLEN=(5),    ..Answer area and length     @
               RETCODE=APF_LRETCODE,      ..Return code                @
               RSNCODE=APF_LRSNCODE,      ..Reason code                @
               MF=(E,PARMLIST)           ..Parameter list area
 CLC   APF_LRETCODE,=AL4(CSVAPFRC_OK)    Success?
 BE    APF$DYNOK                         Yes, process data
 CLC   APF_LRETCODE,=AL4(CSVAPFRC_WARN) Warning?
 BNE   APF$DYNOK                         Yes, process data
 NC    APF_LRSNCODE,=AL4(CSVAPFRSNCODEMASK)     Clear high order bits
 CLC   APF_LRSNCODE,=AL4(CSVAPFRSNNOTALLDATARETURNED)      More data?
*BE    ...
APF$DYNOK DS 0H
 L     R3,APF_DYN+4                       Get address of list
 L     R2,APFH#REC-APFHDR(R3)             Get number of entries
 L     R1,APFHOFF-APFHDR(R3)              Offset to first entry
 AR    R3,R1                              Locate to first entry
 LA    R4,AREAJFCB                        Locate JFCB
APF$DYNL DS 0H
 CLC   APFEVOLUME-APFE(6,R3),JFCBVOLS-INFMJFCB(R4) Volumes match?
 BNE   APF$DYNLB
 SLR   R1,R1
 IC    R1,APFEDSLEN-APFE(R3)
 BCTR  R1,0
 EX    R1,APF$DYNLC
 BNE   APF$DYNLB
 OI    PPD_FLAG1,$PPD_F1APF               Indicate APF library
 B     APF$DYNX
*
APF$DYNLB DS 0H
 LH    R1,APFELEN-APFE(R3)                Get length of this entry
 AR    R3,R1                              Locate next entry
 BCT   R2,APF$DYNL                        Repeat
APF$DYNX  DS 0H
 DA#SMODE 24
 B     APF$X
APF$DYNLC CLC  APFEDSNAME-APFE(0,R3),JFCBDSNM-INFMJFCB(R4)
         AGO   .APF43EX
.APF43E  ANOP  ,
         OI    W_FLAG1,$W_F1APFLSTD       Turn on flag that we couldn't
         B     APF$X
.APF43EX ANOP  ,
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Process the static APFLST
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
*
** We are at MVS ESA SP4.3.0 or higher and the APFLST is static
*
APF$43O  DS    0H
         SLR   R2,R2                      Clear register
         ICM   R2,B'0011',0(R3)           Get Library count
         LA    R3,2(R3)                   Bump to first entry
         B     APF$43BX
*
** We are at an MVS before SP4.3.0, it's static (of course)
*
APF$43B  DS    0H
         SLR   R2,R2                      Clear register
         ICM   R2,B'0001',0(R3)           Get library count
*        ICM   R2,B'0011',0(R3)           Get Library count
         LA    R3,2(R3)                   Bump to first entry
APF$43BX DS    0H
*
** Loop thru the Static APF list looking for our dataset
*
         LA    R4,AREAJFCB                Locate JFCB
APF$ALL  DS    0H
         CLC   1(6,R3),JFCBVOLS-INFMJFCB(R4) Volumes match?
         BNE   APF$ALLB                   No, try next entry
         SLR   R1,R1                      Clear register
         IC    R1,0(R3)                   Get length of Entry
* DOUBLE CHECK THE NEXT LINE:
         SH    R1,=AL2(6+1+1)             Subtract Volume and for EX
         EX    R1,APF$LIBC                Dataset match?
         BNE   APF$ALLB                   No, continue
         OI    PPD_FLAG1,$PPD_F1APF       Indicate APF library
         B     APF$X                      Leave
APF$LIBC CLC   1+6(0,R3),JFCBDSNM-INFMJFCB(R4) ** Executed **
APF$ALLB DS    0H
         SLR   R1,R1                      Clear register
         IC    R1,0(R3)                   Get length of Entry
         LA    R3,1(R1,R3)                Bump to next entry
         BCT   R2,APF$ALL                 Repeat
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Exit and constants for PDSR$APF
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
APF$X    DS    0H
         PR    ,                          Return to caller
*
** Literals and end of PDSR$APF routine
*
         LTORG ,                          Literals in PDSR$APF
         DS    0D                         End of PDSR$APF
         DROP  R13,R12
         EJECT
***********************************************************************
***
**   Read BKLIDS file into memory
**
***
***********************************************************************
         SPACE 2
PDSR$RBF CSECT ,
PDSR$RBF AMODE 24
PDSR$RBF RMODE 24
*
** Standard O/S eyecatcher
*
RBF_EC         B    RBF_ECL(0,R15)         Bump past EyeCatcher
               DC   AL1(L'RBF_ECLIT)       Length of eyecatcher
RBF_ECLIT      DC   C'PDSR$RBF - Read BKLIDS file into memory'
               DS   0H
RBF_ECL        EQU  *-RBF_EC
*
         BAKR  R14,0                      Save registers
         LAE   R12,0(R15,0)               Get base register
         USING PDSR$RBF,R12               Set module base
         SAC   0
         SYSSTATE ASCENV=P
         EREG  R0,R1                      Restore Registers 0 and 1
         LR    R13,R1                     Get register save area
         USING SUBRSA,R13
*
** Is the file allocated in the JCL?
*
         DEVTYPE =CL8'BKLIDS',DOUBLE
         LTR   R15,R15
         BNZ   RBF$X
*
** Obtain storage for work area
*
         L     R1,C_BKUSRC                Get number to read in
         MH    R1,=AL2(BKLEL)             Get number to read in
         LA    R1,BKLHL(R1)               Add for header
         LR    R0,R1
         GETMAIN RU,LV=(0)                Obtain storage
         ST    R1,RBF_PTR                 Save address of area
         LR    R8,R1                      Get start of table
         MVC   BKLH_ID-BKLH(8,R8),=CL8'BKLIDST'
         ST    R0,BKLH_LEN-BKLH(R8)       Save length of area
*
** Open the file for input
*
         LA    R3,BKLH_DCB-BKLH(R8)       Locate DCB
         L     R1,=V(PDSR$C1)
         MVC   0(C_DCBVIL,R3),C_DCBVI-PDSR$C1(R1) Get DCB constant
         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'BKLIDS'
         LA    R2,RBF$EOF                 Locate End-of-File
         STCM  R2,B'0111',DCBEODAD-IHADCB+1(R3) Insert into DCB
         MVC   PARMLIST(C_LSTIL),C_LSTI-PDSR$C1(R1) Get parm list
         OPEN  ((3),(INPUT)),                                          @
               MF=(E,PARMLIST)            Open BKLIDS file
*
** Read records
*
         LA    R8,BKLHL(R8)               Start of entries
         L     R9,C_BKUSRC                Set number of users
         SLR   R6,R6                      Get number used
RBF$RR   EQU   *
         GET   (3)                        Read Record
         LR    R7,R1                      Save address
         MVC   BKLE_USER-BKLE(L'LIDLID,R8),LIDLID-LIDREC+4(R7)
         MVC   BKLE_NAME-BKLE(L'LIDNAME,R8),LIDNAME-LIDREC+4(R7)
         LA    R6,1(R6)                   Increment count
         LA    R8,BKLEL(R8)
         BCT   R9,RBF$RR
*-We could print an overflow message here like the following:
*        BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX
*        MVC   0(MSG12L,R15),MSG12
*        LA    R15,MSG12L+1(R15)
*        L     R1,C_BKUSRC
*        BAS   R9,EDITFWF
*        MVC   1(9,R15),=C'were used'
*        BAS   R9,PRINT_SYSPRINT_RECORD
*        SLR   R9,R9                      Number unused is zero
*
** End of file on BKLids file
*
RBF$EOF  EQU   *
         L     R1,RBF_PTR                 Locate header
         ST    R6,BKLH_USERC-BKLH(R1)     Save number of users
*
         L     R1,=V(PDSR$C1)
         MVC   PARMLIST(C_CLOSEL),C_CLOSE-PDSR$C1(R1)
         CLOSE ((3)),MF=(E,PARMLIST)      Close it
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Exit and constants for PDSR$RBF
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
RBF$X    DS    0H
         PR    ,                          Return to caller
*
** Literals and end of PDSR$RBF routine
*
         DS    0F
C_BKUSRC DC    AL4(#BKUSERS)          Max number of users considered
         LTORG ,                          Literals in PDSR$RBF
         DS    0D                         End of PDSR$RBF
         DROP  R13,R12
         EJECT
***********************************************************************
***
**   Print Report Record
***
***********************************************************************
         SPACE 2
PDSR$PRR CSECT ,
PDSR$PRR AMODE 24
PDSR$PRR RMODE 24
*
** Standard O/S eyecatcher
*
PRR_EC         B    PRR_ECL(0,R15)         Bump past EyeCatcher
               DC   AL1(L'PRR_ECLIT)       Length of eyecatcher
PRR_ECLIT      DC   C'PDSR$PRR - Print Report Record'
               DS   0H
PRR_ECL        EQU  *-PRR_EC
*
         BAKR  R14,0                      Save registers
         LAE   R12,0(R15,0)               Get base register
         USING PDSR$PRR,R12               Set module base
         SAC   0
         SYSSTATE ASCENV=P
         EREG  R0,R1                      Restore Registers 0 and 1
         LR    R13,R1                     Get register save area
         USING SUBRSA,R13
*
         TM    PPC_FLAG1,$PPC_F1DATONLY   Data only/No headings?
         BO    PRR$TITLEX                 Yes, leave
         SLR   R1,R1                      Clear register
         LH    R1,PRR_LC                  Get line count
         BAS   R14,PRR$INC_LC             Increment line count
         TM    PPD_FLAG1,$PPD_F1NEWHEAD   Need new headings?
         BNO   PRR$INCX                   No, continue
         AH    R1,=H'4'                   Max number for headings
PRR$INCX EQU   *
*
         CLM   R1,B'0011',PPC_LINECNT     Need Heading?
         BH    PRR$TITLE                  No, continue
         STH   R1,PRR_LC                  Save line count
*
         TM    PPD_FLAG1,$PPD_F1NEWHEAD   Need new headings?
         BO    PRR$NH                     Yes, do them
         B     PRR$TITLEX                 No, bypass titles
*
PRR$TITLE EQU  *
         MVC   PRR_LC(2),=AL2(5)          Reset line count
         LA    R15,PRR_TITLE1             Locate title line 1
         CLI   0(R15),0                   First time?
         BNE   PRR$PAGE                   No, don't fill it in
         BAS   R14,PRR$CR                 Clear to spaces
         MVI   0(R15),C'1'                Set FBA to 1
         L     R14,=V(DA$PDSR)            Locate start of main CSECT
         MVC   1(8,R15),5(R14)            Get "DA$PDSR" from DA#ENTER
         MVC   1+8+1(11,R15),W_ODGEUR11_STR
         MVC   125-10(8,R15),W_OTIMES8_STR
         MVC   125(4,R15),=CL4'Page'      Insert text
*
         L     R1,=V(PDSR$C1)             -> PDSR$C1 CSECT
         TM    W_FLAG2,$W_F2PDSUM         Print Dataset Summary?
         BO    PRR$T1DS
         TM    PPD_FLAG1,$PPD_F1MEMXREF   Check Duplicates
         BO    PRR$T1M                    Yes, get it
         TM    PPD_FLAG1,$PPD_F1CHKDUP    Check Duplicates
         BO    PRR$T1D                    Yes, get it
         TM    PPD_FLAG1,$PPD_F1ISPF      ISPF heading?
         BO    PRR$T1S                    Yes, get it
         MVC   54(SUBHEADL,R15),SUBHEAD-PDSR$C1(R1)
         B     PRR$PAGE
PRR$T1DS EQU  *
         MVC   53(SUBHDSL,R15),SUBHDS-PDSR$C1(R1)
         TM    W_FLAG2,$W_F2PDSUM1        Print Dataset Sum: 1st time?
         BNO   PRR$PAGE
         NI    W_FLAG2,255-$W_F2PDSUM1
*
         LA    R15,PRR_LHEAD1
         MVI   0(R15),C' '
         MVC   1(133-1,R15),0(R15)           123456 123456
         MVC   1+DSUME_TRKA-DSUME(14,R15),=C'<---Tracks--->'
         MVC   1+DSUME_MEMBERS-DSUME(6,R15),=C'Member'
         MVC   1+DSUME_RECFM-DSUME(3,R15),=C'REC'
         LA    R15,PRR_LHEAD2
         MVI   0(R15),C' '
         MVC   1(133-1,R15),0(R15)
         MVC   1+DSUME_DDNAME-DSUME(6,R15),=C'DDNAME'
         MVC   1+DSUME_ATTR-DSUME(6,R15),=C'Attrib'
         MVC   1+DSUME_TRKA-DSUME(5,R15),=C'Alloc'
         MVC   1+DSUME_TRKU-DSUME(4,R15),=C'Used'
         MVC   1+DSUME_EXTENTS-DSUME(2,R15),=C'EX'
         MVC   1+DSUME_RECFM-DSUME(3,R15),=C'-FM'
         MVC   1+DSUME_MEMBERS+1-DSUME(5,R15),=C'Count'
         MVC   1+DSUME_DSN-DSUME(13,R15),=C'Data Set Name'
         MVC   1+DSUME_VOL-DSUME(6,R15),=C'Volume'
         LA    R15,PRR_LHEAD3
         MVI   0(R15),C' '
         MVC   1(133-1,R15),0(R15)
         MVC   1+DSUME_DDNAME-DSUME(L'DSUME_DDNAME,R15),PRR_DASHS
         MVC   1+DSUME_ATTR-DSUME(L'DSUME_ATTR,R15),PRR_DASHS
         MVC   1+DSUME_TRKA-DSUME(L'DSUME_TRKA,R15),PRR_DASHS
         MVC   1+DSUME_TRKU-DSUME(L'DSUME_TRKU,R15),PRR_DASHS
         MVC   1+DSUME_EXTENTS-DSUME(L'DSUME_EXTENTS,R15),PRR_DASHS
         MVC   1+DSUME_RECFM-DSUME(L'DSUME_RECFM,R15),PRR_DASHS
         MVC   1+DSUME_MEMBERS-DSUME(L'DSUME_MEMBERS,R15),PRR_DASHS
         MVC   1+DSUME_DSN-DSUME(L'DSUME_DSN,R15),PRR_DASHS
         MVC   1+DSUME_VOL-DSUME(L'DSUME_VOL,R15),PRR_DASHS
         LA    R15,PRR_TITLE1             Locate title line 1
         B     PRR$PAGE
PRR$T1M  EQU  *
         MVC   53(SUBHML,R15),SUBHM-PDSR$C1(R1)
         B     PRR$PAGE
PRR$T1D  EQU  *
         MVC   53(SUBHDL,R15),SUBHD-PDSR$C1(R1)
         B     PRR$PAGE
PRR$T1S  EQU  *
         MVC   59(SUBHSL,R15),SUBHS-PDSR$C1(R1)
PRR$PAGE EQU  *
         L     R1,PRR_PC                  Get page count
         LA    R1,1(R1)                   Increment it by 1
         ST    R1,PRR_PC                  Save it
         CVD   R1,DOUBLE                  Convert it to packed
         MVC   129(4,R15),=X'40,20,20,20' Get edit pattern
         ED    129(4,R15),DOUBLE+6        Edit it
         PUT   REPORT,PRR_TITLE1          Print title line
*
** Print second heading line
*
         TM    W_FLAG2,$W_F2PDSUM         Print Dataset Summary?
         BO    PRR$T2X
         LA    R15,PRR_TITLE2             Locate title line 2
         CLI   0(R15),0                   First time?
         BNE   PRR$T2                     No, line already formated
         BAS   R14,PRR$CR                 Clear to blanks
         TM    PPD_FLAG1,$PPD_F1MEMXREF   Check Duplicates
         BO    PRR$T2                     Yes, get it
         TM    PPD_FLAG1,$PPD_F1CHKDUP    Check Duplicates
         BO    PRR$T2                     Yes, get it
         MVI   PRR_TITLE2,C'0'            Skip a line
         LA    R1,AREAJFCB
         MVC   1(10,R15),=C'File Name:'
         MVC   1+10+1(16,R15),PP_PDDN
#PRR$TC  EQU   (133-24)/2
         LA    R15,PRR_TITLE2+#PRR$TC
         MVC   0(4,R15),=C'DSN='
         MVC   4(44,R15),JFCBDSNM-INFMJFCB(R1)
         LA    R15,PRR_TITLE2+L'PRR_TITLE2-8-6
         MVC   0(8,R15),=C'VOL=SER='
         MVC   8(6,R15),JFCBVOLS-INFMJFCB(R1)
PRR$T2   EQU   *
         PUT   REPORT,PRR_TITLE2
PRR$T2X  EQU   *
*
PRR$NH   EQU   *
         L     R1,=V(PDSR$C2)             -> Constants CSECT
         LA    R0,C_BLANKS-PDSR$C2(R1)    Locate blank line
         PUT   REPORT,(0)                 Print blank line
*
** Print of "logical heading lines" for this type of report
*
         TM    W_FLAG2,$W_F2PDSUM         Print Dataset Summary?
         BO    PRR$OH                     Yes, only need two lines
         TM    PPD_FLAG1,$PPD_F1ISPF      ISPF heading?
         BO    PRR$SPFH                   Yes, get it
PRR$OH   DS    0H
         PUT   REPORT,PRR_LHEAD1
         PUT   REPORT,PRR_LHEAD2
         PUT   REPORT,PRR_LHEAD3
         B     PRR$SPFHX
PRR$SPFH EQU  *
         PUT   REPORT,PRR_IHEAD1
         PUT   REPORT,PRR_IHEAD2
PRR$SPFHX EQU *
*
PRR$TITLEX EQU *
*
** Print detail record
*
         PUT   REPORT,RECOUT              Print record
*
** Return to caller
*
         PR    ,                          Return to caller
*
** Increment Line count
**
** Input: RECOUT - FBA byte
**        R1 - current line count (to be incremented)
*
PRR$INC_LC EQU *
         CLI   RECOUT,C'+'
         BE    PRR$ILCX
         CLI   RECOUT,C'-'
         BE    PRR$ILC3
         CLI   RECOUT,C'0'
         BE    PRR$ILC2
         B     PRR$ILC1
PRR$ILC3 EQU   *
         LA    R1,1(R1)
PRR$ILC2 EQU   *
         LA    R1,1(R1)
PRR$ILC1 EQU   *
         LA    R1,1(R1)
PRR$ILCX EQU   *
         BSM   0,R14
*
** Clear recout to blanks
*
PRR$CR   EQU   *
         MVI   0(R15),C' '                Get Blank
         MVC   1(L'RECOUT-1,R15),0(R15)   ..Propagate it
         BSM   0,R14                      Return to caller
*
** Literals, constants
*
         LTORG ,                          Literals in PDSR$PRR
*
PRR_DASHS DC   44C'-'
*
** End of the CSECT
*
         DS    0D                         End on double word boundry
*
PDSR$PRRL EQU  *-PDSR$PRR                 Length of CSECT
PDSR$PRRB EQU  4096-PDSR$PRRL             Bytes left addressable
*
         DROP  R13,R12
         EJECT
***********************************************************************
***
**   Print SYSPRINT Record
***
***********************************************************************
         SPACE 2
PDSR$PSR CSECT ,
PDSR$PSR AMODE 24
PDSR$PSR RMODE 24
*
** Standard O/S eyecatcher
*
PSR_EC         B    PSR_ECL(0,R15)         Bump past EyeCatcher
               DC   AL1(L'PSR_ECLIT)       Length of eyecatcher
PSR_ECLIT      DC   C'PDSR$PSR - Print SYSPRINT Record'
               DS   0H
PSR_ECL        EQU  *-PSR_EC
*
         BAKR  R14,0                      Save registers
         LAE   R12,0(R15,0)               Get base register
         USING PDSR$PSR,R12               Set module base
         SAC   0
         SYSSTATE ASCENV=P
         EREG  R0,R1                      Restore Registers 0 and 1
         LR    R13,R0                     Save input parmlist address
         LR    R10,R1                     Save input record address
         USING PSRAREA,R13
*
** Print title line if needed
*
         CLC   PSR_LC(2),PPC_LINECNT      Hit max?
         BNH   PSR$HX                     No, continue
*
         LA    R15,PSR_TITLE              Locate title line
         CLI   0(R15),0                   First time thru?
         BNE   PSR$PAGE
         MVI   0(R15),C' '                Get Blank
         MVC   1(L'RECOUT-1,R15),0(R15)   ..Propagate it
         MVI   PSRT_FBA-PSRT(R15),C'1'
         L     R1,=V(DA$PDSR)
         MVC   PSRT_PGM-PSRT(8,R15),5(R1) Get "DA$PDSR"
         MVC   PSRT_D1-PSRT(2,R15),=C'--'
         L     R1,=V(PDSR$C1)
         MVC   PSRT_DESC-PSRT(C_PSRTDL,R15),C_PSRTD-PDSR$C1(R1)
         MVC   PSRT_D2-PSRT(2,R15),=C'--'
         MVC   PSRT_SIDD-PSRT(6,R15),=C'SYSID='
*
         L     R14,CVTPTR
         MVC   PSRT_SID-PSRT(8,R15),CVTSNAME-CVTMAP(R14)
*
         MVC   PSRT_D3-PSRT(2,R15),=C'--'
         MVC   PSRT_TIME-PSRT(8,R15),W_OTIMES8_STR
         MVC   PSRT_DATE-PSRT(11,R15),W_ODGEUR11_STR
         MVC   PSRT_D4-PSRT(2,R15),=C'--'
         MVC   PSRT_PAGE-PSRT(4,R15),=C'Page'
PSR$PAGE EQU   *
         L     R1,PSR_PC                  Get page count
         LA    R1,1(R1)                   Increment it by 1
         ST    R1,PSR_PC                  Save for next time
         CVD   R1,DOUBLE                  Convert to packed
         MVC   PSRT_PAGE+4-PSRT(4,R15),=X'40,20,20,20'
         ED    PSRT_PAGE+4-PSRT(4,R15),DOUBLE+6
         PUT   SYSPRINT,PSR_TITLE
*
         L     R1,=V(PDSR$C2)             -> Constants CSECT
         LA    R0,C_BLANKS-PDSR$C2(R1)    Locate blank line
         PUT   SYSPRINT,(0)               Print blank line
         MVC   PSR_LC(2),=AL2(2)          Reset line count
PSR$HX   EQU   *
         LH    R1,PSR_LC                  Get line count
         BAS   R14,PSR$INC_LC             Increment line count
         STH   R1,PSR_LC                  Save line count
*
** Print the input record
*
         PUT   SYSPRINT,0(R10)
*
** Exit
*
         SLR   R15,R15
         PR    ,                          Return to caller
*
** Increment line count
*
PSR$INC_LC EQU *
         CLI   0(R10),C'+'
         BE    PSR$ILCX
         CLI   0(R10),C'-'
         BE    PSR$ILC3
         CLI   0(R10),C'0'
         BE    PSR$ILC2
         B     PSR$ILC1
PSR$ILC3 EQU   *
         LA    R1,1(R1)
PSR$ILC2 EQU   *
         LA    R1,1(R1)
PSR$ILC1 EQU   *
         LA    R1,1(R1)
PSR$ILCX EQU   *
         BSM   0,R14
*
** Literals and end of PDSR$PSR routine
*
         LTORG ,                          Literals in PDSR$PSR
         DS    0D                         End of PDSR$PSR
         DROP  R12
         DROP  R13
         EJECT ,
***********************************************************************
***
**       Program messages
***
***********************************************************************
         SPACE 2
PDSR$MSG CSECT ,
PDSR$MSG AMODE 24
PDSR$MSG RMODE 24
*
** Standard O/S eyecatcher
*
MSG_EC         B    MSG_ECL(0,R15)         Bump past EyeCatcher
               DC   AL1(L'MSG_ECLIT)       Length of eyecatcher
MSG_ECLIT      DC   C'PDSR$MSG - Messages'
               DS   0H
MSG_ECL        EQU  *-MSG_EC
*
** Messages
*
MSG1     DC    C'001I Execution Begins. Time:'
MSG1L    EQU   *-MSG1
MSG2     DC    C'002I Parameter from EXEC card: '''
MSG2L    EQU   *-MSG2
MSG3     DC    C'003E First invalid parm at column:'
MSG3L    EQU   *-MSG3
MSG4     DC    C'004E Number of invalid parms:'
MSG4L    EQU   *-MSG4
MSG4A    DC    C'(Date format error)'
MSG4AL   EQU   *-MSG4A
MSG5     DC    C'005I Processing DDNames with prefix "'
MSG5L    EQU   *-MSG5
MSG6     DC    C'006I Help information for DA$PDSR:'
MSG6L    EQU   *-MSG6
MSG7     DC    C'007E Mutally exclusive keywords not allowed:'
MSG7L    EQU   *-MSG7
MSG8     DC    C'008E PARM=CALLRACF ignored, this program is not '
         DC    C'APF authorized'
MSG8L    EQU   *-MSG8
*
MSG18    DC    C'018I There were no files found with DDNAME prefix'
MSG18L   EQU   *-MSG18
MSG19    DC    C'019I Processing the current'
MSG19L   EQU   *-MSG19
MSG19N   DC    C', Number of files:'
MSG20    DC    C'020I Processing of file'
MSG20L   EQU   *-MSG20
MSG21    DC    C'021I > VOL=SER='
MSG21L   EQU   *-MSG21
MSG21A   DC    C', catalogued to'
MSG21AL  EQU   *-MSG21A
MSG22    DC    C'022I > Used blocks in directory:'
MSG22L   EQU   *-MSG22
MSG23    DC    C'023E > Dataset not found on VOL=SER='
MSG23L   EQU   *-MSG23
MSG24    DC    C'024E > Dataset is not a PDS'
MSG24L   EQU   *-MSG24
MSG25    DC    C'025E > Error while reading member='
MSG25L   EQU   *-MSG25
MSG26    DC    C'026I > '
MSG26SL  EQU   *-MSG26
MSG26NOM DC    C'Number of members processed:'
MSG26L   EQU   *-MSG26
MSG27    DC    C'027E > SYSIN/SYSOUT datasets not supported'
MSG27L   EQU   *-MSG27
MSG28    DC    C'028E > DUMMY dataset not supported'
MSG28L   EQU   *-MSG28
MSG29    DC    C'029E > TSO terminal allocation not supported'
MSG29L   EQU   *-MSG29
MSG30    DC    C'030E > Load failed for member='
MSG30L   EQU   *-MSG30
MSG31    DC    C'031W > There were'
MSG31L   EQU   *-MSG31
MSG31A   DC    C'modules marked authorized in an unauthorized library'
MSG31AL  EQU   *-MSG31A
MSG31B   DC    C'(Verify LNKAUTH=LNKLST IEAAPFxx)'
MSG31BL  EQU   *-MSG31B
MSG32    DC    C'032I >'      ** Translater **
MSG32L   EQU   *-MSG32
MSG33    DC    C'033E JFCB could not be located'
MSG33L   EQU   *-MSG33
MSG34    DC    C'034E Dynamic Allocation failed: RC='
MSG34L   EQU   *-MSG34
MSG35    DC    C'035I > Number of aliases:'
MSG35L   EQU   *-MSG35
MSG36    DC    C'036W > Orphan:'
MSG36L   EQU   *-MSG36
MSG37    DC    C'037E > Deallocation of concatenated file failed: DD='
MSG37L   EQU   *-MSG37
MSG38    DC    C'038I > Dynamically allocated'
MSG38L   EQU   *-MSG38
MSG38C   DC    C'concatenated file:'
MSG38CL  EQU   *-MSG38C
MSG39    DC    C'039E > Catalog locate failed to dataset, CAMLST RC='
MSG39L   EQU   *-MSG39
MSG40    DC    C'040W > Non-standard characters in member name:'
MSG40L   EQU   *-MSG40
MSG41    DC    C'041E > OPEN of file failed, DDNAME='
MSG41L   EQU   *-MSG41
MSG42    DC    C'042I > Number of modules with standard eyecatchers:'
MSG42L   EQU   *-MSG42
MSG43    DC    C'043E > Non-DASD files are not supported'
MSG43L   EQU   *-MSG43
MSG44    DC    C'044I > Simulate mode: directory not processed'
MSG44L   EQU   *-MSG44
MSG45    DC    C'045I > Hex dump of F1-DSCB + '
MSG45L   EQU   *-MSG45
MSG46    DC    C'046I > Number of zapped modules:'
MSG46L   EQU   *-MSG46
MSG47    DC    C'047I > Number of COBOL modules compiled incorrectly '
         DC    C'for CICS:'
MSG47L   EQU   *-MSG47
MSG48    DC    C'048I '
MSG48A   DC    C'Level of'
MSG48L   EQU   *-MSG48
MSG48B   DC    C'DFSMS/MVS:'
MSG48C   DC    C'(but we won''t use it''s services)'
MSG48D   DC    C'DFP:'
MSG48E   DC    C'- BCP:'
MSG49    DC    C'049I Output file was not allocated, DD='
MSG49L   EQU   *-MSG49
MSG50    DC    C'050E This program was assembled with a '
         DC    C'pre-DFSMS/MVS maclib and the '
MSG50T   DC    C'xxxx'
         DC    C'RPT option is not available'
MSG50L   EQU   *-MSG50
MSG51    DC    C'051I Under DFSMS/MVS, the Zap report '
         DC    C'is included with the HISTRPT option and file output'
MSG51L   EQU   *-MSG51
MSG52    DC    C'052I Option='
MSG52T   DC    CL8' '
         DC    C' was ignored since you specified NOSMS'
MSG52L   EQU   *-MSG52
MSG53    DC    C'053I > Member '
MSG53N   DC    CL8' '
         DC    C' was found in library'
MSG53L   EQU   *-MSG53
MSG54    DC    C'054I Member '
MSG54N   DC    CL8' '
         DC    C' was '
MSG54E   DC    C'found '
MSG54L   EQU   *-MSG54
MSG55    DC    C'055E > BLDL failed for'
MSG55L   EQU   *-MSG55
MSG56    DC    C'056E > CSVQUERY failed for'
MSG56L   EQU   *-MSG56
MSG57    DC    C'057I > This library is APF authorized'
MSG57L   EQU   *-MSG57
MSG58    DC    C'058W > This library is in the LPALST and is not in '
         DC    C'the APFLST'
MSG58L   EQU   *-MSG58
MSG59    DC    C'059W Warning: When the DATE= operand is used in '
         DC    C'SYSIN, it will not be used in all situations, '
         DC    C'recommend placing in PARM card'
MSG59L   EQU   *-MSG59
MSG60    DC    C'060I > Hex dump of BLDL of member='
MSG60N   DS    CL8' '
         DS    C' +'
MSG60L   EQU   *-MSG60
MSG61    DC    C'061I > Hex dump of directory entry +'
MSG61L   EQU   *-MSG61
MSG62    DC    C'062I > Number of allocated tracks='
MSG62L   EQU   *-MSG62
MSG63    DC    C'063I Number of extents in LNKLST datasets:'
MSG63L   EQU   *-MSG63
MSG64    DC    C'064I DD=IVCSECT found allocated and will be used'
MSG64L   EQU   *-MSG64
MSG65    DC    C'065I Conflicting options: IVCSECTx and NIVENDOR '
         DC    C'specified with no //IVCSECT file allocated'
MSG65L   EQU   *-MSG65
*
MSG70    DC    C'070I Processing for'
MSG70L   EQU   *-MSG70
MSG70A   DC    C'Duplicate members'
MSG70AL  EQU   *-MSG70A
MSG70B   DC    C'Member Cross Reference'
MSG70BL  EQU   *-MSG70B
MSG71    DC    C'071I Number of duplicate members:'
MSG71L   EQU   *-MSG71
*
MSG80    DC    C'080E Required program not found:'
MSG80L   EQU   *-MSG80
MSG81    DC    C'081E Sort failed,'
MSG81L   EQU   *-MSG81
MSG82    DC    C'082E Required work file not allocated:'
MSG82L   EQU   *-MSG82
MSG83    DC    C'083E Open to global file failed, DDN='
MSG83L   EQU   *-MSG83
*
MSG90    DC    C'090I File processing complete. Condition code was'
MSG90L   EQU   *-MSG90
MSG91    DC    C'091W Was unable to determine APF attribute because '
         DC    C'this program was assembled with backlevel MVS maclib:'
         DC    C' &MMACLIB'
MSG91L   EQU   *-MSG91
*
** MSG100 - MSG119 reserved for PDSR$IVC processing
*
MSG100   DC    C'100I Vendor CSECT results for all libraries:'
MSG100L  EQU   *-MSG100
MSG102   DC    C'102I > Number of'
MSG102L  EQU   *-MSG102
MSG103   DC    C'103I > Vendor CSECT by type:'
MSG103L  EQU   *-MSG103
MSG104   DC    C'104I   >'
MSG104L  EQU   *-MSG104
MSG110   DC    C'110I > Vendor CSECT results for this library:'
MSG110L  EQU   *-MSG110
MSG111   DC    C'111I   > No Vendor CSECTs were found'
MSG111L  EQU   *-MSG111
MSG112   DC    C'112I   > Number of'
MSG112L  EQU   *-MSG112
MSG113   DC    C'113I   > Vendor module totals:'
MSG113L  EQU   *-MSG113
MSG114   DC    C'114I     > '
MSG114SL EQU   *-MSG114
MSG114C  DC    C'Module: '
MSG114M  DS    XL(L'TVP_PREFIX)
         DC    C' Type: '
MSG114T  DC    CL(#TVPDSL)' '
         DC    C'  '
MSG114E  EQU   *
MSG114L  EQU   *-MSG114
MSG115   DC    C'115I'
MSG115L  EQU   *-MSG115
MSG118   DC    C'118W > Storage area maxed out for'
MSG118L  EQU   *-MSG118
MSG119   DC    C'119I Vendor CSECTs matched from'
MSG119L  EQU   *-MSG119
*
** End of processing messages
*
MSG998   DC    C'998I Number of PDS files processed:'
MSG998L  EQU   *-MSG998
MSG999   DC    C'999I Execution Ends. Maximum Condition code was'
MSG999L  EQU   *-MSG999
*
** End of PDSR$MSG
*
         DS    0D                         End on double word boundry
PDSR$MSGL EQU  *-PDSR$MSG                 Length of CSECT
PDSR$MSGB EQU  4096-PDSR$MSGL             Bytes left addressable
         EJECT ,
***********************************************************************
***
**       Program Constants CSECT #1
***
***********************************************************************
         SPACE 2
PDSR$C1  CSECT ,
PDSR$C1  AMODE 24
PDSR$C1  RMODE 24
*
** Standard O/S eyecatcher
*
C1_EC          B    C1_ECL(0,R15)          Bump past EyeCatcher
               DC   AL1(L'C1_ECLIT)        Length of eyecatcher
C1_ECLIT       DC   C'PDSR$C1  - Constants CSECT 1'
               DS   0H
C1_ECL         EQU  *-C1_EC
*
** Misc constants
*
SUBHEAD  DC    C'Load Library Audit Report'
SUBHEADL EQU   *-SUBHEAD
SUBHS    DC    C'ISPF Statistics'
SUBHSL   EQU   *-SUBHS
SUBHD    DC    C'Duplicate Members Report'
SUBHDL   EQU   *-SUBHD
SUBHM    DC    C'Member Cross Reference'
SUBHML   EQU   *-SUBHM
SUBHDS   DC    C'Dataset Summary'
SUBHDSL  EQU   *-SUBHDS
C_PSRTD  DC    C'The PDS Report Utility v&DAVER.'
C_PSRTDL EQU   *-C_PSRTD
C_PPTTR  DC    C' (Does not point to current version of member)'
C_NMLE   DC    C', LOAD errors='
C_NMNE   DC    C', Non-Executable='
*
C_COLS   EQU   *
         DC    C'....+....1....+....2....+....3'
         DC    C'....+....4....+....5....+....6'
         DC    C'....+....7....+....8....+....9'
*
C_DD_FLATOUT DC CL8'FLATOUT'
C_DD_TRANRPT DC CL8'TRANRPT'
C_DD_HISTRPT DC CL8'HISTRPT'
C_DD_ZAPRPT  DC CL8'ZAPRPT'
C_DD_ECRPT   DC CL8'ECRPT'
C_DD_COBCRPT DC CL8'COBCRPT'
C_DD_SYSLIB  DC CL6'SYSLIB'
C_WUNIT      DC CL8'SYSDA'
*
C_LSTI   OPEN  (*-*,(INPUT)),MF=L
C_LSTIL  EQU   *-C_LSTI
C_LSTO   OPEN  (*-*,(OUTPUT)),MF=L
C_LSTOL  EQU   *-C_LSTO
*
C_DCBI   DCB   DDNAME=C_DCBI,                                          @
               DSORG=PS,MACRF=GL,RECFM=FB,EODAD=*-*
C_DCBIL  EQU   *-C_DCBI
*
C_DCBVI  DCB   DDNAME=C_DCBVI,                                         @
               DSORG=PS,MACRF=GL,RECFM=VB,EODAD=*-*
C_DCBVIL EQU   *-C_DCBVI
C_DCBO   DCB   DDNAME=C_DCBO,                                          @
               DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA
C_DCBOL  EQU   *-C_DCBO
*
C_DCBPO  DCB   DDNAME=DIRPO,DSORG=PO,MACRF=R,RECFM=U
C_DCBPOL EQU   *-C_DCBPO
*
C_DCBM DCB     DDNAME=C_DCBM,                                          @
               DSORG=PS,RECFM=U,                                       @
               MACRF=(RP),EODAD=PLM$X,SYNAD=SMSYNAD
C_DCBML EQU    *-C_DCBM
*
C_DCBD   DCB   DDNAME=C_DCBD,                                          @
               DSORG=PS,MACRF=GL,RECFM=FB,LRECL=256,BLKSIZE=256
C_DCBDL  EQU   *-C_DCBD
         READ  C_DECBM,SF,*-*,,'S',MF=L
C_DECBML EQU   *-C_DECBM
*
C_CLOSE  CLOSE (*-*),MF=L
C_CLOSEL EQU   *-C_CLOSE
C_VTOCS  CAMLST SEARCH,*-*,*-*,*-*
C_VTOCSL EQU   *-C_VTOCS
C_LOCATE CAMLST NAME,*-*,,*-*
C_LOCATEL EQU  *-C_LOCATE
C_SFSTRT DC    C'Start of sort messages'
C_SFSTRTL EQU  *-C_SFSTRT
C_SFEND  DC    C'End of sort messages'
C_SFENDL EQU   *-C_SFEND
C_WTO    WTO   '                                                       @
                                                                       @
                       ',                                              @
               ROUTCDE=(11,14),MCSFLAG=HRDCPY,MF=L
C_WTOL   EQU   *-C_WTO
C_SWAREQ SWAREQ FCODE=RL,EPA=*-*,MF=L
C_SWAREQL EQU *-C_SWAREQ
*
** DA#DATE constants
*
C_IDJULC7  DA#DATE DPE,OPREFIX=C_IDJULC7,                              @
               OSTR=NO,OFLAG=$DA#DATE_ADDR,                            @
               OSTRL=$DA#DATE_IDJULC7,OTYPE=$DA#DATE_IDJULC
C_IDJULP4  DA#DATE DPE,OPREFIX=C_IDJULP4,OSTR=NO,                      @
               OSTRL=$DA#DATE_IDJULP4,OTYPE=$DA#DATE_IDJULP
C_ODGEUR11A DA#DATE DPE,OPREFIX=C_ODGEUR11A,                           @
               OSTR=NO,OFLAG=$DA#DATE_ADDR,                            @
               OSTRL=$DA#DATE_ODGEUR11,OTYPE=$DA#DATE_ODGEUR
C_ODDOW3A  DA#DATE DPE,OPREFIX=C_ODDOW3A,                              @
               OSTR=NO,OFLAG=$DA#DATE_ADDR,                            @
               OSTRL=$DA#DATE_ODDOW3,OTYPE=$DA#DATE_ODDOW
           DS  0F
C_ODGEUR11 DA#DATE DPE,OPREFIX=C_ODGEUR11,OSTR=NO,                     @
               OSTRL=$DA#DATE_ODGEUR11,OTYPE=$DA#DATE_ODGEUR
C_OTIMES8 DA#DATE DPE,OPREFIX=C_OTIMES8,OSTR=NO,                       @
               OSTRL=$DA#DATE_OTIMES8,OTYPE=$DA#DATE_OTIMES
*
** End of PDSR$C1
*
         DS    0D                         End on double word boundry
PDSR$C1L EQU   *-PDSR$C1                  Length of CSECT
PDSR$C1B EQU   4096-PDSR$C1L              Bytes left addressable
         EJECT ,
***********************************************************************
***
**       Program Constants CSECT #2
**
** Note: Had to create a new constants CSECT because code that
**       tried to locate fields started to get a "invalid
**       displacement" error because PDSR$C1 grew past 4096 bytes.
***
***********************************************************************
         SPACE 2
PDSR$C2  CSECT ,
PDSR$C2  AMODE 24
PDSR$C2  RMODE 24
*
** Standard O/S eyecatcher
*
C2_EC          B    C2_ECL(0,R15)          Bump past EyeCatcher
               DC   AL1(L'C2_ECLIT)        Length of eyecatcher
C2_ECLIT       DC   C'PDSR$C2  - Constants CSECT 2'
               DS   0H
C2_ECL         EQU  *-C2_EC
*
C_BLANKS DC    133C' '
C_DASHS  DC    C' ',132C'-'               Output line of dashs
C_EQUALS DC    C' ',132C'='               Equal line delimiter
*
** Headings
*
C_DETMEM       DC    C'Member'
C_DETADDR      DC    C'TTR'
C_DETALIAS     DC    C'Alias'
*
C_DET_IVER     DC    C'VV.MM'
C_DET_ICDATE   DC    C'Created'
C_DET_ILDATE   DC    C'Changed'
C_DET_ISIZE    DC    C'Size'
C_DET_IINIT    DC    C'INIT'
C_DET_IMODL    DC    C'MOD'
C_DET_IUID     DC    C'UserID'
*
C_DET_LTRANT   DC    C'LKED/Binder'
C_DET_LMODE1   DC    C'XA Mode'
C_DET_LZAP1    DC    C'Zap'
C_DET_LSIZE    DC    C'Size'
C_DET_LTD_DATE DC    C'Translator Date'
C_DET_LTNAME   DC    C'Translator Name'
C_DET_LMODEA   DC    C'Addr'
C_DET_LCSECT   DC    C'CSECT'
C_DET_LCSECTN  DC    C'Count'
C_DET_LMODER   DC    C'Res'
C_DET_LATTR    DC    C'Attributes'
C_DET_LZAP     DC    C'Cnt'
C_DET_LSSI     DC    C'SSI'
C_DET_LEPA     DC    C'EPA'
C_DET_LCODE    DC    C'Code'
*
C_DET_IDD      DC    C'File Name'
C_DET_IVOL     DC    C'Volume'
C_DET_IDSN     DC    C'Data Set Name'
C_DET_LDD      DC    C'DDNAME'
C_DET_LVOL     EQU   C_DET_IVOL   -->  DC    C'Volume'
C_DET_LDSN     EQU   C_DET_IDSN   -->  DC    C'Data Set Name'
*
C_COBCD  DC    C'Note: The following modules failed the CICS COBOL '
         DC    C'tests.  Please verify that they used in CICS '
         DC    C'and recompile if needed.'
C_COBCDL EQU  *-C_COBCD
*
** Translate table for detecting members with non-standard characters
**
** Standard: Blank, $, #, @, A-Z, and 0-9 (National Characters)
*
C_TABPRT DC    X'00,01,02,03,04,05,06,07,08,09,0A,0B,0C,0D,0E,0F'
         DC    X'10,11,12,13,14,15,16,17,18,19,1A,1B,1C,1D,1E,1F'
         DC    X'20,21,22,23,24,25,26,27,28,29,2A,2B,2C,2D,2E,2F'
         DC    X'30,31,32,33,34,35,36,37,38,39,3A,3B,3C,3D,3E,3F'
         DC    X'00,41,42,43,44,45,46,47,48,49,4A,4B,4C,4D,4E,4F' space
         DC    X'50,51,52,53,54,55,56,57,58,59,5A,00,5C,5D,5E,5F' $
         DC    X'60,61,62,63,64,65,66,67,68,69,6A,6B,6C,6D,6E,6F'
         DC    X'70,71,72,73,74,75,76,77,78,79,7A,00,00,7D,7E,7F' # @
         DC    X'80,81,82,83,84,85,86,87,88,89,8A,8B,8C,8D,8E,8F'
         DC    X'90,91,92,93,94,95,96,97,98,99,9A,9B,9C,9D,9E,9F'
         DC    X'A0,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,AE,AF'
         DC    X'B0,B1,B2,B3,B4,B5,B6,B7,B8,B9,BA,BB,BC,BD,BE,BF'
         DC    X'C0,00,00,00,00,00,00,00,00,00,CA,CB,CC,CD,CE,CF' A-I
         DC    X'D0,00,00,00,00,00,00,00,00,00,DA,DB,DC,DD,DE,DF' J-R
         DC    X'E0,E1,00,00,00,00,00,00,00,00,EA,EB,EC,ED,EE,EF' S-Z
         DC    X'00,00,00,00,00,00,00,00,00,00,FA,FB,FC,FD,FE,FF'
*
** Table to ensure that special characters are changed to dots. Use
** this one for member names as these are the only characters allowed
** by TSO/ISPF conventions
*
C_TRTABM DC    256C'.'
         ORG   C_TRTABM+C' '
         DC    C' '
         ORG   C_TRTABM+C'$'
         DC    C'$'
         ORG   C_TRTABM+C'#'
         DC    C'#'
         ORG   C_TRTABM+C'@'
         DC    C'@'
         ORG   C_TRTABM+C'A'
         DC    C'ABCDEFGHI'
         ORG   C_TRTABM+C'J'
         DC    C'JKLMNOPQR'
         ORG   C_TRTABM+C'S'
         DC    C'STUVWXYZ'
         ORG   C_TRTABM+C'0'
         DC    C'0123456789'
         ORG   ,
*
** Table to ensure that special characters are changed to dots. Use
** this one for non-member names where we can allow a few more
** printable character thru
*
C_TRTABA DC    256C'.'
         ORG   C_TRTABA+C' '
         DC    C' '
         ORG   C_TRTABA+C'Â¢'
         DC    C'Â¢'
         ORG   C_TRTABA+C'<'
         DC    C'<'
         ORG   C_TRTABA+C'('
         DC    C'('
         ORG   C_TRTABA+C'+'
         DC    C'+'
         ORG   C_TRTABA+C'|'
         DC    C'|'
         ORG   C_TRTABA+X'50'
         DC    X'50'                   &
         ORG   C_TRTABA+C'$'
         DC    C'$'
         ORG   C_TRTABA+C'*'
         DC    C'*'
         ORG   C_TRTABA+C')'
         DC    C')'
         ORG   C_TRTABA+X'5E'
         DC    X'5E'                   ;
         ORG   C_TRTABA+C'Â¬'
         DC    C'Â¬'
         ORG   C_TRTABA+C'-'
         DC    C'-'
         ORG   C_TRTABA+C'/'
         DC    C'/'
         ORG   C_TRTABA+C'Â¦'
         DC    C'Â¦'
         ORG   C_TRTABA+C','
         DC    C','
         ORG   C_TRTABA+C'%'
         DC    C'%'
         ORG   C_TRTABA+C'_'
         DC    C'_'
         ORG   C_TRTABA+C'>'
         DC    C'>'
         ORG   C_TRTABA+C'?'
         DC    C'?'
         ORG   C_TRTABA+C'`'
         DC    C'`'
         ORG   C_TRTABA+C':'
         DC    C':'
         ORG   C_TRTABA+C'#'
         DC    C'#'
         ORG   C_TRTABA+C'@'
         DC    C'@'
         ORG   C_TRTABA+X'7D'             Single quotes...
         DC    X'7D'
         ORG   C_TRTABA+C'='
         DC    C'='
         ORG   C_TRTABA+C'"'
         DC    C'"'
*
         ORG   C_TRTABA+C'a'
         DC    C'abcdefghi'
         ORG   C_TRTABA+C'j'
         DC    C'jklmnopqr'
         ORG   C_TRTABA+C's'
         DC    C'stuvwxyz'
*
         ORG   C_TRTABA+C'A'
         DC    C'ABCDEFGHI'
         ORG   C_TRTABA+C'J'
         DC    C'JKLMNOPQR'
         ORG   C_TRTABA+C'S'
         DC    C'STUVWXYZ'
*
         ORG   C_TRTABA+X'F0'
         DC    C'0123456789'
         ORG   ,
*
** Eagle picture
**
** Author of this "ASCII" Eagle unknown.
*
EAGLE_PICTURE DS 0H
 DA#STR '\             / /        The PDS Report Utility - v&DAVER'
 DA#STR ' \\\'' ,      / //'
 DA#STR '  \\\//,   _/ //,        Freeware! written by David Alcock'
 DA#STR '   \_ //'' /  //,'
 DA#STR '     \ ///  //`          Assembled on &ASMDATE. at &SYSTIME us@
               ing:'
 DA#STR '   _/ >>  \\\`'
 DA#STR '  /,)-~>> _\`            - &DMACLIB. MACLIBs'
 DA#STR '  (/ \\ \\\\\            - &MMACLIB. MACLIBs'
 DA#STR '     // // \\\'
 DA#STR '    (( ((                The PDS Eagle has landed!'
 DC  X'FFFF'                      or the buzzards are circling
*
NO_PICTURE DS 0H
 DA#STR 'The PDS Report Utility - v&DAVER'
 DA#STR ' '
 DA#STR 'Freeware! written by David Alcock'
 DA#STR ' '
 DA#STR 'Assembled on &ASMDATE. at &SYSTIME using:'
 DA#STR ' '
 DA#STR '- &DMACLIB. MACLIBs'
 DA#STR '- &MMACLIB. MACLIBs'
 DA#STR ' '
 DC  X'FFFF'
*
** End of PDSR$C2
*
         DS    0D                         End on double word boundry
PDSR$C2L EQU   *-PDSR$C2                  Length of CSECT
PDSR$C2B EQU   4096-PDSR$C2L              Bytes left addressable
         EJECT
***********************************************************************
***
**       Translator tables
***
***********************************************************************
         SPACE 2
PDSR$TRT CSECT ,
PDSR$TRT RMODE 24
PDSR$TRT AMODE 24
*
** Standard O/S eyecatcher
*
TRT_EC         B    TRT_ECL(0,R15)         Bump past EyeCatcher
               DC   AL1(L'TRT_ECLIT)       Length of eyecatcher
TRT_ECLIT      DC   C'PDSR$TRT - Translator and LKED Tables'
               DS   0H
TRT_ECL        EQU  *-TRT_EC
*
** Translator program number table
**
** (Thanks for your list, Bruce Leland!)
*
         DC    CL8'T_TRAN'
T_TRAN   DS    0H
         DC    CL10'566896201 ',CL8'ASMH    ' ASSEMBLER H
         DC    CL10'5734AS1   ',CL8'ASMH    ' OLD
         DC    CL10'569623400 ',CL8'ASMA90  ' HIGH LEVEL ASSEMBLER
         DC    CL10'40CB1     ',CL8'COBOLVS ' SEE APAR PP80690
         DC    CL10'12345     ',CL8'COBOLVS ' OLD
         DC    CL10'5741SC103 ',CL8'IFOX00  ' 1972-1987
         DC    CL10'360SAS037 ',CL8'IFOX00  ' OLD IFOX
         DC    CL10'360SAS038 ',CL8'IFOX00  ' OLD IFOX
         DC    CL10'5734AS100 ',CL8'IFOX00  ' 1977-1992
         DC    CL10'5752SC104 ',CL8'COBOLV4 ' COBOL   V4
         DC    CL10'5740CB103 ',CL8'COBOLVS ' COBOL VS2
         DC    CL10'566895801 ',CL8'COBOLII ' COBOL II
         DC    CL10'566895807 ',CL8'COBOL370' COBOL LE/370
         DC    CL10'566895901 ',CL8'COBOLII ' COBOL II
         DC    CL10'5734-PL1  ',CL8'PL1     ' PL/1 V1
         DC    CL10'5734-FO2  ',CL8'FORTRANG' FORTRAN G
         DC    CL10'5734-FO3  ',CL8'FORTRANH' FORTRAN H
         DC    CL10'5740RG1   ',CL8'RPG     ' RPG
         DC    CL10'1234-5    ',CL8'COBOLV4 ' OLD
         DC    CL10'40CB-1    ',CL8'CAPEXOPT' CAPEX OPTIMIZER
         DC    CL10'5668-910  ',CL8'PL1     ' PL/1 V2
         DC    CL10'5734-F02  ',CL8'FORTRANG' FORTRAN
         DC    CL10'569501301 ',CL8'REXX370 ' COMPILED REXX
         DC    CL10'5668-806  ',CL8'FORTRANV' FORTRAN VS
         DC    CL10'5748-FO3  ',CL8'FORTRANV' FORTRAN VS
         DC    CL10'5688187   ',CL8'C370    ' C/370
         DC    CL10'5688216   ',CL8'C370    ' C/370
         DC    CL10'5688-235  ',CL8'PL1     ' PL/1 FOR MVS AND VM
         DC    CL10'5688040   ',CL8'C370    ' C/370
         DC    CL10'SAS/C     ',CL8'SAS/C   ' SAS/C
         DC    CL10'LC370B    ',CL8'SAS/C   ' SAS/C
         DC    CL10'PL/X-370  ',CL8'PL/X-370' PL/X
         DC    CL10'C''PLS-III'' ',CL8'PLS-III ' PLS-III
         DC    CL10' 5796-PKR ',CL8'EXT.EXP.' EXT. EXPONENT FORTRAN
         DC    CL10'566876701 ',CL8'PASCAL  ' PASCAL
         DC    CL10'CA-PLNK 0 ',CL8'CA PL/S ' CA-PL/S CLONE
         DC    CL10'SAS/C/    ',CL8'SAS/C   ' SAS/C
         DC    CL10'SDS080888 ',CL8'SAS/C   ' SAS/C
         DC    CL10'BLD121988 ',CL8'SAS/C   ' SAS/C
         DC    CL10'TMCOMPIL  ',CL8'XPEDITER' XPIDITER
         DC    CL10'52ASM32B88',CL8'IFOX00  ' STRANGE IFOX
         DC    CL10'52ASM31686',CL8'IFOX00  ' STRANGE IFOX
         DC    CL10'566528444 ',CL8'IEBIMAGE' IEBIMAGE
         DC    CL10'5742SC1UM ',CL8'IEBIMAGE' IEBIMAGE
         DC    CL10'5752SC1UM ',CL8'IEBIMAGE' IEBIMAGE
         DC    CL10'568819801 ',CL8'LECOMMON' LE COMMON EXEC
         DC    CL10'568819802 ',CL8'LECOBOL ' LE COBOL
         DC    CL10'568819803 ',CL8'LEPL/I  ' LE PL/I
         DC    CL10'568819804 ',CL8'LEFORT  ' LE FORTRAN
         DC    CL10'568819805 ',CL8'LEC++   ' LE C++
*
*-From Dave:
         DC    CL10'5645001   ',CL8'LE_C++r2' OS/390 v1r2
T_TRANL  EQU   *-T_TRAN
T_TRANN  EQU   T_TRANL/TRANTL
         DC    18X'FF'
*
** Translator program ID's for Linkage Editor/Binders
*
         DC    CL8'T_LINKT'
T_LINKT  DS    0H
         DC    CL10'5695DF108 ',CL16'DFSMS Binder'
         DC    CL10'566528408 ',CL16'DFP LKED'
         DC    CL10'566529508 ',CL16'DFP LKED'
         DC    CL10'5752SC104 ',CL16'LKED-F'
         DC    CL10'04LE960488',CL16'MVSLKED'
T_LINKTL EQU   *-T_LINKT
T_LINKTN EQU   T_LINKTL/TLTL
         DC    26X'FF'
*
** Table of Vendor CSECT prefix - mapped by TVP DSECT
** Low resource table (over //IVCSECT method)
*
         DC    CL8'T_VENDOR'
T_VENDOR DS    0F
         DC    AL2(3-1,0),CL8'AMP*    ',AL2(T_VPAS-PDSR$TRT)
         DC    AL2(3-1,0),CL8'CEE*    ',AL2(T_VLE-PDSR$TRT)
         DC    AL2(3-1,0),CL8'CBC*    ',AL2(T_VC-PDSR$TRT)
         DC    AL2(3-1,0),CL8'EDC*    ',AL2(T_VC-PDSR$TRT)
         DC    AL2(5-1,0),CL8'BLDQS   ',AL2(T_VCOBII-PDSR$TRT)
         DC    AL2(8-1,0),CL8'COBDBG  ',AL2(T_VCOBII-PDSR$TRT)
         DC    AL2(8-1,0),CL8'COBTEST ',AL2(T_VCOBII-PDSR$TRT)
         DC    AL2(3-1,0),CL8'IGZ*    ',AL2(T_VCOBII-PDSR$TRT)
         DC    AL2(3-1,0),CL8'ILB*    ',AL2(T_VCOBVS-PDSR$TRT)
         DC    AL2(3-1,0),CL8'IFY*    ',AL2(T_VFORT-PDSR$TRT)
         DC    AL2(3-1,0),CL8'AFH*    ',AL2(T_VFORT-PDSR$TRT)
         DC    AL2(3-1,0),CL8'IHE*    ',AL2(T_VPLIA-PDSR$TRT)
         DC    AL2(3-1,0),CL8'IBM*    ',AL2(T_VPLI-PDSR$TRT)
         DC    AL2(8-1,0),CL8'PLISTART',AL2(T_VPLI-PDSR$TRT)
         DC    AL2(8-1,0),CL8'PLIMAIN ',AL2(T_VPLI-PDSR$TRT)
         DC    AL2(3-1,0),CL8'DFH*    ',AL2(T_VCICS-PDSR$TRT)
         DC    AL2(3-1,0),CL8'DSN*    ',AL2(T_VDB2-PDSR$TRT)
         DC    AL2(4-1,0),CL8'IDMS*   ',AL2(T_VIDMS-PDSR$TRT)
T_VENDORN EQU  (*-T_VENDOR)/TVP_SL
         DC    9X'FF'
*
#TVPDSL   EQU    19+2                     Set for max desc string +
*                 ....+....1....+....2
T_VPAS    DA#STR 'IBM_Pascal'
T_VLE     DA#STR 'IBM_LE/370'
T_VC      DA#STR 'IBM_C/C++'
T_VCOBII  DA#STR 'IBM_VS COBOL II'
T_VCOBVS  DA#STR 'IBM_OS/VS COBOL'
T_VFORT   DA#STR 'IBM_FORTRAN'
T_VPLIA   DA#STR 'IBM_PL/I (ancient)'
T_VPLI    DA#STR 'IBM_PL/I'
T_VCICS   DA#STR 'IBM_CICS'
T_VDB2    DA#STR 'IBM_DB2'
T_VIDMS   DA#STR 'CA-IDMS'
          DS     0D
PDSR$TRTL EQU    *-PDSR$TRT               End of PDSR$TRT CSECT
*
** Map T_LINKT
*
TLT      DSECT ,
TLT_ID   DS    CL10' '
TLT_NAME DS    CL16' '
TLTL     EQU   *-TLT
*
** Map T_TRAN table
*
TRANT        DSECT ,
TRANT_ID     DS    CL10                   Translator ID
TRANT_NAME   DS    CL8                    Translator Name
TRANTL       EQU   *-TRANT                Length of entry
*
** Map T_VENDOR table
*
TVP          DSECT ,
TVP_PREFL    DS    XL2                    Prefix length
             DS    XL2                    Not used, get on fullwrd bnd
TVP_PREFIX   DS    CL8                    Prefix value
TVP_IEL      EQU   *-TVP                  Length to copy during init
TVP_OFF      DS    AL2                    Offset in PDSR$TRT of desc
TVP_SL       EQU   *-TVP                  Length of static entry
             ORG   TVP_OFF
TVP_DADDR    DS    AL4                    Address of description
TVP_I        EQU   *
TVP_CNTLIB   DS    AL4                    Count: for this library
TVP_CNTALL   DS    AL4                    Count: for all libraries
TVP_IL       EQU   *-TVP_I
TVP_DL       EQU   *-TVP                  Length of entry
             ORG   ,
         EJECT ,
***********************************************************************
***
**       Help me - Help me - I've been hyp-mo-tized
**
** This routine prints the help information.  The Pascal-like
** strings make the bulk of the input.  There are a few attribute
** bytes which are used instead of a usual string length:
**
** - FF ... End of help information
** - FE ... Print a blank line
** - FD ... Print the translator table
** - FC ... Print the Linkage Editor/Binder Translator table
**
** Help information - We are trying to keep this information
** under 80 columns for good TSO viewing.  It is printed when this
** program is executed with PARM='HELP'.
***
***********************************************************************
         SPACE 2
PDSR$HLP CSECT ,
PDSR$HLP AMODE 24
PDSR$HLP RMODE 24
*
** Standard O/S eyecatcher
*
HLP_EC         B    HLP_ECL(0,R15)         Bump past EyeCatcher
               DC   AL1(L'HLP_ECLIT)       Length of eyecatcher
HLP_ECLIT      DC   C'PDSR$HLP - Help Information'
               DS   0H
HLP_ECL        EQU  *-HLP_EC
*
** Entry Housekeeping
*
         BAKR  R14,0                    Save registers
         LAE   R12,0(R15,0)             Get base register
         USING PDSR$HLP,R12             Set module base
         SAC   0
         SYSSTATE ASCENV=P
         EREG  R0,R1
         LR    R13,R1
         USING SUBRSA,R13                 Locate to data area
         SPACE 2
*
** Print initial messages
*
         BAS   R14,HELP$CLEAR_RECOUT      Clear record to blanks
         BAS   R14,HELP$PSR               Print the record
*
         BAS   R14,HELP$FORMAT_MESSAGE   Initialize the message area
         MVC   0(MSG6L,R15),MSG6-PDSR$MSG(R1) Move in message
         BAS   R14,HELP$PSR               Print the record
*
** Loop thru help text
*
         LA    R3,HELPTEXT                Locate start of text
HELP$L   DS    0H
         BAS   R14,HELP$CLEAR_RECOUT      Clear record to blanks
*-Blank line
         CLI   0(R3),X'FE'                Blank line?
         BNE   HELP$LM                    No, continue
         BAS   R14,HELP$PSR               Print the record
         LA    R3,1(R3)                   Bump past attribute character
         B     HELP$L
HELP$LM  DS    0H
*-Print translator table
         CLI   0(R3),X'FD'                Translators?
         BNE   HELP$TTX                   No, continue
         L     R4,=V(PDSR$TRT)            -> Translater CSECT
         LA    R4,T_TRAN-PDSR$TRT(R4)     Locate to table start
         LA    R5,T_TRANN                 Get number of entries
HELP$TTL DS    0H
         LA    R15,RECOUT+12              Get output location
         MVC   0(L'TRANT_ID,R15),TRANT_ID-TRANT(R4)  Get ID
         LA    R15,L'TRANT_ID+2(R15)                 Bump past ID
         MVC   0(L'TRANT_NAME,R15),TRANT_NAME-TRANT(R4) Get Name
         BAS   R14,HELP$PSR               Print the record
         LA    R4,TRANTL(R4)              Next entry (input)
         BCT   R5,HELP$TTL                Process next entry
         LA    R3,1(R3)                   Bump past attribute character
         B     HELP$L
HELP$TTX DS    0H
*-Print LinkageEditor/Binder Translator table
         CLI   0(R3),X'FC'                LKED translators?
         BNE   HELP$LTX                   No, continue
         L     R4,=V(PDSR$TRT)            -> Translater CSECT
         LA    R4,T_LINKT-PDSR$TRT(R4)    Locate to table start
         LA    R5,T_LINKTN                Get number of entries
HELP$LTL DS    0H
         LA    R15,RECOUT+12              Get output location
         MVC   0(L'TLT_ID,R15),TLT_ID-TLT(R4)        Get ID
         LA    R15,L'TLT_ID+2(R15)                   Bump past ID
         MVC   0(L'TLT_NAME,R15),TLT_NAME-TLT(R4) Get Name
         BAS   R14,HELP$PSR               Print the record
         LA    R4,TLTL(R4)                Next entry (input)
         BCT   R5,HELP$LTL                Process next entry
         LA    R3,1(R3)                   Bump past attribute character
         B     HELP$L
HELP$LTX DS    0H
*-Print Vendor table
         CLI   0(R3),X'FB'                LKED translators?
         BNE   HELP$LVX                   No, continue
         L     R4,=V(PDSR$TRT)            -> Translater CSECT
         LA    R4,T_VENDOR-PDSR$TRT(R4)   Locate to table start
         LA    R5,T_VENDORN               Get number of entries
HELP$LVL DS    0H
         LA    R15,RECOUT+12              Get output location
         MVC   0(L'TVP_PREFIX,R15),TVP_PREFIX-TVP(R4) Get ID
         BAS   R14,HELP$PSR               Print the record
         LA    R4,TVP_SL(R4)              Next entry (input)
         BCT   R5,HELP$LVL                Process next entry
         LA    R3,1(R3)                   Bump past attribute character
         B     HELP$L
HELP$LVX DS    0H
*-Print string
         LA    R15,RECOUT+1               Bump past prefix and 'xxxI '
         SLR   R14,R14                    Clear register
         IC    R14,0(R3)                  Obtain length of messsage - 1
         EX    R14,HELP$MVE               Move string to message area
         LA    R3,2(R14,R3)               Bump past this string
         BAS   R14,HELP$PSR               Print record
*-End of table
         CLI   0(R3),X'FF'                End of table?
         BNE   HELP$L                     No, process next string
*
         BAS   R14,HELP$CLEAR_RECOUT      Clear record to blanks
         BAS   R14,HELP$PSR               Print the record
         B     HELP$X                     Continue
*
HELP$MVE MVC   0(0,R15),1(R3)
*
** Common exit from HELP processing
*
HELP$X   DS    0H
         PR    ,                          Return to caller
*
** Print SYSPRINT Record
*
HELP$PSR DS    0H
         ST    R14,PSR_RA                 Save return address
         LA    R0,PSRAREA                 Locate work area
         LA    R1,RECOUT                  Locate record to print
         L     R15,=V(PDSR$PSR)           Locate sysprint routine
         BASR  R14,R15                    Print Sysprint Record
         L     R14,PSR_RA                 Get return address
         BSM   0,R14                      Return to caller
*
** Clear output record to blanks
*
HELP$CLEAR_RECOUT  DS 0H
         LA    R15,RECOUT                 Locate output record
         MVI   0(R15),C' '                Get Blank
         MVC   1(L'RECOUT-1,R15),0(R15)   ..Propagate it
         BSM   0,R14                      Return to caller
*
** Initialize message
**
** Output: R1 has PDSR$MSG
*
HELP$FORMAT_MESSAGE DS 0H
         LA    R15,RECOUT
         MVI   0(R15),C' '
         MVC   1(L'RECOUT-1,R15),0(R15)
         LA    R15,1(R15)
         L     R1,=V(DA$PDSR)             -> main CSECT
         MVC   0(7,R15),5(R1)             Move in "DA$PDSR"
         MVI   7(R15),C'-'                Insert dash
         LA    R15,MSGPREL(R15)           Bump past "DA$PDSR-"
         L     R1,=V(PDSR$MSG)            -> PDSR$MSG CSECT
         BSM   0,R14
*
** Literals for the PDSR$HLP CSECT
*
         LTORG ,
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**       Help text area
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
HELPTEXT DS    0H
 DC  X'FE'                                Skip a line
*
** General information
*
 DA#STR 'DA$PDSR, a PDS reporting program, can be used to manage'
 DA#STR 'your partitioned datasets.  It processes both load libraries'
 DA#STR 'and non-load libraries. By default, it will process every '
 DA#STR 'library that is allocated with a DDNAME that begins with '
 DA#STR '"SYSLIB" (although you can change the DSNAME prefix to suit'
 DA#STR 'your needs).  You can omit the //SYSLIBxx datasets and '
 DA#STR 'optionally process the whole LNKLST or LPALST'
*
** Sample JCL
*
 DC  X'FE'                                Skip a line
 DA#STR 'It can be invoked via the following JCL:'
 DC  X'FE'                                Skip a line
 DA#STR '//stepname EXEC PGM=DA$PDSR,PARM=''options'' '
 DA#STR '//SYSPRINT DD SYSOUT=*'
 DA#STR '//REPORT   DD SYSOUT=*'
 DA#STR '//HISTRPT  DD SYSOUT=*                      <- optional'
 DA#STR '//TRANRPT  DD SYSOUT=*                      <- optional'
 DA#STR '//ZAPRPT   DD SYSOUT=*                      <- optional'
 DA#STR '//ECRPT    DD SYSOUT=*                      <- optional'
 DA#STR '//*'
 DA#STR '//IVCSECT  DD DISP=SHR,DSN=CEE.SCEELKED     <- optional'
 DA#STR '//         DD DISP=SHR,DSN=COBOL.COB2LIB    <- optional'
 DA#STR '//         DD DISP=SHR,DSN=FORT.VSF2FORT    <- optional'
 DA#STR '//*'
 DA#STR '//SYSLIBaa DD DSN=data-set-name,DISP=SHR'
 DA#STR '//SYSLIBzz DD DSN=data-set-name,DISP=SHR'
 DA#STR '//WRKFILE1 DD DISP=(,DELETE),SPACE=(CYL,1)  <- optional'
 DA#STR '//WRKFILE2 DD DISP=(,DELETE),SPACE=(CYL,##) <- optional'
 DA#STR '//WRKFILE3 DD DISP=(,DELETE),SPACE=(CYL,##) <- optional'
 DA#STR '//SYSIN    DD *                             <- optional'
 DA#STR 'options'
 DA#STR 'options'
 DA#STR '/*'
 DC  X'FE'                                Skip a line
 DA#STR '  Notes:'
 DA#STR '  - The WRKFILEx files are optional and only needed for '
 DA#STR '    sorting when you use the CHKDUP and MEMXREF options '
 DA#STR '    are specified.'
 DA#STR '  - If a "//SORTDIAG" is found allocated, then all of the'
 DA#STR '    SORT messages will be printed in the SYSPRINT file.'
 DA#STR '    Otherwise, the sort messages are only printed if the'
 DA#STR '    SORT has a non-zero return code.'
 DA#STR '  - The CSECTS column of the load module report will only'
 DA#STR '    be updated when you use an option that uses the'
 DA#STR '    DFSMS/MVS Binder API to process a load module''s'
 DA#STR '    CSECTs: TRANRPT, ZAPRPT, ECRPT, etc.'
 DA#STR '  - When running under DFSMS/MVS and you ask for a HISTRPT'
 DA#STR '    TRANRPT or ZAPRPT, you can influence processing by'
 DA#STR '    allocating these files (changes Binder API options):'
 DC  X'FE'                                Skip a line
 DA#STR '      //BINDERDB DD DUMMY      <- Ask for Binder API output'
 DA#STR '      //BINDEROU DD SYSOUT=*   <- Binder API output goes here'
 DC  X'FE'                                Skip a line
 DA#STR '    If you are running DFSMS 1.3 without UW32119, use these'
 DA#STR '    DD statements to turn off Binder API messages:'
 DC  X'FE'                                Skip a line
 DA#STR '      //BINDEROU DD DUMMY      <- Binder API output goes here'
 DA#STR '      //BINDERPR DD DUMMY      <- Turn on print'
 DC  X'FE'                                Skip a line
*
** Pair-A-Meters
*
 DC  X'FE'                                Skip a line
 DC  X'FE'                                Skip a line
 DA#STR 'The following options can be specified on the parm card '
 DA#STR '(PARM="option,option") or in the //SYSIN file:'
 DC  X'FE'                                Skip a line
 DA#STR 'NOBREAK  - Do not "Break" (place a blank line between member'
 DA#STR '           names) when the prefix changes. The prefix is the '
 DA#STR '           first 3 characters: IEFBR14, IEFACTRT, etc.'
 DA#STR '                               ___      ___'
*
 DA#STR 'CHKDUP   - Check for duplicate members in all of the datasets'
 DA#STR '           processed'
*
 DA#STR 'DATAONLY - Do not produce headings on REPORT file'
*
 DA#STR 'DATE=    - Date format: (DATE=US | DATE=EUR | DATE=ISO)'
 DA#STR '           US - United States date format: MM/DD/CCYY'
 DA#STR '           EUR - "European" date format: DD-MMM-CCYY'
 DA#STR '           ISO - ISO Date format: CCYY-MM-DD'
 DA#STR '           << default is DATE=EUR >>'
*
 DA#STR 'EODC     - Report on End Of Data Conditions reported by '
 DA#STR '           the Binder API GETN call for RC=4'
*
 DA#STR 'NODETAIL - Do not print normal detail records if PARM=CHKDUP '
 DA#STR '           was specified.  This option lets you get only the'
 DA#STR '           information needed: the duplicate members.'
*
 DA#STR 'DUMPBLDL - Print the BLDL results from the PDS in hex dump'
 DA#STR '           format'
*
 DA#STR 'DUMPDIRE - Print the PDS directory entry in hex dump format'
*
 DA#STR 'DUMPDSCB - Print the Format-1 DSCB (Data Set Control Block) '
 DA#STR '           in hex dump format as we process the file'
*
 DA#STR 'FINDMEM= - Search each library we process and look for the '
 DA#STR '           the member.  Trailing generics are allowed, for'
 DA#STR '           example: FINDMEM=IEF*'
*
 DA#STR 'FLATOUT  - Put dataset and member detail records to the'
 DA#STR '           DD=FLATOUT file.  This output is good for analysis'
 DA#STR '           by programs written in REXX or SAS'
 DA#STR '           Note: You should have a file allocated to FLATOUT'
*
 DA#STR 'HELP     - List the current options to the SYSPRINT dataset'
*
 DA#STR 'HISTRPT  - Produce a History (IDR Identify and Zap) report on'
 DA#STR '           file HISTRPT.  This function only works on'
 DA#STR '           DFSMS/MVS systems.'
*
 DA#STR 'IVCSECTS - Ignore Vendor CSECT Statistics: The statistics for'
 DA#STR '           CSECTs will not reflect Vendor CSECTs. The vendor'
 DA#STR '           CSECTs will be included in the detail reports'
 DC  X'FE'                                Skip a line
 DA#STR '           Use the //IVCSECT DD concatenation to augment'
 DA#STR '           the CSECTs to be considered as Vendor CSECTS'
 DC  X'FE'                                Skip a line
 DA#STR '           See related option: NIVENDOR'
 DC  X'FE'                                Skip a line
*
 DA#STR 'IVCSECTF - Ignore Vendor CSECT FULL: The vendor CSECTs will '
 DA#STR '           not be reflected in statistics or in the reports'
 DC  X'FE'                                Skip a line
 DA#STR '           Use the //IVCSECT DD concatenation to augment'
 DA#STR '           the CSECTs to be considered as Vendor CSECTS'
 DC  X'FE'                                Skip a line
 DA#STR '           See related option: NIVENDOR'
 DC  X'FE'                                Skip a line
*
 DA#STR 'LINECNT= - Specify the number of lines to be printed per page'
*
 DA#STR 'LNKLST   - Process all of the datasets in the current LNKLST'
*
 DA#STR 'LOADMOD  - Perform a MVS LOAD for all members in a load'
 DA#STR '           library to ensure that they are LOADable.'
*
 DA#STR 'LPALST   - Process all of the datasets in the current LPALST'
*
 DA#STR 'MEMXREF  - Perform Member Cross reference on the libraries'
 DA#STR '           processed.  The REPORT file has some member'
 DA#STR '           information and the data set name of the library'
 DA#STR '           it was found in.  All members are shown.'
*
 DA#STR 'NIVENDOR - Don''t use internal Vendor CSECT table, only'
 DA#STR '           members in the //IVCSECT PDS concatenation will '
 DA#STR '           be considered.  This is used with the IVCSECTx '
 DA#STR '           options'
*
 DA#STR 'ONLYFIND - Only process the modules that are found using'
 DA#STR '           the FINDMEM= value'
*
 DA#STR 'PREFIX=  - Use a different DD prefix for specifing the files'
 DA#STR '           to be processed, the default is SYSLIB. All of the'
 DA#STR '           files allocated to the job step with this prefix'
 DA#STR '           will be processed in addition to other options'
 DA#STR '           like LNKLST, LPALST, etc.'
*
 DA#STR 'SIMULATE - Show the files that would have been processed.  No'
 DA#STR '           reporting is performed but every library has a'
 DA#STR '           MVS OPEN file I/O to ensure access'
*
 DA#STR 'NOSMS    - Do not invoke DFSMS/MVS services when executing '
 DA#STR '           in a DFSMS/MVS environment. This disables some '
 DA#STR '           functions like TRANRPT and HISTRPT'
*
 DA#STR 'NOSYSIN  - Do not process file SYSIN for options'
*
 DA#STR 'NOTRANID - Do not convert Linkage Editor/Binder Translator'
 DA#STR '           program IDs to alias name on the report'
*
 DA#STR 'TRANRPT  - Produce a Translator report on file TRANRPT. This '
 DA#STR '           function only works on DFSMS/MVS systems.'
*
 DA#STR 'TSOVIEW  - When we do an internal hex dump, make the output'
 DA#STR '           fit in 80 columns for easy terminal viewing'
*
 DA#STR 'ZAPRPT   - Create ZAP report on file ZAPRPT (non-DFSMS/MVS)'
 DA#STR '           Note: the ZAP information goes to the HISTRPT when'
 DA#STR '                 executing on a DFSMS/MVS system'
*
** Print the translators
*
 DC  X'FE'                                Skip a line
 DC  X'FE'                                Skip a line
 DA#STR 'List of Translator IDs and Names:'
 DC  X'FE'                                Skip a line
 DC  X'FD'                                Print translators here
*
** Print the Linkage Editor/Binder Translators
*
 DC  X'FE'                                Skip a line
 DC  X'FE'                                Skip a line
 DA#STR 'List of Linkage-Editor/Binder Translator IDs and Names:'
 DC  X'FE'                                Skip a line
 DC  X'FC'                                Print LKED/Binder Trans here
*
** Print the List of vendor CSECTs:
*
 DC  X'FE'                                Skip a line
 DC  X'FE'                                Skip a line
 DA#STR 'List of Vendor CSECTs in internal table:'
 DC  X'FE'                                Skip a line
 DC  X'FB'                                Print LKED/Binder Trans here
*
** End of HELP CSECT
*
 DC  X'FE'                                Skip a line
 DA#STR 'End of Help.'
 DC  X'FF'
*
** End of PDSR$HLP
*
         DROP  R12,R13
         DS  0D
         EJECT ,
***********************************************************************
***
**           Dynamic Allocation (SVC 99) services
**
**     Input: DOUBLE2 - #R$PDS99_func
**     Output: R15 has the return code from SVC 99 (DYNALLOC)
***
***********************************************************************
         SPACE 2
PDSR$DA  CSECT ,
PDSR$DA  AMODE 24
PDSR$DA  RMODE 24
         USING PDSR$DA,R8                 Set base register for CSECT
         USING WORKDS,R13                 Need this area
*
** Standard O/S eyecatcher
*
DA_EC          B    DA_ECL(0,R8)           Bump past EyeCatcher
               DC   AL1(L'DA_ECLIT)        Length of eyecatcher
DA_ECLIT       DC   C'PDSR$DA  - Dynamic Allocation'
               DS   0H
DA_ECL         EQU  *-DA_EC
*
** Format Request block and set up for DYNALLOC
*
         SPACE 1
         LA    R4,RECOUT                  Get address of work area
         ST    R4,DOUBLE                  Save address
         OI    DOUBLE,S99RBPND            Indicate last one
         XC    0(S99RBEND-S99RB,R4),0(R4) Clear Request Block area
         MVI   S99RBLN-S99RB(R4),S99RBEND-S99RB Length of REQUEST BLK
         LA    R5,S99RBEND-S99RB(R4)      Locate Text Units Pointers
         ST    R5,S99TXTPP-S99RB(R4)      STORE ADDR OF Text Unit PTRs
         LA    R6,20(R5)    5*4=20        Bump past Text pointers
****
**
** The address of each of the text Units will be stored in the
** request block text PTR area as they are being defined,
** Active registers are: R5 - Address in text unit pointers
**                       R6 - Address in text unit define area
**
****
** What type of function to perform?
*
         CLI   DOUBLE2,#PDSR$DA$ADSN      Allocate by DSNAME
         BE    DYNA$ADSN
         CLI   DOUBLE2,#PDSR$DA$FDD       Free by DDNAME
         BE    DYNA$FDD
*
         MVC   S99ERROR-S99RB(2,R4),=X'FFFFFFFF' Set internal error
         LA    R15,20                     Set return code
         B     DYNA$X
         SPACE 2
*
** Allocate by DSNAME (AREAJFCB)
*
DYNA$ADSN EQU *
         MVI   S99VERB-S99RB(R4),S99VRBAL    Verb = ALLOCATE
***-(1)---------------------------------- DDNAME=
         ST    R6,0(R5)                     Save Address of Text Unit
         LA    R5,L'S99TUPTR(R5)            Bump to next entry
*
         LA    R14,DALRTDDN                 Generate Key Value
         STH   R14,S99TUKEY-S99TUNIT(R6)    Store Key
         LA    R14,1                        Number of entries
         STH   R14,S99TUNUM-S99TUNIT(R6)    Store Number
         LA    R14,8                        Length of First Entry
         STH   R14,S99TULNG-S99TUNIT(R6)    Store Length
         LA    R1,S99TUPAR-S99TUNIT(R6)     Locate DDNAME
         ST    R1,DOUBLE2                   Save Addr: Returned DDNAME
*
         LA    R6,S99TUPAR-S99TUNIT+8(R6)   Bump past this Text Unit
***-(2)---------------------------------- DISP=
         ST    R6,0(R5)                     Save Address of Text Unit
         LA    R5,L'S99TUPTR(R5)            Bump to next entry
*
         LA    R14,DALSTATS                 Generate Key Value
         STH   R14,S99TUKEY-S99TUNIT(R6)    Store Key
         LA    R14,1                        Number of entries
         STH   R14,S99TUNUM-S99TUNIT(R6)    Store Number
         LA    R14,1                        Length of First Entry
         STH   R14,S99TULNG-S99TUNIT(R6)    Store Length
         MVI   S99TUPAR-S99TUNIT(R6),8      DISP=SHR
*
         LA    R6,S99TUPAR-S99TUNIT+2(R6)   Bump past this Text Unit
***-(3,LAST)----------------------------- DSN=
         ST    R6,0(R5)                     Save Address of Text Unit
         OI    S99TUPTR-S99TUPL(R5),S99TUPLN End of parm indication
*
         LA    R14,DALDSNAM                 Generate Key Value
         STH   R14,S99TUKEY-S99TUNIT(R6)    Store Key
         LA    R14,1                        Number of entries
         STH   R14,S99TUNUM-S99TUNIT(R6)    Store Number
         LA    R14,44                       Length of First Entry
         STH   R14,S99TULNG-S99TUNIT(R6)    Store Length
         MVC   S99TUPAR-S99TUNIT(44,R6),AREAJFCB
***-------------------------------------- Complete and make request
         B     DYNA$DA                      Perform DYNALLOC
*
** Free by DDNAME in PP_ADDN
*
DYNA$FDD EQU   *
         MVI   S99VERB-S99RB(R4),S99VRBUN    Verb = Deallocation
***-(1,LAST)----------------------------- DDNAME=
         ST    R6,0(R5)                     Save Address of Text Unit
         OI    S99TUPTR-S99TUPL(R5),S99TUPLN End of parm indication
*
         LA    R14,DUNDDNAM                 Generate Key Value
         STH   R14,S99TUKEY-S99TUNIT(R6)    Store Key
         LA    R14,1                        Number of entries
         STH   R14,S99TUNUM-S99TUNIT(R6)    Store Number
         LA    R14,8                        Length of First Entry
         STH   R14,S99TULNG-S99TUNIT(R6)    Store Length
         MVC   S99TUPAR-S99TUNIT(8,R6),PP_ADDN Get the DDNAME
***-------------------------------------- Complete and make request
*
** Perform dynamic allocation
*
DYNA$DA EQU    *
         LA    R1,DOUBLE                  Get address of Request BLK
         DYNALLOC ,                       Invoke SVC 99
*
** Common exit from PDSR$DA
*
DYNA$X   EQU   *
         BSM   0,R9                       Return to caller
*
** Constants for PDSR$DA
*
         LTORG ,
         DS    0D
*
** Equates for function type (in first byte of DOUBLE2
*
#PDSR$DA$ADSN EQU 0
#PDSR$DA$FDD   EQU 1
         DROP  R8,R13
         EJECT
***********************************************************************
***
**       Load Module formating
**
**       This CSECT was created to save room in primary CSECT
***
***********************************************************************
         SPACE 2
PDSR$LMF CSECT ,
PDSR$LMF AMODE 24
PDSR$LMF RMODE 24
*
** Standard O/S eyecatcher
*
LMF_EC        B    LMF_ECL(0,R15)         Bump past EyeCatcher
              DC   AL1(L'LMF_ECLIT)       Length of eyecatcher
LMF_ECLIT     DC   C'PDSR$LMF - Load Module formating'
              DS   0H
LMF_ECL       EQU  *-LMF_EC
*
** Entry Housekeeping
*
         BAKR  R14,0                      Save registers
         LAE   R12,0(R15,0)               Get base register
         USING PDSR$LMF,R12               Set module base
         SAC   0
         SYSSTATE ASCENV=P
         EREG  R0,R1                      Restore registers R0 and R1
         LR    R13,R1                     Locate RSA and work area
         USING SUBRSA,R13                 Locate to data area
*
** Branch to routine
*
#LMF_HEADINGS EQU 1
#LMF_FORMAT  EQU 2
*
         CH    R0,=AL2(#LMF_HEADINGS)     Want headings?
         BE    LMF$HEADINGS
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Format detail line
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
         EREG  R2,R3                      Get PDS2 area address
*
** Format EPA Information
*
         LA    R1,RECOUT+1                POINT TO OUTPUT LINE
         UNPK  DET_LEPA-DET(7,R1),PDS2EPA-PDS2(4,R2)
         MVZ   DET_LEPA-DET(6,R1),LMF_ZEROS
         TR    DET_LEPA-DET(6,R1),LMF_HEXTABLE
         MVI   DET_LEPA-DET+6(R1),C' '
*
** Format size and add to total PDS count
*
         LA    R1,RECOUT+1                POINT TO OUTPUT LINE
         UNPK  DET_LSIZE-DET(7,R1),PDS2STOR-PDS2(4,R2)
         MVZ   DET_LSIZE-DET(6,R1),LMF_ZEROS
         TR    DET_LSIZE-DET(6,R1),LMF_HEXTABLE
         MVI   DET_LSIZE-DET+6(R1),C' '
*
         TM    PDS2INDC-PDS2(R2),PDS2ALIS Alias?
         BNO   PPD$LSIZEX                 Yes, don't need it
         SLR   R1,R1                      Clear register
         ICM   R1,B'0111',PDS2STOR-PDS2(R2) Get size
         L     R15,PPD_SIZE               Get current size
         AR    R15,R1                     Add for this member
         ST    R15,PPD_SIZE               Save it
PPD$LSIZEX EQU *
*
** Do Amode and Rmode
*
         MVC   RECOUT+1+DET_LMODER-DET(2),=C'24'
         TM    PDS2FTB2-PDS2(R2),PDSLRMOD
         BNO   PPD$MODE_RX
         MVC   RECOUT+1+DET_LMODER-DET(3),=C'Any'
PPD$MODE_RX EQU *
*
         TM    PDS2FTB2-PDS2(R2),PDSMAMOD  Both on?
         BO    PPD$MODE_AANY              Yes, its ANY
         TM    PDS2FTB2-PDS2(R2),BIT6     Just one?
         BO    PPD$MODE_A31               Yes, its 31
         MVC   RECOUT+1+DET_LMODEA-DET(2),=C'24'
         B     PPD$MODE_AX
PPD$MODE_A31 EQU *
         MVC   RECOUT+1+DET_LMODEA-DET(2),=C'31'
         B     PPD$MODE_AX
PPD$MODE_AANY EQU *
         MVC   RECOUT+1+DET_LMODEA-DET(3),=C'Any'
PPD$MODE_AX EQU *
*
** Process module attributes
*
         LA    R7,RECOUT+1+DET_LATTR-DET
         TM    PDS2ATR2-PDS2(R2),PDS2FLVL
         BNO   PPD$PM_FOX
         MVC   0(2,R7),=C'FO'
         LA    R7,3(R7)
PPD$PM_FOX EQU  *
         TM    PDS2ATR1-PDS2(R2),PDS2EXEC
         BO    PPD$PMA1
         MVC   0(2,R7),=C'NX'
         LA    R7,3(R7)
         L     R1,PPD_NEX
         LA    R1,1(R1)
         ST    R1,PPD_NEX
PPD$PMA1 EQU   *
         TM    PDS2ATR1-PDS2(R2),PDS2RENT
         BNO   PPD$PMA2
         MVC   0(2,R7),=C'RE'
         LA    R7,3(R7)
PPD$PMA2 EQU   *
         TM    PDS2ATR1-PDS2(R2),PDS2REUS
         BNO   PPD$PMA3
         MVC   0(2,R7),=C'RU'
         LA    R7,3(R7)
PPD$PMA3 EQU   *
         TM    PDS2ATR1-PDS2(R2),PDS2OVLY
         BNO   PPD$PMA4
         MVC   0(2,R7),=C'OV'
         LA    R7,3(R7)
PPD$PMA4 EQU   *
*
** Process Load module section
**
** Locating the PDS sections is documented in the comments of the
** 'SYS1.AMODGEN(IHAPDS)' macro.
*
         LA    R5,PDSBCEND-PDS2(R2)       Locate end of PDS2 Area
         TM    PDS2ATR1-PDS2(R2),PDS2SCTR Scatter Load?
         BNO   PPD$LMS_SCX                No, continue
         LA    R5,PDSS01LN(R5)            Bump past scatter section
PPD$LMS_SCX EQU *
         TM    PDS2INDC-PDS2(R2),PDS2ALIS Alias?
         BNO   PPD$LMS_ALX                No, Continue
         LA    R1,RECOUT+1                Point to output line
         MVC   DETALIAS-DET(2,R1),=C'-A'
         MVC   DETALIAS+3-DET(8,R1),PDS2MNM-PDSS02(R5)
         L     R1,PPD_NALIAS              Get current alias count
         LA    R1,1(R1)                   Increment by 1
         ST    R1,PPD_NALIAS              Save current alias count
*
         LA    R1,AREABLDL                Locate work area
         XC    0(BLDLAL,R1),0(R1)         Clear it to zeros
         MVC   BLDLA_FF-BLDLA(2,R1),=AL2(1) Set number of modules to 1
         MVC   BLDLA_LL-BLDLA(2,R1),=AL2(BLDLAL-2) Set length
         MVC   BLDLA_NAME-BLDLA(8,R1),PDS2MNM-PDSS02(R5)
         LR    R0,R1                      Get parameter list address
         BLDL  SYSMEM,(0)                 Perform BLDL
         LA    R1,AREABLDL                Locate work area
         CLC   BLDLA_TTR-BLDLA(3,R1),PDS2TTRP-PDS2(R2)
         BNE   PPD$LMS_AL                 No, this puppy is orphaned
         LTR   R15,R15                    Found?
         BZ    PPD$LMS_ALBX               No, continue
PPD$LMS_AL EQU *
         LA    R1,RECOUT+1                Point to output line
         MVI   DETALIAS-1-DET(R1),C'>'    Mark as not found
         DA#SMODE 31                      Get into 31 bit mode
         L     R14,PP_OTCP                -> Current entry in alias tab
         C     R14,PP_OTLE                At last entry in table?
         BE    PPD$LMS_ALB                Yes, skip it
         MVC   ORPT_RNAME-ORPT(8,R14),PDS2MNM-PDSS02(R5) Real Name
         LA    R1,AREABLDL                Locate BLDL area
         MVC   ORPT_RTTR-ORPT(3,R14),BLDLA_TTR-BLDLA(R1)
         MVC   ORPT_ANAME-ORPT(8,R14),PDS2NAME-PDS2(R2) Alias name
         MVC   ORPT_ATTR-ORPT(3,R14),PDS2TTRP-PDS2(R2) Alias EPA
         LA    R14,ORPTL(R14)             Bump to next entry
         ST    R14,PP_OTCP                Save its position
PPD$LMS_ALB    EQU *
         DA#SMODE 24                      Get back to 24 bit mode
PPD$LMS_ALBX   EQU *
         LA    R5,PDSS02LN(R5)            Bump past Alias section
PPD$LMS_ALX EQU *
         TM    PDS2FTB1-PDS2(R2),PDS2SSI  SSI?
         BNO   PPD$LMS_SSIX               No, Continue
         LA    R1,RECOUT+1                Locate output line
         UNPK  DET_LSSI-DET(9,R1),PDSSSIWD-PDSS03(5,R5)
         MVZ   DET_LSSI-DET(8,R1),LMF_ZEROS
         TR    DET_LSSI-DET(8,R1),LMF_HEXTABLE
         MVI   DET_LSSI-DET+8(R1),C' '    Fix byte
         LA    R5,PDSS03LN(R5)            Bump past SSI section
PPD$LMS_SSIX EQU *
         SLR   R15,R15                    Clear register
         ICM   R15,B'0001',PDSAPFCT-PDSS04(R5) Get length of APF sect.
         BZ    PPD$LMS$APFE               Zero, not there
         IC    R15,PDSAPFAC-PDSS04(R5)    Get auth code
         CVD   R15,DOUBLE                 Convert to packed
         LA    R1,RECOUT+1                Locate output
         UNPK  DET_LCODE+2-DET(2,R1),DOUBLE+7(1) Make zoned
         OI    DET_LCODE+2+1-DET(R1),X'F0'  Fix sign byte
         CLI   PDSAPFAC-PDSS04(R5),0      Zero?
         BE    PPD$LMS$APFX               Yes, leave
         TM    PPD_FLAG1,$PPD_F1APF       This an APF authorized lib?
         BO    PPD$LMS$APFX               Yes, leave
         TM    PP_FLAG1,$PP_F1LPALST      LPALST mode?
         BO    PPD$LMS$APFX               Yes, all are APFed
         L     R1,PPD_NAPF                Get count
         LA    R1,1(R1)                   Increment by one
         ST    R1,PPD_NAPF                Save it
         B     PPD$LMS$APFX               Continue
PPD$LMS$APFE EQU *
         LA    R1,RECOUT+1                Locate output line
         MVC   DET_LCODE+2-DET(2,R1),=CL2'??'  "??" like ISPF does...
PPD$LMS$APFX EQU *
         B     LMF$X
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Format headings
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
LMF$HEADINGS DS 0H
         LA    R15,PRR_LHEAD1             Locate heading record
         CLI   0(R15),0                   First time thru?
         BNE   PP$RFU_HEADX               No, continue
         BAS   R14,LMF$PTR                Clear to blanks
         LA    R15,1(R15)                 Bump past FBA byte
         USING DET,R15
         L     R1,=V(PDSR$C2)             -> Constant CSECT
         USING PDSR$C2,R1
         MVC   DET_LTD_DATE(11),C_DET_LTRANT
         MVC   DET_LTNAME(11),C_DET_LTRANT
         MVC   DET_LMODE(7),C_DET_LMODE1
         MVC   DET_LZAP+1(3),C_DET_LZAP1
         TM    W_FLAG1,$W_F1DFSMS         Using DFSMS/MVS services?
         BNO   PP$HCS1                    No, don't have CSECT count
         MVC   DET_LCSECT+2(5),C_DET_LCSECT-PDSR$C2(R1)
PP$HCS1  DS    0H
         LA    R15,PRR_LHEAD2
         BAS   R14,LMF$PTR                Clear to blanks
         LA    R15,1(R15)                 Bump past FBA byte
         L     R1,=V(PDSR$C2)             -> Constant CSECT
         USING PDSR$C2,R1
         MVC   DETMEM(6),C_DETMEM
         MVC   DETADDR(3),C_DETADDR
         MVC   DETALIAS(5),C_DETALIAS
         MVC   DET_LSIZE(4),C_DET_LSIZE
         MVC   DET_LTD_DATE(15),C_DET_LTD_DATE
         MVC   DET_LTNAME(15),C_DET_LTNAME
         MVC   DET_LMODEA(4),C_DET_LMODEA
         TM    W_FLAG1,$W_F1DFSMS         Using DFSMS/MVS services?
         BNO   PP$HCS2                    No, don't have CSECT count
         MVC   DET_LCSECT+2(5),C_DET_LCSECTN-PDSR$C2(R1)
PP$HCS2  DS    0H
         MVC   DET_LMODER(3),C_DET_LMODER
         MVC   DET_LATTR(10),C_DET_LATTR
         MVC   DET_LZAP+1(3),C_DET_LZAP
         MVC   DET_LSSI+1(3),C_DET_LSSI
         MVC   DET_LEPA(3),C_DET_LEPA
         MVC   DET_LCODE(4),C_DET_LCODE
         LA    R15,PRR_LHEAD3
         BAS   R14,LMF$PTR                Clear to blanks
         LA    R15,1(R15)                 Bump past FBA byte
         L     R1,=V(PDSR$C2)             -> Constant CSECT
         MVC   DETMEM(L'DETMEM),C_DASHS+1
         MVC   DETALIAS(L'DETALIAS),C_DASHS+1
         MVC   DETADDR(L'DETADDR),C_DASHS+1
         MVC   DET_LSIZE(L'DET_LSIZE),C_DASHS+1
         MVC   DET_LTD(DET_LTDL),C_DASHS+1
         TM    W_FLAG1,$W_F1DFSMS  Using DFSMS/MVS services?
         BNO   PP$HCS3             No, don't have CSECT count
         MVC   DET_LCSECT(L'DET_LCSECT),C_DASHS+1
PP$HCS3 DS 0H
         MVC   DET_LTNAME(DET_LTNAMEL),C_DASHS+1
         MVC   DET_LMODE(DET_LMODEL),C_DASHS+1
         MVC   DET_LATTR(L'DET_LATTR),C_DASHS+1
         MVC   DET_LZAP(L'DET_LZAP),C_DASHS+1
         MVC   DET_LSSI(L'DET_LSSI),C_DASHS+1
         MVC   DET_LEPA(L'DET_LEPA),C_DASHS+1
         MVC   DET_LCODE(L'DET_LCODE),C_DASHS+1
         DROP  R1,R15
PP$RFU_HEADX EQU *
         B     LMF$X
LMF$PTR  EQU   *
         MVI   0(R15),C' '                Get Blank
         MVC   1(L'RECOUT-1,R15),0(R15)   ..Propagate it
         BSM   0,R14                      Return to caller
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Common Exit from PDSR$LMF
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
LMF$X    DS    0H
         PR    ,                          Return to caller
*
** Constants
*
LMF_ZEROS    DC    X'00,00,00,00,00,00,00,00'
LMF_HEXTABLE DC    C'0123456789abcdef'
         LTORG ,                          Literals
*
** Calculate length of module
*
#PDSR$LMF EQU  *-PDSR$LMF
#PDSR$LMF_LEFT EQU 4096-#PDSR$LMF
         DROP  R13,R12
         EJECT
***********************************************************************
***
**       ISPF Stats formating
**
**       This CSECT was created to save room in primary CSECT
***
***********************************************************************
         SPACE 2
PDSR$IS  CSECT ,
PDSR$IS  AMODE 24
PDSR$IS  RMODE 24
*
** Standard O/S eyecatcher
*
IS_EC         B    IS_ECL(0,R15)          Bump past EyeCatcher
              DC   AL1(L'IS_ECLIT)        Length of eyecatcher
IS_ECLIT      DC   C'PDSR$IS  - ISPF Stats formating'
              DS   0H
IS_ECL        EQU  *-IS_EC
*
** Entry Housekeeping
*
         BAKR  R14,0                      Save registers
         LAE   R12,0(R15,0)               Get base register
         USING PDSR$IS,R12                Set module base
         SAC   0
         SYSSTATE ASCENV=P
         EREG  R0,R1                      Restore registers R0 and R1
         LR    R13,R1                     Locate RSA and work area
         USING SUBRSA,R13                 Locate to data area
*
** Branch to routine
*
#IS_HEADINGS EQU 1
#IS_FORMAT   EQU 2
*
         CH    R0,=AL2(#IS_HEADINGS)      Want headings?
         BE    IS$HEADINGS
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Format ISPF stats
**
** Input: R2 has PDS entry
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
IS$FORMAT DS 0H
         LA    R4,RECOUT+1                Locate output
         TM    PDS2INDC-PDS2(R2),PDS2ALIS Alias?
         BNO   IS$FALX                    No, continue
         L     R1,PPD_NALIAS              Get current alias count
         LA    R1,1(R1)                   Increment by 1
         ST    R1,PPD_NALIAS              Save current alias count
         MVC   DETALIAS-DET(2,R4),=C'-A'
* Note: we could look at PDS2TTRP and determine real name...
IS$FALX  DS    0H
         TM    PDS2INDC-PDS2(R2),X'0F'    ISPF Stats?
         BO    IS$FSTAT                   Yes, get stats
         L     R1,PPD_NNSSTAT             Get count
         LA    R1,1(R1)                   Increment by 1
         ST    R1,PPD_NNSSTAT             Save count
         B     IS$X                       Continue
IS$FSTAT DS    0H
         LA    R8,PDS2USRD-PDS2(R2)       Locate to user data (Stats)
*
** Version/modification levels
*
         SLR   R1,R1                      Clear register
         IC    R1,UDISPF_VER-UDISPF(R8)   Get Version
         CVD   R1,DOUBLE                  Convert to packed
         UNPK  DET_IVER-DET(2,R4),DOUBLE+6(2) Convert to zoned
         OI    DET_IVER-DET+1(R4),X'F0'   Fix sign byte
         MVI   DET_IVMD-DET(R4),C'.'      Move in delimiter
         SLR   R1,R1                      Clear register
         IC    R1,UDISPF_MOD-UDISPF(R8)   Get Modification
         CVD   R1,DOUBLE                  Convert to packed
         UNPK  DET_IMOD-DET(2,R4),DOUBLE+6(2) Convert to zoned
         OI    DET_IMOD-DET+1(R4),X'F0'   Fix sign byte
*
** Get creation date
*
**       MVI   EJ_IDJULP4_STR,0
**       MVC   EJ_IDJULP4_STR+1(3),UDISPF_CDATE-UDISPF+1(R8)
         MVC   EJ_IDJULP4_STR(4),UDISPF_CDATE-UDISPF(R8)
         LA    R14,DET_ICDATE-DET(R4)
         ST    R14,EJ_ODGEUR11A_STR
         LA    R14,DET_ICDATED-DET(R4)
         ST    R14,EJ_ODDOW3A_STR
         BAS   R9,IS$EDIT_JULIAN
*
** Process changed date and time
*
         MVC   EJ_IDJULP4_STR(4),UDISPF_LDATE-UDISPF(R8)
         LA    R14,DET_ILDATE-DET(R4)
         ST    R14,EJ_ODGEUR11A_STR
         LA    R14,DET_ILDATED-DET(R4)
         ST    R14,EJ_ODDOW3A_STR
         BAS   R9,IS$EDIT_JULIAN
*
         MVC   DET_ILTIME-DET(6,R4),=X'40,20,20,7A,20,21'
         ED    DET_ILTIME-DET(6,R4),UDISPF_LTIME-UDISPF(R8)
*
         SLR   R1,R1
         ICM   R1,B'0011',UDISPF_SIZE-UDISPF(R8)
         BZ    IS$FSIZEX
         TM    PDS2INDC-PDS2(R2),PDS2ALIS Alias?
         BO    IS$FSIZES             Yes, skip increment of size/lines
         L     R15,PPD_SIZE          Get current size
         AR    R15,R1                Add for this member
         ST    R15,PPD_SIZE          Save it
IS$FSIZES DS   0H
         CVD   R1,DOUBLE
         MVC   DET_ISIZE-DET(6,R4),=X'40,20,20,20,20,20'
         ED    DET_ISIZE-DET(6,R4),DOUBLE+5
IS$FSIZEX DS   0H
         OI    DET_ISIZE-DET+5(R4),C'0'
*
         SLR   R1,R1
         ICM   R1,B'0011',UDISPF_INIT-UDISPF(R8)
         BZ    IS$FINITX
         TM    PDS2INDC-PDS2(R2),PDS2ALIS  Alias?
         BO    IS$FINITS             Yes, skip increment of size/lines
         L     R15,PPD_IINIT         Get current size
         AR    R15,R1                Add for this member
         ST    R15,PPD_IINIT         Save it
IS$FINITS DS   0H
         CVD   R1,DOUBLE
         MVC   DET_IINIT-DET(6,R4),=X'40,20,20,20,20,20'
         ED    DET_IINIT-DET(6,R4),DOUBLE+5
IS$FINITX DS   0H
         OI    DET_IINIT-DET+5(R4),C'0'
*
         SLR   R1,R1
         ICM   R1,B'0011',UDISPF_MODL-UDISPF(R8)
         BZ    IS$FMODLX
         TM    PDS2INDC-PDS2(R2),PDS2ALIS Alias?
         BO    IS$FMODLS             Yes, skip increment of size/lines
         L     R15,PPD_IMODL         Get current size
         AR    R15,R1                Add for this member
         ST    R15,PPD_IMODL         Save it
IS$FMODLS DS   0H
         CVD   R1,DOUBLE
         MVC   DET_IMODL-DET(6,R4),=X'40,20,20,20,20,20'
         ED    DET_IMODL-DET(6,R4),DOUBLE+5
IS$FMODLX DS   0H
         OI    DET_IMODL-DET+5(R4),C'0'
*
         MVC   DET_IUID-DET(7,R4),UDISPF_UID-UDISPF(R8)
*
** Here we process the BKLIDs entries.  These entries may have been
** Read in from the //BKLIDS file or userids already looked up via
** RACF calls (see code just below this).
*
         ICM   R9,B'1111',RBF_PTR          Get table address
         BZ    IS$RBEX
         ICM   R0,B'1111',BKLH_USERC-BKLH(R9) Get user count
         BZ    IS$RBEX
         LA    R9,BKLHL(R9)                Bump past header
IS$RBEL  DS    0H
         CLC   BKLE_USER-BKLE(7,R9),UDISPF_UID-UDISPF(R8)
         BE    IS$RBEF
         LA    R9,BKLEL(R9)
         BCT   R0,IS$RBEL
         B     IS$RBEX
IS$RBEF  DS    0H
         LA    R15,DET_IUID+L'DET_IUID+1-DET(R4)
         MVI   0(R15),C'-'
         MVC   2(L'BKLE_NAME,R15),BKLE_NAME-BKLE(R9)
         B     IS$X
IS$RBEX  DS    0H
*
** Ask RACF (nicely) if we can have userid information on this guy
*
* Note: this code is not fully functional.  That is to say that
*       I have only tested it on a system running ACF2 and I see
*       RC=18 (24) - I/O error accessing RACF database. It is possible
*       that this code *may* work on an actual RACF system...
*
         TM    PPC_FLAG5,$PPC_F5CALLRACF  Call RACF?
         BNO   IS$RLX                     Nope, Continue
 MVC   RACF_ENTRY(8),UDISPF_UID-UDISPF(R8) Get TSO user name
 LA    R0,8
 LA    R1,RACF_ENTRYL                     Locate entry
 BAS   R14,SET_ENTRY_LENGTH               Set entry length
*
 CLI   RACF_ENTRY,C' '                    Have a TSO UserID yet?
 BE    IS$RLX                             No, skip it
 CLI   RACF_ENTRY,0                       Have a TSO UserID yet?
 BE    IS$RLX                             No, skip it
*
 XC    WORKAREA(256),WORKAREA             Clear first 256 bytes
 LA    R1,L'WORKAREA                      Get length of WKAREA
 ST    R1,WORKAREA                        Save it
 MVC   PARMLIST(C_RLOCUL),C_RLOCU         Initialize parameter list
 ICHEINTY LOCATE,TYPE='USR',              Get USER information         @
               ENTRY=RACF_ENTRYL,         ..UserID Location            @
               WKAREA=WORKAREA,           ..Return area                @
               MF=(E,PARMLIST)            ..Execute from here
 LTR   R15,R15
 BNZ   IS$RLE
 SLR   R14,R14                            Clear register
 ICM   R14,B'0001',WORKAREA+31            Get programmer name length
 BZ    IS$RLX                             Zero, leave
         LA    R15,DET_IUID+L'DET_IUID+1-DET(R4)
         MVI   0(R15),C'-'
 BCTR  R14,0                              Decrement for EX
 EX    R14,IS$RLM                         Get programmer name
*-Here we should insert code to save userids into BKL control block
 B     IS$RLX
IS$RLE DS    0H
 ST    R15,DOUBLE
         LA    R15,DET_IUID+L'DET_IUID+1-DET(R4)
         MVI   0(R15),C'-'
         MVC   2(19,R15),=C'icheinty locate rc='
         LA    R15,2+19(R15)
         UNPK  0(9,R15),DOUBLE(5)
         MVZ   0(8,R15),=8X'00'
         TR    0(8,R15),=C'0123456789ABCDEF'
         MVI   8(R15),C' '
         B     IS$RLX
IS$RLM MVC   2(0,R15),WORKAREA+32         Get programmer name
*
C_RLOCU  ICHEINTY LOCATE,TYPE='USR',                                   @
               ACTIONS=(C_UNAME),         ..User Name                  @
               RELEASE=1.8,               ..RACF release               @
               MF=L
C_RLOCUL EQU   *-C_RLOCU
*
C_UNAME  ICHEACTN FIELD=NAME,MF=L
IS$RLX DS 0H
         B     IS$X
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Misc int subroutines
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
*
** Set RACF entry length
** Input: R0 - max length of entry
**        R1 - address of entry
*
SET_ENTRY_LENGTH EQU *
 LA    R15,1(R1)                          Bump past length byte
SEL$L EQU *
 CLI   0(R15),C' '                        Blank?
 BE    SEL$LX                             Yes, leave
 CLI   0(R15),0                           Zero?
 BE    SEL$LX                             Yes, leave
 LA    R15,1(R15)                         No, bump to next byte
 BCT   R0,SEL$L                           Repeat
SEL$LX EQU *
 BCTR  R15,0                              Decrement for EX
 SR    R15,R1                             Length = End - Beginning
 STC   R15,0(R1)                          Save length
 BSM   0,R14
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Create headings
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
IS$HEADINGS DS 0H
         LA    R15,PRR_IHEAD1             Locate heading record
         MVI   0(R15),C' '                Get Blank
         MVC   1(L'RECOUT-1,R15),0(R15)   ..Propagate it
         LA    R15,1(R15)                 Bump past FBA byte
         USING DET,R15
         L     R1,=V(PDSR$C2)             -> Constants CSECT
         USING PDSR$C2,R1
         MVC   DETMEM(6),C_DETMEM
         MVC   DETADDR(3),C_DETADDR
         MVC   DETALIAS(5),C_DETALIAS
         MVC   DET_IVER(5),C_DET_IVER
         MVC   DET_ICDATE+5(7),C_DET_ICDATE
         MVC   DET_ILDATE+7(7),C_DET_ILDATE
         MVC   DET_ISIZE+2(4),C_DET_ISIZE
         MVC   DET_IINIT+2(4),C_DET_IINIT
         MVC   DET_IMODL+3(3),C_DET_IMODL
         MVC   DET_IUID(6),C_DET_IUID
         DROP  R15,R1
*
         LA    R15,PRR_IHEAD2             Locate heading record
         MVI   0(R15),C' '                Get Blank
         MVC   1(L'RECOUT-1,R15),0(R15)   ..Propagate it
         LA    R15,1(R15)                 Bump past FBA byte
         USING DET,R15
         L     R1,=V(PDSR$C2)             -> Constants CSECT
         USING PDSR$C2,R1
         MVC   DETMEM(L'DETMEM),C_DASHS+1
         MVC   DETADDR(L'DETADDR),C_DASHS+1
         MVC   DETALIAS(L'DETALIAS),C_DASHS+1
         MVC   DET_IVER(DET_IVVMML),C_DASHS+1
         MVC   DET_ICDATE(DET_ICDATEL),C_DASHS+1
         MVC   DET_ILDATE(DET_ILTODL),C_DASHS+1
         MVC   DET_ISIZE(L'DET_ISIZE),C_DASHS+1
         MVC   DET_IINIT(L'DET_IINIT),C_DASHS+1
         MVC   DET_IMODL(L'DET_IMODL),C_DASHS+1
         MVC   DET_IUID(L'DET_IUID),C_DASHS+1
         DROP  R15,R1
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Common Exit from ISPF_Statistics
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
IS$X     DS    0H
         PR    ,                          Return to caller
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Edit input Julian to output area
**
** Keep in sync with EDIT_JULIAN: use same code!!!!!!
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
IS$EDIT_JULIAN EQU *
         L     R1,=V(PDSR$C1)
         MVC   EJ_IDJULP4(C_IDJULP4L),C_IDJULP4-PDSR$C1(R1)
         MVC   EJ_ODGEUR11A(C_ODGEUR11AL),C_ODGEUR11A-PDSR$C1(R1)
         TM    PPC_IFLAG1,$PPC_IF1DATEISO ISO format?
         BO    IS$EJ$CDISO
         TM    PPC_IFLAG1,$PPC_IF1DATEUS  United States format?
         BNO   IS$EJ$CDISOX               Use default of "European"
         MVI   EJ_ODGEUR11A_TYPE+1,$DA#DATE_ODGUS Make Gregorian US
         MVI   EJ_ODGEUR11A_STRL,$DA#DATE_ODGUS10 Set length
         B     IS$EJ$CDISOX
IS$EJ$CDISO DS 0H
         MVI   EJ_ODGEUR11A_TYPE+1,$DA#DATE_ODISO Make ISO
         MVI   EJ_ODGEUR11A_STRL,$DA#DATE_ODISO10 Set length
IS$EJ$CDISOX DS 0H
         MVC   EJ_ODDOW3A(C_ODDOW3AL),C_ODDOW3A-PDSR$C1(R1)
         DA#SMODE 31                      Must be in 31 bit mode
         L     R15,EP_DA$DATE             Locate EPA of DA$DATE routine
         CALL  (15),(EJ_IDJULP4,EJ_ODGEUR11A,EJ_ODDOW3A),              @
               VL,MF=(E,PARMLIST)
         DA#SMODE 24                      Back to 24 bit mode
         BSM   0,R9
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**       Constants
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
         LTORG ,                          Literals
*
** Calculate length of module
*
#PDSR$IS EQU   *-PDSR$IS
#PDSR$IS_LEFT EQU 4096-#PDSR$IS
         DROP  R13,R12
         EJECT
***********************************************************************
***
**       Dataset Summary processing
**
**       This CSECT was created to save room in primary CSECT
***
***********************************************************************
         SPACE 2
PDSR$DSP CSECT ,
PDSR$DSP AMODE 24
PDSR$DSP RMODE 24
*
** Standard O/S eyecatcher
*
DSP_EC        B    DSP_ECL(0,R15)         Bump past EyeCatcher
              DC   AL1(L'DSP_ECLIT)       Length of eyecatcher
DSP_ECLIT     DC   C'PDSR$DSP - Dataset Summary Processing'
              DS   0H
DSP_ECL       EQU  *-DSP_EC
*
** Entry Housekeeping
*
         BAKR  R14,0                      Save registers
         LAE   R12,0(R15,0)               Get base register
         USING PDSR$DSP,R12               Set module base
         SAC   0
         SYSSTATE ASCENV=P
         EREG  R0,R1                      Restore registers R0 and R1
         LR    R13,R1                     Locate RSA and work area
         USING SUBRSA,R13                 Locate to data area
         SPACE 2
*
** Complete this dataset's information
*
         L     R3,PP_DSUMA                Get address of area
         L     R4,DSUMH_CURR-DSUMH(R3)    Get current entry
*
** Look at this datasets attributes
**
** The most I expect here is 7 bytes total used:
**
** "LNK    ",   "LNK APF",  "LPA    ",  "LPA APF",  "APF    "
**
*
         LA    R15,DSUME_ATTR-DSUME(R4)
         TM    PP_FLAG1,$PP_F1LNKLST
         BNO   DSP$ATTR$LNKLSTX
         MVC   0(3,R15),=C'LNK'
         LA    R15,4(R15)
DSP$ATTR$LNKLSTX DS 0H
         TM    PP_FLAG1,$PP_F1LPALST
         BNO   DSP$ATTR$LPALSTX
         MVC   0(3,R15),=C'LPA'
         LA    R15,4(R15)
DSP$ATTR$LPALSTX DS 0H
         TM    PPD_FLAG1,$PPD_F1APF
         BNO   DSP$ATTR$APFLSTX
         MVC   0(3,R15),=C'APF'
         LA    R15,4(R15)
DSP$ATTR$APFLSTX DS 0H
*
** Get fields from the JFCB
*
         LA    R5,AREAJFCB                Locate "JFCB"
         MVC   DSUME_VOL-DSUME(L'DSUME_VOL,R4),JFCBVOLS-INFMJFCB(R5)
         MVC   DSUME_DSN-DSUME(L'DSUME_DSN,R4),JFCBDSNM-INFMJFCB(R5)
         MVC   DSUME_DDNAME-DSUME(L'DSUME_DDNAME,R4),PP_PDDN
*
         LA    R6,AREADSCB                Locate DSCB
         TM    DS1DSORG-DS1FMTID(R6),DS1DSGPO PDS?
         BNO   DSP$POE
         LH    R1,DS1LSTAR-DS1FMTID(R6)   Load tracks used
         N     R1,=X'0000FFFF'            Turn off high order bytes
         LA    R1,1(R1)                   Add one
         L     R0,DSUMH_CNTTRKU-DSUMH(R3) Get total
         AR    R0,R1
         ST    R0,DSUMH_CNTTRKU-DSUMH(R3) save new total
         CVD   R1,DOUBLE                  Convert number to packed
         MVC   DSUME_TRKU-DSUME(6,R4),=X'40,20,20,20,20,20'
         ED    DSUME_TRKU-DSUME(6,R4),DOUBLE+5
*
         L     R1,PPD_TRKA
         L     R0,DSUMH_CNTTRKA-DSUMH(R3) Get total
         AR    R0,R1
         ST    R0,DSUMH_CNTTRKA-DSUMH(R3) save new total
         CVD   R1,DOUBLE                  Convert number to packed
         MVC   DSUME_TRKA-DSUME(6,R4),=X'40,20,20,20,20,20'
         ED    DSUME_TRKA-DSUME(6,R4),DOUBLE+5
*
         SR    R1,R1
         IC    R1,DS1NOEPV-DS1FMTID(R6)   Get extents
*
         TM    PP_FLAG1,$PP_F1LNKLST      Is this a LNKLST dataset?
         BNO   DSP$LEX
         L     R0,DSUMH_LLE-DSUMH(R3)     Get LNKLST extents
         TM    DS1SMSFG-DS1FMTID(R6),DS1PDSE PDSE?
         BO    DSP$LEP                    Yes, count only as 1 extent
         AR    R0,R1                      Add all extents for this guy
         BO    DSP$LEPX                   Continue
DSP$LEP  DS    0H
         AH    R0,=H'1'                   Add only 1 extent for PDSE
DSP$LEPX DS    0H
         ST    R0,DSUMH_LLE-DSUMH(R3)     Save LNKLST extents
DSP$LEX  DS    0H
*
         CVD   R1,DOUBLE                  Convert to packed
         UNPK  DSUME_EXTENTS-DSUME(2,R4),DOUBLE+6(2) Convert to zoned
         OI    DSUME_EXTENTS-DSUME+1(R4),X'F0' Fix sign byte
*
         L     R1,PPD_NMEM                Number of members
         L     R0,DSUMH_CNTMEM-DSUMH(R3)  Get total
         AR    R0,R1
         ST    R0,DSUMH_CNTMEM-DSUMH(R3)  Save new total
         CVD   R1,DOUBLE                  Convert number to packed
         MVC   DSUME_MEMBERS-DSUME(6,R4),=X'40,20,20,20,20,20'
         ED    DSUME_MEMBERS-DSUME(6,R4),DOUBLE+5
         B     DSP$POX
DSP$POE  DS    0H
         MVC   DSUME_ATTR-DSUME(7,R4),=C'Not PDS'
DSP$POX  DS    0H
*
         LA    R15,DSUME_RECFM-DSUME(R4)
         TM    DS1RECFM-DS1FMTID(R6),DS1RECFU
         BO    PJ$DR1U
         TM    DS1RECFM-DS1FMTID(R6),DS1RECFF
         BO    PJ$DR1F
         TM    DS1RECFM-DS1FMTID(R6),DS1RECFV
         BO    PJ$DR1V
         MVI   0(R15),C'?'
         B     PJ$DR1X
PJ$DR1U  EQU   *
         MVI   0(R15),C'U'
         B     PJ$DR1X
PJ$DR1V  EQU   *
         MVI   0(R15),C'V'
         B     PJ$DR1X
PJ$DR1F  EQU   *
         MVI   0(R15),C'F'
PJ$DR1X  EQU   *
         LA    R15,1(R15)
         TM    DS1RECFM-DS1FMTID(R6),DS1RECFB
         BNO   PJ$DR2X
         MVI   0(R15),C'B'
         LA    R15,1(R15)
PJ$DR2X  EQU   *
         TM    DS1RECFM-DS1FMTID(R6),DS1RECFA
         BO    PJ$DR3A
         TM    DS1RECFM-DS1FMTID(R6),DS1RECMC
         BO    PJ$DR3M
         B     PJ$DR3X
PJ$DR3A  EQU   *
         MVI   0(R15),C'A'
         LA    R15,1(R15)
         B     PJ$DR3X
PJ$DR3M  EQU   *
         MVI   0(R15),C'M'
         LA    R15,1(R15)
PJ$DR3X  EQU   *
*
** Locate to next one
*
         LA    R4,DSUMEL(R4)              Locate to next entry
         ST    R4,DSUMH_CURR-DSUMH(R3)    Set next current entry
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Common Exit from Dataset_Summary_Processing
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
DSP$X    DS    0H
         PR    ,                          Return to caller
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**       Constants
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
         LTORG ,                          Literals
*
** Calculate length of module
*
#PDSR$DSP EQU  *-PDSR$DSP
#PDSR$DSP_LEFT EQU 4096-#PDSR$DSP
         DROP  R13,R12
         EJECT
***********************************************************************
***
**       Parse parameter card
***
***********************************************************************
         SPACE 2
*
#PPC_OPTION_PARM  EQU 0                   Option: parse parm card
#PPC_OPTION_SYSIN EQU 1                   Option: parse SYSIN record
#PPC_RC_OK        EQU 0                   Return code: Parse okay
#PPC_RC_EOF       EQU 4                   Return code: EOF on SYSIN
#PPCIRL           EQU 71                  Input Record Length
*
PDSR$PPC CSECT ,
PDSR$PPC AMODE 24
PDSR$PPC RMODE 24
*
** Standard O/S eyecatcher
*
PPC_EC        B    PPC_ECL(0,R15)         Bump past EyeCatcher
              DC   AL1(L'PPC_ECLIT)       Length of eyecatcher
PPC_ECLIT     DC   C'PDSR$PPC - Parse Parameter Card and SYSIN'
              DS   0H
PPC_ECL       EQU  *-PPC_EC
*
** Entry Housekeeping
*
         BAKR  R14,0                      Save registers
         LAE   R12,0(R15,0)               Get base register
         USING PDSR$PPC,R12               Set module base
         SAC   0
         SYSSTATE ASCENV=P
         EREG  R0,R1                      Restore registers R0 and R1
         LR    R13,R1                     Locate RSA and work area
         USING SUBRSA,R13                 Locate to data area
*
** Decide why we are here
*
PARSE_PARAMETER_CARD DS 0H
         NI    PPC_IFLAG1,255-$PPC_IF1DATESET
*
         STC   R0,PPC_OPTION              Save option
         CH    R0,=AL2(#PPC_OPTION_PARM)  Parsing PARM= card?
         BE    PPC$PARM
         CH    R0,=AL2(#PPC_OPTION_SYSIN) Parsing SYSIN?
         BE    PPC$SYSIN
         B     PPC$X
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Parse the SYSIN input file (1 record at a time)
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
PPC$SYSIN DS   0H
         TM    PPCSI_FLAG1,$PPCSI_F1OIF   Opened Input file yet?
         BO    PPC$SIOX
         OI    PPCSI_FLAG1,$PPCSI_F1OIF   We opened SYSIN...
         MVC   PPCSI_NUM(2),PPC_NUM       Save number of errors
         DEVTYPE =CL8'SYSIN',DOUBLE       Is file allocated?
         LTR   R15,R15
         BNZ   PPC$SIEX
         LA    R3,PPCSI_DCB               Locate DCB work area
         L     R1,=V(PDSR$C1)
         MVC   0(C_DCBIL,R3),C_DCBI-PDSR$C1(R1)
         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'SYSIN'    Get DDNAME
         MVC   PARMLIST(C_LSTIL),C_LSTI-PDSR$C1(R1)
         LA    R2,PPC$SIEOF               Locate END-OF-FILE area
         STCM  R2,B'0111',DCBEODAD-IHADCB+1(R3) Insert into DCB
         OPEN  ((3),(INPUT)),MF=(E,PARMLIST)
PPC$SIOX DS    0H
*
** Read and process SYSIN record
*
         GET   PPCSI_DCB                  Get input record - DD=SYSIN
         LR    R7,R1                      Get address of input record
         LA    R6,#PPCIRL                 Set max length to consider
*-Trim trailing blanks on input record
         LR    R1,R7                      Get start of record
         AR    R1,R6                      Locate to last byte (+1)
         BCTR  R1,0                       Backup to last actual byte
PPC$SITL DS    0H
         CLI   0(R1),C' '                 Blank?
         BNE   PPC$SITX                   No, found end of line
         BCTR  R1,0                       Backup one more byte
         BCTR  R6,0                       Decrement line length
         LTR   R6,R6                      Any more to do?
         BNZ   PPC$SITL                   Process next line
PPC$SITX DS    0H
*
         BAS   R14,PPC$SI_FORMAT_MESSAGE  Initialize the message area
         MVC   0(4,R15),MSG2-PDSR$MSG(R1) Move in "002I"
         LA    R15,5(R15)                 Bump past it
         MVC   0(6,R15),=C'SYSIN:'        Insert text
         LA    R15,7(R15)
         MVC   0(#PPCIRL,R15),0(R7)       Get record
         BAS   R14,PPC$SI_PSR             Print Sysprint Record
         LTR   R6,R6                      Blank record?
         BZ    PPC$X                      Yes, no need to parse
         CLI   0(R7),C'*'                 Comment card?
         BE    PPC$X                      Yes, no need to parse
*
         XC    PPC_COL(2),PPC_COL         Start fresh
         XC    PPC_NUM(2),PPC_NUM         Start fresh
         B     PPC$PARSE                  Parse input record
*
** Print the parsing errors for this SYSIN card (if any)
*
PPC$SIPE DS    0H
         SLR   R1,R1                      Zero out register
         ICM   R1,B'0011',PPC_NUM         Get number of parms errors
         BZ    PPC$SIPE_ERRX              None, leave
         AH    R1,PPCSI_NUM               Add to total
         STH   R1,PPCSI_NUM               Save new total
*
         BAS   R14,PPC$SI_FORMAT_MESSAGE  Initialize the message area
         MVC   0(4,R15),MSG3-PDSR$MSG(R1) Move in message ID
         LA    R15,12(R15)                Locate past "002I SYSIN: "
         L     R1,=V(PDSR$C1)
         MVC   0(#PPCIRL,R15),C_COLS-PDSR$C1(R1)
         BAS   R14,PPC$SI_PSR             Print Sysprint Record
*
         BAS   R14,PPC$SI_FORMAT_MESSAGE  Initialize the message area
         MVC   0(MSG3L,R15),MSG3-PDSR$MSG(R1) Move in message
         LA    R15,MSG3L+1(R15)           Bump past it
         LH    R1,PPC_COL                 Get parameter column
         LA    R1,1(R1)                   Start from 1 not zero
         BAS   R9,PPC$SI_EDITFWF          Print column number
         BAS   R14,PPC$SI_PSR             Print Sysprint Record
PPC$SIPE_ERRX DS 0H
         TM    PPC_IFLAG1,$PPC_IF1DATESET Was the Date format set?
         BNO   PPC$SIPE_DSX               No, continue
         BAS   R14,PPC$SI_FORMAT_MESSAGE  Initialize the message area
         MVC   0(MSG59L,R15),MSG59-PDSR$MSG(R1) Move in message
         BAS   R14,PPC$SI_PSR             Print Sysprint Record
PPC$SIPE_DSX DS  0H
         B     PPC$X
*
** End of file on SYSIN
*
PPC$SIEOF DS   0H
         LA    R3,PPCSI_DCB               Locate DCB work area
         TM    DCBOFLGS-IHADCB(R3),DCBOFOPN Is file open?
         BNO   PPC$SIEX
         L     R1,=V(PDSR$C1)
         MVC   PARMLIST(C_CLOSEL),C_CLOSE-PDSR$C1(R1)
         CLOSE ((3)),MF=(E,PARMLIST)      Close it
PPC$SIEX DS    0H
         MVC   PPC_NUM(2),PPCSI_NUM       Save total number of errors
         LA    R15,#PPC_RC_EOF            Get return code
         ST    R15,PPC_RC                 Save it
         B     PPC$X                      Leave
*
** Print SYSPRINT Record
*
PPC$SI_PSR DS  0H
         ST    R14,PSR_RA                 Save return address
         LA    R0,PSRAREA                 Locate work area
         LA    R1,RECOUT                  Locate record to print
         L     R15,=V(PDSR$PSR)           Locate sysprint routine
         BASR  R14,R15                    Print Sysprint Record
         L     R14,PSR_RA                 Get return address
         BSM   0,R14                      Return to caller
*
** Initialize message
**
** Output: R1 has PDSR$MSG
*
PPC$SI_FORMAT_MESSAGE DS 0H
         LA    R15,RECOUT
         MVI   0(R15),C' '
         MVC   1(L'RECOUT-1,R15),0(R15)
         LA    R15,1(R15)
         L     R1,=V(DA$PDSR)             -> main CSECT
         MVC   0(7,R15),5(R1)             Move in "DA$PDSR"
         MVI   7(R15),C'-'                Insert dash
         LA    R15,MSGPREL(R15)           Bump past "DA$PDSR-"
         L     R1,=V(PDSR$MSG)            -> PDSR$MSG CSECT
         BSM   0,R14
*
** Edit full word in Register 1 flush at location in Register 15
** INPUT: R1 - Register to print
**        R15 - Address to put number
*
PPC$SI_EDITFWF  EQU   *
         LTR   R1,R1                      Check for 0
         BZ    PPC$SI_EDITFWF0            Yes, put zero
         CVD   R1,DOUBLE                  No, convert to packec
         LA    R1,DOUBLE2+14              Locate sig digit
         MVC   DOUBLE2(15),PPC$SI_EDITP15
         EDMK  DOUBLE2(15),DOUBLE+2       Edit and save place
         LA    R14,DOUBLE2+16             Locate last possible byte + 1
         SR    R14,R1                     Length = end - start
         BCTR  R14,0                      Decrement for ex
         EX    R14,PPC$SI_EDITFWFM        Move edit number to output
         LA    R15,0(R14,R15)             Bump pointer past number
         MVI   0(R15),C' '
         BSM   0,R9                       Return to caller
PPC$SI_EDITFWFM MVC 0(0,R15),0(R1)
PPC$SI_EDITP15  DC X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'
PPC$SI_EDITFWF0 DS 0H
         MVI   0(R15),C'0'                Put in zero
         LA    R15,1(R15)                 Bump pointer past zero
         BSM   0,R9                       Return to caller
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Parse the PARM= Card
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
PPC$PARM DS    0H
*
** Set defaults
*
         L     R1,=V(PDSR$C1)             -> Constants CSECT
         MVI   PPC_DDPL,6-1               Set value length
         MVC   PPC_DDP(6),C_DD_SYSLIB-PDSR$C1(R1)
         MVC   PPC_WUNIT(8),C_WUNIT-PDSR$C1(R1)
         LA    R1,52
         STH   R1,PPC_LINECNT             Set as default line count
         XC    W_AREA(256),W_AREA         Initialize
*
** See what register 1 has on input to DA$PDSR
*
         L     R1,PPC_R1ENTRY             -> CPPL
         TM    CPPLCBUF-CPPL(R1),X'80'    Was this command called?
         BNO   PPC$NC                     No, need to look at CBUF
*
** We were called, it has a Batch type (EXEC) parameter
*
         L     R7,0(R1)                   Get address of parm
         SLR   R6,R6                      Clear register
         ICM   R6,B'0011',0(R7)           Get length of parm
         BZ    PPC$X                      None, leave
         LA    R7,2(R7)                   Bump past parm length HW
         B     PPC$PARSE                  Parse the input
*
** We were not called, we are a "TSO Command Processor"
*
PPC$NC   EQU   *
         L     R7,CPPLCBUF-CPPL(R1)       Locate Command Buffer
         SLR   R6,R6                      Clear register
         ICM   R6,B'0011',0(R7)           Get total CBUF length
         SLR   R0,R0                      Clear register
         ICM   R0,B'0011',2(R7)           Get total Command name length
         LA    R15,4                      Length of header
         AR    R7,R15                     Bump past header
         SR    R6,R15                     Decrement for header length
         AR    R7,R0                      Bump past Command length
         SR    R6,R0                      Length of data
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**
** Look thru command buffer/parameter for our commands
**
** Input: R7 - Address of command-buffer/Parameter
**        R6 - Length of command-buffer/Parameter
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
PPC$PARSE EQU *
         STM   R6,R7,PPC_BUFFER           Save length and address
         B     PPC$DLMX
*
** Test for valid delimiter between operands
*
PPC$DLM  EQU   *
         CLI   0(R7),C' '                 Valid delimiter?
         BE    PPC$DLMS                   Yes, continue
         CLI   0(R7),C','                 Valid delimiter?
         BNE   PPC$OERR                   No, print error message
PPC$DLMS EQU   *
         LA    R7,1(R7)                   Bump past delimiter
         BCT   R6,PPC$DLMX                Decrement count
         B     PPC$END                    Hit zero: leave
PPC$DLMX EQU   *
*
** Process keywords into program flags.
**
** This loop compares the value at R7 with flag strings and when
** there is a match, we dynamically create an "OI" machine instruction
** to turn on the flag. For example, if PARM='LNKLST" is matched, this
** machine instruction is generated:
**
**      OI   PPC_FLAG1,$PPC_F1LNKLST
**
** Since the PPC_FLAGx fields are in the WORKDS/SUBRSA area, the instr
** must be based off R13 (hex "D") for it to update the right area.
*
         LA    R3,T_PFLAGSN               Get number of entries
         LA    R2,T_PFLAGS                Locate flag
PPC$FL   EQU   *
         SLR   R15,R15                    Clear register
         ICM   R15,B'0011',TPF_NAME-TPF(R2) Get offset of name string
         AR    R15,R12                    Locate name string (TPF_???)
         SLR   R14,R14                    Get ready for "IC"
         IC    R14,0(R15)                 Get length of string
         CR    R14,R6                     Room left for keyword?
         BH    PPC$FLB                    No, skip this table entry
         EX    R14,PPC$FNC                Match?
         BE    PPC$FLX                    Yes, continue
PPC$FLB  EQU   *
         LA    R2,TPFL(R2)                Bump to next entry
         BCT   R3,PPC$FL                  ..Process it
         B     PPC$FX                     Continue: not a flag
PPC$FNC  CLC   1(0,R15),0(R7)
PPC$FOI  OI    *-*,4
PPC$FLX  DS    0H
         MVC   DOUBLE(4),PPC$FOI          Get Instruction
         MVC   DOUBLE+1(1),TPF_FLAG-TPF(R2)    Set flag
         MVC   DOUBLE+2(2),TPF_OFFSET-TPF(R2) Get offset
         OI    DOUBLE+2,X'D0'             Register 13/SUBRSA
**-Start of debugging code -----------------------------------------
** This code block can be uncommented and run for debugging when you
** want to see the machine instruction that gets dynamically created
** to set flags on based on the option value
*==>     STM  R14,R15,DOUBLE2
*==>     LA   R15,PPCWTO+8
*==>     MVC  0(10,R15),=C'MachInstr='
*==>     LA   R15,10(R15)
*==>     UNPK 0(9,R15),DOUBLE(5)
*==>     MVZ  0(8,R15),=8X'00'
*==>     TR   0(8,R15),=C'0123456789abcdef'
*==>     MVI  8(R15),C' '
*==>     L    R1,DOUBLE2+4
*==>     MVC  9(0,R15),1(R1)
*==>     EX   R14,*-6
*==> PPCWTO WTO '                                                  '
*==>     L  R14,DOUBLE2
**-End of debugging code -----------------------------------------
*
         LA    R15,0                      Set up for EX
         EX    R15,DOUBLE                 Execute: OI field,flag
         LA    R14,1(R14)                 Increment after EX
         AR    R7,R14                     Bump past known length
         SR    R6,R14                     Subtract from total
         LTR   R6,R6                      Check out length
         BZ    PPC$END                    Zero, leave
         BM    PPC$END                    Zero, leave
PPC$FLDL EQU   *
         CLI   0(R7),C' '                 Valid Delimiter?
         BE    PPC$DLMS
         CLI   0(R7),C','                 Valid Delimiter?
         BE    PPC$DLMS
         LA    R7,1(R7)                   Bump past extra byte
         BCT   R6,PPC$FLDL                Process next one
         B     PPC$END                    End of the Parameter string
PPC$FX   EQU   *
*
** DD name prefix (TIOT)
*
PPC$DDP  EQU   *
         CLC   0(7,R7),=C'PREFIX='        Overriding DD prefix?
         BNE   PPC$DDPX                   No, continue
         LA    R7,7(R7)                   Bump past "PREFIX="
         SH    R6,=H'7'                   Decrement for length
         LTR   R6,R6                      Check out length
         BZ    PPC$OERR                   Zero, leave
         LA    R1,PPC_DDP                 Locate output
         LA    R14,7                      Set max
         SLR   R15,R15                    Set count
PPC$DDPL EQU   *
         MVC   0(1,R1),0(R7)              Move input byte
         LA    R7,1(R7)                   Bump to next input byte
         LA    R1,1(R1)                   Bump to next output byte
         BCTR  R14,0                      Decrement max count
         LTR   R14,R14                    Check for overflow...
         BZ    PPC$OERR                   Yes, continue
         LA    R15,1(R15)                 Increment count
         CLI   0(R7),C','                 Found delimiter?
         BE    PPC$DDPLX                  Yes, leave
         BCT   R6,PPC$DDPL                Process next byte
PPC$DDPLX EQU  *
         BCTR  R15,0                      Decrement for later
         STC   R15,PPC_DDPL               Save count
         BCTR  R6,0                       Decrement count
         LTR   R6,R6                      Check count
         BZ    PPC$END                    Zero, at end of parameter
         BM    PPC$END                    Zero, at end of parameter
         B     PPC$DLM                    Process next option
PPC$DDPX EQU   *
*
** Date format
*
PPC$DF   EQU   *
         CLC   0(5,R7),=C'DATE='          Overriding Date format?
         BNE   PPC$DFX                    No, continue
         MVC   PPC_DATEFV+2(2),=C'  '     Ensure trailing blanks
         LA    R7,5(R7)                   Bump past "DATE="
         SH    R6,=H'5'                   Decrement for length
         LTR   R6,R6                      Check out length
         BZ    PPC$OERR                   Zero, leave
         LA    R1,PPC_DATEFV              Locate output
         LA    R14,5                      Set max
         SLR   R15,R15                    Set count
PPC$DFL  DS    0H
         MVC   0(1,R1),0(R7)              Move input byte
         LA    R7,1(R7)                   Bump to next input byte
         LA    R1,1(R1)                   Bump to next output byte
         BCTR  R14,0                      Decrement max count
         LTR   R14,R14                    Check for overflow...
         BZ    PPC$OERR                   Yes, continue
         LA    R15,1(R15)                 Increment count
         CLI   0(R7),C','                 Found delimiter?
         BE    PPC$DFLX                   Yes, leave
         BCT   R6,PPC$DFL                 Process next byte
PPC$DFLX DS    0H
         BCTR  R15,0                      Decrement for later
         OI    PPC_IFLAG1,$PPC_IF1DATESET
         CLI   PPC_DATEFV,C'E'            Looks like "EUR"?
         BE    PPC$DFSE
         CLI   PPC_DATEFV,C'U'            Looks like "US"?
         BE    PPC$DFSU
         CLI   PPC_DATEFV,C'I'            Looks like "ISO"?
         BE    PPC$DFSI                   None, they made a mistake
PPC$DFSERR DS  0H
         OI    PPC_IFLAG1,$PPC_IF1DATEERR
         BCTR  R6,0                       Decrement count
         B     PPC$OERR
PPC$DFSI DS    0H
         OI    PPC_IFLAG1,$PPC_IF1DATEISO
         CLC   PPC_DATEFV(3),=C'ISO'      Looks okay?
         BE    PPC$DFSX
         CLC   PPC_DATEFV(3),=C'I  '      Looks okay?
         BE    PPC$DFSX
         B     PPC$DFSERR
PPC$DFSE DS    0H
         CLC   PPC_DATEFV(3),=C'EUR'      Looks okay?
         BE    PPC$DFSX
         CLC   PPC_DATEFV(3),=C'E  '      Looks okay?
         BE    PPC$DFSX
         B     PPC$DFSERR
PPC$DFSU DS    0H
         OI    PPC_IFLAG1,$PPC_IF1DATEUS
         CLC   PPC_DATEFV(3),=C'US '      Looks okay?
         BE    PPC$DFSX
         CLC   PPC_DATEFV(3),=C'U  '      Looks okay?
         BNE   PPC$DFSERR
PPC$DFSX DS    0H
         BCTR  R6,0                       Decrement count
         LTR   R6,R6                      Check count
         BZ    PPC$END                    Zero, at end of parameter
         BM    PPC$END                    Zero, at end of parameter
         B     PPC$DLM                    Process next option
PPC$DFX  DS    0H
*
** FINDMEM=member
**
** Note: There is a logic error in here somewhere, FINDMEM=12345678
**       fails but FINDMEM=1234567 works.  10JAN1998@DAlcock
*
PPC$FM   EQU   *
         CLC   0(8,R7),=C'FINDMEM='       Finding a member?
         BNE   PPC$FMX                    No, continue
         LA    R7,8(R7)                   Bump past "FINDMEM="
         SH    R6,=H'8'                   Decrement for length
         LTR   R6,R6                      Check out length
         BZ    PPC$OERR                   Zero, leave
         LA    R1,PPC_FM                  Locate output
         MVC   0(8,R1),=CL8' '            Get trailing blanks
         LA    R14,8                      Set max
         SLR   R15,R15                    Set count
PPC$FML  DS    0H
         MVC   0(1,R1),0(R7)              Move input byte
         LA    R7,1(R7)                   Bump to next input byte
         LA    R1,1(R1)                   Bump to next output byte
 LA    R15,1(R15)                 Increment count
 CLI   0(R7),C','                 Found delimiter?
 BE    PPC$FMLX                   Yes, leave
         BCTR  R14,0                      Decrement max count
         LTR   R14,R14                    Check for overflow...
         BZ    PPC$OERR                   Yes, continue
         BCT   R6,PPC$FML                 Process next byte
PPC$FMLX DS    0H
         BCTR  R15,0                      Decrement for later
****
         LA    R14,PPC_FM                 Locate start of field
         AR    R14,R15                    Locate last character
         CLI   0(R14),C'*'                Generic?
         BE    PPC$FMG                    Yes, continue
         CLI   0(R14),C'/'                Generic?
         BNE   PPC$FMGX                   No, continue
PPC$FMG  DS    0H
*-Note: Since FINDMEM=A* results in PPC_FML being zero, we can't just
*-assume that PPC_FML=0 means that no findmem.
         OI    PPC_IFLAG1,$PPC_IF1FMG     FINDMEM was generic
         BCTR  R15,0                      Decrement for generic byte
PPC$FMGX DS    0H
****
         STC   R15,PPC_FML                Save count
         BCTR  R6,0                       Decrement count
         LTR   R6,R6                      Check count
         BZ    PPC$END                    Zero, at end of parameter
         BM    PPC$END                    Zero, at end of parameter
         B     PPC$DLM                    Process next option
PPC$FMX  DS    0H
*
** Line count for output files
*
PPC$LINEC EQU  *
         CLC   0(8,R7),=C'LINECNT='
         BNE   PPC$LINECX                 No, continue
         LA    R7,8(R7)                   Bump past "LINECNT="
         SH    R6,=H'8'                   Decrement for length
         LTR   R6,R6                      Check out length
         BZ    PPC$OERR                   Zero, leave
         LA    R1,DOUBLE                  Locate output
         LA    R14,8                      Set max
         SLR   R15,R15                    Set count
PPC$LINECL EQU *
         MVC   0(1,R1),0(R7)              Move input byte
         LA    R7,1(R7)                   Bump to next input byte
         LA    R1,1(R1)                   Bump to next output byte
         BCTR  R14,0                      Decrement max count
         LTR   R14,R14                    Check for overflow...
         BZ    PPC$LINECLX                Yes, continue
         LA    R15,1(R15)                 Increment count
         CLI   0(R7),C','                 Found delimiter?
         BE    PPC$LINECLX                Yes, leave
         BCT   R6,PPC$LINECL              Process next byte
PPC$LINECLX EQU *
         BCTR  R15,0                      Decrement for later
         EX    R15,PPC$LINECP             Save count
         CVB   R1,DOUBLE2                 Convert it to binary
         STH   R1,PPC_LINECNT             Save it
         BCTR  R6,0                       Decrement count
         LTR   R6,R6                      Check count
         BZ    PPC$END                    Zero, at end of parameter
         BM    PPC$END                    Zero, at end of parameter
         B     PPC$DLM                    Process next option
PPC$LINECP PACK DOUBLE2(8),DOUBLE(0)
PPC$LINECX DS  0H
*
** Parameter in error: isolate it, note position and continue
*
PPC$OERR EQU   *
         SLR   R1,R1                      Clear out register
         ICM   R1,B'0011',PPC_COL         Get previous parm err column
         BNZ   PPC$GNUM                   Yes, go increment number
         L     R1,PPC_BUFFER              Get length of buffer
         SR    R1,R6                      Get location
         STH   R1,PPC_COL                 Save location of error
PPC$GNUM EQU   *
         LH    R1,PPC_NUM                 Get number of errors in parm
         LA    R1,1(R1)                   Increment by 1
         STH   R1,PPC_NUM                 Save for later
PPC$RR   EQU   *
         CLI   0(R7),C','                 Hit a comma yet?
         BE    PPC$BRK                    Yes, leave
         LA    R7,1(R7)                   Bump to next byte
         BCT   R6,PPC$RR                  Test it out
         B     PPC$END                    End of parms...
PPC$BRK  EQU   *
         LA    R7,1(R7)                   Bump past comma
         LTR   R6,R6                      Test for zero length
         BZ    PPC$END                    Yes, end rigth now
         BM    PPC$END                    Yes, end rigth now
         BCT   R6,PPC$DLMX                No, let's test some more
*
** End of parameters found
*
PPC$END  EQU   *
         CLI   PPC_OPTION,#PPC_OPTION_SYSIN  Processing SYSIN?
         BE    PPC$SIPE                   Print errors (if any)
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Common Exit from Parse_Parameter_Card
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
PPC$X    EQU   *
         L     R15,PPC_RC                 Get return code
         PR    ,                          Return to caller
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**       Constants
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
         LTORG ,                          Literals
*
** Parse flags (mapped by TPF DSECT)
*
T_PFLAGS DS  0H
 DC AL1($PPC_F1DATONLY),AL2(TPF_DATAONLY-PDSR$PPC,PPC_FLAG1-SUBRSA)
 DC AL1($PPC_F1NOBREAK),AL2(TPF_NOBREAK-PDSR$PPC,PPC_FLAG1-SUBRSA)
 DC AL1($PPC_F1CHKDUP),AL2(TPF_CHKDUP-PDSR$PPC,PPC_FLAG1-SUBRSA)
 DC AL1($PPC_F1CHKDUP),AL2(TPF_CHKDUP2-PDSR$PPC,PPC_FLAG1-SUBRSA)
 DC AL1($PPC_F1MEMXREF),AL2(TPF_MEMXREF-PDSR$PPC,PPC_FLAG1-SUBRSA)
 DC AL1($PPC_F1NODET),AL2(TPF_NODET-PDSR$PPC,PPC_FLAG1-SUBRSA)
 DC AL1($PPC_F1NODET),AL2(TPF_NODET2-PDSR$PPC,PPC_FLAG1-SUBRSA)
 DC AL1($PPC_F1SIMULATE),AL2(TPF_SIMULATE-PDSR$PPC,PPC_FLAG1-SUBRSA)
*
 DC AL1($PPC_F2LNKLST),AL2(TPF_LNKLST-PDSR$PPC,PPC_FLAG2-SUBRSA)
 DC AL1($PPC_F2LPALST),AL2(TPF_LPALST-PDSR$PPC,PPC_FLAG2-SUBRSA)
 DC AL1($PPC_F2DUMPDIRE),AL2(TPF_DUMPDIRE-PDSR$PPC,PPC_FLAG2-SUBRSA)
 DC AL1($PPC_F2DUMPDIRE),AL2(TPF_DUMPDIRE2-PDSR$PPC,PPC_FLAG2-SUBRSA)
 DC AL1($PPC_F2DUMPDIRE),AL2(TPF_DUMPDIRE3-PDSR$PPC,PPC_FLAG2-SUBRSA)
 DC AL1($PPC_F2DUMPBLDL),AL2(TPF_DUMPBLDL-PDSR$PPC,PPC_FLAG2-SUBRSA)
 DC AL1($PPC_F2DUMPDSCB),AL2(TPF_DUMPDSCB-PDSR$PPC,PPC_FLAG2-SUBRSA)
 DC AL1($PPC_F2HELP),AL2(TPF_HELP-PDSR$PPC,PPC_FLAG2-SUBRSA)
*
 DC AL1($PPC_F3LOADMOD),AL2(TPF_LOADMOD-PDSR$PPC,PPC_FLAG3-SUBRSA)
 DC AL1($PPC_F3ECRPT),AL2(TPF_ECRPT-PDSR$PPC,PPC_FLAG3-SUBRSA)
 DC AL1($PPC_F3ZAPRPT),AL2(TPF_ZAPRPT-PDSR$PPC,PPC_FLAG3-SUBRSA)
 DC AL1($PPC_F3COBCRPT),AL2(TPF_COBCRPT-PDSR$PPC,PPC_FLAG3-SUBRSA)
*
 DC AL1($PPC_F4NTRANID),AL2(TPF_NOTRANID-PDSR$PPC,PPC_FLAG4-SUBRSA)
 DC AL1($PPC_F4TRANR),AL2(TPF_TRANRPT-PDSR$PPC,PPC_FLAG4-SUBRSA)
 DC AL1($PPC_F4HISTR),AL2(TPF_HISTRPT-PDSR$PPC,PPC_FLAG4-SUBRSA)
 DC AL1($PPC_F4NOSMS),AL2(TPF_NOSMS-PDSR$PPC,PPC_FLAG4-SUBRSA)
 DC AL1($PPC_F4ONLYF),AL2(TPF_ONLYFIND-PDSR$PPC,PPC_FLAG4-SUBRSA)
 DC AL1($PPC_F4TSOVIEW),AL2(TPF_TSOVIEW-PDSR$PPC,PPC_FLAG4-SUBRSA)
 DC AL1($PPC_F4NOSYSIN),AL2(TPF_NOSYSIN-PDSR$PPC,PPC_FLAG4-SUBRSA)
 DC AL1($PPC_F4FLATOUT),AL2(TPF_FLATOUT-PDSR$PPC,PPC_FLAG4-SUBRSA)
*
 DC AL1($PPC_F5IVCSECTF),AL2(TPF_IVCSECTF-PDSR$PPC,PPC_FLAG5-SUBRSA)
 DC AL1($PPC_F5IVCSECTF),AL2(TPF_IVCSECTF2-PDSR$PPC,PPC_FLAG5-SUBRSA)
 DC AL1($PPC_F5IVCSECTF),AL2(TPF_IVCSECTF3-PDSR$PPC,PPC_FLAG5-SUBRSA)
 DC AL1($PPC_F5IVCSECTS),AL2(TPF_IVCSECTS-PDSR$PPC,PPC_FLAG5-SUBRSA)
 DC AL1($PPC_F5IVCSECTS),AL2(TPF_IVCSECTS2-PDSR$PPC,PPC_FLAG5-SUBRSA)
 DC AL1($PPC_F5IVCSECTS),AL2(TPF_IVCSECTS3-PDSR$PPC,PPC_FLAG5-SUBRSA)
 DC AL1($PPC_F5NIVENDOR),AL2(TPF_NIVENDOR-PDSR$PPC,PPC_FLAG5-SUBRSA)
 DC AL1($PPC_F5NIVENDOR),AL2(TPF_NIVENDOR2-PDSR$PPC,PPC_FLAG5-SUBRSA)
 DC AL1($PPC_F5NIVENDOR),AL2(TPF_NIVENDOR3-PDSR$PPC,PPC_FLAG5-SUBRSA)
 DC AL1($PPC_F5NVENDORL),AL2(TPF_NVENDORL-PDSR$PPC,PPC_FLAG5-SUBRSA)
 DC AL1($PPC_F5NVENDORL),AL2(TPF_NVENDORL2-PDSR$PPC,PPC_FLAG5-SUBRSA)
 DC AL1($PPC_F5NVENDORL),AL2(TPF_NVENDORL3-PDSR$PPC,PPC_FLAG5-SUBRSA)
  DC AL1($PPC_F5NOEAGLE),AL2(TPF_NOEAGLE-PDSR$PPC,PPC_FLAG5-SUBRSA)
     DC AL1($PPC_F5EODC),AL2(TPF_EODC-PDSR$PPC,PPC_FLAG5-SUBRSA)
 DC AL1($PPC_F5CALLRACF),AL2(TPF_CALLRACF-PDSR$PPC,PPC_FLAG5-SUBRSA)
T_PFLAGSN EQU   (*-T_PFLAGS)/TPFL
*
** Parse name strings
**
** The longer names are intended for //SYSIN and not the parm card
*
TPF_DATAONLY    DA#STR 'DATAONLY'
TPF_NOBREAK     DA#STR 'NOBREAK'
TPF_CHKDUP      DA#STR 'CHKDUP'
TPF_CHKDUP2     DA#STR 'CHECKDUPLICATES'
TPF_MEMXREF     DA#STR 'MEMXREF'
TPF_NODET       DA#STR 'NODET'
TPF_NODET2      DA#STR 'NODETAIL'
TPF_SIMULATE    DA#STR 'SIMULATE'
*
TPF_LNKLST      DA#STR 'LNKLST'
TPF_LPALST      DA#STR 'LPALST'
TPF_DUMPDIRE    DA#STR 'DUMPDIRE'
TPF_DUMPDIRE2   DA#STR 'DUMPDIRECTORYENTRIES'
TPF_DUMPDIRE3   DA#STR 'DUMP_DIRECTORY_ENTRIES'
TPF_DUMPBLDL    DA#STR 'DUMPBLDL'
TPF_CALLRACF    DA#STR 'CALLRACF'
TPF_DUMPDSCB    DA#STR 'DUMPDSCB'
TPF_HELP        DA#STR 'HELP'
*
TPF_LOADMOD     DA#STR 'LOADMOD'
TPF_ECRPT       DA#STR 'ECRPT'
TPF_ZAPRPT      DA#STR 'ZAPRPT'
TPF_COBCRPT     DA#STR 'COBCRPT'
*
TPF_NOTRANID    DA#STR 'NOTRANID'
TPF_TRANRPT     DA#STR 'TRANRPT'
TPF_HISTRPT     DA#STR 'HISTRPT'
TPF_NOSMS       DA#STR 'NOSMS'
TPF_ONLYFIND    DA#STR 'ONLYFIND'
TPF_TSOVIEW     DA#STR 'TSOVIEW'
TPF_NOSYSIN     DA#STR 'NOSYSIN'
TPF_FLATOUT     DA#STR 'FLATOUT'
*
TPF_IVCSECTF    DA#STR 'IVCSECTF'
TPF_IVCSECTF2   DA#STR 'IGNOREVENDORCSECTFULL'
TPF_IVCSECTF3   DA#STR 'IGNORE_VENDOR_CSECT_FULL'
TPF_IVCSECTS    DA#STR 'IVCSECTS'
TPF_IVCSECTS2   DA#STR 'IGNOREVENDORCSECTSTAT'
TPF_IVCSECTS3   DA#STR 'IGNORE_VENDOR_CSECT_STAT'
TPF_NIVENDOR    DA#STR 'NIVENDOR'
TPF_NIVENDOR2   DA#STR 'NOINTERNALVENDOR'
TPF_NIVENDOR3   DA#STR 'NO_INTERNAL_VENDOR'
TPF_NVENDORL    DA#STR 'NVENDORL'
TPF_NVENDORL2   DA#STR 'NOVENDORLIST'
TPF_NVENDORL3   DA#STR 'NO_VENDOR_LIST'
TPF_NOEAGLE     DA#STR 'NOEAGLE'
TPF_EODC        DA#STR 'EODC'
*
         DS    0D                         End CSECT on double word
*
** Calculate length of module
*
#PDSR$PPC EQU  *-PDSR$PPC
#PDSR$PPC_LEFT EQU 4096-#PDSR$PPC
         DROP  R13,R12
*
** T_PFLAG mapping
*
TPF           DSECT ,
TPF_FLAG      DS    X                     Flag value
TPF_NAME      DS    XL2                   Offset to flag name string
TPF_OFFSET    DS    XL2                   Offset to field in WORKDS
TPFL          EQU   *-TPF
         EJECT
***********************************************************************
***
**  Ignore Vendor CSECT
**
**  Upon input:
**  - R0...points to CSECT name
**  - R1...points to SUBRSA (our register save area)
***
***********************************************************************
 SPACE 2
*
** Entry codes
*
#IVC_INIT EQU  1                       Initialization
#IVC_TERM EQU  2                       Termination
#IVC_PDST EQU  3                       PDS termination
*
** Create a standard O/S eyecatcher
*
PDSR$IVC CSECT ,
PDSR$IVC AMODE 31
PDSR$IVC RMODE ANY
IVCEC    B     IVCECL(0,R15)           Bump past Eyecatcher
         DC    AL1(L'IVCECT)           Length of eyecatcher
IVCECT   DC    C'PDSR$IVC - Ignore Vendor CSECTs'
         DS    0H                      Ensure halfword alignment
IVCECL   EQU   *-IVCEC
*
** Entry housekeeping
*
         BAKR  R14,0                   Save registers
         LAE   R12,0(R15,0)            Get base register
         USING PDSR$IVC,R12            Set module base
*
** Locate input fields and output locations
*
         EREG  R0,R1                   Get CSECT, WORKDS address
         LR    R13,R1                  Get register save area
         USING SUBRSA,R13
*
** Branch to the right routine or continue with check
*
         C     R0,=AL4(#IVC_INIT)      Initialization?
         BE    IVC$INIT
         C     R0,=AL4(#IVC_TERM)      Termination?
         BE    IVC$TERM
         C     R0,=AL4(#IVC_PDST)      PDS termination?
         BE    IVC$PDST
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Check for CSECT in Interal Table and //IVCSECT concatenation
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
IVC$CHK  DS    0H
         ICM   R9,B'1111',IVC_AREA+4   Locate area
         USING IVCA,R9                 Get addressability to it
*
         EREG  R2,R3                   Get R2=PDSRCMD area R3=notused
         USING PDSRCMD,R2              Addressibility
*
         NI    PDSRCMD_IFLAG3,255-$PDSRCMD_IF3IVC Turn off flag
         LR    R8,R0                   Save location of CSECT name
*
         TM    PPC_FLAG5,$PPC_F5NIVENDOR Don't use vendor table?
         BO    IVC$CACHE               Yes, skip using it
*
** Loop through internal table looking for Vendor CSECT matchs
*
         LA    R1,IVCA_VENDOR          Locate to Table
         LA    R0,T_VENDORN            Number in table
IVC$VL   DS    0H
         LH    R14,TVP_PREFL-TVP(R1) Get length
         EX    R14,IVC$VLC             Match?
         BE    IVC$VF                  Yes, continue...
         LA    R1,TVP_DL(R1)           No, bump to next one
         BCT   R0,IVC$VL                   and try it out
         B     IVC$CACHE               No match in internal table
IVC$VLC  CLC   TVP_PREFIX-TVP(0,R1),0(R8)
IVC$VF   DS    0H
         L     R15,TVP_CNTLIB-TVP(R1)  Get count for this library
         LA    R15,1(R15)              Increment by 1
         ST    R15,TVP_CNTLIB-TVP(R1)  Save count for this library
*
** If the user wants a list of CSECTs identified as for vendors, put
** them in a nice little table
**
** I've borrowed the code from my IVCC table and will use the same
** CSECT to map the area to contain the list
*
*
         TM    PPC_FLAG5,$PPC_F5NVENDORL List vendor csects matched?
         BO    IVC$FND                 No, continue
         TM    IVCA_FLAG1,$IVCA_F1MAXC Hit max for table?
         BO    IVC$FND                 Yes, can't add anymore
         DA#SMODE 31                   Get into 31 bit mode
         ICM   R14,B'1111',IVCA_VENDORMT+4 Locate table
         BNZ   IVC$VM                  Have it, ready to search
         L     R0,=AL4(#IVCC)          Get length of area
         GETMAIN RU,LV=(0),LOC=(ANY,ANY) Obtain storage
         STM   R0,R1,IVCA_VENDORMT     Save length and address
         MVC   IVCC_HID-IVCC(4,R1),=CL4'IVCV'
         LR    R14,R1                  Save address of IVCC
         SH    R0,=H'17'               Length - 17 is last possible
         LR    R15,R14                 Get start of area
         AR    R15,R0                  Locate last possible entry
         ST    R15,IVCC_HLAST-IVCC(R14) Save it for later
         MVI   8(R15),X'FF'            Just in case
         MVC   9(7,R15),=CL7'IVCVEND'  Debugging for dumps
         LA    R1,IVCC_HL(R1)          Locate past header
         B     IVC$VAD
IVC$VM   DS    0H
         LA    R1,IVCC_HL(R14)         Bump past header
IVC$VBCL DS    0H
         CLC   0(8,R1),0(R8)           Match?
         BE    IVC$VX                  Yes, continue
         LA    R1,8(R1)                No, skip to next entry
         CLI   0(R1),X'FF'             End yet?
         BNE   IVC$VBCL                No, try it out
IVC$VAP  DS    0H
         L     R1,IVCC_HPREV-IVCC(R14) Locate previous entry
         LA    R1,8(R1)                Locate next slot
         C     R1,IVCC_HLAST-IVCC(R14) In range?
         BL    IVC$VAD
         OI    IVCA_FLAG1,$IVCA_F1MAXV Set max flag
         B     IVC$FND                 Leave
IVC$VAD  DS    0H
         MVC   0(8,R1),0(R8)           Insert new entry
         MVI   8(R1),X'FF'             Mark end of table
         ST    R1,IVCC_HPREV-IVCC(R14) Save entry
IVC$VX   DS    0H
         DA#SMODE 24                   Get back to 24 bit mode
         B     IVC$FND
*
** See if this member has already been found and lurking in the cache
*
IVC$CACHE DS  0H
         DA#SMODE 31                   Set addressing mode to 31
         ICM   R1,B'1111',IVCA_CACHE+4 Locate Cache
         BZ    IVC$CHX                 Not created yet...
         LA    R1,IVCC_HL(R1)          Bump past header
IVC$CHL  DS    0H
         CLC   0(8,R1),0(R8)           Match?
         BE    IVC$FNDM                Yes, continue
         LA    R1,8(R1)                No, skip to next entry
         CLI   0(R1),X'FF'             End yet?
         BNE   IVC$CHL                 No, try it out
IVC$CHX  DS    0H
         DA#SMODE 24                   Set addressing mode to 24
*
** Perform BLDL for the member against //IVCSECT
*
         XC    IVCA_PDS(IVCA_PDSL),IVCA_PDS Clear to zeros
         MVC   IVCA_PDS_FF(2),=AL2(1)  Number of members found
         MVC   IVCA_PDS_LL(2),=AL2(IVCA_PDS_ENTRYL) Move in entry len
         MVC   IVCA_PDS_ENTRY+(PDS2NAME-PDS2)(8),0(R8)
         LA    R3,IVCA_PODCB           Locate DCB
         BLDL  (3),IVCA_PDS            Perform BLDL
         LTR   R15,R15                 Check out BLDL
         BNZ   IVC$X                   CSECT not in //IVCSECT
         L     R1,IVCA_CNTABLDL        Get it
         LA    R1,1(R1)                Increment it
         ST    R1,IVCA_CNTABLDL        Save it
         L     R1,IVCA_CNTLBLDL        Get it
         LA    R1,1(R1)                Increment it
         ST    R1,IVCA_CNTLBLDL        Save it
*
** Found a new member, add to cache
*
         TM    IVCA_FLAG1,$IVCA_F1MAXC Hit max for table?
         BO    IVC$FND                 Yes, can't add anymore
         DA#SMODE 31                   Get into 31 bit mode
         ICM   R14,B'1111',IVCA_CACHE+4 Locate Cache
         BNZ   IVC$CAP                 Have it, ready to append nu 1
#IVCC    EQU   IVCC_HL+(32768*8)       Header + Entries
         L     R0,=AL4(#IVCC)          Get length of area
         GETMAIN RU,LV=(0),LOC=(ANY,ANY) Obtain storage
         STM   R0,R1,IVCA_CACHE        Save length and address
         MVC   IVCC_HID-IVCC(4,R1),=CL4'IVCC'
         LR    R14,R1                  Save address of IVCC
         SH    R0,=H'17'               Length - 17 is last possible
         LR    R15,R14                 Get start of area
         AR    R15,R0                  Locate last possible entry
         ST    R15,IVCC_HLAST-IVCC(R14) Save it for later
         MVI   8(R15),X'FF'            Just in case
         MVC   9(7,R15),=CL7'IVCCEND'  Debugging for dumps
         LA    R1,IVCC_HL(R1)          Locate past header
         B     IVC$CAD
IVC$CAP  DS    0H
         L     R1,IVCC_HPREV-IVCC(R14) Locate previous entry
         LA    R1,8(R1)                Locate next slot
         C     R1,IVCC_HLAST-IVCC(R14) In range?
         BL    IVC$CAD
         OI    IVCA_FLAG1,$IVCA_F1MAXC Set max flag
         B     IVC$FND                 Leave
IVC$CAD  DS    0H
         MVC   0(8,R1),0(R8)           Insert new entry
         MVI   8(R1),X'FF'             Mark new end-of-table
         ST    R1,IVCC_HPREV-IVCC(R14) Save entry location
         B     IVC$FND                 Continue
*
** Found: Match on vendor CSECT in Cache
*
IVC$FNDM DS    0H
         L     R1,IVCA_CNTACM          Get it
         LA    R1,1(R1)                Increment it
         ST    R1,IVCA_CNTACM          Save it
*
         L     R1,IVCA_CNTLCM          Get it
         LA    R1,1(R1)                Increment it
         ST    R1,IVCA_CNTLCM          Save it
         DA#SMODE 24                   Ensure we are back to 24
*
** Found: follow up code
*
IVC$FND  DS    0H
         OI    PDSRCMD_IFLAG3,$PDSRCMD_IF3IVC Turn on flag
         B     IVC$X
         DROP  R2                      PDSRCMD work area
         DROP  R9                      IVCA area
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** PDS (library) termination
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
IVC$PDST DS    0H
         ICM   R9,B'1111',IVC_AREA+4   Locate area
         USING IVCA,R9                 Get addressability to it
*
         BAS   R14,IVC$FORMAT_MESSAGE  Initialize the message area
         MVC   0(MSG110L,R15),MSG110-PDSR$MSG(R1) Move in message
         BAS   R14,IVC$PSR             Print the record
*
         ICM   R0,B'1111',IVCA_CNTLBLDL
         BZ    IVCA$PTM2BX
         BAS   R14,IVC$FORMAT_MESSAGE  Initialize the message area
         MVC   0(MSG112L,R15),MSG112-PDSR$MSG(R1) Move in message
         MVC   MSG112L+1(22,R15),=CL22'BLDL matchs:'
         LA    R15,MSG112L+1+23(R15)   Bump past message
         L     R1,IVCA_CNTLBLDL        Get count
         BAS   R14,IVC_EDITFWF         Edit it
         BAS   R14,IVC$PSR             Print the message
         XC    IVCA_CNTLBLDL(4),IVCA_CNTLBLDL
IVCA$PTM2BX DS 0H
*
         ICM   R0,B'1111',IVCA_CNTLCM
         BZ    IVCA$PTM2CX
         BAS   R14,IVC$FORMAT_MESSAGE  Initialize the message area
         MVC   0(MSG112L,R15),MSG112-PDSR$MSG(R1) Move in message
         MVC   MSG102L+1(22,R15),=CL22'BLDL cache matchs:'
         LA    R15,MSG112L+1+23(R15)   Bump past message
         L     R1,IVCA_CNTLCM          Get count
         BAS   R14,IVC_EDITFWF         Edit it
         BAS   R14,IVC$PSR             Print the message
         XC    IVCA_CNTLCM(4),IVCA_CNTLCM
IVCA$PTM2CX DS 0H
*
** Print totals for this library (if any found)
*
         LA    R4,IVCA_VENDOR          Locate dynamic vendor table
         LA    R5,T_VENDORN            Number in table
         MVI   IVCA_PDS,0              Flag area
         SLR   R8,R8                   Clear total count
IVC$PTVL DS    0H
         ICM   R6,B'1111',TVP_CNTLIB-TVP(R4)
         BZ    IVC$PTVB
         XC    TVP_CNTLIB-TVP(L'TVP_CNTLIB,R4),TVP_CNTLIB-TVP(R4)
         L     R1,TVP_CNTALL-TVP(R4)   Get total library count
         AR    R1,R6                   Add for this library
         ST    R1,TVP_CNTALL-TVP(R4)   Save new total
         AR    R8,R6                   Update total for this library
*
         BAS   R14,IVC$PTVP            Print title message
         BAS   R14,IVC$FORMAT_MESSAGE  Initialize the message area
         MVC   0(MSG114L,R15),MSG114-PDSR$MSG(R1) Move in message
         MVC   MSG114M-MSG114(L'TVP_PREFIX,R15),TVP_PREFIX-TVP(R4)
         L     R14,TVP_DADDR-TVP(R4)   Get address of description str
         SLR   R1,R1
         IC    R1,0(R14)               Get length of string
         EX    R1,IVC$PTVM             Move desc string out
         LA    R15,MSG114L(R15)        Locate past message
         CVD   R6,DOUBLE
         MVC   0(12,R15),=X'40,20,20,20,6B,20,20,20,6B,20,20,20'
         ED    0(12,R15),DOUBLE+3
         BAS   R14,IVC$PSR             Print the record
IVC$PTVB DS    0H
         LA    R4,TVP_DL(R4)           Locate to next output entry
         BCT   R5,IVC$PTVL             Try out next entry
         LTR   R8,R8                   Check out total
         BZ    IVC$PT0
         BAS   R14,IVC$FORMAT_MESSAGE  Initialize the message area
         MVC   0(MSG115L,R15),MSG115-PDSR$MSG(R1) Move in message
         LA    R15,MSG114SL(R15)       Locate to end of " >"
         MVI   0(R15),C'-'             Get line
         MVC   1(MSG114E-MSG114C+12-1,R15),0(R15)
         BAS   R14,IVC$PSR             Print the record
         BAS   R14,IVC$FORMAT_MESSAGE  Initialize the message area
         MVC   0(MSG115L,R15),MSG115-PDSR$MSG(R1) Move in message
         MVC   MSG114SL(18,R15),=C'Total for library:'
         LA    R15,MSG114L(R15)        Locate to end of message
         CVD   R8,DOUBLE
         MVC   0(12,R15),=X'40,20,20,20,6B,20,20,20,6B,20,20,20'
         ED    0(12,R15),DOUBLE+3
         BAS   R14,IVC$PSR             Print the record
         BAS   R14,IVC$CLEAR_RECOUT    Clear output record
         BAS   R14,IVC$PSR             Print the record
         B     IVC$X
IVC$PT0  DS    0H
         BAS   R14,IVC$FORMAT_MESSAGE  Initialize the message area
         MVC   0(MSG111L,R15),MSG111-PDSR$MSG(R1) Move in message
         BAS   R14,IVC$PSR             Print the record
         B     IVC$X
IVC$PTVM MVC   MSG114T-MSG114(0,R15),1(R14)
*
** Print title line first time
*
IVC$PTVP DS    0H
         TM    IVCA_PDS,X'80'          Printed title line yet?
         BO    IVC$PTVPX               Yes, leave
         OI    IVCA_PDS,X'80'          Printed title line yet?
         ST    R14,IVCA_PDS+4          Save return address
         BAS   R14,IVC$FORMAT_MESSAGE  Initialize the message area
         MVC   0(MSG113L,R15),MSG113-PDSR$MSG(R1) Move in message
         BAS   R14,IVC$PSR             Print the record
         L     R14,IVCA_PDS+4          Get return address
IVC$PTVPX DS   0H
         BSM   0,R14
         DROP  R9                      IVCA area
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Initialization
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
IVC$INIT DS    0H
*
** Allocate storage area for PDSR$IVC use
*
         LA    R0,IVCAL
         GETMAIN RU,LV=(0)             Obtain storage
         STM   R0,R1,IVC_AREA          Save length and address
         LR    R9,R1
         USING IVCA,R9
         MVC   IVCA_ID(4),=CL4'IVCA'   Set ID for dumps
         MVC   IVCA_PODCBI(4),=CL4'DCB' Set for dumps
         MVC   IVCA_VENDORI(8),=CL8'VENDOR' set for dumps
         MVC   IVCA_END(4),=CL4'END'   Set for dumps
         XC    IVCA_INIT(IVCA_INITL),IVCA_INIT  Init to zeros
*
** Move the static vendor table to our dynamic storage.  We will then
** convert the offsets of the description strings to addresses and
** init the count areas to zero
*
         L     R1,=V(PDSR$TRT)         Locate to Table CSECT
         LA    R1,T_VENDOR-PDSR$TRT(R1) Locate to static vendor table
         LA    R15,IVCA_VENDOR         Locate dynamic vendor table
         LA    R0,T_VENDORN            Number in table
IVC$IVL  DS    0H
         MVC   0(TVP_IEL,R15),0(R1)    Move in entry
         LH    R14,TVP_OFF-TVP(R1)     Get offset of desc string
         A     R14,IVC_TRT             Locate it
         ST    R14,TVP_DADDR-TVP(R15)  Save address
         XC    TVP_I-TVP(TVP_IL,R15),TVP_I-TVP(R15)
         LA    R1,TVP_SL(R1)           Locate to next input entry
         LA    R15,TVP_DL(R15)         Locate to next output entry
         BCT   R0,IVC$IVL              Try out next entry
*
** If user has DD=IVCSECT allocated, print message and continue
*
         DEVTYPE =CL8'IVCSECT',DOUBLE  Check //IVCSECT allocation
         LTR   R15,R15                 Allocated?
         BZ    IVC$IDD                 Yes, continue
*-Check for Parm=IVCSECTx, No-DD-Allocated and PARM=NIVENDOR and gripe
         TM    PPC_FLAG5,$PPC_F5NIVENDOR Option specified?
         BNO   IVC$X                   No, looks good
         BAS   R14,IVC$FORMAT_MESSAGE  Initialize the message area
         MVC   0(MSG65L,R15),MSG65-PDSR$MSG(R1) Move in message
         BAS   R14,IVC$PSR             Print the record
         OI    IVCA_FLAG1,$IVCA_F1CONP Conflicting parms
         B     IVC$X
*
IVC$IDD  DS    0H
         OI    IVCA_FLAG1,$IVCA_F1FILE Say we have a file
         BAS   R14,IVC$FORMAT_MESSAGE  Initialize the message area
         MVC   0(MSG64L,R15),MSG64-PDSR$MSG(R1) Move in message
         BAS   R14,IVC$PSR             Print the record
*
** Open the DCB to be used to check for vendor modules
*
         L     R1,=V(PDSR$C1)          Locate Constants CSECT
         LA    R3,IVCA_PODCB           Locate DCB
         MVC   0(C_DCBPOL,R3),C_DCBPO-PDSR$C1(R1) Get DCB constant
         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'IVCSECT' Update DDNAME
         MVC   PARMLIST(C_LSTIL),C_LSTI-PDSR$C1(R1) Init parm list
         OPEN  ((3),(INPUT)),          Open the directory              @
               MF=(E,PARMLIST)         ..Parameter List
         B     IVC$X
         DROP  R9
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Termination: Close file and free resources
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
IVC$TERM DS    0H
         ICM   R9,B'1111',IVC_AREA+4   Locate area
         USING IVCA,R9
*
** Trivia about IVCSECT processing
*
         TM    IVCA_FLAG1,$IVCA_F1CONP Conflicting parms?
         BO    IVC$TTX                 Yes, leave
         BAS   R14,IVC$CLEAR_RECOUT    Blank out record
         BAS   R14,IVC$PSR             Print the record
*
         BAS   R14,IVC$FORMAT_MESSAGE  Initialize the message area
         MVC   0(MSG100L,R15),MSG100-PDSR$MSG(R1) Move in message
         BAS   R14,IVC$PSR             Print the record
*
*
         TM    IVCA_FLAG1,$IVCA_F1FILE Have a //IVCSECT DD?
         BNO   IVC$TTFX                No, continue
         BAS   R14,IVC$FORMAT_MESSAGE  Initialize the message area
         MVC   0(MSG102L,R15),MSG102-PDSR$MSG(R1) Move in message
         MVC   MSG102L+1(22,R15),=CL22'BLDL matchs:'
         LA    R15,MSG102L+1+23(R15)   Bump past message
         L     R1,IVCA_CNTABLDL        Get count
         BAS   R14,IVC_EDITFWF         Edit it
         BAS   R14,IVC$PSR             Print the message
*
         BAS   R14,IVC$FORMAT_MESSAGE  Initialize the message area
         MVC   0(MSG102L,R15),MSG102-PDSR$MSG(R1) Move in message
         MVC   MSG102L+1(22,R15),=CL22'BLDL cache matchs:'
         LA    R15,MSG102L+1+23(R15)   Bump past message
         L     R1,IVCA_CNTACM          Get count
         BAS   R14,IVC_EDITFWF         Edit it
         BAS   R14,IVC$PSR             Print the message
IVC$TTFX DS    0H
         TM    PPC_FLAG5,$PPC_F5NIVENDOR Don't use vendor table?
         BO    IVC$TTVX                Yes, skip reporting about it
IVC$TTVX DS    0H
IVC$TTX  DS    0H
*
** Print warning messages about cache and Vendor_Match_Table overflow
*
         TM    IVCA_FLAG1,$IVCA_F1MAXC Maxed out on Cache table?
         BNO   IVC$TMCX                Yes, leave
         BAS   R14,IVC$FORMAT_MESSAGE  Initialize the message area
         MVC   0(MSG118L,R15),MSG118-PDSR$MSG(R1) Move in message
         MVC   MSG118L+1(5,R15),=C'Cache'
         BAS   R14,IVC$PSR             Print the record
IVC$TMCX DS    0H
*
         TM    IVCA_FLAG1,$IVCA_F1MAXV Maxed out on Cache table?
         BNO   IVC$TMVX                Yes, leave
         BAS   R14,IVC$FORMAT_MESSAGE  Initialize the message area
         MVC   0(MSG118L,R15),MSG118-PDSR$MSG(R1) Move in message
         MVC   MSG118L+1(6,R15),=C'Vendor'
         BAS   R14,IVC$PSR             Print the record
IVC$TMVX DS    0H
*
** List out the Vendor match tables if requested
*
         TM    PPC_FLAG5,$PPC_F5NVENDORL List vendor csects matched?
         BO    IVC$TVLX                No, continue
         L     R2,IVCA_CACHE+4         Get length and address
         LA    R3,IVC_C_CACHE
         BAS   R4,IVC$TLIST            List out contents
         L     R2,IVCA_VENDORMT+4      Get length and address
         LA    R3,IVC_C_VENDOR
         BAS   R4,IVC$TLIST            List out contents
IVC$TVLX DS    0H
*
** Close the //IVCSECT file
*
         TM    IVCA_FLAG1,$IVCA_F1FILE File was open?
         BNO   IVC$TCFX                No, continue
         LA    R3,IVCA_PODCB           Locate the DCB
         TM    DCBOFLGS-IHADCB(R3),DCBOFOPN Is file open?
         BNO   IVC$TCFX                No, continue
         L     R1,=V(PDSR$C1)          locate constants CSECT
         MVC   PARMLIST(C_CLOSEL),C_CLOSE-PDSR$C1(R1) Get CLOSE parms
         CLOSE ((3)),MF=(E,PARMLIST)   Close the file
IVC$TCFX DS    0H
*
** Free IVCC area storage
*
         LM    R0,R1,IVCA_CACHE        Get area length and address
         LTR   R0,R0                   Check out length
         BZ    IVC$TFCX                None?
         FREEMAIN RU,LV=(0),A=(1)      Release storage
IVC$TFCX DS    0H
*
** Free IVCV area storage
*
         LM    R0,R1,IVCA_VENDORMT     Get area length and address
         LTR   R0,R0                   Check out length
         BZ    IVC$TFVX                None?
         FREEMAIN RU,LV=(0),A=(1)      Release storage
IVC$TFVX DS    0H
*
** Free IVCA area storage
*
         DROP  R9
         LM    R0,R1,IVC_AREA          Get area length and address
         FREEMAIN R,LV=(0),A=(1)       Release storage
         B     IVC$X                   Leave
*
** List the contents of the cache and Vendor_Module_Table areas
**
** Input: R2 has the address of the table to print
**        R3 has a DA#STR string to append to message 119
*
IVC$TLIST DS   0H
         LTR   R2,R2
         BZ    IVC$TLX
         BAS   R14,IVC$CLEAR_RECOUT    Blank out record
         BAS   R14,IVC$PSR             Print the record
*
         BAS   R14,IVC$FORMAT_MESSAGE  Initialize the message area
         MVC   0(MSG119L,R15),MSG119-PDSR$MSG(R1) Move in message
         LA    R15,MSG119L+1(R15)      Bump past text
         SLR   R14,R14                 Clear register
         IC    R14,0(R3)               Get length of string
         EX    R14,IVC$TMS             Append string to message
         BAS   R14,IVC$PSR             Print the record
*
         DA#SMODE 31
         LA    R2,IVCC_HL(R2)          Locate to first entry
         DA#SMODE 24
IVC$TLLS DS    0H
         LA    R5,RECOUT+76            Locate right border
         BAS   R14,IVC$CLEAR_RECOUT    Blank out record
         LA    R15,RECOUT+14           Locate left border
         DA#SMODE 31
IVC$TLL  DS    0H
         MVC   0(8,R15),0(R2)          Move out csect to output line
         LA    R15,9(R15)              Bump to next output location
         LA    R2,8(R2)                Bump to next input location
         CLI   0(R2),X'FF'             End of the table?
         BE    IVC$TLLX                Yes, print last record
         CR    R15,R5                  Still in bounds?
         BNH   IVC$TLL                 Yes, get next csect
         DA#SMODE 24
         BAS   R14,IVC$PSR             No, print full output line
         B     IVC$TLLS                    and then re-init for line
IVC$TLLX DS    0H
         DA#SMODE 24
         CLI   RECOUT+14,C' '          Anything on last line?
         BE    IVC$TLX                 No, skip print of extra one
         BAS   R14,IVC$PSR             Print the record
IVC$TLX  DS    0H
         BSM   0,R4                    Return to caller
IVC$TMS  MVC   0(0,R15),1(R3)
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Misc internal subroutines
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
*
** Print SYSPRINT Record
*
IVC$PSR  DS    0H
         ST    R14,PSR_RA                 Save return address
         LA    R0,PSRAREA                 Locate work area
         LA    R1,RECOUT                  Locate record to print
         L     R15,=V(PDSR$PSR)           Locate sysprint routine
         BASR  R14,R15                    Print Sysprint Record
         L     R14,PSR_RA                 Get return address
         BSM   0,R14                      Return to caller
*
** Clear output record to blanks
*
IVC$CLEAR_RECOUT   DS 0H
         LA    R15,RECOUT                 Locate output record
         MVI   0(R15),C' '                Get Blank
         MVC   1(L'RECOUT-1,R15),0(R15)   ..Propagate it
         BSM   0,R14                      Return to caller
*
** Initialize message
**
** Output: R1 has PDSR$MSG
*
IVC$FORMAT_MESSAGE DS 0H
         LA    R15,RECOUT
         MVI   0(R15),C' '
         MVC   1(L'RECOUT-1,R15),0(R15)
         LA    R15,1(R15)
         L     R1,=V(DA$PDSR)             -> main CSECT
         MVC   0(7,R15),5(R1)             Move in "DA$PDSR"
         MVI   7(R15),C'-'                Insert dash
         LA    R15,MSGPREL(R15)           Bump past "DA$PDSR-"
         L     R1,=V(PDSR$MSG)            -> PDSR$MSG CSECT
         BSM   0,R14
*
** Edit full word in Register 1 flush at location in Register 15
** INPUT: R1 - Register to print
**        R15 - Address to put number
*
IVC_EDITFWF DS 0H
         LTR   R1,R1                      Check for 0
         BZ    IVC_EDITFWF0               Yes, put zero
         ST    R14,PARMLIST               Save return address
         CVD   R1,DOUBLE                  No, convert to packec
         LA    R1,DOUBLE2+14              Locate sig digit
         MVC   DOUBLE2(15),IVC_EDITP15
         EDMK  DOUBLE2(15),DOUBLE+2 EDIT AND SAVE                 PLACE
         LA    R14,DOUBLE2+16             Locate last possible byte + 1
         SR    R14,R1                     Length = end - start
         BCTR  R14,0                      Decrement for ex
         EX    R14,IVC_EDITFWFM           Move edit number to output
         LA    R15,0(R14,R15)             Bump pointer past number
         MVI   0(R15),C' '
         L     R14,PARMLIST
         BSM   0,R14                      Return to caller
IVC_EDITFWFM MVC 0(0,R15),0(R1)
IVC_EDITP15  DC  X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'
IVC_EDITFWF0 DS     0H
         MVI   0(R15),C'0'                Put in zero
         LA    R15,1(R15)                 Bump pointer past zero
         BSM   0,R14                      Return to caller
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Exit from PDSR$IVC (Ignore Vendor CSECT)
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
IVC$X    DS    0H
         SLR   R15,R15
         PR    ,                        Return to caller
*
** Local constants
*
IVC_C_CACHE  DA#STR 'BLDL against //IVCSECT:'
IVC_C_VENDOR DA#STR 'Internal Vendor Table:'
         DS    0F
IVC_TRT  DC    V(PDSR$TRT)
         LTORG ,
         DROP  R12,R13
         DS    0D
#PDSR$IVC EQU  *-PDSR$IVC
#PDSR$IVC_LEFT EQU 4096-#PDSR$IVC
*
** Map our area
*
IVCA           DSECT ,                     PDSR$IVC area
IVCA_ID        DS    CL4'IVCA'             ..ID for dumps
IVCA_INIT      EQU   *
IVCA_CACHE     DS    2F                    ..Cache of BLDL hits
IVCA_VENDORMT  DS    2F                    ..Vendor Table match list
IVCA_CNTABLDL  DS    F                     ..BLDLs (all)
IVCA_CNTACM    DS    F                     ..Cache Matchs (all)
IVCA_CNTLBLDL  DS    F                     ..BLDLs (library)
IVCA_CNTLCM    DS    F                     ..Cache Matchs (library)
IVCA_FLAG1     DS    B'00000000'           ..Flag 1
$IVCA_F1MAXC   EQU   B'10000000'             ..Maxout in Cache
$IVCA_F1MAXV   EQU   B'01000000'             ..Maxout in Vendor list
$IVCA_F1FILE   EQU   B'00100000'             ..Opened the PO DCB
$IVCA_F1CONP   EQU   B'00010000'             ..Conflicting parms
IVCA_INITL     EQU   *-IVCA_INIT           ..Length of to init to 0
IVCA_PDS       DS    0F                    ..BLDL area
IVCA_PDS_FF    DS    X'00,00'                ..Total number of entries
IVCA_PDS_LL    DS    X'00,00'                ..Length of the area
IVCA_PDS_ENTRY DS    XL(#IVCAENT)            ..Length of a pds entry
#IVCAENT       EQU   PDS2USRD-PDS2           ..-> Length of an entry
IVCA_PDS_USERD DS    CL62                    ..User data
IVCA_PDS_ENTRYL EQU  *-IVCA_PDS_ENTRY        ..Length of PDS entry
IVCA_PDSL      EQU   *-IVCA_PDS              ..Length of PDS area
*
IVCA_PODCBI    DS    CL4'DCB'              ..ID for dumps
IVCA_PODCB     DS    XL(C_DCBPOL)          ..BLDL DCB
*
#IVCA_VENDORL  EQU   T_VENDORN*TVP_DL      ..Length of vendor area
IVCA_VENDORI   DS    CL8'VENDOR'           ..ID for dumps
IVCA_VENDOR    DS    XL(#IVCA_VENDORL)     ..Table of vendor prefixes
IVCA_END       DS    CL4'END'              ..ID for dumps
               DS    0D
IVCAL          EQU   *-IVCA
*
** Cache/Vendor_Match_Table Control Block
*
IVCC           DSECT ,                     PDSR$IVC cache area
IVCC_HID       DS    CL4'IVCC'             ..ID for dumps
IVCC_HPREV     DS    F                     ..Previous entry
IVCC_HLAST     DS    F                     ..Last possible entry
IVCC_HL        EQU   *-IVCC                ..Length of header
IVCC_ENTRY     DS    CL8                   Module entries
         EJECT
***********************************************************************
***
**  Module Eyecatcher routine
**
**  This routine is invoked after a successful load of a member
**  or for the text of each CSECT if using the Binder API.
**
**  The eyecatcher of the module is examined to see if it is a
**  "OS Standard" eyecatcher (see the IBM SAVE macro for format).
**
**  Upon input:
**  - R0...points to CSECT name
**  - R1...points to SUBRSA (our register save area)
**  - R2...points to PDS2 area
**  - R3...points to output line
**  - R8...has module length
**  - R9...has module start
***
***********************************************************************
         SPACE 2
PDSR$EC  CSECT ,
PDSR$EC  AMODE 31
PDSR$EC  RMODE ANY
*
** Create a standard O/S eyecatcher
*
ECEC     B     ECECL(0,R15)             Bump past Eyecatcher
         DC    AL1(L'ECECT)             Length of eyecatcher
ECECT    DC    C'PDSR$EC  - Eyecatcher formatter'
         DS    0H                       Ensure halfword alignment
ECECL    EQU   *-ECEC
*
** Entry housekeeping
*
         BAKR  R14,0                    Save registers
         LAE   R12,0(R15,0)             Get base register
         USING PDSR$EC,R12              Set module base
*
** Locate input fields and output locations
*
         EREG  R2,R3                    Get PDS, Output
         EREG  R8,R9                    Get Module length, address
         EREG  R0,R1                    Get CSECT, WORKDS address
         LR    R13,R1                    Get register save area
         USING SUBRSA,R13
*
** Format start of line
*
         MVI   0(R3),C' '               Get blank
         MVC   1(132,R3),0(R3)          Propagate it
*
         MVC   ECR_MEMBER-ECR(8,R3),PDS2NAME-PDS2(R2)
*-Indicate whether this is an alias
         TM    PDS2INDC-PDS2(R2),PDS2ALIS Alias?
         BNO   EC$AX
         MVC   ECR_ALIAS-ECR(2,R3),=C'-A'
EC$AX    DS    0H
*-Get the CSECT name (if any)
         LTR   R0,R0                      Passed to us?
         BZ    EC$CSECT0                  No, load of primary CSECT...
         LR    R14,R0
         MVC   ECR_CSECT-ECR(8,R3),0(R14)
         B     EC$CSECTX
EC$CSECT0 DS   0H
         MVC   ECR_CSECT-ECR(8,R3),=CL8'<<main>>' main
EC$CSECTX DS   0H
*-Print the length of the module
         ST    R8,DOUBLE
         UNPK  ECR_LENGTH-ECR(9,R3),DOUBLE(5)
         MVZ   ECR_LENGTH-ECR(8,R3),=8X'00'
         TR    ECR_LENGTH-ECR(8,R3),=C'0123456789abcdef'
         MVI   ECR_LENGTH+8-ECR(R3),C' '
*
** Now, tackle the module's eyecatcher, if any
*
         DA#SMODE 31                      Module may be over the line
 AGO .JES3ECX - - - - -- - - - - - - - - - - - - - - - - - - - - - - -
         LA    R15,ECR_EC-ECR(R3)
EC$J3L EQU *                              JES3 or regular literal type
         CH    R8,=AL2(4+8)               Module long enough for CLC?
         BL    EC$OS                      No, avoid S0C4
         CLC   4(8,R9),PDS2NAME-PDS2(R2)  JES3/Literal type w/Module?
         BNE   EC$OS                      No, try O/S standard
         LA    R0,128                     Max length to consider
         LA    R9,4(R9)                   Bump to start of literal
EC$J3LL EQU *
         MVC   0(1,R15),0(R9)             Move byte in
         LA    R15,1(R15)                 Bump to next output byte
         LA    R9,1(R9)                   Bump to next input byte
         CLI   0(R9),C' '                 Valid character?
         BL    LE$CP                      No, must be in code...
         BCT   R0,EC$J3LL                 Process next byte
         MVI   0(R15),C'<'                Indicate truncated
         B     LE$CP
EC$OS EQU *                               Standard O/S EyeCatcher
.JES3ECX ANOP  , - - - - - - - - - - - - - - - - - - - - - - - - - -
*-Here we look for a standard O/S eyecatcher
*-Well sometimes, there is a branch at the beginning without a VALID
*-length byte like a "standard O/S eyecatcher" should have.
         CLC   0(2,R9),=X'47F0F0'         Branch, R15?
         BNE   LE$CP                      No, print what we have
         L     R1,PPD_NUMEC               Get current number
         LA    R1,1(R1)                   Increment by 1
         ST    R1,PPD_NUMEC               Save new number
         SLR   R1,R1                      Clear register
         IC    R1,4(R9)                   Get length of literal
         LR    R14,R8                     Get module length
         SH    R14,=H'5'                  Subtract for header
         CR    R1,R14                     In length?
         BNH   LE$CB                      Yes, continue
         LR    R1,R14                     No, use shorter module length
LE$CB    DS    0H
#MAXECL  EQU   133-(ECR_EC-ECR)           Max Eyecatcher - other stuff
         CH    R1,=AL2(#MAXECL)           In range?
         BNH   LE$CC                      No, continue
         LA    R1,#MAXECL                 Set new max
LE$CC    DS    0H
         BCTR  R1,0                       Decrement for EX
         LTR   R1,R1                      Check out the length
         BM    LE$CP                      Doesn't look good
         EX    R1,LE$CM                   Move eyecatcher out
LE$CP    DS    0H
#ECT     EQU   132-(ECR_EC-ECR)           Max length of eyecatcher
         L     R1,=V(PDSR$C2)             Locate constants CSECT
         TR    ECR_EC-ECR(#ECT,R3),C_TRTABA-PDSR$C2(R1)
*
** Exit
*
EC$X     DS    0H
         DA#SMODE 24                    Get into 24 bit addr mode
         PR    ,                        Return to caller
*
** Local constants
*
         DS    0H
LE$CM    MVC   ECR_EC-ECR(0,R3),5(R9)
         LTORG ,
         DROP  R12,R13
*
** Map the EyeCatcher report line
*
ECR        DSECT ,
           DS    C
ECR_MEMBER DS    CL8
ECR_ALIAS  DS    C'-A'
           DS    C
ECR_CSECT  DS    CL8
           DS    C
ECR_LENGTH DS    CL8' '
           DS    C
ECR_EC     EQU   *
         EJECT
***********************************************************************
***
**  COBOL CICS report routine
**
**  This routine is invoked after a successful load of a member.
**  The eyecatcher of the module is examined to see if it is a
**  COBOL program and what options it was compiled with that would
**  impact CICS.
**
**  The COBOL II manual says that CICS COBOL programs should be
**  compiled with these options:  RES, RENT, NODYNAM, and LIB
**
**  Upon input:
**  - R2...points to PDS directory entry
**  - R3...points to output line
**  - R8...has module length
**  - R9...has module start
***
***********************************************************************
         SPACE 2
PDSR$COC CSECT ,
PDSR$COC AMODE 24
PDSR$COC RMODE 24
*
** Create a standard O/S eyecatcher
*
COBCEC   B     COBCECL(0,R15)           Bump past Eyecatcher
         DC    AL1(L'COBCECT)           Length of eyecatcher
COBCECT  DC    C'PDSR$COC - COBOL CICS verification'
         DS    0H                       Ensure halfword alignment
COBCECL  EQU   *-COBCEC
*
** Entry housekeeping
*
         BAKR  R14,0                    Save registers
         LAE   R12,0(R15,0)             Get base register
         USING PDSR$COC,R12             Set module base
*
** Locate input fields and output locations
*
         EREG  R2,R3                    Get PDS, Output
         EREG  R8,R9                    Get Module length, address
         LA    R7,COBCR_INFO-COBCR(R3)  Locate to information output
*
** Determine if the type of program is COBOL/370 or VS COBOL II
*
         DA#SMODE 31                    Get into 31 bit addr mode
         CH    R8,=AL2(CEE_EYECATCHER+4-COBOL_370_DSECT) Module okay?
         BL    COBC$X                   No, this module is very short
*
         CLC   CEE_EYECATCHER-COBOL_370_DSECT(4,R9),COBC_C370
         BE    COBC$370
         CLC   C2_EYECATCHER-COBOL_2_DSECT(4,R9),=CL4' C2 '
         BE    COBC$2
***      CLC   X'14'(4,R9),=CL4'ANS4'     ANSI (Ancient) COBOL?
***      BE    COBC$ANSI
***      CLC   X'14'(4,R9),=CL4'VSR1'     OS/VS COBOL?
***      BE    COBC$OSVS                  Yes, got a live one
*
** Exit
*
COBC$X   DS    0H
         DA#SMODE 24                      Get into 24 bit addr mode
         PR    ,                        Return to caller
*
** Older COBOL non-Support
*
COBC$ANSI DS 0H
         MVC   COBCR_TYPE-COBCR(10,R3),=C'ANSI_COBOL'
         B     COBC$OLD
COBC$OSVS DS 0H
         MVC   COBCR_TYPE-COBCR(11,R3),=C'OS/VS_COBOL'
COBC$OLD DS 0H
         B     COBC$X
*
** COBOL/370
*
COBC$370 DS 0H
         USING COBOL_370_DSECT,R9
*
         CH    R8,=AL2(CEE_STATUS_BYTE_03+1-COBOL_370_DSECT)
         BL    COBC$X
*
         TM    CEE_STATUS_BYTE_01,DYNAM
         BNO   COBC$370_DYNAMX
         MVC   0(5,R7),=C'DYNAM'
         LA    R7,6(R7)
COBC$370_DYNAMX DS 0H
         TM    CEE_STATUS_BYTE_02,LIB
         BO    COBC$370_LIBX
         MVC   0(5,R7),=C'NOLIB'
         LA    R7,6(R7)
COBC$370_LIBX DS 0H
         TM    CEE_STATUS_BYTE_03,RENT
         BO    COBC$370_RENTX
         MVC   0(6,R7),=C'NORENT'
         LA    R7,7(R7)
COBC$370_RENTX DS 0H
         TM    CEE_STATUS_BYTE_03,RES
         BO    COBC$370_RESX
         MVC   0(5,R7),=C'NORES'
         LA    R7,6(R7)
COBC$370_RESX DS 0H
*
         DROP  R9
*
         CLI   COBCR_INFO-COBCR(R3),C' ' Found any errors above?
         BE    COBC$X                    No, continue
         MVC   COBCR_TYPE-COBCR(9,R3),=C'COBOL/370' Mark COBOL type
         MVC   COBCR_ERROR-COBCR(6,R3),=C'Error:'   Set error indicator
         B     COBC$X
*
** VS COBOL II
*
COBC$2   DS    0H
         USING COBOL_2_DSECT,R9
*
         CH    R8,=AL2(C2_STATUS_BYTE_03+1-COBOL_2_DSECT)
         BL    COBC$X
*
         TM    C2_STATUS_BYTE_01,DYNAM
         BNO   COBC$2_DYNAMX
         MVC   0(5,R7),=C'DYNAM'
         LA    R7,6(R7)
COBC$2_DYNAMX DS 0H
         TM    C2_STATUS_BYTE_02,LIB
         BO    COBC$2_LIBX
         MVC   0(5,R7),=C'NOLIB'
         LA    R7,6(R7)
COBC$2_LIBX DS 0H
         TM    C2_STATUS_BYTE_03,RENT
         BO    COBC$2_RENTX
         MVC   0(6,R7),=C'NORENT'
         LA    R7,7(R7)
COBC$2_RENTX DS 0H
         TM    C2_STATUS_BYTE_03,RES
         BO    COBC$2_RESX
         MVC   0(5,R7),=C'NORES'
         LA    R7,6(R7)
COBC$2_RESX DS 0H
*
         DROP  R9
         CLI   COBCR_INFO-COBCR(R3),C' ' Found any errors above?
         BE    COBC$X                    No, continue
         MVC   COBCR_TYPE-COBCR(11,R3),=C'VS_COBOL_II' Mark COBOL type
         MVC   COBCR_ERROR-COBCR(6,R3),=C'Error:'   Set error indicator
         B     COBC$X
*
** Local constants
*
COBC_C370 DC X'00',C'CEE'                    COBOL/370 ?  X'00C3C5C5'
         DS    0H
         LTORG ,
         DROP  R12
         EJECT
***********************************************************************
***
**       Copy in the DA$PDSRC member for DFSMS/MVS Binder API
***
***********************************************************************
         SPACE 2
         AIF   ('&IHADFARELS' LT '01010100').CCMX
         PRINT GEN
*
* +-------------------------------------------------------------------+
* | Name: PDSRCM (originally ..CM meant Csect Map)                    |
* |                                                                   |
* | Purpose: Use IBM's Binder API to analyze a load library member:   |
* |          - Produce a Translator report                            |
* |          - Produce a History (IDR Identify and Zap) Report        |
* |          - Process load module text                               |
* |                                                                   |
* | This program checks to see if these files are allocated and uses  |
* | them as options (parameters).  You would usually allocate them    |
* | via "DD DUMMY":                                                   |
* |                                                                   |
* | o USEDCB .....Use DCB instead of Name method                      |
* | o BINDERMD....Message Exit Debugging                              |
* | o BINDERDB....Binder API "debugging mode" - show all messages     |
* | o BINDERDE....Dump Binder API buffer entries (hex dump)           |
* | o BINDERNM....No Binder API messages                              |
* | o BINDERPR....Get around UW32119 problem with DFSMS/MVS 1.3       |
* |                                                                   |
* | Known Problems:                                                   |
* | - Binder messages will go to the console if UW32119 is not on     |
* |   DFSMS/MVS 1.3 for option=NOPRINT.  Best thing to do is to run   |
* |   with BINDEROU/BINDERPR DD's set to dummy if UW32119 is not on.  |
* |                                                                   |
* +-------------------------------------------------------------------+
         EJECT ,
* +-------------------------------------------------------------------+
* | Start of CSECT                                                    |
* +-------------------------------------------------------------------+
*
PDSRCM   CSECT ,
PDSRCM   AMODE 24
PDSRCM   RMODE 24
*
** Standard O/S eyecatcher
*
PDSRCM_EC     B    PDSRCM_ECL(0,R15)      Bump past EyeCatcher
              DC   AL1(L'PDSRCM_ECLIT)    Length of eyecatcher
PDSRCM_ECLIT  DC   C'PDSRCM   - Binder API reports'
              DS   0H
PDSRCM_ECL    EQU  *-PDSRCM_EC
*
** Entry Housekeeping
*
         BAKR  R14,0                    Save registers
         LAE   R12,0(R15,0)             Get base register
         LAE   R11,2048(,R12)           Set up for second base reg
         LA    R11,2048(,R11)           Locate 4096 past R12
         LAE   R10,2048(,R11)           Set up for third base reg
         LA    R10,2048(,R10)           Locate 4096 past R11
         USING PDSRCM,R12,R11,R10       Set module base
         SAC   0
         SYSSTATE ASCENV=P
         EREG  R0,R1
         LR    R13,R1                     Locate RSA and work area
         USING PDSRCMD,R13                Locate to data area
*
** Do processing that we are called to perform
*
         MVC   PDSRCMD_FUNC(8),=CL8' '    Nothing doing (so far)
*
         CLI   PDSRCMD_CALLT,$PDSRCMD_CT_INIT Initialization?
         BE    PDSRCM$I
         CLI   PDSRCMD_CALLT,$PDSRCMD_CT_MEM  Member?
         BE    PDSRCM$M
         CLI   PDSRCMD_CALLT,$PDSRCMD_CT_LIBS Library start?
         BE    PDSRCM$S
         CLI   PDSRCMD_CALLT,$PDSRCMD_CT_LIBE Library end?
         BE    PDSRCM$E
         CLI   PDSRCMD_CALLT,$PDSRCMD_CT_TERM Termination?
         BE    PDSRCM$T
         LA    R15,255                    Error: invalid option
*
** Termination for PDSRCM
*
PDSRCM$X DS    0H                         Exit
         PR    ,                          Return to caller
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Since I check for the availablity of some of the fields copied
** in by IEWBCES, I need this up here and not with the rest of the
** constants and equates.
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
         COPY IEWBCES ,                 ESD codes
         EJECT ,
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Process a member:
**
** - Binder information
** - CSECT processing:
**   - Translator report
**   - History report
**   - Process text records for a CSECT
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
PDSRCM$M DS    0H
         NI    PDSRCMD_IFLAG2,255-$PDSRCMD_IF2EMSG Turn off flag
         XC    PDSRCMD_MZAPCNT(4),PDSRCMD_MZAPCNT
         OI    PDSRCMD_IFLAG2,$PDSRCMD_IF2MEM  Say we came this way
         XC    PDSRCMD_CSECTS(4),PDSRCMD_CSECTS
         XC    PDSRCMD_CSPRIVC(2),PDSRCMD_CSPRIVC
*
** Print a blank line for new member
*
         TM    PDSRCMD_FLAG1,$PDSRCMD_F1TRAN Doing Translator report?
         BNO   PDSRCM$M_TRSLX             No, continue
         TM    PDSRCMD_IFLAG1,$PDSRCMD_IF1TRM  Found a Translator?
         BNO   PDSRCM$M_TRSLX
         CLI   PDSRCMD_TRPRRLC,99
         BE    PDSRCM$M_TRSLX
         BAS   R14,PDSRCM_CLEAR_RECOUT
         BAS   R14,PDSRCM_TRPRR     Print Report Record
PDSRCM$M_TRSLX DS 0H
*
         TM    PDSRCMD_FLAG1,$PDSRCMD_F1HIST Doing History report?
         BNO   PDSRCM$M_HISLX             No, continue
         TM    PDSRCMD_IFLAG1,$PDSRCMD_IF1HIM  Found a History mem?
         BNO   PDSRCM$M_HISLX
         CLI   PDSRCMD_HIPRRLC,99
         BE    PDSRCM$M_HISLX
         BAS   R14,PDSRCM_CLEAR_RECOUT
         BAS   R14,PDSRCM_HIPRR     Print Report Record
PDSRCM$M_HISLX DS 0H
*
** Create a Workmod with Intent ACCESS
*
         MVC   PDSRCMD_WKTOKEN(8),PDSRCM_ZEROS Clear workmod token
         MVC   PDSRCMD_FUNC(8),=CL8'CREATEW'
         IEWBIND FUNC=CREATEW,                                         C
               RETCODE=PDSRCMD_RETCODE,                                C
               RSNCODE=PDSRCMD_RSNCODE,                                C
               WORKMOD=PDSRCMD_WKTOKEN,                                C
               DIALOG=PDSRCMD_DTOKEN,                                  C
               INTENT=ACCESS,                                          C
               MF=(E,PDSRCMD_PARMLIST)
         CLC   PDSRCMD_RSNCODE(4),C_IEWB_RC_OK Check reason code
         BNE   PDSRCM$ME                  Exit if not zero
*
** Set Binder API options
**
** DFSMS/MVS 1.3 adds the PARMS= keyword
*
         MVC   PDSRCMD_FUNC(8),=CL8'SETO'
         TM    PDSRCMD_IFLAG1,$PDSRCMD_IF1BDB Binder Debug Mode?
         BO    PDSRCM$M_BDBO              Yes, more info
         AIF   ('&IHADFARELS' LT '01010300').MSOP1 .at DFSMS/MVS 1.3?
*-Regular mode for DFSMS/MVS 1.3 and higher
         IEWBIND FUNC=SETO,                                            C
               RETCODE=PDSRCMD_RETCODE,                                C
               RSNCODE=PDSRCMD_RSNCODE,                                C
               WORKMOD=PDSRCMD_WKTOKEN,                                C
               OPTION=O_LIST,OPTVAL=V_OFF,       LIST(OFF)             C
               PARMS=PARMS_NODB,                                       C
               MF=(E,PDSRCMD_PARMLIST)
         AGO   .MSOP1X
.MSOP1   ANOP  ,
*-Regular mode for DFSMS/MVS 1.1 and 1.2
         IEWBIND FUNC=SETO,                                            C
               RETCODE=PDSRCMD_RETCODE,                                C
               RSNCODE=PDSRCMD_RSNCODE,                                C
               WORKMOD=PDSRCMD_WKTOKEN,                                C
               OPTION=O_LIST,OPTVAL=V_OFF,       LIST(OFF)             C
               MF=(E,PDSRCMD_PARMLIST)
.MSOP1X  ANOP  ,
         B     PDSRCM$M_BDBOX
PDSRCM$M_BDBO  DS 0H
         AIF   ('&IHADFARELS' LT '01010300').MSOP2 .at DFSMS/MVS 1.3?
*-Debugging mode for DFSMS/MVS 1.3 and higher
         IEWBIND FUNC=SETO,                                            C
               RETCODE=PDSRCMD_RETCODE,                                C
               RSNCODE=PDSRCMD_RSNCODE,                                C
               WORKMOD=PDSRCMD_WKTOKEN,                                C
               OPTION=O_LIST,OPTVAL=V_ALL,      LIST(ALL)              C
               PARMS=PARMS_DB,                                         C
               MF=(E,PDSRCMD_PARMLIST)
.MSOP2   ANOP  ,
*-Debugging mode for DFSMS/MVS 1.1 and 1.2
         IEWBIND FUNC=SETO,                                            C
               RETCODE=PDSRCMD_RETCODE,                                C
               RSNCODE=PDSRCMD_RSNCODE,                                C
               WORKMOD=PDSRCMD_WKTOKEN,                                C
               OPTION=O_LIST,OPTVAL=V_ALL,      LIST(ALL)              C
               MF=(E,PDSRCMD_PARMLIST)
.MSOP2X  ANOP  ,
PDSRCM$M_BDBOX DS 0H
         CLC   PDSRCMD_RSNCODE(4),C_IEWB_RC_OK Check reason code
         BNE   PDSRCM$ME                  Exit if not zero
*
** Include the module
*
     TM    PDSRCMD_IFLAG2,$PDSRCMD_IF2UDCB    DCB allowed?
     BNO   PDSRCM$M_INAM                      No, always do with name
         TM    PDSRCMD_FLAG1,$PDSRCMD_F1DCB   Driver thought DCB okay?
         BO    PDSRCM$M_IDCB                  Yes, do it that way
PDSRCM$M_INAM DS 0H
         MVC   PDSRCMD_FUNC(8),=CL8'INCLUDEn'  <- Include intype=Name
         IEWBIND FUNC=INCLUDE,                                         C
               RETCODE=PDSRCMD_RETCODE,                                C
               RSNCODE=PDSRCMD_RSNCODE,                                C
               WORKMOD=PDSRCMD_WKTOKEN,                                C
               INTYPE=NAME,                                            C
               DDNAME=PDSRCMD_INCLLIB,                                 C
               MEMBER=PDSRCMD_MODNAME,                                 C
               MF=(E,PDSRCMD_PARMLIST)
         B     PDSRCM$M_IDCBX
PDSRCM$M_IDCB DS 0H
         MVC   PDSRCMD_FUNC(8),=CL8'INCLUDEp' <- Include intype=Pointer
         IEWBIND FUNC=INCLUDE,                                         C
               RETCODE=PDSRCMD_RETCODE,                                C
               RSNCODE=PDSRCMD_RSNCODE,                                C
               WORKMOD=PDSRCMD_WKTOKEN,                                C
               INTYPE=POINTER,                                         C
               DCBPTR=PDSRCMD_DCBPTR,                                  C
               DEPTR=PDSRCMD_DEPTR,                                    C
               MF=(E,PDSRCMD_PARMLIST)
PDSRCM$M_IDCBX DS 0H
         CLC   PDSRCMD_RSNCODE(4),C_IEWB_RC_OK Check reason code
         BE    PDSRCM$M_IDCBO
         CLC   PDSRCMD_RETCODE(4),C_IEWB_RC_WARNING Warning?
         BNE   PDSRCM$ME
*
** Obtain all section names
*
PDSRCM$M_IDCBO DS 0H
         LM    R6,R7,PDSRCMD_SAVEESD     Get saved registers
         USING IEWBESD,R6
         USING ESD_ENTRY,R7
         LM    R8,R9,PDSRCMD_SAVEBNL     Get saved registers
         USING IEWBBNL,R8
         USING BNL_ENTRY,R9
         OI    PDSRCMD_IFLAG2,$PDSRCMD_IF2FSEC
*
         MVC   PDSRCMD_CURSORN(4),PDSRCM_ZEROS
         MVC   PDSRCMD_FUNC(8),=CL8'GETN'
         AIF   ('&IHADFARELS' LT '01010300').MGETN  at DFSMS/MVS 1.3?
*-GETN for DFSMS/MVS 1.3 and higher
         IEWBIND FUNC=GETN,                                            C
               VERSION=1,                                              C
               RETCODE=PDSRCMD_RETCODE,                                C
               RSNCODE=PDSRCMD_RSNCODE,                                C
               WORKMOD=PDSRCMD_WKTOKEN,                                C
               AREA=IEWBBNL,                                           C
               CURSOR=PDSRCMD_CURSORN,                                 C
               COUNT=PDSRCMD_COUNTN,                                   C
               TCOUNT=PDSRCMD_TCOUNT,                                  C
               NTYPE=S,                                                C
               MF=(E,PDSRCMD_PARMLIST)
         AGO   .MGETNX
.MGETN   ANOP  ,
*-GETN for DFSMS/MVS 1.1 and 1.2
         IEWBIND FUNC=GETN,                                            C
               RETCODE=PDSRCMD_RETCODE,                                C
               RSNCODE=PDSRCMD_RSNCODE,                                C
               WORKMOD=PDSRCMD_WKTOKEN,                                C
               AREA=IEWBBNL,                                           C
               CURSOR=PDSRCMD_CURSORN,                                 C
               COUNT=PDSRCMD_COUNTN,                                   C
               TCOUNT=PDSRCMD_TCOUNT,                                  C
               NTYPE=S,                                                C
               MF=(E,PDSRCMD_PARMLIST)
.MGETNX  ANOP  ,
*
         XC    PDSRCMD_COUNTNC(4),PDSRCMD_COUNTNC Current count (debug)
         CLC   PDSRCMD_RSNCODE(4),C_IEWB_RC_OK Check reason code
         BE    PDSRCM$M_NOK
*
         CLC   PDSRCMD_RETCODE(4),C_IEWB_RC_WARNING RC=4?
         BNE   PDSRCM$M_NRC4X             No, continue
         CLC   PDSRCMD_RSNCODE(4),=X'83000800'  End of data?
         BE    PDSRCM$M_NRCVC
         CLC   PDSRCMD_RSNCODE(4),=X'83000801'  No section names?
         BE    PDSRCM$ME
         B     PDSRCM$M_NRCVCX
PDSRCM$M_NRCVC DS 0H
         L     R14,PDSRCMD_PSRAREA        Locate to area
         TM    PPC_FLAG5-PSRAREA(R14),$PPC_F5EODC User wants this?
         BNO   PDSRCM$M_NOK               No, continue
PDSRCM$M_NRCVCX DS 0H
*
         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format the message
         MVC   0(MSGCM20L,R15),MSGCM20-PDSRCMC(R1) Get message text
         LA    R15,MSGCM20L(R15)          Bump past message
         UNPK  0(9,R15),PDSRCMD_RSNCODE(5)
         MVZ   0(8,R15),=8X'00'
         TR    0(8,R15),=C'0123456789abcdef'
         MVC   8(9,R15),=C', member='
         LA    R15,8+9(R15)
         MVC   0(8,R15),PDSRCMD_MODNAME+2
         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT
         B     PDSRCM$M_NOK               Yes, continue
PDSRCM$M_NRC4X DS 0H
*
         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format the message
         MVC   0(MSGCM1L,R15),MSGCM1-PDSRCMC(R1) Get message text
         LA    R15,MSGCM1L(R15)           Bump past message
         L     R1,PDSRCMD_TCOUNT          Get total number of sections
         S     R1,PDSRCMD_COUNTN          Number we didn't get
         BAS   R14,PDSRCM_EDITFWF         Edit it
         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT
PDSRCM$M_NOK EQU *
*
** Process all sections
*
         L     R5,PDSRCMD_COUNTN          Number of sections
PDSRCM$M_L1 DS 0H
         L     R1,PDSRCMD_COUNTNC
         LA    R1,1(R1)
         ST    R1,PDSRCMD_COUNTNC
*
         L     R3,BNL_NAME_PTR            Extract section name
         LH    R2,BNL_NAME_CHARS          Get length of section name
         STH   R2,PDSRCMD_SECTION         Save for later
         LA    R4,PDSRCMD_SECTION
*
         LA    R15,PDSRCMD_SECTION+2      | Note:
         MVI   0(R15),C' '                | This is being done for us
         MVC   1(255,R15),0(R15)          | and not for the Binder API
*
         BCTR  R2,0                       Decrement for EX
         EX    R2,MOVESEC                 Get section name
*-Note: Bruce says he increments the $PRIVATE CSECTs.
*
* .   .    .    .    .    .    .     .    .    .    .   .    .   .
*-Print the section name if we are dumping control blocks
         TM    PDSRCMD_IFLAG1,$PDSRCMD_IF1DMPA Dumping areas?
         BNO   PDSRCM$M_DESX              Nope, leave
         BAS   R14,PDSRCM_FORMAT_MESSAGE
         MVC   0(MSGCM4L,R15),MSGCM4
         MVC   MSGCM4M-MSGCM4(8,R15),PDSRCMD_MODNAME+2
         LA    R15,MSGCM4L(R15)
         CLI   PDSRCMD_SECTION+2,C'A'
         BL    PDSRCM$M_DESS
         LH    R1,PDSRCMD_SECTION
         CH    R1,=H'64'
         BNH   PDSRCM$M_DESK
         LA    R1,64
PDSRCM$M_DESK DS 0H
         BCTR  R1,0
         EX    R1,PDSRCM$M_DESM
         LA    R15,1(R1,R15)
         MVI   0(R15),C'"'
         LA    R15,2(R15)
         B     PDSRCM$M_DES$C
PDSRCM$M_DESS  DS 0H
         SH    R15,=H'2'                      Backup over '="'
         MVI   0(R15),C':'
         LA    R15,2(R15)
         UNPK  0(5,R15),PDSRCMD_SECTION(3)
         MVZ   0(4,R15),PDSRCM_ZEROS
         TR    0(4,R15),PDSRCM_HEXTABLE
         MVI   4(R15),C'-'
         LA    R15,5(R15)
         LH    R0,PDSRCMD_SECTION
         LA    R1,PDSRCMD_SECTION+2
PDSRCM$M_DES$L DS 0H
         UNPK  0(3,R15),0(2,R1)
         MVZ   0(2,R15),PDSRCM_ZEROS
         TR    0(2,R15),PDSRCM_HEXTABLE
         MVI   2(R15),C' '
         LA    R15,2(R15)
         LA    R1,1(R1)
         BCT   R0,PDSRCM$M_DES$L
PDSRCM$M_DES$C DS 0H
         MVI   1(R15),C'#'
         LA    R15,2(R15)
         L     R1,PDSRCMD_COUNTNC
         BAS   R14,PDSRCM_EDITFWF
         MVC   1(2,R15),=C'of'
         LA    R15,1+2+1(R15)
         L     R1,PDSRCMD_COUNTN
         BAS   R14,PDSRCM_EDITFWF
         B     PDSRCM$M_DES$X
PDSRCM$M_DESM  MVC 0(0,R15),PDSRCMD_SECTION+2
PDSRCM$M_DES$X DS   0H
         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT
PDSRCM$M_DESX DS 0H
* .   .    .    .    .    .    .     .    .    .    .   .    .   .
*
** Process the current Section and obtain ESD entries
*
         TM    PDSRCMD_IFLAG2,$PDSRCMD_IF2FSEC      First section?
         BNO   PDSRCM$M_DESBX                       No, continue
         NI    PDSRCMD_IFLAG2,255-$PDSRCMD_IF2FSEC  Reset flag
         BAS   R14,PDSRCM$M_BIND                    Get binder info
         TM    PDSRCMD_FLAG1,$PDSRCMD_F1TRAN        Translator?
         BO    PDSRCM$M_DESBX                       No, continue
         TM    PDSRCMD_FLAG1,$PDSRCMD_F1HIST        History?
         BO    PDSRCM$M_DESBX                       No, continue
         TM    PDSRCMD_FLAG1,$PDSRCMD_F1TEXT        Text processing?
         BO    PDSRCM$M_DESBX                       No, continue
         B     PDSRCM$M_DW                          Leave w/only binder
PDSRCM$M_DESBX DS 0H
*
         MVC   PDSRCMD_CURSORDE(4),PDSRCM_ZEROS
         MVC   PDSRCMD_FUNC(8),=CL8'GETD-ESD'
         AIF   ('&IHADFARELS' LT '01010300').MGESD  at DFSMS/MVS 1.3?
*-GETD/ESD for DFSMS/MVS 1.3 and higher
         IEWBIND FUNC=GETD,                                            C
               VERSION=1,                                              C
               RETCODE=PDSRCMD_RETCODE,                                C
               RSNCODE=PDSRCMD_RSNCODE,                                C
               WORKMOD=PDSRCMD_WKTOKEN,                                C
               SECTION=PDSRCMD_SECTION,                                C
               AREA=IEWBESD,                                           C
               CLASS=PDSRCMD_B_ESD,                                    C
               CURSOR=PDSRCMD_CURSORDE,                                C
               COUNT=PDSRCMD_COUNTDE,                                  C
               MF=(E,PDSRCMD_PARMLIST)
         AGO   .MGESDX
.MGESD   ANOP  ,
*-GETD/ESD for DFSMS/MVS 1.1 and 1.2
         IEWBIND FUNC=GETD,                                            C
               RETCODE=PDSRCMD_RETCODE,                                C
               RSNCODE=PDSRCMD_RSNCODE,                                C
               WORKMOD=PDSRCMD_WKTOKEN,                                C
               SECTION=PDSRCMD_SECTION,                                C
               AREA=IEWBESD,                                           C
               CLASS=PDSRCMD_B_ESD,                                    C
               CURSOR=PDSRCMD_CURSORDE,                                C
               COUNT=PDSRCMD_COUNTDE,                                  C
               MF=(E,PDSRCMD_PARMLIST)
.MGESDX  ANOP  ,
*
         LH    R0,=AL2(ESDH_END-ESDH_START) Get length of header
         LA    R1,C_ID_ESD_HEADER   Locate string of header name
         LR    R15,R6               Locate area to dump
         BAS   R14,PDSRCM_DUMPE     Dump entry
*
         CLC   PDSRCMD_RSNCODE(4),C_IEWB_RC_OK
         BE    PDSRCM$M_DEOK
         CLC   PDSRCMD_RETCODE(4),C_IEWB_RC_WARNING Last buffer
         BE    PDSRCM$M_DEOK
         CLC   PDSRCMD_RETCODE(4),C_IEWB_RC_ERROR  No data for item
         BNE   PDSRCM$M_L2X                        Yes, leave
PDSRCM$M_DEOK EQU *
         L     R4,PDSRCMD_COUNTDE   Number of ESD entries in buffer
         LTR   R4,R4                Skip empty section
         BZ    PDSRCM$M_NS          None, leave
         LA    R7,ESDH_END          First record in ESD buffer
PDSRCM$M_L2 DS 0H
         CLC   ESD_TYPE(L'ESD_TYPE),ESDT_CTRL_SEC CSECT?
         BNE   PDSRCM$M_L2B         No, skip this ESD entry
*
         L     R1,PDSRCMD_CSECTS    Get number
         LA    R1,1(R1)
         ST    R1,PDSRCMD_CSECTS    Save it
*
         LH    R0,=AL2(ESD_END-ESD_ENTRY)  Get length of entry
         LA    R1,C_ID_ESD_BUFFER   Locate string of entry type
         LR    R15,R7               Locate area to dump
         BAS   R14,PDSRCM_DUMPE     Dump entry
*
*-Format the CSECT name for output reports - - - - - - - - - - - - -
         CLI   ESD_SCOPE,C'S'             $PRIVATE?
         BE    PDSRCM$M_L2_CSPRIV         Yes, looks that way...
         LH    R1,PDSRCMD_SECTION         Get length of CSECT name
         CH    R1,=AL2(L'OCL_CSECT)       Longer than field name?
         BNH   PDSRCM$M_L2_CSXOK
         MVC   PDSRCMD_OCLCSECT(L'OCL_CSECT-5),PDSRCMD_SECTION+2
         L     R14,=V(PDSR$C2)            Locate constants CSECT
         TR    PDSRCMD_OCLCSECT(L'OCL_CSECT-5),C_TRTABA-PDSR$C2(R14)
         L     R1,PDSRCMD_TRUNCC
         LA    R1,1(R1)
         ST    R1,PDSRCMD_TRUNCC
*-Here we turn "LONGERNAME" into "LONGE_xxxx" where xxxx is in dec
* for the number of truncated CSECT names
         LA    R14,PDSRCMD_OCLCSECT+(L'OCL_CSECT-5)
         MVI   0(R14),C'_'
         CVD   R1,PDSRCMD_DOUBLE2
         UNPK  1(4,R14),PDSRCMD_DOUBLE2+6(2)
         OI    1+3(R14),C'0'
         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format message
         MVC   0(MSGCM17L,R15),MSGCM17    Get text
         LA    R15,MSGCM17L(R15)
         MVC   0(L'OCL_CSECT,R15),PDSRCMD_OCLCSECT
         LA    R15,L'OCL_CSECT(R15)       Locate past CSECT name
         MVC   0(9,R15),=C', actual='     Insert text
         LA    R15,9(R15)                 Bump past it
         LH    R14,PDSRCMD_SECTION        Get length of name
         CH    R14,=H'64'                 Over 64?
         BNH   PDSRCM$M_L2_CSLCX          No, can fit on this line
*-Note: need to do wraping here. (don't need to truncate twice!!!)
 LA R14,64 Will you still love me, will you still need me when I'm 64
PDSRCM$M_L2_CSLCX DS 0H
         BCTR  R14,0
         EX    R14,PDSRCM$M_L2_CSLCM
         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT
*
         B     PDSRCM$M_L2_CSXX           Brance around executed instr
PDSRCM$M_L2_CSLCM  MVC 0(0,R15),PDSRCMD_SECTION+2
PDSRCM$M_L2_CSOKLM MVC PDSRCMD_OCLCSECT(0),PDSRCMD_SECTION+2
PDSRCM$M_L2_CSOKLT TR  PDSRCMD_OCLCSECT(0),C_TRTABA-PDSR$C2(R14)
         SPACE 2
*-CSECT looks to be a $PRIVATE section, name it so and append a number
PDSRCM$M_L2_CSPRIV DS 0H
         MVI   PDSRCMD_OCLCSECT,C' '
         MVC   PDSRCMD_OCLCSECT+1(L'OCL_CSECT-1),PDSRCMD_OCLCSECT
         LA    R15,PDSRCMD_OCLCSECT
         MVC   0(6,R15),=C'$Priv#'
         LA    R15,6(R15)
         LH    R1,PDSRCMD_CSPRIVC
         LA    R1,1(R1)
         STH   R1,PDSRCMD_CSPRIVC
         BAS   R14,PDSRCM_EDITFWF
         B     PDSRCM$M_L2_CSXX
         SPACE 2
*-CSECT name is okay in length, move it to field for later
PDSRCM$M_L2_CSXOK  DS 0H
         MVI   PDSRCMD_OCLCSECT,C' '
         MVC   PDSRCMD_OCLCSECT+1(L'OCL_CSECT-1),PDSRCMD_OCLCSECT
         BCTR  R1,0
         EX    R1,PDSRCM$M_L2_CSOKLM      Move out CSECT name
         L     R14,=V(PDSR$C2)            Locate constants CSECT
         EX    R1,PDSRCM$M_L2_CSOKLT      Ensure Name is printable
PDSRCM$M_L2_CSXX DS 0H
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
** Initialize for //FLATOUT processing
*
         TM    PDSRCMD_IFLAG2,$PDSRCMD_IF2FO Flatout processing?
         BNO   PDSRCM$M_L2FIX       No, skip this code
         L     R1,PDSRCMD_FOA+4     Locate FLATOUT record Area
         LA    R1,FOM_RECORD-FOM(R1) Locate to record output
         MVI   FOR_TYPE-FOR(R1),$FORTYPE_C
         MVI   FOR_SPACE1-FOR(R1),C' '
         MVI   FOR_SPACE2-FOR(R1),C' '
         MVI   FORC_SPACE1-FOR(R1),C' '
PDSRCM$M_L2FIX DS 0H
*
** See if this CSECT is a "vendor" CSECT
*
         L     R14,PDSRCMD_PSRAREA        Locate to area
         TM    PPC_FLAG5-PSRAREA(R14),$PPC_F5IVCSECTS Flag on?
         BNO   PDSRCM$M_L2_IVCX           No, continue
*
         LA    R0,PDSRCMD_SECTION+2       Locate CSECT name
         L     R1,PDSRCMD_SUBRSAP         Locate SUBRSA
         LR    R2,R13                     Locate PDSRCMD area
         L     R15,=V(PDSR$IVC)           Locate routine
         BASR  R14,R15                    Call Ignore_Vendor_CSECT rout
*
         TM    PDSRCMD_IFLAG3,$PDSRCMD_IF3IVC Vendor CSECT?
         BNO   PDSRCM$M_L2_IVCX           No, continue
         L     R14,PDSRCMD_PSRAREA        Locate to area
         TM    PPC_FLAG5-PSRAREA(R14),$PPC_F5IVCSECTF Full ignore?
         BO    PDSRCM$M_L2B               Yes, skip CSECT completely
PDSRCM$M_L2_IVCX DS 0H
*
** Call each type of routine that looks at a CSECT
*
         BAS   R14,PDSRCM$M_TRAN    Get translator information
         BAS   R14,PDSRCM$M_HISTZ   Get History information (Zap)
         BAS   R14,PDSRCM$M_HISTU   Get History information (User)
         BAS   R14,PDSRCM$M_TEXT    Text (Flatout, eyecatcher)
*
** At this time, the Flatout record is complete, put out record
*
         TM    PDSRCMD_IFLAG2,$PDSRCMD_IF2FO Flatout processing?
         BNO   PDSRCM$M_L2FTX       No, skip this code
         L     R1,PDSRCMD_FOA+4     Locate FLATOUT record Area
         LA    R1,FOM_RDW-FOM(R1)
         LA    R14,FORCL+L'FOM_RDW
         STH   R14,0(R1)
         LR    R0,R1
         PUT   PDSRCMD_DCBF,(0)
PDSRCM$M_L2FTX DS 0H
*
PDSRCM$M_L2B DS 0H
         A     R7,ESDH_ENTRY_LENG   Move to next ESD in this section
         BCT   R4,PDSRCM$M_L2
PDSRCM$M_L2X DS 0H
*
** Bump to the next section
*
PDSRCM$M_NS DS 0H                         Next section - - - - - - -
         A     R9,BNLH_ENTRY_LENG         Move to next section name
         BCT   R5,PDSRCM$M_L1
         B     PDSRCM$MEX
         DROP  R6,R7,R8,R9
*
** Errors found on Binder API call
*
PDSRCM$ME DS 0H
         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format message
         MVC   0(MSGCM2L,R15),MSGCM2-PDSRCMC(R1)  Get text
         LA    R15,MSGCM2L(R15)
         MVC   0(8,R15),PDSRCMD_MODNAME+2   Get member name
         BAS   R14,PDSRCM_EPM             Ensure Printable Member
         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT
*
         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format message
         MVC   0(MSGCM2AL,R15),MSGCM2A    Get text
         LA    R15,MSGCM2AL(R15)          Bump past text
         L     R1,PDSRCMD_PARMLIST+0      Get function address
         UNPK  0(5,R15),0(3,R1)                >
         MVZ   0(4,R15),PDSRCM_ZEROS           >> Hex translate
         TR    0(4,R15),PDSRCM_HEXTABLE >
         MVC   4(2,R15),=C')-'            Delimiter
         LA    R15,6(R15)                 Bump past delimiter
         MVC   0(L'PDSRCMD_FUNC,R15),PDSRCMD_FUNC Function name
         LA    R0,L'PDSRCMD_FUNC          Get max length 0123/function
         BAS   R14,PDSRCM_LOCATE_FIRST_SPACE  Locate first space
         MVC   0(5,R15),=C', RC='         Get text
         LA    R15,5(R15)                 Bump past it
         L     R1,PDSRCMD_RETCODE         Get return code
         BAS   R14,PDSRCM_EDITFWF         Edit it
         MVC   0(9,R15),=C', Reason='     Get text
         LA    R15,9(R15)                 Bump past it
         UNPK  0(9,R15),PDSRCMD_RSNCODE(5)   >
         MVZ   0(8,R15),PDSRCM_ZEROS         >> Hex translate
         TR    0(8,R15),PDSRCM_HEXTABLE >
         MVI   8(R15),C' '                Fix trailing byte
         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT
*
         BAS   R14,PDSRCM_CLEAR_RECOUT    Clear recout to blanks
         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT
PDSRCM$MEX DS 0H
*
** Delete the workmod
*
PDSRCM$M_DW DS 0H
         MVC   PDSRCMD_FUNC(8),=CL8'DELETEW'
         IEWBIND FUNC=DELETEW,                                         C
               RETCODE=PDSRCMD_RETCODE,                                C
               RSNCODE=PDSRCMD_RSNCODE,                                C
               WORKMOD=PDSRCMD_WKTOKEN,                                C
               PROTECT=YES,                                            C
               MF=(E,PDSRCMD_PARMLIST)
         CLC   PDSRCMD_RSNCODE(4),C_IEWB_RC_OK
         BNE   PDSRCM$MDWE
         MVC   PDSRCMD_FUNC(8),=CL8'????????'
         B     PDSRCM$X
*
PDSRCM$MDWE DS 0H
         LA    R15,4
         B     PDSRCM$X
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** This routine formats the common section for the various reports
** (It would be very unlucky to overlay PDSRCMD_DOUBLE here!!!!)
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
PDSRCM_MFCS    DS 0H
         USING IEWBESD,R6
         USING ESD_ENTRY,R7
         ST    R14,PDSRCMD_DOUBLE                  Save return address
         BAS   R14,PDSRCM_CLEAR_RECOUT
         MVC   OCL_MEMBER-OCL(L'OCL_MEMBER,R15),PDSRCMD_MODNAME+2
         MVC   OCL_ALIAS-OCL(L'OCL_ALIAS,R15),PDSRCMD_ALIAS
*
         UNPK  PDSRCMD_DOUBLE2(9),ESD_LENG(5)
         MVZ   PDSRCMD_DOUBLE2(8),PDSRCM_ZEROS
         TR    PDSRCMD_DOUBLE2(8),PDSRCM_HEXTABLE
         MVC   OCL_LENGTH-OCL(8,R15),PDSRCMD_DOUBLE2
*
         UNPK  PDSRCMD_DOUBLE2(9),ESD_MODULE_OFFSET(5)
         MVZ   PDSRCMD_DOUBLE2(8),PDSRCM_ZEROS
         TR    PDSRCMD_DOUBLE2(8),PDSRCM_HEXTABLE
         MVC   OCL_OFFSET-OCL(8,R15),PDSRCMD_DOUBLE2
*
         MVC   OCL_CSECT-OCL(L'OCL_CSECT,R15),PDSRCMD_OCLCSECT
         TM    PDSRCMD_IFLAG3,$PDSRCMD_IF3IVC Vendor CSECT?
         BNO   PDSRCM$M_MFC$VCX           Yes, don't test it
         MVI   OCL_CSECT-1-OCL(R15),C'!'
PDSRCM$M_MFC$VCX DS 0H
*
         CLI   ESD_AMODE,ESDAM_UNSPEC
         BE    PDSRCM$M_MFC$AMX
         CLI   ESD_AMODE,ESDAM_24
         BE    PDSRCM$M_MFC$AM24
         CLI   ESD_AMODE,ESDAM_31
         BE    PDSRCM$M_MFC$AM31
         CLI   ESD_AMODE,ESDAM_ANY
         BE    PDSRCM$M_MFC$AMANY
         CLI   ESD_AMODE,ESDAM_MIN
         BNE   PDSRCM$M_MFC$AMX
         MVC   OCL_AMODE-OCL(9,R15),=C'AMODE Min'
         B     PDSRCM$M_MFC$AMX
PDSRCM$M_MFC$AMANY DS 0H
         MVC   OCL_AMODE-OCL(9,R15),=C'AMODE Any'
         B     PDSRCM$M_MFC$AMX
PDSRCM$M_MFC$AM31 DS 0H
         MVC   OCL_AMODE-OCL(8,R15),=C'AMODE 31'
         B     PDSRCM$M_MFC$AMX
PDSRCM$M_MFC$AM24 DS 0H
         MVC   OCL_AMODE-OCL(8,R15),=C'AMODE 24'
PDSRCM$M_MFC$AMX DS 0H
*
         CLI   ESD_RMODE,ESDRM_UNSPEC
         BE    PDSRCM$M_MFC$RMX
         CLI   ESD_RMODE,ESDRM_24
         BE    PDSRCM$M_MFC$RM24
         CLI   ESD_RMODE,ESDRM_ANY
         BNE   PDSRCM$M_MFC$RMX
         MVC   OCL_RMODE-OCL(9,R15),=C'RMODE Any'
         B     PDSRCM$M_MFC$RMX
PDSRCM$M_MFC$RM24 DS 0H
         MVC   OCL_RMODE-OCL(8,R15),=C'RMODE 24'
PDSRCM$M_MFC$RMX DS 0H
*
         CLI   ESD_ALIGN,ESDAL_BYTE
         BE    PDSRCM$M_MFC$AL_BYTE
         CLI   ESD_ALIGN,ESDAL_HALF_WORD
         BE    PDSRCM$M_MFC$AL_HALF
         CLI   ESD_ALIGN,ESDAL_FULL_WORD
         BE    PDSRCM$M_MFC$AL_FULL
         CLI   ESD_ALIGN,ESDAL_DOUBLE_WORD
         BE    PDSRCM$M_MFC$AL_DOUBLE
         AIF   (NOT D'ESDAL_PAGE).MFCPX
         CLI   ESD_ALIGN,ESDAL_DOUBLE_WORD
         BE    PDSRCM$M_MFC$AL_PAGE
         B     PDSRCM$M_MFC$ALX
PDSRCM$M_MFC$AL_PAGE DS 0H
         MVC   OCL_ALIGN-OCL(4,R15),=C'Page'
.MFCPX   ANOP  ,
         B     PDSRCM$M_MFC$ALX
PDSRCM$M_MFC$AL_BYTE DS 0H
         MVC   OCL_ALIGN-OCL(4,R15),=C'Byte'
         B     PDSRCM$M_MFC$ALX
PDSRCM$M_MFC$AL_HALF DS 0H
         MVC   OCL_ALIGN-OCL(9,R15),=C'Half Word'
         B     PDSRCM$M_MFC$ALX
PDSRCM$M_MFC$AL_FULL DS 0H
         MVC   OCL_ALIGN-OCL(9,R15),=C'Full Word'
         B     PDSRCM$M_MFC$ALX
PDSRCM$M_MFC$AL_DOUBLE DS 0H
         MVC   OCL_ALIGN-OCL(11,R15),=C'Double Word'
PDSRCM$M_MFC$ALX DS 0H
*
** Return to caller
*
         L     R14,PDSRCMD_DOUBLE                  Get return address
         BSM   0,R14
         DROP  R6,R7
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Report on Translator information
**
** We have some special code that looks at the modules that have more
** than one translator record.  Sometimes the second entry is fine
** like for PLS.  Other times, there is a "garbage" second entry that
** begins with the member name.  When we figure out when the second
** translator isn't bogus, we can remove the IF1FT flag stuff...
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
PDSRCM$M_TRAN DS 0H
         TM    PDSRCMD_FLAG1,$PDSRCMD_F1TRAN
         BNO   PDSRCM$M_TRANQO
         NI    PDSRCMD_IFLAG1,255-$PDSRCMD_IF1TRM
         NI    PDSRCMD_IFLAG1,255-$PDSRCMD_IF1FT
         ST    R14,PDSRCMD_MTRA          Save return address
*
         BAS   R14,PDSRCM_MFCS           Format common report section
*
         STM   R4,R9,PDSRCMD_MTSREG      Save work registers
         LM    R6,R7,PDSRCMD_SAVEIDL     Get saved registers
         USING IEWBIDL,R6
         USING IDL_ENTRY,R7
         MVC   PDSRCMD_CURSORDL(4),PDSRCM_ZEROS Set cursor
         MVC   PDSRCMD_FUNC(8),=CL8'GETD-IDL'
         AIF   ('&IHADFARELS' LT '01010300').MGIDL  at DFSMS/MVS 1.3?
*-GETD/IDL for DFSMS/MVS 1.3 and higher
         IEWBIND FUNC=GETD,                                            C
               VERSION=1,                                              C
               RETCODE=PDSRCMD_RETCODE,                                C
               RSNCODE=PDSRCMD_RSNCODE,                                C
               WORKMOD=PDSRCMD_WKTOKEN,                                C
               SECTION=PDSRCMD_SECTION,                                C
               AREA=IEWBIDL,                                           C
               CLASS=PDSRCMD_B_IDRL,                                   C
               CURSOR=PDSRCMD_CURSORDL,                                C
               COUNT=PDSRCMD_COUNTDL,                                  C
               MF=(E,PDSRCMD_PARMLIST)
         AGO   .MGIDLX
.MGIDL   ANOP  ,
*-GETD/IDL for DFSMS/MVS 1.1 and 1.2
         IEWBIND FUNC=GETD,                                            C
               RETCODE=PDSRCMD_RETCODE,                                C
               RSNCODE=PDSRCMD_RSNCODE,                                C
               WORKMOD=PDSRCMD_WKTOKEN,                                C
               SECTION=PDSRCMD_SECTION,                                C
               AREA=IEWBIDL,                                           C
               CLASS=PDSRCMD_B_IDRL,                                   C
               CURSOR=PDSRCMD_CURSORDL,                                C
               COUNT=PDSRCMD_COUNTDL,                                  C
               MF=(E,PDSRCMD_PARMLIST)
.MGIDLX  ANOP  ,
*
         LH    R0,=AL2(IDLH_END-IDLH_START) Get length of header
         LA    R1,C_ID_IDL_HEADER   Locate string of header name
         LR    R15,R6               Locate area to dump
         BAS   R14,PDSRCM_DUMPE     Dump entry
*
         CLC   PDSRCMD_RSNCODE(4),C_IEWB_RC_OK
         BE    PDSRCM$M_TRANS
         CLC   PDSRCMD_RETCODE(4),C_IEWB_RC_WARNING Last buffer?
         BE    PDSRCM$M_TRANS
         CLC   PDSRCMD_RETCODE(4),C_IEWB_RC_ERROR No data for item
         BNE   PDSRCM$M_TRANX       Nothing to report...
*
** Look at the output of the GETD translator call
*
PDSRCM$M_TRANS DS 0H
         L     R4,PDSRCMD_COUNTDL   Number of IDRL entries in buffer
         LTR   R4,R4                Skip empty section
         BZ    PDSRCM$M_TRANX
         LA    R7,IDLH_END          First record in IDL buffer
PDSRCM$M_TRANL DS 0H
*
         LH    R0,=AL2(IDL_END-IDL_ENTRY) Get length of entry
         LA    R1,C_ID_IDL_BUFFER         Locate string of entry type
         LR    R15,R7                     Locate area to dump
         BAS   R14,PDSRCM_DUMPE           Dump entry
*
         TM    PDSRCMD_IFLAG3,$PDSRCMD_IF3IVC Vendor CSECT?
         BO    PDSRCM$M_TRANSZX           Yes, don't test it
         L     R14,PDSRCMD_SAVEESD+4
         CLC   ESD_LENG-ESD_ENTRY(4,R14),PDSRCMD_TRMSIZE
         BNH   PDSRCM$M_TRANSZX
         MVC   PDSRCMD_TRMSIZE(4),ESD_LENG-ESD_ENTRY(R14)
*-Note: need to support CSECT names longer than 8 bytes!!!!
         MVC   PDSRCMD_TRMSIZEN(8),PDSRCMD_SECTION+2
         MVC   PDSRCMD_TRMSIZEM(8),PDSRCMD_MODNAME+2
PDSRCM$M_TRANSZX DS 0H
*
         TM    PDSRCMD_IFLAG1,$PDSRCMD_IF1FT First one?
         BO    PDSRCM$M_TRANLB            No, continue
*
         OI    PDSRCMD_IFLAG1,$PDSRCMD_IF1TRM
         LA    R15,PDSRCMD_RECOUT         Restore address
*
         TM    PDSRCMD_IFLAG3,$PDSRCMD_IF3IVC Vendor CSECT?
         BO    PDSRCM$M_TRODX                 Yes, leave
         CLC   PDSRCMD_TRODATE(L'PDSRCMD_TRODATE),IDL_DATE_PROCESSED
         BL    PDSRCM$M_TRODX
         MVC   PDSRCMD_TRODATE(L'IDL_DATE_PROCESSED),IDL_DATE_PROCESSED
         MVC   PDSRCMD_TRODATEM(8),PDSRCMD_MODNAME+2
*-Note: need to support CSECT names longer than 8 bytes!!!!
         MVC   PDSRCMD_TRODATEN(L'PDSRCMD_TRODATEN),PDSRCMD_SECTION+2
         L     R14,PDSRCMD_SAVEESD+4
         CLI   ESD_SCOPE-ESD_ENTRY(R14),C'S' $PRIVATE?
         BNE   PDSRCM$M_TRODX                No, continue
         LA    R15,PDSRCMD_TRODATEN
         MVI   0(R15),C' '
         MVC   1(L'PDSRCMD_TRODATEN-1,R15),0(R15)
         MVC   0(6,R15),=C'$Priv#'
         LA    R15,6(R15)
         LH    R1,PDSRCMD_CSPRIVC
         BAS   R14,PDSRCM_EDITFWF
         LA    R15,PDSRCMD_RECOUT         Restore address
PDSRCM$M_TRODX DS 0H
         MVC   OCL_TRANDATE-OCL(4,R15),IDL_DATE_PROCESSED
         MVI   OCL_TRANDATE+4-OCL(R15),C'.'
         MVC   OCL_TRANDATE+5-OCL(3,R15),IDL_DATE_PROCESSED+4
*
         MVC   OCL_TRANID-OCL(L'OCL_TRANID,R15),IDL_PID_ID
         MVC   OCL_TRANVER-OCL(L'OCL_TRANVER,R15),IDL_VERSION
         MVI   OCL_TRANDOT-OCL(R15),C'.'
         MVC   OCL_TRANMOD-OCL(L'OCL_TRANMOD,R15),IDL_MOD_LEVEL
*
         LM    R0,R1,PDSRCMD_MTRCXREF     Get table length & address
         SH    R0,=AL2(CXREFL)            Subtract for last entry
PDSRCM$M_TRANTSL DS 0H
         CLC   TRANT_ID-TRANT(L'TRANT_ID,R1),IDL_PID_ID
         BE    PDSRCM$M_TRANTSF
         LA    R1,CXREFL(R1)              Bump to next one
         SH    R0,=AL2(CXREFL)            Decrement table length
         LTR   R0,R0
         BZ    PDSRCM$M_TRANTSE
         BM    PDSRCM$M_TRANTSE
         CLC   0(2,R1),=X'FF,FF'          End of the table?
         BNE   PDSRCM$M_TRANTSL
         MVC   OCL_TRANNAME-OCL(8,R15),=C'*Unknown'
         TM    PDSRCMD_IFLAG3,$PDSRCMD_IF3IVC Turn on flag
         BO    PDSRCM$M_TRANTSX
         MVC   TRANT_ID-TRANT(L'TRANT_ID,R1),IDL_PID_ID
         MVC   TRANT_NAME-TRANT(8,R1),=C'*Unknown'
         LA    R14,1
         STCM  R14,B'1111',CXREF_COUNTT-CXREF(R1)
         STCM  R14,B'1111',CXREF_COUNTL-CXREF(R1)
         MVI   CXREF_TYPE-CXREF(R1),$CXREFT_D Set as dynamic add
         MVC   CXREFL(2,R1),=X'FF,FF'     Set next table entry as end
         B     PDSRCM$M_TRANTSX
PDSRCM$M_TRANTSE DS 0H
         TM    PDSRCMD_IFLAG1,$PDSRCMD_IF1TTO
         BO    PDSRCM$M_TRANTSX
         OI    PDSRCMD_IFLAG1,$PDSRCMD_IF1TTO
         MVC   PDSRCMD_DEREC(133),PDSRCMD_RECOUT  Save record
         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format the message
         MVC   0(MSGCM99L,R15),MSGCM99-PDSRCMC(R1)
         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT
         MVC   PDSRCMD_RECOUT(133),PDSRCMD_DEREC  Restore record
         LA    R15,PDSRCMD_RECOUT         Restore address
         B     PDSRCM$M_TRANTSX
PDSRCM$M_TRANTSF DS 0H
         MVC   OCL_TRANNAME-OCL(L'TRANT_NAME,R15),TRANT_NAME-TRANT(R1)
         TM    PDSRCMD_IFLAG3,$PDSRCMD_IF3IVC Turn on flag
         BO    PDSRCM$M_TRANTSX
         ICM   R14,B'1111',CXREF_COUNTT-CXREF(R1)
         LA    R14,1(R14)
         STCM  R14,B'1111',CXREF_COUNTT-CXREF(R1)
         ICM   R14,B'1111',CXREF_COUNTL-CXREF(R1)
         LA    R14,1(R14)
         STCM  R14,B'1111',CXREF_COUNTL-CXREF(R1)
PDSRCM$M_TRANTSX DS 0H
*
         BAS   R14,PDSRCM_TRPRR     Print Report Record
*
         TM    PDSRCMD_IFLAG2,$PDSRCMD_IF2FO Flatout processing?
         BNO   PDSRCM$M_TRANFOX     No, skip this code
         L     R1,PDSRCMD_FOA+4     Locate FLATOUT record Area
         LA    R1,FOM_RECORD-FOM(R1) Locate to record output
         MVC   FORC_OCL-FOR(OCLSL-1,R1),PDSRCMD_RECOUT+1
PDSRCM$M_TRANFOX DS 0H
*
         BAS   R14,PDSRCM_CLEAR_RECOUT

         OI    PDSRCMD_IFLAG1,$PDSRCMD_IF1FT Say that we've been here
PDSRCM$M_TRANLB DS 0H
         A     R7,IDLH_ENTRY_LENG   Move to next IDL in this section
         BCT   R4,PDSRCM$M_TRANL
PDSRCM$M_TRANLBX DS 0H
*
** Exit from translator processing
*
PDSRCM$M_TRANX DS 0H
         LA    R15,PDSRCMD_RECOUT   Restore R15 to output line
         LM    R4,R9,PDSRCMD_MTSREG Restore our regs
         L     R14,PDSRCMD_MTRA     Get return address
PDSRCM$M_TRANQO DS 0H
         BSM   0,R14                Return to caller
         DROP  R6,R7
         EJECT ,
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Report on Binder Identification information
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
PDSRCM$M_BIND DS 0H
         XC    PDSRCMD_BINDER(4),PDSRCMD_BINDER Reset binder pointer
         ST    R14,PDSRCMD_MTRA          Save return address
*
         STM   R4,R9,PDSRCMD_MTSREG      Save work registers
         LM    R6,R7,PDSRCMD_SAVEIDB     Get saved registers
         USING IEWBIDB,R6
         USING IDB_ENTRY,R7
         MVC   PDSRCMD_CURSORDL(4),PDSRCM_ZEROS Set cursor
         MVC   PDSRCMD_FUNC(8),=CL8'GETD-IDB'
         AIF   ('&IHADFARELS' LT '01010300').MGIDB  at DFSMS/MVS 1.3?
*-GETD/IDB for DFSMS/MVS 1.3 and higher
         IEWBIND FUNC=GETD,                                            C
               VERSION=1,                                              C
               RETCODE=PDSRCMD_RETCODE,                                C
               RSNCODE=PDSRCMD_RSNCODE,                                C
               WORKMOD=PDSRCMD_WKTOKEN,                                C
               SECTION=PDSRCMD_SECTION,                                C
               AREA=IEWBIDB,                                           C
               CLASS=PDSRCMD_B_IDRB,                                   C
               CURSOR=PDSRCMD_CURSORDL,                                C
               COUNT=PDSRCMD_COUNTDL,                                  C
               MF=(E,PDSRCMD_PARMLIST)
         AGO   .MGIDBX
.MGIDB   ANOP  ,
*-GETD/IDB for DFSMS/MVS 1.1 and 1.2
         IEWBIND FUNC=GETD,                                            C
               RETCODE=PDSRCMD_RETCODE,                                C
               RSNCODE=PDSRCMD_RSNCODE,                                C
               WORKMOD=PDSRCMD_WKTOKEN,                                C
               SECTION=PDSRCMD_SECTION,                                C
               AREA=IEWBIDB,                                           C
               CLASS=PDSRCMD_B_IDRB,                                   C
               CURSOR=PDSRCMD_CURSORDL,                                C
               COUNT=PDSRCMD_COUNTDL,                                  C
               MF=(E,PDSRCMD_PARMLIST)
.MGIDBX  ANOP  ,
*
         LH    R0,=AL2(IDBH_END-IDBH_START) Get length of header
         LA    R1,C_ID_IDB_HEADER   Locate string of header name
         LR    R15,R6               Locate area to dump
         BAS   R14,PDSRCM_DUMPE     Dump entry
*
         CLC   PDSRCMD_RSNCODE(4),C_IEWB_RC_OK
         BE    PDSRCM$M_BINDS
         CLC   PDSRCMD_RETCODE(4),C_IEWB_RC_WARNING Last buffer?
         BE    PDSRCM$M_BINDS
         CLC   PDSRCMD_RETCODE(4),C_IEWB_RC_ERROR No data for item
         BNE   PDSRCM$M_BINDX       Nothing to report...
*
** Look at the output of the GETD Binder call
*
PDSRCM$M_BINDS DS 0H
         L     R4,PDSRCMD_COUNTDL   Number of IDRB entries in buffer
         LTR   R4,R4                Skip empty section
         BZ    PDSRCM$M_BINDX
         LA    R7,IDBH_END          First record in IDB buffer
PDSRCM$M_BINDL DS 0H
*
         LH    R0,=AL2(IDB_END-IDB_ENTRY)  Get length of entry
         LA    R1,C_ID_IDB_BUFFER   Locate string of entry type
         LR    R15,R7               Locate area to dump
         BAS   R14,PDSRCM_DUMPE     Dump entry
         ST    R7,PDSRCMD_BINDER    Save IDB buffer entry pointer
*
PDSRCM$M_BINDLB DS 0H
*->      A     R7,IDBH_ENTRY_LENG   Move to next IDB in this section
*->      BCT   R4,PDSRCM$M_BINDL
PDSRCM$M_BINDLBX DS 0H
*
** Exit from Binder processing
*
PDSRCM$M_BINDX DS 0H
         LA    R15,PDSRCMD_RECOUT   Restore R15 to output line
         LM    R4,R9,PDSRCMD_MTSREG Restore our regs
         L     R14,PDSRCMD_MTRA     Get return address
PDSRCM$M_BINDQO DS 0H
         DROP  R6,R7
.IDBEX   ANOP  ,
         BSM   0,R14                Return to caller
         EJECT ,
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Process TEXT data for this CSECT
** - Dump CSECT
** - Eyecatcher report
** - Search for string (not implemented yet)
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
PDSRCM$M_TEXT DS 0H
         TM    PDSRCMD_FLAG1,$PDSRCMD_F1TEXT Doing text processing?
         BNO   PDSRCM$M_TEXTQO           No, quick out
*
         TM    PDSRCMD_IFLAG2,$PDSRCMD_IF2FO Flatout processing?
         BO    PDSRCM$M_TEXTIX           No, skip this code
         TM    PDSRCMD_IFLAG3,$PDSRCMD_IF3EC Eyecatcher?
         BO    PDSRCM$M_TEXTIX           Yes, Continue
         B     PDSRCM$M_TEXTQO           Oops, no valid options
PDSRCM$M_TEXTIX DS 0H
         ST    R14,PDSRCMD_MTRA          Save return address
*
** Get the Binder API to cough up the text for this CSECT
*
         STM   R4,R9,PDSRCMD_MTSREG      Save work registers
         LM    R6,R7,PDSRCMD_SAVETXT     Get saved registers
         USING IEWBTXT,R6
         USING TXT_ENTRY,R7
         MVC   PDSRCMD_CURSORDL(4),PDSRCM_ZEROS Set cursor
         MVC   PDSRCMD_FUNC(8),=CL8'GETD-TXT'
         AIF   ('&IHADFARELS' LT '01010300').MGTXT  at DFSMS/MVS 1.3?
*-GETD/TXT for DFSMS/MVS 1.3 and higher
         IEWBIND FUNC=GETD,                                            C
               VERSION=1,                                              C
               RETCODE=PDSRCMD_RETCODE,                                C
               RSNCODE=PDSRCMD_RSNCODE,                                C
               WORKMOD=PDSRCMD_WKTOKEN,                                C
               SECTION=PDSRCMD_SECTION,                                C
               AREA=IEWBTXT,                                           C
               CLASS=PDSRCMD_B_TEXT,                                   C
               CURSOR=PDSRCMD_CURSORDL,                                C
               COUNT=PDSRCMD_COUNTDL,                                  C
               MF=(E,PDSRCMD_PARMLIST)
         AGO   .MGTXTX
.MGTXT   ANOP  ,
*-GETD/TXT for DFSMS/MVS 1.1 and 1.2
         IEWBIND FUNC=GETD,                                            C
               RETCODE=PDSRCMD_RETCODE,                                C
               RSNCODE=PDSRCMD_RSNCODE,                                C
               WORKMOD=PDSRCMD_WKTOKEN,                                C
               SECTION=PDSRCMD_SECTION,                                C
               AREA=IEWBTXT,                                           C
               CLASS=PDSRCMD_B_TEXT,                                   C
               CURSOR=PDSRCMD_CURSORDL,                                C
               COUNT=PDSRCMD_COUNTDL,                                  C
               MF=(E,PDSRCMD_PARMLIST)
.MGTXTX  ANOP  ,
*
         LH    R0,=AL2(TXTH_END-TXTH_START) Get length of header
         LA    R1,C_ID_TXT_HEADER   Locate string of header name
         LR    R15,R6               Locate area to dump
         BAS   R14,PDSRCM_DUMPE     Dump entry
*
         CLC   PDSRCMD_RSNCODE(4),C_IEWB_RC_OK
         BE    PDSRCM$M_TEXTS
         CLC   PDSRCMD_RETCODE(4),C_IEWB_RC_WARNING Last buffer?
         BE    PDSRCM$M_TEXTS
         CLC   PDSRCMD_RETCODE(4),C_IEWB_RC_ERROR No data for item
         BNE   PDSRCM$M_TEXTX       Nothing to report...
*
** Look at the output of the GETD TEXT call
*
PDSRCM$M_TEXTS DS 0H
         L     R4,PDSRCMD_COUNTDL   Number of TEXT entries in buffer
         LTR   R4,R4                Skip empty section
         BZ    PDSRCM$M_TEXTX
         LA    R7,TXTH_END          First record in TXT buffer
PDSRCM$M_TEXTL DS 0H
*
** Eye-Catcher report processing
**
** We use PDSRCMM's MXREC and MXSAVE
*
         TM    PDSRCMD_IFLAG3,$PDSRCMD_IF3EC Eyecatcher?
         BNO   PDSRCM$M_TEXTECX           No, continue
         STM   R2,R9,PDSRCMD_MXSAVE       Save work regs
         LA    R3,PDSRCMD_MXREC           Locate output record
         L     R2,PDSRCMD_PDS2            Locate PDS2 area
         LR    R9,R7                      Get CSECT start
         L     R8,PDSRCMD_SAVEESD+4
         L     R8,ESD_LENG-ESD_ENTRY(R8)
         LA    R0,PDSRCMD_SECTION+2       Locate CSECT name
         L     R1,PDSRCMD_SUBRSAP         Locate SUBRSA
*
*-R0=CSECT R1=SUBRSA R2=PDS2 R3=Output R8=Module Length R9=Module start
         L     R15,=V(PDSR$EC)            Locate routine
         BASR  R14,R15                    Call Eyecatcher routine
*
         L     R1,PDSRCMD_SUBRSAP         Locate to area
         LA    R1,ECRPT-SUBRSA(R1)
         PUT   (1),PDSRCMD_MXREC          Put out record
         LM    R2,R9,PDSRCMD_MXSAVE       Rest work regs
PDSRCM$M_TEXTECX DS 0H  . . . . . . . . . . . . . . . . . . . . .
*
** Get the first 256 bytes of the CSECT into the FLATOUT record
*
         TM    PDSRCMD_IFLAG2,$PDSRCMD_IF2FO Flatout processing?
         BNO   PDSRCM$M_TEXTFX        No, skip this code
         L     R1,PDSRCMD_FOA+4        Locate FLATOUT record Area
         LA    R1,FOM_RECORD-FOM(R1)    Locate to record output
         XC    FORC_CSECT256-FOR(256,R1),FORC_CSECT256-FOR(R1)
         L     R14,PDSRCMD_SAVEESD+4       Locate Binder area
         L     R14,ESD_LENG-ESD_ENTRY(R14)  Get length of CSECT
         C     R14,=F'256'                   Under our minimum?
         BNH   PDSRCM$M_TEXTFS                Yes, continue
         LA    R14,256                         No, set max length
PDSRCM$M_TEXTFS DS 0H                           Ready for move
         BCTR  R14,0                             Decrement for EX
         EX    R14,PDSRCM$M_TEXTFM                Move up to first 256
         B     PDSRCM$M_TEXTFX                     Continue
PDSRCM$M_TEXTFM MVC FORC_CSECT256-FOR(0,R1),0(R7)   Executed
PDSRCM$M_TEXTFX DS 0H
*
** Exit from Text processing
*
PDSRCM$M_TEXTX DS 0H
         LM    R4,R9,PDSRCMD_MTSREG Restore our regs
         L     R14,PDSRCMD_MTRA     Get return address
PDSRCM$M_TEXTQO DS 0H
         BSM   0,R14                Return to caller
         DROP  R6,R7
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** CSECT history report for User records
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
PDSRCM$M_HISTU DS 0H
         TM    PDSRCMD_FLAG1,$PDSRCMD_F1HIST
         BNO   PDSRCM$M_HISTUQO
         NI    PDSRCMD_IFLAG1,255-$PDSRCMD_IF1HIM
         ST    R14,PDSRCMD_MHIA          Save return address
*
         BAS   R14,PDSRCM_MFCS           Format common report section
*
         STM   R4,R7,PDSRCMD_MHSREG      Save work registers
         LM    R6,R7,PDSRCMD_SAVEIDU     Get saved registers
         USING IEWBIDU,R6
         USING IDU_ENTRY,R7
         MVC   PDSRCMD_CURSORDU(4),PDSRCM_ZEROS Set cursor
         MVC   PDSRCMD_FUNC(8),=CL8'GETD-IDU'
         AIF   ('&IHADFARELS' LT '01010300').MGIDU  at DFSMS/MVS 1.3?
*-GETD/IDU for DFSMS/MVS 1.3 and higher
         IEWBIND FUNC=GETD,                                            C
               VERSION=1,                                              C
               RETCODE=PDSRCMD_RETCODE,                                C
               RSNCODE=PDSRCMD_RSNCODE,                                C
               WORKMOD=PDSRCMD_WKTOKEN,                                C
               SECTION=PDSRCMD_SECTION,                                C
               AREA=IEWBIDU,                                           C
               CLASS=PDSRCMD_B_IDRU,                                   C
               CURSOR=PDSRCMD_CURSORDU,                                C
               COUNT=PDSRCMD_COUNTDU,                                  C
               MF=(E,PDSRCMD_PARMLIST)
         AGO   .MGIDUX
.MGIDU   ANOP  ,
*-GETD/IDU for DFSMS/MVS 1.3 and higher
         IEWBIND FUNC=GETD,                                            C
               RETCODE=PDSRCMD_RETCODE,                                C
               RSNCODE=PDSRCMD_RSNCODE,                                C
               WORKMOD=PDSRCMD_WKTOKEN,                                C
               SECTION=PDSRCMD_SECTION,                                C
               AREA=IEWBIDU,                                           C
               CLASS=PDSRCMD_B_IDRU,                                   C
               CURSOR=PDSRCMD_CURSORDU,                                C
               COUNT=PDSRCMD_COUNTDU,                                  C
               MF=(E,PDSRCMD_PARMLIST)
.MGIDUX  ANOP  ,
*
         LH    R0,=AL2(IDUH_END-IDUH_START) Get length of header
         LA    R1,C_ID_IDU_HEADER   Locate string of header name
         LR    R15,R6               Locate area to dump
         BAS   R14,PDSRCM_DUMPE     Dump entry
*
         CLC   PDSRCMD_RSNCODE(4),C_IEWB_RC_OK
         BE    PDSRCM$M_HISTUS
         CLC   PDSRCMD_RETCODE(4),C_IEWB_RC_WARNING Last buffer?
         BE    PDSRCM$M_HISTUS
         CLC   PDSRCMD_RETCODE(4),C_IEWB_RC_ERROR No data for item
         BNE   PDSRCM$M_HISTUX      Nothing to report...
*
** Look at the output of the GETD IDR User call
*
PDSRCM$M_HISTUS DS 0H
         L     R4,PDSRCMD_COUNTDU   Number of IDRU entries in buffer
         LTR   R4,R4                Skip empty section
         BZ    PDSRCM$M_HISTUX
         LA    R7,IDUH_END          First record in IDU buffer
PDSRCM$M_HISTUL DS 0H
         L     R1,PDSRCMD_MHCOUNTU  Get total count
         LA    R1,1(R1)
         ST    R1,PDSRCMD_MHCOUNTU  Save total count
*
         LH    R0,=AL2(IDU_END-IDU_ENTRY)  Get length of entry
         LA    R1,C_ID_IDU_BUFFER   Locate string of entry type
         LR    R15,R7               Locate area to dump
         BAS   R14,PDSRCM_DUMPE     Dump entry
*
         OI    PDSRCMD_IFLAG1,$PDSRCMD_IF1HIM
         LA    R15,PDSRCMD_RECOUT   Restore address
         MVC   OCL_HISTDATE-OCL(4,R15),IDU_CREATE_DATE
         MVI   OCL_HISTDATE+4-OCL(R15),C'.'
         MVC   OCL_HISTDATE+5-OCL(3,R15),IDU_CREATE_DATE+4
         MVC   OCL_HISTDATA-OCL(3,R15),=C'ID:'
#IDU_HISTDATA EQU 27-5
         LH    R1,IDU_DATA_CHARS    Get number of good bytes
         CH    R1,=AL2(#IDU_HISTDATA)
         BL    PDSRCM$M_HISTULHDM
         LA    R1,#IDU_HISTDATA
PDSRCM$M_HISTULHDM DS 0H
         BCTR  R1,0
         EX    R1,PDSRCM$M_HISTUDM  Move data to line
*-Added for CA-Endevor which puts non-human readable stuff in IDRU
         L     R14,=V(PDSR$C2)      Locate constants CSECT
         EX    R1,PDSRCM$M_HISTUDT  Translate data (just in case)
*
         BAS   R14,PDSRCM_HIPRR     Print Report Record
         BAS   R14,PDSRCM_CLEAR_RECOUT

PDSRCM$M_HISTULB DS 0H
         A     R7,IDUH_ENTRY_LENG   Move to next IDU in this section
         BCT   R4,PDSRCM$M_HISTUL
*
** Exit from History processing
*
PDSRCM$M_HISTUX DS 0H
         LA    R15,PDSRCMD_RECOUT   Restore R15 to output line
         LM    R4,R7,PDSRCMD_MHSREG Restore our regs
         L     R14,PDSRCMD_MHIA     Get return address
PDSRCM$M_HISTUQO DS 0H
         BSM   0,R14                Return to caller
*
PDSRCM$M_HISTUDM MVC   OCL_HISTDATA+4-OCL(0,R15),IDU_DATA
PDSRCM$M_HISTUDT TR    OCL_HISTDATA+4-OCL(0,R15),C_TRTABA-PDSR$C2(R14)
         DROP  R6,R7
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** CSECT history report for Zap records
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
PDSRCM$M_HISTZ DS 0H
         TM    PDSRCMD_FLAG1,$PDSRCMD_F1HIST
         BNO   PDSRCM$M_HISTZQO
         NI    PDSRCMD_IFLAG1,255-$PDSRCMD_IF1HIM
         ST    R14,PDSRCMD_MHIA          Save return address
*
         BAS   R14,PDSRCM_MFCS           Format common report section
*
         STM   R4,R7,PDSRCMD_MHSREG      Save work registers
         LM    R6,R7,PDSRCMD_SAVEIDZ     Get saved registers
         USING IEWBIDZ,R6
         USING IDZ_ENTRY,R7
         MVC   PDSRCMD_CURSORDU(4),PDSRCM_ZEROS Set cursor
         MVC   PDSRCMD_FUNC(8),=CL8'GETD-IDZ'
         AIF   ('&IHADFARELS' LT '01010300').MGIDZ  at DFSMS/MVS 1.3?
*-GETD/IDZ for DFSMS/MVS 1.3 and higher
         IEWBIND FUNC=GETD,                                            C
               VERSION=1,                                              C
               RETCODE=PDSRCMD_RETCODE,                                C
               RSNCODE=PDSRCMD_RSNCODE,                                C
               WORKMOD=PDSRCMD_WKTOKEN,                                C
               SECTION=PDSRCMD_SECTION,                                C
               AREA=IEWBIDZ,                                           C
               CLASS=PDSRCMD_B_IDRZ,                                   C
               CURSOR=PDSRCMD_CURSORDU,                                C
               COUNT=PDSRCMD_COUNTDU,                                  C
               MF=(E,PDSRCMD_PARMLIST)
         AGO   .MGIDZX
.MGIDZ   ANOP  ,
*-GETD/IDZ for DFSMS/MVS 1.1 and 1.2
         IEWBIND FUNC=GETD,                                            C
               RETCODE=PDSRCMD_RETCODE,                                C
               RSNCODE=PDSRCMD_RSNCODE,                                C
               WORKMOD=PDSRCMD_WKTOKEN,                                C
               SECTION=PDSRCMD_SECTION,                                C
               AREA=IEWBIDZ,                                           C
               CLASS=PDSRCMD_B_IDRZ,                                   C
               CURSOR=PDSRCMD_CURSORDU,                                C
               COUNT=PDSRCMD_COUNTDU,                                  C
               MF=(E,PDSRCMD_PARMLIST)
.MGIDZX  ANOP  ,
*
         LH    R0,=AL2(IDZH_END-IDZH_START) Get length of header
         LA    R1,C_ID_IDZ_HEADER   Locate string of header name
         LR    R15,R6               Locate area to dump
         BAS   R14,PDSRCM_DUMPE     Dump entry
*
         CLC   PDSRCMD_RSNCODE(4),C_IEWB_RC_OK
         BE    PDSRCM$M_HISTZS
         CLC   PDSRCMD_RETCODE(4),C_IEWB_RC_WARNING
         BNE   PDSRCM$M_HISTZE
*
** Look at the output of the GETD IDZ call
*
PDSRCM$M_HISTZS DS 0H
         L     R4,PDSRCMD_COUNTDU   Number of IDRZ entries in buffer
         LTR   R4,R4                Skip empty section
         BZ    PDSRCM$M_HISTZX
         LA    R7,IDZH_END          First record in IDZ buffer
PDSRCM$M_HISTZL DS 0H
         L     R1,PDSRCMD_MHCOUNTZ  Get total count
         LA    R1,1(R1)
         ST    R1,PDSRCMD_MHCOUNTZ  Save total count
*
         L     R1,PDSRCMD_MZAPCNT   Get total count
         LA    R1,1(R1)
         ST    R1,PDSRCMD_MZAPCNT   Save total count
*
         LH    R0,=AL2(IDZ_END-IDZ_ENTRY)  Get length of entry
         LA    R1,C_ID_IDZ_BUFFER   Locate string of entry type
         LR    R15,R7               Locate area to dump
         BAS   R14,PDSRCM_DUMPE     Dump entry
*
         OI    PDSRCMD_IFLAG1,$PDSRCMD_IF1HIM
         LA    R15,PDSRCMD_RECOUT   Restore address
         MVC   OCL_HISTDATE-OCL(4,R15),IDZ_DATE
         MVI   OCL_HISTDATE+4-OCL(R15),C'.'
         MVC   OCL_HISTDATE+5-OCL(3,R15),IDZ_DATE+4
         MVC   OCL_HISTDATA-OCL(4,R15),=C'Zap:'
         MVC   OCL_HISTDATA+5-OCL(L'IDZ_ZAP_DATA,R15),IDZ_ZAP_DATA
*
         BAS   R14,PDSRCM_HIPRR     Print Report Record
         BAS   R14,PDSRCM_CLEAR_RECOUT

PDSRCM$M_HISTZLB DS 0H
         A     R7,IDZH_ENTRY_LENG   Move to next IDZ in this section
         BCT   R4,PDSRCM$M_HISTZL
         B     PDSRCM$M_HISTZX
*
** Error in History processing
** Not seen in real life - added: 27MAR1998
*
PDSRCM$M_HISTZE DS 0H
         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format message
         MVC   0(MSGCM19L,R15),MSGCM19-PDSRCMC(R1) Get text
         MVC   MSGCM19L(8,R15),PDSRCMD_MODNAME+2  Get member name
         LA    R15,MSGCM19L+8(R15)
         MVC   0(5,R15),=C'- RC='
         LA    R15,5(R15)
         L     R1,PDSRCMD_RETCODE
         BAS   R14,PDSRCM_EDITFWF        Edit it
         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT
*
** Exit from History processing
*
PDSRCM$M_HISTZX DS 0H
         LA    R15,PDSRCMD_RECOUT   Restore R15 to output line
         LM    R4,R7,PDSRCMD_MHSREG Restore our regs
         L     R14,PDSRCMD_MHIA     Get return address
PDSRCM$M_HISTZQO DS 0H
         BSM   0,R14                Return to caller
*
         DROP  R6,R7
         EJECT ,
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Library Start - Initialize for new library
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
PDSRCM$S DS    0H
         NI    PDSRCMD_IFLAG2,255-$PDSRCMD_IF2MEM   Turn off flag
         MVI   PDSRCMD_TRPRRLC,99                   Reset heading
         XC    PDSRCMD_TRMSIZE(4),PDSRCMD_TRMSIZE   Clear size
         MVC   PDSRCMD_TRODATE(7),=X'FF,FF,FF,FF,FF,FF,FF'
         MVI   PDSRCMD_HIPRRLC,99                   Reset heading
         XC    PDSRCMD_MHCOUNTU(4),PDSRCMD_MHCOUNTU
         XC    PDSRCMD_MHCOUNTZ(4),PDSRCMD_MHCOUNTZ
         XC    PDSRCMD_CSECTS(4),PDSRCMD_CSECTS
*
         L     R1,PDSRCMD_LIBC           Get library count
         LA    R1,1(R1)                  Increment by 1
         ST    R1,PDSRCMD_LIBC           Save count
*
** Flatout processing
*
         TM    PDSRCMD_IFLAG2,$PDSRCMD_IF2FO    Flatout processing?
         BNO   PDSRCM$S_FOX                     No, skip this code
         L     R1,PDSRCMD_FOA+4          Locate FLATOUT record Area
         LA    R1,FOM_RECORD-FOM(R1) Locate to record output
         MVI   FOR_TYPE-FOR(R1),$FORTYPE_D  Set type: DSN
         MVI   FOR_SPACE1-FOR(R1),C' '
         MVI   FOR_SPACE2-FOR(R1),C' '
         LA    R15,FOR_LIBN-FOR(R1)      Locate library num output
         MVI   0(R15),C' '               Get blank
         MVC   1(L'FOR_LIBN-1,R15),0(R15) Propagate blanks.
         L     R1,PDSRCMD_LIBC           Get library count
         BAS   R14,PDSRCM_EDITFWF        Edit it
*
         L     R1,PDSRCMD_FOA+4          Locate FLATOUT record Area
         LA    R1,FOM_RECORD-FOM(R1)     Locate to record output
         L     R14,PDSRCMD_VOLSER        Get address of volser
         MVC   FORD_VOL-FOR(6,R1),0(R14) Insert volser
         MVI   FORD_SPACE1-FOR(R1),C' '  Ensure space in right place
         L     R14,PDSRCMD_DSNAME        Locate dataset name
         MVC   FORD_DSN-FOR(44,R1),0(R14) Insert dataset name
         LA    R15,FORD_DSN-FOR(R1)      Locate to start of DSN
         BAS   R14,PDSRCM_LOCATE_FIRST_SPACE
         L     R1,PDSRCMD_FOA+4          Locate FLATOUT record Area
         LA    R1,FOM_RDW-FOM(R1)        Locate to record output
         SR    R15,R1                    Length = end - start
         STH   R15,0(R1)                 Save length of variable record
         LR    R0,R1                     Get record loc to rite reg
         PUT   PDSRCMD_DCBF,(0)          Output record...
PDSRCM$S_FOX DS 0H
*
** Print SMS information about this dataset
*
#SMSDAL  EQU   30                        Length of each sms_data area
#SMSDN   EQU   3                         Number of sms_data areas
#SMSDL   EQU   #SMSDAL*#SMSDN            Total length of areas
*
         AIF   ('&IHADFARELS' LT '01010300').SASMSX at DFSMS/MVS 1.3?
         CLC   PDSRCMD_DFARELS(4),=X'01010300' Lower than v1.3?
         BL    PDSRCM$S_ASMSX            Yes, don't bother
         ICM   R15,B'1111',PDSRCMD_IGWASMS
         BZ    PDSRCM$S_ASMSX            Yes, don't bother
*
         L     R1,PDSRCMD_DSNAME         Locate dataset name
         SLR   R14,R14                   Clear length counter
         LA    R0,44                     Set max length of dsname
PDSRCM$S_ASMS_DSL DS 0H
         CLI   0(R1),C' '                Hit the end yet?
         BE    PDSRCM$S_ASMS_DSX         Yes, leave
         LA    R1,1(R1)                  No, bump to next byte
         LA    R14,1(R14)                ..increment counter
         BCT   R0,PDSRCM$S_ASMS_DSL      ..and process next byte
PDSRCM$S_ASMS_DSX DS 0H
         ST    R14,PDSRCMD_COUNTDL       Save dsname length
*
         MVC   PDSRCMD_FUNC(8),=CL8'IGWASMS'  Set for debugging
         LA    R1,PDSRCMD_PARMLIST       Locate parameter list
         LA    R14,PDSRCMD_RETCODE       Locate return_code
         XC    0(4,R14),0(R14)
         ST    R14,0(R1)
         LA    R14,PDSRCMD_RSNCODE       Locate reason_code
         XC    0(4,R14),0(R14)
         ST    R14,4(R1)
         LA    R14,PDSRCMD_COUNTN        Locate prob_det
         XC    0(8,R14),0(R14)
         ST    R14,8(R1)
         LA    R14,PDSRCMD_COUNTDL       Locate dsname_length
         ST    R14,12(R1)
         L     R14,PDSRCMD_DSNAME        Locate dsname
         ST    R14,16(R1)
         LA    R14,PDSRCMD_SECTION       Locate sms_data
         XC    0(#SMSDL,R14),0(R14)
         ST    R14,20(R1)
         LA    R14,PDSRCMD_COUNTDE       Locate ds_type
         ST    R14,24(R1)
         BASSM R14,R15
*
         ICM   R15,B'1111',PDSRCMD_RETCODE Get return code
         BZ    PDSRCM$S_ASMSOK
         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format the message
         MVC   0(MSGCM16L,R15),MSGCM16    Move in message text
         LA    R15,MSGCM16L(R15)
         L     R1,PDSRCMD_RETCODE
         BAS   R14,PDSRCM_EDITFWF
         MVC   1(6,R15),=C', RSN='
         LA    R15,1+6(R15)
         L     R1,PDSRCMD_RETCODE
         BAS   R14,PDSRCM_EDITFWF
         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT
         B     PDSRCM$S_ASMSX
PDSRCM$S_ASMSOK DS 0H
         TM    PDSRCMD_IFLAG1,$PDSRCMD_IF1BDB Binder Debug Mode?
         BO    PDSRCM$S_ASMSM15           Yes, be verbose
*-If it makes sense to issue the SMS information, message, do it
         CLC   PDSRCMD_COUNTDE(4),PDSRCM_ZEROS DSTYPE filled in?
         BNE   PDSRCM$S_ASMSM15           Yes, let's print MSG15
         LA    R8,PDSRCMD_SECTION         Locate to area
         CLI   0(R8),C' '                 SMS info?
         BNE   PDSRCM$S_ASMSM15           Yes, let's print MSG15
         LA    R8,#SMSDAL(R8)             Locate to Management clas
         CLI   0(R8),C' '                 SMS info?
         BNE   PDSRCM$S_ASMSM15           Yes, let's print MSG15
         LA    R8,#SMSDAL(R8)             Locate to data class
         CLI   0(R8),C' '                 SMS info?
         BE    PDSRCM$S_ASMSX             No, nothing: leave
PDSRCM$S_ASMSM15 DS 0H
         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format the message
         MVC   0(MSGCM15L,R15),MSGCM15    Move in message text
         LA    R15,MSGCM15L(R15)
         CLC   PDSRCMD_COUNTDE(4),PDSRCM_ZEROS Regular PDS?
         BE    PDSRCM$S_DST_PDS
         CLI   PDSRCMD_COUNTDE+3,1        PDS/E?
         BE    PDSRCM$S_DST_PDSE
         CLI   PDSRCMD_COUNTDE+3,2        HFS?
         BE    PDSRCM$S_DST_HFS
         UNPK  0(9,R15),PDSRCMD_COUNTDE(5)
         MVZ   0(8,R15),PDSRCM_ZEROS
         TR    0(8,R15),PDSRCM_HEXTABLE
         LA    R15,8(R15)
         B     PDSRCM$S_DSTX
PDSRCM$S_DST_HFS DS 0H
         MVC   0(3,R15),=C'HFS'
         LA    R15,3(R15)
         B     PDSRCM$S_DSTX
PDSRCM$S_DST_PDSE DS 0H
         MVC   0(4,R15),=C'PDSE'
         LA    R15,4(R15)
         B     PDSRCM$S_DSTX
PDSRCM$S_DST_PDS DS 0H
         MVC   0(3,R15),=C'PDSE'
         LA    R15,3(R15)
PDSRCM$S_DSTX  DS 0H
         LA    R8,PDSRCMD_SECTION         Locate to area
         MVC   0(13,R15),=C', STOR-Class='
         LA    R15,13(R15)
         CLI   0(R8),C' '
         BE    PDSRCM$S_SCB
         MVC   0(#SMSDAL,R15),0(R8)
         LA    R0,#SMSDAL
         BAS   R14,PDSRCM_LOCATE_FIRST_SPACE
         B     PDSRCM$S_SCX
PDSRCM$S_SCB   DS 0H
         MVI   0(R15),C'*'
         LA    R15,1(R15)
PDSRCM$S_SCX   DS 0H
*
         LA    R8,#SMSDAL(R8)             Locate to Management class
         MVC   0(13,R15),=C', MGMT-Class='
         LA    R15,13(R15)
         CLI   0(R8),C' '
         BE    PDSRCM$S_MCB
         MVC   0(#SMSDAL,R15),0(R8)
         LA    R0,#SMSDAL
         BAS   R14,PDSRCM_LOCATE_FIRST_SPACE
         B     PDSRCM$S_MCX
PDSRCM$S_MCB   DS 0H
         MVI   0(R15),C'*'
         LA    R15,1(R15)
PDSRCM$S_MCX   DS 0H
*
         LA    R8,#SMSDAL(R8)               Locate to Data class
         MVC   0(13,R15),=C', Data-Class='
         LA    R15,13(R15)
         CLI   0(R8),C' '
         BE    PDSRCM$S_DCB
         MVC   0(#SMSDAL,R15),0(R8)
         LA    R0,#SMSDAL
         BAS   R14,PDSRCM_LOCATE_FIRST_SPACE
         B     PDSRCM$S_DCX
PDSRCM$S_DCB   DS 0H
         MVI   0(R15),C'*'
         LA    R15,1(R15)
PDSRCM$S_DCX   DS 0H
*
         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT
PDSRCM$S_ASMSX DS 0H
.SASMSX  ANOP  ,
*
** Common exit from $Library_Start processing
*
         SLR   R15,R15
         B     PDSRCM$X
         EJECT ,
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Library End - print ending statistics if needed
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
PDSRCM$E DS    0H
         TM    PDSRCMD_IFLAG2,$PDSRCMD_IF2MEM Do anything?
         BNO   PDSRCM$E_X
*
** Print Translator stats for library we just processed
*
         TM    PDSRCMD_FLAG1,$PDSRCMD_F1TRAN Doing Translator report?
         BNO   PDSRCM$E_TRX               Nope, leave
*
         LM    R2,R3,PDSRCMD_MTRCXREF     Get table length & address
         NI    PDSRCMD_IFLAG1,255-$PDSRCMD_IF1THR
         SLR   R4,R4                      Clear total
PDSRCM$E_TRL DS 0H
         CLC   CXREF_COUNTL-CXREF(4,R3),PDSRCM_ZEROS Found any?
         BE    PDSRCM$E_TRLB              No, skip print
         TM    PDSRCMD_IFLAG1,$PDSRCMD_IF1THR Print heading?
         BO    PDSRCM$E_TRLHX
         OI    PDSRCMD_IFLAG1,$PDSRCMD_IF1THR We printed the heading
         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format the message
         MVC   0(MSGCM7L,R15),MSGCM7-PDSRCMC(R1) Get text
         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT
PDSRCM$E_TRLHX DS 0H
         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format the message
         MVC   0(MSGCM8L,R15),MSGCM8      Move in message text
         MVC   MSGCM8I-MSGCM8(L'TRANT_ID,R15),TRANT_ID-TRANT(R3)
         MVC   MSGCM8N-MSGCM8(L'TRANT_NAME,R15),TRANT_NAME-TRANT(R3)
         LA    R15,MSGCM8L(R15)           Bump past message
         ICM   R1,B'1111',CXREF_COUNTL-CXREF(R3) Get count
         AR    R4,R1                      Update total
         CVD   R1,PDSRCMD_DOUBLE
         MVC   0(12,R15),=X'40,20,20,20,6B,20,20,20,6B,20,20,20'
         ED    0(12,R15),PDSRCMD_DOUBLE+3
         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT
         LA    R1,0
         STCM  R1,B'1111',CXREF_COUNTL-CXREF(R3) Get count
PDSRCM$E_TRLB DS 0H
         LA    R3,CXREFL(R3)              Bump to next one
         SH    R2,=AL2(CXREFL)            Decrement table length
         LTR   R2,R2
         BZ    PDSRCM$E_TRLX
         BM    PDSRCM$E_TRLX
         CLC   0(2,R3),=X'FF,FF'          End of the table?
         BNE   PDSRCM$E_TRL
PDSRCM$E_TRLX DS 0H
*-Print divider line
         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format the message
         MVC   0(L'MSGCM8,R15),MSGCM8     Move in "C08I  "
         LA    R14,MSGCM8S+2-MSGCM8(R15)  Locate to overright area
         MVI   0(R14),C'-'                Get dash
         MVC   1(MSGCM8SL-2+12-1,R14),0(R14) Propagate dashes
         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT
*-Print totals line
         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format the message
         MVC   0(L'MSGCM8,R15),MSGCM8     Move in "C08I  "
         MVC   MSGCM8S+2-MSGCM8(L'MSGCM8A,R15),MSGCM8A
         LA    R15,MSGCM8L(R15)           Bump past message
         LR    R1,R4                      Update total
         CVD   R1,PDSRCMD_DOUBLE
         MVC   0(12,R15),=X'40,20,20,20,6B,20,20,20,6B,20,20,20'
         ED    0(12,R15),PDSRCMD_DOUBLE+3
         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT
         BAS   R14,PDSRCM_CLEAR_RECOUT    Clear output record
         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT
*
         L     R14,PDSRCMD_PSRAREA        Locate to area
         TM    PPC_FLAG5-PSRAREA(R14),$PPC_F5IVCSECTS Full ignore?
         BNO   PDSRCM$E_TRLIX             None, continue
         LA    R0,#IVC_PDST
         L     R1,PDSRCMD_SUBRSAP         Locate SUBRSA
         L     R15,=V(PDSR$IVC)
         BASR  R14,R15
PDSRCM$E_TRLIX DS 0H
*
         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format the message
         MVC   0(MSGCM13L,R15),MSGCM13-PDSRCMC(R1) Get text
         LA    R15,MSGCM13L(R15)          Locate to overright area
*        UNPK  0(9,R15),PDSRCMD_TRMSIZE(5)
*        MVZ   0(8,R15),PDSRCM_ZEROS
*        TR    0(8,R15),PDSRCM_HEXTABLE
*        MVI   8(R15),C' '
*        LA    R15,9(R15)
*        MVI   0(R15),C'('
*        LA    R15,1(R15)
         L     R1,PDSRCMD_TRMSIZE         Get it
         BAS   R14,PDSRCM_EDITNCF         and print it
         MVC   1(12,R15),=C'bytes, name='
         LA    R15,13(R15)
*-Note: need to support CSECT names longer than 8 bytes!!!!
         MVC   0(8,R15),PDSRCMD_TRMSIZEN  Get name
         LA    R0,8
         BAS   R14,PDSRCM_LOCATE_FIRST_SPACE
         MVC   0(9,R15),=C', member='
         LA    R15,9(R15)
         MVC   0(8,R15),PDSRCMD_TRMSIZEM  Get name
         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT
*
         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format the message
         MVC   0(MSGCM14L,R15),MSGCM14-PDSRCMC(R1) Get text
         LA    R15,MSGCM14L(R15)          Locate to overright area
         MVC   0(4,R15),PDSRCMD_TRODATE   YYYY
         MVI   4(R15),C'.'                    .
         MVC   5(3,R15),PDSRCMD_TRODATE+4      DDD
         LA    R15,4+1+3(R15)
         MVC   0(7,R15),=C', name='
         LA    R15,7(R15)
*-Note: need to support CSECT names longer than 10 bytes!!!
         MVC   0(L'PDSRCMD_TRODATEN,R15),PDSRCMD_TRODATEN  Get name
         LA    R0,L'PDSRCMD_TRODATEN
         BAS   R14,PDSRCM_LOCATE_FIRST_SPACE
         MVC   0(9,R15),=C', member='
         LA    R15,9(R15)
         MVC   0(8,R15),PDSRCMD_TRODATEM  Get name
         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT
PDSRCM$E_TRX DS 0H
*
** Print History stats for the library we just processed
*
         TM    PDSRCMD_FLAG1,$PDSRCMD_F1HIST Doing History report?
         BNO   PDSRCM$E_HIX               Nope, leave
         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format the message
         MVC   0(MSGCM9L,R15),MSGCM9-PDSRCMC(R1)
         LA    R15,MSGCM9L+1(R15)         Bump past it
         L     R1,PDSRCMD_MHCOUNTU        Get count
         BAS   R14,PDSRCM_EDITFWF         Edit it
         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT
*
         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format the message
         MVC   0(MSGCM10L,R15),MSGCM10-PDSRCMC(R1)
         LA    R15,MSGCM10L+1(R15)        Bump past it
         L     R1,PDSRCMD_MHCOUNTZ        Get count
         BAS   R14,PDSRCM_EDITFWF         Edit it
         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT
PDSRCM$E_HIX DS 0H
*
** Common exit from $Library_End processing
*
         NI    PDSRCMD_IFLAG2,255-$PDSRCMD_IF2MEM
PDSRCM$E_X DS 0H
         SLR   R15,R15
         B     PDSRCM$X
         EJECT ,
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Initialization (called only once)
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
PDSRCM$I DS    0H
         MVC   4(4,R13),=C'F1SA'          Set up Register Save Area
         MVC   PDSRCMD_MXSAVE+4(4),=C'F1SA'      Set up RSA
         MVC   PDSRCMD_ID(8),=CL8'PDSRCMD'       ID for dumps
         MVC   PDSRCMD_IFLAG(4),=C'IFLG'         Set for dumps
         MVC   PDSRCMD_WKTOKENI(8),=CL8' WTOKEN='
         MVC   PDSRCMD_DTOKENI(8),=CL8' DTOKEN='
         MVC   PDSRCMD_RETCODEI(4),=CL4' RC='
         MVC   PDSRCMD_RSNCODEI(4),=CL4'RSN='
*
** Set the class names based on the DFSMS level
**
** Note: I've seen DFSMS 1.2 work with all but B_IDRB but let's
**       use the older names for 1.2.
*
         CLC   PDSRCMD_DFARELS(4),=X'01010300' Lower than v1.3?
         BL    PDSRCM$I_CLASSL           Yes, use older names
         MVC   PDSRCMD_B_ESD(7),B_ESD
         MVC   PDSRCMD_B_IDRL(8),B_IDRL
         MVC   PDSRCMD_B_IDRU(8),B_IDRU
         MVC   PDSRCMD_B_IDRZ(8),B_IDRZ
         MVC   PDSRCMD_B_IDRB(8),B_IDRB
         MVC   PDSRCMD_B_TEXT(8),B_TEXT
         B     PDSRCM$I_CLASSX
PDSRCM$I_CLASSL DS 0H
         MVC   PDSRCMD_B_ESD(6),B@ESD
         MVC   PDSRCMD_B_IDRL(7),B@IDRL
         MVC   PDSRCMD_B_IDRU(7),B@IDRU
         MVC   PDSRCMD_B_IDRZ(7),B@IDRZ
         MVC   PDSRCMD_B_IDRB(7),B@IDRB
         MVC   PDSRCMD_B_TEXT(7),B@TEXT
PDSRCM$I_CLASSX DS 0H
*
** Load the IGWASMS program into storage
*
         AIF   ('&IHADFARELS' LT '01010300').IASMSX at DFSMS/MVS 1.3?
         CLC   PDSRCMD_DFARELS(4),=X'01010300' Lower than v1.3?
         BL    PDSRCM$I_ASMSX            Yes, don't bother
         LOAD  EPLOC==CL8'IGWASMS',ERRET=PDSRCM$I_ASMSX
         ST    R0,PDSRCMD_IGWASMS
PDSRCM$I_ASMSX DS 0H
.IASMSX  ANOP  ,
* - - - - - - - - - - - - - - - - - - - - WORKDS fields enabled
         L     R9,PDSRCMD_PSRAREA         Locate to area
         USING PSRAREA,R9                 Enable field access
*
** Eyecatcher
*
         TM    PPC_FLAG3,$PPC_F3ECRPT          ECRPT?
         BNO   PDSRCM$I_ECX                    Yes,...
         OI    PDSRCMD_FLAG1,$PDSRCMD_F1TEXT   Need text processing
         OI    PDSRCMD_IFLAG3,$PDSRCMD_IF3EC   Turn on ECRPT flag
PDSRCM$I_ECX DS 0H
*
** Set options based on DA$PDSRC
*
         TM    PPC_FLAG4,$PPC_F4TSOVIEW   TSO viewing?
         BNO   PDSRCM$I_TVX
         OI    PDSRCMD_IFLAG2,$PDSRCMD_IF2TSOV
PDSRCM$I_TVX DS 0H
*
** Open the FLATOUT file if option is set
**
*
         TM    PPC_FLAG4,$PPC_F4FLATOUT   //FLATOUT processing?
         BNO   PDSRCM$I_FOX               No, leave
*
         TM    PPC_FLAG4,$PPC_F4TRANR     Did user specify TRANRPT?
         BO    PDSRCM$I_FOTX
         OI    PDSRCMD_IFLAG3,$PDSRCMD_IF3STR  Simulate TRANRPT...
         OI    PDSRCMD_FLAG1,$PDSRCMD_F1TRAN   Doing Translator report
PDSRCM$I_FOTX DS 0H
*
         LA    R0,#FLATOUT_Open           Invocation: record
         LA    R1,PDSRCMD_SUBRSA          Locate subroutine RSA
         L     R15,=V(PDSRCMFM)           Locate CSECT
         BASR  R14,R15                    Invoke the flatout routine
PDSRCM$I_FOX   DS 0H
* - - - - - - - - - - - - - - - - - - - - WORKDS fields disabled
         DROP  R9
*
** Temp code: determine whether we use DCB or name method
*
         DEVTYPE =CL8'USEDCB',PDSRCMD_DOUBLE Get file information
         LTR   R15,R15                    Is it allocated?
         BNZ   I$USEDCBX                  No, continue
         OI    PDSRCMD_IFLAG2,$PDSRCMD_IF2UDCB
         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format the message
         MVC   0(MSGCM98L,R15),MSGCM98-PDSRCMC(R1) Get message text
         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT
I$USEDCBX DS   0H
*
** Check for option to do "Message Exit Debugging"
*
         DEVTYPE =CL8'BINDERMD',PDSRCMD_DOUBLE Get DD allocation info
         LTR   R15,R15                    Is FILE=BINDERMD allocated?
         BNZ   PDSRCM$I_MXDBX             No, leave
         OI    PDSRCMD_IFLAG2,$PDSRCMD_IF2MXDB
PDSRCM$I_MXDBX DS 0H
*
** Fix message exit parameters
*
         MVC   PDSRCMD_MESSAGE(4),=V(PDSRCMM) Set msgexit routine addr
         ST    R13,PDSRCMD_MESSAGE+4      Save work area address
         LA    R8,=F'4'                   Default: RC=4 or higher
         DEVTYPE =CL8'BINDERDB',PDSRCMD_DOUBLE Get DD allocation info
         LTR   R15,R15                    Is FILE=BINDERDB allocated?
         BNZ   PDSRCM$I_BDBX              No, leave
         OI    PDSRCMD_IFLAG1,$PDSRCMD_IF1BDB
         LA    R8,=F'0'                   Yes, set to print all msgs
PDSRCM$I_BDBX DS 0H
         ST    R8,PDSRCMD_MESSAGE+8
*
         MVC   PDSRCMD_EXITLIST(CEXITLL),CEXITL
         LA    R1,PDSRCMD_MESSAGE
         ST    R1,PDSRCMD_EXITLIST+(CEXITLA-CEXITL)
*
** Initialize for NAME access
*
         IEWBUFF FUNC=GETBUF,TYPE=NAME
         LR    R14,R8                     To: Address
         L     R15,BNLI_BUFFER_LENG       To: Length
         SLR   R1,R1                      From: Set length and pad
         MVCL  R14,R0                     Zero out table area
*
         IEWBUFF FUNC=INITBUF,TYPE=NAME
         STM   R8,R9,PDSRCMD_SAVEBNL      save regs
         DROP  R8,R9
*
** Initialize for ESD access
*
         IEWBUFF FUNC=GETBUF,TYPE=ESD
         LR    R14,R6                     To: Address
         L     R15,ESDI_BUFFER_LENG       To: Length
         SLR   R1,R1                      From: Set length and pad
         MVCL  R14,R0                     Zero out table area
         IEWBUFF FUNC=INITBUF,TYPE=ESD
         STM   R6,R7,PDSRCMD_SAVEESD      save regs
         DROP  R6,R7
*
** Initialize for IDRB (Binder Indentifcation)
*
         IEWBUFF FUNC=GETBUF,TYPE=IDRB
         LR    R14,R6                     To: Address
         L     R15,IDBI_BUFFER_LENG       To: Length
         SLR   R1,R1                      From: Set length and pad
         MVCL  R14,R0                     Zero out table area
         IEWBUFF FUNC=INITBUF,TYPE=IDRB
         STM   R6,R7,PDSRCMD_SAVEIDB      Save regs
         DROP  R6,R7
*
** Initialize for TEXT processing
*
         TM    PDSRCMD_FLAG1,$PDSRCMD_F1TEXT
         BNO   PDSRCM$I_TXTX
         IEWBUFF FUNC=GETBUF,TYPE=TEXT
         LR    R14,R6                     To: Address
         L     R15,TXTI_BUFFER_LENG       To: Length
         SLR   R1,R1                      From: Set length and pad
         MVCL  R14,R0                     Zero out table area
         IEWBUFF FUNC=INITBUF,TYPE=TEXT
         STM   R6,R7,PDSRCMD_SAVETXT      Save regs
         DROP  R6,R7
PDSRCM$I_TXTX DS 0H
*
** Initialize for IDRL (Translator) report
*
         TM    PDSRCMD_FLAG1,$PDSRCMD_F1TRAN Doing Translator report?
         BNO   PDSRCM$I_TRX               No, continue
         IEWBUFF FUNC=GETBUF,TYPE=IDRL
         LR    R14,R6                     To: Address
         L     R15,IDLI_BUFFER_LENG       To: Length
         SLR   R1,R1                      From: Set length and pad
         MVCL  R14,R0                     Zero out table area
         IEWBUFF FUNC=INITBUF,TYPE=IDRL
         STM   R6,R7,PDSRCMD_SAVEIDL      Save regs
         DROP  R6,R7
*
         TM    PDSRCMD_IFLAG3,$PDSRCMD_IF3STR   Simulate TRANRPT?
         BO    PDSRCM$I_TROX              Yes, skip open
         LA    R3,PDSRCMD_DCBT            Locate DCB
         MVC   0(PDSRCMCDL,R3),PDSRCMCD   Copy in DCB constant
         L     R1,=V(PDSR$C1)
         MVC   DCBDDNAM-IHADCB(8,R3),C_DD_TRANRPT-PDSR$C1(R1)
         MVC   PDSRCMD_PARMLIST(PDSRCMLOL),PDSRCMLO
         OPEN  ((3),(OUTPUT)),            Open the file                @
               MF=(E,PDSRCMD_PARMLIST)
PDSRCM$I_TROX DS 0H
*
         MVI   PDSRCMD_TRPRRLC,99         Start on a new page
         XC    PDSRCMD_TRPRRPC(4),PDSRCMD_TRPRRPC  Set page count
*
#CXREFN  EQU   T_TRANN+1024               Total number to get
#CXREFL  EQU   #CXREFN*CXREFL             Length to grab
         L     R0,=AL4(#CXREFL)           Get length to obtain
         GETMAIN RU,LV=(0)                Get storage
         STM   R0,R1,PDSRCMD_MTRCXREF     Save table length & address
         LR    R14,R1                     To: Address
         LR    R15,R0                     To: Length
         SLR   R1,R1                      From: Set length and pad
         MVCL  R14,R0                     Zero out table area
*
         L     R1,PDSRCMD_MTRCXREF+4      Get table address
         LA    R0,T_TRANN                 Obtain number in table
         L     R14,=V(PDSR$TRT)           Locate CSECT
         LA    R14,T_TRAN-PDSR$TRT(R14)   Locate to table
PDSRCM$I_TRL DS 0H
         MVC   CXREF_TRANT-CXREF(TRANTL,R1),0(R14)
         LA    R14,TRANTL(R14)
         LA    R1,CXREFL(R1)
         BCT   R0,PDSRCM$I_TRL
         MVC   0(2,R1),=X'FF,FF'          Set end of table
PDSRCM$I_TRX DS 0H
*
** Initialize for History report which has IDU and IDZ buffers
*
         TM    PDSRCMD_FLAG1,$PDSRCMD_F1HIST Doing History report?
         BNO   PDSRCM$I_HIX               No, continue
         IEWBUFF FUNC=GETBUF,TYPE=IDRU
         LR    R14,R6                     To: Address
         L     R15,IDUI_BUFFER_LENG       To: Length
         SLR   R1,R1                      From: Set length and pad
         MVCL  R14,R0                     Zero out table area
         IEWBUFF FUNC=INITBUF,TYPE=IDRU
         STM   R6,R7,PDSRCMD_SAVEIDU      Save regs
         DROP  R6,R7
*
         IEWBUFF FUNC=GETBUF,TYPE=IDRZ
         LR    R14,R6                     To: Address
         L     R15,IDZI_BUFFER_LENG       To: Length
         SLR   R1,R1                      From: Set length and pad
         MVCL  R14,R0                     Zero out table area
         IEWBUFF FUNC=INITBUF,TYPE=IDRZ
         STM   R6,R7,PDSRCMD_SAVEIDZ      Save regs
         DROP  R6,R7
*
         LA    R3,PDSRCMD_DCBH            Locate DCB
         MVC   0(PDSRCMCDL,R3),PDSRCMCD   Copy in DCB constant
         L     R1,=V(PDSR$C1)
         MVC   DCBDDNAM-IHADCB(8,R3),C_DD_HISTRPT-PDSR$C1(R1)
         MVC   PDSRCMD_PARMLIST(PDSRCMLOL),PDSRCMLO
         OPEN  ((3),(OUTPUT)),            Open the file                @
               MF=(E,PDSRCMD_PARMLIST)
*
         MVI   PDSRCMD_HIPRRLC,99         Start on a new page
         XC    PDSRCMD_HIPRRPC(4),PDSRCMD_HIPRRPC  Set page count
PDSRCM$I_HIX DS 0H
*
** Dump Binder entries?
**
** Also (temp) show all translator records
*
         DEVTYPE =CL8'BINDERDE',PDSRCMD_DOUBLE Check allocation
         LTR   R15,R15                    Is file allocated?
         BNZ   PDSRCM$I_DEX               No...
         OI    PDSRCMD_IFLAG1,$PDSRCMD_IF1DMPA Set option to dump areas
PDSRCM$I_DEX DS 0H
*
** Start the dialog
*
         MVC   PDSRCMD_FUNC(8),=CL8'STARTD'
         MVC   PDSRCMD_DTOKEN(8),PDSRCM_ZEROS Clear dialog token
         TM    PDSRCMD_IFLAG1,$PDSRCMD_IF1BDB Binder Debug Mode?
         BO    PDSRCM$I_BDBS              Yes, need file list
         DEVTYPE =CL8'BINDERNM',PDSRCMD_DOUBLE Get DD allocation info
         LTR   R15,R15                    Is FILE=BINDERNM allocated?
         BZ    PDSRCM$I_BDBPNM
         DEVTYPE =CL8'BINDERPR',PDSRCMD_DOUBLE Get DD allocation info
         LTR   R15,R15                    Is FILE=BINDERPR allocated?
         BZ    PDSRCM$I_BDBP
         IEWBIND FUNC=STARTD,                                          C
               RETCODE=PDSRCMD_RETCODE,                                C
               RSNCODE=PDSRCMD_RSNCODE,                                C
               DIALOG=PDSRCMD_DTOKEN,                                  C
               EXITS=PDSRCMD_EXITLIST,                                 C
               OPTIONS=OPTLIST1,         <- Has term and print off     C
               MF=(E,PDSRCMD_PARMLIST)
         B     PDSRCM$I_BDBSX
*-No messages
PDSRCM$I_BDBPNM DS 0H
         IEWBIND FUNC=STARTD,                                          C
               RETCODE=PDSRCMD_RETCODE,                                C
               RSNCODE=PDSRCMD_RSNCODE,                                C
               DIALOG=PDSRCMD_DTOKEN,                                  C
               FILES=FILELIST,           <- Has file list for print    C
               OPTIONS=OPTLIST3,         <- Has term off and print on  C
               MF=(E,PDSRCMD_PARMLIST)
         B     PDSRCM$I_BDBSX
*-Temp solution/workaround to use until UW32119 is on DFSMS/MVS 1.3
PDSRCM$I_BDBP  DS 0H
         IEWBIND FUNC=STARTD,                                          C
               RETCODE=PDSRCMD_RETCODE,                                C
               RSNCODE=PDSRCMD_RSNCODE,                                C
               DIALOG=PDSRCMD_DTOKEN,                                  C
               EXITS=PDSRCMD_EXITLIST,                                 C
               FILES=FILELIST,           <- Has file list for print    C
               OPTIONS=OPTLIST3,         <- Has term off and print on  C
               MF=(E,PDSRCMD_PARMLIST)
         B     PDSRCM$I_BDBSX
PDSRCM$I_BDBS  DS 0H
         IEWBIND FUNC=STARTD,                                          C
               RETCODE=PDSRCMD_RETCODE,                                C
               RSNCODE=PDSRCMD_RSNCODE,                                C
               DIALOG=PDSRCMD_DTOKEN,                                  C
               EXITS=PDSRCMD_EXITLIST,                                 C
               FILES=FILELIST,           <- Has file list              C
               OPTIONS=OPTLIST2,         <- Has term and print on      C
               MF=(E,PDSRCMD_PARMLIST)
PDSRCM$I_BDBSX DS 0H
         CLC   PDSRCMD_RSNCODE(4),C_IEWB_RC_OK Check reason code
         BE    PDSRCM$IX                  Okay fine
         OI    PDSRCMD_IFLAG1,$PDSRCMD_IF1INIT We initialized...
         LA    R15,254                    Error with STARTD
         B     PDSRCM$X
*
** End of $Intialization processing
*
PDSRCM$IX DS 0H
         OI    PDSRCMD_IFLAG1,$PDSRCMD_IF1INIT We initialized...
         OI    PDSRCMD_IFLAG2,$PDSRCMD_IF2SD   We did STARTD
         SLR   R15,R15
         B     PDSRCM$X
         EJECT ,
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Termination - Free resources
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
PDSRCM$T DS    0H
         TM    PDSRCMD_IFLAG1,$PDSRCMD_IF1INIT Did we initialize?
         BNO   PDSRCM$TX
*
** End the dialog
*
         TM    PDSRCMD_IFLAG2,$PDSRCMD_IF2SD   Did we do a STARTD?
         BNO   PDSRCM$T_EDX                    No, skip this
         MVC   PDSRCMD_FUNC(8),=CL8'ENDD'
         IEWBIND FUNC=ENDD,                                            C
               RETCODE=PDSRCMD_RETCODE,                                C
               RSNCODE=PDSRCMD_RSNCODE,                                C
               DIALOG=PDSRCMD_DTOKEN,                                  C
               MF=(E,PDSRCMD_PARMLIST)
PDSRCM$T_EDX DS 0H
*
** Delete IGWASMS program
*
         AIF   ('&IHADFARELS' LT '01010300').TASMSX at DFSMS/MVS 1.3?
         ICM   R0,B'1111',PDSRCMD_IGWASMS
         BZ    PDSRCM$T_ASMSX
         DELETE EPLOC==CL8'IGWASMS'
         XC    PDSRCMD_IGWASMS(4),PDSRCMD_IGWASMS
PDSRCM$T_ASMSX DS 0H
.TASMSX  ANOP  ,
*
** Free global Buffers
*
         LM    R6,R7,PDSRCMD_SAVEESD      Get saved registers
         USING IEWBESD,R6
         USING ESD_ENTRY,R7
         IEWBUFF FUNC=FREEBUF,TYPE=ESD
         DROP  R6,R7
*
         LM    R8,R9,PDSRCMD_SAVEBNL      Get saved registers
         USING IEWBBNL,R8
         USING BNL_ENTRY,R9
         IEWBUFF FUNC=FREEBUF,TYPE=NAME
         DROP  R8,R9
*
         LM    R6,R7,PDSRCMD_SAVEIDB      Get saved registers
         USING IEWBIDB,R6
         USING IDB_ENTRY,R7
         IEWBUFF FUNC=FREEBUF,TYPE=IDRB
         DROP  R6,R7
*
** Free Buffers and resources for Text processing
*
         TM    PDSRCMD_FLAG1,$PDSRCMD_F1TEXT
         BNO   PDSRCM$T_TXTX              No, continue
         LM    R6,R7,PDSRCMD_SAVETXT      Get saved registers
         USING IEWBTXT,R6
         USING IDL_ENTRY,R7
         IEWBUFF FUNC=FREEBUF,TYPE=TEXT
         DROP  R6,R7
PDSRCM$T_TXTX DS 0H
*
** Free Buffers and resources for Translator report
*
         TM    PDSRCMD_FLAG1,$PDSRCMD_F1TRAN Doing Translator report?
         BNO   PDSRCM$T_TRX               No, continue
         LM    R6,R7,PDSRCMD_SAVEIDL      Get saved registers
         USING IEWBIDL,R6
         USING IDL_ENTRY,R7
         IEWBUFF FUNC=FREEBUF,TYPE=IDRL
         DROP  R6,R7
*
         LA    R3,PDSRCMD_DCBT
         MVC   PDSRCMD_PARMLIST(PDSRCMCLL),PDSRCMCL
         CLOSE ((3)),MF=(E,PDSRCMD_PARMLIST)
*
         ICM   R1,B'1111',PDSRCMD_LIBC    Get library count
         BZ    PDSRCM$T_TRUX              None, continue
         C     R1,=F'1'                   Processed only one library?
         BE    PDSRCM$T_TRUX              Skip redundant information
         LM    R2,R3,PDSRCMD_MTRCXREF     Get table length & address
         NI    PDSRCMD_IFLAG1,255-$PDSRCMD_IF1THR
         SLR   R4,R4                      Clear total Translators
         SLR   R5,R5                      Clear total unknown ones
PDSRCM$T_TRL DS 0H
         CLC   CXREF_COUNTT-CXREF(4,R3),PDSRCM_ZEROS Found any?
         BE    PDSRCM$T_TRLB              No, skip print
         TM    PDSRCMD_IFLAG1,$PDSRCMD_IF1THR Print heading?
         BO    PDSRCM$T_TRLHX
         OI    PDSRCMD_IFLAG1,$PDSRCMD_IF1THR We printed the heading
         BAS   R14,PDSRCM_CLEAR_RECOUT    Clear recout to blanks
         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT
         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format the message
         MVC   0(MSGCM5L,R15),MSGCM5-PDSRCMC(R1) Get text
         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT
PDSRCM$T_TRLHX DS 0H
         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format the message
         MVC   0(MSGCM6L,R15),MSGCM6      Move in message text
         MVC   MSGCM6I-MSGCM6(L'TRANT_ID,R15),TRANT_ID-TRANT(R3)
         MVC   MSGCM6N-MSGCM6(L'TRANT_NAME,R15),TRANT_NAME-TRANT(R3)
         CLI   CXREF_TYPE-CXREF(R3),$CXREFT_S  Static?
         BE    PDSRCM$T_TRLUX             Just boring Static entry
         LA    R5,1(R5)                   Increment dynamic count
         MVI   MSGCM6U-MSGCM6(R15),C'*'   Mark as dynamic (unknown)
PDSRCM$T_TRLUX DS 0H
         LA    R15,MSGCM6L(R15)           Bump past message
         ICM   R1,B'1111',CXREF_COUNTT-CXREF(R3) Get count
         AR    R4,R1
         CVD   R1,PDSRCMD_DOUBLE
         MVC   0(12,R15),=X'40,20,20,20,6B,20,20,20,6B,20,20,20'
         ED    0(12,R15),PDSRCMD_DOUBLE+3
         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT
PDSRCM$T_TRLB DS 0H
         LA    R3,CXREFL(R3)              Bump to next one
         SH    R2,=AL2(CXREFL)            Decrement table length
         LTR   R2,R2
         BZ    PDSRCM$T_TRLX
         BM    PDSRCM$T_TRLX
         CLC   0(2,R3),=X'FF,FF'          End of the table?
         BNE   PDSRCM$T_TRL
PDSRCM$T_TRLX DS 0H
         LTR   R4,R4
         BZ    PDSRCM$T_TRTX
         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format the message
         MVC   0(L'MSGCM6,R15),MSGCM6     Move in message text
         LA    R14,MSGCM6S+2-MSGCM6(R15)  Locate to overright area
         MVI   0(R14),C'-'                Get dash
         MVC   1(MSGCM6SL-2+12+6-1,R14),0(R14) Propagate dashes
         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT
*
         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format the message
         MVC   0(L'MSGCM6,R15),MSGCM6      Move in message text
         MVC   MSGCM6S+2-MSGCM6(L'MSGCM6A,R15),MSGCM6A
         LA    R15,MSGCM6L(R15)           Bump past message
         LR    R1,R4                      Update total
         CVD   R1,PDSRCMD_DOUBLE
         MVC   0(12,R15),=X'40,20,20,20,6B,20,20,20,6B,20,20,20'
         ED    0(12,R15),PDSRCMD_DOUBLE+3
         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT
         BAS   R14,PDSRCM_CLEAR_RECOUT    Clear output record
         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT
PDSRCM$T_TRTX DS 0H
*
         LTR   R5,R5                      Did we find any unknown ones?
         BZ    PDSRCM$T_TRUX              Nope!
         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format the message
         MVC   0(MSGCM11L,R15),MSGCM11-PDSRCMC(R1) Get message
         LA    R15,MSGCM11L+1(R15)        Locate past message text
         LR    R1,R5                      Get total new program ids
         BAS   R14,PDSRCM_EDITFWF         Edit it
         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT
PDSRCM$T_TRUX DS 0H
*
         LM    R0,R1,PDSRCMD_MTRCXREF     Get table length & address
         FREEMAIN RU,LV=(0),A=(1)         Free storage
PDSRCM$T_TRX DS 0H
*
** Free Buffers and resources for History report
*
         TM    PDSRCMD_FLAG1,$PDSRCMD_F1HIST Doing History report?
         BNO   PDSRCM$T_HIX               No, continue
         LM    R6,R7,PDSRCMD_SAVEIDU      Get saved registers
         USING IEWBIDU,R6
         USING IDU_ENTRY,R7
         IEWBUFF FUNC=FREEBUF,TYPE=IDRU
         DROP  R6,R7
*
         LM    R6,R7,PDSRCMD_SAVEIDZ      Get saved registers
         USING IEWBIDZ,R6
         USING IDU_ENTRY,R7
         IEWBUFF FUNC=FREEBUF,TYPE=IDRZ
         DROP  R6,R7
*
         LA    R3,PDSRCMD_DCBH
         MVC   PDSRCMD_PARMLIST(PDSRCMCLL),PDSRCMCL
         CLOSE ((3)),MF=(E,PDSRCMD_PARMLIST)
PDSRCM$T_HIX DS 0H
*
** Close file if we did //FLATOUT processing
*
         TM    PDSRCMD_IFLAG2,$PDSRCMD_IF2FO    FLATOUT?
         BNO   PDSRCM$T_FOX               No, leave
         LA    R3,PDSRCMD_DCBF
         MVC   PDSRCMD_PARMLIST(PDSRCMCLL),PDSRCMCL
         CLOSE ((3)),MF=(E,PDSRCMD_PARMLIST)
*
         LM    R0,R1,PDSRCMD_FOA          Get area length & address
         FREEMAIN RU,LV=(0),A=(1)         Free storage
PDSRCM$T_FOX DS 0H
*
** End of $Termination processing
*
PDSRCM$TX DS 0H
         SLR   R15,R15
         B     PDSRCM$X
*
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**       Create a hex dump of an entry
**
**       Input: R0 has entry length
**              R1 has ID string of entry type
**              R15 points to the entry to be dumped
**
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
PDSRCM_DUMPE DS 0H
         TM    PDSRCMD_IFLAG1,$PDSRCMD_IF1DMPA Dumping Areas?
         BNO   PDSRCM_DEQO                Nope, leave
         ST    R14,PDSRCMD_DERA           Save return address
         STM   R8,R9,PDSRCMD_DESREG       Save register
         L     R9,PDSRCMD_PSRAREA         Locate to area
         USING PSRAREA,R9                 Enable field access
         STM   R15,R1,PDSRCMD_DESREGA     Save regs
*
** Print message that has the name of the area we are dumping
*
         LA    R15,PDSRCMD_DEREC          Locate output record
         BAS   R14,PDSRCM_FMS             Format message
         MVC   0(MSGCM3L,R15),MSGCM3      Get text
         LA    R15,MSGCM3L(R15)           Bump past text
         L     R1,PDSRCMD_DESREGI         Get ID string address
         SLR   R14,R14                    Clear reg for IC
         IC    R14,0(R1)                  Get length of string
         EX    R14,PDSRCM_DEMID           Move string out
         LA    R15,1(R14,R15)
         MVC   0(12,R15),=C'" - address='
         LA    R15,12(R15)
         UNPK  0(9,R15),PDSRCMD_DESREGA(5)
         MVZ   0(8,R15),PDSRCM_ZEROS
         TR    0(8,R15),PDSRCM_HEXTABLE
         MVC   8(8,R15),=C' length='
         LA    R15,8+8(R15)
         L     R1,PDSRCMD_DESREGL
         BAS   R14,PDSRCM_EDITFWF         Edit it
         MVI   1(R15),C'('
         LA    R15,2(R15)
         UNPK  0(5,R15),PDSRCMD_DESREGL+2(3)
         MVZ   0(4,R15),PDSRCM_ZEROS
         TR    0(4,R15),PDSRCM_HEXTABLE
         MVI   4(R15),C')'
*
         L     R0,PDSRCMD_PSRAREA         Locate work area
         LA    R1,PDSRCMD_DEREC           Locate record to print
         L     R15,=V(PDSR$PSR)           Locate sysprint routine
         BASR  R14,R15                    Print Sysprint Record
*
         MVI   PDSRCMD_DEREC,C' '
         MVC   PDSRCMD_DEREC+1(L'PDSRCMD_DEREC-1),PDSRCMD_DEREC
*
** Perform a hex dump on the area
*
         XC    W_AREA(CMXDL),W_AREA       Initialize area
         LM    R15,R1,PDSRCMD_DESREGA     Restore regs
*-R15 has area address                    Locate directory entry
*-R0 has length                           Get length of directory ent.
         LA    R1,PDSRCMD_DEREC+14        Get output location
         STM   R15,R1,W_AREA+CMXD_ADDRESS-CMXD  Data, Length, Output
         TM    PDSRCMD_IFLAG2,$PDSRCMD_IF2TSOV
         BO    PDSRCM_DE$DIREL
         MVC   W_AREA+CMXD_OUTPUTL-CMXD(2),=AL2(132) <- TSO viewing
PDSRCM_DE$DIREL EQU *
         LA    R1,W_AREA                  Locate work area
         L     R15,EP_DA$MXD              -> DA$MXD E.P.A.
         BASSM R14,R15                    Call DA$MXD
         LR    R8,R15                     Save return code
*
         L     R0,PDSRCMD_PSRAREA         Locate work area
         LA    R1,PDSRCMD_DEREC           Locate record to print
         L     R15,=V(PDSR$PSR)           Locate sysprint routine
         BASR  R14,R15                    Print Sysprint Record
*
         LTR   R8,R8                      Any more lines to do...
         BNZ   PDSRCM_DE$DIREL            Thank you: May I have another
*
         MVI   PDSRCMD_DEREC,C' '
         MVC   PDSRCMD_DEREC+1(L'PDSRCMD_DEREC-1),PDSRCMD_DEREC
         L     R0,PDSRCMD_PSRAREA         Locate work area
         LA    R1,PDSRCMD_DEREC           Locate record to print
         L     R15,=V(PDSR$PSR)           Locate sysprint routine
         BASR  R14,R15                    Print Sysprint Record
*
** Return to caller
*
         L     R14,PDSRCMD_DERA           Get return address
         LM    R8,R9,PDSRCMD_DESREG       Get registers back
PDSRCM_DEQO DS 0H
         BSM   0,R14                      Return to caller
         DROP  R9                         Drop psrarea addressability
PDSRCM_DEMID MVC 0(0,R15),1(R1)           ** Executed **
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**       Misc subroutines
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
*
** Print PDSRCMD_RECOUT to the sysprint file
*
PDSRCM_PRINT_RECOUT DS 0H
         ST    R14,PDSRCMD_DOUBLE         Save return address
         L     R0,PDSRCMD_PSRAREA         Locate work area
         LA    R1,PDSRCMD_RECOUT          Locate record to print
         L     R15,=V(PDSR$PSR)           Locate sysprint routine
         BASR  R14,R15                    Print Sysprint Record
         L     R14,PDSRCMD_DOUBLE         Get return address
         BSM   0,R14
*
** Format for message
*
PDSRCM_FORMAT_MESSAGE DS 0H
         LA    R15,PDSRCMD_RECOUT
PDSRCM_FMS DS 0H
         MVI   0(R15),C' '
         MVC   1(132,R15),0(R15)
         MVC   1(7,R15),=CL7'DA$PDSR'
         MVI   1+7(R15),C'-'
         LA    R15,1+7+1(R15)
         L     R1,=V(PDSRCMC)
         BSM   0,R14
*
** Clear recout to blanks
*
PDSRCM_CLEAR_RECOUT DS 0H
         LA    R15,PDSRCMD_RECOUT
         MVI   0(R15),C' '
         MVC   1(132,R15),0(R15)
         BSM   0,R14
*
** Edit full word in Register 1 flush at location in Register 15
** with no commas
**
** INPUT: R1 - Register to print
**        R15 - Address to put number
*
PDSRCM_EDITNCF EQU *
         LTR   R1,R1                      CHECK FOR 0
         BZ    PDSRCM_EDITNCF0            YES, PUT ZERO
         ST    R14,PDSRCMD_EDITRA         Save return address
         CVD   R1,PDSRCMD_DOUBLE          NO, CONVERT TO PACKEC
**
 LA    R1,PDSRCMD_DOUBLE2+7               LOCATE SIG DIGIT
 MVC   PDSRCMD_DOUBLE2(8),PDSRCM_EDITNCFP
 EDMK  PDSRCMD_DOUBLE2(8),PDSRCMD_DOUBLE+4 EDIT AND SAVE PLACE
 LA    R14,PDSRCMD_DOUBLE2+9              LOCATE LAST POSSIBLE BYTE + 1
**
*        LA    R1,PDSRCMD_DOUBLE2+14      LOCATE SIG DIGIT
*        MVC   PDSRCMD_DOUBLE2(15),PDSRCM_EDITNCFP
*        EDMK  PDSRCMD_DOUBLE2(15),PDSRCMD_DOUBLE+2 EDIT AND SAVE PLACE
*        LA    R14,PDSRCMD_DOUBLE2+16     LOCATE LAST POSSIBLE BYTE + 1
         SR    R14,R1                     LENGTH = END - START
         BCTR  R14,0                      DECREMENT FOR EX
         EX    R14,PDSRCM_EDITNCFM        MOVE EDIT NUMBER TO OUTPUT
         LA    R15,0(R14,R15)             BUMP POINTER PAST NUMBER
         MVI   0(R15),C' '
         L     R14,PDSRCMD_EDITRA         Get return address
         BSM   0,R14                      RETURN TO CALLER
PDSRCM_EDITNCFM MVC 0(0,R15),0(R1)
PDSRCM_EDITNCFP DC X'40,20,20,20,20,20,20,20,20,20,20,20,20,20,20'
PDSRCM_EDITNCF0 DS 0H
         MVI   0(R15),C'0'                PUT IN ZERO
         LA    R15,1(R15)                 BUMP POINTER PAST ZERO
         BSM   0,R14                      RETURN TO CALLER
*
** Edit full word in Register 1 flush at location in Register 15
** INPUT: R1 - Register to print
**        R15 - Address to put number
*
PDSRCM_EDITFWF DS 0H
         LTR   R1,R1                      Check for 0
         BZ    PDSRCM_EDITFWF0            Yes, put zero
         ST    R14,PDSRCMD_EDITRA         Save return address
         CVD   R1,PDSRCMD_DOUBLE          No, convert to packec
         LA    R1,PDSRCMD_DOUBLE2+14      Locate sig digit
         MVC   PDSRCMD_DOUBLE2(15),PDSRCM_EDITP15
         EDMK  PDSRCMD_DOUBLE2(15),PDSRCMD_DOUBLE+2 EDIT AND SAVE PLACE
         LA    R14,PDSRCMD_DOUBLE2+16     Locate last possible byte + 1
         SR    R14,R1                     Length = end - start
         BCTR  R14,0                      Decrement for ex
         EX    R14,PDSRCM_EDITFWFM        Move edit number to output
         LA    R15,0(R14,R15)             Bump pointer past number
         MVI   0(R15),C' '
         L     R14,PDSRCMD_EDITRA
         BSM   0,R14                      Return to caller
PDSRCM_EDITFWFM MVC 0(0,R15),0(R1)
PDSRCM_EDITP15  DC  X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'
PDSRCM_EDITFWF0 DS  0H
         MVI   0(R15),C'0'                Put in zero
         LA    R15,1(R15)                 Bump pointer past zero
         BSM   0,R14                      Return to caller
*
** Point Register 15 to the first blank in a string
** Input:  R0  - Maximum length of the string
**         R15 - String
** Output: R15 - First space in the string
*
PDSRCM_LOCATE_FIRST_SPACE EQU *
         CLI   0(R15),C' '                Blank?
         BE    PDSRCM_LFS$X               Yes, leave
         LA    R15,1(R15)                 No, bump to next byte
         BCT   R0,PDSRCM_LOCATE_FIRST_SPACE ..Repeat
PDSRCM_LFS$X DS 0H
         BSM   0,R14                      Return to caller
*
** Ensure that member (or any 8 byte area) has only valid characters
**
** Input: R15 - 8 byte member name with 18 bytes for hex conversion
**
** Note: We save R2 because TRT *DESTROYS* R2
*
PDSRCM_EPM DS 0H
         ST    R14,PDSRCMD_DOUBLE         Save return address
         ST    R2,PDSRCMD_DOUBLE+4        Save this register (TRT)
         L     R1,=V(PDSR$C2)             -> Constants CSECT
         TRT   0(8,R15),C_TABPRT-PDSR$C2(R1) Valid characters only?
         BZ    PDSRCM$EPM$X               Yes, leave
         MVI   8(R15),C'/'                Insert delimiter
         UNPK  9(9,R15),0(5,R15)          >>
         MVZ   9(8,R15),PDSRCM_ZEROS      >>> Convert first 4 bytes
         TR    9(8,R15),PDSRCM_HEXTABLE   >>
         UNPK  9+8(9,R15),4(5,R15)        <<
         MVZ   9+8(8,R15),PDSRCM_ZEROS    <<< Convert last 4 bytes
         TR    9+8(8,R15),PDSRCM_HEXTABLE <<
         MVI   9+8+8(R15),C' '            Fix last byte
         L     R1,=V(PDSR$C2)             -> Constants CSECT
         TR    0(8,R15),C_TRTABM-PDSR$C2(R1) Translate to valid...
PDSRCM$EPM$X EQU *
         L     R2,PDSRCMD_DOUBLE+4        Restore this register
         L     R14,PDSRCMD_DOUBLE         Get return address
         BSM   0,R14                      Return to caller
#PDSRCM_EPML    EQU   8+1+16              Max length
         EJECT ,
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**       Print Report Record for Translator report
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
PDSRCM_TRPRR DS 0H
         TM    PDSRCMD_IFLAG3,$PDSRCMD_IF3STR   Simulate TRANRPT?
         BO    PDSRCM_TRPRR_QO            Yes, quick out
         ST    R14,PDSRCMD_PRRRA          Save return address
*
         SLR   R1,R1                      Clear register for IC
         IC    R1,PDSRCMD_TRPRRLC         Get current line count
         LA    R1,1(R1)                   Increment by 1
         STC   R1,PDSRCMD_TRPRRLC         Save new line count
         CLI   PDSRCMD_TRPRRLC,47         Over max for page?
         BL    PDSRCM_TRPRR$PL            No, continue
         MVI   PDSRCMD_TRPRRLC,1          Yes, start over on new page
*
         LA    R15,PDSRCMD_PRRHL
         MVI   0(R15),C' '
         MVC   1(132,R15),0(R15)
         MVC   0(27,R15),=C'1Translator report for DSN='
         LA    R15,27(R15)
         L     R1,PDSRCMD_DSNAME
         MVC   0(44,R15),0(R1)
         LA    R0,44
         BAS   R14,PDSRCM_LOCATE_FIRST_SPACE
         MVC   1(9,R15),=C'- Volser='
         LA    R15,1+9(R15)
         L     R1,PDSRCMD_VOLSER
         MVC   0(6,R15),0(R1)
         LA    R0,6
         BAS   R14,PDSRCM_LOCATE_FIRST_SPACE
         MVC   1(7,R15),=C'- Page:'
         LA    R15,1+7+1(R15)
         L     R1,PDSRCMD_TRPRRPC
         LA    R1,1(R1)
         ST    R1,PDSRCMD_TRPRRPC
         BAS   R14,PDSRCM_EDITFWF
*
         MVI   1(R15),C'-'                Insert delimiter
         LA    R15,3(R15)                 Bump past it
         ICM   R1,B'1111',PDSRCMD_DATE    Locate Date DA$DATE area
         SLR   R14,R14                         Clear reg for IC
         IC    R14,DA#DATED_STRL-DA#DATED(R1)  Get length of date
         BCTR  R14,0                           Decrement for EX
         EX    R14,PDSRCM_TRPRRMDS        Move date to heading line
         LA    R15,2(R14,R15)             Bump past date
         ICM   R1,B'1111',PDSRCMD_TIME    Locate time DA#DATE area
         SLR   R14,R14                         Clear reg for IC
         IC    R14,DA#DATED_STRL-DA#DATED(R1)  Get length of time
         BCTR  R14,0                      Decrement for EX
         EX    R14,PDSRCM_TRPRRMDS        Move time out
         PUT   PDSRCMD_DCBT,PDSRCMD_PRRHL
*-Print blank line
         LA    R15,PDSRCMD_PRRHL
         MVI   0(R15),C' '
         MVC   1(132,R15),0(R15)
         PUT   PDSRCMD_DCBT,PDSRCMD_PRRHL
*-Print first heading line
         LA    R15,PDSRCMD_PRRHL
         MVI   0(R15),C' '
         MVC   1(132,R15),0(R15)
         MVC   OCL_TRAN-OCL(L'PDSRCM_TID,R15),PDSRCM_TID
         PUT   PDSRCMD_DCBT,PDSRCMD_PRRHL
*-Print second heading line
         LA    R15,PDSRCMD_PRRHL
         MVI   0(R15),C' '
         MVC   1(132,R15),0(R15)
         L     R14,=V(PDSRCMC)
         MVC   OCL_MEMBER-OCL(6,R15),CMC_MEMBER-PDSRCMC(R14)
         MVC   OCL_CSECT-OCL(10,R15),CMC_CSECT-PDSRCMC(R14)
         MVC   OCL_OFFSET-OCL(6,R15),CMC_OFFSET-PDSRCMC(R14)
         MVC   OCL_LENGTH-OCL(6,R15),CMC_LENGTH-PDSRCMC(R14)
         MVC   OCL_TRANDATE-OCL(4,R15),CMC_TRANDATE-PDSRCMC(R14)
         MVC   OCL_TRANID-OCL(2,R15),CMC_TRANID-PDSRCMC(R14)
         MVC   OCL_TRANVER-OCL(5,R15),CMC_TRANVER-PDSRCMC(R14)
         MVC   OCL_TRANNAME-OCL(4,R15),CMC_TRANNAME-PDSRCMC(R14)
         MVC   OCL_AMODE-OCL(15,R15),CMC_AMODE-PDSRCMC(R14)
         MVC   OCL_ALIGN-OCL(9,R15),CMC_ALIGN-PDSRCMC(R14)
         PUT   PDSRCMD_DCBT,PDSRCMD_PRRHL
*-Print third heading line
         LA    R15,PDSRCMD_PRRHL
         MVI   0(R15),C' '
         MVC   1(132,R15),0(R15)
         L     R14,=V(PDSRCMC)
         MVC   OCL_MEMBER-OCL(L'OCL_MEMBER,R15),CMC_DASH-PDSRCMC(R14)
         MVC   OCL_CSECT-OCL(L'OCL_CSECT,R15),CMC_DASH-PDSRCMC(R14)
         MVC   OCL_OFFSET-OCL(L'OCL_OFFSET,R15),CMC_DASH-PDSRCMC(R14)
         MVC   OCL_LENGTH-OCL(L'OCL_LENGTH,R15),CMC_DASH-PDSRCMC(R14)
         MVC   OCL_TRANDATE-OCL(4+1+3,R15),CMC_DASH-PDSRCMC(R14)
         MVC   OCL_TRANID-OCL(L'OCL_TRANID,R15),CMC_DASH-PDSRCMC(R14)
         MVC   OCL_TRANVER-OCL(5,R15),CMC_DASH-PDSRCMC(R14)
       MVC OCL_TRANNAME-OCL(L'OCL_TRANNAME,R15),CMC_DASH-PDSRCMC(R14)
         MVC   OCL_AMODE-OCL(OCL_AML,R15),CMC_DASH-PDSRCMC(R14)
         MVC   OCL_ALIGN-OCL(9,R15),CMC_DASH-PDSRCMC(R14)
         PUT   PDSRCMD_DCBT,PDSRCMD_PRRHL
PDSRCM_TRPRR$PL DS 0H
         PUT   PDSRCMD_DCBT,PDSRCMD_RECOUT
*
         L     R14,PDSRCMD_PRRRA
PDSRCM_TRPRR_QO DS 0H
         BSM   0,R14
*
PDSRCM_TRPRRMDS MVC 0(0,R15),DA#DATED_STR-DA#DATED(R1)
         EJECT ,
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**       Print Report Record for History report
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
PDSRCM_HIPRR DS 0H
         ST    R14,PDSRCMD_PRRRA          Save return address
*
         SLR   R1,R1                      Clear register for IC
         IC    R1,PDSRCMD_HIPRRLC         Get current line count
         LA    R1,1(R1)                   Increment by 1
         STC   R1,PDSRCMD_HIPRRLC         Save new line count
         CLI   PDSRCMD_HIPRRLC,47         Over max for page?
         BL    PDSRCM_HIPRR$PL            No, continue
         MVI   PDSRCMD_HIPRRLC,1          Yes, start over on new page
*
         LA    R15,PDSRCMD_PRRHL
         MVI   0(R15),C' '
         MVC   1(132,R15),0(R15)
         MVC   0(24,R15),=C'1History report for DSN='
         LA    R15,24(R15)
         L     R1,PDSRCMD_DSNAME
         MVC   0(44,R15),0(R1)
         LA    R0,44
         BAS   R14,PDSRCM_LOCATE_FIRST_SPACE
         MVC   1(9,R15),=C'- Volser='
         LA    R15,1+9(R15)
         L     R1,PDSRCMD_VOLSER
         MVC   0(6,R15),0(R1)
         LA    R0,6
         BAS   R14,PDSRCM_LOCATE_FIRST_SPACE
         MVC   1(7,R15),=C'- Page:'
         LA    R15,1+7+1(R15)
         L     R1,PDSRCMD_HIPRRPC
         LA    R1,1(R1)
         ST    R1,PDSRCMD_HIPRRPC
         BAS   R14,PDSRCM_EDITFWF
*
         MVI   1(R15),C'-'                Insert delimiter
         LA    R15,3(R15)                 Bump past it
         ICM   R1,B'1111',PDSRCMD_DATE    Locate Date DA$DATE area
         SLR   R14,R14                         Clear reg for IC
         IC    R14,DA#DATED_STRL-DA#DATED(R1)  Get length of date
         BCTR  R14,0                           Decrement for EX
         EX    R14,PDSRCM_HIPRRMDS        Move date to heading line
         LA    R15,2(R14,R15)             Bump past date
         ICM   R1,B'1111',PDSRCMD_TIME    Locate time DA#DATE area
         SLR   R14,R14                         Clear reg for IC
         IC    R14,DA#DATED_STRL-DA#DATED(R1)  Get length of time
         BCTR  R14,0                      Decrement for EX
         EX    R14,PDSRCM_HIPRRMDS        Move time out
*
         PUT   PDSRCMD_DCBH,PDSRCMD_PRRHL
*-Print blank line
         LA    R15,PDSRCMD_PRRHL
         MVI   0(R15),C' '
         MVC   1(132,R15),0(R15)
         PUT   PDSRCMD_DCBH,PDSRCMD_PRRHL
*-Print heading line 1
         LA    R15,PDSRCMD_PRRHL
         MVI   0(R15),C' '
         MVC   1(132,R15),0(R15)
         MVC   OCL_MEMBER-OCL(6,R15),=C'Member'
         MVC   OCL_CSECT-OCL(10,R15),=C'CSECT Name'
         MVC   OCL_OFFSET-OCL(6,R15),=C'Offset'
         MVC   OCL_LENGTH-OCL(6,R15),=C'length'
         MVC   OCL_HISTDATE-OCL(4,R15),=C'Date'
         MVC   OCL_HISTDATA-OCL(4,R15),=C'Data'
         PUT   PDSRCMD_DCBH,PDSRCMD_PRRHL
*-Print heading line 2
         LA    R15,PDSRCMD_PRRHL
         MVI   0(R15),C' '
         MVC   1(132,R15),0(R15)
         MVC   OCL_MEMBER-OCL(L'OCL_MEMBER,R15),=32C'-'
         MVC   OCL_CSECT-OCL(L'OCL_CSECT,R15),=32C'-'
         MVC   OCL_OFFSET-OCL(L'OCL_OFFSET,R15),=32C'-'
         MVC   OCL_LENGTH-OCL(L'OCL_LENGTH,R15),=32C'-'
         MVC   OCL_HISTDATE-OCL(4+1+3,R15),=32C'-'
         MVC   OCL_HISTDATA-OCL(4,R15),=32C'-'
         PUT   PDSRCMD_DCBH,PDSRCMD_PRRHL
PDSRCM_HIPRR$PL DS 0H
         PUT   PDSRCMD_DCBH,PDSRCMD_RECOUT
*
         L     R14,PDSRCMD_PRRRA
         BSM   0,R14
PDSRCM_HIPRRMDS MVC 0(0,R15),DA#DATED_STR-DA#DATED(R1)
         EJECT ,
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**       Constants for PDSRCM
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
PDSRCM_ZEROS    DC    X'00,00,00,00,00,00,00,00'
PDSRCM_HEXTABLE DC C'0123456789abcdef'
*
C_IEWB_RC_OK       DC AL4($IEWB_RC_OK)      .... 0
C_IEWB_RC_WARNING  DC AL4($IEWB_RC_WARNING) .... 4
C_IEWB_RC_ERROR    DC AL4($IEWB_RC_ERROR)   .... 8
C_IEWB_RC_SEVERE   DC AL4($IEWB_RC_SEVERE)  .... 12
C_IEWB_RC_TERMINAL DC AL4($IEWB_RC_TERMINAL) ... 16
*
C_ID_IDL_BUFFER DA#STR 'IDL_Buffer Entry'
C_ID_IDU_BUFFER DA#STR 'IDU_Buffer Entry'
C_ID_IDZ_BUFFER DA#STR 'IDZ_Buffer Entry'
C_ID_IDB_BUFFER DA#STR 'IDB_Buffer Entry'
C_ID_ESD_BUFFER DA#STR 'ESD_Buffer Entry'
C_ID_TXT_BUFFER DA#STR 'TXT_Buffer Entry'
*
C_ID_IDL_HEADER DA#STR 'IDL_Buffer Header'
C_ID_IDU_HEADER DA#STR 'IDU_Buffer Header'
C_ID_IDZ_HEADER DA#STR 'IDZ_Buffer Header'
C_ID_IDB_HEADER DA#STR 'IDB_Buffer Header'
C_ID_ESD_HEADER DA#STR 'ESD_Buffer Header'
C_ID_TXT_HEADER DA#STR 'TXT_Buffer Header'
*
MOVESEC  MVC   2(0,R4),0(R3)
*
PDSRCM_TID DC  C'<.......T r a n s l a t o r.........>'
*
*--> 1  <----------------------------------> Defined in PDSRCMC CSECT
MSGCM2A  DC    C'C02E   > IEWBIND FUNC=('
MSGCM2AL EQU   *-MSGCM2A
MSGCM3   DC    C'C03I Dump of "'
MSGCM3L  EQU   *-MSGCM3
MSGCM4   DC    C'C04I > Processing Member='
MSGCM4M  DC    CL8' '
         DC    C' Section="'
MSGCM4L  EQU   *-MSGCM4
*
MSGCM6   DC    C'C06I '
MSGCM6S  DC    C'> Program ID: '
MSGCM6I  DS    XL(L'TRANT_ID)
         DC    C' Name: '
MSGCM6N  DS    XL(L'TRANT_NAME)
MSGCM6U  DC    C'  '
MSGCM6SL EQU   *-MSGCM6S
         DC    C'Count:'
MSGCM6L  EQU   *-MSGCM6
MSGCM6A  DC    C'Total for all libraries:'
*
MSGCM8   DC    C'C08I   '
MSGCM8S  DC    C'> Program ID: '
MSGCM8I  DS    XL(L'TRANT_ID)
         DC    C' Name: '
MSGCM8N  DS    XL(L'TRANT_NAME)
         DC    C'           '
MSGCM8SL EQU   *-MSGCM8S
MSGCM8L  EQU   *-MSGCM8
MSGCM8A  DC    C'Total for library:'
*
MSGCM12  EQU   *-*          Used in PDSRCMM
MSGCM15  DC    C'C15I > Dataset type='
MSGCM15L EQU   *-MSGCM15
MSGCM16  DC    C'C16I > IGWASMS error, rc='
MSGCM16L EQU   *-MSGCM16
MSGCM17  DC    C'C17W > Truncated CSECT name, shown='
MSGCM17L EQU   *-MSGCM17
*--> 18 <----------------------------------> Defined in PDSRCMC CSECT
*
*
** Variable length string constants for version 1.1 and 1.2
*
B@ESD    DC    H'4',C'@ESD'               Class name for ESD
B@IDRL   DC    H'5',C'@IDRL'              Class name for IDR translator
B@IDRU   DC    H'5',C'@IDRU'              Class name for IDR user recs
B@IDRZ   DC    H'5',C'@IDRZ'              Class name for IDR Zap recs
B@IDRB   DC    H'5',C'@IDRB'              Class name for Binder ID Data
B@TEXT   DC    H'5',C'@TEXT'              Class name for TEXT records
*
** Variable length string constants for version 1.3 and higher
*
B_ESD    DC    H'5',C'B_ESD'              Class name for ESD
B_IDRL   DC    H'6',C'B_IDRL'             Class name for IDR translator
B_IDRU   DC    H'6',C'B_IDRU'             Class name for IDR user recs
B_IDRZ   DC    H'6',C'B_IDRZ'             Class name for IDR Zap recs
B_IDRB   DC    H'6',C'B_IDRB'             Class name for Binder ID Data
B_TEXT   DC    H'6',C'B_TEXT'             Class name for TEXT records
*
** Misc binder options
*
O_LIST   DC    H'4',C'LIST'               Option: List
V_ALL    DC    H'3',C'ALL'                Value: All
V_OFF    DC    H'3',C'OFF'                Value: Off
*
PARMS_DB   DC  AL2(L'PARMS_DBV)
PARMS_DBV  DC  C'PRINT(Y)'
*
PARMS_NDB  DC  AL2(L'PARMS_NDBV)
PARMS_NDBV DC  C'PRINT(N)'
*
** Various list constants
*
FILELIST DS    0F                         ddname
         DC    F'1'                       Number
         DC    CL8'PRINT',F'8',A(PRINTX)  Type, length of ddname, addr
PRINTX   DC    CL8'BINDEROU'              The ddname
*
OPTION_Y DC    C'Y'
OPTION_N DC    C'N'
*
OPTLIST1 DS    0F                         Global options specs
         DC    F'2'                       Number of list entries
         DC    CL8'TERM    ',F'1',A(OPTION_N)
         DC    CL8'PRINT   ',F'1',A(OPTION_N)
*
OPTLIST2 DS    0F                         Global options specs
         DC    F'2'                       Number of list entries
         DC    CL8'TERM    ',F'1',A(OPTION_Y)
         DC    CL8'PRINT   ',F'1',A(OPTION_Y)
*
OPTLIST3 DS    0F                         Global options specs
         DC    F'2'                       Number of list entries
         DC    CL8'TERM    ',F'1',A(OPTION_N)
         DC    CL8'PRINT   ',F'1',A(OPTION_Y)
*
CEXITL   DS    0F                         User exit specifications
         DC    F'1'                       Number of list entries
         DC    CL8'MESSAGE'               Type
         DC    F'12'                      Length of exit list
CEXITLA  DC    A(0)
CEXITLL  EQU   *-CEXITL
*
** QSAM I/O
*
PDSRCMCD DCB   DDNAME=PDSRCMCD,                                        @
               DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA
PDSRCMCDL EQU  *-PDSRCMCD
PDSRCMLO OPEN  (*-*,(OUTPUT)),MF=L
PDSRCMLOL EQU  *-PDSRCMLO
PDSRCMCL CLOSE (*-*),MF=L
PDSRCMCLL EQU  *-PDSRCMCL
*
** Buffer Mappings
*
         IEWBUFF FUNC=MAPBUF,TYPE=IDRB,SIZE=32,                        C
               VERSION=1,                                              C
               HEADREG=6,ENTRYREG=7
*
         IEWBUFF FUNC=MAPBUF,TYPE=IDRL,SIZE=32,                        C
               VERSION=1,                                              C
               HEADREG=6,ENTRYREG=7
*
         IEWBUFF FUNC=MAPBUF,TYPE=IDRU,SIZE=256,                       C
               VERSION=1,                                              C
               HEADREG=6,ENTRYREG=7
*
         IEWBUFF FUNC=MAPBUF,TYPE=IDRZ,SIZE=256,                       C
               VERSION=1,                                              C
               HEADREG=6,ENTRYREG=7
*
         IEWBUFF FUNC=MAPBUF,TYPE=TEXT,SIZE=128000,    128k            C
               VERSION=1,                                              C
               HEADREG=6,ENTRYREG=7
*
         IEWBUFF FUNC=MAPBUF,TYPE=ESD,SIZE=256,                        C
               VERSION=1,                                              C
               HEADREG=6,ENTRYREG=7
*
         IEWBUFF FUNC=MAPBUF,TYPE=NAME,SIZE=8192,                      C
               VERSION=1,                                              C
               HEADREG=8,ENTRYREG=9
*
** Copy in constants and equates for the Binder API
*
*        COPY IEWBCRL ,                 RLD codes
*        COPY IEWBCRS ,                 Binder API equates
*-Instead of importing over 700 lines from IEWBCRS, I just copied
*-the ones I needed:
$IEWB_RC_OK          EQU            0
$IEWB_RC_WARNING     EQU            4
$IEWB_RC_ERROR       EQU            8
$IEWB_RC_SEVERE      EQU            12
$IEWB_RC_TERMINAL    EQU            16
*
** Literals - To get more room, more of these LTORG values could
**            be moved to one of the constants CSECTs
*
         PRINT DATA
PDSRCM_LTORG  EQU  *
         LTORG ,
PDSRCM_LTORGL EQU *-PDSRCM_LTORG
         PRINT NODATA
*
** Calculate length of main CSECT
*
         DS    0D                         End on double word boundry
PDSRCML EQU    *-PDSRCM                   Length of program
PDSRCMB EQU    (3*4096)-PDSRCML           Bytes left addressable
         DS    0D
         DROP  R13,R12,R11,R10
         EJECT ,
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Constants for PDSRCM CSECT
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
PDSRCMC  CSECT ,
PDSRCMC  AMODE 24
PDSRCMC  RMODE 24
*
** Standard O/S eyecatcher
*
PDSRCMC_EC    B    PDSRCMC_ECL(0,R15)     Bump past EyeCatcher
              DC   AL1(L'PDSRCMC_ECLIT)   Length of eyecatcher
PDSRCMC_ECLIT DC   C'PDSRCMC  - Constants CSECT for PDSRCM'
              DS   0H
PDSRCMC_ECL   EQU  *-PDSRCMC_EC
*
** Moved constants here to make more room in PDSRCM CSECT
*
MSGCM1   DC    C'C01I > Warning: Not all sections processed, number '
         DC    C'not shown='
MSGCM1L  EQU   *-MSGCM1
MSGCM2   DC    C'C02E > Error using DFSMS/MVS Binder API on member='
MSGCM2L  EQU   *-MSGCM2
MSGCM5   DC    C'C05I Translator XREF for all libraries:'
MSGCM5L  EQU   *-MSGCM5
MSGCM7   DC    C'C07I > Translator XREF for this library:'
MSGCM7L  EQU   *-MSGCM7
MSGCM9   DC    C'C09I > Number of History (IDENTIFY) entries:'
MSGCM9L  EQU   *-MSGCM9
MSGCM10  DC    C'C10I > Number of History (ZAP) entries:'
MSGCM10L EQU   *-MSGCM10
*
MSGCM11  DC    C'C11I Number of Translator Program IDs that were '
         DC    C'unknown:'
MSGCM11L EQU   *-MSGCM11
MSGCM13  DC    C'C13I > Largest CSECT processed: size='
MSGCM13L EQU   *-MSGCM13
MSGCM14  DC    C'C14I > Oldest CSECT processed: date='
MSGCM14L EQU   *-MSGCM14
MSGCM18  DC    C'DA$PDSR-C18I > The following Binder (IEW) messages'
         DC    C' are for member='
MSGCM18L EQU   *-MSGCM18
MSGCM20  DC    C'C20W > Binder API GETN RC=4, Reason='
MSGCM20L EQU   *-MSGCM20
MSGCM19  DC    C'C19W > Binder API error for IDZ processing, Member='
MSGCM19L EQU   *-MSGCM19
MSGCM98  DC    C'C98I Using INTYPE=POINTER (DCB/DirectoryEntry) for '
         DC    C'Binder API IEWBIND FUNC=INCLUDE'
MSGCM98L EQU   *-MSGCM98
MSGCM99  DC    C'C99E Overflow on internal translator table'
MSGCM99L EQU   *-MSGCM99
*
CMC_MEMBER   DC  C'Member'
CMC_CSECT    DC  C'CSECT Name'
CMC_OFFSET   DC  C'Offset'
CMC_LENGTH   DC  C'length'
CMC_TRANDATE DC  C'Date'
CMC_TRANID   DC  C'ID'
CMC_TRANVER  DC  C'vv.mm'
CMC_TRANNAME DC  C'Name'
CMC_AMODE    DC  C'Addressing Mode'
CMC_ALIGN    DC  C'Alignment'
CMC_DASH     DC  32C'-'
         EJECT ,
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Flatout Member processing
**
** Output a line to //FLATOUT for each member processed.  We use
** the information on the output report line.
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
PDSRCMFM CSECT ,
PDSRCMFM AMODE 24
PDSRCMFM RMODE 24
*
** Standard O/S eyecatcher
*
CMFM_EC    B    CMFM_ECL(0,R15)        Bump past EyeCatcher
           DC   AL1(L'CMFM_ECLIT)      Length of eyecatcher
CMFM_ECLIT DC   C'PDSRCMFM - FLATOUT member processing'
           DS   0H
CMFM_ECL   EQU  *-CMFM_EC
*
** Entry Housekeeping
*
         BAKR  R14,0                      Save registers
         LAE   R12,0(R15,0)               Get base register
         USING PDSRCMFM,R12               Set module base
         SAC   0
         SYSSTATE ASCENV=P
         EREG  R0,R1                      Restore registers R0 and R1
         LR    R13,R1                     Locate RSA and work area
*
         CH    R0,=AL2(#FLATOUT_Member)
         BE    CMFM$Member
         CH    R0,=AL2(#FLATOUT_Open)
         BE    CMFM$Open
         B     CMFM$X
*
** Open
*
CMFM$Open ds 0h
         USING PDSRCMD_SUBRSA,R13        Locate to data area
         OI    PDSRCMD_IFLAG2,$PDSRCMD_IF2FO    Turn on flatout flag
         OI    PDSRCMD_FLAG1,$PDSRCMD_F1TEXT    Need Text processing
*
         LA    R3,PDSRCMD_DCBF            Locate DCB
         MVC   0(CMFMDCBVL,R3),CMFMDCBV    Copy in DCB constant
         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'FLATOUT'
         MVC   PDSRCMD_PARMLIST(CMFMOPNL),CMFMOPN
         OPEN  ((3),(OUTPUT)),            Open the file                @
               MF=(E,PDSRCMD_PARMLIST)
         L     R0,=AL4(32756+8)           Create record area
         GETMAIN RU,LV=(0)                Obtain storage
         STM   R0,R1,PDSRCMD_FOA          Save length and address
         MVC   FOM_EC-FOM(8,R1),=CL8'FLATOUT'
         MVI   FOM_EC+7-FOM(R1),C'R'
         XC    FOM_RDW-FOM(4,R1),FOM_RDW-FOM(R1) Zero out RDW
*
         L     R1,PDSRCMD_FOA+4          Locate FLATOUT record Area
         LA    R1,FOM_RECORD-FOM(R1) Locate to record output
         MVI   0(R1),C' '
         MVC   1(FORHL-1,R1),0(R1)
         MVI   FOR_TYPE-FOR(R1),$FORTYPE_H  Set type: Heading line
         L     R14,=V(DA$PDSR)
         MVC   FORH_NAME-FOR(7,R1),=C'DA$PDSR'
         MVC   FORH_VER-FOR(5,R1),=C'V&DAVER'
         MVC   FORH_ADATE-FOR(10,R1),=C'&ASMDATE'
         MVC   FORH_ATIME-FOR(5,R1),=C'&SYSTIME'
         LA    R15,FORHL(R1)             Locate to end of our line
         L     R1,PDSRCMD_FOA+4          Locate FLATOUT record Area
         LA    R1,FOM_RDW-FOM(R1)        Locate to record output
         SR    R15,R1                    Length = end - start
         STH   R15,0(R1)                 Save length of variable record
         LR    R0,R1                     Get record loc to rite reg
         PUT   PDSRCMD_DCBF,(0)          Output record...
         B     CMFM$X                    Leave
         DROP  R13                       Drop: SUBRSA2 + rest of workds
*
** Here we get called for each member
*
CMFM$Member ds 0h
         USING SUBRSA,R13                 Locate to data area
         ICM   R9,B'1111',A_PDSRCMD+4     Locate area
         BZ    CMFM$X                     None?
         USING PDSRCMD,R9                 Get addressability
*
** Debugging code to see what our input RECOUT field looks like
*
 AGO .CMFMDX ....................................
         L     R1,PDSRCMD_FOA+4
         LA    R14,FOM_RECORD-FOM(R1)
         MVI   FOR_TYPE-FOR(R14),$FORTYPE_DB
         MVC   FORDB_TYPE-FOR(8,R14),=CL8'CMFM'
         MVC   FORDB_VAR-FOR(132,R14),RECOUT+1
*
         LA    R1,FOM_RDW-FOM(R1)
         LA    R15,FORDBL+132+4
         STH   R15,0(R1)
         LR    R0,R1
         PUT   PDSRCMD_DCBF,(0)
.CMFMDX ANOP ....................................
*
         LA    R8,RECOUT+1
         USING DET,R8
*
         L     R7,PDSRCMD_FOA+4          Locate FLATOUT record Area
         LA    R7,FOM_RECORD-FOM(R7)     Locate to record output
         USING FOR,R7
*
         MVI   FOR_TYPE,$FORTYPE_M       Type = Member
         MVC   FORM_NAME(L'DETMEM),DETMEM
         MVI   FORM_SPACE1,C' '
         MVC   FORM_SIZE(L'DET_LSIZE),DET_LSIZE
         MVI   FORM_SPACE2,C' '
         MVC   FORM_AMODET(5),=C'AMODE'
         MVC   FORM_AMODE(2),DET_LMODEA
         MVI   FORM_SPACE3,C' '
         MVC   FORM_RMODET(5),=C'RMODE'
         MVC   FORM_RMODE(3),DET_LMODER
         MVI   FORM_SPACE4,C' '
         MVC   FORM_DATET(6),=C'DATE: '
         MVC   FORM_DATE(L'DET_LTD_DATE),DET_LTD_DATE
         MVI   FORM_SPACE5,C' '
         MVC   FORM_ATTRT(6),=C'ATTR: '
         MVC   FORM_ATTR(L'DET_LATTR),DET_LATTR
*-Note: More fields can be added here to output member record
*
         DROP  R7                        Drop: using=FOR
         DROP  R8                        Drop: using=DET: RECOUT+1
*
** Put the record to the //flatout file
*
         L     R1,PDSRCMD_FOA+4          Locate FLATOUT record Area
         LA    R1,FOM_RDW-FOM(R1)        Locate to record output
         LA    R15,FORML+4               Length = end - start
         STH   R15,0(R1)                 Save length of variable record
         LR    R0,R1                     Get record loc to rite reg
         PUT   PDSRCMD_DCBF,(0)          Output record...
         DROP  R9                        Drop: using=PDSRCMD
         DROP  R13                       Drop: SUBRSA + rest of workds
*
** Exit
*
CMFM$X   DS    0H
         SLR   R15,R15
         PR    ,
*
** Constants
*
CMFMDCBV DCB   DDNAME=CMFMDCBV,                                        @
               DSORG=PS,MACRF=PM,RECFM=VB
CMFMDCBVL EQU  *-CMFMDCBV
CMFMOPN OPEN   (*-*,(OUTPUT)),MF=L
CMFMOPNL EQU   *-CMFMOPN
*
** Literals and end of CSECT
*
         LTORG ,
         DS    0D
CMFM$L   EQU   *-PDSRCMFM
         DROP  R12
         EJECT ,
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Message exit routine for Binder API.  This routine gets invoked
** when a message is issued by the Binder.
**
** Although not documented in the current version of the DFSMS 1.3
** "Program Management" manual (SC26-4916-02 May 1997), the message
** buffer differs from the manual when executing under DFSMS 1.3
** where it has a halfword length byte preceding the message.  The
** code below allows for the different buffer format for DFSMS/MVS
** version 1.1, 1.2, 1.3 and higher.
**
** Messages come from the binder of varying lengths include longer
** than 133 so we can't just blindly print the whole message asis.
** The code below breaks up the input line link the Binder at 120
** columns.
**
** After the first line, the left margin gets changed to 10 so text
** text for a message on remaining lines are after the message id.
** For example, a long message would look like:
**
** MSGID text text text text text text text (on line1)
**       text text text (on line 2)
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
PDSRCMM  CSECT ,
*
** Standard O/S eyecatcher
*
PDSRCMM_EC    B    PDSRCMM_ECL(0,R15)     Bump past EyeCatcher
              DC   AL1(L'PDSRCMM_ECLIT)   Length of eyecatcher
PDSRCMM_ECLIT DC   C'PDSRCMM  - Msg Exit for PDSRCM'
              DS   0H
PDSRCMM_ECL   EQU  *-PDSRCMM_EC
*
         BAKR  R14,0                      Save registers
         LAE   R12,0(R15,0)               Get base register
         USING PDSRCMM,R12                Set module base
         SAC   0
         SYSSTATE ASCENV=P
         EREG  R0,R1                      Restore Registers R0 and R1
*
         LR    R10,R1                     Save input parmlist address
         L     R1,MXPL_USERDATA-MXPL(R10) Get address of user data
         L     R11,0(,R1)                 Get user data (work area)
         USING PDSRCMD,R11                Get addressability
         L     R1,MXPL_BUFFER-MXPL(R10)   Get addr of addr of msg buf
         L     R3,0(,R1)                  Get address of message buffer
*-Skip some silly messages if not in Binder-Debug mode
         TM    PDSRCMD_IFLAG1,$PDSRCMD_IF1BDB Debug mode?
         BO    MX$BDBX
         CLC   PDSRCMD_DFARELS(4),=X'01010200' v1.3 or higher?
         BH    MX$SMV13                   Yes, chk with new msg format
         CLC   1(8,R3),=C'IEW2370W'       No data for $PRIVATE
         BE    MX$X
         CLC   1(8,R3),=C'IEW2371W'       GETD no data for IDRU
         BE    MX$X
         B     MX$BDBX
MX$SMV13 DS    0H
         CLC   2(8,R3),=C'IEW2370W'       No data for $PRIVATE
         BE    MX$X
         CLC   2(8,R3),=C'IEW2371W'       GETD no data for IDRU
         BE    MX$X
MX$BDBX  DS    0H
*
** Locate some common fields
*
         L     R1,MXPL_LINECNT-MXPL(,R10) Get addr of line count hw
         LH    R4,0(R1)                   Get number of lines
         L     R1,MXPL_CHARCNT-MXPL(,R10) Get addr of char count hw
         LH    R5,0(R1)                   Number of characters on line
*
         LA    R13,PDSRCMD_MXSAVE
         MVC   4(4,R13),=C'F1SA'          Set up Register Save Area
         LA    R7,PDSRCMD_MXREC
*
** Message exit debugging
*
         TM    PDSRCMD_IFLAG2,$PDSRCMD_IF2MXDB  Debugging mode?
         BNO   MX$DBX                           Yes, do it
         LR    R15,R7
         MVI   0(R15),C' '
         MVC   1(132,R15),0(R15)
         MVC   1(29,R15),=C'DA$PDSR-C12I MSGEXIT - Lines='
         LA    R15,1+29(R15)
         L     R1,MXPL_LINECNT-MXPL(,R10) Get addr of line count hw
         UNPK  0(5,R15),0(3,R1)
         MVZ   0(4,R15),=8X'00'
         TR    0(4,R15),=C'0123456789abdef'
         LA    R15,4(R15)
         MVC   0(10,R15),=C', LineLen='
         LA    R15,10(R15)
         L     R1,MXPL_CHARCNT-MXPL(,R10) Get addr of char count hw
         UNPK  0(5,R15),0(3,R1)
         MVZ   0(4,R15),=8X'00'
         TR    0(4,R15),=C'0123456789abdef'
         LA    R15,4(R15)
         MVC   0(8,R15),=C', DFSMS='
         LA    R15,8(R15)
         UNPK  0(9,R15),PDSRCMD_DFARELS(5)
         MVZ   0(8,R15),=8X'00'
         TR    0(8,R15),=C'0123456789abdef'
         MVI   8(R15),C' '
         L     R0,PDSRCMD_PSRAREA         Locate work area
         LR    R1,R7                      Locate record to print
         L     R15,=V(PDSR$PSR)           Locate sysprint routine
         BASR  R14,R15                    Print Sysprint Record
*
** R3 = message  R4 = Number of lines     R5 = Length of line
         MVI   0(R7),C' '
         MVC   1(132,R7),0(R7)
         L     R9,PDSRCMD_PSRAREA         Locate to area
         USING PSRAREA,R9                 Enable field access
MX$DBML  DS    0H
         XC    W_AREA(CMXDL),W_AREA       Initialize area
         LR    R15,R3                     Get address of area to dump
         LR    R0,R5                      Get length of msg line
         LA    R1,9(R7)                   Get output location
         STM   R15,R1,W_AREA+CMXD_ADDRESS-CMXD  Data, Length, Output
         OI    W_AREA+CMXD_FLAG1-CMXD,$CMXD_F1ADDR
         TM    PDSRCMD_IFLAG2,$PDSRCMD_IF2TSOV
         BO    MX$DBDL
         MVC   W_AREA+CMXD_OUTPUTL-CMXD(2),=AL2(132) <- TSO viewing
MX$DBDL  DS    0H
         LA    R1,W_AREA                  Locate work area
         L     R15,EP_DA$MXD              -> DA$MXD E.P.A.
         BASSM R14,R15                    Call DA$MXD
         LR    R8,R15                     Save return code
*
         L     R0,PDSRCMD_PSRAREA         Locate work area
         LR    R1,R7                      Locate record to print
         L     R15,=V(PDSR$PSR)           Locate sysprint routine
         BASR  R14,R15                    Print Sysprint Record
*
         LTR   R8,R8                      Any more lines to do...
         BNZ   MX$DBDL                    Thank you: May I have another
*
         L     R0,PDSRCMD_PSRAREA         Locate work area
         LR    R1,R7                      Locate record to print
         MVI   0(R1),C' '                 Get blank
         MVC   1(132,R1),0(R1)            ..propagate blank
         L     R15,=V(PDSR$PSR)           Locate sysprint routine
         BASR  R14,R15                    Print Sysprint Record
*
         AR    R3,R5                      Locate next line (if any)
         BCT   R4,MX$DBML
MX$DBX   DS    0H
         L     R1,MXPL_BUFFER-MXPL(R10)   Get addr of addr of msg buf
         L     R3,0(,R1)                  Get address of message buffer
         L     R1,MXPL_LINECNT-MXPL(,R10) Get addr of line count hw
         LH    R4,0(R1)                   Get number of lines
         DROP  R9
*
** For the first Binder messages for this member:
** - Print a message line with the member name so we know who it is for
*
         TM    PDSRCMD_IFLAG2,$PDSRCMD_IF2MXDB
         BO    MX$BLX
         TM    PDSRCMD_IFLAG2,$PDSRCMD_IF2EMSG
         BO    MX$BLX
         OI    PDSRCMD_IFLAG2,$PDSRCMD_IF2EMSG
*
         LR    R15,R7                     Locate print record
         L     R1,=V(PDSRCMC)             Locate constants CSECT
         MVC   1(MSGCM18L,R15),MSGCM18-PDSRCMC(R1) Get message
         LA    R15,1+MSGCM18L(R15)        Locate past message
         MVC   0(8,R15),PDSRCMD_MODNAME+2 Get member name
         BAS   R14,MX_EPM                 Ensure Printable Member name
         LA    R0,#MX_EPML
*-Instream Locate_First_Space routine (it does look familiar?)
MX$M18L  DS    0H
         CLI   0(R15),C' '                Blank?
         BE    MX$M18X                    Yes, leave
         LA    R15,1(R15)                 No, bump to next byte
         BCT   R0,MX$M18L                 ..Repeat
MX$M18X  DS    0H
         MVI   0(R15),C':'                Append it
         L     R0,PDSRCMD_PSRAREA         Locate work area
         LR    R1,R7                      Get input record location
         L     R15,=V(PDSR$PSR)           Locate sysprint routine
         BASR  R14,R15                    Print Sysprint Record
*
         LR    R1,R7                      Locate record to print
         MVI   0(R1),C' '                 Get blank
         MVC   1(132,R1),0(R1)            ..propagate blank
MX$BLX   DS    0H
         CLC   PDSRCMD_DFARELS(4),=X'01010200' v1.3 or higher?
         BH    MX$V13                     Yes, use new format
*
** Set for the message format of DFSMS/MVS 1.1 and 1.2
**
** R3 = message  R4 = Number of lines     R5 = Length of line
*
MX$V11   DS    0H
         LR    R9,R5                      Get length in odd register
         SLR   R8,R8                      Clear for multiply
         MR    R8,R4                      R9 = total message length
         LR    R6,R3                      Locate start of message
         CLI   0(R6),C' '                 Blank at start?
         BNE   MX$V11BX                   No, continue
         BCTR  R9,0                       Yes, decrement length by 1
         LA    R6,1(R6)                   .....and bump past blank
MX$V11BX DS    0H
*-Trim trailing blanks from message
         LR    R1,R6                      Locate start of message
         AR    R1,R9                      Now find the end
MX$V11TL DS    0H
         CLI   0(R1),C' '                 Trailing blank
         BNE   MX$V11TX                   No, leave
         BCTR  R1,0                       Backup 1
         BCT   R9,MX$V11TL                Process next byte
MX$V11TX DS    0H
         LA    R9,1(R9)                   Add back last byte
         B     MX$FPM                     Now format and print message
*
** Set up for the new feature of DFSMS/MVS 1.3 where the message
** buffer now has a halfword length value of the relevant part of
** the message.
*
MX$V13   DS    0H
         LH    R9,0(R3)                   Get length of input record
         LTR   R9,R9                      Input length is zero?
         BZ    MX$V11                     Yes, avoid divide by zero
         LA    R6,2(R3)                   Locate first byte of record
*
** Format and print Message
**
** R9 has total length of message, R6 has start of message
*
#MXRECL  EQU   119                        Length to print on line
MX$FPM   DS    0H
         SLR   R2,R2                      Current line number
         SLR   R8,R8                      Clear for divide
         D     R8,=AL4(#MXRECL)           Calculate number of lines
         LTR   R9,R9                      At least one full line?
         BZ    MX$FPMLX                   Nope, shorter than #MXRECL
MX$FPML  DS    0H
         MVI   0(R7),C' '                 Get Blank
         MVC   1(132,R7),0(R7)            ..Propagate it
         LTR   R2,R2                      Check out line number
         BZ    MX$FPMLM                   First one: use left margin
         LA    R1,10
         MVC   10(#MXRECL,R7),0(R6)       Move over a bit
         B     MX$FPMLMX
MX$FPMLM DS    0H
         LA    R1,1
         MVC   1(#MXRECL,R7),0(R6)        Get full line
MX$FPMLMX DS   0H
         LTR   R8,R8                      Anything on partial line?
         BZ    MX$FPMLAX                  No
         LR    R14,R7                     Locate start of line
         LA    R14,#MXRECL(R14)           Locate to end of line
         AR    R14,R1                     Add for left margin
         MVI   1(R14),C'+'                Indicate continuation line
         CH    R9,=H'1'                   On last line?
         BNE   MX$FPMLAX                  No
         CH    R8,=H'5'                   Makes sense to append?
         BH    MX$FPMLAX                  No
         LR    R15,R6                     Locate start of data
         LA    R15,#MXRECL(R15)           Locate to partial line start
         BCTR  R8,0                       Decrement for ex
         EX    R8,MX$FPMLAM               Append partial to last full
         SLR   R8,R8                      No more partial line
MX$FPMLAX DS   0H
*
         L     R0,PDSRCMD_PSRAREA         Locate work area
         LR    R1,R7                      Locate record to print
         L     R15,=V(PDSR$PSR)           Locate sysprint routine
         BASR  R14,R15                    Print Sysprint Record
*
         LA    R6,#MXRECL(R6)             Bump to next full line
         LA    R2,1(R2)                   Increment line number
         BCT   R9,MX$FPML                 Try it out
MX$FPMLX DS    0H
         LTR   R8,R8                      Check out partial line
         BZ    MX$FPMX                    None, even divide
         MVI   0(R7),C' '                 Get blank
         MVC   1(132,R7),0(R7)            ..propagate it
         BCTR  R8,0                       Decrement for EX
         LTR   R2,R2                      Check out line number
         BZ    MX$FPMLMP                  First one: use left margin
         EX    R8,MX$FPMMPO               Move partial line out
         B     MX$FPMLMPX
MX$FPMLAM MVC  0(0,R14),0(R15)            ** Executed **
MX$FPMMP  MVC  1(0,R7),0(R6)              ** Executed **
MX$FPMMPO MVC  10(0,R7),0(R6)             ** Executed **
MX$FPMLMP DS   0H
          EX    R8,MX$FPMMP               Move partial line out
MX$FPMLMPX DS  0H
*
         L     R0,PDSRCMD_PSRAREA         Locate work area
         LR    R1,R7                      Locate record to print
         L     R15,=V(PDSR$PSR)           Locate sysprint routine
         BASR  R14,R15                    Print Sysprint Record
MX$FPMX  DS    0H
*
** If in MSGEXIT debugging mode, print a blank line after msg(s)
*
         TM    PDSRCMD_IFLAG2,$PDSRCMD_IF2MXDB
         BNO   MX$X
         L     R0,PDSRCMD_PSRAREA         Locate work area
         LR    R1,R7                      Locate record to print
         MVI   0(R1),C' '                 Get blank
         MVC   1(132,R1),0(R1)            ..propagate blank
         L     R15,=V(PDSR$PSR)           Locate sysprint routine
         BASR  R14,R15                    Print Sysprint Record
*
** Exit from PDSRCMM
*
MX$X     DS    0H
         L     R1,MXPL_RC-MXPL(R10)       Locate return code
         XC    0(4,R1),0(R1)              Clear return code (parm)
         SLR   R15,R15                    Clear return code
         PR    ,                          Return to caller
*
** Ensure that member (or any 8 byte area) has only valid characters
**
** Input: R15 - 8 byte member name with 18 bytes for hex conversion
**
** Note: We save R2 because TRT *DESTROYS* R2
*
MX_EPM   DS    0H
         ST    R14,PDSRCMD_DOUBLE         Save return address
         ST    R2,PDSRCMD_DOUBLE+4        Save this register (TRT)
         L     R1,=V(PDSR$C2)             -> Constants CSECT
         TRT   0(8,R15),C_TABPRT-PDSR$C2(R1) Valid characters only?
         BZ    MX$EPM$X                   Yes, leave
         MVI   8(R15),C'/'                Insert delimiter
         UNPK  9(9,R15),0(5,R15)          >>
         MVZ   9(8,R15),MX_ZEROS          >>> Convert first 4 bytes
         TR    9(8,R15),MX_HEXTABLE       >>
         UNPK  9+8(9,R15),4(5,R15)        <<
         MVZ   9+8(8,R15),MX_ZEROS        <<< Convert last 4 bytes
         TR    9+8(8,R15),MX_HEXTABLE     <<
         MVI   9+8+8(R15),C' '            Fix last byte
         L     R1,=V(PDSR$C2)             -> Constants CSECT
         TR    0(8,R15),C_TRTABM-PDSR$C2(R1) Translate to valid...
MX$EPM$X EQU *
         L     R2,PDSRCMD_DOUBLE+4        Restore this register
         L     R14,PDSRCMD_DOUBLE         Get return address
         BSM   0,R14                      Return to caller
#MX_EPML EQU   8+1+16                     Max length
*
** Constants
*
MX_ZEROS    DC    X'00,00,00,00,00,00,00,00'
MX_HEXTABLE DC    C'0123456789abcdef'
*
         LTORG ,                          Literals in PDSRCMM
         DS    0D                         End of PDSRCMM
*
** Calculate length of module
*
#PDSRCMM      EQU    *-PDSRCMM
#PDSRCMM_LEFT EQU 4096-#PDSRCMM
         DROP  R12,R11
*
** Map the Message Exit Parmeter List (passed to the msg exit)
*
MXPL          DSECT ,
MXPL_USERDATA DS    F                     -> Pointer to userdata
MXPL_BUFFER   DS    F                     -> Pointer to Buffer
MXPL_LINECNT  DS    F                     -> Pointer to Line count
MXPL_CHARCNT  DS    F                     -> Pointer to Line length
MXPL_MSGNUM   DS    F                     -> Pointer to Message number
MXPL_SEVCODE  DS    F                     -> Pointer to Severity code
MXPL_REASON   DS    F                     -> Pointer to Reason code
MXPL_RC       DS    F                     -> Pointer to Return code
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Interal DSECTs
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
*
** Compiler XREF DSECT
*
CXREF        DSECT ,
CXREF_TRANT  DS    XL(TRANTL)             T_TRANT entry (if there)
CXREF_TYPE   DS    X                      Type of entry
$CXREFT_S    EQU   0                      ..Static (from T_TRANT)
$CXREFT_D    EQU   1                      ..Dynamic (added when found)
             DS    0F
CXREF_COUNTT DS    F                      Total count
CXREF_COUNTL DS    F                      Library count
CXREFL       EQU   *-CXREF                Length of entry
*
** Map the output CSECT line
*
OCL           DSECT ,
              DS    C                     FBA
OCL_MEMBER    DS    CL8
OCL_ALIAS     DS    CL2
              DS    C
OCL_CSECT     DS    CL10
              DS    C
OCL_OFFSET    DS    CL8
              DS    C
OCL_LENGTH    DS    CL8
              DS    C
OCL_VARIABLE  EQU   *
*
OCL_TRAN      EQU   *
OCL_TRANDATE  DS    C'06-MAR-1962'
              DS    C
OCL_TRANID    DS    XL(L'IDL_PID_ID)
              DS    C
OCL_TRANVER   DS    CL2
OCL_TRANDOT   DS    C'.'
OCL_TRANMOD   DS    CL2
              DS    C
OCL_TRANNAME  DS    XL(L'TRANT_NAME)
OCL_TRANL     EQU   *-OCL_TRAN
OCLSL         EQU   *-OCL
*
              ORG   OCL_VARIABLE
OCL_HIST      EQU   *
OCL_HISTDATE  DS    C'06-MAR-1962'
              DS    C
OCL_HISTDATA  DS    XL(L'IDU_DATA)
              ORG   ,
              ORG   OCL_VARIABLE+40
OCL_AMODE     DS    C'AMODE ANY'
              DS    CL2
OCL_RMODE     DS    C'RMODE ANY'
OCL_AML       EQU   *-OCL_AMODE
              DS    CL4
OCL_ALIGN     DS    C'Double Word'
              ORG   ,
OCLL          EQU   *-OCL
              ORG   ,
*
** FLATOUT Memory (eyecatcher, RECFM=VB Record Desc Word and record)
*
FOM           DSECT ,
FOM_EC        DS    CL8'FLATOUTR'
FOM_RDW       DS    F
FOM_RECORD    EQU   *
*
** FLATOUT record
*
#FLATOUT_Open   EQU X'01'
#FLATOUT_Member EQU X'02'
*
FOR           DSECT ,
FOR_TYPE      DS    C' '                  Type of record:
$FORTYPE_C    EQU   C'C'                  ..CSECT
$FORTYPE_D    EQU   C'D'                  ..DSN
$FORTYPE_M    EQU   C'M'                  ..Member
$FORTYPE_H    EQU   C'H'                  ..Header (ID) line
$FORTYPE_DB   EQU   C'*'                  ..Debugging line
FOR_SPACE1    DS    C' '
FOR_LIBN      DS    C'999'                Overflow if over 999!!!
FOR_SPACE2    DS    C' '
FOR_START     EQU   *
*
FORC          EQU   *                     - - - - - - - - CSECT
FORC_OCL      DS    XL(OCLSL-1)           CSECT info (static only)
FORC_SPACE1   DS    C' '
FORC_CSECT256 DS    XL256                 Up to first 256 bytes
FORCL         EQU   *-FOR
*
              ORG   FOR_START
FORH          EQU   *                     - - - - - - - - DSN
FORH_NAME     DS    C'DA$PDSR'
FORH_SPACE1   DS    C' '
FORH_VER      DS    C'V&DAVER'
FORH_SPACE2   DS    C' '
FORH_ADATE    DS    C'&ASMDATE'
FORH_SPACE3   DS    C' '
FORH_ATIME    DS    C'&SYSTIME'
FORHL         EQU   *-FOR
              ORG   ,
*
              ORG   FOR_START
FORD          EQU   *                     - - - - - - - - DSN
FORD_VOL      DS    CL6
FORD_SPACE1   DS    C' '
FORD_DSN      DS    CL44
FORDL         EQU   *-FOR
              ORG   ,
*
              ORG   FOR_START
FORM          EQU   *                     - - - - - - - - Member
FORM_NAME     DS    CL8' '
FORM_SPACE1   DS    C' '
FORM_SIZE     DS    XL(L'DET_LSIZE)
FORM_SPACE2   DS    C' '
FORM_AMODET   DS    C'AMODE'
FORM_AMODE    DS    CL2
FORM_SPACE3   DS    C' '
FORM_RMODET   DS    C'RMODE'
FORM_RMODE    DS    CL3
FORM_SPACE4   DS    C' '
FORM_DATET    DS    C'DATE: '
FORM_DATE     DS    XL(L'DET_LTD_DATE)
FORM_SPACE5   DS    C' '
FORM_ATTRT    DS    C'ATTR: '
FORM_ATTR     DS    XL(L'DET_LATTR)
FORML         EQU   *-FOR
              ORG   ,
*
              ORG   FOR_START
FORDB         EQU   *                     - - - - - - - - Debugging
FORDB_TYPE    DS    CL8'Type'
FORDB_VAR     EQU   *
FORDBL        EQU   *-FOR
              ORG   ,
*
** Map the PDSRCM Data area
*
PDSRCMD          DSECT ,
PDSRCMD_RSA      DS    18F                Register Save Area
PDSRCMD_ID       DS    CL8'PDSRCMD'       ID for dumps
PDSRCMD_SUBRSA   DS    18F                Register Save Area 4 subs
* = = = = = = = = = = = = = = = = = = = = Start of external fields.....
*
** These fields are modified by callers of PDSRCM
*
PDSRCMD_CALLT    DS    C' '               Call type:
$PDSRCMD_CT_INIT EQU   C'I'               ..Initialization
$PDSRCMD_CT_MEM  EQU   C'M'               ..Member call
$PDSRCMD_CT_LIBS EQU   C'S'               ..Library Start
$PDSRCMD_CT_LIBE EQU   C'E'               ..Library End
$PDSRCMD_CT_TERM EQU   C'T'               ..Termination
PDSRCMD_ALIAS    DS    C'-A'              ALIAS information
PDSRCMD_FLAG1    DS    B'00000000'        Flag byte 1
$PDSRCMD_F1TRAN  EQU   B'10000000'        ..Translator report?
$PDSRCMD_F1HIST  EQU   B'01000000'        ..History report?
$PDSRCMD_F1TEXT  EQU   B'00100000'        ..Looking at TEXT?
*
$PDSRCMD_F1DCB   EQU   B'00000001'        ..Use DCB not INCLLIB/MODNAME
                 DS    0F
PDSRCMD_PDS2     DS    F                  Address of PDS2 member area
PDSRCMD_SUBRSAP  DS    F                  Address of SUBRSA
PDSRCMD_PSRAREA  DS    F                  Print_Sysprint_Record Area
PDSRCMD_DSNAME   DS    XL4                Dataset name for rpt heading
PDSRCMD_VOLSER   DS    XL4                Volser for rpt heading
PDSRCMD_INCLLIB  DS    H'8',CL8' '        DDNAME
PDSRCMD_MODNAME  DS    H'8',CL8' '        Member name
PDSRCMD_DCBPTR   DS    XL4                DCB pointer
PDSRCMD_DEPTR    DS    XL4                Directory Entry Pointer
PDSRCMD_DATE     DS    XL4                DA$DATE structure - Date
PDSRCMD_TIME     DS    XL4                DA$DATE structure - Time
*
** These fields are modified by PDSRCM
*
                 DS    0F
PDSRCMD_BINDER   DS    XL4                Binder entry pointer
PDSRCMD_MZAPCNT  DS    XL4                Zap count for current member
PDSRCMD_CSECTS   DS    XL4                Number of CSECTs
* = = = = = = = = = = = = = = = = = = = = End of external fields.......
*-Note: The rest of the fields in PDSRCM are "Internal" and should not
*-be referenced/changed outside of PDSRCM.
*
                 DS    0F                 Message exit list:
PDSRCMD_FUNC     DS    CL8' '             Current function
PDSRCMD_WKTOKENI DS    CL8' WTOKEN='
PDSRCMD_WKTOKEN  DS    XL8                Workmod Token
PDSRCMD_DTOKENI  DS    CL8' DTOKEN='
PDSRCMD_DTOKEN   DS    XL8                Dialog Token
PDSRCMD_RETCODEI DS    CL4' RC='
PDSRCMD_RETCODE  DS    XL4                Return code
PDSRCMD_RSNCODEI DS    CL4'RSN='
PDSRCMD_RSNCODE  DS    XL4                Reason code
PDSRCMD_B_ESD    DS    H'5',C'B_ESD'      Class name for ESD
PDSRCMD_B_IDRL   DS    H'6',C'B_IDRL'     Class name for IDR translator
PDSRCMD_B_IDRU   DS    H'6',C'B_IDRU'     Class name for IDR user
PDSRCMD_B_IDRZ   DS    H'6',C'B_IDRZ'     Class name for IDR Zap
PDSRCMD_B_IDRB   DS    H'6',C'B_IDRB'     Class name for Binder ID
PDSRCMD_B_TEXT   DS    H'6',C'B_TEXT'     Class name for TEXT
                 DS    0F
PDSRCMD_LIBC     DS    F                  Library count
PDSRCMD_TRUNCC   DS    F                  Truncated CSECT count
PDSRCMD_IGWASMS  DS    F                  EPA of IGWASMS routine
PDSRCMD_FOA      DS    2F                 //FLATOUT record area
                 DS    0F                 Message exit list:
PDSRCMD_MESSAGE  DS    F                  ..Exit routine entry point
                 DS    F                  ..User data for exit routine
                 DS    F                  ..Message exit severity level
PDSRCMD_EXITLIST DS    XL(CEXITLL)        Exit list
                 DS    0F                 GETN for section names
PDSRCMD_COUNTN   DS    F                  ..Number of sections returned
PDSRCMD_COUNTNC  DS    F                  ..Current section processed
PDSRCMD_CURSORN  DS    F                  ..Cursor value for GETN call
PDSRCMD_TCOUNT   DS    F                  ..Total number of sections
                 DS    0F                 GETD for ESD entries
PDSRCMD_COUNTDE  DS    F                  ..Count of ESD entries
PDSRCMD_COUNTDL  DS    F                  ..Count of IDL entries
PDSRCMD_COUNTDU  DS    F                  ..Count of IDU entries
PDSRCMD_CURSORDE DS    F                  ..Cursor value for GETD/ESD
PDSRCMD_CURSORDL DS    F                  ..Cursor value for GETD/IDL
PDSRCMD_CURSORDU DS    F                  ..Cursor value for GETD/IDU
                 DS    0F                 Saved Registers:
PDSRCMD_SAVEESD  DS    2F                 ..IEWBESD area
PDSRCMD_SAVEBNL  DS    2F                 ..IEWBBNL area
PDSRCMD_SAVEIDL  DS    2F                 ..IEWBIDL area
PDSRCMD_SAVEIDU  DS    2F                 ..IEWBIDU area
PDSRCMD_SAVEIDZ  DS    2F                 ..IEWBIDZ area
PDSRCMD_SAVEIDB  DS    2F                 ..IEWBIDB area
PDSRCMD_SAVETXT  DS    2F                 ..IEWBTXT area
                 DS    0F                 Print_Report_Record:
PDSRCMD_PRRRA    DS    F                  ..Return Address
PDSRCMD_PRRHL    DS    CL133              ..Heading record
                 DS    0F                 ..Translator Report:
PDSRCMD_TRPRRPC  DS    F                    ..Page count
                 DS    0F                   ..Max CSECT size:
PDSRCMD_TRMSIZE  DS    F                      ..Size
PDSRCMD_TRMSIZEN DS    CL8                    ..CSECT name
PDSRCMD_TRMSIZEM DS    CL8                    ..Member name
                 DS    0F                   ..Oldest CSECT:
PDSRCMD_TRODATE  DS    XL(L'IDL_DATE_PROCESSED) Date
PDSRCMD_TRODATEN DS    XL(L'OCL_CSECT)        ..CSECT name
PDSRCMD_TRODATEM DS    CL8                    ..Member name
*
PDSRCMD_TRPRRLC  DS    X                    ..Line count
                 DS    0F                 ..History Report:
PDSRCMD_HIPRRPC  DS    F                    ..Page count
PDSRCMD_HIPRRLC  DS    X                    ..Line count
                 DS    0F                 $Member_Translator routine:
PDSRCMD_MTRA     DS    F                  ..Return address
PDSRCMD_MTSREG   DS    6F                 ..Save Regs 4,5,6,7,8,9
PDSRCMD_MTRCXREF DS    2F                 ..Cross Reference table
                 DS    0F                 $Member_History routine:
PDSRCMD_MHIA     DS    F                  ..Return address
PDSRCMD_MHSREG   DS    4F                 ..Save Regs 4,5,6,7
PDSRCMD_MHCOUNTU DS    F                  ..Count of user entries
PDSRCMD_MHCOUNTZ DS    F                  ..Count of zap entries
                 DS    0F                 EditFullWordFlush
PDSRCMD_EDITRA   DS    F                  ..Return address
                 DS    0D                 Misc work areas:
PDSRCMD_DOUBLE   DS    D                  ..Double word work area
PDSRCMD_DOUBLE2  DS    2D                 ..Double Double word area
PDSRCMD_PARMLIST DS    256X               Parameter list for calls
                 DS    0F                 Msgexit (PDSRCMM):
PDSRCMD_MXSAVE   DS    18F                ..Register Save Area
PDSRCMD_MXREC    DS    CL133              ..Output record
                 DS    0F                 Dump_Entry:
PDSRCMD_DERA     DS    F                  ..Return address
PDSRCMD_DESREG   DS    2F                 ..Save register
PDSRCMD_DESREGA  DS    F                    ..Address of area
PDSRCMD_DESREGL  DS    F                    ..Length of area
PDSRCMD_DESREGI  DS    F                    ..ID string address
PDSRCMD_DEREC    DS    CL133              ..Output record
                 DS    0F
PDSRCMD_DCBT     DS    XL(PDSRCMCDL)      DCB for DD=TRANRPT
PDSRCMD_DCBH     DS    XL(PDSRCMCDL)      DCB for DD=HISTRPT
PDSRCMD_DCBF     DS    XL(CMFMDCBVL)      DCB for DD=FLATOUT
PDSRCMD_DFARELS  DS    XL(L'DFARELS)      DFSMS/MVS release level
PDSRCMD_IFLAG    DS    C'IFLG'            Set for dumps
PDSRCMD_IFLAG1   DS    B'00000000'        Internal Flag byte 1
$PDSRCMD_IF1BDB  EQU   B'10000000'        ..Binder Debug Mode?
$PDSRCMD_IF1INIT EQU   B'01000000'        ..Did we initialize?
$PDSRCMD_IF1TRM  EQU   B'00100000'        ..Found Translator member?
$PDSRCMD_IF1HIM  EQU   B'00010000'        ..Found History member?
$PDSRCMD_IF1DMPA EQU   B'00001000'        ..Dump Areas?
$PDSRCMD_IF1FT   EQU   B'00000100'        ..First translator?
$PDSRCMD_IF1THR  EQU   B'00000010'        ..Printed Heading record?
$PDSRCMD_IF1TTO  EQU   B'00000001'        ..Translator Table Overflow?
PDSRCMD_IFLAG2   DS    B'00000000'        Internal Flag byte 2
$PDSRCMD_IF2FSEC EQU   B'10000000'        ..First section?
$PDSRCMD_IF2SD   EQU   B'01000000'        ..Did a good STARTD?
$PDSRCMD_IF2EMSG EQU   B'00100000'        ..First error message?
$PDSRCMD_IF2MEM  EQU   B'00010000'        ..Processed a member yet?
$PDSRCMD_IF2MXDB EQU   B'00001000'        ..MSGEXIT debug?
$PDSRCMD_IF2UDCB EQU   B'00000100'        ..Use DCB?
$PDSRCMD_IF2TSOV EQU   B'00000010'        ..TSO viewing?
$PDSRCMD_IF2FO   EQU   B'00000001'        ..//FLATOUT processing?
PDSRCMD_IFLAG3   DS    B'00000000'        Internal Flag byte 2
$PDSRCMD_IF3EC   EQU   B'10000000'        ..Eyecatcher Report?
$PDSRCMD_IF3STR  EQU   B'01000000'        ..Simulate TranRpt?
$PDSRCMD_IF3IVC  EQU   B'00100000'        ..Vendor CSECT?
*
PDSRCMD_RECOUT   DS    CL133              Output record
                 DS    CL64               Slack
                 DS    0H
PDSRCMD_CSPRIVC  DS    XL2
PDSRCMD_OCLCSECT DS    XL(L'OCL_CSECT)    Output CSECT name
                 DS    0H
PDSRCMD_SECTION  DS    H,1024X            Section Name
                 DS    0D
PDSRCMDL         EQU   *-PDSRCMD
*
.CCMX    ANOP ,
         EJECT
***********************************************************************
***
**       GETMAINed work area
***
***********************************************************************
             SPACE 2
WORKDS       DSECT ,
             DS    18F                    Register Save Area
SUBRSA       DS    18F                    Locate subroutine RSA
             DS    0F                     Process_PDS
PP_TMEM      DS    F                      ..Total members
PP_NLIBS     DS    F                      ..Number of libraries
PP_FMCOUNT   DS    F                      ..Find-Member count
PP_REGS      EQU   *                      ..Registers
PP_TIOTEL    DS    F                      ..TIOT entry length
PP_TIOTEA    DS    F                      ..TIOT entry address
PP_PDSBUF    DS    2F                     ..PDS Buffer length & addr
PP_PDDN      DS    CL16' '                ..Processing File Name
PP_ADDN      DS    CL8' '                 ..Allocated DDNAME
PP_CCCNT     DS    F                      ..ConCatenation Count
PP_DSUMA     DS    F                      ..Dataset Summary Area
*                                         ..Orphan table
PP_OT        DS    2F                       ..length, address
PP_OTCP      DS    F                        ..Current position
PP_OTLE      DS    F                        ..last entry
*                                         ..Translator Table
PP_TT        DS    2F                       ..length, address
PP_TTLE      DS    F                        ..Last entry
PP_FLAG1     DS    B'00000000'            ..Flag 1
$PP_F1TIOT     EQU B'10000000'            ....TIOT processing?
$PP_F1LNKLST   EQU B'01000000'            ....LNKLST?
$PP_F1LPALST   EQU B'00100000'            ....LPALST?
*
             DS    0F                     Print_Report_Record
PRR_RA       DS    F                      ..Return Address
PRR_PC       DS    F                      ..Page Count
PRR_LC       DS    H                      ..Line Count
PRR_TITLE1   DS    CL133                  ..Title line 1
PRR_TITLE2   DS    CL133                  ..Title line 2
PRR_IHEAD1   DS    CL133                  ..ISPF heading line 1
PRR_IHEAD2   DS    CL133                  ..ISPF heading line 2
PRR_LHEAD1   DS    CL133                  ..Load heading line 1
PRR_LHEAD2   DS    CL133                  ..Load heading line 2
PRR_LHEAD3   DS    CL133                  ..Load heading line 3
               DS    0F                   Read_BKLIDS_File
RBF_PTR        DS    F                    ..Pointer to BKL C.B.
*
** DCB and file work areas
*
             DS    0F
REPORT       DS    XL(C_DCBOL)            Report (DD=REPORT)
ZAPRPT       DS    XL(C_DCBOL)            Report (DD=ZAPRPT)
ECRPT        DS    XL(C_DCBOL)            Report (DD=ECRPT)
COBCRPT      DS    XL(C_DCBOL)            Report (DD=COBCRPT)
SYSMEM       DS    XL(C_DCBML)            Member access
SYSLIB       DS    XL(C_DCBDL)            Directory
WRKFILE1     DS    XL(C_DCBOL)            Work file 1
WRKFILE2     DS    XL(C_DCBOL)            Work file 2
WRKFILE3     DS    XL(C_DCBOL)            Work file 3
             DS    0F                     Process_Load_Module
PLM_RA       DS    F                      ..Return Address
PLM_DECB     DS    XL(C_DECBML)           ..DECB
             DS    0F                     Sort_File
SF_RA        DS    F
A_PDSRCMD    DS    2F                     Addr & length of work area
             DS    0F                     Ensure_Printable_Member
EPM_REGS     DS    2F                     ..Save register area
             DS    0F                     Print_Sysprint_Record
PSR_RA       DS    F                      ..Return Address
PSRAREA      DS    18F                    ..Save Area
SYSPRINT     DS    XL(C_DCBOL)            ..Messages (DD=SYSPRINT)
PSR_PC       DS    F                      ..Page count
PSR_LC       DS    H                      ..Line count
PSR_TITLE    DS    CL133                  ..Title line
             DS    0F
PARMLIST     DS    20F                    Parameter list
DOUBLE       DS    D                      Double word
DOUBLE2      DS    2D                     Double word * 2
             ORG   DOUBLE2
RACF_ENTRYL  DS    X                      ..Entry Length
RACF_ENTRY   DS    CL8                    ..Entry
             ORG   ,
             DS    0F                     Ignore_Vendor_CSECT
IVC_AREA     DS    2F                     ..Area length and address
             DS    0F                     Entry Point:
EP_DA$DATE   DS    F                      ..DA$DATE - Date Routine
EP_DA$MXD    DS    F                      ..DA$MXD  - Hex dump routine
*
** DA#DATE work areas
*
             DS    0F
W_ODGEUR11   DA#DATE DPE,OPREFIX=W_ODGEUR11,OSTR=YES,                  @
               OSTRL=$DA#DATE_ODGEUR11,OTYPE=$DA#DATE_ODGEUR
W_OTIMES8    DA#DATE DPE,OPREFIX=W_OTIMES8,OSTR=YES,                   @
               OSTRL=$DA#DATE_OTIMES8,OTYPE=$DA#DATE_OTIMES
             DS    0F
W_IDJULC7    DA#DATE DPE,OPREFIX=W_IDJULC7,OSTR=YES,OSTRL=4
             DS    0F
EJ_IDJULP4   DA#DATE DPE,OPREFIX=EJ_IDJULP4,OSTR=YES,                  @
               OSTRL=$DA#DATE_IDJULP4
EJ_ODGEUR11A DA#DATE DPE,OPREFIX=EJ_ODGEUR11A,OSTR=YES,OSTRL=4
EJ_ODDOW3A   DA#DATE DPE,OPREFIX=EJ_ODDOW3A,OSTR=YES,OSTRL=4
*
** Fields to zero out for each new PDS
*
*                                         Process_PDS_Directory
             DS    0D
PPD_CLR      EQU   *
PPD_DIRBLKS  DS    F                      ..Directory blocks
PPD_DIRBLKSU DS    F                      ..Directory blocks (Unused)
PPD_RA       DS    F                      ..Process_PDS_Directory
PPD_EOB      DS    F                      ..End of block
PPD_NMEM     DS    F                      ..Number of members
PPD_NEX      DS    F                      ..Number: non-executable
PPD_NNSSTAT  DS    F                      ..Number: No ISPF Stats
PPD_NAPF     DS    F                      ..Number: APF
PPD_NLERR    DS    F                      ..Number: Load Errors
PPD_NALIAS   DS    F                      ..Number: Aliases
PPD_NUMEC    DS    F                      ..Number: Standard Eyecatcher
PPD_NUMCOBCE DS    F                      ..Number: COBOL CICS Error
PPD_NUMZAP   DS    F                      ..Number: Zapped modules
PPD_NUMIVTM  DS    F                      ..Number: Int Vendor tbl mat
PPD_SIZE     DS    F                      ..Total number of bytes/Lines
PPD_IINIT    DS    F                      ..ISPF: Initial lines
PPD_IMODL    DS    F                      ..ISPF: Modified lines
PPD_TRKA     DS    F                      ..Allocated tracks
PPD_ABEND    DS    F                      ..LOAD ABEND
PPD_ABENDR   DS    F                      ..LOAD ABEND reason
PPD_DIRENTL  DS    H                      ..Length of directory entry
PPD_LSYS     DS    XL3                    ..Last system processed
PPD_TTR      DS    XL3                    ..TTR for member access
PPD_FLAG1      DS  B'00000000'            ..Flag 1
$PPD_F1APF     EQU B'10000000'              ..APF library
$PPD_F1ISPF    EQU B'01000000'              ..ISPF type processing?
$PPD_F1LOAD    EQU B'00100000'              ..Load Library
$PPD_F1CHKDUP  EQU B'00010000'              ..Check for duplicates?
$PPD_F1MEMXREF EQU B'00001000'              ..Check for duplicates?
$PPD_F1NEWHEAD EQU B'00000100'              ..Need new heading?
$PPD_F1BLDLF   EQU B'00000010'              ..Need new heading?
$PPD_F1RBF     EQU B'00000001'              ..Read BKLIDS file?
PPD_FLAG2      DS  B'00000000'            ..Flag 2
$PPD_F2SYNAD   EQU B'10000000'              ..SYNAD error on member?
$PPD_F2LOADERR EQU B'01000000'              ..Load error?
$PPD_F2BLKCNT  EQU B'00100000'              ..Just counting blocks?
$PPD_F2NBLINFO EQU B'00010000'              ..Need Binder/LKED info?
*
PPD_CLRL     EQU   *-PPD_CLR
*
PPD_PDS        DS   0H                    ..BLDL area
PPD_PDS_FF     DS   X'00,00'                ..Total number of entries
PPD_PDS_LL     DS   X'00,00'                ..Length of the area
PPD_PDS_ENTRY  DS   XL(#PDSENT)             ..Length of a pds entry
#PDSENT        EQU  PDS2USRD-PDS2           ..-> Length of an entry
PPD_PDS_USERD  DS   CL62                    ..User data
PPD_PDS_ENTRYL EQU  *-PPD_PDS_ENTRY         ..Length of PDS entry
PPD_PDSL       EQU  *-PPD_PDS               ..Length of PDS area
PPD_PODCB      DS   XL(C_DCBPOL)         ..BLDL library
*
** Check for Duplicates
*
             ORG   PPD_CLR                Reuse area
*                                         Check_For Duplicates
CFD_NUM      DS    F                      ..Type
CFD_MEMBER   DS    CL8                    ..Member name
CFD_TYPE     DS    X                      ..Type
CFD_FIRST    DS    X                      ..First time?
             DS    0F                     Areas not in reused area
CFD_RECOUT   DS    XL(SORTRECL)           Previous record
             ORG   ,
*
** Returned data areas
*
WORKAREA     DS    0D
AREAJFCB     DS    XL(JFCBLGTH)           JFCB return area
AREADSCB     DS    CL96                   DSCB return area
AREABLDL     DS    XL(BLDLAL)
SYNADMSG     DS    CL78                   Error message from SYNAD
WORKAREAL    EQU   *-WORKAREA
*
** Flags
*
LASTCC       DS    X                      Last Condition Code
$WARN        EQU   4                      ..Warning
$SEVERE      EQU   20                     ..Severe
MAXCC        DS    X                      Maximum Condition Code
*
** Parse_Parameter_Card
*
                DS    0F
PPC_R1ENTRY     DS    F                   R1 upon entry to DA$PDSR
PPC_FLAG1       DS    B'00000000'         Parse Flag 1
$PPC_F1NODET    EQU   B'10000000'         ..No Detail report records?
$PPC_F1DATONLY  EQU   B'01100000'         ..Data only, no headings?
$PPC_F1NOBREAK  EQU   B'00100000'         ..No break between systems?
$PPC_F1CHKDUP   EQU   B'00001000'         ..Check for Duplicates?
$PPC_F1MEMXREF  EQU   B'00000100'         ..Member Cross Reference?
$PPC_F1SIMULATE EQU   B'00000010'         ..Simulate?
PPC_FLAG2       DS    B'00000000'         Parse Flag 2
$PPC_F2HELP     EQU   B'10000000'         ..Help information wanted?
$PPC_F2LNKLST   EQU   B'01000000'         ..LNKLST?
$PPC_F2LPALST   EQU   B'00100000'         ..LPALST?
$PPC_F2DUMPDSCB EQU   B'00010000'         ..Dump DSCB?
$PPC_F2DUMPBLDL EQU   B'00001000'         ..Dump BLDL results?
$PPC_F2DUMPDIRE EQU   B'00000100'         ..Dump Directory entry?
*-Put all LOADMOD flags in FLAG3 and only LOADMOD flags.
PPC_FLAG3       DS    B'00000000'         Parse Flag 3
$PPC_F3LOADMOD  EQU   B'10000000'         ..LOAD each module?
$PPC_F3ECRPT    EQU   B'11000000'         ..EC report?     Need LOADMOD
$PPC_F3COBCRPT  EQU   B'10100000'         ..COBOL CICS report?
$PPC_F3ZAPRPT   EQU   B'10010000'         ..Zap report?
PPC_FLAG4       DS    B'00000000'         Parse Flag 4
$PPC_F4NTRANID  EQU   B'10000000'         ..No Translator ID convert?
$PPC_F4TRANR    EQU   B'01000000'         ..CSECT Report?
$PPC_F4HISTR    EQU   B'00100000'         ..History Report?
$PPC_F4NOSMS    EQU   B'00010000'         ..Don't use DFSMS/MVS code?
$PPC_F4ONLYF    EQU   B'00001000'         ..Only proccess by FINDMEM?
$PPC_F4TSOVIEW  EQU   B'00000100'         ..TSO viewing (dumps mostly)?
$PPC_F4NOSYSIN  EQU   B'00000010'         ..Don't try to read SYSIN?
$PPC_F4FLATOUT  EQU   B'00000001'         ..Output to //FLATOUT?
PPC_FLAG5       DS    B'00000000'         Parse Flag 5
$PPC_F5IVCSECTS EQU   B'10000000'         ..Ignore Vendor CSECT stats?
$PPC_F5IVCSECTF EQU   B'11000000'         ..Ignore Vendor CSECT full?
$PPC_F5NVENDORL EQU   B'00100000'         ..No vendor list wanted
$PPC_F5NIVENDOR EQU   B'00010000'         ..No internal Vendor Table?
$PPC_F5NOEAGLE  EQU   B'00001000'         ..No Eagle?
$PPC_F5EODC     EQU   B'00000100'         ..Report on EndOfDataCond?
$PPC_F5CALLRACF EQU   B'00000010'         ..Report on EndOfDataCond?
*
PPC_IFLAG1      DS    B'00000000'         Internal Flag 1
$PPC_IF1FMG     EQU   B'10000000'         ..FINDMEM was generic?
$PPC_IF1DATEUS  EQU   B'01000000'         ..Date format: US?
$PPC_IF1DATEISO EQU   B'00100000'         ..Date Format: ISO?
$PPC_IF1DATEERR EQU   B'00010000'         ..Date Format error?
$PPC_IF1DATESET EQU   B'00001000'         ..Date Format set?
*
PPC_DDPL        DS    X                   DDNAME prefix Length
PPC_DDP         DS    CL7                 DDNAME prefix Value
*
PPC_FML         DS    X                   Find member (length)
PPC_FM          DS    CL8                 Find member value
PPC_WUNIT       DS    CL8                 Work unit for sort file
                DS    0H
PPC_LINECNT     DS    H                   Line count for files
PPC_COL         DS    H                   Error column number
PPC_NUM         DS    H                   Number of errors in parm
                DS    0F                  OPEN exit
OX_EXLST        DS    F                   ..EXLST
OX_CODE         DS    F                   ..Abend Code
                DS    0F                  Format_Open_ABEND_MSG
FOAM_RA         DS    F                   ..Return Address
*
** Misc global areas
*
W_BCPLEVEL   DS    XL(L'CVTPRODN)         MVS (BCP) level
W_DFARELS    DS    XL(L'DFARELS)          DFSMS/MVS release level
             DS    0F                     Work
W_FLAG1      DS    B'00000000'            ..Flag 1
$W_F1REPORT  EQU   B'10000000'            ....Report file opened?
$W_F1LRDATE  EQU   B'01000000'            ....Loaded DA$DATE?
$W_F1LRMXD   EQU   B'00100000'            ....Loaded DA$MXD?
$W_F1DFSMS   EQU   B'00010000'            ....DFSMS/MVS?
$W_F1NOSMS   EQU   B'00001000'            ....DFSMS/MVS turned off?
$W_F1LOADLIB EQU   B'00000100'            ....Processed any loadlibs?
$W_F1APFLSTD EQU   B'00000010'            ....Processed any loadlibs?
$W_F1APFDYN  EQU   B'00000001'            ....Found Dynamic APF?
W_FLAG2      DS    B'00000000'            ..Flag 2
$W_F2PDSUM   EQU   B'10000000'            ....Print Dataset Summary?
$W_F2PDSUM1  EQU   B'01000000'            ....Print Dataset Sum: 1st?
             DS    0D
W_AREA       DS    XL512                  ..Work area
             ORG   W_AREA                   ..Reuse area for $PPC
PPC_RC       DS    F                          ..Return code
PPC_BUFFER   DS    2F                         ..Buffer length and addr
PPC_DATEFL   DS    X                          ..Date format Length
PPC_DATEFV   DS    CL3                        ..Date format value
PPC_OPTION   DS    X                          ..Option
PPCSI_FLAG1  DS    B'00000000'                ..Flag 1
$PPCSI_F1OIF EQU   B'10000000'                  ..Opened Input file?
             DS    0H
PPCSI_COL    DS    H                          ..first error column
PPCSI_NUM    DS    H                          ..Number of errors
             DS    0F
PPCSI_DCB    DS    XL(C_DCBIL)                ..DCB for SYSIN
             ORG   ,                        ..End of work area
APF_DYN      DS    2F
             ORG   W_AREA
APF_LRETCODE DS    F
APF_LRSNCODE DS    F
             ORG   ,
             DS    0D                     Make GETMAIN/FREEMAIN Happy
*
** Output record
*
             DS    0D
SORTREC      EQU   *                      Sort record
SR_MEMBER    DS    CL8                    ..Number of library
*
SR_INIT      EQU   *                      ..Initialization area
SR_NLIB      DS    XL2                    ..Number of library
SR_DDNAME    DS    XL16                   ..DDNAME
SR_VOLSER    DS    CL6                    ..Volume Serial
SR_DSN       DS    CL44                   ..DSN
SR_FLAG1     DS    X                      ..PPD_FLAG2 from detail rec
SR_FLAG2     DS    X                      ..PPD_FLAG2 from detail rec
SR_INITL     EQU   *-SORTREC              ..Length to initialize
RECOUT       DS    CL133                  Detail record area
SORTRECL     EQU   *-SORTREC
SLACKR       DS    CL133                  Slack if we get carried away
SLACKR2      DS    CL133                  Even more slack
             DS    0D
WORKDSL      EQU   *-WORKDS
             EJECT ,
***********************************************************************
***
**        Internal DSECTs
***
***********************************************************************
         SPACE 2
*
** Map TRANTAB
*
PPTTR        DSECT ,
PPTTR_FIRST  DS    CL8                    First member
             DS    CL2
PPTTR_LAST   DS    CL8                    Last member
             DS    CL2
PPTTR_COUNT  DS    CL6                    Count
PPTTR_COUNTE EQU   *
PPTTR_UL     EQU   *-PPTTR                Length to underline
             DS    CL2
PPTTR_ID     DS    CL8                    Translator ID
             DS    CL2
             DS    CL2
PPTTR_NAME   EQU   *
PPTTRL       EQU   *-PPTTR                Length of entry
*
** Map Orphan table
*
ORPT         DSECT ,
ORPT_ANAME   DS    CL8
ORPT_ATTR    DS    XL3
ORPT_RNAME   DS    CL8
ORPT_RTTR    DS    XL3
ORPTL        EQU   *-ORPT
*
** Dataset Summary report line definition
*
DSUMH         DSECT ,                     Headers
DSUMH_NAME    DS    C'DSUM'               ..Eyecatcher for dumps
DSUMH_LEN     DS    F                     ..Length of area
DSUMH_CURR    DS    F                     ..Current entry address
DSUMH_I       EQU   *                     ..Init
DSUMH_LLE     DS    F                       ..LNKLST extents
DSUMH_NUM     DS    F                       ..Total number so far
DSUMH_CNTTRKA DS    F                       ..Total tracks allocated
DSUMH_CNTTRKU DS    F                       ..Total tracks used
DSUMH_CNTMEM  DS    F                       ..Total members
DSUMH_IL      EQU   *-DSUMH_I             ..Init length
DSUMHL        EQU   *-DSUMH
*
DSUME         DSECT ,
DSUME_MEMBERS DS    CL6
              DS    C
DSUME_TRKA    DS    CL6
              DS    CL2
DSUME_TRKU    DS    CL6
              DS    C
DSUME_EXTENTS DS    CL2
              DS    C
DSUME_ATTR    DS    CL7
              DS    C
DSUME_DSN     DS    CL44
              DS    C
DSUME_VOL     DS    CL6
              DS    C
DSUME_RECFM   DS    CL3
              DS    C
DSUME_DDNAME  DS    XL(L'PP_PDDN)
DSUMEL        EQU   *-DSUME
*
** Output Detail line
*
DET          DSECT ,
DETMEM       DS    CL8
             DS    CL1
DETALIAS     DS    CL11'SD 12345678'
             DS    CL1
DETADDR      DS    CL7
             DS    CL1
*
DET_L        EQU   *
DET_LSIZE    DS    CL6
             DS    CL1
DET_LTRAN    EQU   *
DET_LTD      EQU   *
DET_LTD_DATE DS    C'06-MAR-1962'
             DS    CL1
DET_LTD_DOW  DS    CL3
DET_LTDL     EQU   *-DET_LTD
             DS    CL1
DET_LSSI     DS    CL8
             DS    CL1
DET_LMULT    EQU   *
DET_LTNAME   DS    CL16
DET_LTNAMEL  EQU   *-DET_LTNAME
             DS    CL1
DET_LMODE    EQU   *
DET_LMODEA   DS    C'ADDR'
             DS    CL1
DET_LMODER   DS    C'RES'
DET_LMODEL   EQU   *-DET_LMODE
             DS    CL1
DET_LCSECT   DS    CL8
             DS    CL1
DET_LATTR    DS    CL16
             DS    CL1
DET_LZAP     DS    CL4
             DS    CL1
DET_LEPA     DS    CL6
             DS    CL1
DET_LCODE    DS    CL4
DET_LMULTL   EQU   *-DET_LMULT
*
             ORG   DET_LMULT
DET_LMULTD   DS    C'|'
             DS    C
DET_LDD      DS    CL16
             DS    C
DET_LVOL     DS    CL6
             DS    C
DET_LDSN     EQU   *
DET_LDSNL    EQU   132-(DET_LDSN-DET)
             ORG   ,
             ORG   DET_L
DET_I        EQU   *
DET_IVER     DS    C'00'
DET_IVMD     DS    C'.'
DET_IMOD     DS    C'00'
DET_IVVMML   EQU   *-DET_IVER
             DS    CL1
DET_ICDATE   DS    C'06-MAR-1962 '
DET_ICDATED  DS    C'DOW'
DET_ICDATEL  EQU   *-DET_ICDATE
             DS    CL1
DET_ILDATE   DS    C'06-MAR-1962 '
DET_ILDATED  DS    C'DOW'
DET_IMULT    EQU   *+1
DET_ILTIME   DS    C' HH:MM'
DET_ILTODL   EQU   *-DET_ILDATE
             DS    CL1
DET_ISIZE    DS    CL6
             DS    CL1
DET_IINIT    DS    CL6
             DS    CL1
DET_IMODL    DS    CL6
             DS    CL1
DET_IUID     DS    CL7
DET_IMULTL   EQU   *-DET_IMULT
DET_IL       EQU   *-DET
             ORG   DET_IMULT
             DS    C
DET_IMULTD   DS    C'|'
             DS    C
DET_IDD      DS    CL16
             DS    CL1
DET_IVOL     DS    CL6
             DS    CL1
DET_IDSN     EQU   *
DET_IDSNL    EQU   132-(DET_IDSN-DET)
             ORG   ,
*
** User Data: ISPF statistics (input)
*
**
UDISPF       DSECT ,
UDISPF_VER   DS    X                     Version
UDISPF_MOD   DS    X                     Modification
             DS    X'00,00'              Not used
UDISPF_CDATE DS    X'00,00,00,00'        Creation Date
UDISPF_LDATE DS    X'00,00,00,00'        Last Updated Date
UDISPF_LTIME DS    X'00,00'              Last Updated time
UDISPF_SIZE  DS    X'00,00'              Current size of member
UDISPF_INIT  DS    X'00,00'              Initial size of member
UDISPF_MODL  DS    X'00,00'              Number of modified lines
UDISPF_UID   DS    CL7                   Userid
*
** BLDL area, See "GC26-4014 Data Adminstration" for more information
*
BLDLA        DSECT ,                     BLDL work area
BLDLA_FF     DS    X'00,00'              ..Total number of entries
BLDLA_LL     DS    X'00,00'              ..Length of the area
BLDLA_NAME   DS    CL8' '                ..Name of module
BLDLA_TTR    DS    X'00,00,00'           ..TTR
BLDLA_K      DS    X'00'                 ..Count
BLDLA_Z      DS    X'00'
BLDLA_C      DS    X'00'
BLDLA_UDATA  DS    CL62' '               ..User Data
BLDLAL       EQU   *-BLDLA               Length of work area
*
** Print Summary Record - Title line
*
PSRT         DSECT ,
PSRT_FBA     DS    C' '
PSRT_PGM     DS    C'DA$PDSR'
             DS    C' '
PSRT_D1      DS    C'--'
             DS    C' '
PSRT_DESC    DS    XL(L'C_PSRTD)
             DS    C' '
PSRT_D2      DS    C'--'
             DS    C' '
PSRT_SIDD    DS    C'SYSID='
PSRT_SID     DS    XL(L'CVTSNAME)
             DS    C' '
PSRT_D3      DS    C'--'
             DS    C' '
PSRT_TIME    DS    C'07:05 PM'
             DS    C' '
PSRT_DATE    DS    C'06-MAR-1990'
             DS    C' '
PSRT_D4      DS    C'--'
             DS    C' '
PSRT_PAGE    DS    C'Page'
*
** IDR Zap entry
*
IDRZAPE        DSECT ,
               DS    X
IDRZAPE_DATE   DS    X'89101F'
IDRZAPE_NAME   EQU   *                   IDRDATA name
*
** COBCRPT output line
*
COBCR          DSECT ,
               DS    X
COBCR_MEMBER   DS    CL8' '
               DS    C
COBCR_ALIAS    DS    C'-A'
               DS    C
COBCR_TYPE     DS    C'VS_COBOL_II'
               DS    CL3
COBCR_ERROR    DS    C'Error:'
               DS    C
COBCR_INFO     EQU   *
         END
         EJECT
***********************************************************************
***
**        Linkage editor cards - ASM.PARM='BATCH,...'
***
***********************************************************************
         SPACE 2
 PUNCH ' ENTRY   DA$PDSR          '       Entry point
 PUNCH ' INCLUDE SYSLMOD(DA$DATE) '       Subroutine: Date routine
 PUNCH ' INCLUDE SYSLMOD(DA$MXD)  '       Subroutine: Mini-Hex-Dump
 PUNCH ' NAME    DA$PDSR(R)       '       Name of load module
         END ,
./ ADD NAME=DA$PDSRR 0100-02191-02191-1109-00657-00657-00000-DALCOCK
/* REXX
 |
 | Name: DA$PDSRR
 |
 | Author: David Alcock
 |         dave@planetmvs.com
 |
 | Written: 13-JAN-1998
 |
 | Purpose: Process the "FLATOUT" file from the DA$PDSR assembler
 |          program.  This exec is intended for use in a batch job
 |          that processes the FLATOUT file created in a previous
 |          job step.  The information in the FLATOUT file is subject
 |          to being out of date. Although this also means that you
 |          could save a "FLATOUT" file as a snapshot for later
 |          comparison.
 |
 | Requirements:
 | - Output from the DA$PDSR assembler program: the sequential (flat)
 |   file cleverly called FLATOUT.
 | - The DISASM option requires an external disassembler, this exec
 |   currently has code for the IBM High Level Assembler Toolkit
 |   disassembler and the one from file 171 of the CBT tape.  Don't
 |   you like my "off the shelf" approach?
 |
 | Sample syntax:
 | - DA$PDSRR                    /* With no options does little now */
 | - DA$PDSRR DISASM AI=STCK     /* Assembler Instruction */
 | - DA$PDSRR DISASM AI=SVC___11 /* Search for "SVC   11" */
 | - DA$PDSRR DISASM MC=0A0B     /* Machine Code */
 | - DA$PDSRR DISASMT=HLASMT     /* override inst. default */
 | - DA$PDSRR DISASMT=CBT171     /* override inst. default */
 | - DA$PDSRR VERBOSE            /* override inst. default */
 |
 | Options:
 | - DISASM   - Invoke the disassembler. You should also supply one
 |              of the other disassembly options like AI=, MC=, etc
 |              so we have something to do.
 |
 |              As with all disassemblers, on any platform, they have
 |              some intelligence to figure out of in-line data. There
 |              is always a chance that a computer instruction could
 |              be missed.
 |
 |              The disassembler should be available in the LPA/LNKLST
 |              JOBLIB or STEPLIB...
 |
 | - DISASMT= - Override the installation default for the disassembler
 |              to invoke.  Currently "HLASMT" or "CBT171".
 |
 | - AI=xxx   - Assembler Instruction to search for in the disassembly
 |              listing.  You can put as many AI= parms as is needed
 |              but they do not take multiple args.
 |
 |              To search for complete assembler instructions, use an
 |              underscore where you want a space.  Since the CBT171
 |              disassembler doesn't use "standard" spacing you have
 |              to use different search strings for the two
 |              disassemblers.  Some examples for the TIME SVC:
 |
 |              - HLASMT disassembler: AI=SVC___11_
 |              - CBT171 disassembler: AI=SVC____11_
 |
 |                Note: Apply the trailing "_" to ensure that in the
 |                      example above, you don't trap "SVC   119".
 |
 | - MC=xxx   - Machine Code to search for in the disassembly listing.
 |              You can put as many MC= parms as is needed but they do
 |              not take multiple args.
 |
 |              When compared, the machine code from the disassembly has
 |              the spaces removed. So to search for "58E4 0004",
 |              specify "MC=58E40004".
 | - VERBOSE  - Be a Chatty Kathy
 */

xdate = translate(date(),'-',' ')
xtime = time()
say "%DA$PDSRR - Starting execution on "xdate" at "xtime
say " "

/*---------------------------------------------------------------------
 | Installation defaults
 ------------------------------------------------------------------- */

workunit = "SYSDA"       /* Unit name for work files */
sysallda = "SYSALLDA"    /* Unit to get to every load library */

disasm_dtype = "CBT171"  /* Set default disassembler */
disasm_brc  = 0          /* Number of bad RCs           */
disasm_mbrc = 2          /* Max number of bad RCs       */
xlibs.0 = 0

/*---------------------------------------------------------------------
 | Global vars that are not installation or user specified
 ------------------------------------------------------------------- */

xrc = 0            /* exit return code */
dsname = ""        /* No SYSLIB allocated as yet */
hlasm_type = ""    /* not set yet */

/*---------------------------------------------------------------------
 | Check out the options
 ------------------------------------------------------------------- */

arg options

opt_debug  = 0            /* debug = no */
opt_disasm = 0            /* disasm = no */
opt_verbose = 0           /* verbose = no */
opt_echo    = 0           /* echo (disassembly output) = no */
disasm_mc = ""            /* machine code to search for */
disasm_ai = ""            /* assembler instructions to search for */

do i = 1 to words(options)

   select
     when word(options,i) == "DISASM"   then opt_disasm = 1
     when word(options,i) == "DEBUG"    then opt_debug = 1
     when word(options,i) == "VERBOSE"  then opt_verbose = 1
     when word(options,i) == "ECHO"     then opt_echo = 1

     when substr(word(options,i),1,8)  == "DISASMT=" then do
          parse value word(options,i) with "DISASMT=" instr
          disasm_type = instr
          opt_disasm = 1 /* assume they want a disassembly */
          end

     when substr(word(options,i),1,3)  == "AI=" then do
          parse value word(options,i) with "AI=" instr
          disasm_ai = disasm_ai" "instr
          end

     when substr(word(options,i),1,3)  == "MC=" then do
          parse value word(options,i) with "MC=" instr
          disasm_mc = disasm_mc" "instr
          end

     otherwise
          say "%DA$PDSR - Unknown option was bypassed:" ,
              word(options,i)
     end /* of select */

   end /* of "do i = 1 to words(options)" */

/*---------------------------------------------------------------------
 | Disassembly initializations
 ------------------------------------------------------------------- */

if opt_disasm <> 1 then signal disasmx  /* avoid long DO...END */

/*
 | Verify and set the disassembler type
 */

if disasm_type == "" then disasm_type = hlasm_dtype

select
  when disasm_type == "HLASMT" then do
       disasm_ldd  = "SYSLIB"
       disasm_mc = "" /* HLASMT doesn't give us machine code */
       end
  when disasm_type == "CBT171" then do
       disasm_ldd  = "DISMOD"
       end
  otherwise
     say "%DA$PDSRR - The disassembler type is unrecognized, we" ,
         "support:"
     say "            - HLASMT ... High Level Assembler Toolkit"
     say "            - CBT171 ... From the CBT tape, file 171"
     say "%DA$PDSRR - Terminating without processing FLATIN"
     xrc = 8
     signal theend
  end /* of select */

/*
 | Ensure that we have something to search for in the Disassembly
 | listing.
 */

select
  when disasm_ai <> "" then nop
  when disasm_mc <> "" then nop
  otherwise
     say "%DA$PDSRR - You specified option DISASM but did not" ,
         "provide either:"
     say "            - AI=xxx ... Assembler Instructions"
     say "            - MC=xxx ... Machine Code"
     say "%DA$PDSRR - Hint: The High Level Assembler Toolkit doesn't"
     say "            give us machine code along with the assembler"
     say "            code so you can only supply assembler" ,
                      "instructions."
     say " "
     say "%DA$PDSRR - Terminating without processing FLATIN"
     xrc = 8
     signal theend
  end /* of select */

/*
 | Inform the user what we are planning to do
 */

say "%DA$PDSRR - Will invoke the "disasm_type" disassembler" ,
    "and search for:"
if disasm_mc <> "" then ,
   say "          - Machine Codes:" disasm_mc
if disasm_ai <> "" then ,
   say "          - Assembler Instructions:" disasm_ai

disasmx:
/*---------------------------------------------------------------------
 | Map offset and lengths of fields in the input FLATIN record
 ------------------------------------------------------------------- */

/*
 | These REXX statements created by program DA$ADATA
 | > assembly on 19-MAY-1997 at 06.56 PM
 | > output created on 31-JAN-1998 at 03:40 PM
 */
o_$FORTYPE_C = 195      /* x'000000C3' */
l_$FORTYPE_C = 1
o_$FORTYPE_D = 196      /* x'000000C4' */
l_$FORTYPE_D = 1
o_DUMMY = 0        /* x'00000000' */
l_DUMMY = 1
o_FOM = 0        /* x'00000000' */
l_FOM = 1
o_FOM_EC = 0        /* x'00000000' */
l_FOM_EC = 8
o_FOM_RDW = 8        /* x'00000008' */
l_FOM_RDW = 4
o_FOM_RECORD = 12       /* x'0000000C' */
l_FOM_RECORD = 1
o_FOR = 0        /* x'00000000' */
l_FOR = 1
o_FOR_LIBN = 2        /* x'00000002' */
l_FOR_LIBN = 3
o_FOR_SPACE1 = 1        /* x'00000001' */
l_FOR_SPACE1 = 1
o_FOR_SPACE2 = 5        /* x'00000005' */
l_FOR_SPACE2 = 1
o_FOR_START = 6        /* x'00000006' */
l_FOR_START = 1
o_FOR_TYPE = 0        /* x'00000000' */
l_FOR_TYPE = 1
o_FORC = 6        /* x'00000006' */
l_FORC = 1
o_FORC_CSECT256 = 84       /* x'00000054' */
l_FORC_CSECT256 = 256
o_FORC_OCL = 6        /* x'00000006' */
l_FORC_OCL = 77
o_FORC_SPACE1 = 83       /* x'00000053' */
l_FORC_SPACE1 = 1
o_FORCL = 340      /* x'00000154' */
l_FORCL = 1
o_FORD = 6        /* x'00000006' */
l_FORD = 1
o_FORD_DSN = 13       /* x'0000000D' */
l_FORD_DSN = 44
o_FORD_SPACE1 = 12       /* x'0000000C' */
l_FORD_SPACE1 = 1
o_FORD_VOL = 6        /* x'00000006' */
l_FORD_VOL = 6
o_FORDL = 57       /* x'00000039' */
l_FORDL = 1
o_IDL_PID_ID = 0        /* x'00000000' */
l_IDL_PID_ID = 10
o_OCL = 0        /* x'00000000' */
l_OCL = 1
o_OCL_ALIAS = 9        /* x'00000009' */
l_OCL_ALIAS = 2
o_OCL_CSECT = 12       /* x'0000000C' */
l_OCL_CSECT = 10
o_OCL_LENGTH = 32       /* x'00000020' */
l_OCL_LENGTH = 8
o_OCL_MEMBER = 1        /* x'00000001' */
l_OCL_MEMBER = 8
o_OCL_OFFSET = 23       /* x'00000017' */
l_OCL_OFFSET = 8
o_OCL_TRAN = 41       /* x'00000029' */
l_OCL_TRAN = 1
o_OCL_TRANDATE = 41       /* x'00000029' */
l_OCL_TRANDATE = 11
o_OCL_TRANDOT = 66       /* x'00000042' */
l_OCL_TRANDOT = 1
o_OCL_TRANID = 53       /* x'00000035' */
l_OCL_TRANID = 10
o_OCL_TRANL = 37       /* x'00000025' */
l_OCL_TRANL = 1
o_OCL_TRANMOD = 67       /* x'00000043' */
l_OCL_TRANMOD = 2
o_OCL_TRANNAME = 70       /* x'00000046' */
l_OCL_TRANNAME = 8
o_OCL_TRANVER = 64       /* x'00000040' */
l_OCL_TRANVER = 2
o_OCL_VARIABLE = 41       /* x'00000029' */
l_OCL_VARIABLE = 1
o_OCLL = 78       /* x'0000004E' */
l_OCLL = 1
o_OCLSL = 78       /* x'0000004E' */
l_OCLSL = 1
o_TRANT_NAME = 10       /* x'0000000A' */
l_TRANT_NAME = 8

/*---------------------------------------------------------------------
 | Read the FLATIN file
 ------------------------------------------------------------------- */

"EXECIO * DISKR FLATIN (FINIS STEM flatin."

say " "

do f = 1 to flatin.0

   rtype = substr(flatin.f,o_FOR_TYPE+1,1)

   select
     when rtype == "M" then iterate
     when rtype == "D" then call flatout_dataset
     when rtype == "C" then call flatout_csect
     otherwise
          say "%DA$PDSRR - Unknown input //FLATOUT record, seq="f ,
              "record type="rtype
          say "          - Record:" left(flatin.f,80)
   end

   end /* of "do f = 1 to flatin.0" */

if dsname <> "" then "FREE DA("dsname")"

/*---------------------------------------------------------------------
 | Produce a summary of what we saw before going
 ------------------------------------------------------------------- */

say " "
say left("-",80,"-")
say left("-",80,"-")
say left("-",80,"-")
say " "
say " "
say "%DA$PDSRR -                         S u m m a r y"
say " "
do i = 1 to xlibs.0
   sdsn = word(xlibs.i,1)
   svol = word(xlibs.i,2)
   say " "
   say "DSNAME:" left(sdsn,44) "Volume:" svol
   say " "
   if disasm_fmem.i <> "" then do
      say "  Search string matches:"
      say " "
      k = words(disasm_fmem.i) / 2
      do j = 1 to k by 2
         say "    Member="left(word(disasm_fmem.i,j),8) ,
             " CSECT="word(disasm_fmem.i,j+1)
         end
      end
   end

signal theend

/*---------------------------------------------------------------------
 | Flatout record type is Dataset
 ------------------------------------------------------------------- */

flatout_dataset:

say " "
say left("-",80,"-")

address TSO
if dsname <> "" then "FREE DA("dsname")"

dsname = "'"strip(substr(flatin.f,o_FORD_DSN+1,l_FORD_DSN))"'"
volume = strip(substr(flatin.f,o_FORD_VOL+1,l_FORD_VOL))
libn   = strip(substr(flatin.f,o_FOR_LIBN+1,l_FOR_LIBN))

x = xlibs.0
x = x + 1
xlibs.0 = x
xlibs.x = dsname volume
disasm_fmem.x = ""
disasm_fmemc.x = 0

say "%DA$PDSRR - Processing members for DSN="dsname "on volume="volume

if opt_disasm == 1 then do
   "ALLOCATE FILE("disasm_ldd") DA("dsname") SHR REUSE" ,
   "         UNIT("sysallda") VOLUME("volume")"
   darc = rc
   if darc <> 0 then do
      say "%DA$PDSRR - Allocation of load library failed, rc="darc
      dsname = ""
      end
   end

return

/*---------------------------------------------------------------------
 | Flatout record type is CSECT
 ------------------------------------------------------------------- */

flatout_CSECT:

ocl = substr(flatin.f,o_FORC_OCL+1,l_FORC_OCL)
member = substr(ocl,o_OCL_MEMBER,l_OCL_MEMBER)
csect  = substr(ocl,o_OCL_CSECT,l_OCL_CSECT)

if opt_disasm == 1 then do
   select
     when disasm_type == "HLASMT" then call invoke_hlasmt_disasm
     when disasm_type == "CBT171" then call invoke_cbt171_disasm
     otherwise
       nop /* should not happen as type has already been verified */
       end
   end

return

/*---------------------------------------------------------------------
 | Invoke the "High Level Assembler" disassembler
 |
 | Input: vars "member" and "csect" have our victims names
 ------------------------------------------------------------------- */

invoke_hlasmt_disasm:

if dsname == "" then return   /* no dataset, no way */

say "%DA$PDSRR - Calling the disassembler for member="member ,
    "CSECT="csect
address TSO
"NEWSTACK"
queue member csect
queue ""
"EXECIO * DISKW SYSIN (FINIS"
"DELSTACK"

hlasmt_parm = "COPYRIGHTOK"           /* Disassembler parameter      */
address ATTCHMVS "ASMDASM" hlasmt_parm
disasm_rc = rc
if disasm_rc <> 0 | opt_verbose == 1 then ,
   say "%DA$PDSRR - Disassembler RC="disasm_rc "for" member csect

"EXECIO * DISKR SYSPRINT (FINIS STEM sysprint."
if disasm_rc == 0 then do

   found_code = 0

   do i = 1 to sysprint.0
      if found_code == 1 then do

         if disasm_ai <> "" then do
            do j = 1 to words(disasm_ai)
               tai = word(disasm_ai,j)
               ai = translate(tai,' ','_')
               ail = length(ai)
               if ai == substr(sysprint.i,11,ail) then do
                  say "%DA$PDSRR - Found assembler instruction: "ai
                  if opt_verbose == 1 then do
                     say substr(sysprint.i,2,length(sysprint.i)-1)
                     say " "
                     end
                  call update_found_list
                  end
               end
            end

         iterate
         end

      if substr(sysprint.i,11,5) == "CSECT" then do
         found_code = 1
         end

      end

   end
else do
     if disasm_rc > 12 then disasm_brc = disasm_brc + 1
     if disasm_rc < 0  then disasm_brc = disasm_brc + 1

     if disasm_brc > disasm_mbrc then do
        say " "
        say "%DA$PDSRR - Hit max number of disassembler bad return" ,
            "codes, terminating exec"
        xrc = 12
        signal theend
        end

     end

if opt_echo == 1 then do
   outdd = "ECHO"random()
   "allocate file("outdd")" ,
             "sysout(X) lrecl(137) blksize(1410) recfm(V B A)"
   arc = rc
   if arc <> 0 then say "%DA$PDSRR - allocate of DD="outdd "failed"
   "NEWSTACK"
   found_code = 0
   do i = 1 to sysprint.0
      if substr(sysprint.i,11,5) == "CSECT" then found_code = 1
      if found_code == 1 then queue sysprint.i
      end
   "EXECIO * DISKW "outdd" (FINIS"
   "DELSTACK"
   end
say " "
return

/*---------------------------------------------------------------------
 | Invoke the "CBT tape, file 171" disassembler
 |
 | Input: vars "member" and "csect" have our victims names
 ------------------------------------------------------------------- */

invoke_cbt171_disasm:

if dsname == "" then return   /* no dataset, no way */
say "%DA$PDSRR - Calling the disassembler for member="member ,
    "CSECT="csect

address TSO
"NEWSTACK"
queue "LINES    55"
queue "MODULE   "member
queue "CSECT    "csect
queue ""
"EXECIO * DISKW DISIN (FINIS"
"DELSTACK"

address ATTCHPGM DISASM
disasm_rc = rc
if disasm_rc <> 0 | opt_verbose == 1 then ,
   say "%DA$PDSRR - Disassembler RC="disasm_rc "for" member csect

"EXECIO * DISKR DISPRINT (FINIS STEM disprint."
if disasm_rc == 0 then do

   found_code = 0

   do i = 1 to disprint.0
      if found_code == 1 then do
         if substr(disprint.i,2,1) == " " then iterate
         if substr(disprint.i,2,1) == "DISASM" then iterate

         if disasm_mc <> "" then do
            do j = 1 to words(disasm_mc)
               imc = strip(word(disasm_mc,j))
               imcl = length(imc)
               fmc = strip(substr(disprint.i,12,14),'B')
               if imc == substr(fmc,1,imcl) then do
                  say "%DA$PDSRR - Found machine code requested: "imc
                  if opt_verbose == 1 then do
                     say substr(disprint.i,2,length(disprint.i)-1)
                     say " "
                     end
                  call update_found_list
                  end
               end
            end

         if disasm_ai <> "" then do
            do j = 1 to words(disasm_ai)
               tai = word(disasm_ai,j)
               ai = translate(tai,' ','_')
               ail = length(ai)
               if ai == substr(disprint.i,40,ail) then do
                  say "%DA$PDSRR - Found assembler instruction: "ai
                  if opt_verbose == 1 then do
                     say substr(disprint.i,2,length(disprint.i)-1)
                     say " "
                     end
                  call update_found_list
                  end
               end
            end

         iterate
         end

      if substr(disprint.i,4,4) == "DISP" then do
         found_code = 1
         end

      end

   end
else do
     if disasm_rc > 12 then disasm_brc = disasm_brc + 1
     if disasm_rc < 0  then disasm_brc = disasm_brc + 1

     if disasm_brc > disasm_mbrc then do
        say " "
        say "%DA$PDSRR - Hit max number of disassembler bad return" ,
            "codes, terminating exec"
        xrc = 12
        signal theend
        end

     end


if opt_echo == 1 then do
   outdd = "ECHO"random()
   "allocate file("outdd")"  ,
             "sysout(X) lrecl(137) blksize(1410) recfm(V B A)"
   "NEWSTACK"
   found_code = 0
   do i = 1 to disprint.0
      if substr(disprint.i,4,4) == "DISP" then found_code = 1
      if found_code then queue disprint.i
      end
   "EXECIO * DISKW "outdd" (FINIS"
   "DELSTACK"
   end

say " "
return

/*---------------------------------------------------------------------
 | Update found list - input vars: member csect
 |
 | For the current expectations of this exec, we just save a short
 | list of matchs we found and not detailed information so we try
 | to eliminate duplicates.
 ------------------------------------------------------------------- */

update_found_list:

x = xlibs.0
z = words(disasm_fmem.x) / 2
tmem = strip(member)
do y = 1 to z by 2
   mem = strip(word(disasm_fmem.x,y))
   if mem == tmem then return
   end
disasm_fmem.x = disasm_fmem.x member csect

return
/*---------------------------------------------------------------------
 | Normal exit from the DA$PDSRR rexx exec
 ------------------------------------------------------------------- */

theend:

xdate = translate(date(),'-',' ')
xtime = time()
say " "
say "%DA$PDSRR - Ending execution on "xdate" at "xtime "RC="xrc
exit xrc

/* | ---------EEEEEEEE---------NN-----NN---------DDDDDDD--------- |
   | ---------EE---------------NNNN---NN---------DD----DD-------- |
   | ---------EEEEE------------NN-NN--NN---------DD----DD-------- |
   | ---------EE---------------NN---NNNN---------DD----DD-------- |
   | ---------EEEEEEEE---------NN----NNN---------DDDDDDD--------- | */
./ ADD NAME=DA$PDSRT 0100-01266-01266-1821-00163-00163-00000-DAVE
/* REXX
 |
 | Name: DA$PDSRT
 |
 | Author: David Alcock
 |
 | Purpose: Read the DA$PDSR //FLATOUT file, and generate relinks
 |          JCL when a csect match is found
 |
 | Requirements: Output from the DA$PDSR program and the availablity
 |               of the PDS command from the CBT tape
 |
 | Disclaimer: This exec is FREEWARE.  Use at your own risk.  It
 |             is provided for your enjoyment and neither David
 |             Alcock or his employer provides any warranty for it's
 |             use.  I'd like to hear how it works on your system.
 |
 |             This software is not in the public domain but is
 |             available free of charge and with source code
 |             provided.  It is copyright 2001+ by David Alcock
 |             All rights reserved.
 */

/*---------------------------------------------------------------------
 | Validate input parameters
 ------------------------------------------------------------------- */

arg rcsect rlib rmem
if rcsect == "" then do
   say "%DA$PDSRT - Replacing CSECT value not given, terminating"
   exit 12
   end
if rlib   == "" then do
   say "%DA$PDSRT - Replacing library value not given, terminating"
   exit 12
   end
if rmem == "" then do
   say "%DA$PDSRT - Replacing member value not given, terminating"
   exit 12
   end
rcsect = strip(rcsect)
rlib   = strip(rlib)
rmem   = strip(rmem)

address TSO

"NEWSTACK"

/*---------------------------------------------------------------------
 | If the user has given us some jobcard lines, add them at the front
 ------------------------------------------------------------------- */

"EXECIO * DISKR JOBCARD (FINIS STEM jobcard."

do i = 1 to jobcard.0
   line = strip(jobcard.i,'L')
   queue line
   end

/*---------------------------------------------------------------------
 | Read the //FLATOUT file from DA$PDSR and process entries
 ------------------------------------------------------------------- */

"EXECIO * DISKR SYSUT1 (FINIS STEM sysut1_file."

ldsn = ""
lvol = ""
stepnum = 0
compt = 0
compn = 0

do i = 1 to sysut1_file.0
   select
     when word(sysut1_file.i,1) == "D" then do
          lvol = word(sysut1_file.i,3)
          ldsn = word(sysut1_file.i,4)
          say "Found new library:" ldsn "on" lvol
          end
     when word(sysut1_file.i,1) == "C" then do
          lmem = word(sysut1_file.i,3)
          lcsect = strip(word(sysut1_file.i,4))
          say "Comparing CSECTS: '"rcsect"' with '"lcsect"'"
          if rcsect = lcsect then do

             compn = compn + 1
             if compn == 20 then do
                compn = 0
                compt = compt + 1
                queue "//*"
                queue "//** Compress the library"
                queue "//*"
                queue "//COMP"left(compt,4) "EXEC PGM=IEBCOPY"
                queue "//SYSPRINT DD SYSOUT=*"
                queue "//PDS      DD DISP=SHR,DSN="ldsn
                queue "//SYSIN    DD *"
                queue " COPY INDD=PDS,OUTDD=PDS"
                queue "/*"
                end

             x = outtrap("XMSG.","*")
             address TSO "PDSE '"ldsn"' VOLUME("lvol")" ,
                         "MAP "lmem" RELINK"
             x = outtrap("off")
             if xmsg.0 = 0 then  do
                say "!!! no pdse output found for" lmem
                iterate
                end
             else say "Found match! calling the freeware PDS command"

             do j = 1 to xmsg.0
                if strip(xmsg.j) == "" then iterate
                if substr(xmsg.j,1,2) == "**" then iterate
                if substr(xmsg.j,1,8) == "//SYSLIB" then do
                   queue "//NEWLIB   DD  DISP=SHR,DSN="rlib
                   end
                if substr(xmsg.j,1,7) == "//LKED " then do
                   stepnum = stepnum + 1
                   queue "//*"
                   queue "//** New relink: "lmem
                   queue "//*"
                   queue "//LKED"stepnum"   EXEC  PGM=IEWL,"
                   iterate
                   end

                queue xmsg.j

                if substr(xmsg.j,1,8) == "//SYSLIN" then do
                   queue " INCLUDE NEWLIB("rmem")"
                   end

                end
             end
          end
     otherwise
          say "Skipping unhandled record for type: " ,
              word(sysut1_file.i,1)
          end
   end


/*---------------------------------------------------------------------
 | Add a step to display that we actually did replace the CSECT
 ------------------------------------------------------------------- */

queue "//*"
queue "//** Look in the //TRANRPT to ensure that CSECT "rcsect
queue "//** has the correct date"
queue "//*"
queue "//REPORT   EXEC PGM=DA$PDSR,TIME=1439,"
queue "//         PARM='TRANRPT,DATE=ISO'"
queue "//SYSPRINT DD SYSOUT=*"
queue "//REPORT   DD SYSOUT=*"
queue "//TRANRPT  DD SYSOUT=*"
queue "//BINDEROU DD DUMMY"
queue "//BINDERPR DD DUMMY"
queue "//SYSLIB01 DD DISP=SHR,DSN="ldsn

/*---------------------------------------------------------------------
 | Finish things up and leave
 ------------------------------------------------------------------- */
queue ''      /* add null line to indicate End-Of-File */
address TSO "EXECIO * DISKW SYSUT2 (FINIS"
address TSO "DELSTACK"
./ ADD NAME=DA$SPF2D 0100-01266-01266-1821-00889-00889-00000-DAVE
***********************************************************************
***                                                                 ***
** Name: DA$SPF2D                                                    **
**                                                                   **
** Author = David Alcock :: dave@planetmvs.com
**                                                                   **
** Date: 03-JAN-1985                                                 **
**                                                                   **
** Attributes: Non-Reentrant, Non-Reusable, Non-Authorized           **
**                                                                   **
** Purpose: This program reads an ISPF panel source (non-CUA) and    **
**          *attempts* to convert it to 3270 data stream.  The       **
**          output is an complete assembler program that includes:   **
**                                                                   **
**            - Code to display the 3270 screen on a TSO terminal    **
**            - The 3270 screen in Assembler format                  **
**                                                                   **
**          Once the program is run and an ISPF panel has been       **
**          converted to 3270 data stream.  You should call the      **
**          program on TSO to verify that it looks correct.  You     **
**          can then copy the contents between SCRN1 and SCRN1L for  **
**          use in your assembler program for the generated 3270     **
**          code.                                                    **
**                                                                   **
**                                                                   **
** Warning:  : This program *assumes* (yes ASSUMES) that the input   **
**             ISPF panel has been thoughly debugged and verified    **
**             in ISPF 7.2.                                          **
**                                                                   **
**             This program isn't meant to convert every kind of     **
**             ISPF panel.  It is intended to be used by those       **
**             who want to prototype a 3270 datastream via ISPF.     **
**             I use it mainly for new non-SNA USS screens. Other    **
**             types of text screens like help screens would also    **
**             be ideal for prototyping in ISPF and then converted.  **
**                                                                   **
**             It doesn't attempt to exploit the all of the          **
**             features of the ")INIT", ")ATTR", and ")PROC"         **
**             sections.                                             **
*
* Disclaimer: This program is FREEWARE.  Use at your own risk.  It
*             is provided for your enjoyment and neither David
*             Alcock or his employer provides any warranty for it's
*             use.  I'd like to hear how it works on your system.
*
*             This software is not in the public domain but is
*             available free of charge and with source code
*             provided.  It is copyright 2001+ by David Alcock
*             All rights reserved.
*
** Regrets: If I was starting to write this today, it would have     **
**          been written in REXX - David Alcock                      **
**                                                                   **
** Non-IBM assembler MACROs:                                         **
** o DA#ENTER...Entry housekeeping                                   **
** o DA#LEAVE...Termination housekeeping                             **
** o DA#EYEC....Build standard O/S module eyecatcher                 **
**              (invoked by the DA#ENTER)                            **
** o DA#REGS....Define registers (invoked by DA#ENTER)               **
**                                                                   **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**                                                                   **
** Sample JCL:
**
**       //SPF2DS   EXEC PGM=DA$SPF2D                                **
**       //STEPLIB  DD DISP=SHR,DSN=MY.STEPLIB                       **
**  IN:  //SYSUT1   DD DISP=SHR,DSN=MY.ISPPLIB(NEWUSS)               **
**  OUT: //SYSUT2   DD DISP=SHR,DSN=MY.PDS.ASM(NEWUSS)               **
**       //SYSPRINT DD SYSOUT=*                                      **
***                                                                 ***
***********************************************************************
 SPACE 2
&DAVER   SETC  '1.3'
***********************************************************************
***                                                                 ***
**           M o d i f i c a t i o n   H i s t o r y                 **
**                                                                   **
** Person     Date        Description                                **
** ---------- ----------- ------------------------------------------ **
** DGAlcock   30-NOV-1996 1.3 Renamed to DA$SPF2D;
** DGAlcock   27-JUN-1995 1.2 Fix S0C4 (Parse_Label needed to save
**                        regs); Some spagetti-logic refined; Put
**                        debugging output to SYSPRINT;
** DGAlcock   19-JUN-1995 1.1 Misc changes for lower case support;
** DGAlcock   03-JAN-1985 1.0 Initial program created;
***
***********************************************************************
         EJECT ,
*
** Define local macro INITFLD
*
 MACRO ,
 INITFLD  &NAME,&VALUE
 MVI &NAME,&VALUE
 MVC &NAME+1(L'&NAME.-1),&NAME
 MEND ,
         EJECT
***********************************************************************
***
**   Module start
***
***********************************************************************
         SPACE 2
DA$SPF2D DA#ENTER 'V&DAVER Utility: Convert ISPF panel to 3270 D.S.',  @
               RENT=YES,LV=DSAL,BASE=(12,11,10)
         USING DSA,R13           ADDRESSABILITY TO WORK AREA
*
** Initialize areas and open files
*
         MVI   X_FLAG1,0                 INITIALIZE EXECUTION FLAG
         XC    LINECTR(4),LINECTR        INITIALIZE LINE COUNTER
         MVC   ATTRTAB(ATMASKL),ATMASK   INITIALIZE ATTRIBUTE TABLE
*
         OPEN  (SYSUT1,(INPUT))
         OPEN  (SYSUT2,(OUTPUT))
         OPEN  (SYSPRINT,(OUTPUT))
*
** Someone with a little ambition could do something like parse
** PARM='NAME=screennme' or do a RDJFCB and get the input
** member name (if any).  I'll just put something boring like
** "SCRN1" by default.
*
         MVC   SCRNNAME(8),=CL8'SCRN1'
*
** Print "Execution begins" message on SYSPRINT
*
         INITFLD LINEOUT,C' '
         MVC   LINEOUT+1(18),=C'Start of execution'
         MVC   LINEOUT+1+18+1(L'DA$SPF2D_ECNAME),DA$SPF2D_ECNAME
         LA    R15,LINEOUT+1+18+1+L'DA$SPF2D_ECNAME+1
         MVC   0(10,R15),=C'Assembled:'
         LA    R15,11(R15)
#ECTODL  EQU   L'DA$SPF2D_ECDATE+L'DA$SPF2D_ECTIME
         MVC   0(#ECTODL,R15),DA$SPF2D_ECDATE
         PUT   SYSPRINT,LINEOUT
         INITFLD LINEOUT,C' '
         PUT   SYSPRINT,LINEOUT
         EJECT
***********************************************************************
***                                                                 ***
**       Read input ISPF panel records (ISPPLIB)                     **
***                                                                 ***
***********************************************************************
         SPACE 2
GETREC   EQU   *
         GET   SYSUT1
         LR    R2,R1                     SAve address of input record
         INITFLD LINEOUT,C' '            Initialize
         MVC   LINEOUT+12(80),0(R2)      Put input record on output
         MVI   LINEOUT+10,C'>'           Indicate it
*
         CLI   X_TYPE,$XT_END            Hit the END?
         BE    GR$SKIP                   Yes, ignore the rest
*
** Check for section types
*
         CLI   0(R2),C')'                Hit a new section?
         BNE   GR$CSX
         MVC   LINEOUT+1(7),=C'Section'
         MVC   DOUBLE(4),1(R2)           Get "xxxx" from ")xxxx"
         OC    DOUBLE(4),=CL4' '         Convert to uppercase
*
         CLC   DOUBLE(4),=C'ATTR'
         BNE   GR$CS$ATTRX
         MVI   X_TYPE,$XT_ATTR
* Note: could parse for "default(???)" here
         B     GETRECB
GR$CS$ATTRX DS 0H
         CLC   DOUBLE(4),=C'BODY'
         BNE   GR$CS$BODYX
         MVI   X_TYPE,$XT_BODY
         B     GETRECB
GR$CS$BODYX DS 0H
         CLC   DOUBLE(4),=C'PROC'
         BNE   GR$CS$PROCX
         MVI   X_TYPE,$XT_PROC
         B     GETRECB
GR$CS$PROCX DS 0H
         CLC   DOUBLE(4),=C'END '
         BNE   GR$CS$ENDX
         MVI   X_TYPE,$XT_END
         B     GETRECB
GR$CS$ENDX DS 0H
         MVI   X_TYPE,$XT_SKIP           Other kind we don't care about
         B     GETRECB
GR$CSX   EQU   *
*
** Process this input record by section type
*
         CLI   X_TYPE,$XT_PROC
         BE    GR$PROC
         CLI   X_TYPE,$XT_SKIP
         BE    GR$SKIP
         CLI   X_TYPE,$XT_BODY
         BE    BODY
         CLI   X_TYPE,$XT_ATTR
         BE    GR$ATTR
         MVI   X_TYPE,$XT_BODY           < WE ONLY REACH THIS POINT IF
         B     BODY                      < THERE IS NO )ATTR SECTION
GR$SKIP  EQU   *
         MVC   LINEOUT+1(7),=C'Skipped'
         B     GETRECB
GR$PROC  EQU   *
         MVC   LINEOUT+1(4),=C'Proc'
         B     GETRECB
GR$INIT  EQU   *
         MVC   LINEOUT+1(4),=C'Init'
         B     GETRECB
GR$ATTR  EQU   *
         MVC   LINEOUT+1(4),=C'Attr'
* Note: could parse "? TYPE(type) COLOR(colour)" here...
         B     GETRECB
*
** Bump to next record - print SYSPRINT first though
*
GETRECB  EQU   *
         PUT   SYSPRINT,LINEOUT          Print record
         B     GETREC
EOF      EQU   *
         EJECT
***********************************************************************
***                                                                 ***
**       Termination                                                 **
***                                                                 ***
***********************************************************************
         SPACE 2
EXIT     EQU   *
         INITFLD RECOUT,C' '                  -------|
         MVC   LABEL(7),SCRNNAME                     |  PRINT
         LA    R14,7                                 |  ENDING
         LA    R15,LABEL                             |  LABEL
ENDLOOP  EQU   *                                     |  WITH
         CLI   0(R15),X'40'                          |  LENGTH
         BE    ENDLOOPX                              |  OF
         LA    R15,1(R15)                            |  SCREEN
         BCT   R14,ENDLOOP                           |  GENERATED
ENDLOOPX EQU   *                                     |  AS
         MVI   0(R15),C'L'                           |  SCREEN-
         MVC   OPER(3),EQU                           |  NAME
         MVC   DATA(2),=C'*-'                        |  PLUS
         MVC   DATA+2(7),SCRNNAME                    |  "L"
         PUT   SYSUT2,RECOUT                   ------|
         INITFLD RECOUT,C' '                          ----+
         MVC   OPER(3),=C'END'                            | THE END
         PUT   SYSUT2,RECOUT                          ----+
*
** Print ending on SYSPRINT
*
         INITFLD LINEOUT,C' '
         PUT   SYSPRINT,LINEOUT
*
         LA    R15,LINEOUT+1
         MVC   0(7,R15),=C'Trivia:'
         LA    R15,8(R15)
         L     R1,PSC_CC                   Get count
         BAS   R9,EDITFWF
         MVC   1(16,R15),=C'bytes compressed'
         PUT   SYSPRINT,LINEOUT
*
         INITFLD LINEOUT,C' '
         LA    R15,LINEOUT+1
         MVC   0(21,R15),=C'Number of body lines:'
         LA    R15,22(R15)
         L     R1,X_BODYC                  Get count
         BAS   R9,EDITFWF
         PUT   SYSPRINT,LINEOUT
*
         INITFLD LINEOUT,C' '
         MVC   LINEOUT+1(16),=C'End of execution'
         PUT   SYSPRINT,LINEOUT
*
** Close files
*
         CLOSE (SYSUT1)
         CLOSE (SYSUT2)
         CLOSE (SYSPRINT)
*
** Exit housekeeping - return to caller
*
         DA#LEAVE ,                      Goodbye Cruel World
         EJECT
***********************************************************************
***                                                                 ***
**       ")BODY" PROCESSING                                          **
**       R8: COLUMN NUMBER,  R3: LINE LOCATION PTR                   **
***                                                                 ***
***********************************************************************
         SPACE  2
BODY     DS    0H
         L     R1,X_BODYC
         LA    R1,1(R1)
         ST    R1,X_BODYC
*
         MVC   LINEOUT+1(4),=C'Body'
         MVC   PSC_LA(2),=X'00,00'         Init it out
         XC    PSC_LAC(4),PSC_LAC          zero it out
*
** If this is the first time, put out TSO demo invocation code
*
         TM    X_FLAG1,$XF1_B1ST            First time ?
         BO    B$1STX                       No, leave
         OI    X_FLAG1,$XF1_B1ST            Mark it
*
         INITFLD RECOUT,C' '
         MVI   LABEL,STAR
         MVC   LABEL+3(HORNL),HORN
         PUT   SYSUT2,RECOUT
*
         INITFLD RECOUT,C' '                         -----+
         MVC   LABEL(6),=C'SCREEN'                        |
         MVC   OPER(10),=C'DA#ENTER ,'                    |
         MVC   COMMENT(18),=C'Entry Housekeeping'         |
         PUT   SYSUT2,RECOUT                              |
         INITFLD RECOUT,C' '                              |  DISPLAY
         MVC   OPER(23),=C'STFSMODE ON,INITIAL=YES'       |
         MVC   COMMENT(12),=C'Clear Screen'               |
         PUT   SYSUT2,RECOUT                              |
         INITFLD RECOUT,C' '                              |
         MVC   OPER(25),=C'TPUT SCRN1,SCRN1L,FULLSCR'     |    THE
         PUT   SYSUT2,RECOUT                              |
         INITFLD RECOUT,C' '                              |
         MVC   OPER(13),=C'TGET REPLY,50'                 |
         PUT   SYSUT2,RECOUT                              |
         INITFLD RECOUT,C' '                              |  SCREEN
         MVC   OPER(12),=C'STFSMODE OFF'                  |
         MVC   COMMENT(12),=C'Clear Screen'               |
         PUT   SYSUT2,RECOUT                              |
         INITFLD RECOUT,C' '                              |
         MVC   OPER(13),=C'TPUT REPLY,50'                 |
         PUT   SYSUT2,RECOUT                              |
         INITFLD RECOUT,C' '                              |
         MVC   OPER(10),=C'DA#LEAVE ,'                    |
         MVC   COMMENT(17),=C'Exit Housekeeping'          |
         PUT   SYSUT2,RECOUT                           ---+
         INITFLD RECOUT,C' '                              |
         MVC   LABEL(18),=C'REPLY    DS   CL50'           |
         PUT   SYSUT2,RECOUT                           ---+
*
         INITFLD RECOUT,C' '             ------|
         MVI   LABEL,STAR                      |  PRINT
         PUT   SYSUT2,RECOUT                   |  3
         MVC   LABEL+5(14),=C'Converted Scrn'  |  Comment
         PUT   SYSUT2,RECOUT                   |  LINES
         MVI   LABEL+5,C' '                    |
         MVC   LABEL+6(13),LABEL+5             |
         PUT   SYSUT2,RECOUT             ------|
*
         INITFLD RECOUT,C' '               -------|
         MVC   LABEL(8),SCRNNAME                  |  PRINT
         MVC   OPER(2),DS                         |   SCREEN NAME
         MVC   DATA(2),=C'0H'                     |     EQUATE
         PUT   SYSUT2,RECOUT               -------|
         INITFLD RECOUT,C' '            --------|
         MVC   OPER(2),DC                       |
         MVI   DATA,C'X'                        |  PRINT
         MVI   DATA+1,TICK                      |   COMMAND
         MVC   DATA+2(2),=C'F5'                 |     TYPE
         MVI   DATA+4,TICK                      |
         MVC   COMMENT(11),=CL11'Erase/write'   |
         PUT   SYSUT2,RECOUT            --------|
         INITFLD RECOUT,C' '                   -------|
         MVC   OPER(2),DC                             |
         MVI   DATA,C'X'                              |  PRINT
         MVI   DATA+1,TICK                            |  WRITE
         MVC   DATA+2(2),=C'C3'                       |  CONTROL
         MVI   DATA+4,TICK                            |  CHARACTER
         MVC   COMMENT(3),=CL3'WCC'                   |
         PUT   SYSUT2,RECOUT                    ------|
         INITFLD RECOUT,C' '                      -------|
         MVC   OPER(2),DC                                |
         MVI   DATA,C'X'                                 |  ERASE
         MVI   DATA+1,TICK                               |  THE
         MVC   DATA+2(20),=C'11,40,40,3C,40,40,00'       |  SCREEN
         MVI   DATA+22,TICK                              |  COMMAND
         MVC   COMMENT(16),=C'Erase the screen'          |
         PUT   SYSUT2,RECOUT                       ------|
B$1STX   EQU   *
*
** Initialize
*
         L      R1,LINECTR                 Get line count
         LA     R1,1(R1)                   Increment line count
         ST     R1,LINECTR                 Save line count
         LA     R3,BPL                     Get number of bytes per line
         LR     R4,R2                      Locate input location
*
** Process the input record
*
B$RRL    EQU    *
         CLI    0(R4),C' '                 CHECK FOR INITIAL SPACE
         BNE    B$RRLX                     NO, NOT A BLANK, MOVE ON
         LA     R4,1(R4)                   BUMP UP TO NEXT BYTE
         BCT    R3,B$RRL                   SKIP THIS BYTE
         B      BODYX                      WHOLE RECORD WAS BLANK...
B$RRLX   EQU    *
         LA     R8,BPL                     GET NUMBER OF BYTES PER LINE
         LA     R8,1(R8)                   INCREMENT TO GET OUR OFFSET
         SR     R8,R3                      BPL - LOCATION = COLUMN
         INITFLD RECOUT,C' '               --|
         MVI    RECOUT,STAR                  | PRINT COMMENT LINE
         PUT    SYSUT2,RECOUT              --|
         INITFLD RECOUT,C' '               BLANK OUT OUTPUT RECORD
         BAS    R14,PUT_SBA                Spit out SBA
*
** TRIM TRAILING BLANKS OFF THE END OF LINE
*
         LA     R14,BPL                    GET BYTES PER LINE
         LA     R15,BPL(R2)                POINT TO END OF LINE
         BCTR   R15,0                      NEED TO START ONE BACK
TRIMLOOP EQU    *
         CLI    0(R15),X'40'               IS THIS BYTE A BLANK
         BNE    TRIMX                      NO, MOVE ON
         BCTR   R15,0                      YES, IGNORE HIM
         BCT    R14,TRIMLOOP                    AND GO TEST NEXT ONE
TRIMX    EQU    *
         LA     R15,BPL                    GET BYTES PER LINE
         SR     R15,R14                    R15 = BPL - TRAILING BLANKS
         SR     R3,R15                     R3 = BYTES REMAINING ON LINE
*
** Process good part of line
*
         INITFLD RECOUT,C' '               BLANK OUT RECORD
PBYTE1   EQU    *
         LA     R9,40                      PRINT ONLY FIRST 40 BYTES
         LA     R7,DATA+2                  PLACE TO PUT OUTPUT STUFF
         NI     X_FLAG1,255-$XF1_OUTW    TURN OFF flag
         NI     X_FLAG1,255-$XF1_ATTR    TURN OFF flag
PBYTE2   EQU    *
         BAL    R14,PROCESS_SPECIAL_CHARACTERS
         LTR    R3,R3                      END OF THIS LINE?
         BNP    BODYX                      YES, LEAVE
         TM     X_FLAG1,$XF1_ATTR          WAS THERE AN ATTRIBUTE FOUND
         BO     PBYTE1                     YES, REINITIALIZE
         OI     X_FLAG1,$XF1_OUTW          TURN ON OUTPUT FLAG
         MVC    0(1,R7),0(R4)              MOVE OUT A BYTE AT A TIME
         LA     R4,1(R4)                   INCREMENT TO NEXT BYTE
         LA     R7,1(R7)                   BUMP UP TO NEXT OUTPUT BYTE
         BCTR   R3,0                       DECREMENT BYTE
         LTR    R3,R3                      ARE WE OUT OF BUD?
         BNP    BODYX                      YES, GUESS WE'RE OUT OF BEER
         BCT    R9,PBYTE2                  GET NEXT BYTE
         BAL    R5,PRTDATA                 PRINT THIS DATA RECORD
         B      PBYTE1
BODYX    EQU    *
         BAL    R5,PRTDATA
         B      GETRECB
         EJECT
***********************************************************************
***                                                                 ***
**       PROCESS SPECIAL CHARACTERS                                  **
***                                                                 ***
***********************************************************************
PROCESS_SPECIAL_CHARACTERS DS 0H
         ST     R14,PSC_RA
         LA     R6,ATTRTAB                 ADDR OF ATTRIBUTE TABLE
PSC$L    EQU    *
         CLI    0(R6),X'FF'                ARE WE AT THE END?
         BE     PSC$X                      YES, GO TO EXIT
         CLI    0(R4),TICK                 ---+
         BNE    PSC$TX                        |  PROCESS
         MVI    0(R7),TICK                    |    TICK
         LA     R7,1(R7)                      |    MARKS
         B      PSC$X                      ---+
PSC$TX   EQU    *
         CLI    0(R4),C'&&'                ---+
         BNE    PSC$AX                        |
         CLI    1(R4),C'&&'                   |
         BNE    PSC$AT                        |    PROCESS
         LA     R4,1(R4)                      |
         BCTR   R3,0                          |    AMPERSAND
         LTR    R3,R3                         |
         BNP    PSC$X                         |    CHARACTERS
         BAL    R14,PARSE_LABEL               |
         B      PSC$X                         |
PSC$AT   EQU    *                             |
         MVI    0(R7),C'&&'                   |
         LA     R7,1(R7)                      |
         B      PSC$X                      ---+
PSC$AX   EQU    *
         CLC    0(1,R6),0(R4)              IS BYTE IN TABLE
         BNE    PSC$LB                     NO, MOVE ON
         TM     X_FLAG1,$XF1_OUTW          IS OUTPUT FLAG ON
         BNO    PSC$PDX                    NO, MOVE ON
*
** See if it makes sense to put SBA bytes instead of a bunch of spaces
*
         LR     R15,R7                     Get output location
         SH     R15,=H'4'                  Backup 4 bytes
         CLC    0(4,R15),=CL8' '           Have at least 4 bytes?
         BNE    PSC$CX                     No, don't bother
         OI     X_FLAG1,$XF1_COMP          Turn on flag
*        MVC    0(12,R7),=C'<-Compressed'
         LR     R15,R7                     Re-init location
         BCTR   R15,0                      Start out one below
         LR     R14,R15                    Get End
         LA     R1,DATA+3                  Get Start
         SR     R14,R1                     Length = End - Start
PSC$CL   EQU    *
         CLI    0(R15),C' '                Blank?
         BNE    PSC$CLX                    No, continue
         L      R1,PSC_CC                  Get count
         LA     R1,1(R1)                   Increment count by 1
         ST     R1,PSC_CC                  Save count
         BCTR   R15,0                      Yes, decrement by 1
         BCT    R14,PSC$CL                 and process next byte
PSC$CLX  EQU    *
         MVI    1(R15),TICK                Insert ending tick
PSC$CX   EQU    *
*
** Print current line
*
         BAL    R5,PRTDATA                 Print current data
         TM     X_FLAG1,$XF1_COMP          Compressed?
         BNO    PSC$PDX                    No, continue
         NI     X_FLAG1,255-$XF1_COMP      Turn off flag
         LR     R8,R4                      Get input byte
         SR     R8,R2                      Calculate column
         LA     R8,1(R8)                   Add one - not base 0
         A      R8,PSC_LAC                 Add in attributes skipped
         BAS    R14,PUT_SBA                Put SBA line
PSC$PDX  EQU    *
*
** Put out attribute character
*
         CLI    3(R6),C'I'                  Input field
         BE     PSC$SKT                     Yes, continue
         CLC    PSC_LA(2),1(R6)             Same as previous?
         BE     PSC$SKA                     Yes, skip it
PSC$SKT  EQU    *
*        MVC    PSC_LA(2),1(R6)             Save attribute byte
         INITFLD RECOUT,C' '                BLANK OUT RECORD
         MVC    OPER(2),DC                  MOVE IN ASM STUFF
         MVI    DATA,C'X'                   HEX FIELD INDICATOR
         MVI    DATA+1,TICK                 MOVE IN ASM STUFF
         MVC    DATA+2(2),=CL2'1D'          ATTRIBUTE BYTE
         MVI    DATA+4,C','                 GET COMMA BETWEEN HEX CHARS
         MVC    DATA+5(2),1(R6)             MOVE IN BYTE FROM TABLE
         MVI    DATA+7,TICK                 GET ENDING TICK
         MVC    COMMENT(COMMENTL),3(R6)     DONT FORGET COMMENT
         PUT    SYSUT2,RECOUT               PRINT THIS GUY
         INITFLD RECOUT,C' '                BLANK OUT RECORD
         B      PSC$SKX
PSC$SKA  EQU    *
         L      R1,PSC_LAC                  Get count
         LA     R1,1(R1)                    Increment by 1
         ST     R1,PSC_LAC                  Save it
PSC$SKX  EQU    *
         LA     R4,1(R4)                    Bump past attribute byte
         BCTR   R3,0
         LTR    R3,R3
         BNP    PSC$X
         OI     X_FLAG1,$XF1_ATTR          TURN ON OUTPUT FLAG
         CLI    3(R6),C'I'                  INPUT RECORD?
         BNE    PSC$X                       YES, MOVE ON
*
** Insert cursor
*
         TM     X_FLAG1,$XF1_HOME         Found home?
         BO     PSC$HFX
         OI     X_FLAG1,$XF1_HOME         We found our way home...
         MVC    OPER(2),DC                  MOVE IN ASM STUFF
         MVI    DATA,C'X'                   HEX FIELD INDICATOR
         MVI    DATA+1,TICK                 MOVE IN ASM STUFF
         MVC    DATA+2(2),=CL2'13'          ATTRIBUTE BYTE
         MVI    DATA+4,TICK                 GET COMMA BETWEEN HEX CHARS
         MVC    COMMENT(13),=C'Insert Cursor'
         PUT    SYSUT2,RECOUT               PRINT THIS GUY
         INITFLD RECOUT,C' '                BLANK OUT RECORD
PSC$HFX  EQU    *
*
** Parse label
*
         BAL    R14,PARSE_LABEL             PUT LABEL ON DATA FIELD
         B      PSC$X                       GOTO EXIT
PSC$LB   EQU    *
         LA     R6,ATENTRYL(R6)             BUMP UP TO NEXT ENTRY
         B      PSC$L                       TEST NEXT BYTE
*
** Common exit from Process_Special_Characters
*
PSC$X    EQU    *                           COMMON EXIT
         L      R14,PSC_RA
         BR     R14
         EJECT
***********************************************************************
***                                                                 ***
**       PARSE LABEL                                                 **
***                                                                 ***
***********************************************************************
PARSE_LABEL DS 0H
         ST     R14,PL_RA                 SAVE RETURN ADDRESS
         STM    R5,R7,PL_SREGS            Save registers
*
** Put out line with field name
*
         LA     R5,RECOUT
         XR     R6,R6
         LA     R7,8
PLL1     EQU    *
         CLI    0(R4),C'+'                 IS THIS AN ENDING CHARACTER
         BE     PLX                        YES, WE GOT WHAT WE WANT
         LA     R6,1(R6)                   ADD 1 TO BYTE COUNT
         MVC    0(1,R5),0(R4)              MOVE OUT A BYTE AT A TIME
         LA     R4,1(R4)                   NEXT BYTE ON INPUT LINE
         BCTR   R3,0                       ---+
         LTR    R3,R3                         |  CHECK FOR END-OF-INPUT
         BNP    PLX                        ---+
         BCTR   R7,0                       -------+
         LTR    R7,R7                             | PAST 8 BYTE NAME?
         BNP    PLL1                       -------+
         LA     R5,1(R5)                   NEXT BYTE ON OUTPUT LINE
         B      PLL1
PLX      EQU    *
         OC     RECOUT(8),=CL8' '       Make label uppercase
         MVC    OPER(2),DS              DEFINE STORAGE
         MVC    DATA(2),CL              ..OF CHARACTER LENGTH ???
         CVD    R6,DOUBLE               CHANGE TO RIGHT FORMAT 4 EDIT
         MVC    WRKFLD(12),EDPAT        GET THE EDIT PATTERN
         LA     R1,WRKFLD+11            FIND THE SIGNIFICANT DIGIT
         EDMK   WRKFLD,DOUBLE+2         EDIT THE PACKED FIELD
         LA     R2,WRKFLD+12            FIND THE END OF WRKFLD
         SR     R2,R1                   GET LENGTH W/O LEADING SPACES
         BCTR   R2,0                    DECREMENT FOR EX INSTRUCTION
         EX     R2,MOVELEN              MOVE THE LENGTH TO
         PUT    SYSUT2,RECOUT           PRINT VARIABLE OUTPUT
         INITFLD RECOUT,C' '            BLANK OUT RECORD
         LM     R5,R7,PL_SREGS          Restore registers
         L      R14,PL_RA               GET RETURN ADDRESS
         BR     R14                     RETURN TO SENDER
         EJECT
***********************************************************************
***                                                                 ***
**       Insert new SBA code                                         **
***                                                                 ***
***********************************************************************
         SPACE 2
PUT_SBA  EQU   *
         ST     R14,PSBA_RA
*
         INITFLD SBALINE,C' '
         MVC    SBALINE+O_OPER(2),DC       MOVE IN OPERATION TYPE
         MVI    SBALINE+O_DATA,C'X'        TELL ASSEMBLER THIS IS HEX
         MVI    SBALINE+O_DATA+1,TICK      PUT IN APOSTROPHE
         MVC    SBALINE+O_DATA+2(2),=C'11' DATASTREAM ADDRESS
         L      R1,LINECTR
         LR     R15,R1                     GET ROW NUMBER
         BCTR   R15,0                      DECREMENT BY ONE
         MH     R15,=H'80'                 GET NUMBER OF BYTES PER LINE
         LR     R14,R8                     GET COLUMN NUMBER
         BCTR   R14,0                      DECREMENT TO GET RITE ADDR
         AR     R15,R14                    R15 <- BINARY OFFSET
*
         LR     R14,R15                    MOVE TO WORK REGISTER
         STC    R14,OFFREL0+1              SAVE FOR LATER
         SRL    R14,6
         STC    R14,OFFREL0
         NI     OFFREL0+1,X'3F'
         TR     OFFREL0(2),TAB             FIND OUT DATASTREAM ADDRESS
         LA     R15,OFFREL0                GET PURE HEX VALUES
         UNPK   DOUBLE(5),0(3,R15)         INITIALIZE FOR CONVERSION
         MVZ    DOUBLE(8),=XL8'0'          CLEAR OUT
         TR     DOUBLE(8),HEXTAB           CONVERT TO PRINTABLE HEX
         MVI    SBALINE+O_DATA+4,C','      GET FIRST COMMA B4 LOCATION
         MVC    SBALINE+O_DATA+5(2),DOUBLE GET FIRST HEX CHARACTERS
         MVI    SBALINE+O_DATA+7,C','      PUT IN COMMA AFTER FIRST HEX
         MVC    SBALINE+O_DATA+8(2),DOUBLE+2 GET SECOND HEX CHARACTERS
         MVI    SBALINE+O_DATA+10,TICK     PUT ENDING TICK
*
         LA     R15,SBALINE+O_COMM         Locate output
         MVC    0(6,R15),=C'Locate'        Move in text
         LA     R15,7(R15)                 Bump past it
         L      R1,LINECTR                 Get line number
         BAS    R9,EDITFWF                 Edit line number
         MVI    0(R15),C','                Put in comma
         LA     R15,2(R15)                 Bump past comma
         LR     R1,R8                      Get column
         BAS    R9,EDITFWF                 Edit column number
*
         PUT    SYSUT2,SBALINE             Print line
*
** Return to caller
*
         L      R14,PSBA_RA
         BSM    0,R14
         EJECT
***********************************************************************
***                                                                 ***
**       Print Data                                                  **
**                                                                   **
**       Input: R7 has place on output line                          **
***                                                                 ***
***********************************************************************
         SPACE 2
PRTDATA  EQU    *
         MVC    OPER(2),DC                 Get DC
         MVI    DATA,C'C'                  Character
         MVI    DATA+1,TICK                Starting tick
         TM     X_FLAG1,$XF1_COMP          Compressed?
         BO     PD$TICKX                   Yes, already have tick...
         MVI    0(R7),TICK                 Move in ending tick
PD$TICKX EQU    *
         CLI    DATA+2,TICK                ---+
         BNE    PD$OUT                        | Did we actually
         CLI    DATA+3,TICK                   | produce a good line?
         BNE    PRTDATAX                   ---+
PD$OUT   EQU    *
         PUT    SYSUT2,RECOUT                   PRINT THIS RECORD
PRTDATAX EQU    *
         INITFLD RECOUT,C' '
         BR     R5
         EJECT
***********************************************************************
***                                                                 ***
**       Misc Internal subroutines                                   **
***                                                                 ***
***********************************************************************
         SPACE 2
*
** Edit full word in Register 1 flush at location in Register 15
** INPUT: R1 - Register to print
**        R15 - Address to put number
*
EDITFWF  EQU   *
         LTR   R1,R1                      Check for zero
         BZ    EDITFWF0                   Yes, save cpu time
         CVD   R1,DOUBLE                  No, convert to packed
         LA    R1,DOUBLE2+14              Locate Sig digit
         MVC   DOUBLE2(15),EDITFWFP       Move in edit pattern
         EDMK  DOUBLE2(15),DOUBLE+2       Edit and save place
         LA    R14,DOUBLE2+16             Locate last possible byte + 1
         SR    R14,R1                     Length = end - start
         BCTR  R14,0                      Decrement for EX
         EX    R14,EDITFWFM               Move edit number to output
         LA    R15,0(R14,R15)             Bump pointer past number
         MVI   0(R15),C' '                Insert space after number
         BSM   0,R9                       Return to caller
EDITFWFM MVC   0(0,R15),0(R1)
EDITFWFP DC    X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'
EDITFWF0 DS    0H
         MVI   0(R15),C'0'                Insert zero
         LA    R15,1(R15)                 Bump past zero
         BSM   0,R9                       Return to caller
*
** Point Register 15 to the first blank in a string
** Input:  R0  - Maximum length of the string
**         R15 - String
** Output: R15 - First space in the string
*
LOCATE_FIRST_SPACE DS 0H
         CLI   0(R15),C' '                Blank?
         BE    LFS$X                      Yes, leave
         LA    R15,1(R15)                 No, bump to next byte
         BCT   R0,LOCATE_FIRST_SPACE      ..Repeat
LFS$X    EQU   *
         BSM   0,R14                      Return to caller
         EJECT
***********************************************************************
***                                                                 ***
**       Constants and equates                                       **
***                                                                 ***
***********************************************************************
         SPACE  2
HORN     DC    C'This source was created by the DA$SPF2D program'
HORNL    EQU   *-HORN
DC       DC    CL2'DC'
DS       DC    CL2'DS'
CL       DC    CL2'CL'
EQU      DC    CL3'EQU'
MOVELEN  MVC   DATA+2(0),0(R1)
HEXTAB   DC    C'0123456789ABCDEF'
EDPAT    DC    X'40,20,20,20,20,20,20,20,20,20,21,20'
*
*        THIS TABLE COPIED FROM PAGE 7-14, MANUAL NUMBER: GA23-0061-0
*        "3274 CONTROL UNIT DESCRIPTION AND PROGRAMMER'S GUIDE"
*
TAB      EQU   *
         DC    X'40,C1,C2,C3,C4,C5,C6,C7,C8,C9'
         DC    X'4A,4B,4C,4D,4E,4F'
         DC    X'50,D1,D2,D3,D4,D5,D6,D7,D8,D9'
         DC    X'5A,5B,5C,5D,5E,5F'
         DC    X'60,61,E2,E3,E4,E5,E6,E7,E8,E9'
         DC    X'6A,6B,6C,6D,6E,6F'
         DC    X'F0,F1,F2,F3,F4,F5,F6,F7,F8,F9'
         DC    X'7A,7B,7C,7D,7E,7F'
*
*        ATTRIBUTE TABLE MASK
*
ATMASK   EQU   *                    ....+....1....+....2
         DC    C'%',C'E8',C'O',CL20'ATTR: Prot high int'
         DC    C'+',C'E4',C'O',CL20'ATTR: Prot Low int'
         DC    C'_',C'C5',C'I',CL20'ATTR: Unprotected'
         DC    X'FF'
ATMASKL  EQU   (*-ATMASK)
COMMENTL EQU   20
ATENTRYL EQU   COMMENTL+4
         EJECT
*
*        PROGRAM EQUATES
*
TICK     EQU   X'7D'
STAR     EQU   C'*'
BPL      EQU   80
*
O_LABEL  EQU   0
O_OPER   EQU   9
O_DATA   EQU   15
O_COMM   EQU   49
*
LABEL    EQU   RECOUT+O_LABEL
OPER     EQU   RECOUT+O_OPER
DATA     EQU   RECOUT+O_DATA
COMMENT  EQU   RECOUT+O_COMM
*
** Files - Variable area
*
SYSUT1   DCB   DDNAME=SYSUT1,                                        ...
               DSORG=PS,MACRF=(GL),EODAD=EOF
SYSUT2   DCB   DDNAME=SYSUT2,                                        ...
               DSORG=PS,MACRF=(PM),LRECL=80,RECFM=FB
SYSPRINT DCB   DDNAME=SYSPRINT,                                      ...
               DSORG=PS,MACRF=(PM),LRECL=133,RECFM=FB
*
** Literals
*
         PRINT DATA
LTORG    LTORG ,
LTORGL   EQU   *-LTORG
         PRINT NODATA
*
** Calculate length of main CSECT
*
          DS    0D                        End on double word boundry
DA$SPF2DL EQU   *-DA$SPF2D                Length of program
DA$SPF2DB EQU   (3*4096)-DA$SPF2DL        Bytes left addressable
         DS    0D
         EJECT
***********************************************************************
***                                                                 ***
**       GETMAINed Work area                                         **
***                                                                 ***
***********************************************************************
         SPACE  2
DSA      DSECT ,
         DS    18F                      Register Save Area
WORK     DS    F                        WORK FIELD
DOUBLE   DS    D                        DOUBLE WORK FIELD
DOUBLE2  DS    2D                       DOUBLE WORK FIELD
         DS    0F                       PUT_SBA
PSBA_RA  DS    F                        ..Return address
         DS    0F                       Parse_Label
PL_SREGS DS    3F                       ..Save registers
PL_RA    DS    F                        ..Return address
         DS    0F                       Process_Special_Characters
PSC_RA   DS    F                        ..Return address
PSC_CC   DS    F                        ..Compression count
PSC_LA   DS    2C                       ..Last attribute bytes
PSC_LAC  DS    F                        ..Last attribute bytes count
*
ATLOC    DS    F                        ATTRIBUTE TABLE LOCATION
LINECTR  DS    F                        LINE COUNTER SAVE AREA
OFFREL0  DS    CL2                      OFFSET RELATIVE TO ZERO
WRKFLD   DS    CL12                     WORK FIELD FOR EDIT MASK
SCRNNAME DS    CL8
*
X_FLAG1   DS   B'00000000'              Execution flag 1
$XF1_ATTR EQU  B'10000000'              ..Attribute byte?
$XF1_HOME EQU  B'01000000'              ..Found home
$XF1_OUTW EQU  B'00100000'              ..Output mode
$XF1_B1ST EQU  B'00010000'              ..First time in BODY section
$XF1_COMP EQU  B'00001000'              ..Compressed?
*
X_TYPE   DS    C                        Type of input record
$XT_ATTR EQU   C'A'
$XT_BODY EQU   C'B'
$XT_PROC EQU   C'P'
$XT_END  EQU   C'E'
$XT_SKIP EQU   C'S'
*
         DS    0F
X_BODYC  DS    F
*
SBALINE  DS    CL80                     OUTPUT RECORD
RECOUT   DS    CL80                     OUTPUT RECORD
REVERSE  DS    CL80                     INPUT RECORD REVERSED
ATTRTAB  DS    CL500                    ATTRIBUTE TABLE
LINEOUT  DS    CL133
         DS    0D                       ALIGN DOUBLE WORD
DSAL     EQU   *-DSA                    LENGTH OF DSECT AREA
         END
./ ADD NAME=DA$WDATE 0104-01266-01283-1352-01634-01625-00000-DALCOCK
DA$WDATE TITLE 'Date convertion ISPF application'
* =================================================================== *
*
* Name: DA$WDATE
*
* Author = David Alcock :: dave@planetmvs.com
*
* Purpose: This is an ISPF dialog for performing Date conversions
*          of Julian and Gregorian dates.  Calendars of the
*          previous, current and next month of the date are shown.
*
*          This application was created primarily to verify that the
*          DA$DATE date routine works properly.
*
* Limitations: ASSUMES, yes assumes, United States format of Gregorian
*              dates: mm/dd/yy (Month then Day of month)
*
* Disclaimer: This program is FREEWARE.  Use at your own risk.  It
*             is provided for your enjoyment and neither David
*             Alcock or his employer provides any warranty for it's
*             use.  I'd like to hear how it works on your system.
*
*             This software is not in the public domain but is
*             available free of charge and with source code
*             provided.  It is copyright 2001+ by David Alcock
*             All rights reserved.
*
* Non-IBM External programs:
* o DA$DATE....Date routine
*
* Non-IBM assembler MACROs:
* o DA#ENTER...Entry housekeeping
* o DA#LEAVE...Termination housekeeping
* o DA#EYEC....Build standard O/S module eyecatcher
*              (invoked by the DA#ENTER)
* o DA#REGS....Define registers (invoked by DA#ENTER)
* o DA#DATE....Equates and DSECTs for the date routine
*
* ISPF panels:
* o DA$WDATM...Main panel
* o DA$WDATT...Tutorial panel
* o DA$WDATY...Year on a Page (okay, a half a year on a page)
*
* Enhancement queue:
* o After I get the PTF on and support in DA$DATE, add 64-bit TOD
* =================================================================== *
  SPACE 2
* =================================================================== *
*
* My OS/390 R6 system (maybe all ISPF V4) allows you to Julian to
* Gregorian conversions by moving your cursor to the day of the year
* on the main ISPF menu and hit enter.  You will see this:
*
*    +--------------------------------------------------------------+
*    |                                                              |
*    |  Enter the day and year below:                               |
*    |                                                              |
*    |  Day . . . . 365   (Between 1 and 365 or 366 if leap year)   |
*    |  Year  . . . 1999  (Between 1801 and 2099)                   |
*    |                                                              |
*    |  Day  365  of year  1999  is  Friday        ,  1999/12/31    |
*    |                                                              |
*    +--------------------------------------------------------------+
*
* =================================================================== *
         SPACE 2
&DAVER   SETC  '2.1'
* =================================================================== *
*           M o d i f i c a t i o n   H i s t o r y
*
* Person     Date        Description
* ---------- ----------- ----------------------------------------------
* DGAlcock   2001-10-10  v2.2: Dynamic LIBDEF Rexx written: WHATDATE;
* DGAlcock   14-SEP-1999 v2.1:
*                        - Added checking input parm for date;
*                        - Instead of forcing the user to input either
*                          a Gregorian or Julian date, we have one
*                          input field and parse it;
*                        - Input 32-bit TOD stamp;
* DGAlcock   09-SEP-1999 v2.0:
*                        - Changed name of program to DA$WDATE
*                        - Converted from GUIDE ISPF macros to native
*                          calls to ISPLINK;
*                        - Added ISO 8601 date input and output;
* DGAlcock   07-JUL-1995 v1.0 Original program written;
* =================================================================== *
         EJECT ,
DA$WDATE DA#ENTER 'V&DAVER ISPF Application: Date conversions',        @
               AMODE=31,RMODE=ANY,        ..Residency                  @
               BASE=(12,11,10),           ..Base registers             @
               LV=DSAL,RENT=YES           ..Dynamic Save Area
         USING DSA,R13                    Get addressability
         ST    R1,R1SAVE                  Save R1 on entry
         MVC   PIP_CURSOR(8),=CL8'IDATE'  Set field
         EJECT ,
***********************************************************************
***
**       Misc initializations
***
***********************************************************************
         SPACE 2
*
** Locate ISPLINK module.  We intentionally fail miserably if we
** can't find ISPLINK in the normal search order.
*
         LA    R8,=CL8'ISPLINK'           Locate module name
         LOAD  EPLOC=(8)                  Load it
         ST    R0,EP_ISPLINK              Save entry point address
*
** Control errors return
*
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'CONTROL',       Control                      @
               =CL8'ERRORS',              ..Errors                     @
               =CL8'RETURN'),             ..Return                     @
               VL,MF=(E,PARMLIST)         ..Execute from here
*
** Define our ISPF message variables
*
*->    VDEFINE '(ZERRSM)',ZERRSM,CHAR,=F'24',MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VDEFINE',       Define variable              @
               =C'(ZERRSM)',              ..Name                       @
               ZERRSM,                    ..Location                   @
               =CL8'CHAR',                ..Format                     @
               =F'24'),                   ..Length                     @
               VL,MF=(E,PARMLIST)         ..Execute from here
*->    VDEFINE '(ZERRLM)',ZERRLM,CHAR,=F'79',MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VDEFINE',       Define variable              @
               =C'(ZERRLM)',              ..Name                       @
               ZERRLM,                    ..Location                   @
               =CL8'CHAR',                ..Format                     @
               =F'79'),                   ..Length                     @
               VL,MF=(E,PARMLIST)         ..Execute from here
*->    VDEFINE '(ZERRHM)',ZERRHM,CHAR,=F'8',MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VDEFINE',       Define variable              @
               =C'(ZERRHM)',              ..Name                       @
               ZERRHM,                    ..Location                   @
               =CL8'CHAR',                ..Format                     @
               =F'8'),                    ..Length                     @
               VL,MF=(E,PARMLIST)         ..Execute from here
*->    VDEFINE '(ZERRALRM)',ZERRALRM,CHAR,=F'3',MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VDEFINE',       Define variable              @
               =C'(ZERRALRM)',            ..Name                       @
               ZERRALRM,                  ..Location                   @
               =CL8'CHAR',                ..Format                     @
               =F'3'),                    ..Length                     @
               VL,MF=(E,PARMLIST)         ..Execute from here
*->
         MVC   ZERRHM(8),=CL8' '          Help member
         MVC   ZERRALRM(3),=CL3'YES'      There is cause for Alarm?
*
** Locate DA$DATE module
*
         ICM   R0,B'1111',=V(DA$DATE)     Is it linked into us?
         BNZ   I$DADS                     Yes, use it
         LA    R8,=CL8'DA$DATE'           Locate module name
         LOAD  EPLOC=(8),ERRET=I$DADE     Load it
         OI    FLAG1,$F1LDAD              Indicate we loaded it
         B     I$DADS
I$DADE   DS    0H
         BAS   R9,MSG_CLEAR               Initialize message areas
         MVC   0(MS07L,R14),MS07          Get short message
         MVC   0(ML07L,R15),ML07          Get long message prefix
         LA    R8,MS07L                   Set short message length
         BAS   R9,MSG_SET                 Set the message up
         B     EXIT
I$DADS   DS    0H
         ST    R0,EP_DA$DATE              Save entry point address
I$DADX   EQU   *
*
** Define application ISPF variables
*
*->      VDEFINE '(IDATE)',IDATE,CHAR,32,MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VDEFINE',       Define variable              @
               =C'(IDATE)',               ..Name                       @
               IDATE,                     ..Location                   @
               =CL8'CHAR',                ..Format                     @
               =F'32'),                   ..Length                     @
               VL,MF=(E,PARMLIST)         ..Execute from here
*->      VDEFINE '(OGDATE)',OGDATE,CHAR,29,MF=E   freeform
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VDEFINE',       Define variable              @
               =C'(OGDATE)',              ..Name                       @
               OGDATE,                    ..Location                   @
               =CL8'CHAR',                ..Format                     @
               =F'29'),                   ..Length                     @
               VL,MF=(E,PARMLIST)         ..Execute from here
*->      VDEFINE '(OIDATE)',OIDATE,CHAR,10,MF=E   freeform
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VDEFINE',       Define variable              @
               =C'(OIDATE)',              ..Name                       @
               OIDATE,                    ..Location                   @
               =CL8'CHAR',                ..Format                     @
               =F'10'),                   ..Length                     @
               VL,MF=(E,PARMLIST)         ..Execute from here
*->      VDEFINE '(OJDATE)',OJDATE,CHAR,8,MF=E    "ccyy.ddd"
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VDEFINE',       Define variable              @
               =C'(OJDATE)',              ..Name                       @
               OJDATE,                    ..Location                   @
               =CL8'CHAR',                ..Format                     @
               =F'8'),                    ..Length                     @
               VL,MF=(E,PARMLIST)         ..Execute from here
*->      VDEFINE '(OTIME)',OTIME,CHAR,11,MF=E    "hh:mm:ss.th"
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VDEFINE',       Define variable              @
               =C'(OTIME)',               ..Name                       @
               OTIME,                     ..Location                   @
               =CL8'CHAR',                ..Format                     @
               =F'11'),                   ..Length                     @
               VL,MF=(E,PARMLIST)         ..Execute from here
*
**       VDEFINE '(CAL1)',W_ODCAL1_STR,CHAR,      Calendar 1          @
**             =AL4($DA#DATE_ODCALC),MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VDEFINE',       Define variable              @
               =C'(CAL1)',                ..Name                       @
               W_ODCAL1_STR,              ..Location                   @
               =CL8'CHAR',                ..Format                     @
               =AL4($DA#DATE_ODCALC)),    ..Length                     @
               VL,MF=(E,PARMLIST)         ..Execute from here
**       VDEFINE '(CAL2)',W_ODCAL2_STR,CHAR,      Calendar 2          @
**             =AL4($DA#DATE_ODCALC),MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VDEFINE',       Define variable              @
               =C'(CAL2)',                ..Name                       @
               W_ODCAL2_STR,              ..Location                   @
               =CL8'CHAR',                ..Format                     @
               =AL4($DA#DATE_ODCALC)),                                 @
               VL,MF=(E,PARMLIST)         ..Execute from here
**       VDEFINE '(CAL3)',W_ODCAL3_STR,CHAR,      Calendar 3          @
**             =AL4($DA#DATE_ODCALC),MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VDEFINE',       Define variable              @
               =C'(CAL3)',                ..Name                       @
               W_ODCAL3_STR,              ..Location                   @
               =CL8'CHAR',                ..Format                     @
               =AL4($DA#DATE_ODCALC)),                                 @
               VL,MF=(E,PARMLIST)         ..Execute from here
*
*->      VDEFINE '(LISTLINE)',LISTLINE,CHAR,=F'160',MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VDEFINE',       Define variable              @
               =C'(LISTLINE)',            ..Name                       @
               LISTLINE,                  ..Location                   @
               =CL8'CHAR',                ..Format                     @
               =F'160'),                  ..Length                     @
               VL,MF=(E,PARMLIST)         ..Execute from here
         MVC   PLL_CC(8),=CL8' '
         EJECT ,
***********************************************************************
***
**  Have initial screen showing today's date
***
***********************************************************************
         SPACE 2
PROCESS_PARAMETER EQU *
         L     R1,R1SAVE                  Restore R1 on entry
         TM    CPPLCBUF-CPPL(R1),X'80'    Was this command called?
         BNO   PP$NC                      No, need to look at CBUF
*
** We were called, it has a Batch type (EXEC) parameter
*
         L     R2,0(R1)                   Get address of parm
         SLR   R3,R3                      Clear register
         ICM   R3,B'0011',0(R2)           Get length of parm
         BZ    PP$X                       None, leave
         LA    R2,2(R2)                   Bump past parm length HW
         B     PP$PARSE                   Parse the input
*
** We were not called, it is a "Command Processor"
*
PP$NC    DS    0H
         L     R2,CPPLCBUF-CPPL(R1)       Locate Command Buffer
         SLR   R3,R3                      Clear register
         ICM   R3,B'0011',0(R2)           Get total CBUF length
         SLR   R0,R0                      Clear register
         ICM   R0,B'0011',2(R2)           Get total Command name length
         LA    R15,4                      Length of header
         AR    R2,R15                     Bump past header
         SR    R3,R15                     Decrement for header length
         AR    R2,R0                      Bump past Command length
         SR    R3,R0                      Length of data
*
** Look thru command buffer/parameter for our commands
** Input: R2 - Address of command-buffer/Parameter
**        R3 - Length of command-buffer/Parameter
*
PP$PARSE DS    0H
         LTR   R3,R3                      Check out length
         BZ    PP$X                       Length = Zero: Leave
         BM    PP$X                       Length < Zero: Leave
         CH    R3,=AL2(L'IDATE)           Over length
         BNH   PP$SDATE
*-Note: Need to do this in an ISPF compatible way.
 MVC PARMLIST(18),=C'Invalid Input date'
 TPUT PARMLIST,18
 B    PP$X
PP$SDATE DS    0H
         MVC   IDATE(L'IDATE),=CL32' '    Ensure trailing blanks
         BCTR  R3,0
         EX    R3,PP$MDATE
         B     PIP$PARSE
PP$MDATE MVC   IDATE(0),0(R2)
PP$X     DS    0H
         EJECT ,
***********************************************************************
***
**  Have initial screen showing today's date
***
***********************************************************************
         SPACE 2
*
** Message that we've started off on today's date
*
         BAS   R9,MSG_CLEAR               Initialize message areas
         MVC   0(MS01L,R14),MS01          Get short message
         MVC   0(ML01L,R15),ML01          Get long message prefix
         LA    R8,MS01L                   Set short message length
         BAS   R9,MSG_SET                 Set the message up
*
** Get calendar for the current day
*
         MVC   W_ODGUS29(C_ODGUS29L),C_ODGUS29
         MVC   W_ODJUL8(C_ODJUL8L),C_ODJUL8
         MVC   W_ODGUS10(C_ODGUS10L),C_ODGUS10
         MVC   W_ODISO10(C_ODISO10L),C_ODISO10
         MVC   W_OTIMEM11(C_OTIMEM11L),C_OTIMEM11
         MVC   W_ODCAL2(C_ODCALCL),C_ODCALC Initialize area
         L     R15,EP_DA$DATE             Locate date routine
         CALL  (15),                      Call date routine            @
               (W_ODGUS29,                ..output gregorian           @
               W_ODJUL8,                  ..output gregorian           @
               W_ODGUS10,                 ..output gregorian           @
               W_ODISO10,                 ..output ISO date            @
               W_OTIMEM11,                ..output Time                @
               W_ODCAL2),                 ..output calendar            @
               VL,MF=(E,PARMLIST)         ..execution area
         MVC   OGDATE(29),W_ODGUS29_STR
         MVC   OIDATE(10),W_ODISO10_STR
         MVC   OJDATE(8),W_ODJUL8_STR
*
         TM    FLAG1,$F1TOD               Need time of day?
         BO    PIP$UT1
         MVC   OTIME(11),=CL32' '
         B     PIP$UT1X
PIP$UT1  DS    0H
         MVC   OTIME(11),W_OTIMEM11_STR
         NI    FLAG1,255-$F1TOD           Turn off time of day
PIP$UT1X DS    0H
*
         MVC   PIP_LGDATE(10),W_ODGUS10_STR  Save it
         MVC   PIP_LJDATE(8),W_ODJUL8_STR    Save it
*
         MVI   IVARS,C' '
         MVC   IVARS+1(IVARSL-1),IVARS
         MVC   IDATE(10),W_ODGUS10_STR
*
         MVI   PC_OATTR,#_WHITE           Get output attribute
         MVC   PC_DATECC(4),W_ODGUS10_STR+6 Get "CCYY" -  "mm/dd/CCYY"
*        MVC   PC_DATEYY(2),W_ODGUS10_STR+8 Get "YY" from "mm/dd/ccYY"
         MVC   PC_DATEMM(2),W_ODGUS10_STR   Get "MM" from "MM/dd/ccyy"
         MVC   PC_DATEDD(2),W_ODGUS10_STR+3 Get "DD" from "mm/DD/ccyy"
*
         LA    R7,W_ODCAL2_STR            Locate calendar
         OI    PC_FLAG1,$PCF1_TODAY       It's for today!
         BAS   R14,PROCESS_CALENDAR       Process the calendar
         NI    PC_FLAG1,255-$PCF1_TODAY   It's over for today
         BAS   R14,PROCESS_OTHER_CALENDARS  Process the other ones
         EJECT ,
***********************************************************************
***
**       Process the input panel
***
***********************************************************************
         SPACE 2
PROCESS_INPUT_PANEL EQU *
PIP$L    EQU   *
*->      DISPLAY PANEL==CL8'DA$WDATM',CURSOR=PIP_CURSOR,MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'DISPLAY',       Service: DISPLAY             @
               =CL8'DA$WDATM',            ..Panel name                 @
               =CL8'        ',            ..MSGID                      @
               PIP_CURSOR),               ..Field Name                 @
               VL,MF=(E,PARMLIST)         ..Execute from here
         LTR   R15,R15
         BNZ   PIP$X
*
** Did we get Scrolled?
*
*->      VCOPY '(ZVERB)',ZVERBL,ZVERBA,LOCATE,MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VCOPY',         Service: VCOPY               @
               =C'(ZVERB)',               ..Name                       @
               ZVERBL,                    ..Length                     @
               ZVERBA,                    ..Location                   @
               =CL8'LOCATE'),             ..Type: Move or copy         @
               VL,MF=(E,PARMLIST)         ..Execute from here
         ICM   R1,B'1111',ZVERBA
         BZ    PIP$SCX
         ICM   R0,B'1111',ZVERBL
         BZ    PIP$SCX
         CH    R0,=H'2'                   At least 2?
         BL    PIP$SCX
         CLC   0(2,R1),=C'LE'             Left?
         BE    PIP$SLE
         CLC   0(2,R1),=C'RI'             Right?
         BE    PIP$SRI
         CLC   0(2,R1),=C'UP'             UP?
         BE    PIP$SUP
         CLC   0(2,R1),=C'DO'             Down?
         BE    PIP$SDO
         B     PIP$SCX
*                               01234567
PIP$SUP  EQU   *    PIP_LJDATE="yyyy.ddd'
         PACK  DOUBLE(8),PIP_LJDATE+5(3)  Get day of the year
         CVB   R15,DOUBLE                 Make it binary
         SH    R15,=H'1'                  Reelin' in the years
         LTR   R15,R15                    Too far down?
         BP    PIP$SDOC                   No, it's okay
         LA    R15,365                    Oops no leap year check!!
         PACK  DOUBLE(8),PIP_LJDATE(4)    Make century.year packed
         CVB   R14,DOUBLE                 Make it binary
         SH    R14,=H'1'                  Reelin' in the years
         CVD   R14,DOUBLE                 Convert back to packed
         UNPK  DOUBLE2(4),DOUBLE+4(4)     Convert packed to zoned
         OI    DOUBLE2+3,C'0'             Fix sign byte
         MVC   PIP_LJDATE(4),DOUBLE2      Set new year
         B     PIP$SDOC
*                               01234567
PIP$SDO  EQU   *    PIP_LJDATE="yyyy.ddd'
         PACK  DOUBLE(8),PIP_LJDATE+5(3)  Get day of the year
         CVB   R15,DOUBLE                 Make it binary
         LA    R15,1(R15)                 Reelin' in the years
         CH    R15,=H'365'                Oops, no leap year check!
         BNH   PIP$SDOC                   No, it's okay
         LA    R15,1                      Start at "yyyy.001"
         PACK  DOUBLE(8),PIP_LJDATE(4)    Make century.year packed
         CVB   R14,DOUBLE                 Make it binary
         LA    R14,1(R14)                 Happy New Year!
         CVD   R14,DOUBLE                 Convert back to packed
         UNPK  DOUBLE2(4),DOUBLE+4(4)     Convert packed to zoned
         OI    DOUBLE2+3,C'0'             Fix sign byte
         MVC   PIP_LJDATE(4),DOUBLE2      Set new year
PIP$SDOC EQU   *
         CVD   R15,DOUBLE                 Convert back to packed
         UNPK  DOUBLE2(4),DOUBLE+4(4)     Convert packed to zoned
         OI    DOUBLE2+3,C'0'             Fix sign byte
         LA    R2,W_IDJULC8               Locate output
         MVC   0(C_IDJULC8L,R2),C_IDJULC8 Initialize
         MVC   W_IDJULC8_STR(8),PIP_LJDATE Get last date
         MVC   W_IDJULC8_STR+5(3),DOUBLE2+1
         MVC   IDATE(32),=CL32' '
         MVC   IDATE(8),W_IDJULC8_STR     Reset new input date
         B     PIP$DATE
*                               0123456
PIP$SRI  EQU   *    PIP_LGDATE="mm/dd/ccyy"
         PACK  DOUBLE(8),PIP_LGDATE+6(4)  Make century.year packed
         CVB   R15,DOUBLE                 Make it binary
         LA    R15,1(R15)                 Reelin' in the years
         B     PIP$SLEC
PIP$SLE  EQU   *
         PACK  DOUBLE(8),PIP_LGDATE+6(4)  Make century.year packed
         CVB   R15,DOUBLE                 Make it binary
         SH    R15,=H'1'                  Reelin' in the years
PIP$SLEC EQU   *
         CVD   R15,DOUBLE                 Convert back to packed
         UNPK  DOUBLE2(4),DOUBLE+4(4)     Convert packed to zoned
         OI    DOUBLE2+3,C'0'             Fix sign byte
         LA    R2,W_IDGUS10               Locate output
         MVC   0(C_IDGUS10L,R2),C_IDGUS10 Initialize
         MVC   W_IDGUS10_STR(10),PIP_LGDATE Get last date
         MVC   W_IDGUS10_STR+6(4),DOUBLE2
         MVC   IDATE(32),=CL32' '
         MVC   IDATE(10),W_IDGUS10_STR   Reset new input date
         B     PIP$DATE
PIP$SCX  EQU   *
*
** See if the user specifed a command we should process in ZCMD
*
*->      VCOPY '(ZCMD)',ZCMDL,ZCMDA,LOCATE,MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VCOPY',         Service: VCOPY               @
               =C'(ZCMD)',                ..Name                       @
               ZCMDL,                     ..Length                     @
               ZCMDA,                     ..Location                   @
               =CL8'LOCATE'),             ..Type: Move or copy         @
               VL,MF=(E,PARMLIST)         ..Execute from here
*
         ICM   R2,B'1111',ZCMDL           Get command length
         BZ    PIP$ZCX                    None, display table again
         L     R3,ZCMDA                   Get command address
*
         LA    R14,T_ZCMDV                Locate Verb table
         LA    R15,T_ZCMDVN               Get number of entries
PIP$ZCL  EQU   *
         SLR   R8,R8                      Clear register
         IC    R8,TZCC_MINL-TZCC(R14)     Get minimum length
         CR    R8,R2                      Okay?
         BH    PIP$ZCLB                   No, don't even consider
         EX    R8,PIP$ZCLC                Match?
         BE    PIP$ZCLX                   Yes, leave
PIP$ZCLB EQU   *
         LA    R14,TZCCL(R14)             Bump to next entry
         BCT   R15,PIP$ZCL                Process it
*
         BAS   R9,MSG_CLEAR               Initialize message areas
         MVC   0(MS05L,R14),MS05
         EX    R2,PIP$ZCMM
         LA    R15,2(R2,R15)
         MVC   0(10,R15),=C'is invalid'
         LA    R8,MS05L                   Length of short message
         BAS   R9,MSG_SET                 Set the message up
         B     PIP$ZCRA
PIP$ZCLX EQU   *
         LA    R3,1(R8,R3)                Bump past "VERB "
         SR    R2,R8                      Decrement length
*
PIP$ZCO2L EQU  *                          Ignore blanks...
         CLI   0(R3),C' '                 Blank?
         BNE   PIP$ZCO2LX                 Nope, found 2nd operand
         LA    R3,1(R3)                   Bump to next byte
         BCT   R2,PIP$ZCO2L               Process it
PIP$ZCO2LX EQU *
         SLR   R9,R9                      Clear register
         ICM   R9,B'0011',TZCC_ROUTO-TZCC(R14) Get routine offset
         AR    R9,R12                     Locate routine
         BSM   0,R9                       Branch to routine
PIP$ZCRA EQU   *
         B     PIP$L                      Continue on my wayward son
PIP$ZCMM MVC   0(0,R15),0(R3)
PIP$ZCLC CLC   0(0,R3),TZCC_VERB-TZCC(R14)
PIP$ZCX  EQU   *
*
** Look at input dates
*
PIP$INPUT DS   0H
         CLC   IDATE(L'IDATE),=CL32' '    Have an input date?
         BNE   PIP$PARSE                  Yes, look at it
         BAS   R9,MSG_CLEAR               Initialize message areas
         MVC   0(MS02L,R14),MS02          Get short message
         MVC   0(ML02L,R15),ML02          Get long message prefix
         LA    R8,MS02L                   Set short message length
         BAS   R9,MSG_SET                 Set the message up
         B     PIP$L
*
** Parsing:
** > Gregorian:    "mm/dd/yy"     "mm/dd/ccyy"
**                  0....+..=8     0....+....=10
**
** > ISO:          "ccyy-mm-dd"
**                  0....+....=10
**
** > Julian:       "ccyy.ddd"      "yy.ddd"
**                  0....+..=8      0....+=6
**
** > 32-bit TOD:   "B361183F47FFFFFF" 1999-12-31 23:59
** > 32-bit TOD:   "B361183F48000000" 2000-01-01 00:00
**
*
PIP$PARSE DS 0H
*-Weed out 32-bit TOD stamps
         LA    R0,16
         LA    R1,IDATE
PIP$T32L DS    0H
         CLI   0(R1),X'81'         Below "a"
         BL    PIP$T32X
         CLI   0(R1),X'87'         In "a-f"
         BL    PIP$T32B
         CLI   0(R1),X'C1'         Below "A"
         BL    PIP$T32X
         CLI   0(R1),X'C7'         In "A-F"
         BL    PIP$T32B
         CLI   0(R1),X'F0'         Below "0"
         BL    PIP$T32X
         CLI   0(R1),X'F9'         In "0-9"
         BH    PIP$T32X
PIP$T32B DS    0H
         LA    R1,1(R1)
         BCT   R0,PIP$T32L
         CLI   0(R1),C' '          Blank?
         BE    PIP$TOD32
PIP$T32X DS    0H
*-Weed out Julian
         CLI   IDATE+4,C'.'        Julian?
         BE    PIP$J
         CLI   IDATE+2,C'.'        Julian?
         BE    PIP$J
*-Must be some type of Gregorian (or invalid)
*
** Gregorian Date: "mm/dd/yy "    "mm/dd/ccyy"  "ccyy-mm-dd"
*                   0....+....    0....+....1    0....+....
PIP$G    EQU   *
         CLI   IDATE+4,C'-'               ISO date?
         BE    PIP$GISO
         CLI   IDATE+2,C'-'               Looks good?
         BE    PIP$G2X                    Yes, alternative format
         CLI   IDATE+2,C'/'               Looks good?
         BNE   PIP$EFMT                   No, gripe about it
PIP$G2X  DS    0H
         CLI   IDATE+5,C'-'               Looks good?
         BE    PIP$G5X                    Yes, alternative format
         CLI   IDATE+5,C'/'               Looks good?
         BNE   PIP$EFMT                   No, gripe about it
PIP$G5X  DS    0H
         CLI   IDATE+8,C' '               Shorter date?
         BE    PIP$GS
         LA    R2,W_IDGUS10               Locate output
         MVC   0(C_IDGUS10L,R2),C_IDGUS10 Initialize
         MVC   W_IDGUS10_STR(10),IDATE    Get input
         B     PIP$DATE
PIP$GS   EQU   *
         LA    R2,W_IDGUS8                Locate output
         MVC   0(C_IDGUS8L,R2),C_IDGUS8   Initialize
         MVC   W_IDGUS8_STR(8),IDATE      Get input
         B     PIP$DATE
PIP$GISO EQU   *
         CLI   IDATE+7,C'-'               ISO date?
         BNE   PIP$EFMT                   Nope...
*-Note: I need to change this to use ISO Input format
         LA    R2,W_IDISO10               Locate output
         MVC   0(C_IDISO10L,R2),C_IDISO10 Initialize
         MVC   W_IDISO10_STR(10),IDATE    Get input
         B     PIP$DATE
*
** Julian Date: "yy.ddd " or "ccyy.ddd'
*                0....+.     0....+....
PIP$J    EQU   *
         CLI   IDATE+6,C' '               Shorter date?
         BE    PIP$JS
         CLI   IDATE+4,C'.'               Looks good?
         BNE   PIP$EFMT                   No, gripe about it
         CLC   IDATE+5(3),=C'001'         Valid date?
         BL    PIP$EFMT                   No...
*-Need Leap year check here...
         CLC   IDATE+5(3),=C'366'         Valid date?
         BH    PIP$EFMT                   No...
         LA    R2,W_IDJULC8               Locate input date area
         MVC   0(C_IDJULC8L,R2),C_IDJULC8 Initialize
         MVC   W_IDJULC8_STR(8),IDATE     Get input
         B     PIP$DATE
PIP$JS   EQU   *
         CLI   IDATE+2,C'.'               Looks good?
         BNE   PIP$EFMT                   No, gripe about it
         CLC   IDATE+3(3),=C'001'         Valid date?
         BL    PIP$EFMT                   No...
*-Need Leap year check here...
         CLC   IDATE+3(3),=C'366'         Valid date?
         BH    PIP$EFMT                   No...
         LA    R2,W_IDJULC6               Locate input date area
         MVC   0(C_IDJULC6L,R2),C_IDJULC6 Initialize
         MVC   W_IDJULC6_STR(6),IDATE     Get input
         B     PIP$DATE
*
** Input date is a 32-bit TOD stamp
*
PIP$TOD32 DS   0H
         OI    FLAG1,$F1TOD               Need time of day...
         LA    R2,W_ISTMPC16              Locate input date area
         MVC   0(C_ISTMPC16L,R2),C_ISTMPC16 Initialize
         MVC   W_ISTMPC16_STR(16),IDATE    Get input
         B     PIP$DATE
*
** Error: Format error
*
PIP$EFMT EQU   *
         BAS   R9,MSG_CLEAR               Initialize message areas
         MVC   0(MS04L,R14),MS04          Get short message
         MVC   0(ML04L,R15),ML04          Get long message prefix
         LA    R8,MS04L                   Set short message length
         BAS   R9,MSG_SET                 Set the message up
         B     PIP$L
*
** Error: Date routine returned error
*
PIP$EDR  EQU   *
         BAS   R9,MSG_CLEAR               Initialize message areas
         MVC   0(MS04L,R14),MS04          Get short message
         MVC   0(30,R15),=C'DA$DATE routine passed error:'
         LA    R15,31(R15)
         TM    DA#DATED_FLAG-DA#DATED(R2),$DA#DATE_EITYPE
         BO    PIP$EDR1                   Continue
         TM    DA#DATED_FLAG-DA#DATED(R2),$DA#DATE_EISTRL
         BO    PIP$EDR2                   Continue
         TM    DA#DATED_FLAG-DA#DATED(R2),$DA#DATE_EISTR
         BO    PIP$EDR3                   Continue
         MVC   0(7,R15),=C'Unknown'
         LA    R15,8(R15)
         B     PIP$EDRX                   Continue
PIP$EDR1 EQU   *
         MVC   0(12,R15),=C'Invalid type'
         LA    R15,13(R15)
         B     PIP$EDRX                   Continue
PIP$EDR2 EQU   *
         MVC   0(13,R15),=C'String length'
         LA    R15,14(R15)
         B     PIP$EDRX                   Continue
PIP$EDR3 EQU   *
         MVC   0(16,R15),=C'Format of string'
         LA    R15,17(R15)
         B     PIP$EDRX                   Continue
PIP$EDRX EQU   *
         MVI   0(R15),C'"'
         LA    R15,1(R15)
         SLR   R1,R1
         IC    R1,DA#DATED_STRL-DA#DATED(R2)
         BCTR  R1,0
         EX    R1,PIP$EDM
         LA    R15,1(R1,R15)
         MVI   0(R15),C'"'
*
         LA    R8,MS04L                   Set short message length
         BAS   R9,MSG_SET                 Set the message up
         B     PIP$L
PIP$EDM  MVC   0(0,R15),DA#DATED_STR-DA#DATED(R2)
*
** Get date
*
PIP$DATE EQU   *
         MVC   PIP_CDATE(32),0(R2)        Save current date for SHOWDTE
         MVC   W_ODGUS29(C_ODGUS29L),C_ODGUS29
         MVC   W_ODJUL8(C_ODJUL8L),C_ODJUL8
         MVC   W_ODGUS10(C_ODGUS10L),C_ODGUS10
         MVC   W_ODISO10(C_ODISO10L),C_ODISO10
         MVC   W_OTIMEM11(C_OTIMEM11L),C_OTIMEM11
         MVC   W_ODCAL2(C_ODCALCL),C_ODCALC Initialize area
         L     R15,EP_DA$DATE             Locate date routine
         CALL  (15),                      Call date routine            @
               ((2),                      ..Input date                 @
               W_ODGUS29,                 ..output gregorian           @
               W_ODJUL8,                  ..output Julian              @
               W_ODGUS10,                 ..output gregorian           @
               W_ODISO10,                 ..output ISO date            @
               W_OTIMEM11,                ..output Time                @
               W_ODCAL2),                 ..output calendar            @
               VL,MF=(E,PARMLIST)         ..execution area
         LTR   R15,R15                    Looks okay?
         BNZ   PIP$EFMT                   No, continue
         CLI   DA#DATED_FLAG-DA#DATED(R2),0  Looks okay?
         BNE   PIP$EDR                    No, continue
         MVC   OGDATE(29),W_ODGUS29_STR
         MVC   OIDATE(10),W_ODISO10_STR
         MVC   OJDATE(8),W_ODJUL8_STR
*
         TM    FLAG1,$F1TOD               Need time of day?
         BO    PIP$UT2
         MVC   OTIME(11),=CL32' '
         B     PIP$UT2X
PIP$UT2  DS    0H
         MVC   OTIME(11),W_OTIMEM11_STR
         NI    FLAG1,255-$F1TOD           Turn off time of day
PIP$UT2X DS    0H
*
         MVC   PIP_LGDATE(10),W_ODGUS10_STR  Save it
         MVC   PIP_LJDATE(8),W_ODJUL8_STR    Save it
*
         MVI   PC_OATTR,#_WHITE           Get output attribute
         MVC   PC_DATECC(4),W_ODGUS10_STR+6 Get "CCYY" -  "mm/dd/CCYY"
*        MVC   PC_DATEYY(2),W_ODGUS10_STR+8 Get "YY" from "mm/dd/ccYY"
         MVC   PC_DATEMM(2),W_ODGUS10_STR   Get "MM" from "MM/dd/ccyy"
         MVC   PC_DATEDD(2),W_ODGUS10_STR+3 Get "DD" from "mm/DD/ccyy"
*
         LA    R7,W_ODCAL2_STR            Locate calendar
         BAS   R14,PROCESS_CALENDAR       Process the calendar
         BAS   R14,PROCESS_OTHER_CALENDARS  Process the other ones
         B     PIP$L
*
** Common exit from Process_Input_Panel processing
*
PIP$X    EQU   *
         EJECT ,
***********************************************************************
***
**       Termination section
***
***********************************************************************
         SPACE 2
EXIT     DS    0H
*
** Delete modules from memory
*
         TM    FLAG1,$F1LDAD              Did we load it?
         BNO   X$DATEX                    No, leave
         ICM   R0,B'1111',EP_DA$DATE      -> Program Loaded?
         BZ    X$DATEX                    No, continue
         DELETE EPLOC==CL8'DA$DATE'       Delete from V/S
X$DATEX  EQU   *
*
         DELETE EPLOC==CL8'ISPLINK'       Delete from V/S
*
** Exit housekeeping
*
         DA#LEAVE ,                       Exit housekeeping
         EJECT ,
***********************************************************************
***
**       Misc Internal subroutines
***
***********************************************************************
         SPACE 2
*
** Print line on the list dataset
*
PRINT_LISTLINE EQU *
         L     R15,EP_ISPLINK             EPA of ISPLINK
         CALL  (15),                      Call ISPLINK                 @
               (=CL8'LIST',               ..List Dataset call          @
               =CL8'LISTLINE',            ..Variable name              @
               =F'160',                   ..Length to output           @
               =CL8'  ',                  ..PAGE                       @
               =CL8'  ',                  ..SINGLE                     @
               =CL8'  ',                  ..OVERSTRK                   @
               PLL_CC),                   ..Control Character          @
               VL,MF=(E,PARMLIST)
         BSM   0,R9
*
** Clear our messages
*
MSG_CLEAR EQU  *
         LA    R14,ZERRSM
         MVI   0(R14),C' '
         MVC   1(L'ZERRSM-1,R14),0(R14)
*
         LA    R15,ZERRLM
         MVI   0(R15),C' '
         MVC   1(L'ZERRLM-1,R15),0(R15)
         BSM   0,R9
*
** Set message ISRZ002 which uses ZERRSM and ZERRLM
*
MSG_SET  EQU   *
         ST    R8,ZERRSML                 Set short message length
*->      VDEFINE '(ZERRSM)',ZERRSM,CHAR,ZERRSML,MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VDEFINE',       Define variable              @
               =C'(ZERRSM)',              ..Name                       @
               ZERRSM,                    ..Location                   @
               =CL8'CHAR',                ..Format                     @
               ZERRSML),                  ..Length                     @
               VL,MF=(E,PARMLIST)         ..Execute from here
*->      SETMSG MSG='ISRZ002',MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'SETMSG',        Set message                  @
               =CL8'ISRZ002'),            ..Name                       @
               VL,MF=(E,PARMLIST)         ..Execute from here
         BSM   0,R9
         EJECT
***********************************************************************
***
**       Show assembly date of DA$WDATE and DA$DATE
***
***********************************************************************
         SPACE 2
SHOW_ASM_DATE EQU *
         BAS   R9,MSG_CLEAR               Initialize message areas
         MVC   0(8,R15),DA$WDATE_ECNAME   Get "DA$WDATE"
         LA    R15,9(R15)                 Bump past it
         MVC   0(4,R15),31(R12)           Get "Vx.x" from eyecatcher
         LA    R15,5(R15)
         MVC   0(4,R15),=C'asm('
         LA    R15,4(R15)                 Bump past it
         MVC   0(L'DA$WDATE_ECDATE,R15),DA$WDATE_ECDATE
         LA    R15,L'DA$WDATE_ECDATE+1(R15) Bump past it
         MVC   0(L'DA$WDATE_ECTIME,R15),DA$WDATE_ECTIME
         LA    R15,L'DA$WDATE_ECTIME(R15) Bump past it
         MVI   0(R15),C')'
         LA    R15,3(R15)
*
         L     R14,EP_DA$DATE             Locate date routine
         MVC   0(8,R15),DA$WDATE_ECNAME-DA$WDATE(R14)
         LA    R15,9(R15)                 Bump past it
         MVC   0(4,R15),=C'asm('
         LA    R15,4(R15)                 Bump past it
         MVC   0(L'DA$WDATE_ECDATE,R15),DA$WDATE_ECDATE-DA$WDATE(R14)
         LA    R15,L'DA$WDATE_ECDATE+1(R15) Bump past it
         MVC   0(L'DA$WDATE_ECTIME,R15),DA$WDATE_ECTIME-DA$WDATE(R14)
         LA    R15,L'DA$WDATE_ECTIME(R15) Bump past it
         MVI   0(R15),C')'
*
         LA    R8,0                       No short message length
         BAS   R9,MSG_SET                 Set the message up
         B     PIP$ZCRA
         EJECT
***********************************************************************
***
**       Show all date routine output types
***
***********************************************************************
         SPACE 2
SHOW_ALL_DR EQU *
         BAS   R2,SOD$S
T_SOA    DS    0H
         DC    CL8'ODGUS   ',AL2($DA#DATE_ODGUS,$DA#DATE_ODGUS29)
         DC    CL8'ODGUS   ',AL2($DA#DATE_ODGUS,$DA#DATE_ODGUS23)
         DC    CL8'ODGUS   ',AL2($DA#DATE_ODGUS,$DA#DATE_ODGUS18)
         DC    CL8'ODGUS   ',AL2($DA#DATE_ODGUS,$DA#DATE_ODGUS12)
         DC    CL8'ODGUS   ',AL2($DA#DATE_ODGUS,$DA#DATE_ODGUS10)
         DC    CL8'ODGUS   ',AL2($DA#DATE_ODGUS,$DA#DATE_ODGUS8T)
         DC    CL8'ODGUS   ',AL2($DA#DATE_ODGUS,$DA#DATE_ODGUS8)
         DC    CL8'ODGUS   ',AL2($DA#DATE_ODGUS,$DA#DATE_ODGUS6)
*
         DC    CL8'ODGEUR  ',AL2($DA#DATE_ODGEUR,$DA#DATE_ODGEUR29)
         DC    CL8'ODGEUR  ',AL2($DA#DATE_ODGEUR,$DA#DATE_ODGEUR23)
         DC    CL8'ODGEUR  ',AL2($DA#DATE_ODGEUR,$DA#DATE_ODGEUR18)
         DC    CL8'ODGEUR  ',AL2($DA#DATE_ODGEUR,$DA#DATE_ODGEUR11)
         DC    CL8'ODGEUR  ',AL2($DA#DATE_ODGEUR,$DA#DATE_ODGEUR10)
         DC    CL8'ODGEUR  ',AL2($DA#DATE_ODGEUR,$DA#DATE_ODGEUR8T)
         DC    CL8'ODGEUR  ',AL2($DA#DATE_ODGEUR,$DA#DATE_ODGEUR8)
         DC    CL8'ODGEUR  ',AL2($DA#DATE_ODGEUR,$DA#DATE_ODGEUR6)
*
         DC    CL8'ODJUL   ',AL2($DA#DATE_ODJUL,$DA#DATE_ODJUL8)
         DC    CL8'ODJUL   ',AL2($DA#DATE_ODJUL,$DA#DATE_ODJUL6)
         DC    CL8'ODJUL   ',AL2($DA#DATE_ODJUL,$DA#DATE_ODJUL5)
         DC    CL8'ODJUL   ',AL2($DA#DATE_ODJUL,$DA#DATE_ODJUL3)
*
         DC    CL8'ODISO   ',AL2($DA#DATE_ODISO,$DA#DATE_ODISO10)
T_SOAN   EQU   (*-T_SOA)/TSOAL
SOD$S    DS    0H
         LA    R3,T_SOAN
         MVC   PLL_CC(2),TSOA_T-TSOA(R2)   Get line break value
SOD$L    DS    0H
         LA    R4,W_ODGUS29
         MVC   DA#DATED_TYPE-DA#DATED(2,R4),TSOA_T-TSOA(R2)
         XC    DA#DATED_FLAG-DA#DATED(1,R4),DA#DATED_FLAG-DA#DATED(R4)
         MVC   DA#DATED_STRL-DA#DATED(1,R4),TSOA_L+1-TSOA(R2)
         L     R15,EP_DA$DATE             Locate date routine
         CALL  (15),                      Call date routine            @
               (PIP_CDATE,                ..Input date entry           @
               W_ODGUS29),                ..Output date entry          @
               VL,MF=(E,PARMLIST)         ..execution area
         LA    R15,LISTLINE
         MVI   0(R15),C' '
         MVC   1(78,R15),0(R15)
         MVC   0(L'TSOA_N,R15),TSOA_N-TSOA(R2)
         LA    R15,L'TSOA_N+1(R15)
         MVC   0(7,R15),=C'Length='
         LA    R15,7(R15)
         SLR   R1,R1
         ICM   R1,B'0011',TSOA_L-TSOA(R2)
         BAS   R9,EDITFWF
*
         LA    R15,LISTLINE+20
         MVC   0(5,R15),=C'Flag='
         LA    R15,5(R15)
         UNPK  0(3,R15),DA#DATED_FLAG-DA#DATED(2,R4)
         MVZ   0(2,R15),=8X'00'
         TR    0(2,R15),=C'0123456789ABCDEF'
         MVI   2(R15),C' '
         LA    R15,3(R15)
*
         SLR   R1,R1
         IC    R1,DA#DATED_STRL-DA#DATED(R4)
         BCTR  R1,0
         EX    R1,SOD$M
         TPUT  LISTLINE,79
         LA    R2,TSOAL(R2)
         CLC   TSOA_T-TSOA(2,R2),PLL_CC
         BE    SOD$B
         MVI   LISTLINE,C' '
         TPUT  LISTLINE,1
         MVC   PLL_CC(2),TSOA_T-TSOA(R2)   Get line break value
SOD$B    DS    0H
         BCT   R3,SOD$L
         B     PIP$ZCRA
SOD$M    MVC   0(0,R15),DA#DATED_STR-DA#DATED(R4)
         EJECT
***********************************************************************
***
**       Produce a YOAP - a UNIX weenie thing
***
***********************************************************************
         SPACE 2
YEAR_ON_A_PAGE EQU *
         MVC   YOAP_DATE(8),PC_DATE       Save current year
         MVC   PC_DATE(4),W_ODJUL8_STR    Ensure the year is right
*
** Are we going to be normal or sideways
*
         LTR   R2,R2                      Anything there?
         BZ    YOAP$ISX                   No, assume normal
         BM    YOAP$ISX                   No, assume normal
         CLI   0(R3),C'S'                 Looks like "YOAP SIDEWAYS"?
         BNE   YOAP$ISX                   No, continue
         OI    YOAP_F1,$YF1_SIDEW         Yes, set flag
YOAP$ISX EQU   *
*
** Create headings for sideways calendar printing
*
         TM    YOAP_F1,$YF1_SIDEW         Sideways?
         BNO   YOAP$SHX                   No, continue
         MVI   LISTLINE,C' '
         MVC   LISTLINE+1(L'LISTLINE-1),LISTLINE
         MVC   LISTLINE(13),=C'1Calendar for'
         MVC   LISTLINE+14(4),PC_DATECC
         MVC   PLL_CC(2),=C'CC'
         BAS   R9,PRINT_LISTLINE
         MVC   PLL_CC(2),=CL8' '
*
         MVI   LISTLINE,C' '
         MVC   LISTLINE+1(L'LISTLINE-1),LISTLINE
         BAS   R9,PRINT_LISTLINE
*
         MVI   LISTLINE,C' '
         MVC   LISTLINE+1(L'LISTLINE-1),LISTLINE
         LA    R15,LISTLINE+5
         LA    R1,$DA#DATE_ODCALC_WEEKN-3
         LA    R14,W_ODCAL1_STR+$DA#DATE_ODCALC_WEEKL
YOAP$HL  EQU   *
         MVC   0($DA#DATE_ODCALC_WEEKL,R15),0(R14)
         LA    R15,$DA#DATE_ODCALC_WEEKL(R15)
         BCT   R1,YOAP$HL
         BAS   R9,PRINT_LISTLINE
         B     YOAP$LS
YOAP$SHX EQU   *
YOAP$Y   EQU   *
*
** Initialize for regular YOAP
*
         LA    R4,YOAP_MONTHS             Locate table
         MVI   PC_OATTR,#_BLUE            Get output attribute
         OI    PC_FLAG1,$PCF1_POC         POC mode
*->      VDEFINE '(YEAR)',PC_DATECC,CHAR,4,MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VDEFINE',       Define variable              @
               =C'(YEAR)',                ..Name                       @
               PC_DATECC,                 ..Location                   @
               =CL8'CHAR',                ..Format                     @
               =F'4'),                    ..Length                     @
               VL,MF=(E,PARMLIST)         ..Execute from here
*
** Loop thru months for the year
*
YOAP$LS  EQU   *
         LA    R2,T_MONTH
         LA    R3,1
YOAP$L   EQU   *
         MVC   W_IDGUS8(C_IDGUS8L),C_IDGUS8
         MVC   W_IDGUS8_STR(2),TMD_MM-TMD(R2)
         MVC   W_IDGUS8_STR+2(2),=C'01'
         MVC   W_IDGUS8_STR+4(4),PC_DATECC
         MVC   W_ODCALY(C_ODCALCNDL),C_ODCALCND Initialize area
         L     R15,EP_DA$DATE             Locate date routine
         CALL  (15),                      Call date routine            @
               (W_IDGUS8,                 ..Input date                 @
               W_ODCALY),                 ..output calendar            @
               VL,MF=(E,PARMLIST)         ..execution area
*
         TM    YOAP_F1,$YF1_SIDEW         Sideways?
         BNO   YOAP$LSX                   No, continue
#YOAPDO  EQU   2*$DA#DATE_ODCALC_WEEKL
#YOAPML  EQU   $DA#DATE_ODCALC-$DA#DATE_ODCALC_WEEKL
         MVI   LISTLINE,C' '
         MVC   LISTLINE+1(L'LISTLINE-1),LISTLINE
         MVC   LISTLINE+1(3),W_ODCALY_STR+1 Get month name
         OC    LISTLINE+1(3),=C'   '        Make upper case
         MVC   LISTLINE+5(#YOAPML),W_ODCALY_STR+#YOAPDO
         BAS   R9,PRINT_LISTLINE
         B     YOAP$LB                     Continue
YOAP$LSX EQU   *
         CVD   R3,DOUBLE                  Convert month to packed
         UNPK  DOUBLE2(4),DOUBLE+4(4)     Convert packed to zoned
         OI    DOUBLE2+3,C'0'             Fix sign byte
         MVC   PC_DATEMM(2),DOUBLE2+2     Get new month
         STM   R2,R4,YOAP_SREGS           Save registers
         LA    R7,W_ODCALY_STR            Locate calendar
         BAS   R14,PROCESS_CALENDAR       Process the calendar
         LM    R2,R4,YOAP_SREGS           Restore registers
         MVC   0($DA#DATE_ODCALC,R4),W_ODCALY_STR
         MVC   $DA#DATE_ODCALC_WEEKL-4(4,R4),=CL8' ' Blank out year
         LA    R4,$DA#DATE_ODCALC(R4)     Bump to next month
*
YOAP$LB  EQU   *
         LA    R2,TMDL(R2)                Process next month
         LA    R3,1(R3)                   Continue
         CH    R3,=H'12'                  At the end?
         BNH   YOAP$L
*
** Termination for Sideways print
*
         TM    YOAP_F1,$YF1_SIDEW         Sideways?
         BNO   YOAP$STX                   No, continue
         BAS   R9,MSG_CLEAR               Initialize message areas
         MVC   0(MS06L,R14),MS06          Get short message
         MVC   0(ML06L,R15),ML06          Get long message prefix
         LA    R8,MS06L                   Set short message length
         BAS   R9,MSG_SET                 Set the message up
         B     YOAP$X                     Leave this party
YOAP$STX EQU   *
*
** Normal YOAP
*
         NI    PC_FLAG1,255-$PCF1_POC     POC mode
         OI    YOAP_F1,$YF1_TOP           At the top of the calendar
YOAP$DT  EQU   *
         LA    R4,YOAP_MONTHS
YOAP$DTX EQU   *
         LA    R2,6
         LA    R3,=C'(CALY1)(CALY2)(CALY3)(CALY4)(CALY5)(CALY6)'
YOAP$DSL EQU   *
*        VDEFINE 0(R3),0(R4),CHAR,                Calendar            @
*              =AL4($DA#DATE_ODCALC),MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VDEFINE',       Define variable              @
               (3),                       ..Name                       @
               (4),                       ..Location                   @
               =CL8'CHAR',                ..Format                     @
               =AL4($DA#DATE_ODCALC)),    ..Length                     @
               VL,MF=(E,PARMLIST)         ..Execute from here
         LA    R3,7(R3)                   Bump to next "(CALY?)"
         LA    R4,$DA#DATE_ODCALC(R4)     Bump to next month
         BCT   R2,YOAP$DSL
YOAP$DL  EQU   *
*->      DISPLAY PANEL==CL8'DA$WDATY',MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'DISPLAY',       Service: Display             @
               =CL8'DA$WDATY'),           ..Panel name                 @
               VL,MF=(E,PARMLIST)         ..Execute from here
         LTR   R15,R15
         BNZ   YOAP$X
*
*->      VCOPY '(ZVERB)',ZVERBL,ZVERBA,LOCATE,MF=E
         L     R15,EP_ISPLINK             -> EPA ISPLINK
         CALL  (15),(=CL8'VCOPY',         Service: VCOPY               @
               =C'(ZVERB)',               ..Name                       @
               ZVERBL,                    ..Length                     @
               ZVERBA,                    ..Location                   @
               =CL8'LOCATE'),             ..Type: Move or copy         @
               VL,MF=(E,PARMLIST)         ..Execute from here
         ICM   R1,B'1111',ZVERBA
         BZ    YOAP$DL
         ICM   R0,B'1111',ZVERBL
         BZ    YOAP$DL
         CH    R0,=H'2'                   At least 2?
         BL    YOAP$DL
         CLC   0(2,R1),=C'UP'             UP?
         BE    YOAP$DLU
         CLC   0(2,R1),=C'DO'             Down?
         BE    YOAP$DLD
         CLC   0(2,R1),=C'RI'             Right?
         BE    YOAP$DRI
         CLC   0(2,R1),=C'LE'             Left?
         BE    YOAP$DLE
         B     YOAP$DL
YOAP$DLU EQU   *
         TM    YOAP_F1,$YF1_TOP           Already there?
         BO    YOAP$DL                    Yes, continue
         OI    YOAP_F1,$YF1_TOP           Set at the top
         B     YOAP$DT                    And show the top
YOAP$DLD EQU   *
         TM    YOAP_F1,$YF1_TOP           At the top?
         BNO   YOAP$DL                    No, we are at the bottom
         NI    YOAP_F1,255-$YF1_TOP       Set at the top
         LA    R4,YOAP_MONTHS+(6*$DA#DATE_ODCALC) Locate last 6 months
         B     YOAP$DTX
YOAP$DRI EQU   *
         PACK  DOUBLE(8),PC_DATECC(4)     Make century.year packed
         CVB   R15,DOUBLE                 Make it binary
         LA    R15,1(R15)                 Reelin' in the years
         B     YOAP$DLEC
YOAP$DLE EQU   *
         PACK  DOUBLE(8),PC_DATECC(4)     Make century.year packed
         CVB   R15,DOUBLE                 Make it binary
         SH    R15,=H'1'                  Reelin' in the years
YOAP$DLEC EQU  *
         CVD   R15,DOUBLE                 Convert back to packed
         UNPK  DOUBLE2(4),DOUBLE+4(4)     Convert packed to zoned
         OI    DOUBLE2+3,C'0'             Fix sign byte
         MVC   PC_DATECC(4),DOUBLE2
         B     YOAP$Y
*
** End of YOAP processing
*
YOAP$X   EQU   *
         MVC   PC_DATE(8),YOAP_DATE       Restore date on entry
         B     PIP$ZCRA
         EJECT ,
***********************************************************************
***
**       Process other calendars
***
***********************************************************************
         SPACE 2
PROCESS_OTHER_CALENDARS EQU *
         ST    R14,POC_RA
         MVC   POC_DATE(8),PC_DATE        Save current year
         OI    PC_FLAG1,$PCF1_POC         POC mode
*
** Find month in table
*
         LA    R1,T_MONTH                 Locate month table
         LA    R0,12-1                    Number of months in year
POC$L    EQU   *
         CLC   TMD_MM-TMD(2,R1),PC_DATEMM Match?
         BE    POC$LX                     Yes, continue
         LA    R1,TMDL(R1)                No, continue
         BCT   R0,POC$L                   Process next month
POC$LX   EQU   *
*
** Process previous month
*
         SH    R1,=AL2(TMDL)              Backup to previous month
         MVC   PC_DATEMM(2),TMD_MM-TMD(R1) Save new month
         CLI   TMD_YEAR-TMD(R1),C'C'      Current year?
         BE    POC$C1YX                   Yes, continue
         PACK  DOUBLE(8),PC_DATECC(4)     Make packed
         CVB   R15,DOUBLE                 Make it binary
         SH    R15,=H'1'                  Reelin' in the years
         CVD   R15,DOUBLE                 Convert back to packed
         UNPK  PC_DATECC(4),DOUBLE+4(4)   Convert packed to zoned
         OI    PC_DATECC+3,C'0'           Fix sign byte
         MVC   PC_DATEMM(4),=C'1201'      Fix month date
POC$C1YX EQU   *
         AH    R1,=AL2(2*TMDL)
         ST    R1,POC_NEXT
         MVC   W_IDGUS10(C_IDGUS10L),C_IDGUS10 Initialize
*              "MM/DD/CCYY"      "CCYYMMDD"
         MVC   W_IDGUS10_STR+6(4),PC_DATECC
*        MVC   W_IDGUS10_STR+8(2),PC_DATEYY
         MVC   W_IDGUS10_STR(2),PC_DATEMM
         MVC   W_IDGUS10_STR+3(2),PC_DATEDD
         MVI   W_IDGUS10_STR+2,C'/'
         MVI   W_IDGUS10_STR+5,C'/'
         MVC   W_ODCAL1(C_ODCALCNDL),C_ODCALCND Initialize area
*TPUT PC_DATE,8
*TPUT W_IDGUS10_STR,10
         L     R15,EP_DA$DATE             Locate date routine
         CALL  (15),                      Call date routine            @
               (W_IDGUS10,                ..output gregorian           @
               W_ODCAL1),                 ..output calendar            @
               VL,MF=(E,PARMLIST)         ..execution area
         MVI   PC_OATTR,#_BLUE            Get output attribute
         LA    R7,W_ODCAL1_STR            Locate calendar
         BAS   R14,PROCESS_CALENDAR       Process the calendar
*
** Process next month
*
         L     R1,POC_NEXT                Locate next month entry
         MVC   PC_DATE(4),POC_DATE        Start with a good year
         MVC   PC_DATEMM(2),TMD_MM-TMD(R1)
         CLI   TMD_YEAR-TMD(R1),C'C'      Current year?
         BE    POC$C2YX
         PACK  DOUBLE(8),PC_DATECC(4)     Make packed
         CVB   R15,DOUBLE                 Make it binary
         AH    R15,=H'1'                  Happy new year
         CVD   R15,DOUBLE                 Convert back to packed
         UNPK  PC_DATECC(4),DOUBLE+4(4)   Convert packed to zoned
         OI    PC_DATECC+3,C'0'           Fix sign byte
         MVC   PC_DATEMM(4),=C'0101'      Fix month date
POC$C2YX EQU   *
         MVC   W_IDGUS10(C_IDGUS10L),C_IDGUS10 Initialize
*              "MM/DD/CCYY"      "CCYYMMDD"
         MVC   W_IDGUS10_STR+6(4),PC_DATECC
*        MVC   W_IDGUS10_STR+8(2),PC_DATEYY
         MVC   W_IDGUS10_STR(2),PC_DATEMM
         MVC   W_IDGUS10_STR+3(2),PC_DATEDD
         MVI   W_IDGUS10_STR+2,C'/'
         MVI   W_IDGUS10_STR+5,C'/'
         MVC   W_ODCAL3(C_ODCALCNDL),C_ODCALCND Initialize area
*TPUT PC_DATE,8
*TPUT W_IDGUS10_STR,10
         L     R15,EP_DA$DATE             Locate date routine
         CALL  (15),                      Call date routine            @
               (W_IDGUS10,                ..output gregorian           @
               W_ODCAL3),                 ..output calendar            @
               VL,MF=(E,PARMLIST)         ..execution area
         LA    R7,W_ODCAL3_STR            Locate calendar
         BAS   R14,PROCESS_CALENDAR       Process the calendar
*
** Return to caller
*
         NI    PC_FLAG1,255-$PCF1_POC     POC mode
         MVC   PC_DATE(8),POC_DATE        Restore
         L     R14,POC_RA                 Get return address
         BSM   0,R14                      Return to caller
         EJECT ,
***********************************************************************
***
**       Misc subroutines
***
***********************************************************************
         SPACE 2
*
** Process Calendar for days
** Input: R7 has address of the calendar from DA$DATE
*
PROCESS_CALENDAR DS 0H
*-Code removed 02-SEP-1999  This code use to process the calendar
*-and indicate IPL dates, company holidays, etc.
         BSM   0,R14
*
** Edit full word in Register 1 flush at location in Register 15
** INPUT: R1 - Register to print
**        R15 - Address to put number
*
EDITFWF  EQU   *
         LTR   R1,R1                      Check for 0
         BZ    EDITFWF0                   Yes, put zero
         CVD   R1,DOUBLE                  No, convert to packec
         LA    R1,DOUBLE2+14              Locate sig digit
         MVC   DOUBLE2(15),EDITFWFP
         EDMK  DOUBLE2(15),DOUBLE+2       Edit and save place
         LA    R14,DOUBLE2+16             Locate last possible byte + 1
         SR    R14,R1                     Length = end - start
         BCTR  R14,0                      Decrement for ex
         EX    R14,EDITFWFM               Move edit number to output
         LA    R15,0(R14,R15)             Bump pointer past number
         MVI   0(R15),C' '
         BSM   0,R9                       Return to caller
EDITFWFM MVC   0(0,R15),0(R1)
EDITFWFP DC    X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'
EDITFWF0 DS    0H
         MVI   0(R15),C'0'                Put in zero
         LA    R15,1(R15)                 Bump pointer past zero
         BSM   0,R9                       Return to caller
         EJECT ,
***********************************************************************
***
**       Constants
***
***********************************************************************
         SPACE 2
*
** Months
*
         DC    C'12',C'P'
T_MONTH  DS    0H
         DC    C'01',C'C'
         DC    C'02',C'C'
         DC    C'03',C'C'
         DC    C'04',C'C'
         DC    C'05',C'C'
         DC    C'06',C'C'
         DC    C'07',C'C'
         DC    C'08',C'C'
         DC    C'09',C'C'
         DC    C'10',C'C'
         DC    C'11',C'C'
         DC    C'12',C'C'
         DC    C'01',C'N'
         DS    0H
*
** ZCMD Verb table
**
** The max verb length is 7 given the current logic (trailing blank)
*
T_ZCMDV  EQU   *
         DC    AL1(4-1),CL8'YOAP   ',AL2(YEAR_ON_A_PAGE-DA$WDATE)
         DC    AL1(3-1),CL8'YOP    ',AL2(YEAR_ON_A_PAGE-DA$WDATE)
         DC    AL1(4-1),CL8'YEAR   ',AL2(YEAR_ON_A_PAGE-DA$WDATE)
         DC    AL1(8-1),CL8'ASMDATE',AL2(SHOW_ASM_DATE-DA$WDATE)
         DC    AL1(8-1),CL8'SHOWALL',AL2(SHOW_ALL_DR-DA$WDATE)
T_ZCMDVN EQU   (*-T_ZCMDV)/TZCCL
*
** Messages
*
MS00     EQU   * ....+....1....+....2....|        Maximum short length
MS01     DC    C'Today''s Date'
MS01L    EQU   *-MS01
ML01     DC    C'Today''s date is shown below'
ML01L    EQU   *-ML01
MS02     DC    C'Input date not given'
MS02L    EQU   *-MS02
ML02     DC    C'You must give an input date: Gregorian, Julian, etc'
ML02L    EQU   *-ML02
MS03     DC    C' '    <- Ready for use
MS03L    EQU   *-MS03
ML03     DC    C' '    <- Ready for use
ML03L    EQU   *-ML03
MS04     DC    C'Input format error'
MS04L    EQU   *-MS04
ML04     DC    C'The input field is formatted incorrectly, check '
         DC    C'the template for format'
ML04L    EQU   *-ML04
MS05     DC    C'Verb Invalid'
MS05L    EQU   *-MS05
MS06     DC    C'Calendar created'
MS06L    EQU   *-MS06
ML06     DC    C'Your calendar is in the LIST ISPF dataset'
ML06L    EQU   *-ML06
MS07     DC    C'Routine error'
MS07L    EQU   *-MS07
ML07     DC    C'Could not find or load the required date routine: '
         DC    CL8'DA$DATE'
ML07L    EQU   *-ML07
*
** Date routine
*
C_ODCALC   DA#DATE DPE,OPREFIX=C_ODCALC,OSTR=NO,                       @
               OSTRL=$DA#DATE_ODCALC,OTYPE=$DA#DATE_ODCAL
C_ODCALCND DA#DATE DPE,OPREFIX=C_ODCALCND,OSTR=NO,                     @
               OSTRL=$DA#DATE_ODCALC,OTYPE=$DA#DATE_ODCALND
C_IDJULP4A DA#DATE DPE,OPREFIX=C_IDJULP4A,                             @
               OSTR=NO,OFLAG=$DA#DATE_ADDR,                            @
               OSTRL=$DA#DATE_IDJULP4,OTYPE=$DA#DATE_IDJULP
C_ODGUS10  DA#DATE DPE,OPREFIX=C_ODGUS10,OSTR=NO,                      @
               OSTRL=$DA#DATE_ODGUS10,OTYPE=$DA#DATE_ODGUS
C_IDGUS10  DA#DATE DPE,OPREFIX=C_IDGUS10,OSTR=NO,                      @
               OSTRL=$DA#DATE_IDGUS10,OTYPE=$DA#DATE_IDGUS
C_ODISO10  DA#DATE DPE,OPREFIX=C_ODISO10,OSTR=NO,                      @
               OSTRL=$DA#DATE_ODISO10,OTYPE=$DA#DATE_ODISO
C_IDISO10  DA#DATE DPE,OPREFIX=C_IDISO10,OSTR=NO,                      @
               OSTRL=$DA#DATE_IDISO10,OTYPE=$DA#DATE_IDISO
C_IDGUS8   DA#DATE DPE,OPREFIX=C_IDGUS8,OSTR=NO,                       @
               OSTRL=$DA#DATE_IDGUS8,OTYPE=$DA#DATE_IDGUS
C_ODGUS29  DA#DATE DPE,OPREFIX=C_ODGUS29,OSTR=NO,                      @
               OSTRL=$DA#DATE_ODGUS29,OTYPE=$DA#DATE_ODGUS
C_ODJUL8   DA#DATE DPE,OPREFIX=C_ODJUL8,OSTR=NO,                       @
               OSTRL=$DA#DATE_ODJUL8,OTYPE=$DA#DATE_ODJUL
C_IDJULC6  DA#DATE DPE,OPREFIX=C_IDJULC6,OSTR=NO,                      @
               OSTRL=$DA#DATE_IDJULC6,OTYPE=$DA#DATE_IDJULC
C_IDJULC8  DA#DATE DPE,OPREFIX=C_IDJULC8,OSTR=NO,                      @
               OSTRL=$DA#DATE_IDJULC8,OTYPE=$DA#DATE_IDJULC
C_ISTMPC16 DA#DATE DPE,OPREFIX=C_ISTMPC16,OSTR=NO,                     @
               OSTRL=$DA#DATE_ISTMPC16,OTYPE=$DA#DATE_ISTMPC
C_OTIMEM11 DA#DATE DPE,OPREFIX=C_OTIMEM11,OSTR=NO,                     @
               OSTRL=$DA#DATE_OTIMEM11,OTYPE=$DA#DATE_OTIMEM
             DS  0F
*
** Literals
*
LTORG    EQU   *
         LTORG ,
LTORGL   EQU   *-LTORG
         DS    0D                         End of CSECT
*
** Determine length left addressible in main (DA$WDATE) CSECT
*
#DA$WDATE EQU  *-DA$WDATE                 Bytes used
#DA$WDATE_LEFT EQU (4096*3)-#DA$WDATE     Bytes left
         EJECT ,
***********************************************************************
***
**       Dynamic Save Area
***
***********************************************************************
 SPACE 2
DSA         DSECT ,
            DS    18F                     Register Save Area
            DS    0D
DOUBLE2     DS    2D                      Double word work area * 2
DOUBLE      DS    D                       Double word work area
PARMLIST    DS    20F                     Parameter list for calls
R1SAVE      DS    F
            DS    0F                      Process_Calendar
PC_RA       DS    F                       ..Return address
PC_DATE     EQU   *                       ..Current date
PC_DATECC   DS    C'CC'                   ....Century
PC_DATEYY   DS    C'YY'                   ....Year
PC_DATEMM   DS    C'MM'                   ....Month
PC_DATEDD   DS    C'DD'                   ....Day
PC_IPLD     DS    C'mm/dd/CCYY'           ..IPL Date
PC_OATTR    DS    X                       ..Output attribute: #_????
PC_FLAG1    DS    B'00000000'             ....Flag 1
$PCF1_ID    EQU   B'10000000'             ....IPL Date formated?
$PCF1_F     EQU   B'01000000'             ....IPL Date found?
$PCF1_POC   EQU   B'00100000'             ....POC mode?
$PCF1_TODAY EQU   B'00010000'             ....POC mode?
            DS    0F                      Process_Other_Calendars
POC_RA      DS    F                       ..Return address
POC_NEXT    DS    F                       ..Next TMD entry
POC_DATE    DS    C'ccyymmdd'             ..Date on entry
            DS    0F                      Year_On_A_Page
YOAP_SREGS  DS    3F                      ..Save registers
YOAP_DATE   DS    C'ccyymmdd'             ..Date on entry
YOAP_F1     DS    B'00000000'             ..Flag 1
$YF1_SIDEW  EQU   B'10000000'             ....Sideways Calendar?
$YF1_TOP    EQU   B'01000000'             ....Top of calendars?
YOAP_MONTHS DS    XL(12*$DA#DATE_ODCALC)  ..Months for calendar
            DS    0H                      Print_ListLine
PLL_CC      DS    CL8' '                  ..Control Character?
            DS    0F                      Process_Input_Panel
PIP_CDATE   DS    XL32                    ..Current date pointer
PIP_CURSOR  DS    CL8                     ..Cursor field name
PIP_LGDATE  DS    CL10'mm/dd/ccyy'        ..Last gregorian date
PIP_LJDATE  DS    CL8'yyyy.ddd'           ..Last Julian date
            DS    0F                      Entry_Point
EP_DA$DATE  DS    F                      ..DA$DATE
EP_ISPLINK  DS    F                      ..DA$DATE
*
** Flag
*
FLAG1       DS    B'00000000'             Flag 1
$F1LDAD     EQU   B'10000000'             ..Loaded DA$DATE
$F1TOD      EQU   B'01000000'             ..TOD (need output time?)
*
** ISPF variables
*
IVARS       EQU   *
IDATE       DS    CL32' '                 Input date
IVARSL      EQU   *-IVARS
*
OGDATE      DS    CL32' '                 Output full date
OJDATE      DS    C'ccyy.ddd'             Output julian date
OTIME       DS    C'hh:mm:ss.th'          Output julian date
OIDATE      DS    C'ccyy-mm-dd'           Output ISO date
*
ZERRSML     DS    F                       Short error message length
ZERRSM      DS    CL24                    Short error message
ZERRLM      DS    CL160                   Long error message
ZERRHM      DS    CL8                     Message help member
ZERRALRM    DS    CL3                     Alarm
            DS    0F
ZVERBA      DS    F                       Address of ZVERB variable
ZVERBL      DS    F                       Length of ZVERB variable
*
ZCMDL       DS    F                       ZCMD length
ZCMDA       DS    F                       ZCMD address
*
** Date routine areas
*
         DS    0F
W_ODCAL1    DA#DATE DPE,OPREFIX=W_ODCAL1,OSTR=YES,                     @
               OSTRL=$DA#DATE_ODCALC,OTYPE=$DA#DATE_ODCAL
W_ODCAL2    DA#DATE DPE,OPREFIX=W_ODCAL2,OSTR=YES,                     @
               OSTRL=$DA#DATE_ODCALC,OTYPE=$DA#DATE_ODCAL
W_ODCAL3    DA#DATE DPE,OPREFIX=W_ODCAL3,OSTR=YES,                     @
               OSTRL=$DA#DATE_ODCALC,OTYPE=$DA#DATE_ODCAL
W_ODCALY    DA#DATE DPE,OPREFIX=W_ODCALY,OSTR=YES,                     @
               OSTRL=$DA#DATE_ODCALC,OTYPE=$DA#DATE_ODCAL
W_IDJULP4A  DA#DATE DPE,OPREFIX=W_IDJULP4A,OSTR=YES,OSTRL=4
W_ODGUS10   DA#DATE DPE,OPREFIX=W_ODGUS10,OSTR=YES,                    @
               OSTRL=$DA#DATE_ODGUS10,OTYPE=$DA#DATE_ODGUS
W_IDGUS10   DA#DATE DPE,OPREFIX=W_IDGUS10,OSTR=YES,                    @
               OSTRL=$DA#DATE_IDGUS10,OTYPE=$DA#DATE_IDGUS
W_ODISO10   DA#DATE DPE,OPREFIX=W_ODISO10,OSTR=YES,                    @
               OSTRL=$DA#DATE_ODISO10,OTYPE=$DA#DATE_ODISO
W_IDISO10   DA#DATE DPE,OPREFIX=W_IDISO10,OSTR=YES,                    @
               OSTRL=$DA#DATE_IDISO10,OTYPE=$DA#DATE_IDISO
W_IDGUS8    DA#DATE DPE,OPREFIX=W_IDGUS8,OSTR=YES,                     @
               OSTRL=$DA#DATE_IDGUS8,OTYPE=$DA#DATE_IDGUS
W_ODGUS29   DA#DATE DPE,OPREFIX=W_ODGUS29,OSTR=YES,                    @
               OSTRL=$DA#DATE_ODGUS29,OTYPE=$DA#DATE_ODGUS
W_ODJUL8    DA#DATE DPE,OPREFIX=W_ODJUL8,OSTR=YES,                     @
               OSTRL=$DA#DATE_ODJUL8,OTYPE=$DA#DATE_ODJUL
W_IDJULC6   DA#DATE DPE,OPREFIX=W_IDJULC6,OSTR=YES,                    @
               OSTRL=$DA#DATE_IDJULC6,OTYPE=$DA#DATE_IDJULC
W_IDJULC8   DA#DATE DPE,OPREFIX=W_IDJULC8,OSTR=YES,                    @
               OSTRL=$DA#DATE_IDJULC8,OTYPE=$DA#DATE_IDJULC
W_ISTMPC16  DA#DATE DPE,OPREFIX=W_ISTMPC16,OSTR=YES,                   @
               OSTRL=$DA#DATE_ISTMPC16,OTYPE=$DA#DATE_ISTMPC
W_OTIMEM11 DA#DATE DPE,OPREFIX=W_OTIMEM11,OSTR=NO,                     @
               OSTRL=$DA#DATE_OTIMEM11,OTYPE=$DA#DATE_OTIMEM
*
LISTLINE    DS    CL160
            DS    CL512
*
** End of the DSECT
*
         DS    0D                         Alignment for FREEMAIN
DSAL     EQU   *-DSA
         EJECT ,
***********************************************************************
***
**       DSECTs and equates
***
***********************************************************************
         SPACE 2
*
** Map T_MONTH table
*
TMD      DSECT ,
TMD_MM   DS    CL2
TMD_YEAR DS    C
TMDL     EQU   *-TMD
*
** Map T_HCALD
*
THCAL        DSECT ,
THCAL_CC     DS    C'CC'
THCAL_YY     DS    C'YY'
THCAL_MM     DS    C'MM'
THCAL_DD     DS    C'DD'
THCAL_COLOR  DS    X                      ..Colour
THCAL_DESC   DS    AL2(*-*)               ..Offset of description str
THCALL       EQU   *-THCAL
*
** T_ZCMDV table entry mapping
*
TZCC        DSECT ,
TZCC_MINL   DS    X                       Minimum length: "Verb oper"
TZCC_VERB   DS    CL8                     Verb
TZCC_ROUTO  DS    AL2                     Routine offset
TZCCL       EQU   *-TZCC
*
** Colors on DA$WDAT_ ISPF panels
*
#_BLUE   EQU 01                           Colour: blue
#_WHITE  EQU 02                           Colour: white
#_YELLOW EQU 03                           Colour: yellow
#_TURQ   EQU 04                           Colour: turq
#_RED    EQU 05                           Colour: red
#_GREEN  EQU 06                           Colour: red
*
#_BLUEB  EQU 11                           Colour: blue   Attr: Blink
#_WHITEB EQU 12                           Colour: white  Attr: Blink
#_YELLOWB EQU 13                          Colour: yellow Attr: Blink
#_TURQB  EQU 14                           Colour: turq   Attr: Blink
#_REDB   EQU 15                           Colour: red    Attr: Blink
#_GREENB EQU 16                           Colour: Green  Attr: Blink
*
** Map the T_SOA table
*
TSOA     DSECT ,
TSOA_N   DS    CL8'        '
TSOA_T   DS    XL2
TSOA_L   DS    XL2
TSOAL    EQU   *-TSOA
*
** Non-IBM DSECTs and equates
*
         DA#DATE ,                        Date routine
*
** IBM DSECTs and equates
*
         CVT   DSECT=YES,LIST=NO          MVS CVT
         IEESMCA ,                        SMF control area
         IKJCPPL ,
         END   ,
         SPACE 2
***********************************************************************
***
**        Linkage editor cards - ASM.PARM='BATCH,...'
***
***********************************************************************
         SPACE 2
 PUNCH ' ENTRY   DA$WDATE         '       Entry point
 PUNCH ' INCLUDE SYSLMOD(DA$DATE) '       Subroutine: Date routine
 PUNCH ' NAME    DA$WDATE(R)      '       Name of load module
         END ,
./ ADD NAME=DA$WDATM 0102-01283-01283-1344-00060-00055-00000-DALCOCK
)attr default(%+_)
 /********************************************************************/
 /* Name: DA$WDATM                                                   */
 /* Application: WHATDATE (DA$WDATE)                                 */
 /* Author: David Alcock                                             */
 /* Purpose: Do date conversions                                     */
 /********************************************************************/
 # type(text) intens(high) color(yellow)
 Â¢ type(text) intens(low)  color(green)
 Â¬ type(text) intens(low)  color(green) hilite(reverse)
 ` type(text) intens(high) color(yellow)
 ~ type(text) intens(low)  color(turq)
 { type(output) intens(high) color(yellow) caps(off)
 } type(output) intens(high) color(turq)   caps(off)
 Â¦ area(dynamic) scroll(on)
 ? area(dynamic)
 01 type(dataout) color(blue)
 02 type(dataout) color(white)  intens(high)
 03 type(dataout) color(yellow) intens(high)
 04 type(dataout) color(turq)   intens(high)
 05 type(dataout) color(red)    intens(high)
 06 type(dataout) color(green)  intens(high)
 0B type(dataout) color(blue)                 hilite(blink)
 0C type(dataout) color(white)  intens(high)  hilite(blink)
 0D type(dataout) color(yellow) intens(high)  hilite(blink)
 0E type(dataout) color(turq)   intens(high)  hilite(blink)
 0F type(dataout) color(red)    intens(high)  hilite(blink)
 10 type(dataout) color(green)  intens(high)  hilite(blink)
)body
%----------------------------Â¬ Date conversion %-------------------------------+
%Option ===>_ZCMD

`Input Date%===>_IDATE                           Â¢

Â¢Formats:       ~mm/dd/yy mm/dd/ccyy ccyy-mm-dd yy.ddd ccyy.ddd
                ~mm-dd-yy mm-dd-ccyy
%-------------------------------------------------------------------------------

                          {OGDATE
                          {OIDATE
                          }OJDATE
                          {OTIME
 %Previous month                                                   %Next month
                          Â¬                          +
~?CAL1               ?    Â¬ `?CAL2               ? Â¬ +  ~?CAL3               ?
+?                   ?    Â¬ %?                   ? Â¬ +  +?                   ?
+?                   ?    Â¬ %?                   ? Â¬ +  +?                   ?
+?                   ?    Â¬ %?                   ? Â¬ +  +?                   ?
+?                   ?    Â¬ %?                   ? Â¬ +  +?                   ?
+?                   ?    Â¬ %?                   ? Â¬ +  +?                   ?
+?                   ?    Â¬ %?                   ? Â¬ +  +?                   ?
+?                   ?    Â¬ %?                   ? Â¬ +  +?                   ?
    Â¦DÂ¦                   Â¬                          +
)init
 .HELP = DA$WDATT
 &ZCMD = &ZNULL
)reinit
 &ZCMD = &ZNULL
)proc
)end
./ ADD NAME=DA$WDATT 0101-01283-01283-1336-00035-00035-00000-DALCOCK
)ATTR
 # TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)
 Â¢ TYPE(TEXT) INTENS(HIGH) COLOR(green)
 Â¦ TYPE(TEXT) INTENS(HIGH) COLOR(pink)
 @ TYPE(TEXT) INTENS(HIGH) COLOR(green) hilite(reverse)
 Â¬ TYPE(TEXT) INTENS(HIGH) COLOR(red)
 ` TYPE(TEXT) INTENS(HIGH) COLOR(turq)
 ~ TYPE(TEXT) INTENS(low) COLOR(turq)
)BODY EXPAND(\\)
Â¦TUTORIAL \-\  Date Conversion \-\ TUTORIAL
%Option ===>_ZCMD                                                              +
%
+This ISPF application converts between Gregorian and Julian date formats.
+
+Either specify a Gregorian, Julian or 32-bit TOD formats.
+
Â¢Primary Commands:
+
  #ASMDATE+-`Display the ISPF application and date routine assembly date
  #SHOWALL+-`Display all output date formats that DA$DATE does
  #YEAR   +-`Show the full calendar year
  #YEAR Sideways +-`Puts a full calendar year in your current ISPF list
                   `dataset in the ever so useful "sideways" format.
+
Â¢PFKeys to quickly move the current date around:
+
  #PF7    +-`Backup one day in the year
  #PF8    +-`Advance one day in the year
  #PF10   +-`Backup one year
  #PF11   +-`Advance one year
+
+Hit the#END+key to return to the Date Conversion ISPF application.
)INIT
)PROC
)END
./ ADD NAME=DA$WDATY 0101-01283-01283-1336-00054-00054-00000-DALCOCK
)attr default(%+_)
 /********************************************************************/
 /* Name: DA$WDATY                                                   */
 /* Application: WHATDATE (DA$WDATE)                                 */
 /* Author: David Alcock                                             */
 /* Purpose: Show Calendars for a year                               */
 /********************************************************************/
 # type(text) intens(high) color(yellow)
 Â¢ type(text) intens(low)  color(green)
 Â¬ type(text) intens(low)  color(green) hilite(reverse)
 ` type(text) intens(high) color(yellow)
 ~ type(text) intens(low)  color(turq)
 { type(output) intens(high) color(yellow) caps(off)
 } type(output) intens(high) color(turq)   caps(off)
 Â¦ area(dynamic) scroll(on)
 ? area(dynamic)
 01 type(dataout) color(blue)
 02 type(dataout) color(white)  intens(high)
 03 type(dataout) color(yellow) intens(high)
 04 type(dataout) color(turq)   intens(high)
 05 type(dataout) color(red)    intens(high)
 06 type(dataout) color(green)  intens(high)
 0B type(dataout) color(blue)                 hilite(blink)
 0C type(dataout) color(white)  intens(high)  hilite(blink)
 0D type(dataout) color(yellow) intens(high)  hilite(blink)
 0E type(dataout) color(turq)   intens(high)  hilite(blink)
 0F type(dataout) color(red)    intens(high)  hilite(blink)
 10 type(dataout) color(green)  intens(high)  hilite(blink)
)body
%----------------------------------Â¬ &YEAR%------------------------------------+
%Option ===>_ZCMD

~?CALY1              ?      ~?CALY2              ?      ~?CALY3              ?
+?                   ?      +?                   ?      +?                   ?
+?                   ?      +?                   ?      +?                   ?
+?                   ?      +?                   ?      +?                   ?
+?                   ?      +?                   ?      +?                   ?
+?                   ?      +?                   ?      +?                   ?
+?                   ?      +?                   ?      +?                   ?
+?                   ?      +?                   ?      +?                   ?

~?CALY4              ?      ~?CALY5              ?      ~?CALY6              ?
+?                   ?      +?                   ?      +?                   ?
+?                   ?      +?                   ?      +?                   ?
+?                   ?      +?                   ?      +?                   ?
+?                   ?      +?                   ?      +?                   ?
+?                   ?      +?                   ?      +?                   ?
+?                   ?      +?                   ?      +?                   ?
+?                   ?      +?                   ?      +?                   ?
    Â¦DÂ¦
Â¢Scroll using the#UPÂ¢and#DOWNÂ¢keys or hit the#ENDÂ¢key to return to main screen.
)init
)proc
)end
./ ADD NAME=DA#COBOL 0100-01266-01266-1821-00178-00178-00000-DAVE
         MACRO ,
         DA#COBOL ,
.**********************************************************************
.***                                                                ***
.** These DSECTs were taken from the COMPILE program by              **
.**                                                                  **
.** Author:       Roland Schiradin (Systematics Service GmbH,         *
.**               Hamburg Germany)                                    *
.**                                                                  **
.***                                                                ***
.**********************************************************************
*============================================================*
* COBOL/370 DCL
*============================================================*
COBOL_370_DSECT     DSECT
                    DS CL4  bypass
CEE_EYECATCHER      DS CL4  excatcher
CEE_STACK_FRAME     DS F    stack frame size
CEE_PPA1_OFFSET     DS F    offset to first ppa1
                    DS CL4  reserved
CEE_PPA1_START      DS 0C
CEE_OFFSET          DS X    offset to length of name from ppa1
CEE_SIGNATURE       DS X    CEL-Signature
CEE_FLAG1           DS X    CEL-X_FLAG1S Bitmask
CEE_FLAG2           DS X    Member X_FLAG1s for Cobol
CEE_ADDRESS_OF_PPA2 DS F    Address of PPA2
CEE_OFFSET_DBI      DS F    Offset BDI (None)
CEE_EP_DESCRIPTOR   DS F    Entry Point Descriptor
CEE_STACK_OVERFLOW  DS F    Offset for Stack overflow
                    DS F    available word
                    DS F    available word
                    DS F    available word
                    DS F    available word
CEE_PRIMARY_EP      DS 0C
CEE_PRI_EP_ADDRESS  DS A    primary entry-point address
CEE_PGT_ADDRESS     DS A    PGT-Address
CEE_TGT_ADDRESS     DS A    PGT-Address
CEE_EP_NAME         DS A    Offset to entry_point_name
CEE_CURRENT_EP      DS A    current EP-Address
CEE_START           DS A    procedure code Address
CEE_INIT_PROG       DS A    Initialize Routine
CEE_PARM_LIST       DS A    Address of parm list for CEEINT
                    DS F    available word
                    DS H    available half-word
CEE_LENGTH_NAME     DS XL2  length of program_name
CEE_NAME_PART       DS 0C
CEE_PGM_NAME        DS CL8  name of programm
CEE_COMP_YEAR       DS CL4  year of compilation
CEE_COMP_MONTH      DS CL2  month of compilation
CEE_COMP_DAY        DS CL2  day of compilation
CEE_COMP_HOURS      DS CL2  hours of compilation
CEE_COMP_MIN        DS CL2  minutes of compilation
CEE_COMP_SEC        DS CL2  seconds of compilation
CEE_VERS            DS CL2  version
CEE_REL             DS CL2  release
CEE_MOD             DS CL2  modification level
                    DS F    available word
                    DS F    available word
CEE_STATUS_BYTE_01  DS X    status byte
CEE_STATUS_BYTE_02  DS X    status byte
CEE_STATUS_BYTE_03  DS X    status byte
CEE_STATUS_BYTE_04  DS X    status byte
CEE_STATUS_BYTE_05  DS X    status byte
CEE_STATUS_BYTE_06  DS X    status byte
CEE_STATUS_BYTE_07  DS X    status byte
CEE_STATUS_BYTE_08  DS X    status byte
CEE_STATUS_BYTE_09  DS X    status byte
CEE_STATUS_BYTE_10  DS X    status byte
CEE_STATUS_BYTE_11  DS X    status byte
CEE_STATUS_BYTE_12  DS X    status byte
CEE_STATUS_BYTE_13  DS X    status byte
CEE_STATUS_BYTE_14  DS X    status byte
CEE_STATUS_BYTE_15  DS X    status byte
CEE_STATUS_BYTE_16  DS X    status byte
CEE_STATUS_BYTE_17  DS X    status byte
CEE_STATUS_BYTE_18  DS X    status byte
CEE_STATUS_BYTE_19  DS X    status byte
CEE_STATUS_BYTE_20  DS X    status byte
CEE_STATUS_BYTE_21  DS X    status byte
CEE_STATUS_BYTE_22  DS X    status byte
CEE_STATUS_BYTE_23  DS X    status byte
CEE_COBOL_SIGNAT    DS X    cobol signature level
CEE_DATA_STATEMENTS DS XL4  number of data items
CEE_PROC_LINES      DS XL4  number of proc statements
CEE_STATUS_BYTE_24  DS X    status byte
CEE_STATUS_BYTE_25  DS X    status byte
*============================================================*
* COBOL2 DCL
*============================================================*
COBOL_2_DSECT      DSECT
                   DS CL4  bypass
                   DS X
C2_PGM_NAME        DS CL8  name of programm
C2_EYECATCHER      DS CL4  eyecatcher
C2_VERS            DS CL2  version
C2_REL             DS CL2  release
C2_MOD             DS CL2  modification level
C2_COMP_MONTH      DS CL2  month of compilation
                   DS CL1
C2_COMP_DAY        DS CL2  day of compilation
                   DS CL1
C2_COMP_YEAR       DS CL2  year of compilation
                   DS CL1
C2_COMP_HOURS      DS CL2  hours of compilation
                   DS CL1
C2_COMP_MIN        DS CL2  minutes of compilation
                   DS CL1
C2_COMP_SEC        DS CL2  seconds of compilation
                   DS A
C2_STATUS_BYTE_01  DS X    status byte
C2_STATUS_BYTE_02  DS X    status byte
C2_STATUS_BYTE_03  DS X    status byte
C2_STATUS_BYTE_04  DS X    status byte
C2_STATUS_BYTE_05  DS X    status byte
C2_STATUS_BYTE_06  DS X    status byte
C2_STATUS_BYTE_07  DS X    status byte
C2_STATUS_BYTE_08  DS X    status byte
C2_STATUS_BYTE_09  DS X    status byte
C2_STATUS_BYTE_10  DS X    status byte
C2_STATUS_BYTE_11  DS X    status byte
C2_STATUS_BYTE_12  DS X    status byte
C2_STATUS_BYTE_13  DS X    status byte
C2_STATUS_BYTE_14  DS X    status byte
C2_STATUS_BYTE_15  DS X    status byte
C2_STATUS_BYTE_16  DS X    status byte
C2_STATUS_BYTE_17  DS X    status byte
C2_STATUS_BYTE_18  DS X    status byte
C2_STATUS_BYTE_19  DS X    status byte
C2_STATUS_BYTE_20  DS X    status byte
C2_STATUS_BYTE_21  DS X    status byte
C2_STATUS_BYTE_22  DS X    status byte
C2_STATUS_BYTE_23  DS X    status byte
                   DS X    cobol signature level
C2_DATA_STATEMENTS DS XL4  number of data items
C2_PROC_LINES      DS XL4  number of proc statements
C2_STATUS_BYTE_24  DS X    status byte
C2_STATUS_BYTE_25  DS X    status byte
*
ADV      EQU   B'10000000'
APOST    EQU   B'01000000'
DATA31   EQU   B'00100000'
DECK     EQU   B'00010000'
DUMP     EQU   B'00001000'
DYNAM    EQU   B'00000100'
FASTSRT  EQU   B'00000010'
FDUMP    EQU   B'00000001'
LIB      EQU   B'10000000'
LIST     EQU   B'01000000'
MAP      EQU   B'00100000'
NUM      EQU   B'00010000'
OBJ      EQU   B'00001000'
OFFSET   EQU   B'00000100'
OPTIMIZE EQU   B'00000010'
DDNAME   EQU   B'00000001'
NUMPROC  EQU   B'10000000'
RENT     EQU   B'01000000'
RES      EQU   B'00100000'
SEQUENCE EQU   B'00010000'
SIZE     EQU   B'00001000'
SOURCE   EQU   B'00000100'
SSRANGE  EQU   B'00000010'
TERM     EQU   B'00000001'
TEST     EQU   B'10000000'
TRUNC    EQU   B'01000000'
USERW    EQU   B'00100000'
VBREF    EQU   B'00010000'
XREF     EQU   B'00001000'
ZWB      EQU   B'00000100'
NAME     EQU   B'00000010'
CMPR2    EQU   B'00000001'
NUMPROCM EQU   B'10000000'
NUMCLASS EQU   B'01000000'
DBCS     EQU   B'00100000'
AWO      EQU   B'00010000'
TRUNCB   EQU   B'00001000'
EVENTS   EQU   B'00000100'
CURRENCY EQU   B'00000010'
         MEND  ,
./ ADD NAME=DA#DATE  0100-01266-01266-1821-00226-00226-00000-DAVE
         MACRO ,
         DA#DATE &ITYPE,                  Type of macro invocation     @
               &OPREFIX=DA#DATED,         Parameter: Prefix            @
               &OFLAG=0,                  Parameter: Flag              @
               &OSTR=NO,                  Parameter: Generate area?    @
               &OSTRL=0,                  Parameter: Length of area    @
               &OTYPE=0,                  Parameter: Type constant     @
               &MF=L
.**********************************************************************
.***                                                                ***
.**  Name: DA#DATE                                                   **
.**                                                                  **
.**  Purpose: Provide external interface equates and DSECTs for      **
.**           DA#DATE routine.                                       **
.***                                                                ***
.**********************************************************************
.*
.** Branch table
.*
 AIF   ('&ITYPE' EQ '').EQU
 AIF   ('&ITYPE' EQ 'EQU').EQU
 AIF   ('&ITYPE' EQ 'EQUATE').EQU
 AIF   ('&ITYPE' EQ 'EQUATES').EQU
 AIF   ('&ITYPE' EQ 'DPE').DPE
 AIF   ('&ITYPE' EQ 'STRLOC').STRLOC      Locate String?
 AIF   ('&ITYPE' EQ 'STRLEN').STRLEN      Calculate length of string?
 MNOTE 8,'DA#DATE-01E &ITYPE is invalid'
 MEXIT ,
.**********************************************************************
.***                                                                ***
.**       Calculate string length                                    **
.***                                                                ***
.**********************************************************************
.STRLEN ANOP ,
 LR    R14,R15                            Save address on string
.STRLOC ANOP ,
 TM    &OPREFIX._FLAG,$DA#DATE_ADDR       Address type string?
 BO    SL&SYSNDX.A                        Yes, locate output location
 LA    R15,&OPREFIX._STR                  No, output at this label
 B     SL&SYSNDX.B                        Move on
SL&SYSNDX.A EQU *
 L     R15,&OPREFIX._STR                  Locate string
SL&SYSNDX.B EQU *
 AIF   ('&ITYPE' NE 'STRLEN').SLX         .Check invocation type
 SR    R14,R15                            Length = End - Begining
 STC   R14,&OPREFIX._STRL                 Save length
.SLX ANOP ,
 MEXIT ,
.**********************************************************************
.***                                                                ***
.**       Map the input parameter format                             **
.***                                                                ***
.**********************************************************************
.EQU     ANOP  ,
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** DA#DATE Parameter Entry
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
.DPE ANOP ,
&OPREFIX.         EQU *
&OPREFIX._TYPE    DC  AL2(&OTYPE)
&OPREFIX._FLAG    DC  AL1(&OFLAG)
&OPREFIX._STRL    DC  AL1(&OSTRL)
 AIF ('&OSTR' EQ 'NO').DPEA
&OPREFIX._STR     DC  XL(&OSTRL.)'00'
 AGO  .DPEAX
.DPEA    ANOP ,
&OPREFIX._STR     EQU *
.DPEAX   ANOP ,
&OPREFIX.L        EQU  *-&OPREFIX.
 AIF   ('&ITYPE' NE 'DPE').DPEX
 MEXIT ,
.DPEX ANOP ,
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** DA#DATE Equates
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
*                                         DA#DATED_FLAG
*                                         ..Error
$DA#DATE_EITYPE   EQU B'10000000'           ..Invalid type
$DA#DATE_EISTRL   EQU B'01000000'           ..Invalid String Length
$DA#DATE_EISTR    EQU B'00100000'           ..Invalid String
$DA#DATE_EEXEC    EQU B'00010000'           ..Execution Error
$DA#DATE_ENOSAVE  EQU B'00001000'           ..No Saved entry
$DA#DATE_ROUTINE1 EQU B'00000001'           ..For use for routines
*                                         ..Input options
$DA#DATE_ADDR     EQU B'00000001'           ..Use address
$DA#DATE_ELASPED  EQU B'00000010'           ..Elasped time/date
*
$DA#DATE_INVALID EQU X'FF'                Invalid "S_" address
*
** Time zones - Need to have offset from GMT...
*
$DA#DATE_TZ_PST   EQU C'PST'              ..Pacific  Standard Time 1
$DA#DATE_TZ_MST   EQU C'MST'              ..Mountian Standard Time 2
$DA#DATE_TZ_CST   EQU C'CST'              ..Central  Standard Time 3
$DA#DATE_TZ_EST   EQU C'EST'              ..Eastern  Standard Time 4
$DA#DATE_TZ_AST   EQU C'AST'              ..Atlantic Standard Time 5
 SPACE 2
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
*                           Output
*                           ..Date
$DA#DATE_ODGUS    EQU 1       ..Gregorian (US)
$DA#DATE_ODGUS29      EQU 29    ..dayofweek, mmmmmmmmm dd, ccyy
$DA#DATE_ODGUS23      EQU 23    ..dow, mmmmmmmmm dd, ccyy
$DA#DATE_ODGUS18      EQU 18    ..mmmmmmmmm dd, ccyy
$DA#DATE_ODGUS12      EQU 11    ..mmm dd ccyy
$DA#DATE_ODGUS10      EQU 10    ..mm/dd/ccyy
$DA#DATE_ODGUS8T      EQU 9     ..mmddccyy    (Output length = 8...)
$DA#DATE_ODGUS8       EQU 8     ..mm/dd/yy
$DA#DATE_ODGUS6       EQU 6     ..mmddyy
*
$DA#DATE_ODGEUR   EQU 2       ..Gregorian (European)
$DA#DATE_ODGEUR29     EQU 29    ..dayofweek, dd-mmmmmmmmm-ccyy
$DA#DATE_ODGEUR23     EQU 23    ..dow, dd-mmmmmmmmm-ccyy
$DA#DATE_ODGEUR18     EQU 18    ..dd-mmmmmmmmm-ccyy
$DA#DATE_ODGEUR11     EQU 11    ..dd-mmm-ccyy
$DA#DATE_ODGEUR10     EQU 10    ..dd/mm/ccyy
$DA#DATE_ODGEUR8T     EQU 9     ..ddmmccyy    (Output length = 8...)
$DA#DATE_ODGEUR8      EQU 8     ..dd/mm/yy
$DA#DATE_ODGEUR6      EQU 6     ..ddmmyy
*
$DA#DATE_ODJUL    EQU 3       ..Julian (IBM)
$DA#DATE_ODJUL8       EQU 8     ..19YY.DDD
$DA#DATE_ODJUL6       EQU 6     ..YY.DDD
$DA#DATE_ODJUL5       EQU 5     ..YYDDD
$DA#DATE_ODJUL3       EQU 3     ..DDD
*
$DA#DATE_ODGJUL   EQU 4       ..Gregoran.Julian: MM/DD/YY.DDD
$DA#DATE_OUS      EQU 5       ..US: Date/Time string
$DA#DATE_OEUR     EQU 6       ..Europe: Date/Time String
$DA#DATE_ODDOW    EQU 7       ..Day of week (Sunday, Monday, ...)
$DA#DATE_ODDOW1       EQU 1     ..Number (Binary):
$DA#DATE_ODDOW1SUN        EQU 0   ..Sunday
$DA#DATE_ODDOW1MON        EQU 1   ..Monday
$DA#DATE_ODDOW1TUE        EQU 2   ..Tuesday
$DA#DATE_ODDOW1WED        EQU 3   ..Wednesday
$DA#DATE_ODDOW1THU        EQU 4   ..Thursday
$DA#DATE_ODDOW1FRI        EQU 5   ..Friday
$DA#DATE_ODDOW1SAT        EQU 6   ..Saturday
$DA#DATE_ODDOW3       EQU 3     ..WED
$DA#DATE_ODDOW9       EQU 9     ..Wednesday
$DA#DATE_ODMONTHN EQU 8       ..Month Name
$DA#DATE_ODMONTHN3    EQU 3     ..SEP
$DA#DATE_ODMONTHN9    EQU 9     ..September
$DA#DATE_ODDOM    EQU 9       ..Day of the month
$DA#DATE_ODYEAR   EQU 10      ..Year
*                           ..Time
$DA#DATE_OTIMES   EQU 11      ..Time standard: 01:00 PM
$DA#DATE_OTIMES14     EQU 14    ..HH:MM:SS.th am
$DA#DATE_OTIMES11     EQU 11    ..HH:MM:SS am
$DA#DATE_OTIMES8      EQU 8     ..HH:MM am
$DA#DATE_OTIMES5      EQU 5     ..HH:MM
*                           ..Time
$DA#DATE_OTIMEM   EQU 12      ..Time military: 13:00:00
$DA#DATE_OTIMEM11     EQU 11    ..HH:MM:SS.th
$DA#DATE_OTIMEM8      EQU 8     ..HH:MM:SS
$DA#DATE_OTIMEM6C     EQU 6     ..HHMMSS  (compressed)
$DA#DATE_OTIMEM5      EQU 5     ..HH:MM
*                           ..Time
$DA#DATE_OETD     EQU 13      ..Elasped Time/Date
$DA#DATE_OETD30       EQU 30    ..XXX Years, 5 Days, HH:MM:SS.th
*                           ..Calendar
$DA#DATE_ODCAL    EQU 14      ..Calendar Character format
$DA#DATE_ODCALC       EQU 8*(3*7)  ..Length of Calendar area
$DA#DATE_ODCALC_WEEKN     EQU 8      ..Number of "weeks" w/2 headings
$DA#DATE_ODCALC_WEEKL     EQU 3*7    ..Length of a week
$DA#DATE_ODCALC_DATEEL    EQU 3      ..Length of each day in a week
$DA#DATE_ODCALV       EQU 42
$DA#DATE_ODCALND  EQU 15      ..Calendar Character format, no "**"
*
$DA#DATE_ODISO    EQU 16   ..ISO (standard date)
$DA#DATE_ODISO10      EQU 10  ..ccyy-mm-dd
 SPACE 2
*                           Input
*                           ..Date
$DA#DATE_IDJULC   EQU 93      ..Julian (character)
$DA#DATE_IDJULC8      EQU 8     ..CCYY.DDD - where CC is Century
$DA#DATE_IDJULC7      EQU 7     ..CCYYDDD  - where CC is Century
$DA#DATE_IDJULC6      EQU 6     ..YY.DDD
$DA#DATE_IDJULC5      EQU 5     ..YYDDD
*
$DA#DATE_IDJULP   EQU 94      ..Julian (packed)
$DA#DATE_IDJULP4      EQU 4     ..CCYYDDDF
$DA#DATE_IDJULP3      EQU 3     ..YYDDDF
*
$DA#DATE_IDGUS    EQU 95      ..Gregorian (US)
$DA#DATE_IDGUS12      EQU 12    ..MMM DD, 19YY
$DA#DATE_IDGUS10      EQU 10    ..MM/DD/19YY
$DA#DATE_IDGUS8       EQU 8     ..MM/DD/YY
$DA#DATE_IDGUS6       EQU 6     ..MMDDYY
*
$DA#DATE_IDGEUR   EQU 96      ..Gregorian (Europe)
$DA#DATE_IDJFCB   EQU 97      ..Job file Control Block
*                               JFCBXPDT year bytes represents a year
*                               offset from 1900, thus X'FF' is 2155
$DA#DATE_IDTLABEL EQU 98      ..Tape label
*                               1 - century: blank: 19, 0=20, 1=21
*                           ..TIME
$DA#DATE_ITBIN    EQU 99      ..Binary
$DA#DATE_ITBIN4       EQU 4     ..F'######'
*
$DA#DATE_ISTMPC   EQU 100     ..System Time Stamp character
$DA#DATE_ISTMPC16     EQU 16    ..Hex character string (IDCAMS)
*
$DA#DATE_ISTMPV   EQU 101     ..System Time Stamp Value
$DA#DATE_ISTMPV8      EQU 8     ..Double word value
*
$DA#DATE_ITIMES   EQU 102     ..Time standard: 01:00 PM
$DA#DATE_ITIMES14     EQU 14    ..HH:MM:SS.th am
$DA#DATE_ITIMES11     EQU 11    ..HH:MM:SS am
$DA#DATE_ITIMES8      EQU 8     ..HH:MM am
$DA#DATE_ITIMES6      EQU 6     ..HH:MMa
$DA#DATE_ITIMES5      EQU 5     ..HHMMa
*
$DA#DATE_ITIMEM   EQU 103     ..Time military: 13:00:00
$DA#DATE_ITIMEM11     EQU 11    ..HH:MM:SS.th
$DA#DATE_ITIMEM8      EQU 8     ..HH:MM:SS
$DA#DATE_ITIMEM6      EQU 6     ..HHMMSS
$DA#DATE_ITIMEM5      EQU 5     ..HH:MM
$DA#DATE_ITIMEM4      EQU 4     ..HHMM
*
$DA#DATE_ITDEC    EQU 104     ..Decimal (like from TIME macro)
$DA#DATE_ITDEC4       EQU 4     ..F'######'
*
$DA#DATE_IDISO    EQU 105  ..ISO (standard date)
$DA#DATE_IDISO10      EQU 10  ..ccyy-mm-dd
 MEND  ,
./ ADD NAME=DA#ENTER 0100-01266-01266-1821-00331-00331-00000-DAVE
         MACRO
&LABEL   DA#ENTER &MSG,         Eye catcher for load module            @
               &BASE=12,        Base register                          @
               &FLOAT=NO,       Equate floating point registers        @
               &GPR=YES,        Equate general purpose registers       @
               &LOC=RES,        Getmain location in virtual storage    @
               &LV=72,          Length of getmained area (default)     @
               &ORG=C,          Location counter                       @
               &PL=,            Global flag                            @
               &RENT=NO,        Re-entrant?                            @
               &AMODE=24,       Addressing mode for CSECT              @
               &RMODE=24,       Residency mode for CSECT               @
               &CLEAR=YES,      Clear Getmained area to binary zeros   @
               &GMTYPE=R,       Getmain register type: R, RU, RC       @
               &ASMINFO=YES,    Have DA#EYEC insert Assemble info?     @
               &DATEFMT=ISO,    Date format used by DA#EYEC            @
               &RSA=,           Register save area                     @
               &SP=0            Getmain subpool number
.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
.*  MACNAME:  ENTER                                                  *
.*  MACAUTH:  Skip Abadie                                            *
.*  MACDATE:  12/01/80                                               *
.*  MACUPTE:  David Alcock                                           *
.*                                                                   *
.*  May be used in conjuntion with LEAVE macro.                      *
.*  Registers R0 and R1 are restored to entry values prior to exit.  *
.*                                                                   *
.*  This macro automatically invokes the REQUATE (register equate)   *
.*  macro unless global flag &REGS is set to one.                    *
.*                                                                   *
.*  This macro conditionally invokes the DA#EYEC macro in order to   *
.*  build a standard OS format module identifier.  If global flag    *
.*  &PROLOG is set to one, or if &PL=NO is specified, the DA#EYEC    *
.*  MACRO is not invoked.                                            *
.*                                                                   *
.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
.*                                                                   *
.*  MSG  'TEXT STRING'                                               *
.*       THIS OPTIONAL PARAMETER WILL OVERRIDE THE DEFAULT STANDARD  *
.*       OS FORMAT MODULE IDENTIFIER GENERATED BY THE DA#EYEC MACRO. *
.*       DA#ENTER USES DA#EYEC TO GENERATE THE MODULE IDENTIFIER.    *
.*       SEE THE DESCRIPTION OF THE MSG PARAMETER IN THE PROLOGUE    *
.*       MACRO FOR CODING DETAILS.                                   *
.*                                                                   *
.*  BASE={REGÂ¦(REG0,REG1,...,REGN)Â¦NO}                               *
.*       BASE REGISTER:  REGISTER SPECIFIED WILL BE USED AS A BASE   *
.*       REGISTER.  DEFAULT IS REGISTER 12.  RANGE 2 - 12.  IF THE   *
.*       LIST FORM OF THE OPERAND IS USED, A USING STATEMENT HAVING  *
.*       ALL THE INDICATED REGISTERS WILL BE GENERATED.  IN THE LIST *
.*       FORM, THE FIRST REGISTER IS CONSIDERED TO BE THE FIRST BASE *
.*       REGISTER.  ALL BASE REGISTERS ARE INITIALIZED.  NO BASE     *
.*       REGISTER IS ESTABLISHED IF BASE=NO IS CODED; ALL OTHER      *
.*       ACTIONS OCCUR AS DESCRIBED.                                 *
.*  LV={LITERALÂ¦EXPRESSION}                                          *
.*       THIS PARAMETER IS APPLICABLE ONLY IF RENT=YES IS CODED.     *
.*       THE VALUE OF THE LITERAL OR EXPRESSION IS USED IN AN R-FORM *
.*       GETMAIN.  THE FIRST 72 BYTES OF THE AREA ARE USED FOR A     *
.*       REGISTER SAVE AREA.  REGISTER 13 WILL BE LOADED WITH THE    *
.*       ADDRESS OF THE AREA.                                        *
.*       LITERAL:  A VALUE FROM 72 TO 4096 INCLUSIVE.                *
.*       EXPRESSION:  ANY VALID ASSEMBLER EXPRESSION OF ANY VALUE.   *
.*  RENT={YESÂ¦NO}                                                    *
.*       YES:  GENERATE GETMAIN TO ACQUIRE SAVE AREA.  RENT=YES WILL *
.*       FACILITATE THE USE OF REENTRANT CODING TECHNIQUES.          *
.*       NO:   GENERATE STANDARD IN-LINE 18 WORD SAVE AREA.          *
.*  ORG={LÂ¦C}                                                        *
.*       L:  USE CURRENT LOCATION COUNTER VALUE IN USING STATEMENT   *
.*       (E.G.,   USING *,R12   ).                                   *
.*       C:  USE CSECT LABEL (&SYSECT) AS ORIGIN FOR USING STATEMENT *
.*       (E.G.,   USING &SYSECT,R12   ).                             *
.*  PL={ Â¦NO}                                                        *
.*       NO:   THE PROLOG GLOBAL FLAG IS NOT CHECKED, AND THE        *
.*       DA#EYEC MACRO IS NOT INVOKED.   THIS PARAMETER SHOULD ONLY  *
.*       BE SPECIFIED WHEN NO MESSAGE AND CSECT GENERATION IS        *
.*       REQUIRED, AND/OR NO DA#EYEC MACRO HAS BEEN INVOKED,         *
.*       DIRECTLY OR INDIRECTLY, SINCE THE LAST OCCURRENCE OF ENTER. *
.*                                                                   *
.*** AMODE, RMODE,  ADDED FOR MVS/XA SUPPORT 85.122 -DGA-          ***
.*                                                                   *
.*  AMODE={ Â¦24Â¦31Â¦ANY}                                              *
.*       24:  THE PROGRAM IS DESIGNED TO RECEIVE CONTROL IN 24-BIT   *
.*            MODE.                                                  *
.*       31:  THE PROGRAM IS DESIGNED TO RECEIVE CONTROL IN 31-BIT   *
.*            MODE.                                                  *
.*       ANY: THE PROGRAM IS DESIGNED TO RECEIVE CONTROL IN EITHER   *
.*            24-BIT OR 31-BIT MODE.                                 *
.*  RMODE={ Â¦24Â¦31Â¦ANY}                                              *
.*       24:  THE PROGRAM IS DESIGNED TO RESIDE BELOW THE 16-MEG     *
.*            LINE.                                                  *
.*       ANY: THE PROGRAM IS DESIGNED TO RESIDE IN ANY VIRTUAL       *
.*            STORAGE LOCATION, EITHER ABOVE OR BELOW THE 16-MEG     *
.*            LINE.                                                  *
.*** LOC  ADDED FOR MVS/XA SUPPORT 1985.210 -DGA-                  ***
.*                                                                   *
.*  LOC ={BELOW Â¦ (BELOW,ANY) Â¦ ANY Â¦ (ANY,ANY) Â¦ RES Â¦ (RES,ANY)}   *
.*  LOCATION IN VIRTUAL AND REAL STORAGE TO ALLOCATE.                *
.*  (SEE GC28-1154 MVS/XA SUPERVISOR SERVICES AND MACRO INSTRUCTIONS *
.*   GETMAIN ... OPERAND LOC)
.*            LINE.                                                  *
.*                                                                   *
.*** SP - Getmain sub-pool                                         ***
.*          See SYSTEM MACROs manual for more info                   *
.*                                                                   *
.*** GMTYPE={R, RU, RC}                                            ***
.*          Getmain Register Type (See SYSTEM MACROS)                *
.*                                                                   *
.*** CLEAR={YES Â¦ NO}                                              ***
.*         Clear getmained area to binary zeros.  R2,R3,R4 and R5    *
.*         are modified.                                             *
.*                                                                   *
.*** RSA=                                                          ***
.*         Use Register Save Area at the location pointed to by      *
.*         this field.                                               *
.*                                                                   *
.*** DATEFMT= DA#EYEC parm                                         ***
.*** ASMINFO= DA#EYEC parm                                         ***
.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
.*                                                                   *
.*  EXAMPLES:                                                        *
.*                                                                   *
.* TEST1 DA#ENTER BASE=8,LV=300,RENT=YES                             *
.*     . R8 IS BASE, GETMAIN 300 BYTES, CSECT NAME IS TEST1,         *
.*                                                                   *
.* TEST2 DA#ENTER                                                    *
.*     . R12 IS BASE, IN-LINE SAVEAREA, CSECT NAME IS TEST2,         *
.*                                                                   *
.*       DA#ENTER 'VERSION 1',BASE=(10,11),RENT=YES,LV=WORKEND-WORK  *
.*     . R10,R11 ARE BASES, GETMAIN AL4(WORKEND-WORK) BYTES,         *
.*     . CSECT NAME DEFAULTS TO MAIN                                 *
.*                                                                   *
.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
.**********************************************************************
.***                                                                ***
.**           M o d i f i c a t i o n   H i s t o r y                **
.**                                                                  **
.** Person     Date        Description                               **
.** ---------- ----------- ----------------------------------------- **
.** DGAlcock   07-FEB-1996 Renamed to DA#ENTER from ENTER            **
.***                                                                ***
.**********************************************************************
.*
.*  DEFINE GLOBAL AND LOCAL SET SYMBOLS
.*
         GBLC  &VIRT
         GBLB  &RE,&REGS,&PROLOG,&ENTER31
.*
         LCLA  &B1,&BCT,&BICT
         LCLB  &ALV,&CLV,&BT(16),&OT
         LCLC  &BO,&LAB
.*
.**********************************************************************
.***                                                                ***
.**      "DA#EYEC" MACRO PROCESSING                                  **
.***                                                                ***
.**********************************************************************
.*
.*
.** SET GLOBAL FOR LEAVE MACRO IF WE ARE FOR 31-BIT MODE
.*
         AIF   ('&AMODE' NE '31').NO31MDE
&ENTER31 SETB  1                 SET GLOBAL ENTER 31-BIT FLAG
.NO31MDE ANOP  ,
.*
.** GENERATE MODULE IDENTIFICATION Prologue.
.*
&LAB     SETC  '&SYSECT'         SET CSECT NAME
         AIF   ((&PROLOG) OR ('&PL' EQ 'NO')).E000A SKIP PROLOGUE
&LAB     SETC  '&LABEL'          SET CSECT TO LABEL NAME
         AIF   ('&LABEL' NE '').E000  GEN PROLOGUE IF &LABEL EXISTS
         MNOTE 0,'CSECT NAME OMMITED - CSECT NAME DEFAULTS TO MAIN'
&LAB     SETC  'MAIN'            SET CSECT TO MAIN
.E000    ANOP  ,
         DA#EYEC &LAB,&MSG,RMODE=&RMODE,AMODE=&AMODE,                  @
               ASMINFO=&ASMINFO,DATEFMT=&DATEFMT
.*
.**********************************************************************
.***                                                                ***
.**      EXPAND REGISTERS AND SET CONSTANTS                          **
.***                                                                ***
.**********************************************************************
.*
.*
.** GENERATE STANDARD REGISTER EQUATES IF GLOBAL FLAG &REGS = 0
.*
.E000A   ANOP
&PROLOG  SETB  0                 RESET GLOBAL PROLOGUE FLAG
         DA#REGS GPR=&GPR,FLOAT=&FLOAT
.*
.*       SET CONSTANTS AND LOGICAL SWITCHES
.*
.E001    ANOP  ,
&OT      SETB  ('&ORG' EQ 'L')               SET ORIGIN TYPE FLAG
&RE      SETB  ('&RENT' EQ 'YES')            SET REENTRANT FLAG
&BCT     SETA  N'&BASE                       SET NUMBER OF BASE REGS
&BICT    SETA  1                             SET BASE REG COUNTER
&ALV     SETB  (('&LV' GE '72') AND ('&LV' LE '4096')) SET LV FLAG
&CLV     SETB  ('&LV'(1,1) LE '0')           SET LV FLAG
.*
.** IF BOTH RENT AND RSA ARE CHOSEN, USE ONLY RSA...
.*
         AIF   (NOT &RE).EIRX             .RENT SPECIFIED?
         AIF   ('&RSA' EQ '').EIRX        .BOTH SPECIFIED?
&RE      SETB  0                          SET REENTRANT FLAG
.EIRX    ANOP  ,
.*
.*  SAVE CALLER'S REGISTERS
.*
         STM   R14,R12,12(R13)            SAVE CALLER'S REGISTERS
.*
.**********************************************************************
.***                                                                ***
.**      HANDLE BASE REGISTERS                                       **
.***                                                                ***
.**********************************************************************
.*
.E002    ANOP
         AIF   ('&BASE' EQ 'NO').E003        SKIP, IF NO BASE REG
         AIF   (&BCT NE 1).E002B             DECIDE WHICH BASE REG RTN
.*
.*  SINGLE BASE REGISTER SPECIFIED
.*
.E002A   ANOP
&B1      SETA  &BASE
&BO      SETC  '&B1'                    SET STRING FOR USING
         AIF   ((&B1 GE 2) AND (&B1 LE 12)).E002A1
         MNOTE 4,'BASE REGISTER SPECIFIED IS INVALID - USING R12'
&B1      SETA  12
.E002A1  ANOP
         AIF   (&OT).E002A2
         LR    R&B1,R15                   LOAD BASE REGISTER
         USING &LAB,R&B1                  GET ADDRESSIBLITY
         AGO   .E003
.E002A2  ANOP
         BALR  R&B1,0                     LOAD BASE REGISTER
         USING *,R&B1                     GET ADDRESSIBLITY
         AGO   .E003
.*
.*  MULTIPLE BASE REGISTERS SPECIFIED
.*
.E002B   ANOP
&B1      SETA  &BASE(&BICT)
         AIF   (NOT &BT(&B1+1)).E002C        CHECK REDUNDANCY
         MNOTE 8,'REG &B1 REDUNDANTLY SPECIFIED - GEN SUPPRESSED'
         MEXIT
.E002C   ANOP
&BT(&B1+1) SETB  1                           SET REG USE BIT
         AIF   ((&B1 GE 2) AND (&B1 LE 12)).E002D
         MNOTE 8,'INVALID SECONDARY BASE REGISTER - GEN SUPPRESSED'
         MEXIT
.E002D   ANOP
&BICT    SETA  &BICT+1
         AIF   (&BICT LE &BCT).E002B      .CHECK NEXT BASE REG
&BO      SETC  '&BASE'(2,K'&BASE-2)       .DONE, SET STRING FOR USING
&BICT    SETA  1                          .SET LOOP CONTROL
         AIF   (&OT).E002E1
         LR    R&BASE(1),R15              LOAD BASE REGISTER
         USING &LAB,&BO                   GET ADDRESSIBILITY
         AGO   .E002E
.E002E1  ANOP
         BALR  R&BASE(1),0                LOAD BASE REGISTER
         USING *,&BO                      GET ADDRESSIBILITY
.E002E   ANOP
&BICT    SETA  &BICT+1                    .INCREMENT LOOP CONTROL
&B1      SETA  &BASE(&BICT)
         AIF   (NOT &BT(&B1+1)).E002E
         LA    R&B1.,4095                 SECONDARY
         LA    R&B1.,1(R&B1.,R&BASE(&BICT-1)) BASE REGISTER
         AIF   (&BICT LT &BCT).E002E         SET UP NEXT BASE REG
.*
.**********************************************************************
.***                                                                ***
.**      SET UP SAVE AREA                                            **
.***                                                                ***
.**********************************************************************
.*
.E003    ANOP
         AIF   (NOT &RE).E003B            .NOT REENTRANT?
.*
.*  RENT=YES:  ISSUE GETMAIN FOR REENTRANT PROG
.*
&VIRT    SETC  '&LV'
         AIF   (&ALV OR &CLV).E003A
         MNOTE 4,'LV SPECIFIED IS INVALID - USING 72 BYTES'
&VIRT    SETC  '72'
.E003A   ANOP
         MNOTE  '         GETMAIN &GMTYPE,LV=&VIRT,LOC=&LOC,SP=&SP'
         GETMAIN &GMTYPE,LV=&VIRT,LOC=&LOC,SP=&SP
         AIF   ('&CLEAR' NE 'YES').E004
*
         LR    R2,R1                      ADDRESS OF GETMAINED AREA
         LR    R3,R0                      LENGTH OF GETMAINED AREA
         SLR   R5,R5                      SET PAD AND LENGTH
         MVCL  R2,R4                      CLEAR GETMAINED AREA TO 0
*
         AGO   .E004                      SKIP RENT=NO PROCESSING
.*
.** RENT=NO:  ESTABLISH DS TYPE SAVE AREA IF RSA= FIELD NOT SPECIFIED
.*
.E003B   ANOP
         AIF   ('&RSA' NE '').ERSA        .IS RSA SUPPLIED?
         CNOP  0,4                        ALIGN FULL WORD
         BAL   R1,*+76                    BRANCH AROUND PROGRAM RSA
         DS    18F                        RSA (REGISTER SAVE AREA)
         AGO   .E004                      .MOVE ON
.*
.ERSA    ANOP  ,
         AIF   ('&RSA'(1,1) EQ '(').ERSAR .REGISTER FORM?
         LA    R1,&RSA                    LOCATE SUPPLIED SAVE AREA
         AGO   .E004                      .MOVE ON
.ERSAR   ANOP  ,
         LR    R1,&RSA(1)                 LOCATE SUPPLIED SAVE AREA
.ERSARX  ANOP  ,
.*
.**********************************************************************
.***                                                                ***
.**    COMPLETE MACRO: SET UP FORWARD/BACKWARD CHAIN POINTERS        **
.***                                                                ***
.**********************************************************************
.*
.E004    ANOP
         ST    R1,8(,R13)                 SET FORWARD RSA POINTER
         ST    R13,4(,R1)                 SET BACKWARD RSA POINTER
         LR    R13,R1                     GET PROGRAM RSA ADDRESS
         L     R1,4(,R1)                  GET CALLER'S RSA ADDRESS
         AIF   (NOT &RE).E004A            DON'T RECOVER R0 IF NOT REENT
         LM    R0,R1,20(R1)               RESTORE REGISTERS 0, 1
         MEXIT ,
.E004A   ANOP
         L     R1,24(,R1)                 RESTORE REGISTER 1
.*
         MEND
./ ADD NAME=DA#EYEC  0100-01266-01266-1821-00270-00270-00000-DAVE
         MACRO
         DA#EYEC &CSECT,        CSECT name                             @
               &MSG,            Eye catcher message                    @
               &DATEFMT=ISO,    Date format defaults to ISO format     @
               &TIMEFMT=STD,    Time format defaults to standard       @
               &ASMINFO=YES,    Insert Assembly date and time?         @
               &USING=15,       Register used during eyecatcher branch @
               &AMODE=24,       Addressing mode                        @
               &RMODE=24        Residency mode
.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
.*  MACNAME:  PROLOGUE                                               *
.*  MACAUTH:  Skip Abadie                                            *
.*  MACDATE:  4/2/81                                                 *
.*  MACUPTE:  David Alcock                                           *
.*                                                                   *
.*  May be used to generate CSECT Cards and standard format module   *
.*  eye-catchers.  Both the CSECT and module eye-catchers are        *
.*  optional.  See operand descriptions and examples below.          *
.*                                                                   *
.*  This macro is conditionally invoked by macro DA#ENTER. If flag   *
.*  &PROLOG is not set to one, DA#ENTER invokes DA#EYEC. Note that   *
.*  the DA#ENTER macro always sets the global flag &PROLOG to zero so*
.*  that subsequent DA#EYEC or DA#ENTER macros will expand properly. *
.*                                                                   *
.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
.*                                                                   *
.*  CSECT                                                            *
.*       IF SPECIFIED, THIS POSITIONAL PARAMETER WILL GENERATE A     *
.*       CSECT CARD USING THE SPECIFIED NAME.  IF IT IS OMITTED BY   *
.*       CODING A COMMA, THEN NO CSECT CARD IS GENERATED.  IN EITHER *
.*       CASE, THE FOLLOWING CARDS WILL BE GENERATED:                *
.*                USING *,15                                         *
.*                CNOP  0,4                                          *
.*                B     Past-Eyecatcher                              *
.*                DC    AL1(Length-of-EyeCatcher)                    *
.*                                                                   *
.*  ASMINFO=YES|NO                                                   *
.*       Generate the eyecatcher with the date and time of the       *
.*       assembly?                                                   *
.*                                                                   *
.*  TIMEFMT=STD | CON                                                *
.*                                                                   *
.*       - STD: hh:mm                                                *
.*       - CON: "hh:mm AM" or "hh:mm PM"                             *
.*                                                                   *
.*  DATEFMT=ISO | EUR | OLD                                          *
.*                                                                   *
.*       - ISO: ccyy-mm-dd                                           *
.*       - EUR: dd-mon-ccyy                                          *
.*       - OLD: mm/dd/yy      (Required if not HLASM)                *
.*                                                                   *
.*  MSG                                                              *
.*       Text to be added to the standard MVS module eyecatcher      *
.*       which will consist of:                                      *
.*       - CSECT name                                                *
.*       - Date of assembly - Converted to Day-Month-Year            *
.*       - Time of assembly - Converted to standard time             *
.*       - The &MSG parameter (if any)                               *
.*                                                                   *
.*  AMODE                                                            *
.*       IF SPECIFIED, THIS  PARAMETER WILL GENERATE THE AMODE       *
.*       CARD FOR THE ASSEMBLER H.  AMODE IS A PROGRAM ATTRIBUTE     *
.*       WHICH CAN BE SET TO GIVE ADDRESSING MODE.
.*                                                                   *
.*  RMODE                                                            *
.*       IF SPECIFIED, THIS PARAMETER WILL GENERATE THE RMODE        *
.*       CARD FOR THE ASSEMBLER H.  RMODE IS A PROGRAM ATTRIBUTE     *
.*       WHICH CAN BE SET TO GIVE RESIDENCY MODE.                    *
.*                                                                   *
.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
.**********************************************************************
.***
.**           M o d i f i c a t i o n   H i s t o r y
.**
.** Person     Date        Description
.** ---------- ----------- --------------------------------------------
.** DGAlcock   2000-09-09  Change time to be standard;
.** DGAlcock   2000-03-02  Fix hardcoded century;
.** DGAlcock   07-FEB-1996 Renamed to DA#EYEC from PROLOGUE
.** DGAlcock   15-SEP-1994 Added ASMINFO= operand and changed to get
.** DGAlcock   20-FEB-1991 Added fancy date and time;
.** DGAlcock   ??-???-198? Added AMODE and RMODE operands;
.***
.**********************************************************************
.*
.**  DEFINE GLOBAL AND LOCAL SET SYMBOLS
.*
         GBLB  &PROLOG
         LCLC  &CS,&ECDATE,&ECTIME,&YEAR
         LCLA  &L1,&L2,&L3
&PROLOG  SETB  1
.*
         AIF   (T'&CSECT NE 'O').P001
&CS      SETC  '&SYSECT'
         AGO   .P002
.*
.** GENERATE CSECT, AMODE, AND RMODE CARDS
.*
.P001    ANOP
&CS      SETC  '&CSECT'
&CS      CSECT ,
.P002    ANOP  ,
.*-> MNOTE ' *** CSECT=&CSECT CS=&CS PROLOG=&PROLOG'
.*
.** AMODE and RMODE
.*
         AIF   ('&AMODE' EQ '').AMODEX
&CS      AMODE &AMODE
.AMODEX  AIF   ('&RMODE' EQ '').RMODEX
&CS      RMODE &RMODE
.RMODEX  ANOP  ,
 AIF  ('&ASMINFO' NE 'YES').TIMEX           .Want date and time info?
.*
.** Get Date
.*
 AIF  ('&DATEFMT' EQ 'ISO').DATEISO         Want "ccyy-mm-dd"?
 AIF  ('&DATEFMT' EQ 'OLD').DATEOLD         Want "mm/dd/yy"?
&ECDATE SETC '&SYSDATE'(4,2)'-'             .Get Day of month
.*
&YEAR  SETC '&SYSDATC'(1,4)                   .Grab century from HLASM
.*
 AIF  ('&SYSDATE'(1,2) EQ '01').DATEM01
 AIF  ('&SYSDATE'(1,2) EQ '02').DATEM02
 AIF  ('&SYSDATE'(1,2) EQ '03').DATEM03
 AIF  ('&SYSDATE'(1,2) EQ '04').DATEM04
 AIF  ('&SYSDATE'(1,2) EQ '05').DATEM05
 AIF  ('&SYSDATE'(1,2) EQ '06').DATEM06
 AIF  ('&SYSDATE'(1,2) EQ '07').DATEM07
 AIF  ('&SYSDATE'(1,2) EQ '08').DATEM08
 AIF  ('&SYSDATE'(1,2) EQ '09').DATEM09
 AIF  ('&SYSDATE'(1,2) EQ '10').DATEM10
 AIF  ('&SYSDATE'(1,2) EQ '11').DATEM11
 AIF  ('&SYSDATE'(1,2) EQ '12').DATEM12
 MNOTE 'DA#EYEC-01E Invalid month'
 AGO  .DATEMX
.*
.DATEM01 ANOP ,
&ECDATE SETC '&ECDATE'.'JAN-&YEAR'
 AGO  .DATEMX
.DATEM02 ANOP ,
&ECDATE SETC '&ECDATE'.'FEB-&YEAR'
 AGO  .DATEMX
.DATEM03 ANOP ,
&ECDATE SETC '&ECDATE'.'MAR-&YEAR'
 AGO  .DATEMX
.DATEM04 ANOP ,
&ECDATE SETC '&ECDATE'.'APR-&YEAR'
 AGO  .DATEMX
.DATEM05 ANOP ,
&ECDATE SETC '&ECDATE'.'MAY-&YEAR'
 AGO  .DATEMX
.DATEM06 ANOP ,
&ECDATE SETC '&ECDATE'.'JUN-&YEAR'
 AGO  .DATEMX
.DATEM07 ANOP ,
&ECDATE SETC '&ECDATE'.'JUL-&YEAR'
 AGO  .DATEMX
.DATEM08 ANOP ,
&ECDATE SETC '&ECDATE'.'AUG-&YEAR'
 AGO  .DATEMX
.DATEM09 ANOP ,
&ECDATE SETC '&ECDATE'.'SEP-&YEAR'
 AGO  .DATEMX
.DATEM10 ANOP ,
&ECDATE SETC '&ECDATE'.'OCT-&YEAR'
 AGO  .DATEMX
.*
.DATEM11 ANOP ,
&ECDATE SETC '&ECDATE'.'NOV-&YEAR'
 AGO  .DATEMX
.*
.DATEM12 ANOP ,
&ECDATE SETC '&ECDATE'.'DEC-&YEAR'
.*AGO .DATEMX
.DATEMX  ANOP ,
 AGO .DATEX
.*
.DATEOLD ANOP  ,               If not HLASM or higher
&ECDATE  SETC  '&SYSDATE'
 AGO .DATEX
.*
.DATEISO ANOP  ,
&ECDATE  SETC  '&SYSDATC'(1,4).'-'.'&SYSDATC'(5,2).'-'.'&SYSDATC'(7,2)
.DATEX ANOP
.*
.** Time
.*
 AIF  ('&TIMEFMT' EQ 'STD').TIMESTD         Want "hh:mm"
 AIF  ('&SYSTIME'(1,2) LT '12').TIMEN
 AIF  ('&SYSTIME'(1,2) EQ '12').TIMEH12
 AIF  ('&SYSTIME'(1,2) EQ '13').TIMEH13
 AIF  ('&SYSTIME'(1,2) EQ '14').TIMEH14
 AIF  ('&SYSTIME'(1,2) EQ '15').TIMEH15
 AIF  ('&SYSTIME'(1,2) EQ '16').TIMEH16
 AIF  ('&SYSTIME'(1,2) EQ '17').TIMEH17
 AIF  ('&SYSTIME'(1,2) EQ '18').TIMEH18
 AIF  ('&SYSTIME'(1,2) EQ '19').TIMEH19
 AIF  ('&SYSTIME'(1,2) EQ '20').TIMEH20
 AIF  ('&SYSTIME'(1,2) EQ '21').TIMEH21
 AIF  ('&SYSTIME'(1,2) EQ '22').TIMEH22
 AIF  ('&SYSTIME'(1,2) EQ '23').TIMEH23
 AIF  ('&SYSTIME'(1,2) EQ '24').TIMEH24
 AGO  .TIMEX
.TIMEH12 ANOP ,
&ECTIME SETC '12.'.'&SYSTIME'(4,2)' PM'
 AGO  .TIMEX
.TIMEH13 ANOP ,
&ECTIME SETC '01.'.'&SYSTIME'(4,2)' PM'
 AGO  .TIMEX
.TIMEH14 ANOP ,
&ECTIME SETC '02.'.'&SYSTIME'(4,2)' PM'
 AGO  .TIMEX
.TIMEH15 ANOP ,
&ECTIME SETC '03.'.'&SYSTIME'(4,2)' PM'
 AGO  .TIMEX
.TIMEH16 ANOP ,
&ECTIME SETC '04.'.'&SYSTIME'(4,2)' PM'
 AGO  .TIMEX
.TIMEH17 ANOP ,
&ECTIME SETC '05.'.'&SYSTIME'(4,2)' PM'
 AGO  .TIMEX
.TIMEH18 ANOP ,
&ECTIME SETC '06.'.'&SYSTIME'(4,2)' PM'
 AGO  .TIMEX
.TIMEH19 ANOP ,
&ECTIME SETC '07.'.'&SYSTIME'(4,2)' PM'
 AGO  .TIMEX
.TIMEH20 ANOP ,
&ECTIME SETC '08.'.'&SYSTIME'(4,2)' PM'
 AGO  .TIMEX
.TIMEH21 ANOP ,
&ECTIME SETC '09.'.'&SYSTIME'(4,2)' PM'
 AGO  .TIMEX
.TIMEH22 ANOP ,
&ECTIME SETC '10.'.'&SYSTIME'(4,2)' PM'
 AGO  .TIMEX
.TIMEH23 ANOP ,
&ECTIME SETC '11.'.'&SYSTIME'(4,2)' PM'
 AGO  .TIMEX
.TIMEH24 ANOP ,
&ECTIME SETC '12.'.'&SYSTIME'(4,2)' AM'
 AGO  .TIMEX
.TIMEN  ANOP ,
&ECTIME SETC '&SYSTIME'(1,5)' AM'         .Get Day of month
 AGO .TIMEX
.TIMESTD ANOP ,
&ECTIME SETC '&SYSTIME'                   .Standard time from ASMblr
.TIMEX ANOP
.*
.** Generate Eye Catcher
.*
                USING *,&USING            Get addressibility
                CNOP  0,4                 Full word alignment
                B     &CS._ECX            Branch around Eyecatcher
&CS._ECLEN      DC    AL1(&CS._ECL-1)
&CS._ECNAME     DC    CL8'&CS'
                DC    C' '
 AIF ('&ASMINFO' NE 'YES').ECDTX          .Want date and time info?
&CS._ECDATE     DC    C'&ECDATE'
                DC    C' '
&CS._ECTIME     DC    C'&ECTIME'
                DC    C' '
.ECDTX          ANOP  ,
 AIF ('&MSG' EQ '').ECMSGX
&CS._ECMSG      DC    C&MSG
.ECMSGX         ANOP  ,
&CS._ECL        EQU   *-&CS._ECLEN
&CS._ECX        DS    0H
                DROP  &USING
 MEND  ,
./ ADD NAME=DA#LEAVE 0100-01266-01266-1821-00236-00236-00000-DAVE
         MACRO ,
&LABEL   DA#LEAVE &RC=0,                  Return code                  @
               &LV=,                      Level to freemain            @
               &RR=,                      Return registers             @
               &FMTYPE=R,                 FREEMAIN type                @
               &RENT=NO,                  Re-entrant?                  @
               &GPR=YES,                  General Purpose registers?   @
               &SP=0                      Sub-pool to freemain
.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
.*  MACNAME:  LEAVE                                                  *
.*  MACAUTH:  Skip Abadie                                            *
.*  MACDATE:  12/01/80                                               *
.*  MACUPTE:  David Alcock                                           *
.*                                                                   *
.*  May be used in conjuntion with DA#ENTER macro.                   *
.*                                                                   *
.*  DA#ENTER and DA#LEAVE macros may be nested in an assembly,       *
.*  however, the LV and RENT parms must be explicitly given          *
.*  in this case.                                                    *
.*                                                                   *
.*  This macro automatically invokes the REQUATE (register equate)   *
.*  macro unless global flag &REGS is set to one.                    *
.*                                                                   *
.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
.*                                                                   *
.*  RC={LITERALÂ¦(REG)}                                               *
.*       RETURN CODE:  SPECIFY LITERAL 0 - 4095 OR SINGLE REGISTER   *
.*       (2) - (12) OR (15), TO BE RETURNED TO CALLER IN R15.        *
.*       DEFAULT RETURN CODE IS ZERO.                                *
.*                                                                   *
.*  RR={(REG,...,REGN)}                                              *
.*       RETURN REGISTER:  CONTENTS OF REGISTERS IN LIST WILL BE     *
.*       RETURNED TO CALLER (I.E.,  CALLERS REGISTERS CORRESPONDING  *
.*       TO REGISTERS SPECIFIED IN LIST WILL NOT BE RESTORED).       *
.*       SPECIFY REGISTERS 2 - 12 OR 0.  CAPABILITY TO RETURN R0 IS  *
.*       PROVIDED FOR FORTRAN FUNCTION COMPATIBILITY.  IT SHOULD BE  *
.*       NOTED THAT IF RR=(0) AND RENT=YES ARE BOTH SELECTED, THEN   *
.*       THE CONTENTS OF R0 MUST BE STORED IN, AND SUBSEQUENTLY      *
.*       RESTORED FROM, THE CALLERS SAVE AREA, SINCE THE FREEMAIN    *
.*       SVC ALTERS THE CONTENTS OF R0.                              *
.*                                                                   *
.*  LV={LITERAL}                                                     *
.*       LITERAL VALUE:  IF RENT=YES IS CODED, THE LITERAL VALUE IS  *
.*       THE SIZE OF THE AREA TO BE FREED BY THE FREEMAIN SVC.       *
.*       PARAMETER LV IS NOT REQUIRED IF DA#ENTER MACRO HAS          *
.*       PREVIOUSLY BEEN USED.  IT IS OBTAINED THROUGH GLOBAL        *
.*       VARIABLE &VIRT.  IF RENT=NO IS CODED OR ALLOWED TO DEFAULT, *
.*       THE LV PARAMETER IS IGNORED.                                *
.*                                                                   *
.*  RENT={YESÂ¦NO}                                                    *
.*       YES:  GENERATE FREEMAIN TO FREE STORAGE ACQUIRED BY DA#ENTER*
.*       MACRO.  IF THE LEAVE MACRO IS BEING USED TO FREE AN AREA    *
.*       THAT WAS NOT ACQUIRED BY THE DA#ENTER MACRO, THEN THE LV    *
.*       PARAMETER MUST ALSO BE SPECIFIED.                           *
.*       NO:   NO FREEMAIN SVC REQUIRED.                             *
.*                                                                   *
.*  GPR={YESÂ¦NO}                                                     *
.*       YES:  INVOKE REQUATE TO EQUATE REGISTERS                    *
.*       NO:   DON'T INVOKE REQUATE TO EQUATE REGISTERS              *
.*                                                                   *
.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
.*  ADDED MVS/XA (31-BIT RETURN) SUPPORT -DGA-85.224                 *
.*  ADDED GPR OPERAND -DGA-@04/19/86                                 *
.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
.*                                                                   *
.*  EXAMPLES:                                                        *
.*       DA#LEAVE RC=32,RR=(9,4),LV=300,RENT=YES                     *
.*       DA#LEAVE RR=(0),RENT=YES                                    *
.*       DA#LEAVE RC=(5),RR=(6)                                      *
.*       DA#LEAVE                                                    *
.*                                                                   *
.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
.**********************************************************************
.***                                                                ***
.**           M o d i f i c a t i o n   H i s t o r y                **
.**                                                                  **
.** Person     Date        Description                               **
.** ---------- ----------- ----------------------------------------- **
.** DGAlcock   07-FEB-1996 Renamed to DA#LEAVE from LEAVE            **
.***                                                                ***
.**********************************************************************
.*
.*  DEFINE GLOBAL AND LOCAL SET SYMBOLS
.*
         GBLC  &VIRT
         GBLB  &RE,&REGS,&ENTER31
.*
         LCLA  &R1,&R2,&RRT,&RICT
         LCLB  &ALV,&CLV,&RT(16),&RCR,&CC15
         LCLC  &DISP,&CC,&CCT,&NDX,&LAB
.*
.** REGISTER EQUATES
.*
         AIF   ('&GPR' EQ 'NO').L000
         AIF   ('&GPR' EQ 'YES').REQ00
         MNOTE ,'GPR=&GPR. IS INVALID, YES ASSUMED'
.REQ00   ANOP  ,
         AIF   (&REGS).L000
         DA#REGS ,                        EQUATE GENERAL PURPOSE REG
.L000    ANOP
.*
.*  SET CONSTANTS AND LOGICAL SWITCHES
.*
&RCR     SETB  ('&RC'(1,1) EQ '(')           SET RETURN CODE TYPE FLAG
&RRT     SETA  N'&RR                         SET NUMBER OF RETRN REGS
&RICT    SETA  1                             SET RETURN REG COUNTER
&ALV     SETB  (('&LV' GE '72') AND ('&LV' LE '4096'))   SET LV FLAG
&CLV     SETB  ('&LV' LE '0')                SET LV FLAG
&DISP    SETC  '20242832364044485256606468081216' STANDARD S.A. DISPLS
.*
.*  SET RT FLAGS FOR REGISTERS INCLUDED IN RR PARAMETER
.*
         AIF   (&RRT EQ 0).L002
.L001    ANOP
&R1      SETA  &RR(&RICT)
         AIF   (NOT &RT(&R1+1)).L001A        CHECK REDUNDANCY
         MNOTE 8,'REG &R1 REDUNDANTLY SPECIFIED - GEN SUPPRESSED'
         MEXIT
.L001A   ANOP
&RT(&R1+1) SETB  1                           SET REG USE BIT
         AIF   (((&R1 GE 2) AND (&R1 LE 12)) OR (&R1 EQ 0)).L001B
         MNOTE 8,'RETURN REG &R1 NOT PERMITTED - GEN SUPPRESSED'
         MEXIT
.L001B   ANOP
&RICT    SETA  &RICT+1
         AIF   (&RICT LE &RRT).L001
.*
.*  CHAIN BACK TO CALLERS SAVE AREA
.*
.L002    ANOP
&LAB     SETC  '&LABEL'
         AIF   ((NOT &RE) AND ('&RENT' EQ 'NO')).L002C
&LAB     LR    R1,R13                   OUR RSA ADDR
&LAB     SETC  ''
.L002C   ANOP
&LAB     L     R13,4(,R13)                Caller's RSA address
.*
.*  INITIALIZE RETURN CODE REGISTER (R15)
.*
         AIF   (&RCR).L002B
&CCT     SETC  'A'                         SET RETURN CODE TYPE
         AIF   ((&RC GE 0) AND (&RC LE 4095)).L002A
         MNOTE 4,'INVALID RETURN CODE - USING 4095'
&CC      SETC  '4095'                      SET RETURN CODE LITERAL
         AGO   .L003
.L002A   ANOP
&CC      SETC  '&RC'                       SET RETURN CODE LITERAL
         AGO   .L003
.L002B   ANOP
&CCT     SETC  'R'                         SET RETURN CODE TYPE
&CC      SETC  'R'.'&RC'(2,K'&RC-2)        SET RETURN CODE REGISTER
&CC15    SETB  ('&CC' EQ 'R15')            SET CC15 FLAG
         AIF   ((('&CC' GE 'R2') AND ('&CC' LE 'R12')) OR (&CC15)).L003
         MNOTE 4,'INVALID RETURN CODE REGISTER - USING LITERAL 4095'
&CCT     SETC  'A'                         SET RETURN CODE TYPE
&CC      SETC  '4095'                      SET RETURN CODE LITERAL
.*
.*  ISSUE FREEMAIN TO FREE OWN SAVE AREA (IF RENT=YES OR &RE ON)
.*
.L003    ANOP
         AIF   ((NOT &RE) AND ('&RENT' EQ 'NO')).L004
         AIF   (NOT &RT(1)).L003A          IF R0 NOT AN RR PARM, CONT.
*    ** WARNING **
*    RR=(0) WITH RENT=YES NECESSITATES MODIFYING THE CALLERS SAVE
*    AREA (R0 SLOT) BECAUSE THE FREEMAIN SVC ALTERS R0.
         ST    R0,20(,R13)        ** SAVE R0 IN CALLER'S RSA **
.L003A   ANOP
         AIF   (NOT &CC15).L003A1           IF NOT RC=(15), CONTINUE
*    ** WARNING **
*    RC=(15) WITH RENT=YES NECESSITATES MODIFYING THE CALLERS SAVE
*    AREA (R15 SLOT) BECAUSE THE FREEMAIN SVC ALTERS R15.
         ST    R15,16(,R13)       ** SAVE R15 IN CALLER'S RSA **
&CCT     SETC  ''                    * SET UP
&CC      SETC  '16(,R13)'            *   TO FORCE
&CC15    SETB  0                     *      LOAD ON R15
.L003A1  ANOP
         AIF   ('&VIRT' NE '0').L003C      USE VIRT IF NOT ZERO
         AIF   (&ALV OR &CLV).L003B        ELSE USE LV IF VALID
         MNOTE 8,'LV SPECIFIED IS INVALID - GEN SUPPRESSED'
         MEXIT
.L003B   ANOP
&VIRT    SETC  '&LV'
.L003C   ANOP
         MNOTE '         FREEMAIN &FMTYPE,LV=&VIRT,A=(1),SP=&SP'
         FREEMAIN &FMTYPE,LV=&VIRT,A=(1),SP=&SP
         AIF   (NOT &RT(1)).L004        IF R0 NOT AN RR PARM, CONT.
&RT(1)   SETB  0                        TURN OFF RETURN REG FLAG FOR R0
.*
.*  RESTORE 14, LOAD 15
.*
.L004    ANOP
         AIF   (&CC15).L004A            NO NEED TO LOAD R15 IF CC15 SET
         L&CCT R15,&CC                    Return code
.L004A   ANOP
         L     R14,12(,R13)               Return address
         AIF   (&RRT GT 0).L005
         LM    R0,R12,20(R13)             Restore caller's registers
         AGO   .L006
.*
.*  RESTORE REGS NOT INCLUDED IN RR PARAMETER
.*
.L005    ANOP
&RICT    SETA  0                        SET LOOP CONTROL
.L005A   ANOP
&R1      SETA  &RICT
&RICT    SETA  &RICT+1                  INCREMENT LOOP CONTROL
         AIF   ((&RT(&R1+1)) AND (&R1 LE 12)).L005A
         AIF   ((NOT &RT(&R1+2)) AND (&R1 LE 12)).L005B
         AIF   (NOT (&R1 LE 12)).L006
&CC      SETC  '&DISP'((&R1*2+1),2)
         L     R&R1.,&CC.(,R13)
         AGO   .L005A
.L005B   ANOP
&R2      SETA  &RICT
&RICT    SETA  &RICT+1                  INCREMENT LOOP CONTROL
         AIF   ((NOT &RT(&R2+1)) AND (&R2 LE 12)).L005B
&R2      SETA  &R2-1
&CC      SETC  '&DISP'((&R1*2+1),2)
         AIF   (&R1 EQ &R2).L005C
         LM    R&R1.,R&R2.,&CC.(R13)    RESTORE REGS
         AGO   .L005D
.L005C   ANOP
         L     R&R1.,&CC.(,R13)
.L005D   ANOP
         AIF   (&RICT LE 12).L005A
.*
.*  COMMON END FOR DA#LEAVE MACRO - GENERATE RETURN INSTRUCTION
.*
.L006    ANOP
         AIF   (&ENTER31).L007
.*       BR    R14
         BSM   0,R14                      Return to caller
         MEXIT ,
.L007    ANOP  ,
         BSM   0,R14                      Return to caller
         MEND
./ ADD NAME=DA#MXD   0100-01266-01266-1821-00040-00040-00000-DAVE
 MACRO
 DA#MXD &ITYPE
 AIF ('&ITYPE' EQ 'CSECT').CSECT
 AIF ('&ITYPE' EQ 'DSECT').DSECT
 AIF ('&ITYPE' EQ '').DSECT
 MNOTE 'DA#MXD - Invalid ITYPE: &ITYPE'
 MEXIT ,
.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
.*                                                                   *
.* Name: DA#MXD                                                      *
.*                                                                   *
.* Purpose: Produce DSECTs and Equates for the DA#MXD,               *
.*          Mini-Hex Dump, program                                   *
.*                                                                   *
.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
*
** Input to DA#MXD external subroutine
*
.CSECT        ANOP  ,
CMXD          DS    0F
 AGO          .DSECTX
.DSECT        ANOP  ,
CMXD          DSECT ,
.DSECTX       ANOP  ,
CMXD_RSA      DS    18F                   Register Save Area
CMXD_LIT      DS    C'CMXD'               Literal for dumps
CMXD_ADDRESS  DS    F                     -> Address
CMXD_LENGTH   DS    F                     Length
CMXD_OUTPUT   DS    F                     -> Output
CMXD_OUTPUTL  DS    H                     Output length (Default=80)
CMXD_OFFSET   DS    F                     Current Offset
CMXD_TRTAB    DS    F                     -> User Trans table or Zero
CMXD_FLAG1    DS    B'00000000'           Flag
$CMXD_F1ADDR  EQU   B'10000000'           ..Insert Address?
$CMXD_F1CAPS  EQU   B'01000000'           ..No lower case in char dump?
$CMXD_F1MOFF  EQU   B'00100000'           ..Max offset to full 8 bytes?
CMXD_VAR      DS    XL(CMXD_VARL)         Internal usage by DA#MXD
CMXD_VARL     EQU   CMXDL-(CMXD_VAR-CMXD) Length of internal area
CMXDL         EQU   256                   Total length of area
              MEND  ,
./ ADD NAME=DA#REGS  0100-01266-01266-1821-00067-00067-00000-DAVE
         MACRO
         DA#REGS &GPR=YES,      Equate General Purpose Registers?      @
               &FLOAT=NO        Equate Floating Point Registers?
.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
.*  MACNAME:  REQUATE                                                *
.*  MACAUTH:  Skip Abadie                                            *
.*  MACDATE:  12/01/80                                               *
.*  MACUPTE:  David Alcock                                           *
.*                                                                   *
.*  MACRO DA#REGS MAY BE USED TO EQUATE SYMBOLIC NAMES TO THE        *
.*  GENERAL PURPOSE REGISTERS.                                       *
.*                                                                   *
.*  THIS MACRO IS AUTOMATICALLY INVOKED BY MACROS ENTER AND LEAVE.   *
.*  WHEN INVOKED FOR THE FIRST TIME, DA#REGS SETS THE GLOBAL FLAG    *
.*  &REGS TO ONE.  IF THIS FLAG IS SET, DA#REGS WILL EXIT WITHOUT    *
.*  ANY EXPANSION.                                                   *
.*                                                                   *
.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
.*  CHANGED DA#REGS TO USE STATIC NUMBER OF REGISTERS AND ADDED      *
.*  FLOATING POINT REGISTERS ... DAVID ALCOCK @85.171                *
.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
.**********************************************************************
.***                                                                ***
.**           M o d i f i c a t i o n   H i s t o r y                **
.**                                                                  **
.** Person     Date        Description                               **
.** ---------- ----------- ----------------------------------------- **
.** DGAlcock   07-FEB-1996 Renamed to DA#REGS from REQUATE           **
.***                                                                ***
.**********************************************************************
         GBLB  &REGS,&FPREGS
.*
         AIF   ('&GPR' EQ 'NO').CHKFLT    SEE IF WE WANT GPR(S)
         AIF   (&REGS).CHKFLT             HAVE WE BEEN HERE BEFORE?
&REGS    SETB  1                          SET REQUATE GLOBAL FLAG
         SPACE 1
R0       EQU   0                               *
R1       EQU   1                              ***
R2       EQU   2                             *****
R3       EQU   3                            **   **
R4       EQU   4                           **     **
R5       EQU   5                          **       **
R6       EQU   6                         ** General **
R7       EQU   7                        *** Purpose ***
R8       EQU   8                         **  Regs   **
R9       EQU   9                          **       **
R10      EQU   10                          **     **
R11      EQU   11                           **   **
R12      EQU   12                            *****
R13      EQU   13                             ***
R14      EQU   14                              *
R15      EQU   15
         SPACE 1
.*
.CHKFLT  ANOP  ,
         AIF   ('&FLOAT' EQ 'NO').MACEND  SEE IF WE WANT FLOATING PT
         AIF   (&FPREGS).MACEND         HAVE WE BEEN HERE BEFORE?
         AIF   (&REGS).NOSPC            DID WE SPACED AFTER GPR?
         SPACE 1
.NOSPC   ANOP  ,
&FPREGS  SETB  1                        SET GLOBAL FLAG
FPR0     EQU   0                        FLOATING
FPR2     EQU   2                        ..POINT
FPR4     EQU   4                        ....REGISTER
FPR6     EQU   6                        ......EQUATES
         SPACE 1
.MACEND  MEND
./ ADD NAME=DA#SMODE 0100-01266-01266-1821-00035-00035-00000-DAVE
         MACRO ,
&LABEL   DA#SMODE &MODE,              24 Â¦ 31                          @
               &WREG=1                WORK REGISTER
.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
.*  MACNAME:  DA#SMODE                                               *
.*  MACAUTH:  DAVID ALCOCK --- (I REALLY "LIBERATED" IT FROM SDSF)   *
.*  MACDATE:  6/27/85                                                *
.*                                                                   *
.*  MACRO DA#SMODE MAY BE USED TO CHANGE THE ADDRESSING MODE, BY     *
.*  CHANGING THE PSW A-MODE BIT.  SEE PAGE 25 OF GC28-1158           *
.*  MVS/XA SPL: 31-BIT ADDRESSING                                    *
.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
.**********************************************************************
.***                                                                ***
.**           M o d i f i c a t i o n   H i s t o r y                **
.**                                                                  **
.** Person     Date        Description                               **
.** ---------- ----------- ----------------------------------------- **
.** DGAlcock   07-FEB-1996 Renamed to DA#SMODE from SETMODE          **
.***                                                                ***
.**********************************************************************
         AIF   ('&MODE' EQ '24').XAOFF
         AIF   ('&MODE' EQ '31').XAON
         MNOTE 8,'INVALID ADDRESSING MODE SPECIFIED - &MODE'
         MEXIT ,
.XAON    ANOP ,                    GO TO 31 BIT MODE
         CNOP  2,4                 FORCE FULL WORD ALIGNMENT
         LA    &WREG,*+14          POINT TO AMODE = 31 CODE
         O     &WREG,*+6           TURN ON AMODE = 31 BIT
         BSM   0,&WREG             BRANCH TO AMODE = 31 CODE
         DC    X'80000000'         AMODE = 31 BIT
         MEXIT ,
.XAOFF   LA    &WREG,*+6           POINT TO AMODE = 24 CODE
         BSM   0,&WREG             BRANCH TO AMODE = 24 CODE
         MEND
./ ADD NAME=DA#STR   0100-01266-01266-1821-00023-00023-00000-DAVE
 MACRO
 DA#STR &VALUE,&L=MINUS1
.*
.** Figure out the label problem
.*
 LCLC &OLAB
&OLAB SETC '&SYSLIST(0)'
 AIF ('&OLAB' NE '').OLABX
&OLAB SETC 'LZ&SYSNDX'
.OLABX ANOP ,
.*
.** Create a character string: Length, character value
.*
 AIF ('&L' EQ 'TOTAL').TOTAL
&OLAB DC AL1(&OLAB.L-2)
 AGO .TOTALX
.TOTAL ANOP ,
&OLAB DC AL1(&OLAB.L-1)
.TOTALX ANOP ,
.*
 DC C&VALUE
&OLAB.L EQU *-&OLAB
 MEND
./ ADD NAME=DA#TSOS  0100-01266-01266-1821-00951-00951-00000-DAVE
         MACRO ,
      DA#TSOS &ITYPE,                     Type of invocation           @
               &WA,                       Field to initialize          @
               &CPPL=,                    Address of the CPPL          @
               &STAX=,                    Address of the STAX Attn X   @
               &WRKREG=R1,                Work Register for GET funct. @
               &PCPPL=YES,                Process the CPPL? (Test it)  @
               &PCL=,                     Parameter Control List addr  @
               &PNAME=,                   Program name address         @
               &PNAMEL=7,                 Program name length          @
               &EPUTL=,                   ERROR routine for PUTLINE    @
               &EITERM=,                  ERROR: Invalid Terminal      @
               &ENTERM=,                  ERROR: Not Terminal          @
               &CSOREG=,                  CALCSBA: Output Register     @
               &CSCREG=,                  CALCSBA: Column Register     @
               &CSRREG=,                  CALCSBA: Row Register        @
               &OFFSET=,                  Message offset               @
               &OUTPUT=,                  Output location              @
               &NAME=,                    IKJPARMD field name          @
               &TYPE=,                    Type: CHAR etc               @
               &RJUST=,                   Right Justify                @
               &ERRET=,                   Error routine                @
               &RET=,                     Return address               @
               &MSG=,                     Messages for inserts         @
               &MF=E                      Macro Form
.**********************************************************************
.***                                                                ***
.**   Name: DA#TSOS                                                  **
.**                                                                  **
.**   Author: David G. Alcock                                        **
.**                                                                  **
.**   Purpose: TSO specific code generation                          **
.**            - Verify the CPPL                                     **
.**            - Initialize for PUTLINE                              **
.**            - Process TSO Parse                                   **
.**            - Full Screen (3270) processing                       **
.**            - Process parse and PUTLINE message inserts           **
.***                                                                ***
.**********************************************************************
.*
.** Decision table
.*
         AIF   ('&ITYPE' EQ '').DSECT
         AIF   ('&ITYPE' EQ 'DSECT').DSECT
         AIF   ('&ITYPE' EQ 'EQU').EQU
.*
         AIF   ('&ITYPE' EQ 'IOTABLE').IOTABLE I/O table wanted?
         AIF   ('&ITYPE' EQ 'AIDTAB').AIDTAB   Aid table + Description
         AIF   ('&ITYPE' EQ 'EQUATES').EQU     3270 equates?
         AIF   ('&ITYPE' EQ 'AID').AID         Just PFKs
.*
         AIF   ('&ITYPE' EQ 'EDITR1').EDITR1
         AIF   ('&ITYPE' EQ 'DPE2INS').DPE2INS
         AIF   ('&ITYPE' EQ 'TRIM').TRIM
.*
         AIF   ('&WA' EQ '').EWA
         AIF   ('&ITYPE' EQ 'INIT').INIT
         AIF   ('&ITYPE' EQ 'FSINIT').FSINIT
.*
         AIF   ('&ITYPE' EQ 'PDE2STR').PDE2STR
         AIF   ('&ITYPE' EQ 'PDE2NUM').PDE2NUM
.*
         AIF   ('&ITYPE' EQ 'INITMSG').INITMSG
         AIF   ('&ITYPE' EQ 'PRTMSG').PRTMSG
.*
         AIF   ('&ITYPE' EQ 'CALCSBA').CALCSBA
.*
         AIF   ('&ITYPE' EQ 'GETROW').GROW
         AIF   ('&ITYPE' EQ 'GETCOL').GCOL
         AIF   ('&ITYPE' EQ 'GETCPPL').GCPPL
         AIF   ('&ITYPE' EQ 'GETSCRA').GSCRA
         AIF   ('&ITYPE' EQ 'GETSCRL').GSCRL
         AIF   ('&ITYPE' EQ 'GETANS').GANS
         AIF   ('&ITYPE' EQ 'TSTQRY').TSTQRY
.*
         AIF   ('&ITYPE' EQ 'TERM').TERM
.*
.** Error routines
.*
 MNOTE 8,'RTSO-01E &ITYPE is invalid, macro can not be expanded'
 MEXIT ,
.EWA     ANOP  ,
 MNOTE 8,'RTSO-02E Work area not given'
 MEXIT ,
.EPNAME  ANOP  ,
 MNOTE 8,'RTSO-03E PNAME= not given'
 MEXIT ,
.EPNAMEL ANOP  ,
 MNOTE 8,'RTSO-04E PNAMEL= not given'
 MEXIT ,
.**********************************************************************
.***                                                                ***
.**            Convert PDE to Binary output                          **
.***                                                                ***
.**********************************************************************
.PDE2NUM ANOP ,
 DA#Z01 &SYSLIST(0)                       Generate Label (if any)
 L     R15,&WA+DA#TSOSD_ANS-DA#TSOSD      -> Answer Area
 ICM   R1,B'1111',&NAME.-IKJPARMD(R15)    Locate PDE
 BZ    P$&SYSNDX.O                        IF zero then set output to 0
.*
.** The Number in the PDE can be of different formats
.*
 AIF   ('&TYPE' EQ 'CHAR').P2NTC
 AGO   .EITYPE
.*
.** Character input number
.*
.P2NTC ANOP ,
 LH    R14,&NAME.-IKJPARMD+4(R15)         Obtain length of number
 BCTR  R14,0                              Decrement for EX
 PACK  DOUBLE(8),0(0,R1)                  ** Executed **
 EX    R14,*-6                            Make the number packed
 CVB   R1,DOUBLE                          Convert the number to binary
.*
.** Save the output in the approiate location
.*
P$&SYSNDX.O EQU *
 DA#Z00 &OUTPUT,REG=15                    Locate output
 ST    R1,0(R15)                          Save the number
 MEXIT ,
.**********************************************************************
.***                                                                ***
.**            Convert PDE to String                                 **
.***                                                                ***
.**********************************************************************
.PDE2STR ANOP ,
 DA#Z01 &SYSLIST(0)                       Generate Label (if any)
 L     R15,&WA+DA#TSOSD_ANS-DA#TSOSD      -> Answer Area
 SLR   R14,R14                            Clear length (in case none)
 ICM   R1,B'1111',&NAME.-IKJPARMD(R15)    Locate PDE
 BZ    P$&SYSNDX.X                        IF zero then set output to 0
 LH    R14,&NAME.-IKJPARMD+4(R15)         Obtain length of number
 BCTR  R14,0                              Decrement for EX
 DA#Z00 &OUTPUT,REG=15                    Locate output
.*
.** Right Justification
.*
 AIF   ('&RJUST' NE 'YES').P2SM           .Right Justification?
 LA    R15,&RJUSTL.-1(R15)                Point past string
 SR    R15,R14                            Back up to right just addr
.*
.** Move the string into the program's data area
.*
.P2SM ANOP ,
 MVC   0(0,R15),0(R1)                     ** Executed **
 EX    R14,*-6                            Make the number packed
P$&SYSNDX.X EQU *
 MEXIT ,
.**********************************************************************
.***                                                                ***
.**      Trim trailing blanks from a insert structure (data part)    **
.***                                                                ***
.**********************************************************************
.TRIM ANOP ,
 DA#Z00 &MF(2),REG=15                     .Locate message insert
 LH    R1,0(R15)                          Obtain current length
 LA    R14,0(R1,R15)                      Locate past it
T&SYSNDX.L EQU *
 BCTR  R14,0                              Backup up one
 CLI   0(R14),C' '                        Blank?
 BNE   T&SYSNDX.LX                        Nope, leave loop
 BCT   R1,T&SYSNDX.L                      Decrement length
 B     T&SYSNDX.X                         Ah oh- don't update it
T&SYSNDX.LX EQU *
 CH    R1,=H'5'                           Minimum length?
 BNL   T&SYSNDX.S                         Okay, move on
 LA    R1,5                               Set to minimum length
T&SYSNDX.S  EQU *
 STH   R1,0(R15)                          Save new length of insert
T&SYSNDX.X  EQU *
 MEXIT ,
.**********************************************************************
.***                                                                ***
.**        Convert DA#DATE  (Date routine) result into a TSO insert  **
.***                                                                ***
.**********************************************************************
.DPE2INS ANOP ,
 DA#Z00 &MF(2)
 SLR   R14,R14                            Clear register
 IC    R14,DA#TSOSD_STRL-DA#TSOSD(R1) Get length
 LA    R14,4(R14)                         Increment by header
 STH   R14,0(R1)                          Save into header
 LA    R14,&OFFSET                        Locate offset
 STH   R14,2(R1)                          Save into offset location
 DA#Z05 &RET                              .Return to caller
 MEXIT  ,
.**********************************************************************
.***                                                                ***
.**          Initialize the IOPL for GETLINE and PUTLINE             **
.***                                                                ***
.**********************************************************************
.EDITR1 ANOP ,
 DA#Z01 &SYSLIST(0)                       Generate Label (if any)
 LTR   R1,R1                              Is input number zero?
 BZ    D5E&SYSNDX.0                       Yes, leave
 DA#Z00 &MF(2),REG=15                     Locate output location
 CVD   R1,0(R15)                          Make number
 LA    R14,8(R15)                         Locate edited output
 LA    R1,11(R14)                         Locate past sig. digit
 MVC   0(12,R14),=X'40,20,20,20,20,20,20,20,20,20,21,20'
 EDMK  0(12,R14),2(R15)                   Edit the number
 LA    R14,12(R14)                        Locate past the number
 SR    R14,R1                             Length = End - Start
 DA#Z00 &OUTPUT,REG=15                    Locate output location
 BCTR  R14,0                              Decrement for EX
 MVC   4(0,R15),0(R1)                     ** Executed **
 EX    R14,*-6                            Move number to output
 LA    R14,4+1(R14)                       Bump up for Header + EX
 STH   R14,0(R15)                         Save length of number
 B     D5E&SYSNDX.X                       Leave
D5E&SYSNDX.0 EQU *
 DA#Z00 &OUTPUT,REG=15                    Locate output location
 LA    R1,5                               Length of header + number
 STH   R1,0(R15)                          Save it into header
 MVI   4(R15),C'0'                        Insert number
D5E&SYSNDX.X EQU *
 DA#Z05 &RET                              .Return to caller
 MEXIT ,
.*
.**********************************************************************
.***                                                                ***
.**     Generate AID table with 7 byte description                   **
.***                                                                ***
.**********************************************************************
.*
.CALCSBA ANOP  ,
 DA#Z01 &SYSLIST(0)                       Generate Label (if any)
         MVI   0(&CSOREG),$DA#TSOS_SBA    Move in SBA byte
         LA    &CSOREG,1(&CSOREG)         Bump past it
*
** Calculate binary offset: ((ROW-1) X WIDTH) + COLUMN-1)
*
         BCTR  &CSRREG,0                  Get Row relative to zero
         MH    &CSRREG,&WA+DA#TSOSD_SCRCOL-DA#TSOSD+2
         BCTR  &CSCREG,0                  Get Column relative to zero
         AR    &CSRREG,&CSCREG            Add to columns
*
** Convert Binary offset to 3270 Buffer Address
*
         SLR   &CSCREG,&CSCREG            Clear register
         C     &CSRREG,=F'4095'           Bigger screen?
         BH    CSB&SYSNDX                 Yes, move on
         SLDL  &CSCREG,26                 Shift first byte
         SRL   &CSRREG,26                 Shift back flush
         IC    R15,RTSO_DS3270T(&CSCREG) Pick up 1ST address byte
         SLL   R15,8                      Make room for 2ND Byte
         IC    R15,RTSO_DS3270T(&CSRREG) Pick up 2ND address byte
         STH   R15,0(&CSOREG)             Save SBA
         B     CSX&SYSNDX                 Leave
CSB&SYSNDX EQU *
         SLDL  &CSCREG,24                 Shift first byte
         SRL   &CSRREG,24                 Shift back flush
         STC   &CSCREG,0(&CSOREG)         Save SBA byte 1
         STC   &CSRREG,1(&CSOREG)         Save SBA byte 2
         B     CSX&SYSNDX                 Branch past table
         AGO   .IOTABLE                   .Get table
.CSIOTX  ANOP  ,
CSX&SYSNDX DS  0H
         LA    &CSOREG,2(&CSOREG)         Bump past SBA bytes
         MEXIT ,
.*
.**********************************************************************
.***                                                                ***
.**     Generate AID table with 7 byte description                   **
.***                                                                ***
.**********************************************************************
.*
.AIDTAB  ANOP  ,
*
**  Attention IDentification Table
*
RTSOA EQU     *
         DC   AL1($DA#TSOS_AIDNO),CL7'NOAID-D'
         DC   AL1($DA#TSOS_AIDNOP),CL7'NOAID-P'
         DC   AL1($DA#TSOS_AIDSELA),CL7'LT PEN'
         DC   AL1($DA#TSOS_AIDENT),CL7'Enter  '
         DC   AL1($DA#TSOS_AIDPF1),CL7'PFK1   '
         DC   AL1($DA#TSOS_AIDPF2),CL7'PFK2   '
         DC   AL1($DA#TSOS_AIDPF3),CL7'PFK3   '
         DC   AL1($DA#TSOS_AIDPF4),CL7'PFK4   '
         DC   AL1($DA#TSOS_AIDPF5),CL7'PFK5   '
         DC   AL1($DA#TSOS_AIDPF6),CL7'PFK6   '
         DC   AL1($DA#TSOS_AIDPF7),CL7'PFK7   '
         DC   AL1($DA#TSOS_AIDPF8),CL7'PFK8   '
         DC   AL1($DA#TSOS_AIDPF9),CL7'PFK9   '
         DC   AL1($DA#TSOS_AIDPF10),CL7'PFK10   '
         DC   AL1($DA#TSOS_AIDPF11),CL7'PFK11   '
         DC   AL1($DA#TSOS_AIDPF12),CL7'PFK12   '
         DC   AL1($DA#TSOS_AIDPF13),CL7'PFK13   '
         DC   AL1($DA#TSOS_AIDPF14),CL7'PFK14   '
         DC   AL1($DA#TSOS_AIDPF15),CL7'PFK15   '
         DC   AL1($DA#TSOS_AIDPF16),CL7'PFK16   '
         DC   AL1($DA#TSOS_AIDPF17),CL7'PFK17   '
         DC   AL1($DA#TSOS_AIDPF18),CL7'PFK18   '
         DC   AL1($DA#TSOS_AIDPF19),CL7'PFK19   '
         DC   AL1($DA#TSOS_AIDPF20),CL7'PFK20   '
         DC   AL1($DA#TSOS_AIDPF21),CL7'PFK21   '
         DC   AL1($DA#TSOS_AIDPF22),CL7'PFK22   '
         DC   AL1($DA#TSOS_AIDPF23),CL7'PFK23   '
         DC   AL1($DA#TSOS_AIDPF24),CL7'PFK24   '
         DC   AL1($DA#TSOS_AIDPA1),CL7'PA1    '
         DC   AL1($DA#TSOS_AIDPA2),CL7'PA2    '
         DC   AL1($DA#TSOS_AIDPA3),CL7'PA3    '
         DC   AL1($DA#TSOS_AIDCLR),CL7'Clear  '
         DC   AL1($DA#TSOS_AIDREQ),CL7'TestReq'
         DC   AL1($DA#TSOS_AIDOPID),CL7'OperID'
RTSOAE EQU     ((*-RTSOA)/RTSOAL)            Number of entries
RTSOAL EQU     1+7                           Length of each entry
         DC   AL1(0),CL7'Unknown'
 MEXIT ,
.*
.**********************************************************************
.***                                                                ***
.**         3270 Data Stream control character equates               **
.***                                                                ***
.**********************************************************************
.*
.EQU     ANOP  ,
*
** Buffer orders
*
$DA#TSOS_SF  EQU X'1D'                    Start Field
$DA#TSOS_SBA EQU X'11'                    Set Buffer Address
$DA#TSOS_IC  EQU X'13'                    Insert Cursor
$DA#TSOS_PT  EQU X'05'                    Program Tab
$DA#TSOS_RA  EQU X'3C'                    Repeat to Address
$DA#TSOS_SFE EQU X'29'                    Start Field Extended
$DA#TSOS_EUA EQU X'12'                    Repeat Unprotected to Address
$DA#TSOS_MF  EQU X'2C'                    Modify Field
$DA#TSOS_SA  EQU X'28'                    Set Attribute
*
** Extended Highlighting
*
$DA#TSOS_XHILITE    EQU X'41'              Extended Highlighting
$DA#TSOS_XH_DEFAULT EQU X'00'              ..Select default
$DA#TSOS_XH_BLINK   EQU X'F1',X'10'        ..Blink
$DA#TSOS_XH_RVIDEO  EQU X'F2',X'20'        ..Reverse Video
$DA#TSOS_XH_USCORE  EQU X'F4',X'30'        ..Underscore
*
** Extended Color
*
$DA#TSOS_XCOLOR     EQU X'42'              Extended Color
$DA#TSOS_XC_DEFAULT EQU X'00'              ..Select default
$DA#TSOS_XC_BLUE    EQU X'F1',X'01'        ..Blue
$DA#TSOS_XC_RED     EQU X'F2',X'02'        ..Red
$DA#TSOS_XC_PINK    EQU X'F3',X'03'        ..Pink
$DA#TSOS_XC_GREEN   EQU X'F4',X'04'        ..Green
$DA#TSOS_XC_TURQ    EQU X'F5',X'05'        ..Turquoise
$DA#TSOS_XC_YELLOW  EQU X'F6',X'06'        ..Yellow
$DA#TSOS_XC_WHITE   EQU X'F7',X'07'        ..White
*
** Attribute character equates
**
**  A...Prefix for attributes          H...High intensity
**  U...Unprotected field              E...Select pen detectable
**  P...Protected field                I...Non-Display
**  N...Numerics only                  M...Modified data tag on
**  S...Automatic skip
*
$DA#TSOS_AU     EQU X'40',X'FF' UNPROT
$DA#TSOS_AUM    EQU X'C1'    UNPROT,MDT ON
$DA#TSOS_AUE    EQU X'C4'    UNPROT,SEL PEN
$DA#TSOS_AUEM   EQU X'C5'    UNPROT,SEL PEN,MDT ON
$DA#TSOS_AUHE   EQU X'C8'    UNPROT,HIGH INTENS,SEL PEN
$DA#TSOS_AUHEM  EQU X'C9',X'FE' UNPROT,HIGH INTENS,SEL PEN,MDT ON
$DA#TSOS_AUI    EQU X'4C'    UNPROT,NON-DISP
$DA#TSOS_AUIM   EQU X'4D'    UNPROT,NON-DISP,MDT ON
$DA#TSOS_AUN    EQU X'50'    UNPROT,NUMERIC
$DA#TSOS_AUNM   EQU X'D1'    UNPROT,NUMERIC,MDT ON
$DA#TSOS_AUNE   EQU X'D4'    UNPROT,NUMERIC,SEL PEN
$DA#TSOS_AUNEM  EQU X'D5'    UNPROT,NUMERIC,SEL PEN,MDT ON
$DA#TSOS_AUNHE  EQU X'D8'    UNPROT,NUMERIC,HIGH INTENS,SEL PEN
$DA#TSOS_AUNHEM EQU X'D9'    UNPROT,NUMERIC,HIGH INTENS,SEL PEN,MDT ON
$DA#TSOS_AUNI   EQU X'5C'    UNPROT,NUMERIC,NON-DISP
$DA#TSOS_AUNIM  EQU X'5D'    UNPROT,NUMERIC,NON-DISP,MDT ON
$DA#TSOS_AP     EQU X'60'    PROT
$DA#TSOS_APM    EQU X'61'    PROT,MDT ON
$DA#TSOS_APE    EQU X'E4'    PROT,SEL PEN
$DA#TSOS_APEM   EQU X'E5'    PROT,SEL PEN,MDT ON
$DA#TSOS_APHE   EQU X'E8'    PROT,HIGH INTENS,SEL PEN
$DA#TSOS_APHEM  EQU X'E9'    PROT,HIGH INTENS,SEL PEN,MDT ON
$DA#TSOS_API    EQU X'6C'    PROT,NON-DISP
$DA#TSOS_APIM   EQU X'6D'    PROT,NON-DISP,MDT ON
$DA#TSOS_APS    EQU X'F0'    PROT,AUTO SKIP
$DA#TSOS_APSM   EQU X'F1'    PROT,AUTO SKIP,MDT ON
$DA#TSOS_APSE   EQU X'F4'    PROT,AUTO SKIP,SEL PEN
$DA#TSOS_APSEM  EQU X'F5'    PROT,AUTO SKIP,SEL PEN,MDT ON
$DA#TSOS_APSHE  EQU X'F8'    PROT,AUTO SKIP,HIGH INTENS,SEL PEN
$DA#TSOS_APSHEM EQU X'F9'    PROT,AUTO SKIP,HIGH INTENS,SEL PEN,MDT ON
$DA#TSOS_APSI   EQU X'7C'    PROT,AUTO SKIP,NON-DISP
$DA#TSOS_APSIM  EQU X'7D'    PROT,AUTO SKIP,NON-DISP,MDT ON
*
**  Command codes
*
$DA#TSOS_CCW   EQU X'F1'  WRITE
$DA#TSOS_CCEW  EQU X'F5'  ERASE/WRITE
$DA#TSOS_CCEWA EQU X'7E'  ERASE/WRITE ALTERNATE
$DA#TSOS_CCRB  EQU X'F2'  READ BUFFER
$DA#TSOS_CCRM  EQU X'F6'  READ MODIFIED
$DA#TSOS_CCRMA EQU X'6E'  READ MODIFIED ALL
$DA#TSOS_CCEAU EQU X'6F'  ERASE ALL UNPROTECTED
$DA#TSOS_CCWSF EQU X'F3'  WRITE STRUCTURED FIELD
*
**  Write Control Character
*
$DA#TSOS_WCCM  EQU X'C1'   RESET MDT'S
$DA#TSOS_WCCK  EQU X'C2'   KEYBOARD RESTORE
$DA#TSOS_WCCKM EQU X'C3'   KEYBOARD RESTORE,RESET MDT'S
*
**  InBound Structured Fields
*
$DA#TSOS_AIDISF EQU X'C1'        Inbound Structured Field
$DA#TSOS_AISF_IB3270 EQU X'80'   ..InBound 3270DS
$DA#TSOS_AISF_QR   EQU X'81'     ..Query Reply
$DA#TSOS_AISF_QRCOLOR  EQU X'86'   ..Color
*
**  Attention IDentification
*
.AID     ANOP  ,
$DA#TSOS_AIDNO   EQU X'60'  NO AID GENERATED (DISPLAY)
$DA#TSOS_AIDNOP  EQU X'E8'  NO AID GENERATED (PRINTER)
$DA#TSOS_AIDSELA EQU X'7E'  SELECTOR LIGHT-PEN ATTENTION SPACE NULL
$DA#TSOS_AIDENT  EQU X'7D'  ENTER KEY AND SEL PEN ATTENTION
$DA#TSOS_AIDPF1  EQU X'F1'  PF 1 KEY
$DA#TSOS_AIDPF2  EQU X'F2'  PF 2 KEY
$DA#TSOS_AIDPF3  EQU X'F3'  PF 3 KEY
$DA#TSOS_AIDPF4  EQU X'F4'  PF 4 KEY
$DA#TSOS_AIDPF5  EQU X'F5'  PF 5 KEY
$DA#TSOS_AIDPF6  EQU X'F6'  PF 6 KEY
$DA#TSOS_AIDPF7  EQU X'F7'  PF 7 KEY
$DA#TSOS_AIDPF8  EQU X'F8'  PF 8 KEY
$DA#TSOS_AIDPF9  EQU X'F9'  PF 9 KEY
$DA#TSOS_AIDPF10 EQU X'7A'  PF 10 KEY
$DA#TSOS_AIDPF11 EQU X'7B'  PF 11 KEY
$DA#TSOS_AIDPF12 EQU X'7C'  PF 12 KEY
$DA#TSOS_AIDPF13 EQU X'C1'  PF 13 KEY
$DA#TSOS_AIDPF14 EQU X'C2'  PF 14 KEY
$DA#TSOS_AIDPF15 EQU X'C3'  PF 15 KEY
$DA#TSOS_AIDPF16 EQU X'C4'  PF 16 KEY
$DA#TSOS_AIDPF17 EQU X'C5'  PF 17 KEY
$DA#TSOS_AIDPF18 EQU X'C6'  PF 18 KEY
$DA#TSOS_AIDPF19 EQU X'C7'  PF 19 KEY
$DA#TSOS_AIDPF20 EQU X'C8'  PF 20 KEY
$DA#TSOS_AIDPF21 EQU X'C9'  PF 21 KEY
$DA#TSOS_AIDPF22 EQU X'4A'  PF 22 KEY
$DA#TSOS_AIDPF23 EQU X'4B'  PF 23 KEY
$DA#TSOS_AIDPF24 EQU X'4C'  PF 24 KEY
$DA#TSOS_AIDPA1  EQU X'6C'  PA 1 KEY
$DA#TSOS_AIDPA2  EQU X'6E'  PA 2 KEY
$DA#TSOS_AIDPA3  EQU X'6B'  PA 3 KEY
$DA#TSOS_AIDCLR  EQU X'6D'  CLEAR KEY
$DA#TSOS_AIDREQ  EQU X'F0'  TEST REQ AND SYS REQ KEY
$DA#TSOS_AIDOPID EQU X'E6'  OPERATOR IDENTIFICATION
 MEXIT ,
.*
.**********************************************************************
.***                                                                ***
.**      Generate an I/O table (see 3274 programming guide)          **
.***                                                                ***
.**********************************************************************
.*
.IOTABLE ANOP ,
*
** 3270 Control character I/O codes
*
DA#TSOS_DS3270T EQU *
 DC X'40,C1,C2,C3,C4,C5,C6,C7,C8,C9,4A,4B,4C,4D,4E,4F'
 DC X'50,D1,D2,D3,D4,D5,D6,D7,D8,D9,5A,5B,5C,5D,5E,5F'
 DC X'60,61,E2,E3,E4,E5,E6,E7,E8,E9,6A,6B,6C,6D,6E,6F'
 DC X'F0,F1,F2,F3,F4,F5,F6,F7,F8,F9,7A,7B,7C,7D,7E,7F'
.IOTX    ANOP  ,
         AIF   ('&ITYPE' EQ 'CALCSBA').CSIOTX
         MEXIT ,
.**********************************************************************
.***                                                                ***
.**      Full Screen Initialization                                  **
.***                                                                ***
.**********************************************************************
.FSINIT  ANOP ,
*
** Ensure that the terminal meets minimum requirements
*
         LA    R14,&WA                    Locate work area
         CLI   DA#TSOSD_SCRROW-DA#TSOSD+3(R14),24 Columns => 24
         BL    &EITERM                    No, invalid
         CLI   DA#TSOSD_SCRCOL-DA#TSOSD+3(R14),80 Rows => 80
         BL    &EITERM                    No, invalid
*
** Establish a Full screen environment
*
 MNOTE ' STFSMODE ON,INITIAL=YES          Start full screen mode '
         STFSMODE ON,INITIAL=YES          Start full screen mode
         LTR   R15,R15                    Was it successfull
         BNZ   &ENTERM                    No, fullscreen not available
 MNOTE ' STTMPMD ON                       Give control to the cmd proc'
         STTMPMD ON                       Give control to the cmd proc
 MNOTE ' STLINENO LINE=1                  Tell VTAM where to go'
         STLINENO LINE=1                  Tell VTAM where to go
         OI    &WA+DA#TSOSD_F1-DA#TSOSD,$DA#TSOSD_F1_FS
*
** Clear Queues
*
 MNOTE ' TCLEARQ INPUT                    Clear Input queue'
         TCLEARQ INPUT                    Clear Input queue (terminal)
 MNOTE ' TCLEARQ OUTPUT                   Clear Output queue'
         TCLEARQ OUTPUT                   Clear Output queue (terminal)
         AIF   ('&STAX' EQ '').FSISX      .Do Stax processing?
*
** Create an attention exit
*
 LA  R14,&WA+DA#TSOSD_STAXR13-DA#TSOSD    Locate DSA pointer
 ST  R13,0(R14)                           Save address of DSA
 LA  R1,&WA+DA#TSOSD_RECOUT-DA#TSOSD      Locate parameter list area
 MVC 0(I&SYSNDX.L,R1),I&SYSNDX            Copy STAX Parm List
 L   R15,&STAX                            Locate STAX routine
 MNOTE ' STAX  (R15),                     Address of STAX routine @'
 MNOTE '       USADDR=(R14),              Address of WORKDS       @'
 MNOTE '       MF=(E,(R1))                Execute from here        '
         STAX  (R15),                     Address of STAX routine      @
               USADDR=(R14),              Address of WORKDS            @
               MF=(E,(R1))                Execute from here
         OI    &WA+DA#TSOSD_F1-DA#TSOSD,$DA#TSOSD_F1_STAX
         B     I&SYSNDX.X EQU *           Branch past constant
 MNOTE 'I&SYSNDX STAX MF=L '
I&SYSNDX STAX *-*,MF=L
I&SYSNDX.L EQU *-I&SYSNDX
I&SYSNDX.X EQU *
.FSISX   ANOP  ,
*
** Obtain an area to build the screen buffer
*
         SPACE 2
         SLR   R0,R0                      Clear register for mulitply
         L     R1,&WA+DA#TSOSD_SCRROW-DA#TSOSD
         MH    R1,&WA+DA#TSOSD_SCRCOL-DA#TSOSD+2
         LA    R1,256(R1)                 Add header + slack
         LR    R0,R1                      Put into getmain register
 MNOTE ' GETMAIN R,                       Obtain storage      @'
 MNOTE '       LV=(0)                     Length of screen     '
         GETMAIN R,                       Obtain storage               @
               LV=(0)                     Length of screen
         ST    R0,&WA+DA#TSOSD_SCRL-DA#TSOSD >Length
         ST    R1,&WA+DA#TSOSD_SCRA-DA#TSOSD >Address
         MEXIT ,
.**********************************************************************
.***                                                                ***
.**      Get fields from Work Area                                   **
.***                                                                ***
.**********************************************************************
.GANS    ANOP  ,
         L     &WRKREG,&WA+DA#TSOSD_ANS-DA#TSOSD
         MEXIT ,
.GCPPL   ANOP  ,
         L     &WRKREG,&WA+DA#TSOSD_CPPL-DA#TSOSD
         MEXIT ,
.GROW    ANOP  ,
         L     &WRKREG,&WA+DA#TSOSD_SCRROW-DA#TSOSD
         MEXIT ,
.GCOL    ANOP  ,
         L     &WRKREG,&WA+DA#TSOSD_SCRCOL-DA#TSOSD
         MEXIT ,
.GSCRA   ANOP  ,
         L     &WRKREG,&WA+DA#TSOSD_SCRA-DA#TSOSD
         MEXIT ,
.GSCRL   ANOP  ,
         L     &WRKREG,&WA+DA#TSOSD_SCRL-DA#TSOSD
         MEXIT ,
.TSTQRY  ANOP  ,
         TM    &WA+DA#TSOSD_AFLAG4-DA#TSOSD,$DA#TSOSD_AF4QUERY
         BNO   &ERRET
         MEXIT ,
.**********************************************************************
.***                                                                ***
.**      Initialization                                              **
.***                                                                ***
.**********************************************************************
.INIT    ANOP ,
 LA    R1,&WA                     Save address of storage
 MVI   0(R1),X'00'
 MVC   1(DA#TSOSD_RECOUT-DA#TSOSD,R1),0(R1)
.*
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
** Obtain terminal information
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 MNOTE ' GTSIZE ,'
 GTSIZE ,
 ST    R0,&WA+DA#TSOSD_SCRROW-DA#TSOSD
 ST    R1,&WA+DA#TSOSD_SCRCOL-DA#TSOSD
*
 MNOTE ' GTTERM PRMSZE=&WA+DA#TSOSD_PRMSIZE-DA#TSOSD, '
 MNOTE '       ALTSZE=&WA+DA#TSOSD_ALTSIZE-DA#TSOSD,  '
 MNOTE '       ATTRIB=&WA+DA#TSOSD_ATTRIB-DA#TSOSD,   '
 MNOTE '       MF=(E,&WA+DA#TSOSD_RECOUT-DA#TSOSD     '
         GTTERM PRMSZE=&WA+DA#TSOSD_PRMSIZE-DA#TSOSD,                  @
               ALTSZE=&WA+DA#TSOSD_ALTSIZE-DA#TSOSD,                   @
               ATTRIB=&WA+DA#TSOSD_ATTRIB-DA#TSOSD,                    @
               MF=(E,&WA+DA#TSOSD_RECOUT-DA#TSOSD)
 XC &WA+DA#TSOSD_RECOUT-DA#TSOSD(12),&WA+DA#TSOSD_RECOUT-DA#TSOSD
 SPACE 2
.*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.** CPPL CPPL CPPL CPPL CPPL CPPL CPPL CPPL CPPL CPPL CPPL CPPL CPPL
.*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         AIF   ('&PCPPL' EQ 'NO').CPPLX
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
** CPPL processing
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 SPACE 2
 L     R1,&CPPL                   Locate the CPPL
 ST    R1,&WA+DA#TSOSD_CPPL-DA#TSOSD Save the current CPPL
 TM    CPPLCBUF-CPPL(R1),B'10000000' Were we called?
 BNO   DA#TSOS_CPPLX_I&SYSNDX     No, CPPL is good
*
** Build Fake CPPL, CBUF for called "Command Processor"
*
 LA    R0,DA#TSOSFL               Get Control block length
 L     R14,0(R1)                  Locate parameter list
 AH    R0,0(R14)                  Obtain the length
 MNOTE ' GETMAIN R,LV=(0)'
 GETMAIN R,LV=(0)                 Obtain storage
*
 STM   R0,R1,&WA+DA#TSOSD_FCPPLVS-DA#TSOSD
 XC    0(DA#TSOSFL,R1),0(R1)              Clear work area
*
** Initialize the command buffer header and save location into CPPL
*
 LA    R15,DA#TSOSF_CBUF_H-DA#TSOSF(R1) Locate CBUF
 ST    R15,CPPLCBUF-CPPL(R1)      Save address of CBUF
 MVC   DA#TSOSF_CBUF_H+2-DA#TSOSF(2,R1),=AL2(&PNAMEL)
 LA    R14,&PNAMEL-1              Get program Name length
 LA    R15,DA#TSOSF_CBUF_B-DA#TSOSF(R1) Locate CBUF buffer
*
** Place program name into buffer
*
 AIF   ('&PNAME' EQ '').EPNAME          .Program name address?
 AIF   ('&PNAMEL' EQ '').EPNAMEL        .Program Name length?
.*
 AIF   ('&PNAME'(1,1) EQ '(').IPNAMER   .Register format?
 MVC   0(0,R15),&PNAME
 AGO   .IPNAMEX                         .Move on
.IPNAMER ANOP  ,
 MVC   0(0,R15),0(&PNAME(1))
.IPNAMEX ANOP  ,
 EX    R14,*-6                    Move program name out
 LA    R15,1(R14,R15)             Bump past program name
 MVI   0(R15),C' '                Ensure blanks
 LA    R15,1(R15)                 Bump past it
*
** If there is something passed to us in the Batch style parm, place
** it into the CBUF
*
 L     R14,&CPPL                          Locate parameter start
 L     R14,0(R14)                         Locate address
 SLR   R1,R1                              Clear register
 ICM   R1,B'0011',0(R14)                  Obtain the length
 BZ    ICPPL$CBX                          Zero, leave
 BCTR  R1,0                               Decrement for EX
 MVC   0(0,R15),2(R14)                    ** Executed **
 EX    R1,*-6                             Move parameter to our CBUF
 LA    R15,1(R1,R15)                      Bump past it
ICPPL$CBX EQU *
 L     R1,&WA+DA#TSOSD_CPPL-DA#TSOSD      -> DA#TSOSF
 LA    R14,DA#TSOSF_CBUF_H-DA#TSOSF(R1)   Locate start of CBUF
 SR    R15,R14                            Length = End - Begining
 STH   R15,DA#TSOSF_CBUF_H-DA#TSOSF(R1)   Save length
*
** Locate Control Blocks (PSCB & UPT) and place into fake CPPL
*
 L     R15,PSATOLD-PSA            -> TCB
 L     R15,TCBJSCB-TCB(,R15)      -> JSCB
 L     R15,JSCBPSCB-IEZJSCB(,R15) -> PSCB
 ST    R15,CPPLPSCB-CPPL(R1)      Save address of PSCB
*
 L     R15,PSCBUPT-PSCB(R15)      -> UPT
 ST    R15,CPPLUPT-CPPL(R1)       Save address of UPT
*
 L     R15,PSAAOLD-PSA            -> ASCB
 L     R15,ASCBASXB-ASCB(,R15)    -> ASXB
 L     R15,ASXBLWA-ASXB(R15)      -> LWA
 L     R15,LWAPECT-LWA(,R15)      -> ECT
 ST    R15,CPPLECT-CPPL(R1)       Save address of ECT
DA#TSOS_CPPLX_I&SYSNDX EQU *
.CPPLX   ANOP  ,
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
** Initialize PUTLINE routine
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 LA    R15,&WA                            Locate Work area
 L     R1,DA#TSOSD_CPPL-DA#TSOSD(R15)     Locate CPPL
 L     R14,CPPLUPT-CPPL(,R1)              Get UPT location
 ST    R14,DA#TSOSD_IOPL-DA#TSOSD+IOPLUPT-IOPL(R15)
 L     R14,CPPLECT-CPPL(,R1)              Get ECT location
 ST    R14,DA#TSOSD_IOPL-DA#TSOSD+IOPLECT-IOPL(R15)
.*
 LA    R14,DA#TSOSD_PLECB-DA#TSOSD(R15) Locate ECB
 ST    R14,DA#TSOSD_IOPL-DA#TSOSD+IOPLECB-IOPL(R15)
 LA    R14,DA#TSOSD_PTPB-DA#TSOSD(R15)    Locate PTPB
 ST    R14,DA#TSOSD_IOPL-DA#TSOSD+IOPLIOPB-IOPL(R15)
 MVC   0(DA#TSOS_PUTLC_I&SYSNDX.L,R14),DA#TSOS_PUTLC_I&SYSNDX
 B     DA#TSOS_PUTLC_I&SYSNDX.X EQU * Branch past constant
*
 MNOTE 'DA#TSOS_PUTLC_I&SYSNDX PUTLINE OUTPUT=(0,TERM,SINGLE,...'
DA#TSOS_PUTLC_I&SYSNDX PUTLINE OUTPUT=(*-*,TERM,SINGLE,INFOR),MF=L
DA#TSOS_PUTLC_I&SYSNDX.L EQU *-DA#TSOS_PUTLC_I&SYSNDX
DA#TSOS_PUTLC_I&SYSNDX.X EQU *
*
 LA    R15,&WA                            Locate work area
 LA    R1,1                               || Put line number
 ST    R1,DA#TSOSD_PLNUM-DA#TSOSD(R15)    ||
.*
 LA    R1,DA#TSOSD_RECHEAD-DA#TSOSD(R15) ||| Putline address
 XC    2(2,R1),0(R1)                      |||
 ST    R1,DA#TSOSD_PLADR-DA#TSOSD(R15)    |||
.*
 LA    R1,DA#TSOSD_PLNUM-DA#TSOSD(R15)
 ST    R1,DA#TSOSD_PTPB-DA#TSOSD+PTPBOPUT-PTPB(R15)
.*
 AIF   ('&PCL' EQ '').IPARSEX       .Do PARSE processing
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
** Initialize PARSE routine
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 LA    R15,&WA                      Locate Work area
 L     R14,DA#TSOSD_CPPL-DA#TSOSD(R15) -> CPPL
 L     R1,CPPLUPT-CPPL(,R14)
 ST    R1,DA#TSOSD_PPL-DA#TSOSD+PPLUPT-PPL(R15)
 L     R1,CPPLECT-CPPL(,R14)
 ST    R1,DA#TSOSD_PPL-DA#TSOSD+PPLECT-PPL(R15)
 LA    R1,DA#TSOSD_PARSECB-DA#TSOSD(R15)
 ST    R1,DA#TSOSD_PPL-DA#TSOSD+PPLECB-PPL(R15)
 L     R1,&PCL
 ST    R1,DA#TSOSD_PPL-DA#TSOSD+PPLPCL-PPL(R15)
 LA    R1,DA#TSOSD_ANS-DA#TSOSD(R15)
 ST    R1,DA#TSOSD_PPL-DA#TSOSD+PPLANS-PPL(R15)
 L     R1,CPPLCBUF-CPPL(,R14)
 ST    R1,DA#TSOSD_PPL-DA#TSOSD+PPLCBUF-PPL(R15)
*
** Call the TSO PARSE routine
*
 LA    R1,&WA
 LA    R1,DA#TSOSD_PPL-DA#TSOSD(R1)
 MNOTE ' CALLTSSR EP=IKJPARS,MF=(E,(1)) '
 CALLTSSR EP=IKJPARS,MF=(E,(1))
 CH    R15,=H'0'                          Parse Successful?
 BE    DA#TSOS_PARSEX_I&SYSNDX            No, continue
 CH    R15,=H'4'
 BE    DA#TSOS_PARSEE_I&SYSNDX
 CH    R15,=H'20'
 BE    DA#TSOS_PARSEE_I&SYSNDX
*
 LA    R1,&WA+DA#TSOSD_RECOUT+4-DA#TSOSD
 XC    0(GFLENGF,R1),0(R1)                Clear the Parm list
 ST    R15,GFRCODE-GFCBPTR(,R1)           Save Parse RC
 LA    R15,GFPARSE                        Indicate Parse error
 STH   R15,GFCALLID-GFCBPTR(R1)           Save into parm list
 L     R15,&WA+DA#TSOSD_CPPL-DA#TSOSD     Get Address of the CPPL
 ST    R15,GFCPPLP-GFCBPTR(R1)            Save into parm list
*
 ST    R1,&WA+DA#TSOSD_RECOUT-DA#TSOSD
 LINK  EP=IKJEFF19,MF=(E,&WA+DA#TSOSD_RECOUT-DA#TSOSD)
DA#TSOS_PARSEE_I&SYSNDX EQU *
 OI    &WA+DA#TSOSD_F1-DA#TSOSD,$DA#TSOSD_F1_PARSEE
 B     &ERRET
DA#TSOS_PARSEX_I&SYSNDX EQU *
.IPARSEX ANOP  ,
 MEXIT ,
.**********************************************************************
.***                                                                ***
.**      Initialize Message for Putline                              **
.***                                                                ***
.**********************************************************************
.INITMSG ANOP ,
*
** Initialize message for TSO putline processing
** Output: R15 will point to record
*
 DA#Z01 &SYSLIST(0)               Generate Label (if any)
 LA   R1,&WA
 LA   R15,DA#TSOSD_RECOUT-DA#TSOSD(R1)
 MVI  0(R15),C' '
 MVC  1(L'DA#TSOSD_RECOUT-1,R15),0(R15)
 DA#Z05 &RET
 SPACE 3
 MEXIT ,
.**********************************************************************
.***                                                                ***
.**      Print Message                                               **
.***                                                                ***
.**********************************************************************
.PRTMSG  ANOP ,
 DA#Z01 &SYSLIST(0)                       Generate Label (if any)
 LA    R1,&WA
 XC    DA#TSOSD_PLECB-DA#TSOSD(4,R1),DA#TSOSD_PLECB-DA#TSOSD(R1)
 AIF   ('&MSG' EQ '').PMSING
.** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.** Insert mode
.** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 LA    R14,DA#TSOSD_PLNUM-DA#TSOSD(R1)    Locate Output Line Desc.
 LCLA  &MLC,&MLO                          .Declare variables
&MLC   SETA  1                            .Initialize to one
&MLO   SETA  4                            .Initialize offset
.MPL   ANOP  ,                            .Loop start
 AIF   ('&MSG(&MLC)'(1,1) EQ '(').MPR     .Register Format?
 LA    R15,&MSG(&MLC)                     Locate parameter
 ST    R15,&MLO.(R14)                     Save it into parm list
 AGO   .MPRX
.MPR   ANOP ,
 ST    &MSG(&MLC,1).,&MLO.(R14)           Save location into parm list
.MPRX  ANOP ,
 AIF   (&MLC EQ 32).MOVER
&MLC   SETA  &MLC+1                       .Locate next one
 AIF   ('&MSG(&MLC)' EQ '').MPE           .Is there another one?
&MLO   SETA  &MLO+4                       .Locate next one
 AGO   .MPL
.MOVER ANOP ,
 MNOTE 4,'RTSO-20W Overflow: Only first 32 inserts used'
.MPE   ANOP  ,                            .Exit from PARAM= processing
&MLC   SETA  &MLC-1                       .Decrement by 1
 LA    R15,&MLC                           Get number of messages
 ST    R15,0(R14)                         Save number of messages
 AGO   .PMCOM
.** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.** Single mode
.** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.PMSING  ANOP  ,
* Input: R15 must point at last byte in the message (+1)
 LA    R14,DA#TSOSD_RECHEAD-DA#TSOSD(R1) Locate beginning
 SR    R15,R14                            Length = End - start
 STH   R15,DA#TSOSD_RECHEAD-DA#TSOSD(R1) Save length
.** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.** Common Code (no cure for it)
.** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.PMCOM   ANOP  ,
 LA    R1,DA#TSOSD_IOPL-DA#TSOSD(R1)      Locate the IOPL
 MNOTE ' PUTLINE MF=(E,(1)) '
 PUTLINE MF=(E,(1))
 DA#Z02 &EPUTL                            .Do error routine
 DA#Z05 &RET
 SPACE 3
 MEXIT ,
.**********************************************************************
.***                                                                ***
.**      Terminate                                                   **
.***                                                                ***
.**********************************************************************
.TERM    ANOP ,
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
** CPPL termination section
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 LM    R0,R1,&WA+DA#TSOSD_FCPPLVS-DA#TSOSD
 LTR   R0,R0                      Any length?
 BZ    DA#TSOS_CPPLX_T&SYSNDX     None, move on
 MNOTE '         FREEMAIN R,LV=(0),A=(1)'
 FREEMAIN R,LV=(0),A=(1)          Obtain storage
DA#TSOS_CPPLX_T&SYSNDX EQU *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
** PUTLINE termination section
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
DA#TSOS_PUTLX_T&SYSNDX EQU *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
** PARSE termination section
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 TM    &WA+DA#TSOSD_F1-DA#TSOSD,$DA#TSOSD_F1_PARSEE
 BO    DA#TSOS_PARSEX_T&SYSNDX
 ICM   R1,B'1111',&WA+DA#TSOSD_ANS-DA#TSOSD
 BZ    DA#TSOS_PARSEX_T&SYSNDX             None, leave
 MNOTE ' IKJRLSA (1)'
 IKJRLSA (1)                               Free storage
DA#TSOS_PARSEX_T&SYSNDX EQU *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
** Free The Screen Buffer Area
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 ICM   R1,B'1111',&WA+DA#TSOSD_SCRA-DA#TSOSD
 BZ    B&SYSNDX                        No Address, move on
 L     R0,&WA+DA#TSOSD_SCRL-DA#TSOSD Get length
 FREEMAIN R,LV=(0),A=(1)               Release the storage
B&SYSNDX EQU   *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
** Full Screen Terminations
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 TM    &WA+DA#TSOSD_F1-DA#TSOSD,$DA#TSOSD_F1_FS
 BNO   FS&SYSNDX
 STLINENO LINE=1,MODE=ON          Clear screen before exiting
 STFSMODE OFF                     Exit Full screen mode
 STTMPMD OFF                      Return to display term mgr
FS&SYSNDX EQU  *
 TM    &WA+DA#TSOSD_F1-DA#TSOSD,$DA#TSOSD_F1_STAX
 BNO   FSS&SYSNDX
 STAX  ,                          Turn off Attention exit
FSS&SYSNDX EQU *
 MEXIT ,
.**********************************************************************
.***                                                                ***
.**   Map tso TSO services work area                                 **
.***                                                                ***
.**********************************************************************
.DSECT   ANOP  ,
*
** Main DSECT for TSO services
*
DA#TSOSD         DSECT ,
DA#TSOSD_FCPPLVS DS    2F                 Fake CPPL Length, Address
DA#TSOSD_CPPL    EQU   *-4                Address of CPPL
DA#TSOSD_SCRA    DS    F                  Screen Buffer Address
DA#TSOSD_SCRL    DS    F                  Screen Buffer Length
DA#TSOSD_SCRROW DS     F                  Screen Rows
DA#TSOSD_SCRCOL DS     F                  Screen Columns
*
DA#TSOSD_PRMSIZE DS    XL2                Screen primary Screen
DA#TSOSD_ALTSIZE DS    XL2                Screen Alternate screen
DA#TSOSD_ATTRIB     EQU   *     0XL4      Terminal Attribute
DA#TSOSD_AFLAG1     DS    B'00000000'     ..Flag 1
DA#TSOSD_AFLAG2     DS    B'00000000'     ..Flag 2
$DA#TSOSD_AF2DBCS   EQU   B'10000000'       ..DBCS?
$DA#TSOSD_AF2AENG   EQU   B'00000001'       ..American English?
$DA#TSOSD_AF2KATAK EQU    B'00010001'       ..Katakana?
DA#TSOSD_AFLAG3     DS    B'00000000'     ..Flag3
$DA#TSOSD_AF3ASCII7 EQU   B'00000000'       ..ASCII-7 device code
$DA#TSOSD_AF3ASCII8 EQU   B'00000100'       ..ASCII-8 device code
DA#TSOSD_AFLAG4     DS    B'00000000'     ..Flag4
$DA#TSOSD_AF4ASCII EQU    B'00000010'       ..ASCII terminal?
$DA#TSOSD_AF4QUERY EQU    B'00000001'       ..Queriable terminal?
*
DA#TSOSD_STAXR13 DS    F                  Stax R13
DA#TSOSD_PPL     DS    XL(#PPL)           Mapped by IKJPPL
DA#TSOSD_PARSECB DS    F                  Event Control Block
DA#TSOSD_ANS     DS    F                  ANS
DA#TSOSD_PCL     DS    F                  Parameter Control List
DA#TSOSD_IOPL    DS    XL(#IOPL)          PUTLINE IOPL
 MNOTE 'DA#TSOSD_PTPB    PUTLINE MF=L             PUTLINE PTPB'
DA#TSOSD_PTPB    PUTLINE MF=L             PUTLINE PTPB
DA#TSOSD_PLECB   DS    F                  PUTLINE Event Control Block
DA#TSOSD_PLNUM   DS    F'1'               PUTLINE number of messages
DA#TSOSD_PLADR   DS    A                  PUTLINE message address
DA#TSOSD_RECHEAD DS    F'0'               PUTLINE message heading
DA#TSOSD_RECOUT DS     CL256              PUTLINE message area
DA#TSOSD_F1         DS  B'00000000'       Flag 1
$DA#TSOSD_F1_STAX   EQU B'10000000'       ..STAX performed?
$DA#TSOSD_F1_FS     EQU B'01000000'       ..Full Screen Mode?
$DA#TSOSD_F1_PARSEE EQU B'00100000'       ..Parse error?
                 DS    0F
DA#TSOSDL        EQU   *-DA#TSOSD         Length of DA#TSOSD
*
** "Fake" CPPL getmained area
*
DA#TSOSF         DSECT ,
DA#TSOSF_CPPL    DS    XL(#CPPL)          Command Processor Parm List
*                                         Command buffer
DA#TSOSF_CBUF_H  DS    CL4                ..Header
DA#TSOSF_CBUF_B  DS    CL8                ..Body
DA#TSOSF_CBUFL   EQU   *-DA#TSOSF_CBUF_H  Length of command buffer
DA#TSOSFL        EQU   *-DA#TSOSF
 MEND ,
./ ADD NAME=DA#Z00   0100-01266-01266-1821-00038-00038-00000-DAVE
         MACRO ,
         DA#Z00 &VAR,                     Variable to process          @
               &REG=1,                    Register to use              @
               &CLEAR=NO,                 Clear if not found?          @
               &CODE=LA,                  ASM to locate field          @
               &MF=E
.**********************************************************************
.***                                                                ***
.** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  **
.** DA#Zxx macros are used for easy macro coding                     **
.** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  **
.**                                                                  **
.**  Locate operand regardless of type, for example:                 **
.**                                                                  **
.**  DA#Z00 (2)                                                      **
.** +LR   R1,R2                                                      **
.**                                                                  **
.**  DA#Z00 LABEL                                                    **
.** +LA   R1,LABEL                                                   **
.***                                                                ***
.**********************************************************************
 AIF   ('&VAR' EQ '').EVAR                .Have a variable?
 AIF   ('&VAR'(1,1) EQ '(').CLRPLR        .Register format?
 &CODE &REG,&VAR                          Locate field
 AGO   .CLRPLX                            .Leave
.CLRPLR ANOP ,                            .Register format found
 AIF   ('&VAR(1)' EQ '&REG').CLRPLX       .Registers match?
 AIF   (&VAR(1) EQ &REG).CLRPLX           .Registers match?
 LR    &REG,&VAR(1)                       Locate field
.CLRPLX ANOP ,
 MEXIT ,
.EVAR ANOP ,
 AIF  ('&CLEAR' EQ 'YES').CLRIT
 MNOTE 8,'DA#Z00-01E Missing required operand'
 MEXIT ,
.CLRIT ANOP ,
 SLR   &REG,&REG                          Operand missing, clear reg.
 MEND
./ ADD NAME=DA#Z01   0100-01266-01266-1821-00014-00014-00000-DAVE
 MACRO
 DA#Z01 &LABEL
.**********************************************************************
.***                                                                ***
.** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  **
.** DA#Zxx macros are used for easy macro coding                     **
.** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  **
.**                                                                  **
.**    GENERATE A LABEL IF THE &LABEL OPERAND IS USED                **
.***                                                                ***
.**********************************************************************
 AIF   ('&LABEL' EQ '').MEND
&LABEL DS 0H
.MEND MEND
./ ADD NAME=DA#Z02   0100-01266-01266-1821-00017-00017-00000-DAVE
 MACRO
 DA#Z02 &LABEL,&TEST=YES,&CODE=BNZ
.**********************************************************************
.***                                                                ***
.** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  **
.** DA#Zxx macros are used for easy macro coding                     **
.** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  **
.**                                                                  **
.**     GENERATE TEST AND BRANCH IF THE &LABEL VALUE IS SPECIFIED    **
.***                                                                ***
.**********************************************************************
 AIF   ('&LABEL' EQ '').MEND
 AIF   ('&TEST' EQ 'NO').TESTX
 LTR   R15,R15
.TESTX ANOP ,
 &CODE &LABEL
.MEND MEND
./ ADD NAME=DA#Z04   0100-01266-01266-1821-00039-00039-00000-DAVE
 MACRO
 DA#Z04 &PARAM,&MF=
.**********************************************************************
.***                                                                ***
.** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  **
.** DA#Zxx macros are used for easy macro coding                     **
.** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  **
.**                                                                  **
.** Generate a parameter list (like the CALL macro)                  **
.***                                                                ***
.**********************************************************************
 AIF   ('&PARAM' EQ '').CPX
 DA#Z00 &MF(2)                            .Locate variable
 LCLA  &CPLC,&CPLO                        .Declare variables
&CPLC  SETA  1                            .Initialize to one
&CPLO  SETA  0                            .Initialize to one
.CPL   ANOP  ,                            .Loop start
 AIF   ('&PARAM(&CPLC)'(1,1) EQ '(').CPR  .Register Format?
 LA    R15,&PARAM(&CPLC)                  Locate parameter
 ST    R15,&CPLO.(R1)                     Save it into parm list
 AGO   .CPRX
.CPR   ANOP ,
 ST    &PARAM(&CPLC,1).,&CPLO.(R1)        Save location into parm list
.CPRX  ANOP ,
&CPLC  SETA  &CPLC+1                      .Locate next one
 AIF   ('&PARAM(&CPLC)' EQ '').CPE        .Is there another one?
&CPLO  SETA  &CPLO+4                      .Locate next one
 AGO   .CPL
.CPE   ANOP  ,                            .Exit from PARAM= processing
 OI    &CPLO.(R1),B'10000000'             Indicate last parm entry
.CPX   ANOP  ,                            .Exit from PARAM= processing
.*
.** Handle MF=(G,?,label)
.*
 AIF   ('&MF(1)' NE 'G').GENX
 AIF   ('&MF(3)' EQ '').GENX
&MF(3). EQU &CPLO+4
.GENX ANOP ,
 MEND ,
./ ADD NAME=DA#Z05   0100-01266-01266-1821-00015-00015-00000-DAVE
 MACRO
 DA#Z05 &RET
.**********************************************************************
.***                                                                ***
.** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  **
.** DA#Zxx macros are used for easy macro coding                     **
.** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  **
.**                                                                  **
.**  GENERATE A BRANCH IF THE &RET OPERAND IS SPECIFED               **
.***                                                                ***
.**********************************************************************
 AIF ('&RET' EQ '').MEND
 BSM   0,&RET
.MEND ANOP ,
 MEND
./ ADD NAME=I$EREP   0100-01266-01266-1821-00751-00751-00000-DAVE
>< ADD NAME=LRS$EIN
)attr
 /********************************************************************/
 /* Name: LRS$EIN                                                    */
 /* Author: David Alcock                                             */
 /* Application: Software LOGREC Application                         */
 /* Purpose: Display information about LOGREC table entry            */
 /********************************************************************/
 $ type(text)   intens(high) color(yellow) caps(off)
 ` type(output) intens(low)  color(turq)   caps(off)
 ~ type(output) intens(low)  color(green)  caps(off)
 Â¢ type(text)   intens(low)  color(blue)   caps(off)
 Â¬ type(text)   intens(low)  color(blue)   caps(off)
)body expand(!!) width(&zscreenw)
%!-! LOGREC Software Event Information !-!
%Command ===>_ZCMD                                         ! !%Scroll ===>_AMT +
+
Â¢Dump taken:
$Date:    `LRSDATEG   `LRSDAY    $Julian:    `LRSDATEJ
$Time:    `LRSTIME

Â¢Detail:
$Type:    `LRSTYPE               $Component: `LRSCOMP
$JobName: `LRSJOBN               $CSECT:     `LRSCSCT
$CPU:     `LRSCPU                $Reason:    `LRSREAS
                                 $LOGREC Seq:`LRSSEQN

`LRSDESC




Â¬Hit the%ENTERÂ¬key to return to LOGREC event table
)init
 .HELP = LRS$T1
 &AMT = PAGE
)end
>< ADD NAME=LRS$ETDL
)attr
 /********************************************************************/
 /* Name: LRS$ETDL                                                   */
 /* Author: David Alcock                                             */
 /* Application: Software LOGREC Application                         */
 /* Purpose: Table display for long (more than one line) models      */
 /*          Doesn't have the scan stuff - normal display            */
 /********************************************************************/
 ` type(output) intens(low)  color(turq)   caps(off)
 $ type(output) intens(high) color(yellow) caps(off)
 ~ type(output) intens(low)  color(green)  caps(off) just(asis)
 # type(output) intens(low)  color(blue)   caps(off) just(asis)
 Â¬ type(output) intens(low)  color(green)  caps(off) just(asis)
)body expand(!!) width(&zscreenw)
%!-! LOGREC Software Events !-!
%Command ===>_ZCMD                                         ! !%Scroll ===>_AMT +
+
#LRSRANGE
+
Â¬LRST1                                                                       ! !
Â¬LRST2                                                                       ! !
Â¬LRST3                                                                       ! !
)model
&LRSMOD1
&LRSMOD2
)init
 .HELP = LRS$T1
 &AMT = PAGE
)end
>< ADD NAME=LRS$ETDS
)attr
 /********************************************************************/
 /* Name: LRS$ETDS                                                   */
 /* Author: David Alcock                                             */
 /* Application: Software LOGREC Application                         */
 /* Purpose: Table display for LOGREC entries (only 1 model line)    */
 /*          Doesn't have the scan stuff - normal display            */
 /********************************************************************/
 ` type(output) intens(low)  color(turq)   caps(off)
 $ type(output) intens(high) color(yellow) caps(off)
 ~ type(output) intens(low)  color(green)  caps(off) just(asis)
 # type(output) intens(low)  color(blue)   caps(off) just(asis)
 Â¬ type(output) intens(low)  color(green)  caps(off) just(asis)
)body expand(!!) width(&zscreenw)
%!-! LOGREC Software Events !-!
%Command ===>_ZCMD                                         ! !%Scroll ===>_AMT +
+
#LRSRANGE
+
Â¬LRST1                                                                       ! !
Â¬LRST2                                                                       ! !
)model
&LRSMOD1
)init
 .HELP = LRS$T1
 &AMT = PAGE
)end
>< ADD NAME=LRS$ETSL
)attr
 /********************************************************************/
 /* Name: LRS$ETSL                                                   */
 /* Author: David Alcock                                             */
 /* Application: Software LOGREC Application                         */
 /* Purpose: Table display for long (more than one line) models      */
 /*          This has the scan stuff - keep in sync with LRS$ETDL    */
 /********************************************************************/
 ` type(output) intens(low)  color(turq)   caps(off)
 $ type(output) intens(high) color(yellow) caps(off)
 ~ type(output) intens(low)  color(green)  caps(off) just(asis)
 # type(output) intens(low)  color(blue)   caps(off) just(asis)
 Â¬ type(output) intens(low)  color(green)  caps(off) just(asis)
)body expand(!!) width(&zscreenw)
%!-! LOGREC Software Events !-!
%Command ===>_ZCMD                                         ! !%Scroll ===>_AMT +
+
#LRSRANGE
+
Â¬LRST1                                                                       ! !
Â¬LRST2                                                                       ! !
Â¬LRST3                                                                       ! !
)model rows(scan)
&LRSMOD1
&LRSMOD2
)init
 .HELP = LRS$T1
 &AMT = PAGE
)end
>< ADD NAME=LRS$ETSS
)attr
 /********************************************************************/
 /* Name: LRS$ETSS                                                   */
 /* Author: David Alcock                                             */
 /* Application: Software LOGREC Application                         */
 /* Purpose: Table display for LOGREC entries (only 1 model line)    */
 /*          This has the scan stuff - keep in sync with LRS$ETDS    */
 /********************************************************************/
 ` type(output) intens(low)  color(turq)   caps(off)
 $ type(output) intens(high) color(yellow) caps(off)
 ~ type(output) intens(low)  color(green)  caps(off) just(asis)
 # type(output) intens(low)  color(blue)   caps(off) just(asis)
 Â¬ type(output) intens(low)  color(green)  caps(off) just(asis)
)body expand(!!) width(&zscreenw)
%!-! LOGREC Software Events !-!
%Command ===>_ZCMD                                         ! !%Scroll ===>_AMT +
+
#LRSRANGE
+
Â¬LRST1                                                                       ! !
Â¬LRST2                                                                       ! !
)model rows(scan)
&LRSMOD1
)init
 .HELP = LRS$T1
 &AMT = PAGE
)end
>< ADD NAME=LRS$LOGO
)attr
 /********************************************************************/
 /* Name: LRS$LOGO                                                   */
 /* Author: David Alcock                                             */
 /* Application: Software LOGREC Application                         */
 /* Purpose: Display Logo while we are reading LOGREC file           */
 /********************************************************************/
 # type(output) intens(high) color(yellow) caps(off)
 @ type(output) intens(low)  color(green)  caps(off)
 | type(text)   intens(low)  color(red)
 ~ type(text)   intens(low)  color(turq)   hilite(blink)
 ` type(text)   intens(high) color(green)
 Â¢ type(text)   intens(high) color(blue)
 Â¬ type(text)   intens(low)  color(turq)
)body expand(!!) width(&zscreenw)
%!-! LOGREC Software Application#Z    %!-!
%
! !   `LL         Â¢OOOOOOOO  `GGGGGGGG Â¢RRRRRRRRR `EEEEEEEEEE Â¢CCCCCCCC      ! !
! !   `LLÂ¬\      Â¢OOOOOOOOOO`GGGGGGGGGGÂ¢RRRRRRRRRR`EEEEEEEEEEÂ¢CCCCCCCCCC     ! !
! !   `LLÂ¬\      Â¢OOÂ¬\   Â¢OO`GGÂ¬\   `GGÂ¢RRÂ¬\   Â¢RR`EEÂ¬\      Â¢CCÂ¬\   Â¢CCÂ¬\   ! !
! !   `LLÂ¬\      Â¢OOÂ¬\   Â¢OO`GGÂ¬\      Â¢RRÂ¬\   Â¢RR`EEÂ¬\      Â¢CCÂ¬\           ! !
! !   `LLÂ¬\      Â¢OOÂ¬\   Â¢OO`GGÂ¬\      Â¢RRRRRRRRRR`EEEEEEÂ¬   Â¢CCÂ¬\           ! !
! !   `LLÂ¬\      Â¢OOÂ¬\   Â¢OO`GGÂ¬\`GGGGGÂ¢RRRRRRRRR `EEEEEEÂ¬\  Â¢CCÂ¬\           ! !
! !   `LLÂ¬\      Â¢OOÂ¬\   Â¢OO`GGÂ¬\`GGGGGÂ¢RR Â¢RRÂ¬\  `EEÂ¬\\\\   Â¢CCÂ¬\           ! !
! !   `LLÂ¬\      Â¢OOÂ¬\   Â¢OO`GGÂ¬\   `GGÂ¢RRÂ¬\ Â¢RRÂ¬\`EEÂ¬\      Â¢CCÂ¬\   Â¢CCÂ¬    ! !
! !   `LLLLLLLLLLÂ¢OOOOOOOOOO`GGGGGGGGGGÂ¢RRÂ¬\  Â¢RR `EEEEEEEEEEÂ¢CCCCCCCCCCÂ¬\   ! !
! !   `LLLLLLLLLLÂ¢ OOOOOOOOÂ¬\`GGGGGGGG Â¢RRÂ¬\   Â¢RR`EEEEEEEEEE Â¢CCCCCCCCÂ¬\    ! !
! !   Â¬ \\\\\\\\\   \\\\\\\\   \\\\\\\\  \\      \\ \\\\\\\\\\  \\\\\\\\     ! !
%
! ! |Note:#STATUS                                                            ! !
! !       ~Please be patient: Work in process_OK                             ! !
%
@INFO1
@INFO2
@INFO3
@INFO4

)init
.ZVARS = 'LRSVER'
)proc
)end
>< ADD NAME=LRS$ONLY
)attr
 /********************************************************************/
 /* Name: LRS$ONLY                                                   */
 /* Author: David Alcock                                             */
 /* Application: Software LOGREC Application                         */
 /* Purpose: Allow the user to be prompted when he neglects to enter */
 /*          an operand on the ONLY command.                         */
 /********************************************************************/
 ` type(text) intens(high) color(yellow)
 ~ type(text) intens(low)  color(turq)
 # type(text) intens(low)  color(green)
)body
%----------------------------`ONLY+syntax error%--------------------------------
%Command%===>_ZCMD
+
+You neglected to specify a positional parameter for the`ONLY+command. Please
+specify a field and value to limit the table display.
+
~Field%===>_FIELD   +
~Value%===>_VALUE

+The~Field+area may be one of the following types:
`DATE TIME JULIAN RECTYPE JOBNAME REASON MODULE CSECT CPU SEQNO DESC
+
+The~Value+area must not be blank
+
+
+If you wish to show all records, change the~Field+to OFF
+
+
+
+
+
+
+Enter the`ONLY+operands or hit the%END+key to terminate`ONLY+request.
)init
 &field = ''
 &value = ''
)proc
 ver (&field,list,DATE,TIME,JULIAN,RECTYPE,JOBNAME,REASON,MODULE,CSECT,CPU,
                  SEQNO,DESC,DESCRIPTION,OFF)
 if (&field Â¬= 'OFF')
    ver (&value,nonblank)
)end
>< ADD NAME=LRS$STD
)attr
 /********************************************************************/
 /* Name: LRS$STD                                                    */
 /* Author: David Alcock                                             */
 /* Application: Software LOGREC Application                         */
 /* Purpose: Table display for summary of LOGREC entries             */
 /********************************************************************/
 Â¬ type(output) intens(low)  color(green)  caps(off)
 ~ type(output) intens(high) color(yellow) caps(off)
 ` type(output) intens(low)  color(turq)   caps(off)
 # type(output) intens(low)  color(blue)   caps(off) just(asis)
)body expand(!!) width(&zscreenw)
%!-! LOGREC Software Event Summary !-!
%Command ===>_ZCMD                                         ! !%Scroll ===>_AMT +
+
#LRSRANGE
+
Â¬SUMT1
Â¬SUMT2
)model
&SUMMOD1
)init
 .HELP = LRS$TS1
 &AMT = PAGE
)end
>< ADD NAME=LRS$STTD
)attr
 /********************************************************************/
 /* Name: LRS$ETDS                                                   */
 /* Author: David Alcock                                             */
 /* Application: Software LOGREC Application                         */
 /* Purpose: Table display for LOGREC entries (only 1 model line)    */
 /********************************************************************/
 ` type(output) intens(low)  color(turq)   caps(off) just(asis)
 $ type(output) intens(high) color(yellow) caps(off)
 Â¬ type(output) intens(low)  color(green)  caps(off) just(asis)
 # type(output) intens(low)  color(blue)   caps(off) just(asis)
)body expand(!!) width(&zscreenw)
%!-! LOGREC Software Event Statistics !-!
%Command ===>_ZCMD                                         ! !%Scroll ===>_AMT +
+
#LRSRANGE
+
)model
Â¬LINE                                                                        ! !
)init
 .HELP = LRS$TL1
 &AMT = PAGE
)end
>< ADD NAME=LRS$TL1
)attr
 /********************************************************************/
 /* Name: LRS$TL1                                                    */
 /* Author: David Alcock                                             */
 /* Application: Software LOGREC Application                         */
 /* Purpose: Tutorial page 1 for statistics table display            */
 /********************************************************************/
 # type(text) intens(high) color(yellow)
 Â¢ type(text) intens(high) color(green)
 | type(text) intens(high) color(pink)
 @ type(text) intens(high) color(green)
 ` type(text) intens(high) color(turq)
 ~ type(text) intens(low)  color(turq)
)BODY EXPAND(!!)
|TUTORIAL !-!  Softlog Statistics !-!|TUTORIAL
%Command ===>_ZCMD
+
+You are viewing a statistics of the LOGREC table entries by CPU.  This is
+a nice overview of record types in a matrix.  In addition, if there are any
+records in the LOGREC database that we do not handle, they will be listed
+along with any error messages under the total line.
+
+
~The following commands can be entered on the primary command line.
+
@REPORT
+
+This command is generates a report consisting of the statistics table into the
+ISPF list file.
+
+
~There are no line commands for the statistics table display
+
+
+
+
+Hit the%END+key to complete this tutorial and return to the statistics table.
)init
 &ZCMD = &Z
 &CONT = LRS$TS2
)end
>< ADD NAME=LRS$TS1
)attr
 /********************************************************************/
 /* Name: LRS$TS1                                                    */
 /* Author: David Alcock                                             */
 /* Application: Software LOGREC Application                         */
 /* Purpose: Tutorial page 1 for summary table display               */
 /********************************************************************/
 # type(text) intens(high) color(yellow)
 Â¢ type(text) intens(high) color(green)
 | type(text) intens(high) color(pink)
 @ type(text) intens(high) color(green)
 ` type(text) intens(high) color(turq)
 ~ type(text) intens(low)  color(turq)
)BODY EXPAND(!!)
|TUTORIAL !-!  Softlog Summary !-!|TUTORIAL
%Command ===>_ZCMD
+
+You are viewing a summary of the LOGREC table entries.  Each entry in the
+summary table is a match by`Module CSECT+and`Reason.+Initially the table is
+sort by descending count.
+
+
~The following commands can be entered on the primary command line.
+
@L#value+
+
+This command is used to locate a value in the current sort field which is the
+highlighted field in the table display.  When the date is the sort field,
+only the gregorian date (like format &ZDATE) is considered.
+
@REPORT
+
+This command is generates a report consisting of the summary table into the
+ISPF list file.
+
+
+Hit the%ENTER+key to continue with this tutorial
)init
 &ZCMD = &Z
 &CONT = LRS$TS2
)end
>< ADD NAME=LRS$TS2
)attr
 /********************************************************************/
 /* Name: LRS$TS2                                                    */
 /* Author: David Alcock                                             */
 /* Application: Software LOGREC Application                         */
 /* Purpose: Tutorial page 2 for summary table display               */
 /********************************************************************/
 # type(text) intens(high) color(yellow)
 Â¢ type(text) intens(high) color(green)
 | type(text) intens(high) color(pink)
 @ type(text) intens(high) color(green)
 ` type(text) intens(high) color(turq)
 ~ type(text) intens(low)  color(turq)
)BODY EXPAND(!!)
|TUTORIAL !-!  Softlog Summary (cont) !-!|TUTORIAL
%Command ===>_ZCMD
+
@SORT#field
+
+This command is sorts the tables by a field.  Use the column headings for
+field names.  Changing the sort field allows locating within that field.
+
@STATS+
+
+This command is shows statistics on the entries shown as a matrix by CPU
+and LOGREC entry type.
+
~There are no line commands for the summary table.
+
+
+
+
+
+
+
+
+Hit the%END+key to return to the summary table
)init
 &ZCMD = &Z
)end
>< ADD NAME=LRS$T1
)attr
 /********************************************************************/
 /* Name: LRS$T1                                                     */
 /* Author: David Alcock                                             */
 /* Application: Software LOGREC Application                         */
 /* Purpose: Tutorial page 1                                         */
 /********************************************************************/
 ` type(text) intens(high) color(yellow)
 ~ type(text) intens(low)  color(turq)
 # type(text) intens(low)  color(green)
)body
%TUTORIAL --------- SOFTLOG - LOGREC Software Event History ----------- TUTORIAL
%Command ===>_ZCMD
+
SOFTLOG provides a facility for examining a data base of system software
failures. The data base consists of software, IPL, and EOD records extracted
from`SYS1.LOGREC+ which has a history of the last 31 days.

Each software record documents a system ABEND and contains the`SDWA+(System
Diagnostic Work Area). Note that records are often created without a
corresponding system dump. A flag in the`SDWA+indicates whether or not a system
dump was requested.

The display contains one line for each record in the data base.  The entries are
sorted by date and time.  This makes it easy to obtain a quick overview of all
problems which have occurred over a period of time.

The%scroll+keys may be used to position the display as in Browse.  The initial
display will be positioned to the current date or at the top of the table if
the current date is not in the database.

See the`EREP+manual for more information on`LOGREC.

Hit the%ENTER+key to continue with the Tutorial
)init
 &ZCMD = &Z
 &CONT = LRS$T2
)end
>< ADD NAME=LRS$T2
)attr
 /********************************************************************/
 /* Name: LRS$T2                                                     */
 /* Author: David Alcock                                             */
 /* Application: Software LOGREC Application                         */
 /* Purpose: Tutorial page 2                                         */
 /********************************************************************/
 # type(text) intens(high) color(yellow)
 Â¢ type(text) intens(high) color(green)
 | type(text) intens(high) color(pink)
 @ type(text) intens(high) color(green)
 ` type(text) intens(high) color(turq)
 ~ type(text) intens(low)  color(turq)
)BODY EXPAND(!!)
|TUTORIAL !-!  Softlog - Primary Commands  !-!|TUTORIAL
%Command ===>_ZCMD
+
~The following commands can be entered on the primary command line.
+
@DSAVERPT+
+
+This command is used to indicate that EREP reports are not to be saved past
+SOFTLOG sessions.  This is the default option.  EREP reports can be saved
+via the@SAVERPT+command.
+
@L#value+
+
+This command is used to locate a value in the current sort field which is the
+highlighted field in the table display.  When the date is the sort field,
+only the gregorian date (like format &ZDATE) is considered.
+
@LONG+
+
+This command is used to change the table display to show all fields available
+by expanding the entry to two lines.  Use the@SHORT+command to change back.
+
+Hit the%ENTER+key to continue with tutorial
)init
 &ZCMD = &Z
 &CONT = LRS$T3
)end
>< ADD NAME=LRS$T3
)attr
 /********************************************************************/
 /* Name: LRS$T3                                                     */
 /* Author: David Alcock                                             */
 /* Application: Software LOGREC Application                         */
 /* Purpose: Tutorial page 3                                         */
 /********************************************************************/
 # type(text) intens(high) color(yellow)
 Â¢ type(text) intens(high) color(green)
 | type(text) intens(high) color(pink)
 @ type(text) intens(high) color(green)
 ` type(text) intens(high) color(turq)
 ~ type(text) intens(low)  color(turq)
)BODY EXPAND(!!)
|TUTORIAL !-!  Softlog - Primary Commands (cont)  !-!|TUTORIAL
%Command ===>_ZCMD
+
@ONLY#field`value
+
+This command allows you to display table entries that have the`value+that
+matches the#field+specified.  For example, if you wanted to display only those
+table entries that are record type`ABEND+use:@ONLY#RECTYPE`ABEND
+
+The@ONLY+command allows you to stack limiting pairs. For example, you
+could limit the table display entries to job name`TSO,+record type`ABEND+and
+limited to#CPU`W+use:@ONLY#JOBNAME`TSO#RECTYPE`ABEND#CPU`W
+
+Use the table column headings to get the valid#field+names.
+
+
@ONLY#OFF
+
+This command turns table display limiting by fields. After this command is
+entered, all table rows will be displayed.
+
+
+Hit the%ENTER+key to continue with tutorial
)init
 &ZCMD = &Z
 &CONT = LRS$T4
)end
>< ADD NAME=LRS$T4
)attr
 /********************************************************************/
 /* Name: LRS$T4                                                     */
 /* Author: David Alcock                                             */
 /* Application: Software LOGREC Application                         */
 /* Purpose: Tutorial page 4                                         */
 /********************************************************************/
 # type(text) intens(high) color(yellow)
 Â¢ type(text) intens(high) color(green)
 | type(text) intens(high) color(pink)
 @ type(text) intens(high) color(green)
 ` type(text) intens(high) color(turq)
 ~ type(text) intens(low)  color(turq)
)BODY EXPAND(!!)
|TUTORIAL !-!  Softlog - Primary Commands (cont)  !-!|TUTORIAL
%Command ===>_ZCMD
+
@REPORT
+
+Generate a report consisting of the table display to the ISPF LIST dataset.
+The "LIST" ISPF command can then be used to retrieve the output which can
+be sent to a printer or a dataset.  Don't confuse this with the EREP report
+function. This is a list of the table entries only, not detailed information
+on the individual entry.
+
@SAVERPT+
+
+This command is used to indicate that EREP reports are to be saved past
+SOFTLOG sessions.  EREP reports can be set to be deleted after the SOFTLOG
+session via the@SAVERPT+command.
+
@SORT#field
+
+This command is sorts the tables by a field.  Use the column headings for
+field names.  Changing the sort field allows locating within that field.
+
+Hit the%ENTER+key to continue with tutorial
)init
 &ZCMD = &Z
 &CONT = LRS$T5
)end
>< ADD NAME=LRS$T5
)attr
 /********************************************************************/
 /* Name: LRS$T5                                                     */
 /* Author: David Alcock                                             */
 /* Application: Software LOGREC Application                         */
 /* Purpose: Tutorial page 5                                         */
 /********************************************************************/
 # type(text) intens(high) color(yellow)
 Â¢ type(text) intens(high) color(green)
 | type(text) intens(high) color(pink)
 @ type(text) intens(high) color(green)
 ` type(text) intens(high) color(turq)
 ~ type(text) intens(low)  color(turq)
)BODY EXPAND(!!)
|TUTORIAL !-!  Softlog - Primary Commands (cont)  !-!|TUTORIAL
%Command ===>_ZCMD
+
@SHORT
+
+Put the ISPF table of entries into a short (one-line) display. The@LONG+
+command can be used to change the table display to a two line display.
+
@STATS+
+
+This command is shows statistics on the entries shown as a matrix by CPU
+and LOGREC entry type.
+
@SUM+or@SUMM
+
+Show a summary table display of the entries.  This table is by entries which
+have the same module/component, CSECT and Reason. The count of hits is a
+valuable tool to help diagnose how serious a problem you have.
+
+
+
+
+Hit the%ENTER+key to continue with tutorial (Line commands are next)
)init
 &ZCMD = &Z
 &CONT = LRS$T6
)end
>< ADD NAME=LRS$T6
)attr
 /********************************************************************/
 /* Name: LRS$T6                                                     */
 /* Author: David Alcock                                             */
 /* Application: Software LOGREC Application                         */
 /* Purpose: Tutorial page 6                                         */
 /********************************************************************/
 # type(text) intens(high) color(yellow)
 Â¢ type(text) intens(high) color(green)
 | type(text) intens(high) color(pink)
 @ type(text) intens(high) color(green)
 ` type(text) intens(high) color(turq)
 ~ type(text) intens(low)  color(turq)
 Â¬ type(text) intens(high) color(red)
)BODY EXPAND(!!)
|TUTORIAL !-!  Softlog - Line Commands  !-!|TUTORIAL
%Command ===>_ZCMD
+
~The following line commands can be used on the main table display:
+
@S+
+
+Select the entry for processing by EREP into a report. The may be more entries
+other than the one selected if multiple entries occur in the same minute. You
+will be placed into ISPF browse on the EREP report. When you are browsing the
+dataset, you can use the following commands:
     #BPRINT+- Invoke the Rockwell RPRINT function for the browse dataset.
     #BRCOPY+- Copy the browse dataset    #BRP   +- Print the browse dataset
+
@T+
+
+Browse the EREP "TOURIST" file for control statment information and errors.
+
@?+
+
+Show all table entry fields available on a single screen
+
+Hit the%ENTER+key to continue with this tutorial (field descriptions are next)
)init
 &ZCMD = &Z
 &CONT = LRS$T7
)end
>< ADD NAME=LRS$T7
)attr
 /********************************************************************/
 /* Name: LRS$T7                                                     */
 /* Author: David Alcock                                             */
 /* Application: Software LOGREC Application                         */
 /* Purpose: Tutorial page 7                                         */
 /********************************************************************/
 # type(text) intens(high) color(yellow)
 Â¢ type(text) intens(high) color(green)
 | type(text) intens(high) color(pink)
 @ type(text) intens(high) color(green)
 ` type(text) intens(high) color(turq)
 ~ type(text) intens(low)  color(turq)
 Â¬ type(text) intens(high) color(red)
)BODY EXPAND(!!)
|TUTORIAL !-!  Softlog - Field descriptions !-!|TUTORIAL
%Command ===>_ZCMD
+
~The table entries for each LOGREC record have the following fields:
+
@DATE     +The date in gregorian form when the LOGREC record was written
@TIME     +The time when the LOGREC record was written
@JULIAN   +The date in IBM Julian format when the LOGREC record was written
          Â¬Note:+This field is only displayed when in@LONG+display format
@RECTYPE  +The LOGREC record type:
          #ABEND  ~- A system error recovery: an ABEND occurred.
          #EOD    ~- The system was terminated normally under program control
                  ~  or at the request of an operator.
          #IPL    ~- The system has gone thru operating system initialization.
          #LostRec~- The LOGREC dataset was full and there were lost records.
          #ProgInt~- A system error recovery: a Program Interrupt.
          #Symptom~- When a module detects a programming failure, it contructs
                     a symptom record containing a description of the failure.
@JOBNAME  +The jobname that caused the LOGREC Record to be created. This only
          +applies to#ABEND+and#ProgInt+records.
@REASON   +The reason code

+Hit the%ENTER+key to continue with this tutorial
)init
 &ZCMD = &Z
 &CONT = LRS$T8
)end
>< ADD NAME=LRS$T8
)attr
 /********************************************************************/
 /* Name: LRS$T8                                                     */
 /* Author: David Alcock                                             */
 /* Application: Software LOGREC Application                         */
 /* Purpose: Tutorial page 8                                         */
 /********************************************************************/
 # type(text) intens(high) color(yellow)
 Â¢ type(text) intens(high) color(green)
 | type(text) intens(high) color(pink)
 @ type(text) intens(high) color(green)
 ` type(text) intens(high) color(turq)
 ~ type(text) intens(low)  color(turq)
 Â¬ type(text) intens(high) color(red)
)BODY EXPAND(!!)
|TUTORIAL !-!  Softlog - Field descriptions (cont) !-!|TUTORIAL
%Command ===>_ZCMD
+
@MODULE   +The module or component that caused the LOGREC record to be written
@CSECT    +The CSECT that caused the LOGREC record to be written
@CPU      +The CPU name (if available) or serial number where the LOGREC record
          +was written.
@SEQNO    +The software sequence number. This is only for#ABEND+or#ProgInt
          +records.
          Â¬Note:+This field is only displayed when in@LONG+display format
@DESC     +Description of the LOGREC record or the first 128 bytes of the EBCDIC
          +Variable Recording Area (VRA) of the SDWA from#ABEND+and#ProgInt
          +records.
          Â¬Note:+This field is only displayed when in@LONG+display format







+Hit the%ENTER+key to start over with this tutorial
)init
 &ZCMD = &Z
 &CONT = LRS$T1
)end
>< ENDUP       "REVIEW" PDS MEMBER OFFLOAD AT 20:05 ON 97/02/25
./ ADD NAME=WHATDATE 0100-01283-01283-1354-00014-00014-00000-DALCOCK
/* rexx */
/*trace i*/
/*********************************************************************/
/* This exec invokes Dave's WHATDATE dialog                          */
/*********************************************************************/
parse arg ztrail
daload = "IBMUSER.DA.LOAD"     /* DA$WDATE is asm & linked here */
dasrc  = "IBMUSER.DA.SOURCE"   /* Dave's source library */
address ispexec
"LIBDEF ISPLLIB DATASET ID('"daload"') STACK"
"LIBDEF ISPPLIB DATASET ID('"dasrc"') STACK"
"SELECT PGM(DA$WDATE) NEWAPPL(DA) PASSLIB"
"LIBDEF ISPPLIB"
"LIBDEF ISPLLIB"
./ ADD NAME=X$ADATA  0100-01266-01266-1821-00028-00028-00000-DAVE
-- PUT JOBCARD HERE --
//*********************************************************************
//***                                                               ***
//**  SAMPLE JOB TO INVOKE THE HLASM AND ANALYZE THE ADATA FILE      **
//***                                                               ***
//*********************************************************************
//*
//** ASSEMBLE A DSECT AND GET A ADATA FILE
//*
//DA$DATE  EXEC HLASMC,PARM.C='ADATA'
//C.SYSIN  DD *
         PRINT DATA
         PRINT GEN
         CVT LIST=YES,DSECT=YES
         END ,
//C.SYSADATA DD DSN=&&SYSADATA,
//            DCB=(LRECL=32756,BLKSIZE=32760,RECFM=VB),
//            DISP=(,CATLG),UNIT=SYSTS,
//            SPACE=(CYL,(5,2),RLSE)
//*
//** INVOKE THE BOOTSTRAP PROGRAM TO ANALYZE THE ADATA FILE
//*
//SMPADATA EXEC PGM=DA$ADATA
//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD
//SYSPRINT DD SYSOUT=*,DCB=(LRECL=133,BLKSIZE=133,RECFM=FA)
//REXXOUT  DD SYSOUT=*,DCB=(LRECL=133,BLKSIZE=133,RECFM=F)
//SYSUDUMP DD SYSOUT=*
//SYSADATA DD DISP=SHR,DSN=&&SYSADATA
./ ADD NAME=X$ASMHA1 0100-01266-01266-1821-00366-00366-00000-DAVE
//*     - JOB CARD HERE -
//*********************************************************************
//***                                                               ***
//**     MVS Data Area Handbook                                      **
//***                                                               ***
//*********************************************************************
//*
//DHB      PROC MBR=,APARM=''
//DAHANDBK EXEC PGM=DA$ASMHA,COND=EVEN,
//         PARM='NOLOGO,NOCDASH,ASMPARM(NOXREF,NOESD)&APARM'
//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD
//SYSPRINT DD SYSOUT=*
//SYSUDUMP DD SYSOUT=*
//REPORT   DD DISP=SHR,DSN=IBMUSER.MVS.DHB(&MBR)
//ASMIN    DD DDNAME=SYSIN
//ASMLIB   DD DISP=SHR,DSN=SYS1.MACLIB,UNIT=3390,VOL=SER=ESA43R
//         DD DISP=SHR,DSN=SYS1.MODGEN,UNIT=3390,VOL=SER=ESA43R
//ASMPUNCH DD DUMMY
//ASMLIN   DD DUMMY
//ASMTERM  DD SYSOUT=*
//ASMPRINT DD DISP=SHR,DSN=IBMUSER.MVS.ASMLIST(&MBR)
//ASMUT1   DD UNIT=SYSDA,SPACE=(CYL,(10,5)),DSN=&&SYSUT1
//DHB      PEND
//*
//** Delete old libraries
//*
//DEL$OLD  EXEC PGM=IDCAMS
//SYSPRINT DD SYSOUT=*
//SYSIN    DD *
 DELETE 'IBMUSER.MVS.DHB'
 DELETE 'IBMUSER.MVS.ASMLIST'
 SET MAXCC=0
//*
//** Allocate new libraries
//*
//LOCATE   EXEC PGM=IEFBR14
//DHB      DD DSN=IBMUSER.MVS.DHB,
//            DISP=(,CATLG),UNIT=SYSDA,
//            DCB=(LRECL=133,BLKSIZE=1330,RECFM=FBA),
//            SPACE=(CYL,(15,5,64))
//ASMLIST  DD DSN=IBMUSER.MVS.ASMLIST,
//            DISP=(,CATLG),UNIT=SYSDA,
//            DCB=(LRECL=121,BLKSIZE=1210,RECFM=FBM),
//            SPACE=(CYL,(15,5,64))
//*
//** Generate Data Area Hand Books for various MVS control blocks.
//**
//** The JCL below was modified from Gilbert Saint-flour's file 183
//** HANDBOOK member at CBT v409 @1996-08-31
//**
//** I will be modifying this to do the ISPF PACK to save DASD space.
//*
//ACB    EXEC DHB,MBR=ACB
         IFGACB
         END
//ACEE   EXEC DHB,MBR=ACEE
         IHAACEE
         END
//ASCB   EXEC DHB,MBR=ASCB
         IHAASCB DSECT=YES,LIST=YES
         END
//ASVT   EXEC DHB,MBR=ASVT
         IHAASVT DSECT=YES,LIST=YES
         END
//ASSB   EXEC DHB,MBR=ASSB
         IHAASSB LIST=YES
         END
//ASXB   EXEC DHB,MBR=ASXB
         IHAASXB DSECT=YES,LIST=YES
         END
//ATTACH EXEC DHB,MBR=ATTACH
         IEZATTCH LIST=YES
         END
//BASEA  EXEC DHB,MBR=BASEA
         IEEBASEA
         END
//CDE    EXEC DHB,MBR=CDE
         IHACDE
         END
//CSCB   EXEC DHB,MBR=CSCB
         IEECHAIN
         END
//CSD    EXEC DHB,MBR=CSD
         IHACSD DSECT=YES
         END
//CVT    EXEC DHB,MBR=CVT
         CVT DSECT=YES,LIST=YES,PREFIX=YES
         END
//DCB    EXEC DHB,MBR=DCB
         DCBD  DSORG=PS
         END
//DCBDA  EXEC DHB,MBR=DCBDA
         DCBD  DSORG=DA
         END
//DCE    EXEC DHB,MBR=DCE
         IECDDCE
         END
//DECB   EXEC DHB,MBR=DECB
         IHADECB DSECT=YES
         END
//DFA    EXEC DHB,MBR=DFA
         IHADFA DSECT=YES
         END
//DSAB   EXEC DHB,MBR=DSAB
         IHADSAB
         END
//DSCB1  EXEC DHB,MBR=DSCB1
DSCB1    DSECT ,
         IECSDSL1 1
         END
//DSCB4  EXEC DHB,MBR=DSCB4
DSCB4    DSECT ,
         DS    44X'04'
         IECSDSL1 4
         END
//DYNALL EXEC DHB,MBR=DYNALLOC
*STATUS      OLD=01   MOD=02    NEW=04    SHR=08
*DISP    UNCATLG=01 CATLG=02 DELETE=04   KEEP=08
*SPACE                ALX=02   MXIG=04 CONTIG=08
*LABEL        NL=01    SL=02    NSL=04            SUL=0A
*             BLP=10  LTM=21     AL=40    AUL=48
         IEFZB4D0
         IEFZB4D2
         END
//DEB    EXEC DHB,MBR=DEB
         IEZDEB LIST=YES
         END
//DVA    EXEC DHB,MBR=DVA
         IHADVA DSECT=YES
         END
//DVCT   EXEC DHB,MBR=DVCT
         IHADVCT DSECT=YES
         END
//ECT    EXEC DHB,MBR=ECT
         IKJECT
         END
//ECVT   EXEC DHB,MBR=ECVT
         IHAECVT LIST=YES
         END
//EPIE   EXEC DHB,MBR=EPIE
         IHAEPIE
         END
//GDA    EXEC DHB,MBR=GDA,APARM=',NAMEL=24'
         IHAGDA
         END
//IOB    EXEC DHB,MBR=IOB
         IEZIOB DSECT=YES
         END
//IOCOM  EXEC DHB,MBR=IOCOM
         IECDIOCM
         END
//JCT    EXEC DHB,MBR=JCT
JCT      DSECT
         IEFAJCTB
         END
//JCTX   EXEC DHB,MBR=JCTX
JCTX     DSECT
         IEFJCTX
         END
//JESCT  EXEC DHB,MBR=JESCT
         IEFJESCT
         END
//JFCB   EXEC DHB,MBR=JFCB
JFCB     DSECT
         IEFJFCBN LIST=YES
         END
//JMR    EXEC DHB,MBR=JMR
         IEFJMR
         END
//JSAB   EXEC DHB,MBR=JSAB
         IAZJSAB LIST=YES
         END
//JSCB   EXEC DHB,MBR=JSCB
         IEZJSCB
         END
//JSCVT  EXEC DHB,MBR=JSCVT
         IEFJSCVT
         END
//LCCA   EXEC DHB,MBR=LCCA
         IHALCCA DSECT=YES,LIST=YES
         END
//LCT    EXEC DHB,MBR=LCT
LCT      DSECT ,
         IEFALLCT
         END
//LDA    EXEC DHB,MBR=LDA
         IHALDA
         END
//LLE    EXEC DHB,MBR=LLE
         IHALLE
         END
//LPDE   EXEC DHB,MBR=LPDE
         IHALPDE
         END
//LWA    EXEC DHB,MBR=LWA
         IKJEFLWA
         END
//OCE    EXEC DHB,MBR=OCE
OCE      DSECT ,
         IECDSECS
         IECDSECT
         END
//OUCB   EXEC DHB,MBR=OUCB
         IRAOUCB DSECT=YES
         END
//PCCA   EXEC DHB,MBR=PCCA
         IHAPCCA DSECT=YES
         END
//PDS2   EXEC DHB,MBR=PDS2
         IHAPDS DSECT=YES,PDSBLDL=YES
         END
//PSA    EXEC DHB,MBR=PSA
         IHAPSA DSECT=YES,LIST=YES
         END
//PSCB   EXEC DHB,MBR=PSCB
         IKJPSCB
         END
//RCE    EXEC DHB,MBR=RCE
         IARRCE  ,              RSM CONTROL AND ENUMERATION AREA
         END
//RD     EXEC DHB,MBR=RD
         IHARD   ,              REGION DESCRIPTOR
         END
*/SAMB   EXEC DHB,MBR=SAMB
*        IGGSAMB DSECT=YES
*        END
//RB     EXEC DHB,MBR=RB
         IKJRB DSECT=YES,LIST=YES
         END
//REXX   EXEC DHB,MBR=REXX,APARM=',NAMEL=24'
         IRXARGTB
         IRXCMPTB ,            COMPILER TABLE TSO/E 2.3.1
         IRXDSIB
         IRXEFPL
         IRXENVB               ENVIRONMENT BLOCK
         IRXENVT               ENVIRONMENT TABLE (IRXANCHR)
         IRXEVALB
         IRXEXECB
         IRXEXTE
         IRXFPDIR
         IRXINSTB
         IRXMODNT
         IRXPACKT
         IRXPARMB
         IRXSHVB
         IRXSUBCT
         IRXWORKB
         END
//RIB    EXEC DHB,MBR=RIB
         ISGRIB
         END
//RPL    EXEC DHB,MBR=RPL
         IFGRPL
         IDARMRCD ,                RECORD MGMT ERROR CODES
         END
//SCA    EXEC DHB,MBR=SCA
         IHASCA
         END
//SCB    EXEC DHB,MBR=SCB
         IHASCB DSECT=YES
         END
//SCT    EXEC DHB,MBR=SCT
SCT      DSECT
         IEFASCTB
         END
//SCTX   EXEC DHB,MBR=SCTX
         IEFSCTX DSECT=YES
         END
//SCVT   EXEC DHB,MBR=SCVT
         IHASCVT DSECT=YES,LIST=YES
         END
//SDWA   EXEC DHB,MBR=SDWA
         IHASDWA DSECT=YES,VRAMAP=YES
         END
//SIOT   EXEC DHB,MBR=SIOT
SIOT     DSECT
         IEFASIOT
         END
//SMCA   EXEC DHB,MBR=SMCA
         IEESMCA
         END
//SNAP   EXEC DHB,MBR=SNAP
         IHASNAP DSECT=YES
         END
//SPIE   EXEC DHB,MBR=SPIE
         IHASCA                 SPIE/ESPIE CONTROL AREA
         IHAEPIE                EXTENDED PROGRAM INTERRUPT ELEMENT
         IHAPIE                 PROGRAM INTERRUPT ELEMENT
         IHAPICA                PROGRAM INTERRUPTION CONTROL AREA
         END
//SPQE   EXEC DHB,MBR=SPQE
         IHASPQE                SP Q ELEMENT
         IHAFBQE                FREE BLOCK
         IHASPQA                SP Q DESCRIPTOR
         IHADQE                 DESCRIPTOR Q ELEMENT
         IHAFQE                 FREE Q ELEMENT
         IHASPT                 CSA
         END
//SSOB   EXEC DHB,MBR=SSOB
         IEFJSSOB (AL,SO)
         END
//SSIB   EXEC DHB,MBR=SSIB
         IEFJSSIB
         END
//SSSA   EXEC DHB,MBR=SSSA
         IEFSSSA
         END
//SSVT   EXEC DHB,MBR=SSVT
         IEFJSSVT
         END
//STCB   EXEC DHB,MBR=STCB
         IHASTCB LIST=YES
         END
//SVT    EXEC DHB,MBR=SVT
         IHASVT LIST=YES
         END
//SWB    EXEC DHB,MBR=SWB
         IEFSWB
         END
//TAXE   EXEC DHB,MBR=TAXE
         IKJTAXE
         END
//TCAS   EXEC DHB,MBR=TCAS
         IKTTCAST DSECT=YES
         END
//TCB    EXEC DHB,MBR=TCB
         IKJTCB DSECT=YES,LIST=YES
         END
//TCT    EXEC DHB,MBR=TCT
         IEFTCT
         END
//TIOT   EXEC DHB,MBR=TIOT
TIOT     DSECT
         IEFTIOT1
         END
//TMPWA  EXEC DHB,MBR=TMPWA
         IKJTMPWA
         END
//TPC    EXEC DHB,MBR=TPC
         IEAVVTPC
         END
//TQE    EXEC DHB,MBR=TQE
         IHATQE
         END
//TSB    EXEC DHB,MBR=TSB
         IKJTSB LIST=YES,EXT=YES
         END
//TSVT   EXEC DHB,MBR=TSVT
         IKJTSVT
         END
//UCB    EXEC DHB,MBR=UCB
**       IEFUCBOB LIST=YES,PREFIX=YES,SSMD=YES
         IEFUCBOB LIST=YES,PREFIX=YES
         END
//UCM    EXEC DHB,MBR=UCM
         IEECUCM LIST=YES,DSECT=YES
         END
//UPT    EXEC DHB,MBR=UPT
         IKJUPT
         END
//VLD    EXEC DHB,MBR=IGDVLD
         IGDVLD
         END
//XL     EXEC DHB,MBR=XL
         IHAXTLST
         END
./ ADD NAME=X$ASMHA2 0100-01266-01266-1821-00071-00071-00000-DAVE
//* - PUT JOB CARD HERE -
//*
//** ASSEMBLE THE DA$ASMHA PROGRAM (GOOD BECAUSE IT HAS SOME
//** INSTRUCTIONS THAT TRY TO LOOK/MODIFY LOW CORE WHICH OCCUR
//** BECAUSE OF MISSING COMMAS AND THE LIKE).  THE //PASS3 OUTPUT
//** SHOULD SHOW YOU THE BAD INSTRUCTIONS AS IEV$P3 (PASS 3) MESSAGES.
//*
//ASMH    EXEC ASMHC
//C.SYSLIB DD
//         DD DISP=SHR,DSN=SYS1.MODGEN
//         DD DISP=SHR,DSN=IBMUSER.DA.SOURCE
//SYSPUNCH DD DUMMY
//SYSPRINT DD DSN=&&ASMLIST,DISP=(NEW,PASS),UNIT=VIO,
//            DCB=(LRECL=121,BLKSIZE=1210,RECFM=FBM),
//            SPACE=(TRK,(15,15))
//SYSIN    DD DISP=SHR,DSN=IBMUSER.DA.SOURCE(DA$ASMHA)
//*
//** INVOKE DA$ASMHA WITH DEFAULT -AND- PASS3 FILE
//**
//** HINT: LOOK FOR IEV$P3 MESSAGES!!!!
//*
//SAMP1   EXEC PGM=DA$ASMHA
//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD
//SYSUT1   DD DISP=SHR,DSN=&&ASMLIST
//SYSPRINT DD SYSOUT=*
//PASS3    DD SYSOUT=*              <- MODIFIED ASSEMBLER H LISTING
//SYSUDUMP DD SYSOUT=*
//ABNLDUMP DD SYSOUT=*
//*
//** INVOKE DA$ASMHA WITH DEFAULT -AND- PASS3 FILE -AND- SHOWING
//** THE STARTING ADDRESS MODE (GOOD FOR DEBUGGING AND LOOKING AT
//** DUMPS)
//*
//SAMP2   EXEC PGM=DA$ASMHA,
//        PARM='ADDR=0000FC00'      <- PUT PROGRAM EPA HERE
//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD
//SYSUT1   DD DISP=SHR,DSN=&&ASMLIST
//SYSPRINT DD SYSOUT=*
//PASS3    DD SYSOUT=*              <- MODIFIED ASSEMBLER H LISTING
//SYSUDUMP DD SYSOUT=*
//ABNLDUMP DD SYSOUT=*
//*
//** INVOKE DA$ASMHA AND CREATE DATA AREA HANDBOOKS
//*
//SAMP3   EXEC PGM=DA$ASMHA
//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD
//SYSUT1   DD DISP=SHR,DSN=&&ASMLIST
//SYSPRINT DD SYSOUT=*
//INDEX    DD SYSOUT=*              <- INDEX OF DSECTS IN DHB!
//REPORT   DD SYSOUT=*              <- DATA AREA HANDBOOKS
//SYSUDUMP DD SYSOUT=*
//ABNLDUMP DD SYSOUT=*
//*
//** INVOKE DA$ASMHA AND CREATE DCF OUTPUT
//*
//SAMP4   EXEC PGM=DA$ASMHA,PARM='DCF'
//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD
//SYSUT1   DD DISP=SHR,DSN=&&ASMLIST
//SYSPRINT DD SYSOUT=*
//REPORT   DD SYSOUT=*              <- DCF OUTPUT HERE
//SYSUDUMP DD SYSOUT=*
//ABNLDUMP DD SYSOUT=*
//*
//** ABENDED: NO WAY, I DON'T WRITE PROGRAMS THAT ABEND!
//*
//PRINTIT EXEC PGM=IEBGENER,COND=ONLY
//SYSUT1   DD DISP=SHR,DSN=&&ASMLIST
//SYSUT2   DD SYSOUT=*
//SYSPRINT DD DUMMY
//SYSIN    DD DUMMY
//
./ ADD NAME=X$BRODC1 0100-01266-01266-1821-00012-00012-00000-DAVE
// -PUT JOBCARD HERE-
//*
//** SCAN SYS1.BRODSCAN AND REPORT ON USAGE
//*
//JUSTDOIT EXEC PGM=DA$BRODC
//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD
//BRODCAST DD DISP=SHR,DSN=SYS1.BRODCAST,
//            DCB=BUFNO=16
//SYSPRINT DD SYSOUT=*
//INDEX    DD SYSOUT=*
//MAIL     DD SYSOUT=*
//SYSUDUMP DD SYSOUT=*
./ ADD NAME=X$BRODC2 0100-01266-01266-1821-00031-00031-00000-DAVE
//*
//** SCAN SYS1.BRODSCAN, REPORT ON USAGE, AND SAVE LOST MAIL
//*
//JUSTDOIT EXEC PGM=DA$BRODC
//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD
//BRODCAST DD DISP=SHR,DSN=SYS1.BRODCAST,
//            DCB=BUFNO=16
//*           UNIT=3390,VOL=SER=VOLUME
//*
//SYSPRINT DD SYSOUT=*
//INDEX    DD SYSOUT=*
//MAIL     DD SYSOUT=*
//SYSUDUMP DD SYSOUT=*
//ABNLDUMP DD SYSOUT=*      FORCE IBM (NORMAL) DUMP
//*
//BKLIDS   DD DISP=SHR,DSN=ACF.PRI.BKLIDS           ** OPTIONAL **
//*
//IEBUPDTE DD DSN=&&UPDTE,                          ** OPTIONAL **
//            DISP=(,PASS),UNIT=SYSDA,
//            DCB=(LRECL=80,BLKSIZE=6320,RECFM=FB),
//            SPACE=(CYL,(2,2),RLSE)
//*
//** PROCESS THE IEBUPDTE INPUT RECORDS AND CREATE PDS WITH MAIL...
//*
//UPDATE   EXEC PGM=IEBUPDTE,PARM=NEW
//SYSPRINT DD SYSOUT=*
//SYSUT2   DD DSN=SYS2.LOSTMAIL,
//            DISP=(,CATLG),UNIT=SYSTS,
//            DCB=(LRECL=80,BLKSIZE=23200,RECFM=FB),
//            SPACE=(TRK,(30,15,64),RLSE)
//SYSIN    DD DISP=(OLD,DELETE),DSN=&&UPDTE
./ ADD NAME=X$BRODC3 0100-01266-01266-1821-00057-00057-00000-DAVE
/*********************************************************************
*                                                                    *
* Name: LOSTMAIL                                                     *
*                                                                    *
* Author: David Alcock :: davea@planetmvs.com                        *
*                                                                    *
* Purpose: Show mail lost when SYS1.BRODCAST was reformated. The     *
*          PDS was created from output from the DA$BRODC utility     *
*                                                                    *
*********************************************************************/

arg user
if user == "" then user = sysvar(sysuid)
dsn = "'SYS2.LOSTMAIL("strip(user)")'"

if SYSVAR(SYSISPF) <> 'ACTIVE' then do

   /* if you don't have the LIST command, put a error message
      here and an exit */

   say "Using the LIST command, type 'QUIT' to end after" ,
       "hitting enter"
   address TSO "LIST "dsn  /* Invoke Applied Software's LIST */
   exit
   end

call Browse_Dataset

exit

/*********************************************************************
*  Browse the dataset in variable DSN and handle error conditions    *
*********************************************************************/

Browse_Dataset:
x = LISTDSI(dsn)

if x = 0 then do
   address ISPEXEC "CONTROL ERRORS RETURN"
   address ISPEXEC "CONTROL DISPLAY SAVE"
   address ISPEXEC "BROWSE DATASET("dsn")"
   br_rc = rc
   if br_rc <> 0 then do
      zedsmsg = "No Mail"
      zedlmsg = "No mail for user: "user
      address ISPEXEC "SETMSG MSG(ISRZ001)"
      end
   address ISPEXEC "CONTROL DISPLAY RESTORE"
   address ISPEXEC "CONTROL ERRORS CANCEL"
   end
else do
     zedsmsg = "No Mail"
     zedlmsg = "No mail for user: "user
     address ISPEXEC "SETMSG MSG(ISRZ001)"
     end

return
./ ADD NAME=X$COBR   0100-01266-01266-1821-00014-00014-00000-DAVE
//*********************************************************************
//***                                                               ***
//**   TELL ME EVERYTHING ABOUT A COBOL MODULE'S COMPILE OPTIONS     **
//***                                                               ***
//*********************************************************************
//SOURCEC  EXEC PGM=DA$COBR,PARM='COBEMAIL'
//*
//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DAVE.LOAD
//         DD DISP=SHR,DSN=IBMUSER.DA.LOAD
//*
//SYSPRINT DD SYSOUT=*
//SYSUDUMP DD SYSOUT=*
//ABNLDUMP DD DUMMY
//
./ ADD NAME=X$DISKR  0100-01266-01266-1821-00028-00028-00000-DAVE
- JOB CARD HERE -
//*
//** DISK REPORTING UTILITY
//*
//DASDCONF EXEC PGM=DA$DISKR,DPRTY=(15,15),TIME=1439
//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD
//VATLST   DD DISP=SHR,DSN=SYS1.PARMLIB(VATLST00)
//*
//SYSPRINT DD SYSOUT=*,DCB=(LRECL=133,BLKSIZE=133,RECFM=FBA)
//REPORT   DD SYSOUT=*,DCB=(LRECL=133,BLKSIZE=1330,RECFM=FBA)
//VTOCRPT  DD SYSOUT=*,DCB=(LRECL=133,BLKSIZE=1330,RECFM=FBA)
//SYSUDUMP DD SYSOUT=*
//*
//WRKFILE1 DD DISP=(,PASS),DSN=&&WRKFILE1,UNIT=SYSDA,
//            DCB=(LRECL=512,BLKSIZE=5120,RECFM=FB),
//            SPACE=(CYL,(5,5))
//WRKFILE2 DD DISP=(,PASS),DSN=&&WRKFILE2,UNIT=SYSDA,
//            DCB=(LRECL=512,BLKSIZE=5120,RECFM=FB),
//            SPACE=(CYL,(20,20))
//WRKFILE3 DD DISP=(,PASS),DSN=&&WRKFILE3,UNIT=SYSDA,
//            DCB=(LRECL=512,BLKSIZE=5120,RECFM=FB),
//            SPACE=(CYL,(20,20))
//WRKFILE4 DD DISP=(,PASS),DSN=&&WRKFILE4,UNIT=SYSDA,
//            DCB=(LRECL=80,BLKSIZE=80,RECFM=FB),
//            SPACE=(CYL,(5,5))
//WRKFILE5 DD DISP=(,PASS),DSN=&&WRKFILE5,UNIT=SYSDA,
//            DCB=(LRECL=121,BLKSIZE=1210,RECFM=FBA),
//            SPACE=(CYL,(5,5))
./ ADD NAME=X$EREP   0100-01266-01266-1821-00106-00106-00000-DAVE
//*********************************************************************
//***                                                               ***
//**    GET LOGREC ENTRIES FROM THE CURRENTLY ACTIVE LOGRECS         **
//***                                                               ***
//*********************************************************************
//*
//** CURRENT LOGREC ON SYSTEM SMFID=XYZ1
//*
//LR$XYZ1  EXEC PGM=IFCEREP1,
//         REGION=4096K,
//         PARM=('ZERO=N,ACC=Y,TABSIZE=256K,LINECT=60,TYPE=OTIEDHS',
//         'DEV=(N3725,N2501,N3211),PRINT=PS')
//SERLOG   DD DISP=SHR,DSN=SYS1.LOGREC,
//            UNIT=SYSALLDA,VOL=SER=XA1CAT <- XYZ1
//ACCDEV   DD DSN=&&LRXYZ1,UNIT=SYSDA,
//            DISP=(,PASS,DELETE),
//            SPACE=(CYL,(2,2),RLSE),
//            DCB=(RECFM=VB,BLKSIZE=6144,LRECL=2000)
//TOURIST  DD SYSOUT=*,DCB=BLKSIZE=133
//EREPPT   DD SYSOUT=*,DCB=BLKSIZE=133
//SRSUDUMP DD SYSOUT=*
//SYSIN    DD DUMMY
//*
//** CURRENT LOGREC ON SYSTEM SMFID=XYZ5
//*
//LR$XYZ5  EXEC PGM=IFCEREP1,
//         REGION=4096K,
//         PARM=('ZERO=N,ACC=Y,TABSIZE=256K,LINECT=60,TYPE=OTIEDHS',
//         'DEV=(N3725,N2501,N3211),PRINT=PS')
//SERLOG   DD DISP=SHR,DSN=SYS1.LOGREC,
//            UNIT=SYSALLDA,VOL=SER=SYS5C1 <- XYZ5
//ACCDEV   DD DSN=&&LRXYZ5,UNIT=SYSDA,
//            DISP=(,PASS,DELETE),
//            SPACE=(CYL,(2,2),RLSE),
//            DCB=(RECFM=VB,BLKSIZE=6144,LRECL=2000)
//TOURIST  DD SYSOUT=*,DCB=BLKSIZE=133
//EREPPT   DD SYSOUT=*,DCB=BLKSIZE=133
//SYSUDUMP DD SYSOUT=*
//SYSIN    DD DUMMY
//*********************************************************************
//***                                                               ***
//* CAPTURE THE LAST 31 DAYS OF SOFTWARE RECORDS FOR SOFTLOG PROCES   *
//***                                                               ***
//*********************************************************************
//*
//** CREATE A DATE CARD RANGE TO LIMIT LOGREC
//*
//SOFTLOGR EXEC PGM=IKJEFT01,PARM='%EREP31D'
//SYSTSPRT DD SYSOUT=*
//SYSPROC  DD DISP=SHR,DSN=IBMUSER.DAVE.EXEC
//DATEDD   DD DISP=(,PASS),UNIT=SYSDA,DSN=&&DATE,SPACE=(TRK,1),
//            DCB=(RECFM=FB,LRECL=80,BLKSIZE=0)
//SYSTSIN  DD DUMMY,DCB=BLKSIZE=80
//*
//** INVOKE EREP TO GET THE LAST 30 DAYS FROM THE MONTHLY TAPE
//*
//SOFTLOGT EXEC PGM=IFCEREP1,REGION=6000K,
// PARM='CARD'
//SYSUDUMP DD SYSOUT=*
//ACCIN    DD DISP=SHR,DSN=DS.LOGREC1(-1)
//         DD DISP=SHR,DSN=DS.LOGREC1(0)
//ACCDEV   DD DISP=(NEW,PASS),DSN=&&SOFTLOG,
//            UNIT=SYSDA,
//            DCB=(RECFM=VB,LRECL=2000,BLKSIZE=2004),
//            SPACE=(TRK,(300,300))
//DIRECTWK DD UNIT=SYSDA,SPACE=(CYL,(30,15),,CONTIG)
//TOURIST  DD SYSOUT=*
//SYSIN    DD *
LINECT=60
TABSIZE=900K
ACC=Y
HIST=Y
PRINT=NO
TYPE=SIE
ZERO=N
//   DD DISP=(OLD,DELETE),DSN=&&DATE
//EREPPT DD DUMMY
//*********************************************************************
//***                                                               ***
//** MERGE THE HISTORY LOGREC WITH THE CURRENT LOGREC ENTRIES        **
//***                                                               ***
//*********************************************************************
//*
//** DELETE EXISTING SOFTLOG LIBRARY
//*
//SOFTLOGD EXEC PGM=IEFBR14
//ACCDEV   DD DSN=SYS9.SYS.LOGREC.SOFTLOG,UNIT=SYSALLDA,
//            DISP=(MOD,DELETE,DELETE),
//            SPACE=(TRK,(300,300),RLSE)
//*
//** SORT SOFTLOG LIBRARY
//*
//SOFTLOGS EXEC PGM=SORT,REGION=4000K
//SORTIN   DD DISP=(OLD,DELETE,DELETE),DSN=&&SOFTLOG
//         DD DISP=(OLD,DELETE,DELETE),DSN=&&LRXYZ1
//         DD DISP=(OLD,DELETE,DELETE),DSN=&&LRXYZ5
//SORTOUT  DD DISP=(NEW,CATLG,DELETE),DSN=SYS9.SYS.LOGREC.SOFTLOG,
//            UNIT=3380,VOL=SER=XA1CAT,
//            DCB=(RECFM=VB,LRECL=2000,BLKSIZE=2004),
//            SPACE=(TRK,(300,300),RLSE)
//SYSOUT   DD SYSOUT=*
//SORTMSG  DD SYSOUT=*
//SYSIN    DD *
         SORT  FIELDS=(14,7,BI,A),FILSZ=E3100,DYNALLOC=SYSDA
         RECORD LENGTH=(,,,,500)
/*
./ ADD NAME=X$EREPU  0100-01266-01266-1821-00008-00008-00000-DAVE
// JOB CARD HERE
//UPDATE   EXEC PGM=IEBUPDTE,PARM=NEW
//SYSPRINT DD SYSOUT=*
//SYSUT2   DD DSN=ibmuser.EREP.PANELS,
//            DISP=(,CATLG),UNIT=SYSTS,
//            DCB=(LRECL=80,BLKSIZE=8800,RECFM=FB),
//            SPACE=(TRK,(5,5,8))
//SYSIN    DD DISP=SHR,DSN=ibmuser.DA.SOURCE(I$EREP)
./ ADD NAME=X$IDC    0100-01266-01266-1821-00013-00013-00000-DAVE
//*
//** IDCAMS POST PROCESSOR
//*
//IDCAMS   EXEC PGM=DA$IDC
//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD
//SYSPRINT DD SYSOUT=*
//RECAP    DD SYSOUT=*        DA$IDC: Recap of IDCAMS
//*DATAONLY DD DUMMY          DA$IDC: NO HEADINGS ON //RECAP?
//ERROR    DD SYSOUT=*        DA$IDC: Error code
//*//$$DEBUG  DD SYSOUT=*     DA$IDC: Debugging mode
//SYSUDUMP DD SYSOUT=*
//SYSIN    DD *
 LISTCAT LEVEL('SYS1') ALL
./ ADD NAME=X$PDSR   0100-01266-01266-1821-00161-00161-00000-DAVE
- JOB CARD HERE -
//* SAMPLE INVOCATIONS OF DA$PDSR.  THIS JOBSTREAM DOES NOT EXERCISE
//* ALL OF THE OPTIONS BUT WILL GET YOU STARTED.  USE THE PARM=HELP
//* EXAMPLE TO SEE ALL OF THE OPTIONS AVAILABLE.
//*********************************************************************
//***                                                               ***
//**   DO LINKAGE AND ISPF STATISTICS REPORT FOR ALL DDNAMES         **
//**   WHICH BEGIN WITH SYSLIB                                       **
//***                                                               ***
//*********************************************************************
//STATS    EXEC PGM=DA$PDSR
//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD
//SYSPRINT DD SYSOUT=*
//REPORT   DD SYSOUT=*
//SYSUDUMP DD SYSOUT=*
//ABNLDUMP DD DUMMY
//*
//SYSLIB00 DD DISP=SHR,DSN=SYS1.PARMLIB    <- ISPF STATS
//SYSLIB01 DD DISP=SHR,DSN=SYS1.LINKLIB    <- LOAD LIBRARY INFO
//*********************************************************************
//***                                                               ***
//**   PERFORM A HISTORY AND TRANSLATOR REPORT FOR ALL DDNAMES       **
//**   WHICH BEGIN WITH SYSLIB, THE DATE FORMAT WILL BE US.          **
//**                                                                 **
//**   ADDITIONAL PARAMETERS ARE SPECIFIED IN THE SYSIN FILE RATHER  **
//**   THAN THE PARM CARD.                                           **
//**                                                                 **
//**   THE PDS DIRECTORY ENTRIES WILL BE DUMPED TO SYSPRINT.         **
//***                                                               ***
//*********************************************************************
//TRHIST   EXEC PGM=DA$PDSR,TIME=1439,
//         PARM='HISTRPT,DATE=US'
//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD
//SYSPRINT DD SYSOUT=*
//REPORT   DD SYSOUT=*
//SYSIN    DD *
TRANRPT,DUMPDIRE
//*
//TRANRPT  DD SYSOUT=*
//HISTRPT  DD SYSOUT=*
//BINDEROU DD DUMMY
//BINDERPR DD DUMMY
//SYSUDUMP DD SYSOUT=*
//ABNLDUMP DD DUMMY
//*
//SYSLIB01 DD DISP=SHR,DSN=IBMUSER.DA.LOAD
//*
//WRKFILE1 DD DISP=(,DELETE),UNIT=SYSDA,SPACE=(CYL,25)
//WRKFILE2 DD DISP=(,DELETE),UNIT=SYSDA,SPACE=(CYL,25)
//WRKFILE3 DD DISP=(,DELETE),UNIT=SYSDA,SPACE=(TRK,15)
//*********************************************************************
//***                                                               ***
//**   PERFORM A HISTORY AND TRANSLATOR REPORT FOR ALL DDNAMES       **
//**   WHICH BEGIN WITH SYSLIB. ONLY THE MEMBERS THAT BEGIN WITH     **
//**   "IEF" WILL BE PROCESSED.                                      **
//***                                                               ***
//*********************************************************************
//TRHISTSE EXEC PGM=DA$PDSR,TIME=1439,
//         PARM='HISTRPT,TRANRPT,FINDMEM=IEF*,ONLYFIND'
//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD
//SYSPRINT DD SYSOUT=*
//REPORT   DD SYSOUT=*
//*
//TRANRPT  DD SYSOUT=*
//HISTRPT  DD SYSOUT=*
//BINDEROU DD DUMMY
//BINDERPR DD DUMMY
//SYSUDUMP DD SYSOUT=*
//ABNLDUMP DD DUMMY
//*
//SYSLIB01 DD DISP=SHR,DSN=SYS1.LINKLIB
//*
//WRKFILE1 DD DISP=(,DELETE),UNIT=SYSDA,SPACE=(CYL,25)
//WRKFILE2 DD DISP=(,DELETE),UNIT=SYSDA,SPACE=(CYL,25)
//WRKFILE3 DD DISP=(,DELETE),UNIT=SYSDA,SPACE=(TRK,15)
//*
//*********************************************************************
//***                                                               ***
//**   PRINT THE F1-DSCB FOR SYS1.NUCLEUS AS WE PROCESS IT; USE THE  **
//**   ISODATE FORMAT WHEN DATES ARE SHOWN IN THE REPORT;            **
//***                                                               ***
//*********************************************************************
//NUCLEUS  EXEC PGM=DA$PDSR,PARM='DUMPDSCB,DATE=ISO'
//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD
//SYSPRINT DD SYSOUT=*
//REPORT   DD SYSOUT=*
//SYSUDUMP DD SYSOUT=*
//ABNLDUMP DD DUMMY
//*
//SYSLIB00 DD DISP=SHR,DSN=SYS1.NUCLEUS
//*********************************************************************
//***                                                               ***
//**   GET A EYECATCHER REPORT FOR ALL LIBRARIES THAT START WITH     **
//**   SYSLIB                                                        **
//***                                                               ***
//*********************************************************************
//ECRPT    EXEC PGM=DA$PDSR,PARM='ECRPT'
//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD
//SYSPRINT DD SYSOUT=*
//REPORT   DD SYSOUT=*
//ECRPT    DD SYSOUT=*
//SYSUDUMP DD SYSOUT=*
//ABNLDUMP DD DUMMY
//*
//SYSLIB00 DD DISP=SHR,DSN=SYS1.LPALIB
//*********************************************************************
//***                                                               ***
//**   GET A ZAP REPORT FOR ALL LIBRARIES THAT START WITH            **
//**   SYSLIB                                                        **
//***                                                               ***
//*********************************************************************
//ZAPRPT   EXEC PGM=DA$PDSR,PARM='ZAPRPT'
//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD
//SYSPRINT DD SYSOUT=*
//REPORT   DD SYSOUT=*
//ZAPRPT   DD SYSOUT=*
//SYSUDUMP DD SYSOUT=*
//ABNLDUMP DD DUMMY
//*
//SYSLIB00 DD DISP=SHR,DSN=SYS1.NUCLEUS
//*********************************************************************
//***                                                               ***
//**   SHOW HELP INFORMATION FOR DA$PDSR                             **
//***                                                               ***
//*********************************************************************
//HELP     EXEC PGM=DA$PDSR,PARM='HELP'
//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD
//SYSPRINT DD SYSOUT=*
//REPORT   DD SYSOUT=*
//SYSUDUMP DD SYSOUT=*
//ABNLDUMP DD DUMMY
//*********************************************************************
//***                                                               ***
//**   CHECK FOR DUPLICATE MODULES IN THE LINKLIST                   **
//***                                                               ***
//*********************************************************************
//LNKLST   EXEC PGM=DA$PDSR,PARM='LNKLST,CHKDUP,NODETAIL',
//         TIME=1439
//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD
//SYSPRINT DD SYSOUT=*
//REPORT   DD SYSOUT=*
//SYSUDUMP DD SYSOUT=*
//ABNLDUMP DD DUMMY
//WRKFILE1 DD DISP=(,DELETE),UNIT=SYSDA,SPACE=(CYL,25)
//WRKFILE2 DD DISP=(,DELETE),UNIT=SYSDA,SPACE=(CYL,25)
//WRKFILE3 DD DISP=(,DELETE),UNIT=SYSDA,SPACE=(TRK,15)
//*********************************************************************
//***                                                               ***
//**   CHECK FOR DUPLICATE MODULES IN THE LPALST                     **
//***                                                               ***
//*********************************************************************
//LPALST   EXEC PGM=DA$PDSR,PARM='LPALST,CHKDUP,NODETAIL',
//         TIME=1439
//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD
//SYSPRINT DD SYSOUT=*
//REPORT   DD SYSOUT=*
//SYSUDUMP DD SYSOUT=*
//ABNLDUMP DD DUMMY
//WRKFILE1 DD DISP=(,DELETE),UNIT=SYSDA,SPACE=(CYL,25)
//WRKFILE2 DD DISP=(,DELETE),UNIT=SYSDA,SPACE=(CYL,25)
//WRKFILE3 DD DISP=(,DELETE),UNIT=SYSDA,SPACE=(TRK,15)
./ ADD NAME=X$PDSRJ  0100-01266-01266-1821-00029-00029-00000-DAVE
//* - PUT JOB CARD HERE -
//*********************************************************************
//***                                                               ***
//**   THIS JOBSTREAM VERIFIES THAT YOUR JES2 JCL WILL NOT HAVE AN   **
//**   ERROR AT JES2 STARTUP.  EXECUTING YOUR JES2 JCL THRU DA$PDSR  **
//**   WILL ENSURE THAT THE JCL IS OKAY AND THAT ALL //PROCXX FILES  **
//**   CAN BE PROCESSED VIA AN MVS OPEN.                             **
//**                                                                 **
//**   YOU *MUST* HAVE A VARIABLE TO ALLOW AN OVERRIDE FOR THE       **
//**   PROGRAM NAME IN YOUR JES2 PROC.  PROGRAM NAMES CAN NOT BE     **
//**   OVERRIDEN LIKE OTHER EXEC PARAMETERS.                         **
//**                                                                 **
//**   IF YOU DON'T WANT TO ADD A VARIABLE TO YOUR PRODUCTION JES2   **
//**   PROC, COPY IT INSTREAM AND AT LEAST VERIFY THE PROCLIB        **
//**   CONCATENATIONS.                                               **
//**                                                                 **
//**   EVEN IF YOU DON'T USE DA$PDSR, I WOULD RECOMMEND THAT YOU     **
//**   RUN YOUR JES2 PROC THRU PGM=IEFBR14, CA-JCLCHECK, ETC WHEN    **
//**   IT GETS MODIFIED.  YOU ALWAYS WANT JES2 TO START.             **
//***                                                               ***
//*********************************************************************
//JES2     EXEC JES2,
//         ENTRY='DA$PDSR',                     <- PDS REPORT PROGRAM
//         PARM='PREFIX=PROC'                   <- READ //PROCXX FILES
//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD
//SYSPRINT DD SYSOUT=*
//REPORT   DD SYSOUT=*
//SYSUDUMP DD SYSOUT=*
//ABNLDUMP DD DUMMY
./ ADD NAME=X$PDSRP  0100-01266-01266-1821-00043-00043-00000-DAVE
//*********************************************************************
//***
//**   THIS JOBSTREAM IS AN EXAMPLE OF RELINKING A MODULE WHEN A
//**   CSECT IS FOUND.  IN THIS CASE THE PL/I DATE ROUTINE.
//***
//*********************************************************************
//*
//** EXECUTE DA$PDSR TO GET A CSECT REPORT OUT TO //FLATOUT
//*
//SOURCEC  EXEC PGM=DA$PDSR,TIME=1439,
//         PARM='HISTRPT,TRANRPT,FLATOUT,DATE=ISO'
//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD
//SYSPRINT DD SYSOUT=*
//REPORT   DD SYSOUT=*
//TRANRPT  DD DUMMY
//HISTRPT  DD DUMMY
//FLATOUT  DD DSN=&&FLATOUT,
//            DISP=(,CATLG),UNIT=SYSTS,
//            DCB=(LRECL=32756,BLKSIZE=32760,RECFM=VB),
//            SPACE=(CYL,(50,50),RLSE)
//BINDEROU DD DUMMY CAN BE SYSOUT=*
//BINDERPR DD DUMMY
//*
//SYSLIB01 DD DISP=SHR,DSN=SEP.PGMLIB
//*
//** INVOKE THE PDSE COMMAND FOR EACH MEMBER THAT TO BE RELINKED
//*
//IPDS    EXEC PGM=IKJEFT01,TIME=1439,DYNAMNBR=100,REGION=9M
//SYSEXEC  DD DISP=SHR,DSN=IBMUSER.DA.SOURCE
//SYSUT1   DD DISP=SHR,DSN=&&FLATOUT
//SYSUT2   DD DSN=IBMUSER.RELINK.SEP.PGMLIB,
//            DISP=(,CATLG),UNIT=SYSTS,
//            DCB=(LRECL=80,BLKSIZE=6320,RECFM=FB),
//            SPACE=(CYL,(5,5),RLSE)
//SYSTSPRT DD SYSOUT=*
//SYSTSIN  DD *
 %DA$PDSRT IBMBJDT1 SYS2P.SYS.PL1.PLILINK IBMBJDTA
//JOBCARD  DD *
 //IBMUSERL  JOB  (X,Y,Z,ABC),
 //          'PL/1 RELINK JOB     ',
 //          NOTIFY=IBMUSER,REGION=4M,
 //          MSGCLASS=X,CLASS=U,TIME=1439
/*
./ ADD NAME=X$PDSRR  0100-02191-02191-1111-00107-00107-00000-DALCOCK
.. JOB CARD HERE ..
//*********************************************************************
//***
//**  INVOKE THE DISASSEMBLER TO FIND ALL USAGES OF AN ASSEMBLER
//**  INSTRUCTION.
//***
//*********************************************************************
//SOURCEC  EXEC PGM=DA$PDSR,TIME=1439,
//*        PARM='HISTRPT,TRANRPT,FLATOUT'
//         PARM='HISTRPT,TRANRPT,FLATOUT,FINDMEM=A*,ONLYFIND'
//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD
//SYSPRINT DD SYSOUT=*
//REPORT   DD SYSOUT=*
//TRANRPT  DD SYSOUT=*
//HISTRPT  DD SYSOUT=*
//FLATOUT  DD DSN=&&FLATOUT,
//            DISP=(,PASS),UNIT=SYSDA,
//            DCB=(LRECL=32756,BLKSIZE=32760,RECFM=VB),
//            SPACE=(CYL,(5,5))
//BINDEROU DD DUMMY
//BINDERPR DD DUMMY
//SYSUDUMP DD SYSOUT=*
//ABNLDUMP DD DUMMY
//*
//SYSLIB01 DD DISP=SHR,DSN=IBMUSER.DAVE.LOAD
//*
//** INVOKE THE DA$PDSRR REXX EXEC TO REPORT ON THE FLATOUT FILE
//** USES THE HIGH LEVEL ASSEMBLER TOOLKIT DISASSEMBLER
//*
//RPTDISH EXEC PGM=IKJEFT01,TIME=1439,DYNAMNBR=100,REGION=8M
//STEPLIB  DD DISP=SHR,DSN=SYS1.SASMMOD2       <- IBM HLASM TOOLKIT
//SYSEXEC  DD DISP=SHR,DSN=IBMUSER.DAVE.EXEC
//SYSUDUMP DD SYSOUT=*
//*
//FLATIN   DD DISP=(OLD,PASS),DSN=&&FLATOUT
//SYSPUNCH DD DSN=&&SYSPUNCH,
//            DISP=(,PASS),UNIT=SYSDA,
//            SPACE=(CYL,(100,100))
//SYSPRINT DD DSN=&&SYSPRINT,
//            DISP=(,PASS),UNIT=SYSDA,
//            SPACE=(CYL,(100,100))
//SYSIN    DD DSN=&&SYSIN,
//            DISP=(,PASS),UNIT=SYSDA,
//            DCB=(LRECL=80,BLKSIZE=80,RECFM=F),
//            SPACE=(TRK,(1,1))
//*
//SYSTSPRT DD SYSOUT=*
//SYSTSIN  DD *
%DA$PDSRR DISASMT=HLASMT AI=SVC___13_  ECHO
//
DELETE SPFTEMP1.FLATOUT
//*
//** INVOKE THE DA$PDSRR REXX EXEC TO REPORT ON THE FLATOUT FILE
//** USES THE CBT TAPE, FILE 171 DISASSEMBLER
//*
//RPTDISC EXEC PGM=IKJEFT01,TIME=1439,DYNAMNBR=100,REGION=8M,COND=EVEN
//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DAVE.LOAD    <- CBT 171 DISASSEMBLER
//SYSEXEC  DD DISP=SHR,DSN=IBMUSER.DAVE.EXEC
//*
//FLATIN   DD DISP=(OLD,PASS),DSN=&&FLATOUT
//* ------------------------------------------------------------------*
//*        ASSEMBLER DD'S                                             *
//* ------------------------------------------------------------------*
//SYSPRINT DD DSN=&&PRT,DISP=(NEW,PASS),
//            UNIT=SYSDA,
//            SPACE=(TRK,(15,15)),
//            DCB=(RECFM=FBM,LRECL=121,BLKSIZE=12100)
//SYSIN    DD DSN=&&IN,DISP=(NEW,PASS),
//            UNIT=SYSDA,
//            SPACE=(TRK,(15,15)),
//            DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120)
//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR
//         DD DSN=SYS1.MODGEN,DISP=SHR
//SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,(1,1))
//SYSPUNCH DD DUMMY
//* ------------------------------------------------------------------*
//*        DIS-ASSEMBLER DD'S                                         *
//* ------------------------------------------------------------------*
//DISPUNCH DD DUMMY
//DISPRINT DD DSN=&&DISPRINT,
//            DISP=(,PASS),UNIT=SYSDA,
//            SPACE=(CYL,(100,100))
//DISIN    DD DSN=&&DISIN,
//            DISP=(,PASS),UNIT=SYSDA,
//            DCB=(LRECL=80,BLKSIZE=80,RECFM=F),
//            SPACE=(TRK,(1,1))
//* ------------------------------------------------------------------*
//*        TSO DD'S                                                   *
//* ------------------------------------------------------------------*
//SYSTSPRT DD SYSOUT=*
//SYSTSIN  DD *
%DA$PDSRR DISASMT=CBT171 AI=SVC___48_ AI=SVC___64_  AI=SVC___56_ ECHO
//
%DA$PDSRR DISASMT=CBT171 AI=SVC____11_ AI=STCK

//*
//** SAVE FLATOUT FILE SO CAN BROWSE OUTPUT
//*
//GENFLAT  EXEC PGM=IEBGENER
//SYSPRINT DD SYSOUT=*
//SYSIN    DD DUMMY
//SYSUT1   DD DISP=(OLD,PASS),DSN=&&FLATOUT
//SYSUT2   DD DSN=IBMUSER.SPFTEMP1.FLATOUT,
//            DISP=(,CATLG),UNIT=SYSDA,
//            DCB=(LRECL=32756,BLKSIZE=32760,RECFM=VB),
//            SPACE=(CYL,(5,5))
//
./ ADD NAME=X$SPF2D  0100-01266-01266-1821-00059-00059-00000-DAVE
- JOB CARD HERE -
//*********************************************************************
//***                                                               ***
//**  This job reads a sample ISPF screen and creates an assembler   **
//**  program to display it using 3270 data stream on TSO.           **
//***                                                               ***
//*********************************************************************
//*
//** Convert the input ISPF screen to 3270 datastream
//*
//SPF2DS   EXEC PGM=DA$SPF2D
//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD
//SYSPRINT DD SYSOUT=*
//SYSUDUMP DD SYSOUT=*
//*
//SYSUT1   DD *
)attr
 /* Sample prototype screen - used in ISPF 7.2 */
)body
+xxIPADDR       +        %Company Name here     +                  +TCP/IP v3.1

     +Production         +Test                      +Misc
+P1 -%CICS(DCC/WTU) +T1 -%CICS (DCC/WTU)    +PROFS -%OfficeVision
+P2 -%CICS(CPL)     +T2 -%CICS (CPL)        +IP    -%Infopac
+P3 -%CICS(PSO/TOK) +T3 -%CICS (PSO/TOK)    +TPX   -%Mult-Session Manager
+P4 -%CICS(SWEPCO)  +T4 -%CICS (SWEPCO)
+P5 -%IDMS-CV11
+P6 -%ROSCOE                 +WARNING:%The access to and use of this computer,
+P7 -%TSO                             %its data and its programs are restricted
                                      %by a security system.  Any unauthorized
                                      %access may be a violation of law and
+Enter Application keyword:           %could result in CRIMINAL PROSECUTION.
_Input                                                                         +
)init
)proc
)end
//SYSUT2   DD DSN=IBMUSER.SPFTEMP1.#3270DS,
//            DISP=(,CATLG),UNIT=SYSTS,
//            DCB=(LRECL=80,BLKSIZE=6320,RECFM=FB),
//            SPACE=(CYL,(5,0),RLSE)
//*
//** ASSEMBLE AND LINK THE NEWLY CREATED 3270 DATASTREAM SOURCE
//*
//DA$PDSR EXEC HLASMCL
//C.SYSLIB DD
//         DD DISP=SHR,DSN=SYS1.MODGEN
//         DD DISP=SHR,DSN=IBMUSER.DA.SOURCE
//C.SYSIN  DD DISP=SHR,DSN=IBMUSER.SPFTEMP1.#3270DS
//L.SYSLMOD DD DISP=SHR,DSN=IBMUSER.DA.LOAD(#3270DS)
//*
//** Now to view on TSO: CALL 'IBMUSER.DA.LOAD(#3270DS)'
//** Now to view on TSO: CALL 'IBMUSER.DA.LOAD(#3270DS)'
//** Now to view on TSO: CALL 'IBMUSER.DA.LOAD(#3270DS)'
//** Now to view on TSO: CALL 'IBMUSER.DA.LOAD(#3270DS)'
//** Now to view on TSO: CALL 'IBMUSER.DA.LOAD(#3270DS)'
//** Now to view on TSO: CALL 'IBMUSER.DA.LOAD(#3270DS)'
//** Now to view on TSO: CALL 'IBMUSER.DA.LOAD(#3270DS)'
//** Now to view on TSO: CALL 'IBMUSER.DA.LOAD(#3270DS)'
//*
./ ADD NAME=X$W4TCP  0100-01266-01266-1821-00007-00007-00000-DAVE
//*
//** Wait for the "TCPIP" stack to come active
//**
//** Change "TCPIP" to the name of your TCP/IP stack
//*
//WAIT4TCP EXEC PGM=DA$W4TCP,PARM='TCPIP'
//SYSUDUMP DD SYSOUT=*
./ ADD NAME=Z$DISKR  0100-01266-01266-1821-00032-00032-00000-DAVE
> CLC   DS1LSTAR,=X'000000'    /* Are all 3-bytes Nulls?     */
> BE    NOADDONE               /* Empty File                 */
> ICM   R15,B'0011',DS1LSTAR   /* ICM non-alignd hword (TT)  */
> CLI   DS1LSTAR+2,X'00'       /* Round up by one?     (R)   */
> BE    NOADDONE               /* No                         */
> A     R15,FWD1               /* Add 1 to "# of Trks"       */
> NOADDONE DS    0H                     /* -------------------------- */
> CVD   R15,DWORD              /* Pack it                    */

Subject:  Re: Space Used
From:  Bruce Black <bblack@FDRINNOVATION.COM>
Date:  Tue, 24 Jul 2001 15:12:46 -0400

Jim Moore wrote:

> CLC   DS1LSTAR,=X'000000'    /* Are all 3-bytes Nulls?     */
> BE    NOADDONE               /* Empty File                 */
> ICM   R15,B'0011',DS1LSTAR   /* ICM non-alignd hword (TT)  */
> CLI   DS1LSTAR+2,X'00'       /* Round up by one?     (R)   */
> BE    NOADDONE               /* No                         */
> A     R15,FWD1               /* Add 1 to "# of Trks"       */

Warning!  If you have SMS-managed volumes, you might have
DSORG=PSE (sequential extended format) datasets which can exceed
64K tracks.  if the extended format flag is on (DS1STRP in
DS1SMSFG), then DS1TRBAL becomes an additional TT value.  You
have to prefix DS1TRBAL onto DS1LSTAR to get a TTTTR value, so
that TTTT can exceed 64K.

Although other dataset types (VSAM, PDSE and HFS) can exceed 64K
tracks, even on non-SMS volumes, DS1LSTAR and DS1TRBAL are not
maintained for them.
./ ENDUP       "REVIEW" PDS MEMBER OFFLOAD AT 18:16 ON 02/11/02
