./ ADD NAME=$$README 0100-98016-98016-1800-00022-00022-00000-DALCOCK
 The contents of this file are FREEWARE. Use at your own risk. It
 is provided for your enjoyment and neither David Alcock or his
 employer provides any warranty for their use.  I'd like to hear how
 they work on your system:

    David Alcock :: dave@planetmvs.com

    http://www.planetmvs.com/

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

 This is collection of my SMF exits. I have attempted to remove all
 the installation code and have changed our company prefix for messages
 and such to "XYZ".  Please run on your test machine first.  It is quite
 possible that during my edit I could have deleted something useful.

 See the $SAMPLE member for a sample of the "flower boxes" created
 by my IEFACTRT routine.  I am strange one that likes to collect
 other peoples IEFACTRT "flower boxes" and have created mine based on
 what I have liked on others I've seen.
./ ADD NAME=$SAMPLE  0100-98016-98016-1800-00068-00068-00000-DALCOCK
XYZ120I ------------------------------------------------------------------------
                       S t e p   E n d   S t a t i s t i c s

Step Name: PHONE2W        Cond Code: S322         Start: 14-Jan-1998 10:12:02 AM
Step  Num: 13             PGM  Name: IKJEFT01     End:   14-Jan-1998 10:40:37 AM
CPU (TCB): 00:15:00.98                            Storage below 16M:        264k
CPU (SRB): 00:00:00.03                            Storage above 16M:      4,356k
Trans Act: 00:28:34.59                            Service Units:      33,376,337
Tape Mnts: 0                                      Total EXCPs:               532

Unit-- DDName-- EXCP Count-- Blksize        Unit-- DDName-- EXCP Count-- Blksize
0E24 D SYSEXEC             3  25,504        046A D SYU1802            59  32,600
0EE2 D SYI1723            89   6,320        0EEC D OUT               162  25,550

Total DASD EXCPs:                313        Total Tape EXCPs:                  0

---------------Paging---------------        ---------------Paging---------------
Pages In:                      1,271        Pages Out:                         0
VIO Reclaims:                      0        Pages Stolen:                  5,604

XYZ121I ------------------------------------------------------------------------
XYZ111I-------------------------Start of ABEND information from MVS/Quickref

   System ABEND: S322

   Description:  This ABEND occurred because execution of a job, job step,
                 or cataloged procedure step took more CPU time than was
                 specified in the TIME parameter of an EXEC or JOB
                 statement or the defaulted time set by the JES2 or JES3
                 system.

   User Action:  Correct the looping condition that caused excessive CPU
                 time to be consumed.  If you think no loop exists,
                 increase the CPU time limit value via the TIME= parameter
                 and rerun the job.

XYZ112I---------------------------End of ABEND information from MVS/Quickref
IEF373I STEP /PHONE2W / START 1998014.1012
IEF374I STEP/PHONE2W /STOP  1998014.1040 CPU   15MIN 00.98SEC SRB    0MIN 00.03S
IEF272I ibmuser$ PHONE2D - STEP WAS NOT EXECUTED.
IEF373I STEP /PHONE2D / START 1998014.1040
IEF374I STEP/PHONE2D /STOP  1998014.1040 CPU    0MIN 00.00SEC SRB    0MIN 00.00S
IEF272I ibmuser$ PHONE2C - STEP WAS NOT EXECUTED.
IEF373I STEP /PHONE2C / START 1998014.1040
IEF374I STEP/PHONE2C /STOP  1998014.1040 CPU    0MIN 00.00SEC SRB    0MIN 00.00S
XYZ120I ------------------------------------------------------------------------
                        J o b   E n d   S t a t i s t i c s

Job  Name: ibmuser$       System ID: XYZ1        Submit: 14-Jan-1998 09:30:01 AM
Job JESID: JOB03057       MVS level: SP6.0.2     Start:  14-Jan-1998 10:00:15 AM
Job Class: Q                                     End:    14-Jan-1998 10:40:38 AM
CPU (TCB): 00:15:42.97                           Storage below 16M:       1,588k
CPU (SRB): 00:00:02.57                           Storage above 16M:      12,160k
Trans Act: 00:40:11.85                           Service Units:       35,086,709
Tape Mnts: 2                                     Total EXCPs:             40,051

---------------Paging---------------        ---------------Paging---------------
VIO In:                            0        VIO Out:                           0
Pages In:                      1,271        Pages Out:                     1,271
Common (LPA+CSA):                  2        Hiperspace:                        0
VIO Reclaims:                      0        Pages Stolen:                  8,069

ACF2 User: ibmuser                          Programmer: ALCOCK, DAVID
Acct Info: D,D,D,SYS

XYZ122I ------------------------------------------------------------------------
IEF375I  JOB /ibmuser$/ START 1998014.1000
IEF376I  JOB/ibmuser$/STOP  1998014.1040 CPU   15MIN 42.97SEC SRB    0MIN 02.57S
./ ADD NAME=IEFACTRT 0100-98016-98016-1800-02463-02463-00000-DALCOCK
** Needs ESTAEX !!!!!!
IEFACTRT TITLE 'XYZ - Job/Step Termination SMF exit'
***********************************************************************
***                                                                 ***
** Name = IEFACTRT                                                   **
**                                                                   **
** Author = David Alcock :: dave@planetmvs.com                       **
**                                                                   **
** Purpose = SMF step and job termination exit.                      **
**                                                                   **
**           This is an installation IEFACTRT that get invoked       **
**           by SMF at step and job termination, it:                 **
**           - Print step condition codes on the MVS console for     **
**             operations.                                           **
**           - Print TSO session information at logoff time          **
**           - Print step and Job end statistics on the JES2 SYSMSGS **
**             dataset - known as "flower boxes".                    **
**           - Invoke MVS/Quickref to print system ABEND information **
**             on the JES2 SYSMSGS dataset.  We will bypass QUICKREF **
**             if a "//ABNLIGNR DD DUMMY" is found.                  **
**                                                                   **
**           Although invoked for other SMF record types, this exit  **
**           only reacts to SMF 30 records.                          **
**                                                                   **
**  Reference:                                                       **
**  - MVS v2  = GC28-1153 MVS/XA SPL System Management Facilities    **
**  - MVS v4  = GC28-1637 MVS/ESA Installation Exits                 **
**              GC28-1628 MVS/ESA System Management Facilities       **
**                                                                   **
**  Note = IBM states to tell IEFYS the SMB line address and length  **
**         via this code:                                            **
**                                                                   **
**           MVC   36(4,12),MSGADDR  MOVE MESSAGE ADDRESS AND        **
**           MVC   42(2,12),MSGLEN   LENGTH TO SYSTEM TABLE          **
**                                                                   **
**         This exit uses the actual DSECT to put the message address**
**         and length into the LCT control block fields:             **
**                                                                   **
**                 LCTPARM1   DS A(0) - instead of 36(4,R12)         **
**                 LCTPARM2+2 DS XL2  - instead of 42(2,R12)         **
***                                                                 ***
***********************************************************************
         SPACE 2
***********************************************************************
***                                                                 ***
**           M o d i f i c a t i o n   H i s t o r y                 **
**                                                                   **
** Person     Date        Description                                **
** ---------- ----------- ------------------------------------------ **
** DGAlcock   13-JAN-1998 Use 4 digit year for TSO logon/logoff info **
**                        lines; Check for MVS/Quickref version;     **
** DGAlcock   28-FEB-1997 Add check for //ABNLIGNR DD DUMMY and      **
**                        bypass MVS/QUICKREF if found;              **
** DGAlcock   30-JAN-1997 Added step and job end statistics - known  **
**                        as "flower boxes".                         **
** DGAlcock   23-APR-1996 Print MVS/Quickref information for system  **
**                        ABENDs on the SYSMSGS JES datasets;        **
** DGAlcock   11-FEB-1996 MVS 4.3 upgrade and reassemble;            **
** DGAlcock   17-SEP-1994 Don't print WTO for continuation records;  **
**                        Change debugging TSO message by proc;      **
** DGAlcock   01-SEP-1994 Added Novell-like login/logout messages at **
**                        TSO logoff;                                **
** DGAlcock   01-MAR-1994 Corrected SWAPS text length; Added debug   **
**                        message XYZ109I; Added HiperSpace, LPA and **
**                        VIO paging counts at TSO logoff time;      **
** DGAlcock   20-MAY-1992 Added XYZ106I and XYZ107I to show step and **
**                        job end messages on the operator console;  **
** DGAlcock   08-APR-1992 Created this new version of IEFACTRT to    **
**                        support Komand and the largely unmodified  **
**                        IBM supplied version of IEFACTRT;          **
***                                                                 ***
***********************************************************************
         EJECT
***********************************************************************
***                                                                 ***
**       IBM DSECTs                                                  **
***                                                                 ***
***********************************************************************
         SPACE 2
         PRINT NOGEN
LCTD     DSECT ,
         IEFALLCT                         Linkage Control Table
SMSCT    DSECT ,
         IEFASCTB ,                       Step Control Table
         IEZWPL ,                         WTO Parameter List
         IEFJMR ,                         Job management record
         IEFUCBOB LIST=YES                Unit Control block
         CVT    DSECT=YES,LIST=NO         Communications Vector Table
         PRINT GEN
         IFASMFR (30)                     SMF 30 record mapping
*
** Using the official ASMH/HLASM distinction trick, simulate the
** SYSVER and SYSDATEC variables of HLASM when assembled under
** ASMH...Taken from Gilbert Saint-flour's SHOWMVS.
*
         LCLA  &ASMH_HLASM
         AIF   (T'&ASMH_HLASM EQ 'N').ASMH1X
&SYSVER  SETC  'ASMH'
&SYSDATC SETC  '20'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)
         AIF   ('&SYSDATC' LT '20500000').ASMH1X
&SYSDATC SETC  '19'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)
.ASMH1X  ANOP
*-Convert assembly date from SYSDATC format "YYYYMMDD" to "YYYY-MM-DD"
         LCLC  &ASMDATE
&ASMDATE SETC  '&SYSDATC'(1,4).'-'.'&SYSDATC'(5,2).'-'.'&SYSDATC'(7,2)
         EJECT
***********************************************************************
***                                                                 ***
**       Entry housekeeping                                          **
***                                                                 ***
***********************************************************************
         SPACE 2
*
** Save registers and establish base registers
*
IEFACTRT CSECT ,
IEFACTRT AMODE 31
IEFACTRT RMODE ANY
         SAVE  (14,12),,XYZ_SMFEXIT_IEFACTRT_&ASMDATE._&SYSTIME
         LR    R11,R15                  Load program base register
         LA    R10,4095                 Get 4096-1
         LA    R10,1(R10,R11)           Addressability: 2nd base reg
         LA    R9,4095                  Get 4096-1
         LA    R9,1(R9,R10)             Addressability: 2nd base reg
         USING IEFACTRT,R11,R10,R9      Establish base for program
         USING LCTD,R12                 Establish LCT base
*
** Determine address space type and leave if we don't need this type
*
         L     R8,@ACTRT_SUBS-@ACTRT(R1)  Locate subsystem type
         CLC   0(4,R8),=C'ASCH'           APPC?
         BE    X$QUICKOUT
         CLC   0(3,R8),=C'SYS'            System Address Space?
         BE    X$QUICKOUT
*
** Determine if the reason we are called is worth pursuing:
** - Must be for SMF 30 record (not other types)
** - Leave for continuation records which we don't care about
** - Ensure that IBM is giving us a subsystem section
** - Leave if the subtype isn't 4 (Step Term) or 5 (Job Term)
** - If a subtype 4 (step termination) then leave if TSO user
*
         L     R8,@ACTRT_SMFREC-@ACTRT(R1) Locate SMF record
         CLI   SMF30RTY-SMF30RPS(R8),30 Combined end?
         BNE   X$QUICKOUT               No, Continue
*
         SLR   R14,R14                  Clear register for ICM
         ICM   R14,B'0011',SMF30UON-SMF30RPS(R8) Continuation record?
         BZ    X$QUICKOUT               Yes, don't process this record
*
         ICM   R14,B'0011',SMF30SON-SMF30RPS(R8) Num: Subsystem sects
         BZ    X$QUICKOUT               Zero, Ignore record
         ICM   R14,B'0011',SMF30SLN-SMF30RPS(R8) Len: SubSystem
         BZ    X$QUICKOUT               Zero, Ignore record
         ICM   R14,B'1111',SMF30SOF-SMF30RPS(R8) Offset: SubSystem
         BZ    X$QUICKOUT               Zero, Ignore record
         AR    R14,R8                   Locate Subsystem section
*
         CLC   SMF30TYP-SMF30PSS(2,R14),=AL2(4) Step Termination?
         BNE   I$STEPX                  No, continue
         L     R14,@ACTRT_JMR-@ACTRT(R1) Locate JMR
         TM    JMRINDC-JMR(R14),JMRFIND TSO User (Foreground)?
         BO    X$QUICKOUT               Yes, Leave
         B     I$JOBX                   Continue (good record)
I$STEPX  DS    0H
         CLC   SMF30TYP-SMF30PSS(2,R14),=AL2(5) Job Termination?
         BNE   X$QUICKOUT               No, leave
I$JOBX   DS    0H
*-At this point we have a SMF 30 record of subtype 4 or 5
*
         LR    R2,R0                    Save entry code
         LR    R3,R1                    Save input parm list address
*
** Obtain Dynamic Storage Area (work area for IEFACTRT)
*
         L     R0,=A(DSAL)              Get length of area
       GETMAIN RU,                      Obtain storage                 @
               LV=(0),                  ..Length of area               @
               SP=$DSA_SP,              ..Low private                  @
               LOC=BELOW                ..Must be below the line
*
         XC    DSA_IS-DSA(DSA_IL,R1),DSA_IS-DSA(R1) Init to zeros
*
** Perform Forward/Backward RSA (Register Save Area) chaining
*
         ST    R13,4(,R1)               Save caller's RSA pointer
         ST    R1,8(,R13)               Save our RSA pointer
         LR    R13,R1                   Locate DSA/our RSA
*
         USING DSA,R13                  Establish addressability
         MVC   DSAEC(16),=C'IEFACTRTWORKAREA' Eyecatcher for dumps
         ST    R0,DSAGLEN               Save length of GETMAIN'd area
         STM   R2,R3,IREGS              Save input registers R0 and R1
*
** Obtain fields needed by all SMF30 routines
*
         BAS   R14,R30CPU               Get CPU: T_TCB and T_SRB
*-Locate ID section in the SMF30 record (if any)
         SLR   R1,R1                    Clear for ICM
         ICM   R1,B'0011',SMF30ILN-SMF30RPS(R8) Get length
         BZ    I$IDX                    None, don't have it
         ICM   R1,B'0011',SMF30ION-SMF30RPS(R8) Number of ID sections
         BZ    I$IDX                    None, don't have any
         ICM   R15,B'1111',SMF30IOF-SMF30RPS(R8) Get offset to ID sect
         BZ    I$IDX                    No offset = no ID section
         AR    R15,R8                   Locate section
         ST    R15,A_IDSECT             Save address of ID section
I$IDX    DS    0H
*-Locate Storage section in the SMF30 record (if there)
         SLR   R1,R1
         ICM   R1,B'0011',SMF30RLN-SMF30RPS(R8) Length of section
         BZ    I$STX                    Zero, Ignore it
         ICM   R1,B'0011',SMF30RON-SMF30RPS(R8) Number of sections
         BZ    I$STX                    Zero, Ignore it
         ICM   R15,B'1111',SMF30ROF-SMF30RPS(R8) Offset
         BZ    I$STX
         AR    R15,R8                   Locate section
         ST    R15,A_STSECT             Save address of Storage sect
I$STX    DS    0H
*-Locate Performance section in the SMF30 record (if there)
         SLR   R1,R1
         ICM   R1,B'0011',SMF30PLN-SMF30RPS(R8) Length of section
         BZ    I$PERFX                  Zero, Ignore it
         ICM   R1,B'0011',SMF30PON-SMF30RPS(R8) Number of sections
         BZ    I$PERFX                  Zero, Ignore it
         ICM   R15,B'1111',SMF30POF-SMF30RPS(R8) Offset
         BZ    I$PERFX
         AR    R15,R8                   Locate section
         ST    R15,A_PRSECT             Save address of Storage sect
I$PERFX  DS    0H
*
** Set the message area and length for the remainder of the step code
** (except the MVS/Quickref code - but we exit after it)
*
         LA    R15,WLINE                Locate message area
         ST    R15,LCTPARM1-LCTD(,R12)  Save msg location into LCT
         LA    R15,80                   Get msg length
         STH   R15,LCTPARM2+2-LCTD(,R12) Save msg length
*
** Process according to input SMF record type
*
         ICM   R14,B'1111',SMF30SOF-SMF30RPS(R8) Offset: SubSystem sect
         AR    R14,R8                   Locate subsystem section
         CLC   SMF30TYP-SMF30PSS(2,R14),=AL2(4) Step Termination?
         BE    R30STEP                  Yes, continue
         CLC   SMF30TYP-SMF30PSS(2,R14),=AL2(5) Job Termination?
         BE    R30JOB                   Yes, continue
         SPACE 2
         EJECT
***********************************************************************
***                                                                 ***
**       Common exit from IEFACTRT                                   **
***                                                                 ***
***********************************************************************
         SPACE 2
EXIT     DS    0H
         L     R0,DSAGLEN               Get DSA length
         LR    R1,R13                   Get DSA address
         L     R13,4(,R1)               Load caller's RSA address
*
** Free GETMAINed work area
*
     FREEMAIN  RU,                      Free the storage               @
               LV=(0),                  ..Length                       @
               A=(1),                   ..Address                      @
               SP=$DSA_SP               ..Subpool
*
** Return to caller
*
X$QUICKOUT DS  0H
         LM    R14,R12,12(R13)          Load caller's registers
         SLR   R15,R15                  Set return code - no cancel
         SLR   R1,R1                    Write the dang record
         BSM   0,R14                    Return to caller
         EJECT
***********************************************************************
***                                                                 ***
**       SMF 30 - Step Termination - non-TSO code                    **
***                                                                 ***
***********************************************************************
         SPACE 2
R30STEP  EQU   *
         BAS   R14,FORMAT_COND_CODE     Format the Condition code
         CLC   FCC_CDE(5),=C'FLUSH'     Step executed?
         BE    EXIT                     No, continue
*
         BAS   R14,IGNORE_JOB           Ignore this job?
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Step End Statistics
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
R30_STEP_END_STATS DS 0H
         ICM   R15,B'1111',=V(IEFYS)    Have the IBM SMB routine?
         BZ    EXIT                     No, give up
*
** Print heading lines
*
         MVC   WLINE(MSG120L),MSG120    Get message
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write SMB line out
*-"S t e p   E n d   S t a t i s t i c s"
         MVI   WLINE,C' '               Get blank
         MVC   WLINE+1(79),WLINE        ..propagate it
         MVC   WLINE+23(C_ENDSTSL),C_ENDSTS Move in "step end stat"
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write SMB line out
*-Blank line
         MVI   WLINE,C' '               Get blank
         MVC   WLINE+1(79),WLINE        ..propagate it
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write SMB line out
*
** Data line 1
*
         MVC   WLINE_SESIC1D(10),=C'Step Name:'
         L     R1,IR_PARML              Get IEFACTRT parm list
         L     R1,@ACTRT_STEPNAME-@ACTRT(R1) Locate step name
         MVC   WLINE_SESIC1V(8),0(R1)    Get step name
*
         MVC   WLINE_SESIC2D(10),=C'Cond Code:'
         MVC   WLINE_SESIC2V(5),FCC_CDE    Get condition code
*
         ICM   R14,B'1111',A_IDSECT     Locate ID section
         BZ    R30SES$STODX             None?
         MVC   WLINE_SESIC3DT(6),=C'Start:'
         LA    R15,WLINE_SESIC3VT
         ICM   R0,B'1111',SMF30SIT-SMF30ID(R14) <- Time
         ICM   R1,B'1111',SMF30STD-SMF30ID(R14) <- Date
         BAS   R14,CONVERT_TO_TODSTRING Convert the time and date
R30SES$STODX DS 0H
*
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write SMB line out
         MVI   WLINE,C' '               Get blank
         MVC   WLINE+1(79),WLINE        ..propagate it
*
** Data line 2
*
         ICM   R14,B'1111',A_IDSECT     Locate ID section
         BZ    R30SES$SNX               None?
         MVC   WLINE_SESIC1D(10),=C'Step  Num:'
         LA    R15,WLINE_SESIC1V        Locate to output area
         SLR   R1,R1                    Clear register for ICM
         ICM   R1,B'0011',SMF30STN-SMF30ID(R14) Get the step number
         BAS   R14,EDITFWF              Edit the step number
         LA    R15,WLINE
R30SES$SNX DS  0H
*
         ICM   R14,B'1111',A_IDSECT     Locate ID section
         BZ    R30SES$PNX               None?
         MVC   WLINE_SESIC2D(10),=C'PGM  Name:'
         MVC   WLINE_SESIC2V(8),SMF30PGM-SMF30ID(R14)
R30SES$PNX DS  0H
*
         TIME  BIN                      Don't trust SMF record yet
         MVC   WLINE_SESIC3DT(4),=C'End:'
         LA    R15,WLINE_SESIC3VT
         BAS   R14,CONVERT_TO_TODSTRING Convert the time and date
*
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write SMB line out
         MVI   WLINE,C' '               Get blank
         MVC   WLINE+1(79),WLINE        ..propagate it
*
** Data line 3
*
         LA    R15,WLINE_SESIC1V-2      Location for "  hh:mm:ss.th"
         L     R1,T_TCB                 Get CPU time to edit
         BAS   R14,FORMAT_CPUTIME       Format CPU time
         MVC   WLINE_SESIC1D(10),=C'CPU (TCB):'
*
         ICM   R4,B'1111',A_STSECT      Get storage section
         BZ    R30SES$SBX               None, continue
         L     R1,SMF30URB-SMF30SAP(R4) Get Storage below 16M
         SRL   R1,10                    Get by 1024
         CVD   R1,DOUBLE                Convert to packed
         MVC   WLINE_SESIC3VS-1(12),EDPAT12 Get edit mask
         ED    WLINE_SESIC3VS-1(12),DOUBLE+3 Edit storage
         MVC   WLINE_SESIC3DST(18),=C'Storage below 16M:'
         MVI   WLINE_SESIC3VSK,C'k'
R30SES$SBX DS 0H
*
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write SMB line out
         MVI   WLINE,C' '               Get blank
         MVC   WLINE+1(79),WLINE        ..propagate it
*
** Data line 4
*
         LA    R15,WLINE_SESIC1V-2      Location for "  hh:mm:ss.th"
         L     R1,T_SRB                 Get CPU time to edit
         BAS   R14,FORMAT_CPUTIME       Format CPU time
         MVC   WLINE_SESIC1D(10),=C'CPU (SRB):'
*
         ICM   R4,B'1111',A_STSECT      Get storage section
         BZ    R30SES$SAX               None, continue
         L     R1,SMF30EUR-SMF30SAP(R4) Get storage above 16M
         SRL   R1,10                    Get by 1024
         CVD   R1,DOUBLE                Convert to packed
         MVC   WLINE_SESIC3VS-1(12),EDPAT12 Get edit pattern
         ED    WLINE_SESIC3VS-1(12),DOUBLE+3 Edit it
         MVC   WLINE_SESIC3DST(18),=C'Storage above 16M:'
         MVI   WLINE_SESIC3VSK,C'k'
R30SES$SAX DS 0H
*
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write SMB line out
         MVI   WLINE,C' '               Get blank
         MVC   WLINE+1(79),WLINE        ..propagate it
*
** Data line 5
*
         ICM   R4,B'1111',A_PRSECT      Have a performance section?
         BZ    R30SES$DL5X              No, continue
*
         SLR   R0,R0
         ICM   R1,B'1111',SMF30TAT-SMF30PRF(R4)  Get trans active
         SLDL  R0,10
         BAS   R14,CONVERT_MICRO_SECONDS Convert micro seconds
*                                          h h : m m : s s . t h
*                                      0 1 2 3 4 5 6 7 8 9 0 1 2
         MVC   WLINE_SESIC1V-2(13),=X'402120207A20207A20204B2020'
         ED    WLINE_SESIC1V-2(13),DOUBLE+1
         MVC   WLINE_SESIC1D(10),=C'Trans Act:'
*
         L     R1,SMF30SRV-SMF30PRF(R4) Get service units
         CVD   R1,DOUBLE                Convert to packed
         MVC   WLINE_SESIC3VS(12),EDPAT12
         ED    WLINE_SESIC3VS(12),DOUBLE+3
         MVC   WLINE_SESIC3DST(14),=C'Service Units:'
*
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write SMB line out
         MVI   WLINE,C' '               Get blank
         MVC   WLINE+1(79),WLINE        ..propagate it
R30SES$DL5X DS 0H
*
** Data line 6
*
         LA    R1,0                     Default number of tape mounts
         L     R7,IR_PARML              Get IEFACTRT parm list
         L     R7,@ACTRT_SMFREC-@ACTRT(R7) Locate SMF record
         SLR   R2,R2                    Clear register for ICM
         ICM   R2,B'0011',SMF30OLN-SMF30RPS(R7) Length of section
         BZ    R30SES$OPX               Zero, Ignore it
         ICM   R2,B'0011',SMF30OON-SMF30RPS(R7) Number of sections
         BZ    R30SES$OPX               Zero, Ignore it
         ICM   R4,B'1111',SMF30OOF-SMF30RPS(R7) Get offset to I/O sect
         BZ    R30SES$OPX               Zero, Ignore it
         AR    R4,R7                    Locate operator section
         L     R1,SMF30PTM-SMF30OPS(R4) Get Non-specific tape mounts
         A     R1,SMF30TPR-SMF30OPS(R4) Get specific tape mounts
R30SES$OPX DS 0H
         LR    R2,R1                    Save tape mount total
*
         L     R1,IR_PARML              Get IEFACTRT parm list
         L     R1,@ACTRT_SMFREC-@ACTRT(R1) Locate SMF record
         SLR   R14,R14                  Clear register for ICM
         ICM   R14,B'0011',SMF30ULN-SMF30RPS(R1) Length of section
         BZ    R30SES$EXX               Zero, Ignore it
         ICM   R14,B'0011',SMF30UON-SMF30RPS(R1) Number of sections
         BZ    R30SES$EXX               Zero, Ignore it
         ICM   R4,B'1111',SMF30UOF-SMF30RPS(R1) Get offset to I/O sect
         BZ    R30SES$EXX               Zero, Ignore it
         AR    R4,R1                    Locate it
         L     R1,SMF30TEP-SMF30URA(R4) Obtain EXCP count
R30SES$EXX DS 0H
         LTR   R2,R2                    Tape mounts = 0?
         BNZ   R30SES$DL6P              No, print line
         LTR   R1,R1                    Were the EXCPs also zero?
         BZ    R30SES$DL6X              Yes, skip printing line
R30SES$DL6P DS 0H
         CVD   R1,DOUBLE                Convert to packed
         MVC   WLINE_SESIC3VS(12),EDPAT12
         ED    WLINE_SESIC3VS(12),DOUBLE+3
         MVC   WLINE_SESIC3DST(12),=C'Total EXCPs:'
*
         LR    R1,R2                    Get tape mount total
         LA    R15,WLINE_SESIC1V        Locate output area
         BAS   R14,EDITFWF              Edit number of tape mounts
         MVC   WLINE_SESIC1D(10),=C'Tape Mnts:'
*
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write SMB line out
         MVI   WLINE,C' '               Get blank
         MVC   WLINE+1(79),WLINE        ..propagate it
R30SES$DL6X DS 0H
*
** Print EXCP lines
*
R30SES$EXCP DS  0H
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write blankl line out
*-Locate EXCP Section information (if any)
         L     R1,IR_PARML              Get IEFACTRT parm list
         L     R1,@ACTRT_SMFREC-@ACTRT(R1) Locate SMF record
         SLR   R2,R2                    Clear register
         ICM   R2,B'0011',SMF30ELN-SMF30RPS(R1) Length: EXCP section
         BZ    R30SES$EN                None, continue
*
         ICM   R3,B'1111',SMF30EOF-SMF30RPS(R1) Offset: EXCP section
         BZ    R30SES$EN                None, continue
         AR    R3,R1                    Locate EXCP section
*
         SLR   R6,R6                    Clear register for ICM
         ICM   R6,B'0011',SMF30EON-SMF30RPS(R1) Number of EXCP sect.
         BZ    R30SES$EN                None, continue
*-DD NAME LINE LOOP
R30SES$ES DS   0H
         MVI   WLINE,C' '               Get blank
         MVC   WLINE+1(79),WLINE        ..Propagate it
         LA    R15,WLINE                Locate for first EXCP output
         LA    R7,2                     Num of output entries on line
R30SES$EL DS   0H
         ICM   R1,B'1111',SMF30BLK-SMF30EXP(R3) Get EXCP count
         BZ    R30SES$EZ                Oops, none...
*
         TM    FLAG1,$F1_EXCP           First time thru?
         BO    R30SES$ETX               No, continue
         OI    FLAG1,$F1_EXCP           Say that we've been thru here
         ST    R15,PARMLIST             Save output location
#SES$EC2 EQU   (80/2)+((80-(EOEL*2))/2)
         MVC   WLINE(EOEL),C_EXCPT      Get title for first column
         MVC   WLINE+#SES$EC2(EOEL),C_EXCPT Get title for second column
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write SMB line out
         MVI   WLINE,C' '               Get blank
         MVC   WLINE+1(79),WLINE        ..propagate it
         L     R15,PARMLIST             Reload output location
         ICM   R1,B'1111',SMF30BLK-SMF30EXP(R3) Restore EXCP count
R30SES$ETX DS 0H
*
         CLI   SMF30DEV-SMF30EXP(R3),0  Non-Device type I/O?
         BE    R30SES$EC                Yes, don't do UCB edit
         UNPK  EOE_UNIT-EOE(5,R15),SMF30CUA-SMF30EXP(3,R3)
         MVZ   EOE_UNIT-EOE(4,R15),=X'00,00,00,00'
         TR    EOE_UNIT-EOE(4,R15),=C'0123456789ABCDEF'
         MVI   EOE_UNIT+4-EOE(R15),C' ' Fix byte after UNPK/MVZ/TR
         B     R30SES$ECX               Continue
R30SES$EZ DS   0H
         LA    R7,1(R7)                 We didn't do anything: fix cnt
*-Use the ABENDAID DDNAME to check to turn off Quickref as well. This
*-ASSUMES that there was no I/O to //ABNLIGNR which should be DUMMY.
         CLI   SMF30DDN-SMF30EXP(R3),C'A' Does the DDNAME start with A
         BNE   R30SES$ELB               No, continue
         CLC   SMF30DDN-SMF30EXP(8,R3),=C'ABNLIGNR' Turn ABENDAID off
         BNE   R30SES$ELB               No, continue
         OI    FLAG1,$F1_NQW            Yes, turn off Quickref
         B     R30SES$ELB               Continue
R30SES$EC DS   0H
         CLC   SMF30CUA-SMF30EXP(2,R3),=X'7F,FF' VIO?
         BE    R30SES$ECV               Yes, do it
R30SES$ECJ DS  0H
         MVC   EOE_UNIT-EOE(3,R15),=C'JES' JES dataset
         B     R30SES$ECX               Continue
R30SES$ECV DS  0H
         MVC   EOE_UNIT-EOE(3,R15),=C'VIO' VIO Dataset
R30SES$ECX DS  0H
         MVC   EOE_DDNAME-EOE(L'SMF30DDN,R15),SMF30DDN-SMF30EXP(R3)
*
         CLI   SMF30DEV-SMF30EXP(R3),UCB3TAPE Tape device?
         BE    R30SES$E_TAPE
         CLI   SMF30DEV-SMF30EXP(R3),UCB3DACC DASD device?
         BNE   R30SES$E_TAPEX
         L     R14,T_DASD               Get current DASD count
         AR    R14,R1                   Add for this DD
         ST    R14,T_DASD               Save new DASD count
         MVI   EOE_TYPE-EOE(R15),C'D'   Set as type: DASD
         B     R30SES$E_TAPEX           Continue
R30SES$E_TAPE DS 0H
         L     R14,T_TAPE               Get current TAPE count
         AR    R14,R1                   Add for this DD
         ST    R14,T_TAPE               Save new TAPE count
         MVI   EOE_TYPE-EOE(R15),C'T'   Set as type: Tape
R30SES$E_TAPEX DS 0H
*
         CVD   R1,DOUBLE                Convert EXCP count to decimal
         MVC   EOE_COUNT-EOE(12,R15),EDPAT12   Get edit pattern
         ED    EOE_COUNT-EOE(12,R15),DOUBLE+3  Edit the count
*
         LH    R1,SMF30BSZ-SMF30EXP(R3) Get block size
         N     R1,=XL4'00007FFF'        zero high order bit
         CVD   R1,DOUBLE                Convert block size to decimal
         MVC   EOE_BLKSIZE-EOE(7,R15),=X'4020206B202120'
         ED    EOE_BLKSIZE-EOE(7,R15),DOUBLE+5
         TM    SMF30BSZ-SMF30EXP(R3),X'80' Changed?
         BNO   R30SES$BZX               No, continue
         MVI   EOE_BLKSIZE+8-EOE(R15),C'*' Mark changed BLKSIZE
R30SES$BZX DS  0H
#SES$ENL EQU   (80-(EOEL*2))
         LA    R15,EOEL+#SES$ENL(R15)
*
R30SES$ELB DS 0H
         LA    R3,0(R2,R3)              Locate next EXCP section
         BCTR  R6,0                     Decrement section count
         LTR   R6,R6                    Get count
         BZ    R30SES$DDPX              Zero: end of sections
         BM    R30SES$DDPX              Minus?: should not happen
         BCT   R7,R30SES$EL             Do next entry
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write SMB line out
         B     R30SES$ES                Continue with next line
*
R30SES$DDPX DS 0H
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write SMB line out
         MVI   WLINE,C' '               Get blank
         MVC   WLINE+1(79),WLINE        ..Propagate it
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write SMB line out
*
         ICM   R1,B'1111',T_DASD        Get total DASD EXCPs
         BNZ   R30SES$ETDTS
         ICM   R0,B'1111',T_TAPE        Get total Tape EXCPs
         BZ    R30SES$ETDTX
R30SES$ETDTS DS 0H
         LA    R15,WLINE                Locate first column start
         MVC   0(17,R15),=C'Total DASD EXCPs:' Get text
         CVD   R1,DOUBLE                Convert to decimal
         LA    R15,EOEL-12(R15)         Locate output for number
         MVC   0(12,R15),EDPAT12        Get edit pattern
         ED    0(12,R15),DOUBLE+3       Edit the count
         LA    R15,WLINE+#SES$EC2       Locate second column start
         MVC   0(17,R15),=C'Total Tape EXCPs:' Get text
         L     R0,T_TAPE                Get tape count
         CVD   R0,DOUBLE                Convert to decimal
         LA    R15,EOEL-12(R15)         Locate output for number
         MVC   0(12,R15),EDPAT12        Get edit pattern
         ED    0(12,R15),DOUBLE+3       Edit count
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write SMB line out
         MVI   WLINE,C' '               Get blank
         MVC   WLINE+1(79),WLINE        ..Propagate it
R30SES$ETDTX DS 0H
*
         TM    FLAG1,$F1_EXCP           Found any EXCPs?
         BO    R30SES$EXCPX
*                           ....+....1....+....2....+...
         MVC   WLINE(25),=C'No I/O activity was found'
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write SMB line out
         MVI   WLINE,C' '               Get blank
         MVC   WLINE+1(79),WLINE        ..Propagate it
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write Blank line
         B     R30SES$EXCPX
*
R30SES$C1VM MVC WLINE_SESIC1V(0),0(R5)
*
*-No I/O activity for this step
R30SES$EN DS   0H           ....+....1....+....2....+...
         MVC   WLINE(28),=C'No device entries were found'
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write SMB line out
         MVI   WLINE,C' '               Get blank
         MVC   WLINE+1(79),WLINE        ..Propagate it
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write Blank line
R30SES$EXCPX DS 0H
*
** Print fields in the Storage section
*
         ICM   R4,B'1111',A_STSECT      Get storage section
         BZ    R30SES$STX               None, continue
*
         ICM   R2,B'1111',SMF30VPI-SMF30SAP(R4) Get VIO ins
         BNZ   R30SES$VIOS
         ICM   R3,B'1111',SMF30VPO-SMF30SAP(R4) Get VIO outs
         BZ    R30SES$VIOX
R30SES$VIOS DS 0H
         BAS   R14,R30SES$STT           Get title line first time
         LA    R15,WLINE                Locate first column start
         MVC   0(7,R15),=C'VIO In:'     Get text
         CVD   R2,DOUBLE                Convert to decimal
         LA    R15,EOEL-12(R15)         Locate output for number
         MVC   0(12,R15),EDPAT12        Get edit pattern
         ED    0(12,R15),DOUBLE+3       Edit the count
         LA    R15,WLINE+#SES$EC2       Locate second column start
         MVC   0(8,R15),=C'VIO Out:'    Get text
         CVD   R3,DOUBLE                Convert to decimal
         LA    R15,EOEL-12(R15)         Locate output for number
         MVC   0(12,R15),EDPAT12        Get edit pattern
         ED    0(12,R15),DOUBLE+3       Edit count
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write SMB line out
         MVI   WLINE,C' '               Get blank
         MVC   WLINE+1(79),WLINE        ..Propagate it
R30SES$VIOX DS 0H
*
         ICM   R2,B'1111',SMF30PSI-SMF30SAP(R4) Get Pages swapped in
         BNZ   R30SES$PAGES
         ICM   R3,B'1111',SMF30PSO-SMF30SAP(R4) Get Pages swapped out
         BZ    R30SES$PAGEX
R30SES$PAGES DS 0H
         BAS   R14,R30SES$STT           Get title line first time
         LA    R15,WLINE                Locate first column start
         MVC   0(9,R15),=C'Pages In:'   Get text
         CVD   R2,DOUBLE                Convert to decimal
         LA    R15,EOEL-12(R15)         Locate output for number
         MVC   0(12,R15),EDPAT12        Get edit pattern
         ED    0(12,R15),DOUBLE+3       Edit the count
         LA    R15,WLINE+#SES$EC2       Locate second column start
         MVC   0(10,R15),=C'Pages Out:' Get text
         CVD   R3,DOUBLE                Convert to decimal
         LA    R15,EOEL-12(R15)         Locate output for number
         MVC   0(12,R15),EDPAT12        Get edit pattern
         ED    0(12,R15),DOUBLE+3       Edit count
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write SMB line out
         MVI   WLINE,C' '               Get blank
         MVC   WLINE+1(79),WLINE        ..Propagate it
R30SES$PAGEX DS 0H
*
         ICM   R2,B'1111',SMF30CPI-SMF30SAP(R4) Get Common (lpa+csa)
         BNZ   R30SES$MISC1S
         ICM   R3,B'1111',SMF30HPI-SMF30SAP(R4) Get Hiperspace
         BZ    R30SES$MISC1X
R30SES$MISC1S DS 0H
         BAS   R14,R30SES$STT           Get title line first time
         LA    R15,WLINE                Locate first column start
         MVC   0(17,R15),=C'Common (LPA+CSA):'
         CVD   R2,DOUBLE                Convert to decimal
         LA    R15,EOEL-12(R15)         Locate output for number
         MVC   0(12,R15),EDPAT12        Get edit pattern
         ED    0(12,R15),DOUBLE+3       Edit the count
         LA    R15,WLINE+#SES$EC2       Locate second column start
         MVC   0(11,R15),=C'Hiperspace:'
         CVD   R3,DOUBLE                Convert to decimal
         LA    R15,EOEL-12(R15)         Locate output for number
         MVC   0(12,R15),EDPAT12        Get edit pattern
         ED    0(12,R15),DOUBLE+3       Edit count
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write SMB line out
         MVI   WLINE,C' '               Get blank
         MVC   WLINE+1(79),WLINE        ..Propagate it
R30SES$MISC1X DS 0H
*
         ICM   R2,B'1111',SMF30VPR-SMF30SAP(R4) Vio reclaims
         BNZ   R30SES$MISC2S
         ICM   R3,B'1111',SMF30PST-SMF30SAP(R4) Pages stolen
         BZ    R30SES$MISC2X
R30SES$MISC2S DS 0H
         BAS   R14,R30SES$STT           Get title line first time
         LA    R15,WLINE                Locate first column start
         MVC   0(13,R15),=C'VIO Reclaims:'
         CVD   R2,DOUBLE                Convert to decimal
         LA    R15,EOEL-12(R15)         Locate output for number
         MVC   0(12,R15),EDPAT12        Get edit pattern
         ED    0(12,R15),DOUBLE+3       Edit the count
         LA    R15,WLINE+#SES$EC2       Locate second column start
         MVC   0(13,R15),=C'Pages Stolen:'
         CVD   R3,DOUBLE                Convert to decimal
         LA    R15,EOEL-12(R15)         Locate output for number
         MVC   0(12,R15),EDPAT12        Get edit pattern
         ED    0(12,R15),DOUBLE+3       Edit count
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write SMB line out
         MVI   WLINE,C' '               Get blank
         MVC   WLINE+1(79),WLINE        ..Propagate it
R30SES$MISC2X DS 0H
         B     R30SES$STX               Leave
*
#EOLM    EQU   (EOEL/2)-3               Center "Paging"
R30SES$STT DS  0H
         TM    FLAG1,$F1_PAGT           Printed title line yet?
         BO    R30SES$STTX              Yeessss
         ST    R14,PARMLIST             Nope, save return address
         OI    FLAG1,$F1_PAGT           Set flag that we did it...
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  print blank line
         LA    R15,WLINE                Locate output line
         MVI   0(R15),C'-'              Get dash
         MVC   1(EOEL-1,R15),0(R15)     ..Propagate it
         MVC   #EOLM(6,R15),=C'Paging'  Move in title
         LA    R15,#SES$EC2(R15)        Locate to next section
         MVI   0(R15),C'-'              Get dash
         MVC   1(EOEL-1,R15),0(R15)     ..Propagate it
         MVC   #EOLM(6,R15),=C'Paging'  Move in title
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write SMB line out
         MVI   WLINE,C' '               Get blank
         MVC   WLINE+1(79),WLINE        ..propagate it
         L     R14,PARMLIST             Restore return address
R30SES$STTX DS 0H
         BSM   0,R14
*
R30SES$STX DS  0H
*
** Print ending messages
*
         MVI   WLINE,C' '               Get blank
         MVC   WLINE+1(79),WLINE        ..propagate it
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write SMB line out
*
         MVC   WLINE(MSG120L),MSG120    Get message
         MVI   WLINE+5,C'1'             Change "XYZ120" to "XYZ121"
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write SMB line out
         EJECT
***********************************************************************
***                                                                 ***
** Call MVS/Quickref (from ChicagoSoft) to print information on      **
** system ABENDs in the SYSMSGS (3rd JES SYSOUT dataset).            **
**                                                                   **
** This code has been tested at MVS 4.3 and MVS/Quickref 4.2 & 4.3.  **
**                                                                   **
** You must update the MVS/Quickref options table with the global    **
** database names or (this is untested and I wouldn't do it) put     **
** the MVS/Quickref databases in the INIT JCL.                       **
**                                                                   **
** See #TEXTL and #RTRAL equates for the hardcoded length of a       **
** MVS/Quickref text line and the maximum number of lines that we    **
** are going to print.                                               **
***                                                                 ***
***********************************************************************
 SPACE 2
#TEXTL EQU   78                         Quickref text line length
#MAXL  EQU   50                         Max number of text lines 2 prt
#RTRAL EQU   #TEXTL*#MAXL               Length of Quickref return area
 SPACE 2
 CLI   FCC_CDE,C'S'                     System ABEND
 BNE   EXIT                             No, continue
 TM    FLAG1,$F1_NQW                    Don't do MVS/Quickref
 BO    EXIT                             Yes, skip MVS/Quickref
 XC    QW_REPA(4),QW_REPA               Ensure it's zeros
*
** Load entry point to MVS/Quickref program interface module
*
 LOAD  EPLOC==CL8'QWIKREF1',ERRET=EXIT  Get entry point
 ST    R0,QW_REPA                       Save entry point
*
** At release 5.0, ChicagoSoft changed the programming interface
** so we need a way of doing things differently based on the version.
*
#ECNAME EQU X'2E',8                     C'QWIKREF1'
#ECVER  EQU X'37',4                     x.xx
#ECVERD EQU X'38',1                      .
#ECLEN  EQU X'57'-X'37'                 Total length of EC text
*
 XC    QW_VER(4),QW_VER                 Ensure version
 LR    R1,R0                            Locate epa of QWIKREF1
 CLC   #ECNAME(L'#ECNAME,R1),=CL8'QWIKREF1' Looks right?
 BNE   CMQ$VERE
 CLI   #ECVERD(R1),C'.'                 Have a dot?
 BE    CMQ$VERO                         Looking goood!
CMQ$VERE DS 0H                          Error: Eyecatcher invalid
 MVC   WLINE(C_WTOL),C_WTO              Get WTO constant
 MVC   WLINE+4(MSG116L),MSG116          Get message text
 WTO   ,MF=(E,WLINE)                    Issue WTO
 B     EXIT
CMQ$VERO DS 0H
 MVC   QW_VER(L'#ECVER),#ECVER(R1)      Obtain the "x.xx" level
 CLI   QW_VER,C'5'                      At version 5?
 BL    CMQ$VERX                         No, continue
 MVC   WLINE(C_WTOL),C_WTO              Get WTO constant
 MVC   WLINE+4(MSG117L),MSG117          Get message text
 MVC   WLINE+4+MSG117L+1(L'QW_VER),QW_VER Insert Quickref Version
 WTO   ,MF=(E,WLINE)                    Issue WTO
 B     EXIT
CMQ$VERX DS 0H
*
** Invoke MVS/Quickref to search on the ABEND on this job step.
** We build a search argument of "M=Sxxx".
*
 LA    R1,PARMLIST                      Locate parameter list
 LA    R14,FCC_QW                       Locate Quickref parm area
 MVC   0(2,R14),=X'00,06'               Length of "M=Sxxx"
 MVC   2(2,R14),=C'M='                  Set as MVS QW DB item
 ST    R14,0(R1)                        Save address of command buf.
 LA    R14,QW_RTEXT                     Locate control block
 ST    R14,4(R1)                        Save length of area
 L     R14,=A(#RTRAL)                   Get length of text area
 ST    R14,8(R1)                        Save length
 OI    8(R1),X'80'                      Last parmlist entry!
 L     R15,QW_REPA                      Load entry point of routine
 BASSM R14,R15                          Call MVS/Quickref
 LR    R3,R15                           Save return code
 ST    R15,PARMLIST                     Save return code for afterwards
*
** Check for errors
*
 LTR   R3,R3                            Check return code
 BZ    CMQ$FOUND                        Okay, continue
 CH    R3,=H'4'                         Partial success...
 BE    CMQ$FOUND                        Yes, continue
 MVC   WLINE(C_WTOL),C_WTO              Get WTO constant
 MVC   WLINE+4(MSG110L),MSG110          Get message text
 LA    R15,WLINE+4+MSG110L              Locate past message text
 CVD   R3,DOUBLE                        Convert return code
 MVC   0(4,R15),EDPAT4                  Get edit pattern
 ED    0(4,R15),DOUBLE+6                Edit RC
 LA    R15,4(R15)                       Bump past it
 MVC   0(6,R15),=C', CMD:'              Insert text
 LA    R15,7(R15)                       Bump past it
 MVC   0(2+4,R15),2(R5)                 Get QW command: "M=Sxxx"
 WTO   ,MF=(E,WLINE)                    Issue WTO
 B     CMQ$X
*
** Print header line in SYSMSGS
*
CMQ$FOUND EQU *
 LA    R15,MSG111                       Locate message area
 ST    R15,LCTPARM1-LCTD(,R12)          Save msg location into LCT
 LA    R15,MSG111L                      Get msg length
 STH   R15,LCTPARM2+2-LCTD(,R12)        Save msg length
 L     R15,=V(IEFYS)                    Locate SMB write routine
 BALR  R14,R15                          Write line out
*
 LA    R15,=C' '                        Locate blank
 ST    R15,LCTPARM1-LCTD(,R12)          Save msg location into LCT
 LA    R15,1                            Get msg length
 STH   R15,LCTPARM2+2-LCTD(,R12)        Save msg length
 L     R15,=V(IEFYS)                    Locate SMB write routine
 BALR  R14,R15                          Write line out
*
** Loop thru all of the messages that Quickref returns to us and
** put them in the SYSMSGS
**
** Note: Instead of moving via "MVC WLINE(#TEXTL),0(R2)", tell IEFYS
**       where the Quickref Line is located in the area returned by
**       Quickref for a little better performance.
*
 LA    R15,#TEXTL                       Get length of Quickref line
 STH   R15,LCTPARM2+2-LCTD(,R12)        Save line length
CMQ$SMSG EQU *
 LA    R2,QW_RTEXT                      Locate control block
 ICM   R3,B'1111',PARMLIST+8            Get returned length
 LA    R3,0(R3)                         Take off the edge
CMQ$SML EQU *
*
 CLI   0(R2),C'*'                       Looks like a start/end line?
 BNE   CMQ$SMLD                         No, continue
 CLC   1(36,R2),=C'******************************** TOP'  Start line?
 BE    CMQ$SMLB                         Yes, skip it
 CLC   1(34,R2),=C'****************************** BOT'
 BE    CMQ$SMLB                         Yes, skip it
CMQ$SMLD EQU *
*
 ST    R2,LCTPARM1-LCTD(,R12)           Save record location into LCT
 L     R15,=V(IEFYS)                    Locate SMB write routine
 BALR  R14,R15                          Write SMB line out
CMQ$SMLB EQU *
 LA    R2,#TEXTL(R2)                    Bump to next text
 SH    R3,=AL2(#TEXTL)                  Subtract length of line
 LTR   R3,R3                            Check out remaining length
 BP    CMQ$SML                          Still have some then do it
*
** End of the Quickref messages - print ending line
*
 LA    R15,=C' '                        Locate blank
 ST    R15,LCTPARM1-LCTD(,R12)          Save msg location into LCT
 LA    R15,1                            Get msg length
 STH   R15,LCTPARM2+2-LCTD(,R12)        Save msg length
 L     R15,=V(IEFYS)                    Locate SMB write routine
 BALR  R14,R15                          Write SMB line out
*
 LA    R15,MSG112                       Locate message area
 ST    R15,LCTPARM1-LCTD(,R12)          Save msg location into LCT
 LA    R15,MSG112L                      Get msg length
 STH   R15,LCTPARM2+2-LCTD(,R12)        Save msg length
 L     R15,=V(IEFYS)                    Locate SMB write routine
 BALR  R14,R15                          Write SMB line out
*
** Error - Area not large enough - Usually on purpose as we don't
**         need to print a book - only the first x number of lines.
*
 CLI   PARMLIST+3,4                     RC=4 from Quickref?
 BNE   CMQ$PSX                          No, skip the lecture
 LA    R15,MSG113                       Locate message area
 ST    R15,LCTPARM1-LCTD(,R12)          Save msg location into LCT
 LA    R15,MSG113L                      Get msg length
 STH   R15,LCTPARM2+2-LCTD(,R12)        Save msg length
 L     R15,=V(IEFYS)                    Locate SMB write routine
 BALR  R14,R15                          Write SMB line from WLINE
*
 LA    R15,MSG114                       Locate message area
 ST    R15,LCTPARM1-LCTD(,R12)          Save msg location into LCT
 LA    R15,MSG114L                      Get msg length
 STH   R15,LCTPARM2+2-LCTD(,R12)        Save msg length
 L     R15,=V(IEFYS)                    Locate SMB write routine
 BALR  R14,R15                          Write SMB line from WLINE
CMQ$PSX EQU *
*
** Print WTO message that we put some information in SYSMSGS
*
 MVC   WLINE(C_WTOL),C_WTO              Get WTO constant
 MVC   WLINE+4(MSG115L),MSG115          Get message
 WTO   ,MF=(E,WLINE)                    Issue WTO
*
** Delete module from memory
*
CMQ$X  EQU *
 ICM   R0,B'1111',QW_REPA               Get entry point
 BZ    CMQ$DMX                          None, leave
 DELETE EPLOC==CL8'QWIKREF1'            Delete module from memory
CMQ$DMX EQU *
 B     EXIT                             Leave
         EJECT
***********************************************************************
***                                                                 ***
**       Job termination (Non-TSO only)                              **
***                                                                 ***
***********************************************************************
         SPACE 2
R30JOB   EQU   *
*
** Do different processing for TSO users
*
         L     R1,IR_PARML              Get IEFACTRT parm list
         L     R1,@ACTRT_JMR-@ACTRT(R1) Locate JMR
         TM    JMRINDC-JMR(R1),JMRFIND  TSO User (Foreground)?
         BO    R30JOB_TSO               Yes, do its stuff
*
** Do we need to ignore this job (for some common started tasks we
** don't care about getting Trivia reports)
*
         BAS   R14,IGNORE_JOB           Ignore this job?
*
** Write out the job ended message to the operator console.  A MPF
** exit will ensure that the message is suppressed from the user's
** JES2 JOB LOG and only sent to the MCS console.
*
         MVC   WLINE(C_WTOL),C_WTO      Get WTO constant
         LA    R15,WLINE+4              Locate to text area
         MVC   0(18,R15),=C'XYZ107I JOB ENDED:' Insert message prefix
         LA    R15,18+2(R15)            Bump past it
         L     R1,IR_PARML              Get IEFACTRT parm list
         L     R1,@ACTRT_JMR-@ACTRT(R1) Locate JMR
         MVC   0(8,R15),JMRJOB-JMR(R1)  Get Jobname
         LA    R15,8+1(R15)             Bump past it
         L     R1,IR_PARML              Get IEFACTRT parm list
         L     R1,@ACTRT_PGRMNAME-@ACTRT(R1) Locate Programmer name
         MVC   0(20,R15),0(R1)          Get programmer name
R30J$IW  EQU   *
         WTO   ,MF=(E,WLINE)            Issue WTO
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** Job End Statistics
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
R30JOB_END_STATS DS 0H
         ICM   R15,B'1111',=V(IEFYS)    Have the IBM SMB routine?
         BZ    EXIT                     No, give up
*
** Print heading lines
*
         MVC   WLINE(MSG120L),MSG120    Get message
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write SMB line out
*-"J o b  E n d   S t a t i s t i c s"
         MVI   WLINE,C' '               Get blank
         MVC   WLINE+1(79),WLINE        ..propagate it
         MVC   WLINE+24(5),=C'J o b'    It a tough JOB but somebody...
         MVC   WLINE+32(C_ENDSTL),C_ENDST Get "end stats"
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write SMB line out
*-Print blank line
         MVI   WLINE,C' '               Get blank
         MVC   WLINE+1(79),WLINE        ..propagate it
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write SMB line out
*
** Data line 1
*
         MVC   WLINE_JESIC1D(10),=C'Job  Name:'
         L     R1,IR_PARML              Get IEFACTRT parm list
         L     R1,@ACTRT_JMR-@ACTRT(R1) Locate JMR
         MVC   WLINE_JESIC1V(L'JMRJOB),JMRJOB-JMR(R1)
*
         MVC   WLINE_JESIC2D(10),=C'System ID:'
         L     R14,IR_PARML             Get IEFACTRT parm list
         L     R14,@ACTRT_SMFREC-@ACTRT(R14) Locate SMF record
         MVC   WLINE_JESIC2V(L'SMF30SID),SMF30SID-SMF30RPS(R14)
*
         MVC   WLINE_JESIC3DT(7),=C'Submit:'
         ICM   R14,B'1111',A_IDSECT     Locate ID section
         BZ    R30JES$RTODX             None?
         LA    R15,WLINE_JESIC3VT       Output location
         ICM   R0,B'1111',SMF30RST-SMF30ID(R14) <- Time
         ICM   R1,B'1111',SMF30RSD-SMF30ID(R14) <- Date
         BAS   R14,CONVERT_TO_TODSTRING Convert the time and date
R30JES$RTODX DS 0H
*
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write SMB line out
         MVI   WLINE,C' '               Get blank
         MVC   WLINE+1(79),WLINE        ..propagate it
*
** Data line 2
*
         MVC   WLINE_JESIC1D(10),=C'Job JESID:'
         ICM   R1,B'1111',A_IDSECT      Locate ID section
         BZ    R30JES$JIX               None?
         MVC   WLINE_JESIC1V(8),SMF30JNM-SMF30ID(R1)
R30JES$JIX DS  0H
*
         L     R1,IR_PARML              Get IEFACTRT parm list
         L     R1,@ACTRT_SMFREC-@ACTRT(R1) Locate SMF record
         ICM   R14,B'1111',SMF30SOF-SMF30RPS(R1) Offset: SubSystem
         BZ    R30JES$OSLX              Not there...
         AR    R14,R1                   Locate Subsystem section
         MVC   WLINE_JESIC2D(10),=C'MVS level:'
         MVC   WLINE_JESIC2V(L'SMF30OSL),SMF30OSL-SMF30PSS(R14)
R30JES$OSLX DS 0H
*
         MVC   WLINE_JESIC3DT(6),=C'Start:'
         ICM   R14,B'1111',A_IDSECT     Locate ID section
         BZ    R30JES$STODX             None?
         LA    R15,WLINE_JESIC3VT       Output location
         ICM   R0,B'1111',SMF30SIT-SMF30ID(R14) <- Time
         ICM   R1,B'1111',SMF30STD-SMF30ID(R14) <- Date
         BAS   R14,CONVERT_TO_TODSTRING Convert the time and date
R30JES$STODX DS 0H
*
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write SMB line out
         MVI   WLINE,C' '               Get blank
         MVC   WLINE+1(79),WLINE        ..propagate it
*
** Data line 3
*
*
         ICM   R1,B'1111',A_IDSECT      Locate ID section
         BZ    R30JES$JCX               None?
         MVC   WLINE_JESIC1D(10),=C'Job Class:'
         MVC   WLINE_JESIC1V(1),SMF30CL8-SMF30ID(R1)
R30JES$JCX DS  0H
*
         MVC   WLINE_JESIC3DT(4),=C'End:'
         TIME  BIN                      Get the time and date NOW!
         LA    R15,WLINE_JESIC3VT       Output location
         BAS   R14,CONVERT_TO_TODSTRING Convert the time and date
R30JES$ETODX DS 0H
*
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write SMB line out
         MVI   WLINE,C' '               Get blank
         MVC   WLINE+1(79),WLINE        ..propagate it
*
** Data line 4
*
         LA    R15,WLINE_JESIC1V-2      Location for "  hh:mm:ss.th"
         L     R1,T_TCB                 Get CPU time to edit
         BAS   R14,FORMAT_CPUTIME       Format CPU time
         MVC   WLINE_JESIC1D(10),=C'CPU (TCB):'
*
         ICM   R4,B'1111',A_STSECT      Get storage section
         BZ    R30JES$SBX               None, continue
         L     R1,SMF30URB-SMF30SAP(R4) Get storage length
         SRL   R1,10                    Get by 1024
         CVD   R1,DOUBLE                Convert to packed
         MVC   WLINE_JESIC3VS-1(12),EDPAT12 Get edit mask
         ED    WLINE_JESIC3VS-1(12),DOUBLE+3 Edit the storage
         MVC   WLINE_JESIC3DST(18),=C'Storage below 16M:'
         MVI   WLINE_JESIC3VSK,C'k'
R30JES$SBX DS 0H
*
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write SMB line out
         MVI   WLINE,C' '               Get blank
         MVC   WLINE+1(79),WLINE        ..propagate it
*
** Data line 5
*
         LA    R15,WLINE_JESIC1V-2      Location for "  hh:mm:ss.th"
         L     R1,T_SRB                 Get CPU time to edit
         BAS   R14,FORMAT_CPUTIME       Format CPU time
         MVC   WLINE_JESIC1D(10),=C'CPU (SRB):'
*
         ICM   R4,B'1111',A_STSECT      Get storage section
         BZ    R30JES$SAX               None, continue
         L     R1,SMF30EUR-SMF30SAP(R4) Get storage length
         SRL   R1,10                    Get by 1024
         CVD   R1,DOUBLE                Convert to packed
         MVC   WLINE_JESIC3VS-1(12),EDPAT12 Get edit pattern
         ED    WLINE_JESIC3VS-1(12),DOUBLE+3 Edit it
         MVC   WLINE_JESIC3DST(18),=C'Storage above 16M:'
         MVI   WLINE_JESIC3VSK,C'k'
R30JES$SAX DS 0H
*
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write SMB line out
         MVI   WLINE,C' '               Get blank
         MVC   WLINE+1(79),WLINE        ..propagate it
*
** Data line 6
*
         ICM   R4,B'1111',A_PRSECT      Have a performance section?
         BZ    R30JES$DL6X              No, continue
*
         SLR   R0,R0
         ICM   R1,B'1111',SMF30TAT-SMF30PRF(R4)  Get trans active
         SLDL  R0,10
         BAS   R14,CONVERT_MICRO_SECONDS Convert micro seconds
*                                          h h : m m : s s . t h
*                                      0 1 2 3 4 5 6 7 8 9 0 1 2
         MVC   WLINE_JESIC1V-2(13),=X'402120207A20207A20204B2020'
         ED    WLINE_JESIC1V-2(13),DOUBLE+1
         MVC   WLINE_JESIC1D(10),=C'Trans Act:'
*
         L     R1,SMF30SRV-SMF30PRF(R4) Get service units
         CVD   R1,DOUBLE                Convert to packed
         MVC   WLINE_JESIC3VS(12),EDPAT12
         ED    WLINE_JESIC3VS(12),DOUBLE+3
         MVC   WLINE_JESIC3DST(14),=C'Service Units:'
*
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write SMB line out
         MVI   WLINE,C' '               Get blank
         MVC   WLINE+1(79),WLINE        ..propagate it
R30JES$DL6X DS 0H
*
** Data line 7
*
         LA    R1,0                     Default number of tape mounts
         L     R7,IR_PARML              Get IEFACTRT parm list
         L     R7,@ACTRT_SMFREC-@ACTRT(R7) Locate SMF record
         SLR   R2,R2                    Clear register for ICM
         ICM   R2,B'0011',SMF30OLN-SMF30RPS(R7) Length of section
         BZ    R30JES$OPX               Zero, Ignore it
         ICM   R2,B'0011',SMF30OON-SMF30RPS(R7) Number of sections
         BZ    R30JES$OPX               Zero, Ignore it
         ICM   R4,B'1111',SMF30OOF-SMF30RPS(R7) Get offset to I/O sect
         BZ    R30JES$OPX               Zero, Ignore it
         AR    R4,R7                    Locate operator section
         L     R1,SMF30PTM-SMF30OPS(R4) Get Non-specific tape mounts
         A     R1,SMF30TPR-SMF30OPS(R4) Get specific tape mounts
R30JES$OPX DS 0H
         LR    R2,R1                    Save tape mount total
*
         L     R1,IR_PARML              Get IEFACTRT parm list
         L     R1,@ACTRT_SMFREC-@ACTRT(R1) Locate SMF record
         SLR   R14,R14                  Clear register for ICM
         ICM   R14,B'0011',SMF30ULN-SMF30RPS(R1) Length of section
         BZ    R30JES$EXX               Zero, Ignore it
         ICM   R14,B'0011',SMF30UON-SMF30RPS(R1) Number of sections
         BZ    R30JES$EXX               Zero, Ignore it
         ICM   R4,B'1111',SMF30UOF-SMF30RPS(R1) Get offset to I/O sect
         BZ    R30JES$EXX               Zero, Ignore it
         AR    R4,R1                    Locate it
         L     R1,SMF30TEP-SMF30URA(R4) Obtain EXCP count
R30JES$EXX DS 0H
         LTR   R2,R2                    Tape mounts = 0?
         BNZ   R30JES$DL7P              No, print line
         LTR   R1,R1                    Were the EXCPs also zero?
         BZ    R30JES$DL7X              Yes, skip printing line
R30JES$DL7P DS 0H
         CVD   R1,DOUBLE                Convert to packed
         MVC   WLINE_JESIC3VS(12),EDPAT12
         ED    WLINE_JESIC3VS(12),DOUBLE+3
         MVC   WLINE_JESIC3DST(12),=C'Total EXCPs:'
*
         LR    R1,R2                    Get tape mount total
         LA    R15,WLINE_JESIC1V        Locate output area
         BAS   R14,EDITFWF              Edit number of tape mounts
         MVC   WLINE_JESIC1D(10),=C'Tape Mnts:'
*
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write SMB line out
         MVI   WLINE,C' '               Get blank
         MVC   WLINE+1(79),WLINE        ..propagate it
R30JES$DL7X DS 0H
*
** Print blank line
*
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write SMB line out
*
** Print fields in the Storage section
**
** For the Job end statistics, print all lines even if fields are zero.
*
         ICM   R4,B'1111',A_STSECT      Get storage section
         BZ    R30JES$STX               None, continue
         LA    R15,WLINE                Locate output line
         MVI   0(R15),C'-'              Get dash
         MVC   1(EOEL-1,R15),0(R15)     ..Propagate it
         MVC   #EOLM(6,R15),=C'Paging'  Move in title
         LA    R15,#SES$EC2(R15)        Locate to next section
         MVI   0(R15),C'-'              Get dash
         MVC   1(EOEL-1,R15),0(R15)     ..Propagate it
         MVC   #EOLM(6,R15),=C'Paging'  Move in title
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write SMB line out
         MVI   WLINE,C' '               Get blank
         MVC   WLINE+1(79),WLINE        ..propagate it
*
         ICM   R2,B'1111',SMF30VPI-SMF30SAP(R4) Get VIO ins
***      BNZ   R30JES$VIOS
         ICM   R3,B'1111',SMF30VPO-SMF30SAP(R4) Get VIO outs
***      BZ    R30JES$VIOX
R30JES$VIOS DS 0H
         LA    R15,WLINE                Locate first column start
         MVC   0(7,R15),=C'VIO In:'     Get text
         CVD   R2,DOUBLE                Convert to decimal
         LA    R15,EOEL-12(R15)         Locate output for number
         MVC   0(12,R15),EDPAT12        Get edit pattern
         ED    0(12,R15),DOUBLE+3       Edit the count
         LA    R15,WLINE+#SES$EC2       Locate second column start
         MVC   0(8,R15),=C'VIO Out:'    Get text
         CVD   R3,DOUBLE                Convert to decimal
         LA    R15,EOEL-12(R15)         Locate output for number
         MVC   0(12,R15),EDPAT12        Get edit pattern
         ED    0(12,R15),DOUBLE+3       Edit count
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write SMB line out
         MVI   WLINE,C' '               Get blank
         MVC   WLINE+1(79),WLINE        ..Propagate it
R30JES$VIOX DS 0H
*
         ICM   R2,B'1111',SMF30PSI-SMF30SAP(R4) Get Pages swapped in
***      BNZ   R30JES$PAGES
         ICM   R3,B'1111',SMF30PSO-SMF30SAP(R4) Get Pages swapped out
***      BZ    R30JES$PAGEX
R30JES$PAGES DS 0H
         LA    R15,WLINE                Locate first column start
         MVC   0(9,R15),=C'Pages In:'   Get text
         CVD   R2,DOUBLE                Convert to decimal
         LA    R15,EOEL-12(R15)         Locate output for number
         MVC   0(12,R15),EDPAT12        Get edit pattern
         ED    0(12,R15),DOUBLE+3       Edit the count
         LA    R15,WLINE+#SES$EC2       Locate second column start
         MVC   0(10,R15),=C'Pages Out:' Get text
         CVD   R3,DOUBLE                Convert to decimal
         LA    R15,EOEL-12(R15)         Locate output for number
         MVC   0(12,R15),EDPAT12        Get edit pattern
         ED    0(12,R15),DOUBLE+3       Edit count
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write SMB line out
         MVI   WLINE,C' '               Get blank
         MVC   WLINE+1(79),WLINE        ..Propagate it
R30JES$PAGEX DS 0H
*
         ICM   R2,B'1111',SMF30CPI-SMF30SAP(R4) Get Common (lpa+csa)
***      BNZ   R30JES$MISC1S
         ICM   R3,B'1111',SMF30HPI-SMF30SAP(R4) Get Hiperspace
***      BZ    R30JES$MISC1X
R30JES$MISC1S DS 0H
         LA    R15,WLINE                Locate first column start
         MVC   0(17,R15),=C'Common (LPA+CSA):'
         CVD   R2,DOUBLE                Convert to decimal
         LA    R15,EOEL-12(R15)         Locate output for number
         MVC   0(12,R15),EDPAT12        Get edit pattern
         ED    0(12,R15),DOUBLE+3       Edit the count
         LA    R15,WLINE+#SES$EC2       Locate second column start
         MVC   0(11,R15),=C'Hiperspace:'
         CVD   R3,DOUBLE                Convert to decimal
         LA    R15,EOEL-12(R15)         Locate output for number
         MVC   0(12,R15),EDPAT12        Get edit pattern
         ED    0(12,R15),DOUBLE+3       Edit count
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write SMB line out
         MVI   WLINE,C' '               Get blank
         MVC   WLINE+1(79),WLINE        ..Propagate it
R30JES$MISC1X DS 0H
*
         ICM   R2,B'1111',SMF30VPR-SMF30SAP(R4) Vio reclaims
***      BNZ   R30JES$MISC2S
         ICM   R3,B'1111',SMF30PST-SMF30SAP(R4) Pages stolen
***      BZ    R30JES$MISC2X
R30JES$MISC2S DS 0H
         LA    R15,WLINE                Locate first column start
         MVC   0(13,R15),=C'VIO Reclaims:'
         CVD   R2,DOUBLE                Convert to decimal
         LA    R15,EOEL-12(R15)         Locate output for number
         MVC   0(12,R15),EDPAT12        Get edit pattern
         ED    0(12,R15),DOUBLE+3       Edit the count
         LA    R15,WLINE+#SES$EC2       Locate second column start
         MVC   0(13,R15),=C'Pages Stolen:'
         ICM   R0,B'1111',SMF30PST-SMF30SAP(R4) Pages stolen
         CVD   R3,DOUBLE                Convert to decimal
         LA    R15,EOEL-12(R15)         Locate output for number
         MVC   0(12,R15),EDPAT12        Get edit pattern
         ED    0(12,R15),DOUBLE+3       Edit count
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write SMB line out
         MVI   WLINE,C' '               Get blank
         MVC   WLINE+1(79),WLINE        ..Propagate it
R30JES$MISC2X DS 0H
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Print blank line
R30JES$STX DS  0H
*
** Print trailer line 1
*
         ICM   R14,B'1111',A_IDSECT     Locate ID section
         BZ    R30JES$AUX               None?
         MVC   WLINE_JESIC1D(10),=C'ACF2 User:'
         MVC   WLINE_JESIC1V(L'SMF30RUD),SMF30RUD-SMF30ID(R14)
R30JES$AUX DS 0H
*
         LA    R15,WLINE+#SES$EC2       Locate second column start
         MVC   0(11,R15),=C'Programmer:' Insert description
         LA    R15,12(R15)              Locate past description
         L     R1,IR_PARML              Get IEFACTRT parm list
         L     R1,@ACTRT_PGRMNAME-@ACTRT(R1) Locate programmer name
         MVC   0(20,R15),0(R1)
*
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write SMB line out
         MVI   WLINE,C' '               Get blank
         MVC   WLINE+1(79),WLINE        ..propagate it
*
** Print trailer line 2
*
         L     R1,IR_PARML              Get IEFACTRT parm list
         L     R1,@ACTRT_SMFREC-@ACTRT(R1) Locate SMF record
         ICM   R14,B'1111',SMF30AOF-SMF30RPS(R1) Offset: SubSystem
         BZ    R30JES$TL2X
         AR    R14,R1                   Locate accounting field
         SLR   R2,R2                    Clear register for ICM
         ICM   R2,B'0011',SMF30AON-SMF30RPS(R1) Get number of fields
         BZ    R30JES$TL2X              None: leave
         MVC   WLINE_JESIC1D(10),=C'Acct Info:' Set description
         LA    R15,WLINE_JESIC1V        Locate to start of value out
R30JES$TL2L DS 0H
         SLR   R1,R1                    Clear for IC
         IC    R1,0(R14)                Get length of field
         BCTR  R1,0                     Decrement by 1 for EX
         EX    R1,R30JES$TL2M           Move account field out
         LA    R1,1(R1)                 Add 1 back to field length
         AR    R15,R1                   Bump past field on output
         MVI   0(R15),C','              Insert delimiter
         LA    R15,1(R15)               Bump past delimiter
         LA    R14,1(R1,R14)            Bump past field on input
         BCT   R2,R30JES$TL2L           Process next field
         BCTR  R15,0                    Backup past last delimiter
         MVI   0(R15),C' '              Erase trailing comma
R30JES$TL2X DS 0H
*
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write SMB line out
         MVI   WLINE,C' '               Get blank
         MVC   WLINE+1(79),WLINE        ..propagate it
*
** Print ending lines
*
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write SMB line out
*
         MVC   WLINE(MSG120L),MSG120    Get message
         MVI   WLINE+5,C'2'             Change "XYZ120" to "XYZ122"
         L     R15,=V(IEFYS)            Locate SMB write routine
         BALR  R14,R15                  Write SMB line out
         B     EXIT
*
** Executed instructions
*
R30JES$C MVC   WLINE_JESIC1V(0),0(R5)
R30JES$TL2M MVC 0(0,R15),1(R14)
         EJECT
***********************************************************************
***                                                                 ***
**       SMF 30 - Job Termination - TSO user code                    **
***                                                                 ***
***********************************************************************
         SPACE 2
R30JOB_TSO DS  0H
         L     R3,T_TCB                 Get TCB time
         A     R3,T_SRB                 Add in the SRB time
         BAS   R14,EDIT_CPU_TIME        Edit CPU time: R5=addr R6=Len
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**      Print the first message                                      **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
*
** Print message prefix
*
         LA    R15,WLINE                Locate message area
         MVI   0(R15),C' '              Get space
         MVC   1(79,R15),0(R15)         Propagate spaces
         MVC   0(23,R15),=C'XYZ104I Your session on'
         LA    R15,24(R15)              Bump past text
*
** Print system ID
*
         L     R1,CVTPTR                -> CVT
         MVC   0(8,R15),CVTSNAME-CVTMAP(R1) Obtain System Name
         LA    R0,8                     Length of string
         BAS   R14,LOCATE_FIRST_SPACE   Locate first space
*
** Print CPU information
*
         MVC   1(4,R15),=C'used'        Insert text
         LA    R15,6(R15)               Bump past it
         EX    R6,R30JT$CPU             Move in CPU time
         LA    R15,1(R6,R15)            Bump past it
         MVC   1(11,R15),=C'CPU seconds' Insert text
         LA    R15,12(R15)              Bump past it
*
** Locate I/O Section
**
** We assume that the check SMF30UON was checked for zero eariler
*
         L     R1,IR_PARML              Get IEFACTRT parm list
         L     R1,@ACTRT_SMFREC-@ACTRT(R1) Locate SMF record
         SLR   R14,R14                  Clear register for ICM
         ICM   R14,B'0011',SMF30ULN-SMF30RPS(R1) Length of section
         BZ    R30JT$EXX                Zero, Ignore it
*        ICM   R14,B'0011',SMF30UON-SMF30RPS(R1) Number of sections
*        BZ    R30JT$EXX                Zero, Ignore it
         ICM   R4,B'1111',SMF30UOF-SMF30RPS(R1) Get offset to I/O sect
         BZ    R30JT$EXX                If not available, leave
         AR    R4,R1                    Locate it
*
** Print EXCPS
*
         MVC   1(3,R15),=C'and'         Insert text
         LA    R15,5(R15)               Bump past it
         L     R1,SMF30TEP-SMF30URA(R4) Obtain EXCP count
         BAS   R14,EDITFWF              Edit it
         MVC   1(5,R15),=C'EXCPs'       Insert text
         LA    R15,6(R15)               Bump past it
R30JT$EXX EQU  *
*
** Print message
*
         LA    R1,WLINE                 Locate beginning of message
         LR    R0,R15                   Locate end
         SR    R0,R1                    Length = End - Beginning
         TPUT  (1),(0)                  Print message on TSO terminal
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**      Print second message with performance trivia                 **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
*
** Format message header
*
         LA    R15,WLINE                Locate message area
         MVI   0(R15),C' '              Get space
         MVC   1(79,R15),0(R15)         Propagate spaces
         LA    R15,8(R15)               Bump past "XYZ104I " area
*
** Print fields in the I/O section
*
         L     R1,IR_PARML              Get IEFACTRT parm list
         L     R1,@ACTRT_SMFREC-@ACTRT(R1) Locate SMF record
         SLR   R14,R14                  Clear register for ICM
         ICM   R14,B'0011',SMF30ULN-SMF30RPS(R1) Length of section
         BZ    R30JT$IOX                Zero, Ignore it
*        ICM   R14,B'0011',SMF30UON-SMF30RPS(R1) Number of sections
*        BZ    R30JT$IOX                Zero, Ignore it
         ICM   R4,B'1111',SMF30UOF-SMF30RPS(R1)
         BZ    R30JT$IOX                Zero, Ignore it
         AR    R4,R1                    Locate section
*
         MVC   0(5,R15),=C'TGET:'
         LA    R15,6(R15)
         L     R1,SMF30TGT-SMF30URA(R4)
         BAS   R14,EDITFWF
*
         MVC   1(5,R15),=C'TPUT:'
         LA    R15,7(R15)
         L     R1,SMF30TPT-SMF30URA(R4)
         BAS   R14,EDITFWF
R30JT$IOX EQU  *
*
** Print fields in the Storage Section
*
         ICM   R4,B'1111',A_STSECT      Get storage section
         BZ    R30JT$SSX
*
         L     R1,SMF30PSI-SMF30SAP(R4) Get Swap in count
         A     R1,SMF30PSO-SMF30SAP(R4) Add Swap out count
         LTR   R1,R1                    Do any swapping?
         BZ    R30JT$SWX                No, continue
         MVC   0(8,R15),=C' Swaps: '    Insert text
         LA    R15,8(R15)               Bump past text
         BAS   R14,EDITFWF              Edit swap count
R30JT$SWX EQU  *
*
         L     R1,SMF30VPI-SMF30SAP(R4) Get VIO in count
         A     R1,SMF30VPO-SMF30SAP(R4) Add VIO out count
         LTR   R1,R1                    Do any VIO paging?
         BZ    R30JT$VIX                No, continue
         MVC   0(6,R15),=C' VIO: '      Insert text
         LA    R15,6(R15)               Bump past text
         BAS   R14,EDITFWF              Edit VIO count
R30JT$VIX EQU  *
*
         L     R1,SMF30HPI-SMF30SAP(R4) Get hiperspace in count
         A     R1,SMF30HPO-SMF30SAP(R4) Add Hiperspace out count
         LTR   R1,R1                    Any hiperpace activity?
         BZ    R30JT$HPX                No, continue
         MVC   0(13,R15),=C' HiperSpace: ' Insert text
         LA    R15,13(R15)              Bump past text
         BAS   R14,EDITFWF              Edit swap count
R30JT$HPX EQU  *
*
         ICM   R1,B'1111',SMF30LPI-SMF30SAP(R4) Get LPA count
         BZ    R30JT$LPX                No, continue
         MVC   1(4,R15),=C'LPA:'        Insert text
         LA    R15,6(R15)               Bump past text
         BAS   R14,EDITFWF              Edit count
R30JT$LPX EQU  *
*
R30JT$SSX EQU  *                        End of Storage Section stuff
*
** print terminal name if ID section is around
*
         ICM   R4,B'1111',A_IDSECT      Locate ID section
         BZ    R30JT$TX
         CLC   SMF30TID-SMF30ID(3,R4),=C'TPX'  Useless info?
         BE    R30JT$TX                 Yes, not the real name...
         MVC   1(9,R15),=C'Terminal:'   Get text
         LA    R15,11(R15)              Bump past it
         MVC   0(8,R15),SMF30TID-SMF30ID(R4) Move in Terminal ID
         LA    R15,8(R15)               Bump past it
R30JT$TX DS    0H
*
** Print the message
*
         LA    R1,WLINE                   Locate message start
         LR    R0,R15                     Get end
         SR    R0,R1                      Length = End - Beginning
         CH    R0,=H'8'                   Anything there?
         BE    R30JT$L2X                  Nope, leave
         TPUT  (1),(0)                    Print TSO message
R30JT$L2X EQU  *
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**      Print storage information                                    **
**                                                                   **
**      Storage used: xk (below 16 megs) xk (above 16 megs)          **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
         ICM   R4,B'1111',A_STSECT      Get storage section
         BZ    R30JT$RSX                None, continue
*
** Print blank line
*
         LA    R1,WLINE                 Locate message area
         MVI   0(R1),C' '               Get blank
         LA    R0,1                     Length of line
         TPUT  (1),(0)                  Print blank line
*
** Format message header
*
         LA    R15,WLINE                Locate message area
         MVI   0(R15),C' '              Get space
         MVC   1(79,R15),0(R15)         Propagate spaces
         LA    R15,8(R15)               Bump past "XYZ104I " area
         MVC   0(13,R15),=C'Storage used:'
         LA    R15,14(R15)
*
         L     R1,SMF30URB-SMF30SAP(R4) Get Storage below 16M
         SRL   R1,10                    Get by 1024
         CVD   R1,DOUBLE                Convert to packed
         BAS   R14,EDITFWF
         MVI   0(R15),C'k'
         LA    R15,2(R15)
         MVC   0(15,R15),=C'(below 16 megs)'
         LA    R15,17(R15)
*
         L     R1,SMF30EUR-SMF30SAP(R4) Get storage above 16M
         SRL   R1,10                    Get by 1024
         CVD   R1,DOUBLE                Convert to packed
         BAS   R14,EDITFWF
         MVI   0(R15),C'k'
         LA    R15,2(R15)
         MVC   0(15,R15),=C'(above 16 megs)'
         LA    R15,17(R15)
*
** Print the message
*
         LA    R1,WLINE                   Locate message start
         LR    R0,R15                     Get end
         SR    R0,R1                      Length = End - Beginning
         TPUT  (1),(0)                    Print TSO message
R30JT$RSX DS 0H
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**      Print Novell-like login and logout lines                     **
**                                                                   **
**      Logon:  1962.065 06-MAR-1962 07:05:02 pm
**      Logoff: 20??.??? ??-???-???? 12:59:59 pm
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
         ICM   R4,B'1111',A_IDSECT      Locate ID section
         BZ    R30JT$LIX                None, skip this
*
** Print blank line
*
         LA    R1,WLINE                 Locate message area
         MVI   0(R1),C' '               Get blank
         LA    R0,1                     Length of line
         TPUT  (1),(0)                  Print blank line
*
** Print logon time and date
*
         LA    R15,WLINE                Locate message area
         MVI   0(R15),C' '              Get space
         MVC   1(79,R15),0(R15)         Propagate spaces
         MVC   0(16,R15),=C'XYZ105I Logon:  ' Get text
         LA    R15,16(R15)              Bump past text
*
         SLR   R1,R1                    Clear register
         IC    R1,SMF30STD-SMF30ID(R4)  Get century offset from 1900
         AH    R1,=H'19'                Get the actual century
         CVD   R1,DOUBLE                Save century as Decimal
         UNPK  0(2,R15),DOUBLE+6(2)     Convert to human readable
         OI    1(R15),C'0'              Fix sign byte
         LA    R15,2(R15)               Bump past century
*
         UNPK  DOUBLE2(9),SMF30STD-SMF30ID(5,R4)
         MVZ   DOUBLE2(8),=8X'00'
         TR    DOUBLE2(8),=C'0123456789ABCDEF'
         MVC   0(2,R15),DOUBLE2+2       Get yy from "0cyydddf"
         MVI   2(R15),C'.'              Insert dot
         MVC   3(3,R15),DOUBLE2+4       Get ddd from "0cyydddf"
         LA    R15,7(R15)
*
         ICM   R0,B'1111',SMF30SIT-SMF30ID(R4) <- Time
         ICM   R1,B'1111',SMF30STD-SMF30ID(R4) <- Date
         BAS   R14,CONVERT_TO_TODSTRING Convert the time and date
         MVI   0(R15),C' '
         LA    R1,WLINE                 Locate message start
         LR    R0,R15                   Get end
         SR    R0,R1                    Length = End - Beginning
         TPUT  (1),(0)                  Print TSO message
*
** Print logoff time and date
*
         TIME  BIN                      Don't trust SMF record yet
         STM   R0,R1,DOUBLE             Save Time and Date
*
         LA    R15,WLINE                Locate message area
         MVI   0(R15),C' '              Get space
         MVC   1(79,R15),0(R15)         Propagate spaces
         LA    R15,8(R15)               Bump past "XYZ105I " area
         MVC   0(8,R15),=C'Logoff: '    Move in text
         LA    R15,8(R15)               Bump past text
*
         SLR   R1,R1                    Clear register
         IC    R1,DOUBLE+4              Get century offset from 1900
         AH    R1,=H'19'                Get the actual century
         CVD   R1,DOUBLE2               Save century as Decimal
         UNPK  0(2,R15),DOUBLE2+6(2)    Convert to human readable
         OI    1(R15),C'0'              Fix sign byte
         LA    R15,2(R15)               Bump past century
*
         UNPK  DOUBLE2(9),DOUBLE+4(5)
         MVZ   DOUBLE2(8),=8X'00'
         TR    DOUBLE2(8),=C'0123456789ABCDEF'
         MVC   0(2,R15),DOUBLE2+2       Get yy from "0cyydddf"
         MVI   2(R15),C'.'              Insert dot
         MVC   3(3,R15),DOUBLE2+4       Get ddd from "0cyydddf"
         LA    R15,7(R15)
*
         LM    R0,R1,DOUBLE             Get Time and Date
         BAS   R14,CONVERT_TO_TODSTRING Convert the time and date
         MVI   0(R15),C' '
         LA    R1,WLINE                 Locate message start
         LR    R0,R15                   Get end
         SR    R0,R1                    Length = End - Beginning
         TPUT  (1),(0)                  Print TSO message
R30JT$LIX DS   0H
         SPACE 3
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**      Common Exit from R30JOB_TSO section                          **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
         SPACE 2
R30JT$X  EQU   *
         B     EXIT                       Leave
R30JT$CPU MVC  0(0,R15),0(R5)             ** Executed **
         EJECT
***********************************************************************
***                                                                 ***
**       Misc internal subroutines                                   **
***                                                                 ***
***********************************************************************
         SPACE 2
*
** Convert binary time to printable format " hh:mm:ss"
**
** Input: R1  - Time to convert
**        R15 - Output location
*
CONVERT_BINARY_TIME EQU *
         SLR   R0,R0                      CLEAR REGISTER
         D     R0,=F'100'                 DIVIDE OUT 100THS OF SECOND
         SLR   R0,R0                      CLEAR REGISTER
         D     R0,=F'60'                  DIVIDE OUT SECONDS
         CVD   R0,DOUBLE                  CONVERT SECONDS TO PACKED
         UNPK  6(3,R15),DOUBLE+6(2)       SAVE SECONDS
         OI    6+2(R15),C'0'              FIX SIGN BYTE
         MVI   6(R15),C':'                COLON
         SLR   R0,R0                      CLEAR REGISTER
         D     R0,=F'60'                  DIVIDE OUT MINUTES
         CVD   R0,DOUBLE                  CONVERT MINUTES TO PACKED
         UNPK  3(3,R15),DOUBLE+6(2)       SAVE MINUTES
         OI    3+2(R15),C'0'              FIX SIGN BYTE
         MVI   3(R15),C':'                COLON
         CVD   R1,DOUBLE                  CONVERT MINUTES TO PACKED
         UNPK  0(3,R15),DOUBLE+6(2)       SAVE HOURS
         OI    0+2(R15),C'0'              FIX SIGN BYTE
         MVI   0(R15),C' '                LEADING SPACE
         BSM   0,R14                      Return to caller
*
** Point Register 15 to the first blank in a string
** Input:  R0  - Maximum length of the string
**         R15 - String
** Output: R15 - First space in the string
*
LOCATE_FIRST_SPACE DS 0H
         CLI   0(R15),C' '                Blank?
         BE    LFS$X                      Yes, leave
         LA    R15,1(R15)                 No, bump to next byte
         BCT   R0,LOCATE_FIRST_SPACE      ..Repeat
LFS$X    DS    0H
         BSM   0,R14                      Return to caller
*
** Convert micro seconds
**
** Input: R0-R1 containing value in microseconds
**
** Note: this routine borrowed from S.V. Petersen's IEFACTRT
*
CONVERT_MICRO_SECONDS DS 0H
         AL    R1,F5MSEC           round by 5 milliseconds
         BC    12,*+8
         AL    R0,FONE
         D     R0,F60MIL                       (R1) holds minutes
         CVD   R0,DOUBLE           microseconds to decimal <= 59999999
         LTR   R1,R1
         BZR   R14                 only seconds in result
         C     R1,F60
         BL    CVTMICS7            no hours in result
         SLR   R15,R15
         SLR   R0,R0
         C     R1,F1440
         BL    CVTMICS3            no days  in result
         D     R0,F1440                        (R1) holds days
         LR    R15,R1
         MH    R15,H100            ddd00
         SRDL  R0,32               remainder minutes back down to R1
CVTMICS3 D     R0,F60              (R1) = hh   (R0) = mm
         ALR   R1,R15                  dddhh        (in binary)
         MH    R1,H100                 dddhh00
         ALR   R1,R0                   dddhhmm
CVTMICS7 CVD   R1,DOUBLE2              dddhhmmC (now in decimal)
         SRP   DOUBLE2,8,0         shift 8 digits to left
         AP    DOUBLE,DOUBLE2      and combine with microseconds
         BSM   0,R14               (DOUBLE) = PL8'dddhhmmssthtxxxC'
         SPACE 2
F60MIL   DC    F'60000000'         microseconds/minute
F60HND   DC    F'6000'             centiseconds/minute
F5MSEC   DC    F'5000'             5 milliseconds in microseconds
FONE     DC    F'1'
F60      DC    F'60'               minutes/hour
F1440    DC    F'1440'             minutes/day
H10000   DC    H'10000'
H100     DC    H'100'
         DS    0H
*
** Format the CPU time in "hh:mm:ss.th" format
**
** Input: R1 has CPU time
**        R15 has output location
*
FORMAT_CPUTIME DS 0H
         ST    R15,DOUBLE2                Save output location
         SLR   R0,R0                      Clear for divide
         D     R0,=F'6000'                (R1) = mins
         LR    R15,R0                     centiseconds ssth  (binary)
         SLR   R0,R0                      Clear for divide
         D     R0,=F'60'                  (R0) mins (R1) = hours
         MH    R1,=H'100'                 hh00
         AR    R1,R0                      hhmm
         MH    R1,=H'10000'               hhmm0000
         ALR   R1,R15                     hhmmssth  (binary)
         CVD   R1,DOUBLE                  =PL8'0000000hhmmssthC'
         L     R15,DOUBLE2                Restore output location
         MVC   0(13,R15),=X'402120207A20207A20204B2020'
         ED    0(13,R15),DOUBLE+3         Edit the cpu time
         BSM   0,R14                      Return to caller
*
** Edit CPU time in IPOACTRT/SDSF format
** Input: R3 - CPU Time
** Output: R5 - Address of edited CPU time
**         R6 - Length of edited CPU time
*
EDIT_CPU_TIME EQU *
         CVD   R3,DOUBLE                  Convert CPU time to packed
         MVC   DOUBLE2(15),ECT$EPAT       Get edit pattern
         LA    R1,DOUBLE2+12              Locate past significant byte
         EDMK  DOUBLE2(15),DOUBLE+2       Edit and save start
         LA    R6,DOUBLE2+15              Locate end of time
         SR    R6,R1                      Length = end - start
         BCTR  R6,0                       Decrement for EX
         LR    R5,R1                      Save address of CPU time
         CLI   0(R5),C'.'                 Less than 1
         BNE   ECT$X                      No, continue
         BCTR  R5,0                       Backup 1
         LA    R6,1(R6)                   Increment length for "0"
         MVI   0(R5),C'0'                 Make cpu time "0.xx"
ECT$X    DS    0H
         BSM   0,R14                      Return to caller
ECT$EPAT DC    X'40,20,20,20,6B,20,20,20,6B,20,20,21,4B,20,20'
         DS    0H
*
** Obtain the Total CPU time from the SMF30 record: SRB+TCB
**
** Output:
** - T_TCB ... CPU (TCB)
** - T_SRB ... CPU (SRB)
** - R3    ... Total CPU (TCB+SRB)
*
R30CPU   EQU   *
         L     R1,IR_PARML              Get IEFACTRT parm list
         L     R1,@ACTRT_SMFREC-@ACTRT(R1) Locate SMF record
         SLR   R3,R3
         ICM   R3,B'0011',SMF30CLN-SMF30RPS(R1) Length of section
         BZ    R30C$X                     Not there, leave
         SLR   R3,R3                      Clear total
         ICM   R5,B'1111',SMF30COF-SMF30RPS(R1) Get offset to section
         BZ    R30C$X                     Not there, leave
         AR    R5,R1                      Get offset to CPU section
         SLR   R4,R4                      Clear Register
         ICM   R4,B'0011',SMF30CON-SMF30RPS(R1) # of CPU sections
         BZ    R30C$X                     No, exit
R30C$L   EQU   *
         A     R3,SMF30CPT-SMF30CAS(R5)   Add TCB CPU time
         L     R1,T_TCB
         A     R1,SMF30CPT-SMF30CAS(R5)
         ST    R1,T_TCB
*
         A     R3,SMF30CPS-SMF30CAS(R5)   Add SRB CPU time
         L     R1,T_SRB
         A     R1,SMF30CPS-SMF30CAS(R5)
         ST    R1,T_SRB
*
         LA    R5,SMF30IDT-SMF30CAS+L'SMF30IDT(R5) Locate next section
         BCT   R4,R30C$L                 Until no more...
R30C$X   EQU   *
         BSM   0,R14
*
** Edit register 1 flush
** Input: R1 - Value to edit
**        R15 - Where edited value is to be put
*
EDITFWF  EQU   *
         LTR   R1,R1                      CHECK FOR 0
         BZ    EDITFWF0                   YES, PUT ZERO
         ST    R14,EF_RA                  Save return address
         CVD   R1,DOUBLE                  NO, CONVERT TO PACKEC
         LA    R1,DOUBLE2+14              LOCATE SIG DIGIT
         MVC   DOUBLE2(15),EDITP15
EF$EDMK  EQU   *
         EDMK  DOUBLE2(15),DOUBLE+2       EDIT AND SAVE PLACE
         LA    R14,DOUBLE2+16             LOCATE LAST POSSIBLE BYTE + 1
         SR    R14,R1                     LENGTH = END - START
         BCTR  R14,0                      DECREMENT FOR EX
         EX    R14,EDITFWFM               MOVE EDIT NUMBER TO OUTPUT
         LA    R15,0(R14,R15)             BUMP POINTER PAST NUMBER
         MVI   0(R15),C' '                Fix unprintable character
         L     R14,EF_RA                  Get return address
         BSM   0,R14                      RETURN TO CALLER
EDITFWFM MVC   0(0,R15),0(R1)
EDITP15  DC    X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'
EDITFWF0 DS    0H
         MVI   0(R15),C'0'                PUT IN ZERO
         LA    R15,1(R15)                 BUMP POINTER PAST ZERO
         BSM   0,R14                      RETURN TO CALLER
*
** See if we are to ignore this job for Step/Job end messages
*
IGNORE_JOB EQU *
         CLI   FCC_CDE,C'S'               System ABEND?
         BE    IJ$X                       Let operator know...
         CLI   FCC_CDE,C'U'               User ABEND?
         BE    IJ$X                       Let operator know...
         LA    R1,IJ_TAB                  Locate table
         LA    R0,IJ_TABN                 Get number in table
         L     R15,IR_PARML             Get IEFACTRT parm list
         L     R15,@ACTRT_JMR-@ACTRT(R15)
IJ$L     EQU   *
         CLC   0(8,R1),JMRJOB-JMR(R15)    Jobname match?
         BE    EXIT                       Yes, skip to exit...
         LA    R1,8(R1)                   No, bump to next entry
         BCT   R0,IJ$L                        and process it
IJ$X     DS    0H
         BSM   0,R14                      Return to caller
*
IJ_TAB   EQU   *
         DC    CL8'DCCRDR  '              DCC job reader
         DC    CL8'DEALLOC '              Dealloc
         DC    CL8'DMSAR   '              DMS Auto Recall
         DC    CL8'INIT    '              JES2 Initiators
         DC    CL8'RECALLO '              FDR recall
         DC    CL8'X       '              Dealloc
         DC    CL8'JES2    '              Don't mess with JES2!
IJ_TABN  EQU   (*-IJ_TAB)/8
         DS    0H
         EJECT
***********************************************************************
***                                                                 ***
** Convert input binary time and packed decimal julian date to a     **
** fancy output string of "dd-mmm-ccyy hh:mm:ss pm"                  **
**                                                                   **
** Input: R0 - Time in binary                                        **
**        R1 - Date in packed decimal                                **
**        R15 - points to the output area                            **
**                                                                   **
** Output: the area in R15 will be filled in and R15 updated with    **
**         address just past the filled in area.                     **
***                                                                 ***
***********************************************************************
         SPACE 2
CONVERT_TO_TODSTRING DS 0H
         ST    R15,CTT_OUT                Save output area address
         ST    R14,CTT_RA                 Save return address
*
** Get the input time (binary) and date (packed decimal) and convert
** it to a STCK TOD format
*
         LA    R14,CTT_CIN                Locate routine Time/Date area
         XC    0(CTAREAL,R14),0(R14)      Clear to binary zeros
         STCM  R0,B'1111',CTAREA_TIME-CTAREA(R14) Save Time
         STCM  R1,B'1111',CTAREA_DATE-CTAREA(R14) Save Date
*
         CONVTOD CONVVAL=CTT_CIN,         Convert this Time/Date       @
               TODVAL=CTT_TOD,            ..To TOD format              @
               TIMETYPE=BIN,              ..Time is binary format      @
               DATETYPE=YYDDD,            ..Date is julian 0CYYDDDf    @
               MF=(E,PARMLIST)
         LTR   R15,R15                    CONVTOD worked?
         BNZ   CTT$ERRC                   Failed, do primitive way
*
** Convert the TOD stamp into time and date formats
*
         STCKCONV STCKVAL=CTT_TOD,        Convert this TOD Stamp       @
               CONVVAL=CTT_SOUT,          ..Into these date/time areas @
               TIMETYPE=DEC,              ..Output time format         @
               DATETYPE=DDMMYYYY,         ..Output Date format         @
               MF=(E,PARMLIST)
         LTR   R15,R15                    CONVTOD worked?
         BNZ   CTT$ERRS                   Failed, do primitive way
*
** Format the date
*
         L     R15,CTT_OUT                Locate output area
*                               D  D  -  M  M  -  C  C  Y  Y
         MVC   0(11,R15),=X'40,20,20,60,20,20,60,20,20,20,20'
         ED    0(11,R15),CTT_SOUT+8       Edit it to " dd-mm-ccyy"
         MVC   0(3,R15),1(R15)            Move "dd-" over "dd-...-ccyy"
         PACK  DOUBLE(8),4(2,R15)         Get month in decimal
         CVB   R14,DOUBLE                 Convert to binary
         BCTR  R14,0                      Make relative to zero
         MH    R14,=H'3'                  Multiply for month offset
         LA    R1,=C'JanFebMarAprMayJunJulAugSepOctNovDec'
         AR    R1,R14                     Locate month entry
         MVC   3(3,R15),0(R1)             Move "mmm" to "dd-mmm-ccyy"
         OI    0(R15),X'F0'               Ensure leading zero
         LA    R15,11(R15)                Bump past date
*
** Format the Time: " hh:mm:ss AM"
*
CTT$TIME DS    0H
         L     R1,CTT_CIN+(CTAREA_TIME-CTAREA) Get time
         SLR   R0,R0                      CLEAR REGISTER
         D     R0,=F'100'                 DIVIDE OUT 100THS OF SECOND
         SLR   R0,R0                      CLEAR REGISTER
         D     R0,=F'60'                  DIVIDE OUT SECONDS
         CVD   R0,DOUBLE                  CONVERT SECONDS TO PACKED
         UNPK  6(3,R15),DOUBLE+6(2)       SAVE SECONDS
         OI    6+2(R15),C'0'              FIX SIGN BYTE
         MVI   6(R15),C':'                COLON
         SLR   R0,R0                      CLEAR REGISTER
         D     R0,=F'60'                  DIVIDE OUT MINUTES
         CVD   R0,DOUBLE                  CONVERT MINUTES TO PACKED
         UNPK  3(3,R15),DOUBLE+6(2)       SAVE MINUTES
         OI    3+2(R15),C'0'              FIX SIGN BYTE
         MVI   3(R15),C':'                COLON
         MVC   10(2,R15),=C'AM'           Set default
         CH    R1,=H'12'                  In AM range?
         BNH   CBT$PMX                    Yes, continue
         MVI   10(R15),C'P'               Make it "PM"
         SH    R1,=H'12'                  Standard = Military - 12
CBT$PMX  DS    0H
         CVD   R1,DOUBLE                  CONVERT MINUTES TO PACKED
         UNPK  0(3,R15),DOUBLE+6(2)       SAVE HOURS
         OI    0+2(R15),C'0'              FIX SIGN BYTE
         MVI   0(R15),C' '                LEADING SPACE
         LA    R15,12(R15)                Bump past time
*
** Return to caller
*
CTT$X    DS    0H
         L     R14,CTT_RA                 Get return address
         BSM   0,R14                      Return to caller
*
** Error: either the CONVTOD or STCKCON failed, so display the
** date in julian
*
CTT$ERRC DS    0H
         L     R15,CTT_OUT                Locate output area
         MVI   10(R15),C'C'               Let the sysprog know failer
         B     CTT$ERR
CTT$ERRS DS    0H
         L     R15,CTT_OUT                Locate output area
         MVI   10(R15),C'S'               Let the sysprog know failer
CTT$ERR  DS    0H
         UNPK  DOUBLE2(9),#CTTPMD(5)           *
         MVZ   DOUBLE2(8),=8X'00'              ** Hex convert
         TR    DOUBLE2(8),=C'0123456789ABCDEF' *
         MVC   0(2,R15),DOUBLE2+2         Get yy from "0cyydddf"
         MVI   2(R15),C'.'                Insert dot
         MVC   3(3,R15),DOUBLE2+4         Get ddd from "0cyydddf"
         LA    R15,12(R15)                Locate past date area
         B     CTT$TIME                   Format the time as usual
#CTTPMD  EQU   CTT_CIN+(CTAREA_DATE-CTAREA)    Generate offset
         EJECT ,
***********************************************************************
***                                                                 ***
**   Format condition code for SMF 30 records into FCC_CDE field     **
***                                                                 ***
***********************************************************************
         SPACE 2
FORMAT_COND_CODE EQU *
         MVC   FCC_CDE(5),=CL5'n/a'       If something goes wrong...
*
** Locate record
*
         L     R15,IR_PARML             Get IEFACTRT parm list
         L     R15,@ACTRT_SMFREC-@ACTRT(R15) Locate SMF Record
         SLR   R1,R1                      Clear register
         ICM   R1,B'0011',SMF30TON-SMF30RPS(R15)  Number of comp. sect.
         BZ    FCC$X                      Zero? ignore it
         ICM   R1,B'0011',SMF30TLN-SMF30RPS(R15)  Length of comp. sect.
         BZ    FCC$X                      Zero? ignore it
         ICM   R4,B'1111',SMF30TOF-SMF30RPS(R15)  OFFSET TO COMP SECT
         BZ    FCC$X                      Zero? ignore it
         AR    R4,R15                     LOCATE COMP SECTION
*
** Flushed?
*
         TM    SMF30STI-SMF30CMP(R4),SMF30FLH Was the step flushed
         BNO   FCC$FX                     No, continue
         MVC   FCC_CDE(5),=C'FLUSH'       Set field
         B     FCC$X                      LEAVE
FCC$FX   EQU   *
*
         SLR   R0,R0
         ICM   R0,B'0011',SMF30SCC-SMF30CMP(R4)  Get Condition code
*
** Process non-ABENDs
*
         TM    SMF30STI-SMF30CMP(R4),SMF30ABD Did it ABEND?
         BO    FCC$ABND                   Yes, print ABEND code
         N     R0,=A(X'FFF')              Zero unused portion
         CVD   R0,DOUBLE                  Convert condcode to Packed
         MVC   FCC_CDE-2(6),=X'40,21,20,20,20,20'
         ED    FCC_CDE-2(6),DOUBLE+5
         B     FCC$X                      Leave
*
** Format ABENDs
*
FCC$ABND EQU   *
         TM    SMF30SCC-SMF30CMP(R4),X'80' User ABEND?
         BNO   FCC$SAB                    No, System ABEND
         N     R0,=A(X'FFF')              Turn off unneeded bits
         CVD   R0,DOUBLE                  Convert to packed decimal
         MVC   FCC_CDE-1(L'FCC_CDE+1),=X'40,21,20,20,20,20'
         ED    FCC_CDE-1(L'FCC_CDE+1),DOUBLE+5
         MVI   FCC_CDE,C'U'               Make it a user ABEND
         B     FCC$X                      Leave
*
FCC$SAB  EQU   *
         STH   R0,DOUBLE                  Save system ABEND code
         UNPK  FCC_CDE+1(4),DOUBLE(3)
         MVZ   FCC_CDE+1(3),=X'00,00,00'
         TR    FCC_CDE+1(3),=C'0123456789ABCDEF'
         MVI   FCC_CDE+4,C' '             Fix overflow
         MVI   FCC_CDE,C'S'               Make it a system ABEND
*
** Common Exit from FORMAT_CONDITION_CODE
*
FCC$X    EQU   *
         BSM   0,R14
         EJECT
***********************************************************************
***                                                                 ***
**       Constants                                                   **
***                                                                 ***
***********************************************************************
         SPACE 2
MSG110   DC    C'XYZ110E Error calling MVS/Quickref, RC:'
MSG110L  EQU   *-MSG110
MSG111   DC    C'XYZ111I',25C'-'
         DC    C'Start of ABEND information from MVS/Quickref'
MSG111L  EQU   *-MSG111
MSG112   DC    C'XYZ112I',27C'-'
         DC    C'End of ABEND information from MVS/Quickref'
MSG112L  EQU   *-MSG112
MSG113   DC    C'XYZ113W Hit MVS/Quickref output limit: '
         DC    C'not all lines shown. '
MSG113L  EQU   *-MSG113
MSG114   DC    C'XYZ114I Refer to the IBM "MVS Systems and Codes" '
         DC    C'manual or MVS/Quickref online (TSO and Roscoe) '
         DC    C'for more information.'
MSG114L  EQU   *-MSG114
MSG115   DC    C'XYZ115I ABEND information from MVS/Quickref '
         DC    C'was written to SYSMSGS'
MSG115L  EQU   *-MSG115
MSG116   DC    C'XYZ116I MVS/Quickref version could not be determined'
MSG116L  EQU   *-MSG116
*
MSG117   DC    C'XYZ117I IEFACTRT does not yet support MVS/Quickref at'
MSG117L  EQU   *-MSG117
*
MSG120   DC    C'XYZ120I ',72C'-'    Step End stats - Start
MSG120L  EQU   *-MSG120
MSG121   EQU   *-*                   Step End stats - End
MSG122   EQU   *-*                   Job End Stats - End
*
EDPAT4   DC    X'40,20,20,20'
EDPAT12  DC    X'40,20,20,20,6B,20,20,20,6B,20,21,20'
*
C_WTO    WTO   '                                                       @
                                         ',MF=L
C_WTOL   EQU   *-C_WTO
*
C_EXCPT  DC    CL(EOEL)' '
         ORG   C_EXCPT+(EOE_UNIT-EOE)
         DC    C'Unit--'
         ORG   C_EXCPT+(EOE_DDNAME-EOE)
         DC    C'DDName--'
         ORG   C_EXCPT+(EOE_COUNT-EOE)
         DC    C'EXCP Count--'
         ORG   C_EXCPT+(EOE_BLKSIZE-EOE)
         DC    C'Blksize'
         ORG   ,
C_EXCPTL EQU   *-C_EXCPT
#EOETL   EQU   EOEL                     Test length against C_EXCPTL
*
C_ENDSTS  DC   C'S t e p   '
C_ENDST   DC   C'E n d   S t a t i s t i c s'
C_ENDSTL  EQU  *-C_ENDST
C_ENDSTSL EQU  *-C_ENDSTS
*
** Literals
*
LTORG    EQU   *
         LTORG ,
LTORGL   EQU   *-LTORG
         DS    0D
*
** Determine length left addressible in IEFACTRT CSECT
*
#IEFACTRT EQU  *-IEFACTRT               Bytes used
#IEFACTRT_LEFT EQU (4096*3)-#IEFACTRT   Bytes left
         EJECT
***********************************************************************
***                                                                 ***
**       IEFACTRT GETMAINed work area                                **
***                                                                 ***
***********************************************************************
         SPACE 2
$DSA_SP  EQU   252                      Sub-pool: Low private
DSA      DSECT ,
         DS    18F                      Register Save Area
DSAEC    DS    CL16
DSAGLEN  DS    F                        Length of DSA work area
IREGS    DS    0F                       Input registers
IR_CODE  DS    F                        ..Code
IR_PARML DS    F                        ..CEPA address
EF_RA    DS    F                        EDITFWF return address
         DS    0D
DOUBLE   DS    D                        Double word work area
DOUBLE2  DS    2D                       Double word work area * 2
PARMLIST DS    XL128                    Work area for parm lists
*
** The following area from DSA_IS to DSA_IL is intialized to binary
** zeros at startup.
*
DSA_IS   EQU   *                        Start of area to init to zero
         DS    0D                       Convert_To_TODSTring
CTT_TOD  DS    D                        ..TOD (STCK) area
CTT_OUT  DS    F                        ..Output area address
CTT_RA   DS    F                        ..Return address
CTT_CIN  DS    XL(CTAREAL)              ..CONVTOD input area
CTT_SOUT DS    XL16                     ..STCKCON output area
*
         DS    0F
QW_REPA  DS    F                        Entry point for Quickref pgm
QW_VER   DS    C'x.xx'                  Version of Quickref
A_IDSECT DS    F                        Address of SMF30 ID section
A_STSECT DS    F                        Address of SMF30 Stor section
A_PRSECT DS    F                        Address of SMF30 Perf section
T_SRB    DS    F                        Total: SRB CPU time
T_TCB    DS    F                        Total: TCB CPU time
T_DASD   DS    F                        Total: DASD EXCPs
T_TAPE   DS    F                        Total: Tape EXCPs
FLAG1    DS    B'00000000'              Flag 1
$F1_EXCP EQU   B'10000000'              ..Found a good EXCP section?
$F1_PAGT EQU   B'01000000'              ..Paging title?
$F1_NQW  EQU   B'00100000'              ..No Quickref?
*                                       Format_Condition_Code
FCC_QW   DS    XL2                      ..Quickref length
FCC_PREC DS    CL2                      ..Needed for WRCODE + Quickref
FCC_CDE  DS    CL5                      ..Return code
DSA_IL   EQU   *-DSA_IS
*
** Misc work areas
*
WLINE    DS    CL132                    Work area for IEFYS and WTOs
WLINEL   EQU   *-WLINE
         ORG   WLINE                    Reuse work area
QW_RTEXT DS    XL(#RTRAL+64)            Text return area + slack
         ORG   ,
         DS    0D
DSAL     EQU   *-DSA
         EJECT
***********************************************************************
***                                                                 ***
**       Program Equates                                             **
***                                                                 ***
***********************************************************************
         SPACE 2
*
** Standard register equates
*
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
*
** Area passed to IEFACTRT
*
@ACTRT          DSECT ,
@ACTRT_JMR      DS    F          Parm  1 -> Common Exit Parm: JMR
@ACTRT_STEPNAME DS    F          Parm  2 -> Step name
@ACTRT_PGRMNAME DS    F          Parm  3 -> Programmer Name
@ACTRT_JOBTIME  DS    F          Parm  4 -> Job CPU time / # Acct
@ACTRT_JOBACCT  DS    F          Parm  5 -> Job Account information
@ACTRT_STEPTIME DS    F          Parm  6 -> Step CPU time  / # acct
@ACTRT_STEPACCT DS    F          Parm  7 -> Step Account information
@ACTRT_JOBFLAG  DS    F          Parm  8 -> Flags
@ACTRT_TERMCODE DS    F          Parm  9 -> Termination Status
@ACTRT_SMFREC   DS    F          Parm 10 -> SMF record
@ACTRT_JCPUT4   DS    F          Parm 11 -> Job CPU time
@ACTRT_SCPUT4   DS    F          Parm 12 -> Step CPU time
@ACTRT_SUBS     DS    F          Parm 13 -> Name of subsystem
*
** Output area for Step End Statistics Information
*
SESI            DSECT ,
SESIC1          EQU   *
SESIC1D         DS    C'Step Name: '
SESIC1V         DS    CL8' '
                DS    CL7' '
SESIC2          EQU   *
SESIC2D         DS    C'Cond Code: '
SESIC2V         DS    CL8' '
SESIC2L         EQU   *-SESIC2
                DS    CL5' '
SESIC3          EQU   *
SESIC3DT        DS    C'Start: '
SESIC3VT        DS    C'06-MAR-1962 07:05:02 PM'
SESIC3L         EQU   *-SESIC3
                ORG   SESIC3
SESIC3DST       DS    C'Storage '
SESIC3DSL       DS    C'above '
SESIC3DSM       DS    C'16M:'
SESIC3VS        DS    CL11'xxxxxxxxxxx'
SESIC3VSK       DS    C'k'
                ORG   ,
WLINE_SESIC1D   EQU   WLINE+(SESIC1D-SESI)
WLINE_SESIC1V   EQU   WLINE+(SESIC1V-SESI)
WLINE_SESIC2D   EQU   WLINE+(SESIC2D-SESI)
WLINE_SESIC2V   EQU   WLINE+(SESIC2V-SESI)
WLINE_SESIC2L   EQU   WLINE+(SESIC2L-SESI)
WLINE_SESIC3DT  EQU   WLINE+(SESIC3DT-SESI)
WLINE_SESIC3VT  EQU   WLINE+(SESIC3VT-SESI)
WLINE_SESIC3DST EQU   WLINE+(SESIC3DST-SESI)
WLINE_SESIC3DSL EQU   WLINE+(SESIC3DSL-SESI)
WLINE_SESIC3DSM EQU   WLINE+(SESIC3DSM-SESI)
WLINE_SESIC3VS  EQU   WLINE+(SESIC3VS-SESI)
WLINE_SESIC3VSK EQU   WLINE+(SESIC3VSK-SESI)
*
** Output area for Job End Statistics Information
*
JESI            DSECT ,
JESIC1          EQU   *
JESIC1D         DS    C'Job  Name: '
JESIC1V         DS    CL11'00:00:00.00'
                DS    CL4' '
JESIC2          EQU   *
JESIC2D         DS    C'System ID: '
JESIC2V         DS    CL8' '
JESIC2L         EQU   *-JESIC2
                DS    CL4' '
JESIC3          EQU   *
JESIC3DT        DS    C'Submit: '
JESIC3VT        DS    C'06-MAR-1962 19:05:02:15'
JESIC3L         EQU   *-JESIC3
                ORG   JESIC3
JESIC3DST       DS    C'Storage '
JESIC3DSL       DS    C'above '
JESIC3DSM       DS    C'16M:'
                DS    C
JESIC3VS        DS    CL11'xxxxxxxxxxx'
JESIC3VSK       DS    C'k'
                ORG   ,
WLINE_JESIC1D   EQU   WLINE+(JESIC1D-JESI)
WLINE_JESIC1V   EQU   WLINE+(JESIC1V-JESI)
WLINE_JESIC2D   EQU   WLINE+(JESIC2D-JESI)
WLINE_JESIC2V   EQU   WLINE+(JESIC2V-JESI)
WLINE_JESIC2L   EQU   WLINE+(JESIC2L-JESI)
WLINE_JESIC3    EQU   WLINE+(JESIC3-JESI)
WLINE_JESIC3DT  EQU   WLINE+(JESIC3DT-JESI)
WLINE_JESIC3VT  EQU   WLINE+(JESIC3VT-JESI)
WLINE_JESIC3DST EQU   WLINE+(JESIC3DST-JESI)
WLINE_JESIC3DSL EQU   WLINE+(JESIC3DSL-JESI)
WLINE_JESIC3DSM EQU   WLINE+(JESIC3DSM-JESI)
WLINE_JESIC3VS  EQU   WLINE+(JESIC3VS-JESI)
WLINE_JESIC3VSK EQU   WLINE+(JESIC3VSK-JESI)
*
** Map CONVTOD area
*
CTAREA          DSECT ,
CTAREA_TIME     DS    XL4
                DS    XL4
CTAREA_DATE     DS    XL4
                DS    XL4
CTAREAL         EQU   *-CTAREA
*
** Map EXCP Output Entry
*
EOE             DSECT ,
EOE_UNIT        DS    C'00B1'           Obi-Wan
                DS    C
EOE_TYPE        DS    C
                DS    C
EOE_DDNAME      DS    CL8'Kenobi'
                DS    C
EOE_COUNT       DS    CL12
                DS    C
EOE_BLKSIZE     DS    CL7
EOEL            EQU   *-EOE
*
** End of IEFACTRT
*
                END   ,
./ ADD NAME=IEFUJV   0100-98016-98016-1800-00267-00267-00000-DALCOCK
IEFUJV   TITLE 'SMF Job validation SMF exit'
IEFUJV   CSECT ,
IEFUJV   AMODE 31
IEFUJV   RMODE ANY
***********************************************************************
***                                                                 ***
**  Name: IEFUJV                                                     **
**                                                                   **
**  Description: SMF Job Validation Exit                             **
**                                                                   **
**  Purpose: Selectively place SWA control blocks above the line     **
**           for some jobs.                                          **
**                                                                   **
**           Fill in company code of Account fields if "_"           **
**           - For example:   //DTSO666D JOB (_,_,_,SYS)             **
**             Changed to:    //DTSO666D JOB (D,D,D,SYS)             **
**           - Note: The C/I doesn't allow JES2 EXIT 6 to fill in    **
**                   these underscores so we do them here.           **
**                                                                   **
**  Limitations:                                                     **
**  Uses equates from IEFTXTFT and IEFNEL for equates. They          **
**  match but the SMF manual does not specify to use it:             **
**     o Parm 3 points to STRINDCS in MACRO IEFTXTFT                 **
**     o Parm 4 points to NELPARMO in MACRO IEFNEL                   **
***                                                                 ***
***********************************************************************
         SPACE 2
***********************************************************************
***                                                                 ***
**           M o d i f i c a t i o n   H i s t o r y                 **
**                                                                   **
**                                                                   **
** Date        Person   Description                                  **
** ----------- -------- -------------------------------------------- **
** 27-JUN-1996 DAlcock  Add Roscoe to the SWA=ABOVE;                 **
** 11-NOV-1993 DAlcock  Move JCL standards validation to JES2 exit 6;**
**                      This exit performs the following:            **
**                      > Fill in company code in account field of   **
**                        job card if underscore                     **
**                      > Place SWA above the line for selected jobs;**
***                                                                 ***
***********************************************************************
         EJECT ,
         SAVE  (14,12),,XYZ_SMFEXIT_IEFUJV_&SYSDATE._&SYSTIME
         USING IEFUJV,R12                 Set up addressability
         LR    R12,R15                    Get our base register
         SLR   R15,R15                    Set default return code
*
*    R3 = Address of Common Parameter Exit Area (IEFJMR)
*    R4 = Address of 80 byte JCL text area
*    R5 = Address of entry code byte (STRINDCS in IEFTXTFT)
*    R6 = Address of JES initialization parms (NELPARMO in IEFNEL)
*
         LM    R3,R6,0(R1)                Load input parameters
         USING JMR,R3                     Set addressability to JMR
*
** Branch on type of JCL statement
*
         CLI   0(R5),JOBSTR               Is this a job card?
         BE    PROCESS_JOB_CARD           Yes, continue
*
** Common exit from USRUJI
*
EXIT     EQU   *
         RETURN (14,12),RC=(15)           Return to caller
         DS    0H
         EJECT
***********************************************************************
***                                                                 ***
**       Process job card JCL statements                             **
***                                                                 ***
***********************************************************************
         SPACE 2
PROCESS_JOB_CARD EQU *
         CLI   2(R4),C' '                 Job card continuation?
         BE    PJC$X                      Yes, don't process...
         TM    JMRINDC,JMRFIND            TSO?
         BO    PJC$X                      Yes, verification by ACF2
         SLR   R10,R10                    Set flag register to zeros
*
** Check for debugging job
*
         CLC   JMRJOB(8),=C'ibmuserZ'     Debugging job?
         BNE   PJC$DBCX                   No, continue
         ICM   R10,B'1000',=X'FF'         We need a message...
PJC$DBCX EQU   *
*
** Fill in company codes in accounting fields that have underscores
*
         LR    R1,R4                      Locate paren addr after TRT
         TRT   0(80,R4),T_PAREN           Look for an open paren
         BM    PJC$UPF                    Found it?
         B     PJC$UX                     No, leave
PJC$UPF  EQU   *
         LA    R1,1(R1)                   Locate past open paren
         BAS   R14,PJC$FILL               Fill in underscore if found
         LA    R7,79(R4)                  Locate end of card
         SR    R7,R4                      Set length for rest of card
         EX    R7,PJC$COMC                Locate next comma
         LA    R1,1(R1)                   Bump past comma
         BAS   R14,PJC$FILL               Fill in underscore if found
         LA    R7,79(R4)                  Locate end of card
         SR    R7,R1                      Set length for rest of card
         EX    R7,PJC$COMC                Locate next comma
         LA    R1,1(R1)                   Bump past comma
         BAS   R14,PJC$FILL               Fill in underscore if found
PJC$UX   EQU   *
*
** Search for jobs that need SWA control blocks allocated above the
** 16 meg line
*
PJC$SCLS EQU   *
         LA    R7,T_SWA                   Locate SWA table
         LA    R8,T_SWAN                  Get number in table
         SLR   R9,R9                      Clear register
PJC$SCL  EQU   *
         IC    R9,0(R7)                   Get length
         EX    R9,PJC$SCCJ                Match?
         BE    PJC$SCLX                   Yes, leave
         LA    R7,1+8(R7)                 No, Bump to next entry
         BCT   R8,PJC$SCL                 Do it
*                                         Job is not in table -------
         CLM   R10,B'1000',=X'FF'         Debugging job?
         BE    PJC$WTO                    Yes, need WTO anyway
         B     PJC$X                      No, leave
*
PJC$SCCJ CLC   1(0,R7),JMRJOB             ** Executed **
*
PJC$SCLX EQU   *
         OI    0(R6),NELXA2               Set SWA Above
         ICM   R10,B'0100',=X'FF'         We need a message...
*
** Initialize work area
*
PJC$WTO  EQU   *
         GETMAIN R,LV=DSAL,SP=241         Obtain storage
         LR    R11,R1                     Locate work area
         USING DSA,R11                    Get addressibility to it
         ST    R13,SAVEAREA+4             Chain save area
         ST    R11,8(,R13)                Save save area
         LR    R13,R11                    Locate new Save area
*
** Issue WTO message for debugging job
*
         CLM   R10,B'1000',=X'FF'         Debugging job?
         BNE   PJC$DBMX                   Yes, need WTO anyway
         WTO   E,MF=(E,MSG169)            Yes, issue message
PJC$DBMX EQU   *
*
** Print WTO to say we changed the SWA to above the line
*
         CLM   R10,B'0100',=X'FF'         Changed SWA?
         BNE   PJC$SMX                    No, continue
         WTO   E,MF=(E,MSG168)            Yes, issue message
PJC$SMX  EQU   *
*
** Free work area
*
         L     R13,SAVEAREA+4             Unchain work area
         FREEMAIN R,LV=DSAL,SP=241,A=(11) Free work area
         SLR   R15,R15                    Set return code to zero
*
** Common exit (if no GETMAIN) from Process_Job_Card processing
*
PJC$X    EQU   *
         B     EXIT                       Let's end this party
*
** Fill in underscores with the first character of the jobname
*
PJC$FILL EQU   *
         CLI   0(R1),C'_'
         BNE   PJC$FILLX
         MVC   0(1,R1),JMRJOB
PJC$FILLX EQU  *
         BSM   0,R14
*
PJC$COMC TRT   0(*-*,R1),T_COMMA          TRT for commas in acct field
         EJECT
***********************************************************************
***                                                                 ***
**       Constants                                                   **
***                                                                 ***
***********************************************************************
         SPACE 2
*
** SWA above the line table
*
T_SWA    EQU   *
         DC    AL1(8-1),CL8'ibmuserZ'     David Alcock test job
         DC    AL1(8-1),CL8'ibmuserX'     David Alcock test job
         DC    AL1(4-1),CL8'DIDM'         IDMS CVs
         DC    AL1(4-1),CL8'IDMS'         IDMS CVs
         DC    AL1(6-1),CL8'ROSCOE'       Roscoe
T_SWAN   EQU   (*-T_SWA)/9
         DS    0H                         Half word boundry
*
** Constants
*
MSG168   WTO   'XYZ168I SWA Control Blocks will be placed above the lin@
               e',                                                     @
               ROUTCDE=(12),MCSFLAG=HRDCPY,MSGTYP=JOBNAMES,MF=L
MSG169   WTO   'XYZ169I IEFUJV assembled on &SYSDATE at &SYSTIME',     @
               ROUTCDE=(12),MCSFLAG=HRDCPY,MSGTYP=JOBNAMES,MF=L
*
** Translate tables for parsing
*
         DS    0D
T_PAREN  DC    256XL1'00'
         ORG   T_PAREN+C'('
         DC    C'('
         ORG
T_COMMA  DC    256XL1'00'
         ORG   T_COMMA+C','
         DC    C','
         ORG
         EJECT
***********************************************************************
***                                                                 ***
**       Dynamic Save Area                                           **
***                                                                 ***
***********************************************************************
         SPACE 2
DSA      DSECT ,
SAVEAREA DS    18F                        Register Save Area
*
*-> Put other fields here
*
         DS    0D
DSAL     EQU   *-DSA                      End of DSA area
         EJECT
***********************************************************************
***                                                                 ***
**       Equates                                                     **
***                                                                 ***
***********************************************************************
         SPACE 2
*
** Register Equates
*
R0       EQU   00                      REGISTER 0
R1       EQU   01                      REGISTER 1
R2       EQU   02                      REGISTER 2
R3       EQU   03                      REGISTER 3
R4       EQU   04                      REGISTER 4
R5       EQU   05                      REGISTER 5
R6       EQU   06                      REGISTER 6
R7       EQU   07                      REGISTER 7
R8       EQU   08                      REGISTER 8
R9       EQU   09                      REGISTER 9
R10      EQU   10                      REGISTER 10
R11      EQU   11                      REGISTER 11
R12      EQU   12                      REGISTER 12
R13      EQU   13                      REGISTER 13
R14      EQU   14                      REGISTER 14
R15      EQU   15                      REGISTER 15
         EJECT
***********************************************************************
***                                                                 ***
**       External DSECTs                                             **
***                                                                 ***
***********************************************************************
         SPACE 2
         CVT   DSECT=YES,LIST=NO         CVT
         IEFJMR ,                        CEPA - Job Management Record
         IEFNEL SUBCOM=C                  Converter Parameters
         IEFTXTFT                         Converter Text format
         END   ,
./ ADD NAME=IEFUSI   0100-98016-98016-1800-00543-00543-00000-DALCOCK
IEFUSI   TITLE 'Step initialization SMF exit'
***********************************************************************
***                                                                 ***
** Name = IEFUSI                                                     **
**                                                                   **
** Author = David Alcock                                             **
**          Central and South West Services                          **
**                                                                   **
** Purpose = SMF step initialization exit                            **
**                                                                   **
** Reference = GC28-1637 MVS/ESA Installation Exits                  **
**                                                                   **
** Input: R1 points to:                                              **
**        +00 Address of common parameter exit (JMR)                 **
**        +04 Address of 8-BYTE area containing job step name        **
**        +08 Address of 8-BYTE area containing program name         **
**        +12 Address of area containing accounting information      **
**        +16 Address of Six-word area containing region limits      **
**        +20 Address of word containing performance group number    **
***                                                                 ***
***********************************************************************
         SPACE 2
***********************************************************************
***                                                                 ***
**           M o d i f i c a t i o n   H i s t o r y                 **
**                                                                   **
** Person     Date        Description                                **
** ---------- ----------- ------------------------------------------ **
** DGAlcock   20-DEC-1997 Added extra entries and debugging code;    **
** DGAlcock   14-MAR-1997 Added check for the program name to be     **
**                        passed to IEFUTL;  Add check for job type  **
**                        for quickouts for APPC and SYS addr spaces;**
** DGAlcock   30-MAR-1996 Added Data Space and HiperSpace processing **
**                        (no production users yet);                 **
** DGAlcock   11-NOV-1994 Moved region table to separate CSECT for   **{
**                        external program perusal;                  **
** DGAlcock   20-OCT-1993 Set region size for large users;           **
***                                                                 ***
***********************************************************************
         EJECT
         XYZMFX ,                         Map XYZ SMFexit area
         IEFUSI#T ,                       Map IEFUSI#T CSECT areas
         IEFJMR ,                         Job Management Record
         YREGS ,                          Register Equates
*
** Generate debugging job name
*
         GBLC  &DBGJNME                Generate global variable
&DBGJNME SETC  'ibmuserZ'              ..Jobname for debugging info
*
** Using the official ASMH/HLASM distinction trick, simulate the
** SYSVER and SYSDATEC variables of HLASM when assembled under
** ASMH...Taken from Gilbert Saint-flour's SHOWMVS.
*
         LCLA  &ASMH_HLASM
         AIF   (T'&ASMH_HLASM EQ 'N').ASMH1X
&SYSVER  SETC  'ASMH'
&SYSDATC SETC  '20'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)
         AIF   ('&SYSDATC' LT '20500000').ASMH1X
&SYSDATC SETC  '19'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)
.ASMH1X  ANOP
*-Convert assembly date from SYSDATC format "YYYYMMDD" to "YYYY-MM-DD"
         LCLC  &ASMDATE
&ASMDATE SETC  '&SYSDATC'(1,4).'-'.'&SYSDATC'(5,2).'-'.'&SYSDATC'(7,2)
         EJECT
***********************************************************************
***                                                                 ***
**       Entry                                                       **
***                                                                 ***
***********************************************************************
         SPACE 2
IEFUSI   CSECT ,
IEFUSI   AMODE 31
IEFUSI   RMODE ANY
*
** Entry housekeeping
*
         SAVE  (14,12),,XYZ_SMFEXIT_IEFUSI_&ASMDATE._&SYSTIME
         LR    R12,R15                    Load program base register
         USING IEFUSI,R12                 Establish base for program
*
         LR    R3,R1                      Save address of parms
         USING @USI,R3                    Get addressiblity to map
*
** Determine address space type and leave if we don't need this type
*
         L     R14,@USI_SUBS              Locate subsystem type
         CLC   0(4,R14),=C'ASCH'          APPC?
         BE    X$QUICKOUT
         CLC   0(3,R14),=C'SYS'           System Address Space?
         BE    X$QUICKOUT
*
** Obtain dynamic storage area for IEFUSI use only.
*
         LA    R0,DSAL                    Generate length
       GETMAIN RU,                        Get Dynamic work area        @
               LV=(0),                    ..Length                     @
               SP=$DSA_SP,                ..Subpool: Low Private       @
               LOC=BELOW                  ..Below the line
*
         ST    R13,4(,R1)                 Save caller's RSA pointer
         ST    R1,8(,R13)                 Save my RSA pointer
         LR    R13,R1                     Locate storage for exit usage
         USING DSA,R13                    Establish addressability
         ST    R0,DSAGLEN                 Save length GETMAINed
*
         L     R2,@USI_JMR                -> JMR
         USING JMR,R2                     Get addressiblity to map
*
** Issue message for debugging job
*
         CLI   JMRSTEP,1                  First step?
         BNE   I$DBX                      No, continue
         CLC   JMRJOB(8),=C'&DBGJNME'     Debugging job?
         BNE   I$DBX                      No, continue
         LA    R15,WTOAREA                Locate WTO work area
         MVC   0(C_WTOL,R15),C_WTO        Initialize WTO area
         LA    R15,4(R15)                 Bump past WTO overhead
         MVC   0(MSG192L,R15),MSG192      Get WTO text
         ST    R12,DOUBLE                 Save IEFUSI EP for later
         UNPK  MSG192EP-MSG192(9,R15),DOUBLE(5)
         MVZ   MSG192EP-MSG192(8,R15),=8X'00'
         TR    MSG192EP-MSG192(8,R15),=C'0123456789ABCDEF'
         MVI   MSG192EP+8-MSG192(R15),C','
         L     R1,=V(IEFUSI#T)            Locate CSECT
         LA    R1,ZAPENTRY-IEFUSI#T(R1)   Locate to first zap entry
         ST    R1,DOUBLE
         UNPK  MSG192Z-MSG192(9,R15),DOUBLE(5)
         MVZ   MSG192Z-MSG192(8,R15),=8X'00'
         TR    MSG192Z-MSG192(8,R15),=C'0123456789ABCDEF'
         MVI   MSG192Z+8-MSG192(R15),C' '
         WTO   ,MF=(E,WTOAREA)            Issue the WTO message
I$DBX    EQU   *
         EJECT
***********************************************************************
***                                                                 ***
** Set flag for IEFUTL.  IEFUTL doesn't operate in the normal job    **
** environment so we do the unlimited CPU program name check here    **
** and pass our results in the JMRUCOM for IEFUTL.                   **
***                                                                 ***
***********************************************************************
         SPACE 2
         LA    R1,JMRUCOM                 Locate area
         USING XYZMFX,R1                  Map it
         XC    XYZMFX_INIT(XYZMFX_INITL),XYZMFX_INIT
*
         L     R14,@USI_PGM               Locate program name
         CLC   0(8,R14),=CL8'IEBCOPY'     Needs Unlimited CPU?
         BE    UTL$SP
         CLC   0(8,R14),=CL8'GIMSMP'      Needs Unlimited CPU?
         BNE   UTL$X
UTL$SP   DS    0H
         MVI   XYZMFX_EXTENDP,1           Say we want unlimited CPU
         DROP  R1
UTL$X    DS    0H
         EJECT
***********************************************************************
***                                                                 ***
**       Set region information                                      **
***                                                                 ***
***********************************************************************
         SPACE 2
SET_REGION_VALUES EQU *
         L     R1,@USI_VRFLG              Locate V=R flag
         TM    0(R1),X'80'                V=R?
         BO    EXIT                       Yes, Skip remaining code
*
** See if we need to set different region values for this jobname
*
         L     R5,=V(IEFUSI#T)            Locate CSECT
         LA    R5,TABLE_RS-IEFUSI#T(R5)   Locate region table
         LA    R0,TABLE_RSN               Get number in table
SRV$L    EQU   *
         CLC   IEFUSIRS_JNAME-IEFUSIRS(8,R5),JMRJOB Match?
         BE    SRV$LX                     Yes, continue
         LA    R5,IEFUSIRSL(R5)           No, bump to next entry
         BCT   R0,SRV$L                       and process it
         CLC   JMRJOB(8),=C'&DBGJNME'     Debugging job?
         BE    SRV$MSG                    No, continue
         B     SRV$X                      Don't mess with Texas
SRV$LX   EQU   *
*
** Set the different region values for this jobname
*
         L     R4,@USI_RGN                -> Region area
         ICM   R1,B'1111',REGSZREQ-REGION(R4) Get requested region size
         BZ    SRV$ZR                     Zero: use default values
         OI    REGFLAGS-REGION(R4),X'80'  We are control freaks
         AL    R1,=F'65536'               Add 64K
         ST    R1,REGLIMB-REGION(R4)      Set as region limit below
         MVC   REGSIZB-REGION(4,R4),REGSZREQ-REGION(R4) Region below
         MVC   REGSIZA-REGION(4,R4),IEFUSIRS_RGNSZ-IEFUSIRS(R5) Size
         MVC   REGLIMA-REGION(4,R4),IEFUSIRS_RGNSZ-IEFUSIRS(R5) Limst
*
** Issue message saying what we did
*
SRV$MSG  EQU   *
         CLI   JMRSTEP,1                  First step?
         BNE   SRV$X                      No, continue
         LA    R15,WTOAREA                Locate WTO work area
         MVC   0(C_WTOL,R15),C_WTO        Initialize WTO area
         LA    R15,4(R15)                 Bump past WTO overhead
         MVC   0(MSG190L,R15),MSG190      Get WTO text
         LA    R15,MSG190L+1(R15)         Bump past message
*
         SLR   R0,R0                      Clear register for divide
         L     R1,@USI_RGN                -> Region area
         L     R1,REGSIZA-REGION(R1)      Get region size above
         D     R0,=AL4(#IEFUSIRS_AMEG)    Divide to get number
         BAS   R9,EDITFWF                 Edit (r1) full word flush
*
         MVC   1(MSG190SL,R15),MSG190S    Move in suffix
         WTO   ,MF=(E,WTOAREA)            Issue the WTO message
         B     SRV$X
*
** Issue message griping about REGION=0K in JCL and in table
*
SRV$ZR   EQU   *
         LA    R15,WTOAREA                Locate WTO work area
         MVC   0(C_WTOL,R15),C_WTO        Initialize WTO area
         LA    R15,4(R15)                 Bump past WTO overhead
         MVC   0(MSG191L,R15),MSG191      Get WTO text
         WTO   ,MF=(E,WTOAREA)            Issue the WTO message
*
** Common exit from Set_Region_Values
*
SRV$X    EQU   *
         EJECT
***********************************************************************
***                                                                 ***
**       Set Data Space and HiperSpace values                        **
***                                                                 ***
***********************************************************************
         SPACE 2
SET_DSHS_VALUES EQU *
*
** See if we need to set different region values for this jobname
*
         L     R5,=V(IEFUSI#T)            Locate CSECT
         LA    R5,TABLE_DS-IEFUSI#T(R5)   Locate region table
         LA    R0,TABLE_DSN               Get number in table
SDV$L    EQU   *
         CLC   IEFUSIDS_JNAME-IEFUSIDS(8,R5),JMRJOB Match?
         BE    SDV$LX                     Yes, continue
         LA    R5,IEFUSIDSL(R5)           No, bump to next entry
         BCT   R0,SDV$L                       and process it
         CLC   JMRJOB(8),=C'&DBGJNME'     Debugging job?
         BE    SDV$MSG                    No, continue
         B     SDV$X                      Don't mess with Texas
SDV$LX   EQU   *
*
** Set the new size and ensure that it's not over the limit
*
         L     R1,@USI_DSHS               Locate area
         MVC   DSHS_DEFSIZE-DSHS(4,R1),IEFUSIDS_SIZE-IEFUSIDS(R5)
         CLC   DSHS_DEFSIZE-DSHS(4,R1),=X'0002D980'
         BNH   SDV$SETX
         MVC   DSHS_DEFSIZE-DSHS(4,R1),=X'0002D980' Set to maximum
SDV$SETX EQU   *
*
** Print message saying what we did!
*
SDV$MSG  EQU   *
         CLI   JMRSTEP,1                  First step?
         BNE   SDV$X                      No, continue
         LA    R15,WTOAREA                Locate WTO work area
         MVC   0(C_WTOL,R15),C_WTO        Initialize WTO area
         LA    R15,4(R15)                 Bump past WTO overhead
         MVC   0(MSG193L,R15),MSG193      Get WTO text
         LA    R15,MSG193L+1(R15)         Bump past message
         L     R1,@USI_DSHS               Locate area
         L     R1,DSHS_DEFSIZE-DSHS(R1)   Get the size we set
         MH    R1,=AL2(4)                 Multiply by 4
         BAS   R9,EDITFWF                 Edit (r1) full word flush
         MVI   0(R15),C'K'                Set to value
         WTO   ,MF=(E,WTOAREA)            Issue the WTO message
*
** Common exit from Set_DSHS_Values
*
SDV$X    EQU   *
         EJECT
***********************************************************************
***                                                                 ***
**       Exit from IEFUSI processing                                 **
***                                                                 ***
***********************************************************************
         SPACE 2
EXIT     DS    0H
*
** Free storage obtained for IEFUSI work area
*
         L     R0,DSAGLEN               Get storage area length
         LR    R1,R13                   Get storage address
         L     R13,4(,R1)               Save caller's RSA address
      FREEMAIN RU,                      Free storage                   @
               LV=(0),                  ..Length                       @
               A=(1),                   ..Address                      @
               SP=$DSA_SP               ..Subpool
*
** QUICKOUT is an exit point for jobs not processed by this exit
*
X$QUICKOUT EQU *
         LM    R14,R12,12(R13)          Restore registers
         SLR   R15,R15                  Clear register - (return code)
         BSM   0,R14                    Return to caller
         EJECT
***********************************************************************
***                                                                 ***
**       Misc internal subroutines                                   **
***                                                                 ***
***********************************************************************
         SPACE 2
*
** Edit register 1 flush
** Input: R1 - Value to edit
**        R15 - Where edited value is to be put
*
EDITFWF  EQU   *
         LTR   R1,R1                      Check for zero
         BZ    EDITFWF0                   Yes, cut cpu cycles
         CVD   R1,DOUBLE                  Convert number to packed
         LA    R1,DOUBLE2+14              Locate significant digit
         MVC   DOUBLE2(15),EDITP15        Get edit pattern
         EDMK  DOUBLE2(15),DOUBLE+2       Edit number and save end
         LA    R14,DOUBLE2+16             Locate past last byte
         SR    R14,R1                     Length = end - start
         BCTR  R14,0                      Decrement for EX
         EX    R14,EDITFWFM               Move edit number to output
         LA    R15,0(R14,R15)             Bump pointer past number
         MVI   0(R15),C' '                Fix binary zero
         BSM   0,R9                       Return to caller
EDITFWFM MVC   0(0,R15),0(R1)
EDITP15  DC    X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'
EDITFWF0 DS    0H
         MVI   0(R15),C'0'                Insert "0"
         LA    R15,1(R15)                 Bump past it
         BSM   0,R9                       Return to caller
         EJECT
***********************************************************************
***                                                                 ***
**        Constants                                                  **
***                                                                 ***
***********************************************************************
         SPACE 2
MSG190   DC    C'XYZ190I Region limit set to'
MSG190L  EQU   *-MSG190
MSG190S  DC    C'megabytes (above the line) for all steps'
MSG190SL EQU   *-MSG190S
*
MSG191   DC    C'XYZ191W Region not set for job in table because '
MSG191T  DC    C'REGION=0K in JCL'
MSG191L  EQU   *-MSG191
*
MSG192   DC    C'XYZ192I IEFUSI Assembled on '
         DC    C'&ASMDATE'
         DC    C' at '
         DC    C'&SYSTIME'
         DC    C' - EPA='
MSG192EP DC    C'xxxxxxxx'
         DC    C', 1ZapEntry='
MSG192Z  DC    C'xxxxxxxx'
MSG192L  EQU   *-MSG192
*
MSG193   DC    C'XYZ193I Default user Data Space and Hiperspace size:'
MSG193L  EQU   *-MSG193
*
C_WTO    WTO   '                                                       @
                                                                       @
                       ',                                              @
               MCSFLAG=HRDCPY,                                         @
               MF=L
C_WTOL   EQU   *-C_WTO
*
** Literals
*
         LTORG ,
         DS    0D
IEFUSIL  EQU   *-IEFUSI                       Length of IEFUSI CSECT
         EJECT
***********************************************************************
***                                                                 ***
**       Tables and data that we will let be externally referenced   **
**                                                                   **
**   Note: The H_J2VS/J2X06EDH_J2VS at offset 0 is done to simulate  **
**         the ADRRELVL and ICKRELVL modules.                        **
***                                                                 ***
***********************************************************************
         SPACE 2
*
** Start of CSECT
*
IEFUSI#T CSECT ,
IEFUSI#T AMODE 31
IEFUSI#T RMODE ANY
*
HEADER   EQU   *
H_ID     DC    CL8'IEFUSI#T'                  Module name
H_ASMD   DC    CL10'&ASMDATE'                 ASM date: "1994/03/06"
H_ASMT   DC    CL6'&SYSTIME'                  ASM time: "hh:mm"
H_DBJOB  DC    CL8'&DBGJNME'                  Debugging jobname
HEADERL  EQU   *-HEADER                       Must match IEFUSIEDHL
HEADERT  EQU   IEFUSIEDHL                     Match?  !!!!
*
** Offsets for external programs (mapped by IEFUSI#T)
*
ENTRIES  EQU   *
         DC    AL2($IEFUSIEDE_TRS,TABLE_RS-IEFUSI#T)  Region Size
         DC    AL2($IEFUSIEDE_TDS,TABLE_DS-IEFUSI#T)  Data/hip-spc
         DC    AL1(#IEFUSIEDE_END)                    End of table
         SPACE 2
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
**                                                                   **
***  Region size assigned by jobname                                ***
**                                                                   **
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
         SPACE 2
         PRINT DATA
TABLE_RS DS    0F
         DC    CL8'NET     ',A(64*#IEFUSIRS_AMEG)
         DC    CL8'NETVIEW1',A(64*#IEFUSIRS_AMEG)
*
         DC    CL8'DB2DDBM1',A(64*#IEFUSIRS_AMEG)
         DC    CL8'DB2PDBM1',A(64*#IEFUSIRS_AMEG)
         DC    CL8'DB2DMSTR',A(64*#IEFUSIRS_AMEG)
         DC    CL8'DB2PMSTR',A(64*#IEFUSIRS_AMEG)
         DC    CL8'IRLDPROC',A(64*#IEFUSIRS_AMEG)
         DC    CL8'IRLPPROC',A(64*#IEFUSIRS_AMEG)
*
         DC    CL8'TPX1    ',A(66*#IEFUSIRS_AMEG)
         DC    CL8'TPX2    ',A(66*#IEFUSIRS_AMEG)
         DC    CL8'TPX3    ',A(66*#IEFUSIRS_AMEG)
         DC    CL8'TPX4    ',A(66*#IEFUSIRS_AMEG)
         DC    CL8'TPX5    ',A(66*#IEFUSIRS_AMEG)
         DC    CL8'TPX6    ',A(66*#IEFUSIRS_AMEG)
         DC    CL8'TPX9    ',A(66*#IEFUSIRS_AMEG)
* 4.1
         DC    CL8'CICS1   ',A(192*#IEFUSIRS_AMEG)
         DC    CL8'CICS2   ',A(192*#IEFUSIRS_AMEG)
*
         DC    CL8'TCPIP   ',A(64*#IEFUSIRS_AMEG)
         DC    CL8'TCPIPRF ',A(64*#IEFUSIRS_AMEG)
         DC    CL8'TCPIPT  ',A(64*#IEFUSIRS_AMEG)
         DC    CL8'TCPIPTRF',A(64*#IEFUSIRS_AMEG)
*
         DC    CL8'EDMMGR  ',A(256*#IEFUSIRS_AMEG)
*
         DC    CL8'ibmuserL',A(64*#IEFUSIRS_AMEG)
         DC    CL8'ibmuserZ',A(64*#IEFUSIRS_AMEG)
*
ZAPENTRY EQU   * - - - - - - - - - - - - - - - - - - -Zappable entries
         DC    CL8'ZAP256A ',A(256*#IEFUSIRS_AMEG)
         DC    CL8'ZAP256B ',A(256*#IEFUSIRS_AMEG)
         DC    CL8'ZAP192A ',A(192*#IEFUSIRS_AMEG)
         DC    CL8'ZAP192B ',A(192*#IEFUSIRS_AMEG)
         DC    CL8'ZAP128A ',A(128*#IEFUSIRS_AMEG)
         DC    CL8'ZAP128B ',A(128*#IEFUSIRS_AMEG)
         DC    CL8'ZAP64A  ',A(64*#IEFUSIRS_AMEG)
         DC    CL8'ZAP64B  ',A(64*#IEFUSIRS_AMEG)
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
TABLE_RSN EQU  ((*-TABLE_RS)/IEFUSIRSL)
         DC    AL1(#IEFUSIEDE_END)                    End of table
         PRINT NODATA
         SPACE 2
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
**                                                                   **
***  Default Data Space and Hiper Space size                        ***
***                                                                  **
***  Note: maximum is 186742                                         **
**                                                                   **
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
         SPACE 2
         PRINT DATA
TABLE_DS DS    0F
         DC    CL8'ibmuserL',A(512)
TABLE_DSN EQU  ((*-TABLE_DS)/IEFUSIDSL)
         DC    AL1(#IEFUSIEDE_END)                    End of table
         PRINT NODATA
         SPACE 2
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
**                                                                   **
***      End of IEFUSI#T CSECT                                      ***
**                                                                   **
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
         SPACE 2
         DC    C'ENDOFIEFUSI#T'           Eyecatcher
         DS    0D
IEFUSI$T EQU   *-IEFUSI                   Length (for trivia)
         EJECT
***********************************************************************
***                                                                 ***
**                 Dynamic Save Area                                 **
***                                                                 ***
***********************************************************************
         SPACE 2
$DSA_SP  EQU   252                        SubPool = Low Private
DSA      DSECT ,
         DS    18F                        Register Save Area
DSAGLEN  DS    F                          Length of DSA
DOUBLE   DS    D                          Double word work area
DOUBLE2  DS    2D                         Double word work area * 2
WTOAREA  DS    XL(C_WTOL)                 WTO work area
         DS    0D
DSAL     EQU   *-DSA
         EJECT
***********************************************************************
***                                                                 ***
**       DSECTs and Equates                                          **
***                                                                 ***
***********************************************************************
         SPACE 2
*
** Parameter list passed to us in register 1 upon entry
*
@USI       DSECT ,
@USI_JMR   DS    XL4            1         -> CEPA (JMR)
@USI_STEPN DS    XL4            2         -> 8 byte Step name
@USI_PGM   DS    XL4            3         -> 8 byte Program name
@USI_ACCT  DS    XL4            4         -> Account information
@USI_RGN   DS    XL4            5         -> Region information
@USI_VRFLG DS    XL4            6         -> V=R flag address
@USI_DSHS  DS    XL4            7         -> Data Spaces & Hiperspaces
@USI_SUBS  DS    XL4            8         -> Subsystem name
*
** Map the 6 word area pointed to by @USI_RGN (+16) in R1
**
** Copied from the sample IEFUSI exit in IPO1.SAMPLIB (MVS 4.2.2)
*
REGION   DSECT ,
REGFLAGS DS    F                          FLAG WORD
REGSZREQ DS    F                          REGION SIZE REQUESTED
REGLIMB  DS    F                          REGION LIMIT BELOW 16MB
REGSIZB  DS    F                          REGION SIZE BELOW 16MB
REGLIMA  DS    F                          REGION LIMIT ABOVE 16MB
REGSIZA  DS    F                          REGION SIZE ABOVE 16MB
*
** Map the 3 word area pointed to by @USI_DSHS (word 7) in R1 on entry
*
DSHS           DSECT ,
DSHS_DEFSIZE   DS    XL4
DSHS_MAXSIZE   DS    XL4
DSHS_MAXNUM    DS    XL4
         END
./ ADD NAME=IEFUSI#T 0100-98016-98016-1800-00062-00062-00000-DALCOCK
 MACRO
 IEFUSI#T
.**********************************************************************
.***                                                                ***
.**  Name: IEFUSI#T                                                  **
.**                                                                  **
.**  Purpose: External mappings for XYZ SMF exit IEFUSI to map data  **
.**           in the IEFUSI#T CSECT/module.                          **
.**                                                                  **
.**  Note: The IEFUSI#T module is a part of the IEFUSI load module   **
.**        that is available to other programs via the alias to      **
.**        CSECT IEFUSI#T.                                           **
.***                                                                ***
.**********************************************************************
.**********************************************************************
.***                                                                ***
.**           M o d i f i c a t i o n   H i s t o r y                **
.**                                                                  **
.** Person     Date        Description                               **
.** ---------- ----------- ----------------------------------------- **
.** DGAlcock   11-NOV-1994 Created this mapping macro to be used by  **
.**                        SMF exit IEFUSI and external programs     **
.**                        that read the IEFUSI#T module;            **
.***                                                                ***
.**********************************************************************
*
** External data (IEFUSI#T) mappings
*
IEFUSIED       DSECT ,
IEFUSIEDH      EQU   *                 Module header
IEFUSIEDH_ID   DS    CL8'IEFUSI#T'     ..Module name
IEFUSIEDH_ASMD DS    CL10'1962/03/06'  ..Assembly date
IEFUSIEDH_ASMT DS    CL6'21:05'        ..Assembly time
IEFUSIEDH_DBJOB DS   CL8'jobname'      ..debugging jobname
IEFUSIEDHL     EQU   *-IEFUSIEDH
*
IEFUSIEDE      EQU   *                 Data area entry
IEFUSIEDE_TYPE DS    CL2               ..Data area Type
$IEFUSIEDE_TRS EQU   C'RS'               ..Region Size
$IEFUSIEDE_TDS EQU   C'DS'               ..Data Space and Hiperspace
IEFUSIEDE_OFF  DS    XL2               ..Offset to data area
IEFUSIEDEL     EQU   *-IEFUSIEDE       Data area entry
#IEFUSIEDE_END EQU   X'FF'             End of table
*
** Region size table
*
IEFUSIRS       DSECT ,
IEFUSIRS_JNAME DS    CL8'jobname'      Job name/TSO user name
IEFUSIRS_RGNSZ DS    XL4               Region size
IEFUSIRSL      EQU   *-IEFUSIRS
#IEFUSIRS_AMEG EQU   1024*1024
*
** Data space and Hiperspace table
*
IEFUSIDS       DSECT ,
IEFUSIDS_JNAME DS    CL8'jobname'      Job name/TSO user name
IEFUSIDS_SIZE  DS    XL4               Data Space and HiperSpace size
IEFUSIDSL      EQU   *-IEFUSIDS
.*
.** End of macro
.*
 MEND ,
./ ADD NAME=IEFUTL   0100-98016-98016-1800-00570-00570-00000-DALCOCK
IEFUTL   TITLE 'XYZ - IEFUTL - SMF EXIT - Time Limit Exit'
***********************************************************************
***                                                                 ***
** Name = IEFUTL                                                     **
**                                                                   **
** Author: David Alcock                                              **
**         Rewritten based on earlier XYZ source                     **
**                                                                   **
** Purpose = SMF Time limit exit                                     **
**           - CPU time extensions                                   **
**           - WAIT time extensions                                  **
**                                                                   **
** Reference = GC28-1153 MVS/XA SPL System Management Facilities     **
**                                                                   **
** Warning = A system interlock occurs anytime IEFUTL enqueues on    **
**           a resource already enqueued on by the job. For example  **
**           do not use the Write-To-Programmer WTO route code.      **
***                                                                 ***
***********************************************************************
         SPACE 2
***********************************************************************
***                                                                 ***
**           M o d i f i c a t i o n   H i s t o r y                 **
**                                                                   **
** Person     Date        Description                                **
** ---------- ----------- ------------------------------------------ **
** DGAlcock   14-MAR-1997 Moved XYZSMFX field to the JMRUCOM;        **
** DGAlcock   26-JUN-1992 Let all TSO users enjoy 1 hours wait;      **
** DGAlcock   16-MAR-1992 Rewritten from earlier XYZ source;  Made   **
**                        AMODE31 (TPUTs below the line) for MVS/ESA;**
**                        All started tasks will be driven thru      **
**                        wait and CPU checking and need not be in   **
**                        the various tables.                        **
***                                                                 ***
***********************************************************************
         EJECT
         IEFUTL#T ,                       Map IEFUTL#T CSECT areas
         XYZSMFX ,                        XYZ SMF exit common stuff
         IEFJMR ,                         Job Management Record
         YREGS ,                          Equate registers
         PRINT NOGEN
         IHAPSA ,                         Prefixed Save Area
         IKJTCB ,                         Task Control Block
         IEZJSCB ,                        Job Step Control Block
         IEFJSSIB ,                       SubSystem Identification Blk
*
** Global stuff
*
         GBLC  &DBGJNME                Generate global variable
&DBGJNME SETC  'ibmuserZ'              ..Jobname for debugging info
*
** Using the official ASMH/HLASM distinction trick, simulate the
** SYSVER and SYSDATEC variables of HLASM when assembled under
** ASMH...Taken from Gilbert Saint-flour's SHOWMVS.
*
         LCLA  &ASMH_HLASM
         AIF   (T'&ASMH_HLASM EQ 'N').ASMH1X
&SYSVER  SETC  'ASMH'
&SYSDATC SETC  '20'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)
         AIF   ('&SYSDATC' LT '20500000').ASMH1X
&SYSDATC SETC  '19'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)
.ASMH1X  ANOP
*-Convert assembly date from SYSDATC format "YYYYMMDD" to "YYYY-MM-DD"
         LCLC  &ASMDATE
&ASMDATE SETC  '&SYSDATC'(1,4).'-'.'&SYSDATC'(5,2).'-'.'&SYSDATC'(7,2)
         EJECT
***********************************************************************
***                                                                 ***
**       Entry                                                       **
***                                                                 ***
***********************************************************************
         SPACE 2
IEFUTL   CSECT ,
IEFUTL   AMODE 31
IEFUTL   RMODE ANY
*
** Entry Housekeeping
*
         SAVE  (14,12),,XYZ_SMFEXIT_IEFUTL_&ASMDATE._&SYSTIME
         LR    R12,R15                    Get Base register
         USING IEFUTL,R12                 Obtain addressiblity to CSECT
*
         LR    R6,R0                      Save Expired Time limit code
         L     R10,0(R1)                  => Common Exit parameter list
         USING JMR,R10                    Get addressibility to it
*
** Obtain storage for our work area
*
         LA    R0,DSAL                    Length of area
       GETMAIN RU,                        Obtain storage               @
               LV=(0),                    ..Length                     @
               SP=$DSA_SP,                ..Subpool - Low private      @
               LOC=BELOW                  ..Location: Below the line
*
** Forward/Backword chaining
*
         ST    R13,4(,R1)                 Save Backward RSA Pointer
         ST    R1,8(,R13)                 Save Forward RSA Pointer
         LR    R13,R1                     Get DSA/RSA Address
         USING DSA,R13                    Get Addressiblity to it
*
         MVI   RCODE,$RCODE0              Set Default Return Code
*
** Branch to routine based on binary value (set in R0 upon entry)
*
         CH    R6,=H'0'                   Job CPU time exceeded
         BE    CPUTIME
         CH    R6,=H'4'                   Step CPU time exceeded
         BE    CPUTIME
         CH    R6,=H'8'                   Wait time exceeded
         BE    WAITTIME
*
         B     EXIT
         EJECT
***********************************************************************
***                                                                 ***
**  Return to caller                                                 **
***                                                                 ***
***********************************************************************
         SPACE 2
EXTEND   DS    0H
         MVI   RCODE,$RCODE8              Set Extend RC (Seconds)
*
** If we branch directly to "EXIT", the time is not extended...
*
EXIT     DS    0H
         SLR   R4,R4                      Clear register
         IC    R4,RCODE                   Load return code
         LR    R1,R13                     Get our RSA/DSA
         L     R13,4(,R1)                 Get caller's RSA
*
** Free DSA area
*
         LA    R0,DSAL                    Length of area
      FREEMAIN RU,                        Free storage                 @
               LV=(0),                    ..Length                     @
               A=(1),                     ..Address                    @
               SP=$DSA_SP                 ..Subpool
*
** Exit housekeeping
*
         LR    R15,R4                     Restore return code
         LR    R1,R5                      Set time extension
*
         L     R14,12(,R13)               Get return address
         L     R0,20(,R13)                Get caller's register zero
         LM    R2,R12,28(R13)             Restore rest of registers
         BSM   0,R14                      Return to caller
         EJECT
***********************************************************************
***                                                                 ***
**       CPU Time Exceeded                                           **
***                                                                 ***
***********************************************************************
         SPACE 2
CPUTIME  EQU   *
*
** Check for TSO users not be be cancelled
*
         TM    JMRINDC,JMRFIND            TSO user?
         BNO   CT$TSOX                    No, continue
*
         L     R1,=V(IEFUTL#T)            Locate CSECT
         LA    R1,TABLE_CT-IEFUTL#T(R1)   Locate table
         LA    R0,TABLE_CTN               Number of entries in table
CT$TSOL  EQU   *
         CLC   JMRJOB(8),0(R1)            USERID match?
         BE    CT$TSOE                    Yes, grant extension
         LA    R1,8(R1)                   No, bump to next entry
         BCT   R0,CT$TSOL                     and process it
*
         LA    R1,JMRUCOM                 Locate XYZSMFX area
         CLI   XYZSMFX_EXTENDC-XYZSMFX(R1),X'01' First time?
         BE    CT$TSOK                    No, kill it (no more given)
         MVI   XYZSMFX_EXTENDC-XYZSMFX(R1),X'01' Set that we've done it
         MVC   WTO(MSG156L),MSG156        Get the message
         TPUT  WTO,MSG156L                Issue the message to TSO
CT$TSOE  EQU   *
         MVC   WTO(MSG150L),MSG150        Get the message
         MVI   WTO+(MSG150A-MSG150),C'0'  Set to "05" minutes
         TPUT  WTO,MSG150L                Issue the message to TSO
         L     R5,=AL4(5*60)              5 minutes
         B     EXTEND                     Extend for 5 minutes
CT$TSOK  EQU   *                          Kill Your Television
         MVC   WTO(MSG157L),MSG157        Get the message
         TPUT  WTO,MSG157L                Issue the message to TSO
         B     EXIT                       Grant no extension...
*
CT$TSOX  EQU   *
*
** Check for jobs not to be cancelled because of CPU being exceeded
*
         L     R1,=V(IEFUTL#T)
         LA    R1,TABLE_CJ-IEFUTL#T(R1)   Locate table
         LA    R0,TABLE_CJN               Number of entries in table
CT$JOBL  EQU   *
         CLC   JMRJOB(8),0(R1)            JobName match?
         BE    CT$JOBE                    Yes, grant extension
         LA    R1,8(R1)                   No, bump to next entry
         BCT   R0,CT$JOBL                     and process it
         B     CT$PGMS
*
CT$JOBE  EQU   *
         LA    R15,WTO                    Locate WTO work area
         MVC   0(C_WTOL,R15),C_WTO        Initialize WTO area
         MVC   4(MSG150L,R15),MSG150      Move in message
         LA    R15,4+MSG150L+1(R15)       Bump past message
         BAS   R14,INSERT_JOBID           Get job ID
         WTO   ,MF=(E,WTO)                Issue the WTO
         L     R5,=AL4(15*60)             15 minutes in seconds
         B     EXTEND                     Extend that puppy
*
** Check for programs not to be cancelled
*
CT$PGMS  DS    0H
         LA    R1,JMRUCOM                 Locate XYZSMFX area
         CLI   XYZSMFX_EXTENDP-XYZSMFX(R1),X'01' Program needs expand
         BNE   EXIT                       Nope, leave
         LA    R15,WTO                    Locate WTO work area
         MVC   0(C_WTOL,R15),C_WTO        Initialize WTO area
         MVC   4(MSG150L,R15),MSG150      Move in message
         LA    R15,4+MSG150L+1(R15)       Bump past message
         BAS   R14,INSERT_JOBID           Get job ID
         MVC   1(8,R15),=C'for PGM='      Tell why we're doing this
         LA    R15,1+8(R15)               Bump past text
         MVC   0(8,R15),0(R4)             Insert program name
         WTO   ,MF=(E,WTO)                Issue the WTO
         L     R5,=AL4(15*60)             15 minutes in seconds
         B     EXTEND                     Extend that puppy
         EJECT
***********************************************************************
***                                                                 ***
**       Wait Time Exceeded                                          **
***                                                                 ***
***********************************************************************
         SPACE 2
WAITTIME EQU   *
         TM    JMRINDC,JMRFIND            TSO user?
         BNO   WT$TSOX                    No, continue
*
** Check for TSO users to be extended, Basically we extend all
** TSO users:
**
** - Default is 30 minutes (except for PSO which gets 60 minutes)
** - If in the table, get 2 hours
*
         L     R1,=V(IEFUTL#T)            Locate CSECT
         LA    R1,TABLE_WT-IEFUTL#T(R1)   Locate table
         LA    R0,TABLE_WTN               Number of entries in table
WT$TSOL  EQU   *
         CLC   JMRJOB(8),0(R1)            USERID match?
         BE    WT$TSOE                    Yes, grant extension
         LA    R1,8(R1)                   No, bump to next entry
         BCT   R0,WT$TSOL                     and process it
*
         LA    R1,JMRUCOM                 Locate XYZSMFX area
         CLI   XYZSMFX_EXTENDC-XYZSMFX(R1),X'01' First time?
         BE    WT$TSOK                    No, kill it (no more given)
         MVI   XYZSMFX_EXTENDC-XYZSMFX(R1),X'01' Set that we did it
*
         CLI   JMRJOB,C'P'                PSO?
         BE    WT$TSOP                    Yes, only 30 minutes
         L     R5,=AL4(60*60)             1 hours in seconds
         B     EXTEND                     Extend for 1 hour
WT$TSOP  EQU   *                          PSO users only get 30 minutes
*
         L     R5,=AL4(30*60)             30 minutes in seconds
         B     EXTEND                     Extend for 1 hour
WT$TSOK  EQU   *                          Kill Your Television
         MVC   WTO(MSG153L),MSG153        Get the message
         TPUT  WTO,MSG153L                Issue the message to TSO
         B     EXIT                       Grant no extension...
*
WT$TSOE  EQU   *
         LA    R1,JMRUCOM                 Locate XYZSMFX area
         CLI   XYZSMFX_EXTENDC-XYZSMFX(R1),X'01' First time?
         BE    WT$TSOK                    No, kill it (no more given)
         MVI   XYZSMFX_EXTENDC-XYZSMFX(R1),X'01' Set that we did it
         L     R5,=AL4(120*60)            2 Hours in seconds
         B     EXTEND                     Extend for 2 hours
WT$TSOX  EQU   *
*
** Check for jobs not to be cancelled
*
         L     R1,=V(IEFUTL#T)            Locate CSECT
         LA    R1,TABLE_WJ-IEFUTL#T(R1)   Locate table
         LA    R0,TABLE_WJN               Number of entries in table
WT$JOBL  EQU   *
         CLC   JMRJOB(8),0(R1)            JobName match?
         BE    WT$JOBE                    Yes, grant extension
         LA    R1,8(R1)                   No, bump to next entry
         BCT   R0,WT$JOBL                     and process it
*
         LA    R0,MSG151L                 Get length of WTOR text
         LA    R1,MSG151                  Get address of WTOR text
         BAS   R9,ISSUE_WTOR              Issue the WTOR
*
         OI    WTOREPLY,X'40'             Ensure uppercase
         CLI   WTOREPLY,C'N'              Operator said "No way, Jose"?
         BE    WT$JOBC                    Yes: goodbye Columbus
         MVC   WTO(C_WTOL),C_WTO          Initialize WTO area
         MVC   WTO+4(MSG155L),MSG155      Move in message
         LA    R15,WTO+4+MSG155L+1        Locate to end of message
         MVC   0(1,R15),=C'5'             Insert minutes
         MVC   2(16,R15),=C'minutes given to' Insert text
         LA    R15,2+16+1(R15)            Bump past minutes & text
         BAS   R14,INSERT_JOBID           Get job ID
         WTO   ,MF=(E,WTO)                Issue the WTO
         L     R5,=AL4(5*60)              5 minutes in seconds
         B     EXTEND                     Extend for 5 minutes
*
WT$JOBC  EQU   *
         MVC   WTO(C_WTOL),C_WTO          Initialize WTO area
         MVC   WTO+4(MSG154L),MSG154      Move in message
         LA    R15,WTO+4+MSG154L+1        Locate to end of message
         BAS   R14,INSERT_JOBID           Get job ID
         WTO   ,MF=(E,WTO)                Issue the WTO
         B     EXIT                       Leave
*
WT$JOBE  EQU   *
         MVC   WTO(C_WTOL),C_WTO          Initialize WTO area
         MVC   WTO+4(MSG155L),MSG155      Move in message
         LA    R15,WTO+4+MSG155L+1        Locate to end of message
         MVC   0(2,R15),=C'60'            Insert minutes
         MVC   3(16,R15),=C'minutes given to' Insert text
         LA    R15,3+16+1(R15)            Bump past minutes & text
         BAS   R14,INSERT_JOBID           Get job ID
         WTO   ,MF=(E,WTO)                Issue the WTO
         L     R5,=AL4(60*60)             60 minutes in seconds
         B     EXTEND                     Extend for 60 minutes
         EJECT
***********************************************************************
***                                                                 ***
**       Issue WTOR                                                  **
**                                                                   **
**       Input: R0 - Length (-message ID suffix)                     **
**              R1 - Address of message                              **
***                                                                 ***
***********************************************************************
         SPACE 2
ISSUE_WTOR EQU *
         LA    R15,WTOR                   Locate work area
         MVC   0(C_WTORL,R15),C_WTOR      Initialize WTOR
         LA    R15,12(R15)                Bump past overhead bytes
         MVC   0(3,R15),MSG150            Get message prefix of "XYZ"
         MVC   3(4,R15),0(R1)             Get message ID
         LA    R15,3+4+1(R15)             Bump past "XYZxxxA "
         BAS   R14,INSERT_JOBID           Insert job name/id stuff
         LR    R14,R0                     Get length to move
         BCTR  R14,0                      Decrement for EX
         EX    R14,IW_MMSG                Move message out
*
IW$WTOR  EQU   *
         LA    R2,WTOREPLY                Locate WTOR reply area
         LA    R3,WTORECB                 Locate WTOR ECB
         LA    R4,WTOR                    Locate WTOR to execute
         XC    0(4,R3),0(R3)              Clear ECB to zeros
         WTOR  ,(2),                      Issue WTOR                   @
               L'WTOREPLY,                ..Length of reply            @
               (3),                       ..ECB address                @
               MF=(E,(4))                 ..parameter list
*
         WAIT  1,                         Wait                         @
               ECB=(3),                   ..Address of ECB             @
               LONG=YES                   ..Don't time out!
*
         BSM   0,R9                       Return to caller
*
IW_MMSG  MVC   0(0,R15),4(R1)             Move message to WTOR
         EJECT
***********************************************************************
***                                                                 ***
**       Misc internal subroutines                                   **
***                                                                 ***
***********************************************************************
         SPACE 2
*
** Insert "JOB jobname (jobid)" at R15
*
INSERT_JOBID EQU *
         MVC   0(3,R15),=C'Job'           Set JOB
         LA    R15,3+1(R15)               Bump past it
         MVC   0(8,R15),JMRJOB            Move in the job name
         LA    R15,9(R15)
         BSM   0,R14
         EJECT
***********************************************************************
***                                                                 ***
**                    C o n s t a n t s                              **
***                                                                 ***
***********************************************************************
         SPACE 2
MSG150   DC    C'XYZ150I CPU time extension of '
MSG150A  DC    C'15 minutes given to'
MSG150L  EQU   *-MSG150
*
MSG151   DC    C'151A'
MSG151S  DC    C'has exceeded the WAIT time limit, '
         DC    C'reply "N" to cancel'
MSG151L  EQU   *-MSG151S
*
MSG153   DC    C'XYZ153I TSO WAIT time exceeded, your TSO session is '
         DC    C'being cancelled'
MSG153L  EQU   *-MSG153
*
MSG154   DC    C'XYZ154I Operator did not extend wait time for'
MSG154L  EQU   *-MSG154
*
MSG155   DC    C'XYZ155I WAIT time extension of'
MSG155L  EQU   *-MSG155
*
MSG156   DC    C'XYZ156I CPU time exceeded, you will be granted '
         DC    C'one 5 minute extension'
MSG156L  EQU   *-MSG156
*
MSG157   DC    C'XYZ157I CPU time exceeded, your TSO session is '
         DC    C'being cancelled'
MSG157L  EQU   *-MSG157
*
MSG158   DC    C'XYZ158I IEFUTL entered - '
         DC    C'assembled on &ASMDATE at &SYSTIME'
MSG158L  EQU   *-MSG158
*
C_WTOR   WTOR  '                                                       @
                                                                       @
                       ',MF=L
C_WTORL  EQU    *-C_WTOR
*
C_WTO    WTO   '                                                       @
                                                                       @
                       ',MF=L
C_WTOL   EQU   *-C_WTO
*
** Literals used in IEFUTL
*
         LTORG ,
         EJECT
***********************************************************************
***                                                                 ***
**       Tables and data that we will let be externally referenced   **
**                                                                   **
**   Note: The H_J2VS/J2X06EDH_J2VS at offset 0 is done to simulate  **
**         the ADRRELVL and ICKRELVL modules.                        **
***                                                                 ***
***********************************************************************
         SPACE 2
*
** Start of CSECT
*
IEFUTL#T CSECT ,
IEFUTL#T AMODE 31
IEFUTL#T RMODE ANY
*
HEADER   EQU   *
H_ID     DC    CL8'IEFUTL#T'                  Module name
H_ASMD   DC    CL10'&ASMDATE'                 ASM date: "1994/03/06"
H_ASMT   DC    CL6'&SYSTIME'                  ASM time: "hh:mm"
H_DBJOB  DC    CL8'&DBGJNME'                  Debugging jobname
HEADERL  EQU   *-HEADER                       Must match IEFUTLEDHL
HEADERT  EQU   IEFUTLEDHL                     Match?  !!!!
*
** Offsets for external programs (mapped by IEFUTL#T)
*
ENTRIES  EQU   *
         DC    AL2($IEFUTLEDE_TCJ,TABLE_CJ-IEFUTL#T)  CPU - Jobname
         DC    AL2($IEFUTLEDE_TCP,TABLE_CP-IEFUTL#T)  CPU - Program
         DC    AL2($IEFUTLEDE_TCT,TABLE_CT-IEFUTL#T)  CPU - TSO user
         DC    AL2($IEFUTLEDE_TWJ,TABLE_WJ-IEFUTL#T)  Wait - Jobname
         DC    AL2($IEFUTLEDE_TWT,TABLE_WT-IEFUTL#T)  Wait - TSO user
         DC    AL1(#IEFUTLEDE_END)                    End of table
         SPACE 2
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
**                                                                   **
***  Jobs that are not cancelled if the CPU time is exceeded        ***
**                                                                   **
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
         SPACE 2
TABLE_CJ DS    0F
         DC    CL8'STCNAME1'        PRODUCTION CICS
         DC    CL8'STCNAME2'        PRODUCTION CICS
TABLE_CJN EQU  ((*-TABLE_CJ)/8)     -> Number of entries in table
         DC    AL1(#IEFUTLEDE_END)                    End of table
         SPACE 2
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
**                                                                   **
***  Programs not to be cancelled if the CPU time is exceeded       ***
**                                                                   **
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
         SPACE 2
TABLE_CP DS    0F
         DC    CL8'GIMSMP'                SMP/E PROGRAM
         DC    CL8'IEBCOPY'               IEBCOPY
TABLE_CPN EQU  ((*-TABLE_CP)/8)     -> Number of entries in table
         DC    AL1(#IEFUTLEDE_END)                    End of table
         SPACE 2
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
**                                                                   **
***  TSO users that are not cancelled if the CPU time is exceeded   ***
**                                                                   **
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
         SPACE 2
TABLE_CT DS    0F
         DC    CL8'TSOUSR01'
         DC    CL8'TSOUSR99'
TABLE_CTN EQU  ((*-TABLE_CT)/8)     -> Number of entries in table
         DC    AL1(#IEFUTLEDE_END)                    End of table
         SPACE 2
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
**                                                                   **
***  Jobs not to be cancelled if the Wait time is exceeded          ***
**                                                                   **
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
         SPACE 2
TABLE_WJ DS    0F
         DC    CL8'JOBNAME1'        NOSP KEY PROCESSOR
         DC    CL8'ROSCOE  '        PRODUCTION ROSCOE
         DC    CL8'ROSCOET '        Test ROSCOE
TABLE_WJN EQU  ((*-TABLE_WJ)/8)     -> Number of entries in table
         DC    AL1(#IEFUTLEDE_END)                    End of table
         SPACE 2
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
**                                                                   **
***  Jobs not to be cancelled if the Wait time is exceeded          ***
**                                                                   **
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
         SPACE 2
*
** TSO Users that will get 2 hours of wait time
*
TABLE_WT DS    0F
         DC    CL8'TSOUSR01'
         DC    CL8'TSOUSR99'
*
TABLE_WTN EQU  ((*-TABLE_WT)/8)     -> Number of entries in table
         DC    AL1(#IEFUTLEDE_END)                    End of table
         SPACE 2
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
**                                                                   **
***      End of IEFUTL#T CSECT                                      ***
**                                                                   **
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
         SPACE 2
         DC    C'ENDOFIEFUTL#T'           Eyecatcher
         DS    0D
IEFUTL$T EQU   *-IEFUTL                   Length (for trivia)
         EJECT
***********************************************************************
***                                                                 ***
**       IEFUTL Getmained work area                                  **
***                                                                 ***
***********************************************************************
         SPACE 2
$DSA_SP  EQU   252                        Subpool: Low private
DSA      DSECT
         DS    18F                        Register Save Area
DOUBLE   DS    D
WTO      EQU   *
WTORECB  DS    F                          ..ECB
WTOR     DS    CL256                      ..Work area
WTOREPLY DS    CL3                        ..Reply
WTOL     EQU   *-WTO
*
RCODE    DS    X                          IEFUTL Return code
$RCODE0  EQU   X'00'                      ..Cancel job
$RCODE4  EQU   X'04'                      ..Continue job w/Timer units
$RCODE8  EQU   X'08'                      ..Continue job w/Seconds
*
         DS    0D                         Set for alignment
DSAL     EQU   *-DSA
         END
./ ADD NAME=IEFUTL#T 0100-98016-98016-1800-00057-00057-00000-DALCOCK
 MACRO
 IEFUTL#T
.**********************************************************************
.***                                                                ***
.**  Name: IEFUTL#T                                                  **
.**                                                                  **
.**  Purpose: External mappings for XYZ SMF exit IEFUTL to map data  **
.**           in the IEFUTL#T CSECT/module.                          **
.**                                                                  **
.**  Note: The IEFUTL#T module is a part of the IEFUTL load module   **
.**        that is available to other programs via the alias to      **
.**        CSECT IEFUTL#T.                                           **
.***                                                                ***
.**********************************************************************
.**********************************************************************
.***                                                                ***
.**           M o d i f i c a t i o n   H i s t o r y                **
.**                                                                  **
.** Person     Date        Description                               **
.** ---------- ----------- ----------------------------------------- **
.** DGAlcock   24-JUL-1996 Added program table                       **
.** DGAlcock   20-SEP-1994 Created this mapping macro to be used by  **
.**                        SMF exit IEFUTL and external programs     **
.**                        that read the IEFUTL#T module;            **
.***                                                                ***
.**********************************************************************
*
** External data (IEFUTL#T) mappings
*
IEFUTLED       DSECT ,
IEFUTLEDH      EQU   *                 Module header
IEFUTLEDH_ID   DS    CL8'IEFUTL#T'     ..Module name
IEFUTLEDH_ASMD DS    CL10'1962/03/06'  ..Assembly date
IEFUTLEDH_ASMT DS    CL6'21:05'        ..Assembly time
IEFUTLEDH_DBJOB DS   CL8'jobname'      ..debugging jobname
IEFUTLEDHL     EQU   *-IEFUTLEDH
*
IEFUTLEDE      EQU   *                 Data area entry
IEFUTLEDE_TYPE DS    CL2               ..Data area Type
$IEFUTLEDE_TCJ EQU   C'CJ'             ..CPU for jobs
$IEFUTLEDE_TCT EQU   C'CT'             ..CPU for TSO users
$IEFUTLEDE_TCP EQU   C'CP'             ..CPU for program names
$IEFUTLEDE_TWJ EQU   C'WJ'             ..Wait time for jobs
$IEFUTLEDE_TWT EQU   C'WT'             ..Wait time for TSO users
IEFUTLEDE_OFF  DS    XL2               ..Offset to data area
IEFUTLEDEL     EQU   *-IEFUTLEDE       Data area entry
#IEFUTLEDE_END EQU   X'FF'             End of table
*
** Generic jobname entry
*
IEFUTLJN       DSECT ,
IEFUTLJN_VALUE DS    CL8'jobname'      Job name/TSO user name
IEFUTLJNL      EQU   *-IEFUTLJN
.*
.** End of macro
.*
 MEND ,
./ ADD NAME=XYZSMFX  0100-98016-98016-1800-00021-00021-00000-DALCOCK
 MACRO ,
 XYZSMFX ,
*
** Map the usage of the JMRUCOM (4 byte) area which is used by IEFUSI
** and IEFUTL.
**
** If we needed more data areas more room, we could obtain a data
** area and save address in first four bytes.
**
** See IBM's sample IEFACTRT for how the first byte is
** set.
*
XYZSMFX          DSECT ,
                 DS    X         Used by IPOACTRT (IBM's IEFACTRT)
XYZSMFX_INIT     EQU   *
XYZSMFX_EXTENDW  DS    X         IEFUTL has already extended for wait
XYZSMFX_EXTENDC  DS    X         IEFUTL has already extended for CPU
XYZSMFX_EXTENDP  DS    X         Set by IEFUSI if program should get   @
                                 unlimited CPU - Checked by IEFUTL
XYZSMFX_INITL    EQU   *-XYZSMFX_INIT
 MEND ,
./ ENDUP       "REVIEW" PDS MEMBER OFFLOAD AT 18:01 ON 98/01/16
