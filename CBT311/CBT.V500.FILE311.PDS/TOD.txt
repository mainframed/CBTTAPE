./ ADD NAME=$$README 1100-97081-97081-1322-00078-00078-00000-DALCOCK
Time Of Day Package v1.1 - 22-MAR-1997

This package consists of an MPF exit and a started task that hopefully
increases productivity by reducing the effort needed to determine the
date when browsing a JES job log.

This package is OBSOLETE with OS/390 JES2 which has both functions!!!
This package is OBSOLETE with OS/390 JES2 which has both functions!!!
This package is OBSOLETE with OS/390 JES2 which has both functions!!!
This package is OBSOLETE with OS/390 JES2 which has both functions!!!
This package is OBSOLETE with OS/390 JES2 which has both functions!!!
This package is OBSOLETE with OS/390 JES2 which has both functions!!!
This package is OBSOLETE with OS/390 JES2 which has both functions!!!
This package is OBSOLETE with OS/390 JES2 which has both functions!!!

MPF exit
--------
This MPF exit appends the date onto a WTO message.  When used on the
job start and end messages, you can easily tell when a job ran by
only looking at the job log.

NEWDAY started task
-------------------
The NEWDAY started task should be started by your automated operations
system right after midnight.  It sends a message containing the date
to every started task's job log.

Sample:
------
                     J E S 2  J O B  L O G  --  S Y S T E M  C S W 1  --  N O D

  06.46.59 STC02311 IEF695I START TCPIPT   WITH JOBNAME TCPIPT   IS ASSIGNED TO
  06.46.59 STC02311 $HASP373 TCPIPT   STARTED
  06.46.59 STC02311 ACF9CCCD USERID TCPIPT   IS ASSIGNED TO THIS JOB - TCPIPT
  06.46.59 STC02311 XYZ190I Region limit set to 64 megabytes (above the line) fo
> 06.46.59 STC02311 IEF403I TCPIPT - STARTED - TIME=06.46.59 - 13-Mar-1997 - 199
  06.47.01 STC02311 EZY1876I TCPIP started with parameter TCPIP,ERRFILE(SYSERR),
> 00.01.18 STC02311 MSG FROM OPER:  '----- DATE: 14-MAR-1997 - 1997.073 '
  11.40.02 STC02311 EZB5948E Telnet server: Conn 1: StKillConn- TcpClose failed:

Notice that IEF403I has the date and that right after midnight, the
current date was inserted into the job log.

To install:
----------

You can install only the pieces you want, maybe only the MPF exit is
all you really want.

1) Assemble and link member MPFEXIT into your LNKLST as rent and reus.
   For the example below, the name MPFEXTOD was used.

2) Update your MPFLSTxx member with:

           IEF403I,SUP(NO),USEREXIT(MPFEXTOD)
           IEF404I,SUP(NO),USEREXIT(MPFEXTOD)

3) Copy member NEWDAYP into a JES PROCLIB, I use member name NEWDAY.
   Change the SYSEXEC library name to your REXX library.

4) Copy member NEWDAYE into your REXX Library.  You will need to update
   the REXX exec to issue command the way your installation allows them.
   I have included my OSCMD assembler program if you don't have one.
   You should put security in your OSCMD to prevent authorized use.

Note: If you have Automate/MVS, the NEWDAY EXEC could be executed
without needing a started task.  Other automated operations packages
may be able to execute REXX code also.

 =====================================================================

 The contents of this file are FREEWARE.  Use at your own risk.  It
 is provided for your enjoyment and neither David Alcock or his
 employer provides any warranty for their use.  I'd like to hear
 feedback on how they work on your system:

    David Alcock :: dave@planetmvs.com

 =====================================================================
./ ADD NAME=MPFEXIT  1100-97081-97081-1322-00278-00278-00000-DALCOCK
MPFEXTOD TITLE '                     Append the date to some messages'
***********************************************************************
***                                                                 ***
**                                                                   **
**    Module Name       = MPFEXTOD                                   **
**                                                                   **
**    Author            = David Alcock                               **
**                        dave@planetmvs.com                         **
**                                                                   **
**    Descriptive Name  = Append the current date to some messages.  **
**                                                                   **
**    Reference         = GC28-1147 MVS-XA SPL: User Exits           **
**                                                                   **
**    Attributes        = Reentrant, Reusable, Authorized            **
**                                                                   **
**    Activated by      = Specifed in active MPF member of Parmlib:  **
**                        - SET MPF=XX                               **
**                          where XX is a member in parmlib:         **
**                          'SYS1.PARMLIB(MPFLSTXX)'                 **
**                        - Reference in MPFLSTXX:                   **
**                       IEF403I,SUP(NO),USEREXIT(MPFEXTOD)          **
**                       IEF404I,SUP(NO),USEREXIT(MPFEXTOD)          **
**                                                                   **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**                                                                   **
**    Change:                                                        **
**                                                                   **
**      IEF403I JOBNAME1 - STARTED - TIME=16.38.17                   **
**      IEF404I JOBNAME1 - ENDED - TIME=16.38.23                     **
**                                                                   **
**    To:                                                            **
**                                                                   **
**      IEF403I JOBNAME1 - STARTED - TIME=16.38.17 - 25-FEB-1997     **
**      IEF404I JOBNAME1 - ENDED - TIME=16.38.23 - 25-FEB-1997       **
**                                                                   **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
**                                                                   **
**  If "MONITOR JOBNAMES" is not active, then we update these as     **
**  well:                                                            **
**                                                                   **
**      $HASP373 JOBNAME2 STARTED - INIT    1 - CLASS U - SYS XYZ5   **
**      $HASP395 JOBNAME2 ENDED                                      **
**                                                                   **
**  And update your MPFLSTxx with:                                   **
**                                                                   **
**                      $HASP373,SUP(NO),USEREXIT(MPFEXTOD)          **
**                      $HASP395,SUP(NO),USEREXIT(MPFEXTOD)          **
**                                                                   **
**  I've noticed that the checks I do to only append either          **
**  IEF40xI or $HASP3xx and not both only work on my test machine    **
**  (where there is only one console).  In production, I only        **
**  have the MPF exit on the IEF40xI messages and hope that          **
**  "MONITOR JOBNAMES" is always active.                             **
**                                                                   **
***                                                                 ***
***********************************************************************
         EJECT
         IEZVX100 ,                       WTO exit parameter list
         YREGS ,                          Equate registers to R0-R15
*
** Using the official ASMH/HLASM distinction trick, simulate the
** SYSVER and SYSDATEC variables of HLASM when assembled under
** ASMH...Taken from Gilbert Saint-flour's SHOWMVS.
*
         LCLA  &ASMH_HLASM
         AIF   (T'&ASMH_HLASM EQ 'N').ASMH1X
&SYSVER  SETC  'ASMH'
&SYSDATC SETC  '20'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)
         AIF   ('&SYSDATC' LT '20500000').ASMH1X
&SYSDATC SETC  '19'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)
.ASMH1X  ANOP
*-Convert assembly date from SYSDATC format "YYYYMMDD" to "YYYY/MM/DD"
         LCLC  &ASMDATE
&ASMDATE SETC  '&SYSDATC'(1,4).'/'.'&SYSDATC'(5,2).'/'.'&SYSDATC'(7,2)
         EJECT
***********************************************************************
***                                                                 ***
**       Intialization                                               **
***                                                                 ***
***********************************************************************
         SPACE 2
MPFEXTOD CSECT ,
MPFEXTOD AMODE 31
MPFEXTOD RMODE ANY
*
** Create a standard O/S eyecatcher
*
EC       B     ECL(0,R15)               Bump past Eyecatcher
         DC    AL1(L'ECLIT)             Length of eyecatcher
ECLIT    DC    C'MPFEXTOD &ASMDATE &SYSTIME - Echo message to TSO user'
         DS    0H                       Ensure halfword alignment
ECL      EQU   *-EC
*
** Standard ESA entry housekeeping
*
         BAKR R14,0                     Save regs
         LAE   R12,0(R15,0)             Get base register
         USING MPFEXTOD,R12             Get addressibility
         SAC  0
         SYSSTATE ASCENV=P
         STORAGE OBTAIN,LENGTH=WORKDSL,LOC=BELOW Obtain storage
         LR   R13,R1                    Point to Save Area
         MVC  4(4,R13),=C'F1SA'         Indicate stack SA
         USING WORKDS,R13               Get addressibility to area
*
** Locate MPF exit parameter list and message area
*
         EREG  R0,R1                    Restore regs 0 and 1
         L     R2,0(R1)                 Get CTXT Address
         ICM   R3,B'1111',CTXTTXPJ-CTXT(R2) Locate Major
         BZ    EXIT                     Shouldn't happen, but leave
*
** See we want to touch these guys
*
         TM    CTXTMTY1-CTXT(R2),CTXTMTYA  Monitor jobnames active?
         BNO   TEST$X                   No, hit the JES2 start/stop
         CLC   CTXTTMSG-CTXTATTR(7,R3),=C'$HASP373'
         BE    EXIT
         CLC   CTXTTMSG-CTXTATTR(7,R3),=C'$HASP395'
         BE    EXIT
TEST$X   DS    0H
*
** Append the current date onto the end of the message
*
         TIME  BIN                      Get current time and date
         STM   R0,R1,DOUBLE             Save time and date
         LA    R15,CTXTTMSG-CTXTATTR(R3) Locate to start of message
         SLR   R14,R14                  Clear register
         ICM   R14,B'0011',CTXTTLEN-CTXTATTR(R3) Get length
         AR    R15,R14
         MVC   0(3,R15),=C' - '
         LA    R15,3(R15)
         LM    R0,R1,DOUBLE             Save time and date
         BAS   R14,CONVERT_TO_TODSTRING Convert the time and date
         LA    R14,CTXTTMSG-CTXTATTR(R3) Locate to start of message
         SR    R15,R14
         STCM  R15,B'0011',CTXTTLEN-CTXTATTR(R3) Set new length
         OI    CTXTRFB1-CTXT(R2),CTXTRCMT  Say we changed it
*
** Release resources and return to caller
*
EXIT     DS    0H
         LR    R2,R13                     Get storage address
         STORAGE RELEASE,LENGTH=WORKDSL,ADDR=(R2) Release storage
         SLR   R15,R15                    Set return code
         PR                               Return to caller
         EJECT
***********************************************************************
***                                                                 ***
** Convert input binary time and packed decimal julian date to a     **
** fancy output string of "dd-mmm-ccyy hh:mm:ss pm"                  **
**                                                                   **
** Input: R0 - Time in binary                                        **
**        R1 - Date in packed decimal                                **
**        R15 - points to the output area                            **
**                                                                   **
** Output: the area in R15 will be filled in and R15 updated with    **
**         address just past the filled in area.                     **
***                                                                 ***
***********************************************************************
         SPACE 2
CONVERT_TO_TODSTRING DS 0H
         ST    R15,CTT_OUT                Save output area address
         ST    R14,CTT_RA                 Save return address
*
** Get the input time (binary) and date (packed decimal) and convert
** it to a STCK TOD format
*
         LA    R14,CTT_CIN                Locate routine Time/Date area
         XC    0(CTAREAL,R14),0(R14)      Clear to binary zeros
         STCM  R0,B'1111',CTAREA_TIME-CTAREA(R14) Save Time
         STCM  R1,B'1111',CTAREA_DATE-CTAREA(R14) Save Date
*
         CONVTOD CONVVAL=CTT_CIN,         Convert this Time/Date       @
               TODVAL=CTT_TOD,            ..To TOD format              @
               TIMETYPE=BIN,              ..Time is binary format      @
               DATETYPE=YYDDD,            ..Date is julian 0CYYDDDf    @
               MF=(E,PARMLIST)
         LTR   R15,R15                    CONVTOD worked?
         BNZ   CTT$JUL                    Failed, do primitive way
*
** Convert the TOD stamp into time and date formats
*
         STCKCONV STCKVAL=CTT_TOD,        Convert this TOD Stamp       @
               CONVVAL=CTT_SOUT,          ..Into these date/time areas @
               TIMETYPE=DEC,              ..Output time format         @
               DATETYPE=DDMMYYYY,         ..Output Date format         @
               MF=(E,PARMLIST)
         LTR   R15,R15                    CONVTOD worked?
         BNZ   CTT$JUL                    Failed, do primitive way
*
** Format the date
*
         L     R15,CTT_OUT                Locate output area
*                               D  D  -  M  M  -  C  C  Y  Y
         MVC   0(11,R15),=X'40,20,20,60,20,20,60,20,20,20,20'
         ED    0(11,R15),CTT_SOUT+8       Edit it to " dd-mm-ccyy"
         MVC   0(3,R15),1(R15)            Move "dd-" over "dd-...-ccyy"
         PACK  DOUBLE(8),4(2,R15)         Get month in decimal
         CVB   R14,DOUBLE                 Convert to binary
         BCTR  R14,0                      Make relative to zero
         MH    R14,=H'3'                  Multiply for month offset
         LA    R1,=C'JanFebMarAprMayJunJulAugSepOctNovDec'
         AR    R1,R14                     Locate month entry
         MVC   3(3,R15),0(R1)             Move "mmm" to "dd-mmm-ccyy"
         OI    0(R15),X'F0'               Ensure leading zero
         LA    R15,11(R15)                Bump past date
*
         MVC   0(3,R15),=C' - '
         LA    R15,3(R15)
CTT$JUL  DS    0H
         UNPK  DOUBLE2(9),#CTTPMD(5)           *
         MVZ   DOUBLE2(8),=8X'00'              ** Hex convert
         TR    DOUBLE2(8),=C'0123456789ABCDEF' *
*
         CLI   #CTTPMD,0                  Century = 19xx?
         BE    CTT$Y19
         CLI   #CTTPMD,1                  Century = 20xx?
         BE    CTT$Y20
         CLI   #CTTPMD,2                  Century = 21xx?
         BNE   CTT$YX
         MVC   0(2,R15),=C'22'
         LA    R15,2(R15)
         B     CTT$YX
CTT$Y19  DS    0H
         MVC   0(2,R15),=C'19'
         LA    R15,2(R15)
         B     CTT$YX
CTT$Y20  DS    0H
         MVC   0(2,R15),=C'20'
         LA    R15,2(R15)
CTT$YX   DS    0H
         MVC   0(2,R15),DOUBLE2+2         Get yy from "0cyydddf"
         MVI   2(R15),C'.'                Insert dot
         MVC   3(3,R15),DOUBLE2+4         Get ddd from "0cyydddf"
         LA    R15,6(R15)                 Locate past "yy.ddd'
         L     R14,CTT_RA                 Get return address
         BSM   0,R14                      Return to caller
#CTTPMD  EQU   CTT_CIN+(CTAREA_DATE-CTAREA)    Generate offset
         EJECT
***********************************************************************
***                                                                 ***
**       Constants                                                   **
***                                                                 ***
***********************************************************************
         SPACE 2
         LTORG ,
         EJECT
***********************************************************************
***                                                                 ***
**       GETMAINed work area                                         **
***                                                                 ***
***********************************************************************
         SPACE 2
         DS    0D
WORKDS   DSECT ,
         DS    18F                    Register Save Area
DOUBLE   DS    D
DOUBLE2  DS    2D
PARMLIST DS    10F
         DS    0D
CTT_TOD  DS    D                        ..TOD (STCK) area
CTT_OUT  DS    F                        ..Output area address
CTT_RA   DS    F                        ..Return address
CTT_CIN  DS    XL(CTAREAL)              ..CONVTOD input area
CTT_SOUT DS    XL16                     ..STCKCON output area
         DS    0D
WORKDSL  EQU   *-WORKDS
*
** Map CONVTOD area
*
CTAREA          DSECT ,
CTAREA_TIME     DS    XL4
                DS    XL4
CTAREA_DATE     DS    XL4
                DS    XL4
CTAREAL         EQU   *-CTAREA
         END
./ ADD NAME=NEWDAYE  1100-97081-97081-1322-00316-00316-00000-DALCOCK
/* REXX
 |
 | Name: NEWDAY
 |
 | Author: David Alcock
 |         dave@planetmvs.com
 |         (based on LSTJOBS written by Paul S. Waterhouse)
 |
 | Purpose: Send a message with the current date right after midnight to
 |          the job log of started tasks to make it easy to know what
 |          day a message was issued.
 |
 |          This exec builds the command to send messages using a
 |          JES2 command.  It would need to be modified for JES3.
 |
 | Requirements: You must have a way to succesfully issue MCS operator
 |               commands via a REXX exec.
 |
 |               Your automated operations task should start this REXX
 |               right after midnight.
 */

/**********************************************************************
***                                                                 ***
**           M o d i f i c a t i o n   H i s t o r y                 **
**                                                                   **
** Person     Date        Description                                **
** ---------- ----------- ------------------------------------------ **
** DGAlcock   22-MAR-1997 Add checking of JES2 command prefix;       **
** DGAlcock   01-MAR-1997 Added: debug mode, jobname check;          **
** DGAlcock   25-FEB-1997 Initial REXX exec written based on Paul    **
**                        Waterhouse's execellent LSTJOBS exec;      **
***                                                                 ***
**********************************************************************/

  arg debug

  xgdate = translate(date(),'-',' ')
  xjdate = substr(date('s'),1,4)"."substr(date('j'),3,3)
  say "%NEWDAY - Execution begins - "xgdate" - "xjdate" - "time()

  mcs_cmd = "@C OSCMD "   /* Installation dependant */
  jes2_cp = "$"

 /*-----------------------------------------------------------------+
  |  Let's only do this if if it makes sense.  This command was     |
  |  designed to be executed right after midnight to put a new      |
  |  date message in the job log of long running tasks.             |
  *-----------------------------------------------------------------*/

  if translate(debug) == "DEBUG" then test = 1
  else test = 0

  address TSO mcs_cmd "D T"  /* Test the waters */
  say "%NEWDAY - Issued command 'D T' - RC="rc

  if substr(time(),1,4) <> "00:0" then do
     say "%NEWDAY - Processing at "time()" doesn't make sense"
     if test then say "%NEWDAY - Continuing in test mode, " ,
        "but no commands will be issued"
     else signal quickout
     end

 /*-----------------------------------------------------------------+
  |  Set numeric digits to accomodate BIG hex numbers in decimal    |
  *-----------------------------------------------------------------*/

  numeric digits 15

 /*-----------------------------------------------------------------+
  |  get address pointers                                           |
  |    CVT (real loc 16)                                            |
  |    ASVT (CVT+22C)                                               |
  *-----------------------------------------------------------------*/

   cvt_ptr = get_ptr(10,0)
   asvt_ptr = get_ptr(cvt_ptr,'22c')

 /*-----------------------------------------------------------------+
  |  get system id * REQUIRES GETSMFID FUNCTION *                   |
  *-----------------------------------------------------------------*/

if sysvar(systsoe) > "2040" then ,             /* At v2.5 or higher? */
   c_sys_smfid = mvsvar(syssmfid)              /* Yes, use IBM func  */
else do
     cvt    = storage(10,4)
     dcvt   = c2d(cvt)
     smca   = storage(c2x(d2c(dcvt+x2d(c5))),3)
     dsmca  = c2d(smca)
     c_sys_smfid = storage(c2x(d2c(dsmca+x2d(10))),4)
     end

if substr(c_sys_smfid,1,3) == "XYZ" then ,
   jes2_cp = "/"           /* XYZ uses / instead of $ */

 /*-----------------------------------------------------------------+
  |  Get MASTER (ASID1) values.                                     |
  |                                                                 |
  |  In the ASVT table (starts at ASVT+X'210') master is always     |
  |  one.                                                           |
  |                                                                 |
  |  If the high bit is on and address is that of masters ASVT entry|
  |  then the ASVT entry is for an unusebale ASVT entry.            |
  |                                                                 |
  *-----------------------------------------------------------------*/

  c_end_of_list = '80000000'                    /* Constant      */

  c_curr_asvt = d2x(x2d(asvt_ptr) + x2d(210))   /* Curreny Entry */

  c_mstr_asvt = d2x(x2d(c_end_of_list) + x2d(c_curr_asvt)) /*unuse*/

  c_ascb_unuse_count = 0

 /*-----------------------------------------------------------------+
  |  Scan ASVT routine                                              |
  |                                                                 |
  |  High order bit on and masters address means unuseable.         |
  |  High order bit on and another address means its free.          |
  |  High order bit not on means its in use (active).               |
  |  End of chain is x'80000000'.                                   |
  |                                                                 |
  *-----------------------------------------------------------------*/

  do forever

     c_curr_asvt = d2x(x2d(c_curr_asvt) + x2d(4))  /* Next Entry    */

     ascb_ptr = get_ptr(c_curr_asvt,0,4)           /* Pointer Value */

     select

         /*--------------------------------------------+
          |  End of list check                         |
          *--------------------------------------------*/

           when ascb_ptr = c_end_of_list then
                do
                  leave
                end

         /*--------------------------------------------+
          |  Unuseable check                           |
          *--------------------------------------------*/

           when ascb_ptr = c_mstr_asvt then
                do
                  c_ascb_unuse_count = c_ascb_unuse_count + 1
                  iterate
                end

         /*--------------------------------------------+
          |  x'80' is decimal 128 - this checks for    |
          |  not in use.                               |
          *--------------------------------------------*/

           when x2d(substr(ascb_ptr,1,1)) > 128 | ,
                x2d(substr(ascb_ptr,1,1)) = 128 then
                do
                  iterate
                end

         /*--------------------------------------------+
          |  We got a live one!                        |
          |  Falls out of this select.                 |
          *--------------------------------------------*/

     otherwise
              do
                nop
              end
     end

 /*-----------------------------------------------------------------+
  |  Live one found!!!!!!!                                          |
  |                                                                 |
  |     (1) Check to make sure that ASCB pointer is valid.          |
  |         first four characters at that address must be "ASCB"    |
  |                                                                 |
  |     (2) Get ASID and JOBNAME from ASCB:                         |
  |         ASID = ASCB+X'24' H = ASCBASID                          |
  |         JOBN = ASCB+X'AC' H = ASCBJBNI (Initiated Job)          |
  |           or = ASCB+X'B0' H = ASCBJBNS (STC/TSO)                |
  |                                                                 |
  |      If we got one still, add it to table.                      |
  |      and get next.                                              |
  |                                                                 |
  |      NOTE: No serialization is done, so system can change       |
  |            this data while we are running. DO NOT USE DATA      |
  |            extracted from this routine WITHOUT CHECKING IT      |
  |            FIRST!!!!!!!!!!!!!                                   |
  |                                                                 |
  *-----------------------------------------------------------------*/

     if "ASCB" Â¬= get_data(ascb_ptr,0,4) then
        do
          iterate
        end

     c_jbni = get_ptr(ascb_ptr,'AC')
     c_jbns = get_ptr(ascb_ptr,'B0')
     c_asid = get_hlf(ascb_ptr,'24')

     if c_jbni = 0 then
        do
          jobn_ptr = c_jbns
        end
      else
        do
          jobn_ptr = c_jbni
        end

     c_jobn = get_data(jobn_ptr,0,8)

    /*--------------------------------------------------------------*
     | This code issues a command based on:                         |
     | - if this is a JES-managed address space (has a job log)     |
     | - if this is a started task                                  |
     | - the started task it not to be excluded based on jobname    |
     *--------------------------------------------------------------*/

     assb_ptr = get_ptr(ascb_ptr,'150')
     t_jsab = get_full(assb_ptr,'A8')

     if t_jsab <> "00000000" then do

        jsab_ptr = get_ptr(assb_ptr,'A8')
        c_jobid = get_data(jsab_ptr,'14',8)

        if substr(c_jobid,1,3) == "STC" then do
           say "> Name:" c_jobn "JOBID:" c_jobid

           /* Put the stc names here that we don't want to send msg */
           select
             when c_jobn == "INIT    " then execute_command = 0
             when c_jobn == "xxxxxxxx" then execute_command = 0
             otherwise
                  execute_command = 1
           end /* of select */

           if execute_command then do
              num = substr(c_jobid,4,5) /* stcxxxxx */
              opercmd = jes2_cp"dms"num",'----- Date:" ,
                        xgdate "-" xjdate "'"
              say "        Command: "opercmd

              if test == 0 then do
                 address TSO mcs_cmd opercmd
                 orc = rc
                 say "        Command RC="orc
                 end

              end /* of "if execute_command" */
           else do
                say "        Command was not issued based on jobname"
                end
           say " "

           end /* of "if substr(c_jobid,1,3) == STC" */
        end /* if t_jsab <> "00000000" */

  end

 /*-----------------------------------------------------------------+
  |  End of REXX exec                                               |
  *-----------------------------------------------------------------*/

  say "%NEWDAY - Unusable ASIDS:" c_ascb_unuse_count
  quickout:
  say "%NEWDAY - Execution ends"
  exit

get_ptr: procedure
    /* +-----------------------------------------+
       | returns a 4 byte pointer as hexadecimal |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,4))
  exit

get_full: procedure
    /* +-----------------------------------------+
       | returns a 4 byte field as hexadecimal   |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,4))
  exit

get_hlf: procedure
    /* +-----------------------------------------+
       | returns a 2 byte field as hexadecimal   |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,2))
  exit

get_data: procedure
    /* +-----------------------------------------+
       | returns LENGTH bytes at ADDR+OFFSET as  |
       | an EBCDIC string.                       |
       | ADDR and OFFSET must be HEX strings.    |
       | LENGTH must be a decimal string.        |
       +-----------------------------------------+ */
  arg addr, offset, length
  temp = d2x(x2d(addr) + x2d(offset))
  return storage(temp,length)
  exit
./ ADD NAME=NEWDAYP  1100-97081-97081-1322-00014-00014-00000-DALCOCK
//NEWDAY  PROC
//*********************************************************************
//***                                                               ***
//** THIS PROC IS A STARTED TASK SENDS MESSAGES TO ALL STARTED TASKS **
//** SO AN ENTRY IN THE JOBLOG SHOWS A NEW DAY HAS STARTED.  THIS    **
//** MAKES IT EASIER TO LOOK THRU A JOB LOG AND KNOW WHAT DAY        **
//** A MESSAGE CAME OUT ON.                                          **
//***                                                               ***
//*********************************************************************
//IEFPROC EXEC PGM=IKJEFT01,TIME=1439,DYNAMNBR=100,
//        PARM='%NEWDAY'       (rename the NEWDAYE member to this)
//SYSTSPRT DD SYSOUT=X
//SYSTSIN  DD DUMMY
//SYSPROC  DD DISP=SHR,DSN=your.rexx.library
./ ADD NAME=OSCMD    1100-97081-97081-1322-00234-00234-00000-DALCOCK
 Note: replace ENTER and LEAVE with your Entry and exit housekeeping.
***********************************************************************
***                                                                 ***
** Name: OSCMD                                                       **
**                                                                   **
** Author: David G. Alcock                                           **
**                                                                   **
** Purpose: Issue operator command from TSO/CLIST or via batch.      **
**                                                                   **
** Attributes: Reentrant, Reusable, and APF authorized               **
**                                                                   **
***                                                                 ***
***********************************************************************
         EJECT
OSCMD    ENTER 'ISSUE OPERATOR COMMANDS',                              @
               LV=DSAL,RENT=YES,                                       @
               AMODE=31,RMODE=ANY
         USING DSA,R13                    Get addressiblity to area
         EJECT
***********************************************************************
***                                                                 ***
**       Initialization                                              **
***                                                                 ***
***********************************************************************
         SPACE 2
         ST    R1,R1SAVE                  Save address of input parms
*
** Must be APF authorized
*
         TESTAUTH FCTN=1                 Check for APF Authorization
         LTR   R15,R15                   Are we?
         BNZ   E$APF                     No, leave
*
** User authorized to use this command?
*
VERIFY_TECH_SUPPORT EQU *
         L     R1,PSATOLD-PSA       -> TCB
         L     R1,TCBTIO-TCB(R1)    -> TIOT
         CLC   TIOCNJOB-TIOT1(8,R1),=CL8'CLEAR'  Clear started task
         BE    PROCEED              Yes...
         CLC   TIOCNJOB-TIOT1(8,R1),=CL8'CLEARBC' CLEARBC started task?
         BE    PROCEED              Yes...
         CLC   TIOCNJOB-TIOT1(8,R1),=CL8'NEWDAY' Newday
         BE    PROCEED              Yes...
* Put other checks here like looking at ACF2 LID...
         B     E$NAUTH
PROCEED EQU *
         EJECT ,
***********************************************************************
***                                                                 ***
**       Process input parameters from CBUF or O/S parameter         **
***                                                                 ***
***********************************************************************
         SPACE 2
PROCESS_PARAMETER EQU *
 L     R1,R1SAVE                          -> CPPL
 TM    CPPLCBUF-CPPL(R1),X'80'            Was this command called?
 BNO   PP$NC                              No, need to look at CBUF
*
** We were called, it has a Batch type (EXEC) parameter
*
 L     R2,0(R1)                           Get address of parm
 SLR   R3,R3                              Clear register
 ICM   R3,B'0011',0(R2)                   Get length of parm
 BZ    EXIT                               None, leave
 LA    R2,2(R2)                           Bump past parm length HW
 B     PP$X                               Parse the input
*
** DGAT902 was not called, it is a "Command Processor"
*
PP$NC EQU   *
 L     R2,CPPLCBUF-CPPL(R1)               Locate Command Buffer
 SLR   R3,R3                              Clear register
 ICM   R3,B'0011',0(R2)                   Get total CBUF length
 SLR   R0,R0                              Clear register
 ICM   R0,B'0011',2(R2)                   Get total Command name length
 LA    R15,4                              Length of header
 AR    R2,R15                             Bump past header
 SR    R3,R15                             Decrement for header length
 AR    R2,R0                              Bump past Command length
 SR    R3,R0                              Length of data
 LTR   R3,R3
 BZ    EXIT
*
** R2 - Address of command-buffer/Parameter
** R3 - Length of command-buffer/Parameter
*
PP$X     EQU   *
         BCTR  R3,0                       Decrement for EX
         EJECT
***********************************************************************
***                                                                 ***
**       Issue the command                                           **
***                                                                 ***
***********************************************************************
         SPACE 2
*
** Issue WTO for audit trail
*
         BAS   R9,FORMAT_WTO              Format the WTO
         MVC   0(MSG1L,R15),MSG1          Move in message
         LA    R15,MSG1L+1(R15)           Bump past the message
         EX    R3,MOVEWTO                 Move the command to WTO area
         LA    R15,1(R3,R15)              Bump past the message
         BAS   R9,ISSUE_WTO               Issue the WTO
*
** Issue the command
*
         LA    R14,COMMAND               Locate Command area
         XC    0(MGCRLTH,R14),0(R14)     Clear it to binary zeros
*
         LA    R15,MGCRTEXT-MGCRPL(R14)  Locate Command area
         EX    R3,MOVECMD                Move command to buffer area
         LA    R15,1(R3,R15)             Bump past it
*
         SR    R15,R14                   Length = end - Beginning
         STC   R15,MGCRLGTH-MGCRPL(R14)  Save length
*
         MODESET KEY=ZERO,MODE=SUP       Get into Key Zero
*
         SLR   R0,R0                     Clear register
         MGCR  COMMAND                   Issue command
*
         MODESET KEY=NZERO,MODE=PROB     Get out of Key Zero
         EJECT ,
***********************************************************************
***                                                                 ***
**       Termination section                                         **
***                                                                 ***
***********************************************************************
         SPACE 2
EXIT     EQU   *
         LEAVE ,                                  Return to caller
E$NAUTH  WTO   'OSCMD-99E You are not authorized to use this command'
         B     EXIT
E$APF    WTO   'OSCMD-98E This command must be APF authorized'
         B     EXIT
         EJECT
***********************************************************************
***                                                                 ***
**                 Dynamic WTO Processing                            **
***                                                                 ***
***********************************************************************
         SPACE 2
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** FORMAT THE WTO AND INITIALIZE THE PREFIX AREA                     **
** INPUT: R1 - ADDRESS OF MESSAGE NUMBER TO BE FILLED IN (3 BYTES)   **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
FORMAT_WTO EQU *
*
** INITIALIZE THE WTO
*
         LA    R15,WTO                    LOCATE WORK AREA
         XC    0(WPLTXT-WPL,R15),0(R15)   CLEAR COMMON SECTION
         OI    WPLMCSF1-WPL(R15),WPLMCSFA ROUTE CODE/DESC PRESENT
         OI    WPLMCSF1-WPL(R15),WPLMCSFG ONLY QUEUE TO HARD COPY
*        OI    WPLMCSF2-WPL(R15),WPLMCSFI NO TIME STAMP
         LA    R15,WPLTXT-WPL(R15)        LOCATE MESSAGE TEXT AREA
         MVI   0(R15),C' '                MOVE BLANK INTO TEXT AREA
         MVC   1(124,R15),0(R15)          ..PROPAGATE BLANK
*
** Message Prefix Stuff
*
         MVC   0(5,R15),5(R12)            Move in "OSCMD"
         MVI   5(R15),C'-'
         LA    R15,5+1(R15)               BUMP PAST IT
*
         BSM   0,R9                       RETURN TO CALLER
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
** COMPLETE THE WTO AND ISSUE IT                                     **
** INPUT: R15 - ADDRESS PAST LAST BYTE OF WTO TEXT                   **
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **
ISSUE_WTO EQU *
*
** COMPLETE THE WTO DESC/ROUT
*
         XC    0(WPLQID-WPLFLGS,R15),0(R15)     CLEAR FLAG BYTES
         OI    WPLDESC1-WPLFLGS(R15),WPLDESCG   REGULAR MESSAGE
         OI    WPLROUT2-WPLFLGS(R15),WPLROUTN   ROUTCDE=14
         LA    R15,L'WPLDESC+L'WPLROUT(R15)     BUMP PAST ROUT/DESC
*
** COMPUTE THE LENGTH: TEXT + ROUT/DESC
*
         LA    R1,WTO+WPLTXT-WPL          LOCATE BEGINNING OF TEXT
         SR    R15,R1                     LENGTH = END - BEGINNING
         STCM  R15,B'0011',WTO+WPLLGH-WPL SAVE LENGTH
         WTO   ,MF=(E,WTO)                ISSUE THE WTO
*
         BSM   0,R9                       RETURN TO CALLER
         EJECT
***********************************************************************
***                                                                 ***
**        Constants                                                  **
***                                                                 ***
***********************************************************************
         SPACE 2
MOVEWTO  MVC   0(0,R15),0(R2)             ** Executed **
MOVECMD  MVC   0(0,R15),0(R2)            ** Executed **
*
MSG1     DC    C'01I Command issued:'
MSG1L    EQU   *-MSG1
         LTORG ,                              Literals
         DS    0D
         EJECT
***********************************************************************
***                                                                 ***
**       Getmained Work area                                         **
***                                                                 ***
***********************************************************************
         SPACE 2
DSA      DSECT ,
         DS    18F                        Register Save Area
R1SAVE   DS    F                          R1 at entry
WTO      DS    XL(#WPL)                   WTO work area
COMMAND  DS    XL(MGCRLTH)                Operator Command work area
NJECMD   DS    XL(MGCRLTH)                Operator Command work area
         DS    0D
DSAL     EQU   *-DSA                      Length of DSA
         EJECT ,
***********************************************************************
***                                                                 ***
**       DSECTS                                                      **
***                                                                 ***
***********************************************************************
         SPACE 2
         IKJCPPL ,                        Cmd Processor Parm List
         IEZMGCR  DSECT=NO                SVC 34 Parameter List
         IHAPSA ,                         Prefixed Save Area
         IKJTCB ,
         IEFTIOT1 ,
         IHAASCB ,                        Address Space Control Block
         IEZWPL ,
#WPL     EQU    L'WPLLGH+L'WPLMCSF+L'WPLTXT+L'WPLDESC+L'WPLROUT
         END ,
./ ENDUP       "REVIEW" PDS MEMBER OFFLOAD AT 15:16 ON 98/01/16
