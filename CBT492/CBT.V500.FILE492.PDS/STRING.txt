*/GILBERTM JOB (ACCT#),STRING,
*/ NOTIFY=&SYSUID,
*/ CLASS=A,MSGCLASS=X,COND=(0,NE)
*/HLASM EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF,
*/*FLAG(PAGE0),NORXREF,NODXREF,                   HLASM R3
*/ NOBATCH)
***********************************************************************
*                                                                     *
* MACRO NAME = STRING                                                 *
*                                                                     *
* DESCRIPTIVE NAME = STRING Macro Instruction.                        *
*                                                                     *
* FUNCTION = Provide capabilities similar to PUT EDIT (of PL/I)       *
*            or STRING (of COBOL) to assembler programs.              *
*                                                                     *
*            http://gsf-soft.com/Freeware/STRING.shtml                *
*                                                                     *
* STATUS = R515                                                       *
*                                                                     *
* AUTHOR = Gilbert Saint-Flour <gsf@pobox.com>                        *
*                                                                     *
* ENVIRONMENT = SEE BELOW                                             *
*                                                                     *
*     AMODE = ANY                                                     *
*     RMODE = ANY                                                     *
*     SCP   = OS/360, OS/VS, MVS/370, MVS/XA, MVS/ESA, OS/390 or z/OS *
* Processor = Assembler H, High-Level Assembler                       *
*     KEY   = ANY                                                     *
*     MODE  = ANY                                                     *
*     APF   = ANY                                                     *
*                                                                     *
* OPERATION = SEE DOCUMENTATION AT THE END OF THIS FILE               *
*                                                                     *
* INVOCATION = SEE DOCUMENTATION AT THE END OF THIS FILE              *
*                                                                     *
* NOTES = SEE DOCUMENTATION AT THE END OF THIS FILE                   *
*                                                                     *
* CHANGE ACTIVITY                                                     *
*                                                                     *
*  $301  FIX BUGS WITH (XYZ,,L8) AND INTO=((R1),(R2))                 *
*  $302  GENERATE $DEBUG BOOT-STRAP IN FINAL_CALL INVOCATION          *
*  $303  REPLACE @STRPAD WITH @STRBLANKS                              *
*  $304  USE @00-@15 INSTEAD OF R0-R15 FOR REGISTER EQUATES           *
*  $306  TAILOR @STRING CSECT TO PROGRAM'S REQUIREMENTS               *
*        LITERALS CAN BE CODED AS 'ABC' OR C'ABC' OR X'C1C2C3'        *
*        USE L'PSATOLD AS IMPLICIT LENGTH FOR (PSATOLD-PSA,,X)        *
*  $307  FINAL_CALL OPTION CHANGED TO GENERATE                        *
*        ADD NOCSECT AND LOCTR OPTIONS TO GENERATE CALL               *
*  $308  USE L'RBCDE AS IMPLICIT LENGTH FOR (PRB.RBCDE,,X)            *
*        PREVENT S0C4 WHEN ADDR IS BAD AND LENGTH IS ZERO             *
*  $400  REORG THE CODE TO SIMPLIFY FEATURE SELECTION                 *
*        BLANKS NO LONGER USED OR GENERATED                           *
*  $401  GENERATE @STRHEXT WHEN ((REG),,X) ONLY HEX FIELD             *
*  $502  @STRING ROUTINE REWRITTEN FOR MVS/ESA:                       *
*        -  USE LINKAGE STACK TO STORE CALLER'S REGISTERS             *
*        -  ADD SUPPORT FOR AR MODE                                   *
*        -  @STRING now executes in caller's AMODE                    *
*        -  Rename previous version to STRINGXA                       *
*  $503  DATE CONVERSION TO YYYY-MM-DD FORMAT (ISO STANDARD)          *
*        IMPROVE SUPPORT FOR AR MODE                                  *
*  $504  SET &STRBLANKS TO 10 WHEN PROCESSING DATES                   *
*  $505  Allow for 128K-offset                                        *
*  $506  Remove literal from BAL instruction for HLASM R3             *
*  $507  Merge STRINGXA code, add AR_MODE option                      *
*        Change syntax of GENERATE call                               *
*  $508  Compatibility with FLAG(PAGE0) in HLASM R3                   *
*        Compatibility with pre-XA version of the SAVE macro          *
*        Remove AMODE-based R2 cleanup in 370 mode                    *
*  $509  Length of parm-list entries can vary between 2 and 6 bytes   *
*        Short Literals (one to five bytes) are generated in parm list*
*        Hex string can contain commas, e.g. X'12,3456,7890'          *
*  $510  JDATE=90366 produces 90/13/01 instead of S0C7                *
*  $511  Prevent ACTR error with long literals                        *
*  $512  Packed fields no longer ignored when R0=0                    *
*  $513  Local base not needed for (GENERATE,,LOCTR)                  *
*  $514  '&&'(1,1) at .LIT11C                                         *
*  $515  Negative Value: -12345678                       Tim Alpaerts *
***********************************************************************
         MACRO
&NAME    STRING &INTO=,&PRINT=NOGEN
         GBLC  &STRING_MACRO_VERSION
&STRING_MACRO_VERSION SETC '515'       current version
         AIF   ('&PRINT' EQ 'NOGEN').NOGEN
         PUSH  PRINT
         PRINT GEN
.NOGEN   GBLA  &$_LIT
         GBLB  &$_FEAT(16)             FEATURES
.*                                       1 LITERALS
.*                                       2 REGISTER (BIN)
.*                                       3 REGISTER (HEX)
.*                                       4 PACKED
.*                                       5 JDATE
.*                                       6 BINARY
.*                                       7 HEX
.*                                       8 NUMERIC
.*                                       9 LEFT JUST (NUMERIC)
.*                                       10 LEADING ZEROES
.*                                       11 TRUNCATE (CHAR STRING)
.*                                       12 %TIME
         GBLC  &$_LITS(9999)           LITERALS
         LCLA  &I,&J,&L,&N,&FLAG,&LEN2,&STRBLANKS
         LCLB  &LAST,&BIN,&HEX,&REG,&PACKED,&LEFT,&ZERO,&TRUNC,&NUMERIC
         LCLC  &LABEL,&LQ,&STR,&TO1,&TO2,&P1S,&P2C,&P2L,&P3C,&P3L
         LCLC  &LIT,&ALLFEAT,&OPT2,&OPT3
         AIF   (T'&INTO EQ 'O' AND N'&SYSLIST EQ 1                     X
               AND '&SYSLIST(1,1)' EQ 'GENERATE').GENL
&LABEL   SETC  'IHB&SYSNDX'            STEM FOR LOCAL LABELS
&LQ      SETC  'L'''                   LENGTH ATTRIBUTE
&STR     SETC  '  R&STRING_MACRO_VERSION'
&NAME    BAS   R14,$STRING&STR         CALL @STRING SUB-ROUTINE
         AIF   (N'&SYSLIST EQ 0).ERR1  NO POSITIONAL OPERANDS, ERROR
         AIF   (T'&INTO EQ 'O').ERR2   NO RECEIVING FIELD, ERROR
         AIF   (N'&INTO GT 2).ERR2     INTO=(A,32,BLURB)
         DC    AL2((&LABEL.P-*)/2)     OFFSET TO FIELD DESCRIPTORS
         AIF   (D'$LITERAL).LOCTR2     NOT FIRST TIME, JUMP
$LTORG   LOCTR                         ADDRESSABLE CONSTANTS
$FARRTNE LOCTR                         FAR ROUTINES
.LOCTR2  ANOP
$LITERAL LOCTR                         NON-ADDRESSABLE CONSTANTS
&TO1     SETC  '&INTO(1)'
&TO2     SETC  '&LQ&INTO'
         AIF   (N'&INTO EQ 1).PUNTO8            JUMP IF INTO=XXX
         AIF   ('&INTO(1)'(1,1) NE '(').PUNTO3  JUMP IF INTO=(XXX,44)
&TO1     SETC  '0&INTO(1)'                              INTO=((R3),44)
.PUNTO3  ANOP
&TO2     SETC  '&INTO(2)'                               INTO=(XXX,LL)
         AIF   ('&INTO(2)'(1,1) NE '(').PUNTO8  JUMP IF INTO=(XXX,44)
&TO2     SETC  '0&INTO(2)'                              INTO=(XXX,(R1))
.PUNTO8  ANOP
&LABEL.P DC    S(&TO1,&TO2)
.*--------------------------------------------------------------------*
.*-------      FIELDS       ------------------------------------------*
.*--------------------------------------------------------------------*
         LCLB  &LAST,&BIN,&HEX,&REG,&PACKED,&LEFT,&ZERO,&TRUNC
&I       SETA  1
.*LOOP
.LOOP1   ANOP
         ACTR  200                            SYSDEBUG/DIAG055
         AIF   (N'&SYSLIST(&I) GT 3).FLD990   TOO MANY SUB-OPERANDS
&LAST    SETB  (&I EQ N'&SYSLIST)                LOOP
         AIF   ('&SYSLIST(&I)'(1,1) EQ '''').LIT00
         AIF   ('&SYSLIST(&I)'(K'&SYSLIST(&I),1) EQ '''').LIT01
.*--------------------------------------------------------------------*
.*       PROCESS FIRST SUBPARAMETER (ADDRESS)                         *
.*--------------------------------------------------------------------*
&P1S     SETC  '&SYSLIST(&I,1)'
&P2L     SETC  '0'                     INPUT LENGTH
&P3L     SETC  '0'                     OUTPUT LENGTH
         AIF   ('&SYSLIST(&I)'(1,1) GE '0').FLD180 SPACES
         AIF   ('&SYSLIST(&I)' EQ '%TIME').FLD190 %TIME
         AIF   ('&SYSLIST(&I,1)'(1,1) NE '(').FLD115 (R2)
         AIF   (T'&SYSLIST(&I,2) EQ 'O').FLD250
&P1S     SETC  '0&SYSLIST(&I,1)'       CHANGE (R1) TO 0(R1)
.FLD115  ANOP
.*
         AIF   (T'&SYSLIST(&I,2) NE 'O').FLD200
.*
.*       EXTRACT RBCDE FROM PRB.RBCDE (HLASM)
.*
&L       SETA  1
.*--LOOP
.FLD131  AIF   ('&P1S'(&L,1) EQ '.').FLD133
&L       SETA  &L+1
         AIF   (&L LT K'&P1S).FLD131
.*--ENDLOOP
&P2L     SETC  '&P1S'                    ABCDEF FROM ABCDEF
         AGO   .FLD134
.FLD133  ANOP
&P2L     SETC  '&P1S'(&L+1,K'&P1S-&L)    RBCDE FROM PRB.RBCDE
.FLD134  ANOP
.*
         AIF   (T'&SYSLIST(&I,2) NE 'O').FLD200
.*
         AIF   (NOT D'&P2L).FLD140
&P2C     SETC  T'&P2L
.*MNOTE *,'&P1 &P2C'
         AIF   ('&P2C' EQ 'F' OR '&P2C' EQ 'H' OR '&P2C' EQ 'P').FLD220
         AIF   ('&P2C' EQ 'G').FLD210  FL2
.FLD140  ANOP
.*
.*       EXTRACT PSATOLD FROM PSATOLD-PSA
.*
&L       SETA  1
.*--LOOP
.FLD141  AIF   ('&P2L'(&L,1) EQ '-').FLD143
         AIF   ('&P2L'(&L,1) EQ '+').FLD143
&L       SETA  &L+1
         AIF   (&L LT K'&P2L).FLD141
.*--ENDLOOP
&P2L     SETC  '&LQ&P2L'               L'ABCDEF
         AGO   .FLD300
.FLD143  ANOP
&P2L     SETC  '&LQ'.'&P2L'(1,&L-1)    L'PSATOLD FROM PSATOLD-PSA
         AGO   .FLD300
.*
.FLD180  AIF   ('&SYSLIST(&I)'(K'&SYSLIST(&I),1) NE 'X').FLD800
&P2L     SETC  '&SYSLIST(&I)'(1,K'&SYSLIST(&I)-1) 12
         AIF   (&LAST).FLD186
         DC    X'60',AL1(&P2L)         BLANKS
         AGO   .LIT90
.FLD186  DC    X'E0',AL1(&P2L),0S(0)   BLANKS
         AGO   .LIT90
.*
.FLD190  ANOP                          %TIME
&P1S     SETC  '1(14)'                 %TIME
&$_FEAT(12) SETB 1                     %TIME
         AGO   .FLD800
.*--------------------------------------------------------------------*
.*       PROCESS SECOND SUBPARAMETER (LENGTH/TYPE)                    *
.*--------------------------------------------------------------------*
.FLD200  AIF   (T'&SYSLIST(&I,2) EQ 'O').FLD300 NO LENGTH SPECIFIED
&P2C     SETC  '&SYSLIST(&I,2)'
         AGO   .FLD220
.*T'&P1=G
.FLD210  ANOP
&L       SETA  L'&SYSLIST(&I)          T'&P1 = 'G'
&P2C     SETC  'FL&L'                  T'&P1 = 'G'
.*
.FLD220  ANOP
&P2L     SETC  '0&P2C'                 (R2) LENGTH
         AIF   ('&P2C'(1,1) EQ '(').FLD300
&P2L     SETC  '&P2C'                  3(R2) LENGTH
         AIF   ('&P2C'(K'&P2C,1) EQ ')').FLD300
&P2L     SETC  '0'
&PACKED  SETB  ('&P2C' EQ 'P')
         AIF   (&PACKED).FLD290
&P2L     SETC  '1'
         AIF   ('&P2C' EQ 'FL1').FLD240
&P2L     SETC  '3'
         AIF   ('&P2C' EQ 'FL2' OR '&P2C' EQ 'H').FLD240
&P2L     SETC  '7'
         AIF   ('&P2C' EQ 'FL3').FLD240
&P2L     SETC  '15'
         AIF   ('&P2C' EQ 'F').FLD240
&P2L     SETC  '&P2C'                  IMMEDIATE LENGTH, FIELD
         AGO   .FLD300
.*
.FLD240  ANOP                          BINARY VARIABLE
&BIN     SETB  1
         AGO   .FLD300
.*
.FLD250  ANOP                          REGISTER CONTENT
&REG     SETB  1
         AGO   .FLD300
.*
.FLD290  ANOP                          PACKED
&P2L     SETC  '1'
.*--------------------------------------------------------------------*
.*       PROCESS THIRD SUBPARAMETER (OUTPUT FORMAT)                   *
.*--------------------------------------------------------------------*
.FLD300  AIF   (T'&SYSLIST(&I,3) EQ 'O').FLD800
&HEX     SETB  ('&SYSLIST(&I,3)' EQ 'X') HEXADECIMAL
&TRUNC   SETB  ('&SYSLIST(&I,3)' EQ 'T') TRUNCATE
         AIF   (&HEX OR &TRUNC).FLD800
.*
&P3C     SETC  '&SYSLIST(&I,3)'
&P3L     SETC  '248'
         AIF   ('&P3C' EQ 'YYYY-MM-DD' AND &PACKED).FLD308
&P3L     SETC  '249'
         AIF   ('&P3C' EQ 'YYYYMMDD' AND &PACKED).FLD308
&P3L     SETC  '250'
         AIF   ('&P3C' EQ 'YY/MM/DD' AND &PACKED).FLD308
&P3L     SETC  '251'
         AIF   ('&P3C' EQ 'DD/MM/YY' AND &PACKED).FLD308
&P3L     SETC  '252'
         AIF   ('&P3C' EQ 'MM/DD/YY' AND &PACKED).FLD308
&P3L     SETC  '253'
         AIF   ('&P3C' EQ 'YYMMDD'   AND &PACKED).FLD308
&P3L     SETC  '0'
         AIF   (T'&SYSLIST(&I,2) NE 'N').FLD310
         MNOTE 8,'EDIT PATTERN NOT ALLOWED WITH CHARACTER STRING'
         AGO   .FLD310
.FLD308  ANOP
&$_FEAT(5) SETB 1                      JDATE
         AGO   .FLD800
.*--LOOP
.FLD310  AIF   ('&P3C'(1,1) EQ 'R').FLD318       DEFAULT
         AIF   ('&P3C'(1,1) EQ 'B').FLD318       DEFAULT
         AIF   ('&P3C'(1,1) NE 'L').FLD311
&LEFT    SETB  1
         AGO   .FLD318
.FLD311  AIF   ('&P3C'(1,1) NE 'Z').FLD312
&ZERO    SETB  1
         AGO   .FLD318
.FLD312  AIF   ('&P3C'(1,1) LT '0').FLD993       nn in RnnB is not num
         AIF   ('&P3C'(1,1) GT '9').FLD993       nn in RnnB is not num
&P3L     SETC  '&P3L'.'&P3C'(1,1)
.FLD318  ANOP
.*MNOTE *,'&SYSLIST(&I) P3C=/&P3C/ P3L=/&P3L/'
&P3C     SETC  '&P3C '(2,K'&P3C-1)     STRIP OFF FIRST CHARACTER
         AIF   (K'&P3C GT 0).FLD310
.*--ENDLOOP
         AIF   (&P3L GT 16).FLD993               nn in RnnB is too big
.*--------------------------------------------------------------------*
.FLD800  ANOP
&NUMERIC SETB  (&BIN OR &PACKED OR (&REG AND NOT &HEX))
&TRUNC   SETB  (&TRUNC OR (&LEFT AND NOT &NUMERIC))
&LEFT    SETB  (&LEFT AND &NUMERIC)
         AIF   (NOT &NUMERIC).FLD810
         AIF   (&LEFT OR '&P3L' NE '0').FLD810
&P3L     SETC  '7'                     DEFAULT OUTPUT LENGTH ((R3))
         AIF   (&REG).FLD810
&P3L     SETC  '3'                     DEFAULT OUTPUT LENGTH
         AIF   ('&P2C' EQ 'FL1').FLD810
&P3L     SETC  '5'                     DEFAULT OUTPUT LENGTH
         AIF   ('&P2C' EQ 'H' OR '&P2C' EQ 'FL2').FLD810
&P3L     SETC  '7'                     DEFAULT OUTPUT LENGTH
.FLD810  ANOP
&FLAG    SETA  &HEX*8+&BIN*4+&PACKED*2+&REG*1
&LEN2    SETA  &TRUNC*128+&LEFT*128+&ZERO*64+&P3L
&$_FEAT(2) SETB (&$_FEAT(2) OR (&REG AND NOT &HEX))   REGISTER (BIN)
&$_FEAT(3) SETB (&$_FEAT(3) OR (&REG AND &HEX))       REGISTER (HEX)
&$_FEAT(4) SETB (&$_FEAT(4) OR &PACKED)               PACKED
&$_FEAT(6) SETB (&$_FEAT(6) OR &BIN)                  BINARY
&$_FEAT(7) SETB (&$_FEAT(7) OR (&HEX AND NOT &REG))   HEX
&$_FEAT(8) SETB (&$_FEAT(8) OR &NUMERIC)              BIN,PACKED
&$_FEAT(9) SETB (&$_FEAT(9) OR (&LEFT AND &NUMERIC))
&$_FEAT(10) SETB (&$_FEAT(10) OR &ZERO)
&$_FEAT(11) SETB (&$_FEAT(11) OR &TRUNC)
&BIN     SETB  0                    RESET FLAGS
&HEX     SETB  0                    RESET FLAGS
&REG     SETB  0                    RESET FLAGS
&PACKED  SETB  0                    RESET FLAGS
&LEFT    SETB  0                    RESET FLAGS
&ZERO    SETB  0                    RESET FLAGS
&TRUNC   SETB  0                    RESET FLAGS
         AIF   (&FLAG GE 10).FLD995
         AIF   (&LAST).FLD816
         DC    X'0&FLAG',AL1(&LEN2),SL2(&P1S,&P2L)
         AGO   .LIT99
.FLD816  DC    X'8&FLAG',AL1(&LEN2),SL2(&P1S,&P2L),0S(0)
         AGO   .LIT99
.FLD990  MNOTE 12,'OPERAND &I HAS TOO MANY SUB-OPERANDS'
         AGO   .LIT99
.FLD993  MNOTE 8,'THIRD SUBPARAMETER IS INVALID: ''&SYSLIST(&I,3)'''
         AGO   .LIT99
.FLD995  MNOTE 8,'Invalid Combination of Attributes: &SYSLIST(&I)'
         AGO   .LIT99
.*--------------------------------------------------------------------*
.*------------ LITERALS ----------------------------------------------*
.*--------------------------------------------------------------------*
.LIT00   ANOP
&LIT     SETC  'C&SYSLIST(&I)'
         AGO   .LIT09
.LIT01   ANOP
&LIT     SETC  '&SYSLIST(&I)'
.LIT09   ANOP                              calculate length of literal
&J       SETA  3
&L       SETA  0
         ACTR  K'&LIT+K'&LIT+100
         AIF   ('&LIT'(1,1) EQ 'X').LIT11X
.*LOOP
.LIT11C AIF ('&LIT'(&J,1) NE '''' AND '&LIT'(&J,1) NE '&&'(1,1)).LIT12C
&J       SETA  &J+1
.LIT12C  ANOP
&J       SETA  &J+1
&L       SETA  &L+1
         AIF   (&J LT K'&LIT).LIT11C
.*ENDLOOP
         AGO   .LIT15
.*LOOP
.LIT11X  AIF   ('&LIT'(&J,1) EQ ',').LIT12X
&L       SETA  &L+1
.LIT12X  ANOP
&J       SETA  &J+1
         AIF   (&J LT K'&LIT).LIT11X
.*ENDLOOP
&L       SETA  (&L+1)/2
.LIT15   ANOP                               generate in-line literal
         AIF   (&L GT 5).LIT40
         AIF   (&LAST).LIT16
         DC    X'4&L',&LIT
         AGO   .LIT90
.LIT16   DC    X'C&L',&LIT,0S(0)
         AGO   .LIT90
.LIT40   ANOP                                  check literal table
         AIF   (&$_LIT EQ 0).LIT50
&N       SETA  1
         ACTR  &$_LIT*3+200
.LIT41   AIF   ('&LIT' EQ '&$_LITS(&N)').LIT80       LOOP
&N       SETA  &N+1                                  LOOP
         AIF   (&N LE &$_LIT).LIT41                  LOOP
.LIT50   ANOP
&$_LIT   SETA  &$_LIT+1
&$_LITS(&$_LIT) SETC '&LIT'
&N       SETA  &$_LIT
.LIT80   ANOP                               generate remote literal
&N       SETA  &N+1000
         AIF   (&LAST).LIT86
         DC    X'40',AL1(&L),AL2($LIT&N-*)
         AGO   .LIT90
.LIT86   DC    X'C0',AL1(&L),AL2($LIT&N-*),0S(0)
.LIT90   ANOP
&$_FEAT(1) SETB 1                      LITERAL
.LIT99   ANOP
.*--------------------------------------------------------------------*
&I       SETA  1+&I                              LOOP
         AIF   (&I LE N'&SYSLIST).LOOP1          LOOP
.*ENDLOOP
&SYSLOC  LOCTR
         AGO   .MEND
.ERR1    MNOTE 12,'AT LEAST ONE INPUT FIELD MUST BE SPECIFIED'
         AGO   .MEND
.ERR2    MNOTE 12,'INVALID OUTPUT AREA SPECIFICATION'
         AGO   .MEND
.**********************************************************************
.*       GENERATE: GENERATE LITERALS AND PROCESSING ROUTINE           *
.**********************************************************************
.GENL    ANOP
         AIF   (N'&SYSLIST(1) GT 3).GENL1R
&OPT2    SETC  '&SYSLIST(1,2)'
         AIF   ('&OPT2' NE '' AND '&OPT2' NE 'AR_MODE'                 X
               AND '&OPT2' NE 'NO_CSECT').GENL1R
&OPT3    SETC  '&SYSLIST(1,3)'
         AIF   ('&OPT3' NE '' AND '&OPT3' NE 'LOCTR').GENL1R
         AIF   ('&OPT2' EQ 'NO_CSECT' AND '&OPT3' EQ 'LOCTR').GENL1R
         AGO   .GENL1D
.GENL1R  MNOTE 12,'Invalid GENERATE options, default used'
&OPT2    SETC  ''
&OPT3    SETC  ''
.GENL1D  ANOP
&STRBLANKS SETA 2
         AIF   (D'$LTORG).GENL1F             CSECT-ONLY
&$_FEAT(1) SETB 1,1,1,1,1,1,1,1,1,1,1,1
.GENL1F  ANOP
&ALLFEAT SETC  '&$_FEAT(1)&$_FEAT(2)&$_FEAT(3)&$_FEAT(4)'
&ALLFEAT SETC  '&ALLFEAT&$_FEAT(5)&$_FEAT(7)&$_FEAT(6)&$_FEAT(8)'
&ALLFEAT SETC  '&ALLFEAT&$_FEAT(9)&$_FEAT(10)&$_FEAT(11)&$_FEAT(12)'
&STR     SETC  '&STRING_MACRO_VERSION'
         MNOTE *,'STRING R&STR - FEATURES GENERATED: &ALLFEAT'
         AIF   (&$_LIT EQ 0).GENL3
$LITERAL LOCTR
.GENL2   ANOP                                LOOP
&N       SETA  &N+1                          LOOP
&I       SETA  &N+1000                       LOOP
$LIT&I   DC    &$_LITS(&N)
         AIF   (&N LT &$_LIT).GENL2          LOOP
.GENL3   ANOP
         AIF   ('&OPT2' EQ 'NO_CSECT').GENL8
&ARMODE  SETB  ('&OPT2' EQ 'AR_MODE')
.**********************************************************************
.*                                                                    *
.*       STRING SUB-ROUTINE                                           *
.*                                                                    *
.*             CAUTION: BYTES 49-72 OF THE CALLER'S SAVE AREA         *
.*                      (R7-R12 SLOTS) ARE USED AS WORK SPACE         *
.*                                                                    *
.**********************************************************************
         AIF   ('&OPT3' EQ 'LOCTR').GENL4L
@STRING  CSECT
@STRING  RMODE ANY
         AGO   .GENL4X
.GENL4L  PUSH  USING                   GENERATE,LOCTR
         DROP
@STRING@ LOCTR
@STRING  DS    0H                      ALIGNMENT
.GENL4X  ANOP
@00      EQU   0                       WORK REGISTER
@01      EQU   1                       WORK REGISTER
@02      EQU   2                       WORK REGISTER
@03      EQU   3                       WORK REGISTER
@04      EQU   4                       WORK REGISTER
@05      EQU   5                       WORK REGISTER
@06      EQU   6                       WORK REGISTER
         AIF   (NOT &ARMODE).ARMODE1X
@07      EQU   7                       WORK REGISTER
@08      EQU   8                       WORK REGISTER
@09      EQU   9                       WORK REGISTER
@10      EQU   10                      WORK REGISTER
@11      EQU   11                      WORK REGISTER
@12      EQU   12                      WORK REGISTER
.ARMODE1X ANOP
@13      EQU   13                      CALLER'S SAVE AREA
@14      EQU   14                      WORK REGISTER
@15      EQU   15                      BASE REG
         USING @STRING,@15
         USING @STRSAVE,@13
         B     @STR003                 BRANCH AROUND EYE-CATCHER
         AIF   (&ARMODE).ARMODE2Y
         DC    C'@STRING/370 R&STRING_MACRO_VERSION &ALLFEAT',0H'0'
@STR003  STM   @14,@06,12(@13)         Save caller's registers
         SLR   @06,@06                 R6=0
&LAE     SETC  'LA'
         AGO   .ARMODE2X
.ARMODE2Y ANOP
         DC    C'@STRING/390 R&STRING_MACRO_VERSION &ALLFEAT',0H'0'
@STR002  DC    H'2'
@STR003  STM   @14,@12,12(@13)         SAVE REGS (DEBUGGING ONLY)
.*+++    BSM   @14,0                   Set AMODE when invoked via BAL
         AH    @14,@STR002-@STRING(@15,0) POINT PAST PARM-LIST OFFSET
         BAKR  @14,0                   SAVE REGS AND RETURN ADDRESS
         BCTR  @14,0                   ADJUST ADDR OF PARM LIST OFFSET
         BCTR  @14,0                   ADJUST ADDR OF PARM LIST OFFSET
         LAE   @06,0                   R6=0 AR6=0
         CPYA  @14,@06                 AR14=0
         CPYA  @15,@06                 AR15=0
&LAE     SETC  'LAE'
.ARMODE2X ANOP
         ICM   @06,B'0011',0(@14)      PICK UP PARM-LIST 1/2 OFFSET
         ALR   @06,@06                 PICK UP PARM-LIST OFFSET
         ALR   @06,@14                 R6 NOW POINTS TO PARM LIST
         USING @STRSCON,@06
         &LAE  @02,@STRSCON            RESOLVE FIRST SCON (ADDR)
         BAL   @14,@STRS2A             GET ADDRESS IN R2
         &LAE  @04,0(,@02)             KEEP ADDRESS OF "INTO" FIELD
         L     @14,12(,@13)            RESTORE ADDR OF STRING MACRO
         OI    0(@04),0                GET CLEAN S0C4 IF ADDRESS IS BAD
         &LAE  @02,@STRFLEN            RESOLVE SECOND S-CON (LEN)
         BAL   @14,@STRS2A             GET LENGTH IN R2
         LR    @05,@02                 KEEP LENGTH OF "INTO" FIELD
         CR    @05,@04                 END ADDRESS?
         BL    @STR282                 NO, JUMP
         SR    @05,@04                 CALCULATE LENGTH
         AIF   (NOT &ARMODE).ARMODE5N
@STR282  MSTA  @04                     SAVE R4,R5 ON LINKAGE STACK
.*SLAC   DC    X'B247,0040'            SLAC assembler error
         AGO   .ARMODE5X
.ARMODE5N ANOP
@STR282  ST    @04,8(,@13)             SAVE ADDRESS FOR LATER
.ARMODE5X ANOP
.**********************************************************************
.*       MOVE FIELDS TO OUTPUT AREA                                   *
.**********************************************************************
         &LAE  @06,@STRNEXT            POINT TO 1ST FIELD DESC
         USING @STRPARM,@06
.*LOOP
@STR310  EQU   *
         AIF   (NOT &$_FEAT(1)).FEAT1A
         TM    @STRFLAG,@STRLIT        IS THIS A LITERAL?
         BO    @STR372                 YES, JUMP
.FEAT1A  ANOP
         AIF   (NOT &$_FEAT(2) AND NOT &$_FEAT(3)).FEAT23A
         TM    @STRFLAG,@STRREG        REGISTER?
         BO    @STR323                 YES, JUMP
.FEAT23A ANOP
         AIF   (NOT &$_FEAT(12)).FEAT12A
         CLI   @STRSCON,X'E0'          IS IT %TIME ?
         BE    @STR378                 YES, JUMP
.FEAT12A ANOP
.*
.*       IT'S A FIELD (SCON)
.*
         &LAE  @02,@STRFLEN            RESOLVE SECOND S-CON (LEN)
         BAL   @14,@STRS2A             GET LENGTH IN R2
         AIF   (&$_FEAT(9)).FEAT9E1    (LEFT JUSTIFICATION, NUMERIC)
         LTR   @03,@02                 KEEP/TEST LENGTH
         BZ    @STR398                 ZERO LENGTH, DO NOT EDIT
         AGO   .FEAT9E2
.FEAT9E1 LTR   @03,@02                 KEEP/TEST LENGTH
         BP    @STR313                 LENGTH POSITIVE, JUMP
         TM    @STRLEN2,@STRLEFT       LEFT JUSTIFICATION?
         BNO   @STR398                 NO, ZERO LENGTH IS NOT OK
@STR313  EQU   *
.FEAT9E2 ANOP
         &LAE  @02,@STRSCON            RESOLVE FIRST SCON (ADDR)
         BAL   @14,@STRS2A             GET ADDRESS IN R2
         L     @14,12(,@13)            RESTORE ADDR OF STRING MACRO
         CLI   0(@02),0                GET CLEAN S0C4 IF ADDRESS IS BAD
         CR    @03,@02                 END ADDRESS?
         BL    @STR314                 NO, JUMP
         LA    @00,X'0080'             PSA ADDRESS
         CLR   @02,@00                 PSA REFERENCE?
         BL    @STR314                 YES, JUMP
         SR    @03,@02                 CALCULATE LENGTH
@STR314  EQU   *
         AIF   (NOT &$_FEAT(6)).FEAT6A
         TM    @STRFLAG,@STRBIN        BINARY FIELD?
         BO    @STR328                 YES, JUMP
.FEAT6A  ANOP
         AIF   (NOT &$_FEAT(4)).FEAT4A
         TM    @STRFLAG,@STRPACK       PACKED FIELD?
         BO    @STR351                 YES, JUMP
.FEAT4A  ANOP
         AIF   (NOT &$_FEAT(7)).FEAT7A
         TM    @STRFLAG,@STRHEX        EDIT IN HEX?
         BO    @STR376                 YES, JUMP
.FEAT7A  ANOP
.*
.*       TRUNCATE CHARACTER STRING
.*
         AIF   (NOT &$_FEAT(11)).FEAT11A
         CLI   @STRLEN2,@STRLEFT       CHECK JUSTIFICATION, OUTPUT LEN
         BNE   @STR390                 NO STRING TRUNCATION, JUMP
         &LAE  @01,0(@03,@02)          FIRST BYTE AFTER FIELD
@STR318  BCTR  @01,0                   DOWN 1 BYTE                 LOOP
         CLI   0(@01),C' '             IS IT A SPACE ?             LOOP
         BNE   @STR390                 LAST NON-BLANK BYTE         LOOP
         BCT   @03,@STR318             LOOP UNTIL 1ST NON-BLANK    LOOP
         B     @STR398                 BLANK FIELD, DO NOT EDIT
         AGO   .FEAT11B
.FEAT11A ANOP
         AIF (&$_FEAT(2)+&$_FEAT(3)+&$_FEAT(4)+&$_FEAT(6) EQ 0).FEAT11B
         B     @STR390                 EDIT
.FEAT11B ANOP
.*
.*       REGISTER (R0-R13)
.*
         AIF   (NOT &$_FEAT(2) AND NOT &$_FEAT(3)).FEAT23B
         AIF   (NOT &ARMODE).ARMODE7N
@STR323  LH    @01,@STRSCON            REG NUMBER IN BITS 28-31
         CLI   @STRSCON+1,@06          IS THIS R7-R13?
         BH    @STR323R                YES, JUMP
         LR    @07,@01                 SAVE R1 (R)
         LAE   @10,0(,@04)             SAVE R4
         LR    @11,@05                 SAVE R5
         LAE   @12,0(,@06)             SAVE R6
         EREG  @00,@06                 RELOAD CALLER'S R0-R6
         EX    @07,@STR323L            COPY R0-R6 VALUE
         LAE   @04,0(,@10)             RESTORE R4
         LR    @05,@11                 RESTORE R5
         LAE   @06,0(,@12)             RESTORE R6
         B     @STR323T
@STR323L LR    @00,*-*                 COPY VALUE FOR EDIT
@STR323R EQU   *
         EREG  @07,@12                 RESTORE CALLER'S R7-R12
         EX    @01,@STR323L            COPY R7-R13 INTO R0
         AGO   .ARMODE7X
.ARMODE7N ANOP
@STR323L LR    @00,*-*                 COPY VALUE FOR EDIT
@STR323  LH    @01,@STRSCON            REG NUMBER IN BITS 28-31
         EX    @01,@STR323L            COPY R7-R13 INTO R0
         CLI   @STRSCON+1,@06+1        IS THIS R7-R13?
         BNL   @STR323T                YES, JUMP
         SLL   @01,2                   R1= 000000BB BASE * 4
         L     @00,20(@01,@13)         PICK UP VALUE FOR R0-R6
.ARMODE7X ANOP
@STR323T EQU   *
         AIF   (NOT &$_FEAT(3)).FEAT3R REG,HEX
         AIF   (NOT &$_FEAT(2)).FEAT2H REG,BIN
         TM    @STRFLAG,@STRHEX        EDIT IN HEX?
         BNO   @STR330                 NO, EDIT FWD
.FEAT2H  ANOP
         STCM  @00,B'1111',@STRDWD-1   STORE IT FOR CVD/UNPK
         LA    @03,8                   OUTPUT LENGTH
         B     @STR376X                EDIT IN HEX
.FEAT3R  ANOP
         AIF   (NOT &$_FEAT(6)).FEAT23B
         B     @STR330                 EDIT R0
.FEAT23B ANOP
.*
.*       BINARY VARIABLE: @03 CONTAINS THE ICM MASK (1 3 7 F)
.*
         AIF   (NOT &$_FEAT(6)).FEAT6B
@STR328M ICM   @00,*-*,0(@02)          **EXECUTED INSTRUCTION**
@STR328  SLR   @00,@00
         EX    @03,@STR328M            LOAD THE BINARY VARIABLE
.FEAT6B  ANOP
.*
         AIF   (NOT &$_FEAT(2) AND NOT &$_FEAT(6)).FEAT6C
@STR330  CVD   @00,@STRDWD             CONVERT VALUE TO DECIMAL
         AIF   (NOT &$_FEAT(4)).FEAT6C
         B     @STR361                 EDIT DWD
.FEAT6C  ANOP
.*
.*       PACKED FIELD
.*
         AIF   (NOT &$_FEAT(4)).FEAT4B
@STRZAP  ZAP   @STRDWD,0(*-*,@02)      MOVE TO @STRDWD
@STR351  &LAE  @03,0(,@02)             FIRST BYTE OF PACKED FIELD
         BALR  @14,0
         TM    0(@03),X'0C'            IS THIS THE SIGN BYTE?
         LA    @03,1(,@03)              (NEXT BYTE)
         BNOR  @14                     NO, LOOP MORE
         SLR   @03,@02                 GET LENGTH OF PACKED FIELD
         BCTR  @03,0
         EX    @03,@STRZAP             EXECUTE ZAP
         AIF   (NOT &$_FEAT(5)).FEAT4B
         CLI   @STRLEN2,248            JULIAN-TO-YYMMDD CONV?
         BNL   @STR375                 YES, JUMP
.FEAT4B  ANOP                          PACKED
.*
.*       EDIT @STRDWD (BIN, REG, PACKED)
.*
         AIF   (NOT &$_FEAT(8)).FEAT8B
@STR361  IC    @00,@STRLEN2            OUTPUT LENGTH
         LA    @03,X'003F'             MASK FOR "AND"
         NR    @03,@00                 OUTPUT LENGTH
         MVC   @STRWK16(16),@STRMASK   EDIT MASK
.*
.*       LEFT-JUSTIFICATION (NUMERIC)
.*
         AIF   (NOT &$_FEAT(9)).FEAT9B
         TM    @STRLEN2,@STRLEFT       LEFT JUSTIFICATION?
         BNO   @STR367                 NO, JUMP
         &LAE  @01,@STRWK16+15         PREVENT BAD R1
         EDMK  @STRWK16(16),@STRDWD    ZONED DECIMAL
         BNM   @STR362                 skip if not a negative number
         BCTR  @01,0                   R1 = significance start ptr -1
         MVI   0(@01),C'-'             sink negative sign in front
@STR362  &LAE  @02,0(,@01)             FIRST STRING POSITION
         LTR   @03,@03                 CHECK OUTPUT LENGTH
         BNZ   @STR363                 JUMP IF NOT ZERO
.*       L0    (LEFT JUSTIFIED, NO PADDING)
         &LAE  @03,@STRWK16+16         FIRST POSITION AFTER STRING
         SR    @03,@02                 COMPUTE STRING LENGTH
         B     @STR390                 MOVE FIELD TO OUTPUT LINE
.*       L1-L63 (LEFT JUSTIFIED, PADDING)
@STR363  CR    @03,@05                 COMPARE LENGTH TO REMAINING LEN
         BNH   @STR364                 LARGE ENOUGH, JUMP
         LR    @03,@05                 TOO BIG, TRUNCATE TO REM. LEN.
@STR364  SR    @05,@03                 COMPUTE REMAINING LENGTH
         AIF   (NOT &ARMODE).ARMODE8N
         LAE   @08,0(,@04)             POINTER IN OUTPUT LINE
         LR    @09,@03                 LENGTH WITH PADDING
         AGO   .ARMODE8X
.ARMODE8N ANOP
         LR    @00,@04                 POINTER IN OUTPUT LINE
         LR    @01,@03                 LENGTH WITH PADDING
.ARMODE8X ANOP
         LA    @03,@STRWK16+16         FIRST POSITION AFTER STRING
         SR    @03,@02                 COMPUTE STRING LENGTH
         B     @STR392                 MOVE FIELD TO OUTPUT LINE
@STR367  EQU   *
.FEAT9B  ANOP
         AIF   (NOT &$_FEAT(10)).FEAT10B
         TM    @STRLEN2,@STRZERO       LEADING ZEROES REQ'D?
         BNO   @STR368                 NO, JUMP
         MVI   @STRWK16,C'0'           YES, CHANGE X'40' TO C'0'
@STR368  EQU   *
.FEAT10B ANOP
         &LAE  @01,@STRWK16+15         PREVENT BAD R1
         EDMK  @STRWK16(16),@STRDWD    ZONED DECIMAL
         BNM   @STR369                 skip if not a negative number
         BCTR  @01,0                   R1 = significance start ptr -1
         MVI   0(@01),C'-'             sink negative sign in front
@STR369  &LAE  @02,@STRWK16+16         FIRST POSITION AFTER STRING
         SR    @02,@03                 FIRST STRING POSITION
.FEAT8B  ANOP
.*
.*       LITERAL (@STRSCON IS A 16-BIT OFFSET)
.*       Short Literal (low-order 4 bits of @STRFLAG contains length)
.*       BLANKS  (@STRSCON=ZERO)
.*
         AIF   (NOT &$_FEAT(1)).FEAT1B
         B     @STR390                 MOVE STRING TO OUTPUT LINE
@STR372  LA    @01,7                   mask for NR
         &LAE  @02,@STRLEN2            1st byte of short literal
         IC    @03,@STRFLAG            pick up flags+length
         NR    @03,@01                 R3 has length of short literal
         BNZ   @STR390                 short literal, go move it
         SLR   @02,@02                 Clear Address Register
         IC    @03,@STRLEN2            GET LITERAL LENGTH
         TM    @STRFLAG,@STRX40        string of spaces?
         BO    @STR390                 yes, go move them
         ICM   @02,B'0011',@STRSCON    LOAD LITERAL OFFSET
         LA    @02,@STRSCON(@02)       CONVERT OFFSET TO FULL ADDRESS
.FEAT1B  ANOP
.*
.*       CONVERT JULIAN DATE TO YYMMDD
.*
         AIF   (NOT &$_FEAT(5)).FEAT5F
         B     @STR390                 MOVE STRING TO OUTPUT LINE
@STR375  LA    @00,248                 MASK FOR 'SLR'
         SLR   @01,@01
         IC    @01,@STRLEN2            248-255
         SLR   @01,@00                 000-007
         LA    @00,12                  L'@STR375W
         MR    @00,@00                 COMPUTE OFFSET
         &LAE  @01,@STR375W(@01)       ENTRY IN "TR" MASK TABLE
         SLR   @03,@03
         IC    @03,0(,@01)             LENGTH OF DATE (6, 8 OR 10)
         ZAP   @STRDWD,@STRDWD         DATE=0000000?               @JDT
         BNZ   @STR375B                NO, JUMP                    @JDT
@STR375Z &LAE  @02,@STRBLANKS          WORK AREA
&STRBLANKS SETA 10                     WE NEED AT LEAST 10 BLANKS
         B     @STR390                 MOVE FIELD TO OUTPUT LINE
@STR375W DC    AL1(10,C'-',0,1,2,3,8,4,5,8,6,7) YYYY-MM-DD   248
         DC    AL1(8,C' ',0,1,2,3,4,5,6,7,8,8)  YYYYMMDD//   249
         DC    AL1(8,C'/',2,3,8,4,5,8,6,7,8,8)  YY/MM/DD//   250
         DC    AL1(8,C'/',6,7,8,4,5,8,2,3,8,8)  DD/MM/YY//   251
         DC    AL1(8,C'/',4,5,8,6,7,8,2,3,8,8)  MM/DD/YY//   252
         DC    AL1(6,C' ',2,3,4,5,6,7,8,8,8,8)  YYMMDD       253
.*       DC    AL1(6,C' ',6,7,4,5,2,3,8,8,8,8)  DDMMYY       254
.*       DC    AL1(6,C' ',4,5,6,7,2,3,8,8,8,8)  MMDDYY       255
@STR375T DC    P'59,31,29,31,30,31,30,31,31,30,31,30,31'
         DC    P'999'                  Prevent S0C7 with 90366
@STR375B CLI   @STRDWD+4,X'01'         YEAR 2000 OR ABOVE?
         BH    @STR375C                CC>01, JUMP (MUST BE 19 OR 20)
         MVI   @STRDWD+4,X'20'         CC=01, CHANGE TO CC=20
         BE    @STR375C                CC=01, USE CC=20
         CLI   @STRDWD+4+1,X'50'       YY<50?
         BL    @STR375C                YES, USE CC=20
         MVI   @STRDWD+4,X'19'         NO, FORCE CC=19
@STR375C UNPK  @STRWK16(5),@STRDWD+4(3) CCYY?
         ZAP   @STRDWD+1(2),@STR375T+9(1) INIT MONTH COUNTER
         &LAE  @02,@STR375T            TABLE OF MONTHS (NUMBER OF DAYS)
         TM    @STRDWD+4+1,X'01'       ODD YEARS
         BO    @STR375N                  AREN'T LEAP YEARS
         TM    @STRDWD+4+1,X'12'       ZEROES IN 1980, ALL ONES IN 1992
         BNM   @STR375L                MIXED IN 1982/1990
.*       IF IT'S NOT A LEAP YEAR AND DDD>59, THEN ADD 1 TO DDD
@STR375N CP    @STRDWD+4+2(2),@STR375T ARE WE PAST FEB 28 (DDD>59) ?
         BNH   @STR375L                NO, JUMP
         AP    @STRDWD+4+2(2),@STR375T+3(1) ADD 1 (FROM 31) TO DDD
.*--LOOP WHILE DDD > 0
@STR375L AP    @STRDWD+1(2),@STR375T+3(1)   ADD 1 (FROM 31) TO MONTH
         LA    @02,2(,@02)             NEXT ENTRY IN "MONTHS" TABLE
         SP    @STRDWD+4+2(2),0(2,@02) SUB DAYS-IN-MONTH FROM DDD
         BP    @STR375L
.*--ENDLOOP
         AP    @STRDWD+4+2(2),0(2,@02) UNDO LAST "SP" INSTRUCTION
         UNPK  @STRWK16+4(2),@STRDWD+1(2) FYFYFYFY,FMCM??
         UNPK  @STRWK16+6(2),@STRDWD+6(2) FYFYFYFY,FMCMFDCD
         MVZ   @STRWK16+1(7),@STRWK16     FYFYFYFY,FMCMFDCD
         MVC   @STRWK16+8(1),1(@01)    SEPARATOR
         &LAE  @02,@STRWK16+9          WORK AREA
         MVC   0(10,@02),2(@01)        MOVE CORRESPONDING MASK
         TR    0(10,@02),@STRWK16      CONVERT DATE TO THE RIGHT FORMAT
.FEAT5F  ANOP                          JDATE
.*
.*       HEX STRING
.*
         AIF   (NOT &$_FEAT(7)).FEAT7B
         B     @STR390                 MOVE STRING TO OUTPUT LINE
@STR376M MVC   @STRDWD-1(*-*),0(@02)   PREVENT S0C4 IN UNPK
@STR376  LA    @00,8                   MAX LENGTH
         CLR   @03,@00                 CHECK LENGTH
         BNH   @STR376B                JUMP IF LE 8
         LR    @03,@00                 TRUNCATE TO MAXIMUM LENGTH
@STR376B LR    @01,@03                 INPUT LENGTH
         BCTR  @01,0
         EX    @01,@STR376M            MOVE DATA TO SAFE STORAGE
         ALR   @03,@03                 OUTPUT LENGTH
         AGO   .FEAT37B
.FEAT7B  ANOP
         AIF   (NOT &$_FEAT(3)).FEAT37C
         B     @STR390                 MOVE STRING TO OUTPUT LINE
.FEAT37B ANOP
@STR376X &LAE  @02,@STRWK16            WORK AREA
         UNPK  0(9,@02),@STRDWD-1(5)   EXPAND SOURCE BYTES FOR "TR"
         UNPK  8(9,@02),@STRDWD+3(5)   EXPAND SOURCE BYTES FOR "TR"
         TR    0(16,@02),@STRHEXT-240  =C'0123456789ABCDEF'
.FEAT37C ANOP
.*
.*       %TIME
.*
         AIF   (NOT &$_FEAT(12)).FEAT12B
         B     @STR390                 MOVE STRING TO OUTPUT LINE
@STRTIME DC    X'4021207A20207A20207A20204000'    0X.XX.XX.XX
@STR378  LR    @02,@15                 SAVE BASE REG
         TIME  DEC                     GET HHMMSSHH
         LR    @15,@02                 RESTORE BASE REG
         ST    @00,@STRDWD             STORE HHMMSSHH
         MVC   @STRWK16(13),@STRTIME   MOVE EDIT MASK
         ED    @STRWK16(13),@STRDWD    EDIT HH:MM:SS:HH
         &LAE  @02,@STRWK16+1          WORK AREA
         LA    @03,12                  HH:MM:SS:HH+ SPACE
.FEAT12B ANOP
.*MOVE
@STR390  CR    @03,@05                 COMPARE LENGTH TO REMAINING LEN
         BNH   @STR391                 LARGE ENOUGH, JUMP
         LR    @03,@05                 TOO BIG, TRUNCATE TO REM. LEN.
@STR391  SR    @05,@03                 COMPUTE REMAINING LENGTH
         AIF   (NOT &ARMODE).ARMODE39N
         LAE   @08,0(,@04)             POINTER IN OUTPUT LINE
         LR    @09,@03                 PASS REMAINING LENGTH
         AGO   .ARMODE39X
.ARMODE39N ANOP
         LR    @00,@04                 POINTER IN OUTPUT LINE
         LR    @01,@03                 PASS REMAINING LENGTH
.ARMODE39X ANOP
         LTR   @02,@02                 BLANKS?
         BNZ   @STR392                 NO, JUMP
         SLR   @03,@03                 YES, ZERO LENGTH
@STR392  ICM   @03,B'1000',@STRBLANKS  PAD WITH BLANKS
         AIF   (NOT &ARMODE).ARMODE44N
         MVCL  @08,@02                 MOVE FIELD TO OUTPUT LINE
         LR    @04,@08                 NEW POINTER IN OUTPUT LINE
         AGO   .ARMODE44X
.ARMODE44N ANOP
         MVCL  @00,@02                 MOVE FIELD TO OUTPUT LINE
         LR    @04,@00                 NEW POINTER IN OUTPUT LINE
.ARMODE44X ANOP
@STR398  TM    @STRFLAG,@STRLAST       TEST LAST-ENTRY INDICATOR
         BO    @STR399                 Done, exit
         AIF   (NOT &$_FEAT(1)).FEAT1C
         TM    @STRFLAG,@STRLIT+@STRX40 literal or spaces?
         BM    @STR398L                Literal, not spaces
         BZ    @STR398X                Neither literal nor spaces
         LA    @06,@STRSCON            2-byte entry for blank spaces
         B     @STR310                 PROCESS NEXT ENTRY
@STR398L LA    @01,7                   mask for NR
         IC    @03,@STRFLAG            pick up flags+length
         NR    @03,@01                 R3 has length of short literal
         BZ    @STR398T                not an in-line literal, jump
         LA    @06,@STRLEN2(@03)       Skip VL parm for in-line literal
         B     @STR310                 PROCESS NEXT ENTRY
@STR398T LA    @06,@STRFLEN            4-byte parm for remote literal
         B     @STR310                 PROCESS NEXT ENTRY
.FEAT1C  ANOP
@STR398X LA    @06,@STRNEXT            BUMP UP TO NEXT ENTRY
         B     @STR310                 PROCESS NEXT ENTRY
.*ENDLOOP
.*
.*       END-OF-LINE PROCESSING - PAD WITH BLANKS
.*
@STR399  SLR   @01,@01                 SET UP R1 FOR PADDING
         ICM   @01,B'1000',@STRBLANKS  SET UP R1 FOR PADDING
.***     DROP  @06,@13,@15
         AIF   (&ARMODE).ARMODE52Y
         LA    @14,2                   INCREMENT
         AL    @14,12(,@13)            RETURN ADDRESS
         LR    @15,@04                 CURRENT POINTER IN OUTPUT FIELD
         SL    @15,8(,@13)             CALCULATE LENGTH USED
         MVCL  @04,@00                 PAD WITH BLANKS
         LM    @00,@06,20(@13)         RESTORE WORK REGISTERS
         STM   @06+1,@13-1,48(@13)     MAKE SAVE AREA LOOK NORMAL
         OI    15(@13),1               SIMULATE "T" OPTION OF RETURN
         BR    @14                     RETURN TO CALLER
         AGO   .ARMODE52X
.ARMODE52Y ANOP
         LA    @15,3                   MODIFIABLE AREA
         ESTA  @14,@15                 R14 = START OF OUTPUT AREA
         LR    @15,@04                 END OF OUTPUT AREA
         SR    @15,@14                 R15 = LENGTH USED IN OUTPUT AREA
         MVCL  @04,@00                 PAD WITH BLANKS
         EREG  @00,@14                 RESTORE WORK REGISTERS
         STM   @14,@12,12(@13)         MAKE SAVE AREA LOOK NORMAL
         OI    15(@13),1               SIMULATE "T" OPTION OF RETURN
         PR                            RETURN TO CALLER
.ARMODE52X ANOP
.*
         AIF   (NOT (&$_FEAT(3) OR &$_FEAT(7))).FEAT37T
@STRHEXT DC    C'0123456789ABCDEF'     HEX-TO-EBCDIC CONVERSION
.FEAT37T ANOP
         AIF   (NOT &$_FEAT(8)).FEAT8T
@STRMASK DC    X'4020202020202020,2020202020202120'
.FEAT8T  ANOP
.**********************************************************************
.*       Convert S-con to address                                     *
.*             Input: GPR2 points to an S-CON in the remote parm list *
.*             Output: GPR2 contains the address                      *
.**********************************************************************
@STRS2A  SLR   @00,@00
         ICM   @00,B'0011',0(@02)      R0 = 0000BDDD
         SRDL  @00,12                  R0 = 0000000B, R1= DDD.....
         SRL   @01,20                  R1 = 00000DDD (DISPLACEMENT)
         AIF   (&ARMODE).ARMODE88Y
         CLI   0(@02),@06*16+15        R7-R13?
         BH    @STRS2A3                YES, JUMP
.*BASE REG IS R0-R6
         LTR   @02,@00                 IS R0 THE BASE REG?
         BNZ   @STRS2A2                NO, JUMP
         LTR   @02,@01                 IS THIS A PSA ADDRESS?
         BNZR  @14                     YES, GOBACK
@STRS2A2 SLL   @02,2                   R2= 000000BB BASE * 4
         L     @02,20(@02,@13)         PICK UP BASE REG VALUE
         LA    @02,0(@02,@01)          ADD BASE REG VALUE TO DISPL
         BR    @14
.*BASE REG IS R7-R13
@STRS2A3 LR    @02,@00                 R2= 0000000B (BASE REG NUMBER)
         EX    @02,@STRS2A4            ADD BASE REG VALUE TO DISPL
         BR    @14
@STRS2A4 LA    @02,0(*-*,@01)          ADD BASE REG VALUE TO DISPL
         AGO   .ARMODE88X
.ARMODE88Y ANOP                        AR_MODE=YES
         SLL   @00,2                   MULT BY 4
         CLI   0(@02),@06*16+15        R7-R13?
         BH    @STRS2A6                YES, JUMP
.*BASE REG IS R0-R6
         LTR   @02,@00                 IS R0 THE BASE REG?
         BNZ   @STRS2A5                NO, JUMP
         LTR   @02,@01                 IS THIS A PSA ADDRESS?
         BNZR  @14                     YES, GOBACK
         EREG  @00,@00                 POP R0
         LAE   @02,0                   R2=0 AR2=0
         LR    @02,@00                 PASS R0 VALUE
         LA    @02,0(,@02)             CLEAN UP
         BR    @14                     GOBACK
.*BASE REG IS R1-R6
@STRS2A5 LR    @07,@00                 SAVE R0 (B*4)
         LR    @08,@01                 SAVE R1 (DDD)
         LR    @09,@03                 SAVE R3
         LAE   @10,0(,@04)             SAVE R4
         LR    @11,@05                 SAVE R5
         LAE   @12,0(,@06)             SAVE R6
         EREG  @01,@06                 RELOAD CALLER'S R1-R6
         EX    0,@STRS2A7-4(@07)       ADD BASE REG VALUE TO DISPL
         LR    @03,@09                 RESTORE R3
         LAE   @04,0(,@10)             RESTORE R4
         LR    @05,@11                 RESTORE R5
         LAE   @06,0(,@12)             RESTORE R6
         BR    @14                     GOBACK
.*BASE REG IS R7-R13
@STRS2A6 LR    @02,@00                 R2= 0000000B (BASE REG NUMBER)
         EREG  @07,@12                 RESTORE CALLER'S R7-R12
         EX    0,@STRS2A7-4(@02)       ADD BASE REG VALUE TO DISPL
         BR    @14                     GOBACK
@STRS2A7 LAE   @02,0(@08,@01)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@08,@02)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@08,@03)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@08,@04)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@08,@05)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@08,@06)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@01,@07)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@01,@08)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@01,@09)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@01,@10)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@01,@11)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@01,@12)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@01,@13)          ADD BASE REG VALUE TO DISPL
.ARMODE88X ANOP
         AIF   ('&OPT3' EQ 'LOCTR').GENL7L
@STRBLANKS DC  CL((((*+&STRBLANKS+7-@STRING)/8)*8)-(*-@STRING))' '
         AGO   .GENL7X
.GENL7L  ANOP
@STRBLANKS DC  CL&STRBLANKS.' '
.GENL7X  ANOP
@STRING_SIZE EQU *-@STRING             SIZE OF GENERATED CSECT
         DROP  @06,@13,@15
.**********************************************************************
.*       WORK AREA (CALLER'S SAVE AREA)                               *
.**********************************************************************
@STRSAVE DSECT                         24-BYTE WORK AREA
         DS    A(0,@STRSAVE,@STRSAVE,14,15,0,1,2,3,4,5,6)
@STRWK16 DS    F'7,8,9,10'             WORK AREA
@STRDWD  DS    D'1112'                 WORK AREA
@STRPARM DSECT
@STRFLAG DS    B                   +0  FORMAT, FLAGS
@STRLAST EQU   X'80'                     LAST ENTRY
@STRLIT  EQU   X'40'                     LITERAL, @STRSCON IS AN OFFSET
@STRX40  EQU   X'20'                   String of Spaces
.*             X'0F'                   CONVERSION REQUIRED
.*                                     or length of short literal
@STRHEX  EQU   X'08'                     HEXADECIMAL
@STRBIN  EQU   X'04'                     BINARY
@STRPACK EQU   X'02'                     PACKED
@STRREG  EQU   X'01'                     REGISTER
@STRLEN2 DS    B                   +1  FORMAT, OUTPUT LENGTH
.*                                     or start of short literal
@STRLEFT EQU   X'80'                     LEFT JUSTIFICATION
@STRZERO EQU   X'40'                     LEADING ZEROES
.*             X'3F'                     OUTPUT LENGTH, 0 MEANS TRUNC.
@STRSCON DS    S                   +2  FIELD ADDRESS
@STRFLEN DS    S                   +4  FIELD LENGTH
@STRNEXT EQU   *                   +6
         AIF   (NOT D'$LTORG).MEND99   CSECT-ONLY
         AIF   (D'$STRING).MEND99      CSECT-ONLY
$LTORG   LOCTR
         AIF   ('&OPT3' EQ 'LOCTR').GENL9L
         CNOP  0,4
$STRING  BALR  @15,0                   LOCAL BASE
         L     @15,6(@15,0)            ROUTINE ADDRESS           00
         BR    @15                     GO TO @STRING             04
         AGO   .GENL9
.GENL8   ANOP                          GENERATE,NOCSECT
&$_LIT   SETA  0                       DO NOT GENERATE LITERALS TWICE
&$_FEAT(1) SETB 1,1,1,1,1,1,1,1,1,1,1,1   GENERATE=FULL
$LTORG   LOCTR
         CNOP  0,4
$STRING  BALR  R15,0                   LOCAL BASE
         L     R15,6(R15,0)            ROUTINE ADDRESS           00
         BR    R15                     GO TO @STRING             04
.GENL9   ANOP
         DC    V(@STRING)              ROUTINE ADDRESS           06
         AGO   .MEND
.GENL9L  POP   USING                   GENERATE,LOCTR
$STRING  BASR  R15,0                   Local Base
         AH    R15,6(R15,0)            Add offset to @STRING routine
         BR    R15                     Branch to @STRING
         DC    Y(@STRING-$STRING-2)    Offset to @STRING Routine
.MEND    AIF   ('&PRINT' EQ 'NOGEN').MEND99
         POP   PRINT
.MEND99  MEND
         EJECT
**********************************************************************
**********************************************************************
********* TEST PROGRAM FOR THE 'STRING' MACRO ************************
**********************************************************************
**********************************************************************
**       STRING (GENERATE,AR_MODE)
**       END
         LCLA  &ASMH_HLASM
         AIF   (T'&ASMH_HLASM EQ 'N').ASMH1X
&SYSVER  SETC  'ASMH'
&SYSDATC SETC  '20'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)
.ASMH1X  ANOP
TESTPGM  START X'027000'
TESTPGM  AMODE 24                      (PRE-SMS PUT)
         BALR  R12,0
         USING *,R12
 LOAD EP=SYSDEBUG
 LR R15,R0
 BASSM R14,R15
*STRING 1X,INTO=XXX
*RC8     STRING ((R1),,R**B),((R1),,R22Z),((R1),,R16B),INTO=XXX
         OPEN  (SYSPRINT,OUTPUT)
         STRING 'Assembler is &SYSVER, DATE is &SYSDATC',INTO=XXX
         PUT   SYSPRINT,XXX
         STRING 'AMPERSAND=&& AND APOSTROPHE='' ',INTO=XXX
         PUT   SYSPRINT,XXX
RBPREFIX EQU   *
RBINTCOD EQU   *+6,2,C'H'
         L     R1,PSATOLD-PSA(0,0)
         L     R1,0(,R1)               TCBRBP
         L     R2,PSAAOLD-PSA(0,0)     ASCB
R2ASCB   USING ASCB,R2
         STRING 'SVC',(RBINTCOD-RBPREFIX(R1),H,R3Z),                   X
               1X,(WWWW,,T),' - ',     VV.MM OF SVC RTNE               X
               ((R8),,X),1X,           COM-REG ADDR                    X
               'ASID=',(R2ASCB.ASCBASID,,X),1X,                        X
               PARM1,1X,               MAIN PGM NAME                   X
               INTO=XXX
         PUT   SYSPRINT,XXX
*
         LA    R2,XXX
         STRING 1X,INTO=((R2),8)
         MACRO                                       JDATE MACRO
        @JDATE &DATE                                 JDATE MACRO
         LA    R1,=P'&DATE'                          JDATE MACRO
*** STRING ((R1),P),2X,((R1),P),INTO=XXX
         STRING ((R1),P),2X,((R1),P,YYMMDD),INTO=XXX,                  X
               3X,((R1),P,YY/MM/DD),                                   X
               3X,((R1),P,DD/MM/YY),                                   X
               3X,((R1),P,MM/DD/YY),                                   X
               3X,((R1),P,YYYYMMDD),                                   X
               3X,((R1),P,YYYY-MM-DD)
         PUT   SYSPRINT,XXX                          JDATE MACRO
         MEND                                        JDATE MACRO
        @JDATE 90058
        @JDATE 91059
        @JDATE 93060
        @JDATE 94365
        @JDATE 80058
        @JDATE 84059
        @JDATE 88060
        @JDATE 92061
        @JDATE 00366
         LA    R2,1234
         STRING 'CVTPTR=X''',(CVTPTR,4,X),'''',INTO=XXX,               X
               ' 1234=',((R2),,R4Z)
         PUT   SYSPRINT,XXX
         L     R1,CVTPTR(0,0)
         STRING 'CVTDATE=',(56(R1),P,YYMMDD),INTO=XXX
         PUT   SYSPRINT,XXX
         LA    R0,1000
         LA    R3,0033
         STRING 'D1=/',D1,'/,WWWW=/',WWWW,'/',                         X
               ((R3),,L),'/',((R3),,X),'/',((R0),,L),'/',              X
               ((R3),,R9B),'/',INTO=XXX
         LR    R4,R15                   LENGTH USED
         PUT   SYSPRINT,XXX
         STRING WWWW,                                                  X
               (4(R13),4,X),'''',(4(R13),F),'''',                      X
               (4(R13),F,L),'''',                                      X
               (4(R13),F,L11),'''',                                    X
               (4(R13),F,Z9),'''',                                     X
               8X,'R4=',((R4),,L),      LENGTH USED                    X
               INTO=XXX
         PUT   SYSPRINT,XXX
         STRING %TIME,D1,'B12345678B',5X,(CTR1,P),1X,PARM1,1X,PARM2,   X
               INTO=XXX
         PUT   SYSPRINT,XXX
         LA    R3,17
         STRING INTO=XXX,'CCC1234A',(D1,(R3)),'.',(CTR1,P,R7Z)
         PUT   SYSPRINT,XXX
         STRING C'DDN2(',(D1,,T),')',X'40C1C2,C3C4',                   +
               ' PSATOLD=',(PSATOLD-PSA,,X),                           +
               INTO=XXX
         PUT   SYSPRINT,XXX
         AIF   ('&SYSVER' EQ 'ASMH').HLASM99
PSABASE  USING PSA,R0
         STRING 'PSATOLD=',(PSABASE.PSATOLD,,X),                       +
               ' PSATOLD=',(PSATOLD-PSA,,X),                           +
               INTO=XXX
         PUT   SYSPRINT,XXX
.HLASM99 ANOP
         BALR  R0,0
         STRING 'R0=',((R0),,X),'   16(R0)=',(16(R0),4,X),INTO=XXX
         PUT   SYSPRINT,XXX
         STRING 'R0=',((R0),,X),'   CTR1=',(CTR1,P,R5B),INTO=XXX
         PUT   SYSPRINT,XXX
         SLR   R0,R0
         STRING 'R0=',((R0),,X),'   CTR2=',(CTR2,P,L),'.',INTO=XXX
         PUT   SYSPRINT,XXX
*
AMODE31  LA    R12,0(,R12)             BALR->BASR
         L     R15,=A(*+X'80000006')   AMODE=31
         BSM   0,R15                   AMODE=31
         L     R1,=A(@STRING)          point at CSECT
         CLC   =C'/390',11(R1)         (GENERATE,AR_MODE) ?
         BNE   EXIT                    no, prevent S0E0
         DSPSERV CREATE,                                               X
               NAME==CL8'STRING00',    C'STRING00'                     X
               BLOCKS=HDRBLKS,         SIZE IN PAGES                   X
               STOKEN=DSPCSTKN,                                        X
               ORIGIN=DSPCORG
         ALESERV ADD,STOKEN=DSPCSTKN,ALET=DSPCALET
         LAM   R8,R8,DSPCALET          POINT TO THE DATA SPACE
         L     R8,DSPCORG              SPACE ORIGIN (0 OR 4096)
         SAC   512                     MODE=AR
 LAM R14,R6,TESTPGM+40                 S0E0-28
         STRING WWWW,'AR_MODE WORKED OK',INTO=(2048(R8),100)
         LAM   R2,R2,DSPCALET          POINT TO THE DATA SPACE
         LR    R2,R8                   SPACE ORIGIN (0 OR 4096)
         STRING (2048+L'WWWW(R2),30,T),INTO=XXX
         SAC   0                       MODE=AR OFF
         PUT   SYSPRINT,XXX            AR_MODE WORKS OK
*
EXIT     SLR   R15,R15
         SVC   3                       GOBACK
D1       DC    C'D1-----D1    '
WWWW     DC    C'WWWW'
CTR1     DC    P'1'
CTR2     DC    P'-33'
PARM1    DC    C'<-PARM1->'
PARM2    DC    C'<-PARM2->'
XXX      DS    CL132
DSPCSTKN DS    XL8                  0  AS TOKEN
DSPCALET DS    F                    8  ALET
DSPCORG  DS    F                   12  ORIGIN
HDRBLKS  DC    F'100'
CVTPTR   EQU   0016,4,C'A'
SYSPRINT DCB   DSORG=PS,DDNAME=SYSPRINT,MACRF=PM,RECFM=FB,LRECL=121
XYZ      DSECT
         STRING GENERATE
**       STRING (GENERATE,NO_CSECT) -\
**       STRING (GENERATE,AR_MODE)  -/
**       STRING (GENERATE,,LOCTR)
**       STRING (GENERATE,AR_MODE,LOCTR)
**       STRING (GENERATE,NO_CSECT,LOCTR)    invalid combination
         YREGS
PSA      DSECT
PSATOLD  EQU   *+X'21C',4,C'A'
PSAAOLD  EQU   *+X'224',4,C'A'
ASCB     DSECT
ASCBASID EQU   *+36,2,C'X'
         END
//SYSPRINT DD SYSOUT=*
//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR
//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)
//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200
//*
//GO      EXEC PGM=LOADER,PARM=PRINT,TIME=(,2)
//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,DELETE)
//SYSLOUT  DD SYSOUT=*
//SYSPRINT DD SYSOUT=*
//ABNLTERM DD SYSOUT=*
//ABNLIGNR DD DUMMY
//SYSDEBUG DD SYSOUT=*
//SYSUDUMP DD SYSOUT=*

          +----------------------------------------+
          +                                        +
          +   Documentation for the STRING macro   +
          +                                        +
          +       Last update: 13 Dec 1999         +
          +----------------------------------------+

  The STRING macro is functionally similar to the COBOL DISPLAY
  or PL/I PUT EDIT instructions.

  Using STRING, the assembler programmer can concatenate
  any number of fields, edit each of them if necessary,
  and receive the result in the specified work area.

  Formats:

    (1) label  STRING {field_specification1}
                      {,field_specification2}...
                      ,INTO=workarea|(workarea,length)
                      {,PRINT=GEN|NOGEN}

    (2) label  STRING GENERATE
                      {,PRINT=GEN|NOGEN}


  field_specification

    Each field to be printed is described as a positional
    operand.  Each operand specifies the field address, its
    length, and its formatting requirements.

    Four field description formats are supported:

      1.   symbol
      2.   (symbol,length,format)
      3.   (d(r)|(r),length,format)
      4.   ((r),,format)
      5.   'character string'

  Symbol specifies the field address.  It must be an
    S-type (relocatable) address.

  d(r) may be used to specify the field address in S/370
    base-displacement format.  If d is zero, it may be omitted.
    If d(r) or (r) is used, length must also be specified.  R14
    and R15 may not be used.  If d(0) is used, it is handled the
    way the assembler does, i.e. R0 as a base register is assumed
    to contain zero: 16(0) is equivalent to 16, CVTPTR or, X'10'.

  ((r),,format) specifies that (r) contains the value
    itself, not an address.  R14 and R15 may not be used.

  'character string' specifies a literal enclosed in single quotes
    as specified in a DC instruction.  Hex strings or character
    strings are supported.  The following expressions are equivalent:
    'ABC' C'ABC' X'C1C2C3'

  Length specifies the length and/or the type of the input field.
    It may be specified as an integer, a symbol, a register, or a
    constant.  When used with symbol, it overrides the assembled
    length and/or type.  Length is required if field is specified
    as d(r) or (r).  If a zero length is specified, the field is
    ignored.

        nn   field length in bytes
        H    half-word
        F    full-word
        FL1  1-byte binary integer
        FL3  3-byte binary integer
        P    packed field
        (r)  length of character string (R0 thru R12)
        d(r) length of character string (R1 thru R12)

  Notes:  If the field address is specified as a symbol that
          has been defined previously in the program, the symbol
          type is known and there is no need to specify it.

          If the length is specified as (r) or d(r) and the value
          is greater than the address itself, (r) or d(r) is
          considered to be the end address +1 instead of the length.

          The length is not specified for packed fields.  The
          @STRING subroutine scans the field left-to-right until it
          finds a byte with a valid sign in the low-order 4 bits.

          If symbol is an arithmetic expression and no length is coded,
          the implicit length will be that of the first symbol in the
          expression;  for example, if symbol is coded as PSATOLD-PSA,
          then the implicit length will be L'PSATOLD.

          All numeric items are assumed positive.

  format  optionally indicates editing options that must
          be applied to a field.

      L        left justified
      R        right justified
      nn       output length
      0        adjust length
      Z        leading zeroes
      B        leading/trailing blanks
      T        truncate character string after last non-blank
      X        display in hexadecimal
      YYMMDD   convert julian date to YYMMDD
      YY/MM/DD convert julian date to YY/MM/DD
      DD/MM/YY convert julian date to DD/MM/YY
      MM/DD/YY convert julian date to MM/DD/YY
      YYYYMMDD convert julian date to YYYYMMDD
      YYYY-MM-DD convert julian date to YYYY-MM-DD

    The default format depends on the field type:

        Type                   Default Format

        character string             L
        FL1                          R3B
        H or FL2                     R5B
        other numeric fields         R7B

    Note: L0 and T are equivalent for character strings.

  'character string' is any character string enclosed in
  single quotes.  Blank spaces may be specified as nnX,
  where nn is the number of X'40' bytes you want to be
  inserted in the output line.  %TIME may be specified to
  obtain the current time in hh.mm.ss.hh format.

INTO=workarea|(workarea,length)

  INTO indicates the address and length of the output work area
  into which the result of the concatenation should be placed
  (left justified).  If the work area is too small, truncation
  will occur.  If it is too large, it is padded with blanks.

  The address may be a symbol, d(r) (S-type address) or (r).

  The length may be specified as an integer, a symbol, a register,
  or a constant; it is required if the address is coded as d(r) or
  (r).  If length is not specified for a symbol-type address, the
  assembled length of the symbol is used.

  Upon return from STRING, R15 contains the length actually used
  in the output work area (before padding).

PRINT=GEN|NOGEN

  This operand allows you to temporarily override the PRINT
  specification (GEN or NOGEN).

GENERATE (format 2)

  The GENERATE format must be specified once at the end of the
  program.  It generates the @STRING sub-routine as well as all
  the literals specified in previous invocations of the macro.

  The GENERATE format allows the specifications of the
  AR_MODE, NO_CSECT and LOCTR options.

         STRING GENERATE<,AR_MODE<,LOCTR>>>
                          NO_CSECT

  The following combinations are valid:

         STRING GENERATE
         STRING (GENERATE,NO_CSECT)
         STRING (GENERATE,AR_MODE)
         STRING (GENERATE,,LOCTR)
         STRING (GENERATE,AR_MODE,LOCTR)

  The AR_MODE option can be specified to generate a
  @STRING module that supportd AR mode.  Example:

         STRING (GENERATE,AR_MODE)

  The NO_CSECT option can be specified to indicate that the
  @STRING module should not be generated; only the literals
  are generated in this case.  Example:

         STRING (GENERATE,NO_CSECT)

  The @STRING CSECT contains optional functions (such as %TIME or
  julian date conversion) that are only generated if they have
  been specified in the previous invocations of the STRING macro.

  To generate an @STRING CSECT that supports all of the optional
  functions, two STRING GENERATE macros must be specified:

         STRING (GENERATE,NO_CSECT)        Generate Literals
         STRING GENERATE                   Generate CSECT

Examples:

     STRING 'ERROR===>',LINE1,'<=== POS ',((R6),,L0),INTO=WORKAREA

     STRING 8X,C'ERRORS FOUND: ',(ERRORS,,L0),INTO=((R7),44)

     STRING 'CVT ADDR IS ',(CVTPTR,4,X),X'40C1C2C3C4',INTO=LINE

     LA    R5,WORK+16              end addr +1
     STRING 'R4=',((R4),,X),INTO=(WORK,(R5)),PRINT=GEN

     STRING '//JOBLIB DD DSN=',(DSN1,,T),',DISP=SHR',INTO=((R2),72)

     PUT   SYSLIN                  PUT Locate
     LH    R0,SYSLIN+82            LRECL
     STRING '   NAME  ',(4(R3),8,T),'(R)',INTO=((R1),(R0))

     STRING GENERATE         Generate literals and sub-routine


Programming Notes:

  A STRING macro generates only 6 bytes that need to be covered by
  base registers.  More code is generated at the end of the
  current CSECT (using LOCTR pseudo instruction), but this code
  does not require addressability.  This is particularly useful
  when STRING calls specify a large number of literals.

  Additionally, STRING does not use A-type constants (ACON), but
  S-type constants (SCON) which require symbols to be addressable
  at the point in the program where STRING is issued.

  While these addressing techniques reduce the number of base
  registers required to cover the program's code and make it easier
  to write reentrant programs, they will produce assembly errors in
  the following situations:

  a.  STRING is used in more than one CSECT in the same assembly

  b.  the CSECT in which STRING is used is longer than 64K

  c.  symbols are not addressable at the point in the program
      where STRING is issued

  d.  the $STRING symbol (generated in the $LTORG LOCTR during the
      GENERATE invocation of the STRING macro) is not addressable
      in some of the STRING calls.
