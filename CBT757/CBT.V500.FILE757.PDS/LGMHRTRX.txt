***********************************************************************
*LLL      GGGGGGG M     M H      H RRRRRRR  TTTTTTTTT RRRRRR  Y     Y *
* L       G     G MM   MM H      H R      R T   T   T R     R  Y   Y  *
* L       G       M M M M H      H R      R     T     R     R   Y Y   *
* L       G  GGGG M  M  M HHHHHHHH RRRRRRR      T     RRRRRR     Y    *
* L       G     G M     M H      H R    R       T     R   R      Y    *
* L       G     G M     M H      H R     R      T     R    R     Y    *
* LLLLLLL GGGGGGG M     M H      H R      R     T     R     R    Y    *
***********************************************************************
*                                                                     *
***********************************************************************
*                                                                     *
* NAME:            LGMHRTRY                                           *
*                                                                     *
* TYPE:            Assembler Source (High Level Assembler)            *
*                                                                     *
* FUNCTION:        Logger Services Diagnostic ESTAEX Retry Program    *
*                                                                     *
* INPUT REGS:      R1  => Standard z/OS Parameter List                *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY, AC=0                          *
*                                                                     *
* DEPENDENCIES:    Copybooks LGCPLOGR and LGCPLSWA                    *
*                                                                     *
* RESTRICTIONS:    z/Architecture Mode                                *
*                                                                     *
* RETURN CODES:    Equivalent to System Completion Code and Reason    *
*                  Code from User's Program                           *
*                                                                     *
* REGISTER USAGE:  R15, Entry Point Address                           *
*                  R14, Return Address                                *
*                  R13, (RLCA) Save Area & Dynamic Area               *
*                  R12, (RBASE1) First Program Base Register          *
*                  R11, (RBASE2) Second Program Base Register         *
*                  R10, (RCOMM) Common Area                           *
*                  R9,  (RLGW) LGRWK2II Area (LGCPLSWA CopyBook)      *
*                  R8,  (RSDW) SDWA Dsect Area                        *
*                  R7,  (PLCA) Abending User Program's LCA Address    *
*                  R6,  (RPCC) Current LCA Address                    *
*                  R0-R5, General Work registers                      *
*                                                                     *
* CHANGE ACTIVITY:                                                    *
*                                                                     *
*  Reason  Release   Date    Description                              *
* -------- ------- -------- ------------------------------------------*
* Fix      V1R1M17 20120721 Register Summary Reprt Was Indicating@@KHF*
*                           Invalid 64-bit Address as Belonging  @@KHF*
*                           to Valid Above-the-Bar Memory Object.@@KHF*
* Change                    To Support Processing of Log Records @@KHF*
*                           Residing in Above-the-Bar Storage.   @@KHF*
* Change                    To Support Processing for 1 Megabyte @@KHF*
*                           Addressability (-512K to +512K) to   @@KHF*
*                           Fields Specified by User in Logpoint.@@KHF*
* Fix      V1R1M16 20120127 Moved #LGPOINT Data Areas With LOCTR @@KHF*
*                           to Reduce Logger Services Footprint. @@KHF*
* Change                    Added to SVC Table Info for SVC Type,@@KHF*
*                           Calling Module Name, and Entry Point.@@KHF*
* Fix      V1R1M15 20110930 Wrapped PUTs with SYSSTATE AMODE64=NO@@KHF*
*                           /YES Sequence to Conform to New DFSMS@@KHF*
*                           Macro Changes Introduced in zOS V1R13@@KHF*
*                           That Test for SysState Amode.        @@KHF*
* Fix                       Register Summary Reprt not Indicating@@KHF*
*                           When Registers Flagged Were for the  @@KHF*
*                           Target of an Execute Instruction.    @@KHF*
* Change                    Added Support to Disassemble All the @@KHF*
*                           Hex Machine Code Instructions in the @@KHF*
*                           Vicinity of an Abending Instruction. @@KHF*
* Change                    Added Support to Show the Address and@@KHF*
*                           the Instructions in the Vicinity of  @@KHF*
*                           the Last Interrupt Before the Abend. @@KHF*
* Change                    Added Support to Show Information on @@KHF*
*                           the Allocation of CSA, SQA, and LSQA @@KHF*
*                           in the Register Summary Report.      @@KHF*
* Change                    Reformatted Abend Summary Section and@@KHF*
*                           Moved Section to Before the Abending @@KHF*
*                           Instruction Section Instead of After.@@KHF*
* Fix      V1R1M14 20110423 When Analyzing Bits 16-19 of PSW the @@KHF*
*                           Addr Space Mode and Condition Code in@@KHF*
*                           PSW Not Displayed Correctly When User@@KHF*
*                           Program in Access-Register Mode.     @@KHF*
* Change                    Added Support to Disassemble Machine @@KHF*
*                           Code Instruction from a Storage Area @@KHF*
*                           into an Assembler Source Statement.  @@KHF*
* Change                    Revised Machine Code Table to Conform@@KHF*
*                           to 'Principle of Ops, 9th Edition'.  @@KHF*
* Fix      V1R1M13 20110108 Incorrect Reg Flagged as a Designated@@KHF*
*                           R3 in RRF3/RRF-a-b Format Instructn. @@KHF*
* Fix                       Reg identified incorrectly in the Reg@@KHF*
*                           Summary report when target instructn @@KHF*
*                           field referenced on non-EX instructn.@@KHF*
* Change                    Added Logic to Validate Instruction  @@KHF*
*                           for Address Pointing to Instruction. @@KHF*
* Change                    Added New CPU Instructions Introduced@@KHF*
*                           by the IBM zEnterprise 196 series.   @@KHF*
* Change                    Added PSW Bit Setting Detail Line to @@KHF*
*                           the Abend Information Report.        @@KHF*
* Change                    Added a 128-bit z/Architecture Format@@KHF*
*                           PSW to the Abend Information Report. @@KHF*
* Change                    Added Display of Load Mod Name+Offset@@KHF*
*                           Where Breaking Event Address Occurred@@KHF*
* Change                    Added Subpool Storage Number Info for@@KHF*
*                           Private Area Subpools Allocated Reprt@@KHF*
* Fix      V1R1M12 20100306 Register Address in Register Summary @@KHF*
*                           Report Had an Incorrect Storage Type @@KHF*
*                           Displayed for Alloc/Free-Space Areas.@@KHF*
* Fix                       Target instruction of an Execute Not @@KHF*
*                           Being Displayed When B2 Register =>8.@@KHF*
* Fix      V1R1M11 20091023 Registers Not Correctly Indentified  @@KHF*
*                           in Register Report for EX Instruction@@KHF*
*                           When Target Addr Points to Null Area.@@KHF*
* Fix                       Register Summary Report Displaying   @@KHF*
*                           Incorrect Load Module Name.          @@KHF*
* Change                    Show the Abending Instruction Being  @@KHF*
*                           Analyzed in Register Analysis Summary@@KHF*
* Fix      V1R1M10 20090523 Error in Building some 16-Bit Op Cdes@@KHF*
*                           Fail Search in Machine Instructn Tbl.@@KHF*
* Fix                       S0C4 in Load Module Search when High @@KHF*
*                           Half of Reg not Cleared Before Load. @@KHF*
* Change                    Add Register Analysis Summary Display@@KHF*
* Fix      V1R1M09 20090110 Invalid Registers Displayed When the @@KHF*
*                           LCA FSA Did Not Equal the TCBFSA.    @@KHF*
* Change                    Added the Abending Program Addressing@@KHF*
*                           Mode, Condition Code, PIC (Program   @@KHF*
*                           Interrupt Code) Description, Module  @@KHF*
*                           or Csect Address and Length in Save  @@KHF*
*                           Area Trace, and Machine Instruction  @@KHF*
*                           Characteristics and Attributes for an@@KHF*
*                           Abending Instruction.                @@KHF*
* Change   V1R1M08 20081010 Add Support to Display Access Regs   @@KHF*
*                           Add Support for New Parms in LGMHPSTG@@KHF*
* Change   V1R1M07 20080524 Add Support for Data Set Allocations @@KHF*
* Change                    Add Support for Storage Allocations  @@KHF*
* Change                    Add Recovery of Log Rcrds From Buffer@@KHF*
* Change                    Parse of Mixed Format Save Area Chain@@KHF*
* Fix                       DEB Chain Parse Not Updating DCB Addr@@KHF*
* Change                    Rewrite to Support Future Expansion  @@KHF*
* Update   V1R1M06 20080223 Updated VV.RR.MM stats for Fix Pack 6@@KHF*
* Update   V1R1M05 20080112 Updated VV.RR.MM stats for Fix Pack 5@@KHF*
* Fix      V1R1M04 20071104 S0C4 When No //LGRECOUT DD in JCL    @@KHF*
* Fix                       Loop When Resolving Load Module Name @@KHF*
* Fix                       Completion Code Not Passed to ABEND  @@KHF*
* Update   V1R1M03 20070701 Updated VV.RR.MM stats for Fix Pack 3@@KHF*
* Update   V1R1M02 20070610 Updated VV.RR.MM stats for Fix Pack 2@@KHF*
* Update   V1R1M01 20070512 Updated VV.RR.MM stats for Fix Pack 1@@KHF*
* (New)    V1R1M00 20070420 First Release (@CBT-Tape)            @@KHF*
*                                                                     *
***********************************************************************
*
*+-------------------------------------------------------------------+*
*|  D e f i n e   a n d   S e t   P r o g r a m   V a r i a b l e s  |*
*+-------------------------------------------------------------------+*
*
         LCLC  &KXHVER,&KXHREL,&KXHMOD Version/Release/Modification Lvl
         LCLC  &KXHVRM             Set for Version/Release/Mod Level
         LCLC  &RELDATE            Indicate the Release Date
         LCLC  &AMODE              Addressing Mode of Program
         LCLC  &RMODE              Resident Mode of Program
&KXHVER  SETC  'V1'                Indicated Program Version Number
&KXHREL  SETC  'R1'                Indicated Program Release Number
&KXHMOD  SETC  'M17'               Indicated Program Modification Levl
&KXHVRM  SETC  '&KXHVER.&KXHREL..&KXHMOD'  Set for Version/Release/Mod
&RELDATE SETC  '&SYSDATC'          Assemble (Program Release) Date
&CPYRITE SETC  '2008,2012'         Program Copyright Year
&AMODE   SETC  '64'                Set Default Program Addressing Mode
&RMODE   SETC  'ANY'               Set Default Program Residence Mode
         COPY  LGCPLOGR            Logger Services Source-Setup CopyBk
&MODID   SETC  'LGMHRTRY'          Set the Program Module Identifier
         PRINT NOGEN
         EJECT  ,
***********************************************************************
*+-------------------------------------------------------------------+*
*|          MM       MM     AAAAA    IIIIIII   NNN     NNN           |*
*|          M M     M M    A     A      I       N N     N            |*
*|          M  M   M  M    A     A      I       N  N    N            |*
*|          M   M M   M    AAAAAAA      I       N   N   N            |*
*|          M    M    M    A     A      I       N    N  N            |*
*|          M         M    A     A      I       N     N N            |*
*|         MMM       MMM   A     A   IIIIIII   NNN     NN            |*
*+-------------------------------------------------------------------+*
***********************************************************************
*                                                                     *
***********************************************************************
*+-------------------------------------------------------------------+*
*|    LGMHRTRY - (Entry Point)                                       |*
*+-------------------------------------------------------------------+*
* PROGRAM NAME:    LGMHRTRY                                           *
*                                                                     *
* FUNCTION:        Logger Diagnostic ESTAEX Retry Routine             *
*                                                                     *
*                  This ESTAEX retry program is entered upon a user   *
*                  program abnormally terminating (Abend). The ESTAEX *
*                  environment was established earlier by the Logger  *
*                  Service program 'LGMHLRCI' which designated the    *
*                  Logger Service program 'LGMHESTA' as the recovery  *
*                  exit program. When a user program has abnormally   *
*                  terminated, the Recovery Termination Manager of    *
*                  of z/OS will receive control, and during abnormal  *
*                  termination the z/OS Recovery Termination Manager  *
*                  will route control to the recovery exit program    *
*                  named 'LGMHESTA'. If no retry address was specified*
*                  by the abending program (meaning that the retry    *
*                  address field named LGWRETRY contained zeros in the*
*                  Logger work area LGRWK2II), then the recovery      *
*                  program 'LGMHESTA' using SETRP passes control to   *
*                  this retry program named 'LGMHRTRY'. Therefore,    *
*                  being here means the user program has abended, and *
*                  this retry program will basically hold the phone to*
*                  gather diagnostic information and perform resource *
*                  clean up before allowing the user program to end in*
*                  an abend.                                          *
*                                                                     *
*                  The function of this program is before allowing the*
*                  abend in the user's program to percolate, retry    *
*                  processing will print diagnostic messages. If the  *
*                  //LGRECOUT data set is not available indicating    *
*                  Logger Services was not active, then only a short  *
*                  summary report will be printed. If there is an open*
*                  //LGRECOUT data set available indicating Logger    *
*                  Services was active, then a full diagnostic report *
*                  and cleanup process is performed. With full report *
*                  processing any output Logger records which may have*
*                  acculmulated in memory are recovered and printed to*
*                  prevent loss of data. Then the SDWA is analyzed.   *
*                  The completion code and reason code are printed.   *
*                  For program interruptions (PIC) the reason for the *
*                  abend is printed with a list of possible causes.   *
*                                                                     *
*                  Next the abend code, the abending program name and *
*                  related offset, the ESA/390 format PSW, the 128-bit*
*                  z/Architecture Format PSW, the Data Around PSW, the*
*                  Breaking Event Address, the Abending Instruction   *
*                  Length (ILC) ,the CPU state(Problem,Supervisor),   *
*                  PSW key(0-F), the Amode(24,31,64), the Condition   *
*                  Condition Code(0-3), and the Address Space Mode    *
*                  (Primary, Secondary, Access,Home) are displayed in *
*                  the Abend Summary section.                         *
*                                                                     *
*                  Next an abending instruction summary is produced.  *
*                  A disassembler is called where the machine code    *
*                  for the abending instruction is disassembled into  *
*                  an assembler language source statement. Then       *
*                  detailed information on the characteristics of the *
*                  instruction which abended is displayed including   *
*                  the address of the abending instruction, the       *
*                  abending instruction machine code, the instruction *
*                  op-code, the instruction mnemonic, the instruction *
*                  description, the instruction format, the format    *
*                  type, the instruction attributes, and any hardware *
*                  dependence the instruction may have on extended    *
*                  facilities. If applicable, detailed information on *
*                  the characteristics of the target instruction of an*
*                  abending Execute (EX, EXRL) instruction are also   *
*                  displayed.                                         *
*                                                                     *
*                  Next the instructions in the vicinity of the abend *
*                  are displayed. Up to 20 or more instructions that  *
*                  precede the failing instruction, and the six       *
*                  instructions following the failed instruction are  *
*                  disassembled from the machine code in the load     *
*                  module and displayed as assembler language source  *
*                  statements in the abend report.  If the abend      *
*                  occurred in an SVC, in addition to the instructions*
*                  in the vicinity of the abend, the address in the   *
*                  user's program where the SVC was coded will be     *
*                  displayed. The machine instructions in the vicinity*
*                  of where the SVC was called in the user's program  *
*                  will also be disassembled and displayed to show the*
*                  assembler language statements that the user coded  *
*                  in their program preceding the call to the abending*
*                  SVC.                                               *
*                                                                     *
*                  If a breaking event address is available, then the *
*                  BEA will we displayed and the load module name and *
*                  offset for the BEA will be displayed. In addition, *
*                  the machine instructions in the vicinity of the    *
*                  breaking event address will be disassembled to show*
*                  the assembler language statements in the vicinity  *
*                  of the breaking event address.                     *
*                                                                     *
*                  Next the contents of the 16 64-bit general purpose *
*                  registers and the 32-bit access registers at the   *
*                  time of the abend are printed. Then the content of *
*                  each general purpose register is analyzed for valid*
*                  pointers to any load modules, or to any allocated  *
*                  or free space storage areas. Next any registers    *
*                  used in the abending instruction as a designated,  *
*                  index, base, odd of an even/odd pair, or implied   *
*                  by hardware convention are identified. The result  *
*                  of this analysis is printed to output as a register*
*                  summary report to further aid in the diagnosis of  *
*                  the abend.                                         *
*                                                                     *
*                  Next the save area chain is analyzed to produce a  *
*                  save area trace including each program name, Csect *
*                  address, Csect length, and contents of the general *
*                  purpose registers. Then an analysis is performed on*
*                  the virtual storage allocations of the user program*
*                  at the time of abend, and the results area printed *
*                  to output.                                         *
*                                                                     *
*                  Next information for data set allocations at the   *
*                  time of abend are obtained and printed to output.  *
*                  Then the storage contents of each save area for the*
*                  entire Logger Control Area (LCA) for all programs  *
*                  in the current stack are printed. Then print any   *
*                  common area storage, and print the contents of the *
*                  Logger Services control blocks. All output records *
*                  are printed to the //LGRECOUT DD. Once all abend   *
*                  analysis is completed, then cleanup processing is  *
*                  performed to close any open data sets and release  *
*                  storage.                                           *
*                                                                     *
*                  As a last step allow the abend to percolate. This  *
*                  will be done by obtaining the system completion    *
*                  code and the reason code that existed when the z/OS*
*                  system gave control to the Logger recovery exit    *
*                  program 'LGMHESTA', and then passing this          *
*                  information to the ABEND macro resulting in the    *
*                  IEF450I message displaying the user program's      *
*                  completion code and reason code.                   *
*                                                                     *
* INPUT REGS:      R1  => Standard z/OS Parameter List                *
*                                                                     *
* INPUT DATA:      R1  => LGRWK2II (Mapped By LGCPLSWA CopyBook)      *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY, AC=0                          *
*                                                                     *
* CALLING PROGRAM: LGMHESTA - Logger Services Abend Recovery Exit     *
*                                                                     *
* CALLED PROGRAMS: PRPT0000 - Basic Abend Information Report Program  *
*                  PBFR0000 - Log Records Buffer Recovery Program     *
*                  DIAG0000 - Analyze System Diagnostic Work Area Pgm *
*                  PSTO0000 - Analyze Private Area Storage Allocations*
*                  DSKA0000 - Analyze Data Set Allocations            *
*                  PLCA0000 - Process Logger Control Area Stack Pgm   *
*                  PCOM0000 - Process Logger Services Cntl Blks Pgm   *
*                  CLNU0000 - Perform Cleanup From Abend Program      *
*                                                                     *
* RETURN CODES:    Equivalent to System Completion Code and Reason    *
*                  Code from User's Program                           *
*                                                                     *
***********************************************************************
*
LGMHRTRY LPGMNTRY TYPE=MAIN,       Define Main Program Entry           X
               BASE=(12),          Establish Base Registers            X
               AMOD=64,RMOD=ANY,   Addressing and Residency Modes      X
               STORAGE=32,         Define LCA Stacked Storage Size     X
               LCAPFX=RTR,         Define LCA Prefix for This RSECT    X
               LOG=OFF,            Always Turn Logging 'Off' in Logger!X
               COPY@RT=YES         To Generate a Copyright Statement
*
*+-------------------------------------------------------------------+*
*| Get Addresses to the Logger Work Area, the LCA, and the SDWA. Then|*
*| Determine if Logger Services Was Active for The User's Program at |*
*| Time of the Abend.                                                |*
*+-------------------------------------------------------------------+*
*
         USING COM_DATA,RCOMM      Addressability to Common Data Area
         USING LGRWK2II,RLGW       Establish Addressability to LGRWK2II
         USING SDWA,RSDW           Establish Addressability to SDWA
         USING IHADCB,LGWODCB      Establish Addressability to DCB
RTRY0100 DS    0H
         LLGT  RCOMM,=A(COM_DATA)  Common Constants and Routines Area
         LLGTR RLGW,R1             Get the Address of LGRWK2II Area
         LLGT  RSDW,LGWSDWA        Addr of System Diagnostic Work Area
         LLGT  PLCA,LGWABEND       Get Abending Program's LCA Address
         LTGR  RLGW,RLGW           Was Logger Service Active for Pgm?
         BRZ   RTRY1000            No  => Branch to Print Basic Report
RTRY0200 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Was the LGRECOUT Data Cntl Blk Open?
         BRO   RTRY2000            Yes => Branch to Print a Full Report
         BRU   RTRY1000            No  => Branch to Print Basic Report
*
*+-------------------------------------------------------------------+*
*|   Logger Services Was Not Active, Print Basic Information Report  |*
*+-------------------------------------------------------------------+*
*
RTRY1000 DS    0H
         XC    RTRPLIST,RTRPLIST   Clear the Call Parameter List
         CALL  PRPT0000,           Print a Basic Diagnostic Report     X
               ((RSDW),            ..Pass SDWA Area Address            X
               (RLGW),             ..Pass LGRWK2II Area Address        X
               (RCOMM)),           ..Pass Common Constants&Routines    X
               PLIST8=YES,         ..Indicate the Parameter List FormatX
               LINKINST=LGR,       ..Indicate the Link Instruction TypeX
               MF=(E,RTRPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Process a Basic Diagnostic Report
         LTGFR R15,R15             Basic Report Process Successful?
         BRZ   RTRY1100            Yes => Branch to Process Termination
         LGHI  R2,((RTRY2000-RTRY1100)-4) ...Length of Branch Table
         CGFR  R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   RTRY1100            No  => Branch to Process Termination
         BRU   RTRY$END            Yes => Branch to Exit This Routine
RTRY1100 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   RTRY$END            Basic Report Has Completed - Exit
         BRU   RTRY$END            Branch on Warning-Ignore & Exit
         BRU   RTRY$END            Branch on Processing Error - Exit
         BRU   RTRY$END            Branch on Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*|  Logger Services Was Active, Print Full Abend Information Report  |*
*+-------------------------------------------------------------------+*
*
MAIN     USING LCA,R2              Establish Addresability to the LCA
RTRY2000 DS    0H
         MVC   RTRESPIE(LGRSPILN),LGRESPIE Fill ESPIE Remote Parm List
         LLGT  R2,=A(EPIE$000)     Obtain the User Exit Routine Address
         SLGR  R15,R15             Ensure Clean High-Half for Parm Reg
         ESPIE SET,(R2),(1,2,(4,15)),MF=(E,RTRESPIE)  ESPIE Environment
         ST    R1,RTRTOKEN         Token for Previous ESPIE Environment
         SLGR  R2,R2               For Check of Logger Control Area Adr
         ICM   R2,B'1111',LGWMAINP Does the Main Program Have a LCA?
         BRZ   RTRY3000            No  => Then Print Abend Information
         LLGT  R3,MAIN.LCAPWRD1    Obtain the Address of Common Area
         ST    R3,LGWRCOM@         Save the Common Area Address
         LLGF  R3,MAIN.LCAPWRD2    Obtain the Length of Common Area
         ST    R3,LGWRCOML         Save the Common Area Length
         DROP  MAIN                Remove Listed Reg as LCA Base Reg
*
*+-------------------------------------------------------------------+*
*|    Recover Buffered Logger Records and Print to Output Data Set   |*
*+-------------------------------------------------------------------+*
*
RTRY3000 DS    0H
         XC    RTRPLIST,RTRPLIST   Clear the Call Parameter List
         CALL  PBFR0000,           Recover and Print Log Rcds in BufferX
               ((PLCA),            ..Pass Abending Programs's LCA Addr X
               (RSDW),             ..Pass SDWA Area Address            X
               (RLGW),             ..Pass LGRWK2II Area Address        X
               (RCOMM)),           ..Pass Common Constants&Routines    X
               PLIST8=YES,         ..Indicate the Parameter List FormatX
               LINKINST=LGR,       ..Indicate the Link Instruction TypeX
               MF=(E,RTRPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Process Any Buffered Logger Records
         LTGFR R15,R15             Buffered Records Process Successful?
         BRZ   RTRY3100            Yes => Branch to Process Diagnostics
         LGHI  R2,((RTRY4000-RTRY3100)-4) ...Length of Branch Table
         CGFR  R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   RTRY3100            No  => Branch to Process Diagnostics
         BRU   RTRY$END            Yes => Branch to Exit This Routine
RTRY3100 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   RTRY4000            Log Records Completed, Process SDWA
         BRU   RTRY4000            Branch on Warning-Ignore & Continue
         BRU   RTRY$END            Branch on Processing Error - Exit
         BRU   RTRY$END            Branch on Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*| Analyze the System Diagnostic Work Area (SDWA) and the Save Area  |*
*| Chain, and Print Diagnostic Information to Output Data Set        |*
*+-------------------------------------------------------------------+*
*
RTRY4000 DS    0H
         XC    RTRPLIST,RTRPLIST   Clear the Call Parameter List
         CALL  DIAG0000,           Analyze System Diagnostic Work Area X
               ((PLCA),            ..Pass Abending Programs's LCA Addr X
               (RSDW),             ..Pass SDWA Area Address            X
               (RLGW),             ..Pass LGRWK2II Area Address        X
               (RCOMM)),           ..Pass Common Constants&Routines    X
               PLIST8=YES,         ..Indicate the Parameter List FormatX
               LINKINST=LGR,       ..Indicate the Link Instruction TypeX
               MF=(E,RTRPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Analyze the SDWA for Diagnostic Info
         LTGFR R15,R15             Was the SDWA Processing Successful?
         BRZ   RTRY4100            Yes => Branch to Storage Allocations
         LGHI  R2,((RTRY5000-RTRY4100)-4) ...Length of Branch Table
         CGFR  R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   RTRY4100            No  => Branch to Process the LCA
         BRU   RTRY$END            Yes => Branch to Exit This Routine
RTRY4100 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   RTRY5000            SDWA Process Completed, Analyze Stor
         BRU   RTRY5000            Branch on Warning-Ignore & Continue
         BRU   RTRY$END            Branch on Processing Error - Exit
         BRU   RTRY$END            Branch on Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*| Analyze the Storage Allocations in the Private Area, and Print    |*
*| Storage Allocation Information at Time of Abend to Output Data Set|*
*+-------------------------------------------------------------------+*
*
RTRY5000 DS    0H
         XC    RTRPLIST,RTRPLIST   Clear the Call Parameter List
         CALL  PSTO0000,           Analyze Storage Alloc in Priv Area  X
               ((PLCA),            ..Pass Abending Programs's LCA Addr X
               (RSDW),             ..Pass SDWA Area Address            X
               (RLGW),             ..Pass LGRWK2II Area Address        X
               (RCOMM)),           ..Pass Common Constants&Routines    X
               PLIST8=YES,         ..Indicate the Parameter List FormatX
               LINKINST=LGR,       ..Indicate the Link Instruction TypeX
               MF=(E,RTRPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Analyze Private Area for Diag Info
         LTGFR R15,R15             Private Area Processing Successful?
         BRZ   RTRY5100            Yes => Analyze Data Set Allocations
         LGHI  R2,((RTRY6000-RTRY5100)-4) ...Length of Branch Table
         CGFR  R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   RTRY5100            No  => Branch to Process Data Sets
         BRU   RTRY$END            Yes => Branch to Exit This Routine
RTRY5100 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   RTRY6000            Storage Completed, Process Data Sets
         BRU   RTRY6000            Branch on Warning-Ignore & Continue
         BRU   RTRY$END            Branch on Processing Error - Exit
         BRU   RTRY$END            Branch on Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*|Analyze the Data Set Allocations, and Print the Data Set Allocation|*
*|Information at Time of Abend to the Output Data Set                |*
*+-------------------------------------------------------------------+*
*
RTRY6000 DS    0H
         XC    RTRPLIST,RTRPLIST   Clear the Call Parameter List
         CALL  DSKA0000,           Analyze the Data Set Allocations    X
               ((PLCA),            ..Pass Abending Programs's LCA Addr X
               (RSDW),             ..Pass SDWA Area Address            X
               (RLGW),             ..Pass LGRWK2II Area Address        X
               (RCOMM)),           ..Pass Common Constants&Routines    X
               PLIST8=YES,         ..Indicate the Parameter List FormatX
               LINKINST=LGR,       ..Indicate the Link Instruction TypeX
               MF=(E,RTRPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Analyze Data Set Alloc for Diag Info
         LTGFR R15,R15             Data Set Info Process Successful?
         BRZ   RTRY6100            Yes => Branch to Process the LCA
         LGHI  R2,((RTRY7000-RTRY6100)-4) ...Length of Branch Table
         CGFR  R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   RTRY6100            No  => Branch to Process the LCA
         BRU   RTRY$END            Yes => Branch to Exit This Routine
RTRY6100 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   RTRY7000            Data Set Info Completed, Process LCA
         BRU   RTRY7000            Branch on Warning-Ignore & Continue
         BRU   RTRY$END            Branch on Processing Error - Exit
         BRU   RTRY$END            Branch on Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*|Process the Logger Control Area Stack for the Save Area Chain, and |*
*|Print the Contents of the Save Areas to the Output Data Set.       |*
*+-------------------------------------------------------------------+*
*
RTRY7000 DS    0H
         XC    RTRPLIST,RTRPLIST   Clear the Call Parameter List
         CALL  PLCA0000,           Process Logger Control Area (LCA)   X
               ((RSDW),            ..Pass SDWA Area Address            X
               (RLGW),             ..Pass LGRWK2II Area Address        X
               (RCOMM)),           ..Pass Common Constants&Routines    X
               PLIST8=YES,         ..Indicate the Parameter List FormatX
               LINKINST=LGR,       ..Indicate the Link Instruction TypeX
               MF=(E,RTRPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Process LCA Stack for Diagnostics
         LTGFR R15,R15             Was LCA Stack Process Successful?
         BRZ   RTRY7100            Yes => Branch to Process Logger Blks
         LGHI  R2,((RTRY8000-RTRY7100)-4) ...Length of Branch Table
         CGFR  R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   RTRY7100            No  => Branch to Process Logger Blks
         BRU   RTRY$END            Yes => Branch to Exit This Routine
RTRY7100 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   RTRY8000            LCA Process Completed, Process Blks
         BRU   RTRY8000            Branch on Warning-Ignore & Continue
         BRU   RTRY$END            Branch on Processing Error - Exit
         BRU   RTRY$END            Branch on Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*|Process Logger Services Control Blocks and Print to Output Data Set|*
*+-------------------------------------------------------------------+*
*
RTRY8000 DS    0H
         XC    RTRPLIST,RTRPLIST   Clear the Call Parameter List
         CALL  PCOM0000,           Process Logger Services Control BlksX
               ((RSDW),            ..Pass SDWA Area Address            X
               (RLGW),             ..Pass LGRWK2II Area Address        X
               (RCOMM)),           ..Pass Common Constants&Routines    X
               PLIST8=YES,         ..Indicate the Parameter List FormatX
               LINKINST=LGR,       ..Indicate the Link Instruction TypeX
               MF=(E,RTRPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Process Cntl Blk for Diagnostic Info
         LTGFR R15,R15             Was Cntl Blk Processing Successful?
         BRZ   RTRY8100            Yes => Branch to Process Cleanup
         LGHI  R2,((RTRY9000-RTRY8100)-4) ...Length of Branch Table
         CGFR  R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   RTRY8100            No  => Branch to Process the LCA
         BRU   RTRY$END            Yes => Branch to Exit This Routine
RTRY8100 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   RTRY9000            Clnt Blk Process Completed, Cleanup
         BRU   RTRY9000            Branch on Warning-Ignore & Continue
         BRU   RTRY$END            Branch on Processing Error - Exit
         BRU   RTRY$END            Branch on Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*|   Release Resources to Cleanup Before Allowing Abend to Continue  |*
*+-------------------------------------------------------------------+*
*
RTRY9000 DS    0H
         XC    RTRPLIST,RTRPLIST   Clear the Call Parameter List
         CALL  CLNU0000,           Process for Cleanup from Abend      X
               ((PLCA),            ..Pass Abending Programs's LCA Addr X
               (RSDW),             ..Pass SDWA Area Address            X
               (RLGW),             ..Pass LGRWK2II Area Address        X
               (RCOMM)),           ..Pass Common Constants&Routines    X
               PLIST8=YES,         ..Indicate the Parameter List FormatX
               LINKINST=LGR,       ..Indicate the Link Instruction TypeX
               MF=(E,RTRPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Release Resources and Cleanup
         LTGFR R15,R15             Was Cleanup Processing Successful?
         BRZ   RTRY9100            Yes => Branch to Percolate Abend
         LGHI  R2,((RTRY$END-RTRY9100)-4) ...Length of Branch Table
         CGFR  R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   RTRY9100            No  => Branch to Process the LCA
         BRU   RTRY$END            Yes => Branch to Exit This Routine
RTRY9100 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   RTRY$END            Cleanup Process Completed, Now Abend
         BRU   RTRY$END            Branch on Warning-Ignore & Abend
         BRU   RTRY$END            Branch on Processing Error - Abend
         BRU   RTRY$END            Branch on Severe Error - Abend
*
*+-------------------------------------------------------------------+*
*|   Percolate Abend With Program Completion Code and Reason Code    |*
*+-------------------------------------------------------------------+*
*
RTRY$END DS    0H
         ESPIE RESET,RTRTOKEN      Remove the Current ESPIE Environment
         SLGR  R4,R4               For Insert of System Completion Code
         SLGR  R5,R5               For Insert of Abend Reason Code
         ICM   R4,B'0111',SDWACMPC Get the System Completion Code
         TM    SDWACMPF,SDWARCF    Do We Have a Valid Reason Code?
         BRZ   RTRYEND1            No  => Do Not Attempt to Process One
         LLGT  R5,SDWAXPAD         Addr of SDWA Extension Pointers Area
         ICM   R5,B'1111',SDWASRVP-SDWAPTRS(R5) Adr SDWA 1st Extension?
         BRZ   RTRYEND1            No  => Branch to Process Abend Code
         LLGF  R5,SDWACRC-SDWARC1(,R5) ..Get Reason Code With Our Abend
RTRYEND1 DS    0H
         ABEND (R4),,STEP,,REASON=(R5) Terminate Entire Job Step Task
*
*+-------------------------------------------------------------------+*
*|   Return to Caller                                                |*
*+-------------------------------------------------------------------+*
*|This is only to set the required Logger Services Program Exit      |*
*|protocols at end of RSECT since LGMHRTRY will terminate with Abend |*
*|and not return to the user program.                                |*
*+-------------------------------------------------------------------+*
*
RTRYEXIT DS    0H
         SLGR  R15,R15             Indicate Successful Completion
         ST    R15,RTR$RC          Set the Return Code
         LPGMEXIT RC=RTR$RC        Define Program Exit Protocol
*
*+-------------------------------------------------------------------+*
*|    Program RENT Work Area                                         |*
*+-------------------------------------------------------------------+*
*
         LCA   DEFINE              Define the Program RENT Work Area
*
RTRWORKD DS    10D                 General Work Area
RTRPLIST DS    20FD                CALL Parameter List Area
RTRTOKEN DS    F                   Token of the previously active ESPIE
RTRESPIE DS    XL(LGRSPILN)        Area for ESPIE Macro Remote Parm Lst
*
         LCA   DEFEND              Define End of Program RENT Work Area
*
***********************************************************************
*                   End of LGMHRTRY Main Program                      *
***********************************************************************
         EJECT ,
***********************************************************************
*+-------------------------------------------------------------------+*
*| RRRRRRR   OOOOO  U     U TTTTTTT IIIIIII N     N EEEEEEE   SSSSS  |*
*| R      R O     O U     U    T       I    NN    N E        S     S |*
*| R      R O     O U     U    T       I    N N   N E        S       |*
*| RRRRRRR  O     O U     U    T       I    N  N  N EEEEEE    SSSSS  |*
*| R    R   O     O U     U    T       I    N   N N E              S |*
*| R     R  O     O U     U    T       I    N    NN E        S     S |*
*| R      R  OOOOO   UUUUU     T    IIIIIII N     N EEEEEEE   SSSSS  |*
*+-------------------------------------------------------------------+*
***********************************************************************
*                                                                     *
***********************************************************************
**************************+-----------------+**************************
**************************| P R P T 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|            P r i n t   o f   O u t p u t   R e p o r t            |*
*+-------------------------------------------------------------------+*
* PROGRAM NAME:    PRPT0000                                           *
*                                                                     *
* FUNCTION:        Print Basic Output Report                          *
*                                                                     *
*                  This routine is responsible for performing the     *
*                  print of a short output report when a user program *
*                  has abnormally terminated (abend), and logging was *
*                  not active for the current user program which was  *
*                  executing.                                         *
*                                                                     *
* INPUT REGS:      R1 => Standard O/S Parameter List                  *
*                                                                     *
* INPUT DATA:      Parm1: Addr of System Diagnostic Work Area         *
*                  Parm2: Addr of LGRWK2II Logger Work Area           *
*                  Parm3: Addr of Common Constants and Routines Area  *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY, AC=0                          *
*                                                                     *
* CALLING PROGRAM: LGMHRTRY - Main Program                            *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                  04 - Warning                                       *
*                  08 - Error                                         *
*                  12 - Severe Error - Exit This Routine              *
*                                                                     *
***********************************************************************
*
PRPT0000 LPGMNTRY TYPE=SUB,        Define As A Sub-Program Entry       X
               BASE=(12),          Establish Base Registers            X
               AMOD=64,RMOD=ANY,   Addressing and Residency Modes      X
               LCAPFX=PRP,         Establish LCA Prefix for This RSECT X
               LOG=OFF,            Always Turn Logging 'Off' in Logger!X
               LINKRTRN=BSM,       Define Return Linkage Instruction   X
               COPY@RT=YES         To Generate a Copyright Statement
         USING COM_DATA,RCOMM      Addressability to Common Data Area
         USING LGRWK2II,RLGW       Establish Addressability to LGRWK2II
         USING SDWA,RSDW           Establish Addressability to SDWA
         USING IHADCB,LGWODCB      Establish Addressability to DCB
         LMG   R8,R10,0(R1)        Load the Parameter Area Addresses
         XC    PRPRETCD,PRPRETCD   Initialize the Return Code
*
*+-------------------------------------------------------------------+*
*|        Search for a //SYSPRINT Data Control Block in TIOT         |*
*+-------------------------------------------------------------------+*
*   Verify if the //SYSPRINT DD output data set for printing system   *
*   output is allocated. If not allocated then exit as there will     *
*   be no output data set to write report records. Also attempt to    *
*   verify if there is an open //SYSPRINT DCB by running the DEB      *
*   chain, and if one exists then continue processing to write the    *
*   Logger diagnostic records.                                        *
***********************************************************************
*
PRPT1000 DS    0H
         LLGT  R1,CVTPTR           Absolute Address of Pointer to CVT
         USING CVT,R1              Establish Addressability to CVT
         LLGT  R1,CVTTCBP          Obtain the Task Control Block Addr
         LLGT  R2,4(,R1)           Obtain the Current TCB Address
         USING TCB,R2              Establish Addressability to TCB
         LLGT  R1,TCBTIO           Obtain Address of Task I/O Table
         USING TIOT1,R1            Establish addressability to TIOT
         LA    R1,TIOENTRY         Point at the First DD Entry
         USING TIOENTRY,R1         Establish Addressability to Entry
         SLGR  R0,R0               Clear for Use as Work Register
PRPT1100 DS    0H
         ICM   R0,B'0001',TIOELNGH Is There a Leng in Bytes for Entry?
         BRZ   PRPT1400            No  => Branch If End of TIOT
         CLC   4(8,R1),=C'SYSPRINT' ..Is This Our Output DDname?
         BRE   PRPT1200            Yes => Process This DDname
         ALGFR R1,R0               Point to the Next TIOT DDname Entry
         BRU   PRPT1100            Loop to Check Next DDname in List
PRPT1200 DS    0H
         SLGF  R1,TCBTIO           Get the Offset to Our TIOT DD Entry
         LLGFR R3,R1               Preserve the Offset Value
         ICM   R1,B'1111',TCBDEB   Get First Data Extent Block on Chain
         BRZ   PRPT1400            No DEBs on Chain and No SYSPRINT DCB
         USING DEBBASIC,R1         Establish Addressability to the DEB
PRPT1300 DS    0H
         SLGR  R4,R4               Clear for Use as Work Register
         ICM   R4,B'0111',DEBDCBB  Get Address of Data Control Block
SYSP     USING IHADCB,R4           Establish Addressability to the DCB
         CLM   R3,B'0011',SYSP.DCBTIOT ...This Entry Represent Our DCB?
         BRE   PRPT1500            Yes =>
         ICM   R1,B'0111',DEBDEBB  Is There Another DEB on the Chain?
         BRZ   PRPT1400            No  => SYSPRINT Was Not Found
         BRU   PRPT1300            Yes => Loop to Check the Next DCB
PRPT1400 DS    0H
         LGHI  R15,(4)             Indicate //SYSPRINT DD Was Not Found
         BRU   PRPTEXT1            Branch to Exit This Routine
PRPT1500 DS    0H
PFX      USING DEBPREFX,R5         Addressability to DEB Prefix Table
         LGR   R5,R1               Adr to Data Extent Blk Basic Section
         AGHI  R5,(DEBPREFX-DEBBASIC) ..Subtract to Point to DEB Prefix
         CLI   PFX.DEBAMTYP,DEBAMSUB  ...Is This a Sub-System Data Set?
         BRNE  PRPTEXIT            No  => Then SYSPRINT is not SYSOUT=*
PRPT1600 DS    0H
         LLGT  R4,DEBRRQ           JES Uses ACB, This Is Our DCB
         ST    R4,PRPPRINT         Preserve the //SYSPRINT DCB Address
         DROP  R1,R2,SYSP,PFX      Remove Listed Regs as Base Registers
*
*+-------------------------------------------------------------------+*
*|   Print the Header Lines Center Justified for the Report Output   |*
*+-------------------------------------------------------------------+*
*
PRPT2000 DS    0H
         MVI   PRPCCNTL,C'1'       Force Top-Of-Page for Report Start
         MVI   PRPOLINE,C' '       Set-up to Fill Prnt Line with Blanks
         MVC   PRPOLINE+1(L'PRPOLINE-1),PRPOLINE ...Propogate the Blank
         MVC   PRPOLINE+CARDLEN/2-L'HEADER01/2(L'HEADER01),HEADER01
         LLGT  R5,PRPPRINT         Get the Address of the SYSPRINT DCB
         BRAS  R14,PRPTP100        Print the Output Line to //SYSPRINT
         MVI   PRPOLINE,C' '       Set-up to Fill Prnt Line with Blanks
         MVC   PRPOLINE+1(L'PRPOLINE-1),PRPOLINE ...Propogate the Blank
         MVI   PRPCCNTL,C' '       Set Carriage Control to Single Space
PRPT2100 DS    0H
         MVC   PRPOLINE+CARDLEN/2-L'HEADER02/2(L'HEADER02),HEADER02
         LLGT  R5,PRPPRINT         Get the Address of the SYSPRINT DCB
         BRAS  R14,PRPTP100        Print the Output Line to //SYSPRINT
         MVI   PRPOLINE,C' '       Set-up to Fill Prnt Line with Blanks
         MVC   PRPOLINE+1(L'PRPOLINE-1),PRPOLINE ...Propogate the Blank
PRPT2200 DS    0H
         MVC   PRPOLINE+CARDLEN/2-L'HEADER03/2(L'HEADER03),HEADER03
         LLGT  R5,PRPPRINT         Get the Address of the SYSPRINT DCB
         BRAS  R14,PRPTP100        Print the Output Line to //SYSPRINT
         MVI   PRPOLINE,C' '       Set-up to Fill Prnt Line with Blanks
         MVC   PRPOLINE+1(L'PRPOLINE-1),PRPOLINE ...Propogate the Blank
         BRAS  R14,PRPTP100        Print the Output Line to //SYSPRINT
*
*+-------------------------------------------------------------------+*
*|    Print the Logger Services Report Detail Lines                  |*
*+-------------------------------------------------------------------+*
*
PRPT2300 DS    0H
         LA    R4,RCDLNE01         Get Address of First the Detail Line
         LA    R2,CARDLEN          Obtain the Length of the Detail Line
         LLGT  R3,=A(RCDLNE01+((RCDLINES*CARDLEN)-CARDLEN)) ..Last Line
PRPT2400 DS    0H
         MVC   PRPOLINE(CARDLEN),0(R4) ..Copy the Detail Line to Output
         LLGT  R5,PRPPRINT         Get the Address of the SYSPRINT DCB
         BRAS  R14,PRPTP100        Print the Output Line to //SYSPRINT
         MVI   PRPOLINE,C' '       Set-up to Fill Prnt Line with Blanks
         MVC   PRPOLINE+1(L'PRPOLINE-1),PRPOLINE ...Propogate the Blank
         BXLEG R4,R2,PRPT2400      Print Recommendation Report Lines
*
*+-------------------------------------------------------------------+*
*|    Print the Logger Control Cards                                 |*
*+-------------------------------------------------------------------+*
*
PGM      USING LCA,R3              Establish Addresability to the LCA
MODL     USING RCDLNE32,R1         Establish Addresability to Rcd Line
PRPT3000 DS    0H
         LLGT  R2,CVTPTR           Absolute Address of Pointer to CVT
         USING CVT,R2              Establish Addressability to CVT
         LLGT  R2,CVTTCBP          Obtain the Task Control Block Addr
         LLGT  R2,4(,R2)           Obtain the Current TCB Address
         USING TCB,R2              Establish Addressability to TCB
         LLGT  R2,TCBJSTCB         Get Address of First Job Step TCB
         LLGT  R2,TCBFSA           Get the Address of First Save Area
         LLGT  R2,8(,R2)           Get the Main User Program's LCA
         LLGFR R3,R2               To Search for the Last Program's LCA
PRPT3100 DS    0H
         OC    PGM.LCAF64FWD,PGM.LCAF64FWD  Is There a Forward Pointer?
         BRZ   PRPT3200            No  =>
         LG    R4,PGM.LCAF64FWD    Then Obtain the Next Program's LCA
         CLC   0(4,R4),=C'LCA '    Is This Our Abending Program?
         BRNE  PRPT3200            No  =>
         LGR   R3,R4               Make This Program the Current One
         BRU   PRPT3100            Loop to Check the Next Pointer
PRPT3200 DS    0H
         LLGT  R14,PGM.LCACSADR    Obtain the Address of Entry Point
         MVC   PRPOLINE(CARDLEN),RCDLNE32 Model Statement - Subroutines
         LA    R1,PRPOLINE         Obtain the Address of Output Line
         CLC   PGM.LCASAVE+4(4),=C'F5SA' Format5 Save Area for Pgm?
         BRE   PRPT3300            Yes => Then Entry From Main Program
         MVC   RCDPGMNM-RCDLNE32(L'PRPLMOD,R1),25(R14) Get Program Name
         BRU   PRPT3400            Branch to Process the Csect Name
PRPT3300 DS    0H
         MVC   RCDPGMNM-RCDLNE32(L'PRPLMOD,R1),21(R14) Get Program Name
PRPT3400 DS    0H
         LLGT  R5,PRPPRINT         Get the Address of the SYSPRINT DCB
         BRAS  R14,PRPTP100        Print the Output Line to //SYSPRINT
         MVI   PRPOLINE,C' '       Set-up to Fill Prnt Line with Blanks
         MVC   PRPOLINE+1(L'PRPOLINE-1),PRPOLINE ...Propogate the Blank
PRPT3500 DS    0H
         CGR   R2,R3               At the Top of the Save Area Chain?
         BRE   PRPT3900            Yes => Done
PRPT3600 DS    0H
         LG    R3,PGM.LCAF64BCK    Bump It Back Up The Save Area Chain
         LLGT  R14,PGM.LCACSADR    Get Address of the Entry Point
         MVC   PRPOLINE(CARDLEN),RCDLNE32  ...Get the Model Statement
         LA    R1,PRPOLINE         Obtain the Address of Output Line
         MVC   RCDPTYPE-RCDLNE32(L'RCDPTYPE,R1),PROGRAM Pgm Entry/Exit
         CLC   PGM.LCASAVE+4(4),=C'F5SA' Format5 Save Area for Pgm?
         BRE   PRPT3700            Yes => Then Entry From Main Program
         MVC   RCDPGMNM-RCDLNE32(L'PRPLMOD,R1),25(R14) Get Program Name
         BRU   PRPT3800            Branch to Process the Csect Name
PRPT3700 DS    0H
         MVC   RCDPGMNM-RCDLNE32(L'PRPLMOD,R1),21(R14) Get Program Name
PRPT3800 DS    0H
         LLGT  R5,PRPPRINT         Get the Address of the SYSPRINT DCB
         BRAS  R14,PRPTP100        Print the Output Line to //SYSPRINT
         MVI   PRPOLINE,C' '       Set-up to Fill Prnt Line with Blanks
         MVC   PRPOLINE+1(L'PRPOLINE-1),PRPOLINE ...Propogate the Blank
         BRU   PRPT3500            Loop for All Pgms in Save Area Chain
PRPT3900 DS    0H
         MVC   PRPOLINE(CARDLEN),RCDLNE33 ..Copy the Last JCL Statement
         LLGT  R5,PRPPRINT         Get the Address of the SYSPRINT DCB
         BRAS  R14,PRPTP100        Print the Output Line to //SYSPRINT
         MVI   PRPOLINE,C' '       Set-up to Fill Prnt Line with Blanks
         MVC   PRPOLINE+1(L'PRPOLINE-1),PRPOLINE ...Propogate the Blank
         DROP  R2,PGM,MODL         Remove Listed Regs as Base Registers
*
*+-------------------------------------------------------------------+*
*|   Return to Caller                                                |*
*+-------------------------------------------------------------------+*
*
PRPTEXIT DS    0H
         SLGR  R15,R15             Indicate Successful Completion
PRPTEXT1 DS    0H
         ST    R15,PRPRETCD        Set the Return Code
         LPGMEXIT RC=PRPRETCD      Define Program Exit Protocol
*
*+-------------------------------------------------------------------+*
*|         P r i n t   O u t p u t   D e t a i l   L i n e           |*
*+-------------------------------------------------------------------+*
*|SUBROUTINE NAME: PRPTP100                                          |*
*|FUNCTION.......: Print Detail Line to Output Logger Data Set       |*
*+-------------------------------------------------------------------+*
*
PRPTP100 LPGMSUBE                  Set Subroutine Entry Protocol
         SYSSTATE AMODE64=NO,ARCHLVL=2 Generate Code for Not in AMODE64
         SAM31                     Switch Now to 31-Bit Addressing Mode
         PUT   (R5),PRPLINE        Print the Output Line to //SYSPRINT
         SAM64                     Switch Back to 64-Bit Address Mode
         SYSSTATE AMODE64=YES,ARCHLVL=2    Restore 64-Bit Environment
         LPGMSUBX                  Return to Caller of This Subroutine
*
*+-------------------------------------------------------------------+*
*|    Program RENT Work Area                                         |*
*+-------------------------------------------------------------------+*
*
         LCA   DEFINE              Define the Program RENT Work Area
*
PRPWORKD DS    10D                 General Work Area
PRPPLIST DS    20FD                CALL Parameter List Area
PRPRETCD DS    F                   Save Area for the Return Code
PRPPRINT DS    A                   Address of the SYSPRINT DCB
PRPLMOD  DS    CL32                Load Module Name
PRPLINE  DS    0CL133              Output Print Line Area
PRPCCNTL DS    CL1                 Carriage Control Character
PRPOLINE DS    CL132               Output Record Print Area
*
         LCA   DEFEND              Define End of Program RENT Work Area
*
***********************************************************************
*                 End of Print Basic Report Processing                *
***********************************************************************
         EJECT ,
***********************************************************************
**************************+-----------------+**************************
**************************| P B F R 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|  R e c o v e r   a n d   P r i n t   B u f f e r   R e c o r d s  |*
*+-------------------------------------------------------------------+*
* PROGRAM NAME:    PBFR0000                                           *
*                                                                     *
* FUNCTION:        Print the Buffer Area                              *
*                                                                     *
*                  If a user specified the LPGMNTRY entry with the    *
*                  LOGOUT=BUFR option to direct the buffering of      *
*                  Logger records to memory, this routine will        *
*                  recover the Logger records which have accumulated  *
*                  in the buffer area, and print the records to output*
*                  to prevent loss of Logger Services data from the   *
*                  abend.                                             *
*                                                                     *
* INPUT REGS:      R1 => Standard O/S Parameter List                  *
*                                                                     *
* INPUT DATA:      Parm1: Addr of Abending Program's LCA Area         *
* INPUT DATA:      Parm2: Addr of System Diagnostic Work Area         *
*                  Parm3: Addr of LGRWK2II Logger Work Area           *
*                  Parm4: Addr of Common Constants and Routines Area  *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY, AC=0                          *
*                                                                     *
* CALLING PROGRAM: LGMHRTRY - Main Program                            *
*                                                                     *
* CALLED PROGRAMS: None                                               *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                  04 - Warning                                       *
*                  08 - Error                                         *
*                  12 - Severe Error - Exit This Routine              *
*                                                                     *
***********************************************************************
*
PBFR0000 LPGMNTRY TYPE=SUB,        Define As A Sub-Program Entry       X
               BASE=(12),          Establish Base Registers            X
               AMOD=64,RMOD=ANY,   Addressing and Residency Modes      X
               LCAPFX=PBF,         Establish LCA Prefix for This RSECT X
               LOG=OFF,            Always Turn Logging 'Off' in Logger!X
               LINKRTRN=BSM,       Define Return Linkage Instruction   X
               COPY@RT=YES         To Generate a Copyright Statement
         USING COM_DATA,RCOMM      Addressability to Common Data Area
         USING LGRWK2II,RLGW       Establish Addressability to LGRWK2II
         USING SDWA,RSDW           Establish Addressability to SDWA
         USING IHADCB,LGWODCB      Establish Addressability to DCB
         LMG   R7,R10,0(R1)        Load the Parameter Area Addresses
         XC    PBFRETCD,PBFRETCD   Initialize the Return Code
*
*+-------------------------------------------------------------------+*
*|  If logger records have been written to a buffer area, then       |*
*|  recover the logger records accumulated in the indexed buffer     |*
*|  area, and print these records to the output //LGRECOUT DCB.      |*
*+-------------------------------------------------------------------+*
*
PBFR1000 DS    0H
         MVI   PBFLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   PBFLINE+1(L'PBFLINE-1),PBFLINE ...Propogate the Blank
         MVI   PBFCCNTL,C' '       Set Carriage Control to Single Space
         LTGR  RLGW,RLGW           Verify If We Have a LGRWK2II Area?
         BRZ   PBFREXIT            No  => No Output to Write Loggr Rcds
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   PBFREXIT            No  => No Output to Write Loggr Rcds
*
*+-------------------------------------------------------------------+*
*| Obtain The Index Block Pointers to Logger Records in Buffer Areas |*
*+-------------------------------------------------------------------+*
*
         USING LOGSIBLK,RSDX       Establish LOGSIBLK Addressability
         USING LOGTRBLK,REDB       Establish LOGTRBLK Addressability
PBFR1100 DS    0H
         LA    R3,LGWPINDX         Get Pointer to Primary Indx Blk Addr
         LG    RSDX,0(,R3)         Get the Primary Index Block Address
         LTGR  RSDX,RSDX           There a Primary Index Block Address?
         BRZ   PBFREXIT            No  => Logger Records Not Buffered
PBFR1200 DS    0H
         PUSH  USING               Save Current Addressable Environment
         USING LOGPIBLK,RSDX       Establish Addressability to LOGPIBLK
         LG    R1,LOGPISIZ         Get Length of Primary Index Block
         SLGF  R1,=F'8'            To Point to the Next to Last Entry
         LA    RSDX,0(R1,RSDX)     Point to the Secondary Index Block
         LG    RSDX,0(,RSDX)       Get Pointer to Log Records Data Blk
         POP   USING               Restore the Addressable Environment
*
*+-------------------------------------------------------------------+*
*|          Recover The Logger Records In The Buffers                |*
*+-------------------------------------------------------------------+*
*
PBFR1300 DS    0H
         LG    R14,LOGSIFST        Get the Initial Index Entry Address
         LG    R15,LOGSICNT        Get Count of Entries in This Block
PBFR1400 DS    0H
         STMG  R14,R15,PBFSIPOS    Preserve the Current Index Positions
         LG    REDB,0(,R14)        Get the Logger Record Entry Pointer
         CLC   LOGTRCRD(L'BLANKS/2),BLANKS Current Record a Blank Line?
         BRNE  PBFR1500            No  => Check if Processing TCB/Clock
         MVC   PBFLINE,LOGTRCRD    Loggr Rcrd from Buffr to Output Line
         BRU   PBFR2600            Branch to Write Loggr Rcrd to Output
ABEND    USING LCA,PLCA            Establish Addressability to the LCA
PBFR1500 DS    0H
         TM    ABEND.LCAWFLAG,LCAWTRIM Request to Trim Log Rcrd Output?
         BRZ   PBFR1600            No  => Branch to Process Time Stamp
         MVC   PBFLINE,LOGTRCRD    Loggr Rcrd from Buffr to Output Line
         BRU   PBFR2600            Bypass Time Stamp Suffix, Write Rcrd
         DROP  ABEND               Remove Listed Abending Pgm LCA Base
*
*+-------------------------------------------------------------------+*
*| Get Current CPU Clock Time And Convert To A Julian Date And Time  |*
*+-------------------------------------------------------------------+*
*| The CPU clock time is in STCKE format. Previously the CPU clock   |*
*| time and TCB address of the executing task were acquired when     |*
*| logger service was entered in order to place a date and time      |*
*| stamp at the time the log event occurred. The CPU clock time and  |*
*| TCB address were placed in the prefix area of the user program's  |*
*| LCA. Then the STCKE TOD and TCB address were extracted from the   |*
*| LCA and placed in Logger Control Block LGRWK2II. The CPU clock    |*
*| time was used as the key in the insertion of the log record in    |*
*| the buffer area. For each input logger record we are getting the  |*
*| the CPU clock time from the buffer key, and converting the binary |*
*| clock time to a displayable format that will show up in the logger|*
*| record written from the buffer to the output data set.            |*
*|                                                                   |*
*| The 128-bit TOD Store Clock Extended (STCKE) is being used here   |*
*| to provide a date beyond the year 2042. The existing 64-bit TOD   |*
*| clock from STCK will wrap in the year 2042 (i.e., approximately   |*
*| 09/17/2042 @ 23:53:52.613376 - GMT). The additional bits added to |*
*| the STCKE format TOD time-stamp will provide support beyond the   |*
*| wrap date. Therefore, this routine will support dates beyond the  |*
*| year 2042 and beyond the year 2100.                               |*
*|                                                                   |*
*| The first part of this routine takes the STCKE Format 16-Byte     |*
*| (128-Bit) TOD value, and extracts the high-order 72-bit portion   |*
*| of the TOD into a R0/R1 even-odd grande register pair using       |*
*| z/Architecture 64-bit GPRs. Then the 72-bit TOD will be adjusted  |*
*| through the z/OS CVT (Communications  Vector Table) for Leap      |*
*| Seconds and the Local Time based on the CLOCKxx member of         |*
*| Parmlib, which member contains specifications for controlling     |*
*| z/OS time management (i.e., Sysplex Timer, Time Zones).           |*
*|                                                                   |*
*+-------------------------------------------------------------------+*
*
PBFR1600 DS    0H
         UNPK  LGW$TCB@(L'LGW$TCB@+1),LOGTRTCB(L'LOGTRTCB+1) ..TCB Addr
         TR    LGW$TCB@,HEXCONV-C'0' ...Translate Hex to Character
         MVI   LGW$SEP1,C' '       Insert Blank as a Field Separator
         LMG   R0,R1,LOGTRTIM      Extended CPU Clock Time of Log Event
         RLLG  R0,R0,8 Bits        Position the TOD +142yr Byte to Last
         SRDL  R0,8 Bits           Save TOD Byte to R1, Open Slot in R0
         RLLG  R1,R1,32 Bits       TOD 63-71 Bits to Bit Position 32
         SLDL  R0,8 Bits           TOD Bits 8-71 Now in R0 as 64-Bits
         SRLG  R1,R1,56 Bits       +142 Yr Byte to Build 0-71 Bit TOD
         XGR   R0,R1               Exchange Contents of TOD Registers
         XGR   R1,R0               R0 and R1 to Produce a STCKE 72-Bit
         XGR   R0,R1               Format TOD in Even/Odd Register Pair
PBFR1700 DS    0H
         LLGT  R15,CVTPTR          Absolute Address of Pointer to CVT
         LLGT  R15,CVTEXT2-CVT(,R15) ..Get Address of CVT 2nd Extention
         USING CVTXTNT2,R15        Set Addressability to CVT Extention
         SL    R1,CVTLSOL          Adjust the Low Word for Leap Seconds
         BRC   NOBORROW,PBFR1800   Then Branch If There is No Borrow
         LLIHL R14,1               Otherwise, Set to Indicate a Borrow
         SLGR  R1,R14              And Then Subtract for CVT High Word
         BRC   NOBORROW,PBFR1800   Then Branch If There is No Borrow
         SLGF  R0,=A(1)            Othewise, Then Borrow From High Word
PBFR1800 DS    0H
         LMD   R14,R14,CVTLSOH,CVT$ZTOK  Get CVT Hi Word Offset for TOD
         SLGR  R1,R14              Adjust CVT High Wrd for Leap Seconds
         AL    R1,CVTLDTOR         Adjust Low Word For Time Zone Diff
         BRC   NOCARRY,PBFR1900    And Branch If There Is No Carry
         LLIHL R14,1               Otherwise, Set to Indicate a Carry
         ALGR  R1,R14              And Then Add From the CVT High Word
         BRC   NOCARRY,PBFR1900    And Branch If There Is No New Carry
         AL    R0,=A(1)            Propogate Carry to the TOD High Byte
PBFR1900 DS    0H
         LMD   R14,R14,CVTLDTOL,CVT$ZTOK  Get High Word Time Zone Value
         ALGR  R1,R14              Now Adjust for High Word Time Zone
         DROP  R15                 Remove Listed Reg as CVT Ext Base
*
*+-------------------------------------------------------------------+*
*| This Part of the Routine Will Take the CVT Corrected 72-Bit Binary|*
*| Time Stamp, and Convert the Binary Seconds Portion of the TOD Down|*
*| to a Micosecond (1/1,000,000ths of a Second) With the Result      |*
*| Placed in Storage in Packed Decimal Format.                       |*
*+-------------------------------------------------------------------+*
*
PBFR2000 DS    0H
         SRDL  R0,8 Bits           Drop Last Byte/Put +142Yr Byte in R1
         RLL   R1,R1,8 Bits        +142Yr Byte at End of Low-Half of R1
         RLLG  R1,R1,56 Bits       Rotate to Get Back to Proper Format
         SRLG  R1,R1,17 Bits       Set Microseconds/2**13 (Since 1900)
         DLG   R0,=AD((60*60*24/128)*(1000000/64)) R1=Days R0=Microsecs
         LGR   R15,R1              Preserve the Calculated Elapsed Days
         SRDL  R0,32 Bits          Shift So R0/R1 = Microseconds/2**13
         SLLG  R1,R1,13 Bits       Shift So R0/R1 = Microseconds/2**1
         LLGF  R14,=A(60*60)       Indicate No. of Seconds in an Hour
         MSGF  R14,=A(1000000)     To Obtain Microseconds in an Hour
         SLGR  R0,R0               Clear for the Division Operation
         DLGR  R0,R14              Calculate Total Number of Hours
         CVD   R1,PBFWORKD+8       Create Decimal Version No. of Hours
         MVO   PBFWORKD+4(2),PBFWORKD+14(2) Get Hrs Without High Nibble
         SRDL  R0,32 Bits          Prepare for Division to Get Minutes
         D     R0,=A(60*1000000)   Calculate Total Number of Minutes
         CVD   R1,PBFWORKD+8       Create Decimal Version No. of Mins
         MVO   PBFWORKD+5(2),PBFWORKD+14(2) Get Mins Without Hi Nibble
         SRDA  R0,32 Bits          Prepare for Division to Get Seconds
         D     R0,=A(1000000)      Calculate the Total No. of Seconds
         CVD   R1,PBFWORKD+8       Create Decimal Version No. of Secnds
         MVO   PBFWORKD+6(2),PBFWORKD+14(2) Get Secnd Without Hi Nibble
         CVD   R0,PBFWORKD+8       Decimal Version for Microseconds
         SRP   PBFWORKD+12(4),1,0  Shift to Make Last Byte a Slack Byte
         MVC   PBFWORKD+7(4),PBFWORKD+12 ..Get Fractional Seconds Value
         OI    PBFWORKD+10,15      Certify Sign To Make It Displayable
*
*+-------------------------------------------------------------------+*
*| This Part of the Routine Will Process the Binary Date Portion Of  |*
*| the TOD Representing the Days (i.e., Completed days + Current Day)|*
*| Since the z/OS Epoch (01/01/1900), and Convert The Binary Days to |*
*| a Displayable Julian Date Format (i.e., Ordinal Date).            |*
*+-------------------------------------------------------------------+*
*
PBFR2100 DS    0H
         LGR   R1,R15              Get the Total Number of Elapsed Days
         CLGF  R1,=A(36525+1461+365) Leap Century+4yr Cycle+Non-Leap Yr
         BRNL  PBFR2300            Use Extended Date Processing for TOD
PBFR2200 DS    0H
         ALGF  R1,=A(1)            Calendars Start At Day 1, Not Day 0
         SLLG  R1,R1,2 Bits        Multiple Total Days by Factor of 4
         DSGF  R0,=A(4*365+1)      Divide by the No. of Days in 4 Years
         SRLG  R0,R0,2 Bits        Divide By 4 So Now R1=Year R0=Days
         ALGF  R0,=A(1)            Add 1 Since First Day Starts at 1
         LA    R15,1900(,R1)       Epoch + No. of Years into Century
         MGHI  R15,(1000)          Shift The Years to Align with Days
         ALGFR R15,R0              Add to Merge the Years and the Date
         CVD   R15,PBFWORKD+16     Create Decimal Version of the Date
         MVC   PBFWORKD(4),PBFWORKD+20 ...Save The Packed Julian Date
         OI    PBFWORKD+3,15       Certify Sign To Make It Displayable
         BRU   PBFR2500            Process TOD to a Character Format
PBFR2300 DS    0H
         ALGF  R1,=A(36524)        Add the Number of Days in a Century
         SLLG  R1,R1,2 Bits        Multiply Total Days by a Factor of 4
         DSGF  R0,=A(146097)       Days + Leap Century/Days in 400 Yrs
         BCTGR R1,R0               Equalize for the Leap Century Added
         LLGFR R14,R1              Save Elapsed Centuries Since 1900
         LLGFR R1,R0               Get No. of Days into Current Century
         DSGF  R0,=A(1461*4)       Divide by No. of Days in Leap Year
         LLGFR R15,R1              Save No. of Completed 4-Year Cycles
         LLGFR R1,R0               No. of Completed Days in 4-Yr Period
         DSGF  R0,=A(4)            Divide by 4 so Now R1 Has The Days
         DSGF  R0,=A(365)          Determine No. of Yrs into 4-Yr Cycle
         LTGR  R1,R1               Is this Year Currently a Leap Year?
         BRNZ  PBFR2400            No  => Then Set Calendar Start Day
         LLGFR R3,R14              Get the Elapsed Centuries Since 1900
         BCTGR R3,R0               Set the Century Code to Yr 2000 Base
         TMLL  R3,X'0003'          This a Leap Century (400 Year Rule)?
         BRNZ  PBFR2400            No  => Then Set Calendar Start Day
         ALGF  R0,=A(1)            Add a Day to Account for a Leap Year
PBFR2400 DS    0H
         ALGF  R0,=A(1)            Calendar Starts at Day 1, Not Day 0
         SLLG  R15,R15,2 Bits      Completed 4-Yr Cycles x 4 = Years
         ALGFR R1,R15              Add Years into Current 4-Year Cycle
         MGHI  R14,(100)           No. of Years for Completed Centuries
         LA    R1,1900(R14,R1)     Epoch + Century Yrs + Yrs in Century
         LLGFR R15,R1              Copy the Years to Setup an Alignment
         MGHI  R15,(1000)          Shift The Years to Align with Days
         ALGFR R15,R0              Add to Merge the Years and the Days
         CVD   R15,PBFWORKD+16     Create Decimal Version of the Date
         MVC   PBFWORKD(4),PBFWORKD+20 ...Save The Packed Julian Date
         OI    PBFWORKD+3,15       Certify Sign To Make It Displayable
*
*+-------------------------------------------------------------------+*
*| Place The TCB Address and Date/Time Stamp At The End Of The Logger|*
*| Record And Write The Logger Record To The //LGRECOUT Output Data  |*
*| Set.                                                              |*
*|   Example:                                                        |*
*|              008DCB08 2009051-17:57:27.282688                     |*
*|                 |        |     |  |  |   |                        |*
*|                TCB    Ordinal Hrs | Sec  |                        |*
*|               Address  Date      Min     |                        |*
*|                                    To 1/1,000,000ths              |*
*|                                      of a Second                  |*
*+-------------------------------------------------------------------+*
*
PBFR2500 DS    0H
         UNPK  LGWJULDT(7),PBFWORKD(4) Julian Date to Character Format
         UNPK  PBFWORKD+20(13),PBFWORKD+4(7) ..TOD to Character Format
         MVC   LGWJULTM(12),PBFWORKD+20 ...Time of Day to Output Area
         MVI   LGW$SEP2,C'-'       Insert Date/Time Separator Character
         MVC   LGWDHOUR,LGWJULHH   Obtain Current Hour of the Day
         MVI   LGW$SEP3,C':'       Colon as Hour/Minute Separator
         MVC   LGWDMINS,LGWJULMM   Obtain Current Minute of the Hour
         MVI   LGW$SEP4,C':'       Colon as Minute/Seconds Separator
         MVC   LGWDSECD,LGWJULSS   Obtain Current Seconds of the Min
         MVI   LGW$SEP5,C'.'       Period as Fractional Scnds Separator
         MVC   LGWDSTTH,LGWJULTT   Set to '1/1,000,000ths' of a Second
         MVC   PBFLINE,LOGTRCRD    Loggr Rcrd from Table to Output Line
         MVC   PBFLINE+L'PBFLINE-LGWDMPLN(LGWDMPLN),LGW$TCB@ ..TCB/Time
PBFR2600 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   PBFREXIT            No  => No Further Writes, Then Exit
         SYSSTATE AMODE64=NO,ARCHLVL=2 Generate Code for Not in AMODE64
         SAM31                     Switch Now to 31-Bit Addressing Mode
         PUT   LGWODCB,PBFLINE     Print Logger Recrd From Buffer Area
         SAM64                     Switch Back to 64-Bit Address Mode
         SYSSTATE AMODE64=YES,ARCHLVL=2    Restore 64-Bit Environment
         LMG   R14,R15,PBFSIPOS    Restore the Current Index Positions
         LA    R14,L'LOGSINDX(,R14) Bump to Next Recrd Pointer in Index
*
*+-------------------------------------------------------------------+*
*|  Loop Point to Process the Next Logger Record in the Buffer Area  |*
*+-------------------------------------------------------------------+*
*
PBFR2700 DS    0H
         BRCTG R15,PBFR1400        => Loop to Process Next Logger Recrd
*
*+-------------------------------------------------------------------+*
*|     Loop Point for Next Logger Records Secondary Index Block      |*
*+-------------------------------------------------------------------+*
*
PBFR2800 DS    0H
         LG    RSDX,LOGSINXT       Get the Next Secondary Index Block
         LTGR  RSDX,RSDX           Have We Processed All Loggr Records?
         BRNZ  PBFR1300            No  => Loop to Process Next Record
         BRU   PBFREXIT            Yes => Done, Exit This Routine
         DROP  RSDX                Remove Listed Reg as LOGSIBLK Base
         DROP  REDB                Remove Listed Reg as LOGTRBLK Base
*
*+-------------------------------------------------------------------+*
*|   Return to Caller                                                |*
*+-------------------------------------------------------------------+*
*
PBFREXIT DS    0H
         SLGR  R15,R15             Indicate Successful Completion
         ST    R15,PBFRETCD        Set the Return Code
         LPGMEXIT RC=PBFRETCD      Define Program Exit Protocol
*
*+-------------------------------------------------------------------+*
*|    Program RENT Work Area                                         |*
*+-------------------------------------------------------------------+*
*
         LCA   DEFINE              Define the Program RENT Work Area
*
PBFWORKD DS    10D                 General Work Area
PBFPLIST DS    20FD                CALL Parameter List Area
PBFSIPOS DS    2AD                 Pointer for Secondary Index Position
PBFRETCD DS    F                   Save Area for the Return Code
PBFLINE  DS    0CL133              Output Print Line Area
PBFCCNTL DS    CL1                 Carriage Control Character
PBFOLINE DS    CL132               Output Record Print Area
*
         LCA   DEFEND              Define End of Program RENT Work Area
*
***********************************************************************
*                   End of Print Buffer Area                          *
***********************************************************************
         EJECT ,
***********************************************************************
**************************+-----------------+**************************
**************************| D I A G 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|   P r i n t   o f   D i a g n o s t i c   I n f o r m a t i o n   |*
*+-------------------------------------------------------------------+*
* PROGRAM NAME:    DIAG0000                                           *
*                                                                     *
* FUNCTION:        Print Diagnostic Information                       *
*                                                                     *
*                  This routine is responsible for performing the     *
*                  print of abend information for the user program    *
*                  from the z/OS System Diagnostic Work Area (SDWA)   *
*                  Control Block, and printing the save area trace.   *
*                                                                     *
*                  After processing the SDWA this routine will then   *
*                  process the save area chain, and print the contents*
*                  of the Format-4/Format-5 save area created by      *
*                  Logger Services for each calling program. This will*
*                  show the program name, Csect name, and offset into *
*                  the calling program where the call was made, and   *
*                  will show the contents of the calling program's    *
*                  registers at the time the caller entered the called*
*                  program. In the event a calling Logger Services    *
*                  program called a program not using Logger Services,*
*                  the called program may have used a standard save   *
*                  area format to preserve the caller's registers. An *
*                  attempt will be made to parse this mix of save area*
*                  formats to display the entire save area chain. If  *
*                  valid save area chain pointers cannot be           *
*                  determined, then this routine will exit.           *
*                                                                     *
* INPUT REGS:      R1 => Standard O/S Parameter List                  *
*                                                                     *
* INPUT DATA:      Parm1: Addr of Abending Program's LCA Area         *
*                  Parm2: Addr of System Diagnostic Work Area         *
*                  Parm3: Addr of LGRWK2II Logger Work Area           *
*                  Parm4: Addr of Common Constants and Routines Area  *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY, AC=0                          *
*                                                                     *
* CALLING PROGRAM: LGMHRTRY - Main Program                            *
*                                                                     *
* CALLED PROGRAMS: DSWA0000 - Logger Services Program to Process the  *
*                             System Diagnostic Work Area (SDWA)      *
*                  DSTD0000 - Logger Services Program to Process a    *
*                             Standard Save Area (Format-1)           *
*                  DEXS0000 - Logger Services Program to Process an   *
*                             Extended Save Area (Format-4)           *
*                  D5XS0000 - Logger Services Program to Process an   *
*                             Extended Save Area (Format-5)           *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                  04 - Warning                                       *
*                  08 - Error                                         *
*                  12 - Severe Error - Exit This Routine              *
*                                                                     *
***********************************************************************
*
DIAG0000 LPGMNTRY TYPE=SUB,        Define As A Sub-Program Entry       X
               BASE=(12),          Establish Base Registers            X
               AMOD=64,RMOD=ANY,   Addressing and Residency Modes      X
               LCAPFX=DIA,         Establish LCA Prefix for This RSECT X
               LOG=OFF,            Always Turn Logging 'Off' in Logger!X
               LINKRTRN=BSM,       Define Return Linkage Instruction   X
               COPY@RT=YES         To Generate a Copyright Statement
         USING COM_DATA,RCOMM      Addressability to Common Data Area
         USING LGRWK2II,RLGW       Establish Addressability to LGRWK2II
         USING SDWA,RSDW           Establish Addressability to SDWA
         USING IHADCB,LGWODCB      Establish Addressability to DCB
         LMG   R7,R10,0(R1)        Load the Parameter Area Addresses
         XC    DIARETCD,DIARETCD   Initialize the Return Code
*
*+-------------------------------------------------------------------+*
*|    Print Header Lines for Logger Diagnostic Abend Report          |*
*|                                                                   |*
*|               ******************************                      |*
*|               *      Program Abended       *                      |*
*|               ******************************                      |*
*+-------------------------------------------------------------------+*
*
DIAG0100 DS    0H
         MVI   DIALINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DIALINE+1(L'DIALINE-1),DIALINE ...Propogate the Blank
         MVI   DIACCNTL,C' '       Set Carriage Control to Single Space
         LTGR  RLGW,RLGW           Verify If We Have a LGRWK2II Area?
         BRZ   DIAG0300            No  => Then Bypass Print Output
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DIAGEXIT            No  => Then Bypass Print Output
DIAG0200 DS    0H
         BRAS  R14,DIAGP100        Blank Separator Line to //LGRECOUT
DIAG0300 DS    0H
         MVI   DIALINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DIALINE+1(L'DIALINE-1),DIALINE ...Propogate the Blank
         MVI   DIACCNTL,C'1'       Force Top-Of-Page for Report Start
         MVC   DIAOLINE+CARDLEN/2-L'HEADER01/2(L'HEADER01),HEADER01
         LTGR  RLGW,RLGW           Verify If We Have a LGRWK2II Area?
         BRZ   DIAG0500            No  => Then Bypass Print Output
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DIAGEXIT            No  => Then Bypass Print Output
DIAG0400 DS    0H
         BRAS  R14,DIAGP100        Print 1st Header Line to LGRECOUT
DIAG0500 DS    0H
         MVI   DIALINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DIALINE+1(L'DIALINE-1),DIALINE ...Propogate the Blank
         MVI   DIACCNTL,C' '       Set Carriage Control to Single Space
         MVC   DIAOLINE+CARDLEN/2-L'HEADER02/2(L'HEADER02),HEADER02
         LTGR  RLGW,RLGW           Verify If We Have a LGRWK2II Area?
         BRZ   DIAG0700            No  => Then Bypass Print Output
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DIAGEXIT            No  => Then Bypass Print Output
DIAG0600 DS    0H
         BRAS  R14,DIAGP100        Print 2nd Header Line to //LGRECOUT
DIAG0700 DS    0H
         MVI   DIALINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DIALINE+1(L'DIALINE-1),DIALINE ...Propogate the Blank
         MVC   DIAOLINE+CARDLEN/2-L'HEADER03/2(L'HEADER03),HEADER03
         LTGR  RLGW,RLGW           Verify If We Have a LGRWK2II Area?
         BRZ   DIAG0900            No  => Then Bypass Print Output
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DIAGEXIT            No  => Then Bypass Print Output
DIAG0800 DS    0H
         BRAS  R14,DIAGP100        Print 3rd Header Line to //LGRECOUT
DIAG0900 DS    0H
         MVI   DIALINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DIALINE+1(L'DIALINE-1),DIALINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*|  Analyze the System Diagnostic Work Area for Logger Abend Report  |*
*+-------------------------------------------------------------------+*
*
DIAG1000 DS    0H
         LLGFR RPCC,PLCA           Our Abending Program's LCA Address
         XC    DIAPLIST,DIAPLIST   Clear the Call Parameter List
         CALL  DSWA0000,           Process System Diagnostic Work Area X
               ((PLCA),            ..Pass Abending Programs's LCA Addr X
               (RSDW),             ..Pass SDWA Area Address            X
               (RLGW),             ..Pass LGRWK2II Area Address        X
               (RCOMM)),           ..Pass Common Constants&Routines    X
               PLIST8=YES,         ..Indicate the Parameter List FormatX
               LINKINST=LGR,       ..Indicate the Link Instruction TypeX
               MF=(E,DIAPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Process the SDWA for Diagnostic Info
         LTGFR R15,R15             Was the SDWA Processing Successful?
         BRZ   DIAG1100            Yes => Process LCA Save Area Chain
         LGHI  R2,((DIAG2000-DIAG1100)-4) ...Length of Branch Table
         CGFR  R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   DIAG1100            No  => Branch to Process the LCA
         BRU   DIAG7000            Yes => Branch to Exit This Routine
DIAG1100 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   DIAG2000            SDWA Process Completed, Process LCA
         BRU   DIAG2000            Branch on Warning-Ignore & Continue
         BRU   DIAG7000            Branch on Processing Error - Exit
         BRU   DIAG7000            Branch on Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*|    Analyze the Save Area Chain for the Save Area Trace Report     |*
*+-------------------------------------------------------------------+*
*| Print Header Lines for the Save Area Trace Report.                |*
*|                                                                   |*
*| -Save Area Trace-                                                 |*
*| Proceeding Backward From Last Save Area To First Save Area:       |*
*+-------------------------------------------------------------------+*
*
DIAG2000 DS    0H
         MVI   DIALINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DIALINE+1(L'DIALINE-1),DIALINE ...Propogate the Blank
         MVI   DIACCNTL,C' '       Set Carriage Control to Single Space
         LTGR  RLGW,RLGW           Verify If We Have a LGRWK2II Area?
         BRZ   DIAG2200            No  => Then Bypass Print Output
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DIAGEXIT            No  => Then Bypass Print Output
DIAG2100 DS    0H
         BRAS  R14,DIAGP100        Blank Separator Line to //LGRECOUT
DIAG2200 DS    0H
         MVI   DIALINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DIALINE+1(L'DIALINE-1),DIALINE ...Propogate the Blank
         MVI   DIACCNTL,C' '       Set Carriage Control to Single Space
         MVC   DIAOLINE(L'HEADER04),HEADER04 Header for Save Area Trace
         LTGR  RLGW,RLGW           Verify If We Have a LGRWK2II Area?
         BRZ   DIAG2400            No  => Then Bypass Print Output
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DIAGEXIT            No  => Then Bypass Print Output
DIAG2300 DS    0H
         BRAS  R14,DIAGP100        Print 1st Header Line to LGRECOUT
DIAG2400 DS    0H
         MVI   DIALINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DIALINE+1(L'DIALINE-1),DIALINE ...Propogate the Blank
         MVI   DIACCNTL,C' '       Set Carriage Control to Single Space
         MVC   DIAOLINE(L'HEADER05),HEADER05 Hdr for Proceeding Backwrd
         LTGR  RLGW,RLGW           Verify If We Have a LGRWK2II Area?
         BRZ   DIAG2600            No  => Then Bypass Print Output
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DIAGEXIT            No  => Then Bypass Print Output
DIAG2500 DS    0H
         BRAS  R14,DIAGP100        Print 2nd Header Line to //LGRECOUT
DIAG2600 DS    0H
         BRU   DIAG3000            Branch to Process Save Area Chain
*
*+-------------------------------------------------------------------+*
*| Analyze the save area chain by proceeding backward from the last  |*
*| save area until we reach the TCB first save area. Check for valid |*
*| save area chain pointers before processing the save area. After   |*
*| processing a save area, then loop to process the next save area.  |*
*|                                                                   |*
*| For example:                                                      |*
*|                                                                   |*
*| Called Program Entry Point..: USRTEST7.TGMT0000+(000000)  20100308|*
*|       TGMT0000 Csect Address: 0000000001031958                    |*
*|       TGMT0000 Csect Length.: 00000A18                            |*
*| Called Program Returns To...: USRTEST7.TRDT0000+(0008C2)  20100308|*
*| Calling Program Save Area...: 0000000000011698                    |*
*| Calling Program General Purpose Registers R0-R15 at Entry to Calle|*
*|   0-3   0000000000011920  0000000000032028  00000000010337FC  0000|*
*|   4-7   0000000000010890  00000000000108E9  0000000081030CEC  0000|*
*|   8-11  0000000001033600  0000000000033000  0000000000032000  0000|*
*|   12-15 0000000001030548  0000000000011698  0000000081030DFA  0000|*
*+-------------------------------------------------------------------+*
*
DIAG3000 DS    0H
         LTGR  RPCC,RPCC           Is There an Available Save Area?
         BRNZ  DIAG3200            Yes => Get Previous Save Area Addr
         LLGT  RPCC,LGWFSA         No  => Get First Save Area Address
DIAG3100 DS    0H
         LA    R1,DIAG3300         Get Retry Recovery Address (ESPIE)
         ST    R1,LGWRETRY         Preserve It In Case of an Abend
         LG    R14,LCAF64FWD-LCASAVE(,RPCC) Get Next Save Area Address
         XC    LGWRETRY,LGWRETRY   Disable Recovery, Area Referenced
         LTGR  R14,R14             Is There Another Save Area Address?
         BRZ   DIAG5100            No  => Then Check for End of Chain
         LLGFR RPCC,R14            Yes => Then Get the Next Save Area
         BRU   DIAG3100            Loop to Process Next Save Area
DIAG3200 DS    0H
         CLC   LCAF64F4A-LCASAVE(L'LCAF64F4A,RPCC),=CL4'F4SA' Format 4?
         BRE   DIAG5000            Yes => Process Previous Save Area
         CLC   LCAS64F5A-LCASAVE(L'LCAS64F5A,RPCC),=CL4'F5SA' Format 5?
         BRE   DIAG6000            Yes => Process Previous Save Area
         LA    R1,DIAG3300         Get Retry Recovery Address (ESPIE)
         ST    R1,LGWRETRY         Preserve It In Case of an Abend
         LLGT  R1,LCASA_BCK-LCASAVE(,RPCC) Check If a Previous Savearea
         XC    LGWRETRY,LGWRETRY   Disable Recovery, Area Referenced
         CLM   RPCC,B'1111',LCASA_FWD-LCASAVE(R1) Forwrd Pointer Match?
         BRE   DIAG4000            Yes => Branch to Process Save Area
DIAG3300 DS    0H
         XC    LGWRETRY,LGWRETRY   Clear to Disable Abend Recovery
         CLGF  RPCC,LGWFSA         Is This the TCB First Save Area?
         BRE   DIAG7000            Yes => Done Processing Save Areas
DIAG3400 DS    0H
         MVI   DIALINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DIALINE+1(L'DIALINE-1),DIALINE ...Propogate the Blank
         MVI   DIACCNTL,C' '       Set Carriage Control to Single Space
         MVC   DIAOLINE(L'HEADER06),HEADER06 Hdr for Invalid Back Chain
         LTGR  RLGW,RLGW           Verify If We Have a LGRWK2II Area?
         BRZ   DIAG3600            No  => Then Bypass Print Output
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DIAGEXIT            No  => Then Bypass Print Output
DIAG3500 DS    0H
         BRAS  R14,DIAGP100        Print the Header Line to //LGRECOUT
DIAG3600 DS    0H
         BRU   DIAG7000            Done With Processing Save Area Chain
*
*+-------------------------------------------------------------------+*
*|           Perform Processing for a Standard Save Area             |*
*+-------------------------------------------------------------------+*
*
DIAG4000 DS    0H
         LGR   RPCC,R1             Restore This Previous Save Area
         XC    DIAPLIST,DIAPLIST   Clear the Call Parameter List
         CALL  DSTD0000,           Process Standard Save Area(Format-1)X
               ((RSDW),            ..Pass SDWA Area Address            X
               (RLGW),             ..Pass LGRWK2II Area Address        X
               (RCOMM),            ..Pass Common Constants&Routines    X
               (RPCC)),            ..Pass Calling Program's Save Area  X
               PLIST8=YES,         ..Indicate the Parameter List FormatX
               LINKINST=LGR,       ..Indicate the Link Instruction TypeX
               MF=(E,DIAPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Process SaveArea for Diagnostic Info
         LTGFR R15,R15             Was Save Area Processing Successful?
         BRZ   DIAG4100            Yes => Branch to Process SA Chain
         LGHI  R2,((DIAG4200-DIAG4100)-4) ...Length of Branch Table
         CGFR  R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   DIAG4100            No  => Branch to Process SA Chain
         BRU   DIAG7000            Yes => Branch to Exit This Routine
DIAG4100 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   DIAG4200            Save Area Processing Completed
         BRU   DIAG4200            Branch on Warning-Ignore & Continue
         BRU   DIAG7000            Branch on Processing Error - Exit
         BRU   DIAG7000            Branch on Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*|             Loop Point to Process the Next Save Area              |*
*+-------------------------------------------------------------------+*
*
DIAG4200 DS    0H
         BRU   DIAG3000            Loop to Process Save Area Chain
*
*+-------------------------------------------------------------------+*
*|       Perform Processing for a Format-4 Extended Save Area        |*
*+-------------------------------------------------------------------+*
*
DIAG5000 DS    0H
         LG    RPCC,LCAF64BCK-LCASAVE(,RPCC) Get Previous SaveArea Addr
DIAG5100 DS    0H
         LTGR  RPCC,RPCC           Is This The End of Save Area Chain?
         BRZ   DIAG7000            Yes => Done, Branch to Exit Routine
DIAG5200 DS    0H
         XC    DIAPLIST,DIAPLIST   Clear the Call Parameter List
         CALL  DEXS0000,           Process Format-4 Extended Save Area X
               ((RSDW),            ..Pass SDWA Area Address            X
               (RLGW),             ..Pass LGRWK2II Area Address        X
               (RCOMM),            ..Pass Common Constants&Routines    X
               (RPCC)),            ..Pass Calling Program's Save Area  X
               PLIST8=YES,         ..Indicate the Parameter List FormatX
               LINKINST=LGR,       ..Indicate the Link Instruction TypeX
               MF=(E,DIAPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Process SaveArea for Diagnostic Info
         LTGFR R15,R15             Was Save Area Processing Successful?
         BRZ   DIAG5300            Yes => Branch to Process SA Chain
         LGHI  R2,((DIAG5400-DIAG5300)-4) ...Length of Branch Table
         CGFR  R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   DIAG5300            No  => Branch to Process SA Chain
         BRU   DIAG7000            Yes => Branch to Exit This Routine
DIAG5300 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   DIAG5400            Save Area Processing Completed
         BRU   DIAG5400            Branch on Warning-Ignore & Continue
         BRU   DIAG7000            Branch on Processing Error - Exit
         BRU   DIAG7000            Branch on Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*|             Loop Point to Process the Next Save Area              |*
*+-------------------------------------------------------------------+*
*
DIAG5400 DS    0H
         BRU   DIAG3000            Loop to Process Save Area Chain
*
*+-------------------------------------------------------------------+*
*|       Perform Processing for a Format-5 Extended Save Area        |*
*+-------------------------------------------------------------------+*
*
DIAG6000 DS    0H
         LG    RPCC,LCAF64BCK-LCASAVE(,RPCC) Get Previous SaveArea Addr
         XC    DIAPLIST,DIAPLIST   Clear the Call Parameter List
         CALL  D5XS0000,           Process Format-5 Extended Save Area X
               ((RSDW),            ..Pass SDWA Area Address            X
               (RLGW),             ..Pass LGRWK2II Area Address        X
               (RCOMM),            ..Pass Common Constants&Routines    X
               (RPCC)),            ..Pass Calling Program's Save Area  X
               PLIST8=YES,         ..Indicate the Parameter List FormatX
               LINKINST=LGR,       ..Indicate the Link Instruction TypeX
               MF=(E,DIAPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Process SaveArea for Diagnostic Info
         LTGFR R15,R15             Was Save Area Processing Successful?
         BRZ   DIAG6100            Yes => Branch to Process SA Chain
         LGHI  R2,((DIAG7000-DIAG6100)-4) ...Length of Branch Table
         CGFR  R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   DIAG6100            No  => Branch to Process SA Chain
         BRU   DIAG7000            Yes => Branch to Exit This Routine
DIAG6100 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   DIAG6200            Save Area Processing Completed
         BRU   DIAG6200            Branch on Warning-Ignore & Continue
         BRU   DIAG7000            Branch on Processing Error - Exit
         BRU   DIAG7000            Branch on Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*|             Loop Point to Process the Next Save Area              |*
*+-------------------------------------------------------------------+*
*
DIAG6200 DS    0H
         BRU   DIAG3000            Loop to Process Save Area Chain
*
*+-------------------------------------------------------------------+*
*|    End of the Save Area Chain                                     |*
*+-------------------------------------------------------------------+*
*
DIAG7000 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Was the Logging LGRECOUT DCB Open?
         BRZ   DIAGEXIT            No  => Branch To Exit This Routine
         MVC   DIAOLINE(L'DIALINE1),DIALINE1 ..Statement for Output DCB
         MVC   DIAWTOMG(COMWTOL),COMWTO .Fill WTO Remote Parameter List
         MVC   DIAMSGTX,DIAOLINE   Copy the Message to WTO Buffer Area
         MVC   DIAMSG,=Y(L'DIAMSGTX) ..Indicate Length of Text Message
DIAG7100 DS    0H
         LA    R4,DIAMSG           Obtain Address of Message Text Area
         WTO   TEXT=(R4),          Tracing Info in DD to MVS Console   X
               MF=(E,DIAWTOMG)     Remote Program Parameter List
DIAG7200 DS    0H
         MVI   DIALINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DIALINE+1(L'DIALINE-1),DIALINE ...Propogate the Blank
         LTGR  RLGW,RLGW           Verify If We Have a LGRWK2II Area?
         BRZ   DIAGEXIT            No  => Then Bypass Print Output
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DIAGEXIT            No  => Then Bypass Print Output
         BRAS  R14,DIAGP100        Put Blank Separator Line to LGRECOUT
*
*+-------------------------------------------------------------------+*
*|   Return to Caller                                                |*
*+-------------------------------------------------------------------+*
*
DIAGEXIT DS    0H
         SLGR  R15,R15             Indicate Successful Completion
         ST    R15,DIARETCD        Set the Return Code
         LPGMEXIT RC=DIARETCD      Define Program Exit Protocol
*
*+-------------------------------------------------------------------+*
*|         P r i n t   O u t p u t   D e t a i l   L i n e           |*
*+-------------------------------------------------------------------+*
*|SUBROUTINE NAME: DIAGP100                                          |*
*|FUNCTION.......: Print Detail Line to Output Logger Data Set       |*
*+-------------------------------------------------------------------+*
*
DIAGP100 LPGMSUBE                  Set Subroutine Entry Protocol
         SYSSTATE AMODE64=NO,ARCHLVL=2 Generate Code for Not in AMODE64
         SAM31                     Switch Now to 31-Bit Addressing Mode
         PUT   LGWODCB,DIALINE     Print Output Line to //LGRECOUT
         SAM64                     Switch Back to 64-Bit Address Mode
         SYSSTATE AMODE64=YES,ARCHLVL=2    Restore 64-Bit Environment
         LPGMSUBX                  Return to Caller of This Subroutine
*
*+-------------------------------------------------------------------+*
*|   Definition for Constants                                        |*
*+-------------------------------------------------------------------+*
*
DIALINE1 DC    CL132'Program logging was implemented. Refer to the //LGX
               RECOUT DD.'
*
*+-------------------------------------------------------------------+*
*|    Program RENT Work Area                                         |*
*+-------------------------------------------------------------------+*
*
         LCA   DEFINE              Define the Program RENT Work Area
*
DIAWORKD DS    10D                 General Purpose Work Area
DIAPLIST DS    20FD                CALL Parameter List
DIAF4SAV DS    XL(LCAF64SZE)       Area to Build Format-4 Save Area
DIARETCD DS    F                   Save Area for the Return Code
         DS    0D                  Set For Doubleword Alignment
DIAWTOMG DS    0D,XL(COMWTOL)      Area for WTO Macro List Form
         DS    0F
DIAMSG   DS    H                   Length of Message Text
DIAMSGTX DS    CL80                Text of Message
DIALINE  DS    0CL133              Output Print Line Area
DIACCNTL DS    CL1                 Carriage Control Character
DIAOLINE DS    CL132               Output Record Print Area
*
         LCA   DEFEND              Define End of Program RENT Work Area
*
***********************************************************************
*           End of Print Diagnostic Information Processing            *
***********************************************************************
         EJECT ,
***********************************************************************
**************************+-----------------+**************************
**************************| D S W A 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*| P r o c e s s  S y s t e m  D i a g n o s t i c  W o r k  A r e a |*
*+-------------------------------------------------------------------+*
* PROGRAM NAME:    DSWA0000                                           *
*                                                                     *
* FUNCTION:        Process Diagnostic Information from SDWA           *
*                                                                     *
*                  This routine is responsible for performing the     *
*                  analysis of abend information for the user program *
*                  from the z/OS System Diagnostic Work Area (SDWA)   *
*                  Control Block, and printing diagnostic information *
*                  based on the contents of the SDWA.                 *
*                                                                     *
*For example:                                                         *
*                                                                     *
*                         ******************************              *
*                         *      Program Abended       *              *
*                         ******************************              *
*Completion Code      System = 0C4      Reason = 00000011             *
*Abend caused by program interrupt from page-translation exception: (P*
*                                                                     *
*-Abend Summary-                                                      *
*                                                                     *
*Abend Code.................: System=0C4   Reason=00000011            *
*Abend Location.............: USRTEST7.TRDT0000+(0005A2)  20110605 07.*
*Program Status Word........: 078D2000 B27039DA  (EC)                 *
*zArch Program Status Word..: 07852000 80000000 00000000 327039DA     *
*Data Around PSW............: 327039D4 ==> CD805830 CD3CBE17 300047F0 *
*Breaking Event Address.....: 00000000327039BC at USRTEST7.TRDT0000+(0*
*Abending Instruction Length: 4 bytes                                 *
*CPU State..................: Problem State (Only unprivileged instruc*
*Program Status Word Key....: 8  (The access key used for storage refe*
*Addressing Mode............: 31 (Program was in 31-bit addressing mod*
*Condition Code in PSW......: 2  (Result of last executed instruction *
*Address Space Control Mode.: Primary-space                           *
*                                                                     *
*                                                                     *
* INPUT REGS:      R1 => Standard O/S Parameter List                  *
*                                                                     *
* INPUT DATA:      Parm1: Addr of Abending Program's LCA Area         *
*                  Parm2: Addr of System Diagnostic Work Area         *
*                  Parm3: Addr of LGRWK2II Logger Work Area           *
*                  Parm4: Addr of Common Constants and Routines Area  *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY, AC=0                          *
*                                                                     *
* CALLING PROGRAM: DIAG0000 - Process Abend Diagnostic Report Program *
*                                                                     *
* CALLED PROGRAMS: LNME0000 - Logger Services Program to Resolve an   *
*                             Address to a Load Module Name           *
*                  DABN0000 - Logger Services Program to Resolve an   *
*                             Address to the Abending Instruction     *
*                  DIVC0000 - Logger Services Program to Process the  *
*                             Instructions in Vicinity of Abend       *
*                  DREG0000 - Logger Services Program to Process      *
*                             General Purpose Registers               *
*                  DRBT0000 - Logger Services Program to Process      *
*                             Request Block for Last Interrupt        *
*                  DBRK0000 - Logger Services Program to Process      *
*                             Breaking Event Address                  *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                  04 - Warning                                       *
*                  08 - Error                                         *
*                  12 - Severe Error - Exit This Routine              *
*                                                                     *
***********************************************************************
*
DSWA0000 LPGMNTRY TYPE=SUB,        Define As A Sub-Program Entry       X
               BASE=(12,11),       Establish Base Registers            X
               AMOD=64,RMOD=ANY,   Addressing and Residency Modes      X
               LCAPFX=DWA,         Establish LCA Prefix for This RSECT X
               LOG=OFF,            Always Turn Logging 'Off' in Logger!X
               LINKRTRN=BSM,       Define Return Linkage Instruction   X
               COPY@RT=YES         To Generate a Copyright Statement
         USING COM_DATA,RCOMM      Addressability to Common Data Area
         USING LGRWK2II,RLGW       Establish Addressability to LGRWK2II
         USING SDWA,RSDW           Establish Addressability to SDWA
         USING IHADCB,LGWODCB      Establish Addressability to DCB
LMOD     USING LRTLMBLK,DWALMODI   Establish Addressability to LMODI
         LMG   R7,R10,0(R1)        Load the Parameter Area Addresses
         XC    DWARETCD,DWARETCD   Initialize the Return Code
*
*+-------------------------------------------------------------------+*
*|    Get the Address of the Failing Instruction                     |*
*+-------------------------------------------------------------------+*
*
DSWA0100 DS    0H
         MVC   DWAPSW,SDWACTL1     Basic Control Mode Pgm Status Word
         MVC   DWAPSWTP,=C'(BC)'   Indicate for Basic Control Mode
         MVC   DWAILC,SDWAPMKA     Get the SDWA Binary Program Mask
         NI    DWAILC,SDWAILA      Obtain Instruction Length Code Value
         LLGF  R5,SDWAPMKA         Addr of Next Instruction to Execute
         N     R5,=A(X'00FFFFFF')  Set the Address for 24-Bit Mode
         OC    SDWAEC1,SDWAEC1     Is There Extended Control Mode PSW?
         BRZ   DSWA0300            No  => Determine Failing Instruction
DSWA0200 DS    0H
         MVC   DWAPSW,SDWAEC1      Extended Control Mode Pgm Status Wrd
         MVC   DWAPSWTP,=C'(EC)'   Indicate for Extended Control Mode
         MVC   DWAILC,SDWAILC1     Get the SDWA Binary Program Mask
         NI    DWAILC,SDWAIL1      Obtain Instruction Length Code Value
         LLGT  R5,SDWANXT1         Addr of Next Instruction to Execute
DSWA0300 DS    0H
         LGR   R2,R5               Hold PSW Address at Entry to Abend
         LLGC  R1,SDWAILC1         Get the Instruction Length Code
         CLI   SDWAICD1,X'10'      A Segment-Translation Exception?
         BRE   DSWA0500            Yes => PSW on Abending Instruction
         CLI   SDWAICD1,X'11'      This a Page-Translation Exception?
         BRE   DSWA0500            Yes => PSW on Abending Instruction
         CLI   SDWAICD1,X'29'      This an ALEN-translation Exception?
         BRE   DSWA0500            Yes => PSW on Abending Instruction
         CLI   SDWAICD1,X'38'      This an ASCE-type exception?
         BRE   DSWA0500            Yes => PSW on Abending Instruction
         CLI   SDWAICD1,X'39'      Region-First-Translation Exception?
         BRE   DSWA0500            Yes => PSW on Abending Instruction
         CLI   SDWAICD1,X'3A'      Region-Second-Translation Exception?
         BRE   DSWA0500            Yes => PSW on Abending Instruction
         CLI   SDWAICD1,X'3B'      Region-Third-Translation Exception?
         BRE   DSWA0500            Yes => PSW on Abending Instruction
         CLI   SDWAICD1,X'06'      This a Specification Exception?
         BRNE  DSWA0400            No  => Then Branch to Use the ILC
         NILL  R2,X'0001'          Odd Address on an Instruction Fetch?
         BRNZ  DSWA0500            Yes => Then Using ILC Unpredictable
DSWA0400 DS    0H
         SLGFR R5,R1               Back up to the Abending Instruction
DSWA0500 DS    0H
         STG   R5,DWABEND@         Save Address of Abending Instruction
*
*+-------------------------------------------------------------------+*
*| From the Failing Instruction Address Determine the Abending Load  |*
*| Module/Csect Name and Displacement.                               |*
*+-------------------------------------------------------------------+*
*
DSWA0600 DS    0H
         LLGFR RPCC,PLCA           Our Abending Program's LCA Address
         XC    DWAPLIST,DWAPLIST   Clear the Call Parameter List
         CALL  LNME0000,           Process Storage Address for Mod NameX
               ((R5),              ..Pass Storage Addr to Be Resolved  X
               (RPCC),             ..Pass Abending Programs's LCA Addr X
               DWALMODI,           ..Pass Addr of Load Module Info AreaX
               (RSDW),             ..Pass SDWA Area Address            X
               (RLGW),             ..Pass LGRWK2II Area Address        X
               (RCOMM)),           ..Pass Common Constants&Routines    X
               PLIST8=YES,         ..Indicate the Parameter List FormatX
               LINKINST=LGR,       ..Indicate the Link Instruction TypeX
               MF=(E,DWAPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Process Address for Load Module Name
         LTGFR R15,R15             Resolve Addr Processing Successful?
         BRZ   DSWA0700            Yes => Branch to Process Detail Line
         LGHI  R2,((DSWA1000-DSWA0700)-4) ...Length of Branch Table
         CGFR  R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   DSWA0700            No  => Branch to Process Line Header
         BRU   DSWAEXIT            Yes => Branch to Exit This Routine
DSWA0700 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   DSWA1000            Addr Process Completed, Process Hdr
         BRU   DSWA1000            Branch on Warning-Ignore & Continue
         BRU   DSWAEXIT            Branch on Processing Error - Exit
         BRU   DSWAEXIT            Branch on Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*| Format And Print Completion Code and Reason Code                  |*
*|                                                                   |*
*| For Example:                                                      |*
*|                                                                   |*
*|   Completion Code      System = 0C1      Reason = 00000001        |*
*+-------------------------------------------------------------------+*
*
DSWA1000 DS    0H
         MVC   DWACMPCD,SDWACMPC   Save the System Completion Code
         SLGR  R14,R14             Clear for Use as a Work Register
         SLGR  R15,R15             Clear for Use as a Work Register
         ICM   R14,B'0111',DWACMPCD ...Get the System Completion Code
         SRDL  R14,12              Separate the System & User Codes
         LTGR  R14,R14             Is This a System Completion Code?
         BRZ   DSWA1200            No  => Then a User Completion Code
DSWA1100 DS    0H
         ST    R14,DWAWORKF        Save the System Completion Code
         UNPK  DWAWORKD(5),DWAWORKF+2(3) .Convert Value in Hex to Zoned
         TR    DWAWORKD(4),HEXCONV-C'0'  ...Translate Hex to Character
         MVC   DWASYSCD,DWAWORKD+1 Save the System Completion Code
         BRU   DSWA1300            Branch to Process Completion Code
DSWA1200 DS    0H
         SRL   R15,20              User Cmpl Code in Low Order Bytes
         CVD   R15,DWAWORKD        User Completion Code to Decimal
         UNPK  DWAWORKD(5),DWAWORKD+5(3) ...Get Value in Zoned Format
         OI    DWAWORKD+4,X'F0'    Certify Sign to Make It Printable
         MVC   DWAUSRCD,DWAWORKD+1 Save the User Completion Code
DSWA1300 DS    0H
         MVI   DWALINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DWALINE+1(L'DWALINE-1),DWALINE ...Propogate the Blank
         LA    R2,DWAOLINE         Get Starting Address to Print Line
         MVC   0(15,R2),=CL15'Completion Code' Show the Completion Code
         LA    R2,21(,R2)          Increment to Completion Code Field
         SLGR  R4,R4               For Insert of System Completion Code
         ICM   R4,B'0111',DWASYSCD Do We have a System Completion Code
         BRZ   DSWA1400            No  => Check If User Completion Code
         MVC   0(8,R2),=CL8'System =' Set the System Code Header
         LA    R2,9(,R2)           Increment to Completion Code Field
         STCM  R4,B'0111',0(R2)    System Completion Code to Print Line
         LA    R2,9(,R2)           Increment to Reason Code Field
         BRU   DSWA1500            Branch to Process the Reason Code
DSWA1400 DS    0H
         ICM   R4,B'0111',DWAUSRCD Do We have a User Completion Code
         BRZ   DSWA4000            No  => Process Abend Summary Section
         MVC   0(6,R2),=CL6'User =' Set the User Completion Code Header
         LA    R2,7(,R2)           Increment to Completion Code Field
         STCM  R4,B'0111',0(R2)    User Completion Code to Print Line
         LA    R2,9(,R2)           Increment to Reason Code Field
DSWA1500 DS    0H
         MVC   0(17,R2),=CL17'Reason = 00000000'  Assume No Reason Code
         MVC   DWARSNCD,=CL8'00000000'  No Abending Program Reason Code
         TM    SDWACMPF,SDWARCF    Do We Have a Valid Reason Code?
         BRZ   DSWA1600            No  => Do Not Attempt to Process One
         LLGT  R5,SDWAXPAD         Addr of SDWA Extension Pointers Area
         ICM   R5,B'1111',SDWASRVP-SDWAPTRS(R5) Adr SDWA 1st Extension?
         BRZ   DSWA1600            No  => Branch to Process Abend Line
         LA    R2,9(,R2)           Increment to the Reason Code Field
         MVC   DWAWORKD(L'SDWACRC),SDWACRC-SDWARC1(R5) .Get Reason Code
         UNPK  DWAWRK09,DWAWORKD(5) Convert Reason Code in Hex to Zoned
         TR    DWAWRK09(L'DWAWRK09-1),HEXCONV-C'0'  ...Hex to Character
         MVC   DWARSNCD,DWAWRK09   Save Abending Program Reason Code
         MVC   0(L'DWAWRK09-1,R2),DWAWRK09 ...Reason Code to Print Line
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DSWAEXIT            No  => Then Bypass Print Output
DSWA1600 DS    0H
         BRAS  R14,DSWAP100        Completion Code Line to //LGRECOUT
         MVI   DWALINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DWALINE+1(L'DWALINE-1),DWALINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*| Format And Print Program Interrupt Code Description               |*
*|                                                                   |*
*| For Example:                                                      |*
*|                                                                   |*
*|Abend caused by program interrupt from operation exception: (PIC 01|*
*+-------------------------------------------------------------------+*
*
         USING PIC@NTRY,R5         Establish Addessability to PIC Table
DSWA2000 DS    0H
         TM    SDWAERRA,SDWAPCHK   Is Abend from a Program Interrupt?
         BRZ   DSWA4000            No  => Process Abend Summary Section
         LLGC  R0,SDWAICD1         Get Interrupt Code on Program Check
         LLGT  R5,=A(PICTNTRY)     Address of the PIC Description Table
         LA    R14,L'PICTNTRY      Length of Each PIC Description Entry
         LLGF  R15,=A(PICTNTRY+((PIC#NTRY*L'PICTNTRY)-L'PICTNTRY))
DSWA2100 DS    0H
         CH    R0,PIC@KEY          Is This Our Program Interrupt Code?
         BRE   DSWA2200            Yes => Branch to Set PIC Description
         BRXLG R5,R14,DSWA2100     No  => Loop to Check Next PIC Entry
         BRU   DSWAEXIT            Not Found, Branch to Exit Routine
DSWA2200 DS    0H
         LLGT  R2,=A(PICDESHD)     Address of the PIC Description Table
         MVC   DWAOLINE(L'PICDESHD),0(R2) ...Copy the Header Statement
         MVC   DWAOLINE+L'PICDESHD(L'PIC$EXCP),PIC$EXCP  PIC Descriptor
         LA    R3,DWAOLINE         Set Pointer to Start of Work Area
         LA    R2,DWAOLINE+L'DWAOLINE-1 Address of Where End of Area
         LLGC  R0,=X'7A'           Look for Colon Delimiter Character
DSWA2300 DS    0H
         SRST  R2,R3               Find Delimiter Which Separates Data
         BRO   DSWA2300            Otherwise, Resume Where We Left Off
         BRH   DSWA2500            Did Not Find a Delimiter in Area
DSWA2400 DS    0H
         LA    R2,2(,R2)           Increment Past the Delimiter
         MVC   0(4,R2),=CL4'(PIC'  Set Descriptor for Indicated PIC
         LA    R2,5(,R2)           Increment Past the Descriptor
         UNPK  DWAWRK09,PIC@KEY(L'PIC@KEY+1)  PIC Value in Hex to Zoned
         TR    DWAWRK09(L'DWAWRK09-1),HEXCONV-C'0'  ...Hex to Character
         MVC   0(2,R2),DWAWRK09+6  Copy the PIC Value to Output Line
         MVI   2(R2),C')'          Set the Closing Parenthesis
DSWA2500 DS    0H
         MVC   DWAWTOMG(COMWTOL),COMWTO .Fill WTO Remote Parameter List
         MVC   DWAMSGTX,DWAOLINE   Copy the Message to WTO Buffer Area
         MVC   DWAMSG,=Y(L'DWAMSGTX) ..Indicate Length of Text Message
DSWA2600 DS    0H
         LA    R4,DWAMSG           Obtain Address of Message Text Area
         WTO   TEXT=(R4),          Write PIC Description to MVS ConsoleX
               MF=(E,DWAWTOMG)     Remote Program Parameter List
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DSWAEXIT            No  => Then Bypass Print Output
DSWA2700 DS    0H
         BRAS  R14,DSWAP100        Write PIC Description to //LGRECOUT
*
*+-------------------------------------------------------------------+*
*| Check the Program Interruption Code Description Table for Our     |*
*| Abend, and Format And Print Program Interrupt Reasons for Abend.  |*
*|                                                                   |*
*| For Example:                                                      |*
*|                                                                   |*
*| The following are some possible reasons for abend:                |*
*|  -Invalid branch to a data area resulted in attempt to execute dat|*
*|  -An area in your program with valid instructions was overlaid and|*
*|  -Incorrect entry point or module name was used in call to another|*
*|  -There was an attempt to access a data set which was not opened. |*
*|  -Attempt read after EOF, close data set twice without intervening|*
*|  -There was a missing DDname in your JCL or DDname incorrect or DD|*
*|  -Attempt to execute an instruction requiring a hardware feature o|*
*+-------------------------------------------------------------------+*
*
DSWA3000 DS    0H
         MVI   DWALINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DWALINE+1(L'DWALINE-1),DWALINE ...Propogate the Blank
         LLGT  R3,PIC@DESC         Pointer to PIC Reason Descriptions
         LTGR  R3,R3               There Any Reasons for Abend on PIC?
         BRNZ  DSWA3200            Yes => Then Process Abnd Reason List
DSWA3100 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DSWAEXIT            No  => Then Bypass Print Output
         BRAS  R14,DSWAP100        Print a Blank Separator Line
         BRU   DSWA4000            Branch to Process the Abend Summary
DSWA3200 DS    0H
         LLGT  R2,=A(PICABND$)     Address of the Abend Reason Hdr Line
         MVC   DWAOLINE+1(L'PICABND$),0(R2) ..Copy the Header Statement
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DSWAEXIT            No  => Then Bypass Print Output
         BRAS  R14,DSWAP100        Print the Abend Reason to LGRECOUT
DSWA3300 DS    0H
         MVI   DWALINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DWALINE+1(L'DWALINE-1),DWALINE ...Propogate the Blank
         LGH   R4,PIC@DESL         Count of No. of Abend Reasons Listed
         SAM31                     Switch Now to 31-Bit Addressing Mode
DSWA3400 DS    0H
         MVI   DWAOLINE+1,C'-'     Prefix the Reason Line with Hyphen
         MVC   DWAOLINE+2(PICDESC),0(R3) ...Copy Interrupt Reason Line
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRO   DSWA3500            Yes => Then Print the Output Line
         SAM64                     Switch Back to 64-Bit Address Mode
         BRU   DSWAEXIT            No  => Then Bypass Print Output
DSWA3500 DS    0H
         SYSSTATE AMODE64=NO,ARCHLVL=2 Generate Code for Not in AMODE64
         PUT   LGWODCB,DWALINE     Print an Abend Reason Description
         SYSSTATE AMODE64=YES,ARCHLVL=2    Restore 64-Bit Environment
         LA    R3,PICDESC(,R3)     Increment to Next Abend Reason Line
         BRCTG R4,DSWA3400         Loop to Process Next Abend Reason
DSWA3600 DS    0H
         MVI   DWALINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DWALINE+1(L'DWALINE-1),DWALINE ...Propogate the Blank
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRO   DSWA3700            Yes => Then Print the Output Line
         SAM64                     Switch Back to 64-Bit Address Mode
         BRU   DSWAEXIT            No  => Then Bypass Print Output
DSWA3700 DS    0H
         SYSSTATE AMODE64=NO,ARCHLVL=2 Generate Code for Not in AMODE64
         PUT   LGWODCB,DWALINE     Print a Blank Separator Line
         SAM64                     Switch Back to 64-Bit Address Mode
         SYSSTATE AMODE64=YES,ARCHLVL=2    Restore 64-Bit Environment
*
*+-------------------------------------------------------------------+*
*| Process the Abend Summary Report. Begin by Printing the Header    |*
*| Line for the Abend Summary.                                       |*
*|                                                                   |*
*| -Abend Summary-                                                   |*
*+-------------------------------------------------------------------+*
*
DSWA4000 DS    0H
         MVI   DWALINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DWALINE+1(L'DWALINE-1),DWALINE ...Propogate the Blank
         MVC   DWAOLINE(L'DSWABSUM),DSWABSUM Header for Abend Summary
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DSWAEXIT            No  => Then Bypass Print Output
         BRAS  R14,DSWAP100        Print the Abend Summary Header Line
DSWA4100 DS    0H
         MVI   DWALINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DWALINE+1(L'DWALINE-1),DWALINE ...Propogate the Blank
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DSWAEXIT            No  => Then Bypass Print Output
DSWA4200 DS    0H
         BRAS  R14,DSWAP100        Print Blank Separator Line to Output
         MVI   DWALINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DWALINE+1(L'DWALINE-1),DWALINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*| Format And Print the Abend Code Detail Line                       |*
*|                                                                   |*
*| Abend Code.................: System=0C4   Reason=00000011         |*
*+-------------------------------------------------------------------+*
*
DSWA4300 DS    0H
         SLGR  R14,R14             Clear for Use as a Work Register
         SLGR  R15,R15             Clear for Use as a Work Register
         ICM   R14,B'0111',DWACMPCD ...Get the System Completion Code
         SRDL  R14,12              Separate the System & User Codes
         LTGR  R14,R14             Is This a System Completion Code?
         BRZ   DSWA4500            No  => Then a User Completion Code
DSWA4400 DS    0H
         MVC   DWAOLINE(DSWLNELN),DSWABNDC ...Statement for Abend Code
         LA    R1,DWAOLINE+DSWLNELN  Increment Past the Detail Header
         MVC   0(7,R1),=CL7'System=' Abend is a System Completion Code
         MVC   7(L'DWASYSCD,R1),DWASYSCD ...Copy System Completion Code
         LA    R2,13(,R1)          Increment to the Reason Code Field
         BRU   DSWA4600            Branch to Process Reason Code
DSWA4500 DS    0H
         MVC   DWAOLINE(DSWLNELN),DSWABNDC ...Statement for Abend Code
         LA    R1,DWAOLINE+DSWLNELN  Increment Past Detail Line Header
         MVC   0(5,R1),=CL5'User=' Abend is a User Completion Code
         MVC   5(L'DWAUSRCD,R1),DWAUSRCD ...Copy User Completion Code
         LA    R2,11(,R1)          Increment to the Reason Code Field
DSWA4600 DS    0H
         MVC   0(7,R2),=CL7'Reason=' Abending Program Reason Cde Header
         MVC   7(L'DWARSNCD,R2),DWARSNCD  Copy in the Abend Reason Code
         MVC   DWAMSGTX,DWAOLINE   Copy the Message to WTO Buffer Area
         MVC   DWAMSG,=Y(L'DWAMSGTX) ..Indicate Length of Text Message
         LA    R4,DWAMSG           Obtain Address of Message Text Area
         WTO   TEXT=(R4),          Write Abnd Cde Line to MVS Console  X
               MF=(E,DWAWTOMG)     Remote Program Parameter List
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DSWAEXIT            No  => Then Bypass Print Output
         BRAS  R14,DSWAP100        Print Abend Code Line to //LGRECOUT
*
*+-------------------------------------------------------------------+*
*| Format And Print the Abending Program Location Detail Line        |*
*|                                                                   |*
*| Abend Location.............: USRTEST7.TRDT0000+(0005A2)  20110605 |*
*+-------------------------------------------------------------------+*
*
DSWA5000 DS    0H
         MVI   DWALINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DWALINE+1(L'DWALINE-1),DWALINE ...Propogate the Blank
         MVC   DWAOLINE(DSWLNELN),DSWABLOC ...Header for Abend Location
         LA    R2,DWAOLINE+DSWLNELN  Increment Past Detail Line Header
         CLC   LMOD.LRTLMOD(8),=C'UNKNOWN ' Is Load Module Name Known?
         BRNE  DSWA5100            Yes => Then Load Mod Info to Process
         MVC   0(8,R2),LMOD.LRTLMOD ..Indicate Module Name is Not Known
         BRU   DSWA5400            Branch to Process Lmod Output Line
DSWA5100 DS    0H
         MVC   0(L'LRTPGMNM,R2),LMOD.LRTPGMNM ..Abending Module Name
DSWA5200 DS    0H
         CLI   0(R2),C' '          Is This The End of Load Module Name?
         BRE   DSWA5300            Yes => Branch to Process Version
         LA    R2,1(,R2)           Increment to the Next Character
         BRU   DSWA5200            Loop to Find the End of Module Name
DSWA5300 DS    0H
         LA    R2,1(,R2)           Increment Position for a Spacer Byte
         MVC   0(L'LRTVERSN/2,R2),LMOD.LRTVERSN Get Module Version Info
         MVC   DWAWTOMG(COMWTOL),COMWTO .Fill WTO Remote Parameter List
         MVC   DWAMSGTX,DWAOLINE   Copy the Message to WTO Buffer Area
         MVC   DWAMSG,=Y(L'DWAMSGTX) ..Indicate Length of Text Message
DSWA5400 DS    0H
         LA    R4,DWAMSG           Obtain Address of Message Text Area
         WTO   TEXT=(R4),          Write Abend Location to MVS Console X
               MF=(E,DWAWTOMG)     Remote Program Parameter List
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DSWAEXIT            No  => Then Bypass Print Output
         BRAS  R14,DSWAP100        Print Abend Location to //LGRECOUT
DSWA5500 DS    0H
         MVI   DWALINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DWALINE+1(L'DWALINE-1),DWALINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*| Format And Print Program Status Word (PSW) Detail Line            |*
*|                                                                   |*
*| Program Status Word........: 078D2000 B27039DA  (EC)              |*
*+-------------------------------------------------------------------+*
*
DSWA5600 DS    0H
         LLGT  R4,SDWAXPAD         Addr of SDWA Extension Pointers Area
         USING SDWAPTRS,R4         Addressability to Extension Ptr Area
         ICM   R4,B'1111',SDWAXEME Do We Have a Pointer to 64-bit Info?
         BRZ   DSWA5800            No  => Then Proceed as ESA/390 PSW
         USING SDWARC4,R4          Addressability to 64-bit Info Area
         LLGF  R2,SDWAPSW16+8      High-Half of 64 Bit-PSW Instruct Adr
         LTGFR R2,R2               Instruction Adr Greater than 31 Bit?
         BRZ   DSWA5800            No  => Process as ESA/390 Format PSW
DSWA5700 DS    0H
         LA    R2,DWAOLINE         Obtain the Address of Output Line
         MVC   DWAOLINE(DSWLNELN),DSWABPSW ..Header for Pgm Status Word
         MVC   DSWLNELN(L'DSWPSWNT,R2),DSWPSWNT Unusable ESA/390 Format
         MVC   DSWLNELN+L'DSWPSWNT+2(L'DWAPSWTP,R2),DWAPSWTP  Cntl Mode
         BRU   DSWA5900            No  => Process as ESA/390 Format PSW
         DROP  R4                  Remove Listed Reg as a SDWA Base Reg
DSWA5800 DS    0H
         MVC   DWAOLINE(DSWLNELN),DSWABPSW ..Header for Pgm Status Word
         LA    R2,DWAOLINE+DSWLNELN   Increment Past Detail Line Header
         UNPK  DWAWRK09,DWAPSW(5)  Convert PSW Value in Hex to Zoned
         TR    DWAWRK09(L'DWAWRK09-1),HEXCONV-C'0'  ...Hex to Character
         MVC   0(L'DWAWRK09-1,R2),DWAWRK09  Word One of Pgm Status Word
         UNPK  DWAWRK09,DWAPSW+4(5) ..Convert PSW Value in Hex to Zoned
         TR    DWAWRK09(L'DWAWRK09-1),HEXCONV-C'0'  ...Hex to Character
         MVC   L'DWAWRK09(L'DWAWRK09-1,R2),DWAWRK09 ... Word Two of PSW
         MVC   19(L'DWAPSWTP,R2),DWAPSWTP  Pgm Status Word Control Mode
DSWA5900 DS    0H
         MVC   DWAWTOMG(COMWTOL),COMWTO .Fill WTO Remote Parameter List
         MVC   DWAMSGTX,DWAOLINE   Copy the Message to WTO Buffer Area
         MVC   DWAMSG,=Y(L'DWAMSGTX) ..Indicate Length of Text Message
         LA    R4,DWAMSG           Obtain Address of Message Text Area
         WTO   TEXT=(R4),          Write PSW Info Line to MVS Console  X
               MF=(E,DWAWTOMG)     Remote Program Parameter List
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DSWAEXIT            No  => Then Bypass Print Output
DSWA6000 DS    0H
         BRAS  R14,DSWAP100        Prnt Program Status Word to LGRECOUT
         MVI   DWALINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DWALINE+1(L'DWALINE-1),DWALINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*| Format And Print the 128-bit z/Architecture Program Status Word   |*
*| (PSW) Detail Line.                                                |*
*|                                                                   |*
*| zArch Program Status Word..: 07852000 80000000 00000000 327039DA  |*
*+-------------------------------------------------------------------+*
*
DSWA6100 DS    0H
         LLGT  R4,SDWAXPAD         Addr of SDWA Extension Pointers Area
         USING SDWAPTRS,R4         Addressability to Extension Ptr Area
         ICM   R4,B'1111',SDWAXEME Do We Have a Pointer to 64-bit Info?
         BRZ   DSWA7000            No  => Then No info to Process
         USING SDWARC4,R4          Addressability to 64-bit Info Area
         LLGF  R2,SDWAPSW16        To Check First Word of the zArch PSW
         LTGFR R2,R2               Is z/Arch CPU State Info Available?
         BRZ   DSWA7000            No  => Then Bypass Processing of PSW
         TM    SDWAPSW16+1,X'08'   Is Bit 12 a Zero in the 16-byte PSW?
         BRNZ  DSWA7000            No  => Then Bypass Processing of PSW
DSWA6200 DS    0H
         LA    R2,DWAOLINE         Obtain the Address of Output Line
         MVC   DWAOLINE(DSWLNELN),DSWAZPSW ..Header for Pgm Status Word
         LA    R2,DSWLNELN(,R2)    Increment to 1st Field in Detail Lne
         UNPK  DWAWRK09,SDWAPSW16(5) Convert PSW1 Value in Hex to Zoned
         TR    DWAWRK09(L'DWAWRK09-1),HEXCONV-C'0'  ...Hex to Character
         MVC   0(L'DWAWRK09-1,R2),DWAWRK09  Word 1 of Prog Status Word
         UNPK  DWAWRK09,SDWAPSW16+4(5)   ...Convert PSW in Hex to Zoned
         TR    DWAWRK09(L'DWAWRK09-1),HEXCONV-C'0'  ...Hex to Character
         MVC   L'DWAWRK09(L'DWAWRK09-1,R2),DWAWRK09 ...Word 2 of PSW
         UNPK  DWAWRK09,SDWAPSW16+8(5)   ...Convert PSW in Hex to Zoned
         TR    DWAWRK09(L'DWAWRK09-1),HEXCONV-C'0'  ...Hex to Character
         MVC   2*L'DWAWRK09(L'DWAWRK09-1,R2),DWAWRK09 ...Word 3 of PSW
         UNPK  DWAWRK09,SDWAPSW16+12(5)  ...Convert PSW in Hex to Zoned
         TR    DWAWRK09(L'DWAWRK09-1),HEXCONV-C'0'  ...Hex to Character
         MVC   3*L'DWAWRK09(L'DWAWRK09-1,R2),DWAWRK09 ...Word 4 of PSW
         MVC   DWAWTOMG(COMWTOL),COMWTO .Fill WTO Remote Parameter List
         MVC   DWAMSGTX,DWAOLINE   Copy the Message to WTO Buffer Area
         MVC   DWAMSG,=Y(L'DWAMSGTX) ..Indicate Length of Text Message
DSWA6300 DS    0H
         LA    R4,DWAMSG           Obtain Address of Message Text Area
         WTO   TEXT=(R4),          Write PSW Info Line to MVS Console  X
               MF=(E,DWAWTOMG)     Remote Program Parameter List
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DSWAEXIT            No  => Then Bypass Print Output
         BRAS  R14,DSWAP100        Print the zArch Program Status Word
DSWA6400 DS    0H
         MVI   DWALINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DWALINE+1(L'DWALINE-1),DWALINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*| Format And Print the Detail Line for Data Around PSW. This Data   |*
*| Represents the 12 Bytes of Instructions or Data Around the PSW    |*
*| Address at the Time of Program Failure. The Instruction Stream    |*
*| to be Displayed Will Be the 6 Bytes Before and the 6 Bytes After  |*
*| the Actual Address in the PSW at Time of Failure.                 |*
*|                                                                   |*
*| Data Around PSW............: 327039D4 ==> CD805830 CD3CBE17 300047|*
*+-------------------------------------------------------------------+*
*
DSWA7000 DS    0H
         LLGT  R4,SDWAXPAD         Addr of SDWA Extension Pointers Area
         ICM   R4,B'1111',SDWASRVP-SDWAPTRS(R4) Adr SDWA 1st Extension?
         BRZ   DSWA8000            No  => Branch to Process Break Event
DSWA7100 DS    0H
         LA    R4,SDWAFAIN-SDWARC1(,R4)  Addr Instruction Stream at PSW
         MVC   DWAPSWDT(L'SDWAFAIN),0(R4) Get the Data At Abend PSW Adr
         LLILL R0,(L'DWAPSWDT)     Get Leng for Data at PSW Input Area
         LA    R1,DWAPSWDT         Get Addr of Data at PSW Input Area
         LA    R2,DWAPSOUT         Get Addr of Data at PSW Output Area
         LA    R15,DWA$PWRK        Get Address of Data at PSW Work Area
DSWA7200 DS    0H
         LTGR  R3,R0               Any "Data at PSW" Bytes Remaining?
         BRNP  DSWA7400            No  => Branch to Process PSW Address
         CGHI  R3,(7)              Are Remaining Bytes More Than Seven?
         BRNH  DSWA7300            No  => Branch to Use Current Length
         LLILL R3,(7)              Yes => Set the Max Length to Process
DSWA7300 DS    0H
         LGR   R4,R3               Current Leng of Bytes (Data at PSW)
         SLLG  R4,R4,1 Bit         Multiply the Current Length by Two
         LGR   R5,R4               Expand Length for a Character Format
         SLLG  R5,R5,4 Bits        Char Len Shifted to 1st Len Position
         OGR   R5,R3               Put the Two Unpack Lengths Together
         UNPK  DWA$PWRK(0),0(0,R1) Indicated Target of the Execute
         EX    R5,*-6              Unpack "Data at PSW" to Work Area
         BCTGR R4,R0               Decrement Length for the Execute
         EX    R4,TRNSLATE         Translate Hex to Character Format
* trnslate tr   0(*-*,R15),hexconv-c'0' ...Commented Target of Execute
         MVC   0(0,R2),DWA$PWRK    Indicated Target of the Next Execute
         EX    R4,*-6              Copy Formatted Data to Output Area
         LA    R1,0(R3,R1)         Bump to Next Portion of Data at PSW
         LA    R2,1(R4,R2)         Increment to Next Area in Output
         SGR   R0,R3               Calculate Remaining Length in Data
         BRU   DSWA7200            Loop to Process Remaining PSW Data
DSWA7400 DS    0H
         LLGT  R1,DWAPSW+4         Get Addr in PSW at Time of Failure
         AGHI  R1,(-6)             6 Bytes Before Adr of PSW at Failure
         LTGR  R1,R1               Low Address or No Address Indicated?
         BRNP  DSWA8000            Yes => Branch to Process Break Event
         ST    R1,DWAWRK16         Save Adjusted PSW Addr to Work Area
         UNPK  DWAWRK09,DWAWRK16(5) ..Convert PSW Value in Hex to Zoned
         TR    DWAWRK09(L'DWAWRK09-1),HEXCONV-C'0'  ...Hex to Character
DSWA7500 DS    0H
         LA    R2,DWAOLINE         Obtain the Address of Output Line
         MVC   DWAOLINE(DSWLNELN),DSWDTPSW ..Header for Data Around PSW
         LA    R2,DSWLNELN(,R2)    Increment to 1st Field in Detail Lne
         MVC   0(L'DWAWRK09-1,R2),DWAWRK09 Addr 6 bytes Before PSW Addr
         MVC   L'DWAWRK09(3,R2),=CL3'==>' ..Action Arrow Points to Data
         LA    R2,L'DWAWRK09+4(,R2) ...Increment to Next Field in Line
         MVC   0(L'DWAPDATA,R2),DWAPSOUT    Copy Word 1 of Data at PSW
         MVC   L'DWAPDATA+1(L'DWAPDATA,R2),DWAPSOUT+8  Word 2 of Data
         MVC   2*L'DWAPDATA+2(L'DWAPDATA,R2),DWAPSOUT+16 Word 3 of Data
         MVC   DWAWTOMG(COMWTOL),COMWTO .Fill WTO Remote Parameter List
         MVC   DWAMSGTX,DWAOLINE   Copy the Message to WTO Buffer Area
         MVC   DWAMSG,=Y(L'DWAMSGTX) ..Indicate Length of Text Message
DSWA7600 DS    0H
         LA    R4,DWAMSG           Obtain Address of Message Text Area
         WTO   TEXT=(R4),          Write PSW Data Line to MVS Console  X
               MF=(E,DWAWTOMG)     Remote Program Parameter List
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DSWAEXIT            No  => Then Bypass Print Output
DSWA7700 DS    0H
         BRAS  R14,DSWAP100        Print the Data at PSW to //LGRECOUT
DSWA7800 DS    0H
         MVI   DWALINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DWALINE+1(L'DWALINE-1),DWALINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*|  Format And Print Breaking Event Address Detail Line              |*
*+-------------------------------------------------------------------+*
*|  Show the address of the last successful 'branch from' instruction|*
*|  as an aid for diagnosing errors caused by wild branches. What    |*
*|  this represents are calls made via BALR, BASR, BASSM, and so on. |*
*|  Unfortunately, you also get mode switches to/from 64-bit mode.   |*
*|  Since SDWARC4 is 336 bytes long in z/OS V1R6 and it is is 360    |*
*|  bytes long in z/OS V1R7 or higher+, and the SDWABEA field is     |*
*|  within those additional 24 bytes, you need to check if running   |*
*|  on z/OS 1.7 or later. Then you check for the presence of SDWARC4 |*
*|  to verify that SDWABEA is available for inspection. However, the |*
*|  SDWABEA will still be zeros even on z/OS V1R7 and higher if      |*
*|  running on older (pre-z9) hardware.                              |*
*|                                                                   |*
*|  If a BEA address is available, then as a further diagnostic aid  |*
*|  an attempt will be made to determine the Load Module/Csect name  |*
*|  and the offset within the module where the last successful       |*
*|  'branch from' instruction occurred, and display it in the abend  |*
*|  report.                                                          |*
*|                                                                   |*
*|  For example:                                                     |*
*|                                                                   |*
*|Breaking Event Address.....: 00000000327039BC at USRTEST7.TRDT0000+|*
*+-------------------------------------------------------------------+*
*
DSWA8000 DS    0H
         LLGT  R1,CVTPTR           Absolute Address of Pointer to CVT
         USING CVT,R1              Establish Addressability to CVT
         TM    CVTOSLV5,X'40'      At Least Level z/OS V1.7 (HBB7720)?
         BRZ   DSW10400            No  => Then Bypass Break Address
         DROP  R1                  Remove Listed Register as Base Reg
         LLGT  R4,SDWAXPAD         Addr of SDWA Extension Pointers Area
         USING SDWAPTRS,R4         Addressability to Extension Ptr Area
         ICM   R4,B'1111',SDWAXEME Do We Have a Pointer to 64-bit Info?
         BRZ   DSW10400            No  => Then No info to Process
         USING SDWARC4,R4          Addressability to 64-bit Info Area
         LG    R3,336(,R4)         Get 64-Bit Breaking Event Address
         STG   R3,DWABREAK         Breaking Event Address to Work Area
         LA    R3,DWABREAK         Point to Start of Break Event Field
         UNPK  DWAWRK16(9),0(5,R3) Obtain the High-Half of Addr Value
         UNPK  DWAWRK16+8(9),4(5,R3) Obtain the Low-Half of Addr Value
         TR    DWAWRK16,HEXCONV-C'0' Finalize Conversion to Zoned Char
         MVC   DWAOLINE(DSWLNELN),DSWBREKD ..Header for Breaking Event
         MVC   DWAOLINE+DSWLNELN(L'DWAWRK16),DWAWRK16 Break Event Addr
         MVC   DWAWTOMG(COMWTOL),COMWTO .Fill WTO Remote Parameter List
         MVC   DWAMSGTX,DWAOLINE   Copy the Message to WTO Buffer Area
         MVC   DWAMSG,=Y(L'DWAMSGTX) ..Indicate Length of Text Message
DSWA8100 DS    0H
         LA    R4,DWAMSG           Obtain Address of Message Text Area
         WTO   TEXT=(R4),          Write Brk Event Addr to MVS Console X
               MF=(E,DWAWTOMG)     Remote Program Parameter List
DSWA8200 DS    0H
         XC    DWALMODI,DWALMODI   Clear the Load Module Info Blk Area
         LG    R5,DWABREAK         Get the Breaking Event Address
         LTGR  R5,R5               Is There an Address at All?
         BRNZ  DSWA8300            Yes => Branch to Process the BEA
         LA    R2,DWAOLINE+DSWLNELN+L'DWAWRK16+1 Point Past BEA Address
         MVC   0(23,R2),=CL23'(Address not available)' .Indicate No BEA
         BRU   DSWA9000            Branch to Process the PSW Analysis
*
*+-------------------------------------------------------------------+*
*|  Determine the Load Module/Csect Name and the Offset Within the   |*
*|  Load Module Where the Last Successful 'Branch From' Instruction  |*
*|  Occurred.                                                        |*
*+-------------------------------------------------------------------+*
*
DSWA8300 DS    0H
         XC    DWAPLIST,DWAPLIST   Clear the Call Parameter List
         CALL  LNME0000,           Process BEA for a Load Module Name  X
               ((R5),              ..Pass the Breaking Event Address   X
               (RPCC),             ..Pass Abending Programs's LCA Addr X
               DWALMODI,           ..Pass Addr of Load Module Info AreaX
               (RSDW),             ..Pass SDWA Area Address            X
               (RLGW),             ..Pass LGRWK2II Area Address        X
               (RCOMM)),           ..Pass Common Constants&Routines    X
               PLIST8=YES,         ..Indicate the Parameter List FormatX
               LINKINST=LGR,       ..Indicate the Link Instruction TypeX
               MF=(E,DWAPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Process Address for Load Module Name
         LTGFR R15,R15             Resolve Addr Processing Successful?
         BRZ   DSWA8400            Yes => Branch to Process Detail Line
         LGHI  R2,((DSWA8500-DSWA8400)-4) ...Length of Branch Table
         CGFR  R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   DSWA8400            No  => Branch to Process Line Header
         BRU   DSWAEXIT            Yes => Branch to Exit This Routine
DSWA8400 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   DSWA8500            Addr Process Completed, Process Lne
         BRU   DSWA8500            Branch on Warning-Ignore & Continue
         BRU   DSWA8600            Branch to Print Remaining Line Data
         BRU   DSWA8600            Branch to Print Remaining Line Data
DSWA8500 DS    0H
         CLC   LMOD.LRTLMOD(8),=C'UNKNOWN ' Is Load Module Name Known?
         BRE   DSWA8600            No  => Then No Lmod Info to Process
         LA    R2,DWAOLINE+DSWLNELN+L'DWAWRK16+1 Point Past BEA Address
         MVC   0(2,R2),=CL2'at'    Set Indicator for Addr at Lod Module
         MVC   3(L'LRTPGMNM,R2),LMOD.LRTPGMNM Lmod Name+Offset for BEA
DSWA8600 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DSWAEXIT            No  => Then Bypass Print Output
         BRAS  R14,DSWAP100        Print the Breaking Event Addr Line
*
*+-------------------------------------------------------------------+*
*|  Analyze the PSW for Control Information and Machine State and    |*
*|  Print the Program Status Word CPU Information Detail Lines       |*
*|                                                                   |*
*|  For example:                                                     |*
*|                                                                   |*
*|  Abending Instruction Length: 4 bytes                             |*
*+-------------------------------------------------------------------+*
*
DSWA9000 DS    0H
         MVI   DWALINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DWALINE+1(L'DWALINE-1),DWALINE ...Propogate the Blank
         LA    R2,DWAOLINE         Obtain the Address of Output Line
         MVC   DWAOLINE(DSWLNELN),DSWINILC Header for Instruc Leng Code
         OI    DWAILC,X'F0'        Certify Sign to Make ILC Printable
         MVC   DSWLNELN(L'DWAILC,R2),DWAILC Set Instruction Length Code
         MVC   DSWLNELN+L'DWAILC+1(5,R2),=CL5'bytes'  Show ILC as Bytes
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DSWAEXIT            No  => Then Bypass Print Output
         BRAS  R14,DSWAP100        Prnt Instructn Leng Code to LGRECOUT
*
*+-------------------------------------------------------------------+*
*| Format And Print Program Status Word CPU State Detail Line        |*
*|                                                                   |*
*| For example:                                                      |*
*|                                                                   |*
*| CPU State..................: Problem State (Only unprivileged inst|*
*+-------------------------------------------------------------------+*
*
DSWA9100 DS    0H
         MVI   DWALINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DWALINE+1(L'DWALINE-1),DWALINE ...Propogate the Blank
         MVC   DWAOLINE(DSWLNELN),DSWCPUST ..Header for the CPU State
         TM    DWAPSW+1,X'01'      Was User Progrm in Supervisor State?
         BRO   DSWA9200            No  => User Pgm in Problem State
         MVC   DSWLNELN(L'DSWSUPRV,R2),DSWSUPRV ..Show Supervisor State
         BRU   DSWA9300            Branch to Print the CPU State Info
DSWA9200 DS    0H
         MVC   DSWLNELN(L'DSWPROBS,R2),DSWPROBS ..Show in Problem State
DSWA9300 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DSWAEXIT            No  => Then Bypass Print Output
         BRAS  R14,DSWAP100        Print CPU State Info to //LGRECOUT
*
*+-------------------------------------------------------------------+*
*| Format And Print Program Status Word Key Detail Line              |*
*|                                                                   |*
*| For example:                                                      |*
*|                                                                   |*
*| Program Status Word Key....: 8  (The access key used for storage r|*
*+-------------------------------------------------------------------+*
*
DSWA9400 DS    0H
         MVI   DWALINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DWALINE+1(L'DWALINE-1),DWALINE ...Propogate the Blank
         MVC   DWAOLINE(DSWLNELN),DSWPSWKY ..Header for the PSW Key
         LLGC  R1,DWAPSW+1         Get Program Status Word Key Area
         SRLG  R1,R1,4 Bits        Isolate Just the PSW Key Value
         CVD   R1,DWAWORKD         Current PSW Key Number to Decimal
         OI    DWAWORKD+L'DWAWORKD-1,15 Certify Sign to Make Printable
         UNPK  DWAWRK09(3),DWAWORKD+6(2) ..PSW Key No. to Zoned Format
         CLI   DWAWRK09+1,C'0'     Does the PSW Key Have Two Digits?
         BRE   DSWA9500            No  => Branch When PSW Key is 0-9
         MVC   DWAOLINE+DSWLNELN(2),DWAWRK09+1 Copy When PSW Key 10-15
         BRU   DSWA9600            Branch to Print the PSW Key
DSWA9500 DS    0H
         MVC   DWAOLINE+DSWLNELN(1),DWAWRK09+2 Copy When PSW Key is 0-9
DSWA9600 DS    0H
         MVC   DWAOLINE+DSWLNELN+3(L'DSWACCKY),DSWACCKY ..Copy Comments
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DSWAEXIT            No  => Then Bypass Print Output
         BRAS  R14,DSWAP100        Print the PSW Key Info to //LGRECOUT
*
*+-------------------------------------------------------------------+*
*| Format And Print the PSW Addressing Mode Detail Line              |*
*|                                                                   |*
*| For example:                                                      |*
*|                                                                   |*
*| Addressing Mode............: 31 (Program was in 31-bit addressing |*
*+-------------------------------------------------------------------+*
*
DSWA9700 DS    0H
         MVI   DWALINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DWALINE+1(L'DWALINE-1),DWALINE ...Propogate the Blank
         MVC   DWAOLINE(DSWLNELN),DSWADMOD ..Header for Addressing Mode
         SLGR  R15,R15             Prepare Insert of PSW Status Bits
         ICM   R15,B'0011',DWAPSW+3 ..Get Bits 24 through 40 of the PSW
         NILL  R15,(384)           Extended+Basic Addressing Mode Bits
         SRLG  R15,R15,7 Bits      Shift Extracted Bits for Alignment
         SLLG  R15,R15,2 Bits      Multiply by 4 for Branch Table
         B     *+4(R15)            Branch Based on Bits 31/32 From PSW
DSWA9800 DS    0H
         BRU   DSWA9900            Abending Program Amode24 (0 0)
         BRU   DSW10000            Abending Program Amode31 (0 1)
         BRU   DSW10100            Invalid, Assume Amode64  (1 0) S0C6?
         BRU   DSW10200            Abending Program Amode64 (1 1)
DSWA9900 DS    0H
         MVC   DWAAMODE,=CL2'24'   Save Addressing Mode at Time of Abnd
         MVC   DWAOLINE+DSWLNELN(L'DWAAMODE),DWAAMODE  Show as Amode 24
         BRU   DSW10300
DSW10000 DS    0H
         MVC   DWAAMODE,=CL2'31'   Save Addressing Mode at Time of Abnd
         MVC   DWAOLINE+DSWLNELN(L'DWAAMODE),DWAAMODE  Show as Amode 31
         BRU   DSW10300
DSW10100 DS    0H
         MVC   DWAAMODE,=CL2'64'   Save Addressing Mode at Time of Abnd
         MVC   DWAOLINE+DSWLNELN(L'DWAAMODE),DWAAMODE  Show as Amode 64
         BRU   DSW10300
DSW10200 DS    0H
         MVC   DWAAMODE,=CL2'64'   Save Addressing Mode at Time of Abnd
         MVC   DWAOLINE+DSWLNELN(L'DWAAMODE),DWAAMODE  Show as Amode 64
DSW10300 DS    0H
         MVC   DWAOLINE+DSWLNELN+L'DWAAMODE+1(L'DSWAMODE),DSWAMODE
AMOD     USING DSWAMODE,DWAOLINE+DSWLNELN+L'DWAAMODE+1 For Comment Line
         MVC   AMOD.DSWBITAD,DWAAMODE ...Indicate Bit Addressing Number
         DROP  AMOD                Remove Reference as Comment Lne Base
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DSWAEXIT            No  => Then Bypass Print Output
         BRAS  R14,DSWAP100        Print Amode Information to LGRECOUT
*
*+-------------------------------------------------------------------+*
*| Format And Print the PSW Condition Code Setting to Detail Line    |*
*|                                                                   |*
*| For example:                                                      |*
*|                                                                   |*
*| Condition Code in PSW......: 2  (Result of last executed instructi|*
*+-------------------------------------------------------------------+*
*
DSW10400 DS    0H
         MVI   DWALINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DWALINE+1(L'DWALINE-1),DWALINE ...Propogate the Blank
         MVC   DWAOLINE(DSWLNELN),DSWCONDC ..Header for Condition Code
         MVO   DWAWORKD(2),DWAPSW+2(1) Addr Space Mode + CC Bits of PSW
         NI    DWAWORKD,X'03'      Drop PSW Bits for Address Space Mode
         UNPK  DWAWORKF(5),DWAWORKD(2) Convert Cond Cde in Hex to Zoned
         MVC   DWAOLINE+DSWLNELN(1),DWAWORKF+L'DWAWORKF-1 Get Cond Code
         MVC   DWAOLINE+DSWLNELN+3(L'DSWCCSET),DSWCCSET Set Comment Lne
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DSWAEXIT            No  => Then Bypass Print Output
         BRAS  R14,DSWAP100        Print Cond Code Info to //LGRECOUT
*
*+-------------------------------------------------------------------+*
*| Format And Print the PSW Address Space Control Mode to Detail Line|*
*|                                                                   |*
*| For example:                                                      |*
*|                                                                   |*
*| Address Space Control Mode.: Primary-space                        |*
*+-------------------------------------------------------------------+*
*
DSW10500 DS    0H
         MVI   DWALINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DWALINE+1(L'DWALINE-1),DWALINE ...Propogate the Blank
         MVC   DWAOLINE(DSWLNELN),DSWTMODE ..Header for Addr Space Mode
         TM    DWAPSW+2,X'C0'      Address Space in Home Space Mode?
         BRO   DSW10600            Yes => Branch to Show Adr Space Mode
         TM    DWAPSW+2,X'80'      Addr Space in Secondary Space Mode?
         BRO   DSW10700            Yes => Branch to Show Adr Space Mode
         TM    DWAPSW+2,X'40'      Addr Space in Access Register Mode?
         BRO   DSW10800            Yes => Branch to Show Adr Space Mode
         MVC   DWAOLINE+DSWLNELN(15),=CL15'Primary-space'  Show Mode
         BRU   DSW10900            Branch to Print Address Space Mode
DSW10600 DS    0H
         MVC   DWAOLINE+DSWLNELN(15),=CL15'Home-space' Show Mode
         BRU   DSW10900            Branch to Print Address Space Mode
DSW10700 DS    0H
         MVC   DWAOLINE+DSWLNELN(15),=CL15'Secondary-space'  Show Mode
         BRU   DSW10900            Branch to Print Pgm PSW Attributes
DSW10800 DS    0H
         MVC   DWAOLINE+DSWLNELN(15),=CL15'Access-register'  Show Mode
DSW10900 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DSWAEXIT            No  => Then Bypass Print Output
         BRAS  R14,DSWAP100        PSW Addr Space Cntl Mode to LGRECOUT
DSW11000 DS    0H
         MVI   DWALINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DWALINE+1(L'DWALINE-1),DWALINE ...Propogate the Blank
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DSWAEXIT            No  => Then Bypass Print Output
         BRAS  R14,DSWAP100        Print a Blank Separator Line
*
*+-------------------------------------------------------------------+*
*|  From the Failing Instruction Address Determine What Was the      |*
*|  Abending Instruction, and Then Display the Characteristics of    |*
*|  the Abending Instruction.                                        |*
*+-------------------------------------------------------------------+*
*
DSW11100 DS    0H
         MVC   DWAOLINE(L'DSWABNDI),DSWABNDI .Instruction Causing Abend
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DSWAEXIT            No  => Then Bypass Print Output
         BRAS  R14,DSWAP100        Header Line for Abending Instruction
         MVI   DWALINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DWALINE+1(L'DWALINE-1),DWALINE ...Propogate the Blank
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DSWAEXIT            No  => Then Bypass Print Output
         BRAS  R14,DSWAP100        Print a Blank Separator Line
         LG    R5,DWABEND@         Get Address of Abending Instruction
         LLGFR RPCC,PLCA           Our Abending Program's LCA Address
         LA    R4,DWAMCHI@         Adr of Machine Instruction Tbl Entry
         LA    R3,DWAMCHI1         Addr 1st Entry Found in Instruct Tbl
         XC    DWAPLIST,DWAPLIST   Clear the Call Parameter List
         CALL  DABN0000,           Process for Abending Instruction    X
               (DWATARGT,          ..Address of Target of EX Instructn X
               (R3),               ..Pass Addr 1st Entry Found in TableX
               (R4),               ..Pass Addr of Entry in Machine TbleX
               (R5),               ..Pass Addr of Abending Instruction X
               (PLCA),             ..Pass Abending Programs's LCA Addr X
               (RSDW),             ..Pass SDWA Area Address            X
               (RLGW),             ..Pass LGRWK2II Area Address        X
               (RCOMM)),           ..Pass Common Constants&Routines    X
               PLIST8=YES,         ..Indicate the Parameter List FormatX
               LINKINST=LGR,       ..Indicate the Link Instruction TypeX
               MF=(E,DWAPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Determine the Abending Instruction
         LTGFR R15,R15             Instruction Processing Successful?
         BRZ   DSW11200            Yes => Branch to Process Abend Area
         LGHI  R2,((DSW11300-DSW11200)-4) ...Length of Branch Table
         CGFR  R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   DSW11200            No  => Branch to Process Abend Area
         BRU   DSWAEXIT            Yes => Branch to Exit This Routine
DSW11200 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   DSW11400            Process Instructions Around Abend
         BRU   DSW11400            Branch on Warning-Ignore & Continue
         BRU   DSW11300            Branch on Processing Error, Set Msg
         BRU   DSWAEXIT            Branch on Severe Error - Exit
DSW11300 DS    0H
         MVC   DWAOLINE(L'DSWNOMOD),DSWNOMOD ....No Active Module Found
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DSWAEXIT            No  => Then Bypass Print Output
         BRAS  R14,DSWAP100        Print Msg No Active Module Was Found
         MVI   DWALINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DWALINE+1(L'DWALINE-1),DWALINE ...Propogate the Blank
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DSWAEXIT            No  => Then Bypass Print Output
         BRAS  R14,DSWAP100        Print a Blank Separator Line
*
*+-------------------------------------------------------------------+*
*| From the Failing Instruction Address Disassemble the Machine Code |*
*| in the Load Module and Display the Assembler Source Statements in |*
*| the Vicinity of the Instruction Which Caused the Abend.           |*
*+-------------------------------------------------------------------+*
*
DSW11400 DS    0H
         LLGFR RPCC,PLCA           Our Abending Program's LCA Address
         LA    R4,DWAMCHI1         Adr of Machine Instruction Tbl Entry
         LG    R5,DWABEND@         Get Address of Abending Instruction
         XC    DWAPLIST,DWAPLIST   Clear the Call Parameter List
         CALL  DIVC0000,           Process for Instructions Around AbndX
               ((R4),              ..Pass Addr of Entry in Machine TbleX
               (R5),               ..Pass Addr of Abending Instruction X
               (PLCA),             ..Pass Abending Programs's LCA Addr X
               (RSDW),             ..Pass SDWA Area Address            X
               (RLGW),             ..Pass LGRWK2II Area Address        X
               (RCOMM)),           ..Pass Common Constants&Routines    X
               PLIST8=YES,         ..Indicate the Parameter List FormatX
               LINKINST=LGR,       ..Indicate the Link Instruction TypeX
               MF=(E,DWAPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Determine Instructions Around Abend
         LTGFR R15,R15             Abend Area Processing Successful?
         BRZ   DSW11500            Yes => Branch to Process Registers
         LGHI  R2,((DSW11600-DSW11500)-4) ...Length of Branch Table
         CGFR  R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   DSW11500            No  => Branch to Process Module Name
         BRU   DSWAEXIT            Yes => Branch to Exit This Routine
DSW11500 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   DSW11600            Abend Area Process Done, Process Lod
         BRU   DSW11600            Branch on Warning-Ignore & Continue
         BRU   DSWAEXIT            Branch on Processing Error - Exit
         BRU   DSWAEXIT            Branch on Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*| Process from the SDWA the General Purpose Registers and the Access|*
*| Registers at Entry to Abend.                                      |*
*+-------------------------------------------------------------------+*
*
DSW11600 DS    0H
         LG    R6,DWABEND@         Get Address of Abending Instruction
         XC    DWAPLIST,DWAPLIST   Clear the Call Parameter List
         CALL  DREG0000,           Process for Register Contents       X
               (DWATARGT,          ..Pass Addr of Target of EX Instruc X
               DWAMCHI@,           ..Pass Addr of Entry in Machine TbleX
               DWAAMODE,           ..Pass Addr of Amode at Time of AbndX
               (R6),               ..Pass Addr of Abending Instruction X
               (RSDW),             ..Pass SDWA Area Address            X
               (RLGW),             ..Pass LGRWK2II Area Address        X
               (RCOMM)),           ..Pass Common Constants&Routines    X
               PLIST8=YES,         ..Indicate the Parameter List FormatX
               LINKINST=LGR,       ..Indicate the Link Instruction TypeX
               MF=(E,DWAPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Determine the Register Contents
         LTGFR R15,R15             Was Register Processing Successful?
         BRZ   DSW11700            Yes => Branch to Process the PRB
         LGHI  R2,((DSW12000-DSW11700)-4) ...Length of Branch Table
         CGFR  R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   DSW11700            No  => Branch to Process Interrupt
         BRU   DSWAEXIT            Yes => Branch to Exit This Routine
DSW11700 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   DSW12000            Register Contents Process Completed
         BRU   DSW12000            Branch on Warning-Ignore & Continue
         BRU   DSWAEXIT            Branch on Processing Error - Exit
         BRU   DSWAEXIT            Branch on Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*|  Process the PRB for Last Interrupt Event Before Abend            |*
*+-------------------------------------------------------------------+*
*
DSW12000 DS    0H
         LLGFR RPCC,PLCA           Our Abending Program's LCA Address
         LG    R5,DWABEND@         Get Address of Abending Instruction
         XC    DWAPLIST,DWAPLIST   Clear the Call Parameter List
         CALL  DRBT0000,           Process the PRB for Last Interrupt  X
               ((R5),              ..Pass Addr of Abending Instruction X
               (PLCA),             ..Pass Abending Programs's LCA Addr X
               (RSDW),             ..Pass SDWA Area Address            X
               (RLGW),             ..Pass LGRWK2II Area Address        X
               (RCOMM)),           ..Pass Common Constants&Routines    X
               PLIST8=YES,         ..Indicate the Parameter List FormatX
               LINKINST=LGR,       ..Indicate the Link Instruction TypeX
               MF=(E,DWAPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Determine Address of Last Interrupt
         LTGFR R15,R15             Was Interrupt Processing Successful?
         BRZ   DSW12200            Yes => Branch to Process Break Event
         LGHI  R2,((DSW12300-DSW12200)-4) ...Length of Branch Table
         CGFR  R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   DSW12200            No  => Branch to Process Break Event
         BRU   DSWAEXIT            Yes => Branch to Exit This Routine
DSW12200 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   DSW12300            Interrupt Processing Completed, Exit
         BRU   DSW12300            Branch on Warning-Ignore & Continue
         BRU   DSWAEXIT            Branch on Processing Error - Exit
         BRU   DSWAEXIT            Branch on Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*|Process the Address That Was in the BEAR Before the Abend to Show  |*
*|the Instructions Around the Breaking Event Address.                |*
*+-------------------------------------------------------------------+*
*
DSW12300 DS    0H
         LLGFR RPCC,PLCA           Our Abending Program's LCA Address
         LG    R5,DWABREAK         Get the Breaking Event Address
         LTGR  R5,R5               Is There a Breaking Address at All?
         BRZ   DSWAEXIT            No  => Then Exit, No BEAR to Process
         XC    DWAPLIST,DWAPLIST   Clear the Call Parameter List
         CALL  DBRK0000,           Process the Breaking Event Address  X
               ((R5),              ..Pass Address of Breaking Event    X
               (PLCA),             ..Pass Abending Programs's LCA Addr X
               (RSDW),             ..Pass SDWA Area Address            X
               (RLGW),             ..Pass LGRWK2II Area Address        X
               (RCOMM)),           ..Pass Common Constants&Routines    X
               PLIST8=YES,         ..Indicate the Parameter List FormatX
               LINKINST=LGR,       ..Indicate the Link Instruction TypeX
               MF=(E,DWAPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Determine Address of Last Interrupt
         LTGFR R15,R15             Was BEAR Processing Successful?
         BRZ   DSW12400            Yes => Branch to Exit This Routine
         LGHI  R2,((DSWAEXIT-DSW12400)-4) ...Length of Branch Table
         CGFR  R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   DSW12400            No  => Branch to Exit This Routine
         BRU   DSWAEXIT            Yes => Branch to Exit This Routine
DSW12400 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   DSWAEXIT            Breaking Event Addr Completed, Exit
         BRU   DSWAEXIT            Branch on Warning-Ignore & Continue
         BRU   DSWAEXIT            Branch on Processing Error - Exit
         BRU   DSWAEXIT            Branch on Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*|   Return to Caller                                                |*
*+-------------------------------------------------------------------+*
*
DSWAEXIT DS    0H
         SLGR  R15,R15             Indicate Successful Completion
         ST    R15,DWARETCD        Set the Return Code
         LPGMEXIT RC=DWARETCD      Define Program Exit Protocol
*
*+-------------------------------------------------------------------+*
*|         P r i n t   O u t p u t   D e t a i l   L i n e           |*
*+-------------------------------------------------------------------+*
*|SUBROUTINE NAME: DSWAP100                                          |*
*|FUNCTION.......: Print Detail Line to Output Logger Data Set       |*
*+-------------------------------------------------------------------+*
*
DSWAP100 LPGMSUBE                  Set Subroutine Entry Protocol
         SYSSTATE AMODE64=NO,ARCHLVL=2 Generate Code for Not in AMODE64
         SAM31                     Switch Now to 31-Bit Addressing Mode
         PUT   LGWODCB,DWALINE     Print Output Line to //LGRECOUT
         SAM64                     Switch Back to 64-Bit Address Mode
         SYSSTATE AMODE64=YES,ARCHLVL=2    Restore 64-Bit Environment
         LPGMSUBX                  Return to Caller of This Subroutine
*
*+-------------------------------------------------------------------+*
*|   Definition for Constants                                        |*
*+-------------------------------------------------------------------+*
*
DSWLNELN EQU   29                  Leng for Summary Detail Line Headers

DSWABSUM DC    CL(DSWLNELN)'-Abend Summary-'
DSWABNDC DC    CL(DSWLNELN)'Abend Code.................: '
DSWABLOC DC    CL(DSWLNELN)'Abend Location.............: '
DSWABPSW DC    CL(DSWLNELN)'Program Status Word........: '
DSWAZPSW DC    CL(DSWLNELN)'zArch Program Status Word..: '
DSWDTPSW DC    CL(DSWLNELN)'Data Around PSW............: '
DSWBREKD DC    CL(DSWLNELN)'Breaking Event Address.....: '
DSWINILC DC    CL(DSWLNELN)'Abending Instruction Length: '
DSWCPUST DC    CL(DSWLNELN)'CPU State..................: '
DSWPSWKY DC    CL(DSWLNELN)'Program Status Word Key....: '
DSWADMOD DC    CL(DSWLNELN)'Addressing Mode............: '
DSWCONDC DC    CL(DSWLNELN)'Condition Code in PSW......: '
DSWTMODE DC    CL(DSWLNELN)'Address Space Control Mode.: '
DSWABNDI DC    C'*** Instruction Which Caused the Abend ***'
DSWNOMOD DC    C'    No Active Module Found'
DSWPSWNT DC    C'Not Translatable'
DSWSUPRV DC    C'Supervisor State (All instructions valid)'
DSWPROBS DC    C'Problem State (Only unprivileged instructions valid)'
DSWACCKY DC    C'(The access key used for storage references by the CPUX
               )'                  Comment Line Describing the PSW Key
DSWAMODE DC    C'(Program was in ??-bit addressing mode at time of abenX
               d)'                Comment Line Describing AMODE
         ORG   DSWAMODE            Back Up and Redefine Comment Line
         DS    CL16                Use as a Filler Up to Field Position
DSWBITAD DS    CL2                 Field for Addressing Mode Bit Number
         DS    CL38                Set Filler to End of Comment Line
         ORG   ,                   Reset the Location Counter
DSWCCSET DC    C'(Result of last executed instruction which set Cond CoX
               de in PSW)'
*
*+-------------------------------------------------------------------+*
*|    Program RENT Work Area                                         |*
*+-------------------------------------------------------------------+*
*
         LCA   DEFINE              Define the Program RENT Work Area
*
DWAWORKD DS    10D                 General Purpose Work Area
DWAPLIST DS    20FD                CALL Parameter List
DWAMCHI1 DS    AD                  Addr 1st Entry for Machine Tbl Entry
DWAMCHI@ DS    AD                  Addr of Entry for Machine Tble Entry
DWABEND@ DS    AD                  Address of the Abending Instruction
DWATARGT DS    AD                  Address of Target of EX Instruction
DWARETCD DS    F                   Save Area for the Return Code
DWAWORKF DS    F                   General Purpose Work Area
         DS    XL1                 Slack Byte
         DS    0D                  Set For Doubleword Alignment
DWAWTOMG DS    0D,XL(COMWTOL)      Area for WTO Macro List Form
         DS    0F
DWAMSG   DS    H                   Length of Message Text
DWAMSGTX DS    CL80                Text of Message
DWACMPCD DS    XL3                 System Abend Completion Code
DWASYSCD DS    CL3                 System Completion Code
DWAUSRCD DS    CL3                 User Completion Code
DWAILC   DS    XL1                 ILC - Instruction Length Code
DWAPSWTP DS    CL4                 Program Status Word Type - BC/EC
         DS    0D                  Doubleword Alignment
DWARSNCD DS    CL8                 Abending Program Reason Code
DWABREAK DS    XL8                 Breaking Event Address (Last Branch)
DWAPSW   DS    XL8                 Program Status Word at Abend
DWAPDATA DS    CL8                 Data Around Program Status Word
DWAAMODE DS    CL2                 Addressing Mode at Time of Abend
DWAPSWDT DS    CL(L'SDWAFAIN)      Instruction Stream Data at Abend PSW
DWAPSOUT DS    CL(2*L'DWAPSWDT)    Set a Work Area for Output PSW Data
         DS    X                   Use as Slack Byte for Unpack Process
DWA$PWRK DS    XL16                Set Work Area for Unpacking PSW Data
DWAWRK09 DS    CL9                 General Purpose Work Area
DWAWRK16 DS    CL16                General Purpose Work Area
DWAWRK20 DS    CL20                General Purpose Work Area
DWALMODI DS    CL(LRTLMLEN)        Area for Load Module Information Blk
DWALINE  DS    0CL133              Output Print Line Area
DWACCNTL DS    CL1                 Carriage Control Character
DWAOLINE DS    CL132               Output Record Print Area
*
         LCA   DEFEND              Define End of Program RENT Work Area
*
***********************************************************************
*        End of Analyze System Diagnostic Work Area Processing        *
***********************************************************************
         EJECT ,
***********************************************************************
**************************+-----------------+**************************
**************************| D R B T 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|  D i s p l a y   R e q u e s t   B e f o r e   I n t e r r u p t  |*
*+-------------------------------------------------------------------+*
* PROGRAM NAME:    DRBT0000                                           *
*                                                                     *
* FUNCTION:        This routine attempts to determine the last SVC    *
*                  interrupt event which occurred before abend. This  *
*                  is where an abend occurred in an SVC, and the abend*
*                  most likely occurring from the user passing a bad  *
*                  parameter list. Logger Services will have          *
*                  previously reported the abend in the SVC, where    *
*                  the abend occurred in the SVC, and the instruction *
*                  within the SVC which caused the abend. Now need to *
*                  find out where in the user's program was the SVC   *
*                  issued. This routine will attempt to find where in *
*                  the user's program was the SVC called from, show   *
*                  the address in the user's program where the SVC    *
*                  was coded, and then as a further diagnostic aid    *
*                  disassemble the machine code for the load module   *
*                  in memory to display the assembler instructions the*
*                  user coded in their program preceding the call to  *
*                  the abending SVC.                                  *
*                                                                     *
*---------------------------------------------------------------------*
*                                                                     *
* For example: Here is an abend in OPEN, so show where was the OPEN   *
*              called from, show the characteristics of the SVC, show *
*              the instructions preceding the OPEN, and show the      *
*              registers at entry to OPEN.                            *
*                                                                     *
* Sample Output:                                                      *
*                                                                     *
* *** Last Interrupt Event in Program Before Abend ***                *
*                                                                     *
* Interrupt Event Location: USRTEST7.USRTEST7+(00040C)                *
* Interrupt Event Address.: 00000000189007DC                          *
*                                                                     *
* -Instruction Summary-                                               *
*                                                                     *
* Instruction at Address..: 00000000189007D4                          *
* Machine Instruction.....: 0A13                                      *
* Instruction Op Code.....: 0A                                        *
* Instruction Mnemonic....: SVC      19    (OPEN) Type=4        Calls *
* Instruction Description.: Supervisor Call                           *
* Instruction Format......: SVC nn                                    *
* Instruction Type........: I                                         *
* Instruction Attributes..: Does not set Condition Code               *
* Instruction Facility....: None, zArchitecture base                  *
*                                                                     *
* -Instructions in Vicinity-                                          *
*                                                                     *
* Hex      Hex Machine                                                *
* Offset   Instruction      Assembler Source Statement           Attri*
* ------   ---------------  -----------------------------------  -----*
*    -7C   9694 2024        OI       36(R2),X'94'                Sets *
*    -78   47F0 C3B0        BC       15,944(R0,R12)                   *
*    -74   4110 A318        LA       R1,792(R0,R10)              Modal*
*    -70   BE17 2025        STCM     R1,B'0111',37(R2)                *
*    -6C   4100 A320        LA       R0,800(R0,R10)              Modal*
*    -68   BE07 1001        STCM     R0,B'0111',1(R1)                 *
*    -64   9291 1000        MVI      0(R1),X'91'                      *
*    -60   D215 A320 8688   MVC      800(22,R10),1672(R8)             *
*    -5A   E300 BE2C 0017   LLGT     R0,3628(R0,R11)                  *
*    -54   5000 A338        ST       R0,824(R0,R10)                   *
*    -50   D207 A170 86A0   MVC      368(8,R10),1696(R8)              *
*    -4A   9280 A170        MVI      368(R10),X'80'                   *
*    -46   4110 A170        LA       R1,368(R0,R10)              Modal*
*    -42   94F0 1000        NI       0(R1),X'F0'                 Sets *
*    -3E   960F 1000        OI       0(R1),X'0F'                 Sets *
*    -3A   5021 0004        ST       R2,4(R1,R0)                      *
*    -36   1801             LR       R0,R1                            *
*    -34   1B11             SR       R1,R1                       Sets *
*    -32   0A13             SVC      19    (OPEN)                     *
*    -30   48F0 2052        LH       R15,82(R0,R2)                    *
*    -2C   40F0 A270        STH      R15,624(R0,R10)                  *
*    -28   9110 2030        TM       48(R2),X'10'                Sets *
*    -24   4780 C3E4        BC       8,996(R0,R12)                    *
*    -20   9680 A4C3        OI       1219(R10),X'80'             Sets *
*    -1C   D25F A178 8524   MVC      376(96,R10),1316(R8)             *
*    -16   4120 A178        LA       R2,376(R0,R10)              Modal*
*    -12   4120 BBC8        LA       R2,3016(R0,R11)             Modal*
*     -E   5020 D31C        ST       R2,796(R0,R13)                   *
*     -A   9680 D31C        OI       796(R13),X'80'              Sets *
*     -6   4120 D31C        LA       R2,796(R0,R13)              Modal*
*     -2   1812             LR       R1,R2                            *
*   ===>   0A13             SVC      19    (OPEN)                     *
*     +2   5830 BE30        L        R3,3632(R0,R11)                  *
*     +6   4110 A178        LA       R1,376(R0,R10)              Modal*
*     +A   4100 DABF        LA       R0,2751(R0,R13)             Modal*
*     +E   1FFF             SLR      R15,R15                     Sets *
*    +10   BFF7 1031        ICM      R15,B'0111',49(R1)          Sets *
*    +14   05EF             BALR     R14,R15                     Modal*
*                                                                     *
*General Purpose Registers at Entry to Event.                         *
*Refer to Registers R2-R12 (Low Half)                                 *
*  0-3   0000000000000950  0000000000050000  000000000000731C  0000000*
*  4-7   00000000000004C4  0000000000000000  0000000000000000  0000000*
*  8-11  0000000018907F98  000000000004AB38  0000000000049B38  0000000*
*  12-15 00000000189003DC  0000000000050538  0000000080FDD0D0  0000000*
*                                                                     *
*---------------------------------------------------------------------*
*                                                                     *
* INPUT REGS:      R1 => Standard O/S Parameter List                  *
*                                                                     *
* INPUT DATA:      Parm1: Address of Failing Instruction              *
*                  Parm2: Address of Abending Program's LCA Area      *
*                  Parm3: Address of System Diagnostic Work Area      *
*                  Parm4: Address of LGRWK2II Logger Work Area        *
*                  Parm5: Addr of Common Constants and Routines Area  *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY, AC=0                          *
*                                                                     *
* CALLING PROGRAM: DSWA0000 - SDWA Diagnostic Information Program     *
*                                                                     *
* CALLED PROGRAMS: LNME0000 - Logger Services Program to Resolve an   *
*                             Address to a Load Module Name           *
*                  DABN0000 - Logger Services Program to Resolve an   *
*                             Address to the Abending Instruction     *
*                  DIVC0000 - Logger Services Program to Process the  *
*                             Instructions in Vicinity of Abend       *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                  04 - Warning                                       *
*                  08 - Error                                         *
*                  12 - Severe Error - Exit This Routine              *
*                                                                     *
***********************************************************************
*
DRBT0000 LPGMNTRY TYPE=SUB,        Define As A Sub-Program Entry       X
               BASE=(12),          Establish Base Registers            X
               AMOD=64,RMOD=ANY,   Addressing and Residency Modes      X
               LCAPFX=DRB,         Establish LCA Prefix for This RSECT X
               LOG=OFF,            Always Turn Logging 'Off' in Logger!X
               LINKRTRN=BSM,       Define Return Linkage Instruction   X
               COPY@RT=YES         To Generate a Copyright Statement
         USING COM_DATA,RCOMM      Addressability to Common Data Area
         USING LGRWK2II,RLGW       Establish Addressability to LGRWK2II
         USING SDWA,RSDW           Establish Addressability to SDWA
         USING IHADCB,LGWODCB      Establish Addressability to DCB
LMOD     USING LRTLMBLK,DRBLMODI   Establish Addressability to LMODI
         LMG   R6,R10,0(R1)        Load the Parameter Area Addresses
         STMG  R6,R7,DRBPARM@      Addr of Failing Instruction and PLCA
         XC    DRBRETCD,DRBRETCD   Initialize the Return Code
*
*+-------------------------------------------------------------------+*
*| Determine if the last interrupt event before abend was for SVC    |*
*+-------------------------------------------------------------------+*
*
DRBT0100 DS    0H
         LA    R1,DRBT0200         Get Retry Recovery Address (ESPIE)
         ST    R1,LGWRETRY         Preserve It In Case of an Abend
         LLGT  R1,PSATOLD-PSA(,R0) Get Addr of Current Task Cntl Block
         LLGT  R2,TCBRBP-TCB(,R1)  Addr to the Most Recent RB in Chain
         LTGFR R2,R2               Is There An RB for Our Current TCB?
         BRZ   DRBT0200            No  => Then No RB for Current TCB
         LGR   R3,R2               Addr is Start of Basic Section of RB
         AGHI  R3,-(RBBASIC-RBPREFIX)  Get Addr to Prefix Section of RB
         USING RBPREFIX,R3         Addressability to the RB Prefix Area
         CLI   RBSTAB1,RBFTPRB     Is This for a Problem Request Block?
         BRNE  DRBT0200            No  => Then Top RB is Not For a PRB
         DROP  R3                  Remove as Base to the RB Prefix Area
         LLGT  R5,SDWAXPAD         Addr of SDWA Extension Pointers Area
         ICM   R5,B'1111',SDWASRVP-SDWAPTRS(R5) Adr SDWA 1st Extension?
         BRZ   DRBT0200            No  => No SDWA 1st Extension Area
         USING SDWARC1,R5          Addressablity to 1st Extension Area
         TM    SDWAXFLG,SDWAINTF   Are Contents of SDWAEC2 from an RB?
         BRO   DRBT0200            No  => Contents from a Linkage Stack
         XC    LGWRETRY,LGWRETRY   Areas Referenced, Disable Recovery
         BRU   DRBT0300            Branch to Process Interrupt Address
         DROP  R5                  Remove as Base to SWDA 1st Extension
DRBT0200 DS    0H
         XC    LGWRETRY,LGWRETRY   Clear to Disable Abend Recovery
         LA    R15,4               Indicate Error in RB/XSB Access
         ST    R15,DRBRETCD        Set Highest Generated Return Code
         BRU   DRBTEXIT            Unable to Resolve Interrupt Address
DRBT0300 DS    0H
         LA    R1,DRBT0500         Get Retry Recovery Address (ESPIE)
         ST    R1,LGWRETRY         Preserve It In Case of an Abend
         LLGT  R1,SDWANXT2         RBOPSW from RB Activating Recovery
         AGHI  R1,-(2)             Point Back to SVC Causing Interrupt
         CLI   0(R1),X'0A'         Do We Have an Op Code for Type SVC?
         BRNE  DRBT0500            No  => Not an SVC Entry by User Pgm
         LLGC  R0,1(,R1)           Interrupt Code on RB that Issued SVC
         LLGT  R5,=A(OPC$SVCT)     Address of the SVC Instruction Table
         LA    R14,L'OPC$SVCT      Get Length of Each SVC Table Entry
         LLGF  R15,=A(OPC$SVCT+((OPC$SVNO*L'OPC$SVCT)-L'OPC$SVCT))
DRBT0400 DS    0H
         CLM   R0,B'0001',0(R5)    This Our SVC Instruction in Table?
         BRE   DRBT0600            Yes => Branch to Set SVC Description
         BRXLG R5,R14,DRBT0400     No  => Loop to Check Next SVC Entry
DRBT0500 DS    0H
         XC    LGWRETRY,LGWRETRY   Error, Disable Recovery Enviroment
         LA    R15,4               Error in Interrupt Code Check
         ST    R15,DRBRETCD        Set Highest Generated Return Code
         BRU   DRBTEXIT            Unable to Resolve Interrupt Address
DRBT0600 DS    0H
         XC    LGWRETRY,LGWRETRY   Areas Referenced, Disable Recovery
         STG   R0,DRBINTCD         Save the Interrupt Code from the RB
*
*+-------------------------------------------------------------------+*
*| Determine the Load Module/Csect name and displacement within the  |*
*| user program where the abending SVC was called from.              |*
*+-------------------------------------------------------------------+*
*
DRBT0700 DS    0H
         LLGFR RPCC,PLCA           Our Abending Program's LCA Address
         LLGT  R5,SDWANXT2         Get the Old PSW Address From Our RB
         AGHI  R5,(-2)             Back up to the Last Instruction
         STG   R5,DRBINTR@         Last Instruction Before Interrupt
         XC    DRBPLIST,DRBPLIST   Clear the Call Parameter List
         CALL  LNME0000,           Process Storage Address for Mod NameX
               ((R5),              ..Pass Storage Addr to Be Resolved  X
               (RPCC),             ..Pass Abending Programs's LCA Addr X
               DRBLMODI,           ..Pass Addr of Load Module Info AreaX
               (RSDW),             ..Pass SDWA Area Address            X
               (RLGW),             ..Pass LGRWK2II Area Address        X
               (RCOMM)),           ..Pass Common Constants&Routines    X
               PLIST8=YES,         ..Indicate the Parameter List FormatX
               LINKINST=LGR,       ..Indicate the Link Instruction TypeX
               MF=(E,DRBPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Process Address for Load Module Name
         LTGFR R15,R15             Resolve Addr Processing Successful?
         BRZ   DRBT0800            Yes => Branch to Process SVC Info
         LGHI  R2,((DRBT1000-DRBT0800)-4) ...Length of Branch Table
         CGFR  R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   DRBT0800            No  => Branch to Process SVC Info
         BRU   DRBTEXIT            Yes => Branch to Exit This Routine
DRBT0800 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   DRBT1000            Addr Process Completed, Process Info
         BRU   DRBT1000            Branch on Warning-Ignore & Continue
         BRU   DRBTEXIT            Branch on Processing Error - Exit
         BRU   DRBTEXIT            Branch on Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*| Print the Load Module/Csect name, displacement, and address where |*
*| the abending SVC was called from.                                 |*
*|                                                                   |*
*|  For Example:                                                     |*
*|                                                                   |*
*|  -Last Interrupt Event in Program Before Abend-                   |*
*|                                                                   |*
*|  Interrupt Event Location: USRTEST7.LGMT0000+(000E20)             |*
*|  Interrupt Event Address.: 0000000032702148                       |*
*+-------------------------------------------------------------------+*
*
DRBT1000 DS    0H
         CLC   LMOD.LRTLMOD(8),=C'UNKNOWN ' Is Load Module Name Known?
         BRE   DRBTEXIT            No  => Then Branch to Exit Routine
DRBT1100 DS    0H
         MVI   DRBLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DRBLINE+1(L'DRBLINE-1),DRBLINE ...Propogate the Blank
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DRBTEXIT            No  => Then Bypass Print Output
         BRAS  R14,DRBTP100        Print Blank Separator Line to Output
DRBT1200 DS    0H
         MVI   DRBLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DRBLINE+1(L'DRBLINE-1),DRBLINE ...Propogate the Blank
         MVC   DRBOLINE(L'DRBLNHDR),DRBLNHDR .Hdr for Interrupt Summary
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DRBTEXIT            No  => Then Bypass Print Output
         BRAS  R14,DRBTP100        Print the Interrupt Event Header Lne
DRBT1300 DS    0H
         MVI   DRBLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DRBLINE+1(L'DRBLINE-1),DRBLINE ...Propogate the Blank
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DRBTEXIT            No  => Then Bypass Print Output
         BRAS  R14,DRBTP100        Print Blank Separator Line to Output
DRBT1400 DS    0H
         MVI   DRBLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DRBLINE+1(L'DRBLINE-1),DRBLINE ...Propogate the Blank
         MVC   DRBOLINE(L'DRBLOCTN),DRBLOCTN Hdr for Interrupt Location
         MVC   DRBOLINE+L'DRBLOCTN(L'LRTPGMNM),LMOD.LRTPGMNM Module Nme
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DRBTEXIT            No  => Then Bypass Print Output
         BRAS  R14,DRBTP100        Print the Interrupt Event Location
DRBT1500 DS    0H
         MVI   DRBLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DRBLINE+1(L'DRBLINE-1),DRBLINE ...Propogate the Blank
         MVC   DRBOLINE(L'DRBIADDR),DRBIADDR Hdr for Interrupt Address
         LA    R3,DRBINTR@         Last Instruction Before Interrupt
         UNPK  DRBWRK16(9),0(5,R3) Obtain the High-Half Register Value
         UNPK  DRBWRK16+8(9),4(5,R3) Obtain the Low-Half Register Value
         TR    DRBWRK16,HEXCONV-C'0' .Convert to Zoned Character Format
         MVC   DRBOLINE+L'DRBIADDR(L'DRBWRK16),DRBWRK16  Instructn Addr
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DRBTEXIT            No  => Then Bypass Print Output
         BRAS  R14,DRBTP100        Print Interrupt Event Addr to Output
         MVI   DRBLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DRBLINE+1(L'DRBLINE-1),DRBLINE ...Propogate the Blank
         BRAS  R14,DRBTP100        Print Blank Separator Line to Output
*
*+-------------------------------------------------------------------+*
*| Identify the SVC that was called and display the instruction      |*
*| characteristics.                                                  |*
*|                                                                   |*
*|  For Example:                                                     |*
*|                                                                   |*
*|   Instruction at Address..: 0000000032702148                      |*
*|   Machine Instruction.....: 0A13                                  |*
*|   Instruction Op Code.....: 0A                                    |*
*|   Instruction Mnemonic....: SVC      19    (OPEN) Type=4        Ca|*
*|   Instruction Description.: Supervisor Call                       |*
*|   Instruction Format......: SVC nn                                |*
*|   Instruction Type........: I                                     |*
*|   Instruction Attributes..: Does not set Condition Code           |*
*|   Instruction Facility....: None, zArchitecture base              |*
*+-------------------------------------------------------------------+*
*
DRBT2000 DS    0H
         LG    R5,DRBINTR@         Addr of Instruction Before Interrupt
         LLGFR RPCC,PLCA           Our Abending Program's LCA Address
         LA    R4,DRBMCHI@         Adr of Machine Instruction Tbl Entry
         LA    R3,DRBMCHI1         Addr 1st Entry Found in Instruct Tbl
         XC    DRBPLIST,DRBPLIST   Clear the Call Parameter List
         CALL  DABN0000,           Process for SVC Instruction Info    X
               (DRBTARGT,          ..Address of Target of EX Instructn X
               (R3),               ..Pass Addr 1st Entry Found in TableX
               (R4),               ..Pass Addr of Entry in Machine TbleX
               (R5),               ..Pass Addr of Abending Instruction X
               (PLCA),             ..Pass Abending Programs's LCA Addr X
               (RSDW),             ..Pass SDWA Area Address            X
               (RLGW),             ..Pass LGRWK2II Area Address        X
               (RCOMM)),           ..Pass Common Constants&Routines    X
               PLIST8=YES,         ..Indicate the Parameter List FormatX
               LINKINST=LGR,       ..Indicate the Link Instruction TypeX
               MF=(E,DRBPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Find SVC Instruction and Attributes
         LTGFR R15,R15             Instruction Processing Successful?
         BRZ   DRBT2100            Yes => Find Instructions Around SVC
         LGHI  R2,((DRBT2200-DRBT2100)-4) ...Length of Branch Table
         CGFR  R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   DRBT2100            No  => Branch to Process Instructns
         BRU   DRBTEXIT            Yes => Branch to Exit This Routine
DRBT2100 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   DRBT2200            Process Instructions Around the SVC
         BRU   DRBT2200            Branch on Warning-Ignore & Continue
         BRU   DRBTEXIT            Branch on Processing Error - Exit
         BRU   DRBTEXIT            Branch on Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*| Display the instructions the user coded in their program before   |*
*| making the call to the SVC.                                       |*
*+-------------------------------------------------------------------+*
*
DRBT2200 DS    0H
         LLGFR RPCC,PLCA           Our Abending Program's LCA Address
         LA    R4,DRBMCHI1         Adr of Machine Instruction Tbl Entry
         LG    R5,DRBINTR@         Addr of Instruction Before Interrupt
         XC    DRBPLIST,DRBPLIST   Clear the Call Parameter List
         CALL  DIVC0000,           Process for Instructions Around SVC X
               ((R4),              ..Pass Addr of Entry in Machine TbleX
               (R5),               ..Pass Addr of Abending Instruction X
               (PLCA),             ..Pass Abending Programs's LCA Addr X
               (RSDW),             ..Pass SDWA Area Address            X
               (RLGW),             ..Pass LGRWK2II Area Address        X
               (RCOMM)),           ..Pass Common Constants&Routines    X
               PLIST8=YES,         ..Indicate the Parameter List FormatX
               LINKINST=LGR,       ..Indicate the Link Instruction TypeX
               MF=(E,DRBPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Determine Instructions in Vicinity
         LTGFR R15,R15             Vicinity Area Processing Successful?
         BRZ   DRBT2300            Yes => Branch to Process Registers
         LGHI  R2,((DRBT2400-DRBT2300)-4) ...Length of Branch Table
         CGFR  R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   DRBT2300            No  => Branch to Process Registers
         BRU   DRBTEXIT            Yes => Branch to Exit This Routine
DRBT2300 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   DRBT2400            Vicinity Process Done, Process Regs
         BRU   DRBT2400            Branch on Warning-Ignore & Continue
         BRU   DRBTEXIT            Branch on Processing Error - Exit
         BRU   DRBTEXIT            Branch on Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*| Get the Register Contents at entry to SVC. Since an ESTAE was     |*
*| active, the SVRB for the abending SVC is gone by the time the     |*
*| ESTAE recovery routine was entered, and SDWASRSV is used to       |*
*| to acquire the registers of the RB which created the ESTAE at the |*
*| time it last encountered an interrupt.                            |*
*+-------------------------------------------------------------------+*
*
DRBT2400 DS    0H
         LA    R1,DRBT2500         Get Retry Recovery Address (ESPIE)
         ST    R1,LGWRETRY         Preserve It In Case of an Abend
         LLGT  R15,SDWARBAD        Address of SVRB for Abending Program
         LLGT  R14,RBXSB-RBBASIC(,R15) ..Addr to RB Extended Status Blk
         LTGFR R14,R14             Is there an XSB Pointer Available?
         BRZ   DRBT2500            No  => Then Bypass Register Contents
         LMD   R0,R7,XSBG64H-XSB(R14),SDWASRSV  Get Contents of R0 - R7
         STMG  R0,R7,DRBREGS       Save the General Purpose Registers
         LMD   R0,R7,XSBG64H8-XSB(R14),SDWASR08 Get Contents of R8-R15
         STMG  R0,R7,DRBREGS+(DRBRGLEN/2) Save the General Purpose Regs
         XC    LGWRETRY,LGWRETRY   Disable Recovery, Areas Referenced
         BRU   DRBT2600            Process General Purpose Registers
DRBT2500 DS    0H
         XC    LGWRETRY,LGWRETRY   Clear to Disable Abend Recovery
         LA    R15,4               Indicate Error in RB/XSB Access
         ST    R15,DRBRETCD        Set Highest Generated Return Code
         BRU   DRBTEXIT            Unable to Resolve Regs at Interrupt
*
*+-------------------------------------------------------------------+*
*|  Print General Purpose Registers Header Lines                     |*
*|                                                                   |*
*|  General Purpose Registers at Entry to Event.                     |*
*|  Refer to Registers R2-R12 (Low Half).                            |*
*+-------------------------------------------------------------------+*
*
DRBT2600 DS    0H
         MVI   DRBLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DRBLINE+1(L'DRBLINE-1),DRBLINE ...Propogate the Blank
         MVC   DRBOLINE(PRNTLEN),DRBDTLHD  Header 1 for the GPR's Line
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DRBTEXIT            No  => Then Bypass Print Output
         BRAS  R14,DRBTP100        Print GPR Header Statement to Output
DRBT2700 DS    0H
         MVI   DRBLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DRBLINE+1(L'DRBLINE-1),DRBLINE ...Propogate the Blank
         MVC   DRBOLINE(PRNTLEN),DRBDTLH2  Header 2 for the GPR's Line
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DRBTEXIT            No  => Then Bypass Print Output
         BRAS  R14,DRBTP100        Print GPR Header Statement to Output
DRBT2800 DS    0H
         MVI   DRBLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DRBLINE+1(L'DRBLINE-1),DRBLINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*|  Format And Print General Purpose Registers R0 - R3 Detail Line   |*
*|                                                                   |*
*|  0-3   0000000100100000  0000000000007310  0000000000011DB0  00000|*
*+-------------------------------------------------------------------+*
*
DRBT3000 DS    0H
         MVC   DRBSAVER(DRBSALEN),DRBREGS ..Save Regs From Receive Area
         MVC   DRBOLINE+2(3),=C'0-3' Indicate Registers to Set for Prnt
         LA    R2,DRBOLINE+8       Position Start of Register Values
         LA    R3,DRBREGS          Get Starting Address of Reg Values
         LA    R4,L'DRBREGS        Indicate Length of Register Entry
         LA    R5,DRBREGS+(DRBRGLEN/4)-L'DRBREGS  ...For Regs R0 - R3
DRBT3100 DS    0H
         UNPK  DRBWRK16(9),0(5,R3) Obtain the High-Half Register Value
         UNPK  DRBWRK16+8(9),4(5,R3) Obtain the Low-Half Register Value
         TR    DRBWRK16,HEXCONV-C'0' Finalize Conversion to Zoned Char
         MVC   0(L'DRBWRK16,R2),DRBWRK16 .General Purpose Reg to Output
         LA    R2,18(,R2)          Increment to Next Register Field
         BRXLG R3,R4,DRBT3100      Loop to Process the Next Register
DRBT3200 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DRBTEXIT            No  => Then Bypass Print Output
         BRAS  R14,DRBTP100        Print the GPR 0-3 Values to LGRECOUT
DRBT3300 DS    0H
         MVI   DRBLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DRBLINE+1(L'DRBLINE-1),DRBLINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*|  Format And Print General Purpose Registers R4 - R7 Detail Line   |*
*|                                                                   |*
*|  4-7   0000000100000000  0000000000000000  0000000000000000  00000|*
*+-------------------------------------------------------------------+*
*
DRBR3400 DS    0H
         MVC   DRBOLINE+2(3),=C'4-7' Indicate Registers to Set for Prnt
         LA    R2,DRBOLINE+8       Position Start of Register Values
         LA    R3,DRBREGS+(DRBRGLEN/4) ..Starting Address Points to R4
         LA    R4,L'DRBREGS        Indicate Length of Register Entry
         LA    R5,(DRBRGLEN/4)-L'DRBREGS(,R3)  ...For Regs R4 - R7
DRBT3500 DS    0H
         UNPK  DRBWRK16(9),0(5,R3) Obtain the High-Half Register Value
         UNPK  DRBWRK16+8(9),4(5,R3) Obtain the Low-Half Register Value
         TR    DRBWRK16,HEXCONV-C'0' Finalize Conversion to Zoned Char
         MVC   0(L'DRBWRK16,R2),DRBWRK16 .General Purpose Reg to Output
         LA    R2,18(,R2)           Increment to Next Register Field
         BRXLG R3,R4,DRBT3500       Loop to Process the Next Register
DRBT3600 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DRBTEXIT            No  => Then Bypass Print Output
         BRAS  R14,DRBTP100        Print the GPR 4-7 Values to LGRECOUT
DRBT3700 DS    0H
         MVI   DRBLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DRBLINE+1(L'DRBLINE-1),DRBLINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*|  Format And Print General Purpose Registers R8 - R11 Detail Line  |*
*|                                                                   |*
*|  8-11  0000000018105488  0000000000012C40  0000000000011C40  00000|*
*+-------------------------------------------------------------------+*
*
DRBT3800 DS    0H
         MVC   DRBOLINE+2(4),=C'8-11' Indicate Register Set for Prt Lne
         LA    R2,DRBOLINE+8       Position Start of Register Values
         LA    R3,DRBREGS+(DRBRGLEN/2) ..Starting Address Points to R8
         LA    R4,L'DRBREGS        Indicate Length of Register Entry
         LA    R5,(DRBRGLEN/4)-L'DRBREGS(,R3) ...For Regs R8 - R11
DRBT3900 DS    0H
         UNPK  DRBWRK16(9),0(5,R3) Obtain the High-Half Register Value
         UNPK  DRBWRK16+8(9),4(5,R3) Obtain the Low-Half Register Value
         TR    DRBWRK16,HEXCONV-C'0' Finalize Conversion to Zoned Char
         MVC   0(L'DRBWRK16,R2),DRBWRK16 .General Purpose Reg to Output
         LA    R2,18(,R2)           Increment to Next Register Field
         BRXLG R3,R4,DRBT3900       Loop to Process the Next Register
DRBT4000 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DRBTEXIT            No  => Then Bypass Print Output
         BRAS  R14,DRBTP100        Prnt the GPR 8-11 Values to LGRECOUT
DRBT4100 DS    0H
         MVI   DRBLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DRBLINE+1(L'DRBLINE-1),DRBLINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*| Format And Print General Purpose Registers R12 - R15 Detail Line  |*
*|                                                                   |*
*| 12-15 00000000181008BC  0000000000007000  000000000000090E  000000|*
*+-------------------------------------------------------------------+*
*
DRBT4200 DS    0H
         MVC   DRBOLINE+2(5),=C'12-15' Indicate Register Set for Prt Ln
         LA    R2,DRBOLINE+8       Position Start of Register Values
         LA    R3,DRBREGS+(DRBRGLEN/2+DRBRGLEN/4) Address Points to R12
         LA    R4,L'DRBREGS        Indicate Length of Register Entry
         LA    R5,(DRBRGLEN/4)-L'DRBREGS(,R3) ..For Registers R12 - R15
DRBT4300 DS    0H
         UNPK  DRBWRK16(9),0(5,R3) Obtain the High-Half Register Value
         UNPK  DRBWRK16+8(9),4(5,R3) Obtain the Low-Half Register Value
         TR    DRBWRK16,HEXCONV-C'0' Finalize Conversion to Zoned Char
         MVC   0(L'DRBWRK16,R2),DRBWRK16 .General Purpose Reg to Output
         LA    R2,18(,R2)           Increment to Next Register Field
         BRXLG R3,R4,DRBT4300       Loop to Process the Next Register
DRBT4400 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DRBTEXIT            No  => Then Bypass Print Output
         BRAS  R14,DRBTP100        Print GPR 12-15 Values to //LGRECOUT
*
*+-------------------------------------------------------------------+*
*|   Return to Caller                                                |*
*+-------------------------------------------------------------------+*
*
DRBTEXIT DS    0H
         SLGR  R15,R15             Indicate Successful Completion
         ST    R15,DRBRETCD        Set the Return Code
         LPGMEXIT RC=DRBRETCD      Define Program Exit Protocol
*
*+-------------------------------------------------------------------+*
*|         P r i n t   O u t p u t   D e t a i l   L i n e           |*
*+-------------------------------------------------------------------+*
*|SUBROUTINE NAME: DRBTP100                                          |*
*|FUNCTION.......: Print Detail Line to Output Logger Data Set       |*
*+-------------------------------------------------------------------+*
*
DRBTP100 LPGMSUBE                  Set Subroutine Entry Protocol
         SYSSTATE AMODE64=NO,ARCHLVL=2 Generate Code for Not in AMODE64
         SAM31                     Switch Now to 31-Bit Addressing Mode
         PUT   LGWODCB,DRBLINE     Print Output Line to //LGRECOUT
         SAM64                     Switch Back to 64-Bit Address Mode
         SYSSTATE AMODE64=YES,ARCHLVL=2    Restore 64-Bit Environment
         LPGMSUBX                  Return to Caller of This Subroutine
*
*+-------------------------------------------------------------------+*
*|   Definition for Constants                                        |*
*+-------------------------------------------------------------------+*
*
DRBLNHDR DC    C'*** Last Interrupt Event in Program Before Abend ***'
DRBLOCTN DC    C'Interrupt Event Location: '
DRBIADDR DC    C'Interrupt Event Address.: '
DRBDTLHD DC    CL(PRNTLEN)'General Purpose Registers at Entry to Event.X
               '
DRBDTLH2 DC    CL(PRNTLEN)'Refer to Registers R2-R12 (Low Half).'
*
*+-------------------------------------------------------------------+*
*|    Program RENT Work Area                                         |*
*+-------------------------------------------------------------------+*
*
         LCA   DEFINE              Define the Program RENT Work Area
*
DRBWORKD DS    10D                 General Purpose Work Area
DRBPLIST DS    20FD                CALL Parameter List
DRBPARM@ DS    0FD                 Save Area for Passed Parameters
DRBINTR@ DS    AD                  Addr of Instruction Before Interrupt
DRBPLCA@ DS    AD                  Addr of PLCA
DRBMCHI1 DS    AD                  Addr 1st Entry for Machine Tbl Entry
DRBMCHI@ DS    AD                  Addr of Entry for Machine Tble Entry
DRBTARGT DS    AD                  Address of Target of EX Instruction
DRBINTCD DS    FD                  Interrupt Code from Request Block
DRBREGS  DS    0FD                 GP Regs at Entry to Abend Save Area
DRBREG0  DS    13FD                Register Save Area R0-R12
DRBREG13 DS    FD                  Register R13 Save Area
DRBREG14 DS    2FD                 Register Save Area R14-R15
DRBRGLEN EQU   *-DRBREGS           Length of Our R0 thru R15 Area
DRBSAVER DS    0FD                 Save Area for GP Register Values
         DS    16FD                For 16 General Purpose Registers
DRBSALEN EQU   *-DRBSAVER          Length of Register R0 thru R15 Area
DRB$RGNO EQU   (DRBSALEN)/L'DRBSAVER  No. of Entries in Register Area
DRBRETCD DS    F                   Save Area for the Return Code
DRBLMODI DS    CL(LRTLMLEN)        Area for Load Module Information Blk
DRBWRK09 DS    CL9                 General Purpose Work Area
DRBWRK16 DS    CL16                General Purpose Work Area
DRBLINE  DS    0CL133              Output Print Line Area
DRBCCNTL DS    CL1                 Carriage Control Character
DRBOLINE DS    CL132               Output Record Print Area
DRBREGWK DS    0CL(PRNTLEN)        Register Contents Analysis Work Area
         DS    16CL(PRNTLEN)       Work Areas for Register R0 thru R15
DRBWKLEN EQU   *-DRBREGWK          Len of Register R0 thru R15 Wrk Area
DRB$WKNO EQU   (DRBWKLEN)/L'DRBREGWK  No. of Entries in Reg Work Area
*
         LCA   DEFEND              Define End of Program RENT Work Area
*
***********************************************************************
*    End of Processing for Display Instructions Before Interrupt      *
***********************************************************************
         EJECT ,
***********************************************************************
**************************+-----------------+**************************
**************************| D B R K 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|    D i s p l a y   B r e a k i n g   E v e n t   A d d r e s s    |*
*+-------------------------------------------------------------------+*
* PROGRAM NAME:    DBRK0000                                           *
*                                                                     *
* FUNCTION:        This routine attempts to analyze the address in the*
*                  BEAR before the user program abended. The BEAR is  *
*                  known as the Breaking Event Address Register which *
*                  is a 64-bit register that contains the address of  *
*                  the last instruction which caused a break in       *
*                  sequential instruction, and should indicate the    *
*                  last successful branch address. It can be helpful  *
*                  in attempting to diagnose 0C1 or 0C4 abends that   *
*                  are typically the result of where a wild-branch    *
*                  occurs within a program, and you are trying to     *
*                  determine which branch instruction was it and where*
*                  did it come from.                                  *
*                                                                     *
*                  This routine will be passed the Breaking Event     *
*                  Address from the caller. Then this routine will    *
*                  attempt to find where in the user's program does   *
*                  the address in the BEAR point to, determine the    *
*                  instruction at the Breaking Event Address, show    *
*                  the detailed characteristics of the instruction,   *
*                  disassemble the machine code around the area of the*
*                  Breaking Event Address, and display the Assembler  *
*                  source statements preceding the Breaking Event     *
*                  Address.                                           *
*                                                                     *
* For example:                                                        *
*                                                                     *
* *** Last Instruction Causing Break in Sequential Execution Before Ab*
*                                                                     *
* Breaking Event Location: USRTEST7.TVCT0000+(000480)                 *
* Breaking Event Address.: 00000000327079C8                           *
*                                                                     *
* -Instruction Summary-                                               *
*                                                                     *
* Instruction at Address..: 00000000327079C8                          *
* Machine Instruction.....: 0DEF                                      *
* Instruction Op Code.....: 0D                                        *
* Instruction Mnemonic....: BASR     R14,R15                          *
* Instruction Description.: Branch and Save                           *
* Instruction Format......: R1,R2                                     *
* Instruction Type........: RR                                        *
* Instruction Attributes..: Does not set Condition Code; Modal Instruc*
* Instruction Facility....: None, zArchitecture base                  *
*                                                                     *
* -Instructions in Vicinity-                                          *
*                                                                     *
* Hex      Hex Machine                                                *
* Offset   Instruction      Assembler Source Statement           Attri*
* ------   ---------------  -----------------------------------  -----*
*    -58   E320 C60C 0017   LLGT     R2,1548(R0,R12)                  *
*    -52   E3F0 C624 0090   LLGC     R15,1572(R0,R12)                 *
*    -4C   1816             LR       R1,R6                            *
*    -4A   5860 C610        L        R6,1552(R0,R12)                  *
*    -46   B904 00F0        LGR      R15,R0                           *
*    -42   E310 C614 0017   LLGT     R1,1556(R0,R12)                  *
*    -3C   4160 C466        LA       R6,1126(R0,R12)             Modal*
*    -38   5830 C618        L        R3,1560(R0,R12)                  *
*    -34   E3F0 C625 0090   LLGC     R15,1573(R0,R12)                 *
*    -2E   4140 C472        LA       R4,1138(R0,R12)             Modal*
*    -2A   ECBC FF2C 817C   CGIJNH   R11,-127,*-424                   *
*    -24   C25E 0000 0FFE   CLGFI    R5,X'00000FFE'              Sets *
*    -1E   A784 000A        BRC      8,*+20                           *
*    -1A   5850 4000        L        R5,0(R0,R4)                      *
*    -16   E330 D1F8 0004   LG       R3,504(R0,R13)                   *
*    -10   E320 C61C 0017   LLGT     R2,1564(R0,R12)                  *
*     -A   E300 C5F0 0004   LG       R0,1520(R0,R12)                  *
*     -4   B917 00F0        LLGTR    R15,R0                           *
*   ===>   0DEF             BASR     R14,R15                     Modal*
*     +2   E330 0010 0017   LLGT     R3,16(R0,R0)                     *
*     +8   E330 3000 0017   LLGT     R3,0(R0,R3)                      *
*     +E   EBE1 D150 0024   STMG     R14,R1,336(R13)                  *
*    +14   B98D 0001        EPSW     R0,R1                            *
*    +18   9001 D128        STM      R0,R1,296(R13)                   *
*    +1C   E3F0 C1E4 0017   LLGT     R15,484(R0,R12)                  *
*                                                                     *
*                                                                     *
* INPUT REGS:      R1 => Standard O/S Parameter List                  *
*                                                                     *
* INPUT DATA:      Parm1: Address in Breaking Event Address Register  *
*                  Parm2: Address of Abending Program's LCA Area      *
*                  Parm3: Address of System Diagnostic Work Area      *
*                  Parm4: Address of LGRWK2II Logger Work Area        *
*                  Parm5: Addr of Common Constants and Routines Area  *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY, AC=0                          *
*                                                                     *
* CALLING PROGRAM: DSWA0000 - SDWA Diagnostic Information Program     *
*                                                                     *
* CALLED PROGRAMS: LNME0000 - Logger Services Program to Resolve the  *
*                             Breaking Event Address to a Load Module *
*                  DABN0000 - Logger Services Program to Resolve the  *
*                             Breaking Event Address to an Instruction*
*                  DIVC0000 - Logger Services Program to Process the  *
*                             Instructions in Vicinity of the Breaking*
*                             Event Address.                          *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                  04 - Warning                                       *
*                  08 - Error                                         *
*                  12 - Severe Error - Exit This Routine              *
*                                                                     *
***********************************************************************
*
DBRK0000 LPGMNTRY TYPE=SUB,        Define As A Sub-Program Entry       X
               BASE=(12),          Establish Base Registers            X
               AMOD=64,RMOD=ANY,   Addressing and Residency Modes      X
               LCAPFX=DBK,         Establish LCA Prefix for This RSECT X
               LOG=OFF,            Always Turn Logging 'Off' in Logger!X
               LINKRTRN=BSM,       Define Return Linkage Instruction   X
               COPY@RT=YES         To Generate a Copyright Statement
         USING COM_DATA,RCOMM      Addressability to Common Data Area
         USING LGRWK2II,RLGW       Establish Addressability to LGRWK2II
         USING SDWA,RSDW           Establish Addressability to SDWA
         USING IHADCB,LGWODCB      Establish Addressability to DCB
LMOD     USING LRTLMBLK,DBKLMODI   Establish Addressability to LMODI
         LMG   R6,R10,0(R1)        Load the Parameter Area Addresses
         STMG  R6,R7,DBKPARM@      Breaking Event Address and PLCA
         XC    DBKRETCD,DBKRETCD   Initialize the Return Code
*
*+-------------------------------------------------------------------+*
*| Determine the Load Module/Csect name and displacement within the  |*
*| user program where the breaking event occurred.                   |*
*+-------------------------------------------------------------------+*
*
DBRK0100 DS    0H
         LLGFR RPCC,PLCA           Our Abending Program's LCA Address
         LG    R5,DBKEVNT@         Get the Breaking Event Address
         XC    DBKPLIST,DBKPLIST   Clear the Call Parameter List
         CALL  LNME0000,           Process BEA for a Load Module Name  X
               ((R5),              ..Pass the Breaking Event Address   X
               (RPCC),             ..Pass Abending Programs's LCA Addr X
               DBKLMODI,           ..Pass Addr of Load Module Info AreaX
               (RSDW),             ..Pass SDWA Area Address            X
               (RLGW),             ..Pass LGRWK2II Area Address        X
               (RCOMM)),           ..Pass Common Constants&Routines    X
               PLIST8=YES,         ..Indicate the Parameter List FormatX
               LINKINST=LGR,       ..Indicate the Link Instruction TypeX
               MF=(E,DBKPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Process Address for Load Module Name
         LTGFR R15,R15             Resolve Addr Processing Successful?
         BRZ   DBRK0200            Yes => Branch to Process Detail Line
         LGHI  R2,((DBRK1000-DBRK0200)-4) ...Length of Branch Table
         CGFR  R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   DBRK0200            No  => Branch to Process Line Header
         BRU   DBRKEXIT            Yes => Branch to Exit This Routine
DBRK0200 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   DBRK1000            Addr Process Completed, Process Hdr
         BRU   DBRK1000            Branch on Warning-Ignore & Continue
         BRU   DBRKEXIT            Branch on Processing Error - Exit
         BRU   DBRKEXIT            Branch on Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*| Print the Load Module/Csect name, displacement, and address where |*
*| the last breaking event occurred before program abended.          |*
*|                                                                   |*
*|  For Example:                                                     |*
*|                                                                   |*
*|  *** Last Instruction Causing Break in Sequential Execution Before|*
*|                                                                   |*
*|  Breaking Event Location: USRTEST7.LVCT0000+(000480)              |*
*|  Breaking Event Address.: 00000000327079C8                        |*
*+-------------------------------------------------------------------+*
*
DBRK1000 DS    0H
         CLC   LMOD.LRTLMOD(8),=C'UNKNOWN ' Is Load Module Name Known?
         BRE   DBRKEXIT            No  => Then Branch to Exit Routine
DBRK1100 DS    0H
         MVI   DBKLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DBKLINE+1(L'DBKLINE-1),DBKLINE ...Propogate the Blank
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DBRKEXIT            No  => Then Bypass Print Output
         BRAS  R14,DBRKP100        Print Blank Separator Line to Output
DBRK1200 DS    0H
         MVI   DBKLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DBKLINE+1(L'DBKLINE-1),DBKLINE ...Propogate the Blank
         MVC   DBKOLINE(L'DBKLNHDR),DBKLNHDR Hd for Break Event Summary
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DBRKEXIT            No  => Then Bypass Print Output
         BRAS  R14,DBRKP100        Print the Breaking Event Header Line
DBRK1300 DS    0H
         MVI   DBKLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DBKLINE+1(L'DBKLINE-1),DBKLINE ...Propogate the Blank
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DBRKEXIT            No  => Then Bypass Print Output
         BRAS  R14,DBRKP100        Print Blank Separator Line to Output
DBRK1400 DS    0H
         MVI   DBKLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DBKLINE+1(L'DBKLINE-1),DBKLINE ...Propogate the Blank
         MVC   DBKOLINE(L'DBKLOCTN),DBKLOCTN Break Event Location Headr
         MVC   DBKOLINE+L'DBKLOCTN(L'LRTPGMNM),LMOD.LRTPGMNM Module Nme
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DBRKEXIT            No  => Then Bypass Print Output
         BRAS  R14,DBRKP100        Print the Breaking Event Location
DBRK1500 DS    0H
         MVI   DBKLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DBKLINE+1(L'DBKLINE-1),DBKLINE ...Propogate the Blank
         MVC   DBKOLINE(L'DBKIADDR),DBKIADDR  ...Header for the BEAR
         LA    R3,DBKEVNT@         Get Pointer to Breaking Event Addr
         UNPK  DBKWRK16(9),0(5,R3) Obtain the High-Half Register Value
         UNPK  DBKWRK16+8(9),4(5,R3) Obtain the Low-Half Register Value
         TR    DBKWRK16,HEXCONV-C'0' .Convert to Zoned Character Format
         MVC   DBKOLINE+L'DBKIADDR(L'DBKWRK16),DBKWRK16  Instructn Addr
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DBRKEXIT            No  => Then Bypass Print Output
         BRAS  R14,DBRKP100        Print Breaking Event Addr to Output
         MVI   DBKLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DBKLINE+1(L'DBKLINE-1),DBKLINE ...Propogate the Blank
         BRAS  R14,DBRKP100        Print Blank Separator Line to Output
*
*+-------------------------------------------------------------------+*
*| Identify the instruction at the breaking event address and display|*
*| the instruction characteristics.                                  |*
*|                                                                   |*
*|  For Example:                                                     |*
*|                                                                   |*
*|  -Instruction Summary-                                            |*
*|                                                                   |*
*|  Instruction at Address..: 00000000327079C8                       |*
*|  Machine Instruction.....: 0DEF                                   |*
*|  Instruction Op Code.....: 0D                                     |*
*|  Instruction Mnemonic....: BASR     R14,R15                       |*
*|  Instruction Description.: Branch and Save                        |*
*|  Instruction Format......: R1,R2                                  |*
*|  Instruction Type........: RR                                     |*
*|  Instruction Attributes..: Does not set Condition Code; Modal Inst|*
*|  Instruction Facility....: None, zArchitecture base               |*
*+-------------------------------------------------------------------+*
*
DBRK2000 DS    0H
         LG    R5,DBKEVNT@         Get the Breaking Event Address
         LLGFR RPCC,PLCA           Our Abending Program's LCA Address
         LA    R4,DBKMCHI@         Adr of Machine Instruction Tbl Entry
         LA    R3,DBKMCHI1         Addr 1st Entry Found in Instruct Tbl
         XC    DBKPLIST,DBKPLIST   Clear the Call Parameter List
         CALL  DABN0000,           Process for Breaking Event InstructnX
               (DBKTARGT,          ..Address of Target of EX Instructn X
               (R3),               ..Pass Addr 1st Entry Found in TableX
               (R4),               ..Pass Addr of Entry in Machine TbleX
               (R5),               ..Pass Addr of Abending Instruction X
               (PLCA),             ..Pass Abending Programs's LCA Addr X
               (RSDW),             ..Pass SDWA Area Address            X
               (RLGW),             ..Pass LGRWK2II Area Address        X
               (RCOMM)),           ..Pass Common Constants&Routines    X
               PLIST8=YES,         ..Indicate the Parameter List FormatX
               LINKINST=LGR,       ..Indicate the Link Instruction TypeX
               MF=(E,DBKPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Determine Instruction at Break Event
         LTGFR R15,R15             Instruction Processing Successful?
         BRZ   DBRK2100            Yes => Branch to Process Event Addr
         LGHI  R2,((DBRK2200-DBRK2100)-4) ...Length of Branch Table
         CGFR  R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   DBRK2100            No  => Branch to Process Event Addr
         BRU   DBRKEXIT            Yes => Branch to Exit This Routine
DBRK2100 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   DBRK2200            Process Instructions Around BEA
         BRU   DBRK2200            Branch on Warning-Ignore & Continue
         BRU   DBRKEXIT            Branch on Processing Error - Exit
         BRU   DBRKEXIT            Branch on Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*| Display the Instructions Preceding the Breaking Event Address     |*
*+-------------------------------------------------------------------+*
*
DBRK2200 DS    0H
         LLGFR RPCC,PLCA           Our Abending Program's LCA Address
         LA    R4,DBKMCHI1         Adr of Machine Instruction Tbl Entry
         LG    R5,DBKEVNT@         Addr in Breaking Event Addr Register
         XC    DBKPLIST,DBKPLIST   Clear the Call Parameter List
         CALL  DIVC0000,           Process for Instructions Around BEARX
               ((R4),              ..Pass Addr of Entry in Machine TbleX
               (R5),               ..Pass Addr in Break Event Addr Reg X
               (PLCA),             ..Pass Abending Programs's LCA Addr X
               (RSDW),             ..Pass SDWA Area Address            X
               (RLGW),             ..Pass LGRWK2II Area Address        X
               (RCOMM)),           ..Pass Common Constants&Routines    X
               PLIST8=YES,         ..Indicate the Parameter List FormatX
               LINKINST=LGR,       ..Indicate the Link Instruction TypeX
               MF=(E,DBKPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Determine Instructions Around BEAR
         LTGFR R15,R15             Wss BEAR Processing Successful?
         BRZ   DBRK2300            Yes => Branch to Exit This Routine
         LGHI  R2,((DBRKEXIT-DBRK2300)-4) ...Length of Branch Table
         CGFR  R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   DBRK2300            No  => Branch to Exit This Rontine
         BRU   DBRKEXIT            Yes => Branch to Exit This Routine
DBRK2300 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   DBRKEXIT            BEAR Processing Done, Exit
         BRU   DBRKEXIT            Branch on Warning-Ignore & Exit
         BRU   DBRKEXIT            Branch on Processing Error - Exit
         BRU   DBRKEXIT            Branch on Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*|   Return to Caller                                                |*
*+-------------------------------------------------------------------+*
*
DBRKEXIT DS    0H
         SLGR  R15,R15             Indicate Successful Completion
         ST    R15,DBKRETCD        Set the Return Code
         LPGMEXIT RC=DBKRETCD      Define Program Exit Protocol
*
*+-------------------------------------------------------------------+*
*|         P r i n t   O u t p u t   D e t a i l   L i n e           |*
*+-------------------------------------------------------------------+*
*|SUBROUTINE NAME: DBRKP100                                          |*
*|FUNCTION.......: Print Detail Line to Output Logger Data Set       |*
*+-------------------------------------------------------------------+*
*
DBRKP100 LPGMSUBE                  Set Subroutine Entry Protocol
         SYSSTATE AMODE64=NO,ARCHLVL=2 Generate Code for Not in AMODE64
         SAM31                     Switch Now to 31-Bit Addressing Mode
         PUT   LGWODCB,DBKLINE     Print Output Line to //LGRECOUT
         SAM64                     Switch Back to 64-Bit Address Mode
         SYSSTATE AMODE64=YES,ARCHLVL=2    Restore 64-Bit Environment
         LPGMSUBX                  Return to Caller of This Subroutine
*
*+-------------------------------------------------------------------+*
*|   Definition for Constants                                        |*
*+-------------------------------------------------------------------+*
*
DBKLNHDR DC    C'*** Last Instruction Causing Break in Sequential ExecuX
               tion Before Abend ***'
DBKLOCTN DC    C'Breaking Event Location: '
DBKIADDR DC    C'Breaking Event Address.: '
*
*+-------------------------------------------------------------------+*
*|    Program RENT Work Area                                         |*
*+-------------------------------------------------------------------+*
*
         LCA   DEFINE              Define the Program RENT Work Area
*
DBKWORKD DS    10D                 General Purpose Work Area
DBKPLIST DS    20FD                CALL Parameter List
DBKPARM@ DS    0FD                 Save Area for Passed Parameters
DBKEVNT@ DS    AD                  Save Area for Breaking Event Address
DBKPLCA@ DS    AD                  Save Area for Address of PLCA
DBKMCHI1 DS    AD                  Addr 1st Entry for Machine Tbl Entry
DBKMCHI@ DS    AD                  Addr of Entry for Machine Tble Entry
DBKTARGT DS    AD                  Address of Target of EX Instruction
DBKRETCD DS    F                   Save Area for the Return Code
DBKLMODI DS    CL(LRTLMLEN)        Area for Load Module Information Blk
DBKWRK09 DS    CL9                 General Purpose Work Area
DBKWRK16 DS    CL16                General Purpose Work Area
DBKLINE  DS    0CL133              Output Print Line Area
DBKCCNTL DS    CL1                 Carriage Control Character
DBKOLINE DS    CL132               Output Record Print Area
*
         LCA   DEFEND              Define End of Program RENT Work Area
*
***********************************************************************
*End of Processing for Display Instructions Before Breaking Event Addr*
***********************************************************************
         EJECT ,
***********************************************************************
**************************+-----------------+**************************
**************************| D A B N 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|    D e t e r m i n e   A b e n d i n g   I n s t r u c t i o n    |*
*+-------------------------------------------------------------------+*
* PROGRAM NAME:    DABN0000                                           *
*                                                                     *
* FUNCTION:        Determine Abending Instruction                     *
*                                                                     *
*                  This routine is responsible for determining the    *
*                  abending instruction from an address. The address  *
*                  of the failing instruction was passed to this      *
*                  routine from the calling program. This routine     *
*                  will then take that address and pass it to called  *
*                  program DINS0000 which will determine the actual   *
*                  instruction, and display detailed information on   *
*                  the characteristics of the abending instruction.   *
*                                                                     *
*                  Upon return from DINS0000, this routine will check *
*                  if the abend occurred on an Execute instruction. If*
*                  no, then exit from this routine. If yes, then the  *
*                  address of the target instruction of the Execute   *
*                  will be determined. This routine will pass that    *
*                  address in a second call to DINS0000 to display the*
*                  characteristics of the target instruction to be    *
*                  executed by the Execute instruction.               *
*                                                                     *
* INPUT REGS:      R1 => Standard O/S Parameter List                  *
*                                                                     *
* INPUT DATA:      Parm1: Pointer to Field for Addr of Target Instruct*
*                  Parm2: Address of Field for Machine Table Entry    *
*                  Parm3: Address of Failing Instruction              *
*                  Parm4: Address of Abending Program's LCA Area      *
*                  Parm5: Address of System Diagnostic Work Area      *
*                  Parm6: Address of LGRWK2II Logger Work Area        *
*                  Parm7: Addr of Common Constants and Routines Area  *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY, AC=0                          *
*                                                                     *
* CALLING PROGRAM: DSWA0000 - SDWA Diagnostic Information Program     *
*                  DRBT0000 - Logger Services Program to Determine the*
*                             Last SVC Event Before Abend.            *
*                  DBRK0000 - Logger Services Program to Process the  *
*                             Breaking Event Address Before Abend.    *
*                                                                     *
* CALLED PROGRAMS: DINS0000 - Logger Services Program to Determine the*
*                             the Abending Instruction Characteristics*
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                  04 - Warning                                       *
*                  08 - Error                                         *
*                  12 - Severe Error - Exit This Routine              *
*                                                                     *
***********************************************************************
*
DABN0000 LPGMNTRY TYPE=SUB,        Define As A Sub-Program Entry       X
               BASE=(12),          Establish Base Registers            X
               AMOD=64,RMOD=ANY,   Addressing and Residency Modes      X
               LCAPFX=DAB,         Establish LCA Prefix for This RSECT X
               LOG=OFF,            Always Turn Logging 'Off' in Logger!X
               LINKRTRN=BSM,       Define Return Linkage Instruction   X
               COPY@RT=YES         To Generate a Copyright Statement
         USING COM_DATA,RCOMM      Addressability to Common Data Area
         USING LGRWK2II,RLGW       Establish Addressability to LGRWK2II
         USING SDWA,RSDW           Establish Addressability to SDWA
         USING IHADCB,LGWODCB      Establish Addressability to DCB
         LMG   R3,R10,0(R1)        Load the Parameter Area Addresses
         STMG  R3,R5,DABPARM@      Target Field and Machine Entry Field
         XC    DABRETCD,DABRETCD   Initialize the Return Code
*
*+-------------------------------------------------------------------+*
*|  Find the abending instruction in the machine code table and      |*
*|  display the instruction characteristics in the //LGRECOUT data   |*
*|  set.                                                             |*
*+-------------------------------------------------------------------+*
*
DABN0100 DS    0H
         MVI   DABOPCDE,C' '       To Set-up Op Code Field With Blanks
         MVC   DABOPCDE+1(L'DABOPCDE-1),DABOPCDE ...Propogate the Blank
         XC    DABOPREV,DABOPREV   Clear Previous Instructn Op Cd Field
         LG    R3,DABMCHI@         Addr of Entry Found in Machine Table
         LA    R4,DABOPREV         Get Addr of Previous Op Code Field
         LA    R5,DABOPCDE         Start Addr of Op Code Fields to Pass
         XC    DABPLIST,DABPLIST   Clear the Call Parameter List
         CALL  DINS0000,           Process for Abending Instruction    X
               ((R3),              ..Pass Addr of Entry in Machine TbleX
               (R4),               ..Pass Addr of Previous Op Cde FieldX
               (R5),               ..Pass Addr of Area to Return Op CdeX
               (R6),               ..Pass Addr of Abending Instruction X
               (PLCA),             ..Pass Abending Programs's LCA Addr X
               (RSDW),             ..Pass SDWA Area Address            X
               (RLGW),             ..Pass LGRWK2II Area Address        X
               (RCOMM)),           ..Pass Common Constants&Routines    X
               PLIST8=YES,         ..Indicate the Parameter List FormatX
               LINKINST=LGR,       ..Indicate the Link Instruction TypeX
               MF=(E,DABPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Determine the Abending Instruction
         ST    R15,DABRETCD        Save Return Code From Called Program
         LTGFR R15,R15             Instruction Processing Successful?
         BRZ   DABN0200            Yes => Check If Executed Instruction
         LGHI  R2,((DABN0300-DABN0200)-4) ...Length of Branch Table
         CGFR  R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   DABN0200            No  => Check If Executed Instruction
         BRU   DABNEXIT            Yes => Branch to Exit This Routine
DABN0200 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   DABN0300            Instr Process Completed, Check If EX
         BRU   DABN0300            Branch on Warning-Ignore & Continue
         BRU   DABNEXIT            Branch on Processing Error - Exit
         BRU   DABNEXIT            Branch on Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*|  Determine If Abending Instruction Was From Execute Instruction   |*
*+-------------------------------------------------------------------+*
*
DABN0300 DS    0H
         LG    R1,DABMCHI1         Address to the Address of Tble Entry
         LG    R3,0(,R3)           Get Addr of Machine Tble Entry Found
         STG   R3,0(,R1)           Save Adr of Machine Tble Entry Found
         CLC   DABOPCDE,=CL4'44'   Was This for an Execute Instruction?
         BRE   DABN1000            Yes => Process for Target of Execute
         CLC   DABOPCDE,=CL4'C60'  An Extended Execute Instruction?
         BRE   DABN2000            Yes => Process for Target of Execute
         BRU   DABNEXIT            No  => Then Branch to Exit Routine
*
*+-------------------------------------------------------------------+*
*|  Determine address of target instruction of Execute instruction   |*
*|  where Execute instruction uses type RX-a format 'R1,D2(X2,B2)'.  |*
*|                                                                   |*
*|  For example:                                                     |*
*|                                                                   |*
*|               D2                                                  |*
*|           X2  |                                                   |*
*|           |  +-+                                                  |*
*|        44E3 73A4  <---- EX machine code example:                  |*
*|        | |  |              EX  R14,LABEL1A(R3)                    |*
*|        | R1 B2             44  E   73A4    3                      |*
*|      Op-Cde                                                       |*
*+-------------------------------------------------------------------+*
*
         USING SDWAPTRS,R4         Addressability to Extension Ptr Area
DABN1000 DS    0H
         CLI   SDWAILC1,X'04'      Instruction Leng Code Match Execute?
         BRNE  DABNEXIT            No  => Then Branch to Exit Routine
DABN1100 DS    0H
         SLGR  R15,R15             Used to Hold Index Register Number
         XC    DABWORKD(1),DABWORKD ...To Check the RX Field Position
         MVN   DABWORKD(1),1(R6)   Drop R1 Field and Extract X2 Field
         CLI   DABWORKD,X'00'      The X2 Field Indicate Register Zero?
         BRE   DABN1400            Yes => Branch to Process B2 Field
DABN1200 DS    0H
         LLGC  R15,DABWORKD        Get the Index Register Number Used
         LLGT  R4,SDWAXPAD         Addr of SDWA Extension Pointers Area
         ICM   R4,B'1111',SDWAXEME Do We Have a Pointer to 64-bit Info?
         BRZ   DABN1300            No  => Then Pull 31-bit Registers
X2       USING SDWARC4,R4          Addressability to 64-bit Info Area
         SLLG  R15,R15,3 Bits      Multiply by 8 for 64-Bit Registers
         LG    R15,X2.SDWAG64(R15) Point to Index Register of Execute
         BRU   DABN1400            Branch to Process the B2 Field
         DROP  X2                  Remove Listed Reg as Base Register
DABN1300 DS    0H
         SLLG  R15,R15,2 Bits      Multiply by 4 for 31-Bit Registers
         LLGT  R15,SDWAGRSV(R15)   Point to Index Register of Execute
DABN1400 DS    0H
         XC    DABWORKD(2),DABWORKD ...To Check the B2 Field Position
         MVO   DABWORKD(2),2(1,R6) Get the B2 Field Used in the Execute
         LLGC  R1,DABWORKD         Get the Base Register Number Used
         LTGR  R1,R1               The B2 Field Indicate Register Zero?
         BRZ   DABN1700            Yes => Branch to Process D2 Field
         LLGT  R4,SDWAXPAD         Addr of SDWA Extension Pointers Area
         ICM   R4,B'1111',SDWAXEME Do We Have a Pointer to 64-bit Info?
         BRZ   DABN1500            No  => Then Pull 31-bit Registers
B2       USING SDWARC4,R4          Addressability to 64-bit Info Area
         SLLG  R1,R1,3 Bits        Multiply by 8 for 64-Bit Registers
         LG    R2,B2.SDWAG64(R1)   Base Register Value Used in Execute
         BRU   DABN1700            Branch to Process the D2 Field
         DROP  B2                  Remove Listed Reg as Base Register
DABN1500 DS    0H
         SLLG  R1,R1,2 Bits        Multiply by 4 for 31-Bit Registers
         LLGT  R2,SDWAGRSV(R1)     Index Register Value Used in Execute
DABN1700 DS    0H
         LLGH  R3,2(,R6)           To Obtain the Contents of D2 Field
         NILL  R3,(X'0FFF')        Drop the B2 so only D2 Value Remains
         ALGR  R2,R3               Add Addr in B2 to Displacement in D2
         LA    R1,0(R15,R2)        Now Add X2, B2, and D2 for Address
         CLGR  R1,R6               Target of Execute the Same Execute?
         BRU   DABN3000            No  => Then Determine Instruction
         BRU   DABNEXIT            Yes => Let the S0C3 Tell the Story
         DROP  R4                  Remove Listed Register as Base Reg
*
*+-------------------------------------------------------------------+*
*|  Determine address of target instruction of the Execute Relative  |*
*|  Long (EXRL) instruction which uses type RIL-b format 'R1,RI2'.   |*
*|                                                                   |*
*|  For example:                                                     |*
*|                                                                   |*
*|            RI2                                                    |*
*|   Op-Cde    |                                                     |*
*|    || | +-------+                                                 |*
*|    C6E0 0000 1575 <---- EXRL machine code example:                |*
*|      |                     EXRL  R14,LABEL1A                      |*
*|      R1                    C60   E   00001575                     |*
*|  For OR'ing                                                       |*
*+-------------------------------------------------------------------+*
*
DABN2000 DS    0H
         CLI   SDWAILC1,X'06'      Instruction Leng Code Match Execute?
         BRNE  DABNEXIT            No  => Then Branch to Exit Routine
DABN2100 DS    0H
         SLGR  R15,R15             Used to Hold Contents of I2 Field
         ICM   R15,B'1111',2(R6)   Relative Adr RI2 Positive Halfwords?
         BRNM  DABN2200            Yes => Then Target Range is Ahead
         LCGFR R15,R15             Otherwise Its Behind, Make Positive
         SLLG  R15,R15,1 Bit       Multiple by 2 for No. of Halfwords
         LNGR  R15,R15             Revert to Add Negative Value to Addr
         BRU   DABN2300            Branch to Calculate Target Address
DABN2200 DS    0H
         SLLG  R15,R15,1 Bit       Multiple by 2 for No. of Halfwords
DABN2300 DS    0H
         LA    R1,0(R15,R6)        RI2*2 Plus Address Points to Target
*
*+-------------------------------------------------------------------+*
*| The address to be passed points to the instruction to be executed |*
*| by the Execute instruction. The Op Code from this instruction will|*
*| be used to find the instruction details in the machine code table |*
*| to display the characteristics of the target instruction of the   |*
*| Execute.                                                          |*
*+-------------------------------------------------------------------+*
*
DABN3000 DS    0H
         MVC   DABOPREV,DABOPCDE   Save Previous Instruction Op Code
         MVI   DABOPCDE,C' '       To Set-up Op Code Field With Blanks
         MVC   DABOPCDE+1(L'DABOPCDE-1),DABOPCDE ...Propogate the Blank
         LG    R2,DABTARG@         Get Addr of Field for Instructn Addr
         STG   R1,0(,R2)           Save Addr of Target of Abending EX
         LG    R3,DABMCHI@         Get Addr of Field to Hold Table Addr
         LA    R4,DABOPREV         Get Addr of Previous Op Code Field
         LA    R5,DABOPCDE         Get Address of Op Code Field to Pass
         LGR   R6,R1               Address of the Abending Instruction
         XC    DABPLIST,DABPLIST   Clear the Call Parameter List
         CALL  DINS0000,           Process for Abending Instruction    X
               ((R3),              ..Pass Addr of Field for Machine TblX
               (R4),               ..Pass Addr of Previous Op Cde FieldX
               (R5),               ..Pass Addr of Area to Return Op CdeX
               (R6),               ..Pass Addr of Abending Instruction X
               (PLCA),             ..Pass Abending Programs's LCA Addr X
               (RSDW),             ..Pass SDWA Area Address            X
               (RLGW),             ..Pass LGRWK2II Area Address        X
               (RCOMM)),           ..Pass Common Constants&Routines    X
               PLIST8=YES,         ..Indicate the Parameter List FormatX
               LINKINST=LGR,       ..Indicate the Link Instruction TypeX
               MF=(E,DABPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Determine Target Instruction of Ex
         LTGFR R15,R15             Instruction Processing Successful?
         BRZ   DABN3100            Yes => Done, Branch to Exit
         LGHI  R2,((DABNEXIT-DABN3100)-4) ...Length of Branch Table
         CGFR  R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   DABN3100            No  => Branch to Exit This Routine
         BRU   DABNEXIT            Yes => Branch to Exit This Routine
DABN3100 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   DABNEXIT            Target Instruction Process Completed
         BRU   DABNEXIT            Branch on Warning-Ignore & Continue
         BRU   DABNEXIT            Branch on Processing Error - Exit
         BRU   DABNEXIT            Branch on Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*|   Return to Caller                                                |*
*+-------------------------------------------------------------------+*
*
DABNEXIT DS    0H
         LLGF  R15,DABRETCD        Set the Return Code
         LPGMEXIT RC=DABRETCD      Define Program Exit Protocol
*
*+-------------------------------------------------------------------+*
*|    Program RENT Work Area                                         |*
*+-------------------------------------------------------------------+*
*
         LCA   DEFINE              Define the Program RENT Work Area
*
DABWORKD DS    10D                 General Purpose Work Area
DABPLIST DS    20FD                CALL Parameter List
DABPARM@ DS    0FD                 Save Area for Passed Parameters
DABTARG@ DS    AD                  Addr of Field for Target Instruction
DABMCHI1 DS    AD                  Addr 1st Entry Found in Machine Tble
DABMCHI@ DS    AD                  Addr of Field for Machine Tble Entry
*
DABRETCD DS    F                   Save Area for the Return Code
DABOPCDE DS    CL4                 Save Area for Instruction Op Code
DABOPREV DS    CL4                 Save Area for Previous Op Code
DABLINE  DS    0CL133              Output Print Line Area
DABCCNTL DS    CL1                 Carriage Control Character
DABOLINE DS    CL132               Output Record Print Area
*
         LCA   DEFEND              Define End of Program RENT Work Area
*
***********************************************************************
*          End of Abending Instruction Information Processing         *
***********************************************************************
         EJECT ,
***********************************************************************
**************************+-----------------+**************************
**************************| D I N S 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|D i s p l a y  I n s t r u c t i o n  C h a r a c t e r i s t i c s|*
*+-------------------------------------------------------------------+*
* PROGRAM NAME:    DINS0000                                           *
*                                                                     *
* FUNCTION:        Display Abending Instruction Characteristics       *
*                                                                     *
*                  This routine is responsible for determining the    *
*                  abending instruction from an address, and then     *
*                  processing the instruction characteristics to be   *
*                  displayed in the Logger output data set //LGRECOUT.*
*                                                                     *
*                  This routine will perform a sequential search of a *
*                  machine instruction table containing all of the    *
*                  operation codes, instruction mnemonics, instruction*
*                  attributes, and instruction descriptions for       *
*                  zArchitecture instructions. Instructions with      *
*                  single byte op code fields and extended op code    *
*                  fields are contained in one table. The machine     *
*                  instructions in the table are sorted ascending on  *
*                  the operation code. The search begins by extracting*
*                  the first byte pointed to by the failng instruction*
*                  address passed to this routine. The initial search *
*                  of the table begins by using the first byte of the *
*                  op-code, even if the instruction has a two byte    *
*                  op-code. If there is no match, this routine will   *
*                  exit as the failing instruction address was most   *
*                  likely invalid, or was pointing at a halfword      *
*                  boundary in a data area with a starting byte that  *
*                  matches a valid op-code but failed to conform to   *
*                  the designated instruction format or attributes    *
*                  set in the machine code table, and was not an      *
*                  instruction.                                       *
*                                                                     *
*                  If a match, then the instruction format is checked *
*                  to verify if the instruction has an extended op-   *
*                  code. If no, then the instruction has a one byte   *
*                  op-code, the instruction has been found in the     *
*                  table, and the search is done. If a yes for an     *
*                  extended op-code field, the remaining portion of   *
*                  the extended op-code is extracted from the failing *
*                  instruction based on its field position correspond-*
*                  ing to the instruction format. The search is reset *
*                  to look for the extended op code, and the search   *
*                  retries from where it left off in the table. If the*
*                  search on the extended op-code for the failing     *
*                  instruction then finds a match in the machine      *
*                  instruction table, then the search is done. If no  *
*                  match, then not an instruction and this routine    *
*                  will set a RC=08 and exit.                         *
*                                                                     *
*                  Once a matching machine instruction op code from   *
*                  the abending instruction has been found in the z/OS*
*                  machine instruction table, additional validity     *
*                  checking is performed on the instruction address   *
*                  for halfword alignment and proper instruction      *
*                  length. If the validity checking fails, it would   *
*                  indicate that the instruction address may be mis-  *
*                  aligned, or the instruction was the wrong length   *
*                  when compared to what the ILC indicated in the     *
*                  SDWA, or the instruction address was invalid. In   *
*                  that event this routine will set a RC=08 and exit. *
*                                                                     *
*                  If the instruction validation is successful, then  *
*                  a disassemble of the hex machine code representing *
*                  the abending instruction will be performed where   *
*                  the hex format machine code will be converted into *
*                  a character format Assembler language source       *
*                  statement. To convert to Assembler source a call is*
*                  made to program DXMC0000 in which this routine will*
*                  pass an address pointing to a blank work area for  *
*                  DXMC0000 to build an assembler source statement.   *
*                  Also passed will be an address pointing to the     *
*                  entry found in the machine instruction table for   *
*                  the abending instruction, an address pointing to a *
*                  storage area containing the machine code of the    *
*                  abending instruction in the user's program, and an *
*                  address pointing to a blank work area to place an  *
*                  extended mnemonic description which may be appended*
*                  to the instruction. If DXMC0000 returns with an    *
*                  error, then this routine will set a RC=08 and exit.*
*                                                                     *
*                  Upon return from the call to DXMC0000 with no      *
*                  errors, then this program DINS0000 will have       *
*                  sufficient information to print the detailed       *
*                  characteristics of the abending instruction in an  *
*                  Abending Instruction Summary report which is       *
*                  written to the output Logger data set //LGRECOUT.  *
*                                                                     *
*  Output Example:                                                    *
*  ---------------                                                    *
*                                                                     *
*  -Instruction Summary-                                              *
*                                                                     *
*   Instruction at Address..: 00000000186073F0                        *
*   Machine Instruction.....: 44F0 73C0                               *
*   Instruction Op Code.....: 44                                      *
*   Instruction Mnemonic....: EX     R15,960(R0,R7)                   *
*   Instruction Description.: Execute                                 *
*   Instruction Format......: R1,D2(X2,B2)                            *
*   Instruction Type........: RX-a                                    *
*   Instruction Attributes..: Does not set Condition code             *
*   Instruction Facility....: None, zArchitecture base                *
*                                                                     *
*   -Executed Target Instruction Summary-                             *
*                                                                     *
*   Instruction at Address..: 0000000018608FE0                        *
*   Target Instruction......: EC00 383F 0855                          *
*   Instruction Op Code.....: EC55                                    *
*   Instruction Mnemonic....: RISBG  R0,R0,56,63,8                    *
*   Instruction Description.: Rotate Then Insert Selected Bits Grande *
*   Instruction Format......: R1,R2,I3,I4,I5                        *
*   Instruction Type........: RIE-f                                   *
*   Instruction Attributes..: Sets Condition Code                     *
*   Instruction Facility....: General-instructions-extension facility *
*                                                                     *
*                                                                     *
* INPUT REGS:      R1 => Standard O/S Parameter List                  *
*                                                                     *
* INPUT DATA:      Parm1: Address of Field for Machine Table Entry    *
*                  Parm2: Address of Previous Op Code Area            *
*                  Parm3: Address of Return Op Code Area              *
*                  Parm4: Address of Abending Instruction             *
*                  Parm5: Address of Abending Program's LCA Area      *
*                  Parm6: Address of System Diagnostic Work Area      *
*                  Parm7: Address of LGRWK2II Logger Work Area        *
*                  Parm8: Addr of Common Constants and Routines Area  *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY, AC=0                          *
*                                                                     *
* CALLING PROGRAM: DABN0000 - Logger Services Program to Resolve an   *
*                             Address to the Abending Instruction     *
*                                                                     *
* CALLED PROGRAMS: DXMC0000 - Logger Services Program to Disassemble  *
*                             Machine Code into Assembler Source for  *
*                             Abending Instruction.                   *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                  04 - Warning                                       *
*                  08 - Error                                         *
*                  12 - Severe Error - Exit This Routine              *
*                                                                     *
***********************************************************************
*
DINS0000 LPGMNTRY TYPE=SUB,        Define As A Sub-Program Entry       X
               BASE=(12),          Establish Base Registers            X
               AMOD=64,RMOD=ANY,   Addressing and Residency Modes      X
               LCAPFX=DIN,         Establish LCA Prefix for This RSECT X
               LOG=OFF,            Always Turn Logging 'Off' in Logger!X
               LINKRTRN=BSM,       Define Return Linkage Instruction   X
               COPY@RT=YES         To Generate a Copyright Statement
         USING COM_DATA,RCOMM      Addressability to Common Data Area
         USING LGRWK2II,RLGW       Establish Addressability to LGRWK2II
         USING SDWA,RSDW           Establish Addressability to SDWA
         USING IHADCB,LGWODCB      Establish Addressability to DCB
         LMG   R3,R10,0(R1)        Load the Parameter Area Addresses
         STMG  R3,R5,DINPARM@      Save Contents of Passed Parameters
         XC    DINRETCD,DINRETCD   Initialize the Return Code
*
*+-------------------------------------------------------------------+*
*| Search the zArchitecture Machine Instruction Table to find the    |*
*| table entry that matches the op-code of the abending instruction. |*
*+-------------------------------------------------------------------+*
*
         USING OP@CODES,R3         Addressability Machine Instructions
DINS0100 DS    0H
         LA    R1,DINS0800         Get Retry Recovery Address (ESPIE)
         ST    R1,LGWRETRY         Preserve It In Case of an Abend
         XC    DINOPCDE,DINOPCDE   Clear Op Code Area of Residual Data
         LLGC  R0,0(,R6)           Instruction Op Code for Failed Instr
         LTGR  R0,R0               Is There an Available Op Code?
         BRZ   DINS0800            No  => Zero is Never a Valid Op-Code
         STC   R0,DINOPCDE         Save the Machine Instruction Op-Code
         MVI   DINOPCLN,X'01'      Set the Indicator for 8-Bit Op-Code
         LLILL R2,(1)              Begin Search on a One Byte Op-Code
         LG    R3,=AD(OPC$ZARC)    Address of Machine Instruction Table
         LLILL R4,(OPC$ZNUM)       No. of Machine Instruction Entries
DINS0200 DS    0H
         CLM   R0,0,OP@MCHCD       OpCode That Failed Compared to Table
         EX    R2,*-4              Our Machine Instruction Op-Code?
         BRNE  DINS0700            No  => Then Check Next Entry in Tble
         CLI   OP@OPRND+1,X'01'    Instruction Have a One Byte Op-Code?
         BRE   DINS0900            Yes => Done, Process Instruction
         CLM   R0,B'0010',=X'00'   Instruction Have a Two Byte Op-Code?
         BRNE  DINS0900            Yes => Done, Process Instruction
DINS0300 DS    0H
         SLLG  R0,R0,8 Bits        To Make Room for 2nd Byte of Op Code
         MVO   DINOPWRK(2),OP@OPRND+1(1) ..Position of 2nd Op-Code Byte
         LLGC  R5,DINOPWRK         Position of 2nd Op-Cde Byte as Index
         LA    R1,0(R5,R6)         Point to 2nd Op-Code Byte in Instruc
         CGHI  R5,(1)              12-Bit as Opposed to 16-Bit Op-Code?
         BRE   DINS0500            Yes => Extended Op Cde Field 12-Bits
         LTGR  R5,R5               Contiguous 16-Bit Extended Op-Code?
         BRNZ  DINS0400            No  => Bifarcated 16-Bit Extended Op
         LA    R1,1(,R1)           Increment One Byte Over for Op-Code
DINS0400 DS    0H
         ICM   R0,B'0001',0(R1)    Get the 2nd Byte for 16-Bit Op-Code
         MVI   DINOPCLN,X'03'      Set the Indicator for 16-Bit Op-Code
         BRU   DINS0600            Branch to Continue Search for Op-Cde
DINS0500 DS    0H
         XC    DINOPWRK(2),DINOPWRK To Clear Work Area of Residual Data
         MVO   DINOPWRK(2),0(1,R1) Extract the Op Code Field Nibble
         MVI   DINOPCLN,X'02'      Set the Indicator for 12-Bit Op-Code
         ICM   R0,B'0001',DINOPWRK+1 .Expand 12-Bit Op Code into 16-Bit
DINS0600 DS    0H
         STH   R0,DINOPCDE         Save the Machine Instruction Op-Code
         LLILL R2,(3)              CLM Mask to 0011 for Extended Op-Cde
         BRU   DINS0200            Now Retry Same Place Where Left Off
DINS0700 DS    0H
         LA    R3,OP@NTRYL(,R3)    Increment to Next Instruction Entry
         BRCTG R4,DINS0200         => Loop to Search for Machine Op-Cde
DINS0800 DS    0H
         XC    LGWRETRY,LGWRETRY   Clear to Disable Abend Recovery
         LA    R15,8               Indicate Error in Search Process
         ST    R15,DINRETCD        Set Highest Generated Return Code
         BRU   DINSEXIT            Machine Instruction Op-Cde Not Found
*
*+-------------------------------------------------------------------+*
*|Check the instruction for proper halfword alignment and for correct|*
*|instruction length. If valid convert the hex machine instruction to|*
*|a printable character format.                                      |*
*|                                                                   |*
*| For example: If abending instruction a STCM                       |*
*|     Hex    to    Character                                        |*
*|   BE1734D6==> C2C5F1F7F3F4C4F6                                    |*
*|               B E 1 7 3 4 D 6                                     |*
*+-------------------------------------------------------------------+*
*
DINS0900 DS    0H
         LA    R15,8               ILC Mismatch or Not Halfwrd Boundary
         ST    R15,DINRETCD        Set the Generated Return Code
         ST    R15,LGWREAS$        Set Reason Code on Invalid Instructn
         TMLL  R6,(X'0001')        Instructn Addr not Halfwrd Boundary?
         BRO   DINS1100            Yes => Instruction Address is Odd
         CLC   OP@OPRND(1),SDWAILC1 Does Instruction Length Code Match?
         BRE   DINS1000            Yes => Process this Instruction
         LG    R1,DINOPREV         Get Addr of Area for Previous Op-Cde
         ICM   R15,B'1111',0(R1)   Is a Previous Op-Code Indicated?
         BRNZ  DINS1000            Yes => Have Target of EX Instruction
         CLC   DINOPCDE,=X'0A00'   Machine Instruction Op-Code for SVC?
         BRE   DINS1000            Yes => Product of a Secondary Event
         BRU   DINS1100            No  => Not Target of EX or 2nd Event
DINS1000 DS    0H
         XC    DINRETCD,DINRETCD   Reset RC on ILC and Halfwrd Align Ok
         XC    LGWREAS$,LGWREAS$   Reset Reason Cde on ILC and Align Ok
         LG    R1,DINMCHI@         Address to Hold Address of Tbl Entry
         STG   R3,0(,R1)           Save Adr of Machine Tble Entry Found
         MVI   DININSTR,C' '       Set-up to Fill Work Area with Blanks
         MVC   DININSTR+1(L'DININSTR-1),DININSTR ...Propogate the Blank
         LA    R2,DININSTR         Get Addr of Instruction Output Area
         LLGC  R14,OP@OPRND        Obtain Leng in Bytes of Instruction
         LA    R15,DINOPWRK        Addr of Instruction Data Work Area
         LGR   R4,R14              Current Leng in Bytes of Instruction
         SLLG  R4,R4,1 Bit         Multiply the Current Length by Two
         LGR   R5,R4               Expand Length for a Character Format
         SLLG  R5,R5,4 Bits        Char Len Shifted to 1st Len Position
         OGR   R5,R14              Put the Two Unpack Lengths Together
         UNPK  DINOPWRK(0),0(0,R6) Indicated Target of the Execute
         EX    R5,*-6              Unpack Instruction to a Work Area
         BCTGR R4,R0               Decrement Length for the Execute
         EX    R4,TRNSLATE         Translate Hex to Character Format
* trnslate tr   0(*-*,R15),hexconv-c'0' ...Commented Target of Execute
         MVC   0(0,R2),DINOPWRK    Indicated Target of the Next Execute
         EX    R4,*-6              Displayable Instruction to Hold Area
         XC    LGWRETRY,LGWRETRY   Recovery Off, Instruction Referenced
         NI    LGWFLAG,255-LGWSDUMP Disable Dump Suppression Indicator
         BRU   DINS2000            Verify and Disassemble Machine Code
DINS1100 DS    0H
         XC    LGWRETRY,LGWRETRY   There is No Instruction to Reference
         NI    LGWFLAG,255-LGWSDUMP Disable Dump Suppression Indicator
         BRU   DINSEXIT            Branch to Exit This Routine
*
*+-------------------------------------------------------------------+*
*| Disassemble the hex machine code for the abending instruction, and|*
*| convert it into an assembler language source statement.           |*
*+-------------------------------------------------------------------+*
*
DINS2000 DS    0H
         MVI   DINWAREA,C' '       Set-up to Fill Work Area with Blanks
         MVC   DINWAREA+1(L'DINWAREA-1),DINWAREA ...Propogate the Blank
         MVI   DINXTEND,C' '       To Fill Mnemonic Area with Blanks
         MVC   DINXTEND+1(L'DINXTEND-1),DINXTEND ...Propogate the Blank
         LA    R2,DINWAREA         Get Address of Instruction Work Area
         LA    R5,DINXTEND         Get Addr of Extended Mnemonic Area
         LG    R4,DINOPREV         Get Addr of Area for Previous Op-Cde
         MVC   0(L'OP@MNEUM,R2),OP@MNEUM  Source Instruction Mnemonic
         LA    R2,L'OP@MNEUM+2(,R2) Increment to End of Instruction Nme
         XC    DINPLIST,DINPLIST   Clear the Call Parameter List
         CALL  DXMC0000,           Disassemble Hex Notation Machine CdeX
               ((R2),              ..Pass Addr of Area to Build Source X
               (R3),               ..Pass Addr of Machine Table Entry  X
               (R6),               ..Pass Addr of Machine Code InstructX
               (R5),               ..Pass Addr of Area for Ext MnemonicX
               (R4),               ..Pass Addr of Area for Prev Op-CodeX
               (RLGW),             ..Pass LGRWK2II Area Address        X
               (RCOMM)),           ..Pass Common Constants&Routines    X
               PLIST8=YES,         ..Indicate the Parameter List FormatX
               LINKINST=LGR,       ..Indicate the Link Instruction TypeX
               MF=(E,DINPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Disassemble the Machine Instruction
         LTGFR R15,R15             Was Disassemble Process Successful?
         BRZ   DINS2100            Yes => Branch to Print Output Lines
         LGHI  R2,((DINS2200-DINS2100)-4) ...Length of Branch Table
         CGFR  R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   DINS2100            No  => Branch to Process Output Line
         BRU   DINSEXIT            Yes => Branch to Exit This Routine
DINS2100 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   DINS3000            Disassemble Completed, Print Header
         BRU   DINS3000            Branch on Warning-Ignore & Continue
         BRU   DINS2200            Branch on Process Error, Set RSN Cde
         BRU   DINS2200            Branch on Severe Error, Set RSN Code
DINS2200 DS    0H
         ST    R15,LGWREAS$        Set Reason Code on Invalid Instructn
         ST    R15,DINRETCD        Set Return Code on Invalid Instructn
         BRU   DINSEXIT            Branch on Disassemble Error, Exit
*
*+-------------------------------------------------------------------+*
*|  Format and Print the Abending Instruction Summary Header Line    |*
*|                                                                   |*
*|  -Instruction Summary-                                            |*
*+-------------------------------------------------------------------+*
*
DINS3000 DS    0H
         MVI   DINLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DINLINE+1(L'DINLINE-1),DINLINE ...Propogate the Blank
         MVI   DINCCNTL,C' '       Set Carriage Control to Single Space
         LA    R2,DINOLINE         Obtain the Address of Output Line
         LG    R1,DINOPREV         Get Addr of Area for Previous Op Cde
         ICM   R15,B'1111',0(R1)   Is a Previous Op-Code Indicated?
         BRZ   DINS3100            No  => Hdr for Abending Instruction
         MVC   0(L'DINLNHD2,R2),DINLNHD2  Hdr for a Target Instruction
         BRU   DINS3200            Branch to Print Instruction Header
DINS3100 DS    0H
         MVC   0(L'DINLNHDR,R2),DINLNHDR Add Header Text to Header Line
DINS3200 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DINSEXIT            No  => Then Bypass Print Output
DINS3300 DS    0H
         BRAS  R14,DINSP100        Abend Detail Hdr Line to //LGRECOUT
DINS3400 DS    0H
         MVI   DINLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DINLINE+1(L'DINLINE-1),DINLINE ...Propogate the Blank
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DINSEXIT            No  => Then Bypass Print Output
DINS3500 DS    0H
         BRAS  R14,DINSP100        Blank Separator Line to //LGRECOUT
*
*+-------------------------------------------------------------------+*
*|  Format and Print the Instruction Address Detail Line             |*
*|                                                                   |*
*|  Instruction at Address..: 00000000186073F0                       |*
*+-------------------------------------------------------------------+*
*
DINS3600 DS    0H
         MVI   DINLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DINLINE+1(L'DINLINE-1),DINLINE ...Propogate the Blank
         LA    R2,DINOLINE         Obtain the Address of Output Line
         MVC   0(L'DINSTRAD,R2),DINSTRAD Add Header Text to Detail Line
         LA    R2,L'DINSTRAD(,R2)  Increment to End of Detail Line Hdr
         STG   R6,DINWORKD         Copy Instruction Address to Wrk Area
         UNPK  DINOPWRK(9),DINWORKD(5) Get the High-Half Address Value
         UNPK  DINOPWRK+8(9),DINWORKD+4(5) Get Low-Half Address Value
         TR    DINOPWRK,HEXCONV-C'0' Finalize Conversion to Zoned Char
         MVC   0(L'DINOPWRK,R2),DINOPWRK Instruction Addr to Outpt Line
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DINSEXIT            No  => Then Bypass Print Output
DINS3700 DS    0H
         BRAS  R14,DINSP100        Print the Instruction Address Line
*
*+-------------------------------------------------------------------+*
*|  Format and Print the the Abending Instruction Detail Line        |*
*|                                                                   |*
*|  Abending Instruction....: BE17 34B6                              |*
*+-------------------------------------------------------------------+*
*
DINS3800 DS    0H
         MVI   DINLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DINLINE+1(L'DINLINE-1),DINLINE ...Propogate the Blank
         LA    R2,DINOLINE         Obtain the Address of Output Line
         LG    R1,DINOPREV         Get Addr of Area for Previous Op Cde
         ICM   R15,B'1111',0(R1)   Is a Previous Op Code Indicated?
         BRZ   DINS3900            No  => Process Abending Instruction
         MVC   0(L'DINTARGT,R2),DINTARGT  Hdr for a Target Instruction
         LA    R2,L'DINTARGT(,R2)  Increment to End of the Header Text
         BRU   DINS4000            Branch to Process Target Instruction
DINS3900 DS    0H
         MVC   0(L'DINABNDI,R2),DINABNDI Add Header Text to Detail Line
         LA    R2,L'DINABNDI(,R2)  Increment to End of the Header Text
DINS4000 DS    0H
         MVC   0(L'DININSTR/4,R2),DININSTR 1st Halfword of Instruction
         CLI   OP@OPRND,X'02'      Is Instruction Length 1 Halfword?
         BRE   DINS4100            Yes => Branch to Print Instruction
         LA    R2,L'DININSTR/4+1(,R2) Increment for 2nd Halfword
         MVC   0(L'DININSTR/4,R2),DININSTR+L'DININSTR/4 2nd Halfword
         CLI   OP@OPRND,X'04'      Is Instruction Length 2 Halfwords?
         BRE   DINS4100            Yes => Branch to Print Instruction
         LA    R2,L'DININSTR/4+1(,R2) Increment for 3rd Halfword
         MVC   0(L'DININSTR/4,R2),DININSTR+L'DININSTR/2 3rd Halfword
DINS4100 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DINSEXIT            No  => Then Bypass Print Output
DINS4200 DS    0H
         BRAS  R14,DINSP100        Print Abending Instructn to LGRECOUT
*
*+-------------------------------------------------------------------+*
*|  Format and Print the Instruction Op Code Detail Line             |*
*|                                                                   |*
*|  Instruction Op Code.....: BE                                     |*
*+-------------------------------------------------------------------+*
*
DINS4300 DS    0H
         MVI   DINLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DINLINE+1(L'DINLINE-1),DINLINE ...Propogate the Blank
         LA    R2,DINOLINE         Obtain the Address of Output Line
         MVC   0(L'DINOPCOD,R2),DINOPCOD Add Header Text to Detail Line
         LA    R2,L'DINOPCOD(,R2)  Increment to End of the Header Text
         UNPK  DINOPWRK(5),DINOPCDE(3)   Get the Instruction Op Code
         TR    DINOPWRK(4),HEXCONV-C'0'  Final Conversion to Zoned Char
         LLGC  R15,DINOPCLN        Get Length of Instruction Op Code
         MVC   0(0,R2),DINOPWRK    Indicated Target of the Execute
         EX    R15,*-6             Instruction Op Code to Output Line
         LG    R1,DINOPCD@         Get Addr of Area to Return Op Code
         MVC   0(0,R1),0(R2)       Indicated Target of the Execute
         EX    R15,*-6             Copy the Op Code into Return Area
DINS4400 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DINSEXIT            No  => Then Bypass Print Output
DINS4500 DS    0H
         BRAS  R14,DINSP100        Print Instruction Op Cde to LGRECOUT
*
*+-------------------------------------------------------------------+*
*| Format and Print the Detail Line for the Assembler Language Source|*
*| Statement for the Abending Instruction.                           |*
*|                                                                   |*
*|  Instruction Mnemonic....: STCM   R1,B'0111',1206(R3)             |*
*+-------------------------------------------------------------------+*
*
DINS4600 DS    0H
         MVI   DINLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DINLINE+1(L'DINLINE-1),DINLINE ...Propogate the Blank
         LA    R2,DINOLINE         Obtain the Address of Output Line
         MVC   0(L'DINMNEUM,R2),DINMNEUM Add Header Text to Detail Line
         LA    R2,L'DINMNEUM(,R2)  Increment to End of the Header Text
         MVC   0(L'DINWAREA,R2),DINWAREA ...Assembler Source Statement
DINS4700 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DINSEXIT            No  => Then Bypass Print Output
DINS4800 DS    0H
         BRAS  R14,DINSP100        Print Assembler Instruction to Outpt
*
*+-------------------------------------------------------------------+*
*|  Format and Print the Instruction Description Detail Line         |*
*|                                                                   |*
*|  Instruction Description.: Store Characters under Mask (low)      |*
*+-------------------------------------------------------------------+*
*
DINS4900 DS    0H
         MVI   DINLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DINLINE+1(L'DINLINE-1),DINLINE ...Propogate the Blank
         LA    R2,DINOLINE         Obtain the Address of Output Line
         MVC   0(L'DINDESCR,R2),DINDESCR Add Header Text to Detail Line
         LA    R2,L'DINDESCR(,R2)  Increment to End of the Header Text
         MVC   0(L'OP@DESCR,R2),OP@DESCR  Mnemonic Description to Outpt
         CLC   DINXTEND,BLANKS     Add Extended Mnemonic Description?
         BRE   DINS5500            No  => Description Not Available
DINS5000 DS    0H
         LA    R1,DINOLINE         Obtain Address of Output Line
         LGR   R15,R1              Hold Starting Address of Output Line
         LA    R5,L'DINOLINE-1     Get Length of the Output Line Area
         LA    R1,0(R5,R15)        Point to the End of Output Line Area
         LA    R14,1               Check is for One Byte at a Time
         LNGR  R14,R14             To Scan Backwards Through Output Lne
         LLGC  R2,=C' '            Search Is For Trailing Blanks
DINS5100 DS    0H
         BRXHG R1,R14,DINS5200     Find the End of Text Going Backward
         BRU   DINS5300            Branch to Process the Text Length
DINS5200 DS    0H
         CLM   R2,B'0001',0(R1)    Is This a Blank Character?
         BRNE  DINS5300            No  => Found End of Our Description
         BRU   DINS5100            Loop to Check the Next Byte in Field
DINS5300 DS    0H
         LA    R5,1(,R1)           Point to End of Instruct Description
         SGR   R1,R15              Calculate Length of Description Text
         BRNP  DINS5500            Branch If Nothing Is Left
DINS5400 DS    0H
         LA    R5,1(,R5)           Increment to Position for Descriptor
         MVC   0(L'DINXTEND,R5),DINXTEND  Extended Mnemonic Description
DINS5500 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DINSEXIT            No  => Then Bypass Print Output
DINS5600 DS    0H
         BRAS  R14,DINSP100        Instruction Description to LGRECOUT
*
*+-------------------------------------------------------------------+*
*|  Format and Print the Instruction Format Detail Line              |*
*|                                                                   |*
*|  Instruction Format......: R1,M3,D2(B2)                           |*
*+-------------------------------------------------------------------+*
*
DINS5700 DS    0H
         MVI   DINLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DINLINE+1(L'DINLINE-1),DINLINE ...Propogate the Blank
         LA    R2,DINOLINE         Obtain the Address of Output Line
         MVC   0(L'DINFORMT,R2),DINFORMT Add Header Text to Detail Line
         LA    R2,L'DINFORMT(,R2)  Increment to End of the Header Text
         MVC   0(L'OP@FORMT,R2),OP@FORMT  Instruction Format to Output
DINS5800 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DINSEXIT            No  => Then Bypass Print Output
DINS5900 DS    0H
         BRAS  R14,DINSP100        Print Instruction Format to LGRECOUT
*
*+-------------------------------------------------------------------+*
*|  Format and Print the Instruction Type Detail Line                |*
*|                                                                   |*
*|  Instruction Type........: RS-b                                   |*
*+-------------------------------------------------------------------+*
*
DINS6000 DS    0H
         MVI   DINLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DINLINE+1(L'DINLINE-1),DINLINE ...Propogate the Blank
         LA    R2,DINOLINE         Obtain the Address of Output Line
         MVC   0(L'DINSTYPE,R2),DINSTYPE Add Header Text to Detail Line
         LA    R2,L'DINSTYPE(,R2)  Increment to End of the Header Text
         MVC   0(L'OP@TYPE,R2),OP@TYPE Instruction Format Type to Outpt
DINS6100 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DINSEXIT            No  => Then Bypass Print Output
DINS6200 DS    0H
         BRAS  R14,DINSP100        Print Instruction Type to //LGRECOUT
*
*+-------------------------------------------------------------------+*
*|  Format and Print the Instruction Attributes Detail Line          |*
*|                                                                   |*
*|  Instruction Attributes..: Does not set Condition code            |*
*+-------------------------------------------------------------------+*
*
         USING OPC$ATTR,R5         Addressability to Attributes Table
DINS6300 DS    0H
         MVI   DINLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DINLINE+1(L'DINLINE-1),DINLINE ...Propogate the Blank
         LA    R2,DINOLINE         Obtain the Address of Output Line
         MVC   0(L'DINSATTR,R2),DINSATTR Add Header Text to Detail Line
         LA    R2,L'DINSATTR(,R2)  Increment to End of the Header Text
         LG    R5,=AD(OPC$ATTR)    Addr of Instruction Attributes Table
         LLILL R4,(OPC$ANBR)       No. of Instruction Attribute Entries
DINS6400 DS    0H
         CLC   OPC$ATTR(L'OP@ATTR1),OP@ATTR1  Is This our Attribute?
         BRE   DINS6600            Yes => Process Instruction Attribute
DINS6500 DS    0H
         LA    R5,L'OPC$ATTR(,R5)  Increment to Next Attribute Entry
         BRCTG R4,DINS6400         Loop to Check Next Instruction Attr
         BRU   DINS6700            Branch if Attributes Were Not Found
DINS6600 DS    0H
         MVC   0(OPC$ATLN,R2),OPC$ATTR+2 Instruction Attr to Output
         DROP  R5                  Remove Listed Reg as Attr Table Base
DINS6700 DS    0H
         TM    OP@MODES,X'80'      Is this a zArch Modal Instruction?
         BRZ   DINS7300            No  => Branch to Process Attributes
DINS6800 DS    0H
         LA    R1,DINOLINE         Obtain Address of Output Line
         LGR   R15,R1              Hold Starting Address of Output Line
         LA    R5,L'DINOLINE-1     Get Length of the Output Line Area
         LA    R1,0(R5,R15)        Point to the End of Output Line Area
         LA    R14,1               Check is for One Byte at a Time
         LNGR  R14,R14             To Scan Backwards Through Output Lne
         LLGC  R2,=C' '            Search Is For Trailing Blanks
DINS6900 DS    0H
         BRXHG R1,R14,DINS7000     Find End of Attr Text Going Backward
         BRU   DINS7100            Branch to Process the Text Length
DINS7000 DS    0H
         CLM   R2,B'0001',0(R1)    Is This a Blank Character?
         BRNE  DINS7100            No  => Branch to Determine Length
         BRU   DINS6900            Loop to Check the Next Byte in Field
DINS7100 DS    0H
         LA    R5,1(,R1)           Point to End of Current Attributes
         SGR   R1,R15              Calculate Leng of Current Attr Text
         BRNP  DINS7300            Branch If Nothing Is Left
DINS7200 DS    0H
         MVI   0(R5),C';'          Set Semicolon for Modal Attribute
         LA    R5,2(,R5)           Increment Past Semicolon for Attr
         MVC   0(17,R5),=CL17'Modal Instruction' Indicate Modal Instruc
DINS7300 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DINSEXIT            No  => Then Bypass Print Output
DINS7400 DS    0H
         BRAS  R14,DINSP100        Print Instruction Attr to //LGRECOUT
*
*+-------------------------------------------------------------------+*
*|  Format and Print the Detail Line for any Hardware Dependence the |*
*|  Abending Instruction May Have for Extended Facilities.           |*
*|                                                                   |*
*|  Instruction Facility....: None, zArchitecture base               |*
*+-------------------------------------------------------------------+*
*
         USING OPC$FCIL,R5         Addressability to Facilities Table
DINS7500 DS    0H
         MVI   DINLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DINLINE+1(L'DINLINE-1),DINLINE ...Propogate the Blank
         LA    R2,DINOLINE         Obtain the Address of Output Line
         MVC   0(L'DINFACIL,R2),DINFACIL Add Header Text to Detail Line
         LA    R2,L'DINFACIL(,R2)  Increment to End of the Header Text
         LG    R5,=AD(OPC$FCIL)    Addr of Instruction Facilities Table
         LLILL R4,(OPC$FANO)       No. of Instruction Facility Entries
DINS7600 DS    0H
         CLC   OPC$FCIL(L'OP@FACIL),OP@FACIL  Is This our Facility ID?
         BRE   DINS7800            Yes => Process Instruction Facility
DINS7700 DS    0H
         LA    R5,L'OPC$FCIL(,R5)  Increment to Next Facility Entry
         BRCTG R4,DINS7600         Loop to Check Next Instruction Facil
         BRU   DINS7900            Branch if Facilities Were Not Found
DINS7800 DS    0H
         MVC   0(OPC$F2LN,R2),OPC$FCIL+OPC$F1LN Copy Facility to Output
DINS7900 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DINSEXIT            No  => Then Bypass Print Output
DINS8000 DS    0H
         BRAS  R14,DINSP100        Print Instruction Facility to Output
DINS8100 DS    0H
         USING PSA,R0              Establish Addressability to the PSA
         MVI   DINLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DINLINE+1(L'DINLINE-1),DINLINE ...Propogate the Blank
         LA    R2,DINOLINE+L'DINFACIL Obtain the Address of Output Line
DINS8200 DS    0H
         CLC   OP@MCHCD,=XL2'B22B' Is This a Set Storage Key Extended?
         BRNE  DINS8300            No  => Check Next Instruction Group
         TM    FLCFACL0,FLCFSSKE   Conditional-SSKE facility installed?
         BRZ   DINS8700            No  => Then No Further Processing
         MVC   0(L'DINFSSKE,R2),DINFSSKE  Subject to Conditional-SSKE
         BRU   DINS8500            Branch to Print Facility Attribute
DINS8300 DS    0H
         CLC   OP@MCHCD,=XL2'B2A6' Is This a Convert Unicode to UTF-8?
         BRE   DINS8400            Yes => ETF3 has M3 Bits Significance
         CLC   OP@MCHCD,=XL2'B2A7' Is This a Convert UTF-8 to Unicode?
         BRE   DINS8400            Yes => ETF3 has M3 Bits Significance
         CLC   OP@MCHCD,=XL2'B9B0' Is This a Convert UTF-8 to UTF-32?
         BRE   DINS8400            Yes => ETF3 has M3 Bits Significance
         CLC   OP@MCHCD,=XL2'B9B1' Is This a Convert UTF-16 to UTF-32?
         BRNE  DINS8700            No  => Then No Facility Attributes
DINS8400 DS    0H
         TM    FLCFACL3,FLCFET3E   ETF3-enhancement Facility Installed?
         BRZ   DINS8700            No  => Then No Further Processing
         MVC   0(L'DINFETF3,R2),DINFETF3 Instruction is Subject to ETF3
         DROP  R0                  Remove Listed Reg as PSA Base Reg
DINS8500 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DINSEXIT            No  => Then Bypass Print Output
DINS8600 DS    0H
         BRAS  R14,DINSP100        Print Facility Attributes to Output
DINS8700 DS    0H
         MVI   DINLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DINLINE+1(L'DINLINE-1),DINLINE ...Propogate the Blank
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DINSEXIT            No  => Then Bypass Print Output
         BRAS  R14,DINSP100        Blank Separator Line to //LGRECOUT
         DROP  R5                  Remove Listed Reg as Facility Base
         DROP  R3                  Remove Listed Reg as Instrn Tbl Base
*
*+-------------------------------------------------------------------+*
*|   Return to Caller                                                |*
*+-------------------------------------------------------------------+*
*
DINSEXIT DS    0H
         LLGF  R15,DINRETCD        Set the Return Code
         LPGMEXIT RC=DINRETCD      Define Program Exit Protocol
*
*+-------------------------------------------------------------------+*
*|         P r i n t   O u t p u t   D e t a i l   L i n e           |*
*+-------------------------------------------------------------------+*
*|SUBROUTINE NAME: DINSP100                                          |*
*|FUNCTION.......: Print Detail Line to Output Logger Data Set       |*
*+-------------------------------------------------------------------+*
*
DINSP100 LPGMSUBE                  Set Subroutine Entry Protocol
         SYSSTATE AMODE64=NO,ARCHLVL=2 Generate Code for Not in AMODE64
         SAM31                     Switch Now to 31-Bit Addressing Mode
         PUT   LGWODCB,DINLINE     Print Output Line to //LGRECOUT
         SAM64                     Switch Back to 64-Bit Address Mode
         SYSSTATE AMODE64=YES,ARCHLVL=2    Restore 64-Bit Environment
         LPGMSUBX                  Return to Caller of This Subroutine
*
*+-------------------------------------------------------------------+*
*|   Definition for Constants                                        |*
*+-------------------------------------------------------------------+*
*
DINLNHDR DC    C'-Instruction Summary-'      Instruction Summary Header
DINLNHD2 DC    C'-Executed Target Instruction Summary-' Target Instruct
DINSTRAD DC    C'Instruction at Address..: ' Instruction Addr Detail Ln
DINABNDI DC    C'Machine Instruction.....: ' Abending Instruction Line
DINTARGT DC    C'Target Instruction......: ' Target Instruction Detail
DINOPCOD DC    C'Instruction Op Code.....: ' Op Cde Detail Line Header
DINMNEUM DC    C'Instruction Mnemonic....: ' Mnemonic Detail Line
DINDESCR DC    C'Instruction Description.: ' Mnemonic Description Line
DINFORMT DC    C'Instruction Format......: ' Instruction Format Detail
DINSTYPE DC    C'Instruction Type........: ' Instruction Type Detail Ln
DINSATTR DC    C'Instruction Attributes..: ' Instruction Attributes Lne
DINFACIL DC    C'Instruction Facility....: ' Instruction Facilities Lne
DINFETF3 DC    C'ETF3-enhancement facility installed: M3 settings have X
               added significance'
DINFSSKE DC    C'Conditional-SSKE facility installed: M3 settings have X
               added significance'
*
*+-------------------------------------------------------------------+*
*|    Program RENT Work Area                                         |*
*+-------------------------------------------------------------------+*
*
         LCA   DEFINE              Define the Program RENT Work Area
*
DINWORKD DS    10D                 General Purpose Work Area
DINPLIST DS    20FD                CALL Parameter List
DINPARM@ DS    0FD                 Save Area for Passed Parameters
DINMCHI@ DS    AD                  Addr of Field for Machine Tble Entry
DINOPREV DS    AD                  Address of Area for Previous Op Code
DINOPCD@ DS    AD                  Address of Area to Return Op Code
*
DINRETCD DS    F                   Save Area for the Return Code
DINOPCDE DS    H                   Save Area for Instruction Op Code
DINOPCLN DS    XL1                 Save Area for the Op Code Length
DINOPWRK DS    XL16                Work Area for Unpacking Instruction
         DS    XL1                 Slack for Reverse of Low Order Byte
DININSTR DS    CL16                Area for Instructn in Character Form
DINXTEND DS    CL16                Area for Extended Mnemonic Format
DINWAREA DS    CL100               Work Area for Disassembled Instructn
DINLINE  DS    0CL133              Output Print Line Area
DINCCNTL DS    CL1                 Carriage Control Character
DINOLINE DS    CL132               Output Record Print Area
*
         LCA   DEFEND              Define End of Program RENT Work Area
*
***********************************************************************
*     End of Display Abending Instruction Characteristics Process     *
***********************************************************************
         EJECT ,
***********************************************************************
**************************+-----------------+**************************
**************************| D I V C 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|D e t e r m i n e   I n s t r u c t i o n s   i n   V i c i n i t y|*
*+-------------------------------------------------------------------+*
* PROGRAM NAME:    DIVC0000                                           *
*                                                                     *
* FUNCTION:        Determine Instructions in Vicinity of Abend        *
*                                                                     *
*                  This routine is responsible for determining the    *
*                  instructions prior to and after the failing        *
*                  instruction. In this routine an attempt is made to *
*                  disassemble code from a given start address in a   *
*                  storage area containing the hexadecimal machine    *
*                  code that was generated by the assembler for the   *
*                  instructions around the failing instruction        *
*                  address. So basically just try to disassemble a    *
*                  bunch of hex bytes in a chuck of storage around the*
*                  area of the abend.                                 *
*                                                                     *
*                  First from the failing instruction address a call  *
*                  is made to LNME0000 to verify that the abend did   *
*                  occur within a load module, and to establish the   *
*                  displacement of the failing instruction within the *
*                  load module. In addition the abending load module  *
*                  starting address and ending address is determined. *
*                  Next arbitrarily backup 128 bytes from the failing *
*                  instruction address, and check if that proposed    *
*                  starting address is within range of the main       *
*                  storage block address for the abending load module.*
*                  If yes then an ending address 48 bytes past the    *
*                  failing instruction address is checked to verify if*
*                  it is within range of the main storage block       *
*                  address for the abending module. If either check   *
*                  fails, then one further attempt is made to squeeze *
*                  the address range around the failng instruction by *
*                  using the load module starting and ending address  *
*                  range. Then this storage area containing our hex   *
*                  machine code is copied to a work area.             *
*                                                                     *
*                  Next from the arbitrary start point in the storage *
*                  area preceding the failed instruction, step through*
*                  the storage area going forward one halfword at a   *
*                  time. Each halfword increment is run through the   *
*                  machine code table in an attempt to verify if the  *
*                  hex data in storage would represent machine code   *
*                  for a valid assembler instruction. If a storage    *
*                  area on a halfword boundary cannot be validated as *
*                  actual machine code for an assembler instruction,  *
*                  then move forward to the next halfword in storage  *
*                  and retry. Continue to run the storage area through*
*                  the machine instruction table one halfword at a    *
*                  time in order to find a valid instruction. If hex  *
*                  code is found that appears to be an instruction,   *
*                  then the instruction length attribute of 2, 4, or 6*
*                  bytes is pulled from the machine code table, and   *
*                  added to the current address. This will point to   *
*                  the next potential instruction which again is      *
*                  validity checked against the machine instruction   *
*                  table. If an invalid instruction is found probably *
*                  due to hitting a constant area, then reset the     *
*                  counters, and go back to halfword searches until a *
*                  valid instruction is found again to restart the    *
*                  count. Continue this process until a sufficient    *
*                  sequence of at least 7 or more consecutive valid   *
*                  instructions is found immediately preceding the    *
*                  failed instruction. Determining a consecutive      *
*                  instruction sequence in this first pass is meant to*
*                  establish a start address in the storage area that *
*                  would most likely represent a valid instruction set*
*                  for successful second pass processing. If the      *
*                  instruction count of at least 7 instructions       *
*                  preceding the failing instruction cannot be met,   *
*                  then exit this routine.                            *
*                                                                     *
*                  Next perform a second pass through the storage area*
*                  beginning at the starting address established from *
*                  the first pass. Get the instruction description    *
*                  entry from the machine instruction table, and then *
*                  call DXMC0000 to disassemble the instruction into  *
*                  an Assembler language source statement. In the call*
*                  to program DXMC0000 there will be passed an address*
*                  pointing to a work area to return the assembler    *
*                  source statement. Also passed will be an address   *
*                  pointing to the instruction description entry in   *
*                  the machine instruction table for the instruction  *
*                  being processed, and an address pointing to the    *
*                  hex machine code for the instruction in the load   *
*                  module. DXMC0000 performs additional validity      *
*                  checking, and the instruction may fail the more    *
*                  detailed analysis in second pass processing. If the*
*                  disassembler returns with an error attempting to   *
*                  process an instruction, then this routine will set *
*                  a RC=08 and exit. Otherwise, continuing looping    *
*                  through the work area containing the list of hex   *
*                  machine codes until all instructions are completely*
*                  disassembled.                                      *
*                                                                     *
*                  Next print the output report. The report will show *
*                  a negative displacement hex offset for instructions*
*                  preceding the failed instruction, and a positive   *
*                  displacement hex offset for those instructions     *
*                  listed after the failed instruction. The actual    *
*                  failing instruction will be flagged with a right   *
*                  arrow (===>). The report will show the hex machine *
*                  code for the instruction, the source statement, and*
*                  any special attributes indicating whether the      *
*                  instruction sets the condition code, is a modal    *
*                  instruction, a privileged instruction, or other    *
*                  attributes.                                        *
*                                                                     *
*Output example:                                                      *
*                                                                     *
*-Instructions in Vicinity-                                           *
*                                                                     *
* Hex      Hex Machine                                                *
* Offset   Instruction      Assembler Source Statement           Attri*
* ------   ---------------  -----------------------------------  -----*
*    -3A   960F D1A7        OI       423(R13),X'0F'              Sets *
*    -36   F317 D20A D1A0   UNPK     522(2,R13),416(8,R13)            *
*    -30   1810             LR       R1,R0                            *
*    -2E   4E10 D1A0        CVD      R1,416(R0,R13)                   *
*    -2A   960F D1A7        OI       423(R13),X'0F'              Sets *
*    -26   F317 D20C D1A0   UNPK     524(2,R13),416(8,R13)            *
*    -20   D205 D1A0 D208   MVC      416(6,R13),520(R13)              *
*    -1A   92F0 D1A6        MVI      422(R13),X'F0'                   *
*    -16   F236 D219 D1A0   PACK     537(4,R13),416(7,R13)            *
*    -10   F833 D20E CC58   ZAP      526(4,R13),3160(4,R12)      Sets *
*     -A   47F0 C422        BC       15,1058(R0,R12)                  *
*     -6   F871 D1A0 D210   ZAP      416(8,R13),528(2,R13)       Sets *
*   ===>   FA72 D1A0 D216   AP       416(8,R13),534(3,R13)       Sets *
*     +6   8CE0 003F        SRDL     R14,63                           *
*     +A   BFF6 D20E        ICM      R15,B'0110',526(R13)        Sets *
*     +E   BFF1 CCDA        ICM      R15,B'0001',3290(R12)       Sets *
*    +12   88F0 0004        SRL      R15,4                            *
*    +16   90EF D1A8        STM      R14,R15,424(R13)                 *
*    +1A   4FF0 D1A8        CVB      R15,424(R0,R13)                  *
*                                                                     *
*                                                                     *
* INPUT REGS:      R1 => Standard O/S Parameter List                  *
*                                                                     *
* INPUT DATA:      Parm1: Address of Entry in Machine Instruction Tble*
*                  Parm2: Address of Failing Instruction              *
*                  Parm3: Address of Abending Program's LCA Area      *
*                  Parm4: Address of System Diagnostic Work Area      *
*                  Parm5: Address of LGRWK2II Logger Work Area        *
*                  Parm6: Addr of Common Constants and Routines Area  *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY, AC=0                          *
*                                                                     *
* CALLING PROGRAM: DSWA0000 - SDWA Diagnostic Information Program     *
*                  DRBT0000 - Logger Services Program to Determine the*
*                             Last SVC Event Before Abend.            *
*                  DBRK0000 - Logger Services Program to Process the  *
*                             Breaking Event Address Before Abend.    *
*                                                                     *
* CALLED PROGRAMS: LNME0000 - Logger Services Program to Resolve an   *
*                             Address to a Load Module Name.          *
*                  DXMC0000 - Logger Services Program to Disassemble  *
*                             Machine Code into an Assembler Source   *
*                             Statement.                              *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                  04 - Warning                                       *
*                  08 - Error                                         *
*                  12 - Severe Error - Exit This Routine              *
*                                                                     *
***********************************************************************
*
DIVC0000 LPGMNTRY TYPE=SUB,        Define As A Sub-Program Entry       X
               BASE=(12,11),       Establish Base Registers            X
               AMOD=64,RMOD=ANY,   Addressing and Residency Modes      X
               LCAPFX=DVC,         Establish LCA Prefix for This RSECT X
               LOG=OFF,            Always Turn Logging 'Off' in Logger!X
               LINKRTRN=BSM,       Define Return Linkage Instruction   X
               COPY@RT=YES         To Generate a Copyright Statement
         USING COM_DATA,RCOMM      Addressability to Common Data Area
         USING LGRWK2II,RLGW       Establish Addressability to LGRWK2II
         USING IHADCB,LGWODCB      Establish Addressability to DCB
LMOD     USING LRTLMBLK,DVCLMODI   Establish Addressability to LMODI
         LMG   R5,R10,0(R1)        Load the Parameter Area Addresses
         STMG  R5,R8,DVCPARM@      Preserve the Input Parameters
         XC    DVCRETCD,DVCRETCD   Initialize the Return Code
*
*+-------------------------------------------------------------------+*
*| Obtain location of the abending instruction within a load module  |*
*+-------------------------------------------------------------------+*
*
DIVC0100 DS    0H
         XC    DVCPLIST,DVCPLIST   Clear the Call Parameter List
         CALL  LNME0000,           Process Storage Address for Mod NameX
               ((R6),              ..Pass Storage Addr to Be Resolved  X
               (PLCA),             ..Pass Abending Program LCA Address X
               DVCLMODI,           ..Pass Addr of Load Module Info AreaX
               (RSDW),             ..Pass Address of the SDWA          X
               (RLGW),             ..Pass LGRWK2II Area Address        X
               (RCOMM)),           ..Pass Common Constants&Routines    X
               PLIST8=YES,         ..Indicate the Parameter List FormatX
               LINKINST=LGR,       ..Indicate the Link Instruction TypeX
               MF=(E,DVCPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Process Address for Load Module Name
         LTGFR R15,R15             Resolve Addr Processing Successful?
         BRZ   DIVC0200            Yes => Branch to Process Output Line
         ST    R15,DVCRETCD        Save Highest Return Code Generated
         LGHI  R2,((DIVC0300-DIVC0200)-4) ...Length of Branch Table
         CGFR  R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   DIVC0200            No  => Branch to Process Output Line
         BRU   DIVCEXIT            Yes => Branch to Exit This Routine
DIVC0200 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   DIVC0300            Addr Process Completed, Process Line
         BRU   DIVC0300            Branch on Warning-Ignore & Continue
         BRU   DIVCEXIT            Branch on Processing Error - Exit
         BRU   DIVCEXIT            Branch on Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*| Verify the proposed starting address is within range of the main  |*
*| storage block address for the abending load module, and copy load |*
*| module contents around the point failure to a work storage area   |*
*| to prepare for first pass processing.                             |*
*+-------------------------------------------------------------------+*
*
DIVC0300 DS    0H
         CLC   LMOD.LRTLMOD(8),=C'UNKNOWN ' Is Load Module Name Known?
         BRE   DIVC0900            No  => No Instructions to Process
         TMLL  R6,(X'0001')        Instructn Addr on Halfwrd Boundary?
         BRZ   DIVC0600            Yes => Instruction Address is Even
DIVC0400 DS    0H
         LG    RSDW,DVCSDWA@       Addr of System Diagnostic Work Area
         USING SDWA,RSDW           Establish Addressability to SDWA
         SLGR  R14,R14             Clear for Use as a Work Register
         ICM   R14,B'0111',SDWACMPC ...Get the System Completion Code
         SRDL  R14,12              Separate the System & User Codes
         LTGR  R14,R14             Is This a System Completion Code?
         BRZ   DIVC0900            No  => User Code Could be Anything
         CGHI  R14,X'00C6'         Did Odd Address Lead to S0C6 Abend?
         BRE   DIVC0900            Yes => Making It Even Too Unreliable
         OC    SDWAEC1,SDWAEC1     Is There Extended Control Mode PSW?
         BRZ   DIVC0900            No  => Failing Instructn Unavailable
         ICM   R1,B'0011',SDWAEC1+3 Get PSW Addressing Mode Indicators
         TMLL  R1,X'0180'          Was User Program in 64-Bit Amode?
         BRNO  DIVC0900            No  => Looking for Amode 64 Conflict
DIVC0500 DS    0H
         LLGT  R4,SDWAXPAD         Addr of SDWA Extension Pointers Area
         USING SDWAPTRS,R4         Addressability to Extension Ptr Area
         ICM   R4,B'1111',SDWAXEME Do We Have a Pointer to 64-bit Info?
         BRZ   DIVC0900            No  => Cannot Verify Why Odd Address
         USING SDWARC4,R4          Addressability to 64-bit Info Area
         LLGF  R2,SDWAPSW16        To Check First Word of the zArch PSW
         LTGFR R2,R2               Is z/Arch CPU State Info Available?
         BRZ   DIVC0900            No  => Then Bypass Processing of PSW
         TM    SDWAPSW16+1,X'08'   Is Bit 12 a Zero in the 16-byte PSW?
         BRNZ  DIVC0900            No  => Its Always 0 in zArchitecture
         TM    SDWAPSW16+L'SDWAPSW16-1,X'01' Odd No. Addr in zArch PSW?
         BRO   DIVC0900            Yes => Problem Not an Amode Conflict
         NILL  R6,X'FFFE'          No  => Conflict, Make PSW Addr Even
         DROP  R4,RSDW             Removed Listed Registers as Base Reg
DIVC0600 DS    0H
         LG    R1,LMOD.LRTMSBAD    Addr of Load Module Main Storage Blk
         LLGF  R2,LMOD.LRTMSBLA    Get Length of Lmod Main Storage Blk
         LA    R2,0(R1,R2)         Calculate Ending Addr of Storage Blk
         LGR   R3,R6               To Set Addr Before Failing Instructn
         LGR   R5,R6               To Set Addr After Failing Instructn
         AGHI  R3,(-128)           128 Bytes Before PSW Addr at Failure
         AGHI  R5,(48)             48 Bytes After PSW Addr at Failure
         CGR   R3,R1               Are We Within a Main Storage Block?
         BRNL  DIVC0700            Yes => Branch to Check End of Block
         LGR   R3,R1               Use Main Storage Block Addr as Start
DIVC0700 DS    0H
         CGR   R5,R2               Are We Past End of Main Storage Blk?
         BRNH  DIVC0800            No  => Branch to Process Instruction
         LGR   R5,R2               Use End of Main Storage Blk as Limit
DIVC0800 DS    0H
         LGR   R15,R5              Ending Address to a Work Register
         LGR   R14,R6              Abending Instruction Adr to Work Reg
         SLGR  R14,R3              Calculate Offset From Start Address
         STG   R14,DVCABNDO        Save the Offset from Starting Addr
         LA    R1,DVCINARE(R14)    Abending Instruction Adr in Wrk Area
         SLGR  R15,R3              Calculate the Length of Storage Area
         BCTGR R15,R0              Decrement Length for the Execute
         LA    R1,DIVC0900         Get Retry Recovery Address (ESPIE)
         ST    R1,LGWRETRY         Preserve It In Case of an Abend
         MVC   DVCINARE(*-*),0(R3) Indicated Target of the Execute
         EX    R15,*-6             Copy Lmod Area in Vicinity of Abend
         XC    LGWRETRY,LGWRETRY   Area Referenced, Disable Recovery
         BRU   DIVC1000            Branch to Find a Starting Address
DIVC0900 DS    0H
         XC    LGWRETRY,LGWRETRY   Clear to Disable Abend Recovery
         LA    R15,4               Indicate Error in Storage Process
         ST    R15,DVCRETCD        Set Highest Generated Return Code
         BRU   DIVCEXIT            Unable to Resolve Area Around Abend
*
*+-------------------------------------------------------------------+*
*| Proceed with a first pass through the work storage area which     |*
*| contains a block of hex machine code from the load module. Run    |*
*| this work area through the zArchitecture machine code table to see|*
*| if there is a sufficient sequence of consecutive instructions     |*
*| preceding the failing instruction to establish a valid starting   |*
*| address with the work area.                                       |*
*+-------------------------------------------------------------------+*
*
DIVC1000 DS    0H
         LA    R0,DVCOTARE         Work Area to Process Instructions
         LLILL R1,(DVCOTLEN)       Len of Output Instruction Work Area
         SLGR  R14,R14             Indicate the Sending Area is Nulls
         SLGR  R15,R15             No Length and Using Pad Character
DIVC1100 DS    0H
         MVCLE R0,R14,C' '(0)      Clear the Entire Work Area to Blanks
         BRO   DIVC1100            Upon Interrupt Resume Where Left Off
DIVC1200 DS    0H
         LA    R8,DVCINARE         Addr of Input Instruction Work Area
         LLILL R6,L'DVCOPCDE       To Check the Next Halfword Boundary
         LG    R1,DVCABNDO         Get Offset to Abending Instruction
         LA    R7,0(R1,R8)         Set Address of Abending Instruction
DIVC1300 DS    0H
         BRAS  R14,DVCO$000        Search Machine Table for an Op Code
         LTGR  R15,R15             Was There a Machine Op Code Found?
         BRZ   DIVC1500            Yes => Branch to Process Instruction
         XC    DVCOPCNT,DVCOPCNT   Clear Consecutive Instructions Count
         XC    DVCOPSTR,DVCOPSTR   Clear Instruction Starting Address
         BRXLG R8,R6,DIVC1300      Loop to Check Next Halfword Address
         CGR   R8,R7               Reached Addr of Abending Instructn?
         BRH   DIVC1700            Yes => Do Instructions After Failure
DIVC1400 DS    0H
         LA    R15,4               Unable to Find Valid Instructio Set
         ST    R15,DVCRETCD        Set Highest Generated Return Code
         BRU   DIVCEXIT            Unable to Resolve Area Around Abend
DIVC1500 DS    0H
         LG    R1,DVCOPCNT         Get Consecutive Instructions Counter
         AGHI  R1,(1)              Increment Count for Instructions
         STG   R1,DVCOPCNT         Save Count of Consecutive Instructns
         CGHI  R1,(1)              First Time Through Since Last Reset?
         BRNE  DIVC1600            No  => Then Branch to Check Counter
         STG   R8,DVCOPSTR         Save Instruction Starting Address
DIVC1600 DS    0H
         USING OP@CODES,R3         Addressability Machine Instructions
         LG    R3,DVCMTBLE         Get Addr of Machine Tble Entry Found
         LLGC  R1,OP@OPRND         Obtain Leng in Bytes of Instruction
         LA    R8,0(R1,R8)         Increment to the Next Instruction
         CGR   R8,R7               Reached Addr of Abending Instructn?
         BRH   DIVC1700            Yes => Process Instruction Group
         BRU   DIVC1300            No  => Check for Another Instruction
DIVC1700 DS    0H
         LG    R1,DVCOPCNT         Get Consecutive Instructions Counter
         CGHI  R1,(7)              At Least 7 Consecutive Instructions?
         BRNL  DIVC1800            Yes => Process the Instruction Set
         LA    R15,4               Unable to Find Valid Instruction Set
         ST    R15,DVCRETCD        Set Highest Generated Return Code
         BRU   DIVCEXIT            Unable to Resolve Area Around Abend
DIVC1800 DS    0H
         LLILL R1,(6)              Instructions After Abend Limit Count
         STG   R1,DVCAFTCT         Save Instructions After Abend Count
         STG   R7,DVCABNIN         Save Address of Abending Instruction
         LA    R7,DVCINARE+L'DVCINARE-L'DVCOPCDE For End of Input Area
DIVC1900 DS    0H
         BRAS  R14,DVCO$000        Search Machine Table for an Op Code
         LTGR  R15,R15             Was There a Machine Op Code Found?
         BRNZ  DIVC3000            Yes => Branch to Process Instruction
DIVC2000 DS    0H
         LG    R1,DVCOPCNT         Get Consecutive Instructions Counter
         AGHI  R1,(1)              Increment Count for Instructions
         STG   R1,DVCOPCNT         Save Count of Consecutive Instructns
         LG    R3,DVCMTBLE         Get Addr of Machine Tble Entry Found
         LLGC  R1,OP@OPRND         Obtain Leng in Bytes of Instruction
         LA    R8,0(R1,R8)         Increment to the Next Instruction
         CGR   R8,R7               Reached End of Input Instructn Area?
         BRH   DIVC3000            Yes => Process Instruction Group
         LG    R15,DVCAFTCT        Get Instructions After Abend Counter
         BRCTG R15,DIVC2100        Decrement Limit Count, Nxt Instructn
         BRU   DIVC3000            No. of Instructs After Abend Reached
DIVC2100 DS    0H
         STG   R15,DVCAFTCT        Update Count for Instructn Processed
         BRU   DIVC1900            Loop to Check Storage for Instructn
         DROP  R3                  Remove Listed Reg as Table Base Reg
*
*+-------------------------------------------------------------------+*
*| Initialize parameters to prepare for second pass processing       |*
*+-------------------------------------------------------------------+*
*
         USING OP@CODES,R3         Addressability Machine Instructions
DIVC3000 DS    0H
         LG    R7,DVCABNIN         Restore Addr of Abending Instruction
         MVI   DCVOSIGN,C'-'       Set Minus Sign Prefix for the Offset
         LG    R8,DVCOPSTR         Get the Instruction Starting Address
         LGR   R6,R8               Starting Address to a Work Register
         SGR   R6,R7               Displacement From Starting Address
         LA    R1,DVCOTARE         Addr of Work Area for Instructions
         LA    R2,L'DVCOTARE       Leng of Each Work Area Record Entry
         LLGF  R3,=A((DVCONTRY*L'DVCOTARE)-L'DVCOTARE)  Length of Area
         LA    R3,0(R1,R3)         Point to the Next to the Last Entry
         DROP  R3                  Remove Listed Reg as Table Base Reg
*
*+-------------------------------------------------------------------+*
*| Proceed with a second pass through the work storage area using    |*
*| both the zArchitecture machine code table and the Logger Services |*
*| disassembler program to perform additional validity checking, and |*
*| to convert the hex machine code from the load module into their   |*
*| repective assembler language source statements.                   |*
*+-------------------------------------------------------------------+*
*
DIVC3100 DS    0H
         STMG  R1,R3,DVCOPNTR      Save the Instruction Work Area Parms
DIVC3200 DS    0H
         BRAS  R14,DVCO$000        Process Through zArch Machine Table
         LTGR  R15,R15             Was the Machine Op Code Verified?
         BRZ   DIVC3300            Yes => Branch to Process Instruction
         LA    R15,4               Unable to Verify as Valid Instructn
         ST    R15,DVCRETCD        Set Highest Generated Return Code
         BRU   DIVCEXIT            Unable to Resolve Area Around Abend
DIVC3300 DS    0H
         LG    R1,DVCOP$CT         Get Instructions Processed Counter
         AGHI  R1,(1)              Increment Count for Instructions
         STG   R1,DVCOP$CT         Save Count of Processed Instructions
         CGHI  R1,(1)              Processing 1st Instruction Sequence?
         BRNE  DIVC4000            No  => Branch to Process Instruction
DIVC3400 DS    0H
         USING OP@CODES,R3         Addressability Machine Instruct Tabl
         LG    R3,DVCMTBLE         Get Addr of Machine Tble Entry Found
         LLGC  R1,OP@OPRND         Obtain Leng in Bytes of Instruction
         LA    R8,0(R1,R8)         Suppress First Entry, Use the Next
         AGR   R6,R1               Reset Displacement From Start Addr
         BRU   DIVC3200            Loop to Check Storage for Instructn
         DROP  R3                  Remove Listed Reg as Table Base Reg
*
*+-------------------------------------------------------------------+*
*| Call the Logger Services disassembler program DXMC0000 to analyze |*
*| the hex machine code instruction within the load module, perform  |*
*| validity checking, and if valid convert the machine code into an  |*
*| assembler language source statement.                              |*
*+-------------------------------------------------------------------+*
*
         USING OP@CODES,R3         Addressability Machine Instructions
DIVC4000 DS    0H
         MVI   DVCWAREA,C' '       Set-up to Fill Work Area with Blanks
         MVC   DVCWAREA+1(L'DVCWAREA-1),DVCWAREA ...Propogate the Blank
         MVI   DVCXTEND,C' '       To Fill Mnemonic Area with Blanks
         MVC   DVCXTEND+1(L'DVCXTEND-1),DVCXTEND ...Propogate the Blank
         LA    R2,DVCWAREA         Get Address of Instruction Work Area
         LG    R3,DVCMTBLE         Get Addr of Machine Tble Entry Found
         LA    R4,DVCOPREV         Get Addr to Addr of Previous Op-Cde
         LA    R5,DVCXTEND         Get Addr of Extended Mnemonic Area
         MVC   0(L'OP@MNEUM,R2),OP@MNEUM  Source Instruction Mnemonic
         LA    R2,L'OP@MNEUM+2(,R2) Increment to End of Instruction Nme
         XC    DVCPLIST,DVCPLIST   Clear the Call Parameter List
         CALL  DXMC0000,           Disassemble Hex Notation Machine CdeX
               ((R2),              ..Pass Addr of Area to Return InstruX
               (R3),               ..Pass Addr of Machine Table Entry  X
               (R8),               ..Pass Addr of Machine Code InstructX
               (R5),               ..Pass Addr of Area for Ext MnemonicX
               (R4),               ..Pass Addr of Area for Prev Op-CodeX
               (RLGW),             ..Pass LGRWK2II Area Address        X
               (RCOMM)),           ..Pass Common Constants&Routines    X
               PLIST8=YES,         ..Indicate the Parameter List FormatX
               LINKINST=LGR,       ..Indicate the Link Instruction TypeX
               MF=(E,DVCPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Disassemble the Machine Instruction
         LTGFR R15,R15             Was Disassemble Process Successful?
         BRZ   DIVC4100            Yes => Branch to Print Output Lines
         LGHI  R2,((DIVC4200-DIVC4100)-4) ...Length of Branch Table
         CGFR  R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   DIVC4100            No  => Branch to Process Output Line
         BRU   DIVCEXIT            Yes => Branch to Exit This Routine
DIVC4100 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   DIVC5000            Disassemble Completed on Instruction
         BRU   DIVC5000            Branch on Warning-Ignore & Continue
         BRU   DIVC4200            Branch on Process Error, Check Count
         BRU   DIVC4300            Branch on Severe Error, Set RSN Code
DIVC4200 DS    0H
         LG    R1,DVCOP$CT         Get Instructions Processed Counter
         CGHI  R1,(3)              Error Within 1st 3 Tries From Start?
         BRH   DIVC4300            No  => Starting Address is in Error
         LG    R3,DVCMTBLE         Get Addr of Machine Tble Entry Found
         LLGC  R1,OP@OPRND         Obtain Leng in Bytes of Instruction
         LA    R8,0(R1,R8)         Increment to the Next Instruction
         AGR   R6,R1               Add Instruction Leng to Displacement
         BRU   DIVC3200            Loop to Process the Next Instruction
DIVC4300 DS    0H
         LA    R15,4               Unable to Verify as Valid Instructn
         ST    R15,DVCRETCD        Set Highest Generated Return Code
         BRU   DIVCEXIT            Unable to Resolve Area Around Abend
         DROP  R3                  Remove Listed Reg as Table Base Reg
*
*+-------------------------------------------------------------------+*
*|Display the instruction hex offset relative to failed instruction. |*
*|                                                                   |*
*|Convert the hex displacement of the instruction to character format|*
*|prefixing a minus sign (-) for instructions listed before the      |*
*|failed instruction, a right arrow (===>) to designate the failed   |*
*|instruction, and a plus sign (+) for instructions that are listed  |*
*|after the failed instruction.                                      |*
*|                                                                   |*
*| For example:                                                      |*
*|                                                                   |*
*| Hex      Hex Machine                                              |*
*| Offset   Instruction      Assembler Source Statement           Att|*
*| ------   ---------------  -----------------------------------  ---|*
*|    -6C                                                            |*
*+-------------------------------------------------------------------+*
*
DIVC5000 DS    0H
         LG    R1,DVCACCPT         Get Instructions Accepted Counter
         AGHI  R1,(1)              Increment Count for Instructions
         STG   R1,DVCACCPT         Save Count of Accepted Instructions
         LG    R4,DVCOPNTR         Get Current Pointer in Output Area
         LTGR  R6,R6               Reached Addr for Abending Instructn?
         BRNZ  DIVC5100            No  => Continue with Offset Process
         STG   R8,DVCABNDI         Save Addr for Abending Instruction
DIVC5100 DS    0H
         LPGFR R1,R6               Complement for a Negative Offset No.
         ST    R1,DVCOFF04         Instruction Offset to Work Area
         UNPK  DVCWRK09,DVCOFF04(5) Get Offset Value to Make Printable
         TR    DVCWRK09(L'DVCWRK09-1),HEXCONV-C'0'  Convert Hex to Char
         LA    R14,DVCWRK09        Work Area Has Offset into Data Area
         LA    R0,L'DVCWRK09-1     Get Leng of Work Area Holding Offset
DIVC5200 DS    0H
         CLI   0(R14),C'0'         This a Leading Zero in Offset No.?
         BRNE  DIVC5300            No  => Branch to Put a Prefix Char
         MVI   0(R14),C' '         Yes => Then Suppress Leading Zero
         LA    R14,1(,R14)         Increment to Next Byte in Work Area
         BRCTG R0,DIVC5200         Branch to Check for Leading Zero
         MVI   DCVOSIGN,C'+'       No More Negative Offsets, Now at +0
         MVC   3(4,R4),=CL4'===>'  Set Indicator for Failing Instructn
         LA    R4,10(,R4)          Increment to Hex Machine Code Field
         BRU   DIVC5400            Branch to Process the Machine Code
DIVC5300 DS    0H
         BCTGR R14,R0              Backup to Position Before Offset No.
         MVC   0(1,R14),DCVOSIGN   Prefix '+/-' Sign Notation to Offset
         MVC   0(7,R4),DVCWRK09+1  Copy Offset Value to Output Line
         LA    R4,10(,R4)          Increment to Hex Machine Code Field
*
*+-------------------------------------------------------------------+*
*|Display the hex machine instruction.                               |*
*|                                                                   |*
*|Convert the hex machine instruction to a printable character format|*
*|and then display the full machine instruction with a space inserted|*
*|after every halfword.                                              |*
*|                                                                   |*
*| For example:                                                      |*
*|                                                                   |*
*|     Hex       to   Character                                      |*
*| D5FFBFF86F3A       C4F5C6C6 C2C6C6F8 F6C6F3C1                     |*
*|                    | | | |  | | | |  | | | |                      |*
*|                    D 5 F F  B F F 8  6 F 3 A                      |*
*|                                                                   |*
*| Hex      Hex Machine                                              |*
*| Offset   Instruction      Assembler Source Statement           Att|*
*| ------   ---------------  -----------------------------------  ---|*
*|    -6C   D5FF BFF8 6F3A                                           |*
*+-------------------------------------------------------------------+*
*
         USING OP@CODES,R3         Addressability Machine Instructions
DIVC5400 DS    0H
         LG    R3,DVCMTBLE         Get Addr of Machine Tble Entry Found
         MVI   DVCINSTR,C' '       Set-up to Fill Work Area with Blanks
         MVC   DVCINSTR+1(L'DVCINSTR-1),DVCINSTR ...Propogate the Blank
         LA    R2,DVCINSTR         Get Addr of Instruction Output Area
         LLGC  R14,OP@OPRND        Obtain Leng in Bytes of Instruction
         LA    R15,DVCOPWRK        Addr of Instruction Data Work Area
         LGR   R1,R14              Current Leng in Bytes of Instruction
         SLLG  R1,R1,1 Bit         Multiply the Current Length by Two
         LGR   R5,R1               Expand Length for a Character Format
         SLLG  R5,R5,4 Bits        Char Len Shifted to 1st Len Position
         OGR   R5,R14              Put the Two Unpack Lengths Together
         UNPK  DVCOPWRK(0),0(0,R8) Indicated Target of the Execute
         EX    R5,*-6              Unpack Instruction to a Work Area
         BCTGR R1,R0               Decrement Length for the Execute
         EX    R1,TRNSLATE         Translate Hex to Character Format
* trnslate tr   0(*-*,R15),hexconv-c'0' ...Commented Target of Execute
         MVC   0(0,R2),DVCOPWRK    Indicated Target of the Next Execute
         EX    R1,*-6              Displayable Instruction to Hold Area
         MVC   0(L'DVCINSTR/4,R4),DVCINSTR 1st Halfword of Instruction
         CLI   OP@OPRND,X'02'      Is Instruction Length 1 Halfword?
         BRE   DIVC5500            Yes => Done, Increment to Next Field
         LA    R1,L'DVCINSTR/4+1(,R4) Increment for 2nd Halfword
         MVC   0(L'DVCINSTR/4,R1),DVCINSTR+L'DVCINSTR/4 2nd Halfword
         CLI   OP@OPRND,X'04'      Is Instruction Length 2 Halfwords?
         BRE   DIVC5500            Yes => Done, Increment to Next Field
         LA    R1,L'DVCINSTR/4+1(,R1) Increment for 3rd Halfword
         MVC   0(L'DVCINSTR/4,R1),DVCINSTR+L'DVCINSTR/2 3rd Halfword
DIVC5500 DS    0H
         LA    R4,17(,R4)          Increment to Source Statement Field
*
*+-------------------------------------------------------------------+*
*| Display the Assembler language source statement for instruction.  |*
*|                                                                   |*
*| For example:                                                      |*
*|                                                                   |*
*| Hex      Hex Machine                                              |*
*| Offset   Instruction      Assembler Source Statement           Att|*
*| ------   ---------------  -----------------------------------  ---|*
*|    -6C   D5FF BFF8 6F3A   CLC      4088(256,R11),3898(R6)         |*
*+-------------------------------------------------------------------+*
*
DIVC5600 DS    0H
         MVC   0(L'DVCWAREA,R4),DVCWAREA ...Assembler Source Statement
*
*+-------------------------------------------------------------------+*
*| Display the Instruction Attributes.                               |*
*|                                                                   |*
*| For example:                                                      |*
*|                                                                   |*
*| Hex      Hex Machine                                              |*
*| Offset   Instruction      Assembler Source Statement           Att|*
*| ------   ---------------  -----------------------------------  ---|*
*|    -6C   D5FF BFF8 6F3A   CLC      4088(256,R11),3898(R6)      Set|*
*+-------------------------------------------------------------------+*
*
         USING OPC$ATTR,R5         Addressability to Attributes Table
DIVC6000 DS    0H
         LA    R4,37(,R4)          Increment to the Attributes Field
         LG    R5,=AD(OPC$ATTR)    Addr of Instruction Attributes Table
         LLILL R2,(OPC$ANBR)       No. of Instruction Attribute Entries
DIVC6100 DS    0H
         CLC   OPC$ATTR(L'OP@ATTR1),OP@ATTR1  Is This our Attribute?
         BRE   DIVC6300            Yes => Process Instruction Attribute
DIVC6200 DS    0H
         LA    R5,L'OPC$ATTR(,R5)  Increment to Next Attribute Entry
         BRCTG R2,DIVC6100         Loop to Check Next Instruction Attr
         BRU   DIVC6400            Branch if Attributes Were Not Found
DIVC6300 DS    0H
         CLC   OP@ATTR1,=CL2'  '   Does Not Set a Condition Code?
         BRE   DIVC6400            Yes => Then Bypass This Attribute
         MVC   0(OPC$ATLN,R4),OPC$ATTR+2 Instruction Attr to Output
         DROP  R5                  Remove Listed Reg as Attr Table Base
DIVC6400 DS    0H
         TM    OP@MODES,X'80'      Is this a zArch Modal Instruction?
         BRZ   DIVC7100            No  => Branch to Process Attributes
DIVC6500 DS    0H
         LG    R15,DVCOPNTR        Get Starting Address of Output Line
         LA    R5,L'DVCOTARE-1     Length of Output Area Record Entry
         LA    R1,0(R5,R15)        Point to the End of Output Line Area
         LA    R14,1               Check is for One Byte at a Time
         LNGR  R14,R14             To Scan Backwards Through Output Lne
         LGR   R15,R4              Scan Limit Start of Attributes Field
         LLGC  R2,=C' '            Search Is For Trailing Blanks
DIVC6600 DS    0H
         BRXHG R1,R14,DIVC6700     Find End of Attr Text Going Backward
         BRU   DIVC6800            Branch to Process the Text Length
DIVC6700 DS    0H
         CLM   R2,B'0001',0(R1)    Is This a Blank Character?
         BRNE  DIVC6800            No  => Branch to Determine Length
         BRU   DIVC6600            Loop to Check the Next Byte in Field
DIVC6800 DS    0H
         LA    R5,1(,R1)           Point to End of Current Attributes
         SGR   R1,R15              Calculate Leng of Current Attr Text
         BRNP  DIVC7000            Branch If Nothing Is Left
DIVC6900 DS    0H
         MVI   0(R5),C','          Comma Separator for Modal Attribute
         LA    R5,2(,R5)           Increment Past Comma for Attribute
         MVC   0(17,R5),=CL17'Modal Instruction' Indicate Modal Instruc
         BRU   DIVC7100            Loop to Check the Next Byte in Field
DIVC7000 DS    0H
         MVC   0(17,R4),=CL17'Modal Instruction' Indicate Modal Instruc
*
*+-------------------------------------------------------------------+*
*| Loop Point to Process the Next Machine Instruction From the Load  |*
*| Module into an Assembler Language Source Statement.               |*
*+-------------------------------------------------------------------+*
*
DIVC7100 DS    0H
         LG    R3,DVCMTBLE         Get Addr of Machine Tble Entry Found
         LLGC  R1,OP@OPRND         Obtain Leng in Bytes of Instruction
         LA    R8,0(R1,R8)         Increment to the Next Instruction
         AGR   R6,R1               Add Instruction Leng to Displacement
         CLC   DVCOP$CT,DVCOPCNT   Reached Instructions Processed Limit
         BRNL  DIVC7200            Yes => Branch to Verify Offset Count
         LMG   R1,R3,DVCOPNTR      Get Instruction Work Area Parameters
         BRXLG R1,R2,DIVC3100      Loop to Process the Next Instruction
DIVC7200 DS    0H
         LG    R1,DVCABNDI         Obtain Addr for Abending Instruction
         LTGR  R1,R1               An Address for Abending Instruction?
         BRZ   DIVC7300            No  => Then Offset Count Incorrect
         CGR   R1,R7               Addr Match for Abending Instruction?
         BRE   DIVC8000            Yes => Instruction Position Correct
DIVC7300 DS    0H
         LA    R15,4               Unable to Verify as a Valid Report
         ST    R15,DVCRETCD        Set Highest Generated Return Code
         BRU   DIVCEXIT            Unable to Resolve Area Around Abend
*
*+-------------------------------------------------------------------+*
*| Print the List of Instructions in the Vicinity of the Abend from  |*
*| the Work Area to the Output Data Set.                             |*
*+-------------------------------------------------------------------+*
*
DIVC8000 DS    0H
         LA    R3,DVCLNHD1         Get Address of the First Header Line
         LA    R4,DVCHDRLN         Obtain the Length of the Header Line
         LLGT  R5,=A(DVCLNHD1+((DVCLHDR#*DVCHDRLN)-DVCHDRLN)) Last Line
DIVC8100 DS    0H
         MVI   DVCLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DVCLINE+1(L'DVCLINE-1),DVCLINE ...Propogate the Blank
         MVI   DVCCCNTL,C' '       Set Carriage Control to Single Space
         MVC   DVCLINE+1(DVCHDRLN),0(R3)   Instruction Header to Output
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DIVCEXIT            No  => Then Bypass Print Output
DIVC8200 DS    0H
         BRAS  R14,DIVCP100        Print the Header Line to //LGRECOUT
         BRXLG R3,R4,DIVC8100      Loop to Process Next Header Line
DIVC8300 DS    0H
         LA    R3,DVCOTARE         Addr of Output Area for Instructions
         LA    R4,L'DVCOTARE       Leng of Each Output Area Recrd Entry
         LG    R5,DVCACCPT         Get Instructions Accepted Counter
         BCTGR R5,R0               To Set to the Next to the Last Entry
         MGHI  R5,L'DVCOTARE       Offset into Area by No. of Instructs
         LA    R5,0(R3,R5)         Point to the Last Instruction Record
DIVC8400 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DIVCEXIT            No  => Then Bypass Print Output
         SYSSTATE AMODE64=NO,ARCHLVL=2 Generate Code for Not in AMODE64
         SAM31                     Switch Now to 31-Bit Addressing Mode
         PUT   LGWODCB,(R3)        Print Instruction Line to //LGRECOUT
         SAM64                     Switch Back to 64-Bit Address Mode
         SYSSTATE AMODE64=YES,ARCHLVL=2    Restore 64-Bit Environment
         BRXLG R3,R4,DIVC8400      Loop to Process Next Instructn Line
DIVC8500 DS    0H
         MVI   DVCLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DVCLINE+1(L'DVCLINE-1),DVCLINE ...Propogate the Blank
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DIVCEXIT            No  => Then Bypass Print Output
DIVC8600 DS    0H
         BRAS  R14,DIVCP100        Blank Separator Line to //LGRECOUT
*
*+-------------------------------------------------------------------+*
*|   Return to Caller                                                |*
*+-------------------------------------------------------------------+*
*
DIVCEXIT DS    0H
         LLGF  R15,DVCRETCD        Set the Return Code
         LPGMEXIT RC=DVCRETCD      Define Program Exit Protocol
*
**************************+-----------------+**************************
**************************| D V C O $ 0 0 0 |**************************
**************************+-----------------+**************************
*+-------------------------------------------------------------------+*
*|  S e a r c h   M a c h i n e   I n s t r u c t i o n   T a b l e  |*
*+-------------------------------------------------------------------+*
*|                                                                   |*
*|SUBROUTINE NAME: DVCO$000                                          |*
*|                                                                   |*
*|FUNCTION: Search the zArchitecture Machine Instruction Table to    |*
*|          find the entry in the table which matches the op-code    |*
*|          for the hex machine instruction in the load module.      |*
*--------------------------------------------------------------------*
*
         USING OP@CODES,R3         Addressability Machine Instructions
DVCO$000 LPGMSUBE                  Set Subroutine Entry Protocol
         LA    R1,DVCO0800         Get Retry Recovery Address (ESPIE)
         ST    R1,LGWRETRY         Preserve It In Case of an Abend
         XC    DVCOPCDE,DVCOPCDE   Clear Op Code Area of Residual Data
         LLGC  R0,0(,R8)           Instruction Op Code for Failed Instr
         LTGR  R0,R0               Is There an Available Op Code?
         BRZ   DVCO0800            No  => Zero is Never a Valid Op-Code
         STC   R0,DVCOPCDE         Save the Machine Instruction Op-Code
         MVI   DVCOPCLN,X'01'      Set the Indicator for 8-Bit Op-Code
         LLILL R2,(1)              Begin Search on a One Byte Op-Code
         LG    R3,=AD(OPC$ZARC)    Address of Machine Instruction Table
         LLILL R4,(OPC$ZNUM)       No. of Machine Instruction Entries
DVCO0200 DS    0H
         CLM   R0,0,OP@MCHCD       OpCode That Failed Compared to Table
         EX    R2,*-4              Our Machine Instruction Op-Code?
         BRNE  DVCO0700            No  => Then Check Next Entry in Tble
         CLI   OP@OPRND+1,X'01'    Instruction Have a One Byte Op-Code?
         BRE   DVCO0900            Yes => Done, Process Instruction
         CLM   R0,B'0010',=X'00'   Instruction Have a Two Byte Op-Code?
         BRNE  DVCO0900            Yes => Done, Process Instruction
DVCO0300 DS    0H
         SLLG  R0,R0,8 Bits        To Make Room for 2nd Byte of Op Code
         MVO   DVCOPWRK(2),OP@OPRND+1(1) ..Position of 2nd Op-Code Byte
         LLGC  R15,DVCOPWRK        Position of 2nd Op-Cde Byte as Index
         LA    R1,0(R15,R8)        Point to 2nd Op-Code Byte in Instruc
         CGHI  R15,(1)             12-Bit as Opposed to 16-Bit Op-Code?
         BRE   DVCO0500            Yes => Extended Op Cde Field 12-Bits
         LTGR  R15,R15             Contiguous 16-Bit Extended Op-Code?
         BRNZ  DVCO0400            No  => Bifarcated 16-Bit Extended Op
         LA    R1,1(,R1)           Increment One Byte Over for Op-Code
DVCO0400 DS    0H
         ICM   R0,B'0001',0(R1)    Get the 2nd Byte for 16-Bit Op-Code
         MVI   DVCOPCLN,X'03'      Set the Indicator for 16-Bit Op-Code
         BRU   DVCO0600            Branch to Continue Search for Op-Cde
DVCO0500 DS    0H
         XC    DVCOPWRK(2),DVCOPWRK To Clear Work Area of Residual Data
         MVO   DVCOPWRK(2),0(1,R1) Extract the Op Code Field Nibble
         MVI   DVCOPCLN,X'02'      Set the Indicator for 12-Bit Op-Code
         ICM   R0,B'0001',DVCOPWRK+1 .Expand 12-Bit Op Code into 16-Bit
DVCO0600 DS    0H
         STH   R0,DVCOPCDE         Save the Machine Instruction Op-Code
         LLILL R2,(3)              Set Mask to 0011 for Extended Op-Cde
         BRU   DVCO0200            Now Retry Same Place Where Left Off
DVCO0700 DS    0H
         LA    R3,OP@NTRYL(,R3)    Increment to Next Instruction Entry
         BRCTG R4,DVCO0200         => Loop to Search for Machine Op-Cde
DVCO0800 DS    0H
         XC    LGWRETRY,LGWRETRY   Clear to Disable Abend Recovery
         LA    R15,4               Indicate Error in Search Process
         ST    R15,DVCRETCD        Set Highest Generated Return Code
         BRU   DVCO1000            Branch to Exit This Routine
DVCO0900 DS    0H
         XC    LGWRETRY,LGWRETRY   Clear to Disable Abend Recovery
         STG   R3,DVCMTBLE         Save Adr of Machine Tble Entry Found
         SLGR  R15,R15             Indicate Success in Search Process
         ST    R15,DVCRETCD        Set Highest Generated Return Code
DVCO1000 DS    0H
         LPGMSUBX                  Return to Caller of This Subroutine
         LTORG ,                   Set Literal Origin Table
         DROP  R3                  Remove Listed Reg as Table Base Reg
*
**************************+-----------------+**************************
**************************| D V C O P 1 0 0 |**************************
**************************+-----------------+**************************
*+-------------------------------------------------------------------+*
*|         P r i n t   O u t p u t   D e t a i l   L i n e           |*
*+-------------------------------------------------------------------+*
*|                                                                   |*
*|SUBROUTINE NAME: DVCOP100                                          |*
*|                                                                   |*
*|FUNCTION.......: Print Detail Line to Output Logger Data Set       |*
*+-------------------------------------------------------------------+*
*
DIVCP100 LPGMSUBE                  Set Subroutine Entry Protocol
         SYSSTATE AMODE64=NO,ARCHLVL=2 Generate Code for Not in AMODE64
         SAM31                     Switch Now to 31-Bit Addressing Mode
         PUT   LGWODCB,DVCLINE     Print Output Line to //LGRECOUT
         SAM64                     Switch Back to 64-Bit Address Mode
         SYSSTATE AMODE64=YES,ARCHLVL=2    Restore 64-Bit Environment
         LPGMSUBX                  Return to Caller of This Subroutine
*
*+-------------------------------------------------------------------+*
*|   Definitions for Constants                                       |*
*+-------------------------------------------------------------------+*
*
DVCHDRLN EQU   120                 Indicate Length of Each Header Line
DVCLNHD1 DC    CL(DVCHDRLN)'-Instructions in Vicinity-'   Header Line 1
DVCLNHD2 DC    CL(DVCHDRLN)' '     Separator Lne 2 for Detail Hdr Lne-1
DVCLNHD3 DC    CL(DVCHDRLN)'Hex      Hex Machine'  Detail Header Line-3
DVCLNHR4 DC    CL(DVCHDRLN)'Offset   Instruction      Assembler Source X
               Statement           Attributes'     Detail Header Line-4
DVCLNHD5 DC    CL(DVCHDRLN)'------   ---------------  -----------------X
               ------------------  ------------------------------------X
               --------------'     Instruction Detail Header Line-5
DVCLHDR# EQU   (*-DVCLNHD1)/DVCHDRLN Number of Instruction Header Lines
*
*+-------------------------------------------------------------------+*
*|    Program RENT Work Area                                         |*
*+-------------------------------------------------------------------+*
*
         LCA   DEFINE              Define the Program RENT Work Area
*
DVCWORKD DS    10D                 General Purpose Work Area
DVCPLIST DS    20FD                CALL Parameter List
DVCPARM@ DS    0FD                 Save Area for Passed Parameters
DVCMCHI@ DS    AD                  Addr of Field for Machine Tble Entry
DVCABND@ DS    AD                  Addr of Field for Abending Instructn
DVCALCA@ DS    AD                  Addr of Abending Program's LCA Area
DVCSDWA@ DS    AD                  Addr of System Diagnostic Work Area
DVCMTBLE DS    AD                  Addr for Machine Table Entry Found
DVCABNDI DS    AD                  Addr for Abending Instr in Work Area
DVCOPREV DS    AD                  Addr for Area for Previous Op Code
DVCOPSTR DS    AD                  Addr of Start of Consecutive Instruc
DVCABNIN DS    AD                  Address of Abending Instruction
DVCOPNTR DS    3AD                 For Current Pointers in Output Area
DVCABNDO DS    FD                  Offset to Abending Instr in Wrk Area
DVCOPCNT DS    FD                  Consecutive Instructions Counter
DVCOP$CT DS    FD                  Instructions Processed Counter
DVCACCPT DS    FD                  Instructions Accepted Counter
DVCAFTCT DS    FD                  Instructions After Abend Counter
DVCRETCD DS    F                   Save Area for the Return Code
DVCOPCDE DS    H                   Save Area for Instruction Op Code
DVCOPCLN DS    XL1                 Save Area for the Op Code Length
DCVOSIGN DS    CL1                 '+/-' Sign Notation to Offset Value
         DS    0D                  Ensure Set for Doubleword Alignment
DVCOPWRK DS    XL16                Work Area for Unpacking Instruction
         DS    XL1                 Slack for Reverse of Low Order Byte
DVCOFF04 DS    F                   Save Area for Instruction Offset
         DS    XL1                 Slack Byte
DVCWRK09 DS    CL9                 General Purpose Work Area
DVCINSTR DS    CL16                Area for Instructn in Character Form
DVCXTEND DS    CL16                Area for Extended Mnemonic Format
DVCWAREA DS    CL100               Work Area for Disassembled Instructn
DVCLMODI DS    CL(LRTLMLEN)        Area for Load Module Information Blk
         DS    0D                  Ensure Set for Doubleword Alignment
DVCINARE DS    CL256               Input Area to Process Instructions
DVCLINE  DS    0CL133              Output Print Line Area
DVCCCNTL DS    CL1                 Carriage Control Character
DVCOLINE DS    CL132               Output Record Print Area
DVCOTARE DS    64CL(L'DVCOLINE)    Work Area to Process Instructions
DVCOTLEN EQU   *-DVCOTARE          Length of Work Area for Instructions
DVCONTRY EQU   (*-DVCOTARE)/L'DVCOTARE Number of Entries in Work Area
*
         LCA   DEFEND              Define End of Program RENT Work Area
*
***********************************************************************
*       End of Processing for Instructions in Vicinity of Abend       *
***********************************************************************
         EJECT ,
***********************************************************************
**************************+-----------------+**************************
**************************| D X M C 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|    D i s a s s e m b l e    H e x    M a c h i n e    C o d e     |*
*+-------------------------------------------------------------------+*
* PROGRAM NAME:    DXMC0000                                           *
*                                                                     *
* FUNCTION:        Disassemble Hex Format Machine Code into Assembler *
*                  Language Source Instruction.                       *
*                                                                     *
*                  This routine is responsible for the disassemble of *
*                  an instruction from a storage address. The storage *
*                  address of the instruction was passed to this      *
*                  routine from the calling program. The load module  *
*                  storage address passed by the caller points to the *
*                  machine code in hexadecimal notation that was      *
*                  generated by the assembler for the specific source *
*                  statement. The machine code components of the      *
*                  instruction are analyzed to verify the storage     *
*                  address pointed to as machine code represents a    *
*                  valid instruction. If the storage area cannot be   *
*                  validated as representing machine code for an      *
*                  assembler instruction, then exit from this routine.*
*                                                                     *
*                  If the instruction is valid, an assembler source   *
*                  statement is created from the hex machine code     *
*                  showing the symbolic assembler op-code for the     *
*                  machine instruction such as L, STH, or MVC. Then   *
*                  based on the machine instruction format the        *
*                  assembler operands that were used in the source    *
*                  instruction will be created from the machine code  *
*                  for designated registers, index registers, base    *
*                  registers, base displacement, bit masks, immediate *
*                  values, shift amounts, or data lengths.            *
*                                                                     *
*                  For the multiple-operation instructions which      *
*                  perform an algebraic or logical compare followed by*
*                  by a branch or trap, the explicit branch mask field*
*                  is not displayed. Instead the mask field is dropped*
*                  and in its place an extended mnemonic is put into  *
*                  a work area to be appended later to the end of the *
*                  instruction. For the boolean instructions the      *
*                  boolean variable (the mask) is displayed in hex    *
*                  except for the boolean insert, store, and test     *
*                  operations where a 4-bit mask indicating byte      *
*                  positions is displayed as binary bits. Immediate   *
*                  operand fields in the machine code are displayed in*
*                  their hex format, and relative immediate fields are*
*                  expressed in a decimal format as a positve or a    *
*                  negative displacement from the current location    *
*                  counter.                                           *
*                                                                     *
*                  Once the machine code from the load module in      *
*                  in memory has been formatted into an assembler     *
*                  language source statement, it is placed into the   *
*                  work area passed to this routine by the calling    *
*                  program.                                           *
*                                                                     *
* INPUT REGS:      R1 => Standard O/S Parameter List                  *
*                                                                     *
* INPUT DATA:      Parm1: Address of Area to Return Disassembled Code *
*                  Parm2: Address of Machine Instruction Table Entry  *
*                  Parm3: Address of Machine Instruction in Storage   *
*                  Parm4: Address of Area for Extended Mnemonic Code  *
*                  Parm5: Address of Area for Previous Operation Code *
*                  Parm6: Address of LGRWK2II Logger Work Area        *
*                  Parm7: Addr of Common Constants and Routines Area  *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* OUTPUT DATA:     A single Assembler source statement                *
*                                                                     *
* For example:                                                        *
*                                                                     *
* If input is a storage area containing a machine code instruction:   *
*                                                                     *
*   X'BE1734B6'                                                       *
*                                                                     *
* Then output is an assembler source statement:                       *
*                                                                     *
*   STCM   R1,B'0111',1206(R3)                                        *
*                                                                     *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY, AC=0                          *
*                                                                     *
* CALLING PROGRAM: DINS0000 - Logger Services Program to Display      *
*                             Abending Instruction Characteristics    *
*                  DIVC0000 - Logger Services Program to Process the  *
*                             Instructions in Vicinity of Abend       *
*                                                                     *
* CALLED PROGRAMS: None                                               *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                  04 - Warning                                       *
*                  08 - Error - Exit This Routine                     *
*                  12 - Severe Error - Exit This Routine              *
*                                                                     *
***********************************************************************
*
DXMC0000 LPGMNTRY TYPE=SUB,        Define As A Sub-Program Entry       X
               BASE=(12,11,8,7),   Establish Base Registers            X
               AMOD=64,RMOD=ANY,   Addressing and Residency Modes      X
               LCAPFX=DXM,         Establish LCA Prefix for This RSECT X
               LOG=OFF,            Always Turn Logging 'Off' in Logger!X
               LINKRTRN=BSM,       Define Return Linkage Instruction   X
               COPY@RT=YES         To Generate a Copyright Statement
         USING COM_DATA,RCOMM      Addressability to Common Data Area
         USING LGRWK2II,RLGW       Establish Addressability to LGRWK2II
         LMG   R0,R6,0(R1)         Load the Parameter Area Addresses
         STMG  R0,R4,DXMPARM@      Save Contents of Passed Parameters
         LLGTR R9,R5               Set Address for the Common Data Area
         LLGTR R10,R6              Set Address for LGRWK2II Work Area
         XC    DXMRETCD,DXMRETCD   Initialize the Return Code
*
*+-------------------------------------------------------------------+*
*| Disassemble a Hex Machine Code Instruction to Make It Displayable |*
*| as a Character Format Assembler Source Statement.                 |*
*+-------------------------------------------------------------------+*
*
         USING OP@CODES,R3         Addressability Machine Instructions
DXMC0100 DS    0H
         LG    R3,DXMMCHI@         Addr to Machine Instructn Tble Entry
         LTGR  R3,R3               Is a Machine Table Entry Available?
         BRZ   DXMCEXIT            No  => Branch to Exit This Routine
         LG    R5,DXMINST@         Get Addr of the Machine Instruction
         LTGR  R5,R5               Is There an Adr for Our Instruction?
         BRZ   DXMCEXIT            No  => Branch to Exit This Routine
DXMC0200 DS    0H
         LA    R1,DXMCEXIT         Get Retry Recovery Address (ESPIE)
         ST    R1,LGWRETRY         Preserve It In Case of an Abend
         LA    R15,8               In The Event of an Access Error
         ST    R15,DXMRETCD        Pre-set Return Code in Case of Error
         LLGC  R14,OP@OPRND        Obtain Leng in Bytes of Instruction
         BCTGR R14,R0              Decrement Length for the Execute
         MVC   DXMINSTR(*-*),0(R5) Target of Following EX Instruction
         EX    R14,*-6             Copy Machine Instruction to Wrk Area
         XC    LGWRETRY,LGWRETRY   Disable Recovery, Area Referenced
         XC    DXMRETCD,DXMRETCD   Clear the Return Code Field
         LLGC  R15,OP@OFSET        Get Offset for Instruction Format
         SLLG  R15,R15,2 Bits      Multiple by 4 for Branch Table Entry
DXMC0300 DS    0H
         B     *+4(R15)            Branch Based on Instruction Format
         BRU   DXMC0400            Instruction Format E, I, RI-c, RIL-c
         BRU   DXMC2000            Instruction Format RI-a and RI-b
         BRU   DXMC3000            Instruction Format RIE-a,c, RIL-a,b
         BRU   DXMC6000            Instruction Format RIE-b and RIE-f
         BRU   DXMC9000            Instruction Format RIE-d,e and RSI
         BRU   DXM10000            Instruction Format RIS
         BRU   DXM11000            Instruction Format RR
         BRU   DXM13000            Instruction Format RRD
         BRU   DXM14000            Instruction Format RRE
         BRU   DXM16000            Instruction Format RRF-a,b
         BRU   DXM19000            Instruction Format RRF-c,d
         BRU   DXM23000            Instruction Format RRF-e
         BRU   DXM25000            Instruction Format RRS
         BRU   DXM26000            Instruction Format RS-a and RS-b
         BRU   DXM29000            Instruction Format RSL
         BRU   DXM30000            Instruction Format RSY-a and RSY-b
         BRU   DXM34000            Instruction Format RX-a and RX-b
         BRU   DXM35000            Instruction Format RXE
         BRU   DXM37000            Instruction Format RXF
         BRU   DXM39000            Instruction Format RXY-a and RXY-b
         BRU   DXM41000            Instruction Format S
         BRU   DXM43000            Instruction Format SIL
         BRU   DXM44000            Instruction Format SI
         BRU   DXM45000            Instruction Format SIY
         BRU   DXM47000            Instruction Format SS-a
         BRU   DXM49000            Instruction Format SS-b
         BRU   DXM51000            Instruction Format SS-c
         BRU   DXM53000            Instruction Format SS-f
         BRU   DXM55000            Instruction Format SS-d
         BRU   DXM57000            Instruction Format SS-e
         BRU   DXM59000            Instruction Format SSE
         BRU   DXM61000            Instruction Format SSF
*
*+-------------------------------------------------------------------+*
*| Process the type E machine instruction format. This format is for |*
*| an operation using implied operands and an extended op-code field.|*
*|                                                                   |*
*| Instruction Group E:                                              |*
*| --------------------                                              |*
*|  PFPO  PR  PTFF  SAM24  SAM31  SAM64  SCKPF  TAM  TRAP2  UPT      |*
*|                                                                   |*
*| E                                                                 |*
*| +------------+                                                    |*
*| |Op Code     |                                                    |*
*| +------------+                                                    |*
*| 0           15                                                    |*
*+-------------------------------------------------------------------+*
*
DXMC0400 DS    0H
         CLC   OP@TYPE,=CL6'E'     This Format for a Type E Instructn?
         BRE   DXMCEXIT            Yes => Instruction Has No Operands
         CLC   OP@TYPE,=CL6'I'     This Format for an SVC Instruction?
         BRE   DXMC0500            Yes => Then Process Instruction
         CLC   OP@TYPE,=CL6'RI-c'  This for a RI-c Format Instruction?
         BRE   DXMC0800            Yes => Then Process Instruction
         CLC   OP@TYPE,=CL6'RIL-c' This for a RIL-c Format Instruction?
         BRE   DXMC0800            Yes => Then Process Instruction
         BRU   DXMCEXIT            No  => Branch to Exit This Routine
*
*+-------------------------------------------------------------------+*
*| Process the Type I machine instruction format. Basically the      |*
*| format I is an RR format instruction in which the entire second   |*
*| byte for both register fields is used instead as an immediate byte|*
*| to pass the SVC interrupt code number.                            |*
*|                                                                   |*
*| Instruction Group I:                                              |*
*| --------------------                                              |*
*|  SVC                                                              |*
*|                                                                   |*
*| I                                                                 |*
*| +----------------+                                                |*
*| |Op Code|    I   |                                                |*
*| +----------------+                                                |*
*|  0       8      15                                                |*
*+-------------------------------------------------------------------+*
*
DXMC0500 DS    0H
         LLGC  R0,DXMINSTR+1       Get the SVC Number in Instruction
         LLGT  R5,=A(OPC$SVCT)     Address of the SVC Instruction Table
         LA    R14,L'OPC$SVCT      Length of Each SVC Table Entry
         LLGF  R15,=A(OPC$SVCT+((OPC$SVNO*L'OPC$SVCT)-L'OPC$SVCT))
DXMC0600 DS    0H
         CLM   R0,B'0001',0(R5)    This Our SVC Instruction in Table?
         BRE   DXMC0700            Yes => Branch to Set SVC Description
         BRXLG R5,R14,DXMC0600     No  => Loop to Check Next SVC Entry
         BRU   DXMCEXIT            Not Found, Branch to Exit Routine
DXMC0700 DS    0H
         LG    R4,DXMRTNI@         Address of Area to Return Instructn
         CVD   R0,DXMOPWRK         SVC Number in Reg to Decimal Format
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit SVC Instructn Type to Character
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of Our SVC Number
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              SVC Interrupt Code as Decimal Number
         LA    R4,5(R2,R4)         Increment Past the Decimal Value
         MVC   0(OPC$S2LN,R4),OPC$S1LN(R5) Copy in the SVC Description
         BRU   DXMCEXIT            Done For This Format, Branch to Exit
*
*+-------------------------------------------------------------------+*
*| Process the type RI-c and the RIL-c variation machine instruction |*
*| format. These instruction formats are for an immediate operation  |*
*| with an extended op-code field, a 4-bit mask field, and a one-byte|*
*| relative immediate field for RI-c, and for RIL-c a longer two-byte|*
*| relative immediate field.                                         |*
*|                                                                   |*
*| Instruction Group RI-c         Instruction Group RIL-c            |*
*| ----------------------         -----------------------            |*
*|  BRC                            BRCL  PFDRL                       |*
*|                                                                   |*
*| RI3 / RI-c                     RIL3 / RIL-c                       |*
*| M1,RI2                         M1,RI2                             |*
*| +------------------------+     +--------------------------------+ |*
*| |Op Code| M1 |Op|  RI2   |     |Op Code| M1 |Op|       RI2      | |*
*| +------------------------+     +--------------------------------+ |*
*| 0        8    12 16     31     0        8    12 16             47 |*
*+-------------------------------------------------------------------+*
*
DXMC0800 DS    0H
         LG    R4,DXMRTNI@         Address of Area to Return Instructn
         LLGC  R0,DXMINSTR+1       Get the M1 Operand Mask in Instructn
         SRLG  R0,R0,4 Bits        Remove Op Code Bits and Isolate Mask
         CVD   R0,DXMOPWRK         Set the M1 Value to Packed Decimal
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit the M1 Mask Value to Character
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of CC/Mask Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy M1 Mask Value to Return Area
         LA    R4,1(R2,R4)         Increment Past Instructn Mask Value
         MVI   0(R4),C','          Insert Comma Character After M1 Mask
         LA    R4,1(,R4)           Increment to Immediate Value Field
         CLC   OP@TYPE,=CL6'RIL-c' This for a RIL-c Format Instruction?
         BRE   DXMC0900            Yes => Then Branch to Process RIL-c
         LH    R0,DXMINSTR+2       Get RI2 16-bit Signed Immed Value
         SLAG  R0,R0,1             Multiply by 2 for Relative Immediate
         BRU   DXMC1000            Branch to Process Immediate Value
DXMC0900 DS    0H
         ICM   R0,B'1111',DXMINSTR+2 Get RI2 32-bit Signed Immed Value
         SLAG  R0,R0,1             Multiply by 2 for Relative Immediate
DXMC1000 DS    0H
         CVD   R0,DXMOPWRK         Immed Value in Reg to Decimal Format
         MVC   DXMDECI2,DXMPTRN2   Copy in the Number Editing Pattern
         LA    R1,DXMFORC2         Load 1st Forced Result Char Location
         EDMK  DXMDECI2,DXMOPWRK   Edit Immediate Value to Character
         BRNM  DXMC1100            Branch if the Result is Positive
         MVI   0(R4),C'*'          Instruction Current Location Counter
         MVI   1(R4),C'-'          Target Indicates Branching Backward
         LA    R4,2(,R4)           Increment Past Operand Indicators
         BRU   DXMC1200            Branch to Process Source Statement
DXMC1100 DS    0H
         MVI   0(R4),C'*'          Instruction Current Location Counter
         MVI   1(R4),C'+'          Target Indicates Branching Forward
         LA    R4,2(,R4)           Increment Past Operand Indicators
DXMC1200 DS    0H
         LA    R2,DXMDECI2+L'DXMDECI2-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of Immediate Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Show Immediate Value in Char Format
         BRU   DXMCEXIT            Done For This Format, Branch to Exit
*
*+-------------------------------------------------------------------+*
*| Process the type RI-a and the RI-b variation machine instruction  |*
*| format. These instruction formats are for a register-and-immediate|*
*| operation with an extended op-code field, and a two-byte immediate|*
*| field for RI-a, and for RI-b a two-byte relative immediate field. |*
*|                                                                   |*
*| Instruction Group RI-a                                            |*
*| ----------------------                                            |*
*|  AGHI AHI  BRAS  BRCT  BRCTG  CGHI   CHI   IIHH  IIHL  IILH  IILL |*
*|  LGHI LHI  LLIHH LLIHL LLILH  LLILL  MGHI  MHI   NIHH  NIHL  NILH |*
*|  NILL OIHH OIHL  OILH  OILL   TMH    TMHH  TMHL  TML   TMLH  TMLL |*
*|                                                                   |*
*| Instruction Group RI-b                                            |*
*| ----------------------                                            |*
*|  BRAS BRCT BRCTG                                                  |*
*|                                                                   |*
*| RI1 / RI-a                      RI2 / RI-b                        |*
*| R1,I2                           R1,RI2                            |*
*| +----------------------+        +----------------------+          |*
*| |Op Code|R1|Op|   I2   |        |Op Code|R1|Op|   RI2  |          |*
*| +----------------------+        +----------------------+          |*
*| 0        8  12 16     31        0        8  12 16     31          |*
*+-------------------------------------------------------------------+*
*
DXMC2000 DS    0H
         LG    R4,DXMRTNI@         Address of Area to Return Instructn
         LLGC  R0,DXMINSTR+1       Get Register Operand for Instruction
         SRLG  R0,R0,4 Bits        Isolate Just the Register Operand
         CVD   R0,DXMOPWRK         Register No. Used to Decimal Format
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Register No. to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of Register Value
         MVI   0(R4),C'R'          To Designate Operand is for Register
         LA    R4,1(,R4)           Increment Past the Reg Designater
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Show Register as a Character Number
         LA    R4,1(R2,R4)         Increment Past the Register Operand
         MVI   0(R4),C','          Insert Comma Character After Operand
         LA    R4,1(,R4)           Increment to Immediate Value Field
         CLC   OP@TYPE,=CL6'RI-b'  This a Branch Relative Instruction?
         BRE   DXMC2300            Yes => Uses a Relative Immed Opernd
         CLC   OP@MCHCD,=XL2'A780' Show LHI Immediate Value in Decimal?
         BRE   DXMC2600            No  => Show Immediate Value in Hex
         CLC   OP@MCHCD,=XL2'A790' Show LGHI Immed Value in Decimal?
         BRE   DXMC2600            No  => Show Immediate Value in Hex
         CLC   OP@MCHCD,=XL2'A730' Show the Immediate Value in Decimal?
         BRNH  DXMC2600            No  => Show Immediate Value in Hex
         CLC   OP@MCHCD,=XL2'A7D0' Show the Immediate Value in Decimal?
         BRH   DXMC2600            No  => Show Immediate Value in Hex
DXMC2100 DS    0H
         LGH   R0,DXMINSTR+2       Get I2 16-bit Signed Immediate Value
         CVD   R0,DXMOPWRK         Immediate Value to Packed Decimal
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Immediate Value to Character
         BRNM  DXMC2200            Branch if the Result is Positive
         MVI   0(R4),C'-'          Indicate Immediate Value is Negative
         LA    R4,1(,R4)           Increment Past the Minus Character
DXMC2200 DS    0H
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of Immediate Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy Immediate Value to Return Area
         BRU   DXMCEXIT            Done For This Format, Branch to Exit
DXMC2300 DS    0H
         LGH   R0,DXMINSTR+2       Get RI2 16-bit Signed Immed Value
         SLAG  R0,R0,1             Multiply by 2 for Relative Immediate
         CVD   R0,DXMOPWRK         Immed Value to Packed Decimal Format
         MVC   DXMDECI2,DXMPTRN2   Copy in the Number Editing Pattern
         LA    R1,DXMFORC2         Load 1st Forced Result Char Location
         EDMK  DXMDECI2,DXMOPWRK   Edit Immediate Value to Character
         BRNM  DXMC2400            Branch if the Result is Positive
         MVI   0(R4),C'*'          Set for the Current Location Counter
         MVI   1(R4),C'-'          Target Indicates Branching Backward
         LA    R4,2(,R4)           Increment Past Operand Indicators
         BRU   DXMC2500            Branch to Process Source Statement
DXMC2400 DS    0H
         MVI   0(R4),C'*'          Set for the Current Location Counter
         MVI   1(R4),C'+'          Target Indicates Branching Forward
         LA    R4,2(,R4)           Increment Past Operand Indicators
DXMC2500 DS    0H
         LA    R2,DXMDECI2+L'DXMDECI2-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of Immediate Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Show Immediate Value in Char Format
         BRU   DXMCEXIT            Done For This Format, Branch to Exit
DXMC2600 DS    0H
         LLGH  R0,DXMINSTR+2       Get the 16-bit Immediate Value
         MVC   0(2,R4),=CL2'X'''   To Show Immediate Value in Hex Form
         LA    R4,2(,R4)           Increment to the I2 Operand Field
         STG   R0,DXMWORKD         Put Immediate Value to a Work Area
         UNPK  DXMOPWRK(5),DXMWORKD+6(3) ..Convert I2 From Hex to Zoned
         TR    DXMOPWRK(4),HEXCONV-C'0'  ..Translate Hex to Character
         MVC   0(4,R4),DXMOPWRK    Hex Value Now in a Character Format
         MVI   4(R4),C''''         End Hex I2 with a Closing Apostrophe
         BRU   DXMCEXIT            Done For This Format, Branch to Exit
*
*+-------------------------------------------------------------------+*
*| Process the type RIL-a and RIL-b variation machine instruction    |*
*| format. These instruction formats are for a register-and-immediate|*
*| operation with an extended op-code field, and a longer 32-bit     |*
*| immediate field for RIL-a, and for RIL-b a longer 32-bit relative |*
*| immediate field.                                                  |*
*|                                                                   |*
*| Instruction Group RIL-a                                           |*
*| -----------------------                                           |*
*|  AFI    AGFI   AIH    ALFI   ALGFI  ALSIH  ALSIHN  NIHF   NILF    |*
*|  CFI    CGFI   CIH    CLFI   CLGFI  CLIH   XIHF    XILF   IIHF    |*
*|  IILF   LGFI   LLIHF  LLILF  MSFI   MSGFI  OIHF    OILF   SLFI    |*
*|  SLGFI                                                            |*
*|                                                                   |*
*| Instruction Group RIL-b                                           |*
*| -----------------------                                           |*
*|  BRASL  BRCTH  CRL    CGRL   CGFRL  CHRL   CGHRL   CLRL   CLGRL   |*
*|  CLGFRL CLHRL  CLGHRL EXRL   LRL    LGRL   LGFRL   LARL   LHRL    |*
*|  LGHRL  LLGFRL LLHRL  LLGHRL STRL   STGRL  STHRL                  |*
*|                                                                   |*
*| RIL1 / RIL-a                     RIL1 / RIL-b                     |*
*| R1,I2                            R1,RI2                           |*
*| +------------------------------+ +------------------------------+ |*
*| |Op Code|R1|Op|      I2        | |Op Code|R1|Op|      RI2       | |*
*| +------------------------------+ +------------------------------+ |*
*|  0       8  12 16             47  0       8  12 16             47 |*
*+-------------------------------------------------------------------+*
*
DXMC3000 DS    0H
         LG    R4,DXMRTNI@         Address of Area to Return Instructn
         LLGC  R14,DXMINSTR+1      Get Register Operand for Instruction
         SRDL  R14,4 Bits          Isolate Just the Register Operand
         CVD   R14,DXMOPWRK        Register No. Used to Decimal Format
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Register No. to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of Register Value
         MVI   0(R4),C'R'          To Designate Operand is for Register
         LA    R4,1(,R4)           Increment Past the Reg Designater
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy Register Number to Return Area
         LA    R4,1(R2,R4)         Increment Past the Register Operand
         MVI   0(R4),C','          Insert Comma Character After Operand
         LA    R4,1(,R4)           Increment to the Next Operand Field
         CLC   OP@TYPE(3),=CL3'RIE'  This for an RIE-a or RIE-c Format?
         BRE   DXMC4000            Yes => Branch for RIE-a/RIE-c Format
         ICM   R0,B'1111',DXMINSTR+2 Operand Has 32-bit Immediate Value
         CLC   OP@MCHCD,=XL2'C200' Multiply Single Grande FW Immediate?
         BRE   DXMC3100            Yes => Signed Immediate as Decimal
         CLC   OP@MCHCD,=XL2'C210' Multiply Single Fullword Immediate?
         BRE   DXMC3100            Yes => Signed Immediate as Decimal
         CLC   OP@MCHCD,=XL2'C240' Subtract Logical Grande FW Immed?
         BRE   DXMC3200            Yes => Unsigned Immediate as Decimal
         CLC   OP@MCHCD,=XL2'C250' Subtract Logical Fullword Immediate?
         BRE   DXMC3200            Yes => Unsigned Immediate as Decimal
         CLC   OP@MCHCD,=XL2'C280' This Add Grande Fullword Immediate?
         BRE   DXMC3100            Yes => Signed Immediate as Decimal
         CLC   OP@MCHCD,=XL2'C290' This for an Add Fullword Immediate?
         BRE   DXMC3100            Yes => Signed Immediate as Decimal
         CLC   OP@MCHCD,=XL2'C2A0' Add Logical Grande Fullwd Immediate?
         BRE   DXMC3200            Yes => Unsigned Immediate as Decimal
         CLC   OP@MCHCD,=XL2'C2B0' Add Logical Fullword Immediate?
         BRE   DXMC3200            Yes => Unsigned Immediate as Decimal
         CLC   OP@MCHCD,=XL2'CC80' This for an Add Immediate High?
         BRE   DXMC3100            Yes => Signed Immediate as Decimal
         CLC   OP@MCHCD,=XL2'CCA0' Add Logical Signed Immediate High?
         BRE   DXMC3100            Yes => Signed Immediate as Decimal
         CLC   OP@MCHCD,=XL2'CCB0' Add Logical Signed Immed High Noset?
         BRE   DXMC3100            Yes => Signed Immediate as Decimal
         CLC   OP@TYPE,=CL6'RIL-b' Is This a Relative Long Instruction?
         BRE   DXMC3500            Yes => Uses a Relative Immed Operand
         BRU   DXMC3800            Not Relative or Arithmetic, Show Hex
DXMC3100 DS    0H
         LGFR  R0,R0               Instruct Uses Signed Immediate Value
         BRU   DXMC3300            Branch to Process Immediate Value
DXMC3200 DS    0H
         LLGFR R0,R0               Instruct Uses Unsigned Immed Value
DXMC3300 DS    0H
         CVDG  R0,DXMOPWRK         Immed Value in Reg to Decimal Format
         MVC   DXMDECI2,DXMPTRN2   Copy in the Number Editing Pattern
         LA    R1,DXMFORC2         Load 1st Forced Result Char Location
         EDMK  DXMDECI2,DXMOPWRK+8 Edit Immediate Value to Character
         BRNM  DXMC3400            Branch if the Result is Positive
         MVI   0(R4),C'-'          Indicate Immediate Value is Negative
         LA    R4,1(,R4)           Increment Past the Minus Character
DXMC3400 DS    0H
         LA    R2,DXMDECI2+L'DXMDECI2-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of Immediate Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Show Immediate Value in Char Format
         BRU   DXMCEXIT            Done With This Format,Branch to Exit
DXMC3500 DS    0H
         LGFR  R0,R0               Instruct Uses Signed Immediate Value
         SLAG  R0,R0,1             Multiply by Two for Relative Immed
         CVDG  R0,DXMOPWRK         Immed Value in Reg to Decimal Format
         MVC   DXMDECI2,DXMPTRN2   Copy in the Number Editing Pattern
         LA    R1,DXMFORC2         Load 1st Forced Result Char Location
         EDMK  DXMDECI2,DXMOPWRK+8 Edit Immediate Value to Character
         BRNM  DXMC3600            Branch if the Result is Positive
         MVI   0(R4),C'*'          Set for the Current Location Counter
         MVI   1(R4),C'-'          Target Indicates Branching Backward
         LA    R4,2(,R4)           Increment Past the Minus Character
         BRU   DXMC3700            Branch to Process Immediate Value
DXMC3600 DS    0H
         MVI   0(R4),C'*'          Set for the Current Location Counter
         MVI   1(R4),C'+'          Target Indicates Branching Forward
         LA    R4,2(,R4)           Increment Past the Plus Character
DXMC3700 DS    0H
         LA    R2,DXMDECI2+L'DXMDECI2-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of Immediate Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Show Immediate Value in Char Format
         BRU   DXMCEXIT            Done With This Format,Branch to Exit
DXMC3800 DS    0H
         MVC   0(2,R4),=CL2'X'''   To Show Immediate Value in Hex Form
         LA    R4,2(,R4)           Increment to the I2 Operand Field
         STG   R0,DXMWORKD         Put Immediate Value to a Work Area
         UNPK  DXMOPWRK(9),DXMWORKD+4(5) ..Convert I2 From Hex to Zoned
         TR    DXMOPWRK(8),HEXCONV-C'0'  ..Translate Hex to Character
         MVC   0(8,R4),DXMOPWRK    Hex Value Now in a Character Format
         MVI   8(R4),C''''         End Hex I2 with a Closing Apostrophe
         BRU   DXMCEXIT            Done For This Format, Branch to Exit
*
*+-------------------------------------------------------------------+*
*| Process the type RIE-a variation machine instruction format. The  |*
*| RIE-a instruction format is for a register-and-immediate operation|*
*| with a longer extended two-byte bifarcated op-code, a two-byte    |*
*| 16-bit immediate field, a 4-bit mask field, and two unused 4-bit  |*
*| operand fields.                                                   |*
*|                                                                   |*
*| Instruction Group RIE-a                                           |*
*| -----------------------                                           |*
*|  CGIT   CIT    CLFIT  CLGIT                                       |*
*|                                                                   |*
*| RIE1 / RIE-a                                                      |*
*| R1,I2,M3                                                          |*
*| +----------------------------------------+                        |*
*| |Op Code| R1 |----| I2 | M3 |----|Op Code|                        |*
*| +----------------------------------------+                        |*
*|  0       8    12   16   32   36   40    47                        |*
*+-------------------------------------------------------------------+*
*
DXMC4000 DS    0H
         CLC   OP@TYPE,=CL6'RIE-c' Our Instruction Use Relative Format?
         BRE   DXMC5000            Yes => Branch to Process RIE-c Form
         XC    DXMOPWRK(2),DXMOPWRK ..To Check RIE-a Instruction Format
         MVN   DXMOPWRK(1),DXMINSTR+1 ...Drop R1 and Extract Slack Bits
         CLI   DXMOPWRK,X'00'      Are the Instruction Slack Bits Zero?
         BRNE  DXMC4100            No  => Failed Instructn,Addr Invalid
         MVN   DXMOPWRK+1(1),DXMINSTR+4 Drop M3 Mask,Extract Slack Bits
         CLI   DXMOPWRK+1,X'00'    Are the Instruction Slack Bits Zero?
         BRE   DXMC4200            Yes => Branch to Process Instruction
DXMC4100 DS    0H
         LA    R15,8               Instruction Had Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Invalid Instructn
DXMC4200 DS    0H
         CLI   OP@MNEUM+1,C'L'     Instruction Use Unsigned I2 Operand?
         BRE   DXMC4300            Yes => Branch for Unsigned Immediate
         LGH   R0,DXMINSTR+2       Get 16-bit I2 Signed Immediate Value
         BRU   DXMC4400            Branch to Process Immediate Value
DXMC4300 DS    0H
         LLGH  R0,DXMINSTR+2       Get 16-bit I2 Unsigned Immed Value
DXMC4400 DS    0H
         CVD   R0,DXMOPWRK         Immed Value in Reg to Decimal Format
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Immediate Value to Character
         BRNM  DXMC4500            Branch if the Result is Positive
         MVI   0(R4),C'-'          Indicate Immediate Value is Negative
         LA    R4,1(,R4)           Increment Past the Minus Character
DXMC4500 DS    0H
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of Immediate Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Show Immediate Value in Char Format
         LLGC  R0,DXMINSTR+4       Get the M3 Operand for Instruction
         SRLG  R0,R0,4 Bits        Isolate Instruction Operand M3 Mask
         LG    R1,DXMRTNI@         Address of Area to Return Instructn
         AGHI  R1,-(L'OP@MNEUM+2)  Back up to Start of Base Mnemonic
         LLILL R6,(L'OP@MNEUM+1)   Length of Base Instruction Mnemonic
         LLGT  R5,=A(DXMXTEND)     Address of Extended Mnemonics Table
         LA    R14,L'DXMXTEND      Length of Each Mnemonic Table Entry
         LLGF  R15,=A(DXMXTEND+((DXM$XTNO*L'DXMXTEND)-L'DXMXTEND))
DXMC4600 DS    0H
         CLM   R0,B'0001',0(R5)    This Our Mask From Mnemonic Table?
         BRE   DXMC4700            Yes => Copy in the Extended Mnemonic
         BRXLG R5,R14,DXMC4600     No  => Loop to Check Next Tble Entry
         BRU   DXMC4900            Not Found, Branch to Hard Code M3
DXMC4700 DS    0H
         CLI   0(R1),C' '          Is This End of Base Mnemonic Name?
         BRE   DXMC4800            Yes => Process Extended Mnemonic
         LA    R1,1(,R1)           Increment to the Next Character
         BRCTG R6,DXMC4700         Loop to Find End of Base Mnemonic
         LA    R15,8               Instruction Had Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Invalid Instructn
DXMC4800 DS    0H
         MVC   0(DXM$X2LN,R1),DXM$X1LN(R5) Add the Extended Mnemonic
         LG    R2,DXMXTND@         Addr Extended Mnemonic Return Area
         MVC   0(DXM$X3LN,R2),DXM$X1LN+DXM$X2LN(R5) Add the Description
         BRU   DXMCEXIT            Done With RIE-a Format, Now Exit
DXMC4900 DS    0H
         LA    R4,1(R2,R4)         Increment Past I2 Immediate Operand
         MVI   0(R4),C','          Insert Comma Character After Operand
         LA    R4,1(,R4)           Increment to the M3 Mask Value Field
         CVD   R0,DXMOPWRK         Mask Value to Packed Decimal Format
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit M3 Mask Value to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of M3 Mask Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy M3 Mask Value to Return Area
         BRU   DXMCEXIT            Done With RIE-a Format, Now Exit
*
*+-------------------------------------------------------------------+*
*| Process the type RIE-c variation machine instruction format. The  |*
*| RIE-c instruction format is for a register-and-immediate operation|*
*| with a longer extended bifarcated op-code, a two-byte 16-bit      |*
*| relative immediate field, a one-byte 8-bit immediate field, and a |*
*| 4-bit mask field.                                                 |*
*|                                                                   |*
*| Instruction Group RIE-c                                           |*
*| -----------------------                                           |*
*|  CGIJ   CIJ    CLGIJ  CLIJ                                        |*
*|                                                                   |*
*| RIE3 / RIE-c                                                      |*
*| R1,I2,M3,RI4                                                      |*
*| +------------------------------------+                            |*
*| |Op Code| R1 | M3 | RI4 | I2 |Op Code|                            |*
*| +------------------------------------+                            |*
*|  0       8    12   16    32   40    47                            |*
*+-------------------------------------------------------------------+*
*
DXMC5000 DS    0H
         LLGC  R0,DXMINSTR+4       Get 8-bit I2 Operand Immediate Value
         CLI   OP@MNEUM+1,C'L'     Instruction Use Unsigned I2 Operand?
         BRE   DXMC5100            Yes => Branch for Unsigned Immediate
         ICMH  R0,B'1000',DXMINSTR+4 Get 8-bit Signed Immediate Operand
         SRAG  R0,R0,32+24 Bits    For Extending a Sign Bit in Register
DXMC5100 DS    0H
         CVD   R0,DXMOPWRK         Immediate Value to Packed Decimal
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Immediate Value to Character
         BRNM  DXMC5200            Branch if the Result is Positive
         MVI   0(R4),C'-'          Indicate Immediate Value is Negative
         LA    R4,1(,R4)           Increment Past the Minus Character
DXMC5200 DS    0H
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of Immediate Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy Immediate Value to Return Area
         LA    R4,1(R2,R4)         Increment Past I2 Immediate Operand
         MVI   0(R4),C','          Insert Comma Character After Operand
         LA    R4,1(,R4)           Increment to the M3 Mask Value Field
         SRLG  R0,R15,28 Bits      Held in R15,Now Put M3 Operand in R0
         LG    R1,DXMRTNI@         Address of Area to Return Instructn
         AGHI  R1,-(L'OP@MNEUM+2)  Back up to Start of Base Mnemonic
         LLILL R6,(L'OP@MNEUM+1)   Length of Base Instruction Mnemonic
         LLGT  R5,=A(DXMXTEND)     Address of Extended Mnemonics Table
         LA    R14,L'DXMXTEND      Length of Each Mnemonic Table Entry
         LLGF  R15,=A(DXMXTEND+((DXM$XTNO*L'DXMXTEND)-L'DXMXTEND))
DXMC5300 DS    0H
         CLM   R0,B'0001',0(R5)    This Our Mask From Mnemonic Table?
         BRE   DXMC5400            Yes => Copy in the Extended Mnemonic
         BRXLG R5,R14,DXMC5300     No  => Loop to Check Next Tble Entry
         BRU   DXMC5600            Not Found, Branch to Hard Code M3
DXMC5400 DS    0H
         CLI   0(R1),C' '          Is This End of Base Mnemonic Name?
         BRE   DXMC5500            Yes => Process Extended Mnemonic
         LA    R1,1(,R1)           Increment to the Next Character
         BRCTG R6,DXMC5400         Loop to Find End of Base Mnemonic
         LA    R15,8               Instruction Had Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Invalid Instructn
DXMC5500 DS    0H
         MVC   0(DXM$X2LN,R1),DXM$X1LN(R5) Add the Extended Mnemonic
         LG    R2,DXMXTND@         Addr Extended Mnemonic Return Area
         MVC   0(DXM$X3LN,R2),DXM$X1LN+DXM$X2LN(R5) Add the Description
         BRU   DXMC5700            Branch to Process the RI4 Operand
DXMC5600 DS    0H
         CVD   R0,DXMOPWRK         Set M3 Operand in a Decimal Format
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit M3 Mask Value to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of M3 Mask Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy M3 Mask Value to Return Area
         LA    R4,1(R2,R4)         Increment Past the M3 Mask Operand
         MVI   0(R4),C','          Insert Comma Character After Operand
         LA    R4,1(,R4)           Increment to the RI4 Operand Field
DXMC5700 DS    0H
         LGH   R0,DXMINSTR+2       Get 16-bit RI4 as Signed Immediate
         SLAG  R0,R0,1             Multiply by Two for Relative Immed
         CVD   R0,DXMOPWRK         Relative Immediate to Packed Decimal
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit RI4 Immed Value to Character
         BRNM  DXMC5800            Branch if the Result is Positive
         MVI   0(R4),C'*'          Set for the Current Location Counter
         MVI   1(R4),C'-'          Target Address is Branching Backward
         LA    R4,2(,R4)           Increment Past Operand Indicators
         BRU   DXMC5900            Process Immed Value to Return Area
DXMC5800 DS    0H
         MVI   0(R4),C'*'          Set for the Current Location Counter
         MVI   1(R4),C'+'          Target Address is Branching Forward
         LA    R4,2(,R4)           Increment Past Operand Indicators
DXMC5900 DS    0H
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of RI4 Immed Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Relative Immed Value to Return Area
         BRU   DXMCEXIT            Done With RIE3 Format, Now Exit
*
*+-------------------------------------------------------------------+*
*| Process the type RIE-b variation machine instruction format. The  |*
*| RIE-b instruction format is for a register-and-immediate operation|*
*| with a longer extended bifarcated op-code field, a two-byte 16-bit|*
*| relative immediate field, and a 4-bit mask field.                 |*
*|                                                                   |*
*| Instruction Group RIE-b                                           |*
*| -----------------------                                           |*
*|  CGRJ   CLGRJ  CLRJ   CRJ                                         |*
*|                                                                   |*
*| RIE2 / RIE-b                                                      |*
*| R1,R2,M3,RI4                                                      |*
*| +-----------------------------------------+                       |*
*| |Op Code| R1 | R2 | RI4 | M3 |----|Op Code|                       |*
*| +-----------------------------------------+                       |*
*|  0       8    12   16    32   36   40    47                       |*
*+-------------------------------------------------------------------+*
*
DXMC6000 DS    0H
         LG    R4,DXMRTNI@         Address of Area to Return Instructn
         SLGR  R15,R15             Clear to Hold the R2 Register Value
         LLGC  R0,DXMINSTR+1       Get Register Operands in Instruction
         SRLG  R15,R0,4 Bits       Isolate Just the R1 Register Operand
         LGR   R1,R15              R1 Register Operand to Work Register
         BRAS  R14,DXDW1000        R1 Register Used to a Decimal Format
         MVI   0(R4),C','          Insert Comma Character After Operand
         LA    R4,1(,R4)           Increment to the Next Operand Field
         NILL  R0,(X'000F')        Drop the R1 so only R2 Value Remains
         CVD   R0,DXMOPWRK         R2 Register Used to a Decimal Format
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Register No. to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of Register Value
         MVI   0(R4),C'R'          To Designate Operand is for Register
         LA    R4,1(,R4)           Increment Past the Reg Designater
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy Register Number to Return Area
         LA    R4,1(R2,R4)         Increment Past the Register Operand
         MVI   0(R4),C','          Insert Comma Character After Operand
         LA    R4,1(,R4)           Increment to the Next Operand Field
         CLC   OP@TYPE,=CL6'RIE-f' This for a RIE-f Format Instruction?
         BRE   DXMC7000            Yes => Branch to Process RIE-f Formt
DXMC6100 DS    0H
         LLGC  R0,DXMINSTR+4       Get the M3 Mask Value in Instruction
         TMLL  R0,X'000F'          Are the Unused Operand Bits Zero?
         BRZ   DXMC6200            Yes => Branch to Process Instruction
         LA    R15,8               Instruction Has Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Failed Instruction Addr is Invalid
DXMC6200 DS    0H
         SRLG  R0,R0,4 Bits        Isolate Just the M3 Mask Operand
         LG    R1,DXMRTNI@         Address of Area to Return Instructn
         AGHI  R1,-(L'OP@MNEUM+2)  Back up to Start of Base Mnemonic
         LLILL R6,(L'OP@MNEUM+1)   Length of Base Instruction Mnemonic
         LLGT  R5,=A(DXMXTEND)     Address of Extended Mnemonics Table
         LA    R14,L'DXMXTEND      Length of Each Mnemonic Table Entry
         LLGF  R15,=A(DXMXTEND+((DXM$XTNO*L'DXMXTEND)-L'DXMXTEND))
DXMC6300 DS    0H
         CLM   R0,B'0001',0(R5)    This Our Mask From Mnemonic Table?
         BRE   DXMC6400            Yes => Copy in the Extended Mnemonic
         BRXLG R5,R14,DXMC6300     No  => Loop to Check Next Tble Entry
         BRU   DXMC6600            Not Found, Branch to Hard Code M3
DXMC6400 DS    0H
         CLI   0(R1),C' '          Is This End of Base Mnemonic Name?
         BRE   DXMC6500            Yes => Process Extended Mnemonic
         LA    R1,1(,R1)           Increment to the Next Character
         BRCTG R6,DXMC6400         Loop to Find End of Base Mnemonic
         LA    R15,8               Instruction Had Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Invalid Instructn
DXMC6500 DS    0H
         MVC   0(DXM$X2LN,R1),DXM$X1LN(R5) Add the Extended Mnemonic
         LG    R2,DXMXTND@         Addr Extended Mnemonic Return Area
         MVC   0(DXM$X3LN,R2),DXM$X1LN+DXM$X2LN(R5) Add the Description
         BRU   DXMC6700            Branch to Process the RI4 Operand
DXMC6600 DS    0H
         CVD   R0,DXMOPWRK         Set M3 Operand in a Decimal Format
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit M3 Mask Value to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of M3 Mask Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy M3 Mask Value to Return Area
         LA    R4,1(R2,R4)         Increment Past the M3 Mask Operand
         MVI   0(R4),C','          Insert Comma Character After Operand
         LA    R4,1(,R4)           Increment to the RI4 Operand Field
DXMC6700 DS    0H
         LGH   R0,DXMINSTR+2       Get 16-bit RI4 as Signed Immediate
         SLAG  R0,R0,1             Multiply by Two for Relative Immed
         CVD   R0,DXMOPWRK         Relative Immediate to Packed Decimal
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit RI4 Immed Value to Character
         BRNM  DXMC6800            Branch if the Result is Positive
         MVI   0(R4),C'*'          Set for the Current Location Counter
         MVI   1(R4),C'-'          Target Address is Branching Backward
         LA    R4,2(,R4)           Increment Past Operand Indicators
         BRU   DXMC6900            Process Immed Value to Return Area
DXMC6800 DS    0H
         MVI   0(R4),C'*'          Set for the Current Location Counter
         MVI   1(R4),C'+'          Target Address is Branching Forward
         LA    R4,2(,R4)           Increment Past the Plus Character
DXMC6900 DS    0H
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of RI4 Immed Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Relative Immed Value to Return Area
         BRU   DXMCEXIT            Done With RIE2 Format, Now Exit
*
*+-------------------------------------------------------------------+*
*| Process the type REI-f machine instruction format. The RIE-f      |*
*| instruction format is for a register-and-immediate operation with |*
*| a longer extended two-byte bifarcated op-code, and three one-byte |*
*| immediate fields.                                                 |*
*|                                                                   |*
*| Instruction Group RIE-f                                           |*
*| -----------------------                                           |*
*|  RISBG RISBHG RISBLG RNSBG  ROSBG  RXSBG                          |*
*|                                                                   |*
*| RIE5 / RIE-f                                                      |*
*| R1,R2,I3,I4,I5                                                  |*
*| +----------------------------------------+                        |*
*| |Op Code| R1 | R2 | I3 | I4 | I5 |Op Code|                        |*
*| +----------------------------------------+                        |*
*|  0       8    12   16   24   32   40    47                        |*
*+-------------------------------------------------------------------+*
*
DXMC7000 DS    0H
         LLGC  R0,DXMINSTR+2       Get I3 Immediate Value in Instructn
         CLC   OP@MCHCD,=XL2'EC51' This Rotate with Bits Low (RISBLG)?
         BRE   DXMC7100            Yes => Branch to Process I3 Field
         CLC   OP@MCHCD,=XL2'EC5D' This Rotate with Bits High (RISBHG)?
         BRE   DXMC7100            Yes => Branch to Process I3 Field
         NILL  R0,X'003F'          Isolate Bits 2-7 of the I3 field
         BRU   DXMC7200            Branch to Process I3 Field Value
DXMC7100 DS    0H
         NILL  R0,X'001F'          Isolate Bits 3-7 of the I3 field
DXMC7200 DS    0H
         CLI   OP@MNEUM+1,C'I'     Rotate and Insert Bits Instruction?
         BRE   DXMC7600            Yes => I3 Immed Field Has No 'T' Bit
         TM    DXMINSTR+2,X'80'    Is There a Test-Results Control Bit?
         BRO   DXMC7300            Yes => Then Branch to Show Bit is On
         BRU   DXMC7600            No  => The Test-Results Bit is Off
DXMC7300 DS    0H
         LG    R1,DXMRTNI@         Address of Area to Return Instructn
         AGHI  R1,-(L'OP@MNEUM+2)  Back up to Start of Base Mnemonic
         LLILL R2,(L'OP@MNEUM+1)   Length of Base Instruction Mnemonic
DXMC7400 DS    0H
         CLI   0(R1),C' '          Is This End of Base Mnemonic Name?
         BRE   DXMC7500            Yes => Process Extended Mnemonic
         LA    R1,1(,R1)           Increment to the Next Character
         BRCTG R2,DXMC7400         Loop to Find End of Base Mnemonic
         MVC   0(6,R4),=CL6'X''80''+' Hard Code Test-results Bit as On
         LA    R4,6(,R4)           To Move to Next Position in Operand
         BRU   DXMC7600            Branch to Process I3 Operand Value
DXMC7500 DS    0H
         MVI   0(R1),C'T'          Add Extended Mnemonic for Test Mode
         LG    R2,DXMXTND@         Addr Extended Mnemonic Return Area
         MVC   0(4,R2),=CL4'Test'  Add the Description for Test Mode
DXMC7600 DS    0H
         CVD   R0,DXMOPWRK         Set I3 Value to Packed Decimal Form
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit M3 Mask Value to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of I3 Field Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy I3 Immed Value to Return Area
         LA    R4,1(R2,R4)         Increment Past the I3 Immed Operand
         MVI   0(R4),C','          Insert Comma Character After Operand
         LA    R4,1(,R4)           Increment to the I4 Operand Field
DXMC7700 DS    0H
         LLGC  R0,DXMINSTR+3       Get I4 Immediate Value in Instructn
         CLC   OP@MCHCD,=XL2'EC51' This Rotate with Bits Low (RISBLG)?
         BRE   DXMC7800            Yes => Branch to Process I4 Field
         CLC   OP@MCHCD,=XL2'EC5D' This Rotate with Bits High (RISBHG)?
         BRE   DXMC7800            Yes => Branch to Process I4 Field
         NILL  R0,X'003F'          Isolate Bits 2-7 of the I4 field
         BRU   DXMC7900            Branch to Process I4 Field Value
DXMC7800 DS    0H
         NILL  R0,X'001F'          Isolate Bits 3-7 of the I4 field
DXMC7900 DS    0H
         CLI   OP@MNEUM+1,C'I'     Rotate and Insert Bits Instruction?
         BRNE  DXMC8300            No  => I4 Immed Field Has No 'Z' Bit
         TM    DXMINSTR+3,X'80'    A Zero-Remaining-Bits Control Bit?
         BRO   DXMC8000            Yes => Branch to Show 'Z' Bit is On
         BRU   DXMC8300            Zero-Remaining-Bits Control Was Off
DXMC8000 DS    0H
         LG    R1,DXMRTNI@         Address of Area to Return Instructn
         AGHI  R1,-(L'OP@MNEUM+2)  Back up to Start of Base Mnemonic
         LLILL R2,(L'OP@MNEUM+1)   Length of Base Instruction Mnemonic
DXMC8100 DS    0H
         CLI   0(R1),C' '          Is This End of Base Mnemonic Name?
         BRE   DXMC8200            Yes => Process Extended Mnemonic
         LA    R1,1(,R1)           Increment to the Next Character
         BRCTG R2,DXMC8100         Loop to Find End of Base Mnemonic
         MVC   0(6,R4),=CL6'X''80''+' Code Zero-Remaining-Bits Control
         LA    R4,6(,R4)           To Move to Next Position in Operand
         BRU   DXMC8300            Branch to Process I4 Operand Value
DXMC8200 DS    0H
         MVI   0(R1),C'Z'          Add Extended Mnemonic for Zero Bits
         LG    R2,DXMXTND@         Addr Extended Mnemonic Return Area
         MVC   0(8,R2),=CL8'and Zero' ...Description for Remaining Bits
DXMC8300 DS    0H
         CVD   R0,DXMOPWRK         I4 Indicates the Ending Bit Position
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit M3 Mask Value to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of I4 Field Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy I4 Immed Value to Return Area
         LA    R4,1(R2,R4)         Increment Past the I4 Immed Operand
         MVI   0(R4),C','          Insert Comma Character After Operand
         LA    R4,1(,R4)           Increment to the I4 Operand Field
DXMC8400 DS    0H
         ICMH  R0,B'1000',DXMINSTR+4 ...Get 8-bit I5 Immediate Operand
         SRAG  R0,R0,32+24 Bits    For Extending a Sign Bit of Operand
         CVD   R0,DXMOPWRK         Immediate Value to Packed Decimal
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Immediate Value to Character
         BRNM  DXMC8500            Branch if the Result is Positive
         MVI   0(R4),C'-'          Indicate Immediate Value is Negative
         LA    R4,1(,R4)           Increment Past the Minus Character
DXMC8500 DS    0H
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of Immediate Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy I5 Immed Value to Return Area
         BRU   DXMCEXIT            Done With RIE-f Format, Now Exit
*
*+-------------------------------------------------------------------+*
*| Process the type RIE-d and RIE-e variation machine instruction    |*
*| formats, and the type RSI machine instruction format. These       |*
*| instruction formats are for a register-and-immediate operation    |*
*| with a longer extended two-byte bifarcated op-code and a longer   |*
*| two-byte immediate field for type RIL-d, and a longer extended    |*
*| two-byte bifarcated op-code with a longer two-byte relative       |*
*| immediate field for the RIE-e type. The RSI format has a one-byte |*
*| op-code with a longer two-byte relative immediate field.          |*
*|                                                                   |*
*| Instruction Group RIE-d          Instruction Group RIE-e          |*
*| -----------------------          -----------------------          |*
*|  AHIK  AGHIK  ALHSIK  ALGHSIK     BRXHG  BRXLG                    |*
*|                                                                   |*
*| RIE4 / RIE-d                     RIE4/ RIE-e                      |*
*| R1,R3,I2                         R1,R3,RI2                        |*
*| +------------------------------+ +------------------------------+ |*
*| |Op Code|R1|R3| I2  |--|Op Code| |Op Code|R1|R3| RI2 |--|Op Code| |*
*| +------------------------------+ +------------------------------+ |*
*|  0       8  12 16    32 40    47  0       8  12 16    32 40    47 |*
*|                                                                   |*
*| Instruction Group RSI                                             |*
*| ---------------------                                             |*
*|  BRXH  BRXLE                                                      |*
*|                                                                   |*
*| RSI                                                               |*
*| R1,R3,RI2                                                         |*
*| +-----------------------+                                         |*
*| |Op Code| R1 | R3 | RI2 |                                         |*
*| +-----------------------+                                         |*
*|  0       8    12   16  31                                         |*
*+-------------------------------------------------------------------+*
*
DXMC9000 DS    0H
         CLC   OP@TYPE(3),=CL3'RIE'  Register + Immed with Extended Op?
         BRNE  DXMC9100            No  => Branch to Process RSI Format
         LLGC  R1,DXMINSTR+4       For This Format Unused Area 8 Bits
         LTGR  R1,R1               All Unused Operand Area Bits Zero?
         BRZ   DXMC9100            Yes => Branch to Process Instruction
         LA    R15,8               Indicate a Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Instruction Address is Invalid
DXMC9100 DS    0H
         LG    R4,DXMRTNI@         Address of Area to Return Instructn
         SLGR  R15,R15             Clear to Hold the R3 Register Value
         LLGC  R0,DXMINSTR+1       Get Register Operands in Instruction
         SRLG  R15,R0,4 Bits       Isolate Just the R1 Register Operand
         LGR   R1,R15              R1 Register Operand to Work Register
         BRAS  R14,DXDW1000        R1 Register Used to a Decimal Format
         MVI   0(R4),C','          Insert Comma Character After Operand
         LA    R4,1(,R4)           Increment to the Next Operand Field
         NILL  R0,(X'000F')        Drop the R1 so only R3 Value Remains
DXMC9200 DS    0H
         CVD   R0,DXMOPWRK         R3 Register Used to a Decimal Format
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Register No. to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of Register Value
         MVI   0(R4),C'R'          To Designate Operand is for Register
         LA    R4,1(,R4)           Increment Past the Reg Designater
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy Register Number to Return Area
         LA    R4,1(R2,R4)         Increment Past the Register Operand
         MVI   0(R4),C','          Insert Comma Character After Operand
         LA    R4,1(,R4)           Increment to the Next Operand Field
         CLC   OP@MNEUM(2),=CL2'BR' This a Branch Relative Instruction?
         BRE   DXMC9600            Yes => Uses a Relative Immed Operand
DXMC9300 DS    0H
         LGH   R0,DXMINSTR+2       Get 16-bit I2 Signed Immediate Value
         CVD   R0,DXMOPWRK         Set Operand Value to Packed Decimal
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit I2 Immediate Value to Character
         BRNM  DXMC9400            Branch if the Result is Positive
         MVI   0(R4),C'-'          Indicate Immediate Value is Negative
         LA    R4,1(,R4)           Increment Past the Minus Character
         BRU   DXMC9500            Process Immed Value to Return Area
DXMC9400 DS    0H
         MVI   0(R4),C'+'          Relative Immediate Value is Positive
         LA    R4,1(,R4)           Increment Past the Plus Character
DXMC9500 DS    0H
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of RI4 Immed Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Relative Immed Value to Return Area
         BRU   DXMCEXIT            Done With RIE2 Format, Now Exit
DXMC9600 DS    0H
         LGH   R0,DXMINSTR+2       Get 16-bit RI2 as Signed Immediate
         SLAG  R0,R0,1             Multiply by Two for Relative Immed
         CVD   R0,DXMOPWRK         Relative Immediate to Packed Decimal
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit RI2 Immed Value to Character
         BRNM  DXMC9700            Branch if the Result is Positive
         MVI   0(R4),C'*'          Set for the Current Location Counter
         MVI   1(R4),C'-'          Target Address is Branching Backward
         LA    R4,2(,R4)           Increment Past Operand Indicators
         BRU   DXMC9800            Process Immed Value to Return Area
DXMC9700 DS    0H
         MVI   0(R4),C'*'          Set for the Current Location Counter
         MVI   1(R4),C'+'          Target Address is Branching Forward
         LA    R4,2(,R4)           Increment Past the Plus Character
DXMC9800 DS    0H
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of RI4 Immed Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Relative Immed Value to Return Area
         BRU   DXMCEXIT            Done With RIE/RIS Format, Now Exit
*
*+-------------------------------------------------------------------+*
*| Process the type RIS machine instruction format. The RIS type     |*
*| instruction is for a register-and-immediate operation and a       |*
*| storage operation with a longer extended two-byte bifarcated      |*
*| op-code, a one-byte immediate field, and a 4-bit mask field.      |*
*|                                                                   |*
*| Instruction Group RIS                                             |*
*| ---------------------                                             |*
*|  CGIB  CIB   CLGIB  CLIB                                          |*
*|                                                                   |*
*| RIS                                                               |*
*| R1,I2,M3,D4(B4)                                                   |*
*| +----------------------------------------+                        |*
*| |Op Code| R1 | M3 | B4 | D4 | I2 |Op Code|                        |*
*| +----------------------------------------+                        |*
*|  0       8    12   16   20   32   40    47                        |*
*+-------------------------------------------------------------------+*
*
DXM10000 DS    0H
         LG    R4,DXMRTNI@         Address of Area to Return Instructn
         LLGC  R14,DXMINSTR+1      Get R1 Register Operand for Instruct
         SRDL  R14,4 Bits          Isolate Just the R1 Register Operand
         CVD   R14,DXMOPWRK        Register No. Used to Decimal Format
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Register No. to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of Register Value
         MVI   0(R4),C'R'          To Designate Operand is for Register
         LA    R4,1(,R4)           Increment Past the Reg Designater
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy R1 Register No. to Return Area
         LA    R4,1(R2,R4)         Increment Past the Register Operand
         MVI   0(R4),C','          Insert Comma Character After Operand
         LA    R4,1(,R4)           Increment to the Next Operand Field
         LLGC  R0,DXMINSTR+4       Get 8-bit I2 Operand Immediate Value
         CLI   OP@MNEUM+1,C'L'     Instruction Use Unsigned I2 Operand?
         BRE   DXM10100            Yes => Branch for Unsigned Immediate
         ICMH  R0,B'1000',DXMINSTR+4 ...Get 8-bit I5 Immediate Operand
         SRAG  R0,R0,32+24 Bits    For Extending a Sign Bit in Register
DXM10100 DS    0H
         CVD   R0,DXMOPWRK         Immediate Value to Packed Decimal
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Immediate Value to Character
         BRNM  DXM10200            Branch if the Result is Positive
         MVI   0(R4),C'-'          Indicate Immediate Value is Negative
         LA    R4,1(,R4)           Increment Past the Minus Character
DXM10200 DS    0H
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of Immediate Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy Immediate Value to Return Area
         LA    R4,1(R2,R4)         Increment Past I2 Immediate Operand
         MVI   0(R4),C','          Insert Comma Character After Operand
         LA    R4,1(,R4)           Increment to the M3 Mask Value Field
         SRLG  R0,R15,28 Bits      Held in R15,Now Put M3 Operand in R0
         LG    R1,DXMRTNI@         Address of Area to Return Instructn
         AGHI  R1,-(L'OP@MNEUM+2)  Back up to Start of Base Mnemonic
         LLGT  R5,=A(DXMXTEND)     Address of Extended Mnemonics Table
         LA    R14,L'DXMXTEND      Length of Each Mnemonic Table Entry
         LLGF  R15,=A(DXMXTEND+((DXM$XTNO*L'DXMXTEND)-L'DXMXTEND))
DXM10300 DS    0H
         CLM   R0,B'0001',0(R5)    This Our Mask From Mnemonic Table?
         BRE   DXM10400            Yes => Copy in the Extended Mnemonic
         BRXLG R5,R14,DXM10300     No  => Loop to Check Next Tble Entry
         BRU   DXM10600            Not Found, Branch to Hard Code M3
DXM10400 DS    0H
         CLI   0(R1),C' '          Is This End of Base Mnemonic Name?
         BRE   DXM10500            Yes => Process Extended Mnemonic
         LA    R1,1(,R1)           Increment to the Next Character
         BRU   DXM10400            Loop to Find End of Base Mnemonic
DXM10500 DS    0H
         MVC   0(DXM$X2LN,R1),DXM$X1LN(R5) Add the Extended Mnemonic
         LG    R2,DXMXTND@         Addr Extended Mnemonic Return Area
         MVC   0(DXM$X3LN,R2),DXM$X1LN+DXM$X2LN(R5) Add the Description
         BRU   DXM10700            Branch to Process the B4/D4 Operand
DXM10600 DS    0H
         CVD   R0,DXMOPWRK         Set M3 Operand in a Decimal Format
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit M3 Mask Value to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of M3 Mask Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy M3 Mask Value to Return Area
         LA    R4,1(R2,R4)         Increment Past the M3 Mask Operand
         MVI   0(R4),C','          Insert Comma Character After Operand
         LA    R4,1(,R4)           Increment to the B4/D4 Operand Field
DXM10700 DS    0H
         LLGH  R14,DXMINSTR+2      Get Base/Displacement B4/D4 Operands
         SLGR  R15,R15             Clear for Use as a D4 Work Register
         SRDL  R14,12 Bits         Isolate the B4 Base Register Number
         SRLG  R15,R15,20 Bits     D4 Displacement to Low Order Bytes
         CVD   R15,DXMOPWRK        Displacement Value to Packed Decimal
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit D4 Displacement to Character
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of D4 Field Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy D4 Displacment to Return Area
         LA    R4,1(R2,R4)         Increment Past the Displacement
         MVI   0(R4),C'('          Insert Left Parand After Operand
         LA    R4,1(,R4)           Increment to B4 Base Register Field
DXM10800 DS    0H
         CVD   R14,DXMOPWRK        Base Register Used to Decimal Format
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Base Register to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of Register Value
         MVI   0(R4),C'R'          To Designate Operand is for Register
         LA    R4,1(,R4)           Increment Past the Reg Designater
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy Register Number to Return Area
         LA    R4,1(R2,R4)         Increment Past the Register Operand
         MVI   0(R4),C')'          Insert Closing Parenthesis for Reg
         BRU   DXMCEXIT            Done for RIS Format, Branch to Exit
*
*+-------------------------------------------------------------------+*
*| Process the type RR machine instruction format. The RR type       |*
*| instruction is for a register-and-register operation with a       |*
*| one-byte op-code.                                                 |*
*|                                                                   |*
*| Instruction Group RR                                              |*
*| --------------------                                              |*
*|  ADR   AER   ALR   AR   AUR   AWR   AXR  BALR  BASR  BASSM   BCR  |*
*|  BCTR  BSM   CDR   CER  CLCL  CLR   CR   DDR   DER   DR      HDR  |*
*|  HER   LCDR  LCER  LCR  LDR   LDXR  LEDR LER   LNDR  LNER    LNR  |*
*|  LPDR  LPER  LPR   LR   LRDR  LRER  LTDR LTER  LTR   MDER    MDR  |*
*|  MER   MR    MVCL  MXDR MXR   NR    OR   SDR   SER   SLR     SPM  |*
*|  SR    SUR   SWR   SXR  XR                                        |*
*|                                                                   |*
*| RR                              RR                                |*
*| R1,R2                           M1,R2                             |*
*| +-----------------+             +-----------------+               |*
*| |Op Code| R1 | R2 |             |Op Code| M1 | R2 |               |*
*| +-----------------+             +-----------------+               |*
*|  0       8    12 15              0       8    12 15               |*
*+-------------------------------------------------------------------+*
*
DXM11000 DS    0H
         SLGR  R15,R15             Clear to Hold the R1 Register Value
         LLGC  R0,DXMINSTR+1       Get Register Operands in Instruction
         SRLG  R15,R0,4 Bits       Isolate Just the R1 Register Operand
         NILL  R0,(X'000F')        Drop the R1 so only R2 Value Remains
         LLGT  R1,=A(DXM$PAIR)     Address of the Register Pair Table
         LA    R4,L'DXM$PAIR       Len of Each Register Use Table Entry
         LLGF  R5,=A(DXM$PAIR+((DXM$RTNO*L'DXM$PAIR)-L'DXM$PAIR))
DXM11100 DS    0H
         LLGC  R2,0(,R1)           Get Bit Indicator From Reg Pair Tble
         TM    OP@REGEO,(0)        Indicated Target of the Execute
         EX    R2,*-4              Instructn Reg Attribute Match Table?
         BRO   DXM11200            Yes => Instruction has Register Pair
         BRXLG R1,R4,DXM11100      No  => Loop to Check Next Pair Type
         BRU   DXM11900            Instruction Uses No Register Pair(s)
DXM11200 DS    0H
         ICM   R2,B'0011',DXM$R1LN(R1) ..Get the Branch Location Offset
         BRZ   DXM11900            No  => Then Uses No Register Pair(s)
         LLGT  R1,=A(DXMC0000)     Base Address to Calculate the Offset
         LA    R14,0(R2,R1)        Add Offset to Base for Branch Addr
         BR    R14                 Branch Based on Register Attributes
DXM11300 DS    0H
         STC   R15,DXMWORKD        R1 Operand Register to a Work Area
         TRT   DXMWORKD(1),DXMFLTPT ..Valid FltPt R1 Register Coupling?
         BRZ   DXM11900            Yes => Branch to Process Instruction
         LA    R15,8               No  => Indicate Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM11400 DS    0H
         STC   R0,DXMWORKD         R2 Operand Register to a Work Area
         TRT   DXMWORKD(1),DXMFLTPT ..Valid FltPt R2 Register Coupling?
         BRZ   DXM11900            Yes => Branch to Process Instruction
         LA    R15,8               No  => Indicate Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM11500 DS    0H
         STC   R15,DXMWORKD        R1 Operand Register to a Work Area
         STC   R0,DXMWORKD+1       R2 Operand Register to a Work Area
         TRT   DXMWORKD(1),DXMFLTPT ..Valid FltPt R1 Register Coupling?
         BRNZ  DXM11600            No  => FltPt R1 Not a Valid Register
         TRT   DXMWORKD+1(1),DXMFLTPT Valid FltPt R2 Register Coupling?
         BRZ   DXM11900            Yes => Both R1+R2 Valid Fltpt Pairs
DXM11600 DS    0H
         LA    R15,8               No  => Indicate Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM11700 DS    0H
         TM    DXMINSTR+1,X'11'    Are Both R1+R2 Even for an E/O Pair?
         BRZ   DXM11900            Yes => Instruction Has Valid Pairing
         LA    R15,8               No  => Indicate Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM11800 DS    0H
         TM    DXMINSTR+1,X'10'    Is the R1 Reg Even for an E/O Pair?
         BRZ   DXM11900            No  => Then Instruction Has Valid R1
         LA    R15,8               Indicate a Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity
DXM11900 DS    0H
         LG    R4,DXMRTNI@         Address of Area to Return Instructn
         CLC   OP@MCHCD,=XL2'0700' A Branch on Condition Instruction?
         BRNE  DXM12000            No  => For Others the R1 is a Reg
         CVD   R15,DXMOPWRK        Set the M1 Value to Packed Decimal
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit M1 Cond Code Value to Character
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of Cond Code Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy the M1 CC Value to Return Area
         LA    R4,1(R2,R4)         Increment Past Instruction CC Value
         BRU   DXM12100            Branch to Process the R2 Operand
DXM12000 DS    0H
         LGR   R1,R15              R1 Register Operand to Work Register
         BRAS  R14,DXDW1000        R1 Register Used to a Decimal Format
DXM12100 DS    0H
         CLC   OP@MCHCD,=XL2'0400' This a Set Program Mask Instruction?
         BRE   DXM12200            Yes => Then It Only Uses One Operand
         MVI   0(R4),C','          Insert Comma Character After Operand
         LA    R4,1(,R4)           Increment to the Next Operand Field
         LGR   R1,R0               R2 Register Operand to Work Register
         BRAS  R14,DXDW1000        R2 Register Used to a Decimal Format
DXM12200 DS    0H
         BRU   DXMCEXIT            Done for RR Format, Branch to Exit
*
*+-------------------------------------------------------------------+*
*| Process the type RRD machine instruction format. The RRD type     |*
*| is for a register-and-register operation with a longer two-byte   |*
*| contiguous op-code field, and an additional R field.              |*
*|                                                                   |*
*| Instruction Group RRD                                             |*
*| ---------------------                                             |*
*| MAER  MADR   MSER  MSDR  MAYR  MAYHR  MAYLR   MYR   MYHR  MYLR    |*
*| MAEBR MADBR  MSEBR MSDBR                                          |*
*|                                                                   |*
*| RRD                                                               |*
*| R1,R3,R2                                                          |*
*| +-------------------------------+                                 |*
*| |  Op Code  | R1 |----| R3 | R2 |                                 |*
*| +-------------------------------+                                 |*
*|  0           16   20   24   28 31                                 |*
*+-------------------------------------------------------------------+*
*
DXM13000 DS    0H
         SLGR  R15,R15             Clear to Hold the R1 Register Value
         LLGC  R0,DXMINSTR+2       Get R1 Register Operand in Instructn
         SRLG  R15,R0,4 Bits       Isolate Just the R1 Register Operand
         TMLL  R0,(X'000F')        Area Not Used as Operand All Zeros?
         BRZ   DXM13100            Yes => Branch to Process Instruction
         LA    R15,8               Indicate a Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM13100 DS    0H
         LLGT  R1,=A(DXM$PAIR)     Address of the Register Pair Table
         LA    R4,L'DXM$PAIR       Len of Each Register Use Table Entry
         LLGF  R5,=A(DXM$PAIR+((DXM$RTNO*L'DXM$PAIR)-L'DXM$PAIR))
DXM13200 DS    0H
         LLGC  R2,0(,R1)           Get Bit Indicator From Reg Pair Tble
         TM    OP@REGEO,(0)        Indicated Target of the Execute
         EX    R2,*-4              Instructn Reg Attribute Match Table?
         BRO   DXM13300            Yes => Instruction has Register Pair
         BRXLG R1,R4,DXM13200      No  => Loop to Check Next Pair Type
         BRU   DXM13500            Instruction Uses No Register Pair(s)
DXM13300 DS    0H
         ICM   R2,B'0011',DXM$R1LN+DXM$R2LN*2(R1) Brnch Location Offset
         BRZ   DXM13500            No  => Then Uses No Register Pair(s)
         LLGT  R1,=A(DXMC0000)     Base Address to Calculate the Offset
         LA    R14,0(R2,R1)        Add Offset to Base for Branch Addr
         BR    R14                 Branch Based on Register Attributes
DXM13400 DS    0H
         STC   R15,DXMWORKD        R1 Operand Register to a Work Area
         TRT   DXMWORKD(1),DXMFLTPT ..Valid FltPt R1 Register Coupling?
         BRZ   DXM13500            Yes => Branch to Process Instruction
         LA    R15,8               No  => Indicate Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM13500 DS    0H
         LG    R4,DXMRTNI@         Address of Area to Return Instructn
         LGR   R1,R15              R1 Register Operand to Work Register
         BRAS  R14,DXDW1000        R1 Register Used to a Decimal Format
         MVI   0(R4),C','          Insert Comma Character After Operand
         LA    R4,1(,R4)           Increment to the Next Operand Field
DXM13600 DS    0H
         SLGR  R15,R15             Clear to Hold the Register Values
         LLGC  R0,DXMINSTR+3       Get Register Operands in Instruction
         SRLG  R15,R0,4 Bits       Isolate Just the R3 Register Operand
         NILL  R0,(X'000F')        Drop the R3 so only R2 Value Remains
         LGR   R1,R15              R3 Register Operand to Work Register
         BRAS  R14,DXDW1000        R3 Register Used to a Decimal Format
         MVI   0(R4),C','          Insert Comma Character After Operand
         LA    R4,1(,R4)           Increment to the Next Operand Field
DXM13700 DS    0H
         CVD   R0,DXMOPWRK         R2 Register Used to a Decimal Format
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Register No. to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of Register Value
         MVI   0(R4),C'R'          To Designate Operand is for Register
         LA    R4,1(,R4)           Increment Past the Reg Designater
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy Register Number to Return Area
         BRU   DXMCEXIT            Done for RRD Format, Branch to Exit
*
*+-------------------------------------------------------------------+*
*| Process the type RRE machine instruction format. The RRE type     |*
*| is for a register-and-register operation with a longer extended   |*
*| two-byte contiguous op-code field.                                |*
*|                                                                   |*
*| Instruction Group RRE                                             |*
*| ---------------------                                             |*
*|  ADBR   AEBR  AGFR  AGR   ALCGR  ALCR  ALGFR  ALGR   AXBR  BAKR   |*
*|  BCTGR  BSA   BSG   CDBR  CDFBR  CDFR  CDGBR  CDGR   CDGTR CDSTR  |*
*|  CDTR   CDUTR CEBR  CEDTR CEFBR  CEFR  CEGBR  CEGR   CEXTR CGFR   |*
*|  CGR    CKSM  CLGFR CLGR  CLST   CMPSC CPYA   CSP    CSPG  CU41   |*
*|  CU42   CUDTR CUSE  CUXTR CXBR   CXFBR CXFR   CXGBR  CXGR  CXGTR  |*
*|  CXR    CXSTR CXTR  CXUTR DDBR   DEBR  DLGR   DLR    DSGFR DSGR   |*
*|  DXBR   DXR   EAR   EEDTR EEXTR  EFPC  EPAIR  EPAR   EPSW  EREG   |*
*|  EREGG  ESAIR ESAR  ESDTR ESEA   ESTA  ESXTR  FIDR   FIER  FIXR   |*
*|  FLOGR  IAC   IPM   IPTE  ISKE   IVSK  KDBR   KDTR   KEBR  KIMD   |*
*|  KLMD   KM    KMAC  KMC   KXBR   KXTR  LBR    LCDBR  LCDFR LCEBR  |*
*|  LCGFR  LCGR  LCXBR LCXR  LDEBR  LDER  LDGR   LDXBR  LEDBR LEXBR  |*
*|  LEXR   LGBR  LGDR  LGFR  LGHR   LGR   LHR    LLCR   LLGCR LLGFR  |*
*|  LLGHR  LLGTR LLHR  LNDBR LNDFR  LNEBR LNGFR  LNGR   LNXBR LNXR   |*
*|  LPDBR  LPDFR LPEBR LPGFR LPGR   LPXBR LPXR   LRVGR  LRVR  LTDBR  |*
*|  LTDTR  LTEBR LTGFR LTGR  LTXBR  LTXR  LTXTR  LURA   LURAG LXDBR  |*
*|  LXDR   LXEBR LXER  LXR   LZDR   LZER  LZXR   MDBR   MDEBR MEEBR  |*
*|  MEER   MLGR  MLR   MSGFR MSGR   MSR   MSTA   MVPG   MVST  MXBR   |*
*|  MXDBR  NGR   OGR   PALB  PFMF   PGIN  PGOUT  PT     PTF   PTI    |*
*|  RRBE   SAR   SDBR  SEBR  SFASR  SFPC  SGFR   SGR    SLBGR SLBR   |*
*|  SLGFR  SLGR  SQDBR SQDR  SQEBR  SQER  SQXBR  SQXR   SRST  SRSTU  |*
*|  SSAIR  SSAR  STURA STURG SXBR   TAR   TB     THDER  THDR  TRE    |*
*|  XGR                                                              |*
*|                                                                   |*
*| RRE                                                               |*
*| R1,R2                                                             |*
*| +----------------------------+                                    |*
*| |  Op Code  |------| R1 | R2 |                                    |*
*| +----------------------------+                                    |*
*|  0           16     24   28 31                                    |*
*+-------------------------------------------------------------------+*
*
DXM14000 DS    0H
         LLGC  R1,DXMINSTR+2       For This Format Unused Area 8 Bits
         LTGR  R1,R1               Are Unused Operand Area Bits Zero?
         BRZ   DXM14100            Yes => Branch to Process Instruction
         LA    R15,8               Indicate a Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Instruction Address is Invalid
DXM14100 DS    0H
         SLGR  R15,R15             Clear to Hold the R1 Register Value
         LLGC  R0,DXMINSTR+3       Get Register Operands in Instruction
         SRLG  R15,R0,4 Bits       Isolate Just the R1 Register Operand
         NILL  R0,(X'000F')        Drop the R1 so only R2 Value Remains
         LLGT  R1,=A(DXM$PAIR)     Address of the Register Pair Table
         LA    R4,L'DXM$PAIR       Len of Each Register Use Table Entry
         LLGF  R5,=A(DXM$PAIR+((DXM$RTNO*L'DXM$PAIR)-L'DXM$PAIR))
DXM14200 DS    0H
         LLGC  R2,0(,R1)           Get Bit Indicator From Reg Pair Tble
         TM    OP@REGEO,(0)        Indicated Target of the Execute
         EX    R2,*-4              Instructn Reg Attribute Match Table?
         BRO   DXM14300            Yes => Instruction has Register Pair
         BRXLG R1,R4,DXM14200      No  => Loop to Check Next Pair Type
         BRU   DXM15600            Instruction Uses No Register Pair(s)
DXM14300 DS    0H
         ICM   R2,B'0011',DXM$R1LN+DXM$R2LN(R1)  Branch Location Offset
         BRZ   DXM15600            No  => Then Uses No Register Pair(s)
         LLGT  R1,=A(DXMC0000)     Base Address to Calculate the Offset
         LA    R14,0(R2,R1)        Add Offset to Base for Branch Addr
         BR    R14                 Branch Based on Register Attributes
DXM14400 DS    0H
         STC   R15,DXMWORKD        R1 Operand Register to a Work Area
         TRT   DXMWORKD(1),DXMFLTPT ..Valid FltPt R1 Register Coupling?
         BRZ   DXM15600            Yes => Branch to Process Instruction
         LA    R15,8               No  => Indicate Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM14500 DS    0H
         STC   R0,DXMWORKD         R2 Operand Register to a Work Area
         TRT   DXMWORKD(1),DXMFLTPT ..Valid FltPt R2 Register Coupling?
         BRZ   DXM15600            Yes => Branch to Process Instruction
         LA    R15,8               No  => Indicate Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM14600 DS    0H
         STC   R15,DXMWORKD        R1 Operand Register to a Work Area
         STC   R0,DXMWORKD+1       R2 Operand Register to a Work Area
         TRT   DXMWORKD(1),DXMFLTPT ..Valid FltPt R1 Register Coupling?
         BRNZ  DXM14700            No  => FltPt R1 Not a Valid Register
         TRT   DXMWORKD+1(1),DXMFLTPT Valid FltPt R2 Register Coupling?
         BRZ   DXM15600            Yes => Both R1+R2 Valid Fltpt Pairs
DXM14700 DS    0H
         LA    R15,8               Indicate a Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM14800 DS    0H
         STC   R15,DXMWORKD        R1 Operand Register to a Work Area
         TRT   DXMWORKD(1),DXMFLTPT ..Valid FltPt R1 Register Coupling?
         BRNZ  DXM14900            No  => Branch on Validity Chck Error
         TMLL  R0,X'0001'          Is the R2 Reg Even for an E/O Pair?
         BRZ   DXM15600            Yes => Then Instruction Has Valid R2
DXM14900 DS    0H
         LA    R15,8               Indicate a Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM15000 DS    0H
         TM    DXMINSTR+3,X'11'    Are Both R1+R2 Register Nos. Even?
         BRNZ  DXM15200            No  => Instructn Has Invalid Pairing
         CLC   OP@MCHCD,=XL2'B92A' This a Cipher Message with CFB?
         BRE   DXM15100            Yes => Branch to Verify Regs Not 0
         CLC   OP@MCHCD,=XL2'B92B' This a Cipher Message with OFB?
         BRE   DXM15100            Yes => Branch to Verify Regs Not 0
         CLC   OP@MCHCD,=XL2'B92E' This a Cipher Message Instruction?
         BRE   DXM15100            Yes => Branch to Verify Regs Not 0
         CLC   OP@MCHCD,=XL2'B92F' This Cipher Message with Chaining?
         BRE   DXM15100            Yes => Branch to Verify Regs Not 0
         BRU   DXM15600            No  => No Reg Number 0 Restriction
DXM15100 DS    0H
         LTGR  R15,R15             R1 Designate General Registerr Zero?
         BRZ   DXM15200            Yes => Then Invalid Register No.
         LTGR  R0,R0               R2 Designate General Registerr Zero?
         BRNZ  DXM15600            No  => Then Register No. is Not Zero
DXM15200 DS    0H
         LA    R15,8               Indicate a Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM15300 DS    0H
         TM    DXMINSTR+3,X'01'    Is the R2 Reg Even for an E/O Pair?
         BRZ   DXM15600            Yes => Then Instruction Has Valid R2
DXM15400 DS    0H
         LA    R15,8               Indicate a Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity
DXM15500 DS    0H
         TM    DXMINSTR+3,X'10'    Is the R1 Reg Even for an E/O Pair?
         BRZ   DXM15600            Yes => Then Instruction Has Valid R1
         LA    R15,8               Indicate a Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity
DXM15600 DS    0H
         LG    R4,DXMRTNI@         Address of Area to Return Instructn
         CVD   R15,DXMOPWRK        R1 Register Used to a Decimal Format
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Register No. to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of Register Value
         MVI   0(R4),C'R'          To Designate Operand is for Register
         LA    R4,1(,R4)           Increment Past the Reg Designater
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy Register Number to Return Area
         CLC   OP@MNEUM,=CL7'PTF'  This for Perform Topology Function?
         BRE   DXMCEXIT            Yes => Then an RRE that Only Uses R1
         LA    R4,1(R2,R4)         Increment Past the Register Operand
         MVI   0(R4),C','          Insert Comma Character After Operand
         LA    R4,1(,R4)           Increment to the Next Operand Field
DXM15700 DS    0H
         CVD   R0,DXMOPWRK         R2 Register Used to a Decimal Format
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Register No. to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of Register Value
         MVI   0(R4),C'R'          To Designate Operand is for Register
         LA    R4,1(,R4)           Increment Past the Reg Designater
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy Register Number to Return Area
         BRU   DXMCEXIT            Done for RRE Format, Branch to Exit
*
*+-------------------------------------------------------------------+*
*| Perform processing for type RRF-a variation instruction format.   |*
*| The RRF-a type is for a register-and-register operation with a    |*
*| longer extended two-byte contiguous op-code field, and an         |*
*| additional register field.                                        |*
*|                                                                   |*
*| Instruction Group RRF-a                                           |*
*| -----------------------                                           |*
*|  ADTR   ARK    AGRK   AHHHR  AHHLR  ALRK   ALGRK  ALHHHR  ALHHLR  |*
*|  AXTR   DDTR   DXTR   IPTE   MDTR   MXTR   NRK    NGRK    ORK     |*
*|  OGRK   SDTR   SGRK   SHHHR  SHHLR  SLRK   SLGRK  SLHHHR  SLHHLR  |*
*|  SRK    SXTR   XRK    XGRK                                        |*
*|                                                                   |*
*| RRF3 / RRF-a                                                      |*
*| R1,R2,R3                                                          |*
*| +-------------------------------+                                 |*
*| |  Op Code  | R3 |----| R1 | R2 |                                 |*
*| +-------------------------------+                                 |*
*|  0           16   20   24   28 31                                 |*
*+-------------------------------------------------------------------+*
*
DXM16000 DS    0H
         CLC   OP@TYPE,=CL6'RRF-b' Variation-b RRF Instruction Format?
         BRE   DXM17000            Yes => Process This Instructn Format
         XC    DXMOPWRK(1),DXMOPWRK ..To Check RRF-a Instruction Format
         MVN   DXMOPWRK(1),DXMINSTR+2 Drop R3, Check the Unused Operand
         CLI   DXMOPWRK,X'00'      Are Unused Operand Area Bits Zero?
         BRE   DXM16200            Yes => Branch to Check Attributes
DXM16100 DS    0H
         LA    R15,8               An Instruction Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM16200 DS    0H
         LLGC  R6,DXMINSTR+2       Get R3 Register Operand in Instructn
         SRLG  R6,R6,4 Bits        Isolate Just the R3 Register Operand
         SLGR  R15,R15             Clear to Hold the R1 Register Value
         LLGC  R0,DXMINSTR+3       Get Register Operands in Instruction
         SRLG  R15,R0,4 Bits       Isolate Just the R1 Register Operand
         NILL  R0,(X'000F')        Drop the R1 so only R2 Value Remains
         LLGT  R1,=A(DXM$PAIR)     Address of the Register Pair Table
         LA    R4,L'DXM$PAIR       Len of Each Register Use Table Entry
         LLGF  R5,=A(DXM$PAIR+((DXM$RTNO*L'DXM$PAIR)-L'DXM$PAIR))
DXM16300 DS    0H
         LLGC  R2,0(,R1)           Get Bit Indicator From Reg Pair Tble
         TM    OP@REGEO,(0)        Indicated Target of the Execute
         EX    R2,*-4              Instructn Reg Attribute Match Table?
         BRO   DXM16400            Yes => Instruction has Register Pair
         BRXLG R1,R4,DXM16300      No  => Loop to Check Next Pair Type
         BRU   DXM16700            Instruction Uses No Register Pair(s)
DXM16400 DS    0H
         ICM   R2,B'0011',DXM$R1LN+DXM$R2LN*3(R1) Brnch Location Offset
         BRZ   DXM16700            No  => Then Uses No Register Pair(s)
         LLGT  R1,=A(DXMC0000)     Base Address to Calculate the Offset
         LA    R14,0(R2,R1)        Add Offset to Base for Branch Addr
         BR    R14                 Branch Based on Register Attributes
DXM16500 DS    0H
         STC   R15,DXMWORKD        R1 Operand Register to a Work Area
         STC   R0,DXMWORKD+1       R2 Operand Register to a Work Area
         STC   R6,DXMWORKD+2       R3 Operand Register to a Work Area
         TRT   DXMWORKD(1),DXMFLTPT ..Valid FltPt R1 Register Coupling?
         BRNZ  DXM16600            No  => FltPt R1 Not a Valid Register
         TRT   DXMWORKD+1(1),DXMFLTPT Valid FltPt R2 Register Coupling?
         BRNZ  DXM16600            Yes => Both R1+R2 Valid Fltpt Pairs
         TRT   DXMWORKD+2(1),DXMFLTPT Valid FltPt R3 Register Coupling?
         BRZ   DXM16700            Yes => R1+R2+R3 Valid Fltpt Pairs
DXM16600 DS    0H
         LA    R15,8               An Instruction Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM16700 DS    0H
         LG    R4,DXMRTNI@         Address of Area to Return Instructn
         LGR   R1,R15              R1 Register Operand to Work Register
         BRAS  R14,DXDW1000        R1 Register Used to a Decimal Format
         MVI   0(R4),C','          Insert Comma Character After Operand
         LA    R4,1(,R4)           Increment to the Next Operand Field
DXM16800 DS    0H
         LGR   R1,R0               R2 Register Operand to Work Register
         BRAS  R14,DXDW1000        R2 Register Used to a Decimal Format
         MVI   0(R4),C','          Insert Comma Character After Operand
         LA    R4,1(,R4)           Increment to the Next Operand Field
DXM16900 DS    0H
         CVD   R6,DXMOPWRK         R3 Register Used to a Decimal Format
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Register No. to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of Register Value
         MVI   0(R4),C'R'          To Designate Operand is for Register
         LA    R4,1(,R4)           Increment Past the Reg Designater
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy R3 Register No. to Return Area
         BRU   DXMCEXIT            RRF-a Format Done, Branch to Exit
*
*+-------------------------------------------------------------------+*
*| Perform processing for type RRF-b variation instruction format.   |*
*| The RRF-b type is for a register-and-register operation with a    |*
*| longer extended two-byte contiguous op-code field, an additional  |*
*| register field, and in certain instances may also include a 4-bit |*
*| mask field.                                                       |*
*|                                                                   |*
*| Instruction Group RRF-b                                           |*
*| -----------------------                                           |*
*|  CPSDR  DIDBR  DIEBR  IDTE  IEDTR  IEXTR  KMCTR  LPTEA  QADTR     |*
*|  QAXTR  RRDTR  RRXTR                                              |*
*|                                                                   |*
*| RRF3 / RRF-b                                                      |*
*| R1,R3,R2,M4                                                     |*
*| +------------------------------+                                  |*
*| |  Op Code  | R3 |M4+| R1 | R2 |                                  |*
*| +------------------------------+                                  |*
*|  0           16   20  24   28 31                                  |*
*+-------------------------------------------------------------------+*
*
DXM17000 DS    0H
I        USING OP@CODES,R3         Addressability to Machine Tble Entry
         XC    DXMWORKD(1),DXMWORKD ..To Check RRF-b Instruction Format
         TM    I.OP@MODES,OP@M4NOP Is M4 Operand Used in Instruction?
         BRZ   DXM17100            Yes => Branch If M4 Operand is Used
         MVN   DXMWORKD(1),DXMINSTR+2 No M4, Check as an Unused Operand
         CLI   DXMWORKD,X'00'      Are Unused Operand Area Bits Zero?
         BRE   DXM17600            Yes => Branch to Check Attributes
         LA    R15,8               An Instruction Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM17100 DS    0H
         MVN   DXMWORKD(1),DXMINSTR+2  Drop R3 to Check the M4 Operand
         CLC   OP@MCHCD,=XL2'B353' Is This a Divide to Integer Short?
         BRE   DXM17200            Yes => Verify Rounding Modifier Bits
         CLC   OP@MCHCD,=XL2'B35B' Is This a Divide to Integer Long?
         BRE   DXM17200            Yes => Verify Rounding Modifier Bits
         CLC   OP@MCHCD,=XL2'B9AA' This Load Page Table Entry Address?
         BRE   DXM17400            Yes => Verify ASC Element Mask Bits
         BRU   DXM17600            No  => Branch to Process Instruction
DXM17200 DS    0H
         USING PSA,R0              Establish Addressability to the PSA
         TM    FLCFACL4,X'04'      Floating Point Extension Facility?
         BRO   DXM17300            Yes => FP Extension Facil Available
         TRT   DXMWORKD(1),DXMFPBNX .Valid Quotient Rounding Modifiers?
         BRZ   DXM17600            Yes => Branch to Process Instruction
         BRU   DXM17500            No  => Branch on Validity Chck Error
         DROP  R0                  Remove Listed Reg as PSA Base Reg
DXM17300 DS    0H
         TRT   DXMWORKD(1),DXMFPBXF .Valid Quotient Rounding Modifiers?
         BRZ   DXM17600            Yes => Branch to Process Instruction
         BRU   DXM17500            No  => Branch on Validity Chck Error
DXM17400 DS    0H
         TRT   DXMWORKD(1),DXMASCEM Address Space Control Element Bits?
         BRZ   DXM17600            Yes => A Valid Combination of Bits
DXM17500 DS    0H
         LA    R15,8               An Instruction Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM17600 DS    0H
         LLGC  R6,DXMINSTR+2       Get R3 Register Operand in Instructn
         SRLG  R6,R6,4 Bits        Isolate Just the R3 Register Operand
         SLGR  R15,R15             Clear to Hold the R1 Register Value
         LLGC  R0,DXMINSTR+3       Get Register Operands in Instruction
         SRLG  R15,R0,4 Bits       Isolate Just the R1 Register Operand
         NILL  R0,(X'000F')        Drop the R1 so only R2 Value Remains
         LLGT  R1,=A(DXM$PAIR)     Address of the Register Pair Table
         LA    R4,L'DXM$PAIR       Len of Each Register Use Table Entry
         LLGF  R5,=A(DXM$PAIR+((DXM$RTNO*L'DXM$PAIR)-L'DXM$PAIR))
DXM17700 DS    0H
         LLGC  R2,0(,R1)           Get Bit Indicator From Reg Pair Tble
         TM    OP@REGEO,(0)        Indicated Target of the Execute
         EX    R2,*-4              Instructn Reg Attribute Match Table?
         BRO   DXM17800            Yes => Instruction has Register Pair
         BRXLG R1,R4,DXM17700      No  => Loop to Check Next Pair Type
         BRU   DXM18500            Instruction Uses No Register Pair(s)
DXM17800 DS    0H
         ICM   R2,B'0011',DXM$R1LN+DXM$R2LN*4(R1) Brnch Location Offset
         BRZ   DXM18500            No  => Then Uses No Register Pair(s)
         LLGT  R1,=A(DXMC0000)     Base Address to Calculate the Offset
         LA    R14,0(R2,R1)        Add Offset to Base for Branch Addr
         BR    R14                 Branch Based on Register Attributes
DXM17900 DS    0H
         STC   R15,DXMWORKD        R1 Operand Register to a Work Area
         STC   R6,DXMWORKD+1       R3 Operand Register to a Work Area
         TRT   DXMWORKD(1),DXMFLTPT ..Valid FltPt R1 Register Coupling?
         BRNZ  DXM18000            No  => FltPt R1 Not a Valid Register
         TRT   DXMWORKD+1(1),DXMFLTPT Valid FltPt R3 Register Coupling?
         BRZ   DXM18500            Yes => Both R1+R3 Valid Fltpt Pairs
DXM18000 DS    0H
         LA    R15,8               No  => Indicate Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM18100 DS    0H
         STC   R15,DXMWORKD        R1 Operand Register to a Work Area
         STC   R0,DXMWORKD+1       R2 Operand Register to a Work Area
         STC   R6,DXMWORKD+2       R3 Operand Register to a Work Area
         TRT   DXMWORKD(1),DXMFLTPT ..Valid FltPt R1 Register Coupling?
         BRNZ  DXM18200            No  => FltPt R1 Not a Valid Register
         TRT   DXMWORKD+1(1),DXMFLTPT Valid FltPt R2 Register Coupling?
         BRNZ  DXM18200            No  => FltPt R2 Not a Valid Register
         TRT   DXMWORKD+2(1),DXMFLTPT Valid FltPt R3 Register Coupling?
         BRNZ  DXM18200            No  => FltPt R3 Not a Valid Register
         TM    I.OP@MODES,OP@RDIFF Must Also Designate Different Regs?
         BRZ   DXM18500            No  => Only Verify Regs Valid FltPnt
         CLGR  R15,R0              Is R1 Reg No. Same As R2 Reg No.?
         BRE   DXM18200            Yes => Requirement Must be Different
         CLGR  R15,R6              Is R1 Reg No. Same As R3 Reg No.?
         BRE   DXM18200            Yes => Requirement Must be Different
         CLGR  R0,R6               Is R2 Reg No. Same As R3 Reg No.?
         BRNE  DXM18500            No  => Reg Designates Different No.
DXM18200 DS    0H
         LA    R15,8               An Instruction Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM18300 DS    0H
         TM    DXMINSTR+3,X'11'    Are Both R1+R2 Even Numbered Regs?
         BRNZ  DXM18400            No  => Instruction Has Invalid Regs
         TM    I.OP@MODES,OP@R3EVN Is R3 Operand Required to Be Even?
         BRZ   DXM18500            No  => Branch If R3 Not Required
         TM    DXMINSTR+2,X'10'    Is the R3 an Even Numbered Register?
         BRZ   DXM18500            Yes => Branch to Process Instruction
DXM18400 DS    0H
         LA    R15,8               No  => Indicate Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
         DROP  I                   Remove Listed Reg as Tble Entry Base
DXM18500 DS    0H
         LG    R4,DXMRTNI@         Address of Area to Return Instructn
         LGR   R1,R15              R1 Register Operand to Work Register
         BRAS  R14,DXDW1000        R1 Register Used to a Decimal Format
         MVI   0(R4),C','          Insert Comma Character After Operand
         LA    R4,1(,R4)           Increment to the Next Operand Field
DXM18600 DS    0H
         LGR   R1,R6               R3 Register Operand to Work Register
         BRAS  R14,DXDW1000        R3 Register Used to a Decimal Format
         MVI   0(R4),C','          Insert Comma Character After Operand
         LA    R4,1(,R4)           Increment to the Next Operand Field
DXM18700 DS    0H
         LGR   R1,R0               R2 Register Operand to Work Register
         BRAS  R14,DXDW1000        R2 Register Used to a Decimal Format
DXM18800 DS    0H
M        USING OP@CODES,R3         Addressability to Machine Tble Entry
         TM    M.OP@MODES,OP@M4NOP Is M4 Operand Used in Instruction?
         BRNZ  DXM18900            No  => Branch If M4 Operand Not Used
         MVI   0(R4),C','          Insert Comma Character for M4 Opernd
         LA    R4,1(,R4)           Increment to the M4 Operand Field
         LLGC  R0,DXMINSTR+2       Get the M4 Operand in Instruction
         NILL  R0,(X'000F')        Drop Bits so only M4 Value Remains
         CVD   R0,DXMOPWRK         M4 Operand Used to a Decimal Format
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit the M4 Value to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of Edited M4 Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy M4 Mask Value to Return Area
DXM18900 DS    0H
         BRU   DXMCEXIT            RRF-b Format Done, Branch to Exit
         DROP  M                   Remove Listed Reg as Tble Entry Base
*
*+-------------------------------------------------------------------+*
*| Perform processing for type RRF-c variation instruction format.   |*
*| The RRF-c type is for a register-and-register operation with a    |*
*| longer extended two-byte contiguous op-code field, a 4-bit unused |*
*| operand field, and in certain instances may also include a 4-bit  |*
*| mask field.                                                       |*
*|                                                                   |*
*| Instruction Group RRF-c                                           |*
*| -----------------------                                           |*
*|  CGRT  CLGRT CLRT CRT  CU12  CUTFU  CU14  CU21  CUUTF  CU24       |*
*|  LOCR  LOCGR SSKE TRTE TRTRE TROO   TROT  TRTO  TRTT              |*
*|                                                                   |*
*| RRF2 / RRF-c                                                      |*
*| R1,R2,M3                                                        |*
*| +-------------------------------+                                 |*
*| |  Op Code  | M3+|----| R1 | R2 |                                 |*
*| +-------------------------------+                                 |*
*|  0           16   20   24   28 31                                 |*
*+-------------------------------------------------------------------+*
*
DXM19000 DS    0H
         CLC   OP@TYPE,=CL6'RRF-d' Variation-d RRF Instruction Format?
         BRE   DXM21000            Yes => Process This Instructn Format
         XC    DXMOPWRK(1),DXMOPWRK ..To Check RRF-c Instruction Format
         MVN   DXMOPWRK(1),DXMINSTR+2 Drop M3, Check the Unused Operand
         CLI   DXMOPWRK,X'00'      Are Unused Operand Area Bits Zero?
         BRE   DXM19200            Yes => Branch to Check Attributes
DXM19100 DS    0H
         LA    R15,8               An Instruction Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM19200 DS    0H
         LLGC  R6,DXMINSTR+2       Get M3 Operand Value in Instruction
         SRLG  R6,R6,4 Bits        Isolate Just the M3 Operand Value
         SLGR  R15,R15             Clear to Hold the R1 Register Value
         LLGC  R0,DXMINSTR+3       Get Register Operands in Instruction
         SRLG  R15,R0,4 Bits       Isolate Just the R1 Register Operand
         NILL  R0,(X'000F')        Drop the R1 so only R2 Value Remains
         LLGT  R1,=A(DXM$PAIR)     Address of the Register Pair Table
         LA    R4,L'DXM$PAIR       Len of Each Register Use Table Entry
         LLGF  R5,=A(DXM$PAIR+((DXM$RTNO*L'DXM$PAIR)-L'DXM$PAIR))
DXM19300 DS    0H
         LLGC  R2,0(,R1)           Get Bit Indicator From Reg Pair Tble
         TM    OP@REGEO,(0)        Indicated Target of the Execute
         EX    R2,*-4              Instructn Reg Attribute Match Table?
         BRO   DXM19400            Yes => Instruction has Register Pair
         BRXLG R1,R4,DXM19300      No  => Loop to Check Next Pair Type
         BRU   DXM19900            Instruction Uses No Register Pair(s)
DXM19400 DS    0H
         ICM   R2,B'0011',DXM$R1LN+DXM$R2LN*5(R1) Brnch Location Offset
         BRZ   DXM19900            No  => Then Uses No Register Pair(s)
         LLGT  R1,=A(DXMC0000)     Base Address to Calculate the Offset
         LA    R14,0(R2,R1)        Add Offset to Base for Branch Addr
         BR    R14                 Branch Based on Register Attributes
DXM19500 DS    0H
         TM    DXMINSTR+3,X'11'    Are Both R1+R2 Even Numbered Regs?
         BRZ   DXM19900            Yes => Instructn Has Valid Reg Pairs
DXM19600 DS    0H
         LA    R15,8               No  => Indicate Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM19700 DS    0H
         TM    DXMINSTR+3,X'10'    Is R1 Operand an Even Numbered Reg?
         BRZ   DXM19900            Yes => Instruction Has Valid R1 Reg
DXM19800 DS    0H
         LA    R15,8               No  => Indicate Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM19900 DS    0H
         LG    R4,DXMRTNI@         Address of Area to Return Instructn
         LGR   R1,R15              R1 Register Operand to Work Register
         BRAS  R14,DXDW1000        R1 Register Used to a Decimal Format
         MVI   0(R4),C','          Insert Comma Character After Operand
         LA    R4,1(,R4)           Increment to the Next Operand Field
DXM20000 DS    0H
         LGR   R1,R0               R2 Register Operand to Work Register
         BRAS  R14,DXDW1000        R2 Register Used to a Decimal Format
DXM20100 DS    0H
         CLC   OP@MCHCD,=XL2'B960' A Compare Grande Register and Trap?
         BRE   DXM20200            Yes => Process for Extended Mnemonic
         CLC   OP@MCHCD,=XL2'B961' Compare Logical Grande Reg and Trap?
         BRE   DXM20200            Yes => Process for Extended Mnemonic
         CLC   OP@MCHCD,=XL2'B972' Is This a Compare Register and Trap?
         BRE   DXM20200            Yes => Process For Extended Mnemonic
         CLC   OP@MCHCD,=XL2'B973' A Compare Logical Register and Trap?
         BRNE  DXM20700            No  => Check Other Instructions
DXM20200 DS    0H
         LG    R2,DXMRTNI@         Address of Area to Return Instructn
         AGHI  R2,-(L'OP@MNEUM+2)  Back up to Start of Base Mnemonic
         LLGT  R1,=A(DXMXTEND)     Address of Extended Mnemonics Table
         LA    R14,L'DXMXTEND      Length of Each Mnemonic Table Entry
         LLGF  R15,=A(DXMXTEND+((DXM$XTNO*L'DXMXTEND)-L'DXMXTEND))
DXM20300 DS    0H
         CLM   R6,B'0001',0(R1)    This Our Mask From Mnemonic Table?
         BRE   DXM20400            Yes => Copy in the Extended Mnemonic
         BRXLG R1,R14,DXM20300     No  => Loop to Check Next Tble Entry
         BRU   DXM20700            Not Found, Branch to Hard Code M3
DXM20400 DS    0H
         LA    R14,L'OP@MNEUM+1    Length of Base Instruction Mnemonic
DXM20500 DS    0H
         CLI   0(R2),C' '          Is This End of Base Mnemonic Name?
         BRE   DXM20600            Yes => Process Extended Mnemonic
         LA    R2,1(,R2)           Increment to the Next Character
         BRCTG R14,DXM20500        Loop to Find End of Base Mnemonic
         LA    R15,8               Not Found, An Instructn Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Instruction Error
DXM20600 DS    0H
         MVC   0(DXM$X2LN,R2),DXM$X1LN(R1) Add the Extended Mnemonic
         LG    R2,DXMXTND@         Addr Extended Mnemonic Return Area
         MVC   0(DXM$X3LN,R2),DXM$X1LN+DXM$X2LN(R1) Add the Description
         BRU   DXM20900            Drop M3 When Using Extended Mnemonic
DXM20700 DS    0H
M        USING OP@CODES,R3         Addressability to Machine Tble Entry
         CLC   M.OP@FACIL,=CL2'E3' Instruction Use the ETF-3 Facility?
         BRNE  DXM20800            No  => Branch If ETF-3 is Not Used
         USING PSA,R0              Establish Addressability to the PSA
         TM    FLCFACL3,FLCFET3E   An Extended-Translation Facility 3?
         BRO   DXM20800            Yes => M3 Operand Used in Instructn
         LTGR  R6,R6               Are All the M3 Operand Bits Zero?
         BRNZ  DXM20800            No  => Use But Ignored without ETF-3
         BRU   DXM20900            Yes => Assume Operand was Not Coded
         DROP  M,R0                Remove Listed Registers as Base Regs
DXM20800 DS    0H
         MVI   0(R4),C','          Insert Comma Character After Operand
         LA    R4,1(,R4)           Increment to the Next Operand Field
         CVD   R6,DXMOPWRK         Set M3 Operand in a Decimal Format
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit M3 Mask Value to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of M3 Mask Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy M3 Mask Value to Return Area
DXM20900 DS    0H
         BRU   DXMCEXIT            RRF-c Format Done, Branch to Exit
*
*+-------------------------------------------------------------------+*
*| Perform processing for type RRF-d variation instruction format.   |*
*| The RRF-d type is for a register-and-register operation with a    |*
*| longer extended two-byte contiguous op-code field, a 4-bit mask   |*
*| field, and a 4-bit unused operand field.                          |*
*|                                                                   |*
*| Instruction Group RRF-d                                           |*
*| -----------------------                                           |*
*|  CSDTR  CSXTR  LDETR  LXDTR                                       |*
*|                                                                   |*
*| RRF2 / RRF-d                                                      |*
*| R1,R2,M4                                                          |*
*| +------------------------------+                                  |*
*| |  Op Code  |---| M4 | R1 | R2 |                                  |*
*| +------------------------------+                                  |*
*|  0           16  20   24   28 31                                  |*
*+-------------------------------------------------------------------+*
*
DXM21000 DS    0H
         LLGC  R6,DXMINSTR+2       Get M4 Operand Value in Instruction
         RLLG  R6,R6,-4 Bits       Rotate Right to Isolate Unused Area
         SRA   R6,R6               Are Unused Operand Area Bits Zero?
         BRZ   DXM21200            Yes => Branch to Process Instruction
DXM21100 DS    0H
         LA    R15,8               An Instruction Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM21200 DS    0H
         RLLG  R6,R6,4 Bits        Rotate Left the M4 Value to Low Half
         SLGR  R15,R15             Clear to Hold the R1 Register Value
         LLGC  R0,DXMINSTR+3       Get Register Operands in Instruction
         SRLG  R15,R0,4 Bits       Isolate Just the R1 Register Operand
         NILL  R0,(X'000F')        Drop the R1 so only R2 Value Remains
         LLGT  R1,=A(DXM$PAIR)     Address of the Register Pair Table
         LA    R4,L'DXM$PAIR       Len of Each Register Use Table Entry
         LLGF  R5,=A(DXM$PAIR+((DXM$RTNO*L'DXM$PAIR)-L'DXM$PAIR))
DXM21300 DS    0H
         LLGC  R2,0(,R1)           Get Bit Indicator From Reg Pair Tble
         TM    OP@REGEO,(0)        Indicated Target of the Execute
         EX    R2,*-4              Instructn Reg Attribute Match Table?
         BRO   DXM21400            Yes => Instruction has Register Pair
         BRXLG R1,R4,DXM21300      No  => Loop to Check Next Pair Type
         BRU   DXM21900            Instruction Uses No Register Pair(s)
DXM21400 DS    0H
         ICM   R2,B'0011',DXM$R1LN+DXM$R2LN*6(R1) Brnch Location Offset
         BRZ   DXM21900            No  => Then Uses No Register Pair(s)
         LLGT  R1,=A(DXMC0000)     Base Address to Calculate the Offset
         LA    R14,0(R2,R1)        Add Offset to Base for Branch Addr
         BR    R14                 Branch Based on Register Attributes
DXM21500 DS    0H
         STC   R15,DXMWORKD        R1 Operand Register to a Work Area
         TRT   DXMWORKD(1),DXMFLTPT ..Valid FltPt R1 Register Coupling?
         BRZ   DXM21900            Yes => FltPt R1 is a Valid Register
DXM21600 DS    0H
         LA    R15,8               An Instruction Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM21700 DS    0H
         TMLL  R15,X'0001'         Is the R1 an Even Numbered Register?
         BRNZ  DXM21800            No  => GP Reg 1 Not a Valid E/O Pair
         STC   R0,DXMWORKD         R2 Operand Register to a Work Area
         TRT   DXMWORKD(1),DXMFLTPT ..Valid FltPt R2 Register Coupling?
         BRZ   DXM21900            Yes => R2 is a Valid FltPnt Register
DXM21800 DS    0H
         LA    R15,8               No  => Indicate Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM21900 DS    0H
         LG    R4,DXMRTNI@         Address of Area to Return Instructn
         LGR   R1,R15              R1 Register Operand to Work Register
         BRAS  R14,DXDW1000        R1 Register Used to a Decimal Format
         MVI   0(R4),C','          Insert Comma Character After Operand
         LA    R4,1(,R4)           Increment to the Next Operand Field
DXM22000 DS    0H
         LGR   R1,R0               R2 Register Operand to Work Register
         BRAS  R14,DXDW1000        R2 Register Used to a Decimal Format
         MVI   0(R4),C','          Insert Comma Character After Operand
         LA    R4,1(,R4)           Increment to the Next Operand Field
DXM22100 DS    0H
         CVD   R6,DXMOPWRK         Set M4 Operand in a Decimal Format
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit M4 Mask Value to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of M4 Mask Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy M4 Mask Value to Return Area
         BRU   DXMCEXIT            RRF-c Format Done, Branch to Exit
*
*+-------------------------------------------------------------------+*
*| Perform processing for type RRF-e variation instruction format.   |*
*| The RRF-e type is for a register-and-register operation with a    |*
*| longer extended two-byte contiguous op-code field, a 4-bit 3rd    |*
*| operand mask field, and in certain instances may also include a   |*
*| 4-bit 4th operand mask field.                                     |*
*|                                                                   |*
*| Instruction Group RRF-e                                           |*
*| -----------------------                                           |*
*|  CDFTR  CDLFBR  CDLFTR  CDLGBR  CDLGTR  CELFBR  CELGBR  CFDBR     |*
*|  CFDR   CFDTR   CFEBR   CFER    CFXBR   CFXR    CFXTR   CGDBR     |*
*|  CGDR   CGDTR   CGEBR   CGER    CGXBR   CGXR    CGXTR   CLFDBR    |*
*|  CLFDTR CLFEBR  CLFXBR  CLFXTR  CLGDBR  CLGDTR  CLGEBR  CLGXBR    |*
*|  CLGXTR CXFTR   CXLFBR  CXLFTR  CXLGBR  CXLGTR  FIDBR   FIDTR     |*
*|  FIEBR  FIXBR   FIXTR   LDXTR   LEDTR   TBDR    TBDR    TBEDR     |*
*|                                                                   |*
*| RRF2 / RRF-e                                                      |*
*| R1,M3,R2,M4                                                     |*
*| +-------------------------------+                                 |*
*| |  Op Code  | M3 | M4+| R1 | R2 |                                 |*
*| +-------------------------------+                                 |*
*|  0           16   20   24   28 31                                 |*
*+-------------------------------------------------------------------+*
*
DXM23000 DS    0H
M        USING OP@CODES,R3         Addressability to Machine Tble Entry
         TM    M.OP@MODES,OP@M4NOP Is M4 Operand Used in Instruction?
         BRZ   DXM23200            Yes => Branch If M4 Operand is Used
         XC    DXMOPWRK(1),DXMOPWRK ..To Check RRF-e Instruction Format
         MVN   DXMOPWRK(1),DXMINSTR+2 Drop M4, Check the Unused Operand
         CLI   DXMOPWRK,X'00'      Are Unused Operand Area Bits Zero?
         BRE   DXM23200            Yes => Branch to Check Attributes
DXM23100 DS    0H
         LA    R15,8               An Instruction Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM23200 DS    0H
         SLGR  R15,R15             Clear to Hold the R1 Register Value
         LLGC  R0,DXMINSTR+3       Get Register Operands in Instruction
         SRLG  R15,R0,4 Bits       Isolate R1 Operand in Work Register
         NILL  R0,(X'000F')        Drop R1 so only the R2 Operand Value
         LLGT  R1,=A(DXM$PAIR)     Address of the Register Pair Table
         LA    R4,L'DXM$PAIR       Len of Each Register Use Table Entry
         LLGF  R5,=A(DXM$PAIR+((DXM$RTNO*L'DXM$PAIR)-L'DXM$PAIR))
DXM23300 DS    0H
         LLGC  R2,0(,R1)           Get Bit Indicator From Reg Pair Tble
         TM    OP@REGEO,(0)        Indicated Target of the Execute
         EX    R2,*-4              Instructn Reg Attribute Match Table?
         BRO   DXM23400            Yes => Instruction has Register Pair
         BRXLG R1,R4,DXM23300      No  => Loop to Check Next Pair Type
         BRU   DXM24300            Instruction Uses No Register Pair(s)
DXM23400 DS    0H
         ICM   R2,B'0011',DXM$R1LN+DXM$R2LN*7(R1) Brnch Location Offset
         BRZ   DXM24300            No  => Then Uses No Register Pair(s)
         LLGT  R1,=A(DXMC0000)     Base Address to Calculate the Offset
         LA    R14,0(R2,R1)        Add Offset to Base for Branch Addr
         BR    R14                 Branch Based on Register Attributes
DXM23500 DS    0H
         STC   R15,DXMWORKD        R1 Operand Register to a Work Area
         TRT   DXMWORKD(1),DXMFLTPT ..Valid FltPt R1 Register Coupling?
         BRZ   DXM24300            Yes => FltPt R1 is a Valid Register
DXM23600 DS    0H
         LA    R15,8               No  => Indicate Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM23700 DS    0H
         STC   R0,DXMWORKD         R2 Operand Register to a Work Area
         TRT   DXMWORKD(1),DXMFLTPT ..Valid FltPt R2 Register Coupling?
         BRZ   DXM24300            Yes => FltPt R2 is a Valid Register
DXM23800 DS    0H
         LA    R15,8               No  => Indicate Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM23900 DS    0H
         STC   R15,DXMWORKD        R1 Operand Register to a Work Area
         STC   R0,DXMWORKD+1       R2 Operand Register to a Work Area
         TRT   DXMWORKD(1),DXMFLTPT ..Valid FltPt R1 Register Coupling?
         BRNZ  DXM24000            No  => FltPt R1 Not a Valid Register
         TRT   DXMWORKD+1(1),DXMFLTPT Valid FltPt R2 Register Coupling?
         BRZ   DXM24300            Yes => Both R1+R2 Valid Fltpt Pairs
DXM24000 DS    0H
         LA    R15,8               No  => Indicate Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM24100 DS    0H
         STC   R15,DXMWORKD        R1 Operand Register to a Work Area
         STC   R0,DXMWORKD+1       R2 Operand Register to a Work Area
         TRT   DXMWORKD(1),DXMFLTPT ..Valid FltPt R1 Register Coupling?
         BRNZ  DXM24200            No  => FltPt R1 Not a Valid Register
         TRT   DXMWORKD+1(1),DXMFLTPT Valid FltPt R2 Register Coupling?
         BRZ   DXM24300            Yes => All Regs Valid FltPnt Pairs
DXM24200 DS    0H
         LA    R15,8               No  => Indicate Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM24300 DS    0H
         LG    R4,DXMRTNI@         Address of Area to Return Instructn
         SLGR  R6,R6               Clear to Hold the M4 Operand Value
         LLGC  R5,DXMINSTR+2       Get M3 and M4 Operands in Instructn
         SRLG  R6,R5,4 Bits        Isolate M4 Operand in Work Register
         SRLG  R5,R5,4 Bits        Drop M4 and Just Leave M3 Operand
         CVD   R15,DXMOPWRK        R1 Register Used to a Decimal Format
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Register No. to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of Register Value
         MVI   0(R4),C'R'          To Designate Operand is for Register
         LA    R4,1(,R4)           Increment Past the Reg Designater
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy R1 Register No. to Return Area
         LA    R4,1(R2,R4)         Increment Past the Register Operand
         MVI   0(R4),C','          Insert Comma Character After Operand
         LA    R4,1(,R4)           Increment to the Next Operand Field
DXM24400 DS    0H
         CVD   R5,DXMOPWRK         Set M3 Operand in a Decimal Format
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit M3 Mask Value to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of M3 Mask Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy M3 Mask Value to Return Area
         LA    R4,1(R2,R4)         Increment Past the M3 Operand
         MVI   0(R4),C','          Insert Comma Character After Operand
         LA    R4,1(,R4)           Increment to the Next Operand Field
DXM24500 DS    0H
         CVD   R0,DXMOPWRK         R2 Register Used to a Decimal Format
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Register No. to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of Register Value
         MVI   0(R4),C'R'          To Designate Operand is for Register
         LA    R4,1(,R4)           Increment Past the Reg Designater
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy R2 Register No. to Return Area
DXM24600 DS    0H
         TM    M.OP@MODES,OP@M4NOP Is M4 Operand Used in Instruction?
         BRNZ  DXM24700            No  => Branch If M4 Operand Not Used
         LA    R4,1(R2,R4)         Increment Past the Register Operand
         MVI   0(R4),C','          Insert Comma Character After Operand
         LA    R4,1(,R4)           Increment to the Next Operand Field
         CVD   R6,DXMOPWRK         Set M4 Operand in a Decimal Format
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit M4 Mask Value to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of M4 Mask Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy M4 Mask Value to Return Area
DXM24700 DS    0H
         BRU   DXMCEXIT            RRF-e Format Done, Branch to Exit
         DROP  M                   Remove Listed Reg as Tble Entry Base
*
*+-------------------------------------------------------------------+*
*| Process the type RRS machine instruction format. The RRS type     |*
*| instruction is for a register-and-register operation and a storage|*
*| operation with a longer extended two-byte bifarcated op-code,     |*
*| a 4-bit mask field, and an unused 4-bit operand field.            |*
*|                                                                   |*
*| Instruction Group RRS                                             |*
*| ---------------------                                             |*
*|  CGRB  CLGRB  CLRB  CRB                                           |*
*|                                                                   |*
*| RRS                                                               |*
*| R1,R2,M3,D4(B4)                                                   |*
*| +--------------------------------------------+                    |*
*| |Op Code| R1 | R2 | B4 | D4  | M3 |--|Op Code|                    |*
*| +--------------------------------------------+                    |*
*|  0       8    12   16   20    32   36 40    47                    |*
*+-------------------------------------------------------------------+*
*
DXM25000 DS    0H
         XC    DXMOPWRK(1),DXMOPWRK ...To Check RRS Instruction Format
         MVN   DXMOPWRK(1),DXMINSTR+4 Drop M3, Check the Unused Operand
         CLI   DXMOPWRK,X'00'      Are Unused Operand Area Bits Zero?
         BRE   DXM25100            Yes => Branch to Process Instruction
         LA    R15,8               An Instruction Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM25100 DS    0H
         SLGR  R15,R15             Clear to Hold the R1 Register Value
         LLGC  R0,DXMINSTR+1       Get Register Operands in Instruction
         SRLG  R15,R0,4 Bits       Isolate R1 Operand in Work Register
         NILL  R0,(X'000F')        Drop R1 so only the R2 Operand Value
         LLGC  R6,DXMINSTR+4       Get M3 Operand Value in Instruction
         SRLG  R6,R6,4 Bits        Shift Out Un-used Operand so Only M3
         LG    R2,DXMRTNI@         Address of Area to Return Instructn
         AGHI  R2,-(L'OP@MNEUM+2)  Back up to Start of Base Mnemonic
         LLGT  R1,=A(DXMXTEND)     Address of Extended Mnemonics Table
         LA    R4,L'DXMXTEND       Length of Each Mnemonic Table Entry
         LLGF  R5,=A(DXMXTEND+((DXM$XTNO*L'DXMXTEND)-L'DXMXTEND))
DXM25200 DS    0H
         CLM   R6,B'0001',0(R1)    This Our Mask From Mnemonic Table?
         BRE   DXM25300            Yes => Copy in the Extended Mnemonic
         BRXLG R1,R4,DXM25200      No  => Loop to Check Next Tble Entry
         OI    DXMOPMNM,X'80'      Not Found, Indicate to Hard Code M3
         BRU   DXM25600            Branch to Process Instruction
DXM25300 DS    0H
         LA    R4,L'OP@MNEUM+1     Length of Base Instruction Mnemonic
DXM25400 DS    0H
         CLI   0(R2),C' '          Is This End of Base Mnemonic Name?
         BRE   DXM25500            Yes => Process Extended Mnemonic
         LA    R2,1(,R2)           Increment to the Next Character
         BRCTG R4,DXM25400         Loop to Find End of Base Mnemonic
         LA    R15,8               Not Found, An Instructn Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Instruction Error
DXM25500 DS    0H
         MVC   0(DXM$X2LN,R2),DXM$X1LN(R1) Add the Extended Mnemonic
         LG    R2,DXMXTND@         Addr Extended Mnemonic Return Area
         MVC   0(DXM$X3LN,R2),DXM$X1LN+DXM$X2LN(R1) Add the Description
DXM25600 DS    0H
         LG    R4,DXMRTNI@         Address of Area to Return Instructn
         LGR   R1,R15              R1 Register Operand to Work Register
         BRAS  R14,DXDW1000        R1 Register Used to a Decimal Format
         MVI   0(R4),C','          Insert Comma Character After Operand
         LA    R4,1(,R4)           Increment to the Next Operand Field
DXM25700 DS    0H
         LGR   R1,R0               R2 Register Operand to Work Register
         BRAS  R14,DXDW1000        R2 Register Used to a Decimal Format
         MVI   0(R4),C','          Insert Comma Character After Operand
         LA    R4,1(,R4)           Increment to the Next Operand Field
DXM25800 DS    0H
         TM    DXMOPMNM,X'80'      No Extended Mnemonic, Hard Code M3?
         BRZ   DXM25900            No  => Extended Mnemonic Was Used
         CVD   R6,DXMOPWRK         Set M3 Operand in a Decimal Format
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit M3 Mask Value to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of M3 Mask Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy M3 Mask Value to Return Area
         LA    R4,1(R2,R4)         Increment Past the M3 Operand Value
         MVI   0(R4),C','          Insert Comma Character After Operand
         LA    R4,1(,R4)           Increment to the Next Operand Field
DXM25900 DS    0H
         SLGR  R15,R15             Clear for Use as a B4 Work Register
         LLGH  R14,DXMINSTR+2      Get B4 and D4 Operands in Instructn
         SRLG  R15,R14,12 Bits     B4 Register Operand to Work Register
         NILL  R14,(X'0FFF')       Drop B4 so only the D4 Operand Value
         CVD   R14,DXMOPWRK        Displacement Value to Packed Decimal
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit D4 Displacement to Character
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of D4 Field Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy D4 Displacment to Return Area
         LA    R4,1(R2,R4)         Increment Past the Displacement
         MVI   0(R4),C'('          Insert Left Parand After Operand
         LA    R4,1(,R4)           Increment to B4 Base Register Field
         LGR   R1,R15              B4 Register Operand to Work Register
         BRAS  R14,DXDW1000        B4 Register Used to a Decimal Format
         MVI   0(R4),C')'          Insert Closing Parenthesis for Reg
         BRU   DXMCEXIT            Done for RRS Format, Branch to Exit
*
*+-------------------------------------------------------------------+*
*| Perform processing for the type RS-a variation instruction format.|*
*| The RS-a type is for a register-and-storage operation with a one  |*
*| byte op-code field, and in certain instances may also include an  |*
*| additional register.                                              |*
*|                                                                   |*
*| Instruction Group RS-a                                            |*
*| ----------------------                                            |*
*|  BXH  BXLE  CDS  CLCLE  CS    LAM   LCTL  LM   MVCLE  SIGP  SLA   |*
*|  SLDA SLDL  SLL  SRA    SRDA  SRDL  SRL   STAM STCTL  STM   TRACE |*
*|                                                                   |*
*| RS1 / RS-a                                                        |*
*| R1,R3,D2(B2) / R1,D2(B2)                                          |*
*| +----------------------------+                                    |*
*| |Op Code| R1 | R3+| B2 | D2  |                                    |*
*| +----------------------------+                                    |*
*|  0       8    12   16   20  31                                    |*
*+-------------------------------------------------------------------+*
*
DXM26000 DS    0H
         CLC   OP@TYPE,=CL6'RS-b'  Variation-b RS Instruction Format?
         BRE   DXM28000            Yes => Process This Instructn Format
M        USING OP@CODES,R3         Addressability to Machine Tble Entry
         TM    M.OP@MODES,OP@R3NOP Is R3 Operand Used in Instruction?
         BRZ   DXM26200            Yes => Branch If R3 Operand is Used
         XC    DXMOPWRK(1),DXMOPWRK ..To Check RS-a Instruction Format
         MVN   DXMOPWRK(1),DXMINSTR+1 Drop R3, Check the Unused Operand
         CLI   DXMOPWRK,X'00'      Are Unused Operand Area Bits Zero?
         BRE   DXM26200            Yes => Branch to Check Attributes
DXM26100 DS    0H
         LA    R15,8               An Instruction Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM26200 DS    0H
         CLC   OP@MCHCD,=XL2'8800' Part of an Instruction Shift Group?
         BRL   DXM26400            No  => B2/D2 Operands Address Data
         CLC   OP@MCHCD,=XL2'8F00' Part of an Instruction Shift Group?
         BRH   DXM26400            No  => B2/D2 Operands Address Data
         LLGH  R1,DXMINSTR+2       Get the B2 and D2 Operand Values
         SRLG  R1,R1,6 Bits        Only Rightmost 6-bits Used in Shifts
         LTGR  R1,R1               Bits 16-25 From Instruction Zero?
         BRZ   DXM26400            Yes => Branch to Process Instruction
DXM26300 DS    0H
         LA    R15,8               An Instruction Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM26400 DS    0H
         SLGR  R15,R15             Clear to Hold R1 Operand Reg Value
         LLGC  R0,DXMINSTR+1       Get Register Operands in Instruction
         SRLG  R15,R0,4 Bits       Isolate R1 Operand in Work Register
         NILL  R0,(X'000F')        Drop R1 so only the R3 Operand Value
         LLGT  R1,=A(DXM$PAIR)     Address of the Register Pair Table
         LA    R4,L'DXM$PAIR       Len of Each Register Use Table Entry
         LLGF  R5,=A(DXM$PAIR+((DXM$RTNO*L'DXM$PAIR)-L'DXM$PAIR))
DXM26500 DS    0H
         LLGC  R2,0(,R1)           Get Bit Indicator From Reg Pair Tble
         TM    OP@REGEO,(0)        Indicated Target of the Execute
         EX    R2,*-4              Instructn Reg Attribute Match Table?
         BRO   DXM26600            Yes => Instruction has Register Pair
         BRXLG R1,R4,DXM26500      No  => Loop to Check Next Pair Type
         BRU   DXM26900            Instruction Uses No Register Pair(s)
DXM26600 DS    0H
         ICM   R2,B'0011',DXM$R1LN+DXM$R2LN*8(R1) Brnch Location Offset
         BRZ   DXM26900            No  => Then Uses No Register Pair(s)
         LLGT  R1,=A(DXMC0000)     Base Address to Calculate the Offset
         LA    R14,0(R2,R1)        Add Offset to Base for Branch Addr
         BR    R14                 Branch Based on Register Attributes
DXM26700 DS    0H
         TM    DXMINSTR+1,X'11'    Are Both R1+R2 Even Numbered Regs?
         BRZ   DXM26900            Yes => Instructn Has Valid Reg Pairs
         LA    R15,8               No  => Indicate Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM26800 DS    0H                  20
         TM    DXMINSTR+1,X'10'    Is R1 Operand an Even Numbered Reg?
         BRZ   DXM26900            Yes => Instruction Has Valid R1 Reg
         LA    R15,8               No  => Indicate Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM26900 DS    0H
         LG    R4,DXMRTNI@         Address of Area to Return Instructn
         SLGR  R6,R6               Clear to Hold the D2 Operand Value
         LLGH  R5,DXMINSTR+2       Get B2 and D2 Operands in Instructn
         SRLG  R6,R5,12 Bits       Isolate B2 Operand in Work Register
         NILL  R5,(X'0FFF')        Drop B2 so only the D2 Operand Value
         LGR   R1,R15              R1 Register Operand to Work Register
         BRAS  R14,DXDW1000        R1 Register Used to a Decimal Format
         MVI   0(R4),C','          Insert Comma Character After Operand
         LA    R4,1(,R4)           Increment to the Next Operand Field
DXM27000 DS    0H
         TM    M.OP@MODES,OP@R3NOP Is R3 Operand Used in Instruction?
         BRNZ  DXM27100            No  => Branch If R3 Operand Not Used
         DROP  M                   Remove Listed Entry as a Base Entry
         CVD   R0,DXMOPWRK         R3 Register Used to a Decimal Format
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Register No. to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of Register Value
         MVI   0(R4),C'R'          To Designate Operand is for Register
         LA    R4,1(,R4)           Increment Past the Reg Designater
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy R3 Register No. to Return Area
         LA    R4,1(R2,R4)         Increment Past the Register Operand
DXM27100 DS    0H
         CLC   OP@MCHCD,=XL2'A800' Is This for a MVCLE Instruction?
         BRE   DXM27300            Yes => B2/D2 Are Used as a Pad Byte
         CLC   OP@MCHCD,=XL2'A900' Is This for a CLCLE Instruction?
         BRE   DXM27300            Yes => B2/D2 Are Used as a Pad Byte
         CLC   OP@MCHCD,=XL2'8800' Part of an Instruction Shift Group?
         BRL   DXM27400            No  => B2/D2 Operands Address Data
         CLC   OP@MCHCD,=XL2'8F00' Part of an Instruction Shift Group?
         BRH   DXM27400            No  => B2/D2 Operands Address Data
DXM27200 DS    0H
         NILL  R5,(X'003F')        Only Rightmost 6-Bits Used in B2/D2
         CVD   R5,DXMOPWRK         No. of Bit Positions to be Shifted
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Shift Value to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of the Shift Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy Shift Value to Return Area
         BRU   DXMCEXIT            Done with RS-a, Branch to Exit
DXM27300 DS    0H
         NILL  R5,(X'00FF')        Only Rightmost 8-Bits Used in B2/D2
         MVC   0(3,R4),=CL3',X'''  To Show the Pad Byte in a Hex Format
         LA    R4,3(,R4)           Increment to the Operand Field
         STG   R5,DXMWORKD         Pad Byte Character to a Work Area
         UNPK  DXMOPWRK+6(3),DXMWORKD+7(2) Convert From Hex to Zoned
         TR    DXMOPWRK+6(2),HEXCONV-C'0' ...Translate Hex to Character
         MVC   0(2,R4),DXMOPWRK+6  Hex Pad Byte in Character Format
         MVI   2(R4),C''''         Set with Closing Apostrophe
         BRU   DXMCEXIT            Done with RS-a, Branch to Exit
DXM27400 DS    0H
         MVI   0(R4),C','          Insert Comma Character After Operand
         LA    R4,1(,R4)           Increment to the Next Operand Field
         CVD   R5,DXMOPWRK         Displacement Value to Packed Decimal
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit D2 Displacement to Character
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of D2 Field Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy D2 Displacment to Return Area
         LA    R4,1(R2,R4)         Increment Past the Displacement
         MVI   0(R4),C'('          Insert Left Parand After Operand
         LA    R4,1(,R4)           Increment to B2 Base Register Field
DXM27500 DS    0H
         LGR   R1,R6               B2 Register Operand to Work Register
         BRAS  R14,DXDW1000        B2 Register Used to a Decimal Format
         MVI   0(R4),C')'          Insert Closing Parenthesis for Reg
         BRU   DXMCEXIT            Done with RS-a, Branch to Exit
*
*+-------------------------------------------------------------------+*
*| Perform processing for the type RS-b variation instruction format.|*
*| The RS-b type is for a register-and-storage operation with a one  |*
*| byte op-code field and a 4-bit mask field.                        |*
*|                                                                   |*
*| Instruction Group RS-b                                            |*
*| ----------------------                                            |*
*|  CLM  ICM  STCM                                                   |*
*|                                                                   |*
*| RS2 / RS-b                                                        |*
*| R1,M3,D2(B2)                                                      |*
*| +----------------------------+                                    |*
*| |Op Code| R1 | M3 | B2 | D2  |                                    |*
*| +----------------------------+                                    |*
*|  0       8    12   16   20  31                                    |*
*+-------------------------------------------------------------------+*
*
DXM28000 DS    0H
         LG    R4,DXMRTNI@         Address of Area to Return Instructn
         SLGR  R15,R15             Clear to Hold the R1 Register Value
         LLGC  R0,DXMINSTR+1       Get Register Operands in Instruction
         SRLG  R15,R0,4 Bits       Isolate R1 Operand in Work Register
         NILL  R0,(X'000F')        Drop R1 so only the M3 Operand Value
         CVD   R15,DXMOPWRK        R1 Register Used to a Decimal Format
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Register No. to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of Register Value
         MVI   0(R4),C'R'          To Designate Operand is for Register
         LA    R4,1(,R4)           Increment Past the Reg Designater
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy R1 Register No. to Return Area
         LA    R4,1(R2,R4)         Increment Past the Register Operand
DXM28100 DS    0H
         LG    R1,DXMPREV@         Get Addr of Area for Previous Op-Cde
         SLGR  R15,R15             Clear to Hold Previous Op-Code Type
         ICM   R15,B'1111',0(R1)   Is a Previous Op Code Indicated?
         BRZ   DXM28200            No  => Not Target of EX Instruction
         LTGR  R0,R0               Any Mask Value Coded for M3 Operand?
         BRNZ  DXM28200            Yes => Then Show M3 in Binary Bits
         MVC   0(3,R4),=CL3',0,'   Specify 0 for M3 Instruction Element
         LA    R4,3(,R4)           Increment Past Where EX will 'OR' M3
         BRU   DXM28500            Process the D2(B2) Operand Field
DXM28200 DS    0H
         LLGT  R5,=A(DXMBINRY)     Adr of Binary Mask Byte-Position Tbl
         LA    R14,L'DXMBINRY      Leng of Each Binary Mask Table Entry
         LLGF  R15,=A(DXMBINRY+((DXM$BMNO*L'DXMBINRY)-L'DXMBINRY))
DXM28300 DS    0H
         CLM   R0,B'0001',DXM$BINX-1(R5) Mask From Byte Position Table?
         BRE   DXM28400            Yes => Then Show the Mask in Binary
         BRXLG R5,R14,DXM28300     No  => Loop to Check Next Tble Entry
         LA    R15,8               Instruction Check Validation Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Validation Error
DXM28400 DS    0H
         MVC   0(3,R4),=CL3',B'''  To Show Byte Position Mask in Binary
         LA    R4,3(,R4)           Increment to the M3 Operand Field
         MVC   0(DXM$BINM,R4),DXM$BINX(R5) ..Add the Byte Position Mask
         LA    R4,DXM$BINM(,R4)    Increment to End of M3 Mask Value
         MVI   0(R4),C''''         Enclose Mask with Ending Apostrophe
         MVI   1(R4),C','          Add Comma Delimiter for Next Operand
         LA    R4,2(,R4)           Increment to D2(B2) Operand Field
DXM28500 DS    0H
         SLGR  R6,R6               Clear to Hold the D2 Operand Value
         LLGH  R5,DXMINSTR+2       Get B2 and D2 Operands in Instructn
         SRLG  R6,R5,12 Bits       Isolate B2 Operand in Work Register
         NILL  R5,(X'0FFF')        Drop B2 so only the D2 Operand Value
         CVD   R5,DXMOPWRK         Displacement Value to Packed Decimal
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit D2 Displacement to Character
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of D2 Field Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy D2 Displacment to Return Area
         LA    R4,1(R2,R4)         Increment Past the Displacement
         MVI   0(R4),C'('          Insert Left Parand After Operand
         LA    R4,1(,R4)           Increment to B2 Base Register Field
DXM28600 DS    0H
         LGR   R1,R6               B2 Register Operand to Work Register
         BRAS  R14,DXDW1000        B2 Register Used to a Decimal Format
         MVI   0(R4),C')'          Insert Closing Parenthesis for Reg
         BRU   DXMCEXIT            Done with RS-b, Branch to Exit
*
*+-------------------------------------------------------------------+*
*| Process the type RSL machine instruction format. The RSL type     |*
*| instruction is for a storage operation with a longer extended     |*
*| two-byte bifarcated op-code, a 4-bit length specification field,  |*
*| and two unused operand fields.                                    |*
*|                                                                   |*
*| Instruction Group RSL                                             |*
*| ---------------------                                             |*
*|  TP                                                               |*
*|                                                                   |*
*| RSL                                                               |*
*| D1(L1,B1)                                                         |*
*| +--------------------------------------+                          |*
*| |Op Code| L1 |---| B1 | D1 |---|Op Code|                          |*
*| +--------------------------------------+                          |*
*|  0       8    12  16   20   32  40    47                          |*
*+-------------------------------------------------------------------+*
*
DXM29000 DS    0H
         LG    R4,DXMRTNI@         Address of Area to Return Instructn
         XC    DXMOPWRK(2),DXMOPWRK ...To Check RSL Instruction Format
         MVN   DXMOPWRK(1),DXMINSTR+1  Drop L1, Extract Unused Operand
         CLI   DXMOPWRK,X'00'      Are the Unused Operand Bits Zero?
         BRNE  DXM29100            No  => Instruction Fails Validity
         LLGC  R1,DXMINSTR+4       For This Format Unused Area = 8 Bits
         LTGR  R1,R1               Are All Unused Operand Bits Zero?
         BRZ   DXM29200            Yes => Branch to Process Instruction
DXM29100 DS    0H
         LA    R15,8               Indicate a Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM29200 DS    0H
         LLGC  R5,DXMINSTR+1       Get L1 Length Operand in Instruction
         SRLG  R5,R5,4 Bits        Isolate L1 Operand Bits in Register
         AGHI  R5,(1)              Real Leng is +1 to Machine Code Leng
         SLGR  R15,R15             Clear for Use as a B1 Work Register
         LLGH  R14,DXMINSTR+2      Get B1 and D1 Operands in Instructn
         SRLG  R15,R14,12 Bits     B1 Register Operand to Work Register
         NILL  R14,(X'0FFF')       Drop B1 so only the D1 Operand Value
DXM29300 DS    0H
         CVD   R14,DXMOPWRK        Displacement Value to Packed Decimal
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit D1 Displacement to Character
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of D1 Field Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy D1 Displacment to Return Area
         LA    R4,1(R2,R4)         Increment Past the Displacement
         MVI   0(R4),C'('          Insert Left Parand After Operand
         LA    R4,1(,R4)           Increment to L1 Operand Length Field
DXM29400 DS    0H
         CVD   R5,DXMOPWRK         L1 Operand Value to Packed Decimal
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit L1 Displacement to Character
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of L1 Field Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy L1 Operand Value to Return Area
         LA    R4,1(R2,R4)         Increment Past the L1 Operand Value
         MVI   0(R4),C','          Insert Comma Delimiter After Operand
         LA    R4,1(,R4)           Increment to B1 Base Register Field
DXM29500 DS    0H
         LGR   R1,R15              B1 Register Operand to Work Register
         BRAS  R14,DXDW1000        B1 Register Used to a Decimal Format
         MVI   0(R4),C')'          Closing Parenthesis for Operands
         BRU   DXMCEXIT            Done with RSL Format, Branch to Exit
*
*+-------------------------------------------------------------------+*
*|Perform processing for the type RSY-a variation instruction format.|*
*|It is a register-and-storage operation with a longer extended      |*
*|two-byte bifarcated op-code, an additional register, and a 20-bit  |*
*|long displacement field.                                           |*
*|                                                                   |*
*| Instruction Group RSY-a                                           |*
*| -----------------------                                           |*
*|  BXHG  BXLEG  CDSG  CDSY  CLCLU CSG  CSY   ECAG  LAA   LAAG  LAAL |*
*|  LAALG LAMY   LAN   LANG  LAO   LAOG LAX   LAXG  LCTLG LMG   LMH  |*
*|  LMY   MVCLU  RLL   RLLG  SLAG  SLAK SLLG  SLLK  SRAG  SRAK  SRLG |*
*|  SRLK  STAMY  STCTG STMG  STMH  STMY TRACG                        |*
*|                                                                   |*
*| RSY1 / RSY-a                                                      |*
*| R1,R3,D2(B2)                                                      |*
*| +------------------------------------------+                      |*
*| |Op Code| R1 | R3 | B2 | DL2 | DH2 |Op Code|                      |*
*| +------------------------------------------+                      |*
*|  0       8    12   16   20    32    40    47                      |*
*+-------------------------------------------------------------------+*
*
DXM30000 DS    0H
         CLC   OP@TYPE,=CL6'RSY-b' Variation-b RSY Instruction Format?
         BRE   DXM32000            Yes => Process This Instructn Format
         SLGR  R15,R15             Clear to Hold the R1 Register Value
         LLGC  R0,DXMINSTR+1       Get Register Operands in Instruction
         SRLG  R15,R0,4 Bits       Isolate R1 Operand in Work Register
         NILL  R0,(X'000F')        Drop R1 so only the R3 Operand Value
         LLGT  R1,=A(DXM$PAIR)     Address of the Register Pair Table
         LA    R4,L'DXM$PAIR       Len of Each Register Use Table Entry
         LLGF  R5,=A(DXM$PAIR+((DXM$RTNO*L'DXM$PAIR)-L'DXM$PAIR))
DXM30100 DS    0H
         LLGC  R2,0(,R1)           Get Bit Indicator From Reg Pair Tble
         TM    OP@REGEO,(0)        Indicated Target of the Execute
         EX    R2,*-4              Instructn Reg Attribute Match Table?
         BRO   DXM30200            Yes => Instruction has Register Pair
         BRXLG R1,R4,DXM30100      No  => Loop to Check Next Pair Type
         BRU   DXM30400            Instruction Uses No Register Pair(s)
DXM30200 DS    0H
         ICM   R2,B'0011',DXM$R1LN+DXM$R2LN*9(R1) Brnch Location Offset
         BRZ   DXM30400            No  => Then Uses No Register Pair(s)
         LLGT  R1,=A(DXMC0000)     Base Address to Calculate the Offset
         LA    R14,0(R2,R1)        Add Offset to Base for Branch Addr
         BR    R14                 Branch Based on Register Attributes
DXM30300 DS    0H
         TM    DXMINSTR+1,X'11'    Are Both R1+R2 Even Numbered Regs?
         BRZ   DXM30400            Yes => Instructn Has Valid Reg Pairs
         LA    R15,8               No  => Indicate Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM30400 DS    0H
         LG    R4,DXMRTNI@         Address of Area to Return Instructn
         LGR   R1,R15              1st Operand R1 Value to Wrk Register
         BRAS  R14,DXDW1000        R1 Register Used to a Decimal Format
         MVI   0(R4),C','          Insert Comma Character After Operand
         LA    R4,1(,R4)           Increment to the Next Operand Field
DXM30500 DS    0H
         LGR   R1,R0               3rd Operand R3 Value to Wrk Register
         BRAS  R14,DXDW1000        R3 Register Used to a Decimal Format
         MVI   0(R4),C','          Insert Comma Character After Operand
         LA    R4,1(,R4)           Increment to Process the 2nd Operand
DXM30600 DS    0H
M        USING OP@CODES,R3         Addressability to Machine Tble Entry
         TM    M.OP@MODES,OP@2NDBP 2nd Operand Used for Bit Positions?
         BRZ   DXM30700            No  => 2nd Operand Used for Address
         DROP  M                   Remove Listed Reg as Base Register
         LLGH  R5,DXMINSTR+2       Get B2+DL2, Hardware Ignores B2+DH2
         NILL  R5,(X'003F')        Only Rightmost 6-Bits Used in DL2
         CVD   R5,DXMOPWRK         No. of Bit Positions to be Shifted
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Shift Value to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1  Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of the Shift Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy Shift Value to Return Area
         BRU   DXMCEXIT            Done with RSY-a, Branch to Exit
DXM30700 DS    0H
         ICMH  R5,B'1100',DXMINSTR+2  Get B2 Field and DL2 (low) Field
         SRLG  R5,R5,4 Bits        Open a Byte Where DH2 to Overlay B2
         ICMH  R5,B'1000',DXMINSTR+4 DH2 (high) Field is to Left of DL2
         SRAG  R6,R5,32+12 Bits    Set Signed 20-bit Displacement Value
         CVD   R6,DXMOPWRK         20-bit Displacement to Decimal Form
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Displacement to Character Form
         BRNM  DXM30800            Branch if Displacement is Positive
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Leng of Displacement Value
         MVI   0(R4),C'-'          Specify the Displacement as Negative
         LA    R4,1(,R4)           Increment Past the Sign Indicator
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              20-bit Displacement to Return Area
         LA    R4,1(R2,R4)         Increment Past Displacement Value
         BRU   DXM30900            Branch to Process the Instruction
DXM30800 DS    0H
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Leng of Displacement Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              20-bit Displacement to Return Area
         LA    R4,1(R2,R4)         Increment Past Displacement Value
DXM30900 DS    0H
         LLGC  R0,DXMINSTR+2       Get Register Operand in Instruction
         SRLG  R0,R0,4 Bits        Isolate B2 Operand in Work Register
         MVI   0(R4),C'('          Insert Left Parand After Operand
         LA    R4,1(,R4)           Increment to B2 Base Register Field
         LGR   R1,R0               B2 Register Operand to Work Register
         BRAS  R14,DXDW1000        B2 Register Used to a Decimal Format
         MVI   0(R4),C')'          Insert Closing Parenthesis for Reg
         BRU   DXMCEXIT            Done with RSY-a Form, Branch to Exit
*
*+-------------------------------------------------------------------+*
*|Perform processing for the type RSY-b variation instruction format.|*
*|It is a register-and-storage operation with a longer extended      |*
*|two-byte bifarcated op-code, a larger 20-bit long displacement     |*
*|field, and a 4-bit mask field. The single RSY-b variation has two  |*
*|separate assembler language syntax variations.                     |*
*|                                                                   |*
*| Instruction Group RSY-b                                           |*
*| -----------------------                                           |*
*|  CLMH  CLMY  ICMH  ICMY  LOC  LOCG  STCMH  STCMY  STOC  STOCG     |*
*|                                                                   |*
*| RSY2 / RSY-b                                                      |*
*| R1,M3,D2(B2) / R1,D2(B2),M3                                       |*
*| +------------------------------------------+                      |*
*| |Op Code| R1 | M3 | B2 | DL2 | DH2 |Op Code|                      |*
*| +------------------------------------------+                      |*
*|  0       8    12   16   20    32    40    47                      |*
*+-------------------------------------------------------------------+*
DXM32000 DS    0H
         LG    R4,DXMRTNI@         Address of Area to Return Instructn
         SLGR  R15,R15             Clear to Hold the R1 Register Value
         LLGC  R0,DXMINSTR+1       Get Register Operands in Instruction
         SRLG  R15,R0,4 Bits       Isolate R1 Operand in Work Register
         NILL  R0,(X'000F')        Drop R1 so only the M3 Operand Value
         LGR   R1,R15              R1 Register Operand to Work Register
         BRAS  R14,DXDW1000        R1 Register Used to a Decimal Format
         MVI   0(R4),C','          Insert Comma Character After Operand
         LA    R4,1(,R4)           Increment to the Next Operand Field
DXM32100 DS    0H
M        USING OP@CODES,R3         Addressability to Machine Tble Entry
         TM    M.OP@MODES,OP@2NDBP 3rd Operand Used for Byte Positions?
         BRZ   DXM32600            No  => Branch If Operand a Cond Code
         DROP  M                   Remove Listed Reg as Base Register
DXM32200 DS    0H
         LG    R2,DXMPREV@         Get Addr of Area for Previous Op-Cde
         SLGR  R5,R5               Clear to Hold Previous Op-Code Type
         ICM   R5,B'1111',0(R2)    Is a Previous Op Code Indicated?
         BRZ   DXM32300            No  => Not Target of EX Instruction
         LTGR  R0,R0               Any Mask Value Coded for M3 Operand?
         BRNZ  DXM32300            Yes => Then Show M3 in Binary Bits
         MVC   0(2,R4),=CL2'0,'    Specify 0 for M3 Instruction Element
         LA    R4,2(,R4)           Increment Past Where EX will 'OR' M3
         BRU   DXM32600            Process DL2/DH2(B2) Operand Fields
DXM32300 DS    0H
         LLGT  R5,=A(DXMBINRY)     Adr of Binary Mask Byte Position Tbl
         LA    R14,L'DXMBINRY      Leng of Each Binary Mask Table Entry
         LLGF  R15,=A(DXMBINRY+((DXM$BMNO*L'DXMBINRY)-L'DXMBINRY))
DXM32400 DS    0H
         CLM   R0,B'0001',DXM$BINX-1(R5) Mask From Byte Position Table?
         BRE   DXM32500            Yes => Copy in Byte Position Mask
         BRXLG R5,R14,DXM32400     No  => Loop to Check Next Tble Entry
         LA    R15,8               Instruction Check Validation Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Validation Error
DXM32500 DS    0H
         MVC   0(2,R4),=CL2'B'''   To Show Byte Position Mask in Binary
         LA    R4,2(,R4)           Increment to the M3 Operand Field
         MVC   0(DXM$BINM,R4),DXM$BINX(R5) ..Add the Byte Position Mask
         LA    R4,DXM$BINM(,R4)    Increment to End of M3 Mask Value
         MVI   0(R4),C''''         Enclose Mask with Ending Apostrophe
         MVI   1(R4),C','          Add Comma Delimiter for Next Operand
         LA    R4,2(,R4)           Increment for DL2/DH2(B2) Operands
DXM32600 DS    0H
         ICMH  R5,B'1100',DXMINSTR+2  Get B2 Field and DL2 (low) Field
         SRLG  R5,R5,4 Bits        Open a Byte Where DH2 to Overlay B2
         ICMH  R5,B'1000',DXMINSTR+4 DH2 (high) Field is to Left of DL2
         SRAG  R6,R5,32+12 Bits    Set Signed 20-bit Displacement Value
         CVD   R6,DXMOPWRK         20-bit Displacement to Decimal Form
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Displacement to Character Form
         BRNM  DXM32700            Branch if Displacement is Positive
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Leng of Displacement Value
         MVI   0(R4),C'-'          Specify the Displacement as Negative
         LA    R4,1(,R4)           Increment Past the Sign Indicator
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              20-bit Displacement to Return Area
         LA    R4,1(R2,R4)         Increment Past Displacement Value
         BRU   DXM32800            Branch to Process the Instruction
DXM32700 DS    0H
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Leng of Displacement Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              20-bit Displacement to Return Area
         LA    R4,1(R2,R4)         Increment Past Displacement Value
DXM32800 DS    0H
         LLGC  R15,DXMINSTR+2      Get Register Operand in Instruction
         SRLG  R15,R15,4 Bits      Isolate B2 Operand in Work Register
         MVI   0(R4),C'('          Insert Left Parand After Operand
         LA    R4,1(,R4)           Increment to B2 Base Register Field
         LGR   R1,R15              B2 Register Operand to Work Register
         BRAS  R14,DXDW1000        B2 Register Used to a Decimal Format
         MVI   0(R4),C')'          Insert Closing Parenthesis for Reg
         LA    R4,1(,R4)           Increment to the Next Operand Field
DXM32900 DS    0H
M        USING OP@CODES,R3         Addressability to Machine Tble Entry
         TM    M.OP@MODES,OP@2NDBP 3rd Operand Used for Cond Code Mask?
         BRZ   DXM33000            Yes => Branch If Operand a Cond Code
         DROP  M                   Remove Listed Reg as Base Register
         BRU   DXM33100            Done With This Variation in Syntax
DXM33000 DS    0H
         MVI   0(R4),C','          Insert Comma Delimiter After Operand
         LA    R4,1(,R4)           For This Syntax M3 Operand at End
         CVD   R0,DXMOPWRK         M3 Operand Value to a Decimal Format
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit M3 Operand to Character Format
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of M3 Operand Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy M3 Operand Value to Return Area
DXM33100 DS    0H
         BRU   DXMCEXIT            Done with RSL Format, Branch to Exit
*
*+-------------------------------------------------------------------+*
*| Process the type RX-a and RX-b variation machine instruction      |*
*| formats. These instruction formats are for a register-and-indexed |*
*| storage operation with a one-byte op-code. The RX-b uses a 4-bit  |*
*| mask field in place of the register field used in the RX-a format.|*
*|                                                                   |*
*| Instruction Group RX-a                                            |*
*| ----------------------                                            |*
*|  A   AD  AE  AH  AL  AU  AW  BAL  BAS  BCT  C  CD  CE  CH  CL     |*
*|  CVB CVD D   DD  DE  EX  IC  L    LA   LAE  LD LE  LH  LRA M      |*
*|  MD  MDE ME  MH  MS  MXD N   O    S    SD   SE SH  SL  ST  STC    |*
*|  STD STE STH SU  SW  X                                            |*
*|                                                                   |*
*| RX / RX-a                                                         |*
*| R1,D2(X2,B2)                                                      |*
*| +-----------------------------+                                   |*
*| |Op Code| R1 | X2 | B2 |  D2  |                                   |*
*| +-----------------------------+                                   |*
*|  0       8    12   16   20   32                                   |*
*|                                                                   |*
*| Instruction Group RX-b                                            |*
*| ----------------------                                            |*
*|  BC                                                               |*
*|                                                                   |*
*| RX / RX-b                                                         |*
*| M1,D2(X2,B2)                                                      |*
*| +-----------------------------+                                   |*
*| |Op Code| M1 | X2 | B2 |  D2  |                                   |*
*| +-----------------------------+                                   |*
*|  0       8    12   16   20   32                                   |*
*+-------------------------------------------------------------------+*
*
DXM34000 DS    0H
         SLGR  R15,R15             Clear to Hold the R1 Register Value
         LLGC  R0,DXMINSTR+1       Get Register Operands in Instruction
         SRLG  R15,R0,4 Bits       Isolate R1 Operand in Work Register
         NILL  R0,(X'000F')        Drop R1 so only the X2 Operand Value
         LLGT  R1,=A(DXM$PAIR)     Address of the Register Pair Table
         LA    R4,L'DXM$PAIR       Len of Each Register Use Table Entry
         LLGF  R5,=A(DXM$PAIR+((DXM$RTNO*L'DXM$PAIR)-L'DXM$PAIR))
DXM34100 DS    0H
         LLGC  R2,0(,R1)           Get Bit Indicator From Reg Pair Tble
         TM    OP@REGEO,(0)        Indicated Target of the Execute
         EX    R2,*-4              Instructn Reg Attribute Match Table?
         BRO   DXM34200            Yes => Instruction has Register Pair
         BRXLG R1,R4,DXM34100      No  => Loop to Check Next Pair Type
         BRU   DXM34500            Instruction Uses No Register Pair(s)
DXM34200 DS    0H
         ICM   R2,B'0011',DXM$R1LN+DXM$R2LN*10(R1) Branch Location
         BRZ   DXM34500            No  => Then Uses No Register Pair(s)
         LLGT  R1,=A(DXMC0000)     Base Address to Calculate the Offset
         LA    R14,0(R2,R1)        Add Offset to Base for Branch Addr
         BR    R14                 Branch Based on Register Attributes
DXM34300 DS    0H
         STC   R15,DXMWORKD        R1 Operand Register to a Work Area
         TRT   DXMWORKD(1),DXMFLTPT ..Valid FltPt R1 Register Coupling?
         BRZ   DXM34500            Yes => Branch to Process Instruction
         LA    R15,8               No  => Indicate Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM34400 DS    0H
         TM    DXMINSTR+1,X'10'    Is R1 Operand an Even Numbered Reg?
         BRZ   DXM34500            Yes => Instruction Has Valid R1 Reg
         LA    R15,8               No  => Indicate Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM34500 DS    0H
         LG    R4,DXMRTNI@         Address of Area to Return Instructn
         CVD   R15,DXMOPWRK        R1 Register Used to a Decimal Format
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Register No. to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of Register Value
         CLC   OP@TYPE,=CL6'RX-b'  Variation-b RX Instruction Format?
         BRE   DXM34600            Yes => Operand Used as Cond Cde Mask
         MVI   0(R4),C'R'          To Designate Operand is for Register
         LA    R4,1(,R4)           Increment Past the Reg Designater
DXM34600 DS    0H
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy R1 or M1 Operand to Return Area
         LA    R4,1(R2,R4)         Increment Past the Operand Value
         MVI   0(R4),C','          Insert Comma Character After Operand
         LA    R4,1(,R4)           Increment for DL2/DH2(B2) Operands
DXM34700 DS    0H
         SLGR  R6,R6               Clear to Hold the D2 Operand Value
         LLGH  R5,DXMINSTR+2       Get B2 and D2 Operands in Instructn
         SRLG  R6,R5,12 Bits       Isolate B2 Operand in Work Register
         NILL  R5,(X'0FFF')        Drop B2 so only the D2 Operand Value
         CVD   R5,DXMOPWRK         12-bit Displacement to Decimal Form
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Displacement to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Leng of Displacement Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              12-bit Displacement to Return Area
         LA    R4,1(R2,R4)         Increment Past Displacement Value
         MVI   0(R4),C'('          Insert Left Parand After Operand
         LA    R4,1(,R4)           Increment to X2 Index Register Field
DXM34800 DS    0H
         LGR   R1,R0               X2 Register Operand to Work Register
         BRAS  R14,DXDW1000        X2 Register Used to a Decimal Format
         MVI   0(R4),C','          Insert Comma Delimiter After Operand
         LA    R4,1(,R4)           Increment to the B2 Register Field
DXM34900 DS    0H
         LGR   R1,R6               B2 Register Operand to Work Register
         BRAS  R14,DXDW1000        B2 Register Used to a Decimal Format
         MVI   0(R4),C')'          Insert Closing Parenthesis for Reg
         BRU   DXMCEXIT            Done with RX Format, Branch to Exit
*
*+-------------------------------------------------------------------+*
*| Process the type RXE machine instruction format. The RXE type     |*
*| instruction is for a register-and-index storage operation with a  |*
*| longer extended two-byte bifarcated op-code, and a 4-bit unused   |*
*| operand field.                                                    |*
*|                                                                   |*
*| Instruction Group RXE                                             |*
*| ---------------------                                             |*
*|  ADB  AEB  CDB  CEB  DDB   DEB   KDB   KEB   LDE   LDEB  LXD  LXDB|*
*|  LXE  LXEB MDB  MDEB MEE   MEEB  MXDB  SDB   SEB   SQD   SQDB SQE |*
*|  SQEB TCDB TCEB TCXB TDCDT TDCET TDCXT TDGDT TDGET TDGXT          |*
*|                                                                   |*
*| RXE                                                               |*
*| R1,D2(X2,B2)                                                      |*
*| +----------------------------------------+                        |*
*| |Op Code| R1 | X2 | B2 | D2  |---|Op Code|                        |*
*| +----------------------------------------+                        |*
*|  0       8    12   16   20    32  40    47                        |*
*+-------------------------------------------------------------------+*
*
DXM35000 DS    0H
         LLGC  R1,DXMINSTR+4       For This Format Unused Area 8 Bits
         LTGR  R1,R1               Are Unused Operand Area Bits Zero?
         BRZ   DXM35100            Yes => Branch to Process Instruction
         LA    R15,8               Indicate a Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Instruction Address is Invalid
DXM35100 DS    0H
         SLGR  R15,R15             Clear to Hold the R1 Register Value
         LLGC  R0,DXMINSTR+1       Get Register Operands in Instruction
         SRLG  R15,R0,4 Bits       Isolate R1 Operand in Work Register
         NILL  R0,(X'000F')        Drop R1 so only the X2 Operand Value
         LLGT  R1,=A(DXM$PAIR)     Address of the Register Pair Table
         LA    R4,L'DXM$PAIR       Len of Each Register Use Table Entry
         LLGF  R5,=A(DXM$PAIR+((DXM$RTNO*L'DXM$PAIR)-L'DXM$PAIR))
DXM35200 DS    0H
         LLGC  R2,0(,R1)           Get Bit Indicator From Reg Pair Tble
         TM    OP@REGEO,(0)        Indicated Target of the Execute
         EX    R2,*-4              Instructn Reg Attribute Match Table?
         BRO   DXM35300            Yes => Instruction has Register Pair
         BRXLG R1,R4,DXM35200      No  => Loop to Check Next Pair Type
         BRU   DXM35500            Instruction Uses No Register Pair(s)
DXM35300 DS    0H
         ICM   R2,B'0011',DXM$R1LN+DXM$R2LN*11(R1) Branch Location
         BRZ   DXM35500            No  => Then Uses No Register Pair(s)
         LLGT  R1,=A(DXMC0000)     Base Address to Calculate the Offset
         LA    R14,0(R2,R1)        Add Offset to Base for Branch Addr
         BR    R14                 Branch Based on Register Attributes
DXM35400 DS    0H
         STC   R15,DXMWORKD        R1 Operand Register to a Work Area
         TRT   DXMWORKD(1),DXMFLTPT ..Valid FltPt R1 Register Coupling?
         BRZ   DXM35500            Yes => FltPt R1 is a Valid Register
         LA    R15,8               No  => Indicate Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM35500 DS    0H
         LG    R4,DXMRTNI@         Address of Area to Return Instructn
         CVD   R15,DXMOPWRK        R1 Register Used to a Decimal Format
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Register No. to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of Register Value
         MVI   0(R4),C'R'          To Designate Operand is for Register
         LA    R4,1(,R4)           Increment Past the Reg Designater
DXM35600 DS    0H
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy R1 Operand Value to Return Area
         LA    R4,1(R2,R4)         Increment Past the Operand Value
         MVI   0(R4),C','          Insert Comma Character After Operand
         LA    R4,1(,R4)           Increment for D2 Operand Field
         SLGR  R15,R15             Clear for Use as a B2 Work Register
         LLGH  R14,DXMINSTR+2      Get B2 and D2 Operands in Instructn
         SRLG  R15,R14,12 Bits     B2 Register Operand to Work Register
         NILL  R14,(X'0FFF')       Drop B2 so only the D2 Operand Value
DXM35700 DS    0H
         CVD   R14,DXMOPWRK        Displacement Value to Packed Decimal
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit D2 Displacement to Character
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of D2 Field Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy D2 Displacement to Return Area
         LA    R4,1(R2,R4)         Increment Past the Displacement
         MVI   0(R4),C'('          Insert Left Parand After Operand
         LA    R4,1(,R4)           Increment to X2 Index Register Field
DXM35800 DS    0H
         LGR   R1,R0               X2 Register Operand to Work Register
         BRAS  R14,DXDW1000        X2 Register Used to a Decimal Format
         MVI   0(R4),C','          Insert Comma Delimiter After Operand
         LA    R4,1(,R4)           Increment to B2 Base Register Field
DXM35900 DS    0H
         LGR   R1,R15              B2 Register Operand to Work Register
         BRAS  R14,DXDW1000        B2 Register Used to a Decimal Format
         MVI   0(R4),C')'          Closing Parenthesis for Operands
         BRU   DXMCEXIT            Done with RXE Format, Branch to Exit
*
*+-------------------------------------------------------------------+*
*| Process the type RXF machine instruction format. The RXF type     |*
*| instruction is for a register-and-index storage operation with a  |*
*| longer extended two-byte bifarcated op-code, an additional        |*
*| register field, and a 4-bit unused operand field.                 |*
*|                                                                   |*
*| Instruction Group RXF                                             |*
*| ---------------------                                             |*
*|  MAD  MADB  MAE  MAEB  MAY  MAYH  MAYL  MSD  MSDB  MSE  MSEB      |*
*|  MY   MYH   MYL  SLDT  SLXT SRDT  SRXT                            |*
*|                                                                   |*
*| RXF                                                               |*
*| R1,R3,D2(X2,B2)                                                   |*
*| +---------------------------------------------+                   |*
*| |Op Code| R3 | X2 | B2 | D2  | R1 |---|Op Code|                   |*
*| +---------------------------------------------+                   |*
*|  0       8    12   16   20    32   36  40    47                   |*
*+-------------------------------------------------------------------+*
*
DXM37000 DS    0H
         XC    DXMOPWRK(2),DXMOPWRK ...To Check RXF Instruction Format
         MVN   DXMOPWRK(1),DXMINSTR+4  Drop R1, Extract Unused Operand
         CLI   DXMOPWRK,X'00'      Are the Unused Operand Bits Zero?
         BRE   DXM37100            Yes => Instruction Passes Validity
         LA    R15,8               Indicate a Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM37100 DS    0H
         SLGR  R15,R15             Clear to Hold the R3 Register Value
         LLGC  R0,DXMINSTR+1       Get Register Operands in Instruction
         SRLG  R15,R0,4 Bits       Isolate R3 Operand in Work Register
         NILL  R0,(X'000F')        Drop R3 so only the X2 Operand Value
         LLGC  R6,DXMINSTR+4       Get R1 Register Operand in Instructn
         LLGT  R1,=A(DXM$PAIR)     Address of the Register Pair Table
         LA    R4,L'DXM$PAIR       Len of Each Register Use Table Entry
         LLGF  R5,=A(DXM$PAIR+((DXM$RTNO*L'DXM$PAIR)-L'DXM$PAIR))
DXM37200 DS    0H
         LLGC  R2,0(,R1)           Get Bit Indicator From Reg Pair Tble
         TM    OP@REGEO,(0)        Indicated Target of the Execute
         EX    R2,*-4              Instructn Reg Attribute Match Table?
         BRO   DXM37300            Yes => Instruction has Register Pair
         BRXLG R1,R4,DXM37200      No  => Loop to Check Next Pair Type
         BRU   DXM37700            Instruction Uses No Register Pair(s)
DXM37300 DS    0H
         ICM   R2,B'0011',DXM$R1LN+DXM$R2LN*12(R1) Branch Location
         BRZ   DXM37700            No  => Then Uses No Register Pair(s)
         LLGT  R1,=A(DXMC0000)     Base Address to Calculate the Offset
         LA    R14,0(R2,R1)        Add Offset to Base for Branch Addr
         BR    R14                 Branch Based on Register Attributes
DXM37400 DS    0H
         STC   R15,DXMWORKD        R1 Operand Register to a Work Area
         TRT   DXMWORKD(1),DXMFLTPT ..Valid FltPt R1 Register Coupling?
         BRZ   DXM37700            Yes => FltPt R1 is a Valid Register
         LA    R15,8               No  => Indicate Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM37500 DS    0H
         STC   R6,DXMWORKD         R1 Operand Register to a Work Area
         STC   R15,DXMWORKD+1      R3 Operand Register to a Work Area
         TRT   DXMWORKD(1),DXMFLTPT ..Valid FltPt R1 Register Coupling?
         BRNZ  DXM37600            No  => FltPt R1 Not a Valid Register
         TRT   DXMWORKD+1(1),DXMFLTPT Valid FltPt R3 Register Coupling?
         BRZ   DXM37700            Yes => Both R1+R3 Valid Fltpt Pairs
DXM37600 DS    0H
         LA    R15,8               No  => Indicate Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM37700 DS    0H
         LG    R4,DXMRTNI@         Address of Area to Return Instructn
         CVD   R6,DXMOPWRK         R1 Register Used to a Decimal Format
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Register No. to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of Register Value
         MVI   0(R4),C'R'          To Designate Operand is for Register
         LA    R4,1(,R4)           Increment Past the Reg Designater
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy R1 Register No. to Return Area
         LA    R4,1(R2,R4)         Increment Past the Register Operand
         MVI   0(R4),C','          Insert Comma Character After Operand
         LA    R4,1(,R4)           Increment to the Next Operand Field
DXM37800 DS    0H
         CVD   R15,DXMOPWRK        R3 Register Used to a Decimal Format
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Register No. to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of Register Value
         MVI   0(R4),C'R'          To Designate Operand is for Register
         LA    R4,1(,R4)           Increment Past the Reg Designater
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy R3 Register No. to Return Area
         LA    R4,1(R2,R4)         Increment Past the Register Operand
         MVI   0(R4),C','          Insert Comma Character After Operand
         LA    R4,1(,R4)           Increment to the Next Operand Field
DXM37900 DS    0H
         SLGR  R15,R15             Clear for Use as a B2 Work Register
         LLGH  R14,DXMINSTR+2      Get B2 and D2 Operands in Instructn
         SRLG  R15,R14,12 Bits     B2 Register Operand to Work Register
         NILL  R14,(X'0FFF')       Drop B2 so only the D4 Operand Value
         CVD   R14,DXMOPWRK        Displacement Value to Packed Decimal
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit D2 Displacement to Character
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of D2 Field Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy D2 Displacment to Return Area
         LA    R4,1(R2,R4)         Increment Past the Displacement
         MVI   0(R4),C'('          Insert Left Parand After Operand
         LA    R4,1(,R4)           Increment to B4 Base Register Field
DXM38000 DS    0H
         CVD   R0,DXMOPWRK         X2 Index Register to Decimal Format
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit the Index Register to Character
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of Register Value
         MVI   0(R4),C'R'          To Designate Operand is for Register
         LA    R4,1(,R4)           Increment Past the Reg Designater
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy Index Register to Return Area
         LA    R4,1(R2,R4)         Increment Past the Register Operand
         MVI   0(R4),C','          Comma Separator to Next B2 Operand
         LA    R4,1(,R4)           Increment to B2 Base Register Field
DXM38100 DS    0H
         CVD   R15,DXMOPWRK        Base Register Used to Decimal Format
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Base Register to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of Register Value
         MVI   0(R4),C'R'          To Designate Operand is for Register
         LA    R4,1(,R4)           Increment Past the Reg Designater
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy in the B2 Base Register Number
         LA    R4,1(R2,R4)         Increment Past Base Register Value
         MVI   0(R4),C')'          Closing Parenthesis for Operands
         BRU   DXMCEXIT            Done with RXF Format, Branch to Exit
*
*+-------------------------------------------------------------------+*
*| Process the type RXY-a and RXY-b variation machine instruction    |*
*| formats. These instruction formats are for a register-and-indexed |*
*| storage operation with a longer extended two-byte bifarcated      |*
*| op-code, and a larger 20-bit long displacement field. The RXY-b   |*
*| uses a 4-bit mask field in place of the register field used in the|*
*| RXY-a format.                                                     |*
*|                                                                   |*
*| Instruction Group RXY-a                                           |*
*| -----------------------                                           |*
*|  AG   AGF  AHY  ALC  ALCG  ALG  ALGF  ALY   AY   BCTG  CG    CGF  |*
*|  CGH  CHF  CHY  CLG  CLGF  CLHF CLY   CVBG  CVBY CVDG  CVDY  CY   |*
*|  DL   DLG  DSG  DSGF ICY   LAEY LAY   LB    LBH  LDY   LEY   LFH  |*
*|  LG   LGB  LGF  LGH  LHH   LHY  LLC   LLCH  LLGC LLGF  LLGH  LLGT |*
*|  LLH  LLHH LPQ  LRAG LRAY  LRV  LRVG  LRVH  LT   LTG   LTGF  LY   |*
*|  MFY  MHY  ML   MLG  MSG   MSGF MSY   NG    NY   OG    OY    SG   |*
*|  SGF  SHY  SLB  SLBG SLG   SLGF SLY   STCH  STCY STDY  STEY  STFH |*
*|  STFH STG  STHH STHY STPQ  STRV STRVG STRVH STY  SY    XG    XY   |*
*|                                                                   |*
*| RXY2 / RXY-a                                                      |*
*| R1,D2(X2,B2)                                                      |*
*| +------------------------------------------+                      |*
*| |Op Code| R1 | X2 | B2 | DL2 | DH2 |Op Code|                      |*
*| +------------------------------------------+                      |*
*|  0       8    12   16   20    32    40    47                      |*
*|                                                                   |*
*|                                                                   |*
*| Instruction Group RXY-b                                           |*
*| -----------------------                                           |*
*|  PFD                                                              |*
*|                                                                   |*
*| RXY1 / RXY-b                                                      |*
*| M1,D2(X2,B2)                                                      |*
*| +------------------------------------------+                      |*
*| |Op Code| M1 | X2 | B2 | DL2 | DH2 |Op Code|                      |*
*| +------------------------------------------+                      |*
*|  0       8    12   16   20    32    40    47                      |*
*+-------------------------------------------------------------------+*
*
DXM39000 DS    0H
         SLGR  R15,R15             Clear to Hold the R1 Register Value
         LLGC  R0,DXMINSTR+1       Get Register Operands in Instruction
         SRLG  R15,R0,4 Bits       Isolate R1 Operand in Work Register
         NILL  R0,(X'000F')        Drop R1 so only the X2 Operand Value
         LLGT  R1,=A(DXM$PAIR)     Address of the Register Pair Table
         LA    R4,L'DXM$PAIR       Len of Each Register Use Table Entry
         LLGF  R5,=A(DXM$PAIR+((DXM$RTNO*L'DXM$PAIR)-L'DXM$PAIR))
DXM39100 DS    0H
         LLGC  R2,0(,R1)           Get Bit Indicator From Reg Pair Tble
         TM    OP@REGEO,(0)        Indicated Target of the Execute
         EX    R2,*-4              Instructn Reg Attribute Match Table?
         BRO   DXM39200            Yes => Instruction has Register Pair
         BRXLG R1,R4,DXM39100      No  => Loop to Check Next Pair Type
         BRU   DXM39400            Instruction Uses No Register Pair(s)
DXM39200 DS    0H
         ICM   R2,B'0011',DXM$R1LN+DXM$R2LN*13(R1) Branch Location
         BRZ   DXM39400            No  => Then Uses No Register Pair(s)
         LLGT  R1,=A(DXMC0000)     Base Address to Calculate the Offset
         LA    R14,0(R2,R1)        Add Offset to Base for Branch Addr
         BR    R14                 Branch Based on Register Attributes
DXM39300 DS    0H
         TM    DXMINSTR+1,X'10'    Is R1 Operand an Even Numbered Reg?
         BRZ   DXM39400            Yes => Instruction Has Valid R1 Reg
         LA    R15,8               No  => Indicate Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM39400 DS    0H
         LG    R4,DXMRTNI@         Address of Area to Return Instructn
         CVD   R15,DXMOPWRK        R1 Register Used to a Decimal Format
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Register No. to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of Register Value
         CLC   OP@TYPE,=CL6'RXY-b' Variation-b RXY Instruction Format?
         BRE   DXM39500            Yes => Operand Used as Cond Cde Mask
         MVI   0(R4),C'R'          To Designate Operand is for Register
         LA    R4,1(,R4)           Increment Past the Reg Designater
DXM39500 DS    0H
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy R1 or M1 Operand to Return Area
         LA    R4,1(R2,R4)         Increment Past the Operand Value
         MVI   0(R4),C','          Insert Comma Character After Operand
         LA    R4,1(,R4)           Increment for DL2/DH2(B2) Operands
         ICMH  R5,B'1100',DXMINSTR+2  Get B2 Field and DL2 (low) Field
         SRLG  R5,R5,4 Bits        Open a Byte Where DH2 to Overlay B2
         ICMH  R5,B'1000',DXMINSTR+4 DH2 (high) Field is to Left of DL2
         SRAG  R6,R5,32+12 Bits    Set Signed 20-bit Displacement Value
         CVD   R6,DXMOPWRK         20-bit Displacement to Decimal Form
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Displacement to Character Form
         BRNM  DXM39600            Branch if Displacement is Positive
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Leng of Displacement Value
         MVI   0(R4),C'-'          Specify the Displacement as Negative
         LA    R4,1(,R4)           Increment Past the Sign Indicator
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              20-bit Displacement to Return Area
         LA    R4,1(R2,R4)         Increment Past Displacement Value
         BRU   DXM39700            Branch to Process the Instruction
DXM39600 DS    0H
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Leng of Displacement Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              20-bit Displacement to Return Area
         LA    R4,1(R2,R4)         Increment Past Displacement Value
DXM39700 DS    0H
         LLGC  R15,DXMINSTR+2      Get Register Operand in Instruction
         SRLG  R15,R15,4 Bits      Isolate B2 Operand in Work Register
         MVI   0(R4),C'('          Insert Left Parand After Operand
         LA    R4,1(,R4)           Increment to X2 Index Register Field
         CVD   R0,DXMOPWRK         Index Register Used to Decimal Form
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit the Index Register to Character
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of Register Value
         MVI   0(R4),C'R'          To Designate Operand is for Register
         LA    R4,1(,R4)           Increment Past the Reg Designater
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy Index Reg Number to Return Area
         LA    R4,1(R2,R4)         Increment Past the Register Operand
         MVI   0(R4),C','          Insert Comma Delimiter After Operand
         LA    R4,1(,R4)           Increment to the B2 Register Field
DXM39800 DS    0H
         CVD   R15,DXMOPWRK        B2 Base Register to a Decimal Format
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit B2 Register to Character Format
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of B2 Operand Value
         MVI   0(R4),C'R'          To Designate Operand is for Register
         LA    R4,1(,R4)           Increment Past the Reg Designater
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy the B2 Register to Return Area
         LA    R4,1(R2,R4)         Increment Past the Register Operand
         MVI   0(R4),C')'          Insert Closing Parenthesis for Reg
         BRU   DXMCEXIT            Done with RXY Format, Branch to Exit
*
*+-------------------------------------------------------------------+*
*| Process the type S machine instruction format. The S type         |*
*| instruction is for a storage operation with a longer extended     |*
*| two-byte contiguous op-code or a one-byte op-code with implied    |*
*| operands. In certain instances it may have unused operand fields. |*
*|                                                                   |*
*| Instruction Group S                                               |*
*| -------------------                                               |*
*|  CFC   CSCH  HSCH  IPK   LFAS  LFPC  LPSW  LPSWE MSCH  PC    PTLB |*
*|  RCHP  RP    RSCH  SAC   SACF  SAL   SCHM  SCK   SCKC  SIE   SPKA |*
*|  SPT   SPX   SRNM  SRNMB SRNMT SSCH  SSM   STAP  STCK  STCKC STCKE|*
*|  STCKF STCPS STCRW STFL  STFLE STFPC STIDP STPT  STPX  STSCH STSI |*
*|  TPI   TRAP4 TS    TSCH  XSCH                                     |*
*|                                                                   |*
*| S                                 S                               |*
*| D2(B2)                            D2(B2)                          |*
*| +-------------------------+       +-------------------------+     |*
*| |  Op Code   | B2 |  D2   |       |Op Code|----| B2 |  D2   |     |*
*| +-------------------------+       +-------------------------+     |*
*|  0           16    20    31        0       8    16   20    31     |*
*|                                                                   |*
*| S                                                                 |*
*| (No Operands)                                                     |*
*| +-------------------------+                                       |*
*| |  Op Code   |----|-------|                                       |*
*| +-------------------------+                                       |*
*|  0            16   20    31                                       |*
*+-------------------------------------------------------------------+*
*
DXM41000 DS    0H
         CLC   OP@FORMT(7),=CL7'Op_Code' Are There Designated Operands?
         BRNE  DXM41100            Yes => Branch to Process Instruction
         LLGH  R15,DXMINSTR+2      Get Unused Operand Area in Instructn
         LTGR  R15,R15             Are the Unused Operand Bits Zero?
         BRZ   DXMCEXIT            Yes => Then Done For This Variation
         LA    R15,8               Indicate a Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM41100 DS    0H
         CLC   OP@MCHCD,=XL2'8000' This for a Set System Mask Instruct?
         BRE   DXM41200            Yes => Instruction Has 1 Byte Op Cde
         CLC   OP@MCHCD,=XL2'8200' Is This for a Load PSW Instruction?
         BRE   DXM41200            Yes => Instruction Has 1 Byte Op Cde
         CLC   OP@MCHCD,=XL2'9300' This for a Test and Set Instruction?
         BRE   DXM41200            Yes => Instruction Has 1 Byte Op Cde
         BRU   DXM41300            No  => Then Process All Others
DXM41200 DS    0H
         LLGC  R1,DXMINSTR+1       On This Variation a One Byte Op Code
         LTGR  R1,R1               Are Unused Operand Area Bits Zero?
         BRZ   DXM41300            Yes => Branch to Process Instruction
         LA    R15,8               Indicate a Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM41300 DS    0H
         LG    R4,DXMRTNI@         Address of Area to Return Instructn
         SLGR  R15,R15             Clear for Use as a B2 Work Register
         LLGH  R14,DXMINSTR+2      Get B2 and D2 Operands in Instructn
         SRLG  R15,R14,12 Bits     B2 Register Operand to Work Register
         NILL  R14,(X'0FFF')       Drop B2 so only the D2 Operand Value
         CVD   R14,DXMOPWRK        Displacement Value to Packed Decimal
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit D2 Displacement to Character
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of D2 Field Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy D2 Displacment to Return Area
         LA    R4,1(R2,R4)         Increment Past the Displacement
         MVI   0(R4),C'('          Insert Left Parand After Operand
         LA    R4,1(,R4)           Increment to B2 Base Register Field
DXM41400 DS    0H
         LGR   R1,R15              B2 Register Operand to Work Register
         BRAS  R14,DXDW1000        B2 Register Used to a Decimal Format
         MVI   0(R4),C')'          Insert Closing Parenthesis for Reg
         BRU   DXMCEXIT            Done for S Format, Branch to Exit
*
*+-------------------------------------------------------------------+*
*| Process the type SIL machine instruction format. The SIL type     |*
*| instruction is for a storage-and-immediate operation with a longer|*
*| extended two-byte contiguous op-code with a 16-bit immediate      |*
*| field.                                                            |*
*|                                                                   |*
*| Instruction Group SIL                                             |*
*| ---------------------                                             |*
*|  CGHSI  CHHSI  CHSI  CLFHSI  CLGHSI  CLHHSI  MVGHI  MVHHI  MVHI   |*
*|                                                                   |*
*| SIL                                                               |*
*| D1(B1),I2                                                         |*
*| +------------------------------+                                  |*
*| |  Op Code  | B1 | D1 |   I2   |                                  |*
*| +------------------------------+                                  |*
*|  0           16   20   32     47                                  |*
*+-------------------------------------------------------------------+*
*
DXM43000 DS    0H
         LG    R4,DXMRTNI@         Address of Area to Return Instructn
         SLGR  R6,R6               Clear to Hold the D1 Operand Value
         LLGH  R5,DXMINSTR+2       Get B1 and D1 Operands in Instructn
         SRLG  R6,R5,12 Bits       Isolate B2 Operand in Work Register
         NILL  R5,(X'0FFF')        Drop B1 so only the D1 Operand Value
         CVD   R5,DXMOPWRK         12-bit Displacement to Decimal Form
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Displacement to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Leng of Displacement Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              12-bit Displacement to Return Area
         LA    R4,1(R2,R4)         Increment Past Displacement Value
         MVI   0(R4),C'('          Insert Left Parand After Operand
         LA    R4,1(,R4)           Increment to B1 Base Register Field
DXM43100 DS    0H
         CVD   R6,DXMOPWRK         Base Register Used to Decimal Format
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Base Register to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Leng of B1 Register Value
         MVI   0(R4),C'R'          To Designate Operand is for Register
         LA    R4,1(,R4)           Increment Past the Reg Designater
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy B1 Base Reg No. to Return Area
         LA    R4,1(R2,R4)         Increment Past Base Register Operand
         MVI   0(R4),C')'          Insert Closing Parenthesis for Reg
         MVI   1(R4),C','          Insert Comma Delimiter for I2 Field
         LA    R4,2(,R4)           Increment to the I2 Operand Field
         CLI   OP@MNEUM+1,C'L'     Instruction Use Unsigned I2 Operand?
         BRE   DXM43200            Yes => Branch for Unsigned Immediate
         LGH   R0,DXMINSTR+4       Instruct Uses Signed Immediate Value
         BRU   DXM43300            Branch to Process Immediate Value
DXM43200 DS    0H
         LLGH  R0,DXMINSTR+4       Instruction Uses Unsigned Immediate
DXM43300 DS    0H
         CVD   R0,DXMOPWRK         Immed Value in Reg to Decimal Format
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Base Register to Character Form
         BRNM  DXM43400            Branch if the Result is Positive
         MVI   0(R4),C'-'          Indicate Immediate Value is Negative
         LA    R4,1(,R4)           Increment Past the Minus Character
DXM43400 DS    0H
         LA    R2,DXMDECI2+L'DXMDECI2-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of Immediate Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy I2 Operand Value to Return Area
         BRU   DXMCEXIT            Done for SIL Format, Branch to Exit
*
*+-------------------------------------------------------------------+*
*| Process the type SI machine instruction format. The SI type       |*
*| instruction is for a storage-and-immediate operation with a one   |*
*| byte op-code and a 16-bit immediate field.                        |*
*|                                                                   |*
*| Instruction Group SI                                              |*
*| --------------------                                              |*
*|  CLI  MC  MVI  NI  OI  STNSM  STOSM  TM  XI                       |*
*|                                                                   |*
*| SI                                                                |*
*| D1(B1),I2                                                         |*
*| +--------------------------+                                      |*
*| |Op Code|I2     | B1 | D1  |                                      |*
*| +--------------------------+                                      |*
*|  0       8       16   20  31                                      |*
*+-------------------------------------------------------------------+*
*
DXM44000 DS    0H
         LLGC  R15,DXMINSTR+1      Get the I2 Immediate Operand Value
         CLC   OP@MCHCD,=XL2'AF00' This for a Monitor Call Instruction?
         BRNE  DXM44200            No  => Branch to Process When Not MC
DXM44100 DS    0H
         TMLL  R15,X'00F0'         Are the Bit Positions 8-11 Zeros?
         BRZ   DXM44200            Yes => Branch to Process Instruction
         LA    R15,8               Indicate a Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM44200 DS    0H
         LG    R4,DXMRTNI@         Address of Area to Return Instructn
         SLGR  R6,R6               Clear to Hold the D1 Operand Value
         LLGH  R5,DXMINSTR+2       Get B1 and D1 Operands in Instructn
         SRLG  R6,R5,12 Bits       Isolate B1 Operand in Work Register
         NILL  R5,(X'0FFF')        Drop B1 so only the D1 Operand Value
         CVD   R5,DXMOPWRK         12-bit Displacement to Decimal Form
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Displacement to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Leng of Displacement Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              12-bit Displacement to Return Area
         LA    R4,1(R2,R4)         Increment Past Displacement Value
         MVI   0(R4),C'('          Insert Left Parand After Operand
         LA    R4,1(,R4)           Increment to B1 Base Register Field
DXM44300 DS    0H
         CVD   R6,DXMOPWRK         Base Register Used to Decimal Format
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Base Register to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Leng of B1 Register Value
         MVI   0(R4),C'R'          To Designate Operand is for Register
         LA    R4,1(,R4)           Increment Past the Reg Designater
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy B1 Base Reg No. to Return Area
         LA    R4,1(R2,R4)         Increment Past Base Register Operand
         MVI   0(R4),C')'          Insert Closing Parenthesis for Reg
         LA    R4,1(,R4)           Increment to Prepare for I2 Operand
DXM44400 DS    0H
         MVC   0(3,R4),=CL3',X'''  To Show Immediate Value in Hex Form
         LA    R4,3(,R4)           Increment to the I2 Operand Field
         STG   R15,DXMWORKD        I2 Immediate Value to a Work Area
         UNPK  DXMOPWRK(5),DXMWORKD+6(3) ..Convert I2 From Hex to Zoned
         TR    DXMOPWRK(4),HEXCONV-C'0'  ..Translate Hex to Character
         MVC   0(2,R4),DXMOPWRK+2  Hex Value Now in a Character Format
         MVI   2(R4),C''''         End Hex I2 with a Closing Apostrophe
         BRU   DXMCEXIT            Done with SI Format, Branch to Exit
*
*+-------------------------------------------------------------------+*
*| Process the type SIY machine instruction format. The SIY type     |*
*| instruction is for a storage-and-immediate operation with a longer|*
*| extended two-byte bifarcated op-code, a larger 20-bit long        |*
*| displacement field, and an 8-bit immediate field.                 |*
*|                                                                   |*
*| Instruction Group SIY                                             |*
*| ---------------------                                             |*
*|  AGSI  ALGSI  ALSI  ASI  CLIY  MVIY  NIY  OIY  TMY  XIY           |*
*|                                                                   |*
*| SIY                                                               |*
*| D1(B1),I2                                                         |*
*| +-------------------------------------+                           |*
*| |Op Code| I2 | B1 | DL1 | DH1 |Op Code|                           |*
*| +-------------------------------------+                           |*
*|  0       8    16   20    32    40    47                           |*
*+-------------------------------------------------------------------+*
DXM45000 DS    0H
         LG    R4,DXMRTNI@         Address of Area to Return Instructn
         ICMH  R5,B'1100',DXMINSTR+2  Get B1 Field and DL1 (low) Field
         SRLG  R5,R5,4 Bits        Open a Byte Where DH1 to Overlay B1
         ICMH  R5,B'1000',DXMINSTR+4 DH1 (high) Field is to Left of DL1
         SRAG  R6,R5,32+12 Bits    Set Signed 20-bit Displacement Value
         CVD   R6,DXMOPWRK         20-bit Displacement to Decimal Form
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Displacement to Character Form
         BRNM  DXM45100            Branch if Displacement is Positive
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Leng of Displacement Value
         MVI   0(R4),C'-'          Specify the Displacement as Negative
         LA    R4,1(,R4)           Increment Past the Sign Indicator
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              20-bit Displacement to Return Area
         LA    R4,1(R2,R4)         Increment Past Displacement Value
         BRU   DXM45200            Branch to Process the Instruction
DXM45100 DS    0H
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Leng of Displacement Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              20-bit Displacement to Return Area
         LA    R4,1(R2,R4)         Increment Past Displacement Value
DXM45200 DS    0H
         LLGC  R15,DXMINSTR+2      Get Register Operand in Instruction
         SRLG  R15,R15,4 Bits      Isolate B1 Operand in Work Register
         MVI   0(R4),C'('          Insert Left Parand After Operand
         LA    R4,1(,R4)           Increment to B1 Base Register Field
         CVD   R15,DXMOPWRK        Base Register Used to Decimal Form
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit the Base Register to Character
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of Register Value
         MVI   0(R4),C'R'          To Designate Operand is for Register
         LA    R4,1(,R4)           Increment Past the Reg Designater
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy Base Reg Number to Return Area
         LA    R4,1(R2,R4)         Increment Past the Register Operand
         MVI   0(R4),C')'          Insert Closing Parenthesos for Reg
         MVI   1(R4),C','          Insert Comma Delimiter for I2 Field
         LA    R4,2(,R4)           Increment to the I2 Operand Field
DXM45300 DS    0H
         LLGH  R15,OP@MCHCD        Get the Op Code for Our Instruction
         SRLG  R15,R15,4 Bits      Isolate the High-Order 3 Nibbles
         CLM   R15,B'0011',=X'0EB5'  Part of Boolean Instruction Group?
         BRNE  DXM45500            No  => Branch to Show I2 as Decimal
DXM45400 DS    0H
         LLGC  R15,DXMINSTR+1      Get 8-bit I2 Operand Immediate Value
         MVC   0(2,R4),=CL2'X'''   To Show Immediate Value in Hex Form
         LA    R4,2(,R4)           Increment to the Operand Field
         STG   R15,DXMWORKD        I2 Immediate Value to a Work Area
         UNPK  DXMOPWRK(5),DXMWORKD+6(3) ..Convert I2 From Hex to Zoned
         TR    DXMOPWRK(4),HEXCONV-C'0'  ..Translate Hex to Character
         MVC   0(2,R4),DXMOPWRK+2  Hex Value Now in a Character Format
         MVI   2(R4),C''''         End Hex I2 with a Closing Apostrophe
         BRU   DXM45700            Done with This SIY Format Variation
DXM45500 DS    0H
         ICMH  R0,B'1000',DXMINSTR+1 ...Get 8-bit I2 Immediate Operand
         SRAG  R0,R0,32+24 Bits    For Extending a Sign Bit in Register
         CVD   R0,DXMOPWRK         Immediate Value to Packed Decimal
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Immediate Value to Character
         BRNM  DXM45600            Branch if the Result is Positive
         MVI   0(R4),C'-'          Indicate Immediate Value is Negative
         LA    R4,1(,R4)           Increment Past the Minus Character
DXM45600 DS    0H
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of Immediate Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy Immediate Value to Return Area
DXM45700 DS    0H
         BRU   DXMCEXIT            Done with SIY Format, Branch to Exit
*
*+-------------------------------------------------------------------+*
*|Perform processing for the type SS-a variation instruction format. |*
*|The type SS-a is a storage-and-storage operation with a one-byte   |*
*|op-code field and a single 8-bit length specification field.       |*
*|                                                                   |*
*| Instruction Group SS-a                                            |*
*| ----------------------                                            |*
*|  CLC   ED     EDMK   MVC  MVCIN  MVN  MVZ  NC  OC  TR  TRT        |*
*|  TRTR  UNPKA  UNPKU  XC                                           |*
*|                                                                   |*
*| SS1 / SS-a                                                        |*
*| D1(L,B1),D2(B2)                                                   |*
*| +----------------------------------+                              |*
*| |Op Code| L  | B1 | D1  | B2 | D2  |                              |*
*| +----------------------------------+                              |*
*|  0       8    16   20    32   36  47                              |*
*+-------------------------------------------------------------------+*
*
DXM47000 DS    0H
         CLC   OP@MCHCD,=XL2'EA00' This for Unpack ASCII Instruction?
         BRE   DXM47200            Yes => Check Length Operand Value
         CLC   OP@MCHCD,=XL2'E200' This for Unpack Unicode Instruction?
         BRNE  DXM47400            No  => Process All Other Instructns
DXM47100 DS    0H
         CLI   DXMINSTR+1,X'3F'    Leng in Unpack Unicode More than 63?
         BRH   DXM47300            Yes => Then Not a Valid Instruction
         TM    DXMINSTR+1,X'01'    Is the Length an Odd Number Value?
         BRZ   DXM47300            No  => Invalid Length, Must be Odd
         BRU   DXM47400            Yes => Machine Code Odd for Even 'L'
DXM47200 DS    0H
         CLI   DXMINSTR+1,X'1F'    Length in Unpack ASCII More than 31?
         BRNH  DXM47400            No  => Length Value Within Bounds
DXM47300 DS    0H
         LA    R15,8               Indicate a Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM47400 DS    0H
         LG    R4,DXMRTNI@         Address of Area to Return Instructn
         LLGC  R5,DXMINSTR+1       Get L1 Length Operand in Instruction
         LG    R2,DXMPREV@         Get Addr of Area for Previous Op-Cde
         SLGR  R15,R15             Clear to Hold Previous Op-Code Type
         ICM   R15,B'1111',0(R2)   Is a Previous Op Code Indicated?
         BRZ   DXM47450            No  => Not Target of EX Instruction
         LTGR  R5,R5               Any Leng Value Coded for L Operand?
         BRZ   DXM47460            No  => Leave at 0, EX will 'OR Leng
DXM47450 DS    0H
         AGHI  R5,(1)              Real Leng is +1 to Machine Code Leng
DXM47460 DS    0H
         SLGR  R15,R15             Clear for Use as a B1 Work Register
         LLGH  R14,DXMINSTR+2      Get B1 and D1 Operands in Instructn
         SRLG  R15,R14,12 Bits     B1 Register Operand to Work Register
         NILL  R14,(X'0FFF')       Drop B1 so only the D1 Operand Value
DXM47500 DS    0H
         CVD   R14,DXMOPWRK        Displacement Value to Packed Decimal
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit D1 Displacement to Character
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of D1 Field Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy D1 Displacment to Return Area
         LA    R4,1(R2,R4)         Increment Past the Displacement
         MVI   0(R4),C'('          Insert Left Parand After Operand
         LA    R4,1(,R4)           Increment to L1 Operand Length Field
DXM47600 DS    0H
         CVD   R5,DXMOPWRK         L1 Operand Value to Packed Decimal
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit L1 Displacement to Character
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of L1 Field Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy L1 Operand Value to Return Area
         LA    R4,1(R2,R4)         Increment Past the L1 Operand Value
         MVI   0(R4),C','          Insert Comma Delimiter After Operand
         LA    R4,1(,R4)           Increment to B1 Base Register Field
DXM47700 DS    0H
         LGR   R1,R15              B1 Register Operand to Work Register
         BRAS  R14,DXDW1000        B1 Register Used to a Decimal Format
         MVI   0(R4),C')'          Closing Parenthesis for Operands
         MVI   1(R4),C','          Insert Comma Delimiter After Operand
         LA    R4,2(,R4)           Increment to B2 Base Register Field
DXM47800 DS    0H
         SLGR  R15,R15             Clear for Use as a B2 Work Register
         LLGH  R14,DXMINSTR+4      Get B1 and D1 Operands in Instructn
         SRLG  R15,R14,12 Bits     B2 Register Operand to Work Register
         NILL  R14,(X'0FFF')       Drop B2 so only the D2 Operand Value
         CVD   R14,DXMOPWRK        Displacement Value to Packed Decimal
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit D1 Displacement to Character
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of D2 Field Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy D2 Displacement to Return Area
         LA    R4,1(R2,R4)         Increment Past the Displacement
         MVI   0(R4),C'('          Insert Left Parand After Operand
         LA    R4,1(,R4)           Increment to B2 Base Register Field
DXM47900 DS    0H
         LGR   R1,R15              B2 Register Operand to Work Register
         BRAS  R14,DXDW1000        B2 Register Used to a Decimal Format
         MVI   0(R4),C')'          Closing Parenthesis for B2 Operand
         BRU   DXMCEXIT            Done with SS-a, Branch to Exit
*
*+-------------------------------------------------------------------+*
*|Perform processing for the type SS-b variation instruction format. |*
*|The type SS-b is a storage-and-storage operation with a one-byte   |*
*|op-code field and two separate 4-bit length specification fields.  |*
*|                                                                   |*
*| Instruction Group SS-b                                            |*
*| ----------------------                                            |*
*|  AP  CP  DP  MP  MVO  PACK  SP  UNPK  ZAP                         |*
*|                                                                   |*
*| SS2 / SS-b                                                        |*
*| D1(L1,B1),D2(L2,B2)                                               |*
*| +---------------------------------------+                         |*
*| |Op Code| L1 | L2 | B1 | D1  | B2 | D2  |                         |*
*| +---------------------------------------+                         |*
*|  0       8    12   16   20    32   36  47                         |*
*+-------------------------------------------------------------------+*
*
DXM49000 DS    0H
         LG    R4,DXMRTNI@         Address of Area to Return Instructn
         SLGR  R5,R5               Clear to Hold the L1 Length Value
         LLGC  R6,DXMINSTR+1       Get Length Operands in Instruction
         LG    R2,DXMPREV@         Get Addr of Area for Previous Op-Cde
         SLGR  R15,R15             Clear to Hold Previous Op-Code Type
         ICM   R15,B'1111',0(R2)   Is a Previous Op Code Indicated?
         BRZ   DXM49100            No  => Not Target of EX Instruction
         LTGR  R6,R6               Leng Value Coded for L1/L2 Operands?
         BRZ   DXM49200            No  => Leave at 0, EX will 'OR Leng
DXM49100 DS    0H
         SRLG  R5,R6,4 Bits        Isolate L1 Operand in Work Register
         AGHI  R5,(1)              Real Leng is +1 to Machine Code Leng
         NILL  R6,(X'000F')        Drop L1 so only the L2 Operand Value
         AGHI  R6,(1)              Real Leng is +1 to Machine Code Leng
DXM49200 DS    0H
         SLGR  R15,R15             Clear to Hold the D1 Operand Value
         LLGH  R0,DXMINSTR+2       Get B1 and D1 Operands in Instructn
         SRLG  R15,R0,12 Bits      Isolate B1 Operand in Work Register
         NILL  R0,(X'0FFF')        Drop B1 so only the D1 Operand Value
         CVD   R0,DXMOPWRK         12-bit Displacement to Decimal Form
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Displacement to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Leng of Displacement Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              12-bit Displacement to Return Area
         LA    R4,1(R2,R4)         Increment Past Displacement Value
         MVI   0(R4),C'('          Insert Left Parand After Operand
         LA    R4,1(,R4)           Increment to L1 Length Operand Field
DXM49300 DS    0H
         CVD   R5,DXMOPWRK         L1 Operand Value to Packed Decimal
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit L1 Displacement to Character
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of L1 Field Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy L1 Operand Value to Return Area
         LA    R4,1(R2,R4)         Increment Past the L1 Operand Value
         MVI   0(R4),C','          Insert Comma Delimiter After Operand
         LA    R4,1(,R4)           Increment to B1 Base Register Field
DXM49400 DS    0H
         LGR   R1,R15              B1 Register Operand to Work Register
         BRAS  R14,DXDW1000        B1 Register Used to a Decimal Format
         MVI   0(R4),C')'          Closing Parenthesis for B1 Operand
         MVI   1(R4),C','          Insert Comma Delimiter After Operand
         LA    R4,2(,R4)           Increment to D2 Displacement Field
DXM49500 DS    0H
         SLGR  R15,R15             Clear to Hold the D2 Operand Value
         LLGH  R0,DXMINSTR+4       Get B2 and D2 Operands in Instructn
         SRLG  R15,R0,12 Bits      Isolate B2 Operand in Work Register
         NILL  R0,(X'0FFF')        Drop B2 so only the D2 Operand Value
         CVD   R0,DXMOPWRK         12-bit Displacement to Decimal Form
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Displacement to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Leng of Displacement Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              12-bit Displacement to Return Area
         LA    R4,1(R2,R4)         Increment Past Displacement Value
         MVI   0(R4),C'('          Insert Left Parand After Operand
         LA    R4,1(,R4)           Increment to L2 Length Operand Field
DXM49600 DS    0H
         CVD   R6,DXMOPWRK         L2 Operand Value to Packed Decimal
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit L2 Displacement to Character
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of L2 Field Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy L2 Operand Value to Return Area
         LA    R4,1(R2,R4)         Increment Past the L2 Operand Value
         MVI   0(R4),C','          Insert Comma Delimiter After Operand
         LA    R4,1(,R4)           Increment to B2 Base Register Field
DXM49700 DS    0H
         LGR   R1,R15              B2 Register Operand to Work Register
         BRAS  R14,DXDW1000        B2 Register Used to a Decimal Format
         MVI   0(R4),C')'          Closing Parenthesis for B2 Operand
         BRU   DXMCEXIT            Done with SS-b, Branch to Exit
*
*+-------------------------------------------------------------------+*
*|Perform processing for the type SS-c variation instruction format. |*
*|The type SS-c is a storage-and-storage operation with a one-byte   |*
*|op-code field, a single 4-bit shift specification field, and a     |*
*|4-bit decimal-rounding-digit immediate field.                      |*
*|                                                                   |*
*| Instruction Group SS-c                                            |*
*| ----------------------                                            |*
*|  SRP                                                              |*
*|                                                                   |*
*| SS3 /SS-c                                                         |*
*| D1(L1,B1),D2(B2),I3                                               |*
*| +-------------------------------------+                           |*
*| |Op Code|L1 |I3 | B1 | D1  | B2 | D2  |                           |*
*| +-------------------------------------+                           |*
*|  0       8   12  16   20    32   36  47                           |*
*+-------------------------------------------------------------------+*
*
DXM51000 DS    0H
         SLGR  R5,R5               Clear to Hold the L1 Length Value
         LLGC  R6,DXMINSTR+1       Get L1 Leng and I3 Immediate Operand
         SRLG  R5,R6,4 Bits        Isolate L1 Operand in Work Register
         LG    R2,DXMPREV@         Get Addr of Area for Previous Op-Cde
         SLGR  R15,R15             Clear to Hold Previous Op-Code Type
         ICM   R15,B'1111',0(R2)   Is a Previous Op Code Indicated?
         BRZ   DXM51100            No  => Not Target of EX Instruction
         LTGR  R5,R5               Any Leng Value Coded for L1 Operand?
         BRZ   DXM51200            No  => Leave at 0, EX will 'OR Leng
DXM51100 DS    0H
         AGHI  R5,(1)              Real Leng is +1 to Machine Code Leng
DXM51200 DS    0H
         NILL  R6,(X'000F')        Drop L1 so only the I3 Operand Value
         SLGR  R15,R15             Clear to Hold the D1 Operand Value
         LLGH  R0,DXMINSTR+2       Get B1 and D1 Operands in Instructn
         SRLG  R15,R0,12 Bits      Isolate B1 Operand in Work Register
         NILL  R0,(X'0FFF')        Drop B1 so only the D1 Operand Value
DXM51300 DS    0H
         CGHI  R6,X'0009'          I3 Rounding Factor in a Valid Range?
         BRNH  DXM51400            Yes => Rounding Factor in Range 0-9
         LA    R15,8               An Instruction Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM51400 DS    0H
         LLGH  R1,DXMINSTR+4       Get the B2 and D2 Operand Values
         SRLG  R1,R1,6 Bits        Only Rightmost 6-bits Used in Shifts
         LTGR  R1,R1               Bits 16-25 From Instruction Zero?
         BRZ   DXM51500            Yes => Branch to Process Instruction
         LA    R15,8               An Instruction Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM51500 DS    0H
         LG    R4,DXMRTNI@         Address of Area to Return Instructn
         CVD   R0,DXMOPWRK         12-bit Displacement of D1 to Decimal
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Displacement to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Leng of Displacement Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              D1 12-bit Displacement to Retrn Area
         LA    R4,1(R2,R4)         Increment Past D1 Displacement Value
         MVI   0(R4),C'('          Insert Left Parand After Operand
         LA    R4,1(,R4)           Increment to L1 Length Operand Field
DXM51600 DS    0H
         CVD   R5,DXMOPWRK         L1 Operand Value to Packed Decimal
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit L1 Displacement to Character
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of L1 Field Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy L1 Operand Value to Return Area
         LA    R4,1(R2,R4)         Increment Past the L1 Operand Value
         MVI   0(R4),C','          Insert Comma Delimiter After Operand
         LA    R4,1(,R4)           Increment to B1 Base Register Field
DXM51700 DS    0H
         LGR   R1,R15              B1 Register Operand to Work Register
         BRAS  R14,DXDW1000        B1 Register Used to a Decimal Format
         MVI   0(R4),C')'          Closing Parenthesis for B1 Operand
         MVI   1(R4),C','          Insert Comma Delimiter After Operand
         LA    R4,2(,R4)           Increment to D2 Base Register Field
DXM51800 DS    0H
         LLGH  R0,DXMINSTR+4       Get B2 and D2 Operands in Instructn
         NILL  R0,(X'003F')        Only Rightmost 6-Bits Used in B2/D2
         LLILL R1,X'0040'          Smallest No. With Low-Order 6 Bits 0
         SGR   R0,R1               Determine If a Left or a Right Shift
         CVD   R0,DXMOPWRK         No. of Bit Positions to be Shifted
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Shift Value to Character Form
         BRNM  DXM51900            Branch if Shift Result is Positive
         MVC   0(3,R4),=CL3'64-'   To Show a Right Shift in Range 0-32
         LA    R4,3(,R4)           Increment to Shift Expression Field
         BRU   DXM52000            Branch to Process Shift Amount Value
DXM51900 DS    0H
         MVC   0(3,R4),=CL3'64+'   To Show a Left Shift in Range 0-31
         LA    R4,3(,R4)           Increment to Shift Expression Field
DXM52000 DS    0H
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate the Length of Shift Amount
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Show Shift Expression Amount in Char
         LA    R4,1(R2,R4)         Increment Past Shift Amount Value
         MVI   0(R4),C','          Insert Comma Delimiter After Operand
         LA    R4,1(,R4)           Increment to the I3 Immediate Field
DXM52100 DS    0H
         CVD   R6,DXMOPWRK         I3 Rounding Factor to Packed Decimal
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Rounding Factor to Character
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of I3 Rounding No.
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy Rounding Factor to Return Area
         BRU   DXMCEXIT            Done with SS-c, Branch to Exit
*
*+-------------------------------------------------------------------+*
*|Perform processing for the type SS-f variation instruction format. |*
*|The type SS-f is a storage-and-storage operation with a one-byte   |*
*|op-code field and a single 8-bit length specification field.       |*
*|                                                                   |*
*| Instruction Group SS-f                                            |*
*| ----------------------                                            |*
*|  PKA  PKU                                                         |*
*|                                                                   |*
*| SS1 / SS-f                                                        |*
*| D1(B1),D2(L2,B2)                                                  |*
*| +-----------------------------------+                             |*
*| |Op Code| L2  | B1 | D1  | B2 | D2  |                             |*
*| +-----------------------------------+                             |*
*|  0       8     16   20    32   36  47                             |*
*+-------------------------------------------------------------------+*
*
DXM53000 DS    0H
         LLGC  R6,DXMINSTR+1       Get L2 Length Operand in Instruction
         CLC   OP@MCHCD,=XL2'E100' This for a Pack Unicode Instruction?
         BRE   DXM53100            Yes => Branch to Check L2 Leng Value
         CLC   OP@MCHCD,=XL2'E900' This for a Pack ASCII Instruction?
         BRE   DXM53300            Yes => Branch to Check L2 Leng Value
         BRU   DXMCEXIT            Only 2 Instruction with SS-f Format
DXM53100 DS    0H
         CGHI  R6,X'3F'            Is the L2 Value Greater than 64?
         BRH   DXM53200            Yes => Then an Invalid L2 Length
         TMLL  R6,X'0001'          Is the L2 Length Value an Even No.?
         BRO   DXM53400            Yes => Machine Code Odd for Even L2
DXM53200 DS    0H
         LA    R15,8               An Instruction Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM53300 DS    0H
         CGHI  R6,X'1F'            Is the L2 Value Greater than 32?
         BRNH  DXM53400            No  => Then a Valid L2 Length
         LA    R15,8               An Instruction Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM53400 DS    0H
         LG    R4,DXMRTNI@         Address of Area to Return Instructn
         SLGR  R15,R15             Clear to Hold the D1 Operand Value
         LLGH  R0,DXMINSTR+2       Get B1 and D1 Operands in Instructn
         SRLG  R15,R0,12 Bits      Isolate B1 Operand in Work Register
         NILL  R0,(X'0FFF')        Drop B1 so only the D1 Operand Value
         CVD   R0,DXMOPWRK         12-bit Displacement to Decimal Form
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Displacement to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Leng of Displacement Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              12-bit Displacement to Return Area
         LA    R4,1(R2,R4)         Increment Past Displacement Value
         MVI   0(R4),C'('          Insert Left Parand After Operand
         LA    R4,1(,R4)           Increment to B1 Base Register Field
DXM53500 DS    0H
         LGR   R1,R15              B1 Register Operand to Work Register
         BRAS  R14,DXDW1000        B1 Register Used to a Decimal Format
         MVI   0(R4),C')'          Closing Parenthesis for B1 Operand
         MVI   1(R4),C','          Insert Comma Delimiter After Operand
         LA    R4,2(,R4)           Increment to D2 Displacement Field
DXM53600 DS    0H
         SLGR  R15,R15             Clear to Hold the D2 Operand Value
         LLGH  R0,DXMINSTR+4       Get B2 and D2 Operands in Instructn
         SRLG  R15,R0,12 Bits      Isolate B2 Operand in Work Register
         NILL  R0,(X'0FFF')        Drop B2 so only the D2 Operand Value
         CVD   R0,DXMOPWRK         12-bit Displacement to Decimal Form
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Displacement to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Leng of Displacement Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              12-bit Displacement to Return Area
         LA    R4,1(R2,R4)         Increment Past Displacement Value
         MVI   0(R4),C'('          Insert Left Parand After Operand
         LA    R4,1(,R4)           Increment to L2 Length Operand Field
DXM53700 DS    0H
         LG    R2,DXMPREV@         Get Addr of Area for Previous Op-Cde
         SLGR  R5,R5               Clear to Hold Previous Op-Code Type
         ICM   R5,B'1111',0(R2)    Is a Previous Op Code Indicated?
         BRZ   DXM53800            No  => Not Target of EX Instruction
         LTGR  R6,R6               Any Leng Value Coded for L2 Operand?
         BRZ   DXM53900            No  => Leave at 0, EX will 'OR Leng
DXM53800 DS    0H
         AGHI  R6,(1)              Real Leng is +1 to Machine Code Leng
DXM53900 DS    0H
         CVD   R6,DXMOPWRK         L2 Operand Value to Packed Decimal
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit L2 Displacement to Character
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of L2 Field Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy L2 Operand Value to Return Area
         LA    R4,1(R2,R4)         Increment Past the L2 Operand Value
         MVI   0(R4),C','          Insert Comma Delimiter After Operand
         LA    R4,1(,R4)           Increment to B2 Base Register Field
DXM54000 DS    0H
         LGR   R1,R15              B2 Register Operand to Work Register
         BRAS  R14,DXDW1000        B2 Register Used to a Decimal Format
         MVI   0(R4),C')'          Closing Parenthesis for B2 Operand
         BRU   DXMCEXIT            Done with SS-f, Branch to Exit
*
*+-------------------------------------------------------------------+*
*|Perform processing for the type SS-d variation instruction format. |*
*|The type SS-d is a storage-and-storage operation with a one-byte   |*
*|op-code field and two additional register fields.                  |*
*|                                                                   |*
*| Instruction Group SS-d                                            |*
*| ----------------------                                            |*
*|  MVCK  MVCP  MVCS                                                 |*
*|                                                                   |*
*| SS4 / SS-d                                                        |*
*| D1(R1,B1),D2(B2),R3                                               |*
*| +---------------------------------------+                         |*
*| |Op Code| R1 | R3 | B1 | D1  | B2 | D2  |                         |*
*| +---------------------------------------+                         |*
*|  0       8    12   16   20    32   36  47                         |*
*+-------------------------------------------------------------------+*
*
DXM55000 DS    0H
         LG    R4,DXMRTNI@         Address of Area to Return Instructn
         SLGR  R5,R5               Clear to Hold R1 Register No. Value
         LLGC  R6,DXMINSTR+1       Get Register Operands in Instruction
         SRLG  R5,R6,4 Bits        Isolate R1 Operand in Work Register
         NILL  R6,(X'000F')        Drop R1 so Only the R3 Operand Value
         SLGR  R15,R15             Clear to Hold the D1 Operand Value
         LLGH  R0,DXMINSTR+2       Get B1 and D1 Operands in Instructn
         SRLG  R15,R0,12 Bits      Isolate B1 Operand in Work Register
         NILL  R0,(X'0FFF')        Drop B1 so only the D1 Operand Value
         CVD   R0,DXMOPWRK         12-bit Displacement to Decimal Form
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Displacement to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Leng of Displacement Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              12-bit Displacement to Return Area
         LA    R4,1(R2,R4)         Increment Past Displacement Value
         MVI   0(R4),C'('          Insert Left Parand After Operand
         LA    R4,1(,R4)           Increment to R1 Length Operand Field
DXM55100 DS    0H
         LGR   R1,R5               R1 Register Operand to Work Register
         BRAS  R14,DXDW1000        R1 Register Used to a Decimal Format
         MVI   0(R4),C','          Insert Comma Delimiter After Operand
         LA    R4,1(,R4)           Increment to B1 Base Register Field
DXM55200 DS    0H
         LGR   R1,R15              B1 Register Operand to Work Register
         BRAS  R14,DXDW1000        B1 Register Used to a Decimal Format
         MVI   0(R4),C')'          Closing Parenthesis for B1 Operand
         MVI   1(R4),C','          Insert Comma Delimiter After Operand
         LA    R4,2(,R4)           Increment to D2 Displacement Field
DXM55300 DS    0H
         SLGR  R15,R15             Clear for Use as a B2 Work Register
         LLGH  R14,DXMINSTR+4      Get B1 and D1 Operands in Instructn
         SRLG  R15,R14,12 Bits     B2 Register Operand to Work Register
         NILL  R14,(X'0FFF')       Drop B2 so only the D2 Operand Value
         CVD   R14,DXMOPWRK        Displacement Value to Packed Decimal
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit D1 Displacement to Character
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of D2 Field Value
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy D2 Displacement to Return Area
         LA    R4,1(R2,R4)         Increment Past the Displacement
         MVI   0(R4),C'('          Insert Left Parand After Operand
         LA    R4,1(,R4)           Increment to B2 Base Register Field
DXM55400 DS    0H
         LGR   R1,R15              B2 Register Operand to Work Register
         BRAS  R14,DXDW1000        B2 Register Used to a Decimal Format
         MVI   0(R4),C')'          Closing Parenthesis for B2 Operand
         MVI   1(R4),C','          Insert Comma Delimiter After Operand
         LA    R4,2(,R4)           Increment to R3 Register Operand
DXM55500 DS    0H
         LGR   R1,R6               R3 Register Operand to Work Register
         BRAS  R14,DXDW1000        R3 Register Used to a Decimal Format
         BRU   DXMCEXIT            Done with SS-d, Branch to Exit
*
*+-------------------------------------------------------------------+*
*|Perform processing for the type SS-e variation instruction format. |*
*|The type SS-d is a storage-and-storage operation with a one-byte   |*
*|op-code field and two additional register fields. This single SS-e |*
*|variation has two separate assembler language syntax variations.   |*
*|                                                                   |*
*| Instruction Group SS-e                                            |*
*| ----------------------                                            |*
*|  LMD  PLO                                                         |*
*|                                                                   |*
*| SS5 / SS-e                                                        |*
*| R1,R3,D2(B2),D4(B4)   R1,D2(B2),R3,D4(B4)                         |*
*| +---------------------------------------+                         |*
*| |Op Code| R1 | R3 | B2 | D2  | B4 | D4  |                         |*
*| +---------------------------------------+                         |*
*|  0       8    12   16   20    32   36  47                         |*
*+-------------------------------------------------------------------+*
*
DXM57000 DS    0H
         LG    R4,DXMRTNI@         Address of Area to Return Instructn
         SLGR  R5,R5               Clear to Hold R1 Register No. Value
         LLGC  R6,DXMINSTR+1       Get Register Operands in Instruction
         SRLG  R5,R6,4 Bits        Isolate R1 Operand in Work Register
         NILL  R6,(X'000F')        Drop R1 so Only the R3 Operand Value
         SLGR  R15,R15             Clear to Hold the D2 Operand Value
         LLGH  R0,DXMINSTR+2       Get B2 and D2 Operands in Instructn
         SRLG  R15,R0,12 Bits      Isolate B2 Operand in Work Register
         NILL  R0,(X'0FFF')        Drop B2 so only the D2 Operand Value
DXM57100 DS    0H
         LGR   R1,R5               R1 Register Operand to Work Register
         BRAS  R14,DXDW1000        R1 Register Used to a Decimal Format
         MVI   0(R4),C','          Insert Comma Delimiter After Operand
         LA    R4,1(,R4)           Increment to the Next Operand Field
DXM57200 DS    0H
         CLC   OP@MCHCD,=XL2'EE00' This for a Perform Locked Operation?
         BRE   DXM57300            Yes => R3 Mnemonic Position Altered
         LGR   R1,R6               R3 Register Operand to Work Register
         BRAS  R14,DXDW1000        R3 Register Used to a Decimal Format
         MVI   0(R4),C','          Insert Comma Delimiter After Operand
         LA    R4,1(,R4)           Increment to the D2 Operand Field
DXM57300 DS    0H
         CVD   R0,DXMOPWRK         12-bit Displacement to Decimal Form
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit D2 Displacement to Character
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of D2 Displacement
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              12-bit D2 Displacement to Retrn Area
         LA    R4,1(R2,R4)         Increment Past D2 Displacement Value
         MVI   0(R4),C'('          Insert Left Parand After Operand
         LA    R4,1(,R4)           Increment to B2 Base Register Field
DXM57400 DS    0H
         LGR   R1,R15              B2 Register Operand to Work Register
         BRAS  R14,DXDW1000        B2 Register Used to a Decimal Format
         MVI   0(R4),C')'          Closing Parenthesis for B2 Operand
         MVI   1(R4),C','          Insert Comma Delimiter After Operand
         LA    R4,2(,R4)           Increment to the Next Operand Field
DXM57500 DS    0H
         CLC   OP@MCHCD,=XL2'EE00' This for a Perform Locked Operation?
         BRNE  DXM57600            No  => Then Process D4 Operand Field
         LGR   R1,R6               R3 Register Operand to Work Register
         BRAS  R14,DXDW1000        R3 Register Used to a Decimal Format
         MVI   0(R4),C','          Insert Comma Delimiter After Operand
         LA    R4,1(,R4)           Increment to the D4 Operand Field
DXM57600 DS    0H
         SLGR  R15,R15             Clear to Hold the D4 Operand Value
         LLGH  R0,DXMINSTR+4       Get B4 and D4 Operands in Instructn
         SRLG  R15,R0,12 Bits      Isolate B4 Operand in Work Register
         NILL  R0,(X'0FFF')        Drop B4 so only the D4 Operand Value
         CVD   R0,DXMOPWRK         12-bit Displacement to Decimal Form
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit D4 Displacement to Character
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of D4 Displacement
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              12-bit D4 Displacement to Retrn Area
         LA    R4,1(R2,R4)         Increment Past D4 Displacement Value
         MVI   0(R4),C'('          Insert Left Parand After Operand
         LA    R4,1(,R4)           Increment to D4 Base Register Field
DXM57700 DS    0H
         LGR   R1,R15              B4 Register Operand to Work Register
         BRAS  R14,DXDW1000        B4 Register Used to a Decimal Format
         MVI   0(R4),C')'          Closing Parenthesis for B4 Operand
         BRU   DXMCEXIT            Done with SS-e, Branch to Exit
*
*+-------------------------------------------------------------------+*
*| Perform processing for the type SSE instruction format. The type  |*
*| SS-d is a storage-and-storage operation with a one-byte op-code   |*
*| field and implied register operands.                              |*
*|                                                                   |*
*| Instruction Group SSE                                             |*
*| ---------------------                                             |*
*|  LASP  MVCDK  MVCSK  STRAG  TPROT                                 |*
*|                                                                   |*
*| SSE                                                               |*
*| D1(B1),D2(B2)                                                     |*
*| +-------------------------------------+                           |*
*| |  Op Code   | B1 | D1   | B2 | D2    |                           |*
*| +-------------------------------------+                           |*
*|  0            16   20     32   36    47                           |*
*+-------------------------------------------------------------------+*
*
DXM59000 DS    0H
         LG    R4,DXMRTNI@         Address of Area to Return Instructn
         SLGR  R15,R15             Clear to Hold the D1 Operand Value
         LLGH  R0,DXMINSTR+2       Get B1 and D1 Operands in Instructn
         SRLG  R15,R0,12 Bits      Isolate B1 Operand in Work Register
         NILL  R0,(X'0FFF')        Drop B1 so only the D1 Operand Value
DXM59100 DS    0H
         CVD   R0,DXMOPWRK         12-bit Displacement to Decimal Form
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit D1 Displacement to Character
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of D1 Displacement
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              12-bit D1 Displacement to Retrn Area
         LA    R4,1(R2,R4)         Increment Past D1 Displacement Value
         MVI   0(R4),C'('          Insert Left Parand After Operand
         LA    R4,1(,R4)           Increment to B1 Base Register Field
DXM59200 DS    0H
         LGR   R1,R15              B1 Register Operand to Work Register
         BRAS  R14,DXDW1000        B1 Register Used to a Decimal Format
         MVI   0(R4),C')'          Closing Parenthesis for B1 Operand
         MVI   1(R4),C','          Insert Comma Delimiter After Operand
         LA    R4,2(,R4)           Increment to the D2 Operand Field
DXM59300 DS    0H
         SLGR  R15,R15             Clear to Hold the D2 Operand Value
         LLGH  R0,DXMINSTR+4       Get B2 and D2 Operands in Instructn
         SRLG  R15,R0,12 Bits      Isolate B2 Operand in Work Register
         NILL  R0,(X'0FFF')        Drop B2 so only the D2 Operand Value
         CVD   R0,DXMOPWRK         12-bit Displacement to Decimal Form
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit D2 Displacement to Character
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of D2 Displacement
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              12-bit D2 Displacement to Retrn Area
         LA    R4,1(R2,R4)         Increment Past D2 Displacement Value
         MVI   0(R4),C'('          Insert Left Parand After Operand
         LA    R4,1(,R4)           Increment to B2 Base Register Field
DXM59400 DS    0H
         LGR   R1,R15              B1 Register Operand to Work Register
         BRAS  R14,DXDW1000        B1 Register Used to a Decimal Format
         MVI   0(R4),C')'          Closing Parenthesis for B2 Operand
         BRU   DXMCEXIT            Done with SSE Format, Branch to Exit
*
*+-------------------------------------------------------------------+*
*| Perform processing for the type SSF instruction format. The type  |*
*| SSF is a storage-and-storage operation with an extended op-code   |*
*| and an additional register. The SSF format type has two separate  |*
*| assembler language syntax variations.                             |*
*|                                                                   |*
*| Instruction Group SSF                                             |*
*| ---------------------                                             |*
*|  CSST  ECTG  LPD  LPDG  MVCOS                                     |*
*|                                                                   |*
*| SSF                                                               |*
*| R3,D1(B1),D2(B2)  /  D1(B1),D2(B2),R3                             |*
*| +---------------------------------------+                         |*
*| |Op Code| R3 | Op | B1 | D1  | B2 | D2  |                         |*
*| +---------------------------------------+                         |*
*|  0       8    12   16   20    32   36  47                         |*
*+-------------------------------------------------------------------+*
*
DXM61000 DS    0H
         LLGC  R6,DXMINSTR+1       Get R3 Register Operand in Instructn
         SRLG  R6,R6,4 Bits        Isolate Just the R3 Register Operand
         SLGR  R15,R15             Clear to Hold the D1 Operand Value
         LLGH  R0,DXMINSTR+2       Get B1 and D1 Operands in Instructn
         SRLG  R15,R0,12 Bits      Isolate B1 Operand in Work Register
         NILL  R0,(X'0FFF')        Drop B1 so only the D1 Operand Value
         LLGT  R1,=A(DXM$PAIR)     Address of the Register Pair Table
         LA    R4,L'DXM$PAIR       Len of Each Register Use Table Entry
         LLGF  R5,=A(DXM$PAIR+((DXM$RTNO*L'DXM$PAIR)-L'DXM$PAIR))
DXM61100 DS    0H
         LLGC  R2,0(,R1)           Get Bit Indicator From Reg Pair Tble
         TM    OP@REGEO,(0)        Indicated Target of the Execute
         EX    R2,*-4              Instructn Reg Attribute Match Table?
         BRO   DXM61200            Yes => Instruction has Register Pair
         BRXLG R1,R4,DXM61100      No  => Loop to Check Next Pair Type
         BRU   DXM61400            Instruction Uses No Register Pair(s)
DXM61200 DS    0H
         ICM   R2,B'0011',DXM$R1LN+DXM$R2LN*14(R1) Branch Location
         BRZ   DXM61400            No  => Then Uses No Register Pair(s)
         LLGT  R1,=A(DXMC0000)     Base Address to Calculate the Offset
         LA    R14,0(R2,R1)        Add Offset to Base for Branch Addr
         BR    R14                 Branch Based on Register Attributes
DXM61300 DS    0H
         TM    OP@MODES,OP@R3EVN   Is R3 Operand Required to Be Even?
         BRZ   DXM61400            No  => Branch If R3 Not Required
         TM    DXMINSTR+1,X'10'    Is the R3 an Even Numbered Register?
         BRZ   DXM61400            Yes => Branch to Process Instruction
         LA    R15,8               No  => Indicate Validity Check Error
         ST    R15,DXMRETCD        Set Highest Generated Return Code
         BRU   DXMCEXIT            Branch to Exit on Fail Validity Chck
DXM61400 DS    0H
         LG    R4,DXMRTNI@         Address of Area to Return Instructn
         CLC   OP@MCHCD,=XL2'C840' This for a Load Pair Disjoint?
         BRE   DXM61500            Yes => R3 Mnemonic Position Altered
         CLC   OP@MCHCD,=XL2'C850' This for Load Pair Disjoint Grande?
         BRE   DXM61500            Yes => R3 Mnemonic Position Altered
         BRU   DXM61600            No  => Branch to Process for D1/B1
DXM61500 DS    0H
         LGR   R1,R6               R3 Register Operand to Work Register
         BRAS  R14,DXDW1000        R3 Register Used to a Decimal Format
         MVI   0(R4),C','          Insert Comma Delimiter After Operand
         LA    R4,1(,R4)           Increment to the Next Operand Field
DXM61600 DS    0H
         CVD   R0,DXMOPWRK         12-bit Displacement to Decimal Form
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit D1 Displacement to Character
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of D1 Displacement
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              12-bit D1 Displacement to Retrn Area
         LA    R4,1(R2,R4)         Increment Past D1 Displacement Value
         MVI   0(R4),C'('          Insert Left Parand After Operand
         LA    R4,1(,R4)           Increment to B1 Base Register Field
DXM61700 DS    0H
         LGR   R1,R15              B1 Register Operand to Work Register
         BRAS  R14,DXDW1000        B1 Register Used to a Decimal Format
         MVI   0(R4),C')'          Closing Parenthesis for B1 Operand
         MVI   1(R4),C','          Insert Comma Delimiter After Operand
         LA    R4,2(,R4)           Increment to the D2 Operand Field
DXM61800 DS    0H
         SLGR  R15,R15             Clear to Hold the D2 Operand Value
         LLGH  R0,DXMINSTR+4       Get B2 and D2 Operands in Instructn
         SRLG  R15,R0,12 Bits      Isolate B2 Operand in Work Register
         NILL  R0,(X'0FFF')        Drop B2 so only the D2 Operand Value
         CVD   R0,DXMOPWRK         12-bit Displacement to Decimal Form
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit D2 Displacement to Character
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of D2 Displacement
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              12-bit D2 Displacement to Retrn Area
         LA    R4,1(R2,R4)         Increment Past D2 Displacement Value
         MVI   0(R4),C'('          Insert Left Parand After Operand
         LA    R4,1(,R4)           Increment to B2 Base Register Field
DXM61900 DS    0H
         LGR   R1,R15              B2 Register Operand to Work Register
         BRAS  R14,DXDW1000        B2 Register Used to a Decimal Format
         MVI   0(R4),C')'          Closing Parenthesis for B2 Operand
         LA    R4,1(,R4)           Increment to the R3 Register Field
DXM62000 DS    0H
         CLC   OP@MCHCD,=XL2'C840' This for a Load Pair Disjoint?
         BRE   DXM62200            Yes => R3 Mnemonic Position Done
         CLC   OP@MCHCD,=XL2'C850' This for Load Pair Disjoint Grande?
         BRE   DXM62200            Yes => R3 Mnemonic Position Done
DXM62100 DS    0H
         MVI   0(R4),C','          Insert Comma Delimiter for the R3
         LA    R4,1(,R4)           Increment to the R3 Operand Field
         LGR   R1,R6               R3 Register Operand to Work Register
         BRAS  R14,DXDW1000        R3 Register Used to a Decimal Format
DXM62200 DS    0H
         BRU   DXMCEXIT            Done with SSF Format, Branch to Exit
*
*+-------------------------------------------------------------------+*
*|   Return to Caller                                                |*
*+-------------------------------------------------------------------+*
*
DXMCEXIT DS    0H
         LLGF  R15,DXMRETCD        Set the Return Code
         LPGMEXIT RC=DXMRETCD      Define Program Exit Protocol
*
***********************************************************************
**************************+-----------------+**************************
**************************| D X D W 1 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|          P r o c e s s   R e g i s t e r   O p e r a n d          |*
*+-------------------------------------------------------------------+*
*|                                                                   |*
*|SUBROUTINE NAME: DXDW1000                                          |*
*|                                                                   |*
*|FUNCTION: Process the Register Operand to Decimal Format and Move  |*
*|          to Work Area                                             |*
*--------------------------------------------------------------------*
*
DXDW1000 LPGMSUBE                  Set Subroutine Entry Protocol
         CVD   R1,DXMOPWRK         Register Operand to a Decimal Format
         MVC   DXMDECIM,DXMPTRN1   Copy in the Number Editing Pattern
         LA    R1,DXMFORC1         Load 1st Forced Result Char Location
         EDMK  DXMDECIM,DXMOPWRK+4 Edit Operand Value to Character Form
         LA    R2,DXMDECIM+L'DXMDECIM-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of Operand Value
         MVI   0(R4),C'R'          To Designate Operand is for Register
         LA    R4,1(,R4)           Increment Past the Reg Designater
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Copy Register Number to Return Area
         LA    R4,1(R2,R4)         Increment Past the Register Operand
DXDW2000 DS    0H
         LPGMSUBX                  Return to Caller of This Subroutine
*
*+-------------------------------------------------------------------+*
*|   Definitions for Constants                                       |*
*+-------------------------------------------------------------------+*
*
DXMPTRN1 DC    XL8'4020202020202120'  To Use as Pattern for Editing
DXMPTRN2 DC    XL16'40202020202020202020202020202120'  Edit Pattern
         DS    0D                  Set for Doubleword Alignnent
DXM$X1LN EQU   1                   Length for the Bit Mask Value Entry
DXM$X2LN EQU   2                   Len for the Extended Mnemonic Suffix
DXM$X3LN EQU   16                  Len of Extended Mnemonic Description
DXMXTEND DS    0CL(DXM$X1LN+DXM$X2LN+DXM$X3LN) Extended Mnemonics Table
DXMXT$HI DC    XL(DXM$X1LN)'02',CL(DXM$X2LN)'H',CL(DXM$X3LN)'High'
DXMXTLOW DC    XL(DXM$X1LN)'04',CL(DXM$X2LN)'L',CL(DXM$X3LN)'Low'
DXMXTNEQ DC    XL(DXM$X1LN)'06',CL(DXM$X2LN)'NE',CL(DXM$X3LN)'Not EqualX
               '
DXMXT$EQ DC    XL(DXM$X1LN)'08',CL(DXM$X2LN)'E',CL(DXM$X3LN)'Equal'
DXMXTNLW DC    XL(DXM$X1LN)'0A',CL(DXM$X2LN)'NL',CL(DXM$X3LN)'Not Low'
DXMXTNHI DC    XL(DXM$X1LN)'0C',CL(DXM$X2LN)'NH',CL(DXM$X3LN)'Not High'
DXM$XTLN EQU   *-DXMXTEND          Length of Extended Mnemonics Table
DXM$XTNO EQU   (DXM$XTLN)/L'DXMXTEND Number of Entries in Mnemonic Tble
DXM$R1LN EQU   1                   Length for the Bit Mask Value Entry
DXM$R2LN EQU   2                   Length for the Offset Entry
DXM$PAIR DS    0CL(DXM$F2PR-DXM$F1PR)   Register Use Instruction Table
DXM$F1PR DC    XL(DXM$R1LN)'80' .....R1 Floating Point Register Pair
         DC    AL(DXM$R2LN)(DXM11300-DXMC0000) ...Format RR
         DC    AL(DXM$R2LN)(DXM14400-DXMC0000) ...Format RRE
         DC    AL(DXM$R2LN)(DXM13400-DXMC0000) ...Format RRD
         DC    AL(DXM$R2LN)(*-*,*-*,*-*)
         DC    AL(DXM$R2LN)(DXM21500-DXMC0000) ...Format RRf-d
         DC    AL(DXM$R2LN)(DXM23500-DXMC0000) ...Format RRf-e
         DC    AL(DXM$R2LN)(*-*,*-*)
         DC    AL(DXM$R2LN)(DXM34300-DXMC0000) ...Format RX-a
         DC    AL(DXM$R2LN)(DXM35400-DXMC0000) ...Format RXE
         DC    AL(DXM$R2LN)(DXM37400-DXMC0000) ...Format RXF
         DC    AL(DXM$R2LN)(*-*,*-*)
DXM$F2PR DC    XL(DXM$R1LN)'40'   ...R2 Floating Point Register Pair
         DC    AL(DXM$R2LN)(DXM11400-DXMC0000) ...Format RR
         DC    AL(DXM$R2LN)(DXM14500-DXMC0000) ...Format RRE
         DC    AL(DXM$R2LN)(*-*,*-*,*-*,*-*,*-*)
         DC    AL(DXM$R2LN)(DXM23700-DXMC0000) ...Format RRf-e
         DC    AL(DXM$R2LN)(*-*,*-*,*-*,*-*,*-*,*-*,*-*)
DXM$F1F2 DC    XL(DXM$R1LN)'20'   ...R1+R2 Floating Point Register Pair
         DC    AL(DXM$R2LN)(DXM11500-DXMC0000) ...Format RR
         DC    AL(DXM$R2LN)(DXM14600-DXMC0000) ...Format RRE
         DC    AL(DXM$R2LN)(*-*,*-*)
         DC    AL(DXM$R2LN)(DXM17900-DXMC0000) ...Format RRF-b
         DC    AL(DXM$R2LN)(*-*,*-*)           ...Format RRF-c,d
         DC    AL(DXM$R2LN)(DXM23900-DXMC0000) ...Format RRf-e
         DC    AL(DXM$R2LN)(*-*,*-*,*-*,*-*)
         DC    AL(DXM$R2LN)(DXM37500-DXMC0000) ...Format RXF
         DC    AL(DXM$R2LN)(*-*,*-*)
DXM$1P2E DC    XL(DXM$R1LN)'10'   ...R1 Flt Pnt Reg Pair + R2 Even/Odd
         DC    AL(DXM$R2LN)(DXM11900-DXMC0000) ...Format RR
         DC    AL(DXM$R2LN)(DXM14800-DXMC0000) ...Format RRE
         DC    AL(DXM$R2LN)(*-*,*-*,*-*,*-*)
         DC    AL(DXM$R2LN)(DXM21700-DXMC0000) ...Format RRf-d
         DC    AL(DXM$R2LN)(*-*,*-*,*-*,*-*,*-*,*-*)
         DC    AL(DXM$R2LN)(*-*,*-*)
DXM$FPAL DC    XL(DXM$R1LN)'08'   ...All Regs Flt Point Register Pairs
         DC    AL(DXM$R2LN)(DXM11900-DXMC0000) ...Format RR
         DC    AL(DXM$R2LN)(*-*,*-*)
         DC    AL(DXM$R2LN)(DXM16500-DXMC0000) ...Format RRF-a
         DC    AL(DXM$R2LN)(DXM18100-DXMC0000) ...Format RRF-b
         DC    AL(DXM$R2LN)(*-*,*-*)
         DC    AL(DXM$R2LN)(DXM24100-DXMC0000) ...Format RRf-e
         DC    AL(DXM$R2LN)(*-*,*-*,*-*,*-*,*-*,*-*,*-*)
DXM$R1R2 DC    XL(DXM$R1LN)'04'   ...R1+R2 GP-Reg Even/Odd Reg Pairs
         DC    AL(DXM$R2LN)(DXM11700-DXMC0000) ...Format RR
         DC    AL(DXM$R2LN)(DXM15000-DXMC0000) ...Format RRE
         DC    AL(DXM$R2LN)(*-*,*-*)
         DC    AL(DXM$R2LN)(DXM18300-DXMC0000) ...Format RRF-b
         DC    AL(DXM$R2LN)(DXM19500-DXMC0000) ...Format RRF-c
         DC    AL(DXM$R2LN)(*-*,*-*)
         DC    AL(DXM$R2LN)(DXM26700-DXMC0000) ...Format RS-a
         DC    AL(DXM$R2LN)(DXM30300-DXMC0000) ...Format RSY-a
         DC    AL(DXM$R2LN)(*-*,*-*,*-*,*-*,*-*)
DXM$R2EO DC    XL(DXM$R1LN)'02'   ...R2 GP-Register Even/Odd Reg Pair
         DC    AL(DXM$R2LN)(DXM11900-DXMC0000) ...Format RR
         DC    AL(DXM$R2LN)(DXM15300-DXMC0000) ...Format RRE
         DC    AL(DXM$R2LN)(*-*,*-*,*-*,*-*,*-*,*-*,*-*)
         DC    AL(DXM$R2LN)(*-*,*-*,*-*,*-*,*-*,*-*)
DXM$R1EO DC    XL(DXM$R1LN)'01'   ...R1/R3 GP-Register Even/Odd Pair
         DC    AL(DXM$R2LN)(DXM11800-DXMC0000) ...Format RR
         DC    AL(DXM$R2LN)(DXM15500-DXMC0000) ...Format RRE
         DC    AL(DXM$R2LN)(*-*,*-*,*-*)
         DC    AL(DXM$R2LN)(DXM19700-DXMC0000) ...Format RRF-c
         DC    AL(DXM$R2LN)(*-*,*-*)
         DC    AL(DXM$R2LN)(DXM26800-DXMC0000) ...Format RS-a
         DC    AL(DXM$R2LN)(*-*)
         DC    AL(DXM$R2LN)(DXM34400-DXMC0000) ...Format RX-a
         DC    AL(DXM$R2LN)(*-*,*-*)           ...Format RXE
         DC    AL(DXM$R2LN)(DXM39300-DXMC0000) ...Format RXY-a
         DC    AL(DXM$R2LN)(DXM61300-DXMC0000) ...Format SSF
DXM$RTLN EQU   *-DXM$PAIR          Length of Register Use Table
DXM$RTNO EQU   (DXM$RTLN)/L'DXM$PAIR Number of Entries in Register Tble
DXM$RTSL EQU   (DXM$RTLN)/DXM$RTNO   Register Table Section Length
DXMFLTPT DC    X'0000FFFF0000FFFF0000FFFF0000FFFF' Float-Pnt Reg Pairs
DXMFPBXF DC    X'000002000000000008090A0B0C0D0E0F' FP Rounding Bit Mask
DXMFPBNX DC    X'000002030000000008090A0B0C0D0E0F' FP Rounding Bit Mask
DXMASCEM DC    X'000000000005060708090A0B0C0D0E0F' ASC Element Bit Mask
DXM$BINX EQU   2                   Length for the Binary Mask Entry Id
DXM$BINM EQU   4                   Length for the Binary Mask Entry
DXMBINRY DC    0CL(DXM$BINX+DXM$BINM)  To Correspond to Byte Positions
         DC    Y(0),CL(DXM$BINM)'0000',Y(1),CL(DXM$BINM)'0001'
         DC    Y(2),CL(DXM$BINM)'0010',Y(3),CL(DXM$BINM)'0011'
         DC    Y(4),CL(DXM$BINM)'0100',Y(5),CL(DXM$BINM)'0101'
         DC    Y(6),CL(DXM$BINM)'0110',Y(7),CL(DXM$BINM)'0111'
         DC    Y(8),CL(DXM$BINM)'1000',Y(9),CL(DXM$BINM)'1001'
         DC    Y(10),CL(DXM$BINM)'1010',Y(11),CL(DXM$BINM)'1011'
         DC    Y(12),CL(DXM$BINM)'1100',Y(13),CL(DXM$BINM)'1101'
         DC    Y(14),CL(DXM$BINM)'1110',Y(15),CL(DXM$BINM)'1111'
DXM$BINL EQU   *-DXMBINRY          Length of Byte Position Mask Table
DXM$BMNO EQU   (DXM$BINL)/L'DXMBINRY Number of Entries in Mask Table
*
*+-------------------------------------------------------------------+*
*|    Program RENT Work Area                                         |*
*+-------------------------------------------------------------------+*
*
         LCA   DEFINE              Define the Program RENT Work Area
*
DXMWORKD DS    10D                 General Purpose Work Area
DXMPLIST DS    20FD                CALL Parameter List
DXMPARM@ DS    0FD                 Save Area for Passed Parameters
DXMRTNI@ DS    AD                  Addr of Area to Return Instruction
DXMMCHI@ DS    AD                  Addr of Machine Instructn Tble Entry
DXMINST@ DS    AD                  Address of the Machine Instruction
DXMXTND@ DS    AD                  Address of Area to Return Mnemonic
DXMPREV@ DS    AD                  Address of Area for Previous Op-Code
DXMRETCD DS    F                   Save Area for the Return Code
DXMOPCDE DS    H                   Save Area for Instruction Op Code
DXMOPMNM DS    XL1                 Save Area for the Mnemonic Indicator
DXMOPCLN DS    XL1                 Save Area for the Op Code Length
DXMIPWRK DS    XL16                Work Area for Unpacking Instruction
         DS    XL1                 Slack for Reverse of Low Order Byte
DXMINSTR DS    D                   Work Area for Machine Instruction
DXMOPWRK DS    2D                  Area to Convert Operands to Decimal
DXMDECIM DS    CL(L'DXMPTRN1)      Work Area for Editing Decimal Values
DXMFORC1 EQU   *-1                 First Forced Result Char Location
DXMDECI2 DS    CL(L'DXMPTRN2)      Work Area for Editing Decimal Values
DXMFORC2 EQU   *-1                 First Forced Result Char Location
DXMLINE  DS    0CL133              Output Print Line Area
DXMCCNTL DS    CL1                 Carriage Control Character
DXMOLINE DS    CL132               Output Record Print Area
*
         LCA   DEFEND              Define End of Program RENT Work Area
*
***********************************************************************
*            End of Disassemble Machine Instruction Process           *
***********************************************************************
         EJECT ,
***********************************************************************
**************************+-----------------+**************************
**************************| D R E G 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|       D e t e r m i n e   R e g i s t e r   C o n t e n t s       |*
*+-------------------------------------------------------------------+*
* PROGRAM NAME:    DREG0000                                           *
*                                                                     *
* FUNCTION:        Determine Register Contents                        *
*                                                                     *
*                  This routine will process and display the general  *
*                  purpose registers and access registers at entry to *
*                  abend. The register contents are obtained from the *
*                  System Diagnostic Work Area where the address      *
*                  pointing to the SDWA was passed to this program.   *
*                  In addition, the value in each general purpose     *
*                  register at time of abend is analyzed, and a       *
*                  formatted register summary report is created. The  *
*                  report indicates if the register value is pointing *
*                  to a load module, and if so the module name and    *
*                  offset is displayed. If the register value is      *
*                  determined to be pointing to a storage area, the   *
*                  subpool number, storage key, the TCB associated    *
*                  with the storage, and the addressable range of the *
*                  storage area from the address in the register is   *
*                  displayed. Also, any general purpose register used *
*                  as a designated, index, base, or implied register  *
*                  in the abending instruction is identifed in the    *
*                  register summary report.                           *
*                                                                     *
* For example:                                                        *
*                                                                     *
*General Purpose Registers R0-R15 at Entry to Abend:                  *
*  0-3   0000000098988AB8  0000000000000001  0000004A80000800  0000000*
*  4-7   0000000000007FF4  0000000000000189  FFFFFFFFFFFFFE78  0000000*
*  8-11  0000000018908B28  000000000004BB38  000000000004AB38  0000000*
*  12-15 0000000018900CC4  0000000000007000  0000000018913214  0000000*
*Access Registers:                                                    *
*  0-3   984AF47A  00000000  00000000  00000000                       *
*  4-7   00000000  00000000  00000000  00000000                       *
*  8-11  00000000  00000000  00000000  00000000                       *
*  12-15 00000000  00000000  00000000  00000000                       *
*                                                                     *
*-General Purpose Register Summary-                                   *
*                                                                     *
*  R0:  0000000098988AB8 Load Module/Csect  IGGCSI00+(000000)  Decimal*
*D-R1:  0000000000000001 Allocated storage  (PSA+PSAE+PSAX)    Decimal*
*B-R2:  0000004A80000800 Allocated storage  Memory object      Decimal*
*X-R3:  00000000FAC00000 (Invalid Storage)  0C4 if referenced  Decimal*
*  R4:  0000000000007FF4 Allocated storage  Subpool=003 Key=8  TCB=008*
*  R5:  0000000000000189 Allocated storage  (PSA+PSAE+PSAX)    Decimal*
*  R6:  FFFFFFFFFFFFFE78 (No memory object or a guard area)    Decimal*
*  R7:  0000000018909B28 Load Module/Csect  SVLTEST7+(008E70)  Decimal*
*  R8:  0000000018908B28 Load Module/Csect  SVLTEST7+(007E70)  Decimal*
*  R9:  000000000004BB38 Free space storage Subpool=000 Key=8  TCB=008*
*  R10: 000000000004AB38 Allocated storage  Subpool=003 Key=8  TCB=008*
*  R11: 0000000018901CC4 Load Module/Csect  SVLTEST7+(00100C)  Decimal*
*  R12: 0000000018900CC4 Load Module/Csect  SVLTEST7+(00000C)  Decimal*
*  R13: 0000000000007000 Allocated storage  Subpool=003 Key=8  TCB=008*
*  R14: 0000000018913214 Load Module/Csect  SVLTEST7+(01255C)  Decimal*
*  R15: 0000000083358BC0 Load Module/Csect  IEFDB475+(000BC0)  Decimal*
*                                                                     *
*  '?-Rx:' Used as a designated (D), index (X), base (B), odd (O) of  *
*          an even/odd pair, or hardware implied (H) register in      *
*          abending instruction STH                                   *
*                                                                     *
* INPUT REGS:      R1 => Standard O/S Parameter List                  *
*                                                                     *
* INPUT DATA:      Parm1: Pointer to Field for Addr of Target Instruct*
*                  Parm2: Address to the Address of Entry in Machine  *
*                         Instruction Table                           *
*                  Parm3: Address of Amode at Time of Abend           *
*                  Parm4: Address of Abending Instruction             *
*                  Parm5: Address of System Diagnostic Work Area      *
*                  Parm6: Address of LGRWK2II Logger Work Area        *
*                  Parm7: Addr of Common Constants and Routines Area  *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY, AC=0                          *
*                                                                     *
* CALLING PROGRAM: DSWA0000 - SDWA Diagnostic Information Program     *
*                                                                     *
* CALLED PROGRAMS  LNME0000 - Logger Services Program to Resolve an   *
*                             Address to a Load Module Name           *
*                  DRVS0000 - Logger Services Program to Determine    *
*                             Register Contents Pointing to Virtual   *
*                             Storage Areas.                          *
*                  DRUS0000 - Logger Services Program to Determine    *
*                             Registers Used in Abending Instruction  *
*                                                                     *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                  04 - Warning                                       *
*                  08 - Error                                         *
*                  12 - Severe Error - Exit This Routine              *
*                                                                     *
***********************************************************************
*
DREG0000 LPGMNTRY TYPE=SUB,        Define As A Sub-Program Entry       X
               BASE=(12,11),       Establish Base Registers            X
               AMOD=64,RMOD=ANY,   Addressing and Residency Modes      X
               LCAPFX=DRG,         Establish LCA Prefix for This RSECT X
               LOG=OFF,            Always Turn Logging 'Off' in Logger!X
               LINKRTRN=BSM,       Define Return Linkage Instruction   X
               COPY@RT=YES         To Generate a Copyright Statement
         USING COM_DATA,RCOMM      Addressability to Common Data Area
         USING LGRWK2II,RLGW       Establish Addressability to LGRWK2II
         USING SDWA,RSDW           Establish Addressability to SDWA
         USING IHADCB,LGWODCB      Establish Addressability to DCB
         LMG   R4,R10,0(R1)        Load the Parameter Area Addresses
         STMG  R4,R7,DRGPARM@      Save Contents of Passed Parameters
         XC    DRGRETCD,DRGRETCD   Initialize the Return Code
*
*+-------------------------------------------------------------------+*
*|  Print General Purpose Registers Header Line                      |*
*|                                                                   |*
*|  General Purpose Registers R0-R15 at Entry to Abend:              |*
*+-------------------------------------------------------------------+*
*
DREG0100 DS    0H
         MVI   DRGLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DRGLINE+1(L'DRGLINE-1),DRGLINE ...Propogate the Blank
         MVC   DRGOLINE(PRNTLEN),DRGDTL05  Statement for the GPR's Line
         MVC   DRGWTOMG(COMWTOL),COMWTO .Fill WTO Remote Parameter List
         MVC   DRGMSGTX,DRGOLINE   Copy the Message to WTO Buffer Area
         MVC   DRGMSG,=Y(L'DRGMSGTX) ..Indicate Length of Text Message
DREG0200 DS    0H
         LA    R4,DRGMSG           Obtain Address of Message Text Area
         WTO   TEXT=(R4),          Write PSW Info Line to MVS Console  X
               MF=(E,DRGWTOMG)     Remote Program Parameter List
DREG0300 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DREGEXIT            No  => Then Bypass Print Output
DREG0400 DS    0H
         BRAS  R14,DREGP100        Print GPR Header Line to //LGRECOUT
*
*+-------------------------------------------------------------------+*
*|  Format And Print General Purpose Registers R0 - R3 Detail Line   |*
*|                                                                   |*
*|  0-3   0000000100100000  0000000000007310  0000000000011DB0  00000|*
*+-------------------------------------------------------------------+*
*
DREG0500 DS    0H
         MVI   DRGLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DRGLINE+1(L'DRGLINE-1),DRGLINE ...Propogate the Blank
         LLGT  R4,SDWAXPAD         Addr of SDWA Extension Pointers Area
         USING SDWAPTRS,R4         Addressability to Extension Ptr Area
         ICM   R4,B'1111',SDWAXEME Do We Have a Pointer to 64-bit Info?
         BRZ   DREG0600            No  => Then Pull 31-bit Registers
         USING SDWARC4,R4          Addressability to 64-bit Info Area
         MVC   DRGREGS(DRGEGLEN),SDWAG64 Get 64-bit Reg R0-R15 at Abend
         BRU   DREG0800            Branch to Process Register Values
         DROP  R4                  Remove Listed Register as Base Reg
DREG0600 DS    0H
         LA    R2,DRGREGS          Get Starting Addr of Receiving Area
         LA    R3,SDWAGRSV         Get Starting Addr Reg Values in SDWA
         LA    R4,L'SDWAGR00       Indicate Length of a Register Entry
         LA    R5,SDWAGR15-L'SDWAGR15 Setup For SDWA Registers R0 - R15
DREG0700 DS    0H
         LLGF  R1,0(,R3)           Get the 31-bit SDWA Register Value
         STG   R1,0(,R2)           Copy the Register Value at Abend
         LA    R2,8(,R2)           Bump to the Next Receiving Field
         BRXLG R3,R4,DREG0700      Bump and Loop to Next SDWA Register
DREG0800 DS    0H
         MVC   DRGSAVER(DRGSALEN),DRGREGS ..Save Regs From Receive Area
         MVC   DRGOLINE+2(3),=C'0-3' Indicate Registers to Set for Prnt
         LA    R2,DRGOLINE+8       Position Start of Register Values
         LA    R3,DRGREGS          Get Starting Address of Reg Values
         LA    R4,L'DRGREGS        Indicate Length of Register Entry
         LA    R5,DRGREGS+(DRGEGLEN/4)-L'DRGREGS  ...For Regs R0 - R3
DREG0900 DS    0H
         UNPK  DRGWRK16(9),0(5,R3) Obtain the High-Half Register Value
         UNPK  DRGWRK16+8(9),4(5,R3) Obtain the Low-Half Register Value
         TR    DRGWRK16,HEXCONV-C'0' Finalize Conversion to Zoned Char
         MVC   0(L'DRGWRK16,R2),DRGWRK16 .General Purpose Reg to Output
         LA    R2,18(,R2)          Increment to Next Register Field
         BRXLG R3,R4,DREG0900      Loop to Process the Next Register
DREG1000 DS    0H
         MVC   DRGWTOMG(COMWTOL),COMWTO .Fill WTO Remote Parameter List
         MVC   DRGMSGTX,DRGOLINE   Copy the Message to WTO Buffer Area
         MVC   DRGMSG,=Y(L'DRGMSGTX) ..Indicate Length of Text Message
         LA    R4,DRGMSG           Obtain Address of Message Text Area
         WTO   TEXT=(R4),          Write GPR Info Line to MVS Console  X
               MF=(E,DRGWTOMG)     Remote Program Parameter List
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DREGEXIT            No  => Then Bypass Print Output
DREG1100 DS    0H
         BRAS  R14,DREGP100        Print the GPR 0-3 Values to LGRECOUT
DREG1200 DS    0H
         MVI   DRGLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DRGLINE+1(L'DRGLINE-1),DRGLINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*|  Format And Print General Purpose Registers R4 - R7 Detail Line   |*
*|                                                                   |*
*|  4-7   0000000100000000  0000000000000000  0000000000000000  00000|*
*+-------------------------------------------------------------------+*
*
DREG1300 DS    0H
         MVC   DRGOLINE+2(3),=C'4-7' Indicate Registers to Set for Prnt
         LA    R2,DRGOLINE+8       Position Start of Register Values
         LA    R3,DRGREGS+(DRGEGLEN/4) ..Starting Address Points to R4
         LA    R4,L'DRGREGS        Indicate Length of Register Entry
         LA    R5,(DRGEGLEN/4)-L'DRGREGS(,R3)  ...For Regs R4 - R7
DREG1400 DS    0H
         UNPK  DRGWRK16(9),0(5,R3) Obtain the High-Half Register Value
         UNPK  DRGWRK16+8(9),4(5,R3) Obtain the Low-Half Register Value
         TR    DRGWRK16,HEXCONV-C'0' Finalize Conversion to Zoned Char
         MVC   0(L'DRGWRK16,R2),DRGWRK16 .General Purpose Reg to Output
         LA    R2,18(,R2)           Increment to Next Register Field
         BRXLG R3,R4,DREG1400       Loop to Process the Next Register
DREG1500 DS    0H
         MVC   DRGWTOMG(COMWTOL),COMWTO .Fill WTO Remote Parameter List
         MVC   DRGMSGTX,DRGOLINE   Copy the Message to WTO Buffer Area
         MVC   DRGMSG,=Y(L'DRGMSGTX) ..Indicate Length of Text Message
DREG1600 DS    0H
         LA    R4,DRGMSG           Obtain Address of Message Text Area
         WTO   TEXT=(R4),          Write GPR Info Line to MVS Console  X
               MF=(E,DRGWTOMG)     Remote Program Parameter List
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DREGEXIT            No  => Then Bypass Print Output
DREG1700 DS    0H
         BRAS  R14,DREGP100        Print GPR 4-7 Values to //LGRECOUT
DREG1800 DS    0H
         MVI   DRGLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DRGLINE+1(L'DRGLINE-1),DRGLINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*|  Format And Print General Purpose Registers R8 - R11 Detail Line  |*
*|                                                                   |*
*|  8-11  0000000018105488  0000000000012C40  0000000000011C40  00000|*
*+-------------------------------------------------------------------+*
*
DREG1900 DS    0H
         MVC   DRGOLINE+2(4),=C'8-11' Indicate Register Set for Prt Lne
         LA    R2,DRGOLINE+8       Position Start of Register Values
         LA    R3,DRGREGS+(DRGEGLEN/2) ..Starting Address Points to R8
         LA    R4,L'DRGREGS        Indicate Length of Register Entry
         LA    R5,(DRGEGLEN/4)-L'DRGREGS(,R3) ...For Regs R8 - R11
DREG2000 DS    0H
         UNPK  DRGWRK16(9),0(5,R3) Obtain the High-Half Register Value
         UNPK  DRGWRK16+8(9),4(5,R3) Obtain the Low-Half Register Value
         TR    DRGWRK16,HEXCONV-C'0' Finalize Conversion to Zoned Char
         MVC   0(L'DRGWRK16,R2),DRGWRK16 .General Purpose Reg to Output
         LA    R2,18(,R2)           Increment to Next Register Field
         BRXLG R3,R4,DREG2000       Loop to Process the Next Register
DREG2100 DS    0H
         MVC   DRGWTOMG(COMWTOL),COMWTO .Fill WTO Remote Parameter List
         MVC   DRGMSGTX,DRGOLINE   Copy the Message to WTO Buffer Area
         MVC   DRGMSG,=Y(L'DRGMSGTX) ..Indicate Length of Text Message
DREG2200 DS    0H
         LA    R4,DRGMSG           Obtain Address of Message Text Area
         WTO   TEXT=(R4),          Write GPR Info Line to MVS Console  X
               MF=(E,DRGWTOMG)     Remote Program Parameter List
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DREGEXIT            No  => Then Bypass Print Output
DREG2300 DS    0H
         BRAS  R14,DREGP100        Print GPR 8-11 Values to //LGRECOUT
DREG2400 DS    0H
         MVI   DRGLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DRGLINE+1(L'DRGLINE-1),DRGLINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*| Format And Print General Purpose Registers R12 - R15 Detail Line  |*
*|                                                                   |*
*| 12-15 00000000181008BC  0000000000007000  000000000000090E  000000|*
*+-------------------------------------------------------------------+*
*
DREG2500 DS    0H
         MVC   DRGOLINE+2(5),=C'12-15' Indicate Register Set for Prt Ln
         LA    R2,DRGOLINE+8       Position Start of Register Values
         LA    R3,DRGREGS+(DRGEGLEN/2+DRGEGLEN/4) Address Points to R12
         LA    R4,L'DRGREGS        Indicate Length of Register Entry
         LA    R5,(DRGEGLEN/4)-L'DRGREGS(,R3) ..For Registers R12 - R15
DREG2600 DS    0H
         UNPK  DRGWRK16(9),0(5,R3) Obtain the High-Half Register Value
         UNPK  DRGWRK16+8(9),4(5,R3) Obtain the Low-Half Register Value
         TR    DRGWRK16,HEXCONV-C'0' Finalize Conversion to Zoned Char
         MVC   0(L'DRGWRK16,R2),DRGWRK16 .General Purpose Reg to Output
         LA    R2,18(,R2)           Increment to Next Register Field
         BRXLG R3,R4,DREG2600       Loop to Process the Next Register
DREG2700 DS    0H
         MVC   DRGWTOMG(COMWTOL),COMWTO .Fill WTO Remote Parameter List
         MVC   DRGMSGTX,DRGOLINE   Copy the Message to WTO Buffer Area
         MVC   DRGMSG,=Y(L'DRGMSGTX) ..Indicate Length of Text Message
DREG2800 DS    0H
         LA    R4,DRGMSG           Obtain Address of Message Text Area
         WTO   TEXT=(R4),          Write GPR Info Line to MVS Console  X
               MF=(E,DRGWTOMG)     Remote Program Parameter List
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DREGEXIT            No  => Then Bypass Print Output
DREG2900 DS    0H
         BRAS  R14,DREGP100        Prnt GPR 12-15 Values to //LGRECOUT
DREG3000 DS    0H
         MVI   DRGLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DRGLINE+1(L'DRGLINE-1),DRGLINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*|  Format And Print Access Registers AR0 - AR3 Detail Line          |*
*|                                                                   |*
*|Access Registers:                                                  |*
*|  0-3   00000000  00000000  00000000  00000000                     |*
*+-------------------------------------------------------------------+*
*
DREG3100 DS    0H
         MVC   DRGOLINE(17),=CL17'Access Registers:' ..Access Registers
         MVC   DRGWTOMG(COMWTOL),COMWTO .Fill WTO Remote Parameter List
         MVC   DRGMSGTX,DRGOLINE   Copy the Message to WTO Buffer Area
         MVC   DRGMSG,=Y(L'DRGMSGTX) ..Indicate Length of Text Message
DREG3200 DS    0H
         LA    R4,DRGMSG           Obtain Address of Message Text Area
         WTO   TEXT=(R4),          Write Access Reg Info to MVS ConsoleX
               MF=(E,DRGWTOMG)     Remote Program Parameter List
DREG3300 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DREGEXIT            No  => Then Bypass Print Output
DREG3400 DS    0H
         BRAS  R14,DREGP100        Print Access Registers Header Line
DREG3500 DS    0H
         MVI   DRGLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DRGLINE+1(L'DRGLINE-1),DRGLINE ...Propogate the Blank
         LLGT  R14,SDWAXPAD        Addr of SDWA Extension Pointers Area
         ICM   R14,B'1111',SDWASRVP-SDWAPTRS(R14) ..SDWA 1st Extension?
         BRZ   DREGEXIT            No  => Then Branch to Exit Routine
         USING SDWARC1,R14         Addressability-Recordable Extension
DREG3600 DS    0H
         LA    R2,DRGREGS          Get Starting Addr of Receiving Area
         LA    R3,SDWAARER         Get Starting Addr Access Reg Values
         LA    R4,L'SDWAARE0       Indicate Length of a Register Entry
         LA    R5,SDWAAREF         Point to Start of Last Entry (AR15)
         DROP  R14                 Remove Listed Register as Base Reg
DREG3700 DS    0H
         LLGF  R1,0(,R3)           Get the 31-bit Access Register Value
         ST    R1,0(,R2)           Save the Register Value at Abend
         LA    R2,0(R4,R2)         Bump to the Next Receiving Field
         BRXLG R3,R4,DREG3700      Loop for the Next Access Register
DREG3800 DS    0H
         MVC   DRGOLINE+2(3),=C'0-3' Indicate Registers to Set for Prnt
         LA    R2,DRGOLINE+8       Position Start of Register Values
         LA    R3,DRGREGS          Get Starting Address of Reg Values
         LA    R4,L'DRGREGS/2      Indicate Length of Register Entry
         LA    R5,DRGREGS+(DRGEGLEN/8)-L'DRGREGS/2 ..For Regs AR0 - AR3
DREG3900 DS    0H
         UNPK  DRGWRK09,0(5,R3)    Obtain the Access Register Value
         TR    DRGWRK09(L'DRGWRK09-1),HEXCONV-C'0'  ...Hex to Character
         MVC   0(L'DRGWRK09-1,R2),DRGWRK09 ...Access Register to Output
         LA    R2,10(,R2)          Increment to Next Register Field
         BRXLG R3,R4,DREG3900      Loop to Process the Next Register
DREG4000 DS    0H
         MVC   DRGWTOMG(COMWTOL),COMWTO .Fill WTO Remote Parameter List
         MVC   DRGMSGTX,DRGOLINE   Copy the Message to WTO Buffer Area
         MVC   DRGMSG,=Y(L'DRGMSGTX) ..Indicate Length of Text Message
         LA    R4,DRGMSG           Obtain Address of Message Text Area
         WTO   TEXT=(R4),          Write Access Reg Info to MVS ConsoleX
               MF=(E,DRGWTOMG)     Remote Program Parameter List
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DREGEXIT            No  => Then Bypass Print Output
DREG4100 DS    0H
         BRAS  R14,DREGP100        Access Registers 0-3 to //LGRECOUT
DREG4200 DS    0H
         MVI   DRGLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DRGLINE+1(L'DRGLINE-1),DRGLINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*|  Format And Print Access Registers AR4 - AR7 Detail Line          |*
*|                                                                   |*
*|  4-7   00000000  00000000  00000000  00000000                     |*
*+-------------------------------------------------------------------+*
*
DREG4300 DS    0H
         MVC   DRGOLINE+2(3),=C'4-7' Indicate Registers to Set for Prnt
         LA    R2,DRGOLINE+8       Position Start of Register Values
         LA    R3,DRGREGS+(DRGEGLEN/8) ..Starting Address Points to AR4
         LA    R4,L'DRGREGS/2      Indicate Length of Register Entry
         LA    R5,(DRGEGLEN/8)-L'DRGREGS/2(,R3)  ...For Regs AR4 - AR7
DREG4400 DS    0H
         UNPK  DRGWRK09,0(5,R3)    Obtain the Access Register Value
         TR    DRGWRK09(L'DRGWRK09-1),HEXCONV-C'0'  ...Hex to Character
         MVC   0(L'DRGWRK09-1,R2),DRGWRK09 ...Access Register to Output
         LA    R2,10(,R2)          Increment to Next Register Field
         BRXLG R3,R4,DREG4400      Loop to Process the Next Register
DREG4500 DS    0H
         MVC   DRGWTOMG(COMWTOL),COMWTO .Fill WTO Remote Parameter List
         MVC   DRGMSGTX,DRGOLINE   Copy the Message to WTO Buffer Area
         MVC   DRGMSG,=Y(L'DRGMSGTX) ..Indicate Length of Text Message
DREG4600 DS    0H
         LA    R4,DRGMSG           Obtain Address of Message Text Area
         WTO   TEXT=(R4),          Write Access Reg Info to MVS ConsoleX
               MF=(E,DRGWTOMG)     Remote Program Parameter List
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DREGEXIT            No  => Then Bypass Print Output
DREG4700 DS    0H
         BRAS  R14,DREGP100        Access Registers 4-7 to //LGRECOUT
DREG4800 DS    0H
         MVI   DRGLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DRGLINE+1(L'DRGLINE-1),DRGLINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*|  Format And Print Access Registers AR8 - AR11 Detail Line         |*
*|                                                                   |*
*|  8-11  00000000  00000000  00000000  00000000                     |*
*+-------------------------------------------------------------------+*
*
DREG4900 DS    0H
         MVC   DRGOLINE+2(4),=C'8-11' Indicate Register Set for Prt Lne
         LA    R2,DRGOLINE+8       Position Start of Register Values
         LA    R3,DRGREGS+(DRGEGLEN/4) ..Starting Address Points to AR8
         LA    R4,L'DRGREGS/2      Indicate Length of Register Entry
         LA    R5,(DRGEGLEN/8)-L'DRGREGS/2(,R3) ...For Regs AR8 - AR11
DREG5000 DS    0H
         UNPK  DRGWRK09,0(5,R3)    Obtain the Access Register Value
         TR    DRGWRK09(L'DRGWRK09-1),HEXCONV-C'0'  ...Hex to Character
         MVC   0(L'DRGWRK09-1,R2),DRGWRK09 ...Access Register to Output
         LA    R2,10(,R2)          Increment to Next Register Field
         BRXLG R3,R4,DREG5000      Loop to Process the Next Register
DREG5100 DS    0H
         MVC   DRGWTOMG(COMWTOL),COMWTO .Fill WTO Remote Parameter List
         MVC   DRGMSGTX,DRGOLINE   Copy the Message to WTO Buffer Area
         MVC   DRGMSG,=Y(L'DRGMSGTX) ..Indicate Length of Text Message
DREG5200 DS    0H
         LA    R4,DRGMSG           Obtain Address of Message Text Area
         WTO   TEXT=(R4),          Write Access Reg Info to MVS ConsoleX
               MF=(E,DRGWTOMG)     Remote Program Parameter List
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DREGEXIT            No  => Then Bypass Print Output
DREG5300 DS    0H
         BRAS  R14,DREGP100        Access Registers 8-11 to //LGRECOUT
DREG5400 DS    0H
         MVI   DRGLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DRGLINE+1(L'DRGLINE-1),DRGLINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*|  Format And Print Access Registers AR12 - AR15 Detail Line        |*
*|                                                                   |*
*| 12-15  00000000  00000000  00000000  00000000                     |*
*+-------------------------------------------------------------------+*
*
DREG5500 DS    0H
         MVC   DRGOLINE+2(5),=C'12-15' Indicate Register Set for Print
         LA    R2,DRGOLINE+8       Position to Start of Register Values
         LA    R3,DRGREGS+(DRGEGLEN/4+DRGEGLEN/8) Address Points to R12
         LA    R4,L'DRGREGS/2      Indicate Length of Register Entry
         LA    R5,(DRGEGLEN/8)-L'DRGREGS/2(,R3) For Registers R12 - R15
DREG5600 DS    0H
         UNPK  DRGWRK09,0(5,R3)    Obtain the Access Register Value
         TR    DRGWRK09(L'DRGWRK09-1),HEXCONV-C'0'  ...Hex to Character
         MVC   0(L'DRGWRK09-1,R2),DRGWRK09 ...Access Register to Output
         LA    R2,10(,R2)          Increment to Next Register Field
         BRXLG R3,R4,DREG5600      Loop to Process the Next Register
DREG5700 DS    0H
         MVC   DRGWTOMG(COMWTOL),COMWTO .Fill WTO Remote Parameter List
         MVC   DRGMSGTX,DRGOLINE   Copy the Message to WTO Buffer Area
         MVC   DRGMSG,=Y(L'DRGMSGTX) ..Indicate Length of Text Message
DREG5800 DS    0H
         LA    R4,DRGMSG           Obtain Address of Message Text Area
         WTO   TEXT=(R4),          Write GPR Info Line to MVS Console  X
               MF=(E,DRGWTOMG)     Remote Program Parameter List
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DREGEXIT            No  => Then Bypass Print Output
DREG5900 DS    0H
         BRAS  R14,DREGP100        Access Registers 12-15 to //LGRECOUT
         MVI   DRGLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DRGLINE+1(L'DRGLINE-1),DRGLINE ...Propogate the Blank
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DREGEXIT            No  => Then Bypass Print Output
DREG6000 DS    0H
         BRAS  R14,DREGP100        Blank Separator Line to //LGRECOUT
*
*+-------------------------------------------------------------------+*
*|  Print the Register Summary Report Header Line                    |*
*|                                                                   |*
*| -General Purpose Register Summary-                                |*
*+-------------------------------------------------------------------+*
*
DREG6100 DS    0H
         MVI   DRGLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DRGLINE+1(L'DRGLINE-1),DRGLINE ...Propogate the Blank
         MVC   DRGOLINE(L'DRGLNHDR),DRGLNHDR Copy the GPR's Header Line
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DREGEXIT            No  => Then Bypass Print Output
DREG6200 DS    0H
         BRAS  R14,DREGP100        Print GPR Summary Header to LGRECOUT
         MVI   DRGLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DRGLINE+1(L'DRGLINE-1),DRGLINE ...Propogate the Blank
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DREGEXIT            No  => Then Bypass Print Output
DREG6300 DS    0H
         BRAS  R14,DREGP100        Blank Separator Line to //LGRECOUT
*
*+-------------------------------------------------------------------+*
*| Obtain a Register Info Work Area Which Will Be Used to Analyze the|*
*| Contents of the General Purpose Registers at Time of Abend        |*
*+-------------------------------------------------------------------+*
*
DREG6400 DS    0H
         LA    R0,DRGREGWK         Start Adr for Register Info Wrk Area
         STG   R0,DRGWKADR         Save Beginning Addr of Reg Work Area
         LLILL R1,(DRGWKLEN)       Get the Length of Register Work Area
         SLGR  R14,R14             Indicate the Sending Area is Nulls
         SLGR  R15,R15             No Length and Using Pad Character
DREG6500 DS    0H
         MVCLE R0,R14,C' '(0)      Clear the Entire Area to Blanks
         BRO   DREG6500            Upon Interrupt Resume Where Left Off
DREG6600 DS    0H
         LA    R2,DRGREGNO         Start Addr for Register Number Area
         STG   R2,DRGNOADR         Save Beginning Addr of Reg No. Area
         LA    R3,DRGSAVER         Address of Gen Purpose Register Tble
         LA    R4,L'DRGSAVER       Indicate Leng of Each Register Entry
         LA    R5,DRGSAVER+((DRG$RGNO*L'DRGSAVER)-L'DRGSAVER) ...Limit
*
*+-------------------------------------------------------------------+*
*|      Check If The Register Contents Point to a Load Module        |*
*+-------------------------------------------------------------------+*
*
DREG6700 DS    0H
         STMG  R3,R5,DRGPNTR@      Save Current Register Table Pointers
         LG    R3,0(,R3)           Value in Register Being Processed
         SLGR  R4,R4               Not Using an Abending Pgm's LCA Addr
         XC    DRGPLIST,DRGPLIST   Clear the Call Parameter List
         CALL  LNME0000,           Process Register Value for LMod NameX
               ((R3),              ..Pass Register Value to Be ResolvedX
               (R4),               ..Pass Null Abending Pgm LCA AddressX
               DRGLMODI,           ..Pass Addr of Load Module Info AreaX
               (RSDW),             ..Pass SDWA Area Address            X
               (RLGW),             ..Pass LGRWK2II Area Address        X
               (RCOMM)),           ..Pass Common Constants&Routines    X
               PLIST8=YES,         ..Indicate the Parameter List FormatX
               LINKINST=LGR,       ..Indicate the Link Instruction TypeX
               MF=(E,DRGPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Process Register for Load Module Nme
         LTGFR R15,R15             Register Value Process Successful?
         BRZ   DREG6800            Yes => Branch to Process Detail Line
         LGHI  R2,((DREG6900-DREG6800)-4) ...Length of Branch Table
         CGFR  R15,R2              Ret Cde in R15 Exceed Branch Length?
         BRL   DREG6800            No  => Branch to Process Line Header
         BRU   DREGEXIT            Yes => Branch to Exit This Routine
DREG6800 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   DREG6900            Addr Process Completed, Process Hdr
         BRU   DREG6900            Branch on Warning-Ignore & Continue
         BRU   DREGEXIT            Branch on Processing Error - Exit
         BRU   DREGEXIT            Branch on Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*|Show Load Module Name + Offset and Show Register Content as Decimal|*
*|                                                                   |*
*|For example:                                                       |*
*|                                                                   |*
*|Reg #    Value in      Value in Reg is    Module Name and  Register|
*| |       Register     a Storage Address   Offset Our Addr  Value in|
*| |          |         Pointing to Module    Points To      Decimal |*
*| |          |                |                   |             |   |*
*|R5:  00000000186074CE Load Module/Csect  USRTEST1+(0074CE)  Decimal|*
*+-------------------------------------------------------------------+*
*
LMOD     USING LRTLMBLK,DRGLMODI   Establish Addressability to LMODI
RWRK     USING LRTRGBLK,R2         Addressibility to Register Info Blk
DREG6900 DS    0H
         LG    R1,DRGNOADR         Get Current Pointer to Reg No. Area
         LG    R2,DRGWKADR         Get Current Address in Reg Work Area
         STG   R3,RWRK.LRTREGCX    GP Reg Contents (Hex) to Work Area
         MVC   RWRK.LRTREGNO,0(R1) Current Register No. to Work Area
         STG   R3,DRGWORKD         Copy Register Value to a Work Area
         UNPK  DRGWRK16(9),DRGWORKD(5) Get the High-Half Register Value
         UNPK  DRGWRK16+8(9),DRGWORKD+4(5) Get Low-Half Register Value
         TR    DRGWRK16,HEXCONV-C'0' Finalize Conversion to Zoned Char
         MVC   RWRK.LRTREGCC,DRGWRK16  Reg Contents (Char) to Work Area
         CLC   LMOD.LRTLMOD(8),=C'UNKNOWN ' Reg a Pointer to a Module?
         BRE   DREG7600            No  => Check Contents Next Register
DREG7000 DS    0H
         MVC   RWRK.LRTALLOC(L'DRGLMODC),DRGLMODC .LMod or Csect Header
         MVC   RWRK.LRTSUBPL(L'LRTPGMNM),LMOD.LRTPGMNM  Get Module Name
         LLGC  R0,=X'40'           Establish the Search Stop Character
         LA    R4,RWRK.LRTSUBPL    Addr of Module Name in Reg Work Line
         LLILL R5,((LRTREFER-LRTSUBPL)+L'LRTREFER)  Set the Search Leng
         LA    R6,DRGTRTBL         Get the Address of Translate Table
DREG7100 DS    0H
         TRE   R4,R6               Search for End of Module Info Field
         BRO   DREG7100            Resume Where We Left Off
         BRZ   DREG7500            Branch If Stop Character Not Found
DREG7200 DS    0H
         LA    R4,2(,R4)           Increment to Decimal Display Area
         MVC   0(L'DRGDECHD,R4),DRGDECHD Detail Lne Hdr to Show Decimal
         LA    R4,L'DRGDECHD(,R4)  Increment Past Detail Line Header
         LG    R0,RWRK.LRTREGCX    Get the Contents of Current Register
         NILH  R0,(X'7FFF')        Clear Hi-Order Bit to Isolate Addr
         CVD   R0,DRGADWRK         Address in Reg to a Decimal Format
         MVC   DRGDECIM,DRGPTRN1   Copy in the Number Editing Pattern
         LA    R1,DRGFORC1         Load 1st Forced Result Char Location
         EDMK  DRGDECIM,DRGADWRK+1 Edit Reg Value as No. Bytes to Char
         LA    R3,DRGDECIM+L'DRGDECIM-1 .Point to End of Edit Work Area
         SGR   R3,R1               Calculate the Length of Our Number
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R3,*-6              Show Addr in Reg as a Decimal Number
         LA    R4,2(R3,R4)         Increment Past the Decimal Value
         MVC   0(4,R4),=CL4'(31)'  Calculation Omits High Order Bit
         LA    R4,5(,R4)           Increment Past the 31-bit Indicator
DREG7300 DS    0H
         LG    R0,RWRK.LRTREGCX    Get the Contents of Current Register
         CLMH  R0,B'1111',=A(X'00000000') Did Reg Contain 64-Bit Value?
         BRE   DREG7500            No  => Process the Next Register
         LG    1,DRGAMOD@          Get Pointer to Amode at Time of Abnd
         CLC   0(2,R1),=CL2'64'    Program in Amode64 at Time of Abend?
         BRNE  DREG7500            No  => Process the Next Register
         CVDG  R0,DRGADWRK         Addr in Register to Decimal Format
         MVC   DRGHIADR,DRGPTRN2   Copy in the Number Editing Pattern
         LA    R1,DRGFORC2         Load 1st Forced Result Char Location
         EDMK  DRGHIADR,DRGADWRK   Edit High Number Value to Character
         BRNM  DREG7400            Branch if the Result is Positive
         MVI   0(R4),C'-'          Indicate the Number is Negative
         LA    R4,1(,R4)           Increment Past the Minus Character
DREG7400 DS    0H
         LA    R3,DRGHIADR+L'DRGHIADR-1  Point to End of Edit Work Area
         SGR   R3,R1               Calculate the Length of Our Number
         MVC   0(*-*,R4),0(R1)     Indicated Target of the Execute
         EX    R3,*-6              Show Value in Reg as Decimal Number
         LA    R4,2(R3,R4)         Increment Past the Decimal Value
         MVC   0(4,R4),=CL4'(64)'  Indicate Calculation for 64 bits
DREG7500 DS    0H
         BRU   DREG7600            Branch to Process Info for Next Reg
         DROP  LMOD                Remove Listed Reg as LMODI Base Reg
         DROP  RWRK                Remove Listed Reg as Reg Work Base
*
*+-------------------------------------------------------------------+*
*|      Loop Point to Process the Next General Purpose Register      |*
*+-------------------------------------------------------------------+*
*
DREG7600 DS    0H
         LG    R1,DRGNOADR         Get Current Pointer to Reg No. Area
         LA    R1,L'DRGREGNO(,R1)  Increment to Next Register Number
         STG   R1,DRGNOADR         Save New Pointer to Reg No. Area
         LG    R2,DRGWKADR         Get Current Address of Reg Work Area
         LA    R2,LRTRGLEN(,R2)    Increment to Next Reg Wrk Area Entry
         STG   R2,DRGWKADR         Save New Pointer in Reg Work Area
         LMG   R3,R5,DRGPNTR@      Restore Current Reg Table Pointers
         BRXLG R3,R4,DREG6700      Loop to Check the Next GP Register
*
*+-------------------------------------------------------------------+*
*| Now Check If Any Register Contents Not Pointing to a Load Module  |*
*| May Point to a Storage Area.                                      |*
*+-------------------------------------------------------------------+*
*
DREG7700 DS    0H
         XC    DRGPLIST,DRGPLIST   Clear the Call Parameter List
         CALL  DRVS0000,           Process Registers to Virtual StorageX
               (DRGREGWK,          ..Pass Addr of Reg Info Work Area   X
               DRG$WKNO,           ..Pass Count in Reg Info Work Area  X
               (RSDW),             ..Pass SDWA Area Address            X
               (RLGW),             ..Pass LGRWK2II Area Address        X
               (RCOMM)),           ..Pass Common Constants&Routines    X
               PLIST8=YES,         ..Indicate the Parameter List FormatX
               LINKINST=LGR,       ..Indicate the Link Instruction TypeX
               MF=(E,DRGPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Process Register Contents to Storage
         LTGFR R15,R15             Was Register Processing Successful?
         BRZ   DREG7800            Yes => Branch to Process Regs Used
         LGHI  R2,((DREG7900-DREG7800)-4) ...Length of Branch Table
         CGFR  R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   DREG7800            No  => Branch to Process Regs Used
         BRU   DREGEXIT            Yes => Branch to Exit This Routine
DREG7800 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   DREG7900            Register Contents Process Completed
         BRU   DREG7900            Branch on Warning-Ignore & Continue
         BRU   DREGEXIT            Branch on Processing Error - Exit
         BRU   DREGEXIT            Branch on Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*| The Register Info Work Area Has Been Filled With 16 Detail Lines  |*
*| That Contain Information About the 16 General Purpose Registers.  |*
*| Now Process the Register Information Work Area to Identify in the |*
*| Register Summary Report Which Registers Were Referenced in the    |*
*| Abending Instruction.                                             |*
*+-------------------------------------------------------------------+*
*
DREG7900 DS    0H
         ICM   R2,B'1111',LGWREAS$ Reason Cde Indicate Invalid Instruc?
         BRNZ  DREG8100            Yes => Bypass Reg Instructn Process
         LG    R4,DRGMCHI@         Pointer to Machine Table Entry Addr
         XC    DRGPLIST,DRGPLIST   Clear the Call Parameter List
         CALL  DRUS0000,           Determine Regs Used in Instruction  X
               (DRGTARG@,          ..Pass Addr of Target of EX InstructX
               (R4),               ..Pass Addr of Addr to Table Entry  X
               DRGABND@,           ..Pass Addr of Abending Instruction X
               DRGREGWK,           ..Pass Addr of Reg Info Work Area   X
               DRG$WKNO,           ..Pass Count in Reg Info Work Area  X
               (RSDW),             ..Pass SDWA Area Address            X
               (RLGW),             ..Pass LGRWK2II Area Address        X
               (RCOMM)),           ..Pass Common Constants&Routines    X
               PLIST8=YES,         ..Indicate the Parameter List FormatX
               LINKINST=LGR,       ..Indicate the Link Instruction TypeX
               MF=(E,DRGPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Process for the Registers Used
         LTGFR R15,R15             Was Regs Used Process Successful?
         BRZ   DREG8000            Yes => Done, Branch to Prnt Reg Info
         LGHI  R2,((DREG8100-DREG8000)-4) ...Length of Branch Table
         CGFR  R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   DREG8000            No  => Branch to Print Reg Work Area
         BRU   DREGEXIT            Yes => Branch to Exit This Routine
DREG8000 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   DREG8100            Registers Used Process Completed
         BRU   DREG8100            Branch on Warning-Ignore & Continue
         BRU   DREGEXIT            Branch on Processing Error - Exit
         BRU   DREGEXIT            Branch on Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*| Print the Register Info Work Area to Output Data Set to Create the|*
*| General Purpose Register Summary Report.                          |*
*+-------------------------------------------------------------------+*
*
DREG8100 DS    0H
         MVI   DRGLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DRGLINE+1(L'DRGLINE-1),DRGLINE ...Propogate the Blank
         LA    R3,DRGREGWK         Register Contents Analysis Work Area
         LLILL R4,(DRG$WKNO)       Count of No. of General Purpose Regs
DREG8200 DS    0H
         MVC   DRGOLINE(LRTRGLEN-L'LRTREGCX-1),LRTREGUS-LRTRGBLK(R3)
         CLI   DRGOLINE,C' '       Register Used Indicator Set for Reg?
         BRE   DREG8300            No  => Branch to Check DCB Status
         OI    DRGFLAG1,DRGLEGND   Indicate Print Legend for Regs Used
DREG8300 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DREGEXIT            No  => Then Bypass Print Output
DREG8400 DS    0H
         BRAS  R14,DREGP100        Print a Register Contents Info Line
         LA    R3,LRTRGLEN(,R3)    Increment to Next Reg Wrk Area Entry
         BRCTG R4,DREG8200         Loop to Process the Next Register
DREG8500 DS    0H
         TM    DRGFLAG1,DRGLEGND   Print Legend for Any Registers Used?
         BRZ   DREGEXIT            No  => Then Bypass Print Output
         MVI   DRGLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DRGLINE+1(L'DRGLINE-1),DRGLINE ...Propogate the Blank
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DREGEXIT            No  => Then Bypass Print Output
DREG8600 DS    0H
         BRAS  R14,DREGP100        Blank Separator Line to //LGRECOUT
         MVI   DRGLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DRGLINE+1(L'DRGLINE-1),DRGLINE ...Propogate the Blank
         MVC   DRGOLINE+2(L'DRGLEREG),DRGLEREG Copy Register Legend Lne
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DREGEXIT            No  => Then Bypass Print Output
DREG8700 DS    0H
         BRAS  R14,DREGP100        Print Registr Legend Lne to LGRECOUT
         MVI   DRGLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DRGLINE+1(L'DRGLINE-1),DRGLINE ...Propogate the Blank
         MVC   DRGOLINE+10(L'DRGLERG2),DRGLERG2 Cpy Register Legend Lne
DREG8800 DS    0H
         USING OP@CODES,R3         Addressability Machine Instr Table
         LG    R3,DRGMCHI@         Pointer to Machine Table Entry Addr
         LG    R3,0(,R3)           Get Address to Machine Table Entry
         LTGR  R3,R3               There an Addr for Machine Tbl Entry?
         BRZ   DREG8900            No  => Then Branch to Print Line
         LA    R4,DRGOLINE+10+L'DRGLERG2  Point to End of Legend Line
         MVC   0(L'OP@MNEUM,R4),OP@MNEUM  Get Abending Instr Mneumonic
         DROP  R3                  Remove Listed Reg as Tble Entry Base
DREG8900 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DREGEXIT            No  => Then Bypass Print Output
         BRAS  R14,DREGP100        Print Registr Legend Lne to LGRECOUT
DREG9000 DS    0H
         LG    R1,DRGTARG@         Get Pointer to Addr of Target of EX
         LG    R1,0(,R1)           Get Address of Target of EX Instruct
         LTGR  R1,R1               Was There a Target Addr Available?
         BRZ   DREGEXIT            No  => Not Processing Executed Instr
         MVI   DRGLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DRGLINE+1(L'DRGLINE-1),DRGLINE ...Propogate the Blank
         MVC   DRGOLINE+3(L'DRGLETAR),DRGLETAR  Target Instr of Execute
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DREGEXIT            No  => Then Bypass Print Output
         BRAS  R14,DREGP100        Show Legend is for Target Instructn
*
*+-------------------------------------------------------------------+*
*|   Return to Caller                                                |*
*+-------------------------------------------------------------------+*
*
DREGEXIT DS    0H
         SLGR  R15,R15             Indicate Successful Completion
         ST    R15,DRGRETCD        Set the Return Code
         LPGMEXIT RC=DRGRETCD      Define Program Exit Protocol
*
*+-------------------------------------------------------------------+*
*|         P r i n t   O u t p u t   D e t a i l   L i n e           |*
*+-------------------------------------------------------------------+*
*|SUBROUTINE NAME: DREGP100                                          |*
*|FUNCTION.......: Print Detail Line to Output Logger Data Set       |*
*+-------------------------------------------------------------------+*
*
DREGP100 LPGMSUBE                  Set Subroutine Entry Protocol
         SYSSTATE AMODE64=NO,ARCHLVL=2 Generate Code for Not in AMODE64
         SAM31                     Switch Now to 31-Bit Addressing Mode
         PUT   LGWODCB,DRGLINE     Print Output Line to //LGRECOUT
         SAM64                     Switch Back to 64-Bit Address Mode
         SYSSTATE AMODE64=YES,ARCHLVL=2    Restore 64-Bit Environment
         LPGMSUBX                  Return to Caller of This Subroutine
*
*+-------------------------------------------------------------------+*
*|   Definition for Constants                                        |*
*+-------------------------------------------------------------------+*
*
DRGLNHDR DC    C'-General Purpose Register Summary-'  Reg Contents Hdr
DRGDTL05 DC    CL(PRNTLEN)'General Purpose Registers R0-R15 at Entry toX'
                Abend:'
DRGLEREG DC    C'''?-Rx:'' Used as a designated (D), index (X), base (BX
               ), odd (O) of an even/odd pair,'
DRGLERG2 DC    C'or hardware implied (H) register in abending instructiX
               on '
DRGLETAR DC    C'Note:  Registers flagged are for the target instructioX
               n of the Execute instruction.'
DRGLMODC DC    C'Load Module/Csect'  Indicator for Load Module or Csect
DRGDECHD DC    C'Decimal='         Indicator for Reg Value as Decimal
DRGREGNO DC    C'R0:  '            Register 0 Contents Detail Line
         DC    C'R1:  '            Register 1 Contents Detail Line
         DC    C'R2:  '            Register 2 Contents Detail Line
         DC    C'R3:  '            Register 3 Contents Detail Line
         DC    C'R4:  '            Register 4 Contents Detail Line
         DC    C'R5:  '            Register 5 Contents Detail Line
         DC    C'R6:  '            Register 6 Contents Detail Line
         DC    C'R7:  '            Register 7 Contents Detail Line
         DC    C'R8:  '            Register 8 Contents Detail Line
         DC    C'R9:  '            Register 9 Contents Detail Line
         DC    C'R10: '            Register 10 Contents Detail Line
         DC    C'R11: '            Register 11 Contents Detail Line
         DC    C'R12: '            Register 12 Contents Detail Line
         DC    C'R13: '            Register 13 Contents Detail Line
         DC    C'R14: '            Register 14 Contents Detail Line
         DC    C'R15: '            Register 15 Contents Detail Line
DRGTRTBL DC    256AL1(*-DRGTRTBL)  Definition for a Translate Table
DRGPTRN1 DC    XL18'40206B2020206B2020206B2020206B202120' .Edit Pattern
DRGPTRN2 DC    XL42'40206B2020206B2020206B2020206B2020206B2020206B20202X
               06B2020206B2020206B2020206B202120'       ...Edit Pattern
*
*+-------------------------------------------------------------------+*
*|    Program RENT Work Area                                         |*
*+-------------------------------------------------------------------+*
*
         LCA   DEFINE              Define the Program RENT Work Area
*
DRGWORKD DS    10D                 General Purpose Work Area
DRGPLIST DS    20FD                CALL Parameter List
DRGPNTR@ DS    3FD                 Save Area for Register Area Pointers
DRGPARM@ DS    0FD                 Save Area for Passed Parameters
DRGTARG@ DS    AD                  Address of Target of EX Instruction
DRGMCHI@ DS    AD                  Address of Entry in Machine Table
DRGAMOD@ DS    AD                  Address of Amode at Time of Abend
DRGABND@ DS    AD                  Address of Abending Instruction
*
DRGNOADR DS    AD                  Address in Register Number Area
DRGWKADR DS    AD                  Address in Register Info Work Area
DRGREGS  DS    0FD                 GP Regs at Entry to Abend Save Area
DRGREG0  DS    13FD                Register Save Area R0-R12
DRGREG13 DS    FD                  Register R13 Save Area
DRGREG14 DS    2FD                 Register Save Area R14-R15
DRGEGLEN EQU   *-DRGREGS           Length of Our R0 thru R15 Area
DRGSAVER DS    0FD                 Save Area for GP Register Values
         DS    16FD                For 16 General Purpose Registers
DRGSALEN EQU   *-DRGSAVER          Length of Register R0 thru R15 Area
DRG$RGNO EQU   (DRGSALEN)/L'DRGSAVER  No. of Entries in Register Area
DRGRETCD DS    F                   Save Area for the Return Code
         DS    0D                  Set For Doubleword Alignment
DRGWTOMG DS    0D,XL(COMWTOL)      Area for WTO Macro List Form
         DS    0F
DRGMSG   DS    H                   Length of Message Text
DRGMSGTX DS    CL80                Text of Message
DRGLMODI DS    CL(LRTLMLEN)        Area for Load Module Information Blk
DRGWRK09 DS    CL9                 General Purpose Work Area
DRGWRK16 DS    CL16                General Purpose Work Area
DRGADWRK DS    2D                  Wrk Area for Addr to Decimal Convert
DRGDECIM DS    CL(L'DRGPTRN1)      Work Area for Editing Decimal Values
DRGFORC1 EQU   *-1                 First Forced Result Char Location
DRGHIADR DS    CL(L'DRGPTRN2)      Work Area for High Addr to Character
DRGFORC2 EQU   *-1                 First Forced Result Char Location
DRGFLAG1 DS    XL1                 Flag Byte for Register Info Wrk Area
DRGLEGND EQU   X'80'               ..Indicate Print Legend for Reg Used
DRGLINE  DS    0CL133              Output Print Line Area
DRGCCNTL DS    CL1                 Carriage Control Character
DRGOLINE DS    CL132               Output Record Print Area
DRGREGWK DS    0CL(PRNTLEN)        Register Contents Analysis Work Area
         DS    16CL(PRNTLEN)       Work Areas for Register R0 thru R15
DRGWKLEN EQU   *-DRGREGWK          Len of Register R0 thru R15 Wrk Area
DRG$WKNO EQU   (DRGWKLEN)/L'DRGREGWK  No. of Entries in Reg Work Area
*
         LCA   DEFEND              Define End of Program RENT Work Area
*
***********************************************************************
*           End of Register Contents Information Processing           *
***********************************************************************
         EJECT ,
***********************************************************************
**************************+-----------------+**************************
**************************| D R V S 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|   D e t e r m i n e   V i r t u a l   S t o r a g e   A r e a s   |*
*+-------------------------------------------------------------------+*
* PROGRAM NAME:    DRVS0000                                           *
*                                                                     *
* FUNCTION:        Determine Virtual Storage Areas                    *
*                                                                     *
*                  This routine is responsible for determining the    *
*                  storage area a register may be pointing to. The    *
*                  value in a register was previously checked to      *
*                  see if it was pointing into a load module, and if  *
*                  so the load module name and offset was determined. *
*                  Those registers associated with a load module are  *
*                  not checked in this routine as they have already   *
*                  been processed by the calling program DREG0000.    *
*                  The purpose of this routine is to look at any      *
*                  remaining registers to determine if they contain   *
*                  an address that may be pointing to a storage area. *
*                                                                     *
*                  A call is made to VSMLIST for storage information  *
*                  on CSA, SQA, LSQA, and private area subpools. The  *
*                  contents of the work area returned by VSMLIST will *
*                  include the allocated block descriptors and the    *
*                  free space descriptors associated with each subpool*
*                  for an area, this area being either the private    *
*                  area, CSA, SQA, or LSQA. A separate call is made to*
*                  VSMLIST for the private area subpools where the    *
*                  returned work area is analyzed, then the same is   *
*                  done for the CSA subpools, the SQA subpools, and   *
*                  the LSQA subpools.                                 *
*                                                                     *
*                  The information returned from each call to VSMLIST *
*                  is analyzed against the value in a register on the *
*                  assumption the register value represents a storage *
*                  address. If the value in a register is within an   *
*                  allocated or free-space range of subpool storage as*
*                  indicated by the information returned in the work  *
*                  area by VSMLIST, then the subpool number, the      *
*                  storage key, the TCB associated with the storage if*
*                  a private area, and the addressable range of the   *
*                  storage area based on the address in the register  *
*                  is placed in the register information work area.   *
*                                                                     *
* INPUT REGS:      R1 => Standard O/S Parameter List                  *
*                                                                     *
* INPUT DATA:      Parm1: Address of Register Information Work Area   *
*                  Parm2: Register Count in Register Info Work Area   *
*                  Parm4: Address of System Diagnostic Work Area      *
*                  Parm4: Address of LGRWK2II Logger Work Area        *
*                  Parm5: Addr of Common Constants and Routines Area  *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY, AC=0                          *
*                                                                     *
* CALLING PROGRAM: DREG0000 - Logger Services Program to Process the  *
*                             Contents of Registers at Entry to Abend *
*                                                                     *
* CALLED PROGRAMS: VSMLIST  - Virtual Storage Manager Routine         *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                  04 - Warning                                       *
*                  08 - Error                                         *
*                  12 - Severe Error - Exit This Routine              *
*                                                                     *
***********************************************************************
*
DRVS0000 LPGMNTRY TYPE=SUB,        Define As A Sub-Program Entry       X
               BASE=(12,11),       Establish Base Registers            X
               AMOD=64,RMOD=ANY,   Addressing and Residency Modes      X
               LCAPFX=DVS,         Establish LCA Prefix for This RSECT X
               LOG=OFF,            Always Turn Logging 'Off' in Logger!X
               LINKRTRN=BSM,       Define Return Linkage Instruction   X
               COPY@RT=YES         To Generate a Copyright Statement
         USING COM_DATA,RCOMM      Addressability to Common Data Area
         USING LGRWK2II,RLGW       Establish Addressability to LGRWK2II
         USING SDWA,RSDW           Establish Addressability to SDWA
         USING IHADCB,LGWODCB      Establish Addressability to DCB
         LMG   R6,R10,0(R1)        Load the Parameter Area Addresses
         STMG  R6,R7,DVSWKADR      Save Parms to Register Info Wrk Area
         XC    DVSRETCD,DVSRETCD   Initialize the Return Code
*
*+-------------------------------------------------------------------+*
*| Retain virtual storage old area and release physical paging to    |*
*| clear the portion of the LGRWK2II area which is being re-used as  |*
*| a temporary work area to hold data returned from the VSMLIST call.|*
*+-------------------------------------------------------------------+*
*
DRVS0100 DS    0H
         LGR   R1,RLGW             Get Starting Address to Logger Area
         LLGF  R0,=A(LGW$PVML)     Get Length of the VSMLIST Work Area
         LLGF  R2,=A(LGW$PVSM-LGRWK2II)  Index to the VSMLIST Work Area
         LA    R1,0(R2,R1)         Establish Addr of VSMLIST Work Area
         LGR   R3,R1               Hold Start Addr of VSMLIST Work Area
         LGR   R15,R1              Starting Address of VSMLIST Wrk Area
         AGR   R15,R0              Calculate Ending Address of Wrk Area
         NG    R15,=AD(-4096)      Round Area Down to a Page Boundary
         BCTGR R15,R0              Ensure Pointing to Actual End Addr
         LA    R1,4095(,R1)        Add 4K to Existing Starting Address
         NG    R1,=AD(-4096)       Round It Up to Full Page Boundary
         CGR   R15,R1              Any Page Aligned Areas to Release?
         BRNH  DRVS0200            No  => Branch for a Physical Clear
       PGSER R,RELEASE,            Release the VSMLIST Work Area Pages X
               A=(1),              Starting Address of VSMLIST Wrk AreaX
               EA=(15),            Address of Last Byte in Work Areas  X
               BRANCH=N            Using SVC Entry for Paging Service
         BRU   DRVS0300            Branch to Obtain Virtual Storage Map
DRVS0200 DS    0H
         LGR   R0,R3               Starting Address to VSMLIST Wrk Area
         LLGF  R1,=A(LGW$PVML)     Get Length of the VSMLIST Work Area
         SLGR  R14,R14             Our Sending Area is Nulls
         SLGR  R15,R15             No Length and Pad Character to Zeros
         MVCLE R0,R14,0            Clear VSMLIST + Subpool Summary Area
*
*+-------------------------------------------------------------------+*
*|       Get Subpool Storage Information for the Private Area        |*
*+-------------------------------------------------------------------+*
*
DRVS0300 DS    0H
         XC    DVSREGCT,DVSREGCT   Init Entry Count for Reg Info Area
         LLGF  R1,=A(LGW$PVSM-LGRWK2II) Index to the VSMLIST Work Area
         LA    R3,0(R1,RLGW)       Address of Work Area to Return Data
         STG   R3,DVSRDAT@         Save Address of Returned Data Area
DRVS0400 DS    0H
         LG    R3,DVSRDAT@         Get Start Addr of Returned Data Area
         SAM31                     Switch Now to 31-Bit Addressing Mode
         VSMLIST SP=PVT,           Get Info on Subpools in Private AreaX
               TCB=(,ALL),         Subpool Info is for TCB and SubtasksX
               SPACE=FREE,         Subpool Info on Allocated+Free SpaceX
               WKAREA=(0(R3),LGW$PVML), Address and Leng of Return AreaX
               PVTSP=ALL,          Subpl Info Returned Owned or Shared X
               LOC=31,             Subpool Info for Areas Below the BarX
               LINKAGE=SYSTEM      Problem State-PC to VSMLIST Routine
         SAM64                     Switch Back to 64-Bit Address Mode
DRVS0500 DS    0H
         LLGF  R1,0(,R3)           Get Return Code from VSMLIST Routine
         CGHI  R1,4                Was Full or Partial Info Returned?
         BRH   DRVS4100            No  => Exit on a Sub-Pool List Error
*
*+-------------------------------------------------------------------+*
*| Work area has been returned from VSMLIST with the allocated block |*
*| descriptors and the free space descriptors associated with each   |*
*| subpool in the private area.                                      |*
*+-------------------------------------------------------------------+*
*
         USING VSMD,R4             Addressability to the VSM Descriptor
         USING LRTRGBLK,R6         Addressibility to Register Info Blk
DRVS0600 DS    0H
         LLGT  R1,4(,R3)           Get Address of Returned Data Area
         LLGF  R2,8(,R3)           Get the Length of Returned Data Area
         LA    R15,0(R1,R2)        Calculate Ending Addr of Data Area
         STG   R15,DVSRDATZ        Ending Address of Returned Data Area
         LLGF  R2,0(,R1)           Get the No. of TCB's in Private Area
         STG   R2,DVSTCBCT         Save the Private Area TCB Count
         LLGT  R5,8(,R1)           Get the Count for No. of Subpools
         LA    R4,12(,R1)          Get the Subpool Descriptor Entry
DRVS0700 DS    0H
         MVC   DVRVSMID,VSMDID     Get the Subpool Id and Storage Key
         MVC   DVRTCBSP,VSMDTCBP   Get the Address of the Owning TCB
         LA    R4,VSMD+L'VSMDSP+L'VSMDTCBP ..Point to Descriptor Count
         LLGF  R3,VSMDCNT          Current Allocated Blk Descriptor Cnt
         LA    R4,VSMD+L'VSMDCNT   Point to Allocated Block Descriptor
         LG    R1,DVSWKRG#         Register Count in Register Info Area
         STG   R1,DVSREGCT         Set Counter for Processing Reg Area
         LG    R6,DVSWKADR         Get Addr to Register Info Work Area
*
*+-------------------------------------------------------------------+*
*| Process the register contents by comparing the value in each      |*
*| register to the storage address in the allocated block descriptor |*
*| to check if that register value were used as an address would it  |*
*| point into an allocated storage area that is in-use.              |*
*+-------------------------------------------------------------------+*
*
DRVS1000 DS    0H
         LLGF  R14,VSMDAREA        Get Address of This Allocated Block
         LA    R1,VSMD+L'VSMDAREA+L'VSMDCNT Point to Nxt Blk Descriptor
         LLGF  R2,VSMDCNT-VSMD(,R1) ...Get Free Space Descriptors Count
         LTGR  R2,R2               Allocated Block Have Any Free Space?
         BRZ   DRVS1300            No  => All of Allocated Blk is Used
DRVS1100 DS    0H
         LA    R1,L'VSMDCNT(,R1)   Point 1st Free Space Blk Descriptor
         LLGF  R15,VSMDAREA-VSMD(,R1) Get Addr of This Free Space Block
         CLGR  R14,R15             Free Space Area at Beginning of Blk?
         BRNE  DRVS1200            No  => Set End Addr of Allocated Blk
         ALGF  R14,VSMDSIZE-VSMD(,R1) Point to Start Addr of Allocation
         ALGF  R15,VSMDSIZE        Add the Size of This Allocated Block
         BCTGR R15,R0              Point to Last Byte in Allocated Blk
         BRU   DRVS1400            Branch to Check for Storage Address
DRVS1200 DS    0H
         BCTGR R15,R0              Point to Last Byte in Allocated Blk
         BRU   DRVS1400            Check Just The Portion Which is Used
DRVS1300 DS    0H
         LGR   R15,R14             Adr of Allocated Blk to Wrk Register
         ALGF  R15,VSMDSIZE        Add the Size of This Allocated Block
         BCTGR R15,R0              Point to Last Byte in Allocated Blk
DRVS1400 DS    0H
         LG    R7,LRTREGCX         Get the Contents of Current Register
         NILH  R7,(X'7FFF')        Clear Hi-Order Bit of Low Half Reg
         CGR   R7,R14              Reg Content Within This Storage Blk?
         BRL   DRVS2000            No  => Storage Area Not Found
         CGR   R7,R15              Reg Content Within This Storage Blk?
         BRH   DRVS2000            No  => Storage Area Not Found
DRVS1500 DS    0H
         CLI   LRTRGFLG,X'01'      Reg Info Entry Already Processed?
         BRE   DRVS2000            Yes => Branch to Check Next Register
         CLI   LRTREGIN,C' '       Register Information Field Filled?
         BRNE  DRVS2000            Yes => Branch to Check Next Register
*
*+-------------------------------------------------------------------+*
*| Register was found with a pointer into an allocated storage area. |*
*| Extract the storage area attributes of the 4K page, indicate that |*
*| the register value as an address would point into an allocated    |*
*| storage area which is currently being used, and then place this   |*
*| information into the register information work area.              |*
*|                                                                   |*
*| For example:                                                      |*
*|                                                                   |*
*| R1:  0000000000010F66 Allocated storage  Subpool=003 Key=8  TCB=00|*
*+-------------------------------------------------------------------+*
*
DRVS1600 DS    0H
         MVI   LRTRGFLG,X'01'      Indicate Reg Info Entry Processed
         MVC   LRTALLOC(L'DVSALLOC),DVSALLOC Indicate Allocated Storage
         MVC   LRTSUBPL(L'DVSSUBPL),DVSSUBPL Indicator for Subpool Id
         LLGC  R0,DVRVSMID         Get the Binary Subpool Id
         CVD   R0,DVSWORKD         Decimal Version of Subpool Id
         OI    DVSWORKD+7,15       Certify Sign To Make It Displayable
         UNPK  LRTSUBPL+L'DVSSUBPL(L'LRTSUBPL-L'DVSSUBPL),DVSWORKD+6(2)
DRVS1700 DS    0H
         LLGC  R0,DVRVSMID+L'VSMDID Get Storage Protect Key + Flag Byte
         SRLG  R0,R0,4 Bits        Push Off Flag Bits So Just the Key
         CVD   R0,DVSWORKD         Convert Storage Key Value to Decimal
         LA    R1,DVSFORC1         Preload 1st Forced Result Location
         MVC   DVSWRK08,DVSPATRN   Copy in the Number Editing Pattern
         EDMK  DVSWRK08,DVSWORKD+4 Edit Storage Key Value to Character
         LA    R2,DVSWRK08+L'DVSWRK08-1 Point to End of Edit Work Area
         SGR   R2,R1               Calculate Leng of Storage Key Value
         MVC   LRTSTKEY(L'DVSSTKEY),DVSSTKEY Indicator for Storage Key
         MVC   LRTSTKEY+L'DVSSTKEY(*-*),0(R1)  ...Target of the Execute
         EX    R2,*-6              Storage Protect Key to Reg Info Area
DRVS1800 DS    0H
         UNPK  DVSWRK08(L'DVSWRK08+1),DVRTCBSP(L'DVRTCBSP+1) ..TCB Addr
         TR    DVSWRK08,HEXCONV-C'0' ...Translate Hex to Character
         MVC   LRTSTTCB(L'DVSSTTCB),DVSSTTCB ..Indicator for Owning TCB
         MVC   LRTSTTCB+L'DVSSTTCB(L'LRTSTTCB-L'DVSSTTCB),DVSWRK08 .TCB
DRVS1900 DS    0H
         LA    R1,1(,R15)          For Length Addressing Starts At Zero
         SGR   R1,R7               Calculate Range from Adr in Register
         BRNP  DRVS2000            Calculation is Forward, Not Backward
         CVDG  R1,DVSSTWRK         Binary Number of Addressable Bytes
         MVC   DVSRANGE,DVSPTRN2   Copy in the Number Editing Pattern
         LA    R1,DVSFORC2         Load 1st Forced Result Char Location
         EDMK  DVSRANGE,DVSSTWRK+9 Edit # of Addressable Bytes to Char
         LA    R2,DVSRANGE+L'DVSRANGE-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of the Bytes Number
         MVC   LRTREFER(L'DVSSTREF),DVSSTREF Indicate as Storage Range
         MVC   LRTREFER+L'DVSSTREF(*-*),0(R1) ...Target of Execute
         EX    R2,*-6              Addressable Range of Allocated Area
         LA    R1,LRTREFER+L'DVSSTREF+2(R2)  ..Point Past Storage Range
         MVC   0(5,R1),=CL5'bytes' Set Trailer Indicating No. of Bytes
*
*+-------------------------------------------------------------------+*
*| Loop Point to Compare the Contents of the Next Register to the    |*
*| Allocated Block Descriptor. Still with the same allocated block   |*
*| descriptor.                                                       |*
*+-------------------------------------------------------------------+*
*
DRVS2000 DS    0H
         AGHI  R6,(LRTRGLEN)       Increment to Next Reg Info Wrk Entry
         LG    R1,DVSREGCT         Current Reg Count for Reg Info Area
         BRCTG R1,DRVS2100         Decrement Remaining Cnt for Next Reg
         BRU   DRVS2200            Branch to Process the Next Register
DRVS2100 DS    0H
         STG   R1,DVSREGCT         Save Count for No. of Regs Remaining
         BRU   DRVS1400            Loop to Process Next Register Entry
DRVS2200 DS    0H
         LA    R4,VSMD+L'VSMDAREA+L'VSMDCNT Point to Nxt Blk Descriptor
         LLGF  R2,VSMDCNT          Get the Free Space Descriptors Count
         LA    R4,VSMD+L'VSMDCNT   Point to Free Space Block Descriptor
         LTGR  R2,R2               Allocated Block Have Any Free Space?
         BRZ   DRVS3100            No  => Check Next Allocated Block
*
*+-------------------------------------------------------------------+*
*| Still with the same allocated block descriptor, and this block    |*
*| descriptor also has free space information associated with it.    |*
*| Process the register contents by comparing the value in each      |*
*| register to the storage addresses listed in the free space block  |*
*| descriptors to check that if a register value were used as an     |*
*| address would it point into an un-used storage area in a partially|*
*| used page.                                                        |*
*+-------------------------------------------------------------------+*
*
DRVS2300 DS    0H
         LG    R6,DVSWKADR         Get Addr to Register Info Work Area
         LG    R1,DVSWKRG#         Register Count in Register Info Area
         STG   R1,DVSREGCT         Set Counter for Processing Reg Area
         LLGF  R14,VSMDAREA        Get Address of This Allocated Block
         LGR   R15,R14             Addr of Free Space to Work Register
         ALGF  R15,VSMDSIZE        Add the Size of This Free Space Blk
         BCTGR R15,R0              Point to Last Byte in Free Space Blk
DRVS2400 DS    0H
         LG    R7,LRTREGCX         Get the Contents of Current Register
         NILH  R7,(X'7FFF')        Clear Hi-Order Bit of Low Half Reg
         CGR   R7,R14              Reg Content Within This Free Space?
         BRL   DRVS2800            No  => Storage Area Not Found
         CGR   R7,R15              Reg Content Within This Free Space?
         BRH   DRVS2800            No  => Storage Area Not Found
*
*+-------------------------------------------------------------------+*
*| Register was found with a pointer into an un-used storage area of |*
*| a partially used page. Extract the storage area attributes of the |*
*| 4K page, indicate this register value if used as an address would |*
*| point into a free space area, and place this information into the |*
*| register information work area.                                   |*
*|                                                                   |*
*| For example:                                                      |*
*|                                                                   |*
*| R2:  0000000000017582 Free space storage Subpool=003 Key=8  TCB=00|*
*+-------------------------------------------------------------------+*
*
DRVS2500 DS    0H
         MVI   LRTRGFLG,X'01'      Indicate Reg Info Entry Processed
         MVC   LRTALLOC(L'DVSFRESP),DVSFRESP Show as Free Space Storage
         MVC   LRTSUBPL(L'DVSSUBPL),DVSSUBPL Indicator for Subpool Id
         LLGC  R0,DVRVSMID         Get the Binary Subpool Id
         CVD   R0,DVSWORKD         Decimal Version of Subpool Id
         OI    DVSWORKD+7,15       Certify Sign To Make It Displayable
         UNPK  LRTSUBPL+L'DVSSUBPL(L'LRTSUBPL-L'DVSSUBPL),DVSWORKD+6(2)
DRVS2600 DS    0H
         LLGC  R0,DVRVSMID+L'VSMDID Get Storage Protect Key + Flag Byte
         SRLG  R0,R0,4 Bits        Push Off Flag Bits So Just the Key
         CVD   R0,DVSWORKD         Convert Storage Key Value to Decimal
         LA    R1,DVSFORC1         Preload 1st Forced Result Location
         MVC   DVSWRK08,DVSPATRN   Copy in the Number Editing Pattern
         EDMK  DVSWRK08,DVSWORKD+4 Edit Storage Key Value to Character
         LA    R7,DVSWRK08+L'DVSWRK08-1 Point to End of Edit Work Area
         SGR   R7,R1               Calculate Leng of Storage Key Value
         MVC   LRTSTKEY(L'DVSSTKEY),DVSSTKEY Indicator for Storage Key
         MVC   LRTSTKEY+L'DVSSTKEY(*-*),0(R1)  ...Target of the Execute
         EX    R7,*-6              Storage Protect Key to Reg Info Area
DRVS2700 DS    0H
         UNPK  DVSWRK08(L'DVSWRK08+1),DVRTCBSP(L'DVRTCBSP+1) ..TCB Addr
         TR    DVSWRK08,HEXCONV-C'0' ...Translate Hex to Character
         MVC   LRTSTTCB(L'DVSSTTCB),DVSSTTCB Indicator for Owning TCB
         MVC   LRTSTTCB+L'DVSSTTCB(L'LRTSTTCB-L'DVSSTTCB),DVSWRK08 TCB
         MVC   LRTREFER(L'DVSUNUSD),DVSUNUSD Indicate as Un-used Space
DRVS2800 DS    0H
         AGHI  R6,(LRTRGLEN)       Increment to Next Reg Info Wrk Entry
         LG    R1,DVSREGCT         Current Reg Count in Reg Info Area
         BRCTG R1,DRVS2900         Decrement Remaining Cnt for Next Reg
         BRU   DRVS3000            Branch to Process Nxt Blk Descriptor
DRVS2900 DS    0H
         STG   R1,DVSREGCT         Save Count for No. of Regs Remaining
         BRU   DRVS2400            Loop to Process Next Register Entry
DRVS3000 DS    0H
         LA    R4,VSMD+L'VSMDAREA+L'VSMDCNT Point to Nxt Blk Descriptor
         BRCTG R2,DRVS2300         Loop to Process Next Free Space Blk
*
*+-------------------------------------------------------------------+*
*| Loop Point to Process the Next Allocated Block Descriptor for     |*
*| this Storage Subpool.                                             |*
*+-------------------------------------------------------------------+*
*
DRVS3100 DS    0H
         LG    R6,DVSWKADR         Get Addr to Register Info Work Area
         LG    R1,DVSWKRG#         Register Count in Register Info Area
         STG   R1,DVSREGCT         Set Counter for Processing Reg Area
         BRCTG R3,DRVS1000         Loop to Next Alloc Descriptor Block
*
*+-------------------------------------------------------------------+*
*| Loop Point to Process Allocated Block Descriptors for Next Subpool|*
*| of the Current TCB.                                               |*
*+-------------------------------------------------------------------+*
*
DRVS3200 DS    0H
         LG    R6,DVSWKADR         Get Addr to Register Info Work Area
         LG    R1,DVSWKRG#         Register Count in Register Info Area
         STG   R1,DVSREGCT         Set Counter for Processing Reg Area
         BRCTG R5,DRVS0700         Loop to Process the Next Sub Pool ID
*
*+-------------------------------------------------------------------+*
*| Loop Point to Process Storage Subpools for the Next TCB in List   |*
*+-------------------------------------------------------------------+*
*
DRVS3300 DS    0H
         LG    R2,DVSTCBCT         Get the No. of TCB's in Private Area
         LTGR  R2,R2               A Rollover in Remaining TCB Count?
         BRNP  DRVS3500            Yes => Branch to Check Return Code
         BRCTG R2,DRVS3400         No  => Process Next TCB's Subpools
         BRU   DRVS3500            Done, Branch to Check Return Code
DRVS3400 DS    0H
         STG   R2,DVSTCBCT         Save Remaining Priv Area TCB Count
         LLGT  R5,L'VSMDTCB(,R4)   Count for Number of Subpools for TCB
         LA    R4,8(,R4)           Get the Subpool Descriptor Entry
         LG    R6,DVSWKADR         Get Addr to Register Info Work Area
         LG    R1,DVSWKRG#         Register Count in Register Info Area
         STG   R1,DVSREGCT         Set Counter for Processing Reg Area
         BRU   DRVS0700            Loop to Process Subpools of Next TCB
*
*+-------------------------------------------------------------------+*
*| The VSMLIST work area has been processed. Check if all registers  |*
*| have pointers matching a storage area. If yes, no further VSMLIST |*
*| processing required as all general purpose registers of interest  |*
*| have been examined. If no, then check for a return code 04 from   |*
*| VSMLIST to verify if there is any remaining subpool information.  |*
*| If yes for RC=04, then loop to call VSMLIST again as there is     |*
*| additional subpool information pending to be checked against the  |*
*| contents of remaining registers for which a storage address has   |*
*| not yet been found.                                               |*
*+-------------------------------------------------------------------+*
*
DRVS3500 DS    0H
         LG    R1,DVSWKRG#         Register Count in Register Info Area
         LG    R6,DVSWKADR         Get Addr to Register Info Work Area
DRVS3600 DS    0H
         CLI   LRTRGFLG,X'01'      Reg Info Entry Already Processed?
         BRNE  DRVS3700            No  => Process Any Remaining Regs
         AGHI  R6,(LRTRGLEN)       Increment to Next Reg Info Wrk Entry
         BRCTG R1,DRVS3600         Loop to Check the Next Register
         BRU   DRVS4200            VSMLIST Pending But Registers Done
DRVS3700 DS    0H
         LG    R3,DVSRDAT@         Start Addr of Returned Subpool Data
         LLGF  R15,0(,R3)          Get Return Code from VSMLIST Routine
         CGHI  R15,4               Was Partial Information Returned?
         BRE   DRVS0400            Yes => Loop If Only Partial Info
DRVS3800 DS    0H
         BRL   DRVS4000            Full Info Was Returned from VSMLIST
DRVS3900 DS    0H
         BRU   DRVS4100            Error, Branch to Set Condition Code
         DROP  R4                  Remove Listed Reg as VSMLIST Base
DRVS4000 DS    0H
         SLGR  R15,R15             Indicate Successful Completion
         ST    R15,DVSRETCD        Set Highest Return Code Generated
         BRU   DRVS4200            Branch to Process the SQA SubPools
DRVS4100 DS    0H
         LA    R15,8               Serious Error Processng Subpool IDs
         ST    R15,DVSRETCD        Set Highest Return Code Generated
*
*+-------------------------------------------------------------------+*
*| Retain virtual storage old area and release physical paging to    |*
*| clear the portion of the LGRWK2II area which is being re-used as  |*
*| a temporary work area to hold data returned from the VSMLIST call.|*
*+-------------------------------------------------------------------+*
*
DRVS4200 DS    0H
         LLGT  R1,=A(DVSMLTBL)     Addr of VSMLIST Call Sequence Table
         LLILL R2,(L'DVSMLTBL)     Leng of VSMLIST Call Sequence Entry
         LLGF  R3,=A(DVSMLTBL+((DVSTBLNO*L'DVSMLTBL)-L'DVSMLTBL))
         STMG  R1,R3,DVSMTBL@      Save VSMLIST Call Sequence Tbl Parms
DRVS4300 DS    0H
         LGR   R1,RLGW             Get Starting Address to Logger Area
         LLGF  R0,=A(LGW$PVML)     Get Length of the VSMLIST Work Area
         LLGF  R2,=A(LGW$PVSM-LGRWK2II)  Index to the VSMLIST Work Area
         LA    R1,0(R2,R1)         Establish Addr of VSMLIST Work Area
         LGR   R3,R1               Hold Start Addr of VSMLIST Work Area
         LGR   R15,R1              Starting Address of VSMLIST Wrk Area
         AGR   R15,R0              Calculate Ending Address of Wrk Area
         NG    R15,=AD(-4096)      Round Area Down to a Page Boundary
         BCTGR R15,R0              Ensure Pointing to Actual End Addr
         LA    R1,4095(,R1)        Add 4K to Existing Starting Address
         NG    R1,=AD(-4096)       Round It Up to Full Page Boundary
         CGR   R15,R1              Any Page Aligned Areas to Release?
         BRNH  DRVS4400            No  => Branch for a Physical Clear
       PGSER R,RELEASE,            Release the VSMLIST Work Area Pages X
               A=(1),              Starting Address of VSMLIST Wrk AreaX
               EA=(15),            Address of Last Byte in Work Areas  X
               BRANCH=N            Using SVC Entry for Paging Service
         BRU   DRVS4500            Branch to Obtain Virtual Storage Map
DRVS4400 DS    0H
         LGR   R0,R3               Starting Address to VSMLIST Wrk Area
         LLGF  R1,=A(LGW$PVML)     Get Length of the VSMLIST Work Area
         SLGR  R14,R14             Our Sending Area is Nulls
         SLGR  R15,R15             No Length and Pad Character to Zeros
         MVCLE R0,R14,0            Clear VSMLIST + Subpool Summary Area
*
*+-------------------------------------------------------------------+*
*|      Get Subpool Storage Information for CSA, SQA, and LSQA       |*
*+-------------------------------------------------------------------+*
*
DRVS4500 DS    0H
         XC    DVSREGCT,DVSREGCT   Init Entry Count for Reg Info Area
         LLGF  R1,=A(LGW$PVSM-LGRWK2II) Index to the VSMLIST Work Area
         LA    R3,0(R1,RLGW)       Address of Work Area to Return Data
         STG   R3,DVSRDAT@         Save Address of Returned Data Area
DRVS4600 DS    0H
         LG    R3,DVSRDAT@         Get Start Addr of Returned Data Area
         LG    R1,DVSMTBL@         Current VSMLIST Call Sequence Addr
         LG    R1,0(,R1)           VSMLIST Call Sequence is an Offset
         LLGT  R14,=A(DRVS0000)    Base Address to Calculate Entry Addr
         LA    R14,0(R14,R1)       Add Offset to Base for Branch Addr
         BR    R14                 Based on Whether CSA, SQA, or LSQA
DRVS4700 DS    0H
         SAM31                     Switch Now to 31-Bit Addressing Mode
         VSMLIST SP=CSA,           Get Info on Subpools in the CSA AreaX
               SPACE=FREE,         Subpool Info on Allocated+Free SpaceX
               WKAREA=(0(R3),LGW$PVML), Address and Leng of Return AreaX
               LOC=31,             Subpool Info for Areas Below the BarX
               LINKAGE=SYSTEM      Problem State-PC to VSMLIST Routine
         SAM64                     Switch Back to 64-Bit Address Mode
         BRU   DRVS5000            Process Info on Allocation of CSA
DRVS4800 DS    0H
         SAM31                     Switch Now to 31-Bit Addressing Mode
         VSMLIST SP=SQA,           Get Info on Subpools in the SQA AreaX
               SPACE=FREE,         Subpool Info on Allocated+Free SpaceX
               WKAREA=(0(R3),LGW$PVML), Address and Leng of Return AreaX
               LOC=31,             Subpool Info for Areas Below the BarX
               LINKAGE=SYSTEM      Problem State-PC to VSMLIST Routine
         SAM64                     Switch Back to 64-Bit Address Mode
         BRU   DRVS5000            Process Info on Allocation of SQA
DRVS4900 DS    0H
         SAM31                     Switch Now to 31-Bit Addressing Mode
         VSMLIST SP=LSQA,          Get Info on Subpools in LSQA Area   X
               SPACE=FREE,         Subpool Info on Allocated+Free SpaceX
               WKAREA=(0(R3),LGW$PVML), Address and Leng of Return AreaX
               LOC=31,             Subpool Info for Areas Below the BarX
               LINKAGE=SYSTEM      Problem State-PC to VSMLIST Routine
         SAM64                     Switch Back to 64-Bit Address Mode
DRVS5000 DS    0H
         LLGF  R1,0(,R3)           Get Return Code from VSMLIST Routine
         CGHI  R1,4                Was Full or Partial Info Returned?
         BRH   DRVS7800            No  => Exit on a Sub-Pool List Error
*
*+-------------------------------------------------------------------+*
*| Work area has been returned from VSMLIST with the allocated block |*
*| descriptors and the free space descriptors associated with each   |*
*| subpool for the designated area.                                  |*
*+-------------------------------------------------------------------+*
*
         USING VSMD,R4             Addressability to the VSM Descriptor
         USING LRTRGBLK,R6         Addressibility to Register Info Blk
DRVS5100 DS    0H
         LLGT  R1,4(,R3)           Get Address of Returned Data Area
         LLGF  R2,8(,R3)           Get the Length of Returned Data Area
         LA    R15,0(R1,R2)        Calculate Ending Addr of Data Area
         STG   R15,DVSRDATZ        Ending Address of Returned Data Area
         LLGT  R5,0(,R1)           Get the Count for No. of Subpools
         LA    R4,4(,R1)           Get the Subpool Descriptor Entry
DRVS5200 DS    0H
         MVC   DVRVSMID,VSMDID     Get the Subpool Id and Storage Key
         LA    R4,VSMD+L'VSMDSP+L'VSMDTCBP ..Point to Descriptor Count
         LLGF  R3,VSMDCNT          Current Allocated Blk Descriptor Cnt
         LA    R4,VSMD+L'VSMDCNT   Point to Allocated Block Descriptor
         LG    R1,DVSWKRG#         Register Count in Register Info Area
         STG   R1,DVSREGCT         Set Counter for Processing Reg Area
         LG    R6,DVSWKADR         Get Addr to Register Info Work Area
*
*+-------------------------------------------------------------------+*
*| Process the register contents by comparing the value in each      |*
*| register to the storage address in the allocated block descriptor |*
*| to check that if a register value were used as an address would   |*
*| it point into an allocated storage area that is in-use.           |*
*+-------------------------------------------------------------------+*
*
DRVS5300 DS    0H
         LLGF  R14,VSMDAREA        Get Address of This Allocated Block
         LA    R1,VSMD+L'VSMDAREA+L'VSMDCNT Point to Nxt Blk Descriptor
         LLGF  R2,VSMDCNT-VSMD(,R1) ...Get Free Space Descriptors Count
         LTGR  R2,R2               Allocated Block Have Any Free Space?
         BRZ   DRVS5600            No  => All of Allocated Blk is Used
DRVS5400 DS    0H
         LA    R1,L'VSMDCNT(,R1)   Point 1st Free Space Blk Descriptor
         LLGF  R15,VSMDAREA-VSMD(,R1) Get Addr of This Free Space Block
         CLGR  R14,R15             Free Space Area at Beginning of Blk?
         BRNE  DRVS5500            No  => Set End Addr of Allocated Blk
         ALGF  R14,VSMDSIZE-VSMD(,R1) Point to Start Addr of Allocation
         ALGF  R15,VSMDSIZE        Add the Size of This Allocated Block
         BCTGR R15,R0              Point to Last Byte in Allocated Blk
         BRU   DRVS5700            Branch to Check for Storage Address
DRVS5500 DS    0H
         BCTGR R15,R0              Point to Last Byte in Allocated Blk
         BRU   DRVS5700            Check Just The Portion Which is Used
DRVS5600 DS    0H
         LGR   R15,R14             Adr of Allocated Blk to Wrk Register
         ALGF  R15,VSMDSIZE        Add the Size of This Allocated Block
         BCTGR R15,R0              Point to Last Byte in Allocated Blk
DRVS5700 DS    0H
         LG    R7,LRTREGCX         Get the Contents of Current Register
         NILH  R7,(X'7FFF')        Clear Hi-Order Bit of Low Half Reg
         CGR   R7,R14              Reg Content Within This Storage Blk?
         BRL   DRVS6200            No  => Storage Area Not Found
         CGR   R7,R15              Reg Content Within This Storage Blk?
         BRH   DRVS6200            No  => Storage Area Not Found
DRVS5800 DS    0H
         CLI   LRTRGFLG,X'01'      Reg Info Entry Already Processed?
         BRE   DRVS6200            Yes => Branch to Check Next Register
         CLI   LRTREGIN,C' '       Register Information Field Filled?
         BRNE  DRVS6200            Yes => Branch to Check Next Register
*
*+-------------------------------------------------------------------+*
*| Register was found with a pointer into an allocated storage area. |*
*| Extract the storage area attributes of the 4K page, indicate that |*
*| the register value as an address would point into an allocated    |*
*| storage area which is currently being used, and then place this   |*
*| information into the register information work area.              |*
*|                                                                   |*
*| For example:                                                      |*
*|                                                                   |*
*| R2:  000000007FFF958D Allocated storage  Subpool=255 Key=0  Addres|*
*+-------------------------------------------------------------------+*
*
DRVS5900 DS    0H
         MVI   LRTRGFLG,X'01'      Indicate Reg Info Entry Processed
         MVC   LRTALLOC(L'DVSALLOC),DVSALLOC Indicate Allocated Storage
         MVC   LRTSUBPL(L'DVSSUBPL),DVSSUBPL Indicator for Subpool Id
         LLGC  R0,DVRVSMID         Get the Binary Subpool Id
         CVD   R0,DVSWORKD         Decimal Version of Subpool Id
         OI    DVSWORKD+7,15       Certify Sign To Make It Displayable
         UNPK  LRTSUBPL+L'DVSSUBPL(L'LRTSUBPL-L'DVSSUBPL),DVSWORKD+6(2)
DRVS6000 DS    0H
         LLGC  R0,DVRVSMID+L'VSMDID Get Storage Protect Key + Flag Byte
         SRLG  R0,R0,4 Bits        Push Off Flag Bits So Just the Key
         CVD   R0,DVSWORKD         Convert Storage Key Value to Decimal
         LA    R1,DVSFORC1         Preload 1st Forced Result Location
         MVC   DVSWRK08,DVSPATRN   Copy in the Number Editing Pattern
         EDMK  DVSWRK08,DVSWORKD+4 Edit Storage Key Value to Character
         LA    R2,DVSWRK08+L'DVSWRK08-1 Point to End of Edit Work Area
         SGR   R2,R1               Calculate Leng of Storage Key Value
         MVC   LRTSTKEY(L'DVSSTKEY),DVSSTKEY Indicator for Storage Key
         MVC   LRTSTKEY+L'DVSSTKEY(*-*),0(R1)  ...Target of the Execute
         EX    R2,*-6              Storage Protect Key to Reg Info Area
DRVS6100 DS    0H
         LA    R1,1(,R15)          For Length Addressing Starts At Zero
         SGR   R1,R7               Calculate Range from Adr in Register
         BRNP  DRVS6200            Calculation is Forward, Not Backward
         CVDG  R1,DVSSTWRK         Binary Number of Addressable Bytes
         MVC   DVSRANGE,DVSPTRN2   Copy in the Number Editing Pattern
         LA    R1,DVSFORC2         Load 1st Forced Result Char Location
         EDMK  DVSRANGE,DVSSTWRK+9 Edit # of Addressable Bytes to Char
         LA    R2,DVSRANGE+L'DVSRANGE-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of the Bytes Number
         MVC   LRTSTREF(L'DVSSTREF),DVSSTREF Indicate as Storage Range
         MVC   LRTSTREF+L'DVSSTREF(*-*),0(R1) ...Target of Execute
         EX    R2,*-6              Addressable Range of Allocated Area
         LA    R1,LRTSTREF+L'DVSSTREF+2(R2)  ..Point Past Storage Range
         MVC   0(5,R1),=CL5'bytes' Set Trailer Indicating No. of Bytes
*
*+-------------------------------------------------------------------+*
*| Loop Point to Compare the Contents of the Next Register to the    |*
*| Allocated Block Descriptor. Still with the same allocated block   |*
*| descriptor.                                                       |*
*+-------------------------------------------------------------------+*
*
*
DRVS6200 DS    0H
         AGHI  R6,(LRTRGLEN)       Increment to Next Reg Info Wrk Entry
         LG    R1,DVSREGCT         Current Reg Count for Reg Info Area
         BRCTG R1,DRVS6300         Decrement Remaining Cnt for Next Reg
         BRU   DRVS6400            Branch tn Process the Next Register
DRVS6300 DS    0H
         STG   R1,DVSREGCT         Save Count for No. of Regs Remaining
         BRU   DRVS5700            Loop to Process Next Register Entry
DRVS6400 DS    0H
         LA    R4,VSMD+L'VSMDAREA+L'VSMDCNT Point to Nxt Blk Descriptor
         LLGF  R2,VSMDCNT          Get the Free Space Descriptors Count
         LA    R4,VSMD+L'VSMDCNT   Point to Free Space Block Descriptor
         LTGR  R2,R2               Allocated Block Have Any Free Space?
         BRZ   DRVS7200            No  => Check Next Allocated Block
*
*+-------------------------------------------------------------------+*
*| Still with the same allocated block descriptor, and this block    |*
*| descriptor has free space information associated with it. Process |*
*| the register contents by comparing the value in each register to  |*
*| to the storage addresses in the free space block descriptors to   |*
*| check that if a register value were used as an address would it   |*
*| point into an un-used storage area in a partially used page.      |*
*+-------------------------------------------------------------------+*
*
DRVS6500 DS    0H
         LG    R6,DVSWKADR         Get Addr to Register Info Work Area
         LG    R1,DVSWKRG#         Register Count in Register Info Area
         STG   R1,DVSREGCT         Set Counter for Processing Reg Area
         LLGF  R14,VSMDAREA        Get Address of This Allocated Block
         LGR   R15,R14             Addr of Free Space to Work Register
         ALGF  R15,VSMDSIZE        Add the Size of This Free Space Blk
         BCTGR R15,R0              Point to Last Byte in Free Space Blk
DRVS6600 DS    0H
         LG    R7,LRTREGCX         Get the Contents of Current Register
         NILH  R7,(X'7FFF')        Clear Hi-Order Bit of Low Half Reg
         CGR   R7,R14              Reg Content Within This Free Space?
         BRL   DRVS6900            No  => Storage Area Not Found
         CGR   R7,R15              Reg Content Within This Free Space?
         BRH   DRVS6900            No  => Storage Area Not Found
*
*+-------------------------------------------------------------------+*
*| Register was found with a pointer into an un-used storage area of |*
*| a partially used page. Extract the storage area attributes of the |*
*| 4K page, indicate this register value if used as an address would |*
*| point into a free space area, and place this information into the |*
*| register information work area.                                   |*
*|                                                                   |*
*| For example:                                                      |*
*|                                                                   |*
*| R3:  00000000005E68F0 Free space storage Subpool=255 Key=0  Unused|*
*+-------------------------------------------------------------------+*
*
DRVS6700 DS    0H
         MVI   LRTRGFLG,X'01'      Indicate Reg Info Entry Processed
         MVC   LRTALLOC(L'DVSFRESP),DVSFRESP Show as Free Space Storage
         MVC   LRTSUBPL(L'DVSSUBPL),DVSSUBPL Indicator for Subpool Id
         LLGC  R0,DVRVSMID         Get the Binary Subpool Id
         CVD   R0,DVSWORKD         Decimal Version of Subpool Id
         OI    DVSWORKD+7,15       Certify Sign To Make It Displayable
         UNPK  LRTSUBPL+L'DVSSUBPL(L'LRTSUBPL-L'DVSSUBPL),DVSWORKD+6(2)
DRVS6800 DS    0H
         LLGC  R0,DVRVSMID+L'VSMDID Get Storage Protect Key + Flag Byte
         SRLG  R0,R0,4 Bits        Push Off Flag Bits So Just the Key
         CVD   R0,DVSWORKD         Convert Storage Key Value to Decimal
         LA    R1,DVSFORC1         Preload 1st Forced Result Location
         MVC   DVSWRK08,DVSPATRN   Copy in the Number Editing Pattern
         EDMK  DVSWRK08,DVSWORKD+4 Edit Storage Key Value to Character
         LA    R7,DVSWRK08+L'DVSWRK08-1 Point to End of Edit Work Area
         SGR   R7,R1               Calculate Leng of Storage Key Value
         MVC   LRTSTKEY(L'DVSSTKEY),DVSSTKEY Indicator for Storage Key
         MVC   LRTSTKEY+L'DVSSTKEY(*-*),0(R1)  ...Target of the Execute
         EX    R7,*-6              Storage Protect Key to Reg Info Area
         MVC   LRTSTREF(L'DVSUNUSD),DVSUNUSD Indicate as Un-used Space
DRVS6900 DS    0H
         AGHI  R6,(LRTRGLEN)       Increment to Next Reg Info Wrk Entry
         LG    R1,DVSREGCT         Current Reg Count in Reg Info Area
         BRCTG R1,DRVS7000         Decrement Remaining Cnt for Next Reg
         BRU   DRVS7100            Branch to Process Nxt Blk Descriptor
DRVS7000 DS    0H
         STG   R1,DVSREGCT         Save Count for No. of Regs Remaining
         BRU   DRVS6600            Loop to Process Next Register Entry
DRVS7100 DS    0H
         LA    R4,VSMD+L'VSMDAREA+L'VSMDCNT Point to Nxt Blk Descriptor
         BRCTG R2,DRVS6500         Loop to Process Next Free Space Blk
*
*+-------------------------------------------------------------------+*
*| Loop Point to Process the Next Allocated Block Descriptor for     |*
*| this Storage Subpool.                                             |*
*+-------------------------------------------------------------------+*
*
DRVS7200 DS    0H
         LG    R6,DVSWKADR         Get Addr to Register Info Work Area
         LG    R1,DVSWKRG#         Register Count in Register Info Area
         STG   R1,DVSREGCT         Set Counter for Processing Reg Area
         BRCTG R3,DRVS5300         Loop to Next Alloc Descriptor Block
*
*+-------------------------------------------------------------------+*
*| Loop Point to Process Allocated Block Descriptors for Next Subpool|*
*+-------------------------------------------------------------------+*
*
DRVS7300 DS    0H
         LG    R6,DVSWKADR         Get Addr to Register Info Work Area
         LG    R1,DVSWKRG#         Register Count in Register Info Area
         STG   R1,DVSREGCT         Set Counter for Processing Reg Area
         BRCTG R5,DRVS5200         Loop to Process the Next Sub Pool ID
*
*+-------------------------------------------------------------------+*
*| The VSMLIST work area has been processed. Check if all registers  |*
*| have pointers matching a storage area. If yes, no further VSMLIST |*
*| processing required as all general purpose registers of interest  |*
*| have been examined. If no, then check for a return code 04 from   |*
*| VSMLIST to verify if there is any remaining subpool information.  |*
*| If yes for RC=04, then loop to call VSMLIST again as there is     |*
*| additional subpool information pending to be checked against the  |*
*| contents of remaining registers for which a storage address has   |*
*| not yet been found.                                               |*
*+-------------------------------------------------------------------+*
*
DRVS7400 DS    0H
         LG    R1,DVSWKRG#         Register Count in Register Info Area
         LG    R6,DVSWKADR         Get Addr to Register Info Work Area
DRVS7500 DS    0H
         CLI   LRTRGFLG,X'01'      Reg Info Entry Already Processed?
         BRNE  DRVS7600            No  => Process Any Remaining Regs
         AGHI  R6,(LRTRGLEN)       Increment to Next Reg Info Wrk Entry
         BRCTG R1,DRVS7500         Loop to Check the Next Register
         BRU   DRVS4300            VSMLIST Pending But Registers Done
DRVS7600 DS    0H
         LG    R3,DVSRDAT@         Start Addr of Returned Subpool Data
         LLGF  R15,0(,R3)          Get Return Code from VSMLIST Routine
         CGHI  R15,4               Was Partial Information Returned?
         BRE   DRVS4600            Yes => Loop If Only Partial Info
         BRL   DRVS7700            Full Info Was Returned from VSMLIST
         BRU   DRVS7800            Error, Branch to Set Condition Code
         DROP  R4                  Remove Listed Reg as VSMLIST Base
DRVS7700 DS    0H
         SLGR  R15,R15             Indicate Successful Completion
         ST    R15,DVSRETCD        Set Highest Return Code Generated
         BRU   DRVS7900            Branch to Process Next SubPool Range
DRVS7800 DS    0H
         LA    R15,8               Serious Error Processng Subpool IDs
         ST    R15,DVSRETCD        Set Highest Return Code Generated
*
*+-------------------------------------------------------------------+*
*|      Loop Point to Process Subpool Range for the Next Area        |*
*+-------------------------------------------------------------------+*
*
DRVS7900 DS    0H
         LMG   R1,R3,DVSMTBL@      Get VSMLIST Call Sequence Entries
         BRXLG R1,R2,DRVS8000      Increment to the Next Subpool Range
         BRU   DRVS8100            Done, Process Remaining Registers
DRVS8000 DS    0H
         STMG  R1,R3,DVSMTBL@      Save VSMLIST Call Sequence Entries
         BRU   DRVS4300            Loop to Process Next SubPool Range
*
*+-------------------------------------------------------------------+*
*| For any remaining registers for which the contents have not been  |*
*| determined from Contents Supervision or from VSMLIST, check the   |*
*| register value to see if it were used as an address would it still|*
*| happen to point into an accessible storage area.                  |*
*+-------------------------------------------------------------------+*
*
DRVS8100 DS    0H
         LG    R6,DVSWKADR         Get Addr to Register Info Work Area
         LG    R3,DVSWKRG#         Register Count in Register Info Area
         LA    R1,DRVS9000         Get Retry Recovery Address (ESPIE)
         ST    R1,LGWRETRY         Preserve It in Case of an Abend
DRVS8200 DS    0H
         CLI   LRTRGFLG,X'01'      Reg Info Entry Already Processed?
         BRE   DRVS9400            Yes => Branch to Check Next Register
         CLI   LRTREGIN,C' '       Register Information Field Filled?
         BRNE  DRVS9400            Yes => Branch to Check Next Register
DRVS8300 DS    0H
         LG    R4,LRTREGCX         Get the Contents of Current Register
         CLMH  R4,B'1111',=A(X'00000000') Reg Contain a 64-Bit Address?
         BRNE  DRVS8400            Yes => Assume Accessible 64-bit Area
         NILH  R4,(X'7FFF')        No  => Assume Accessible 31-bit Area
         CLGF  R4,=A((PSAEND-PSA)+PSAX_LEN) .Value Within PSA and PSAX?
         BRNH  DRVS8500            No  => Branch to Check Next Register
DRVS8400 DS    0H
         LLGC  R2,0(,R4)           Attempt to Fetch a Byte of Storage
         BRU   DRVS8700            Byte Was Referenced, Check Address
*
*+-------------------------------------------------------------------+*
*|  Process Registers Contents When Pointing to a Low Storage Area   |*
*+-------------------------------------------------------------------+*
*
DRVS8500 DS    0H
         MVI   LRTRGFLG,X'01'      Indicate Reg Info Entry Processed
         MVC   LRTALLOC(L'DVSSTLOW),DVSSTLOW ..Indicate For Low Storage
         MVC   LRTREGIN+L'DVSSTLOW+2(L'DVSDECIM),DVSDECIM ..Show as Dec
         LA    R5,LRTREGIN+L'DVSSTLOW+L'DVSDECIM+2 Point to End of Hdrs
         LG    R0,LRTREGCX         Get the Contents of Current Register
         CVD   R0,DVSSTWRK         Binary No. in Reg to Decimal Format
         MVC   DVSRANGE,DVSPTRN2   Copy in the Number Editing Pattern
         LA    R1,DVSFORC2         Load 1st Forced Result Char Location
         EDMK  DVSRANGE,DVSSTWRK+1 Edit Reg Value as No. Bytes to Char
         LA    R2,DVSRANGE+L'DVSRANGE-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate the Length of Our Number
         MVC   0(*-*,R5),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Show Value in Reg as Decimal Number
         LA    R5,2(R2,R5)         Point Past the Decimal Value Number
         LLILL R1,((PSAEND-PSA)+PSAX_LEN) Set Ending Adr of Prefix Area
         SGR   R1,R4               Calculate Range from Adr in Register
         BRNP  DRVS9400            Calculation is Forward, Not Backward
DRVS8600 DS    0H
         CVD   R1,DVSSTWRK         Binary No. of Addressable Bytes
         MVC   DVSRANGE,DVSPTRN2   Copy in the Number Editing Pattern
         LA    R1,DVSFORC2         Load 1st Forced Result Char Location
         EDMK  DVSRANGE,DVSSTWRK+1 Edit # of Addressable Bytes to Char
         LA    R2,DVSRANGE+L'DVSRANGE-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate Length of the Bytes Number
         MVC   0(L'DVSSTREF,R5),DVSSTREF Hdr to Show Addressable Range
         MVC   L'DVSSTREF(*-*,R5),0(R1)  ...Target of the Execute
         EX    R2,*-6              Addressable Range of Allocated Area
         LA    R1,L'DVSSTREF+2(R2,R5) Point Past Storage Range in Bytes
         MVC   0(5,R1),=CL5'bytes' Set Trailer Indicating No. of Bytes
         BRU   DRVS9400            Area Referenced, Branch to Process
*
*+-------------------------------------------------------------------+*
*|Process Registers Contents When Pointing to Accessible Storage Area|*
*+-------------------------------------------------------------------+*
*
DRVS8700 DS    0H
         CLMH  R4,B'1111',=A(X'00000000') Reg Contain a 64-Bit Address?
         BRE   DRVS8800            No  => Set as Accessible 31-bit Area
         MVI   LRTRGFLG,X'01'      Indicate Reg Info Entry Processed
         MVC   LRTALLOC(L'DVSSTHIH),DVSSTHIH .Indicate For High Storage
         MVC   LRTREGIN+L'DVSSTHIH+2(L'DVSDECIM),DVSDECIM ..Show as Dec
         LA    R5,LRTREGIN+L'DVSSTHIH+L'DVSDECIM+2 Point to End of Hdrs
         LG    R0,LRTREGCX         Get the Contents of Current Register
         CVDG  R0,DVSSTWRK         Binary No. in Reg to Decimal Format
         MVC   DVSHINUM,DVSPTRN3   Copy in the Number Editing Pattern
         LA    R1,DVSFORC3         Load 1st Forced Result Char Location
         EDMK  DVSHINUM,DVSSTWRK   Edit High Number Value to Character
         LA    R2,DVSHINUM+L'DVSHINUM-1  Point to End of Edit Work Area
         SGR   R2,R1               Calculate the Length of Our Number
         MVC   0(*-*,R5),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Show Value in Reg as Decimal Number
         BRU   DRVS9400            Branch to Process the Next Register
DRVS8800 DS    0H
         MVC   LRTREGIN(L'DVS31STO),DVS31STO  Show Storage Referenced
         MVC   LRTREGIN+L'DVS31STO(L'DVSDECIM),DVSDECIM Show as Decimal
         LA    R5,LRTREGIN+L'DVS31STO+L'DVSDECIM Point to End of Headrs
         LG    R0,LRTREGCX         Get the Contents of Current Register
         CVD   R0,DVSSTWRK         Binary No. in Reg to Decimal Format
         MVC   DVSRANGE,DVSPTRN2   Copy in the Number Editing Pattern
         LA    R1,DVSFORC2         Load 1st Forced Result Char Location
         EDMK  DVSRANGE,DVSSTWRK+1 Edit Reg Value as No. Bytes to Char
         BRNM  DRVS8900            Branch if the Result is Positive
         MVI   0(R5),C'-'          Indicate the Number is Negative
         LA    R5,1(,R5)           Increment Past the Minus Character
DRVS8900 DS    0H
         LA    R2,DVSRANGE+L'DVSRANGE-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate the Length of Our Number
         MVC   0(*-*,R5),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Show Value in Reg as Decimal Number
         BRU   DRVS9400            Branch to Process the Next Register
*
*+-------------------------------------------------------------------+*
*|Process Registers Contents When Pointing to Invalid 64-Bit Address |*
*+-------------------------------------------------------------------+*
*
DRVS9000 DS    0H
         CLMH  R4,B'1111',=A(X'00000000') Reg Contain a 64-Bit Address?
         BRE   DRVS9200            No  => Show as Invalid 31-bit Area
         MVC   LRTREGIN(L'DVSNOOBJ),DVSNOOBJ .Not Memory Obj or Guarded
         MVC   LRTREGIN+L'DVSNOOBJ+1(L'DVSDECIM),DVSDECIM ..Show as Dec
         LA    R5,LRTREGIN+L'DVSNOOBJ+L'DVSDECIM+1 Point to End of Hdrs
         LG    R0,LRTREGCX         Get the Contents of Current Register
         CVDG  R0,DVSSTWRK         Binary No. in Reg to Decimal Format
         MVC   DVSHINUM,DVSPTRN3   Copy in the Number Editing Pattern
         LA    R1,DVSFORC3         Load 1st Forced Result Char Location
         EDMK  DVSHINUM,DVSSTWRK   Edit High Number Value to Character
         BRNM  DRVS9100            Branch if the Result is Positive
         MVI   0(R5),C'-'          Indicate the Number is Negative
         LA    R5,1(,R5)           Increment Past the Minus Character
DRVS9100 DS    0H
         LA    R2,DVSHINUM+L'DVSHINUM-1  Point to End of Edit Work Area
         SGR   R2,R1               Calculate the Length of Our Number
         MVC   0(*-*,R5),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Show Value in Reg as Decimal Number
         BRU   DRVS9400            Branch to Process the Next Register
*
*+-------------------------------------------------------------------+*
*|Process Registers Contents When Pointing to Invalid 31-Bit Address |*
*+-------------------------------------------------------------------+*
*
DRVS9200 DS    0H
         MVC   LRTREGIN(L'DVSNOSTO),DVSNOSTO  Show Invalid Storage Area
         MVC   LRTREGIN+L'DVSNOSTO(L'DVSDECIM),DVSDECIM Show as Decimal
         LA    R5,LRTREGIN+L'DVSNOSTO+L'DVSDECIM Point to End of Headrs
         LG    R0,LRTREGCX         Get the Contents of Current Register
         CVD   R0,DVSSTWRK         Binary No. in Reg to Decimal Format
         MVC   DVSRANGE,DVSPTRN2   Copy in the Number Editing Pattern
         LA    R1,DVSFORC2         Load 1st Forced Result Char Location
         EDMK  DVSRANGE,DVSSTWRK+1 Edit Reg Value as No. Bytes to Char
         BRNM  DRVS9300            Branch if the Result is Positive
         MVI   0(R5),C'-'          Indicate the Number is Negative
         LA    R5,1(,R5)           Increment Past the Minus Character
DRVS9300 DS    0H
         LA    R2,DVSRANGE+L'DVSRANGE-1 .Point to End of Edit Work Area
         SGR   R2,R1               Calculate the Length of Our Number
         MVC   0(*-*,R5),0(R1)     Indicated Target of the Execute
         EX    R2,*-6              Show Value in Reg as Decimal Number
*
*+-------------------------------------------------------------------+*
*|      Loop Point to Process the Contents of the Next Register      |*
*+-------------------------------------------------------------------+*
*
DRVS9400 DS    0H
         AGHI  R6,(LRTRGLEN)       Increment to Next Reg Info Wrk Entry
         BRCTG R3,DRVS8200         Loop to Check the Next Register
         XC    LGWRETRY,LGWRETRY   Disable Recovery, Area Referenced
         DROP  R6                  Removed Listed Reg as Reg Info Base
*
*+-------------------------------------------------------------------+*
*|   Return to Caller                                                |*
*+-------------------------------------------------------------------+*
*
DRVSEXIT DS    0H
         LLGF  R15,DVSRETCD        Set the Return Code
         LPGMEXIT RC=DVSRETCD      Define Program Exit Protocol
*
*+-------------------------------------------------------------------+*
*|   Definition for Constants                                        |*
*+-------------------------------------------------------------------+*
*
DVSALLOC DC    C'Allocated storage'  Indicator for Storage Allocated
DVSSTLOW DC    C'Allocated storage  (PSA+PSAE+PSAX)  ' Low Storage
DVSSTHIH DC    C'Allocated storage  Memory object    ' High Storage
DVSFRESP DC    C'Free space storage' Indicator for Free Space Storage
DVSUNUSD DC    C'Unused space in partially used page' Indicator Unused
DVSSUBPL DC    C'Subpool='         Indicator for Subpool Id
DVSSTKEY DC    C'Key='             Indicator for Storage Protect Key
DVSSTTCB DC    C'TCB='             Indicator for TCB Owning Storage
DVSDECIM DC    C'Decimal='         Indicator for Reg Value as Decimal
DVSSTREF DC    C'Addressable storage is ' Indicator for Storage Range
DVS31STO DC    C'Accessible storage Fetch/Read access  ' Fetchable
DVSNOSTO DC    C'(Invalid Storage)  0C4 if referenced  ' Not Storage
DVSNOOBJ DC    C'(No usable memory) 0C4 if referenced '  For Above Bar
DVSPATRN DC    XL8'4020202020202120'  To Use as Pattern for Editing
DVSPTRN2 DC    XL18'40206B2020206B2020206B2020206B202120' .Edit Pattern
DVSPTRN3 DC    XL42'40206B2020206B2020206B2020206B2020206B2020206B20202X
               06B2020206B2020206B2020206B202120'         Edit Pattern
*
DVSMLTBL DS    0D                  VSMLIST Macro Call Offset Table
DVSMCSA$ DC    AD(DRVS4700-DRVS0000) ...VSMLIST Offset Entry for CSA
DVSMSQA$ DC    AD(DRVS4800-DRVS0000) ...VSMLIST Offset Entry for SQA
DVSMLSQA DC    AD(DRVS4900-DRVS0000) ...VSMLIST Offset Entry for LSQA
DVSMTBLN EQU   (*-DVSMLTBL)        Length of VSMLIST Call Offset Table
DVSTBLNO EQU   (*-DVSMLTBL)/L'DVSMLTBL No. of Entries in VSMLIST Table
*
*+-------------------------------------------------------------------+*
*|    Program RENT Work Area                                         |*
*+-------------------------------------------------------------------+*
*
         LCA   DEFINE              Define the Program RENT Work Area
*
DVSWORKD DS    10D                 General Purpose Work Area
DVSPLIST DS    20FD                CALL Parameter List
DVSWKADR DS    AD                  Start Addr to Register Info Wrk Area
DVSWKRG# DS    FD                  Register Count in Register Info Area
DVSREGCT DS    FD                  Current Count in Reg Info Work Area
DVSRDAT@ DS    AD                  Start Addr of Returned Subpool Data
DVSRDATZ DS    AD                  Ending Addr of Returned Subpool Data
DVSMTBL@ DS    3AD                 VSMLIST Call Sequence Address Table
DVSTCBCT DS    FD                  TCB Count for Returned Subpool Data
DVSRETCD DS    F                   Save Area for the Return Code
DVRTCBSP DS    A                   Address of TCB for Subpool Storage
DVRVSMID DS    CL(L'VSMDID+L'VSMDKEY) ...Subpool Id and Storage Key
DVSWRK08 DS    CL(L'DVSPATRN)      Work Area for Editing Decimal Values
DVSFORC1 EQU   *-1                 Set 1st Forced Result Char Location
         DS    XL1                 Slack for Reverse of Low Order Byte
DVSSTWRK DS    2D                  Subpool Storage Range Work Area
DVSRANGE DS    CL(L'DVSPTRN2)      Work Area for Editing Decimal Values
DVSFORC2 EQU   *-1                 First Forced Result Char Location
DVSHINUM DS    CL(L'DVSPTRN3)      Work Area for High No. to Character
DVSFORC3 EQU   *-1                 First Forced Result Char Location
*
         LCA   DEFEND              Define End of Program RENT Work Area
*
***********************************************************************
*         End of Register to Virtual Storage Area Processing          *
***********************************************************************
         EJECT ,
***********************************************************************
**************************+-----------------+**************************
**************************| D R U S 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|D e t e r m i n e   R e g s   U s e d   I n   I n s t r u c t i o n|*
*+-------------------------------------------------------------------+*
* PROGRAM NAME:    DRUS0000                                           *
*                                                                     *
* FUNCTION:        Determine Registers Used in Abending Instruction   *
*                                                                     *
*                  This routine is responsible for determining the    *
*                  registers used in the abending instruction. This   *
*                  routine is passed the address of a register        *
*                  information work area containing a detail line for *
*                  each of the sixteen general purpose registers. The *
*                  format of the abending instruction is analyzed, and*
*                  any designated, index, or base registers which     *
*                  were explicitly specified in the instruction will  *
*                  be identified by prefixing a 'D', 'X', or 'B' to   *
*                  the register number detail line in the register    *
*                  summary report. Also, any implied registers used in*
*                  the instruction such as the use of an even/odd pair*
*                  will be identified by prefixing an 'O' to the odd  *
*                  register. If by hardware convention an implied     *
*                  register was used in the instruction then it will  *
*                  be identified by prefixing an 'H' to the appropiate*
*                  register number detail line in the register info   *
*                  work area. This process is performed only for the  *
*                  general purpose registers used in an instruction   *
*                  for the general purpose register summary report.   *
*                                                                     *
* For example: Any registers referenced by the abending instruction in*
*              the user's program are to be identified in the general *
*              purpose register summary report by prefixing the       *
*              register detail line with a B, D, X, O or H depending  *
*              on the instruction type.                               *
*              |                                                      *
* +------------+                                                      *
* |                                                                   *
* |                                                                   *
* | R0:  0000000098988AB8 Load Module/Csect  IGGCSI00+(000000)  Decima*
* D-R1:  0000000000000001 Allocated storage  (PSA+PSAE+PSAX)    Decima*
* B-R2:  0000004A80000800 Allocated storage  Memory object      Decima*
* X-R3:  00000000FAC00000 (Invalid Storage)  0C4 if referenced  Decima*
*   R4:  0000000000007FF4 Allocated storage  Subpool=003 Key=8  TCB=00*
*   R5:  0000000000000189 Allocated storage  (PSA+PSAE+PSAX)    Decima*
*   R6:  FFFFFFFFFFFFFE78 (No memory object or a guard area)    Decima*
*   R7:  0000000018909B28 Load Module/Csect  SVLTEST7+(008E70)  Decima*
*   R8:  0000000018908B28 Load Module/Csect  SVLTEST7+(007E70)  Decima*
*   R9:  000000000004BB38 Free space storage Subpool=000 Key=8  TCB=00*
*   R10: 000000000004AB38 Allocated storage  Subpool=003 Key=8  TCB=00*
*   R11: 0000000018901CC4 Load Module/Csect  SVLTEST7+(00100C)  Decima*
*   R12: 0000000018900CC4 Load Module/Csect  SVLTEST7+(00000C)  Decima*
*   R13: 0000000000007000 Allocated storage  Subpool=003 Key=8  TCB=00*
*   R14: 0000000018913214 Load Module/Csect  SVLTEST7+(01255C)  Decima*
*   R15: 0000000083358BC0 Load Module/Csect  IEFDB475+(000BC0)  Decima*
*                                                                     *
*  '?-Rx:' Used as a designated (D), index (X), base (B), odd (O) of  *
*          an even/odd pair, or hardware implied (H) register in      *
*          abending instruction STH                                   *
*                                                                     *
*                                                                     *
* INPUT REGS:      R1 => Standard O/S Parameter List                  *
*                                                                     *
* INPUT DATA:      Parm1: Pointer to Address of Address of Field for  *
*                         Address of Target Instruction of Execute    *
*                  Parm2: Pointer to Address of Machine Table Entry   *
*                  Parm3: Pointer to Address of Abending Instruction  *
*                  Parm4: Address of Register Information Work Area   *
*                  Parm5: Register Count in Register Info Work Area   *
*                  Parm6: Address of System Diagnostic Work Area      *
*                  Parm7: Address of LGRWK2II Logger Work Area        *
*                  Parm8: Addr of Common Constants and Routines Area  *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY, AC=0                          *
*                                                                     *
* CALLING PROGRAM: DREG0000 - Logger Services Program to Process the  *
*                             Contents of Registers at Entry to Abend *
*                                                                     *
* CALLED PROGRAMS: None                                               *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                  04 - Warning                                       *
*                  08 - Error                                         *
*                  12 - Severe Error - Exit This Routine              *
*                                                                     *
***********************************************************************
*
DRUS0000 LPGMNTRY TYPE=SUB,        Define As A Sub-Program Entry       X
               BASE=(12,11),       Establish Base Registers            X
               AMOD=64,RMOD=ANY,   Addressing and Residency Modes      X
               LCAPFX=DRU,         Establish LCA Prefix for This RSECT X
               LOG=OFF,            Always Turn Logging 'Off' in Logger!X
               LINKRTRN=BSM,       Define Return Linkage Instruction   X
               COPY@RT=YES         To Generate a Copyright Statement
         USING COM_DATA,RCOMM      Addressability to Common Data Area
         USING LGRWK2II,RLGW       Establish Addressability to LGRWK2II
         USING SDWA,RSDW           Establish Addressability to SDWA
         USING IHADCB,LGWODCB      Establish Addressability to DCB
         LMG   R3,R10,0(R1)        Load the Parameter Area Addresses
         STMG  R3,R7,DRUPARM@      Save Contents of Passed Parameters
         XC    DRURETCD,DRURETCD   Initialize the Return Code
*
*+-------------------------------------------------------------------+*
*| Process For Registers Used in the Abending Instruction Based on   |*
*| the Format of the Abending Instruction.                           |*
*+-------------------------------------------------------------------+*
*
         USING OP@CODES,R3         Addressability Machine Instructions
         USING LRTRGBLK,R4         Addressibility to Register Info Blk
DRUS0100 DS    0H
         LA    R1,DRUSEXIT         Get Retry Recovery Address (ESPIE)
         ST    R1,LGWRETRY         Preserve It In Case of an Abend
         LG    R3,DRUMCHI@         Get Pointer to Machine Table Address
         LG    R3,0(,R3)           Get Address to Machine Table Entry
         LTGR  R3,R3               Is a Machine Table Entry Available?
         BRZ   DRUSEXIT            No  => Branch to Exit This Routine
         LG    R4,DRUWKADR         Start Addr to Register Info Wrk Area
         LG    R5,DRUTARG@         Pointer to Addr of Instruction Addr
         LG    R5,0(,R5)           Get Addr to Addr of Abending Instruc
         LG    R5,0(,R5)           Addr of Target of Abending Instructn
         LTGR  R5,R5               Is There an Addr for Target Instruc?
         BRZ   DRUS0150            No  => Then Instruc Not Target of EX
         CLI   0(R5),X'0'          Is Our Indicated Op Code a Zero?
         BRNE  DRUS0200            No  => Then Instruct Target of an EX
DRUS0150 DS    0H
         LG    R5,DRUABND@         Pointer to Abending Instruction Addr
         LG    R5,0(,R5)           Get Address to Abending Instruction
DRUS0200 DS    0H
         LLGC  R14,OP@OPRND        Obtain Leng in Bytes of Instruction
         MVC   DRUINSTR(*-*),0(R5) Target of Following EX Instruction
         EX    R14,*-6             Move the Instruction to a Work Area
         XC    LGWRETRY,LGWRETRY   Disable Recovery, Area Referenced
         LLGC  R15,OP@OFSET        Get Offset for Instruction Format
         SLLG  R15,R15,2 Bits      Multiple by 4 for Branch Table Entry
DRUS0300 DS    0H
         B     *+4(R15)            Branch Based on Instruction Format
         BRU   DRUS0400            Instruction Format E, I, RI-c, RIL-c
         BRU   DRUS0600            Instruction Format RI-a and RI-b
         BRU   DRUS0700            Instruction Format RIE-a,c, RIL-a,b
         BRU   DRUS0800            Instruction Format RIE-b and RIE-f
         BRU   DRUS0900            Instruction Format RIE-d,e and RSI
         BRU   DRUS1000            Instruction Format RIS
         BRU   DRUS1100            Instruction Format RR
         BRU   DRUS1700            Instruction Format RRD
         BRU   DRUS2000            Instruction Format RRE
         BRU   DRUS3000            Instruction Format RRF-a,b
         BRU   DRUS3300            Instruction Format RRF-c,d
         BRU   DRUS3300            Instruction Format RRF-e
         BRU   DRUS5000            Instruction Format RRS
         BRU   DRUS6000            Instruction Format RS-a and RS-b
         BRU   DRUS7000            Instruction Format RSL
         BRU   DRUS8000            Instruction Format RSY-a and RSY-b
         BRU   DRUS9000            Instruction Format RX-a and RX-b
         BRU   DRU10000            Instruction Format RXE
         BRU   DRU11000            Instruction Format RXF
         BRU   DRU12000            Instruction Format RXY-a and RXY-b
         BRU   DRU13000            Instruction Format S
         BRU   DRU14000            Instruction Format SIL
         BRU   DRU14000            Instruction Format SI
         BRU   DRU14000            Instruction Format SIY
         BRU   DRU15000            Instruction Format SS-a
         BRU   DRU15000            Instruction Format SS-b
         BRU   DRU15000            Instruction Format SS-c
         BRU   DRU15000            Instruction Format SS-f
         BRU   DRU16000            Instruction Format SS-d
         BRU   DRU16000            Instruction Format SS-e
         BRU   DRU17000            Instruction Format SSE
         BRU   DRU18000            Instruction Format SSF
*
*+-------------------------------------------------------------------+*
*|   Perform Processing for the type E, I, RI-c, and RIL-c Formats   |*
*+-------------------------------------------------------------------+*
*
DRUS0400 DS    0H
         CLC   OP@TYPE,=CL6'I'     Is This Format for an SVC?
         BRE   DRUSEXIT            No  => Then No Further Processing
         CLC   OP@TYPE,=CL6'RI-c'  Is This Format for a BRC Instructn?
         BRE   DRUSEXIT            No  => Then No Further Processing
         CLC   OP@TYPE,=CL6'RIL-c' Is This Format for a BRCL/PFDRL?
         BRE   DRUSEXIT            No  => Then No Further Processing
         CLC   OP@MCHCD,=XL2'0101' This for Program Return Instruction?
         BRE   DRUSEXIT            Yes => Then No Further Processing
         CLC   OP@MCHCD,=XL2'010C' For Set Addressimg Mode 24 (SAM24)?
         BRE   DRUSEXIT            Yes => Then No Further Processing
         CLC   OP@MCHCD,=XL2'010D' For Set Addressing Mode 31 (SAM31)?
         BRE   DRUSEXIT            Yes => Then No Further Processing
         CLC   OP@MCHCD,=XL2'010E' For Set Addressing Mode 64 (SAM64)?
         BRE   DRUSEXIT            Yes => Then No Further Processing
         CLC   OP@MCHCD,=XL2'01FF' Is This for a TRAP2 Instruction?
         BRE   DRUSEXIT            Yes => Then No Further Processing
         MVI   LRTREGUS-LRTRGBLK(R4),C'H' By Hardware Convention Reg0
         MVI   LRTREGUS-LRTRGBLK+1(R4),C'-' ..Hyphen to Highlight Reg
         CLC   OP@MCHCD,=XL2'0107' Set Clock Programable Field (SCKPF)?
         BRE   DRUSEXIT            Yes => Then R0 only by HW Convention
         MVI   (LRTREGUS-LRTRGBLK)+PRNTLEN(R4),C'H' Hardware Uses Reg1
         MVI   (LRTREGUS-LRTRGBLK+1)+PRNTLEN(R4),C'-' ..Highlight Reg
DRUS0500 DS    0H
         CLC   OP@MCHCD,=XL2'0102' This for an Update Tree Instruction?
         BRNE  DRUSEXIT            No  => Then No Further Processing
         MVI   LRTREGUS-LRTRGBLK(R4),C'H' By Hardware Convention Reg0
         MVI   LRTREGUS-LRTRGBLK+1(R4),C'-' ..Hyphen to Highlight Reg
         MVI   (LRTREGUS-LRTRGBLK)+PRNTLEN(R4),C'H' Hardware Uses Reg1
         MVI   (LRTREGUS-LRTRGBLK+1)+PRNTLEN(R4),C'-' ..Highlight Reg
         LLILL R1,(2)              Set the Register Number for R2
         LLGFR R5,R1               Our Current Register No. to Work Reg
         MGHI  R5,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R5,R4) Point to Reg Info Work Area
         MVI   0(R5),C'H'          R2 Used by Hardware in Instruction
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         LA    R1,1(,R1)           Increment to Next Register as R3
         LLGFR R5,R1               Our Current Register No. to Work Reg
         MGHI  R5,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R5,R4) Point to Reg Info Work Area
         MVI   0(R5),C'H'          R3 Used by Hardware in Instruction
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         LA    R1,1(,R1)           Increment to Next Register as R4
         LLGFR R5,R1               Our Current Register No. to Work Reg
         MGHI  R5,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R5,R4) Point to Reg Info Work Area
         MVI   0(R5),C'H'          R4 Used by Hardware in Instruction
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         LA    R1,1(,R1)           Increment to Next Register as R5
         LLGFR R5,R1               Our Current Register No. to Work Reg
         MGHI  R5,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R5,R4) Point to Reg Info Work Area
         MVI   0(R5),C'H'          R5 Used by Hardware in Instruction
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done For This Format, Branch to Exit
*
*+-------------------------------------------------------------------+*
*|Perform processing for type RI-a and RI-b instruction format.      |*
*|                                                                   |*
*| RI1 / RI-a                      RI2 / RI-b                        |*
*| +----------------------+        +----------------------+          |*
*| |Op Code|R1|Op|   I2   |        |Op Code|R1|Op|   RI2  |          |*
*| +----------------------+        +----------------------+          |*
*| 0        8  12 16     31        0        8  12 16     31          |*
*+-------------------------------------------------------------------+*
*
DRUS0600 DS    0H
         LLGC  R1,DRUINSTR+1       Get Byte from Abending Instruction
         SRLG  R1,R1,4 Bits        Shift Out Op Code to Isolate the R1
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'D'          Designated R1 Reg Used for Instructn
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
*
*+-------------------------------------------------------------------+*
*|Perform processing for the type RIE-a, REI-c, RIL-a, and RIL-b     |*
*|instruction formats. These formats may be subject to abends for    |*
*|storage access or operation exceptions if the extended-immediate   |*
*|facility or the general-instructions-extension facility is not     |*
*|installed.                                                         |*
*|                                                                   |*
*| RIE1 / RIE-a                     RIE3 / RIE-c                     |*
*| +------------------------------+ +------------------------------+ |*
*| |Op Code|R1|--|I2|M3|--|Op Code| |Op Code|R1|M3|RI4 |I2 |Op Code| |*
*| +------------------------------+ +------------------------------+ |*
*|  0       8  12 16 32 36 40    47  0       8  12 16   32  40    47 |*
*|                                                                   |*
*| RIL1 / RIL-a                     RIL2 / RIL-b                     |*
*| +------------------------------+ +------------------------------+ |*
*| |Op Code|R1|Op|      I2        | |Op Code|R1|Op|      RI2       | |*
*| +------------------------------+ +------------------------------+ |*
*|  0       8  12 16             47  0       8  12 16             47 |*
*+-------------------------------------------------------------------+*
*
DRUS0700 DS    0H
         LLGC  R1,DRUINSTR+1       Get Byte from Abending Instruction
         SRLG  R1,R1,4 Bits        Shift Out Slack Bits, Isolate the R1
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'D'          Designated R1 Reg Used for Instructn
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
*
*+-------------------------------------------------------------------+*
*|Perform processing for the type RIE-b and REI-f instruction format.|*
*|These instruction types may be subject to an operation exception if|*
*|the general-instructions-extension facility is not installed.      |*
*|                                                                   |*
*| RIE2 / RIE-b                     RIE5 / RIE-f                     |*
*| +------------------------------+ +------------------------------+ |*
*| |Op Code|R1|R2|I4|M3|--|Op Code| |Op Code|R1|R2|I3|I4|I5|Op Code| |*
*| +------------------------------+ +------------------------------+ |*
*|  0       8  12 16 32 36 40    47  0       8  12 16 24 32 40    47 |*
*+-------------------------------------------------------------------+*
*
DRUS0800 DS    0H
         UNPK  DRUWORKD(5),DRUINSTR+1(2) ...Get the R1 and R2 Registers
         LLGC  R1,DRUWORKD+2       Get Just the R1 Designated Register
         NILL  R1,(X'0F0F')        Remove Zone Where Digit is Our Reg
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'D'          Designated R1 Reg Used for Instructn
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         LLGC  R1,DRUWORKD+3       Get Just the R2 Designated Register
         NILL  R1,(X'0F0F')        Remove Zone Where Digit is Our Reg
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'D'          Designated R2 Reg Used for Instructn
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
*
*+-------------------------------------------------------------------+*
*|Perform processing for type RIE4 and RSI instruction format.       |*
*|                                                                   |*
*| RIE4 / RIE-d                      RSI                             |*
*| +------------------------------+  +-------------------+           |*
*| |Op Code|R1|R3| I2  |--|Op Code|  |Op Code|R1|R3| RI2 |           |*
*| +------------------------------+  +-------------------+           |*
*|  0       8  12 16    32 40    47   0       8  12 16  31           |*
*+-------------------------------------------------------------------+*
*
DRUS0900 DS    0H
         UNPK  DRUWORKD(5),DRUINSTR+1(2) ...Get the R1 and R3 Registers
         LLGC  R1,DRUWORKD+2       Get Just the R1 Designated Register
         NILL  R1,(X'0F0F')        Remove Zone Where Digit is Our Reg
         LGR   R5,R1               Copy Result to a Work Register
         MGHI  R5,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R5,R4) Point to Reg Info Work Area
         MVI   0(R5),C'D'          Designated R1 Reg Used for Instructn
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         LLGC  R2,DRUWORKD+3       Get Just the R3 Designated Register
         NILL  R2,(X'0F0F')        Remove Zone Where Digit is Our Reg
         LGR   R5,R2               Copy Result to a Work Register
         MGHI  R5,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R5,R4) Point to Reg Info Work Area
         MVI   0(R5),C'D'          Designated R3 Reg Used for Instructn
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         CLC   OP@MNEUM(2),=CL2'BR' This a Branch Relative Instruction?
         BRNE  DRUSEXIT            No  => Then No Implied Register Pair
         TMLL  R2,X'0001'          Is R3 Operand an Even No. Register?
         BRO   DRUSEXIT            No  => Does not Designate a Reg Pair
         LA    R1,1(,R2)           Point to Odd Reg in Even/Odd Pair
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R5),C'O'          Implied Odd R3+1 Reg for Instruction
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done with This Format, Exit Routine
*
*+-------------------------------------------------------------------+*
*| Perform processing for the type RIS instruction format.           |*
*|                                                                   |*
*| RIS                                                               |*
*| +------------------------------+                                  |*
*| |Op Code|R1|M3|B4|D4|I2|Op Code|                                  |*
*| +------------------------------+                                  |*
*|  0       8  12 16 20 32 40    47                                  |*
*+-------------------------------------------------------------------+*
*
DRUS1000 DS    0H
         LLGC  R1,DRUINSTR+1       Get Byte from Abending Instruction
         SRLG  R1,R1,4 Bits        Shift Out M3 Mask to Isolate the R1
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'D'          Designated R1 Reg Used for Instructn
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         LLGC  R1,DRUINSTR+2       Get Byte from Abending Instruction
         SRLG  R1,R1,4 Bits        Shift Out the D4 Part to Isolate B4
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'B'          Base B4 Used in Abending Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
*
*+-------------------------------------------------------------------+*
*| Perform processing for type RR instruction format.                |*
*|                                                                   |*
*|  RR                                                               |*
*|  +-----------------+                                              |*
*|  |Op Code|R1  |R2  |                                              |*
*|  +-----------------+                                              |*
*|   0       8    12 15                                              |*
*+-------------------------------------------------------------------+*
*
DRUS1100 DS    0H
         CLC   OP@TYPE,=CL6'RR'    This a Register to Register Format?
         BRNE  DRUSEXIT            No  => Branch to Exit This Routine
         CLC   OP@MCHCD,=XL2'2000' A Floating Point Instruction Group?
         BRNL  DRUSEXIT            Yes => Do Not Show FP Reg as GP Reg
         UNPK  DRUWORKD(5),DRUINSTR+1(2) ...Get the R1 and R2 Registers
         LLGC  R1,DRUWORKD+2       Get Just the R1 Designated Register
         NILL  R1,(X'000F')        Remove Zone Where Digit is Our Reg
         LGR   R5,R1               Copy Result to a Work Register
         MGHI  R5,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R5,R4) Point to Reg Info Work Area
         MVI   0(R5),C'D'          Designated R1 Reg Used for Instructn
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         LLGC  R2,DRUWORKD+3       Get Just the R2 Designated Register
         NILL  R2,(X'000F')        Remove Zone Where Digit is Our Reg
         LGR   R5,R2               Copy Result to a Work Register
         MGHI  R5,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R5,R4) Point to Reg Info Work Area
         MVI   0(R5),C'D'          Designated R2 Reg Used for Instructn
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
DRUS1200 DS    0H
         CLC   OP@MCHCD,=XL2'1D00' Implied Registers (Even/Odd Pair)?
         BRE   DRUS1300            Yes => DR Instr Uses E/O Pair on R1
         CLC   OP@MCHCD,=XL2'1C00' Implied Registers (Even/Odd Pair)?
         BRE   DRUS1300            Yes => MR Instr Uses E/O Pair on R1
         CLC   OP@MCHCD,=XL2'0F00' Implied Registers (Even/Odd Pair)?
         BRE   DRUS1400            Yes => CLCL Uses E/O Pair on R1/R2
         CLC   OP@MCHCD,=XL2'0E00' Implied Registers (Even/Odd Pair)?
         BRE   DRUS1400            Yes => MVCL Uses E/O Pair on R1/R2
         BRU   DRUSEXIT            Remaining to Show Only Explicit Regs
DRUS1300 DS    0H
         LA    R1,1(,R1)           Point to Odd Reg in Even/Odd Pair
         LLGFR R15,R1              Hold Designated Reg No. in Work Reg
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R5),C'O'          Implied Odd R1+1 Reg for Instruction
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         TMLL  R15,(X'0001')       Our Designated R1+1 an Odd Register?
         BRO   DRUSEXIT            Yes => Reg Adjacent to R1 Was Odd
         MVI   1(R5),C'*'          Indicate Even/Odd Reg Pair Mismatch
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
DRUS1400 DS    0H
         LA    R1,1(,R1)           Point to Odd Reg in Even/Odd Pair
         LLGFR R15,R1              Hold Designated Reg No. in Work Reg
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R5),C'O'          Implied Odd R1+1 Reg for Instruction
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         TMLL  R15,(X'0001')       Our Designated R1+1 an Odd Register?
         BRO   DRUS1500            Yes => Reg Adjacent to R1 Was Odd
         MVI   1(R5),C'*'          Indicate Even/Odd Reg Pair Mismatch
DRUS1500 DS    0H
         LA    R2,1(,R2)           Point to R2+1 Reg in Even/Odd Pair
         LLGFR R15,R2              Hold Designated Reg No. in Work Reg
         MGHI  R2,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R2,R4) Point to Reg Info Work Area
         MVI   0(R5),C'O'          Implied R2+1 Odd Reg for Instruction
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         TMLL  R15,(X'0001')       Our Designated R2+1 an Odd Register?
         BRO   DRUSEXIT            Yes => Reg Adjacent to R2 Was Odd
         MVI   1(R5),C'*'          Indicate Even/Odd Reg Pair Mismatch
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
*
*+-------------------------------------------------------------------+*
*| Perform processing for type RRD instruction format.               |*
*|                                                                   |*
*| RRD                                                               |*
*| +-----------------------------+                                   |*
*| |  Op Code  |R1 |---|R3  |R2  |                                   |*
*| +-----------------------------+                                   |*
*|  0           16  20  24   28 31                                   |*
*+-------------------------------------------------------------------+*
*
DRUS1700 DS    0H
         CLC   OP@MCHCD(1),=XL1'B3' Part of a FltPnt Instruction Group?
         BRE   DRUSEXIT            Yes => For Now RRD Only Includes FP
         UNPK  DRUWORKD(5),DRUINSTR+3(2) ...Get the R3 and R2 Registers
         LLGC  R1,DRUWORKD+2       Get Just the R3 Designated Register
         NILL  R1,(X'000F')        Remove Zone Where Digit is Our Reg
         LGR   R5,R1               Copy Result to a Work Register
         MGHI  R5,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R5,R4) Point to Reg Info Work Area
         MVI   0(R5),C'D'          Designated R3 Reg Used for Instructn
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         LLGC  R2,DRUWORKD+3       Get Just the R2 Designated Register
         NILL  R2,(X'000F')        Remove Zone Where Digit is Our Reg
         LGR   R5,R2               Copy Result to a Work Register
         MGHI  R5,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R5,R4) Point to Reg Info Work Area
         MVI   0(R5),C'D'          Designated R2 Reg Used for Instructn
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         LLGC  R5,DRUINSTR+2       Get the R1 Operand Register Value
         SRLG  R5,R5,4 Bits        Remove Unused Operand So Only the R1
         MGHI  R5,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R5,R4) Point to Reg Info Work Area
         MVI   0(R5),C'D'          Designated R1 Reg Used for Instructn
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
*
*+-------------------------------------------------------------------+*
*| Perform processing for type RRE instruction format.               |*
*|                                                                   |*
*| RRE                                                               |*
*| +----------------------------+                                    |*
*| |  Op Code  |------|R1+ |R2+ |                                    |*
*| +----------------------------+                                    |*
*|  0           16     24   28 31                                    |*
*+-------------------------------------------------------------------+*
*
DRUS2000 DS    0H
         CLC   OP@MCHCD(1),=XL1'B3' Part of a FltPnt Instruction Group?
         BRE   DRUSEXIT            Yes => Do Not Show FP Regs as GP Reg
         CLC   OP@MNEUM,=CL7'DXR'  Divide Extended Hexidecimal FntPnt?
         BRE   DRUSEXIT            Yes => Do Not Show FP Regs as GP Reg
         CLC   OP@MNEUM,=CL7'SQER' Square Root Short Hexidecimal FltPt?
         BRE   DRUSEXIT            Yes => Do Not Show FP Regs as GP Reg
         CLC   OP@MNEUM,=CL7'SQDR' Square Root Long Hexidecimal FltPnt?
         BRE   DRUSEXIT            Yes => Do Not Show FP Regs as GP Reg
         CLC   OP@MNEUM,=CL7'CSP'  Compare Swap and Purge Instruction?
         BRE   DRUS2200            Yes => This One Uses E/O Pair on R1
         CLC   OP@MNEUM,=CL7'CSPG' This Compare Swap and Purge Grande?
         BRE   DRUS2200            Yes => This One Uses E/O Pair on R1
         CLC   OP@MNEUM,=CL7'DLR'  Divide Logical (Even/Odd Pair)?
         BRE   DRUS2200            Yes => This One Uses E/O Pair on R1
         CLC   OP@MNEUM,=CL7'DLGR' Divide Logical (Even/Odd Pair)?
         BRE   DRUS2200            Yes => This One Uses E/O Pair on R1
         CLC   OP@MNEUM,=CL7'DSGR' Divide Single (Even/Odd Pair)?
         BRE   DRUS2200            Yes => This One Uses E/O Pair on R1
         CLC   OP@MNEUM,=CL7'DSGFR' Divide Single Fwrd (Even/Odd Pair)?
         BRE   DRUS2200            Yes => This One Uses E/O Pair on R1
         CLC   OP@MNEUM,=CL7'ESTA' Extract Stacked State Instruction?
         BRE   DRUS2200            Yes => This One Uses E/O Pair on R1
         CLC   OP@MNEUM,=CL7'FLOGR' Find Leftmost One (Even/Odd Pair)?
         BRE   DRUS2200            Yes => This One Uses E/O Pair on R1
         CLC   OP@MNEUM,=CL7'MLR'  Multiply Logical (Even/Odd Pair)?
         BRE   DRUS2200            Yes => This One Uses E/O Pair on R1
         CLC   OP@MNEUM,=CL7'MLGR' Multiply Logical (Even/Odd Pair)?
         BRE   DRUS2200            Yes => This One Uses E/O Pair on R1
         CLC   OP@MNEUM,=CL7'TRE'  Translate Extended (Even/Odd Pair)?
         BRE   DRUS2200            Yes => This One Uses E/O Pair on R1
         CLC   OP@MNEUM,=CL7'CKSM' Checksum (Even/Odd Pair)?
         BRE   DRUS2400            Yes => Uses an E/O Pair on R2
         CLC   OP@MNEUM,=CL7'KM'   Cipher Message (E/O Pair)?
         BRE   DRUS2400            Yes => Uses an E/O Pair on R2
         CLC   OP@MNEUM,=CL7'KMC'  Cipher Msg w/Chaining (E/O Pair)?
         BRE   DRUS2400            Yes => Uses an E/O Pair on R2
         CLC   OP@MNEUM,=CL7'KMF'  Cipher Msg w/Feedback (E/O Pair)?
         BRE   DRUS2400            Yes => Uses an E/O Pair on R2
         CLC   OP@MNEUM,=CL7'KMO'  Cipher Msg w/Feedback (E/O Pair)?
         BRE   DRUS2400            Yes => Uses an E/O Pair on R2
         CLC   OP@MNEUM,=CL7'KIMD' Compute Msg Digest (Even/Odd Pair)?
         BRE   DRUS2400            Yes => Uses an E/O Pair on R2
         CLC   OP@MNEUM,=CL7'KLMD' Compute Msg Digest (Even/Odd Pair)?
         BRE   DRUS2400            Yes => Uses an E/O Pair on R2
         CLC   OP@MNEUM,=CL7'KMAC' Compute Msg Auth (Even/Odd Pair)?
         BRE   DRUS2400            Yes => Uses an E/O Pair on R2
         CLC   OP@MNEUM,=CL7'CMPSC' Compression Call (Even/Odd Pair)?
         BRE   DRUS2600            Yes => Uses E/O Pair on R1 and R2
         CLC   OP@MNEUM,=CL7'CUSE' Compare Substring (Even/Odd Pair)?
         BRE   DRUS2600            Yes => Uses E/O Pair on R1 and R2
         CLC   OP@MNEUM,=CL7'CU41' Convert UTF-32/8 (Even/Odd Pair)?
         BRE   DRUS2600            Yes => Uses E/O Pair on R1 and R2
         CLC   OP@MNEUM,=CL7'CU42' Convert UTF-32/16 (Even/Odd Pair)?
         BRE   DRUS2600            Yes => Uses E/O Pair on R1 and R2
         CLC   OP@MNEUM,=CL7'MVPG' This for a Move Page Instructionen?
         BRE   DRUS2900            Yes => R0 by Hardware Convention
         CLC   OP@MNEUM,=CL7'PALB' This for Purge ART-Lookaside Buffer
         BRE   DRUSEXIT            Yes => Then No Further Processing
         CLC   OP@MNEUM,=CL7'PCC'  Perform Cryptographic Computation?
         BRE   DRUS2800            Yes => Uses R0 and R1 by Hardware
         CLC   OP@MNEUM,=CL7'PCKMO' Perform Crypto Key Mgmt Operation
         BRE   DRUS2800            Yes => Uses R0 and R1 by Hardware
         CLC   OP@MNEUM,=CL7'PTLB' A Purge Translate Lookaside Buffer?
         BRE   DRUSEXIT            Yes => Then No Further Processing
DRUS2100 DS    0H
         UNPK  DRUWORKD(5),DRUINSTR+3(2) ...Get the R1 and R2 Registers
         LLGC  R1,DRUWORKD+2       Get Just the R1 Designated Register
         NILL  R1,(X'000F')        Remove Zone Where Digit is Our Reg#
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'D'          Designated R1 Reg Used for Instructn
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         CLC   OP@MNEUM,=CL7'PTF'  This for Perform Topology Function?
         BRE   DRUS2800            Yes => Then Only uses R1 with RRE
         LLGC  R2,DRUWORKD+3       Get Just the R2 Designated Register
         NILL  R2,(X'000F')        Remove Zone Where Digit is Our Reg#
         MGHI  R2,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R2,LRTREGUS-LRTRGBLK(R2,R4) Point to Reg Info Work Area
         MVI   0(R2),C'D'          Designated R2 Reg Used for Instructn
         MVI   1(R2),C'-'          Fill with a Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
DRUS2200 DS    0H
         UNPK  DRUWORKD(5),DRUINSTR+3(2) ...Get the R1 and R2 Registers
         LLGC  R1,DRUWORKD+2       Get Just the R1 Designated Register
         NILL  R1,(X'000F')        Remove Zone Where Digit is Our Reg#
         LGR   R5,R1               Copy Result to a Work Register
         MGHI  R5,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R5,R4) Point to Reg Info Work Area
         MVI   0(R5),C'D'          Designated R1 Reg Used for Instructn
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         LLGC  R2,DRUWORKD+3       Get Just the R2 Designated Register
         NILL  R2,(X'000F')        Remove Zone Where Digit is Our Reg#
         MGHI  R2,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R2,LRTREGUS-LRTRGBLK(R2,R4) Point to Reg Info Work Area
         MVI   0(R2),C'D'          Designated R2 Reg Used for Instructn
         MVI   1(R2),C'-'          Fill with a Hyphen to Highlight Reg
         LA    R1,1(,R1)           Point to Odd Reg in R1 Even/Odd Pair
         LLGFR R15,R1              Hold Designated Reg No. in Work Reg
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'O'          Implied R1+1 Odd Reg for Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         TMLL  R15,(X'0001')       Our Designated R1+1 an Odd Register?
         BRO   DRUS2300            Yes => Reg Adjacent to R1 Was Odd
         MVI   1(R1),C'*'          Indicate Even/Odd Reg Pair Mismatch
DRUS2300 DS    0H
         CLC   OP@MNEUM,=CL7'TRE'  A Translate Extended Instruction?
         BRNE  DRUSEXIT            No  => Then Branch to Exit Routine
         MVI   LRTREGUS-LRTRGBLK(R4),C'H' By Hardware Convention Use R0
         MVI   LRTREGUS-LRTRGBLK+1(R4),C'-' Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
DRUS2400 DS    0H
         UNPK  DRUWORKD(5),DRUINSTR+3(2) ...Get the R1 and R2 Registers
         LLGC  R1,DRUWORKD+2       Get Just the R1 Designated Register
         NILL  R1,(X'000F')        Remove Zone Where Digit is Our Reg
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'D'          Designated R1 Reg Used for Instructn
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         LLGC  R2,DRUWORKD+3       Get Just the R2 Designated Register
         NILL  R2,(X'000F')        Remove Zone Where Digit is Our Reg
         LGR   R5,R2               Copy Result to a Work Register
         MGHI  R5,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R5,R4) Point to Reg Info Work Area
         MVI   0(R5),C'D'          Designated R2 Reg Used for Instructn
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         LA    R2,1(,R2)           Point to Odd Reg in R2 Even/Odd Pair
         LLGFR R15,R2              Hold Designated Reg No. in Work Reg
         MGHI  R2,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R2,LRTREGUS-LRTRGBLK(R2,R4) Point to Reg Info Work Area
         MVI   0(R2),C'O'          Implied R2+1 Odd Reg for Instruction
         MVI   1(R2),C'-'          Fill with a Hyphen to Highlight Reg
         TMLL  R15,(X'0001')       Our Designated R2+1 an Odd Register?
         BRO   DRUS2500            Yes => Reg Adjacent to R2 Was Odd
         MVI   1(R2),C'*'          Indicate Even/Odd Reg Pair Mismatch
DRUS2500 DS    0H
         CLC   OP@MNEUM,=CL7'CKSM' Is This a Checksum Instruction?
         BRE   DRUSEXIT            Yes => Then no Further Processing
         MVI   LRTREGUS-LRTRGBLK(R4),C'H' ..Hardware Implies Register 0
         MVI   LRTREGUS-LRTRGBLK+1(R4),C'-' ..Hyphen to Highlight Reg
         LA    R5,PRNTLEN(,R4)     Point to Register 1 Line in Wrk Area
         MVI   LRTREGUS-LRTRGBLK(R5),C'H' ..Hardware Implies Register 1
         MVI   LRTREGUS-LRTRGBLK+1(R5),C'-' ..Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
DRUS2600 DS    0H
         UNPK  DRUWORKD(5),DRUINSTR+3(2) ...Get the R1 and R2 Registers
         LLGC  R1,DRUWORKD+2       Get Just the R1 Designated Register
         NILL  R1,(X'000F')        Remove Zone Where Digit is Our Reg
         LGR   R5,R1               Copy Result to a Work Register
         MGHI  R5,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R5,R4) Point to Reg Info Work Area
         MVI   0(R5),C'D'          Designated R1 Reg Used for Instructn
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         LLGC  R2,DRUWORKD+3       Get Just the R2 Designated Register
         NILL  R2,(X'000F')        Remove Zone Where Digit is Our Reg
         LGR   R5,R2               Copy Result to a Work Register
         MGHI  R5,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R5,R4) Point to Reg Info Work Area
         MVI   0(R5),C'D'          Designated R2 Reg Used for Instructn
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         LA    R1,1(,R1)           Point to Odd Reg in R1 Even/Odd Pair
         LLGFR  R15,R1             Hold Designated Reg No. in Work Reg
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'O'          Implied R1+1 Odd Reg for Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         TMLL  R15,(X'0001')       Our Designated R1+1 an Odd Register?
         BRO   DRUS2700            Yes => Reg Adjacent to R1 Was Odd
         MVI   1(R1),C'*'          Indicate Even/Odd Reg Pair Mismatch
DRUS2700 DS    0H
         LA    R2,1(,R2)           Point to Odd Reg in Even/Odd Pair
         LLGFR R15,R2              Hold Designated Reg No. in Work Reg
         MGHI  R2,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R2,LRTREGUS-LRTRGBLK(R2,R4) Point to Reg Info Work Area
         MVI   0(R2),C'O'          Implied R2+1 Odd Reg for Instruction
         MVI   1(R2),C'-'          Fill with a Hyphen to Highlight Reg
         TMLL  R15,(X'0001')       Our Designated R1+1 an Odd Register?
         BRO   DRUS2800            Yes => Reg Adjacent to R1 Was Odd
         MVI   1(R2),C'*'          Indicate Even/Odd Reg Pair Mismatch
DRUS2800 DS    0H
         MVI   LRTREGUS-LRTRGBLK(R4),C'H' Hardware Convention Uses Reg0
         MVI   LRTREGUS-LRTRGBLK+1(R4),C'-' ..Hyphen to Highlight Reg
         LA    R5,PRNTLEN(,R4)     Point to Register 1 Line in Wrk Area
         MVI   LRTREGUS-LRTRGBLK(R5),C'H' Hardware Convention Uses Reg1
         MVI   LRTREGUS-LRTRGBLK+1(R5),C'-' ..Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
DRUS2900 DS    0H
         MVI   LRTREGUS-LRTRGBLK(R4),C'H' Hardware Convention Uses Reg0
         MVI   LRTREGUS-LRTRGBLK+1(R4),C'-' ..Hyphen to Highlight Reg
         UNPK  DRUWORKD(5),DRUINSTR+3(2) ...Get the R1 and R2 Registers
         LLGC  R1,DRUWORKD+2       Get Just the R1 Designated Register
         NILL  R1,(X'000F')        Remove Zone Where Digit is Our Reg#
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'D'          Designated R1 Reg Used for Instructn
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         LLGC  R2,DRUWORKD+3       Get Just the R2 Designated Register
         NILL  R2,(X'000F')        Remove Zone Where Digit is Our Reg#
         MGHI  R2,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R2,LRTREGUS-LRTRGBLK(R2,R4) Point to Reg Info Work Area
         MVI   0(R2),C'D'          Designated R2 Reg Used for Instructn
         MVI   1(R2),C'-'          Fill with a Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
*
*+-------------------------------------------------------------------+*
*| Perform processing for type RRF-a and RRF-b variation instruction |*
*| format.                                                           |*
*|                                                                   |*
*| RRF3 / RRF-a,b                                                    |*
*| +----------------------------+                                    |*
*| |  Op Code  |R3|M4+|R1  |R2  |                                    |*
*| +----------------------------+                                    |*
*|  0           16 20  24   28 31                                    |*
*+-------------------------------------------------------------------+*
*
DRUS3000 DS    0H
         CLC   OP@MCHCD(1),=XL1'B3' Part of a FltPnt Instruction Group?
         BRE   DRUSEXIT            Yes => Do Not Show FP Regs as GP Reg
         LLGC  R1,DRUINSTR+2       Get Byte from Abending Instruction
         SRLG  R1,R1,4 Bits        Shift Out Unused M4 Mask to Set R3
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'D'          Designated R3 Reg Used for Instructn
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         UNPK  DRUWORKD(5),DRUINSTR+3(2) ...Get the R1 and R2 Registers
         LLGC  R1,DRUWORKD+2       Get Just the R1 Designated Register
         NILL  R1,(X'000F')        Remove Zone Where Digit is Our Reg
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'D'          Designated R1 Reg Used for Instructn
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         LLGC  R2,DRUWORKD+3       Get Just the R2 Designated Register
         NILL  R2,(X'000F')        Remove Zone Where Digit is Our Reg
         LGR   R5,R2               Designated R2 Reg No. to a Work Reg
         MGHI  R5,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R5,R4) Point to Reg Info Work Area
         MVI   0(R5),C'D'          Designated R2 Reg Used for Instructn
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         CLC   OP@MCHCD,=XL2'B92D' Cipher Msg with Counter Instruction?
         BRNE  DRUSEXIT            No  => Done for This Instructn Group
DRUS3100 DS    0H
         LA    R2,1(,R2)           Point to Odd Reg in R2 Even/Odd Pair
         LLGFR R15,R2              Hold Designated Reg No. in Work Reg
         MGHI  R2,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R2,LRTREGUS-LRTRGBLK(R2,R4) Point to Reg Info Work Area
         MVI   0(R2),C'O'          Implied R2+1 Odd Reg for Instruction
         MVI   1(R2),C'-'          Fill with a Hyphen to Highlight Reg
         TMLL  R15,(X'0001')       Our Designated R2+1 an Odd Register?
         BRO   DRUS3200            Yes => Reg Adjacent to R2 Was Odd
         MVI   1(R2),C'*'          Indicate Even/Odd Reg Pair Mismatch
DRUS3200 DS    0H
         MVI   LRTREGUS-LRTRGBLK(R4),C'H' ..Hardware Implies Register 0
         MVI   LRTREGUS-LRTRGBLK+1(R4),C'-' ..Hyphen to Highlight Reg
         LA    R5,PRNTLEN(,R4)     Point to Register 1 Line in Wrk Area
         MVI   LRTREGUS-LRTRGBLK(R5),C'H' ..Hardware Implies Register 1
         MVI   LRTREGUS-LRTRGBLK+1(R5),C'-' ..Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
*
*+-------------------------------------------------------------------+*
*| Perform processing for type RRF-c, RRF-d, and RRF-e variation     |*
*| instruction formats.                                              |*
*|                                                                   |*
*| RRF2 / RRF-c                     RRF2 / RRF-d                     |*
*| +------------------------------+ +------------------------------+ |*
*| |  Op Code  | M3+|---| R1 | R2 | |  Op Code  |----|M4 | R1 | R2 | |*
*| +------------------------------+ +------------------------------+ |*
*|  0           16   20  24   28 31  0           16   20  24   28 31 |*
*|                                                                   |*
*| RRF2 / RRF-e                                                      |*
*| +------------------------------+                                  |*
*| |  Op Code  | M3 |M4+| R1 | R2 |                                  |*
*| +------------------------------+                                  |*
*|  0           16   20  24   28 31                                  |*
*+-------------------------------------------------------------------+*
*
DRUS3300 DS    0H
         UNPK  DRUWORKD(5),DRUINSTR+3(2) ...Get the R1 and R2 Registers
         TM    OP@REGAT,OP@FPGP1   FltPt Instructn Use R1 as a GP Reg?
         BRNZ  DRUS3400            Yes => R1 Used as Generl Purpose Reg
         TM    OP@REGAT,OP@FPGP2   FltPnt Instructn Use R2 as a GP Reg?
         BRNZ  DRUS3500            Yes => R2 Used as Generl Purpose Reg
         BRU   DRUS3600            Yes => Process Remaining Instructns
DRUS3400 DS    0H
         LLGC  R1,DRUWORKD+2       Get Just the R1 Designated Register
         NILL  R1,(X'000F')        Remove Zone Where Digit is Our Reg
         LGR   R5,R1               Copy Result to a Work Register
         MGHI  R5,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R5,R4) Point to Reg Info Work Area
         MVI   0(R5),C'D'          Designated R1 Reg Used for Instructn
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         BRU   DRUSEXIT            No  => Done for This Format, Exit
DRUS3500 DS    0H
         LLGC  R2,DRUWORKD+3       Get Just the R2 Designated Register
         NILL  R2,(X'000F')        Remove Zone Where Digit is Our Reg
         LGR   R5,R2               Copy Result to a Work Register
         MGHI  R5,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R5,R4) Point to Reg Info Work Area
         MVI   0(R5),C'D'          Designated R2 Reg Used for Instructn
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         BRU   DRUSEXIT            No  => Done for This Format, Exit
DRUS3600 DS    0H
         CLC   OP@TYPE,=CL6'RRF-c' This for General Instructions Group?
         BRE   DRUS3700            Yes => Branch to Process Instruction
         CLC   OP@MCHCD,=XL2'B3EB' A Convert to Signed Packed Extended?
         BRE   DRUS3700            Yes => 128-bit Result to GP E/O Pair
         BRU   DRUSEXIT            No  => Do Not Show FP Regs as GP Reg
DRUS3700 DS    0H
         LLGC  R1,DRUWORKD+2       Get Just the R1 Designated Register
         NILL  R1,(X'000F')        Remove Zone Where Digit is Our Reg
         LGR   R5,R1               Copy Result to a Work Register
         MGHI  R5,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R5,R4) Point to Reg Info Work Area
         MVI   0(R5),C'D'          Designated R1 Reg Used for Instructn
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         CLC   OP@MCHCD,=XL2'B3EB'  Convert to Signed Packed Extended?
         BRE   DRUS3900            Yes => 128-bit Result to GP E/O Pair
DRUS3800 DS    0H
         LLGC  R2,DRUWORKD+3       Get Just the R2 Designated Register
         NILL  R2,(X'000F')        Remove Zone Where Digit is Our Reg
         LGR   R5,R2               Copy Result to a Work Register
         MGHI  R5,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R5,R4) Point to Reg Info Work Area
         MVI   0(R5),C'D'          Designated R2 Reg Used for Instructn
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
DRUS3900 DS    0H
         TM    OP@REGEO,X'15'      Even/Odd Register Pair Attributes?
         BRZ   DRUSEXIT            No  => Done for This Format, Exit
         LA    R1,1(,R1)           Point to Odd Reg in R1 Even/Odd Pair
         LLGFR R15,R1              Hold Designated Reg No. in Work Reg
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'O'          Implied R1+1 Odd Reg for Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         TMLL  R15,(X'0001')       Our Designated R1+1 an Odd Register?
         BRO   DRUS4000            Yes => Reg Adjacent to R1 Was Odd
         MVI   1(R1),C'*'          Indicate Even/Odd Reg Pair Mismatch
DRUS4000 DS    0H
         TM    OP@REGEO,X'04'      Uses a R1+R2 Even/Odd Register Pair?
         BRZ   DRUS4100            No  => Check if Hardware Implied Reg
         LA    R2,1(,R2)           Point to Odd Reg in Even/Odd Pair
         LLGFR R15,R2              Hold Designated Reg No. in Work Reg
         MGHI  R2,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R2,LRTREGUS-LRTRGBLK(R2,R4) Point to Reg Info Work Area
         MVI   0(R2),C'O'          Implied R2+1 Odd Reg for Instruction
         MVI   1(R2),C'-'          Fill with a Hyphen to Highlight Reg
         TMLL  R15,(X'0001')       Our Designated R2+1 an Odd Register?
         BRO   DRUSEXIT            Yes => Done for This Format, Exit
         MVI   1(R2),C'*'          Indicate Even/Odd Reg Pair Mismatch
DRUS4100 DS    0H
         CLC   OP@MNEUM,=CL7'TRTE' Is This Translate and Test Extended?
         BRE   DRUS4200            Yes => Then Uses Hardware Implied R1
         CLC   OP@MNEUM,=CL7'TRTRE' Translate and Tst Reverse Extended?
         BRE   DRUS4200            Yes => Then Uses Hardware Implied R1
         CLC   OP@MNEUM,=CL7'TROO' Is This a Translate One to One?
         BRE   DRUS4300            Yes => Uses Hardware Implied R0+R1
         CLC   OP@MNEUM,=CL7'TROT' Is This a Translate One to Two?
         BRE   DRUS4300            Yes => Uses Hardware Implied R0+R1
         CLC   OP@MNEUM,=CL7'TRTO' Is This a Translate Two to One?
         BRE   DRUS4300            Yes => Uses Hardware Implied R0+R1
         CLC   OP@MNEUM,=CL7'TRTT' Is This a Translate Two to Two?
         BRE   DRUS4300            Yes => Uses Hardware Implied R0+R1
         BRU   DRUSEXIT            No  => Done With This Format, Exit
DRUS4200 DS    0H
         LA    R5,PRNTLEN(,R4)     Point to Register 1 Line in Wrk Area
         MVI   LRTREGUS-LRTRGBLK(R5),C'H' ..Hardware Implies Register 1
         MVI   LRTREGUS-LRTRGBLK+1(R5),C'-' ..Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
DRUS4300 DS    0H
         MVI   LRTREGUS-LRTRGBLK(R4),C'H' ..Hardware Implies Register 0
         MVI   LRTREGUS-LRTRGBLK+1(R4),C'-' ..Hyphen to Highlight Reg
         LA    R5,PRNTLEN(,R4)     Point to Register 1 Line in Wrk Area
         MVI   LRTREGUS-LRTRGBLK(R5),C'H' ..Hardware Implies Register 1
         MVI   LRTREGUS-LRTRGBLK+1(R5),C'-' ..Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
*
*+-------------------------------------------------------------------+*
*| Perform processing for the type RRS format instruction.           |*
*|                                                                   |*
*| RRS                                                               |*
*| +---------------------------------+                               |*
*| |Op Code|R1|R2|B4|D4|M3|--|Op Code|                               |*
*| +---------------------------------+                               |*
*|  0       8  12 16 20 32 36 40    47                               |*
*+-------------------------------------------------------------------+*
*
DRUS5000 DS    0H
         UNPK  DRUWORKD(5),DRUINSTR+1(2) ...Get the R1 and R2 Registers
         LLGC  R1,DRUWORKD+2       Get Just the R1 Designated Register
         NILL  R1,(X'000F')        Remove Zone Where Digit is Our Reg
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R5),C'D'          Designated R1 Reg Used in Instructn
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         LLGC  R2,DRUWORKD+3       Get Just the R2 Designated Register
         NILL  R2,(X'000F')        Remove Zone Where Digit is Our Reg
         MGHI  R2,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R2,R4) Point to Reg Info Work Area
         MVI   0(R5),C'D'          Designated R2 Reg Used in Instructn
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         LLGC  R1,DRUINSTR+2       Get the B4/D4 Portion of Instruction
         SRLG  R1,R1,4 Bits        Shift Out the D4 Part to Isolate B4
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'B'          Show B4 Base Reg Used in Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
*
*+-------------------------------------------------------------------+*
*| Perform processing for type RS-a and RS-b variation instruction   |*
*| format.                                                           |*
*|                                                                   |*
*| RS1 / RS-a                       RS2 / RS-b                       |*
*| +------------------------+       +------------------------+       |*
*| |Op Code|R1 |R3 |B2 |D2  |       |Op Code|R1 |M3 |B2 |D2  |       |*
*| +------------------------+       +------------------------+       |*
*|  0       8   12  16  20 31        0       8   12  16  20 31       |*
*+-------------------------------------------------------------------+*
*
DRUS6000 DS    0H
         CLC   OP@TYPE,=CL6'RS-b'  Variation-2 RS-b Instruction Format?
         BRE   DRUS6100            Yes => Process CLM, STCM, and ICM
         CLC   OP@MCHCD,=XL2'8800' This a Shift Right Single Logical?
         BRE   DRUS6200            Yes => R1 is the Only Designated Reg
         CLC   OP@MCHCD,=XL2'8900' This a Shift Left Single Logical?
         BRE   DRUS6200            Yes => R1 is the Only Designated Reg
         CLC   OP@MCHCD,=XL2'8A00' This a Shift Right Single Algebraic?
         BRE   DRUS6200            Yes => R1 is the Only Designated Reg
         CLC   OP@MCHCD,=XL2'8B00' This a Shift Left Single Algebraic?
         BRE   DRUS6200            Yes => R1 is the Only Designated Reg
         CLC   OP@MCHCD,=XL2'9A00' A Load Access Multiple Instruction?
         BRE   DRUS6600            Yes => B2 Only Gen Purpose Reg Used
         CLC   OP@MCHCD,=XL2'9B00' A Store Access Multiple Instruction?
         BRE   DRUS6600            Yes => B2 Only Gen Purpose Reg Used
         CLC   OP@MCHCD,=XL2'B600' This a Store Control Instruction?
         BRE   DRUS6600            Yes => B2 Only Gen Purpose Reg Used
         CLC   OP@MCHCD,=XL2'B700' This a Load Control Instruction?
         BRE   DRUS6600            Yes => B2 Only Gen Purpose Reg Used
         TM    OP@REGEO,OP@R1EOP   Instruction Group with R1 E/O Pair?
         BRO   DRUS6300            Yes => Then R1 Used as an E/O Pair
         TM    OP@REGEO,OP@R12EO   Uses a R1+R3 Even/Odd Register Pair?
         BRNZ  DRUS6700            Yes => R1+R3 Must be Even or EO Pair
         BRU   DRUS6400            No  => Then Process Instruction
DRUS6100 DS    0H
         LLGC  R1,DRUINSTR+1       Get Byte from Abending Instruction
         SRLG  R1,R1,4 Bits        Shift Out M3 Mask to Isolate the R1
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'D'          Designated R1 Reg Used in Instructn
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         LLGC  R1,DRUINSTR+2       Get Byte from Abending Instruction
         SRLG  R1,R1,4 Bits        Shift Out the D2 Part to Isolate B2
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'B'          The Base B2 Reg Used for Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
DRUS6200 DS    0H
         LLGC  R1,DRUINSTR+1       Get Byte from Abending Instruction
         SRLG  R1,R1,4 Bits        Shift Out to Isolate Designated R1
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'D'          Designated R1 Reg Used in Instructn
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         BRU   DRUSEXIT            Only Rightmost 6 Bits Used in B2/D2
DRUS6300 DS    0H
         LLGC  R1,DRUINSTR+1       Get Byte from Abending Instruction
         SRLG  R1,R1,4 Bits        Shift Out to Isolate Designated R1
         LGR   R5,R1               Copy Result to a Work Register
         MGHI  R5,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R5,R4) Point to Reg Info Work Area
         MVI   0(R5),C'D'          Designated R1 in Abending Instructn
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         LA    R1,1(,R1)           Point to Odd Reg in R1 Even/Odd Pair
         LLGFR R15,R1              Hold Designated Reg No. in Work Reg
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'O'          Implied Odd R1+1 Used in Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         TMLL  R15,(X'0001')       Our Designated R1+1 an Odd Register?
         BRO   DRUSEXIT            Yes => Done With Instruction Format
         MVI   1(R1),C'*'          Indicate Even/Odd Reg Pair Mismatch
         BRU   DRUSEXIT            Only Rightmost 6 Bits Used in B2/D2
DRUS6400 DS    0H
         UNPK  DRUWORKD(5),DRUINSTR+1(2) ...Get the R1 and R3 Registers
         LLGC  R1,DRUWORKD+2       Get Just the R1 Designated Register
         NILL  R1,(X'000F')        Remove Zone Where Digit is Our Reg
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R5),C'D'          Designated R1 Reg Used in Instructn
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         LLGC  R2,DRUWORKD+3       Get Just the R3 Designated Register
         NILL  R2,(X'000F')        Remove Zone Where Digit is Our Reg
         LGR   R15,R2              Hold the R3 Number in Work Register
         MGHI  R2,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R2,R4) Point to Reg Info Work Area
         MVI   0(R5),C'D'          Designated R3 Reg Used in Instructn
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         LLGC  R1,DRUINSTR+2       Get the B2/D2 Portion of Instruction
         SRLG  R1,R1,4 Bits        Shift Out the D2 Part to Isolate B2
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'B'          The Base B2 Reg Used for Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         CLC   OP@MCHCD,=XL2'8600' This a Branch on Index High?
         BRE   DRUS6500            Yes => Check for Even Numbered R3
         CLC   OP@MCHCD,=XL2'8700' Branch on Index Less Than or Equal?
         BRNE  DRUSEXIT            No  => Done for This Format, Exit
DRUS6500 DS    0H
         TMLL  R15,X'0001'         R3 Specified as an Even Register?
         BRNZ  DRUSEXIT            No  => Then Done for This Instructn
         AGHI  R15,(1)             Yes => Set to Adjoining Odd Register
         MGHI  R15,(PRNTLEN)       Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R15,R4) Point to Reg Info Work Area
         MVI   0(R5),C'O'          R3+1 Register Implied in Instruction
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
DRUS6600 DS    0H
         LLGC  R1,DRUINSTR+2       Get the B2/D2 Portion of Instruction
         SRLG  R1,R1,4 Bits        Shift Out the D2 Part to Isolate B2
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'B'          The Base B2 Reg Used for Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
DRUS6700 DS    0H
         UNPK  DRUWORKD(5),DRUINSTR+1(2) ...Get the R1 and R3 Registers
         LLGC  R1,DRUWORKD+2       Get Just the R1 Designated Register
         NILL  R1,(X'000F')        Remove Zone Where Digit is Our Reg
         LGR   R5,R1               Copy Result to a Work Register
         MGHI  R5,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R5,R4) Point to Reg Info Work Area
         MVI   0(R5),C'D'          Designated R1 Reg Used in Instructn
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         LLGC  R2,DRUWORKD+3       Get Just the R3 Designated Register
         NILL  R2,(X'000F')        Remove Zone Where Digit is Our Reg
         LGR   R5,R2               Copy Result to a Work Register
         MGHI  R5,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R5,R4) Point to Reg Info Work Area
         MVI   0(R5),C'D'          Designated R3 Reg Used in Instructn
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         LA    R1,1(,R1)           Point to Odd Reg in R1 Even/Odd Pair
         LLGFR R15,R1              Hold Designated Reg No. in Work Reg
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'O'          Implied R1+1 Odd Reg in Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         TMLL  R15,(X'0001')       Our Designated R1+1 an Odd Register?
         BRO   DRUS6800            Yes => Reg Adjacent to R1 Was Odd
         MVI   1(R1),C'*'          Indicate Even/Odd Reg Pair Mismatch
DRUS6800 DS    0H
         LA    R2,1(,R2)           Point to Odd Reg in Even/Odd Pair
         LLGFR R15,R2              Hold Designated Reg No. in Work Reg
         MGHI  R2,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R2,LRTREGUS-LRTRGBLK(R2,R4) Point to Reg Info Work Area
         MVI   0(R2),C'O'          Implied R3+1 Odd Reg in Instruction
         MVI   1(R2),C'-'          Fill with a Hyphen to Highlight Reg
         TMLL  R15,(X'0001')       Our Designated R3+1 an Odd Register?
         BRO   DRUS6900            Yes => R3+1 Reg is Odd, Check for B2
         MVI   1(R2),C'*'          Indicate Even/Odd Reg Pair Mismatch
DRUS6900 DS    0H
         CLC   OP@MNEUM,=CL7'CDS'  Compare Double and Swap Instruction?
         BRNE  DRUSEXIT            No  => For Other B2/D2 is a Pad Byte
         LLGC  R1,DRUINSTR+2       Get Byte from Abending Instruction
         SRLG  R1,R1,4 Bits        Shift Out the D2 Part to Isolate B2
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'B'          The Base B2 Reg Used for Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
*
*+-------------------------------------------------------------------+*
*| Perform processing for the type RSL instruction format.           |*
*|                                                                   |*
*| RSL                                                               |*
*| +------------------------------+                                  |*
*| |Op Code|L1|--|B2|D2|--|Op Code|                                  |*
*| +------------------------------+                                  |*
*|  0       8  12 16 20 32 40    47                                  |*
*+-------------------------------------------------------------------+*
*
DRUS7000 DS    0H
         LLGC  R1,DRUINSTR+2       Get Byte from Abending Instruction
         SRLG  R1,R1,4 Bits        Shift Out the D2 Part to Isolate B2
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'B'          The Base B2 Reg Used for Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
*
*+-------------------------------------------------------------------+*
*| Perform processing for the type RSY-a and type RSY-b variation    |*
*| instruction format.                                               |*
*|                                                                   |*
*| RSY1 / RSY-a                                                      |*
*| +--------------------------------+                                |*
*| |Op Code|R1|R3|B2|DL2|DH2|Op Code|                                |*
*| +--------------------------------+                                |*
*|  0       8  12 16 20  32  40    47                                |*
*|                                                                   |*
*| RSY2 / RSY-b                                                      |*
*| +--------------------------------+                                |*
*| |Op Code|R1|M3|B2|DL2|DH2|Op Code|                                |*
*| +--------------------------------+                                |*
*|  0       8  12 16 20  32  40    47                                |*
*+-------------------------------------------------------------------+*
*
DRUS8000 DS    0H
         CLC   OP@TYPE,=CL6'RSY-b' RSY-b Variation Instruction Format?
         BRE   DRUS8900            Yes => Process Instructns Using Mask
         CLC   OP@MCHCD,=XL2'EB0A' Is This for Shift Instruction Group?
         BRL   DRUS8100            No  => Keeping Checking Instructions
         CLC   OP@MCHCD,=XL2'EB0D' Is This for Shift Instruction Group?
         BRNH  DRUS8400            Yes => B2/DL2 Not Used for Address
         CLC   OP@MCHCD,=XL2'EBDC' This Shift Distinct Instructn Group?
         BRL   DRUS8100            No  => Keeping Checking Instructions
         CLC   OP@MCHCD,=XL2'EBDF' This Shift Distinct Instructn Group?
         BRNH  DRUS8400            Yes => B2/DL2 Not Used for Address
DRUS8100 DS    0H
         CLC   OP@MCHCD,=XL2'EB1C' This for Rotate Left Single Logical?
         BRE   DRUS8400            Yes => B2/DL2 Not Used for Address
         CLC   OP@MCHCD,=XL2'EB1D' This for Rotate Left Single Logical?
         BRE   DRUS8400            Yes => B2/DL2 Not Used for Address
         CLC   OP@MCHCD,=XL2'EB31' A Compare Double and Swap (Long)?
         BRE   DRUS8600            Yes => Uses an R1 and R3 E/O Pair
         CLC   OP@MCHCD,=XL2'EB3E' A Compare Double and Swap (Grande)?
         BRE   DRUS8600            Yes => Uses an R1 and R3 E/O Pair
         CLC   OP@MCHCD,=XL2'EB8E' This a Move Character Long Unicode?
         BRE   DRUS8600            Yes => Uses an R1 and R3 E/O Pair
         CLC   OP@MCHCD,=XL2'EB8F' This Compare Character Long Unicode?
         BRE   DRUS8600            Yes => Uses an R1 and R3 E/O Pair
         CLC   OP@MCHCD,=XL2'EB9A' This for a Load Access Multiple?
         BRE   DRUS8500            Yes => B2 Only Gen Purpose Reg Used
         CLC   OP@MCHCD,=XL2'EB9B' This for a Store Access Multiple?
         BRE   DRUS8500            Yes => B2 Only Gen Purpose Reg Used
         CLC   OP@MCHCD,=XL2'EB25' This for Store Control Instruction?
         BRE   DRUS8500            Yes => B2 Only Gen Purpose Reg Used
         CLC   OP@MCHCD,=XL2'EB2F' This for a Load Control Instruction?
         BRE   DRUS8500            Yes => B2 Only Gen Purpose Reg Used
DRUS8200 DS    0H
         UNPK  DRUWORKD(5),DRUINSTR+1(2) ...Get the R1 and R3 Registers
         LLGC  R1,DRUWORKD+2       Get Just the R1 Designated Register
         NILL  R1,(X'000F')        Remove Zone Where Digit is Our Reg
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R5),C'D'          Designated R1 Reg Used for Instructn
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         LLGC  R2,DRUWORKD+3       Get Just the R3 Designated Register
         NILL  R2,(X'000F')        Remove Zone Where Digit is Our Reg
         LGR   R15,R2              Hold the R3 Number in Work Register
         MGHI  R2,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R2,R4) Point to Reg Info Work Area
         MVI   0(R5),C'D'          Designated R3 Reg Used for Instructn
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         LLGC  R1,DRUINSTR+2       Get the B2/D2 Portion of Instruction
         SRLG  R1,R1,4 Bits        Shift Out the D2 Part to Isolate B2
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'B'          The Base B2 Reg Used for Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         CLC   OP@MCHCD,=XL2'EB44' This a Branch on Index High Grande?
         BRE   DRUS8300            Yes => Check for Even Numbered R3
         CLC   OP@MCHCD,=XL2'EB45' Branch on Index Less Than or Equal?
         BRNE  DRUSEXIT            No  => Done for This Format, Exit
DRUS8300 DS    0H
         TMLL  R15,X'0001'         R3 Specified as an Even Register?
         BRNZ  DRUSEXIT            No  => Then Done for This Instructn
         AGHI  R15,(1)             Yes => Set to Adjoining Odd Register
         MGHI  R15,(PRNTLEN)       Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R15,R4) Point to Reg Info Work Area
         MVI   0(R5),C'O'          R3+1 Register Implied in Instruction
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
DRUS8400 DS    0H
         UNPK  DRUWORKD(5),DRUINSTR+1(2) ...Get the R1 and R3 Registers
         LLGC  R1,DRUWORKD+2       Get Just the R1 Designated Register
         NILL  R1,(X'000F')        Remove Zone Where Digit is Our Reg
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R5),C'D'          Designated R1 Reg Used for Instructn
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         LLGC  R2,DRUWORKD+3       Get Just the R3 Designated Register
         NILL  R2,(X'000F')        Remove Zone Where Digit is Our Reg
         MGHI  R2,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R2,R4) Point to Reg Info Work Area
         MVI   0(R5),C'D'          Designated R3 Reg Used for Instructn
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         BRU   DRUSEXIT            B2/DL2 Not Used to Hold an Address
DRUS8500 DS    0H
         LLGC  R1,DRUINSTR+2       Get the B2/D2 Portion of Instruction
         SRLG  R1,R1,4 Bits        Shift Out the D2 Part to Isolate B2
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'B'          Base B2 Register Used in Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
DRUS8600 DS    0H
         UNPK  DRUWORKD(5),DRUINSTR+1(2) ...Get the R1 and R3 Registers
         LLGC  R1,DRUWORKD+2       Get Just the R1 Designated Register
         NILL  R1,(X'000F')        Remove Zone Where Digit is Our Reg
         LGR   R5,R1               Copy Result to a Work Register
         MGHI  R5,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R5,R4) Point to Reg Info Work Area
         MVI   0(R5),C'D'          Designated R1 Reg Used in Instructn
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         LLGC  R2,DRUWORKD+3       Get Just the R3 Designated Register
         NILL  R2,(X'000F')        Remove Zone Where Digit is Our Reg
         LGR   R5,R2               Copy Result to a Work Register
         MGHI  R5,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R5,R4) Point to Reg Info Work Area
         MVI   0(R5),C'D'          Designated R3 Reg Used in Instructn
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         LA    R1,1(,R1)           Point to Odd Reg in R1 Even/Odd Pair
         LLGFR R15,R1              Hold Designated Reg No. in Work Reg
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'O'          Implied R1+1 Odd Reg for Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         TMLL  R15,(X'0001')       Our Designated R1+1 an Odd Register?
         BRO   DRUS8700            Yes => R1+1 Reg is Odd, Look at R3
         MVI   1(R1),C'*'          Indicate Even/Odd Reg Pair Mismatch
DRUS8700 DS    0H
         LA    R2,1(,R2)           Point to Odd Reg in Even/Odd Pair
         LLGFR R15,R2              Hold Designated Reg No. in Work Reg
         MGHI  R2,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R2,LRTREGUS-LRTRGBLK(R2,R4) Point to Reg Info Work Area
         MVI   0(R2),C'O'          Implied R3+1 Odd Reg for Instruction
         MVI   1(R2),C'-'          Fill with a Hyphen to Highlight Reg
         TMLL  R15,(X'0001')       Our Designated R3+1 an Odd Register?
         BRO   DRUS8800            Yes => R3+1 Reg is Odd, Check for B2
         MVI   1(R2),C'*'          Indicate Even/Odd Reg Pair Mismatch
DRUS8800 DS    0H
         LLGC  R1,DRUINSTR+2       Get the Base Register of Instruction
         SRLG  R1,R1,4 Bits        Shift Out the D2 Part to Isolate B2
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'B'          The Base B2 Reg Used in Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
DRUS8900 DS    0H
         LLGC  R1,DRUINSTR+1       Get the R1 Designated Register
         SRLG  R1,R1,4 Bits        Shift Out M3 Mask Part to Isolate R1
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'D'          Designated R1 Reg Used in Instructn
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         LLGC  R1,DRUINSTR+2       Get B2/DL2 Portion of Instruction
         SRLG  R1,R1,4 Bits        Shift Out the DL2 Part to Isolate B2
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'B'          The Base B2 Reg Used in Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
*
*+-------------------------------------------------------------------+*
*| Perform processing for the type RX-a variation and RX-b variation |*
*| instruction formats.                                              |*
*|                                                                   |*
*| RX / RX-a                         RX / RX-b                       |*
*| +-----------------------------+   +-----------------------------+ |*
*| |Op Code| R1 | X2 | B2 |D2    |   |Op Code| M1 | X2 | B2 |D2    | |*
*| +-----------------------------+   +-----------------------------+ |*
*|  0       8    12   16   20   32    0       8    12   16   20   32 |*
*+-------------------------------------------------------------------+*
*
DRUS9000 DS    0H
         CLC   OP@MCHCD,=XL2'4700' This for a Branch on Condition?
         BRE   DRUS9400            Yes => Uses M1 Field in Place of R1
         CLC   OP@MCHCD,=XL2'5C00' This for a Multiply Instruction?
         BRE   DRUS9200            Yes => Then Uses R1+1 E/O Reg Pair
         CLC   OP@MCHCD,=XL2'5D00' This for a Divide Instruction?
         BRE   DRUS9200            Yes => Then Uses R1+1 E/O Reg Pair
         CLC   OP@MCHCD,=XL2'7100' This a Multiple Single Instruction?
         BRE   DRUS9100            Yes => Do Not Include in FltPt Group
         CLC   OP@MCHCD,=XL2'6000' Beginning of FltPnt Instructn Group?
         BRL   DRUS9100            No  => Not Floating Point Instructn
         BRU   DRUSEXIT            Yes => Do Not Show FP Regs as GP Reg
DRUS9100 DS    0H
         UNPK  DRUWORKD(5),DRUINSTR+1(2) ...Get the R1 and X2 Registers
         LLGC  R1,DRUWORKD+2       Get Just the R1 Designated Register
         NILL  R1,(X'000F')        Remove Zone Where Digit is Our Reg
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R5),C'D'          Designated R1 Reg Used in Instructn
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         LLGC  R2,DRUWORKD+3       Get Just the X2 Designated Register
         NILL  R2,(X'000F')        Remove Zone Where Digit is Our Reg
         MGHI  R2,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R2,R4) Point to Reg Info Work Area
         MVI   0(R5),C'X'          Index X2 Reg Used in the Instruction
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         LLGC  R1,DRUINSTR+2       Get the B2/D2 Portion of Instruction
         SRLG  R1,R1,4 Bits        Shift Out the D2 Part to Isolate B2
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'B'          The Base B2 Base Reg for Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
DRUS9200 DS    0H
         UNPK  DRUWORKD(5),DRUINSTR+1(2) ...Get the R1 and X2 Registers
         LLGC  R1,DRUWORKD+2       Get Just the R1 Designated Register
         NILL  R1,(X'000F')        Remove Zone Where Digit is Our Reg
         LGR   R5,R1               Copy Result to a Work Register
         MGHI  R5,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R5,R4) Point to Reg Info Work Area
         MVI   0(R5),C'D'          Designated R1 Reg Used in Instructn
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         LLGC  R2,DRUWORKD+3       Get Just the X2 Designated Register
         NILL  R2,(X'000F')        Remove Zone Where Digit is Our Reg
         LGR   R5,R2               Copy Result to a Work Register
         MGHI  R5,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R5,R4) Point to Reg Info Work Area
         MVI   0(R5),C'X'          Index X2 Reg Used in the Instruction
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         LA    R1,1(,R1)           Point to Odd Reg in R1 Even/Odd Pair
         LLGFR R15,R1              Hold Designated Reg No. in Work Reg
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'O'          Implied R1+1 Odd Reg for Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         TMLL  R15,(X'0001')       Our Designated R1+1 an Odd Register?
         BRO   DRUS9300            Yes => R1+1 Reg is Odd, Look at B2
         MVI   1(R1),C'*'          Indicate Even/Odd Reg Pair Mismatch
DRUS9300 DS    0H
         LLGC  R1,DRUINSTR+2       Get the B2/D2 Portion of Instruction
         SRLG  R1,R1,4 Bits        Shift Out the D2 Part to Isolate B2
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'B'          Base B2 Register Used in Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
DRUS9400 DS    0H
         LLGC  R2,DRUWORKD+3       Get Just the X2 Designated Register
         NILL  R2,(X'000F')        Remove Zone Where Digit is Our Reg
         MGHI  R2,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R2,R4) Point to Reg Info Work Area
         MVI   0(R5),C'X'          Index X2 Reg Used in the Instruction
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         LLGC  R1,DRUINSTR+2       Get the B2/D2 Portion of Instruction
         SRLG  R1,R1,4 Bits        Shift Out the D2 Part to Isolate B2
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'B'          The Base B2 Base Reg for Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
*
*+-------------------------------------------------------------------+*
*| Perform processing for the type RXE instruction format.           |*
*|                                                                   |*
*| RXE                                                               |*
*| +----------------------------------------+                        |*
*| |Op Code| R1 | X2 | B2 | D2  |---|Op Code|                        |*
*| +----------------------------------------+                        |*
*|  0       8    12   16   20    32  40    47                        |*
*+-------------------------------------------------------------------+*
*
DRU10000 DS    0H
         CLC   OP@MCHCD(1),=X'ED'  A Floating Point Instruction Group?
         BRE   DRUSEXIT            Yes => Do Not Show FP Regs as GP Reg
         UNPK  DRUWORKD(5),DRUINSTR+1(2) ...Get the R1 and X2 Registers
         LLGC  R1,DRUWORKD+2       Get Just the R1 Designated Register
         NILL  R1,(X'000F')        Remove Zone Where Digit is Our Reg
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R5),C'D'          Designated R1 Reg Used in Instructn
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         LLGC  R2,DRUWORKD+3       Get Just the X2 Designated Register
         NILL  R2,(X'000F')        Remove Zone Where Digit is Our Reg
         MGHI  R2,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R2,R4) Point to Reg Info Work Area
         MVI   0(R5),C'X'          Index X2 Reg Used in the Instruction
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         LLGC  R1,DRUINSTR+2       Get the B2/D2 Portion of Instruction
         SRLG  R1,R1,4 Bits        Shift Out the D2 Part to Isolate B2
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'B'          The Base B2 Base Reg for Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
*
*+-------------------------------------------------------------------+*
*| Perform processing for the type RXF instruction format.           |*
*|                                                                   |*
*| RXF                                                               |*
*| +---------------------------------------------+                   |*
*| |Op Code| R3 | X2 | B2 | D2  | R1 |---|Op Code|                   |*
*| +---------------------------------------------+                   |*
*|  0       8    12   16   20    32   36  40    47                   |*
*+-------------------------------------------------------------------+*
*
DRU11000 DS    0H
         UNPK  DRUWORKD(5),DRUINSTR+1(2) ...Get the R3 and X2 Registers
         LLGC  R1,DRUWORKD+2       Get Just the R3 Designated Register
         NILL  R1,(X'000F')        Remove Zone Where Digit is Our Reg
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R5),C'D'          Designated R3 Reg Used in Instructn
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         LLGC  R2,DRUWORKD+3       Get Just the X2 Designated Register
         NILL  R2,(X'000F')        Remove Zone Where Digit is Our Reg
         MGHI  R2,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R2,R4) Point to Reg Info Work Area
         MVI   0(R5),C'X'          Index X2 Reg Used in the Instruction
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         LLGC  R1,DRUINSTR+2       Get the B2/D2 Portion of Instruction
         SRLG  R1,R1,4 Bits        Shift Out the D2 Part to Isolate B2
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'B'          The Base B2 Base Reg for Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         LLGC  R1,DRUINSTR+4       Get the R1 Portion of Instruction
         SRLG  R1,R1,4 Bits        Shift Out Unused Operand to Get R1
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'D'          The Base B2 Base Reg for Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
*
*+-------------------------------------------------------------------+*
*| Perform processing for type RXY1 and RXY2 instruction format.     |*
*|                                                                   |*
*| RXY1 / RXY-a                                                      |*
*| +--------------------------------+                                |*
*| |Op Code|M1|X2|B2|DL2|DH2|Op Code|                                |*
*| +--------------------------------+                                |*
*|  0       8  12 16 20  32  40    47                                |*
*|                                                                   |*
*| RXY2 / RXY-b                                                      |*
*| +--------------------------------+                                |*
*| |Op Code|R1|X2|B2|DL2|DH2|Op Code|                                |*
*| +--------------------------------+                                |*
*|  0       8  12 16 20  32  40    47                                |*
*+-------------------------------------------------------------------+*
*
DRU12000 DS    0H
         CLC   OP@TYPE,=CL6'RXY-b' Is This an RXY-b Instruction Format?
         BRE   DRU12400            Yes => Then Prefetch Data Instructn
         CLC   OP@MCHCD,=XL2'E302' Instructn Group Beginning with LTG?
         BRL   DRUSEXIT            No  => Not Part of RXY-a Format Grp
         CLC   OP@MCHCD,=XL2'EB06' Instruction Group Ending With CVBY?
         BRH   DRUSEXIT            No  => Past This is Floating Point
         CLC   OP@MCHCD,=XL2'E30D' This for a Divide Single Grande?
         BRE   DRU12200            Yes => Then Uses R1+1 E/O Reg Pair
         CLC   OP@MCHCD,=XL2'E313' This for a Load Real Address (LRAY)?
         BRE   DRUSEXIT            Yes => Then Priviledged Instruction
         CLC   OP@MCHCD,=XL2'E31D' This Divide Single Grande Fullword?
         BRE   DRU12200            Yes => Then Uses R1+1 E/O Reg Pair
         CLC   OP@MCHCD,=XL2'E35C' This for Multiply (MFY)?
         BRE   DRU12200            Yes => Then Uses R1+1 E/O Reg Pair
         CLC   OP@MCHCD,=XL2'E386' This for Multiply Logical Grande?
         BRE   DRU12200            Yes => Then Uses R1+1 E/O Reg Pair
         CLC   OP@MCHCD,=XL2'E387' This for Divide Logical Grande?
         BRE   DRU12200            Yes => Then Uses R1+1 E/O Reg Pair
         CLC   OP@MCHCD,=XL2'E38E' This for Store Pair to Quadword?
         BRE   DRU12200            Yes => Then Uses R1+1 E/O Reg Pair
         CLC   OP@MCHCD,=XL2'E38F' This for Load Pair from Quadword?
         BRE   DRU12200            Yes => Then Uses R1+1 E/O Reg Pair
         CLC   OP@MCHCD,=XL2'E396' This for Multiply Logical?
         BRE   DRU12200            Yes => Then Uses R1+1 E/O Reg Pair
         CLC   OP@MCHCD,=XL2'E397' This for Divide Logical?
         BRE   DRU12200            Yes => Then Uses R1+1 E/O Reg Pair
DRU12100 DS    0H
         UNPK  DRUWORKD(5),DRUINSTR+1(2) ...Get the R1 and X2 Registers
         LLGC  R1,DRUWORKD+2       Get Just the R1 Designated Register
         NILL  R1,(X'000F')        Remove Zone Where Digit is Our Reg
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R5),C'D'          Designated R1 Reg Used in Instructn
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         LLGC  R2,DRUWORKD+3       Get Just the X2 Designated Register
         NILL  R2,(X'000F')        Remove Zone Where Digit is Our Reg
         MGHI  R2,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R2,R4) Point to Reg Info Work Area
         MVI   0(R5),C'X'          Index X2 Reg Used in the Instruction
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         LLGC  R1,DRUINSTR+2       Get B2/DL2 Portion of Instruction
         SRLG  R1,R1,4 Bits        Shift Out the DL2 Part to Isolate B2
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'B'          Base B2 Register Used in Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
DRU12200 DS    0H
         UNPK  DRUWORKD(5),DRUINSTR+1(2) ...Get the R1 and X2 Registers
         LLGC  R1,DRUWORKD+2       Get Just the R1 Designated Register
         NILL  R1,(X'000F')        Remove Zone Where Digit is Our Reg
         LGR   R5,R1               Copy Result to a Work Register
         MGHI  R5,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R5,R4) Point to Reg Info Work Area
         MVI   0(R5),C'D'          Designated R1 Reg Used in Instructn
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         LLGC  R2,DRUWORKD+3       Get Just the X2 Designated Register
         NILL  R2,(X'000F')        Remove Zone Where Digit is Our Reg
         LGR   R5,R2               Copy Result to a Work Register
         MGHI  R5,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R5,R4) Point to Reg Info Work Area
         MVI   0(R5),C'X'          Index X2 Reg Used in the Instruction
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         LA    R1,1(,R1)           Point to Odd Reg in R1 Even/Odd Pair
         LLGFR R15,R1              Hold Designated Reg No. in Work Reg
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'O'          Implied R1+1 Odd Reg for Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         TMLL  R15,(X'0001')       Our Designated R1+1 an Odd Register?
         BRO   DRU12300            Yes => R1+1 Reg is Odd, Look at B2
         MVI   1(R1),C'*'          Indicate Even/Odd Reg Pair Mismatch
DRU12300 DS    0H
         LLGC  R1,DRUINSTR+2       Get B2/DL2 Portion of Instruction
         SRLG  R1,R1,4 Bits        Shift Out the DL2 Part to Isolate B2
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'B'          Base B2 Base Reg Used in Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
DRU12400 DS    0H
         LLGC  R1,DRUINSTR+1       Get Byte from Abending Instruction
         NILL  R1,(X'000F')        Remove M1 Mask to Isolate the X2 Reg
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'X'          Index X2 Register Used in Instructn
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         LLGC  R1,DRUINSTR+2       Get B2/DL2 Portion of Instruction
         SRLG  R1,R1,4 Bits        Shift Out the DL2 Part to Isolate B2
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'B'          Base B2 Reg Used in the Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
*
*+-------------------------------------------------------------------+*
*| Perform processing for the type S instruction format.             |*
*|                                                                   |*
*| S                               S                                 |*
*| D2(B2)                          D2(B2)                            |*
*| +-----------------------+       +-----------------------+         |*
*| |  Op Code   | B2 | D2  |       |Op Code|----| B2 | D2  |         |*
*| +-----------------------+       +-----------------------+         |*
*|  0           16   20   31        0       8   16   20   31         |*
*|                                                                   |*
*| S                                                                 |*
*| (No Operands)                                                     |*
*| +-----------------------+                                         |*
*| |  Op Code   |----|-----|                                         |*
*| +-----------------------+                                         |*
*|  0           16   20   31                                         |*
*+-------------------------------------------------------------------+*
*
DRU13000 DS    0H
         CLC   OP@MCHCD,=XL2'B29D' This a Load Floating Point Control?
         BRE   DRUSEXIT            Yes => No FP Regs in GP Regs Report
         CLC   OP@MCHCD,=XL2'B2BD' This Load FltPnt Control and Signal?
         BRE   DRUSEXIT            Yes => No FP Regs in GP Regs Report
         CLC   OP@MCHCD,=XL2'B299' A Set Binary FltPnt Rounding Mode?
         BRE   DRUSEXIT            Yes => No FP Regs in GP Regs Report
         CLC   OP@MCHCD,=XL2'B2B8' A Set Binary FltPnt Rounding Mode?
         BRE   DRUSEXIT            Yes => No FP Regs in GP Regs Report
         CLC   OP@MCHCD,=XL2'B2B9' A Set Decimal FltPnt Rounding Mode?
         BRE   DRUSEXIT            Yes => No FP Regs in GP Regs Report
         CLC   OP@MCHCD,=XL2'B29C' This a Store Floating Point Control?
         BRE   DRUSEXIT            Yes => No FP Regs in GP Regs Report
         CLC   OP@MCHCD,=XL2'B27D' This for a Store System Information?
         BRE   DRU13100            Yes => Uses Hardware Implied R0/R1
         CLC   OP@MCHCD,=XL2'B21A' This for Compare and Form Codeword?
         BRE   DRU13200            Yes => Hardware Implied R1/R2/R3
         CLC   OP@MCHCD,=XL2'B2B0' This a Store Facility List Extended?
         BRE   DRU13300            Yes => Uses a Hardware Implied R0
         CLC   OP@MCHCD,=XL2'B20B' This an Insert PSW Key Instruction?
         BRE   DRU13400            Yes => Uses a Hardware Implied R2
         CLC   OP@MCHCD,=XL2'B20D' Purge Translation-Lookaside Buffer?
         BRE   DRUSEXIT            Yes => Instruction Uses No Operands
         CLC   OP@MCHCD,=XL2'B248' This a Purge ART-Lookaside Buffer?
         BRE   DRUSEXIT            Yes => Instruction Uses No Operands
         CLC   OP@MCHCD,=XL2'B276' This Cancel Subchannel Instruction?
         BRE   DRU13500            Yes => No Operands,Hardware Uses R1
         CLC   OP@MCHCD,=XL2'B230' This Clear Subchannel Instruction?
         BRE   DRU13500            Yes => No Operands,Hardware Uses R1
         CLC   OP@MCHCD,=XL2'B231' This a Halt Subchannel Instruction?
         BRE   DRU13500            Yes => No Operands,Hardware Uses R1
         CLC   OP@MCHCD,=XL2'B232' This Modify Subchannel Instruction?
         BRE   DRU13500            Yes => No Operands,Hardware Uses R1
         CLC   OP@MCHCD,=XL2'B23B' This Reset Channel Path Instructn?
         BRE   DRU13500            Yes => No Operands,Hardware Uses R1
         CLC   OP@MCHCD,=XL2'B238' This Resume Subchannel Instruction?
         BRE   DRU13500            Yes => No Operands,Hardware Uses R1
         CLC   OP@MCHCD,=XL2'B237' This Set Address Limit Instruction?
         BRE   DRU13500            Yes => No Operands,Hardware Uses R1
         CLC   OP@MCHCD,=XL2'B23C' This Set Channel Monitor Instructn?
         BRE   DRU13500            Yes => No Operands,Hardware Uses R1
         CLC   OP@MCHCD,=XL2'B233' This Start Subchannel Instruction?
         BRE   DRU13600            Yes => Uses a Hardware Implied R1
         CLC   OP@MCHCD,=XL2'B234' This Store Subchannel Instruction?
         BRE   DRU13600            Yes => Uses a Hardware Implied R1
         CLC   OP@MCHCD,=XL2'B235' This a Test Subchannel Instruction?
         BRE   DRU13600            Yes => Uses a Hardware Implied R1
         LLGC  R1,DRUINSTR+2       Get B2/D2 Portion of Instruction
         SRLG  R1,R1,4 Bits        Shift Out the D2 Part to Isolate B2
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'B'          Base B2 Reg Used in the Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
DRU13100 DS    0H
         MVI   LRTREGUS-LRTRGBLK(R4),C'H' ..Hardware Implies Register 0
         MVI   LRTREGUS-LRTRGBLK+1(R4),C'-' ..Hyphen to Highlight Reg
         LA    R5,PRNTLEN(,R4)     Point to Register 1 Line in Wrk Area
         MVI   LRTREGUS-LRTRGBLK(R5),C'H' ..Hardware Implies Register 1
         MVI   LRTREGUS-LRTRGBLK+1(R5),C'-' ..Hyphen to Highlight Reg
         LLGC  R1,DRUINSTR+2       Get B2/D2 Portion of Instruction
         SRLG  R1,R1,4 Bits        Shift Out the D2 Part to Isolate B2
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'B'          Base B2 Reg Used in the Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
DRU13200 DS    0H
         LA    R5,PRNTLEN(,R4)     Point to Register 1 Line in Wrk Area
         MVI   LRTREGUS-LRTRGBLK(R5),C'H' ..Hardware Implies Register 1
         MVI   LRTREGUS-LRTRGBLK+1(R5),C'-' ..Hyphen to Highlight Reg
         LA    R5,PRNTLEN*2(,R4)   Point to Register 2 Line in Wrk Area
         MVI   LRTREGUS-LRTRGBLK(R5),C'H' ..Hardware Implies Register 2
         MVI   LRTREGUS-LRTRGBLK+1(R5),C'-' ..Hyphen to Highlight Reg
         LA    R5,PRNTLEN*3(,R4)   Point to Register 3 Line in Wrk Area
         MVI   LRTREGUS-LRTRGBLK(R5),C'H' ..Hardware Implies Register 3
         MVI   LRTREGUS-LRTRGBLK+1(R5),C'-' ..Hyphen to Highlight Reg
         LLGC  R1,DRUINSTR+2       Get B2/D2 Portion of Instruction
         SRLG  R1,R1,4 Bits        Shift Out the D2 Part to Isolate B2
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'B'          Base B2 Reg Used in the Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
DRU13300 DS    0H
         MVI   LRTREGUS-LRTRGBLK(R4),C'H' ..Hardware Implies Register 0
         MVI   LRTREGUS-LRTRGBLK+1(R4),C'-' ..Hyphen to Highlight Reg
         LLGC  R1,DRUINSTR+2       Get B2/D2 Portion of Instruction
         SRLG  R1,R1,4 Bits        Shift Out the D2 Part to Isolate B2
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'B'          Base B2 Reg Used in the Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
DRU13400 DS    0H
         LA    R5,PRNTLEN*2(,R4)   Point to Register 2 Line in Wrk Area
         MVI   LRTREGUS-LRTRGBLK(R5),C'H' ..Hardware Implies Register 2
         MVI   LRTREGUS-LRTRGBLK+1(R5),C'-' ..Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
DRU13500 DS    0H
         LA    R5,PRNTLEN(,R4)     Point to Register 1 Line in Wrk Area
         MVI   LRTREGUS-LRTRGBLK(R5),C'H' ..Hardware Implies Register 1
         MVI   LRTREGUS-LRTRGBLK+1(R5),C'-' ..Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
DRU13600 DS    0H
         LA    R5,PRNTLEN(,R4)     Point to Register 1 Line in Wrk Area
         MVI   LRTREGUS-LRTRGBLK(R5),C'H' ..Hardware Implies Register 1
         MVI   LRTREGUS-LRTRGBLK+1(R5),C'-' ..Hyphen to Highlight Reg
         LLGC  R1,DRUINSTR+2       Get B2/D2 Portion of Instruction
         SRLG  R1,R1,4 Bits        Shift Out the D2 Part to Isolate B2
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'B'          Base B2 Reg Used in the Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
*
*+-------------------------------------------------------------------+*
*| Perform processing for the type SI, SIL, and SIY instruction      |*
*| formats.                                                          |*
*|                                                                   |*
*| SI                                 SIL                            |*
*| +------------------------+       +------------------------------+ |*
*| |Op Code|I2     |B1 |D1  |       |  Op Code  | B1 | D1 |   I2   | |*
*| +------------------------+       +------------------------------+ |*
*|  0       8       16  20 31        0           16   20   32     47 |*
*|                                                                   |*
*| SIY                                                               |*
*| +-------------------------------------+                           |*
*| |Op Code| I2 | B1 | DL1 | DH1 |Op Code|                           |*
*| +-------------------------------------+                           |*
*|  0       8    16   20    32    40    47                           |*
*+-------------------------------------------------------------------+*
*
DRU14000 DS    0H
         LLGC  R1,DRUINSTR+2       Get B1/D1 Portion of Instruction
         SRLG  R1,R1,4 Bits        Shift Out the D1 Part to Isolate B1
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'B'          Base B1 Reg Used in the Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
*
*+-------------------------------------------------------------------+*
*| Perform processing for the type SS-a, SS-b, SS-c, and SS-f 1      |*
*| variation instruction formats.                                    |*
*|                                                                   |*
*| SS1 / SS-a / SS-f                SS2 / SS-b                       |*
*| +-----------------------------+ +-------------------------------+ |*
*| |Op Code|L  |B1 |D1  |B2 |D2  | |Op Code|L1|L2|B1 |D1  |B2 |D2  | |*
*| +-----------------------------+ +-------------------------------+ |*
*|  0       8   16  20   32  36 47  0       8  12 16  20   32  36 47 |*
*|                                                                   |*
*| SS3 / SS-c                                                        |*
*| +-----------------------------+                                   |*
*| |Op Code|L1|I3|B1|D1 |B2 |D2  |                                   |*
*| +-----------------------------+                                   |*
*|  0       8  12 16 20  32  36 47                                   |*
*+-------------------------------------------------------------------+*
*
DRU15000 DS    0H
         LLGC  R1,DRUINSTR+2       Get B1/D1 Portion of Instruction
         SRLG  R1,R1,4 Bits        Shift Out the D1 Part to Isolate B1
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'B'          Base B1 Register Used in Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         CLC   OP@MCHCD,=XL2'F000' This Shift and Round Packed Decimal?
         BRE   DRUSEXIT            Only Rightmost 6 Bits Used in B2/D2
         LLGC  R1,DRUINSTR+4       Get B2/D2 Portion of Instruction
         SRLG  R1,R1,4 Bits        Shift Out the D2 Part to Isolate B2
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'B'          Base B2 Register Used in Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         CLC   OP@MCHCD,=XL2'D000' This for Translate and Test Reverse?
         BRE   DRU15200            Yes => Process for Implied Registers
         CLC   OP@MCHCD,=XL2'DD00' This for Translate and Test?
         BRE   DRU15200            Yes => Process for Implied Registers
         CLC   OP@MCHCD,=XL2'DF00' This Edit and Mark (EDMK)?
         BRNE  DRUSEXIT            No  => Then Done With This Format
DRU15100 DS    0H
         LA    R1,PRNTLEN(,R4)     Point to Register 1 Line in Wrk Area
         MVI   LRTREGUS-LRTRGBLK(R1),C'H' Hardware Convention Uses Reg1
         MVI   LRTREGUS-LRTRGBLK+1(R1),C'-' ..Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for EDMK, Branch to Exit
DRU15200 DS    0H
         LA    R1,PRNTLEN(,R4)     Point to Register 1 Line in Wrk Area
         MVI   LRTREGUS-LRTRGBLK(R1),C'H' ...Hardware Uses Register 1
         MVI   LRTREGUS-LRTRGBLK+1(R1),C'-' ...Hyphen to Highlight Reg
         LA    R1,PRNTLEN(,R1)     Point to Register 2 Line in Wrk Area
         MVI   LRTREGUS-LRTRGBLK(R1),C'H' ...Hardware Uses Register 2
         MVI   LRTREGUS-LRTRGBLK+1(R1),C'-' ...Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for TRT and TRTR, Exit Routine
*
*+-------------------------------------------------------------------+*
*| Perform processing for type SS-d and SS-e variation instruction   |*
*| formats.                                                          |*
*|                                                                   |*
*| SS4 / SS-d                       SS5 / SS-e                       |*
*| +------------------------------+ +------------------------------+ |*
*| |Op Code|R1|R3|B1 |D1 |B2 |D2  | |Op Code|R1|R3|B2 |D2 |B4 |D4  | |*
*| +------------------------------+ +------------------------------+ |*
*|  0       8  12 16  20  32  36 47  0       8  12 16  20  32  36 47 |*
*+-------------------------------------------------------------------+*
*
DRU16000 DS    0H
         CLC   OP@MCHCD,=XL2'EE00' This for Perform Locked Operation?
         BRE   DRU16200            Yes => Process for Register Use
DRU16100 DS    0H
         MVO   DRUWORKD(2),DRUINSTR+1(1) Get the R1 Designated Register
         LLGC  R1,DRUWORKD         R1 Reg No. Used to Determine Offset
         LGR   R14,R1              Hold Designated Reg No. in Work Reg
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'D'          Designated R1 Reg Used in Instructn
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         MVI   DRUWORKD,X'00'      Clear the Work Area Byte
         MVN   DRUWORKD(1),DRUINSTR+1 ..Get the R3 Designated Register
         LLGC  R1,DRUWORKD         R3 Reg No. Used to Determine Offset
         LGR   R15,R1              Hold Designated Reg No. in Work Reg
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'D'          Designated R3 Reg Used in Instructn
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         MVI   DRUWORKD,X'00'      Clear the Work Area Byte
         MVO   DRUWORKD(2),DRUINSTR+2(1) Get the B1 Designated Register
         LLGC  R1,DRUWORKD         B1 Reg No. Used to Determine Offset
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'B'          Base B1 Reg Used in the Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         MVO   DRUWORKD(2),DRUINSTR+4(1) Get the B2 Designated Register
         LLGC  R1,DRUWORKD         B2 Reg No. Used to Determine Offset
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'B'          Base B2 Reg Used in the Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
DRU16200 DS    0H
         MVI   LRTREGUS-LRTRGBLK(R4),C'H' By Hardware Convention Reg0
         MVI   LRTREGUS-LRTRGBLK+1(R4),C'-' ..Hyphen to Highlight Reg
         MVI   (LRTREGUS-LRTRGBLK)+PRNTLEN(R4),C'H' Hardware Uses Reg1
         MVI   (LRTREGUS-LRTRGBLK+1)+PRNTLEN(R4),C'-' ..Highlight Reg
         MVO   DRUWORKD(2),DRUINSTR+1(1) Get the R1 Designated Register
         LLGC  R1,DRUWORKD         R1 Reg No. Used to Determine Offset
         LGR   R14,R1              Hold Designated Reg No. in Work Reg
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'D'          Designated R1 Reg Used in Instructn
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         MVI   DRUWORKD,X'00'      Clear the Work Area Byte
         MVN   DRUWORKD(1),DRUINSTR+1 ..Get the R3 Designated Register
         LLGC  R1,DRUWORKD         R3 Reg No. Used to Determine Offset
         LGR   R15,R1              Hold Designated Reg No. in Work Reg
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'D'          Designated R3 Reg Used in Instructn
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         MVI   DRUWORKD,X'00'      Clear the Work Area Byte
         MVO   DRUWORKD(2),DRUINSTR+2(1) Get the B2 Designated Register
         LLGC  R1,DRUWORKD         B2 Reg No. Used to Determine Offset
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'B'          Base B2 Reg Used in the Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         MVO   DRUWORKD(2),DRUINSTR+4(1) Get the B4 Designated Register
         LLGC  R1,DRUWORKD         B4 Reg No. Used to Determine Offset
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'B'          Base B4 Reg Used in the Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         LLGT  R2,SDWAXPAD         Addr of SDWA Extension Pointers Area
         USING SDWAPTRS,R2         Addressability to Extension Ptr Area
         ICM   R2,B'1111',SDWAXEME Do We Have a Pointer to 64-bit Info?
         BRZ   DRU16300            No  => Then Pull 31-bit Registers
         USING SDWARC4,R2          Addressability to 64-bit Info Area
         LG    R1,SDWAG6400        Get the 64-bit Register R0 at Abend
         BRU   DRU16400            Branch to Process Register Values
         DROP  R2                  Remove Listed Register as Base Reg
DRU16300 DS    0H
         LLGF  R1,SDWAGR00         Get the Register 0 Value at Abend
DRU16400 DS    0H
         NG    R1,=AD(255)         Isolate the Function Code Byte
         DSGF  R0,=A(4)            Set Function Code as a Multiple of 4
         LTGR  R1,R1               Is Function Code Zero through Three?
         BRZ   DRUSEXIT            Yes => Then No R1+1 Implied Reg Use
         TMLL  R1,(X'0001')        Even Multiple of 4 or 2 More Than 4?
         BRO   DRU16500            No  => Then No R1+1 Implied Reg Use
         LA    R1,1(,R14)          Point to Odd Reg in R1 Even/Odd Pair
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'O'          Implied R1+1 Odd Reg for Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
DRU16500 DS    0H
         CGHI  R1,(2)              Is This Function Code 8 Through 11?
         BRNE  DRUSEXIT            No  => Then No R3+1 Implied Reg Use
         TMLL  R0,(X'0001')        Is This for a Function Code 9 or 11?
         BRO   DRUSEXIT            Yes => Then No R3+1 Implied Reg Use
         LA    R2,1(,R15)          Point to Odd Reg in Even/Odd Pair
         LLGFR R15,R2              Hold Designated Reg No. in Work Reg
         MGHI  R2,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R2,LRTREGUS-LRTRGBLK(R2,R4) Point to Reg Info Work Area
         MVI   0(R2),C'O'          Implied R3+1 Odd Reg for Instruction
         MVI   1(R2),C'-'          Fill with a Hyphen to Highlight Reg
         TMLL  R15,(X'0001')       Our Designated R3+1 an Odd Register?
         BRO   DRUSEXIT            Yes => R3+1 Reg is Odd, Exit Routine
         MVI   1(R2),C'*'          Indicate Even/Odd Reg Pair Mismatch
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
*
*+-------------------------------------------------------------------+*
*| Perform processing for the type SSE Instruction format.           |*
*|                                                                   |*
*| SSE                                                               |*
*| +-------------------------------------+                           |*
*| |  Op Code   | B1 | D1   | B2 | D2    |                           |*
*| +-------------------------------------+                           |*
*|  0            16   20     32   36    47                           |*
*+-------------------------------------------------------------------+*
*
DRU17000 DS    0H
         CLC   OP@MNEUM,=CL7'MVCDK' This a Move with Destination Key?
         BRE   DRU17100            Yes => Branch to Process Instruction
         CLC   OP@MNEUM,=CL7'MVCSK' This a Move with Source Key?
         BRE   DRU17100            Yes => Branch to Process Instruction
         CLC   OP@MNEUM,=CL7'TPROT' This a Test Protection Instruction?
         BRE   DRU17200            Yes => Branch to Process Instruction
         CLC   OP@MNEUM,=CL7'STRAG' Store Real Address Grande Instruct?
         BRE   DRU17200            Yes => Branch to Process Instruction
         BRNE  DRUSEXIT            No  => Then No Further Processing
DRU17100 DS    0H
         MVI   LRTREGUS-LRTRGBLK(R4),C'H' By Hardware Convention Reg0
         MVI   LRTREGUS-LRTRGBLK+1(R4),C'-' ..Hyphen to Highlight Reg
         MVI   (LRTREGUS-LRTRGBLK)+PRNTLEN(R4),C'H' Hardware Uses Reg1
         MVI   (LRTREGUS-LRTRGBLK+1)+PRNTLEN(R4),C'-' ..Highlight Reg
DRU17200 DS    0H
         LLGC  R1,DRUINSTR+2       Get B1/D1 Portion of Instruction
         SRLG  R1,R1,4 Bits        Shift Out the D1 Part to Isolate B1
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'B'          Base B1 Register Used in Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         LLGC  R1,DRUINSTR+4       Get B2/D2 Portion of Instruction
         SRLG  R1,R1,4 Bits        Shift Out the D2 Part to Isolate B2
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'B'          Base B2 Register Used in Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
*
*+-------------------------------------------------------------------+*
*| Perform processing for the type SSF instruction format.           |*
*|                                                                   |*
*| SSF                                                               |*
*| +------------------------------+                                  |*
*| |Op Code|R3|Op|B1 |D1 |B2 |D2  |                                  |*
*| +------------------------------+                                  |*
*|  0       8  12 16  20  32  36 47                                  |*
*+-------------------------------------------------------------------+*
*
DRU18000 DS    0H
         CLC   OP@MCHCD,=XL2'C800' A Move with Optional Specifications?
         BRE   DRU18300            Yes => Then Hardware Implied R0
         CLC   OP@MCHCD,=XL2'C810' This an Extract CPU Time Instructn?
         BRE   DRU18300            Yes => Then Hardware Implied R0+R1
         CLC   OP@MCHCD,=XL2'C820' This a Compare and Swap and Store?
         BRE   DRU18300            Yes => Then Hardware Implied R0+R1
DRU18100 DS    0H
         MVO   DRUWORKD(2),DRUINSTR+1(1) Get the R3 Designated Register
         LLGC  R1,DRUWORKD         R3 Reg No. Used to Determine Offset
         LGR   R5,R1               Copy Result to a Work Register
         MGHI  R5,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R5,R4) Point to Reg Info Work Area
         MVI   0(R5),C'D'          Designated R3 Reg Used in Instructn
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         LA    R1,1(,R1)           Point to Odd Reg in Even/Odd Pair
         LLGFR R15,R1              Hold Designated Reg No. in Work Reg
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R5),C'O'          Implied Odd R3+1 Reg for Instruction
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         TMLL  R15,(X'0001')       Our Designated R3+1 an Odd Register?
         BRO   DRU18200            Yes => Reg Adjacent to R3 Was Odd
         MVI   1(R5),C'*'          Indicate Even/Odd Reg Pair Mismatch
DRU18200 DS    0H
         MVI   DRUWORKD,X'00'      Clear the Work Area Byte
         MVO   DRUWORKD(2),DRUINSTR+2(1) Get the B1 Designated Register
         LLGC  R1,DRUWORKD         B1 Reg No. Used to Determine Offset
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'B'          Base B1 Reg Used in the Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         MVO   DRUWORKD(2),DRUINSTR+4(1) Get the B2 Designated Register
         LLGC  R1,DRUWORKD         B2 Reg No. Used to Determine Offset
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'B'          Base B2 Reg Used in the Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
DRU18300 DS    0H
         MVI   LRTREGUS-LRTRGBLK(R4),C'H' By Hardware Convention Reg0
         MVI   LRTREGUS-LRTRGBLK+1(R4),C'-' ..Hyphen to Highlight Reg
         CLC   OP@MCHCD,=XL2'C800' A Move with Optional Specifications?
         BRE   DRU18400            Yes => Then R0 only by HW Convention
         MVI   (LRTREGUS-LRTRGBLK)+PRNTLEN(R4),C'H' Hardware Uses Reg1
         MVI   (LRTREGUS-LRTRGBLK+1)+PRNTLEN(R4),C'-' ..Highlight Reg
DRU18400 DS    0H
         MVO   DRUWORKD(2),DRUINSTR+1(1) Get the R3 Designated Register
         LLGC  R1,DRUWORKD         R3 Reg No. Used to Determine Offset
         LGR   R5,R1               Copy Result to a Work Register
         MGHI  R5,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R5,LRTREGUS-LRTRGBLK(R5,R4) Point to Reg Info Work Area
         MVI   0(R5),C'D'          Designated R3 Reg Used in Instructn
         MVI   1(R5),C'-'          Fill with a Hyphen to Highlight Reg
         CLC   OP@MCHCD,=XL2'C820' This a Compare and Swap and Store?
         BRNE  DRU18600            No  => Then No Implied E/O Reg Pair
         CLI   LRTREGCC-LRTRGBLK+L'LRTREGCC-1(R4),C'2' CSST Function 2?
         BRNE  DRU18600            No  => No E/O Pair When Not Functn 2
         USING PSA,R0              Establish Addressability to the PSA
         TM    FLCFACL3,FLCFCSF2   Compare-and-Swap Facility 2 install?
         BRZ   DRU18600            No  => No E/O Pair if No Facility 2
         DROP  R0                  Remove Listed Reg as PSA Base Reg
DRU18500 DS    0H
         LA    R1,1(,R1)           Point to Odd Reg of R3 Even/Odd Pair
         LLGFR R15,R1              Hold Designated Reg No. in Work Reg
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'O'          Implied Odd R1+1 Reg for Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         TMLL  R15,(X'0001')       Our Designated R1+1 an Odd Register?
         BRO   DRU18600            Yes => Reg Adjacent to R1 Was Odd
         MVI   1(R1),C'*'          Indicate Even/Odd Reg Pair Mismatch
DRU18600 DS    0H
         MVI   DRUWORKD,X'00'      Clear the Work Area Byte
         MVO   DRUWORKD(2),DRUINSTR+2(1) Get the B1 Designated Register
         LLGC  R1,DRUWORKD         B1 Reg No. Used to Determine Offset
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'B'          Base B1 Reg Used in the Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         MVO   DRUWORKD(2),DRUINSTR+4(1) Get the B2 Designated Register
         LLGC  R1,DRUWORKD         B2 Reg No. Used to Determine Offset
         MGHI  R1,(PRNTLEN)        Calculate Offset into Reg Work Area
         LA    R1,LRTREGUS-LRTRGBLK(R1,R4) Point to Reg Info Work Area
         MVI   0(R1),C'B'          Base B2 Reg Used in the Instruction
         MVI   1(R1),C'-'          Fill with a Hyphen to Highlight Reg
         BRU   DRUSEXIT            Done for This Format, Branch to Exit
*
*+-------------------------------------------------------------------+*
*|   Return to Caller                                                |*
*+-------------------------------------------------------------------+*
*
DRUSEXIT DS    0H
         XC    LGWRETRY,LGWRETRY   Ensure Recovery is Disabled
         LLGF  R15,DRURETCD        Set the Return Code
         LPGMEXIT RC=DRURETCD      Define Program Exit Protocol
*
*+-------------------------------------------------------------------+*
*|    Program RENT Work Area                                         |*
*+-------------------------------------------------------------------+*
*
         LCA   DEFINE              Define the Program RENT Work Area
*
DRUWORKD DS    10D                 General Purpose Work Area
DRUPLIST DS    20FD                CALL Parameter List
DRUPARM@ DS    0FD                 Save Area for Passed Parameters
DRUTARG@ DS    AD                  Address of Target of EX Instruction
DRUMCHI@ DS    AD                  Address of Entry in Machine Table
DRUABND@ DS    AD                  Address of Abending Instruction
DRUWKADR DS    AD                  Start Addr to Register Info Wrk Area
DRUWKRG# DS    FD                  Register Count in Register Info Area
*
DRURETCD DS    F                   Save Area for the Return Code
DRUINSTR DS    CL8                 Work Area for Machine Instruction
*
         LCA   DEFEND              Define End of Program RENT Work Area
*
***********************************************************************
*       End of Determine Registers Used in Abending Instruction       *
***********************************************************************
         EJECT ,
***********************************************************************
**************************+-----------------+**************************
**************************| D S T D 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|       P r o c e s s   S t a n d a r d   S a v e   A r e a         |*
*+-------------------------------------------------------------------+*
* PROGRAM NAME:    DSTD0000                                           *
*                                                                     *
* FUNCTION:        Process Standard Save Area                         *
*                                                                     *
*                  This routine is responsible for processing a       *
*                  standard format 72 byte save area. Prints the load *
*                  module/Csect name and offset of calling program at *
*                  entry to the called program, and prints the general*
*                  purpose registers of calling program at entry to   *
*                  called program. The 31-bit values are expanded to  *
*                  64-bit with the high-half set to zeros.            *
*                                                                     *
*For example:                                                         *
*                                                                     *
*Called Program Entry Point..: TESTPGM9+(026440)                      *
*     TESTPGM9 Module Address: 0000000018600000                       *
*     TESTPGM9 Module Length.: 0004D8E8                               *
*Calling Program Returns To..: TESTPGM9+(02556E)                      *
*Calling Program Save Area...: 0000000000006AE0                       *
*Calling Program General Purpose Registers R0-R15 at Entry to Called P*
*  0-3   00000000000108F8  0000000000006000  0000000000008000  0000000*
*  4-7   000000000000F878  00000000008FF350  00000000008B8FE0  0000000*
*  8-11  00000000008FC030  00000000008C9CC8  0000000000000000  0000000*
*  12-15 0000000018625400  0000000000006AE0  000000009862556E  0000000*
*                                                                     *
* INPUT REGS:      R1 => Standard O/S Parameter List                  *
*                                                                     *
* INPUT DATA:      Parm1: Addr of System Diagnostic Work Area         *
*                  Parm2: Addr of LGRWK2II Logger Work Area           *
*                  Parm3: Addr of Common Constants and Routines Area  *
*                  Parm4: Addr of Abending Program's LCA Area         *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY, AC=0                          *
*                                                                     *
* CALLING PROGRAM: DIAG0000 - Analyze System Diagnostic Work Area Pgm *
*                                                                     *
* CALLED PROGRAMS: LNME0000 - Logger Services Program to Resolve an   *
*                             Address to a Load Module Name           *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                  04 - Warning                                       *
*                  08 - Error                                         *
*                  12 - Severe Error - Exit This Routine              *
*                                                                     *
***********************************************************************
*
DSTD0000 LPGMNTRY TYPE=SUB,        Define As A Sub-Program Entry       X
               BASE=(12),          Establish Base Registers            X
               AMOD=64,RMOD=ANY,   Addressing and Residency Modes      X
               LCAPFX=DSD,         Establish LCA Prefix for This RSECT X
               LOG=OFF,            Always Turn Logging 'Off' in Logger!X
               LINKRTRN=BSM,       Define Return Linkage Instruction   X
               COPY@RT=YES         To Generate a Copyright Statement
         USING COM_DATA,RCOMM      Addressability to Common Data Area
         USING LGRWK2II,RLGW       Establish Addressability to LGRWK2II
         USING SDWA,RSDW           Establish Addressability to SDWA
         USING IHADCB,LGWODCB      Establish Addressability to DCB
LMOD     USING LRTLMBLK,DSDLMODI   Establish Addressability to LMODI
         LMG   R8,R10,0(R1)        Load the Parameter Area Addresses
         LG    RPCC,24(,R1)        Get the Current Save Area Address
         XC    DSDRETCD,DSDRETCD   Initialize the Return Code
*
*+-------------------------------------------------------------------+*
*|    Determine the Load Module/Csect Name For the Called Program    |*
*+-------------------------------------------------------------------+*
*
DSTD0100 DS    0H
         LLGT  R5,LCASA_R15-LCASAVE(,RPCC) Get Called Pgm Entry Address
         LGR   R4,RPCC             Preserve Calling Program's R13 Value
         LLGT  RPCC,LCASA_FWD-LCASAVE(,RPCC) Set Called Pgm's R13 Value
         XC    DSDPLIST,DSDPLIST   Clear the Call Parameter List
         CALL  LNME0000,           Process Storage Address for Mod NameX
               ((R5),              ..Pass Storage Addr to Be Resolved  X
               (RPCC),             ..Pass Abending Programs's LCA Addr X
               DSDLMODI,           ..Pass Addr of Load Module Info AreaX
               (RSDW),             ..Pass Address of the SDWA          X
               (RLGW),             ..Pass LGRWK2II Area Address        X
               (RCOMM)),           ..Pass Common Constants&Routines    X
               PLIST8=YES,         ..Indicate the Parameter List FormatX
               LINKINST=LGR,       ..Indicate the Link Instruction TypeX
               MF=(E,DSDPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Process Address for Load Module Name
         LTGFR R15,R15             Resolve Addr Processing Successful?
         BRZ   DSTD0200            Yes => Branch to Process Output Line
         LGHI  R2,((DSTD0300-DSTD0200)-4) ...Length of Branch Table
         CGFR  R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   DSTD0200            No  => Branch to Process Output Line
         BRU   DSTDEXIT            Yes => Branch to Exit This Routine
DSTD0200 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   DSTD0300            Addr Process Completed, Process Line
         BRU   DSTD0300            Branch on Warning-Ignore & Continue
         BRU   DSTDEXIT            Branch on Processing Error - Exit
         BRU   DSTDEXIT            Branch on Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*|  Format And Print the Called Program Detail Line                  |*
*|                                                                   |*
*|  Called Program Entry Point..: TESTPGM9+(026440)                  |*
*+-------------------------------------------------------------------+*
*
MODL     USING DTLINE07,R2         Addressability to Model Detail Lne 7
DSTD0300 DS    0H
         LGR   RPCC,R4             Restore Calling Program's R13 Value
         MVI   DSDLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DSDLINE+1(L'DSDLINE-1),DSDLINE ...Propogate the Blank
         MVI   DSDCCNTL,C' '       Set Carriage Control to Single Space
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DSTDEXIT            No  => Then Bypass Print Output
DSTD0400 DS    0H
         BRAS  R14,DSTDP100        Blank Separator Line to //LGRECOUT
DSTD0500 DS    0H
         MVI   DSDLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DSDLINE+1(L'DSDLINE-1),DSDLINE ...Propogate the Blank
         MVI   DSDCCNTL,C' '       Set Carriage Control to Single Space
         LA    R2,DSDOLINE         Obtain the Address of Output Line
         MVC   DTLNETYP-DTLINE07(L'DTLNETYP,R2),DSDPGEPA ...Entry Point
         MVC   DTLCALLP-DTLINE07(L'DTLCALLP,R2),LMOD.LRTPGMNM .Pgm Name
         LA    R2,MODL.DTLCALLP    Establish Current Position in Line
         DROP  MODL                Remove List Reg as Detail Line7 Base
DSTD0600 DS    0H
         CLI   0(R2),C' '          Is This The End of Load Module Name?
         BRE   DSTD0700            Yes => Branch to Process Version
         LA    R2,1(,R2)           Increment to the Next Character
         BRU   DSTD0600            Loop to Find the End of Module Name
DSTD0700 DS    0H
         LA    R2,1(,R2)           Increment Position for Spacer Byte
         MVC   0(L'LRTVERSN,R2),LMOD.LRTVERSN .Copy Module Version Info
DSTD0800 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DSTDEXIT            No  => Then Bypass Print Output
DSTD0900 DS    0H
         BRAS  R14,DSTDP100        Print Program Name Line to LGRECOUT
DSTD1000 DS    0H
         MVI   DSDLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DSDLINE+1(L'DSDLINE-1),DSDLINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*|  Format And Print the Called Load Module/Csect Address Detail Line|*
*|                                                                   |*
*|  TESTPGM9 Module Address: 0000000018600000                        |*
*+-------------------------------------------------------------------+*
*
DSTD1100 DS    0H
         LA    R2,DSDOLINE         Obtain the Address of Output Line
         CLC   LMOD.LRTLMOD(8),=C'UNKNOWN ' Is Load Module Name Known?
         BRE   DSTD2100            No  => Then No Load Info to Process
         MVC   5(L'LRTLMOD,R2),LMOD.LRTLMOD  ..Get the Load Module Name
         LA    R2,5(,R2)           Establish Current Position in Line
DSTD1200 DS    0H
         CLI   0(R2),C' '          Is This The End of the Csect Name?
         BRE   DSTD1300            Yes => Branch to Process Text Line
         LA    R2,1(,R2)           Increment to the Next Character
         BRU   DSTD1200            Loop to Find the End of Csect Name
DSTD1300 DS    0H
         LA    R2,1(,R2)           Increment Position for Spacer Byte
         MVC   0(L'DSDPGCSA,R2),DSDPGCSA Add Header Text to Detail Line
         LA    R2,L'DSDPGCSA(,R2)  Increment to End of the Header Text
         LG    R14,LMOD.LRTMSBAD   Acquire Main Storage Block Address
         STG   R14,DSDWORKD        Copy the Csect Address to Work Area
         UNPK  DSDWRK16(9),DSDWORKD(5) Get the High-Half Address Value
         UNPK  DSDWRK16+8(9),DSDWORKD+4(5) Get Low-Half Address Value
         TR    DSDWRK16,HEXCONV-C'0' Finalize Conversion to Zoned Char
         MVC   0(L'DSDWRK16,R2),DSDWRK16 Copy Csect Addr to Output Line
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DSTDEXIT            No  => Then Bypass Print Output
DSTD1400 DS    0H
         BRAS  R14,DSTDP100        Print Program Addr Line to LGRECOUT
DSTD1500 DS    0H
         MVI   DSDLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DSDLINE+1(L'DSDLINE-1),DSDLINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*|  Format And Print the Load Module/Csect Length Detail Line        |*
*|                                                                   |*
*|  TESTPGM9 Module Length.: 0004D8E8                                |*
*+-------------------------------------------------------------------+*
*
DSTD1600 DS    0H
         LA    R2,DSDOLINE         Obtain the Address of Output Line
         MVC   5(L'LRTLMOD,R2),LMOD.LRTLMOD  ..Get the Load Module Name
         LA    R2,5(,R2)           Establish Current Position in Line
DSTD1700 DS    0H
         CLI   0(R2),C' '          Is This The End of the Csect Name?
         BRE   DSTD1800            Yes => Branch to Process Text Line
         LA    R2,1(,R2)           Increment to the Next Character
         BRU   DSTD1700            Loop to Find the End of Csect Name
DSTD1800 DS    0H
         LA    R2,1(,R2)           Increment Position for Spacer Byte
         MVC   0(L'DSDPGCSL,R2),DSDPGCSL Add Header Text to Detail Line
         LA    R2,L'DSDPGCSL(,R2)  Increment to End of the Header Text
         UNPK  DSDWRK09,LMOD.LRTMSBLA(L'LRTMSBLA+1) Leng Storage Block
         TR    DSDWRK09(L'DSDWRK09-1),HEXCONV-C'0'  Convert Hex to Char
         MVC   0(L'DSDWRK09-1,R2),DSDWRK09 .Csect Length to Output Line
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DSTDEXIT            No  => Then Bypass Print Output
DSTD1900 DS    0H
         BRAS  R14,DSTDP100        Print Program Leng Line to LGRECOUT
DSTD2000 DS    0H
         MVI   DSDLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DSDLINE+1(L'DSDLINE-1),DSDLINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*|  Programs at Initiation Which Receive Control from the Operating  |*
*|  System Will Have the Return Address Pointing to CVTEXIT. Check   |*
*|  the Return Address in R14 to Determine Type of Entry.            |*
*|                                                                   |*
*|  Called Program Returns To...: Program was entered via LINK       |*
*+-------------------------------------------------------------------+*
*
DSTD2100 DS    0H
         LLGT  R1,CVTPTR           Absolute Address of Pointer to CVT
         LLGT  R2,CVTTCBP-CVTMAP(,R1)  Obtain Task Control Block Addr
         LA    R3,CVTEXIT-CVTMAP(,R1)  Obtain Addr of CVT Exit (SVC 3)
         LLGT  R2,L'PSATNEW(,R2)   Obtain the Current TCB Address
         LLGT  R2,TCBJSTCB-TCB(,R2) .Get Address of First Job Step TCB
         LLGT  R2,TCBFSA-TCB(,R2)  ..Get the Address of First Save Area
         LLGT  R1,LCASA_R14-LCASAVE(,RPCC)  Get Linkage Return Address
         CLGR  R2,R4               First Save Area Match Our R13 Value?
         BRNE  DSTD2700            No  => Process Linkage Return Addr
         CLGR  R3,R1               Does Return Addr Point to CVT Exit?
         BRE   DSTD2300            Yes => Indicate Entry Was Via Link
DSTD2200 DS    0H
         MVC   DSDOLINE(L'DSDPGRET),DSDPGRET ...Set Return Point Header
         MVC   DSDOLINE+L'DSDPGRET(L'DSDPGCAL),DSDPGCAL  Entry Via Call
         BRU   DSTD2400            Branch to Print Entry Type to Pgm
DSTD2300 DS    0H
         MVC   DSDOLINE(L'DSDPGRET),DSDPGRET ...Set Return Point Header
         MVC   DSDOLINE+L'DSDPGRET(L'DSDPGLNK),DSDPGLNK  Entry Via Link
DSTD2400 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DSTDEXIT            No  => Then Bypass Print Output
DSTD2500 DS    0H
         BRAS  R14,DSTDP100        Print Program Entry Type to LGRECOUT
DSTD2600 DS    0H
         MVI   DSDLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DSDLINE+1(L'DSDLINE-1),DSDLINE ...Propogate the Blank
         BRU   DSTD3500            Branch to Process Save Area Address
*
*+-------------------------------------------------------------------+*
*|   Determine the Load Module/Csect Name for the Calling Program    |*
*+-------------------------------------------------------------------+*
*
DSTD2700 DS    0H
         LLGT  R5,LCASA_R14-LCASAVE(,RPCC)  Get Linkage Return Address
         XC    DSDPLIST,DSDPLIST   Clear the Call Parameter List
         CALL  LNME0000,           Process Storage Address for Mod NameX
               ((R5),              ..Pass Storage Addr to Be Resolved  X
               (RPCC),             ..Pass Abending Programs's LCA Addr X
               DSDLMODI,           ..Pass Addr of Load Module Info AreaX
               (RSDW),             ..Pass Address of the SDWA          X
               (RLGW),             ..Pass LGRWK2II Area Address        X
               (RCOMM)),           ..Pass Common Constants&Routines    X
               PLIST8=YES,         ..Indicate the Parameter List FormatX
               LINKINST=LGR,       ..Indicate the Link Instruction TypeX
               MF=(E,DSDPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Process Address for Load Module Name
         LTGFR R15,R15             Resolve Addr Processing Successful?
         BRZ   DSTD2800            Yes => Branch to Process Output Line
         LGHI  R2,((DSTD2900-DSTD2800)-4) ...Length of Branch Table
         CGFR  R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   DSTD2800            No  => Branch to Process Output Line
         BRU   DSTDEXIT            Yes => Branch to Exit This Routine
DSTD2800 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   DSTD2900            Addr Process Completed, Process Line
         BRU   DSTD2900            Branch on Warning-Ignore & Continue
         BRU   DSTDEXIT            Branch on Processing Error - Exit
         BRU   DSTDEXIT            Branch on Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*|  Format And Print the Calling Program Detail Line                 |*
*|                                                                   |*
*|  Calling Program Returns To..: TESTPGM9+(02556E)                  |*
*+-------------------------------------------------------------------+*
*
MODL     USING DTLINE07,R2         Addressability to Model Detail Lne 7
DSTD2900 DS    0H
         LA    R2,DSDOLINE         Obtain the Address of Output Line
         MVC   DTLNETYP-DTLINE07(L'DTLNETYP,R2),DSDPGRET ..Return Point
         MVC   DTLCALLP-DTLINE07(L'DTLCALLP,R2),LMOD.LRTPGMNM .Pgm Name
         LA    R2,MODL.DTLCALLP    Establish Current Position in Line
         DROP  MODL                Remove List Reg as Detail Line7 Base
DSTD3000 DS    0H
         CLI   0(R2),C' '          Is This The End of Load Module Name?
         BRE   DSTD3100            Yes => Branch to Process Version
         LA    R2,1(,R2)           Increment to the Next Character
         BRU   DSTD3000            Loop to Find the End of Module Name
DSTD3100 DS    0H
         LA    R2,1(,R2)           Increment Position for Spacer Byte
         MVC   0(L'LRTVERSN,R2),LMOD.LRTVERSN .Copy Module Version Info
DSTD3200 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DSTDEXIT            No  => Then Bypass Print Output
DSTD3300 DS    0H
         BRAS  R14,DSTDP100        Print Calling Pgm Line to //LGRECOUT
DSTD3400 DS    0H
         MVI   DSDLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DSDLINE+1(L'DSDLINE-1),DSDLINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*|  Format And Print the Save Area Address Detail Line               |*
*|                                                                   |*
*|  Calling Program Save Area...: 0000000000006AE0                   |*
*+-------------------------------------------------------------------+*
*
MODL     USING DTLINE07,R2         Addressability to Model Detail Lne 7
DSTD3500 DS    0H
         LA    R2,DSDOLINE         Obtain the Address of Output Line
         STG   RPCC,DSDWORKD       Copy Save Area Address to Work Area
         UNPK  DSDWRK16(9),DSDWORKD(5) Get the High-Half Register Value
         UNPK  DSDWRK16+8(9),DSDWORKD+4(5) Get Low-Half Register Value
         TR    DSDWRK16,HEXCONV-C'0' Finalize Conversion to Zoned Char
         MVC   DTLNETYP-DTLINE07(L'DTLNETYP,R2),DSDPGSVA Line Type Hdr
         MVC   DTLCALLP-DTLINE07(L'DSDWRK16,R2),DSDWRK16 Save Area Addr
         DROP  MODL                Remove List Reg as Detail Line7 Base
DSTD3600 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DSTDEXIT            No  => Then Bypass Print Output
DSTD3700 DS    0H
         BRAS  R14,DSTDP100        Print Save Area Addr Lne to LGRECOUT
DSTD3800 DS    0H
         MVI   DSDLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DSDLINE+1(L'DSDLINE-1),DSDLINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*|  Format And Print General Purpose Registers R0 - R3 Detail Line   |*
*|  For Calling Program                                              |*
*|                                                                   |*
*|  Calling Program General Purpose Registers R0-R15 at Entry to Call|*
*|    0-3   00000000000108F8  0000000000006000  0000000000008000  000|*
*+-------------------------------------------------------------------+*
*
DSTD4000 DS    0H
         MVC   DSDREG0(13*4),LCASA_R0-LCASAVE(RPCC)  Get R0 Through R12
         ST    RPCC,DSDREG13       Now Obtain the Register R13 Value
         MVC   DSDREG14(2*4),LCASA_R14-LCASAVE(RPCC) ...Now R14 and R15
         MVC   DSDOLINE(PRNTLEN),DTLINE06  Statement for the GPR's Line
DSTD4100 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DSTDEXIT            No  => Then Bypass Print Output
DSTD4200 DS    0H
         BRAS  R14,DSTDP100        Print the GPR Statement to LGRECOUT
DSTD4300 DS    0H
         MVI   DSDLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DSDLINE+1(L'DSDLINE-1),DSDLINE ...Propogate the Blank
         MVC   DSDOLINE+2(3),=C'0-3' Indicate Register Set for Prnt Lne
         LA    R2,DSDOLINE+8       Position Start of Register Values
         LA    R3,DSDREGS          Get Starting Address of Reg Values
         LA    R4,L'DSDREGS        Indicate Length of Register Entry
         LA    R5,DSDREGS+(DSDEGLEN/4)-L'DSDREGS  ...For Regs R0 - R3
DSTD4400 DS    0H
         UNPK  DSDWRK16+1,0(5,R3)  Obtain the Save Area Register Value
         TR    DSDWRK16+1(L'DSDWRK16-1),HEXCONV-C'0' ..Hex to Character
         MVI   DSDWRK16,C'0'       Fill High Order Byte with Zoned Zero
         MVC   0(L'DSDWRK16,R2),DSDWRK16 .General Purpose Reg to Output
         LA    R2,18(,R2)          Increment to Next Register Field
         BRXLG R3,R4,DSTD4400      Loop to Process the Next Register
DSTD4500 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DSTDEXIT            No  => Then Bypass Print Output
DSTD4600 DS    0H
         BRAS  R14,DSTDP100        Print the GPR 0-3 Values to LGRECOUT
DSTD4700 DS    0H
         MVI   DSDLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DSDLINE+1(L'DSDLINE-1),DSDLINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*|  Format And Print General Purpose Registers R4 - R7 Detail Line   |*
*|  For Calling Program                                              |*
*|                                                                   |*
*|  4-7   000000000000F878  00000000008FF350  00000000008B8FE0  00000|*
*+-------------------------------------------------------------------+*
*
DSTD5000 DS    0H
         MVC   DSDOLINE+2(3),=C'4-7'  Indicate Register Set for Prt Lne
         LA    R2,DSDOLINE+8       Position Start of Register Values
         LA    R3,DSDREGS+(DSDEGLEN/4) ..Starting Address Points to R4
         LA    R4,L'DSDREGS        Indicate Length of Register Entry
         LA    R5,(DSDEGLEN/4)-L'DSDREGS(,R3)  ...For Regs R4 - R7
DSTD5100 DS    0H
         UNPK  DSDWRK16+1,0(5,R3)  Obtain the Save Area Register Value
         TR    DSDWRK16+1(L'DSDWRK16-1),HEXCONV-C'0' ..Hex to Character
         MVI   DSDWRK16,C'0'       Fill High Order Byte with Zoned Zero
         MVC   0(L'DSDWRK16,R2),DSDWRK16 .General Purpose Reg to Output
         LA    R2,18(,R2)          Increment to Next Register Field
         BRXLG R3,R4,DSTD5100      Loop to Process the Next Register
DSTD5200 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DSTDEXIT            No  => Then Bypass Print Output
DSTD5300 DS    0H
         BRAS  R14,DSTDP100        Print GPR 4-7 Values to //LGRECOUT
DSTD5400 DS    0H
         MVI   DSDLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DSDLINE+1(L'DSDLINE-1),DSDLINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*|  Format And Print General Purpose Registers R8 - R11 Detail Line  |*
*|  For Calling Program                                              |*
*|                                                                   |*
*|  8-11  00000000008FC030  00000000008C9CC8  0000000000000000  00000|*
*+-------------------------------------------------------------------+*
*
DSTD6000 DS    0H
         MVC   DSDOLINE+2(4),=C'8-11' Indicate Register Set for Prt Lne
         LA    R2,DSDOLINE+8       Position Start of Register Values
         LA    R3,DSDREGS+(DSDEGLEN/2) ..Starting Address Points to R8
         LA    R4,L'DSDREGS        Indicate Length of Register Entry
         LA    R5,(DSDEGLEN/4)-L'DSDREGS(,R3)  ...For Regs R8 - R11
DSTD6100 DS    0H
         UNPK  DSDWRK16+1,0(5,R3)  Obtain the High-Half Register Value
         TR    DSDWRK16+1(L'DSDWRK16-1),HEXCONV-C'0' ..Hex to Character
         MVI   DSDWRK16,C'0'       Fill High Order Byte with Zoned Zero
         MVC   0(L'DSDWRK16,R2),DSDWRK16 .General Purpose Reg to Output
         LA    R2,18(,R2)          Increment to Next Register Field
         BRXLG R3,R4,DSTD6100      Loop to Process the Next Register
DSTD6200 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DSTDEXIT            No  => Then Bypass Print Output
DSTD6300 DS    0H
         BRAS  R14,DSTDP100        Print GPR 8-11 Values to //LGRECOUT
DSTD6400 DS    0H
         MVI   DSDLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DSDLINE+1(L'DSDLINE-1),DSDLINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*|  Format And Print General Purpose Registers R12 - R15 Detail Line |*
*|  For Calling Program                                              |*
*|                                                                   |*
*|  12-15 0000000018625400  0000000000006AE0  000000009862556E  00000|*
*+-------------------------------------------------------------------+*
*
DSTD7000 DS    0H
         MVC   DSDOLINE+2(5),=C'12-15' Indicate the Registers to Print
         LA    R2,DSDOLINE+8       Position Start of Register Values
         LA    R3,DSDREGS+(DSDEGLEN/2+DSDEGLEN/4) Address Points to R12
         LA    R4,L'DSDREGS        Indicate Length of Register Entry
         LA    R5,(DSDEGLEN/4)-L'DSDREGS(,R3) ..For Registers R12 - R15
DSTD7100 DS    0H
         UNPK  DSDWRK16+1,0(5,R3)  Obtain the High-Half Register Value
         TR    DSDWRK16+1(L'DSDWRK16-1),HEXCONV-C'0' ..Hex to Character
         MVI   DSDWRK16,C'0'       Fill High Order Byte with Zoned Zero
         MVC   0(L'DSDWRK16,R2),DSDWRK16 .General Purpose Reg to Output
         LA    R2,18(,R2)          Increment to Next Register Field
         BRXLG R3,R4,DSTD7100      Loop to Process the Next Register
DSTD7200 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DSTDEXIT            No  => Then Bypass Print Output
DSTD7300 DS    0H
         BRAS  R14,DSTDP100        Print GPR 12-15 Values to LGRECOUT
DSTD7400 DS    0H
         MVI   DSDLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DSDLINE+1(L'DSDLINE-1),DSDLINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*|   Return to Caller                                                |*
*+-------------------------------------------------------------------+*
*
DSTDEXIT DS    0H
         SLGR  R15,R15             Indicate Successful Completion
         ST    R15,DSDRETCD        Set the Return Code
         LPGMEXIT RC=DSDRETCD      Define Program Exit Protocol
*
*+-------------------------------------------------------------------+*
*|         P r i n t   O u t p u t   D e t a i l   L i n e           |*
*+-------------------------------------------------------------------+*
*|SUBROUTINE NAME: DSTDP100                                          |*
*|FUNCTION.......: Print Detail Line to Output Logger Data Set       |*
*+-------------------------------------------------------------------+*
*
DSTDP100 LPGMSUBE                  Set Subroutine Entry Protocol
         SYSSTATE AMODE64=NO,ARCHLVL=2 Generate Code for Not in AMODE64
         SAM31                     Switch Now to 31-Bit Addressing Mode
         PUT   LGWODCB,DSDLINE     Print Output Line to //LGRECOUT
         SAM64                     Switch Back to 64-Bit Address Mode
         SYSSTATE AMODE64=YES,ARCHLVL=2    Restore 64-Bit Environment
         LPGMSUBX                  Return to Caller of This Subroutine
*
*+-------------------------------------------------------------------+*
*|   Definition for Constants                                        |*
*+-------------------------------------------------------------------+*
*
DSDPGEPA DC    C'Called Program Entry Point..: ' EPA Detail Line Header
DSDPGCSA DC    C'Module Address: ' Load Module Address Detail Line Hdr
DSDPGCSL DC    C'Module Length.: ' Load Module Length Detail Line Hdr
DSDPGRET DC    C'Called Program Returns To...: ' RET Detail Line Header
DSDPGSVA DC    C'Calling Program Save Area...: ' SA Detail Line Header
DSDPGLNK DC    C'Program was entered via LINK '  Entry was from System
DSDPGCAL DC    C'Program was entered via CALL '  Entry was from Program
*
*+-------------------------------------------------------------------+*
*|    Program RENT Work Area                                         |*
*+-------------------------------------------------------------------+*
*
         LCA   DEFINE              Define the Program RENT Work Area
*
DSDWORKD DS    10D                 General Purpose Work Area
DSDPLIST DS    20FD                CALL Parameter List
DSDREGS  DS    0F                  Caller's Register Save Area
DSDREG0  DS    13F                 Caller's Register Save Area R0-R12
DSDREG13 DS    F                   Caller's Register R13 Save Area
DSDREG14 DS    2F                  Caller's Register Save Area R14-R15
DSDEGLEN EQU   *-DSDREGS           Length of Caller's R0 thru R15 Area
DSDRETCD DS    F                   Save Area for the Return Code
DSDWRK09 DS    CL9                 Area for Unpacking Length Values
DSDWRK16 DS    CL16                Area for Unpacking Register Values
         DS    XL1                 Slack for Reverse of Low Order Byte
DSDLMODI DS    CL(LRTLMLEN)        Area for Load Module Information Blk
DSDLINE  DS    0CL133              Output Print Line Area
DSDCCNTL DS    CL1                 Carriage Control Character
DSDOLINE DS    CL132               Output Record Print Area
*
         LCA   DEFEND              Define End of Program RENT Work Area
*
***********************************************************************
*          End of Standard Save Area Information Processing           *
***********************************************************************
         EJECT ,
***********************************************************************
**************************+-----------------+**************************
**************************| D E X S 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|       P r o c e s s   E x t e n d e d   S a v e   A r e a         |*
*+-------------------------------------------------------------------+*
* PROGRAM NAME:    DEXS0000                                           *
*                                                                     *
* FUNCTION:        Process Extended Save Area                         *
*                                                                     *
*                  This routine is responsible for processing a       *
*                  extended format save area. Prints the load module/ *
*                  Csect name and offset of calling program at entry  *
*                  to the called program, and prints the general      *
*                  purpose registers of calling program at entry to   *
*                  called program.                                    *
*                                                                     *
*For example:                                                         *
*                                                                     *
*Called Program Entry Point..: USERPGM2.VRDT0000+(0000)  20110327 13.2*
*      VRDT0000 Csect Address: 0000000001031918                       *
*      VRDT0000 Csect Length.: 00000908                               *
*Called Program Returns To...: USERPGM2.CNTL0000+(08B2)  20110327 13.2*
*Calling Program Save Area...: 0000000000010698                       *
*Calling Program General Purpose Registers R0-R15 at Entry to Called P*
*  0-3   0000000000010920  0000000000021028  00000000010341FC  0000000*
*  4-7   000000000000F890  000000000000F8E9  0000000081030CEC  0000000*
*  8-11  0000000001034000  0000000000022000  0000000000021000  0000000*
*  12-15 0000000001030550  0000000000010698  0000000081030DF2  0000000*
*                                                                     *
* INPUT REGS:      R1 => Standard O/S Parameter List                  *
*                                                                     *
* INPUT DATA:      Parm1: Addr of System Diagnostic Work Area         *
*                  Parm2: Addr of LGRWK2II Logger Work Area           *
*                  Parm3: Addr of Common Constants and Routines Area  *
*                  Parm4: Addr of Abending Program's LCA Area         *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY, AC=0                          *
*                                                                     *
* CALLING PROGRAM: DIAG0000 - Analyze System Diagnostic Work Area Pgm *
*                                                                     *
* CALLED PROGRAMS: LNME0000 - Logger Services Program to Resolve an   *
*                             Address to a Load Module Name           *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                  04 - Warning                                       *
*                  08 - Error                                         *
*                  12 - Severe Error - Exit This Routine              *
*                                                                     *
***********************************************************************
*
DEXS0000 LPGMNTRY TYPE=SUB,        Define As A Sub-Program Entry       X
               BASE=(12),          Establish Base Registers            X
               AMOD=64,RMOD=ANY,   Addressing and Residency Modes      X
               LCAPFX=DSX,         Establish LCA Prefix for This RSECT X
               LOG=OFF,            Always Turn Logging 'Off' in Logger!X
               LINKRTRN=BSM,       Define Return Linkage Instruction   X
               COPY@RT=YES         To Generate a Copyright Statement
         USING COM_DATA,RCOMM      Addressability to Common Data Area
         USING LGRWK2II,RLGW       Establish Addressability to LGRWK2II
         USING SDWA,RSDW           Establish Addressability to SDWA
         USING IHADCB,LGWODCB      Establish Addressability to DCB
LMOD     USING LRTLMBLK,DSXLMODI   Establish Addressability to LMODI
         LMG   R8,R10,0(R1)        Load the Parameter Area Addresses
         LG    RPCC,24(,R1)        Get the Current Save Area Address
         XC    DSXRETCD,DSXRETCD   Initialize the Return Code
*
*+-------------------------------------------------------------------+*
*|    Determine the Load Module/Csect Name For the Called Program    |*
*+-------------------------------------------------------------------+*
*
DEXS0100 DS    0H
         LA    R1,DEXSEXIT         Get Retry Recovery Address (ESPIE)
         ST    R1,LGWRETRY         Preserve It In Case of an Abend
         LG    R5,LCAF64R15-LCASAVE(,RPCC) Get Called Pgm Entry Address
         LGR   R4,RPCC             Preserve Calling Program's R13 Value
         LG    RPCC,LCAF64FWD-LCASAVE(,RPCC) Set Called Pgm's R13 Value
         XC    LGWRETRY,LGWRETRY   Disable Recovery, Area Referenced
         XC    DSXPLIST,DSXPLIST   Clear the Call Parameter List
         CALL  LNME0000,           Process Storage Address for Mod NameX
               ((R5),              ..Pass Storage Addr to Be Resolved  X
               (RPCC),             ..Pass Abending Programs's LCA Addr X
               DSXLMODI,           ..Pass Addr of Load Module Info AreaX
               (RSDW),             ..Pass Address of the SDWA          X
               (RLGW),             ..Pass LGRWK2II Area Address        X
               (RCOMM)),           ..Pass Common Constants&Routines    X
               PLIST8=YES,         ..Indicate the Parameter List FormatX
               LINKINST=LGR,       ..Indicate the Link Instruction TypeX
               MF=(E,DSXPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Process Address for Load Module Name
         LTGFR R15,R15             Resolve Addr Processing Successful?
         BRZ   DEXS0200            Yes => Branch to Process Output Line
         LGHI  R2,((DEXS0300-DEXS0200)-4) ...Length of Branch Table
         CGFR  R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   DEXS0200            No  => Branch to Process Output Line
         BRU   DEXSEXIT            Yes => Branch to Exit This Routine
DEXS0200 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   DEXS0300            Addr Process Completed, Process Line
         BRU   DEXS0300            Branch on Warning-Ignore & Continue
         BRU   DEXSEXIT            Branch on Processing Error - Exit
         BRU   DEXSEXIT            Branch on Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*|  Format And Print the Called Program Detail Line                  |*
*|                                                                   |*
*|  Called Program Entry Point..: USERPGM2.VRDT0000+(0000)  20110327 |*
*+-------------------------------------------------------------------+*
*
MODL     USING DTLINE07,R2         Addressability to Model Detail Lne 7
DEXS0300 DS    0H
         MVI   DSXLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DSXLINE+1(L'DSXLINE-1),DSXLINE ...Propogate the Blank
         MVI   DSXCCNTL,C' '       Set Carriage Control to Single Space
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DEXSEXIT            No  => Then Bypass Print Output
DEXS0400 DS    0H
         BRAS  R14,DEXSP100        Blank Separator Line to //LGRECOUT
DEXS0500 DS    0H
         MVI   DSXLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DSXLINE+1(L'DSXLINE-1),DSXLINE ...Propogate the Blank
         MVI   DSXCCNTL,C' '       Set Carriage Control to Single Space
         LA    R2,DSXOLINE         Obtain the Address of Output Line
         MVC   DTLNETYP-DTLINE07(L'DTLNETYP,R2),DSXPGEPA ...Entry Point
         MVC   DTLCALLP-DTLINE07(L'DTLCALLP,R2),LMOD.LRTPGMNM .Pgm Name
         LA    R2,MODL.DTLCALLP    Establish Current Position in Line
         DROP  MODL                Remove List Reg as Detail Line7 Base
DEXS0600 DS    0H
         CLI   0(R2),C' '          Is This The End of Load Module Name?
         BRE   DEXS0700            Yes => Branch to Process Version
         LA    R2,1(,R2)           Increment to the Next Character
         BRU   DEXS0600            Loop to Find the End of Module Name
DEXS0700 DS    0H
         LA    R2,1(,R2)           Increment Position for Spacer Byte
         MVC   0(L'LRTVERSN,R2),LMOD.LRTVERSN .Copy Module Version Info
DEXS0800 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DEXSEXIT            No  => Then Bypass Print Output
DEXS0900 DS    0H
         BRAS  R14,DEXSP100        Print Program Name Line to LGRECOUT
DEXS1000 DS    0H
         MVI   DSXLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DSXLINE+1(L'DSXLINE-1),DSXLINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*|  Format And Print the Called Program Csect Address Detail Line    |*
*|                                                                   |*
*|     VRDT0000 Csect Address: 0000000001031918                      |*
*+-------------------------------------------------------------------+*
*
DEXS1100 DS    0H
         LA    R2,DSXOLINE         Obtain the Address of Output Line
         CLC   0(L'LCAS64PLI,RPCC),=C'LCA ' .Pgm Using Logger Services?
         BRNE  DEXS2500            No  => Then No LCA to Process
         CLC   LMOD.LRTLMOD(8),=C'UNKNOWN ' Is Load Module Name Known?
         BRE   DEXS2500            No  => Then No Load Info to Process
         CLC   LMOD.LRTCSECT(8),=C'UNKNOWN ' Contrl Section Name Known?
         BRE   DEXS2500            No  => Then No Csect Info to Process
         MVC   6(L'LRTCSECT,R2),LMOD.LRTCSECT ...Get the Csect Name
         LA    R2,6(,R2)           Establish Current Position in Line
DEXS1200 DS    0H
         CLI   0(R2),C' '          Is This The End of the Csect Name?
         BRE   DEXS1300            Yes => Branch to Process Text Line
         LA    R2,1(,R2)           Increment to the Next Character
         BRU   DEXS1200            Loop to Find the End of Csect Name
DEXS1300 DS    0H
         LA    R2,1(,R2)           Increment Position for Spacer Byte
         MVC   0(L'DSXPGCSA,R2),DSXPGCSA Add Header Text to Detail Line
         LA    R2,L'DSXPGCSA(,R2)  Increment to End of the Header Text
         CLC   0(L'LCAS64PLI,RPCC),=C'LCA ' .Pgm Using Logger Services?
         BRNE  DEXS1400            No  => Then Use CDE Storage Address
         LLGT  R14,LCACSADR-LCASAVE(,RPCC) ...Get the Csect Address
         BRU   DEXS1500            Branch to Process Csect Address
DEXS1400 DS    0H
         LG    R14,LMOD.LRTMSBAD   Acquire Main Storage Block Address
DEXS1500 DS    0H
         STG   R14,DSXWORKD        Copy the Csect Address to Work Area
         UNPK  DSXWRK16(9),DSXWORKD(5) Get the High-Half Address Value
         UNPK  DSXWRK16+8(9),DSXWORKD+4(5) Get Low-Half Address Value
         TR    DSXWRK16,HEXCONV-C'0' Finalize Conversion to Zoned Char
         MVC   0(L'DSXWRK16,R2),DSXWRK16 Copy Csect Addr to Output Line
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DEXSEXIT            No  => Then Bypass Print Output
DEXS1600 DS    0H
         BRAS  R14,DEXSP100        Print Program Addr Line to LGRECOUT
DEXS1700 DS    0H
         MVI   DSXLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DSXLINE+1(L'DSXLINE-1),DSXLINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*|  Format And Print the Called Program Csect Length Detail Line     |*
*|                                                                   |*
*|     VRDT0000 Csect Length.: 00000908                              |*
*+-------------------------------------------------------------------+*
*
DEXS1800 DS    0H
         LA    R2,DSXOLINE         Obtain the Address of Output Line
         MVC   6(L'LRTCSECT,R2),LMOD.LRTCSECT ...Get the Csect Name
         LA    R2,6(,R2)           Establish Current Position in Line
DEXS1900 DS    0H
         CLI   0(R2),C' '          Is This The End of the Csect Name?
         BRE   DEXS2000            Yes => Branch to Process Text Line
         LA    R2,1(,R2)           Increment to the Next Character
         BRU   DEXS1900            Loop to Find the End of Csect Name
DEXS2000 DS    0H
         LA    R2,1(,R2)           Increment Position for Spacer Byte
         MVC   0(L'DSXPGCSL,R2),DSXPGCSL Add Header Text to Detail Line
         LA    R2,L'DSXPGCSL(,R2)  Increment to End of the Header Text
         CLC   0(L'LCAS64PLI,RPCC),=C'LCA ' .Pgm Using Logger Services?
         BRNE  DEXS2100            No  => Then Use CDE Storage Length
         UNPK  DSXWRK09,LCACSLTH-LCASAVE(L'LCACSLTH+1,RPCC) Csect Leng
         BRU   DEXS2200            Branch to Process the Csect Length
DEXS2100 DS    0H
         UNPK  DSXWRK09,LMOD.LRTMSBLA(L'LRTMSBLA+1) Leng Storage Block
DEXS2200 DS    0H
         TR    DSXWRK09(L'DSXWRK09-1),HEXCONV-C'0'  Convert Hex to Char
         MVC   0(L'DSXWRK09-1,R2),DSXWRK09 .Csect Length to Output Line
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DEXSEXIT            No  => Then Bypass Print Output
DEXS2300 DS    0H
         BRAS  R14,DEXSP100        Print Program Leng Line to LGRECOUT
DEXS2400 DS    0H
         MVI   DSXLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DSXLINE+1(L'DSXLINE-1),DSXLINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*|   Determine the Load Module/Csect Name for the Calling Program    |*
*+-------------------------------------------------------------------+*
*
DEXS2500 DS    0H
         LGR   RPCC,R4             Restore Calling Program's R13 Value
         LG    R5,LCAF64R14-LCASAVE(,RPCC)  Get Linkage Return Address
         XC    DSXPLIST,DSXPLIST   Clear the Call Parameter List
         CALL  LNME0000,           Process Storage Address for Mod NameX
               ((R5),              ..Pass Storage Addr to Be Resolved  X
               (RPCC),             ..Pass Abending Programs's LCA Addr X
               DSXLMODI,           ..Pass Addr of Load Module Info AreaX
               (RSDW),             ..Pass Address of the SDWA          X
               (RLGW),             ..Pass LGRWK2II Area Address        X
               (RCOMM)),           ..Pass Common Constants&Routines    X
               PLIST8=YES,         ..Indicate the Parameter List FormatX
               LINKINST=LGR,       ..Indicate the Link Instruction TypeX
               MF=(E,DSXPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Process Address for Load Module Name
         LTGFR R15,R15             Resolve Addr Processing Successful?
         BRZ   DEXS2600            Yes => Branch to Process Output Line
         LGHI  R2,((DEXS2700-DEXS2600)-4) ...Length of Branch Table
         CGFR  R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   DEXS2600            No  => Branch to Process Output Line
         BRU   DEXSEXIT            Yes => Branch to Exit This Routine
DEXS2600 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   DEXS2700            Addr Process Completed, Process Line
         BRU   DEXS2700            Branch on Warning-Ignore & Continue
         BRU   DEXSEXIT            Branch on Processing Error - Exit
         BRU   DEXSEXIT            Branch on Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*|  Format And Print the Calling Program Detail Line                 |*
*|                                                                   |*
*|  Called Program Returns To...: USERPGM2.CNTL0000+(08B2)  20110327 |*
*+-------------------------------------------------------------------+*
*
MODL     USING DTLINE07,R2         Addressability to Model Detail Lne 5
DEXS2700 DS    0H
         LA    R2,DSXOLINE         Obtain the Address of Output Line
         MVC   DTLNETYP-DTLINE07(L'DTLNETYP,R2),DSXPGRET ..Return Point
         MVC   DTLCALLP-DTLINE07(L'DTLCALLP,R2),LMOD.LRTPGMNM .Pgm Name
         LA    R2,MODL.DTLCALLP    Establish Current Position in Line
         DROP  MODL                Remove List Reg as Detail Line7 Base
DEXS2800 DS    0H
         CLI   0(R2),C' '          Is This The End of Load Module Name?
         BRE   DEXS2900            Yes => Branch to Process Version
         LA    R2,1(,R2)           Increment to the Next Character
         BRU   DEXS2800            Loop to Find the End of Module Name
DEXS2900 DS    0H
         LA    R2,1(,R2)           Increment Position for Spacer Byte
         MVC   0(L'LRTVERSN,R2),LMOD.LRTVERSN .Copy Module Version Info
DEXS3000 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DEXSEXIT            No  => Then Bypass Print Output
DEXS3100 DS    0H
         BRAS  R14,DEXSP100        Print Calling Pgm Line to //LGRECOUT
DEXS3200 DS    0H
         MVI   DSXLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DSXLINE+1(L'DSXLINE-1),DSXLINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*|  Format And Print the Save Area Address Detail Line               |*
*|                                                                   |*
*|  Calling Program Save Area...: 0000000000010698                   |*
*+-------------------------------------------------------------------+*
*
MODL     USING DTLINE07,R2         Addressability to Model Detail Lne 7
DEXS3300 DS    0H
         LA    R2,DSXOLINE         Obtain the Address of Output Line
         STG   RPCC,DSXWORKD       Copy Save Area Address to Work Area
         UNPK  DSXWRK16(9),DSXWORKD(5) Get the High-Half Address Value
         UNPK  DSXWRK16+8(9),DSXWORKD+4(5) Get Low-Half Address Value
         TR    DSXWRK16,HEXCONV-C'0' Finalize Conversion to Zoned Char
         MVC   DTLNETYP-DTLINE07(L'DTLNETYP,R2),DSXPGSVA Line Type Hdr
         MVC   DTLCALLP-DTLINE07(L'DSXWRK16,R2),DSXWRK16 Save Area Addr
         DROP  MODL                Remove List Reg as Detail Line7 Base
DEXS3400 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DEXSEXIT            No  => Then Bypass Print Output
DEXS3500 DS    0H
         BRAS  R14,DEXSP100        Print Save Area Addr Lne to LGRECOUT
DEXS3600 DS    0H
         MVI   DSXLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DSXLINE+1(L'DSXLINE-1),DSXLINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*|  Format And Print General Purpose Registers R0 - R3 Detail Line   |*
*|  For Calling Program                                              |*
*|                                                                   |*
*|  Calling Program General Purpose Registers R0-R15 at Entry to Call|*
*|    0-3   0000000000010920  0000000000021028  00000000010341FC  000|*
*+-------------------------------------------------------------------+*
*
DEXS4000 DS    0H
         LA    R1,DEXSEXIT         Get Retry Recovery Address (ESPIE)
         ST    R1,LGWRETRY         Preserve It In Case of an Abend
         MVC   DSXREG0(13*8),LCAF64R00-LCASAVE(RPCC) Get R0 Through R12
         STG   RPCC,DSXREG13       Next Get the Register R13 Value
         MVC   DSXREG14(2*8),LCAF64R14-LCASAVE(RPCC) ...Now R14 and R15
         XC    LGWRETRY,LGWRETRY   Disable Recovery, Area Referenced
         MVC   DSXOLINE(PRNTLEN),DTLINE06  Statement for the GPR's Line
DEXS4100 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DEXSEXIT            No  => Then Bypass Print Output
DEXS4200 DS    0H
         BRAS  R14,DEXSP100        Print GPR Header Line to //LGRECOUT
DEXS4300 DS    0H
         MVI   DSXLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DSXLINE+1(L'DSXLINE-1),DSXLINE ...Propogate the Blank
         MVC   DSXOLINE+2(3),=C'0-3' Indicate Register Set for Prnt Lne
         LA    R2,DSXOLINE+8       Position Start of Register Values
         LA    R3,DSXREGS          Get Starting Address of Reg Values
         LA    R4,L'DSXREGS        Indicate Length of Register Entry
         LA    R5,DSXREGS+(DSXEGLEN/4)-L'DSXREGS  ...For Regs R0 - R3
DEXS4400 DS    0H
         UNPK  DSXWRK16(9),0(5,R3) Obtain the High-Half Register Value
         UNPK  DSXWRK16+8(9),4(5,R3) Obtain the Low-Half Register Value
         TR    DSXWRK16,HEXCONV-C'0' Finalize Conversion to Zoned Char
         MVC   0(L'DSXWRK16,R2),DSXWRK16 .General Purpose Reg to Output
         LA    R2,18(,R2)           Increment to Next Register Field
         BRXLG R3,R4,DEXS4400       Loop to Process the Next Register
DEXS4500 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DEXSEXIT            No  => Then Bypass Print Output
DEXS4600 DS    0H
         BRAS  R14,DEXSP100        Print the GPR 0-3 Values to LGRECOUT
DEXS4700 DS    0H
         MVI   DSXLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DSXLINE+1(L'DSXLINE-1),DSXLINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*|  Format And Print General Purpose Registers R4 - R7 Detail Line   |*
*|  For Calling Program                                              |*
*|                                                                   |*
*|  4-7   000000000000F890  000000000000F8E9  0000000081030CEC  00000|*
*+-------------------------------------------------------------------+*
*
DEXS5000 DS    0H
         MVC   DSXOLINE+2(3),=C'4-7'  Indicate Register Set for Prt Lne
         LA    R2,DSXOLINE+8       Position Start of Register Values
         LA    R3,DSXREGS+(DSXEGLEN/4) ..Starting Address Points to R4
         LA    R4,L'DSXREGS        Indicate Length of Register Entry
         LA    R5,(DSXEGLEN/4)-L'DSXREGS(,R3)  ...For Regs R4 - R7
DEXS5100 DS    0H
         UNPK  DSXWRK16(9),0(5,R3) Obtain the High-Half Register Value
         UNPK  DSXWRK16+8(9),4(5,R3) Obtain the Low-Half Register Value
         TR    DSXWRK16,HEXCONV-C'0' Finalize Conversion to Zoned Char
         MVC   0(L'DSXWRK16,R2),DSXWRK16 .General Purpose Reg to Output
         LA    R2,18(,R2)           Increment to Next Register Field
         BRXLG R3,R4,DEXS5100       Loop to Process the Next Register
DEXS5200 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DEXSEXIT            No  => Then Bypass Print Output
DEXS5300 DS    0H
         BRAS  R14,DEXSP100        Print GPR 4-7 Values to //LGRECOUT
DEXS5400 DS    0H
         MVI   DSXLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DSXLINE+1(L'DSXLINE-1),DSXLINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*|  Format And Print General Purpose Registers R8 - R11 Detail Line  |*
*|  For Calling Program                                              |*
*|                                                                   |*
*|  8-11  0000000001034000  0000000000022000  0000000000021000  00000|*
*+-------------------------------------------------------------------+*
*
DEXS6000 DS    0H
         MVC   DSXOLINE+2(4),=C'8-11' Indicate Register Set for Prt Lne
         LA    R2,DSXOLINE+8       Position Start of Register Values
         LA    R3,DSXREGS+(DSXEGLEN/2) ..Starting Address Points to R8
         LA    R4,L'DSXREGS        Indicate Length of Register Entry
         LA    R5,(DSXEGLEN/4)-L'DSXREGS(,R3)  ...For Regs R8 - R11
DEXS6100 DS    0H
         UNPK  DSXWRK16(9),0(5,R3) Obtain the High-Half Register Value
         UNPK  DSXWRK16+8(9),4(5,R3) Obtain the Low-Half Register Value
         TR    DSXWRK16,HEXCONV-C'0' Finalize Conversion to Zoned Char
         MVC   0(L'DSXWRK16,R2),DSXWRK16 .General Purpose Reg to Output
         LA    R2,18(,R2)           Increment to Next Register Field
         BRXLG R3,R4,DEXS6100       Loop to Process the Next Register
DEXS6200 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DEXSEXIT            No  => Then Bypass Print Output
DEXS6300 DS    0H
         BRAS  R14,DEXSP100        Print GPR 8-11 Values to //LGRECOUT
DEXS6400 DS    0H
         MVI   DSXLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DSXLINE+1(L'DSXLINE-1),DSXLINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*|  Format And Print General Purpose Registers R12 - R15 Detail Line |*
*|  For Calling Program                                              |*
*|                                                                   |*
*|  12-15 0000000001030550  0000000000010698  0000000081030DF2  00000|*
*+-------------------------------------------------------------------+*
*
DEXS7000 DS    0H
         MVC   DSXOLINE+2(5),=C'12-15' Indicate the Registers to Print
         LA    R2,DSXOLINE+8       Position Start of Register Values
         LA    R3,DSXREGS+(DSXEGLEN/2+DSXEGLEN/4) Address Points to R12
         LA    R4,L'DSXREGS        Indicate Length of Register Entry
         LA    R5,(DSXEGLEN/4)-L'DSXREGS(,R3) ..For Registers R12 - R15
DEXS7100 DS    0H
         UNPK  DSXWRK16(9),0(5,R3) Obtain the High-Half Register Value
         UNPK  DSXWRK16+8(9),4(5,R3) Obtain the Low-Half Register Value
         TR    DSXWRK16,HEXCONV-C'0' Finalize Conversion to Zoned Char
         MVC   0(L'DSXWRK16,R2),DSXWRK16 .General Purpose Reg to Output
         LA    R2,18(,R2)           Increment to Next Register Field
         BRXLG R3,R4,DEXS7100       Loop to Process the Next Register
DEXS7200 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DEXSEXIT            No  => Then Bypass Print Output
DEXS7300 DS    0H
         BRAS  R14,DEXSP100        Print GPR 12-15 Values to //LGRECOUT
DEXS7400 DS    0H
         MVI   DSXLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DSXLINE+1(L'DSXLINE-1),DSXLINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*|   Return to Caller                                                |*
*+-------------------------------------------------------------------+*
*
DEXSEXIT DS    0H
         XC    LGWRETRY,LGWRETRY   Disable the Recovery Environment
         SLGR  R15,R15             Indicate Successful Completion
         ST    R15,DSXRETCD        Set the Return Code
         LPGMEXIT RC=DSXRETCD      Define Program Exit Protocol
*
*+-------------------------------------------------------------------+*
*|         P r i n t   O u t p u t   D e t a i l   L i n e           |*
*+-------------------------------------------------------------------+*
*|SUBROUTINE NAME: DSTDP100                                          |*
*|FUNCTION.......: Print Detail Line to Output Logger Data Set       |*
*+-------------------------------------------------------------------+*
*
DEXSP100 LPGMSUBE                  Set Subroutine Entry Protocol
         SYSSTATE AMODE64=NO,ARCHLVL=2 Generate Code for Not in AMODE64
         SAM31                     Switch Now to 31-Bit Addressing Mode
         PUT   LGWODCB,DSXLINE     Print Output Line to //LGRECOUT
         SAM64                     Switch Back to 64-Bit Address Mode
         SYSSTATE AMODE64=YES,ARCHLVL=2    Restore 64-Bit Environment
         LPGMSUBX                  Return to Caller of This Subroutine
*
*+-------------------------------------------------------------------+*
*|   Definition for Constants                                        |*
*+-------------------------------------------------------------------+*
*
DSXPGEPA DC    C'Called Program Entry Point..: ' EPA Detail Line Header
DSXPGCSA DC    C'Csect Address: '  Csect Address Detail Line Header
DSXPGCSL DC    C'Csect Length.: '  Csect Length Detail Line Header
DSXPGRET DC    C'Called Program Returns To...: ' RET Detail Line Header
DSXPGSVA DC    C'Calling Program Save Area...: ' SA Detail Line Header
*
*+-------------------------------------------------------------------+*
*|    Program RENT Work Area                                         |*
*+-------------------------------------------------------------------+*
*
         LCA   DEFINE              Define the Program RENT Work Area
*
DSXWORKD DS    10D                 General Purpose Work Area
DSXPLIST DS    20FD                CALL Parameter List
DSXREGS  DS    0FD                 Caller's Register Save Area
DSXREG0  DS    13FD                Caller's Register Save Area R0-R12
DSXREG13 DS    FD                  Caller's Register R13 Save Area
DSXREG14 DS    2FD                 Caller's Register Save Area R14-R15
DSXEGLEN EQU   *-DSXREGS           Length of Caller's R0 thru R15 Area
DSXRETCD DS    F                   Save Area for the Return Code
DSXWRK09 DS    CL9                 Area for Unpacking Length Values
DSXWRK16 DS    CL16                Area for Unpacking Register Values
         DS    XL1                 Slack for Reverse of Low Order Byte
DSXLMODI DS    CL(LRTLMLEN)        Area for Load Module Information Blk
DSXLINE  DS    0CL133              Output Print Line Area
DSXCCNTL DS    CL1                 Carriage Control Character
DSXOLINE DS    CL132               Output Record Print Area
*
         LCA   DEFEND              Define End of Program RENT Work Area
*
***********************************************************************
*          End of Extended Save Area Information Processing           *
***********************************************************************
         EJECT ,
***********************************************************************
**************************+-----------------+**************************
**************************| D 5 X S 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*| P r o c e s s  F o r m a t - 5  E x t e n d e d  S a v e  A r e a |*
*+-------------------------------------------------------------------+*
* PROGRAM NAME:    D5XS0000                                           *
*                                                                     *
* FUNCTION:        Process Format-5 Extended Save Area                *
*                                                                     *
*                  This routine is responsible for processing a       *
*                  Format-5 extended format save area. Prints the     *
*                  load module/Csect name and offset of calling       *
*                  program at entry to the called program, and prints *
*                  the general purpose registers of calling program   *
*                  at entry to called program. Since Logger Services  *
*                  upon start from the main program does not know the *
*                  characteristics of or have control of its caller,  *
*                  whether by an application or the z/OS system,      *
*                  Logger assumes a 72-byte save area is all that is  *
*                  provided by the caller assuming a calling user     *
*                  program even bothered to provide one. In this      *
*                  instance Logger Services saves the low-half of the *
*                  64-bit registers R0 through R15 in the caller's    *
*                  save area, and after obtaining dynamic storage     *
*                  saves the high-half of the general purpose         *
*                  registers in its own Format-5 dynamic storage area *
*                  referred to as the LCA First save area. This       *
*                  routine basically joins these bifarcated register  *
*                  values from the caller provided save area and from *
*                  the called program's own save area created by      *
*                  Logger Services. This routine takes these two areas*
*                  with 32-bit values and builds contiguous 64-bit    *
*                  register values in a separate Format-4 like work   *
*                  area. This separate work area is then used as input*
*                  for processing the save area values to be printed. *
*                                                                     *
*For example:                                                         *
*                                                                     *
*Called Program Entry Point..: TESTPGM7+(000000)                      *
*     TESTPGM7 Module Address: 0000000018600000                       *
*     TESTPGM7 Module Length.: 0003F0A8                               *
*Called Program Returns To...: Program was entered via LINK           *
*Calling Program Save Area...: 0000000000006F60                       *
*Calling Program General Purpose Registers R0-R15 at Entry to Called P*
*  0-3   00000000FD000008  0000000000006FF8  0000000000000040  0000000*
*  4-7   00000000008D1D60  00000000008FF358  00000000008B8FE0  0000000*
*  8-11  00000000008FC010  00000000008C9CD0  0000000000000000  0000000*
*  12-15 0000000083191B4A  0000000000006F60  0000000080FD9078  0000000*
*                                                                     *
* INPUT REGS:      R1 => Standard O/S Parameter List                  *
*                                                                     *
* INPUT DATA:      Parm1: Addr of System Diagnostic Work Area         *
*                  Parm2: Addr of LGRWK2II Logger Work Area           *
*                  Parm3: Addr of Common Constants and Routines Area  *
*                  Parm4: Addr of Abending Program's LCA Area         *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY, AC=0                          *
*                                                                     *
* CALLING PROGRAM: DIAG0000 - Analyze System Diagnostic Work Area Pgm *
*                                                                     *
* CALLED PROGRAMS: LNME0000 - Logger Services Program to Resolve an   *
*                             Address to a Load Module Name           *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                  04 - Warning                                       *
*                  08 - Error                                         *
*                  12 - Severe Error - Exit This Routine              *
*                                                                     *
***********************************************************************
*
D5XS0000 LPGMNTRY TYPE=SUB,        Define As A Sub-Program Entry       X
               BASE=(12),          Establish Base Registers            X
               AMOD=64,RMOD=ANY,   Addressing and Residency Modes      X
               LCAPFX=D5X,         Establish LCA Prefix for This RSECT X
               LOG=OFF,            Always Turn Logging 'Off' in Logger!X
               LINKRTRN=BSM,       Define Return Linkage Instruction   X
               COPY@RT=YES         To Generate a Copyright Statement
         USING COM_DATA,RCOMM      Addressability to Common Data Area
         USING LGRWK2II,RLGW       Establish Addressability to LGRWK2II
         USING SDWA,RSDW           Establish Addressability to SDWA
         USING IHADCB,LGWODCB      Establish Addressability to DCB
LMOD     USING LRTLMBLK,D5XLMODI   Establish Addressability to LMODI
         LMG   R8,R10,0(R1)        Load the Parameter Area Addresses
         LG    RPCC,24(,R1)        Get the Current Save Area Address
         XC    D5XRETCD,D5XRETCD   Initialize the Return Code
*
*+-------------------------------------------------------------------+*
*|   Process the Calling Program Registers From Format-5 Save Area   |*
*+-------------------------------------------------------------------+*
*
D5XS0100 DS    0H
         LA    R1,D5XSEXIT         Get Retry Recovery Address (ESPIE)
         ST    R1,LGWRETRY         Preserve It In Case of an Abend
         LLGF  R14,LCASA_FWD-LCASAVE(,RPCC) Get Next Save Area Address
         LTGR  R14,R14             Do We Have a Save Area Address?
         BRZ   D5XSEXIT            No  => Then Branch to Exit Routine
         CLC   LCAS64F5A-LCASAVE(L'LCAS64F5A,R14),=CL4'F5SA'  Format 5?
         BRNE  D5XSEXIT            No  => Then Branch to Exit Routine
         CLC   0(L'LCAS64PLI,R14),=C'LCA '  A Pgm Using Logger Service?
         BRNE  D5XSEXIT            No  => Then Branch to Exit Routine
D5XS0200 DS    0H
         LGR   R15,RPCC            Hold the First Save Area Address
         MVC   D5XNTRYP,LCACSADR-LCASAVE(R14)  For the Entry Point Addr
         LM    R0,R1,LCASA_R14-LCASAVE(R15)  Get Low Half R14 Thru R15
         LMH   R0,R1,LCAH64R14-LCASAVE(R14)  Get High Half R14 Thru R15
         STMG  R0,R1,D5XF4SAV+(LCAF64R14-LCASAVE) Save High + Low Half
         LM    R0,R5,LCASA_R0-LCASAVE(R15)  ..Get Low Half R0 Thru R5
         LMH   R0,R5,LCAH64R00-LCASAVE(R14) ..Get High Half R0 Thru R5
         STMG  R0,R5,D5XF4SAV+(LCAF64R00-LCASAVE) Save High + Low Half
         LM    R0,R6,LCASA_R6-LCASAVE(R15)  ..Get Low Half R6 Thru R12
         LMH   R0,R6,LCAH64R06-LCASAVE(R14) .Get High Half R6 Thru R12
         STMG  R0,R6,D5XF4SAV+(LCAF64R06-LCASAVE) Save High + Low Half
         STG   R14,D5XF4SAV+(LCAF64FWD-LCASAVE)  Forward Chain Pointer
         LLGF  R14,LCASA_BCK-LCASAVE(,R15) ..Get the Backchain Pointer
         STG   R14,D5XF4SAV+(LCAF64BCK-LCASAVE) Save Backchain Pointer
         LGR   RPCC,R15            Restore the First Save Area Address
         XC    LGWRETRY,LGWRETRY   Disable Recovery, Area Referenced
*
*+-------------------------------------------------------------------+*
*|    Determine the Load Module/Csect Name For the Called Program    |*
*+-------------------------------------------------------------------+*
*
D5XS0300 DS    0H
         LGR   R4,RPCC             Preserve Calling Program's R13 Value
         LA    RPCC,D5XF4SAV       Get Re-Constructed Format4 Save Area
         LG    R5,LCAF64R15-LCASAVE(,RPCC) Get Called Pgm Entry Address
         CLGF  R5,=A(X'FFFFF002')  Was 64-Bit Entry Linkage Indicated?
         BRNE  D5XS0400            No  => Use R15 Addr for Entry Point
         LLGT  R5,D5XNTRYP         Yes => Use Csect Start Addr from LCA
D5XS0400 DS    0H
         LLGT  R1,CVTPTR           Absolute Address of Pointer to CVT
         LLGT  R2,CVTTCBP-CVTMAP(,R1)  Obtain Task Control Block Addr
         LA    R3,CVTEXIT-CVTMAP(,R1)  Obtain Addr of CVT Exit (SVC 3)
         LLGT  R2,L'PSATNEW(,R2)   Obtain the Current TCB Address
         LLGT  R2,TCBJSTCB-TCB(,R2) .Get Address of First Job Step TCB
         LLGT  R2,TCBFSA-TCB(,R2)  ..Get the Address of First Save Area
         CLGR  R2,R4               First Save Area Match Our R13 Value?
         BRNE  D5XS0500            No  => Not TCB FSA, We Were Called
         LA    R1,D5XSEXIT         Get Retry Recovery Address (ESPIE)
         ST    R1,LGWRETRY         Preserve It In Case of an Abend
         LLGF  R1,LCASA_FWD-LCASAVE(,R4) Get the Next Save Area Address
         CLC   LCAS64F5A-LCASAVE(L'LCAS64F5A,R1),=CL4'F5SA'  Format 5?
         BRNE  D5XS0500            No  => Find Module This Belongs To
         CLC   0(L'LCAS64PLI,R1),=C'LCA '  This Save Area Belong to Us?
         BRNE  D5XS0500            No  => Branch If Not an LCA FSA
         LGR   RPCC,R1             Yes => Then Use as LCA 1st Save Area
D5XS0500 DS    0H
         XC    LGWRETRY,LGWRETRY   Disable Recovery, Area Referenced
         XC    D5XPLIST,D5XPLIST   Clear the Call Parameter List
         CALL  LNME0000,           Process Storage Address for Mod NameX
               ((R5),              ..Pass Storage Addr to Be Resolved  X
               (RPCC),             ..Pass Abending Programs's LCA Addr X
               D5XLMODI,           ..Pass Addr of Load Module Info AreaX
               (RSDW),             ..Pass Address of the SDWA          X
               (RLGW),             ..Pass LGRWK2II Area Address        X
               (RCOMM)),           ..Pass Common Constants&Routines    X
               PLIST8=YES,         ..Indicate the Parameter List FormatX
               LINKINST=LGR,       ..Indicate the Link Instruction TypeX
               MF=(E,D5XPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Process Address for Load Module Name
         LTGFR R15,R15             Resolve Addr Processing Successful?
         BRZ   D5XS0600            Yes => Branch to Process Output Line
         LGHI  R2,((D5XS0700-D5XS0600)-4) ...Length of Branch Table
         CGFR  R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   D5XS0600            No  => Branch to Process Output Line
         BRU   D5XSEXIT            Yes => Branch to Exit This Routine
D5XS0600 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   D5XS0700            Addr Process Completed, Process Line
         BRU   D5XS0700            Branch on Warning-Ignore & Continue
         BRU   D5XSEXIT            Branch on Processing Error - Exit
         BRU   D5XSEXIT            Branch on Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*|  Format And Print the Called Program Detail Line                  |*
*|                                                                   |*
*|  Called Program Entry Point..: TESTPGM7+(000000)                  |*
*+-------------------------------------------------------------------+*
*
MODL     USING DTLINE07,R2         Addressability to Model Detail Lne 7
D5XS0700 DS    0H
         MVI   D5XLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   D5XLINE+1(L'D5XLINE-1),D5XLINE ...Propogate the Blank
         MVI   D5XCCNTL,C' '       Set Carriage Control to Single Space
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   D5XSEXIT            No  => Then Bypass Print Output
D5XS0800 DS    0H
         BRAS  R14,D5XSP100        Blank Separator Line to //LGRECOUT
D5XS0900 DS    0H
         MVI   D5XLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   D5XLINE+1(L'D5XLINE-1),D5XLINE ...Propogate the Blank
         MVI   D5XCCNTL,C' '       Set Carriage Control to Single Space
         LA    R2,D5XOLINE         Obtain the Address of Output Line
         MVC   DTLNETYP-DTLINE07(L'DTLNETYP,R2),D5XPGEPA ...Entry Point
         MVC   DTLCALLP-DTLINE07(L'DTLCALLP,R2),LMOD.LRTPGMNM .Pgm Name
         LA    R2,MODL.DTLCALLP    Establish Current Position in Line
         DROP  MODL                Remove List Reg as Detail Line7 Base
D5XS1000 DS    0H
         CLI   0(R2),C' '          Is This The End of Load Module Name?
         BRE   D5XS1100            Yes => Branch to Process Version
         LA    R2,1(,R2)           Increment to the Next Character
         BRU   D5XS1000            Loop to Find the End of Module Name
D5XS1100 DS    0H
         LA    R2,1(,R2)           Increment Position for Spacer Byte
         MVC   0(L'LRTVERSN,R2),LMOD.LRTVERSN .Copy Module Version Info
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   D5XSEXIT            No  => Then Bypass Print Output
D5XS1200 DS    0H
         BRAS  R14,D5XSP100        Print Program Name Line to LGRECOUT
         MVI   D5XLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   D5XLINE+1(L'D5XLINE-1),D5XLINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*|  Format And Print the Called Program Module Address or Csect      |*
*|  Address Detail Line                                              |*
*|                                                                   |*
*|  TESTPGM6 Csect Address.: 000000000102E000                        |*
*|                                                                   |*
*|  TESTPGM7 Module Address: 0000000018600000                        |*
*+-------------------------------------------------------------------+*
*
D5XS1300 DS    0H
         LA    R2,D5XOLINE         Obtain the Address of Output Line
         CLC   LMOD.LRTLMOD(8),=C'UNKNOWN ' Is Load Module Name Known?
         BRE   D5XS3000            No  => Then No Load Info to Process
         MVC   5(L'LRTLMOD,R2),LMOD.LRTLMOD  ..Get the Load Module Name
         LA    R2,5(,R2)           Establish Current Position in Line
D5XS1400 DS    0H
         CLI   0(R2),C' '          Is This The End of the Csect Name?
         BRE   D5XS1500            Yes => Branch to Process Text Line
         LA    R2,1(,R2)           Increment to the Next Character
         BRU   D5XS1400            Loop to Find the End of Csect Name
D5XS1500 DS    0H
         LA    R2,1(,R2)           Increment Position for Spacer Byte
         CLC   0(L'LCAS64PLI,RPCC),=C'LCA ' .Pgm Using Logger Services?
         BRNE  D5XS1600            No  => Then Use CDE Storage Address
         MVC   0(L'D5XPGCSA,R2),D5XPGCSA Detail Line Hdr for Csect Addr
         LA    R2,L'D5XPGCSA(,R2)  Increment to End of the Header Text
         LLGT  R14,LCACSADR-LCASAVE(,RPCC) ...Get the Csect Address
         BRU   D5XS1700            Branch to Process Csect Address
D5XS1600 DS    0H
         MVC   0(L'D5XPGLMA,R2),D5XPGLMA Detail Lne Hdr for Module Addr
         LA    R2,L'D5XPGLMA(,R2)  Increment to End of the Header Text
         LG    R14,LMOD.LRTMSBAD   Acquire Main Storage Block Address
D5XS1700 DS    0H
         STG   R14,D5XWORKD        Copy the Csect Address to Work Area
         UNPK  D5XWRK16(9),D5XWORKD(5) Get the High-Half Address Value
         UNPK  D5XWRK16+8(9),D5XWORKD+4(5) Get Low-Half Address Value
         TR    D5XWRK16,HEXCONV-C'0' Finalize Conversion to Zoned Char
         MVC   0(L'D5XWRK16,R2),D5XWRK16 Copy Csect Addr to Output Line
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   D5XSEXIT            No  => Then Bypass Print Output
D5XS1800 DS    0H
         BRAS  R14,D5XSP100        Print Program Addr Line to LGRECOUT
D5XS1900 DS    0H
         MVI   D5XLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   D5XLINE+1(L'D5XLINE-1),D5XLINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*|  Format And Print the Called Program Module/Csect Length Detail   |*
*|  Line                                                             |*
*|                                                                   |*
*|  TESTPGM6 Csect Length..: 00000958                                |*
*|                                                                   |*
*|  TESTPGM7 Module Length.: 0003F0A8                                |*
*+-------------------------------------------------------------------+*
*
D5XS2000 DS    0H
         LA    R2,D5XOLINE         Obtain the Address of Output Line
         MVC   5(L'LRTLMOD,R2),LMOD.LRTLMOD  ..Get the Load Module Name
         LA    R2,5(,R2)           Establish Current Position in Line
D5XS2100 DS    0H
         CLI   0(R2),C' '          Is This The End of the Csect Name?
         BRE   D5XS2200            Yes => Branch to Process Text Line
         LA    R2,1(,R2)           Increment to the Next Character
         BRU   D5XS2100            Loop to Find the End of Csect Name
D5XS2200 DS    0H
         LA    R2,1(,R2)           Increment Position for Spacer Byte
         CLC   0(L'LCAS64PLI,RPCC),=C'LCA ' .Pgm Using Logger Services?
         BRNE  D5XS2300            No  => Then Use CDE Storage Length
         MVC   0(L'D5XPGCSL,R2),D5XPGCSL Detail Lne Hdr for Csect Leng
         LA    R2,L'D5XPGCSL(,R2)  Increment to End of the Header Text
         UNPK  D5XWRK09,LCACSLTH-LCASAVE(L'LCACSLTH+1,RPCC) Csect Leng
         BRU   D5XS2400            Branch to Process the Csect Length
D5XS2300 DS    0H
         MVC   0(L'D5XPGLML,R2),D5XPGLML Detail Lne Hdr for Module Leng
         LA    R2,L'D5XPGLML(,R2)  Increment to End of the Header Text
         UNPK  D5XWRK09,LMOD.LRTMSBLA(L'LRTMSBLA+1) Leng Storage Block
D5XS2400 DS    0H
         TR    D5XWRK09(L'D5XWRK09-1),HEXCONV-C'0'  Convert Hex to Char
         MVC   0(L'D5XWRK09-1,R2),D5XWRK09 .Csect Length to Output Line
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   D5XSEXIT            No  => Then Bypass Print Output
D5XS2500 DS    0H
         BRAS  R14,D5XSP100        Print Program Leng Line to LGRECOUT
D5XS2600 DS    0H
         MVI   D5XLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   D5XLINE+1(L'D5XLINE-1),D5XLINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*|  Programs at Initiation Which Receive Control from the Operating  |*
*|  System Will Have the Return Address Pointing to CVTEXIT. Check   |*
*|  the Return Address in R14 to Determine Type of Entry.            |*
*|                                                                   |*
*|  Called Program Returns To...: Program was entered via LINK       |*
*+-------------------------------------------------------------------+*
*
D5XS3000 DS    0H
         LA    RPCC,D5XF4SAV       Get Constructed Format-4 Save Area
         LLGT  R1,CVTPTR           Absolute Address of Pointer to CVT
         LLGT  R2,CVTTCBP-CVTMAP(,R1)  Obtain Task Control Block Addr
         LA    R3,CVTEXIT-CVTMAP(,R1)  Obtain Addr of CVT Exit (SVC 3)
         LLGT  R2,L'PSATNEW(,R2)   Obtain the Current TCB Address
         LLGT  R2,TCBJSTCB-TCB(,R2) .Get Address of First Job Step TCB
         LLGT  R2,TCBFSA-TCB(,R2)  ..Get the Address of First Save Area
         LG    R1,LCAF64R14-LCASAVE(,RPCC)  Get Linkage Return Address
         LLGTR R1,R1               Set Address and Clear Amode-31 Bit
         CLGR  R2,R4               First Save Area Match Our R13 Value?
         BRNE  D5XS3600            No  => Process Linkage Return Addr
         CLGR  R3,R1               Does Return Addr Point to CVT Exit?
         BRE   D5XS3200            Yes => Indicate Entry Was Via Link
D5XS3100 DS    0H
         MVC   D5XOLINE(L'D5XPGRET),D5XPGRET ...Set Return Point Header
         MVC   D5XOLINE+L'D5XPGRET(L'D5XPGCAL),D5XPGCAL  Entry Via Call
         BRU   D5XS3300            Branch to Print Entry Type to Pgm
D5XS3200 DS    0H
         MVC   D5XOLINE(L'D5XPGRET),D5XPGRET ...Set Return Point Header
         MVC   D5XOLINE+L'D5XPGRET(L'D5XPGLNK),D5XPGLNK  Entry Via Link
D5XS3300 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   D5XSEXIT            No  => Then Bypass Print Output
D5XS3400 DS    0H
         BRAS  R14,D5XSP100        Print Program Entry Type to LGRECOUT
D5XS3500 DS    0H
         MVI   D5XLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   D5XLINE+1(L'D5XLINE-1),D5XLINE ...Propogate the Blank
         BRU   D5XS5000            Branch to Process Save Area Address
*
*+-------------------------------------------------------------------+*
*|   Determine the Load Module/Csect Name for the Calling Program    |*
*+-------------------------------------------------------------------+*
*
D5XS3600 DS    0H
         LG    R5,LCAF64R14-LCASAVE(,RPCC)  Get Linkage Return Address
         XC    D5XPLIST,D5XPLIST   Clear the Call Parameter List
         CALL  LNME0000,           Process Storage Address for Mod NameX
               ((R5),              ..Pass Storage Addr to Be Resolved  X
               (RPCC),             ..Pass Abending Programs's LCA Addr X
               D5XLMODI,           ..Pass Addr of Load Module Info AreaX
               (RSDW),             ..Pass Address of the SDWA          X
               (RLGW),             ..Pass LGRWK2II Area Address        X
               (RCOMM)),           ..Pass Common Constants&Routines    X
               PLIST8=YES,         ..Indicate the Parameter List FormatX
               LINKINST=LGR,       ..Indicate the Link Instruction TypeX
               MF=(E,D5XPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Process Address for Load Module Name
         LTGFR R15,R15             Resolve Addr Processing Successful?
         BRZ   D5XS3700            Yes => Branch to Process Output Line
         LGHI  R2,((D5XS4000-D5XS3700)-4) ...Length of Branch Table
         CGFR  R15,R2              Ret Code in R15 Exceed Table Length?
         BRL   D5XS3700            No  => Branch to Process Output Line
         BRU   D5XSEXIT            Yes => Branch to Exit This Routine
D5XS3700 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   D5XS4000            Addr Process Completed, Process Line
         BRU   D5XS4000            Branch on Warning-Ignore & Continue
         BRU   D5XSEXIT            Branch on Processing Error - Exit
         BRU   D5XSEXIT            Branch on Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*|  Format And Print the Calling Program Detail Line                 |*
*|                                                                   |*
*|  Called Program Returns To...: USERPGM2+(0008B2)                  |*
*+-------------------------------------------------------------------+*
*
MODL     USING DTLINE07,R2         Addressability to Model Detail Lne 7
D5XS4000 DS    0H
         LA    R2,D5XOLINE         Obtain the Address of Output Line
         MVC   DTLNETYP-DTLINE07(L'DTLNETYP,R2),D5XPGRET ..Return Point
         MVC   DTLCALLP-DTLINE07(L'DTLCALLP,R2),LMOD.LRTPGMNM .Pgm Name
         LA    R2,MODL.DTLCALLP    Establish Current Position in Line
         DROP  MODL                Remove List Reg as Detail Line7 Base
D5XS4100 DS    0H
         CLI   0(R2),C' '          Is This The End of Load Module Name?
         BRE   D5XS4200            Yes => Branch to Process Version
         LA    R2,1(,R2)           Increment to the Next Character
         BRU   D5XS4100            Loop to Find the End of Module Name
D5XS4200 DS    0H
         LA    R2,1(,R2)           Increment Position for Spacer Byte
         MVC   0(L'LRTVERSN,R2),LMOD.LRTVERSN .Copy Module Version Info
D5XS4300 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   D5XSEXIT            No  => Then Bypass Print Output
D5XS4400 DS    0H
         BRAS  R14,D5XSP100        Print Calling Program Line LGRECOUT
D5XS4500 DS    0H
         MVI   D5XLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   D5XLINE+1(L'D5XLINE-1),D5XLINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*|  Format And Print the Save Area Address Detail Line               |*
*|                                                                   |*
*|  Calling Program Save Area...: 0000000000006F60                   |*
*+-------------------------------------------------------------------+*
*
MODL     USING DTLINE07,R2         Addressability to Model Detail Lne 7
D5XS5000 DS    0H
         LA    R2,D5XOLINE         Obtain the Address of Output Line
         STG   R4,D5XWORKD         Copy Save Area Address to Work Area
         UNPK  D5XWRK16(9),D5XWORKD(5) Get the High-Half Register Value
         UNPK  D5XWRK16+8(9),D5XWORKD+4(5) Get Low-Half Register Value
         TR    D5XWRK16,HEXCONV-C'0' Finalize Conversion to Zoned Char
         MVC   DTLNETYP-DTLINE07(L'DTLNETYP,R2),D5XPGSVA Line Type Hdr
         MVC   DTLCALLP-DTLINE07(L'D5XWRK16,R2),D5XWRK16 Save Area Addr
         DROP  MODL                Remove List Reg as Detail Line7 Base
D5XS5100 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   D5XSEXIT            No  => Then Bypass Print Output
D5XS5200 DS    0H
         BRAS  R14,D5XSP100        Print Save Area Addr Lne to LGRECOUT
D5XS5300 DS    0H
         MVI   D5XLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   D5XLINE+1(L'D5XLINE-1),D5XLINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*|  Format And Print General Purpose Registers R0 - R3 Detail Line   |*
*|  For Calling Program                                              |*
*|                                                                   |*
*|  Calling Program General Purpose Registers R0-R15 at Entry to Call|*
*|    0-3   00000000FD000008  0000000000006FF8  0000000000000040  000|*
*+-------------------------------------------------------------------+*
*
D5XS6000 DS    0H
         MVC   D5XREG0(13*8),LCAF64R00-LCASAVE(RPCC) Get R0 Through R12
         STG   R4,D5XREG13         Get Calling Pgm Register R13 Value
         MVC   D5XREG14(2*8),LCAF64R14-LCASAVE(RPCC) ...Now R14 and R15
         MVC   D5XOLINE(PRNTLEN),DTLINE06  Statement for the GPR's Line
D5XS6100 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   D5XSEXIT            No  => Then Bypass Print Output
D5XS6200 DS    0H
         BRAS  R14,D5XSP100        Print GPR Header Line to //LGRECOUT
D5XS6300 DS    0H
         MVI   D5XLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   D5XLINE+1(L'D5XLINE-1),D5XLINE ...Propogate the Blank
         MVC   D5XOLINE+2(3),=C'0-3' Indicate Register Set for Prnt Lne
         LA    R2,D5XOLINE+8       Position Start of Register Values
         LA    R3,D5XREGS          Get Starting Address of Reg Values
         LA    R4,L'D5XREGS        Indicate Length of Register Entry
         LA    R5,D5XREGS+(D5XRGLEN/4)-L'D5XREGS  ...For Regs R0 - R3
D5XS6400 DS    0H
         UNPK  D5XWRK16(9),0(5,R3) Obtain the High-Half Register Value
         UNPK  D5XWRK16+8(9),4(5,R3) Obtain the Low-Half Register Value
         TR    D5XWRK16,HEXCONV-C'0' Finalize Conversion to Zoned Char
         MVC   0(L'D5XWRK16,R2),D5XWRK16 .General Purpose Reg to Output
         LA    R2,18(,R2)           Increment to Next Register Field
         BRXLG R3,R4,D5XS6400       Loop to Process the Next Register
D5XS6500 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   D5XSEXIT            No  => Then Bypass Print Output
D5XS6600 DS    0H
         BRAS  R14,D5XSP100        Print the GPR 0-3 Values to LGRECOUT
D5XS6700 DS    0H
         MVI   D5XLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   D5XLINE+1(L'D5XLINE-1),D5XLINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*|  Format And Print General Purpose Registers R4 - R7 Detail Line   |*
*|  For Calling Program                                              |*
*|                                                                   |*
*|  4-7   00000000008D1D60  00000000008FF358  00000000008B8FE0  00000|*
*+-------------------------------------------------------------------+*
*
D5XS7000 DS    0H
         MVC   D5XOLINE+2(3),=C'4-7'  Indicate Register Set for Prt Lne
         LA    R2,D5XOLINE+8       Position Start of Register Values
         LA    R3,D5XREGS+(D5XRGLEN/4) ..Starting Address Points to R4
         LA    R4,L'D5XREGS        Indicate Length of Register Entry
         LA    R5,(D5XRGLEN/4)-L'D5XREGS(,R3)  ...For Regs R4 - R7
D5XS7100 DS    0H
         UNPK  D5XWRK16(9),0(5,R3) Obtain the High-Half Register Value
         UNPK  D5XWRK16+8(9),4(5,R3) Obtain the Low-Half Register Value
         TR    D5XWRK16,HEXCONV-C'0' Finalize Conversion to Zoned Char
         MVC   0(L'D5XWRK16,R2),D5XWRK16 .General Purpose Reg to Output
         LA    R2,18(,R2)           Increment to Next Register Field
         BRXLG R3,R4,D5XS7100       Loop to Process the Next Register
D5XS7200 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   D5XSEXIT            No  => Then Bypass Print Output
D5XS7300 DS    0H
         BRAS  R14,D5XSP100        Print GPR 4-7 Values to //LGRECOUT
D5XS7400 DS    0H
         MVI   D5XLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   D5XLINE+1(L'D5XLINE-1),D5XLINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*|  Format And Print General Purpose Registers R8 - R11 Detail Line  |*
*|  For Calling Program                                              |*
*|                                                                   |*
*|  8-11  00000000008FC010  00000000008C9CD0  0000000000000000  00000|*
*+-------------------------------------------------------------------+*
*
D5XS8000 DS    0H
         MVC   D5XOLINE+2(4),=C'8-11' Indicate Register Set for Prt Lne
         LA    R2,D5XOLINE+8       Position Start of Register Values
         LA    R3,D5XREGS+(D5XRGLEN/2) ..Starting Address Points to R8
         LA    R4,L'D5XREGS        Indicate Length of Register Entry
         LA    R5,(D5XRGLEN/4)-L'D5XREGS(,R3)  ...For Regs R8 - R11
D5XS8100 DS    0H
         UNPK  D5XWRK16(9),0(5,R3) Obtain the High-Half Register Value
         UNPK  D5XWRK16+8(9),4(5,R3) Obtain the Low-Half Register Value
         TR    D5XWRK16,HEXCONV-C'0' Finalize Conversion to Zoned Char
         MVC   0(L'D5XWRK16,R2),D5XWRK16 .General Purpose Reg to Output
         LA    R2,18(,R2)           Increment to Next Register Field
         BRXLG R3,R4,D5XS8100       Loop to Process the Next Register
D5XS8200 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   D5XSEXIT            No  => Then Bypass Print Output
D5XS8300 DS    0H
         BRAS  R14,D5XSP100        Print GPR 8-11 Values to //LGRECOUT
D5XS8400 DS    0H
         MVI   D5XLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   D5XLINE+1(L'D5XLINE-1),D5XLINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*|  Format And Print General Purpose Registers R12 - R15 Detail Line |*
*|  For Calling Program                                              |*
*|                                                                   |*
*|  12-15 0000000083191B4A  0000000000006F60  0000000080FD9078  00000|*
*+-------------------------------------------------------------------+*
*
D5XS9000 DS    0H
         MVC   D5XOLINE+2(5),=C'12-15' Indicate the Registers to Print
         LA    R2,D5XOLINE+8       Position Start of Register Values
         LA    R3,D5XREGS+(D5XRGLEN/2+D5XRGLEN/4) Address Points to R12
         LA    R4,L'D5XREGS        Indicate Length of Register Entry
         LA    R5,(D5XRGLEN/4)-L'D5XREGS(,R3) ..For Registers R12 - R15
D5XS9100 DS    0H
         UNPK  D5XWRK16(9),0(5,R3) Obtain the High-Half Register Value
         UNPK  D5XWRK16+8(9),4(5,R3) Obtain the Low-Half Register Value
         TR    D5XWRK16,HEXCONV-C'0' Finalize Conversion to Zoned Char
         MVC   0(L'D5XWRK16,R2),D5XWRK16 .General Purpose Reg to Output
         LA    R2,18(,R2)           Increment to Next Register Field
         BRXLG R3,R4,D5XS9100       Loop to Process the Next Register
D5XS9200 DS    0H
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   D5XSEXIT            No  => Then Bypass Print Output
D5XS9300 DS    0H
         BRAS  R14,D5XSP100        Print GPR 12-15 Values to LGRECOUT
D5XS9400 DS    0H
         MVI   D5XLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   D5XLINE+1(L'D5XLINE-1),D5XLINE ...Propogate the Blank
*
*+-------------------------------------------------------------------+*
*|   Return to Caller                                                |*
*+-------------------------------------------------------------------+*
*
D5XSEXIT DS    0H
         XC    LGWRETRY,LGWRETRY   Ensure Recovery Disabled upon Exit
         SLGR  R15,R15             Indicate Successful Completion
         ST    R15,D5XRETCD        Set the Return Code
         LPGMEXIT RC=D5XRETCD      Define Program Exit Protocol
*
*+-------------------------------------------------------------------+*
*|         P r i n t   O u t p u t   D e t a i l   L i n e           |*
*+-------------------------------------------------------------------+*
*|SUBROUTINE NAME: D5XSP100                                          |*
*|FUNCTION.......: Print Detail Line to Output Logger Data Set       |*
*+-------------------------------------------------------------------+*
*
D5XSP100 LPGMSUBE                  Set Subroutine Entry Protocol
         SYSSTATE AMODE64=NO,ARCHLVL=2 Generate Code for Not in AMODE64
         SAM31                     Switch Now to 31-Bit Addressing Mode
         PUT   LGWODCB,D5XLINE     Print Output Line to //LGRECOUT
         SAM64                     Switch Back to 64-Bit Address Mode
         SYSSTATE AMODE64=YES,ARCHLVL=2    Restore 64-Bit Environment
         LPGMSUBX                  Return to Caller of This Subroutine
*
*+-------------------------------------------------------------------+*
*|   Definition for Constants                                        |*
*+-------------------------------------------------------------------+*
*
D5XPGEPA DC    C'Called Program Entry Point..: ' EPA Detail Line Header
D5XPGLMA DC    C'Module Address: ' Load Module Address Detail Line Hdr
D5XPGLML DC    C'Module Length.: ' Load Module Length Detail Line Hdr
D5XPGCSA DC    C'Csect Address.: ' Csect Address Detail Line Header
D5XPGCSL DC    C'Csect Length..: ' Csect Length Detail Line Header
D5XPGRET DC    C'Called Program Returns To...: ' RET Detail Line Header
D5XPGSVA DC    C'Calling Program Save Area...: ' SA Detail Line Header
D5XPGLNK DC    C'Program was entered via LINK '  Entry was from System
D5XPGCAL DC    C'Program was entered via CALL '  Entry was from Program
*
*+-------------------------------------------------------------------+*
*|    Program RENT Work Area                                         |*
*+-------------------------------------------------------------------+*
*
         LCA   DEFINE              Define the Program RENT Work Area
*
D5XWORKD DS    10D                 General Purpose Work Area
D5XPLIST DS    20FD                CALL Parameter List
D5XREGS  DS    0FD                 Caller's Register Save Area
D5XREG0  DS    13FD                Caller's Register Save Area R0-R12
D5XREG13 DS    FD                  Caller's Register R13 Save Area
D5XREG14 DS    2FD                 Caller's Register Save Area R14-R15
D5XRGLEN EQU   *-D5XREGS           Length of Caller's R0 thru R15 Area
D5XF4SAV DS    XL(LCAF64SZE)       Area to Build Format-4 Save Area
D5XNTRYP DS    F                   Save Area for the Entry Point Addr
D5XRETCD DS    F                   Save Area for the Return Code
D5XWRK09 DS    CL9                 Area for Unpacking Length Values
D5XWRK16 DS    CL16                Area for Unpacking Register Values
         DS    XL1                 Slack for Reverse of Low Order Byte
D5XLMODI DS    CL(LRTLMLEN)        Area for Load Module Information Blk
D5XLINE  DS    0CL133              Output Print Line Area
D5XCCNTL DS    CL1                 Carriage Control Character
D5XOLINE DS    CL132               Output Record Print Area
*
         LCA   DEFEND              Define End of Program RENT Work Area
*
***********************************************************************
*          End of Extended Save Area Information Processing           *
***********************************************************************
         EJECT ,
***********************************************************************
**************************+-----------------+**************************
**************************| L N M E 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*| P e r f o r m   T r a n s l a t e   A d d r e s s   To   N a m e  |*
*+-------------------------------------------------------------------+*
* PROGRAM NAME:    LNME0000                                           *
*                                                                     *
* FUNCTION:        Translate Address to a Module Name/Csect Name      *
*                                                                     *
*                  This routine is responsible for determining the    *
*                  the Load Module Name, or the Control Section Name  *
*                  and the Control Section offset based on the storage*
*                  address which is passed from the calling routine.  *
*                                                                     *
*                  This translate address routine is passed a given   *
*                  address as input. This routine processes the       *
*                  address by attempting to locate the name of the    *
*                  load module that resides at the storage address    *
*                  which was passed. Initially this routine will      *
*                  locate the current Control Section (CSECT) name    *
*                  and offset into the Control Section represented by *
*                  the requested log point entry. When a user program *
*                  uses the copybook 'LGCPLOGR', that copybook has a  *
*                  protocol which determines the address and the      *
*                  length of the Control Section (CSECT), and places  *
*                  that information in the Logger Control Area (LCA)  *
*                  prefix where its location is known. Obtaining this *
*                  address in the LCA gets the pointer to the start of*
*                  that CSECT. The Control Section (CSECT) Name can be*
*                  extracted from the eyecatcher at the beginning of  *
*                  the program.                                       *
*                                                                     *
*                  Otherwise, to locate the load module name may      *
*                  require the use of Contents Supervision of z/OS    *
*                  Program Management Services. This routine will run *
*                  the CDE chain (JPAQ) from the TCB to determine if  *
*                  the storage address passed to this routine points  *
*                  into any program that was entered via the LINK,    *
*                  SYNCH, or ATTACH. If not, then an attempt will be  *
*                  made to run the LLE (Load List Element) chain to   *
*                  verify if the address is in a module that was      *
*                  loaded for the user's job. If still not found then *
*                  search the LPAQ looking at each module in the LPA  *
*                  to verify if our input address that was passed to  *
*                  this routine is in one of the modules in the Link  *
*                  Pack Area (LPA).                                   *
*                                                                     *
*                  This routine is passed an address of a work area   *
*                  from the calling program which is mapped by the    *
*                  LRTLMBLK Dsect. Once the storage address also      *
*                  passed to this routine is resolved, the load module*
*                  information obtained is written to the LRTLMBLK    *
*                  output area for use by the calling program.        *
*                                                                     *
* INPUT REGS:      R1 => Standard O/S Parameter List                  *
*                                                                     *
* INPUT DATA:      Parm1: Addr of Storage Area to Be Resolved to Name *
*                  Parm2: Addr of Abending Program's LCA Area         *
*                  Parm3: Addr of Load Module Information Output Area *
*                  Parm4: Addr of System Diagnostic Work Area         *
*                  Parm5: Addr of LGRWK2II Logger Work Area           *
*                  Parm6: Addr of Common Constants and Routines Area  *
*                                                                     *
* OUTPUT DATA:     LRTLMOD  = The Load Module Name                    *
*                  LRTCSECT = The Program CSECT Name                  *
*                  LRTMODID = The Program CSECT Name and Version      *
*                  LRTOFSET = Offset into the CSECT as "+(0000)"      *
*                  LRTPGMNM = The Load Module.Csect LMOD.csect+(0000) *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY, AC=0                          *
*                                                                     *
* CALLING PROGRAM: DSWA0000 - SDWA Diagnostic Information Program     *
*                  DSTD0000 - Standard Save Area Analysis Program     *
*                  DEXS0000 - Extended Save Area Analysis Program     *
*                  D5XS0000 - Format-5 Save Area Analysis Program     *
*                  DIVC0000 - Logger Services Program to Process the  *
*                             Instructions in Vicinity of Abend       *
*                  DRBT0000 - Logger Services Program to Determine the*
*                             Last SVC Event Before Abend.            *
*                  DBRK0000 - Logger Services Program to Process the  *
*                             Breaking Event Address Before Abend.    *
*                                                                     *
* CALLED PROGRAMS: None                                               *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                  04 - Warning                                       *
*                  08 - Error                                         *
*                  12 - Severe Error - Exit This Routine              *
*                                                                     *
***********************************************************************
*
LNME0000 LPGMNTRY TYPE=SUB,        Define As A Sub-Program Entry       X
               BASE=(12),          Establish Base Registers            X
               AMOD=64,RMOD=ANY,   Addressing and Residency Modes      X
               LCAPFX=LNM,         Establish LCA Prefix for This RSECT X
               LOG=OFF,            Always Turn Logging 'Off' in Logger!X
               LINKRTRN=BSM,       Define Return Linkage Instruction   X
               COPY@RT=YES         To Generate a Copyright Statement
         USING COM_DATA,RCOMM      Addressability to Common Data Area
         USING LGRWK2II,RLGW       Establish Addressability to LGRWK2II
         USING SDWA,RSDW           Establish Addressability to SDWA
         USING IHADCB,LGWODCB      Establish Addressability to DCB
         USING LRTLMBLK,R7         Establish Addressability to Wrk Area
         LMG   R5,R10,0(R1)        Load the Parameter Area Addresses
         XC    LNMRETCD,LNMRETCD   Initialize the Return Code
         XC    LRTOFSET,LRTOFSET   Clear the Load Module Offset Field
         LA    R1,LNME4400         Get Retry Recovery Address (ESPIE)
         ST    R1,LGWRETRY         Preserve It In Case of an Abend
*
*+-------------------------------------------------------------------+*
*|Verify If Start Search for CSECT Name and Offset in the LCA or JPAQ|*
*+-------------------------------------------------------------------+*
*
         MVC   LRTPGMNM,BLANKS     Clear Program Name Area to Blanks
         LLGTR R2,R5               Preserve Storage Address of Program
         LLGFR R3,RPCC             Reserve Logger Control Area Address
         MVC   LRTLMOD,BLANKS      Clear the Load Module Name Line
         MVC   LRTLMOD(8),=CL8'UNKNOWN' Default to No Load Module Found
         MVC   LRTMODID,BLANKS     Clear Load Module Information Line
         MVC   LRTMODID(8),=CL8'UNKNOWN'  Default to Modid Info Unknown
         LTGR  RPCC,RPCC           Is R13 Valid?
         BRZ   LNME2200            No  => Branch to Check the JPAQ
         BRU   LNME1000            Yes => Branch to Check the LCA
*
*+-------------------------------------------------------------------+*
*|Locate The CSECT Name and The Offset from Logger Control Area (LCA)|*
*+-------------------------------------------------------------------+*
*
CNTLPGM  USING LCA,RPCC            Establish Addresability to the LCA
LNME1000 DS    0H
         CLC   0(4,RPCC),=C'LCA '  This a Program Using Logger Service?
         BRNE  LNME2200            No => Then Branch to Check the JPAQ
LNME1100 DS    0H
         LLGT  R14,CNTLPGM.LCACSADR ...Get the Caller's CSECT Address
         CLGF  R5,=A(X'FFFFF002')  Is 64-Bit Entry Linkage Indicated?
         BRNE  LNME1200            No  => Branch to Process Load Module
         LGR   R2,R14              Preserve the Input Storage Address
LNME1200 DS    0H
         LGR   R15,R14             Caller's CSECT Addr to Work Register
         ALGF  R15,CNTLPGM.LCACSLTH  Add CSECT Leng to CSECT Start Addr
         CGR   R2,R14              Input Address Within This Program?
         BRL   LNME2000            No  => Program Not Found
         CGR   R2,R15              Input Address Within This Program?
         BRH   LNME2000            No  => Then Our Program Not Found
LNME1300 DS    0H
         CLC   CNTLPGM.LCASAVE+4(4),=C'F5SA' Format5 Save Area for Pgm?
         BRNE  LNME1400            No => Then Get Csect Name Area Leng
         LLGC  R15,20(,R14)        Get the Length of Csect Name Area
         BRU   LNME1500            Branch to Process Control Section
LNME1400 DS    0H
         LLGC  R15,24(,R14)        Set the Length of Csect Name Area
LNME1500 DS    0H
         BCTGR R15,0               To Decrement for the Execute
         LTGR  R15,R15             Was the Supplied Length Field Empty?
         BRNP  LNME1600            Yes => Branch to Set Default Length
         CGHI  R15,(L'LRTMODID-1)  Will Name Data Fit in Modid Field?
         BRL   LNME1700            Yes => Then Use This Length
LNME1600 DS    0H
         LGHI  R15,(L'LRTMODID-1)  No  => Use Default Leng as Max Leng
LNME1700 DS    0H
         CLC   CNTLPGM.LCASAVE+4(4),=C'F5SA' Format5 Save Area for Pgm?
         BRE   LNME1800            Yes => Then Entry From Main Program
         MVC   LRTMODID(*-*),25(R14) ...Indicated Target of the Execute
         EX    R15,*-6             Module Identifier to Receiving Field
         BRU   LNME1900            Branch to Process the Csect Name
LNME1800 DS    0H
         MVC   LRTMODID(*-*),21(R14) ...Indicated Target of the Execute
         EX    R15,*-6             Module Identifier to Receiving Field
LNME1900 DS    0H
         LLGFR R15,R2              Input Storage Addr to Work Register
         SLGR  R15,R14             Calculate Offset of Addr into CSECT
         ST    R15,LNMWORKF        Save Offset Result to Work Area
         UNPK  LNMWORKD(7),LNMWORKF+1(4) .Convert Value in Hex to Zoned
         TR    LNMWORKD(6),HEXCONV-C'0'  ...Translate Hex to Character
         MVC   LRTOFSET(2),=C'+('  Copy In Indicator for Offset Value
         MVC   LRTOFSET+2(6),LNMWORKD   Copy in Actual Calculated Value
         LLGFR RPCC,R3             Restore Logger Control Area Address
         BRU   LNME2200            Branch to Search Load Module Name
LNME2000 DS    0H
         TM    CNTLPGM.LCASFLAG,LCAMAINP ..Is This a Main User Program?
         BRZ   LNME2100            No  => Check for End of LCA Chain
         MVC   LGWMODID(20),=CL20'UNKNOWN' Indicate the Name is Unknown
         LLGFR RPCC,R3             Restore Logger Control Area Address
         BRU   LNME2200            Branch to Search Load Module Name
LNME2100 DS    0H
         LG    RPCC,CNTLPGM.LCASAVE+(LCAF64BCK-LCASAVE) Backchain Pntr
         LTGR  RPCC,RPCC           Invalid Backchain Pointer Indicated?
         BRZ   LNME2200            Yes => Branch to Search Module Name
         BRU   LNME1000            Parse Save Area Chain-All Callers
         DROP  CNTLPGM             Remove Listed Reg as LCA Base Reg
*
*+-------------------------------------------------------------------+*
*|           Locate the Load Module Name in the z/OS JPAQ            |*
*+-------------------------------------------------------------------+*
*|    Search the job pack area queue representing a chain of CDE     |*
*|    (Contents Directory Entry) control blocks. Each CDE contains   |*
*|    the name of a load module, the address of the entry point for  |*
*|    the load module name, and use count for how many users are     |*
*|    currently using the module. If the load module has an alias,   |*
*|    then there are two CDE's where one CDE is for the major name   |*
*|    representing the primary name of the module, and the other     |*
*|    CDE for the minor name of the module representing the alias.   |*
*|    The job pack area (JPA) is the virtual storage area that       |*
*|    contains the modules loaded into the private area of the       |*
*|    z/OS address space executing the user program.                 |*
*+-------------------------------------------------------------------+*
*
LNME2200 DS    0H
         LLGT  R1,CVTPTR           Absolute Address of Pointer to CVT
         USING CVT,R1              Establish Addressability to CVT
         LLGT  R1,CVTTCBP          Obtain the Task Control Block Addr
         LLGT  R1,4(,R1)           Obtain the Current TCB Address
         USING TCB,R1              Establish Addressability to TCB
         SLGR  R4,R4               Clear for Use as Work Register
         ICM   R4,B'0111',TCBJPQB  Get the Address of Last CDE in JPAQ
         USING CDENTRY,R4          Establish Addressability to the CDE
LNME2300 DS    0H
         TM    CDATTR,CDMIN        Is this Entry for a Minor CDE?
         BRO   LNME2700            Yes => Then Skip This Entry
         TM    CDATTR2,CDXLE       Do We Have an Extent List?
         BRZ   LNME2700            No  => Skip This Entry
         TM    CDATTR,CDNIC        Module in Process of Being Loaded?
         BRO   LNME2700            Yes => Skip This Entry
*
*+-------------------------------------------------------------------+*
*|    Determine If The Input Address is in This Program's Extent     |*
*|    List from Job Pack Area Search                                 |*
*+-------------------------------------------------------------------+*
*
LNME2400 DS    0H
         LLGT  R15,CDXLMJP         Get the Address of the Extent List
         USING XTLST,R15           Establish Addressability to XTLST
         LLGF  R14,XTLNRFAC        Get the Number of Extents in List
LNME2500 DS    0H
         LLGT  R0,XTLMSBAD         Get the Main Storage Block Address
         LLGT  R1,XTLMSBLA         Leng of Main Storage Block (Extent)
         ALGR  R1,R0               Calculate Ending Addr of Storage Blk
         CGR   R2,R0               Input Addr Greater Than MSBAD Start?
         BRL   LNME2600            No  => Check Next Extent List Entry
         CGR   R2,R1               Is Input Addr Less Than MSBAD End?
         BRH   LNME2600            No  => Check Next Extent List Entry
         MVC   LRTLMOD(L'CDNAME),CDNAME Extract Name of the Load Module
         LLGT  R3,XTLMSBAD         Get the Main Storage Block Address
         STG   R3,LRTMSBAD         Save Address of Main Storage Block
         LLGT  R3,XTLMSBLA         Get Length of Main Storage Block
         ST    R3,LRTMSBLA         Save Length of Main Storage Block
         BRU   LNME4400            Branch to Process the Module Name
LNME2600 DS    0H
         LA    R15,8(,R15)         Bump to the Next Main Storage Block
         BRCTG R14,LNME2500        Loop to Check Next Extent Lst Entry
LNME2700 DS    0H
         ICM   R4,B'1111',CDCHAIN  There Another CDE on the CDE Chain?
         BRZ   LNME2800            No  => End-Of-Chain, Check for LLE's
         BRU   LNME2300            Yes => Loop to Check the Next CDE
         DROP  R1,R4,R15           Remove Listed Regs as Base Regs
*
*+-------------------------------------------------------------------+*
*|    Locate the Load Module Name in the Load List                   |*
*+-------------------------------------------------------------------+*
*|  Search the load list representing a chain of Load List Elements  |*
*|  (LLE) control blocks. There is an LLE and a CDE for each module  |*
*|  which has been explicity loaded by the task executing a user     |*
*|  program, and this queue of modules is available within the z/OS  |*
*|  address space executing a user program.                          |*
*+-------------------------------------------------------------------+*
*
LNME2800 DS    0H
         LLGT  R1,CVTPTR           Absolute Address of Pointer to CVT
         USING CVT,R1              Establish Addressability to CVT
         LLGT  R1,CVTTCBP          Obtain the Task Control Block Addr
         LLGT  R1,4(,R1)           Obtain the Current TCB Address
         USING TCB,R1              Establish Addressability to TCB
         SLGR  R5,R5               Ensure No Residual in Hi Half of Reg
         ICM   R5,B'1111',TCBLLS   Addr for Last LLE in the Load List?
         BRZ   LNME3400            No  => End-Of-Chain, Check the LPAQ
         USING LLE,R5              Establish Addressability to the LLE
LNME2900 DS    0H
         LLGT  R4,LLECDPT          Get Address of the CDE for the LLE
         USING CDENTRY,R4          Establish Addressability to the CDE
         TM    CDATTR,CDMIN        Is this Entry for a Minor CDE?
         BRNO  LNME3300            No  => Skip This Entry
         TM    CDATTR2,CDXLE       Do We Have an Extent List?
         BRZ   LNME3300            No  => Skip This Entry
         TM    CDATTR,CDNIC        Module in Process of Being Loaded?
         BRO   LNME3300            Yes => Skip This Entry
*
*+-------------------------------------------------------------------+*
*|    Determine if Input Address is in This Program's Extent List    |*
*|    from Load List Search.                                         |*
*+-------------------------------------------------------------------+*
*
LNME3000 DS    0H
         LLGT  R15,CDXLMJP         Get the Address of the Extent List
         USING XTLST,R15           Establish Addressability to XTLST
         LLGF  R14,XTLNRFAC        Get the Number of Extents in List
LNME3100 DS    0H
         LLGT  R0,XTLMSBAD         Get the Main Storage Block Address
         LLGT  R1,XTLMSBLA         Leng of Main Storage Block (Extent)
         ALGR  R1,R0               Calculate Ending Addr of Storage Blk
         CGR   R2,R0               Input Addr Greater Than MSBAD Start?
         BRL   LNME3200            No  => Check Next Extent List Entry
         CGR   R2,R1               Is Input Addr Less Than MSBAD End?
         BRH   LNME3200            No  => Check Next Extent LIst Entry
         MVC   LRTLMOD(L'CDNAME),CDNAME Extract Name of the Load Module
         LLGT  R3,XTLMSBAD         Get the Main Storage Block Address
         STG   R3,LRTMSBAD         Save Address of Main Storage Block
         LLGT  R3,XTLMSBLA         Get Length of Main Storage Block
         ST    R3,LRTMSBLA         Save Length of Main Storage Block
         BRU   LNME4400            Branch to Process Module Name
LNME3200 DS    0H
         LA    R15,8(,R15)         Bump to the Next Main Storage Block
         BRCTG R14,LNME3100        Loop to Check Next Extent Lst Entry
LNME3300 DS    0H
         ICM   R5,B'1111',LLECHN   There Another LLE on the LLE Chain?
         BRZ   LNME3400            No  => End-Of-Chain, Check the LPAQ
         BRU   LNME2900            Loop to Check the Next LLE
         DROP  R1,R4,R5,R15        Remove Listed Regs as Base Regs
*
*+-------------------------------------------------------------------+*
*|    Locate the Load Module Name in the z/OS LPAQ                   |*
*+-------------------------------------------------------------------+*
*|  Search the z/OS Link Pack Area Queue representing a queue of     |*
*|  Contents Directory Entries (CDE's) for modules residing in the   |*
*|  the FLPA and the MLPA.                                           |*
*+-------------------------------------------------------------------+*
*
LNME3400 DS    0H
         LLGT  R1,CVTPTR           Absolute Address of Pointer to CVT
         USING CVT,R1              Establish Addressability to CVT
         SLGR  R4,R4               Clear for Use as Work Register
         ICM   R4,B'0111',CVTLPDIR  ...Get Address of the LPA Directory
         USING CDENTRY,R4          Establish Addressability to the CDE
LNME3500 DS    0H
         TM    CDATTR,CDMIN        Is this Entry for a Minor CDE?
         BRNO  LNME3900            No  => Skip This Entry
         TM    CDATTR2,CDXLE       Do We Have an Extent List?
         BRZ   LNME3900            No  => Skip This Entry
         TM    CDATTR,CDNIC        Module in Process of Being Loaded?
         BRO   LNME3900            Yes => Skip This Entry
*
*+-------------------------------------------------------------------+*
*|    Determine if Input Address is in This Program's Extent List    |*
*|    from LPAQ Search                                               |*
*+-------------------------------------------------------------------+*
*
LNME3600 DS    0H
         LLGT  R15,CDXLMJP         Get the Address of the Extent List
         USING XTLST,R15           Establish Addressability to XTLST
         LLGF  R14,XTLNRFAC        Get the Number of Extents in List
LNME3700 DS    0H
         LLGT  R0,XTLMSBAD         Get the Main Storage Block Address
         LLGT  R1,XTLMSBLA         Leng of Main Storage Block (Extent)
         ALGR  R1,R0               Calculate Ending Addr of Storage Blk
         CGR   R2,R0               Input Addr Greater Than MSBAD Start?
         BRL   LNME3800            No  => Then Check Next List Entry
         CGR   R2,R1               Is Input Addr Less Than MSBAD End?
         BRH   LNME3800            No  => Then Check Next List Entry
         MVC   LRTLMOD(L'CDNAME),CDNAME Extract Name of the Load Module
         LLGT  R3,XTLMSBAD         Get the Main Storage Block Address
         STG   R3,LRTMSBAD         Save Address of Main Storage Block
         LLGT  R3,XTLMSBLA         Get Length of Main Storage Block
         ST    R3,LRTMSBLA         Save Length of Main Storage Block
         BRU   LNME4400            Branch to Process Module Name
LNME3800 DS    0H
         LA    R15,8(,R15)         Bump to the Next Main Storage Block
         BRCTG R14,LNME3700        Loop to Check Next Extent Lst Entry
LNME3900 DS    0H
         ICM   R4,B'1111',CDCHAIN  There Another CDE on the CDE Chain?
         BRZ   LNME4000            No  => End-Of-Chain, Module Unknown
         BRU   LNME3500            Loop to Check the Next CDE
         DROP  R1,R4,R15           Remove Listed Regs as Base Regs
*
*+-------------------------------------------------------------------+*
*|     Determine if Input Address Points to a Module in the PLPA     |*
*+-------------------------------------------------------------------+*
*| Search the LPDE to perform a final search for currently active    |*
*| modules in the PLPA. Major LPDEs contain only one extent and that |*
*| extent information is contained in the last eight-byte area of    |*
*| the LPDE. There is a CDE chain, but a LPDE is stored somewhat     |*
*| differently in a hash table (directory). There is no chain pointer|*
*| like in the CDE. In this instance the LPDE will be searched by    |*
*| adding the length of the LPDE for each entry until a module name  |*
*| field in the LPDE is found which will not contain zeros but will  |*
*| contain all hex 'FF's. However, not all module names in the LPDE  |*
*| may be available for comparison using this sequential search.     |*
*+-------------------------------------------------------------------+*
*
LNME4000 DS    0H
         LLGT  R1,CVTPTR           Absolute Address of Pointer to CVT
         USING CVT,R1              Establish Addressability to CVT
         LLGT  R4,CVTLPDIA         Get the Address of the LPA Directory
         LGR   R5,R2               TRT Uses R2 by Hardware Convention
         USING LPDE,R4             Establish Addressability to the LPDE
LNME4100 DS    0H
         TM    LPDEATTR,LPDEMIN    Is this Entry for a Minor LPDE?
         BRO   LNME4200            Yes => Then Skip This Entry
         LLGT  R0,LPDEXTAD         Get the Main Storage Block Address
         LLGF  R1,LPDEXTLN         Leng of Main Storage Block (Extent)
         ALGR  R1,R0               Calculate Ending Addr of Storage Blk
         CGR   R2,R0               Input Addr Greater Than MSBAD Start?
         BRL   LNME4200            No  => Then Check Next LPDE Entry
         CGR   R2,R1               Is Input Addr Less Than MSBAD End?
         BRH   LNME4200            No  => Then Check Next LPDE Entry
         LLGT  R3,=A(EBCDIC$Z)     Get Address of Character Scan Table
         TRT   LPDENAME,0(R3)      Load Module Name Qualifier Valid?
         BRZ   LNME4300            No  => Unusable, Module is Unknown
         LLGT  R3,=A(EBCDIC$I)     Get Address of Inverted Scan Table
         TRT   LPDENAME(1),0(R3)   1st Character in Module Name Valid?
         BRZ   LNME4300            No  => Unusable, Module is Unknown
         MVC   LRTLMOD(L'LPDENAME),LPDENAME Extract Name of PLPA Module
         LLGT  R3,LPDEXTAD         Get the Main Storage Block Address
         STG   R3,LRTMSBAD         Save Address of Main Storage Block
         LLGT  R3,LPDEXTLN         Get Length of Main Storage Block
         ST    R3,LRTMSBLA         Save Length of Main Storage Block
         BRU   LNME4300            Branch to Process Module Name
LNME4200 DS    0H
         LA    R4,LPDEXTAD+L'LPDEXTAD Increment to the Next LPDE Entry
         CLC   LPDENAME(4),=X'FFFFFFFF'  At End of LPA Directory Area?
         BRNE  LNME4100            No  => Loop to Process Next LPDE
LNME4300 DS    0H
         LGR   R2,R5               Restore Address Where Pgm Abended
         BRU   LNME4400            End of PLPA Search, Process Module
         DROP  R1,R4               Remove Listed Regs as Base Regs
*
*+-------------------------------------------------------------------+*
*|      Fill the Output Area With the Module Name & CSECT Info       |*
*+-------------------------------------------------------------------+*
*|  Field LRTLMOD  = The Load Module Name                            |*
*|  Field LRTCSECT = The Program Control Section (CSECT) Name        |*
*|  Field LRTOFSET = The Calculated Offset into CSECT as "+(000000)" |*
*|  Field LRTPGMNM = The Program LMOD.CSECT+(000000)                 |*
*+-------------------------------------------------------------------+*
*
LNME4400 DS    0H
         XC    LGWRETRY,LGWRETRY   Clear to Disable Abend Recovery
         LG    R1,LRTOFSET         Check If Value Filled in for Offset
         LTGR  R1,R1               Was an Offset Previously Calculated?
         BRZ   LNME4500            No  => Then Calculate from CDE Entry
         BRU   LNME4600            Yes => Value Previously Calculated
LNME4500 DS    0H
         LG    R0,LRTMSBAD         Get Load Module Entry Point Address
         LGR   R1,R2               Get the Storage Address Passed to Us
         SGR   R1,R0               Calculate Offset Into Load Module
         ST    R1,LNMWORKF         Place Offset into Workarea
         UNPK  LNMWORKD(7),LNMWORKF+1(4) .Convert Value in Hex to Zoned
         TR    LNMWORKD(6),HEXCONV-C'0'  ...Translate Hex to Character
         MVC   LRTOFSET(2),=C'+('  Copy In Indicator for Offset Value
         MVC   LRTOFSET+2(6),LNMWORKD   Copy in Actual Calculated Value
LNME4600 DS    0H
         LA    R2,LRTPGMNM         Get the Address of Line Build Area
         MVC   0(8,R2),LRTLMOD     Copy the Load Module Name to Line
LNME4700 DS    0H
         CLI   0(R2),C' '          Is This The End of Load Module Name?
         BRE   LNME4800            Yes => Branch to Process CSECT Name
         LA    R2,1(,R2)           Increment to the Next Character
         BRU   LNME4700            Loop to Find the End of Module Name
LNME4800 DS    0H
         CLC   LRTCSECT(8),=C'UNKNOWN ' .Is Control Section Name Known?
         BRE   LNME5000            No  => Bypass Using a Csect Name
         MVI   0(R2),C'.'          Insert the Separator Character
         LA    R2,1(,R2)           Increment Past Separator Character
         MVC   0(L'LRTCSECT,R2),LRTCSECT Copy LMOD Control Section Name
LNME4900 DS    0H
         CLI   0(R2),C' '          Is This The End of the Csect Name?
         BRE   LNME5000            Yes => Branch to Process Offset
         LA    R2,1(,R2)           Increment to the Next Character
         BRU   LNME4900            Loop to Find the End of Csect Name
LNME5000 DS    0H
         MVC   0(L'LRTOFSET,R2),LRTOFSET ..Copy Offset Value for Csect
         MVI   L'LRTOFSET(R2),C')' Set Closing Parenthesis for Offset
*
*+-------------------------------------------------------------------+*
*|   Return to Caller                                                |*
*+-------------------------------------------------------------------+*
*
LNMEEXIT DS    0H
         SLGR  R15,R15             Indicate Successful Completion
         ST    R15,LNMRETCD        Set the Return Code
         LPGMEXIT RC=LNMRETCD      Define Program Exit Protocol
*
*+-------------------------------------------------------------------+*
*|    Program RENT Work Area                                         |*
*+-------------------------------------------------------------------+*
*
         LCA   DEFINE              Define the Program RENT Work Area
*
LNMWORKD DS    10D                 General Purpose Work Area
LNMPLIST DS    20FD                CALL Parameter List
LNMRETCD DS    F                   Save Area for the Return Code
LNMWORKF DS    F                   General Purpose Work Area
         DS    XL1                 Slack Byte
         DS    0D                  Set For Doubleword Alignment
LNMWTOMG DS    0D,XL(COMWTOL)      Area for WTO Macro List Form
         DS    0F
LNMMSG   DS    H                   Length of Message Text
LNMMSGTX DS    CL80                Text of Message
*
         LCA   DEFEND              Define End of Program RENT Work Area
*
***********************************************************************
*             End of Translate Address to Name Processing             *
***********************************************************************
         EJECT ,
***********************************************************************
**************************+-----------------+**************************
**************************| P S T O 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|   P r o c e s s  P r i v a t e   A r e a   S t o r a g e   U s e  |*
*+-------------------------------------------------------------------+*
* PROGRAM NAME:    PSTO0000                                           *
*                                                                     *
* FUNCTION:        Print Private Area Storage Allocations             *
*                                                                     *
*                  This routine is responsible for analyzing the      *
*                  current utilization of the user's private area     *
*                  storage at the time of abend. It will call the     *
*                  LGMHPSTG program to analyze storage areas which    *
*                  are Below-the-Line, Above-the-Line, and Above-the- *
*                  Bar in the user's address space. CPU time used is  *
*                  also calculated and printed showing the job step   *
*                  CPU time and job step SRB time. In addition this   *
*                  routine will build and format a report displaying  *
*                  at the time of abend how all of the allocated      *
*                  virtual storage areas in the private area below the*
*                  bar were distributed among the various subpools.   *
*                                                                     *
*For example:                                                         *
*                                                                     *
*-Storage Use at Abend-                                               *
* Private Area Storage Allocated:                                     *
*   <16M: In Use=968K       Unused=8223K       Limit=9192K       HighU*
*   >16M: In Use=105074K    Unused=157069K     Limit=262144K     HighU*
*   >BAR: Allocated=10 Gigabytes                  Guard Amount=6,240 M*
*   >BAR: Useable  =4,000 Megabytes               High Water  =4,000 M*
*   >BAR: Objects  =1                             Shr Objects =0      *
*   >BAR: Shr Alloc=0 Megabytes                   Shr Hi-Water=0 Megab*
* Private Area Subpools Allocated: Owned by Task - Acquired by GETMAIN*
*  SP-Key  Allocated   Free Space  Allocated   Free Space    Allocated*
*          Areas-DQE   Areas-FQE   Below 16M   Below 16M   Above 16M L*
*  003-8   25          1           724,992     2,872       71,917,568 *
*  004-8   5,000       5,000       0           0           20,480,000 *
*  005-8   5,000       5,000       0           0           20,480,000 *
*  229-5   2           2           0           0           12,288     *
*  230-0   1           1           4,096       1,896       0          *
*  230-5   4           9           12,288      11,472      4,096      *
*  230-8   1           1           0           0           4,096      *
*  251-8   2           2           0           0           331,776    *
*  252-0   1           1           0           0           4,096      *
*          ----------  ----------  ----------  ----------  -----------*
*  Totals  10,036      10,017      741,376     16,240      113,233,920*
* Job Step CPU: 0HR 1MIN 34.70903SEC       Job Step SRB: 0HR 0MIN 3.06*
* Subpool Storage Information:                                        *
*    Extended Private Storage - Subpool Numbers that may be used for a*
*      ECSA Subpools  :  227      228   231  241                      *
*      ELSQA Subpools :  203 thru 225   233  234  235  253 254  255   *
*      ESQA Subpools  :  239      245   246  247  248                 *
*      ESWA Subpools  :  229      230   249  236  237                 *
*      USER Subpools  :  0  thru  132   240  250  251  252            *
*    Private Storage - Subpool Numbers that may be used for areas Belo*
*      CSA Subpools   :  227      228   231  241                      *
*      LSQA Subpools  :  203 thru 225   233  234  235  253 254  255   *
*      SQA Subpools   :  226      239   245                           *
*      SWA Subpools   :  229      230   249  236  237                 *
*      USER Subpools  :  0  thru  132   240  250  251  252            *
*                                                                     *
*                                                                     *
* INPUT REGS:      R1 => Standard O/S Parameter List                  *
*                                                                     *
* INPUT DATA:      Parm1: Addr of Abending Program's LCA Area         *
*                  Parm2: Addr of System Diagnostic Work Area         *
*                  Parm3: Addr of LGRWK2II Logger Work Area           *
*                  Parm4: Addr of Common Constants and Routines Area  *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY, AC=0                          *
*                                                                     *
* CALLING PROGRAM: LGMHRTRY - Main Program                            *
*                                                                     *
* CALLED PROGRAMS: LGMHPSTG - Logger Services Program to Analyze      *
*                             Private Area Storage Allocations        *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                  04 - Warning                                       *
*                  08 - Error                                         *
*                  12 - Severe Error - Exit This Routine              *
*                                                                     *
***********************************************************************
*
PSTO0000 LPGMNTRY TYPE=SUB,        Define As A Sub-Program Entry       X
               BASE=(12),          Establish Base Registers            X
               AMOD=64,RMOD=ANY,   Addressing and Residency Modes      X
               LCAPFX=PST,         Establish LCA Prefix for This RSECT X
               LOG=OFF,            Always Turn Logging 'Off' in Logger!X
               LINKRTRN=BSM,       Define Return Linkage Instruction   X
               COPY@RT=YES         To Generate a Copyright Statement
         USING COM_DATA,RCOMM      Addressability to Common Data Area
         USING LGRWK2II,RLGW       Establish Addressability to LGRWK2II
         USING SDWA,RSDW           Establish Addressability to SDWA
         USING IHADCB,LGWODCB      Establish Addressability to DCB
         LMG   R7,R10,0(R1)        Load the Parameter Area Addresses
         XC    PSTRETCD,PSTRETCD   Initialize the Return Code
*
*+-------------------------------------------------------------------+*
*|   Analyze the Private Area Storage Allocations at Time of Abend   |*
*+-------------------------------------------------------------------+*
*
PSTO1000 DS    0H
         LLGF  R14,=A(LGWLINE-LGRWK2II) Index to Log Record Buffer Area
         LA    R3,0(R14,RLGW)      Point to the Log Record Buffer Area
         SLGR  R4,R4               Set the Current Line Counter to Zero
         MVI   PSTTRIND,X'0'       Set the Log Record Indentation Level
         XC    PSTPLIST,PSTPLIST   Clear the Call Parameter List
         CALL  LGMHPSTG,           Analyze the Private Area Storage UseX
               (LGRWK2II,          ..Pass Pointer to Logger Work Area  X
               (R3),               ..Pass Current Line Position in BuffX
               (R4),               ..Pass Current Line Count in Buffer X
               PSTTRIND),          ..Pass Pointer to Indentation Level X
               PLIST8=YES,         ..Indicate Parameter List Format    X
               LINKINST=LGR,       ..Indicate Link Instruction Type    X
               MF=(E,PSTPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Branch to Process Priv Area Storage
         LTGFR R15,R15             Was Private Area Analyze Successful?
         BRZ   PSTO1100            Yes => Branch to Print Private Area
         LGHI  R5,((PSTO2000-PSTO1100)-4) ...Length of Branch Table
         CGR   R15,R5              Ret Code in R15 Exceed Table Length?
         BRL   PSTO1100            No  => Process Private Area Info
         BRU   PSTOEXIT            Branch to Exit This Routine
PSTO1100 DS    0H
         B     *+4(R15)            Branch on Return Code
         BRU   PSTO2000            Print Records for Pvt Area Analysis
         BRU   PSTO2000            Warning on Private Area - Continue
         BRU   PSTO2000            Serious Error - Ignore and Continue
         BRU   PSTOEXIT            Process for Severe Error - Exit
*
*+-------------------------------------------------------------------+*
*| Format And Print the Private Area Storage Allocation Information  |*
*+-------------------------------------------------------------------+*
*
PSTO2000 DS    0H
         MVI   PSTLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   PSTLINE+1(L'PSTLINE-1),PSTLINE  Propogate Blanks
         MVI   PSTCCNTL,C' '       Set Carriage Control to Single Space
         MVC   PST$LINE(L'PSTMSG01),PSTMSG01 Move in Detail Line Header
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   PSTOEXIT            No  => Then Bypass Print Output
PSTO2100 DS    0H
         BRAS  R14,PSTOP100        Prnt Storage Use Hdr Lne to LGRECOUT
PSTO2200 DS    0H
         LG    R4,LGWOCNTR         Get Log Recrd Buffer Area Line Count
         LTGR  R4,R4               Storage Analysis Lines Available?
         BRZ   PSTOEXIT            No  => Process Other Log Point Data
         LLGF  R14,=A(LGWLINE-LGRWK2II) Index to Log Record Buffer Area
         LA    R3,0(R14,RLGW)      Point to the Log Record Buffer Area
PSTO2300 DS    0H
         MVI   PSTLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   PSTLINE+1(L'PSTLINE-1),PSTLINE  Propogate Blanks
         MVC   PST$LINE(PSTLNLEN-5),5(R3)  Storage Allocation Info Line
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   PSTOEXIT            No  => Then Bypass Print Output
PSTO2400 DS    0H
         BRAS  R14,PSTOP100        Prnt Storage Use Info Ln to LGRECOUT
PSTO2500 DS    0H
         LA    R3,L'LGWLINE(,R3)   Point to Next Line in Record Buffer
         BRCTG R4,PSTO2300         => Loop to Process the Next Line
PSTO2600 DS    0H
         LG    R3,=AD(SPC$SINF)    Get Start Addr of Subpool Info Area
         LA    R4,L'SPC$SINF       Indicate Leng of Subpool Info Entry
         LG    R5,=AD((SPC$SINF+SPC$ARLN)-L'SPC$SINF) Nxt to Last Entry
PSTO2700 DS    0H
         MVI   PSTLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   PSTLINE+1(L'PSTLINE-1),PSTLINE ...Propogate the Blank
         MVI   PSTCCNTL,C' '       Set Carriage Control to Single Space
         MVC   PSTLINE+2(L'SPC$SINF),0(R3) Copy SP Info Line to Output
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   PSTOEXIT            No  => Then Bypass Print Output
         BRAS  R14,PSTOP100        Blank Separator Line to //LGRECOUT
         BRXLG R3,R4,PSTO2700      Loop to Process Next SP Info Line
PSTO2800 DS    0H
         MVI   PSTLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   PSTLINE+1(L'PSTLINE-1),PSTLINE ...Propogate the Blank
         MVI   PSTCCNTL,C' '       Set Carriage Control to Single Space
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   PSTOEXIT            No  => Then Bypass Print Output
         BRAS  R14,PSTOP100        Blank Separator Line to //LGRECOUT
*
*+-------------------------------------------------------------------+*
*|   Return to Caller                                                |*
*+-------------------------------------------------------------------+*
*
PSTOEXIT DS    0H
         SLGR  R15,R15             Indicate Successful Completion
         ST    R15,PSTRETCD        Set the Return Code
         LPGMEXIT RC=PSTRETCD      Define Program Exit Protocol
*
*+-------------------------------------------------------------------+*
*|         P r i n t   O u t p u t   D e t a i l   L i n e           |*
*+-------------------------------------------------------------------+*
*|SUBROUTINE NAME: PSTOP100                                          |*
*|FUNCTION.......: Print Detail Line to Output Logger Data Set       |*
*+-------------------------------------------------------------------+*
*
PSTOP100 LPGMSUBE                  Set Subroutine Entry Protocol
         SYSSTATE AMODE64=NO,ARCHLVL=2 Generate Code for Not in AMODE64
         SAM31                     Switch Now to 31-Bit Addressing Mode
         PUT   LGWODCB,PSTLINE     Print Output Line to //LGRECOUT
         SAM64                     Switch Back to 64-Bit Address Mode
         SYSSTATE AMODE64=YES,ARCHLVL=2    Restore 64-Bit Environment
         LPGMSUBX                  Return to Caller of This Subroutine
*
*+-------------------------------------------------------------------+*
*|   Definition for Constants                                        |*
*+-------------------------------------------------------------------+*
*
PSTMSG01 DC    CL22'-Storage Use at Abend-'          Detail Line Header
PSTLNLEN EQU   100                 Indicate Detail Line Leng to Process
*
*+-------------------------------------------------------------------+*
*|    Program RENT Work Area                                         |*
*+-------------------------------------------------------------------+*
*
         LCA   DEFINE              Define the Program RENT Work Area
*
PSTWORKD DS    10D                 General Purpose Work Area
PSTPLIST DS    20FD                CALL Parameter List
PSTRETCD DS    F                   Save Area for the Return Code
PSTLINE  DS    0CL133              Output Print Line Area
PSTCCNTL DS    CL1                 Carriage Control Character
PST$LINE DS    CL132               Output Record Print Area
*
         LCA   DEFEND              Define End of Program RENT Work Area
*
***********************************************************************
*           End of Print Private Area Storage Allocations             *
***********************************************************************
         EJECT ,
***********************************************************************
**************************+-----------------+**************************
**************************| D S K A 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|     P r i n t   o f   D a t a   S e t   A l l o c a t i o n s     |*
*+-------------------------------------------------------------------+*
* PROGRAM NAME:    DSKA0000                                           *
*                                                                     *
* FUNCTION:        Process Disk Data Set Allocations                  *
*                                                                     *
*                  This routine is responsible for performing the     *
*                  print of data set allocation information for the   *
*                  user program.                                      *
*                                                                     *
*                  This routine will check each data set requested for*
*                  allocation. From the CVT go to the active TCB to   *
*                  acquire the TIOT, the JSCB, and the QDB in order   *
*                  to get the first Data Set Association Block (DSAB) *
*                  in the chain of DSAB's where there is one DSAB for *
*                  each data set requested for allocation. Then loop  *
*                  through the DSAB chain to extract the DDname, the  *
*                  data set name that is associated with a DDname,    *
*                  the data set disposition, the Volume Serial for the*
*                  data set, and the Execute Channel Program count.   *
*                                                                     *
*                  The EXCP count is related to I/O activity, and is  *
*                  meant to represent the number of channel programs  *
*                  which were executed at the DD level. However,      *
*                  various access methods will report the number of   *
*                  data blocks read or written as EXCPs without regard*
*                  to the actual number of channel program executions *
*                  involved, and by other access methods what is      *
*                  reported as a single EXCP may result in the tranfer*
*                  of a large number of data blocks. The EXCP count   *
*                  then is not so much a hard and fast rule but more  *
*                  of a guideline representing only an estimate of the*
*                  amount of I/O activity performed.                  *
*                                                                     *
*                  Once all information is obtained for a data set,   *
*                  it is formatted and printed to output. Then the    *
*                  next DSAB is obtained for the next data set.       *
*                                                                     *
* Example of DSAB:                                                    *
*                                                                     *
*  +---------+       +---------+       +---------+       +---------+  *
*  |  C V T  |  +--> |  T C B  |  +--> | J S C B |  +--> |  Q D B  |  *
*  +---------+  |    +---------+  |    +---------+  |    +---------+  *
*  |         |  |    |         |  |    |         |  |    |         |  *
*  +---------+  |    +---------+  |    +---------+  |    +---------+  *
*  | CVTTCBP |--+    | TCBJSCB |--+    |JSCDSABQ |--+ +--|QDBFELMP |  *
*  +---------+       +---------+       +---------+    |  +---------+  *
*  |         |       |         |       |         |    |  |         |  *
*  +---------+       +---------+       +---------+    |  +---------+  *
*                                                     |               *
*                                  +------------------+               *
*                                  |                                  *
*                          +--------------+                           *
*                          |    D S A B   |                           *
*     +-----------+        +--------------+                           *
*     |  T I O T  |        |              |                           *
*     +-----------+        +--------------+                           *
*     |  Jobname  |   +----|   DSABTIOT   |                           *
*     +-----------+   |    +--------------+       +--------------+    *
*     | Step Name |   |    |   DSABFCHA   |------>|    D S A B   |    *
*     +-----------+   |    +--------------+       +--------------+    *
* +---| DD Entry  |<--+                           |              |    *
* |   +-----------+                               +--------------+    *
* |   | DD Entry  |<------------------------------|   DSABTIOT   |    *
* |   +-----------+                               +--------------+    *
* |                                               |   DSABFCHA   |    *
* |                            +-----------+      +--------------+    *
* +--TIOEJFCB----(SWAREQ)----->|  J F C B  |                          *
*                              +-----------+                          *
*                                                                     *
* INPUT REGS:      R1 => Standard O/S Parameter List                  *
*                                                                     *
* INPUT DATA:      Parm1: Addr of Abending Program's LCA Area         *
*                  Parm2: Addr of System Diagnostic Work Area         *
*                  Parm3: Addr of LGRWK2II Logger Work Area           *
*                  Parm4: Addr of Common Constants and Routines Area  *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY, AC=0                          *
*                                                                     *
* CALLING PROGRAM: LGMHRTRY - Main Program                            *
*                                                                     *
* CALLED PROGRAMS: None                                               *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                  04 - Warning                                       *
*                  08 - Error                                         *
*                  12 - Severe Error - Exit This Routine              *
*                                                                     *
***********************************************************************
*
DSKA0000 LPGMNTRY TYPE=SUB,        Define As A Sub-Program Entry       X
               BASE=(12),          Establish Base Registers            X
               AMOD=64,RMOD=ANY,   Addressing and Residency Modes      X
               LCAPFX=DSK,         Establish LCA Prefix for This RSECT X
               LOG=OFF,            Always Turn Logging 'Off' in Logger!X
               LINKRTRN=BSM,       Define Return Linkage Instruction   X
               COPY@RT=YES         To Generate a Copyright Statement
         USING COM_DATA,RCOMM      Addressability to Common Data Area
         USING LGRWK2II,RLGW       Establish Addressability to LGRWK2II
         USING SDWA,RSDW           Establish Addressability to SDWA
         USING IHADCB,LGWODCB      Establish Addressability to DCB
         LMG   R7,R10,0(R1)        Load the Parameter Area Addresses
         XC    DSKRETCD,DSKRETCD   Initialize the Return Code
*
*+-------------------------------------------------------------------+*
*|   Print Headers and Obtain the Data Set Association Block (DSAB)  |*
*+-------------------------------------------------------------------+*
*
DSKA0100 DS    0H
         MVI   DSKLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DSKLINE+1(L'DSKLINE-1),DSKLINE  Propogate Blanks
         MVC   DSKOLINE(L'DSKMSG01),DSKMSG01   Data Set Allocation Hdr
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DSKAEXIT            No  => Then Bypass Print Output
DSKA0200 DS    0H
         BRAS  R14,DSKAP100        Prnt Disk Alloc Hdr Lne to LGRECOUT
DSKA0300 DS    0H
         MVI   DSKLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DSKLINE+1(L'DSKLINE-1),DSKLINE  Propogate the Blanks
         MVC   DSKOLINE(L'DTLINE08),DTLINE08  Get Detail Line Alloc Hdr
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DSKAEXIT            No  => Then Bypass Print Output
DSKA0400 DS    0H
         BRAS  R14,DSKAP100        Prnt Disk Alloc Hdr Lne to LGRECOUT
DSKA0500 DS    0H
         LA    R1,DSKA6000         Get Retry Recovery Address (ESPIE)
         ST    R1,LGWRETRY         Preserve It In Case of an Abend
         LLGT  R3,CVTPTR           Absolute Address of Pointer to CVT
         LLGT  R3,CVTTCBP-CVTMAP(,R3)  Obtain Task Control Block Addr
         LLGT  R3,L'PSATNEW(,R3)   Obtain the Current TCB Address
         LLGT  R3,TCBJSCB-TCB(,R3) Get the Job Step Control Block
         USING IEZJSCB,R3          Establish Addressability to JSCB
         LLGT  R3,JSCBACT          Obtain the Active JSCB Address
         LLGT  R3,JSCDSABQ         Obtain DSAB Queue Descriptor Block
         USING QDB,R3              Establish Addressability to QDB
         LLGT  R3,QDBFELMP         Obtain the First DSAB
         USING DSAB,R3             Establish Addressability to DSAB
*
*+-------------------------------------------------------------------+*
*|               Get the Data Definition Name (DDname)               |*
*+-------------------------------------------------------------------+*
*
         USING TIOENTRY,R6         Establish Addressability to Entry
DSKA1000 DS    0H
         LLGT  R6,DSABTIOT         Obtain the TIOT DD Entry
         LLGC  R0,TIOELNGH         Get Leng in Bytes for This DD Entry
         LTGR  R0,R0               Is There a Length Value for Entry?
         BRZ   DSKA5000            No  => Branch If End of Tiot
         TM    TIOESTTA,TIOSLTYP   Is This a Freed TIOT Entry?
         BRO   DSKA5000            Yes => Branch for Next DDname Entry
         MVC   DSKDDNAM,4(R6)      Get Data Definition Name from TIOT
*
*+-------------------------------------------------------------------+*
*|          Get the Data Set Name, Vol/SER, and Disposition          |*
*+-------------------------------------------------------------------+*
*
DSKA1100 DS    0H
         MVI   DSKDSNAM,C' '       Set-up to Fill DSN Field with Blanks
         MVC   DSKDSNAM+1(L'DSKDSNAM-1),DSKDSNAM   Propogate the Blanks
         MVC   DSKVOLSR,=CL8' '    Clear the Volume/Serial Field
         MVC   DSKDISPO,=CL3' '    Clear Data Set Disposition Status
         XC    DSKEXCP#,DSKEXCP#   Zero Execute Channel Pgm Count Field
         LA    R4,EPA              Get the Address of the EPA
         ST    R4,SWEPAPTR         Initialize the Current EPA pointer
         USING ZB505,R4            Establish Addressability to the EPA
         XC    SWAEPAX,SWAEPAX     Initialize the EPA
         MVC   SWVA,TIOEJFCB       Move SVA of JFCB into the EPA
         SAM31                     Switch Now to 31-Bit Addressing Mode
       SWAREQ FCODE=RL,EPA=SWEPAPTR,UNAUTH=YES,MF=(E,SWAPARMS)
         SAM64                     Switch Back to 64-Bit Address Mode
         LLGT  R4,SWBLKPTR         Set the Pointer to the JFCB
         USING INFMJFCB,R4         Establish Addressability to JFCB
         MVC   DSKDSNAM(L'JFCBDSNM),JFCBDSNM ..Get Data Set Name for DD
         TM    JFCBIND1,JFCPDS     A Member of a Partitioned Data Set?
         BRZ   DSKA1900            No  => Bypass Member Name Processing
DSKA1200 DS    0H
         LA    R1,DSKDSNAM         Get Address of Data Set Name Field
         LGR   R15,R1              Preserve Starting Addr of Work Line
         LA    R5,L'DSKDSNAM-1     Get Length of Data Set Name Field
         LA    R1,0(R5,R15)        Point to End of Data Set Name Field
         LA    R14,1               Check is for One Byte at a Time
         LNGR  R14,R14             To Scan Backwards Through Name Field
         LLGC  R2,=C' '            Search Is For Trailing Blanks
DSKA1300 DS    0H
         BRXHG R1,R14,DSKA1400     Find End of Data Set Going Backward
         BRU   DSKA1500            Branch to Process the Key Length
DSKA1400 DS    0H
         CLM   R2,B'0001',0(R1)    Is This a Blank Character?
         BRNE  DSKA1500            No  => Branch to Determine Length
         BRU   DSKA1300            Loop to Check the Next Byte in Field
DSKA1500 DS    0H
         LA    R5,1(,R1)           Point to the End of Data Set Name
         SGR   R1,R15              Calculate Length of Data Set Name
         BRNP  DSKA1900            Branch If Nothing Is Left
DSKA1600 DS    0H
         MVI   0(R5),C'('          Set Left Parand for Start Mbr Name
         LA    R5,1(,R5)           Increment Past Parand for Mbr Name
         MVC   0(L'JFCBELNM,R5),JFCBELNM ...Copy the PDS Member Name
         LA    R14,DSKDSNAM        Get Address to Data Set Name Field
         LLILL R15,(L'DSKDSNAM)    Get Length of Data Set Name Field
DSKA1700 DS    0H
         CLI   0(R14),C' '         Is this a Blank Character?
         BRE   DSKA1800            Yes => Branch to Place Ending Parand
         LA    R14,1(,R14)         Increment Address to the Next Byte
         BRCTG R15,DSKA1700        Loop to Check The Next Byte in Field
DSKA1800 DS    0H
         MVI   0(R14),C')'         Copy the Ending Parand for Mbr Name
DSKA1900 DS    0H
         TM    TIOELINK,TIOESSDS   Is This Entry for a JES Data Set?
         BRZ   DSKA2000            No  => Branch to Check for a UCB
         MVC   DSKVOLSR,=CL8'JES'  To Indicate a SYSIN/SYSOUT Data Set
         BRU   DSKA3000            Branch to Bypass the Vol/Ser Process
DSKA2000 DS    0H
         SLGR  R5,R5               Clear to Prepare for 24-bit Address
         ICM   R5,B'0111',TIOEFSRT An Address for a Unit Control Blk?
         BRZ   DSKA4000            No  => Indicates NULLFILE Allocation
         USING UCBOB,R5            Establish Addressability to the UCB
         TM    UCBOB,UCBVRDEV      Is This Allocation for VIO Data Set?
         BRO   DSKA2100            Yes => Branch to Set Data Set as VIO
         MVC   DSKVOLSR,JFCBVOLS   No  => Then Get the First Vol/Ser
         BRU   DSKA2200            Branch to Set Data Set Disposition
         DROP  R5                  Remove Listed Reg as UCB Base Reg
DSKA2100 DS    0H
         MVC   DSKVOLSR,=CL8'VIO'  Indicate Data Set Allocated as VIO
DSKA2200 DS    0H
         LLGT  R1,=A(DSKDDISP)     Addr of Data Set Disposition Table
         LLILL R14,(L'DSKDDISP)    Length of Data Set Disp Table Entry
         LLGF  R15,=A(DSKDDISP+((DSKDSPNM*L'DSKDDISP)-L'DSKDDISP))
DSKA2300 DS    0H
         LLGC  R5,0(R1)            Get Data Set Disposition Mask Byte
         TM    JFCBIND2,0          Indicated Target of the Execute
         EX    R5,*-4              Disposition in JFCB Match Tbl Entry?
         BRO   DSKA2400            Yes => Branch to Get Data Set DISP=
         BRXLG R1,R14,DSKA2300     Loop to Check Next Disp Entry in Tbl
         BRU   DSKA3000            Branch, Disp Status is Undetermined
DSKA2400 DS    0H
         MVC   DSKDISPO,1(R1)      Get the Present Data Set Disposition
         DROP  R4                  Remove Listed Reg as JFCB Base Reg
*
*+-------------------------------------------------------------------+*
*|               Get the Execute Channel Program Count               |*
*+-------------------------------------------------------------------+*
* Obtain the SMF Timing Control Table address and get the pointer to  *
* the TCT I/O lookup Table. Take the TIOT offset being used with the  *
* current DSAB, and search the TCT I/O Lookup Table entries to match  *
* that TIOT offset associated with the DSAB to a TIOT offset value in *
* the TCT I/O Lookup Table. An entry in that table contains an offset *
* value to the TCT I/O Counter Table. Then obtain the address to the  *
* TCT I/O Measurement Table, and to that address add the offset       *
* obtained from the TCT I/O Lookup table which gets you the pointer   *
* to the TCT I/O Counter Table entry for your designated DDname. That *
* tabel entry will have a field containing the EXCP count.            *
*---------------------------------------------------------------------*
*
DSKA3000 DS    0H
         LLGT  R1,CVTPTR           Absolute Address of Pointer to CVT
         LLGT  R1,CVTTCBP-CVTMAP(,R1)  Obtain Task Control Block Addr
         LLGT  R1,L'PSATNEW(,R1)   Obtain the Current TCB Address
         LGR   R14,R6              Get the Current Tiot Entry Address
         SLGF  R14,TCBTIO-TCB(,R1) Calculate the Offset in the TIOT
         LLGT  R15,PSATOLD-PSA(,R0) Get Addr of Current Task Cntl Blk
         LLGT  R15,TCBTCT-TCB(,R15) Addr of SMF Timing Common Section
         LTGR  R15,R15             SMF Data Being Collected for Task?
         BRZ   DSKA4000            No  => Then Bypass EXCP Processing
         LLGT  R15,TCTIOTBL-SMFTCT(,R15) ..Addr of I/O Measurement Tble
         LA    R15,TCTIODSP-TCTTIOT(,R15) .Point to the First DD Entry
         USING TCTDCBTD,R15        Addressability to Lookup Table Entry
DSKA3100 DS    0H
         CLGF  R14,TCTDCBTD        Both Offsets Show Same TIOT Origin?
         BRE   DSKA3200            Yes => This is Our Lookup Tble Entry
         LLGF  R1,TCTDCBLE         This Table Also Has Offset from TIOT
         LA    R15,TCTDCBLE        Get Next TCT I/O Lookup Tble Entry
         LTGR  R1,R1               At the End of TCT I/O Lookup Tble?
         BRNZ  DSKA3100            No  => Loop to Find Matching Offsets
         SLGR  R4,R4               Yes => Then There is No EXCP Count
         BRU   DSKA3300            Branch to Process the EXCP Value
DSKA3200 DS    0H
         LLGF  R5,TCTIOTSD         Get Offset from TCT I/O Table Origin
         LLGT  R1,PSATOLD-PSA(,R0) Get Addr of Current Task Cntl Block
         LLGT  R1,TCBTCT-TCB(,R1)  Get Adr of SMF Timing Common Section
         ALGF  R5,TCTIOTBL-SMFTCT(,R1) Addr of TCT I/O Measurement Tble
TBL      USING TCTDDENT,R5         Addressability TCT I/O Counter Table
         LLGF  R4,TBL.TCTDCTR      Obtain Execute Channel Program Count
DSKA3300 DS    0H
         STG   R4,DSKEXCP#         Save EXCP Count Value to a Work Area
         DROP  TBL,R6,R15          Remove Listed Registers as Base Regs
*
*+-------------------------------------------------------------------+*
*|        Format And Print the Data Set Allocation Information       |*
*+-------------------------------------------------------------------+*
*
DSKA4000 DS    0H
         MVI   DSKLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DSKLINE+1(L'DSKLINE-1),DSKLINE  Propogate Blanks
         LA    R2,DSKOLINE         Obtain the Address of Output Line
         MVC   DTLDDNAM-DTLINE08(L'DTLDDNAM,R2),DSKDDNAM Get the DDname
DSKA4100 DS    0H
         LG    R0,DSKEXCP#         Get the Execute Channel Pgm Count
         CVDG  R0,DSKWORKD         Convert EXCP Count Value to Decimal
         LA    R1,DSKFORC1         Preload 1st Forced Result Location
         MVC   DSKWRK15,DSKEDITP   Copy in the Number Editing Pattern
         EDMK  DSKWRK15,DSKWORKD+10 Edit EXCP Count Value to Character
         BRZ   DSKA4200            Branch If EXCP Count Value is Zero
         LA    R14,DSKWRK15+L'DSKWRK15 ..Point to End of Edit Work Area
         SGR   R14,R1              Calculate Length of EXCP Count Value
         MVC   DTL@EXCP-DTLINE08(*-*,R2),0(R1) ...Target of the Execute
         EX    R14,*-6             Copy the EXCP Count to Output Line
DSKA4200 DS    0H
         MVC   DTLDSNAM-DTLINE08(L'DTLDSNAM,R2),DSKDSNAM  Data Set Name
         MVC   DTL@DISP-DTLINE08(L'DTL@DISP,R2),DSKDISPO  Disposition
         MVC   DTLVOLSR-DTLINE08(L'DTLVOLSR,R2),DSKVOLSR  Volume Serial
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DSKAEXIT            No  => Then Bypass Print Output
DSKA4300 DS    0H
         BRAS  R14,DSKAP100        Print Data Set Info Line to LGRECOUT
*
*+-------------------------------------------------------------------+*
*|         Loop Point to Process the Next DSAB in Chain              |*
*+-------------------------------------------------------------------+*
*
DSKA5000 DS    0H
         LLGT  R3,DSABFCHA         Obtain the Next DSAB in Chain
         LTGR  R3,R3               Are We at the End of the DSAB Chain?
         BRNZ  DSKA1000            No  => Then Loop Back for Next DSAB
         BRU   DSKA6000            Yes => Branch to Process Trailer
*
*+-------------------------------------------------------------------+*
*|           End of DSAB Chain, Print the Trailer Line               |*
*+-------------------------------------------------------------------+*
*
DSKA6000 DS    0H
         MVI   DSKLINE,C' '        Set-up to Fill Prnt Line with Blanks
         MVC   DSKLINE+1(L'DSKLINE-1),DSKLINE ...Propogate the Blank
         MVI   DSKCCNTL,C' '       Set Carriage Control to Single Space
         TM    DCBOFLGS,DCBOFOPN   Is LGRECOUT Data Control Block Open?
         BRZ   DSKAEXIT            No  => Then Bypass Print Output
DSKA6100 DS    0H
         BRAS  R14,DSKAP100        Blank Separator Line to //LGRECOUT
*
*+-------------------------------------------------------------------+*
*|   Return to Caller                                                |*
*+-------------------------------------------------------------------+*
*
DSKAEXIT DS    0H
         XC    LGWRETRY,LGWRETRY   Ensure Recovery is Disabled
         SLGR  R15,R15             Indicate Successful Completion
         ST    R15,DSKRETCD        Set the Return Code
         LPGMEXIT RC=DSKRETCD      Define Program Exit Protocol
*
*+-------------------------------------------------------------------+*
*|         P r i n t   O u t p u t   D e t a i l   L i n e           |*
*+-------------------------------------------------------------------+*
*|SUBROUTINE NAME: DSKAP100                                          |*
*|FUNCTION.......: Print Detail Line to Output Logger Data Set       |*
*+-------------------------------------------------------------------+*
*
DSKAP100 LPGMSUBE                  Set Subroutine Entry Protocol
         SYSSTATE AMODE64=NO,ARCHLVL=2 Generate Code for Not in AMODE64
         SAM31                     Switch Now to 31-Bit Addressing Mode
         PUT   LGWODCB,DSKLINE     Print Output Line to //LGRECOUT
         SAM64                     Switch Back to 64-Bit Address Mode
         SYSSTATE AMODE64=YES,ARCHLVL=2    Restore 64-Bit Environment
         LPGMSUBX                  Return to Caller of This Subroutine
*
*+-------------------------------------------------------------------+*
*|   Definition for Constants                                        |*
*+-------------------------------------------------------------------+*
*
         DS    0F
DSKDDISP DS    0CL4                Tble for Data Set Disposition Status
         DC    AL1(JFCNEW),C'NEW'  Indicate Disposition Status of New
         DC    AL1(JFCMOD),C'MOD'  Indicate Disposition Status of Mod
         DC    AL1(JFCOLD+JFCSHARE),C'SHR'  Disposition Status of Share
         DC    AL1(JFCOLD),C'OLD'  Indicate Disposition Status of Old
DSKDSPNM EQU   (*-DSKDDISP)/L'DSKDDISP No. of Disp Status Table Entries
DSKEDITP DC    XL15'4020206B2020206B2020206B202120'  EXCP Edit Pattern
DSKMSG01 DC    CL31'-Data Set Allocations at Abend-' Detail Line Header
*
*+-------------------------------------------------------------------+*
*|    Program RENT Work Area                                         |*
*+-------------------------------------------------------------------+*
*
         LCA   DEFINE              Define the Program RENT Work Area
*
DSKWORKD DS    10D                 General Purpose Work Area
DSKPLIST DS    20FD                CALL Parameter List
DSKEXCP# DS    FD                  Save Area for the EXCP Count
DSKRETCD DS    F                   Save Area for the Return Code
SWEPAPTR DS    F                   SWA Manager Locate Mode Parm List
EPA      DS    XL(L'SWAEPAX)       SWA Manager External Parameter Area
SWAPARMS SWAREQ UNAUTH=YES,MF=L    SWA Request Parameter List
DSKDISPO DS    CL3                 Save Area for Data Set Disposition
DSKVOLSR DS    CL8                 Save Area for Volume Serial
DSKDDNAM DS    CL8                 Save Area for DDname
DSKDSNAM DS    CL54                Save Area for the Data Set Name
DSKWRK15 DS    CL(L'DSKEDITP)      Work Area for Editing Decimal Values
DSKFORC1 EQU   *-1                 First Forced Result Char Location
DSKLINE  DS    0CL133              Output Print Line Area
DSKCCNTL DS    CL1                 Carriage Control Character
DSKOLINE DS    CL132               Output Record Print Area
*
         LCA   DEFEND              Define End of Program RENT Work Area
*
***********************************************************************
*            End of Print Data Set Allocation Information             *
***********************************************************************
         EJECT ,
***********************************************************************
**************************+-----------------+**************************
**************************| P L C A 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|      P r i n t   o f   L o g g e r   C o n t r o l   A r e a      |*
*+-------------------------------------------------------------------+*
* PROGRAM NAME:    PLCA0000                                           *
*                                                                     *
* FUNCTION:        Print Logger Control Area.                         *
*                                                                     *
*                  This routine is responsible for performing the     *
*                  print of the Logger Control Area (LCA) for all     *
*                  program Csects in the current LCA stack. This      *
*                  routine contains in-line Log Points that are       *
*                  manually hard coded here in this routine in the    *
*                  same format as would be generated automatically    *
*                  by the #LGPOINT command in a user program so they  *
*                  can be used by Logger Services program LGMHLRCE.   *
*                  Since the main LGMHRTRY program was implemented    *
*                  with LOG=OFF in LPGMNTRY, Logger Services is being *
*                  temporarily enabled in this routine to allow Logger*
*                  Services program LGMHLRCE to be used to process the*
*                  hard coded Log Points.                             *
*                                                                     *
* INPUT REGS:      R1 => Standard O/S Parameter List                  *
*                                                                     *
* INPUT DATA:      Parm1: Addr of System Diagnostic Work Area         *
*                  Parm2: Addr of LGRWK2II Logger Work Area           *
*                  Parm3: Addr of Common Constants and Routines Area  *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY, AC=0                          *
*                                                                     *
* CALLING PROGRAM: LGMHRTRY - Main Program                            *
*                                                                     *
* CALLED PROGRAMS: LGMHLRCE - Logger Services Event Publishing Program*
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                  04 - Warning                                       *
*                  08 - Error                                         *
*                  12 - Severe Error - Exit This Routine              *
*                                                                     *
***********************************************************************
*
PLCA0000 LPGMNTRY TYPE=SUB,        Define As A Sub-Program Entry       X
               BASE=(12),          Establish Base Registers            X
               AMOD=64,RMOD=ANY,   Addressing and Residency Modes      X
               LCAPFX=PLC,         Establish LCA Prefix for This RSECT X
               LOG=ON,             Turn Logging 'On' Temporarily       X
               LINKRTRN=BSM,       Define Return Linkage Instruction   X
               COPY@RT=YES         To Generate a Copyright Statement
         USING COM_DATA,RCOMM      Addressability to Common Data Area
         USING LGRWK2II,RLGW       Establish Addressability to LGRWK2II
         USING SDWA,RSDW           Establish Addressability to SDWA
         LMG   R8,R10,0(R1)        Load the Parameter Area Addresses
         XC    PLCRETCD,PLCRETCD   Initialize the Return Code
*
*+-------------------------------------------------------------------+*
*|    Print the Initial Logger Control Area Message                  |*
*+-------------------------------------------------------------------+*
*
CNTLPGM  USING LCA,R2              Establish Addresability to the LCA
PLCA1000 DS    0H
         MVC   PLCLGPTT,BASSM      Enable Logger Services Log Points
         NI    LGWFLAG2,255-LGWSTEXH Reset In Case Previous Blk Overrun
         ST    RLGW,PLCTRCDS       Addr of LGRWK2II Area to Current LCA
         STMG  R14,R1,PLCWR141     Save the Registers Over Log Point
         SLGR  R0,R0               Zero 1st Operand Register of Execute
         LLGT  R15,PLCVCON         Obtain the Address of Logger Program
         O     R15,=A(X'00000001') Turn On the Low Order AMODE-64 Bit
         EX    R0,PLCLGPTT         Execute the Appropriate Log Point
         BRU   PLCA1400            Branch Around the Log Point Data
         DC    AL4(PLCA1100)       Addr of #LGPOINT Parameter Data Area
PLCA1100 DC    CL4'LPNT'           Set the Log Point Information Type
         DC    AL4(*-*)            Set the Program Exit Offset Value
         DC    B'0000000000000000' Indicate Registers to Trace
         DC    BL1'10110001'       Flag: MSG=,SUPHEAD,COMPRESS, No TOD
         DC    AL1(L'PLCA1200)     Number of Characters in Name
PLCA1200 DC    C'PLCA1000'         Name of This User Program Log Point
         DC    YL2(PLCALEN1)       Indicate the Length of MSG= Data
PLCA1300 DC    C'-Printing Storage Areas From Main Program-'
PLCALEN1 EQU   *-PLCA1300          Establish Length of Message Area
PLCA1400 DS    0H
         LMG   R14,R1,PLCWR141     Restore Registers After Log Point
*
*+-------------------------------------------------------------------+*
*|    Print the Logger Control Area Storage For User Programs        |*
*+-------------------------------------------------------------------+*
*
PLCA2000 DS    0H
         LLGT  R2,LGWMAINP         Obtain Main Program's LCA Address
PLCA2100 DS    0H
         LLGT  R3,CNTLPGM.LCADSADR ...Get the Address of LCA
         LLGF  R4,CNTLPGM.LCADSLTH ...Get the Length  of LCA
         LLGT  R5,CNTLPGM.LCACSADR ...Get Address of Control Section
         CLC   CNTLPGM.LCASAVE+4(4),=C'F5SA' Format5 Save Area for Pgm?
         BRE   PLCA2200            Yes => Then Entry From Main Program
         MVC   PLCCSECT,25(R5)     Preserve the Control Section Name
         BRU   PLCA2300            Branch to Process the Csect Name
PLCA2200 DS    0H
         MVC   PLCCSECT,21(R5)     Preserve the Control Section Name
PLCA2300 DS    0H
         STMG  R14,R1,PLCWR141     Save Current Registers Over Log Pnt
         SLGR  R0,R0               Zero 1st Operand Register of Execute
         LLGT  R15,PLCVCON         Get the Address of Logger Program
         O     R15,=A(X'00000001') Turn On the Low Order AMODE-64 Bit
         EX    R0,PLCLGPTT         Execute the Appropriate Log Point
         BRU   PLCA2900            Branch Around Log Point Data
         DC    AL4(PLCA2400)       Addr of #LGPOINT Parameter Data Area
PLCA2400 DC    CL4'LPNT'           Set the Log Point Information Type
         DC    AL4(*-*)            Set the Program Exit Offset Value
         DC    BL2'0000000000000000'  Indicate the Registers to Log
         DC    BL1'11110001'       Flag Byte for Parameters Specified
         DC    AL1(L'PLCA2500)     Number of Characters in Name
PLCA2500 DC    C'PLCA2300'         Name of This User Program Log Point
         DC    YL2(PLCAMLN2)       Length of MSG= Data
PLCA2600 EQU   *                   Beginning of the MSG= Parameter
         DC    C'Save Area Storage For CSECT: '
         DC    X'40'               Add Fill Byte for Halfword Alignment
         DC    X'FE',C'C'          Indicate a Variable & Variable Type
         RLLG  R0,R0,PLCCSECT      Address of the Message Variable
         DC    YL2(L'PLCCSECT)     Length of the Message Variable
PLCAMLN2 EQU *-PLCA2600            Length of the Message Area
         DC    YL2(PLCADLN2)       Length of the SHOW= Area
PLCA2700 EQU   *                   Beginning of the SHOW= Parameter
         RLLG  R0,R0,0(R3)         Address for the Data To Print
         DC    YL2((R4))           Length of Data To Print
         DC    BL1'00100000'       No Redirection, Length in Register
         DC    YL1(L'PLCA2800)     Length of Header
PLCA2800 DC    C'Begin Dump of LCA Storage Area'
PLCADLN2 EQU   *-PLCA2700          Length of Data Area
PLCA2900 DS    0H
         LMG   R14,R1,PLCWR141     Restore Registers After Log Point
*
*+-------------------------------------------------------------------+*
*|    Loop Point to Print LCA for All Active Programs                |*
*+-------------------------------------------------------------------+*
*
PLCA3000 DS    0H
         LG    R2,LCAF64FWD-LCASAVE(,R2) Get the Next Save Area Address
         LTGR  R2,R2               Is There Another Save Area Address?
         BRZ   PLCAEXIT            No => Branch to Exit This Routine
         CLC   0(4,R2),=C'LCA '    Is This One of Our Programs?
         BRE   PLCA2100            Yes => Loop to Process LCA
         BRU   PLCAEXIT            No  => Branch to Exit This Routine
         DROP  CNTLPGM             Remove Listed Reg as LCA Base Reg
*
*+-------------------------------------------------------------------+*
*|   Return to Caller                                                |*
*+-------------------------------------------------------------------+*
*
PLCAEXIT DS    0H
         XC    PLCLGPTT,PLCLGPTT   Disable Logger Services Log Points
         SLGR  R15,R15             Indicate Successful Completion
         ST    R15,PLCRETCD        Set the Return Code
         LPGMEXIT RC=PLCRETCD      Define Program Exit Protocol
*
BASSM    BASSM R14,R15             Used to Enable Log Points
*
*+-------------------------------------------------------------------+*
*|    Program RENT Work Area                                         |*
*+-------------------------------------------------------------------+*
*
         LCA   DEFINE              Define the Program RENT Work Area
*
PLCWORKD DS    10D                 General Work Area
PLCRETCD DS    F                   Save Area for the Return Code
PLCCSECT DS    CL32                Program Control Section (CSECT) Name
*
         LCA   DEFEND              Define End of Program RENT Work Area
*
***********************************************************************
*           End of Print Logger Control Area Processing               *
***********************************************************************
         EJECT ,
***********************************************************************
**************************+-----------------+**************************
**************************| P C O M 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|     P r i n t   o f   P r o g r a m   C o m m o n    A r e a      |*
*+-------------------------------------------------------------------+*
* PROGRAM NAME:    PCOM0000                                           *
*                                                                     *
* FUNCTION:        Print the Common Area and Control Blocks           *
*                                                                     *
*                  This routine is responsible for performing         *
*                  the print of the common area, and the Dsect Areas  *
*                  LGRWK2II and PGMLG2II defined in the LGCPLSWA      *
*                  Copybook. This routine contains in-line Log Points *
*                  that are manually hard coded in this routine in the*
*                  same format as would be generated automatically by *
*                  a #LGPOINT command in a user program so they can   *
*                  be used by Logger Services program LGMHLRCE. Since *
*                  the main LGMHRTRY program was implemented with     *
*                  LOG=OFF in LPGMNTRY, Logger Services is being      *
*                  temporarily enabled in this routine to allow Logger*
*                  Services program LGMHLRCE to be used to process the*
*                  hard coded Log Points.                             *
*                                                                     *
* INPUT REGS:      R1 => Standard O/S Parameter List                  *
*                                                                     *
* INPUT DATA:      Parm1: Addr of System Diagnostic Work Area         *
*                  Parm2: Addr of LGRWK2II Logger Work Area           *
*                  Parm3: Addr of Common Constants and Routines Area  *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY, AC=0                          *
*                                                                     *
* CALLING PROGRAM: LGMHRTRY - Main Program                            *
*                                                                     *
* CALLED PROGRAMS: LGMHLRCE - Logger Services Event Publishing Program*
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                  04 - Warning                                       *
*                  08 - Error                                         *
*                  12 - Severe Error - Exit This Routine              *
*                                                                     *
***********************************************************************
*
PCOM0000 LPGMNTRY TYPE=SUB,        Define As A Sub-Program Entry       X
               BASE=(12),          Establish Base Registers            X
               AMOD=64,RMOD=ANY,   Addressing and Residency Modes      X
               LCAPFX=PCO,         Establish LCA Prefix for This RSECT X
               LOG=ON,             Turn Logging 'On' Temporarily       X
               LINKRTRN=BSM,       Define Return Linkage Instruction   X
               COPY@RT=YES         To Generate a Copyright Statement
         USING COM_DATA,RCOMM      Addressability to Common Data Area
         USING LGRWK2II,RLGW       Establish Addressability to LGRWK2II
         USING SDWA,RSDW           Establish Addressability to SDWA
         LMG   R8,R10,0(R1)        Load the Parameter Area Addresses
         XC    PCORETCD,PCORETCD   Initialize the Return Code
*
*+-------------------------------------------------------------------+*
*|    Print the Common Area Storage Block                            |*
*+-------------------------------------------------------------------+*
*
CNTLPGM  USING LCA,R2              Establish Addressability to the LCA
PCOM1000 DS    0H
         MVC   PCOLGPTT,BASSM$     Enable Logger Services Log Points
         ST    RLGW,PCOTRCDS       Addr of LGRWK2II Area to Current LCA
         LLGT  R2,LGWMAINP         Obtain Main Program's LCA Address
         SLGR  R5,R5               Ensure We Have a Clean High Half
         ICM   R5,B'1111',CNTLPGM.LCA$COMM  Have a Common Area Addr?
         BRZ   PCOM3000            No  => Then Bypass Printing of Area
         ICM   R4,B'1111',CNTLPGM.LCA$COML  Have a Common Area Length?
         BRZ   PCOM3000            No  => Then Bypass Printing of Area
         CGHI  R4,(32767)          Is the Length Within Maximum Bounds?
         BRH   PCOM3000            No  => Then Bypass Printing of Area
PCOM2000 DS    0H
         STMG  R14,R1,PCOWR141     Save Current Registers Over Log Pnt
         SLGR  R0,R0               Zero 1st Operand Register of Execute
         LLGT  R15,PCOVCON         Get the Address of Logger Program
         O     R15,=A(X'00000001') Turn On the Low Order AMODE-64 Bit
         EX    R0,PCOLGPTT         Execute the Appropriate Log Point
         BRU   PCOM2600            Branch Around Log Point Data
         DC    AL4(PCOM2100)       Addr of #LGPOINT Parameter Data Area
PCOM2100 DS    0H
         DC    CL4'LPNT'           Set the Log Point Information Type
         DC    AL4(*-*)            Set the Program Exit Offset Value
         DC    BL2'0000000000000000'   Registers to Trace
         DC    BL1'01110001'       Flag Byte for Parameters Specified
         DC    AL1(L'PCOM2200)     Number of Characters in Name
PCOM2200 DC    C'PCOM2000'         Name of This User Program Log Point
         DC    YL2(PCOMDLN1)       Length of the SHOW= Area
PCOM2300 EQU   *                   Beginning of the SHOW= Parameter
         RLLG  R0,R0,0(R5)         Address for the Data To Print
         DC    YL2((R4))           Length of Data To Print
         DC    BL1'00100000'       No Redirection, Length in Register
         DC    YL1(L'PCOM2400)     Length of Header
PCOM2400 DC    C'Printing Common Area Block'
PCOMDLN1 EQU   *-PCOM2300          Length of Data Area
PCOM2600 DS    0H
         LMG   R14,R1,PCOWR141     Restore Registers After Log Point
         DROP  CNTLPGM             Remove Listed Reg as LCA Base Reg
*
*+-------------------------------------------------------------------+*
*|    Print the LGRWK2II Storage Control Block                       |*
*+-------------------------------------------------------------------+*
*
PCOM3000 DS    0H
         LTGR  RLGW,RLGW           Log Service Active in User Program?
         BRZ   PCOMEXIT            No  => Branch to Exit This Routine
PCOM4000 DS    0H
         STMG  R14,R1,PCOWR141     Save Current Registers Over Log Pnt
         SLGR  R0,R0               Zero 1st Operand Register of Execute
         LLGT  R15,PCOVCON         Get the Address of Logger Program
         O     R15,=A(X'00000001') Turn On the Low Order AMODE-64 Bit
         EX    R0,PCOLGPTT         Execute the Appropriate Log Point
         BRU   PCOM4600            Branch Around Log Point Data
         DC    AL4(PCOM4100)       Addr of #LGPOINT Parameter Data Area
PCOM4100 DC    CL4'LPNT'           Set the Log Point Information Type
         DC    AL4(*-*)            Set the Program Exit Offset Value
         DC    BL2'0000000000000000'   Registers to Trace
         DC    BL1'01110001'       Flag Byte for Parameters Specified
         DC    AL1(L'PCOM4200)     Number of Characters in Name
PCOM4200 DC    C'PCOM4000'         Name of This User Program Log Point
         DC    YL2(PCOMDLN2)       Length of the SHOW= Area
PCOM4300 EQU   *                   Beginning of the SHOW= Parameter
         RLLG  R0,R0,0(RLGW)       Address for the Data To Print
         DC    YL2(1024*4)         Length of Data To Print
         DC    BL1'00000000'       Data Processing Flag Byte
         DC    YL1(L'PCOM4400)     Length of Header
PCOM4400 DC    C'LGRWK2II Work Area'
PCOMDLN2 EQU   *-PCOM4300          Length of Data Area
PCOM4600 DS    0H
         LMG   R14,R1,PCOWR141     Restore Registers After Log Point
*
*+-------------------------------------------------------------------+*
*|    Print the PGMLG2II Storage Control Block                       |*
*+-------------------------------------------------------------------+*
*
PCOM5000 DS    0H
         SLGR  R2,R2               Ensure We Have a Clean High Half
         ICM   R2,B'1111',LGWPGML  User Program Have a PGMLG2II Area?
         BRZ   PCOM7000            No  => Branch to Process Message
PCOM6000 DS    0H
         STMG  R14,R1,PCOWR141     Save Current Registers Over Log Pnt
         SLGR  R0,R0               Zero 1st Operand Register of Execute
         LLGT  R15,PCOVCON         Get the Address of Logger Program
         O     R15,=A(X'00000001') Turn On the Low Order AMODE-64 Bit
         EX    R0,PCOLGPTT         Execute the Appropriate Log Point
         BRU   PCOM6600            Branch Around Log Point Data
         DC    AL4(PCOM6100)       Addr of #LGPOINT Parameter Data Area
PCOM6100 DC    CL4'LPNT'           Set the Log Point Information Type
         DC    AL4(*-*)            Set the Program Exit Offset Value
         DC    BL2'0000000000000000'   Registers to Trace
         DC    BL1'01110001'       Flag Byte for Parameters Specified
         DC    AL1(L'PCOM6200)     Number of Characters in Name
PCOM6200 DC    C'PCOM6000'         Name of This User Program Log Point
         DC    YL2(PCOMDLN3)       Length of the DATA= Area
PCOM6300 EQU   *                   Beginning of the SHOW= Parameter
         RLLG  R0,R0,0(R2)         Address for the Data To Print
         DC    YL2(PGMLG2LN)       Length of Data To Print
         DC    BL1'00000000'       Data Processing Flag Byte
         DC    YL1(L'PCOM6400)     Length of Header
PCOM6400 DC    C'PGMLG2II Control Block'
PCOMDLN3 EQU   *-PCOM6300          Length of Data Area
PCOM6600 DS    0H
         LMG   R14,R1,PCOWR141     Restore Registers After Log Point
*
*+-------------------------------------------------------------------+*
*|    Print the Ending Message                                       |*
*+-------------------------------------------------------------------+*
*
PCOM7000 DS    0H
         STMG  R14,R1,PCOWR141     Save the Registers Over Log Point
         SLGR  R0,R0               Zero 1st Operand Register of Execute
         LLGT  R15,PCOVCON         Obtain the Address of Logger Program
         O     R15,=A(X'00000001') Turn On the Low Order AMODE-64 Bit
         EX    R0,PCOLGPTT         Execute the Appropriate Log Point
         BRU   PCOM7400            Branch Around the Log Point Data
         DC    AL4(PCOM7100)       Addr of #LGPOINT Parameter Data Area
PCOM7100 DC    CL4'LPNT'           Set the Log Point Information Type
         DC    AL4(*-*)            Set the Program Exit Offset Value
         DC    B'0000000000000000' Indicate Registers to Trace
         DC    BL1'10110001'       Flag: MSG=,SUPHEAD,COMPRESS
         DC    AL1(L'PCOM7200)     Number of Characters in Name
PCOM7200 DC    C'PCOM7000'         Name of This Trap
         DC    YL2(PCOMLEN1)       Indicate the Length of MSG= Data
PCOM7300 DC    C'End of Logger Service Diagnostic Output.'
PCOMLEN1 EQU   *-PCOM7300          Establish Length of Message Area
PCOM7400 DS    0H
         LMG   R14,R1,PCOWR141     Restore Registers After Log Point
*
*+-------------------------------------------------------------------+*
*|   Return to Caller                                                |*
*+-------------------------------------------------------------------+*
*
PCOMEXIT DS    0H
         XC    PCOLGPTT,PCOLGPTT   Disable Logger Services Log Points
         SLGR  R15,R15             Indicate Successful Completion
         ST    R15,PCORETCD        Set the Return Code
         LPGMEXIT RC=PCORETCD      Define Program Exit Protocol
*
BASSM$   BASSM R14,R15             Used to Enable Log Points
*
*+-------------------------------------------------------------------+*
*|    Program RENT Work Area                                         |*
*+-------------------------------------------------------------------+*
*
         LCA   DEFINE              Define the Program RENT Work Area
*
PCOWORKD DS    10D                 General Work Area
PCORETCD DS    F                   Save Area for the Return Code
*
         LCA   DEFEND              Define End of Program RENT Work Area
*
***********************************************************************
*        End of Print Common Area and Control Block Processing        *
***********************************************************************
         EJECT ,
***********************************************************************
**************************+-----------------+**************************
**************************| C L N U 0 0 0 0 |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|       P e r f o r m   C l e a n   U p   F r o m   A b e n d       |*
*+-------------------------------------------------------------------+*
* PROGRAM NAME:    CLNU0000                                           *
*                                                                     *
* FUNCTION:        Perform Clean Up Process From Abend                *
*                                                                     *
*                  This routine is responsible for performing         *
*                  the clean up processing after an abend by closing  *
*                  data sets and releasing storage.                   *
*                                                                     *
*                  This routine invokes an ESPIE (Specify Program     *
*                  Interruption Exits Extended) service for processing*
*                  potential S0C1 and S0C4 abends. These ESPIE        *
*                  interruption types are basically to cover those    *
*                  conditions where (1)the user's program has an open *
*                  DCB that was either in get-main'ed storage or      *
*                  resided in a secondary load module brought in by   *
*                  the user's program with a LOAD, and before our     *
*                  attempt to close it the DCB storage has been       *
*                  released or the load module was deleted when at a  *
*                  load count of 1, or (2)the user's program has an   *
*                  open DCB and before our attempt to close it as part*
*                  of our abend cleanup the DCB had been previously   *
*                  overlaid or corrupted in some manner.              *
*                                                                     *
*                  Once the data set clean-up is completed, then a    *
*                  check is made to verify if the user specified      *
*                  the LOGOUT=BUFR parameter to buffer Logger records.*
*                  If yes, then the storage area for Logger Services  *
*                  output records is released.                        *
*                                                                     *
* INPUT REGS:      R1 => Standard O/S Parameter List                  *
*                                                                     *
* INPUT DATA:      Parm1: Addr of Abending Program's LCA Area         *
*                  Parm2: Addr of System Diagnostic Work Area         *
*                  Parm3: Addr of LGRWK2II Logger Work Area           *
*                  Parm4: Addr of Common Constants and Routines Area  *
*                                                                     *
* OUTPUT REGS:     R15 => Return Code                                 *
*                                                                     *
* ATTRIBUTES:      REENTRANT, REUSABLE                                *
*                  AMODE 64, RMODE ANY, AC=0                          *
*                                                                     *
* CALLING PROGRAM: LGMHRTRY - Main Program                            *
*                                                                     *
* CALLED PROGRAMS: LGMHLRCB - Logger Services Log Record Program for  *
*                             Buffering Records Above-the-Line        *
*                  LGMHLB64 - Logger Services Log Record Program for  *
*                             Buffering Records Above-the-Bar         *
*                                                                     *
* RETURN CODES:    00 - Success                                       *
*                  04 - Warning                                       *
*                  08 - Error                                         *
*                  12 - Severe Error - Exit This Routine              *
*                                                                     *
***********************************************************************
*
CLNU0000 LPGMNTRY TYPE=SUB,        Define As A Sub-Program Entry       X
               BASE=(12),          Establish Base Registers            X
               AMOD=64,RMOD=ANY,   Addressing and Residency Modes      X
               LCAPFX=CLN,         Establish LCA Prefix for This RSECT X
               LOG=OFF,            Always Turn Logging 'Off' in Logger!X
               LINKRTRN=BSM,       Define Return Linkage Instruction   X
               COPY@RT=YES         To Generate a Copyright Statement
         USING COM_DATA,RCOMM      Addressability to Common Data Area
         USING LGRWK2II,RLGW       Establish Addressability to LGRWK2II
         USING SDWA,RSDW           Establish Addressability to SDWA
         LMG   R7,R10,0(R1)        Load the Parameter Area Addresses
         STG   R7,CLNPLCA@         Save Abending Prpgram's LCA Address
         XC    CLNRETCD,CLNRETCD   Initialize the Return Code
*
*+-------------------------------------------------------------------+*
*|         Search For Data Control Blocks in TCB DEB Chain           |*
*+-------------------------------------------------------------------+*
*|  Attempt to verify if there is an open DCB by running the DEB     |*
*|  chain. If a DEB exists for the data set then attempt to close it |*
*|  as a part of the clean up process.                               |*
***********************************************************************
*
         USING TCB,R3              Addressability to Task Control Block
         USING DEBBASIC,R4         Addressability to DEB Basic Section
PFX      USING DEBPREFX,R5         Addressability to DEB Prefix Table
         USING IHADCB,R6           Set Addressability to Data Cntl Blk
CLNU1000 DS    0H
         LLGT  R1,CVTPTR           Absolute Address of Pointer to CVT
         USING CVT,R1              Establish Addressability to CVT
         LLGT  R1,CVTTCBP-CVT(,R1) Obtain the Task Control Block Addr
         LLGT  R3,4(,R1)           Obtain the Current TCB Address
         LLGT  R7,TCBTIO           Address of Task I/O Table Origin
         LLGT  R3,PSATOLD-PSA(,R0) Get Addr of Current Task Cntl Block
         LLGT  R4,TCBDEB-TCB(,R3)  Get Address of Job Step Cntl Block
         LTGFR R4,R4               Is First DEB in the Chain Available?
         BRZ   CLNUEXIT            No  => Then There are No Open DCB's
         MVC   CLNESPIE(LGRSPILN),LGRESPIE Fill ESPIE Remote Parm List
         LA    R2,CLNU5000         Obtain the User Exit Routine Address
         SLGR  R15,R15             Ensure Clean High-Half for Parm Reg
         ESPIE SET,(R2),(1,4),MF=(E,CLNESPIE) Set the ESPIE Environment
         ST    R1,CLNTOKEN         Token for Previous ESPIE Environment
CLNU1100 DS    0H
         LGR   R5,R4               Adr to Data Extent Blk Basic Section
         AGHI  R5,(DEBPREFX-DEBBASIC) ..Subtract to Point to DEB Prefix
         LLGT  R6,DEBDCBAD         Get Addr of DCB or ACB for This DEB
         CLI   PFX.DEBAMTYP,DEBAMVSM  Access Method Type VSAM Data Set?
         BRE   CLNU2000            Yes => Check DEB/DCB Association
CLNU1200 DS    0H
         N     R6,=A(X'00FFFFFF')  Clear High Order Byte for 24-Bit DCB
         CLI   PFX.DEBAMTYP,DEBAMSUB  ...Is This a Sub-System Data Set?
         BRNE  CLNU2000            No  => Continue to Process for Close
         ICM   R6,B'1111',DEBRRQ   JES Uses an ACB, So Is There a DCB?
         BRZ   CLNU2600            No  => No DCB to Close So Next DEB
*
*+-------------------------------------------------------------------+*
*| Check the TIOT, verify the DEB and DCB point back to one another, |*
*| check if the DCB was defined with an exit list and disable it to  |*
*| ensure there is no DCB exit processing on close, and check the    |*
*| buffering technique used to open the data set to verify the mode  |*
*| specification on the CLOSE macro which will be used is consistent |*
*| with that which was used on the OPEN macro.                       |*
*+-------------------------------------------------------------------+*
*
CLNU2000 DS    0H
         LLGH  R1,DCBTIOT          Offset to TIOT Origin for DD of DCB
         LA    R1,0(R1,R7)         Point to TIOELENG in TIOT for the DD
         CLC   TIOEDDNM-TIOENTRY(L'TIOEDDNM,R1),=CL8'STEPLIB'  Steplib?
         BRE   CLNU2600            Yes => Then Process the Next DEB
CLNU2100 DS    0H
         LA    R1,DEBBASIC         Get Addr to DEB Associated with DCB
         CLM   R1,B'0111',DCBDEBA  Does DCB Associated with DEB Match?
         BRNE  CLNU2600            No  => Then Process the Next DEB
         SLGR  R0,R0               Clear for Use as a Work Register
         ICM   R0,B'0111',DCBEXLSA Is DCB Defined With a DCB Exit List?
         BRZ   CLNU2200            No  => Then Proceed to Check Buffers
         XC    DCBEXLSA,DCBEXLSA   Disable DCB Exit Processing on Close
CLNU2200 DS    0H
         TM    DCBBFTEK,DCBH0+DCBH1 ..There a DCBE Present for Our DCB?
         BRZ   CLNU2300            No  => Then Proceed to Attempt Close
         LLGT  R1,DCBDCBE          Obtain DCBE Associated With This DCB
         TM    DCBEFLG1-DCBE(R1),DCBEMD31 System Allows Access 31-bit?
         BRZ   CLNU2300            No  => Then Assume 24-Bit Buffers
         TM    DCBCIND2,DCBCNQSM   Is This DCB for a QSAM Data Set?
         BRZ   CLNU2400            No  => Proceed to Close as 31-Bit
         TM    DCBEFLG2-DCBE(R1),DCBEBU31 RMODE=31 Buffers Set on QSAM?
         BRO   CLNU2400            Yes => Proceed to Close as 31-Bit
CLNU2300 DS    0H
         MVC   CLNCLS24,LCLOSE24   Build the Close Parameter List
         SYSSTATE AMODE64=NO,ARCHLVL=2 Generate Code for Not in AMODE64
         SAM31                     Switch Now to 31-Bit Addressing Mode
         CLOSE ((R6)),             Perform Close Process for Data Set  X
               MF=(E,CLNCLS24)     Execute Form of Close
         SAM64                     Switch Back to 64-Bit Address Mode
         SYSSTATE AMODE64=YES,ARCHLVL=2    Restore 64-Bit Environment
         BRU   CLNU2500            Branch to Process the Next DEB
CLNU2400 DS    0H
         MVC   CLNCLS31,LCLOSE31   Build the Close Parameter List
         SYSSTATE AMODE64=NO,ARCHLVL=2 Generate Code for Not in AMODE64
         SAM31                     Switch Now to 31-Bit Addressing Mode
         CLOSE ((R6)),             Perform Close Process for Data Set  X
               MF=(E,CLNCLS31),    Execute Form of Close               X
               MODE=31             Indicate 31-bit Mode
         SAM64                     Switch Back to 64-Bit Address Mode
         SYSSTATE AMODE64=YES,ARCHLVL=2    Restore 64-Bit Environment
CLNU2500 DS    0H
         LLGT  R4,TCBDEB-TCB(,R3)  Get First Data Extent Block on Chain
         BRU   CLNU2700            Branch to Process Data Extent Blocks
CLNU2600 DS    0H
         ICM   R4,B'0111',DEBDEBB  Check If Another DEB is on the Chain
CLNU2700 DS    0H
         LTGFR R4,R4               We at the End of the TCB DEB Chain?
         BRNZ  CLNU1100            No  => Branch to Process Next DEB
         DROP  R3,R4,PFX,R6        Remove Listed Regs as Base Registers
CLNU3000 DS    0H
         ESPIE RESET,CLNTOKEN      Remove the Current ESPIE Environment
*
*+-------------------------------------------------------------------+*
*|            Release Logger Records Buffer Storage Area             |*
*+-------------------------------------------------------------------+*
*
CALLER   USING LCACLN,PLCA         Setup Caller's LCA Addressability
CLNU4000 DS    0H
         LA    R2,LGWPINDX         Get Pointer to Primary Indx Blk Addr
         LG    RSDX,0(,R2)         Get the Primary Index Block Address
         LTGR  RSDX,RSDX           There a Primary Index Block Address?
         BRZ   CLNUEXIT            No  => No Buffer Area to be Released
         LG    PLCA,CLNPLCA@       Get Abending User Program's LCA Addr
         TM    CALLER.CLNWFLAG,LCAWBUFR Log Rcd Buffers Above-the-Line?
         BRO   CLNU4100            Yes => Free Above-the-Line Storage
         TM    CALLER.CLNWFLAG,LCAWBU64 Log Rcrd Buffers Above-the-Bar?
         BRO   CLNU4200            Yes => Release Above-the-Bar Storage
         BRU   CLNUEXIT            No  => No Buffer Area to be Released
CLNU4100 DS    0H
         LLGT  R15,=A(LCXALRCB)    Pointer to Addr of Pgm for Rcrds ATL
         LLGT  R15,0(,R15)         Addr of Pgm for Rcrds Above-the-Line
         BRU   CLNU4300            Branch to Release Log Record Buffers
CLNU4200 DS    0H
         LLGT  R15,=A(LCXALB64)    Pointer to Addr of Pgm for Rcrds ATB
         LLGT  R15,0(,R15)         Addr of Pgm for Recrds Above-the-Bar
CLNU4300 DS    0H
         LLGF  R4,=A(X'7FFFFFFF')  Set High Value Indicator to Rcrd Cnt
         XC    CLNPLIST,CLNPLIST   Clear the Call Parameter List
         LGR   R2,R13              Preserve Current Save Area Address
         LA    R13,CLNSAVEG        Provide Save Area Stack for Program
         CALL  (15),               Process Release of Log Recd Buffers X
               (LGRWK2II,          ..Pass Pntr to Logger Service Area  X
               (R4)),              ..Pass High Value Indicator for RlseX
               PLIST8=YES,         ..Indicate Parameter List Format    X
               LINKINST=LGR,       ..Indicate Link Instruction Type    X
               MF=(E,CLNPLIST)     ..Remote Program Parameter List
         LA    R15,1(,R14)         Turn On the Low Order AMODE-64 Bit
         BASSM R14,R15             Release Logger Recrds Buffer Storage
         LGR   R13,R2              Restore Current Save Area Address
         DROP  CALLER              Remove Listed Reg as LCA Base Reg
*
*+-------------------------------------------------------------------+*
*|   Return to Caller                                                |*
*+-------------------------------------------------------------------+*
*
CLNUEXIT DS    0H
         SLGR  R15,R15             Indicate Successful Completion
         ST    R15,CLNRETCD        Set the Return Code
         LPGMEXIT RC=CLNRETCD      Define Program Exit Protocol
*
***********************************************************************
*  ESPIE Exit Routine to Receive Control Upon a Program Interruption  *
***********************************************************************
*
         PUSH  USING               Save Current Environment
CLNU5000 DS    0H
         CNOP  0,8                 Ensure Proper Boundary Alignment
         BRAS  R15,*+8             Branch Around the Static Data Area
         DC    A(*+4)              Establish Static Area with Address
         L     R15,0(R15,R0)       Set up to Address of Static Data
INT      USING *-4,R15             Establish Addressability to Exit Pnt
         USING EPIE,R1             Establish Addressability to EPIE
         LLGT  R2,=A(CLNU2600)     Get Return Point in Interrupted Pgm
         ST    R2,EPIEPSW+4        Set Return Point in the OPSW of EPIE
         OI    EPIEAMF1,EPIEMOD1   Set the Addressing Mode Flag (RTM)
         OI    EPIEFLGS,EPIEUP64   Use Values in EPIEG64 for Registers
         BSM   0,R14               Return for Retry in Our Retry Pgm
         DROP  R1,INT              Remove Listed Regs as Exit Base Regs
         POP   USING               Restore Current Environment
         LTORG ,                   Establish the Literal Origin Pool
*
*+-------------------------------------------------------------------+*
*|    Program RENT Work Area                                         |*
*+-------------------------------------------------------------------+*
*
         LCA   DEFINE              Define the Program RENT Work Area
*
CLNWORKD DS    10D                 General Work Area
CLNSAVEG DS    27FD                Program Save Area 1 - (GPR's)
CLNSAVE2 DS    27FD                Stacked Save Area 2 - (F5SA Format)
CLNSAVE3 DS    27FD                Stacked Save Area 3 - (F5SA Format)
CLNSAVE4 DS    27FD                Stacked Save Area 4 - (F5SA Format)
CLNSAVE5 DS    27FD                Stacked Save Area 5 - (F5SA Format)
CLNPLIST DS    20FD                CALL Parameter List
CLNPLCA@ DS    AD                  Abending Program's LCA Address
CLNRETCD DS    F                   Save Area for the Return Code
CLNTOKEN DS    F                   Token of the previously active ESPIE
CLNESPIE DS    XL(LGRSPILN)        Area for ESPIE Macro List Form
         DS    0F
CLNCLS24 DS    XL(LCLLEN24)        CLOSE Macro Parameter List
         DS    0F
CLNCLS31 DS    XL(LCLLEN31)        CLOSE Macro Parameter List
*
         LCA   DEFEND              Define End of Program RENT Work Area
*
***********************************************************************
*               End of Clean Up From Abend Processing                 *
***********************************************************************
         EJECT ,
***********************************************************************
*+-------------------------------------------------------------------+*
*|                DDDDDD    AAAAA    TTTTTTT   AAAAA                 |*
*|                D     D  A     A      T     A     A                |*
*|                D     D  A     A      T     A     A                |*
*|                D     D  AAAAAAA      T     AAAAAAA                |*
*|                D     D  A     A      T     A     A                |*
*|                D     D  A     A      T     A     A                |*
*|                DDDDDD   A     A      T     A     A                |*
*+-------------------------------------------------------------------+*
***********************************************************************
*                                                                     *
***********************************************************************
*
*+-------------------------------------------------------------------+*
*|           D e f i n e   G e n e r i c   E q u a t e s             |*
*+-------------------------------------------------------------------+*
*
RLCA     EQU   13                  Establish Caller's LCA Address (R13)
RBASE1   EQU   12                  Establish Program Base Register 1
RBASE2   EQU   11                  Establish Program Base Register 2
RCOMM    EQU   10                  Address of Common Constants Area
RLGW     EQU   9                   Address of Associated LGRWK2II Area
RSDW     EQU   8                   System Diagnostic Work Area (SDWA)
PLCA     EQU   7                   Abending User Program's LCA Addr
RPCC     EQU   6                   Current Logger Control Area Address
RSDX     EQU   5                   Logger Buffer Secondary Index Block
REDB     EQU   4                   Logger Buffer Record Data Block
         USING COM_DATA,RCOMM      Addressability to Common Data Area
         USING LGRWK2II,RLGW       Establish Addressability to LGRWK2II
         USING SDWA,RSDW           Establish Addressability to SDWA
         USING IHADCB,LGWODCB      Establish Addressability to DCB
*
***********************************************************************
**************************+-----------------+**************************
**************************| C O M _ D A T A |**************************
**************************+-----------------+**************************
***********************************************************************
*+-------------------------------------------------------------------+*
*|   L o g g e r   C o n t r o l   C o m m o n   D a t a   A r e a   |*
*+-------------------------------------------------------------------+*
*
COM_DATA RSECT
COM_DATA AMODE &AMODE
COM_DATA RMODE &RMODE
*
BLANKS   DC    CL133' '            Define Character String of Blanks
CVT$ZTOK DC    D'0'                CVT TOD High Word Offset Zero Token
NOCARRY  EQU   8+4                 Condition Code for No Carry
NOBORROW EQU   2+1                 Condition Code for No Borrow
PROGRAM  DC    CL6'PROGRM'         Logger Line Program Name Indicator
*
COMWTO   DS    0D                  Write to Operator
         WTO   TEXT=(R4),,ROUTCDE=(11),MF=L      List Form of Macro
COMWTOL  EQU   *-COMWTO            Length of the WTO List Area
*
LGRESPIE DS    0D                  Specify Pgm Interrupt Exits Extended
         ESPIE SET,MF=L            List Form of Macro
LGRSPILN EQU   *-LGRESPIE          Length of the ESPIE List Area
         SYSSTATE AMODE64=NO,ARCHLVL=2 Generate Code for Not in AMODE64
LCLOSE24 CLOSE (*-*),MF=L          DCB Close Macro Parameter List
LCLLEN24 EQU  *-LCLOSE24           Length Definition for DCB Close List
LCLOSE31 CLOSE (*-*),MF=L,MODE=31  DCB Close Macro Parameter List
LCLLEN31 EQU  *-LCLOSE31           Length Definition for DCB Close List
         SYSSTATE AMODE64=YES,ARCHLVL=2    Restore 64-Bit Environment
LRTDDNMS DS    0CL10               DDnames Table
SYSIN    DC    CL8'SYSIN   ',Y(0)  Data Definition Name for //SYSIN
LGRSYSIN DC    CL8'LGRSYSIN',Y(0)  Data Definition Name for //LGRSYSIN
LGRECOUT DC    CL8'LGRECOUT',Y(0)  Data Definition Name for //LGRECOUT
LRT#DDNM EQU   (*-LRTDDNMS)/L'LRTDDNMS  Length of the DDnames Table
*
TRNSLATE TR    0(*-*,R15),HEXCONV-C'0' ...Translate Hex to Character
LCXALRCB DC    V(LGMHLRCB)         Vcon for Log Services Buffer Program
LCXALB64 DC    V(LGMHLB64)         Vcon for Log Services Buffer Program
*
*+-------------------------------------------------------------------+*
*|                  Define the Logger Output Lines                   |*
*+-------------------------------------------------------------------+*
*
CARDLEN  EQU   80                  Indicate Output Line Leng to Process
*
HEADER01 DC    CL30'******************************'
HEADER02 DC    CL30'*      Program Abended       *'
HEADER03 DC    CL30'******************************'
HEADER04 DC    C'-Save Area Trace-'
HEADER05 DC    C'Proceeding Backward From Last Save Area To First Save X
               Area:'
HEADER06 DC    C'-Invalid Back Chain-'
*
RCDLNE01 DC    CL(CARDLEN)'A program in this job has abended. To resolvX
               e the problem, attempt the'
RCDLNE02 DC    CL(CARDLEN)'following steps.'
RCDLNE03 DC    CL(CARDLEN)' '
RCDLNE04 DC    CL(CARDLEN)'(1)Determine the program release and modificX
               ation level.'
RCDLNE05 DC    CL(CARDLEN)'(2)Obtain the abend code, module name, and mX
               odule offset.'
RCDLNE06 DC    CL(CARDLEN)'(3)Get output from job including JESMSGLG, JX
               ESYSMSG, SYSTERM, SYSPRINT,'
RCDLNE07 DC    CL(CARDLEN)'   and dump output from SYSUDUMP, SYSABEND oX
               r SYSMDUMP if available.'
RCDLNE08 DC    CL(CARDLEN)' '
RCDLNE09 DC    CL(CARDLEN)'For a return or reason code with an abend coX
               de, refer to the manual'
RCDLNE10 DC    CL(CARDLEN)'z/OS MVS System Codes.'
RCDLNE11 DC    CL(CARDLEN)' '
RCDLNE12 DC    CL(CARDLEN)'For the message text or a return or reason cX
               ode in a message, check'
RCDLNE13 DC    CL(CARDLEN)'the following references:'
RCDLNE14 DC    CL(CARDLEN)' z/OS MVS System Messages, Vol 1 (ABA-AOM)'
RCDLNE15 DC    CL(CARDLEN)' z/OS MVS System Messages, Vol 2 (ARC-ASA)'
RCDLNE16 DC    CL(CARDLEN)' z/OS MVS System Messages, Vol 3 (ASB-BPX)'
RCDLNE17 DC    CL(CARDLEN)' z/OS MVS System Messages, Vol 4 (CBD-DMO)'
RCDLNE18 DC    CL(CARDLEN)' z/OS MVS System Messages, Vol 5 (EDG-GFS)'
RCDLNE19 DC    CL(CARDLEN)' z/OS MVS System Messages, Vol 6 (GOS-IEA)'
RCDLNE20 DC    CL(CARDLEN)' z/OS MVS System Messages, Vol 7 (IEB-IEE)'
RCDLNE21 DC    CL(CARDLEN)' z/OS MVS System Messages, Vol 8 (IEF-IGD)'
RCDLNE22 DC    CL(CARDLEN)' z/OS MVS System Messages, Vol 9 (IGF-IWM)'
RCDLNE23 DC    CL(CARDLEN)' z/OS MVS System Messages, Vol 10 (IXC-IZP)'
RCDLNE24 DC    CL(CARDLEN)' z/OS MVS Dump Output Messages'
RCDLNE25 DC    CL(CARDLEN)' '
RCDLNE26 DC    CL(CARDLEN)'In addition, you may try adding the followinX
               g JCL statements to the'
RCDLNE27 DC    CL(CARDLEN)'jobstream, and rerun the job to generate addX
               itional log output to'
RCDLNE28 DC    CL(CARDLEN)'assist in diagnosing the abend or error condX
               ition.'
RCDLNE29 DC    CL(CARDLEN)' '
RCDLNE30 DC    CL(CARDLEN)'    //LGRECOUT DD SYSOUT=*,DCB=(LRECL=133,BLX
               KSIZE=133)'
RCDLNE31 DC    CL(CARDLEN)'    //LGRSYSIN DD *'
RCDLINES EQU   (*-RCDLNE01)/CARDLEN
RCDLNE32 DC    CL(CARDLEN)'      LOGEVENT PROGRM,NAME='
         ORG   RCDLNE32
         DS    CL15
RCDPTYPE DS    CL6
         DS    CL6
RCDPGMNM DC    CL(CARDLEN-(*-RCDLNE32))' '
         ORG   ,
RCDLNE33 DC    CL(CARDLEN)'    /*'
*
*+-------------------------------------------------------------------+*
*|  Define Logger Diagnostic Information Report Output Detail Lines  |*
*+-------------------------------------------------------------------+*
*
PRNTLEN  EQU   132                 Indicate Output Line Leng to Process
DTLINE06 DC    CL(PRNTLEN)'Calling Program General Purpose Registers R0X
               -R15 at Entry to Called Program:'
DTLINE07 DC    CL(PRNTLEN)'Entered From: '
         ORG   DTLINE07
DTLNETYP DC    CL30' '
DTLCALLP DS    CL(L'LGWPGMNM)
         DC    CL(PRNTLEN-(*-DTLINE07))' '
         ORG   ,
DTLINE08 DC    CL(PRNTLEN)'DDName    EXCP Count        Data Set Name   X
                                                      Disp  VolSer'
         ORG   DTLINE08
DTLDDNAM DS    CL8
         DS    CL2
DTL@EXCP DS    CL15
         DS    CL3
DTLDSNAM DS    CL54
         DS    CL1
DTL@DISP DS    CL3
         DS    CL3
DTLVOLSR DS    CL8
         DC    CL(PRNTLEN-(*-DTLINE08))' '
*
HEXCONV  DC    C'0123456789ABCDEF' Translate Table for Hex to Character
         EJECT ,
*
***********************************************************************
*                    Logger Services Scan Table                       *
***********************************************************************
*
         DS    0D                  Set for DoubleWord Alignment (DUMP)
LGR#SCAN RSECT                     Program Control Section
LGR#SCAN AMODE &AMODE              Establish Addressing Mode
LGR#SCAN RMODE &RMODE              Establish Residence Mode
EBCDIC$Z DS    0CL256              Area for Character Translation Table
         DC    256XL1'00'          All Characters Set to Zero
         ORG   EBCDIC$Z+C' '       Reset Counter for Translation Scan
         DC    C' '                Set Storage to Display Blanks
         ORG   EBCDIC$Z+C'$'       Reset Counter for Translation Scan
         DC    C'$'                Dollar Sign, Asterisk & Right Parand
         ORG   EBCDIC$Z+C'-'       Reset Counter for Translation Scan
         DC    C'-'                Display Hyphen and Forward Slash
         ORG   EBCDIC$Z+C'#'       Reset Counter for Translation Scan
         DC    C'#@''='            # Sign, @ Sign, Apostrophe & Equal
         ORG   EBCDIC$Z+C'A'       Reset Counter for Translation Scan
         DC    C'ABCDEFGHI'        Set Stor to Display Upper Case A - I
         ORG   EBCDIC$Z+C'J'       Reset Counter for Translation Scan
         DC    C'JKLMNOPQR'        Set Stor to Display Upper Case J - R
         ORG   EBCDIC$Z+C'S'       Reset Counter for Translation Scan
         DC    C'STUVWXYZ'         Set Stor to Display Upper Case S - Z
         ORG   EBCDIC$Z+C'0'       Reset Counter for Translation Scan
         DC    C'0123456789'       Set Storage to Display Numeric 0 - 9
         ORG   ,                   Reset Location Counter to End of Tbl
EBCDIC$I DS    0CL256              Area for Character Translation Table
         DC    256AL1(*-EBCDIC$I)  Inverted Translate & Test Scan Table
         ORG   EBCDIC$I+X'00'      Reset to Point to 0 in Inverted Tble
         DC    X'01'               Fill Background 0 with 1 for Table
         ORG   EBCDIC$I+C'-'       Reset to Point to Hyphen in Table
         DC    X'00'               Use Background Zero for Inverted Tbl
         ORG   EBCDIC$I+C'0'       Reset to Point to Numerics in Table
         DC    XL10'00'            Use Background Zero for Inverted Tbl
         ORG   ,                   Reset Location Counter to End of Tbl
         EJECT ,
*
***********************************************************************
*  ESPIE Exit Routine to Receive Control Upon a Program Interruption  *
***********************************************************************
*
         DS    0D                  Set For Doubleword Alignment
EPIE$000 RSECT                     Program Read-Only Control Section
EPIE$000 AMODE &AMODE              Establish Addressing Mode
EPIE$000 RMODE &RMODE              Establish Residence Mode
         PUSH  USING               Save Current Environment
         CNOP  0,8                 Ensure Proper Boundary Alignment
         BRAS  R15,*+8             Branch Around the Static Data Area
         DC    A(*+4)              Establish Static Area with Address
         L     R15,0(R15,R0)       Set up to Address of Static Data
         USING *-4,R15             Establish Addressability to Exit Pnt
         USING EPIE,R1             Establish Addressability to EPIE
         LLGT  R0,LGWRETRY         Get Return Point in Interrupted Pgm
         LTGR  R0,R0               Is There a Designated Return Point?
         BRZ   EPIE$100            No  => Then Do Not Attempt Any Retry
         ST    R0,EPIEPSW+4        Set Return Point in the OPSW of EPIE
         OI    EPIEAMF1,EPIEMOD1   Set the Addressing Mode Flag (RTM)
         OI    EPIEFLGS,EPIEUP64   Use Values in EPIEG64 for Registers
         BSM   0,R14               Return for Retry in Our Retry Pgm
EPIE$100 DS    0H
         EX    R0,*                Take an Abend to Terminate Retry
         DROP  R1,R15              Remove Listed Regs as Exit Base Regs
         POP   USING               Restore Current Environment
         EJECT ,
*
***********************************************************************
*+-------------------------------------------------------------------+*
*|                  Program Interruption Code Table                  |*
*+-------------------------------------------------------------------+*
***********************************************************************
*
         DS    0D                  Set For Doubleword Alignment
PICEXCP  EQU   46                  Length of PIC Exception Description
PIC$KYWD RSECT                     Program Read-Only Control Section
PIC$KYWD AMODE &AMODE              Establish Addressing Mode
PIC$KYWD RMODE &RMODE              Establish Residence Mode
PICTNTRY DS    0CL(PIC@SIZE)       PIC Table Description Entry
PIC$X001 DC    Y(X'1'),Y(0),A(PIC$D001),Y(PIC$L001/PICDESC)
         DC    CL(PICEXCP)'operation exception:'
PIC$X002 DC    Y(X'2'),Y(0),A(PIC$D002),Y(PIC$L002/PICDESC)
         DC    CL(PICEXCP)'privileged-operation exception:'
PIC$X003 DC    Y(X'3'),Y(0),A(PIC$D003),Y(PIC$L003/PICDESC)
         DC    CL(PICEXCP)'execute exception:'
PIC$X004 DC    Y(X'4'),Y(0),A(PIC$D004),Y(PIC$L004/PICDESC)
         DC    CL(PICEXCP)'protection exception:'
PIC$X005 DC    Y(X'5'),Y(0),A(PIC$D005),Y(PIC$L005/PICDESC)
         DC    CL(PICEXCP)'addressing exception:'
PIC$X006 DC    Y(X'6'),Y(0),A(PIC$D006),Y(PIC$L006/PICDESC)
         DC    CL(PICEXCP)'specification exception:'
PIC$X007 DC    Y(X'7'),Y(0),A(PIC$D007),Y(PIC$L007/PICDESC)
         DC    CL(PICEXCP)'data exception:'
PIC$X008 DC    Y(X'8'),Y(0),A(PIC$D008),Y(PIC$L008/PICDESC)
         DC    CL(PICEXCP)'fixed-point-overflow exception:'
PIC$X009 DC    Y(X'9'),Y(0),A(PIC$D009),Y(PIC$L009/PICDESC)
         DC    CL(PICEXCP)'fixed-point-divide exception:'
PIC$X00A DC    Y(X'A'),Y(0),A(PIC$D00A),Y(PIC$L00A/PICDESC)
         DC    CL(PICEXCP)'decimal-overflow exception:'
PIC$X00B DC    Y(X'B'),Y(0),A(PIC$D00B),Y(PIC$L00B/PICDESC)
         DC    CL(PICEXCP)'decimal-divide exception:'
PIC$X00C DC    Y(X'C'),Y(0),A(PIC$D00C),Y(PIC$L00C/PICDESC)
         DC    CL(PICEXCP)'HFP-exponent-overflow exception:'
PIC$X00D DC    Y(X'D'),Y(0),A(PIC$D00D),Y(PIC$L00D/PICDESC)
         DC    CL(PICEXCP)'HFP-exponent-underflow exception:'
PIC$X00E DC    Y(X'E'),Y(0),A(PIC$D00E),Y(PIC$L00E/PICDESC)
         DC    CL(PICEXCP)'HFP-significance exception:'
PIC$X00F DC    Y(X'F'),Y(0),A(PIC$D00F),Y(PIC$L00F/PICDESC)
         DC    CL(PICEXCP)'HFP-floating-point-divide exception:'
PIC$X010 DC    Y(X'10'),Y(0),A(PIC$D010),Y(PIC$L010/PICDESC)
         DC    CL(PICEXCP)'segment-translation exception:'
PIC$X011 DC    Y(X'11'),Y(0),A(PIC$D011),Y(PIC$L011/PICDESC)
         DC    CL(PICEXCP)'page-translation exception:'
PIC$X012 DC    Y(X'12'),Y(0),A(*-*),Y(*-*)
         DC    CL(PICEXCP)'translation-specification exception:'
PIC$X013 DC    Y(X'13'),Y(0),A(*-*),Y(*-*)
         DC    CL(PICEXCP)'special-operation exception:'
PIC$X015 DC    Y(X'15'),Y(0),A(*-*),Y(*-*)
         DC    CL(PICEXCP)'operand exception:'
PIC$X016 DC    Y(X'16'),Y(0),A(*-*),Y(*-*)
         DC    CL(PICEXCP)'trace-table exception:'
PIC$X017 DC    Y(X'17'),Y(0),A(*-*),Y(*-*)
         DC    CL(PICEXCP)'ASN-translation specification exception:'
PIC$X01C DC    Y(X'1C'),Y(0),A(*-*),Y(*-*)
         DC    CL(PICEXCP)'space-switch event:'
PIC$X01D DC    Y(X'1D'),Y(0),A(*-*),Y(*-*)
         DC    CL(PICEXCP)'HFP-square-root exception:'
PIC$X01F DC    Y(X'1F'),Y(0),A(*-*),Y(*-*)
         DC    CL(PICEXCP)'PC-translation-specification exception:'
PIC$X020 DC    Y(X'20'),Y(0),A(*-*),Y(*-*)
         DC    CL(PICEXCP)'AFX-translation exception:'
PIC$X021 DC    Y(X'21'),Y(0),A(*-*),Y(*-*)
         DC    CL(PICEXCP)'ASX-translation exception:'
PIC$X022 DC    Y(X'22'),Y(0),A(*-*),Y(*-*)
         DC    CL(PICEXCP)'LX-translation exception:'
PIC$X023 DC    Y(X'23'),Y(0),A(*-*),Y(*-*)
         DC    CL(PICEXCP)'EX-translation exception:'
PIC$X024 DC    Y(X'24'),Y(0),A(*-*),Y(*-*)
         DC    CL(PICEXCP)'primary-authority exception:'
PIC$X025 DC    Y(X'25'),Y(0),A(*-*),Y(*-*)
         DC    CL(PICEXCP)'secondary-authority exception:'
PIC$X026 DC    Y(X'26'),Y(0),A(*-*),Y(*-*)
         DC    CL(PICEXCP)'LFX-translation exception:'
PIC$X027 DC    Y(X'27'),Y(0),A(*-*),Y(*-*)
         DC    CL(PICEXCP)'LSX-translation exception:'
PIC$X028 DC    Y(X'28'),Y(0),A(*-*),Y(*-*)
         DC    CL(PICEXCP)'ALET-specification exception:'
PIC$X029 DC    Y(X'29'),Y(0),A(PIC$D029),Y(PIC$L029/PICDESC)
         DC    CL(PICEXCP)'ALEN-translation exception:'
PIC$X02A DC    Y(X'2A'),Y(0),A(*-*),Y(*-*)
         DC    CL(PICEXCP)'ALE-sequence exception:'
PIC$X02B DC    Y(X'2B'),Y(0),A(*-*),Y(*-*)
         DC    CL(PICEXCP)'ASTE-validity exception:'
PIC$X02C DC    Y(X'2C'),Y(0),A(*-*),Y(*-*)
         DC    CL(PICEXCP)'ASTE-sequence exception:'
PIC$X02D DC    Y(X'2D'),Y(0),A(*-*),Y(*-*)
         DC    CL(PICEXCP)'extended-authority exception:'
PIC$X02E DC    Y(X'2E'),Y(0),A(*-*),Y(*-*)
         DC    CL(PICEXCP)'LSTE sequence:'
PIC$X02F DC    Y(X'2F'),Y(0),A(*-*),Y(*-*)
         DC    CL(PICEXCP)'ASTE instance:'
PIC$X030 DC    Y(X'30'),Y(0),A(*-*),Y(*-*)
         DC    CL(PICEXCP)'stack-full exception:'
PIC$X031 DC    Y(X'31'),Y(0),A(*-*),Y(*-*)
         DC    CL(PICEXCP)'stack-empty exception:'
PIC$X032 DC    Y(X'32'),Y(0),A(*-*),Y(*-*)
         DC    CL(PICEXCP)'stack-specification exception:'
PIC$X033 DC    Y(X'33'),Y(0),A(*-*),Y(*-*)
         DC    CL(PICEXCP)'stack-type exception:'
PIC$X034 DC    Y(X'34'),Y(0),A(*-*),Y(*-*)
         DC    CL(PICEXCP)'stack-operation exception:'
PIC$X038 DC    Y(X'38'),Y(0),A(PIC$D038),Y(PIC$L038/PICDESC)
         DC    CL(PICEXCP)'ASCE-type exception:'
PIC$X039 DC    Y(X'39'),Y(0),A(PIC$D039),Y(PIC$L039/PICDESC)
         DC    CL(PICEXCP)'region-first-translation exception:'
PIC$X03A DC    Y(X'3A'),Y(0),A(PIC$D03A),Y(PIC$L03A/PICDESC)
         DC    CL(PICEXCP)'region-second-translation exception:'
PIC$X03B DC    Y(X'3B'),Y(0),A(PIC$D03B),Y(PIC$L03B/PICDESC)
         DC    CL(PICEXCP)'region-third-translation exception:'
PIC$X040 DC    Y(X'40'),Y(0),A(*-*),Y(*-*)
         DC    CL(PICEXCP)'monitor event:'
PICTBLEN EQU   (*-PICTNTRY)
PIC#NTRY EQU   (*-PICTNTRY)/L'PICTNTRY
PICDESHD DC    C'Abend caused by program interrupt from '
PICABND$ DC    C'The following are some possible reasons for abend: '
         EJECT ,
*
***********************************************************************
*+-------------------------------------------------------------------+*
*|            Program Interruption Code Description Table            |*
*+-------------------------------------------------------------------+*
***********************************************************************
*
         DS    0D                  Set For Doubleword Alignment
PICDESC  EQU   100                 Length of PIC Condition Description
PIC$DESC RSECT                     Program Read-Only Control Section
PIC$DESC AMODE &AMODE              Establish Addressing Mode
PIC$DESC RMODE &RMODE              Establish Residence Mode
PIC$KDA@ DS    D                   Set PIC Descriptor Table Area Prefix
PIC$D001 DC    CL(PICDESC)'Invalid branch to a data area resulted in atX
               tempt to execute data.'
         DC    CL(PICDESC)'An area in your program with valid instructiX
               ons was overlaid and attempt to execute data.'
         DC    CL(PICDESC)'Incorrect entry point or module name was useX
               d in call to another routine.'
         DC    CL(PICDESC)'Incorrect linkage or logic placed zeros in RX
               15 before branch to intended routine.'
         DC    CL(PICDESC)'There was an attempt to access a data set whX
               ich was not opened.'
         DC    CL(PICDESC)'Attempt read after EOF, close data set twiceX
                without intervening open, or write to closed data set.'
         DC    CL(PICDESC)'There was a missing DDname in your JCL or DDX
               name incorrect or DDname specified wrong DSN.'
         DC    CL(PICDESC)'Attempt to execute an instruction requiring X
               a hardware feature or facility not installed.'
PIC$L001 EQU   *-PIC$D001          Length of the PIC Message Text Area
PIC$D002 DC    CL(PICDESC)'There was an attempt to execute a privilegedX
                instruction when not in supervisor state.'
         DC    CL(PICDESC)'Invalid branch to a data area where data by X
               chance matched a privileged instruction op code.'
         DC    CL(PICDESC)'An area in your program was overlaid and attX
               empt to execute unintended privileged instruction.'
         DC    CL(PICDESC)'Incorrect call was made to unintended routinX
               e with privilged instructions.'
PIC$L002 EQU   *-PIC$D002          Length of the PIC Message Text Area
PIC$D003 DC    CL(PICDESC)'The target of an execute instruction was anoX
               ther execute instruction.'
PIC$L003 EQU   *-PIC$D003          Length of the PIC Message Text Area
PIC$D004 DC    CL(PICDESC)'Storage or PSW protection key did not match X
               program protection key.'
         DC    CL(PICDESC)'Incorrect or invalid address in instruction X
               resulted in access to fetch or write protected storage.'
         DC    CL(PICDESC)'Runaway program loop using index eventually X
               creeped to a fetch or write protected area.'
         DC    CL(PICDESC)'Entry point on a branch from your program waX
               s to a routine with different storage protection key.'
         DC    CL(PICDESC)'An LA instead of L or vice versa resulted inX
                branch, base, or index register with invalid pointer.'
PIC$L004 EQU   *-PIC$D004          Length of the PIC Message Text Area
PIC$D005 DC    CL(PICDESC)'Invalid address caused attempt to reference X
               real storage outside available physical storage.'
PIC$L005 EQU   *-PIC$D005          Length of the PIC Message Text Area
PIC$D006 DC    CL(PICDESC)'An odd-number register was used in R1 field X
               of an instruction using an even-odd pair of registers.'
         DC    CL(PICDESC)'2nd operand length of packed decimal multiplX
               y/divide was equal or greater than 1st operand length.'
         DC    CL(PICDESC)'Multiplier of multiply packed greater than 7X
                bytes or not less than the multiplicand length.'
         DC    CL(PICDESC)'Branch to an odd address by loading non-aligX
               ned label address on assembler generated slack byte.'
         DC    CL(PICDESC)'AMODE64 without BASSM/BSM, branched to progrX
               am in another Amode without removing 64-bit indicator.'
PIC$L006 EQU   *-PIC$D006          Length of the PIC Message Text Area
PIC$D007 DC    CL(PICDESC)'Attempt to execute decimal instruction on daX
               ta not in signed-packed-decimal format.'
         DC    CL(PICDESC)'Attempt to execute decimal instruction on paX
               cked data not aligned on rightmost byte in field.'
         DC    CL(PICDESC)'Multiplicand in MP did not have at least as X
               many leftmost zeros as the no. of bytes in multiplier.'
         DC    CL(PICDESC)'Previous PACK used invalid zoned data or useX
               d wrong data area causing invalid packed data field.'
         DC    CL(PICDESC)'The sign or digit code of data used in packeX
               d decimal, edit, or CVB instruction was invalid.'
         DC    CL(PICDESC)'Base register had incorrect address or a stoX
               rage area with expected packed data was overlaid.'
         DC    CL(PICDESC)'Pack field had an invalid digit not 0-9, or X
               last byte had invalid sign (not A, B, C, D, E, or F).'
PIC$L007 EQU   *-PIC$D007          Length of the PIC Message Text Area
PIC$D008 DC    CL(PICDESC)'The receiving field of a signed binary integX
               er arithmetic operation was too small.'
PIC$L008 EQU   *-PIC$D008          Length of the PIC Message Text Area
PIC$D009 DC    CL(PICDESC)'Division of a binary integer by zero was attX
               empted.'
         DC    CL(PICDESC)'Dividend was so large and divisor sufficientX
               ly small the quotient could not fit in R1+1 register.'
         DC    CL(PICDESC)'Packed decimal no. in CVB/CVBG instruction wX
               hen converted to binary too large to fit in register.'
PIC$L009 EQU   *-PIC$D009          Length of the PIC Message Text Area
PIC$D00A DC    CL(PICDESC)'A decimal instruction result was too large fX
               or the receiving field.'
PIC$L00A EQU   *-PIC$D00A          Length of the PIC Message Text Area
PIC$D00B DC    CL(PICDESC)'An attempt was made to divide by zero in a dX
               ecimal divide instruction.'
         DC    CL(PICDESC)'A decimal divide instruction resulted in a qX
               uotient that would exceed the data field size.'
         DC    CL(PICDESC)'Quotient field not large enough to hold max X
               possible dividend divided by minimum possible divisor.'
PIC$L00B EQU   *-PIC$D00B          Length of the PIC Message Text Area
PIC$D00C DC    CL(PICDESC)'A floating-point instruction resulted in an X
               exponent that is too large.'
         DC    CL(PICDESC)'A very large number was multipled by or was X
               added to another very large number.'
         DC    CL(PICDESC)'A floating point input value or constant speX
               cified an incorrect decimal point or exponent value.'
PIC$L00C EQU   *-PIC$D00C          Length of the PIC Message Text Area
PIC$D00D DC    CL(PICDESC)'A floating-point instruction resulted in an X
               exponent that is too small.'
         DC    CL(PICDESC)'A very small number was divided by a very laX
               rge number.'
         DC    CL(PICDESC)'A very small number was multipled by a very X
               small number.'
         DC    CL(PICDESC)'A floating point input value or constant speX
               cified an incorrect decimal point or exponent value.'
PIC$L00D EQU   *-PIC$D00D          Length of the PIC Message Text Area
PIC$D00E DC    CL(PICDESC)'A floating-point operation yielded an all zeX
               ro fraction while the exponent was still non-zero.'
PIC$L00E EQU   *-PIC$D00E          Length of the PIC Message Text Area
PIC$D00F DC    CL(PICDESC)'An attempt was made to divide by zero in a fX
               oating point divide instruction.'
         DC    CL(PICDESC)'A divisor field with an absolute value of leX
               ss than .5 was rounded down to zero before division.'
PIC$L00F EQU   *-PIC$D00F          Length of the PIC Message Text Area
PIC$D010 DC    CL(PICDESC)'Note: For this abend the PSW points to the aX
               bending instruction and not the next instruction.'
         DC    CL(PICDESC)'An invalid address in instruction resulted iX
               n a reference to storage not allocated.'
         DC    CL(PICDESC)'A previously valid address in instruction reX
               ferenced get-main storage area already released.'
         DC    CL(PICDESC)'An address in instruction needed Amode-31 toX
                reference 31-bit storage when program was in Amode-24.'
         DC    CL(PICDESC)'An invalid length in instruction resulted inX
                a fetch or store to storage not in your address space.'
         DC    CL(PICDESC)'BCT count set incorrectly to not be positiveX
                results in loop being enforced on a negative count.'
         DC    CL(PICDESC)'An LA instead of L or vice versa resulted inX
                branch, base, or index register with invalid pointer.'
         DC    CL(PICDESC)'Program loop using bad index to reference daX
               ta eventually creeped into an unallocated storage area.'
         DC    CL(PICDESC)'You passed an invalid parameter list addressX
                to a called routine and routine encountered S0C4.'
         DC    CL(PICDESC)'Attempt was made to close a data set twice wX
               ithout an intervening open.'
         DC    CL(PICDESC)'Attempt was made to read or write to a data X
               set where the DCB was not opened.'
         DC    CL(PICDESC)'Attempt to close data set where DCB in get-mX
               ain area and DCB get-main area released before close.'
PIC$L010 EQU   *-PIC$D010          Length of the PIC Message Text Area
PIC$D011 DC    CL(PICDESC)'Note: For this abend the PSW points to the aX
               bending instruction and not the next instruction.'
         DC    CL(PICDESC)'An invalid address in instruction resulted iX
               n a reference to storage not get-mained.'
         DC    CL(PICDESC)'A previously valid address in instruction reX
               ferenced get-main storage area already released.'
         DC    CL(PICDESC)'An address in instruction needed Amode-31 toX
                reference 31-bit storage when program was in Amode-24.'
         DC    CL(PICDESC)'An invalid length in instruction resulted inX
                a fetch or store to storage not in your address space.'
         DC    CL(PICDESC)'BCT count set incorrectly to not be positiveX
                results in loop being enforced on a negative count.'
         DC    CL(PICDESC)'An LA instead of L or vice versa resulted inX
                branch, base, or index register with invalid pointer.'
         DC    CL(PICDESC)'Program loop using bad index to access storaX
               ge eventually referenced an area not get-mained.'
         DC    CL(PICDESC)'Program loop adding to address to access stoX
               rage eventually referenced an area not in your program.'
         DC    CL(PICDESC)'You passed an invalid parameter list addressX
                to a called routine and routine encountered S0C4.'
         DC    CL(PICDESC)'Attempt was made to close a data set twice wX
               ithout an intervening open.'
         DC    CL(PICDESC)'Attempt was made to read or write to a data X
               set where the DCB was not opened.'
         DC    CL(PICDESC)'Attempt to close data set where DCB in get-mX
               ain area and DCB get-main area released before close.'
         DC    CL(PICDESC)'You took a wild-branch to an invalid addressX
               , check for Breaking Event Address if one is available.'
PIC$L011 EQU   *-PIC$D011          Length of the PIC Message Text Area
PIC$D029 DC    CL(PICDESC)'Note: For this abend the PSW points to the aX
               bending instruction and not the next instruction.'
         DC    CL(PICDESC)'An ALET specified an access list entry (ALE)X
                that is not valid due to corrupted access registers.'
         DC    CL(PICDESC)'Access registers being utilized were not resX
               tored from a previous action leaving residual data.'
         DC    CL(PICDESC)'A base register did not have its correspondiX
               ng access-register zeroed out prior to entering AR mode.X
               '
         DC    CL(PICDESC)'ALET was associated with a valid access-listX
                at one time but was deallocated before you used it.'
         DC    CL(PICDESC)'You were in access-register mode when you diX
               d not intend so because did not SAC back to proper mode.X
               '
PIC$L029 EQU   *-PIC$D029          Length of the PIC Message Text Area
PIC$D038 DC    CL(PICDESC)'Note: For this abend the PSW points to the aX
               bending instruction and not the next instruction.'
         DC    CL(PICDESC)'An invalid address in instruction resulted iX
               n reference to memory object not GETSTORed with IARV64.'
         DC    CL(PICDESC)'A 31-bit address with high order bit on was X
               used to reference storage area when running Amode64.'
         DC    CL(PICDESC)'Amode64 and 31-bit address was loaded into 6X
               4-bit register without clearing high-half of register.'
PIC$L038 EQU   *-PIC$D038          Length of the PIC Message Text Area
PIC$D039 DC    CL(PICDESC)'Note: For this abend the PSW points to the aX
               bending instruction and not the next instruction.'
         DC    CL(PICDESC)'An invalid address in instruction resulted iX
               n reference to memory object not GETSTORed with IARV64.'
         DC    CL(PICDESC)'A 31-bit address with high order bit on was X
               used to reference storage area when running Amode64.'
         DC    CL(PICDESC)'Amode64 and 31-bit address was loaded into 6X
               4-bit register without clearing high-half of register.'
         DC    CL(PICDESC)'Amode31 on program entry, switched to Amode6X
               4, and did not switch back to Amode31 before exiting.'
PIC$L039 EQU   *-PIC$D039          Length of the PIC Message Text Area
PIC$D03A DC    CL(PICDESC)'Note: For this abend the PSW points to the aX
               bending instruction and not the next instruction.'
         DC    CL(PICDESC)'An invalid address in instruction resulted iX
               n reference to memory object not GETSTORed with IARV64.'
         DC    CL(PICDESC)'A 31-bit address with high order bit on was X
               used to reference storage area when running Amode64.'
         DC    CL(PICDESC)'Amode64 and 31-bit address was loaded into 6X
               4-bit register without clearing high-half of register.'
         DC    CL(PICDESC)'Amode31 on program entry, switched to Amode6X
               4, and did not switch back to Amode31 before exiting.'
PIC$L03A EQU   *-PIC$D03A          Length of the PIC Message Text Area
PIC$D03B DC    CL(PICDESC)'Note: For this abend the PSW points to the aX
               bending instruction and not the next instruction.'
         DC    CL(PICDESC)'An invalid address in instruction resulted iX
               n reference to memory object not GETSTORed with IARV64.'
         DC    CL(PICDESC)'A 31-bit address with high order bit on was X
               used to reference storage area when running Amode64.'
         DC    CL(PICDESC)'Amode64 and 31-bit address was loaded into 6X
               4-bit register without clearing high-half of register.'
         DC    CL(PICDESC)'Amode31 on program entry, switched to Amode6X
               4, and did not switch back to Amode31 before exiting.'
PIC$L03B EQU   *-PIC$D03B          Length of the PIC Message Text Area
PID@DLEN EQU   *-PIC$DESC          Length of the Keyword Values Area
*
***********************************************************************
*+-------------------------------------------------------------------+*
*|        zArchitecture Machine Instruction Description Table        |*
*+-------------------------------------------------------------------+*
***********************************************************************
*
         DS    0D                  Set For Doubleword Alignment
OPC$ZARC RSECT                     Program Read-Only Control Section
OPC$ZARC AMODE &AMODE              Establish Addressing Mode
OPC$ZARC RMODE &RMODE              Establish Residence Mode
OPC$0101 DC    AL2(X'0101'),Y(X'0000'),XL2'0000',Y(X'0202'),AD(00000000X
               ),CL(L'OP@MNEUM)'PR',CL(L'OP@TYPE)'E',CL(L'OP@FORMT)'Op_X
               Code',CL(L'OP@ATTR)'qn  ',CL(L'OP@DESCR)'Program Return'
OPC$0102 DC    AL2(X'0102'),Y(X'0080'),XL2'0000',Y(X'0202'),AD(00000000X
               ),CL(L'OP@MNEUM)'UPT',CL(L'OP@TYPE)'E',CL(L'OP@FORMT)'OpX
               _Code',CL(L'OP@ATTR)'ic  ',CL(L'OP@DESCR)'Update Tree'
OPC$0104 DC    AL2(X'0104'),Y(X'0000'),XL2'0000',Y(X'0202'),AD(00000000X
               ),CL(L'OP@MNEUM)'PTFF',CL(L'OP@TYPE)'E',CL(L'OP@FORMT)'OX
               p_Code',CL(L'OP@ATTR)'qc  ',CL(L'OP@DESCR)'Perform TiminX
               g-Facility Function'
OPC$0107 DC    AL2(X'0107'),Y(X'0000'),XL2'0000',Y(X'0202'),AD(00000000X
               ),CL(L'OP@MNEUM)'SCKPF',CL(L'OP@TYPE)'E',CL(L'OP@FORMT)'X
               Op_Code',CL(L'OP@ATTR)'p   ',CL(L'OP@DESCR)'Set Clock PrX
               ogrammable Field'
OPC$010A DC    AL2(X'010A'),Y(X'0000'),XL2'0000',Y(X'0202'),AD(00000000X
               ),CL(L'OP@MNEUM)'PFPO',CL(L'OP@TYPE)'E',CL(L'OP@FORMT)'OX
               p_Code',CL(L'OP@ATTR)'  PF',CL(L'OP@DESCR)'Perform FloatX
               ing-Point Operation'
OPC$010B DC    AL2(X'010B'),Y(X'0000'),XL2'0000',Y(X'0202'),AD(00000000X
               ),CL(L'OP@MNEUM)'TAM',CL(L'OP@TYPE)'E',CL(L'OP@FORMT)'OpX
               _Code',CL(L'OP@ATTR)'c N3',CL(L'OP@DESCR)'Test AddressinX
               g Mode'
OPC$010C DC    AL2(X'010C'),Y(X'0000'),XL2'0000',Y(X'0202'),AD(00000000X
               ),CL(L'OP@MNEUM)'SAM24',CL(L'OP@TYPE)'E',CL(L'OP@FORMT)'X
               Op_Code',CL(L'OP@ATTR)'  N3',CL(L'OP@DESCR)'Set AddressiX
               ng Mode 24-bit'
OPC$010D DC    AL2(X'010D'),Y(X'0000'),XL2'0000',Y(X'0202'),AD(00000000X
               ),CL(L'OP@MNEUM)'SAM31',CL(L'OP@TYPE)'E',CL(L'OP@FORMT)'X
               Op_Code',CL(L'OP@ATTR)'  N3',CL(L'OP@DESCR)'Set AddressiX
               ng Mode 31-bit'
OPC$010E DC    AL2(X'010E'),Y(X'0000'),XL2'0000',Y(X'0202'),AD(00000000X
               ),CL(L'OP@MNEUM)'SAM64',CL(L'OP@TYPE)'E',CL(L'OP@FORMT)'X
               Op_Code',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'Set AddressiX
               ng Mode 64-bit'
OPC$01FF DC    AL2(X'01FF'),Y(X'0000'),XL2'0000',Y(X'0202'),AD(00000000X
               ),CL(L'OP@MNEUM)'TRAP2',CL(L'OP@TYPE)'E',CL(L'OP@FORMT)'X
               Op_Code',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Trap'
OPC$04   DC    AL2(X'0400'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'SPM',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'RX
               1',CL(L'OP@ATTR)'n   ',CL(L'OP@DESCR)'Set Program Mask'
OPC$05   DC    AL2(X'0500'),Y(X'0080'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'BALR',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Branch and LinX
               k Register'
OPC$06   DC    AL2(X'0600'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'BCTR',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Branch on CounX
               t Register (32)'
OPC$07   DC    AL2(X'0700'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'BCR',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'MX
               1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Branch on CondiX
               tion'
OPC$0A   DC    AL2(X'0A00'),Y(X'0000'),XL2'0000',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'SVC',CL(L'OP@TYPE)'I',CL(L'OP@FORMT)'SVX
               C nn',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Supervisor CallX
               '
OPC$0B   DC    AL2(X'0B00'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'BSM',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'RX
               1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Branch and Set X
               Mode'
OPC$0C   DC    AL2(X'0C00'),Y(X'0080'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'BASSM',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Branch and SaX
               ve and Set Mode'
OPC$0D   DC    AL2(X'0D00'),Y(X'0080'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'BASR',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Branch and SavX
               e'
OPC$0E   DC    AL2(X'0E00'),Y(X'0080'),XL2'0406',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'MVCL',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'ic  ',CL(L'OP@DESCR)'Move CharacterX
                Long'
OPC$0F   DC    AL2(X'0F00'),Y(X'0080'),XL2'0406',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLCL',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Compare LogicaX
               l Character Long'
OPC$10   DC    AL2(X'1000'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'LPR',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'RX
               1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Load Positive RX
               egister (32)'
OPC$11   DC    AL2(X'1100'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'LNR',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'RX
               1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Load Negative RX
               egister (32)'
OPC$12   DC    AL2(X'1200'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'LTR',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'RX
               1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Load and Test RX
               egister (32)'
OPC$13   DC    AL2(X'1300'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'LCR',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'RX
               1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Load ComplementX
                Register (32)'
OPC$14   DC    AL2(X'1400'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'NR',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'R1X
               ,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'And Register (32X
               )'
OPC$15   DC    AL2(X'1500'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLR',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'RX
               1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Compare LogicalX
                Register (32)'
OPC$16   DC    AL2(X'1600'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'OR',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'R1X
               ,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Or Register (32)X
               '
OPC$17   DC    AL2(X'1700'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'XR',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'R1X
               ,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Exclusive Or RegX
               ister (32)'
OPC$18   DC    AL2(X'1800'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'LR',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'R1X
               ,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Load Register (3X
               2)'
OPC$19   DC    AL2(X'1900'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'CR',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'R1X
               ,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Compare RegisterX
                (32)'
OPC$1A   DC    AL2(X'1A00'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'AR',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'R1X
               ,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Add Register (32X
               )'
OPC$1B   DC    AL2(X'1B00'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'SR',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'R1X
               ,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Subtract RegisteX
               r (32)'
OPC$1C   DC    AL2(X'1C00'),Y(X'0000'),XL2'0106',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'MR',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'R1X
               ,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Multiply RegisteX
               r (64<-32)'
OPC$1D   DC    AL2(X'1D00'),Y(X'0000'),XL2'0106',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'DR',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'R1X
               ,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Divide Register X
               (32<-64)'
OPC$1E   DC    AL2(X'1E00'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'ALR',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'RX
               1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Add Logical RegX
               ister (32)'
OPC$1F   DC    AL2(X'1F00'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'SLR',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'RX
               1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Subtract LogicaX
               l Register (32)'
OPC$20   DC    AL2(X'2000'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'LPDR',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Load Positive X
               Long Hexidecimal Floating Point Register'
OPC$21   DC    AL2(X'2100'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'LNDR',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Load Negative X
               Long Hexidecimal Floating Point Register'
OPC$22   DC    AL2(X'2200'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'LTDR',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Load and Test X
               Long Hexidecimal Floating Point Register'
OPC$23   DC    AL2(X'2300'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'LCDR',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Load ComplemenX
               t Long Hexidecimal Floating Point Register'
OPC$24   DC    AL2(X'2400'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'HDR',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'RX
               1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Halve Long HexiX
               decimal Floating Point Register'
OPC$25   DC    AL2(X'2500'),Y(X'0000'),XL2'0406',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'LDXR',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Load Rounded EX
               xtended Hex Floating Point Register to Long HFP RegisterX
               '
OPC@25   DC    AL2(X'2500'),Y(X'0000'),XL2'0406',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'LRDR',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Load Rounded EX
               xtended Hex Floating Point Register to Long HFP RegisterX
               '
OPC$26   DC    AL2(X'2600'),Y(X'0000'),XL2'2006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'MXR',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'RX
               1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Multiply ExtendX
               ed Hexadecimal Floating Point Regsiter'
OPC$27   DC    AL2(X'2700'),Y(X'0000'),XL2'8006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'MXDR',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Multiply Long X
               Hexidecimal Floating Point Register to Extended HFP RegiX
               ster'
OPC$28   DC    AL2(X'2800'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'LDR',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'RX
               1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Load Long HexidX
               ecimal Floating-Point Register'
OPC$29   DC    AL2(X'2900'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'CDR',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'RX
               1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Compare Long HeX
               xidecimal Floating Point Register'
OPC$2A   DC    AL2(X'2A00'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'ADR',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'RX
               1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Add Normalized X
               Long Hexidecimal Floating Point Register'
OPC$2B   DC    AL2(X'2B00'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'SDR',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'RX
               1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Subtract NormalX
               ized Long Hexidecimal Floating Point Register'
OPC$2C   DC    AL2(X'2C00'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'MDR',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'RX
               1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Multiply Long HX
               exidecimal Floating Point Register'
OPC$2D   DC    AL2(X'2D00'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'DDR',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'RX
               1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Divide Long HexX
               idecimal Floating Point Register)'
OPC$2E   DC    AL2(X'2E00'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'AWR',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'RX
               1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Add UnnormalizeX
               d Long Hexidecimal Floating Point Register'
OPC$2F   DC    AL2(X'2F00'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'SWR',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'RX
               1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Subtract UnnormX
               alized Long Hexidecimal Floating Point Register'
OPC$30   DC    AL2(X'3000'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'LPER',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Load Positive X
               Short Hexidecimal (Short Hexidecimal Floating Point)'
OPC$31   DC    AL2(X'3100'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'LNER',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Load Negative X
               Short Hexidecimal Floating Point Register'
OPC$32   DC    AL2(X'3200'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'LTER',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Load and Test X
               Short Hexidecimal Floating Point Register'
OPC$33   DC    AL2(X'3300'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'LCER',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Load ComplemenX
               t Short Hexidecimal Floating Point Register'
OPC$34   DC    AL2(X'3400'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'HER',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'RX
               1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Halve Short HexX
               idecimal Floating Point Register'
OPC$35   DC    AL2(X'3500'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'LRER',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Load Rounded LX
               ong Hex Floating Point Register to Short HFP Register'
OPC@35   DC    AL2(X'3500'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'LEDR',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Load Rounded LX
               ong Hex Floating Point Register to Short HFP Register'
OPC$36   DC    AL2(X'3600'),Y(X'0000'),XL2'2006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'AXR',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'RX
               1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Add Normalized X
               Extended Hexidecimal Floating Point Register'
OPC$37   DC    AL2(X'3700'),Y(X'0000'),XL2'2006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'SXR',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'RX
               1,D2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Subtract NormalX
               ized Extended Hexadecimal Floating Point Register'
OPC$38   DC    AL2(X'3800'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'LER',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'RX
               1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Load Short HexiX
               decimal Floating Point Register'
OPC$39   DC    AL2(X'3900'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'CER',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'RX
               1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Compare Short HX
               exidecimal Floating Point Register'
OPC$3A   DC    AL2(X'3A00'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'AER',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'RX
               1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Add Normalized X
               Short Hexidecimal Floating Point Register'
OPC$3B   DC    AL2(X'3B00'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'SER',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'RX
               1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Subtract NormalX
               ized Short Hexidecimal Floating Point Register'
OPC$3C   DC    AL2(X'3C00'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'MDER',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Multiply ShortX
                Hexidecimal Floating Register to Long HFP Register'
OPC@3C   DC    AL2(X'3C00'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'MER',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'RX
               1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Multiply Short X
                Hexidecimal Floating Register to Long HFP Register'
OPC$3D   DC    AL2(X'3D00'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'DER',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'RX
               1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Divide Short HeX
               xidecimal Floating Point Register'
OPC$3E   DC    AL2(X'3E00'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'AUR',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'RX
               1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Add UnnormalizeX
               d Short Hexidecimal Floating Point Register'
OPC$3F   DC    AL2(X'3F00'),Y(X'0000'),XL2'0006',Y(X'0201'),AD(00000000X
               ),CL(L'OP@MNEUM)'SUR',CL(L'OP@TYPE)'RR',CL(L'OP@FORMT)'RX
               1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Subtract UnnormX
               alized Short Hexidecimal Floating Point Register'
OPC$40   DC    AL2(X'4000'),Y(X'0000'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'STH',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)X
               'R1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Store X
               Halfword'
OPC$41   DC    AL2(X'4100'),Y(X'0080'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'LA',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Load AdX
               dress'
OPC$42   DC    AL2(X'4200'),Y(X'0000'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'STC',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)X
               'R1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Store X
               Character'
OPC$43   DC    AL2(X'4300'),Y(X'0000'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'IC',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Insert X
               Character'
OPC$44   DC    AL2(X'4400'),Y(X'0000'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'EX',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'ExecuteX
               '
OPC$45   DC    AL2(X'4500'),Y(X'0080'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'BAL',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)X
               'R1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'BranchX
                and Link'
OPC$46   DC    AL2(X'4600'),Y(X'0000'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'BCT',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)X
               'R1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'BranchX
                on Count (32)'
OPC$47   DC    AL2(X'4700'),Y(X'0000'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'BC',CL(L'OP@TYPE)'RX-b',CL(L'OP@FORMT)'X
               M1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Branch X
               on Condition'
OPC$48   DC    AL2(X'4800'),Y(X'0000'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'LH',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Load HaX
               lf word (32<-16)'
OPC$49   DC    AL2(X'4900'),Y(X'0000'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'CH',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'CompareX
                Halfword (32<-16)'
OPC$4A   DC    AL2(X'4A00'),Y(X'0000'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'AH',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Add HalX
               fword (32<-16)'
OPC$4B   DC    AL2(X'4B00'),Y(X'0000'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'SH',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'SubtracX
               t Halfword (32<-16)'
OPC$4C   DC    AL2(X'4C00'),Y(X'0000'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'MH',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'MultiplX
               y Halfword (32<-16)'
OPC$4D   DC    AL2(X'4D00'),Y(X'0080'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'BAS',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)X
               'R1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'BranchX
                and Save'
OPC$4E   DC    AL2(X'4E00'),Y(X'0000'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'CVD',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)X
               'R1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'ConverX
               t to Decimal (32)'
OPC$4F   DC    AL2(X'4F00'),Y(X'0000'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'CVB',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)X
               'R1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'ConverX
               t to Binary (32)'
OPC$50   DC    AL2(X'5000'),Y(X'0000'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'ST',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Store (X
               32)'
OPC$51   DC    AL2(X'5100'),Y(X'0080'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'LAE',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)X
               'R1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Load AX
               ddress Extended'
OPC$54   DC    AL2(X'5400'),Y(X'0000'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'N',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)'RX
               1,D2(X2,B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'And (32)X
               '
OPC$55   DC    AL2(X'5500'),Y(X'0000'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'CL',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'CompareX
                Logical (32)'
OPC$56   DC    AL2(X'5600'),Y(X'0000'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'O',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)'RX
               1,D2(X2,B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Or (32)'
OPC$57   DC    AL2(X'5700'),Y(X'0000'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'X',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)'RX
               1,D2(X2,B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'ExclusivX
               e Or (32)'
OPC$58   DC    AL2(X'5800'),Y(X'0000'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'L',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)'RX
               1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Load (32X
               )'
OPC$59   DC    AL2(X'5900'),Y(X'0000'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'C',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)'RX
               1,D2(X2,B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Compare X
               (32)'
OPC$5A   DC    AL2(X'5A00'),Y(X'0000'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'A',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)'RX
               1,D2(X2,B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Add (32)X
               '
OPC$5B   DC    AL2(X'5B00'),Y(X'0000'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'S',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)'RX
               1,D2(X2,B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'SubtractX
                (32)'
OPC$5C   DC    AL2(X'5C00'),Y(X'0000'),XL2'0110',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'M',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)'RX
               1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'MultiplyX
                (64<-32)'
OPC$5D   DC    AL2(X'5D00'),Y(X'0000'),XL2'0110',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'D',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)'RX
               1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Divide (X
               32<-64)'
OPC$5E   DC    AL2(X'5E00'),Y(X'0000'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'AL',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Add LogX
               ical (32)'
OPC$5F   DC    AL2(X'5F00'),Y(X'0000'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'SL',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'SubtracX
               t Logical (32)'
OPC$60   DC    AL2(X'6000'),Y(X'0000'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'STD',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)X
               'R1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Store X
               (Long Floating-Point-Support)'
OPC$67   DC    AL2(X'6700'),Y(X'0000'),XL2'8010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'MXD',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)X
               'R1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'MultipX
               ly (Long HFP multiplier and multiplicand, extended HFP pX
               roduct)'
OPC$68   DC    AL2(X'6800'),Y(X'0000'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'LD',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Load LoX
               ng Hexidecimal Floating Point'
OPC$69   DC    AL2(X'6900'),Y(X'0000'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'CD',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'CompareX
                Long Hexidecimal Floating Point'
OPC$6A   DC    AL2(X'6A00'),Y(X'0000'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'AD',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Add NorX
               malized Long Hexidecimal Floating Point'
OPC$6B   DC    AL2(X'6B00'),Y(X'0000'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'SD',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'SubtracX
               t Normalized Long Hexidecimal Floating Point'
OPC$6C   DC    AL2(X'6C00'),Y(X'0000'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'MD',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'MultiplX
               y Long Hexidecimal Floating Point'
OPC$6D   DC    AL2(X'6D00'),Y(X'0000'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'DD',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Divide X
               Long Hexidecimal Floating Point'
OPC$6E   DC    AL2(X'6E00'),Y(X'0000'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'AW',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Add UnnX
               ormalized Long Hexidecimal Floating Point'
OPC$6F   DC    AL2(X'6F00'),Y(X'0000'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'SW',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'SubtracX
               t Unnormalized Long Hexidecimal Floating Point'
OPC$70   DC    AL2(X'7000'),Y(X'0000'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'STE',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)X
               'R1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Store X
               Short Hexidecimal Floating Point'
OPC$71   DC    AL2(X'7100'),Y(X'0000'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'MS',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'MultiplX
               y Single (32)'
OPC$78   DC    AL2(X'7800'),Y(X'0000'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'LE',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Load (SX
               hort Floating Point Support)'
OPC$79   DC    AL2(X'7900'),Y(X'0000'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'CE',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'CompareX
                Short Hexidecimal (Short Hexidecimal Floating Point)'
OPC$7A   DC    AL2(X'7A00'),Y(X'0000'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'AE',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Add NorX
               malized Short Hexidecimal Floating Point'
OPC$7B   DC    AL2(X'7B00'),Y(X'0000'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'SE',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'SubtracX
               t Normalized Short Hexidecimal Floating Point'
OPC@7C   DC    AL2(X'7C00'),Y(X'0000'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'MDE',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)X
               'R1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'MultipX
               ly Short Hexedecimal Floating Point to Long HFP Product'
OPC$7D   DC    AL2(X'7D00'),Y(X'0000'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'DE',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Divide X
               Short Hexidecimal Floating Point'
OPC$7E   DC    AL2(X'7E00'),Y(X'0000'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'AU',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Add UnnX
               ormalized Short Hexidecimal'
OPC$7F   DC    AL2(X'7F00'),Y(X'0000'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'SU',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'SubtracX
               t Unnormalized Short Hexidecimal'
OPC$80   DC    AL2(X'8000'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SSM',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'D2X
               (B2)',CL(L'OP@ATTR)'p   ',CL(L'OP@DESCR)'Set System MaskX
               '
OPC$82   DC    AL2(X'8200'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LPSW',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'DX
               2(B2)',CL(L'OP@ATTR)'pn  ',CL(L'OP@DESCR)'Load Program SX
               tatus Word'
OPC$84   DC    AL2(X'8400'),Y(X'0000'),XL2'0004',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'BRXH',CL(L'OP@TYPE)'RSI',CL(L'OP@FORMT)X
               'R1,R3,RI2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Branch ReX
               lative on Index High (32)'
OPC$85   DC    AL2(X'8500'),Y(X'0000'),XL2'0004',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'BRXLE',CL(L'OP@TYPE)'RSI',CL(L'OP@FORMTX
               )'R1,R3,RI2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Branch RX
               elative on Index Low or Equal (32)'
OPC$86   DC    AL2(X'8600'),Y(X'0000'),XL2'000D',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'BXH',CL(L'OP@TYPE)'RS-a',CL(L'OP@FORMT)X
               'R1,R3,D2(B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'BranchX
                on Index High'
OPC$87   DC    AL2(X'8700'),Y(X'0000'),XL2'000D',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'BXLE',CL(L'OP@TYPE)'RS-a',CL(L'OP@FORMTX
               )'R1,R3,D2(B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'BrancX
               h on Index Low or Equal'
OPC$88   DC    AL2(X'8800'),Y(X'0010'),XL2'000D',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'SRL',CL(L'OP@TYPE)'RS-a',CL(L'OP@FORMT)X
               'R1,D2(B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Shift RigX
               ht Single Logical (32)'
OPC$89   DC    AL2(X'8900'),Y(X'0010'),XL2'000D',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'SLL',CL(L'OP@TYPE)'RS-a',CL(L'OP@FORMT)X
               'R1,D2(B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Shift LefX
               t Single Logical (32)'
OPC$8A   DC    AL2(X'8A00'),Y(X'0010'),XL2'000D',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'SRA',CL(L'OP@TYPE)'RS-a',CL(L'OP@FORMT)X
               'R1,D2(B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Shift RigX
               ht Single Algebraic (32)'
OPC$8B   DC    AL2(X'8B00'),Y(X'0010'),XL2'000D',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'SLA',CL(L'OP@TYPE)'RS-a',CL(L'OP@FORMT)X
               'R1,D2(B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Shift LefX
               t Single Algebraic (32)'
OPC$8C   DC    AL2(X'8C00'),Y(X'0010'),XL2'010D',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'SRDL',CL(L'OP@TYPE)'RS-a',CL(L'OP@FORMTX
               )'R1,D2(B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Shift RiX
               ght Double Logical (64)'
OPC$8D   DC    AL2(X'8D00'),Y(X'0010'),XL2'010D',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'SLDL',CL(L'OP@TYPE)'RS-a',CL(L'OP@FORMTX
               )'R1,D2(B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Shift LeX
               ft Double Logical (64)'
OPC$8E   DC    AL2(X'8E00'),Y(X'0010'),XL2'010D',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'SRDA',CL(L'OP@TYPE)'RS-a',CL(L'OP@FORMTX
               )'R1,D2(B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Shift RiX
               ght Double Algebraic (64)'
OPC$8F   DC    AL2(X'8F00'),Y(X'0010'),XL2'010D',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'SLDA',CL(L'OP@TYPE)'RS-a',CL(L'OP@FORMTX
               )'R1,D2(B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Shift LeX
               ft Double Algebraic (64)'
OPC$90   DC    AL2(X'9000'),Y(X'0000'),XL2'000D',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'STM',CL(L'OP@TYPE)'RS-a',CL(L'OP@FORMT)X
               'R1,R3,D2(B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Store X
               Multiple (32)'
OPC$91   DC    AL2(X'9100'),Y(X'0000'),XL2'0016',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'TM',CL(L'OP@TYPE)'SI',CL(L'OP@FORMT)'D1X
               (B1),I2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Test under MX
               ask'
OPC$92   DC    AL2(X'9200'),Y(X'0000'),XL2'0016',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'MVI',CL(L'OP@TYPE)'SI',CL(L'OP@FORMT)'DX
               1(B1),I2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Move ImmediX
               ate'
OPC$93   DC    AL2(X'9300'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'TS',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'D2(X
               B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Test and Set'
OPC$94   DC    AL2(X'9400'),Y(X'0141'),XL2'0016',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'NI',CL(L'OP@TYPE)'SI',CL(L'OP@FORMT)'D1X
               (B1),I2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'And ImmediatX
               e'
OPC$95   DC    AL2(X'9500'),Y(X'0000'),XL2'0016',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLI',CL(L'OP@TYPE)'SI',CL(L'OP@FORMT)'DX
               1(B1),I2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Compare LogX
               ical Immediate'
OPC$96   DC    AL2(X'9600'),Y(X'0000'),XL2'0016',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'OI',CL(L'OP@TYPE)'SI',CL(L'OP@FORMT)'D1X
               (B1),I2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Or ImmediateX
               '
OPC$97   DC    AL2(X'9700'),Y(X'0000'),XL2'0016',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'XI',CL(L'OP@TYPE)'SI',CL(L'OP@FORMT)'D1X
               (B1),I2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Exclusive OrX
                Immediate'
OPC$98   DC    AL2(X'9800'),Y(X'0000'),XL2'000D',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'LM',CL(L'OP@TYPE)'RS-a',CL(L'OP@FORMT)'X
               R1,R3,D2(B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Load MuX
               ltiple (32)'
OPC$99   DC    AL2(X'9900'),Y(X'0000'),XL2'000D',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'TRACE',CL(L'OP@TYPE)'RS-a',CL(L'OP@FORMX
               T)'R1,R3,D2(B2)',CL(L'OP@ATTR)'p   ',CL(L'OP@DESCR)'TracX
               e (32)'
OPC$9A   DC    AL2(X'9A00'),Y(X'0000'),XL2'000D',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'LAM',CL(L'OP@TYPE)'RS-a',CL(L'OP@FORMT)X
               'R1,R3,D2(B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Load AX
               ccess Multiple'
OPC$9B   DC    AL2(X'9B00'),Y(X'0000'),XL2'000D',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'STAM',CL(L'OP@TYPE)'RS-a',CL(L'OP@FORMTX
               )'R1,R3,D2(B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'StoreX
                Access Multiple'
OPC$A50  DC    AL2(X'A500'),Y(X'0000'),XL2'0001',Y(X'0412'),AD(00000000X
               ),CL(L'OP@MNEUM)'IIHH',CL(L'OP@TYPE)'RI-a',CL(L'OP@FORMTX
               )'R1,I2',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'Insert ImmedX
               iate High High (Uses high halfword of high-order word)'
OPC$A51  DC    AL2(X'A510'),Y(X'0000'),XL2'0001',Y(X'0412'),AD(00000000X
               ),CL(L'OP@MNEUM)'IIHL',CL(L'OP@TYPE)'RI-a',CL(L'OP@FORMTX
               )'R1,I2',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'Insert ImmedX
               iate High Low (Uses low halfword of high-order word)'
OPC$A52  DC    AL2(X'A520'),Y(X'0000'),XL2'0001',Y(X'0412'),AD(00000000X
               ),CL(L'OP@MNEUM)'IILH',CL(L'OP@TYPE)'RI-a',CL(L'OP@FORMTX
               )'R1,I2',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'Insert ImmedX
               iate Low High (Uses high halfword of low-order word)'
OPC$A53  DC    AL2(X'A530'),Y(X'0000'),XL2'0001',Y(X'0412'),AD(00000000X
               ),CL(L'OP@MNEUM)'IILL',CL(L'OP@TYPE)'RI-a',CL(L'OP@FORMTX
               )'R1,I2',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'Insert ImmedX
               iate Low Low (Uses low halfword of low-order word)'
OPC$A54  DC    AL2(X'A540'),Y(X'0000'),XL2'0001',Y(X'0412'),AD(00000000X
               ),CL(L'OP@MNEUM)'NIHH',CL(L'OP@TYPE)'RI-a',CL(L'OP@FORMTX
               )'R1,I2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'And ImmediatX
               e High High (Uses high halfword of high-order word)'
OPC$A55  DC    AL2(X'A550'),Y(X'0000'),XL2'0001',Y(X'0412'),AD(00000000X
               ),CL(L'OP@MNEUM)'NIHL',CL(L'OP@TYPE)'RI-a',CL(L'OP@FORMTX
               )'R1,I2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'And ImmediatX
               e High Low (Uses low halfword of high-order word)'
OPC$A56  DC    AL2(X'A560'),Y(X'0000'),XL2'0001',Y(X'0412'),AD(00000000X
               ),CL(L'OP@MNEUM)'NILH',CL(L'OP@TYPE)'RI-a',CL(L'OP@FORMTX
               )'R1,I2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'And ImmediatX
               e Low High (Uses high halfword of low-order word)'
OPC$A57  DC    AL2(X'A570'),Y(X'0000'),XL2'0001',Y(X'0412'),AD(00000000X
               ),CL(L'OP@MNEUM)'NILL',CL(L'OP@TYPE)'RI-a',CL(L'OP@FORMTX
               )'R1,I2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'And ImmediatX
               e Low Low (Uses low halfword of low-order word)'
OPC$A58  DC    AL2(X'A580'),Y(X'0000'),XL2'0001',Y(X'0412'),AD(00000000X
               ),CL(L'OP@MNEUM)'OIHH',CL(L'OP@TYPE)'RI-a',CL(L'OP@FORMTX
               )'R1,I2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'Or ImmediateX
                High High (Uses high halfword of high-order word)'
OPC$A59  DC    AL2(X'A590'),Y(X'0000'),XL2'0001',Y(X'0412'),AD(00000000X
               ),CL(L'OP@MNEUM)'OIHL',CL(L'OP@TYPE)'RI-a',CL(L'OP@FORMTX
               )'R1,I2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'Or ImmediateX
                High Low (Uses low halfword of high-order word)'
OPC$A5A  DC    AL2(X'A5A0'),Y(X'0000'),XL2'0001',Y(X'0412'),AD(00000000X
               ),CL(L'OP@MNEUM)'OILH',CL(L'OP@TYPE)'RI-a',CL(L'OP@FORMTX
               )'R1,I2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'Or ImmediateX
                Low High (Uses high halfword of low-order word)'
OPC$A5B  DC    AL2(X'A5B0'),Y(X'0000'),XL2'0001',Y(X'0412'),AD(00000000X
               ),CL(L'OP@MNEUM)'OILL',CL(L'OP@TYPE)'RI-a',CL(L'OP@FORMTX
               )'R1,I2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'Or ImmediateX
                Low Low (Uses low halfword of low-order word)'
OPC$A5C  DC    AL2(X'A5C0'),Y(X'0000'),XL2'0001',Y(X'0412'),AD(00000000X
               ),CL(L'OP@MNEUM)'LLIHH',CL(L'OP@TYPE)'RI-a',CL(L'OP@FORMX
               T)'R1,I2',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'Load LogicaX
               l Immediate High High (Uses high halfword of high-order X
               word)'
OPC$A5D  DC    AL2(X'A5D0'),Y(X'0000'),XL2'0001',Y(X'0412'),AD(00000000X
               ),CL(L'OP@MNEUM)'LLIHL',CL(L'OP@TYPE)'RI-a',CL(L'OP@FORMX
               T)'R1,I2',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'Load LogicaX
               l Immediate High Low (Uses low halfword of high-order woX
               rd)'
OPC$A5E  DC    AL2(X'A5E0'),Y(X'0000'),XL2'0001',Y(X'0412'),AD(00000000X
               ),CL(L'OP@MNEUM)'LLILH',CL(L'OP@TYPE)'RI-a',CL(L'OP@FORMX
               T)'R1,I2',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'Load LogicaX
               l Immediate Low High (Uses high halfword of low-order woX
               rd)'
OPC$A5F  DC    AL2(X'A5F0'),Y(X'0000'),XL2'0001',Y(X'0412'),AD(00000000X
               ),CL(L'OP@MNEUM)'LLILL',CL(L'OP@TYPE)'RI-a',CL(L'OP@FORMX
               T)'R1,I2',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'Load LogicaX
               l Immediate Low Low (Uses low halfword of low-order wordX
               )'
OPC@A70  DC    AL2(X'A700'),Y(X'0000'),XL2'0001',Y(X'0412'),AD(00000000X
               ),CL(L'OP@MNEUM)'TMLH',CL(L'OP@TYPE)'RI-a',CL(L'OP@FORMTX
               )'R1,I2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'Test under MX
               ask Low High (Uses high halfword of low-order word)'
OPC$A70  DC    AL2(X'A700'),Y(X'0000'),XL2'0001',Y(X'0412'),AD(00000000X
               ),CL(L'OP@MNEUM)'TMH',CL(L'OP@TYPE)'RI-a',CL(L'OP@FORMT)X
               'R1,I2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Test under MaX
               sk High'
OPC@A71  DC    AL2(X'A710'),Y(X'0000'),XL2'0001',Y(X'0412'),AD(00000000X
               ),CL(L'OP@MNEUM)'TMLL',CL(L'OP@TYPE)'RI-a',CL(L'OP@FORMTX
               )'R1,I2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'Test under MX
               ask Low Low (Uses low halfword of low-order word)'
OPC$A71  DC    AL2(X'A710'),Y(X'0000'),XL2'0001',Y(X'0412'),AD(00000000X
               ),CL(L'OP@MNEUM)'TML',CL(L'OP@TYPE)'RI-a',CL(L'OP@FORMT)X
               'R1,I2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Test under MaX
               sk Low'
OPC$A72  DC    AL2(X'A720'),Y(X'0000'),XL2'0001',Y(X'0412'),AD(00000000X
               ),CL(L'OP@MNEUM)'TMHH',CL(L'OP@TYPE)'RI-a',CL(L'OP@FORMTX
               )'R1,I2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'Test under MX
               ask High High (Uses high halfword of high-order word)'
OPC$A73  DC    AL2(X'A730'),Y(X'0000'),XL2'0001',Y(X'0412'),AD(00000000X
               ),CL(L'OP@MNEUM)'TMHL',CL(L'OP@TYPE)'RI-a',CL(L'OP@FORMTX
               )'R1,I2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'Test under MX
               ask High Low (Uses low halfword of high-order word)'
OPC$A74  DC    AL2(X'A740'),Y(X'0000'),XL2'0000',Y(X'0412'),AD(00000000X
               ),CL(L'OP@MNEUM)'BRC',CL(L'OP@TYPE)'RI-c',CL(L'OP@FORMT)X
               'M1,RI2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Branch RelatX
               ive on Condition'
OPC$A75  DC    AL2(X'A750'),Y(X'0080'),XL2'0001',Y(X'0412'),AD(00000000X
               ),CL(L'OP@MNEUM)'BRAS',CL(L'OP@TYPE)'RI-b',CL(L'OP@FORMTX
               )'R1,RI2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Branch RelaX
               tive and Save'
OPC$A76  DC    AL2(X'A760'),Y(X'0000'),XL2'0001',Y(X'0412'),AD(00000000X
               ),CL(L'OP@MNEUM)'BRCT',CL(L'OP@TYPE)'RI-b',CL(L'OP@FORMTX
               )'R1,RI2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Branch RelaX
               tive on Count (32)'
OPC$A77  DC    AL2(X'A770'),Y(X'0000'),XL2'0001',Y(X'0412'),AD(00000000X
               ),CL(L'OP@MNEUM)'BRCTG',CL(L'OP@TYPE)'RI-b',CL(L'OP@FORMX
               T)'R1,RI2',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'Branch RelX
               ative on Count Grande (64)'
OPC$A78  DC    AL2(X'A780'),Y(X'0000'),XL2'0001',Y(X'0412'),AD(00000000X
               ),CL(L'OP@MNEUM)'LHI',CL(L'OP@TYPE)'RI-a',CL(L'OP@FORMT)X
               'R1,I2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Load HalfwordX
                Immediate (32<-I16)'
OPC$A79  DC    AL2(X'A790'),Y(X'0000'),XL2'0001',Y(X'0412'),AD(00000000X
               ),CL(L'OP@MNEUM)'LGHI',CL(L'OP@TYPE)'RI-a',CL(L'OP@FORMTX
               )'R1,I2',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'Load Grande X
               Halfword Immediate (64<-I16)'
OPC$A7A  DC    AL2(X'A7A0'),Y(X'0000'),XL2'0001',Y(X'0412'),AD(00000000X
               ),CL(L'OP@MNEUM)'AHI',CL(L'OP@TYPE)'RI-a',CL(L'OP@FORMT)X
               'R1,I2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Add Halfword X
               Immediate (32<-I16)'
OPC$A7B  DC    AL2(X'A7B0'),Y(X'0000'),XL2'0001',Y(X'0412'),AD(00000000X
               ),CL(L'OP@MNEUM)'AGHI',CL(L'OP@TYPE)'RI-a',CL(L'OP@FORMTX
               )'R1,I2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'Add Grande HX
               alfword Immediate (64<-I16)'
OPC$A7C  DC    AL2(X'A7C0'),Y(X'0000'),XL2'0001',Y(X'0412'),AD(00000000X
               ),CL(L'OP@MNEUM)'MHI',CL(L'OP@TYPE)'RI-a',CL(L'OP@FORMT)X
               'R1,I2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Multiply HalfX
               word Immediate (32<-I16)'
OPC$A7D  DC    AL2(X'A7D0'),Y(X'0000'),XL2'0001',Y(X'0412'),AD(00000000X
               ),CL(L'OP@MNEUM)'MGHI',CL(L'OP@TYPE)'RI-a',CL(L'OP@FORMTX
               )'R1,I2',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'Multiply GraX
               nde Halfword Immediate (64<-I16)'
OPC$A7E  DC    AL2(X'A7E0'),Y(X'0000'),XL2'0001',Y(X'0412'),AD(00000000X
               ),CL(L'OP@MNEUM)'CHI',CL(L'OP@TYPE)'RI-a',CL(L'OP@FORMT)X
               'R1,I2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Compare HalfwX
               ord Immediate (32<-I16)'
OPC$A7F  DC    AL2(X'A7F0'),Y(X'0000'),XL2'0001',Y(X'0412'),AD(00000000X
               ),CL(L'OP@MNEUM)'CGHI',CL(L'OP@TYPE)'RI-a',CL(L'OP@FORMTX
               )'R1,I2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'Compare GranX
               de Halfword Immediate (64<-I16)'
OPC$A8   DC    AL2(X'A800'),Y(X'0080'),XL2'040D',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'MVCLE',CL(L'OP@TYPE)'RS-a',CL(L'OP@FORMX
               T)'R1,R3,D2(B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'MoveX
                Character Long Extended'
OPC$A9   DC    AL2(X'A900'),Y(X'0080'),XL2'040D',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLCLE',CL(L'OP@TYPE)'RS-a',CL(L'OP@FORMX
               T)'R1,R3,D2(B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'CompX
               are Logical Character Long Extended'
OPC$AC   DC    AL2(X'AC00'),Y(X'0000'),XL2'0016',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'STNSM',CL(L'OP@TYPE)'SI',CL(L'OP@FORMT)X
               'D1(B1),I2',CL(L'OP@ATTR)'p   ',CL(L'OP@DESCR)'Store TheX
               n And System Mask'
OPC$AD   DC    AL2(X'AD00'),Y(X'0000'),XL2'0016',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'STOSM',CL(L'OP@TYPE)'SI',CL(L'OP@FORMT)X
               'D1(B1),I2',CL(L'OP@ATTR)'p   ',CL(L'OP@DESCR)'Store TheX
               n Or System Mask'
OPC$AE   DC    AL2(X'AE00'),Y(X'0000'),XL2'000D',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'SIGP',CL(L'OP@TYPE)'RS-a',CL(L'OP@FORMTX
               )'R1,R3,D2(B2)',CL(L'OP@ATTR)'pc  ',CL(L'OP@DESCR)'SignaX
               l Processor'
OPC$AF   DC    AL2(X'AF00'),Y(X'0000'),XL2'0016',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'MC',CL(L'OP@TYPE)'SI',CL(L'OP@FORMT)'D1X
               (B1),I2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Monitor CallX
               '
OPC$B1   DC    AL2(X'B100'),Y(X'0000'),XL2'0010',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'LRA',CL(L'OP@TYPE)'RX-a',CL(L'OP@FORMT)X
               'R1,D2(X2,B2)',CL(L'OP@ATTR)'pc  ',CL(L'OP@DESCR)'Load RX
               eal Address (32)'
OPC$B202 DC    AL2(X'B202'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'STIDP',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'X
               D2(B2)',CL(L'OP@ATTR)'p   ',CL(L'OP@DESCR)'Store CPU ID'
OPC$B204 DC    AL2(X'B204'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SCK',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'D2X
               (B2)',CL(L'OP@ATTR)'pc  ',CL(L'OP@DESCR)'Set Clock'
OPC$B205 DC    AL2(X'B205'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'STCK',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'DX
               2(B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Store Clock'
OPC$B206 DC    AL2(X'B206'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SCKC',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'DX
               2(B2)',CL(L'OP@ATTR)'p   ',CL(L'OP@DESCR)'Set Clock CompX
               arator'
OPC$B207 DC    AL2(X'B207'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'STCKC',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'X
               D2(B2)',CL(L'OP@ATTR)'p   ',CL(L'OP@DESCR)'Store Clock CX
               omparator'
OPC$B208 DC    AL2(X'B208'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SPT',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'D2X
               (B2)',CL(L'OP@ATTR)'p   ',CL(L'OP@DESCR)'Set CPU Timer'
OPC$B209 DC    AL2(X'B209'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'STPT',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'DX
               2(B2)',CL(L'OP@ATTR)'p   ',CL(L'OP@DESCR)'Store CPU TimeX
               r'
OPC$B20A DC    AL2(X'B20A'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SPKA',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'DX
               2(B2)',CL(L'OP@ATTR)'q   ',CL(L'OP@DESCR)'Set Program StX
               atus Word Key from Address'
OPC$B20B DC    AL2(X'B20B'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'IPK',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'OpX
               _Code',CL(L'OP@ATTR)'q   ',CL(L'OP@DESCR)'Insert PSW KeyX
               '
OPC$B20D DC    AL2(X'B20D'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'PTLB',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'OX
               p_Code',CL(L'OP@ATTR)'p   ',CL(L'OP@DESCR)'Purge TranslaX
               tion Lookaside Buffer (TLB)'
OPC$B210 DC    AL2(X'B210'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SPX',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'D2X
               (B2)',CL(L'OP@ATTR)'p   ',CL(L'OP@DESCR)'Set Prefix'
OPC$B211 DC    AL2(X'B211'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'STPX',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'DX
               2(B2)',CL(L'OP@ATTR)'p   ',CL(L'OP@DESCR)'Store Prefix'
OPC$B212 DC    AL2(X'B212'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'STAP',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'DX
               2(B2)',CL(L'OP@ATTR)'p   ',CL(L'OP@DESCR)'Store CPU AddrX
               ess'
OPC$B214 DC    AL2(X'B214'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SIE',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'D2X
               (B2)',CL(L'OP@ATTR)'ip  ',CL(L'OP@DESCR)'Start InterpretX
               ive Execution'
OPC$B218 DC    AL2(X'B218'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'PC',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'D2(X
               B2)',CL(L'OP@ATTR)'q   ',CL(L'OP@DESCR)'Program Call'
OPC$B219 DC    AL2(X'B219'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SAC',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'D2X
               (B2)',CL(L'OP@ATTR)'q   ',CL(L'OP@DESCR)'Set Address SpaX
               ce Control'
OPC$B21A DC    AL2(X'B21A'),Y(X'0080'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CFC',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'D2X
               (B2)',CL(L'OP@ATTR)'ic  ',CL(L'OP@DESCR)'Compare and ForX
               m Codeword'
OPC$B221 DC    AL2(X'B221'),Y(X'0000'),XL2'0009',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'IPTE',CL(L'OP@TYPE)'RRF-a',CL(L'OP@FORMX
               T)'R1,R2,R3',CL(L'OP@ATTR)'p   ',CL(L'OP@DESCR)'InvaliX
               date Page Table Entry'
OPC$B222 DC    AL2(X'B222'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'IPM',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)'X
               R1',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Insert Program MaX
               sk'
OPC$B223 DC    AL2(X'B223'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'IVSK',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'q   ',CL(L'OP@DESCR)'Insert VirtuaX
               l Storage Key'
OPC$B224 DC    AL2(X'B224'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'IAC',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)'X
               R1',CL(L'OP@ATTR)'qc  ',CL(L'OP@DESCR)'Insert Address SpX
               ace Control'
OPC$B225 DC    AL2(X'B225'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SSAR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Set Secondary ASX
               N from Register'
OPC$B226 DC    AL2(X'B226'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'EPAR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1',CL(L'OP@ATTR)'q   ',CL(L'OP@DESCR)'Extract Primary X
               ASN to Register'
OPC$B227 DC    AL2(X'B227'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'ESAR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1',CL(L'OP@ATTR)'q   ',CL(L'OP@DESCR)'Extract SecondarX
               y ASN to Register'
OPC$B228 DC    AL2(X'B228'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'PT',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)'RX
               1,R2',CL(L'OP@ATTR)'q   ',CL(L'OP@DESCR)'Program TransfeX
               r'
OPC$B229 DC    AL2(X'B229'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'ISKE',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'p   ',CL(L'OP@DESCR)'Insert StoragX
               e Key Extended'
OPC$B22A DC    AL2(X'B22A'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'RRBE',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'pc  ',CL(L'OP@DESCR)'Reset ReferenX
               ce Bit Extended'
OPC$B22B DC    AL2(X'B22B'),Y(X'0040'),XL2'000A',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SSKE',CL(L'OP@TYPE)'RRF-c',CL(L'OP@FORMX
               T)'R1,R2,M3',CL(L'OP@ATTR)'pc  ',CL(L'OP@DESCR)'Set StX
               orage Key Extended'
OPC$B22C DC    AL2(X'B22C'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'TB',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)'RX
               1,R2',CL(L'OP@ATTR)'pc  ',CL(L'OP@DESCR)'Test Block'
OPC$B22D DC    AL2(X'B22D'),Y(X'0000'),XL2'2008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'DXR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Divide ExtendeX
               d Hexadecimal Floating Point'
OPC$B22E DC    AL2(X'B22E'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'PGIN',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'pcES',CL(L'OP@DESCR)'Page In'
OPC$B22F DC    AL2(X'B22F'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'PGOUT',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'pcES',CL(L'OP@DESCR)'Page Out'
OPC$B230 DC    AL2(X'B230'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CSCH',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'OX
               p_Code',CL(L'OP@ATTR)'pc  ',CL(L'OP@DESCR)'Clear SubchanX
               nel'
OPC$B231 DC    AL2(X'B231'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'HSCH',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'OX
               p_Code',CL(L'OP@ATTR)'pc  ',CL(L'OP@DESCR)'Halt SubchannX
               el'
OPC$B232 DC    AL2(X'B232'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'MSCH',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'DX
               2(B2)',CL(L'OP@ATTR)'pc  ',CL(L'OP@DESCR)'Modify SubchanX
               nel'
OPC$B233 DC    AL2(X'B233'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SSCH',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'DX
               2(B2)',CL(L'OP@ATTR)'pc  ',CL(L'OP@DESCR)'Start SubchannX
               el'
OPC$B234 DC    AL2(X'B234'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'STSCH',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'X
               D2(B2)',CL(L'OP@ATTR)'pc  ',CL(L'OP@DESCR)'Store SubchanX
               nel'
OPC$B235 DC    AL2(X'B235'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'TSCH',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'DX
               2(B2)',CL(L'OP@ATTR)'pc  ',CL(L'OP@DESCR)'Test SubchanneX
               l'
OPC$B236 DC    AL2(X'B236'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'TPI',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'D2X
               (B2)',CL(L'OP@ATTR)'pc  ',CL(L'OP@DESCR)'Test Pending InX
               terruption'
OPC$B237 DC    AL2(X'B237'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SAL',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'OpX
               _Code',CL(L'OP@ATTR)'p   ',CL(L'OP@DESCR)'Set Address LiX
               mit'
OPC$B238 DC    AL2(X'B238'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'RSCH',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'OX
               p_Code',CL(L'OP@ATTR)'pc  ',CL(L'OP@DESCR)'Resume SubchaX
               nnel'
OPC$B239 DC    AL2(X'B239'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'STCRW',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'X
               D2(B2)',CL(L'OP@ATTR)'pc  ',CL(L'OP@DESCR)'Store ChannelX
                Report Word'
OPC$B23A DC    AL2(X'B23A'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'STCPS',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'X
               D2(B2)',CL(L'OP@ATTR)'p   ',CL(L'OP@DESCR)'Store ChannelX
                Path Status'
OPC$B23B DC    AL2(X'B23B'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'RCHP',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'OX
               p_Code',CL(L'OP@ATTR)'pc  ',CL(L'OP@DESCR)'Reset ChannelX
                Path'
OPC$B23C DC    AL2(X'B23C'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SCHM',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'OX
               p_Code',CL(L'OP@ATTR)'p   ',CL(L'OP@DESCR)'Set Channel MX
               onitor'
OPC$B240 DC    AL2(X'B240'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'BAKR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'q   ',CL(L'OP@DESCR)'Branch and StX
               ack'
OPC$B241 DC    AL2(X'B241'),Y(X'0080'),XL2'0208',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CKSM',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Checksum'
OPC$B244 DC    AL2(X'B244'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SQDR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Square Root LX
               ong Hexidecimal Floating Point'
OPC$B245 DC    AL2(X'B245'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SQER',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Square Root SX
               hort Hexidecimal Floating Point'
OPC$B246 DC    AL2(X'B246'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'STURA',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'p   ',CL(L'OP@DESCR)'Store Using X
               Real Address (32)'
OPC$B247 DC    AL2(X'B247'),Y(X'0000'),XL2'0108',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'MSTA',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Modify Stacked SX
               tate'
OPC$B248 DC    AL2(X'B248'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'PALB',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'Op_Code',CL(L'OP@ATTR)'p   ',CL(L'OP@DESCR)'Purge AccesX
               s-Register-Translation Lookaside Buffer (ALB)'
OPC$B249 DC    AL2(X'B249'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'EREG',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Extract StackX
               ed Registers (32)'
OPC$B24A DC    AL2(X'B24A'),Y(X'0000'),XL2'0108',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'ESTA',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Extract StackX
               ed State'
OPC$B24B DC    AL2(X'B24B'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LURA',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'p   ',CL(L'OP@DESCR)'Load Using ReX
               al Address (32)'
OPC$B24C DC    AL2(X'B24C'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'TAR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Test Access ReX
               gister'
OPC$B24D DC    AL2(X'B24D'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CPYA',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Copy Access'
OPC$B24E DC    AL2(X'B24E'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SAR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Set Access RegX
               ister'
OPC$B24F DC    AL2(X'B24F'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'EAR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Extract AccessX
                Register'
OPC$B250 DC    AL2(X'B250'),Y(X'0000'),XL2'0108',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CSP',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'pc  ',CL(L'OP@DESCR)'Compare and SwX
               ap and Purge (32)'
OPC$B252 DC    AL2(X'B252'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'MSR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Multiply SinglX
               e Register (32)'
OPC$B254 DC    AL2(X'B254'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'MVPG',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'qc  ',CL(L'OP@DESCR)'Move Page'
OPC$B255 DC    AL2(X'B255'),Y(X'0080'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'MVST',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Move String'
OPC$B257 DC    AL2(X'B257'),Y(X'0080'),XL2'0408',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CUSE',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'ic  ',CL(L'OP@DESCR)'Compare UntilX
                Substring Equal'
OPC$B258 DC    AL2(X'B258'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'BSG',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Branch in SubsX
               pace Group'
OPC$B25A DC    AL2(X'B25A'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'BSA',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'q   ',CL(L'OP@DESCR)'Branch and SetX
                Authority'
OPC$B25D DC    AL2(X'B25D'),Y(X'0080'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLST',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Compare LogicX
               al String'
OPC$B25E DC    AL2(X'B25E'),Y(X'0080'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SRST',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Search StringX
               '
OPC$B263 DC    AL2(X'B263'),Y(X'0080'),XL2'0408',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CMPSC',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'ic  ',CL(L'OP@DESCR)'Compression X
               Call'
OPC$B276 DC    AL2(X'B276'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'XSCH',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'OX
               p_Code',CL(L'OP@ATTR)'pc  ',CL(L'OP@DESCR)'Cancel SubchaX
               nnel'
OPC$B277 DC    AL2(X'B277'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'RP',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'D2(X
               B2)',CL(L'OP@ATTR)'qn  ',CL(L'OP@DESCR)'Resume Program'
OPC$B278 DC    AL2(X'B278'),Y(X'0261'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'STCKE',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'X
               D2(B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Store Clock EX
               xtended'
OPC$B279 DC    AL2(X'B279'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SACF',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'DX
               2(B2)',CL(L'OP@ATTR)'q   ',CL(L'OP@DESCR)'Set Address SpX
               ace Control Fast'
OPC$B27C DC    AL2(X'B27C'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'STCKF',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'X
               D2(B2)',CL(L'OP@ATTR)'c SC',CL(L'OP@DESCR)'Store Clock FX
               ast'
OPC$B27D DC    AL2(X'B27D'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'STSI',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'DX
               2(B2)',CL(L'OP@ATTR)'pc  ',CL(L'OP@DESCR)'Store System IX
               nformation'
OPC$B299 DC    AL2(X'B299'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SRNM',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'DX
               2(B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Set Binary FloX
               ating Point Rounding Mode'
OPC$B29C DC    AL2(X'B29C'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'STFPC',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'X
               D2(B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Store FloatinX
               g Point Control'
OPC$B29D DC    AL2(X'B29D'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LFPC',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'DX
               2(B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Load Floating X
               Point Control'
OPC$B2A5 DC    AL2(X'B2A5'),Y(X'0000'),XL2'0108',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'TRE',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Translate ExteX
               nded'
OPC$B2A6 DC    AL2(X'B2A6'),Y(X'00C0'),XL2'040A',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CUUTF',CL(L'OP@TYPE)'RRF-c',CL(L'OP@FORX
               MT)'R1,R2,M3',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'ConveX
               rt Unicode to UTF-8'
OPC@B2A6 DC    AL2(X'B2A6'),Y(X'00C0'),XL2'040A',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CU21',CL(L'OP@TYPE)'RRF-c',CL(L'OP@FORMX
               T)'R1,R2,M3',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'ConverX
               t UTF-16 to UTF-8'
OPC$B2A7 DC    AL2(X'B2A7'),Y(X'00C0'),XL2'040A',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CU12',CL(L'OP@TYPE)'RRF-c',CL(L'OP@FORMX
               T)'R1,R2,M3',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'ConverX
               t UTF-8 to UTF-16'
OPC@B2A7 DC    AL2(X'B2A7'),Y(X'00C0'),XL2'040A',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CUTFU',CL(L'OP@TYPE)'RRF-c',CL(L'OP@FORX
               MT)'R1,R2,M3',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'ConveX
               rt UTF-8 to Unicode'
OPC$B2B0 DC    AL2(X'B2B0'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'STFLE',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'X
               D2(B2)',CL(L'OP@ATTR)'c FL',CL(L'OP@DESCR)'Store FacilitX
               y List Extended'
OPC$B2B1 DC    AL2(X'B2B1'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'STFL',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'DX
               2(B2)',CL(L'OP@ATTR)'p N3',CL(L'OP@DESCR)'Store FacilityX
                List'
OPC$B2B2 DC    AL2(X'B2B2'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LPSWE',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'X
               D2(B2)',CL(L'OP@ATTR)'pnN ',CL(L'OP@DESCR)'Load Program X
               Status Word Extended'
OPC$B2B8 DC    AL2(X'B2B8'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SRNMB',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'X
               D2(B2)',CL(L'OP@ATTR)'  F ',CL(L'OP@DESCR)'Set Binary FlX
               oating Point Rounding Mode'
OPC$B2B9 DC    AL2(X'B2B9'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SRNMT',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'X
               D2(B2)',CL(L'OP@ATTR)'  TR',CL(L'OP@DESCR)'Set Decimal FX
               loating Point Rounding Mode'
OPC$B2BD DC    AL2(X'B2BD'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LFAS',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'DX
               2(B2)',CL(L'OP@ATTR)'  XF',CL(L'OP@DESCR)'Load Floating X
               Point Control and Signal'
OPC$B2BE DC    AL2(X'B2BE'),Y(X'0080'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SRSTU',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'c E3',CL(L'OP@DESCR)'Search StrinX
               g Unicode'
OPC$B2FF DC    AL2(X'B2FF'),Y(X'0000'),XL2'0014',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'TRAP4',CL(L'OP@TYPE)'S',CL(L'OP@FORMT)'X
               D2(B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Trap'
OPC$B300 DC    AL2(X'B300'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LPEBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Load PositivX
               e Short Binary Binary Floating Point Register'
OPC$B301 DC    AL2(X'B301'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LNEBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Load NegativX
               e Short Binary Binary Floating Point Register'
OPC$B302 DC    AL2(X'B302'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LTEBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Load and TesX
               t Short Binary Floating Point Register'
OPC$B303 DC    AL2(X'B303'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LCEBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Load ComplemX
               ent Short Binary Floating Point Register'
OPC$B304 DC    AL2(X'B304'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LDEBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Load LengtheX
               ned Short Binary Floating Point to Long BFP Register'
OPC$B305 DC    AL2(X'B305'),Y(X'0000'),XL2'8008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LXDBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Load LengtheX
               ned Long Binary Floating Point to Extended BFP Register'
OPC$B306 DC    AL2(X'B306'),Y(X'0000'),XL2'8008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LXEBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Load LengtheX
               ned Short Binary Floating Point to Extended BFP RegisterX
               '
OPC$B307 DC    AL2(X'B307'),Y(X'0000'),XL2'8008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'MXDBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Multiply LonX
               g Binary Floating Point to Extended BFP Register'
OPC$B308 DC    AL2(X'B308'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'KEBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Compare and SX
               ignal Short Binary Floating Point Register'
OPC$B309 DC    AL2(X'B309'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CEBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Compare ShortX
                Binary Floating Point Register'
OPC$B30A DC    AL2(X'B30A'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'AEBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Add Short BinX
               ary Floating Point Register'
OPC$B30B DC    AL2(X'B30B'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SEBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Subtract ShorX
               t Binary Floating Point Register'
OPC$B30C DC    AL2(X'B30C'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'MDEBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Multiply (ShX
               ort Binary Floating Point to Long BFP Register'
OPC$B30D DC    AL2(X'B30D'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'DEBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Divide Short X
               Binary Floating Point Register'
OPC$B30E DC    AL2(X'B30E'),Y(X'0000'),XL2'0007',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'MAEBR',CL(L'OP@TYPE)'RRD ',CL(L'OP@FORMX
               T)'R1,R3,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'MultiplyX
                and Add Short Binary Floating Point Register'
OPC$B30F DC    AL2(X'B30F'),Y(X'0000'),XL2'0007',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'MSEBR',CL(L'OP@TYPE)'RRD ',CL(L'OP@FORMX
               T)'R1,R3,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'MultiplyX
                and Subtract Short Binary Floating Point Register'
OPC$B310 DC    AL2(X'B310'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LPDBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Load PositivX
               e Long Binary Floating Point Register'
OPC$B311 DC    AL2(X'B311'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LNDBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Load NegativX
               e Long Binary Floating Point Register'
OPC$B312 DC    AL2(X'B312'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LTDBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Load and TesX
               t Long Binary Floating Point Register'
OPC$B313 DC    AL2(X'B313'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LCDBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Load ComplemX
               ent Long Binary Floating Point Register'
OPC$B314 DC    AL2(X'B314'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SQEBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Square Root X
               Short Binary Floating Point Register'
OPC$B315 DC    AL2(X'B315'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SQDBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Square Root X
               Long Binary Floating Point Register'
OPC$B316 DC    AL2(X'B316'),Y(X'0000'),XL2'2008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SQXBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Square Root X
               Extended Binary Floating Point Register'
OPC$B317 DC    AL2(X'B317'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'MEEBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Multiply ShoX
               rt Binary Floating Point Register'
OPC$B318 DC    AL2(X'B318'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'KDBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Compare and SX
               ignal Long Binary Floating Point Register'
OPC$B319 DC    AL2(X'B319'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CDBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Compare Long X
               Binary Floating Point Register'
OPC$B31A DC    AL2(X'B31A'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'ADBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Add Long BinaX
               ry Floating Point Register'
OPC$B31B DC    AL2(X'B31B'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SDBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Subtract LongX
                Binary Floating Point Register'
OPC$B31C DC    AL2(X'B31C'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'MDBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Multiply LongX
                Binary Floating Point Register'
OPC$B31D DC    AL2(X'B31D'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'DDBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Divide Long BX
               inary Floating Point Register'
OPC$B31E DC    AL2(X'B31E'),Y(X'0000'),XL2'0007',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'MADBR',CL(L'OP@TYPE)'RRD ',CL(L'OP@FORMX
               T)'R1,R3,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'MultiplyX
                and Add Long Binary Floating Point Register'
OPC$B31F DC    AL2(X'B31F'),Y(X'0000'),XL2'0007',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'MSDBR',CL(L'OP@TYPE)'RRD ',CL(L'OP@FORMX
               T)'R1,R3,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'MultiplyX
                and Subtract Long Binary Floating Point Register'
OPC$B324 DC    AL2(X'B324'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LDER',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Load LengthenX
               ed Short Hexidecimal Floating Point to Long HFP RegisterX
               '
OPC$B325 DC    AL2(X'B325'),Y(X'0000'),XL2'8008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LXDR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Load LengthenX
               ed Long Hexidecimal Floating Point to Extended HFP RegisX
               ter'
OPC$B326 DC    AL2(X'B326'),Y(X'0000'),XL2'8008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LXER',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Load LengthenX
               ed Short Hexidecimal Floating Point to Extended HFP RegiX
               ster'
OPC$B32E DC    AL2(X'B32E'),Y(X'0000'),XL2'0007',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'MAER',CL(L'OP@TYPE)'RRD ',CL(L'OP@FORMTX
               )'R1,R3,R2',CL(L'OP@ATTR)'  HM',CL(L'OP@DESCR)'Multiply X
               and Add Short Hexidecimal Floating Point Register'
OPC$B32F DC    AL2(X'B32F'),Y(X'0000'),XL2'0007',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'MSER',CL(L'OP@TYPE)'RRD ',CL(L'OP@FORMTX
               )'R1,R3,R2',CL(L'OP@ATTR)'  HM',CL(L'OP@DESCR)'Multiply X
               and Subtract Short Hexidecimal Floating Point Register'
OPC$B336 DC    AL2(X'B336'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SQXR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Square Root EX
               xtended Hexadecimal Floating Point Register'
OPC$B337 DC    AL2(X'B337'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'MEER',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Multiply ShorX
               t Hexidecimal Floating Point Register'
OPC$B338 DC    AL2(X'B338'),Y(X'0000'),XL2'0007',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'MAYLR',CL(L'OP@TYPE)'RRD ',CL(L'OP@FORMX
               T)'R1,R3,R2',CL(L'OP@ATTR)'  UE',CL(L'OP@DESCR)'MultiplyX
                and Add Unnormalized Long HFP to Extended Low-order HFPX
                Register'
OPC$B339 DC    AL2(X'B339'),Y(X'0000'),XL2'0007',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'MYLR',CL(L'OP@TYPE)'RRD ',CL(L'OP@FORMTX
               )'R1,R3,R2',CL(L'OP@ATTR)'  UE',CL(L'OP@DESCR)'Multiply X
               Unnormalized Long HFP to Extended Low-order HFP RegisterX
               '
OPC$B33A DC    AL2(X'B33A'),Y(X'0000'),XL2'8007',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'MAYR',CL(L'OP@TYPE)'RRD ',CL(L'OP@FORMTX
               )'R1,R3,R2',CL(L'OP@ATTR)'  UE',CL(L'OP@DESCR)'Multiply X
               and Add Unnormalized Long HFP to Extended HFP Register'
OPC$B33B DC    AL2(X'B33B'),Y(X'0000'),XL2'8007',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'MYR',CL(L'OP@TYPE)'RRD ',CL(L'OP@FORMT)X
               'R1,R3,R2',CL(L'OP@ATTR)'  UE',CL(L'OP@DESCR)'Multiply UX
               nnormalized Long HFP to Extended HFP Register'
OPC$B33C DC    AL2(X'B33C'),Y(X'0000'),XL2'0007',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'MAYHR',CL(L'OP@TYPE)'RRD ',CL(L'OP@FORMX
               T)'R1,R3,R2',CL(L'OP@ATTR)'  UE',CL(L'OP@DESCR)'MultiplyX
                and Add Unnormalized Long HFP to Extended High-order HFX
               P Register'
OPC$B33D DC    AL2(X'B33D'),Y(X'0000'),XL2'0007',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'MYHR',CL(L'OP@TYPE)'RRD ',CL(L'OP@FORMTX
               )'R1,R3,R2',CL(L'OP@ATTR)'  UE',CL(L'OP@DESCR)'Multiply X
               Unnormalized Long HFP to Extended High-order HFP RegisteX
               r'
OPC$B33E DC    AL2(X'B33E'),Y(X'0000'),XL2'0007',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'MADR',CL(L'OP@TYPE)'RRD ',CL(L'OP@FORMTX
               )'R1,R3,R2',CL(L'OP@ATTR)'  HM',CL(L'OP@DESCR)'Multiply X
               and Add Long Hexidecimal Floating Point Register'
OPC$B33F DC    AL2(X'B33F'),Y(X'0000'),XL2'0007',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'MSDR',CL(L'OP@TYPE)'RRD ',CL(L'OP@FORMTX
               )'R1,R3,R2',CL(L'OP@ATTR)'  HM',CL(L'OP@DESCR)'Multiply X
               and Subtract Long Hexidecimal Floating Point Register'
OPC$B340 DC    AL2(X'B340'),Y(X'0000'),XL2'2008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LPXBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Load PositivX
               e Extended Binary Floating Point Register'
OPC$B341 DC    AL2(X'B341'),Y(X'0000'),XL2'2008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LNXBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Load NegativX
               e Extended Binary Floating Point Register'
OPC$B342 DC    AL2(X'B342'),Y(X'0000'),XL2'2008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LTXBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Load and TesX
               t Extended Binary Floating Point Register'
OPC$B343 DC    AL2(X'B343'),Y(X'0000'),XL2'2008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LCXBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Load ComplemX
               ent Extended Binary Floating Point Register'
OPC$B344 DC    AL2(X'B344'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LEDBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Load RoundedX
               Short Binary Floating Point from Long BFP Register'
OPC$B345 DC    AL2(X'B345'),Y(X'0000'),XL2'2008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LDXBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Load RoundedX
                Long Binary Floating Point from Extended BFP Register'
OPC$B346 DC    AL2(X'B346'),Y(X'0000'),XL2'2008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LEXBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Load RoundedX
                Short Binary Floating Point from Extended BFP Register'
OPC$B347 DC    AL2(X'B347'),Y(X'0040'),XL2'200B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'FIXBR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FORX
               MT)'R1,M3,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Load FlX
               oating Point Integer from Extended BFP Register'
OPC$B348 DC    AL2(X'B348'),Y(X'0000'),XL2'2008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'KXBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Compare and SX
               ignal Extended Binary Floating Point Register'
OPC$B349 DC    AL2(X'B349'),Y(X'0000'),XL2'2008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CXBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Compare ExtenX
               ded Binary Floating Point Register'
OPC$B34A DC    AL2(X'B34A'),Y(X'0000'),XL2'2008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'AXBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Add Extended X
               Binary Floating Point Register'
OPC$B34B DC    AL2(X'B34B'),Y(X'0000'),XL2'2008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SXBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,D2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Subtract ExteX
               nded Binary Floating Point Register'
OPC$B34C DC    AL2(X'B34C'),Y(X'0000'),XL2'2008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'MXBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Multiply ExteX
               nded Binary Floating Point Register'
OPC$B34D DC    AL2(X'B34D'),Y(X'0000'),XL2'2008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'DXBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Divide ExtendX
               ed Binary Floating Point Register'
OPC$B350 DC    AL2(X'B350'),Y(X'0040'),XL2'000B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'TBEDR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FORX
               MT)'R1,M3,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'ConvertX
                to Binary Floating Point Short from Long Hex Floating PX
               nt Register'
OPC$B351 DC    AL2(X'B351'),Y(X'0040'),XL2'000B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'TBDR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FORMX
               T)'R1,M3,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Convert X
               Binary Floating Long from Long Hexidecimal Floating PoinX
               t Register'
OPC$B353 DC    AL2(X'B353'),Y(X'0001'),XL2'0809',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'DIEBR',CL(L'OP@TYPE)'RRF-b',CL(L'OP@FORX
               MT)'R1,R3,R2,M4',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'DiviX
               de to Integer Short Binary Floating Point Register'
OPC$B357 DC    AL2(X'B357'),Y(X'0040'),XL2'000B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'FIEBR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FORX
               MT)'R1,M3,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Load FlX
               oating Point Integer from Short Binary Floating Point ReX
               gister'
OPC$B358 DC    AL2(X'B358'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'THDER',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Convert to HX
               ex Floating Point Long from Short Binary Floating Pnt ReX
               gister'
OPC$B359 DC    AL2(X'B359'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'THDR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Convert to HeX
               x Floating Point Long from Long Binary Floating Pnt RegiX
               ster'
OPC$B35B DC    AL2(X'B35B'),Y(X'0001'),XL2'0809',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'DIDBR',CL(L'OP@TYPE)'RRF-b',CL(L'OP@FORX
               MT)'R1,R3,R2,M4',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'DiviX
               de to Integer Long Binary Floating Point Register'
OPC$B35F DC    AL2(X'B35F'),Y(X'0040'),XL2'000B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'FIDBR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FORX
               MT)'R1,M3,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Load FlX
               oating Point Integer from Long Binary Floating Point RegX
               ister'
OPC$B360 DC    AL2(X'B360'),Y(X'0000'),XL2'2008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LPXR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Load PositiveX
                Extended Hexadecimal Floating Point Register'
OPC$B361 DC    AL2(X'B361'),Y(X'0000'),XL2'2008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LNXR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Load NegativeX
                Extended Hexadecimal Floating Point Register'
OPC$B362 DC    AL2(X'B362'),Y(X'0000'),XL2'2008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LTXR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Load and TestX
                Extended Hexadecimal Floating Point Register'
OPC$B363 DC    AL2(X'B363'),Y(X'0000'),XL2'2008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LCXR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Load ComplemeX
               nt Extended Hexadecimal Floating Point Register'
OPC$B365 DC    AL2(X'B365'),Y(X'0000'),XL2'2008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LXR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Load Extended X
               Hexidecimal Floating Point Register'
OPC$B366 DC    AL2(X'B366'),Y(X'0000'),XL2'4008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LEXR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Load Rounded X
               Short Hexidecimal Floating Point from Extended HFP RegisX
               ter'
OPC$B367 DC    AL2(X'B367'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'FIXR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Load FloatingX
                Point Integer from Extended Hexidecimal Floating Pt RegX
               ister'
OPC$B369 DC    AL2(X'B369'),Y(X'0000'),XL2'2008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CXR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Compare ExtendX
               ed Hexadecimal Floating Point Register'
OPC$B370 DC    AL2(X'B370'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LPDFR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'  FS',CL(L'OP@DESCR)'Load PositivX
               e Long Floating Point Register'
OPC$B371 DC    AL2(X'B371'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LNDFR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'  FS',CL(L'OP@DESCR)'Load NegativX
               e Long Floating Point Register'
OPC$B372 DC    AL2(X'B372'),Y(X'0040'),XL2'0009',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CPSDR',CL(L'OP@TYPE)'RRF-b',CL(L'OP@FORX
               MT)'R1,R3,R2',CL(L'OP@ATTR)'  FS',CL(L'OP@DESCR)'Copy SiX
               gn Long Floating Point Register'
OPC$B373 DC    AL2(X'B373'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LCDFR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'  FS',CL(L'OP@DESCR)'Load ComplemX
               ent Long Floating Point Register'
OPC$B374 DC    AL2(X'B374'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LZER',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Load Zero Short X
               into Floating Point Register'
OPC$B375 DC    AL2(X'B375'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LZDR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Load Zero Long iX
               nto Floating Point Register'
OPC$B376 DC    AL2(X'B376'),Y(X'0000'),XL2'8008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LZXR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Load Zero ExtendX
               ed into Floating Point Register'
OPC$B377 DC    AL2(X'B377'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'FIER',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Load FloatingX
                Point Integer from Short Hexidecimal Floating Point RegX
               ister'
OPC$B37F DC    AL2(X'B37F'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'FIDR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Load FloatingX
                Point Integer from Long Hexidecimal Floating Point RegiX
               ster'
OPC$B384 DC    AL2(X'B384'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SFPC',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Set Floating PoiX
               nt Control Register'
OPC$B385 DC    AL2(X'B385'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SFASR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1',CL(L'OP@ATTR)'  XF',CL(L'OP@DESCR)'Set Floating PoX
               int Control and Signal Register'
OPC$B38C DC    AL2(X'B38C'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'EFPC',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Extract FloatingX
                Point Control Register'
OPC$B390 DC    AL2(X'B390'),Y(X'0200'),XL2'000B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CELFBR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FOX
               RMT)'R1,M3,R2,M4',CL(L'OP@ATTR)'  F ',CL(L'OP@DESCR)'ConX
               vert Short From Logical Fullword to Binary Floating PoinX
               t Register'
OPC$B391 DC    AL2(X'B391'),Y(X'0200'),XL2'000B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CDLFBR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FOX
               RMT)'R1,M3,R2,M4',CL(L'OP@ATTR)'  F ',CL(L'OP@DESCR)'ConX
               vert Long From Logical Fullword to Binary Floating PointX
                Register'
OPC$B392 DC    AL2(X'B392'),Y(X'0200'),XL2'800B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CXLFBR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FOX
               RMT)'R1,M3,R2,M4',CL(L'OP@ATTR)'  F ',CL(L'OP@DESCR)'ConX
               vert Extended From Logical Fullword to Binary Floating PX
               oint Register'
OPC$B394 DC    AL2(X'B394'),Y(X'0200'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CEFBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Convert ShorX
               t from Fixed-Integer to Binary Floating Point Register'
OPC$B395 DC    AL2(X'B395'),Y(X'0200'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CDFBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Convert LongX
                from Fixed-Integer to Binary Floating Point Register'
OPC$B396 DC    AL2(X'B396'),Y(X'0200'),XL2'8008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CXFBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Convert ExteX
               nded from Fixed-Integer to Binary Floating Point RegisteX
               r'
OPC$B398 DC    AL2(X'B398'),Y(X'0140'),XL2'000B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CFEBR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FORX
               MT)'R1,M3,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'ConvertX
                to Fixed-Integer from Short Binary Floating Point RegisX
               ter'
OPC$B399 DC    AL2(X'B399'),Y(X'0140'),XL2'000B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CFDBR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FORX
               MT)'R1,M3,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'ConvertX
                to Fixed-Integer from Long Binary Floating Point RegistX
               er'
OPC$B39A DC    AL2(X'B39A'),Y(X'0140'),XL2'400B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CFXBR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FORX
               MT)'R1,M3,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'ConvertX
                to Fixed-Integer from Extended Binary Floating Point ReX
               gister'
OPC$B39C DC    AL2(X'B39C'),Y(X'0100'),XL2'000B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLFEBR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FOX
               RMT)'R1,M3,R2,M4',CL(L'OP@ATTR)'c F ',CL(L'OP@DESCR)'ConX
               vert to Logical Fullword from Short Binary Floating PoinX
               t Register'
OPC$B39D DC    AL2(X'B39D'),Y(X'0100'),XL2'000B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLFDBR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FOX
               RMT)'R1,M3,R2,M4',CL(L'OP@ATTR)'c F ',CL(L'OP@DESCR)'ConX
               vert to Logical Fullword from Long Binary Floating PointX
                Register'
OPC$B39E DC    AL2(X'B39E'),Y(X'0140'),XL2'000B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLFXBR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FOX
               RMT)'R1,M3,R2,M4',CL(L'OP@ATTR)'c F ',CL(L'OP@DESCR)'ConX
               vert to Logical Fullword from Extended Binary Floating PX
               oint Register'
OPC$B3A0 DC    AL2(X'B3A0'),Y(X'0200'),XL2'000B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CELGBR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FOX
               RMT)'R1,M3,R2,M4',CL(L'OP@ATTR)'  F ',CL(L'OP@DESCR)'ConX
               vert Short From Logical Grande to Binary Floating Point X
               Register'
OPC$B3A1 DC    AL2(X'B3A1'),Y(X'0200'),XL2'000B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CDLGBR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FOX
               RMT)'R1,M3,R2,M4',CL(L'OP@ATTR)'  F ',CL(L'OP@DESCR)'ConX
               vert Long From Logical Grande to Binary Floating Point RX
               egister'
OPC$B3A2 DC    AL2(X'B3A2'),Y(X'0280'),XL2'000B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CXLGBR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FOX
               RMT)'R1,M3,R2,M4',CL(L'OP@ATTR)'  F ',CL(L'OP@DESCR)'ConX
               vert Extended From Logical Grande to Binary Floating PoiX
               nt Register'
OPC$B3A4 DC    AL2(X'B3A4'),Y(X'0200'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CEGBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'Convert ShorX
               t from Grande to Binary Floating Point Register'
OPC$B3A5 DC    AL2(X'B3A5'),Y(X'0200'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CDGBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'Convert LongX
                from Grande to Binary Floating Point Register'
OPC$B3A6 DC    AL2(X'B3A6'),Y(X'0200'),XL2'8008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CXGBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'Convert ExteX
               nded from Grande to Binary Floating Point Register'
OPC$B3A8 DC    AL2(X'B3A8'),Y(X'0140'),XL2'000B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CGEBR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FORX
               MT)'R1,M3,R2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'ConvertX
                to Grande from Short Binary Floating Point Register'
OPC$B3A9 DC    AL2(X'B3A9'),Y(X'0140'),XL2'000B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CGDBR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FORX
               MT)'R1,M3,R2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'ConvertX
                to Grande from Long Binary Floating Point Register'
OPC$B3AA DC    AL2(X'B3AA'),Y(X'0140'),XL2'400B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CGXBR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FORX
               MT)'R1,M3,R2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'ConvertX
                to Grande from Extended Binary Floating Point Register'
OPC$B3AC DC    AL2(X'B3AC'),Y(X'0100'),XL2'000B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLGEBR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FOX
               RMT)'R1,M3,R2,M4',CL(L'OP@ATTR)'c F ',CL(L'OP@DESCR)'ConX
               vert to Logical Grande from Short Binary Floating Point X
               Register'
OPC$B3AD DC    AL2(X'B3AD'),Y(X'0100'),XL2'000B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLGDBR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FOX
               RMT)'R1,M3,R2,M4',CL(L'OP@ATTR)'c F ',CL(L'OP@DESCR)'ConX
               vert to Logical Grande from Long Binary Floating Point RX
               egister'
OPC$B3AE DC    AL2(X'B3AE'),Y(X'0100'),XL2'000B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLGXBR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FOX
               RMT)'R1,M3,R2,M4',CL(L'OP@ATTR)'c F ',CL(L'OP@DESCR)'ConX
               vert to Logical Grande from Extended Binary Floating PoiX
               nt Register'
OPC$B3B4 DC    AL2(X'B3B4'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CEFR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Convert to ShX
               ort Hexidecimal Floating Point from Fixed Register'
OPC$B3B5 DC    AL2(X'B3B5'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CDFR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Convert to LoX
               ng Hexidecimal Floating Point from Fixed Register'
OPC$B3B6 DC    AL2(X'B3B6'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CXFR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Convert to ExX
               tended Hexidecimal Floating Point from Fixed Register'
OPC$B3B8 DC    AL2(X'B3B8'),Y(X'0140'),XL2'000B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CFER',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FORMX
               T)'R1,M3,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Convert X
               to Fixed from Short Hexidecimal Floating Point Register'
OPC$B3B9 DC    AL2(X'B3B9'),Y(X'0140'),XL2'000B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CFDR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FORMX
               T)'R1,M3,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Convert X
               to Fixed from Long Hexidecimal Floating Point Register'
OPC$B3BA DC    AL2(X'B3BA'),Y(X'0140'),XL2'400B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CFXR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FORMX
               T)'R1,M3,R2',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Convert X
               to Fixed from Extended Hexidecimal Floating Point RegistX
               er'
OPC$B3C1 DC    AL2(X'B3C1'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LDGR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'  FG',CL(L'OP@DESCR)'Load Long FloX
               ating Point Register from General Register (64 to Long)'
OPC$B3C4 DC    AL2(X'B3C4'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CEGR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'Convert to ShX
               ort Hexidecimal Floating Point from General Register (64X
               )'
OPC$B3C5 DC    AL2(X'B3C5'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CDGR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'Convert to LoX
               ng Hexidecimal Floating Point from General Register (64)X
               '
OPC$B3C6 DC    AL2(X'B3C6'),Y(X'0000'),XL2'8008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CXGR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'Convert to ExX
               tended Hexidecimal Floating Point from General Register X
               (64)'
OPC$B3C8 DC    AL2(X'B3C8'),Y(X'0140'),XL2'000B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CGER',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FORMX
               T)'R1,M3,R2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'Convert X
               to Grande from Short Hexidecimal Floating Point RegisterX
               '
OPC$B3C9 DC    AL2(X'B3C9'),Y(X'0140'),XL2'000B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CGDR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FORMX
               T)'R1,M3,R2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'Convert X
               to Grande from Long Hexidecimal Floating Point Register'
OPC$B3CA DC    AL2(X'B3CA'),Y(X'0140'),XL2'400B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CGXR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FORMX
               T)'R1,M3,R2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'Convert X
               to Grande from Extended Hexidecimal Floating Point RegisX
               ter'
OPC$B3CD DC    AL2(X'B3CD'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LGDR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'  FG',CL(L'OP@DESCR)'Load General X
               Register from Floating Point Register (Long to 64)'
OPC$B3D0 DC    AL2(X'B3D0'),Y(X'0000'),XL2'0009',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'MDTR',CL(L'OP@TYPE)'RRF-a',CL(L'OP@FORMX
               T)'R1,R2,R3',CL(L'OP@ATTR)'  TF',CL(L'OP@DESCR)'MultiplyX
                Long Decimal Floating Point Register'
OPC$B3D1 DC    AL2(X'B3D1'),Y(X'0000'),XL2'0009',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'DDTR',CL(L'OP@TYPE)'RRF-a',CL(L'OP@FORMX
               T)'R1,R2,R3',CL(L'OP@ATTR)'  TF',CL(L'OP@DESCR)'Divide LX
               ong Decimal Floating Point Register'
OPC$B3D2 DC    AL2(X'B3D2'),Y(X'0000'),XL2'0009',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'ADTR',CL(L'OP@TYPE)'RRF-a',CL(L'OP@FORMX
               T)'R1,R2,R3',CL(L'OP@ATTR)'c TF',CL(L'OP@DESCR)'Add LongX
                Decimal Floating Point Register'
OPC$B3D3 DC    AL2(X'B3D3'),Y(X'0000'),XL2'0009',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SDTR',CL(L'OP@TYPE)'RRF-a',CL(L'OP@FORMX
               T)'R1,R2,R3',CL(L'OP@ATTR)'c TF',CL(L'OP@DESCR)'SubtractX
                Long Decimal Floating Point Register'
OPC$B3D4 DC    AL2(X'B3D4'),Y(X'0020'),XL2'000A',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LDETR',CL(L'OP@TYPE)'RRF-d',CL(L'OP@FORX
               MT)'R1,R2,M4',CL(L'OP@ATTR)'  TF',CL(L'OP@DESCR)'Load LeX
               ngthened Long Decimal Floating Point from Short DFP RegiX
               ster'
OPC$B3D5 DC    AL2(X'B3D5'),Y(X'0000'),XL2'000B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LEDTR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FORX
               MT)'R1,M3,R2,M4',CL(L'OP@ATTR)'  TF',CL(L'OP@DESCR)'LoadX
                Rounded Short Decimal Floating Point from Long DFP RegiX
               ster'
OPC$B3D6 DC    AL2(X'B3D6'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LTDTR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'c TF',CL(L'OP@DESCR)'Load and TesX
               t Long Decimal Floating Point Register'
OPC$B3D7 DC    AL2(X'B3D7'),Y(X'0000'),XL2'000B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'FIDTR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FORX
               MT)'R1,M3,R2,M4',CL(L'OP@ATTR)'  TF',CL(L'OP@DESCR)'LoadX
                Floating Point Integer from Long Decimal Floating PointX
                Register'
OPC$B3D8 DC    AL2(X'B3D8'),Y(X'0000'),XL2'0809',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'MXTR',CL(L'OP@TYPE)'RRF-a',CL(L'OP@FORMX
               T)'R1,R2,R3',CL(L'OP@ATTR)'  TF',CL(L'OP@DESCR)'MultiplyX
                Extended Decimal Floating Point Register'
OPC$B3D9 DC    AL2(X'B3D9'),Y(X'0000'),XL2'0809',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'DXTR',CL(L'OP@TYPE)'RRF-a',CL(L'OP@FORMX
               T)'R1,R2,R3',CL(L'OP@ATTR)'  TF',CL(L'OP@DESCR)'Divide EX
               xtended Decimal Floating Point Register'
OPC$B3DA DC    AL2(X'B3DA'),Y(X'0000'),XL2'0809',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'AXTR',CL(L'OP@TYPE)'RRF-a',CL(L'OP@FORMX
               T)'R1,R2,R3',CL(L'OP@ATTR)'c TF',CL(L'OP@DESCR)'Add ExteX
               nded Decimal Floating Point Register'
OPC$B3DB DC    AL2(X'B3DB'),Y(X'0000'),XL2'0809',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SXTR',CL(L'OP@TYPE)'RRF-a',CL(L'OP@FORMX
               T)'R1,R2,R3',CL(L'OP@ATTR)'c TF',CL(L'OP@DESCR)'SubtractX
                Extended Decimal Floating Point Register'
OPC$B3DC DC    AL2(X'B3DC'),Y(X'0020'),XL2'800A',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LXDTR',CL(L'OP@TYPE)'RRF-d',CL(L'OP@FORX
               MT)'R1,R2,M4',CL(L'OP@ATTR)'  TF',CL(L'OP@DESCR)'Load LeX
               ngthened Extended Decimal Floating Point from Long DFP RX
               egister'
OPC$B3DD DC    AL2(X'B3DD'),Y(X'0000'),XL2'200B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LDXTR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FORX
               MT)'R1,M3,R2,M4',CL(L'OP@ATTR)'  TF',CL(L'OP@DESCR)'LoadX
                Rounded Long Decimal Floating Point from Extended DFP RX
               egister'
OPC$B3DE DC    AL2(X'B3DE'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LTXTR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'c TF',CL(L'OP@DESCR)'Load and TesX
               t Extended Decimal Floating Point Register'
OPC$B3DF DC    AL2(X'B3DF'),Y(X'0000'),XL2'080B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'FIXTR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FORX
               MT)'R1,M3,R2,M4',CL(L'OP@ATTR)'  TF',CL(L'OP@DESCR)'LoadX
                Floating Point Integer from Extended Decimal Floating PX
               oint Register'
OPC$B3E0 DC    AL2(X'B3E0'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'KDTR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'c TF',CL(L'OP@DESCR)'Compare and SX
               ignal Long Decimal Floating Point Register'
OPC$B3E1 DC    AL2(X'B3E1'),Y(X'0140'),XL2'000B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CGDTR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FORX
               MT)'R1,M3,R2',CL(L'OP@ATTR)'c TF',CL(L'OP@DESCR)'ConvertX
                to Grande from Long Decimal Floating Point Register'
OPC$B3E2 DC    AL2(X'B3E2'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CUDTR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'  TF',CL(L'OP@DESCR)'Convert to UX
               nsigned Packed from Long Decimal Floating Point RegisterX
               '
OPC$B3E3 DC    AL2(X'B3E3'),Y(X'0120'),XL2'000A',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CSDTR',CL(L'OP@TYPE)'RRF-d',CL(L'OP@FORX
               MT)'R1,R2,M4',CL(L'OP@ATTR)'  TF',CL(L'OP@DESCR)'ConvertX
                to Signed Packed from Long Decimal Floating Point RegisX
               ter'
OPC$B3E4 DC    AL2(X'B3E4'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CDTR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'c TF',CL(L'OP@DESCR)'Compare Long X
               Decimal Floating Point Register'
OPC$B3E5 DC    AL2(X'B3E5'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'EEDTR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'  TF',CL(L'OP@DESCR)'Extract BiasX
               ed Exponent from Long Decimal Floating Point Register'
OPC$B3E7 DC    AL2(X'B3E7'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'ESDTR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'  TF',CL(L'OP@DESCR)'Extract SignX
               ificance from Long Decimal Floating Point Register'
OPC$B3E8 DC    AL2(X'B3E8'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'KXTR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'c TF',CL(L'OP@DESCR)'Compare and SX
               ignal Extended Decimal Floating Point Register'
OPC$B3E9 DC    AL2(X'B3E9'),Y(X'0140'),XL2'400B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CGXTR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FORX
               MT)'R1,M3,R2',CL(L'OP@ATTR)'c TF',CL(L'OP@DESCR)'ConvertX
                to Grande from Extended Decimal Floating Point RegisterX
               '
OPC$B3EA DC    AL2(X'B3EA'),Y(X'0000'),XL2'1008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CUXTR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'  TF',CL(L'OP@DESCR)'Convert to UX
               nsigned Packed from Extended Decimal Floating Point RegiX
               ster'
OPC$B3EB DC    AL2(X'B3EB'),Y(X'0020'),XL2'100A',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CSXTR',CL(L'OP@TYPE)'RRF-d',CL(L'OP@FORX
               MT)'R1,R2,M4',CL(L'OP@ATTR)'  TF',CL(L'OP@DESCR)'ConvertX
                to Signed Packed from Extended Decimal Floating Point RX
               egister'
OPC$B3EC DC    AL2(X'B3EC'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CXTR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'c TF',CL(L'OP@DESCR)'Compare ExtenX
               ded Decimal Floating Point Register'
OPC$B3ED DC    AL2(X'B3ED'),Y(X'0000'),XL2'4008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'EEXTR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'  TF',CL(L'OP@DESCR)'Extract BiasX
               ed Exponent from Extended Decimal Floating Point RegisteX
               r'
OPC$B3EF DC    AL2(X'B3EF'),Y(X'0000'),XL2'4008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'ESXTR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'  TF',CL(L'OP@DESCR)'Extract SignX
               ificance from Extended Decimal Floating Point Register'
OPC$B3F1 DC    AL2(X'B3F1'),Y(X'0200'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CDGTR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'  TF',CL(L'OP@DESCR)'Convert fromX
                Grande to Long Decimal Floating Point Register'
OPC$B3F2 DC    AL2(X'B3F2'),Y(X'0000'),XL2'0208',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CDUTR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'  TF',CL(L'OP@DESCR)'Convert fromX
                Unsigned Packed to Long Decimal Floating Point RegisterX
               '
OPC$B3F3 DC    AL2(X'B3F3'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CDSTR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'  TF',CL(L'OP@DESCR)'Convert fromX
                Signed Packed to Long Decimal Floating Point Register'
OPC$B3F4 DC    AL2(X'B3F4'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CEDTR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'c TF',CL(L'OP@DESCR)'Compare BiasX
               ed Exponent Long Decimal Floating Point Register'
OPC$B3F5 DC    AL2(X'B3F5'),Y(X'0000'),XL2'0009',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'QADTR',CL(L'OP@TYPE)'RRF-b',CL(L'OP@FORX
               MT)'R1,R3,R2,M4',CL(L'OP@ATTR)'  TF',CL(L'OP@DESCR)'QuanX
               tize Long Decimal Floating Point Register'
OPC$B3F6 DC    AL2(X'B3F6'),Y(X'0040'),XL2'0009',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'IEDTR',CL(L'OP@TYPE)'RRF-b',CL(L'OP@FORX
               MT)'R1,R3,R2',CL(L'OP@ATTR)'  TF',CL(L'OP@DESCR)'Insert X
               Biased Exponent into Long Decimal Floating Point RegisteX
               r'
OPC$B3F7 DC    AL2(X'B3F7'),Y(X'0000'),XL2'0009',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'RRDTR',CL(L'OP@TYPE)'RRF-b',CL(L'OP@FORX
               MT)'R1,R3,R2,M4',CL(L'OP@ATTR)'  TF',CL(L'OP@DESCR)'ReroX
               und Long Decimal Floating Point Register'
OPC$B3F9 DC    AL2(X'B3F9'),Y(X'0200'),XL2'8008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CXGTR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'  TF',CL(L'OP@DESCR)'Convert fromX
                Grande to Extended Decimal Floating Point Register'
OPC$B3FA DC    AL2(X'B3FA'),Y(X'0000'),XL2'1008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CXUTR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'  TF',CL(L'OP@DESCR)'Convert fromX
                Unsigned Packed to Extended Decimal Floating Point RegiX
               ster'
OPC$B3FB DC    AL2(X'B3FB'),Y(X'0000'),XL2'1008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CXSTR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'  TF',CL(L'OP@DESCR)'Convert fromX
                Signed Packed to Extended Decimal Floating Point RegistX
               er'
OPC$B3FC DC    AL2(X'B3FC'),Y(X'0000'),XL2'2008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CEXTR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'c TF',CL(L'OP@DESCR)'Compare BiasX
               ed Exponent Extended Decimal Floating Point Register'
OPC$B3FD DC    AL2(X'B3FD'),Y(X'0000'),XL2'0809',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'QAXTR',CL(L'OP@TYPE)'RRF-b',CL(L'OP@FORX
               MT)'R1,R3,R2,M4',CL(L'OP@ATTR)'  TF',CL(L'OP@DESCR)'QuanX
               tize Extended Decimal Floating Point Register'
OPC$B3FE DC    AL2(X'B3FE'),Y(X'0040'),XL2'2009',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'IEXTR',CL(L'OP@TYPE)'RRF-b',CL(L'OP@FORX
               MT)'R1,R3,R2',CL(L'OP@ATTR)'  TF',CL(L'OP@DESCR)'Insert X
               Biased Exponent into Extended Decimal Floating Point RegX
               ister'
OPC$B3FF DC    AL2(X'B3FF'),Y(X'0000'),XL2'2009',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'RRXTR',CL(L'OP@TYPE)'RRF-b',CL(L'OP@FORX
               MT)'R1,R3,R2,M4',CL(L'OP@ATTR)'  TF',CL(L'OP@DESCR)'ReroX
               und Extended Decimal Floating Point Register'
OPC$B6   DC    AL2(X'B600'),Y(X'0000'),XL2'000D',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'STCTL',CL(L'OP@TYPE)'RS-a',CL(L'OP@FORMX
               T)'R1,R3,D2(B2)',CL(L'OP@ATTR)'p   ',CL(L'OP@DESCR)'StorX
               e Control (32)'
OPC$B7   DC    AL2(X'B700'),Y(X'0000'),XL2'000D',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'LCTL',CL(L'OP@TYPE)'RS-a',CL(L'OP@FORMTX
               )'R1,R3,D2(B2)',CL(L'OP@ATTR)'p   ',CL(L'OP@DESCR)'Load X
               Control (32)'
OPC$B900 DC    AL2(X'B900'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LPGR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'Load PositiveX
                Grande Register (64)'
OPC$B901 DC    AL2(X'B901'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LNGR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'Load NegativeX
                Grande Register (64)'
OPC$B902 DC    AL2(X'B902'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LTGR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'Load and TestX
                Grande Register (64)'
OPC$B903 DC    AL2(X'B903'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LCGR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'Load ComplemeX
               nt Grande Register (64)'
OPC$B904 DC    AL2(X'B904'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LGR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'Load Grande ReX
               gister (64)'
OPC$B905 DC    AL2(X'B905'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LURAG',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'p N ',CL(L'OP@DESCR)'Load Using RX
               eal Address Grande (64)'
OPC$B906 DC    AL2(X'B906'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LGBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'  EI',CL(L'OP@DESCR)'Load Grande BX
               yte Register (64<-8)'
OPC$B907 DC    AL2(X'B907'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LGHR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'  EI',CL(L'OP@DESCR)'Load Grande HX
               alfword Register (64<-16)'
OPC$B908 DC    AL2(X'B908'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'AGR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'Add Grande RegX
               ister (64)'
OPC$B909 DC    AL2(X'B909'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SGR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'Subtract GrandX
               e Register (64)'
OPC$B90A DC    AL2(X'B90A'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'ALGR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'Add Logical GX
               rande Register (64)'
OPC$B90B DC    AL2(X'B90B'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SLGR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'Subtract LogiX
               cal Grande Register (64)'
OPC$B90C DC    AL2(X'B90C'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'MSGR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'Multiply SingX
               le Grande Register (64)'
OPC$B90D DC    AL2(X'B90D'),Y(X'0000'),XL2'0108',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'DSGR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'Divide SingleX
                Grande Register (64)'
OPC$B90E DC    AL2(X'B90E'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'EREGG',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'Extract StacX
               ked Registers Grande (64)'
OPC$B90F DC    AL2(X'B90F'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LRVGR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'Load ReverseX
               d Grande Register (64)'
OPC$B910 DC    AL2(X'B910'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LPGFR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'Load PositivX
               e Grande Fullword Register (64<-32)'
OPC$B911 DC    AL2(X'B911'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LNGFR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'Load NegativX
               e Grande Fullword Register (64<-32)'
OPC$B912 DC    AL2(X'B912'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LTGFR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'Load and TesX
               t Grande Fullword Register (64<-32)'
OPC$B913 DC    AL2(X'B913'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LCGFR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'Load ComplemX
               ent Grande Fullword Register (64<-32)'
OPC$B914 DC    AL2(X'B914'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LGFR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'Load Grande FX
               ullword Register (64<-32)'
OPC$B916 DC    AL2(X'B916'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LLGFR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'Load LogicalX
                Grande Fullword Register (64<-32)'
OPC$B917 DC    AL2(X'B917'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LLGTR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'Load LogicalX
                Grande Thirty-One Bits Register (64<-31)'
OPC$B918 DC    AL2(X'B918'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'AGFR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'Add Grande FuX
               llword Register (64<-32)'
OPC$B919 DC    AL2(X'B919'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SGFR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'Subtract GranX
               de Fullword Register (64<-32)'
OPC$B91A DC    AL2(X'B91A'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'ALGFR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'Add Logical X
               Grande Fullword Register (64<-32)'
OPC$B91B DC    AL2(X'B91B'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SLGFR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'Subtract LogX
               ical Grande Fullword Register (64<-32)'
OPC$B91C DC    AL2(X'B91C'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'MSGFR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'Multiply SinX
               gle Grande Fullword Register (64<-32)'
OPC$B91D DC    AL2(X'B91D'),Y(X'0000'),XL2'0108',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'DSGFR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'Divide SinglX
               e Grande Fullword Register (64<-32)'
OPC$B91E DC    AL2(X'B91E'),Y(X'0000'),XL2'0208',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'KMAC',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'c MS',CL(L'OP@DESCR)'Compute MessaX
               ge Authentication Code'
OPC$B91F DC    AL2(X'B91F'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LRVR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'  N3',CL(L'OP@DESCR)'Load ReversedX
                Register (32)'
OPC$B920 DC    AL2(X'B920'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CGR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'Compare GrandeX
                Register (64)'
OPC$B921 DC    AL2(X'B921'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLGR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'Compare LogicX
               al Grande Register (64)'
OPC$B925 DC    AL2(X'B925'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'STURG',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'p N ',CL(L'OP@DESCR)'Store Using X
               Real Address Grande (64)'
OPC$B926 DC    AL2(X'B926'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'  EI',CL(L'OP@DESCR)'Load Byte RegiX
               ster (32)'
OPC$B927 DC    AL2(X'B927'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LHR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'  EI',CL(L'OP@DESCR)'Load Halfword X
               Register (32<-16)'
OPC$B928 DC    AL2(X'B928'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'PCKMO',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'Op_Code',CL(L'OP@ATTR)'p M3',CL(L'OP@DESCR)'Perform CrX
               yptographic Key Management Operation'
OPC$B92A DC    AL2(X'B92A'),Y(X'0001'),XL2'0408',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'KMF',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'c M4',CL(L'OP@DESCR)'Cipher MessageX
                with Cipher Feedback'
OPC$B92B DC    AL2(X'B92B'),Y(X'0001'),XL2'0408',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'KMO',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'c M4',CL(L'OP@DESCR)'Cipher MessageX
                with Output Feedback'
OPC$B92C DC    AL2(X'B92C'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'PCC',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)'X
               Op_Code',CL(L'OP@ATTR)'c M4',CL(L'OP@DESCR)'Perform CrypX
               tographic Computation'
OPC$B92D DC    AL2(X'B92D'),Y(X'0042'),XL2'0409',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'KMCTR',CL(L'OP@TYPE)'RRF-b',CL(L'OP@FORX
               MT)'R1,R3,R2',CL(L'OP@ATTR)'c M4',CL(L'OP@DESCR)'Cipher X
               Message with Counter'
OPC$B92E DC    AL2(X'B92E'),Y(X'0000'),XL2'0408',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'KM',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)'RX
               1,R2',CL(L'OP@ATTR)'c MS',CL(L'OP@DESCR)'Cipher Message'
OPC$B92F DC    AL2(X'B92F'),Y(X'0000'),XL2'0408',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'KMC',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'c MS',CL(L'OP@DESCR)'Cipher MessageX
                with Chaining'
OPC$B930 DC    AL2(X'B930'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CGFR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'Compare GrandX
               e Fullword Register (64<-32)'
OPC$B931 DC    AL2(X'B931'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLGFR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'Compare LogiX
               cal Grande Fullword Register (64<-32)'
OPC$B93E DC    AL2(X'B93E'),Y(X'0000'),XL2'0208',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'KIMD',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'c MS',CL(L'OP@DESCR)'Compute InterX
               mediate Message Digest'
OPC$B93F DC    AL2(X'B93F'),Y(X'0000'),XL2'0208',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'KLMD',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'c MS',CL(L'OP@DESCR)'Compute Last X
               Message Digest'
OPC$B941 DC    AL2(X'B941'),Y(X'0100'),XL2'000B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CFDTR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FORX
               MT)'R1,M3,R2,M4',CL(L'OP@ATTR)'c F ',CL(L'OP@DESCR)'ConvX
               ert to Fixed from Long DFP Register (32<-LD)'
OPC$B942 DC    AL2(X'B942'),Y(X'0100'),XL2'000B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLGDTR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FOX
               RMT)'R1,M3,R2,M4',CL(L'OP@ATTR)'c F ',CL(L'OP@DESCR)'ConX
               vert to Logical Grande from Long DFP Register (64<-LD)'
OPC$B943 DC    AL2(X'B943'),Y(X'0100'),XL2'000B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLFDTR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FOX
               RMT)'R1,M3,R2,M4',CL(L'OP@ATTR)'c F ',CL(L'OP@DESCR)'ConX
               vert to Logical Fullword from Long Decimal Floating PoinX
               t Register'
OPC$B946 DC    AL2(X'B946'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'BCTGR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'Branch on CoX
               unt Grande Register (64)'
OPC$B949 DC    AL2(X'B949'),Y(X'0100'),XL2'400B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CFXTR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FORX
               MT)'R1,M3,R2,M4',CL(L'OP@ATTR)'c F ',CL(L'OP@DESCR)'ConvX
               ert to Fixed from Extended Decimal Floating Point RegistX
               er'
OPC$B94A DC    AL2(X'B94A'),Y(X'0100'),XL2'400B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLGXTR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FOX
               RMT)'R1,M3,R2,M4',CL(L'OP@ATTR)'c F ',CL(L'OP@DESCR)'ConX
               vert to Logical Grande from Extended Decimal Floating PoX
               int Register'
OPC$B94B DC    AL2(X'B94B'),Y(X'0100'),XL2'400B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLFXTR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FOX
               RMT)'R1,M3,R2,M4',CL(L'OP@ATTR)'c F ',CL(L'OP@DESCR)'ConX
               vert to Logical Fullword from Extended Decimal Floating X
               Point Register'
OPC$B951 DC    AL2(X'B951'),Y(X'0200'),XL2'000B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CDFTR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FORX
               MT)'R1,M3,R2,M4',CL(L'OP@ATTR)'  F ',CL(L'OP@DESCR)'ConvX
               ert Long from Fixed to Decimal Floating Point Register'
OPC$B952 DC    AL2(X'B952'),Y(X'0200'),XL2'000B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CDLGTR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FOX
               RMT)'R1,M3,R2,M4',CL(L'OP@ATTR)'  F ',CL(L'OP@DESCR)'ConX
               vert Long From Logical Grande to Decimal Floating Point X
               Register'
OPC$B953 DC    AL2(X'B953'),Y(X'0200'),XL2'000B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CDLFTR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FOX
               RMT)'R1,M3,R2,M4',CL(L'OP@ATTR)'  F ',CL(L'OP@DESCR)'ConX
               vert Long From Logical Fullword to Decimal Floating PoinX
               t Register'
OPC$B959 DC    AL2(X'B959'),Y(X'0000'),XL2'800B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CXFTR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FORX
               MT)'R1,M3,R2,M4',CL(L'OP@ATTR)'  F ',CL(L'OP@DESCR)'ConvX
               ert Extended from Fixed to Decimal Floating Point RegistX
               er'
OPC$B95A DC    AL2(X'B95A'),Y(X'0200'),XL2'800B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CXLGTR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FOX
               RMT)'R1,M3,R2,M4',CL(L'OP@ATTR)'  F ',CL(L'OP@DESCR)'ConX
               vert Extended From Logical Grande to Decimal Floating PoX
               int Register'
OPC$B95B DC    AL2(X'B95B'),Y(X'0200'),XL2'800B',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CXLFTR',CL(L'OP@TYPE)'RRF-e',CL(L'OP@FOX
               RMT)'R1,M3,R2,M4',CL(L'OP@ATTR)'  F ',CL(L'OP@DESCR)'ConX
               vert Extended From Logical Fullword to Decimal Floating X
               Point Register'
OPC$B960 DC    AL2(X'B960'),Y(X'0040'),XL2'000A',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CGRT',CL(L'OP@TYPE)'RRF-c',CL(L'OP@FORMX
               T)'R1,R2,M3',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'Compare X
               Grande Register and Trap'
OPC$B961 DC    AL2(X'B961'),Y(X'0040'),XL2'000A',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLGRT',CL(L'OP@TYPE)'RRF-c',CL(L'OP@FORX
               MT)'R1,R2,M3',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'CompareX
                Logical Grande Register and Trap'
OPC$B972 DC    AL2(X'B972'),Y(X'0040'),XL2'000A',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CRT',CL(L'OP@TYPE)'RRF-c',CL(L'OP@FORMTX
               )'R1,R2,M3',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'Compare aX
               nd Trap'
OPC$B973 DC    AL2(X'B973'),Y(X'0040'),XL2'000A',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLRT',CL(L'OP@TYPE)'RRF-c',CL(L'OP@FORMX
               T)'R1,R2,M3',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'Compare X
               Logical Register and Trap'
OPC$B980 DC    AL2(X'B980'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'NGR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'And Grande RegX
               ister (64)'
OPC$B981 DC    AL2(X'B981'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'OGR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'Or Grande RegiX
               ster (64)'
OPC$B982 DC    AL2(X'B982'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'XGR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'Exclusive Or GX
               rande Register (64)'
OPC$B983 DC    AL2(X'B983'),Y(X'0000'),XL2'0108',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'FLOGR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'c EI',CL(L'OP@DESCR)'Find LeftmosX
               t One Grande Register'
OPC$B984 DC    AL2(X'B984'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LLGCR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'  EI',CL(L'OP@DESCR)'Load LogicalX
                Grande Character Register (64<-8)'
OPC$B985 DC    AL2(X'B985'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LLGHR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'  EI',CL(L'OP@DESCR)'Load LogicalX
                Grande Halfword Register (64<-16)'
OPC$B986 DC    AL2(X'B986'),Y(X'0000'),XL2'0108',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'MLGR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'Multiply LogiX
               cal Grande Register (128<-64)'
OPC$B987 DC    AL2(X'B987'),Y(X'0000'),XL2'0108',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'DLGR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'Divide LogicaX
               l Grande Register (64<-128)'
OPC$B988 DC    AL2(X'B988'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'ALCGR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'Add Logical X
               with Carry Grande Register (64)'
OPC$B989 DC    AL2(X'B989'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SLBGR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'Subtract LogX
               ical with Borrow Grande Register (64)'
OPC$B98A DC    AL2(X'B98A'),Y(X'0000'),XL2'0108',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CSPG',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'pcDE',CL(L'OP@DESCR)'Compare and SX
               wap and Purge Grande (64)'
OPC$B98D DC    AL2(X'B98D'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'EPSW',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'  N3',CL(L'OP@DESCR)'Extract PSW'
OPC$B98E DC    AL2(X'B98E'),Y(X'0040'),XL2'0009',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'IDTE',CL(L'OP@TYPE)'RRF-b',CL(L'OP@FORMX
               T)'R1,R3,R2',CL(L'OP@ATTR)'puDE',CL(L'OP@DESCR)'InvalidaX
               te DAT Table Entry'
OPC$B990 DC    AL2(X'B990'),Y(X'00C0'),XL2'010A',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'TRTT',CL(L'OP@TYPE)'RRF-c',CL(L'OP@FORMX
               T)'R1,R2,M3',CL(L'OP@ATTR)'c E2',CL(L'OP@DESCR)'TranslX
               ate Two to Two'
OPC$B991 DC    AL2(X'B991'),Y(X'00C0'),XL2'010A',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'TRTO',CL(L'OP@TYPE)'RRF-c',CL(L'OP@FORMX
               T)'R1,R2,M3',CL(L'OP@ATTR)'c E2',CL(L'OP@DESCR)'TranslX
               ate Two to One'
OPC$B992 DC    AL2(X'B992'),Y(X'00C0'),XL2'010A',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'TROT',CL(L'OP@TYPE)'RRF-c',CL(L'OP@FORMX
               T)'R1,R2,M3',CL(L'OP@ATTR)'c E2',CL(L'OP@DESCR)'TranslX
               ate One to Two'
OPC$B993 DC    AL2(X'B993'),Y(X'00C0'),XL2'010A',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'TROO',CL(L'OP@TYPE)'RRF-c',CL(L'OP@FORMX
               T)'R1,R2,M3',CL(L'OP@ATTR)'c E2',CL(L'OP@DESCR)'TranslX
               ate One to One'
OPC$B994 DC    AL2(X'B994'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LLCR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'  EI',CL(L'OP@DESCR)'Load Logical X
               Character Register (32<-8)'
OPC$B995 DC    AL2(X'B995'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LLHR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'  EI',CL(L'OP@DESCR)'Load Logical X
               Halfword Register (32<-16)'
OPC$B996 DC    AL2(X'B996'),Y(X'0000'),XL2'0108',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'MLR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'  N3',CL(L'OP@DESCR)'Multiply LogicX
               al Register (64<-32)'
OPC$B997 DC    AL2(X'B997'),Y(X'0000'),XL2'0108',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'DLR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'  N3',CL(L'OP@DESCR)'Divide LogicalX
                Register (32<-64)'
OPC$B998 DC    AL2(X'B998'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'ALCR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'c N3',CL(L'OP@DESCR)'Add Logical wX
               ith Carry Register (32)'
OPC$B999 DC    AL2(X'B999'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SLBR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'c N3',CL(L'OP@DESCR)'Subtract LogiX
               cal with Borrow Register (32)'
OPC$B99A DC    AL2(X'B99A'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'EPAIR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1',CL(L'OP@ATTR)'q RA',CL(L'OP@DESCR)'Extract PrimaryX
                ASN and Instance'
OPC$B99B DC    AL2(X'B99B'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'ESAIR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1',CL(L'OP@ATTR)'q RA',CL(L'OP@DESCR)'Extract SecondaX
               ry ASN and Instance'
OPC$B99D DC    AL2(X'B99D'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'ESEA',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'p N ',CL(L'OP@DESCR)'Extract and SX
               et Extended Authority'
OPC$B99E DC    AL2(X'B99E'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'PTI',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)'X
               R1,R2',CL(L'OP@ATTR)'q RA',CL(L'OP@DESCR)'Program TransfX
               er with Instance'
OPC$B99F DC    AL2(X'B99F'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SSAIR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1',CL(L'OP@ATTR)'  RA',CL(L'OP@DESCR)'Set Secondary AX
               ddress Space Number with Instance Register'
OPC$B9A2 DC    AL2(X'B9A2'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'PTF',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)'X
               R1',CL(L'OP@ATTR)'pcCT',CL(L'OP@DESCR)'Perform Topology X
               Function'
OPC$B9AA DC    AL2(X'B9AA'),Y(X'0000'),XL2'0009',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LPTEA',CL(L'OP@TYPE)'RRF-b',CL(L'OP@FORX
               MT)'R1,R3,R2,M4',CL(L'OP@ATTR)'c D2',CL(L'OP@DESCR)'LoadX
                Page-Table-Entry Address'
OPC$B9AE DC    AL2(X'B9AE'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'RRBM',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'p RB',CL(L'OP@DESCR)'Reset ReferenX
               ce Bits Multiple'
OPC$B9AF DC    AL2(X'B9AF'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'PFMF',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'p ED',CL(L'OP@DESCR)'Perform FrameX
                Management Function'
OPC$B9B0 DC    AL2(X'B9B0'),Y(X'0040'),XL2'040A',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CU14',CL(L'OP@TYPE)'RRF-c',CL(L'OP@FORMX
               T)'R1,R2,M3',CL(L'OP@ATTR)'c E3',CL(L'OP@DESCR)'ConverX
               t UTF-8 to UTF-32'
OPC$B9B1 DC    AL2(X'B9B1'),Y(X'0040'),XL2'040A',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CU24',CL(L'OP@TYPE)'RRF-c',CL(L'OP@FORMX
               T)'R1,R2,M3',CL(L'OP@ATTR)'c E3',CL(L'OP@DESCR)'ConverX
               t UTF-16 to UTF-32'
OPC$B9B2 DC    AL2(X'B9B2'),Y(X'0000'),XL2'0408',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CU41',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'c E3',CL(L'OP@DESCR)'Convert UTF-3X
               2 to UTF-8'
OPC$B9B3 DC    AL2(X'B9B3'),Y(X'0000'),XL2'0408',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CU42',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'c E3',CL(L'OP@DESCR)'Convert UTF-3X
               2 to UTF-16'
OPC$B9BD DC    AL2(X'B9BD'),Y(X'00C0'),XL2'010A',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'TRTRE',CL(L'OP@TYPE)'RRF-c',CL(L'OP@FORX
               MT)'R1,R2,M3',CL(L'OP@ATTR)'  PE',CL(L'OP@DESCR)'TransX
               late and Test Reverse Extended'
OPC$B9BF DC    AL2(X'B9BF'),Y(X'00C0'),XL2'010A',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'TRTE',CL(L'OP@TYPE)'RRF-c',CL(L'OP@FORMX
               T)'R1,R2,M3',CL(L'OP@ATTR)'  PE',CL(L'OP@DESCR)'TranslX
               ate and Test Extended'
OPC$B9C8 DC    AL2(X'B9C8'),Y(X'0000'),XL2'0009',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'AHHHR',CL(L'OP@TYPE)'RRF-a',CL(L'OP@FORX
               MT)'R1,R2,R3',CL(L'OP@ATTR)'c HW',CL(L'OP@DESCR)'Add HigX
               hword High and High Register'
OPC$B9C9 DC    AL2(X'B9C9'),Y(X'0000'),XL2'0009',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SHHHR',CL(L'OP@TYPE)'RRF-a',CL(L'OP@FORX
               MT)'R1,R2,R3',CL(L'OP@ATTR)'c HW',CL(L'OP@DESCR)'SubtracX
               t Highword High and High Register'
OPC$B9CA DC    AL2(X'B9CA'),Y(X'0000'),XL2'0009',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'ALHHHR',CL(L'OP@TYPE)'RRF-a',CL(L'OP@FOX
               RMT)'R1,R2,R3',CL(L'OP@ATTR)'c HW',CL(L'OP@DESCR)'Add LoX
               gical Highword High and High Register'
OPC$B9CB DC    AL2(X'B9CB'),Y(X'0000'),XL2'0009',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SLHHHR',CL(L'OP@TYPE)'RRF-a',CL(L'OP@FOX
               RMT)'R1,R2,R3',CL(L'OP@ATTR)'c HW',CL(L'OP@DESCR)'SubtraX
               ct Logical Highword High and High Register'
OPC$B9CD DC    AL2(X'B9CD'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CHHR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'c HW',CL(L'OP@DESCR)'Compare High X
               and High Register'
OPC$B9CF DC    AL2(X'B9CF'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLHHR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'c HW',CL(L'OP@DESCR)'Compare LogiX
               ical High and High Register'
OPC$B9D8 DC    AL2(X'B9D8'),Y(X'0000'),XL2'0009',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'AHHLR',CL(L'OP@TYPE)'RRF-a',CL(L'OP@FORX
               MT)'R1,R2,R3',CL(L'OP@ATTR)'c HW',CL(L'OP@DESCR)'Add HigX
               hword High and Low Register'
OPC$B9D9 DC    AL2(X'B9D9'),Y(X'0000'),XL2'0009',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SHHLR',CL(L'OP@TYPE)'RRF-a',CL(L'OP@FORX
               MT)'R1,R2,R3',CL(L'OP@ATTR)'c HW',CL(L'OP@DESCR)'SubtracX
               t Highword High and Low Register'
OPC$B9DA DC    AL2(X'B9DA'),Y(X'0000'),XL2'0009',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'ALHHLR',CL(L'OP@TYPE)'RRF-a',CL(L'OP@FOX
               RMT)'R1,R2,R3',CL(L'OP@ATTR)'c HW',CL(L'OP@DESCR)'Add LoX
               gical Highword High and Low Register'
OPC$B9DB DC    AL2(X'B9DB'),Y(X'0000'),XL2'0009',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SLHHLR',CL(L'OP@TYPE)'RRF-a',CL(L'OP@FOX
               RMT)'R1,R2,R3',CL(L'OP@ATTR)'c HW',CL(L'OP@DESCR)'SubtraX
               ct Logical Highword High and Low Register'
OPC$B9DD DC    AL2(X'B9DD'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CHLR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMT)X
               'R1,R2',CL(L'OP@ATTR)'c HW',CL(L'OP@DESCR)'Compare High X
               and Low Register'
OPC$B9DF DC    AL2(X'B9DF'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLHLR',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMTX
               )'R1,R2',CL(L'OP@ATTR)'c HW',CL(L'OP@DESCR)'Compare LogiX
               cal High and Low Register'
OPC$B9E1 DC    AL2(X'B9E1'),Y(X'0000'),XL2'0008',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'POPCNT',CL(L'OP@TYPE)'RRE',CL(L'OP@FORMX
               T)'R1,R2',CL(L'OP@ATTR)'c PK',CL(L'OP@DESCR)'Population X
               Count'
OPC$B9E2 DC    AL2(X'B9E2'),Y(X'0040'),XL2'000A',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LOCGR',CL(L'OP@TYPE)'RRF-c',CL(L'OP@FORX
               MT)'R1,R2,M3',CL(L'OP@ATTR)'  CL',CL(L'OP@DESCR)'Load onX
                Condition Grande Register (64)'
OPC$B9E4 DC    AL2(X'B9E4'),Y(X'0000'),XL2'0009',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'NGRK',CL(L'OP@TYPE)'RRF-a',CL(L'OP@FORMX
               T)'R1,R2,R3',CL(L'OP@ATTR)'c DO',CL(L'OP@DESCR)'And GranX
               de Register Distinct (64)'
OPC$B9E6 DC    AL2(X'B9E6'),Y(X'0000'),XL2'0009',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'OGRK',CL(L'OP@TYPE)'RRF-a',CL(L'OP@FORMX
               T)'R1,R2,R3',CL(L'OP@ATTR)'c DO',CL(L'OP@DESCR)'Or GrandX
               e Register Distinct (64)'
OPC$B9E7 DC    AL2(X'B9E7'),Y(X'0000'),XL2'0009',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'XGRK',CL(L'OP@TYPE)'RRF-a',CL(L'OP@FORMX
               T)'R1,R2,R3',CL(L'OP@ATTR)'c DO',CL(L'OP@DESCR)'ExclusivX
               e Or Grande Register Distinct (64)'
OPC$B9E8 DC    AL2(X'B9E8'),Y(X'0000'),XL2'0009',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'AGRK',CL(L'OP@TYPE)'RRF-a',CL(L'OP@FORMX
               T)'R1,R2,R3',CL(L'OP@ATTR)'c DO',CL(L'OP@DESCR)'Add GranX
               de Register Distinct (64)'
OPC$B9E9 DC    AL2(X'B9E9'),Y(X'0000'),XL2'0009',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SGRK',CL(L'OP@TYPE)'RRF-a',CL(L'OP@FORMX
               T)'R1,R2,R3',CL(L'OP@ATTR)'c DO',CL(L'OP@DESCR)'SubtractX
                Grande Register Distinct (64)'
OPC$B9EA DC    AL2(X'B9EA'),Y(X'0000'),XL2'0009',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'ALGRK',CL(L'OP@TYPE)'RRF-a',CL(L'OP@FORX
               MT)'R1,R2,R3',CL(L'OP@ATTR)'c DO',CL(L'OP@DESCR)'Add LogX
               ical Grande Register Distinct (64)'
OPC$B9EB DC    AL2(X'B9EB'),Y(X'0000'),XL2'0009',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SLGRK',CL(L'OP@TYPE)'RRF-a',CL(L'OP@FORX
               MT)'R1,R2,R3',CL(L'OP@ATTR)'c DO',CL(L'OP@DESCR)'SubtracX
               t Logical Grande Register Distinct (64)'
OPC$B9F2 DC    AL2(X'B9F2'),Y(X'0040'),XL2'000A',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'LOCR',CL(L'OP@TYPE)'RRF-c',CL(L'OP@FORMX
               T)'R1,R2,M3',CL(L'OP@ATTR)'  CL',CL(L'OP@DESCR)'Load on X
               Condition Register (32)'
OPC$B9F4 DC    AL2(X'B9F4'),Y(X'0000'),XL2'0009',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'NRK',CL(L'OP@TYPE)'RRF-a',CL(L'OP@FORMTX
               )'R1,R2,R3',CL(L'OP@ATTR)'c DO',CL(L'OP@DESCR)'And RegisX
               ter Distinct (32)'
OPC$B9F6 DC    AL2(X'B9F6'),Y(X'0000'),XL2'0009',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'ORK',CL(L'OP@TYPE)'RRF-a',CL(L'OP@FORMTX
               )'R1,R2,R3',CL(L'OP@ATTR)'c DO',CL(L'OP@DESCR)'Or RegistX
               er Distinct (32)'
OPC$B9F7 DC    AL2(X'B9F7'),Y(X'0000'),XL2'0009',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'XRK',CL(L'OP@TYPE)'RRF-a',CL(L'OP@FORMTX
               )'R1,R2,R3',CL(L'OP@ATTR)'c DO',CL(L'OP@DESCR)'ExclusiveX
                Or Register Distinct (32)'
OPC$B9F8 DC    AL2(X'B9F8'),Y(X'0000'),XL2'0009',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'ARK',CL(L'OP@TYPE)'RRF-a',CL(L'OP@FORMTX
               )'R1,R2,R3',CL(L'OP@ATTR)'c DO',CL(L'OP@DESCR)'Add RegisX
               ter Distinct (32)'
OPC$B9F9 DC    AL2(X'B9F9'),Y(X'0000'),XL2'0009',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SRK',CL(L'OP@TYPE)'RRF-a',CL(L'OP@FORMTX
               )'R1,R2,R3',CL(L'OP@ATTR)'c DO',CL(L'OP@DESCR)'Subtract X
               Register Distinct (32)'
OPC$B9FA DC    AL2(X'B9FA'),Y(X'0000'),XL2'0009',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'ALRK',CL(L'OP@TYPE)'RRF-a',CL(L'OP@FORMX
               T)'R1,R2,R3',CL(L'OP@ATTR)'c DO',CL(L'OP@DESCR)'Add LogiX
               cal Register Distinct (32)'
OPC$B9FB DC    AL2(X'B9FB'),Y(X'0000'),XL2'0009',Y(X'0402'),AD(00000000X
               ),CL(L'OP@MNEUM)'SLRK',CL(L'OP@TYPE)'RRF-a',CL(L'OP@FORMX
               T)'R1,R2,R3',CL(L'OP@ATTR)'c DO',CL(L'OP@DESCR)'SubtractX
                Logical Register Distinct (32)'
OPC$BA   DC    AL2(X'BA00'),Y(X'0000'),XL2'000D',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'CS',CL(L'OP@TYPE)'RS-a',CL(L'OP@FORMT)'X
               R1,R3,D2(B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'CompareX
                and Swap (32)'
OPC$BB   DC    AL2(X'BB00'),Y(X'0000'),XL2'040D',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'CDS',CL(L'OP@TYPE)'RS-a',CL(L'OP@FORMT)X
               'R1,R3,D2(B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'ComparX
               e Double and Swap (32)'
OPC$BD   DC    AL2(X'BD00'),Y(X'0000'),XL2'000D',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLM',CL(L'OP@TYPE)'RS-b',CL(L'OP@FORMT)X
               'R1,M3,D2(B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'ComparX
               e Logical Characters under Mask'
OPC$BE   DC    AL2(X'BE00'),Y(X'0000'),XL2'000D',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'STCM',CL(L'OP@TYPE)'RS-b',CL(L'OP@FORMTX
               )'R1,M3,D2(B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'StoreX
                Characters under Mask (low)'
OPC$BF   DC    AL2(X'BF00'),Y(X'0000'),XL2'000D',Y(X'0401'),AD(00000000X
               ),CL(L'OP@MNEUM)'ICM',CL(L'OP@TYPE)'RS-b',CL(L'OP@FORMT)X
               'R1,M3,D2(B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'InsertX
                Characters under Mask (low)'
OPC$C00  DC    AL2(X'C000'),Y(X'0080'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'LARL',CL(L'OP@TYPE)'RIL-b',CL(L'OP@FORMX
               T)'R1,RI2',CL(L'OP@ATTR)'  N3',CL(L'OP@DESCR)'Load AddreX
               ss Relative Long'
OPC$C01  DC    AL2(X'C010'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'LGFI',CL(L'OP@TYPE)'RIL-a',CL(L'OP@FORMX
               T)'R1,I2',CL(L'OP@ATTR)'  EI',CL(L'OP@DESCR)'Load GrandeX
                Fullword Immediate (64<-I32)'
OPC$C04  DC    AL2(X'C040'),Y(X'0000'),XL2'0000',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'BRCL',CL(L'OP@TYPE)'RIL-c',CL(L'OP@FORMX
               T)'M1,RI2',CL(L'OP@ATTR)'  N3',CL(L'OP@DESCR)'Branch RelX
               ative on Condition Long'
OPC$C05  DC    AL2(X'C050'),Y(X'0080'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'BRASL',CL(L'OP@TYPE)'RIL-b',CL(L'OP@FORX
               MT)'R1,RI2',CL(L'OP@ATTR)'  N3',CL(L'OP@DESCR)'Branch ReX
               lative and Save Long'
OPC$C06  DC    AL2(X'C060'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'XIHF',CL(L'OP@TYPE)'RIL-a',CL(L'OP@FORMX
               T)'R1,I2',CL(L'OP@ATTR)'c EI',CL(L'OP@DESCR)'Exclusive OX
               r Immediate High Fullword'
OPC$C07  DC    AL2(X'C070'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'XILF',CL(L'OP@TYPE)'RIL-a',CL(L'OP@FORMX
               T)'R1,I2',CL(L'OP@ATTR)'c EI',CL(L'OP@DESCR)'Exclusive OX
               r Immediate Low Fullword'
OPC$C08  DC    AL2(X'C080'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'IIHF',CL(L'OP@TYPE)'RIL-a',CL(L'OP@FORMX
               T)'R1,I2',CL(L'OP@ATTR)'  EI',CL(L'OP@DESCR)'Insert ImmeX
               diate High Fullword'
OPC$C09  DC    AL2(X'C090'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'IILF',CL(L'OP@TYPE)'RIL-a',CL(L'OP@FORMX
               T)'R1,I2',CL(L'OP@ATTR)'  EI',CL(L'OP@DESCR)'Insert ImmeX
               diate Low Fullword'
OPC$C0A  DC    AL2(X'C0A0'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'NIHF',CL(L'OP@TYPE)'RIL-a',CL(L'OP@FORMX
               T)'R1,I2',CL(L'OP@ATTR)'c EI',CL(L'OP@DESCR)'And ImmediaX
               te High Fullword'
OPC$C0B  DC    AL2(X'C0B0'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'NILF',CL(L'OP@TYPE)'RIL-a',CL(L'OP@FORMX
               T)'R1,I2',CL(L'OP@ATTR)'c EI',CL(L'OP@DESCR)'And ImmediaX
               te Low Fullword'
OPC$C0C  DC    AL2(X'C0C0'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'OIHF',CL(L'OP@TYPE)'RIL-a',CL(L'OP@FORMX
               T)'R1,I2',CL(L'OP@ATTR)'c EI',CL(L'OP@DESCR)'Or ImmediatX
               e High Fullword'
OPC$C0D  DC    AL2(X'C0D0'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'OILF',CL(L'OP@TYPE)'RIL-a',CL(L'OP@FORMX
               T)'R1,I2',CL(L'OP@ATTR)'c EI',CL(L'OP@DESCR)'Or ImmediatX
               e Low Fullword'
OPC$C0E  DC    AL2(X'C0E0'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'LLIHF',CL(L'OP@TYPE)'RIL-a',CL(L'OP@FORX
               MT)'R1,I2',CL(L'OP@ATTR)'  EI',CL(L'OP@DESCR)'Load LogicX
               al Immediate High Fullword'
OPC$C0F  DC    AL2(X'C0F0'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'LLILF',CL(L'OP@TYPE)'RIL-a',CL(L'OP@FORX
               MT)'R1,I2',CL(L'OP@ATTR)'  EI',CL(L'OP@DESCR)'Load LogicX
               al Immediate Low Fullword'
OPC$C20  DC    AL2(X'C200'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'MSGFI',CL(L'OP@TYPE)'RIL-a',CL(L'OP@FORX
               MT)'R1,I2',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'Multiply SX
               ingle Grande Fullword Immediate (64<-I32)'
OPC$C21  DC    AL2(X'C210'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'MSFI',CL(L'OP@TYPE)'RIL-a',CL(L'OP@FORMX
               T)'R1,I2',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'Multiply SiX
               ngle Fullword Immediate'
OPC$C24  DC    AL2(X'C240'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'SLGFI',CL(L'OP@TYPE)'RIL-a',CL(L'OP@FORX
               MT)'R1,I2',CL(L'OP@ATTR)'c EI',CL(L'OP@DESCR)'Subtract LX
               ogical Grande Fullword Immediate (64<-I32)'
OPC$C25  DC    AL2(X'C250'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'SLFI',CL(L'OP@TYPE)'RIL-a',CL(L'OP@FORMX
               T)'R1,I2',CL(L'OP@ATTR)'c EI',CL(L'OP@DESCR)'Subtract LoX
               gical Fullword Immediate (32)'
OPC$C28  DC    AL2(X'C280'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'AGFI',CL(L'OP@TYPE)'RIL-a',CL(L'OP@FORMX
               T)'R1,I2',CL(L'OP@ATTR)'c EI',CL(L'OP@DESCR)'Add Grande X
               Fullword Immediate (64<-I32)'
OPC$C29  DC    AL2(X'C290'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'AFI',CL(L'OP@TYPE)'RIL-a',CL(L'OP@FORMTX
               )'R1,I2',CL(L'OP@ATTR)'c EI',CL(L'OP@DESCR)'Add FullwordX
                Immediate (32)'
OPC$C2A  DC    AL2(X'C2A0'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'ALGFI',CL(L'OP@TYPE)'RIL-a',CL(L'OP@FORX
               MT)'R1,I2',CL(L'OP@ATTR)'c EI',CL(L'OP@DESCR)'Add LogicaX
               l Grande Fullword Immediate (64<-32)'
OPC$C2B  DC    AL2(X'C2B0'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'ALFI',CL(L'OP@TYPE)'RIL-a',CL(L'OP@FORMX
               T)'R1,I2',CL(L'OP@ATTR)'c EI',CL(L'OP@DESCR)'Add LogicalX
                Fullword Immediate (32)'
OPC$C2C  DC    AL2(X'C2C0'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'CGFI',CL(L'OP@TYPE)'RIL-a',CL(L'OP@FORMX
               T)'R1,I2',CL(L'OP@ATTR)'c EI',CL(L'OP@DESCR)'Compare GraX
               nde Fullword Immediate (64<-I32)'
OPC$C2D  DC    AL2(X'C2D0'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'CFI',CL(L'OP@TYPE)'RIL-a',CL(L'OP@FORMTX
               )'R1,I2',CL(L'OP@ATTR)'c EI',CL(L'OP@DESCR)'Compare FullX
               word Immediate (32)'
OPC$C2E  DC    AL2(X'C2E0'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLGFI',CL(L'OP@TYPE)'RIL-a',CL(L'OP@FORX
               MT)'R1,I2',CL(L'OP@ATTR)'c EI',CL(L'OP@DESCR)'Compare LoX
               gical Grande Fullword Immediate (64<-I32)'
OPC$C2F  DC    AL2(X'C2F0'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLFI',CL(L'OP@TYPE)'RIL-a',CL(L'OP@FORMX
               T)'R1,I2',CL(L'OP@ATTR)'c EI',CL(L'OP@DESCR)'Compare LogX
               ical Fullword Immediate (32)'
OPC$C42  DC    AL2(X'C420'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'LLHRL',CL(L'OP@TYPE)'RIL-b',CL(L'OP@FORX
               MT)'R1,RI2',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'Load LogiX
               cal Halfword Relative Long (32<-16)'
OPC$C44  DC    AL2(X'C440'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'LGHRL',CL(L'OP@TYPE)'RIL-b',CL(L'OP@FORX
               MT)'R1,RI2',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'Load GranX
               de Halfword Relative Long (64<-16)'
OPC$C45  DC    AL2(X'C450'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'LHRL',CL(L'OP@TYPE)'RIL-b',CL(L'OP@FORMX
               T)'R1,RI2',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'Load HalfwX
               ord Relative Long (32<-16)'
OPC$C46  DC    AL2(X'C460'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'LLGHRL',CL(L'OP@TYPE)'RIL-b',CL(L'OP@FOX
               RMT)'R1,RI2',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'Load LogX
               ical Grande Halfword Relative Long  (64<-16)'
OPC$C47  DC    AL2(X'C470'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'STHRL',CL(L'OP@TYPE)'RIL-b',CL(L'OP@FORX
               MT)'R1,RI2',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'Store HalX
               fword Relative Long'
OPC$C48  DC    AL2(X'C480'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'LGRL',CL(L'OP@TYPE)'RIL-b',CL(L'OP@FORMX
               T)'R1,RI2',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'Load GrandX
               e Relative Long (64)'
OPC$C4B  DC    AL2(X'C4B0'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'STGRL',CL(L'OP@TYPE)'RIL-b',CL(L'OP@FORX
               MT)'R1,RI2',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'Store GraX
               nde Relative Long (64)'
OPC$C4C  DC    AL2(X'C4C0'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'LGFRL',CL(L'OP@TYPE)'RIL-b',CL(L'OP@FORX
               MT)'R1,RI2',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'Load GranX
               de Fullword Relative Long (64<-32)'
OPC$C4D  DC    AL2(X'C4D0'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'LRL',CL(L'OP@TYPE)'RIL-b',CL(L'OP@FORMTX
               )'R1,RI2',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'Load RelatiX
               ve Long (32)'
OPC$C4E  DC    AL2(X'C4E0'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'LLGFRL',CL(L'OP@TYPE)'RIL-b',CL(L'OP@FOX
               RMT)'R1,RI2',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'Load LogX
               ical Grande Fullword Relative Long (64<-32)'
OPC$C4F  DC    AL2(X'C4F0'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'STRL',CL(L'OP@TYPE)'RIL-b',CL(L'OP@FORMX
               T)'R1,RI2',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'Store RelaX
               tive Long (32)'
OPC$C60  DC    AL2(X'C600'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'EXRL',CL(L'OP@TYPE)'RIL-b',CL(L'OP@FORMX
               T)'R1,RI2',CL(L'OP@ATTR)'  XX',CL(L'OP@DESCR)'Execute ReX
               lative Long'
OPC$C62  DC    AL2(X'C620'),Y(X'0000'),XL2'0000',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'PFDRL',CL(L'OP@TYPE)'RIL-c',CL(L'OP@FORX
               MT)'M1,RI2',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'Prefetch X
               Data Relative Long'
OPC$C64  DC    AL2(X'C640'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'CGHRL',CL(L'OP@TYPE)'RIL-b',CL(L'OP@FORX
               MT)'R1,RI2',CL(L'OP@ATTR)'c GE',CL(L'OP@DESCR)'Compare GX
               rande Halfword Relative Long (64<-16)'
OPC$C65  DC    AL2(X'C650'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'CHRL',CL(L'OP@TYPE)'RIL-b',CL(L'OP@FORMX
               T)'R1,RI2',CL(L'OP@ATTR)'c GE',CL(L'OP@DESCR)'Compare HaX
               lfword Relative Long (32<-I8)'
OPC$C66  DC    AL2(X'C660'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLGHRL',CL(L'OP@TYPE)'RIL-b',CL(L'OP@FOX
               RMT)'R1,RI2',CL(L'OP@ATTR)'c GE',CL(L'OP@DESCR)'Compare X
               Logical Grande Halfword Relative Long (64<-16)'
OPC$C67  DC    AL2(X'C670'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLHRL',CL(L'OP@TYPE)'RIL-b',CL(L'OP@FORX
               MT)'R1,RI2',CL(L'OP@ATTR)'c GE',CL(L'OP@DESCR)'Compare LX
               ogical Halfword Relative Long (32I16)'
OPC$C68  DC    AL2(X'C680'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'CGRL',CL(L'OP@TYPE)'RIL-b',CL(L'OP@FORMX
               T)'R1,RI2',CL(L'OP@ATTR)'c GE',CL(L'OP@DESCR)'Compare GrX
               ande Relative Long (64)'
OPC$C6A  DC    AL2(X'C6A0'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLGRL',CL(L'OP@TYPE)'RIL-b',CL(L'OP@FORX
               MT)'R1,RI2',CL(L'OP@ATTR)'c GE',CL(L'OP@DESCR)'Compare LX
               ogical Grande Relative Long (64)'
OPC$C6C  DC    AL2(X'C6C0'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'CGFRL',CL(L'OP@TYPE)'RIL-b',CL(L'OP@FORX
               MT)'R1,RI2',CL(L'OP@ATTR)'c GE',CL(L'OP@DESCR)'Compare GX
               rande Fullword Relative Long (64<-32)'
OPC$C6D  DC    AL2(X'C6D0'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'CRL',CL(L'OP@TYPE)'RIL-b',CL(L'OP@FORMTX
               )'R1,RI2',CL(L'OP@ATTR)'c GE',CL(L'OP@DESCR)'Compare RelX
               ative Long (32)'
OPC$C6E  DC    AL2(X'C6E0'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLGFRL',CL(L'OP@TYPE)'RIL-b',CL(L'OP@FOX
               RMT)'R1,RI2',CL(L'OP@ATTR)'c GE',CL(L'OP@DESCR)'Compare X
               Logical Grande Fullword Relative Long (64<-32)'
OPC$C6F  DC    AL2(X'C6F0'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLRL',CL(L'OP@TYPE)'RIL-b',CL(L'OP@FORMX
               T)'R1,RI2',CL(L'OP@ATTR)'c GE',CL(L'OP@DESCR)'Compare LoX
               gical Relative Long (32)'
OPC$C80  DC    AL2(X'C800'),Y(X'0000'),XL2'001F',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'MVCOS',CL(L'OP@TYPE)'SSF',CL(L'OP@FORMTX
               )'D1(B1),D2(B2),R3',CL(L'OP@ATTR)'cqMO',CL(L'OP@DESCR)'MX
               ove with Optional Specifications'
OPC$C81  DC    AL2(X'C810'),Y(X'0000'),XL2'001F',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'ECTG',CL(L'OP@TYPE)'SSF',CL(L'OP@FORMT)X
               'D1(B1),D2(B2),R3',CL(L'OP@ATTR)'  ET',CL(L'OP@DESCR)'ExX
               tract CPU Time Grande'
OPC$C82  DC    AL2(X'C820'),Y(X'0000'),XL2'041F',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'CSST',CL(L'OP@TYPE)'SSF',CL(L'OP@FORMT)X
               'D1(B1),D2(B2),R3',CL(L'OP@ATTR)'c CS',CL(L'OP@DESCR)'CoX
               mpare and Swap and Store'
OPC$C84  DC    AL2(X'C840'),Y(X'0002'),XL2'011F',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'LPD',CL(L'OP@TYPE)'SSF',CL(L'OP@FORMT)'X
               R3,D1(B1),D2(B2)',CL(L'OP@ATTR)'c IA',CL(L'OP@DESCR)'LoaX
               d Pair Disjoint (32)'
OPC$C85  DC    AL2(X'C850'),Y(X'0002'),XL2'011F',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'LPDG',CL(L'OP@TYPE)'SSF',CL(L'OP@FORMT)X
               'R3,D1(B1),D2(B2)',CL(L'OP@ATTR)'c IA',CL(L'OP@DESCR)'LoX
               ad Pair Disjoint Grande (64)'
OPC$CC6  DC    AL2(X'CC60'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'BRCTH',CL(L'OP@TYPE)'RIL-b',CL(L'OP@FORX
               MT)'R1,RI2',CL(L'OP@ATTR)'  HW',CL(L'OP@DESCR)'Branch ReX
               lative on Count Highword'
OPC$CC8  DC    AL2(X'CC80'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'AIH',CL(L'OP@TYPE)'RIL-a',CL(L'OP@FORMTX
               )'R1,I2',CL(L'OP@ATTR)'c HW',CL(L'OP@DESCR)'Add ImmediatX
               e High'
OPC$CCA  DC    AL2(X'CCA0'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'ALSIH',CL(L'OP@TYPE)'RIL-a',CL(L'OP@FORX
               MT)'R1,I2',CL(L'OP@ATTR)'c HW',CL(L'OP@DESCR)'Add LogicaX
               l with Signed Immediate High'
OPC$CCB  DC    AL2(X'CCB0'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'ALSIHN',CL(L'OP@TYPE)'RIL-a',CL(L'OP@FOX
               RMT)'R1,I2',CL(L'OP@ATTR)'  HW',CL(L'OP@DESCR)'Add LogicX
               al with Signed Immediate High Noset'
OPC$CCD  DC    AL2(X'CCD0'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'CIH',CL(L'OP@TYPE)'RIL-a',CL(L'OP@FORMTX
               )'R1,I2',CL(L'OP@ATTR)'c HW',CL(L'OP@DESCR)'Compare ImmeX
               diate High'
OPC$CCF  DC    AL2(X'CCF0'),Y(X'0000'),XL2'0002',Y(X'0612'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLIH',CL(L'OP@TYPE)'RIL-a',CL(L'OP@FORMX
               T)'R1,I2',CL(L'OP@ATTR)'c HW',CL(L'OP@DESCR)'Compare LogX
               ical Immediate High'
OPC$D0   DC    AL2(X'D000'),Y(X'0080'),XL2'0018',Y(X'0601'),AD(00000000X
               ),CL(L'OP@MNEUM)'TRTR',CL(L'OP@TYPE)'SS-a',CL(L'OP@FORMTX
               )'D1(L,B1),D2(B2)',CL(L'OP@ATTR)'c E3',CL(L'OP@DESCR)'TrX
               anslate and Test Reverse'
OPC$D1   DC    AL2(X'D100'),Y(X'0000'),XL2'0018',Y(X'0601'),AD(00000000X
               ),CL(L'OP@MNEUM)'MVN',CL(L'OP@TYPE)'SS-a',CL(L'OP@FORMT)X
               'D1(L,B1),D2(B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'MovX
               e Numerics'
OPC$D2   DC    AL2(X'D200'),Y(X'0000'),XL2'0018',Y(X'0601'),AD(00000000X
               ),CL(L'OP@MNEUM)'MVC',CL(L'OP@TYPE)'SS-a',CL(L'OP@FORMT)X
               'D1(L,B1),D2(B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'MovX
               e Character'
OPC$D3   DC    AL2(X'D300'),Y(X'0000'),XL2'0018',Y(X'0601'),AD(00000000X
               ),CL(L'OP@MNEUM)'MVZ',CL(L'OP@TYPE)'SS-a',CL(L'OP@FORMT)X
               'D1(L,B1),D2(B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'MovX
               e Zones'
OPC$D4   DC    AL2(X'D400'),Y(X'0000'),XL2'0018',Y(X'0601'),AD(00000000X
               ),CL(L'OP@MNEUM)'NC',CL(L'OP@TYPE)'SS-a',CL(L'OP@FORMT)'X
               D1(L,B1),D2(B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'And X
               Character'
OPC$D5   DC    AL2(X'D500'),Y(X'0000'),XL2'0018',Y(X'0601'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLC',CL(L'OP@TYPE)'SS-a',CL(L'OP@FORMT)X
               'D1(L,B1),D2(B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'ComX
               pare Logical Character'
OPC$D6   DC    AL2(X'D600'),Y(X'0000'),XL2'0018',Y(X'0601'),AD(00000000X
               ),CL(L'OP@MNEUM)'OC',CL(L'OP@TYPE)'SS-a',CL(L'OP@FORMT)'X
               D1(L,B1),D2(B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Or CX
               haracter'
OPC$D7   DC    AL2(X'D700'),Y(X'0000'),XL2'0018',Y(X'0601'),AD(00000000X
               ),CL(L'OP@MNEUM)'XC',CL(L'OP@TYPE)'SS-a',CL(L'OP@FORMT)'X
               D1(L,B1),D2(B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'ExclX
               usive Or Character'
OPC$D9   DC    AL2(X'D900'),Y(X'0000'),XL2'001C',Y(X'0601'),AD(00000000X
               ),CL(L'OP@MNEUM)'MVCK',CL(L'OP@TYPE)'SS-d',CL(L'OP@FORMTX
               )'D1(R1,B1),D2(B2),R3',CL(L'OP@ATTR)'qc  ',CL(L'OP@DESCRX
               )'Move with Key'
OPC$DA   DC    AL2(X'DA00'),Y(X'0000'),XL2'001C',Y(X'0601'),AD(00000000X
               ),CL(L'OP@MNEUM)'MVCP',CL(L'OP@TYPE)'SS-d',CL(L'OP@FORMTX
               )'D1(R1,B1),D2(B2),R3',CL(L'OP@ATTR)'qc  ',CL(L'OP@DESCRX
               )'Move to Primary'
OPC$DB   DC    AL2(X'DB00'),Y(X'0000'),XL2'001C',Y(X'0601'),AD(00000000X
               ),CL(L'OP@MNEUM)'MVCS',CL(L'OP@TYPE)'SS-d',CL(L'OP@FORMTX
               )'D1(R1,B1),D2(B2),R3',CL(L'OP@ATTR)'qc  ',CL(L'OP@DESCRX
               )'Move to Secondary'
OPC$DC   DC    AL2(X'DC00'),Y(X'0080'),XL2'0018',Y(X'0601'),AD(00000000X
               ),CL(L'OP@MNEUM)'TR',CL(L'OP@TYPE)'SS-a',CL(L'OP@FORMT)'X
               D1(L,B1),D2(B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'TranX
               slate'
OPC$DD   DC    AL2(X'DD00'),Y(X'0080'),XL2'0018',Y(X'0601'),AD(00000000X
               ),CL(L'OP@MNEUM)'TRT',CL(L'OP@TYPE)'SS-a',CL(L'OP@FORMT)X
               'D1(L,B1),D2(B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'TraX
               nslate and Test'
OPC$DE   DC    AL2(X'DE00'),Y(X'0000'),XL2'0018',Y(X'0601'),AD(00000000X
               ),CL(L'OP@MNEUM)'ED',CL(L'OP@TYPE)'SS-a',CL(L'OP@FORMT)'X
               D1(L,B1),D2(B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'EditX
               '
OPC$DF   DC    AL2(X'DF00'),Y(X'0000'),XL2'0018',Y(X'0601'),AD(00000000X
               ),CL(L'OP@MNEUM)'EDMK',CL(L'OP@TYPE)'SS-a',CL(L'OP@FORMTX
               )'D1(L,B1),D2(B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'EdX
               it and Mark'
OPC$E1   DC    AL2(X'E100'),Y(X'0000'),XL2'001B',Y(X'0601'),AD(00000000X
               ),CL(L'OP@MNEUM)'PKU',CL(L'OP@TYPE)'SS-f',CL(L'OP@FORMT)X
               'D1(B1),D2(L2,B2)',CL(L'OP@ATTR)'  E2',CL(L'OP@DESCR)'PaX
               ck Unicode'
OPC$E2   DC    AL2(X'E200'),Y(X'0000'),XL2'0018',Y(X'0601'),AD(00000000X
               ),CL(L'OP@MNEUM)'UNPKU',CL(L'OP@TYPE)'SS-a',CL(L'OP@FORMX
               T)'D1(L1,B1),D2(B2)',CL(L'OP@ATTR)'c E2',CL(L'OP@DESCR)'X
               Unpack Unicode'
OPC$E302 DC    AL2(X'E302'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LTG',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'c EI',CL(L'OP@DESCR)'Load X
               and Test Grande (64)'
OPC$E303 DC    AL2(X'E303'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LRAG',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMX
               T)'R1,D2(X2,B2)',CL(L'OP@ATTR)'pcN ',CL(L'OP@DESCR)'LoadX
                Real Address Grande (64)'
OPC$E304 DC    AL2(X'E304'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LG',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMT)X
               'R1,D2(X2,B2)',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'Load GX
               rande (64)'
OPC$E308 DC    AL2(X'E308'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'AG',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMT)X
               'R1,D2(X2,B2)',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'Add GrX
               ande (64)'
OPC$E309 DC    AL2(X'E309'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'SG',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMT)X
               'R1,D2(X2,B2)',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'SubtraX
               ct Grande (64)'
OPC$E30A DC    AL2(X'E30A'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'ALG',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'Add LX
               ogical Grande (64)'
OPC$E30B DC    AL2(X'E30B'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'SLG',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'SubtrX
               act Logical Grande (64)'
OPC$E30C DC    AL2(X'E30C'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'MSG',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'MultiX
               ply Single Grande (64)'
OPC$E30D DC    AL2(X'E30D'),Y(X'0000'),XL2'0113',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'DSG',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'DividX
               e Single Grande (64)'
OPC$E30E DC    AL2(X'E30E'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'CVBG',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMX
               T)'R1,D2(X2,B2)',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'ConvX
               ert to Binary Grande (64)'
OPC$E30F DC    AL2(X'E30F'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LRVG',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMX
               T)'R1,D2(X2,B2)',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'LoadX
                Reversed Grande (64)'
OPC$E312 DC    AL2(X'E312'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LT',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMT)X
               'R1,D2(X2,B2)',CL(L'OP@ATTR)'c EI',CL(L'OP@DESCR)'Load aX
               nd Test (32)'
OPC$E313 DC    AL2(X'E313'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LRAY',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMX
               T)'R1,D2(X2,B2)',CL(L'OP@ATTR)'pcLD',CL(L'OP@DESCR)'LoadX
                Real Address Long (32)'
OPC$E314 DC    AL2(X'E314'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LGF',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'Load X
               Grande Fullword (64<-32)'
OPC$E315 DC    AL2(X'E315'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LGH',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'Load X
               Grande Halfword (64<-16)'
OPC$E316 DC    AL2(X'E316'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LLGF',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMX
               T)'R1,D2(X2,B2)',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'LoadX
                Logical Grande Fullword (64<-32)'
OPC$E317 DC    AL2(X'E317'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LLGT',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMX
               T)'R1,D2(X2,B2)',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'LoadX
                Logical Grande Thirty-One Bits (64<-31)'
OPC$E318 DC    AL2(X'E318'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'AGF',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'Add GX
               rande Fullword (64<-32)'
OPC$E319 DC    AL2(X'E319'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'SGF',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'SubtrX
               act Grande Fullword (64<-32)'
OPC$E31A DC    AL2(X'E31A'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'ALGF',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMX
               T)'R1,D2(X2,B2)',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'Add X
               Logical Grande Fullword (64<-32)'
OPC$E31B DC    AL2(X'E31B'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'SLGF',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMX
               T)'R1,D2(X2,B2)',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'SubtX
               ract Logical Grande Fullword (64<-32)'
OPC$E31C DC    AL2(X'E31C'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'MSGF',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMX
               T)'R1,D2(X2,B2)',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'MultX
               iply Single Grande Fullword (64<-32)'
OPC$E31D DC    AL2(X'E31D'),Y(X'0000'),XL2'0113',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'DSGF',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMX
               T)'R1,D2(X2,B2)',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'DiviX
               de Single Grande Fullword (64<-32)'
OPC$E31E DC    AL2(X'E31E'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LRV',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'  N3',CL(L'OP@DESCR)'Load X
               Reversed (32)'
OPC$E31F DC    AL2(X'E31F'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LRVH',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMX
               T)'R1,D2(X2,B2)',CL(L'OP@ATTR)'  N3',CL(L'OP@DESCR)'LoadX
                Reversed Halfword (16)'
OPC$E320 DC    AL2(X'E320'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'CG',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMT)X
               'R1,D2(X2,B2)',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'ComparX
               e Grande (64)'
OPC$E321 DC    AL2(X'E321'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLG',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'CompaX
               re Logical Grande (64)'
OPC$E324 DC    AL2(X'E324'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'STG',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'StoreX
                Grande (64)'
OPC$E326 DC    AL2(X'E326'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'CVDY',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMX
               T)'R1,D2(X2,B2)',CL(L'OP@ATTR)'  LD',CL(L'OP@DESCR)'ConvX
               ert to Decimal Long (32, 20-bit Long Displacement)'
OPC$E32E DC    AL2(X'E32E'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'CVDG',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMX
               T)'R1,D2(X2,B2)',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'ConvX
               ert to Decimal Grande (64)'
OPC$E32F DC    AL2(X'E32F'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'STRVG',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORX
               MT)'R1,D2(X2,B2)',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'StoX
               re Reversed Grande (64)'
OPC$E330 DC    AL2(X'E330'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'CGF',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'CompaX
               re Grande Fullword (64<-32)'
OPC$E331 DC    AL2(X'E331'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLGF',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMX
               T)'R1,D2(X2,B2)',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'CompX
               are Logical Grande Fullword (64<-32)'
OPC$E332 DC    AL2(X'E332'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LTGF',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMX
               T)'R1,D2(X2,B2)',CL(L'OP@ATTR)'c GE',CL(L'OP@DESCR)'LoadX
                And Test Grande Fullword (64<-32)'
OPC$E334 DC    AL2(X'E334'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'CGH',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'c GE',CL(L'OP@DESCR)'CompaX
               re Grande Halfword (64<-16)'
OPC$E336 DC    AL2(X'E336'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'PFD',CL(L'OP@TYPE)'RXY-b',CL(L'OP@FORMTX
               )'M1,D2(X2,B2)',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'PrefeX
               tch Data'
OPC$E33E DC    AL2(X'E33E'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'STRV',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMX
               T)'R1,D2(X2,B2)',CL(L'OP@ATTR)'  N3',CL(L'OP@DESCR)'StorX
               e Reversed (32)'
OPC$E33F DC    AL2(X'E33F'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'STRVH',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORX
               MT)'R1,D2(X2,B2)',CL(L'OP@ATTR)'  N3',CL(L'OP@DESCR)'StoX
               re Reversed Halfword (16)'
OPC$E346 DC    AL2(X'E346'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'BCTG',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMX
               T)'R1,D2(X2,B2)',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'BranX
               ch on Count Grande (64)'
OPC$E350 DC    AL2(X'E350'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'STY',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'  LD',CL(L'OP@DESCR)'StoreX
                Long ((32), 20-bit Long Displacement)'
OPC$E351 DC    AL2(X'E351'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'MSY',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'  LD',CL(L'OP@DESCR)'MultiX
               ply Single Long ((32), 20-bit Long Displacement)'
OPC$E354 DC    AL2(X'E354'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'NY',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMT)X
               'R1,D2(X2,B2)',CL(L'OP@ATTR)'c LD',CL(L'OP@DESCR)'And LoX
               ng ((32), 20-bit Long Displacement)'
OPC$E355 DC    AL2(X'E355'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLY',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'c LD',CL(L'OP@DESCR)'CompaX
               re Logical Long ((32), 20-bit Long Displacement)'
OPC$E356 DC    AL2(X'E356'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'OY',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMT)X
               'R1,D2(X2,B2)',CL(L'OP@ATTR)'c LD',CL(L'OP@DESCR)'Or LonX
               g ((32), 20-bit Long Displacement)'
OPC$E357 DC    AL2(X'E357'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'XY',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMT)X
               'R1,D2(X2,B2)',CL(L'OP@ATTR)'c LD',CL(L'OP@DESCR)'ExclusX
               ive Or Long ((32), 20-bit Long Displacement)'
OPC$E358 DC    AL2(X'E358'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LY',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMT)X
               'R1,D2(X2,B2)',CL(L'OP@ATTR)'  LD',CL(L'OP@DESCR)'Load LX
               ong ((32), 20-bit Long Displacement)'
OPC$E359 DC    AL2(X'E359'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'CY',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMT)X
               'R1,D2(X2,B2)',CL(L'OP@ATTR)'c LD',CL(L'OP@DESCR)'ComparX
               e Long ((32), 20-bit Long Displacement)'
OPC$E35A DC    AL2(X'E35A'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'AY',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMT)X
               'R1,D2(X2,B2)',CL(L'OP@ATTR)'c LD',CL(L'OP@DESCR)'Add LoX
               ng ((32), 20-bit Long Displacement)'
OPC$E35B DC    AL2(X'E35B'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'SY',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMT)X
               'R1,D2(X2,B2)',CL(L'OP@ATTR)'c LD',CL(L'OP@DESCR)'SubtraX
               ct Long ((32), 20-bit Long Displacement)'
OPC$E35C DC    AL2(X'E35C'),Y(X'0000'),XL2'0113',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'MFY',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'MultiX
               ply Long (20-bit Long Displacement)'
OPC$E35E DC    AL2(X'E35E'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'ALY',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'c LD',CL(L'OP@DESCR)'Add LX
               ogical Long ((32), 20-bit Long Displacement)'
OPC$E35F DC    AL2(X'E35F'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'SLY',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'c LD',CL(L'OP@DESCR)'SubtrX
               act Logical Long ((32), 20-bit Long Displacement)'
OPC$E370 DC    AL2(X'E370'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'STHY',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMX
               T)'R1,D2(X2,B2)',CL(L'OP@ATTR)'  LD',CL(L'OP@DESCR)'StorX
               e Halfword Long (20-bit Long Displacement)'
OPC$E371 DC    AL2(X'E371'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LAY',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'  LD',CL(L'OP@DESCR)'Load X
               Address Long (20-bit Long Displacement)'
OPC$E372 DC    AL2(X'E372'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'STCY',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMX
               T)'R1,D2(X2,B2)',CL(L'OP@ATTR)'  LD',CL(L'OP@DESCR)'StorX
               e Character Long (20-bit Long Displacement)'
OPC$E373 DC    AL2(X'E373'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'ICY',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'  LD',CL(L'OP@DESCR)'InserX
               t Character Long (20-bit Long Displacement)'
OPC$E375 DC    AL2(X'E375'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LAEY',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMX
               T)'R1,D2(X2,B2)',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'LoadX
                Address Extended Long (20-bit Long Displacement)'
OPC$E376 DC    AL2(X'E376'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LB',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMT)X
               'R1,D2(X2,B2)',CL(L'OP@ATTR)'  LD',CL(L'OP@DESCR)'Load BX
               yte (32)'
OPC$E377 DC    AL2(X'E377'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LGB',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'  LD',CL(L'OP@DESCR)'Load X
               Grande Byte (64<-8)'
OPC$E378 DC    AL2(X'E378'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LHY',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'  LD',CL(L'OP@DESCR)'Load X
               Halfword Long (32<-16, 20-bit Long Displacement)'
OPC$E379 DC    AL2(X'E379'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'CHY',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'c LD',CL(L'OP@DESCR)'CompaX
               re Halfword Long (32<-I16, 20-bit Long Displacement)'
OPC$E37A DC    AL2(X'E37A'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'AHY',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'c LD',CL(L'OP@DESCR)'Add HX
               alfword Long (32<-16, 20-bit Long Displacement)'
OPC$E37B DC    AL2(X'E37B'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'SHY',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'c LD',CL(L'OP@DESCR)'SubtrX
               act Halfword Long (32<-16, 20-bit Long Displacement)'
OPC$E37C DC    AL2(X'E37C'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'MHY',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'MultiX
               ply Halfword Long (20-bit Long Displacement)'
OPC$E380 DC    AL2(X'E380'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'NG',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMT)X
               'R1,D2(X2,B2)',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'And GrX
               ande (64)'
OPC$E381 DC    AL2(X'E381'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'OG',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMT)X
               'R1,D2(X2,B2)',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'Or GraX
               nde (64)'
OPC$E382 DC    AL2(X'E382'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'XG',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMT)X
               'R1,D2(X2,B2)',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'ExclusX
               ive Or Grande (64)'
OPC$E386 DC    AL2(X'E386'),Y(X'0000'),XL2'0113',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'MLG',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'MultiX
               ply Logical Grande (128<-64)'
OPC$E387 DC    AL2(X'E387'),Y(X'0000'),XL2'0113',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'DLG',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'DividX
               e Logical Grande (64<-128)'
OPC$E388 DC    AL2(X'E388'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'ALCG',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMX
               T)'R1,D2(X2,B2)',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'Add X
               Logical with Carry Grande (64)'
OPC$E389 DC    AL2(X'E389'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'SLBG',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMX
               T)'R1,D2(X2,B2)',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'SubtX
               ract Logical with Borrow Grande (64)'
OPC$E38E DC    AL2(X'E38E'),Y(X'0000'),XL2'0113',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'STPQ',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMX
               T)'R1,D2(X2,B2)',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'StorX
               e Pair to Quadword'
OPC$E38F DC    AL2(X'E38F'),Y(X'0000'),XL2'0113',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LPQ',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'Load X
               Pair from Quadword'
OPC$E390 DC    AL2(X'E390'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LLGC',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMX
               T)'R1,D2(X2,B2)',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'LoadX
                Logical Grande Character (64<-8)'
OPC$E391 DC    AL2(X'E391'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LLGH',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMX
               T)'R1,D2(X2,B2)',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'LoadX
                Logical Grande Halfword (64<-16)'
OPC$E394 DC    AL2(X'E394'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LLC',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'  EI',CL(L'OP@DESCR)'Load X
               Logical Character (32<-8)'
OPC$E395 DC    AL2(X'E395'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LLH',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'  EI',CL(L'OP@DESCR)'Load X
               Logical Halfword (32<-16)'
OPC$E396 DC    AL2(X'E396'),Y(X'0000'),XL2'0113',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'ML',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMT)X
               'R1,D2(X2,B2)',CL(L'OP@ATTR)'  N3',CL(L'OP@DESCR)'MultipX
               ly Logical (64<-32)'
OPC$E397 DC    AL2(X'E397'),Y(X'0000'),XL2'0113',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'DL',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMT)X
               'R1,D2(X2,B2)',CL(L'OP@ATTR)'  N3',CL(L'OP@DESCR)'DivideX
                Logical (32<-64)'
OPC$E398 DC    AL2(X'E398'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'ALC',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'c N3',CL(L'OP@DESCR)'Add LX
               ogical with Carry (32)'
OPC$E399 DC    AL2(X'E399'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'SLB',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'c N3',CL(L'OP@DESCR)'SubtrX
               act Logical with Borrow (32)'
OPC$E3C0 DC    AL2(X'E3C0'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LBH',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'  HW',CL(L'OP@DESCR)'Load X
               Byte High (20-bit Long Displacement)'
OPC$E3C2 DC    AL2(X'E3C2'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LLCH',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMX
               T)'R1,D2(X2,B2)',CL(L'OP@ATTR)'  HW',CL(L'OP@DESCR)'LoadX
                Logical Character High (20-bit Long Displacement)'
OPC$E3C3 DC    AL2(X'E3C3'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'STCH',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMX
               T)'R1,D2(X2,B2)',CL(L'OP@ATTR)'  HW',CL(L'OP@DESCR)'StorX
               e Character High (20-bit Long Displacement)'
OPC$E3C4 DC    AL2(X'E3C4'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LHH',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'  HW',CL(L'OP@DESCR)'Load X
               Halfword High (20-bit Long Displacement)'
OPC$E3C6 DC    AL2(X'E3C6'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LLHH',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMX
               T)'R1,D2(X2,B2)',CL(L'OP@ATTR)'  HW',CL(L'OP@DESCR)'LoadX
                Logical Halfword High (20-bit Long Displacement)'
OPC$E3C7 DC    AL2(X'E3C7'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'STHH',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMX
               T)'R1,D2(X2,B2)',CL(L'OP@ATTR)'  HW',CL(L'OP@DESCR)'StorX
               e Halfword High (20-bit Long Displacement)'
OPC$E3CA DC    AL2(X'E3CA'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LFH',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'  HW',CL(L'OP@DESCR)'Load X
               Fullword High (20-bit Long Displacement)'
OPC$E3CB DC    AL2(X'E3CB'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'STFH',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMX
               T)'R1,D2(X2,B2)',CL(L'OP@ATTR)'  HW',CL(L'OP@DESCR)'StorX
               e Fullword High (20-bit Long Displacement)'
OPC$E3CD DC    AL2(X'E3CD'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'CHF',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'c HW',CL(L'OP@DESCR)'CompaX
               re High Fullword (20-bit Long Displacement)'
OPC$E3CF DC    AL2(X'E3CF'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLHF',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMX
               T)'R1,D2(X2,B2)',CL(L'OP@ATTR)'c HW',CL(L'OP@DESCR)'CompX
               are Logical High Fullword'
OPC$E500 DC    AL2(X'E500'),Y(X'0000'),XL2'001E',Y(X'0602'),AD(00000000X
               ),CL(L'OP@MNEUM)'LASP',CL(L'OP@TYPE)'SSE',CL(L'OP@FORMT)X
               'D1(B1),D2(B2)',CL(L'OP@ATTR)'pc  ',CL(L'OP@DESCR)'Load X
               Address Space Parameters'
OPC$E501 DC    AL2(X'E501'),Y(X'0000'),XL2'001E',Y(X'0602'),AD(00000000X
               ),CL(L'OP@MNEUM)'TPROT',CL(L'OP@TYPE)'SSE',CL(L'OP@FORMTX
               )'D1(B1),D2(B2)',CL(L'OP@ATTR)'pc  ',CL(L'OP@DESCR)'TestX
                Protection'
OPC$E502 DC    AL2(X'E502'),Y(X'0000'),XL2'001E',Y(X'0602'),AD(00000000X
               ),CL(L'OP@MNEUM)'STRAG',CL(L'OP@TYPE)'SSE',CL(L'OP@FORMTX
               )'D1(B1),D2(B2)',CL(L'OP@ATTR)'p N ',CL(L'OP@DESCR)'StorX
               e Real Address Grande'
OPC$E50E DC    AL2(X'E50E'),Y(X'0000'),XL2'001E',Y(X'0602'),AD(00000000X
               ),CL(L'OP@MNEUM)'MVCSK',CL(L'OP@TYPE)'SSE',CL(L'OP@FORMTX
               )'D1(B1),D2(B2)',CL(L'OP@ATTR)'q   ',CL(L'OP@DESCR)'MoveX
                with Source Key'
OPC$E50F DC    AL2(X'E50F'),Y(X'0000'),XL2'001E',Y(X'0602'),AD(00000000X
               ),CL(L'OP@MNEUM)'MVCDK',CL(L'OP@TYPE)'SSE',CL(L'OP@FORMTX
               )'D1(B1),D2(B2)',CL(L'OP@ATTR)'q   ',CL(L'OP@DESCR)'MoveX
                with Destination Key'
OPC$E544 DC    AL2(X'E544'),Y(X'0000'),XL2'0015',Y(X'0602'),AD(00000000X
               ),CL(L'OP@MNEUM)'MVHHI',CL(L'OP@TYPE)'SIL',CL(L'OP@FORMTX
               )'D1(B1),I2',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'Move HalX
               fword Halfword-Immediate (16<-I16)'
OPC$E548 DC    AL2(X'E548'),Y(X'0000'),XL2'0015',Y(X'0602'),AD(00000000X
               ),CL(L'OP@MNEUM)'MVGHI',CL(L'OP@TYPE)'SIL',CL(L'OP@FORMTX
               )'D1(B1),I2',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'Move GraX
               nde Halfword-Immediate (64<-I16)'
OPC$E54C DC    AL2(X'E54C'),Y(X'0000'),XL2'0015',Y(X'0602'),AD(00000000X
               ),CL(L'OP@MNEUM)'MVHI',CL(L'OP@TYPE)'SIL',CL(L'OP@FORMT)X
               'D1(B1),I2',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'Move HalfX
               word Immediate (32<-I16)'
OPC$E554 DC    AL2(X'E554'),Y(X'0000'),XL2'0015',Y(X'0602'),AD(00000000X
               ),CL(L'OP@MNEUM)'CHHSI',CL(L'OP@TYPE)'SIL',CL(L'OP@FORMTX
               )'D1(B1),I2',CL(L'OP@ATTR)'c GE',CL(L'OP@DESCR)'Compare X
               Halfword to Halfword-Signed-Immediate (16<-I16)'
OPC$E555 DC    AL2(X'E555'),Y(X'0000'),XL2'0015',Y(X'0602'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLHHSI',CL(L'OP@TYPE)'SIL',CL(L'OP@FORMX
               T)'D1(B1),I2',CL(L'OP@ATTR)'c GE',CL(L'OP@DESCR)'CompareX
                Logical Halfword to Halfword-Signless-Immediate (16<-I1X
               6)'
OPC$E558 DC    AL2(X'E558'),Y(X'0000'),XL2'0015',Y(X'0602'),AD(00000000X
               ),CL(L'OP@MNEUM)'CGHSI',CL(L'OP@TYPE)'SIL',CL(L'OP@FORMTX
               )'D1(B1),I2',CL(L'OP@ATTR)'c GE',CL(L'OP@DESCR)'Compare X
               Grande to Halfword-Signed-Extended Immediate (64<-I16)'
OPC$E559 DC    AL2(X'E559'),Y(X'0000'),XL2'0015',Y(X'0602'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLGHSI',CL(L'OP@TYPE)'SIL',CL(L'OP@FORMX
               T)'D1(B1),I2',CL(L'OP@ATTR)'c GE',CL(L'OP@DESCR)'CompareX
                Logical Grande to Halfword-Sign-Extended Immediate (64<X
               -I16)'
OPC$E55C DC    AL2(X'E55C'),Y(X'0000'),XL2'0015',Y(X'0602'),AD(00000000X
               ),CL(L'OP@MNEUM)'CHSI',CL(L'OP@TYPE)'SIL',CL(L'OP@FORMT)X
               'D1(B1),I2',CL(L'OP@ATTR)'c GE',CL(L'OP@DESCR)'Compare FX
               ullword to Halfword-Signed-Extended Immediate (32<-I16)'
OPC$E55D DC    AL2(X'E55D'),Y(X'0000'),XL2'0015',Y(X'0602'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLFHSI',CL(L'OP@TYPE)'SIL',CL(L'OP@FORMX
               T)'D1(B1),I2',CL(L'OP@ATTR)'c GE',CL(L'OP@DESCR)'CompareX
                Logical Fullword to Halfword-Sign-Extended Immediate (3X
               2<-I16)'
OPC$E8   DC    AL2(X'E800'),Y(X'0000'),XL2'0018',Y(X'0601'),AD(00000000X
               ),CL(L'OP@MNEUM)'MVCIN',CL(L'OP@TYPE)'SS-a',CL(L'OP@FORMX
               T)'D1(L,B1),D2(B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'MX
               ove Character Inverse'
OPC$E9   DC    AL2(X'E900'),Y(X'0000'),XL2'001B',Y(X'0601'),AD(00000000X
               ),CL(L'OP@MNEUM)'PKA',CL(L'OP@TYPE)'SS-f',CL(L'OP@FORMT)X
               'D1(B1),D2(L2,B2)',CL(L'OP@ATTR)'  E2',CL(L'OP@DESCR)'PaX
               ck ASCII'
OPC$EA   DC    AL2(X'EA00'),Y(X'0000'),XL2'0018',Y(X'0601'),AD(00000000X
               ),CL(L'OP@MNEUM)'UNPKA',CL(L'OP@TYPE)'SS-a',CL(L'OP@FORMX
               T)'D1(L1,B1),D2(B2)',CL(L'OP@ATTR)'c E2',CL(L'OP@DESCR)'X
               Unpack ASCII'
OPC$EB04 DC    AL2(X'EB04'),Y(X'0000'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LMG',CL(L'OP@TYPE)'RSY-a',CL(L'OP@FORMTX
               )'R1,R3,D2(B2)',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'Load X
               Multiple Grande (64)'
OPC$EB06 DC    AL2(X'EB06'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'CVBY',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMX
               T)'R1,D2(X2,B2)',CL(L'OP@ATTR)'  LD',CL(L'OP@DESCR)'ConvX
               ert to Binary Long ((32), 20-bit Long Displacement)'
OPC$EB0A DC    AL2(X'EB0A'),Y(X'0008'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'SRAG',CL(L'OP@TYPE)'RSY-a',CL(L'OP@FORMX
               T)'R1,R3,D2(B2)',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'ShifX
               t Right Single Algebraic Grande (64)'
OPC$EB0B DC    AL2(X'EB0B'),Y(X'0008'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'SLAG',CL(L'OP@TYPE)'RSY-a',CL(L'OP@FORMX
               T)'R1,R3,D2(B2)',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'ShifX
               t Left Single Algebraic Grande (64)'
OPC$EB0C DC    AL2(X'EB0C'),Y(X'0008'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'SRLG',CL(L'OP@TYPE)'RSY-a',CL(L'OP@FORMX
               T)'R1,R3,D2(B2)',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'ShifX
               t Right Single Logical Grande (64)'
OPC$EB0D DC    AL2(X'EB0D'),Y(X'0008'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'SLLG',CL(L'OP@TYPE)'RSY-a',CL(L'OP@FORMX
               T)'R1,R3,D2(B2)',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'ShifX
               t Left Single Logical Grande (64)'
OPC$EB0F DC    AL2(X'EB0F'),Y(X'0000'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'TRACG',CL(L'OP@TYPE)'RSY-a',CL(L'OP@FORX
               MT)'R1,R3,D2(B2)',CL(L'OP@ATTR)'p N ',CL(L'OP@DESCR)'TraX
               ce Grande (64)'
OPC$EB14 DC    AL2(X'EB14'),Y(X'0000'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'CSY',CL(L'OP@TYPE)'RSY-a',CL(L'OP@FORMTX
               )'R1,R3,D2(B2)',CL(L'OP@ATTR)'c LD',CL(L'OP@DESCR)'CompaX
               re and Swap Long ((32), 20-bit Long Displacement'
OPC$EB1C DC    AL2(X'EB1C'),Y(X'0008'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'RLLG',CL(L'OP@TYPE)'RSY-a',CL(L'OP@FORMX
               T)'R1,R3,D2(B2)',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'RotaX
               te Left Single Logical Grande (64)'
OPC$EB1D DC    AL2(X'EB1D'),Y(X'0008'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'RLL',CL(L'OP@TYPE)'RSY-a',CL(L'OP@FORMTX
               )'R1,R3,D2(B2)',CL(L'OP@ATTR)'  N3',CL(L'OP@DESCR)'RotatX
               e Left Single Logical (32)'
OPC$EB20 DC    AL2(X'EB20'),Y(X'0008'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLMH',CL(L'OP@TYPE)'RSY-b',CL(L'OP@FORMX
               T)'R1,M3,D2(B2)',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'CompX
               are Logical Characters under Mask High'
OPC$EB21 DC    AL2(X'EB21'),Y(X'0008'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLMY',CL(L'OP@TYPE)'RSY-b',CL(L'OP@FORMX
               T)'R1,M3,D2(B2)',CL(L'OP@ATTR)'c LD',CL(L'OP@DESCR)'CompX
               are Logical Characters under Mask'
OPC$EB24 DC    AL2(X'EB24'),Y(X'0000'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'STMG',CL(L'OP@TYPE)'RSY-a',CL(L'OP@FORMX
               T)'R1,R3,D2(B2)',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'StorX
               e Multiple Grande (64)'
OPC$EB25 DC    AL2(X'EB25'),Y(X'0000'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'STCTG',CL(L'OP@TYPE)'RSY-a',CL(L'OP@FORX
               MT)'R1,R3,D2(B2)',CL(L'OP@ATTR)'p N ',CL(L'OP@DESCR)'StoX
               re Control Grande (64)'
OPC$EB26 DC    AL2(X'EB26'),Y(X'0000'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'STMH',CL(L'OP@TYPE)'RSY-a',CL(L'OP@FORMX
               T)'R1,R3,D2(B2)',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'StorX
               e Multiple High'
OPC$EB2C DC    AL2(X'EB2C'),Y(X'0008'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'STCMH',CL(L'OP@TYPE)'RSY-b',CL(L'OP@FORX
               MT)'R1,M3,D2(B2)',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'StoX
               re Characters under Mask High'
OPC$EB2D DC    AL2(X'EB2D'),Y(X'0008'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'STCMY',CL(L'OP@TYPE)'RSY-b',CL(L'OP@FORX
               MT)'R1,M3,D2(B2)',CL(L'OP@ATTR)'  LD',CL(L'OP@DESCR)'StoX
               re Characters under Mask Long (20-bit Long Displacement)X
               '
OPC$EB2F DC    AL2(X'EB2F'),Y(X'0000'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LCTLG',CL(L'OP@TYPE)'RSY-a',CL(L'OP@FORX
               MT)'R1,R3,D2(B2)',CL(L'OP@ATTR)'p N ',CL(L'OP@DESCR)'LoaX
               d Control Grande (64)'
OPC$EB30 DC    AL2(X'EB30'),Y(X'0000'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'CSG',CL(L'OP@TYPE)'RSY-a',CL(L'OP@FORMTX
               )'R1,R3,D2(B2)',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'CompaX
               re and Swap Grande (64)'
OPC$EB31 DC    AL2(X'EB31'),Y(X'0000'),XL2'050F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'CDSY',CL(L'OP@TYPE)'RSY-a',CL(L'OP@FORMX
               T)'R1,R3,D2(B2)',CL(L'OP@ATTR)'c LD',CL(L'OP@DESCR)'CompX
               are Double and Swap Long ((32), 20-bit Long DisplacementX
               )'
OPC$EB3E DC    AL2(X'EB3E'),Y(X'0000'),XL2'050F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'CDSG',CL(L'OP@TYPE)'RSY-a',CL(L'OP@FORMX
               T)'R1,R3,D2(B2)',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'CompX
               are Double and Swap Grande (64)'
OPC$EB44 DC    AL2(X'EB44'),Y(X'0000'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'BXHG',CL(L'OP@TYPE)'RSY-a',CL(L'OP@FORMX
               T)'R1,R3,D2(B2)',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'BranX
               ch on Index High Grande'
OPC$EB45 DC    AL2(X'EB45'),Y(X'0000'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'BXLEG',CL(L'OP@TYPE)'RSY-a',CL(L'OP@FORX
               MT)'R1,R3,D2(B2)',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'BraX
               nch on Index Low or Equal Grande (64)'
OPC$EB4C DC    AL2(X'EB4C'),Y(X'0000'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'ECAG',CL(L'OP@TYPE)'RSY-a',CL(L'OP@FORMX
               T)'R1,R3,D2(B2)',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'ExtrX
               act Cache Attribute Grande'
OPC$EB51 DC    AL2(X'EB51'),Y(X'0000'),XL2'0017',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'TMY',CL(L'OP@TYPE)'SIY',CL(L'OP@FORMT)'X
               D1(B1),I2',CL(L'OP@ATTR)'c LD',CL(L'OP@DESCR)'Test underX
                Mask Long (20-bit Long Displacement)'
OPC$EB52 DC    AL2(X'EB52'),Y(X'0000'),XL2'0017',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'MVIY',CL(L'OP@TYPE)'SIY',CL(L'OP@FORMT)X
               'D1(B1),I2',CL(L'OP@ATTR)'  LD',CL(L'OP@DESCR)'Move ImmeX
               diate Long (20-bit Long Displacement)'
OPC$EB54 DC    AL2(X'EB54'),Y(X'0000'),XL2'0017',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'NIY',CL(L'OP@TYPE)'SIY',CL(L'OP@FORMT)'X
               D1(B1),I2',CL(L'OP@ATTR)'c LD',CL(L'OP@DESCR)'And ImmediX
               ate Long (20-bit Long Displacement)'
OPC$EB55 DC    AL2(X'EB55'),Y(X'0000'),XL2'0017',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLIY',CL(L'OP@TYPE)'SIY',CL(L'OP@FORMT)X
               'D1(B1),I2',CL(L'OP@ATTR)'c LD',CL(L'OP@DESCR)'Compare LX
               ogical Immediate Long (20-bit Long Displacement)'
OPC$EB56 DC    AL2(X'EB56'),Y(X'0000'),XL2'0017',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'OIY',CL(L'OP@TYPE)'SIY',CL(L'OP@FORMT)'X
               D1(B1),I2',CL(L'OP@ATTR)'c LD',CL(L'OP@DESCR)'Or ImmediaX
               te Long (20-bit Long Displacement)'
OPC$EB57 DC    AL2(X'EB57'),Y(X'0000'),XL2'0017',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'XIY',CL(L'OP@TYPE)'SIY',CL(L'OP@FORMT)'X
               D1(B1),I2',CL(L'OP@ATTR)'c LD',CL(L'OP@DESCR)'Exclusive X
               Or Immediate Long (20-bit Long Displacement)'
OPC$EB6A DC    AL2(X'EB6A'),Y(X'0000'),XL2'0017',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'ASI',CL(L'OP@TYPE)'SIY',CL(L'OP@FORMT)'X
               D1(B1),I2',CL(L'OP@ATTR)'c GE',CL(L'OP@DESCR)'Add SignedX
                Immediate (32<-I8)'
OPC$EB6E DC    AL2(X'EB6E'),Y(X'0000'),XL2'0017',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'ALSI',CL(L'OP@TYPE)'SIY',CL(L'OP@FORMT)X
               'D1(B1),I2',CL(L'OP@ATTR)'c GE',CL(L'OP@DESCR)'Add LogicX
               al with Signed Immediate (32<-I8)'
OPC$EB7A DC    AL2(X'EB7A'),Y(X'0000'),XL2'0017',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'AGSI',CL(L'OP@TYPE)'SIY',CL(L'OP@FORMT)X
               'D1(B1),I2',CL(L'OP@ATTR)'c GE',CL(L'OP@DESCR)'Add GrandX
               e with Signed Immediate (64<-I8)'
OPC$EB7E DC    AL2(X'EB7E'),Y(X'0000'),XL2'0017',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'ALGSI',CL(L'OP@TYPE)'SIY',CL(L'OP@FORMTX
               )'D1(B1),I2',CL(L'OP@ATTR)'c GE',CL(L'OP@DESCR)'Add LogiX
               cal Grande with Signed Immediate (64<-I8)'
OPC$EB80 DC    AL2(X'EB80'),Y(X'0008'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'ICMH',CL(L'OP@TYPE)'RSY-b',CL(L'OP@FORMX
               T)'R1,M3,D2(B2)',CL(L'OP@ATTR)'c N ',CL(L'OP@DESCR)'InseX
               rt Characters under Mask (high)'
OPC$EB81 DC    AL2(X'EB81'),Y(X'0008'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'ICMY',CL(L'OP@TYPE)'RSY-b',CL(L'OP@FORMX
               T)'R1,M3,D2(B2)',CL(L'OP@ATTR)'c LD',CL(L'OP@DESCR)'InseX
               rt Characters under Mask Long (Low, 20-bit Long DisplaceX
               ment)'
OPC$EB8E DC    AL2(X'EB8E'),Y(X'0080'),XL2'040F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'MVCLU',CL(L'OP@TYPE)'RSY-a',CL(L'OP@FORX
               MT)'R1,R3,D2(B2)',CL(L'OP@ATTR)'c E2',CL(L'OP@DESCR)'MovX
               e Character Long Unicode'
OPC$EB8F DC    AL2(X'EB8F'),Y(X'0080'),XL2'040F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLCLU',CL(L'OP@TYPE)'RSY-a',CL(L'OP@FORX
               MT)'R1,R3,D2(B2)',CL(L'OP@ATTR)'c E2',CL(L'OP@DESCR)'ComX
               pare Logical Character Long Unicode'
OPC$EB90 DC    AL2(X'EB90'),Y(X'0000'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'STMY',CL(L'OP@TYPE)'RSY-a',CL(L'OP@FORMX
               T)'R1,R3,D2(B2)',CL(L'OP@ATTR)'  LD',CL(L'OP@DESCR)'StorX
               e Multiple Long (32, 20-bit Long Displacement)'
OPC$EB96 DC    AL2(X'EB96'),Y(X'0000'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LMH',CL(L'OP@TYPE)'RSY-a',CL(L'OP@FORMTX
               )'R1,R3,D2(B2)',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'Load X
               Multiple High'
OPC$EB98 DC    AL2(X'EB98'),Y(X'0000'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LMY',CL(L'OP@TYPE)'RSY-a',CL(L'OP@FORMTX
               )'R1,R3,D2(B2)',CL(L'OP@ATTR)'  LD',CL(L'OP@DESCR)'Load X
               Multiple Long (32, 20-bit Long Displacement)'
OPC$EB9A DC    AL2(X'EB9A'),Y(X'0000'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LAMY',CL(L'OP@TYPE)'RSY-a',CL(L'OP@FORMX
               T)'R1,R3,D2(B2)',CL(L'OP@ATTR)'  LD',CL(L'OP@DESCR)'LoadX
                Access Multiple Long (20-bit Long Displacement)'
OPC$EB9B DC    AL2(X'EB9B'),Y(X'0000'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'STAMY',CL(L'OP@TYPE)'RSY-a',CL(L'OP@FORX
               MT)'R1,R3,D2(B2)',CL(L'OP@ATTR)'  LD',CL(L'OP@DESCR)'StoX
               re Access Multiple Long (20-bit Long Displacement)'
OPC$EBC0 DC    AL2(X'EBC0'),Y(X'0000'),XL2'000E',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'TP',CL(L'OP@TYPE)'RSL',CL(L'OP@FORMT)'DX
               1(L1,B1)',CL(L'OP@ATTR)'c E2',CL(L'OP@DESCR)'Test PackedX
                Decimal'
OPC$EBDC DC    AL2(X'EBDC'),Y(X'0008'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'SRAK',CL(L'OP@TYPE)'RSY-a',CL(L'OP@FORMX
               T)'R1,R3,D2(B2)',CL(L'OP@ATTR)'c DO',CL(L'OP@DESCR)'ShifX
               t Right Single Algebraic Distinct (32)'
OPC$EBDD DC    AL2(X'EBDD'),Y(X'0008'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'SLAK',CL(L'OP@TYPE)'RSY-a',CL(L'OP@FORMX
               T)'R1,R3,D2(B2)',CL(L'OP@ATTR)'c DO',CL(L'OP@DESCR)'ShifX
               t Left Single Algebraic Distinct (32)'
OPC$EBDE DC    AL2(X'EBDE'),Y(X'0008'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'SRLK',CL(L'OP@TYPE)'RSY-a',CL(L'OP@FORMX
               T)'R1,R3,D2(B2)',CL(L'OP@ATTR)'  DO',CL(L'OP@DESCR)'ShifX
               t Right Single Logical Distinct (32)'
OPC$EBDF DC    AL2(X'EBDF'),Y(X'0008'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'SLLK',CL(L'OP@TYPE)'RSY-a',CL(L'OP@FORMX
               T)'R1,R3,D2(B2)',CL(L'OP@ATTR)'  DO',CL(L'OP@DESCR)'ShifX
               t Left Single Logical Distinct (32)'
OPC$EBE2 DC    AL2(X'EBE2'),Y(X'0000'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LOCG',CL(L'OP@TYPE)'RSY-b',CL(L'OP@FORMX
               T)'R1,D2(B2),M3',CL(L'OP@ATTR)'  CL',CL(L'OP@DESCR)'LoadX
                on Condition Grande (64)'
OPC$EBE3 DC    AL2(X'EBE3'),Y(X'0000'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'STOCG',CL(L'OP@TYPE)'RSY-b',CL(L'OP@FORX
               MT)'R1,D2(B2),M3',CL(L'OP@ATTR)'  CL',CL(L'OP@DESCR)'StoX
               re on Condition Grande (64)'
OPC$EBE4 DC    AL2(X'EBE4'),Y(X'0000'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LANG',CL(L'OP@TYPE)'RSY-a',CL(L'OP@FORMX
               T)'R1,R3,D2(B2)',CL(L'OP@ATTR)'c IA',CL(L'OP@DESCR)'LoadX
                and And Grande (64)'
OPC$EBE6 DC    AL2(X'EBE6'),Y(X'0000'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LAOG',CL(L'OP@TYPE)'RSY-a',CL(L'OP@FORMX
               T)'R1,R3,D2(B2)',CL(L'OP@ATTR)'c IA',CL(L'OP@DESCR)'LoadX
                And Or Grande (64)'
OPC$EBE7 DC    AL2(X'EBE7'),Y(X'0000'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LAXG',CL(L'OP@TYPE)'RSY-a',CL(L'OP@FORMX
               T)'R1,R3,D2(B2)',CL(L'OP@ATTR)'c IA',CL(L'OP@DESCR)'LoadX
                And Exclusive Or Grande (64)'
OPC$EBE8 DC    AL2(X'EBE8'),Y(X'0000'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LAAG',CL(L'OP@TYPE)'RSY-a',CL(L'OP@FORMX
               T)'R1,R3,D2(B2)',CL(L'OP@ATTR)'c IA',CL(L'OP@DESCR)'LoadX
                And Add Grande ((64), 20-bit Long Displacement)'
OPC$EBEA DC    AL2(X'EBEA'),Y(X'0000'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LAALG',CL(L'OP@TYPE)'RSY-a',CL(L'OP@FORX
               MT)'R1,R3,D2(B2)',CL(L'OP@ATTR)'c IA',CL(L'OP@DESCR)'LoaX
               d And Add Logical Grande ((64), 20-bit Long DisplacementX
               )'
OPC$EBF2 DC    AL2(X'EBF2'),Y(X'0000'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LOC',CL(L'OP@TYPE)'RSY-b',CL(L'OP@FORMTX
               )'R1,D2(B2),M3',CL(L'OP@ATTR)'  CL',CL(L'OP@DESCR)'Load X
               On Condition (32)'
OPC$EBF3 DC    AL2(X'EBF3'),Y(X'0000'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'STOC',CL(L'OP@TYPE)'RSY-b',CL(L'OP@FORMX
               T)'R1,D2(B2),M3',CL(L'OP@ATTR)'  CL',CL(L'OP@DESCR)'StorX
               e On Condition (32)'
OPC$EBF4 DC    AL2(X'EBF4'),Y(X'0000'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LAN',CL(L'OP@TYPE)'RSY-a',CL(L'OP@FORMTX
               )'R1,R3,D2(B2)',CL(L'OP@ATTR)'c IA',CL(L'OP@DESCR)'Load X
               and And (32)'
OPC$EBF6 DC    AL2(X'EBF6'),Y(X'0000'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LAO',CL(L'OP@TYPE)'RSY-a',CL(L'OP@FORMTX
               )'R1,R3,D2(B2)',CL(L'OP@ATTR)'c IA',CL(L'OP@DESCR)'Load X
               And Or (32)'
OPC$EBF7 DC    AL2(X'EBF7'),Y(X'0000'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LAX',CL(L'OP@TYPE)'RSY-a',CL(L'OP@FORMTX
               )'R1,R3,D2(B2)',CL(L'OP@ATTR)'c IA',CL(L'OP@DESCR)'Load X
               And Exclusive Or (32)'
OPC$EBF8 DC    AL2(X'EBF8'),Y(X'0000'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LAA',CL(L'OP@TYPE)'RSY-a',CL(L'OP@FORMTX
               )'R1,R3,D2(B2)',CL(L'OP@ATTR)'c IA',CL(L'OP@DESCR)'Load X
               And Add (32)'
OPC$EBFA DC    AL2(X'EBFA'),Y(X'0000'),XL2'000F',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LAAL',CL(L'OP@TYPE)'RSY-a',CL(L'OP@FORMX
               T)'R1,R3,D2(B2)',CL(L'OP@ATTR)'c IA',CL(L'OP@DESCR)'LoadX
                And Add Logical (32)'
OPC$EC44 DC    AL2(X'EC44'),Y(X'0000'),XL2'0004',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'BRXHG',CL(L'OP@TYPE)'RIE-e',CL(L'OP@FORX
               MT)'R1,R3,RI2',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'BranchX
                Relative on Index High Grande (64)'
OPC$EC45 DC    AL2(X'EC45'),Y(X'0000'),XL2'0004',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'BRXLG',CL(L'OP@TYPE)'RIE-e',CL(L'OP@FORX
               MT)'R1,R3,RI2',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)'BranchX
                Relative on Index Low or Equal Grande (64)'
OPC$EC51 DC    AL2(X'EC51'),Y(X'0000'),XL2'0003',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'RISBLG',CL(L'OP@TYPE)'RIE-f',CL(L'OP@FOX
               RMT)'R1,R2,I3,I4,I5',CL(L'OP@ATTR)'  HW',CL(L'OP@DESCRX
               )'Rotate Then Insert Selected Bits Low Grande'
OPC$EC54 DC    AL2(X'EC54'),Y(X'0000'),XL2'0003',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'RNSBG',CL(L'OP@TYPE)'RIE-f',CL(L'OP@FORX
               MT)'R1,R2,I3,I4,I5',CL(L'OP@ATTR)'c GE',CL(L'OP@DESCR)X
               'Rotate Then AND Selected Bits Grande'
OPC$EC55 DC    AL2(X'EC55'),Y(X'0000'),XL2'0003',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'RISBG',CL(L'OP@TYPE)'RIE-f',CL(L'OP@FORX
               MT)'R1,R2,I3,I4,I5',CL(L'OP@ATTR)'c GE',CL(L'OP@DESCR)X
               'Rotate Then Insert Selected Bits Grande'
OPC$EC56 DC    AL2(X'EC56'),Y(X'0000'),XL2'0003',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'ROSBG',CL(L'OP@TYPE)'RIE-f',CL(L'OP@FORX
               MT)'R1,R2,I3,I4,I5',CL(L'OP@ATTR)'c GE',CL(L'OP@DESCR)X
               'Rotate Then OR Selected Bits Grande'
OPC$EC57 DC    AL2(X'EC57'),Y(X'0000'),XL2'0003',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'RXSBG',CL(L'OP@TYPE)'RIE-f',CL(L'OP@FORX
               MT)'R1,R2,I3,I4,I5',CL(L'OP@ATTR)'c GE',CL(L'OP@DESCR)X
               'Rotate Then Exclusive Or Selected Bits Grande'
OPC$EC5D DC    AL2(X'EC5D'),Y(X'0000'),XL2'0003',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'RISBHG',CL(L'OP@TYPE)'RIE-f',CL(L'OP@FOX
               RMT)'R1,R2,I3,I4,I5',CL(L'OP@ATTR)'  HW',CL(L'OP@DESCRX
               )'Rotate Then Insert Selected Bits High Grande'
OPC$EC64 DC    AL2(X'EC64'),Y(X'0000'),XL2'0003',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'CGRJ',CL(L'OP@TYPE)'RIE-b',CL(L'OP@FORMX
               T)'R1,R2,M3,RI4',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'CompX
               are Grande Register and Branch Relative'
OPC$EC65 DC    AL2(X'EC65'),Y(X'0000'),XL2'0003',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLGRJ',CL(L'OP@TYPE)'RIE-b',CL(L'OP@FORX
               MT)'R1,R2,M3,RI4',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'ComX
               pare Logical Grande Register and Branch Relative'
OPC$EC70 DC    AL2(X'EC70'),Y(X'0000'),XL2'0002',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'CGIT',CL(L'OP@TYPE)'RIE-a',CL(L'OP@FORMX
               T)'R1,I2,M3',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'Compare X
               Grande Immediate and Trap'
OPC$EC71 DC    AL2(X'EC71'),Y(X'0000'),XL2'0002',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLGIT',CL(L'OP@TYPE)'RIE-a',CL(L'OP@FORX
               MT)'R1,I2,M3',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'CompareX
                Logical Grande Immediate and Trap'
OPC$EC72 DC    AL2(X'EC72'),Y(X'0000'),XL2'0002',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'CIT',CL(L'OP@TYPE)'RIE-a',CL(L'OP@FORMTX
               )'R1,I2,M3',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'Compare IX
               mmediate and Trap'
OPC$EC73 DC    AL2(X'EC73'),Y(X'0000'),XL2'0002',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLFIT',CL(L'OP@TYPE)'RIE-a',CL(L'OP@FORX
               MT)'R1,I2,M3',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'CompareX
                Logical Fullword Immediate and Trap'
OPC$EC76 DC    AL2(X'EC76'),Y(X'0000'),XL2'0003',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'CRJ',CL(L'OP@TYPE)'RIE-b',CL(L'OP@FORMTX
               )'R1,R2,M3,RI4',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'CompaX
               re Register and Branch Relative'
OPC$EC77 DC    AL2(X'EC77'),Y(X'0000'),XL2'0003',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLRJ',CL(L'OP@TYPE)'RIE-b',CL(L'OP@FORMX
               T)'R1,R2,M3,RI4',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'CompX
               are Logical Register and Branch Relative'
OPC$EC7C DC    AL2(X'EC7C'),Y(X'0000'),XL2'0002',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'CGIJ',CL(L'OP@TYPE)'RIE-c',CL(L'OP@FORMX
               T)'R1,I2,M3,RI4',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'CompX
               are Grande Immediate and Branch Relative'
OPC$EC7D DC    AL2(X'EC7D'),Y(X'0000'),XL2'0002',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLGIJ',CL(L'OP@TYPE)'RIE-c',CL(L'OP@FORX
               MT)'R1,I2,M3,RI4',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'ComX
               pare Logical Grande Immediate and Branch Relative'
OPC$EC7E DC    AL2(X'EC7E'),Y(X'0000'),XL2'0002',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'CIJ',CL(L'OP@TYPE)'RIE-c',CL(L'OP@FORMTX
               )'R1,I2,M3,RI4',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'CompaX
               re Immediate and Branch Relative'
OPC$EC7F DC    AL2(X'EC7F'),Y(X'0000'),XL2'0002',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLIJ',CL(L'OP@TYPE)'RIE-c',CL(L'OP@FORMX
               T)'R1,I2,M3,RI4',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'CompX
               are Logical Immediate and Branch Relative'
OPC$ECD8 DC    AL2(X'ECD8'),Y(X'0000'),XL2'0004',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'AHIK',CL(L'OP@TYPE)'RIE-d',CL(L'OP@FORMX
               T)'R1,R3,I2',CL(L'OP@ATTR)'c DO',CL(L'OP@DESCR)'Add HalfX
               word Immediate Distinct (32<-16)'
OPC$ECD9 DC    AL2(X'ECD9'),Y(X'0000'),XL2'0004',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'AGHIK',CL(L'OP@TYPE)'RIE-d',CL(L'OP@FORX
               MT)'R1,R3,I2',CL(L'OP@ATTR)'c DO',CL(L'OP@DESCR)'Add GraX
               nde with Halfword Immediate Distinct (64<-16)'
OPC$ECDA DC    AL2(X'ECDA'),Y(X'0000'),XL2'0004',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'ALHSIK',CL(L'OP@TYPE)'RIE-d',CL(L'OP@FOX
               RMT)'R1,R3,I2',CL(L'OP@ATTR)'c DO',CL(L'OP@DESCR)'Add LoX
               gical Fullword with Halfword-Signed-Immediate Distinct (X
               32<-I16)'
OPC$ECDB DC    AL2(X'ECDB'),Y(X'0000'),XL2'0004',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'ALGHSIK',CL(L'OP@TYPE)'RIE-d',CL(L'OP@FX
               ORMT)'R1,R3,I2',CL(L'OP@ATTR)'c DO',CL(L'OP@DESCR)'Add LX
               ogical Grande with Halfword-Signed-Immediate Distinct (6X
               4<-I16)'
OPC$ECE4 DC    AL2(X'ECE4'),Y(X'0000'),XL2'000C',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'CGRB',CL(L'OP@TYPE)'RRS',CL(L'OP@FORMT)X
               'R1,R2,M3,D4(B4)',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'ComX
               pare Grande Register and Branch'
OPC$ECE5 DC    AL2(X'ECE5'),Y(X'0000'),XL2'000C',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLGRB',CL(L'OP@TYPE)'RRS',CL(L'OP@FORMTX
               )'R1,R2,M3,D4(B4)',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'CoX
               mpare Logical Grande Register and Branch'
OPC$ECF6 DC    AL2(X'ECF6'),Y(X'0000'),XL2'000C',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'CRB',CL(L'OP@TYPE)'RRS',CL(L'OP@FORMT)'X
               R1,R2,M3,D4(B4)',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'CompX
               are Register and Branch'
OPC$ECF7 DC    AL2(X'ECF7'),Y(X'0000'),XL2'000C',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLRB',CL(L'OP@TYPE)'RRS',CL(L'OP@FORMT)X
               'R1,R2,M3,D4(B4)',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'ComX
               pare Logical Register and Branch'
OPC$ECFC DC    AL2(X'ECFC'),Y(X'0000'),XL2'0005',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'CGIB',CL(L'OP@TYPE)'RIS',CL(L'OP@FORMT)X
               'R1,I2,M3,D4(B4)',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'ComX
               pare Grande Immediate and Branch'
OPC$ECFD DC    AL2(X'ECFD'),Y(X'0000'),XL2'0005',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLGIB',CL(L'OP@TYPE)'RIS',CL(L'OP@FORMTX
               )'R1,I2,M3,D4(B4)',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'CoX
               mpare Logical Grande Immediate and Branch'
OPC$ECFE DC    AL2(X'ECFE'),Y(X'0000'),XL2'0005',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'CIB',CL(L'OP@TYPE)'RIS',CL(L'OP@FORMT)'X
               R1,I2,M3,D4(B4)',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'CompX
               are Immediate and Branch'
OPC$ECFF DC    AL2(X'ECFF'),Y(X'0000'),XL2'0005',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'CLIB',CL(L'OP@TYPE)'RIS',CL(L'OP@FORMT)X
               'R1,I2,M3,D4(B4)',CL(L'OP@ATTR)'  GE',CL(L'OP@DESCR)'ComX
               pare Logical Immediate and Branch'
OPC$ED04 DC    AL2(X'ED04'),Y(X'0000'),XL2'0011',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LDEB',CL(L'OP@TYPE)'RXE',CL(L'OP@FORMT)X
               'R1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Load LX
               engthened Long Binary Floating Point from Short Binary FX
               loating Pnt'
OPC$ED05 DC    AL2(X'ED05'),Y(X'0000'),XL2'8011',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LXDB',CL(L'OP@TYPE)'RXE',CL(L'OP@FORMT)X
               'R1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Load LX
               engthened Extended Binary Floating Point from Long BFP'
OPC$ED06 DC    AL2(X'ED06'),Y(X'0000'),XL2'8011',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LXEB',CL(L'OP@TYPE)'RXE',CL(L'OP@FORMT)X
               'R1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Load LX
               engthened Extended Binary Floating Point from Short BFP'
OPC$ED07 DC    AL2(X'ED07'),Y(X'0000'),XL2'8011',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'MXDB',CL(L'OP@TYPE)'RXE',CL(L'OP@FORMT)X
               'R1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'MultipX
               ly Extended Binary Floating Point from Long Binary FloatX
               ing Point'
OPC$ED08 DC    AL2(X'ED08'),Y(X'0000'),XL2'0011',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'KEB',CL(L'OP@TYPE)'RXE',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'CompareX
                and Signal Short Binary Floating Point'
OPC$ED09 DC    AL2(X'ED09'),Y(X'0000'),XL2'0011',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'CEB',CL(L'OP@TYPE)'RXE',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'CompareX
                Short Binary Floating Point'
OPC$ED0A DC    AL2(X'ED0A'),Y(X'0000'),XL2'0011',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'AEB',CL(L'OP@TYPE)'RXE',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Add ShoX
               rt Binary Floating Point'
OPC$ED0B DC    AL2(X'ED0B'),Y(X'0000'),XL2'0011',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'SEB',CL(L'OP@TYPE)'RXE',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'SubtracX
               t Short Binary Floating Point'
OPC$ED0C DC    AL2(X'ED0C'),Y(X'0000'),XL2'0011',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'MDEB',CL(L'OP@TYPE)'RXE',CL(L'OP@FORMT)X
               'R1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'MultipX
               ly Long Binary Floating Point from Short Binary FloatingX
                Point'
OPC$ED0D DC    AL2(X'ED0D'),Y(X'0000'),XL2'0011',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'DEB',CL(L'OP@TYPE)'RXE',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Divide X
               Short Binary Floating Point'
OPC$ED0E DC    AL2(X'ED0E'),Y(X'0000'),XL2'0012',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'MAEB',CL(L'OP@TYPE)'RXF',CL(L'OP@FORMT)X
               'R1,R3,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'MulX
               tiply and Add Short Binary Floating Point'
OPC$ED0F DC    AL2(X'ED0F'),Y(X'0000'),XL2'0012',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'MSEB',CL(L'OP@TYPE)'RXF',CL(L'OP@FORMT)X
               'R1,R3,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'MulX
               tiply and Subtract Short Binary Floating Point'
OPC$ED10 DC    AL2(X'ED10'),Y(X'0000'),XL2'0011',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'TCEB',CL(L'OP@TYPE)'RXE',CL(L'OP@FORMT)X
               'R1,D2(X2,B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Test DX
               ata Class Short Binary Floating Point'
OPC$ED11 DC    AL2(X'ED11'),Y(X'0000'),XL2'0011',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'TCDB',CL(L'OP@TYPE)'RXE',CL(L'OP@FORMT)X
               'R1,D2(X2,B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Test DX
               ata Class Long Binary Floating Point'
OPC$ED12 DC    AL2(X'ED12'),Y(X'0000'),XL2'8011',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'TCXB',CL(L'OP@TYPE)'RXE',CL(L'OP@FORMT)X
               'R1,D2(X2,B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Test DX
               ata Class Extended Binary Floating Point'
OPC$ED14 DC    AL2(X'ED14'),Y(X'0000'),XL2'0011',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'SQEB',CL(L'OP@TYPE)'RXE',CL(L'OP@FORMT)X
               'R1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'SquareX
                Root Short Binary Floating Point'
OPC$ED15 DC    AL2(X'ED15'),Y(X'0000'),XL2'0011',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'SQDB',CL(L'OP@TYPE)'RXE',CL(L'OP@FORMT)X
               'R1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'SquareX
                Root Long Binary Floating Point'
OPC$ED17 DC    AL2(X'ED17'),Y(X'0000'),XL2'0011',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'MEEB',CL(L'OP@TYPE)'RXE',CL(L'OP@FORMT)X
               'R1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'MultipX
               ly Short Binary Floating Point from Short Binary FloatinX
               g Point'
OPC$ED18 DC    AL2(X'ED18'),Y(X'0000'),XL2'0011',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'KDB',CL(L'OP@TYPE)'RXE',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'CompareX
                and Signal Long Binary Binary Floating Point'
OPC$ED19 DC    AL2(X'ED19'),Y(X'0000'),XL2'0011',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'CDB',CL(L'OP@TYPE)'RXE',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'CompareX
                Long Binary Floating Point'
OPC$ED1A DC    AL2(X'ED1A'),Y(X'0000'),XL2'0011',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'ADB',CL(L'OP@TYPE)'RXE',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'Add LonX
               g Binary Floating Point'
OPC$ED1B DC    AL2(X'ED1B'),Y(X'0000'),XL2'0011',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'SDB',CL(L'OP@TYPE)'RXE',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'SubtracX
               t Long Binary Floating Point'
OPC$ED1C DC    AL2(X'ED1C'),Y(X'0000'),XL2'0011',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'MDB',CL(L'OP@TYPE)'RXE',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'MultiplX
               y Long Binary Floating Point'
OPC$ED1D DC    AL2(X'ED1D'),Y(X'0000'),XL2'0011',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'DDB',CL(L'OP@TYPE)'RXE',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Divide X
               Long Binary Floating Point'
OPC$ED1E DC    AL2(X'ED1E'),Y(X'0000'),XL2'0012',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'MADB',CL(L'OP@TYPE)'RXF',CL(L'OP@FORMT)X
               'R1,R3,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'MulX
               tiply and Add Long Binary Floating Point)'
OPC$ED1F DC    AL2(X'ED1F'),Y(X'0000'),XL2'0012',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'MSDB',CL(L'OP@TYPE)'RXF',CL(L'OP@FORMT)X
               'R1,R3,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'MulX
               tiply and Subtract Long Binary Floating Point'
OPC$ED24 DC    AL2(X'ED24'),Y(X'0000'),XL2'0011',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LDE',CL(L'OP@TYPE)'RXE',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Load LeX
               ngthened Long Hexidecimal Floating Point from Short HFP'
OPC$ED25 DC    AL2(X'ED25'),Y(X'0000'),XL2'8011',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LXD',CL(L'OP@TYPE)'RXE',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Load LeX
               ngthened Extended Hexidecimal Floating Point from Long HX
               FP'
OPC$ED26 DC    AL2(X'ED26'),Y(X'0000'),XL2'8011',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LXE',CL(L'OP@TYPE)'RXE',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Load LeX
               ngthened Extended Hexidecimal Floating Point from Short X
               HFP'
OPC$ED2E DC    AL2(X'ED2E'),Y(X'0000'),XL2'0012',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'MAE',CL(L'OP@TYPE)'RXF',CL(L'OP@FORMT)'X
               R1,R3,D2(X2,B2)',CL(L'OP@ATTR)'  HM',CL(L'OP@DESCR)'MultX
               iply and Add Short Hexidecimal Floating Point'
OPC$ED2F DC    AL2(X'ED2F'),Y(X'0000'),XL2'0012',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'MSE',CL(L'OP@TYPE)'RXF',CL(L'OP@FORMT)'X
               R1,R3,D2(X2,B2)',CL(L'OP@ATTR)'  HM',CL(L'OP@DESCR)'MultX
               iply and Subtract Short Hexidecimal Floating Point'
OPC$ED34 DC    AL2(X'ED34'),Y(X'0000'),XL2'0011',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'SQE',CL(L'OP@TYPE)'RXE',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Square X
               Root Short Hexidecimal Floating Point'
OPC$ED35 DC    AL2(X'ED35'),Y(X'0000'),XL2'0011',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'SQD',CL(L'OP@TYPE)'RXE',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'Square X
               Root Long Hexidecimal Floating Point'
OPC$ED37 DC    AL2(X'ED37'),Y(X'0000'),XL2'0011',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'MEE',CL(L'OP@TYPE)'RXE',CL(L'OP@FORMT)'X
               R1,D2(X2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'MultiplX
               y Short Hexidecimal Floating Point from Short HFP'
OPC$ED38 DC    AL2(X'ED38'),Y(X'0000'),XL2'8012',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'MAYL',CL(L'OP@TYPE)'RXF',CL(L'OP@FORMT)X
               'R1,R3,D2(X2,B2)',CL(L'OP@ATTR)'  UE',CL(L'OP@DESCR)'MulX
               tiply and Add Unnormalized low-order Extended HFP from LX
               ong HFP'
OPC$ED39 DC    AL2(X'ED39'),Y(X'0000'),XL2'8012',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'MYL',CL(L'OP@TYPE)'RXF',CL(L'OP@FORMT)'X
               R1,R3,D2(X2,B2)',CL(L'OP@ATTR)'  UE',CL(L'OP@DESCR)'MultX
               iply Unnormalized low-order Extended HFP from Long HFP'
OPC$ED3A DC    AL2(X'ED3A'),Y(X'0000'),XL2'8012',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'MAY',CL(L'OP@TYPE)'RXF',CL(L'OP@FORMT)'X
               R1,R3,D2(X2,B2)',CL(L'OP@ATTR)'  UE',CL(L'OP@DESCR)'MultX
               iply and Add Unnormalized Extended Hex Floating Point frX
               om Long HFP'
OPC$ED3B DC    AL2(X'ED3B'),Y(X'0000'),XL2'8012',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'MY',CL(L'OP@TYPE)'RXF',CL(L'OP@FORMT)'RX
               1,R3,D2(X2,B2)',CL(L'OP@ATTR)'  UE',CL(L'OP@DESCR)'MultiX
               ply Unnormalized Extended Hexidecimal Floating Point froX
               m Long HFP'
OPC$ED3C DC    AL2(X'ED3C'),Y(X'0000'),XL2'8012',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'MAYH',CL(L'OP@TYPE)'RXF',CL(L'OP@FORMT)X
               'R1,R3,D2(X2,B2)',CL(L'OP@ATTR)'  UE',CL(L'OP@DESCR)'MulX
               tiply and Add Unnormalized high-order Extended HFP from LX
               Long HFP'
OPC$ED3D DC    AL2(X'ED3D'),Y(X'0000'),XL2'8012',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'MYH',CL(L'OP@TYPE)'RXF',CL(L'OP@FORMT)'X
               R1,R3,D2(X2,B2)',CL(L'OP@ATTR)'  UE',CL(L'OP@DESCR)'MultX
               iply Unnormalized high-order Extended HFP from Long HFP'
OPC$ED3E DC    AL2(X'ED3E'),Y(X'0000'),XL2'0012',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'MAD',CL(L'OP@TYPE)'RXF',CL(L'OP@FORMT)'X
               R1,R3,D2(X2,B2)',CL(L'OP@ATTR)'  HM',CL(L'OP@DESCR)'MultX
               iply and Add Long Hexidecimal Floating Point'
OPC$ED3F DC    AL2(X'ED3F'),Y(X'0000'),XL2'0012',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'MSD',CL(L'OP@TYPE)'RXF',CL(L'OP@FORMT)'X
               R1,R3,D2(X2,B2)',CL(L'OP@ATTR)'  HM',CL(L'OP@DESCR)'MultX
               iply and Subtract Long Hexidecimal Floating Point'
OPC$ED40 DC    AL2(X'ED40'),Y(X'0000'),XL2'0012',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'SLDT',CL(L'OP@TYPE)'RXF',CL(L'OP@FORMT)X
               'R1,R3,D2(X2,B2)',CL(L'OP@ATTR)'  TF',CL(L'OP@DESCR)'ShiX
               ft Significand Left Long Decimal Floating Point'
OPC$ED41 DC    AL2(X'ED41'),Y(X'0000'),XL2'0012',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'SRDT',CL(L'OP@TYPE)'RXF',CL(L'OP@FORMT)X
               'R1,R3,D2(X2,B2)',CL(L'OP@ATTR)'  TF',CL(L'OP@DESCR)'ShiX
               ft Significand Right Long Decimal Floating Point'
OPC$ED48 DC    AL2(X'ED48'),Y(X'0000'),XL2'2012',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'SLXT',CL(L'OP@TYPE)'RXF',CL(L'OP@FORMT)X
               'R1,R3,D2(X2,B2)',CL(L'OP@ATTR)'  TF',CL(L'OP@DESCR)'ShiX
               ft Significand Left Extended Decimal Floating Point'
OPC$ED49 DC    AL2(X'ED49'),Y(X'0000'),XL2'2012',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'SRXT',CL(L'OP@TYPE)'RXF',CL(L'OP@FORMT)X
               'R1,R3,D2(X2,B2)',CL(L'OP@ATTR)'  TF',CL(L'OP@DESCR)'ShiX
               ft Significand Right Extended Decimal Floating Point'
OPC$ED50 DC    AL2(X'ED50'),Y(X'0000'),XL2'0011',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'TDCET',CL(L'OP@TYPE)'RXE',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'  TF',CL(L'OP@DESCR)'Test X
               Data Class Short Decimal Floating Point'
OPC$ED51 DC    AL2(X'ED51'),Y(X'0000'),XL2'0011',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'TDGET',CL(L'OP@TYPE)'RXE',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'  TF',CL(L'OP@DESCR)'Test X
               Data Group Short Decimal Floating Point'
OPC$ED54 DC    AL2(X'ED54'),Y(X'0000'),XL2'0011',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'TDCDT',CL(L'OP@TYPE)'RXE',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'  TF',CL(L'OP@DESCR)'Test X
               Data Class Long Decimal Floating Point'
OPC$ED55 DC    AL2(X'ED55'),Y(X'0000'),XL2'0011',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'TDGDT',CL(L'OP@TYPE)'RXE',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'  TF',CL(L'OP@DESCR)'Test X
               Data Group Long Decimal Floating Point'
OPC$ED58 DC    AL2(X'ED58'),Y(X'0000'),XL2'8011',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'TDCXT',CL(L'OP@TYPE)'RXE',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'  TF',CL(L'OP@DESCR)'Test X
               Data Class Extended Decimal Floating Point'
OPC$ED59 DC    AL2(X'ED59'),Y(X'0000'),XL2'8011',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'TDGXT',CL(L'OP@TYPE)'RXE',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'  TF',CL(L'OP@DESCR)'Test X
               Data Group Extended Decimal Floating Point'
OPC$ED64 DC    AL2(X'ED64'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LEY',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'  LD',CL(L'OP@DESCR)'Load X
               Short Hexidecimal Floating Point Long (20-bit Long DisplX
               acement)'
OPC$ED65 DC    AL2(X'ED65'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'LDY',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMTX
               )'R1,D2(X2,B2)',CL(L'OP@ATTR)'  LD',CL(L'OP@DESCR)'Load X
               Long Hexidecimal Floating Point Long (20-bit Long DisplaX
               cement)'
OPC$ED66 DC    AL2(X'ED66'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'STEY',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMX
               T)'R1,D2(X2,B2)',CL(L'OP@ATTR)'  LD',CL(L'OP@DESCR)'StorX
               e Short Hexidecimal Floating Point Long (20-bit Long DisX
               placement'
OPC$ED67 DC    AL2(X'ED67'),Y(X'0000'),XL2'0013',Y(X'0652'),AD(00000000X
               ),CL(L'OP@MNEUM)'STDY',CL(L'OP@TYPE)'RXY-a',CL(L'OP@FORMX
               T)'R1,D2(X2,B2)',CL(L'OP@ATTR)'  LD',CL(L'OP@DESCR)'StorX
               e Long Hexidecimal Floating Point Long (20-bit Long DispX
               lacement'
OPC$EE   DC    AL2(X'EE00'),Y(X'0000'),XL2'001D',Y(X'0601'),AD(00000000X
               ),CL(L'OP@MNEUM)'PLO',CL(L'OP@TYPE)'SS-e',CL(L'OP@FORMT)X
               'R1,D2(B2),R3,D4(B4)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)X
               'Perform Locked Operation'
OPC$EF   DC    AL2(X'EF00'),Y(X'0000'),XL2'001D',Y(X'0601'),AD(00000000X
               ),CL(L'OP@MNEUM)'LMD',CL(L'OP@TYPE)'SS-e',CL(L'OP@FORMT)X
               'R1,R3,D2(B2),D4(B4)',CL(L'OP@ATTR)'  N ',CL(L'OP@DESCR)X
               'Load Multiple Disjoint'
OPC$F0   DC    AL2(X'F000'),Y(X'0008'),XL2'001A',Y(X'0601'),AD(00000000X
               ),CL(L'OP@MNEUM)'SRP',CL(L'OP@TYPE)'SS-c',CL(L'OP@FORMT)X
               'D1(L1,B1),D2(B2),I3',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)X
               'Shift and Round Packed Decimal'
OPC$F1   DC    AL2(X'F100'),Y(X'0000'),XL2'0019',Y(X'0601'),AD(00000000X
               ),CL(L'OP@MNEUM)'MVO',CL(L'OP@TYPE)'SS-b',CL(L'OP@FORMT)X
               'D1(L1,B1),D2(L2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)X
               'Move with Offset'
OPC$F2   DC    AL2(X'F200'),Y(X'0000'),XL2'0019',Y(X'0601'),AD(00000000X
               ),CL(L'OP@MNEUM)'PACK',CL(L'OP@TYPE)'SS-b',CL(L'OP@FORMTX
               )'D1(L1,B1),D2(L2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCRX
               )'Pack'
OPC$F3   DC    AL2(X'F300'),Y(X'0000'),XL2'0019',Y(X'0601'),AD(00000000X
               ),CL(L'OP@MNEUM)'UNPK',CL(L'OP@TYPE)'SS-b',CL(L'OP@FORMTX
               )'D1(L1,B1),D2(L2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCRX
               )'Unpack'
OPC$F8   DC    AL2(X'F800'),Y(X'0000'),XL2'0019',Y(X'0601'),AD(00000000X
               ),CL(L'OP@MNEUM)'ZAP',CL(L'OP@TYPE)'SS-b',CL(L'OP@FORMT)X
               'D1(L1,B1),D2(L2,B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)X
               'Zero and Add Packed Decimal'
OPC$F9   DC    AL2(X'F900'),Y(X'0000'),XL2'0019',Y(X'0601'),AD(00000000X
               ),CL(L'OP@MNEUM)'CP',CL(L'OP@TYPE)'SS-b',CL(L'OP@FORMT)'X
               D1(L1,B1),D2(L2,B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'X
               Compare Packed Decimal'
OPC$FA   DC    AL2(X'FA00'),Y(X'0000'),XL2'0019',Y(X'0601'),AD(00000000X
               ),CL(L'OP@MNEUM)'AP',CL(L'OP@TYPE)'SS-b',CL(L'OP@FORMT)'X
               D1(L1,B1),D2(L2,B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'X
               Add Packed Decimal'
OPC$FB   DC    AL2(X'FB00'),Y(X'0000'),XL2'0019',Y(X'0601'),AD(00000000X
               ),CL(L'OP@MNEUM)'SP',CL(L'OP@TYPE)'SS-b',CL(L'OP@FORMT)'X
               D1(L1,B1),D2(L2,B2)',CL(L'OP@ATTR)'c   ',CL(L'OP@DESCR)'X
               Subtract Packed Decimal'
OPC$FC   DC    AL2(X'FC00'),Y(X'0000'),XL2'0019',Y(X'0601'),AD(00000000X
               ),CL(L'OP@MNEUM)'MP',CL(L'OP@TYPE)'SS-b',CL(L'OP@FORMT)'X
               D1(L1,B1),D2(L2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'X
               Multiply Packed Decimal'
OPC$FD   DC    AL2(X'FD00'),Y(X'0000'),XL2'0019',Y(X'0601'),AD(00000000X
               ),CL(L'OP@MNEUM)'DP',CL(L'OP@TYPE)'SS-b',CL(L'OP@FORMT)'X
               D1(L1,B1),D2(L2,B2)',CL(L'OP@ATTR)'    ',CL(L'OP@DESCR)'X
               Divide Packed Decimal'
OPC$ZLEN EQU   *-OPC$ZARC          Length of Machine Instructions Area
OPC$ZNUM EQU   (OPC$ZLEN)/OP@NTRYL No. of Entries in Instruction Table
         EJECT ,
*
*+-------------------------------------------------------------------+*
*|        zArchitecture Machine Instruction Attributes Table         |*
*+-------------------------------------------------------------------+*
*
         DS    0D                  Set for Doubleword Alignnent
OPC$ATLN EQU   62                  Length for Instruction Attributes
OPC$ATTR DS    0CL(OPC$ATLN+2)     Instruction Attributes Description
OPC$COND DC    C'c ',CL(OPC$ATLN)'Sets Condition Code'
OPC$NWCC DC    C'n ',CL(OPC$ATLN)'New Condition Code is loaded'
OPC$PRIV DC    C'p ',CL(OPC$ATLN)'Privileged instruction'
OPC$SEMI DC    C'q ',CL(OPC$ATLN)'Semiprivileged instruction'
OPC$UNPR DC    C'u ',CL(OPC$ATLN)'Condition code is unpredictable'
OPC$NOAT DC    C'  ',CL(OPC$ATLN)'Does not set Condition Code'
OPC$CDPV DC    C'cq',CL(OPC$ATLN)'Sets Condition code; Semiprivileged iX
               nstruction'
OPC$INCD DC    C'ic',CL(OPC$ATLN)'Interruptible instruction; Sets CondiX
               tion code'
OPC$INPV DC    C'ip',CL(OPC$ATLN)'Interruptible instruction; PrivilegedX
                instruction'
OPC$PVCD DC    C'pc',CL(OPC$ATLN)'Privileged instruction; Sets ConditioX
               n code'
OPC$PVNW DC    C'pn',CL(OPC$ATLN)'Privileged instruction; New ConditionX
                code is loaded'
OPC$PVUN DC    C'pu',CL(OPC$ATLN)'Privileged instruction; Condition codX
               e is unpredictable'
OPC$SMCC DC    C'qc',CL(OPC$ATLN)'Semiprivileged instruction; Sets CondX
               ition code'
OPC$SMNW DC    C'qn',CL(OPC$ATLN)'Semiprivileged instruction; New CondiX
               tion code is loaded'
OPC$ALEN EQU   *-OPC$ATTR          Leng of Instruction Attributes Area
OPC$ANBR EQU   (OPC$ALEN)/L'OPC$ATTR No. of Entries in Attributes Table
*
*+-------------------------------------------------------------------+*
*|        zArchitecture Machine Instruction Facilities Table         |*
*+-------------------------------------------------------------------+*
*
         DS    0D                  Set for Doubleword Alignnent
OPC$F1LN EQU   2                   Length for Instruction Facilties Id
OPC$F2LN EQU   46                  Leng for the Facilties Description
OPC$FCIL DS    0CL(OPC$F1LN+OPC$F2LN) Instruction Facilities Tble Entry
OPC$FC00 DC    CL(OPC$F1LN)'  ',CL(OPC$F2LN)'None, zArchitecture base'
OPC$FCCL DC    CL(OPC$F1LN)'CL',CL(OPC$F2LN)'Load/Store-on-Condition faX
               cility'
OPC$FCCS DC    CL(OPC$F1LN)'CS',CL(OPC$F2LN)'Compare-and-swap-and-storeX
                facility'
OPC$FCCT DC    CL(OPC$F1LN)'CT',CL(OPC$F2LN)'Configuration topology facX
               ility'
OPC$FCDE DC    CL(OPC$F1LN)'DE',CL(OPC$F2LN)'DAT-enhancement facility'
OPC$FCDO DC    CL(OPC$F1LN)'DO',CL(OPC$F2LN)'Distinct-Operands facilityX
               '
OPC$FCD2 DC    CL(OPC$F1LN)'D2',CL(OPC$F2LN)'DAT-enhancement facility 2X
               '
OPC$FCED DC    CL(OPC$F1LN)'ED',CL(OPC$F2LN)'Enhanced-DAT facility'
OPC$FCEI DC    CL(OPC$F1LN)'EI',CL(OPC$F2LN)'Extended-immediate facilitX
               y'
OPC$FCE2 DC    CL(OPC$F1LN)'E2',CL(OPC$F2LN)'Extended-translation facilX
               ity 2'
OPC$FCE3 DC    CL(OPC$F1LN)'E3',CL(OPC$F2LN)'Extended-translation facilX
               ity 3'
OPC$FCES DC    CL(OPC$F1LN)'ES',CL(OPC$F2LN)'Expanded-storage facility'
OPC$FCET DC    CL(OPC$F1LN)'ET',CL(OPC$F2LN)'Extract-CPU-time facility'
OPC$FCF  DC    CL(OPC$F1LN)'F ',CL(OPC$F2LN)'Floating-Point Extension FX
               acility'
OPC$FCFG DC    CL(OPC$F1LN)'FG',CL(OPC$F2LN)'FPR-GPR-transfer facility'
OPC$FCFL DC    CL(OPC$F1LN)'FL',CL(OPC$F2LN)'Store-facility-list-extendX
               ed facility '
OPC$FCFS DC    CL(OPC$F1LN)'FS',CL(OPC$F2LN)'Floating-point-support-sigX
               n-handling facility'
OPC$FCGE DC    CL(OPC$F1LN)'GE',CL(OPC$F2LN)'General-instructions-extenX
               sion facility'
OPC$FCHM DC    CL(OPC$F1LN)'HM',CL(OPC$F2LN)'HFP multiply-and-add/subtrX
               act facility'
OPC$FCHW DC    CL(OPC$F1LN)'HW',CL(OPC$F2LN)'High-Word Facility'
OPC$FCIA DC    CL(OPC$F1LN)'IA',CL(OPC$F2LN)'Interlocked-Access FacilitX
               y'
OPC$FCLD DC    CL(OPC$F1LN)'LD',CL(OPC$F2LN)'Long-displacement facilityX
               '
OPC$FCN  DC    CL(OPC$F1LN)'N ',CL(OPC$F2LN)'New in z/Architecture'
OPC$FCMO DC    CL(OPC$F1LN)'MO',CL(OPC$F2LN)'Move-with-optional-specifiX
               cations facility'
OPC$FCMS DC    CL(OPC$F1LN)'MS',CL(OPC$F2LN)'Message-security assist'
OPC$FCM3 DC    CL(OPC$F1LN)'M3',CL(OPC$F2LN)'Message-security assist exX
               tension 3'
OPC$FCM4 DC    CL(OPC$F1LN)'M4',CL(OPC$F2LN)'Message-security assist exX
               tension 4'
OPC$FCN3 DC    CL(OPC$F1LN)'N3',CL(OPC$F2LN)'New in z/Architecture and X
               added to ESA/390'
OPC$FCPE DC    CL(OPC$F1LN)'PE',CL(OPC$F2LN)'Parsing-enhancement faciliX
               ty'
OPC$FCPF DC    CL(OPC$F1LN)'PF',CL(OPC$F2LN)'Perform Floating Point OpeX
               ration Facility'
OPC$FCPK DC    CL(OPC$F1LN)'PK',CL(OPC$F2LN)'Population-Count facility'
OPC$FCRA DC    CL(OPC$F1LN)'RA',CL(OPC$F2LN)'ASN-and-LX-reuse facility'
OPC$FCRB DC    CL(OPC$F1LN)'RB',CL(OPC$F2LN)'Reset-reference-bits MultiX
               ple facility'
OPC$FCSC DC    CL(OPC$F1LN)'SC',CL(OPC$F2LN)'Store-clock-fast facility'
OPC$FCTF DC    CL(OPC$F1LN)'TF',CL(OPC$F2LN)'Decimal-floating-point facX
               ility'
OPC$FCTR DC    CL(OPC$F1LN)'TR',CL(OPC$F2LN)' Decimal-floating-point-roX
               unding facility'
OPC$FCTS DC    CL(OPC$F1LN)'TS',CL(OPC$F2LN)'TOD-clock-steering facilitX
               y'
OPC$FCUE DC    CL(OPC$F1LN)'UE',CL(OPC$F2LN)'HFP unnormalized-extensionX
                facility'
OPC$FCXF DC    CL(OPC$F1LN)'XF',CL(OPC$F2LN)'IEEE-exception-support facX
               ility'
OPC$FCXX DC    CL(OPC$F1LN)'XX',CL(OPC$F2LN)'Execute-extension facilityX
               '
OPC$FALN EQU   *-OPC$FCIL          Leng of Instruction Facilities Area
OPC$FANO EQU   (OPC$FALN)/L'OPC$FCIL No. of Entries in Facilities Table
         EJECT ,
*
*+-------------------------------------------------------------------+*
*|               zArchitecture SVC Instruction Table                 |*
*+-------------------------------------------------------------------+*
*
         DS    0D                  Set for Doubleword Alignnent
OPC$S1LN EQU   1                   Length for the SVC Type Entry
OPC$S2LN EQU   79                  Leng for the SVC Entry Description
OPC$SVCT DS    0CL(OPC$S1LN+OPC$S2LN)   ...The SVC Instruction Table
         DC    AL(OPC$S1LN)(0),CL(OPC$S2LN)'(EXCP/XDAP) Type 1     CallX
               s module IECVEXCP, entry point IGC000'
         DC    AL(OPC$S1LN)(1),CL(OPC$S2LN)'(WAIT/WAITR/PRTOV) Type 1  X
               Calls module IEAVEWAT, entry point IGC001'
         DC    AL(OPC$S1LN)(2),CL(OPC$S2LN)'(POST/PRTO) Type=1     CallX
               s module IEAVEPST, entry point IGC002'
         DC    AL(OPC$S1LN)(3),CL(OPC$S2LN)'(EXIT) Type=1          CallX
               s module IEAVEOR, entry point IGC003'
         DC    AL(OPC$S1LN)(4),CL(OPC$S2LN)'(GETMAIN) Type=1       CallX
               s module IGVVSM24, entry point IGC004'
         DC    AL(OPC$S1LN)(5),CL(OPC$S2LN)'(FREEMAIN) Type=1      CallX
               s module IGVVSM24, entry point IGC005'
         DC    AL(OPC$S1LN)(6),CL(OPC$S2LN)'(LINK/LINKX) Type=2    CallX
               s module CSVLINK, entry point IGC006'
         DC    AL(OPC$S1LN)(7),CL(OPC$S2LN)'(XCTL/XCTLX) Type=2    CallX
               s module CSVXCTL, entry point IGC007'
         DC    AL(OPC$S1LN)(8),CL(OPC$S2LN)'(LOAD) Type=2          CallX
               s module CSVLOAD, entry point IGC008'
         DC    AL(OPC$S1LN)(9),CL(OPC$S2LN)'(DELETE) Type=2        CallX
               s module CSVDELET, entry point IGC009'
         DC    AL(OPC$S1LN)(10),CL(OPC$S2LN)'(GETMAIN/FREEMAIN) Type=1 X
               Calls module IGVVSM24, entry point IGC010'
         DC    AL(OPC$S1LN)(11),CL(OPC$S2LN)'(TIME) Type=3         CallX
               s module IEAVRT01, entry point IGC0001A'
         DC    AL(OPC$S1LN)(12),CL(OPC$S2LN)'(SYNCH/SYNCHX) Type=2 CallX
               s module CSVSYNCH, entry point IGC012'
         DC    AL(OPC$S1LN)(13),CL(OPC$S2LN)'(ABEND) Type=4        CallX
               s module IEAVTRT2, entry point IGC0101C'
         DC    AL(OPC$S1LN)(14),CL(OPC$S2LN)'(SPIE) Type=3         CallX
               s module IEAVTESP, entry point IGC0001D'
         DC    AL(OPC$S1LN)(15),CL(OPC$S2LN)'(ERREXCP) Type=1      CallX
               s module IECVPST, entry point IGC015'
         DC    AL(OPC$S1LN)(16),CL(OPC$S2LN)'(PURGE) Type=2        CallX
               s module IOSPURGA, entry point IGC016'
         DC    AL(OPC$S1LN)(17),CL(OPC$S2LN)'(RESTORE) Type=3      CallX
               s module IGC0001G, entry point IGC017'
         DC    AL(OPC$S1LN)(18),CL(OPC$S2LN)'(BLDL/FIND) Type=2    CallX
               s module IGC018'
         DC    AL(OPC$S1LN)(19),CL(OPC$S2LN)'(OPEN) Type=4         CallX
               s module IGC0001I'
         DC    AL(OPC$S1LN)(20),CL(OPC$S2LN)'(CLOSE) Type=4        CallX
               s module IGC00020'
         DC    AL(OPC$S1LN)(21),CL(OPC$S2LN)'(STOW) Type=3         CallX
               s module IGC0002A'
         DC    AL(OPC$S1LN)(22),CL(OPC$S2LN)'(OPEN (TYPE=J))' Type=4 CaX
               lls module IGC0002B'
         DC    AL(OPC$S1LN)(23),CL(OPC$S2LN)'(CLOSE (TYPE=T)) Type=4 CaX
               lls module IGC0002C'
         DC    AL(OPC$S1LN)(24),CL(OPC$S2LN)'(DEVTYPE) Type=3      CallX
               s module IGC0002D'
         DC    AL(OPC$S1LN)(25),CL(OPC$S2LN)'(TRKBAL) Type=3       CallX
               s module IGC0002E'
         DC    AL(OPC$S1LN)(26),CL(OPC$S2LN)'(CATALOG/INDEX/LOCATE) TypX
               e=4, Calls module IGC0002F'
         DC    AL(OPC$S1LN)(27),CL(OPC$S2LN)'(OBTAIN) Type=3       CallX
               s module IGC0002G'
         DC    AL(OPC$S1LN)(28),CL(OPC$S2LN)'(Reserved)'
         DC    AL(OPC$S1LN)(29),CL(OPC$S2LN)'(SCRATCH) Type=3      CallX
               s module IGC0002I'
         DC    AL(OPC$S1LN)(30),CL(OPC$S2LN)'(RENAME) Type=3       CallX
               s module IGC00030'
         DC    AL(OPC$S1LN)(31),CL(OPC$S2LN)'(FEOV) Type=4         CallX
               s module IGC0003A'
         DC    AL(OPC$S1LN)(32),CL(OPC$S2LN)'(REALLOC) Type=4      CallX
               s module IGGDAC01'
         DC    AL(OPC$S1LN)(33),CL(OPC$S2LN)'(IOHALT) Type=2       CallX
               s module IGC0003C'
         DC    AL(OPC$S1LN)(34),CL(OPC$S2LN)'(MGCR/MGCRE/QEDIT) Type=4 X
               Calls module IEE0003D'
         DC    AL(OPC$S1LN)(35),CL(OPC$S2LN)'(WTO/WTOR) Type=4     CallX
               s module IEAVM600'
         DC    AL(OPC$S1LN)(36),CL(OPC$S2LN)'(WTL) Type=4          CallX
               s module IEEMB804'
         DC    AL(OPC$S1LN)(37),CL(OPC$S2LN)'(SEGLD/SEG) Type=2    CallX
               s module IEWSUOVR, entry point IGC037'
         DC    AL(OPC$S1LN)(38),CL(OPC$S2LN)'(Reserved)'
         DC    AL(OPC$S1LN)(39),CL(OPC$S2LN)'(LABEL) Type=3        CallX
               s module IGC0003I'
         DC    AL(OPC$S1LN)(40),CL(OPC$S2LN)'(EXTRACT) Type=3      CallX
               s module IEAVTB00, entry point IGC00040'
         DC    AL(OPC$S1LN)(41),CL(OPC$S2LN)'(IDENTIFY) Type=3     CallX
               s module IEAVID00'
         DC    AL(OPC$S1LN)(42),CL(OPC$S2LN)'(ATTACH/ATTACHX) Type=2 CaX
               lls module IEAVEAT0'
         DC    AL(OPC$S1LN)(43),CL(OPC$S2LN)'(CIRB) Type=1         CallX
               s module IEAVEF00, entry point IGC043'
         DC    AL(OPC$S1LN)(44),CL(OPC$S2LN)'(CHAP) Type=2         CallX
               s module IEAVECH0'
         DC    AL(OPC$S1LN)(45),CL(OPC$S2LN)'(OVLYBRCH) Type=2     CallX
               s module IEWSUOVR, entry point IGC045'
         DC    AL(OPC$S1LN)(46),CL(OPC$S2LN)'(TTIMER/STIMERM (TEST and X
               CANCEL options)) Type=2'
         DC    AL(OPC$S1LN)(47),CL(OPC$S2LN)'(STIMER/STIMERM (SET optioX
               n)) Type=2'
         DC    AL(OPC$S1LN)(48),CL(OPC$S2LN)'(DEQ) Type=2          CallX
               s module ISGGRT, entry point IGC048'
         DC    AL(OPC$S1LN)(49),CL(OPC$S2LN)'(Reserved)'
         DC    AL(OPC$S1LN)(50),CL(OPC$S2LN)'(Reserved)'
         DC    AL(OPC$S1LN)(51),CL(OPC$S2LN)'(SNAP/SNAPX/SDUMP/SDUMPX) X
               Type=4, Calls module IEAVAD00'
         DC    AL(OPC$S1LN)(52),CL(OPC$S2LN)'(RESTART) Type=4      CallX
               s module IEFRSTRT'
         DC    AL(OPC$S1LN)(53),CL(OPC$S2LN)'(RELEX) Type=3        CallX
               s module IGC0005C'
         DC    AL(OPC$S1LN)(54),CL(OPC$S2LN)'(DISABLE) Type=3      CallX
               s module IGC0005D'
         DC    AL(OPC$S1LN)(55),CL(OPC$S2LN)'(EOV) Type=4          CallX
               s module IGC0005E'
         DC    AL(OPC$S1LN)(56),CL(OPC$S2LN)'(ENQ/RESERVE) Type=2  CallX
               s module ISGGRT'
         DC    AL(OPC$S1LN)(57),CL(OPC$S2LN)'(FREEDBUF) Type=3     CallX
               s module IGC0005G'
         DC    AL(OPC$S1LN)(58),CL(OPC$S2LN)'(RELBUF/REQBUF) Type=1 CalX
               ls module IGC058'
         DC    AL(OPC$S1LN)(59),CL(OPC$S2LN)'(OLTEP) Type=3        CallX
               s module IGC0005I'
         DC    AL(OPC$S1LN)(60),CL(OPC$S2LN)'(STAE/ESTAE) Type=2   CallX
               s module IEAVSTA0, entry point IGC060'
         DC    AL(OPC$S1LN)(61),CL(OPC$S2LN)'(IKJEGS6A (TSO TEST)) TypeX
               =3, TSO/E only, Calls module IGC0006A'
         DC    AL(OPC$S1LN)(62),CL(OPC$S2LN)'(DETACH) Type=2       CallX
               s module IEAVEED0, entry point IGC062'
         DC    AL(OPC$S1LN)(63),CL(OPC$S2LN)'(CHKPT) Type=4        CallX
               s module IHJACP00, entry point IGC0006C'
         DC    AL(OPC$S1LN)(64),CL(OPC$S2LN)'(RDJFCB) Type=3       CallX
               s module IGC0006D'
         DC    AL(OPC$S1LN)(65),CL(OPC$S2LN)'(Reserved)'
         DC    AL(OPC$S1LN)(66),CL(OPC$S2LN)'(BTAMTEST) Type=4     CallX
               s module IGC0006F'
         DC    AL(OPC$S1LN)(67),CL(OPC$S2LN)'(Reserved)'
         DC    AL(OPC$S1LN)(68),CL(OPC$S2LN)'(SYNADAF/SYNADRLS) Type=4 X
               Calls module IGC0006H'
         DC    AL(OPC$S1LN)(69),CL(OPC$S2LN)'(BSP) Type=3          CallX
               s module IGC0006I'
         DC    AL(OPC$S1LN)(70),CL(OPC$S2LN)'(GSERV) Type=2        CallX
               s module IGC070'
         DC    AL(OPC$S1LN)(71),CL(OPC$S2LN)'(ASGNBFR/BUFINQ/RLSEBFR) TX
               ype=3, Calls module IGC0007A'
         DC    AL(OPC$S1LN)(72),CL(OPC$S2LN)'(No macro, Type=4)    CallX
               s module IEAVVCTR'
         DC    AL(OPC$S1LN)(73),CL(OPC$S2LN)'(SPAR) Type=3         CallX
               s module IGC0007C'
         DC    AL(OPC$S1LN)(74),CL(OPC$S2LN)'(DAR) Type=3          CallX
               s module IGC0007D'
         DC    AL(OPC$S1LN)(75),CL(OPC$S2LN)'(DQUEUE) Type=3       CallX
               s module IGC0007E'
         DC    AL(OPC$S1LN)(76),CL(OPC$S2LN)'(No Macro, Type=3)    CallX
               s module IFBSVC76, entry point IGC0007F'
         DC    AL(OPC$S1LN)(77),CL(OPC$S2LN)'(Reserved)'
         DC    AL(OPC$S1LN)(78),CL(OPC$S2LN)'(LSPACE) Type=3       CallX
               s module IGC0007H'
         DC    AL(OPC$S1LN)(79),CL(OPC$S2LN)'(STATUS) Type=2       CallX
               s module IEAVSETS, entry point IGC079'
         DC    AL(OPC$S1LN)(80),CL(OPC$S2LN)'(Reserved)'
         DC    AL(OPC$S1LN)(81),CL(OPC$S2LN)'(SETPRT/SETDEV) Type=4 CalX
               ls module IGC0008A'
         DC    AL(OPC$S1LN)(82),CL(OPC$S2LN)'(Reserved)'
         DC    AL(OPC$S1LN)(83),CL(OPC$S2LN)'(SMFWTM/SMFEWTM) Type=3 CaX
               lls module IEEMB830'
         DC    AL(OPC$S1LN)(84),CL(OPC$S2LN)'(GRAPHICS) Type=1     CallX
               s module IGC084, entry point IGC00084'
         DC    AL(OPC$S1LN)(85),CL(OPC$S2LN)'(No Macro, Type=3)    CallX
               s module IGC0008E'
         DC    AL(OPC$S1LN)(86),CL(OPC$S2LN)'(ATLAS (Obsolete))'
         DC    AL(OPC$S1LN)(87),CL(OPC$S2LN)'(DOM) Type=3          CallX
               s module IEAVXDOM, entry point IGC0008G'
         DC    AL(OPC$S1LN)(88),CL(OPC$S2LN)'(Reserved)'
         DC    AL(OPC$S1LN)(89),CL(OPC$S2LN)'(Reserved)'
         DC    AL(OPC$S1LN)(90),CL(OPC$S2LN)'(Reserved)'
         DC    AL(OPC$S1LN)(91),CL(OPC$S2LN)'(VOLSTAT) Type=3      CallX
               s module IGC0009A'
         DC    AL(OPC$S1LN)(92),CL(OPC$S2LN)'(TCBEXCP) Type=1      CallX
               s module IECVEXCP, entry point IGC092'
         DC    AL(OPC$S1LN)(93),CL(OPC$S2LN)'(TGET/TPG/TPUT) Type=3'
         DC    AL(OPC$S1LN)(94),CL(OPC$S2LN)'(STCC) Type=3         CallX
               s module IGC0009D'
         DC    AL(OPC$S1LN)(95),CL(OPC$S2LN)'(SYSEVENT) Type=1     CallX
               s module IRARMINT'
         DC    AL(OPC$S1LN)(96),CL(OPC$S2LN)'(STAX) Type=3         CallX
               s module IEAVAX00'
         DC    AL(OPC$S1LN)(97),CL(OPC$S2LN)'(TSO TEST) Type=3     CallX
               s module IGC0009G'
         DC    AL(OPC$S1LN)(98),CL(OPC$S2LN)'(PROTECT) Type=4      CallX
               s module IGC0009H'
         DC    AL(OPC$S1LN)(99),CL(OPC$S2LN)'(DYNALLOC) Type=3     CallX
               s module IEFDB400, entry point IGC0009I'
         DC    AL(OPC$S1LN)(100),CL(OPC$S2LN)'(IKJEFFIB (TSO/E only)) CX
               alls module IKJEFF00, entry point IGC00100'
         DC    AL(OPC$S1LN)(101),CL(OPC$S2LN)'(QTIP) Type=1        UsedX
                only by TSO/E and the MCP'
         DC    AL(OPC$S1LN)(102),CL(OPC$S2LN)'(AQCTL) Type=3       CallX
               s module IEDQEB, entry point IGC0010B'
         DC    AL(OPC$S1LN)(103),CL(OPC$S2LN)'(XLATE) Type=3       CallX
               s module IGC0010C'
         DC    AL(OPC$S1LN)(104),CL(OPC$S2LN)'(TOPCTL) Type=4      CallX
               s module IGC0010D'
         DC    AL(OPC$S1LN)(105),CL(OPC$S2LN)'(IMGLIB) Type=3      CallX
               s module IGC0010E'
         DC    AL(OPC$S1LN)(106),CL(OPC$S2LN)'(Reserved)'
         DC    AL(OPC$S1LN)(107),CL(OPC$S2LN)'(MODESET) Type=6     CallX
               s module IEAVMODE, entry point IGC107'
         DC    AL(OPC$S1LN)(108),CL(OPC$S2LN)'(Reserved)'
         DC    AL(OPC$S1LN)(109),CL(OPC$S2LN)'(ESR) Type=4         CallX
               s module IGC0010F'
         DC    AL(OPC$S1LN)(110),CL(OPC$S2LN)'(Reserved)'
         DC    AL(OPC$S1LN)(111),CL(OPC$S2LN)'(No Macro, Type=2)   CallX
               s module IGC111'
         DC    AL(OPC$S1LN)(112),CL(OPC$S2LN)'(PGRLSE) Type=1      CallX
               s module IARPS, entry point IGC112'
         DC    AL(OPC$S1LN)(113),CL(OPC$S2LN)'(PGFIX/PGFREE/PGLOAD/PGOUX
               T/PGANY) Calls module IARPS, entry point IGC11'
         DC    AL(OPC$S1LN)(114),CL(OPC$S2LN)'(EXCPVR) Type=1      CallX
               s module IECVEXCP, entry point IGC114'
         DC    AL(OPC$S1LN)(115),CL(OPC$S2LN)'(Reserved)'
         DC    AL(OPC$S1LN)(116),CL(OPC$S2LN)'(ESR) Type=1         CallX
               s module IECTSVC, entry point IECTRDIL'
         DC    AL(OPC$S1LN)(117),CL(OPC$S2LN)'(DEBCHK) Type=2'
         DC    AL(OPC$S1LN)(118),CL(OPC$S2LN)'(Reserved)'
         DC    AL(OPC$S1LN)(119),CL(OPC$S2LN)'(TESTAUTH) Type=1    CallX
               s module IEAVTEST, entry point IGC119'
         DC    AL(OPC$S1LN)(120),CL(OPC$S2LN)'(GETMAIN/FREEMAIN) Type=1X
                Calls module IGVVSM31, entry point IGC120'
         DC    AL(OPC$S1LN)(121),CL(OPC$S2LN)'(VSAM) Type=1        CallX
               s module IGC121'
         DC    AL(OPC$S1LN)(122),CL(OPC$S2LN)'(ESR) Type=2'
         DC    AL(OPC$S1LN)(123),CL(OPC$S2LN)'(PURGEDQ) Type=2     CallX
               s module IEAVEPD0, entry point IGC123'
         DC    AL(OPC$S1LN)(124),CL(OPC$S2LN)'(TPIO) Type=1        CallX
               s module ISTAPC22'
         DC    AL(OPC$S1LN)(125),CL(OPC$S2LN)'(EVENTS) Type=1      CallX
               s module IEAVEVT0, entry point IGC125'
         DC    AL(OPC$S1LN)(126),CL(OPC$S2LN)'(Reserved)'
         DC    AL(OPC$S1LN)(127),CL(OPC$S2LN)'(Reserved)'
         DC    AL(OPC$S1LN)(128),CL(OPC$S2LN)'(Reserved)'
         DC    AL(OPC$S1LN)(129),CL(OPC$S2LN)'(Reserved)'
         DC    AL(OPC$S1LN)(130),CL(OPC$S2LN)'(RACHECK) Type=3     CallX
               s module IRRRCK00 if RACF installed'
         DC    AL(OPC$S1LN)(131),CL(OPC$S2LN)'(RACINIT) Type=3     CallX
               s module ICHRIN00 if RACF installed'
         DC    AL(OPC$S1LN)(132),CL(OPC$S2LN)'(RACLIST/RACXTRT/ICHEINTYX
               ) Type=3, Calls module ICHRSV00'
         DC    AL(OPC$S1LN)(133),CL(OPC$S2LN)'(RACDEF) Type=3      CallX
               s module IRRRDF00 if RACF installed'
         DC    AL(OPC$S1LN)(134),CL(OPC$S2LN)'(Reserved)'
         DC    AL(OPC$S1LN)(135),CL(OPC$S2LN)'(Reserved)'
         DC    AL(OPC$S1LN)(136),CL(OPC$S2LN)'(Reserved)'
         DC    AL(OPC$S1LN)(137),CL(OPC$S2LN)'(ESR) Type=6         CallX
               s module IEAVEDS0'
         DC    AL(OPC$S1LN)(138),CL(OPC$S2LN)'(PGSER) Type=2       CallX
               s module IARPI, entry point IGC138'
         DC    AL(OPC$S1LN)(139),CL(OPC$S2LN)'(CVAF) Type=3        CallX
               s module IGC0013I'
         DC    AL(OPC$S1LN)(143),CL(OPC$S2LN)'(GENKEY/RETKEY/CIPHER/EMKX
               ) Type=4'
         DC    AL(OPC$S1LN)(144),CL(OPC$S2LN)'(z/OS Unix PTrace)'
         DC    AL(OPC$S1LN)(146),CL(OPC$S2LN)'(BPESVC) Type=3      CallX
               s module BPESVC00, entry point BPESVC00'
OPC$SVCN EQU   *-OPC$SVCT          Length of SVC Instruction Table Area
OPC$SVNO EQU   (OPC$SVCN)/L'OPC$SVCT     Number of Entries in SVC Table
*
*+-------------------------------------------------------------------+*
*|          zArchitecture Subpool Storage Information Table          |*
*+-------------------------------------------------------------------+*
*
         DS    0D                  Set for Doubleword Alignnent
SPC$SINF DS    0CL(SPC$SPLN)       Subpool Information Area Table Entry
SPC$SPLN EQU   100                 Length for Subpool Information Line
SPC$SP00 DC    CL(SPC$SPLN)'Subpool Storage Information:'
SPC$SP01 DC    CL(SPC$SPLN)' Extended Private Storage - Subpool NumbersX
                that may be used for areas Above 16M Line'
SPC$SP02 DC    CL(SPC$SPLN)'   ECSA Subpools.... 227      228   231  24X
               1'
SPC$SP03 DC    CL(SPC$SPLN)'   ELSQA Subpools... 203 thru 225   233  23X
               4  235  253  254  255'
SPC$SP04 DC    CL(SPC$SPLN)'   ESQA Subpools.... 239      245   246  24X
               7  248'
SPC$SP05 DC    CL(SPC$SPLN)'   ESWA Subpools.... 229      230   249  23X
               6  237'
SPC$SP06 DC    CL(SPC$SPLN)'   USER Subpools.... 0  thru  132   240  25X
               0  251  252'
SPC$SP07 DC    CL(SPC$SPLN)' Private Storage - Subpool Numbers that mayX
                be used for areas Below 16M Line'
SPC$SP08 DC    CL(SPC$SPLN)'   CSA Subpools..... 227      228   231  24X
               1'
SPC$SP09 DC    CL(SPC$SPLN)'   LSQA Subpools.... 203 thru 225   233  23X
               4  235  253  254  255'
SPC$SP10 DC    CL(SPC$SPLN)'   SQA Subpools..... 226      239   245'
SPC$SP11 DC    CL(SPC$SPLN)'   SWA Subpools..... 229      230   249  23X
               6  237'
SPC$SP12 DC    CL(SPC$SPLN)'   USER Subpools.... 0  thru  132   240  25X
               0  251  252'
SPC$ARLN EQU   *-SPC$SINF          Length of Subpool Information Area
SPC$SPNM EQU   (SPC$ARLN)/L'SPC$SINF ...No. of Entries in SP Info Area
*
         EJECT ,
***********************************************************************
*+-------------------------------------------------------------------+*
*|      DDDDDD    SSSSS   EEEEEEE   CCCCCC   TTTTTTTTT   SSSSS       |*
*|      D     D  S     S  E        C      C      T      S     S      |*
*|      D     D  S        E        C             T      S            |*
*|      D     D   SSSSS   EEEEEE   C             T       SSSSS       |*
*|      D     D        S  E        C             T            S      |*
*|      D     D  S     S  E        C      C      T      S     S      |*
*|      DDDDDD    SSSSS   EEEEEEE   CCCCCC       T       SSSSS       |*
*+-------------------------------------------------------------------+*
***********************************************************************
*
*+-------------------------------------------------------------------+*
*|        L o g g e r   S e r v i c e   W o r k   A r e a            |*
*+-------------------------------------------------------------------+*
*
         COPY  LGCPLSWA            Include Logger Service Work Area Map
         EJECT ,
*
*+-------------------------------------------------------------------+*
*|        L o g g e r   C o n t r o l   A r e a   -   (LCA )         |*
*+-------------------------------------------------------------------+*
*
         COPY  LGCPLOGR            Include Logger Service for LCA Dsect
RTRLRCE@ LPGMNTRY TYPE=SUB,        Define as a Sub-Program Entry       X
               LCAPFX=LCA,         Define LCA Prefix for This Mapping  X
               LCADSECT=YES,       Create the LCA Area Dsect Map Only  X
               LOG=OFF             Turn Logging Off In This Program
         EJECT ,
*+-------------------------------------------------------------------+*
*|                  Load Module Information Block                    |*
*+-------------------------------------------------------------------+*
*
LRTLMBLK DSECT ,                   Load Module Information Block
LRTLMOD  DS    CL32                Load Module Name
LRTMODID DS    0CL96               Program Name and Version
LRTCSECT DS    CL32                Program Control Section (CSECT) Name
LRTVERSN DS    CL64                Program Version
LRTOFSET DS    CL8                 Offset into Program as "+000000"
LRTPGMNM DS    CL72                Program Name as LMOD.Csect.+000000
LRTMSBAD DS    AD                  Address of Main Storage Block
LRTMSBLA DS    F                   Length the Main Storage Block
LRTLMLEN EQU   *-LRTLMBLK          Leng of Load Module Information Blk
*
*+-------------------------------------------------------------------+*
*|                Register Contents Information Block                |*
*+-------------------------------------------------------------------+*
*
LRTRGBLK DSECT ,                   Register Contents Information Block
LRTREGCX DS    XL8                 GP Register Contents (Hex)
LRTRGFLG DS    XL1                 GP Register Indicator Flag Byte
LRTREGUS DS    CL2                 GP Register Used in Instruction
LRTREGNO DS    CL5                 GP Register Number
LRTREGCC DS    CL16                GP Register Contents (Character)
         DS    CL1                 ...Filler
LRTREGIN DS    0CL1                GP Register Contents Information
LRTALLOC DS    CL18                GPR Contents Point to Allocated Area
         DS    CL1                 ...Filler
LRTSUBPL DS    CL11                Subpool Number for Allocated Area
         DS    CL1                 ...Filler
LRTSTKEY DS    CL6                 Storage Key for Allocated Area
         DS    CL1                 ...Filler
LRTSTTCB DS    CL12                TCB Associated with Allocated Area
         ORG   LRTSTTCB            Back Up and Redefine the TCB Line
LRTSTREF DS    CL(PRNTLEN-(*-LRTRGBLK)) Bytes Which Can Be Referanced
         ORG   LRTSTTCB+L'LRTSTTCB Location Counter Back Where It Was
         DS    CL1                 ...Filler
LRTREFER DS    CL(PRNTLEN-(*-LRTRGBLK)) Bytes Which Can Be Referanced
LRTRGLEN EQU   *-LRTRGBLK          Leng of Register Information Block
*
*+-------------------------------------------------------------------+*
*|           Program Interruption Code Table Entry Mapping           |*
*+-------------------------------------------------------------------+*
*
PIC@NTRY DSECT ,                   Program Interrupt Code Table Entry
PIC@KEY  DS    Y                   Program Interrupt Code Value
PIC@SEQN DS    Y                   PIC Table Entry Sequence Number
PIC@DESC DS    A                   Pointer to PIC Reason Descriptions
PIC@DESL DS    Y                   Leng of PIC Reason Description Area
PIC$EXCP DS    CL(PICEXCP)         PIC Summary Description of Exception
PIC@SIZE EQU   *-PIC@NTRY          Length for Keyword Names Table Entry
*
*+-------------------------------------------------------------------+*
*|       zArchitecture Machine Instruction Table Entry Mapping       |*
*+-------------------------------------------------------------------+*
*
OP@CODES DSECT                     zArch Machine Instruction Tble Entry
OP@MCHCD DS    AL2                 zArch Machine Instruction Op Code
OP@REGAT DS    XL1                 Instruction Register Attributes
OP@FPGP2 EQU   X'02'               FltPoint Uses General Purpose Reg 2
OP@FPGP1 EQU   X'01'               FltPoint Uses General Purpose Reg 1
OP@MODES DS    XL1                 Instruction Format Attributes
OP@MODLI EQU   X'80'               ..Modal Instruction
OP@M4NOP EQU   X'40'               ..M4 Operand Not Defined
OP@M3NOP EQU   X'20'               ..M3 Operand Not defined
OP@R3NOP EQU   X'10'               ..R3 Operand Not defined
OP@2NDBP EQU   X'08'               ..Operand is Bit Shift/Byte Position
OP@R3EVN EQU   X'02'               ..R3 Must Be Even Numbered Register
OP@RDIFF EQU   X'01'               ..Registers Must All Be Diffrent
OP@REGEO DS    XL1                 Instruction Register Pair Attributes
OP@R1FPP EQU   X'80'               ..R1 Register is Floating Point Pair
OP@R2FPP EQU   X'40'               ..R2 Register is Floating Point Pair
OP@R12FP EQU   X'20'               ..R1+R2 Are Both Floating Pnt Pairs
OP@R1F2E EQU   X'10'               ..R2 Floating Pnt Pair + R1 Even/Odd
OP@RALLF EQU   X'08'               ..All Registers Floating Point Pairs
OP@R12EO EQU   X'04'               ..R1+R2 General Regs Even/Odd Pairs
OP@R2EOP EQU   X'02'               ..R2 General Reg is an Even/Odd Pair
OP@R1EOP EQU   X'01'               ..R1/R3 General Reg is Even/Odd Pair
OP@OFSET DS    XL1                 Instruction Offset for Branch Table
OP@OPRND DS    Y                   Instruction Operand Indicator
OP@ADDR  DS    AD                  Addr of Machine Instr Format Routine
OP@MNEUM DS    CL7                 Machine Instruction Mnemonic
OP@TYPE  DS    CL6                 Machine Instruction Type
OP@FORMT DS    CL21                Machine Instruction Format
OP@ATTR  DS    0CL4                Machine Instruction Characteristics
OP@ATTR1 DS    CL2                 Machine Instruction Attributes
OP@FACIL DS    CL2                 Machine Instruction Facilities
OP@DESCR DS    CL74                Machine Instruction Description
OP@NTRYL EQU   *-OP@CODES          Length for Machine Instr Table Entry
         EJECT ,
***********************************************************************
*+-------------------------------------------------------------------+*
*|           Program Logger Record Buffer Control Blocks             |*
*+-------------------------------------------------------------------+*
***********************************************************************
*                                                                     *
*  LOGPIBLK = Primary Index Block Structure                           *
*  LOGSIBLK = Secondary Index Block Structure                         *
*  LOGTRBLK = Log Record Buffer Area Structure                        *
*                                                                     *
*  The following Log Record control blocks represent the indexing     *
*  structure which is utilized for processing the Log Records. The    *
*  address entries in the primary index control block point to        *
*  secondary index control blocks. The entries in the secondary       *
*  index control blocks will point to the individual log records      *
*  in the buffers.                                                    *
*                                                                     *
***********************************************************************
*
*+-------------------------------------------------------------------+*
*|              Log Record Primary Index Control Block               |*
*+-------------------------------------------------------------------+*
*
LOGPIBLK DSECT ,                   Log Record Primary Index Block
LOGPISIZ DS    FD                  Size of This Primary Index Block
LOGPINXT DS    AD                  Next Primary Index Block or Zero
LOGPIFST DS    AD                  Address of First Entry in Block
LOGPICNT DS    FD                  Count of Entries in Primary Indx Blk
LOGPITOT DS    FD                  Count of Total Log Record Entries
LOGPIHP2 DS    FD                  Highest Power of 2 LE Entry Count
LOGPISXH DS    AD                  Secondary Index Block Chain Header
LOGPISXT DS    AD                  Secondary Index Block Chain Trailer
LOGPIMTH DS    AD                  Log Record Data Block Chain Header
LOGPIMTT DS    AD                  Log Record Data Block Chain Trailr
LOGPOIX2 DS    AD                  Secondary Index Memory Object Origin
LOGPHIX2 DS    AD                  Secondary Index Mem Obj High Address
LOGPHUX2 DS    AD                  Secondary Indx Mem Obj High Used Adr
LOGPOLRD DS    AD                  Log Record Data Memory Object Origin
LOGPHLRD DS    AD                  Log Record Data Mem Obj High Address
LOGPGRDZ DS    FD                  Log Recrd Data Mem Object Guard Size
LOGPGRD2 DS    FD                  Secondary Indx Mem Object Guard Size
         ORG   LOGPIBLK+576        (Reserved - LOGGER)
LOGPINDX DS    0AD                 Last Available Primary Index Entry
         DS    131000AD            Allow 131,000 Primary Index Entries
LOGPILEN EQU   *-LOGPIBLK          Set Length of Primary Index Block
*
*+-------------------------------------------------------------------+*
*|             Log Record Secondary Index Control Block              |*
*+-------------------------------------------------------------------+*
*
LOGSIBLK DSECT ,                   Log Record Secondary Index Block
LOGSISIZ DS    FD                  Size of This Secondary Index Block
LOGSIPRV DS    AD                  Prev Secondary Index Block or Zero
LOGSINXT DS    AD                  Next Secondary Index Block or Zero
LOGSIFST DS    AD                  Addr of First Data Entry in Block
LOGSICNT DS    FD                  Count of Data Pointers in This Block
LOGSIHP2 DS    FD                  Highest Power of 2 LE Entry Count
LOGSIKEY DS    0CL(L'LOGSITIM+L'LOGSITCB+L'LOGSISEQ) Highest Key in Blk
LOGSITIM DS    XL16                ..Log Record Entry Time Stamp
LOGSITCB DS    XL4                 ..Log Record Entry TCB Address
LOGSISEQ DS    XL4                 ..Log Record Entry Sequence No.
         ORG   LOGSIBLK+768        (Reserved - LOGGER)
LOGSINDX DS    0AD                 Last Available Secondary Indx Entry
         DS    4000AD              Allow 4,000 Secondary Index Pointers
         ORG   *-8                 Point at Last Secondary Index Entry
LOGSILST DS    AD                  Addr Highest Secondary Index Entry
LOGSISPL EQU   (*-LOGSINDX)/2      Len of a Split Secondary Index Block
LOGSILEN EQU   *-LOGSIBLK          Set Length of Secondary Index Block
LOGSISGZ EQU   (1024*1024)         Set Size of Secondary Index Segment
*
*+-------------------------------------------------------------------+*
*|             Log Record Control Block for Buffer Areas             |*
*+-------------------------------------------------------------------+*
*
LOGTRBLK DSECT ,                   Log Record Entry Data Cntl Block
LOGTRSIZ DS    FD                  Size of the Log Record Data Block
LOGTRNXT DS    AD                  Address of the Next Block on Chain
LOGTRCNT DS    FD                  Count of Record Entries in Buffer
LOGTRSLT DS    AD                  First Available Slot in Buffer Area
         DS    D                   (Reserved - LOGGER)
LOGTRHLN EQU   *-LOGTRBLK          Length of Data Block Header Section
         ORG   LOGTRBLK            Reset Buffer Area Location Counter
LOGTRRCD DS    0F                  Address of First Log Record Entry
LOGTRKEY DS    0CL(L'LOGTRTIM+L'LOGTRTCB+L'LOGTRSEQ) Log Record Key
LOGTRTIM DS    XL16                ..Log Record Entry Time Stamp
LOGTRTCB DS    XL4                 ..Log Record Entry TCB Address
LOGTRSEQ DS    XL4                 ..Log Record Entry Sequence No.
*
LOGTRCRD DS    CL(L'LGWLINE)       Area for the Log Trace Event Record
LOG$BLK@ DS    AD                  Log Record Buffer Area Block Address
*
LOGTRLEN EQU   *-LOGTRRCD          Length of Log Record Buffer Entry
LOGPIDBS EQU   1024*8192           Size of Rcrd Area for Storage (8Meg)
LOGTRMXB EQU   (LOGPIDBS-LOGTRHLN)/LOGTRLEN  Maximum Blocks in a Buffer
LOGMXSIZ EQU   (1*10240)           Max Memlimit in Megabytes (10Gig)
*
         EJECT ,
*+-------------------------------------------------------------------+*
*|            z / O S   S y s t e m   D s e c t s                    |*
*+-------------------------------------------------------------------+*
*
         PRINT NOGEN
         CVT    DSECT=YES,LIST=YES Communications Vector Table
         DCBD   DSORG=PS,DEVD=DA   Data Control Block
         IHADCBE                   Data Control Block Extension
         IHARB    LIST=YES         Request Block
         IHAXSB   LIST=YES         RB Extended Status Block
         IHAPSA   LIST=YES         Prefix Storage Area
         IHAPSAX  DSECT=YES,PSAX=YES  Prefix Storage Area Extension
         IKJTCB   LIST=YES         Job Task Control Block
         IEZDEB   LIST=YES         Data Extent Block
         IEZJSCB ,                 Job Step Control Block
         IHADSAB                   Data Set Association Block
         IHAQDB   DSECT=YES        Queue Descriptor Block
         IHADFA ,                  Data Facilities Area
         IHASDWA ,                 System Diagnostic Work Area Recovery
         IHALLE ,                  Load List Element
         IHACDE ,                  Contents Directory Entry (JPAQ)
         IHAXTLST ,                Extent List for CDE/LPDE Modules
         IHALPDE ,                 Link Pack Directory Entry (LPAD)
         IGVVSMD                   VSM Descriptors
         IHAEPIE ,                 Extended Progrm Interruption Element
         IEFTCT                    SMF Timing Control Table
         IEFJESCT TYPE=DSECT,MNTBL=YES  JES Communication Table
         IEFZB505 LOCEPAX=YES      EPA Mapping for SWA Manager
         IEFUCBOB LIST=YES,PREFIX=YES  Unit Control Block
TIODSECT DSECT
         IEFTIOT1                  Task Input/Output Table
JFCB     DSECT *
         IEFJFCBN LIST=YES         Job File Control Block
         END
