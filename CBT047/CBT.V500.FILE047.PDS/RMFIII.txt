./       ADD   NAME=$AMODE
         MACRO
&LABEL  $AMODE &MODE,&REG=R9,&SAVE=,&RESET=
&SP      SETC  'SP'.'&SYSNDX'
         AIF   (T'&MODE EQ 'O').MODEOK
         AIF   ('&MODE' EQ '24' OR '&MODE' EQ '31').MODEOK
         MNOTE 12,'*** INVALID AMODE SPECIFIED.'
         MEXIT
.MODEOK  ANOP
         AIF   (T'&LABEL EQ 'O').NOLABEL
&LABEL   DS    0H
.NOLABEL ANOP
         L     &REG,16
         TM    CVTDCB-CVTMAP(&REG),CVTMVSE
         BZ    &SP
         AIF   (T'&SAVE EQ 'O').NOSAVE
         SR    &REG,&REG
         BSM   &REG,0
         ST    &REG,&SAVE
.NOSAVE  ANOP
         AIF   (T'&RESET EQ 'O').SET
         L     &REG,&RESET
         O     &REG,=AL4(*+6)
         BSM   0,&REG
         AGO   .AMODE99
.SET     ANOP
         AIF   ('&MODE' EQ '31').TO31
         L     &REG,=AL4(*+6)
         BSM   0,&REG
         AGO   .AMODE99
.TO31    ANOP
         L     &REG,=AL4(*+6+X'80000000')
         BSM   0,&REG
.AMODE99 ANOP
&SP      DS    0H
         MEND
./       ADD   NAME=$EPILOG
         MACRO
&LABEL   $EPILOG &RC
&LABEL   LR    R1,R13              GET SAVEAREA ADDRESS
         L     R13,4(R13)          GET BACK CHAIN POINTER
         L     R0,16(R13)          GET SAVEAREA LENGTH
         ST    R15,16(R13)         SAVE REGISTER 15 (RETCODE)
         FREEMAIN R,LV=(0),A=(1)   FREE SAVEAREA
         LM    R14,R12,12(R13)     RESTORE CALLERS REGS
         AIF   (T'&RC EQ 'O').SPEC
         LA    R15,&RC             SET RETURN CODE
.SPEC    ANOP
         BR    R14                 RETURN TO CALLER
         MEND
./       ADD   NAME=$JCL
//TSGJCLU  JOB (T50000),'TSGJCL  ',
//         NOTIFY=TSGJCL,MSGCLASS=X,CLASS=Z
//ERB3  EXEC PGM=ERB3POST,REGION=128M
//STEPLIB  DD  DSN=TSGJCL.SYSTEMS.LOAD,
//             DISP=SHR
//SYSUT1   DD  DSN=SYS3.RMFIII.DS1,
//             DISP=SHR
//SYSUDUMP DD  SYSOUT=*
//SYSPRINT DD  SYSOUT=*
//ASIDLIST DD  SYSOUT=*
//ASIDS    DD  DSN=&&ASIDS,
//             DISP=(,CATLG),
//             UNIT=WORK,
//             SPACE=(CYL,(10,5),RLSE)
//DEVICES  DD  DSN=&&DEVICES,
//             DISP=(,CATLG),
//             UNIT=WORK,
//             SPACE=(CYL,(10,5),RLSE)
//*
//         EXEC SAS
//ASIDS    DD  DSN=&&ASIDS,
//             DISP=SHR
//DEVICES  DD  DSN=&&DEVICES,
//             DISP=SHR
//SYSIN    DD  DSN=TSGJCL.SYSTEMS.RMFIII(SASASID),
//             DISP=SHR
//         DD  DSN=TSGJCL.SYSTEMS.RMFIII(SASDEVCE),
//             DISP=SHR
//
./       ADD   NAME=$PROLOG
         MACRO
&LABEL   $PROLOG &LV=0
.**********************************************************************
.*
.*       THIS MACRO WILL PROVIDE ENTRY LINKAGE AND OPTIONALLY
.*       MULTIPLE BASE REGISTERS.  ALSO, VIA THE 'LV=' KEYWORD
.*       PROVIDE ADDITIONAL USER STORAGE (APPENDED TO THE
.*       SAVE AREA) ADDRESSABLE FROM REG 13.  IF NO OPERANDS
.*       ARE CODED, REG 12 IS ASSUMED THE BASE. EXAMPLE:
.*              SECTNAME $PROLOG          = STANDARD REG 12 BASE
.*              SECTNAME $PROLOG 5        = STANDARD, REG 5 BASE
.*              SECTNAME $PROLOG 10,LV=20 = ADD 20 BYTES TO SAVE AREA
.*                                             REG 10 IS BASE
.*              SECTNAME $PROLOG R10,R11  = REGS 10 AND 11 ARE BASES
.*
.**********************************************************************
         LCLA  &AA,&AB,&AC
         GBLB  &PRORG
&AC      SETA  4096
&LABEL   CSECT
         B     32(R15)             BRANCH AROUND
         DC    AL1(26)
         DC    CL8'&LABEL'         CSECT NAME
         DC    C'-'
         DC    CL8'&SYSDATE'       COMPILE DATE
         DC    C'-'
         DC    CL8'&SYSTIME'       COMPILE TIME
         CNOP  0,4                 ALIGNMENT
         STM   R14,R12,12(R13)     SAVE REGISTERS
         LR    R12,R15             LOAD BASE REG
         USING &LABEL,R12          INFORM ASSEMBLER
         AIF   (&LV GT 4023).MERR
         LA    R0,&LV+72           LOAD REG 0 WITH LENGTH VARIABLE
         GETMAIN R,LV=(0)          GET CORE FOR SAVEAREA AND USER
         AIF   (&LV+72 LE 256).XC2
         AIF   (&LV+72 LE 512).XC1
         MVI   0(R1),X'00'         MOVE X'00' TO FIRST BYTE
         LR    R2,R1               SAVE POINTER IN EVEN REG
         LA    R4,1(R1)            SET RECEIVING POINTER
         LR    R5,R0               SET RECEIVING LENGTH
         BCTR  R5,R0               DECREMENT LENGTH
         LA    R5,0(R5)            CLEAR HIGH ORDER BYTE
         LA    R3,1                SET SENDING LENGTH
         MVCL  R4,R2               INSTRUCTION PADS WITH X'00'
         AGO   .STORE
.XC1     ANOP
         XC    256(&LV-184,R1),256(R1)  CLEAR SAVE AREA
         XC    0(256,R1),0(R1)          CLEAR SAVE AREA
         AGO   .STORE
.XC2     ANOP
         XC    0(&LV+72,R1),0(R1)       CLEAR SAVE AREA
.STORE   ANOP
         ST    R13,4(R1)           SAVE BACK CHAIN
         ST    R1,8(R13)           SET FORWARD CHAIN
         LR    R11,R1              SAVE NEW SAVEAREA ADDRESS
         L     R15,16(R13)         RESTORE REG 15
         ST    R0,16(R13)          SAVE SAVEAREA LENGTH
         LM    R0,R1,20(R13)       RESTORE REGS USED IN GETMAIN
         LR    R13,R11             SET SAVEAREA POINTER
         AIF   (N'&SYSLIST EQ 0).MEND
         AIF   ('&SYSLIST(1)' EQ 'R12').SKIPIT
         AIF   ('&SYSLIST(1)' EQ '12').SKIPIT
         LA    &SYSLIST(1),&LABEL  LOAD REQUESTED BASE REG
         DROP  R12                 DROP ASSUMED BASE REG
         USING &LABEL,&SYSLIST(1)  INFORM ASSEMBLER
.SKIPIT  ANOP
&AA      SETA  2
.LOOP    ANOP
         AIF   (&AA GT N'&SYSLIST).MEXIT
&AB      SETA  &AA-1
         LA    &SYSLIST(&AA),2048(&SYSLIST(&AB))  LOAD NEXT BASE REG
         LA    &SYSLIST(&AA),2048(&SYSLIST(&AA))  LOAD NEXT BASE REG
         USING &LABEL+&AC,&SYSLIST(&AA) INFORM ASSEMBLER
&AC      SETA  &AC+4096
&AA      SETA  &AA+1
         AGO   .LOOP
.MEXIT   ANOP
         AIF   (&PRORG).MEX2
         SPACE
         $REGS
         SPACE
.MEX2    ANOP
&AA      SETA  &LV+72
         MNOTE *,'TOTAL STORAGE AREA RECEIVED = &AA'
         MEXIT
.MEND    ANOP
         MNOTE *,'NO REGISTER SPECIFIED - R12 ASSUMED'
         AGO   .MEXIT
.MERR    ANOP
         MNOTE 12,'LV > 4023 - REQUEST IGNORED'
         AGO   .MEXIT
         MEND
./       ADD   NAME=$REGS
         MACRO
         $REGS
         GBLB  &PRORG
         AIF   (&PRORG).MEX2
&PRORG   SETB  1
 SPACE
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
 SPACE
REG0     EQU   0
REG1     EQU   1
REG2     EQU   2
REG3     EQU   3
REG4     EQU   4
REG5     EQU   5
REG6     EQU   6
REG7     EQU   7
REG8     EQU   8
REG9     EQU   9
REG10    EQU   10
REG11    EQU   11
REG12    EQU   12
REG13    EQU   13
REG14    EQU   14
REG15    EQU   15
 SPACE
.MEX2    ANOP
       MEND
./       ADD   NAME=@STCK
         MACRO
&LABEL   @STCK  &TYPE
         LCLC   &L
.**********************************************************************
.****    THIS MACRO WILL PROVIDE THE DAY, DATE, AND TIME FROM
.****    THE TIME-OF-DAY CLOCK IN GREGORIAN (ENGLISH) FORMAT.
.**********************************************************************
.****    TYPE SHOULD BE: 'BOTH' - GEN CODE AND DATA AREAS.
.****                    'CODE' - GEN CODE ONLY.
.****                    'DATA' - GEN DATA AREA ONLY.
.**********************************************************************
.****    DATA AREAS ARE SHOWN BELOW:
.****
.****  STCK     DC   CL28'MM/DD/YY HH:MM:SS DOW YY.DDD'
.****
.****  STCKDATE DS   CL8    THE DATE IN MM/DD/YY FORMAT
.****
.****  STCKTIME DS   CL8    THE TIME IN HH:MM:SS FORMAT
.****
.****  STCKDOW  DS   CL3    CHAR DAY OF WEEK
.****
.****  STCKDATJ DS   CL6    YY.DDD - JULIAN DATE
.****
.****  STCKWRK1 DS   D      WORK AREA
.****  STCKWRK2 DS   D      WORK AREA
.****
.****  STCKDOWX DS   H      A BINARY NUMBER (HEX) RELATIVE TO
.****                       THE DAY OF THE WEEK AS FOLLOWS
.****                       0=MONDAY, 1=TUESDAY, 2=WEDNESDAY,
.****                       3=THURSDAY, 4=FRIDAY,
.****                       5=SATURDAY, 6=SUNDAY
.****  STCKDDDX DS   H      A BINARY NUMBER-DAY IN YEAR 1-366
.****  STCKYYX  DS   H      A BINARY NUMBER-YEAR
.****  STCKMMX  DS   H      A BINARY NUMBER-MONTH (1-12)
.****  STCKDDX  DS   H      A BINARY NUMBER-DAY-OF-MONTH (1-31)
.****
.****  STCKSTCK DS   CL8    THE STCK TO BE CONVERTED
.****
.****    NOTE THAT THE CALLER MUST PROVIDE A REGISTER SAVE AREA
.****    THAT BEGINS ON A DOUBLEWORD BOUNDARY TO BE USED AS A
.****    WORK AREA BY THIS ROUTINE (R-13 BASED).
.****
.**********************************************************************
&L       SETC  '&SYSNDX'
&LABEL   DS    0H                 STORE THE TIME-OF-DAY CLOCK
         AIF    ('&TYPE' EQ 'DATA').GEN ONLY DO DATA
         AIF    ('&TYPE' EQ 'BOTH').CODE DO CODE
         AIF    ('&TYPE' EQ 'CODE').CODE DO CODE
         MNOTE 8,'INVALID TYPE:  &TYPE , MUST BE DATA,BOTH, OR CODE'
.CODE    ANOP
*
**             GET INPUT, ADJUST TIME ZONE
*
         LM    R0,R1,STCKSTCK          LOAD INTO WORK REGS
         L     R15,16                  GET CVT ADDRESS
         A     R0,304(R15)             ADD LOCAL TIME DEVIATION
         SRDL  R0,12                   ISOLATE NUMBER OF MICROSECONDS
*              MINUTES
         D     R0,=F'60000000'         DIVIDE BY 60M (R1=MINUTES AFT EP
         LR    R15,R0                  COPY REMAINDER OF MICS TO GET SE
         SR    R14,R14                 CLEAR FOR DIVIDE
*              SECONDS
         D     R14,=F'951424'          DIVIDE TO GET REMAINING SECONDS
         LR    R14,R15                 COPY TO WORK REG
S&L.B    SL    R14,=F'60'              DECREMENT BY 60 SECONDS
         BM    S&L.S                   LESS THAN SIXTY, CONTINUE
         SL    R15,=F'60'              MORE THAN SIXTY, ADJUST FOR LEAP
         AL    R1,=F'1'                BUMP MINUTES
         B     S&L.B                   CHECK AGAIN
*
**             DISPLAYABLE TIME HH:MM:SS
*
S&L.S    CVD   R15,STCKWRK1            CONVERT SECONDS TO PACKED FORMAT
         UNPK  STCKWRK2(4),STCKWRK1    UNPACK SECONDS FOR PRINT
         OI    STCKWRK2+3,X'F0'        SET UP FOR PRINTING
         MVC   STCKTIME+6(2),STCKWRK2+2 MOVE THE SECONDS
*
         XR    R0,R0
         D     R0,=F'60'               DIVIDE INTO HOURS AND MINUTES
         CVD   R0,STCKWRK1             CONVERT MINUTES TO PACKED
         UNPK  STCKWRK2(4),STCKWRK1    UNPACK MINUTES FOR PRINT
         OI    STCKWRK2+3,X'F0'        SET UP FOR PRINTING
         MVC   STCKTIME+3(2),STCKWRK2+2 MOVE THE MINUTES
*
         XR    R0,R0                   CLEAR
         D     R0,=F'24'               R1=DAYS AND R0=HOURS
         CVD   R0,STCKWRK1             CONVERT HOURS TO PACKED
         UNPK  STCKWRK2(4),STCKWRK1    UNPACK HOURS FOR PRINT
         OI    STCKWRK2+3,X'F0'        SET UP FOR PRINTING
         MVC   STCKTIME+0(2),STCKWRK2+2 MOVE THE HOURS
*
         MVI   STCKTIME+2,C':'         ADD COLIN
         MVI   STCKTIME+5,C':'         ADD COLIN
*
**             DAY-OF-WEEK
*
         LR    R15,R1                  COPY NUMBER OF DAYS
         XR    R14,R14                 CLEAR
         D     R14,=F'7'               GET DAY INDEX
         STC   R14,STCKDOWX            SET RELATIVE DAY OF WEEK
         MH    R14,=H'3'               WEEKDAY: 0,3,..
         LA    R14,S&L.W(R14)          GET 3CHAR DAY
         MVC   STCKDOW,0(R14)          MAKE DISPLAYABLE
*
**             JULIAN
*
         XR    R0,R0                   CLEAR EVEN REG
         S     R1,=F'365'              # OF DAYS SINCE JAN 1, 1901
         D     R0,=F'1461'             # COMPLETED LEAP YRS
         SLA   R1,2                    * LEAP YEARS BY 4
         LR    R14,R1                  SAVE
         STH   R1,STCKYYX              SAVE BINARY YEAR FOR CALLER
         LR    R1,R0                   REMANDER
         SR    R0,R0                   CLEAR R0
         D     R0,=F'365'              # COMPLETED YRS (NOT INCL LEAPS)
         AR    R1,R14                  # OF LEAPS*4
         LA    R1,1(,R1)               +1 FOR 1900 ADJUST ABOVE
         LR    R14,R1                  SAVE BINARY YEAR
         AH    R0,=H'1'                JAN 1 IS XX001 NOT XX000
         LR    R15,R0                  SAVE BINARY DAY(1-366)
         STH   R0,STCKDDDX             SAVE BINARY DAY FOR CALLER
         MH    R1,=H'1000'             YY OVER 3 DIGITS
         AR    R1,R0                   ADD DAYS
         CVD   R1,STCKWRK2             DEC VERSION 0..YYDDDS
         MVC   STCKWRK1(7),=X'4021204B202020'
         ED    STCKWRK1(7),STCKWRK2+5  JULIAN
         MVC   STCKDATJ,STCKWRK1+1     KILL BLANK
*
**             GREGORIAN
*
         CVD   R14,STCKWRK1            DEC. YEAR
         UNPK  STCKDATE+6(2),STCKWRK1+6(2) UNPACK INTO OUT AREA
         LA    R1,S&L.T                LOAD ADDR OF TABLE
         N     R14,=F'3'               SEE IF MULT OF 4
         BNZ   S&L.NL                  NOT 0, BRANCH
         LA    R1,S&L.TL               LEAP YEAR
S&L.NL   LR    R0,R1                   SAVE TABLE ADDR
S&L.L    IC    R14,0(R1)               LOAD CHAR FROM TABLE
         LA    R1,1(R1)                INDEX TABLE POINTER
         SR    R15,R14                 SUBTRACT FROM WORK VALUE
         BP    S&L.L                   STILL POSITIVE, DO AGAIN
         AR    R15,R14                 ELSE, ADD IT BACK
         STH   R15,STCKDDX             SAVE BINARY DAY FOR CALLER
         CVD   R15,STCKWRK1            CONVERT TO DEC
         UNPK  STCKDATE+3(2),STCKWRK1+6(2) UNPACK DAY
         SR    R1,R0                   GET MONTH INDEX FROM TABLE
         STH   R1,STCKMMX              SAVE BINARY MONTH FOR CALLER
         CVD   R1,STCKWRK1             CONVERT TO DEC
         UNPK  STCKDATE(2),STCKWRK1+6(2)  UNPACK MONTH INTO OUT
         OI    STCKDATE+1,C'0'         INSURE NUMERICS
         OI    STCKDATE+4,C'0'         INSURE NUMERICS
         OI    STCKDATE+7,C'0'         INSURE NUMERICS
         MVI   STCKDATE+2,C'/'         ADD SLASH
         MVI   STCKDATE+5,C'/'         ADD SLASH
*
**             CONSTANTS
*
         B     S&L.E                    BR AROUND CONSTANTS
S&L.W    DC    C'MONTUEWEDTHUFRISATSUN' DAYS OF WEEK
S&L.T    DC    AL1(31,28,31,30,31,30,31,31,30,31,30,31) MONTH TABLE
S&L.TL   DC    AL1(31,29,31,30,31,30,31,31,30,31,30,31) LEAP YEAR
         AIF    ('&TYPE' EQ 'CODE').NOGEN ONLY DO CODE
.GEN     ANOP
STCK     DC    0C'MM/DD/YY HH:MM:SS DOW YY.DDD'
STCKDATE DC    C'  /  /  '             MM/DD/YY
         DC    C' '                    FILLER                  25JUN84
STCKTIME DC    C'  :  :  '             HH:MM:SS
         DC    C' '                    FILLER                  25JUN84
STCKDOW  DC    C'XXX'                  DAY OF THE WEEK
         DC    C' '                    FILLER                  25JUN84
STCKDATJ DC    C'YY.DDD'               JULIAN DATE
         DC    C' '                    FILLER                  25JUN84
STCKWRK1 DS    D                       WORK
STCKWRK2 DS    D                       WORK
STCKSTCK DS    D                       STORE CLOCK INPUT
STCKDOWX DC    H'00'                   REL. DAY OF THE WEEK
STCKDDDX DC    H'00'                   BINARY DAY IN YEAR (1-366)
STCKYYX  DC    H'00'                   BINARY YEAR
STCKMMX  DC    H'00'                   BINARY MONTH (1-12)
STCKDDX  DC    H'00'                   BINARY DAY-OF-MONTH (1-31)
.NOGEN   ANOP
S&L.E    DS    0H
         MEND
./       ADD   NAME=DATASECT
DATASECT CSECT ,
         PRINT GEN
        @STCK  DATA
         PRINT NOGEN
DOUBLE   DC    D'0'
DWK2     EQU   DOUBLE+6,2
DWK3     EQU   DOUBLE+5,3
PWAOPN   DC    F'0'               0=CLOSED, 255=OPEN
PWDOPN   DC    F'0'               0=CLOSED, 255=OPEN
         DS    0F
TABSTART DS    AL4                START OF MONITOR III DATA
TABEND   DS    AL4                END OF MONITOR III DATA
BXLE1    DS    3AL4               LOOP CONTROL TO FILL TABLE.
         SPACE ,
CURRSSH  DC    AL4(0)             CURRENT SET OF SAMPLES HDR ADDR.
CURRASIG DC    AL4(0)             CURRENT ASID TABLE ADDR
CURRDVTG DC    AL4(0)             CURRENT DEVICE TABLE ADDR.
LASTSAMP DC    AL4(0)             ADDR OF LAST HEADER IN A SET OF SMPLS
         SPACE ,
ACBAD    DS    AL4                INPUT ACB ADDRESS
RPLAD    DS    AL4                INPUT RPL ADDRESS
EXLAD    DS    AL4                EXLST ADDRESS
ARGFLD   DS    AL4                ARGUMENT FIELD. FEEDS BACK RRN
PLINE0   DS    2AL4               PARM LIST FOR PRINT ROUTINE
PRTLINE  DS    CL133              PRINT LINE WORK AREA.
PWALHD1  XPRLDEF TEXT=PWLHDT1,LENGTH=L'PWLHDT1,SPB=(0,ATHOF),SPA=1
PWLHDT1  DC    C'&NAME &VERSION -- LISTING OF ACTIVE ASIDS'
PWALHD2  XPRLDEF TEXT=PWLHDT2,LENGTH=132,SPB=0,SPA=2
PWLHDT2  DS    0H
         DC    CL132' '
         ORG   PWLHDT2
         DC    CL1' '
         DC    CL8'JOBN/SER',CL2' '       JOB NAME
         DC    CL3'TYP',CL2' '       JOB/TSU/STC
         DC    CL3'DOW',CL2' '      DAY OF THE WEEK
         DC    CL8'--DATE--',CL2' '      DATE MM/DD/YY
         DC    CL8'--TIME--',CL2' '      TIME HH:MM:SS
         DC    CL11'--CPU TIME-',CL2' '      CPU TIME
         DC    CL5'#SMPL',CL2' '      VALID SAMPLES
         DC    CL3'USG',CL2' '      USING PERCENT
         DC    CL3'DLY',CL2' '      DELAY PERCENT
         DC    CL8'USG JOBN',CL2' '
         DC    CL8'DLY JOBN',CL2' '
         ORG   PWLHDT2+132
         SPACE ,
LA1LINE  DC    CL133' '
         ORG   LA1LINE
         DC    CL1' '
LA1JOBNA DC    CL8' ',CL2' '       JOB NAME
LA1TYPE  DC    CL3' ',CL2' '       JOB/TSU/STC
LA1DOW   DC    CL3' ',CL2' '      DAY OF THE WEEK
LA1DATE  DC    CL8' ',CL2' '      DATE MM/DD/YY
LA1TIME  DC    CL8' ',CL2' '      TIME HH:MM:SS
LA1CPUTM DC    CL11' ',CL2' '      CPU TIME
LA1SMPLS DC    CL5' ',CL2' '      VALID SAMPLES
LA1USING DC    CL3' ',CL2' '      USING PERCENT
LA1DELAY DC    CL3' ',CL2' '      DELAY PERCENT
         ORG   LA1LINE+133
         SPACE ,
LD1LINE  DC    CL133' '
         ORG   LD1LINE
         DC    CL1' '
LD1VOLI  DC    CL6' ',CL4' '       VOLSER
LD1TYPE  DC    CL3' ',CL2' '       DEV
LD1DOW   DC    CL3' ',CL2' '      DAY OF THE WEEK
LD1DATE  DC    CL8' ',CL2' '      DATE MM/DD/YY
LD1TIME  DC    CL8' ',CL2' '      TIME HH:MM:SS
         DC    CL11' ',CL2' '
LD1SMPLS DC    CL5' ',CL2' '
LD1USING DC    CL3' ',CL2' '      USING PERCENT
LD1DELAY DC    CL3' ',CL2' '      DELAY PERCENT
LD1HUJBN DC    CL8' ',CL2' '      HIGHEST USING JOB
LD1HWJBN DC    CL8' ',CL2' '      MOST DELAYED JOB
         ORG   LD1LINE+133
         SPACE 1
         DS    0F
PWA      XPRDCB  DDNAME=SYSPRINT
HEADER1  XPRLDEF TEXT=HTEXT1,LENGTH=L'HTEXT1,SPB=(0,ATHOF),SPA=1
HTEXT1   DC    C'&NAME &VERSION -- LISTING OF RMF MONITOR III RECORDINGX
                DATASET CONTENTS            '
HEADER2A XPRLDEF TEXT=HTEXT2A,LENGTH=L'HTEXT2A,SPB=0,SPA=2
HTEXT2A  DC    C'DSIG3: DATASET RECORD AND TABLE FORMATS '
./       ADD   NAME=EDIT
         MACRO
&NAME    EDIT  &PR,&NUM,&ED
         LCLA  &A1,&A2,&A3,&A4
         LCLB  &B1,&B2
         LCLC  &C1,&C2,&C3
         ACTR  200
         AIF   (N'&SYSLIST EQ 2 AND K'&ED EQ 0).ANOP1
         AIF   (N'&SYSLIST NE 3).MNOTE1
         AIF   ('&ED'(1,1) EQ '-' OR '&ED'(1,1) EQ '$').EDMK
.ANOP1   ANOP
&A1      SETA  &A1+1
         AIF   (K'&ED LT &A1).CONT
&A2      SETA  &A2+1
&A4      SETA  &A4+1
         AIF   ('&ED'(&A1,1) NE 'Z' AND '&ED'(&A1,1) NE '&C2').NINE
.ANOP2   ANOP
&C1      SETC  '&C1.20'
         AGO   .ANOP1
.NINE    AIF   ('&ED'(&A1,1) NE '9').PER
         AIF   (&B1).ANOP2
&B1      SETB  1
         AIF   (&A1 EQ 1).SIGNIF
         AIF   (&A1 EQ 2 AND &B2).SIGNIF
&C3      SETC  '&C1'(&A4*2-3,2)
         AIF   ('&C3' NE '20').NINE2
&C1      SETC  '&C1'(1,&A4*2-4).'2120'
         AGO   .ANOP1
.NINE2   ANOP
&C1      SETC  '&C1'(1,&A4*2-6).'21&C3.20'
         AGO   .ANOP1
.SIGNIF  ANOP
&C1      SETC  '21'
         AGO   .ANOP1
.PER     AIF   ('&ED'(&A1,1) NE '.').COMMA
&C1      SETC  '&C1.4B'
&A2      SETA  &A2-1
         AGO   .ANOP1
.COMMA   AIF   ('&ED'(&A1,1) NE 'V').SLASH
&C1      SETC  '&C1.6B'
&A2      SETA  &A2-1
         AGO   .ANOP1
.SLASH   AIF   ('&ED'(&A1,1) NE '/').DBCR
&C1      SETC  '&C1.61'
&A2      SETA  &A2-1
         AGO   .ANOP1
.DBCR    AIF   (&A1+1 NE K'&ED).MNOTE2
         AIF   ('&ED'(&A1,2) NE 'CR').DB
&C1      SETC  '&C1.C3D9'
&A2      SETA  &A2-1
         AGO   .CONT
.DB      AIF   ('&ED'(&A1,2) NE 'DB').MNOTE2
&C1      SETC  '&C1.C4C2'
&A2      SETA  &A2-1
.CONT    ANOP
&C3      SETC  '&PR'
         AIF   (L'&NUM*2-1 NE &A2).EDSIZE
.ENDCHEC ANOP
&A2      SETA  0
         AIF   (K'&C1/2+1 NE L'&PR).AREASIZ
.LAST    AIF   (&B2).EDMKEND
&NAME    MVC   &C3,=X'40&C1'
         ED    &C3,&NUM
         MEXIT
.EDSIZE  AIF   (L'&NUM*2-1 LT &A2).LONG
.SHORT   ANOP
&C1      SETC  '20&C1'
&A3      SETA  &A3+1
         AIF   (L'&NUM*2-1 GT &A2+&A3).SHORT
         AGO   .ENDCHEC
.LONG    ANOP
&C1      SETC  '&C1'(3,K'&C1-2)
&A3      SETA  &A3+1
         AIF   (L'&NUM*2-1 LT &A2-&A3).LONG
         AGO   .ENDCHEC
.AREASIZ AIF   (K'&C1/2+1 LT L'&PR).LESS
&A2      SETA  K'&C1/2+1-L'&PR
&A3      SETA  K'&C1/2+1
&C3      SETC  '&C3-&A2.(&A3)'
&B1      SETB  1
         AGO   .LAST
.LESS    ANOP
&B1      SETB  0
&A3      SETA  K'&C1/2+1
         AIF   (K'&C1/2+5 GE L'&PR).PLUSET
&C3      SETC  '&C3.(&A3)'
         AGO   .LAST
.PLUSET  ANOP
&A2      SETA  L'&PR-K'&C1/2-1
&C3      SETC  '&C3+&A2.(&A3)'
         AGO   .LAST
.EDMK    AIF   ('&ED'(1,1) EQ '-').NEG
&C2      SETC  '$'
         AGO   .C2SET
.NEG     ANOP
&C2      SETC  '-'
.C2SET   ANOP
&A1      SETA  1
&B2      SETB  1
         AGO   .ANOP1
.EDMKEND ANOP
&A1      SETA  -1
.EDMKNOP ANOP
&A1      SETA  &A1+2
         AIF   (K'&C1 LT &A1).SETA
         AIF   ('&C1'(&A1,2) EQ '21').SETAA
         AIF   ('&C1'(&A1,2) NE '4B').EDMKNOP
&A1      SETA  (&A1+1)/2
         AGO   .LA
.SETA    ANOP
&A1      SETA  (&A1+1)/2-1
         AGO   .LA
.SETAA   ANOP
&A1      SETA  (&A1+1)/2+1
.LA      ANOP
         AIF   (&B1).MINUS
&A1      SETA  &A1+&A2
         AGO   .MVC
.MINUS   ANOP
&A1      SETA  &A1-&A2
.MVC     ANOP
&NAME    MVC   &C3,=X'40&C1'
         LA    1,&PR+&A1
         EDMK  &C3,&NUM
         AIF   ('&C2' EQ '$').DOLLAR
         BNM   EDIT&SYSNDX
         BCTR  1,0
         MVI   0(1),C'-'
&C3      SETC  '&SYSNDX'
EDIT&C3  EQU   *
         MEXIT
.DOLLAR  BCTR  1,0
         MVI   0(1),C'$'
         MEXIT
.MNOTE1  MNOTE 8,'THREE OPERANDS MUST BE SPECIFIED'
         MEXIT
.MNOTE2  MNOTE 8,'INVALID EDIT PATTERN'
         MEND
./       ADD   NAME=ERBASIG3
         MACRO
         ERBASIG3
ASIG3    DSECT ,
ASIASIG3 DS    CL5           ACRONYM 'ASIG3'
ASIVERG3 DS    XL1           CONTROL BLOCK VERSION X'04'           @035
ASIHDRLE DS    XL1           LENGTH OF ASIG3 HEADER
ASIENTLE DS    XL1           LENGTH OF EACH TABLE ENTRY
ASIENTMX DS    XL4           NUMBER OF TABLE ENTRIES
ASIENTNR DS    XL4           INDEX OF LAST TABLE ENTRY (?)
ASIG3ENT DSECT ,
ASIENIDX DS    XL2           INDEX OF THIS TABLE ENTRY
ASIOREVI DS    XL2           INDEX OF THE PREVIOUS TABLE ENTRY FOR THE
*                            SAME ADDRESS SPACE
ASIJOBNA DS    CL8           JOBNAME FOR THIS ASID
ASINPG   DS    XL2           CONTROL PERFORMANCE GROUP
         DS    XL1
ASIDMN   DS    XL1           DOMAIN
ASIASINR DS    XL2           ASID NUMBER
ASIFLAG1 DS    XL2           JOB FLAGS:
*                            BIT     MEANING WHEN SET
*                            0       STARTED TASK
*                            1       BATCH JOB
*                            2       TSO ASID
*                            3-15    RESERVED
ASICPUTA DS    XL4           TOTAL TCB+SRB TIME (IN MILLISECONDS)
ASIDCTIA DS    XL4           TOTAL CHANNEL CONNECT TIME
ASIFIXA  DS    XL4           NUMBER OF REAL FIXED FRAMES
ASITRCA  DS    XL4           TOTAL NUMBER OF TRANSACTIONS
ASIFMCT  DS    XL4           TOTAL FRAMES FOR SWAPPED-IN USERS
ASIFMCTI DS    XL4           TOTAL FRAMES FOR IDLE USERS
ASIESF   DS    XL4           EXTENDED STORAGE FRAMES - SWAPPED-IN
ASIESFI  DS    XL4           EXTENDED STORAGE FRAMES - IDLE USERS
ASISMPCT DS    XL2           NUMBER OF VALID SAMPLES
ASISWAP  DS    XL2           NUMBER OF SAMPLES WHEN JOB WAS PHYSICALLY
*                            SWAPPED OUT.
ASIIDLE  DS    XL2           NUMBER OF SAMPLES WHEN JOB WAS IDLE
ASISWAR  DS    XL2           NUMBER OF SAMPLES WHEN JOB WAS SWAPPED
*                            OUT READY.
         DS    XL2
ASIUKN   DS    XL2           NUMBER OF SAMPLES WHEN JOB STATUS UNKNOWN
ASISUSEN DS    XL2           NUMBER OF SINGLE STATE USING SAMPLES
ASISUCPR DS    XL2           # OF SINGLE STATE SAMPLES USING PROCESSOR
ASISUCDV DS    XL2           # OF SINGLE STATE SAMPLES USING DEVICE
ASISWAIN DS    XL2           # OF SINGLE STATE SAMPLES DELAYED
ASISDCPR DS    XL2           # OF SINGLE STATE SAMPLES DELAYED PROC
ASISDCDV DS    XL2           # OF SINGLE STATE SAMPLES DELAYED DEV
ASISDCST DS    XL2           # OF SINGLE STATE SAMPLES DELAYED STOR
ASISDCJE DS    XL2           # OF SINGLE STATE SAMPLES DELAYED JES
ASISDCHS DS    XL2           # OF SINGLE STATE SAMPLES DELAYED HSM
ASISDCEN DS    XL2           # OF SINGLE STATE SAMPLES DELAYED ENQ
ASIVECTA DS    XL4           TOTAL ACCUMULATED VECTOR PROC TIME    @035
         MEND
./       ADD   NAME=ERBDSIG3
         MACRO
         ERBDSIG3
DSIG3    DSECT ,
DSIDSIG3 DS    CL5           ACRONYM 'DSIG3'
DSIGRMFV DS    XL1           CONTROL BLOCK VERSION X'01'
DSIGID   DS    CL4           SYSTEM IDENTIFIER
         DS    XL2
DSIGTODC DS    XL8           TIME DATASET WAS CREATED
DSIGTODF DS    XL8           TIME STAMP FOR FIRST SET OF SAMPLES
DSIGTODL DS    XL8           TIME STAMP FOR LAST SET OF SAMPLES
DSIGFSPT DS    AL4           OFFSET OF 1ST SET OF SAMPLES FROM ERBDSIG3
DSIGLSPT DS    AL4           OFFSET OF LST SET OF SAMPLES FROM ERBDSIG3
         DS    XL4
DSIGFIPT DS    AL4           OFFSET OF 1ST INDEX ENTRY FROM ERBDSIG3
DSIGLIPT DS    AL4           OFFSET OF LAST INDEX ENTRY FROM ERBDSIG3
         DS    XL4
DSIGILEN DS    AL4           LENGTH OF AN INDEX ENTRY
         DS    XL4
         DS    XL6
DSIG3IX  DSECT ,
DSIGTOD1 DS    XL8           TIME STAMP FOR BEGINNING SET OF SAMPLES
DSIGTOD2 DS    XL8           TIME STAMP FOR ENDING SET OF SAMPLES
DSIGSBEG DS    AL4           OFFSET FROM BEGINNING OF THE DATASET TO
*                            THE SET OF SAMPLES
DSIGSLEN DS    AL4           LENGTH OF THE SET OF SAMPLES.
         DS    XL1
         DS    XL3
         MEND
./       ADD   NAME=ERBDVTG3
         MACRO
         ERBDVTG3
DVTG3    DSECT ,
DVTDVTG3 DS    CL5           ACRONYM 'DVTG3'
DVTVERG3 DS    XL1           CONTROL BLOCK VERSION - X'02'
DVTHDRLE DS    XL1           LENGTH OF THE DEVICE TABLE HEADER
DVTENTLE DS    XL1           LENGTH OF EACH TABLE ENTRY
DVTENTMX DS    XL4           NUMBER OF TABLE ENTRIES
DVTENTNR DS    XL4           INDEX OF LAST TABLE ENTRY
DVTG3ENT DSECT ,
DVTVOLI  DS    CL6           VOLSER FOR THIS DEVICE
DVTENIDX DS    XL2           INDEX OF THIS TABLE ENTRY
DVTDEVNR DS    XL2           DEVICE NUMBER IN HEX
DVTPREVI DS    XL2           INDEX OF THE PREVIOUS TABLE ENTRY FOR THE
*                            SAME DEVICE
         DS    XL4
         DS    XL4
DVTFLAG1 DS    XL1           DEVICE TYPE INDICATOR
*                            BIT     MEANING WHEN SET
*                            0       MULTIPLE EXPOSURE DEVICE
*                            1       DASD DEVICE
*                            2       TAPE DEVICE
*                            3       MSC CONTROLLER
*                            4       VIRTUAL DASD
*                            5       DEVICE HAS ALT CUA (3350P)
*                            6-7     RESERVED
DVTFLAG2 DS    XL1           DEVICE STORAGE INDICATOR
*                            BIT     MEANING WHEN SET
*                            0       CONN/DISC/PEND TIMES AVAILABLE
*                                    AT BEGIN TIME
*                            1       CONN/DISC/PEND TIMES AVAILABLE
*                                    AT END TIME
*                            2       DEV BUSY DELAY/CUB DELAY TIMES
*                                    AVAILABLE AT BEGIN TIME
*                            3       DEV BUSY DELAY/CUB DELAY TIMES
*                                    AVAILABLE AT END TIME
*                            4       DEVICE HAS PLPA DATASET
*                            5       DEVICE HAS COMMON PAGE DATASET
*                            6       DEVICE HAS LOCAL PAGE DATASET
*                            7       DEVICE HAS SWAP PAGE DATASET
DVTMEXNR DS    XL2           NUMBER OF EXPOSURE (INCLUDING BASE)
DVTDISIF DS    XL4           DEVICE DISC TIME AT BEGIN OF THE MINTIME
*                            FOR THIS SET OF SAMPLES
*                            (128 MICROSECOND UNITS).
DVTPETIF DS    XL4           DEVICE PEND TIME AT BEGIN OF THE MINTIME
*                            FOR THIS SET OF SAMPLES
*                            (128 MICROSECOND UNITS).
DVTCOTIF DS    XL4           DEVICE CONN TIME AT BEGIN OF THE MINTIME
*                            FOR THIS SET OF SAMPLES
*                            (128 MICROSECOND UNITS).
DVTDVBIF DS    XL4           DEVICE BUSY DELAY TIME AT BEGIN OF THE
*                            MINTIME FOR THIS SET OF SAMPLES
*                            (128 MICROSECOND UNITS).
DVTCUBIF DS    XL4           CONTROL UNIT BUSY DELAY AT BEGIN OF THE
*                            MINTIME FOR THIS SET OF SAMPLES
*                            (128 MICROSECOND UNITS).
DVTDISIL DS    XL4           DEVICE DISC TIME AT END OF THE MINTIME
*                            FOR THIS SET OF SAMPLES
*                            (128 MICROSECOND UNITS).
DVTPETIL DS    XL4           DEVICE PEND TIME AT END OF THE MINTIME
*                            FOR THIS SET OF SAMPLES
*                            (128 MICROSECOND UNITS).
DVTCOTIL DS    XL4           DEVICE CONN TIME AT END OF THE MINTIME
*                            FOR THIS SET OF SAMPLES
*                            (128 MICROSECOND UNITS).
DVTDVBIL DS    XL4           DEVICE BUSY DELAY TIME AT END OF THE
*                            MINTIME FOR THIS SET OF SAMPLES
*                            (128 MICROSECOND UNITS).
DVTCUBIL DS    XL4           CONTROL UNIT BUSY DELAY AT END OF THE
*                            MINTIME FOR THIS SET OF SAMPLES
*                            (128 MICROSECOND UNITS).
DVTTYP   DS    XL4           DEVICE TYPE FROM UCBTYP MACRO
         MEND
./       ADD   NAME=ERBENTG3
         MACRO
         ERBENTG3
ENTG3    DSECT ,
ENTENTG3 DS    CL5           ACRONYM 'ENTG3'
ENTVERG3 DS    XL1           CONTROL BLOCK VERSION - X'02'
ENTHDRLE DS    XL1           LENGTH OF THE ENQUEUE NAME TABLE HEADER
ENTENTLE DS    XL4           LENGTH OF EACH ENTRY
ENTENTMX DS    XL4           NUMBER OF TABLE ENTRIES
ENTENTNR DS    XL4           INDEX OF LAST TABLE ENTRY
ENTG3ENT DSECT ,
ENTENIDX DS    XL2           INDEX OF THIS TABLE ENTRY
ENTMAJNA DS    CL8           MAJOR NAME OF THIS RESOURCE
ENTMINNA DS    CL36          MINOR NAME OF THIS RESOURCE
ENTSCOPE DS    XL1           SCOPE OF THE RESOURCE:
*                            BIT     MEANING WHEN SET
*                            1       SYSTEMS
*                            2       STEP
*                            3       GLOBAL RESOURCE
*                            4-7     RESERVED
         MEND
./       ADD   NAME=ERBGEIG3
         MACRO
         ERBGEIG3
GEIG3    DSECT ,
GEIGEIG3 DS    CL5           ACRONYM 'GEIG3'
GEIVERG3 DS    XL1           CONTROL BLOCK VERSION - X'02'         @035
GEILEN   DS    XL2           LENGTH OF THIS CONTROL BLOCK
GEIWTIMB DS    XL8           SUM OF WAIT TIME FOR ALL PROCESSORS AT THE
*                            BEGIN OF THIS MINTIME INTERVAL
GEIWTIME DS    XL8           SUM OF WAIT TIME FOR ALL PROCESSORS AT THE
*                            END OF THIS MINTIME INTERVAL
GEIVERSN DS    XL1           CPU VERSION NUMBER
         DS    XL1
GEIFLAG  DS    XL1           PROCESSOR FLAG:
*                            BIT     MEANING WHEN SET
*                            0       SERVICE PROCESSOR ARCHITECTURE
*                                    SUPPORTED
*                            1-7     RESERVED
         DS    XL1
GEIMODEL DS    XL2           CPU MODEL NUMBER (PACKED UNSIGNED)
GEIIPSID DS    CL2           IPS MEMBER SUFFIX
GEIOPTN  DS    CL2           OPT MEMBER SUFFIX
GEIICSN  DS    CL2           ICS MEMBER SUFFIX
GEISID   DS    CL4           SMF ID
GEICPUOL DS    XL4           NUMBER OF ONLINE PROCESSORS
GEIAHUIC DS    XL4           HIGHEST SYSTEM UIC
GEIRPOOL DS    XL4           NUMBER OF ONLINE REAL FRAMES
GEIRCOMA DS    XL4           NUMBER OF REAL CSA FRAMES
GEIRSQAA DS    XL4           NUMBER OF REAL SQA FRAMES
GEIRAFC  DS    XL4           NUMBER OF AVAILABLE REAL FRAMES
GEINUCA  DS    XL4           NUMBER OF NUCLEUS FRAMES
         DS    XL8
GEIEESPL DS    XL4           NUMBER OF ONLINE EXTENDED STORAGE FRAMES
GEIGAGE  DS    XL4           EXTENDED STORAGE MIGRATION AGE
GEIECOME DS    XL4           NUMBER OF EXTENDED COMMON FRAMES
GEIEAEC  DS    XL4           NUMBER OF AVAILABLE EXTENDED FRAMES
GEIVECOL DS    XL4           NUMBER OF ONLINE VECTOR PROCESSORS    @035
         MEND
./       ADD   NAME=ERBREDG3
         MACRO
         ERBREDG3
REDG3    DSECT ,
REDREDID DS    XL1           RESOURCE ID:
*                            VALUE MEANING
*                            X'01' PROC
*                            X'02' DEV
*                            X'03' STOR
*                            X'04' JES2/JES3
*                            X'06' HSM
*                            X'07' ENQ
*                            X'3F' USER
REDFLAG  DS    XL1           RESOURCE DATA RECORD FLAGS:
*                            BIT   MEANING WHEN SET
*                            0     INVALID RESOURCE
*                            1     USE RECORDS AVAILABLE
*                            2     WAIT RECORDS AVAILABLE
*                            3-7   RESERVED
         DS    XL2
REDFUWDO DS    XL4           OFFSET TO 1ST USE/WAIT RECORD FROM
*                            ERBREDG3
REDUWDLE DS    0XL1          FOR USE/WAIT RECORDS, THE LENGTH OF THE
*                            RECORD
REDUSERL DS    0XL1          FOR USER RECORDS, THEN LENGTH OF THE
*                            RECORD
REDUWDL1 DS    XL1           FOR ENQ USE RECORDS, THE LENGTH OF THE
*                            RECORD WITHOUT SYSTEM/JOBNAME
REDUWDL2 DS    XL1           FOR ENQ USE RECORDS, THE LENGTH OF THE
*                            RECORD INCLUDING SYSTEM/JOBNAME
REDUWDNR DS    0XL2          NUMBER OF USE/WAIT RECORDS
REDUSERN DS    XL2           NUMBER OF USER EXIT RECORDS
         MEND
./       ADD   NAME=ERBSHDG3
         MACRO
         ERBSHDG3
SHDG3    DSECT ,
SHDSHDG3 DS    CL5           ACRONYM 'SHDG3'
SHDRMFV  DS    XL1           CONTROL BLOCK VERSION - X'02'
SHDLEN   DS    XL1           LENGTH OF SHDG3 CONTROL BLOCK
SHDFLAG1 DS    XL1           SAMPLE FLAGS:
*                            BIT     MEANING WHEN SET
*                            0       INVALID SAMPLE
*                            1-7     RESERVED
SHDPREVO DS    XL4           OFFSET TO PREVIOUS SAMPLE FROM ERBSHDG3
SHDNEXTO DS    XL4           OFFSET TO NEXT SAMPLE FROM ERBSHDG3
SHDREDOF DS    XL4           OFFSET TO FIRST RESOURCE DATA RECORD
*                            (RED) FROM ERBSHDG3
SHDREDNR DS    XL2           NUMBER OF RED RECORDS
SHDREDLE DS    XL2           LENGTH OF EACH RED ENTRY
         DS    XL4
         DS    XL2
SHDUWDNR DS    XL2           NUMBER OF USE/WAIT RECORDS
         DS    XL8
         DS    XL8
         MEND
./       ADD   NAME=ERBSSHG3
         MACRO
         ERBSSHG3
SSHG3    DSECT ,
SSHSSHG3 DS    CL5           ACRONYM 'SSHG3'
SSHRMFV  DS    XL1           CONTROL BLOCK VERSION NUMBER X'02'
SSHLEN   DS    AL2           LENGTH OF SET OF SAMPLES HEADER
SSHRMFVN DS    CL3           RMF VERSION NUMBER
         DS    XL1
         DS    XL24
SSHSHDFO DS    AL4           OFFSET OF 1ST SAMPLE HEADER FROM ERBSSHG3
SSHSHDLO DS    AL4           OFFSET OF LAST SAMPLE HEADER FROM ERBSSHG3
SSHTOTLE DS    AL4           TOTAL LENGTH FOR THIS SET OF SAMPLES
*                             (INCLUDING THE SET OF SAMPLES HEADER)
         DS    XL4
         DS    XL4
SSHSMPNR DS    AL4           NUMBER OF VALID SAMPLES
SSHTIBEG DS    XL8           BEGIN TIME FOR THIS SET OF SAMPLES
SSHTIEND DS    XL8           END TIME FOR THIS SET OF SAMPLES
         DS    XL16
SSHASIO  DS    AL4           OFFSET OF THE ASID TABLE FROM ERBSSHG3
         DS    XL4
         DS    XL4
         DS    XL4
SSHDVTO  DS    AL4           OFFSET OF THE DVT TABLE FROM ERBSSHG3
         DS    XL4
         DS    XL4
SSHENTO  DS    AL4           OFFSET OF THE ENT TABLE FROM ERBSSHG3
         DS    XL8
         DS    XL4
         DS    XL12
SSHGEIO  DS    AL4           OFFSET OF THE GENERAL INFORMATION TABLE
*                            FROM ERBSSHG3
SSHIOML  DS    XL1           PROCESSOR TYPE ON WHICH THE DATA WAS
*                            CREATED:
*        EQU   X'01'          308X/908X
*        EQU   X'02'          4381
*        EQU   X'03'          3090
SSHEFLAG DS    XL1           EXTENDED STORAGE INDICATORS:
*                             BIT     MEANING WHEN SET
*                             0       EXTENDED STORAGE INSTALLED
*                             1-7     RESERVED
         DS    XL2
SSHGOCYC DS    XL4           GATHERER CYCLE OPTION
SSHGOSTO DS    XL4           GATHERER STOP OPTION
*                            (IF THE 1ST BIT IS 0, NOSTOP IS IN EFFECT)
SSHGOSYN DS    XL4           GATHERER SYNC OPTION
*                            (IF THE 1ST BIT IS 0, NOSYNC IS IN EFFECT)
SSHGOMNT DS    XL4           GATHERER MINTIME OPTION
         DS    XL3
SSHGOCLA DS    CL1           GATHERER SYSOUT CLASS OPTION
         DS    XL4
SSHJESN  DS    CL1           NAME OF JES SUBSYSTEM
SSHGOWHL DS    XL4           GATHERER DATASET WHOLD OPTION
SSHGOWST DS    XL4           GATHERER WSTOR OPTION
         DS    XL40
SSHSTDIF DS    XL8           DIFFERENCE BETWEEN LOCAL TIME AND GMT
*                            WHERE THE DIFFERENCE EQUALS LOCAL TIME
*                            MINUS GMT
         DS    XL24
         MEND
./       ADD   NAME=ERBUWDG3
         MACRO
         ERBUWDG3
UWDG3    DSECT ,
UWDUWRID DS    XL1           USE/WAIT RECORD ID
*                            BIT     MEANING WHEN SET
*                            0       WAIT RECORD
*                            1       USE RECORD
*                            2-7     RESOURCE ID
UWDASID  DS    XL2           ADDRESS SPACE (ASIG3) TABLE INDEX
UWDDEVNR DS    0XL2          DEVICE TABLE (DVTG3) INDEX
UWDPDEVR DS    XL2           PAGING DEVICE (DVTG3) INDEX
UWDFLAGS DS    XL1           FLAGS FOR STORAGE STATUS:
*                            BIT     MEANING WHEN SET
*                            0       DELAYED FOR LOCAL REQUEST
*                            1       DELAYED FOR SWAP IN REQUEST
*                            2       DELAYED FOR COMMON REQUEST
*                            3       DELAYED FOR VIO REQUEST
*                            4       SPACE TYPE LOCAL
*                            5       SPACE TYPE SWAP
*                            6       SPACE TYPE COMMON
*                            7       SPACE TYPE VIO
         ORG   *-3
UWDJESFU DS    XL2           JES2/JES3 FUNCTION CODE
UWDJS3MO DS    XL1           JES3 MODIFICATION CODE
         ORG   *-3
UWDHSMFU DS    XL2           HSM FUNCTION CODE
UWDHSMMO DS    XL1           HSM MODIFICATION CODE
         ORG   *-3
UWDENTID DS    XL2           ENQUEUE NAME TABLE (ENTG3) INDEX
UWDFLAGE DS    XL1           ENQUEUE FLAGS:
*                            BIT     MEANING WHEN SET
*                            0       OFF=REQUEST IS EXCLUSIF
*                                    ON=REQUEST IS SHARED
*                            1       ON=REQUEST FROM ANOTHER SYSTEM
*                                    FIELDS UXDSYSNA/UWDJOBNA ARE
*                                    VALID
*                            2-7     RESERVED
UWDSYSNA DS    CL8           SYSTEM NAME OF REQUESTOR
UWDJOBNA DS    CL8           JOB NAME OF REQUESTOR
         MEND
./       ADD   NAME=ERB3POST
ERB3     TITLE 'DISCLAIMER - INSTALLATION INSTRUCTIONS'
***********************************************************************
*                                                                     *
*     THIS PROGRAM, DEVELOPED AT MANUFACTURER'S LIFE INSURANCE OR     *
*     SUPPLIED BY OTHER USERS ON A NON-RESTRICTIVE BASIS, IS OF       *
*     GENERAL INTEREST AND IS SUBMITTED FOR UNRESTRICTED DISTRIBUTION.*
*                                                                     *
*     THE AUTHOR HAS, SINCE DEVELOPING THIS PROGRAM, MOVED TO SUNCOR  *
*     INC.  USERS ARE INVITED TO SUBMIT SUGGESTIONS OR ERROR          *
*     DOCUMENTATION TO SUNCOR.  HOWEVER, NO PROMISE CAN BE MADE THAT  *
*     SUCH SUGGESTIONS WILL BE IMPLEMENTED OR ERRORS CORRECTED.       *
*     SUBMIT COMMENTS TO:                                             *
*                                                                     *
*                                                                     *
*              JIM LANE                                               *
*              TECHNICAL SUPPORT GROUP                                *
*              SUNCOR INC.                                            *
*              36 YORK MILLS RD                                       *
*              TORONTO, ONTARIO M2P 2C5                               *
*                                                                     *
*                PHONE: (416)-733-7396                                *
*                                                                     *
*                SHARE INSTALLATION CODE: SNI                         *
*                                                                     *
*     THIS PROGRAM IS MADE AVAILABLE BY SUNCOR WITHOUT CHARGE OR      *
*     CONSIDERATION.  RECIPIENTS ARE FREE TO MAKE THIS PROGRAM        *
*     AVAILABLE TO OTHERS IN LIKE MANNER.  IT MAY NOT BE SOLD.        *
*                                                                     *
*                                                                     *
***********************************************************************
 TITLE 'PROGRAM DESCRIPTION.'
***********************************************************************
*                                                                     *
*  NAME         ERB3POST                                              *
*                                                                     *
*  FUNCTION     READS THE DATASET PRODUCED BY RMF 3.5 MONITOR         *
*               III, WRITES A REPORT OF POSSIBLE ANOMOLIES AND        *
*               WRITES TWO SEQUENTIAL FILES (ONE ABOUT ADDRESS        *
*               SPACES AND ONE ABOUT DEVICES) SUMMARIZING THE         *
*               MONITOR III MEASUREMENTS.                             *
*                                                                     *
*  DESCRIPTION  THE DATASET PRODUCED BY RMF MONITOR III AS OF 3.5 IS  *
*               NOT IN ANY WAY NORMAL. IT IS A VSAM ESDS OF 32K       *
*               RECORDS. THE 1ST RECORD, AFTER SOME DESCRIPTIVE       *
*               DATA IS FILLED WITH AN ARRAY OF 28 BYTE POINTERS      *
*               DESCRIBING "SETS OF SAMPLES". A SET OF SAMPLES IS     *
*               WHAT MONITOR III CALCULATES EVERY "MINTIME" SECONDS.  *
*               THE SAMPLE DATA DATA FILLS RECORDS 2 THROUGH N.       *
*               THE CATCH IS THAT MONITOR III KEEPS TRACK OF WHERE    *
*               THINGS ARE IN THE DATASET BY USING OFFSET FIELDS      *
*               THAT ARE RELATIVE TO BYTE 0 OF RECORD 1. IN EFFECT    *
*               WHAT YOU HAVE IS A CHECKPOINTED COPY OF AN INCORE     *
*               ARRAY OF SOME KIND, NOTHING IN RECORDS 2 TO N IS IN   *
*               ANY NECESSARY ORDER. THEREFORE, IN ORDER TO PROCESS   *
*               THIS MESS YOU NEED THE WHOLE THING IN CORE.           *
*                                                                     *
*               ERB3POST PROCESSES BY READING THE ENTIRE DATASET      *
*               INTO MEMORY AND THEN LOOPING OVER ALL SET OF SAMPLES  *
*               POINTERS IN RECORD 1. FOR EACH OF THESE, TWO          *
*               SUBROUTINES ARE CALLED ONE TO PROCESS ASID'S AND ONE  *
*               TO PROCESS DEVICES. ASIDS AND DEVICES ARE EACH HELD   *
*               IN A TABLE POINTED TO BY THE SET OF SAMPLES HEADER    *
*               WHICH IS POINTED TO FROM RECORD 1. THE SUBROUTINES    *
*               PRINT A LINE OF THE REPORT IF THE DELAY PERCENTS SEEM *
*               HIGH AND WRITE A RECORD TO THE EXTRACT FILES.         *
*               THE DATA WRITTEN TO THE EXTRACT FILES IS ESSENTIALLY  *
*               WHAT YOU WOULD SEE WITH THE "DELAYJ" AND "DEVR"       *
*               COMMANDS UNDER RMFWDM.                                *
*                                                                     *
***********************************************************************
 EJECT ,
***********************************************************************
*                                                                     *
* ENVIRONMENT   MVS/XA 2.2.0                                          *
*               RMF 3.5                                               *
*               DFP/XA 2.3                                            *
*                                                                     *
* INPUT         A DATASET PRODUCED BY RMF MONITOR III.                *
*                                                                     *
* OUTPUT        A PRINTED REPORT OF JOBS AND DEVICES WITH HIGH DELAYS *
*               A SEQUENTIAL FILE, ONE RECORD PER ASID PER SET OF     *
*               SAMPLES.                                              *
*               A SEQUENTIAL FILE, ONE RECORD PER DEVICE PER SET OF   *
*               SAMPLES.                                              *
*                                                                     *
* JCL EXAMPLE                                                         *
*                                                                     *
*          //ERB3  EXEC PGM=ERB3POST,REGION=128M                      *
*          //STEPLIB  DD  DSN=JIMLANE.SYSTEMS.LOAD,                   *
*          //             DISP=SHR                                    *
*          //SYSUT1   DD  DSN=THP.RMFIII.MANDS,                       *
*          //             DISP=SHR                                    *
*          //SYSUDUMP DD  SYSOUT=*                                    *
*          //SYSPRINT DD  SYSOUT=*                                    *
*          //ASIDLIST DD  SYSOUT=*                                    *
*          //ASIDS    DD  DSN=JIMLANE.ASIDS,                          *
*          //             DISP=(,CATLG),                              *
*          //             UNIT=TEST,                                  *
*          //             SPACE=(TRK,(15,15),RLSE)                    *
*          //DEVICES  DD  DSN=JIMLANE.DEVICES,                        *
*          //             DISP=(,CATLG),                              *
*          //             UNIT=TEST,                                  *
*          //             SPACE=(TRK,(15,15),RLSE)                    *
*          //*                                                        *
*          //         EXEC SAS                                        *
*          //ASIDS    DD  DSN=JIMLANE.ASIDS,                          *
*          //             DISP=SHR                                    *
*          //DEVICES  DD  DSN=JIMLANE.DEVICES,                        *
*          //             DISP=SHR                                    *
*          //SYSIN    DD  DSN=JIMLANE.SYSTEMS.RMFIII(SASASID),        *
*          //             DISP=SHR                                    *
*          //                                                         *
*                                                                     *
*                                                                     *
*                                                                     *
***********************************************************************
         PRINT NOGEN
&NAME    SETC  'ERB3POST'
&VERSION SETC  '1.1.0'
         TITLE 'RMF MONITOR III POST PROCESSOR.'
         AMODE 31
         PUNCH ' MODE AMODE(31),RMODE(24) '
        $REGS ,
POST3   $PROLOG R11,R12
         L     R10,=V(DATASECT)
         USING DATASECT,R10
         L     R2,MEG128          LENGTH TO GETMAIN
         GETMAIN RU,LV=(2),                                            X
               LOC=(ANY,ANY)      GET STORAGE FOR MONITOR III DATA
         ST    R1,TABSTART        SAVE START ADDRESS.
         ST    R1,BXLE1           SAVE START ADDRESS.
         L     R3,RECLIII         GET RECORD LENGTH
         ST    R3,BXLE1+4         SAVE AS INCREMENT
         AR    R1,R2              DEVELOP END ADDRESS
         SR    R1,R3              WHICH IS THE START OF THE LAST SLOT
         ST    R1,TABEND          AND SAVE IT ALSO.
         ST    R1,BXLE1+8         SAVE ALSO AS STOP VALUE.
         GENCB BLK=ACB,                                                X
               AM=VSAM,                                                X
               DDNAME=SYSUT1,                                          X
               EXLST=EXLST1,                                           X
               MACRF=(KEY,AMODE31,SEQ)
         ST    R1,ACBAD           SAVE ADDRESS OF INPUT ACB.
         GENCB BLK=RPL,                                                X
               AM=VSAM,                                                X
               ACB=(*,ACBAD),                                          X
               ARG=(S,ARGFLD),                                         X
               AREALEN=32752,                                          X
               OPTCD=(KEY,SEQ)
         ST    R1,RPLAD           SAVE RPL ADDRESS
         L     R2,ACBAD           ADDR OF ACB TO BE OPENED
        $AMODE 24                 OPEN IN AMODE24
         OPEN  ((2))
        $AMODE 31                 BACK TO 31 BIT
         LM    R3,R5,BXLE1        LOOP OVER MONITOR DATA
         L     R2,RPLAD           PICK UP RPL ADDRESS
RDLOOP1  MODCB RPL=(2),AREA=(3)   SPECIFY BUFFER ADDRESS.
         GET   RPL=(2)            GET A RECORD
         LTR   R15,R15            GOTTEN OK?
         BZ    RDLOOP2            YES.
         ICM   R3,15,RPLFDBWD-IFGRPL(R2)
         ABEND 1,DUMP             CRASH AND BURN.
RDLOOP2  BXLE  R3,R4,RDLOOP1      READ ALL RECORDS
*        ABEND 99,DUMP            TABLE OVERFLOW
EODADIN  DS    0H
         L     R2,ACBAD           ADDR OF ACB TO BE CLOSED
        $AMODE 24                 CLOSE IN AMODE24
         CLOSE ((2))
        $AMODE 31                 BACK TO 31 BIT
         XPROPEN PWA              OPEN PRINT FILE
         XPRHEAD PWA,LIST=(HEADER1,HEADER2A)
         L     R3,TABSTART        START ADDR OF RMFIII DATA.
         USING DSIG3,R3
         LA    R1,DSIGTODC        GET TIME/DATE DATASET CREATED.
         BAL   R9,CLOCK           CONVERT IT.
         MVC   PRTLINE(19),=C' DATA SET CREATED: '
         MVC   PRTLINE+30(28),STCK MOVE IN CREATE DATE/TIME
         LA    R0,0               SKIP 0 LINES
         LA    R1,PRTLINE+1       START OF DATA TO PRINT.
         STM   R0,R1,PLINE0       SAVE PLIST
         BAL   R9,PRINT
         LA    R1,DSIGTODF        GET TIME/DATE 1ST SET OF SAMPLES
         BAL   R9,CLOCK           CONVERT IT.
         MVC   PRTLINE(27),=C' 1ST SET OF SAMPLES TAKEN: '
         MVC   PRTLINE+30(28),STCK MOVE IN CREATE DATE/TIME
         LM    R0,R1,PLINE0       PRINTER PARMS
         BAL   R9,PRINT
         LA    R1,DSIGTODL        GET TIME/DATE 1ST SET OF SAMPLES
         BAL   R9,CLOCK           CONVERT IT.
         MVC   PRTLINE(28),=C' LAST SET OF SAMPLES TAKEN: '
         MVC   PRTLINE+30(28),STCK MOVE IN CREATE DATE/TIME
         LM    R0,R1,PLINE0       PRINTER PARMS
         BAL   R9,PRINT
         LR    R5,R3              GET DSIG3 ADDRESS
         A     R5,DSIGFIPT        ADDRESS OF 1ST INDEX ENTRY
         USING DSIG3IX,R5
         L     R6,DSIGILEN        LENGTH OF AN INDEX ENTRY
         LR    R7,R3              GET DSIG3 ADDRESS
         A     R7,DSIGLIPT        ADDRESS OF LAST INDEX ENTRY
LOOPIX1  DS    0H
         CLC   DSIGTOD1,DSIGTOD2  COMPARE TIMESTAMPS
         BNL   LOOPIX1A           EQUAL INDICATES TIME GAP, I THINK
         L     R9,DSIGSBEG        OFFSET OF SET OF SAMPLES HEADER
         AR    R9,R3              PLUS ERBDSIG3
         USING SSHG3,R9
         CLC   SSHSMPNR,=F'30'    CHECK NUMBER OF SAMPLES
         BNH   LOOPIX1A           A LOW NUMBER IS A GAP, I THINK?
         DROP  R9
         LA    R1,DSIGTOD1        TIMESTAMP BEGINNING
         BAL   R9,CLOCK           CONVERT IT.
         L     R15,=V(LISTASID)   ASID TABLE ROUTINE
         BALR  R14,R15            CALL IT.
         L     R15,=V(LISTDEVT)   DEVICE TABLE ROUTINE
         BALR  R14,R15            CALL IT, TOO.
LOOPIX1A BXLE  R5,R6,LOOPIX1      PROCESS ALL INDEX ENTRIES.
         XPRCLOSE PWA             CLOSE PRINT FILE
         L     R1,TABSTART        ADDRESS TO FREEMAIN
         L     R0,MEG128          LENGTH TO FREEMAIN
         FREEMAIN RU,LV=(0),A=(1)
        $EPILOG ,
         TITLE ' - TOD CLOCK CONVERSION SUBROUTINE.'
CLOCK    DS    0H
         MVC   STCKSTCK,0(R1)     MOVE IN CLOCK VALUE TO BE CONVERTED.
        @STCK  CODE
         BR    R9                 GOBACK.
         TITLE ' - PRINT LINE SUBROUTINE.'
PRINT    DS    0H
         ST    R1,PRINT1
         XPRNTLIN  PWA,TEXT=(R1),LENGTH=132,SPB=((R0)),SPA=1
         L     R1,PRINT1
         MVI   0(R1),C' '
         MVC   1(132,R1),0(R1)
         BR    R9                 GOBACK.
PRINT1   DC    F'0'
         LTORG ,
         TITLE 'DATA AREAS.'
         DS    0F
MEG128   DC    AL4(128*1024*1024) 128 MEG TABLE SIZE
RECLIII  DC    AL4(32752)         RECORDING DATASET RECORD LENGTH.
EXLST1   EXLST EODAD=EODADIN      EOD ROUTINE FOR SYSUT1
         SPACE ,
         PRINT NOGEN
         COPY  LISTASID
         COPY  LISTDEVT
         COPY  TOTIME
         COPY  DATASECT
         PRINT OFF
         COPY  PRINT
         PRINT ON,GEN
         ERBASIG3 ,
         ERBDSIG3 ,
         ERBDVTG3 ,
         ERBENTG3 ,
         ERBGEIG3 ,
         ERBREDG3 ,
         ERBSHDG3 ,
         ERBSSHG3 ,
         ERBUWDG3 ,
         PRINT NOGEN
         CVT   DSECT=YES
         IFGRPL ,
         END   POST3
./       ADD   NAME=LISTASID
         TITLE ' - LIST ACTIVE ASIDS.'
* ON ENTRY R5 CONTAINS THE DATASET INDEX ENTRY ADDRESS.
* R3 CONTAINS ERBDSIG3
LISTASID $PROLOG R11,R12
         L     R10,=V(DATASECT)
         USING DATASECT,R10
         CLC   PWAOPN,=F'0'       HAVE I BEEN HERE BEFORE.
         BNE   LAOPEN             YES.
        $AMODE 24
         OPEN  (ASIDS,OUTPUT)     OPEN ASID DATA OUTPUT FILE.
        $AMODE 31
         CLC   PWDOPN,=F'0'       HAVE I HAD A DEVICE ALREADY?
         BNE   LAOPEN1            IF SO, HEADINGS ARE SET.
         XPRHEAD PWA,LIST=(PWALHD1,PWALHD2)
         XPREJECT PWA
LAOPEN1  DS    0H
         MVC   PWAOPN,=F'255'     SAY ITS OPEN.
LAOPEN   DS    0H
         L     R6,DSIGSBEG        OFFSET OF SET OF SAMPLES HEADER.
         AR    R6,R3              PLUS ERBDSIG3.
         USING SSHG3,R6
         MVC   ASRTIBEG,SSHTIBEG  SETUP BEGIN TIME STAMP.
         L     R7,SSHASIO         OFFSET OF ASID TABLE.
         AR    R7,R6              PLUS ERBSSHG3.
         DROP  R6
         USING ASIG3,R7
         L     R2,ASIENTMX        NUMBER OF ASID ENTRIES.
         LTR   R2,R2              ARE THERE ANY?
         BNP   LAEXIT             IF NOT, GET OUT.
         SR    R8,R8              CLEAR A REGISTER.
         ICM   R8,1,ASIENTLE      ENTRY LENGTH.
         SR    R6,R6              CLEAR A REGISTER.
         ICM   R6,1,ASIHDRLE      HEADER LENGTH
         AR    R7,R6              POINT TO 1ST ENTRY
         DROP  R7
         USING ASIG3ENT,R7
LALOOP1  DS    0H
         SR    R6,R6
         ICM   R6,3,ASISMPCT      GET NUMBER OF SAMPLES.
         LTR   R6,R6              ARE THERE ANY?
         BNP   LALOOP2            SKIP IT IF NOT.
         ICM   R4,15,ASICPUTA     GET CPU TIME.
         LTR   R4,R4              WAS THERE ANY?
         BNP   LALOOP2            SKIP IT IF NOT.
         SPACE ,
         MVC   ASRJOBNA,ASIJOBNA
         MVC   ASRNPG,ASINPG
         MVC   ASRDMN,ASIDMN
         MVC   ASRASINR,ASIASINR
         MVC   ASRCPUTA,ASICPUTA
         MVC   ASRDCTIA,ASIDCTIA
         MVC   ASRFIXA,ASIFIXA
         MVC   ASRTRCA,ASITRCA
         MVC   ASRFMCT,ASIFMCT
         MVC   ASRFMCTI,ASIFMCTI
         MVC   ASRSMPCT,ASISMPCT
         MVC   ASRSWAP,ASISWAP
         MVC   ASRIDLE,ASIIDLE
         MVC   ASRSWAR,ASISWAR
         MVC   ASRUKN,ASIUKN
         MVC   ASRSUSEN,ASISUSEN
         MVC   ASRSUCPR,ASISUCPR
         MVC   ASRSUCDV,ASISUCDV
         MVC   ASRSWAIN,ASISWAIN
         MVC   ASRSDCPR,ASISDCPR
         MVC   ASRSDCDV,ASISDCDV
         MVC   ASRSDCST,ASISDCST
         MVC   ASRSDCJE,ASISDCJE
         MVC   ASRSDCHS,ASISDCHS
         MVC   ASRSDCEN,ASISDCEN
        $AMODE 24
         PUT   ASIDS,ASREC        WRITE DETAILS OF ASID
        $AMODE 31
         SPACE ,
         MVC   LA1JOBNA,ASIJOBNA  MOVE IN JOB NAME
         ICM   R0,15,ASICPUTA     CPU TIME
         LA    R1,LA1CPUTM        ADDR OF RESULT FIELD.
         L     R15,=V(TOTIME)     ADDR OF CONVERT ROUTINE
         BALR  R14,R15            GET IT IN HH:MM:SS
         SR    R4,R4
         ICM   R4,3,ASISUSEN      GET NUMBER OF USING SAMPLES
         SR    R5,R5
         ICM   R5,3,ASISWAIN      GET NUMBER OF DELAY SAMPLES
         LTR   R5,R5              ANY DELAY?
         BZ    LALOOP2            NO PROBLEM. NO REPORT.
         AR    R5,R4              R5 = USING + DELAY SAMPLES.
         LTR   R5,R5              ARE THERE ANY?
         BNP   LALOOP2            IF NOT, WHY BOTHER?
         MH    R4,=H'100'         TIMES 100
         SRDA  R4,32              SET UP TO DIVIDE
         DR    R4,R6              DIVIDE BY TOTAL SAMPLES
         CVD   R5,DOUBLE          R5 IS USING PERCENT.
         ST    R5,LAUSING         SAVE FOR LATER ANALYSIS
         EDIT  LA1USING,DWK2,ZZ9  FORMAT USING PERCENT.
         SR    R4,R4
         ICM   R4,3,ASISWAIN      GET NUMBER OF DELAY SAMPLES
         MH    R4,=H'100'         TIMES 100
         SRDA  R4,32              SET UP TO DIVIDE
         DR    R4,R6              DIVIDE BY TOTAL SAMPLES
         CVD   R5,DOUBLE          R5 IS DELAY PERCENT.
         ST    R5,LADELAY         SAVE FOR LATER.
         EDIT  LA1DELAY,DWK2,ZZ9  FORMAT DELAY PERCENT.
         CVD   R6,DOUBLE          CONVERT TOTAL SAMPLES
         EDIT  LA1SMPLS,DWK3,ZZZZZ9
         TM    ASIFLAG1,X'80'     IS IT AN STC?
         BNO   *+10               NO
         MVC   LA1TYPE,=C'STC'    CALL AN STC AN STC.
         TM    ASIFLAG1,X'40'     IS IT A JOB?
         BNO   *+10               NO
         MVC   LA1TYPE,=C'JOB'    CALL A JOB A JOB.
         TM    ASIFLAG1,X'20'     IS IT A TSU?
         BNO   *+10               NO
         MVC   LA1TYPE,=C'TSU'    CALL A TSU A TSU.
         MVC   LA1DOW,STCKDOW     DAY OF THE WEEK
         MVC   LA1DATE,STCKDATE   DATE
         MVC   LA1TIME,STCKTIME   TIME
         BAL   R9,LASELECT        SELECT ONLY THE INTERSTING ONES.
         LTR   R1,R1              DO WE WANT THIS ONE?
         BNZ   LALOOP2            I GUESS NOT.
         XPRNTLIN  PWA,TEXT=LA1LINE,LENGTH=132,SPB=0,SPA=1
LALOOP2  AR    R7,R8              POINT TO NEXT ENTRY.
         BCT   R2,LALOOP1         LOOP OVER ALL ASIDS.
LAEXIT   DS    0H
         $EPILOG ,
         TITLE ' - SELECT ONLY INTERESTING ASIDS.'
LASELECT DS    0H
         LA    R1,1               REJECT BY DEFAULT.
         C     R6,=F'50'          DECENT NUMBER OF SAMPLES?
         BLR   R9                 IF NOT, THE REST DOESN'T MEAN MUCH
         TM    ASIFLAG1,X'20'     IS IT A TSU?
         BO    LASELTSU           GOTO TSU LOGIC
         TM    ASIFLAG1,X'40'     IS IT A JOB?
         BO    LASELJOB           GOTO JOB LOGIC
         CLC   LADELAY,=F'10'     DELAY PCT > 10 ?
         BLR   R9                 NO.
         SR    R1,R1              THAT'S A KEEPER.
         BR    R9                 GOBACK.
LASELTSU DS    0H
         CLC   LADELAY,=F'50'     DELAY PCT > 50 ?
         BLR   R9                 NO.
         SR    R1,R1              THAT'S A KEEPER.
         BR    R9                 GOBACK.
LASELJOB DS    0H
         CLC   LADELAY,=F'25'     DELAY PCT > 25 ?
         BLR   R9                 NO.
         SR    R1,R1              THAT'S A KEEPER.
         BR    R9                 GOBACK.
         LTORG ,
         TITLE 'DATA AREAS.'
LAUSING  DC    F'0'               USING PERCENT
LADELAY  DC    F'0'               DELAY PERCENT
         SPACE ,
ASIDS    DCB   DDNAME=ASIDS,DSORG=PS,MACRF=(PM),LRECL=75,BLKSIZE=9375, X
               RECFM=FB
ASREC    DS    0H
ASRJOBNA DS    CL8           JOBNAME FOR THIS ASID
ASRTIBEG DS    XL8           BEGIN TIME STAMP.
ASRNPG   DS    XL2           CONTROL PERFORMANCE GROUP
ASRDMN   DS    XL1           DOMAIN
ASRASINR DS    XL2           ASID NUMBER
ASRCPUTA DS    XL4           TOTAL TCB+SRB TIME (IN MILLISECONDS)
ASRDCTIA DS    XL4           TOTAL CHANNEL CONNECT TIME
ASRFIXA  DS    XL4           NUMBER OF REAL FIXED FRAMES
ASRTRCA  DS    XL4           TOTAL NUMBER OF TRANSACTIONS
ASRFMCT  DS    XL4           TOTAL FRAMES FOR SWAPPED-IN USERS
ASRFMCTI DS    XL4           TOTAL FRAMES FOR IDLE USERS
ASRSMPCT DS    XL2           NUMBER OF VALID SAMPLES
ASRSWAP  DS    XL2           NUMBER OF SAMPLES WHEN JOB WAS PHYSICALLY
*                            SWAPPED OUT.
ASRIDLE  DS    XL2           NUMBER OF SAMPLES WHEN JOB WAS IDLE
ASRSWAR  DS    XL2           NUMBER OF SAMPLES WHEN JOB WAS SWAPPED
*                            OUT READY.
ASRUKN   DS    XL2           NUMBER OF SAMPLES WHEN JOB STATUS UNKNOWN
ASRSUSEN DS    XL2           NUMBER OF SINGLE STATE USING SAMPLES
ASRSUCPR DS    XL2           # OF SINGLE STATE SAMPLES USING PROCESSOR
ASRSUCDV DS    XL2           # OF SINGLE STATE SAMPLES USING DEVICE
ASRSWAIN DS    XL2           # OF SINGLE STATE SAMPLES DELAYED
ASRSDCPR DS    XL2           # OF SINGLE STATE SAMPLES DELAYED PROC
ASRSDCDV DS    XL2           # OF SINGLE STATE SAMPLES DELAYED DEV
ASRSDCST DS    XL2           # OF SINGLE STATE SAMPLES DELAYED STOR
ASRSDCJE DS    XL2           # OF SINGLE STATE SAMPLES DELAYED JES
ASRSDCHS DS    XL2           # OF SINGLE STATE SAMPLES DELAYED HSM
ASRSDCEN DS    XL2           # OF SINGLE STATE SAMPLES DELAYED ENQ
ASRLEN   EQU   *-ASREC
./       ADD   NAME=LISTDEVT
         TITLE ' - LIST ACTIVE DEVICES.'
* ON ENTRY R5 CONTAINS THE DATASET INDEX ENTRY ADDRESS.
* R3 CONTAINS ERBDSIG3
LISTDEVT $PROLOG R11,R12
         L     R10,=V(DATASECT)
         USING DATASECT,R10
         CLC   PWDOPN,=F'0'       HAVE I BEEN HERE BEFORE.
         BNE   LDOPEN             YES.
        $AMODE 24
         OPEN  (DEVICES,OUTPUT)   OPEN DEVICE DATA OUTPUT FILE.
        $AMODE 31
         CLC   PWAOPN,=F'0'       HAVE I HAD AN ASID ALREADY.
         BNE   LDOPEN1            YES, HEADINGS SET.
         XPRHEAD PWA,LIST=(PWALHD1,PWALHD2)
         XPREJECT PWA
LDOPEN1  DS    0H
         MVC   PWDOPN,=F'255'     SAY ITS OPEN.
LDOPEN   DS    0H
         L     R2,ASDVTBAD        ADDR OF ASID/DEVICE TABLE.
         LTR   R2,R2              IS IT GOTTEN?
         BNZ   LDTBOK             YES.
         L     R2,ASDVTBLN        LENGTH TO GETMAIN
         GETMAIN RU,LV=(2),                                            X
               LOC=(ANY,ANY)      GET STORAGE FOR ASID/DEVICE TABLE
         ST    R1,ASDVTBAD        SAVE START ADDRESS.
LDTBOK   DS    0H
         L     R6,DSIGSBEG        OFFSET OF SET OF SAMPLES HEADER.
         AR    R6,R3              PLUS ERBDSIG3.
         USING SSHG3,R6
         ST    R6,CURRSSH         SAVE THIS FOR LATER.
         MVC   DVRTIBEG,SSHTIBEG  MOVE IN TIMESTAMP.
         XC    LDSMPLES,LDSMPLES  ZERO SAMPLE COUNT
         XC    LDUWFLAG,LDUWFLAG  RESET USE/WAIT FLAG
         L     R1,SSHSHDLO        OFFSET OF LAST SAMPLE HEADER.
         AR    R1,R6              ADDR OF LAST SAMPLE HEADER.
         ST    R1,LASTSAMP        SAVE AS STOP CRITERION
         A     R6,SSHSHDFO        PLUS OFFSET OF 1ST SAMPLE HEADER
         DROP  R6
         USING SHDG3,R6
LDSMLP1  DS    0H
         L     R3,SHDREDOF        OFFSET OF 1ST RED RECORD.
         AR    R3,R6              PLUS A(SHDG3) TO GET A(RED)
         LH    R4,SHDREDNR        COUNT OF RED'S. (COULD BE ZERO).
         LTR   R4,R4              ARE THERE ANY?
         BNP   LDSMLP1C           NO.
         LH    R4,SHDREDLE        PICK LENGTH OF AN RED RECORD.
         LR    R5,R4
         MH    R5,SHDREDNR        LENGTH TIMES NUMBER OF RED'S
         AR    R5,R3              PLUS ADDR OF 1ST RED.
         USING REDG3,R3
LDSMLP1A DS    0H
         CLI   REDREDID,X'02'     IS THIS THE ONE FOR DEV?
         BE    LDSMLP1B           YES
         BXLE  R3,R4,LDSMLP1A     CHECK ALL RED RECORDS.
         B     LDSMLP1C           NO DEV. HOW ODD!
LDSMLP1B DS    0H
         LH    R4,REDUWDLE        LENGTH OF A USE/WAIT RECORD.
         LH    R5,REDUWDNR        NUMBER OF USE/WAIT RECORDS.
         MH    R5,REDUWDLE        TIMES LENGTH OF EACH
         A     R5,REDFUWDO        PLUS OFFSET OF 1ST ONE.
         AR    R5,R3              PLUS A(REDG3)
         SR    R5,R4              MINUS 1 FOR START OF LAST ENTRY.
         A     R3,REDFUWDO        ADDR OF 1ST USE/WAIT RECORD.
         DROP  R3
         USING UWDG3,R3
LDSMLP2A DS    0H
         SR    R1,R1
         ICM   R1,3,UWDASID       PICK UP ASID INDEX.
         SR    R14,R14
         ICM   R14,3,UWDDEVNR     PICK UP DEVICE INDEX.
         SLL   R14,12             TIMES 4096 BYTES PER DEVICE
         SLL   R1,2               TIMES 4 BYTES PER ASID PER DEVICE
         AR    R1,R14             SUBSCRIPT W/IN TABLE.
         A     R1,ASDVTBAD        PLUS START ADDR.
         TM    UWDUWRID,X'80'     IS THIS A WAIT RECORD?
         BZ    LDSMLP2C           NO, TRY FOR A USE.
         LA    R1,2(0,R1)         SKIP OVER USE COUNT HALFWORD.
         OI    LDUWFLAG,X'80'     FLAG WAIT RECORDS FOUND.
         B     LDSMLP2D           PROCESS WAIT RECORD.
LDSMLP2C TM    UWDUWRID,X'40'     IS THIS A USE RECORD?
         BZ    LDSMLP2B           NO, KEEP GOING.
         OI    LDUWFLAG,X'40'     FLAG USE RECORDS FOUND.
LDSMLP2D LH    R9,0(0,R1)         PICK UP USE OR WAIT COUNT.
         LA    R9,1(0,R9)         ADD ONE.
         STH   R9,0(0,R1)         AND SAVE IT.
LDSMLP2B BXLE  R3,R4,LDSMLP2A     LOOP OVER ALL DEV USE/WAIT RECORDS
LDSMLP1C DS    0H
         CLC   SHDNEXTO,=F'0'     WAS THAT THE LAST SAMPLE HEADER?
         BE    LDSMLP2            YES.
         L     R1,LDSMPLES        PICK UP SAMPLE COUNT.
         LA    R1,1(0,R1)         INCREMENT IT.
         ST    R1,LDSMPLES        AND SAVE IT.
         A     R6,SHDNEXTO        INCREMENT TO NEXT HEADER.
         B     LDSMLP1            AND GO TO IT.
LDSMLP2  DS    0H
         L     R6,CURRSSH         PICK UP CURRENT SSH.
         USING SSHG3,R6
         L     R7,SSHASIO         OFFSET OF ASID TABLE.
         AR    R7,R6              PLUS ERBSSHG3.
         ST    R7,CURRASIG        SAVE ASID TABLE ADDR FOR LATER.
         L     R7,SSHDVTO         OFFSET OF DEVICE TABLE.
         AR    R7,R6              PLUS ERBSSHG3.
         DROP  R6
         USING DVTG3,R7
         ST    R7,CURRDVTG        SAVE DEVICE TABLE ADDRESS.
         L     R2,DVTENTMX        NUMBER OF DEVICE ENTRIES.
         LTR   R2,R2              ARE THERE ANY?
         BNP   LDEXIT             IF NOT, GET OUT.
         SR    R8,R8              CLEAR A REGISTER.
         ICM   R8,1,DVTENTLE      ENTRY LENGTH.
         SR    R6,R6              CLEAR A REGISTER.
         ICM   R6,1,DVTHDRLE      HEADER LENGTH
         AR    R7,R6              POINT TO 1ST ENTRY
         DROP  R7
         USING DVTG3ENT,R7
LDLOOP1  DS    0H
         SPACE ,
         MVC   DVRVOLI,DVTVOLI
         MVC   DVRMEXNR,DVTMEXNR
         MVC   DVRDISIF,DVTDISIF
         MVC   DVRPETIF,DVTPETIF
         MVC   DVRCOTIF,DVTCOTIF
         MVC   DVRDVBIF,DVTDVBIF
         MVC   DVRCUBIF,DVTCUBIF
         MVC   DVRDISIL,DVTDISIL
         MVC   DVRPETIL,DVTPETIL
         MVC   DVRCOTIL,DVTCOTIL
         MVC   DVRDVBIL,DVTDVBIL
         MVC   DVRCUBIL,DVTCUBIL
         MVC   DVRTYP,DVTTYP
         MVC   DVRHUJBN,=CL8'--NONE--'
         MVC   DVRHWJBN,=CL8'--NONE--'
         XC    DVRHUCNT,DVRHUCNT
         XC    DVRHWCNT,DVRHWCNT
         XC    DVRSMPCT,DVRSMPCT
         LH    R3,DVTENIDX        INDEX OF CURRENT DEVICE
         SLL   R3,12              4096 BYTES PER DEVICE.
         A     R3,ASDVTBAD        PLUS START OF ASID/DEVICE TABLE
         LA    R4,4               4 BYTE ENTRIES
         LR    R5,R3
         AH    R5,=H'4096'        LAST ASID ENTRY THIS DEVICE.
         SR    R1,R1              CURRENT HIGH USE COUNT
         SR    R14,R14            CURRENT HIGH WAIT COUNT
         SR    R6,R6              INDEX FOR HIGH USE COUNT
         SR    R9,R9              INDEX FOR HIGH WAIT COUNT
LDSMLP3  DS    0H
         CH    R1,0(R3)           IS THIS NEW HIGHEST USER?
         BNL   LDSMLP3A           NO.
         LH    R1,0(R3)           PICK UP NEW HIGH COUNT.
         LR    R6,R3              PICK UP INDEX THEREOF
LDSMLP3A CH    R14,2(R3)          IS THIS NEW HIGHEST WAITER?
         BNL   LDSMLP3B           NO
         LH    R14,2(R3)          PICK NEW HIGH WAIT COUNT
         LR    R9,R3              PICK ITS INDEX.
LDSMLP3B BXLE  R3,R4,LDSMLP3
         XC    LDUWFLAG,LDUWFLAG  RESET FLAG
         LTR   R6,R6              WAS THERE ANY USE?
         BNP   *+8                NO.
         OI    LDUWFLAG,X'40'     YES.
         LTR   R9,R9              WAS THERE ANY DELAY?
         BNP   *+8                NO.
         OI    LDUWFLAG,X'80'     YES.
         LR    R0,R14
         LH    R3,DVTENIDX        INDEX OF CURRENT DEVICE
         SLL   R3,12              4096 BYTES PER DEVICE.
         A     R3,ASDVTBAD        PLUS START OF ASID/DEVICE TABLE
         SR    R6,R3              ADDR TO OFFSET
         SRL   R6,2               DIVIDE BY 4 TO GET ASID INDEX
         SR    R9,R3              ADDR TO OFFSET
         SRL   R9,2               DIVIDE BY 4 TO GET ASID INDEX
         L     R3,CURRASIG        PICK UP ADDR OF ASID TABLE.
         USING ASIG3,R3
         SR    R14,R14
         IC    R14,ASIENTLE       PICK UP ASID ENTRY LENGTH
         ST    R14,SAVENTLE       SAVE FOR LATER.
         LA    R3,16(0,R3)        SKIP OVER HEADER.
         DROP  R3
         SRDA  R14,32             SET UP TO DIVIDE
         MR    R14,R6             R15 CONTAINS OFFSET OF HIGHEST USER
         AR    R15,R3             PLUS ADDR OF 1ST ENTRY
         USING ASIG3ENT,R15
         TM    LDUWFLAG,X'40'     WERE THERE USE RECORDS?
         BZ    LDSMLP3C           IF NOT, NO HIGHEST USER.
         MVC   DVRHUJBN,ASIJOBNA  MOVE HIGHEST USER'S NAME
         STCM  R1,15,DVRHUCNT     STORE HIGHEST USE COUNT
LDSMLP3C DS    0H
         L     R14,SAVENTLE
         SRDA  R14,32             SET UP TO DIVIDE
         MR    R14,R9             R15 CONTAINS OFFSET OF HIGHEST WAITER
         AR    R15,R3             PLUS ADDR OF 1ST ENTRY
         TM    LDUWFLAG,X'80'     WERE THERE WAIT RECORDS?
         BZ    LDSMLP3D           IF NOT, NO HIGHEST WAITER
         MVC   DVRHWJBN,ASIJOBNA  MOVE HIGHEST WAITER'S NAME
         LR    R14,R0
         STCM  R14,15,DVRHWCNT    STORE HIGHEST WAIT COUNT
LDSMLP3D DS    0H
         DROP  R15
         MVC   DVRSMPCT,LDSMPLES  SAMPLE COUNT
LDSMLP4  DS    0H
        $AMODE 24
         PUT   DEVICES,DVREC      WRITE DETAILS OF DEVICE
        $AMODE 31
         SPACE ,
         MVC   LD1VOLI,DVTVOLI    MOVE IN VOLSER
         MVC   LD1TYPE,=C'DEV'    CALL IT A DEVICE.
         MVC   LD1HUJBN,DVRHUJBN  MOST USING JOB.
         MVC   LD1HWJBN,DVRHWJBN  MOST DELAYED JOB.
         MVC   LD1DOW,STCKDOW     DAY OF THE WEEK
         MVC   LD1DATE,STCKDATE   DATE
         MVC   LD1TIME,STCKTIME   TIME
         ICM   R3,15,DVRSMPCT     TOTAL SAMPLES
         LTR   R3,R3              ANY SAMPLES?
         BNP   LDSMLP4A           NO 0C9'S PLEASE.
         ICM   R4,15,DVRHUCNT     NUMBER OF USING SAMPLES
         MH    R4,=H'100'         TIMES 100
         SRDA  R4,32              SET UP TO DIVIDE
         DR    R4,R3              R5 CONTAINS USING PERCENT
         ST    R5,LDUSING         SAVE FOR LATER ANALYSIS
         CVD   R5,DOUBLE
         EDIT  LD1USING,DWK2,ZZ9  FORMAT USING PERCENT
         ICM   R4,15,DVRHWCNT     NUMBER OF DELAY SAMPLES
         MH    R4,=H'100'         TIMES 100
         SRDA  R4,32              SET UP TO DIVIDE
         DR    R4,R3              R5 CONTAINS DELAY PERCENT
         ST    R5,LDDELAY         SAVE FOR LATER ANALYSIS
         CVD   R5,DOUBLE
         EDIT  LD1DELAY,DWK2,ZZ9  FORMAT DELAY PERCENT
LDSMLP4A DS    0H
         L     R5,LDSMPLES        SAMPLE COUNT
         CVD   R5,DOUBLE
         EDIT  LD1SMPLS,DWK3,ZZZZ9
         BAL   R9,LDSELECT        SELECT ONLY THE INTERSTING ONES.
         LTR   R1,R1              DO WE WANT THIS ONE?
         BNZ   LDLOOP2            I GUESS NOT.
         XPRNTLIN  PWA,TEXT=LD1LINE,LENGTH=132,SPB=0,SPA=1
LDLOOP2  AR    R7,R8              POINT TO NEXT ENTRY.
         BCT   R2,LDLOOP1         LOOP OVER ALL DEVICES.
LDEXIT   DS    0H
         L     R4,ASDVTBAD
         L     R5,ASDVTBLN
         L     R14,ASDVTBAD
         SR    R15,R15
         MVCL  R4,R14
         $EPILOG ,
         TITLE ' - SELECT ONLY INTERESTING DEVICES.'
LDSELECT DS    0H
         LA    R1,1               REJECT BY DEFAULT.
         CLI   DVTFLAG1,X'00'     ANY DEVICE TYPE FLAGS SET?
         BER   R9                 IF NONE, MUST BE NO GOOD.
         CLI   DVTVOLI,C'A'       VOLSER OK?
         BLR   R9                 REJECT WEIRD VOLSERS.
         CLI   DVTVOLI,C'9'       COULD BE STRANGE EITHER WAY!
         BHR   R9                 SKIP THEM TOO.
         L     R5,DVTCOTIL        ENDING CONNECT TIME.
         SL    R5,DVTCOTIF        MINUS START CONNECT TIME.
         LTR   R5,R5              IS ANYTHING HAPPENING?
         BNPR  R9                 REJECT THE SLEEPERS.
* FIELDS REFERENCED BELOW ARE 3090 ONLY.
*        L     R5,DVTDVBIL        END DEV BUSY DELAY
*        AL    R5,DVTCUBIL        PLUS END CUB DELAY
*        SL    R5,DVTDVBIF        MINUS START DEV BUSY DELAY
*        SL    R5,DVTCUBIF        MINUS START CUB DELAY.
*        LTR   R5,R5              WAS THERE ANY DELAY?
*        BNPR  R9                 NO DELAY, NO PROBLEM, NO LIST.
         CLC   LDDELAY,=F'10'     WORST DELAY LT 10%
         BLR   R9                 YES. SO WHO CARES
         SR    R1,R1              SELECT IT.
         BR    R9                 GOBACK.
         LTORG ,
         TITLE 'DATA AREAS.'
LDUSING  DC    F'0'               USING PERCENT
LDDELAY  DC    F'0'               DELAY PERCENT
         SPACE ,
DEVICES  DCB   DDNAME=DEVICES,DSORG=PS,MACRF=(PM),LRECL=88,            X X
               BLKSIZE=9416,RECFM=FB
LDSMPLES DC    F'0'               COUNT OF SAMPLES THIS SET.
LDUWFLAG DC    X'00'              FLAG FOR USE/WAIT SAMPLES THIS DEVICE
SAVENTLE DC    F'0'               SAVE AREA. ASID ENTRY LENGTH
ASDVTBAD DC    AL4(0)             ADDR OF TABLE OF DEVICES/ASIDS.
ASDVTBLN DC    AL4(1024*256*4)    LENGTH OF ABOVE TABLE.
DVREC    DS    0H
DVRVOLI  DC    CL6'  '       VOLSER FOR THIS DEVICE
DVRMEXNR DC    XL2'00'       NUMBER OF EXPOSURE (INCLUDING BASE)
DVRDISIF DC    XL4'00'       DEVICE DISC TIME AT BEGIN OF THE MINTIME
DVRPETIF DC    XL4'00'       DEVICE PEND TIME AT BEGIN OF THE MINTIME
DVRCOTIF DC    XL4'00'       DEVICE CONN TIME AT BEGIN OF THE MINTIME
DVRDVBIF DC    XL4'00'       DEVICE BUSY DELAY TIME AT BEGIN OF THE
DVRCUBIF DC    XL4'00'       CONTROL UNIT BUSY DELAY AT BEGIN OF THE
DVRDISIL DC    XL4'00'       DEVICE DISC TIME AT END OF THE MINTIME
DVRPETIL DC    XL4'00'       DEVICE PEND TIME AT END OF THE MINTIME
DVRCOTIL DC    XL4'00'       DEVICE CONN TIME AT END OF THE MINTIME
DVRDVBIL DC    XL4'00'       DEVICE BUSY DELAY TIME AT END OF THE
DVRCUBIL DC    XL4'00'       CONTROL UNIT BUSY DELAY AT END OF THE
DVRTYP   DC    XL4'00'       DEVICE TYPE FROM UCBTYP MACRO
DVRSMPCT DC    XL4'00'            SAMPLE COUNT.
DVRHUJBN DC    CL8' '             JOBNAME OF HIGHEST USER
DVRHUCNT DC    XL4'00'            USE COUNT OF HIGHEST USER
DVRHWJBN DC    CL8' '             JOBNAME OF HIGHEST WAITER
DVRHWCNT DC    XL4'00'            WAIT COUNT OF HIGHEST WAITER
DVRTIBEG DC    XL8'00'            TIME STAMP.
DVRECL   EQU   *-DVREC
./       ADD   NAME=PRINT
         TITLE 'XPRNTSUB - GENERAL PRINTING SUBROUTINE'
         SPACE
* FUNCTION/OPERATION:  THIS IS A GENERAL PRINTING SUBROUTINE TO MANAGE
*        THE DETAILS OF PAGINATION, HEADINGS, AND OUTPUT COMPRESSION
*        FOR PRINTED OUTPUT.  IT IS INVOKED FROM A PROBLEM PROGRAM VIA
*        THE MACRO 'XPRNT', WHICH HAS THE FOLLOWING CALL MODES:
*           OPEN - INITIALIZES PAGE SIZE PARAMETERS AND MAXIMUM NUMBER
*              OF OUTPUT LINES, RESETS PAGE NUMBER, CLEARS HEADING
*              LINES AND INSERTS CURRENT DATE AND TIME, INSERTS DDNAME
*              IN DCB, AND OPENS THE DATA SET.
*           MODIFY - ALTERS ANY OR ALL OF THE PARAMETERS LISTED UNDER
*              'OPEN' EXCEPT THE DDNAME.
*           SETHEAD - SUPPLIES TEXT FOR ONE OR MORE LINES TO BE USED
*              PAGE HEADINGS.
*           PRINT - DELIVERS ONE OR MORE LINES TO BE PRINTED.
*           SPACE - MOVES THE PAGE VERTICALLY A GIVEN NUMBER OF LINES.
*           EJECT - CONDITIONAL OR UNCONDITIONAL SKIP TO HEAD-OF-FORM.
*           CLOSE - CLOSES THE DATA SET.
         SPACE
* ENTRY POINTS:  EACH MODE HAS A SEPARATE ENTRY AT A FIXED OFFSET FROM
*        THE BASE ADDRESS.  ENTRYS ARE EFFECTED BY A  BAL  14,D(15)
*        (WHERE D IS A DISPLACEMENT WHICH SELECTS THE DESIRED MODE) AND
*        ASSUMES THAT REGISTER 13 ADDRESSES A STANDARD 18-WORD SAVE
*        AREA.
         SPACE
* INPUT:  ON ENTRY, REG 0 POINTS TO A WORK AREA FOR THE DATA SET, WHICH
*        IS DESCRIBED IN THIS CODING BY THE DUMMY SECTION 'WORKAREA'.
*        REG 1 POINTS TO A PARAMETER LIST OF A FORM APPROPRIATE TO THE
*        CALL MODE.  THESE LISTS ARE EITHER DESCRIBED BY DUMMY SECTIONS
*        OR ARE STANDARD VARIABLE-LENGTH ADDRESS LISTS.
         SPACE
         SPACE
* OUTPUT:  PRINT LINES AND SPACE CONTROL RECORDS ARE DELIVERED VIA QSAM
*        TO A SEQUENTIAL DATA SET.  EACH LINE IS REDUCED TO ITS MIN-
*        IMUM LENGTH BY TRUNCATING TRAILING BLANKS.
         SPACE
* DATA SETS:  THE OUTPUT DATA SET IS SEQUENTIAL, ARRANGED FOR BLOCKED
*        FORMAT V RECORDS USING MACHINE CONTROL CHARACTERS APPROPRIATE
*        TO 1403 OR 1404 PRINTERS.  THE DDNAME IS SUPPLIED BY THE
*        'OPEN' CALL; THE STANDARD VALUE IS 'SYSPRINT'.
         SPACE
* EXTERNAL ROUTINES:  CALLS 'XDATEDIT' TO FORMAT THE DATE FOR THE
*        PAGE HEADING LINE.
         SPACE
* EXITS - NORMAL:  RETURNS VIA REG 14 WITH RETURN CODE 0 IN REG 15.
*        THE CURRENT PAGE NUMBER (IN BINARY) IS IN REG 0 AND THE BINARY
*        NUMBER OF LINES REMAINING ON THE CURRENT PAGE IS IN REG 1.
*        IF AN OPEN CALL CANNOT OPEN THE DCB, THE RETURN CODE IS 4.
         SPACE
* EXITS - ERROR:  ERRONEOUS CALLS RESULT IN AN 'ABEND' WITH ONE OF THE
*        FOLLOWING COMPLETION CODES:
*           4000 - ROUTINE WAS ILLEGALLY ENTERED AT ITS BASE ADDRESS.
*           4002 - A CALL MODE OTHER THAN 'OPEN' WAS DIRECTED TO A DATA
*              SET WHICH WAS NOT OPEN.
*           4003 - 'OPEN' OR 'MODIFY' SPECIFIED TOO LARGE A PAGE WIDTH.
*           4004 - 'OPEN' OR 'MODIFY' SPECIFIED TOO LONG A PAGE.
*           4005 - 'PRINT' OR 'SETHEAD' SPECIFIED A LINE WHOSE TEXT
*              LENGTH PLUS OFFSET EXCEEDED THE PAGE WIDTH.
*           4006 - THE MAXIMUM NUMBER OF OUTPUT LINES WAS EXCEEDED.
*           4007 - SYNCHRONOUS I/O ERROR.
         SPACE
* TABLES/WORK AREAS:  THE CALL PARAMETER LISTS, WORK AREA, AND PRINT
*        LINE DESCRIPTOR BLOCK ARE ALL DESCRIBED BY DUMMY SECTIONS
*        AT THE END OF THE PROGRAM.
         SPACE
* ATTRIBUTES:  REENTRANT, READ-ONLY.  WILL HANDLE ANY NUMBER OF DATA
*        SETS SIMULTANEOUSLY, USING A SEPARATE WORK AREA FOR EACH.
         SPACE
* OPERATING ENVIRONMENT:  RUNS UNDER OPERATING SYSTEM/360, USING
*        QSAM DATA MANAGEMENT WITH LOCATE-MODE PUT MACROS AND SIMPLE
*        BUFFERING.  ASSUMES OPTION 6A OR 6B FOR TIME OF DAY.
         SPACE
* NOTES:  NONE.
         EJECT
XPRNTSUB CSECT
         SPACE 2
* REGISTER ASSIGNMENTS:
         SPACE 2
* N.B.  REGISTER GROUPS 'RWA,RWB,RWC,RWD' AND 'RLPEXIT,RPARM' MUST BE
* KEPT IN ORDER FOR LM AND STM ORDERS.
         SPACE
RWA      EQU   2                   GENERAL WORK REG
RWB      EQU   3                   GENERAL WORK REG
RWC      EQU   4                   GENERAL WORK REG
RWD      EQU   5                   GENERAL WORK REG
RSPACE   EQU   6                   NUMBER OF LINES TO SPACE
RBAL     EQU   7                   NUMBER OF LINES LEFT ON PAGE
RLPEXIT  EQU   8                   EXIT FROM LIST PROCESSING ROUTINE
RPARM    EQU   9                   CALL PARAMETER LIST ADDR
RPLD     EQU   10                  PLD BLOCK BASE
RWKAREA  EQU   11                  BASE REGISTER FOR WORK AREA
RBASE    EQU   12                  BASE REGISTER FOR CODING
RRET     EQU   14                  STANDARD RETURN ADDR
         SPACE
* MASKS FOR CONTROL BYTE "SWITCHES":
         SPACE
HOFBIT   EQU   X'80'               PAGE IS AT PHYSICAL HEAD-OF-FORM
NOSKBIT  EQU   X'40'               DISALLOW EJECT DURING HEAD PRINTING
TXT1BIT  EQU   X'20'               ON FOR FIRST TEXT LINE ON PAGE
HD1BIT   EQU   X'10'               ON FOR FIRST HEAD LINE WITH PAGE
*                                  NO, ETC
SP0BIT   EQU   X'08'               LAST LINE SPACED 0
         SPACE 2
EJFORCE  EQU   255                 SPACING QUANTITY TO FORCE PAGE EJECT
OPENBIT  EQU   X'10'               TO TEST 'DCBOFLGS' FOR SUCCESSFUL
*                                  OPEN
MAXLNGTH EQU   254                 MAXIMUM PAGE LENGTH
MAXWIDTH EQU   132                 MAXIMUM PAGE WIDTH
DEFBLKSZ EQU   1692                DEFAULT DCB BLOCK SIZE
         EJECT
**********************
* ENTRY AND PROLOGUE *
**********************
         SPACE
* ENTER FROM THE CALLING SEQUENCE VIA THE INSTRUCTION "BAL 14,X(0,15)".
* REGISTER 15 IS SET TO THE BASE OF THE ROUTINE AND THE DISPLACEMENT
* "X" SELECTS THE ENTRY POINT.  EACH ENTRY SAVES REGISTERS, LOADS THE
* ADDRESS OF THE APPROPRIATE SUBROUTINE, AND GOES TO A COMMON
* PROLOGUE.  NOTE THAT AN ATTEMPT TO ENTER AT THE BASE RESULTS IN
* AN ABEND.
         SPACE 2
BASEADDR B     20(0,R15)           BRANCH AROUND MODULE IDENTIFIER
         DC    AL1(15)             LENGTH OF IDENTIFIER
         DC    CL15'XPRNTSUB-028214'
         STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS
         SR    R1,R1               SET ABEND COMPLETION CODE
         LR    RBASE,R15           SET BASE REG FOR ABEND ROUTINE
         USING BASEADDR,RBASE
         B     ABEND
         DROP  RBASE
         SPACE 2
* ENTRY POINTS FOR VARIOUS FUNCTIONS, AT 12-BYTE INTERVALS BEGINNING
* AT BASEADDR+32.  EACH LOADS "RWA" WITH THE ADDRESS OF THE SUBROUTINE
* TO GO TO AFTER EXECUTING "PROLOGUE".
         SPACE
         ORG   XPRNTSUB+32
         USING BASEADDR,R15
         SPACE
PRENTRY  STM   R14,R12,12(R13)     PRINT
         LA    RWA,PRPROC
         B     PROLOGUE
SPENTRY  STM   R14,R12,12(R13)     SPACE
         LA    RWA,SPPROC
         B     PROLOGUE
OPENTRY  STM   R14,R12,12(R13)     OPEN
         LA    RWA,OPPROC
         B     PROLOGUE
CLENTRY  STM   R14,R12,12(R13)     CLOSE
         LA    RWA,CLPROC
         B     PROLOGUE
SHENTRY  STM   R14,R12,12(R13)     SETHEAD
         LA    RWA,SHPROC
         B     PROLOGUE
EJENTRY  STM   R14,R12,12(R13)     EJECT
         LA    RWA,EJPROC
         B     PROLOGUE
MDENTRY  STM   R14,R12,12(R13)     MODIFY
         LA    RWA,MDPROC
         B     PROLOGUE
         SPACE 2
* PROLOGUE.  SET UP BASE REGISTERS FOR CODING AND WORK AREA.  CHAIN
* SAVE AREAS IN STANDARD FASHION.  LOAD "RBAL" WITH CURRENT PAGE
* BALANCE AND "RPARM" WITH THE CALLING PARAMETER LIST ADDRESS.
         SPACE
PROLOGUE LR    RBASE,R15           LOAD CODING BASE REG
         USING BASEADDR,RBASE
         DROP  R15
         SPACE
         LR    RWKAREA,R0          BASE REG FOR WORK AREA
         USING WORKAREA,RWKAREA
         SPACE
         LR    RWB,R13             ADDR OF CALLER'S SAVE AREA
         LA    R13,SAVEAREA        ADDR OF OUR SAVE AREA
         ST    R13,8(RWB)          CHAIN TO US FROM CALLER
         ST    RWB,SAVEAREA+4      CHAIN TO CALLER FROM US
         SPACE
        $AMODE 24,REG=RWB
         LR    RPARM,R1            LOAD PARAMETER LIST ADDR
         LH    RBAL,PAGEBAL        LOAD PAGE LINE COUNT BALANCE
         MVC   DCBSYNAD(3),=AL3(SYNAD)  PUT ERROR ROUTINE ADDRESS IN
*                                  DCB
         SPACE
         TM    DCBOFLGS,OPENBIT    MAKE SURE DATA SET IS OPEN
         BCR   1,RWA               BRANCH IF OPEN
         CL    RWA,=A(OPPROC)      IF NOT, ONLY OPEN CALL ALLOWED
         BCR   8,RWA               BR IF OPEN CALL
         LA    R1,2                ERROR CODE 2, GO TO ABEND
         SPACE 3
* ABEND ROUTINE FOR SERIOUS ERRORS.  ENTER WITH ERROR NUMBER IN R1.
* ADD DECIMAL 4000 FOR USER CONPLETION CODE AND ISSUE 'ABEND' WITH DUMP
         SPACE
         CNOP  2,4                 ALIGN CONSTANT FOLLOWING SVC
ABEND    AL    R1,*+6              LOAD ABEND CODES
         SVC   13                  ISSUE ABEND SVC
         DC    X'80'               'DUMP' BIT FOR ABEND
         DC    AL3(4000)           BASE FOR COMPLETION CODE
         EJECT
************
* EPILOGUE *
************
         SPACE
* ALL MODES RETURN TO THE CALLER VIA THIS ROUTINE.  IT EXITS WITH
* THE RETURN CODE IN REGISTER 15, THE PAGE NUMBER IN REGISTER 0, AND
* THE NUMBER OF LINES REMAINING ON THE PAGE IN REGISTER 1.
         SPACE 2
EXIT4    LA    R15,4               SET RETURN CODE 4
         B     EXIT
         SPACE
EXIT0    SR    R15,R15             SET RETURN CODE 0
         SPACE
EXIT     LH    R0,PAGENO           LOAD CURRENT PAGE NUMBER
         LR    R1,RBAL             LOAD NUMBER OF LINES LEFT
         STH   RBAL,PAGEBAL        SAVE PAGE BALANCE
         XC    DCBSYNAD(3),DCBSYNAD  CLEAR ERROR ROUTINE ADDRESS
         SPACE
        $AMODE 31
         L     R13,SAVEAREA+4      ADDRESS OF CALLER'S SAVE AREA
         L     R14,12(R13)         LOAD RETURN ADDRESS
         LM    R2,R12,28(R13)      RESTORE CALLER'S REGISTERS
         MVI   12(R13),X'FF'       SET RETURN INDICATION
         BR    R14                 RETURN TO CALLER
         EJECT
******************
* PRINT FUNCTION *
******************
         SPACE
* PRINT LINE DELIVERY CALL.  THE PARAMETER LIST IS A VARIABLE-LENGTH
* LIST OF ADDRESSES, THE LAST OF WHICH IS NEGATIVE (I.E. BIT 0 IS A 1).
* EACH ADDRESS POINTS TO A PLD DESCRIBING A LINE TO BE PRINTED.  CALL
* THE GENERAL LIST PROCESSING ROUTINE TO DO THE DIRTY WORK.
         SPACE 2
PRPROC   BAL   RLPEXIT,LISTPROC    INVOKE LIST PROCESSOR
         SPACE
         B     EXIT0               EXIT TO CALLER
         EJECT
******************
* SPACE FUNCTION *
******************
         SPACE
* CALL TO MOVE THE PAPER A SPECIFIED NUMBER OF LINES.  IF THE NUMBER
* OF LINES EXCEEDS THE CURRENT PAGE BALANCE, AN EJECT RESULTS, UNLESS
* SUPPRESSED BY THE 'SPNOEJ' BIT IN THE PARAMETER LIST.  IF THE PAGE
* IS AT HEAD-OF-FORM, SPACING IS SUPPRESSED UNLESS THE 'SPATHOF' BIT
* IS SET IN THE PARAMETER LIST.  IN THE LATTER CASE, THE PAGE HEADINGS
* WILL BE PRINTED BEFORE THE SPACING IS EXECUTED.
         SPACE 2
         USING SPPARM,RPARM        ADDRESSING FOR PARM LIST
         SPACE
SPPROC   TM    SWITCHES,HOFBIT     TEST IF AT HEAD-OF-FORM
         BZ    SPSUBTR             BR IF NOT
         TM    SPCOND,SPATHOF      IS SPACE ALLOWED AT HOF?
         BZ    EXIT0               EXIT IF NOT
         BAL   RRET,HEADPRNT       IF SO, PRINT HEADINGS FIRST
         SPACE
SPSUBTR  SR    RSPACE,RSPACE
         IC    RSPACE,SPQUAN       LOAD SPACING AMOUNT
         SR    RBAL,RSPACE         COMPUTE NEW PAGE BALANCE
         SPACE
         BP    SPMOVE              BRANCH IF BAL STILL > 0
         TM    SPCOND,SPNOEJ       TEST IF EJECT ALLOWED
         BO    SPMOVE              BRANCH IF NOT
         LA    RSPACE,EJFORCE      IF ALLOWED, FORCE EJECT
         SPACE
SPMOVE   BAL   RWA,MOVE            CALL PAPER MOVING SUB
         B     EXIT0               EXIT TO CALLER
         SPACE
         DROP  RPARM
         EJECT
******************
* EJECT FUNCTION *
******************
         SPACE
* CALL TO MOVE THE PAPER TO HEAD-OF-FORM.  IF THE PAGE IS ALREADY
* THERE, THE EJECT IS NOT EXECUTED UNLESS THE 'EJATHOF' BIT IN THE
* PARAMETER LIST IS ON.  IN THE LATTER CASE, A SKIP IS EXECUTED WITHOUT
* PRINTING ANY HEADINGS, RESULTING IN A BLANK PAGE.  IF THE MASK BITS
* IN THE 'EJCOND' PARAMETER ARE NOT ALL ONES, A CONDITIONAL EJECT IS
* REQUESTED.  THE PAGE BALANCE IS COMPARED AGAINST THE TEST QUANTITY
* 'EJQUAN' IN THE PARAMETER LIST, THEN THE DECISION TO EJECT OR NOT
* IS MADE WITH A 'BC' ORDER USING THE 'EJCOND' BITS AS A MASK.
         SPACE 2
         USING EJPARM,RPARM        FOR PARM LIST ADDRESSING
         SPACE
EJPROC   TM    SWITCHES,HOFBIT     TEST IF AT HOF
         BZ    EJTEST              BR IF NOT
         TM    EJCOND,EJATHOF      IF SO, IS EJECT ALLOWED?
         BZ    EXIT0               IF NOT, EXIT
         SPACE
EJTEST   SR    R0,R0
         IC    R0,EJQUAN           LOAD TEST QUANTITY
         IC    R1,EJCOND           GET CONDITIONAL TEST MASK
         N     R1,=XL4'000000F0'   KEEP BITS 24-27 ONLY
         CR    RBAL,R0             COMPARE BALANCE WITH TEST QUAN
         EX    R1,EJBC             EXECUTE BC WITH MASK FROM PARM
         B     EXIT0               EXIT IF CONDITION NOT MET
         SPACE
EJMOVE   LA    RSPACE,EJFORCE      TO FORCE EJECT
         BAL   RWA,MOVE            CALL PAPER MOVER SUB
         B     EXIT0               EXIT TO CALLER
         SPACE 2
EJBC     BC    0,EJMOVE            BRANCH IF EJECT REQUIRED
         SPACE
         DROP  RPARM
         EJECT
*****************
* OPEN FUNCTION *
*****************
         SPACE
* THIS MUST BE THE FIRST CALL FOR A NEW DATA SET.  IT SETS THE DDNAME
* IN THE DCB AND OPENS THE DATA SET.   ALL COUNTERS AND SWITCHES ARE
* SET TO THEIR NOMINAL VALUES BEFORE PROCESSING ANY OPTIONS WHICH
* MAY HAVE BEEN SUPPLIED WITH THE CALL.  THE PAGE BALANCE IS SET TO
* ZERO, BUT THE PAGE IS NOT MOVED.  THE PROGRAMMER SHOULD NORMALLY
* ISSUE AN 'EJECT' CALL BEFORE BEGINNING HIS OUTPUT.
         SPACE
* IF THE DATA SET IS ALREADY OPEN, THE DDNAME IS IGNORED, THE NOMINAL
* OPTIONS ARE SET, THEN THIS CALL IS TREATED EXACTLY AS IF IT WERE A
* 'MODIFY' CALL.
         SPACE 2
         USING OMPARM,RPARM
         SPACE
OPPROC   MVC   PAPARMS(DEFSIZE),DEFAULTS  SET STANDARD OPTIONS
         MVI   HLTEXT,C' '         CLEAR HEADING TEXT
         MVC   HLTEXT+1(HLTXTLNG-1),HLTEXT
         SPACE
         TIME  DEC                 GET CURRENT DATE & TIME
         STM   R0,R1,HPRSAVE       SAVE TIME AND DATE
         SPACE
* NOW IF DATA SET IS ALREADY OPEN, GO TO 'MDPROC'.  OTHERWISE, INSERT
* DDNAME AND OPEN IT.
         SPACE
         TM    DCBOFLGS,OPENBIT    TEST IF OPEN
         BO    OPJOIN              BR TO 'MDPROC' IF OPEN
         MVC   DCBDDNAM(8),OMDDNAME  INSERT DDNAME INTO CLOSED DCB
         MVC   DCBEXLST(3),=AL3(EXLST)  INSERT ADDRESS OF EXIT LIST
         SPACE
         MVI   DWORK,X'80'         SET END-OF-LIST BIT
         OPEN  (PRINTDCB,(OUTPUT,LEAVE)),MF=(E,DWORK)
         SPACE
         XC    DCBEXLST(3),DCBEXLST  CLEAR ADDRESS OF EXIT LIST
         TM    DCBOFLGS,OPENBIT    TEST FOR SUCCESSFUL OPEN
         BO    OPJOIN              TO 'MDPROC' IF O.K.
         B     EXIT4               EXIT WITH RC=4 IF OPEN FAILS
         SPACE
         DROP  RPARM
         EJECT
* DCB EXIT ROUTINE FOR OPEN.  SET BLOCK SIZE TO THE DEFAULT VALUE IF
* NOT SPECIFIED IN DS LABEL OR DD CARD.
         SPACE
EXLST    DS    0F                  EXIT LIST, ON BOUNDARY
         DC    X'85'
         DC    AL3(DCBMOD)
         SPACE
DCBMOD   LH    RWA,DCBBLKSZ        LOAD BLOCK SIZE
         LTR   RWA,RWA             TEST IF ZERO
         BNZ   DCBNZ               BRANCH IF NOT ZERO
SETDEF   LA    RWA,DEFBLKSZ        SET DEFAULT BLOCK SIZE
         STH   RWA,DCBBLKSZ        STORE IN DCB
         BR    R14                 RETURN TO OPEN ROUTINE
DCBNZ    CH    RWA,=H'141'         TEST FOR MINIMUM BLOCKSIZE
         BL    SETDEF              USE DEFAULT IF TOO LOW
         BR    R14                 RETURN TO OPEN IF OK
         EJECT
*******************
* MODIFY FUNCTION *
*******************
         SPACE
* THIS CALL MAY ALTER ANY  OR ALL OF THE FOLLOWING: DATE, TIME, PAGE
* NUMBER, PAGE LENGTH, PAGE WIDTH, MAXIMUM NUMBER OF OUTPUT LINES.
* THE NEW VALUES ARE PRESENTED IN A PARAMETER LIST.  IF A PARAMETER IS
* ZERO, THE CORRESPONDING QUANTITY IS NOT ALTERED.
         SPACE
* THE DATE AND TIME FIELDS MAY BE SUPPLIED BY THE 'OPEN' ROUTINE,
* WHICH JOINS THIS CODING AT 'OPJOIN'.  IN THAT CASE, THE VALUES
* INSERTED BY 'OPEN' ARE USED UNLESS OVERRIDDEN BY THE PARAMETER LIST.
         SPACE
         USING OMPARM,RPARM
         SPACE
MDPROC   SR    R0,R0               GENERATE TWO ZERO WORDS
         SR    R1,R1
         STM   R0,R1,HPRSAVE       SET DATE & TIME FIELDS TO ZERO
         SPACE
* ENTER HERE FROM 'OPEN'.  THE OBJECT OF THE FOLLOWING IS TO GET THE
* ACTUAL TIME AND DATE (IN PACKED DECIMAL) INTO 'HPRSAVE' AND
* 'HPRSAVE+4', RESPECTIVELY.  THOSE FIELDS MAY HAVE BEEN FILLED IN BY
* THE OPEN ROUTINE, OR THEY MAY HAVE BEEN SET TO ZEROS BY 'MDPROC'
* ABOVE.  NOW WE SEE IF ADDRESSES FOR TIME AND/OR DATE VALUES WERE
* PROVIDED IN THE PARAMETER LIST, AND TRANSFER THE VALUES IF SO.
         SPACE
OPJOIN   LM    RWA,RWB,OMTIMEAD    LOAD TIME & DATE ADDRS FROM PARM
         LTR   RWA,RWA             TEST FOR TIME ADDR SUPPLIED
         BZ    NOTIME              BRANCH IF ZERO
         MVC   HPRSAVE(4),0(RWA)   GET TIME AS DECIMAL 'HHMMSSTH'
NOTIME   LTR   RWB,RWB             TEST IF DATE ADDR SUPPLIED
         BZ    DATEEDIT            BR IF NOT
         MVC   HPRSAVE+4(4),0(RWB)  GET DECIMAL DATE AS '00YYDDD+'
         SPACE
* IF THE DATE VALUE IS NOT ZERO, EDIT INTO THE HEADING LINE TEXT.  BOTH
* THE DAY NUMBER AND THE MONTH-DAY-YEAR FORM ARE USED.
         SPACE
DATEEDIT LM    RWA,RWB,HPRSAVE     LOAD TIME & DATE FOR TESTING
         LTR   RWB,RWB             TEST IF DATE WAS GIVEN
         BZ    TIMEEDIT            BRANCH IF ZERO
         SPACE
         MVC   HLDAY(4),=C'DAY='   INSERT DAY NUMBER
         UNPK  HLDAY+4(3),HPRSAVE+6(2)  UNPACK DAY NUMBER
         OI    HLDAY+6,X'F0'       TIDY UP SIGN BITS
         SPACE
         ST    RWB,DWORK+4         STORE DATE ARG FOR EDIT RTNE
         LA    R1,DWORK            CONSTRUCT ONE-WORD PARM LIST
         ST    R1,HPRSAVE+4        FOR XDATEDIT CALL
         LA    R1,HPRSAVE+4        LOAD PARM LIST ADDRESS
         L     R15,=V(XDATEDIT)    LOAD ADDRESS OF DATE EDIT RTNE
         BALR  R14,R15             TO EDIT DATE AS 'MM/DD/YY'
         MVC   HLDATE(8),DWORK     INSERT RESULT IN HL TEXT
         SPACE
* EDIT TIME IN HOURS AND MINUTES, IF SUPPLIED.
         SPACE
TIMEEDIT LTR   RWA,RWA             TEST IF TIME GIVEN
         BZ    TSTPGNO             BR IF ZERO
         SRL   RWA,4               ADD LEADING ZERO TO TIME
         ST    RWA,HPRSAVE         STORE TIME IN WORK LOC
         MVC   HLTIME(7),=X'402120207A2020'  EDIT CONTROL CHAR
         ED    HLTIME(7),HPRSAVE   EDIT INTO ALPHA
         SPACE
* MODIFY PAGE NUMBER.  VALUE GIVEN IS DECREMENTED BY ONE, SINCE IT IS
* INCREMENTED BEFORE USE.
         SPACE
TSTPGNO  LH    RWA,OMPAGENO        GET VALUE FROM PARM LIST
         LTR   RWA,RWA             TEST IF ZERO
         BZ    TSTPGWID            BR IF ZERO
         BCTR  RWA,0               DECREMENT BY 1
         STH   RWA,PAGENO          STORE
         SPACE
* MODIFY PAGE WIDTH, TESTING FOR MAXIMUM ALLOWED.
         SPACE
TSTPGWID SR    RWA,RWA
         IC    RWA,OMPAGWID        GET WIDTH FROM PARM LIST
         LTR   RWA,RWA             TEST IF ZERO
         BZ    TSTPGLNG            BRANCH IF SO
         CLI   OMPAGWID,MAXWIDTH   TEST MAXIMUM SIZE
         BNH   PGWIDOK
         LA    R1,3                ERROR, TOO LARGE
         B     ABEND
PGWIDOK  STH   RWA,PAGWIDTH
         SPACE
* MODIFY PAGE LENGTH, TESTING FOR MAXIMUM VALUE.
         SPACE
TSTPGLNG SR    RWA,RWA
         IC    RWA,OMPAGLNG        GET FROM PARM LIST
         LTR   RWA,RWA             TEST IF SUPPLIED
         BZ    TSTMAXLN            BR IF NOT
         CLI   OMPAGLNG,MAXLNGTH   TEST FOR LEGAL VALUE
         BNH   PGLNGOK
         LA    R1,4                ERROR, ABORT
         B     ABEND
PGLNGOK  STH   RWA,PAGELNG         STORE
         SPACE
* MODIFY PRINT LINE LIMIT COUNTER.
         SPACE
TSTMAXLN L     RWA,OMMAXLIN        GET FROM PARM LIST
         LTR   RWA,RWA             TEST IF SUPPLIED
         BZ    EXIT0               EXIT IF NOT
         ST    RWA,MAXLINES        STORE
         B     EXIT0               EXIT TO CALLER
         SPACE
         DROP  RPARM
         EJECT
********************
* SETHEAD FUNCTION *
********************
         SPACE
* THIS CALL PRESENTS A LIST OF LINES WHICH WILL BE USED AS PAGE HEADING
* AND SUB-HEADING LINES.  THE PARAMETER LIST IS A VARIABLE-LENGTH LIST
* OF PLD ADDRESSES, EXACTLY AS FOR 'PRINT' CALLS.  THE FIRST LINE WILL
* HAVE ADDED TO ITS RIGHT END THE DATE, TIME, AND PAGE NUMBER.
* HOWEVER, IF ITS LENGTH EXCEEDS 98 BYTES, IT WILL OVERLAY THOSE
* FIELDS.  THE SECOND AND SUBSEQUENT LINES WILL BE PRINTED NORMALLY.
* NOTE THAT THESE LINES ARE NOT PRINTED WHEN THE PAGE IS EJECTED, BUT
* WHEN THE LINE WHICH WILL BE FIRST ON THE NEW PAGE IS DELIVERED, THUS
* ALLOWING THE HEADINGS TO BE ALTERED AFTER DELIVERY OF THE LAST LINE
* ON THE PRECEDING PAGE.  THE ADDRESS OF THE PARAMETER LIST IS SAVED
* BY THE PRINTING ROUTINE, BUT THE PARAMETER LIST, THE PLD'S TO WHICH
* IT POINTS, AND THE LINE TEXTS TO WHICH THEY POINT, MUST BE PRESERVED
* BY THE PROBLEM PROGRAM FOR AS LONG AS THEY ARE IN USE, SINCE THEY
* ARE REFERRED TO AT THE BEGINNING OF EACH NEW PAGE.  EACH CALL TO
* TO 'SETHEAD' SUPERSEDES THE EFFECT OF THE PREVIOUS CALL.  A CALL WITH
* A PARAMETER LIST ADDRESS OF ZERO INDICATES THAT NO HEADINGS ARE
* PROVIDED BY THE PROBLEM PROGRAM, AND ONLY THE PAGE NUMBER, DATE, AND
* TIME WILL BE PRINTED, WITH A STANDARD SPACING OF THREE.
         SPACE 2
SHPROC   LTR   RPARM,RPARM         TEST FOR NULL LIST ADDR
         BNZ   SHOK                BRANCH IF NON-ZERO
         LA    RPARM,NOHDLIST      ADDRESS OF PLD FOR BLANK LINE
SHOK     ST    RPARM,HEADLIST      STORE ADDR OF HEADING PARMS
         B     EXIT0               EXIT
         EJECT
******************
* CLOSE FUNCTION *
******************
         SPACE
* THIS CALL CLOSES THE PRINTER DATA SET.  IT DOES NOT MOVE THE PAGE
* OR ALTER ANY SWITCHES OR VARIABLES EXCEPT THE DCB ITSELF.
* AFTER CLOSING THE DCB, IT RELEASES THE PRINT BUFFERS.
         SPACE 2
CLPROC   TM    DCBOFLGS,OPENBIT    IS DCB OPEN NOW?
         BZ    EXIT0               EXIT IF ALREADY CLOSED
         MVI   DWORK,X'80'         SET END-OF-LIST BIT
         CLOSE (PRINTDCB,LEAVE),MF=(E,DWORK)
         SPACE
         FREEPOOL  PRINTDCB        FREE THE BUFFER CORE
         SPACE
         B     EXIT0               EXIT TO CALLER
         EJECT
************
* LISTPROC *
************
         SPACE
* THIS ROUTINE PROCESSES A LIST OF PLD ADDRESSES, FORMATTING EACH PRINT
* LINE AND PERFORMING THE NECESSARY PRE- AND POST-SPACING OPERATIONS.
* IT IS ENTERED WITH 'RPARM' POINTING TO THE LIST OF ADDRESSES AND
* 'RLPEXIT' CONTAINING THE EXIT ADDRESS.  IT MAY DISCOVER THAT ITS
* SPACING OPERATIONS HAVE BROUGHT THE PAGE TO HEAD OF FORM, REQUIRING
* THAT THE HEADING AND SUB-HEADING LINES BE PRINTED.  WHEN THIS OCCURS,
* IT BRANCHES TO 'HEADPRNT', WHICH SAVES 'RPARM' AND 'RLPEXIT' AND
* REENTERS THIS ROUTINE WITH AN ADDRESS LIST FOR THE HEADING LINES.
* (WHEN THIS SECOND-LEVEL CALL IS MADE, SWITCH 'NOSKPBIT' IS ON,
* PREVENTING ANY FURTHER PAGE SKIPS AND ELIMINATING THE POSSIBILITY OF
* YET ANOTHER CALL TO 'HEADPRNT'.)  AFTER THE HEADINGS ARE PRINTED,
* THE ORIGINAL VALUES ARE RETURNED TO 'RPARM' AND 'RLPEXIT' AND
* PROCESSING OF THE LIST OF TEXT LINES PROVIDED BY THE CALLER IS
* CONTINUED.
         SPACE 2
         USING PLDBLOCK,RPLD       TO ADDRESS PLD BLOCKS
         SPACE
LISTPROC L     RPLD,0(RPARM)       LOAD A PLD BLOCK ADDRESS
         SPACE
* IF PAGE IS NOW AT HEAD OF FORM, EXECUTE 'HEADPRNT'.
         SPACE
         LA    RRET,LISTPROC       EXIT FROM HEADPRNT STARTS AGAIN
         TM    SWITCHES,HOFBIT     SEE IF HEAD-OF-FORM FLAG IS ON
         BO    HEADPRNT            EXIT IF SO
         SPACE 2
* TEST WHETHER WE ARE AT THE FIRST TEXT LINE ON A PAGE, AND, IF SO,
* WHETHER PRE-SPACING IS ALLOWED IN THAT POSITION.  IF NOT, BYPASS
* PRE-SPACING ALTOGETHER.
         SPACE
         TM    SWITCHES,TXT1BIT    TEST IF FIRST TEXT LINE
         BZ    PRSUBTR             BRANCH IF NOT
         TM    PLDFLAGS,PRHOFBIT   TEST IF ALLOW SKIP AT HOF
         BZ    POSTSP              SKIP PRESPACING IF NOT
         SPACE
* DECREMENT THE PAGE BALANCE BY THE AMOUNT TO BE SPACED.
         SPACE
PRSUBTR  SR    RSPACE,RSPACE
         IC    RSPACE,PLDSPB       LOAD AMOUNT TO SPACE
         SR    RBAL,RSPACE         DECREMENT PAGE BALANCE
         SPACE
* IF SKIPPING IS ALLOWED BY BOTH THE SYSTEM AND THE USER, TEST THE
* BALANCE AND FORCE A PAGE SKIP IF <= ZERO.
         SPACE
         TM    SWITCHES,NOSKBIT    TEST IF SYSTEM ALLOWS SKIP
         BO    PREMOVE             BRANCH IF NOT
         TM    PLDFLAGS,PRSKPBIT   TEST IF USER ALLOWS SKIP
         BO    PREMOVE             BRANCH IF NOT
         LTR   RBAL,RBAL           TEST PAGE BALANCE
         BP    PREMOVE             BRANCH IF SOME LINES LEFT
         LA    RSPACE,EJFORCE      FORCE A PAGE SKIP
         SPACE
* MOVE THE PAGE THE NUMBER OF LINES IN 'RSPACE'.
         SPACE
PREMOVE  BAL   RWA,MOVE            TO PAPER MOVING SUBROUTINE
         SPACE
* IF THAT MOVING PUT US AT HEAD-OF-FORM, PRINT THE HEADINGS.
         SPACE
         LA    RRET,LISTPROC       EXIT FROM HEADPRNT STARTS AGAIN
         TM    SWITCHES,HOFBIT     TEST HEAD-OF-FORM BIT
         BO    HEADPRNT            EXIT IF AT HEAD
         SPACE 2
* NOW CONSIDER THE SPACING TO BE PERFORMED WHEN THE TEXT OF THE LINE
* IS PRINTED.  BEGIN BY COMPUTING THE NEW PAGE BALANCE.
         SPACE
POSTSP   SR    RSPACE,RSPACE
         IC    RSPACE,PLDSPA       LOAD AMOUNT TO SPACE AFTER PRINT
         SR    RBAL,RSPACE         COMPUTE NEW PAGE BALANCE
         SPACE
* IF THE SYSTEM AND USER BOTH ALLOW SKIPPING, TEST THE PAGE BALANCE,
* AND FORCE A SKIP IF <= ZERO.
         SPACE
         TM    SWITCHES,NOSKBIT    TEST IF SYSTEM ALLOWS SKIPPING
         BO    GETPRCC             BRANCH IF NOT
         TM    PLDFLAGS,SPSKPBIT   TEST IF USER ALLOWS SKIPPING
         BO    GETPRCC             BRANCH IF NOT
         LTR   RBAL,RBAL           TEST FOR PAGE END
         BP    GETPRCC             BRANCH IF SOME LINES LEFT
         LA    RSPACE,EJFORCE      FORCE PAGE SKIP
         SPACE
* NOW CONSTRUCT THE PRINT LINE IN AN OUTPUT BUFFER.  IN THE INTERESTS
* OF SAVING BUFFER SPACE, THE CALLER'S TEXT IS SCANNED FROM THE RIGHT
* TO REDUCE ITS NOMINAL LENGTH BY THE NUMBER OF RIGHT BLANKS.  IN THE
* EXTREME CASE THAT IT IS ENTIRELY BLANK, BYPASS PRINTING ALTOGETHER
* AND MERELY SPACE.  IF THIS IS TO BE THE FIRST HEADING LINE OF THE
* PAGE ('HD1BIT' SET), SCANNING IS OMITTED, THE RECORD LENGTH IS SET TO
* THE PAGE WIDTH, AND THE DATE, TIME, AND PAGE NUMBER ARE INSERTED.
         SPACE
GETPRCC  DS    0H
         SR    RWA,RWA
         IC    RWA,PLDLNGTH        LOAD NOMINAL LENGTH OF TEXT
         SR    RWB,RWB
         IC    RWB,PLDOFFST        LOAD LEFT MARGIN OFFSET
         SPACE
         LA    R0,0(RWA,RWB)       LINE LENGTH = TEXT + OFFSET
         CH    R0,PAGWIDTH         TEST AGAINST PAGE WIDTH
         BNH   TSTHD1              BR IF OK
         LA    R1,5                ERROR, LINE TOO LONG
         B     ABEND
         SPACE
TSTHD1   TM    SWITCHES,HD1BIT     TEST IF FIRST HEADING LINE
         BZ    BLNKSCAN            BR IF NOT
         LH    RWB,PAGWIDTH        SET RECORD LENGTH AS PAGE WIDTH
         B     GETBUF              SKIP BLANK SCANNING
         SPACE
* SET UP A 'BXH' FOR SCAN.  R0 IS INCREMENT, R1 IS COMPARAND, RWA
* VARIABLE.
         SPACE
BLNKSCAN LH    R0,=H'-1'           INCREMENT IS MINUS 1
         L     R1,PLDTXTAD-1       LOAD TEXT ADDRESS
         LA    R1,0(R1)            ZERO HIGH-ORDER BYTE
         BCTR  R1,0                DECREMENT BY ONE
         AR    RWA,R1              SET RWA TO RIGHT-MOST TEXT BYTE
         SPACE
* SCAN THE LINE, SEARCHING FOR FIRST NON-BLANK.  RESULT IS NEW TEXT
* LENGTH IN RWA, WHICH WILL BE ZERO FOR BLANK LINES.
         SPACE
BLNKLOOP CLI   0(RWA),C' '         TEST FOR NON-BLANK CHAR
         BNE   BLNKDONE            EXIT WHEN FOUND
         BXH   RWA,R0,BLNKLOOP
BLNKDONE SR    RWA,R1              NOW RWA IS NEW TEXT LENGTH
         BC    13,POSTMOVE         NO PRINTING IF <= 0
         SPACE
* NOW ADD OFFSET TO LENGTH OF SURVIVING TEXT TO GET ACTUAL LINE LENGTH.
         SPACE
         AR    RWB,RWA             ADD TEXT LENGTH
         SPACE
* NOW RWA IS THE LENGTH OF THE CALLER'S TEXT, AND RWB IS THE LENGTH OF
* THE LINE.  THE RECORD LENGTH WILL BE FIVE MORE THAT THE LENGTH OF THE
* LINE, TO INCLUDE FORMAT 'V'  AND PRINTER CONTROL CHARACTERS.  GET
* A BUFFER OF THE PROPER LENGTH, KEEPING ITS ADDRESS IN R1.
         SPACE
GETBUF   LA    RWC,5(RWB)          LOAD LENGTH OF RECORD IN RWC
         STH   RWC,DCBLRECL        PUT LRECL IN DCB FOR PUT CALL
         SPACE
         PUT   PRINTDCB            GET BUFFER ADDRESS IN R1
         SPACE
         ST    R1,CCLAST           SAVE LOCATION OF THIS LINE
         LR    RWD,R1              RWD BECOMES BUFFER BASE REG
         MVI   3(RWD),C' '         CLEAR BUFFER TO BLANKS
         EX    RWB,BLNKMOVE
         SLL   RWC,16              SET UP 4-BYTE 'V' CONTROL FIELD
         ST    RWC,DWORK           CAN'T ASSUME BUFFER ON ANY
         MVC   0(4,RWD),DWORK      BOUNDARY
         SPACE
* IF THIS IS THE FIRST HEADING LINE, INSERT DATE AND TIME, AND EDIT
* THE PAGE NUMBER.
         SPACE
         TM    SWITCHES,HD1BIT     TEST IF FIRST LINE
         BZ    MOVETEXT            BRANCH IF NOT
         SPACE
         LA    RWC,0(RWB,RWD)      ADDRESS RIGHT END -5
         SH    RWC,=AL2(HLTXTLNG+10-5)  LOCATE PLACE FOR HEADING INFO
         MVC   0(HLTXTLNG,RWC),HLTEXT  INSERT DATE & TIME
         SPACE
         LH    R1,PAGENO           INCREMENT PAGE NUMBER
         LA    R1,1(R1)
         STH   R1,PAGENO
         CVD   R1,DWORK            CONVERT TO DECIMAL
         MVC   HLTXTLNG(10,RWC),=XL10'40404040402020202120'  EDIT CHARS
         LA    R1,HLTXTLNG+9(RWC)  IN CASE SIGNIFIGANCE FORCED
         EDMK  HLTXTLNG+4(6,RWC),DWORK+5  EDIT AND MARK SPOT FOR "PAGE"
         SH    R1,=H'5'
         MVC   0(4,R1),=C'PAGE'    INSERT WORD "PAGE"
         SPACE
* PUT PRINTER CONTROL CHARACTER AND CALLER'S TEXT INTO THE BUFFER.
* REGISTER RWA CONTAINS THE LENGTH OF THE TEXT.
         SPACE
MOVETEXT BAL   RWB,CCGEN           GO GET CONTROL CHAR
         STC   R0,4(RWD)           INSERT IN BUFFER
         NI    4(RWD),B'11111101'  CHANGE SPACE IMMEDIATE TO WRITE
         SPACE
         SR    RWB,RWB
         IC    RWB,PLDOFFST        LOAD LEFT MARGIN OFFSET
         LA    RWB,5(RWB,RWD)      ADDRESS FOR FIRST TEXT BYTE
         BCTR  RWA,0               DECREMENT LENGTH BY 1 FOR MVC
         L     RWC,PLDTXTAD-1      LOAD ADDRESS OF CALLER'S TEXT
         EX    RWA,MOVEINST        MOVE TEXT
         SPACE
         NI    SWITCHES,255-HD1BIT-TXT1BIT  RESET ONE-SHOT BITS
         SPACE
* DECREMENT PRINT LINE LIMIT COUNTER, ABORTING IF IT GOES NEGATIVE.
         SPACE
         L     R1,MAXLINES
         S     R1,=F'1'            BCTR WOULD NOT SET COND CODE
         ST    R1,MAXLINES
         BP    POSTMOVE            BRANCH IF POSITIVE
         LA    R1,6                ABORT, TOO MUCH OUTPUT
         B     ABEND
         SPACE
* DO ANY ADDITIONAL SPACING NECESSARY.  AMOUNT STILL IN 'RSPACE'.
         SPACE
POSTMOVE BAL   RWA,MOVE            CALL PAPER MOVING SUBROUTINE
         SPACE 2
* NOW WE ARE FINISHED WITH THAT LINE.  IF THE ADDRESS WHICH POINTED TO
* ITS PLD WAS NEGATIVE, THE LIST IS EXHAUSTED AND THE ROUTINE EXITS.
* OTHERWISE, INCREMENT THE LIST POINTER BY 4 AND START THE NEXT ONE.
         SPACE
         LTR   RPLD,RPLD           TEST CURRENT PLD ADDRESS
         BCR   4,RLPEXIT           EXIT IF NEGATIVE
         SPACE
         LA    RPARM,4(RPARM)      INCREMENT LIST POINTER
         B     LISTPROC            TO PROCESS NEXT LINE
         SPACE 2
* EXECUTED INSTRUCTIONS:
         SPACE
BLNKMOVE MVC   4(0,RWD),3(RWD)     SPREAD BLANKS IN OUTPUT BUFFER
MOVEINST MVC   0(0,RWB),0(RWC)     MOVE CALLER'S TEXT TO OUTPUT BUF
         SPACE
         DROP  RPLD
         EJECT
************
* HEADPRNT *
************
         SPACE
* ENTER THIS ROUTINE WHEN IT IS DISCOVERED THAT WE ARE AT
* HEAD-OF-FORM AND ARE ABOUT TO PRINT A LINE.  SAVE THE REGISTERS
* DEFINING THE STATE OF 'LISTPROC' AND CALL IT WITH A LIST SPECIFYING
* THE HEADING AND SUB-HEADING LINES.
         SPACE 2
HEADPRNT ST    RRET,HPREXIT        SAVE RETURN ADDRESS
         STM   RLPEXIT,RPARM,HPRSAVE  STORE LISTPROC REGISTERS
         SPACE
* RESET HEAD-OF-FORM BIT AND SET NO-SKIP BIT TO SUPPRESS FORM SKIPS
* AND HEADING LINE BIT TO INCLUDE THE PAGE NUMBER.  RESET PAGE BALANCE.
         SPACE
         NI    SWITCHES,255-HOFBIT  RESET HOF BIT
         OI    SWITCHES,HD1BIT+NOSKBIT  SET HEADING AND NOSKIP BITS
         LH    RBAL,PAGELNG        RESET PAGE BALANCE
         SPACE
* LOAD ADDRESS OF HEADINGS LIST AND CALL LIST PROCESSOR.
         SPACE
         L     RPARM,HEADLIST      ADDRESS OF HEADINGS LIST
         BAL   RLPEXIT,LISTPROC    CALL PROCESSING ROUTINE
         SPACE
* AFTER PRINTING THE HEADINGS, TURN SYSTEM SKIP-SUPPRESSION BIT OFF
* AND SET 'TXT1BIT' TO INDICATE THAT THERE ARE NO TEXT LINES ON THE
* PAGE YET.  THEN RESTORE THE 'LISTPROC' REGISTERS AND RETURN TO
* PROCESSING THE CALLER'S LINES.
         SPACE
         NI    SWITCHES,255-NOSKBIT  RESET NO-SKIP BIT
         OI    SWITCHES,TXT1BIT    SET FIRST-TEXT-LINE BIT
         SPACE
         LM    RLPEXIT,RPARM,HPRSAVE  RESTORE LISTPROC REGISTERS
         L     RRET,HPREXIT        RECOVER EXIT ADDRESS AND
         BR    RRET                RETURN TO CALLER
         EJECT
***********************************
* MOVE - VERTICAL SPACING ROUTINE *
***********************************
         SPACE
* SUBROUTINE TO MOVE THE PAPER BY THE NUMBER OF LINES IN REGISTER
* 'RSPACE'.  RETURN ADDRESS IS IN 'RWA'.  IF THE CONTROL CHARACTER FOR
* THE LAST LINE SPACED 0 LINES, REPLACE IT WITH A NEW ONE BEFORE
* GENERATING ANY EXTRA LINES.
         SPACE 2
MOVE     LTR   RSPACE,RSPACE       TEST NUMBER OF LINES TO BE MOVED
         BCR   13,RWA              EXIT IF <= ZERO
         TM    SWITCHES,SP0BIT     DID PREVIOUS LINE SPACE 0?
         BZ    PREVNOT0            BRANCH IF NOT
         L     R1,CCLAST           GET ADDRESS OF PREVIOUS LINE
         BAL   RWB,CCGEN           GENERATE NEW CONTROL CHAR
         NI    4(R1),X'02'         TEST WRITE/SPACE BIT IN OLD CC
         STC   R0,4(R1)            STORE NEW CC IN PREVIOUS LINE
         BNZ   *+8                 BR IF WRITE/SPACE BIT WAS ON
         NI    4(R1),255-X'02'     TURN WRITE/SPACE BIT OFF
PREVNOT0 DS    0H
         MVC   DCBLRECL(2),MOVELINE  SET LOGICAL RECORD LENGTH IN DCB
         SPACE
         PUT   PRINTDCB            GET BUFFER ADDRESS IN R1
         SPACE
         ST    R1,CCLAST           SAVE LOCATION OF THIS LINE
         MVC   0(6,R1),MOVELINE    INSERT FORMAT 'V' CONTROL RECORD
         BAL   RWB,CCGEN           GET PRINT CONTROL CHAR IN R0
         STC   R0,4(R1)            INSERT IN RECORD
         SPACE
         B     MOVE                LOOP UNTIL 'RSPACE' IS ZERO
         SPACE 3
MOVELINE DC    XL6'000600000340'   FORMAT 'V' CONTROL RECORD
         EJECT
*****************************************
* CCGEN - GENERATE PRINTER CONTROL CHAR *
*****************************************
         SPACE
* THIS ROUTINE GENERATES A PRINTER CONTROL CHARACTER TO SPACE OR EJECT
* IMMEDIATELY (WITHOUT PRINTING).  ENTER WITH THE TOTAL NUMBER OF
* LINES TO BE MOVED IN 'RSPACE' AND RETURN ADDRESS IN 'RWB'.  EXITS
* WITH THE CONTROL CHARACTER IN BITS 24-31 OF REGISTER 0 AND THE COUNT
* IN 'RSPACE' DECREMENTED BY THE AMOUNT WHICH THE CHARACTER WILL SPACE.
* A SPACE VALUE OF 255 OR GREATER WILL GENERATE AN EJECT CONTROL
* CHARACTER, SET 'RSPACE' AND 'RBAL' TO ZERO, AND SET THE HEAD-OF-FORM
* BIT.  NOTE:  MUST NOT USE R1.
         SPACE 2
CCGEN    NI    SWITCHES,255-SP0BIT  RESET 'PREVIOUS SPACED 0' BIT
         CH    RSPACE,=AL2(EJFORCE)  TEST FOR EJECT REQUEST
         BL    CCNOEJ              BRANCH IF NOT
         LA    R0,X'8B'            LOAD 'SKIP TO CHAN 1' CC
         OI    SWITCHES,HOFBIT     SET HEAD-OF-PAGE BIT
         SR    RBAL,RBAL           SET PAGE BALANCE TO ZERO
         SR    RSPACE,RSPACE       SET REMAINING SPACING TO ZERO
         BR    RWB                 EXIT
         SPACE
CCNOEJ   LR    R15,RSPACE          LOAD WORK REGISTER
         CH    RSPACE,=H'3'        TEST IF OVER THREE LINES
         BNH   CCOK                BR IF <= 3
         LA    R15,3               SET 3, MAXIMUM FOR 1 OPERATION
CCOK     SR    RSPACE,R15          DECR RSPACE BY AMOUNT SPACED
         SLL   R15,3               PUT AMOUNT IN BITS 2-4 OF BYTE
         LA    R0,X'03'(R15)       ADD COMMAND BITS AND PUT IN R0
         LTR   R15,R15             TEST FOR ZERO SPACING
         BCR   7,RWB               EXIT IF NOT ZERO
         OI    SWITCHES,SP0BIT     SET 'LINE SPACED 0' BIT
         BR    RWB                 EXIT
         EJECT
***********************
* SYNAD ERROR ROUTINE *
***********************
         SPACE
* IF A PERMANENT I/O ERROR OCCURS, TYPE A DIAGNOSTIC MESSAGE AND ABORT.
         SPACE
SYNAD    SYNADAF ACSMETH=QSAM      GET ERROR MESSAGE FROM O/S
         LR    RWA,R1              SAVE MESSAGE ADDRESS
         GETMAIN R,LV=128          GET BUFFER FOR MESSAGE
         MVC   0(LIOMSG,R1),IOMSG  INSERT MESSAGE BEGINNING
         MVC   LIOMSG(79,R1),49(RWA)  ADD TEXT FROM O/S
         LR    RWA,R1              SAVE MESSAGE ADDRESS
         SYNADRLS                  FREE O/S MESSAGE
         WTO   MF=(E,(RWA))        TYPE MESSAGE ON CONSOLE
         LA    R1,7                LOAD ERROR CODE
         B     ABEND               TO ABORT AND DUMP
         SPACE
IOMSG    DC    AL2(LIOMSG+78,0)    FORMAT V CONTROL FIELD
         DC    C'XPRNTSUB I/O ERROR'
LIOMSG   EQU   *-IOMSG
         EJECT
**************************
* CONSTANTS AND LITERALS *
**************************
         SPACE
* DUMMY PARAMETER LIST AND PLD FOR USE WHEN NO HEADING IS PROVIDED.
         SPACE
NOHDLIST DS    0F
         DC    XL1'80'             VL LIST BIT
         DC    AL3(NOHDPLD)        ADDRESS OF PLD BELOW
         SPACE
NOHDPLD  DS    0F                  ALIGN ON FULL-WORD BOUNDARY
         DC    BL1'00010000'       OPTION BITS
         DC    AL3(BLANK1)         PRINT TEXT ADDRESS
         DC    AL1(1)              PRINT TEXT LENGTH
         DC    AL1(0)              LEFT MARGIN INDENTATION
         DC    AL1(0)              SPACING BEFORE PRINTING
         DC    AL1(3)              SPACING AFTER PRINTING
         SPACE
* CONSTANTS TO INITIALIZE PARAMETERS AND SWITCHES WHEN 'OPEN' CALL IS
* RECEIVED.  THE ORDER MUST MATCH THE 'PAPARMS' LIST IN THE WORK AREA.
         SPACE
DEFAULTS DS    0F
         DC    A(NOHDLIST)         PAGE HEADING PARM LIST ADDRESS
         DC    F'1000000'          MAXIMUM NUMBER OF OUTPUT LINES
         DC    H'132'              PAGE WIDTH
         DC    H'57'               PAGE LENGTH            ***TRW***
         DC    H'0'                PAGE NUMBER (-1)
         DC    H'0'                PAGE BALANCE
         DC    X'00'               SWITCHES
DEFSIZE  EQU   *-DEFAULTS
         SPACE
* MISCELLANEOUS CONSTANTS:
         SPACE
BLANK1   DC    C' '                TEXT OF DUMMY HEADING LINE
         LTORG
         EJECT
*******************
* WORK AREA DSECT *
*******************
         SPACE
* THIS DUMMY SECTION DEFINES THE WORK AREA PROVIDED BY THE PROBLEM
* PROGRAM FOR EACH DATA SET.  ITS ADDRESS IS PASSED IN PARAMETER
* REGISTER 0 AT EACH CALL.
         SPACE 2
WORKAREA DSECT
         SPACE 2
* STANDARD 18-WORD SAVE AREA:
         SPACE
SAVEAREA DS    18F
         SPACE 2
* DATA CONTROL BLOCK FOR PRINTER DATA SET:
         SPACE
         PRINT NOGEN
PRINTDCB DCB   DDNAME=SYSPRINT,                                        X
               DSORG=PS,                                               X
               RECFM=VBM,                                              X
               LRECL=137,                                              X
               MACRF=PL,                                               X
               BFTEK=S,                                                X
               BUFNO=2,                                                X
               EROPT=ACC
         PRINT GEN
         SPACE
DCBEXLST EQU   PRINTDCB+37         ADDRESS OF EXIT LIST
DCBOFLGS EQU   PRINTDCB+48         CONTAINS 'OPENED SUCCESSFULLY' BIT
DCBDDNAM EQU   PRINTDCB+40         DDNAME (WHEN CLOSED)
DCBSYNAD EQU   PRINTDCB+57         ADDRESS OF SYNCHRONOUS ERROR ROUTINE
DCBBLKSZ EQU   PRINTDCB+62         BLOCK SIZE
DCBLRECL EQU   PRINTDCB+82         LOGICAL RECORD LENGTH
         SPACE 2
* ADDRESS OF LAST BUFFER OBTAINED BY "PUT" MACRO:
         SPACE
CCLAST   DS    1A
         SPACE
         DS    1F                  SPARE FULL WORD
         SPACE 2
* TEMPORARY WORK CELLS:
         SPACE
DWORK    DS    1D                  DOUBLE-WORD WORK CELL
HPREXIT  DS    1F                  HEADPRNT EXIT SAVE
HPRSAVE  DS    2F                  HEADPRNT REGISTER STORAGE
         SPACE 2
* PARAMETERS AND SWITCHES WHICH DEFINE THE PAGE SIZE AND STATUS.
* SEQUENCE MUST MATCH THAT IN 'DEFAULTS', WHICH INITIALIZES THEM.
         SPACE
PAPARMS  DS    0F
HEADLIST DS    1A                  PAGE HEADING PARM LIST ADDRESS
MAXLINES DS    1F                  MAXIMUM NUMBER OF OUTPUT LINES
PAGWIDTH DS    1H                  PAGE WIDTH
PAGELNG  DS    1H                  PAGE LENGTH
PAGENO   DS    1H                  PAGE NUMBER OF CURRENT PAGE
PAGEBAL  DS    1H                  PAGE BALANCE
SWITCHES DS    1X                  SWITCHES
         SPACE 2
* STORAGE FOR DATE AND TIME PORTION OF PAGE HEADING:
         SPACE
HLTXTLNG EQU   24
HLTEXT   DS    CL(HLTXTLNG)
HLDAY    EQU   HLTEXT
HLTIME   EQU   HLTEXT+7
HLDATE   EQU   HLTEXT+16
         EJECT
*************************
* PARAMETER LIST DSECTS *
*************************
         SPACE 2
* PARAMETER LIST FOR 'EJECT' CALL:
         SPACE
EJPARM   DSECT
         SPACE
EJCOND   DS    1X                  CONDITIONAL MASK AND SWITCHES
EJQUAN   DS    1X                  CONDITIONAL TEST QUANTITY
         SPACE
EJATHOF  EQU   X'01'               MASK FOR 'EJCOND'
         SPACE 6
* PARAMETER LIST FOR 'SPACE' CALL:
         SPACE
SPPARM   DSECT
         SPACE
SPCOND   DS    1X                  CONDITIONAL BITS
SPQUAN   DS    1X                  NUMBER OF LINES TO SPACE
         SPACE
SPATHOF  EQU   X'01'               MASK FOR 'SPCOND'
SPNOEJ   EQU   X'02'               MASK FOR 'SPCOND'
         SPACE 6
* PARAMETER LIST FOR 'OPEN' AND 'MODIFY' CALLS:
         SPACE
OMPARM   DSECT
         SPACE
OMMAXLIN DS    1F                  MAXIMUM NUMBER OF OUTPUT LINES
OMPAGENO DS    1H                  INITIAL PAGE NUMBER
OMPAGWID DS    1X                  PAGE WIDTH
OMPAGLNG DS    1X                  PAGE LENGTH
OMTIMEAD DS    1A                  ADDRESS OF TIME
OMDATEAD DS    1A                  ADDRESS OF DATE
OMDDNAME DS    CL8                 DDNAME (OPEN CALL ONLY)
         EJECT
*************
* PLD DSECT *
*************
         SPACE
* PRINT LINE DESCRIPTOR DUMMY SECTION:
         SPACE 2
*        ******************************************************
*        *            *                                       *
*        *   OPTION   *                                       *
*        *    BITS    *             TEXT ADDRESS              *
*        *            *                                       *
*        ******************************************************
*        *            *            *            *             *
*        *    TEXT    *    TEXT    *   SPACE    *    SPACE    *
*        *   LENGTH   *   OFFSET   *   BEFORE   *    AFTER    *
*        *            *            *            *             *
*        ******************************************************
         SPACE 3
PLDBLOCK DSECT
         SPACE
PLDFLAGS DS    1X                  OPTION BITS
PLDTXTAD DS    AL3                 TEXT ADDRESS
PLDLNGTH DS    1X                  TEXT LENGTH
PLDOFFST DS    1X                  TEXT OFFSET, OR LEFT MARGIN
PLDSPB   DS    1X                  AMOUNT TO SPACE BEFORE PRINTING
PLDSPA   DS    1X                  AMOUNT TO SPACE AFTER PRINTING
         SPACE 2
PRHOFBIT EQU   B'00000010'         MASK FOR 'PLDFLAGS'
PRSKPBIT EQU   B'00000001'         MASK FOR 'PLDFLAGS'
SPSKPBIT EQU   B'00010000'         MASK FOR 'PLDFLAGS'
         TITLE 'DATE EDITING ROUTINE "XDATEDIT"'
* STATUS:  VERSION 0, MOD 2, 5 OCTOBER 1967.
         SPACE
* FUNCTION/OPERATION:  EDITS A PACKED DECIMAL DATE IN YEAR-DAY FORM TO
*        EBCDIC MONTH-DAY-YEAR FORM.  CORRECTS FOR LEAP YEARS AND
*        FOR THE TURN OF A CENTURY.
         SPACE
* ENTRY POINTS:  ENTER AT "XDATEDIT" VIA BALR 14,15 WITH REG 13 SET
*        TO A STANDARD 18-WORD SAVE AREA.  REGISTER 1 POINTS TO A
*        PARAMETER LIST CONTAINING ONE ADDRESS.
         SPACE
* INPUT:  THE ADDRESS IN THE PARAMETER LIST IS THAT OF AN ALIGNED
*        DOUBLE WORD CONTAINING THE ARGUMENT IN PACKED DECIMAL AS:
*        X'0000000000YYDDD+'.
         SPACE
* OUTPUT:  THE RESULT IS RETURNED IN THE SAME DOUBLE WORD IN EBCDIC AS
*        C'MM/DD/YY'.
         SPACE
* DATA SETS:  NONE.
         SPACE
* EXTERNAL ROUTINES:  NONE.
         SPACE
* EXITS-NORMAL:  RETURN VIA REG 14 WITH RETURN CODE 0 IN REG 15.
         SPACE
* EXITS-ERROR:  IF THE DAY NUMBER IS ZERO OR EXCEEDS THE MAXIMUM VALUE
*        APPROPRIATE TO THE YEAR, RETURN VIA REG 14 WITH RETURN CODE 4
*        IN REG 15 AND THE RESULT FIELD SET TO C' YY.DDD '.
         SPACE
* TABLES/WORK AREAS:  NONE.
         SPACE
* ATTRIBUTES:  REENTRANT, READ ONLY.
         SPACE
* NOTES:  NONE.
         EJECT
* DUMMY SECTION TO DEFINE THE ARGUMENT AND RETURN FIELD.
         SPACE
DUMMY    DSECT
DWORD    DS    1D
         SPACE 6
* BEGIN CONTROL SECTION HERE.  DEFINE REGISTER TAGS.
         SPACE
XDATEDIT CSECT
         SPACE
RDSECT   EQU   11                  BASE REG FOR ARGUMENT/RESULT
RPARMD   EQU   1                   PARAMETER LIST POINTER
RARGSAVE EQU   2                   TO SAVE ORIGINAL PACKED ARGUMENT
RMONTH   EQU   3
RDAY     EQU   4                   RDAY AND RYEAR ARE AN EVEN/ODD
RYEAR    EQU   5                   PAIR FOR DIVISION
RWORK    EQU   6
RLIST    EQU   7
         SPACE 6
* ENTER HERE.  SAVE GENERAL REGISTERS AND SET UP BASE REGISTERS.
         SPACE
         SAVE  (14,12),,*
         SPACE
         BALR  RBASE,0
         USING *,RBASE
         L     RDSECT,0(RPARMD)    LOAD ARGUMENT ADDRESS
         USING DWORD,RDSECT
         EJECT
* CONVERT YEAR AND DAY TO BINARY, AND SEPARATE BY DIVISION.
         SPACE
         MVI   DWORD,X'00'         CLEAR HIGH DECIMAL DIGITS
         MVC   DWORD+1(4),DWORD    IN ARG TO ZEROS
         OI    DWORD+7,X'0F'       FORCE PLUS SIGN
         L     RARGSAVE,DWORD+4    SAVE ARGUMENT FOR 'BADDATE'
         SPACE
         CVB   RYEAR,DWORD         CONVERT YYDDD TO BINARY
         SR    RDAY,RDAY           CLEAR HIGH-ORDER DIVIDEND
         D     RDAY,F1000          QUOTIENT=YEAR; REMAINDER=DAY
         SPACE
* CHECK FOR LEAP YEAR, AND LOAD RLIST WITH BASE ADDRESS OF APPROPRIATE
* LIST OF MONTH SIZES.
         SPACE
DAYOK    DS    0H
         LA    RLIST,STDLIST       POINT RLIST TO STANDARD MONTHS
         LTR   RWORK,RYEAR         LOAD BINARY YEAR NUMBER
         BZ    NOTLEAP             BR IF TURN OF CENTURY
         N     RWORK,=F'3'         TEST LOW TWO BITS
         BC    4,NOTLEAP           BR IF NON-ZERO
         LA    RLIST,LPYLIST       POINT RLIST TO LEAP-YEAR MONTHS
NOTLEAP  DS    0H
         SPACE
* TEST DAY NUMBER AGAINST ZERO AND THE UPPER LIMIT DETERMINED BY
* THE YEAR NUMBER.
         SPACE
         LTR   RDAY,RDAY           TEST FOR ZERO
         BZ    BADDATE             BR IF SO
         CH    RDAY,0(0,RLIST)     TEST FOR UPPER LIMIT
         BH    BADDATE             BR IF TOO LARGE
         SPACE
* REDUCE JULIAN DAY TO DAY-OF-MONTH, ACCUMULATING MONTH NUMBER.
         SPACE
         LA    RMONTH,1            INITIAL MONTH NUMBER
         SR    RWORK,RWORK
DAYLOOP  IC    RWORK,1(RMONTH,RLIST)  LENGTH OF MONTH INTO RWORK
         CR    RDAY,RWORK          TEST IF DAY IN THIS MONTH
         BNH   DAYDONE             BR IF DAY LESS THAN MONTH SIZE
         SR    RDAY,RWORK          REDUCE DAY BY LENGTH OF MONTH
         LA    RMONTH,1(RMONTH)    INCREMENT MONTH
         B     DAYLOOP
DAYDONE  DS    0H
         SPACE
* COMBINE MONTH, DAY, AND YEAR IN BINARY IN ONE REGISTER, MULTIPLYING
* EACH BY A FACTOR TO PLACE IT PROPERLY IN THE DECIMAL RESULT.
* THE TRICK IS THAT  1000(1000(MONTH)+DAY)+YEAR  GIVES  MM0DD0YY  WHEN
* CONVERTED TO DECIMAL.  AFTER UNPACKING, THE ZEROS ARE REPLACED BY
* SLASHES.
         SPACE
         MH    RMONTH,H1000
         AR    RMONTH,RDAY
         MH    RMONTH,H1000
         AR    RMONTH,RYEAR
         CVD   RMONTH,DWORD
         MVC   DWORD(5),DWORD+3    MOVE OVER FOR UNPACKING
         UNPK  DWORD(8),DWORD(5)   CONVERT TO ALPHA
         OI    DWORD+7,X'F0'       COVER UP SIGN
         MVI   DWORD+2,C'/'        INSERT SLASHES
         MVI   DWORD+5,C'/'
         SR    15,15               SET NORMAL RETURN CODE OF 0
         SPACE
EXITD    RETURN  (14,12),T,RC=(15)  RETURN TO CALLER
         SPACE 2
* FOR ARGUMENTS WHOSE DAY NUMBER IS ZERO OR TOO LARGE, RETURN IN
* 'DWORD' THE EDITED VALUE  C' YY.DDD ' AND SET A RETURN CODE OF 4.
         SPACE
BADDATE  ST    RARGSAVE,DWORD      RESTORE ORIGINAL PACKED ARGUMENT
         UNPK  DWORD+2(5),DWORD+1(3)  UNPACK INTO ALPHA
         MVC   DWORD+1(2),DWORD+2  SHIFT YEAR 1 LEFT
         MVI   DWORD,C' '          APPLY COSMETICS
         MVI   DWORD+3,C'.'
         MVI   DWORD+7,C' '
         LA    15,4                SET RETURN CODE
         B     EXITD
         EJECT
* LISTS OF MONTH SIZES FOR STANDARD AND LEAP YEARS:
         SPACE
         SPACE
STDLIST  DC    H'365'              DAY LIMIT FOR STANDARD YEARS
         DC    AL1(31)
         DC    AL1(28)
         DC    AL1(31)
         DC    AL1(30)
         DC    AL1(31)
         DC    AL1(30)
         DC    AL1(31)
         DC    AL1(31)
         DC    AL1(30)
         DC    AL1(31)
         DC    AL1(30)
         DC    AL1(31)
         SPACE
LPYLIST  DC    H'366'              DAY LIMIT FOR LEAP YEARS
         DC    AL1(31)
         DC    AL1(29)
         DC    AL1(31)
         DC    AL1(30)
         DC    AL1(31)
         DC    AL1(30)
         DC    AL1(31)
         DC    AL1(31)
         DC    AL1(30)
         DC    AL1(31)
         DC    AL1(30)
         DC    AL1(31)
         SPACE
F1000    DC    F'1000'
H1000    EQU   F1000+2
         LTORG
./       ADD   NAME=SASASID
DATA A;
 INFILE ASIDS;
 INPUT
 @01  ASRJOBNA       $8.
 @09  ASRTIBEG       TODSTAMP.
 @17  ASRNPG         IB2.
 @19  ASRDMN         IB1.
 @20  ASRASINR       IB2.
 @22  ASRCPUTA       IB4.
 @26  ASRDCTIA       IB4.
 @30  ASRFIXA        IB4.
 @34  ASRTRCA        IB4.
 @38  ASRFMCT        IB4.
 @42  ASRFMCTI       IB4.
 @46  ASRSMPCT       IB2.
 @48  ASRSWAP        IB2.
 @50  ASRIDLE        IB2.
 @52  ASRSWAR        IB2.
 @54  ASRUKN         IB2.
 @56  ASRSUSEN       IB2.
 @58  ASRSUCPR       IB2.
 @60  ASRSUCDV       IB2.
 @62  ASRSWAIN       IB2.
 @64  ASRSDCPR       IB2.
 @66  ASRSDCDV       IB2.
 @68  ASRSDCST       IB2.
 @70  ASRSDCJE       IB2.
 @72  ASRSDCHS       IB2.
 @74  ASRSDCEN       IB2.
      @ ;
 DATE=DATEPART(ASRTIBEG);
 IF WEEKDAY(DATE) = 1
  | WEEKDAY(DATE) = 7 THEN DELETE;
 TIME=TIMEPART(ASRTIBEG);
 USING=(ASRSUSEN*100)/ASRSMPCT;
 DELAY=(ASRSWAIN*100)/ASRSMPCT;

 IF ASRJOBNA=:'CICP'
  | ASRJOBNA='JES2'
  | ASRJOBNA='NET'
  | ASRJOBNA=:'ADAP'
 ;

PROC SORT; BY ASRJOBNA DATE;


PROC PLOT DATA=WORK.A;
 PLOT USING*TIME='U' DELAY*TIME='*' / OVERLAY VAXIS=0 TO 100 BY 10;
 BY ASRJOBNA DATE;
 FORMAT TIME TIME. ;
 FORMAT DATE DATE. ;

./       ADD   NAME=SASDEVCE
DATA A;
 INFILE DEVICES;
 INPUT
  @01      DVRVOLI        $6.
  @07      DVRMEXNR       IB2.
  @09      DVRDISIF       IB4.
  @13      DVRPETIF       IB4.
  @17      DVRCOTIF       IB4.
  @21      DVRDVBIF       IB4.
  @25      DVRCUBIF       IB4.
  @29      DVRDISIL       IB4.
  @33      DVRPETIL       IB4.
  @37      DVRCOTIL       IB4.
  @41      DVRDVBIL       IB4.
  @45      DVRCUBIL       IB4.
  @49      DVRTYP         IB4.
  @53      DVRSMPCT       IB4.
  @57      DVRHUJBN       $8.
  @65      DVRHUCNT       IB4.
  @69      DVRHWJBN       $8.
  @77      DVRHWCNT       IB4.
  @81      DVRTIBEG       TODSTAMP.
      @ ;
 DATE=DATEPART(DVRTIBEG);
 TIME=TIMEPART(DVRTIBEG);
 USING=(DVRHUCNT*100)/DVRSMPCT;
 DELAY=(DVRHWCNT*100)/DVRSMPCT;
IF DVRVOLI=:'PROD'
 | DVRVOLI=:'SUN' ;

PROC SORT; BY DVRVOLI DATE;


PROC PLOT DATA=WORK.A;
 PLOT USING*TIME='U' DELAY*TIME='*' / OVERLAY VAXIS=0 TO 100 BY 10;
 BY DVRVOLI DATE;
 FORMAT TIME TIME. ;
 FORMAT DATE DATE. ;

./       ADD   NAME=TOTIME
         TITLE ' - TIME CONVERSION SUBROUTINE.'
* ON ENTRY R0 CONTAINS THE TIME TO CONVERT,
* AND R1 THE ADDRESS OF A RESULT FIELD TO BE UPDATED.
TOTIME  $PROLOG R12
         L     R10,=V(DATASECT)
         USING DATASECT,R10
         LR    R5,R0              INPUT TIME IN 100THS SEC
         SR    R4,R4              SETUP FOR DIVIDE
         MVC   WRK11PAT,=C'HH:MM:SS.TH'  SETUP OUTPUT PATTERN
         D     R4,=F'100'         GET 100TH OF SECS
         CVD   R4,DOUBLE          PACKED DEC
         OI    DOUBLE+7,X'0F'     FOXIE SIGN
         UNPK  WRK11TH,DOUBLE+6(2) HUND OF SEC
         SR    R4,R4              SETUP FOR DIVIDE
         D     R4,=F'60'          GET SECS
         CVD   R4,DOUBLE          PACKED DEC
         OI    DOUBLE+7,X'0F'     FOXIE SIGN
         UNPK  WRK11SS,DOUBLE+6(2) SEC
         SR    R4,R4              SETUP FOR DIVIDE
         D     R4,=F'60'          GET MIN
         CVD   R4,DOUBLE          PACKED DEC
         OI    DOUBLE+7,X'0F'     FOXIE SIGN
         UNPK  WRK11MM,DOUBLE+6(2) MIN
         CVD   R5,DOUBLE          PACKED DEC
         OI    DOUBLE+7,X'0F'     FOXIE SIGN
         UNPK  WRK11HH,DOUBLE+6(2) HR
         MVC   0(11,R1),WRK11PAT  UPDATE CALLER'S RESULT FIELD.
        $EPILOG ,
         LTORG ,
         TITLE 'DATA AREAS.'
WRK11PAT DS    CL11            WORK AREA TO BUILD HH:MM:SS:TH
WRK11HH  EQU   WRK11PAT+00,2
WRK11MM  EQU   WRK11PAT+03,2
WRK11SS  EQU   WRK11PAT+06,2
WRK11TH  EQU   WRK11PAT+09,2
./       ADD   NAME=XPRCLOSE
         MACRO
&SYMBOL  XPRCLOSE  &WA
.* MACRO TO EXECUTE A CLOSE CALL TO 'XPRNTSUB'.
         CNOP  0,4
&SYMBOL  B     *+8                     BRANCH AROUND ADDRESS
         XPRINNRA  &WA,68
         MEND
./       ADD   NAME=XPRDCB
         MACRO
&SYMBOL  XPRDCB  &DDNAME=SYSPRINT,&BLKSIZE=0
         LCLC  &TAG
.* MACRO TO GENERATE A WORK AREA FOR A PRINTER DATA SET, CONTAINING
.* A SAVE AREA, THE DCB, OPEN AND CLOSE PARAMETER LISTS, AND VARIOUS
.* CELLS AND SWITCHES.
&TAG     SETC  '&SYMBOL'
         AIF   (T'&SYMBOL NE 'O').TOK  TEST IF NAME SUPPLIED
&TAG     SETC  'XPRDCB01'              SUPPLY STANDARD PRDCB NAME
.TOK     ANOP
&TAG     DS    0D                      ALIGN ON DOUBLE-WORD BOUNDARY
         DS    18F                     STANDARD SAVE AREA
         SPACE
*        DCB   DDNAME=&DDNAME,DSORG=PS,RECFM=VBM,LRECL=137,           X
*              BLKSIZE=&BLKSIZE,MACRF=PL,BFTEK=S,BUFNO=2
IHB&SYSNDX DCB DDNAME=&DDNAME,DSORG=PS,RECFM=VBM,LRECL=137,            X
               BLKSIZE=&BLKSIZE,MACRF=PL,BFTEK=S,BUFNO=2
         SPACE
* PARAMETER LISTS FOR OPEN AND CLOSE:
         SPACE
         OPEN  (IHB&SYSNDX,(OUTPUT,LEAVE)),MF=L  PARM LIST FOR OPEN
         SPACE
         CLOSE (IHB&SYSNDX,LEAVE),MF=L PARM LIST FOR CLOSE
         SPACE
* WORK CELLS AND VARIABLE STORAGE:
         SPACE
         DS    1D                      WORK CELL
         DS    3F                      WORK CELLS
         DS    1A                      PAGE HEADING PARM LIST ADDRESS
         DS    1F                      MAXIMUM NUMBER OF OUTPUT LINES
         DS    1H                      PAGE WIDTH
         DS    1H                      PAGE LENGTH
         DS    1H                      PAGE NUMBER
         DS    1H                      PAGE BALANCE
         DS    1X                      SWITCHES
         DS    CL24                    DATE & TIME FOR PAGE HEADING
         SPACE 2
         MEND
./       ADD   NAME=XPREJECT
         MACRO
&SYMBOL  XPREJECT  &WA,&COND=
.* MACRO TO EXECUTE AN EJECT CALL TO 'XPRNTSUB'.
         LCLC  &TAG,&SYM,&OPT,&R
         LCLA  &K
&SYM     SETC  '&SYMBOL'
&TAG     SETC  'IHB&SYSNDX'
         CNOP  2,4
.TST1    AIF   ('&COND' NE '').TST2
&OPT     SETC  'F000'
         AGO   .SIMPLE
.TST2    AIF   ('&COND' NE 'ATHOF').TSTC
&OPT     SETC  'F100'
.SIMPLE  ANOP
&SYM     BAL   1,&TAG.L                LOAD PARM ADDRESS
         DC    XL2'&OPT'               OPTION BITS
         AGO   .VCON
.TSTC    AIF   ('&COND(1)' NE 'EQ').NE
&OPT     SETC  '80'
.NE      AIF   ('&COND(1)' NE 'NE').LT
&OPT     SETC  '70'
.LT      AIF   ('&COND(1)' NE 'LT').GT
&OPT     SETC  '40'
.GT      AIF   ('&COND(1)' NE 'GT').LE
&OPT     SETC  '20'
.LE      AIF   ('&COND(1)' NE 'LE').GE
&OPT     SETC  'C0'
.GE      AIF   ('&COND(1)' NE 'GE').NOT
&OPT     SETC  'A0'
.NOT     AIF   ('&OPT' NE '').COK
         MNOTE 4,'COND OPERAND &COND(1) ILLEGAL'
.COK     AIF   ('&COND(2)' NE '').C2OK
         MNOTE 4,'COND TEST QUANTITY MISSING'
         AGO   .NOTREG
.C2OK    AIF   ('&COND(2)'(1,1) NE '(').NOTREG
&K       SETA  K'&COND(2)-2
&R       SETC  '&COND(2)'(2,&K)
&SYM     STC   &R,&TAG.A               STORE INTO PARM LIST
&SYM     SETC  ''
.NOTREG  ANOP
&SYM     BAL   1,&TAG.L                LOAD PARM ADDRESS
         DC    XL1'&OPT'               CONDITION MASK
         AIF   ('&COND(2)' EQ '').NOTREG2
         AIF   ('&COND(2)'(1,1) NE '(').NOTREG2
&TAG.A   DC    AL1(0)                  TEST QUANTITY
         AGO   .VCON
.NOTREG2 DC    AL1(&COND(2))           TEST QUANTITY
.VCON    ANOP
&TAG.L   XPRINNRA  &WA,92
         MEND
./       ADD   NAME=XPRHEAD
         MACRO
&SYMBOL  XPRHEAD  &WA,&LIST=
.* MACRO TO PRESENT A LIST OF PRINT LINE DESCRIPTORS FOR PAGE HEADINGS
.* TO 'XPRNTSUB'.
&SYMBOL  XPRLIST  &WA,LIST=&LIST,IHBPARM=80
         MEND
./       ADD   NAME=XPRINNRA
         MACRO
&TAG     XPRINNRA  &WA,&IHBPARM
.* INNER MACRO USED IN CALLS TO 'XPRNTSUB'
         DC    V(XPRNTSUB)             PRINTING SUBROUTINE ADDRESS
&TAG     L     15,*-4                  LOAD ENTRY POINT
         AIF   ('&WA' NE '').WOK
         LA    0,XPRDCB01              LOAD STANDARD WORK AREA ADDRESS
         AGO   .BAL
.WOK     AIF   ('&WA' EQ '(0)').BAL
         AIF   ('&WA'(1,1) EQ '(').REG
         LA    0,&WA                   LOAD WORK AREA ADDRESS
         AGO   .BAL
.REG     LR    0,&WA(1)                LOAD WORK AREA ADDRESS
.BAL     BAL   14,&IHBPARM.(15)        CALL PRINT SUBROUTINE
         MEND
./       ADD   NAME=XPRLDEF
         MACRO
&SYMBOL  XPRLDEF  &TEXT=,&LENGTH=132,&OFFSET=0,&SPA=1,&SPB=0
.* MACRO TO DEFINE PRINT LINE DESCRIPTOR BLOCKS ("PLD" BLOCKS) FOR
.* THE PRINTING SUBROUTINE "XPRNTSUB".
         LCLA  &N
         LCLC  &B3,&B6,&B7
         ACTR  25                      JUST IN CASE
&B3      SETC  '0'
&B6      SETC  '0'
&B7      SETC  '0'
.* PROCESS OPTIONS IN SPA OPERAND:
.TSTA1   AIF   ('&SPA(2)' EQ '').TSTB1
         AIF   ('&SPA(2)' NE 'NOEJ').TSTA2
&B3      SETC  '1'
         AGO   .TSTB1
.TSTA2   MNOTE 4,'OPERAND &SPA(2) AFTER KEYWORD SPA IS ILLEGAL'
.* PROCESS OPTIONS IN SPB OPERAND:
.TSTB1   ANOP
&N       SETA  2
.TSTB5   AIF   ('&SPB(&N)' NE 'NOEJ').TSTB2
&B7      SETC  '1'
         AGO   .TSTB4
.TSTB2   AIF   ('&SPB(&N)' NE 'ATHOF').TSTB3
&B6      SETC  '1'
         AGO   .TSTB4
.TSTB3   AIF   ('&SPB(&N)' EQ '').TSTB4
         MNOTE 4,'OPERAND &SPB(&N) AFTER KEYWORD SPB IS ILLEGAL'
.TSTB4   ANOP
&N       SETA  &N+1
         AIF   (&N LE 3).TSTB5
.IFTEXT  AIF   ('&TEXT' NE '').TOK
         MNOTE 4,'TEXT ADDRESS MISSING'
.TOK     ANOP
&SYMBOL  DS    0F                      ALIGN ON FULL-WORD BOUNDARY
         DC    BL1'000&B3.00&B6&B7'    OPTION BITS
         DC    AL3(&TEXT)              TEXT ADDRESS
         DC    AL1(&LENGTH)            TEXT LENGTH
         DC    AL1(&OFFSET)            MARGIN OFFSET
.TESTB   AIF   ('&SPB(1)' EQ 'EJECT').BSKIP
         AIF   ('&SPB(1)' EQ 'SKIP').BSKIP
         DC    AL1(&SPB(1))            PRE-SPACING
         AGO   .TESTA
.BSKIP   ANOP
         DC    AL1(255)                EJECT BEFORE PRINTING
.TESTA   AIF   ('&SPA(1)' EQ 'EJECT').ASKIP
         AIF   ('&SPA(1)' EQ 'SKIP').ASKIP
         DC    AL1(&SPA(1))                 POST-SPACING
         MEXIT
.ASKIP   ANOP
         DC    AL1(255)                EJECT AFTER PRINTING
         MEND
./       ADD   NAME=XPRLIST
         MACRO
&SYMBOL  XPRLIST  &WA,&LIST=,&IHBPARM=32
.* MACRO TO DELIVER A LIST OF PRINT LINE DESCRIPTORS TO 'XPRNTSUB'.
         LCLA  &N,&K,&D
         LCLC  &TAG,&SYM,&R
         ACTR  100
&SYM     SETC  '&SYMBOL'
&TAG     SETC  'IHB&SYSNDX'
         AIF   ('&LIST' NE '').LOK
         MNOTE 8,'LIST OPERAND MUST BE SUPPLIED'
         MEXIT
.LOK     CNOP  0,4
         AIF   ('&LIST' NE '(1)').STLOOP
&SYMBOL  B     &TAG.L                  BRANCH AROUND ADDRESS
         AGO   .VCON
.STLOOP  ANOP
&N       SETA  &N+1
         AIF   (&N GT N'&LIST).STDONE
         AIF   ('&LIST(&N)'(1,1) NE '(').STLOOP
&K       SETA  K'&LIST(&N)-2
&R       SETC  '&LIST(&N)'(2,&K)
&D       SETA  4*(&N-1)
&SYM     ST    &R,&TAG.A+&D            STORE INTO PARM LIST
&SYM     SETC  ''
         AIF   (&N NE N'&LIST).STLOOP
         OI    &TAG.A+&D,X'80'         SET END-OF-LIST BIT
.STDONE  ANOP
&SYM     BAL   1,&TAG.L                LOAD PARM LIST ADDRESS
&SYM     SETC  '&TAG.A'
&N       SETA  0
.LOOP    ANOP
&N       SETA  &N+1
         AIF   (&N GT N'&LIST).VCON
         AIF   ('&LIST(&N)'(1,1) NE '(').NOTREG
&SYM     DC    A(0)
&SYM     SETC  ''
         AGO   .LOOP
.NOTREG  AIF   (&N EQ N'&LIST).LAST
&SYM     DC    A(&LIST(&N))
&SYM     SETC  ''
         AGO   .LOOP
.LAST    ANOP
&SYM     DC    X'80'                   END-OF-LIST BIT
         DC    AL3(&LIST(&N))
.VCON    ANOP
&TAG.L   XPRINNRA  &WA,&IHBPARM
         MEND
./       ADD   NAME=XPRMOD
         MACRO
&SYMBOL  XPRMOD  &WA,&MAXLINE=0,&PAGENO=0,&PAGEWID=0,&PAGELEN=0,       X
               &TIME=0,&DATE=0
.* MACRO TO EXECUTE A MODIFY CALL TO 'XPRINTSUB'.
&SYMBOL  XPROPEN  &WA,MAXLINE=&MAXLINE,PAGENO=&PAGENO,PAGEWID=&PAGEWID,X
               PAGELEN=&PAGELEN,TIME=&TIME,DATE=&DATE,IHBPARM=104
         MEND
./       ADD   NAME=XPRNTLIN
         MACRO
&SYMBOL  XPRNTLIN  &WA,&TEXT=00,&LENGTH=132,&OFFSET=0,&SPB=0,&SPA=1
         LCLA  &N
         LCLC  &B3,&B6,&B7,&T,&R
         ACTR  25
&T       SETC  'IHB&SYSNDX'
&B3      SETC  '0'
&B6      SETC  '0'
&B7      SETC  '0'
.* PROCESS OPTIONS IN SPA OPERAND:
.TSTA1   AIF   ('&SPA(2)' EQ '').TSTB1
         AIF   ('&SPA(2)' NE 'NOEJ').TSTA2
&B3      SETC  '1'
         AGO   .TSTB1
.TSTA2   MNOTE 4,'OPERAND &SPA(2) AFTER KEYWORD SPA IS ILLEGAL'
.* PROCESS OPTIONS IN SPB OPERAND:
.TSTB1   ANOP
&N       SETA  2
.TSTB5   AIF   ('&SPB(&N)' NE 'NOEJ').TSTB2
&B7      SETC  '1'
         AGO   .TSTB4
.TSTB2   AIF   ('&SPB(&N)' NE 'ATHOF').TSTB3
&B6      SETC  '1'
         AGO   .TSTB4
.TSTB3   AIF   ('&SPB(&N)' EQ '').TSTB4
         MNOTE 4,'OPERAND &SPB(&N) AFTER KEYWORD SPB IS ILLEGAL'
.TSTB4   ANOP
&N       SETA  &N+1
         AIF   (&N LE 3).TSTB5
.* GENERATE STORE INSTRUCTIONS IF REGISTER NOTATION IS USED:
         CNOP  0,4
         AIF   ('&SYMBOL' EQ '').IFR1
&SYMBOL  DS    0H
.IFR1    AIF   ('&TEXT' NE '00').TXTOK
         MNOTE 4,'TEXT ADDRESS MUST BE SUPPLIED'
.TXTOK   AIF   ('&TEXT'(1,1) NE '(').IFR2
         ST    &TEXT(1),&T.A           STORE TEXT ADDRESS
         MVI   &T.A,B'000&B3.00&B6&B7' INSERT OPTION BITS
.IFR2    AIF   ('&LENGTH'(1,1) NE '(').IFR3
         STC   &LENGTH(1),&T.A+4       STORE TEXT LENGTH
.IFR3    AIF   ('&OFFSET'(1,1) NE '(').IFR4
         STC   &OFFSET(1),&T.A+5       STORE MARGIN OFFSET
.IFR4    AIF   ('&SPB(1)'(1,1) NE '(').IFR5
&N       SETA  K'&SPB(1)-2
&R       SETC  '&SPB(1)'(2,&N)
         STC   &R,&T.A+6               STORE PRE-SPACING
.IFR5    AIF   ('&SPA(1)'(1,1) NE '(').LOAD1
&N       SETA  K'&SPA(1)-2
&R       SETC  '&SPA(1)'(2,&N)
         STC   &R,&T.A+7               STORE POST-SPACING
.* LOAD REG 1 AND GENERATE PLD LIST ADDRESS:
.LOAD1   BAL   1,&T.L                  LOAD PARM ADDRESS
         DC    X'80'                   MARK END OF ADDRESS LIST
         DC    AL3(&T.A)               ADDRESS OF PLD
.* GENREATE PLD PARAMETERS TO DESCRIBE THE PRINT LINE:
.IFR11   AIF   ('&TEXT'(1,1) NE '(').NOTR11
&T.A     DC    A(0)                    TEXT ADDRESS & OPTION BITS
         AGO   .IFR12
.NOTR11  ANOP
&T.A     DC    B'000&B3.00&B6&B7'      OPTION BITS
         DC    AL3(&TEXT)              TEXT ADDRESS
.IFR12   AIF   ('&LENGTH'(1,1) NE '(').NOTR12
         DC    AL1(0)                  TEXT LENGTH
         AGO   .IFR13
.NOTR12  DC    AL1(&LENGTH)            TEXT LENGTH
.IFR13   AIF   ('&OFFSET'(1,1) NE '(').NOTR13
         DC    AL1(0)                  MARGIN OFFSET
         AGO   .IFR14
.NOTR13  DC    AL1(&OFFSET)            MARGIN OFFSET
.IFR14   AIF   ('&SPB(1)'(1,1) NE '(').NOTR14
         DC    AL1(0)                  PRE-SPACING
         AGO   .IFR15
.NOTR14  AIF   ('&SPB(1)' EQ 'EJECT').BSKIP
         AIF   ('&SPB(1)' EQ 'SKIP').BSKIP
         DC    AL1(&SPB(1))            PRE-SPACING
         AGO   .IFR15
.BSKIP   DC    AL1(255)                SKIP BEFOR PRINTING
.IFR15   AIF   ('&SPA(1)'(1,1) NE '(').NOTR15
         DC    AL1(0)                  POST-SPACING
         AGO   .VCON
.NOTR15  AIF   ('&SPA(1)' EQ 'EJECT').ASKIP
         AIF   ('&SPA(1)' EQ 'SKIP').ASKIP
         DC    AL1(&SPA(1))            POST-SPACING
         AGO   .VCON
.ASKIP   DC    AL1(255)                SKIP AFTER PRINTING
.VCON    ANOP
&T.L    XPRINNRA  &WA,32
         MEND
./       ADD   NAME=XPROPEN
         MACRO
&SYMBOL  XPROPEN  &WA,&MAXLINE=0,&PAGENO=0,&PAGEWID=0,&PAGELEN=0,      X
               &TIME=0,&DATE=0,&DDNAME=SYSPRINT,&IHBPARM=56
.* MACRO TO EXECUTE AN 'OPEN' OR 'MODIFY' CALL TO 'XPRNTSUB'.
         LCLC  &TAG
&TAG     SETC  'IHB&SYSNDX'
         AIF   ('&SYMBOL' EQ '').T1
&SYMBOL  DS    0H
.T1      AIF   ('&MAXLINE'(1,1) NE '(').T2
         ST    &MAXLINE(1),&TAG.A      STORE IN PARM LIST
.T2      AIF   ('&PAGENO'(1,1) NE '(').T3
         STH   &PAGENO(1),&TAG.A+4     STORE IN PARM LIST
.T3      AIF   ('&PAGEWID'(1,1) NE '(').T4
         STC   &PAGEWID(1),&TAG.A+6    STORE IN PARM LIST
.T4      AIF   ('&PAGELEN'(1,1) NE '(').T5
         STC   &PAGELEN(1),&TAG.A+7    STORE IN PARM LIST
.T5      AIF   ('&TIME'(1,1) NE '(').T6
         ST    &TIME(1),&TAG.A+8       STORE IN PARM LIST
.T6      AIF   ('&DATE'(1,1) NE '(').T7
         ST    &DATE(1),&TAG.A+12      STORE IN PARM LIST
.T7      AIF   ('&DDNAME'(1,1) NE '(').CNOP
         MVC   &TAG.A+16(8),0(&DDNAME(1))  STORE IN PARM LIST
.CNOP    CNOP  0,4
         BAL   1,&TAG.L        LOAD PARM LIST ADDRESS
.P1      AIF   ('&MAXLINE'(1,1) EQ '(').PR1
&TAG.A   DC    A(&MAXLINE)             PRINT OUTPUT LIMIT
         AGO   .P2
.PR1     ANOP
&TAG.A   DC    A(0)                    PRINT OUTPUT LIMIT
.P2      AIF   ('&PAGENO'(1,1) EQ '(').PR2
         DC    AL2(&PAGENO)            PAGE NUMBER
         AGO   .P3
.PR2     DC    AL2(0)                  PAGE NUMBER
.P3      AIF   ('&PAGEWID'(1,1) EQ '(').PR3
         DC    AL1(&PAGEWID)           PAGE WIDTH
         AGO   .P4
.PR3     DC    AL1(0)                  PAGE WIDTH
.P4      AIF   ('&PAGELEN'(1,1) EQ '(').PR4
         DC    AL1(&PAGELEN)           PAGE LENGTH
         AGO   .P5
.PR4     DC    AL1(0)                  PAGE LENGTH
.P5      AIF   ('&TIME'(1,1) EQ '(').PR5
         DC    A(&TIME)                ADDRESS OF TIME
         AGO   .P6
.PR5     DC    A(0)                    ADDRESS OF TIME
.P6      AIF   ('&DATE'(1,1) EQ '(').PR6
         DC    A(&DATE)                ADDRESS OF DATE
         AGO   .P7
.PR6     DC    A(0)                    ADDRESS OF DATE
.P7      AIF   ('&IHBPARM' NE '56').VCON
         AIF   ('&DDNAME'(1,1) EQ '(').PR7
         DC    CL8'&DDNAME'            DDNAME FOR DATA SET
         AGO   .VCON
.PR7     DC    CL8' '                  DDNAME FOR DATA SET
.VCON    ANOP
&TAG.L   XPRINNRA  &WA,&IHBPARM
         MEND
./       ADD   NAME=XPRSPACE
         MACRO
&SYMBOL  XPRSPACE  &WA,&LINES=1,&COND=
.* MACRO TO EXECUTE A SPACE CALL TO 'XPRNTSUB'.
         LCLA  &N,&B6,&B7
         LCLC  &TAG,&SYM
&SYM     SETC  '&SYMBOL'
&TAG     SETC  'IHB&SYSNDX'
.LOOP    ANOP
&N       SETA  &N+1
         AIF   (&N GT N'&COND).LDONE
.TST1    AIF   ('&COND(&N)' NE 'NOEJ').TST2
&B6      SETA  1
         AGO   .LOOP
.TST2    AIF   ('&COND(&N)' NE 'ATHOF').TST3
&B7      SETA  1
         AGO   .LOOP
.TST3    MNOTE 4,'OPERAND &COND(&N) AFTER KEYWORD COND IS ILLEGAL'
         AGO   .LOOP
.LDONE   CNOP  2,4
         AIF   ('&LINES'(1,1) NE '(').NOTREG1
&SYM     STC   &LINES(1),&TAG.A+1      STORE INTO PARM LIST
&SYM     SETC  ''
.NOTREG1 ANOP
&SYM     BAL   1,&TAG.L                LOAD PARM LIST ADDRESS
&TAG.A   DC    B'000000&B6&B7'         OPTION BITS
         AIF   ('&LINES'(1,1) NE '(').NOTREG2
         DC    X'00'                   SPACING AMOUNT
         AGO   .VCON
.NOTREG2 DC    AL1(&LINES)             SPACING AMOUNT
.VCON    ANOP
&TAG.L   XPRINNRA  &WA,44
         MEND
