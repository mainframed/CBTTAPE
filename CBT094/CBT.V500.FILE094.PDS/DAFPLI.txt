./ ADD NAME=$CMP     0100-97322-97322-1519-00020-00020-00000-OLDDAF
//ZT12$CMP JOB (SZ0000),'DAF_Compile',CLASS=B,MSGCLASS=X,NOTIFY=ZT12
//********************************************************************
//*            Dataset Audit Facility (DAF) - Version 1.3           **
//*            (c) Copyright Cleary Consulting 1988, 1989           **
//*                       All Rights Reserved                       **
//********************************************************************
//IEL0AA  EXEC PGM=IEL0AA,PARM='OPTIMIZE(2),XREF(FULL)'
//STEPLIB   DD DSN=SYS1.PLI.PLICOMP,DISP=SHR
//SYSIN     DD DSN=ZTGP01.DAF.V13.INSTALL($SRC),DISP=SHR
//SYSLIN    DD DSN=&&OBJ,DISP=(NEW,PASS),UNIT=VIO,SPACE=(80,(250,100))
//SYSPRINT  DD SYSOUT=*
//SYSUT1    DD UNIT=SYSDA,SPACE=(1024,(200,50)),DCB=BLKSIZE=1024
//IEWL    EXEC PGM=IEWL,PARM='LIST,MAP'
//SYSUT1    DD UNIT=SYSDA,SPACE=(1700,(400,50))
//SYSPRINT  DD SYSOUT=*
//SYSLIN    DD DSN=&&OBJ,DISP=(OLD,DELETE)
//          DD *
  NAME DAF(R)
//SYSLIB    DD DSN=SYS1.PLI.PLIBASE,DISP=SHR
//SYSLMOD   DD DSN=ZTGP01.DAF.V13.LINKLIB,DISP=SHR
./ ADD NAME=$DOC     0100-97322-97322-1519-00635-00635-00000-OLDDAF
1














                   Dataset Audit Facility (DAF) - Version 1.3
                   (c) Copyright Cleary Consulting 1988, 1989
                              All Rights Reserved


















                          Cleary Consulting
                          9254 Flax Place
                          Riverside, California  92503
                          (714) 688-4411
1


                      T A B L E    O F    C O N T E N T S


     Disclaimer .....................................................  1

     Introduction ...................................................  2

     Overview of Processing .........................................  3

     Installation ...................................................  4

     Software Considerations ........................................  5

     Control Statements - Syntax ....................................  6

     Control Statements - Examples ..................................  7

     Execution ......................................................  8

     Error Conditions ...............................................  9

     SHARE Requirements ............................................. 10

     References ..................................................... 11

     Modification History ........................................... 12

     Statement of Direction ......................................... 13
1                                                                Page  1


                              D I S C L A I M E R


     Permission is hereby granted to copy, redistribute and use DAF
     if the following conditions are met:
         1)  The copyright notice remains intact.
         2)  NO profit is made beyond a nominal charge for material
             and handling.
         3)  NO modifications are made.

     DAF is distributed on an ASIS basis.

     DAF has been found useful and it appears to perform its
     documented function.

     NO warranty, either expressed or implied, is made as to the
     fitness or appropriateness of DAF for any purpose whatsoever.

     NO responsibility is assumed by either the author or the
     copyright holder for the effect of any use or lack of use of DAF.

     NO guarantee is made that DAF will be kept current or that user
     suggestions will be implemented.

     NO assurance is made that the installation or execution of DAF
     will not create an integrity exposure, although DAF is intended
     to execute unauthorized.

     It is the sole responsibility of the user to evaluate the
     usefulness of DAF in any given environment.
1                                                                Page  2


                            I N T R O D U C T I O N


     IBM has been kind enough to create dataset related information in
     SMF, but neglected to provide a facility for sifting through the
     large amount of data to get specific information about a
     particular dataset access.  Over the years, I have made many
     desperate attempts to attack this mountain of SMF data, each more
     sophisticated than its predecessor.  My varied attempts have
     evolved into DAF.

     DAF is a batch PL/1 utility program that understands 17 different
     types of SMF records and generates many reports dealing with
     dataset activity.

     DAF can be a useful tool for people in many varied areas of
     responsibility.  Positions that could benefit from DAF include:

         Application Programmers
         Auditors
         Capacity Planners
         DASD Managers
         End Users
         Help Desk
         Operations Analysts
         Performance Tuners
         Security Officers
         System Programmers

     Problems or suggestions can be communicated via a Reader Comment
     Form (Member $RCF of the INSTALL dataset).

     Special Thanks to:

         Frank Bolan for navigating me through the PL/1 hurricane.
         Gary Davis for being reasonable.
         David Wolfskill for performing reality checks.

         And, of course, IBM for hiding all this information in SMF.

     I would like to add support for SMF Record Type 59, which is cut
     by BDT, but our system does not have BDT.  If someone would be so
     kind as to give me a call and send me some SMF data from BDT, I
     will add the code to DAF so it will process the BDT SMF data.

1                                                                Page  3


                 O V E R V I E W    O F    P R O C E S S I N G


     DAF determines the selection criteria for the SMF data from
     control statements encountered in the DAFIN DD statement.

     DAF reads the SMF data from the DAFSMF DD statement, and processes
     only the data that matches the selection criteria.

     DAF can create four application SYSOUT datasets:

         DAFLOG  - Images of the DAFIN Control Statements.
                 - Invalid DAFIN Control Statements (Flagged).
                 - Selection Criteria.
                 - Error messages.

         DAFRPT  - Detailed dataset information sorted on
                   ascending DSN (Primary) and ascending Date/Time
                   (Secondary).
                 - DSN,Date/Time,CPU,Jobname,SMF Record Type and
                   Volume Serial (If Available) are present for every
                   record.
                 - The amount and type of information provided is
                   based on the data present in that particular SMF
                   Record Type.  The labels used on the report are
                   usually the suffix of the actual SMF field names.
                   For example, SMF14NEX becomes NEX=.  Further
                   information can be obtained from the manuals listed
                   in the "References" section of this document.

         DAFSTAT - Statistics by SMF Record Type and SMF Functional Area.
                 - DAFSMF Date/Time Range.

         DAFXCLD - Excludes dataset information sorted on ascending DSN.
                 - DSN and Occurrences.
1                                                                Page  4


                            I N S T A L L A T I O N


     DAF is distributed on a tape with a Volume Serial of DAF13 which
     contains the following IEBCOPY unloaded files:

         1.  DAF.V13.INSTALL DSORG=PO  RECFM=FB  LRECL=80  BLKSIZE=15440
             $CMP - PL/1 Compile/Link JCL
             $DOC - Documentation (Contains ASA Control Characters)
             $EXE - Execution JCL
             $IVP - Installation Verification Program
             $PRT - Print JCL
             $RCF - Reader Comment Form
             $SRC - PL/1 Source

     The following steps should be followed to install DAF:

         1.  Unload tape (BLKSIZE and MAXBLK are only needed if you
             desire to change the blocksizes).

             //IEBCOPY EXEC PGM=IEBCOPY
             //SYSPRINT  DD SYSOUT=*
             //INSTI     DD DSN=DAF.V13.INSTALL,DISP=SHR,UNIT=3480,
             //             VOL=SER=DAF13,LABEL=(1,SL,EXPDT=98000)
             //INSTO     DD DSN=ZT12.DAF.V13.INSTALL,DISP=(NEW,CATLG),
             //             DCB=BLKSIZE=3120,UNIT=SYSDA,VOL=SER=VVVVVV,
             //             SPACE=(CYL,(1,1,16),RLSE)
             //SYSIN     DD *
              COPY    O=INSTO,I=((INSTI,R))

         2.  Compile.

         3.  Ensure SMF Records 14, 15, 17, 18, 36, 60-69, 77 and 80
             are being collected.

         4.  Ensure SMF data is being dumped / cleared with an IFASMFDP
             like product.

         5.  The frequency that SMF Record Type 77 is generated
             depends on the RMF reporting interval.  To allow DAF to
             provide better granularity in the area of enqueue
             activity, it is recommended that this interval be set to
             15 minutes.  This can be accomplished by specifying the
             parameter INTERVAL(15M) at RMF initialization.  The impact
             of this change on the overall space requirements of the
             SMF data has been minimal.
1                                                                Page  5


                 S O F T W A R E    C O N S I D E R A T I O N S


     The following IBM APARS should be reviewed:

         APAR        - OY06621
         Title       - SMF Type 41 Record Incomplete
         Description - SMF Type 41 Records do not contain the name of
                       the job that does the access or unaccess of the
                       DIV object.
         Fix         - PTF UY22185 on PUT8806 (JBB2220)

         APAR        - OY06875
         Title       - SMF Type 36 Record Incomplete
         Description - SMF Type 36 Records do not contain several of
                       their documented fields.
         Fix         - PTF UY10694 on PUT8706 (HDP2230)

         APAR        - OY10596
         Title       - SMF Type 64 Record Documentation Misleading
         Description - SMF Type 64 Record documentation implies that the
                       EXCP statistics are kept on a per job basis. The
                       statistics are data set orientated and do not
                       necessarily reflect the individual job.
         Fix         - Publication Change

         APAR        - OY11725
         Title       - SMF Type 60,61,65 and 66 Records Incomplete
         Description - SMF Type 60,61,65 and 66 Records do not always
                       contain a valid subfunction.
         Fix         - PTF UY17981 on PUT8803 (HDP2230)

         APAR        - OY14846
         Title       - SMF Type 64 Record Incomplete
         Description - SMF Type 64 Records do not always contain a
                       cluster component name (SMF64DNM)
         Fix         - Unknown

     The following can indirectly use DAF:

         Fast Dump and Restore (FDR) can be installed to perform
         RACHECKs on datasets prior to backups and restores.

         Sysout Archival and Retrieval (SAR) can be installed to
         perform RACHECKs on SYSOUT as datasets.

         Non-dataset enqueue contention:

             Minor       Major       Product
             --------    --------    -------
             CMTDIR      UCC11CMT    CA-11
             RECORDER    SYSZLOGR    Logrec
             STCQUE      SYSIEFSD    MVS
             SYSVTOC     XXXXXX      MVS
             UCCONEQN    TMS-AUD     CA-1
             UCCONEQN    TMS-TMC     CA-1
             ZZZZZZ      SYSZVOLS    MVS
1                                                                Page  6


            C O N T R O L    S T A T E M E N T S    -    S Y N T A X


     Control statements are used to determine the selection criteria.

     Control statements may begin in any column.
     Control statements must begin and end on the same card image.
     Only one control statement is allowed per card image.

     Date Criteria:

         BEG=YYDDD  (Defaults to a BEGin date of 00000)
         END=YYDDD  (Defaults to an END date of 99366)

     Include Criteria:

         CPU=       (Defaults to All CPUs)
         DDN=       (Defaults to All DDNames)
         DSN=       (Defaults to All DSNames)
         FUN=       (Defaults to All FUNctions)
         JOB=       (Defaults to All JOBs)
         VOL=       (Defaults to All VOLumes)

     Exclude Criteria:

         XCPU=       (Defaults to not excluding CPUs)
         XDDN=       (Defaults to not excluding DDNames)
         XDSN=       (Defaults to not excluding DSNames)
         XFUN=       (Defaults to not excluding FUNctions)
         XJOB=       (Defaults to not excluding JOBs)
         XVOL=       (Defaults to not excluding VOLumes)

     NOTE:

         Control statements are processed according to the following
             hiearchy:  Date, Include, Exclude.
         BEG/END can be specified an unlimited number of times but
             only the last value is used
         BEG/END ***MUST*** be fully qualified (5 bytes)
         CPU/DDN/DSN/JOB/VOL/XCPU/XDDN/XDSN/XJOB/XVOL can be specified
             0 to 64 times each
         CPU/XCPU can be partially or fully qualified (1 to 4 bytes)
         DDN/JOB/XDDN/XJOB can be partially or fully qualified
             (1 to 8 bytes)
         DSN/XDSN can be partially or fully qualified (1 to 44 bytes)
         FUN/XFUN can be specified an unlimited number of times
         FUN/XFUN can contain an unlimited number of valid operands
         which are listed below:
             C - Catalog Function
             D - Dataset Function
             E - Enqueue Function
             R - RACF Function
         VOL/XVOL can be partially or fully qualified (1 to 6 bytes)
1                                                                Page  7


          C O N T R O L    S T A T E M E N T S    -    E X A M P L E S


     By default, DAF is a tree killer.  The art of using DAF
     sucessfully is the ability to only select what you need.  This
     can be accomplished:

         1.  Implicitly by using only the SMF data you need
             (hourly,daily,weekly or monthly)

         2.  Explicitly by specifing control statements to limit
             the selection criteria.

     DAF can provide detailed information about dataset creation,
     access, rename and deletion:

         How many EXCPs?
         What CPU?  DDName?  DSName?  Job?  Member?  Time?  Volume?

     DAF can answer many general questions:

         Was a dataset used on a certain day?
             DSN=PROD.NEEDED.LIBRARY
             BEG=890005
             END=890005

         What RACF profile was used to access a dataset?
             DSN=PROD.NEEDED.LIBRARY
             FUN=R

         When did a dataset go into multiple extents?
         When did the blocksize of a dataset change?
             DSN=PROD.NEEDED.LIBRARY
             FUN=D

         What CPU did a Job run on?
         What datasets did an job use?
         What volumes did an application use?
             JOB=JJJJ

         Who accessed the system volumes (Excluding the Work Packs) ?
             VOL=S
             XVOL=SWS

         What jobs used STEPLIB?
             DDN=STEPLIB

         Am I backing up all the datasets used by an application
         (Knowing that PROD,SYS1 and UCC11 datasets are already being
          backed up)?
             JOB=JJJJ
             XDSN=PROD
             XDSN=SYS1
             XDSN=UCC11
1                                                                Page  8


                               E X E C U T I O N


     The following steps should be followed to execute DAF:

         1.  Edit the execute JCL (Member $EXE of the INSTALL dataset)
             which should basically resemble the sample below:

             //DAF     EXEC PGM=DAF
             //STEPLIB   DD DSN=ZTGP01.DAF.V13.LINKLIB,DISP=SHR
             //DAFIN     DD *
             DSN=SYS2
             //DAFLOG    DD SYSOUT=*
             //DAFRPT    DD SYSOUT=*
             //DAFSMF    DD DSN=DCTR.SMFDUMP.DAILY.BBC1(+0),DISP=SHR
             //DAFSTAT   DD SYSOUT=*
             //DAFXCLD   DD SYSOUT=*
             //DAF1IN    DD DSN=&&DAF1IN,UNIT=3380,SPACE=(CYL,(100)),
             //             DCB=(RECFM=FB,LRECL=439,BLKSIZE=23706)
             //DAF1OUT   DD DSN=&&DAF1OUT,UNIT=3380,SPACE=(CYL,(100)),
             //             DCB=(RECFM=FB,LRECL=439,BLKSIZE=23706)
             //DAF1WK01  DD DSN=&&DAF1WK01,UNIT=3380,SPACE=(CYL,(50))
             //DAF1WK02  DD DSN=&&DAF1WK02,UNIT=3380,SPACE=(CYL,(50))
             //DAF1WK03  DD DSN=&&DAF1WK03,UNIT=3380,SPACE=(CYL,(50))
             //DAF2IN    DD DSN=&&DAF2IN,UNIT=3380,SPACE=(CYL,(100)),
             //             DCB=(RECFM=FB,LRECL=044,BLKSIZE=23716)
             //DAF2OUT   DD DSN=&&DAF2OUT,UNIT=3380,SPACE=(CYL,(100)),
             //             DCB=(RECFM=FB,LRECL=044,BLKSIZE=23716)
             //DAF2WK01  DD DSN=&&DAF2WK01,UNIT=3380,SPACE=(CYL,(50)),
             //DAF2WK02  DD DSN=&&DAF2WK02,UNIT=3380,SPACE=(CYL,(50)),
             //DAF2WK03  DD DSN=&&DAF2WK03,UNIT=3380,SPACE=(CYL,(50)),
             //SRTMSG    DD SYSOUT=*

         2.  Determine which SMF Data to use.

         3.  Determine which control statements to use.

         4.  Submit.

         5.  Review SYSOUT.

         6.  Repeat steps 1 through 5 until satisfied.
1                                                                Page  9


                        E R R O R    C O N D I T I O N S


     DAF can detect and identify the following error conditions:

     Return Code ---- 1001
     Error ---------- No DAFSMF Records Selected
     Response ------- Modify DAFIN Control Statement(s) and Resubmit
                                   And/Or
                      Utilize Different DAFSMF Dataset(s) and Resubmit

     Return Code ---- 1002
     Error ---------- Invalid DAFIN Control Statement(s)
     Response ------- Modify DAFIN Control Statement(s) and Resubmit

     Return Code ---- 1003
     Error ---------- Sort Problem
     Response ------- Resolve Sort Problem and Resubmit
1                                                                Page 10


                      S H A R E    R E Q U I R E M E N T S


     Requirement:
       SOMVSE89005

     Title:
       Add Object DSN to DIV SMF Record

     Statement:
       The Data in Virtual SMF record type 41 does not contain the
       object dataset name.

     Justification:
       The object dataset name is required by users to support the
       following activities.

         1) Audit Trail
         2) Billing
         3) Capacity Planning
         4) Performance Tuning

       JOBNAME and DDNAME are the only identification fields contained
       in the existing record.  These names are variable in nature
       (subject to the whims of the programmer) and require access to
       the JCL that was actually executed to determine the object
       dataset name.  Adding the object dataset name would make this
       record usable in an automated reporting process.
1                                                                Page 11


                              R E F E R E N C E S


     DAF utilizes the following SMF record types:

         14 - INPUT or RDBACK Dataset Activity
         15 - OUTPUT, UPDAT, INOUT or OUTIN Dataset Activity
         17 - Scratch Dataset Status
         18 - Rename Dataset Status
         36 - Integrated Catalog Facility Catalog
         60 - VSAM Volume Dataset Updated
         61 - Integrated Catalog Facility Define Activity
         62 - VSAM Component or Cluster Opened
         63 - VSAM Entry Defined
         64 - VSAM Component or Cluster Status
         65 - Integrated Catalog Facility Delete Activity
         66 - Integrated Catalog Facility Alter Activity
         67 - VSAM Entry Deleted
         68 - VSAM Entry Renamed
         69 - VSAM Data Space Defined, Extended or Deleted
         77 - Enqueue Activity
         80 - RACF Processing Record

     The following manuals were found to be helpful during the
     development of DAF:

         MVS/Extended Architecture Debugging Handbook Volume 4
         Data Areas J - Q
         LC28-1167-5  (For MVS/XA 2.2.0)
         Sixth Edition
         June 1987

         MVS/Extended Architecture System Programming Library:
         System Management Facility (SMF)
         GC28-1153-5  (For MVS/XA 2.2.0)
         Sixth Edition
         June 1987

         System Programming Library:
         Resource Access Control Facility (RACF)
         SC28-1343-3  (For RACF 1.8)
         Fourth Edition
         December 1987

     Note:  BDT, IBM, MVS, RACF, SMF and XA are Products and/or
            Trademarks of International Business Machines Corporation.
1                                                                Page 12


                    M O D I F I C A T I O N    H I S T O R Y


     Version 1.0 - 09/06/88
         - Born

     Version 1.1 - 12/09/88
         - Added Control Statement CPU=
         - Added Member $IVP (Installation Verification Program)
         - Added Member $PRT (Print JCL)
         - Added Member $RCF (Reader Comment Form)
         - Added Support for SMF Record Type 36
         - Added Support for SMF Record Type 69
         - Added Support for SMF Record Type 80
         - Enhanced Documentation
         - Enhanced Selection Logic to check both old and new DSNs
         - Enhanced Statistics
         - Renamed Member $EXECUTE to $EXE (Execution JCL)
         - Renamed Member $INSTALL to $CMP (PL/1 Compile/Link JCL)
         - Renamed Member $MANUAL  to $DOC (Documentation)
         - Renamed Member DAF      to $SRC (PL/1 Source)

     Version 1.2 - 02/14/89
         - Added Control Statement FUN=
         - Added Control Statement XCPU=
         - Added Control Statement XDDN=
         - Added Control Statement XDSN=
         - Added Control Statement XFUN=
         - Added Control Statement XJOB=
         - Added Control Statement XVOL=
         - Added Support for SMF Record Type 77
         - Changed Control Statement END= Default from 99365 to 99366
         - Changed Control Statement BEG= Default from 86001 to 00000
         - Enhanced Documentation
         - Enhanced Log
         - Enhanced Report
         - Enhanced Statistics
         - Increased Individual Control Statement Capacity from 32 to 64
         - Reinvented Wheel
         - Renamed Control Statement SD= to BEG=
         - Renamed Control Statement ED= to END=

     Version 1.3 - 09/15/89
         - Enhanced Documentation
         - Stabilized Non-Commercial Offering
1                                                                Page 13


                  S T A T E M E N T    O F    D I R E C T I O N


     In response to many user requests, Cleary Consulting is proud to
     announce a commercial offering of DAF.  The commercial offering
     will consist of:

         - Additional Reporting Options
         - Additional SMF Record Support
         - Electronic Bulletin Board System
           - Online SMF Subsystem APAR information
           - Online Suggestion Submittal
         - ISPF Panel Interface
         - Removal of PL/I Language Requirement
         - Technical Support

     Release 1.3 will remain a non-commercial offering, but will be
     functionally stabilized.

     For additional information, please contact:


                          Cleary Consulting
                          9254 Flax Place
                          Riverside, California  92503
                          (714) 688-4411
./ ADD NAME=$EXE     0100-97322-97322-1519-00039-00039-00000-OLDDAF
//ZT12$EXE JOB (SZ0000),'DAF_Execute',CLASS=B,MSGCLASS=X,NOTIFY=ZT12
//********************************************************************
//*            Dataset Audit Facility (DAF) - Version 1.3           **
//*            (c) Copyright Cleary Consulting 1988, 1989           **
//*                       All Rights Reserved                       **
//********************************************************************
//DAF     EXEC PGM=DAF
//STEPLIB   DD DSN=ZTGP01.DAF.V13.LINKLIB,DISP=SHR
//DAFIN     DD *
JOB=ZT12$IVP
//DAFLOG    DD SYSOUT=*
//DAFRPT    DD SYSOUT=*
//*AFSMF    DD DSN=DCTR.SMFDUMP.DAILY.BBC1(+0),DISP=SHR
//*AFSMF    DD DSN=DCTR.SMFDUMP.WEEKLY.BBC1(+0),DISP=SHR
//*AFSMF    DD DSN=DCTR.SMFDUMP.ACCUM.BBC1(+0),DISP=SHR
//DAFSMF    DD DSN=ZTGP01.DAF.V13.IVP,DISP=SHR
//DAFSTAT   DD SYSOUT=*
//DAFXCLD   DD SYSOUT=*
//DAF1IN    DD DSN=&&DAF1IN,UNIT=3380,SPACE=(CYL,(100,50),RLSE),
//             DCB=(RECFM=FB,LRECL=439,BLKSIZE=23706)
//DAF1OUT   DD DSN=&&DAF1OUT,UNIT=3380,SPACE=(CYL,(100,50),RLSE),
//             DCB=(RECFM=FB,LRECL=439,BLKSIZE=23706)
//DAF1WK01  DD DSN=&&DAF1WK01,UNIT=3380,SPACE=(CYL,(50,10),RLSE),
//             DCB=BUFNO=64
//DAF1WK02  DD DSN=&&DAF1WK02,UNIT=3380,SPACE=(CYL,(50,10),RLSE),
//             DCB=BUFNO=64
//DAF1WK03  DD DSN=&&DAF1WK03,UNIT=3380,SPACE=(CYL,(50,10),RLSE),
//             DCB=BUFNO=64
//DAF2IN    DD DSN=&&DAF2IN,UNIT=3380,SPACE=(CYL,(100,50),RLSE),
//             DCB=(RECFM=FB,LRECL=044,BLKSIZE=23716)
//DAF2OUT   DD DSN=&&DAF2OUT,UNIT=3380,SPACE=(CYL,(100,50),RLSE),
//             DCB=(RECFM=FB,LRECL=044,BLKSIZE=23716)
//DAF2WK01  DD DSN=&&DAF2WK01,UNIT=3380,SPACE=(CYL,(50,10),RLSE),
//             DCB=BUFNO=64
//DAF2WK02  DD DSN=&&DAF2WK02,UNIT=3380,SPACE=(CYL,(50,10),RLSE),
//             DCB=BUFNO=64
//DAF2WK03  DD DSN=&&DAF2WK03,UNIT=3380,SPACE=(CYL,(50,10),RLSE),
//             DCB=BUFNO=64
//SRTMSG    DD SYSOUT=*
./ ADD NAME=$IVP     0100-97322-97322-1519-00144-00144-00000-OLDDAF
//ZT12$IVP JOB (SZ0000),'DAF_IVP',CLASS=B,MSGCLASS=X,NOTIFY=ZT12
//********************************************************************
//*            Dataset Audit Facility (DAF) - Version 1.3           **
//*            (c) Copyright Cleary Consulting 1988, 1989           **
//*                       All Rights Reserved                       **
//********************************************************************
//IVP$1   EXEC PGM=IDCAMS
//SYSPRINT  DD SYSOUT=*
//SYSIN     DD *
 DEL         DAFICF.PATH.CLUSTER         PATH
 DEL         DAFICF.AIX.CLUSTER          AIX
 DEL         DAFICF.KSDS.CLUSTER         CLUSTER
 DEL         DAFICF.ESDS.CLUSTER         CLUSTER
 DEL         DAFICF.ESDS.RENAME.CLUSTER  CLUSTER
 DEL         DAFICF.GDG.G0001V00         NSCR
 DEL         DAFICF.GDG                  GDG
 DEL         DAFICF.RRDS.CLUSTER         CLUSTER
 DEL         DAFICF.EXP                  NVSAM
 DEL         DAFICF.NVSAM                NVSAM
 DEL         DAFICF.RENAME.NVSAM         NVSAM
 DEL         DAFICF                      ALIAS
 DEL         SYS1.CAT.DAFICF             UCAT
 DEL         DAFVSAM.PATH.CLUSTER        PATH
 DEL         DAFVSAM.AIX.CLUSTER         AIX
 DEL         DAFVSAM.KSDS.CLUSTER        CLUSTER
 DEL         DAFVSAM.ESDS.CLUSTER        CLUSTER
 DEL         DAFVSAM.ESDS.RENAME.CLUSTER CLUSTER
 DEL         DAFVSAM.GDG.G0001V00        NSCR
 DEL         DAFVSAM.GDG                 GDG
 DEL         DAFVSAM.RRDS.CLUSTER        CLUSTER
 DEL         DAFVSAM.EXP                 NVSAM
 DEL         DAFVSAM.NVSAM               NVSAM
 DEL         DAFVSAM.RENAME.NVSAM        NVSAM
 DEL         UZOD01 SPACE CAT(SYS1.CAT.DAFVSAM)
 DEL         DAFVSAM                     ALIAS
 DEL         SYS1.CAT.DAFVSAM            UCAT
 SET         MAXCC = 0
//IVP$2   EXEC PGM=IDCAMS
//SYSPRINT  DD SYSOUT=*
//SYSIN     DD *
 DEF UCAT  ( ICFCAT  NAME(SYS1.CAT.DAFICF)  VOL(UZOD02) TRK(9 9) )
 DEF UCAT  ( VSAMCAT NAME(SYS1.CAT.DAFVSAM) VOL(UZOD02) TRK(9 9) )
 DEF ALIAS ( NAME(DAFICF)  RELATE(SYS1.CAT.DAFICF)  )
 DEF ALIAS ( NAME(DAFVSAM) RELATE(SYS1.CAT.DAFVSAM) )
//IVP$3   EXEC PGM=IEFBR14
//I$EXP     DD UNIT=3380,SPACE=(CYL,(9,9),RLSE),VOL=SER=UZOD02,
//             DSN=DAFICF.EXP,DISP=(NEW,CATLG,DELETE)
//I$NVSAM   DD UNIT=3380,SPACE=(CYL,(9,9),RLSE),VOL=SER=UZOD02,
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=15440),
//             DSN=DAFICF.NVSAM,DISP=(NEW,CATLG,DELETE)
//V$NVSAM   DD UNIT=3380,SPACE=(CYL,(9,9),RLSE),VOL=SER=UZOD02,
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=15440),
//             DSN=DAFVSAM.NVSAM,DISP=(NEW,CATLG,DELETE)
//IVP$4   EXEC PGM=IDCAMS
//I$EXP     DD DISP=SHR,DSN=DAFICF.EXP
//I$NVSAM   DD DISP=SHR,DSN=DAFICF.NVSAM
//V$NVSAM   DD DISP=SHR,DSN=DAFVSAM.NVSAM
//VATLST00  DD DISP=SHR,DSN=SYS1.PARMLIB(VATLST00)
//SYSPRINT  DD SYSOUT=*
//SYSIN     DD *
 DEF CL    ( NAME(DAFICF.ESDS.CLUSTER) VOL(UZOD02) RECSZ(80 80) -
             TRK(9 9) NIXD ) -
     DATA  ( NAME(DAFICF.ESDS.DATA) )
 DEF CL    ( NAME(DAFVSAM.ESDS.CLUSTER) VOL(UZOD02) RECSZ(80 80) -
             TRK(9 9) NIXD UNIQUE) -
     DATA  ( NAME(DAFVSAM.ESDS.DATA) )
 DEF CL    ( NAME(DAFICF.KSDS.CLUSTER) VOL(UZOD02) RECSZ(80 80) -
             TRK(9 9) IXD KEYS(6 72) ) -
     DATA  ( NAME(DAFICF.KSDS.DATA) ) -
     INDEX ( NAME(DAFICF.KSDS.INDEX) )
 DEF CL    ( NAME(DAFVSAM.KSDS.CLUSTER) VOL(UZOD02) RECSZ(80 80) -
             TRK(9 9) IXD KEYS(6 72) UNIQUE) -
     DATA  ( NAME(DAFVSAM.KSDS.DATA) ) -
     INDEX ( NAME(DAFVSAM.KSDS.INDEX) )
 DEF CL    ( NAME(DAFICF.RRDS.CLUSTER) VOL(UZOD02) RECSZ(80 80) -
             TRK(9 9) NUMD ) -
     DATA  ( NAME(DAFICF.RRDS.DATA) )
 DEF CL    ( NAME(DAFVSAM.RRDS.CLUSTER) VOL(UZOD02) RECSZ(80 80) -
             TRK(9 9) NUMD UNIQUE) -
     DATA  ( NAME(DAFVSAM.RRDS.DATA) )
 DEF GDG   ( NAME(DAFICF.GDG)  LIMIT(9) )
 DEF GDG   ( NAME(DAFVSAM.GDG) LIMIT(9) )
 DEF NVSAM ( NAME(DAFICF.GDG.G0001V00)  VOL(UZOD02) DEVT(3380) )
 DEF NVSAM ( NAME(DAFVSAM.GDG.G0001V00) VOL(UZOD02) DEVT(3380) )
 REPRO       IFILE(VATLST00) ODS(DAFICF.ESDS.CLUSTER)
 REPRO       IFILE(VATLST00) ODS(DAFVSAM.ESDS.CLUSTER)
 REPRO       IFILE(VATLST00) ODS(DAFICF.KSDS.CLUSTER)
 REPRO       IFILE(VATLST00) ODS(DAFVSAM.KSDS.CLUSTER)
 REPRO       IFILE(VATLST00) ODS(DAFICF.RRDS.CLUSTER)
 REPRO       IFILE(VATLST00) ODS(DAFVSAM.RRDS.CLUSTER)
 REPRO       IFILE(VATLST00) OFILE(I$NVSAM)
 REPRO       IFILE(VATLST00) OFILE(V$NVSAM)
 DEF AIX   ( NAME(DAFICF.AIX.CLUSTER) VOL(UZOD02) RECSZ(80 80) -
             RELATE(DAFICF.KSDS.CLUSTER) -
             TRK(9 9) KEYS(8 0) ) -
     DATA  ( NAME(DAFICF.AIX.DATA) ) -
     INDEX ( NAME(DAFICF.AIX.INDEX) )
 DEF AIX   ( NAME(DAFVSAM.AIX.CLUSTER) VOL(UZOD02) RECSZ(80 80) -
             RELATE(DAFVSAM.KSDS.CLUSTER) -
             TRK(9 9) KEYS(8 0) UNIQUE) -
     DATA  ( NAME(DAFVSAM.AIX.DATA) ) -
     INDEX ( NAME(DAFVSAM.AIX.INDEX) )
 DEF PATH  ( NAME(DAFICF.PATH.CLUSTER)  PENT(DAFICF.AIX.CLUSTER) )
 DEF PATH  ( NAME(DAFVSAM.PATH.CLUSTER) PENT(DAFVSAM.AIX.CLUSTER) )
 BIX         IDS(DAFICF.KSDS.CLUSTER) ODS(DAFICF.PATH.CLUSTER)
 BIX         IDS(DAFVSAM.KSDS.CLUSTER) ODS(DAFVSAM.PATH.CLUSTER)
 ALTER       DAFICF.ESDS.CLUSTER  NEWNAME(DAFICF.ESDS.RENAME.CLUSTER)
 ALTER       DAFVSAM.ESDS.CLUSTER NEWNAME(DAFVSAM.ESDS.RENAME.CLUSTER)
 ALTER       DAFICF.NVSAM  NEWNAME(DAFICF.RENAME.NVSAM)
 ALTER       DAFVSAM.NVSAM NEWNAME(DAFVSAM.RENAME.NVSAM)
 EXP         SYS1.CAT.DAFICF  TEMP OFILE(I$EXP)
 DEF SPC   ( VOL(UZOD01) CYL(3) ) CAT(SYS1.CAT.DAFVSAM)
 DEF SPC   ( VOL(UZOD01) TRK(1) ) CAT(SYS1.CAT.DAFVSAM)
//IVP$5   EXEC PGM=IDCAMS
//SYSPRINT  DD SYSOUT=*
//SYSIN     DD *
 DEL         DAFICF.PATH.CLUSTER         PATH
 DEL         DAFICF.AIX.CLUSTER          AIX
 DEL         DAFICF.KSDS.CLUSTER         CLUSTER
 DEL         DAFICF.ESDS.CLUSTER         CLUSTER
 DEL         DAFICF.ESDS.RENAME.CLUSTER  CLUSTER
 DEL         DAFICF.GDG.G0001V00         NSCR
 DEL         DAFICF.GDG                  GDG
 DEL         DAFICF.RRDS.CLUSTER         CLUSTER
 DEL         DAFICF.EXP                  NVSAM
 DEL         DAFICF.NVSAM                NVSAM
 DEL         DAFICF.RENAME.NVSAM         NVSAM
 DEL         DAFICF                      ALIAS
 DEL         SYS1.CAT.DAFICF             UCAT
 DEL         DAFVSAM.PATH.CLUSTER        PATH
 DEL         DAFVSAM.AIX.CLUSTER         AIX
 DEL         DAFVSAM.KSDS.CLUSTER        CLUSTER
 DEL         DAFVSAM.ESDS.CLUSTER        CLUSTER
 DEL         DAFVSAM.ESDS.RENAME.CLUSTER CLUSTER
 DEL         DAFVSAM.GDG.G0001V00        NSCR
 DEL         DAFVSAM.GDG                 GDG
 DEL         DAFVSAM.RRDS.CLUSTER        CLUSTER
 DEL         DAFVSAM.EXP                 NVSAM
 DEL         DAFVSAM.NVSAM               NVSAM
 DEL         DAFVSAM.RENAME.NVSAM        NVSAM
 DEL         UZOD01 SPACE CAT(SYS1.CAT.DAFVSAM)
 DEL         DAFVSAM                     ALIAS
 DEL         SYS1.CAT.DAFVSAM            UCAT
 SET         MAXCC = 0
./ ADD NAME=$PRT     0100-97322-97322-1519-00022-00022-00000-OLDDAF
//ZT12$PRT JOB (SZ0000),'DAF_Print',CLASS=B,MSGCLASS=X,NOTIFY=ZT12
//********************************************************************
//*            Dataset Audit Facility (DAF) - Version 1.3           **
//*            (c) Copyright Cleary Consulting 1988, 1989           **
//*                       All Rights Reserved                       **
//********************************************************************
//IFASMFDP EXEC PGM=IFASMFDP
//*UMPIN    DD DISP=SHR,DSN=DCTR.SMFDUMP.ACCUM.BBC1(0)
//*UMPIN    DD DISP=SHR,DSN=DCTR.SMFDUMP.DAILY.BBC1(0)
//*UMPIN    DD DISP=SHR,DSN=DCTR.SMFDUMP.WEEKLY.BBC1(0)
//DUMPIN    DD DISP=SHR,DSN=ZTGP01.DAF.V13.IVP
//DUMPOUT   DD DSN=&&SMF,DISP=(NEW,PASS,DELETE),
//             UNIT=(SYSDA),SPACE=(CYL,(50,10),RLSE)
//SYSIN     DD *
  INDD(DUMPIN,OPTIONS(DUMP))
  OUTDD(DUMPOUT,TYPE(77))
//SYSPRINT  DD SYSOUT=*
//IDCAMS  EXEC PGM=IDCAMS
//SMF       DD DISP=(OLD,DELETE),DSN=&&SMF
//SYSIN     DD *
  PRINT IFILE(SMF)
//SYSPRINT  DD SYSOUT=*
./ ADD NAME=$RCF     0100-97322-97322-1519-00051-00051-00000-OLDDAF
                   Dataset Audit Facility (DAF) - Version 1.3
                   (c) Copyright Cleary Consulting 1988, 1989
                              All Rights Reserved

                            DAF Reader Comment Form


Personal Information:


Name:          _______________________________________________________

Installation:  _______________________________________________________

Address:       _______________________________________________________

Phone:         _______________________________________________________

Date:          ________________


How does your installation use DAF ?


______________________________________________________________________

______________________________________________________________________

______________________________________________________________________

______________________________________________________________________


Problems and/or Suggestions:


______________________________________________________________________

______________________________________________________________________

______________________________________________________________________

______________________________________________________________________

______________________________________________________________________

______________________________________________________________________

______________________________________________________________________

______________________________________________________________________
./ ADD NAME=$SRC     0100-97322-97322-1519-02039-02039-00000-OLDDAF
 DAF: PROC OPTIONS(MAIN) REORDER;
 /* *************************************************************** */
 /*            Dataset Audit Facility (DAF) - Version 1.3           */
 /*            (c) Copyright Cleary Consulting 1988, 1989           */
 /*                       All Rights Reserved                       */
 /* *************************************************************** */
 /*  Areas  */
 DCL ARA_SMF      AREA(32767);
 /*  Counters  */
 DCL CTR_DAFIN    FIXED BIN(031,0) INIT(0);
 DCL CTR_NCS_CPU  FIXED BIN(031,0) INIT(0);
 DCL CTR_NCS_DDN  FIXED BIN(031,0) INIT(0);
 DCL CTR_NCS_DSN  FIXED BIN(031,0) INIT(0);
 DCL CTR_NCS_FUN  FIXED BIN(031,0) INIT(0);
 DCL CTR_NCS_JOB  FIXED BIN(031,0) INIT(0);
 DCL CTR_NCS_VOL  FIXED BIN(031,0) INIT(0);
 DCL CTR_NCS_XCPU FIXED BIN(031,0) INIT(0);
 DCL CTR_NCS_XDDN FIXED BIN(031,0) INIT(0);
 DCL CTR_NCS_XDSN FIXED BIN(031,0) INIT(0);
 DCL CTR_NCS_XFUN FIXED BIN(031,0) INIT(0);
 DCL CTR_NCS_XJOB FIXED BIN(031,0) INIT(0);
 DCL CTR_NCS_XVOL FIXED BIN(031,0) INIT(0);
 DCL CTR_TXT      FIXED BIN(031,0) INIT(1);
 DCL CTR_WRK      FIXED BIN(031,0) INIT(0);
 DCL CTR_XXX      FIXED BIN(031,0) INIT(0);
 /*  Files  */
 DCL DAFIN        FILE INPUT  RECORD       ENV(CONSECUTIVE);
 DCL DAFLOG       FILE OUTPUT STREAM PRINT ENV(F,RECSIZE(133));
 DCL DAFRPT       FILE OUTPUT STREAM PRINT ENV(F,RECSIZE(133));
 DCL DAFSMF       FILE INPUT  RECORD       ENV(BUFFERS(16),
                                               CONSECUTIVE);
 DCL DAFSTAT      FILE OUTPUT STREAM PRINT ENV(F,RECSIZE(133));
 DCL DAFXCLD      FILE OUTPUT STREAM PRINT ENV(F,RECSIZE(133));
 DCL DAF1IN       FILE OUTPUT RECORD       ENV(BUFFERS(08),
                                               CONSECUTIVE);
 DCL DAF1OUT      FILE INPUT  RECORD       ENV(BUFFERS(08),
                                               CONSECUTIVE);
 DCL DAF2IN       FILE OUTPUT RECORD       ENV(BUFFERS(08),
                                               CONSECUTIVE);
 DCL DAF2OUT      FILE INPUT  RECORD       ENV(BUFFERS(08),
                                               CONSECUTIVE);
 /*  Flags  */
 DCL FLG_CLASS_DATASET BIT(001) INIT('0'B);
 DCL FLG_DAFIN_ERROR   BIT(001) INIT('0'B);
 DCL FLG_EOF_DAFIN     BIT(001) INIT('0'B);
 DCL FLG_EOF_DAFSMF    BIT(001) INIT('0'B);
 DCL FLG_EOF_DAF1OUT   BIT(001) INIT('0'B);
 DCL FLG_EOF_DAF2OUT   BIT(001) INIT('0'B);
 DCL FLG_FND_CPU       BIT(001) INIT('0'B);
 DCL FLG_FND_DDN       BIT(001) INIT('0'B);
 DCL FLG_FND_DSN       BIT(001) INIT('0'B);
 DCL FLG_FND_XCPU      BIT(001) INIT('0'B);
 DCL FLG_FND_XDDN      BIT(001) INIT('0'B);
 DCL FLG_FND_XDSN      BIT(001) INIT('0'B);
 DCL FLG_FND_XJOB      BIT(001) INIT('0'B);
 DCL FLG_FND_XVOL      BIT(001) INIT('0'B);
 DCL FLG_FND_JOB       BIT(001) INIT('0'B);
 DCL FLG_FND_VOL       BIT(001) INIT('0'B);
 DCL FLG_FUN_CATALOG   BIT(001) INIT('0'B);
 DCL FLG_FUN_DATASET   BIT(001) INIT('0'B);
 DCL FLG_FUN_ENQUEUE   BIT(001) INIT('0'B);
 DCL FLG_FUN_RACF      BIT(001) INIT('0'B);
 DCL FLG_NONE_SELECTED BIT(001) INIT('0'B);
 DCL FLG_SEL_DATE      BIT(001) INIT('0'B);
 DCL FLG_SEL_EXCLUDE   BIT(001) INIT('0'B);
 DCL FLG_SEL_INCLUDE   BIT(001) INIT('0'B);
 DCL FLG_SORT_ERROR    BIT(001) INIT('0'B);
 DCL FLG_XFUN_CATALOG  BIT(001) INIT('0'B);
 DCL FLG_XFUN_DATASET  BIT(001) INIT('0'B);
 DCL FLG_XFUN_ENQUEUE  BIT(001) INIT('0'B);
 DCL FLG_XFUN_RACF     BIT(001) INIT('0'B);
 /*  Functions  */
 DCL ADDR         BUILTIN;
 DCL DATE         BUILTIN;
 DCL INDEX        BUILTIN;
 DCL LENGTH       BUILTIN;
 DCL LOW          BUILTIN;
 DCL PLIRETC      BUILTIN;
 DCL PLISRTA      BUILTIN;
 DCL SUBSTR       BUILTIN;
 DCL TIME         BUILTIN;
 /*  Pointers  */
 DCL PTR_SMF POINTER;
 /*  Tables  */
 DCL 1 TBL_CSI(064),
     2 TBL_CPUREQ CHAR(008) INIT(' '),
     2 TBL_CPULEN FIXED BIN(031,0) INIT(0),
     2 TBL_DDNREQ CHAR(008) INIT(' '),
     2 TBL_DDNLEN FIXED BIN(031,0) INIT(0),
     2 TBL_DSNREQ CHAR(044) INIT(' '),
     2 TBL_DSNLEN FIXED BIN(031,0) INIT(0),
     2 TBL_JOBREQ CHAR(008) INIT(' '),
     2 TBL_JOBLEN FIXED BIN(031,0) INIT(0),
     2 TBL_VOLREQ CHAR(006) INIT(' '),
     2 TBL_VOLLEN FIXED BIN(031,0) INIT(0),
     2 TBL_XCPUREQ CHAR(044) INIT(' '),
     2 TBL_XCPULEN FIXED BIN(031,0) INIT(0),
     2 TBL_XDDNREQ CHAR(044) INIT(' '),
     2 TBL_XDDNLEN FIXED BIN(031,0) INIT(0),
     2 TBL_XDSNREQ CHAR(044) INIT(' '),
     2 TBL_XDSNLEN FIXED BIN(031,0) INIT(0),
     2 TBL_XJOBREQ CHAR(044) INIT(' '),
     2 TBL_XJOBLEN FIXED BIN(031,0) INIT(0),
     2 TBL_XVOLREQ CHAR(044) INIT(' '),
     2 TBL_XVOLLEN FIXED BIN(031,0) INIT(0);
 DCL 1 TBL_RPTCTR(008),
     2 CTR_LNE    FIXED BIN(031,0) INIT(0),
     2 CTR_PGE    FIXED BIN(031,0) INIT(0);
 DCL 1 TBL_CTR(150),
     2 CTR_DSC    CHAR(050) INIT(' '),
     2 CTR_DAFRPT FIXED BIN(031,0) INIT(0),
     2 CTR_DAFSMF FIXED BIN(031,0) INIT(0),
     2 CTR_DAFXCLD FIXED BIN(031,0) INIT(0);
 /*  General Variables  */
 DCL DAFIN_REC    CHAR(080) INIT(' ');
 DCL DAFXXDCS     CHAR(080);
 DCL DTE_HGH      FIXED DEC(007) INIT(00000);
 DCL DTE_LOW      FIXED DEC(007) INIT(99366);
 DCL DTE_BEG      FIXED DEC(5) INIT(00000);
 DCL DTE_END      FIXED DEC(5) INIT(99366);
 DCL DTE_RUN      PIC'99/99/99';
 DCL DTE_WRK      PIC'99999';
 DCL DTE_YYDDD    CHAR(005);
 DCL PREV_DSN     CHAR(044) INIT('ZZZZZZZZZ');
 DCL WRK_NUM      PIC'ZZZZZZZZZ9';
 DCL WRKXXENM     CHAR(044) INIT(' ');
 DCL WRKXXJNM     CHAR(008) INIT(' ');
 DCL WRKXXNME     CHAR(020) INIT(' ');
 DCL 1 DAFXXREC,
     2 DAFXXENM   CHAR(044),
     2 DAFXXDTE   FIXED DEC(5),
     2 DAFXXTME   BIT(032),
     2 DAFXXSID   CHAR(004),
     2 DAFXXJNM   CHAR(008),
     2 DAFXXDDN   CHAR(008),
     2 DAFXXVOL   CHAR(006),
     2 DAFXXRTY   PIC'99',
     2 DAFXXLNE   CHAR(360);
 DCL SRT_RC       BINARY FIXED(31) INIT(0);
 DCL TME_CC       FIXED BIN(015);
 DCL TME_HGH      BIT(032) INIT((32)'0'B);
 DCL TME_LONG     PIC'99.99.99.99';
 DCL TME_LOW      BIT(032) INIT((32)'1'B);
 DCL TME_HH       FIXED BIN(015);
 DCL TME_MM       FIXED BIN(015);
 DCL TME_RUN      PIC'99.99.99';
 DCL TME_SS       FIXED BIN(015);
 DCL TME_WRK      FIXED BIN(31);
 /*  SMF Records  */
 DCL 1 SMF_PHYSCL BASED(ADDR(ARA_SMF)),
     2 SMFXXLEN   BIT(016),
     2 SMFXXSEG   BIT(016),
     2 SMF_LGCL   CHAR(32763);
 DCL 1 SMF_COMMON BASED(ADDR(SMF_LGCL)),
     2 SMFXXFLG   BIT(008),
     2 SMFXXRTY   BIT(008),
     2 SMFXXTME   BIT(032),
     2 SMFXXDTE   FIXED DEC(007),
     2 SMFXXSID   CHAR(004),
     2 SMF_UNIQUE CHAR(32750);
 DCL 1 SMFRCD14   BASED(ADDR(SMF_UNIQUE)),
     2 SMF14JBN   CHAR(008),
     2 SMF14RST   BIT(032),
     2 SMF14RSD   FIXED DEC(007),
     2 SMF14UID   CHAR(008),
     2 SMF14RIN   BIT(016),
     2 SMF14SDC   BIT(008),
     2 SMF14NUC   BIT(008),
     2 SMF14SUC   BIT(008),
     2 SMF14SET   BIT(008),
     2 SMF14OPE   BIT(032),
     2 SMFTIOE1   BIT(008),
     2 SMFTIOE2   BIT(008),
     2 SMFTIOE3   BIT(008),
     2 SMFTIOE4   BIT(008),
     2 SMFTIOE5   CHAR(008),
     2 SMFTIOE6   BIT(024),
     2 SMFTIOE7   BIT(008),
     2 JFCBDSNM   CHAR(044),
     2 JFCBELNM   CHAR(008),
     2 JFCBTSDM   BIT(008),
     2 JFCBDSCB   BIT(024),
     2 JFCAMCRO   BIT(016),
     2 JFCAMSTR   BIT(016),
     2 JFCBADBF   BIT(016),
     2 JFCNLREC   BIT(016),
     2 JFCVINDX   BIT(016),
     2 JFCBLTYP   BIT(008),
     2 JFCBUFOF   BIT(008),
     2 JFCBFLSQ   BIT(016),
     2 JFCBVLSQ   BIT(016),
     2 JFCBOPS1   BIT(040),
     2 JFCBFLG1   BIT(008),
     2 JFCBFLG2   BIT(008),
     2 JFCBOPS2   BIT(008),
     2 JFCBCRDT,
     3 CRDT_YY    BIT(008),
     3 CRDT_DDD   BIT(016),
     2 JFCBXPDT,
     3 XPDT_YY    BIT(008),
     3 XPDT_DDD   BIT(016),
     2 JFCBIND1,
     3 JFCRLSE    BIT(006),
     3 JFCGDG     BIT(001),
     3 JFCPDS     BIT(001),
     2 JFCBIND2   BIT(008),
     2 JFCBUFNO   BIT(008),
     2 JFCBFTEK   BIT(008),
     2 JFCBUFL    BIT(016),
     2 JFCEROPT   BIT(008),
     2 JFCKEYLE   BIT(008),
     2 JFCDEN     BIT(008),
     2 JFCBABFS   BIT(024),
     2 JFCDSRG1,
     3 JFCORGIS   BIT(001),
     3 JFCORGPS   BIT(001),
     3 JFCORGDA   BIT(001),
     3 JFCORGDX   BIT(001),
     3 JFCORGCQ   BIT(001),
     3 JFCORGMQ   BIT(001),
     3 JFCORGPO   BIT(001),
     3 JFCORGU    BIT(001),
     2 JFCDSRG2,
     3 JFCORGGS   BIT(001),
     3 JFCORGTX   BIT(001),
     3 JFCORGTQ   BIT(001),
     3 JFCRSV13   BIT(001),
     3 JFCORGAM   BIT(001),
     3 JFCORGTR   BIT(001),
     3 JFCRSV15   BIT(001),
     3 JFCRSV16   BIT(001),
     2 JFCRECFM,
     3 JFCFIX     BIT(001),
     3 JFCVAR     BIT(001),
     3 JFCRFO     BIT(001),
     3 JFCRFB     BIT(001),
     3 JFCRFS     BIT(001),
     3 JFCASA     BIT(001),
     3 JFCMAC     BIT(001),
     3 JFCRSV99   BIT(001),
     2 JFCOPTCD   BIT(008),
     2 JFCBLKSI   BIT(016),
     2 JFCLRECL   BIT(016),
     2 JFCNCP     BIT(008),
     2 JFCBFSEQ   BIT(008),
     2 JFCRBIDC   BIT(032),
     2 JFCINTVL   BIT(008),
     2 JFCOUTLI   BIT(024),
     2 JFCBNTCS   BIT(008),
     2 JFCBNVOL   BIT(008),
     2 JFCBVOL1   CHAR(006),
     2 JFCBVOL2   CHAR(006),
     2 JFCBVOL3   CHAR(006),
     2 JFCBVOL4   CHAR(006),
     2 JFCBVOL5   CHAR(006),
     2 JFCBEXTL   BIT(008),
     2 JFCBEXAD   BIT(024),
     2 JFCBPQTY   BIT(024),
     2 JFCBCTRI,
     3 JFCBCTRI_0 BIT(001),
     3 JFCBCTRI_1 BIT(001),
     3 JFCBCTRI_2 BIT(001),
     3 JFCBCTRI_3 BIT(001),
     3 JFCBCTRI_4 BIT(001),
     3 JFCBCTRI_5 BIT(001),
     3 JFCBCTRI_6 BIT(001),
     3 JFCBCTRI_7 BIT(001),
     2 JFCBSQTY   BIT(024),
     2 JFCFLGS1   BIT(008),
     2 JFCBDQTY   CHAR(003),
     2 JFCBFLG3   BIT(008),
     2 JFCBRV08   BIT(016),
     2 JFCBABST   BIT(016),
     2 JFCBSBNM   BIT(024),
     2 JFCBDRLH   BIT(024),
     2 JFCBVLCT   BIT(008),
     2 JFCBSPTN   BIT(008),
     2 SMFDCBOR   BIT(016),
     2 SMFDCBRF   BIT(008),
     2 SMFDCBMF   BIT(016),
     2 SMFDCBFL   BIT(008),
     2 SMFDCBOP   BIT(008),
     2 SMF14RV2   BIT(008),
     2 SMFDEBFL   BIT(008),
     2 SMFDEBOP   BIT(008),
     2 SMFDEBVL   BIT(016),
     2 SMF14NTU   BIT(032),
     2 SMF14NTR   BIT(032),
     2 SMF14NER   BIT(008),
     2 SMF14RV4   BIT(024),
     2 SMFUCBDV   BIT(016),
     2 SMFSRTEV   CHAR(006),
     2 SMFUCBTY   BIT(032),
     2 SMFSRTES   BIT(008),
     2 SMF14NEX   BIT(008),
     2 SMF14RV5   BIT(016),
     2 SMFEXCP    BIT(032);
 DCL 1 SMFRCD17   BASED(ADDR(SMF_UNIQUE)),
     2 SMF17JBN   CHAR(008),
     2 SMF17RST   BIT(032),
     2 SMF17RSD   FIXED DEC(007),
     2 SMF17UID   CHAR(008),
     2 SMF17RIN   BIT(016),
     2 SMF17DSN   CHAR(044),
     2 SMF17RV1   BIT(024),
     2 SMF17NVL   BIT(008),
     2 SMF17RV2   BIT(016),
     2 SMF17FVL   CHAR(006);
 DCL 1 SMFRCD18   BASED(ADDR(SMF_UNIQUE)),
     2 SMF18JBN   CHAR(008),
     2 SMF18RST   BIT(032),
     2 SMF18RSD   FIXED DEC(007),
     2 SMF18UID   CHAR(008),
     2 SMF18RIN   BIT(016),
     2 SMF18ODS   CHAR(044),
     2 SMF18NDS   CHAR(044),
     2 SMF18RV1   BIT(024),
     2 SMF18NVL   BIT(008),
     2 SMF18RV2   BIT(016),
     2 SMF18FVL   CHAR(006);
 DCL 1 SMFRCD36   BASED(ADDR(SMF_UNIQUE)),
     2 SMF36SBS   CHAR(004),
     2 SMF36SUB   CHAR(002),
     2 SMF36NOT   BIT(016),
     2 SMF36RES   BIT(016),
     2 SMF36POF   BIT(032),
     2 SMF36PLN   BIT(016),
     2 SMF36PNO   BIT(016),
     2 SMF36DOF   BIT(032),
     2 SMF36DLN   BIT(016),
     2 SMF36DNO   BIT(016),
     2 SMF36PVN   CHAR(002),
     2 SMF36PNM   CHAR(008),
     2 SMF36PRL   CHAR(002),
     2 SMF36JNM   CHAR(008),
     2 SMF36RST   BIT(032),
     2 SMF36RDT   FIXED DEC(007),
     2 SMF36UID   CHAR(008),
     2 SMF36PGM   CHAR(008),
     2 SMF36CNM   CHAR(044),
     2 SMF36CVS   CHAR(006),
     2 SMF36CDT   BIT(032),
     2 SMF36EDT   CHAR(008),
     2 SMF36ETM   CHAR(008),
     2 SMF36PDS   CHAR(044),
     2 SMF36PVS   CHAR(006),
     2 SMF36PDT   BIT(032),
     2 SMF36EIN   CHAR(002);
 DCL 1 SMFRCD60   BASED(ADDR(SMF_UNIQUE)),
     2 SMF60SBS   CHAR(004),
     2 SMF60SUB   CHAR(002),
     2 SMF60POF   BIT(032),
     2 SMF60PLN   BIT(016),
     2 SMF60PNO   BIT(016),
     2 SMF60DOF   BIT(032),
     2 SMF60DLN   BIT(016),
     2 SMF60DNO   BIT(016),
     2 SMF60VER   CHAR(002),
     2 SMF60PNM   CHAR(008),
     2 SMF60JNM   CHAR(008),
     2 SMF60RST   BIT(032),
     2 SMF60RDT   FIXED DEC(007),
     2 SMF60UID   CHAR(008),
     2 SMF60FNC   CHAR(001),
     2 SMF60CNM   CHAR(044),
     2 SMF60TYP   CHAR(001),
     2 SMF60ENM   CHAR(044),
     2 SMF60NNM   CHAR(044),
     2 SMF60CRC   BIT(016);
 DCL 1 SMFRCD61   BASED(ADDR(SMF_UNIQUE)),
     2 SMF61SBS   CHAR(004),
     2 SMF61SUB   CHAR(002),
     2 SMF61POF   BIT(032),
     2 SMF61PLN   BIT(016),
     2 SMF61PNO   BIT(016),
     2 SMF61DOF   BIT(032),
     2 SMF61DLN   BIT(016),
     2 SMF61DNO   BIT(016),
     2 SMF61VER   CHAR(002),
     2 SMF61PNM   CHAR(008),
     2 SMF61JNM   CHAR(008),
     2 SMF61RST   BIT(032),
     2 SMF61RDT   FIXED DEC(007),
     2 SMF61UID   CHAR(008),
     2 SMF61FNC   CHAR(001),
     2 SMF61CNM   CHAR(044),
     2 SMF61TYP   CHAR(001),
     2 SMF61ENM   CHAR(044),
     2 SMF61NNM   CHAR(044),
     2 SMF61CRC   BIT(016);
 DCL 1 SMFRCD62   BASED(ADDR(SMF_UNIQUE)),
     2 SMF62JBN   CHAR(008),
     2 SMF62RST   BIT(032),
     2 SMF62RSD   FIXED DEC(007),
     2 SMF62UIF   CHAR(008),
     2 SMF62IND   BIT(032),
     2 SMF62CNM   CHAR(044),
     2 SMF62CVS   CHAR(006),
     2 SMF62DNM   CHAR(044),
     2 SMF62VCT   BIT(016),
     2 SMF62VSR   CHAR(006),
     2 SMF62DTY   BIT(016);
 DCL 1 SMFRCD63   BASED(ADDR(SMF_UNIQUE)),
     2 SMF63JBN   CHAR(008),
     2 SMF63RST   BIT(032),
     2 SMF63RSD   FIXED DEC(007),
     2 SMF63UIF   CHAR(008),
     2 SMF63FDT,
     3 SMF63FDT_0 BIT(001),
     3 SMF63FDT_1 BIT(001),
     3 SMF63FDT_2 BIT(004),
     3 SMF63FDT_6 BIT(001),
     3 SMF63FDT_7 BIT(001),
     2 SMF63TYP,
     3 SMF63TYP_0 BIT(001),
     3 SMF63TYP_1 BIT(001),
     3 SMF63TYP_2 BIT(001),
     3 SMF63TYP_3 BIT(001),
     3 SMF63TYP_4 BIT(001),
     3 SMF63TYP_5 BIT(001),
     3 SMF63TYP_6 BIT(001),
     3 SMF63TYP_7 BIT(001),
     2 SMF63NSZ   BIT(016),
     2 SMF63OSZ   BIT(016),
     2 SMF63CNM   CHAR(044),
     2 SMF63ENM   CHAR(044),
     2 SMF63NCR   BIT(002);
 DCL 1 SMFRCD64   BASED(ADDR(SMF_UNIQUE)),
     2 SMF64JBN   CHAR(008),
     2 SMF64RST   BIT(032),
     2 SMF64RSD   FIXED DEC(007),
     2 SMF64UIF   CHAR(008),
     2 SMF64RIN,
     3 SMF64RIN_0 BIT(001),
     3 SMF64RIN_1 BIT(001),
     3 SMF64RIN_2 BIT(001),
     3 SMF64RIN_3 BIT(001),
     3 SMF64RIN_4 BIT(001),
     3 SMF64RIN_5 BIT(001),
     3 SMF64RIN_6 BIT(001),
     3 SMF64RIN_7 BIT(001),
     2 SMF64DTY,
     3 SMF64DTY_0 BIT(001),
     3 SMF64DTY_1 BIT(001),
     3 SMF64DTY_2 BIT(001),
     3 SMF64DTY_3 BIT(001),
     3 SMF64DTY_4 BIT(001),
     3 SMF64DTY_5 BIT(001),
     3 SMF64DTY_6 BIT(001),
     3 SMF64DTY_7 BIT(001),
     2 SMF64CNM   CHAR(044),
     2 SMF64DNM   CHAR(044),
     2 SMF64NTR   BIT(016),
     2 SMF64CHR   BIT(032),
     2 SMF64ESL   BIT(016),
     2 SMF64FCC   BIT(032),
     2 SMF64TCC   BIT(032),
     2 SMF64VSN   CHAR(006),
     2 SMF64CUU   BIT(016),
     2 SMF64IND   BIT(016),
     2 SMF64UTY   BIT(032),
     2 SMF64RV1   BIT(032),
     2 FIL64EXT(5120) CHAR(001);
 DCL 1 SMFEXT64   BASED(PTR_SMF),
     2 SMF64SLN   BIT(032),
     2 SMF64NIL   BIT(032),
     2 SMF64NEX   BIT(032),
     2 SMF64NLR   BIT(032),
     2 SMF64NDE   BIT(032),
     2 SMF64NIN   BIT(032),
     2 SMF64NUP   BIT(032),
     2 SMF64NRE   BIT(032),
     2 SMF64NFS   BIT(032),
     2 SMF64NCS   BIT(032),
     2 SMF64NAS   BIT(032),
     2 SMF64NEP   BIT(032),
     2 SMF64DIL   BIT(032),
     2 SMF64DEX   BIT(032),
     2 SMF64DLR   BIT(032),
     2 SMF64DDE   BIT(032),
     2 SMF64DIN   BIT(032),
     2 SMF64DUP   BIT(032),
     2 SMF64DRE   BIT(032),
     2 SMF64DFS   BIT(032),
     2 SMF64DCS   BIT(032),
     2 SMF64DAS   BIT(032),
     2 SMF64DEP   BIT(032),
     2 SMF64DBS   BIT(032),
     2 SMF64DCI   BIT(032),
     2 SMF64DLS   BIT(032),
     2 SMF64DKL   BIT(016),
     2 SMF64DDN   CHAR(008);
 DCL 1 SMFRCD65   BASED(ADDR(SMF_UNIQUE)),
     2 SMF65SBS   CHAR(004),
     2 SMF65SUB   CHAR(002),
     2 SMF65POF   BIT(032),
     2 SMF65PLN   BIT(016),
     2 SMF65PNO   BIT(016),
     2 SMF65DOF   BIT(032),
     2 SMF65DLN   BIT(016),
     2 SMF65DNO   BIT(016),
     2 SMF65VER   CHAR(002),
     2 SMF65PNM   CHAR(008),
     2 SMF65JNM   CHAR(008),
     2 SMF65RST   BIT(032),
     2 SMF65RDT   FIXED DEC(007),
     2 SMF65UID   CHAR(008),
     2 SMF65FNC   CHAR(001),
     2 SMF65CNM   CHAR(044),
     2 SMF65TYP   CHAR(001),
     2 SMF65ENM   CHAR(044),
     2 SMF65NNM   CHAR(044),
     2 SMF65CRC   BIT(016);
 DCL 1 SMFRCD66   BASED(ADDR(SMF_UNIQUE)),
     2 SMF66SBS   CHAR(004),
     2 SMF66SUB   CHAR(002),
     2 SMF66POF   BIT(032),
     2 SMF66PLN   BIT(016),
     2 SMF66PNO   BIT(016),
     2 SMF66DOF   BIT(032),
     2 SMF66DLN   BIT(016),
     2 SMF66DNO   BIT(016),
     2 SMF66VER   CHAR(002),
     2 SMF66PNM   CHAR(008),
     2 SMF66JNM   CHAR(008),
     2 SMF66RST   BIT(032),
     2 SMF66RDT   FIXED DEC(007),
     2 SMF66UID   CHAR(008),
     2 SMF66FNC   CHAR(001),
     2 SMF66CNM   CHAR(044),
     2 SMF66TYP   CHAR(001),
     2 SMF66ENM   CHAR(044),
     2 SMF66NNM   CHAR(044),
     2 SMF66CRC   BIT(016);
 DCL 1 SMFRCD67   BASED(ADDR(SMF_UNIQUE)),
     2 SMF67JBN   CHAR(008),
     2 SMF67RST   BIT(032),
     2 SMF67RSD   FIXED DEC(007),
     2 SMF67UIF   CHAR(008),
     2 SMF67FDT,
     3 SMF67FDT_0 BIT(001),
     3 SMF67FDT_1 BIT(001),
     3 SMF67FDT_2 BIT(004),
     3 SMF67FDT_6 BIT(001),
     3 SMF67FDT_7 BIT(001),
     2 SMF67IOD,
     3 SMF67IOD_0 BIT(001),
     3 SMF67IOD_1 BIT(001),
     3 SMF67IOD_2 BIT(001),
     3 SMF67IOD_3 BIT(001),
     3 SMF67IOD_4 BIT(001),
     3 SMF67IOD_5 BIT(001),
     3 SMF67IOD_6 BIT(001),
     3 SMF67IOD_7 BIT(001),
     2 SMF67CNM   CHAR(044),
     2 SMF67DEN   CHAR(044),
     2 SMF67RSZ   BIT(016),
     2 SMF67CRC   BIT(016);
 DCL 1 SMFRCD68   BASED(ADDR(SMF_UNIQUE)),
     2 SMF68JBN   CHAR(008),
     2 SMF68RST   BIT(032),
     2 SMF68RSD   FIXED DEC(007),
     2 SMF68UIF   CHAR(008),
     2 SMF68CNM   CHAR(044),
     2 SMF68ONM   CHAR(044),
     2 SMF68NNM   CHAR(044);
 DCL 1 SMFRCD69   BASED(ADDR(SMF_UNIQUE)),
     2 SMF69JBN   CHAR(008),
     2 SMF69RST   BIT(032),
     2 SMF69RSD   FIXED DEC(007),
     2 SMF69UIF   CHAR(008),
     2 SMF69CUU   BIT(016),
     2 SMF69IND   BIT(016),
     2 SMF69NDS   BIT(016),
     2 SMF69NUC   BIT(016),
     2 SMF69NUT   BIT(016),
     2 SMF69LNC   BIT(016),
     2 SMF69LNT   BIT(016),
     2 SMF69CNM   CHAR(044),
     2 SMF69VSR   CHAR(006);
 DCL 1 SMFRCD77   BASED(ADDR(SMF_UNIQUE)),
     2 SMF77SSI   CHAR(004),
     2 SMF77STY   BIT(016),
     2 SMF77TRN   BIT(016),
     2 SMF77XX1   BIT(016),
     2 SMF77PRS   BIT(032),
     2 SMF77PRL   BIT(016),
     2 SMF77PRN   BIT(016),
     2 SMF77EQS   BIT(032),
     2 SMF77EQL   BIT(016),
     2 SMF77EQN   BIT(016),
     2 SMF77EDS   BIT(032),
     2 SMF77EDL   BIT(016),
     2 SMF77EDN   FIXED BIN(015),
     2 SMF77MFV   CHAR(002),
     2 SMF77PRD   CHAR(008),
     2 SMF77IST   BIT(032),
     2 SMF77DAT   BIT(032),
     2 SMF77INT   BIT(032),
     2 SMF77MFL   BIT(016),
     2 SMF77SAM   BIT(032),
     2 SMF77RV2   BIT(016),
     2 SMF77FLA   BIT(016),
     2 SMF77RLS   CHAR(004),
     2 SMF77CYC   BIT(032),
     2 SMF77MVS   CHAR(008),
     2 SMF77IML   BIT(008),
     2 SMF77PRF   BIT(008),
     2 SMF77XX2   BIT(016),
     2 SMF77FG1   BIT(008),
     2 SMF77RF2   BIT(008),
     2 SMF77XX3   BIT(016),
     2 SMF77EDX(1024),
     3 SMF77QNM   CHAR(008),
     3 SMF77RNM   CHAR(044),
     3 SMF77WTM   BIT(032),
     3 SMF77WTX   BIT(032),
     3 SMF77WTT   BIT(032),
     3 SMF77RV3   BIT(016),
     3 SMF77QL1   BIT(016),
     3 SMF77QL2   BIT(016),
     3 SMF77QL3   BIT(016),
     3 SMF77QL4   BIT(016),
     3 SMF77QLT   BIT(016),
     3 SMF77EXM   BIT(016),
     3 SMF77EXX   BIT(016),
     3 SMF77SHM   BIT(016),
     3 SMF77SHX   BIT(016),
     3 SMF77EVT   BIT(016),
     3 SMF77RLN   BIT(008),
     3 SMF77DFG   BIT(008),
     3 SMF77DOW   BIT(016),
     3 SMF77DWR   BIT(016),
     3 SMF77DO1   CHAR(008),
     3 SMF77DO2   CHAR(008),
     3 SMF77DW1   CHAR(008),
     3 SMF77DW2   CHAR(008),
     3 SMF77SY1   CHAR(008),
     3 SMF77SY2   CHAR(008),
     3 SMF77SY3   CHAR(008),
     3 SMF77SY4   CHAR(008);
 DCL 1 SMFRCD80   BASED(ADDR(SMF_UNIQUE)),
     2 SMF80DES,
     3 SMF80DES_0 BIT(001),
     3 SMF80DES_1 BIT(001),
     3 SMF80DES_2 BIT(001),
     3 SMF80DES_3 BIT(001),
     3 SMF80DES_4 BIT(12),
     2 SMF80EVT   BIT(008),
     2 SMF80EVQ   BIT(008),
     2 SMF80USR   CHAR(008),
     2 SMF80GRP   CHAR(008),
     2 SMF80REL   BIT(016),
     2 SMF80CNT   FIXED BIN(015),
     2 SMF80ATH,
     3 SMF80ATH_0 BIT(001),
     3 SMF80ATH_1 BIT(001),
     3 SMF80ATH_2 BIT(001),
     3 SMF80ATH_3 BIT(001),
     3 SMF80ATH_4 BIT(001),
     3 SMF80ATH_5 BIT(001),
     3 SMF80ATH_6 BIT(001),
     3 SMF80ATH_7 BIT(001),
     2 SMF80REA,
     3 SMF80REA_0 BIT(001),
     3 SMF80REA_1 BIT(001),
     3 SMF80REA_2 BIT(001),
     3 SMF80REA_3 BIT(001),
     3 SMF80REA_4 BIT(001),
     3 SMF80REA_5 BIT(001),
     3 SMF80REA_6 BIT(001),
     3 SMF80REA_7 BIT(001),
     2 SMF80TLV   BIT(008),
     2 SMF80ERR   BIT(008),
     2 SMF80TRM   CHAR(008),
     2 SMF80JBN   CHAR(008),
     2 SMF80RST   BIT(032),
     2 SMF80RSD   FIXED DEC(007),
     2 SMF80UID   CHAR(008),
     2 SMF80VER   BIT(008),
     2 SMF80RE2   BIT(008),
     2 SMF80RLS(4096) CHAR(001);
 DCL 1 SMF_80_REL BASED(PTR_SMF),
     2 SMF80DTP   BIT(008),
     2 SMF80DLN   BIT(008),
     2 SMF80DTA   CHAR(255);
 DCL 1 SMF80DTA_BITS BASED(ADDR(SMF80DTA)),
     2 SMF80DTA_0 BIT(001),
     2 SMF80DTA_1 BIT(001),
     2 SMF80DTA_2 BIT(001),
     2 SMF80DTA_3 BIT(001),
     2 SMF80DTA_4 BIT(001),
     2 SMF80DTA_5 BIT(001),
     2 SMF80DTA_6 BIT(001),
     2 SMF80DTA_7 BIT(001);
 ON ENDFILE(DAFIN)   FLG_EOF_DAFIN = '1'B;
 ON ENDFILE(DAFSMF)  FLG_EOF_DAFSMF = '1'B;
 ON ENDFILE(DAF2OUT) FLG_EOF_DAF2OUT = '1'B;
 ON ENDFILE(DAF1OUT) FLG_EOF_DAF1OUT = '1'B;
 ON ENDPAGE(DAFRPT) BEGIN;
   CALL PUT_TITLE(DAFRPT,'DAFRPT',2);
   IF DAFXXENM = PREV_DSN THEN
      DO;
        PUT FILE(DAFRPT) SKIP EDIT
            (DAFXXENM,' --  Continued  -- ') ((2)(A));
      END;
   IF DAFXXENM = PREV_DSN THEN
      DO;
        PUT FILE(DAFRPT) SKIP EDIT (DAFXXENM) (A);
      END;
   PUT FILE(DAFRPT) SKIP EDIT (' ') (A);
   PUT FILE(DAFRPT) SKIP EDIT
       ('Date  ','Time        ','CPU  ',
        'Jobname  ','RT ','Volser ') ((6)(A));
 END;
 ON ENDPAGE(DAFXCLD) BEGIN;
   CALL PUT_TITLE(DAFXCLD,'DAFXCLD',4);
   PUT FILE(DAFXCLD) SKIP EDIT
       ('Excluded Datasets','Occurrences') (A,COL(41),A);
   PUT FILE(DAFXCLD) SKIP EDIT (' ') (A);
 END;
 ON FINISH BEGIN;
   IF (FLG_DAFIN_ERROR) THEN
     DO;
       PUT FILE(DAFLOG) SKIP(4) EDIT (' ') (A);
       PUT FILE(DAFLOG) SKIP EDIT
           ('Error    - Invalid DAFIN Control Statement(s)') (A);
       PUT FILE(DAFLOG) SKIP EDIT (' ') (A);
       PUT FILE(DAFLOG) SKIP EDIT
           ('Response - Modify DAFIN Control Statement(s) and Resubmit')
           (A);
       CALL PLIRETC(2);
     END;
   ELSE
   IF (FLG_NONE_SELECTED) THEN
     DO;
       PUT FILE(DAFLOG) SKIP(4) EDIT (' ') (A);
       PUT FILE(DAFLOG) SKIP EDIT
           ('Error    - No DAFSMF Records Selected') (A);
       PUT FILE(DAFLOG) SKIP EDIT (' ') (A);
       PUT FILE(DAFLOG) SKIP EDIT
           ('Response - Modify DAFIN Control Statement(s) and Resubmit')
           (A);
       PUT FILE(DAFLOG) SKIP EDIT
           ('                        And/Or') (A);
       PUT FILE(DAFLOG) SKIP EDIT
        ('           Utilize Different DAFSMF Dataset(s) and Resubmit')
           (A);
       CALL PLIRETC(1);
     END;
   ELSE
   IF (FLG_SORT_ERROR) THEN
     DO;
       PUT FILE(DAFLOG) SKIP(4) EDIT (' ') (A);
       PUT FILE(DAFLOG) SKIP EDIT
           ('Error    - Sort Problem') (A);
       PUT FILE(DAFLOG) SKIP EDIT (' ') (A);
       PUT FILE(DAFLOG) SKIP EDIT
           ('Response - Resolve Sort Problem and Resubmit') (A);
       CALL PLIRETC(3);
     END;
   ELSE
       CALL PLIRETC(0);
   CLOSE FILE (DAFLOG);
 END;
 CALL PRC_DAFIN;
 CALL PRC_DAFSMF;
 CHG_TME: PROC(TME_XXX);
   DCL TME_XXX BIT(032);
   TME_WRK = TME_XXX;
   TME_HH    = TME_WRK / 360000;
   TME_MM    = TME_WRK / 6000 -
               TME_HH * 60;
   TME_SS    = TME_WRK / 100 -
               TME_HH * 3600 -
               TME_MM * 60;
   TME_CC    = TME_WRK -
               TME_HH * 360000 -
               TME_MM * 6000 -
               TME_SS * 100;
   TME_LONG  = TME_HH * 1000000 +
               TME_MM * 10000 +
               TME_SS * 100 +
               TME_CC;
 END CHG_TME;
 CHK_ALL: PROC;
   IF DAFXXENM = LOW(44) THEN DAFXXENM = ' ';
   CALL CHK_DATE;
   IF (FLG_SEL_DATE) THEN CALL CHK_INCLUDE;
   IF (FLG_SEL_DATE) &
      (FLG_SEL_INCLUDE) THEN CALL CHK_EXCLUDE;
   IF (FLG_SEL_DATE) &
      (FLG_SEL_INCLUDE) &
      (FLG_SEL_EXCLUDE) THEN
     DO;
       IF DAFXXENM = ' ' THEN CALL PUT_DAF1IN;
     END;
   IF (FLG_SEL_DATE) &
      (FLG_SEL_INCLUDE) &
      (FLG_SEL_EXCLUDE) THEN
     DO;
       CALL PUT_DAF2IN;
     END;
   DAFXXLNE,WRKXXENM,WRKXXJNM = ' ';
   CTR_TXT = 1;
 END CHK_ALL;
 CHK_CPU: PROC;
   FLG_FND_CPU = '0'B;
   DO CTR_XXX = 1 TO CTR_NCS_CPU;
     IF SUBSTR(DAFXXSID,1,TBL_CPULEN(CTR_XXX)) =
        SUBSTR(TBL_CPUREQ(CTR_XXX),1,TBL_CPULEN(CTR_XXX)) THEN
        FLG_FND_CPU = '1'B;
   END;
   IF (FLG_FND_CPU) THEN FLG_SEL_INCLUDE = '0'B;
 END CHK_CPU;
 CHK_CTR: PROC;
   IF CTR_TXT <=  85 THEN IF CTR_WRK >=  85 THEN CTR_TXT =  86;
   IF CTR_TXT <= 170 THEN IF CTR_WRK >= 170 THEN CTR_TXT = 171;
   IF CTR_TXT <= 255 THEN IF CTR_WRK >= 255 THEN CTR_TXT = 256;
 END CHK_CTR;
 CHK_DATE: PROC;
   FLG_SEL_DATE = '1'B;
   IF DAFXXDTE < DTE_BEG THEN FLG_SEL_DATE = '0'B;
   IF DAFXXDTE > DTE_END THEN FLG_SEL_DATE = '0'B;
 END CHK_DATE;
 CHK_DDN: PROC;
   FLG_FND_DDN = '0'B;
   DO CTR_XXX = 1 TO CTR_NCS_DDN;
     IF SUBSTR(DAFXXDDN,1,TBL_DDNLEN(CTR_XXX)) =
        SUBSTR(TBL_DDNREQ(CTR_XXX),1,TBL_DDNLEN(CTR_XXX)) THEN
        FLG_FND_DDN = '1'B;
   END;
   IF (FLG_FND_DDN) THEN FLG_SEL_INCLUDE = '0'B;
 END CHK_DDN;
 CHK_DSN: PROC;
   FLG_FND_DSN = '0'B;
   DO CTR_XXX = 1 TO CTR_NCS_DSN;
     IF SUBSTR(DAFXXENM,1,TBL_DSNLEN(CTR_XXX)) =
        SUBSTR(TBL_DSNREQ(CTR_XXX),1,TBL_DSNLEN(CTR_XXX)) THEN
        FLG_FND_DSN = '1'B;
     IF SUBSTR(WRKXXENM,1,TBL_DSNLEN(CTR_XXX)) =
        SUBSTR(TBL_DSNREQ(CTR_XXX),1,TBL_DSNLEN(CTR_XXX)) THEN
        FLG_FND_DSN = '1'B;
   END;
   IF (FLG_FND_DSN) THEN FLG_SEL_INCLUDE = '0'B;
 END CHK_DSN;
 CHK_EXCLUDE: PROC;
   FLG_SEL_EXCLUDE = '1'B;
   IF CTR_NCS_XCPU > 0 THEN CALL CHK_XCPU;
   IF CTR_NCS_XDDN > 0 THEN CALL CHK_XDDN;
   IF CTR_NCS_XDSN > 0 THEN CALL CHK_XDSN;
   IF CTR_NCS_XJOB > 0 THEN CALL CHK_XJOB;
   IF CTR_NCS_XVOL > 0 THEN CALL CHK_XVOL;
 END CHK_EXCLUDE;
 CHK_INCLUDE: PROC;
   FLG_SEL_INCLUDE = '1'B;
   IF CTR_NCS_CPU > 0 THEN CALL CHK_CPU;
   IF CTR_NCS_DDN > 0 THEN CALL CHK_DDN;
   IF CTR_NCS_DSN > 0 THEN CALL CHK_DSN;
   IF CTR_NCS_JOB > 0 THEN CALL CHK_JOB;
   IF CTR_NCS_VOL > 0 THEN CALL CHK_VOL;
 END CHK_INCLUDE;
 CHK_JOB: PROC;
   FLG_FND_JOB = '0'B;
   DO CTR_XXX = 1 TO CTR_NCS_JOB;
     IF SUBSTR(DAFXXJNM,1,TBL_JOBLEN(CTR_XXX)) =
        SUBSTR(TBL_JOBREQ(CTR_XXX),1,TBL_JOBLEN(CTR_XXX)) THEN
        FLG_FND_JOB = '1'B;
     IF SUBSTR(WRKXXJNM,1,TBL_JOBLEN(CTR_XXX)) =
        SUBSTR(TBL_JOBREQ(CTR_XXX),1,TBL_JOBLEN(CTR_XXX)) THEN
        FLG_FND_JOB = '1'B;
   END;
   IF (FLG_FND_JOB) THEN FLG_SEL_INCLUDE = '0'B;
 END CHK_JOB;
 CHK_VOL: PROC;
   FLG_FND_VOL = '0'B;
   DO CTR_XXX = 1 TO CTR_NCS_VOL;
     IF SUBSTR(DAFXXVOL,1,TBL_VOLLEN(CTR_XXX)) =
        SUBSTR(TBL_VOLREQ(CTR_XXX),1,TBL_VOLLEN(CTR_XXX)) THEN
        FLG_FND_VOL = '1'B;
   END;
   IF (FLG_FND_VOL) THEN FLG_SEL_INCLUDE = '0'B;
 END CHK_VOL;
 CHK_XCPU: PROC;
   FLG_FND_XCPU = '0'B;
   DO CTR_XXX = 1 TO CTR_NCS_XCPU;
     IF SUBSTR(DAFXXSID,1,TBL_XCPULEN(CTR_XXX)) =
        SUBSTR(TBL_XCPUREQ(CTR_XXX),1,TBL_XCPULEN(CTR_XXX)) THEN
        FLG_FND_XCPU = '1'B;
   END;
   IF (FLG_FND_XCPU) THEN FLG_SEL_EXCLUDE = '0'B;
 END CHK_XCPU;
 CHK_XDDN: PROC;
   FLG_FND_XDDN = '0'B;
   DO CTR_XXX = 1 TO CTR_NCS_XDDN;
     IF SUBSTR(DAFXXDDN,1,TBL_XDDNLEN(CTR_XXX)) =
        SUBSTR(TBL_XDDNREQ(CTR_XXX),1,TBL_XDDNLEN(CTR_XXX)) THEN
        FLG_FND_XDDN = '1'B;
   END;
   IF (FLG_FND_XDDN) THEN FLG_SEL_EXCLUDE = '0'B;
 END CHK_XDDN;
 CHK_XDSN: PROC;
   FLG_FND_XDSN = '0'B;
   DO CTR_XXX = 1 TO CTR_NCS_XDSN;
     IF SUBSTR(DAFXXENM,1,TBL_XDSNLEN(CTR_XXX)) =
        SUBSTR(TBL_XDSNREQ(CTR_XXX),1,TBL_XDSNLEN(CTR_XXX)) THEN
        FLG_FND_XDSN = '1'B;
     IF SUBSTR(WRKXXENM,1,TBL_XDSNLEN(CTR_XXX)) =
        SUBSTR(TBL_XDSNREQ(CTR_XXX),1,TBL_XDSNLEN(CTR_XXX)) THEN
        FLG_FND_XDSN = '1'B;
   END;
   IF (FLG_FND_XDSN) THEN FLG_SEL_EXCLUDE = '0'B;
 END CHK_XDSN;
 CHK_XJOB: PROC;
   FLG_FND_XJOB = '0'B;
   DO CTR_XXX = 1 TO CTR_NCS_XJOB;
     IF SUBSTR(DAFXXJNM,1,TBL_XJOBLEN(CTR_XXX)) =
        SUBSTR(TBL_XJOBREQ(CTR_XXX),1,TBL_XJOBLEN(CTR_XXX)) THEN
        FLG_FND_XJOB = '1'B;
     IF SUBSTR(WRKXXJNM,1,TBL_XJOBLEN(CTR_XXX)) =
        SUBSTR(TBL_XJOBREQ(CTR_XXX),1,TBL_XJOBLEN(CTR_XXX)) THEN
        FLG_FND_XJOB = '1'B;
   END;
   IF (FLG_FND_XJOB) THEN FLG_SEL_EXCLUDE = '0'B;
 END CHK_XJOB;
 CHK_XVOL: PROC;
   FLG_FND_XVOL = '0'B;
   DO CTR_XXX = 1 TO CTR_NCS_XVOL;
     IF SUBSTR(DAFXXVOL,1,TBL_XVOLLEN(CTR_XXX)) =
        SUBSTR(TBL_XVOLREQ(CTR_XXX),1,TBL_XVOLLEN(CTR_XXX)) THEN
        FLG_FND_XVOL = '1'B;
   END;
   IF (FLG_FND_XVOL) THEN FLG_SEL_EXCLUDE = '0'B;
 END CHK_XVOL;
 EXT_DAFSMF: PROC;
   DAFXXSID,DAFXXDDN,DAFXXENM,DAFXXJNM,DAFXXVOL = ' ';
   DAFXXDTE,DAFXXRTY,DAFXXTME = 0;
   DAFXXDTE = SMFXXDTE;
   DAFXXSID = SMFXXSID;
   DAFXXRTY = SMFXXRTY;
   DAFXXTME = SMFXXTME;
   IF (FLG_FUN_CATALOG) THEN
     SELECT (SMFXXRTY);
       WHEN(36) CALL EXT_T36;
       WHEN(60) CALL EXT_T60;
       WHEN(61) CALL EXT_T61;
       WHEN(62) CALL EXT_T62;
       WHEN(63) CALL EXT_T63;
       WHEN(64) CALL EXT_T64;
       WHEN(65) CALL EXT_T65;
       WHEN(66) CALL EXT_T66;
       WHEN(67) CALL EXT_T67;
       WHEN(68) CALL EXT_T68;
       WHEN(69) CALL EXT_T69;
       OTHERWISE;
     END;
   IF (FLG_FUN_DATASET) THEN
     SELECT (SMFXXRTY);
       WHEN(14) CALL EXT_T14;
       WHEN(15) CALL EXT_T14;
       WHEN(17) CALL EXT_T17;
       WHEN(18) CALL EXT_T18;
       OTHERWISE;
     END;
   IF (FLG_FUN_ENQUEUE) THEN
     SELECT (SMFXXRTY);
       WHEN(77) CALL EXT_T77;
       OTHERWISE;
     END;
   IF (FLG_FUN_RACF) THEN
     SELECT (SMFXXRTY);
       WHEN(80) CALL EXT_T80;
       OTHERWISE;
     END;
   CALL CHK_ALL;
 END EXT_DAFSMF;
 EXT_T14: PROC;
   DAFXXENM = JFCBDSNM;
   DAFXXJNM = SMF14JBN;
   DAFXXDDN = SMFTIOE5;
   DAFXXVOL = JFCBVOL1;
   IF SMFTIOE5 = ' ' THEN CALL GET_CHR(' DD=',SMFTIOE5);
   IF JFCBELNM = ' ' THEN
     DO;
       IF JFCGDG = '1'B THEN CALL GET_CHR(' GDG=',JFCBELNM);
       IF JFCPDS = '1'B THEN CALL GET_CHR(' Mem=',JFCBELNM);
     END;
   DTE_WRK = CRDT_YY * 1000;
   DTE_WRK = DTE_WRK + CRDT_DDD;
   DTE_YYDDD = DTE_WRK;
   CALL GET_CHR(' CRDT=',DTE_YYDDD);
   DTE_WRK = XPDT_YY * 1000;
   DTE_WRK = DTE_WRK + XPDT_DDD;
   DTE_YYDDD = DTE_WRK;
   CALL GET_CHR(' XPDT=',DTE_YYDDD);
   IF (JFCORGDA) & (JFCORGU) THEN CALL GET_CHR(' DSORG=','DA');
   IF (JFCORGDA) & (JFCORGU)  THEN CALL GET_CHR(' DSORG=','DAU');
   IF (JFCORGPO) & (JFCORGU) THEN CALL GET_CHR(' DSORG=','PO');
   IF (JFCORGPO) & (JFCORGU)  THEN CALL GET_CHR(' DSORG=','POU');
   IF (JFCORGPS) & (JFCORGU) THEN CALL GET_CHR(' DSORG=','PS');
   IF (JFCORGPS) & (JFCORGU)  THEN CALL GET_CHR(' DSORG=','PSU');
   IF (JFCFIX)  & (JFCVAR) & (JFCRFB) THEN
     CALL GET_CHR(' RECFM=','F');
   IF (JFCFIX)  & (JFCVAR) & (JFCRFB)  THEN
     CALL GET_CHR(' RECFM=','FB');
   IF (JFCFIX)  & (JFCVAR)              THEN
     CALL GET_CHR(' RECFM=','U');
   IF (JFCFIX) & (JFCVAR)  & (JFCRFB) THEN
     CALL GET_CHR(' RECFM=','V');
   IF (JFCFIX) & (JFCVAR)  & (JFCRFB)  THEN
     CALL GET_CHR(' RECFM=','VB');
   CALL GET_BIT(' LRECL=',JFCLRECL);
   CALL GET_BIT(' BLKSZ=',JFCBLKSI);
   CALL GET_BIT(' BUFNO=',JFCBUFNO);
   CALL GET_BIT(' EXCP=',SMFEXCP);
   IF (JFCBCTRI_0)  & (JFCBCTRI_1) THEN CALL GET_CHR(' CTRI=','TRK');
   IF (JFCBCTRI_0) & (JFCBCTRI_1)  THEN CALL GET_CHR(' CTRI=','BLK');
   IF (JFCBCTRI_0)  & (JFCBCTRI_1)  THEN CALL GET_CHR(' CTRI=','CYL');
   CALL GET_BIT(' PQTY=',JFCBPQTY);
   CALL GET_BIT(' SQTY=',JFCBSQTY);
   CALL GET_BIT(' NEX=',SMF14NEX);
   CALL GET_BIT(' NTR=',SMF14NTR);
   CALL GET_BIT(' NER=',SMF14NER);
 END EXT_T14;
 EXT_T17: PROC;
   DAFXXENM = SMF17DSN;
   DAFXXJNM = SMF17JBN;
   DAFXXVOL = SMF17FVL;
 END EXT_T17;
 EXT_T18: PROC;
   DAFXXENM = SMF18ODS;
   WRKXXENM = SMF18NDS;
   DAFXXJNM = SMF18JBN;
   DAFXXVOL = SMF18FVL;
   CALL GET_CHR(' NDS=',SMF18NDS);
   CALL CHK_ALL;
   DAFXXENM = SMF18NDS;
   WRKXXENM = SMF18ODS;
   CALL GET_CHR(' ODS=',SMF18ODS);
 END EXT_T18;
 EXT_T36: PROC;
   DAFXXENM = SMF36CNM;
   WRKXXENM = SMF36PDS;
   DAFXXJNM = SMF36JNM;
   DAFXXVOL = SMF36CVS;
   IF SMF36EIN = 'AE' THEN CALL GET_CHR(' EIN=','Aliases_Exported');
   IF SMF36EIN = 'NE' THEN CALL GET_CHR(' EIN=','Not_Exported');
   CALL GET_CHR(' PDS=',SMF36PDS);
   CALL GET_CHR(' PVS=',SMF36PVS);
   CALL CHK_ALL;
   DAFXXENM = SMF36PDS;
   WRKXXENM = SMF36CNM;
   DAFXXVOL = SMF36PVS;
   IF SMF36EIN = 'AE' THEN CALL GET_CHR(' EIN=','Aliases_Exported');
   IF SMF36EIN = 'NE' THEN CALL GET_CHR(' EIN=','Not_Exported');
   CALL GET_CHR(' CNM=',SMF36CNM);
   CALL GET_CHR(' CVS=',SMF36CVS);
 END EXT_T36;
 EXT_T60: PROC;
   DAFXXENM = SMF60ENM;
   DAFXXJNM = SMF60JNM;
   CALL GET_TYP(SMF60TYP);
   CALL GET_SUB(SMF60SUB);
   CALL GET_CHR(' CNM=',SMF60CNM);
 END EXT_T60;
 EXT_T61: PROC;
   DAFXXENM = SMF61ENM;
   DAFXXJNM = SMF61JNM;
   CALL GET_TYP(SMF61TYP);
   CALL GET_SUB(SMF61SUB);
   CALL GET_CHR(' CNM=',SMF61CNM);
 END EXT_T61;
 EXT_T62: PROC;
   DAFXXENM = SMF62DNM;
   DAFXXJNM = SMF62JBN;
   DAFXXVOL = SMF62VSR;
   CALL GET_CHR(' CNM=',SMF62CNM);
 END EXT_T62;
 EXT_T63: PROC;
   DAFXXENM = SMF63ENM;
   DAFXXJNM = SMF63JBN;
   IF (SMF63FDT_0) THEN CALL GET_CHR(' FDT=','New_Definition');
   IF (SMF63FDT_1) THEN CALL GET_CHR(' FDT=','Altered_Definition');
   IF (SMF63FDT_6) THEN CALL GET_CHR(' FDT=','Path_Def/Alt');
   IF (SMF63FDT_7) THEN CALL GET_CHR(' FDT=','AIX_Def/Alt');
   IF (SMF63TYP_0) THEN CALL GET_CHR(' TYP=','VSAM_Cluster');
   IF (SMF63TYP_1) THEN CALL GET_CHR(' TYP=','VSAM_Data_Component');
   IF (SMF63TYP_2) THEN CALL GET_CHR(' TYP=','VSAM_Index_Component');
   IF (SMF63TYP_3) THEN CALL GET_CHR(' TYP=','VSAM_Catalog');
   IF (SMF63TYP_4) THEN CALL GET_CHR(' TYP=','Non-VSAM_Data_Set');
   IF (SMF63TYP_5) THEN CALL GET_CHR(' TYP=','Generation_Data_Group');
   IF (SMF63TYP_6) THEN CALL GET_CHR(' TYP=','Alias');
   CALL GET_CHR(' CNM=',SMF63CNM);
 END EXT_T63;
 EXT_T64: PROC;
   PTR_SMF = ADDR(FIL64EXT(SMF64ESL-25));
   DAFXXDDN = SMF64DDN;
   DAFXXENM = SMF64DNM;
   DAFXXJNM = SMF64JBN;
   DAFXXVOL = SMF64VSN;
   CALL GET_BIT(' NIL=',SMF64NIL);
   CALL GET_BIT(' NEX=',SMF64NEX);
   CALL GET_BIT(' NLR=',SMF64NLR);
   CALL GET_BIT(' NDE=',SMF64NDE);
   CALL GET_BIT(' NIN=',SMF64NIN);
   CALL GET_BIT(' NUP=',SMF64NUP);
   CALL GET_BIT(' NRE=',SMF64NRE);
   CALL GET_BIT(' NCS=',SMF64NCS);
   CALL GET_BIT(' NAS=',SMF64NAS);
   CALL GET_BIT(' NEP=',SMF64NEP);
   CALL GET_BIT(' DIL=',SMF64DIL);
   CALL GET_BIT(' DEX=',SMF64DEX);
   CALL GET_BIT(' DLR=',SMF64DLR);
   CALL GET_BIT(' DDE=',SMF64DDE);
   CALL GET_BIT(' DIN=',SMF64DIN);
   CALL GET_BIT(' DUP=',SMF64DUP);
   CALL GET_BIT(' DRE=',SMF64DRE);
   CALL GET_BIT(' DCS=',SMF64DCS);
   CALL GET_BIT(' DAS=',SMF64DAS);
   CALL GET_BIT(' DEP=',SMF64DEP);
   CALL GET_BIT(' DCI=',SMF64DCI);
   CALL GET_BIT(' DKL=',SMF64DKL);
   CALL GET_BIT(' DLS=',SMF64DLS);
   CALL GET_BIT(' DBS=',SMF64DBS);
   CALL GET_CHR(' CNM=',SMF64CNM);
   CALL GET_CHR(' DDN=',SMF64DDN);
   IF (SMF64RIN_0) THEN CALL GET_CHR(' RIN=','Component_Closed');
   IF (SMF64RIN_1) THEN CALL GET_CHR(' RIN=','Volume_Switched');
   IF (SMF64RIN_2) THEN CALL GET_CHR(' RIN=','No_Space_Available');
   IF (SMF64RIN_3) THEN CALL GET_CHR(' RIN=','Catalog/CRA_Record');
   IF (SMF64RIN_4) THEN CALL GET_CHR(' RIN=','TYPE=T');
   IF (SMF64RIN_5) THEN CALL GET_CHR(' RIN=','ABEND');
   IF (SMF64RIN_6) THEN CALL GET_CHR(' RIN=','VVDS/ICF_Catalog');
   IF (SMF64DTY_0) THEN CALL GET_CHR(' DTY=','Data_Component');
   IF (SMF64DTY_1) THEN CALL GET_CHR(' DTY=','Index_Component');
 END EXT_T64;
 EXT_T65: PROC;
   DAFXXENM = SMF65ENM;
   DAFXXJNM = SMF65JNM;
   CALL GET_FNC(SMF65FNC);
   CALL GET_TYP(SMF65TYP);
   CALL GET_SUB(SMF65SUB);
   CALL GET_CHR(' CNM=',SMF65CNM);
 END EXT_T65;
 EXT_T66: PROC;
   DAFXXENM = SMF66ENM;
   IF SMF66FNC = 'R' THEN WRKXXENM = SMF66NNM;
   DAFXXJNM = SMF66JNM;
   CALL GET_FNC(SMF66FNC);
   CALL GET_TYP(SMF66TYP);
   CALL GET_SUB(SMF66SUB);
   IF SMF66FNC = 'R'  THEN CALL GET_CHR(' NNM=',SMF66NNM);
   CALL GET_CHR(' CNM=',SMF66CNM);
   IF SMF66FNC = 'R' THEN
     DO;
       CALL CHK_ALL;
       DAFXXENM = SMF66NNM;
       WRKXXENM = SMF66ENM;
       CALL GET_FNC(SMF66FNC);
       CALL GET_TYP(SMF66TYP);
       CALL GET_SUB(SMF66SUB);
       CALL GET_CHR(' ENM=',SMF66ENM);
       CALL GET_CHR(' CNM=',SMF66CNM);
     END;
 END EXT_T66;
 EXT_T67: PROC;
   DAFXXENM = SMF67DEN;
   DAFXXJNM = SMF67JBN;
   IF (SMF67FDT_0) THEN CALL GET_CHR(' FDT=','Uncataloged');
   IF (SMF67FDT_1) THEN CALL GET_CHR(' FDT=','Scratched');
   IF (SMF67FDT_6) THEN CALL GET_CHR(' FDT=','Path_Deleted');
   IF (SMF67FDT_7) THEN CALL GET_CHR(' FDT=','AIX_Deleted');
   IF (SMF67IOD_0) THEN CALL GET_CHR(' IOD=','VSAM_Cluster');
   IF (SMF67IOD_1) THEN CALL GET_CHR(' IOD=','VSAM_Data_Component');
   IF (SMF67IOD_2) THEN CALL GET_CHR(' IOD=','VSAM_Index_Component');
   IF (SMF67IOD_3) THEN CALL GET_CHR(' IOD=','VSAM_Catalog');
   IF (SMF67IOD_4) THEN CALL GET_CHR(' IOD=','Non-VSAM_Data_Set');
   IF (SMF67IOD_5) THEN CALL GET_CHR(' IOD=','Generation_Data_Group');
   IF (SMF67IOD_6) THEN CALL GET_CHR(' IOD=','Alias');
   CALL GET_CHR(' CNM=',SMF67CNM);
 END EXT_T67;
 EXT_T68: PROC;
   DAFXXENM = SMF68ONM;
   WRKXXENM = SMF68NNM;
   DAFXXJNM = SMF68JBN;
   CALL GET_CHR(' NNM=',SMF68NNM);
   CALL GET_CHR(' CNM=',SMF68CNM);
   CALL CHK_ALL;
   DAFXXENM = SMF68NNM;
   WRKXXENM = SMF68ONM;
   CALL GET_CHR(' ONM=',SMF68ONM);
   CALL GET_CHR(' CNM=',SMF68CNM);
 END EXT_T68;
 EXT_T69: PROC;
   DAFXXENM = SMF69CNM;
   DAFXXJNM = SMF69JBN;
   DAFXXVOL = SMF69VSR;
   CALL GET_BIT(' NDS=',SMF69NDS);
   CALL GET_BIT(' NUC=',SMF69NUC);
   CALL GET_BIT(' NUT=',SMF69NUT);
   CALL GET_BIT(' LNC=',SMF69LNC);
   CALL GET_BIT(' LNT=',SMF69LNT);
 END EXT_T69;
 EXT_T77: PROC;
 DCL CTR_ENQ FIXED BIN(031,0) INIT(0);
   CTR_ENQ = 1;
   DO WHILE (CTR_ENQ <= SMF77EDN);
     IF CTR_ENQ = 1 THEN CALL CHK_ALL;
     DAFXXENM = SMF77RNM(CTR_ENQ);
     DAFXXJNM = SMF77DO1(CTR_ENQ);
     WRKXXJNM = SMF77DW1(CTR_ENQ);
     CALL GET_CHR(' QNM=',SMF77QNM(CTR_ENQ));
     CALL GET_CHR(' DW1=',SMF77DW1(CTR_ENQ));
     CALL GET_BIT(' WTX=',SMF77WTX(CTR_ENQ));
     CALL GET_BIT(' EXX=',SMF77EXX(CTR_ENQ));
     CALL GET_BIT(' SHX=',SMF77SHX(CTR_ENQ));
     CTR_ENQ = CTR_ENQ + 1;
   END;
 END EXT_T77;
 EXT_T80: PROC;
   DCL CTR_RACF FIXED BIN(031,0) INIT(0);
   SELECT (SMF80EVT);
     WHEN(2,3,4,5,6,7)
       DO;
         DAFXXJNM = SMF80JBN;
         WRKXXJNM = SMF80USR;
         CALL GET_CHR(' USR=',SMF80USR);
         CALL GET_CHR(' GRP=',SMF80GRP);
         CALL GET_CHR(' TRM=',SMF80TRM);
         IF (SMF80DES_0) THEN CALL GET_CHR(' DES=','Violation');
         IF (SMF80DES_3) THEN CALL GET_CHR(' DES=','Warning');
         IF (SMF80ATH_0) THEN CALL GET_CHR(' ATH=','Normal');
         IF (SMF80ATH_1) THEN CALL GET_CHR(' ATH=','SPECIAL');
         IF (SMF80ATH_2) THEN CALL GET_CHR(' ATH=','OPERATIONS');
         IF (SMF80ATH_3) THEN CALL GET_CHR(' ATH=','AUDITOR');
         IF (SMF80ATH_4) THEN CALL GET_CHR(' ATH=','Exit');
         IF (SMF80ATH_5) THEN CALL GET_CHR(' ATH=','Failsoft');
         IF (SMF80REA_0) THEN CALL GET_CHR(' REA=','Profile_Change');
         IF (SMF80REA_1) THEN CALL GET_CHR(' REA=','User_Audit');
         IF (SMF80REA_2) THEN CALL GET_CHR(' REA=','SPECIAL_Audit');
         IF (SMF80REA_3) THEN
             CALL GET_CHR(' REA=','AUDIT/Exit/Failsoft');
         IF (SMF80REA_4) THEN CALL GET_CHR(' REA=','RACINIT_Failure');
         IF (SMF80REA_5) THEN CALL GET_CHR(' REA=','Command_Audit');
         IF (SMF80REA_6) THEN CALL GET_CHR(' REA=','CMDVIOL');
         IF (SMF80REA_7) THEN CALL GET_CHR(' REA=','Global_Audit');
         CTR_RACF = 1;
         FLG_CLASS_DATASET = '0'B;
         PTR_SMF = ADDR(SMF80RLS);
         DO WHILE (SMF80CNT > 0);
           SELECT (SMF80DTP);
             WHEN(1)
               DO;
                 DAFXXENM = SUBSTR(SMF80DTA,1,SMF80DLN);
               END;
             WHEN(2)
               DO;
                 WRKXXENM = SUBSTR(SMF80DTA,1,SMF80DLN);
               END;
             WHEN(3)
               DO;
                 IF (SMF80DTA_0) THEN CALL GET_CHR(' AAR=','Alter');
                 IF (SMF80DTA_1) THEN CALL GET_CHR(' AAR=','Control');
                 IF (SMF80DTA_2) THEN CALL GET_CHR(' AAR=','Update');
                 IF (SMF80DTA_3) THEN CALL GET_CHR(' AAR=','Read');
                 IF (SMF80DTA_4) THEN CALL GET_CHR(' AAR=','None');
               END;
             WHEN(4)
               DO;
                 IF (SMF80DTA_0) THEN CALL GET_CHR(' AAA=','Alter');
                 IF (SMF80DTA_1) THEN CALL GET_CHR(' AAA=','Control');
                 IF (SMF80DTA_2) THEN CALL GET_CHR(' AAA=','Update');
                 IF (SMF80DTA_3) THEN CALL GET_CHR(' AAA=','Read');
                 IF (SMF80DTA_4) THEN CALL GET_CHR(' AAA=','None');
               END;
             WHEN(8)
               DO;
                 WRKXXNME = SUBSTR(SMF80DTA,1,SMF80DLN);
                 CTR_WRK = SMF80DLN;
                 DO WHILE(SUBSTR(WRKXXNME,CTR_WRK,1) = ' ');
                   CTR_WRK = CTR_WRK - 1;
                 END;
                 DO CTR_XXX = 1 TO CTR_WRK;
                   IF SUBSTR(WRKXXNME,CTR_XXX,1) = ' ' THEN
                     SUBSTR(WRKXXNME,CTR_XXX,1) = '_';
                 END;
                 CALL GET_CHR(' NME=',SUBSTR(WRKXXNME,1,SMF80DLN));
               END;
             WHEN(15,16)
               DO;
                 DAFXXVOL = SUBSTR(SMF80DTA,1,SMF80DLN);
               END;
             WHEN(17)
               DO;
                 IF SUBSTR(SMF80DTA,1,SMF80DLN) = 'DATASET ' THEN
                    FLG_CLASS_DATASET = '1'B;
               END;
             WHEN(33)
               DO;
                CALL GET_CHR(' PRF=',SUBSTR(SMF80DTA,2,(SMF80DLN-1)));
                 IF (SMF80DTA_0) THEN
                   CALL GET_CHR(' ','Resource_Name_is_Generic');
                 IF (SMF80DTA_1) THEN
                   CALL GET_CHR(' ','Old_Name');
               END;
             OTHERWISE;
           END;
           CTR_RACF = CTR_RACF + SMF80DLN + 2;
           PTR_SMF = ADDR(SMF80RLS(CTR_RACF));
           SMF80CNT = SMF80CNT - 1;
         END;
         IF FLG_CLASS_DATASET = '0'B THEN DAFXXENM = ' ';
       END;
     OTHERWISE;
   END;
 END EXT_T80;
 GET_BIT: PROC(SMFXXLIT,SMFXXNUM);
   DCL SMFXXLIT CHAR(*);
   DCL SMFXXNUM BIT(*);
   DCL CTR_BIT FIXED BIN(031,0) INIT(0);
   DCL CTR_NUM FIXED BIN(031,0) INIT(0);
   WRK_NUM = SMFXXNUM;
   CTR_BIT = 0;
   DO CTR_NUM = 1 TO 10;
     IF SUBSTR(WRK_NUM,CTR_NUM,1) = ' ' THEN CTR_BIT = CTR_BIT + 1;
   END;
   CTR_WRK = CTR_TXT + CTR_BIT + LENGTH(SMFXXLIT);
   CALL CHK_CTR;
   SUBSTR(DAFXXLNE,CTR_TXT,LENGTH(SMFXXLIT)) = SMFXXLIT;
   CTR_TXT = CTR_TXT + LENGTH(SMFXXLIT);
   SUBSTR(DAFXXLNE,CTR_TXT,CTR_BIT) =
          SUBSTR(WRK_NUM,10-CTR_BIT+1,CTR_BIT);
   CTR_TXT = CTR_TXT + CTR_BIT;
 END GET_BIT;
 GET_CHR: PROC(SMFXXLIT,SMFXXTXT);
   DCL SMFXXLIT CHAR(*);
   DCL SMFXXTXT CHAR(*);
   DCL CTR_CHR  FIXED BIN(031,0) INIT(0);
   CTR_CHR = INDEX(SMFXXTXT,' ');
   IF CTR_CHR = 0 THEN CTR_CHR = LENGTH(SMFXXTXT);
   ELSE CTR_CHR = CTR_CHR - 1;
   CTR_WRK = CTR_TXT + CTR_CHR + LENGTH(SMFXXLIT);
   CALL CHK_CTR;
   IF SUBSTR(SMFXXTXT,1,1) = LOW(1) THEN
     DO;
       SUBSTR(DAFXXLNE,CTR_TXT,LENGTH(SMFXXLIT)) = SMFXXLIT;
       CTR_TXT = CTR_TXT + LENGTH(SMFXXLIT);
       SUBSTR(DAFXXLNE,CTR_TXT,CTR_CHR) = SMFXXTXT;
       CTR_TXT = CTR_TXT + CTR_CHR;
     END;
 END GET_CHR;
 GET_FNC: PROC(SMFXXFNC);
   DCL SMFXXFNC CHAR(001);
   IF SMFXXFNC = 'R' THEN CALL GET_CHR(' FNC=','Rename');
   IF SMFXXFNC = 'S' THEN CALL GET_CHR(' FNC=','Scratch');
   IF SMFXXFNC = 'U' THEN CALL GET_CHR(' FNC=','Uncatalog');
 END GET_FNC;
 GET_DAFSMF: PROC;
   READ FILE(DAFSMF) INTO(SMF_LGCL);
   IF SMFXXDTE = DTE_HGH THEN
     DO;
       IF SMFXXTME > TME_HGH THEN TME_HGH = SMFXXTME;
     END;
   IF SMFXXDTE > DTE_HGH THEN
     DO;
       DTE_HGH = SMFXXDTE;
       TME_HGH = SMFXXTME;
     END;
   IF SMFXXDTE = DTE_LOW THEN
     DO;
       IF SMFXXTME < TME_LOW THEN TME_LOW = SMFXXTME;
     END;
   IF SMFXXDTE < DTE_LOW THEN
     DO;
       DTE_LOW = SMFXXDTE;
       TME_LOW = SMFXXTME;
     END;
   SELECT (SMFXXRTY);
     WHEN(14,15,17,18,36,60,61,62,63,64,65,66,67,68,69,77,80)
       CTR_DAFSMF(SMFXXRTY) = CTR_DAFSMF(SMFXXRTY) + 1;
     OTHERWISE CTR_DAFSMF(128) = CTR_DAFSMF(128) + 1;
   END;
   SELECT (SMFXXRTY);
     WHEN(14,15,17,18) CTR_DAFSMF(131) = CTR_DAFSMF(131) + 1;
     WHEN(36,60,61,62,63,64,65,66,67,68,69)
       CTR_DAFSMF(130) = CTR_DAFSMF(130) + 1;
     WHEN(77) CTR_DAFSMF(132) = CTR_DAFSMF(132) + 1;
     WHEN(80) CTR_DAFSMF(133) = CTR_DAFSMF(133) + 1;
     OTHERWISE;
   END;
 END GET_DAFSMF;
 GET_SUB: PROC(SMFXXSUB);
   DCL SMFXXSUB CHAR(002);
   IF SMFXXSUB = 'DE' THEN CALL GET_CHR(' SUB=','Delete');
   IF SMFXXSUB = 'IN' THEN CALL GET_CHR(' SUB=','Insert');
   IF SMFXXSUB = 'UP' THEN CALL GET_CHR(' SUB=','Update');
 END GET_SUB;
 GET_TYP: PROC(SMFXXTYP);
   DCL SMFXXTYP CHAR(001);
   IF SMFXXTYP = 'A' THEN CALL GET_CHR(' TYP=','Nonvsam');
   IF SMFXXTYP = 'B' THEN CALL GET_CHR(' TYP=','GDG');
   IF SMFXXTYP = 'C' THEN CALL GET_CHR(' TYP=','Cluster');
   IF SMFXXTYP = 'D' THEN CALL GET_CHR(' TYP=','Data');
   IF SMFXXTYP = 'E' THEN CALL GET_CHR(' TYP=','VSAM_Extension');
   IF SMFXXTYP = 'G' THEN CALL GET_CHR(' TYP=','AIX');
   IF SMFXXTYP = 'H' THEN CALL GET_CHR(' TYP=','GDS');
   IF SMFXXTYP = 'I' THEN CALL GET_CHR(' TYP=','Index');
   IF SMFXXTYP = 'J' THEN CALL GET_CHR(' TYP=','GDG_Extension');
   IF SMFXXTYP = 'M' THEN CALL GET_CHR(' TYP=','Mastercat');
   IF SMFXXTYP = 'R' THEN CALL GET_CHR(' TYP=','Path');
   IF SMFXXTYP = 'T' THEN CALL GET_CHR(' TYP=','True');
   IF SMFXXTYP = 'U' THEN CALL GET_CHR(' TYP=','Usercat');
   IF SMFXXTYP = 'V' THEN CALL GET_CHR(' TYP=','Volume');
   IF SMFXXTYP = 'X' THEN CALL GET_CHR(' TYP=','Alias');
 END GET_TYP;
 PRC_DAFIN: PROC;
   DCL CTR_BCS FIXED BIN(031,0) INIT(0);
   DCL CTR_ECS FIXED BIN(031,0) INIT(0);
   OPEN FILE (DAFIN) INPUT;
   OPEN FILE (DAF1IN) OUTPUT;
   DTE_RUN = DATE;
   TME_RUN = SUBSTR(TIME,1,6);
   OPEN FILE (DAFLOG) PRINT LINESIZE(132);
   CALL PUT_TITLE(DAFLOG,'DAFLOG',1);
   PUT FILE(DAFLOG) SKIP EDIT ('DAFIN Control Statements:') (A);
   PUT FILE(DAFLOG) SKIP EDIT (' ') (A);
   READ FILE(DAFIN) INTO(DAFIN_REC);
   DO WHILE(FLG_EOF_DAFIN);
     CTR_DAFIN = CTR_DAFIN + 1;
     CTR_BCS = 1;
     DO WHILE(SUBSTR(DAFIN_REC,CTR_BCS,1) = ' ');
       CTR_BCS = CTR_BCS + 1;
     END;
     CTR_ECS = CTR_BCS;
     DO WHILE(SUBSTR(DAFIN_REC,CTR_ECS,1) = ' ');
       CTR_ECS = CTR_ECS + 1;
     END;
     DAFXXDCS = ' ';
     DAFXXDCS = SUBSTR(DAFIN_REC,1,CTR_ECS);
     SELECT (SUBSTR(DAFIN_REC,CTR_BCS,4));
       WHEN('BEG=')
         DO;
           DTE_BEG = SUBSTR(DAFIN_REC,CTR_ECS-5,5);
         END;
       WHEN('CPU=')
         DO;
           CTR_NCS_CPU = CTR_NCS_CPU + 1;
           TBL_CPULEN(CTR_NCS_CPU) = CTR_ECS - CTR_BCS - 4;
           TBL_CPUREQ(CTR_NCS_CPU) =
             SUBSTR(DAFIN_REC,CTR_BCS+4,TBL_CPULEN(CTR_NCS_CPU));
         END;
       WHEN('DDN=')
         DO;
           CTR_NCS_DDN = CTR_NCS_DDN + 1;
           TBL_DDNLEN(CTR_NCS_DDN) = CTR_ECS - CTR_BCS - 4;
           TBL_DDNREQ(CTR_NCS_DDN) =
             SUBSTR(DAFIN_REC,CTR_BCS+4,TBL_DDNLEN(CTR_NCS_DDN));
         END;
       WHEN('DSN=')
         DO;
           CTR_NCS_DSN = CTR_NCS_DSN + 1;
           TBL_DSNLEN(CTR_NCS_DSN) = CTR_ECS - CTR_BCS - 4;
           TBL_DSNREQ(CTR_NCS_DSN) =
             SUBSTR(DAFIN_REC,CTR_BCS+4,TBL_DSNLEN(CTR_NCS_DSN));
         END;
       WHEN('END=')
         DO;
           DTE_END = SUBSTR(DAFIN_REC,CTR_ECS-5,5);
         END;
       WHEN('FUN=')
         DO CTR_XXX = CTR_BCS+4 TO CTR_ECS;
           IF SUBSTR(DAFIN_REC,CTR_XXX,1) = 'C' THEN
             DO;
               CTR_NCS_FUN = CTR_NCS_FUN + 1;
               FLG_FUN_CATALOG = '1'B;
             END;
           IF SUBSTR(DAFIN_REC,CTR_XXX,1) = 'D' THEN
             DO;
               CTR_NCS_FUN = CTR_NCS_FUN + 1;
               FLG_FUN_DATASET = '1'B;
             END;
           IF SUBSTR(DAFIN_REC,CTR_XXX,1) = 'E' THEN
             DO;
               CTR_NCS_FUN = CTR_NCS_FUN + 1;
               FLG_FUN_ENQUEUE = '1'B;
             END;
           IF SUBSTR(DAFIN_REC,CTR_XXX,1) = 'R' THEN
             DO;
               CTR_NCS_FUN = CTR_NCS_FUN + 1;
               FLG_FUN_RACF = '1'B;
             END;
         END;
       WHEN('JOB=')
         DO;
           CTR_NCS_JOB = CTR_NCS_JOB + 1;
           TBL_JOBLEN(CTR_NCS_JOB) = CTR_ECS - CTR_BCS - 4;
           TBL_JOBREQ(CTR_NCS_JOB) =
             SUBSTR(DAFIN_REC,CTR_BCS+4,TBL_JOBLEN(CTR_NCS_JOB));
         END;
       WHEN('VOL=')
         DO;
           CTR_NCS_VOL = CTR_NCS_VOL + 1;
           TBL_VOLLEN(CTR_NCS_VOL) = CTR_ECS - CTR_BCS - 4;
           TBL_VOLREQ(CTR_NCS_VOL) =
             SUBSTR(DAFIN_REC,CTR_BCS+4,TBL_VOLLEN(CTR_NCS_VOL));
         END;
       WHEN('XCPU')
         DO;
           CTR_NCS_XCPU = CTR_NCS_XCPU + 1;
           TBL_XCPULEN(CTR_NCS_XCPU) = CTR_ECS - CTR_BCS - 5;
           TBL_XCPUREQ(CTR_NCS_XCPU) =
             SUBSTR(DAFIN_REC,CTR_BCS+5,TBL_XCPULEN(CTR_NCS_XCPU));
         END;
       WHEN('XDDN')
         DO;
           CTR_NCS_XDDN = CTR_NCS_XDDN + 1;
           TBL_XDDNLEN(CTR_NCS_XDDN) = CTR_ECS - CTR_BCS - 5;
           TBL_XDDNREQ(CTR_NCS_XDDN) =
             SUBSTR(DAFIN_REC,CTR_BCS+5,TBL_XDDNLEN(CTR_NCS_XDDN));
         END;
       WHEN('XDSN')
         DO;
           CTR_NCS_XDSN = CTR_NCS_XDSN + 1;
           TBL_XDSNLEN(CTR_NCS_XDSN) = CTR_ECS - CTR_BCS - 5;
           TBL_XDSNREQ(CTR_NCS_XDSN) =
             SUBSTR(DAFIN_REC,CTR_BCS+5,TBL_XDSNLEN(CTR_NCS_XDSN));
         END;
       WHEN('XFUN')
         DO CTR_XXX = CTR_BCS+5 TO CTR_ECS;
           IF SUBSTR(DAFIN_REC,CTR_XXX,1) = 'C' THEN
             DO;
               CTR_NCS_XFUN = CTR_NCS_XFUN + 1;
               FLG_XFUN_CATALOG = '1'B;
             END;
           IF SUBSTR(DAFIN_REC,CTR_XXX,1) = 'D' THEN
             DO;
               CTR_NCS_XFUN = CTR_NCS_XFUN + 1;
               FLG_XFUN_DATASET = '1'B;
             END;
           IF SUBSTR(DAFIN_REC,CTR_XXX,1) = 'E' THEN
             DO;
               CTR_NCS_XFUN = CTR_NCS_XFUN + 1;
               FLG_XFUN_ENQUEUE = '1'B;
             END;
           IF SUBSTR(DAFIN_REC,CTR_XXX,1) = 'R' THEN
             DO;
               CTR_NCS_XFUN = CTR_NCS_XFUN + 1;
               FLG_XFUN_RACF = '1'B;
             END;
         END;
       WHEN('XJOB')
         DO;
           CTR_NCS_XJOB = CTR_NCS_XJOB + 1;
           TBL_XJOBLEN(CTR_NCS_XJOB) = CTR_ECS - CTR_BCS - 5;
           TBL_XJOBREQ(CTR_NCS_XJOB) =
             SUBSTR(DAFIN_REC,CTR_BCS+5,TBL_XJOBLEN(CTR_NCS_XJOB));
         END;
       WHEN('XVOL')
         DO;
           CTR_NCS_XVOL = CTR_NCS_XVOL + 1;
           TBL_XVOLLEN(CTR_NCS_XVOL) = CTR_ECS - CTR_BCS - 5;
           TBL_XVOLREQ(CTR_NCS_XVOL) =
             SUBSTR(DAFIN_REC,CTR_BCS+5,TBL_XVOLLEN(CTR_NCS_XVOL));
         END;
       OTHERWISE
         DO;
          SUBSTR(DAFXXDCS,CTR_ECS+2,CTR_ECS+15) = '*** Error ***';
          FLG_DAFIN_ERROR = '1'B;
         END;
     END;
     PUT FILE(DAFLOG) SKIP EDIT (DAFXXDCS) (A);
     READ FILE(DAFIN) INTO(DAFIN_REC);
   END;
   CLOSE FILE (DAFIN);
   IF (FLG_DAFIN_ERROR) THEN STOP;
   IF CTR_DAFIN = 0 THEN
     PUT FILE(DAFLOG) SKIP EDIT ('None Specified') (A);
   PUT FILE(DAFLOG) SKIP(4) EDIT (' ') (A);
   PUT FILE(DAFLOG) SKIP EDIT ('Date Criteria:') (A);
   PUT FILE(DAFLOG) SKIP EDIT (' ') (A);
   IF DTE_BEG = 00000 THEN
     DO;
       PUT FILE(DAFLOG) SKIP EDIT
           ('BEGin Date .... 00000 (Default)') (A);
     END;
   ELSE
     DO;
       DTE_WRK = DTE_BEG;
       PUT FILE(DAFLOG) SKIP EDIT
           ('BEGin Date .... ',DTE_WRK) ((2)(A));
     END;
   IF DTE_END = 99366 THEN
     DO;
       PUT FILE(DAFLOG) SKIP EDIT
           ('END Date ...... 99366 (Default)') (A);
     END;
   ELSE
     DO;
       DTE_WRK = DTE_END;
       PUT FILE(DAFLOG) SKIP EDIT
           ('END Date ...... ',DTE_WRK) ((2)(A));
     END;
   PUT FILE(DAFLOG) SKIP EDIT (' ') (A);
   PUT FILE(DAFLOG) SKIP EDIT ('Include Criteria:') (A);
   PUT FILE(DAFLOG) SKIP EDIT (' ') (A);
   IF CTR_NCS_CPU = 0 THEN
      DO;
         PUT FILE(DAFLOG) SKIP EDIT
             ('CPUs .......... All (Default)') (A);
      END;
   ELSE
      DO;
         DO CTR_XXX = 1 TO CTR_NCS_CPU;
           PUT FILE(DAFLOG) SKIP EDIT
               ('CPUs .......... ',TBL_CPUREQ(CTR_XXX))
               ((2)(A));
         END;
      END;
   IF CTR_NCS_DDN = 0 THEN
      DO;
         PUT FILE(DAFLOG) SKIP EDIT
             ('DDNames ....... All (Default)') (A);
      END;
   ELSE
      DO;
         DO CTR_XXX = 1 TO CTR_NCS_DDN;
           PUT FILE(DAFLOG) SKIP EDIT
               ('DDNames ....... ',TBL_DDNREQ(CTR_XXX))
               ((2)(A));
         END;
      END;
   IF CTR_NCS_DSN = 0 THEN
      DO;
         PUT FILE(DAFLOG) SKIP EDIT
             ('DSNames ....... All (Default)') (A);
      END;
   ELSE
      DO;
         DO CTR_XXX = 1 TO CTR_NCS_DSN;
           PUT FILE(DAFLOG) SKIP EDIT
               ('DSNames ....... ',TBL_DSNREQ(CTR_XXX))
               ((2)(A));
         END;
      END;
   IF CTR_NCS_FUN = 0 THEN
     DO;
       FLG_FUN_CATALOG = '1'B;
       FLG_FUN_DATASET = '1'B;
       FLG_FUN_ENQUEUE = '1'B;
       FLG_FUN_RACF    = '1'B;
       PUT FILE(DAFLOG) SKIP EDIT
           ('FUNctions ..... All (Default)') (A);
      END;
   ELSE
      DO;
         IF (FLG_FUN_CATALOG) THEN PUT FILE(DAFLOG) SKIP EDIT
            ('FUNctions ..... Catalog') (A);
         IF (FLG_FUN_DATASET) THEN PUT FILE(DAFLOG) SKIP EDIT
            ('FUNctions ..... Dataset') (A);
         IF (FLG_FUN_ENQUEUE) THEN PUT FILE(DAFLOG) SKIP EDIT
            ('FUNctions ..... Enqueue') (A);
         IF (FLG_FUN_RACF) THEN PUT FILE(DAFLOG) SKIP EDIT
            ('FUNctions ..... RACF') (A);
      END;
   IF CTR_NCS_JOB = 0 THEN
     DO;
       PUT FILE(DAFLOG) SKIP EDIT
           ('JOBs .......... All (Default)') (A);
      END;
   ELSE
      DO;
         DO CTR_XXX = 1 TO CTR_NCS_JOB;
           PUT FILE(DAFLOG) SKIP EDIT
               ('JOBs .......... ',TBL_JOBREQ(CTR_XXX))
               ((2)(A));
         END;
      END;
   IF CTR_NCS_VOL = 0 THEN
     DO;
       PUT FILE(DAFLOG) SKIP EDIT
           ('VOLumes ....... All (Default)') (A);
      END;
   ELSE
      DO;
         DO CTR_XXX = 1 TO CTR_NCS_VOL;
           PUT FILE(DAFLOG) SKIP EDIT
               ('VOLumes ....... ',TBL_VOLREQ(CTR_XXX))
               ((2)(A));
         END;
      END;
   PUT FILE(DAFLOG) SKIP EDIT (' ') (A);
   PUT FILE(DAFLOG) SKIP EDIT ('Exclude Criteria:') (A);
   PUT FILE(DAFLOG) SKIP EDIT (' ') (A);
   IF CTR_NCS_XCPU = 0 THEN
      DO;
         PUT FILE(DAFLOG) SKIP EDIT
             ('XCPUs ......... None (Default)') (A);
      END;
   ELSE
      DO;
         DO CTR_XXX = 1 TO CTR_NCS_XCPU;
           PUT FILE(DAFLOG) SKIP EDIT
               ('XCPUs ......... ',TBL_XCPUREQ(CTR_XXX))
               ((2)(A));
         END;
      END;
   IF CTR_NCS_XDDN = 0 THEN
      DO;
         PUT FILE(DAFLOG) SKIP EDIT
             ('XDDNames ...... None (Default)') (A);
      END;
   ELSE
      DO;
         DO CTR_XXX = 1 TO CTR_NCS_XDDN;
           PUT FILE(DAFLOG) SKIP EDIT
               ('XDDNames ...... ',TBL_XDDNREQ(CTR_XXX))
               ((2)(A));
         END;
      END;
   IF CTR_NCS_XDSN = 0 THEN
      DO;
         PUT FILE(DAFLOG) SKIP EDIT
             ('XDSNames ...... None (Default)') (A);
      END;
   ELSE
      DO;
         DO CTR_XXX = 1 TO CTR_NCS_XDSN;
           PUT FILE(DAFLOG) SKIP EDIT
               ('XDSNames ...... ',TBL_XDSNREQ(CTR_XXX))
               ((2)(A));
         END;
      END;
   IF CTR_NCS_XFUN = 0 THEN
     DO;
       FLG_XFUN_CATALOG = '1'B;
       FLG_XFUN_DATASET = '1'B;
       FLG_XFUN_ENQUEUE = '1'B;
       FLG_XFUN_RACF    = '1'B;
       PUT FILE(DAFLOG) SKIP EDIT
           ('XFUNctions .... None (Default)') (A);
      END;
   ELSE
      DO;
         IF (FLG_XFUN_CATALOG) THEN
           DO;
             PUT FILE(DAFLOG) SKIP EDIT
                 ('XFUNctions .... Catalog') (A);
             FLG_FUN_CATALOG = '0'B;
           END;
         IF (FLG_XFUN_DATASET) THEN
           DO;
             PUT FILE(DAFLOG) SKIP EDIT
                 ('XFUNctions .... Dataset') (A);
             FLG_FUN_DATASET = '0'B;
           END;
         IF (FLG_XFUN_ENQUEUE) THEN
           DO;
             PUT FILE(DAFLOG) SKIP EDIT
                 ('XFUNctions .... Enqueue') (A);
             FLG_FUN_ENQUEUE = '0'B;
           END;
         IF (FLG_XFUN_RACF) THEN
           DO;
             PUT FILE(DAFLOG) SKIP EDIT
                 ('XFUNctions .... RACF') (A);
             FLG_FUN_RACF = '0'B;
           END;
      END;
   IF CTR_NCS_XJOB = 0 THEN
      DO;
         PUT FILE(DAFLOG) SKIP EDIT
             ('XJOBs ......... None (Default)') (A);
      END;
   ELSE
      DO;
         DO CTR_XXX = 1 TO CTR_NCS_XJOB;
           PUT FILE(DAFLOG) SKIP EDIT
               ('XJOBs ......... ',TBL_XJOBREQ(CTR_XXX))
               ((2)(A));
         END;
      END;
   IF CTR_NCS_XVOL = 0 THEN
      DO;
         PUT FILE(DAFLOG) SKIP EDIT
             ('XVOLumes ...... None (Default)') (A);
      END;
   ELSE
      DO;
         DO CTR_XXX = 1 TO CTR_NCS_XVOL;
           PUT FILE(DAFLOG) SKIP EDIT
               ('XVOLumes ...... ',TBL_XVOLREQ(CTR_XXX))
               ((2)(A));
         END;
      END;
 END PRC_DAFIN;
 PRC_DAFSMF: PROC;
   CALL DAFSMF_SELECT;
   IF CTR_DAFRPT(129) = 0 THEN CALL RPT_DAFRPT;
   CALL RPT_DAFSTAT;
   IF CTR_DAFXCLD(129) = 0 THEN CALL RPT_DAFXCLD;
 END PRC_DAFSMF;
 PUT_DAF1IN: PROC;
   WRITE FILE(DAF1IN) FROM(DAFXXREC);
   SELECT (SMFXXRTY);
     WHEN(14,15,17,18,36,60,61,62,63,64,65,66,67,68,69,77,80)
       CTR_DAFRPT(SMFXXRTY) = CTR_DAFRPT(SMFXXRTY) + 1;
     OTHERWISE CTR_DAFRPT(128) = CTR_DAFRPT(128) + 1;
   END;
   SELECT (SMFXXRTY);
     WHEN(14,15,17,18) CTR_DAFRPT(131) = CTR_DAFRPT(131) + 1;
     WHEN(36,60,61,62,63,64,65,66,67,68,69)
       CTR_DAFRPT(130) = CTR_DAFRPT(130) + 1;
     WHEN(77) CTR_DAFRPT(132) = CTR_DAFRPT(132) + 1;
     WHEN(80) CTR_DAFRPT(133) = CTR_DAFRPT(133) + 1;
     OTHERWISE;
   END;
 END PUT_DAF1IN;
 PUT_DAF2IN: PROC;
   WRITE FILE(DAF2IN) FROM(DAFXXENM);
   SELECT (SMFXXRTY);
     WHEN(14,15,17,18,36,60,61,62,63,64,65,66,67,68,69,77,80)
       CTR_DAFXCLD(SMFXXRTY) = CTR_DAFXCLD(SMFXXRTY) + 1;
     OTHERWISE CTR_DAFXCLD(128) = CTR_DAFXCLD(128) + 1;
   END;
   SELECT (SMFXXRTY);
     WHEN(14,15,17,18) CTR_DAFXCLD(131) = CTR_DAFXCLD(131) + 1;
     WHEN(36,60,61,62,63,64,65,66,67,68,69)
       CTR_DAFXCLD(130) = CTR_DAFXCLD(130) + 1;
     WHEN(77) CTR_DAFXCLD(132) = CTR_DAFXCLD(132) + 1;
     WHEN(80) CTR_DAFXCLD(133) = CTR_DAFXCLD(133) + 1;
     OTHERWISE;
   END;
 END PUT_DAF2IN;
 PUT_TITLE: PROC(TTL_FIL,TTL_CHR,TTL_NUM);
   DCL TTL_FIL FILE;
   DCL TTL_CHR CHAR(*);
   DCL TTL_NUM FIXED BIN(015,0);
   CTR_PGE(TTL_NUM) = CTR_PGE(TTL_NUM) + 1;
   CTR_LNE(TTL_NUM) = 0;
   IF CTR_PGE(TTL_NUM) = 1 THEN
     DO;
       PUT FILE(TTL_FIL)      EDIT
           ('Dataset Audit Facility (DAF) - Version 1.3',
            'Page:     ',CTR_PGE(TTL_NUM)) (COL(45),A,COL(115),A,F(4));
     END;
   ELSE
     DO;
       PUT FILE(TTL_FIL) PAGE EDIT
           ('Dataset Audit Facility (DAF) - Version 1.3',
            'Page:     ',CTR_PGE(TTL_NUM)) (COL(45),A,COL(115),A,F(4));
     END;
   PUT FILE(TTL_FIL) SKIP EDIT
       ('(c) Copyright Cleary Consulting 1988, 1989')
       (COL(50),A);
   PUT FILE(TTL_FIL) SKIP EDIT ('All Rights Reserved') (COL(56),A);
   PUT FILE(TTL_FIL) SKIP EDIT (' ') (A);
   PUT FILE(TTL_FIL) SKIP EDIT
       ('Time: ',TME_RUN,TTL_CHR,'Date: ',DTE_RUN)
       (COL(1),A,COL(7),A,COL(63),A,COL(115),A,COL(121),A);
   PUT FILE(TTL_FIL) SKIP EDIT (' ') (A);
 END PUT_TITLE;
 RPT_DAFRPT: PROC;
   CALL PLISRTA (' SORT FIELDS=(01,44,CH,A,45,7,BI,A) ',
                 ' RECORD TYPE=F,LENGTH=(439) ',
                 600000,SRT_RC,'DAF1') ;
   IF SRT_RC = 0 THEN
     DO;
       FLG_SORT_ERROR = '1'B;
       STOP;
     END;
   OPEN FILE (DAFRPT) PRINT LINESIZE(132);
   OPEN FILE (DAF1OUT) INPUT;
   READ FILE (DAF1OUT) INTO(DAFXXREC);
   DO WHILE (FLG_EOF_DAF1OUT);
     DTE_WRK = DAFXXDTE;
     CALL CHG_TME(DAFXXTME);
     IF DAFXXENM = PREV_DSN THEN
        DO;
          SIGNAL ENDPAGE(DAFRPT);
          PREV_DSN = DAFXXENM;
        END;
     IF CTR_LNE(2) > 50 THEN SIGNAL ENDPAGE(DAFRPT);
     PUT FILE(DAFRPT) SKIP EDIT
       (DTE_WRK,' ',TME_LONG,' ',DAFXXSID,' ',DAFXXJNM,' ',
        DAFXXRTY,' ',DAFXXVOL,SUBSTR(DAFXXLNE,1,85)) ((12)(A));
     CTR_LNE(2) = CTR_LNE(2) + 1;
     IF SUBSTR(DAFXXLNE,86,85) = ' ' THEN
       DO;
         PUT FILE(DAFRPT) SKIP EDIT (SUBSTR(DAFXXLNE,86,85))
         (COL(42),A);
         CTR_LNE(2) = CTR_LNE(2) + 1;
       END;
     IF SUBSTR(DAFXXLNE,171,85) = ' ' THEN
       DO;
         PUT FILE(DAFRPT) SKIP EDIT (SUBSTR(DAFXXLNE,171,85))
         (COL(42),A);
         CTR_LNE(2) = CTR_LNE(2) + 1;
       END;
     IF SUBSTR(DAFXXLNE,256,85) = ' ' THEN
       DO;
         PUT FILE(DAFRPT) SKIP EDIT (SUBSTR(DAFXXLNE,256,85))
         (COL(42),A);
         CTR_LNE(2) = CTR_LNE(2) + 1;
       END;
      READ FILE(DAF1OUT) INTO(DAFXXREC);
   END;
   CLOSE FILE (DAFRPT);
   CLOSE FILE (DAF1OUT);
 END RPT_DAFRPT;
 RPT_DAFSTAT: PROC;
   CTR_DSC(14)  = 'INPUT or RDBACK Dataset Activity .................';
   CTR_DSC(15)  = 'OUTPUT, UPDAT, INOUT or OUTIN Dataset Activity ...';
   CTR_DSC(17)  = 'Scratch Dataset Status ...........................';
   CTR_DSC(18)  = 'Rename Dataset Status ............................';
   CTR_DSC(36)  = 'Integrated Catalog Facility Catalog ..............';
   CTR_DSC(60)  = 'VSAM Volume Dataset Updated ......................';
   CTR_DSC(61)  = 'Integrated Catalog Facility Define Activity ......';
   CTR_DSC(62)  = 'VSAM Component or Cluster Opened .................';
   CTR_DSC(63)  = 'VSAM Entry Defined ...............................';
   CTR_DSC(64)  = 'VSAM Component or Cluster Status .................';
   CTR_DSC(65)  = 'Integrated Catalog Facility Delete Activity ......';
   CTR_DSC(66)  = 'Integrated Catalog Facility Alter Activity .......';
   CTR_DSC(67)  = 'VSAM Entry Deleted ...............................';
   CTR_DSC(68)  = 'VSAM Entry Renamed ...............................';
   CTR_DSC(69)  = 'VSAM Data Space Defined, Extended or Deleted .....';
   CTR_DSC(77)  = 'Enqueue Activity .................................';
   CTR_DSC(80)  = 'RACF Processing Record ...........................';
   CTR_DSC(128) = 'Other ............................................';
   CTR_DSC(129) = 'Total ............................................';
   CTR_DSC(130) = 'Catalog - SMF Record Types 36,60-69 ..............';
   CTR_DSC(131) = 'Dataset - SMF Record Types 14,15,17,18 ...........';
   CTR_DSC(132) = 'Enqueue - SMF Record Type  77 ....................';
   CTR_DSC(133) = 'RACF    - SMF Record Type  80 ....................';
   OPEN FILE (DAFSTAT) PRINT LINESIZE(132);
   CALL PUT_TITLE(DAFSTAT,'DAFSTAT',3);
   PUT FILE(DAFSTAT) SKIP EDIT
       ('SMF Record Types                                        ',
        '       DAFSMF        DAFRPT       DAFXCLD') ((2)(A));
   PUT FILE(DAFSTAT) SKIP EDIT (' ') (A);
   DO CTR_WRK = 1 TO 127;
     IF SUBSTR(CTR_DSC(CTR_WRK),50,1) = '.' THEN
       DO;
         PUT FILE(DAFSTAT) SKIP EDIT (CTR_WRK,' - ',CTR_DSC(CTR_WRK),
          CTR_DAFSMF(CTR_WRK),CTR_DAFRPT(CTR_WRK),CTR_DAFXCLD(CTR_WRK))
          (F(2),(5)(A));
       END;
   END;
   PUT FILE(DAFSTAT) SKIP EDIT (' ') (A);
   DO CTR_WRK = 128 TO 129;
     PUT FILE(DAFSTAT) SKIP EDIT ('     ',CTR_DSC(CTR_WRK),
          CTR_DAFSMF(CTR_WRK),CTR_DAFRPT(CTR_WRK),CTR_DAFXCLD(CTR_WRK))
          ((5)(A));
   END;
   PUT FILE(DAFSTAT) SKIP(4) EDIT (' ') (A);
   PUT FILE(DAFSTAT) SKIP EDIT
       ('SMF Functional Areas                                    ',
        '       DAFSMF        DAFRPT       DAFXCLD') ((2)(A));
   PUT FILE(DAFSTAT) SKIP EDIT (' ') (A);
   DO CTR_WRK = 130 TO 133;
     PUT FILE(DAFSTAT) SKIP EDIT ('     ',CTR_DSC(CTR_WRK),
          CTR_DAFSMF(CTR_WRK),CTR_DAFRPT(CTR_WRK),CTR_DAFXCLD(CTR_WRK))
          ((5)(A));
   END;
   PUT FILE(DAFSTAT) SKIP EDIT (' ') (A);
   DO CTR_WRK = 128 TO 129;
     PUT FILE(DAFSTAT) SKIP EDIT ('     ',CTR_DSC(CTR_WRK),
          CTR_DAFSMF(CTR_WRK),CTR_DAFRPT(CTR_WRK),CTR_DAFXCLD(CTR_WRK))
          ((5)(A));
   END;
   PUT FILE(DAFSTAT) SKIP(4) EDIT (' ') (A);
   PUT FILE(DAFSTAT) SKIP EDIT ('DAFSMF Date/Time Range:') (A);
   PUT FILE(DAFSTAT) SKIP EDIT (' ') (A);
   CALL CHG_TME(TME_LOW);
   DTE_WRK = DTE_LOW;
   PUT FILE(DAFSTAT) SKIP EDIT
       ('Low  - Date: ',DTE_WRK,'  Time: ',TME_LONG) ((4)(A));
   CALL CHG_TME(TME_HGH);
   DTE_WRK = DTE_HGH;
   PUT FILE(DAFSTAT) SKIP EDIT
       ('High - Date: ',DTE_WRK,'  Time: ',TME_LONG) ((4)(A));
   CLOSE FILE (DAFSTAT);
   IF CTR_DAFRPT(129) = 0 THEN
     DO;
       FLG_NONE_SELECTED = '1'B;
       STOP;
     END;
 END RPT_DAFSTAT;
 RPT_DAFXCLD: PROC;
   CALL PLISRTA (' SORT   FIELDS=(01,44,CH,A) ',
                 ' RECORD TYPE=F,LENGTH=(44) ',
                 600000,SRT_RC,'DAF2') ;
   IF SRT_RC = 0 THEN
     DO;
       FLG_SORT_ERROR = '1'B;
       STOP;
     END;
   OPEN FILE (DAFXCLD) PRINT LINESIZE(132);
   OPEN FILE (DAF2OUT) INPUT;
   SIGNAL ENDPAGE(DAFXCLD);
   READ FILE (DAF2OUT) INTO(WRKXXENM);
   PREV_DSN = WRKXXENM;
   CTR_WRK = 0;
   DO WHILE (FLG_EOF_DAF2OUT);
     IF WRKXXENM = PREV_DSN THEN CTR_WRK = CTR_WRK + 1;
     IF WRKXXENM = PREV_DSN THEN
       DO;
         IF CTR_LNE(4) > 50 THEN SIGNAL ENDPAGE(DAFXCLD);
         PUT FILE(DAFXCLD) SKIP EDIT (PREV_DSN,' ',CTR_WRK)
             (A,A,F(6));
         CTR_LNE(4) = CTR_LNE(4) + 1;
         CTR_WRK = 1;
         PREV_DSN = WRKXXENM;
       END;
     READ FILE(DAF2OUT) INTO(WRKXXENM);
   END;
   IF CTR_LNE(4) > 50 THEN SIGNAL ENDPAGE(DAFXCLD);
   PUT FILE(DAFXCLD) SKIP EDIT (WRKXXENM,' ',CTR_WRK)
       (A,A,F(6));
   CLOSE FILE (DAFXCLD);
   CLOSE FILE (DAF2OUT);
 END RPT_DAFXCLD;
 DAFSMF_SELECT: PROC;
   OPEN FILE (DAFSMF) INPUT;
   OPEN FILE (DAF2IN) OUTPUT;
   CALL GET_DAFSMF;
   DO WHILE(FLG_EOF_DAFSMF);
      CALL EXT_DAFSMF;
      CALL GET_DAFSMF;
   END;
   CLOSE FILE (DAFSMF);
   CLOSE FILE (DAF1IN);
   CLOSE FILE (DAF2IN);
   DO CTR_WRK = 1 TO 128;
     CTR_DAFRPT(129)  = CTR_DAFRPT(129)  + CTR_DAFRPT(CTR_WRK);
     CTR_DAFSMF(129)  = CTR_DAFSMF(129)  + CTR_DAFSMF(CTR_WRK);
     CTR_DAFXCLD(129) = CTR_DAFXCLD(129) + CTR_DAFXCLD(CTR_WRK);
   END;
 END DAFSMF_SELECT;
 END DAF ;
./ ADD NAME=CBTINSTL 0100-97322-97322-1519-00008-00008-00000-OLDDAF
//CBT1845 JOB 527TSO000S0008,'DAF',CLASS=8,MSGCLASS=6,
// NOTIFY=TS15500
/*JOBPARM ROOM=F04L
//STEP01   EXEC BANNER,P='CBT1845!!DAF',COPY=3
// EXEC PLIX,SO=6
//SYSIN DD DISP=SHR,DSN=TS15500.CBT1845.PDS($SRC)
// EXEC LINKX,SO=6,NAME=CBT1845,LIB='SYS2.MLINKLIB'
 ALIAS DAF
./ ADD NAME=CBTJCL   0100-97322-97322-1519-00039-00039-00000-OLDDAF
//TX15500E JOB 527TSO000S0008,ARNIE,CLASS=8,MSGCLASS=5
//********************************************************************
//*  Dataset Audit Facility (DAF) - Version 1.0                     **
//*                                                                 **
//*  Bergen Brunswig Corporation                                    **
//*  4000 Metropolitan Drive                                        **
//*  Orange, CA  92668                                              **
//*                                                                 **
//*  Michael Joseph Cleary                                          **
//*  (714) 385-4052                                                 **
//*                                                                 **
//********************************************************************
//SMFDSN  EXEC PGM=DAF
//STEPLIB  DD DSN=TEST.LOAD,DISP=SHR
//DAFLOG   DD  SYSOUT=*
//DAFRPT   DD  SYSOUT=*
//SRTMSG   DD  SYSOUT=*
//PL1DUMP  DD  SYSOUT=*
//SYSOUT   DD  SYSOUT=*
//SMFIN    DD  DSN=TX15500.SYS1.MANA,DISP=SHR
//SORTIN   DD  UNIT=3380,SPACE=(CYL,(60,60),RLSE),
//             DCB=(RECFM=FB,LRECL=242,BLKSIZE=15246)
//SORTOUT  DD  UNIT=3380,SPACE=(CYL,(60,60),RLSE),
//             DCB=(RECFM=FB,LRECL=242,BLKSIZE=15246)
//*            DSN=ZT12.SORTOUT,DISP=(NEW,CATLG,DELETE)
//SORTWK01 DD  UNIT=3380,SPACE=(CYL,(60,60),RLSE)
//SORTWK02 DD  UNIT=3380,SPACE=(CYL,(60,60),RLSE)
//SORTWK03 DD  UNIT=3380,SPACE=(CYL,(60,60),RLSE)
//SORTWK04 DD  UNIT=3380,SPACE=(CYL,(60,60),RLSE)
//SORTWK05 DD  UNIT=3380,SPACE=(CYL,(60,60),RLSE)
//SORTWK06 DD  UNIT=3380,SPACE=(CYL,(60,60),RLSE)
//* DDN=@ (DEFAULT ALL)
//* DSN=@ (DEFAULT ALL)
//* JOB=@ (DEFAULT ALL)
//* VOL=@ (DEFAULT ALL)
//* SD=YYDDD (DEFAULT 86001)
//* ED=YYDDD (DEFAULT 99365)
//DAFIN    DD  *
DSN=HVCVA.
