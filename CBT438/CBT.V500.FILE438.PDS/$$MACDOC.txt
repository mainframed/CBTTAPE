IN THE FOLLOWING LIST OF MACROS, EACH ONE IS ASSIGNED TO A CATEGORY
ACCORDING TO ITS INTENDED USE.  MOST OF THE TESTING ON THESE MACROS
HAS BEEN DONE IN AN ENVIRONMENT CALLED 'VERSION 2', OR '2ND
GENERATION'. THIS ENVIRONMENT PRESENTS A PROGRAMMER WITH A PSEUDO-COBOL
WAY OF CODING, AND WAS CREATED IN THE EARLY 1990'S AS AN AID TO GETTING
PROGRAMS GOING FASTER.  THE 'VERSION 1' OR '1ST GENERATION' ENVIRONMENT
WAS CREATED IN THE MID 1970'S, AND IS SOMEWHAT MORE ORIENTED TOWARD
SYSTEMS PROGRAMMING TYPES OF PROGRAMMING.

IF A MACRO IS LISTED AS BEING 'GENERAL', OR GENERAL PURPOSE, THEN IT IS
NOT PART OF EITHER VERSION 1 OR 2, BUT IT MIGHT NOT HAVE BEEN TESTED
OUTSIDE ONE OF THESE ENVIRONMENTS.

WHAT FOLLOWS IS A DESCRIPTION OF THE CATEGORIES THAT THESE MACROS HAVE
BEEN CLASSIFIED INTO:

DIAGNOSTIC - THE MACRO MAY BE USED IN EITHER VERSION 1 OR 2 PROGRAMS,
AND IS INTENDED PRIMARILY AS A DIAGNOSTIC AID IN GETTING THE
PROGRAM RUNNING CORRECTLY.  HOPEFULLY THE EFFORT EXPENDED IN
USING ONE OR MORE OF THESE DIAGNOSTIC MACROS WILL PAY OFF IN DIAGNOSING
THE PROGRESS OF YOUR PROGRAM.

GENERAL - VARIOUS UTILITY MACROS THAT SHOULD PROVIDE SERVICES REQUIRED
FOR TYPICAL PROGRAMS.

INTERNAL - THESE MACROS ARE TYPICALLY USED AS COMMON SERVICE ROUTINES
BY OTHER MACROS WITHIN THIS LIBRARY.  THEY USUALLY PROVIDE SERVICES
THAT WOULD NOT BE USEFUL FOR USE AS OPEN CODE MACROS (THOSE CODED
WITHIN THE PROGRAM ITSELF).

RUN-TIME-TOTALS - A SET OF GENERAL PURPOSE MACROS THAT MIGHT MAKE IT
EASIER TO CREATE COUNTERS THAT CAN BE INCREMENTED AT EACH OF SEVERAL
PLACES WITHIN A PROGRAM, AND THEN AT SOME POINT DURING PROGRAM
EXECUTION (PRESUMABLY DURING THE FINALIZATION STEP OF THE PROGRAM),
PRINT OUT ALL OF THE ACCUMULATED COUNTS WITH ONE EASY STATEMENT.

STRUCTURED - MACROS THAT CONTROL THE CONDITIONAL OR REPETITIVE
EXECUTION OF A GROUP OF INSTRUCTIONS FOLLOWING THE GROUP-INITIATION
MACRO AND ENDING WITH A GROUP-TERMINATING MACRO.

1ST GENERATION - A SET OF MACROS THAT PROVIDE STANDARD MVS INTERFACE
AND SUBROUTINE LINKAGE CONVENTIONS.

2ND GENERATION - ANOTHER SET OF MVS INTERFACE AND SUBROUTINE LINKAGE
MACROS.

WHAT FOLLOWS IS AN ALPHABETIC LISTING OF ALL OF THE MACRO DEFINITIONS
INCLUDED IN THE PACKAGE, WITH ITS IDENTIFYING MACRO TYPE:

$AGOTO    INTERNAL
$ASECT    INTERNAL
$IA       INTERNAL
$MENDDO1  INTERNAL
$MENDDO2  INTERNAL
$MGBLDEF  INTERNAL
$MGFNAME  INTERNAL
$MGPNAME  INTERNAL
$WA       INTERNAL
ADDR      GENERAL
AFTER     STRUCTURED
AN        GENERAL
BEGTEST   DIAGNOSTIC
BHE       GENERAL
BLE       GENERAL
COMBOX    GENERAL
CONTINUE  GENERAL
CPYPAR$E  INTERNAL
CTE       TEXT SEARCH
CTEB      TEXT SEARCH
CVN       GENERAL
CVXREGS   DIAGNOSTIC
CVXWORD   DIAGNOSTIC
DEFPGMID  INTERNAL
DIAGMSG   INTERNAL
DISPLAY   DIAGNOSTIC
DIVISION  2ND GENERATION
DO        STRUCTURED
DTM       INTERNAL
DUMPMAIN  DIAGNOSTIC
DUMPREGS  DIAGNOSTIC
EDIT      STRUCTURED
ELSE      STRUCTURED
ELSEDO    STRUCTURED
ELSEIF    STRUCTURED
EM        GENERAL
ENDAFTER  STRUCTURED
ENDELSE   STRUCTURED
ENDFIRST  STRUCTURED
ENDIF     STRUCTURED
ENDO      STRUCTURED
ENDP      1ST GENERATION
ENDSECT   2ND GENERATION
ENDTEST   DIAGNOSTIC
EPACK     GENERAL
EQUATE    GENERAL
EUNPK     GENERAL
EVERY     STRUCTURED
EXECUTE   GENERAL
EXIT      2ND GENERATION
FINAL     2ND GENERATION
FIRST     STRUCTURED
GO        1ST GENERATION
GOBACK    2ND GENERATION
GOTO      2ND GENERATION
HEXRTN    DIAGNOSTIC (1ST GENERATION VERSION)
HROUTINE  DIAGNOSTIC (2ND GENERATION VERSION)
I         GENERAL
IF        STRUCTURED
IP        GENERAL
LEVELMSG  INTERNAL
MACBOX    GENERAL
NEXT      STRUCTURED
PAR$E     INTERNAL
PCALL     1ST GENERATION
PERFORM   2ND GENERATION
PRDEF     GENERAL (1ST GENERATION VERSION)
PRINTER   GENERAL (2ND GENERATION VERSION)
PROC      1ST GENERATION
PRTTABLE  RUN-TIME-TOTALS
RETN      1ST OR 2ND GENERATION
RTTBEG    RUN-TIME-TOTALS
RTTEND    RUN-TIME-TOTALS
RTTENT    RUN-TIME-TOTALS
RTTINCR   RUN-TIME-TOTALS
RTTPRT    RUN-TIME-TOTALS
RTTRESET  RUN-TIME-TOTALS
SECONDEP  2ND GENERATION
SECTION   2ND GENERATION
SETCSECT  INTERNAL
SETDEF    INTERNAL
SETRC     GENERAL
SETUP     INTERNAL
STOP      1ST GENERATION
SYSUT1    1ST GENERATION
SYSUT2    1ST GENERATION
TAG       GENERAL
THENDO    STRUCTURED
TRACER    DIAGNOSTIC
TRACER2   INTERNAL
TRC       DIAGNOSTIC (1ST GENERATION ONLY)
TRSP      GENERAL
VAL       INTERNAL
VERSION   INTERNAL

                            DIAGNOSTIC

THE MACROS IN THIS GROUP FURNISH VARIOUS AIDS THAT CAN BE USED IN
DIAGNOSING THE EXECUTION OF A PROGRAM.  THE 'BEGTEST' AND 'ENDTEST'
MACROS ALLOW MULTIPLE LINES OF CODE TO BE INCLUDED OR EXCLUDED FROM
AN ASSEMBLY, BASED ON THE VALUE OF A GLOBAL SET SYMBOL.

BEGTEST
THIS MACRO HEADS A GROUP OF INSTRUCTIONS THAT ARE CONDITIONALLY
INCLUDED OR EXCLUDED FROM A PARTICULAR ASSEMBLY. THE GROUP MUST BE
TERMINATED WITH AN 'ENDTEST' MACRO.  THE 'BEGTEST' REQUIRES ONE
POSITIONAL OPERAND.  IF THE OPERAND IS NUMERIC, THEN THAT VALUE IS
COMPARED WITH THE GLOBAL TYPE 'A' SET SYMBOL &TESTLVL.  IF THE OPERAND
IS GREATER THAN &TESTLVL, THEN THE INSTRUCTIONS BETWEEN THE 'BEGTEST'
AND 'ENDTEST' ARE EXCLUDED FROM THIS ASSEMBLY, OTHERWISE THEY ARE
INCLUDED:

          GBLA  &TESTLVL
 &TESTLVL SETA  10
 ...
          BEGTEST 5
          WTO   'HELP'
          ENDTEST ,

IN THIS CASE, THE 'WTO' STATEMENT WILL BE ASSEMBLED.  IF &TESTLVL HAD
BEEN SET TO 0 (ZERO), THEN THE 'WTO' WOULD HAVE BEEN EXCLUDED FROM
THIS ASSEMBLY.

IF THE VALUE OF THE POSITIONAL OPERAND OF THE 'BEGTEST' IS 'A', 'B',
'C', OR 'D', THEN THE LOGIC IS BASED ON THE SETTING OF THE GLOBAL TYPE
'C' SET SYMBOL &$A, &$B, &$C OR &$D RESPECTIVELY:

          GBLC  &$A
&$A       SETC  'Y'     ANY OTHER VALUE CAUSES EXCLUSION
...
          BEGTEST A
          WTO   'OPT CODE INCLUDED'
          ENDTEST ,

SINCE THE SET SYMBOL &$A WAS SET TO 'Y', THE 'WTO' WILL BE INCLUDED IN
THIS ASSEMBLY.  IF &$A HAD BEEN SET TO ANY OTHER VALUE THEN THE CODE
WOULD NOT BE INCLUDED IN THIS ASSEMBLY.

CVXREGS
THIS ONE CAUSES THE VALUES OF ALL 16 GPRS TO THE PRINTER. NO OPERANDS
OTHER THAN THE NORMAL OPTIONAL NAME FIELD. IT REQUIRES THAT HEXRTN AND
PRDEF (1ST GENERATION) OR HROUTINE AND PRINTER (2ND GENERATION) BE
INCLUDED.

          CVXREGS ,

DISPLAY
THIS MACRO FUNCTIONS SIMILAR TO THE COBOL DISPLAY STATEMENT. IT
REQUIRES THE HEX AND PRINT ROUTINES, AND ACCEPTS ONE OR MORE
POSITIONAL PARAMETERS. EACH OPERANT MUST BE ONE OF THE FOLLOWING:
A PACKED DECIMAL FIELD (CONVERTED TO ZONED FOR PRINTING)
A ZONED OR CHARACTER FIELD
A GPR ENCLOSED WITHIN PARENTHESES
A TEXT STRING ENCLOSED WITHIN QUOTES AND PRECEDED WITH A 'C'

          DISPLAY C'DIAG INFO',FIELDA,(R15)

DUMPMAIN
THIS ONE ACCEPTS PAIRS OF POSITIONAL OPERANDS, EACH OF WHICH MUST BE
A MAIN STORAGE ADDRESS (NONE OF THAT GPR STUFF HERE, THANK YOU). THE
FIRST OF EACH PAIR IS THE STARTING ADDRESS TO BE DUMPED, IN HEX, TO
THE PRINTER, AND THE SECOND IS THE LAST ADDRESS. MULTIPLE
DISCONTIGUOUS GROUPS MAY BE SPECIFIED:

          DUMPMAIN FIELDA,FIELDA+9,FIELDC,ENDFLDC

ENDTEST
THIS ONE NEEDS TO BE USED ONLY IN CONJUNCTION WITH THE 'BEGTEST'
MACRO. IT IS USED TO END A GROUP OF CONDITIONALLY INCLUDED LINES OF
CODE. PLEASE SEE THE DOCUMENTATION FOR 'BEGTEST'.

HEXRTN
HROUTINE
THESE MACLIB MEMBERS ARE NOT MACROS, BUT COPIED CODE. THEY PROVIDE
VARIOUS HEXADECIMAL PRINTING SERVICES FOR OTHER DIAGNOSTIC ROUTINES.
IF THE DEFINITION OF A DIAGNOSTIC MACRO THAT YOU WANT TO USE SPECIFIES
THE REQUIREMENT FOR ONE OF THESE ROUTINES, THEN CODE ONE OF THE
FOLLOWING STATEMENTS NEAR THE END OF YOUR PROGRAM:

          COPY HEXRTN             FOR VERSION 1 PROGRAMS ONLY
          COPY HROUTINE           FOR VERSION 2 PROGRAMS ONLY

TRACER
THIS MACRO IS SIMILAR TO 'DISPLAY', WITH THE DIFFERENCES THAT:
1. IT WRITES ITS OUTPUT TO A FILE WITH DDNAME 'TRACER'
2. IT REQUIRES THE INCLUSION OF OBJECT MODULE 'TRACER' AT LINK EDIT
   TIME
3. IT ALLOWS THE OPTIONAL INCLUSION OF A NUMERIC FIRST PARAMETER,
   WHERE ITS VALUE IS COMPARED WITH THE GLOBAL TYPE A SET SYMBOL
   &TESTLVL. IF THIS VALUE IS <= &TESTLVL, THEN THE TRACER CODE IS
   GENERATED. IF IT IS > &TESTLVL, THEN IT IS TREATED AS A 'NOP'.
   PLEASE SEE 'BEGTEST' FOR A MORE COMPLETE DESCRIPTION OF THE USE OF
   &TESTLVL.

TRC
THIS IS AN EARLIER VERSION OF THE TRACER MACRO, AND IS CONTINUED FOR
COMPATIBILITY PURPOSES.

                            GENERAL

ADDR
THIS ONE COPIES THE ADDRESS OF A VARIABLE INTO A SPECIFIED REGISTER.
IT REQUIRES TWO POSITIONAL OPERANDS. THE FIRST MUST BE A GPR. IF THE
SECOND OPERAND IS ENCLOSED IN PARENTHESES, THEN IT IS ASSUMED TO BE A
GPR AND IS COPIED INTO THE FIRST.  OTHERWISE, A 'LOAD ADDRESS (LA)'
INSTRUCTION IS GENERATED. NOTE THAT IF THE SECOND OPERAND SPECIFIES
THE SAME GPR AS THE FIRST, THEN A 'NOP' IS GENERATED.

         ADDR  R1,(R6)
+        LR    R1,R6                GENERATED

         ADDR  R14,ADDCON
+        LA    R14,ADDCON           GENERATED

AN
'ADD NUMERIC' MIGHT SIMPLIFY SOME ADD OPERATIONS. IT REQUIRES TWO
POSITIONAL PARAMETERS. EACH CAN BE A GPR (THE OPERAND MUST BE ENCLOSED
WITHIN PARENTHESES), A PACKED DECIMAL FIELD, OR A ZONED DECIMAL FIELD.
THE VALUE OF THE SECOND OPERAND IS ADDED TO THE VALUE OF THE FIRST,
AND THE RESULT IS STORED IN THE FIRST OPERAND.
NOTES: 1. WORK AREAS ARE GENERATED AS REQUIRED
       2. PACKED FIELDS MAY BE FROM 1 THRU 16 BYTES LONG
       3. ZONED FIELDS MAY BE FROM 1 THRU 31 BYTES LONG. IF A ZONED
          FIELD IS LONGER THAN 16 BYTES, THEN MULTIPLE 'PACK'
          INSTRUCTIONS ARE GENERATED TO CREATE THE CORRECT PACKED
          RESULT.

         AN    FIELD1,FIELD2
+        AP    FIELD1,FIELD2     GENERATED IF BOTH ARE PACKED

         AN    ZONED1,ZONED2
+        PACK  WS_PL16A,ZONED1
+        PACK  WS_PL16B,ZONED2
+        AP    WS_PL16A,WS_PL16B
+        UNPK  ZONED1,WS_PL16A

BHE
ADDS ONE MORE 'EXTENDED MNEMONIC BRANCH' INSTRUCTION - BRANCH HIGH OR
EQUAL. IT GENERATES A 'BNL' INSTRUCTION:

         BHE   SKIPONE
+        BNL   SKIPONE          GENERATED

BLE
ADDS ONE MORE 'EXTENDED MNEMONIC BRANCH' INSTRUCTION - BRANCH LOW OR
EQUAL. IT GENERATES A 'BNH' INSTRUCTION:

         BLE   SKIPONE
+        BNH   SKIPONE          GENERATED

COMBOX
THIS MEMBER OF MACLIB CAN BE USED DURING A TSO EDIT SESSION TO COPY A
PRE-FORMATTED COMMENT BOX INTO YOUR CODE. IT IS NOT A MACRO.

CONTINUE
THIS STATEMENT IS MEANT TO GIVE COBOL PROGRAMMERS A 'WARM FUZZY'
WITHIN A STRUCTURED PROGRAM. IT GENERATES A 'NOP' INSTRUCTION:

 HERE1    CONTINUE ,
+HERE1    DS    0H              GENERATED

CVN
THIS 'CONVERT TO NUMERIC' MACRO REQUIRES TWO POSITIONAL OPERANDS, AND
ALLOWS A THIRD POSITIONAL AND A KEYWORD 'LEADING=' OPERAND. THE
NUMERIC DIGITS OF THE SECOND ARE MOVED, RIGHT JUSTIFIED, TO THE FIRST.
IF THE THIRD OPERAND IS SPECIFIED, IT MUST BE A GPR ENCLOSED WITHIN
PARENTHESES, OR A PACKED DECIMAL FIELD. IT WILL CONTAIN THE NUMBER OF
DIGITS DETECTED WITHIN THE SECOND OPERAND. THE DEFAULT VALUE FOR
'LEADING=' IS 0 (ZERO), WHICH CAUSES LEADING ZEROS TO BE LOADED INTO
THE FIRST OPERAND. ITS OPTIONAL VALUE IS 'B' (FOR BLANK), WHICH CAUSES
LEADING BLANKS TO BE LOADED.

          CVN   FIELDA,FIELDB,(R1),LEADING=B

CVXWORD
THIS MACRO REQUIRES TWO POSITIONAL OPERANDS. THE SECOND MUST BE 4
BYTES LONG, AND IT IS MOVED AND EXPANDED INTO THE 8 BYTE FIRST
OPERAND. EACH BYTE OF THE FIRST OPERAND WILL BE THE PRINTABLE
EQUIVALENT OF THE HEXADECIMAL VALUE OF THE CORRESPONDING HALF-BYTE OF
THE SECOND OPERAND.

          CVXWORD MYDOUBLE,MYFULL

EM
THIS MACRO WAS INTENDED TO MAKE THE USE OF THE S/390 ED OR EDMK
INSTRUCTIONS EASIER. I'M NOT SURE IT DOES. BUT, NONETHELESS, HERE
IT IS:
         SPACE 2

'EM' UTILIZES 'ED' OR 'EDMK' TO EDIT USER FIELD TO USER'S SPECS
THE FIRST OPERAND SPECIFIES THE RECEIVING FIELD
THE SECOND IS THE SENDING FIELD AND MUST BE VALID DECIMAL DATA
  (IF THE DATA IS ZONED, IT IS CONVERTED TO PACKED)
THE (OPTIONAL) THIRD FIELD (A NUMERIC SELF-DEFINING TERM)
  SPECIFIES THE TOTAL NUMBER OF DIGITS TO THE RIGHT OF THE DECIMAL
  - IF THIS PARAMETER IS OMITTED, THE SCALING VALUE OF THE SOURCE
  OPERAND IS USED (EG: DC    PL4'12345.67' WOULD HAVE A SCALING
  VALUE OF 2)
FLOAT=X SPECIFIES THE FILL CHARACTER TO PRECEED THE
  FIRST NUMERIC DIGIT (BLANK IS DEFAULT) (X IS ANY NON-BLANK CHAR)
INSERT=X SPECIFIES THE SINGLE CHARACTER TO IMMEDIATELY PRECEED THE
  FIRST NUMERIC DIGIT (BLANK IS DEFAULT) (X IS ANY NON-BLANK CHAR)
EX: IF FLOAT=* AND INSERT=$ THEN THE RESULT COULD APPEAR:
        *******$1,225.00
COMMA=NO CAUSES NO COMMAS TO BE INSERTED IN THE RESULT. LEAVING
  PARAMETER OUT OR SPECIFYING ANY VALUE OTHER THAN 'NO' CAUSES
  COMMAS TO BE INSERTED BETWEEN EACH THREE DIGITS
MASK=HEXDIGITS ALLOWS USER TO SPECIFY HER/HIS OWN EDIT MASK
DB=X ALLOWS USER TO SPECIFY TYPE OF NOTATION FOR +/- VALUES. IF
  NOT SPECIFIED, NEGATIVE VALUES ARE INDICATED BY A '-' IN THE
  HIGH ORDER POSITION (IMMEDIATELY PRECEDING THE MOST SIGNIFICANT
  DIGIT.
  SUPPORTED VALUES FOR THIS PARAMETER ARE:
  DB=- OR DB=(-,LEFT/RIGHT)
  DB=DB
  DB=PARENS
  DB=CR
  DB=+ OR DB=(+,LEFT/RIGHT)
  WHEN -, DB, OR PARENS IS SPECIFIED. INDICATION IS PROVIDED
  FOR NEGATIVE VALUES ONLY. WHEN CR OR + IS SPECIFIED, AN
  EXPLICIT INDICATION IS PROVIDED FOR POSITIVE OR NEGATIVE VALUES
  (I.E. DB FOR NEGATIVE AND CR FOR POSITIVE).
  FOR + AND - ONLY, A SECOND POSITIONAL SUBPARAMETER IS
  SUPPORTED WHICH ALLOWS PLACEMENT OF THE SIGN TO THE LEFT OF THE
  MOST SIGNIFICANT DIGIT, WITH NO BLANK POSITIONS BETWEEN THE SIGN
  AND THE DIGIT. DEFAULT IS 'RIGHT', AGAIN WITH NO BLANK POSITIONS
  BETWEEN THE RIGHTMOST DIGIT AND THE SIGN.
  WHEN DB OR CR IS SPECIFIED, ONE BLANK POSITION IS PROVIDED
  BETWEEN THE RIGHTMOST DIGIT AND THE CR OR DB INDICATOR.
THE FIRST TWO OPERANDS CAN BE SPECIFIED IN THE FOLLOWING WAYS:
   DATANAME   - OR - DATANAME(LENGTH)   - OR -
   DATANAME(,BASEREG)  - OR - DATANAME(LENGTH,BASEREG)  - OR -
   NUMERIC(LENGTH,BASEREG)
THE LENGTH PARAMETER FOR EACH OPERAND DEFAULTS TO THE LENGTH
ATTRIBUTE OF THE VARIABLE NAME (IF ANY - THE LENGTH IS SET TO 1
FOR EXPRESSIONS WHICH DO NOT BEGIN WITH A DATA NAME). THE LENGTH
OF 'TARGET' MUST BE BETWEEN 1 AND 255. IF THE SOURCE ITEM IS
ZONED DECIMAL, ITS LENGTH MUST BE BETWEEN 1 AND 31. IF IT IS NOT
ZONED DECIMAL, THEN IT IS ASSUMED TO BE PACKED DECIMAL, AND ITS
LENGTH MUST BE BETWEEN 1 AND 16 (16 IS THE MAXIMUM NUMBER OF BYTES
IN A PACKED DECIMAL FIELD).

         SPACE 2

EPACK
THIS ONE (EXTENDED-PACK) REQUIRES TWO POSITIONAL PARAMETERS. IT COPIES
THE SECOND (FROM 1 TO 31 BYTES) INTO THE FIRST (FROM 1 TO 16 BYTES).
IF THE SECOND IS LESS THAN 17 BYTES LONG, 1 PACK INSTRUCTION IS
GENERATED. IF THE SECOND IS GREATER THAN 16 BYTES LONG, THEN MULTIPLE
OVERLAPPING PACK INSTRUCTIONS ARE GENERATED AS REQUIRED. YOU MAY USE
ANY OF THE FORMS OF OPERAND FORMAT SUPPORTED BY THE PACK
INSTRUCTION - IE IMPLICIT VS EXPLICIT DEFINITION OF THE LENGTH AND/OR
BASE REGISTER:

          EPACK PACKED1,ZONED1
          EPACK 9(12,R4),0(23,R5)

EQUATE
THIS ONE REQUIRES NO OPERANDS, AND GENERATES AN 'EQU' STATEMENT FOR
EACH OF THE 16 GPRS:

          EQUATE ,
+R0       EQU   0
+...
+R15      EQU   15

EUNPK
THIS UNPACKS THE SECOND OPERAND (1 TO 16 BYTES) INTO THE
FIRST (1 TO 31 BYTES):

          EUNPK  MYZONED1,MYPACKD1

EXECUTE
THIS ONE MAKES IT POSSIBLE TO CONSTRUCT AN 'EX' INSTRUCTION WITH ONE
LINE OF CODE.  IF YOU'VE NEVER USED THE 'EX' INSTRUCTION, YOU'RE
PROBABLY BETTER OFF SKIPPING THE REST OF THIS 'EXECUTE' DOCUMENTATION.
IF YOU HAVE ALREADY USED IT, OR IF YOU'RE VERY BRAVE, THEN HERE GOES.
IT REQUIRES THREE POSITIONAL OPERANDS. THE FIRST IS A GPR (IT DOESN'T
HAVE TO BE WITHIN PARENTHESES, SINCE IT HAS TO BE A GPR), THE SECOND
IS THE OP CODE FOR THE INSTRUCTION BEING 'EX'ECUTED, AND THE THIRD
CONSISTS OF ALL OF THE OPERANDS OF THE INSTRUCTION BEING 'EX'ECUTED,
AND THEY MUST BE ENCLOSED WITHIN PARENTHESES.

          EXECUTE R15,MVC,(FIELDA(0),FIELDB)
+         EX     R15,$EX1234         GENERATED
+...
+$EX1234  MVC   FIELDA(0),FIELDB     GENERATED

NOTE THAT THE THIRD OPERAND IS GENERATED OUT-OF-LINE.  IF VERSION 1
MACROS ARE BEING USED, THEN THE OUT-OF-LINE INSTRUCTION WILL BE IN THE
DATAAREA CSECT. IF VERSION 2 MACROS ARE BEING USED, THEN IT WILL BE
ADDRESSED BY THE DATA LOCTR. IF NEITHER VERSION 1 OR 2 IS BEING USED,
GOOD LUCK.

I
THIS MACRO REQUIRES ONE POSITIONAL PARAMETER (A GPR, NOT ENCLOSED
WITHIN PARENTHESES), AND ALLOWS A SECOND. IN THE ONE-PARAMETER OPTION,
THE GPR SPECIFIED IS INCREMENTED BY 1. IF A SECOND PARAMETER
IS SPECIFIED, THEN THE GPR SPECIFIED IS INCREMENTED BY THE AMOUNT
SPECIFIED:

          I     R5
          I     R6,7

IN THE FIRST EXAMPLE, R5 WILL BE INCREMENTED BY 1. IN THE SECOND,
R6 WILL BE INCREMENTED BY 7.

IP
THIS PERFORMS THE SAME SERVICE FOR PACKED DECIMAL FIELDS THAT 'I'
PERFORMS FOR BINARY VALUES IN GPR'S:

          IP   PACKED1
          IP   PACKED2,7

MACBOX
THIS MEMBER OF MACLIB CAN BE USED DURING A TSO EDIT SESSION TO COPY A
PRE-FORMATTED COMMENT BOX INTO YOU CODE. IT IS NOT A MACRO.

PRDEF    (VERSION 1)
PRINTER  (VERSION 2)
THESE MACROS BRING IN THE EXECUTABLE CODE, THE DCB, AND THE BUFFERS
NEEDED TO CREATE AND USE A PRINT FILE. THE NAME FIELD SPECIFIED IN
THE MACRO STATEMENT WILL BE THE NAME USED TO CALL THE PRINT ROUTINE
(PCALL IN VERSION 1 AND PERFORM IN VERSION 2), AND KEYWORD PARAMETERS
ARE USED TO FURTHER CUSTOMIZE THE CODE. IN THE FOLLOWING, IF A VALUE
IS GIVEN FOR A KEYWORD, THEN THAT VALUE IS THE DEFAULT:

  DDNAME=SYSPRINT  USED IN CREATING THE DCB
  LRECL=133        USED IN CREATING THE DCB
  BLKSIZE=133      USED IN CREATING THE DCB
  OUTLINE=OUTLINE  NAME FOR 133 BYTE FIELD USED FOR CONSTRUCTION
                   AN OUTPUT DATA LINE. GENERATED BY THIS MACRO. MUST
                   BE UNIQUE WITHIN THIS ASSEMBLY.
  CCCHAR=CCCHAR    NAME OF CARRIAGE CONTROL CHARACTER. GENERATED BY
                   THIS MACRO. MUST BE UNIQUE WITHIN THIS ASSEMBLY.
                   PRESUMABLY THE FIRST BYTE OF 'OUTLINE'.
  HEADER1=HEADER1  HEADER LINE PRINTED BY THIS ROUTINE AT THE HEAD OF
                   EACH PAGE. TO CUSTOMIZE ITS VALUE, ISSUE THE
                   FOLLOWING STATEMENTS AT SOME POINT FOLLOWING THIS
                   MACRO:

         ORG   HEADER1
 ...    CUSTOMIZATION CODE TOTALLING UP TO 133 CHARACTERS
         ORG   ,

  HEADER2=      CODE A VALUE (SUCH AS HEADER2=HEADER2) HERE IF YOU
                NEED MORE THAT ONE HEADER LINE. DEFAULT IS 1 HEADER
                LINE. SEE INSTRUCTIONS FOR HEADER1 FOR CUSTOMIZING.

  HEADER3=      CODE A VALUE (SUCH AS HEADER3=HEADER3) HERE IF YOU
                NEED MORE THAT TWO HEADER LINES. DEFAULT IS 1 HEADER
                LINE. SEE INSTRUCTIONS FOR HEADER1 FOR CUSTOMIZING.

  SPACES=SPACES THIS NAME IS GENERATED BY THE MACRO, AND IS USED TO
                BLANK OUT 'OUTLINE' AT THE END OF EACH CALL. IT MUST
                BE UNIQUE WITHIN EACH ASSEMBLY.

  LINECT=LINECT THE NAME OF A VARIABLE, GENERATED BY THIS MACRO,
                USED TO CONTROL PAGE OVERFLOW. IN GENERAL, IT SHOULD
                NOT BE DIRECTLY MANIPULATED FROM OPEN CODE. MUST BE
                UNIQUE WITHIN AN ASSEMBLY.

  PSIZE=60      NUMBER OF LINES THAT CAN BE PRINTED PER PAGE. WHEN
                THIS NUMBER IS EXCEEDED, PAGE OVERFLOW OCCURS,
                HEADERS ARE PRINTED, AND THE DATA LINE WILL BE
                PRINTED ON THE FOLLOWING PAGE.

  PCTR=PCTR     NAME OF A PACKED DECIMAL VARIABLE USED TO MAINTAIN
                PAGE COUNT. GENERATED BY THIS MACRO. MUST BE
                UNIQUE WITHIN AN ASSEMBLY.

  PFIELD=       THE NAME OF A FIELD, PRESUMABLY DEFINED WITHIN
                HEADER1, HEADER2, OR HEADER3, WHERE THE PAGE COUNT
                WILL BE MOVED DURING EACH PAGE OVERFLOW OPERATION.
                NO PAGE NUMBER WILL BE PRINTED IF A VALUE IS NOT
                SUPPLIED FOR THIS VARIABLE.

  DCBNAME=PRINTER THIS IS THE NAME USED THE THE DCB GENERATED BY THIS
                MACRO. MUST BE UNIQUE WITHIN AN ASSEMBLY.

SETRC
THIS MACRO IS USED TO SET THE STORAGE LOCATION FOR R15 TO SOME VALUE.
IF YOU HAVE USED EITHER VERSION 1 OR 2 MACROS IN YOUR PROGRAM, THEN
THE LOCATION FOR R15 IS SET TO ZERO AT THE TIME THE PROGRAM BEGINS
EXECUTION, AND THIS MACRO CAN CHANGE IT TO SOME OTHER VALUE.  THERE
IS ONE REQUIRED POSITIONAL PARAMETER, AND A SECOND OPTIONAL PARAMETER.
THE FIRST IS THE VALUE FOR THE RETURN CODE. IF IT IS A NUMERIC
SELF-DEFINING TERM, THEN ITS VALUE BECOMES THE RETURN CODE. IF THIS
PARAMETER IS ENCLOSED WITHIN PARENTHESES, THEN IT MUST BE A GPR, AND
THE VALUE IN THE GPR BECOMES THE RETURN CODE.  ELSE IF THE TYPE
ATTRIBUTE OF THE FIRST OPERAND IS 'H', THEN THE VALUE OF THE HALFWORD
OPERAND BECOMES THE RETURN CODE, ELSE THE OPERAND IS ASSUMED TO BE A
FULLWORD, AND ITS VALUE BECOMES THE RETURN CODE.

IF THE SECOND OPERAND IS SPECIFIED, AND ITS VALUE IS 'RESET', THEN
THE VALUE OF THE FIRST OPERAND BECOMES THE NEW RETURN CODE. IF NOT,
THEN THE VALUE OF THE FIRST OPERAND BECOMES THE RETURN CODE ONLY IF
IT IS GREATER THAN THE CURRENT VALUE OF THE RETURN CODE.

          SETRC 12
 ...
          SETRC 0,RESET

TAG
USING THIS MACRO IS A WAY TO ASSIGN A TAG TO AN INSTRUCTION WITHOUT
CAUSING ANY CODE TO BE GENERATED. IF THE GLOBAL TYPE C SET SYMBOL
&$MTRACE IS CURRENTLY SET TO 'YES', THEN A 'TRACER' MACRO IS ISSUED
TO SHOW THAT THE INSTRUCTION LOGIC HAS PROCESSED THIS INSTRUCTION.

 HERENOW TAG   ,

TRSP

   'TRSP' WILL RETURN (IN REG 15) THE NUMBER OF TRAILING SPACES IN THE
   OPERAND FIELD. THE LENGTH OF THE FIELD MAY BE FROM 1 TO 256 BYTES.
   TO PROCESS THE FIELD USING THE LENGTH DEFINED FOR THE FIELD CODE:

        TRSP  MYFIELD

   WHERE 'MYFIELD' IS THE FIELD TO BE TESTED. IF YOU NEED TO SPECIFY A
   LENGTH OTHER THAN THE DEFAULT, THEN CODE THE LENGTH WITHIN
   PARENTHESES IMMEDIATELY FOLLOWING THE OPERAND:

        TRSP  MYFIELD(30)

   IF YOU NEED TO CODE THE OPERAND USING BASE+DISPLACEMENT, THEN CODE:

        TRSP  12(30,R7)

   WHERE 12 IS THE DISPLACEMENT (ANY VALUE FROM 0 TO 4095) AND R7 IS
   ANY GPR OTHER THAN R0. IN THIS FORM, THERE IS NO DEFAULT LENGTH, SO
   IT MUST BE EXPLICITLY CODED AS THE FIRST VALUE WITHIN THE
   PARENTHESES.


                            INTERNAL


                            RUN-TIME-TOTALS

THIS FAMILY WAS CREATED TO MAKE IT EASIER TO COUNT THE NUMBER OF PASSES
THROUGH VARIOUS PARTS OF A PROGRAM, GIVE EACH COUNTER AN ASSOCIATED
TEXT STRING, AND THEN PRINT OUT THE COUNTERS AND THE TEXT AT THE END OF
THE PROGRAM'S EXECUTION.

WITHIN THIS LIBRARY, ANY MACRO NAME BEGINNING WITH 'RTT' IS PART OF THIS
FAMILY.

WITHIN THE DATA DIVISION PORTION OF THE PROGRAM, YOU MUST CODE ONE
HEADER MACRO, ONE TRAILER MACRO, AND, BETWEEN THEM, ONE ENTRY MACRO FOR
EACH COUNTER THAT YOU NEED.

RTTBEG
THIS IS THE HEADER MACRO. IT MUST PRECEED THE ENTRY MACROS THAT DEFINE
THE COUNTERS BEING CREATED. IT SUPPORTS TWO OPTIONAL KEYWORD PARAMETERS:

          RTTBEG  TEXTLEN=50,MAXVAL=9999999

TEXTLEN DEFINES THE BYTE-LENGTH OF THE FIELD, CREATED FOR EACH ENTRY,
THAT WILL BE USED TO DESCRIBE THE COUNTER ON THE PRINTED REPORT. ITS
DEFAULT VALUE IS 50.

MAXVAL MUST BE THE LARGEST VALUE THAT YOU EXPECT ANY COUNTER TO ATTAIN.
NOTE THAT THIS MUST BE THE SAME VALUE FOR ALL THE COUNTERS CREATED
WITHIN ONE PROGRAM. ITS DEFAULT IS 7 DIGITS (9999999).

RTTENT
CODE ONE OF THESE MACROS FOR EACH COUNTER THAT YOU WILL NEED:

          RTTBEG ,
COUNTER1  RTTENT 'VALUE FOR COUNTER1'
COUNTER2  RTTENT 'VALUE FOR COUNTER2'
          RTTEND ,

NOTE THAT EACH RTTENT STATEMENT HAS A NAME FIELD. THIS IS THE VALUE
THAT IS USED IN THE PROCEDURE DIVISION TO INCREMENT THE COUNTER. THE
VALUE WITHIN THE QUOTES IS PRINTER ALONG WITH THE VALUE FOR THE COUNTER
WHEN THE RTTPRT MACRO IS ISSUED.

RTTEND
THIS MACRO MUST BE CODED IMMEDIATELY FOLLOWING THE LAST 'RTTENT'. IT
HELPS CONTROL THE OPERATION OF THE 'RTTPRT' MACRO.

RTTINCR
THIS MACRO IS USED IN THE EXECUTABLE PORTION TO INCREMENT ONE OF THE
COUNTERS THAT WAS DEFINED WITH THE 'RTTENT' MACRO. IT CAN BE USED TO
INCREMENT THE COUNTER BY 1 (DEFAULT) OR BY SOME OTHER VALUE:

          RTTINCR COUNTER1

          -- OR --

          RTTINCR COUNTER2,3

IN THE FIRST EXAMPLE, 'COUNTER1' WILL BE INCREMENTED BY 1. IN THE
SECOND, 'COUNTER2' WILL BE INCREMENTED BY 3.

RTTPRT
THIS MACRO CAUSES THE VALUE FOR EACH COUNTER THAT WAS PREVIOUSLY
DEFINED WITH AN RTTENT MACRO TO BE PRINTED, ALONG WITH THE VALUE FOR THE
TEXT STRING ASSOCIATED WITH THE COUNTER.  IT REQUIRES THAT 'PRDEF' BE
INCLUDED IN THE ASSEMBLY, AND IT DOES NOT RESET THE COUNTERS TO ZERO
UNLESS YOU CODE:

          RTTPRT RESET=YES

OBVIOUSLY (?) 'RESET=NO' IS THE DEFAULT.

RTTRESET
YOU CAN USE THIS MACRO TO RESET THE ACCUMULATED VALUES FOR ALL OF THE
COUNTERS THAT WERE DEFINED WITH AN 'RTTENT' MACRO WITHOUT PRINTING
THEIR VALUES:

          RTTRESET ,

IN THIS EXAMPLE, ALL OF THE COUNTERS WILL BE RESET. IN THE FOLLOWING
EXAMPLE, ONLY 'COUNTER1' WILL BE RESET:

          RTTRESET COUNTER1

HERE IS A TRADITIONAL 80-80 LIST PROGRAM THAT KEEPS A FEW COUNTERS. IT
WILL MAKE USE OF 2ND GENERATION, STRUCTURED, GENERAL, AND RUN-TIME
MACROS:

IDENTIFICATION DIVISION PROGID=EIGHTY80
DATA     DIVISION
SYSIN    DCB   DDNAME=SYSIN,MACRF=GM,LRECL=80,EODAD=ENDSYSIN,          X
               DSORG=PS,RECFM=FB
IN_BUF   DS    CL80
EOF_SW   DC    C'N'
         RTTBEG ,
IPTCOUNT RTTENT 'INPUT RECORDS READ'
OPTCOUNT RTTENT 'OUTPUT RECORDS WRITTEN'
         RTTEND ,
PROCEDURE DIVISION
         OPEN  (SYSIN)
         PERFORM GETINPUT
         DO    WHILE=(CLI,EOF_SW,C'Y',NE)
           MVC   OUTLINE+1(80),IN_BUF
           PERFORM PRINTRTN
           RTTINCR OPTCOUNT
           PERFORM GETINPUT
         ENDO ,
         RTTPRT ,
         CLOSE (SYSIN,,PRINTER)
         GOBACK ,
GETINPUT SECTION ,
         GET   SYSIN,IN_BUF
         RTTINCR IPTCOUNT
         RETN  ,
ENDSYSIN MVI   EOF_SW,C'Y'
         ENDSECT ,
PRINTRTN PRDEF  ,
         FINAL  ,
         END   EIGHTY80

                            STRUCTURED

THIS SET OF MACROS CAUSES A CONDITIONAL AND/OR REPETITIVE EXECUTION OF
A GROUP OF ONE OR MORE INSTRUCTIONS.  FOR CONVENIENCE, LET'S CALL A
GROUP OF INSTRUCTIONS THAT MIGHT OR MIGHT NOT BE EXECUTED ONE TIME, OR
MULTIPLE TIMES, A 'CR-GROUP', FOR 'C'ONDITIONAL/'R'EPETITIVE.

EACH CR-GROUP MUST BE HEADED BY ONE OF THE FOLLOWING MACRO STATEMENTS:

  AFTER      DO     EVERY      FIRST      IF

AND MUST BE TERMINATED BY ONE OF THE FOLLOWING:

  ENDAFTER   ENDO   ENDEVERY   ENDFIRST   ENDIF

IT IS SOMEWHAT OVERSIMPLIFYING TO SAY THAT ALL OF THE ENDXXXXX MACROS
SIMPLY INVOKE 'ENDO', BUT THE TRUTH IS THAT THE INDIVIDUAL ENDXXXXX
MACROS ARE MORE FOR PROGRAM DOCUMENTATION THAN THEY ARE FOR INTERNAL
LOGIC DIFFERENCES. SO, IF YOU END AN CR-GROUP WITH AN 'ENDAFTER'
MACRO, NO DIAGNOSTICS WILL BE ISSUED AND YOUR PROGRAM WILL WORK THE
SAME AS IF YOU HAD CODED AN 'ENDIF'.

CR-GROUPS MAY BE NESTED TO ANY DESIRED LEVEL:

          IF    ...
          ...
            DO    ...
            ...
            ENDO  ,
          ...
          ENDIF ,

YOU MAY FIND IT EFFECTIVE TO INDENT AT EACH LEVEL OF NESTING, BUT
BEWARE - THE CONTINUATION COLUMN IS ALWAYS THE SAME (16 IS THE
DEFAULT).

THERE ARE TWO ADDITIONAL SIGNIFICANT MACROS THAT CAN BE USED WITHIN
THIS PACKAGE OF STRUCTURED PROGRAMMING MACROS.  THE 'ELSEIF' MACRO CAN
BE USED FOLLOWING AN 'IF' OR ANOTHER 'ELSEIF' MACRO, AND SUPPORTS THE
SAME TYPES OF LOGIC THAT THE 'IF' MACRO SUPPORTS.  THE 'ELSE' MACRO
CAN FOLLOW AN 'IF', 'ELSEIF', 'AFTER', 'EVERY' OR 'FIRST' MACRO, AND
ALLOWS ITS CR-GROUP TO BE EXECUTED IF ALL OF THE PRECEDING CR-GROUPS
WERE NOT EXECUTED.

AFTER
THIS MACRO HEADS A CR-GROUP THAT WILL BE SKIPPED FOR THE FIRST 'N'
PASSES THROUGH THIS SECTION OF CODE, AND THEN EXECUTED EVERY PASS
THROUGH THE CODE FROM THEN ON.  'N' MUST BE A NUMERIC SELF-DEFINING
TERM.

         AFTER 1000000
            ...
         ENDAFTER ,

DO
THIS ONE PROVIDES REPETITIVE EXECUTION OF A CR-GROUP. THERE ARE
SEVERAL OPTIONS: THE FIRST IS TO CODE A NUMERIC SELF-DEFINING TERM,
WHICH CAUSES THE CR-GROUP TO BE EXECUTED THAT NUMBER OF TIMES:

          DO    5
            ...
          ENDO  ,

A SLIGHT VARIATION IS TO CODE:

         DO    FOREVER
           ...
         ENDO  ,

THIS CAUSES THE CR-GROUP TO BE CONTINUOUSLY EXECUTED UNTIL SOMETHING
EITHER WITHIN THE LOOP OR SOMETHING OUTSIDE THE PROGRAM (TIME
EXCEEDED, ETC) CAUSES THE LOOP TO BE BROKEN.

IF YOU CODE:

         DO    MYVARBL
           ...
         ENDO  ,

THEN 'MYVARBL' MUST BE A PACKED DECIMAL VARIABLE WHICH YOU HAVE
ALREADY INITIALIZED TO THE VALUE FOR THE NUMBER OF TIMES THAT YOU
WANT THIS CR-GROUP REPEATED. BE VERY CAREFUL ABOUT MODIFYING THIS
VARIABLE FROM WITHIN THE LOOP. ITS VALUE IS CAPTURED ONLY AT THE
BEGINNING OF THE EXECUTION OF THE CR-GROUP, AND ANY CHANGE TO THE
VALUE OF THE VARIABLE WILL TAKE EFFECT THE NEXT TIME THE 'DO'
STATEMENT IS ENCOUNTERED.

IF YOU WANT TO REPEAT A CR-GROUP BASED ON ONE OR MORE CONDITIONS,
THEN YOU CAN USE EITHER ONE OF THE FOLLOWING:

         DO    UNTIL=(...)
           ...
         ENDO  ,

         .. OR ..

         DO    WHILE=(...)
           ...
         ENDO  ,

IN THE FIRST OF THESE TWO EXAMPLES, THE CR-GROUP WILL BE EXECUTED
REPETITIVELY UNTIL ONE OR MORE OF THE CONDITIONS IS MET. IN THE
SECOND, IT WILL BE EXECUTED SO LONG AS ONE OR MORE OF THE CONDITIONS
IS MET.  IN BOTH OF THESE EXAMPLES, THE VALUES WITHIN THE PARENTHESES
ARE THE SAME AS FOR THE 'IF' MACRO. PLEASE SEE ITS DOCUMENTATION FOR
THE DETAILS.  THE ONLY DIFFERENCE BETWEEN THE OPERANDS HERE AND FOR
THE 'IF' MACRO IS THAT, IF THE CONDITION IS COMPLEX, THAT IS, IF IT
CONSISTS OF MULTIPLE CONDITIONS CONNECTED WITH 'AND' AND/OR 'OR'
CLAUSES, THEN THE ENTIRE OPERAND MUST BE ENCLOSED WITHIN ONE
ADDITIONAL LEVEL OF PARENTHESES:

          DO    UNTIL=((...),OR,(...))
                      *              *  <== REQUIRED IF COMPLEX
            ...
          ENDO  ,

ONE ADDITIONAL KEYWORD OPERAND IS AVAILABLE:

          DO    UNTIL=(...),TEST=AFTER
            ...
          ENDO  ,

          .. OR ..

          DO    WHILE=(...),TEST=AFTER
            ...
          ENDO  ,

THE 'TEST=AFTER' CAUSES THE CR-GROUP TO BE EXECUTED ONE TIME BEFORE
THE CONDITIONAL TESTS ARE MADE. DEFAULT IS 'TEST=BEFORE', WHERE THE
CR-GROUP MIGHT NOT BE EXECUTED EVEN ONCE, DEPENDING ON THE INITIAL
CONDITIONS.

ELSE
THIS MACRO MAY BE CODED ONLY WITHIN A CR-GROUP HEADED BY AN 'AFTER',
'ELSEIF', 'EVERY' OR 'FIRST' CR-GROUP HEADER.  IT CAUSES EXECUTION OF
ITS CR-GROUP IF ALL OF THE PREVIOUS CR-GROUPS HAVE BEEN BYPASSED:

          AFTER 1000000
            ...             EXECUTED AFTER 1,000,000 PASSES
          ELSE  ,
            ...             EXECUTED FIRST 1,000,000 PASSES
          ENDELSE ,

ELSEIF
THIS MACRO MAY FOLLOW ONLY ANOTHER 'ELSEIF' STATEMENT, OR AN 'IF'
STATEMENT. IT SUPPORTS ALL THE OPTIONS OF THE 'IF' STATEMENT. PLEASE
SEE THE 'IF' STATEMENT FOR THE DETAILS.

          IF    (...),THENDO
            ...
          ELSEIF (...),THENDO
            ...
          ENDELSE ,

ENDAFTER
ENDELSE
ENDEVERY
ENDFIRST
ENDIF
ENDO
THESE MACROS ARE EQUIVALENT, AND SHOULD BE USED TO END THEIR
RESPECTIVE TYPES OF CR-GROUPS.

EVERY
THIS MACRO HEADS A CR-GROUP THAT WILL BE EXECUTED EVERY 'N'TH PASS
THROUGH THIS SECTION OF CODE. 'N' MUST BE A NUMERIC SELF-DEFINING TERM.

         EVERY 1000000
            WTO   'ANOTHER 1,000,000 PASSES'
         ENDEVERY ,

FIRST
THIS MACRO HEADS A CR-GROUP THAT WILL BE EXECUTED FOR THE FIRST 'N'
PASSES THROUGH THIS SECTION OF CODE, AND THEN SKIPPED EVERY PASS
THROUGH THE CODE FROM THEN ON.  'N' MUST BE A NUMERIC SELF-DEFINING
TERM.

         FIRST 1000000
            ...
         ENDAFTER ,

ITS DESIGNED USE IS TO DO STUFF ONLY ON THE FIRST PASS THROUGH A
SECTION OF CODE

         FIRST 1
           OPEN  (...)
         ENDFIRST ,

IF
THIS IS THE HEART OF THE STRUCTURED MACROS. IT SUPPORTS THE
CONDITIONAL EXECUTION OF A CR-GROUP BASED ON ONE OR MORE TESTS. EACH
TEST PHRASE, CONTAINED WITHIN PARENTHESES, MUST CONSIST OF AN OP-CODE,
A FIRST OPERAND, A SECOND OPERAND, AND A CONDITION. (NOTE OP-CODES
WITH OTHER THAN TWO OPERANDS ARE SUPPORTED, BUT THE OP-CODE MUST
ALWAYS BE FIRST AND THE CONDITION MUST ALWAYS BE LAST WITHIN THE
PHRASE.)  FOLLOWING THE LAST PHRASE, THE FINAL POSITIONAL PARAMETER
MUST BE 'THENDO':

          IF    (CLC,FIELDA,FIELDB,E),THENDO
            ...
          ENDIF ,

NOTE THAT THE OP-CODE 'CLC' WILL BE USED THROUGHOUT THESE EXAMPLES.
WHEN YOU CODE YOUR PROGRAM, USE WHATEVER INSTRUCTION IS APPORPRIATE,
SO LONG AS IT IS ONE THAT SETS THE PROCESSOR'S CONDITION CODE FIELD.

IN THIS EXAMPLE, IF FIELDA IS EQUAL TO FIELDB, THEN THE CR-GROUP
WILL BE EXECUTED.  THE CONDITION, CODED AS THE LAST POSITIONAL
SUB-PARAMETER, CAN BE ANY OF THE EXTENDED BRANCH NMEMONICS:

  E NE H NH L NL M NM O NO P NP Z NZ

IN THE ABOVE EXAMPLE, THE MACRO EXPANDS INTO:

          IF    (CLC,FIELDA,FIELDB,E),THENDO
+         CLC   FIELDA,FIELDB    GENERATED
+         BNE   $TAG             BRANCH AROUND 'IF' GROUP
          ...                    YOUR INSTRUCTIONS
          ENDIF ,
+$TAG     DS    0H

NOTE: '$TAG' INDICATES THAT THE MACRO GENERATION PROCESS WILL GENERATE
AN UNIQUE TAG, WHOSE NAME BEGINS WITH '$', AND ENDS WITH A UNIQUE NUMBER
OBTAINED FROM A SYSTEM COUNTER.

IF YOU HAD CODED 'NE' AS THE CONDITION, THEN IT WOULD EXPAND TO:

          IF    (CLC,FIELDA,FIELDB,NE),THENDO
+         CLC   FIELDA,FIELDB    GENERATED
+         BE    $TAG             BRANCH AROUND 'IF' GROUP
          ...                    YOUR INSTRUCTIONS
          ENDIF ,
+$TAG     DS    0H

     TO EXECUTE THE CR-GROUP IF EITHER ONE OF TWO CONDITIONS IS
TRUE, THE FORMAT IS:

     IF    (CLC,A,B,NE),OR,(CLC,C,D,NE),THENDO

     ALTERNATE FORMAT:
                                                          72
     IF    (CLC,A,B,NE),OR,                                C
           (CLC,C,D,NE),THENDO

     SINCE 'AND' TAKES PRECEDENCE OVER 'OR', IN THE FOLLOWING
EXAMPLE, THE CR-GROUP IS PERFORMED IF THE FIRST TEST IS TRUE, OR
IF BOTH THE SECOND AND THIRD ARE TRUE:

     IF    (CLC,A,B,E),OR,                                 C
           (CLC,C,D,E),AND,                                C
           (CLC,E,F,E),THENDO

     IF THE CR-GROUP IS TO BE PERFORMED IF THE THIRD IS TRUE AND
EITHER THE FIRST OR SECOND IS TRUE, INCLUDE THE TESTS CONNECTED
BY THE 'OR' WITHIN ADDITIONAL PARENTHESES:

           * <-NESTING PARENTHESES -> *
     IF    ((CLC,A,B,E),OR,(CLC,C,D,E)),AND,               C
           (CLC,E,F,E),THENDO

     THE AUTHOR OF THESE MACROS PREFERS THE FORMAT:

     IF    ((CLC,A,B,E),OR,                                C
           (CLC,C,D,E)),AND,                               C
           (CLC,E,F,E),THENDO

     I GUESS THE BOTTOM LINE IS THAT S/390 ASSEMBLER IS SOMEWHAT OF A
PAIN, NO MATTER HOW YOU FORMAT THE STATEMENTS!

     GROUPS OF EXPRESSIONS MAY BE NESTED AS DEEPLY AS REQUIRED
TO DEFINE THE LOGIC DESIRED. THE LIMIT IS THAT ANY SINGLE
PARAMETER IS LIMITED BY THE ASSEMBLER TO 255 CHARACTERS IN LENGTH.

     EACH CR-GROUP MUST BE TERMINATED WITH AN 'ENDO' STATEMENT
OR AN 'ELSE' - 'ENDELSE' COMBINATION:

     ENDIF ,
                 - OR -
     ELSE  ,
     ... ADDITIONAL INSTRUCTIONS TO BE EXECUTED IF 'IF' FAILS
     ENDELSE ,  (OR ENDIF - EITHER IS ACCEPTABLE AFTER AN 'ELSE')

     ALTERNATIVELY, A CR-GROUP CAN BE TERMINATED AS FOLLOWS:

     ELSEIF  (CLC,G,H,E),THENDO ...
        ...
     ELSEIF  (CLC,I,J,E),THENDO ...
        ...
     ELSE  ,
        ...
     ENDELSE ,

     ANY NUMBER OF 'ELSEIF' STATEMENTS CAN FOLLOW THE ORIGINAL
     'IF' STATEMENT. THERE MAY BE (BUT NEED NOT BE) ONE AND ONLY
     ONE 'ELSE' STATEMENT FOLLOWING THE FINAL 'ELSEIF'. THE ENTIRE
     GROUP IS TERMINATED WITH ONE 'ENDIF' OR 'ENDELSE'.

NEXT
I WROTE THIS MACRO SO THAT AN ASSEMBLER PROGRAM COULD BE MADE TO LOOK
EVEN MORE LIKE COBOL.  IT IS THE EQUIVALENT TO 'CONTINUE', AND ITS ONLY
(REQUIRED) POSITIONAL PARAMETER IS 'SENTENCE':

         IF    (TM,0(R1),X'80',O),THENDO
            NEXT  SENTENCE
         ENDIF ,

THENDO
THIS WAS THE ORIGINAL STRUCTURED MACRO OF THIS PACKAGE.  IT IS NOT SO
POWERFUL AS THE NEWER ONES, BUT YOU MIGHT FIND SOME USE FOR IT. ITS ONLY
POSITIONAL PARAMETER MUST BE ONE OF THE CONDITIONS THAT YOU CAN APPEND
TO THE 'B' TO CREATE ONE OF THE EXTENDED BRANCH INSTRUCTIONS, SUCH AS
'E'.  PLEASE REFER TO THE DOCUMENTATION FOR THE 'IF' MACRO FOR A
COMPLETE LIST.

THIS MACRO DEPENDS ON A PREVIOUS INSTRUCTION IN THE PROGRAM, SUCH AS A
'CLR', TO SET THE CONDITION CODE. ITS CR-GROUP WILL THEN BE EXECUTED IF
THE OPERAND SATISFIES THE SETTING OF THE CONDITION CODE:

          CLR   R5,R6
          THENDO E
            ...
          ENDO  ,

          -- OR --

          CLC   R5,R6
          THENDO E
            ...
          ELSE  ,
            ...
          ENDO  ,

IN THIS EXAMPLE, THE FIRST CR-GROUP WILL BE EXECUTED IF R5 = R6, AND
THE SECOND WILL BE EXECUTED IF THEY ARE UNEQUAL.

THAT'S IT, FOLKS. NO OTHER OPTIONS FOR 'THENDO' (OTHER THAN NESTING).

                            2ND GENERATION

THIS SET OF MACROS WAS INTENDED TO MAKE IT SOMEWHAT EASIER FOR COBOL
PROGRAMMERS TO PICK UP S/390 ASSEMBLER. THE CODING CONVENTIONS ARE
STANDARD ASSEMBLER, BUT THE NAMES, OPERANDS, AND FUNCTIONS OF THE MACROS
JUST MIGHT MAKE THE TRANSITION A LITTLE EASIER.

THE 'DIVISION' AND 'SECTION' MACROS GIVE THE PROGRAM AN APPEARANCE NOT
TOO DIFFERENT FROM COBOL.  THE 'SECTION' MACRO CAN BE USED IN THE
'DATA DIVISION' (FOR DOCUMENTATION), BUT ITS USE IN THE 'PROCEDURE
DIVISION' IS USED TO DEFINE SUBROUTINES.

WHEN YOU CREATE AN EXECUTABLE SECTION (THAT IS, A 'SECTION' MACRO
WITHIN THE 'PROCEDURE DIVISION'), EXECUTION CAN BE TRANSFERRED IN ONE
OF THREE WAYS:
1. EXECUTION CAN FALL THROUGH INTO THE SECTION. IN THIS CASE, THE
   SECTION CAN BE USED TO INCREASE THE SIZE OF THE PROGRAM BEYOND THE
   4K LIMIT ON EXECUTABLE CODE WITHIN THE MAIN PORTION OF THE PROGRAM
   WHICH IS IMPOSED BY THE USE OF ONLY ONE BASE REGISTER. WHEN
   EXECUTION FALLS THROUGH INTO A SECTION, THEN EXECUTION 'FALLS OUT'
   AT THE END. WHEN THE PROGRAM BEGINS EXECUTION, THE RETURN LOGIC
   OF EACH SECTION IS PRE-SET TO FALL THROUGH TO THE NEXT SECTION, AND,
   WHENEVER IT IS EXECUTED VIA FALL-THROUGH, THIS SAME EXIT IS RESET.
2. A SECTION CAN BE EXECUTED BY THE 'PERFORM SECTNAME' MACRO. IN THIS
   CASE, WHEN THE SECTION FINISHES, EXECUTION RETURNS TO THE STATEMENT
   FOLLOWING THE 'PERFORM'. THIS LOGIC SETS THE RETURN OF THIS SECTION
   TO BE TO THE STATEMENT FOLLOWING THE PERFORM.
3. A SECTION CAN BE EXECUTED BY THE 'GOTO' STATEMENT.  THE 'GOTO' DOES
   NOT CHANGE THE EXIT LOGIC FOR THE SECTION, SO BEWARE USING MORE THAN
   ONE METHOD FOR SECTION EXECUTION. IF YOU USE ONLY FALL-THROUGH AND
   'GOTO', THEN EXECUTION WILL ALWAYS FALL THROUGH TO THE FOLLOWING
   SECTION. IF YOUR PROGRAM ALWAYS USES A 'PERFORM' FIRST, THEN A
   'GOTO', THEN EXECUTION WILL ALWAYS RETURN TO THE STATEMENT FOLLOWING
   THE 'PERFORM'.  IF YOU USE MULTIPLE 'PERFORMS' FOR A PARTICULAR
   SECTION, AND/OR ALLOW EXECUTION TO FALL THROUGH INTO THE SECTION,
   AND THEN YOU USE A 'GOTO' MACRO, AND YOU MAKE IT WORK CORRECTLY,
   THEN YOU'RE A BETTER PROGRAMMER THAN I.

A PROGRAM TO INCREMENT A COUNTER AND PRINT A LINE MIGHT LOOK LIKE:

IDENTIFICATION DIVISION PROGID=PRINTPGM
DATA     DIVISION
WORKING_STORAGE SECTION
COUNTER  DC    PL2'0'
PROCEDURE DIVISION ,
         MVC   OUTLINE+1(09),=CL09'TEST DATA'
         PERFORM COUNTRTN
         PERFORM PRINTRTN
         GOBACK ,
COUNTRTN SECTION ,
         AP    COUNTER,=P'1'
         UNPK  OUTLINE+11(3),COUNTER
         IO    OUTLINE+13,C'0'
         RETN  ,
         ENDSECT ,
PRINTRTN PRINTER ,
         FINAL ,
         END   PRINTPGM

DIVISION
THIS MACRO PROVIDES THE HEADING FOR EACH OF THE MAIN SECTIONS OF A
PROGRAM. THE NAME FIELD (BEGINNING IN COL 1) IS REQUIRED, AND, LIKE A
COBOL PROGRAM, THE DIVISIONS MUST OCCUR IN ORDER: IDENTIFICATION,
DATA, THEN PROCEDURE (SORRY, NO 'ENVIRONMENT' DIVISION IS SUPPORTED).

WHEN THE NAME FIELD IS 'IDENTIFICATION', THEN THE KEYWORD PARAMETER
'PROGID=' IS REQUIRED, AND THIS NAME BECOMES THE NAME OF THE CSECT (OR
PROGRAM) BEING CREATED:

IDENTIFICATION DIVISION PROGID=MAINPROG

THE NEXT STATEMENT IMPORTANT TO THESE MACROS WOULD BE:

DATA     DIVISION

NO PARAMETERS FOR THIS ONE, THANK YOU. WHAT THIS ONE DOES IS TO CREATE
TWO LOCATION COUNTERS (INST AND DATA), THEN CREATE A REGISTER SAVE AREA
WITHIN THE 'DATA' LOCTR. WHEN YOU CODE STATEMENTS WITHIN THE DATA
DIVISION, THEY MAY BE 'DC', 'DS', 'DCB', ETC.

THREE ADDITIONAL MACROS MAY BE INCLUDED WITHIN THE DATA DIVISION:

FILE     SECTION ,

WORKING_STORAGE SECTION ,

LINKAGE  SECTION ,

THESE ARE FOR DOCUMENTATION PURPOSES ONLY. YOU MIGHT MAKE IT EASIER
ON FUTURE PROGRAMMERS WHO WORK ON YOUR CODE IF YOU CODE 'DCB' STATEMENTS
WITHIN THE 'FILE SECTION', AND OTHER STATEMENTS THAT ACTUALLY ALLOCATE
STORAGE IN THE 'WORKING_STORAGE SECTION', AND MAPPING STATEMENTS SUCH AS
DSECTS IN THE 'LINKAGE SECTION'.

NEXT COMES THE:

PROCEDURE DIVISION ,

IT HAS AN OPTIONAL KEYWORD PARAMETER: INTRO=YES/NO. IF YOU CODE 'YES'
(WHICH IS THE DEFAULT), THEN MESSAGES ARE WRITTEN TO THE LOG ABOUT WHEN
THE MODULE WAS COMPILED, AND WHEN IT IS BEING EXECUTED. IF YOU CODE
'NO', THEN THE MESSAGES ARE NOT WRITTEN.

A SECOND OPTIONAL KEYWORD, 'BASE=', ALLOWS YOU TO SPECIFY A BASE
REGISTER. R12 IS THE DEFAULT.

ANOTHER OPTIONAL KEYWORD IS 'LINK='. THIS ALLOWS YOU TO SPECIFY A GPR
TO BE USED IN LINKING TO INTERNAL SUBROUTINES (VIA THE 'PERFORM'
MACRO). DEFAULT IS R14.

AFTER THIS 'PROCEDURE DIVISION' MACRO IS EXECUTED, THE ENVIRONMENT
PRESENTED TO YOU IS:

R1 POINTS TO THE HALFWORD DESCRIBING THE PARAMETERS (IF ANY) PASSED TO
   THIS PROGRAM
R12 (DEFAULT) IS THE BASE REGISTER
R13 POINTS TO THE REGISTER SAVE AREA (ALSO THE BEGINNING OF THE DATA
    DIVISION)

AT THIS POINT, YOU MAY START CODING 'NORMAL' EXECUTABLE INSTRUCTIONS.

ENDSECT
THIS STATEMENT MUST BE USED TO END THE CODE OF A 'SECTION' THAT YOU
HAVE CREATED TO BE USED AS AN INTERNAL SUBROUTINE. IT GENERATES A
'RETN' FUNCTION, SO THAT IF EXECUTION FALLS THROUGH TO THE 'ENDSECT'
STATEMENT, THE SUBROUTINE WILL RETURN CONTROL TO THE STATEMENT
FOLLOWING THE 'PERFORM' THAT INVOKED THE SECTION.

FINAL
THIS MACRO NEEDS TO BE CODED AS THE LAST STATEMENT BEFORE THE 'END'
STATEMENT FOR THE ASSEMBLY.  IT CORRELATES THE CREATION AND USAGE OF
THE 'SECTION' STATEMENTS IN THE PROGRAM, AND MAKES AS SURE AS POSSIBLE
THAT YOU HAVE USED THE 'PERFORM' AND 'SECTION' STATEMENTS CORRECTLY.
IF YOU OMIT THIS MACRO, YOU WILL GET ERROR MESSAGES ABOUT
UNDEFINED VARIABLES.

GOBACK
THIS STATEMENT CAN BE USED WITHIN THE MAIN PORTION OF A PROGRAM, OR
FROM WITHIN A 'PERFORMED' SECTION. IN EITHER CASE, IT SIGNALS THE
COMPLETION OF THIS PROGRAM AND RETURNS CONTROL TO THE OPERATING SYSTEM
(OR TO THE CALLING PROGRAM, IF AN MVS 'CALL' MACRO WAS USED TO INVOKE
THE PROGRAM).

ITS ONE OPTIONAL KEYWORD PARAMETER IS:

          GOBACK  RC=...

IF THE PARAMETER IS ENCLOSED WITHIN PARENTHESES, THEN IT MUST BE A GPR
WHICH CONTAINS THE VALUE TO BE USED AS A RETURN CODE. IF IT IS A
NUMERIC SELF-DEFINING TERM, THEN THAT VALUE BECOMES THE RETURN CODE. IF
IT IS THE NAME OF A HALFWORD OR FULLWORD IN STORAGE, THEN THE VALUE
STORED IN THAT VARIABLE BECOMES THE RETURN CODE.  IF THE PARAMETER IS
NOT CODED, THEN THE RETURN CODE IS LEFT AS IT IS.  THIS VALUE IS SET TO
ZERO WHEN THE PROGRAM BEGINS EXECUTION (BY THE PROCEDURE DIVISION
MACRO), AND CAN BE CHANGED VIA THE 'SETRC' MACRO.

GOTO
THIS IS ONE OF THE METHODS OF TRANSFERRING EXECUTION TO A 'SECTION'.
IT HAS ONE REQUIRED POSITIONAL PARAMETER, AND ONE OPTIONAL POSITIONAL
PARAMETER. IN THE FIRST EXAMPLE, EXECUTION IS TRANSFERRED
UNCONDITIONALLY TO THE SECTION:

          GOTO  MYSECT

IN THE SECOND EXAMPLE, EXECUTION IS TRANSFERRED CONDITIONALLY BASED ON
THE CURRENT SETTING OF THE CONDITION CODE (WHICH MUST HAVE BEEN SET BY
A PREVIOUS STATEMENT):

         CLC   FIELDA,FIELDB
         GOTO  E,MYSECT

IN THIS CASE, EXECUTION WOULD BE TRANSFERRED IF FIELDA = FIELDB,
OTHERWISE EXECUTION WOULD PASS TO THE STATEMENT FOLLOWING THE 'GOTO'.

PLEASE SEE THE DOCUMENTATION AT THE BEGINNING OF '2ND GENERATION' FOR
A THOROUGH DESCRIPTION OF THE CAVEATS CONCERNING THE USE OF THE 'GOTO'
MACRO.

PERFORM
THIS MACRO CAUSES EXECUTION TO TRANSFER UNCONDITIONALLY TO THE SECTION
IDENTIFIED BY ITS ONE REQUIRED POSITONAL PARAMETER:

          PERFORM MYSECT

WHEN THE SECTION FINISHES ITS EXECUTION, CONTROL IS RETURNED TO THE
STATEMENT FOLLOWING THE 'PERFORM'.

RETN
THIS MACRO, WHEN USED WITHIN A SECTION, CAUSES CONTROL TO BE RETURNED
TO THE STATEMENT IMMEDIATELY FOLLOWING THE 'PERFORM' STATEMENT, OR, IF
THE SECTION WAS ENTERED VIA FALL-THROUGH, TO THE FIRST STATEMENT OF THE
SECTION IMMEDIATELY FOLLOWING THIS SECTION.

ITS ONE OPTIONAL POSITIONAL PARAMETER TESTS A CONDITION, WHICH MUST HAVE
BEEN SET BY A PREVIOUS INSTRUCTION, UNDER WHICH A RETURN ACTION IS TO
OCCUR. IF THE CONDITION IS FALSE, THEN THE INSTRUCTION FOLLOWING THE
'RETN' WILL BE EXECUTED:

         RETN  ,            UNCONDITIONAL RETURN

         -- OR --

         CLC   FIELDA,FIELDB
         RETN  E            RETURN IF FIELDA = FIELDB
         ...                OTHERWISE FALL THROUGH

SECTION
WHEN VARIATIONS OF THIS MACRO ARE CODED WITHIN THE 'DATA DIVISION'
(PLEASE SEE THE DESCRIPTION OF THE 'DIVISION' MACRO), THEY HAVE A
DIFFERENT MEANING THAN WHEN THEY ARE USED IN THE 'PROCEDURE DIVISION'.

WHEN IT IS USED IN THE 'PROCEDURE DIVISION', THE 'SECTION' MACRO DEFINES
A GROUP OF INSTRUCTIONS THAT CAN BE CALLED AS AN INTERNAL SUBROUTINE
WITHIN THE PROGRAM BEING ASSEMBLED. IT CAN BE EXECUTED VIA FALL-THROUGH,
THE PERFORM MACRO, OR THE GOTO MACRO. BY DEFAULT, WHEN A SECTION BEGINS
EXECUTION, REGS 2 - 11 ARE SAVED, AND THEY ARE RESTORED WHEN EXECUTION
RETURNS TO THE CALLING STATEMENT.

IF YOU DO NOT WANT THE REGISTERS RESORED AFTER A SECTION'S EXECUTION,
THEN CODE THE OPTIONAL KEYWORD PARAMETER:

MYSECT   SECTION RESTORE=N

IF YOU WANT SOME DIFFERENT SET OF REGISTERS TO BE RESTORED, THEN YOU
CAN CODE:

MYSECT   SECTION MAXREG=NN

WHERE 'NN' IS THE NUMBER OF THE HIGHEST REGISTER THAT YOU WANT TO BE
RESTORED. THE LOWEST WILL ALWAYS BE REG 2. SO, IF YOU CODE:

MYSECT   SECTION MAXREG=8

THEN REGS 2 - 8 WILL BE RESTORED JUST BEFORE THE SECTION RETURNS CONTROL
TO THE CALLING ROUTINE.

                            1ST GENERATION

I WROTE THIS 'SUB-PACKAGE' OF MACROS IN THE EARLY 1970'S, AND IT MAY
OFFER MORE TOTAL VERSATILITY THAN THE 2ND GENERATION PACKAGE. THE MAIN
PROGRAM RESIDES IN A CSECT WITH THE SAME NAME AS THE NAME FIELD THAT
YOU SPECIFY ON YOUR 'GO' MACRO, IT USES A CSECT NAMED 'DATAAREA' TO
HOLD CONSTANTS AND VARIABLES, AND CREATES AN ADDITIONAL CSECT FOR EACH
'PROC' (SUBROUTINE) THAT YOU CREATE.  THE ORIGINAL INTENT WAS TO MAKE IT
EASY TO CREATE RE-ENTRANT PROGRAMS, BUT THAT FACET HAS NOT BEEN
COMPLETED.

ITS MAIN ADVANTAGE OVER THE 2ND GENERATION MACROS IS THAT THE USE OF
MULTIPLE BASE REGISTERS WITHIN EACH ROUTINE IS SUPPORTED, SO THAT IT
IS CONVENIENT TO HAVE A MODULE SIZE OF 8K, 12K, OR 16K, DEPENDING ON
THE NUMBER OF REGISTERS THAT YOU CARE TO DEVOTE TO ADDRESSABILITY.

PLEASE CONTACT THE AUTHOR FOR ADDITIONAL DOCUMENTATION.

THE FOLLOWING IS A ROUTINE THAT I USE TO CREATE ENTRIES IN A TRACE FILE
DURING THE TESTING PHASE OF A PROGRAM.  THE CALLING PROGRAM MUST PASS,
AS ITS ONLY PARAMETER, A 133 CHARACTER PRINT LINE (ASA CARRIAGE
CONTROL). WHEN CALLED FOR THE FIRST TIME, TRACERTN WILL ISSUE AN 'OPEN'
FOR THE FILE. AS THE CALLING PROGRAM IS TERMINATING, IT SHOULD CALL
TRACERTN WITH '99999999' IN COLS 2-9 OF THE DATA LINE, CAUSING TRACERTN
TO ISSUE A CLOSE FOR THE FILE.

         PRINT NOGEN
IDENTIFICATION DIVISION PROGID=TRACERTN
DATA     DIVISION
FILE     SECTION
PRINTER  DCB   DDNAME=TRACER,DSORG=PS,MACRF=PM,RECFM=FBA,LRECL=133,    X
               BLKSIZE=133
WORKING_STORAGE SECTION
SPACES   DC    CL133' '
LINKAGE  SECTION
PASSED   DSECT
PASSED_DATA DS CL133
PROCEDURE DIVISION INTRO=NO        DON'T ISSUE TIME-STAMP WTO
         L     R11,0(,R1)          ADDRESS OF CALLER'S DATA
         USING PASSED,R11          ASSEMBLER CONVENTION
         FIRST 1                   FIRST TIME THRU...
           IF   (CLC,=C'99999999',PASSED_DATA+1,E),THENDO CLOSE SIGNAL?
             GOBACK ,              DON'T DO NOTHIN
           ELSE  ,
             OPEN  (PRINTER,OUTPUT)  . OPEN THE TRACER FILE
           ENDIF ,
         ENDO  ,                   .
         IF    (CLC,=C'99999999',PASSED_DATA+1,E),THENDO CLOSE SIGNAL?
           CLOSE PRINTER           . YES - DO IT
         ELSE  ,
           PUT   PRINTER,PASSED_DATA . ELSE PRINT THE LINE
           MVC   PASSED_DATA,SPACES  AT YOUR SERVICE...
         ENDIF ,                   .
         GOBACK ,                  AMSCRAY
         FINAL ,                   BOOKKEEPING
         END

