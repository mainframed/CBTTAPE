                     Structured Macros
                                             by Dan Snyder

As you well know, if you have ever programmed in S/390 Assembler,
many aspects of it are impediments to creating decent code, rather
than assists.  Creating a large complex program can become a real
burden, just in accomplishing the necessary housekeeping.  And, just
because of the nature of coding in Assembler, most programs resemble
spaghetti code.  Since the programmer has to define a name to use as
a branch target for each piece of logic within the program, studying
someone else's code and determining the meaning of the various name
fields can be very frustrating.  Editing the source has its
challenges, but studying the Assembly listing can be even more
difficult.  What I longed for was just the simple Cobol IF-THEN-ELSE
construct.

With the intention of creating an environment that maintained all
the reasons for coding in Assembler in the first place, such as the
rich instruction set and the straightforward ability to access many
functions not conveniently available to those programming in other
languages, I started to work on a structured programming set of
macro definitions in the early 1970's.  This paper is not a
blue-sky picture of what life might be like 'if only...', but
rather is a treatise on the macro definitions that I created, which
are available on the CBT tape..

The cornerstone of these macros is the IF.  It would head a group of
instructions (cr-group for conditional/repetitive) that would then
be terminated with an ENDIF.  My goal in writing the IF was to
provide a maximum of flexibility along with a short learning curve
for those who had already mastered programming in Assembler.  So,
the format for the operand of the IF became a comma-delimited string
consisting of the op-code that would set the system's condition code
register, the a-operand, the b-operand, and the condition which
would cause the cr-group to be either executed or not executed. The
first operand of the IF must be one of these comma-delimited
strings, enclosed within parentheses.  For a simple condition,
follow this expression with 'THENDO':

                PRINT GEN                   DISPLAY MACRO EXPANSIONS
                IF      (CLC,FIELDA,FIELDB,E),THENDO
MVC     OUTPUT(20),FIELDA   DO IF FIELDA = FIELDB
                ENDIF ,

In this example, the Assembler listing would look like:

                PRINT GEN                   DISPLAY MACRO EXPANSIONS
                IF      (CLC,FIELDA,FIELDB,E),THENDO
+               CLC     FIELDA,FIELDB
+               BNE     $MDF0001
MVC     OUTPUT(20),FIELDA  DO IF FIELDA = FIELDB
                ENDIF ,
+$MDF0001       DC      0H'0'

First, a few observations.  The '+' at the left of some of the lines
of code indicates that that line was generated by the Assembler's
macro pre-processor (I.E. it is part of what is termed the 'macro
expansion').  Also, the last 4 characters of the generated tag,
'0001', is obtained from &SYSNDX, which is an internal Assembler
register that can be used to create uniqueness in generating tags
required when the same macro is invoked multiple times within a
given program.  In an actual Assembly, the four digits would
represent the then current value for &SYSNDX.  Here, we'll just use
0001.

Note also that each macro supports the use of a NAME field,
beginning in column 1, but why would you want to?

The condition, which comprises the fourth sub-parameter, may be any
one or two letters that can be appended to a 'B' to create one of
the extended branch instructions, such as 'E' or 'NE' creating 'BE'
or 'BNE'.  Thus, if the instruction created by the specified
op-code, a-operand and b-operand results in an 'Equal', then the
cr-group will be executed.

An optional 'ELSE' cr-group was also supported:

                IF      (CLC,FIELDA,FIELDB,E),THENDO
MVC     OUTPUT(20),FIELDA  DO IF FIELDA = FIELDB
                ELSE ,
MVC     OUTPUT(20),FIELDB  DO IF FIELDA NOT = FIELDB
                ENDIF ,

This would generate:

                IF      (CLC,FIELDA,FIELDB,E),THENDO
+               CLC     FIELDA,FIELDB
+               BNE     $MDF0001
MVC     OUTPUT(20),FIELDA  DO IF FIELDA = FIELDB
                ELSE ,
+               B       $MDS0001
+$MDF0001       DC      0H'0'
MVC     OUTPUT(20),FIELDB  DO IF FIELDA NOT = FIELDB
                ENDIF ,
+$MDS0001       DC      0H'0'

Obviously, since the programmer is responsible for coding the
instructions that set the condition code (the operands of the IF
macro), and the macro package generates only branch on condition
instructions and tags for these branch instructions, the generated
code is as efficient as it would be without using the macro package.

Additional IF statements and their associated cr-groups may be
nested to any required level (would anyone ever require more than
255 levels of nesting?):

                IF      (CLC,FIELDA,FIELDB),THENDO
                        IF      (LTR,R15,R15,Z),THENDO
                                ...
                        ELSE  ,
                                ...
                        ENDIF ,
                ENDIF ,

In creating the sub-fields representing a condition, the op-code
must be first and the condition must be last.  If you use an S/390
instruction that has more (such as SRP) or fewer (UPT and SSCH come
to mind) operands than the two that most instructions have, then you
should code the op-code, followed by any required operands, and then
the condition:

                IF      (SRP,PKDFLD1,64-3,0,NZ),THENDO
                ...                     INSTRUCTIONS EXECUTED IF THE SHIFT
                ...                     RESULTS IN A NON-ZERO CONDITION
                ENDIF ,

For complex conditions, the comma-delimited conditions must
alternate with an 'OR' or an 'AND', with the final conditional still
followed by that required 'THENDO':

                IF      (CLC,FIELDA,FIELDB,E),OR,
                        (TM,ENDSW,X'80',O),THENDO
                        ...
                ENDIF ,

During the initial phase of creating this package, I prepared a
'proof of concept' version, and tested it (to my complete
satisfaction). Next was the preparation of the 'industrial strength'
version, that would permit multiple conditions connected with OR or
AND clauses, and allowing additional parentheses to support the
typical situation where a cr-group would need to be executed if
either of two conditions were true, AND a third was true:

                IF      ((CLC,FIELDA,FIELDB,E),OR,
                        (TM,ENDSW,X'80',O)),AND,
                        (CP,COUNTER1,=P'1000000',L),THENDO
                        ...
                ENDIF ,

Please note the double parentheses at the left of the first
conditional phrase and at the right of the second.  This causes the
cr-group to be executed if the third condition results in a 'low',
and if either the first results in an 'equal' or the second results
in a 'ones'.   With this syntax it is possible to create an
arbitrarily complex condition to control the execution of the
following cr-group.

This version created correct code, so I started to do some
pathological testing, throwing all of the curves that I could think
of, including (there are 10 pairs of parentheses - don't bother
counting!):

                IF      ((((((((((CLC,FIELDA,FIELDB,E)))))))))),THENDO
                        MVC     OUTLINE(20),FIELDA
                ENDIF ,

The code that was generated produced correct output, but it looked
like:

                IF      ((((((((((CLC,FIELDA,FIELDB,E)))))))))),THENDO
+               CLC     FIELDA,FIELDB
+               BNE     *+8
+               B       *+8
+               B       *+8
+               B       *+8
+               B       *+8
+               B       *+8
+               B       *+8
+               B       *+8
+               B       *+8
+               B       *+8
+               B       *+8
+               B       *+8
+               B       *+8
+               B       *+8
+               B       *+8
+               B       *+8
+               B       *+8
+               B       *+8
+               B       $MDF0001
                        MVC     OUTLINE(20),FIELDA
                ENDIF ,
+$MDF0001       DC      0H'0'

Well, even though the program worked correctly, the generated code
wasn't too cool.  So, although I hadn't intended to create a 2nd
production version, guess what?  I did.  When I fed the above
program into this new version, here's what came out:

                IF      ((((((((((CLC,FIELDA,FIELDB,E)))))))))),THENDO
+               CLC     FIELDA,FIELDB
+               BNE     $MDF0001
                        MVC     OUTLINE(20),FIELDA
                ENDIF ,
+$MDF0001       DC      0H'0'

So at last we had the functionality and elegance that we needed.
The IF was complete, and what followed were additional macro
definitions based on it.

Since the CASE verb appears in just about every language (called
EVALUATE in Cobol), a simple addition to this package provides
similar functionality: the ELSEIF statement.  It has the same syntax
as the IF, and one or more may be coded between the IF and its
cr-group terminating ENDIF, or the ELSE, if one is needed:

IF    (CLC,FIELDA,FIELDB,E),THENDO
                        MVC   OUTPUT(20),FIELDA
                        ELSEIF (CLC,FIELDA,FIELDC,E),THENDO
                        MVC   OUTPUT(20),FIELDC
                        ELSEIF (CLC,FIELDA,FIELDD,E),THENDO
                        MVC   OUTPUT(20),FIELDD
                        ELSE  ,
                        MVC   OUTPUT(20),FIELDE
                        ENDIF ,


                IF    (CLC,FIELDA,FIELDB,E),THENDO
+               CLC   FIELDA,FIELDB
+               BNE   $MDF0001
                        MVC   OUTPUT(20),FIELDA
                        ELSEIF (CLC,FIELDA,FIELDC,E),THENDO
+               B     $MDF0005
+$MDF0001       CLC   FIELDA,FIELDC
+               BNE   $MDF0006
                        MVC   OUTPUT(20),FIELDC
                        ELSEIF (CLC,FIELDA,FIELDD,E),THENDO
+               B     $MDF0005
+$MDF0006       CLC   FIELDA,FIELDD
+               BNE   $MDF0010
                        MVC   OUTPUT(20),FIELDD
                        ELSE  ,
+               B     $MDS0010
+$MDF0010       DC      0H'0'
                        MVC   OUTPUT(20),FIELDE
                        ENDIF ,
+$MDS0010 DC    0H'0'
+$MDF0005 DC    0H'0'

In this example, I copied the SYSPRINT from an Assembly to
illustrate the actual names that are generated.

Next on the list of necessary functionality is the need to execute a
cr-group repetitively.  This led to the creation of the DO macro.
DO has several different formats.  The simplest is to execute a
cr-group a specific number of times:

        DO      5
                WTO     '**** ERROR **** PGM TESTPGM TABLE OVERFLOW'
        ENDO ,

In this form, the DO macro causes the statements between it and the
cr-group terminating ENDO to be executed 'n' times, where 'n' is a
numeric, self defining integer.

A second form is:

        PACK    PKDFLD1,=Z'10'
        DO      PKDFLD1
                WTO     '2ND ERROR'
        ENDO ,

When you use this option, the operand of the DO must be a packed
decimal field, and its value must have been set before the DO is
executed.  The DO macro makes a local copy of the value of the
parameter, so that if its value is changed during the repetitive
execution of the cr-group, that change will not effect the current
execution, but it will control the number of loops  the next time it
is executed.

If you need to create a never-ending loop, you would code:

        DO      FOREVER
                ...
        ENDO    ,

In this case, something other than the DO statement would be
responsible for ending the loop, such as a branch instruction within
the loop (horror!), or a System 222, etc.

If you need to control the loop with a simple or complex condition,
you may code either the UNTIL= or the WHILE= parameter. If you need
a simple condition, then enclose the sub-parameters within single
parentheses:

        DO      UNTIL=(CLC,FIELDA,FIELDB,E)
                ...
                MVC     FIELDA,FIELDB
        ENDO    ,

Although the DO macro invokes the IF to do the actual processing of
the conditional phrases, you do not include the THENDO phrase here.
However, if you code a complex conditional, including one or more OR
or AND phrases, then you must enclose the entire set of conditions
within an additional set of parentheses:

DO      UNTIL=((CLC,FIELDA,FIELDB,E),AND,
                (CLI,ENDFLAG,C'Y',NE))
                        ...
                        MVC     FIELDA,FIELDB
ENDO    ,

You may code either the WHILE or the UNTIL clause, but not both.  In
either case, the cr-group will be executed zero or more times, based
on the evaluation of the conditions.  If you need the cr-group to be
executed at least one time, then you can add the keyword parameter
TEST=AFTER to either of the above two options:

        DO      UNTIL=(CLI,ENDFLAG,C'Y',E),TEST=AFTER
                ...
                MVI     ENDFLAG,C'Y'
        ENDO ,

If you don't specify TEST=AFTER, then the default TEST=BEFORE applies.

If you look at these macros on the CBT tape, you will see reference
to a few other structured macros, and many other general purpose
macros, with some supporting subroutine creation and linkage.  But,
alas, they will have to wait for another article.


