//DSPACE   JOB
/*ROUTE  PRINT R7
//*
//*    DSN=CBT.SOURCE(DSPACE)
//*
//*     FIND 'END FOR NOW' TO GET  TO LKED STEP....
//*
//*
//SPACE EXEC HLASMCL,PARMC='ESD',PARML='LIST,LET,MAP,NCAL'
//ASM.SYSLIB DD DSN=SYS1.MACLIB,DISP=SHR
//           DD DISP=SHR,DSN=RH87944.SOURCE.CNTL
//           DD DSN=SYS1.MODGEN,DISP=SHR
//ASM.SYSPRINT DD SYSOUT=*
//ASM.SYSIN DD *
*    THIS VERSION OF DS USES SUPER LOCATE TO SEARCH THE
*    CATALOG, AND UCBSCAN TO SEARCH THE UCB TABLE.
*
*      THIS  VERSION ALSO HANDLES MIGRATED DATASETS
*
*      JAN 99...SINCE I FIGURED OUT HOW TO USE THE UNIT ADDRESS,
*               CHANGE DEFAULT UNIT IN VARIABLE TUPAR3 TO BLANK
*               AND USE THE 4 DIGIT UNIT ADDRESSES FROM THE UCB
*               FOR THE UNIT NAME...IT S/B IN FORMAT /1234...
*               SEE CODE AT LABEL MOVEVOLS.
*               OF COURSE, SPECIFYING UNIT() OVERRIDES THIS...
*            ...ADD CODE AT LABEL DOSVC99 TO SHOW REASON CODE
*               AND INFO CODE IF SVC 99 FAILS....
*
*      MAR 98...ADD CODE AT LABEL NOPRINT TO DETERMINE WHAT
*               SYSTEM WE ARE ON.
*               IF ON THE Y1YY, CHANGE THE SMS MCDS DATASET.
*
*      MAR 98...CHANGE DEFAULT UNIT IN VARIABLE TUPAR3 TO SYSDA
*               SO THAT DS CAN HANDLE 4 DIGIT UNIT ADDRESSES
*               AND DON'T USE UNIT NAME FROM UCB.
*               IT APPEARS THAT SVC 99 AND DAIRFAIL DON'T LIKE
*               4 DIGIT UNIT NAMES SUCH AS 1530...
*
*      MAR 97...USE IDCAMS TO GET VOLSERS IF LOCATE SHOWS MORE
*               THAN 6 FOR A DATASET, AS LOCATE ONLY GIVES
*               1ST 20 VOLSERS.
*            ...ADDED AN MCDS(...) KEYWORD TO ALLOW CHANGING
*               DEFAULT OF "SMS.DFHSM.MCDS" AT LABEL MCDDSN...
*
*      JAN 96...CHANGED VTCREAD TO STOP READING VTOC WHEN 255
*               EMPTY BLOCKS ARE FOUND.
*            ...DON'T PRINT GDG AND TAPE MSGS IF NOLIST
*      OCT 95...CHANGED VTCREAD TO STOP READING VTOC WHEN THE 2ND
*               EMPTY BLOCK IS  FOUND.
*      MAY 95...FIX 66D ABEND IN TSOPUT/PUTLINE...CLEAR ECB/IOPLUPT
*      JAN 95...CHANGED TPUT TO PUTLINE FOR DATASET OUTPUT.
*            ...CHANGED INDEX OUTPUT TO INCLUDE CREATE/USED DATES.
*            ...CHANGED VTCREAD TO GET TRKS/CYL FROM DSCB 4
*      FEB 94...CHANGED IKJPARS FOR DSNAME FROM IKJPOSIT TO
*               IKJIDENT SO GDGS COULD BE SPECIFIED.
*      JUL 93...ADDED DYNAMIC=YES TO UCBSCAN MACRO.
*               (AT LABEL NEXTUCB).
*      NOV 89...FIX FREE OF MCDS DATASET, AND PRINT MSG IF NOT.
*               (AT LABEL CLSNVSAM).
*      NOV 89...MODIFIED TO SEE IF PRINT(...) DATASET IS MIGRATED.
*               (AT LABEL LISTEMOK).
*      AUG 88...MODIFIED TO PROPERLY HANDLE MULTI-VOLUME DATASETS.
*
SP       TITLE  'TSO SPACE COMMAND'
         MACRO
&LAB     PUTIT &MESS,&LTH,&RET=NO
         LCLC  &L
&L       SETC  'L'''
         AIF   ('&MESS'(1,1) EQ '''').NOLTH TITLE IN QUOTES?
         AIF   ('&LTH' EQ '').DOLTH  LTH SPECIFIED?
.*       DC    C'&TITLE'          COMMENT...
.*       AGO   .NOCOMM
&LAB     MVC   MSG+1(&LTH),&MESS    MOVE MSG TO PRINT
         LA    R14,0              SET R14 = 0
         AIF   ('&RET' EQ 'NO').NORET  B IF NO RETURN
         LA    R14,*+4+4          SET R14 = A(AFTER PUTIT)
.NORET   ANOP
         B     PRINTMSG           GO PRINT IT
         MEXIT
.DOLTH   ANOP
&LAB     MVC   MSG+1(&L.&MESS),&MESS    MOVE MSG TO PRINT
         LA    R14,0              SET R14 = 0
         AIF   ('&RET' EQ 'NO').NORET2 B IF NO RETURN
         LA    R14,*+4+4          SET R14 = A(AFTER PUTIT)
.NORET2  ANOP
         B     PRINTMSG           GO PRINT IT
         MEXIT
.INQ     ANOP
.*       DC    C&TITLE            COMMENT...
.NOLTH   ANOP
&LAB     MVC   MSG+1(&L.M&SYSNDX),M&SYSNDX  MOVE MSG TO PRINT
         LA    R14,0              SET R14 = 0
         AIF   ('&RET' EQ 'NO').NORET3 B IF NO RETURN
         LA    R14,M&SYSNDX.R     SET R14 = A(AFTER PUTIT)
*        LA    R14,8(0,R14)       SET R14 = A(AFTER PUTIT)
.NORET3  ANOP
         B     PRINTMSG           GO PRINT IT
M&SYSNDX DC    C&MESS
M&SYSNDX.R DS  0H
         MEND
         MACRO
&LAB     TPUTIT &MESS
         LCLC  &L
&L       SETC  'L'''
&LAB     TPUT  M&SYSNDX,&L.M&SYSNDX
         B     RETURN
M&SYSNDX DC    C&MESS
         MEND
         MACRO
&LAB     PUTIT1 &MESS
&LAB     BAL   LINK,CLOSRDR
         STAX  DEFER=NO
         PUTIT &MESS
         MEND
*
         COPY  MACROS             THESE ARE IN RH87944.SOURCE.CNTL
*
*              END OF MACROS....
*
         EJECT
SPACE    CSECT
SPACE    AMODE 31
SPACE    RMODE 24
* SPACE LEVEL(--------)
* NOTE LEVEL DEFAULTS TO USERID
BASE     EQU   12
         ENTRY SW3,MSG,REPORT,INFO1
START    DS    0H
         USING *,R15
         B     AROUND             BRANCH AROUND DUMP TITLE
EYECATCH DC    AL1(EYELTH)        LTH OF EYECATCHER
         DC    C'DSPACE  '        PROGRAM NAME
         DC    C'VERSION 5.1 '    VERSION
         DC    CL8'&SYSDATE'      DATE WRITTEN
         DC    CL6'&SYSTIME'      TIME WRITTEN
         DC    C' '
         DC    C'CHANGE VTCREAD TO STOP AT 255TH EMPTY DSCB BLOCK'
         DC    C' AND ADD HELP SCREENS'
EYELTH   EQU   *-EYECATCH
*        DC    C'VERSION 5.0 '    VERSION
*        DC    C'CHANGE VTCREAD TO STOP AT 2ND BINARY DSCB BLOCK'
         SPACE 1
AROUND   DS    0H
         DROP  R15
         STM    14,12,12(13)
         LR    BASE,15
         USING SPACE,BASE,R11,R7
         LA    R11,4095(0,R12)   LOAD SECOND BASE REGISTER
         LA    R11,1(0,R11)      LOAD SECOND BASE REGISTER
         LA    R7,4095(0,R11)    LOAD THIRD  BASE REGISTER
         LA    R7,1(0,R7)        LOAD THIRD  BASE REGISTER
         L     15,=A(SUPRSAVE)
         ST    13,4(15)
         ST    15,8(13)
         LR    13,15
         B     SUPRSAVE+72
SUPRSAVE DC    18A(0)
         LR    R10,R1  SAVE PARM LIST
         ST    R10,CPPLADDR         SAVE A(CPPL)
         USING CPPL,R10           ADDRESS IT
         USING PSCB,R9
         SPACE 1
         L     R3,=V(IOPLADD)     R3 -> TO IOPL
         USING IOPL,R3            SET IOPL BASE
         L     R4,CPPLUPT
         ST    R4,IOPLUPT         SET UP IOPL
         L     R4,CPPLECT
         ST    R4,IOPLECT
         L     R4,=V(ECB)
         ST    R4,IOPLECB
         DROP  R3                 DROP IOPL BASE....
         SPACE 1
         L    R15,16               CVT POINTER
         L    R15,0(R15)           TCB PTR PTR
         L    R15,0(R15)           TCB POINTER
         L     R15,180(0,R15)     R15 -> TO JSCB                    RH3
         L     R15,264(0,R15)     R15 -> TO TSO PSCB                RH3
         LTR   R15,R15            IS THERE A PSCB?                  RH3
         BP    BYPASSF            YES, IT'S A TSO TERMINAL          RH3
*                                 NO, IT'S A BATCH JOB. SET FLAG    RH3
         OI    SW3,SW380           SAY BATCH PROCESSING
         OPEN  (REPORT,(OUTPUT))
         TM    REPORT+48,X'10'    DID REPORT FILE OPEN ?            RH
         BZ    ABEND1             NO                                RH
         MVI   PRINTNOP+1,X'00'   YES, CHANGE B TO NOP              RH
         MVI   RETNOP+1,X'00'     YES, CHANGE B TO NOP              RH
         OPEN  (SYSIN,(INPUT))    OPEN INPUT FILE                   RH
         TM    SYSIN+48,X'10'     DID SYSIN FILE OPEN ?             RH
         BZ    USEPARM            NO                                RH
         OI    SW3,SW340          YES, SAY WE HAVE SYSIN            RH
         SPACE 1
GETIN    DS    0H
         GET   SYSIN              READ A RECORD
         LR    R2,R1              R2 -> TO DATASET NAME
         SPACE 1
BATLOOP1 DS    0H
         CLI   0(R2),C' '         END OF DSN ?
         BE    ENDLOOP1           YES
         LA    R2,1(0,R2)         R2 -> TO NEXT DSN CHAR
         B     BATLOOP1           CHECK IT
         SPACE 1
ENDLOOP1 DS    0H
         SR    R2,R1              R2 = LTH OF DSN
         LR    R3,R1              R3 -> TO DSN
         LA    R4,LVLBUF+2        R4 -> TO WHERE DSN GOES
         MVC   LVLBUF(2),=XL2'00' LTH = 0
         MVI   0(R4),C' '         CLEAR DSN FIELD
         MVC   1(43,R4),0(R4)     ''
         MVC   DSNAME(44),0(R4)   CLEAR FIELD CALLED DSNAME
         B     BATCH0             CONTINUE
         SPACE 1
USEPARM  DS    0H
         L     R9,0(0,R10)        R9 -> TO PARM
         LA    R4,LVLBUF+2        R4 -> TO WHERE DSN GOES
         MVC   LVLBUF(2),=XL2'00' LTH = 0
         LH    R2,0(0,R9)         R2 = LTH OF DSN
         LA    R3,2(0,R9)         R3 -> TO DSN
         SPACE 1
BATCH0   DS    0H
         LA    R10,FAKECPPL       R10 -> TO FAKE CPPL
         LA    R6,FAKEVOL         R6 -> TO FAKE VOL LIST
         USING VOLDX,R6           SET BASE
         L     R9,CPPLPSCB        R9 -> TO FAKE PSCB
         ST    R9,PSCBADDR        SAVE PSCB ADDR
         SR    R8,R8              CLEAR R8
         B     BATCH1             ON WE GO
         SPACE 1
FAKECPPL DS    0F
         DC    2F'0'
         DC    A(FAKEPSCB)
         DC    F'0'
FAKEPSCB DS    0F
         DC    CL7' '
         DC    CL1' '
         DC    CL8' '
         DC    X'80'
         DC    CL56' '
FAKEVOL  DS    0C
         DC    6X'00'
         DC    2X'00'
         DC    X'FF000000'
         SPACE 1
*        SET UP PARM FOR PARSE
         SPACE 2
REPOPEN  DS    0H                                                   RH
BYPASSF  DS    0H                                                   RH
         L     R9,CPPLPSCB
         ST    R9,PSCBADDR        SAVE PSCB ADDR
         MVC   PPLUPT,CPPLUPT
         MVC   PPLECT,CPPLECT
         MVC   PPLCBUF,CPPLCBUF
         LA    R1,PPLUPT  POINT TO IT
         LINK  EP=IKJPARS
         B     *+4(R15)  BRANCH ON RETURNED CODE
         B     PARSOK
         B     ERROR2
         B     RETURN  USER ATTNED OUT
         B     ABEND1  PROGRAM BUG
         B     ERROR3  SPACE NOT AVAILABLE IN REGION
         B     ERROR4  INVALID PARM
         EJECT
PARSOK   L     R8,PPLANS  CHECK ANSWER ADDRESS
         LTR   R8,R8
         BZ    ABEND2  PARSE ERROR
         USING IKJPARMD,R8
         SPACE 5
*        SET UP FOR CALL TO DAIR
         MVC   DAPLUPT,CPPLUPT
         MVC   DAPLECT,CPPLECT
         MVC   DAPLPSCB,CPPLPSCB
         SPACE 1
PRINTSET DS    0H                                                   RH
         LH    R5,PRNTKWD         R5 -> TO PRINT KEYWORD            RH
         CH    R5,=H'1'           IS THERE A PRINT KEYWORD ?        RH
         BNE   NOPRINT            NO, PRINT AT TERMINAL             RH
         SPACE 1                                                    RH
         OI    SWITCHWD,PRINTIT   YES, TURN ON SWITCH               RH
         LA    R5,PRINTDD         R5 -> TO PRINT DSN                RH
         USING SVDDX,R5           SET BASE FOR PRINT DSN KEYWORD    RH
         MVC   PRTDSNL,SVDLTH     MOVE DSNAME LTH TO DAIR WORK AREA RH
         L     R2,SVDPTR          R2 -> TO PRINT DSNAME             RH
         LH    R14,SVDLTH         R14 = DSN LTH                     RH
         BCTR  R14,0              SUBT 1 FOR MVC LTH                RH
         STC   R14,MVC1+1         SET MVC LTH                       RH
MVC1     MVC   PRTDSN,0(R2)       MOVE DSN TO DAIR WORK AREA        RH
         SPACE 1                                                    RH
NOPRINT  DS    0H
*
*              FIND WHAT SYSTEM WE ARE ON.
*              IF ON THE Y2K, CHANGE SMS DSN
*
         L     R5,16              R5 -> TO ASCB
         L     R5,196(0,R5)       R5 -> TO BATCH JOB PTR
         LA    R5,16(0,R5)        R5 -> AT SYSTEM ID
         CLC   =C'Y1YY',0(R5)     ARE WE ON Y1YY?
         BNE   MCDSSET            NO, SMS DSN IS OKAY
*        LA    R5,MCDDSNL2        YES, R5 -> AT Y2K SMS DSN
*        ST    R5,MCDDDSN         SAVE IT
         MVC   MCDDSNL(46),MCDDSNL2    CHANGE MCD DSN
*
MCDSSET  DS    0H                                                   RH
         LH    R5,MCDSKWD         R5 -> TO MCDS  KEYWORD            RH
         CH    R5,=H'1'           IS THERE AN MCDS KEYWORD ?        RH
         BNE   NOMCDS             NO, USE DEFAULT                   RH
         SPACE 1                                                    RH
         MVI   MCDDSN,C' '        CLEAR OUT DEFAULT MCDS NAME       RH
         MVC   MCDDSN+1(43),MCDDSN ....                             RH
         LA    R5,MCDSDSN         R5 -> TO MCDS DSN                 RH
         USING SVDDX,R5           SET BASE FOR PRINT DSN KEYWORD    RH
         MVC   MCDDSNL,SVDLTH     MOVE DSNAME LTH TO DAIR WORK AREA RH
         L     R2,SVDPTR          R2 -> TO MCDS  DSNAME             RH
         LH    R14,SVDLTH         R14 = DSN LTH                     RH
         BCTR  R14,0              SUBT 1 FOR MVC LTH                RH
         STC   R14,MVC2+1         SET MVC LTH                       RH
MVC2     MVC   MCDDSN,0(R2)       MOVE DSN TO DAIR WORK AREA        RH
         SPACE 1                                                    RH
NOMCDS   DS    0H
         LA         R5,DSNCT      R5 -> TO MAX PARM
         DROP       R5
         USING      DSNCTDX,R5
         TM         DSNCTFLG,DSNCTON
         BZ         NODSNCT
         MVC   MAXBUF(2),DSNCTLTH
         L     R5,DSNCTPTR
         MVC   MAXBUF+2(8),0(R5)
NODSNCT  LA         R5,ACCUMKWD   R5 -> TO TOTAL PARM
         DROP       R5
         USING      TOTDX,R5
         TM    TOTTYPE+1,TOTON    WAS TOTAL KEYWORD SPECIFIED ?
         BZ    NOTOTAL            NO, TAKE DEFAULTS OF
*                                     YES IF HLI,
*                                     NO, IF DSN
         LA         R5,PERCKWD
         DROP       R5
         USING      PERCDX,R5
         TM    PERCTYPE+1,PERCNO  IS IT TOTAL(NO) ?
         BO    NOTOTAL            YES, ON WE GO, AS THATS DEFAULT
         OI    SWITCHWD,PERCENTS+TOTALIT CHANGE TO TOTAL(YES)
NOTOTAL  LA         R5,LISTKWD    R5 -> TO LIST KEYWORD
         DROP       R5
         USING      LISTDX,R5
         TM         LISTTYPE+1,LISTOFF
         BZ         LISTEM
         OI         SWITCHWD,OFFLIST
         DROP       R5
LISTEM   EQU        *
         TM    SWITCHWD,PRINTIT   PRINT TO A FILE?                  RH
         BZ    PDEADDR            NO, SKIP ALLOC CRAP               RH
         LA     R4,PRTDSN         R4 -> TO PRINT DSN                RH
         ST     R4,TCAMDSN        PUT A(DSN) IN TCAM LIST           RH
         LOCATE TCAML             GO FIND VOL SER FOR PRINT DSN     RH
         LTR    R15,R15           WAS IT FOUND ?                    RH
         BZ    LISTEMOK           YES                               RH
         SPACE 1
LISTBAD  DS    0H
         NI    SWITCHWD,255-PRINTIT  TURN OFF PRINT TO A FILE SW    RH
         B      ERROR10           SAY NOT CATALOGUED                RH
         SPACE 1
LISTEMOK DS    0H
         CLC   =C'MIGRAT',TWORK+6 BUT WAS IT MIGRATED?              RH
         BE    LISTBAD            YES, TOO BAD                      RH
         MVC   PRTDVSER(6),TWORK+6 MOVE VOLSER TO DAIR BLOCK        RH
         MVI   PRTDDSP1,X'01'     DISP=OLD                          RH
         LA    R14,PRTDRBLK       PUT A(PRINT DAIR BLOCK)           RH
         ST    R14,DAPLDAPB       IN DAIR PARM LIST                 RH
         LA    R1,DAPLUPT         R1 -> TO DAIR LIST                RH
         LINK  EP=IKJDAIR         CALL DAIR                         RH
         B     *+4(R15)           BRANCH ON RETURNED CODE           RH
         B     DAIROK1            DAIR OK, CONTINUE                 RH
         B     ABEND1  INVALID PARM LIST                            RH
         B     ERROR10  DATA SET NOT IN CATALOG                     RH
         B     DAIRERR  DAIR ERROR                                  RH
         B     ERROR5  NO TIOT ENTRIES AVAILABLE                    RH
         B     ERROR6 DDNAME NOT AVAILABLE                          RH
         B     ERROR7 DSNAME IS MEMBER OF CONCAT GRP                RH
         B     ABEND1 DDNAME OR DSNAME NOT ALLOC                    RH
         B     ERROR8  OLD DATA SET                                 RH
         B     ABEND1  ERROR IN CATALOG ROUTINE                     RH
         B     ABEND1  OUT OF QUALIFIER ROOM                        RH
         B     ERROR11  DELETED DATA SET                            RH
DAIROK1  DS    0H                                                   RH
         OPEN  (PRTDCB,(OUTPUT))  OPEN FILE AS OUTPUT TO POINT      RH
         CLOSE (PRTDCB)           TO FRONT, THEN CLOSE IT           RH
         LA    R1,DA18CD          R1 -> TO FREE DAIR BLK            RH
         ST    R1,DAPLDAPB        PUT FREE BLK ADDR IN DAIR UPT     RH
         MVC   DA18DDN(8),PRTDDDNM MOVE PRINT DDN TO DA18 BLOCK     RH
         LA    R1,DAPLUPT         R1 -> TO DAIR UPT                 RH
         LINK  EP=IKJDAIR         LINK TO DAIR                      RH
         LTR   R15,R15            WAS FREE OKAY ?                   RH
         BNZ   DAIRERR2           NO, GO TO ERROR ROUTINE           RH
         MVI   PRTDDSP1,X'02'     CHANGE DISP TO MOD                RH
         LA    R14,PRTDRBLK       PUT A(PRINT DAIR BLOCK)           RH
         ST    R14,DAPLDAPB       IN DAIR PARM LIST                 RH
         LA    R1,DAPLUPT         R1 -> TO DAIR LIST                RH
         LINK  EP=IKJDAIR  CALL DAIR                                RH
DAIRERR2 B     *+4(R15)  BRANCH ON RETURNED CODE                    RH
         B     RESETDRB           DAIR OK, CONTINUE                 RH
         B     ABEND1  INVALID PARM LIST                            RH
         B     ERROR10  DATA SET NOT IN CATALOG                     RH
         B     DAIRERR  DAIR ERROR                                  RH
         B     ERROR5  NO TIOT ENTRIES AVAILABLE                    RH
         B     ERROR6 DDNAME NOT AVAILABLE                          RH
         B     ERROR7 DSNAME IS MEMBER OF CONCAT GRP                RH
         B     ABEND1 DDNAME OR DSNAME NOT ALLOC                    RH
         B     ERROR8  OLD DATA SET                                 RH
         B     ABEND1  ERROR IN CATALOG ROUTINE                     RH
         B     ABEND1  OUT OF QUALIFIER ROOM                        RH
         B     ERROR11  DELETED DATA SET                            RH
         SPACE 1                                                    RH
RESETDRB DS    0H                                                   RH
         OPEN  (PRTDCB,(OUTPUT))  OPEN FILE AS OUTPUT AGAIN         RH
         SPACE 1                                                    RH
PDEADDR  LA        R5,SVDSN              R5 -> TO ALLOC PARMS
         USING     SVDDX,R5
         LA        R6,SERS        R6 -> TO VOL KEYWORD
         USING     VOLDX,R6
         LA        R9,LEVEL       R9 -> TO SEARCH NAME
         USING     LVLDX,R9
         DROP       R10
*        L     R10,0(0,R9)        R10 -> TO DSNAME
         ICM   R10,15,0(R9)       R10 -> TO DSNAME        JAN96
         BZ    SETR10             NO DSNAME.....          JAN96
         CLC   =C'HELP',0(R10)    SHOW HELP PANEL?        JAN96
         BNE   NOHELP             NO                      JAN96
         EXTRN HELPPAN
         L     R15,=V(HELPPAN)    LOAD A(HELP PANEL)
         CALL  (15)               GO PRINT HELP PANEL     JAN96
*        CALL  HELPPAN            GO PRINT HELP PANEL     JAN96
         B     RETURN             END OF DS CMD           JAN96
         SPACE 1                                          JAN96
NOHELP   DS    0H                                         JAN96
*
*                  SEE IF DSNAME WAS QUOTED....
*
         BCTR  R10,0              R10 -> TO CHAR BEFORE DSNAME
         CLI   0(R10),C''''       IS DSNAME QUOTED?
         BNE   SETR10             NO
         OI    LVLFLG,X'40'       YES, SAY DSNAME IS QUOTED
         SPACE 1
SETR10   DS    0H
         LA        R10,UNIT       R10 -> TO UNIT KEYWORD
         USING     UNTDX,R10
         LH        R8,SUPV               R8 = NBR OF ALLOC DSNS
         DROP      R8
LVLSTRNG TM        LVLFLG,B'11000000'
         BNO       NOQUOTE
         LA        R4,LVLBUF+2
         MVC       LVLBUF(2),=X'0000'                               RH
MOVELVL  LH        R2,LVLLTH
         L         R3,LVLPTR
         SPACE 1                                                    RH
BATCH1   DS    0H
         SH        R2,=H'1'
         EX        R2,XMOVE
         AH        R2,=H'1'
         AH        R2,LVLBUF
         STH       R2,LVLBUF
         B     VOLDSNMX           GO TEST FOR UNIT PARM             RH
         SPACE 1                                                    RH
NOQUOTE  DS    0H
         SR    R2,R2               R2 = 0
         L     R3,DAPLUPT          R3 -> TO UPT
         LA    R3,16(0,R3)         R3 -> UPT USER NAME
         CLI   7(R3),X'00'         UPT HAVE HIGH LEVEL INDEX ?
         BE    NOUPT               NO, USE TSOID
         IC    R2,7(R3)            R2 = LTH OF UPTUSER
         B     MOVEUSER            SET UP BUFFER
NOUPT    DS    0H
         ST    R9,SAVER9A         SAVE R9
         DROP  R9                 DROP LVLDX BASE
         L     R9,PSCBADDR        LOAD PSCB ADDR
*        L     R9,CPPLPSCB        R9 -> TO FAKE PSCB
         USING PSCB,R9            SET PSCB BASE
         LA    R3,PSCBUSER         R3 -> TO PSCB USERID
         IC    R2,PSCBUSRL         R2 = LTH OF PSCBUSER
         DROP  R9                 DROP PSCB BASE
         L     R9,SAVER9A         RELOAD R9
         USING LVLDX,R9           SET LVLDX BASE
         SPACE 1
MOVEUSER DS    0H
         MVC   LVLBUF+2(7),0(R3)   MOVE HLI TO BUFFER
         TM    LVLFLG,X'C0'        ANY LEVEL PARM ?
         BZ    NOLEVEL             NO, USE TSOID
         LA    R4,LVLBUF+2         R4 -> TO TSOID
         LA    R4,0(R2,R4)         R4 -> END OF TSOID
         MVI   0(R4),C'.'          ADD . TO END OF TSOID
         LA    R4,1(0,R4)          R4 -> TO NEXT AVAILABLE BYTE
         LA    R2,1(0,R2)          R2 = LTH OF TSOID.
         STH   R2,LVLBUF           SAVE TSOID. LTH
         B     MOVELVL             ADD REST OF NAME
         DROP  R9                 DROP R9 BASE
         SPACE 2
NOLEVEL  DS    0H
         STH   R2,LVLBUF           SAVE TSOID LTH
VOLDSNMX TM       UNTFLG,B'10000000'
         BZ       NOUNIT
         MVC       TUPAR3(5),=CL5'     '
         LH       R2,UNTLTH
         STH      R2,TULNG3           PUT UNIT LTH IN SVC99 BLK
         SH       R2,=H'1'
          L       R3,UNTPTR
          LA      R4,TUPAR3
          EX      R2,XMOVE
NOUNIT   DS     0H
         CH        R8,=H'1'              ARE THERE ANY ALLOC DSNS?
         BNE       NOTSUPV               NO
         SPACE 1
SUPVDSRT LH        R2,SVDLTH             R2 = LTH OF ALLOC DSN
         L         R3,SVDPTR             R3 -> TO ALLOC DSN
         LA     R4,DDSNAM                R4 -> TO WHERE DSN GOES
         ST     R4,TCAMDSN               PUT A(DSN) IN TCAM LIST
         SH        R2,=H'1'
         EX        R2,XMOVE
         AH        R2,=H'1'
         STH       R2,DDSNAML
         B      LOCVOL                   GO DO LOCATE
         SPACE 1
NOTSUPV  DS        0H
         TM        SW1,X'01'       WANT ALL VOLS?
         BO        NEXTVOL         YES, GET NEXT VOL
         TM        VOLFLG,B'10000000'
         BZ        VOLTABLX
         L         R3,VOLPTR
         CLC   0(6,R3),=C'ALLVOL'  WANT ALL VOLS ?
         BE    GETVOLS             YES, GET FIRST VOL
         MVC   TUPAR1(6),0(R3)    SAVE VOLSER SER FOR LATER         RH
         TM    SW1,X'01'           WANT ALL VOLS?
         BO    NEXTVOL             YES, GET NEXT VOL
         CLC   =C'MIGRAT',TUPAR1  ONLY WANT MIGRATED DATASETS?      RH
         BNE   FINDUCB            NO, GO FIND UCB FOR SPECIFIED VOL RH
         MVI   MIGRAT1+1,X'F0'    YES, CHANGE NOP TO BRANCH
         MVI   MIGRAT2+1,X'F0'    YES, CHANGE NOP TO BRANCH
         MVI   MIGRAT3+1,X'F0'    YES, CHANGE NOP TO BRANCH
         MVI   MIGRAT4+1,X'F0'    YES, CHANGE NOP TO BRANCH
         B     VOLTABLX           YES, DON'T LOOK FOR UCB           RH
         SPACE 1                                                    RH
MOVEVOLS DS    0H
         MVC   TUPAR1(6),0(R3)    MOVE VOLSER TO S99 BLOCK
         MVI   FAILSW+1,X'32'     CHANGE DAIRFAIL TO SAY SVC 99     RH
*
*              SVC 99 AND DAIRFAIL DON'T LIKE A 4 DIGIT UNIT
*              NAME SO USE UNIT(SYSDA)
*
*              JAN 1999...AH, BUT  IT WILL IF IT IS PRECEDED BY /   RH
*              ..EG../190A.....
*
         TM    UNTFLG,B'10000000' DID USER SPECIFY UNIT()?          RH
         BO    DAIRLINK           YES, DON'T CHANGE IT              RH
*        CLI   TUPAR3,C' '        IS UNIT NAME BLANK?               RH
*        BNE   DAIRLINK           NO, THEY USED UNIT() PARM
*
*              CONVERT UCB ADDRESS FOR UNIT NAME
*
         MVI   TUPAR3,C'/'        SAY WE ARE USING A 4-DIGIT UCB    RH
         MVI   TULNG3+1,X'05'     MAKE SURE LTH IS 5                RH
         UNPK  TUPAR3+1(5),4(3,R1)  UNPACK 4 DIGIT UNIT ADDRESS
         MVI   TUPAR3+5,X'EF'     TRANSLATES TO BLANK
         TR    TUPAR3+1(5),TRTAB-239 TRANSLATE TO DISPLAY
*
*        UNPK  TUPAR3(5),4(3,R1)  UNPACK 4 DIGIT UNIT ADDRESS
*        MVI   TUPAR3+4,X'EF'     TRANSLATES TO BLANK
*        TR    TUPAR3(5),TRTAB-239 TRANSLATE TO DISPLAY
* OLD    MVC   TUPAR3(3),13(R1)   MOVE UNIT NAME TO S99 BLOCK       RH
         B         DAIRLINK
         SPACE 1                                                    RH
GETVOLS  DS    0H
         OI    SW1,X'01'           TURN ON ALL VOLS SWITCH
         SPACE 1                                                    RH
FINDUCB  DS    0H                                                   RH
         NI    SW2,255-SW204      TURN VOL FOUND SWITCH OFF         RH
         STM   R2,R6,VOLSAVE       SAVES REGS
         XC    WORKAREA,WORKAREA  CLEAR UCBSCAN WORKAREA
         SPACE 1                                                    RH
NEXTVOL  DS    0H
         SPACE 1                                                    RH
NEXTUCB  DS    0H
         UCBSCAN COPY,WORKAREA=WORKAREA,UCBAREA=UCBAREA,               +
               DYNAMIC=YES,DEVCLASS=DASD,VOLSER=TUPAR1,                +
               RANGE=ALL,CMXTAREA=CMXTAREA,DCEAREA=DCEAREA,            +
               DCELEN=DCELEN
         LTR   R15,R15            HAS A UCB BEEN RETURNED?
         BNZ   NOMORE             NO, AT END OF DEVICE CLASS AND
*                                 NO MATCH FOUND.
         LA    R3,UCBAREA         R3 -> TO UCB THAT THE SCAN
*                                 SERVICE RETURNED.
         TM    3(R3),X'80'           ONLINE?
         BZ    NEXTUCB
         TM    6(R3),X'40'        IS DEVICE READY ?
         BO    NEXTUCB            NO, DON'T USE IT THEN
         TM    35(R3),X'80'       IS IT MOUNTED ?
         BO    NEXTUCB            NO, ASSUME IT IS OFFLINE
         CLI   28(R3),X'00'       IS THERE A VOL SER?
         BE    NEXTUCB            NO, DON'T USE IT THEN
         SPACE 1
         TM    SW1,X'01'          DOING ALLVOL ?                    RH
         BO    DOALLVOL           YES                               RH
         CLC   28(6,R3),TUPAR1    IS THIS OUR VOL ?                 RH
         BNE   NEXTUCB            NO, GET NEXT UCB                  RH
         B     UCBFOUND           YES, ON WE GO                     RH
         SPACE 1                                                    RH
DOALLVOL DS    0H
****** CHECK TO SEE IF THIS UCB HAS ALREADY BEEN PROCESSED.
         LA    R5,UCBTABLE  TABLE OF ALREADY-PROCESSED UCBS
         L     R6,NUMENTS   CURRENT NO. OF ACTIVE ENTRIES
UCBSRCH  CLM   R3,3,0(R5)   CURRENT UCB ADDR=ALREADY DONE UCB ADDR?
         BE    NEXTUCB      SKIP THIS ONE (ALREADY DONE)
         LA    R5,2(,R5)    NEXT ENTRY
         BCT   R6,UCBSRCH   REPEAT FOR CURRENT TABLE SIZE
         STCM  R3,3,0(R5)   FILL IN NEW ADDRESS IN TABLE
         L     R6,NUMENTS
         LA    R6,1(,R6)    ADD 1 NEW ADDR
         C     R6,UCBTABLN        IS UCB TABLE FULL ?               RH
         BNL   TABLFULL           YES, END OF DS                    RH
         ST    R6,NUMENTS
****** END OF TABLE LOOKUP.
         SPACE 1                                                    RH
UCBFOUND DS    0H
         OI    SW2,SW204          TURN ON VOL FOUND SWITCH          RH
         LR    R1,R3               R1 -> TO UCB DATA
         LM    R2,R6,VOLSAVE       RELOAD REGS
         LA    R3,28(0,R1)         R3 -> TO VOLSER
         SPACE 1
         B     MOVEVOLS            MOVE VOL TO WORK AREA
         SPACE 1
TABLFULL DS    0H                                                   RH
         L     R6,VOLSAVE+16      RELOAD R6                         RH
         NI    SW1,255-X'01'      MAKE SURE ALLVOLS SWITCH IS OFF   RH
         MVC   VOLNXT(4),=XL4'FF000000'  SAY END OF VOLS            RH
         PUTIT 'UCB TABLE FULL. CALL SYSTEMS SUPPORT' TELL HIM      RH
         SPACE 1
NOMORE   DS    0H
         NI    SW1,X'FF'-X'01'     TURN OFF LOOP SWITCH
         TM    SW2,SW204          WAS VOLUME FOUND ?
         BO    RETURN             YES, END OF DSPACE
         B     VOLERR             NO, SAY ERROR
         SPACE 2
VOLTABLX DS     0H
         LH     R2,LVLBUF                R2 = LTH OF DSN
         LA     R3,LVLBUF+2              R3 -> TO DSN
         LA     R4,DDSNAM                R4 -> TO WHERE DSN GOES
         ST     R4,TCAMDSN               PUT A(DSN) IN TCAM LIST
         SH        R2,=H'1'
         EX        R2,XMOVE
         AH        R2,=H'1'
         STH       R2,DDSNAML
         MVC   SAVPART(46),LVLBUF  SAVE INPUT DSN IN CASE WE
*                                 HAVE A PARTIAL DSN
MIGRAT1  NOP   SCATDSN2           B IF ONLY WANT MIGRATED DSNS
*        L     R15,VOLPTR         R15 -> TO VOL TO SEARCH FOR
*        CLC   =C'MIGRAT',0(R15)  ONLY WANT MIGRATED DATASETS?      RH
*        BE    SCATDSN2           YES, DON'T DO LOCATE              RH
         SPACE 1
LOCVOL   DS     0H
*        B     SCATDSN2           ALWAYS LET SUPER LOCATE TRY IT
*                                 THIS ALSO PRINTS THE HEADING      RH
*                                 ON MULTI TAPE FILES!!             RH
*
*              WE DON'T NEED HEADING INFO ON A TAPE DATASET,
*              SO DO LOCATE WITH  NO HEADING....
*
         LOCATE TCAML                    GO FIND VOL SER
         LTR    R15,R15                  WAS IT FOUND ?
         BNZ   SCATDSN2           NO, LET SUPER LOCATE TRY IT
         SPACE 1
**  ENTRY HERE FOR DSNAME OR HLI SPECIFIED TO ORIG LOCATE
SCATDSN  DS    0H                                               MVS
         CLC   DSNAME(8),=C'CATALOG.' ICF CATALOG POINTER?       XA RH
         BE    SCATDSN2               YES, USE SUPERLOCATE       XA RH
         CLC   DSNAME(8),=C'SYSCTLG.'   CVOL POINTER?           MVS
         BNE   SCATDSN0                 -NO, GOT DSNAME         MVS
         SPACE 1
**  ENTRY HERE FOR PARTIAL INDEX SPECIFIED TO ORIG LOCATE
SCATDSN2 DS    0H                                               MVS
         MVC   DSNAME,SAVPART+2   RESTORE DSNAME
         MVC   SUPERLVL(45),SAVPART+1  SET UP NAME FOR SUPER LOCATE
         SR    R1,R1              CLEAR R1
         IC    R1,SUPERLVL        R1 = LTH OF DSN
*
*              SEE IF THERE IS A  PERIOD IN DSN ALREADY
*
         LA    R15,SUPERLVL+1     R15 -> TO DSNAME
         SPACE 1
SCATDSN3 DS    0H                                               MVS
         CLI   0(R15),C'.'        FIND A PERIOD?
         BE    SLOC               YES, LEAVE LTH ALONE
         LA    R15,1(0,R15)       R15 -> TO NEXT DSN CHAR
         BCT   R1,SCATDSN3        CHECK FOR PERIOD
         SPACE 1
SCATDSN4 DS    0H                 NO PERIOD FOUND               MVS
         IC    R1,SUPERLVL        R1 = LTH OF DSN
         LA    R15,1(0,R1)        R15 = LTH OF DSN + .
         STC   R15,SUPERLVL       SAVE NEW LTH
         LA    R15,SUPERLVL+1     R15 -> TO DSN
         LA    R15,0(R1,R15)      R15 -> TO END OF DSN
         MVI   0(R15),C'.'        PUT . AT END OF DSN
         SPACE 1
SLOC     DS    0H
         LOCATE SUPERLOC          GO GET ALL ENTRIES
         LTR   R15,R15            WAS SUPER LOCATE OKAY ?
         BZ    SHOWCAT            YES, GO PROCESS DSNS
         CH    R15,=H'40'         RC = 40 ?
         BE    GET#MORE           YES, IT'S OKAY TOO
         CH    R15,=H'44'         RC = 44 ?
         BNE   ERROR10            NO, SAY NOT CATALOGUED
*
*              LOAD THE CURRENT & REQUIRED WORKAREA SIZE
*
GET#MORE L     R1,WORKADDR
         LH    R0,0(,R1)
         SR    R2,R2              CLEAR R2
         ICM   R2,3,2(R1)         GET REQUIRED WORKAREA LTH
         CH    R0,H265            IS THIS THE 1ST TIME THRU?
         BNE   NOTFIRST           NO, GO FREE AND GET
*
*              CHECK SIZE OF NEW WORKAREA
*
         C     R2,=F'65524'       IS NEW SIZE = X'FFF4'?
         BL    GETNEXT            NO, GO GET A LARGER WORKAREA
         LH    R2,=H'32767'       YES, R2 = MAX HALFWORD SIZE
         B     GETNEXT            GO GET MAX SIZE
         SPACE 1
NOTFIRST DS    0H
*
*              CHECK SIZE OF NEW WORKAREA
*
         C     R2,=F'65524'       IS NEW SIZE = X'FFF4'?
*        BE    SHOWCAT            YES, TOO MANY ENTRIES IN CAT,
         BE    TOOBIG             YES, TOO MANY ENTRIES IN CAT,
*                                 PROCESS WHAT WE CAN
*
*              FREEMAIN THE CURRENT WORKAREA
*
*       FREEMAIN R,                                                    X
               A=(1),                                                  X
               LV=(0)
         SPACE 1
GETNEXT  DS    0H
*
*              GETMAIN AN EXPANDED WORKAREA
*
        GETMAIN R,                                                     X
               LV=(2)
         LTR   R15,R15            DID WE GET IT?
         BNZ   NOROOM             NO, SAY NO ROOM
*
*              INITIALIZE THE WORKAREA ADDRESS & HEADER
*
         SLL   R2,16
         ST    R2,0(,R1)
         ST    R1,WORKADDR
*
         MVI   SUPERLOC+3,X'00'   TURN ALL RESERVED BITS OFF        RH
         XC    CTGFDBK,CTGFDBK    CLEAR FEEDBACK AREA               RH
*
*              GO ISSUE SUPERLOCATE AGAIN
*
         B     SLOC
         SPACE 2                                                MVS
NOROOM   DS    0H                                               MVS
         PUTIT 'CAN''T GET SUPERLOCATE WORKAREA. REGION SIZE TOO SMALL'+
               ,RET=YES
         B     LOCVOL2            EXIT
         SPACE 2                                                MVS
TOOBIG   DS    0H                                               MVS
         CALL  TSOPUT,(TOOBIG1),VL  PRINT 1ST PART OF MSG
         CALL  TSOPUT,(TOOBIG2),VL  PRINT 2ND PART OF MSG
*        PUTIT BIGMSG1,BIGLTH1      PRINT 1ST PART OF MSG
*        PUTIT BIGMSG2,BIGLTH2      PRINT 2ND PART OF MSG
         B     SHOWCAT            PROCESS WHAT WE HAVE
*
*        NOTE  ... THE FOLLOWING PARMS ARE SET UP IN PL1 FORMAT
*                  FOR TSOPUT.
*
         DS    0H
TOOBIG1  DC    A(BIG1MSG)
BIG1MSG  DC    AL2(BIGLTH1)
BIGMSG1  DC    C' TOO MANY ENTRIES TO LIST. QUALIFY SEARCH WITH'
         DC    C' ANOTHER LEVEL.'
BIGLTH1  EQU   *-BIGMSG1
         DS    0H
TOOBIG2  DC    A(BIG2MSG)
BIG2MSG  DC    AL2(BIGLTH2)
BIGMSG2  DC    C'0WILL PROCESS WHAT IS AVAILABLE.'
BIGLTH2  EQU   *-BIGMSG2
*        PUTIT 'TOO MANY ENTRIES TO LIST. QUALIFY SEARCH WITH ANOTHER L+
               EVEL'
*        PUTIT 'WILL PROCESS WHAT IS AVAILABLE.'
*        B     ANYMORE            SEE IF ANY MORE VOLS
         SPACE 2                                                MVS
SCATDSN0 DS    0H                                               MVS
         CLC   DSNAME,LVLBUF+2    DID LOCATE CHANGE DSNAME?
         BE    LOCVOL2            NO, EXIT
         MVC   LVLBUF+2(44),DSNAME YES, PUT IT IN LVLBUF
         LA    R2,DSNAME+43       R2 -> TO END OF DSNAME
         LA    R1,DSNAME          R1 -> TO DSNAME
         SPACE 1
CHKDSN   DS    0H
         CLI   0(R2),C' '         END OF DSNAME?
         BNE   ENDDSN             YES
         BCT   R2,CHKDSN          NO, R2 -> AT NEXT DSN CHAR TO CHK
         SPACE 1
ENDDSN   DS    0H
         SR    R2,R1              R2 = NEW HEX LTH OF DSNAME
         LA    R2,1(0,R2)         R2 = DECIMAL LTH OF DSNAME
         STH   R2,LVLBUF          SAVE IT
         B     LOCVOL2             EXIT
         SPACE 2
*
***  ROUTINE TO PROCESS SUPER LOCATE WORK AREA
*
SHOWCAT  DS    0H
         OI    SW2,X'80'          TURN INDEX SWITCH ON
         OI    SWITCHWD,HLILIST   TURN HLI SWITCH ON
         L     R1,PPLANS          R1 -> TO PARSE AREA
         USING IKJPARMD,R1
         LA    R1,ACCUMKWD        R1 -> TO TOTAL KEYWORD
         DROP  R1
         USING TOTDX,R1           SET BASE
         TM    TOTTYPE+1,TOTON    TOTAL KEYWORD SUPPLIED ?
         BO    TOTALSET           IT'S THERE, USE IT
         DROP  R1
         OI    SWITCHWD,PERCENTS+TOTALIT ELSE, SAY TOTAL(YES)
TOTALSET DS    0H                                               MVS
         OI    SWITCHWD,HEADING   SAY PRINT HEADING ONLY
         LA    R1,PARML           R1 -> TO PLI PARMS
         L     R15,=V(PLICALLA)   R15 -> TO PLI PGM
         BALR  R14,R15            GO FOR IT
         NI    SWITCHWD,255-HEADING  TURN PRINT HEADING ONLY OFF
         OI    SWITCHWD,MULTIVOL  SAY DOING MULTI VOLUMES
*
         L     R2,WORKADDR        R2 -> TO SUPER WORK AREA
         SR    R0,R0              R0 = 0                            RH
         SR    R1,R1              R1 = 0                            RH
         ICM   R1,3,0(R2)         R1 = LTH OF WORKAREA
         ICM   R0,3,2(R2)         R0 = LTH OF WORKAREA USED
         CR    R0,R1              IS USED < THAN SIZE?
         BL    R0OKAY             YES
         LR    R0,R1              NO, PROCESS MAX SIZE
         SPACE 1
R0OKAY   DS    0H
         LA    R14,4(0,R2)        R14 -> TO 1ST DSN
*        CLI   0(R14),C'X'        IS IT THE HLI POINTER
*        BNE   SCATGO             NO, SO MUST BE A DSN
*        LA    R14,45(0,R14)      YES, R14 -> TO NEXT DSN
         SPACE 1
SCATGO   DS    0H
         LA    R14,1(0,R14)       R14 -> PAST ID
         ST    R14,TCAMDSN        SAVE ADDR OF FIRST DSN
         MVC   LVLBUF+2(44),0(R14) PUT DSN INTO PLI WORK AREA
         LA    R15,44             ALWAYS USE LTH OF
         STH   R15,LVLBUF         44 FOR HLI SEARCH
         LA    R15,0(0,R2)        R15 -> TO SUPER WORK AREA
         AR    R15,R0             R15 -> TO END OF DSNS
         ST    R15,LASTDSN        SAVE ADDR OF LAST DSN
         SPACE 1
SCATGO2  DS    0H
         BCTR  R14,0              R14 -> TO DSN TYPE
         CLI   0(R14),C'A'        IS THIS A NONVSAM DATASET?
         BE    SCATGO3            YES
MIGRAT4  NOP   ANYMORE            B IF ONLY WANT MIGRATED DSNS
         CLI   0(R14),C'B'        IS THIS A GDG BASE NAME?
         BE    GDGBASE            YES
         SPACE 1
SCATGO3  DS    0H
         LOCATE TCAML             FIND IT
         LTR   R0,R15              LOCATE OK?
         BNZ   ERROR9              BR IF NOT
         B     LOCVOL2             NOW GO AHEAD
         SPACE 1
NEXTDSNA DS    0H
         L     R14,TCAMDSN        R14 -> TO DSN WE JUST DID
         LA    R14,45(0,R14)      R14 -> TO NEXT DSN
         C     R14,LASTDSN        HAVE WE DONE LAST DSN ?
         BH    DONE               YES, END OF SEARCH, PRINT TOTALS
         ST    R14,TCAMDSN        PUT IT IN LOCATE LIST
         MVC   LVLBUF+2(44),0(R14) PUT DSN INTO PLI WORK AREA
         B     SCATGO2            GO GET IT
         SPACE  1
*              ALL LOCATES EVENTUALLY GET HERE....
         SPACE  1
LOCVOL2  DS     0H
*******************************************************************
*
*              CHECK HOW MANY VOLUMES ARE IN THE LOCATE WORK AREA.
*              IF THERE ARE 20, CALL IDCAMS TO MAKE SURE
*              THAT ALL VOLUMES ARE IN THE LIST, TO A MAX OF 50,
*              AS LOCATE RETURNS A MAX OF 20....
*
*******************************************************************
         SPACE 1
         LH    R15,TWORK          R15 = NBR VOLSERS
         CH    R15,=H'20'         AT LEAST 20?
         BL    LOCVOL4            NO
*        CH    R15,=H'6'          MORE THAN 6?
*        BNH   LOCVOL4            NO
*
         LA    R1,TCAML           R1 -> TO CAMLST
         PERFORM CALLIDC          GO GET VOLSERS USING IDCAMS
         LTR   R15,R15            DID WE GET IT?
         BZ    LOCVOL3            YES
*        BNZ   GETSIZE2           NO, TOO BAD
         LH    R15,TWORK          R15 = NBR VOLSERS
         CVD   R15,DWORD2         CONVERT TO DECIMAL
         UNPK  DWORD2(5),DWORD2+5(3) CONVERT TO DISPLAY
         MVZ   DWORD2+4(1),DWORD2 FIX SIGN BITS
         MVC   IDCVOLM(3),DWORD2+2 PUT TOT IN MSG
         MVI   TWORK,X'00'        DROP MAX VOLS
         MVC   MSG(IDCMSGL),IDCMSG  MOVE MSG TO PRINT
         B     PRINTMS1           PRINT IT, THEN GOTO ANYMORE
*        LA    R14,ANYMORE        GO HERE AFTER PRINTING
*        B     PRINTMSG           PRINT IT
*
LOCVOL3  DS     0H
         LH    R15,TWORK          R15 = NBR VOLSERS
         CH    R15,=H'50'         MORE THAN 50?
         BNH   LOCVOL4            NO
         SRL   R15,8              R15 = TOT VOLSERS
         CVD   R15,DWORD2         CONVERT TO DECIMAL
         UNPK  DWORD2(5),DWORD2+5(3) CONVERT TO DISPLAY
         MVZ   DWORD2+4(1),DWORD2 FIX SIGN BITS
         MVC   MAXVOL(3),DWORD2+2 PUT TOT IN MSG
         MVI   TWORK,X'00'        DROP MAX VOLS
         MVC   MSG(MAXMSGL),MAXMSG  MOVE MSG TO PRINT
         B     PRINTMS1           PRINT IT, THEN GOTO ANYMORE
*        LA    R14,ANYMORE        GO HERE AFTER PRINTING
*        B     PRINTMSG           PRINT IT
*
LOCVOL4  NOP   LOCVOL5            ONLY DO THIS ONCE
         MVI   LOCVOL4+1,X'F0'    CHANGE NOP TO B
         TM    TWORK+4,X'80'      IS DSN ON A TAPE ?
         BZ    LOCVOL5            NO
         CH    R15,=H'1'          MORE THAN 1?
         BNH   LOCVOL5            NO
*
         LA    R1,0               SET VOLCNT2 TO 0 SO THAT WE WILL
         STH   R1,VOLCNT2         REPROCESS THE 1ST TAPE VOLSER..
         CVD   R15,DWORD2         CONVERT TO DECIMAL
         UNPK  DWORD2(5),DWORD2+5(3) CONVERT TO DISPLAY
         MVZ   DWORD2+4(1),DWORD2 FIX SIGN BITS
         MVC   MAXVOL(3),DWORD2+2 PUT TOT IN MSG
         MVI   TWORK,X'00'        DROP MAX VOLS
         MVC   MSG(VOLMSGL),MAXMSG  MOVE MSG TO PRINT
         B     PRINTMS1           PRINT IT, THEN GOTO ANYMORE
*        LA    R14,ANYMORE        GO HERE AFTER PRINTING
*        B     PRINTMSG           PRINT IT
*
LOCVOL5  DS     0H
         MVC   TUPAR1(6),TWORK+6        MOVE VOLSER TO DAIR BLOCK
         L     R14,TCAMDSN        R14 -> TO DSN WE JUST DID
         BCTR  R14,0              R14 -> TO DSN TYPE
         CLI   0(R14),C'X'        IS THIS AN ALIAS NAME?
         BE    ALIASNAM           YES
         SPACE  1
OBTAIN1  DS     0H
         CLC   =C'MIGRAT',TUPAR1  HAS DATASET BEEN MIGRATED?        RH
         BE    MCDLBL0            YES, GO DO HSM STUFF              RH
MIGRAT2  NOP   ANYMORE            B IF ONLY WANT MIGRATED DSNS
         CLI   TWORK+4,X'20'      IS DSN ON A DISK VOLUME?
         BNE   NOTDISK            NO, GO SEE WHAT IT IS
         B     FINDUCB            YES, GO FIND UCB FOR THIS PACK    RH
         SPACE 1
******** ***** ****************** *********************************
*
*              DATASET HAS BEEN MIGRATED. GO TO HSM TO GET THE
*              INFO. ALLOCATE MCDS DATASET ONLY ONCE.
*
******** ***** ****************** *********************************
         SPACE 1
MCDLBL0  NOP   FINDUCB            B IF ANY MCDS ERRORS              RH
MCDLBL1  NOP   MCDLBL2            B AFTER 1ST PASS                  RH
         MVI   MCDLBL1+1,X'F0'    CHANGE NOP TO B                   RH
         NI    MCDSW,255-PRINTIT  TURN OFF MCD ALLOCATED SW         RH
*
*  MAKE SURE WE HAVE READ ACCESS TO MCDS
*
*              GET THE VOLUME THE  MCDS HLI IS ON
*
         L     R4,TCAMDSN         SAVE LAST LOCATE DSN POINTER      RH
         LA    R14,MCDHLI         R14 -> TO MCD DSN HLI             RH
         ST    R14,TCAMDSN        PUT A(HLI) IN TCAM LIST           RH
         LOCATE TCAML             GO FIND VOL SER                   RH
         ST    R4,TCAMDSN         RELOAD LAST LOCATE DSN POINTER    RH
         LTR    R15,R15           WAS IT FOUND ?                    RH
         BZ    HLIOK              YES                               RH
         MVI   MCDLBL0+1,X'F0'    CHANGE NOP TO B                   RH
         B      ERROR10           SAY NOT CATALOGUED                RH
         SPACE 1
HLIOK    DS    0H
         LA    R5,TWORK+6         R5 -> TO VOLSER
*                WHEN THIS RUNS AUTHORIZED, TURN OFF ERROR LOGGING
*                BY ADDING ,LOG=NONE AFTER CLASS=READ
         RACHECK ENTITY=(MCDDSN),VOLSER=(R5),                          +
               DSTYPE=V,          IT'S A VSAM FILE                     +
               CLASS='DATASET',ATTR=READ     LOG=NONE
         LTR   R15,R15            ARE WE OKAY?
         BZ    RACRET             YES
         MVI   MCDLBL0+1,X'F0'    NO, CHANGE NOP TO B               RH
         B     FINDUCB            GO TO REST OF CODE
         SPACE 1
RACRET   DS    0H
         L     R4,TCAMDSN         SAVE LAST LOCATE DSN POINTER      RH
         LA    R14,MCDDSN         R14 -> TO MCD DSN                 RH
         ST    R14,TCAMDSN        PUT A(DSN) IN TCAM LIST           RH
         LOCATE TCAML             GO FIND VOL SER                   RH
         ST    R4,TCAMDSN         RELOAD LAST LOCATE DSN POINTER    RH
         LTR    R15,R15           WAS IT FOUND ?                    RH
         BZ    MCDMOK             YES                               RH
         MVI   MCDLBL0+1,X'F0'    CHANGE NOP TO B                   RH
*        B      ERROR10           SAY NOT CATALOGUED                RH
         PUTIT MCDDSN,RET=YES     PRINT DEFAULT MCDS NAME
         PUTIT 'MCDS DATA NOT FOUND. USE MCDS(''...'') KEYWORD.'
         B     FINDUCB            GO TO REST OF CODE
         SPACE 1
MCDSW    DC    X'00'              MCD SWITCH                        RH
         SPACE 2
MCDDRBLK DS    0F
MCDDCD   DC    X'0008'
MCDDFLG  DC    H'0'
MCDDDARC DC    H'0'
MCDDCTRC DC    H'0'
MCDDDSN  DC    A(MCDDSNL)
MCDDDDNM DC    CL8'MCDS    '
MCDDUNIT DC    CL8'SYSALLDA'
MCDDVSER DC    CL8' '
MCDDBLK  DC    F'00'
MCDDPQTY DC    F'0'
MCDDSQTY DC    F'0'
MCDDDQTY DC    F'0'
MCDDMNAM DC    CL8' '
MCDDPSWD DC    CL8' '
MCDDDSP1 DC    X'08' SHR
MCDDDSP2 DC    X'08' KEEP
MCDDDSP3 DC    X'08' KEEP
MCDDCTL  DC    X'00'
MCDDUID  EQU   X'20'  OR IN TO CONCAT USERID
         DC    3X'00'
MCDDFLG2 DC    XL1'00'
MCDDALN  DC    CL8' '
         SPACE 1
MCDDSNL  DC    AL2(14)            LTH OF MCDS DSN                   RH
MCDDSN   DC    CL44'SMS.DFHSM.MCDS'  MCDS DATASET NAME              RH
MCDDSNL2 DC    AL2(21)            LTH OF MCDS DSN                   RH
MCDDSN2  DC    CL44'SMS.Y2K.DFSMSHSM.MCDS'  MCDS DATASET NAME       RH
MCDHLI   DC    CL44'SMS'          MCDS DSN HLI                      RH
         SPACE 1
MCDMOK   DS    0H
*        MVC   PRTDSNL(46),MCDDSNL SET UP MCDS DSNAME AND LTH       RH
*        MVC   PRTDDDNM(8),=CL8'MCDS' DDNAME = MCDS                 RH
         MVC   MCDDVSER(6),TWORK+6 MOVE VOLSER TO DAIR BLOCK        RH
*        MVI   PRTDDSP1,X'08'     DISP=SHR                          RH
         LA    R14,MCDDRBLK       PUT A(MCDS DAIR BLOCK)            RH
         ST    R14,DAPLDAPB       IN DAIR PARM LIST                 RH
         LA    R1,DAPLUPT         R1 -> TO DAIR LIST                RH
         LINK  EP=IKJDAIR         CALL DAIR                         RH
         LTR   R15,R15            DAIR OKAY?
         BZ    MCDMOK2            YES
         MVI   MCDLBL0+1,X'F0'    CHANGE NOP TO B                   RH
         SPACE 1
MCDMOK2  DS    0H
         B     *+4(R15)           BRANCH ON RETURNED CODE           RH
         B     MCDSOK1            DAIR OK, CONTINUE                 RH
         B     ABEND1  INVALID PARM LIST                            RH
         B     ERROR10  DATA SET NOT IN CATALOG                     RH
         B     DAIRERR  DAIR ERROR                                  RH
         B     ERROR5  NO TIOT ENTRIES AVAILABLE                    RH
         B     ERROR6 DDNAME NOT AVAILABLE                          RH
         B     ERROR7 DSNAME IS MEMBER OF CONCAT GRP                RH
         B     ABEND1 DDNAME OR DSNAME NOT ALLOC                    RH
         B     ERROR8  OLD DATA SET                                 RH
         B     ABEND1  ERROR IN CATALOG ROUTINE                     RH
         B     ABEND1  OUT OF QUALIFIER ROOM                        RH
         B     ERROR11  DELETED DATA SET                            RH
         SPACE  1
MCDSOK1  DS    0H                                                   RH
         OI    MCDSW,PRINTIT      TURN ON  MCD ALLOCATED SW         RH
         SPACE 1                                                    RH
***********************************************************************
*                                                                     *
*    OPEN THE MCDS FILE.                                              *
*                                                                     *
***********************************************************************
         SPACE 3
*
*    BUILD THE ACB.
*
OPNVSAM  DS    0H
*        TM    FLAG,FLAGEXP       SHOULD WE OPEN MCDS FILE ?        RH
*        BO    ACBOPEN            NO, IT'S ALREADY OPEN             RH
         L     R15,=V(MCDS)        GET ADDRESS OF ACB
*        LA    R15,MCDS            GET ADDRESS OF ACB
         OPEN  ((R15),(INPUT))
         LTR   R15,R15             ERROR OPENING ACB ???
         BZ    CKOPENS             NO, SO SEE IF ERROR WERE FOUND
*
*    'MCDS' ACB DID NOT OPEN.
*
         MVI   MCDLBL0+1,X'F0'    CHANGE NOP TO B                   RH
         WTO   '**ERROR** MCDS ACB FAILED TO OPEN.',                   *
               ROUTCDE=(11)
         B     FINDUCB            BYPASS HSM FOR NOW                RH
         SPACE 1                                                    RH
CKOPENS  DS    0H
         L     R1,=V(FLAG)        R1 -> TO ACB OPEN FLAG
         OI    0(R1),FLAGEXP      SAY WE OPENED MCDS FILE           RH
         SPACE 1                                                    RH
ACBOPEN  DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
*    GETMAIN AN AREA LARGE ENOUGH TO HOLD A DSCB                      *
*                                                                     *
***********************************************************************
         SPACE 3
         L     R2,DSCB#LEN         LENGTH FOR EACH DSCB
         AGO   .NOLEN
*
*    CALCULATE THE AMOUNT OF STORAGE REQUIRED
*
         LA    R2,4095(,R3)        ALIGN SIZE TO 4K BOUNDARY
         N     R2,=X'FFFFF000'
*        C     R2,GETMLEN          DO WE HAVE ALREADY HAVE AN AREA ???
*        BNH   READVTOC            YES, SO USE IT
*
*    FREEMAIN ANY PREVIOUSLY OBTAINED AREA.
*
*        L     R0,GETMLEN          LOAD CURRENT LENGTH
*        L     R1,GETMADDR         LOAD CURRENT ADDRESS
*        LTR   R0,R0               SIZE > 0 ???
*        BZ    GETDSCB             NO
*        FREEMAIN RU,                                                  *
               A=(R1),                                                 *
               LV=(R0)
*
*    GETMAIN A DYNAMIC WORKAREA
*
GETDSCB  EQU   *
.NOLEN   ANOP
         ST    R2,GETMLEN          STORE THE GETMAIN SIZE
         LR    R0,R2              R0 = LTH TO GET
         GETMAIN RU,                                                   *
               LV=(R0)
         ST    R1,GETMADDR         STORE THE GETMAIN ADDRESS
         EJECT
         SPACE 1                                                    RH
MCDLBL2  DS    0H                                                   RH
         SPACE 1
***********************************************************************
*                                                                     *
*    GO TO HSM TO GET A 'DSCB'                                        *
*                                                                     *
***********************************************************************
         SPACE 3
         L     R15,=V($CHGMCDS)   R15 -> TO HSM CODE                RH
         BALR  R14,R15            GO TO IT                          RH
         LTR   R15,R15            DID WE GET OUR INFO?              RH
         BZ    MCDLBL3            YES, GO ON                        RH
         CH    R15,=H'16'         DID WE GET A VSAM DATA ALIAS?
         BE    SAYDATA            YES
         CH    R15,=H'20'         DID WE GET A VSAM INDEX ALIAS?
         BE    SAYINDEX           YES
MIGRAT3  NOP   ANYMORE            B IF ONLY WANT MIGRATED DSNS
         B     HSMERR             NO, SAY HSM READ ERROR            RH
         SPACE 1                                                    RH
MCDLBL3  DS    0H                                                   RH
*        L     R15,=V(MCDBUFF)    R15 -> TO A(HSM DATA BUFFER)      RH
*        L     R15,0(0,R15)       R15 -> TO HSM DATA BUFFER         RH
         L     R15,GETMADDR       R15 -> TO FORMATTED HSM DSCB      RH
         ST    R15,PARMLMCD       PASS IT TO PLI PGM                RH
         B     PLILINK            GO TO PLI CODE                    RH
         SPACE  1
         ENTRY GETMADDR
GETMADDR DC    F'0'
GETMLEN  DC    F'0'
DSCB#LEN DC    A(148)
         SPACE  1
XMOVE    MVC   0(0,R4),0(R3)
         SPACE  1
DAIRLINK DS    0H
*                                                                   RH
*              SINCE WE NO LONGER  USE  OPER AS A MEANS             RH
*              OF DETERMINING WHICH  PACKS A USER CAN               RH
*              SEE, DROP THE VOLSER TESTS.                          RH
*                                                                   RH
*        TM    PSCBATR1,PSCBCTRL   CAN HE USE OPER ?
*        BO    NOCHEK              YES, LET HIM LOOK AT ANY PACK
*        CLI   TUPAR1,C'I'         IPO PACK?
*        BE    VOLERR              YES, HE CAN'T LOOK AT IT
*        CLI   TUPAR1,C'S'         OTHER SYSTEM PACKS? (SSG)
*        BE    VOLERR              YES, HE CAN'T SEE THEM EITHER
*        CLI   TUPAR1,C'P'         OTHER SYSTEM PACKS? (PAGE)
*        BE    VOLERR              YES, HE CAN'T SEE THEM EITHER
*        L     R15,UCBADDR        R15 -> TO UCB ENTRY               RH
*        SR    R1,R1              CLEAR R1                          RH
*        ICM   R1,3,0(R15)        R1 -> TO UCB                      RH
*        CLI   19(R1),X'0B'       IS IT A 3350 ?
*        BNE   VOLERR             NO, HE CAN'T SEE THEM EITHER
         SPACE 1
NOCHEK   DS    0H
DOSVC99  DS    0H
         MVI   S99VERB,X'01'      SAY WE WANT TO ALLOCATE BY DSNAME
*                                 BECAUSE FOR SOME STRANGE REASON
*                                 ALLOCATE BY DDNAME (06) DOES
*                                 NOT WANT TO WORK
         MVC   TUPAR2,TUPAR1      MOVE VOLSER TO TEXT UNIT 2
         LA    R1,S99RB           R1 -> TO SVC 99 RB FOR ALLOC
         ST    R1,FAILPARM        PUT SVC99 PARM LIST IN DAIRFAIL
         LA    R1,S99TUPL         R1 -> TO SVC 99 PARMS FOR ALLOC
         ST    R1,S99TXTPP        PUT IT IN SVC 99 RB
         LA    R1,S99RBPTR        R1 -> TO SVC 99 PARMS
         SVC   99
         LTR   R15,R15            WAS SVC99 OKAY?
         BZ    DAIROK             YES
         ST    R15,DAIR15         SAVE SVC 99 ERROR CODE
*        B     *+4(R15)  BRANCH ON RETURNED CODE
*        B     DAIROK
*        B     ERR04              DAIR ERROR
*        B     ERROR12            DENIED BY INSTALLATION EXIT
*        B     ABEND1  INVALID PARM LIST
ERR04    EQU   *
*
*              CONVERT REASON CODE TO DECIMAL
*
         UNPK  ERR04RC(5),S99ERROR(3) UNPACK 4 DIGIT REASON CODE
         MVI   ERR04RC+4,X'EF'    TRANSLATES TO BLANK
         TR    ERR04RC(5),TRTAB-239 TRANSLATE TO DISPLAY
         MVI   ERR04RC+4,C'-'     CHANGE BLANK TO DASH
*
*              CONVERT INFO CODE TO DECIMAL
*
         UNPK  ERR04IN(5),S99INFO(3) UNPACK 4 DIGIT INFO CODE
         MVI   ERR04IN+4,X'EF'    TRANSLATES TO BLANK
         TR    ERR04IN(5),TRTAB-239 TRANSLATE TO DISPLAY
*
*        LA    R1,X'218'          CHECK FOR 218 ERROR...
*        CH    R1,S99ERROR        WAS IT?
*        BNE   DAIRERR            NO, GO SET UP DAIR ERROR
         MVC   ERR04DSN,LVLBUF+2  PUT DSN IN MSG
         MVC   ERR04VOL,TUPAR1    PUT VOLSER IN MSG
         PUTIT ERR04MSG,ERR04LTH,RET=YES PRINT IT
*        B     DAIROK             ON WE GO...IF RET=YES...
         L     R15,DAIR15         LOAD SVC 99 ERROR CODE
         B     *+4(R15)           BRANCH ON RETURNED CODE
         B     DAIROK             IT WAS OKAY...
         B     DAIRERR            DAIR ERROR
         B     ERROR12            DENIED BY INSTALLATION EXIT
         B     ABEND1  INVALID PARM LIST
*
         SPACE 5
DAIROK   DS    0H
         SPACE 5
PLILINK  LA    R1,PARML
         L     R15,=V(PLICALLA)
         BALR  R14,R15
         CLC   =C'MIGRAT',TUPAR1  HAS DATASET BEEN MIGRATED?        RH
         BE    ANYMORE            YES, DON'T DO DEALLOCATE          RH
         SPACE 1
FREEUNIT DS    0H
         MVI   S99VERB,X'02'      CHANGE TO UNALLOCATE
         LA    R1,S99TUPL2        R1 -> TO SVC 99 PARMS FOR FREE
         ST    R1,S99TXTPP        PUT IT IN SVC 99 RB
         LA    R1,S99RBPTR        R1 -> TO SVC 99 PARMS
         SVC   99
         B     *+4(R15)  BRANCH ON RETURNED CODE
         B     ANYMORE            0, SEE IF ANY MORE PACKS TO TRY
         B     DAIRERR            4, DAIR ERROR
         B     ERROR12            8, DENIED BY INSTALLATION EXIT
         B     ABEND1             12,  INVALID PARM LIST
         SPACE 1
ANYMORE  DS    0H
         SPACE 1
NXTVOL   DS    0H
         CLC   VOLCNT,=H'0'       ANY VOLS TO PROCESS?
         BE    ENDVOLS2           NO
         SR    R15,R15            MAKE SURE R15 IS 0
         LH    R1,VOLCNT2         R1 = NBR VOLS PROCESSED
         CH    R1,VOLCNT          HAVE WE DONE THEM ALL?
         BE    ENDVOLS            YES
         MH    R1,=H'12'          R1 = OFFSET TO NEXT VOL
         LA    R15,TVOL           R15 -> 1ST VOLSER
         AR    R15,R1             R15 -> TO NEXT VOLSER
         MVC   TUPAR1(6),0(R15)   PUT NEXT VOLSER IN OBTAIN AREA
         LH    R1,VOLCNT2         R1 = NBR VOLS PROCESSED
         LA    R1,1(0,R1)         ADD 1
         STH   R1,VOLCNT2         SAVE IT
         B     OBTAIN1            GO PROCESS IT
         SPACE 1
ENDVOLS  DS    0H
         LA    R1,0               R1 = 0
         STH   R1,VOLCNT          CLEAR VOLCNT FROM LOCATE
         LA    R1,1               R1 = 1
         STH   R1,VOLCNT2         R1 = NBR VOLS PROCESSED
         SPACE 1
ENDVOLS2 DS    0H
         CLC       VOLNXT(4),=XL4'FF000000'  ANY MORE VOLS ?
         BE        RETURN         NO
         OI        SWITCHWD,MULTIVOL  INSERT FOR CUMMULATIVE TOTALING
         L     R6,VOLNXT
         CH    R8,=H'1'                  ALLOC DSN SUPPLIED?
         BNE   NOTSUPV                   NO
         CLC   SVDNXT,=XL4'FF000000'     ANY MORE ALLOC DSNS?
         BE    RETURN                    NO, END OF DSPACE
         L     R5,SVDNXT                 YES, R5 -> TO NEXT ALLOC  DSN
         B     SUPVDSRT                  GO GET IT
SW1RTN   DS    0H
         OI    SWITCHWD,MULTIVOL      INSERT FOR CUMMULATIVE TOTALING
         B     NOTSUPV
         SPACE 1
SAYDATA  DS    0H
         MVI   ABENDFLG,X'00'     SET ABEND FLAG TO CONTINUE
         MVC   ERRMSG,DATAMSG     MSG = VSAM DATA OBJECT NAME
         B     VOLERR2            SET UP REST OF MSG
         SPACE 1
SAYINDEX DS    0H
         MVI   ABENDFLG,X'00'     SET ABEND FLAG TO CONTINUE
         MVC   ERRMSG,INDEXMSG    MSG = VSAM INDEX OBJECT NAME
         B     VOLERR2            SET UP REST OF MSG
         SPACE 1
HSMERR   DS    0H
         MVI   ABENDFLG,X'00'     SET ABEND FLAG TO CONTINUE
         MVC   ERRMSG,HSMMSG      MSG = ERROR READING HSM
         B     VOLERR2            SET UP REST OF MSG
         SPACE 1
GDGBASE  DS    0H
         MVI   ABENDFLG,X'00'     SET ABEND FLAG TO CONTINUE
         MVC   ERRMSG,BASEMSG     MSG = GDG BASE
         MVC   TUPAR1,=CL6' '     BLANK OUT VOLSER FIELD
         B     VOLERR2            SET UP REST OF MSG
         SPACE 1
ALIASNAM DS    0H
         MVI   ABENDFLG,X'00'     SET ABEND FLAG TO CONTINUE
         MVC   ERRMSG,ALIASMSG    MSG = ALIAS NAME
*        MVC   TUPAR1,=CL6' '     BLANK OUT VOLSER FIELD
         B     VOLERR2            SET UP REST OF MSG
         SPACE 1
NOTDISK  DS    0H
         MVI   ABENDFLG,X'00'     SET ABEND FLAG TO CONTINUE
         TM    TWORK+4,X'80'      IS DSN ON A TAPE ?
         BZ    NOTTAPE            NO
*        BNE   NOTTAPE            NO
         TM    TWORK+5,X'80'      IS DSN ON A TAPE CARTRIDGE?
         BZ    NOTCART            NO
*        BNE   NOTCART            NO
         MVC   ERRMSG,CARTMSG     MSG = CARTRIDGE TAPE DATASET
         B     VOLERR2            SET UP REST OF MSG
*
NOTCART  DS    0H
         MVC   ERRMSG,TAPEMSG     MSG = TAPE DATASET
         B     VOLERR2            SET UP REST OF MSG
*
NOTTAPE  DS    0H
         MVC   ERRMSG,UNKNMSG     MSG = UNKNOWN DEVICE TYPE
         B     VOLERR2            SET UP REST OF MSG
         SPACE 2
VOLERR   DS    0H
         MVC   ERRMSG,NTVALMSG    MSG = NOT VALID FOR YOUR USE
         CLC   =C'MIGRAT',TUPAR1  WANT MIGRATED DATASETS            RH
         BNE   VOLERR2            NO, SAY NOT VALID                 RH
         MVC   ERRMSG,MIGMSG      MSG = DATASET WAS MIGRATED BY HSM
         SPACE 1
VOLERR2  DS    0H
         MVC   ERRVOL,TUPAR1         MOVE BAD VOL TO MSG
         MVC   ERRDSN,LVLBUF+2       MOVE DSN TO ERR MSG
         MVC   MSG(L'VOLMSG),VOLMSG  MOVE BAD VOL MSG TO PRINT
         B     PRINTMS1           PRINT IT, THEN GOTO ANYMORE
*        LA    R14,ANYMORE        GO HERE NEXT...
*        B     PRINTNOP           ON WE GO                          RH
         SPACE 1
PRINTMSG DS    0H
         LTR   R14,R14            IS R14 SET?
         BP    PRINTMS2           YES
         SPACE 1
PRINTMS1 DS    0H
         LA    R14,ANYMORE        NO, GO HERE NEXT...
         SPACE 1
PRINTMS2 DS    0H
         ST    R14,RETADDR        SAVE RETURN ADDRESS
PRINTNOP B     PRINTPUT           NOP IF BATCH  FILE OPEN           RH
         PUT   REPORT,INFO1       OUTPUT THE MSG
         SPACE 1
CLEARMSG DS    0H
         MVI   MSG,C' '           CLEAR PRINT LINE
         MVC   MSG+1(131),MSG     *
         CLI   ABENDFLG,X'FF'     SHOULD WE END DS CMD ?
         BE    RETURN             YES
*        B     ANYMORE            NO, GO SEE IF ANY MORE PACKS
         L     R14,RETADDR        LOAD RETURN ADDRESS
         BR    R14                GO DO NEXT INST...
         SPACE 1
PRINTPUT DS    0H                                                   RH
         TM    SWITCHWD,PRINTIT   DOES HE WANT OUTPUT IN A FILE?
         BO    PRINTOUT           YES
         TM    SWITCHWD,OFFLIST   PRINT THE MSG?            JAN96   RH
         BO    CLEARMSG           NO                        JAN96   RH
*        TPUT  MSG,88   (WAS 44)  TPUT MSG RATHER THAN PUT          RH
*        LA    R1,88              LTH TO PRINT
         CALL  TSOPUT,(PUTMSG),VL  PRINT IT
         B     CLEARMSG           CLEAR OUT MSG AREA                RH
         SPACE 1
PRINTOUT DS    0H                                                   RH
         PUT   PRTDCB,INFO1       PUT MSG IN FILE                   RH
         B     CLEARMSG           CLEAR OUT MSG AREA                RH
         SPACE  1
DONE     DS     0H
         MVI   SW2,X'00'          TURN ALL SW2 OFF
         TM    SWITCHWD,TOTALIT   DOES HE WANT TOTALS ?
         BZ    RETURN             NO, END OF DS
         OI    SWITCHWD,TOTALS+PERCENTS SAY PRINT TOTALS ONLY
         LA    R1,PARML           R1 -> TO PLI PARMS
         L     R15,=V(PLICALLA)   R15 -> TO PLI PGM
         BALR  R14,R15            GO FOR IT
         NI    SWITCHWD,255-TOTALS-PERCENTS TURN PRINT TOTALS ONLY OFF
         SPACE 5
RETURN   TM    SW1,X'01'           DOING ALL VOLS?
         BO    SW1RTN              YES, GET NEXT VOL
         TM    SW2,X'80'          DOING ALL DSNAMES BY CATLG ?
         BO    NEXTDSNA           YES, GET NEXT DSNAME ADDRESS
         SPACE 1
RETURN2  DS    0H
         TM    SW3,SW380+SW340    DOING BATCH WITH SYSIN ?
         BO    GETIN              YES, GET NEXT DSNAME
         SPACE 1                                                    RH
ENDBATCH DS    0H
         TM    MCDSW,PRINTIT      WAS MCD ALLOCATED ?               RH
         BZ    RET0               NO, DON'T TRY TO CLOSE IT         RH
         SPACE 3
***********************************************************************
*                                                                     *
*    CLOSE THE VSAM FILE:  MCDS.                                      *
*                                                                     *
***********************************************************************
         SPACE 3
*
*    CLOSE THE VSAM FILES.
*
         SPACE
CLSVSAM  DS    0H
         L     R6,=V(FLAG)        R6 -> TO ACB OPEN FLAG
         TM    0(R6),FLAGEXP      DID WE OPEN MCDS FILE ?           RH
         BZ    CLSNVSAM           NO, DON'T TRY TO CLOSE IT         RH
         L     R6,=V(MCDS)        R6 -> TO MCDS ACB
*        LA    R6,MCDS
         CLOSE ((R6))
*        LTR   R15,R15             CLOSE SUCCESSFUL ???
*        BZ    CLSNVSAM            YES, SO CLOSE NON-VSAM FILES
*
*    ISSUE MESSAGE THAT THE MCDS DID NOT CLOSE.  THIS ISN'T VERY
*    SERIOUS AS THE PROGRAM HAS FINISHED.
*
*        CALL  $CHGERR,(MAIN03),VL
*        LA    R1,2                LOAD WARNING RETURN CODE
*        C     R1,RETCODE          WARNING <= RETURN CODE ???
*        BNH   CLSNVSAM            YES, SO DO NOT UPDATE RETURN CODE
*        ST    R1,RETCODE          STORE WARNING RETURN CODE
         SPACE 1
CLSNVSAM DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
*    DEALLOCATE THE MCDS FILE                                         *
*                                                                     *
***********************************************************************
         SPACE 3
         LA    R1,DA18CD          R1 -> TO FREE DAIR BLK            RH
         ST    R1,DAPLDAPB        PUT FREE BLK ADDR IN DAIR UPT     RH
         MVC   DA18DDN(8),MCDDDDNM MOVE MCDS DDN TO DA18 BLOCK      RH
         MVI   DA18DPS2,X'08'      KEEP MCDS DATA SET               RH
         LA    R1,DAPLUPT         R1 -> TO DAIR UPT                 RH
         LINK  EP=IKJDAIR         LINK TO DAIR                      RH
         LTR   R15,R15            WAS MCDS FREED?
         BZ    MCDSFREE           YES, SO CLOSE NON-VSAM FILES
         NI    MCDSW,255-PRINTIT  SAY MCD NOT ALLOCATED             RH
         MVI   ABENDFLG,X'FF'     SET ABEND FLAG TO ABEND
         PUTIT 'HSM FILE(MCDS) NOT FREED. DO A FREE COMMAND'
*
         SPACE 1
MCDSFREE DS    0H
*
*    FREEMAIN ANY PREVIOUSLY OBTAINED AREA.
*
         L     R0,GETMLEN          LOAD CURRENT LENGTH
         L     R1,GETMADDR         LOAD CURRENT ADDRESS
         LTR   R0,R0               SIZE > 0 ???
         BZ    RET0                NO
         FREEMAIN R,              DON'T ABEND IF IT CAN'T BE FREED     *
               A=(R1),                                                 *
               LV=(R0)
         SPACE 1
RET0     DS    0H
         TM    SWITCHWD,PRINTIT   DID WE PRINT TO A FILE?           RH
         BZ    RET1               NO, SKIP DEALLOC CRAP             RH
         CLOSE (PRTDCB)           CLOSE IT                          RH
         LA    R1,DA18CD          R1 -> TO FREE DAIR BLK            RH
         ST    R1,DAPLDAPB        PUT FREE BLK ADDR IN DAIR UPT     RH
         MVC   DA18DDN(8),=C'PRTDDNAM' MOVE PRINT DDN TO DA18 BLOCK RH
         MVI   DA18DPS2,X'08'      KEEP PRINT DATA SET              RH
         LA    R1,DAPLUPT         R1 -> TO DAIR UPT                 RH
         LINK  EP=IKJDAIR         LINK TO DAIR                      RH
         SPACE 1                                                    RH
RET1     DS    0H
RETNOP   B     NOCLOSE            NOP IF REPORT FILE OPEN           RH
         CLOSE (REPORT)           CLOSE OUTPUT FILE
         SPACE 1                                                    RH
NOCLOSE  DS    0H
         L     R13,4(,R13)
         RETURN (14,12),RC=0
         SPACE 3
*        PRINT NOGEN
*
ERROR2   DS    0H
         MVI   ABENDFLG,X'FF'     SET ABEND FLAG TO ABEND
         PUTIT 'INCOMPLETE PARAMETERS'
*
ERROR3   DS    0H
         MVI   ABENDFLG,X'FF'     SET ABEND FLAG TO ABEND
         PUTIT 'NOT ENOUGH SPACE IN REGION'
*
ERROR4   DS    0H
         MVI   ABENDFLG,X'FF'     SET ABEND FLAG TO ABEND
         PUTIT 'INVALID PARAMETERS'
*
ABEND1   ABEND 1004,DUMP
ABEND2   EQU   ABEND1
*
ERROR5   DS    0H
         MVI   ABENDFLG,X'FF'     SET ABEND FLAG TO ABEND
         PUTIT 'NO TIOT ENTRIES AVAILABLE'
*
ERROR6   DS    0H
         MVI   ABENDFLG,X'FF'     SET ABEND FLAG TO ABEND
         PUTIT 'DDNAME NOT AVAILABLE'
*
ERROR7   DS    0H
         MVI   ABENDFLG,X'FF'     SET ABEND FLAG TO ABEND
         PUTIT 'DSNAME IS MEMBER OF CONCAT. DATA SET'
*
ERROR8   DS    0H
         MVI   ABENDFLG,X'FF'     SET ABEND FLAG TO ABEND
         PUTIT 'SVC 99 ERROR'
*
ERROR9   DS    0H
         MVI   ABENDFLG,X'00'     SET ABEND FLAG TO CONTINUE
         MVC   MSG+40(44),LVLBUF+2 PUT DSNAME INTO MSG              RH
         B     ERROR14            GO PRINT MSG
*
ERROR10  DS    0H
         MVI   ABENDFLG,X'FF'     SET ABEND FLAG TO ABEND
         B     ERROR13            GO PRINT MSG
*
ERROR11  DS    0H
         MVI   ABENDFLG,X'FF'     SET ABEND FLAG TO ABEND
         PUTIT 'DATA SET HAS BEEN DELETED'
*
ERROR12  DS    0H
         MVI   ABENDFLG,X'00'     SET ABEND FLAG TO CONTINUE
         PUTIT 'REQUEST DENIED BY INSTALLATION EXIT'
*
ERROR13  DS    0H
         MVI   SW2,X'00'          TURN ALL CATLG BITS OFF
*
ERROR14  DS    0H
         PUTIT 'DATA SET NOT IN CATALOG'
*
DAIRERR  DS    0H
         ST    R15,DAIR15          SAVE IKJDAIR ERROR CODE
         LA    R1,FAILPARM         R1 -> TO DAIRFAIL PARM LIST
         LINK  EP=IKJEFF18         LINK TO DAIRFAIL
         LTR   R15,R15             WAS DAIRFAIL OKAY ?
         BZ    ANYMORE             YES, ANY MORE VOLS ?
         PUTIT 'DAIRFAIL ERROR.    CALL SYSTEMS SUPPORT'
         SPACE 2
         EJECT
* $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
*        WORK AREAS
* $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
DUMPTITL DC    C'WORKING STORAGE SECTION'
* ------ WORK  AREAS              ------------------------------------
         LTORG
RETADDR  DS    F                  SAVE AREA FOR RETURN ADDRESS
SAVER9A  DS    F                  SAVE AREA FOR R9
PSCBADDR DS    F                  PSCBADDR
*SVCERR  DC    F'0'               SVC 99 RC IF > 0
VOLCNT2  DC    H'1'                      VOL COUNT
VOLLTH2  DS    0F              LTH OF MSG
         DC    AL2(0)          TSID
         DC    AL2(L'VOLMSG)   BUFFER SIZE
VOLMSG   DS    0CL96              WAS 84
         DC    CL1' '
         DC    CL12' '            SKIP PAST CREATE/USED DATES...
ERRVOL   DC    CL6' '
ERRMSG   DC    CL32' '
         DC    C' '
ERRDSN   DS    CL44
*        DC    CL1' '
ERRLTH   EQU   *-ERRVOL
NTVALMSG DC    CL32'    NOT VALID FOR YOUR USE'
DATAMSG  DC    CL32'    VSAM DATA  OBJECT NAME'
INDEXMSG DC    CL32'    VSAM INDEX OBJECT NAME'
HSMMSG   DC    CL32'    ERROR READING HSM DATASET'
BASEMSG  DC    CL32'    GDG BASE'
CARTMSG  DC    CL32'    CARTRIDGE TAPE DATASET'
TAPEMSG  DC    CL32'    TAPE DATASET'
UNKNMSG  DC    CL32'    UNKNOWN DEVICE TYPE'
MIGMSG   DC    CL32'    DATASET WAS MIGRATED BY HSM'
ALIASMSG DC    CL32'    ALIAS NAME'
*
*RR04MSG DS    0C
*        DC    CL12' '
*RR04VOL DS    CL6' '
*        DC    CL33'   ERROR GETTING DATASET INFO'
*RR04DSN DC    CL44' '
*RR04LTH EQU   *-ERR04MSG
*
ERR04MSG DS    0C
         DC    CL12' '
ERR04VOL DS    CL6' '
ERR0433  DS    0C
*        DC    CL33'   ERROR GETTING DATASET INFO'
         DC    C'   SVC99 ERROR. RC='
ERR04RC  DC    CL5' '
ERR04IN  DC    CL5' '
         DC    CL(33-(*-ERR0433))' '
ERR04DSN DC    CL44' '
ERR04LTH EQU   *-ERR04MSG
*
MAXMSG   DC    C' DATASET USES '
MAXVOL   DC    CL3' '
         DC    C' VOLUMES.'
VOLMSGL  EQU   *-MAXMSG
         DC    C' ONLY THE FIRST 50 ARE SHOWN'
         DC    CL(80-(*-MAXMSG))'  '
MAXMSGL  EQU   *-MAXMSG
*
IDCMSG   DC    C' ERROR CALLING IDCAMS. '
         DC    C' DATASET MAY USE MORE THAN '
IDCVOLM  DC    CL3' '
         DC    C' VOLUMES.'
         DC    CL(80-(*-IDCMSG))'  '
IDCMSGL  EQU   *-IDCMSG
DWORD2   DS    D
*
LASTDSN  DC    F'0'
         SPACE 2
*        TCAM   LIST
TCAML    DS     0F
TCFLGS   DC     X'44000000'              TCAM ON DSN
TCAMDSN  DC     A(0)                     A(DSN)
         DC     A(0)                     VOL POINTER
         DC     A(TWORK)                 A(265 BYTE WORK AREA)
         DS    0D                 PUT ON DOUBLE WORD BOUNDARY
TWORK    DS     0CL265
VOLCNT   DC     H'0'                     VOL COUNT
DEVTYP   DC     XL4'00'                  DEVICE TYPE
TVOL     DC     CL6' '                   FIRST VOL SER
         DC     CL(265-(*-TWORK))' '     ROOM FOR 19 MORE...
         DC     360C' '           ROOM FOR 30 MORE BY IDCAMS....
         DC     12X'FF'           END OF LIST...
         SPACE 2
*
*              SEE DIAGNOSIS:SYSTEM REFERENCE, SECTION 7, SVC 26,
*              FOR SUPERLOC WORK AREA, OR MACRO IEZCTGPL.
*                  NOTE... THIS WAS # LY28-1011 IN 1989.
*
         DS    0F
SUPERLOC DC    X'07001100'
         DC    A(SUPERLVL)
         DC    A(0)
WORKADDR DC    A(SWORK)
         DC    A(0)
CTGFDBK  DC    A(0)               SUPERLOCATE FEEDBACK AREA         RH
         DC    A(0)
         DC    A(0)
         SPACE 3
SWORK    DS    0F
H265     DC    H'265'
         DC    H'0'
         DS    CL265
         SPACE 3
TRTAB    DC    C' 0123456789ABCDEF'
         SPACE 3
*        PARSE PARAMETER LIST
         SPACE 2
PPLUPT   DC    A(0)
PPLECT   DC    A(0)
PPLECB   DC    A(PPLECBS)
PPLPCL   DC    A(PARMLIST)
         DC    A(PPLANS)
PPLCBUF  DC    A(0)
PPLUWA   DC    A(0)
         SPACE 1
PPLECBS  DC    A(0)
PPLANS   DC    A(0)  ANSWER PLACE
         SPACE 5
*        DAIR ALLOCATE BY DSNAME BLOCK FOR PRINT FILE               RH
         SPACE 2
PRTDRBLK DS    0F
PRTDCD   DC    X'0008'
PRTDFLG  DC    H'0'
PRTDDARC DC    H'0'
PRTDCTRC DC    H'0'
PRTDDSN  DC    A(PRTDSNL)
PRTDDDNM DC    C'PRTDDNAM'
PRTDUNIT DC    CL8'SYSALLDA'
PRTDVSER DC    CL8' '
PRTDBLK  DC    F'00'
PRTDPQTY DC    F'0'
PRTDSQTY DC    F'0'
PRTDDQTY DC    F'0'
PRTDMNAM DC    CL8' '
PRTDPSWD DC    CL8' '
PRTDDSP1 DC    X'08' SHR
PRTDDSP2 DC    X'08' KEEP
PRTDDSP3 DC    X'08' KEEP
PRTDCTL  DC    X'00'
PRTDUID  EQU   X'20'  OR IN TO CONCAT USERID
         DC    3X'00'
PRTDFLG2 DC    XL1'00'
PRTDALN  DC    CL8' '
         SPACE 1
         ENTRY DDSNAML,DSNAME
*DDSNAML  DC    AL2(L'SPACDSN+L'DSPADSN)
DDSNAML  DC    AL2(44)
DDSNAM   DS    0CL44
DSNAME   DS    0CL44
DSPADSN  DC    C'            '
SPACDSN  DC    C'      '
         DC    CL(44-L'SPACDSN-L'DSPADSN)' '
PRTDSNL  DC    AL2(44)
PRTDSN   DC    CL44' '
         SPACE 1                                                    RH
         ENTRY PRTDCB
PRTDCB   DCB   DSORG=PS,DDNAME=PRTDDNAM,MACRF=PM,RECFM=FBA,         RH C
               LRECL=133,BLKSIZE=19019                              RH
         SPACE 5
*        DAIR PARAMETER LIST
         SPACE 2
DAPLUPT  DC    A(0)
DAPLECT  DC    A(0)
DAPLECB  DC    A(DAPLECBS)
DAPLPSCB DC    A(0)
DAPLDAPB DC    A(PRTDRBLK)
DAPLECBS DC    A(0)
         SPACE 5
*        DAIR DEALLOCATE BY DDNAME BLOCK
         SPACE 2
         DS    0F
DA18CD   DC    X'0018'
DA18FLG  DC    H'0'
DA18DARC DC    H'0'
DA18CTRC DC    H'0'
DA18DSN  DC    F'0'
DA18DDN  DC    CL8' '
DA18MEM  DC    CL8' '
DA18SCLS DC    CL2' '
DA18DPS2 DC    X'08'
DA18CTL  DC    X'10'              UNALLOCATE PERM. ALLOC DSNS
         DC    8X'00'
         SPACE 5
* PL/1 PARAMETER LIST
         DS    0D
PARML    DC         A(PLEVEL)
         DC         A(PVOL)
         DC         A(PMAX)
         DC         A(PDD)
         DC    A(PLSW)
         DC    XL1'80',AL3(PARMLMCD)
*
         ENTRY LVLBUF
PLEVEL   DC    A(LVLBUF),H'44',X'8000'
LVLBUF   DC    AL2(*-*),CL44' '
SUPERLVL DC    AL1(*-*),CL45' '
SAVPART  DC    AL2(*-*),CL44' '
**
ABENDFLG DC    X'00'              FLAG FOR ABEND OR NOT
**
PVOL     DC    A(TUPAR1),H'6',X'0000'
*
PMAX     DC    A(MAXBUF),H'8',X'8000'
MAXBUF   DC    AL2(*-*),CL8' '
*
PDD      DC    A(PRTDDDNM)                                          RH
PDDLTH   DC    H'8',X'0000'
*
PARMLMCD DC    A(0),H'1',X'0000'
*
PLSW     DC    A(SWITCHWD),H'1',X'0000'
         ENTRY SWITCHWD
SWITCHWD DC    BL1'00000000'      DEFAULT IS TOTAL(NO)
*W1      DC         X'00'
PRINTIT  EQU   B'10000000'
TOTALIT  EQU   B'01000000'
PERCENTS EQU   B'00100000'
MULTIVOL EQU   B'00010000'
OFFLIST  EQU   B'00001000'
HLILIST  EQU   B'00000100'        HIGH LEVEL INDEX SWITCH
HEADING  EQU   B'00000010'        PRINT HEADING ONLY SWITCH
TOTALS   EQU   B'00000001'        PRINT TOTALS ONLY SWITCH
*
SW1      DC    X'00'
SW101    EQU   X'01'              DO ALL VOLS SWITCH
*
SW2      DC         X'00'
SW280    EQU   X'80'              PROCESSING AN INDEX
SW240    EQU   X'40'              DSN IS OK
SW220    EQU   X'20'              PROCESSING A GDG
SW210    EQU   X'10'              PROCESSING A PARTIAL DSN
SW204    EQU   X'04'              SPECIFIED VOLUME NOT FOUND
*
SW3      DC         X'00'
SW380    EQU   X'80'              THIS IS A BATCH RUN
SW340    EQU   X'40'
SW320    EQU   X'20'
SW310    EQU   X'10'
*
         SPACE 1
NUMENTS  DC    F'1'               INITIALLY 1 ENTRY (0)
UCBTABLE DC    500Y(0)
UCBTABLN DC    A((*-UCBTABLE)/2)  NBR OF 2 BYTE ENTRIES IN TABLE    RH
VOLSAVE  DC    5F'0'
UCBADDR  DC    F'0'
PRTDDN   DC    CL8' '             DEFAULT TO NO PRINT DDNAME        RH
         SPACE 2
FAILPARM DC    A(DAPLUPT)         OR A(S99RB  ) FOR SVC 99...       RH
         DC    A(DAIR15)
         DC    A(JEFF02)
         DC    A(FAILSW)
CPPLADDR DC    A(0)
         DC    A(DFBUFS)
DAIR15   DC    F'0'               SVC 99 RETURN CODE
JEFF02   DC    A(0)
FAILSW   DC    X'0001'            DAIR
*              X'0032'            SVC 99
*              X'0033'            SVC 99 FREE
DFBUFS   DS    0F
         DS    AL2
         DS    AL2
         DS    CL251
*        DS    0H
         DS    AL2
         DS    AL2
         DS    CL251
         SPACE 1
         DS    0H
PUTMSG   DC    A(PUT1MSG)
PUT1MSG  DC    AL2(88)            AL2(PUTLTH1) CAUSES 66D-08 ABEND.
INFO1    DS    0CL133
*        DC    C'0'
MSG      DC    CL44' '
CTLTOTAL DC    CL8' '
         DC    CL80' '
         DC    C' '
PUTLTH1  EQU   *-INFO1
         EJECT
*        DCB'S  FOR FILES
*
* ------ DCB'S                    ------------------------------------
REPORT   DCB   DSORG=PS,DDNAME=SYSPRINT,LRECL=133,RECFM=FBA,        XXXX
               MACRF=(PM),BLKSIZE=133
SYSIN    DCB   DSORG=PS,DDNAME=SYSIN,LRECL=80,RECFM=FB,             XXXX
               MACRF=(GL),EODAD=ENDBATCH
         EJECT
*              CONTROL BLOCKS FOR  SVC 99
         SPACE 1
         DS    0F                 PUT ON FULLWORD BOUNDARY
S99RBPTR DC    XL1'80'
         DC    AL3(S99RB)
S99RB    DS    0F
S99RBLN  DC    AL1(20)
S99VERB  DC    AL1(1)             ALLOCATE BY DSNAME
S99FLAG1 DC    XL2'2000'          DON'T MOUNT VOLS OR CONSIDER OFFLINES
S99ERROR DC    AL2(0)
S99INFO  DC    AL2(0)
S99TXTPP DC    A(S99TUPL)
S99RES1  DC    A(0)
S99FLAG2 DC    A(0)
         SPACE 1
S99TUPL  DS    0F
TUPL1    DC    A(TUNIT1)
TUPL2    DC    A(TUNIT2)
TUPL3    DC    A(TUNIT3)
TUPL4    DC    A(TUNIT4)
TUPL6    DC    A(TUNIT6)
TUPL7    DC    XL1'80'
         DC    AL3(TUNIT7)
         SPACE 1
S99TUPL2 DS    0F
TUPL21   DC    A(TUNIT1)
TUPL22   DC    A(TUNIT22)
TUPL27   DC    XL1'80'
         DC    AL3(TUNIT7)
         SPACE 1
TUNIT1   DS    0C
TUKEY1   DC    AL2(1)             ALLOCATE BY DDNAME
TUNUM1   DC    AL2(1)
TUENT1   DS    0C
TULNG1   DC    AL2(6)             LTH OF DDNAME
TUPAR1   DC    CL6'XXXXXX'        DDNAME
         SPACE 1
TUNIT2   DS    0C
TUKEY2   DC    XL2'0010'          VOL SER
TUNUM2   DC    AL2(1)
TUENT2   DS    0C
TULNG2   DC    XL2'0006'          LTH OF VOL SER
TUPAR2   DC    CL6' '             VOL SER
         SPACE 1
TUNIT3   DS    0C
TUKEY3   DC    XL2'0015'          UNIT TYPE
TUNUM3   DC    AL2(1)
TUENT3   DS    0C
TULNG3   DC    AL2(5)             LTH OF UNIT TYPE
TUPAR3   DC    CL8'     '         DEFAULT UNIT TYPE  WAS SYSDA.0199
         SPACE 1
TUNIT4   DS    0C
TUKEY4   DC    XL2'0016'          UNIT COUNT
TUNUM4   DC    AL2(1)
TUENT4   DS    0C
TULNG4   DC    AL2(1)             LTH OF UNIT COUNT
TUPAR4   DC    XL1'01'            UNIT COUNT IS 1
         SPACE 1
TUNIT6   DS    0C
TUKEY6   DC    XL2'0004'          STATUS OF UNIT
TUNUM6   DC    AL2(1)
TUENT6   DS    0C
TULNG6   DC    AL2(1)             LTH OF STATUS
TUPAR6   DC    X'08'              STATUS = SHR
*        DC    X'02'              STATUS = MOD
*        DC    X'04'              STATUS = NEW
*        DC    X'01'              STATUS = OLD
         SPACE 1
TUNIT7   DS    0C
TUKEY7   DC    XL2'0005'          STATUS 2..DISP=(OLD,KEEP)
TUNUM7   DC    AL2(1)
TUENT7   DS    0C
TULNG7   DC    AL2(1)             LTH OF STATUS 2
TUPAR7   DC    X'08'              DISP= KEEP
         SPACE 1
TUNIT22  DS    0C
TUKEY22  DC    XL2'0007'          UNALLOC EVEN IF PERM ALLOC
TUNUM22  DC    AL2(0)
         SPACE 1
PARMLST2 DS    3F                 PARMLIST MAPPING
         ORG   PARMLST2
PARMWA   DC    A(WORKAREA)        ADDRESS OF 100-BYTE WORKAREA
PARMDEVT DC    A(DEVCLASS)        ADDRESS OF BYTE CONTAINING
*                                 THE DEVICE TYPE TO BE SEARCHED
PARMUCB  DC    AL1(80)            ADDRESS OF WORD TO CONTAIN THE
         DC    AL3(ADDRUCB)       THE UCB ADDRESS
         SPACE 1
DEVCLASS DC    XL1'20'            BYTE CONTAINING DEVICE CLASS
*                                 TO BE SEARCHED FOR
*                                 X'20' IS DIRECT ACCESS
ADDRUCB  DS    F                  WORD IN WHICH UCBSCAN WILL
*                                 PLACE THE ADDRESS OF THE UCB
         DS    0D                 ALIGN TO DOUBLE-WORD BOUNDARY
*                                 THE WORKAREA FOR SCAN SERVICE
*                                 MUST BE ON A DOUBLE-WORD BOUNDARY
WORKAREA DS    CL100              WORKAREA
UCBAREA  DS    CL48               WORKAREA FOR UCB
CMXTAREA DS    CL32               WORKAREA FOR UCB
DCELEN   DC    AL2(128)           WORKAREA FOR UCB
DCEAREA  DS    CL128              WORKAREA FOR UCB
         SPACE 1
         LTORG
         SPACE 1
*        IEFUCBOB                 UCB MAPPING MACRO
*        CVT   DSECT=YES
*              NOTE..THE ABOVE MACROS ARE IN SYS1.AMODGEN
         SPACE 1
*
*
CHECKPTR EQU  3
CHECKPDE EQU  4
UT2      EQU  2
*0       EQU   0
*1       EQU   1
*2       EQU   2
*3       EQU   3
*4       EQU   4
*5       EQU   5
*6       EQU   6
*7       EQU   7
*8       EQU   8
*9       EQU   9
*10      EQU   10
*11      EQU   11
*12      EQU   12
*13      EQU   13
*14      EQU   14
*15      EQU   15
PARMLIST IKJPARM
*EVEL    IKJPOSIT  DSNAME,                                             X
               VALIDCK=DSNCHECK,                                       X
               HELP=('LEVEL OF INDEX','STRING FOR DSNAME SEARCH')
LEVEL    IKJIDENT  'DSNAME',LIST,MAXLNTH=44,                           X
               FIRST=ALPHANUM,OTHER=ANY,CHAR,                          X
               VALIDCK=DSNCHECK,                                       X
               HELP=('LEVEL OF INDEX','STRING FOR DSNAME SEARCH')
VOLKWD   IKJKEYWD   DEFAULT='VOL'
         IKJNAME    'VOL',SUBFLD=VOLSUB
SUPV     IKJKEYWD
         IKJNAME    'ALLOC',SUBFLD=SUPERALL
UNTKWD   IKJKEYWD
         IKJNAME    'UNIT',SUBFLD=UNTSUB
PRNTKWD  IKJKEYWD
         IKJNAME    'PRINT',SUBFLD=PRNTDD
MCDSKWD  IKJKEYWD
         IKJNAME    'MCDS',SUBFLD=MCDSDD
ACCUMKWD IKJKEYWD
         IKJNAME    'TOTAL',SUBFLD=PERCENT
DSNCTKW  IKJKEYWD   DEFAULT='MAX'
         IKJNAME    'MAX',SUBFLD=DSNCTSBF
LISTKWD  IKJKEYWD   DEFAULT='LIST'
         IKJNAME    'LIST'
         IKJNAME    'NOLIST'
VOLSUB   IKJSUBF
SERS     IKJIDENT  'VOL SERS',LIST,MAXLNTH=6,                          X
               FIRST=ALPHANUM,OTHER=ALPHANUM,                          X
               VALIDCK=VOLCHECK,                                       X
               HELP=('VOLUME TO BE SEARCHED FOR DATA SETS')
SUPERALL IKJSUBF
SVDSN    IKJPOSIT  DSNAME,LIST,PROMPT='DSN TO BE ALLOCATED'
UNTSUB   IKJSUBF
UNIT     IKJIDENT  'UNIT TYPE',FIRST=ANY,OTHER=ANY,MAXLNTH=5
PRNTDD   IKJSUBF
PRINTDD  IKJPOSIT   DSNAME,USID,HELP='DSNAME OF PRINT OUTPUT FILE'  RH
MCDSDD   IKJSUBF
MCDSDSN  IKJPOSIT   DSNAME,USID,HELP='DSNAME OF HSM MIGRATE FILE'   RH
PERCENT  IKJSUBF
PERCKWD  IKJKEYWD   DEFAULT='YES'
         IKJNAME    'NO'
         IKJNAME    'YES'
DSNCTSBF IKJSUBF
DSNCT    IKJIDENT   '# OF DATA SETS',FIRST=NUMERIC,OTHER=NUMERIC,      X
               MAXLNTH=8,DEFAULT='9999'
         IKJENDP
*
*
         PRINT GEN
         IKJCPPL
         IKJIOPL
         IKJPSCB
LVLDX    DSECT
LVLPTR   DS    A
LVLLTH   DS    H
LVLFLG   DS    BL2
LVLNXT   DS    A
*
*
VOLDX    DSECT
VOLPTR   DS    A
VOLLTH   DS    H
VOLFLG   DS    BL2
VOLNXT   DS    A
*
*
SVDDX    DSECT
SVDPTR   DS    A
SVDLTH   DS        H
SVDFLG   DS    BL2
SVDXXX   DS    2D
SVDNXT   DS    A
*
*
UNTDX    DSECT
UNTPTR   DS     A
UNTLTH   DS     H
UNTFLG   DS     BL2
*
PRNTDX   DSECT      DESCRIPTION OF PRINTDD SUBF OF PRINT KWD
PRNTPTR  DS         A
PRNTLTH  DS         H
PRNTFLG  DS         BL2
PRINTON  EQU        X'80'
*
TOTDX    DSECT      DESCRIPTION OF TOTAL KWD
TOTTYPE  DS         H
TOTON    EQU        X'01'
TOTOFF   EQU        X'00'
*
PERCDX   DSECT      DESCRIPTION OF PERCENT KWD
PERCTYPE DS         H
PERCYES  EQU        X'02'
PERCNO   EQU        X'01'
*
DSNCTDX  DSECT      DESCRIPTION OF MAX KWD SUBF
DSNCTPTR DS         A
DSNCTLTH DS         H
DSNCTFLG DS         BL2
DSNCTON  EQU        X'80'
*
LISTDX   DSECT       LIST KEYWORD DSECT
LISTTYPE DS         H
LISTON   EQU        X'01'
LISTOFF  EQU        X'02'
*
         EJECT
VOLCHECK CSECT
         STM   R14,R12,12(R13)
         BALR  BASE,0
         USING *,BASE
         LR    CHECKPTR,R1
         L     R0,ALWORK
         GETMAIN   R,LV=(0)
         XC    0(LWORK,R1),0(R1)
         ST    R1,8(R13)
         ST    R13,4(R1)
         LR    R13,R1
         L     CHECKPDE,0(CHECKPTR)
         LH    UT2,4(CHECKPDE)
         CH    UT2,=H'6'
         BNE   BADLTH
         LA    R15,0
GOBACK   LR    R1,R13
         L     R13,4(R1)
         L     R0,ALWORK
         LR    R10,R15            SAVE R15 OVER FREEMAIN
         FREEMAIN  R,LV=(0),A=(1)
         LR    R15,R10            RELOAD R15
         LM    R0,R12,20(R13)
         L     R14,12(R13)
         BR    R14
BADLTH   LA    R15,4
         LA    UT2,MBADLTH
         ST    UT2,8(CHECKPTR)
         B     GOBACK
         DS    0D
ALWORK   DC    AL1(0),AL3(LWORK)
LWORK    EQU   72
MBADLTH  DC    AL4(0),AL2(L'MSGBADL+4),AL2(0)
MSGBADL  DC    C' VOL SER MUST BE SIX CHARACTERS IN LENGTH '
LIT2     LTORG
         EJECT
*
*              CHECK THE DSN TO SEE IF IT IS TOO LONG....
*
DSNCHECK CSECT
         STM   R14,R12,12(R13)
         BALR  BASE,0
         USING *,BASE
         LR    CHECKPTR,R1
         L     R0,DLWORK
         GETMAIN   R,LV=(0)
         XC    0(LWORK,R1),0(R1)
         ST    R1,8(R13)
         ST    R13,4(R1)
         LR    R13,R1
         L     CHECKPDE,0(CHECKPTR)
         LH    UT2,4(CHECKPDE)
         CH    UT2,=H'44'
         BH    BADLTHD
         LA    R15,0
GOBACKD  LR    R1,R13
         L     R13,4(R1)
         L     R0,DLWORK
         LR    R10,R15            SAVE R15 OVER FREEMAIN
         FREEMAIN  R,LV=(0),A=(1)
         LR    R15,R10            RELOAD R15
         LM    R0,R12,20(R13)
         L     R14,12(R13)
         BR    R14
BADLTHD  LA    R15,4
         LA    UT2,MBADLTH2
         ST    UT2,8(CHECKPTR)
         B     GOBACKD
         DS    0D
DLWORK   DC    AL1(0),AL3(LWORK)
*WORK    EQU   72
MBADLTH2 DC    AL4(0),AL2(L'MSGBADL2+4),AL2(0)
MSGBADL2 DC    C' DSNAME MUST BE LESS THAN 44 CHARACTERS IN LENGTH '
LIT2D    LTORG
*        EJECT
         TITLE  'TSO SPACE COMMAND - CODE FOR PL/I TPUT'
*
*            CODE FOR PL/1 TPUT
*
TSOPUT   CSECT
         STM       R14,R12,12(R13)
         LR    R11,R15
         USING     TSOPUT,R11
         LR        PARMPTR,R1
*        L         R0,ALWORK
*ETWORK  GETMAIN   R,LV=(0)
*        XC        0(LWORK,R1),0(R1)
         LA    R1,PUTSAVE
         ST        R13,4(0,R1)
         ST        R1,8(R13)
         LR    R13,R1             R13 -> TO OUR SAVE AREA
*        LR        WORKPTR,R1
*        USING     WORK,WORKPTR
         L         PARMPTR,0(PARMPTR)
         USING     SDV,PARMPTR
         L         R1,SDVADDR
         LH    R0,0(,R1)          R0 = LTH OF MSG
         LA    R1,2(,R1)          R1 -> TO MSG
         L     R3,=V(SW3)         R3 -> TO SW3 IN SPACE PGM
         TM    0(R3),SW380        IS THIS A BATCH RUN ?
         BZ    PUTIT              NO, GO DO A TPUT
         LR    R4,R0              R4 = LTH OF MSG
         BCTR  R4,0               R4 = HEX LTH OF MSG
         L     R3,=V(INFO1)       R3 -> TO MSG AREA
         EX    R4,MVCMSG          MOVE MSG TO PRINT LINE
*VCMSG   MVC   0(0,R3),0(R1)      MVC MSG TO PRINT LINE
         L     R1,=V(REPORT)      R1 -> TO REPORT DCB
         SPACE 1
PUTITP   DS    0H
         L     R0,=V(INFO1)       R0 -> TO REPORT PRINT LINE
         PUT   (1),(0)            OUTPUT THE MSG
         SPACE 1
         MVI   0(R3),C'0'         CHANGE CC TO DOUBLE SPACE
         MVI   1(R3),C' '         CLEAR PRINT LINE
         MVC   2(131,R3),1(R3)    *
         B     TSOEND             RETURN TO PLI PGM
         SPACE 1
PUTIT    DS    0H
         L     R3,=V(SWITCHWD)    R3 -> TO SWITCHWD IN SPACE PGM
         TM    0(R3),PRINTIT      PRINT TO A FILE?
         BZ    PUTIT2             NO, GO DO A TPUT
         LR    R4,R0              R4 = LTH OF MSG
         BCTR  R4,0               R4 = HEX LTH OF MSG
         L     R3,=V(INFO1)       R3 -> TO MSG AREA
         EX    R4,MVCMSG          MOVE MSG TO PRINT LINE
*VCMSG   MVC   0(0,R3),0(R1)      MVC MSG TO PRINT LINE
         L     R1,=V(PRTDCB)      R1 -> TO OUTPUT DCB
         B     PUTITP             GO PUT RECORD IN FILE
         SPACE 1
PUTIT2   DS    0H
         MVI   0(R1),C' '         REMOVE CC FOR TPUT
*        TPUT  (1),(0),R
*        AGO   .PUT1
*        LA    R2,L'DLINE         ENTIRE LINE LENGTH
*        LA    R2,4(0,R2)         ADD RDW LEN
*        STH   R2,RDWP
*        LA    R2,L'DLINE         ENTIRE LINE LENGTH
*        MVI   BUFFER,C' '        CLEAR BUFFER
*        MVC   BUFFER,+1(119),BUFFER    ....
         LR    R2,R0              R2 = LINE LTH
         BCTR  R2,R0              R2 = HEX LINE LTH
         EX    R2,MOVEDATA        SET UP PRINT LINE.
         LA    R2,5(0,R2)         ADD RDW LEN + 1 WE TOOK OFF
         STH   R2,RDWP
*        ST    R1,PUTMSG          SAVE A(LINE) IN PLI PGM....
*        MVC   BUFFER,DLINE
         L     R1,=V(ECB)         R1 -> TO ECB
         XC    0(4,R1),0(R1)      MAKE SURE IT'S CLEAR
         L     R1,=V(IOPLADD)     R1 -> TO IOPL LIST
         XC    0(4,R1),0(R1)      MAKE SURE IOPLUPT IS CLEAR....
         PUTLINE PARM=PUTLIST,OUTPUT=(RDWP,TERM,SINGLE,DATA),          +
               MF=(E,IOPLADD)
.PUT1    ANOP
*        LR        R1,WORKPTR
*        L         R13,4(WORKPTR)
         SPACE 1
TSOEND   DS    0H
         L     R13,PUTSAVE+4
*        L         R0,ALWORK
*REEWORK FREEMAIN  R,LV=(0),A=(1)
         LM        R14,R12,12(R13)
         BR        R14
MOVEDATA MVC   BUFFER,0(R1)       SET UP PRINT LINE.
         DS        0D
*LWORK   DC        AL1(0),AL3(LWORK)
PUTSAVE  DS    9D
MVCMSG   MVC   0(0,R3),0(R1)      MVC MSG TO PRINT LINE
PUTLIST  PUTLINE MF=L
RDWP     DC    F'0'
BUFFER   DS    CL120' '
*
*        NOTE  ... THE FOLLOWING PARMS ARE SET UP IN PL1 FORMAT
*                  FOR TSOPUT.
*
         DS    0H
*PUTMSG  DC    A(PUT1MSG)
*UT1MSG  DC    AL2(PUTLTH1)
*UTMSG1  DC    CL120' '
*UTLTH1  EQU   *-PUTMSG1
         ENTRY ECB,IOPLADD
ECB      DC    F'0'
IOPLADD  DS    4F
LITERALS LTORG
SDV      DSECT
SDVADDR  DS        A
SDVMAXL  DS        H
SDVFLAG  DS        H
*
*    REGISTER EQUATES
PARMPTR  EQU   10
         SPACE 2
*        END
         TITLE  'TSO SPACE COMMAND - RETRIEVE RECORDS FROM THE HSM MAST+
               ER CONTROL DATASET.'
         SPACE 3
***********************************************************************
*                                                                     *
*                                                                     *
*  PURPOSE:                                                           *
*  -------                                                            *
*                                                                     *
*      TO RETRIEVE RECORDS FROM THE HSM MCDS.  THE DATASET NAME OF    *
*    MIGRATED DATASET IS CONVERTED TO THE TRUE DATASET NAME AND THE   *
*    RECORD DESCRIBING THE MIGRATED DATASET IS READ.                  *
*                                                                     *
*                                                                     *
*  CALLING SEQUENCE:                                                  *
*  ------- --------                                                   *
*                                                                     *
*      CALL $CHGMCDS                                                  *
*                                                                     *
*                                                                     *
*  RETURN CODES:                                                      *
*  ------ -----                                                       *
*                                                                     *
*     0 - RECORD SUCCESSFULLY READ.                                   *
*     4 - RECORD WAS NOT FOUND.                                       *
*                                                                     *
*                                                                     *
*  ABENDS:                                                            *
*  ------                                                             *
*                                                                     *
*    NONE.                                                            *
*                                                                     *
***********************************************************************
         EJECT
         SPACE 3
*
*    RETURN CODES
*
         SPACE
NORECORD EQU   4                   RECORD NOT FOUND READING MCDS
         EJECT
***********************************************************************
*                                                                     *
*    EXTERNAL ROUTINES.                                               *
*                                                                     *
***********************************************************************
         SPACE 3
*
*    ROUTINES USED BY $CHGMCDS.
*
         SPACE
*        EXTRN $CHGDATA
*        EXTRN $CHGERR
*        EXTRN $CHGHEX
         EJECT
***********************************************************************
*                                                                     *
*    ENTRY POINTS.                                                    *
*                                                                     *
***********************************************************************
         SPACE 3
*
*    LOCATIONS THAT ARE KNOWN EXTERNALY.
*
         SPACE
         ENTRY MCDS
         ENTRY $CHGMCDS
         EJECT
***********************************************************************
*                                                                     *
*    STANDARD HIGH-LEVEL SUBROUTINE LINKAGE.                          *
*                                                                     *
***********************************************************************
         SPACE 3
$CHGMCDS CSECT
         USING *,R15              SET TEMP BASE
         B     CONTINUE
         DC    FL1'24',CL9'$CHGMCDS'
         DC    CL6'&SYSTIME'
         DC    CL8'&SYSDATE'
         SPACE 1
CONTINUE DS    0H
         STM   R14,R12,12(R13)
         LR    R12,R15
         DROP  R15                DROP TEMP BASE
         USING $CHGMCDS,R12
         LA    R14,MCDSAVE
         ST    R13,4(,R14)
         ST    R14,8(,R13)
         LR    R13,R14
*
*    SETUP DATA AREA ADDRESSABILITY.
*
*        L     R11,=V($CHGDATA)
*        USING $CHGDA,R11
*
*    ZERO RETURN CODE.
*
         XC    RETCODE(4),RETCODE
*        PRINT ON,NOGEN
         EJECT
         AGO   .NOALIAS
***********************************************************************
*                                                                     *
*    READ THE MCA (MIGRATION CONTROL DATASET ALIAS) RECORD.           *
*                                                                     *
***********************************************************************
         SPACE 3
*
*    ASSUME NO MCD (MIGRATION CONTROL DATASET) RECORD WILL BE
*    FOUND.  SET THE ADDRESS OF THE RECORD TO ZERO.
*
         XC    MCDSADDR(4),MCDSADDR
*
*    COPY THE DATASET NAME, WHICH IS THE KEY FOR THE ALIAS RECORD.
*
         L     R10,DSCBADDR        LOAD ADDRESS OF DSCB
         USING $DYNAREA,R10
         MVC   DSNAME2(44),DS1DSNAM STORE KEY FOR ALIAS RECORD
*
*    ATTEMPT TO READ THE ALIAS RECORD.
*
         GET   RPL=GETMCA
         LTR   R15,R15             ANY ERRORS ???
         BNZ   $CHGEND             YES, SO EXIT
*
*    AN ALIAS RECORD WAS READ.  THE RECORD'S KEY MUST CONTAIN THE
*    GENERATED NAME OF A MIGRATED DATASET.
*
         L     R04,MCABUFF         LOAD ADDRESS OF DATA RECORD
         USING MCA,R04
         CLI   MCAINTTP,C'M'       GENERATED NAME ???
         BNE   SETNTFND            NO, SO RECORD NOT FOUND
         EJECT
.NOALIAS ANOP
***********************************************************************
*                                                                     *
*    READ THE MCD (MIGRATION CONTROL DATASET) RECORD.                 *
*                                                                     *
***********************************************************************
         SPACE 3
         TM    FLAG,FLAGEXP       DID WE OPEN MCDS FILE ?           RH
         BZ    $CHGEND            NO, DON'T TRY TO READ IT          RH
*
*    COPY THE DATASET NAME, WHICH IS THE KEY FOR THE RECORD.
*
*        MVC   DSNAME2(44),MCAINTNM COPY NAME OF USER DATASET
*        L     R15,=V(DSNAME)     R15 -> TO DSNAME
         L     R15,=V(LVLBUF)     R15 -> TO DSNAME LTH
         MVC   DSNAME2(44),2(R15)   COPY NAME OF USER DATASET
*        DROP  R04
*
*    ATTEMPT TO READ THE RECORD.
*
         GET   RPL=GETMCD
*        ST    R15,RETCODE        SAVE RETURN CODE SHOULDN'T NEED
         LTR   R15,R15             ANY ERRORS ???
         BNZ   $CHGEND             YES, SO EXIT
         EJECT
***********************************************************************
*                                                                     *
*    VERIFY MCD RECORD POINTS TO A SUITABLE DATASET.                  *
*                                                                     *
***********************************************************************
         SPACE 3
*
*    A MCD RECORD WAS FOUND THAT MATCHED THE DATASET NAME.  NOW WE MUST
*    COMPARE VOLUME SERIALS.  THE VOLUME HSM THINKS THE DATASET IS ON
*    SHOULD MATCH THE VOLUME SERIAL OF OUR CURRENT UCB.
*
*        L     R1,UCBADDR2         LOAD ADDRESS OF UCB
*        USING UCBOB,R1
         L     R5,MCDBUFF          LOAD ADDRESS OF DATA RECORD
         USING MCD,R5
*        CLC   UCBVOLI(6),MCDVSN   VOLUME SERIALS MATCH ???
*        BE    ON#VOL              YES
         B     ON#VOL              YES
*
*    YIKES.  HSM THINKS THIS DATASET IS ON ANOTHER VOLUME.  THE
*    DSCB WE FOUND SHOULD NOT BE THERE.  ISSUE AN ERROR MESSAGE THAT
*    WE HAVE FOUND AN ORPHAN MIGRATED DATASET.
*
*        MVC   MCDS03+74(44),DS1DSNAM
*        MVC   MCDS03B+23(6),UCBVOLI
*        MVC   MCDS03B+31(3),UCBNAME
*        CALL  $CHGERR,(MCDS03,MCDS03B),VL
         B     SETNTFND            WE DID NOT FIND A MIGRATED DATASET
*        DROP  R1
*
*    CHECK THAT A MIGRATED COPY EXISTS.
*
ON#VOL   EQU   *
         CLI   MCDTYPE,X'00'      IS THIS A DATASET TYPE RECORD?
         BNE   CHKTYPE             NO
         TM    MCDFLGS,MCDFASN     MIGRATED COPY EXISTS ???
         BZ    SETNTFND            NO
*
*    CHECK THAT THE DATASET HAS NOT BEEN RECALLED.
*
         TM    MCDFLGS,MCDFNSCR    DATASET BEEN RECALLED ???
         BO    SETNTFND            YES
*
*    CHECK THAT THIS IS NOT A DUMMY RECORD.
*
         TM    MCDFLGS+1,MCDFDUMD  DUMMY RECORD ???
         BO    SETNTFND            YES
*
*    CHECK THE DEVICE TYPE OF THE PRIMARY VOLUME THE DATASET RESIDED
*    ON.  DEVICE MUST BE DASD 3350 3380, OR 3390.
*
         CLI   MCDUCBTY+2,X'20'    DASD DEVICE ???
         BNE   SETNTFND            NO
         CLI   MCDUCBTY+3,X'0B'    3350 ???
         BE    GOOD#DEV            YES
         CLI   MCDUCBTY+3,X'0E'    3380 ???
         BE    GOOD#DEV            YES
         CLI   MCDUCBTY+3,X'0F'    3390 ???
         BE    GOOD#DEV            YES
         B     SETNTFND
*
*    CHECK THE RECORD TYPE FOR VSAM
*
         SPACE 1
CHKTYPE  DS    0H
         CLI   MCDTYPE,X'11'      IS THIS AN ALIAS TYPE RECORD?
         BNE   SETNTFND            NO, SAY RECORD NOT FOUND
*
         CLI   MCDVSN,C'D'        IS ALIAS FOR A VSAM DATA OBJECT?
         BNE   CHKINDEX           NO, SEE IF FOR INDEX
         MVI   RETCODE+3,16       YES, SET RC = 16
         B     $CHGEND            RETURN TO CALLER
         SPACE 1
CHKINDEX DS    0H
         CLI   MCDVSN,C'I'        IS ALIAS FOR A VSAM INDEX OBJECT?
         BNE   SETNTFND           NO, SAY NOT FOUND
         MVI   RETCODE+3,20       YES, SET RC = 20
         B     $CHGEND            RETURN TO CALLER
*
*    RETURN THE ADDRESS OF THE MCD.
*
GOOD#DEV EQU   *
         ST    R5,MCDSADDR         STORE ADDRESS
         SPACE 1
***********************************************************************
*
*    SET UP A 'DSCB' FOR THE PRINT PROGRAM
*
***********************************************************************
         SPACE 1
         L     R10,=V(GETMADDR)    LOAD A(ADDRESS OF DSCB)_
         L     R10,0(0,R10)       R10 -> TO DSCB AREA
         USING $DYNAREA,R10
         MVI   DS1DSNAM,X'00'     ZERO OUT DSCB
         MVC   DS1DSNAM+1(139),DS1DSNAM  ''
         MVC   DS1DSNAM,MCDKEY    PUT DSNAME INTO DSCB
         MVI   DS1FMTID,C'1'      PUT IDENTIFIER INTO DSCB
*        MVC   DS1CREDT,MCDDLC    PUT CREATE DATE INTO DSCB
*
*              CONVERT CREATE DATE FROM PACKED TO HEX
*
         LH    R14,MCDDLC         R14 = PACKED YEAR
         LTR   R14,R14            IS THERE A DATE?
         BZ    NODATE1            NO
         SLL   R14,4              MAKE ROOM FOR SIGN
         AH    R14,=H'12'         PUT IN 'C' SIGN
         ST    R14,DWORD+4        SAVE IT FOR CONVERT
         CVB   R14,DWORD          CONVERT TO BINARY
         STC   R14,DS1CREDT       PUT YEAR IN DSCB
*
         LH    R14,MCDDLC+2       R14 = PACKED DAY
         ST    R14,DWORD+4        SAVE IT FOR CONVERT
         CVB   R14,DWORD          CONVERT TO BINARY
         STH   R14,DS1CREDT+1     PUT DAY IN DSCB
*
         MVI   DS1NOEPV,X'01'     SAY 1 EXTENT IN DSCB
*        MVC   DS1REFD,MCDDLR     PUT LAST U DATE INTO DSCB
*
*              CONVERT LAST REF DATE FROM PACKED TO HEX
*
         SPACE 1
NODATE1  DS    0H
         LH    R14,MCDDLR         R14 = PACKED YEAR
         LTR   R14,R14            IS THERE A DATE?
         BZ    NODATE2            NO
         SLL   R14,4              MAKE ROOM FOR SIGN
         AH    R14,=H'12'         PUT IN 'C' SIGN
         ST    R14,DWORD+4        SAVE IT FOR CONVERT
         CVB   R14,DWORD          CONVERT TO BINARY
         STC   R14,DS1REFD        PUT YEAR IN DSCB
*
         LH    R14,MCDDLR+2       R14 = PACKED DAY
         ST    R14,DWORD+4        SAVE IT FOR CONVERT
         CVB   R14,DWORD          CONVERT TO BINARY
         STH   R14,DS1REFD+1      PUT DAY IN DSCB
*
         SPACE 1
NODATE2  DS    0H
         MVC   DS1DSORG,MCDDSORG  PUT DSORG INTO DSCB
         MVC   DS1RECFM,MCDRECFM  PUT RECFM INTO DSCB
         MVC   DS1BLKL,MCDBLKSZ   PUT BLKSIZE INTO DSCB
*        MVC   DS1LRECL,MCDLRECL  PUT LRECL INTO DSCB
         MVC   DS1DSIND,MCDDSIND  PUT INDICATORS INTO DSCB
         L     R14,MCDSIZE        R14 = NBR TRKS ALLOC
*
*              CREATE 1ST EXTENT DESCRIPTION
*
         STCM  R14,3,DS1EXT1+6    SET ENDING CCH
         MVI   DS1EXT1,X'01'      SAY 1ST EXTENT
*
*              CREATE LAST USED TTB
*
         SLL   R14,8              MAKE IT TT AND BLOCK
         STCM  R14,7,DS1LSTAR     SAVE IT IN DSCB
         DROP  R5
         EJECT
***********************************************************************
*                                                                     *
*    RETURN TO CALLING ROUTINE.                                       *
*                                                                     *
***********************************************************************
         SPACE 3
*
*    NORMAL TERMINATION.
*
$CHGEND  EQU   *
         L     R13,4(,R13)
         L     R14,12(,R13)
         L     R15,RETCODE
         LM    R0,R12,20(R13)
         MVI   12(R13),X'FF'
         BR    R14
         SPACE 1
DWORD    DS    D
*MAIN03  $MSG  '0<MAIN03> MCDS CLOSE FAILED.'
*MAIN04  $MSG  '0<MAIN04> MCDS OPEN FAILED. '
         SPACE 1
*        DROP  R10
*        DROP  R11
         EJECT
***********************************************************************
*                                                                     *
*    INFORM CALLER VALID MCD RECORD WAS NOT FOUND.                    *
*                                                                     *
***********************************************************************
         SPACE 3
*
*    VALID MCD RECORD WAS NOT FOUND.  POSSIBLE REASONS ARE:
*
*        - NO MCA RECORD EXISTS.  SOME JOKER HAPPENED TO CHOOSE 'HMIG'
*          AS A SECOND LEVEL INDEX.
*
*        - MCD RECORD EXISTS BUT THE DATASET IS NOT YET MIGRATED.
*
*        - MCD RECORD EXISTS BUT THE DATASET HAS BEEN RECALLED.
*
*        - MCD RECORD EXISTS BUT IT IS DUMMY.
*
*        - MCD RECORD EXISTS BUT THE PRIMARY VOLUME IT REFERENCES IS
*          NOT A 3350 3380, OR 3390 DASD.
*
*
SETNTFND EQU   *
         LA    R15,NORECORD           SET THE RETURN CODE
         ST    R15,RETCODE            STORE THE RETURN CODE
         B     $CHGEND                RETURN TO CALLING ROUTINE
         EJECT
***********************************************************************
*                                                                     *
*    VSAM LOGICAL ERROR RECOVERY.                                     *
*                                                                     *
***********************************************************************
         SPACE 3
*
*    A LOGICAL ERROR OCCURRED.  SAVE THE REGISTERS.
*
LOG#ERR  EQU   *
         STM   R0,R15,ERRSAVE+4       SAVE THE REGISTERS
         LA    R13,SHOWSAVE           GET ADDR OF SAVE AREA FOR SHOWCB
*
*    GET THE FEEDBACK CODE.
*
         SHOWCB RPL=(R1),                                              *
               AREA=LOG#AREA,                                          *
               LENGTH=4,                                               *
               FIELDS=(FDBK)
*
*    FEEDBACK CODE OF 16 INDICATES THE RECORD WAS NOT FOUND.
*
         L     R2,LOG#AREA         LOAD FEEDBACK CODE
         C     R2,=F'16'           RECORD NOT FOUND ???
         BNE   BAD#FD              NO
*
*    SET THE RETURN CODE TO 4.
*
         LA    R15,NORECORD        SET RETURN CODE
         ST    R15,RETCODE         STORE RETURN CODE
         B     LOG#EXIT            RETURN TO VSAM
*
*    UNRECOVERABLE LOGICAL ERROR.
*
*        *ERROR* LOGICAL ERROR READING HSM MCDS.
*                KEY = 'DATASET.NAME'
*                FEEDBACK CODE = X'00000000'.
*
BAD#FD   EQU   *
*        MVC   ERR#KEY+20(44),DSNAME2
*        CALL  $CHGHEX,(ERR#FBC+31,LOG#AREA,F4),VL
*        CALL  $CHGERR,(MCDS01,ERR#KEY,ERR#FBC),VL
*
*    SET THE RETURN CODE TO 4.
*
         LA    R15,NORECORD        SET RETURN CODE
         ST    R15,RETCODE         STORE RETURN CODE
*
*    RETURN TO VSAM.
*
LOG#EXIT EQU   *
         LM    R0,R15,ERRSAVE+4    RESTORE REGISTERS
         BR    R14                 RETURN TO VSAM
         EJECT
***********************************************************************
*                                                                     *
*    VSAM PHYSICAL ERROR RECOVERY.                                    *
*                                                                     *
***********************************************************************
         SPACE 3
*
*    A PHYSICAL ERROR OCCURRED.  SAVE THE REGISTERS.
*
PHY#ERR  EQU   *
         STM   R0,R15,ERRSAVE+4       SAVE THE REGISTERS
         LA    R13,SHOWSAVE           GET ADDR OF SAVE AREA FOR SHOWCB
*
*    GET THE FEEDBACK CODE.
*
         SHOWCB RPL=(R1),                                              *
               AREA=PHY#AREA,                                          *
               LENGTH=4,                                               *
               FIELDS=(FDBK)
*
*    UNRECOVERABLE PHYSICAL ERROR.
*
*        *ERROR* PHYSICAL ERROR READING HSM MCDS.
*                KEY = 'DATASET.NAME'
*                FEEDBACK CODE = X'00000000'.
*                SYNAD ERROR MESSAGE.
*
*        MVC   ERR#KEY+20(44),DSNAME2 COPY DATASET NAME
*        CALL  $CHGHEX,(ERR#FBC+31,PHY#AREA,F4),VL
*
*    COPY PORTION OF SYNAD ERROR MESSAGE.
*
         MVC   ERR#SYN+13(116),PHY#MSG+12
*
*    OUTPUT ERROR MESSAGES.
*
*        CALL  $CHGERR,(MCDS02,ERR#KEY,ERR#FBC,ERR#SYN),VL
*
*    SET THE RETURN CODE TO 4.
*
         LA    R15,NORECORD        SET RETURN CODE
         ST    R15,RETCODE         STORE RETURN CODE
*
*    RETURN TO VSAM.
*
PHY#EXIT EQU   *
         LM    R0,R15,ERRSAVE+4    RESTORE REGISTERS
         BR    R14                 RETURN TO VSAM
         EJECT
***********************************************************************
*                                                                     *
*    DATA SECTION.                                                    *
*                                                                     *
***********************************************************************
         SPACE 3
*
*    REGISTER SAVE AREA.
*
         SPACE
MCDSAVE  DC    C'SAVE'
         DC    17F'-1'
         SPACE 3
*
*    REGISTER SAFE STORE WHILE PROCESSING LOGICAL AND PHYSICAL ERRORS.
*
         SPACE
ERRSAVE  DC    C'REGS'
         DC    16F'-1'
         SPACE 3
*
*    SAVE AREA FOR SHOWCB MACRO IN LOGICAL AND PHYSICAL ERROR EXITS.
*
         SPACE
SHOWSAVE DC    C'SHOW'
         DC    17F'-1'
         SPACE 3
*
*    RETURN CODE.
*
         SPACE
RETCODE  DS    F
         SPACE 3
*
*    LENGTHS USED BY $CHGHEX.
*
         SPACE
F4       DC    F'4'
         EJECT
*
*    CONTROL BLOCKS TO READ AND PROCESS RECORDS FROM THE HSM MASTER
*    CONTROL DATASET.
*
         SPACE 3
*
*    ACB TO READ HSM MASTER CONTROL DATA SET.
*
         SPACE 1
         PRINT ON,NOGEN
MCDS     ACB   AM=VSAM,                                                *
               BUFND=2,                                                *
               BUFNI=1,                                                *
               DDNAME=MCDS,                                            *
               EXLST=EXTNAMES,                                         *
               MACRF=(KEY,DIR),                                        *
               STRNO=1
         SPACE 3
*
*    RETRIEVE MCA RECORD FROM THE DATA SET.
*
         SPACE
GETMCA   RPL   ACB=MCDS,                                               *
               AM=VSAM,                                                *
               AREA=MCABUFF,                                           *
               AREALEN=4,                                              *
               ARG=DSNAME2,                                            *
               MSGAREA=PHY#MSG,                                        *
               MSGLEN=128,                                             *
               OPTCD=(KEY,DIR,FKS,LOC)
         SPACE 3
*
*    RETRIEVE MCD RECORD FROM THE DATA SET.
*
         SPACE
GETMCD   RPL   ACB=MCDS,                                               *
               AM=VSAM,                                                *
               AREA=MCDBUFF,                                           *
               AREALEN=4,                                              *
               ARG=DSNAME2,                                            *
               MSGAREA=PHY#MSG,                                        *
               MSGLEN=128,                                             *
               OPTCD=(KEY,DIR,FKS,LOC)
         SPACE 3
*
*    DEFINITION OF ERROR EXITS.
*
         SPACE
EXTNAMES EXLST AM=VSAM,                                                *
               LERAD=(LOG#ERR,A),                                      *
               SYNAD=(PHY#ERR,A)
         SPACE 3
*
*    ADDRESSES OF MCA AND MCD RECORDS.
*
         ENTRY MCDBUFF
         SPACE
MCABUFF  DC    A(0)
MCDBUFF  DC    A(0)
         SPACE 3
*
*    ADDRESSES USED BY SHOWCB TO RETRIEVE FEEDBACK CODE.
*
         SPACE
LOG#AREA DS    F
PHY#AREA DS    F
         SPACE 3
*
*    KEYS OF RECORDS TO BE RETREIVED.
*
         SPACE
DSNAME2  DC    CL44' '
         SPACE 3
*
*    PHYSICAL ERROR MESSAGE AREA.
*
         SPACE
PHY#MSG  DS    0H
         DS    CL128
         EJECT
*
*    OUTPUT ERROR MESSAGES.
*
         SPACE 3
*ERR#FBC $MSG  '         FEEDBACK CODE = X''00000000''.'
*ERR#KEY $MSG  '         KEY = ''XXXXXXXX.XXXXXXXX.XXXXXXXX.XXXXXXXX.XX*
               XXXXXX''.'
ERR#SYN  DC    Y(129),Y(0)
         DC    CL125' '
*MCDS01  $MSG  '0<MCDS01> LOGICAL ERROR READING HSM MCDS.'
*MCDS02  $MSG  '0<MCDS02> PHYSICAL ERROR READING HSM MCDS.'
*MCDS03  $MSG  '0<MCDS03> AN ORPHAN MIGRATED DATASET WAS FOUND.  HSM HA*
               S NO RECORD OF ''XXXXXXX.XXXXXXXX.XXXXXXXX.XXXXXXXX.XXXX*
               XXXXX'''
*MCDS03B $MSG  '         ON VOLUME XXXXXX (XXX).'
         EJECT
*
*    LITERAL POOL.
*
         SPACE
         LTORG
         EJECT
*
*    DATA AREA DSECT.
*
         SPACE 3
*$CHGDA  DSECT
*        COPY  $CHGDA
         DC    FL1'24',CL9'$CHGDATA'
         DC    CL6'&SYSTIME'
         DC    CL8'&SYSDATE'
DTEMP    DS    D                   DOUBLEWORD WORK AREA
*
VTOCEXTS DS    0D                  VTOC EXTENTS FROM FORMAT 4 DSCB
VTOC#BEG DS    XL4                 STARTING CC HH
VTOC#END DS    XL4                 ENDING   CC HH
*
JOBNAME  DC    CL8'$CHARGER'       JOBNAME
VERSION  DC    CL4'02.00'          VERSION
SYSID    DS    CL4                 SYSTEM IDENTIFICATION
BINTIME  DS    F                   BINARY TIME OF DAY (1/100 SEC)
JULDATE  DS    PL4                 JULIAN DATE
*
*ETMADDR DS    A                   ADDRESS OF AREA TO HOLD VTOC
*ETMLEN  DS    F                   LENGTH  OF AREA TO HOLD VTOC
HI#DSCB  DS    A                   ADDRESS OF HIGHEST DSCB
VTOCFENC DS    A
*
UCBADDR2 DS    A                   UCB ADDRESS OF CURRENT DEVICE
DEVADDR  DS    A                   ADDRESS OF DEVICE TABLE ENTRY
DSCBADDR DS    A                   ADDRESS OF FORMAT 1 DSCB
MCDSADDR DS    A                   ADDRESS OF MCDS RECORD
*
DSTYPE   DS    CL1                 DATA SET TYPE (O=OS, V=VSAM)
*
TEMP#CNT DC    F'0'                NUMBER OF TEMP DATASETS ON VOLUME
VSAM#CNT DC    F'0'                NUMBER OF VSAM DATASETS ON VOLUME
PERM#CNT DC    F'0'                NUMBER OF PERM DATASETS ON VOLUME
HSM#CNT  DC    F'0'                NUMBER OF HSM  DATASETS ON VOLUME
*
TEMP#TRK DC    F'0'                NUMBER OF TEMP TRACKS   ON VOLUME
VSAM#TRK DC    F'0'                NUMBER OF VSAM TRACKS   ON VOLUME
PERM#TRK DC    F'0'                NUMBER OF PERM TRACKS   ON VOLUME
HSM#TRK  DC    F'0'                NUMBER OF HSM  TRACKS   ON VOLUME
*
S136#VOL DC    F'0'                NUMBER OF 136 RECORDS ON VOLUME
S136#TOT DC    F'0'                NUMBER OF 136 RECORDS IN TOTAL
*
TRK#DSN  DS    F                   NUMBER OF TRACKS IN DATASET
TRK#VOL  DS    F                   NUMBER OF TRACKS ON VOLUME
TRK#TOT  DS    F                   NUMBER OF TRACKS IN TOTAL
*
ERR#LC   DC    H'65'               'ERROR' LINE COUNT
ERR#MLC  DC    H'64'               'ERROR' LINES PER PAGE
ERR#PAGE DC    H'0'                'ERROR' PAGE COUNT
*
RPT#LC   DC    H'65'               'REPORT' LINE COUNT
RPT#MLC  DC    H'64'               'REPORT' LINES PER PAGE
RPT#PAGE DC    H'0'                'REPORT' PAGE COUNT
*
*    DEVICE TABLE.  AN ENTRY EXITS FOR EACH VALID DASD DEVICE.
*
DEV#CNT  DC    H'2'                NO. OF VALID DASD DEVICES
DEV#ELN  DC    H'24'               LENGTH OF EACH ENTRY
*
*              DEV             TRK   DSCB   BYTES   UNIT
*              TYPE            /CYL  /TRK   /TRK    NAME
*
DEV#TAB  DS    0F
         DC    X'0B',X'000000',F'30',F'47',F'19069',CL8'3350'
         DC    X'0E',X'000000',F'15',F'53',F'47476',CL8'3380'
         DC    X'0F',X'000000',F'15',F'53',F'56664',CL8'3390'
*
         ENTRY FLAG
FLAG     DC    XL1'40'             FLAG BYTE                        RH
FLAGINC  EQU   X'80'               INCLUDE VOLUMES
FLAGEXC  EQU   X'40'               EXCLUDE VOLUMES
FLAGEXP  EQU   X'20'               EXPAND HSM MIGRATED DATASETS     RH
FLAGTRUE EQU   X'10'               OUTPUT DS TRUE NAME (HSM MIG DS) SS
*
KEYCOUNT DC    F'3'               CURRENT NUMBER OF KEYWORD ENTRIES RH
KEYLENG  DC    F'8'                LENGTH OF ONE KEYWORD ENTRY
KEYLSIZE DC    F'200'              MAXIMUM NUMBER OF KEYWORD ENTRIES
KEYWSIZE DC    F'1200'             LENGTH OF AREA TO HOLD KEYWORDS
KEYLIST  DS    0F                  KEYWORD ENTRIES                  RH
         DC    A(KEYWORD1)        DEFAULT KEYWORD ENTRY             RH
         DC    X'07'              DEFAULT KEYWORD LTH               RH
         DC    X'01'              DEFAULT KEYWORD POSITION          RH
         DC    X'0001'            DEFAULT KEYWORD CARD NUMBER       RH
         DC    A(KEYWORD2)        DEFAULT KEYWORD ENTRY             RH
         DC    X'03'              DEFAULT KEYWORD LTH               RH
         DC    X'09'              DEFAULT KEYWORD POSITION          RH
         DC    X'0001'            DEFAULT KEYWORD CARD NUMBER       RH
         DC    A(KEYWORD3)        DEFAULT KEYWORD ENTRY             RH
         DC    X'03'              DEFAULT KEYWORD LTH               RH
         DC    X'0D'              DEFAULT KEYWORD POSITION          RH
         DC    X'0001'            DEFAULT KEYWORD CARD NUMBER       RH
KEYDEFS  EQU   (*-KEYLIST)        NUMBER OF DEFAULTS                RH
         DS    (400-(KEYDEFS/4))F MAKE UP 400 KEYWORD ENTRIES       RH
KEYWORDS DS    0CL1200             KEYWORDS                         RH
KEYWORD1 DC    CL6'EXCLUDE'       DEFAULT KEYWORD 1                 RH
KEYWORD2 DC    CL3'OLD'           DEFAULT KEYWORD 2                 RH
KEYWORD3 DC    CL3'SMS'           DEFAULT KEYWORD 3                 RH
         DS    CL(1200-(*-KEYWORDS)) REST OF KEYWORDS               RH
         SPACE 2
         EJECT
*
*    DSECT TO MAP MCA (MIGRATION CONTROL DATASET ALIAS) RECORD
*
MCA      DSECT
MCAKEY   DS    CL44                MCA KEY (DSNAME PADDED WITH BLANKS)
MCAHDR   DS    CL20                HEADER
MCAINTTP DS    CL1                 RECALL INTERCEPT TYPE
MCAVSATP DS    CL1                 VSAM ASSOCIATION TYPE
         DS    CL2                 RESERVED
MCAINTNM DS    CL44                MCD KEY
         EJECT
*
*    DSECT TO MAP MCD (MIGRATION CONTROL DATASET) RECORD
*    SEE  HSM  DIAGNOSIS REFERENCE, VOL 2, LY35-0077
*
         SPACE
MCD      DSECT
MCDKEY   DS    CL44                MCD KEY (DSNAME PADDED WITH BLANKS)
MCDHDR   DS    0CL20               HEADER
MCDLEN   DS    CL2                 LENGTH OF RECORD
MCDTYPE  DS    CL1                 RECORD TYPE
         DS    CL17                REST OF HEADER
*
*                       THE REST OF THIS LAYOUT IS FOR A TYPE D RECORD
*
MCDVSN   DS    CL6                 VOLSER OF MIGRATION VOLUME
MCDFLGS  DS    XL2                 FLAGS
MCDFASN  EQU   X'80'                   MIGRATED COPY EXISTS
MCDFMIG  EQU   X'40'                   DATASET IS TO BE MIGRATED
MCDFNOMG EQU   X'20'                   DATASET RETAINED FROM MIGRATION
MCDFDEL  EQU   X'10'                   DATASET WAS DELETED
MCDFSDP  EQU   X'08'                   DATASET IN VSAM SMALL-PACKING
MCDFL2   EQU   X'04'                   DATASET IS ON LEVEL 2
MCDFNSCR EQU   X'02'                   DS RECALLED, BUT NOT SCRATCHED
MCDJES3  EQU   X'01'                   PROCESSED DURING HSM JES3 SETUP
MCDFSMVL EQU   X'04'                   SPACE MNGT FLAGS ARE VALID
MCDFDUMD EQU   X'02'                   DUMMY RECORD
MCDFR3   EQU   X'01'                   RECORD CREATED IN RELEASE 3
MCDCOMPR DS    XL1                 PERCENT OF SPACE SAVED
         DS    CL3                 RESERVED
MCDDLC   DS    XL4                 DATE DATASET CREATED
MCDTLR   DS    XL4                 TIME DATASET LAST USED
MCDDLR   DS    XL4                 DATE DATASET LAST REFERENCED
MCDTLU   DS    XL4                 TIME VSAM DATASET LAST UPDATED
MCDDLU   DS    XL4                 DATE VSAM DATASET LAST UPDATED
MCDTMIG  DS    XL4                 TIME DATASET WAS MIGRATED
MCDDMIG  DS    XL4                 DATE DATASET WAS MIGRATED
MCDDSORG DS    XL2                 DATASET ORGANIZATION
MCDBLKSZ DS    XL2                 MAX BLOCKSIZE
MCDKEYLN DS    XL1                 KEY LENGTH
MCDRECFM DS    XL1                 RECORD FORMAT
MCDRFTYP EQU   X'C0'                   F, V, OR B FORMAT
MCDRFTO  EQU   X'20'                   TRACK OVERFLOW
MCDDSIND DS    XL1                 DATASET INDICATORS FROM FMT 1 DSCB
MCDFRACF EQU   X'40'                   RACF PROTECTED
MCDFSCTY EQU   X'10'                   PASSWORD PROTECTED
MCDFWSEC EQU   X'04'                   WRITE PASSWORD PROTECTED
MCDFCHNG EQU   X'02'                   DATASET OPENED FOR UPDATE
MCDHID   DS    XL1                 ID OF PROCESSOR USING RECORD
MCDSIZE  DS    XL4                 SIZE, IN TRACKS,    ON USER'S VOL
MCDSIZEB DS    XL4                 SIZE, IN BYTES,     ON USER'S VOL
MCDCSZ   DS    XL4                 SIZE, IN 2K BLOCKS, ON MIGRATION VOL
MCDNMIG  DS    XL2                 NO. TIMES DATASET MIGRATED
MCDDAYS  DS    XL2                 NO. DAYS BEFORE DS ELIGIBLE FOR MIG
MCDFRVSN DS    CL6                 VOLSER OF PRIMARY VOL BEFORE MIG
         DS    XL1                 RESERVED
MCDMCL43 DS    XL1                 KEY FOR MCL RECORD
MCDCTID  DS    XL4                 COMPACTION TABLE ID
MCDUCBTY DS    XL4                 DEVICE TYPE OF PRIMARY VOL
MCDTRES  DS    XL4                 TIME DATASET WAS RECALLED OR DELETED
MCDDRES  DS    XL4                 DATE DATASET WAS RECALLED OR DELETED
MCDMDEVT DS    XL4                 DEVICE TYPE OF MIGRATION VOL
MCDJDAYS DS    XL1                 DEFAULT NO. DAYS TO DELAY MIGRATION
MCDJDATE DS    XL3                 LAST DATE HSM WILL DELAY MIGRATION
MCDJVEXD DS    XL3                 LAST DATE HSM WILL HOLD VOLSERS
MCDPDEP  DS    XL1                 DEFINE POOL
MCDJCT   DS    XL1                 NO. VOL ELIGIBLE FOR RECALL
MCDJVOLS DS    XL50                5 VOLUMES ELIGIBLE FOR RECALL
MCDEXPDT DS    XL4                 DATASET EXPIRATION DATE
MCDMCANM DS    CL44                KEY TO MCA RECORD
         EJECT
*
*    MISCELLANEOUS DSECTS.
*
         SPACE 3
         PRINT ON,NOGEN
         CVT   DSECT=YES
         SPACE 3
         IEESMCA
         SPACE 3
         DCBD  DSORG=PS
$DYNAREA DSECT
DSCB#CHR DS    XL5
DSCB#KDL DS    XL3
DSCB     DS    XL140
         ORG   DSCB
        IECSDSL1 (1)
         ORG   DSCB
        IECSDSL1 (2)
         ORG   DSCB
        IECSDSL1 (3)
         ORG   DSCB+44
        IECSDSL1 (4)
         ORG   DSCB
        IECSDSL1 (5)
         ORG   DSCB
        IECSDSL1 (6)
$DYNSIZE EQU   *-$DYNAREA
         SPACE 3
         IEFUCBOB
         SPACE 1
 TITLE 'READ CATALOG WITH IDCAMS'
*
*/*
***********************************************************************
*                                                                     *
*             MODULE NAME = CALLIDC                                   *
*                                                                     *
*             DESCRIPTIVE NAME =  VRH SUPPLIED ROUTINE TO IVOKE       *
*                IDCAMS TO GET VOLSERS FROM THE CATALOG FOR A         *
*                DATASET.                                             *
*                                                                     *
*                 REGISTER CONVENTIONS = STANDARD CONVENTIONS.        *
*                    REGISTERS 0 - 2   = WORK REGISTERS               *
*                    REGISTERS 3 - 11  = UNUSED                       *
*                    REGISTERS 12      = BASE REGISTER                *
*                    REGISTER  13 -15  = STANDARD OS USAGE            *
*                                                                     *
*                ATTRIBUTES = PROBLEM STATE                           *
*                                                                     *
*        THE PARM PASSED TO CALLIDC IS THE LOCATE CAMLST              *
*                                                                     *
*    *        TCAM   LIST
*    TCAML    DS     0F
*    TCFLGS   DC     X'44000000'              TCAM ON DSN
*    TCAMDSN  DC     A(0)                     A(DSN)
*             DC     A(0)                     VOL POINTER
*             DC     A(TWORK)                 A(265 BYTE WORK AREA)
*             DS    0D                 PUT ON DOUBLE WORD BOUNDARY
*    TWORK    DS     0CL265
*    VOLCNT   DC     H'0'                     VOL COUNT
*    DEVTYP   DC     XL4'00'                  DEVICE TYPE
*    TVOL     DC     CL6' '                   FIRST VOL SER
*             DC     CL(265-(*-TWORK))' '     ROOM FOR 19 MORE...
*             DC     CL(12*30)' '      ROOM FOR 30 MORE BY IDCAMS....
*             DC     12X'FF'           END OF LIST...
***********************************************************************
*
*        ENTRY POINT
*
         DS    0H
CALLIDC  SECTION  GEN=YES,BASE=2
*        RDJFCB STEPCAT           READ STEPCAT JFCB
         ST    R1,PARMADDR        SAVE PARM ADDRESS
         L     R14,12(0,R1)       R14 -> AT TCAM WORK AREA
         ST    R14,VVDSADDR       SAVE IT'S ADDRESS
         ST    R14,VVDSREC        SAVE IT'S ADDRESS FOR IDCAMS EXIT
*        GETMAIN LU,LA=VVDSLTH,A=VVDSADDR GET CORE FOR IDCAMS DATA
*        L     R1,VVDSADDR        R1 ->  CORE
*        ST    R1,VVDSREC         SAVE IT'S ADDRESS FOR IDCAMS EXIT
*        L     R1,VVDSLTH         R1 = LTH OF AREA
*        LA    R1,0(0,R1)         CLEAR HI ORDER BYTE
*        SR    R0,R0              CLEAR R0
*        D     R0,=F'12'          R1 NOW = NBR VVDS AREAS
         LA    R1,50              R1 NOW = NBR VOLSER AREAS
         L     R14,=V(MAXVVDS)    R14 -> TO VVDS MAX CTR
         ST    R1,0(0,R14)        SAVE IT
         SPACE
         L     R1,PARMADDR        R1 ->  PARM, IF ANY
*        L     R1,0(0,R1)         R1 -> TO PARMS
*        LH    R2,0(0,R1)         R2 = PARM LTH
*        LTR   R2,R2              IS THERE A PARM ?
*        BZ    NEXTCAT            NO, GO READ CATIN
         L     R3,4(0,R1)         R3 -> TO TCAM DSN
         LR    R4,R3              R4 -> TO PARM
         SPACE 1
         AGO   .IDC1
         MVC   DSNAME,0(R3)       SET UP ATTACH NAME
         B     GETCAT             GO AROUND DC'S
         SPACE
SETNAME  MVC   DSNAME(0),2(R1)    SET UP ATTACH NAME
PARMADDR DS    F                  SET UP ATTACH NAME
         SPACE 2
*        TCAM   LIST
TCAML    DS     0F
TCFLGS   DC     X'44000000'              TCAM ON DSN
TCAMDSN  DC     A(DSNAME)                A(DSN)
         DC     A(0)                     VOL POINTER
         DC     A(TWORK)                 A(265 BYTE WORK AREA)
         DS    0D                 PUT ON DOUBLE WORD BOUNDARY
TWORK    DS     0CL265
VOLCNT   DC     H'0'                     VOL COUNT
DEVTYP   DC     XL4'00'                  DEVICE TYPE
TVOL     DC     CL6' '                   FIRST VOL SER
         DC     CL244' '                 REST OF TCAML DATA
         DC     CL12' '                  REST OF TCAML DATA
         SPACE 2
DSNAME   DC    CL44' '            DSNAME FOR LOCATE
         SPACE
GETCAT   DS    0H
         MVC   INCATLG,DSNAME     MOVE CATALOG NAME TO IDCAMS CTL STMT
.IDC1    ANOP
         MVC   INCATLG,0(R3)      SET UP DATASET NAME
         SPACE
NOSMCA   DS    0H                                                   RH
         LINK  EP=IDCAMS,PARAM=(OPTIONS,DNAMES,PGNO,IOLIST),VL=1
         ST    R15,IDCCODE        SAVE RC
         AGO   .IDC2
         LTR   R15,R15            WAS LINK OKAY
         BNZ   ABEND              NO, ABEND
         TM    SW,X'40'           END OF LINKS ?
         BZ    NOSMCA             NO,  DO ANOTHER ONE
         SPACE 1
         NI    SW,255-X'40'       CLEAR SWITCH
         L     R1,VVDSADDR        R1 -> TO 1ST VVDS
         ST    R1,VVDSREC         SAVE IT'S ADDRESS
         OPEN  (REPORT,(OUTPUT))
         TM    REPORT+48,X'10'    DID REPORT FILE OPEN ?            RH
         BZ    NEXTCAT            NO                                RH
*        HDUMP OUTDCB,0,0,NOTOPEN,OPEN   OPEN SYSOUT         DEBUG  RH
*        HDUMP OUTDCB,0,0,TITLE='BACK FROM IDCAMS'           DEBUG  RH
         SPACE 1
DYNLOOP  DS    0H
         L     R2,VVDSREC         R2 -> TO VVDS NAME
*                                 DUMP 44 BYTES AT R2        DEBUG  RH
*        HDUMP OUTDCB,R2,44,OPEN,OPEN                        DEBUG  RH
*        L     R3,DSSEJFCB        R3 -> TO JFCB              DEBUG  RH
*                                 DUMP 1024 BYTES AT JFCB    DEBUG  RH
*        HDUMP OUTDCB,R3,1024,OPEN,CLOSE                     DEBUG  RH
*        HDUMP OUTDCB,0,0,TITLE='DUMP REGS ONLY'             DEBUG  RH
         MVC   PRINT+1(6),6(R2)   MVC IT TO PRINT AREA
         PUT   REPORT,PRINT       PRINT IT
         LA    R2,12(0,R2)        R2 -> TO NEXT VVDS NAME
         ST    R2,VVDSREC         SAVE IT
         L     R1,VVDSCTR         R1 = NUMBER OF VVDS'S
*        LTR   R1,R1              ANY MORE ?
*        BZ    NEXTCAT            NO, GET NEXT CATALOG NAME
*        BZ    SVC3               NO
         BCTR  R1,0               -1
         ST    R1,VVDSCTR         SAVE NUMBER LEFT
         LTR   R1,R1              ANY MORE ?
         BZ    NEXTCAT            NO, GET NEXT CATALOG NAME
         SPACE 1
*        LA    R1,PARML           R1 -> TO DYNALLOC PARMS
*        L     R15,=V(DYNALOC)    R15 -> TO DYNALLOC CODE
*        BALR  R14,R15            GO FOR IT
         B     DYNLOOP            GO FOR NEXT VVDS
.IDC2    ANOP
         SPACE 1
***********************************************************************
*                                                                     *
*              RETURN TO CALLER WITH RC IN R15                        *
*                                                                     *
***********************************************************************
*
SVC3     DS    0H
ENDVTOC  SECEXIT BASE=2,GEN=YES   RETURN TO CALLER
         SPACE 3
*
PARMADDR DS    F                  SET UP ATTACH NAME
IDCCODE  DC    F'0'
OPTIONS  DC    H'0'
DNAMES   DC    H'0'
PGNO     DC    H'0'
IOLIST   DC    F'2'
         DC    A(ASYSIN)          CONTROLLER FOR SYSIN
         DC    A(INRTN)
         DC    A(AUDATA)
         DC    A(BSYSOUT)         CONTROLLER FOR SYSPRINT
         DC    A(OUTRTN)
         DC    A(BUDATA)
ASYSIN   DC    CL10'DDSYSIN'
BSYSOUT  DC    CL10'DDSYSPRINT'
AUDATA   DC    CL256' '
BUDATA   DC    CL256' '
         SPACE 5
* DYNALLOC PARAMETER LIST
         DS    0D
         ENTRY VVDSADDR
VVDSADDR DC    A(VVDSNAME)
VVDSLTH  DC    AL1(128)
         DC    AL3(600)           ROOM FOR 50 VOLSERS....
PARML2   DC    A(VVDSNAME)
         DC    XL1'80',AL3(VVDSVOL)
*
VVDSNAME DC    CL44' '
VVDSVOL  DC    CL6' '
*
         SPACE 1
*
*        ENTRY POINT
*
*NRTN    CSECT
*NRTN    AMODE 24
*NRTN    RMODE 24
INRTN    DS    0H
         USING *,R15      GET TEMP ADDRESSABILITY
         B     AROUND2            BRANCH AROUND DUMP TITLE
         DC    AL1(EYELTH2)       LTH OF EYE CATCHER
EYECAT2  DS    0C
         DC    C'INRTN  '         PROGRAM NAME
         DC    C' VERSION 2.0 '   VERSION
         DC    CL8'&SYSDATE'      DATE WRITTEN
         DC    CL6'&SYSTIME'      TIME WRITTEN
         DC    C'..MAKE 31-BIT COMPLIANT'    COMMENT
*        DC    C'..HANDLE AMODE 31 MODULES'    COMMENT
EYELTH2  EQU   *-EYECAT2          LTH OF EYE CATCHER
         SPACE 1
AROUND2  DS    0H
         LA    R1,0(0,R1)         CLEAR HI-ORDER BYTE FOR 31 BIT
         LA    R13,0(0,R13)       CLEAR HI-ORDER BYTE FOR 31 BIT
         BSM   R14,0              SAVE CURRENT AMODE
         STM   R14,R12,12(R13)    SAVE CALLERS REGS
         LR    R12,R15            SET OUR 1ST BASE REG
         DROP  R15                DROP TEMP BASE
         USING INRTN,R12,R11      SET OUR ADDRESSABILITY
         LA    R11,4095(0,R12)   LOAD SECOND BASE REGISTER
         LA    R11,1(0,R11)      LOAD SECOND BASE REGISTER
         SPACE 1
         LA    15,INSAVE
         ST    13,4(15)
         ST    15,8(13)
         LR    13,15
*        B     CONT2
         SPACE
*NSAVE   DC    18F'0'
         SPACE
CONT2    DS    0H
         L     R2,4(0,R1)         R2 -> TO IOFLAGS                  RH
         USING IOFLAGS,R2         SET BASE                          RH
         CLI   IOFLAG1,IOFOPEN    OPENING SYSIN?
*        BE    RETRC0             YES, SAY OPEN WAS OK
         BE    OPENIN             YES, SAY OPEN WAS OK
         CLI   IOFLAG1,IOFCLOS    CLOSE SYSIN?
         BE    RETRC0             YES, SAY CLOSE WAS OKAY
*        BE    CLOSIN             YES, GO CLOSE IT
         TM    IOFLAG1,IOFGET     DOES IDCAMS WANT A RECORD?
         BO    GIVEREC            YES, PASS IT A PRINT CMD
         B     RETRC12            IGNORE EVERYTHING ELSE
         SPACE 1
GIVEREC  DS    0H
         L     R3,8(0,R1)         R3 -> TO RECORD AREA
         USING IOINFO,R3          SET BASE                          RH
         L     R15,INREC          R15 -> TO PRINT CTL RECORD
         LH    R14,0(0,R15)       R14 = LTH OF RECORD
         ST    R14,IOIRECL        PASS IT TO IDCAMS
         LA    R1,2(0,R15)        R1 -> TO RECORD
         ST    R1,IOIREC          PASS IT TO IDCAMS
         AR    R15,R14            ADD REC LTH TO R15
         LA    R15,2(0,R15)       R15 -> TO NEXT REC
         ST    R15,INREC          SAVE ITS ADDRESS
         CLC   0(2,R1),ENDATA     END OF INPUT TO IDCAMS?
         BE    RETRC4             YES
         SPACE 1
RETRC0   DS    0H
         LA    R15,0              SAY  GET WAS OK                   RH
         B     RET2               GO BACK TO IDCAMS                 RH
RETRC4   DS    0H
         LA    R15,4              SAY  NO MORE SYSIN                RH
         B     RET2               GO BACK TO IDCAMS                 RH
         SPACE 1
CLOSIN   DS    0H
*        CLOSE INFILE             CLOSE SYSIN
*        B     RETRC0             RETURN
         SPACE 1
OPENIN   DS    0H
         LA    R15,INLTH          R15 -> TO 1ST INPUT AREA
         ST    R15,INREC          RESET INPUT REC ADDRESS
         B     RETRC0             GO SET RC AND RETURN
*        OPEN  (INFILE,(INPUT))
*        TM    INFILE+48,X'10'    DID REPORT FILE OPEN ?            RH
*        BO    RETRC0             YES                               RH
         SPACE 1
RETRC12  DS    0H
         LA    R15,12             SAY CALL WAS BAD                  RH
         B     RET2               GO BACK TO IDCAMS                 RH
         SPACE 1
RET      LA    15,0          GET RETURN CODE
         ORG   *-2
RETRC    DS    H             HALF WORD RETURN CODE, INITIALY ZERO
RET2     DS    0H
         L     R13,4(R13)         R13 -> TO CALLERS SAVE AREA
         L     R14,12(R13)        SET R14 TO CALLER'S R14
         LM    R0,R12,20(R13)     SET R0-R12 TO CALLERS REGS
*              GET INTO PROPER MODE AND GO BACK TO CALLER
         BSM   0,R14              RETURN TO CALLING PROGRAM
*
         SPACE 1
INSAVE   DC    18F'0'
*
INREC    DC    A(INLTH)
INLTH    DC    AL2(INCTLL)
INCTL    DC    C' LISTCAT ENT( '                        14
INCATLG  DC    CL44' '                                  44
         DC    C' ) VOL '                                7
         DC    CL(80-(*-INCTL))'  '                     80 LONG...
INCTLL   EQU   *-INCTL
*
INLTH2   DC    AL2(2)
ENDATA   DC    C'/*'
         SPACE 1
         AGO   .IDC3
INFILE   DCB   DSORG=PS,DDNAME=CATIN,LRECL=80,RECFM=FB,             XXXX
               MACRF=(GM),EODAD=SVC3
STEPCAT  DCB   DSORG=PS,DDNAME=STEPCAT,LRECL=80,RECFM=FB,           XXXX
               MACRF=(GM),BLKSIZE=80,EXLST=JFCBADD
         DS    0F
         DC    C'JFCB'            KEEP JFCB AT REPORT+352           RH1
JFCBDSNM DS    0C
JFCB     DC    CL176' '
*        ORG   JFCB               BACK TO START OF JFCB
*        IEFJFCBN                 GEN JFCB LABELS
JFCBADD  DC    X'87'              JFCB ADDRESS                      RH1
         DC    AL3(JFCB)          *                                 RH1
         EJECT
.IDC3    ANOP
         DROP  R12,R11            DROP OUR BASE
*
*        ENTRY POINT
*
*UTRTN   CSECT
*UTRTN   AMODE 24
*UTRTN   RMODE 24
OUTRTN   DS    0H
         USING *,R15      GET TEMP ADDRESSABILITY
         B     AROUND3            BRANCH AROUND DUMP TITLE
         DC    AL1(EYELTH3)       LTH OF EYE CATCHER
EYECAT3  DS    0C
         DC    C'OUTRTN '         PROGRAM NAME
         DC    C' VERSION 2.0 '   VERSION
         DC    CL8'&SYSDATE'      DATE WRITTEN
         DC    CL6'&SYSTIME'      TIME WRITTEN
         DC    C'..MAKE 31-BIT COMPLIANT'    COMMENT
*        DC    C'..HANDLE AMODE 31 MODULES'    COMMENT
EYELTH3  EQU   *-EYECAT3          LTH OF EYE CATCHER
         SPACE 1
AROUND3  DS    0H
         LA    R1,0(0,R1)         CLEAR HI-ORDER BYTE FOR 31 BIT
         LA    R13,0(0,R13)       CLEAR HI-ORDER BYTE FOR 31 BIT
         BSM   R14,0              SAVE CURRENT AMODE
         STM   R14,R12,12(R13)    SAVE CALLERS REGS
         LR    R12,R15            SET OUR 1ST BASE REG
         DROP  R15                DROP TEMP BASE
         USING OUTRTN,R12,R11     SET OUR ADDRESSABILITY
         LA    R11,4095(0,R12)   LOAD SECOND BASE REGISTER
         LA    R11,1(0,R11)      LOAD SECOND BASE REGISTER
         LA    15,OUTSAVE
         ST    13,4(15)
         ST    15,8(13)
         LR    13,15
         SPACE
CONT3    DS    0H
         L     R2,4(0,R1)         R2 -> TO IOFLAGS                  RH
         USING IOFLAGS,R2         SET BASE                          RH
         CLI   IOFLAG1,IOFOPEN    OPENING SYSPRINT ?
         BE    OPENSYS            YES, SAY OPEN WAS OK
         CLI   IOFLAG1,IOFCLOS    CLOSE SYSPRINT ?
         BE    CLOSOUT            YES, GO CLOSE IT
         TM    IOFLAG1,IOFPUT     DOES IDCAMS HAVE A RECORD FOR US?
         BO    GETREC             YES, GO GET IT
         B     OUTRC12            IGNORE EVERYTHING ELSE
         SPACE 1
CLOSOUT  DS    0H
*        CLOSE REPORT             CLOSE SYSPRINT
         OI    SW,X'40'           SAY END OF CALLS
         B     OUTRC0             RETURN
*        B     OUTRC12            RETURN
         SPACE 1
GETREC   DS    0H
         L     R3,8(0,R1)         R3 -> TO RECORD AREA
         USING IOINFO,R3          SET BASE                          RH
         L     R5,IOIREC          R5 -> TO RECORD FROM IDCAMS
         L     R4,IOIRECL         R4 = LTH OF RECORD
         SPACE 1
CHKLTH   CH    R4,=H'133'         LTH OVER 133?
         BL    LTHOK              NO
         MVC   PRINT,0(R5)        MOVE 133 BYTES
         LA    R5,133(0,R5)       R5 -> TO NEXT 133 BYTES
         SH    R4,=H'133'         R4 = LTH LEFT
         B     PUTITI             PRINT IT
         SPACE 1
LTHOK    DS    0H
         BCTR  R4,0               -1 FOR HEX LTH
         STC   R4,PUTLTH+1        SET LTH
PUTLTH   MVC   PRINT(0),0(R5)     MOVE DATA
         SR    R4,R4              R4=0
         SPACE 1
PUTITI   DS    0H
*        PUT   REPORT,PRINT       PRINT IT
         LA    R14,PRINT+1        R14 -> TO DATA AFTER CC
         LA    R15,20             R15 = NBR CHARS TO CHECK
*
PUTIT2I  DS    0H
         CLI   0(R14),C' '        FOUND NON BLANK?
         BNE   PUTIT4I            YES
         LA    R14,1(0,R14)       NO, R14 -> AT NEXT BYTE
         BCT   R15,PUTIT2I        CHECK MAX CHARS
         B     ENDPUT             MUST BE A BLANK LINE....
*
PUTIT4I  DS    0H
         CLC   =C'VOLSER---',0(R14)  DO WE WANT THIS RECORD?
         BNE   ENDPUT             NO
*
*    ONCE WE FIND THE VOL INFO IN THE IDCAMS OUTPUT,
*    IT SHOULD LOOK LIKE THIS.....
*
*    VOLSER------------B16038     DEVTYPE------X'78048081'
*
*    THE DEVTYPE HAS TO BE CONVERTED TO HEX
*
*VOLREC  DSECT
*        DS    CL18               JUNK BEFORE VOLSER...
*IDCVOL  DS    CL6                THE VOLSER
*        DS    CL20               JUNK BEFORE THE DEVTYPE...
*IDCDEV  DS    CL8                THE VOLSER DEVTYPE IN DECIMAL
*
         USING VOLREC,R14         SET VOLSER RECORD BASE
         PACK  PACKDEV(5),IDCDEV(9)  PACK DEVTYPE TO MAKE IT HEX...
*
*              NOW SET UP PSEUDO LOCATE WORK AREA....
*
GOTVVDS  DS    0H
         L     R6,VVDSCTR         R6 = VVDS COUNTER
         LA    R6,1(0,R6)         ADD 1 TO R6
         ST    R6,VVDSCTR         SAVE IT
         L     R1,=V(VVDSADDR)    R1 -> A(FIRST VOLSER ENTRY)
         L     R1,0(0,R1)         R1 ->   FIRST VOLSER ENTRY
         C     R6,MAXVVDS         MORE THAN MAX VVDS RECORDS?
         BNH   GOTVVDS2           NO
         STC   R6,0(0,R1)         COUNT ALL VOLS
         B     OUTRC0             GO GET THE NEXT RECORD
*        MVI   0(R1),X'FF'        SAY TOO MANY VOLSERS.....
*        B     OUTRC12            YES, END OF IDCAMS
         SPACE 1
*        PUT   REPORT,PRINT       PRINT IT
         SPACE 1
*
GOTVVDS2 DS    0H
         STH   R6,0(0,R1)         SET NBR ENTRIES
*
         L     R6,VVDSREC         R6 -> TO WHERE VVDS NAME IS SAVED
         MVC   0(2,R6),=X'0001'   SET COUNT TO 1
         MVC   2(4,R6),PACKDEV    SET DEVTYPE
         MVC   6(6,R6),IDCVOL     SET VOLSER
         DROP  R14                DROP VOLSER RECORD BASE
         LA    R6,12(0,R6)        ADD 12 TO R6
         ST    R6,VVDSREC         SAVE IT
*
*        L     R6,VVDSCTR         R6 = VVDS COUNTER
*        LA    R6,1(0,R6)         ADD 1 TO R6
*        ST    R6,VVDSCTR         SAVE IT
*        L     R1,=V(VVDSADDR)    R1 -> A(FIRST VOLSER ENTRY)
*        L     R1,0(0,R1)         R1 ->   FIRST VOLSER ENTRY
*        STH   R6,0(0,R1)         SET NBR ENTRIES
*        C     R6,MAXVVDS         MORE THAN MAX VVDS RECORDS?
*        BNH   ENDPUT             NO
*        MVI   0(R1),X'FF'        SAY TOO MANY VOLSERS.....
*        B     OUTRC12            YES, END OF IDCAMS
*        SPACE 1
*        PUT   REPORT,PRINT       PRINT IT
         SPACE 1
ENDPUT   DS    0H
         MVI   PRINT,C' '         CLEAR PRINT LINE
         MVC   PRINT+1(132),PRINT ''
         LTR   R4,R4              ANY LEFT?
         BP    CHKLTH             YES, GO PRINT IT
         SPACE 1
         B     OUTRC0             GO GET THE NEXT RECORD
         SPACE 1
OPENSYS  DS    0H
*        OPEN  (REPORT,(OUTPUT))
*        TM    REPORT+48,X'10'    DID REPORT FILE OPEN ?            RH
*        BZ    OUTRC12            NO                                RH
         SPACE 1
OUTRC0   DS    0H
         LA    R15,0              SAY  GET WAS OK                   RH
         B     RET4               GO BACK TO IDCAMS                 RH
         SPACE 1
OUTRC12  DS    0H
         LA    R15,12             SAY CALL WAS BAD                  RH
         B     RET4               GO BACK TO IDCAMS                 RH
         SPACE 1
RET3     LA    15,0          GET RETURN CODE
         ORG   *-2
RETRC2   DS    H             HALF WORD RETURN CODE, INITIALY ZERO
RET4     DS    0H
         L     R13,4(R13)         R13 -> TO CALLERS SAVE AREA
         L     R14,12(R13)        SET R14 TO CALLER'S R14
         LM    R0,R12,20(R13)     SET R0-R12 TO CALLERS REGS
*              GET INTO PROPER MODE AND GO BACK TO CALLER
         BSM   0,R14              RETURN TO CALLING PROGRAM
*
OUTSAVE  DC    18A(0)
PACKDEV  DC    PL5'0'
         SPACE 1
*        AGO   .IDC4
*REPORT  DCB   DSORG=PS,DDNAME=IDCPRINT,LRECL=133,RECFM=FBA,        XXXX
               MACRF=(PM),BLKSIZE=133
         SPACE 1
SW       DC    X'00'
PRINT    DC    CL133' '
VVDSCTR  DC    F'0'
         ENTRY MAXVVDS
MAXVVDS  DC    A(1)
VVDSREC  DC    A(VVDSREC1)
VVDSREC1 DC    CL44' '
*        DC    19CL44' '
         LTORG
IOFLAGS  DSECT
IOFLAG1  DS    X
IOFOPEN  EQU   X'00'
IOFCLOS  EQU   X'04'
IOFGET   EQU   X'08'
IOFPUT   EQU   X'0C'
IOFLAG2  DS    X
IOFIN    EQU   X'80'
IOFOUT   EQU   X'40'
IOFLAG3  DS    X
IOFLAG4  DS    X
         SPACE 1
IOINFO   DSECT
IOIREC   DS    F
IOIRECL  DS    F
         SPACE 1
*
*    ONCE WE FIND THE VOL INFO IN THE IDCAMS OUTPUT,
*    IT SHOULD LOOK LIKE THIS.....
*
*    VOLSER------------B16038     DEVTYPE------X'78048081'
*
VOLREC   DSECT
         DS    CL18               JUNK BEFORE VOLSER...
IDCVOL   DS    CL6                THE VOLSER
         DS    CL20               JUNK BEFORE THE DEVTYPE...
IDCDEV   DS    CL8                THE VOLSER DEVTYPE IN DECIMAL
         SPACE 1
         REQUATE SAVE=YES,REGS=YES,E=NO
         END
/*
//*
//LKED.SYSLMOD DD DSN=&&TEMP,UNIT=SYSDA,DISP=(NEW,PASS),
//   SPACE=(TRK,(15,5,5))
//LKED.SYSIN DD *
    ENTRY SPACE
    SETCODE AC(0)
    MODE    AMODE(31) RMODE(24)
    NAME  DSSUPER(R)
/*
//*
//*      ASSEMBLE HELP PANEL CODE....
//*
//HELP  EXEC HLASMCL,PARMC='ESD',PARML='LIST,LET,MAP,NCAL'
//ASM.SYSLIB DD DSN=SYS1.MACLIB,
//   DISP=SHR
//   DD DSN=SYS1.MODGEN,DISP=SHR
//ASM.SYSPRINT DD SYSOUT=*
//ASM.SYSIN DD *
SP       TITLE  'TSO SPACE COMMAND HELP PANEL'
HELPPAN  CSECT
HELPPAN  AMODE 31
HELPPAN  RMODE 24
         STM       R14,R12,12(R13)
         LR    R11,R15
         USING     HELPPAN,R11
         LR        PARMPTR,R1
*        L         R0,ALWORK
*ETWORK  GETMAIN   R,LV=(0)
*        XC        0(LWORK,R1),0(R1)
         LA    R1,HELPSAVE
         ST        R13,4(0,R1)
         ST        R1,8(R13)
         LR    R13,R1             R13 -> TO OUR SAVE AREA
         AGO   .HELP1
*        LR        WORKPTR,R1
*        USING     WORK,WORKPTR
         L         PARMPTR,0(PARMPTR)
         USING     SDV,PARMPTR
         L         R1,SDVADDR
         LH    R0,0(,R1)          R0 = LTH OF MSG
         LA    R1,2(,R1)          R1 -> TO MSG
         L     R3,=V(SW3)         R3 -> TO SW3 IN SPACE PGM
         TM    0(R3),SW380        IS THIS A BATCH RUN ?
         BZ    PUTIT              NO, GO DO A TPUT
         LR    R4,R0              R4 = LTH OF MSG
         BCTR  R4,0               R4 = HEX LTH OF MSG
         L     R3,=V(INFO1)       R3 -> TO MSG AREA
         EX    R4,MVCMSG          MOVE MSG TO PRINT LINE
*VCMSG   MVC   0(0,R3),0(R1)      MVC MSG TO PRINT LINE
         L     R1,=V(REPORT)      R1 -> TO REPORT DCB
         SPACE 1
PUTITP   DS    0H
         L     R0,=V(INFO1)       R0 -> TO REPORT PRINT LINE
         PUT   (1),(0)            OUTPUT THE MSG
         SPACE 1
         MVI   0(R3),C'0'         CHANGE CC TO DOUBLE SPACE
         MVI   1(R3),C' '         CLEAR PRINT LINE
         MVC   2(131,R3),1(R3)    *
         B     HELPEND            RETURN TO PLI PGM
         SPACE 1
PUTIT    DS    0H
         L     R3,=V(SWITCHWD)    R3 -> TO SWITCHWD IN SPACE PGM
         TM    0(R3),PRINTIT      PRINT TO A FILE?
         BZ    PUTIT2             NO, GO DO A TPUT
         LR    R4,R0              R4 = LTH OF MSG
         BCTR  R4,0               R4 = HEX LTH OF MSG
         L     R3,=V(INFO1)       R3 -> TO MSG AREA
         EX    R4,MVCMSG          MOVE MSG TO PRINT LINE
*VCMSG   MVC   0(0,R3),0(R1)      MVC MSG TO PRINT LINE
         L     R1,=V(PRTDCB)      R1 -> TO OUTPUT DCB
         B     PUTITP             GO PUT RECORD IN FILE
         SPACE 1
PUTIT2   DS    0H
         MVI   0(R1),C' '         REMOVE CC FOR TPUT
*        TPUT  (1),(0),R
*        AGO   .PUT1
*        LA    R2,L'DLINE         ENTIRE LINE LENGTH
*        LA    R2,4(0,R2)         ADD RDW LEN
*        STH   R2,RDWP
*        LA    R2,L'DLINE         ENTIRE LINE LENGTH
*        MVI   BUFFER,C' '        CLEAR BUFFER
*        MVC   BUFFER,+1(119),BUFFER    ....
         LR    R2,R0              R2 = LINE LTH
         BCTR  R2,R0              R2 = HEX LINE LTH
         EX    R2,MOVEDATA        SET UP PRINT LINE.
         LA    R2,5(0,R2)         ADD RDW LEN + 1 WE TOOK OFF
         STH   R2,RDWP
*        ST    R1,PUTMSG          SAVE A(LINE) IN PLI PGM....
*        MVC   BUFFER,DLINE
.HELP1   ANOP
         GTSIZE ,                 GET SCREEN SIZE
         LTR   R0,R0                    SEE IF A SCREEN
         BZ    NOCLR1             NOT, SO NO CLEAR
         STFSMODE ON,INITIAL=YES        TELL TSO/VTAM IN FULLSCRN
         TPUT  BLANKOUT,L'BLANKOUT,FULLSCR    BLANK OUT THE SCREEN
         STFSMODE OFF                   TELL TSO/VTAM OUT OF FULLSC N
         SPACE 1
NOCLR1   DS    0H
         L     R1,=V(ECB)         R1 -> TO ECB
         XC    0(4,R1),0(R1)      MAKE SURE IT'S CLEAR
         L     R1,=V(IOPLADD)     R1 -> TO IOPL LIST
         XC    0(4,R1),0(R1)      MAKE SURE IOPLUPT IS CLEAR....
         PUTLINE PARM=PUTHELP,OUTPUT=(HELPPG1,TERM,MULTLIN,DATA),      +
               MF=(E,(1))
*              MF=(E,IOPLADD)
         TGET  REPLY,80,EDIT,WAIT GET INPUT
         GTSIZE ,                 GET SCREEN SIZE
         LTR   R0,R0                    SEE IF A SCREEN
         BZ    NOCLR2             NOT, SO NO CLEAR
         STFSMODE ON,INITIAL=YES        TELL TSO/VTAM IN FULLSCRN
         TPUT  BLANKOUT,L'BLANKOUT,FULLSCR    BLANK OUT THE SCREEN
         STFSMODE OFF                   TELL TSO/VTAM OUT OF FULLSC N
         SPACE 1
NOCLR2   DS    0H
         L     R1,=V(ECB)         R1 -> TO ECB
         XC    0(4,R1),0(R1)      MAKE SURE IT'S CLEAR
         L     R1,=V(IOPLADD)     R1 -> TO IOPL LIST
         XC    0(4,R1),0(R1)      MAKE SURE IOPLUPT IS CLEAR....
         PUTLINE PARM=PUTHELP,OUTPUT=(HELPPG2,TERM,MULTLIN,DATA),      +
               MF=(E,(1))
*              MF=(E,IOPLADD)
         TGET  REPLY,80,EDIT,WAIT GET INPUT
.PUT1    ANOP
*        LR        R1,WORKPTR
*        L         R13,4(WORKPTR)
         SPACE 1
HELPEND  DS    0H
         L     R13,HELPSAVE+4
*        L         R0,ALWORK
*REEWORK FREEMAIN  R,LV=(0),A=(1)
         LM        R14,R12,12(R13)
         BR        R14
MOVEDATA MVC   BUFFER,0(R1)       SET UP PRINT LINE.
BLANKOUT DC    X'401140403C404000114040'    MESSAGE TO BLANK OUT SCREEN
         DS        0D
*LWORK   DC        AL1(0),AL3(LWORK)
HELPSAVE DS    9D
MVCMSG   MVC   0(0,R3),0(R1)      MVC MSG TO PRINT LINE
PUTHELP  PUTLINE MF=L
RDWP     DC    F'0'
REPLY    DC    CL80' '            TGET BUFFER
BUFFER   DS    CL120' '
*
*        NOTE  ... THE FOLLOWING PARMS ARE SET UP IN PL1 FORMAT
*                  FOR HELPPAN.
*
         DS    0H
*PUTMSG  DC    A(PUT1MSG)
*UT1MSG  DC    AL2(PUTLTH1)
*UTMSG1  DC    CL120' '
*UTLTH1  EQU   *-PUTMSG1
*        ENTRY ECB,IOPLADD
*ECB     DC    F'0'
*IOPLADD DS    4F
*
LITERALS LTORG
*
*    REGISTER EQUATES
PARMPTR  EQU   10
HELPMSG  DS    0C
*
*              PAGE 1
*
HELPPG1  DS    0A
P1L1     DC    A(P1L2)
         DC    AL2(L'L1P1+4),H'0'
*        DC    H'0'
L1P1     DC    C'THE DS COMMAND CAN BE USED TO DISPLAY OR PRINT'
P1L2     DC    A(P1L3)
*        DC    AL2(84)
*        DC    H'0'
         DC    AL2(L'L2P1+4),H'0'
L2P1     DC    C'DATA SET CHARACTERISTICS, CURRENT SPACE ALLOCATION'
P1L3     DC    A(P1L4)
         DC    AL2(L'L3P1+4),H'0'
L3P1     DC    C'AND USAGE, TOTALS, AND PERCENT CALCULATION FOR A'
P1L4     DC    A(P1L5)
         DC    AL2(L'L4P1+4),H'0'
L4P1     DC    C'SPECIFIED DATA SET OR GROUP OF DATA SETS AT THE'
P1L5     DC    A(P1L6)
         DC    AL2(L'L5P1+4),H'0'
L5P1     DC    C'TERMINAL, TO A SEQUENTIAL DATA SET, OR TO SYSPRINT'
P1L6     DC    A(P1L7)
         DC    AL2(L'L6P1+4),H'0'
L6P1     DC    C'IF THE DS COMMAND IS RUN IN BATCH.'
P1L7     DC    A(P1L8)
         DC    AL2(L'L7P1+4),H'0'
L7P1     DC    C' '
P1L8     DC    A(P1L9)
         DC    AL2(L'L8P1+4),H'0'
L8P1     DC    C'SYNTAX:'
P1L9     DC    A(P1L10)
         DC    AL2(L'L9P1+4),H'0'
L9P1     DC    C'DS ''SEARCH-KEY'' VOL(''VOL-SER-LIST''/''VOL-SER'')'
P1L10    DC    A(P1L11)
         DC    AL2(L'L10P1+4),H'0'
L10P1    DC    C' UNIT(''UNIT-NAME'') MAX(''NNNN'') PRINT(''DSNAME'')'
*10P1    DC    CL33'   UNIT(''UNIT-NAME'') MAX(''NNNN'') '
*        DC    CL47'PRINT(''DSNAME'')'
P1L11    DC    A(P1L12)
         DC    AL2(L'L11P1+4),H'0'
L11P1    DC    C'   TOTAL(YES/NO) NOLIST ALLOC(''DSN'')'
P1L12    DC    A(P1L13)
         DC    AL2(L'L12P1+4),H'0'
L12P1    DC    C' '
P1L13    DC    A(P1L14)
         DC    AL2(L'L13P1+4),H'0'
L13P1    DC    C'REQUIRED - NONE.'
P1L14    DC    A(P1L15)
         DC    AL2(L'L14P1+4),H'0'
L14P1    DC    C'DEFAULTS - ''SEARCH-KEY'' TO USER ID.'
P1L15    DC    A(P1L16)
         DC    AL2(L'L15P1+L'L15AP1+4),H'0'
*15P1    DC    C'   ''VOL-SER'' TO USERS HIGH-LEVEL-INDEX VOLUME.'
L15P1    DC    C'           ''VOL-SER'' TO USERS HIGH-LEVEL'
L15AP1   DC    C'-INDEX VOLUME.'
P1L16    DC    A(P1L17)
         DC    AL2(L'L16P1+4),H'0'
L16P1    DC    C'           ''UNIT-NAME'' TO ''USER'''
P1L17    DC    A(P1L18)
         DC    AL2(L'L17P1+4),H'0'
L17P1    DC    C'           ''NNNN'' TO 9999'
P1L18    DC    A(P1L19)
         DC    AL2(L'L18P1+4),H'0'
L18P1    DC    C'           ''DSNAME'' TO TERMINAL (NO FILE)'
P1L19    DC    A(P1L20)
         DC    AL2(L'L19P1+4),H'0'
L19P1    DC    C'            TOTAL(YES) IF SEARCH-KEY IS A DATA SET.'
P1L20    DC    A(P1L21)
*        DC    AL2(L'L20P1+4),H'0'
         DC    AL2(L'L20P1+L'L20AP1+4),H'0'
*20P1    DC    C' TOTAL(NO) IF SEARCH-KEY IS A HIGH LEVEL INDEX.'
L20P1    DC    C'            TOTAL(NO) IF SEARCH-KEY IS A HIGH '
L20AP1   DC    C'LEVEL INDEX.'
P1L21    DC    A(P1L22)
         DC    AL2(L'L21P1+4),H'0'
L21P1    DC    C'            LIST.'
P1L22    DC    A(P1L23)
         DC    AL2(L'L22P1+4),H'0'
L22P1    DC    C' '
P1L23    DC    A(P1L24)
         DC    AL2(L'L23P1+4),H'0'
L23P1    DC    C'ALIAS - NONE'
P1L24    DC    A(0)
         DC    AL2(L'L24P1+4),H'0'
L24P1    DC    C'*** PRESS ENTER TO CONTINUE...'
*        DC    C' '
*
*              PAGE 2
*
HELPPG2  DS    0A
P2L1     DC    A(P2L2)
*        DC    AL2(84)
*        DC    H'0'
         DC    AL2(L'L1P2+4),H'0'
L1P2     DC    C'TO RUN THE DS COMMAND IN BATCH, THE FOLLOWING JCL'
P2L2     DC    A(P2L3)
         DC    AL2(L'L2P2+4),H'0'
L2P2     DC    C'CAN BE USED :'
P2L3     DC    A(P2L4)
         DC    AL2(L'L3P2+4),H'0'
L3P2     DC    C' //       JOB (PIN,CHGNBR),...ETC.'
P2L4     DC    A(P2L5)
         DC    AL2(L'L4P2+4),H'0'
L4P2     DC    C' /*ROUTE PRINT R...      IF DESIRED'
P2L5     DC    A(P2L6)
         DC    AL2(L'L5P2+4),H'0'
L5P2     DC    C' //S0      EXEC  PGM=DS,PARM=''SEARCH-KEY'''
P2L6     DC    A(P2L7)
         DC    AL2(L'L6P2+4),H'0'
L6P2     DC    C' //SYSPRINT DD SYSOUT=*'
P2L7     DC    A(P2L8)
         DC    AL2(L'L7P2+4),H'0'
L7P2     DC    C' //'
P2L8     DC    A(P2L9)
         DC    AL2(L'L8P2+4),H'0'
L8P2     DC    C' OR '
P2L9     DC    A(P2L10)
         DC    AL2(L'L9P2+4),H'0'
L9P2     DC    C' //       JOB (PIN,CHGNBR),...ETC.'
P2L10    DC    A(P2L11)
         DC    AL2(L'L10P2+4),H'0'
L10P2    DC    C' /*ROUTE PRINT R...      IF DESIRED'
P2L11    DC    A(P2L12)
         DC    AL2(L'L11P2+4),H'0'
L11P2    DC    C' //S0    EXEC PGM=DS'
P2L12    DC    A(P2L13)
         DC    AL2(L'L12P2+4),H'0'
L12P2    DC    C' //SYSPRINT DD SYSOUT=*'
P2L13    DC    A(P2L14)
         DC    AL2(L'L13P2+4),H'0'
L13P2    DC    C' //SYSIN  DD  *'
P2L14    DC    A(P2L15)
         DC    AL2(L'L14P2+4),H'0'
L14P2    DC    C' HLI'
P2L15    DC    A(P2L16)
         DC    AL2(L'L15P2+4),H'0'
L15P2    DC    C' DSN'
P2L16    DC    A(P2L17)
         DC    AL2(L'L16P2+4),H'0'
L16P2    DC    C' HLI.INDEX.INDEX'
P2L17    DC    A(P2L18)
         DC    AL2(L'L17P2+4),H'0'
L17P2    DC    C' //'
P2L18    DC    A(P2L19)
         DC    AL2(L'L18P2+4),H'0'
L18P2    DC    C'WHEN RUN AS A BATCH JOB, THE SEARCH-KEY IS THE ONLY'
P2L19    DC    A(P2L20)
         DC    AL2(L'L19P2+4),H'0'
L19P2    DC    C'OPERAND THAT WILL BE RECOGNIZED.'
P2L20    DC    A(P2L21)
         DC    AL2(L'L20P2+4),H'0'
L20P2    DC    C' '
P2L21    DC    A(P2L22)
         DC    AL2(L'L21P2+4),H'0'
L21P2    DC    C'FOR DETAILED HELP, USE ''HELP DS'' COMMAND.'
P2L22    DC    A(0)
         DC    AL2(L'L22P2+4),H'0'
L22P2    DC    C'*** PRESS ENTER TO CONTINUE...'
*        DC    C'EOF'
SDV      DSECT
SDVADDR  DS        A
SDVMAXL  DS        H
SDVFLAG  DS        H
         SPACE 2
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         END   HELPPAN
/*
//*
//LKED.SYSLMOD DD DSN=&&TEMP,UNIT=SYSDA,DISP=(SHR,PASS),
//   SPACE=(TRK,(15,5,5))
//LKED.SYSIN DD *
    SETCODE AC(0)
    MODE    AMODE(31) RMODE(24)
    NAME  HELPPAN(R)
/*
//*
//*
//*DSSPART3   JOB (87944,799588),HALL.S1BL,MSGCLASS=A,
//*  PRTY=1,USER=RH87944,GROUP=SYS1,PASSWORD=*
//*ROUTE  PRINT  R7
//*
//*
//*    THIS VERSION USES OBTAIN SEARCH AND OBTAIN SEEK
//*    TO READ FORMAT 1 AND FORMAT 3 DSCBS IF A HLI IS
//*    SPECIFIED, OR EXCPS TO READ THE VTOC IF 'ALL.HLI'
//*    IS SPECIFIED.
//*
//*    MODIFIED DEC/87 TO HANDLE MIGRATED DATASET 'DSCBS'.
//*    MODIFIED NOV/89 TO HANDLE 3390'S IN VTCREAD.
//*
//*      JUL 31/93....ADDED CODE TO READ FORMAT 4 DSCB FOR A 'NEW'
//*                   DEVICE TO GET #DSCBS/TRK AND ADD TO TABLE
//*                   (DSCB+44=X'F4' AND DSCB+74=X'DSCBS/TRK')
//*
//PRINT EXEC PLIXCL,
//           COND=EVEN,
//           PARMC='MARGINS(2,72,1),LIST',CLASS='*',
//           PARML='LIST,LET,MAP,NCAL,SIZE=(1024K,512K)'
//*          PARML='LIST,LET,MAP,SIZE=(1024K,512K)'
//PLI.SYSIN DD *
 DSPACE:PROC(USERID,VOLSER,MAXDSN,PRINTDD,SWITCHES,MCDDSCB)
        OPTIONS(MAIN) REORDER;
 /*    *******************************************************  */
 /*    *   DSPACE : FORMATTING AND ACCUMULATION MODULE OF THE*  */
 /*    * TSO DSPACE COMMAND PROCESSOR.                       *  */
 /*    * INPUT: R1 POINTS TO 5 FULLWORD ADDRESSES OF SDV'S   *  */
 /*    *    1). SEARCH_KEY ,STRING FOR SELECTING DATA SETS   *  */
 /*    *    2). VOLSER , VOLUME SERIAL OF VOL TO BE SEARCHED *  */
 /*    *    3). MAXDSN , MAXIMUM NUMBER OF DATA SETS TO BE   *  */
 /*    *        PRINTED.                                     *  */
 /*    *    4). PRINTDD ,FILE NAME OF OUTPUT PRINT IF NOT    *  */
 /*    *        TERMINAL.                                    *  */
 /*    *    5). SWITCHES , 1 BYTE OF BIT SWITCHES DESCRIBING *  */
 /*    *        OPTIONS TO BE USED.                          *  */
 /*    * PROCESSING:                                         *  */
 /*    *     CALLS 'VTCREAD' FOR ALL VTOC I/O                *  */
 /*    *     CALLS 'TSOPUT' FOR ALL TERMINAL I/O             *  */
 /*    *                                                     *  */
 /*    * SWITCH FUNCTIONS:                                   *  */
 /*    *    BIT 1 ON) OUTPUT IS TO BE PRINTED ON FILE.       *  */
 /*    *    BIT 2 ON) TOTALS ARE TO BE PRINTED.              *  */
 /*    *    BIT 3 ON) PERCENTS ARE TO BE CALCULATED.         *  */
 /*    *    BIT 4 ON) DON'T ZERO OUT FIELDS BEFORE           *  */
 /*    *              ACCUMULATING.                          *  */
 /*    *    BIT 5 ON) DON'T PRINT DATA SET STATISTICS,       *  */
 /*    *              (AUTOMATICALLY CAUSES TOTALING)        *  */
 /*    *    BIT 6 ON) HIGH LEVEL INDEX BEING PROCESSED.      *  */
 /*    *    BIT 7 ON) PRINT HEADING ONLY.                    *  */
 /*    *    BIT 8 ON) PRINT TOTALS ONLY.                     *  */
 /*    *                                                     *  */
 /*    * OUTPUT :                                            *  */
 /*    *    LISTING TO TERMINAL OR PRINTER FILE.             *  */
 /*    *    TOTALS OVER ALL VOLUMES.                         *  */
 /*    *                                                     *  */
 /*    * PRESENT CALCULATIONS ARE BASED ON 19 TRACKS PER     *  */
 /*    * CYLINDER.                                           *  */
 /*    *                                                     *  */
 /*    *                                                     *  */
 /*    *                                                     *  */
 /*    *                                                     *  */
 /*    *                                                     *  */
 /*    *******************************************************  */
 DCL    MAXDSN CHAR(8) VAR,
        PRINTDD CHAR(8) VAR, SWITCHES CHAR(1) VAR,
        SW_ARRAY(8) BIT(1) BASED(SWPTR),PRINTR FILE PRINT STREAM,
        (TRACK_TOTAL,USED_TOTAL,TOTAL_EXT) STATIC FIXED BIN(31),
        TRK_PER_CYL FIXED BIN(31) INIT(30) STATIC,
        TOTDS STATIC FIXED BIN(31),
        DSNMAX FIXED BIN(15),
 /*     USERID CHAR(44) VAR, ULEN1 FIXED BIN(15) STATIC,            */
        USERID CHAR(44) VAR,
        ULEN1 FIXED BIN(15) STATIC,
        VOLSER CHAR(6),
        (DEC_PERC,DEC_FRAG) FIXED
            DEC(7,3),
        (DEC_USED,DEC_TOT,DEC_TRKS,DEC_EXT) FIXED
            DEC(7,0) ;

 DCL    MCDDSCB      CHAR(140) VAR ;  /* EXT ; */

 DCL    TSOPUT ENTRY(CHAR(120) VAR) EXT,
        LINE CHAR(120) VAR,
        VTCREAD
       ENTRY(FIXED BIN(31,0),CHAR(8),PTR,FIXED BIN(31,0),CHAR(44) VAR)
            EXTERNAL;
     /* ASM SUB TO READ VTOC - LIFTED FROM SPRLIST */
     /* AND MODIFIED TO BE CALLABLE FROM PL/1. */
 DCL BITDSCB(296) BIT(4) BASED(PDSCB),
     1 F1DSCB BASED(PDSCB),
       2 CCHHR       CHAR(5),
       2 MBB         CHAR(3),
       2 DSN         CHAR(44),
       2 FORMAT#     CHAR(1),
       2 DS1DSSN     CHAR(6),
       2 DS1VOLSQ    BIT(16),
       2 DS1CREDT,
         3 CREDT1       BIT(8),
         3 CREDT2      BIT(16),
       2 DS1EXPDT    CHAR(3),
       2 DS1NOEPV    BIT(8),
       2 DS1NOBDB    BIT(8),
       2 RESERVE1    CHAR(1),
               /*  2 DS1SYSCD    CHAR(10), */
               /*  2 DS1USEDT    FIXED DEC(5), */
       2 DS1SYSCD    CHAR(13),                      /*SU60*/
       2 DS1USEDT,                                  /*SU60*/
         3 USEDT1       BIT(8),                     /*SU60*/
         3 USEDT2      BIT(16),                     /*SU60*/
               /*  2 RESERVE2    CHAR(7), */
       2 RESERVE2    CHAR(4),                       /*SU60*/
       2 DS1DSORG(16)BIT(1),
       2 DS1RECFM(8) BIT(1),
       2 DS1OPTCD(8) BIT(1),
       2 DS1BLKL     FIXED BIN(15),
       2 DS1LRECL    FIXED BIN(15),
       2 DS1KEYL     BIT(8),
       2 DS1RKP      BIT(16),
       2 DS1DSIND(8) BIT(1),
       2 DS1SCALO(8) BIT(1),
       2 DS1SCAL2    BIT(24),
       2 DS1LSTAR,
         3 TT        BIT(16),
         3 R         BIT(8),
       2 DS1TRBAL    BIT(16),
       2 RESERVE3    CHAR(2),
       2 DS1EXT(3),
         3 EXTENT_TYPE BIT(8),
         3 SEQ_NUMBER  BIT(8),
         3 LCC         BIT(16),
         3 LHH         BIT(16),
         3 UCC         BIT(16),
         3 UHH         BIT(16),
       2 DS1PTRDS     CHAR(5),
     1 F1DSCB_OVERLAY BASED(PDSCB),
       2 XXX         CHAR(80),
       2 BINUSEDT,
         3 BINUSEDT_DATA   BIT(20),
         3 BINUSEDT_SIGN   BIT(4),
     1 F3DSCB BASED(PDSCB),
       2 SAME_AS_F1  CHAR(8),
       2 KEY03       CHAR(4),
       2 DS3EXTNT(4),
         3 EXTENT_TYPE BIT(8),
         3 SEQ_NUMBER  BIT(8),
         3 LCC         BIT(16),
         3 LHH         BIT(16),
         3 UCC         BIT(16),
         3 UHH         BIT(16),
       2 DS3FMTID    CHAR(1),
       2 DS3ADEXT(9),
         3 EXTENT_TYPE BIT(8),
         3 SEQ_NUMBER  BIT(8),
         3 LCC         BIT(16),
         3 LHH         BIT(16),
         3 UCC         BIT(16),
         3 UHH         BIT(16),
       2 DS3PTRDS     CHAR(5),
     1 DATA(DSNMAX) CTL,
       2 DSNAME      CHAR(44),
       2 TRACKS      FIXED BIN(31),
       2 CREDT       FIXED DEC(5),
       2 USEDT       FIXED DEC(5),
       2 F#          CHAR(1),
       2 KEY         CHAR(5),
       2 DSORG       CHAR(3),
       2 RECFM       CHAR(4) VAR,
       2 BLKL        FIXED BIN(15),
       2 LRECL       FIXED BIN(15),
       2 USED        FIXED BIN(15),
       2 NOEPV       FIXED BIN(15),
     1 FORMAT3(DSNMAX*2) CTL,
       2 F3KEY       CHAR(5),
       2 F3TRACKS    FIXED BIN(31);
 DCL (ENTRY_TYPE,ERROR_IND,NUMDS,NUMF3) FIXED BIN(31) STATIC,
     DDNAME CHAR(8),
     ENTRY_TYPE2 FIXED BIN(31) STATIC INIT(0),
     PDSCB PTR;
 /*    *******************************************************  */
 /*    *   DSPACE : MAIN CODE FOLLOWS.                       *  */
 /*    *******************************************************  */
 /*                                                             */
 ON ERROR BEGIN;
     LINE='0ERROR CONDITION IN FORMAT PGM OF SPACE';
 /*  IF SW_ARRAY(1) THEN PUT FILE(PRINTR) EDIT(LINE) (COL(1),A);    */
     CALL TSOPUT(LINE);
     GOTO END_S;
     END;
 ALLOC :ULEN1=LENGTH(USERID);
        DSNMAX=MAXDSN;
         IF DSNMAX<100 THEN DSNMAX=100;
        ALLOCATE DATA,FORMAT3;
        SWPTR=ADDR(SWITCHES);
 /*     IF SW_ARRAY(1) THEN DO;
  *         OPEN FILE(PRINTR) TITLE(PRINTDD) PAGESIZE(55);
  *
  *     END;
  */
 /*
  * ON ENDPAGE(PRINTR) BEGIN;
  *   IF  SW_ARRAY(6) THEN
  *     PUT FILE(PRINTR) SKIP(3)  EDIT('TSO SPACE ALLOCATION',
  *         ' AND USAGE LISTING FOR ',INDEX,' LEVEL ',
  *         USERID,'            ') (COL(1),SKIP,A,A,A,A,A,A);
  *   ELSE
  *     PUT FILE(PRINTR) SKIP(3)  EDIT('TSO SPACE ALLOCATION',
  *         ' AND USAGE LISTING FOR ',VOLSER,' AT ',
  *         USERID,' INDEX LEVEL') (COL(1),SKIP,A,A,A,A,A,A);
  *     END;
  */
 START:
     IF  VOLSER = 'MIGRAT' THEN PDSCB = ADDR(MCDDSCB) ;

     IF SUBSTR(USERID,1,4)  = 'ALL.' THEN GOTO START2;
     ENTRY_TYPE2 = 4 ;
     IF USERID = 'ALL.DSNAMES' THEN GOTO START2 ;
     ULEN1 = ULEN1-4 ;
     USERID = SUBSTR(USERID,5,ULEN1) ;

 START2 :
   IF SW_ARRAY(8) THEN GOTO TOTALS;    /* ONLY WANT TOTALS ?         */
        NUMDS,NUMF3=0;
 /*
  *           IF SW_ARRAY(1) THEN SIGNAL ENDPAGE(PRINTR);
  */
        IF  SW_ARRAY(4) THEN DO;     /* ZERO SOME FIELDS           */
           TOTDS=0;
                 TRACK_TOTAL=0;
                 USED_TOTAL=0;
                 TOTAL_EXT=0;
        END;

   IF SW_ARRAY(7) THEN DO;        /* PRINT HEADING                  */
        LINE=' ';
        PUT STRING(LINE)          EDIT('1TSO SPACE ALLOCATION',
            ' AND USAGE LISTING FOR INDEX LEVEL ',
            USERID) (A,A,A);
 /*     IF SW_ARRAY(1) THEN DO;
  *        SUBSTR(LINE,1,1) = ' ' ;
  *        PUT FILE(PRINTR) SKIP(3)  EDIT(LINE) (COL(1),A);
  *     END ;
  *     ELSE CALL TSOPUT(LINE);
  */
        CALL TSOPUT(LINE);

     IF  SW_ARRAY(5) THEN DO ;
        LINE=' ';
        PUT STRING(LINE)
            EDIT(' CREDT USEDT VOLSER DSO RCFM  BLK  REC TRKS',
           ' USED EX DATA SET') (A,A);
 /*     IF SW_ARRAY(1) THEN PUT FILE(PRINTR) EDIT(LINE) (COL(1),A);
  *     ELSE CALL TSOPUT(LINE);
  */
         CALL TSOPUT(LINE);
        GOTO END_S;
     END;
   END;                           /* END OF SW_ARRAY(7) CODE...     */

     TRACKS=0;
     F3TRACKS=0;
     DDNAME=VOLSER;
     ENTRY_TYPE=1 + ENTRY_TYPE2;
     IF  VOLSER = 'MIGRAT' THEN GOTO MCD1 ;

     CALL VTCREAD(ENTRY_TYPE,DDNAME,PDSCB,ERROR_IND,'OPEN'); /* OPEN */
     IF ERROR_IND=4 THEN GOTO END_S;
     IF ERROR_IND=8 THEN DO;
         PUT STRING(LINE) EDIT('0OPEN RETURN CODE=8 - DDNAME='||DDNAME
         ||' - CONTINUING') (A);
 /*      IF SW_ARRAY(1) THEN DO ;
  *            SUBSTR(LINE,1,1) = ' ' ;
  *            PUT FILE(PRINTR) EDIT(LINE) (COL(1),A);
  *                          END ;
  *      ELSE CALL TSOPUT(LINE);
  */
         CALL TSOPUT(LINE);
         GOTO STOP;
     END;                         /* END OF ERROR_IND=8             */

 MCD1 :
          TRK_PER_CYL = ENTRY_TYPE;   /*SET TRKS/CYL FROM RDVTOC    */

 GET_DSCB:
          ENTRY_TYPE  = 0 + ENTRY_TYPE2 ;      /* READ */
     IF  VOLSER = 'MIGRAT' THEN GOTO MCD2 ;

          CALL VTCREAD(ENTRY_TYPE,DDNAME,PDSCB,ERROR_IND,USERID);
     IF ERROR_IND=4 THEN GOTO STOP;
     IF ERROR_IND=8 THEN DO;
         PUT STRING(LINE) EDIT('0READ RETURN CODE=8 - DDNAME='||DDNAME
         ||' CCHHR=',UNSPEC(CCHHR),' - CONTINUING WITH NEXT TRACK')
         (A,B,A);
 /*      IF SW_ARRAY(1) THEN PUT FILE(PRINTR) EDIT(LINE) (COL(1),A);
  *      ELSE CALL TSOPUT(LINE);
  */
         CALL TSOPUT(LINE);
         LINE=' ';
 /*      IF SW_ARRAY(1) THEN PUT FILE(PRINTR) EDIT(LINE) (COL(1),A);
  *      ELSE CALL TSOPUT(LINE);
  */
         CALL TSOPUT(LINE);
         IF ENTRY_TYPE = 0 THEN GOTO STOP;
         GOTO GET_DSCB;
      END;


 MCD2 :
     IF ENTRY_TYPE2 = 4 THEN GOTO TEST_F1;
     IF FORMAT#  = '3' THEN GOTO F3;

 TEST_F1:
     IF FORMAT# = '1' THEN GOTO TEST_TYPE;
     IF USERID   = 'ALL.DSNAMES' THEN GOTO GET_ALL;
     IF USERID   = SUBSTR(DSN,1,ULEN1) THEN GOTO GET_ALL;

 TEST_TYPE:
     IF  ENTRY_TYPE = 0 THEN GOTO STOP ;
     IF  ENTRY_TYPE2 = 0 THEN GOTO STOP ;
     GOTO GET_DSCB ;

 GET_ALL :
     IF NUMDS=DSNMAX THEN DO;
       LINE=' MORE THAN '||MAXDSN||' DATA SETS AT THIS LEVEL,ONLY '
            ||MAXDSN||' LISTED';
 /*    IF SW_ARRAY(1) THEN PUT FILE(PRINTR) EDIT(LINE) (COL(1),A);
  *    ELSE CALL TSOPUT(LINE);
  */
       CALL TSOPUT(LINE);
       LINE=' USE MAX(...) KEYWORD TO LIST MORE THAN '
            ||MAXDSN||' DATASETS';
       CALL TSOPUT(LINE);
       GOTO STOP;
     END;
     NUMDS=NUMDS+1;
     DSNAME(NUMDS)=DSN;
 /*    LINE=NUMDS||DSN ;          /*   DEBUG                        */
 /*    CALL TSOPUT(LINE);         /*   DEBUG                        */
     IF DS1NOBDB THEN DSNAME(NUMDS) =
                 SUBSTR(DSNAME(NUMDS)||'***',1,44) ;
     CREDT(NUMDS)=(1000.0*CREDT1)+CREDT2;
     /* IF BINUSEDT_SIGN='1111'B THEN USEDT(NUMDS)=DS1USEDT;  */
     IF USERDT1 = 0 THEN
                    USEDT(NUMDS)=(1000.0*USEDT1)+USEDT2;
                    ELSE
                    USEDT(NUMDS)=0;
     KEY(NUMDS)=DS1PTRDS;
     BLKL(NUMDS)=DS1BLKL;
     LRECL(NUMDS)=DS1LRECL;
     USED(NUMDS)=DS1LSTAR.TT+(DS1LSTAR.R>0);
     NOEPV(NUMDS)=DS1NOEPV;
     IF DS1DSORG(1) THEN DSORG(NUMDS)='IS';
         ELSE IF DS1DSORG(2) THEN DSORG(NUMDS)='PS';
         ELSE IF DS1DSORG(3) THEN DSORG(NUMDS)='DA';
         ELSE IF DS1DSORG(7) THEN DSORG(NUMDS)='PO';
         ELSE IF DS1DSORG(13) THEN DSORG(NUMDS)='VS';
         ELSE DSORG(NUMDS)='??';
     IF DS1DSORG(8) THEN SUBSTR(DSORG(NUMDS),3,1)='U';
     IF DS1RECFM(1) & DS1RECFM(2) THEN RECFM(NUMDS)='U';
         ELSE IF DS1RECFM(1) THEN RECFM(NUMDS)='F';
         ELSE IF DS1RECFM(2) THEN RECFM(NUMDS)='V';
         ELSE RECFM(NUMDS)='?';
     IF DS1RECFM(3) THEN RECFM(NUMDS)=RECFM(NUMDS)||'T';
     IF DS1RECFM(4) THEN RECFM(NUMDS)=RECFM(NUMDS)||'B';
     IF DS1RECFM(5) THEN RECFM(NUMDS)=RECFM(NUMDS)||'S';
     IF DS1RECFM(6) THEN RECFM(NUMDS)=RECFM(NUMDS)||'A';
         ELSE IF DS1RECFM(7) THEN RECFM(NUMDS)=RECFM(NUMDS)||'M';
     DO I=1 TO 3;
         IF DS1EXT(I).EXTENT_TYPE = '00000000'B THEN GOTO GET_F3;
      /* IF DS1EXT(I).EXTENT_TYPE = '00000000'B THEN GOTO GET_DSCB; */
         TRACKS(NUMDS)=TRACKS(NUMDS)+TRK_PER_CYL*(DS1EXT(I).UCC
              -DS1EXT(I).LCC)+(DS1EXT(I).UHH-DS1EXT(I).LHH)+1;
         IF VOLSER = 'MIGRAT' THEN TRACKS(NUMDS) =
                                   TRACKS(NUMDS) - 1 ;
         END;
 GET_F3:
     IF UNSPEC(DS1PTRDS) = (5)'00000000'B THEN GOTO TEST_TYPE;
   /*IF  ENTRY_TYPE = 0 THEN GOTO GET_DSCB; */
   /*    IF UNSPEC(DS1PTRDS) = (5)'00000000'B THEN GOTO STOP;  */

 GET_NEXT_F3:
         ENTRY_TYPE = 3 ;   /* READ FORMAT 3 */
     IF  VOLSER = 'MIGRAT' THEN GOTO MCD3 ;

          CALL VTCREAD(ENTRY_TYPE,DDNAME,PDSCB,ERROR_IND,USERID);
     IF ERROR_IND=4 THEN GOTO TEST_TYPE;
  /* IF ERROR_IND=4 THEN GOTO STOP;  */
     IF ERROR_IND=8 THEN DO;
         PUT STRING(LINE) EDIT('0READ RETURN CODE=8 - DDNAME='||DDNAME
         ||' CCHHR=',UNSPEC(CCHHR),' - CONTINUING WITH NEXT TRACK')
         (A,B,A);
 /*      IF SW_ARRAY(1) THEN DO ;
  *            SUBSTR(LINE,1,1) = ' ' ;
  *            PUT FILE(PRINTR) EDIT(LINE) (COL(1),A);
  *                          END ;
  *      ELSE CALL TSOPUT(LINE);
  */
         CALL TSOPUT(LINE);
         LINE=' ';
 /*      IF SW_ARRAY(1) THEN PUT FILE(PRINTR) EDIT(LINE) (COL(1),A);
  *      ELSE CALL TSOPUT(LINE);
  */
         CALL TSOPUT(LINE);
         GOTO TEST_TYPE;
     /*  GOTO STOP; */
     /*  GOTO GET_DSCB;   */
      END;

 MCD3 :
     IF FORMAT# = '3' THEN GOTO TEST_TYPE;
  /* IF FORMAT# = '3' THEN GOTO STOP ; */

 F3:
     NUMF3=NUMF3+1;
     F3KEY(NUMF3)=KEY(NUMDS);
 /*  F3KEY(NUMF3)=CCHHR; */
     DO I=1 TO 4;
         IF DS3EXTNT(I).EXTENT_TYPE = '00000000'B THEN GOTO TEST_TYPE;
      /* IF DS3EXTNT(I).EXTENT_TYPE = '00000000'B THEN GOTO GET_DSCB; */
         F3TRACKS(NUMF3)=F3TRACKS(NUMF3)
             +TRK_PER_CYL*(DS3EXTNT(I).UCC-DS3EXTNT(I).LCC)
                +(DS3EXTNT(I).UHH-DS3EXTNT(I).LHH)+1;
      END;
     DO I=1 TO 9;
         IF DS3ADEXT(I).EXTENT_TYPE = '00000000'B THEN GOTO TEST_TYPE;
      /* IF DS3ADEXT(I).EXTENT_TYPE = '00000000'B THEN GOTO GET_DSCB; */
         F3TRACKS(NUMF3)=F3TRACKS(NUMF3)
             +TRK_PER_CYL*(DS3ADEXT(I).UCC-DS3ADEXT(I).LCC)
                +(DS3ADEXT(I).UHH-DS3ADEXT(I).LHH)+1;
      END;
     IF UNSPEC(DS3PTRDS) = (5)'00000000'B THEN GOTO TEST_TYPE;
  /* DS1PTRDS = DS3PTRDS ;  */
     GOTO GET_NEXT_F3;

 STOP:
       ENTRY_TYPE=2;
     IF  VOLSER = 'MIGRAT' THEN GOTO MCD4 ;

     CALL VTCREAD(ENTRY_TYPE,DDNAME,PDSCB,ERROR_IND,'CL'); /* CLOSE */

 MCD4 :
     IF NUMDS=0 THEN DO;
       DDNAME = (16)' ' ;         /* SET EMPTY DDNAME               */
       LINE='0    '||DDNAME||VOLSER ;
       LINE=LINE||'    DOES NOT CONTAIN DATA SET    ' ;
       LINE=LINE||USERID;
 /*    LINE='0'||DDNAME||'  DOES NOT CONTAIN DATA SET    '||USERID; */
 /*    IF SW_ARRAY(1) THEN DO ;
  *            SUBSTR(LINE,1,1) = ' ' ;
  *            PUT FILE(PRINTR) EDIT(LINE) (COL(1),A);
  *    END ;                      /* END OF SW_ARRAY(1) CODE...     */
 /*    ELSE CALL TSOPUT(LINE);
  */
       CALL TSOPUT(LINE);
       GOTO END_S;
     END;                         /* END OF NUMDS=0                 */
         TOTDS=TOTDS+NUMDS;
     DO I=1 TO NUMDS;             /* TOTAL F3 SPACE IF ANY...       */
         DO J=1 TO NUMF3;
             IF F3KEY(J)=KEY(I) THEN DO;
                 TRACKS(I)=TRACKS(I)+F3TRACKS(J);
          /*     GOTO E_M;    */
             END;                 /* END OF F3KEY(J)=KEY(I)         */
         END;                     /* END OF J=1 TO NUMF3            */
 E_M :
     END;                         /* END OF I=1 TO NUMDS            */
 /*                                                                 */
 /*      TEST  TO SEE IF DOING A  HIGH LEVEL INDEX                  */
 /*                                                                 */
     IF  SW_ARRAY(6) THEN GOTO NOTHLI;
     LINE=' ';
 /*
  *  PUT STRING(LINE) EDIT(' VOLSER DSO RCFM  BLK  REC TRKS',
  *    ' USED EX DATA SET') (A,A);
  *  IF SW_ARRAY(1) THEN PUT FILE(PRINTR) EDIT(LINE) (COL(1),A);
  *  ELSE CALL TSOPUT(LINE);
  *
  */
     DO I=1 TO NUMDS;
        IF SW_ARRAY(5) THEN DO;
         IF DSORG(I) = 'VS' THEN DO ; /* NOT_VSAM ;                */
 NOT_VSAM:
            PUT STRING(LINE)
              EDIT('0',CREDT(I),USEDT(I),DDNAME,DSORG(I),RECFM(I),
                BLKL(I),LRECL(I),TRACKS(I),USED(I),NOEPV(I),DSNAME(I))
              (A,P'99999',X(1),P'99999',X(1),A(6),X(1),A(4),
 /*           (A,F(5),X(1),P'ZZZZZ',X(1),A(6),X(1),A(4),            */
                 A(4),F(5),F(5),F(5),F(5),
                 F(3),X(1),A);
            GOTO  PRINT_1;
         END ;

 VSAM:
         IF BLKL(I) < 0 THEN GOTO CLUSTER_NAME;
         PUT STRING(LINE)
           EDIT('0',CREDT(I),USEDT(I),DDNAME,DSORG(I),
             BLKL(I),TRACKS(I),USED(I),NOEPV(I),DSNAME(I))
           (A,P'99999',X(1),P'99999',X(1),A(6),X(1),A(4),
 /*        (A,F(5),X(1),P'ZZZZZ',X(1),A(6),X(1),A(4),               */
             X(4),F(5),X(5),F(5),F(5),
             F(3),X(1),A);
         GOTO  PRINT_1;

 CLUSTER_NAME:
         PUT STRING(LINE) EDIT('0',DDNAME,
             'CLUSTER NAME',DSNAME(I))
             (A,X(12),A(6),X(3),A(12),X(18),A);

 PRINT_1:
 /*          IF SW_ARRAY(1) THEN  DO ;
  *            SUBSTR(LINE,1,1) = ' ' ;
  *            PUT FILE(PRINTR) EDIT(LINE) (COL(1),A);
  *                               END ;
  *          ELSE CALL TSOPUT(LINE);
  */
             CALL TSOPUT(LINE);
        END;                      /* END OF SW_ARRAY(5)            */

       TOTAL_EXT=TOTAL_EXT+NOEPV(I);
       TRACK_TOTAL=TRACK_TOTAL+TRACKS(I);
       USED_TOTAL=USED_TOTAL+USED(I);
     END;                         /* END OF I=1 TO NUMDS            */

     GO  TO TOTALS;
 /*                                                                 */
 /*      END OF TEST TO SEE IF DOING A  HIGH LEVEL INDEX            */
 /*                                                                 */
 NOTHLI  :
   IF SW_ARRAY(5) THEN DO;
     LINE=' ';
 /*  PUT STRING(LINE) EDIT('0DATA SETS ON VOLUME '||DDNAME) (A);    */
        PUT STRING(LINE) EDIT('0TSO SPACE ALLOCATION',
            ' AND USAGE LISTING FOR ',
            USERID) (A,A,A);
 /*  IF SW_ARRAY(1) THEN DO;
  *            SUBSTR(LINE,1,1) = ' ' ;
  *            PUT FILE(PRINTR) EDIT(LINE) (COL(1),A);
  *  END ;
  *  ELSE CALL TSOPUT(LINE);
  */
     CALL      TSOPUT(LINE);
     LINE=' ';
     PUT STRING(LINE)
         EDIT(' CREDT USEDT VOLSER DSO RCFM  BLK  REC TRKS',
       ' USED EX DATA SET') (A,A);
 /*  IF SW_ARRAY(1) THEN PUT FILE(PRINTR) EDIT(LINE) (COL(1),A);
  *  ELSE CALL TSOPUT(LINE);
  */
     CALL      TSOPUT(LINE);
   END;                           /* END OF SW_ARRAY(5)            */

     DO I=1 TO NUMDS;
        IF SW_ARRAY(5) THEN DO;
         PUT STRING(LINE)
             EDIT('0',CREDT(I),USEDT(I),DDNAME,DSORG(I),RECFM(I),
             BLKL(I),LRECL(I),TRACKS(I),USED(I),NOEPV(I),DSNAME(I))
             (A,P'99999',X(1),P'99999',X(1),A(6),X(1),A(4),A(4),
 /*          (A,F(5),X(1),P'ZZZZZ',X(1),A(6),X(1),A(4),A(4),        */
             F(5),F(5),F(5),F(5),F(3),X(1),A);
 /*          IF SW_ARRAY(1) THEN  DO ;
  *            SUBSTR(LINE,1,1) = ' ' ;
  *            PUT FILE(PRINTR) EDIT(LINE) (COL(1),A);
  *          END ;
  *          ELSE CALL TSOPUT(LINE);
  */
             CALL TSOPUT(LINE);
        END;                      /* END OF SW_ARRAY(5)            */
       TOTAL_EXT=TOTAL_EXT+NOEPV(I);
       TRACK_TOTAL=TRACK_TOTAL+TRACKS(I);
       USED_TOTAL=USED_TOTAL+USED(I);
     END;                         /* END OF I=1 TO NUMDS            */

 TOTALS:
        IF SW_ARRAY(6) THEN GOTO TOTALS2 ;               /*        */
        IF SW_ARRAY(8) THEN GOTO END_S ;

 TOTALS2 :
        IF SW_ARRAY(5)|SW_ARRAY(2)|SW_ARRAY(8) THEN DO;
        PUT STRING(LINE) EDIT('0TOTALS: TRKS=',TRACK_TOTAL,' USED=',
            USED_TOTAL,' DATA SETS=',TOTDS,' EXTENTS=',TOTAL_EXT)
            (A,F(6),A,F(6),A,F(6),A,F(6));
 /*      IF SW_ARRAY(1) THEN DO;
  *            SUBSTR(LINE,1,1) = ' ' ;
  *            PUT FILE(PRINTR) EDIT(LINE) (COL(1),A);
  *                          END ;
  *      ELSE CALL TSOPUT(LINE);
  */
         CALL TSOPUT(LINE);
         IF SW_ARRAY(3) THEN DO;
             DEC_USED=USED_TOTAL;
             DEC_TRKS=TRACK_TOTAL;
             DEC_TOT=TOTDS;
             DEC_EXT=TOTAL_EXT;
             IF TRACK_TOTAL=0 THEN
                 DEC_PERC=DIVIDE(DEC_USED,DEC_TRKS,5,2);
             ELSE DEC_PERC=1;
          DEC_PERC = DEC_PERC * 100.00 ;
             IF TOTDS = 0 THEN
                DEC_FRAG=DIVIDE(DEC_EXT,DEC_TOT,4,2);
             ELSE DEC_FRAG = 0 ;
             PUT STRING(LINE) EDIT(' PERCENT TRKS USED/ALLOC=',
                 DEC_PERC,'    EXTENTS/TOTAL # DS=',
                 DEC_FRAG)
                 (A,F(5,1),A,F(4,2));
 /*          IF SW_ARRAY(1) THEN PUT FILE(PRINTR) EDIT(LINE) (COL(1),A);
  *          ELSE CALL TSOPUT(LINE);
  */
             CALL TSOPUT(LINE);
         END;
       END;
        IF SW_ARRAY(6) THEN GOTO END_S ;
        IF SW_ARRAY(1)|SW_ARRAY(5) THEN DO;
           LINE='0DSPACE COMPLETED SUCCESSFULLY ON VOLUME '||VOLSER;
           CALL TSOPUT(LINE);
        END;
 END_S:
 END DSPACE;
/*
//*
//LKED.SYSLMOD DD DSN=&&TEMP,UNIT=SYSDA,DISP=(SHR,PASS),
//   SPACE=(TRK,(15,5,5))
//LKED.SYSIN DD *
    SETCODE AC(0)
    MODE    AMODE(31) RMODE(24)
    NAME  DSPACE1(R)
/*
//*
//VTCREAD EXEC HLASMCL,COND=EVEN,
//           MAC1='SYS1.MODGEN',
//           PARMC='ESD',PARML='LIST,LET,MAP',CLASS='*'
//ASM.SYSPRINT DD SYSOUT=*
//ASM.SYSIN DD *
VTRD     TITLE 'VTCREAD - VTOC READING SUBROUTINE'
* STATUS:  VERSION 3, 9 MARCH 1984.
         SPACE
* AUTHOR:  R.HALL. DIVERSIFIED DEVELOPMENTS.
         SPACE
         SPACE
* FUNCTION: THIS SUBROUTINE READS THE VOLUME TABLE OF CONTENTS (VTOC)
*        FROM A DIRECT-ACCESS DEVICE USING OBTAIN SEARCH FOR THE
*        FORMAT 1 AND OBTAIN SEEK FOR ANY FORMAT 3 DSCB'S AND
*        PRESENTS IT TO THE CALLER ONE RECORD (DSCB) AT A TIME.
         SPACE
* OPERATION: THE ROUTINE HAS 6 CALL MODES:
*
*        0 - READ.  RETURNS WITH THE CORE ADDRESS OF A DSCB IN THE 3RD
*              PARAMETER.  THE CORE CONSISTS OF 148 CONSECUTIVE BYTES,
*              CONTAINING THE COUNT (8 BYTES), KEY (44 BYTES), AND DATA
*              (96 BYTES) FOR ONE DSCB.  RETURN CODES (4TH PARAMETER)
*              ARE:
*                      0 - NORMAL;
*                      4 - END OF FILE, NO DATA PRESENTED;
*
*        1 - OPEN.  THE SECOND PARAMETER SHOULD POINT TO THE SDV OF
*              AN 8-BYTE FIELD CONTAINING THE DDNAME TO BE USED IN THE
*              DCB.  THE CORRESPONDING DD CARD SHOULD SPECIFY A DISP OF
*              (OLD,KEEP).  ON A NORMAL RETURN, THE DDNAME WILL BE SET
*              TO THE VOLUME SERIAL NUMBER OF THE DISK WHICH THAT
*              DD CARD POINTS TO,  AND THE ENTRY TYPE CONTAINS THE
*              NUMBER OF TRKS/CYL. RETURN CODES (4TH PARAMETER) ARE:
*                      0 - NORMAL;
*                      4 - UNABLE TO OPEN (PROBABLY MISSING DD CARD);
*                      8 - DD CARD DID NOT REFER TO A DIRECT-ACCESS
*                          DEVICE, OR DEVICE TYPE UNKNOWN.
*
*        2 - CLOSE.  NO ARGUMENTS ARE REQUIRED OR RETURNED.  RETURN
*              CODE (4TH PARAMETER) IS 0.
*
*        3 - READ3. RETURNS WITH THE CORE ADDRESS OF A DSCB3 IN THE 3RD
*              PARAMETER.  THE CORE CONSISTS OF 104 CONSECUTIVE BYTES,
*              CONTAINING THE CCHHR (8 BYTES) OF THE FORMAT 3 DSCB,
*              AND THE DATA PORTION (96 BYTES) OF THE FORMAT 3 DSCB.
*              RETURN CODES (4TH PARAMETER) ARE:
*                      0 - NORMAL;
*                      4 - END OF FILE, NO DATA PRESENTED;
*
*        4 - READ.  RETURNS WITH THE CORE ADDRESS OF A DSCB IN THE 3RD
*              PARAMETER.  THE CORE CONSISTS OF 148 CONSECUTIVE BYTES,
*              CONTAINING THE COUNT (8 BYTES), KEY (44 BYTES), AND DATA
*              (96 BYTES) FOR ONE DSCB.  RETURN CODES (4TH PARAMETER)
*              ARE:
*                      0 - NORMAL;
*                      4 - END OF FILE, NO DATA PRESENTED;
*                      8 - PERMANENT I/O ERROR.  THE KEY AND DATA AREAS
*                          WILL BE SET TO ZEROS; THE COUNT AREA WILL
*                          CONTAIN THE CORRECT CCHHR.  SINCE READING
*                          IS DONE A TRACK AT A TIME, ALL THE DSCB'S
*                          FOR THAT TRACK WILL BE MARKED IN ERROR.
*                          READING MAY CONTINUE ON TO THE NEXT TRACK.
*
*        5 - OPEN.  THE SECOND PARAMETER SHOULD POINT TO THE SDV OF
*              AN 8-BYTE FIELD CONTAINING THE DDNAME TO BE USED IN THE
*              DCB.  THE CORRESPONDING DD CARD SHOULD SPECIFY A DISP OF
*              (OLD,KEEP).  ON A NORMAL RETURN, THE DDNAME WILL BE SET
*              TO THE VOLUME SERIAL NUMBER OF THE DISK WHICH THAT
*              DD CARD POINTS TO,  AND THE ENTRY TYPE CONTAINS THE
*              NUMBER OF TRKS/CYL. RETURN CODES (4TH PARAMETER) ARE:
*                      0 - NORMAL;
*                      4 - UNABLE TO OPEN (PROBABLY MISSING DD CARD);
*                      8 - DD CARD DID NOT REFER TO A DIRECT-ACCESS
*                          DEVICE, OR DEVICE TYPE UNKNOWN.
*
         SPACE
* ENTRY POINTS:  ENTRY IS ALWAYS TO 'CVTREAD' VIA A PL/1 CALL.
*        ARGUMENTS ARE:
*                      1 - A(FULL-WORD BINARY ENTRY TYPE);
*                      2 - A(DDNAME);
*                      3 - A(PTR FOR DSCB);
*                      4 - A(FULL-WORD BINARY RETURN CODE);
*                      4 - A(DSNAME TO USE AS A KEY).
         SPACE
* DATA SETS:  READS VOLUME TABLE OF CONTENTS FROM ANY DIRECT-ACCESS
*        DEVICE.
         SPACE
* EXTERNAL ROUTINES:  USES SUPERVISOR ROUTINE 'OBTAIN'.
         SPACE
* EXITS - NORMAL:  RETURNS TO PL/I AFTER PUTTING RETURN
*        CODE IN FOURTH PARAMETER.  (SEE ABOVE FOR RETURN CODE VALUES.)
         SPACE
* EXITS - ERROR:  NONE.
         SPACE
* TABLES AND WORK AREAS:  TABLE OF DEVICE TYPES.
         SPACE
* ATTRIBUTES:  SERIALLY REUSABLE, NON-RECURSIVE, NON-REENTRANT.
         EJECT
* SECTION DEFINITION AND REGISTER ASSIGNMENTS:
         SPACE
VTCREAD CSECT
         SPACE 2
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R9       EQU   9
R10      EQU   10              RETURN CODE REGISTER
R11      EQU   11              LOCAL SUBROUTINE EXIT REGISTER
R13      EQU   13
R14      EQU   14
R15      EQU   15
         SPACE 3
* TAGS FOR CHANNEL COMMANDS AND FLAG BITS:
         SPACE
READR0   EQU   X'16'           READ RECORD 0
READCKD  EQU   X'1E'           READ COUNT, KEY, AND DATA
         SPACE
CC       EQU   X'40'           COMMAND CHAIN FLAG
SLI      EQU   X'20'           SUPPRESS LENGTH INDICATION FLAG
SKIP     EQU   X'10'           SKIP DATA TRANSFER FLAG
         SPACE 3
* COMMUNICATION VECTOR TABLE (CVT) DEFINITIONS:
         SPACE
CVT      EQU   16              LOCATION OF CVT BASE ADDRESS
CVTPCNVT EQU   28              OFFSET TO CONVERT ROUTINE ADDRESS
         EJECT
************
* PROLOGUE *
************
         SPACE
* ENTER HERE AND PERFORM STANDARD REGISTER SAVE AREA HOUSEKEEPING.
         SPACE
         SAVE  (14,11),,VTCREAD        SAVE PL/I REGS IN PL/I DSA.
         USING VTCREAD,R15
         ST    R13,VTCRSAVE+4          STORE PL/I DSA ADDRESS.
         LA    R13,VTCRSAVE
         DROP  R15
         SPACE
         BALR  8,0                     SET LOCAL BASE REGISTER
         USING *,8
START    LR    R9,R1                    SAVE PARAMETER REGISTER
         L     R1,0(R9)                ADDR OF ENTRY TYPE
         SR    R10,R10                 ZERO RETURN CODE REGISTER
         SPACE
* SELECT MODE FROM CONTENTS AT ADDRESS IN REGISTER 1.
         SPACE
*        LA    R2,3                    MASK FOR LOW 2 BITS
*        N     R2,0(R1)                GET CALL MODE
         L     R2,0(R1)                GET CALL MODE
         SLL   R2,2                    MODE TIMES 4
         B     *+4(R2)                 BRANCH ON MODE
         SPACE
         B     GET                 0   MODE 0, GET A DSCB
         B     OPEN                4   MODE 1, OPEN A NEW VTOC
         B     CLOSE               8   MODE 2, CLOSE
         B     GETF3               C   MODE 3, READ FORMAT 3
         B     GET4               10   MODE 4, READ USING EXCP
         B     OPEN5              14   MODE 5, OPEN FOR EXCP READ
         SPACE 1
*        B     RETURN0             C   MODE 3 NOT DEFINED, NO OP
         SPACE 3
***********
* RETURNS *
***********
         SPACE
RETURN8  LA    R10,4(R10)              ENTRY FOR RETURN CODE 8
RETURN4  LA    R10,4(R10)              ENTRY FOR RETURN CODE 4
RETURN0  L     R15,12(R9)              ENTRY FOR RETURN CODE 0
         ST    R10,0(R15)
         L     R15,8(R9)               GET ADDR OF PTR FOR DSCB
         ST    R1,0(R15)
         L     R13,4(R13)
         LM    R14,11,12(R13)          RESTORE PL/I REGISTERS.
         BR    R14                     RETURN TO PL/I.
         EJECT
*********************
* MODE 0 - GET DSCB *
*********************
         SPACE
         SPACE
GET      DS    0H
         SPACE
***********************************************************************
*                                                                     *
*              SET UP THE KEY FOR THE VTOC READ                       *
*                                                                     *
***********************************************************************
*        MVI   KEY,C' '           CLEAR KEY AREA
*        MVC   KEY+1(43),KEY      ""
         L     R4,16(R9)          R4 -> TO A(DATASET NAME)
         L     R4,0(0,R4)         R4 -> TO DATASET NAME LTH
         LA    R4,2(0,R4)         R4 -> TO DATASET NAME
         MVC   KEY(44),0(R4)      SET UP KEY
         SPACE
***********************************************************************
*                                                                     *
*              READ THE VTOC BY KEY USING OBTAIN SEARCH               *
*                                                                     *
***********************************************************************
         SPACE
READVT   DS    0H
         OBTAIN F1CAM             GET FORMAT 1 DSCB
         LTR   R15,R15            WAS OBTAIN OKAY ?
         BNZ   RETURN4            NO, SAY NOT FOUND
         LA    R2,FULLDSCB             POINT TO DSCB
         SPACE
PASSDSCB DS    0H
         LR    R1,R2                   PASS ADDRESS TO USER
*ETOUT   DS    0H
         B     RETURN0                 RETURN CODE 0
         EJECT
******************************
* MODE 3 - GET FORMAT 3 DSCB *
******************************
         SPACE
GETF3    DS    0H
         SPACE
***********************************************************************
*                                                                     *
*              SET UP THE KEY FOR THE VTOC READ                       *
*              USING THE CCHHR IN THE FORMAT 1                        *
*                                                                     *
***********************************************************************
         LA    R4,KEY             R4 -> FORMAT 1 DSCB
         MVC   BLKA+3(5),135(R4)  MOVE CCHHR TO BLKA FIELD
         MVC   DSCB3(5),135(R4)   SET UP CCHHR FOR PLI TEST
         SPACE
***********************************************************************
*                                                                     *
*              READ THE VTOC BY CCHHR USING OBTAIN SEEK               *
*                                                                     *
***********************************************************************
         SPACE
         SPACE
READF3   DS    0H
         OBTAIN F3CAM             GET FORMAT 3 DSCB
         LTR   R15,R15            WAS OBTAIN OKAY ?
         BNZ   RETURN4            NO, SAY NOT FOUND
         LA    R2,FULLDSCB        POINT TO DSCB3
*        LA    R2,DSCB3           POINT TO DSCB3
         B     PASSDSCB           PASS DSCB ADDRESS TO USER
         SPACE
         EJECT
*****************
* MODE 1 - OPEN *
*****************
         SPACE
* ENTER WITH A DDNAME IN SECOND PARAMETER POSITION.
         SPACE
OPEN     DS    0H
         SPACE
         BAL   R11,CLOSESUB            CALL CLOSE SUBROUTINE
         L     1,4(R9)                 GET ADDR OF DDNAME
         L     1,0(1)
         MVC   DCBDDNAM(8),0(1)    INSERT DDNAME IN DCB
         SPACE
* CHECK DEVICE TYPE TO BE SURE IT IS DIRECT ACCESS.
         SPACE
         DEVTYPE  DCBDDNAM,DWORK       GET DEVICE TYPE
         LTR   R15,R15                 TEST IF IT FOUND DD CARD
         BNZ   RETURN4                 ERROR, DD CARD MISSING
         CLI   DWORK+2,X'20'           TEST DEVICE TYPE
         BNE   RETURN8                 ERROR IF NOT DIRECT ACCESS
         SPACE
         CLI   DWORK+3,MAXDVT          TEST FOR MAX DEVICE TYPE
         BNL   RETURN8                 ERROR IF TOO LARGE
         L     R2,0(R9)                ADDR OF ENTRY TYPE
         SR    R1,R1
         IC    R1,DWORK+3              LOAD DEVICE NUMBER
         SLL   R1,1               X 2 FOR LTH OF TABLE ENTRIES
         LA    R4,DVICETAB+1(R1) R4 -> TRKS/CYL BYTE OF TABLE
*        AGO   .SKIP1
*
*              FOLLOWING CODE ADDED JUL 93
*
         CLI   0(R4),X'00'        IS TABLE ENTRY USED?   JUL93
         BH    TABLSET            YES                    JUL93
         MVC   0(1,R4),DWORK+11   PUT TRKS/CYL IN TABLE  JUL93
         SPACE 1                                         JUL93
TABLSET  DS    0H                                        JUL93
         ST    R4,SAVE4           SAVE TABLE ENTRY ADDRESS JUL93
*
*              ABOVE     CODE ADDED JUL 93
*
.SKIP1   ANOP
         MVC   3(1,R2),0(R4)      PUT TRKS/CYL INTO ENTRY TYPE
         IC    R1,DVICETAB(R1)         LOAD DSCB'S/TRK FROM TABLE
         LTR   R1,R1                   ZERO IS UNDEFINED DEVICE
*        BZ    RETURN8                 EXIT IF UNKNOWN      JUL93
*        AGO   .SKIP2
*
*              FOLLOWING CODE ADDED JUL 93
*
         BP    SAVNBRD            DEVICE IS DEFINED, BRANCH JUL93
         LA    R1,100             SAY GET BIG AREA FOR DSCB JUL93
         MVI   DSCBFLG,X'80'      SAY NO DSCB/TRK           JUL93
         SPACE 1                                         JUL93
SAVNBRD  DS    0H                                        JUL93
*
*              ABOVE     CODE ADDED JUL 93
*
.SKIP2   ANOP
         ST    R1,NDSCBS               STORE NUMBER OF DSCB'S/TRACK
         SPACE
* READ JFCB TO GET VOL SER
         SPACE
         RDJFCB  VTOCDCB
         L     1,4(R9)                 GET DDNAME ADDRESS BACK
         L     1,0(1)
         MVC   RNAME,JFCBVOLS     SAVE VOLSER FOR OBTAINS
         MVC   0(6,1),JFCBVOLS         MOVE IN VOL SER #
         MVC   6(2,1),=C'  '
         SPACE
         B     RETURN0                 INDICATE SUCCESSFUL OPEN
         EJECT
******************
* MODE 2 - CLOSE *
******************
         SPACE
CLOSE    DS    0H
         BAL   R11,CLOSESUB            CALL CLOSE SUBROUTINE
         B     RETURN0            INDICATE SUCCESSFUL CLOSE
         SPACE 2
* IF THE CHANNEL PROGRAM IS RUNNING, WAIT FOR IT BEFORE TAKING FURTHER
* ACTION.
         SPACE
CLOSESUB DS    0H
         TM    MODESW,XCPRUN           TEST IF CHANNEL PROGRAM RUNNING
         BZ    NOEXCP                  BRANCH IF NOT
         WAIT  ECB=VTOCECB             WAIT UNTIL COMPLETE
         NI    MODESW,X'FF'-XCPRUN     TURN RUNNING SWITCH OFF
NOEXCP   DS    0H
         SPACE
* CLOSE THE DCB.
         SPACE
         TM    DCBOFLGS,OPENBIT        TEST IF DCB OPEN
         BZ    NOCLOSE                 BRANCH IF NOT
         CLOSE VTOCDCB
NOCLOSE  DS    0H
         SPACE
* RELEASE CORE OBTAINED FOR DSCB BUFFERS.
         SPACE
         TM    MODESW,CBGOT            TEST IF CORE GOTTEN
         BZ    NOFREE                  BRANCH IF NOT
         LM    R0,R1,CBSIZE            LOAD SIZE AND LOCATION
         FREEMAIN  R,LV=(0),A=(1)      FREE CORE
         NI    MODESW,X'FF'-CBGOT      SET CORE GOTTEN BIT OFF
NOFREE   DS    0H
         SPACE
         NI    MODESW,X'FF'-RDERR      CLEAR ERROR SWITCH
         BR    R11
         EJECT
*********************
* MODE 5 - GET DSCB VIA EXCP. *
*********************
         SPACE
* IF END-OF-FILE WAS REACHED, RETURN AT ONCE.
         SPACE
GET4     DS    0H
         TM    MODESW,EOFSW            TEST END-OF-FILE BIT
         BO    RETURN4                 RETURN CODE 4 IF ON
         SPACE
* IF CHANNEL PROGRAM HAS BEEN STARTED, GO TO CHECK IT.  OTHERWISE,
* ASSUME THERE IS AT LEAST ONE FULL BUFFER.
         SPACE
         TM    MODESW,XCPRUN           TEST IF EXCP ISSUED
         BO    XCPTEST                 BRANCH IF SO
         SPACE
* SET BUFFER ADDRESS TO NEXT DSCB AND TEST IF LAST ON TRACK.  IF NOT,
* EXIT WITH ITS ADDRESS IN R1.
         SPACE
         L     R2,DSCBADR              LOAD BUFFER POINTER
         LA    R2,148(R2)              ADVANCE TO NEXT DSCB
NDXSTORE ST    R2,DSCBADR              STORE UPDATED POINTER
         C     R2,DSCBLIM              TEST IF LAST DSCB IN BUFFER
         BNL   LASTDSCB                BRANCH IF SO
         LR    R1,R2                   PASS ADDRESS TO USER
*OCT95   CLC   =X'00000000',0(R1) 1ST 4 BYTES OF NAME BINARY 0'S?
*OCT95   BE    GET4               YES, EMPTY DSCB
         SPACE 1
GETOUT   DS    0H
         MVC   FULLDSCB(148),0(R1) SET UP FULLDSCB IN CASE WE NEED F3
         TM    MODESW,RDERR            TEST IF ERROR ON THIS TRACK
         BZ    RETURN0                 RETURN CODE 0 IF NOT
         B     RETURN8                 RETURN CODE 8 IF ERROR
         SPACE
* IF THIS IS THE LAST DSCB, MOVE IT TO THE JFCB BUFFER AND START
* READING THE NEXT TRACK.
         SPACE
LASTDSCB MVC   JFCB(148),0(R2)         MOVE LAST DSCB
         L     R3,TTRN                 LOAD RELATIVE TRACK NUMBER
         AL    R3,=X'00010000'         INCREMENT TO NEXT TRACK
         ST    R3,TTRN
         BAL   R11,EXCP                START CHANNEL PROGRAM
         LA    R1,JFCB                 LOAD DSCB ADDRESS FOR CALLER
         B     GETOUT                  TO RETURN
         EJECT
* WAIT FOR CHANNEL PROGRAM COMPLETION AND TEST THE OUTCOME.
         SPACE
XCPTEST  WAIT  ECB=VTOCECB
         SPACE
         NI    MODESW,X'FF'-XCPRUN     TURN EXCP STARTED BIT OFF
         CLI   VTOCECB,X'7F'           TEST COMPLETION CODE
         BNE   PERMERR                 BRANCH IF ERROR
SETDSCBA L     R2,DSCBSTRT             SET BUFFER POINTER TO 1ST DSCB
*
*              CODE ADDED TO CHECK FOR EOF ON DSCB....OCT95
*              UPDATED TO CHECK 255 TIMES....         JAN96
*
         CLC   =X'00000000',8(R2) 1ST 4 BYTES OF BUF DATA X'0'S?
         BNE   NDXSTORE           NO, IT'S A GOOD DSCB
*OCT95   TM    MODESW2,EOFSW2     YES, HAVE WE BEEN HERE BEFORE?
         TM    MODESW2,X'FF'      YES, HAVE WE BEEN HERE 255 TIMES?
         BO    SETEOFSW           YES, SAY EOF.
*OCT95   OI    MODESW2,EOFSW2     NO, SAY WE'VE BEEN HERE BEFORE
         IC    R1,MODESW2         R1 = COUNT
         LA    R1,1(0,R1)         ADD 1
         STC   R1,MODESW2         SAVE NEW COUNT
         B     NDXSTORE
         SPACE 1
SETEOFSW DS    0H
         OI    MODESW,EOFSW       YES, SET END-OF-FILE BIT
*
*              CODE ABOVE ADDED TO CHECK FOR EOF ON DSCB....OCT95
*
         B     NDXSTORE
         SPACE
* PERMANENT ERROR FOR THIS TRACK.  ZERO THE DSCB'S AND FILL IN THE
* CCHHR PORTIONS OF THE COUNT AREAS.
         SPACE
PERMERR  OI    MODESW,RDERR            SIGNAL READ ERROR
         NI    IOBFLAG1,X'FB'          TURN OFF BIT 5 OF IOB FLAG
         NI    DCBIFLGS,X'3F'          TURN OFF BITS 0 AND 1
         L     R2,DSCBSTRT             LOAD ADDRESS OF FIRST DSCB
         LA    R3,1                    LOAD RECORD NUMBER
         SPACE
DSCBELUP XC    0(148,R2),0(R2)         ZERO DSCB BUFFER
         MVC   0(4,R2),IOBSEEK+3       INSERT CCHH IN COUNT FIELD
         STC   R3,4(R2)                INSERT R IN COUNT FIELD
         LA    R2,148(R2)              POINT TO NEXT BUFFER
         LA    R3,1(R3)                INCREMENT RECORD NUMBER
         C     R2,DSCBLIM              TEST FOR LAST BUFFER
         BNH   DSCBELUP
         B     SETDSCBA                BRANCH TO RESET BUFFER POINTER
         EJECT
*****************
* MODE 4 - OPEN VTOC FOR READ USING EXCP. *
*****************
         SPACE
* ENTER WITH A DDNAME IN SECOND PARAMETER POSITION.  PERFORM CLOSE
* SUBROUTINE FIRST TO BE SURE EVERYTHING IS INITIALIZED.
         SPACE
OPEN5    DS    0H
         BAL   R11,CLOSESUB            CALL CLOSE SUBROUTINE
         SPACE
         L     1,4(R9)                 GET ADDR OF DDNAME
         L     1,0(1)
         MVC   DCBDDNAM(8),0(1)    INSERT DDNAME IN DCB
         SPACE
* CHECK DEVICE TYPE TO BE SURE IT IS DIRECT ACCESS.
         SPACE
         DEVTYPE  DCBDDNAM,DWORK       GET DEVICE TYPE
         LTR   R15,R15                 TEST IF IT FOUND DD CARD
         BNZ   RETURN4                 ERROR, DD CARD MISSING
         CLI   DWORK+2,X'20'           TEST DEVICE TYPE
         BNE   RETURN8                 ERROR IF NOT DIRECT ACCESS
         SPACE
         CLI   DWORK+3,MAXDVT          TEST FOR MAX DEVICE TYPE
         BNL   RETURN8                 ERROR IF TOO LARGE
         L     R2,0(R9)                ADDR OF ENTRY TYPE
         SR    R1,R1
         IC    R1,DWORK+3              LOAD DEVICE NUMBER
         SLL   R1,1               X 2 FOR LTH OF TABLE ENTRIES
         LA    R4,DVICETAB+1(R1) R4 -> TRKS/CYL BYTE OF TABLE
*        AGO   .SKIP4
*
*              FOLLOWING CODE ADDED JUL 93
*
         CLI   0(R4),X'00'        IS TABLE ENTRY USED?   JUL93
         BH    TABLESET           YES                    JUL93
         MVC   0(1,R4),DWORK+11   PUT TRKS/CYL IN TABLE  JUL93
         SPACE 1                                         JUL93
TABLESET DS    0H                                        JUL93
         ST    R4,SAVE4           SAVE TABLE ENTRY ADDRESS JUL93
*
*              ABOVE     CODE ADDED JUL 93
*
.SKIP4   ANOP
         MVC   3(1,R2),0(R4)      PUT TRKS/CYL INTO ENTRY TYPE
         IC    R1,DVICETAB(R1)         LOAD DSCB'S/TRK FROM TABLE
         LTR   R1,R1                   ZERO IS UNDEFINED DEVICE
*        BZ    RETURN8                 EXIT IF UNKNOWN      JUL93
*        AGO   .SKIP5
*
*              FOLLOWING CODE ADDED JUL 93
*
         BP    SAVENBRD           DEVICE IS DEFINED, BRANCH JUL93
         LA    R1,100             SAY GET BIG AREA FOR DSCB JUL93
         MVI   DSCBFLG,X'80'      SAY NO DSCB/TRK           JUL93
         SPACE 1                                         JUL93
SAVENBRD DS    0H                                        JUL93
*
*              ABOVE     CODE ADDED JUL 93
*
.SKIP5   ANOP
         ST    R1,NDSCBS               STORE NUMBER OF DSCB'S/TRACK
         SPACE
* READ JFCB AND INSERT DATA SET NAME OF 44 X'04'.
         SPACE
         RDJFCB  VTOCDCB
         MVI   JFCBDSNM,X'04'          GENERATE DATA SET NAME
         MVC   JFCBDSNM+1(43),JFCBDSNM OF THE VTOC.
         OI    JFCBTSDM,JFCNWRIT       INHIBIT JFCB WRITE BACK
         L     1,4(R9)                 GET DDNAME ADDRESS BACK
         L     1,0(1)
         MVC   RNAME,JFCBVOLS     SAVE VOLSER FOR OBTAINS
         MVC   0(6,1),JFCBVOLS         MOVE IN VOL SER #
         MVC   6(2,1),=C'  '
         SPACE
* OPEN THE DSCB.
         SPACE
         OPEN  (VTOCDCB,(INPUT)),TYPE=J
         TM    DCBOFLGS,OPENBIT        TEST IF OPEN WORKED
         BZ    RETURN4                 ERROR IF OPEN FAILED
         SPACE
* OBTAIN CORE FOR CHANNEL PROGRAM AND DSCB BUFFERS.
         SPACE
         LA    R0,156                  CORE FOR ONE DSCB AND ITS CCW
         MH    R0,NDSCBS+2             TIMES NUMBER PER TRACK
         AH    R0,=H'15'               PLUS 1 CCW AND ROUNDING
         N     R0,=X'FFFFFFF8'         ROUND TO DOUBLE-WORD MULTIPLE
         ST    R0,CBSIZE               SAVE SIZE OF GOTTEN CORE
         GETMAIN  R,LV=(0)             GET TRACK BUFFERS
         ST    R1,CBADDR               SAVE ADDRESS OF GOTTEN CORE
         OI    MODESW,CBGOT            INDICATE CORE GOTTEN
         SPACE
* GENERATE CHANNEL PROGRAM.  IT CONSISTS OF A 'READ R0' ORDER WITH
* THE SKIP FLAG ON, FOLLOWED BY A 'READ COUNT-KEY-AND-DATA' ORDER FOR
* EACH DSCB.
         SPACE
GENCHAN  DS    0H
         L     R2,NDSCBS               NUMBER OF DSCB'S
         SLL   R2,3                    TIMES   8
         LA    R2,8(R2,R1)             PLUS 8 AND BASE = 1ST BUFFER ADD
         ST    R2,DSCBSTRT             SAVE ADDRESS OF FIRST BUFFER
         SPACE
         ST    R1,IOBSTART             ADDRESS OF CHANNEL PROGRAM
         MVC   0(8,R1),INITCCW         INSERT FIRST CCW
         LA    R3,8(R1)                PLACE FOR NEXT CCW
         LA    R4,1                    BUFFER COUNTER
         SPACE
CCWLOOP  MVC   0(8,R3),READCCW         INSERT READ CCW FOR ONE DSCB
         ST    R2,0(R3)                SET ITS BUFFER ADDRESS
         MVI   0(R3),READCKD           RESTORE COMMAND CODE
         C     R4,NDSCBS               TEST BUFFER COUNTER
         BNL   LASTCCW                 BRANCH IF LAST BUFFER
         LA    R3,8(R3)                INCREMENT CCW ADDRESS
         LA    R2,148(R2)              INCREMENT BUFFER ADDRESS
         LA    R4,1(R4)                INCREMENT BUFFER COUNTER
         B     CCWLOOP                 DO NEXT BUFFER
         SPACE
LASTCCW  NI    4(R3),X'FF'-CC          TURN OFF COMMAND CHAIN BIT
         ST    R2,DSCBLIM              SAVE ADDRESS OF LAST DSCB BUFFER
         SPACE
* SET OTHER THINGS AND START PROGRAM TO FILL BUFFER.
         SPACE
         SR    R0,R0
         ST    R0,TTRN                 SET RELATIVE TRACK NUMBER TO 0
         NI    MODESW,X'FF'-XCPRUN-RDERR-EOFSW   SET FLAGS OFF
         BAL   R11,EXCP                START CHANNEL PROGRAM
*        AGO   .SKIP6
*
*              FOLLOWING CODE ADDED JUL 93
*
         TM    DSCBFLG,X'80'      DEVICE FOUND?
         BZ    RETURN0            YES
         NI    DSCBFLG,X'FF'-X'80'  TURN DEVICE NOT FOUND BIT OFF
         L     R2,0(R9)           R2 -> TO WHERE TRK GOES
         L     R4,SAVE4           RELOAD R4
* WAIT FOR CHANNEL PROGRAM COMPLETION AND TEST THE OUTCOME.
         SPACE
         WAIT  ECB=VTOCECB
         SPACE
         NI    MODESW,X'FF'-XCPRUN     TURN EXCP STARTED BIT OFF
         CLI   VTOCECB,X'7F'           TEST COMPLETION CODE
         BNE   RETURN8                 BRANCH IF ERROR
*        BNE   PERMERR                 BRANCH IF ERROR
         L     R2,DSCBSTRT             SET BUFFER POINTER TO 1ST DSCB
         ST    R2,DSCBADR              STORE UPDATED POINTER
         L     R3,DSCB-FULLDSCB(R2)    R3 -> TO DSCB
         CLI   0(R3),X'F4'             IS IT A TYPE 4 DSCB
         BNE   RETURN8            NO, BAD READ
         MVC   0(1,R4),30(R3)     SAVE DSCB/TRK IN TABLE
         MVC   NDSCBS+3(1),30(R3)      SAVE DSCB/TRK
         B     GENCHAN            GO TRY TO READ IT ONE MORE TIME
*
*              ABOVE     CODE ADDED JUL 93
*
.SKIP6   ANOP
         B     RETURN0                 INDICATE SUCCESSFUL OPEN
         EJECT
****************
* EXCP ROUTINE *
****************
         SPACE
* CONVERT RELATIVE TRACK ADDRESS IN 'TTRN' TO ABSOLUTE SEEK ADDRESS IN
* 'IOBSEEK', USING SUPERVISOR CONVERSION ROUTINE.
         SPACE
EXCP     DS    0H
         STM   R2,R13,EXCPSAVE         SAVE IMPORTANT REGISTERS
         L     R0,TTRN                 LOAD RELATIVE TRACK NUMBER
         L     R1,DCBDEBAD             LOAD DEB ADDRESS
         LA    R2,IOBSEEK              LOAD ADDR TO RECEIVE MBBCCHHR
         L     R15,CVT                 LOAD CVT ADDRESS
         L     R15,CVTPCNVT(R15)       LOAD ADDR OF CONVERT ROUTINE
         BALR  R14,R15                 CONVERT TTRN TO MBBCCHHR
         DROP  8                       THAT CLOBBERED BASE REG
         USING *,R14                   R14 SET BY BALR ABOVE
         LM    R2,R13,EXCPSAVE         RESTORE REGISTERS
         DROP  R14
         USING START,8                 BASE REGISTER RECOVERED
         LTR   R15,R15                 TEST IF EXTENT VIOLATED (RC=4)
         BNZ   SETEOF                  IF SO, MEANS END-OF-FILE
         SPACE
* ZERO ECB AND START CHANNEL PROGRAM.
         SPACE
         SR    R0,R0
         ST    R0,VTOCECB              CLEAR ECB
         NI    MODESW,X'FF'-RDERR      RESET ERROR SWITCH
         EXCP  VTOCIOB                 START CHANNEL PROGRAM
         OI    MODESW,XCPRUN           SET 'RUNNING' FLAG
         BR    R11
         SPACE
* WHEN EXTENT IS VIOLATED, SET END-FILE AND EXIT VIA CLOSE ROUTINE.
         SPACE
SETEOF   OI    MODESW,EOFSW            SET END-OF-FILE BIT
         BR    R11                RETURN TO CALLER
*                                 I THINK GOING TO CLOSESUB SKIPS
*                                 THE LAST DSCB......JAN96
         B     CLOSESUB                EXIT VIA CLOSE SUBROUTINE
         EJECT
********************************
* CONSTANTS, VARIABLES, ETC... *
********************************
         SPACE
INITCCW  CCW   READR0,0,CC+SLI+SKIP,8
READCCW  CCW   READCKD,0,CC,148
         SPACE
DVICETAB DC    X'00',X'00'     TABLE OF NUMBER OF DSCB'S/TRACK
*                              AND OF TRKS/CYL
         DC    AL1(16),X'00'      2311
         DC    AL1(63),X'00'      2301
         DC    AL1(17),X'00'      2303
         DC    AL1(22),X'00'      2302
         DC    AL1(8),X'00'       2321
         DC    X'00',X'00'
         DC    X'00',X'00'
         DC    AL1(25),X'00'      2314
         DC    AL1(39),AL1(19)    3330
         DC    X'00',X'00'
         DC    AL1(47),AL1(30)    3350
         DC    X'00',X'00'
         DC    AL1(39),AL1(19)    3330-1
         DC    AL1(53),AL1(15)    3380                              RH
         DC    AL1(50),AL1(15)    3390                              RH
         DC    AL1(00),AL1(00)    FOR NEW DEVICES                   RH
         DC    AL1(00),AL1(00)    FOR NEW DEVICES                   RH
MAXDVT   EQU   (*-DVICETAB)/2
         SPACE
DWORK    DS    3D              WORK CELL
SAVE4    DC    F'0'
VTCRSAVE DC    20F'0'
EXCPSAVE EQU   VTCRSAVE+12
CBSIZE   DS    2F              SIZE AND LOCATION OF GOTTEN CORE
CBADDR   EQU   CBSIZE+4
NDSCBS   DS    F               NUMBER OF DSCB'S PER TRACK
DSCBSTRT DS    F               ADDRESS OF 1ST DSCB BUFFER
DSCBLIM  DS    F               ADDRESS OF LAST DSCB BUFFER
DSCBADR  DS    F               ADDRESS OF CURRENT DSCB
TTRN     DS    F               RELATIVE TRACK NUMBER
         SPACE
* MODE SWITCH AND BIT DEFINITIONS:
         SPACE
MODESW   DC    X'00'
CBGOT    EQU   X'80'           CORE GOTTEN FOR BUFFER
XCPRUN   EQU   X'40'           CHANNEL PROGRAM STARTED BUT NOT CHECKED
RDERR    EQU   X'20'           PERMANENT I/O ERROR
EOFSW    EQU   X'10'           END-OF-FILE SENSED
         SPACE
MODESW2  DC    X'00'
EOFSW2   EQU   X'10'           END-OF-FILE SENSED
         SPACE
DSCBFLG  DC    F'0'
*        EQU   X'80'           DSCB NOT FOUND FOR DEVICE
         SPACE
* DATA CONTROL BLOCK
         SPACE
VTOCDCB  DCB   DDNAME=VOLUME01,MACRF=(E),EXLST=JFCBADDR
         SPACE
DCBDDNAM EQU   VTOCDCB+40
DCBIFLGS EQU   VTOCDCB+44
DCBDEBAD EQU   VTOCDCB+44
DCBOFLGS EQU   VTOCDCB+48
OPENBIT  EQU   X'10'
         EJECT
* IOB FOR CHANNEL PROGRAM:
         SPACE
VTOCIOB  DS    0D
IOBFLAG1 DC    X'42000000'     COMMAND CHAIN, NOT RELATED
         DC    A(VTOCECB)
         DC    2F'0'
IOBSTART DC    A(0)            CHANNEL PROGRAM BEGINNING
         DC    A(VTOCDCB)
         DC    X'03000000'
         DC    F'0'
IOBSEEK  DC    D'0'            INITIAL SEEK ADDRESS
         SPACE
* EVENT CONTROL BLOCK FOR CHANNEL PROGRAM:
         SPACE
VTOCECB  DC    F'0'            EVENT CONTROL BLOCK
         SPACE 3
* BUFFER FOR JFCB AND DCB EXIT LIST:
         SPACE
JFCBADDR DS    0F
         DC    X'87'
         DC    AL3(JFCB)
         SPACE
JFCB     DS    0D
         DS    CL176
         SPACE
JFCBDSNM EQU   JFCB            DATA SET NAME
JFCBTSDM EQU   JFCB+52         SWITCHES
JFCNWRIT EQU   X'08'           DO NOT WRITE BACK JFCB
JFCBVOLS EQU   JFCB+118        VOLUME SERIAL NUMBER
         SPACE
*
* DSCB I/O AREA AND CONTROL BLOCKS
*
RNAME    DC    CL6' '
FULLDSCB DS    0C
BLKA     DC    XL8'00'
DSCB3    EQU   *                  DSCB3
KEY      DC    CL44' '
DSCB     DC    XL140'00'
         SPACE
F1CAM    CAMLST SEARCH,KEY,RNAME,DSCB
F3CAM    CAMLST SEEK,BLKA+3,RNAME,DSCB3
         SPACE
         LTORG
         END
/*
//LKED.SYSLMOD DD DSN=&&TEMP,UNIT=SYSDA,DISP=(SHR,PASS),
//   SPACE=(TRK,(15,5,5))
//LKED.SYSIN DD *
    SETCODE AC(0)
    MODE    AMODE(31) RMODE(24)
    NAME  VTCREAD(R)
/*
//TSOPUT EXEC HLASMC,PARMC='ESD',CLASS='*',COND=EVEN
//*TEP4 EXEC ASMGCL,PARMC='ESD',PARML='LIST,LET,MAP'
//ASM.SYSPRINT DD SYSOUT=*
//ASM.SYSIN DD *
         TITLE     'PL/1 TSO PUT ROUTINE'
*
*              NOTE.............. ..
*              TSOPUT HAS BEEN MOVED TO DSPART1.
*              THIS COPY IS HERE ONLY AS AN EXAMPLE
*              OF TSOPUT AS A RE- ENTRANT VERSION.
*
*
*  REENTRANT CODE FOR PL/1 TPUT
*
*TSOPUT   CSECT
*         STM       R14,R12,12(R13)
*         LR        BASE,R15
*         USING     TSOPUT,BASE
*         LR        PARMPTR,R1
*         L         R0,ALWORK
*GETWORK  GETMAIN   R,LV=(0)
*         XC        0(LWORK,R1),0(R1)
*         ST        R13,4(R1)
*         ST        R1,8(R13)
*         LR        WORKPTR,R1
*         USING     WORK,WORKPTR
*         L         PARMPTR,0(PARMPTR)
*         USING     SDV,PARMPTR
*         L         R1,SDVADDR
*         LH    R0,0(,R1)
*         LA    R1,2(,R1)
*PUTIT    TPUT      (1),(0),R
*         LR        R1,WORKPTR
*         L         R13,4(WORKPTR)
*         L         R0,ALWORK
*FREEWORK FREEMAIN  R,LV=(0),A=(1)
*         LM        R14,R12,12(R13)
*         BR        R14
*         DS        0D
*ALWORK   DC        AL1(0),AL3(LWORK)
*LITERALS LTORG
*SDV      DSECT
*SDVADDR  DS        A
*SDVMAXL  DS        H
*SDVFLAG  DS        H
**
**    REGISTER EQUATES
*R0       EQU   0
*R1       EQU   1
*R2       EQU   2
*R3       EQU   3
*R4       EQU   4
*R5       EQU   5
*R6       EQU   6
*R7       EQU   7
*R8       EQU   8
*R9       EQU   9
*R10      EQU   10
*R11      EQU   11
*R12      EQU   12
*R13      EQU   13
*R14      EQU   14
*R15      EQU   15
*BASE     EQU   11
*PARMPTR  EQU   10
*WORKPTR  EQU   9
*WORK     DSECT
*SAVEAREA DS        9D
*WORKEND  DS        0D
*LWORK    EQU       WORKEND-WORK
         END
/*
//*
//LINK  EXEC LKED,PARML='LIST,LET,MAP',CLASS='*',COND=EVEN
//LKED.SYSLIB   DD  DISP=SHR,DSN=SYSPP.PLI.PROD.SIBMBASE
//              DD  DISP=SHR,DSN=SYSPP.PLI.PROD.PLILINK
//              DD  DISP=SHR,DSN=SYSPP.LE.PROD.SCEELKED
//LKED.SYSLMOD DD DSN=HALL.LINKLIB,DISP=SHR                FOR TEST
//*KED.SYSLMOD DD DSN=SYS1.DYNAMIC.PROD.LINKLIB,DISP=SHR   FOR PROD
//LKED.LINKMOD DD DSN=&&TEMP,DISP=(OLD,DELETE)
//LKED.SYSIN DD *
    INCLUDE LINKMOD(DSSUPER)
    INCLUDE LINKMOD(HELPPAN)
    INCLUDE LINKMOD(DSPACE1,VTCREAD)
    ENTRY   SPACE
    SETCODE AC(0)
    MODE    AMODE(31) RMODE(24)
    NAME    DS(R)
/*
//* ALIAS DS
//* NAME DSSPART3(R)
//* NAME  DSSUPER(R)
//
//*     END FOR NOW....
//*
//*
//*
//HELP   EXEC PGM=IEBGENER
//SYSPRINT DD SYSOUT=A
//SYSIN DD DUMMY
//SYSUT2 DD SYSOUT=A,DCB=(RECFM=FB,LRECL=80,BLKSIZE=80)
//*SYSUT2 DD DSN=SYS1.HELP(DS),DISP=SHR
//SYSUT1 DD *
)F FUNCTION:
    THE DS COMMAND CAN BE USED TO DISPLAY OR PRINT
    DATA SET CHARACTERISTICS, CURRENT SPACE ALLOCATION
    AND USAGE, TOTALS, AND PERCENT CALCULATION FOR A
    SPECIFIED DATA SET OR GROUP OF DATA SETS AT THE
    TERMINAL, TO A SEQUENTIAL DATA SET, OR TO SYSPRINT
    IF THE DS COMMAND IS RUN IN BATCH.

)X SYNTAX:
    DS 'SEARCH-KEY' VOL('VOL-SER-LIST'/'VOL-SER')
       UNIT('UNIT-NAME') MAX('NNNN') PRINT('DSNAME')
       TOTAL(YES/NO) NOLIST ALLOC('DSN')

   REQUIRED - NONE.
   DEFAULTS - 'SEARCH-KEY' TO USER ID.
              'VOL-SER' TO USERS HIGH LEVEL INDEX VOLUME.
              'UNIT-NAME' TO 'USER'
              'NNNN' TO 100
              'DSNAME' TO TERMINAL (NO FILE)
              TOTAL(YES) IF SEARCH-KEY IS A DATA SET.
              TOTAL(NO) IF SEARCH-KEY IS A HIGH LEVEL INDEX.
              LIST.

   ALIAS - NONE

   TO RUN THE DS COMMAND IN BATCH, THE FOLLOWING JCL
   CAN BE USED :
      //         JOB (PIN,CHGNBR),...ETC.
      /*ROUTE  PRINT  R...      IF DESIRED
      //S0      EXEC PGM=DS,PARM='SEARCH-KEY'
      //SYSPRINT DD  SYSOUT=*
      //
      OR
      //         JOB (PIN,CHGNBR),...ETC.
      /*ROUTE  PRINT  R...      IF DESIRED
      //S0      EXEC PGM=DS
      //SYSPRINT DD  SYSOUT=*
      //SYSIN    DD  *
      HLI
      DSN
      HLI.INDEX.INDEX
      //
   WHEN RUN AS A BATCH JOB, THE SEARCH-KEY IS THE ONLY
   OPERAND THAT WILL BE RECOGNIZED.

)O OPERANDS:
    'SEARCH-KEY' IS A POSITIONAL OPERAND.
  IF ANY KEYWORD OPERANDS ARE SPECIFIED 'SEARCH KEY'
  MUST ALSO BE SPECIFIED.
   'SEARCH-KEY' IS THE KEY ON WHICH DATA SET NAMES
  ARE COMPARED. IF IT IS ENCLOSED IN QUOTES IT WILL BE
  USED AS IS, OTHERWISE THE USERS ID WILL BE
  CONCATENATED TO THE LEFT.
        E.G. - STRING WILL BE 'USERID.STRING'.
  NOTE - SEARCH-KEY CANNOT END WITH A PERIOD (.) .
       - IF SEARCH-KEY IS A HIGH LEVEL INDEX, ALL DATASETS
         CATALOGED UNDER THE HLI WILL BE LISTED.
       - IF SEARCH-KEY IS SPECIFIED AS 'ALL.DSNAMES', ALL
         DATASETS ON THE SPECIFIED VOLUME WILL BE LISTED.
       - IF SEARCH-KEY IS SPECIFIED AS 'ALL.HLI', ALL
         DATASETS BEGINNING WITH 'HLI' ON THE SPECIFIED
         VOLUME WILL BE LISTED.
  DEFAULT - USER'S ID.

))VOL('VOL-SER-LIST'/'VOL-SER')
    'VOL-SER-LIST'/'VOL-SER' - THE VOLUME SERIAL
   OF THE VOLUME OR VOLUMES YOU WISH TO BE SEARCHED
   FOR DATA SETS.
   IF VOL(ALLVOL) IS SPECIFIED, ALL VOLUMES CURRENTLY
   ON-LINE AND AVAILABLE FOR YOUR USE WILL BE SEARCHED.

   DEFAULT - USERS LIBRARY VOLUME.

))UNIT('UNIT-NAME')
    'UNIT-NAME' OF THE DEVICE TO BE SEARCHED.

  DEFAULT - 'USER'

))MAX('NNNN')
    'NNNN' IS THE NUMBER OF DATA SETS THAT FIT THE
   SEARCH KEY THAT YOU WISH TO HAVE LISTED. IF THERE ARE
   MORE DATA SETS THAN YOU SPECIFY A MESSAGE WILL
   INFORM YOU OF THIS.

   DEFAULT - 100.

))PRINT('DSNAME')
    'DSNAME' IS THE DATA SET NAME OF A FILE THAT
     YOU WANT THE DS INFORMATION PRINTED IN.
     THE DCB INFORMATION OF THIS FILE WILL BE CHANGED
     TO DCB=(RECFM=FBA,LRECL=133,BLKSIZE=19019) AND
     ANY DATA IN THIS FILE WILL BE WIPED OUT BY THE DS
     INFORMATION. THIS DATA SET SHOULD NOT BE A MEMBER
     OF A PARTITIONED DATA SET. IT SHOULD ONLY BE A
     SEQUENTIAL DATA SET.

     NOTE : IF THE DATA SET NAME IS NOT ENCLOSED IN
            QUOTES, YOUR USERID WILL AUTOMATICALLY
            BE APPENDED TO THE FRONT OF THE DSN YOU
            HAVE SPECIFIED.

     DEFAULT - NO FILE , IE. PRINT AT TERMINAL.

     EXAMPLE:
     DS 'HLI' PRINT('HLI.DSLIST')
     IN THE ABOVE EXAMPLE, THE DS OUTPUT WOULD BE
     PRINTED ON THE DATASET 'HLI.DSLIST'.

))TOTAL(YES/NO)
    TOTAL CAUSES THE NUMBER OF DATA SETS, TOTAL NUMBER
   OF TRACKS, USED TRACKS, AND EXTENTS TO BE PRINTED.
   IF YES IS SPECIFIED IT WILL ALSO CALCULATE THE
   PERCENTAGE OF TRACKS ALLOCATED TO TRACKS USED AND
   THE RATIO OF DATA SETS TO EXTENTS.

   DEFAULT - YES IF SEARCH-KEY IS A DATASET NAME,
           - NO IF SEARCH-KEY IS A HIGH LEVEL INDEX

))NOLIST
   NOLIST CAUSES ONLY THE TOTAL LINE TO BE PRINTED.

))ALLOC('DSN')
    IF YOU DO NOT KNOW THE VOLSER OF THE VOLUME
    YOU WANT TO SEARCH, 'ALLOC' ALLOWS YOU TO
    POINT TO A VOLUME BY SPECIFYING THE NAME OF
    A CATALOGUED DATA SET.
    'DSN' IS THE FULLY QUALIFIED DATA SET NAME.

   DEFAULT - NONE
/*
//
