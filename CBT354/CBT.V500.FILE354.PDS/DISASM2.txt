//DISASM2 JOB (87944,348496),HALL.S1BL,MSGCLASS=A,
//             USER=RH87944,PASSWORD=*
/*ROUTE  PRINT R7
//STEP1  EXEC HLASMC,CLASS='*',
//            PARMC='SYSPARM(1,ESD)'
//ASM.SYSLIB DD DSN=HALL.DISASM.SOURCE,DISP=SHR
//   DD DSN=SYS1.MACLIB,DISP=SHR
//   DD DSN=SYS1.AMODGEN,DISP=SHR
//ASM.SYSLIN   DD DSN=HALL.OBJECT(DISASM2),DISP=SHR
//ASM.SYSIN DD *
*                                                                   RH
*   MODIFIED JAN 1999 BY RANDY HALL                                 RH
*      HOPEFULLY ALL MODS HAVE "RH" IN COL 69-70...                 RH
*      1) REMOVED MACRO CALL TO "SVLNK" TO USE 3 BASE REGS          RH
*      2) AT LABEL CKLOSEQ, TEST IF PAST END OF LABEL TABLE         RH
*      3) AT LABEL INSTR, HOPEFULLY BEEFED UP INSTRUCTION TESTS     RH
*      4) AT LABEL ICKTBL, TEST IF PAST END OF LABEL TABLE          RH
*         ADD CODE TO CALCULATE OFFSET IN INST TO LABEL,            RH
*         AND  PUT A COMMENT LINE BEFORE THE LABEL, AND             RH
*              PUT THE INSTRUCTION LABEL ON A SEPARATE LINE         RH
*              AS A "DS 0H'                                         RH
*      5) AT LABEL NOTINST, ADD CODE TO SHOW COMMENTS               RH
*      6) AT LABEL CHEX, TEST DATA TYPE                             RH
*      7) AT LABEL CCFWD, ADD CODE TO JOIN MULTIPLE DECLARES        RH
*      8) AT LABEL CDATACON, ADD CODE TO PRINT V TYPE AD CON        RH
*      9) AT LABEL FORCONST, CHECK FOR PSEUDO LABEL                 RH
*     10) AT LABEL FCHAR, ADD CODE TO JOIN MULTIPLE DECLARES        RH
*     11) AT LABEL MVHX, SET UP MULT DC'S EG..DC 4C'AA'             RH
*     12) AT LABEL SSTRT ETC, SET UP ASSEMBLER TYPE ADDR1           RH
*     13) AT LABEL RSBBD ETC, SET UP ASSEMBLER TYPE ADDR2           RH
*     14) AT LABEL EQUSTMT, CHANGE "EQU" STATEMENT OUTPUT           RH
*     15) AT LABEL SCHLBL, ADDED CODE TO BETTER TEST FOR A BASE REG RH
*         ADDED CODE (G10ADDR) TO SHOW DISPLACEMENT AS DECIMAL      RH
*     16) AT LABEL SETSGL, ADDED CODE TO PRINT ASSEMBLER OUTPUT     RH
*         TYPE HEADING ON EACH PAGE                                 RH
*     17) AT LABEL TXTFMT, ADDED CODE (H10OBJEC) TO SET UP          RH
*         ASSEMBLER TYPE OBJECT CODE IN LISTING                     RH
*     18) ADDED MORE CHARACTERS TO "CHARTRAN" TABLE                 RH
*     19) INCLUDE DSECTS FROM SYSLIB WITH "DISASPRM" COPY AT END    RH
*                                                                   RH
*                                                                   RH
DIS2     TITLE '*** DISASSEMBLY PHASE 2 ***'
         MACRO
&NAME    SVLNK &REG1,&REG2,&REG3,&IND,&LV=
         GBLC  &EQU
         GBLC  &GM
         GBLC  &CSECT
         LCLC  &REGA
         AIF   (T'&NAME EQ 'O').NOCSECT
         AIF   ('&NAME' EQ '*').NOCSECT
&CSECT   SETC  '&NAME'
&CSECT   CSECT                         NAME OF PROGRAM
         AGO   .RST
.NOCSECT ANOP
&CSECT   SETC  '*'
         CSECT                         BEGINNING OF PROGRAM
.RST     ANOP
         AIF   ('&EQU' EQ 'ON').NRQ
&EQU     SETC  'ON'
*
***REGISTER EQUATES***
*
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
.NRQ     ANOP
*
*******************  PROGRAM INITIALIZATION  *************************
*
         AIF   (T'&REG1 EQ 'O').NOREG
&REGA    SETC  '&REG1'
         AIF   (T'&REG2 EQ 'O').ONEREG
         USING &CSECT,&REGA,&REG2          ESTABLISH ADDRESSABILITY
         AGO   .BYUSE
.NOREG   ANOP
&REGA    SETC  'R3'
.ONEREG  USING &CSECT,&REGA              ESTABLISH ADDRESSABILITY
.BYUSE   ANOP
         STM   R14,R12,12(R13) :       STORE REGS IN HIGH SAVE AREA
         LR    &REGA,R15                  INITIALIZE BASE REG
         AIF   (T'&REG2 EQ 'O').NOLA
         LA    &REG2,4095(&REGA)       INITIALIZE THE SECOND
         LA    &REG2,1(&REG2)                BASE REGISTER
.NOLA    ANOP
         AIF   (T'&REG3 EQ 'O').NOLNK
         L     &REG3,0(R1)                GET PARAMETER LIST ADDR
.NOLNK   ANOP
         AIF (T'&IND EQ 'O').GETIT
         CNOP  0,4
         BAL   R15,SAVEAREA+72         BRANCH AROUND SAVE AREA
SAVEAREA DS    18F                     REGISTER SAVE AREA
         ST    R15,8(R13)
         ST    R13,SAVEAREA+4
         LR    R13,R15
         AGO   .NOSAVE
.GETIT   ANOP
         AIF   (T'&LV EQ 'O').GMD
&GM      SETC  '&LV'
         AGO   .DGM
.GMD     ANOP
&GM      SETC  '72'
.DGM     ANOP
*
***GET MAIN STORAGE FOR SAVE AREA***
*
         AIF   ('&GM' LT '4096').LA
         GETMAIN R,LV=&GM              GET CORE FOR SAVE AREA
         AGO   .EGM
.LA      ANOP
         LA    R0,&GM                  GET &GM BYTES
         GETMAIN R,LV=(0)
.EGM     ANOP
*
***SET UP SAVE AREA POINTERS***
*
         ST    R1,8(R13)               STORE LOW SAVE POINTER
         ST    R13,4(R1)               STORE HIGH SAVE POINTER
         LR    R13,R1                  INITIALIZE SAVE POINTER
         AIF   (T'&REG3  NE 'O').NOSAVE
         L     R1,4(R13)               GET POINTER TO RESTORE PARA REG
         L     R1,24(R1)               RESTORE PARAMETER REGISTER
.NOSAVE  ANOP
         AIF   ('&CSECT' EQ '*').EXIT
         B     *+12
         DC    CL8'&CSECT'             END INITIAL., BEGIN THIS PROG.
.EXIT    ANOP
*
*********************  END INITIALIZATION  ***************************
*
         MEND
         EJECT
*ISASM2  SVLNK R3,R4
DISASM2  CSECT                         NAME OF PROGRAM
*
***REGISTER EQUATES***
*
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
*
*******************  PROGRAM INITIALIZATION  ************************
*
         USING DISASM2,R15                 ESTABLISH ADDRESSABILITY
         STM   R14,R12,12(R13) :       STORE REGS IN HIGH SAVE AREA
*
***SET UP SAVE AREA POINTERS***
*
         LA    R1,SAVEAREA        R1 -> TO MY SAVEAREA              RH
         ST    R1,8(R13)               STORE LOW SAVE POINTER       RH
         ST    R13,4(R1)               STORE HIGH SAVE POINTER      RH
         LR    R13,R1                  INITIALIZE SAVE POINTER      RH
         L     R1,4(R13)               GET POINTER TO RESTORE PARM  RH
         L     R1,24(R1)               RESTORE PARAMETER REGISTER   RH
         B     CONTINUE                                             RH
         DC    CL8'DISASM2'            END INITIAL., BEGIN THIS PROG.H
SAVEAREA DC    18F'-1'            MY SAVE AREA                      RH
CONTINUE DS    0H                                                   RH
         DROP  R15                DROP TEMP BASE                    RH
         USING SAVEAREA,R13,R3,R4 SET NEW BASES                     RH
         LA    R3,4095(0,R13)     SET BASE REG 2                    RH
         LA    R3,1(0,R3)         ''                                RH
         LA    R4,4095(R3)             INITIALIZE THE THIRD         RH
         LA    R4,1(R4)                      BASE REGISTER          RH
*
*********************  END INITIALIZATION  **************************
*
         PRINT NOGEN
* THIS SUB-PROGRAM IS CALLED BY DISASM AFTER THE DIRECTORY
* ENTRY AND LOAD MODULE ARE PROCESSED. THE ESD AND RLD
* ENTRIES HAVE BEEN USED TO CREATE A PROGRAM LABEL TABLE,
* AND MODULE TEXT IS IN AN AREA OF STORAGE. A COMMON PARAMETER
* AREA IS DEFINED IN DISASM, AND PASSED TO THIS PROGRAM.
*
* TEXT BYTES ARE USED TO CREATE ASSEMBLY LANGUAGE STATEMENTS,
* AND MACHINE INSTRUCTION STATEMENTS. OUTPUT IS WRITTEN
* TO THE WORK1 DATASET FOR FURTHER PROCESSING BY OTHER
* MODULES.
*   A TEXT BYTE IS CONSIDERED TO BE AN INSTRUCTION IF
* IT OCCURS ON A HALFWORD BOUNDARY, IS A VALID OP-CODE,
* AND IS FOLLOWED BY A VALID OP-CODE. UNCONDITIONAL BRANCHES
* NEED NOT BE FOLLOWED BY A VALID OP-CODE, HOWEVER. THE
* PRIVILEGED AND FLOATING POINT INSTRUCTIONS ARE NOT
* TREATED AS INSTRUCTIONS UNLESS THE USER SPECIFIED
* THEIR INCLUSION AT EXEC TIME.
*
*
*
*
* AUTHOR R THORNTON - NOV 1977
* UPDATED ROBERT STYMA - JAN 1989 AND MARCH 1991
* UPDATED ALAN C FIELD - APR 1990
*
*
******************************************************************
*                                                                *
* CHECK IF USER WISHES FLOATING POINT AND PRIVILEGED INSTRUCTIONS*
* IF NOT, CLEAR THE APPROPRIATE ENTRIES IN THE INSTRUCTION OP    *
* CODE TABLES.                                                   *
*                                                                *
******************************************************************
*
         L     R5,0(R1)                GET PARM FIELD ADDRESS
         USING COMMPARM,R5
         CLI   FLPTASM,1               FLOATING POINT INSTR O.K.
         BE    TSTPRIV                 YES
         LA    R12,SGLOP               POINT TO OP-CODE TBL
TSTOPND  CLI   0(R12),X'FF'            END OF TBL
         BE    TSTPRIV                 YES
         TM    ICLASS-INSTENT(R12),FLTPT IS IT FLOATING POINT
         BZ    FLPSTP                  NO
         XC    0(L'SGLOP,R12),0(R12)   CLEAR ENTRY
FLPSTP   LA    R12,L'SGLOP(R12)        TO NEXT ENTRY
         B     TSTOPND                 LOOP THRU TABLE
TSTPRIV  CLI   PRIVASM,1               PRIVILEGED INSTR O.K.
         BE    MAINLINE                YES
         LA    R12,SGLOP               POINT TO OP-CODE TBL
TTOPND   CLI   0(R12),X'FF'            END OF TABLE
         BE    CKDBLS                  YES
         TM    ICLASS-INSTENT(R12),PRIV PRIVILEGED INSTR
         BZ    PRIVSTP                 NO
         XC    0(L'SGLOP,R12),0(R12)   YES, CLEAR ENTRY
PRIVSTP  LA    R12,L'SGLOP(R12)        TO NEXT ENTRY
         B     TTOPND                  LOOP THRU TABLE
CKDBLS   L     R12,DBLOPAD             @ 2-BYTE OP-CODE TBL
CKDBND   CLI   0(R12),X'FF'            END OF TBL
         BE    MAINLINE                YES
         TM    ICLASS-INSTENT+2(R12),PRIV PRIVILEGED OP-CODE
         BZ    DBSTP                   NO
         XC    0(L'DBLOP,R12),0(R12)   YES, CLEAR ENTRY
DBSTP    LA    R12,L'DBLOP(R12)        TO NEXT ENTRY
         B     CKDBND                  LOOP THRU TABLE
*
*
*
******************************************************************
*                                                                *
* MAINLINE ROUTINE FOR DISASSEMBLY. EACH BYTE OF TEXT IS CHECKED *
* TO DETERMINE WHETHER IT MAY BE AN INSTRUCTION OP-CODE. IF NOT, *
* THE CONST ROUTINE IS PERFORMED TO HANDLE CONSTANT DATA. IF IT  *
* APPEARS TO BE AN OP-CODE, THE INSTR ROUTINE IS PERFORMED.      *
* WHEN TEXT IS EXHAUSTED, THIS PHASE TERMINATES.                 *
*                                                                *
******************************************************************
*
MAINLINE EQU   *                       MAINLINE ROUTINE
         L     R6,LBLTBL               @ LABEL TABLE
         USING LABELD,R6
         MVC   TXTCURR,TXTSTRT         COPY TEXT START ADDR
GETCURR  L     R7,TXTCURR              @ CURRENT TXT BYTE
         C     R7,TXTEND               END OF TEXT
         BNL   EOJ                     YES          FIX******
         LR    R12,R7                  COPY TEXT ADDR
         S     R12,TXTSTRT             COMPUTE OFFSET
         ST    R12,TXTOFST             SAVE OFFSET TO THIS BYTE
         CLC   NEXCHG,TXTOFSET         TIME TO CHANGE BASES
         BH    CKDARNG                 NO
         BAL   R9,NEXUSG               YES, GO DO IT
CKDARNG  L     R12,DATONLY             GET DATA ONLY TBL ADDR
         CLC   TXTOFSET,0(R12)         RANGE BEGINS LATER
         BL    CKLOSEQ                 YES
         CLC   TXTOFSET,3(R12)         THIS BYTE IN THE RANGE
         BNH   CONST                   YES
         LA    R12,6(R12)              PAST THIS ENTRY, STEP OVER 1
         ST    R12,DATONLY             SAVE UPDATED ADDR
         B     CKDARNG                 GO CHECK AGAIN
CKLOSEQ  CLC   TXTOFSET,LBLADR         LABEL ENTRY OUT OF SEQ
         BNH   GCKODD                  NO, CONTINUE
         C     R6,CURRLBL         ARE WE PAST LAST LABEL IN TABLE?  RH
         BNL   GCKODD             YES                               RH
         BAL   R9,FORCONST             YES, FORCE ANY CONSTANT OUT
         MVC   NAME,LBLNAME            NAME TO OUTPUT
         MVC   MNEMONIC,=CL5'EQU'      MNEMONIC
         MVI   OPNDS,C'*'              OPERAND
         MVC   COMMENT(14),=14C'?'     SHOW ERROR
         BAL   R9,WRTOUT               WRITE ERROR RECORD
         BAL   R9,PRINT                GO PRINT IT
         LA    R6,L'LABEL(R6)          TO NEXT LABEL
         B     CKLOSEQ                 CONTINUE SEQ CHK
GCKODD   TM    TXTCURR+3,1             ODD ADDRESS
         BO    CONST                   YES, NOT INSTR
         CLC   1(3,R7),0(R7)           4 CONSEC IDENTICAL BYTES
         BE    CONST                   YES, NOT INSTR
         TRT   0(1,R7),CHARTRAN        TEST TEXT BYTE
         BNZ   CKINSTR                 NOT CHARACTER
         CLI   CONPROG,1               IS CONSTANT IN PROGRESS
         BNE   CK6                     NO
         CLI   CONTYPE,C'C'            IS IT CHARACTER TYPE
         BE    CONST                   YES, ADD THIS TO CONSTANT
CK6      TRT   0(6,R7),CHARTRAN        6 CONSECUTIVE CHARACTERS
         BZ    CONST                   YES, NOT INSTRUCTION
CKINSTR  SR    R8,R8                   CLEAR WORK
         IC    R8,0(R7)                PICK UP TXT BYTE
         MH    R8,SGOPLEN              TIMES TABLE LENGTH
         LA    R8,SGLOP(R8)            @ INSTR TBL ENTRY
         MVC   INSTENT,0(R8)           SAVE INSTRUCTION TBL ENTRY
         CLI   INAME,0                 IS IT AN INSTR OP-CODE
         BE    CONST                   NO
         CLI   ITYPE,TWO               TWO-BYTE OP-CODE
         BNE   INSTR                   NO
         L     R8,DBLOPAD              YES, GET 2-BYTE TBL ADDR
DBLND    CLI   0(R8),X'FF'             END OF TABLE
         BE    CONST                   YES, NOT INSTR
         CLC   0(2,R8),0(R7)           THIS ENTRY MATCHES TXT
         BE    GOTDBLI                 YES
         LA    R8,L'DBLOP(R8)          TO NEXT ENTRY
         B     DBLND                   LOOP THRU TBL
GOTDBLI  LA    R8,2(R8)                PASS OP-CODE BYTES
         MVC   INSTENT,0(R8)           SAVE INSTR TBL ENTRY
*
*
*
******************************************************************
*                                                                *
* THIS ROUTINE IS ENTERED WHEN CURSORY CHECKS IN THE MAINLINE    *
* INDICATE THIS TEXT BYTE IS AN INSTRUCTION OP-CODE. FURTHER     *
* TESTING IS DONE BY THE IVERFY (NON-FLOATING POINT), OR FPVERFY *
* (FLOATING POINT) ROUTINES. BYTES PASSING THESE TESTS ARE       *
* ACCEPTED AS OP-CODES, AND ARE PASSED TO THE APPROPRIATE FORMAT *
* ROUTINES. FORMAT ROUTINES ARE ENTERED VIA A BRANCH TABLE USING *
* A BYTE IN THE INSTRUCTION OP-CODE TABLE ENTRY.                 *
*                                                                *
******************************************************************
*
INSTR    EQU   *                       *** INSTRUCTIONS (POSSIBLY) ***
*                                                                   RH
*                                 CHECK THIS INSTRUCTION            RH
*                                                                   RH
         AGO   .B2
         CLI   0(R7),X'B2'        IS IT A X'B2' INSTR?              RH
         BNE   INSTR1             NO, ON WE GO                      RH
         CLI   1(R7),X'13'        YES, OVER VALID TYPE CODE?        RH
         BH    CONST              YES, IT'S NOT A B2 INSTR THEN     RH
*                                                                   RH
*              SET UP B2 OP CODE                                    RH
*                                                                   RH
         SR    R12,R12            CLEAR R12                         RH
         IC    R12,1(R7)          R12 = TYPE CODE                   RH
         MH    R12,=H'5'          MULT BY TABLE ENTRY LTH           RH
         LA    R12,B2TABLE(R12)   R12 -> TO B2 OP CODE              RH
         MVC   INAME,0(R12)       SET UP REAL BE MNEMONIC           RH
         B     INSTR2             ON WE GO                          RH
         SPACE 1                                                    RH
INSTR1   DS    0H                      *** INSTRUCTIONS (POSSIBLY)  RH
.B2      ANOP
         CLI   0(R7),X'80'        IS IT AN SSM INSTR?               RH
         BNE   INSTR2             NO, ON WE GO                      RH
         CLI   1(R7),X'00'        YES, IS THERE A BASE REG?         RH
         BE    CONST              NO, IT'S NOT AN SSM INSTR THEN    RH
         SPACE 1                                                    RH
INSTR2   DS    0H                      *** INSTRUCTIONS (POSSIBLY)  RH
*                                                                   RH
*                                 CHECK NEXT INSTRUCTION            RH
*                                                                   RH
         MVC   ILENG+1(1),INLNG        SET INSTR LENGTH
         LH    R12,ILENG               PICK UP LENGTH
         AR    R12,R7                  ADDR OF NEXT OP CODE
         SR    R15,R15                 CLEAR WORK
         IC    R15,0(R12)              PICK UP NEXT OP-CODE
         MH    R15,SGOPLEN             TIMES TBL ENTRY LENG
         LA    R15,SGLOP(R15)          INSTR TBL ENTRY ADDR
         CLI   INAME-INSTENT(R15),0    IS IT AN OP-CODE
         BNE   ICKSEC                  YES
*                                                                   RH
*              CHECK 2ND BYTE ALONG FOR INSTRUCTION                 RH
*                                                                   RH
         AH    R15,SGOPLEN        R15 -> TO NEXT BYTE               RH
         AH    R15,SGOPLEN        R15 MAY -> TO NEXT INST           RH
         CLI   INAME-INSTENT(R15),0    IS IT AN OP-CODE             RH
         BNE   ICKSEC                  YES                          RH
*                                                                   RH
*                                 CHECK FIRST INSTRUCTION           RH
*                                                                   RH
*        CLI   0(R7),X'45'             IS IT BAL
*        BE    ICKTBL                  YES, CONTINUE
*        CLI   0(R7),X'0B'             IS IT BSM
*        BE    ICKTBL                  YES, CONTINUE
*        CLI   0(R7),X'4D'             IS IT BAS
*        BE    ICKTBL                  YES, CONTINUE
         SPACE 1                                                    RH
         LR    R12,R7             R12 -> TO FIRST INSTRUCTION       RH
         B     ICKSEC2            GO CHECK THIS INST                RH
         SPACE 1                                                    RH
*        CLI   0(R7),7                 NO, IS IT BCR
*        BE    POSSB                   YES
*        CLI   0(R7),X'47'             IS IT BC
*        BNE   CONST                   NO, THEN THIS NOT INSTR
*OSSB    TM    1(R7),X'F0'             IS IT UNCONDL BRCH
*        BNO   CONST                   NO, THEN THIS NOT INSTR
*        B     ICKTBL                  ACCEPT UNCOND BRCHS
*                                                                   RH
*                                 CHECK THIRD INSTRUCTION           RH
*                                                                   RH
ICKSEC   SR    R1,R1                   CLEAR WORK
         IC    R1,INLNG-INSTENT(R15)   GET INSTR LENGTH
         AR    R1,R12                  ADDR OF NEXT OP CODE
         SR    R14,R14                 CLEAR WORK
         IC    R14,0(R1)               PICK UP NEXT OP-CODE
         MH    R14,SGOPLEN             TIMES TBL ENTRY LENG
         LA    R14,SGLOP(R14)          INSTR TBL ENTRY ADDR
         CLI   INAME-INSTENT(R14),0    IS IT AN OP-CODE
         BNE   ICKTBL                  YES
*                                                                   RH
*                                 CHECK 1ST INSTRUCTION             RH
*                                                                   RH
*        CLI   0(R7),X'45'        IS FIRST INST A BAL?              RH
*        BE    ICKTBL             YES, CONTINUE                     RH
         CLI   0(R7),X'05'             NO, IS IT BALR?              RH
         BE    ICKTBL                  YES                          RH
         CLI   0(R7),X'06'             NO, IS IT BCTR?              RH
         BE    ICKTBL                  YES                          RH
         CLI   0(R7),X'07'             NO, IS IT BCR?               RH
         BE    ICKTBL                  YES                          RH
         CLI   0(R7),X'45'             IS IT BAL                    RH
         BE    ICKTBL                  YES, CONTINUE                RH
         CLI   0(R7),X'46'             IS IT BCT?                   RH
         BE    ICKTBL                  YES, CONTINUE                RH
         CLI   0(R7),X'47'             IS IT BC?                    RH
         BE    ICKTBL                  YES                          RH
         CLI   0(R7),X'86'             IS IT BXH?                   RH
         BE    ICKTBL                  YES, CONTINUE                RH
         CLI   0(R7),X'87'             IS IT BXLE?                  RH
         BE    ICKTBL                  YES                          RH
*                                                                   RH
*                                 CHECK 1ST OR 2ND INSTRUCTION      RH
*                                                                   RH
ICKSEC2  DS    0H                                                   RH
         CLI   0(R12),X'05'            NO, IS IT BALR?              RH
         BE    ICKTBL                  YES                          RH
         CLI   0(R12),X'06'            NO, IS IT BCTR?              RH
         BE    ICKTBL                  YES                          RH
         CLI   0(R12),X'07'            NO, IS IT BCR?               RH
         BE    POSSB2                  YES                          RH
         CLI   0(R12),X'45'            IS IT BAL                    RH
         BE    ICKTBL                  YES, CONTINUE                RH
         CLI   0(R12),X'46'            IS IT BCT?                   RH
         BE    ICKTBL                  YES, CONTINUE                RH
         CLI   0(R12),X'47'            IS IT BC?                    RH
         BE    POSSB3                  YES                          RH
         CLI   0(R12),X'86'            IS IT BXH?                   RH
         BE    ICKTBL                  YES, CONTINUE                RH
         CLI   0(R12),X'87'            IS IT BXLE?                  RH
         BNE   CONST                   NO, THEN THIS NOT INSTR
         SPACE 1                                                    RH
POSSB2   DS    0H                 CHECK MASK FOR BCR INST           RH
         TM    1(R12),X'F0'       IS IT UNCONDL BRCH                RH
         BO    ICKTBL             YES                               RH
         TM    1(R12),X'E0'       IS IT A BNO ?                     RH
         BO    ICKTBL             YES                               RH
         TM    1(R12),X'D0'       IS IT A BNH/BNP ?                 RH
         BO    ICKTBL             YES                               RH
         TM    1(R12),X'B0'       IS IT A BNL/BNM ?                 RH
         BO    ICKTBL             YES                               RH
         TM    1(R12),X'80'       IS IT A BE/BZ ?                   RH
         BO    ICKTBL             YES                               RH
         TM    1(R12),X'70'       IS IT A BNE/BNZ ?                 RH
         BM    ICKTBL             YES                               RH
         TM    1(R12),X'40'       IS IT A BL/BM ?                   RH
         BO    ICKTBL             YES                               RH
         TM    1(R12),X'20'       IS IT A BH/BP ?                   RH
         BO    ICKTBL             YES                               RH
         SPACE 1                                                    RH
         TM    1(R12),X'10'       IS IT A NOP?                      RH
         BZ    ICKTBL             YES                               RH
         BO    ICKTBL             NO, BUT ITS A BO                  RH
         SPACE 1                                                    RH
         B     CONST              NOT AN INST                       RH
         SPACE 1                                                    RH
POSSB3   DS    0H                 CHECK MASK FOR BC INST            RH
         TM    1(R12),X'0F'       OVER X...0?                       RH
         BM    CONST              YES, NOT AN INST                  RH
         SPACE 1                                                    RH
         CLI   1(R12),X'10'            IS IT A NOP?                 RH
         BL    ICKTBL             YES                               RH
         BE    ICKTBL             NO, BUT ITS A BO                  RH
         SPACE 1                                                    RH
         CLI   1(R12),X'20'       IS IT A BH/BP ?                   RH
         BE    ICKTBL             YES                               RH
         CLI   1(R12),X'40'       IS IT A BL/BM ?                   RH
         BE    ICKTBL             YES                               RH
         CLI   1(R12),X'70'       IS IT A BNE/BNZ ?                 RH
         BE    ICKTBL             YES                               RH
         SPACE 1                                                    RH
         CLI   1(R12),X'80'       IS IT A BE/BZ ?                   RH
         BE    ICKTBL             YES                               RH
         CLI   1(R12),X'B0'       IS IT A BNL/BNM ?                 RH
         BE    ICKTBL             YES                               RH
         CLI   1(R12),X'D0'       IS IT A BNH/BNP ?                 RH
         BE    ICKTBL             YES                               RH
         CLI   1(R12),X'E0'       IS IT A BNO ?                     RH
         BE    ICKTBL             YES                               RH
         CLI   1(R12),X'F0'       IS IT UNCONDL BRCH
         BNE   CONST              NO, THEN THIS NOT INSTR
ICKTBL   LH    R12,ILENG               GET INSTR LENGTH
         AR    R12,R7                  @ NEXT TEXT LOC
         BCTR  R12,R0                  BACK UP 1
         S     R12,TXTSTRT             RELATIVIZE IN CSECT
         CLM   R12,7,LBLADR            LBL TBL ADDR HERE
         BL    NOILBL                  NO
         C     R6,CURRLBL         ARE WE PAST LAST LABEL IN TABLE?  RH
         BNL   NOILBL             YES                               RH
*        CLC   TXTOFSET,LBLADR         LABEL AT INSTR START         RH
*        BNE   NOTINST                 NO, MUST BE CONSTANT   FIX** RH
         CLI   LBLTYP,C'L'             IS IT A LABEL ONLY
         BNE   NOTINST                 NO                        FIX***
         CLI   CONPROG,1               CONSTANT IN PROGRESS
         BNE   CKLBLNG                 NO
         BAL   R9,FORCONST             YES, FORCE IT OUT
         SPACE 1                                                    RH
CKLBLNG  DS    0H                                                   RH
         SPACE 1                                                    RH
         CLC   TXTOFSET,LBLADR    LABEL AT INSTR START              RH
         BE    SETLBL             YES                               RH
*        BE    SAMELTH            YES                               RH
*                                                                   RH
*              CALCULATE OFFSET IN INST TO LABEL                    RH
*                                                                   RH
         SR    R9,R9              CLEAR R9                          RH
         SR    R15,R15            CLEAR R15                         RH
         ICM   R15,7,LBLADR       R15 = LABEL ADDRESS               RH
         ICM   R9,7,TXTOFSET      R9 = LABEL OFFSET                 RH
         SR    R15,R9             R15 = OFFSET TO LABEL             RH
         STC   R15,LBLLEN         SAVE LABEL OFFSET                 RH
         MVI   LBLOFSET,X'FF'     SAY WE NEED AN EQU+1              RH
         SPACE 1                                                    RH
SAMELTH  DS    0H                                                   RH
*                                                                   RH
         CLC   LBLLEN,INLNG            LENGTHS SAME
         BE    SETLBL                  YES
         CLI   LBLLEN,0                DON'T CARE LENGTH
         BE    SETLBL                  YES
         BAL   R9,EQUSTMT              NO, BUILD EQU STATEMENT
         B     ISTPLBL                 CONTINUE
*                                                                   RH
*              PUT A COMMENT LINE BEFORE THE LABEL, AND             RH
*              PUT THE INSTRUCTION LABEL ON A SEPARATE LINE         RH
*              AS A "DS 0H'                                         RH
*                                                                   RH
SETLBL   DS    0H                                                   RH
         MVI   NAME,C'*'               SET UP A "BLANK" LINE        RH
         BAL   R9,WRTOUT               WRITE PUNCH RECORD           RH
         BAL   R9,PRINT                GO PRINT IT                  RH
         MVC   NAME,LBLNAME            LABEL ENTRY NAME TO INSTR
         MVC   CONLEN,LBLLEN           SET CONSTANT LENGTH IN CASE
         MVC   MNEMONIC,=CL5'DS '      MNEMONIC                     RH
         MVC   OPNDS(2),=C'0H'         OPERAND                      RH
         BAL   R9,WRTOUT               WRITE PUNCH RECORD           RH
         BAL   R9,PRINT                GO PRINT IT                  RH
         SPACE 1                                                    RH
ISTPLBL  DS    0H                                                   RH
         LR    R9,R6                   GET TEMP COPY OF LABEL TAB ENT
         LA    R6,L'LABEL(R6)          TO NEXT LABEL TBL ENTRY
         CLC   LBLADR(3),LBLADR-LABEL(R9)  THIS ENTRY SAME ADDR?
         BNE   ICKTBL                  NO
         LR    R6,R9                   BACK UP TO PREV ENTRY
         C     R6,CURRLBL         ARE WE PAST LAST LABEL IN TABLE?  RH
         BNL   NOILBL             YES                               RH
         CLC   TXTOFSET,LBLADR    THIS ENTRY SAME ADDR?             RH
*        CLM   R6,7,LBLADR             THIS ENTRY SAME ADDR
         BNE   ICKTBL                  NO
         SH    R6,LBLLGTH              BACK UP TO 1ST ENTRY
         BAL   R9,EQUSTMT              GO BUILD EQU STATEMENT
         LA    R6,L'LABEL(R6)          TO NEXT ENTRY
         B     ICKTBL                  GO CHECK NEXT LABEL
NOILBL   CLI   CONPROG,1               CONSTANT IN PROGRESS
         BNE   MVMNE                   NO
         BAL   R9,FORCONST             YES, FORCE IT OUT
MVMNE    MVC   MNEMONIC,0(R8)          SET INSTR MNEMONIC
         MVC   OFFSET,TXTOFSET         SET OFFSET
         MVC   INSTYP,5(R8)            SET INSTR TYPE
         MVI   TYPE,X'0D'              SHOW IT IS AN INSTRUCTION
         MVC   LEN,ILENG+1             SHOW LENGTH
         MVC   TEXT(6),0(R7)           MOVE ACTUAL TEXT
OPNDFMT  TM    ICLASS,FLTPT            FLOATING POINT OP-CODE
         BO    FPVERFY                 YES, GO VERIFY
         CLI   IEDT,0                  ANY EDIT REQUIRED
         BE    PFMFMT                  NO
         B     IVERFY                  YES, GO EDIT
PFMFMT   SR    R1,R1                   CLEAR WORK
         IC    R1,INSTYP               GET INSTRUCTION TYPE
         L     R9,OPND9                GET FORMAT ROUTINE RETURN ADDR
         B     *+4(R1)                 TO APPROPRIATE FORMATTING ROUTIN
         B     RROPND                  TYPE=0, RR
         B     RXOPND                  TYPE=4, RX
         B     SOPND                   TYPE=8, S
         B     SIOPND                  TYPE=C, SI
         B     RSOPND                  TYPE=10, RS
         B     SS1OPND                 TYPE=14, 1-LENGTH SS
         B     SS2OPND                 TYPE=18, 2-LENGTH SS
         B     SOPND                   TYPE=1C, 2-BYTE OP-CODES
         B     BCOPND                  TYPE=20, CONDITIONAL BRANCH
         B     SVCOPND                 TYPE=24, SVC
         B     SSEOPND                 TYPE=28, SSE
         B     EOPND                   TYPE=2C, E
         B     RROPND                  TYPE=30, RRE 1 OPERAND
         B     RROPND                  TYPE=34, RRE 2 OPERANDS
OPNDRTN  B     INSTOUT                 NORMAL OPERAND FORMAT RETURN
         MVC   CONNAME,NAME            ANY NAME TO CONSTANT AREA
         B     CONST                   ERROR INSTRUCTION, TREAT AS CONS
NOTINST  CLC   NAME,BLANX              IS NAME FILLED IN?        FIX***
         BE    CONST                                             FIX***
         SH    R6,LBLLGTH              BACK UP                   FIX***
         B     CONST                                             FIX***
         SPACE 1                                                    RH
INSTOUT  DS 0H                                                      RH
         CLI   DCINST,C'D'        WAS PREV INST A DC ?              RH
         BNE   INSTOUT2           NO                                RH
         LH    R9,ILENG           R9 = LTH OF THIS INST             RH
         BCTR  R9,0               R9 = HEX LTH                      RH
         EX    R9,TRTTEXT         TEST TEXT                         RH
*RTTEXT  TRT   TEXT(0),HEXTRAN    TEST TEXT BYTE                    RH
         BNZ   INSTOUT2           NOT CHARACTER                     RH
         EX    R9,MVCTEXT         SET UP TEXT AS COMMENT            RH
         SPACE 1                                                    RH
INSTOUT2 DS 0H                                                      RH
         BAL   R9,WRTOUT               WRITE INSTRUCTION RECORD
         BAL   R9,TXTFMT               FORMAT HEX DATA
         BAL   R9,PRINT                GO PRINT IT
         MVI   DCINST,C' '        SAY WE DID A REAL INST            RH
         AH    R7,ILENG                STEP TO NEXT TEXT BYTE
         ST    R7,TXTCURR              SAVE NEXT ADDR
         MVC   CCTYPE,ICCSET           SHOW COND CODE SET TYPE
         B     GETCURR                 CONTINUE TXT PROCESSING
*
TRTTEXT  TRT   TEXT(0),HEXTRAN    TEST TEXT BYTE                    RH
MVCTEXT  MVC   COMMENT(0),TEXT    SET UP COMMENT                    RH
*
*
*
******************************************************************
*                                                                *
* THIS ROUTINE IS ENTERED FROM THE INSTR ROUTINE FOR NON FLOATING*
* POINT INSTRUCTIONS. VARIOUS EDITS ARE PERFORMED TO INSURE THE  *
* INPUT TEXT BYTE IS AN OP-CODE. IF IT IS, RETURN IS TO LABEL    *
* PFMFMT, OTHERWISE THE CONST ROUTINE IS PERFORMED.              *
*                                                                *
******************************************************************
*
IVERFY   EQU   *                       *** VERIFY POSSIBLE INSTRUCTION
         TM    IEDT,EPR                EVEN-ODD REG PAIR
         BZ    IVE2                    NO
         TM    1(R7),X'10'             R1 IS ODD
         BO    CONST                   YES, NOT INSTR
         CLI   0(R7),X'0E'             IS IT MVCL
         BE    IVTRG2                  YES
         CLI   0(R7),X'0F'             IS IT CLCL
         BNE   IVE2                    NO
IVTRG2   TM    1(R7),X'01'             R2 IS ODD
         BO    CONST                   YES, NOT INSTR
         SR    R1,R1                   CLEAR WORK
         SR    R2,R2                   CLEAR WORK
         IC    R1,1(R7)                GET R1R2
         SRL   R1,4                    SHIFT OUT R2
         PACK  DBLWD(1),1(1,R7)        FLIP R1R2 BYTE
         IC    R2,DBLWD                PICK UP R2R1
         SRL   R2,4                    SHIFT OUT R1
         CR    R1,R2                   R1=R2
         BE    CONST                   YES, NOT INSTR
         B     PFMFMT                  NO, GOOD INSTR
IVE2     TM    IEDT,E2                 HALFWORD STORAGE ALIGNMENT
         BZ    IVE4                    NO
         TM    3(R7),X'01'             DISPL IS ODD
         BZ    IVES2                   NO, O.K.
         TM    2(R7),X'F0'             BASE REG = 0
         BNZ   IVES2                   NO, CONTINUE
         CLI   0(R7),X'44'             EX OP CODE
         BE    CONST                   YES, NOT INSTR
         CLI   0(R7),X'47'             BC OP CODE
         BE    CONST                   YES, NOT INSTR
         CLI   ITYPE,RS                RS INSTRUCTION
         BE    CONST                   YES, NOT INSTR
         TM    1(R7),X'0F'             INDEX REG IS 0
         BZ    CONST                   YES, NOT INSTR
         B     IVES2                   CONTINUE
IVE4     TM    IEDT,E4                 2ND OPND ON FULLWORD BOUND
         BZ    IVE8                    NO
         TM    3(R7),X'03'             DISPL DIV BY 4
         BZ    IVES2                   YES, O.K.
         TM    2(R7),X'F0'             BASE REG = 0
         BNZ   IVES2                   NO, CONTINUE
         CLI   ITYPE,RS                RS INSTRUCTION OP CODE
         BE    CONST                   YES, NOT INSTR
         TM    1(R7),X'0F'             INDEX REG = 0
         BZ    CONST                   YES, NOT INSTR
         B     IVES2                   NO, CONTINUE
IVE8     TM    IEDT,E8                 2ND OPND ON DBLWD BOUND
         BZ    IVES2                   NO
         TM    3(R7),X'07'             DISPL DIV BY 8
         BZ    IVES2                   YES, O.K.
         TM    2(R7),X'F0'             BASE REG = 0
         BNZ   IVES2                   NO
         TM    1(R7),X'0F'             INDEX REG = 0
         BZ    CONST                   YES, NOT INSTR
IVES2    CLI   PRIVASM,1               PRIVILEGED INSTR O.K.
         BE    PFMFMT                  YES
         TM    IEDT,S2                 OPND2 MUST HAVE BASE
         BZ    IVES1                   NO
         TM    2(R7),X'F0'             BASE REG = 0
         BNZ   PFMFMT                  NO, O.K.
         CLI   ITYPE,RS                RS INSTRUCTION
         BE    CONST                   YES, NOT INSTR
         CLI   0(R7),X'92'             IS IT MVI OP CODE
         BE    CONST                   YES, NOT INSTR
         TM    1(R7),X'0F'             INDEX REG = 0
         BZ    CONST                   YES, NOT INSTR
         B     PFMFMT                  NO, GOOD INSTR
IVES1    TM    IEDT,S1                 1ST OPND MUST HAVE BASE
         BZ    PFMFMT                  NO, CONTINUE
         TM    2(R7),X'F0'             1ST OPND HAS BASE
         BZ    CONST                   NO, NOT INSTR
         B     PFMFMT                  YES, INSTR O.K.
*
*
*
******************************************************************
*                                                                *
* THIS ROUTINE IS ENTERED FROM THE INSTR ROUTINE FOR FLOATING    *
* POINT INSTRUCTIONS. VARIOUS EDITS ARE PERFORMED TO INSURE THE  *
* INPUT TEXT BYTE IS AN OP-CODE. IF IT IS, RETURN IS TO LABEL    *
* PFMFMT, OTHERWISE THE CONST ROUTINE IS PERFORMED.              *
*                                                                *
******************************************************************
*
FPVERFY  EQU   *                       *** VALIDATE FLOATING POINT OP-C
         TM    1(R7),X'90'             R1 IS 0, 2, 4, OR 6
         BNZ   CONST                   NO, NOT INSTR
         CLI   0(R7),X'27'             MXDR OP-CODE
         BE    FPR1EXT                 YES
         CLI   0(R7),X'67'             MXD OP-CODE
         BNE   FPCKTYP                 NO
FPR1EXT  TM    1(R7),X'B0'             R1 IS 0 OR 4
         BNZ   CONST                   NO, NOT INSTR
FPCKTYP  CLI   ITYPE,RR                RR TYPE INSTRUCTION
         BNE   FPRXVER                 NO
         TM    1(R7),X'09'             R2 IS 0, 2, 4, 6
         BNZ   CONST                   NO, NOT INSTR
         CLI   0(R7),X'25'             LRDR OP CODE
         BE    FPR2EXT                 YES
         CLI   0(R7),X'37'             SXR OP-CODE
         BE    FPR2EXT                 YES
         CLI   0(R7),X'26'             MXR OP-CODE
         BE    FPR2EXT                 YES
         CLI   0(R7),X'36'             AXR OP-CODE
         BNE   PFMFMT                  NO, GOOD INSTR
FPR2EXT  TM    1(R7),X'0B'             R2 IS 0 OR 4
         BZ    PFMFMT                  YES, GOOD INSTR
         B     CONST                   NO, NOT INSTR
FPRXVER  CLI   PRIVASM,1               PRIVILEGED INSTRUCTIONS O.K.
         BE    FPALIGN                 YES
         TM    2(R7),X'F0'             ANT BASE REG
         BNZ   FPALIGN                 YES
         TM    1(R7),X'0F'             ANY INDEX REG
         BZ    CONST                   NO, NOT INSTR
FPALIGN  TM    2(R7),X'F0'             ANY BASE REG
         BNZ   PFMFMT                  YES, ACCEPT INSTR
         TM    1(R7),X'0F'             ANY INDEX REG
         BNZ   PFMFMT                  YES, ACCEPT INSTR
         TM    3(R7),X'03'             DISPL DIV BY 4
         BNZ   CONST                   NO, NOT INSTR
         TM    ICLASS,FLSHT            SHORT PRECISION
         BO    PFMFMT                  YES, ACCEPT INSTRUCTION
         TM    3(R7),X'07'             DISPL DIV BY 8
         BZ    PFMFMT                  YES, ACCEPT INSTR
         B     CONST                   NO, NOT INSTR
*
*
*
******************************************************************
*                                                                *
* THIS ROUTINE IS ENTERED FROM VARIOUS OTHER ROUTINES WHEN THE   *
* CURRENT TEXT BYTE IS DETERMINED NOT TO BE AN INSTRUCTION OP    *
* CODE. A CONSTANT AREA IS BUILT TO CONTAIN THE CONSTANT, IT'S   *
* DATA TYPE, SYMBOL TO BE USED FOR ADCONS, LABEL TO BE USED, IF  *
* ANY, ETC. THE CONSTANT IS BUILT BYTE BY BYTE, AND IS TERMINATED*
* FOR OUTPUT BY THE FORCONST ROUTINE. THIS ROUTINE DETECTS END OF*
* CONSTANT WHEN THE CONSTANT IN PROGRESS EXCEEDS 2 BYTES FOR A   *
* HALFWORD, 4 BYTES FOR A FULLWORD, OR 8 BYTES AS A MAXIMUM. IT  *
* IS ALSO TERMINATED WHEN A CHANGE IN DATA TYPE OCCURS.          *
*                                                                *
******************************************************************
*
CONST    EQU   *                       *** PROCESS CONSTANTS ***
         MVC   WORKREC,BLANX           CLEAR WORK RECORD AREA
         CLI   CONPROG,1               CONSTANT IN PROGRESS
         BNE   CCNEW                   NO
         CLC   TXTOFSET,LBLADR         LABEL ENTRY HAS THIS OFFSET
         BNE   CGETYP                  NO
CSTNEW   BAL   R9,FORCONST             FORCE IT OUT
         B     CCNEW                   GO START A NEW ONE
CGETYP   TRT   0(1,R7),CHARTRAN        CHECK DATA TYPE OF BYTE
         BNZ   CHEX                    IT'S HEX
NOTHEX   MVI   CCKTYP+1,C'C'           SET TYPE IN COMPARE
         B     CCKTYP                  GO COMPARE
CHEX     DS    0H         SET TYPE IN COMPARE
         TRT   0(1,R7),HEXTRAN         CHECK DATA TYPE OF BYTE      RH
         BZ    NOTHEX                  IT'S CHARACTER               RH
         MVI   CCKTYP+1,C'X'           SET TYPE IN COMPARE
CCKTYP   CLI   CONTYPE,C' '            TYPE IN PROG SAME AS THIS BYTE
         BNE   CSTNEW                  NO
CUPDCON  LH    R11,CONLEN              GET CURRENT LENGTH
         LA    R11,1(R11)              ADD 1
         STH   R11,CONLEN              UPDATE LENGTH
         L     R11,CONLOC              GET CURRENT LOC IN CONST DATA
         MVC   0(1,R11),0(R7)          MOVE BYTE TO DATA
         LA    R11,1(R11)              STEP OVER ONE BYTE
         ST    R11,CONLOC              SAVE UPDATED DATA ADDR
         CLI   CONTYPE,C'C'            CHARACTER CONSTANT
         BE    CCK8                    YES
         TM    CONOFST+3,1             OFFSET IS ODD
         BO    CCFIN1                  YES
         TM    CONOFST+3,2             HALFWORD OFFSET
         BZ    CCFWD                   NO
         CLI   CONLEN+1,1              HALFWORD, IS LENGTH = 1
         BE    CCXIT1                  YES
         B     CCFIN1                  NO
CCFWD    CLI   CONLEN+1,4              NO, IS HEX CONST 4 BYTES
         BL    CCXIT1                  NOT YET
*              NOW LET'S SEE IF WE HAVE MULTIPLE 4 BYTE CHUNKS      RH
*                                                                   RH
         LA    R9,1               WE HAVE AT LEAST 1 SET OF 4       RH
         LA    R11,1(0,R7)        R11 -> TO NEXT 4 BYTES            RH
         SPACE 1                                                    RH
MULTLOOP DS    0H                                                   RH
         LR    R14,R11            R14 -> TO NEXT 4 BYTES            RH
         S     R14,TXTSTRT        R14 = OFFSET TO NEXT 4 BYTES      RH
         CLM   R14,7,LBLADR       IS THERE A LABEL IN THESE 4 BYTES RH
         BNL   OUTMULT            YES, GO PRINT DC                  RH
         CLC   CONDATA(4),0(R11)  NEXT 4 BYTES THE SAME ?           RH
         BNE   OUTMULT            NO                                RH
         LA    R9,1(0,R9)         ADD 1 TO MULTIPLE COUNTER         RH
         LA    R11,4(0,R11)       R11 -> TO NEXT 4 BYTES            RH
         C     R11,TXTEND         PAST END OF MODULE?               RH
         BL    MULTLOOP           NO, GO CHECK THEM OUT             RH
*        BNL   OUTMULT            YES, END OF MULT CODE             RH
*        B     MULTLOOP           GO CHECK THEM OUT                 RH
         SPACE 1                                                    RH
OUTMULT  DS    0H                                                   RH
         STH   R9,CONDUP          SAVE DUPLICATION COUNTER          RH
         LR    R7,R11             UPDATE R7                         RH
         BCTR  R7,0               ''                                RH
         SPACE 1                                                    RH
*                                                                   RH
CCFIN1   BAL   R9,FORCONST             MAX LENG, FORCE IT OUT
         B     CCXIT1                  FINISH
*CK8     CLC   CONLEN,H8               CHAR CONSTANT 8 BYTES
CCK8     CLC   CONLEN,MAXCON           CHAR CONSTANT AT MAX BYTES ? RH
         BNL   CCFIN1                  YES
CCXIT1   LA    R7,1(R7)                STEP OVER 1 BYTE IN TEXT
         ST    R7,TXTCURR              UPDATE TEXT ADDR
         B     GETCURR                 CONTINUE TEXT PROCESSING
CCNEW    MVI   CONPROG,1               SHOW CONSTANT IN PROGRESS
         MVC   CONOFST,TXTOFST         SET OFFSET TO 1ST BYTE
         MVC   CONNAME,BLANX           CLEAR NAME
         XC    CONDATA,CONDATA         CLEAR DATA AREA
         MVC   CONSYM,BLANX            CLEAR SYMBOL NAME
         MVC   CONLEN,XZROS            CLEAR LENGTH
         LA    R11,CONDATA             GET 1ST DATA BYTE ADDR
         ST    R11,CONLOC              SET STARTING ADDRESS OF DATA
         CLC   TXTOFSET,LBLADR         LABEL AT THIS OFFSET
         BE    CLBLD                   YES
TRTYPE   TRT   0(1,R7),CHARTRAN        CHECK DATA TYPE OF BYTE
         BNZ   CCSHX                   IT'S HEX
         MVI   CONTYPE,C'C'            IT'S CHAR, SO INDICATE
         B     CUPDCON                 GO COMPLETE
CCSHX    MVI   CONTYPE,C'X'            IT'S HEX, SO INDICATE
         B     CUPDCON                 GO COMPLETE
CLBLD    CLI   LBLTYP,C'L'             IS IT A LABEL ONLY
         BNE   CDATACON                NO
         MVC   CONNAME,LBLNAME         NAME TO CONSTANT WORK AREA
         MVC   CONLLEN,LBLLEN         SAVE LENGTH
         LA    R6,L'LABEL(R6)          TO NEXT LABEL ENTRY
         CLC   TXTOFSET,LBLADR         THIS LABEL AT SAME ADDR
         BNE   TRTYPE                  NO
         CLI   LBLTYP,C'L'             THIS ANOTHER LABEL ONLY
         BNE   CDATACON                NO
         SH    R6,LBLLGTH             BACK UP TO LABEL ENTRY
         BAL   R9,EQUSTMT             GO BUILD EQU STATEMENT
         LA    R6,L'LABEL(R6)          TO NEXT LABELENTRY
         B     CCNEW                   GO TO NEXT LABEL
CDATACON MVC   CONTYPE,LBLTYP          TYPE TO CONSTANT AREA
         SPACE 1                                                    RH
         CLI   LBLTYP,C'W'        WEAK EXTERNAL ?                   RH
         BNE   *+4+4              NO                                RH
         MVI   CONTYPE,C'V'       YES, CHANGE TO V TYPE             RH
         SPACE 1                                                    RH
         SR    R1,R1                   CLEAR WORK
         IC    R1,LBLLEN               PICK UP CONSTNT LENGTH
         STH   R1,CONLEN               SAVE CONSTANT LENGTH
         BCTR  R1,R0                   COMPUTE CONSTANT LENGTH CODE
         STC   R1,MCD+1                SET MOVE LENGTH CODE
MCD      MVC   CONDATA,0(R7)           MOVE DATA TO RECORD
         MVC   CONSYM,LBLNAME          SYMBOL TO CONSTANT AREA
         SR    R11,R11                 CLEAR WORK REG
         IC    R11,LBLLEN              PICK UP LENGTH
         AR    R7,R11                  STEP PAST TEXT
         ST    R7,TXTCURR              UPDATE TEXT ADDRESS
         BAL   R9,FORCONST             FORCE CONSTANT OUT
         LA    R6,L'LABEL(R6)          STEP TO NEXT LABEL ENTRY
         B     GETCURR                 CONTINUE TEXT PROCESS
*
*
*
******************************************************************
*                                                                *
* THIS ROUTINE IS ENTERED BY VARIOUS ROUTINES WHEN IT IS         *
* NECESSARY TO WRITE THE CONSTANT CURRENTLY IN PROGRESS, AND     *
* CLEAR FIELDS FOR THE NEXT CONSTANT TO BE CREATED.              *
*                                                                *
******************************************************************
*
FORCONST EQU   *                       *** FORCE OUT CONSTANT IN PROGRE
         ST    R9,FC9                  SAVE RETURN ADDR
         CLC   CONNAME,BLANX           ANY LABEL NAME SET UP
         BE    CKCNPRG                 NO, CONTINUE
         CLC   CONLLEN,CONLEN+1        LENGTHS SAME
         BE    CKCNPRG                 YES, CONTINUE
         CLI   CONLLEN,X'00'           IS LENGTH ZERO ?             RH
         BE    CKCNPRG                 YES, CONTINUE                RH
         CLC   CONNAME,CONPSLBL+4 LABEL SAME AS PSEUDO LABEL?       RH
         BE    CKCNPRG                 YES, CONTINUE                RH
         ST    R6,FC6                  SAVE LABEL TABLE ADDR
         LA    R6,CONPSLBL             @ PSEUDO LABEL ENTRY
         BAL   R9,EQUSTMT              GO BUILD EQU STATEMENT
         MVC   CONNAME,BLANX           CLEAR STATEMENT LABEL FIELD
         L     R6,FC6                  RESTORE LABEL TABLE POINTER
CKCNPRG  CLI   CONPROG,1               CONSTANT IN PROGRESS
         BNE   FCCLR                   NO
         CLI   CONLEN+1,0              ANY DATA LENGTH
         BE    FCCLR                   NO
         XC    TEXT,TEXT               CLEAR TEXT FIELD
*****************************************************************
         CLI   CONTYPE,C'W'            IS THIS A WEAK EXTERN?
         BNE   NOTWEXT                 IF NOT, LEAVE IT ALONE
         MVC   MNEMONIC(5),=C'WXTRN'   BUILD AN ENTRY STATEMENT
         MVC   OPNDS(8),CONSYM         FOR THE WEAK EXTERNAL REF
         BAL   R9,WRTOUT               PUT WEXTRN RECORD OUT
         BAL   R9,PRINT                TO THE PRINT FILE ALSO.
         MVI   CONTYPE,C'A'            CHANGE TO AN A CONSTANT
NOTWEXT  DS    0H
*****************************************************************
         MVC   MNEMONIC(2),=C'DC'      SET MNEMONIC
         MVC   OPNDS(1),CONTYPE        SET TYPE
         MVI   OPNDS+1,C''''           OPERAND DELIMITER
*        LH    R11,CONLEN         R11 = DATA LENGTH                 RH
*        CH    R11,H1             IS IT A 1 BYTE DC ?               RH
*        BE    NOLTH              YES                               RH
*        CVD   R11,DBLWD          CONVERT TO DECIMAL                RH
*        UNPK  OPNDS+1(3),DBLWD+6(2) UNPACK LTH                     RH
*        MVI   OPNDS+1,C'L'       SET 'L' PART OF CL                RH
*        MVI   OPNDS+4,C''''      SET '                             RH
*        SPACE 1                                                    RH
*NOLTH   DS    0H                                                   RH
         MVC   NAME,CONNAME            NAME TO RECORD
         MVC   OFFSET,CONOFST+1        OFFSET TO RECORD
         MVI   INSTYP,0                NOT AN INSTRUCTION
         MVI   TYPE,2                  NON-ADDRESS CONSTANT
         MVC   LEN,CONLEN+1            DATA LENGTH
         LH    R11,CONLEN              DATA LENGTH
         BCTR  R11,R0                  DATA LENGTH CODE
         STC   R11,FMCON+1             MOVE LENGTH TO MVC
FMCON    MVC   TEXT,CONDATA            DATA TO RECORD
         CLI   CONTYPE,C'C'            CHARACTER TYPE
         BE    FCHAR                   YES
         CLI   CONTYPE,C'X'            HEX TYPE
         BNE   FSYMBOL                 NO
         TM    CONOFST+3,1             OFFSET TO CONSTANT IS ODD
         BO    FHEX                    YES
         TM    CONLEN+1,1              LENGTH IS ODD
         BO    FHEX                    YES
         TM    CONOFST+3,2             OFFSET DIVISIBLE BY 4
         BO    FHWD                    NO
         CLI   CONLEN+1,4              IS IT 4-BYTES
         BNE   FHWD                    NO, JUST HALFWORD
         CLC   CONDATA(4),XZROS        CONSTANT IS ALL ZEROS
         BNE   FFCKNEG                 NO
         MVC   OPNDS(4),=C'F''0'''     BUILD OPERANDS
         B     FCWRT                   CONTINUE
FFCKNEG  ICM   R11,15,CONDATA          GET DATA
         BM    FHEX                    NEG, TREAT AS HEX
         C     R11,=F'99999'           VALUE EXCEEDS 99,999
         BH    FHEX                    YES, TREAT AS HEX
         MVC   OPNDS(2),=C'F'''        OPERAND DATA TYPE IS F
         CVD   R11,DBLWD               CONVERT VALUE TO PACKED
         UNPK  OPNDS+2(5),DBLWD+5(3)   UNPACK INTO OPERAND
         OI    OPNDS+6,C'0'            SET SIGN = F
         MVI   OPNDS+7,C''''           ENDING QUOTE
         B     FCWRT                   CONTINUE
FHWD     LH    R11,CONDATA             PICK UP HALFWORD
         LTR   R11,R11                 TEST CONSTANT VALUE
         BM    FHEX                    NEGATIVE, TREAT AS HEX
         BNZ   FHCMAX                  NOT ZERO, CHECK MAX VALUE
         MVC   OPNDS(4),=C'H''0'''     SET OPERAND FOR ZERO
         B     FCWRT                   CONTINUE
FHCMAX   CH    R11,=H'9999'            VALUE EXCEEDS 9,999
         BH    FHEX                    YES, TREAT AS HEX
         CVD   R11,DBLWD               CONVERT TO PACKED
         OI    DBLWD+7,X'0F'           CLEAR SIGN TO F
         MVC   OPNDS(2),=C'H'''        SET DELIMITER IN OPERAND
         UNPK  OPNDS+2(4),DBLWD+5(3)   UNPACK VALUE TO OPERAND
         MVI   OPNDS+6,C''''           ENDING DELIMITER
         B     FCWRT                   CONTINUE
FCHAR    MVC   OPNDS(2),=C'C'''        OPERAND DELIMITER FOR CHARACTER
         LH    R11,CONLEN              GET DATA LENGTH
         LA    R12,OPNDS+2        R12 -> TO WHERE DATA GOES         RH
         CH    R11,H1             IS IT A 1 BYTE DC ?               RH
         BE    NOLTH              YES                               RH
         CVD   R11,DBLWD          CONVERT TO DECIMAL                RH
         UNPK  OPNDS+1(3),DBLWD+6(2) UNPACK LTH                     RH
         MVZ   OPNDS+3(1),OPNDS+2 FIX ZONE                          RH
         MVI   OPNDS+1,C'L'       SET 'L' PART OF CL                RH
         MVI   OPNDS+4,C''''      SET '                             RH
*                                                                   RH
*              NOW LETS CHECK TO  SEE IF THE DC IS ALL THE SAME     RH
*                                                                   RH
         LA    R12,CONDATA+1      R12 -> TO FIRST BYTE TO TEST      RH
         LR    R9,R11             R9 = LTH TO TEST                  RH
         BCTR  R9,R0              -1 FOR BYTE 1                     RH
         SPACE 1                                                    RH
LOOP1    DS    0H                                                   RH
         CLC   CONDATA(1),0(R12)  IS THIS BYTE SAME AS THE FIRST?   RH
         BNE   NOTSAME            NO, PUT IT OUT AS IS              RH
         LA    R12,1(0,R12)       R12 -> TO NEXT BYTE TO TEST       RH
         BCT   R9,LOOP1           GO CHECK IT                       RH
         MVC   OPNDS+5(1),CONDATA MOVE 1 BYTE TO DC                 RH
         MVI   OPNDS+6,C''''      MOVE IN END QUOTE                 RH
         B     FCWRT              CONTINUE                          RH
         SPACE 1                                                    RH
NOTSAME  DS    0H                                                   RH
*                                                                   RH
         LA    R12,OPNDS+5        R12 -> TO WHERE DATA GOES         RH
         SPACE 1                                                    RH
NOLTH    DS    0H                                                   RH
         BCTR  R11,R0                  LENGTH CODE
         STC   R11,FMCNT+1             SET MOVE LENGTH
FMCNT    MVC   0(1,R12),CONDATA        DATA TO OPERAND              RH
         LA    R11,1(R12,R11)          STEP PAST OPERAND DATA       RH
*MCNT    MVC   OPNDS+2,CONDATA         DATA TO OPERAND
*        LA    R11,OPNDS+3(R11)        STEP PAST OPERAND DATA
         MVI   0(R11),C''''            ENDING QUOTE
         B     FCWRT                   CONTINUE
FSYMBOL  CLC   CONSYM,BLANX            IS IT BLANK
         BE    FHEX                    YES, TREAT AS HEX
         CLI   CONLEN+1,4              LENGTH IS 4
         BH    FHEX                    NO, GREATER
         BE    AC4                     YES, 4 BYTES
         CLI   CONLEN+1,3              LENGTH IS 3
         BE    AC3                     YES
         CLI   CONLEN+1,2              LENGTH IS 2
         BE    AC2                     YES
         MVC   OPNDS+1(2),=C'L1'       OPND LENGTH
         B     FSLHE1                  CONTINUE
AC2      MVC   OPNDS+1(2),=C'L2'       OPND LGTH
         B     FSLHE1                  CONTINUE
AC3      MVC   OPNDS+1(2),=C'L3'       OPND LENGTH
         B     FSLHE1                  CONTINUE
AC4      LA    R11,OPNDS+1             STEP TO ( POS
         B     FSLHE                   CONTINUE
FSLHE1   LA    R11,OPNDS+3             STEP TO ( POS
FSLHE    MVI   0(R11),C'('             DELIMITER
         MVC   1(8,R11),CONSYM         SYMBOL TO RECORD
         LA    R11,9(R11)              @ RHE SYMBOL IN OPERAND
FRHE     CLI   0(R11),C' '             CHARACTER IS BLANK
         BNE   SETRPAR                 NO
         BCT   R11,FRHE                LOOP TO FIND RHE
SETRPAR  MVI   1(R11),C')'             SET CLOSING PAREN
         B     FCWRT                   CONTINUE
FHEX     MVC   OPNDS(2),=C'X'''        TYPE AND BEGIN QUOTE
         LA    R12,CONDATA             @ CONSTANT DATA
         BAL   R9,HEXPRT4              CONVERT TO PRINTABLE
         LH    R12,CONLEN              GET DATA LENGTH
         SLL   R12,1                   DOUBLE IT
         BCTR  R12,R0                  -1 = LENGTH CODE
         STC   R12,MVHX+1              SET MOVE LENGTH
MVHX     MVC   OPNDS+2(1),PRTABL       HEX CHARS TO OPERAND
         LA    R12,OPNDS+2(R12)        OPERAND END ADDRESS
         MVI   1(R12),C''''            ENDING QUOTE
         B     FCWRT                   CONTINUE
         SPACE 1                                                    RH
FCWRT    DS    0H                                                   RH
         CLI   CONDUP+1,1         IS THERE A DUPLICATION COUNT?     RH
         BNH   FCWRT2             NO                                RH
         MVC   CONDATA(10),OPNDS  SAVE DC OPERAND                   RH
         LH    R11,CONDUP         R11 = DUPLICATION COUNT           RH
         CVD   R11,DBLWD          CONVERT TO DECIMAL                RH
         UNPK  OPNDS(3),DBLWD+6(2) UNPACK                           RH
         MVZ   OPNDS+2(1),OPNDS+1 FIX ZONE                          RH
         LA    R11,OPNDS+3        HERES WHERE OPERAND GOES          RH
         SPACE 1                                                    RH
GETDUP   DS    0H                                                   RH
         CLI   OPNDS,C'0'         LEADING 0?                        RH
         BNE   GETOPND            NO                                RH
         BCTR  R11,0              HERES WHERE OPERAND GOES          RH
         MVC   OPNDS(2),OPNDS+1   DROP 0 BYTE                       RH
         B     GETDUP             GO CHECK IT NOW                   RH
         SPACE 1                                                    RH
GETOPND  DS    0H                                                   RH
         MVC   0(10,R11),CONDATA  PUT DC OPERAND BACK IN            RH
         SPACE 1                                                    RH
FCWRT2   DS    0H                                                   RH
*                                                                   RH
         BAL   R9,WRTOUT               WRITE RECORD
         BAL   R9,TXTFMT               GO FORMAT HEX DATA
         BAL   R9,PRINT                GO PRINT IT
         MVI   DCINST,C'D'        SAY WE PRINTED A DC               RH
         SPACE 1                                                    RH
FCCLR    MVI   CONPROG,0               RESET CONSTANT IN PROGRESS
         MVC   CONNAME,BLANX           CLEAR NAME
         MVI   CONTYPE,0               RESET TYPE
         XC    CONDATA,CONDATA         CLEAR CONSTANT DATA
         MVC   CONSYM,BLANX            CLEAR SYMBOL
         XC    CONLEN,CONLEN           CLEAR LENGTH
         XC    CONDUP,CONDUP           CLEAR DUP COUNTER            RH
         MVC   CONLOC,XZROS            CLEAR LOCATION
         MVC   CONOFST,XZROS           CLEAR OFFSET TO CONSTANT
         L     R9,FC9                  GET RETURN ADDR
         BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* THIS ROUTINE FORMATS RR-FORMAT INSTRUCTIONS FOR OUTPUT.        *
*                                                                *
******************************************************************
*
RROPND   EQU   *                       *** RR FORMAT INSTRUCTIONS ***
         CLI   0(R7),X'05'             IS IT BALR
         BNE   RRSTRT
         CLI   1(R7),X'EF'             IS IT BALR 14,15
         BE    RRSTDL                  YES
         TM    1(R7),X'0F'             NO, IS R2 = 0
         BNZ   RRNSTD                  NO
         MVC   COMMENT(11),=C'ADDRESS SET'
         B     RRSTRT                  CONTINUE
RRSTDL   MVC   COMMENT(11),=C'STD LINKAGE'
         B     RRSTRT                  CONTINUE
RRNSTD   MVC   COMMENT(14),=C'NONSTD LINKAGE'
RRSTRT   EQU   *
         LA    R15,TEXT+1              POINT TO TEXT
         LR    R11,R1                  COPY INSTRUCTION TYPE
         CH    R11,=H'48'              RRE TYPE?
         BL    *+8                     NO, JUST RR
         LA    R15,2(R15)              ADJ FO 2 BYTE OPCODE
         SR    R1,R1                   CLEAR WORK
         IC    R1,TEXT+1               GET 2ND BYTE
         SRL   R1,4                    SHIFT OUT R2
         CVD   R1,DBLWD                CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         MVI   OPNDS,C'R'              BEGIN R1 OPERAND
         CH    R1,H10                  REG NBR > 9
         BL    RR11                    NO, 0-9
         MVC   OPNDS+1(2),DBLWD        YES, 10-15
         LA    R1,OPNDS+3              TO NEXT POS
         B     RRCMA                   CONTINUE
RR11     MVC   OPNDS+1(1),DBLWD+1      MOVE REG NBR
         LA    R1,OPNDS+2              TO NEXT POS
RRCMA    EQU   *
         CH    R11,=H'48'              RRE WITH ONE OPERAND?
         BE    RRXIT                   YES
         CLI   TEXT,X'04'              IS IT SPM
         BNE   RRCMA1                  NO
         TM    1(R7),X'0F'             YES, IS R2 FIELD = 0
         BZ    RRXIT                   YES, GOOD INSTR
         B     4(R9)                   ERROR RETURN (NOT INSTR)
RRCMA1   MVC   0(2,R1),=C',R'          DELIMITERS
         PACK  DBLWD(1),0(1,R15)       FLIP 2ND BYTE
         SR    R15,R15                 CLEAR WORK
         IC    R15,DBLWD               GET R2R1
         SRL   R15,4                   SHIFT OUT R1
         CVD   R15,DBLWD               CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         CH    R15,H10                 R2 > 9
         BL    RR21                    NO, 0-9
         MVC   2(2,R1),DBLWD           YES, MOVE REG 10-15
         BR    R9                      EXIT
RR21     MVC   2(1,R1),DBLWD+1         MOVE REG 0-9
RRXIT    BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT RX-TYPE  *
* INSTRUCTIONS. THE BDXADR ROUTINE IS CALLED TO FORMAT THE       *
* STORAGE OPERAND.                                               *
*                                                                *
******************************************************************
*
RXOPND   EQU   *                       *** RX FORMAT INSTRUCTIONS ***
         CLI   0(R7),X'45'             IS IT BAL OP CODE
         BNE   RXSTRT                  NO
         MVC   COMMENT(7),=C'PERFORM'
         TM    1(R7),X'E0'             R1 = 0 OR 1
         BNZ   RXSTRT                  NO
         MVC   COMMENT(13),=C'PARM SET BRCH'
RXSTRT   SR    R1,R1                   CLEAR WORK
         IC    R1,TEXT+1               GET R1X2
         SRL   R1,4                    SHIFT OUT X2
         CVD   R1,DBLWD                CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         MVI   OPNDS,C'R'              BEGIN 1ST OPERAND
         CH    R1,H10                  R1 < 10
         BL    RXR11                   YES, 0-9
         MVC   OPNDS+1(2),DBLWD        NO, MOVE REG 10-15
         LA    R15,OPNDS+3             TO NEXT POS
         B     RXCMA                   CONTINUE
RXR11    MVC   OPNDS+1(1),DBLWD+1      MOVE REG 0-9
         LA    R15,OPNDS+2             TO NEXT POS
RXCMA    MVI   0(R15),C','             DELIMITER
         PACK  DBLWD(1),TEXT+1(1)      FLIP 2ND BYTE
         SR    R10,R10                 CLEAR WORK
         IC    R10,DBLWD               PICK UP X2R1
         SRL   R10,4                   SHIFT OUT R1
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET BDDD
         BAL   R9,BDXADR               CONVERT RX ADDRESS
         STC   R10,BDXMVC+1            SET MOVE LENGTH
BDXMVC   MVC   1(1,R15),OPNDWK         MOVE RX OPERAND
         L     R9,OPND9                GET RETURN ADDR
         BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT S-TYPE   *
* INSTRUCTIONS. THE BDADR ROUTINE IS CALLED TO FORMAT THE        *
* STORAGE OPERAND.                                               *
*                                                                *
******************************************************************
*
SOPND    EQU   *                       *** S FORMAT INSTRUCTIONS ***
         CLI   1(R7),0                 BYTE 2 OF INSTR IS ZERO
         BE    SCK2                    YES
         CLI   0(R7),X'80'             NO, IS IT SSM
         BE    4(R9)                   YES, NOT INSTR
         CLI   0(R7),X'82'             NO, IS IT LPSW
         BE    4(R9)                   YES, NOT INSTR
         CLI   0(R7),X'93'             NO, IS IT TS
         BE    4(R9)                   YES, NOT INSTR
SCK2     CLI   0(R7),X'B2'             OP-CODE IS B2
         BNE   SSTRT                   NO
         CLC   2(2,R7),XZROS           3RD AND 4TH BYTES ZERO
         BE    SSTRT                   YES
         CLI   1(R7),X'0B'             IPK INSTRUCTION
         BE    4(R9)                   YES, NOT INSTR
         CLI   1(R7),X'0D'             PTLB INSTR
         BE    4(R9)                   YES, NOT INSTR
SSTRT    SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET BDDD
         BAL   R9,BDADR                CONVERT BDDD ADDRESS
         MVC   PADDR1,ADDRVAL     SET UP ADDR 1                     RH
         STC   R10,SOPMVC+1            SET MOVE LENGTH
SOPMVC   MVC   OPNDS,OPNDWK            MOVE OPERAND
         L     R9,OPND9                GET RETURN ADDR
         BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT SI-TYPE  *
* INSTRUCTIONS. THE BDADR ROUTINE IS CALLED TO FORMAT THE        *
* STORAGE OPERAND.                                               *
*                                                                *
******************************************************************
*
SIOPND   EQU   *                       *** SI FORMAT INSTRUCTIONS ***
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET BDDD ADDRESS
         BAL   R9,BDADR                CONVERT ADDRESS
         MVC   PADDR1,ADDRVAL     SET UP ADDR 1                     RH
         STC   R10,SIOMVC+1            SET MOVE LENGTH
SIOMVC   MVC   OPNDS,OPNDWK            MOVE BDDD OPERAND
         LA    R15,OPNDS+1(R10)        TO NEXT POS
         MVI   0(R15),C','             DELIMITER
         TRT   TEXT+1(1),CHARTRAN      TEST IF CHARACTER
         BNZ   HEXIMM                  NO, HEX
         CLI   TEXT,X'95'              IS IT CLI
         BE    CHIMM                   YES
         CLI   TEXT,X'92'              IS IT MVI
         BNE   HEXIMM                  NO
CHIMM    MVC   1(2,R15),=C'C'''        DELIMITER
         MVC   3(1,R15),TEXT+1         CHARACTER TO OPERAND
         MVI   4(R15),C''''            ENDING DELIMITER
         L     R9,OPND9                GET RETURN ADDR
         BR    R9                      EXIT
HEXIMM   MVC   1(2,R15),=C'X'''        DELIMITER FOR HEX
         LA    R12,TEXT+1              @ HEX BYTE
         BAL   R9,HEXPRT1              CONVERT
         MVC   3(2,R15),PRTABL         PRINTABLE HEX TO OPERAND
         MVI   5(R15),C''''            FINAL QUOTE
         L     R9,OPND9                GET RETURN ADDR
         BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT RS-TYPE  *
* INSTRUCTIONS. THE BDADR ROUTINE IS CALLED TO FORMAT THE        *
* STORAGE OPERAND.                                               *
*                                                                *
******************************************************************
*
RSOPND   EQU   *                       *** RS FORMAT INSTRUCTIONS ***
         CLI   TEXT,X'90'              IS IT STM
         BE    RSSTM                   YES
         CLI   TEXT,X'98'              IS IT LM
         BNE   RSCLR1                  NO
         MVC   COMMENT(12),=C'RESTORE REGS'
         B     RSCLR1                  CONTINUE
RSSTM    MVC   COMMENT(9),=C'SAVE REGS'
RSCLR1   SR    R1,R1                   CLEAR WORK
         IC    R1,TEXT+1               PICK UP R1R3
         SRL   R1,4                    SHIFT OUT R3
         CVD   R1,DBLWD                CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         MVI   OPNDS,C'R'              BEGINNING OPERAND 1
         CH    R1,H10                  REG NBR < 10
         BL    RSR11                   YES
         MVC   OPNDS+1(2),DBLWD        MOVE REG 10-15
         LA    R15,OPNDS+3             TO NEXT POS
         B     RSCMA                   CONTINUE
RSR11    MVC   OPNDS+1(1),DBLWD+1      MOVE REG 0-9
         LA    R15,OPNDS+2             TO NEXT POS
RSCMA    CLI   0(R7),X'88'             IS IT SHIFT INSTR
         BL    RSCMA1                  NO
         CLI   0(R7),X'8F'             IS IT SHIFT INSTR
         BH    RSCMA1                  NO
         TM    1(R7),X'0F'             SHIFT, IS R3 POS = 0
         BZ    RSBDD                   YES, GOOD SHIFT
         B     4(R9)                   NO, NOT INSTR
RSCMA1   MVC   0(2,R15),=C',R'         DELIMITERS
         CLI   0(R7),X'BD'             CLM, STCM, OR ICM
         BL    RSPK2                   NO
         CLI   0(R7),X'BF'             CLM,STCM, OR ICM
         BH    RSPK2                   NO
         BCTR  R15,R0                  CLM, STCM, ICM HAVE MASK IN R3 P
RSPK2    PACK  DBLWD(1),TEXT+1(1)      FLIP 2ND BYTE
         SR    R1,R1                   CLEAR WORK
         IC    R1,DBLWD                GET R3R1
         SRL   R1,4                    SHIFT OUT R1
         CVD   R1,DBLWD                CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         CH    R1,H10                  REG NBR < 10
         BL    RSR31                   YES, 0-9
         MVC   2(2,R15),DBLWD          MOVE REG 10-15
         LA    R15,4(R15)              TO NEXT POS
         B     RSBDD                   CONTINUE
RSR31    MVC   2(1,R15),DBLWD+1        MOVE REG 0-9
         LA    R15,3(R15)              TO NEXT POS
RSBDD    MVI   0(R15),C','             DELIMITER
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET BDD ADDRESS
         BAL   R9,BDADR                CONVERT BDDD ADDRESS
         MVC   PADDR2,ADDRVAL     SET UP ADDR 2                     RH
         STC   R10,RSMVC+1             SET MOVE LENGTH
RSMVC    MVC   1(1,R15),OPNDWK         MOVE BDDD ADDRESS
         L     R9,OPND9                GET RETURN ADDR
         BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT SS-TYPE  *
* INSTRUCTIONS OF THE SINGLE LENGTH VARIETY. THE BDLADR ROUTINE  *
* IS CALLED TO FORMAT THE 1ST STRG OPND, AND BDADR FOR THE 2ND.  *
*                                                                *
******************************************************************
*
SS1OPND  EQU   *                       *** SS FORMAT INSTRUCTIONS - SIN
         SR    R10,R10                 CLEAR WORK
         IC    R10,TEXT+1              GET LENGTH CODE
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET BDDD ADDRESS
         BAL   R9,BDLADR               CONVERT ADDRESS
         MVC   PADDR1,ADDRVAL     SET UP ADDR 1                     RH
         STC   R10,SS1MV1+1            SET MOVE LENGTH
SS1MV1   MVC   OPNDS,OPNDWK            MOVE ADDRESS
         LA    R15,OPNDS+1(R10)        TO NEXT POS
         MVI   0(R15),C','             DELIMITER
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+4            GET SECOND BDDD ADDRESS
         BAL   R9,BDADR                CONVERT ADDRESS
         MVC   PADDR2,ADDRVAL     SET UP ADDR 2                     RH
         STC   R10,SS1MV2+1            SET MOVE LENGTH
SS1MV2   MVC   1(1,R15),OPNDWK         MOVE 2ND OPERAND
         L     R9,OPND9                GET RETURN ADDR
         BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT SS-TYPE  *
* INSTRUCTIONS OF THE DOUBLE LENGTH VARIETY. THE BDLADR ROUTINE  *
* IS CALLED TO FORMAT THE STORAGE OPERANDS.                      *
*                                                                *
******************************************************************
*
SS2OPND  EQU   *                       *** SS FORMAT INSTRUCTIONS - 2 L
         SR    R10,R10                 CLEAR WORK
         IC    R10,TEXT+1              GET L1L2
         SRL   R10,4                   SHIFT OUT L2
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET BDDD ADDRESS
         BAL   R9,BDLADR               CONVERT ADDRESS
         MVC   PADDR1,ADDRVAL     SET UP ADDR 1                     RH
         STC   R10,SS2MV1+1            SET MOVE LENGTH
SS2MV1   MVC   OPNDS,OPNDWK            MOVE 1ST OPERAND
         LA    R15,OPNDS+1(R10)        TO NEXT POS
         MVI   0(R15),C','             DELIMITER
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+4            GET 2ND BDDD ADDR
         PACK  DBLWD(1),TEXT+1(1)      FLIP LENGTH BYTE
         SR    R10,R10                 CLEAR WORK
         IC    R10,DBLWD               PICK UP L2L1
         SRL   R10,4                   SHIFT OUT L1
         CLI   TEXT,X'F0'              SRP OP-CODE
         BE    SRPOP2                  YES
         TM    IEDT,M1                 SPECIAL MOVE INST OP-CODE
         BO    SRPOP2                  YES
         BAL   R9,BDLADR               CONVERT ADDRESS
         MVC   PADDR2,ADDRVAL     SET UP ADDR 2                     RH
         STC   R10,SS2MV2+1            SET MOVE LENGTH
SS2MV2   MVC   1(1,R15),OPNDWK         MOVE 2ND OPERAND
SS2XIT   L     R9,OPND9                GET RETURN ADDR
         BR    R9                      EXIT
SRPOP2   BAL   R9,BDADR                GO BUILD OPERAND 2
         MVC   PADDR2,ADDRVAL     SET UP ADDR 2                     RH
         STC   R10,SRMV1+1             SET MOVE LENGTH
SRMV1    MVC   1(1,R15),OPNDWK         MOVE OPERAND 2
         LA    R15,2(R10,R15)          TO NEXT OPERAND POS  FIX***
         PACK  DBLWD(1),TEXT+1(1)      FLIP LENGTH BYTE
         SR    R10,R10                 CLEAR WORK
         IC    R10,DBLWD               PICK UP I3/R3
         SRL   R10,4                   SHIFT OUT L1
         CVD   R10,DBLWD               CONVERT I3/R3
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         MVI   0(R15),C','             OPERAND SEPARATOR    FIX***
         UNPK  1(1,R15),DBLWD+7(1)     UNPACK I3/R3 TO OPERAND FIX***
         CH    R2,H10                  I3/R3 < 10
         BL    SS2XIT                  YES
         UNPK  1(2,R15),DBLWD+6(2)     NO, UNPACK MORE
         B     SS2XIT                  CONTINUE
*
*
*
******************************************************************
*                                                                *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT COND-    *
* ITIONAL BRANCH INSTRUCTIONS. AN ATTEMPT IS MADE TO USE THE     *
* EXTENDED MNEMONICS WHERE POSSIBLE. FOR RR-TYPE BRANCHES, ONLY  *
* THE BR AND NOPR MNEMONICS ARE USED. FOR RX-TYPE BRANCHES, THE  *
* FULL SET OF EXTENDED MNEMONICS IS USED. THE TYPES USED ARE     *
* ARITHMETIC, COMPARE, AND 8=ZERO TYPES. THE SET TO BE USED IS   *
* DETERMINED BY THE TYPE SAVED BY THE LAST CONDITION-CODE-SETTING*
* INSTRUCTION GENERATED.                                         *
*
******************************************************************
*
BCOPND   EQU   *                       *** CONDITIONAL BRANCH INSTRUCTI
         TM    TEXT+1,X'F0'            UNCONDITIONAL BRANCH
         BZ    NOPS                    NO, NOP
         BO    UNCNDS                  YES, UNCONDITIONAL
         SR    R11,R11                 CLEAR WORK
         IC    R11,TEXT+1              PICK UP M1X2
         SRL   R11,4                   SHIFT OUT ALL BUT M1
         CLI   TEXT,X'07'              BCR OP CODE
         BE    NOEXTND                 YES, NO EXTENDED MNEMONICS
         CLI   CCTYPE,0                LAST INSTR SET CC
         BE    NOEXTND                 NO
         TM    CCTYPE,ARITH            YES, WAS IT ARITHMETIC
         BO    EXTARITH                YES
         TM    CCTYPE,CPR              WAS IT COMPARE
         BO    EXTCPR                  YES
         TM    CCTYPE,ZRO8             IS IT VALID FOR 8 = BZ
         BO    EXTZRO                  YES
NOEXTND  CVD   R11,DBLWD               CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         CH    R11,H10                 MASK < 10
         BL    BCM1                    YES, SINGLE DIGIT MASK
         MVC   OPNDS(2),DBLWD          2-DIGIT MASK TO OPERAND
         LA    R15,OPNDS+2             TO NEXT POS
         B     BCCMA                   CONTINUE
BCM1     MVC   OPNDS(1),DBLWD+1        SINGLE DIGIT MASK TO OPERAND
         LA    R15,OPNDS+1             TO NEXT POS
BCCMA    MVI   0(R15),C','             DELIMITER
         CLI   TEXT,X'07'              RR BRANCH
         BE    BCROPND                 YES
BCXOPND  PACK  DBLWD(1),TEXT+1(1)      PACK 2ND BYTE
         SR    R10,R10                 CLEAR WORK
         IC    R10,DBLWD               PICK UP X2M1
         SRL   R10,4                   SHIFT OUT M1
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            PICK UP BDDD ADDRESS
         BAL   R9,BDXADR               CONVERT ADDRESS
         STC   R10,BLDXMVC+1           SET MOVE LENGTH
BLDXMVC  MVC   1(1,R15),OPNDWK         MOVE OPERAND
         B     BCOXIT                  GO TO EXIT
BCROPND  MVI   1(R15),C'R'             REGISTER DELIMITER
         SR    R10,R10                 CLEAR WORK
         PACK  DBLWD(1),TEXT+1(1)      FLIP 2ND BYTE
         IC    R10,DBLWD               PICK UP R2M1
         SRL   R10,4                   SHIFT OUT M1
         CVD   R10,DBLWD               CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         CH    R10,H10                 REG NBR < 10
         BL    BCRR1                   YES, 0-9
         MVC   2(2,R15),DBLWD          MOVE 2-DIGIT REG NBR
         B     BCOXIT                  GO TO EXIT
BCRR1    MVC   2(1,R15),DBLWD+1        MOVE 1-DIGIT REG NBR
         B     BCOXIT                  GO TO EXIT
NOPS     CLI   TEXT,X'07'              RR NOP
         BNE   BCXNOP                  NO, RX
         MVC   MNEMONIC,=CL5'NOPR'     SET MNEMONIC
         LA    R15,OPNDS-1             TO OPND POS
         B     BCROPND                 FINISH
BCXNOP   MVC   MNEMONIC,=CL5'NOP'      SET MNEMONIC
         LA    R15,OPNDS-1             TO OPND POS
         B     BCXOPND                 FINISH
UNCNDS   CLI   TEXT,X'07'              IS IT RR BRANCH
         BNE   BCXBRCH                 NO, RX
         MVC   MNEMONIC,=CL5'BR'       SET MNEMONIC
         LA    R15,OPNDS-1             OPERAND ADDR
         CLI   TEXT+1,X'FE'            IS IT BR 14
         BNE   BCROPND                 NO
         MVC   COMMENT(4),=C'EXIT'     COMMENT
         B     BCROPND                 FINISH FORMATTING
BCXBRCH  MVC   MNEMONIC(5),=CL5'B'     SET MNEMONIC
BCXTFIN  LA    R15,OPNDS-1             SET OPND POS
         B     BCXOPND                 FINISH FORMAT
BCOXIT   L     R9,OPND9                GET RETURN ADDR
         BR    R9                      EXIT
EXTARITH CH    R11,H8                  COND CODE = 8
         BE    ARBZ                    YES
         BL    ARLOW                   NO, LOWER
         CH    R11,H14                 COND CODE = 14
         BE    ARBNO                   YES
         CH    R11,H13                 COND CODE = 13
         BE    ARBNP                   YES
         CH    R11,H11                 COND CODE = 11
         BE    ARBNM                   YES
         B     NOEXTND                 NO, NOT EXTENDED
ARLOW    CH    R11,H7                  COND CODE = 7
         BE    ARBNZ                   YES
         CH    R11,H1                  COND CODE = 1
         BE    ARBO                    YES
         CH    R11,H2                  COND CODE = 2
         BE    ARBP                    YES
         CH    R11,H4                  COND CODE = 4
         BE    ARBM                    YES
         B     NOEXTND                 NO, NOT EXTENDED
ARBZ     MVC   MNEMONIC(2),=C'BZ'      SET EXT MNEMONIC
         B     BCXTFIN                 CONTINUE
ARBNO    MVC   MNEMONIC(3),=C'BNO'     SET EXTENDED MNEMONIC
         B     BCXTFIN                 CONTINUE
ARBNP    MVC   MNEMONIC(3),=C'BNP'     SET EXT MNEMONIC
         B     BCXTFIN                 CONTINUE
ARBNM    MVC   MNEMONIC(3),=C'BNM'     SET EXT MNEMONIC
         B     BCXTFIN                 CONTINUE
ARBNZ    MVC   MNEMONIC(3),=C'BNZ'     SET EXT MNEMONIC
         B     BCXTFIN                 CONTINUE
ARBO     MVC   MNEMONIC(2),=C'BO'      SET EXT MNEMONIC
         B     BCXTFIN                 CONTINUE
ARBP     MVC   MNEMONIC(2),=C'BP'      SET EXT MNEMONIC
         B     BCXTFIN                 CONTINUE
ARBM     MVC   MNEMONIC(2),=C'BM'      SET EXT MNEMONIC
         B     BCXTFIN                 CONTINUE
EXTZRO   CH    R11,H8                  COND CODE = 8
         BE    ARBZ                    YES, USE BZ MNEMONIC
         CH    R11,H7                  COND CODE IS 7
         BE    ARBNZ                   YES
         B     NOEXTND                 NO, NOT EXTENDED
EXTCPR   CH    R11,H8                  COND CODE = 8
         BE    CPBE                    YES
         CH    R11,H7                  COND CODE = 7
         BE    CPBNE                   YES
         BL    CPLOW                   NO, LOWER
         CH    R11,H13                 COND CODE = 13
         BE    CPBNH                   YES
         CH    R11,H11                 COND CODE = 11
         BE    CPBNL                   YES
         B     NOEXTND                 NO, NOT EXTENDED
CPLOW    CH    R11,H4                  COND CODE = 4
         BE    CPBL                    YES
         CH    R11,H2                  COND CODE = 2
         BE    CPBH                    YES
         B     NOEXTND                 NO, NOT EXTENDED
CPBE     MVC   MNEMONIC(2),=C'BE'      SET EXT MNEMONIC
         B     BCXTFIN                 CONTINUE
CPBNE    MVC   MNEMONIC(3),=C'BNE'     SET EXT MNEMONIC
         B     BCXTFIN                 CONTINUE
CPBNH    MVC   MNEMONIC(3),=C'BNH'     SET EXT MNEMONIC
         B     BCXTFIN                 CONTINUE
CPBNL    MVC   MNEMONIC(3),=C'BNL'     SET EXT MNEMONIC
         B     BCXTFIN                 CONTINUE
CPBL     MVC   MNEMONIC(2),=C'BL'      SET EXT MNEMONIC
         B     BCXTFIN                 CONTINUE
CPBH     MVC   MNEMONIC(2),=C'BH'      SET EXTENDED MNEMONIC
         B     BCXTFIN                 CONTINUE
*
*
*
******************************************************************
*                                                                *
* VALIDATE AND FORMAT SVC INSTRUCTIONS. IF THE SVC OP-CODE IS    *
* FOUND IN THE SVC TABLE, IT IS ACCEPTED AS AN SVC, AND THE TABLE*
* LITERAL IS MOVED TO THE COMMENTS FIELD OF THE INSTRUCTION.     *
*                                                                *
******************************************************************
*
SVCOPND  EQU   *                       *** SVC INSTRUCTIONS ***
         CLI   TEXT+1,126              VALID OPERAND
         BH    NOTSVC                  NO, NOT SVC
         L     R1,SVCTBLAD             GET SVC TABLE ADDRESS
SVCKND   CLI   0(R1),X'FF'             END OF SVC TABLE
         BE    NOTSVC                  YES, MUST NOT BE SVC
         CLC   0(1,R1),TEXT+1          THIS THE ENTRY
         BE    GOTSVC                  YES
         LA    R1,L'SVCOP(R1)          STEP TO NEXT ENTRY
         B     SVCKND                  LOOP THRU TABLE
NOTSVC   B     4(R9)                   ERROR RETURN
GOTSVC   MVC   COMMENT(14),1(R1)       COMMENT TO WORK AREA
         SR    R1,R1                   CLEAR WORK
         IC    R1,TEXT+1               GET SVC OPERAND
         CVD   R1,DBLWD                CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(3),DBLWD+6(2)     UNPACK
         CH    R1,H100                 OPERAND > 100
         BL    SVCK10                  YES
         MVC   OPNDS(3),DBLWD          MOVE 3-DIGIT OPERAND
         B     SVCXIT                  EXIT
SVCK10   CH    R1,H10                  OPERAND < 10
         BL    SVCL10                  YES
         MVC   OPNDS(2),DBLWD+1        MOVE 2-DIGIT OPERAND
         B     SVCXIT                  EXIT
SVCL10   MVC   OPNDS(1),DBLWD+2        MOVE 1-DIGIT OPERAND
SVCXIT   BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT SSE-TYPE *
* INSTRUCTIONS. THE BDADDR ROUTINE IS CALLED TO FORMAT THE STOR- *
* AGE OPERANDS.                                                  *
*                                                                *
******************************************************************
SSEOPND  EQU   *
         SR    R10,R10                 CLEAR WORK
         IC    R10,TEXT+1              GET LENGTH CODE
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET BDDD ADDRESS
         BAL   R9,BDADR                CONVERT ADDRESS
         STC   R10,SSEMV1+1            SET MOVE LENGTH
SSEMV1   MVC   OPNDS,OPNDWK            MOVE ADDRESS
         LA    R15,OPNDS+1(R10)        TO NEXT POS
         MVI   0(R15),C','             DELIMITER
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+4            GET BDDD ADDRESS
         BAL   R9,BDADR                CONVERT ADDRESS
         STC   R10,SSEMV2+1            SET MOVE LENGTH
SSEMV2   MVC   1(1,R15),OPNDWK         MOVE ADDRESS
         L     R9,OPND9                GET RETURN ADDR
         BR    R9                      EXIT
*
*
*
******************************************************************
*   E INSTR, NO OPERANDS                                         *
******************************************************************
EOPND    EQU   *
         BR    R9
*
*
*
******************************************************************
*   RRE INSTRUCTIONS, 1 OR 2 OPERANDS                            *
******************************************************************
RREOPND  EQU   *
         BR    R9
*
*
*
******************************************************************
* BUILD EQU STATEMENTS USING THE LABEL TABLE ENTRY ADDRESSED BY  *
* REG 6 ON ENTRY.                                                *
*                                                                *
******************************************************************
*                                                                *
EQUSTMT  EQU   *                       BUILD EQU STATEMENTS
         ST    R9,EQU9                 SAVE RETURN ADDR
         USING LABELD,R6
         MVC   PADDR2,LBLNAME+2   PUT IT IN PRINT RECORD            RH
         MVC     NAME,LBLNAME          NAME TO EQU STMT
         MVC   MNEMONIC,=CL5'EQU'      BUILD EQU STATEMENT
         MVI   OPNDS,C'*'              SET EQU OPERAND
         CLI   LBLOFSET,X'FF'     DO WE NEED AN EQU+1               RH
         BE    EQU1               YES                               RH
         CLI   LBLLEN,1                LENGTH 0 OR 1
*        BNH   CCXEQU                  YES
         BE    CCXEQU             YES, IT'S 1                       RH
         BH    EQU1               NO, ON WE GO                      RH
*        BL    *+4                YES, IT'S 0, SET UP ADDR2         RH
         CLI   PADDR2,C'0'        DO WE HAVE A VALID ADDR?          RH
         BE    CCXEQU             YES, AS NEAR AS WE CAN TELL       RH
         MVC   PADDR2,BLANX       NO, BLANK IT OUT                  RH
         CLC   0(3,R6),13(R6)     ADDR SAME AS NEXT ENTRY?          RH
         BNE   CCXEQU             NO, ON WE GO                      RH
         MVC   PADDR2,19(R6)      YES, PUT IT IN PRINT RECORD       RH
         B     CCXEQU             ON WE GO                          RH
         SPACE 1                                                    RH
EQU1     DS    0H                                                   RH
         SR    R9,R9                   CLEAR WORK
         IC    R9,LBLLEN               GET LENGTH
         CVD   R9,DBLWD                CONVERT
         UNPK  DBLWD(3),DBLWD+6(2)     UNPACK
         OI    DBLWD+2,C'0'            CLEAR SIGN
         CH    R9,H100                 LENGTH < 100
         BL    CCXQ10                  YES
         MVC   OPNDS+2(3),DBLWD        MOVE LENGTH
         B     CCXEQC                  GO SET COMMA
CCXQ10   CH    R9,H10                  LENGTH < 10
         BL    CCXQ1                   YES
         MVC   OPNDS+2(2),DBLWD+1      MOVE 2-DIGIT LENGTH
         B     CCXEQC                  GO SET COMMA
CCXQ1    MVC   OPNDS+2(1),DBLWD+2      MOVE 1-DIGIT LENGTH
CCXEQC   MVI   OPNDS+1,C','            SET COMMA
         CLI   CONPROG,1               CONSTANT IN PROGRESS         RH
         BE    CCXEQU             YES                               RH
         MVI   OPNDS+1,C'+'       CHANGE COMMA TO PLUS              RH
         SPACE 1                                                    RH
CCXEQU   BAL   R9,WRTOUT               OUTPUT EQU STATEMENT
         BAL   R9,PRINT                GO PRINT IT
         MVI   LBLOFSET,X'00'     CLEAR EQU+1 FLAG                  RH
         L     R9,EQU9                 GET RETURN ADDR
         BR    R9                      RETURN
         DROP  R6
*
*
*
******************************************************************
*                                                                *
* BUILDS STORAGE OPERANDS CONTAINING BASE, DISPLACEMENT, AND     *
* LENGTH. ON ENTRY, REG 11 CONTAINS THE BDDD ADDRESS, AND REG 10 *
* CONTAINS THE LENGTH. THE SCHLBL ROUTINE IS CALLED TO CREATE A  *
* LABEL REFERENCE, IF THE BASE REG IS CURRENT, AND A LABEL EXISTS*
* IF SCHLBL IS UNSUCCESSFUL, AN EXPLICIT ADDRESS OF THE FORM     *
* DDDD(LLL,RRR) IS CREATED.                                      *
*                                                                *
******************************************************************
*
BDLADR   EQU   *                       *** FORMAT DDDD(LLL,RRR) OPERAND
         ST    R9,BDL9                 SAVE RETURN ADDR
         SR    R0,R0                   CLEAR WORK REG
         LR    R1,R11                  COPY BDDD ADDRESS
         SLDL  R0,20                   BASE REG TO R0
         LTR   R0,R0                   IS BASE REG 0
         BNZ   BDLSCHL                 NO
         SRL   R1,20                   RIGHT JUSTIFY DISPL
         CH    R1,H16                  REFERENCE TO CVT ADDR
         BE    BDLCVTR                 YES
         CH    R1,H76                  REF TO ALTERNATE CVT ADDR
         BE    BDLCVTR                 YES
         MVC   COMMENT(13),=C'PSA REFERENCE'
         B     BDLSCHL                 CONTINUE
BDLCVTR  MVC   COMMENT(11),=C'CVT ADDRESS'
BDLSCHL  BAL   R9,SCHLBL               SEARCH FOR LABEL
         B     BDLGLBL                 BRANCH IF LABEL FOUND
*        MVC   PADDR2,ADDRVAL     SET UP ADDR 2                     RH
         LR    R1,R11                  COPY BDDD ADDRESS
         SLL   R1,20                   SHIFT OUT B
         SRL   R1,20                   RIGHT JUSTIFY DDD
         CVD   R1,DBLWD                CONVERT DDD
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(4),DBLWD+5(3)     UNPACK
         MVC   OPNDWK,BLANX            CLEAR WORK AREA
         CH    R1,H1000                DISPL < 1000
         BL    BDLD100                 YES
         MVC   OPNDWK(4),DBLWD         MOVE 4-DIGIT DISPL
         LA    R1,OPNDWK+4             TO NEXT POS
         B     BDLLPN                  CONTINUE
BDLD100  CH    R1,H100                 DISPL < 100
         BL    BDLD10                  YES
         MVC   OPNDWK(3),DBLWD+1       MOVE 3-DIGIT DISPL
         LA    R1,OPNDWK+3             TO NEXT POS
         B     BDLLPN                  CONTINUE
BDLD10   CH    R1,H10                  DISPL < 10
         BL    BDLD1                   YES
         MVC   OPNDWK(2),DBLWD+2       MOVE 2-DIGIT DISPL
         LA    R1,OPNDWK+2             TO NEXT POS
         B     BDLLPN                  CONTINUE
BDLD1    MVC   OPNDWK(1),DBLWD+3       MOVE 1-DIGIT DISPL
         LA    R1,OPNDWK+1             TO NEXT POS
BDLLPN   MVI   0(R1),C'('              LEFT PAREN DELIMITER
         TM    IEDT,M1                 IS THIS A SPECIAL MOVE INSTR
         BO    *+8                     DON'T ADJUST LENGTH
         LA    R10,1(R10)              COMPUTE ACTUAL LENGTH FROM LENG
         CVD   R10,DBLWD               CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(3),DBLWD+6(2)     UNPACK
         CH    R10,H100                LENGTH < 100
         BL    BDLL10                  YES
         MVC   1(3,R1),DBLWD           MOVE 3-DIGIT LENGTH
         LA    R1,4(R1)                TO NEXT POS
         B     BDLCMA                  CONTINUE
BDLL10   CH    R10,H10                 LENGTH < 10
         BL    BDLL1                   YES
         MVC   1(2,R1),DBLWD+1         MOVE 2-DIGIT LENGTH
         LA    R1,3(R1)                TO NEXT POS
         B     BDLCMA                  CONTINUE
BDLL1    MVC   1(1,R1),DBLWD+2         MOVE 1-DIGIT LENGTH
         LA    R1,2(R1)                TO NEXT POS
BDLCMA   MVC   0(2,R1),=C',R'          DELIMITERS
         SRL   R11,12                  RT JUSTIFY BASE REG
         CVD   R11,DBLWD               CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         CH    R11,H10                 REG < 10
         BL    BDLR1                   YES
         MVC   2(2,R1),DBLWD           MOVE 2-DIGIT REGISTER
         LA    R1,4(R1)                TO NEXT POS
         B     BDLRPN                  CONTINUE
BDLR1    MVC   2(1,R1),DBLWD+1         MOVE 1-DIGIT REG
         CLI   2(R1),C'0'              IS REG = 0
         BNE   BDLB1                   NO
         MVC   0(2,R1),BLANX           YES, BLANK IT
***      BCTR  R1,R0                   BACK UP 1            FIX***
         B     BDLRPN                  CONTINUE
BDLB1    LA    R1,3(R1)                TO NEXT POS
BDLRPN   MVI   0(R1),C')'              FINAL DELIMITER
         LR    R10,R1                  COPY END ADDRESS
         S     R10,OWSTRT              COMPUTE OPERAND LENGTH CODE
         L     R9,BDL9                 GET RETURN ADDR
         BR    R9                      EXIT
         USING LABELD,R12
BDLGLBL  MVC   OPNDWK(8),LBLNAME       LABEL ENTRY NAME TO WORK
*        MVC   PADDR2,ADDRVAL     SET UP ADDR 2                     RH
         LA    R10,1(R10)              COMPUTE ACTUAL LENGTH
         LA    R1,OPNDWK+7             @ LAST POSS CHARACTER
BDLGRHE  CLI   0(R1),C' '              AT RHE
         BNE   BDLGCKLN                YES
         BCT   R1,BDLGRHE              LOOP TO RHE
BDLGCKLN DS    0H                                                   RH
******************************************************************  RH
*              ALWAYS PUT THE LTH ON THE INSTRUCTION OPERANDS       RH
******************************************************************  RH
*        CLM   R10,1,LBLLEN            LBL AND INSTR LENGTHS SAME   RH
*        BE    BDLGCMP                 YES                          RH
******************************************************************  RH
         MVI   1(R1),C'('              NO, DELIMITER
         CVD   R10,DBLWD               CONVERT LENGTH
         UNPK  DBLWD(3),DBLWD+5(3)     UNPACK
         OI    DBLWD+2,C'0'            CLEAR SIGN
         CH    R10,H100                LENGTH < 100
         BL    BDLG10                  YES
         MVC   2(3,R1),DBLWD           MOVE 3-DIGIT LENGTH
         LA    R1,5(R1)                TO NEXT POS
         B     BDLGRPN                 CONTINUE
BDLG10   CH    R10,H10                 LENGTH < 10
         BL    BDLG1                   YES
         MVC   2(2,R1),DBLWD+1         MOVE 2-DIGIT LENGTH
         LA    R1,4(R1)                TO NEXT POS
         B     BDLGRPN                 CONTINUE
BDLG1    MVC   2(1,R1),DBLWD+2         MOVE 1-DIGIT LENGTH
         LA    R1,3(R1)                TO NEXT POS
BDLGRPN  MVI   0(R1),C')'              FINAL DELIMITER
BDLGCMP  LR    R10,R1                  COPY END ADDRESS
         S     R10,OWSTRT              COMPUTE LENGTH CODE
         L     R12,SLSAV+12            RESTORE R12
         L     R9,BDL9                 GET RETURN ADDR
         BR    R9                      EXIT
         DROP  R12
*
*
*
******************************************************************
*                                                                *
* BUILDS STORAGE OPERANDS CONTAINING BASE AND DISPLACEMENT.      *
* THE SCHLBL ROUTINE IS CALLED TO SEE WHETHER A LABEL REFERENCE  *
* MAY BE USED, RATHER THAN AN EXPLICIT ADDRESS. IF LBLSCH IS NOT *
* SUCCESSFUL, AN EXPLICIT ADDRESS OF THE FORM DDDD(RRR) IS FORMED*
* ON ENTRY, REG 11 CONTAINS THE BDDD ADDRESS.                    *
*                                                                *
******************************************************************
*
BDADR    EQU   *                       *** FORMAT DDDD(RRR) OPERANDS **
         ST    R9,BD9                  SAVE RETURN ADDR
         SR    R0,R0                   CLEAR WORK REG
         LR    R1,R11                  COPY BDDD ADDRESS
         SLDL  R0,20                   BASE REG TO R0
         LTR   R0,R0                   IS BASE REG 0
         BNZ   BDSCHL                  NO
         CLI   TEXT,X'8F'              IS IT SLDA??              FIX***
         BH    BDSADR1                 YES                       FIX***
         CLI   TEXT,X'88'              IS IT SRL                 FIX***
         BNL   BDSCHL                  YES                       FIX***
BDSADR1  SRL   R1,20                   RIGHT JUSTIFY DISPL       FIX***
         CH    R1,H16                  REFERENCE TO CVT ADDR
         BE    BDCVTR                  YES
         CH    R1,H76                  REF TO ALTERNATE CVT ADDR
         BE    BDCVTR                  YES
         MVC   COMMENT(13),=C'PSA REFERENCE'
         B     BDSCHL                  CONTINUE
BDCVTR   MVC   COMMENT(11),=C'CVT ADDRESS'
BDSCHL   BAL   R9,SCHLBL               GO SEARCH FOR LABEL
         B     BDGLBL                  BRANCH IF FOUND
*        MVC   PADDR1,ADDRVAL     SET UP ADDR 1                     RH
         LR    R1,R11                  COPY BDDD ADDRESS
         SLL   R1,20                   SHIFT OUT B
         SRL   R1,20                   RIGHT JUSTIFY DDD
         CVD   R1,DBLWD                CONVERT DISPL
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(4),DBLWD+5(3)     UNPACK
         CH    R1,H1000                DISPL < 1000
         BL    BDAD100                 YES
         MVC   OPNDWK(4),DBLWD         MOVE 4-DIGIT DISPL
         LA    R1,OPNDWK+4             TO NEXT POS
         B     BDALPN                  CONTINUE
BDAD100  CH    R1,H100                 DISPL < 100
         BL    BDAD10                  YES
         MVC   OPNDWK(3),DBLWD+1       MOVE 3-DIGIT DISPL
         LA    R1,OPNDWK+3             TO NEXT POS
         B     BDALPN                  CONTINUE
BDAD10   CH    R1,H10                  DISPL < 10
         BL    BDAD1                   YES
         MVC   OPNDWK(2),DBLWD+2       MOVE 2-DIGIT DISPL
         LA    R1,OPNDWK+2             TO NEXT POS
         B     BDALPN                  CONTINUE
BDAD1    MVC   OPNDWK(1),DBLWD+3       MOVE 1-DIGIT DISPL
         LA    R1,OPNDWK+1             TO NEXT POS
BDALPN   MVC   0(2,R1),=C'(R'          DELIMITERS
         SRL   R11,12                  RT JUSTIFY BASE REG
         CVD   R11,DBLWD               CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         CH    R11,H10                 BASE REG < 10
         BL    BDAR1                   YES
         MVC   2(2,R1),DBLWD           MOVE 2-DIGIT BASE REG
         LA    R1,4(R1)                TO NEXT POS
         B     BDARPN                  CONTINUE
BDAR1    MVC   2(1,R1),DBLWD+1         MOVE 1-DIGIT BASE REG
         LA    R1,3(R1)                TO NEXT POS
BDARPN   MVI   0(R1),C')'              FINAL DELIMITER
         LR    R2,R1                   COPY END ADDRESS
         SH    R2,H4                   BACK UP 4
         CLC   1(4,R2),=C'(R0)'        BASE REG IS ZERO
         BNE   BDCE                    NO
         MVC   1(4,R2),BLANX           CLEAR BASE REG
         LR    R1,R2                   COPY NEW END ADDR
BDCE     LR    R10,R1                  COPY END ADDR
         S     R10,OWSTRT              COMPUTE LENGTH CODE
         L     R9,BD9                  GET RETURN ADDR
         BR    R9                      EXIT
         USING LABELD,R12
BDGLBL   MVC   OPNDWK(8),LBLNAME       LABEL ENTRY NAME TO WORK
*        MVC   PADDR1,ADDRVAL     SET UP ADDR 1                     RH
         LA    R1,OPNDWK+7             @ LAST POSS CHARACTER
BDGRHE   CLI   0(R1),C' '              AT RHE
         BNE   BDGCMP                  YES
         BCT   R1,BDGRHE               LOOP TO RHE
BDGCMP   LR    R10,R1                  COPY END ADDRESS
         S     R10,OWSTRT              COMPUTE LENGTH CODE
         L     R12,SLSAV+12            RESTORE R12
         L     R9,BD9                  GET RETURN ADDR
         BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* BUILDS STORAGE OPERANDS CONTAINING BASE, DISPLACEMENT, AND     *
* INDEX. ON ENTRY, REG 11 CONTAINS THE BDDD ADDRESS, AND REG 10  *
* CONTAINS THE INDEX. THE SCHLBL ROUTINE IS CALLED TO CREATE A   *
* LABEL REFERENCE, IF THE BASE REG IS CURRENT, AND A LABEL EXISTS*
* IF SCHLBL IS UNSUCCESSFUL, AN EXPLICIT ADDRESS OF THE FORM     *
* DDDD(XXX,RRR) IS CREATED.                                      *
*                                                                *
******************************************************************
*
BDXADR   EQU   *                       *** FORMAT DDDD(XXX,BBB) OPERAND
         ST    R9,BDX9                 SAVE RETURN ADDR
         LTR   R10,R10                 ANY INDEX REG
         BNZ   BDXSCHL                 YES
         SR    R0,R0                   CLEAR WORK REG
         LR    R1,R11                  COPY BDDD ADDRESS
         SLDL  R0,20                   BASE REG TO R0
         LTR   R0,R0                   IS BASE REG 0
         BNZ   BDXSCHL                 NO
         CLI   TEXT,X'41'              IS IT LA
         BE    BDXSCHL                 YES
         SRL   R1,20                   RIGHT JUSTIFY DISPL
         CH    R1,H16                  REFERENCE TO CVT ADDR
         BE    BDXCVTR                 YES
         CH    R1,H76                  REF TO ALTERNATE CVT ADDR
         BE    BDXCVTR                 YES
         MVC   COMMENT(13),=C'PSA REFERENCE'
         B     BDXSCHL                 CONTINUE
BDXCVTR  MVC   COMMENT(11),=C'CVT ADDRESS'
BDXSCHL  BAL   R9,SCHLBL               GO SEARCH FOR LABEL
         B     BDXGLBL                 BRANCH IF FOUND
         MVC   PADDR2,ADDRVAL     SET UP ADDR 2                     RH
         LR    R1,R11                  COPY BDDD ADDRESS
         SLL   R1,20                   SHIFT OUT BASE REG
         SRL   R1,20                   RIGHT JUSTIFY DISPL
         SRL   R11,12                  RT JUSTIFY BASE REG
         CVD   R1,DBLWD                CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(4),DBLWD+5(3)     UNPACK
         CH    R1,H1000                DISPL < 1000
         BL    BDXD100                 YES
         MVC   OPNDWK(4),DBLWD         MOVE 4-DIGIT DISPL
         LA    R1,OPNDWK+4             TO NEXT POS
         B     BDXLPN                  CONTINUE
BDXD100  CH    R1,H100                 DISPL < 100
         BL    BDXD10                  YES
         MVC   OPNDWK(3),DBLWD+1       MOVE 3-DIGIT DISPL
         LA    R1,OPNDWK+3             TO NEXT POS
         B     BDXLPN                  CONTINUE
BDXD10   CH    R1,H10                  DISPL < 10
         BL    BDXD1                   YES
         MVC   OPNDWK(2),DBLWD+2       MOVE 2-DIGIT DISPL
         LA    R1,OPNDWK+2             TO NEXT POS
         B     BDXLPN                  CONTINUE
BDXD1    MVC   OPNDWK(1),DBLWD+3       MOVE 1-DIGIT DISPL
         LA    R1,OPNDWK+1             TO NEXT POS
BDXLPN   LTR   R10,R10                 ANY INDEX REG
         BNZ   BDXLPNR                 YES
         LTR   R11,R11                 ANY BASE REG
         BNZ   PREPB                   YES
         BCTR  R1,R0                   NO, BACK UP TO RHE
         B     BDXCE                   CONTINUE
PREPB    MVC   0(3,R1),=C'(,R'         DELIMITERS
         LA    R1,1(R1)                STEP OVER 1 BYTE
         B     BDXCBAS                 CONTINUE
BDXLPNR  MVC   0(2,R1),=C'(R'          DELIMITERS
         CVD   R10,DBLWD               CONVERT INDEX REG
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         CH    R10,H10                 INDEX REG < 10
         BL    BDXX1                   YES
         MVC   2(2,R1),DBLWD           MOVE 2-DIGIT INDEX REG
         LA    R1,4(R1)                TO NEXT POS
         B     BDXCMA                  CONTINUE
BDXX1    MVC   2(1,R1),DBLWD+1         MOVE 1-DIGIT INDEX REG
         LA    R1,3(R1)                TO NEXT POS
BDXCMA   LTR   R11,R11                 ANY BASE REG
         BZ    BDXRPN                  NO
         MVC   0(2,R1),=C',R'          DELIMITERS
BDXCBAS  CVD   R11,DBLWD               CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         CH    R11,H10                 BASE REG < 10
         BL    BDXB1                   YES
         MVC   2(2,R1),DBLWD           MOVE 2-DIGIT BASE REG
         LA    R1,4(R1)                TO NEXT POS
         B     BDXRPN                  CONTINUE
BDXB1    MVC   2(1,R1),DBLWD+1         MOVE 1-DIGIT BASE REG
         LA    R1,3(R1)                TO NEXT POS
BDXRPN   MVI   0(R1),C')'              FINAL DELIMITER
BDXCE    LR    R10,R1                  COPY END ADDR
         S     R10,OWSTRT              COMPUTE LENGTH CODE
         L     R9,BDX9                 GET RETURN ADDR
         BR    R9                      EXIT
         USING LABELD,R12
BDXGLBL  MVC   OPNDWK(8),LBLNAME       LABEL ENTRY NAME TO WORK
         MVC   PADDR2,ADDRVAL     SET UP ADDR 2                     RH
         LA    R1,OPNDWK+7             @ LAST POSS CHARACTER
BDXGRHE  CLI   0(R1),C' '              AT RHE
         BNE   BDXGCKLN                YES
         BCT   R1,BDXGRHE              LOOP TO RHE
BDXGCKLN LTR   R10,R10                 ANY INDEX REGISTER
         BZ    BDXGCMP                 NO
         MVI   1(R1),C'('              YES, DELIMITER
         CVD   R10,DBLWD               CONVERT LENGTH
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         OI    DBLWD+1,C'0'            CLEAR SIGN
BDXG10   CH    R10,H10                 LENGTH < 10
         BL    BDXG1                   YES
         MVC   2(2,R1),DBLWD           MOVE 2-DIGIT LENGTH
         LA    R1,4(R1)                TO NEXT POS
         B     BDXGRPN                 CONTINUE
BDXG1    MVC   2(1,R1),DBLWD+1         MOVE 1-DIGIT LENGTH
         LA    R1,3(R1)                TO NEXT POS
BDXGRPN  MVI   0(R1),C')'              FINAL DELIMITER
BDXGCMP  LR    R10,R1                  COPY END ADDRESS
         S     R10,OWSTRT              COMPUTE LENGTH CODE
         L     R12,SLSAV+12            RESTORE R12
         L     R9,BDX9                 GET RETURN ADDR
         BR    R9                      EXIT
*
*
*
WRTOUT   EQU   *                       WRITE OUTPUT RECORDS
         L     R1,PUNCHDCB             @ SYSPUNCH DCB
         MVC   PLABEL(80),WORKREC      SAVE IN PRINT                RH
*        MVC   PRT(80),WORKREC         SAVE IN PRINT
         TM    48(R1),X'10'            IS FILE OPEN
         BZ    CLRWKR                  NO
         AP    CARDNO,=P'10'           INCREMENT CARD NO
         UNPK  SEQNBR,CARDNO           UNPACK INTO CARD
         OI    SEQNBR+7,C'0'           CLEAR SIGN
         MVC   PSEQ,SEQNBR        PUT SEQUENCE NUMBER IN LISTING    RH
         PUT   (1),WORKREC             WRITE SOURCE CARD
CLRWKR   MVC   WORKREC,BLANX           CLEAR OUTPUT RECORD
         BR    R9                      RETURN
*
*
*
******************************************************************
*                                                                *
* SEARCHES THE BASE REGISTER TABLE TO FIND THE BASE REGISTER     *
* ASSOCIATED WITH THE BDDD OPERAND ADDRESS PASSED IN REG 11 ON   *
* ENTRY. IF THE BASE REGISTER GIVEN IS NOT A CURRENT BASE REG    *
* THE UNSUCCESSFUL RETURN IS MADE TO 4 BYTES PAST THE ADDRESS    *
* IN REG 9 ON ENTRY. WHEN THE CURRENT BASE REGISTER ENTRY IS FOR *
* A PROGRAM BASE REG, THE DISPLACEMENT IS ADDED TO THE ASSUMED   *
* BASE REGISTER VALUE IS ADDED TO THE DISPLACEMENT TO GIVE AN    *
* OFFSET IN THE PROGRAM. THE LABEL TABLE IS SEARCHED FOR AN ENTRY*
* WITH THIS OFFSET, AND IF FOUND, IS RETURNED TO THE CALLER. WHEN*
* THE BASE REGISTER FOUND IS FOR A DSECT, THE DSECT HEADER ENTRY *
* ADDRESS IS GIVEN IN THE BASE TABLE ENTRY. THE DSECT HEADER HAS *
* THE ADDRESS OF THE FIELD DEFINITION TABLE FOR THE DSECT. THE   *
* FIELD DEFINITION TABLE IS SEARCHED FOR AN ENTRY HAVING THE     *
* DISPLACEMENT IN THE BDDD INSTRUCTION, AND IF FOUND IS PASSED   *
* BACK TO THE CALLER. IF THE LABEL/FIELD TABLE SEARCHES ARE      *
* UNSUCCESSFUL, RETURN IS TO 4 BYTES PAST REG 9.                 *
*                                                                *
******************************************************************
*
SCHLBL   EQU   *                       *** SEARCH FOR LABEL AT BDDD ADD
*        TM    MORUSG,X'80'            ANY BASES ACTIVE             RH
*        BZ    4(R9)                   NO, UNSUCCESSFUL EXIT        RH
         STM   R9,R12,SLSAV            YES, SAVE REGS USED
         LR    R12,R11                 COPY BDDD ADDRESS
         SRL   R12,12                  CLEAR WORK REG
*        LTR   R12,R12                 IS BASE REG ZERO             RH
*        BZ    SCHNF                   YES, NO LABEL                RH
         MH    R12,USGLEN              BASE X BASE TBL ENTRY LENG
         LA    R12,BASES(R12)          @ BASE TBL ENTRY
         USING USINGD,R12
*        CLI   USTYPE,0                ENTRY IN USE                 RH
*        BE    SCHNF                   NO, EXIT                     RH
         LR    R9,R11                  COPY BDDD ADDRESS
         SLL   R9,20                   SHIFT OUT BASE
         SRL   R9,20                   RIGHT JUSTIFY DDD
         LR    R14,R9                  SAVE DISPLACEMENT            RH
         TM    MORUSG,X'80'            ANY BASES ACTIVE             RH
         BZ    SCHNF                   NO, UNSUCCESSFUL EXIT        RH
         USING USINGD,R12
         CLI   USTYPE,0                ENTRY IN USE                 RH
         BE    SCHNF                   NO, EXIT                     RH
         ICM   R11,7,USVALU            GET BASE REG VALUE
         LA    R11,0(R11)              CLEAR HI-ORDER
         CLI   USTYPE,C'P'             PROGRAM BASE REG
         BE    PGMBASE                 YES
         DROP  R12
         LR    R12,R11                 COPY DSECT FIELD TBL ADDRESS
         USING DSECTD,R12
CKDSCTND CLM   R9,7,DSOFSET            THIS THE ENTRY
         BE    SCHFD                   YES
         CLC   DSOFSET,HIVAL           NO, AT TABLE END
         BE    SCHNF                   YES, NO LABEL FOUND
         LA    R12,L'DSECT(R12)        STEP TO NEXT ENTRY
         B     CKDSCTND                LOOP THRU DSECT FIELDS
PGMBASE  AR    R9,R11                  COMPUTE OFFSET
         LR    R14,R9                  SAVE DISPLACEMENT            RH
         DROP  R12
         L     R12,LBLTBL              @ LABEL TABLE
         USING LABELD,R12
CKENTFD  CLM   R9,7,LBLADR             THIS THE ENTRY
         BE    SCHFD                   YES
         LA    R12,L'LABEL(R12)        TO NEXT ENTRY
         C     R12,CURRLBL             END OF TBL
         BNL   SCHNF                   YES, NO LABEL
         B     CKENTFD                 NO, CONTINUE SEARCH
SCHNF    DS    0H                                                   RH
         BAL   R10,G10ADDR        CONVERT DISP TO DISPLAY           RH
         LM    R9,R12,SLSAV            NOT FOUND, RESTORE REGS
         B     4(R9)                   NOT FOUND RETURN
SCHFD    DS    0H                                                   RH
         BAL   R10,G10ADDR        CONVERT DISP TO DISPLAY           RH
         LM    R9,R11,SLSAV            FOUND RESTORE ALL BUT 12
         BR    R9                      FOUND RETURN
         DROP  R12
*
G10ADDR  DS    0H                                                   RH
         ST    R14,DWORD                SAVE ADDRESS 2              RH
         SR    R14,R14                  CLEAR R14                   RH
         IC    R14,DWORD+1              R14 = BYTE 2                RH
         STC   R14,ADDRVAL              STORE IN ADDR               RH
         IC    R14,DWORD+2              R14 = BYTE 3 OF ADDR        RH
         STC   R14,ADDRVAL+2            SET UP BYTE 3 OF ADDR       RH
         SRL   R14,4                    DROP BYTE 3                 RH
         STC   R14,ADDRVAL+1            SET UP BYTE 2               RH
         IC    R14,DWORD+3              R14 = BYTE 4                RH
         STC   R14,ADDRVAL+4            SET UP BYTE 5               RH
         SRL   R14,4                    DROP BYTE 5                 RH
         STC   R14,ADDRVAL+3            SET UP BYTE 4               RH
         MVZ   ADDRVAL+2(3),ADDRVAL+1   ZONE = 0                    RH
         MVZ   ADDRVAL(1),ADDRVAL+1     ZONE = 0                    RH
         TR    ADDRVAL(5),OPTRT         TRANSLATE ADDRESS           RH
         BR    R10                      RETURN TO CALLER            RH
         SPACE 1                                                    RH
DWORD    DS    D                                                    RH
ADDRVAL  DS    CL5                                                  RH
*
*
******************************************************************
*                                                                *
* PRINT A LINE USING THE SYSPRINT DCB DEFINED IN DISASM PHASE 0. *
*                                                                *
******************************************************************
*
PRINT    DS    0H                      PRINT ROUTINE                RH
         AP    STMTCTR,P1               ADD 1 TO STATEMENT COUNTER  RH
         MVC   PSTMT-2(6),=X'402020202120' EDIT STATEMENT COUNTER   RH
         ED    PSTMT-2(6),STMTCTR       *                           RH
         L     R1,PRINTDCB             @ SYSPRINT DCB
         TM    48(R1),X'10'            IS SYSPRINT OPEN
         BNO   CLRPRT                  NO
         PUT   (1),PRTLINE             WRITE PRINT LINE
CLRPRT   MVC   PRT,BLANX               CLEAR PRINT LINE
         AP    LINECT,P1               INCR LINE COUNTER
         CLI   PCC,C' '                SINGLE SPACED
         BE    SETSGL                  YES
         AP    LINECT,P1               INCR LINE COUNTER
         CLI   PCC,C'0'                DOUBLE SPACED
         BE    SETSGL                  YES
         AP    LINECT,P1               INCR LINE COUNTER
         CLI   PCC,C'-'                TRIPLE SPACED
         BE    SETSGL                  YES
         ZAP   LINECT,P0               NO, MUST BE NEW PAGE
SETSGL   MVI   PCC,C' '                SET SINGLE SPACING
         CP    LINECT,P58              PAST END OF PAGE
         BH    NEWPAGE                 YES
         BR    R9                      EXIT
         SPACE 1                                                    RH
NEWPAGE  DS    0H                                                   RH
         MVI   PCC,C'1'                SET SKIP TO HOF
         ZAP   LINECT,P0               RESET LINE COUNTER
*        BR    R9                      EXIT                         RH
         SPACE 3                                                    RH
********************************************************************RH*
*                                                                   RH*
*        ROUTINE TO PRINT HEADING. RETURN ON R9                     RH*
*                                                                   RH*
********************************************************************RH*
         SPACE 2                                                    RH
L10HEAD  DS    0H                                                   RH
         AP    PAGECTR,P1         ADD 1 TO PAGE COUNTER             RH
         L     R1,PRINTDCB             @ SYSPRINT DCB               RH
         TM    48(R1),X'10'            IS SYSPRINT OPEN             RH
         BNO   CLRPRT1                 NO                           RH
         PUT   (1),PRTLINE        SKIP TO NEW PAGE                  RH
         SPACE 1                                                    RH
         MVC   PAGENO,=X'40202020'      EDIT PAGE NUMBER            RH
         ED    PAGENO,PAGECTR           *                           RH
         MVC   PRT,HEAD1                MOVE HEADING TO PRINT       RH
         MVI   PCC,C' '           PRINT, SPACE 1                    RH
         AP    LINECT,P1          ADD 1 TO LINE COUNT               RH
         L     R1,PRINTDCB             @ SYSPRINT DCB               RH
         PUT   (1),PRTLINE        PRINT HEADING                     RH
         MVC   PRT,BLANX          CLEAR PRINT LINE                  RH
         MVI   PCC,C'0'           SPACE 2 LINES                     RH
         SPACE 1                                                    RH
CLRPRT1  DS    0H                                                   RH
         BR    R9                       RETURN TO CALLER
*AGECTR  DC    PL2'0'             PAGE COUNTER                      RH
*TMTCTR  DC    PL3'0'             STATEMENT COUNTER                 RH
*EQNUM   DC    PL4'0'             SEQUENCE NUMBER                   RH
*EQINC   DC    P'100'             SEQUENCE INCREMENT                RH
*
*
*
******************************************************************
*                                                                *
* CONVERT HEX DATA TO PRINTABLE FORM: 2 CHARACTERS PER BYTE. ON  *
* ENTRY, REG 12 CONTAINS THE ADDRESS OF THE LEFT END OF THE FIELD*
* TO BE CONVERTED, AND THE ENTRY POINT USED DETERMINES THE LENGTH*
* FORMATTED OUTPUT IS PLACED IN THE PRTABL FIELD.                *
*                                                                *
******************************************************************
*
HEXPRT   DS    0H                      HEX TO PRINTABLE ROUTINE
HEXPRT1  UNPK  PRTABL(3),0(2,R12)      UNPACK HEX
         B     HEXCLTR                 CONTINUE
HEXPRT2  UNPK  PRTABL(5),0(3,R12)      UNPACK HEX
         B     HEXCLTR                 CONTINUE
HEXPRT3  UNPK  PRTABL(7),0(4,R12)      UNPACK HEX
         B     HEXCLTR                 CONTINUE
HEXPRT4  UNPK  PRTABL(9),0(5,R12)      UNPACK HEX
HEXCLTR  MVZ   PRTABL(8),XZROS         CLEAR FOR TRANSLATE
         TR    PRTABL(8),TRTBL         MAKE PRINTABLE
         BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* FORMATS THE HEX DATA CORRESPONDING TO THE FORMATTED INSTRUCTION*
* BEING OUTPUT. PRINTABLE HEX IS PLACED AT THE RIGHT OF THE LINE *
* ON THE SYSPRINT OUTPUT.                                        *
*                                                                *
******************************************************************
*
TXTFMT   EQU   *                       *** FORMAT TEXT FOR PRINT ***
         ST    R9,TX9                  SAVE RETURN ADDR
         LA    R11,PRT                 @ PRINT LINE
         CLI   TYPE,1                  ADCON
         BE    TFOFST                  YES
         CLI   TYPE,2                  CONSTANT
         BE    TFOFST                  YES
         CLI   TYPE,X'0D'              INSTRUCTION
         BNE   TXTCLEAN                NO
TFOFST   LA    R12,OFFSET              @ OFFSET TO INSTR
         BAL   R9,HEXPRT3              CONVERT TO PRINTABLE
         MVC   PLOCN(6),PRTABL         OFFSET TO PRINT              RH
*        MVC   PRT+00(6),PRTABL        OFFSET TO PRINT
*        LA    R12,LEN                 @ DATA LENGTH
*        BAL   R9,HEXPRT1              MAKE PRINTABLE
*        MVC   PRT+08(2),PRTABL        LENGTH TO PRINT
*        LA    R12,TEXT                @ TEXT TO PRINT
         SPACE 1                                                    RH
********************************************************************RH
*                                                                  *RH
*        ROUTINE TO SET UP OBJECT CODE                             *RH
*                                                                  *RH
********************************************************************RH
         SPACE 2                                                    RH
H10OBJEC DS    0H                                                   RH
         LA    R2,TEXT                @ TEXT TO PRINT               RH
         SR    R14,R14                  CLEAR R14                   RH
         IC    R14,0(0,R2)              R14 = 1ST BYTE OF OBJ CODE  RH
         STC   R14,POBJ2+1              SET UP 2ND BYTE             RH
         SRL   R14,4                    SET UP 1ST BYTE             RH
         STC   R14,POBJ2                *                           RH
         MVZ   POBJ2+1(1),POBJ2         ZONE = 0                    RH
         CLI   LEN,X'01'                INST LTH = 1 ?              RH
         BE    H60                      YES, 1 BYTE DC              RH
         SPACE 1                                                    RH
         IC    R14,1(0,R2)              R14 = 2ND BYTE OF OBJ CODE  RH
         STC   R14,POBJ2+3              SET UP 4TH BYTE             RH
         SRL   R14,4                    SET UP 3RD BYTE             RH
         STC   R14,POBJ2+2              *                           RH
         MVZ   POBJ2+3(1),POBJ2+2       ZONE = 0                    RH
         TR    POBJ2,OPTRT              TRANSLATE OBJECT CODE 1 & 2 RH
         CLI   LEN,X'02'                INST LTH = 2 ?              RH
         BE    H50                      YES, END OF SET-UP          RH
         SPACE 1                                                    RH
         IC    R14,2(0,R2)              R14 = 3RD BYTE OF OBJ CODE  RH
         STC   R14,POBJ4+1              SET UP 6TH BYTE             RH
         SRL   R14,4                    SET UP 5TH BYTE             RH
         STC   R14,POBJ4                *                           RH
         MVZ   POBJ4+1(1),POBJ4         ZONE = 0                    RH
         CLI   LEN,X'03'                INST LTH = 3 ?              RH
         BE    H70                      YES, 3 BYTE DC              RH
         SPACE 1                                                    RH
         IC    R14,3(0,R2)              R14 = 4TH BYTE OF OBJ CODE  RH
         STC   R14,POBJ4+3              SET UP 8TH BYTE             RH
         SRL   R14,4                    SET UP 7TH BYTE             RH
         STC   R14,POBJ4+2              *                           RH
         MVZ   POBJ4+3(1),POBJ4+2       ZONE = 0                    RH
         TR    POBJ4,OPTRT              TRANSLATE OBJECT CODE 3 & 4 RH
         CLI   LEN,X'04'                INST LTH = 4 ?              RH
         BE    H50                      YES, END OF SET-UP          RH
         SPACE 1                                                    RH
         IC    R14,4(0,R2)              R14 = 5TH BYTE OF OBJ CODE  RH
         STC   R14,POBJ6+1              SET UP 10TH BYTE            RH
         SRL   R14,4                    SET UP  9TH BYTE            RH
         STC   R14,POBJ6                *                           RH
         MVZ   POBJ6+1(1),POBJ6         ZONE = 0                    RH
         SPACE 1                                                    RH
         IC    R14,5(0,R2)              R14 = 6TH BYTE OF OBJ CODE  RH
         STC   R14,POBJ6+3              SET UP 12TH BYTE            RH
         SRL   R14,4                    SET UP 11TH BYTE            RH
         STC   R14,POBJ6+2              *                           RH
         MVZ   POBJ6+3(1),POBJ6+2       ZONE = 0                    RH
         TR    POBJ6,OPTRT              TRANSLATE OBJECT CODE 5 & 6 RH
         SPACE 1                                                    RH
H50      DS    0H                       END OF SET-UP               RH
         CLC   PCODE,=CL5'DC'     IS THIS INST A DC ?               RH
         BNE   H90                NO, RETURN TO CALLER              RH
         MVC   POBJ2+4(4),POBJ4   DROP FIRST BLANK                  RH
         MVC   POBJ2+8(4),POBJ6   DROP 2ND BLANK                    RH
         MVC   POBJ6+2(2),PCODE+2 CLEAR LAST 2 BYTES                RH
*                                                                   RH
*        SINCE WE ARE DOING A DE- COMPILE, DON'T CHANGE             RH
*        ANY OF THE ACTUAL OBJECT CODE, AS IT REPRESENTS            RH
*        WHAT  IS REALLY IN THE LOAD  MODULE.....                   RH
*                                                                   RH
*        CLI   POPNDS,C'V'        IS IT A VCON?                     RH
*        BNE   H90                NO                                RH
*        MVI   POBJ2,C'0'         YES, OBJECT CODE IS ZERO          RH
*        MVC   POBJ2+1(5),POBJ2     ''                              RH
*                                                                   RH
         B     H90                      RETURN TO CALLER            RH
         SPACE 1                                                    RH
H60      DS    0H                                                   RH
         TR    POBJ2(2),OPTRT           TRANSLATE 1 BYTE            RH
         B     H50                      GET OUT                     RH
         SPACE 1                                                    RH
H70      DS    0H                                                   RH
         TR    POBJ4(2),OPTRT           TRANSLATE 1 BYTE            RH
         B     H50                      GET OUT                     RH
         SPACE 1                                                    RH
OPTRT    DS    0H                                                   RH
         DC    C'0123456789ABCDEF'                                  RH
         SPACE 1                                                    RH
*        BAL   R9,HEXPRT4              CONVERT 1ST 4 BYTES
*        CLI   LEN,4                   IS IT 4 BYTES
*        BNL   TXT4                    YES, OR MORE
*        CLI   LEN,3                   IS IT 3 BYTES
*        BE    TXT3                    YES
*        CLI   LEN,2                   IS IT 2 BYTES
*        BE    TXT2                    YES
*        MVC   PRT+94(2),PRTABL        TEXT TO PRINT
*        B     TXTCLEAN                FINISH
*XT2     MVC   PRT+94(4),PRTABL        TEXT TO PRINT
*        B     TXTCLEAN                FINISH
*XT3     MVC   PRT+94(6),PRTABL        TEXT TO PRINT
*        B     TXTCLEAN                FINISH
*XT4     MVC   PRT+94(8),PRTABL        TEXT TO PRINT
*        CLI   LEN,4                   IS IT 4 BYTES
*        BE    TXTCLEAN                YES, FINISH
*        LA    R12,TEXT+4              @ TEXT
*        BAL   R9,HEXPRT4              CONVERT
*        CLI   LEN,8                   8 BYTES OF TEXT
*        BNL   TXT8                    YES                          RH
*        BE    TXT8                    YES
*        CLI   LEN,7                   7 BYTES OF TEXT
*        BE    TXT7                    YES
*        CLI   LEN,6                   6 BYTES OF TEXT
*        BE    TXT6                    YES
*        MVC   PRT+98(2),PRTABL        TEXT TO PRINT
*        B     TXTCLEAN                FINISH
*XT6     MVC   PRT+102(4),PRTABL       TEXT TO PRINT
*        B     TXTCLEAN                FINISH
*XT7     MVC   PRT+102(6),PRTABL       TEXT TO PRINT
*        B     TXTCLEAN                FINISH
*XT8     MVC   PRT+102(8),PRTABL       TEXT TO PRINT
         SPACE 1
H90      DS    0H
TXTCLEAN XC    OFFSET,OFFSET           CLEAR
         L     R9,TX9                  GET RETURN ADDR
         BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* ENTERED WHENEVER THE CURRENT TEXT OFFSET IS PAST THE NEXCHG    *
* FIELD VALUE. THIS ROUTINE CREATES DROP CARDS FOR EXHAUSTED BASE*
* REGISTERS, AND USING STATEMENTS FOR NEW BASE REGISTERS. THE    *
* BASES TABLE IS SCANNED, AND ANY ENTRY WHICH IS NO LONGER IN USE*
* IS ZEROED OUT, AND A DROP RECORD IS CREATED. NEXT, THE USING   *
* TABLE IS SCANNED. WHEN AN ENTRY IS FOUND WHICH IS VALID AT THE *
* CURRENT OFFSET, THE BASE TABLE IS CHECKED. IF THE ENTRY IS NOT *
* IN USE, A USING STATEMENT IN CREATED, AND THE USING TABLE ENTRY*
* IS MOVED TO THE BASES TABLE. THE NEXCHG FIELD IS CHANGED TO    *
* CONTAIN THE OFFSET AT WHICH THE NEXT SCAN MUST BE MADE. AN IND-*
* ICATOR CALLED MORUSG IS SET TO SHOW WHEN ANY BASE REGISTERS ARE*
* CURRENTLY IN USE. WHEN NO MORE REGISTERS ARE AVAILABLE, THE    *
* NEXCHG FIELD IS SET TO HEX FF'S.                               *
*                                                                *
******************************************************************
*
NEXUSG   EQU   *                       *** GET NEXT BASE REG SET ***
         MVC   NEXCHG,HIVAL            RESET NEXT CHANGE ADDR
         MVI   MORUSG,0                CLEAR BASE REG AVAIL INDIC
         ST    R9,USG9                 SAVE RETURN ADDR
*        XC    BASES(L'USING),BASES    CLEAR R0 ELEMENT
         MVC   BASES+16*L'USING(4),HIVAL SET TABLE STOPPER
         USING USINGD,R2
         LA    R2,BASES                @ R0'S ELEMENT
*        LA    R2,BASES+L'USING        @ R1'S ELEMENT
DRPCKND  CLI   0(R2),X'FF'             END OF TABLE
         BE    USGUSG                  YES
         CLC   USEND,XZROS             ENTRY USED
         BE    DRPSTEP                 NO
         CLC   TXTOFSET,USEND          PAST END OF THIS ONE
         BL    DRPSTEP                 NO
         MVC   MNEMONIC(4),=C'DROP'    OPERATION IS DROP
         MVI   OPNDS,C'R'              DELIMITER FOR REGS
         SR    R12,R12                 CLEAR WORK
         IC    R12,USREG               GET REG
         CVD   R12,DBLWD               CONVERT TO PACKED
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         OI    DBLWD+1,C'0'            CLEAR SIGN
         CH    R12,H10                 REG < 10
         BL    DPR1                    YES
         MVC   OPNDS+1(2),DBLWD        MOVE REG NBR
         B     WRTDROP                 GO WRITE DROP
DPR1     MVC   OPNDS+1(1),DBLWD+1      MOVE 1-DIGIT REG
WRTDROP  BAL   R9,WRTOUT               WRITE DROP RECORD
         BAL   R9,PRINT                PRINT DROP RECORD
         XC    USING,USING             CLEAR THE ENTRY
DRPSTEP  LA    R2,L'USING(R2)          TO NEXT BASE ELEMENT
         B     DRPCKND                 LOOP
USGUSG   L     R2,USGSTRT              GET FIRST USING TBL ADDR
ENDUS    CLI   0(R2),X'FF'             END OF TABLE
         BE    XITUS                   YES
         CLC   TXTOFSET,USEND          PAST END OF THIS ONE
         BNL   ECSTEP                  YES
         OI    MORUSG,1                SHOW MORE BASES AVAIL
USBGCK   CLC   TXTOFSET,USBGN          CURR LOC BEFORE THIS
         BNL   CKNEWLO                 NO
         CLC   USBGN,NEXCHG            BEGINS BEFORE NEXT CHANGE
         BNL   ECSTEP                  NO
         MVC   NEXCHG,USBGN            YES, SET LOWER CHANGE OFFSET
         B     ECSTEP                  CONTINUE
CKNEWLO  CLC   USEND,NEXCHG            THIS ENTRY ENDS EARLIER
         BNL   ECMVC                   NO
         MVC   NEXCHG,USEND            YES, SET NEW END
ECMVC    SR    R1,R1                   CLEAR WORK
         IC    R1,USREG                PICK UP REG
         MH    R1,USGLEN               TIMES ENTRY LENGTH
         LA    R1,BASES(R1)            @ BASE TABLE ENTRY
         OI    MORUSG,X'80'            SHOW BASE IN USE
         CLC   USING,0(R1)             OLD AND NEW IDENTICAL
         BE    ECSTEP                  YES
MAKUSG   MVC   0(L'USING,R1),USING     NEW USING TO TABLE
         MVC   MNEMONIC(5),=C'USING'   OPERATION IS USING
         CLI   USTYPE,C'D'             IS IT A DSECT
         BNE   CKUTPS                  NO
         ICM   R12,7,USVALU            YES, GET DSECT HEADER ADDR
         L     R11,DTBSTRT             @ 1ST DSECT HEADER ENTRY
DSCTEND  C     R11,DTBCUR              END OF TABLE
         BH    MVDSNAME                YES
         CLM   R12,7,8(11)             THIS THE HEADER ENTRY
         BNE   DSCTSTEP                NO
         LR    R12,R11                 YES, COPY IT'S ADDRESS
         B     MVDSNAME                CONTINUE
DSCTSTEP LA    R11,11(R11)             TO NEXT HEADER ENTRY
         B     DSCTEND                 LOOP THRU TABLE
MVDSNAME MVC   OPNDS(8),0(R12)         DSECT NAME TO OPERANDS
         LA    R12,OPNDS+7             TO END OF NAME
USFRHED  CLI   0(R12),C' '             FOUND RHE
         BNE   USFMADD                 YES
         BCT   R12,USFRHED             BACK UP 1 AND LOOP
USFMADD  LA    R12,1(R12)              TO NEXT BYTE
USFMCMA  MVC   0(2,R12),=C',R'         DELIMITERS
         SR    R11,R11                 CLEAR WORK
         IC    R11,USREG               GET REGISTER NBR
         CVD   R11,DBLWD               CONVERT TO PACKED
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK REG NBR
         OI    DBLWD+1,C'0'            CLEAR SIGN
         CH    R11,H10                 REG < 10
         BL    USFMR1                  YES
         MVC   2(2,R12),DBLWD          MOVE 2-DIGIT REG NBR
         B     USINGOUT                GO WRITE USING
USFMR1   MVC   2(1,R12),DBLWD+1        MOVE 1-DIGIT REG NBR
USINGOUT BAL   R9,WRTOUT               WRITE USING STMT
         BAL   R9,PRINT                PRINT USING STMT
         B     ECSTEP                  CONTINUE
CKUTPS   CLC   USVALU,TXTOFSET         USING AT CURR LOC
         BNE   USFMLBL                 NO
         MVI   OPNDS,C'*'              SET CURRENT LOC SYMBOL IN OPERAN
         LA    R12,OPNDS+1             GET NEXT POS ADDR
         B     USFMCMA                 GO FORMAT REG
USFMLBL  MVI   OPNDS,C'A'              SET 1ST CHAR OF LABEL NAME
         LA    R12,USVALU              GET OFFSET
         BAL   R9,HEXPRT3              CONVERT TO PRINTABLE
         MVC   OPNDS+1(6),PRTABL       PRINTABLE HEX TO LABEL
         LA    R12,OPNDS+7             TO NEXT LOC
         B     USFMCMA                 FORMAT REG
ECSTEP   LA    R2,L'USING(R2)          TO NEXT USING ENTRY
         B     ENDUS                   CONTINUE SCAN
XITUS    L     R9,USG9                 GET RETURN ADDR
         BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* END OF PHASE 2 - RETURN TO PHASE 0                             *
*                                                                *
******************************************************************
*
EOJ      EQU   *                       END OF JOB
         BAL   R9,FORCONST             YES, FORCE IT OUT
         L     R13,4(R13)              GET POINTER TO CALLER'S SAVE ARE
         LM    R14,R12,12(R13)         RESTORE CALLER'S REGS
         SR    R15,R15                 CLEAR RETURN CODE
         BR    R14                     RETURN TO CALLER
*
*
*                 *** DATA AND WORK AREAS ***
*
*
DCINST   DC    C' '               = D IF PREV INST WAS A DC         RH
SVCTBLAD DC    A(SVCOP)                @ SVC TABLE
DBLOPAD  DC    A(DBLOP)                @ TWO-BYTE OP-CODE TBL
OWSTRT   DC    A(OPNDWK)               @ OPERAND WORK AREA
OPND9    DC    A(OPNDRTN)              RETURN ADDR FOR OPERAND ROUTINES
USG12    DS    2F                      REG SAVE AREA
USG9     DS    F                       RETURN SAVE
EQU9     DS    F                       RETURN ADDR FOR EQUSTMT
FC6      DS    F                       SAVE AREA FOR R6
FC9      DS    F                       FORCONST RETURN ADDR
TX9      DS    F                       RETURN ADDR FOR TXTFMT
BD9      DS    F                       RETURN FOR BDADR
BDX9     DS    F                       RETURN FOR BDXADR
BDL9     DS    F                       RETURN FOR BDLADR
SLSAV    DS    4F                      SAVE FOR SCHLBL
SGOPLEN DC AL2(L'SGLOP) SINGLE BYTE OP COD TBL LEN                   */
ILENG    DC    H'0'                    INSTRUCTION LENGTH  FIX***
CONPROG  DC    X'00'                   CONSTANT IN PROGRESS INDIC
CONPSLBL DS    0CL13                   PSEUDO LABEL ENTRY FOR CONSTANTS
         DS    XL4
CONNAME  DS    CL8                     CONSTANT NAME
CONLLEN  DS    XL1                     LABEL LENGTH
CONTYPE  DS    CL1                     TYPE
         DS    0H
CONDATA  DS    XL50                    CONSTANT DATA                RH
*ONDATA  DS    XL8                     CONSTANT DATA
CONSYM   DS    CL8                     CONSTANT SYMBOL
CONLEN   DS    H                       CONSTANT LENGTH
CONDUP   DS    H                  DUPLICATION COUNTER               RH
CONOFST  DS    F                       RELATIVE OFFSET TO CONSTANT
CONLOC   DS    F                       @ CURRENT BYTE IN CONSTANT
CCTYPE   DC    X'00'                   CC SET TYPE OF INSTR SETTING
TXTOFST  DS    0F
         DS    X
TXTOFSET DS    XL3                     OFFSET TO TEXT BYTE
OPNDWK   DS    CL13                    OPERAND BUILD AREA
OFFSET   DS    XL3                     OFFSET FROM PGM START
INSTYP   DS    CL1                     INSTRUCTION TYPE
TYPE     DS    XL1                     TYPE CODE
*                                       0=CSECT, 1=ADCON, 2=CONST
*                                       E=USING, D=INSTRUCTION
*                                       C=COMMENT, 9=ENTRY
*                                       A=EQU
LEN      DS    XL1                     TEXT LENGTH
TEXT     DS    XL50                    TEXT                         RH
*EXT     DS    XL8                     TEXT
LBLOFSET DC    X'00'              EQU+1 LABEL NEEDED IF X'FF'       RH
H1       DC    H'1'                    CONSTANT 1
H2       DC    H'2'                    CONSTANT 2
H4       DC    H'4'                    CONSTANT 4
H7       DC    H'7'                    CONSTANT 7
H8       DC    H'8'                    CONSTANT 8
H10      DC    H'10'                   CONSTANT 10
H11      DC    H'11'                   CONSTANT 11
H13      DC    H'13'                   CONSTANT 13
H14      DC    H'14'                   CONSTANT 14
H16      DC    H'16'                   CONSTANT 16
H76      DC    H'76'                   CONSTANT 76
H100     DC    H'100'                  CONSTANT 100
H1000    DC    H'1000'                 CONSTANT 1000
P0       DC    P'0'                    CONSTANT 0
P1       DC    P'1'                    CONSTANT 1
P58      DC    P'58'                   CONSTANT 58
MAXCON   DC    H'50'                   MAX CONSTANT LTH             RH
BLANX    DC    CL133' '                CONSTANT BLANKS              RH
*LANX    DC    CL121' '                CONSTANT BLANKS
XZROS    DC    16X'00'                 CONSTANT ZEROS
HIVAL    DC    4X'FF'                  CONSTANT X F'S
NEXCHG   DC    XL3'00'                 OFFSET TO NEXT BASE REG CHG
         DS    0H                 ALIGN ON HALFWORD BOUNDARY        RH
USGLEN   DC    AL2(L'USING)       LENGTH OF USING TBL ENTRIES
MORUSG   DC    X'00'                   0=NO MORE BASES, 80=MORE BASES A
TRTBL    DC    C'0123456789ABCDEF'     TRANSLATE TBL
PRTABL   DS    CL9                     PRINTABLE HEX WORK
BASES    DC    XL256'00'               BASE REG TABLE
*        TRT TABLE FOR CHAR/HEX DETERMINATION
*        00 FOR VALID CHARACTERS, FF FOR HEX VALUES
*
*                 0 1 2 3 4 5 6 7 8 9 A B C D E F
CHARTRAN DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' 0
         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' 1
         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' 2
         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' 3
         DC    X'00FFFFFFFFFFFFFFFFFFFF00FFFFFFFF' 4   BLANK AND DOT
         DC    X'FFFFFFFFFFFFFFFFFFFFFF00FFFFFFFF' 5   $
         DC    X'0000FFFFFFFFFFFFFFFFFFFFFF00FFFF' 6   /, -, AND _
         DC    X'FFFFFFFFFFFFFFFFFFFFFF0000FFFFFF' 7   # AND @
         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' 8
         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' 9
         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' A
         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' B
         DC    X'FF000000000000000000FFFFFFFFFFFF' C   A-I
         DC    X'FF000000000000000000FFFFFFFFFFFF' D   J-R
         DC    X'FFFF0000000000000000FFFFFFFFFFFF' E   S-Z
         DC    X'00000000000000000000FFFFFFFFFFFF' F   0-9
*                 0 1 2 3 4 5 6 7 8 9 A B C D E F
         ORG   CHARTRAN+C' '                                        RH
         DC    X'00'                   BLANK IS CHARACTER           RH
         ORG   CHARTRAN+C'A'                                        RH
         DC    9X'00'                  A-I ARE CHARACTERS           RH
         ORG   CHARTRAN+C'J'                                        RH
         DC    9X'00'                  J-R ARE CHARACTERS           RH
         ORG   CHARTRAN+C'S'                                        RH
         DC    8X'00'                  S-Z ARE CHARACTERS           RH
         ORG   CHARTRAN+C'0'                                        RH
         DC    10X'00'                 0-9 ARE CHARACTERS           RH
         ORG   ,                                                    RH
*                                                                   RH
HEXTRAN  DC    256X'FF'        TRT TABLE FOR CHAR/HEX DETERMINATION RH
         ORG   HEXTRAN+C' '                                         RH
         DC    X'00'                   BLANK IS CHARACTER           RH
         ORG   HEXTRAN+74                                           RH
         DC    7X'00'             .<(+|&                           RH
         ORG   HEXTRAN+90                                           RH
         DC    8X'00'             !$*);-/                          RH
         ORG   HEXTRAN+106                                          RH
         DC    6X'00'             |,%_>?                            RH
         ORG   HEXTRAN+121                                          RH
         DC    7X'00'             ':#@'="                           RH
         ORG   HEXTRAN+C'A'                                         RH
         DC    9X'00'                  A-I ARE CHARACTERS           RH
         ORG   HEXTRAN+C'J'                                         RH
         DC    9X'00'                  J-R ARE CHARACTERS           RH
         ORG   HEXTRAN+C'S'                                         RH
         DC    8X'00'                  S-Z ARE CHARACTERS           RH
         ORG   HEXTRAN+C'0'                                         RH
         DC    10X'00'                 0-9 ARE CHARACTERS           RH
         ORG   ,                                                    RH
HEAD1    DS    0CL132                                               RH
         DC    C'   LOC  OBJECT CODE    ADDR1 ADDR2  STMT'          RH
         DC    C'    SOURCE STATEMENT'                              RH
         DC    CL17' '                                              RH
         DC    C'CHARACTER REP'                                     RH
         DC    CL20' '                                              RH
         DC    C'PAGE'                                              RH
PAGENO   DS    CL4                                                  RH
         DC    CL14' '                                              RH
         LTORG                                                      RH
*                                                                   RH
*                                                                   RH
*                                                                   RH
         COPY  DISASM3A                COPY INSTRUCTION TABLES
         COPY  DISASM3B                COPY SVC TABLE
*                                                                   RH
*                                                                   RH
*                                                                   RH
*                                                                   RH
         PRINT GEN                                                  RH
         DISASPRM DSECT=YES            COMMON AREAS                 RH
         END
/*
//
//*            END IF JUST WANT OBJECT MODULE
//*
//LKED.SYSLMOD  DD DISP=SHR,DSN=HALL.LOAD
//LKED.SYSIN DD *
     SETCODE AC(0)
     NAME DISASM2(R)
//
//
