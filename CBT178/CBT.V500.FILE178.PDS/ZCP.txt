./       ADD   $README$
********************************************************************************
**                                                                            **
**                            D I S C L A I M E R                             **
**                                                                            **
**           THE MATERIAL  AND PROGRAMS  ENCLOSED IN THIS PACKAGE  HAVE BEEN  **
**  DEVELOPED BY  CONSUMERS POWER COMPANY  FOR ITS  OWN USE,  AND  CONSUMERS  **
**  POWER COMPANY  DOES NOT  WARRANT THAT THE MATERIAL NOR PROGRAMS ENCLOSED  **
**  IN THIS PACKAGE WILL  FUNCTION CORRECTLY.   THE USER OF THE MATERIAL AND  **
**  PROGRAMS ENCLOSED  IN THIS PACKAGE IS RESPONSIBLE FOR MAKING THE EVALUA-  **
**  TION AS TO THE  USEFULNESS OF  THE MATERIAL AND PROGRAMS  FOR THEIR PUR-  **
**  POSES.   CONSUMERS POWER COMPANY WILL NOT BE RESPONSIBLE FOR MAINTAINING  **
**  OR PROVIDING UPDATE  INFORMATION FOR THE  MATERIAL OR PROGRAMS  ENCLOSED  **
**  IN THIS PACKAGE.   THE USE OF THE  MATERIAL AND PROGRAMS  ENCLOSED IS AT  **
**  THE  SOLE  RISK OF  THE  USER AND  CONSUMERS POWER COMPANY  WILL  NOT BE  **
**  RESPONSIBLE  FOR ANY LOSS OR  DAMAGE SUFFERED  BY THE USER OR  ANY THIRD  **
**  PARTIES  RESULTING  FROM ANY  ERRORS,  INACCURACIES,  OR DEFECTS  IN THE  **
**  MATERIAL OR PROGRAMS.  CONSUMERS POWER COMPANY WILL ALSO NOT BE RESPONS-  **
**  IBLE FOR ANY LOSS OR EXPENSE  INCURRED AS THE RESULT  THAT THE MATERIALS  **
**  OR PROGRAMS CONSTITUTES AN INFRINGEMENT OF ANY COPYRIGHT.                 **
**                                                                            **
**          THE USE  OF ANY OF  THE MATERIAL  OR PROGRAMS  ENCLOSED  IN THIS  **
**  PACKAGE SHALL CONSTITUTE ACCEPTANCE OF THE ABOVE TERMS.                   **
********************************************************************************
THIS FILE CONTAINS THE IPCS CLISTS THAT HAVE BEEN CREATED AT CONSUMERS POWER
COMPANY TO ASSIST IN READING IDMS CV DUMPS.  THIS FILE CONTAINS MULTIPLE
MEMBERS.  EACH MEMBER STARTS WITH A LINE CONTAINING "./  ADD  MBRNAME" AND ENDS
WITH A LINE CONTAINING ALL HYPHENS.  TO BE OF ANY USE, THIS FILE MUST BE SPLIT
UP AND PLACED IN SEPARATE MEMBERS OF AN MVS PARTITIONED DATASET.  THE MEMBER
NAMES MUST MATCH THE NAME SHOWN AT THE START OF EACH MEMBER.  THIS DATASET CAN
BE PROCESSED DIRECTLY BY IEBCOPY TO ACCOMPLISH THIS.
/*-------------------------------------------------------------------*/
./       ADD   CSA#RCE
/* THIS CLIST WALKS ALL OF THE RCE CHAINS OFF FROM THE CSA.  THE     */
/* "INIT" CLIST MUST BE EXECUTED BEFORE EXECUTING THIS CLIST.  THIS  */
/* CLIST INVOKES THE FOLLOWING CLIST:  RLE.                          */
/*                                                                   */
         PROC 0 PRINT TERMINAL DEBUG
         IF &DEBUG = DEBUG THEN CONTROL LIST
         EVALSYM #CSADS
         IF &LASTCC > 0 THEN +
            DO
               NOTE 'SYMBOL ''#CSADS'' IS NOT DEFINED'
               GOTO GETOUT
            END
         DROPSYM *
         NOTE 'RCE''S WILL BE DISPLAYED FOR #CSADS'
         NOTE '====== SIGNON RLE/RCE CHAIN =========================='
         EQUATE RLESTART #CSADS+2B4 LENGTH(4) POINTER
         EVALSYM RLESTART CLIST(ADDRESS(A) POSITION(P) DECIMAL)
         SET &RLESTART = &A + &P
         RUNCHAIN ADDRESS(RLESTART%) +
            LENGTH(X'C') STRUCTURE(#RLEDS) +
            EXEC((RLE &PRINT &TERMINAL &DEBUG)) +
            NULL(&RLESTART) NAME(#RLEDS) LINK(X'00') +
            CHAIN(100) DROP NOVERIFY
         NOTE '====== SINGLE-THREAD RLE/RCE CHAIN ==================='
         EQUATE RLESTART #CSADS+2C0 LENGTH(4) POINTER
         EVALSYM RLESTART CLIST(ADDRESS(A) POSITION(P) DECIMAL)
         SET &RLESTART = &A + &P
         RUNCHAIN ADDRESS(RLESTART%) +
            LENGTH(X'C') STRUCTURE(#RLEDS) +
            EXEC((RLE &PRINT &TERMINAL &DEBUG)) +
            NULL(&RLESTART) NAME(#RLEDS) LINK(X'00') +
            CHAIN(100) DROP NOVERIFY
         NOTE '====== SYSTEM RLE/RCE CHAIN =========================='
         EQUATE RLESTART #CSADS+2C8 LENGTH(4) POINTER
         EVALSYM RLESTART CLIST(ADDRESS(A) POSITION(P) DECIMAL)
         SET &RLESTART = &A + &P
         RUNCHAIN ADDRESS(RLESTART%) +
            LENGTH(X'C') STRUCTURE(#RLEDS) +
            EXEC((RLE &PRINT &TERMINAL &DEBUG)) +
            NULL(&RLESTART) NAME(#RLEDS) LINK(X'00') +
            CHAIN(100) DROP NOVERIFY
GETOUT:  NOTE ' '
         END
/*-------------------------------------------------------------------*/
./       ADD   CSASTAT
/* THIS CLIST DISPLAYS THE CONTENTS OF VARIOUS FLAGS AND COUNTERS    */
/* FOUND IN THE CSA.  THE "INIT" CLIST MUST BE EXECUTED BEFORE       */
/* EXECUTING THIS CLIST.                                             */
/*                                                                   */
         PROC 0 PRINT TERMINAL DEBUG
         IF &DEBUG = DEBUG THEN CONTROL LIST
/* GET NUMBER OF TASKS WAITING FOR LOADER */
         EQUATE CSATEMP #CSADS+3D0 LENGTH(4) UNSIGNED SCALAR
         EVALUATE CSATEMP CLIST(STORAGE(S))
         NOTE '&S TASKS WERE WAITING FOR LOADER'
/* GET CAPACITY OF LOG AREA IN BYTES */
         EQUATE CSATEMP #CSADS+3D4 LENGTH(4) UNSIGNED SCALAR
         EVALUATE CSATEMP CLIST(STORAGE(S))
         NOTE 'THE CAPACITY OF THE LOG AREA IS &S BYTES'
/* GET FULLNESS OF LOG AREA IN BYTES */
         EQUATE CSATEMP #CSADS+3DC LENGTH(4) UNSIGNED SCALAR
         EVALUATE CSATEMP CLIST(STORAGE(S))
         NOTE 'THERE ARE CURRENTLY &S BYTES USED IN THE LOG AREA'
/* GET NUMBER OF ACTIVE TASKS */
         EQUATE CSATEMP #CSADS+4E8 LENGTH(4) UNSIGNED SCALAR
         EVALUATE CSATEMP CLIST(STORAGE(S))
         NOTE '&S TASKS WERE ACTIVE'
/* CHECK FOR SHORT ON STORAGE */
         EQUATE CSATEMP #CSADS+6C0 LENGTH(1) BIT
         COMPARE ADDRESS(CSATEMP) LENGTH(1) +
            WITH(VALUE(X'80')) LENGTH(1) MASK(X'80')
         IF &LASTCC = 0 THEN +
            NOTE 'SHORT ON STORAGE CONDITION EXISTS'
         ELSE +
            NOTE 'NOT SHORT ON STORAGE'
/* CHECK FOR MAX TASKS CONDITION */
         COMPARE ADDRESS(CSATEMP) LENGTH(1) +
            WITH(VALUE(X'40')) LENGTH(1) MASK(X'40')
         IF &LASTCC = 0 THEN +
            NOTE 'MAX TASKS CONDITION EXISTS'
         ELSE +
            NOTE 'NOT AT MAX TASKS'
/* CHECK FOR SYSTEM BEING SHUTDOWN */
         COMPARE ADDRESS(CSATEMP) LENGTH(1) +
            WITH(VALUE(X'02')) LENGTH(1) MASK(X'02')
         IF &LASTCC = 0 THEN +
            NOTE 'THE SYSTEM IS BEING SHUT DOWN'
         ELSE +
            NOTE 'THE SYSTEM IS NOT BEING SHUT DOWN'
/* CHECK FOR SYSTEM BEING QUIESCED */
         EQUATE CSATEMP #CSADS+6C1 LENGTH(1) BIT
         COMPARE ADDRESS(CSATEMP) LENGTH(1) +
            WITH(VALUE(X'40')) LENGTH(1) MASK(X'40')
         IF &LASTCC = 0 THEN +
            NOTE 'SYSTEM IS BEING QUIESCED'
         ELSE +
            NOTE 'SYSTEM IS NOT BEING QUIESCED'
/* CHECK FOR FACTOTUM TYPE 2 ACTIVE */
         COMPARE ADDRESS(CSATEMP) LENGTH(1) +
            WITH(VALUE(X'08')) LENGTH(1) MASK(X'08')
         IF &LASTCC = 0 THEN +
            NOTE 'FACTOTUM TYPE 2 IS ACTIVE'
         ELSE +
            NOTE 'FACTOTUM TYPE 2 IS NOT ACTIVE'
/* CHECK FOR INIT OF DC DONE */
         COMPARE ADDRESS(CSATEMP) LENGTH(1) +
            WITH(VALUE(X'04')) LENGTH(1) MASK(X'04')
         IF &LASTCC = 0 THEN +
            NOTE 'INITIALIZATION OF IDMS/CV IS COMPLETE'
         ELSE +
            NOTE 'INITIALIZATION OF IDMS/CV IS NOT COMPLETE'
/* CHECK FOR SHORT ON RLES */
         EQUATE CSATEMP #CSADS+6C3 LENGTH(1) BIT
         COMPARE ADDRESS(CSATEMP) LENGTH(1) +
            WITH(VALUE(X'80')) LENGTH(1) MASK(X'80')
         IF &LASTCC = 0 THEN +
            NOTE 'SYSTEM IS SHORT ON RLES'
         ELSE +
            NOTE 'SYSTEM IS NOT SHORT ON RLES'
/* CHECK FOR SHORT ON ILES */
         COMPARE ADDRESS(CSATEMP) LENGTH(1) +
            WITH(VALUE(X'10')) LENGTH(1) MASK(X'10')
         IF &LASTCC = 0 THEN +
            NOTE 'SYSTEM IS SHORT ON ILES'
         ELSE +
            NOTE 'SYSTEM IS NOT SHORT ON ILES'
/* CHECK FOR WAIT ON ERUS QUIESCE */
         COMPARE ADDRESS(CSATEMP) LENGTH(1) +
            WITH(VALUE(X'04')) LENGTH(1) MASK(X'04')
         IF &LASTCC = 0 THEN +
            NOTE 'SYSTEM IS WAITING ON ERUS QUIESCE'
         ELSE +
            NOTE 'SYSTEM IS NOT WAITING ON ERUS QUIESCE'
/* CHECK FOR SHORT ON RCES */
         COMPARE ADDRESS(CSATEMP) LENGTH(1) +
            WITH(VALUE(X'02')) LENGTH(1) MASK(X'02')
         IF &LASTCC = 0 THEN +
            NOTE 'SYSTEM IS SHORT ON RCES'
         ELSE +
            NOTE 'SYSTEM IS NOT SHORT ON RCES'
/* CHECK FOR SHORT ON DPES */
         COMPARE ADDRESS(CSATEMP) LENGTH(1) +
            WITH(VALUE(X'01')) LENGTH(1) MASK(X'01')
         IF &LASTCC = 0 THEN +
            NOTE 'SYSTEM IS SHORT ON DPES'
         ELSE +
            NOTE 'SYSTEM IS NOT SHORT ON DPES'
/* CHECK FOR QUIESCE FOR NUCLEUS LOAD */
         EQUATE CSATEMP #CSADS+6C6 LENGTH(1) BIT
         COMPARE ADDRESS(CSATEMP) LENGTH(1) +
            WITH(VALUE(X'10')) LENGTH(1) MASK(X'10')
         IF &LASTCC = 0 THEN +
            NOTE 'SYSTEM IS BEING QUIESCED FOR NUCLEUS LOAD'
         ELSE +
            NOTE 'SYSTEM IS NOT BEING QUIESCED FOR NUCLEUS LOAD'
/* GET NUMBER OF TOTAL TASKS CURRENTLY ACTIVE */
         EQUATE CSATEMP #CSADS+6D0 LENGTH(2) UNSIGNED SCALAR
         EVALUATE CSATEMP CLIST(STORAGE(S))
         NOTE '&S TOTAL TASKS WERE CURRENTLY ACTIVE'
/* GET NUMBER OF SYSTEM TASKS CURRENTLY ACTIVE */
         EQUATE CSATEMP #CSADS+6D2 LENGTH(2) UNSIGNED SCALAR
         EVALUATE CSATEMP CLIST(STORAGE(S))
         NOTE '&S SYSTEM TASKS WERE CURRENTLY ACTIVE'
/* GET NUMBER OF SCTS CURRENTLY SHORT ON STORAGE */
         EQUATE CSATEMP #CSADS+6D4 LENGTH(2) UNSIGNED SCALAR
         EVALUATE CSATEMP CLIST(STORAGE(S))
         NOTE '&S STORAGE POOLS CURRENTLY SHORT ON STORAGE'
/* GET NUMBER OF ONLINE TASKS CURRENTLY ACTIVE */
         EQUATE CSATEMP #CSADS+6D6 LENGTH(2) UNSIGNED SCALAR
         EVALUATE CSATEMP CLIST(STORAGE(S))
         NOTE '&S ONLINE TASKS WERE CURRENTLY ACTIVE'
/* GET NUMBER OF EXTERNAL TASKS CURRENTLY ACTIVE */
         EQUATE CSATEMP #CSADS+6D8 LENGTH(2) UNSIGNED SCALAR
         EVALUATE CSATEMP CLIST(STORAGE(S))
         NOTE '&S EXTERNAL TASKS WERE CURRENTLY ACTIVE'
         DROPSYM CSATEMP
         END
/*-------------------------------------------------------------------*/
./       ADD   CVSTAT
/* THIS CLIST DISPLAYS THE CONTENTS OF VARIOUS FLAGS AND COUNTERS    */
/* FOUND IN THE DCE, TCE, LTE, AND PTE FOR A GIVEN TASK.  TO USE     */
/* THIS CLIST, YOU MUST SUPPLY THE SUFFIX VALUE FOR THE IPCS SYMBOL  */
/* NAMES.  AN EXAMPLE CALL MIGHT BE "CVSTAT INDEX(12)".  THE "INIT"  */
/* CLIST MUST BE EXECUTED BEFORE EXECUTING THIS CLIST.  THIS CLIST   */
/* INVOKES THE FOLLOWING CLISTS:  DCESTAT, TCESTAT, LTESTAT, AND     */
/* PTESTAT.                                                          */
/*                                                                   */
         PROC 0 PRINT TERMINAL DEBUG INDEX(01)
         IF &DEBUG = DEBUG THEN CONTROL LIST
/* DISPLAY THE STATISTICS FOR THE #DCEDS CONTROL BLOCK */
         DCESTAT &PRINT &TERMINAL &DEBUG INDEX(&INDEX)
/* DISPLAY THE STATISTICS FOR THE #TCEDS CONTROL BLOCK */
         TCESTAT &PRINT &TERMINAL &DEBUG INDEX(&INDEX)
/* DISPLAY THE STATISTICS FOR THE #LTEDS CONTROL BLOCK */
         LTESTAT &PRINT &TERMINAL &DEBUG INDEX(&INDEX)
/* DISPLAY THE STATISTICS FOR THE #PTEDS CONTROL BLOCK */
         PTESTAT &PRINT &TERMINAL &DEBUG INDEX(&INDEX)
         END
/*-------------------------------------------------------------------*/
./       ADD   DCESTAT
/* THIS CLIST DISPLAYS THE CONTENTS OF THE VARIOUS FLAGS IN THE DCE. */
/* TO USE THIS CLIST, YOU MUST SUPPLY THE SUFFIX OF THE IPCS SYMBOL  */
/* NAME OF THE PARTICULAR DCE CONTROL BLOCK THAT YOU ARE INTERESTED  */
/* IN.  A SAMPLE CALL MIGHT BE "DCESTAT INDEX(05)".  THE "INIT"      */
/* CLIST MUST BE EXECUTED BEFORE EXECUTING THIS CLIST.               */
/*                                                                   */
         PROC 0 PRINT TERMINAL DEBUG INDEX() NAME(#DCEDS)
         IF &DEBUG = DEBUG THEN CONTROL LIST
         EVALSYM EQ &NAME&INDEX
         IF &LASTCC = 0 THEN +
            NOTE 'THE FOLLOWING NOTES ARE FOR CONTROL BLOCK &NAME&INDEX'
         ELSE +
            DO
               NOTE 'THE SYMBOL ''&NAME&INDEX'' WAS NOT FOUND'
               GOTO GETOUT
            END
/* GET THE DISPATCHING PRIORITY */
         EVALUATE &NAME&INDEX+24 LENGTH(1) UNSIGNED CLIST(STORAGE(S))
         NOTE 'THE DISPATCHING PRIORITY IS &S'
/* CHECK FOR TASK READY TO RUN */
         EQUATE DCETEMP &NAME&INDEX+25 LENGTH(1) BIT
         COMPARE ADDRESS(DCETEMP) LENGTH(1) +
            WITH(VALUE(X'80')) LENGTH(1) MASK(X'80')
         IF &LASTCC = 0 THEN +
            NOTE 'TASK IS READY TO RUN, NOT YET DISPATCHED'
/* CHECK FOR TASK CURRENTLY EXECUTING */
         COMPARE ADDRESS(DCETEMP) LENGTH(1) +
            WITH(VALUE(X'40')) LENGTH(1) MASK(X'40')
         IF &LASTCC = 0 THEN +
            NOTE 'TASK IS CURRENTLY EXECUTING'
         ELSE +
            NOTE 'TASK IS NOT CURRENTLY EXECUTING'
/* CHECK FOR TASK WAITING */
         COMPARE ADDRESS(DCETEMP) LENGTH(1) +
            WITH(VALUE(X'20')) LENGTH(1) MASK(X'20')
         IF &LASTCC = 0 THEN +
            NOTE 'TASK IS WAITING'
         ELSE +
            NOTE 'TASK IS NOT WAITING'
/* CHECK FOR TASK WAITING ON ECB */
         COMPARE ADDRESS(DCETEMP) LENGTH(1) +
            WITH(VALUE(X'10')) LENGTH(1) MASK(X'10')
         IF &LASTCC = 0 THEN +
            NOTE 'TASK IS WAITING ON AT LEAST ONE ECB'
         ELSE +
            NOTE 'TASK IS NOT WAITING ON ANY ECB''S'
/* CHECK FOR TASK WAITING ON LOCK/MPMODE */
         COMPARE ADDRESS(DCETEMP) LENGTH(1) +
            WITH(VALUE(X'08')) LENGTH(1) MASK(X'08')
         IF &LASTCC = 0 THEN +
            NOTE 'TASK IS WAITING ON A LOCK OR MPMODE'
         ELSE +
            NOTE 'TASK IS NOT WAITING ON ANY LOCK OR MPMODE'
/* CHECK FOR TASK HICCUP WAIT IN PROGRESS */
         COMPARE ADDRESS(DCETEMP) LENGTH(1) +
            WITH(VALUE(X'04')) LENGTH(1) MASK(X'04')
         IF &LASTCC = 0 THEN +
            NOTE 'TASK HICCUP WAIT IN PROGRESS'
         ELSE +
            NOTE 'TASK HICCUP WAIT NOT IN PROGRESS'
/* CHECK FOR NEW TASK */
         COMPARE ADDRESS(DCETEMP) LENGTH(1) +
            WITH(VALUE(X'02')) LENGTH(1) MASK(X'02')
         IF &LASTCC = 0 THEN +
            NOTE 'NEW TASK, NOT YET DISPATCHED'
/* CHECK FOR RUNABLE TASK */
         EQUATE DCETEMP &NAME&INDEX+26 LENGTH(1) BIT
         COMPARE ADDRESS(DCETEMP) LENGTH(1) +
            WITH(VALUE(X'80')) LENGTH(1) MASK(X'80')
         IF &LASTCC = 0 THEN +
            NOTE 'EMBRACE ROUTINE FOUND TASK RUNABLE'
/* CHECK FOR SUBTASK AFFINITY */
         COMPARE ADDRESS(DCETEMP) LENGTH(1) +
            WITH(VALUE(X'40')) LENGTH(1) MASK(X'40')
         IF &LASTCC = 0 THEN +
            NOTE 'TASK REQUIRED SUBTASK AFFINITY'
/* CHECK FOR SET TO REMOVE TASK FROM SYSTEM */
         COMPARE ADDRESS(DCETEMP) LENGTH(1) +
            WITH(VALUE(X'20')) LENGTH(1) MASK(X'20')
         IF &LASTCC = 0 THEN +
            NOTE 'SET TO REMOVE TASK FROM SYSTEM'
/* CHECK FOR DCE CURRENTLY OWNED */
         COMPARE ADDRESS(DCETEMP) LENGTH(1) +
            WITH(VALUE(X'01')) LENGTH(1) MASK(X'01')
         IF &LASTCC = 0 THEN +
            NOTE 'DCE IS CURRENTLY OWNED'
         ELSE +
            NOTE 'DCE IS NOT CURRENTLY OWNED'
GETOUT:  DROPSYM DCETEMP
/*-------------------------------------------------------------------*/
./       ADD   INIT
/* THIS IS THE INITIALIZATION CLIST FOR READING IDMS CV DUMPS.  THIS */
/* MUST BE THE FIRST CLIST EXECUTED BEFORE ANY OTHER IPCS CLIST IS   */
/* EXECUTED.  THIS CLIST INVOKES THE FOLLOWING CLISTS:  TCE AND PTE. */
/*                                                                   */
         PROC 0 PRINT TERMINAL DEBUG
         IF &DEBUG = DEBUG THEN CONTROL LIST
/* DO THE INITIAL HOUSEKEEPING STUFF */
         STATUS NOPRINT NOTERMINAL
         DROPSYM * PURGE
         DROPMAP ASID(X'0001')
/* LIST THE GENERAL PURPOSE REGISTER CONTENTS */
         NOTE 'REGISTER VALUES FOR IDMS ADDRESS SPACE'
         LIST 0R:15R
/* FIND THE STARTUP MODULE */
         FIND = C'RHDCOS00' ADDRESS(0.:00FFFFFF.) NOBREAK FIRST
         EQUATE @RHDCOS00 X MODULE(RHDCOS00) LENGTH(X'88C') +
            REMARK('THE IDMS CV STARTUP MODULE') NODROP
         COMPARE ADDRESS(@RHDCOS00) CHARACTER LENGTH(8) +
            WITH(VALUE(C'RHDCOS00')) LENGTH(8)
         IF &LASTCC = 0 THEN GOTO GOTSTRT
         NOTE 'NO IDMS STARTUP MODULE FOUND'
         GOTO DONE
/* FIND THE #CSADS DSECT */
GOTSTRT: EQUATE #CSADS @RHDCOS00+24% LENGTH(X'4290') +
            STRUCTURE(#CSADS) REMARK('COMMON SYSTEM AREA (CSA)') +
            NODROP
         IF &LASTCC ¬= 0 THEN GOTO DONE
         COMPARE ADDRESS(#CSADS) HEXADECIMAL LENGTH(4) +
            WITH(VALUE(X'47F0F9EE')) LENGTH(4)
         IF &LASTCC = 0 THEN GOTO GOTCSA
         NOTE 'CSA DOES NOT START OUT WITH SYSTEM ENTRY BRANCH' +
            SPACE(1) &TERMINAL
         GOTO DONE
/* RUN THE DCE CHAIN GETTING #DCEDS, #TCEDS, #LTEDS, #PTEDS DSECTS */
GOTCSA:  EQUATE DCESTRT #CSADS+2A0 LENGTH(4) POINTER
         EVALSYM DCESTRT CLIST(ADDRESS(A) POSITION(P) DECIMAL)
         SET &DCESTRT = &A + &P
         RUNCHAIN ADDRESS(DCESTRT%) +
            LENGTH(X'40') STRUCTURE(#DCEDS) +
            REMARK('DISPATCH CONTROL ELEMENT (DCE)') +
            EXEC((TCE &PRINT &TERMINAL &DEBUG)) +
            NULL(&DCESTRT) NAME(#DCEDS) LINK(X'00') +
            CHAIN(50) NODROP
/* GET THE #CCEDS DSECT ADDRESS */
         EQUATE #CCEDS #CSADS+308% LENGTH(464) STRUCTURE(#CCEDS) +
            REMARK('CENTRAL CONTROL ELEMENT (CCE)') NODROP
/* RUN MASTER READY QUEUE FOR LTERMS */
         EQUATE #LTTDS #CSADS+320% LENGTH(56) AREA
         EQUATE LTESTRT #LTTDS+10 LENGTH(4) POINTER
         RUNCHAIN ADDRESS(LTESTRT%) +
            LENGTH(X'100') STRUCTURE(#LTEDS) +
            REMARK('LTE ON MASTER''S READY QUEUE') +
            EXEC((PTE &PRINT &TERMINAL &DEBUG)) +
            NULL(X'00000000') NAME(#MLTEDS) LINK(X'10') +
            CHAIN(75) NODROP
/* DELETE TEMPORARY SYMBOLS */
         DROPSYM * NOPURGE
DONE:    NOTE ' '
         EXIT CODE(&MAXCC)
         END
/*-------------------------------------------------------------------*/
./       ADD   IPCS
/* THIS IS A SAMPLE CLIST FOR BRINGING UP IPCS IN FULL-SCREEN MODE.  */
/* THIS CLIST HAS BEEN MODIFIED TO INCORPORATE THE CHANGES REQUIRED  */
/* TO SUPPORT THE AMDAHL IPCS EXITS.  SOME MODIFICATION MAY BE       */
/* REQUIRED TO GET THIS CLIST TO WORK IN YOUR SHOP.  IT IS ASSUMED   */
/* THAT THE IPCS DUMP AND PROBLEM DIRECTORIES HAVE BEEN PREVIOUSLY   */
/* ALLOCATED AND INITIALIZED (REFER TO THE IPCS MANUALS).            */
/*                                                                   */
PROC 0 PARM(00)
CONTROL NOFLUSH NOMSG
FREE FI(SYSPROC ISPPLIB ISPMLIB ISPSLIB ISPTLIB ISPLLIB)
FREE FI(IPCSDDIR IPCSPDIR IPCSPARM IPCSPRNT IPCSTOC)
FREE FI(MACLIB,SNAP)
FREE FI(SYSUDUMP) DELETE
CONTROL MSG
ALLOC FI(SYSPROC) DA( +
    'SYS1.ISPCLIB', +
    'SYS1.SBLSCLI0', +
    'YOUR.IPCS.CLIST.DATASET' ) SHR REUSE
ALLOC FI(ISPPLIB) DA( +
    'SYS1.ISPPLIB', +
    'SYS1.SBLSPNL0') SHR REUSE
ALLOC FI(ISPMLIB) DA( +
    'SYS1.ISPMLIB', +
    'SYS1.SBLSMSG0') SHR REUSE
ALLOC FI(ISPSLIB) DA( +
    'SYS1.ISPSLIB', +
    'SYS1.SBLSKEL0') SHR REUSE
ALLOC FI(ISPTLIB) DA( +
    'SYS1.ISPTLIB', +
    'SYS1.SBLSTBL0') SHR REUSE
ALLOC FI(MACLIB) DA( +
    'YOUR.IDMS.SRCLIB', +
    'SYS1.MACLIB', +
    'SYS1.AMODGEN') SHR REUSE
ALLOC FI(SNAP) DUMMY
ALLOC FI(IPCSPRNT) SYSOUT(A)
ALLOC FI(IPCSTOC) SYSOUT(A)
ALLOC FI(IPCSDDIR) DSN('YOUR.IPCS.DUMP.DIRECTORY') SHR REUSE
ALLOC FI(IPCSPDIR) DSN('YOUR.IPCS.PROBLEM.DIRECTORY') SHR REUSE
ALLOC FI(IPCSPARM) DSN('YOUR.IPCS.PARMLIB') SHR REUSE
IPCS PARM(&PARM) TASKLIB('YOUR.IPCS.EXIT.LOADLIB')
ISPSTART PGM(BLSG) PARM(PANEL(BLSPPRIM)) NEWAPPL(BLSG)
END
/*-------------------------------------------------------------------*/
./       ADD   LTE#RCE
/* THIS CLIST WALKS ALL OF THE RCE CHAINS OFF FROM A GIVEN LTE.  YOU */
/* MUST SUPPLY THE SUFFIX OF THE IPCS SYMBOL NAME OF THE PARTICULAR  */
/* LTE CONTROL BLOCK THAT YOU ARE INTERESTED IN.  A SAMPLE CALL      */
/* MIGHT BE "LTE#RCE INDEX(21)".  THE "INIT" CLIST MUST BE EXECUTED  */
/* BEFORE EXECUTING THIS CLIST.  THIS CLIST INVOKES THE FOLLOWING    */
/* CLIST:  RCE.                                                      */
/*                                                                   */
         PROC 0 PRINT TERMINAL DEBUG INDEX() NAME(#LTEDS)
         IF &DEBUG = DEBUG THEN CONTROL LIST
         EVALSYM &NAME&INDEX
         IF &LASTCC > 0 THEN +
            DO
               NOTE 'SYMBOL ''&NAME&INDEX'' IS NOT DEFINED'
               GOTO GETOUT
            END
         NOTE 'RCE''S WILL BE DISPLAYED FOR &NAME&INDEX'
         NOTE '====== LTE RLE/RCE CHAIN ============================='
         EQUATE RLESTART &NAME&INDEX+18 LENGTH(4) POINTER
         EVALSYM RLESTART CLIST(ADDRESS(A) POSITION(P) DECIMAL)
         SET &RLESTART = &A + &P
         RUNCHAIN ADDRESS(RLESTART%) +
            LENGTH(X'C') STRUCTURE(#RLEDS) +
            REMARK('RESOURCE LINK ELEMENT (RLE)') +
            EXEC((RLE &PRINT &TERMINAL &DEBUG)) +
            NULL(&RLESTART) NAME(#RLEDS) LINK(X'00') +
            CHAIN(100) DROP
         DROPSYM *
GETOUT:  NOTE ' '
         END
/*-------------------------------------------------------------------*/
./       ADD   LTESTAT
/* THIS CLIST DISPLAYS THE CONTENTS OF THE VARIOUS FLAGS IN THE LTE. */
/* TO USE THIS CLIST, YOU MUST SUPPLY THE SUFFIX OF THE IPCS SYMBOL  */
/* NAME OF THE PARTICULAR LTE CONTROL BLOCK THAT YOU ARE INTERESTED  */
/* IN.  A SAMPLE CALL MIGHT BE "LTESTAT INDEX(07)".  THE "INIT"      */
/* CLIST MUST BE EXECUTED BEFORE EXECUTING THIS CLIST.               */
/*                                                                   */
         PROC 0 PRINT TERMINAL DEBUG INDEX() NAME(#LTEDS)
         IF &DEBUG = DEBUG THEN CONTROL LIST
         EVALSYM EQ &NAME&INDEX
         IF &LASTCC = 0 THEN +
            NOTE 'THE FOLLOWING NOTES ARE FOR CONTROL BLOCK &NAME&INDEX'
         ELSE +
            DO
               NOTE 'THE SYMBOL ''&NAME&INDEX'' WAS NOT FOUND'
               GOTO GETOUT
            END
/* GET THE LTERM NAME */
         EVALUATE &NAME&INDEX+0 LENGTH(8) CHARACTER CLIST(STORAGE(S))
         NOTE 'THE LTERM NAME IS &S'
/* GET THE PTERM NAME */
         EVALUATE &NAME&INDEX+8% LENGTH(8) CHARACTER CLIST(STORAGE(S))
         NOTE 'THE PTERM NAME IS &S'
/* GET THE USER INFORMATION */
         EQUATE SONTEMP &NAME&INDEX+20 LENGTH(4) POINTER
         COMPARE ADDRESS(SONTEMP) LENGTH(4) +
            WITH(VALUE(X'00000000')) LENGTH(4) MASK(X'00FFFFFF')
         IF &LASTCC ¬= 0 THEN +
            DO
               EQUATE LTETEMP &NAME&INDEX+20% LENGTH(4) POINTER
               EQUATE SONTEMP LTETEMP+C% LENGTH(8) CHARACTER SCALAR
               EVALUATE SONTEMP+1 LENGTH(32) +
                  CHARACTER SCALAR CLIST(STORAGE(S))
               NOTE 'THE USER FOR THIS TASK IS &S'
               EVALUATE SONTEMP+21 LENGTH(1) +
                  UNSIGNED SCALAR CLIST(STORAGE(S))
               NOTE 'THE USER PRIORITY IS &S'
            END
/* GET NUMBER OF REPORTS PRINTED */
         EVALUATE &NAME&INDEX+24 LENGTH(2) UNSIGNED CLIST(STORAGE(S))
         NOTE '&S REPORTS HAVE BEEN PRINTED FROM THIS LTERM'
/* GET PRIORITY FOR THE LTERM */
         EVALUATE &NAME&INDEX+28 LENGTH(1) UNSIGNED CLIST(STORAGE(S))
         NOTE 'THE LTERM PRIORITY IS &S'
/* CHECK FOR UPPER CASE TRANSLATE */
         EQUATE LTETEMP &NAME&INDEX+29 LENGTH(1) BIT
         COMPARE ADDRESS(LTETEMP) LENGTH(1) +
            WITH(VALUE(X'01')) LENGTH(1) MASK(X'01')
         IF &LASTCC = 0 THEN +
            NOTE 'LOWERCASE IS TRANSLATED TO UPPERCASE'
         ELSE +
            NOTE 'LOWERCASE IS NOT TRANSLATED TO UPPERCASE'
/* CHECK FOR TERMINAL OWNED BY MASTER */
         COMPARE ADDRESS(LTETEMP) LENGTH(1) +
            WITH(VALUE(X'02')) LENGTH(1) MASK(X'02')
         IF &LASTCC = 0 THEN +
            NOTE 'TERMINAL IS OWNED BY MASTER TASK'
/* CHECK FOR LAST I/O */
         COMPARE ADDRESS(LTETEMP) LENGTH(1) +
            WITH(VALUE(X'04')) LENGTH(1) MASK(X'04')
         IF &LASTCC = 0 THEN +
            NOTE 'LAST I/O WAS A WRITE'
         ELSE +
            NOTE 'LAST I/O WAS A READ'
/* CHECK FOR TERMINAL ON MASTER READY QUEUE */
         COMPARE ADDRESS(LTETEMP) LENGTH(1) +
            WITH(VALUE(X'10')) LENGTH(1) MASK(X'10')
         IF &LASTCC = 0 THEN +
            NOTE 'TERMINAL IS ON MASTER''S READY QUEUE'
/* CHECK FOR INTERNAL TASK */
         COMPARE ADDRESS(LTETEMP) LENGTH(1) +
            WITH(VALUE(X'20')) LENGTH(1) MASK(X'20')
         IF &LASTCC = 0 THEN +
            NOTE 'TASK IS BEING INVOKED INTERNALLY'
         ELSE +
            NOTE 'TASK IS BEING INVOKED EXTERNALLY'
/* CHECK FOR NEW TASK */
         COMPARE ADDRESS(LTETEMP) LENGTH(1) +
            WITH(VALUE(X'40')) LENGTH(1) MASK(X'40')
         IF &LASTCC = 0 THEN +
            NOTE 'A NEW TRANSACTION IS BEING STARTED'
/* CHECK FOR IN/OUT OF SERVICE */
         EQUATE LTETEMP &NAME&INDEX+2A LENGTH(1) BIT
         COMPARE ADDRESS(LTETEMP) LENGTH(1) +
            WITH(VALUE(X'01')) LENGTH(1) MASK(X'01')
         IF &LASTCC = 0 THEN +
            NOTE 'LTERM IS OUT OF SERVICE'
         ELSE +
            NOTE 'LTERM IS IN SERVICE'
/* CHECK FOR PTERM SWAP */
         COMPARE ADDRESS(LTETEMP) LENGTH(1) +
            WITH(VALUE(X'02')) LENGTH(1) MASK(X'02')
         IF &LASTCC = 0 THEN +
            DO
               NOTE 'LTERM IS BEING SWAPPED TO A NEW PTERM'
/* GET THE NEW PTERM NAME */
               EQUATE LTETEMP &NAME&INDEX+50 LENGTH(4) POINTER
               COMPARE ADDRESS(LTETEMP) LENGTH(4) +
                  WITH(VALUE(X'00000000')) LENGTH(4) +
                  MASK(X'00FFFFFF')
               IF &LASTCC ¬= 0 THEN +
                  DO
                     EVALUATE &NAME&INDEX+50% LENGTH(8) CHARACTER +
                        CLIST(STORAGE(S))
                     NOTE 'THE NEW PTERM NAME IS &S'
                  END
            END
/* CHECK FOR PRINTER LTERM */
         SET &PRINTER = N
         COMPARE ADDRESS(LTETEMP) LENGTH(1) +
            WITH(VALUE(X'04')) LENGTH(1) MASK(X'04')
         IF &LASTCC = 0 THEN +
            DO
               NOTE 'THE LTERM IS A PRINTER'
               SET &PRINTER = Y
            END
/* CHECK FOR MESSAGE QUEUED TO LTERM */
         COMPARE ADDRESS(LTETEMP) LENGTH(1) +
            WITH(VALUE(X'08')) LENGTH(1) MASK(X'08')
         IF &LASTCC = 0 THEN +
            NOTE 'THERE IS A MESSAGE QUEUED TO THE LTERM'
/* CHECK FOR MESSAGE QUEUED TO USER */
         COMPARE ADDRESS(LTETEMP) LENGTH(1) +
            WITH(VALUE(X'10')) LENGTH(1) MASK(X'10')
         IF &LASTCC = 0 THEN +
            NOTE 'THERE IS A MESSAGE QUEUED TO THE USER'
/* CHECK ACTION CODE FOR MASTER FACTOTUM TASK */
         EVALUATE &NAME&INDEX+2B LENGTH(1) UNSIGNED CLIST(STORAGE(S))
         SET &T = &S
         IF &S = &STR(4) THEN +
            SET &T = &STR(WRITE ABEND CODE OF PREVIOUS TASK)
         IF &S = &STR(8) THEN +
            SET &T = &STR(WRITE ENTER-NEXT-TASK-CODE MESSAGE)
         IF &S = &STR(12) THEN +
            SET &T = &STR(WRITE UNDEFINED-TASK-CODE MESSAGE)
         IF &S = &STR(16) THEN +
            SET &T = &STR(WRITE TASK-SECURITY-VIOLATION MAP)
         IF &S = &STR(20) THEN +
            SET &T = &STR(WRITE TDE-SPECIFIED MAP)
         IF &S = &STR(24) THEN +
            SET &T = &STR(INTERNAL-TASK-BEING-INVOKED-FROM-TERMINAL)
         IF &S = &STR(28) THEN +
            SET &T = &STR(WRITE SYSTEM-BEING-QUIESCED MESSAGE)
         IF &S = &STR(32) THEN +
            SET &T = &STR(SIGNOFF USER AND/OR TERMINATE SESSION)
         IF &S = &STR(36) THEN +
            SET &T = &STR(PREPARE TERMINAL FOR A #TREQ READ)
         IF &S = &STR(40) THEN +
            SET &T = &STR(WAIT FOR TERMINAL OPERATOR TO FINISH)
         IF &S = &STR(44) THEN +
            SET &T = &STR(WRITE TASK-OUT-OF-SERVICE MESSAGE)
         IF &S = &STR(48) THEN +
            SET &T = &STR(WRITE PROGRAM-OUT-OF-SERVICE MESSAGE)
         IF &S = &STR(52) THEN +
            SET &T = &STR(INVOKE RESOURCE TIMEOUT PROGRAM)
         IF &S = &STR(56) THEN +
            SET &T = &STR(PRINT SCREEN CONTENTS)
         IF &S = &STR(60) THEN +
            SET &T = &STR(WRITE BLAST MESSAGE/REFRESH SCREEN)
         IF &S = &STR(64) THEN +
            SET &T = &STR(GET NEXT COMMAND FROM CLIST)
         IF &S = &STR(68) THEN +
            SET &T = &STR(MAP PAGING SESSION)
         IF &S = &STR(72) THEN +
            SET &T = &STR(MAXIMUM CONCURRENT TASK CONDITION)
         IF &S = &STR(76) THEN +
            SET &T = &STR(MODEENT GROUP REQUIRES INITIALIZATION)
         IF &S = &STR(80) THEN +
            SET &T = &STR(HANDLE LU6.2 FUNCTION MANAGEMENT HEADER)
         NOTE 'FACTOTUM TASK ACTION CODE IS : &T'
/* GET INFO FOR NON-PRINTER LTERMS */
         IF &PRINTER = N THEN +
            DO
            /* GET NEXT TASK CODE FOR LTERM */
               EVALUATE &NAME&INDEX+2D LENGTH(7) CHARACTER +
                  CLIST(STORAGE(S))
               EVALUATE &NAME&INDEX+95 LENGTH(1) CHARACTER +
                  CLIST(STORAGE(T))
               NOTE 'NEXT TASK CODE FOR TERMINAL IS &T&S'
            /* GET AUTO TASK CODE FOR LTERM */
               EVALUATE &NAME&INDEX+34 LENGTH(8) CHARACTER +
                  CLIST(STORAGE(S))
               IF &S ¬= &STR(        ) THEN +
                  NOTE 'AUTO TASK CODE FOR TERMINAL IS &S'
            /* GET ABEND CODE OF LAST TASK */
               EVALUATE &NAME&INDEX+3C LENGTH(4) CHARACTER +
                  CLIST(STORAGE(S))
               NOTE 'ABEND CODE OF LAST TASK FOR LTERM WAS &S'
            /* GET RESOURCE TIMEOUT PROGRAM FOR LTERM */
               EVALUATE &NAME&INDEX+64 LENGTH(8) CHARACTER +
                  CLIST(STORAGE(S))
               NOTE 'RESOURCE TIMEOUT PROGRAM IS &S'
            /* GET DEFAULT VERSION FOR TASKS */
               EVALUATE &NAME&INDEX+72 LENGTH(2) UNSIGNED +
                  CLIST(STORAGE(S))
               NOTE 'DEFAULT VERSION FOR TASKS IS &S'
            /* GET DEFAULT DBNODE */
               EVALUATE &NAME&INDEX+AC LENGTH(8) CHARACTER +
                  CLIST(STORAGE(S))
               NOTE 'DEFAULT DBNODE IS &S'
            /* GET DEFAULT DBNAME */
               EVALUATE &NAME&INDEX+B4 LENGTH(8) CHARACTER +
                  CLIST(STORAGE(S))
               NOTE 'DEFAULT DBNAME IS &S'
            /* GET DEFAULT DICTNODE */
               EVALUATE &NAME&INDEX+C4 LENGTH(8) CHARACTER +
                  CLIST(STORAGE(S))
               NOTE 'DEFAULT DICTNODE IS &S'
            /* GET DEFAULT DICTNAME */
               EVALUATE &NAME&INDEX+CC LENGTH(8) CHARACTER +
                  CLIST(STORAGE(S))
               NOTE 'DEFAULT DICTNAME IS &S'
            /* GET DEFAULT LOADLIB */
               EVALUATE &NAME&INDEX+DC LENGTH(8) CHARACTER +
                  CLIST(STORAGE(S))
               NOTE 'DEFAULT LOADLIB IS &S'
            END
         ELSE +
            DO
            /* GET NAME OF REPORT BEING PRINTED */
               EVALUATE &NAME&INDEX+34 LENGTH(8) CHARACTER +
                  CLIST(STORAGE(S))
               NOTE 'NAME OF REPORT BEING PRINTED IS &S'
            /* CHECK FOR DRAIN PRINTER */
               EQUATE LTETEMP &NAME&INDEX+4C LENGTH(1) BIT
               COMPARE ADDRESS(LTETEMP) LENGTH(1) +
                  WITH(VALUE(X'01')) LENGTH(1) MASK(X'01')
               IF &LASTCC = 0 THEN +
                  NOTE 'PRINTER IS BEING DRAINED'
            /* CHECK FOR CANCEL PRINTER */
               COMPARE ADDRESS(LTETEMP) LENGTH(1) +
                  WITH(VALUE(X'02')) LENGTH(1) MASK(X'02')
               IF &LASTCC = 0 THEN +
                  NOTE 'PRINTER IS BEING CANCELED'
            /* CHECK FOR INTERRUPT PRINTER */
               COMPARE ADDRESS(LTETEMP) LENGTH(1) +
                  WITH(VALUE(X'04')) LENGTH(1) MASK(X'04')
               IF &LASTCC = 0 THEN +
                  NOTE 'PRINTER IS BEING INTERRUPTED'
            /* CHECK FOR READ NEXT QUEUE RECORD */
               COMPARE ADDRESS(LTETEMP) LENGTH(1) +
                  WITH(VALUE(X'08')) LENGTH(1) MASK(X'08')
               IF &LASTCC = 0 THEN +
                  NOTE 'PRINTER IS READING NEXT QUEUE RECORD'
            /* CHECK FOR PRINT TASK */
               COMPARE ADDRESS(LTETEMP) LENGTH(1) +
                  WITH(VALUE(X'10')) LENGTH(1) MASK(X'10')
               IF &LASTCC = 0 THEN +
                  NOTE 'PRINT TASK WANTS TO USE PRINTER'
            /* CHECK FOR FIRST RECORD READ */
               COMPARE ADDRESS(LTETEMP) LENGTH(1) +
                  WITH(VALUE(X'20')) LENGTH(1) MASK(X'20')
               IF &LASTCC = 0 THEN +
                  NOTE 'FIRST REPORT QUEUE RECORD HAS BEEN READ'
            /* CHECK FOR EMPTY REPORT QUEUE */
               COMPARE ADDRESS(LTETEMP) LENGTH(1) +
                  WITH(VALUE(X'40')) LENGTH(1) MASK(X'40')
               IF &LASTCC = 0 THEN +
                  NOTE 'NO MORE RECORDS IN REPORT QUEUE'
               ELSE +
                  NOTE 'THE REPORT QUEUE IS NOT EMPTY'
            /* CHECK FOR BANNER PAGE */
               COMPARE ADDRESS(LTETEMP) LENGTH(1) +
                  WITH(VALUE(X'80')) LENGTH(1) MASK(X'80')
               IF &LASTCC = 0 THEN +
                  NOTE 'BANNER PAGES WILL BE SUPPRESSED'
               ELSE +
                  NOTE 'BANNER PAGES WILL BE PRINTED'
            /* GET CURRENT PRINT CLASS/DESTINATION */
               EQUATE LTETEMP &NAME&INDEX+60 LENGTH(1) BIT
               COMPARE ADDRESS(LTETEMP) LENGTH(1) +
                  WITH(VALUE(X'80')) LENGTH(1) MASK(X'80')
               IF &LASTCC = 0 THEN +
                  DO
                     EVALUATE &NAME&INDEX+60 LENGTH(8) CHARACTER +
                        CLIST(STORAGE(S))
                     NOTE 'CURRENT PRINT DESTINATION IS &S'
                  END
               ELSE +
                  DO
                     EVALUATE &NAME&INDEX+60 LENGTH(2) UNSIGNED +
                        CLIST(STORAGE(S))
                     NOTE 'CURRENT PRINT CLASS IS &S'
                  END
            END
GETOUT:  DROPSYM (LTETEMP SONTEMP)
/*-------------------------------------------------------------------*/
./       ADD   MAP
/* THIS CLIST DISPLAYS A MEMORY MAP OF THE CV ADDRESS SPACE.  THE    */
/* "INIT" CLIST MUST BE EXECUTED BEFORE EXECUTING THIS CLIST.        */
/*                                                                   */
         PROC 0 PRINT TERMINAL DEBUG
         IF &DEBUG = DEBUG THEN CONTROL LIST
         EVALSYM #CSADS
         IF &LASTCC > 0 THEN +
            DO
               NOTE 'SYMBOL ''#CSADS'' IS NOT DEFINED'
               GOTO GETOUT
            END
         NOTE 'IDMS-CV SYSTEM REGION MAP'
         NOTE '========================='
         EQUATE RMAPSTRT #CSADS+34C% LENGTH(4) POINTER
         EVALSYM RMAPSTRT CLIST(ADDRESS(A) POSITION(P) DECIMAL)
         SET &A = &A + &P
LOOP:    COMPARE ADDRESS(RMAPSTRT) LENGTH(1) +
            WITH(VALUE(X'00')) LENGTH(1)
         IF &LASTCC = 0 THEN GOTO DONE
         EVALUATE RMAPSTRT+0 CHARACTER LENGTH(8) +
            CLIST(STORAGE(N1))
         EVALUATE RMAPSTRT+8 HEXADECIMAL LENGTH(4) +
            CLIST(STORAGE(A1))
         EQUATE @&N1 &A1.. NODROP
         SET &A = &A + 12
         INTEGER &A CLIST(STORAGE(AX))
         EQUATE RMAPSTRT &AX.. LENGTH(4) POINTER
         COMPARE ADDRESS(RMAPSTRT) LENGTH(1) +
            WITH(VALUE(X'00')) LENGTH(1)
         IF &LASTCC = 0 THEN +
            DO
               NOTE '&N1 &A1'
               GOTO DONE
            END
         EVALUATE RMAPSTRT+0 CHARACTER LENGTH(8) +
            CLIST(STORAGE(N2))
         EVALUATE RMAPSTRT+8 HEXADECIMAL LENGTH(4) +
            CLIST(STORAGE(A2))
         EQUATE @&N2 &A2.. NODROP
         SET &A = &A + 12
         INTEGER &A CLIST(STORAGE(AX))
         EQUATE RMAPSTRT &AX.. LENGTH(4) POINTER
         COMPARE ADDRESS(RMAPSTRT) LENGTH(1) +
            WITH(VALUE(X'00')) LENGTH(1)
         IF &LASTCC = 0 THEN +
            DO
               NOTE '&N1 &A1         &N2 &A2'
               GOTO DONE
            END
         EVALUATE RMAPSTRT+0 CHARACTER LENGTH(8) +
            CLIST(STORAGE(N3))
         EVALUATE RMAPSTRT+8 HEXADECIMAL LENGTH(4) +
            CLIST(STORAGE(A3))
         EQUATE @&N3 &A3.. NODROP
         SET &A = &A + 12
         INTEGER &A CLIST(STORAGE(AX))
         EQUATE RMAPSTRT &AX.. LENGTH(4) POINTER
         COMPARE ADDRESS(RMAPSTRT) LENGTH(1) +
            WITH(VALUE(X'00')) LENGTH(1)
         IF &LASTCC = 0 THEN +
            DO
               NOTE '&N1 &A1         &N2 &A2         &N3 &A3'
               GOTO DONE
            END
         EVALUATE RMAPSTRT+0 CHARACTER LENGTH(8) +
            CLIST(STORAGE(N4))
         EVALUATE RMAPSTRT+8 HEXADECIMAL LENGTH(4) +
            CLIST(STORAGE(A4))
         EQUATE @&N4 &A4.. NODROP
         SET &A = &A + 12
         INTEGER &A CLIST(STORAGE(AX))
         EQUATE RMAPSTRT &AX.. LENGTH(4) POINTER
         NOTE '&N1 &A1         &N2 &A2         &N3 &A3         &N4 &A4'
         GOTO LOOP
DONE:    DROPSYM *
GETOUT:  NOTE ' '
         END
/*-------------------------------------------------------------------*/
./       ADD   PTE
/* THIS CLIST CREATES A LIST OF PTERMS ON THE MASTER READY QUEUE.    */
/* THE "INIT" CLIST MUST BE EXECUTED BEFORE EXECUTING THIS CLIST.    */
/*                                                                   */
         PROC 0 PRINT TERMINAL DEBUG
         IF &DEBUG = DEBUG THEN CONTROL LIST
         EQUATE LTEPTR X LENGTH(4) AREA SCALAR
         EVALSYM < @RHDCOS00 CLIST(SYMBOL(S))
         IF &SUBSTR(1:4,&S) ¬= &STR(#MLT) THEN +
            DO WHILE &SUBSTR(1:4,&S) ¬= &STR(#MLT)
               EVALSYM < &S CLIST(SYMBOL(S))
               IF &LASTCC > 0 THEN GOTO GETOUT
            END
         SET &SUFFIX = &SUBSTR(8:9,&S)
         EQUATE #MPTEDS&SUFFIX LTEPTR+8% LENGTH(X'110') +
            STRUCTURE(#PTEDS) NODROP +
            REMARK('PTERM ON MASTER''S READY QUEUE ')
GETOUT:  NOTE ' '
         END
/*-------------------------------------------------------------------*/
./       ADD   PTESTAT
/* THIS CLIST DISPLAYS THE CONTENTS OF THE VARIOUS FLAGS IN THE PTE. */
/* TO USE THIS CLIST, YOU MUST SUPPLY THE SUFFIX OF THE IPCS SYMBOL  */
/* NAME OF THE PARTICULAR PTE CONTROL BLOCK THAT YOU ARE INTERESTED  */
/* IN.  A SAMPLE CALL MIGHT BE "PTESTAT INDEX(07)".  THE "INIT"      */
/* CLIST MUST BE EXECUTED BEFORE EXECUTING THIS CLIST.               */
/*                                                                   */
/* N O T E:  THIS CLIST HAS BEEN GEARED PRETTY MUCH TO WORK FOR UCF  */
/* TERMINALS.  SOME MODIFICATIN MAY BE REQUIRED FOR VTAM OR OTHER    */
/* TYPE OF LINES.                                                    */
/*                                                                   */
         PROC 0 PRINT TERMINAL DEBUG INDEX() NAME(#PTEDS)
         IF &DEBUG = DEBUG THEN CONTROL LIST
         EVALSYM EQ &NAME&INDEX
         IF &LASTCC = 0 THEN +
            NOTE 'THE FOLLOWING NOTES ARE FOR CONTROL BLOCK &NAME&INDEX'
         ELSE +
            DO
               NOTE 'THE SYMBOL ''&NAME&INDEX'' WAS NOT FOUND'
               GOTO GETOUT
            END
/* GET THE PTERM NAME */
         EVALUATE &NAME&INDEX+0 LENGTH(8) CHARACTER CLIST(STORAGE(S))
         NOTE 'THE PTERM NAME IS &S'
/* GET THE LINE INFO */
         EQUATE PTETEMP &NAME&INDEX+8% LENGTH(4) POINTER
         EVALUATE PTETEMP+0 LENGTH(8) CHARACTER CLIST(STORAGE(S))
         NOTE 'THE LINE ID IS &S'
/* GET THE LINE TYPE */
         EVALUATE PTETEMP+40 LENGTH(1) CHARACTER CLIST(STORAGE(R))
         IF &R = &STR(0) THEN SET &T = &STR(SYSINX/SYSOUTX)
         IF &R = &STR(1) THEN SET &T = &STR(LOCAL 3270'S)
         IF &R = &STR(2) THEN SET &T = &STR(REMOTE 3270'S)
         IF &R = &STR(3) THEN SET &T = &STR(SIMULATED 3270'S)
         IF &R = &STR(4) THEN SET &T = &STR(OPERATOR'S CONSOLE)
         IF &R = &STR(5) THEN SET &T = &STR(VTAM OR DCAM INTERFACE)
         IF &R = &STR(6) THEN SET &T = &STR(START/STOP TERMINALS)
         IF &R = &STR(7) THEN SET &T = &STR(SYSOUT ONLY - PRINTERS)
         IF &R = &STR(8) THEN SET &T = &STR(LOCAL 3280 PRINTER)
         IF &R = &STR(9) THEN SET &T = &STR(ONLINE SIMULATED 3270'S)
         IF &R = &STR(A) THEN SET &T = &STR(TCAM DRIVER)
         IF &R = &STR(B) THEN +
            SET &T = &STR(BSC NON-SWITCHED POINT-TO-POINT)
         IF &R = &STR(C) THEN +
            SET &T = &STR(BSC SWITCHED POINT-TO-POINT)
         IF &R = &STR(D) THEN SET &T = &STR(BSC MULTIPOINT)
         IF &R = &STR(E) THEN SET &T = &STR(VTAM/SNA LOGICAL UNITS)
         IF &R = &STR(F) THEN SET &T = &STR(APPC EMULATOR)
         IF &R = &STR(L) THEN SET &T = &STR(SDS NETWORK LINE DRIVER)
         IF &R = &STR(Z) THEN SET &T = &STR(UCF LINE DRIVER)
         NOTE 'THE LINE TYPE IS &T'
/* GET THE TERMINAL DEVICE TYPE */
         EVALUATE &NAME&INDEX+24 LENGTH(1) UNSIGNED CLIST(STORAGE(S))
         IF &S = &STR(0) THEN SET &T = &STR(UCFTERM)
         IF &S = &STR(1) THEN SET &T = &STR(INOUTT)
         IF &S = &STR(2) THEN SET &T = &STR(3275)
         IF &S = &STR(3) THEN SET &T = &STR(S3277)
         IF &S = &STR(4) THEN SET &T = &STR(L3277, V3277, OR D3277)
         IF &S = &STR(5) THEN SET &T = &STR(R3277)
         IF &S = &STR(6) THEN SET &T = &STR(S3278)
         IF &S = &STR(7) THEN SET &T = &STR(R3278, V3278, OR D3278)
         IF &S = &STR(8) THEN SET &T = &STR(L3278)
         IF &S = &STR(9) THEN SET &T = &STR(R3284)
         IF &S = &STR(10) THEN SET &T = &STR(L3284, V3284, OR D3284)
         IF &S = &STR(11) THEN SET &T = &STR(R3286)
         IF &S = &STR(12) THEN SET &T = &STR(L3286, V3286, OR D3286)
         IF &S = &STR(13) THEN SET &T = &STR(R3287)
         IF &S = &STR(14) THEN SET &T = &STR(L3287, V3287, OR D3287)
         IF &S = &STR(15) THEN SET &T = &STR(R3288)
         IF &S = &STR(16) THEN SET &T = &STR(L3288, V3288, OR D3288)
         IF &S = &STR(17) THEN SET &T = &STR(R3289 OR V3289)
         IF &S = &STR(18) THEN SET &T = &STR(L3289)
         IF &S = &STR(19) THEN SET &T = &STR(ASR33)
         IF &S = &STR(20) THEN SET &T = &STR(CRT)
         IF &S = &STR(21) THEN SET &T = &STR(RO33)
         IF &S = &STR(22) THEN SET &T = &STR(2741)
         IF &S = &STR(23) THEN SET &T = &STR(OPERATOR)
         IF &S = &STR(24) THEN SET &T = &STR(SYSOUTT)
         IF &S = &STR(25) THEN SET &T = &STR(VTAM LU)
         IF &S = &STR(32) THEN +
            SET &T = &STR(L3279, R3279, S3279, OR V3279)
         IF &S = &STR(33) THEN SET &T = &STR(3741)
         IF &S = &STR(34) THEN SET &T = &STR(3780)
         IF &S = &STR(35) THEN SET &T = &STR(3741)
         IF &S = &STR(36) THEN SET &T = &STR(3275)
         IF &S = &STR(37) THEN SET &T = &STR(3780)
         IF &S = &STR(48) THEN SET &T = &STR(SVC - SDS LINE)
         IF &S = &STR(49) THEN SET &T = &STR(CTC - SDS LINE)
         IF &S = &STR(50) THEN SET &T = &STR(BSC - SDS LINE)
         IF &S = &STR(51) THEN SET &T = &STR(VTAM - SDS LINE)
         IF &S = &STR(52) THEN SET &T = &STR(SNA LU - GENERAL CATEGORY)
         IF &S = &STR(53) THEN SET &T = &STR(3600 FULL-FUNCTION LU)
         IF &S = &STR(54) THEN SET &T = &STR(3600 PIPELINE)
         IF &S = &STR(55) THEN SET &T = &STR(3614)
         IF &S = &STR(56) THEN SET &T = &STR(SNA LU 6.2 SESSION)
         IF &S = &STR(65) THEN SET &T = &STR(DVTSU)
         IF &S = &STR(66) THEN SET &T = &STR(D8160)
         IF &S = &STR(67) THEN SET &T = &STR(GENERIC SIEMENS TERMINAL)
         IF &S = &STR(68) THEN SET &T = &STR(D9750)
         IF &S = &STR(69) THEN SET &T = &STR(GENERIC SIEMENS PRINTER)
         IF &S = &STR(70) THEN SET &T = &STR(D8121)
         IF &S = &STR(71) THEN SET &T = &STR(D8122)
         IF &S = &STR(72) THEN SET &T = &STR(D9003)
         IF &S = &STR(73) THEN SET &T = &STR(APPC EMULATOR)
         IF &S = &STR(74) THEN SET &T = &STR(VIDEOTEX)
         IF &S = &STR(75) THEN SET &T = &STR(DCAM - SDS LINE)
         NOTE 'THE TERMINAL DEVICE TYPE IS &T'
/* GET THE TERMINAL DEVICE MODEL */
         EVALUATE &NAME&INDEX+25 LENGTH(1) CHARACTER CLIST(STORAGE(S))
         NOTE 'THE TERMINAL DEVICE MODEL IS &S'
/* CHECK FOR TERMINAL CLOSED */
         EQUATE PTETEMP &NAME&INDEX+26 LENGTH(1) BIT
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'01')) LENGTH(1) MASK(X'01')
         IF &LASTCC = 0 THEN +
            NOTE 'TERMINAL IS CLOSED (NEVER OPENED)'
/* CHECK FOR TERMINAL OUT OF SERVICE */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'02')) LENGTH(1) MASK(X'02')
         IF &LASTCC = 0 THEN +
            NOTE 'TERMINAL IS OUT OF SERVICE'
/* CHECK FOR TERMINAL DISCONNECTED */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'04')) LENGTH(1) MASK(X'04')
         IF &LASTCC = 0 THEN +
            NOTE 'TERMINAL IS DISCONNECTED, OR INTERVENTION REQUIRED'
/* CHECK FOR 3270 TERMINAL */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'08')) LENGTH(1) MASK(X'08')
         IF &LASTCC = 0 THEN +
            NOTE 'TERMINAL LOOKS LIKE A 3270 DISPLAY'
/* CHECK FOR QUEUED INPUT */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'10')) LENGTH(1) MASK(X'10')
         IF &LASTCC = 0 THEN +
            NOTE 'INPUT IS QUEUED TO THE TERMINAL'
/* CHECK FOR VARY FLAG */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'20')) LENGTH(1) MASK(X'20')
         IF &LASTCC = 0 THEN +
            NOTE 'THE DON''T-VARY-OUT-OT-SERVICE FLAG IS ON'
/* CHECK FOR VARY OUT-OF-SERVICE */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'40')) LENGTH(1) MASK(X'40')
         IF &LASTCC = 0 THEN +
            NOTE 'LINE DRIVER SHOULD VARY THE PTERM OUT-OF-SERVICE'
/* CHECK FOR VARY IN-SERVICE */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'80')) LENGTH(1) MASK(X'80')
         IF &LASTCC = 0 THEN +
            NOTE 'LINE DRIVER SHOULD VARY THE PTERM IN-SERVICE'
/* CHECK FOR REQUEST IN PROGRESS */
         EQUATE PTETEMP &NAME&INDEX+27 LENGTH(1) BIT
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'01')) LENGTH(1) MASK(X'01')
         IF &LASTCC = 0 THEN +
            NOTE 'THERE IS A TERMINAL REQUEST IN PROGRESS'
/* CHECK FOR HALT REQUEST */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'02')) LENGTH(1) MASK(X'02')
         IF &LASTCC = 0 THEN +
            NOTE 'THERE HAS BEEN A HALT REQUEST'
/* CHECK FOR WAITING FOR SERVICE */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'04')) LENGTH(1) MASK(X'04')
         IF &LASTCC = 0 THEN +
            NOTE 'TERMINAL IS WAITING FOR SERVICE'
/* GET MAX # OF CONSECUTIVE PERM ERRORS */
         EVALUATE &NAME&INDEX+4C LENGTH(1) UNSIGNED CLIST(STORAGE(S))
         NOTE 'MAX # OF CONSECTIVE PERM ERRORS IS &S'
/* GET # OF CONSECUTIVE PERM ERRORS */
         EVALUATE &NAME&INDEX+4D LENGTH(1) UNSIGNED CLIST(STORAGE(S))
         NOTE '# OF CONSECTIVE PERM ERRORS IS &S'
/* GET LINE LENGTH */
         EVALUATE &NAME&INDEX+50 LENGTH(2) UNSIGNED CLIST(STORAGE(S))
         NOTE 'TERMINAL LINE LENGTH IS &S CHARACTERS'
/* GET PAGE LENGTH */
         EVALUATE &NAME&INDEX+52 LENGTH(2) UNSIGNED CLIST(STORAGE(S))
         NOTE 'TERMINAL PAGE LENGTH IS &S LINES'
/* CHECK FOR ASCII/EBCDIC */
         EQUATE PTETEMP &NAME&INDEX+57 LENGTH(1) BIT
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'01')) LENGTH(1) MASK(X'01')
         IF &LASTCC = 0 THEN +
            NOTE 'TERMINAL IS ASCII'
         ELSE +
            NOTE 'TERMINAL IS EBCDIC'
/* CHECK FOR 328X FORM FEED SUPPORT */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'02')) LENGTH(1) MASK(X'02')
         IF &LASTCC = 0 THEN +
            NOTE 'TERMINAL SUPPORTS 328X FORM FEED'
/* CHECK FOR 328X PRINTER */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'04')) LENGTH(1) MASK(X'04')
         IF &LASTCC = 0 THEN +
            NOTE 'TERMINAL LOOKS LIKE A 328X PRINTER'
/* CHECK FOR ASA CONTROL CHARACTER */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'08')) LENGTH(1) MASK(X'08')
         IF &LASTCC = 0 THEN +
            NOTE 'TERMINAL REQUIRES ASA CONTROL CHARACTER'
/* CHECK FOR TERMINAL STATS COLLECTION */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'10')) LENGTH(1) MASK(X'10')
         IF &LASTCC = 0 THEN +
            NOTE 'TERMINAL STATISTICS ARE BEING COLLECTED'
         ELSE +
            NOTE 'TERMINAL STATISTICS ARE NOT BEING COLLECTED'
/* CHECK FOR ERASE/WRITE ALTERNATE */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'20')) LENGTH(1) MASK(X'20')
         IF &LASTCC = 0 THEN +
            NOTE 'TERMINAL USES ERASE/WRITE ALTERNATE COMMAND'
/* CHECK FOR READ BUFFER SUPPORT */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'40')) LENGTH(1) MASK(X'40')
         IF &LASTCC = 0 THEN +
            NOTE 'TERMINAL READ BUFFER IS NOT SUPPORTED'
         ELSE +
            NOTE 'TERMINAL READ BUFFER IS SUPPORTED'
/* CHECK FOR SNA CHARACTER STRING DEVICE */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'80')) LENGTH(1) MASK(X'80')
         IF &LASTCC = 0 THEN +
            NOTE 'TERMINAL IS AN SNA CHARACTER STRING DEVICE'
/* GET RELATIVE TERMINAL NUMBER */
         EVALUATE &NAME&INDEX+58 LENGTH(2) UNSIGNED CLIST(STORAGE(S))
         NOTE 'RELATIVE TERMINAL NUMBER IS &S'
/* GET REQUEST COMPLETION CODE */
         EVALUATE &NAME&INDEX+5C LENGTH(1) UNSIGNED CLIST(STORAGE(S))
         SET &T = &S
         IF &S = &STR(0) THEN +
            SET &T = &STR(GOOD COMPLETION - I/O SUCCESSFUL)
         IF &S = &STR(4) THEN +
            SET &T = &STR(INPUT TRUNCATED, INPUT AREA TOO SMALL)
         IF &S = &STR(8) THEN +
            SET &T = &STR(TERMINAL OPERATOR HIT ATTN OR BREAK)
         IF &S = &STR(12) THEN +
            SET &T = &STR(LOGICAL ERRORS IN DATA STREAM)
         IF &S = &STR(16) THEN +
            SET &T = &STR(PERMANENT I/O ERROR)
         IF &S = &STR(20) THEN +
            SET &T = &STR(LINE DISCONNECTED OR INTERVENTION REQUIRED)
         IF &S = &STR(24) THEN +
            SET &T = &STR(TERMINAL IS OUT-OF-SERVICE)
         IF &S = &STR(28) THEN +
            SET &T = &STR(TERMINAL IS CLOSED - OPEN DIDN'T WORK)
         IF &S = &STR(32) THEN +
            SET &T = &STR(INVALID TRB PARAMETER LIST)
         IF &S = &STR(36) THEN +
            SET &T = &STR(INVALID 'BLAST' DESTINATION)
         NOTE 'REQUEST COMPLETION CODE : &T'
/* GET I/O EVENT COMPLETION CODE */
         EVALUATE &NAME&INDEX+5D LENGTH(1) UNSIGNED CLIST(STORAGE(S))
         SET &T = &S
         IF &S = &STR(0) THEN +
            SET &T = &STR(GOOD COMPLETION - I/O SUCCESSFUL)
         IF &S = &STR(4) THEN +
            SET &T = &STR(INPUT TRUNCATED, INPUT AREA TOO SMALL)
         IF &S = &STR(8) THEN +
            SET &T = &STR(TERMINAL OPERATOR HIT ATTN OR BREAK)
         IF &S = &STR(12) THEN +
            SET &T = &STR(LOGICAL ERRORS IN DATA STREAM)
         IF &S = &STR(16) THEN +
            SET &T = &STR(PERMANENT I/O ERROR)
         IF &S = &STR(20) THEN +
            SET &T = &STR(LINE DISCONNECTED OR INTERVENTION REQUIRED)
         IF &S = &STR(24) THEN +
            SET &T = &STR(TERMINAL IS OUT-OF-SERVICE)
         IF &S = &STR(28) THEN +
            SET &T = &STR(TERMINAL IS CLOSED - OPEN DIDN'T WORK)
         IF &S = &STR(32) THEN +
            SET &T = &STR(INVALID TRB PARAMETER LIST)
         IF &S = &STR(36) THEN +
            SET &T = &STR(INVALID 'BLAST' DESTINATION)
         NOTE 'I/O EVENT COMPLETION CODE : &T'
/* CHECK FOR ENTER-NEXT-TASK-CODE PROMPT */
         EQUATE PTETEMP &NAME&INDEX+5E LENGTH(1) BIT
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'01')) LENGTH(1) MASK(X'01')
         IF &LASTCC = 0 THEN +
            NOTE 'NO ENTER-NEXT-TASK-CODE PROMPT'
/* CHECK FOR SUSPEND AT NEXT TASK CODE */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'02')) LENGTH(1) MASK(X'02')
         IF &LASTCC = 0 THEN +
            NOTE 'SUSPEND AT NEXT TASK CODE'
/* CHECK FOR SUSPEND TERMINAL */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'04')) LENGTH(1) MASK(X'04')
         IF &LASTCC = 0 THEN +
            NOTE 'SUSPEND TERMINAL'
/* CHECK FOR APPC SUPPORT */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'08')) LENGTH(1) MASK(X'08')
         IF &LASTCC = 0 THEN +
            NOTE 'APPC IS SUPPORTED'
/* CHECK FOR WRITE REQUEST */
         EQUATE PTETEMP &NAME&INDEX+60 LENGTH(1) BIT
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'01')) LENGTH(1) MASK(X'01')
         IF &LASTCC = 0 THEN +
            DO
               EVALUATE &NAME&INDEX+68 LENGTH(2) UNSIGNED +
                  CLIST(STORAGE(S))
               EVALUATE &NAME&INDEX+64% LENGTH(&S) CHARACTER +
                  CLIST(STORAGE(T))
               NOTE 'DATA TO BE WRITTEN : &T'
               NOTE 'TRB PARM - WRITE REQUEST'
            END
/* CHECK FOR READ REQUEST */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'02')) LENGTH(1) MASK(X'02')
         IF &LASTCC = 0 THEN +
            NOTE 'TRB PARM - READ REQUEST'
/* CHECK FOR CHECK */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'04')) LENGTH(1) MASK(X'04')
         IF &LASTCC = 0 THEN +
            NOTE 'TRB PARM - CHECK'
/* CHECK FOR CONNECT */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'10')) LENGTH(1) MASK(X'10')
         IF &LASTCC = 0 THEN +
            NOTE 'TRB PARM - CONNECT'
/* CHECK FOR DISCONNECT */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'20')) LENGTH(1) MASK(X'20')
         IF &LASTCC = 0 THEN +
            NOTE 'TRB PARM - DISCONNECT'
/* CHECK FOR MAPPING */
         EQUATE PTETEMP &NAME&INDEX+61 LENGTH(1) BIT
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'01')) LENGTH(1) MASK(X'01')
         IF &LASTCC = 0 THEN +
            NOTE 'TRB PARM - REQUEST INVOLVES MAPPING'
/* CHECK FOR LOCATE MODE TYPE READ */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'02')) LENGTH(1) MASK(X'02')
         IF &LASTCC = 0 THEN +
            NOTE 'TRB PARM - LOCATE MODE TYPE READ'
/* CHECK FOR FREE CALLER'S WRITE BUFFER */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'04')) LENGTH(1) MASK(X'04')
         IF &LASTCC = 0 THEN +
            NOTE 'TRB PARM - #FREESTG CALLER''S WRITE BUFFER'
/* CHECK FOR JOURNAL I/O */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'08')) LENGTH(1) MASK(X'08')
         IF &LASTCC = 0 THEN +
            NOTE 'TRB PARM - DO NOT JOURNAL THIS I/O'
/* CHECK FOR SAVE WRITE IF BLASTED */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'10')) LENGTH(1) MASK(X'10')
         IF &LASTCC = 0 THEN +
            NOTE 'TRB PARM - SAVE THIS WRITE IF BLASTED'
/* CHECK FOR LTEADDR/TCELTEA */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'40')) LENGTH(1) MASK(X'40')
         IF &LASTCC = 0 THEN +
            NOTE 'TRB PARM - USE R0 LTEADDR, NOT TCELTEA'
/* CHECK FOR BLAST WRITE REQUEST */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'80')) LENGTH(1) MASK(X'80')
         IF &LASTCC = 0 THEN +
            NOTE 'TRB PARM - BLAST WRITE REQUEST'
/* CHECK FOR NEW-PAGE */
         EQUATE PTETEMP &NAME&INDEX+62 LENGTH(1) BIT
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'01')) LENGTH(1) MASK(X'01')
         IF &LASTCC = 0 THEN +
            NOTE 'TRB PARM - NEW-PAGE, EJECT, OR ERASE/WRITE'
/* CHECK FOR ATTENTION WAIT */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'02')) LENGTH(1) MASK(X'02')
         IF &LASTCC = 0 THEN +
            NOTE 'TRB PARM - DON''T WAIT FOR ATTENTION'
/* CHECK FOR READ FROM SCREEN POSITION */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'10')) LENGTH(1) MASK(X'10')
         IF &LASTCC = 0 THEN +
            NOTE 'TRB PARM - READ FROM SCREEN POSITION'
/* CHECK FOR BLAST TO DEST ID */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'20')) LENGTH(1) MASK(X'20')
         IF &LASTCC = 0 THEN +
            NOTE 'TRB PARM - ''BLAST'' TO DESTINATION ID'
/* CHECK FOR BLAST TO LTERM ID */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'40')) LENGTH(1) MASK(X'40')
         IF &LASTCC = 0 THEN +
            NOTE 'TRB PARM - ''BLAST'' TO LTERM ID'
/* CHECK FOR BLAST TO USER ID */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'80')) LENGTH(1) MASK(X'80')
         IF &LASTCC = 0 THEN +
            NOTE 'TRB PARM - ''BLAST'' TO USER ID'
/* CHECK FOR INPUT TRUNCATED */
         EQUATE PTETEMP &NAME&INDEX+63 LENGTH(1) BIT
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'01')) LENGTH(1) MASK(X'01')
         IF &LASTCC = 0 THEN +
            NOTE 'TRB CONDITIONS HANDLED - INPUT TRUNCATED'
/* CHECK FOR ATTN HIT ON OUTPUT */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'02')) LENGTH(1) MASK(X'02')
         IF &LASTCC = 0 THEN +
            NOTE 'TRB CONDITIONS HANDLED - ATTN HIT ON OUTPUT'
/* CHECK FOR LOGICAL DATA ERRORS */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'04')) LENGTH(1) MASK(X'04')
         IF &LASTCC = 0 THEN +
            NOTE 'TRB CONDITIONS HANDLED - LOGICAL DATA ERRORS'
/* CHECK FOR PERMANENT I/O ERRORS */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'08')) LENGTH(1) MASK(X'08')
         IF &LASTCC = 0 THEN +
            NOTE 'TRB CONDITIONS HANDLED - PERMANENT I/O ERRORS'
/* CHECK FOR TERMINAL IS DEAD */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'10')) LENGTH(1) MASK(X'10')
         IF &LASTCC = 0 THEN +
            NOTE 'TRB CONDITIONS HANDLED - TERMINAL IS DEAD'
/* CHECK FOR INVALID PTE PARAMETER LIST */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'20')) LENGTH(1) MASK(X'20')
         IF &LASTCC = 0 THEN +
            NOTE 'TRB CONDITIONS HANDLED - INVALID PTE PARAMETER LIST'
/* CHECK FOR INVALID BLAST DESTINATION */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'40')) LENGTH(1) MASK(X'40')
         IF &LASTCC = 0 THEN +
            NOTE 'TRB CONDITIONS HANDLED - INVALID BLAST DESTINATION'
/* CHECK FOR ENTER NEXT TASK CODE ALONE */
         EQUATE PTETEMP &NAME&INDEX+84 LENGTH(1) BIT
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'80')) LENGTH(1) MASK(X'80')
         IF &LASTCC = 0 THEN +
            NOTE 'ENTER NEXT TASK CODE ALONE ON SCREEN'
/* CHECK FOR MAPR TO USE DEFAULT SCREEN SIZE */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'40')) LENGTH(1) MASK(X'40')
         IF &LASTCC = 0 THEN +
            NOTE 'MAPR IS TO USE DEFAULT SCREEN SIZE'
/* CHECK FOR WAITING FOR RHDCMSTR */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'20')) LENGTH(1) MASK(X'20')
         IF &LASTCC = 0 THEN +
            NOTE 'WAITING FOR RHDCMSTR TO VARY PTERM IN'
/* CHECK FOR VARY QUIESCE */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'08')) LENGTH(1) MASK(X'08')
         IF &LASTCC = 0 THEN +
            NOTE 'VARY QUIESCE HAS BEEN ISSUED'
/* CHECK FOR VARY ABORT */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'04')) LENGTH(1) MASK(X'04')
         IF &LASTCC = 0 THEN +
            NOTE 'VARY ABORT HAS BEEN ISSUED'
/* CHECK FOR VARY CONNECT */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'02')) LENGTH(1) MASK(X'02')
         IF &LASTCC = 0 THEN +
            NOTE 'VARY CONNECT HAS BEEN ISSUED'
/* CHECK FOR VARY DISCONNECT */
         COMPARE ADDRESS(PTETEMP) LENGTH(1) +
            WITH(VALUE(X'01')) LENGTH(1) MASK(X'01')
         IF &LASTCC = 0 THEN +
            NOTE 'VARY DISCONNECT HAS BEEN ISSUED'
/* GET INFORMATION FOR UCF PTERMS */
         IF &R = &STR(Z) THEN +
            DO
            /* GET FRONT END TERMINAL ID */
               EVALUATE &NAME&INDEX+B8 LENGTH(8) CHARACTER +
                  CLIST(STORAGE(R))
               NOTE 'FRONT END TERMINAL ID IS &R'
            /* GET FRONT END SYSTEM ID */
               EVALUATE &NAME&INDEX+C0 LENGTH(8) CHARACTER +
                  CLIST(STORAGE(S))
               NOTE 'FRONT END SYSTEM ID IS &S'
            /* CHECK FOR DEDICATED MODE */
               EQUATE PTETEMP &NAME&INDEX+C8 LENGTH(1) BIT
               COMPARE ADDRESS(PTETEMP) LENGTH(1) +
                  WITH(VALUE(X'80')) LENGTH(1) MASK(X'80')
               IF &LASTCC = 0 THEN +
                  NOTE 'PTERM IS IN DEDICATED MODE'
            /* CHECK FOR INTERMITTENT MODE */
               COMPARE ADDRESS(PTETEMP) LENGTH(1) +
                  WITH(VALUE(X'40')) LENGTH(1) MASK(X'40')
               IF &LASTCC = 0 THEN +
                  NOTE 'PTERM IS IN INTERMITTENT MODE'
            /* CHECK FOR CONVERSATIONAL MODE */
               COMPARE ADDRESS(PTETEMP) LENGTH(1) +
                  WITH(VALUE(X'20')) LENGTH(1) MASK(X'20')
               IF &LASTCC = 0 THEN +
                  NOTE 'PTERM IS IN CONVERSATIONAL MODE'
            /* CHECK FOR TYPE 1 PRINTER */
               COMPARE ADDRESS(PTETEMP) LENGTH(1) +
                  WITH(VALUE(X'10')) LENGTH(1) MASK(X'10')
               IF &LASTCC = 0 THEN +
                  NOTE 'PTERM IS A TYPE 1 PRINTER'
            /* CHECK FOR TYPE 2 PRINTER */
               COMPARE ADDRESS(PTETEMP) LENGTH(1) +
                  WITH(VALUE(X'08')) LENGTH(1) MASK(X'08')
               IF &LASTCC = 0 THEN +
                  NOTE 'PTERM IS A TYPE 2 PRINTER'
            /* CHECK FOR SUSPENDED PTERM */
               EQUATE PTETEMP &NAME&INDEX+CA LENGTH(1) BIT
               COMPARE ADDRESS(PTETEMP) LENGTH(1) +
                  WITH(VALUE(X'80')) LENGTH(1) MASK(X'80')
               IF &LASTCC = 0 THEN +
                  NOTE 'PTERM IS SUSPENDED'
            /* CHECK FOR ACTIVE PTERM */
               COMPARE ADDRESS(PTETEMP) LENGTH(1) +
                  WITH(VALUE(X'40')) LENGTH(1) MASK(X'40')
               IF &LASTCC = 0 THEN +
                  NOTE 'PTERM IS ACTIVE'
            /* CHECK FOR RESERVED PTERM */
               COMPARE ADDRESS(PTETEMP) LENGTH(1) +
                  WITH(VALUE(X'20')) LENGTH(1) MASK(X'20')
               IF &LASTCC = 0 THEN +
                  NOTE 'PTERM IS RESERVED FOR TERMINAL &R'
            /* CHECK FOR WAIT ON ERE */
               COMPARE ADDRESS(PTETEMP) LENGTH(1) +
                  WITH(VALUE(X'10')) LENGTH(1) MASK(X'10')
               IF &LASTCC = 0 THEN +
                  NOTE 'PTERM IS WAITING FOR ERE'
            /* CHECK FOR ABORT ERE */
               COMPARE ADDRESS(PTETEMP) LENGTH(1) +
                  WITH(VALUE(X'08')) LENGTH(1) MASK(X'08')
               IF &LASTCC = 0 THEN +
                  NOTE 'PTERM WILL ABORT ERE IMMEDIATELY ON VARY OUT'
            /* CHECK FOR CONVERSING PTERM */
               COMPARE ADDRESS(PTETEMP) LENGTH(1) +
                  WITH(VALUE(X'01')) LENGTH(1) MASK(X'01')
               IF &LASTCC = 0 THEN +
                  NOTE 'PTERM CONVERSING - TERMINAL READ IN PROGRESS'
            /* CHECK FOR DISCONNECT REQUEST */
               EQUATE PTETEMP &NAME&INDEX+CB LENGTH(1) BIT
               COMPARE ADDRESS(PTETEMP) LENGTH(1) +
                  WITH(VALUE(X'80')) LENGTH(1) MASK(X'80')
               IF &LASTCC = 0 THEN +
                  NOTE 'TERMINAL USER ASKED TO DISCONNECT'
            /* CHECK FOR SUSPEND PTERM */
               COMPARE ADDRESS(PTETEMP) LENGTH(1) +
                  WITH(VALUE(X'40')) LENGTH(1) MASK(X'40')
               IF &LASTCC = 0 THEN +
                  NOTE 'SUSPEND PTERM ON NEXT FINISH'
            /* CHECK FOR TRANSFER TO FRONT-END TASK */
               COMPARE ADDRESS(PTETEMP) LENGTH(1) +
                  WITH(VALUE(X'20')) LENGTH(1) MASK(X'20')
               IF &LASTCC = 0 THEN +
                  NOTE 'TRANSFER TO FRONT-END TASK'
            /* CHECK FOR GETLTE TEST */
               COMPARE ADDRESS(PTETEMP) LENGTH(1) +
                  WITH(VALUE(X'08')) LENGTH(1) MASK(X'08')
               IF &LASTCC = 0 THEN +
                  NOTE 'GETLTE TEST PRINTER REQUEST'
            /* CHECK FOR GETLTE WAIT */
               COMPARE ADDRESS(PTETEMP) LENGTH(1) +
                  WITH(VALUE(X'04')) LENGTH(1) MASK(X'04')
               IF &LASTCC = 0 THEN +
                  NOTE 'GETLTE WAIT PRINTER REQUEST'
            /* CHECK FOR GETLTE NOWAIT */
               COMPARE ADDRESS(PTETEMP) LENGTH(1) +
                  WITH(VALUE(X'02')) LENGTH(1) MASK(X'02')
               IF &LASTCC = 0 THEN +
                  NOTE 'GETLTE NOWAIT PRINTER REQUEST'
            /* CHECK FOR FREELTE PRINTER */
               COMPARE ADDRESS(PTETEMP) LENGTH(1) +
                  WITH(VALUE(X'01')) LENGTH(1) MASK(X'01')
               IF &LASTCC = 0 THEN +
                  NOTE 'FREELTE PRINTER REQUEST'
            /* GET DISCONNECT/ABORT CODE */
               EVALUATE &NAME&INDEX+CC LENGTH(4) CHARACTER +
                  CLIST(STORAGE(S))
               NOTE 'PTERM DISCONNECT/ABORT CODE IS &S'
            END
GETOUT:  DROPSYM PTETEMP
/*-------------------------------------------------------------------*/
./       ADD   RLE
/* THIS CLIST DISPLAYS INFORMATION PERTAINING TO A RCE FOR A GIVEN   */
/* RLE.  THIS CLIST IS NORMALLY INVOKED ONLY BY THE CSA#RCE AND      */
/* LTE#RCE CLISTS.                                                   */
/*                                                                   */
         PROC 0 PRINT TERMINAL DEBUG
         IF &DEBUG = DEBUG THEN CONTROL LIST
         EQUATE RLEPTR X LENGTH(4) AREA SCALAR
         EQUATE RCEPTR RLEPTR+8% STRUCTURE(#RCEDS) +
            LENGTH(X'18') SCALAR
         EVALUATE RCEPTR+0 HEXADECIMAL LENGTH(1) CLIST(STORAGE(S))
         SET &RCETYPE = '&S'
         IF &RCETYPE = '01' THEN +
            DO
               NOTE 'RCE IS FOR STORAGE ---------------------------'
               COMPARE ADDRESS(RCEPTR+1) LENGTH(1) HEXADECIMAL +
                  WITH(VALUE(X'80')) LENGTH(1) MASK(X'80')
               IF &LASTCC = 0 THEN +
                  NOTE 'STORAGE IS KEPT ACROSS TASKS'
               ELSE +
                  NOTE 'STORAGE IS NOT KEPT ACROSS TASKS'
               EVALUATE RCEPTR+1 UNSIGNED LENGTH(1) CLIST(STORAGE(S))
               IF &S > 128 THEN +
                  SET &S = &S - 128
               NOTE 'STORAGE POOL ID IS &S'
               EVALUATE RCEPTR+2 UNSIGNED LENGTH(2) CLIST(STORAGE(S))
               NOTE 'NUMBER OF RLE''S OWNING THIS RCE IS &S'
               EVALUATE RCEPTR+4 UNSIGNED LENGTH(4) CLIST(STORAGE(S))
               NOTE 'THIS RCE WAS CREATED BY TASK ID &S'
               COMPARE ADDRESS(RCEPTR+8) LENGTH(1) HEXADECIMAL +
                  WITH(VALUE(X'80')) LENGTH(1) MASK(X'80')
               IF &LASTCC = 0 THEN +
                  NOTE 'STORAGE IS RELOCATABLE'
               ELSE +
                  NOTE 'STORAGE IS NOT RELOCATABLE'
               EVALUATE RCEPTR+9 UNSIGNED LENGTH(3) CLIST(STORAGE(L))
               NOTE 'STORAGE LENGTH IS &L'
               COMPARE ADDRESS(RCEPTR+C) LENGTH(1) HEXADECIMAL +
                  WITH(VALUE(X'80')) LENGTH(1) MASK(X'80')
               IF &LASTCC = 0 THEN +
                  DO
                     NOTE 'STORAGE IS CURRENTLY ''OUT'' '
                     EVALUATE RCEPTR+C HEXADECIMAL LENGTH(4) +
                        CLIST(STORAGE(S)
                     EVALUATE RCEPTR+C CHARACTER LENGTH(4) +
                        CLIST(STORAGE(T)
                     NOTE 'THE SCRATCH ID IS C''&T'' X''&S'' '
                     SET &A = '00000000'
                  END
               ELSE +
                  DO
                     EVALUATE RCEPTR+C HEXADECIMAL LENGTH(4) +
                        CLIST(STORAGE(A)
                     NOTE 'THE STORAGE ADDRESS IS X''&A'' '
                  END
               EVALUATE RCEPTR+10 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               EVALUATE RCEPTR+10 CHARACTER LENGTH(4) +
                  CLIST(STORAGE(T))
               NOTE 'THE SYMBOLIC STORAGE ID IS C''&T'' X''&S'' '
               EVALUATE RCEPTR+14 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'THE SCT ADDRESS IS X''&S'' '
               IF &A ¬= '00000000' THEN +
                   EQUATE $STG&A &A.. +
                      LENGTH(&L) AREA(STORAGE)
               GOTO GETOUT
            END
         IF &RCETYPE = '02' THEN +
            DO
               NOTE 'RCE IS FOR PROGRAM ---------------------------'
               COMPARE ADDRESS(RCEPTR+1) LENGTH(1) HEXADECIMAL +
                  WITH(VALUE(X'01')) LENGTH(1) MASK(X'01')
               IF &LASTCC = 0 THEN +
                  NOTE 'PROGRAM IS IN USE BY SOME TASK'
               COMPARE ADDRESS(RCEPTR+1) LENGTH(1) HEXADECIMAL +
                  WITH(VALUE(X'02')) LENGTH(1) MASK(X'02')
               IF &LASTCC = 0 THEN +
                  NOTE 'PROGRAM IS BEING DEBUGGED'
               COMPARE ADDRESS(RCEPTR+1) LENGTH(1) HEXADECIMAL +
                  WITH(VALUE(X'04')) LENGTH(1) MASK(X'04')
               IF &LASTCC = 0 THEN +
                  NOTE 'PROGRAM IS CURRENTLY OVERLAID'
               COMPARE ADDRESS(RCEPTR+1) LENGTH(1) HEXADECIMAL +
                  WITH(VALUE(X'08')) LENGTH(1) MASK(X'08')
               IF &LASTCC = 0 THEN +
                  NOTE 'PROGRAM MAY BE OVERLAID'
               COMPARE ADDRESS(RCEPTR+1) LENGTH(1) HEXADECIMAL +
                  WITH(VALUE(X'80')) LENGTH(1) MASK(X'80')
               IF &LASTCC = 0 THEN +
                  NOTE 'PROGRAM TO BE PURGED - NEW COPY'
               EVALUATE RCEPTR+2 UNSIGNED LENGTH(2) CLIST(STORAGE(S))
               NOTE 'NUMBER OF RLE''S OWNING THIS RCE IS &S'
               EVALUATE RCEPTR+4 UNSIGNED LENGTH(4) CLIST(STORAGE(S))
               NOTE 'THIS RCE WAS CREATED BY TASK ID &S'
               EVALUATE RCEPTR+8 UNSIGNED LENGTH(4) CLIST(STORAGE(L))
               NOTE 'PROGRAM LENGTH IS &L'
               EVALUATE RCEPTR+C HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(A))
               NOTE 'PROGRAM ADDRESS IS X''&A'' '
               EVALUATE RCEPTR+10% CHARACTER LENGTH(8) +
                  CLIST(STORAGE(N))
               NOTE 'PROGRAM NAME IS ''&N'' '
               EVALUATE RCEPTR+10 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(A2))
               NOTE 'THE PDE ADDRESS IS X''&A2'' '
               EVALUATE RCEPTR+14 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'THE PDT ADDRESS IS X''&S'' '
               EQUATE $PGM$&N &A.. LENGTH(&L) +
                  AREA(PROGRAM)
               EQUATE $PDE$&N &A2.. LENGTH(196) +
                  STRUCTURE(#PDEDS)
               GOTO GETOUT
            END
         IF &RCETYPE = '03' THEN +
            DO
               NOTE 'RCE IS FOR FILE CONTROL ----------------------'
               EVALUATE RCEPTR+2 UNSIGNED LENGTH(2) CLIST(STORAGE(S))
               NOTE 'NUMBER OF RLE''S OWNING THIS RCE IS &S'
               EVALUATE RCEPTR+4 UNSIGNED LENGTH(4) CLIST(STORAGE(S))
               NOTE 'THIS RCE WAS CREATED BY TASK ID &S'
               EVALUATE RCEPTR+8 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'FIRST VARIABLE WORD IS X''&S'' '
               EVALUATE RCEPTR+C HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'SECOND VARIABLE WORD IS X''&S'' '
               EVALUATE RCEPTR+10 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'THIRD VARIABLE WORD IS X''&S'' '
               EVALUATE RCEPTR+14 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'FOURTH VARIABLE WORD IS X''&S'' '
               GOTO GETOUT
            END
         IF &RCETYPE = '04' THEN +
            DO
               NOTE 'RCE IS FOR SCRATCH ---------------------------'
               EVALUATE RCEPTR+2 UNSIGNED LENGTH(2) CLIST(STORAGE(S))
               NOTE 'NUMBER OF RLE''S OWNING THIS RCE IS &S'
               EVALUATE RCEPTR+4 UNSIGNED LENGTH(4) CLIST(STORAGE(S))
               NOTE 'THIS RCE WAS CREATED BY TASK ID &S'
               EVALUATE RCEPTR+8 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(A))
               NOTE 'SCRATCH INDEX AREA ADDRESS IS X''&A'' '
               EVALUATE RCEPTR+C CHARACTER LENGTH(8) +
                  CLIST(STORAGE(N))
               NOTE 'SCRATCH INDEX AREA ID IS ''&N'' '
               EVALUATE RCEPTR+14 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'FOURTH VARIABLE WORD IS X''&S'' '
               EQUATE $SIA$&N &A.. LENGTH(48) STRUCTURE(#SIADS)
               GOTO GETOUT
            END
         IF &RCETYPE = '05' THEN +
            DO
               NOTE 'RCE IS FOR INTERNAL RUN UNIT -----------------'
               EVALUATE RCEPTR+2 UNSIGNED LENGTH(2) CLIST(STORAGE(S))
               NOTE 'NUMBER OF RLE''S OWNING THIS RCE IS &S'
               EVALUATE RCEPTR+4 UNSIGNED LENGTH(4) CLIST(STORAGE(S))
               NOTE 'THIS RCE WAS CREATED BY TASK ID &S'
               EVALUATE RCEPTR+8 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'FIRST VARIABLE WORD IS X''&S'' '
               EVALUATE RCEPTR+C HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'RUN UNIT AREA ADDRESS IS X''&S'' '
               EQUATE $RUA &S.. LENGTH(24) STRUCTURE(#RUADS)
               EVALUATE RCEPTR+10 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'SUBSCHEMA CONTROL ADDRESS IS X''&S'' '
               EQUATE $SSC &S.. LENGTH(200) STRUCTURE(#SSCDS)
               EVALUATE RCEPTR+14 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'FOURTH VARIABLE WORD IS X''&S'' '
               GOTO GETOUT
            END
         IF &RCETYPE = '06' THEN +
            DO
               NOTE 'RCE IS FOR QUEUE -----------------------------'
               EVALUATE RCEPTR+2 UNSIGNED LENGTH(2) CLIST(STORAGE(S))
               NOTE 'NUMBER OF RLE''S OWNING THIS RCE IS &S'
               EVALUATE RCEPTR+4 UNSIGNED LENGTH(4) CLIST(STORAGE(S))
               NOTE 'THIS RCE WAS CREATED BY TASK ID &S'
               EVALUATE RCEPTR+8 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'FIRST VARIABLE WORD IS X''&S'' '
               EVALUATE RCEPTR+C HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'QUEUE CONTROL ELEMENT ADDRESS IS X''&S'' '
               EQUATE $QCE$&S &S.. LENGTH(48) STRUCTURE(#QCEDS)
               EVALUATE $QCE$&S+0 CHARACTER LENGTH(16) +
                  CLIST(STORAGE(T))
               NOTE 'THE QUEUE NAME IS ''&T'' '
               EVALUATE RCEPTR+10 HEXADECIMAL LENGTH(1) +
                  CLIST(STORAGE(S))
               NOTE 'QUEUE ELEMENT PREVIOUS FUNCTION IS X''&S'' '
               EVALUATE RCEPTR+14 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'FOURTH VARIABLE WORD IS X''&S'' '
               GOTO GETOUT
            END
         IF &RCETYPE = '07' THEN +
            DO
               NOTE 'RCE IS FOR DUMP ------------------------------'
               EVALUATE RCEPTR+2 UNSIGNED LENGTH(2) CLIST(STORAGE(S))
               NOTE 'NUMBER OF RLE''S OWNING THIS RCE IS &S'
               EVALUATE RCEPTR+4 UNSIGNED LENGTH(4) CLIST(STORAGE(S))
               NOTE 'THIS RCE WAS CREATED BY TASK ID &S'
               EVALUATE RCEPTR+8 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'FIRST VARIABLE WORD IS X''&S'' '
               EVALUATE RCEPTR+C HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(A))
               NOTE 'ADDRESS TO DUMP IF TASK ABENDS IS X''&A'' '
               EVALUATE RCEPTR+10 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(L))
               NOTE 'LENGTH OF STORAGE TO DUMP IS X''&L'' '
               EQUATE $DUMP$&A &A.. LENGTH(X'&L') AREA(DUMP)
               EVALUATE RCEPTR+14 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'FOURTH VARIABLE WORD IS X''&S'' '
               GOTO GETOUT
            END
         IF &RCETYPE = '08' THEN +
            DO
               NOTE 'RCE IS FOR MESSAGE QUEUE ---------------------'
               EVALUATE RCEPTR+2 UNSIGNED LENGTH(2) CLIST(STORAGE(S))
               NOTE 'NUMBER OF RLE''S OWNING THIS RCE IS &S'
               EVALUATE RCEPTR+4 UNSIGNED LENGTH(4) CLIST(STORAGE(S))
               NOTE 'THIS RCE WAS CREATED BY TASK ID &S'
               EVALUATE RCEPTR+8 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'MESSAGE QUEUE LENGTH IS X''&S'' '
               EVALUATE RCEPTR+C HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'DATABASE KEY IS X''&S'' '
               EVALUATE RCEPTR+10 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'THIRD VARIABLE WORD IS X''&S'' '
               EVALUATE RCEPTR+14 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'FOURTH VARIABLE WORD IS X''&S'' '
               GOTO GETOUT
            END
         IF &RCETYPE = '09' THEN +
            DO
               NOTE 'RCE IS FOR SIGNON ----------------------------'
               EVALUATE RCEPTR+2 UNSIGNED LENGTH(2) CLIST(STORAGE(S))
               NOTE 'NUMBER OF RLE''S OWNING THIS RCE IS &S'
               EVALUATE RCEPTR+4 UNSIGNED LENGTH(4) CLIST(STORAGE(S))
               NOTE 'THIS RCE WAS CREATED BY TASK ID &S'
               EVALUATE RCEPTR+8 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'FIRST VARIABLE WORD IS X''&S'' '
               EVALUATE RCEPTR+C HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(A))
               NOTE 'SIGNON ELEMENT ADDRESS IS X''&A'' '
               EVALUATE RCEPTR+10 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(N))
               NOTE 'LOGICAL TERMINAL ELEMENT ADDRESS IS X''&N'' '
               EQUATE $SON$&N &A.. LENGTH(108) STRUCTURE(#SONDS)
               EVALUATE RCEPTR+14 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'OTP USER CONTROL BLOCK ADDRESS IS X''&S'' '
               GOTO GETOUT
            END
         IF &RCETYPE = '0A' THEN +
            DO
               NOTE 'RCE IS FOR ENQUEUE ---------------------------'
               EVALUATE RCEPTR+2 UNSIGNED LENGTH(2) CLIST(STORAGE(S))
               NOTE 'NUMBER OF RLE''S OWNING THIS RCE IS &S'
               EVALUATE RCEPTR+4 UNSIGNED LENGTH(4) CLIST(STORAGE(S))
               NOTE 'THIS RCE WAS CREATED BY TASK ID &S'
               EVALUATE RCEPTR+8 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'FIRST VARIABLE WORD IS X''&S'' '
               EVALUATE RCEPTR+C HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'ENQUEUE CONTROL ELEMENT ADDRESS IS X''&S'' '
               EQUATE $ECE$&S &S.. LENGTH(21) STRUCTURE(#ECEDS)
               EVALUATE RCEPTR+10 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'THIRD VARIABLE WORD IS X''&S'' '
               EVALUATE RCEPTR+14 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'FOURTH VARIABLE WORD IS X''&S'' '
               GOTO GETOUT
            END
         IF &RCETYPE = '0B' THEN +
            DO
               NOTE 'RCE IS FOR SINGLE-THREAD RESOURCE ------------'
               COMPARE ADDRESS(RCEPTR+1) LENGTH(1) HEXADECIMAL +
                  WITH(VALUE(X'01')) LENGTH(1)
               IF &LASTCC = 0 THEN +
                  NOTE 'RESOURCE IS LOADER'
               COMPARE ADDRESS(RCEPTR+1) LENGTH(1) HEXADECIMAL +
                  WITH(VALUE(X'02')) LENGTH(1)
               IF &LASTCC = 0 THEN +
                  NOTE 'RESOURCE IS LOG FILE'
               COMPARE ADDRESS(RCEPTR+1) LENGTH(1) HEXADECIMAL +
                  WITH(VALUE(X'03')) LENGTH(1)
               IF &LASTCC = 0 THEN +
                  NOTE 'RESOURCE IS TRANSACTION LOG FILE'
               COMPARE ADDRESS(RCEPTR+1) LENGTH(1) HEXADECIMAL +
                  WITH(VALUE(X'04')) LENGTH(1)
               IF &LASTCC = 0 THEN +
                  NOTE 'RESOURCE IS SCRATCH AREA'
               EVALUATE RCEPTR+2 UNSIGNED LENGTH(2) CLIST(STORAGE(S))
               NOTE 'NUMBER OF RLE''S OWNING THIS RCE IS &S'
               EVALUATE RCEPTR+4 UNSIGNED LENGTH(4) CLIST(STORAGE(S))
               NOTE 'THIS RCE WAS CREATED BY TASK ID &S'
               EVALUATE RCEPTR+8 UNSIGNED LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'NUMBER OF TASKS WAITING FOR RESOURCE IS &S'
               EVALUATE RCEPTR+C HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'ADDRESS OF OWNER DCE IS X''&S'' '
               EVALUATE RCEPTR+10 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'RESOURCE ECB ADDRESS IS X''&S'' '
               EVALUATE RCEPTR+14 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'FOURTH VARIABLE WORD IS X''&S'' '
               GOTO GETOUT
            END
         IF &RCETYPE = '0C' THEN +
            DO
               NOTE 'RCE IS FOR ECB ID ----------------------------'
               EVALUATE RCEPTR+2 UNSIGNED LENGTH(2) CLIST(STORAGE(S))
               NOTE 'NUMBER OF RLE''S OWNING THIS RCE IS &S'
               EVALUATE RCEPTR+4 UNSIGNED LENGTH(4) CLIST(STORAGE(S))
               NOTE 'THIS RCE WAS CREATED BY TASK ID &S'
               EVALUATE RCEPTR+8 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'FIRST VARIABLE WORD IS X''&S'' '
               EVALUATE RCEPTR+C HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'GENERAL ECB IS X''&S'' '
               EVALUATE RCEPTR+10 CHARACTER LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'SYMBOLIC ECB ID IS ''&S'' '
               EVALUATE RCEPTR+14 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'FOURTH VARIABLE WORD IS X''&S'' '
               GOTO GETOUT
            END
         IF &RCETYPE = '0D' THEN +
            DO
               NOTE 'RCE IS FOR MSG DICT QUEUE --------------------'
               EVALUATE RCEPTR+2 UNSIGNED LENGTH(2) CLIST(STORAGE(S))
               NOTE 'NUMBER OF RLE''S OWNING THIS RCE IS &S'
               EVALUATE RCEPTR+4 UNSIGNED LENGTH(4) CLIST(STORAGE(S))
               NOTE 'THIS RCE WAS CREATED BY TASK ID &S'
               EVALUATE RCEPTR+8 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'FIRST VARIABLE WORD IS X''&S'' '
               EVALUATE RCEPTR+C HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'MSG DICT QUEUE ELEMENT ADDRESS IS X''&S'' '
               EQUATE $MDQ$&S &S.. LENGTH(156) STRUCTURE(#MDQDS)
               EVALUATE RCEPTR+10 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'RLE ANCHOR ADDRESS FOR RCE IS X''&S'' '
               EVALUATE RCEPTR+14 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'FOURTH VARIABLE WORD IS X''&S'' '
               GOTO GETOUT
            END
         IF &RCETYPE = '0E' THEN +
            DO
               NOTE 'RCE IS FOR IDMS RUN UNIT ---------------------'
               EVALUATE RCEPTR+2 UNSIGNED LENGTH(2) CLIST(STORAGE(S))
               NOTE 'NUMBER OF RLE''S OWNING THIS RCE IS &S'
               EVALUATE RCEPTR+4 UNSIGNED LENGTH(4) CLIST(STORAGE(S))
               NOTE 'THIS RCE WAS CREATED BY TASK ID &S'
               EVALUATE RCEPTR+8 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'FIRST VARIABLE WORD IS X''&S'' '
               EVALUATE RCEPTR+C HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'VARIABLE SUBSCHEMA ADDRESS IS X''&S'' '
               EQUATE $VIB &S.. LENGTH(556) STRUCTURE(#VIBDS)
               EVALUATE RCEPTR+10 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'THIRD VARIABLE WORD IS X''&S'' '
               EVALUATE RCEPTR+14 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'FOURTH VARIABLE WORD IS X''&S'' '
               GOTO GETOUT
            END
         IF &RCETYPE = '0F' THEN +
            DO
               NOTE 'RCE IS FOR INTERVAL CONTROL ------------------'
               EVALUATE RCEPTR+2 UNSIGNED LENGTH(2) CLIST(STORAGE(S))
               NOTE 'NUMBER OF RLE''S OWNING THIS RCE IS &S'
               EVALUATE RCEPTR+4 UNSIGNED LENGTH(4) CLIST(STORAGE(S))
               NOTE 'THIS RCE WAS CREATED BY TASK ID &S'
               EVALUATE RCEPTR+8 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'FIRST VARIABLE WORD IS X''&S'' '
               EVALUATE RCEPTR+C HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'INTERVAL CONTROL ELEMENT ADDRESS IS X''&S'' '
               EQUATE $ILE &S.. LENGTH(24) STRUCTURE(#ILEDS)
               EVALUATE RCEPTR+10 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'THIRD VARIABLE WORD IS X''&S'' '
               EVALUATE RCEPTR+14 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'FOURTH VARIABLE WORD IS X''&S'' '
               GOTO GETOUT
            END
         IF &RCETYPE = '10' THEN +
            DO
               NOTE 'RCE IS FOR BLL LIST --------------------------'
               EVALUATE RCEPTR+2 UNSIGNED LENGTH(2) CLIST(STORAGE(S))
               NOTE 'NUMBER OF RLE''S OWNING THIS RCE IS &S'
               EVALUATE RCEPTR+4 UNSIGNED LENGTH(4) CLIST(STORAGE(S))
               NOTE 'THIS RCE WAS CREATED BY TASK ID &S'
               EVALUATE RCEPTR+8 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'PROGRAM RCE OF BLL OWNER IS X''&S'' '
               EVALUATE RCEPTR+C HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'BLL LIST ADDRESS IS X''&S'' '
               EVALUATE RCEPTR+10 HEXADECIMAL LENGTH(2) +
                  CLIST(STORAGE(S))
               NOTE 'DISPLACEMENT OF FIRST BLL FOR RSRC IS X''&S'' '
               EVALUATE RCEPTR+12 HEXADECIMAL LENGTH(2) +
                  CLIST(STORAGE(S))
               NOTE 'DISPLACEMENT OF SECOND BLL FOR RSRC IS X''&S'' '
               EVALUATE RCEPTR+14 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'TASK GLOBAL TABLE ADDRESS IS X''&S'' '
               GOTO GETOUT
            END
         IF &RCETYPE = '11' THEN +
            DO
               NOTE 'RCE IS FOR BLAST MESSAGE BUFFER --------------'
               EVALUATE RCEPTR+2 UNSIGNED LENGTH(2) CLIST(STORAGE(S))
               NOTE 'NUMBER OF RLE''S OWNING THIS RCE IS &S'
               EVALUATE RCEPTR+4 UNSIGNED LENGTH(4) CLIST(STORAGE(S))
               NOTE 'THIS RCE WAS CREATED BY TASK ID &S'
               EVALUATE RCEPTR+8 UNSIGNED LENGTH(4) +
                  CLIST(STORAGE(L))
               NOTE 'MESSAGE BUFFER LENGTH IS &L'
               EVALUATE RCEPTR+C HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'ADDRESS TO DUMP IF TASK ABENDS IS X''&S'' '
               EQUATE $BLAST &S.. LENGTH(&L) AREA(BLAST)
               EVALUATE RCEPTR+10 UNSIGNED LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'NUMBER OF TERMINALS QUEUED TO MESSAGE IS &S'
               EVALUATE RCEPTR+14 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'FOURTH VARIABLE WORD IS X''&S'' '
               GOTO GETOUT
            END
         IF &RCETYPE = '12' THEN +
            DO
               NOTE 'RCE IS FOR DDS LONG TERM RESOURCES -----------'
               EVALUATE RCEPTR+2 UNSIGNED LENGTH(2) CLIST(STORAGE(S))
               NOTE 'NUMBER OF RLE''S OWNING THIS RCE IS &S'
               EVALUATE RCEPTR+4 UNSIGNED LENGTH(4) CLIST(STORAGE(S))
               NOTE 'THIS RCE WAS CREATED BY TASK ID &S'
               EVALUATE RCEPTR+8 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'FIRST VARIABLE WORD IS X''&S'' '
               EVALUATE RCEPTR+C CHARACTER LENGTH(8) +
                  CLIST(STORAGE(S))
               NOTE 'DDS TARGET FOR LONG TERM RESOURCES IS ''&S'' '
               EVALUATE RCEPTR+14 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'FOURTH VARIABLE WORD IS X''&S'' '
               GOTO GETOUT
            END
         IF &RCETYPE = '13' THEN +
            DO
               NOTE 'RCE IS FOR RELOCATABLE STORAGE ---------------'
               EVALUATE RCEPTR+2 UNSIGNED LENGTH(2) CLIST(STORAGE(S))
               NOTE 'NUMBER OF RLE''S OWNING THIS RCE IS &S'
               EVALUATE RCEPTR+4 UNSIGNED LENGTH(4) CLIST(STORAGE(S))
               NOTE 'THIS RCE WAS CREATED BY TASK ID &S'
               EVALUATE RCEPTR+8 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'ADDRESS OF TYPE 1 RCE FOR STORAGE IS X''&S'' '
               EVALUATE RCEPTR+C HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'RELOCATABLE STORAGE ADDRESS IS X''&S'' '
               EQUATE $RSTG$&S &S.. AREA(RSTG)
               EVALUATE RCEPTR+10 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'THIRD VARIABLE WORD IS X''&S'' '
               EVALUATE RCEPTR+14 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'FOURTH VARIABLE WORD IS X''&S'' '
               GOTO GETOUT
            END
         IF &RCETYPE = '14' THEN +
            DO
               NOTE 'RCE IS FOR OTP IOP ---------------------------'
               EVALUATE RCEPTR+2 UNSIGNED LENGTH(2) CLIST(STORAGE(S))
               NOTE 'NUMBER OF RLE''S OWNING THIS RCE IS &S'
               EVALUATE RCEPTR+4 UNSIGNED LENGTH(4) CLIST(STORAGE(S))
               NOTE 'THIS RCE WAS CREATED BY TASK ID &S'
               EVALUATE RCEPTR+8 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'FIRST VARIABLE WORD IS X''&S'' '
               EVALUATE RCEPTR+C HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'OTP IOP ADDRESS IS X''&S'' '
               EVALUATE RCEPTR+10 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'THIRD VARIABLE WORD IS X''&S'' '
               EVALUATE RCEPTR+14 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'FOURTH VARIABLE WORD IS X''&S'' '
               GOTO GETOUT
            END
         IF &RCETYPE = '15' THEN +
            DO
               NOTE 'RCE IS FOR OTP PAGE BUFFER -------------------'
               EVALUATE RCEPTR+2 UNSIGNED LENGTH(2) CLIST(STORAGE(S))
               NOTE 'NUMBER OF RLE''S OWNING THIS RCE IS &S'
               EVALUATE RCEPTR+4 UNSIGNED LENGTH(4) CLIST(STORAGE(S))
               NOTE 'THIS RCE WAS CREATED BY TASK ID &S'
               EVALUATE RCEPTR+8 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'FIRST VARIABLE WORD IS X''&S'' '
               EVALUATE RCEPTR+C HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'OTP PAGE BUFFER ADDRESS IS X''&S'' '
               EVALUATE RCEPTR+10 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'THIRD VARIABLE WORD IS X''&S'' '
               EVALUATE RCEPTR+14 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'FOURTH VARIABLE WORD IS X''&S'' '
               GOTO GETOUT
            END
         IF &RCETYPE = '16' THEN +
            DO
               NOTE 'RCE IS FOR OTP BUFFER WAIT -------------------'
               EVALUATE RCEPTR+2 UNSIGNED LENGTH(2) CLIST(STORAGE(S))
               NOTE 'NUMBER OF RLE''S OWNING THIS RCE IS &S'
               EVALUATE RCEPTR+4 UNSIGNED LENGTH(4) CLIST(STORAGE(S))
               NOTE 'THIS RCE WAS CREATED BY TASK ID &S'
               EVALUATE RCEPTR+8 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'FIRST VARIABLE WORD IS X''&S'' '
               EVALUATE RCEPTR+C HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'OTP BUFFER WAIT ADDRESS IS X''&S'' '
               EVALUATE RCEPTR+10 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'THIRD VARIABLE WORD IS X''&S'' '
               EVALUATE RCEPTR+14 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'FOURTH VARIABLE WORD IS X''&S'' '
               GOTO GETOUT
            END
         IF &RCETYPE = '17' THEN +
            DO
               NOTE 'RCE IS FOR OTP TRESPASSER FEB ----------------'
               EVALUATE RCEPTR+2 UNSIGNED LENGTH(2) CLIST(STORAGE(S))
               NOTE 'NUMBER OF RLE''S OWNING THIS RCE IS &S'
               EVALUATE RCEPTR+4 UNSIGNED LENGTH(4) CLIST(STORAGE(S))
               NOTE 'THIS RCE WAS CREATED BY TASK ID &S'
               EVALUATE RCEPTR+8 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'FIRST VARIABLE WORD IS X''&S'' '
               EVALUATE RCEPTR+C HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'OTP TRESSPASSER FEB ADDRESS IS X''&S'' '
               EVALUATE RCEPTR+10 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'THIRD VARIABLE WORD IS X''&S'' '
               EVALUATE RCEPTR+14 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'FOURTH VARIABLE WORD IS X''&S'' '
               GOTO GETOUT
            END
         IF &RCETYPE = 'FF' THEN +
            DO
               NOTE 'RCE IS UNINITIALIZED -------------------------'
               EVALUATE RCEPTR+2 UNSIGNED LENGTH(2) CLIST(STORAGE(S))
               NOTE 'NUMBER OF RLE''S OWNING THIS RCE IS &S'
               EVALUATE RCEPTR+4 UNSIGNED LENGTH(4) CLIST(STORAGE(S))
               NOTE 'THIS RCE WAS CREATED BY TASK ID &S'
               EVALUATE RCEPTR+8 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'FIRST VARIABLE WORD IS X''&S'' '
               EVALUATE RCEPTR+C HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'SECOND VARIABLE WORD IS X''&S'' '
               EVALUATE RCEPTR+10 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'THIRD VARIABLE WORD IS X''&S'' '
               EVALUATE RCEPTR+14 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'FOURTH VARIABLE WORD IS X''&S'' '
               GOTO GETOUT
            END
         NOTE 'AN UNKNOWN RCE TYPE HAS BEEN ENCOUNTERED ***********'
               EVALUATE RCEPTR+0 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'FIRST FIXED WORD IS X''&S'' '
               EVALUATE RCEPTR+4 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'SECOND FIXED WORD IS X''&S'' '
               EVALUATE RCEPTR+8 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'FIRST VARIABLE WORD IS X''&S'' '
               EVALUATE RCEPTR+C HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'SECOND VARIABLE WORD IS X''&S'' '
               EVALUATE RCEPTR+10 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'THIRD VARIABLE WORD IS X''&S'' '
               EVALUATE RCEPTR+14 HEXADECIMAL LENGTH(4) +
                  CLIST(STORAGE(S))
               NOTE 'FOURTH VARIABLE WORD IS X''&S'' '
GETOUT:  NOTE ' '
         END
/*-------------------------------------------------------------------*/
./       ADD   SCRW
/* THIS CLIST GIVES A PARTIAL DISPLAY OF THE CONTENTS OF THE SCRATCH */
/* WORK BUFFERS.  ONLY AS MUCH INFORMATION WILL BE DISPLAYED FOR     */
/* EACH BUFFER PAGE AS WILL FIT ON ONE LINE OF THE TERMINAL DISPLAY. */
/* THE WIDHTH OF THE TERMINAL DISPLAY CAN BE SPECIFIED BY THE "COLS" */
/* PARAMETER.  AN EXAMPLE CALL MIGHT BE "SCRW COLS(80)".  THE "INIT" */
/* CLIST MUST BE EXECUTED BEFORE EXECUTING THIS CLIST.  THIS CLIST   */
/* INVOKES THE FOLLOWING CLIST:  SCRWBUFF.                           */
/*                                                                   */
         PROC 0 PRINT TERMINAL DEBUG COLS(132)
         IF &DEBUG = DEBUG THEN CONTROL LIST
         EVALSYM #CSADS
         IF &LASTCC > 0 THEN +
            DO
               NOTE 'SYMBOL ''#CSADS'' IS NOT DEFINED'
               GOTO GETOUT
            END
         EQUATE $SCRW #CSADS+42C% LENGTH(104) STRUCTURE(#SCRWDS)
         EQUATE BUFSTRT $SCRW+4% LENGTH(4) POINTER
         NOTE 'CONTENTS OF SCRATCH BUFFER PAGES'
         NOTE '======================================================='
         NOTE 'DB PAGE#| TEXT (EXCLUDING PAGE HEADER)'
         NOTE '--------|----------------------------------------------'
         RUNCHAIN ADDRESS(BUFSTRT) CHAIN(100) +
            EXEC((SCRWBUFF &PRINT &TERMINAL &DEBUG COLS(&COLS))) +
            LINK(X'00') NAME($SCRWBUFF) NULL(X'00000000') +
            NOVERIFY
GETOUT:  NOTE ' '
         END
/*-------------------------------------------------------------------*/
./       ADD   SCRWBUFF
/* THIS CLIST DISPLAYS THE CONTENTS OF ONE PAGE IN THE SCRATCH WORK  */
/* BUFFERS.  THIS CLIST IS NORMALLY INVOKED ONLY BY THE SCRW CLIST.  */
/*                                                                   */
         PROC 0 PRINT TERMINAL DEBUG COLS()
         IF &DEBUG = DEBUG THEN CONTROL LIST
         SET &LNGTH = &COLS - 5
         EQUATE BUFFPTR X
         EVALUATE BUFFPTR+18 HEXADECIMAL LENGTH(4) +
            CLIST(STORAGE(P))
         EVALUATE BUFFPTR+2C CHARACTER LENGTH(&LNGTH) +
            CLIST(STORAGE(T) UNQUOTE)
         NOTE '&P|&T'
         END
/*-------------------------------------------------------------------*/
./       ADD   SIA
/* THIS CLIST DISPLAYS THE CONTENTS OF A GIVEN SCRATCH INDEX AREA.   */
/* YOU MUST SUPPLY THE SUFFIX OF THE IPCS SYMBOL NAME FOR THE        */
/* PARTICULAR SCRATCH INDEX AREA THAT YOU ARE INTERESTED IN.  A      */
/* SAMPLE CALL MIGHT BE "SIA INDEX(02)".  THE "INIT" CLIST MUST BE   */
/* EXECUTED BEFORE EXECUTING THIS CLIST.                             */
/*                                                                   */
         PROC 0 PRINT TERMINAL DEBUG INDEX() NAME($SIA$)
         IF &DEBUG = DEBUG THEN CONTROL LIST
         EVALSYM &NAME&INDEX
         IF &LASTCC > 0 THEN +
            DO
               NOTE 'SYMBOL ''&NAME&INDEX'' IS NOT DEFINED'
               GOTO GETOUT
            END
         NOTE 'SCRATCH INDEX AREA DISPLAY FOR ID ''&INDEX'' '
         NOTE '======================================================'
         NOTE 'PAGE LIST AREA'
         NOTE '--------------------------'
         NOTE 'DB PAGE# | SPACE AVAILABLE'
         NOTE '---------|----------------'
         EQUATE PLAPTR &NAME&INDEX+20% LENGTH(4) POINTER
         EVALSYM PLAPTR CLIST(ADDRESS(A) POSITION(P) DECIMAL)
         SET &A = &A + &P
LOOP1:   COMPARE ADDRESS(PLAPTR+0) LENGTH(4) +
            WITH(VALUE(X'00000000')) LENGTH(4)
         IF &LASTCC = 0 THEN GOTO GETSIE
         EVALUATE PLAPTR+0 HEXADECIMAL LENGTH(4) CLIST(STORAGE(DBP))
         EVALUATE PLAPTR+4 UNSIGNED LENGTH(4) +
            CLIST(STORAGE(SA))
         NOTE '&DBP | &SA'
         SET &A = &A + 8
         INTEGER &A CLIST(STORAGE(AX))
         EQUATE PLAPTR &AX.. LENGTH(4) POINTER
         GOTO LOOP1
GETSIE:  NOTE '======================================================'
         NOTE 'SCRATCH INDEX ELEMENTS'
         NOTE '------------------------------------------------------'
         NOTE 'REC ID   | DBKEY    | SPACE USED (SIE''S FOR THIS REC)'
         NOTE '---------|----------|---------------------------------'
         EQUATE SIESTRT &NAME&INDEX+10% LENGTH(4) POINTER
         EVALSYM SIESTRT CLIST(ADDRESS(A) POSITION(P) DECIMAL)
         SET &A = &A + &P
         EQUATE SIEEND &NAME&INDEX+18% LENGTH(4) POINTER
         EVALSYM SIEEND CLIST(ADDRESS(A2) POSITION(P2) DECIMAL)
         SET &A2 = &A2 + &P2
LOOP2:   IF &A >= &A2 THEN GOTO GETOUT
         EVALUATE SIESTRT+0 HEXADECIMAL LENGTH(4) +
            CLIST(STORAGE(RECID))
         EVALUATE SIESTRT+4 HEXADECIMAL LENGTH(4) +
            CLIST(STORAGE(DBKEY))
         EVALUATE SIESTRT+8 UNSIGNED LENGTH(2) +
            CLIST(STORAGE(USED))
         EVALUATE SIESTRT+A UNSIGNED LENGTH(1) +
            CLIST(STORAGE(SIES))
         NOTE '&RECID | &DBKEY | &USED (&SIES)'
         SET &A = &A + 12
         INTEGER &A CLIST(STORAGE(AX))
         EQUATE SIESTRT &AX.. LENGTH(4) POINTER
         GOTO LOOP2
GETOUT:  NOTE ' '
         END
/*-------------------------------------------------------------------*/
./       ADD   TASKS
/* THIS CLIST DISPLAYS A LIST OF ALL TASKS THAT WERE EXECUTING UNDER */
/* CV AT THE TIME OF THE DUMP.  THE "INIT" CLIST MUST BE EXECUTED    */
/* BEFORE EXECUTING THIS CLIST.  THIS CLIST INVOKES THE FOLLOWING    */
/* CLIST:  TCETASK.                                                  */
/*                                                                   */
         PROC 0 PRINT TERMINAL DEBUG
         IF &DEBUG = DEBUG THEN CONTROL LIST
/* RUN THE DCE CHAIN GETTING #DCEDS, #TCEDS, #LTEDS, #PTEDS DSECTS */
         EQUATE DCESTRT #CSADS+2A0 LENGTH(4) POINTER
         EVALSYM DCESTRT CLIST(ADDRESS(A) POSITION(P) DECIMAL)
         SET &DCESTRT = &A + &P
         RUNCHAIN ADDRESS(DCESTRT%) +
            LENGTH(X'40') STRUCTURE(#DCEDS) +
            EXEC((TCETASK &PRINT &TERMINAL &DEBUG)) +
            NULL(&DCESTRT) NAME(#DCEX) LINK(X'00') +
            CHAIN(75) DROP DISPLAY(NOREQUEST) NOTERMINAL
/* DELETE TEMPORARY SYMBOLS */
         DROPSYM * NOPURGE
DONE:    NOTE ' '
         EXIT CODE(&MAXCC)
         END
/*-------------------------------------------------------------------*/
./       ADD   TCE
/* THIS CLIST ESTABLISHES ADDRESSABILITY TO THE TCE CONTROL BLOCK    */
/* AND ITS ASSOCIATED LTE AND PTE CONTROL BLOCKS (IF ANY).  THIS     */
/* CLIST IS NORMALLY INVOKED ONLY BY THE "INIT" CLIST.               */
/*                                                                   */
         PROC 0 PRINT TERMINAL DEBUG
         IF &DEBUG = DEBUG THEN CONTROL LIST
         EQUATE DCEPTR X LENGTH(4) AREA SCALAR
         EVALSYM < @RHDCOS00 CLIST(SYMBOL(S))
         IF &SUBSTR(1:4,&S) ¬= &STR(#DCE) THEN +
            DO WHILE &SUBSTR(1:4,&S) ¬= &STR(#DCE)
               EVALSYM < &S CLIST(SYMBOL(S))
               IF &LASTCC > 0 THEN GOTO GETOUT
            END
         SET &SUFFIX = &SUBSTR(7:8,&S)
         COMPARE ADDRESS(DCEPTR+8%) LENGTH(4) +
            WITH(VALUE(C'TCE*')) LENGTH(4)
         IF &LASTCC = 0 THEN +
            DO
               EQUATE #TCEDS&SUFFIX DCEPTR+8% STRUCTURE(#TCEDS) +
                  LENGTH(X'E10') SCALAR NODROP +
                  REMARK('TASK CONTROL ELEMENT (TCE)')
               COMPARE ADDRESS(#TCEDS&SUFFIX+4C) LENGTH(4) +
                  WITH(VALUE(X'00000000')) LENGTH(4) MASK(X'0FFFFFFF')
               IF &LASTCC ¬= 0 THEN +
                  DO
                     EQUATE #LTEDS&SUFFIX #TCEDS&SUFFIX+4C% +
                        STRUCTURE(#LTEDS) LENGTH(X'100') +
                        REMARK('LOGICAL TERMINAL ELEMENT (LTE)') +
                        SCALAR NODROP
                     EQUATE #PTEDS&SUFFIX #LTEDS&SUFFIX+8% +
                        STRUCTURE(#PTEDS) LENGTH(X'110') +
                        REMARK('PHYSICAL TERMINAL ELEMENT (PTE)') +
                        SCALAR NODROP
                  END
            END
GETOUT:  NOTE ' '
         END
/*-------------------------------------------------------------------*/
./       ADD   TCE#RCE
/* THIS CLIST WALKS ALL OF THE RCE CHAINS OFF FROM A GIVEN TCE.  YOU */
/* MUST SUPPLY THE SUFFIX OF THE IPCS SYMBOL NAME OF THE PARTICULAR  */
/* TCE CONTROL BLOCK THAT YOU ARE INTERESTED IN.  A SAMPLE CALL      */
/* MIGHT BE "TCE#RCE INDEX(13)".  THE "INIT" CLIST MUST BE EXECUTED  */
/* BEFORE EXECUTING THIS CLIST.  THIS CLIST INVOKES THE FOLLOWING    */
/* CLIST:  RCE.                                                      */
/*                                                                   */
         PROC 0 PRINT TERMINAL DEBUG INDEX() NAME(#TCEDS)
         IF &DEBUG = DEBUG THEN CONTROL LIST
         EVALSYM &NAME&INDEX
         IF &LASTCC > 0 THEN +
            DO
               NOTE 'SYMBOL ''&NAME&INDEX'' IS NOT DEFINED'
               GOTO GETOUT
            END
         DROPSYM *
         NOTE 'RCE''S WILL BE DISPLAYED FOR &NAME&INDEX'
         NOTE '====== TASK RLE/RCE CHAIN ============================'
         EQUATE RLESTART &NAME&INDEX+8 LENGTH(4) POINTER
         EVALSYM RLESTART CLIST(ADDRESS(A) POSITION(P) DECIMAL)
         SET &RLESTART = &A + &P
         RUNCHAIN ADDRESS(RLESTART%) +
            LENGTH(X'C') STRUCTURE(#RLEDS) +
            EXEC((RLE &PRINT &TERMINAL &DEBUG)) +
            NULL(&RLESTART) NAME(#RLEDS) LINK(X'00') +
            CHAIN(100) DROP NOVERIFY
         NOTE '====== PROGRAM RLE/RCE CHAIN ========================='
         EQUATE RLESTART &NAME&INDEX+10 LENGTH(4) POINTER
         EVALSYM RLESTART CLIST(ADDRESS(A) POSITION(P) DECIMAL)
         SET &RLESTART = &A + &P
         RUNCHAIN ADDRESS(RLESTART%) +
            LENGTH(X'C') STRUCTURE(#RLEDS) +
            EXEC((RLE &PRINT &TERMINAL &DEBUG)) +
            NULL(&RLESTART) NAME(#RLEDS) LINK(X'00') +
            CHAIN(100) DROP NOVERIFY
         NOTE '====== SCRATCH RLE/RCE CHAIN ========================='
         EQUATE RLESTART &NAME&INDEX+18 LENGTH(4) POINTER
         EVALSYM RLESTART CLIST(ADDRESS(A) POSITION(P) DECIMAL)
         SET &RLESTART = &A + &P
         RUNCHAIN ADDRESS(RLESTART%) +
            LENGTH(X'C') STRUCTURE(#RLEDS) +
            EXEC((RLE &PRINT &TERMINAL &DEBUG)) +
            NULL(&RLESTART) NAME(#RLEDS) LINK(X'00') +
            CHAIN(100) DROP NOVERIFY
         NOTE '====== QUEUE RLE/RCE CHAIN ==========================='
         EQUATE RLESTART &NAME&INDEX+20 LENGTH(4) POINTER
         EVALSYM RLESTART CLIST(ADDRESS(A) POSITION(P) DECIMAL)
         SET &RLESTART = &A + &P
         RUNCHAIN ADDRESS(RLESTART%) +
            LENGTH(X'C') STRUCTURE(#RLEDS) +
            EXEC((RLE &PRINT &TERMINAL &DEBUG)) +
            NULL(&RLESTART) NAME(#RLEDS) LINK(X'00') +
            CHAIN(100) DROP NOVERIFY
GETOUT:  NOTE ' '
         END
/*-------------------------------------------------------------------*/
./       ADD   TCESTAT
/* THIS CLIST DISPLAYS THE CONTENTS OF THE VARIOUS FLAGS IN THE TCE. */
/* TO USE THIS CLIST, YOU MUST SUPPLY THE SUFFIX OF THE IPCS SYMBOL  */
/* NAME OF THE PARTICULAR TCE CONTROL BLOCK THAT YOU ARE INTERESTED  */
/* IN.  A SAMPLE CALL MIGHT BE "TCESTAT INDEX(04)".  THE "INIT"      */
/* CLIST MUST BE EXECUTED BEFORE EXECUTING THIS CLIST.               */
/*                                                                   */
         PROC 0 PRINT TERMINAL DEBUG INDEX() NAME(#TCEDS)
         IF &DEBUG = DEBUG THEN CONTROL LIST
         EVALSYM EQ &NAME&INDEX
         IF &LASTCC = 0 THEN +
            NOTE 'THE FOLLOWING NOTES ARE FOR CONTROL BLOCK &NAME&INDEX'
         ELSE +
            DO
               NOTE 'THE SYMBOL''&NAME&INDEX'' WAS NOT FOUND'
               GOTO GETOUT
            END
/* GET THE TASK NUMBER */
         EVALUATE &NAME&INDEX+4 LENGTH(4) UNSIGNED CLIST(STORAGE(S))
         NOTE 'THE TASK NUMBER IS &S'
/* GET THE CURRENT PROGRAM */
         EQUATE PDETEMP &NAME&INDEX+2C LENGTH(4) POINTER
         COMPARE ADDRESS(PDETEMP) LENGTH(4) +
            WITH(VALUE(X'00000000')) LENGTH(4) MASK(X'00FFFFFF')
         IF &LASTCC ¬= 0 THEN +
            DO
               EQUATE TCETEMP &NAME&INDEX+2C% LENGTH(4) POINTER
               EQUATE PDETEMP TCETEMP+10% LENGTH(8) CHARACTER SCALAR
               EVALUATE PDETEMP CLIST(STORAGE(S))
               NOTE 'THE CURRENT PROGRAM IS &S'
               EVALUATE PDETEMP+8 LENGTH(2) UNSIGNED SCALAR +
                  CLIST(STORAGE(S))
               NOTE 'THE CURRENT PROGRAM VERSION IS &S'
            END
/* GET THE EXTERNAL ABEND CODE */
         EVALUATE &NAME&INDEX+40 LENGTH(4) CHARACTER CLIST(STORAGE(S))
         NOTE 'THE EXTERNAL ABEND CODE IS &S'
/* GET THE LAST CALL TRACE WORD */
         EVALUATE &NAME&INDEX+48 LENGTH(4) BIT CLIST(STORAGE(S))
         NOTE 'THE LAST CALL TRACE WORD IS X''&S'''
/* GET THE USER INFORMATION */
         EQUATE SONTEMP &NAME&INDEX+58 LENGTH(4) POINTER
         COMPARE ADDRESS(SONTEMP) LENGTH(4) +
            WITH(VALUE(X'00000000')) LENGTH(4) MASK(X'00FFFFFF')
         IF &LASTCC ¬= 0 THEN +
            DO
               EQUATE TCETEMP &NAME&INDEX+58% LENGTH(4) POINTER
               EQUATE SONTEMP TCETEMP+C% LENGTH(8) CHARACTER SCALAR
               EVALUATE SONTEMP+1 LENGTH(32) +
                  CHARACTER SCALAR CLIST(STORAGE(S))
               NOTE 'THE USER FOR THIS TASK IS &S'
               EVALUATE SONTEMP+21 LENGTH(1) +
                  UNSIGNED SCALAR CLIST(STORAGE(S))
               NOTE 'THE USER''S PRIORITY IS &S'
            END
/* GET THE ACTIVE TASK CODE */
         COMPARE ADDRESS(&NAME&INDEX+70) LENGTH(4) POINTER +
            WITH(VALUE(X'00000000')) LENGTH(4) MASK(X'00FFFFFF')
         IF &LASTCC ¬= 0 THEN +
            DO
               EVALUATE &NAME&INDEX+70% LENGTH(8) CHARACTER +
                  CLIST(STORAGE(S))
               NOTE 'THE TASK CODE WAS &S'
            END
/* CHECK THE AMODE OF THE CURRENT PROGRAM */
         COMPARE ADDRESS(&NAME&INDEX+83) LENGTH(1) BIT +
            WITH(VALUE(X'00')) LENGTH(1)
         IF &LASTCC = 0 THEN +
            NOTE 'THE AMODE OF THE CURRENT PROGRAM IS 24'
         ELSE +
            NOTE 'THE AMODE OF THE CURRENT PROGRAM IS 31'
/* CHECK FOR USER MODE OR SYSTEM MODE */
         EQUATE TCETEMP &NAME&INDEX+84 LENGTH(1) BIT
         COMPARE ADDRESS(TCETEMP) LENGTH(1) +
            WITH(VALUE(X'10')) LENGTH(1) MASK(X'10')
         IF &LASTCC = 0 THEN +
            NOTE 'THE TASK IS CURRENTLY IN USER MODE'
         ELSE +
            NOTE 'THE TASK IS CURRENTLY IN SYSTEM MODE'
/* CHECK FOR ABENDING TASK */
         COMPARE ADDRESS(TCETEMP) LENGTH(1) +
            WITH(VALUE(X'08')) LENGTH(1) MASK(X'08')
         IF &LASTCC = 0 THEN +
            NOTE 'THE TASK IS CURRENTLY ABENDING'
         ELSE +
            NOTE 'THE TASK IS NOT CURRENTLY ABENDING'
/* CHECK FOR INACTIVE TASK */
         COMPARE ADDRESS(TCETEMP) LENGTH(1) +
            WITH(VALUE(X'04')) LENGTH(1) MASK(X'04')
         IF &LASTCC = 0 THEN +
            NOTE 'THE TASK EXCEEDED ITS INACTIVE INTERVAL'
/* CHECK FOR RUNAWAY TASK */
         COMPARE ADDRESS(TCETEMP) LENGTH(1) +
            WITH(VALUE(X'02')) LENGTH(1) MASK(X'02')
         IF &LASTCC = 0 THEN +
            NOTE 'THE TASK EXCEEDED ITS RUNAWAY INTERVAL'
/* CHECK FOR ERUS/ONLINE TASK */
         COMPARE ADDRESS(TCETEMP) LENGTH(1) +
            WITH(VALUE(X'01')) LENGTH(1) MASK(X'01')
         IF &LASTCC = 0 THEN +
            NOTE 'THE TASK IS AN ERUS TASK'
         ELSE +
            NOTE 'THE TASK IS AN ONLINE TASK'
/* CHECK FOR DRIVER TASK */
         EQUATE TCETEMP &NAME&INDEX+85 LENGTH(1) BIT
         COMPARE ADDRESS(TCETEMP) LENGTH(1) +
            WITH(VALUE(X'04')) LENGTH(1) MASK(X'04')
         IF &LASTCC = 0 THEN +
            NOTE 'THE TASK IS A DRIVER TASK'
/* CHECK FOR FACTOTUM TASK */
         COMPARE ADDRESS(TCETEMP) LENGTH(1) +
            WITH(VALUE(X'01')) LENGTH(1) MASK(X'01')
         IF &LASTCC = 0 THEN +
            NOTE 'THE TASK IS A FACTOTUM TASK'
/* CHECK FOR DRIVER TASK */
         EQUATE TCETEMP &NAME&INDEX+86 LENGTH(1) BIT
         COMPARE ADDRESS(TCETEMP) LENGTH(1) +
            WITH(VALUE(X'10')) LENGTH(1) MASK(X'10')
         IF &LASTCC = 0 THEN +
            NOTE 'THE TASK IS A PRINTER TASK'
/* CHECK FOR DRIVER TASK */
         COMPARE ADDRESS(TCETEMP) LENGTH(1) +
            WITH(VALUE(X'04')) LENGTH(1) MASK(X'04')
         IF &LASTCC = 0 THEN +
            NOTE 'THE TASK HAS DEADLOCKED'
/* CHECK FOR UCF PRINT CONTROLLER TASK */
         COMPARE ADDRESS(TCETEMP) LENGTH(1) +
            WITH(VALUE(X'02')) LENGTH(1) MASK(X'02')
         IF &LASTCC = 0 THEN +
            NOTE 'THE TASK IS THE UCF PRINT CONTROLLER TASK'
/* CHECK FOR ROLLBACK IN PROGRESS */
         COMPARE ADDRESS(TCETEMP) LENGTH(1) +
            WITH(VALUE(X'01')) LENGTH(1) MASK(X'01')
         IF &LASTCC = 0 THEN +
            NOTE 'THE TASK IS CURRENTLY PERFORMING A ROLLBACK'
/* CHECK FOR TASK STORAGE LOCATION */
         EQUATE TCETEMP &NAME&INDEX+87 LENGTH(1) BIT
         COMPARE ADDRESS(TCETEMP) LENGTH(1) +
            WITH(VALUE(X'20')) LENGTH(1) MASK(X'20')
         IF &LASTCC = 0 THEN +
            NOTE 'THE TASK STORAGE LOCATION IS ANY'
         ELSE +
            NOTE 'THE TASK STORAGE LOCATION IS BELOW'
/* CHECK FOR TIMEOUT ABEND PENDING */
         COMPARE ADDRESS(TCETEMP) LENGTH(1) +
            WITH(VALUE(X'04')) LENGTH(1) MASK(X'04')
         IF &LASTCC = 0 THEN +
            NOTE 'A TIMEOUT ABEND IS PENDING'
/* CHECK FOR QUEUE ATTACHED TASK */
         COMPARE ADDRESS(TCETEMP) LENGTH(1) +
            WITH(VALUE(X'01')) LENGTH(1) MASK(X'01')
         IF &LASTCC = 0 THEN +
            NOTE 'THIS IS A QUEUE-ATTACHED TASK'
/* CHECK FOR RLE THRESHOLD EXCEEDED */
         EQUATE TCETEMP &NAME&INDEX+88 LENGTH(1) BIT
         COMPARE ADDRESS(TCETEMP) LENGTH(1) +
            WITH(VALUE(X'80')) LENGTH(1) MASK(X'80')
         IF &LASTCC = 0 THEN +
            NOTE 'THE TASK BROKE THE RLE THRESHOLD'
/* CHECK FOR RCE THRESHOLD EXCEEDED */
         COMPARE ADDRESS(TCETEMP) LENGTH(1) +
            WITH(VALUE(X'40')) LENGTH(1) MASK(X'40')
         IF &LASTCC = 0 THEN +
            NOTE 'THE TASK BROKE THE RCE THRESHOLD'
/* CHECK FOR DPE THRESHOLD EXCEEDED */
         COMPARE ADDRESS(TCETEMP) LENGTH(1) +
            WITH(VALUE(X'20')) LENGTH(1) MASK(X'20')
         IF &LASTCC = 0 THEN +
            NOTE 'THE TASK BROKE THE DPE THRESHOLD'
/* CHECK FOR ILE THRESHOLD EXCEEDED */
         COMPARE ADDRESS(TCETEMP) LENGTH(1) +
            WITH(VALUE(X'10')) LENGTH(1) MASK(X'10')
         IF &LASTCC = 0 THEN +
            NOTE 'THE TASK BROKE THE ILE THRESHOLD'
/* CHECK FOR HELOT TASK */
         COMPARE ADDRESS(TCETEMP) LENGTH(1) +
            WITH(VALUE(X'01')) LENGTH(1) MASK(X'01')
         IF &LASTCC = 0 THEN +
            NOTE 'THIS IS A HELOT TASK'
/* CHECK FOR SERVICE DRIVER TASK */
         EQUATE TCETEMP &NAME&INDEX+89 LENGTH(1) BIT
         COMPARE ADDRESS(TCETEMP) LENGTH(1) +
            WITH(VALUE(X'80')) LENGTH(1) MASK(X'80')
         IF &LASTCC = 0 THEN +
            NOTE 'THIS IS A SERVICE DRIVER TASK'
/* CHECK FOR DB I/O DRIVER TASK */
         COMPARE ADDRESS(TCETEMP) LENGTH(1) +
            WITH(VALUE(X'08')) LENGTH(1) MASK(X'08')
         IF &LASTCC = 0 THEN +
            NOTE 'THIS IS A DB I/O DRIVER TASK'
/* CHECK FOR JOURNAL DRIVER TASK */
         COMPARE ADDRESS(TCETEMP) LENGTH(1) +
            WITH(VALUE(X'04')) LENGTH(1) MASK(X'04')
         IF &LASTCC = 0 THEN +
            NOTE 'THIS IS A JOURNAL DRIVER TASK'
/* CHECK FOR DB I/O TASK */
         COMPARE ADDRESS(TCETEMP) LENGTH(1) +
            WITH(VALUE(X'02')) LENGTH(1) MASK(X'02')
         IF &LASTCC = 0 THEN +
            NOTE 'THIS IS DB I/O TASK'
/* CHECK FOR DB I/O READ DRIVER TASK */
         COMPARE ADDRESS(TCETEMP) LENGTH(1) +
            WITH(VALUE(X'01')) LENGTH(1) MASK(X'01')
         IF &LASTCC = 0 THEN +
            NOTE 'THIS IS DB I/O READ DRIVER TASK'
/* GET THE TOTAL LOCKS COUNT */
         EVALUATE &NAME&INDEX+C4 LENGTH(4) UNSIGNED CLIST(STORAGE(S))
         NOTE 'TOTAL LOCKS AS OF LAST DBMS CALL IS &S'
/* GET THE SELECT LOCKS COUNT */
         EVALUATE &NAME&INDEX+C8 LENGTH(4) UNSIGNED CLIST(STORAGE(S))
         NOTE 'SELECT LOCKS AS OF LAST DBMS CALL IS &S'
/* GET THE UPDATE LOCKS COUNT */
         EVALUATE &NAME&INDEX+CC LENGTH(4) UNSIGNED CLIST(STORAGE(S))
         NOTE 'UPDATE LOCKS AS OF LAST DBMS CALL IS &S'
/* GET THE CURRENT STORAGE OWNED BY TASK */
         EVALUATE &NAME&INDEX+D0 LENGTH(4) UNSIGNED CLIST(STORAGE(S))
         NOTE 'CURRENT STORAGE OWNED BY TASK IS &S'
/* GET NUMBER OF RCES IN USE */
         EVALUATE &NAME&INDEX+128 LENGTH(4) UNSIGNED CLIST(STORAGE(S))
         NOTE 'NUMBER OF RCE''S IN USE IS &S'
/* GET NUMBER OF RLES IN USE */
         EVALUATE &NAME&INDEX+12C LENGTH(4) UNSIGNED CLIST(STORAGE(S))
         NOTE 'NUMBER OF RLE''S IN USE IS &S'
/* GET NUMBER OF DPES IN USE */
         EVALUATE &NAME&INDEX+130 LENGTH(4) UNSIGNED CLIST(STORAGE(S))
         NOTE 'NUMBER OF DPE''S IN USE IS &S'
/* GET NUMBER OF ILES IN USE */
         EVALUATE &NAME&INDEX+148 LENGTH(4) UNSIGNED CLIST(STORAGE(S))
         NOTE 'NUMBER OF ILE''S IN USE IS &S'
GETOUT:  DROPSYM (TCETEMP PDETEMP SONTEMP)
/*-------------------------------------------------------------------*/
./       ADD   TCETASK
/* THIS CLIST IS INVOKED BY THE "TASKS" CLIST TO DISPLAY A LIST OF   */
/* TASKS CURRENTLY EXECUTING UNDER CV AT THE TIME OF THE DUMP.       */
/* INFORMATION IS GATHERED FROM THE DCE, TCE, LTE, AND PTE CONTROL   */
/* BLOCKS AND THEN IS  DISPLAYED TO THE TERMINAL.                    */
/*                                                                   */
         PROC 0 PRINT TERMINAL DEBUG
         IF &DEBUG = DEBUG THEN CONTROL LIST
         EQUATE DCEPTR X LENGTH(4) AREA SCALAR
         EVALSYM < @RHDCOS00 CLIST(SYMBOL(S))
         IF &SUBSTR(1:5,&S) ¬= &STR(#DCEX) THEN +
            DO WHILE &SUBSTR(1:5,&S) ¬= &STR(#DCEX)
               EVALSYM < &S CLIST(SYMBOL(S))
               IF &LASTCC > 0 THEN GOTO GETOUT
            END
         SET &SUFFIX = &SUBSTR(6:7,&S)
         COMPARE ADDRESS(DCEPTR+8%) LENGTH(4) +
            WITH(VALUE(C'TCE*')) LENGTH(4)
         IF &LASTCC = 0 THEN +
            DO
               EQUATE #TCEX&SUFFIX DCEPTR+8% STRUCTURE(#TCEDS) +
                  LENGTH(X'E10') SCALAR DROP
/* --- DCE FIELDS -------------------------------------------------- */
/* GET THE DISPATCHING PRIORITY */
         EVALUATE #DCEX&SUFFIX+24 LENGTH(1) UNSIGNED +
            CLIST(STORAGE(S))
         SET &T = &STR(&S    )
         SET &PRIOR = &SUBSTR(1:4,&T)
         EQUATE DCETEMP #DCEX&SUFFIX+25 LENGTH(1) BIT
/* CHECK FOR TASK CURRENTLY EXECUTING */
         COMPARE ADDRESS(DCETEMP) LENGTH(1) +
            WITH(VALUE(X'20')) LENGTH(1) MASK(X'20')
         IF &LASTCC = 0 THEN +
            SET &ACTV = &STR(INACTIVE)
         ELSE +
            SET &ACTV = &STR(ACTIVE  )
/* CHECK FOR NEW TASK */
         COMPARE ADDRESS(DCETEMP) LENGTH(1) +
            WITH(VALUE(X'02')) LENGTH(1) MASK(X'02')
         IF &LASTCC = 0 THEN +
            SET &ACTV = &STR(NEW TASK)
/* --- TCE FIELDS -------------------------------------------------- */
         EVALUATE #TCEX&SUFFIX+4 LENGTH(4) UNSIGNED +
            CLIST(STORAGE(S))
         SET &T = &STR(&S        )
         SET &TASKNBR = &SUBSTR(1:8,&T)
/* GET THE CURRENT PROGRAM */
         EQUATE PDETEMP #TCEX&SUFFIX+2C LENGTH(4) POINTER
         COMPARE ADDRESS(PDETEMP) LENGTH(4) +
            WITH(VALUE(X'00000000')) LENGTH(4) MASK(X'00FFFFFF')
         IF &LASTCC ¬= 0 THEN +
            DO
               EQUATE TCETEMP #TCEX&SUFFIX+2C% LENGTH(4) POINTER
               EQUATE PDETEMP TCETEMP+10% LENGTH(8) CHARACTER SCALAR
               EVALUATE PDETEMP CLIST(STORAGE(PGMNAME))
            END
         ELSE SET &PGMNAME = &STR(        )
/* GET THE EXTERNAL ABEND CODE */
         EVALUATE #TCEX&SUFFIX+40 LENGTH(4) CHARACTER +
            CLIST(STORAGE(ABRT))
/* GET THE USER INFORMATION */
         EQUATE SONTEMP #TCEX&SUFFIX+58 LENGTH(4) POINTER
         COMPARE ADDRESS(SONTEMP) LENGTH(4) +
            WITH(VALUE(X'00000000')) LENGTH(4) MASK(X'00FFFFFF')
         IF &LASTCC ¬= 0 THEN +
            DO
               EQUATE TCETEMP #TCEX&SUFFIX+58% LENGTH(4) POINTER
               EQUATE SONTEMP TCETEMP+C% LENGTH(8) CHARACTER SCALAR
               EVALUATE SONTEMP+1 LENGTH(32) +
                  CHARACTER SCALAR CLIST(STORAGE(USERID))
            END
         ELSE SET &USERID = &STR(                                )
/* GET THE ACTIVE TASK CODE */
         COMPARE ADDRESS(#TCEX&SUFFIX+70) LENGTH(4) POINTER +
            WITH(VALUE(X'00000000')) LENGTH(4) MASK(X'00FFFFFF')
         IF &LASTCC ¬= 0 THEN +
            DO
               EVALUATE #TCEX&SUFFIX+70% LENGTH(8) CHARACTER +
                  CLIST(STORAGE(TASKCDE))
            END
         ELSE SET &TASKCDE = &STR(        )
/* CHECK FOR FACTOTUM TASK */
         EQUATE TCETEMP #TCEX&SUFFIX+85 LENGTH(1) BIT
         COMPARE ADDRESS(TCETEMP) LENGTH(1) +
            WITH(VALUE(X'01')) LENGTH(1) MASK(X'01')
         IF &LASTCC = 0 THEN +
            SET &TASKCDE = &STR(FACTOTUM)
/* CHECK FOR HELOT TASK */
         EQUATE TCETEMP #TCEX&SUFFIX+88 LENGTH(1) BIT
         COMPARE ADDRESS(TCETEMP) LENGTH(1) +
            WITH(VALUE(X'01')) LENGTH(1) MASK(X'01')
         IF &LASTCC = 0 THEN +
            SET &TASKCDE = &STR(HELOT   )
/* --- LTE FIELDS -------------------------------------------------- */
/* GET ADDRESSABILITY TO THE LTE */
         COMPARE ADDRESS(#TCEX&SUFFIX+4C) LENGTH(4) +
            WITH(VALUE(X'00000000')) LENGTH(4) MASK(X'0FFFFFFF')
         IF &LASTCC ¬= 0 THEN +
            DO
               EQUATE #LTEX&SUFFIX #TCEX&SUFFIX+4C% +
                  STRUCTURE(#LTEDS) LENGTH(X'100') +
                  SCALAR DROP
/* GET THE LTERM NAME */
         EVALUATE #LTEX&SUFFIX+0 LENGTH(8) CHARACTER +
            CLIST(STORAGE(LTERM))
/* GET THE USER INFORMATION */
         EQUATE SONTEMP #LTEX&SUFFIX+20 LENGTH(4) POINTER
         COMPARE ADDRESS(SONTEMP) LENGTH(4) +
            WITH(VALUE(X'00000000')) LENGTH(4) MASK(X'00FFFFFF')
         IF &LASTCC ¬= 0 THEN +
            DO
               EQUATE LTETEMP #LTEX&SUFFIX+20% LENGTH(4) POINTER
               EQUATE SONTEMP LTETEMP+C% LENGTH(8) CHARACTER SCALAR
               EVALUATE SONTEMP+1 LENGTH(32) +
                  CHARACTER SCALAR CLIST(STORAGE(USERID))
            END
/* GET DEFAULT DBNAME */
         EVALUATE #LTEX&SUFFIX+B4 LENGTH(8) CHARACTER +
            CLIST(STORAGE(DBNAME))
/* GET DEFAULT DICTNAME */
         EVALUATE #LTEX&SUFFIX+CC LENGTH(8) CHARACTER +
            CLIST(STORAGE(DICTNME))
/* --- PTE FIELDS -------------------------------------------------- */
/* GET ADDRESSABILITY TO THE PTE */
         EQUATE #PTEX&SUFFIX #LTEX&SUFFIX+8% +
            STRUCTURE(#PTEDS) LENGTH(X'110') +
            SCALAR DROP
/* GET THE PTERM NAME */
         EVALUATE #PTEX&SUFFIX+0 LENGTH(8) CHARACTER +
            CLIST(STORAGE(PTERM))
         EQUATE PTETEMP #PTEX&SUFFIX+8% LENGTH(4) POINTER
/* GET THE LINE TYPE */
         EVALUATE PTETEMP+40 LENGTH(1) CHARACTER CLIST(STORAGE(R))
/* GET INFORMATION FOR UCF PTERMS */
         IF &R = &STR(Z) THEN +
            DO
            /* GET FRONT END TERMINAL ID */
               EVALUATE #PTEX&SUFFIX+B8 LENGTH(8) CHARACTER +
                  CLIST(STORAGE(TERMID))
            /* GET FRONT END SYSTEM ID */
               EVALUATE #PTEX&SUFFIX+C0 LENGTH(8) CHARACTER +
                  CLIST(STORAGE(FESID))
            END
         ELSE +
            DO
               SET &TERMID = &STR(        )
               SET &FESID = &STR(        )
            END
                  END
               ELSE +
                  DO
                     SET &LTERM = &STR(        )
                     SET &DBNAME = &STR(        )
                     SET &DICTNME = &STR(        )
                     SET &PTERM = &STR(        )
                     SET &TERMID = &STR(        )
                     SET &FESID = &STR(        )
                  END
               SET &T1 = &STR(&SUFFIX &TASKNBR &TASKCDE &PRIOR &ACTV)
               SET &T2 = &STR(&PGMNAME &ABRT &TERMID &LTERM &DBNAME)
               SET &T3 = &STR(&DICTNME &USERID)
               NOTE '&T1 &T2 &T3'
            END
GETOUT:  SET &SUFFIX = &STR(00)
         END
/*-------------------------------------------------------------------*/
****** THIS IS THE END OF THIS FILE.  THERE ARE NO MORE MEMBERS. ******
