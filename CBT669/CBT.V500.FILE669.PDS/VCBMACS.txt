*-
* VCBMACS
* Macros for handling local memory structure.
* Storage areas can be added, updated, deleted and searched.
* Each area is named.
*
*  Sample
*        VCBGlobal anchor=f.VCBa,subbase=r11,keepnum=30,keepmaxw=1024
*        . .
*        VCBAACQ init=y,anchorr=r8
*        st    r8,VCBa
*        . .
*        la    r2,6
*        VCBPut name=(name,(r2)),data=((r6),(r4))
*        . .
*        la    r2,name
*        la    r3,6
*        VCBGet name=((r2),(r3)),data=data
*        . .
*        VCBCall Drop
*        . .
*  name  dc  c20'KILROY'
*  data  dc  cl200' '
*        . .
*        VCBANCHR dsect=yes
*        VCBmodul
*        VCB   ,   dsect
*
* Updates
*  2016-01-11 VCBscan fix handling of 'all'
*  2016-08-12 Fix updates of fields VCBAaqn and VCBAfqn
*  2017-09-08 Load of changes to make VCB reentrant
*             Reverse order of len,addr parameters for VCBLOCATE
*             New macro VCBGET
*             VCBSCAN is disabled
*  2018-08-04 'C,rx,eq=a(n)' changed to 'CLFI,rx,eq,n)'
*  2018-11-01 add 'subbase' to globals, change VCBENTRY accordingly.
*  2018-11-05 add function 'VCBDELAL' - delete all entries in a pool.
*             change VCBDEL, only move VCB to free if size le 4k.
*  2018-12-19 add macro VCBAACQ for getmain and init of anchor
*  2019-01-15 use macro STRC2X instead of CVXD.
*  2019-06-17 add LOC=31 to all STORAGE OBTAIN
*
* Author
*     Willy Jensen
*     mail: willy@harders-jensen.com
*     web : http://harders-jensen.com/wjtech/index.html
*-

* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
*        VCBGLOBAL   : set globals                                    *
* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
         Macro
         VCBGLOBAL &anchor=,&trace=N,&subbase=,&keepnum=,&keepmaxw=,   c
               &sp=131
         gblc  &$$vcbanchor,&$$vcbtrace,&VCBsubbase
         gblc  &$$vcbkeepnum,&$$vcbkeepmaxw,&$$vcbsp
&$$vcbanchor   setc '&anchor'
&$$vcbtrace    setc '&trace'
&VCBsubbase    setc '&subbase'
&$$vcbkeepnum  setc '&keepnum'
&$$vcbkeepmaxw setc '&keepmaxw'
&$$vcbsp       setc '&sp'
 mnote *,'VCB globals: anchor=&$$vcbanchor trace=&$$vcbtrace subbase=&V+
               CBsubbase sp=&$$vcbsp'
         Mend

* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
*        VCBCALL     : Call VCB routine                               *
* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
         Macro
         VCBCALL &mod,&anchor=,&name=,&data=,&parmlist=
         gblc  &$$vcbanchor,&gblsetpc
         lclc  &l,&s,&lanchr
         lcla  &n,&p
         aif   (k'&mod ne 0).modn
         mnote 8,'*** modname (parm 1) missing'
         mexit
.modn    anop
         VCBsetgp C,&anchor,&$$vcbanchor
         aif   (k'&gblsetpc ne 0).anchr1
         mnote 8,'*** VCBCALL Anchor not defined'
         mexit
.anchr1  anop
&lanchr  setc  '&gblsetpc'
&l       setc  'VCB&sysndx'
         aif   (k'&parmlist eq 0 and k'&name eq 0                      c
               and k'&data eq 0).call
         $la   r1,&lanchr
         la    r1,VCBAcpl-VCBAnchr(,r1) -> call parameter list
         aif   (k'&parmlist ne 0).prmlst   superceedes name/data
         aif   (k'&name gt 0 and k'&data gt 0).ndsetb
         aif   (k'&name gt 0 and k'&data eq 0).ndsetn
         aif   (k'&name eq 0 and k'&data gt 0).ndsetd
         ago   .call
.ndsetb  anop
*name
         $la   r14,&name(1)            address
         $la   r15,&name(2)            length
         stm   r14,r15,0(r1)           save
*data
         $la   r14,&data(1)            address
         $la   r15,&data(2)            length
         stm   r14,r15,8(r1)           save
         ago   .call
.ndsetn  anop
*name
         $la   r14,&name(1)
         $la   r15,&name(2)
         stm   r14,r15,0(r1)           save
         ago   .call
.ndsetd  anop
*data
         $la   r14,&data(1)
         $la   r15,&data(2)
         stm   r14,r15,0(r1)           save
         ago   .call
.prmlst  anop  ,
*parmlist
&n       seta  &n+1
         aif   (&n gt n'&parmlist).prmlstn
&l       setc  '&parmlist(&n)'
         $la   r14,&l
         st    r14,&p.(,r1)
&p       seta  &p+4
         ago   .prmlst
.prmlstn anop
         oi    VCBAcpl+&p,x'80'         set VL flag
.call    anop
         $la   r0,&lanchr              -> VCB anchor
&s       setc  Upper('&mod')
         aif   ('&s   '(1,3) eq 'VCB').call2
         l     r15,=V(VCB&mod)
         ago   .callx
.call2   l     r15,=V(&mod)
.callx   basr  r14,r15
         ltr   r15,r15
         Mend

* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
*        VCBSETGP  subroutine, set parameter                          *
* syntax: what,parm1,parm2,..,parmn                                   *
* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
         Macro
         VCBSETGP
         gblc  &gblsetpc
         gbla  &gblsetpa
         lcla  &n
         lclc  &p,&s
&gblsetpc  setc  ''
&gblsetpa  seta  0
&s       setc  Upper('&syslist(1)')
         aif   ('&s' eq 'A' or '&s' eq 'C').typeok
         mnote 8,'** Invalid 1st operand, must be A or C'
         mexit
.typeok  anop
&n       seta  1
.a       anop
&n       seta  &n+1
&p       setc  '&syslist(&n)'
         aif   (k'&p ne 0 and '&s' eq 'A').seta
         aif   (k'&p ne 0 and '&s' eq 'C').setc
         aif   (&n lt n'&syslist).a
         mexit
.seta    anop
&gblsetpa seta  &p
         mexit
.setc    anop
&gblsetpc setc  '&p'
         mexit
         Mend

* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
*        VCBENTRY  subroutine entry                                   *
* r0 -> Anchor                                                        *
* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
         MACRO
&name    VCBEntry &BASE=,&ANCHORR=
         gblc  &VCBsubname,&VCBsubbase,&VCBentbase
         gblc  &$$vcbsave,&VCBanchrr
         mnote *,'save: &$$vcbsave'
         lclc  &pgm,&l,&lbase
&l       setc  '$$&sysndx'
&pgm     setc  (UPPER '&name')
&VCBsubname setc '&pgm'
&VCBanchrr  setc '&anchorr'
         ds    0d
&lbase   setc  '&base'
         aif   (k'&lbase ne 0).basen
&lbase   setc  '&VCBsubbase'
         aif   (k'&lbase ne 0).basen
&lbase   setc  'r12'
.basen   anop
&VCBentbase setc '&lbase'
         using &pgm,&lbase
         using VCBanchr,&anchorr
.* &pgm  $$modes
&pgm     Amode 31
&pgm     Rmode any
&pgm     Csect
         bakr  14,0                    save callers status on stack
         lr    &lbase,r15
         lr    &anchorr,r0
         la    r15,VCBAsan             end of save areas
         la    r13,VCBAsa1             locate free save area
         do    forever
           if    (cli,0(r13),eq,0),then=leave  free
           la    r13,72(,r13)          -> next
           if    (cr,r13,ge,r15)       overflow?
             ABEND 401,DUMP
           endif
         enddo
         mvi   0(r13),255              set 'in use'
         clear VCBAtrrec
         VCBtrcX '&pgm begin'
         Ereg  0,1
.x       MEND

* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
*        VCBEXIT  subroutine exit                                     *
* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
         MACRO
&name    VCBExit  &RC=,&R1=r1,&SAC=,&trace=Y
.* trace=y is to allow trace, not neccessarily do it
         lclc  &pgm,&l,&p1,&u
         gblc  &VCBsubname,&VCBentbase,&VCBanchrr
&pgm     setc  '&VCBsubname'
&l       setc  '$$&sysndx'
&name    Cnop  0,4
         aif   (K'&sac eq 0).sac99
&p1      setc  (UPPER '&sac')
         aif   ('&p1' eq 'OFF').sacoff
         sac   &sac
         ago   .sac99
.sacoff  sac   0
.sac99   anop
.back    anop
         aif   ('&trace' ne 'Y').trcn
         VCBtrcX '&pgm exit'
.trcn    anop
         aif   (K'&RC eq 0).rcn
         $la   r15,&RC
.rcn     anop
         mvi   0(r13),0                mark savearea as free
         pr    ,
.tfinal  anop
&p1      setc  (UPPER '&syslist(1)')
         aif   (K'&p1 eq 0).x
         aif   ('&p1' eq 'FINAL').final
         mnote 8,'*Invalid 1st parm: &p1'
         ago   .x
.final   anop
         Ltorg
         ds    0d
         drop  &VCBentbase,&VCBanchrr
.x       MEND

* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
*              VCB   : data area map (dsect)                          *
* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
              Macro
              VCB  &prefix=VCB
&q            setc  (UPPER '&syslist(1)')
              aif  ('&q' EQ 'DSECT' or k'&q eq 0).dsect
              ago   .define
.dsect        anop
&prefix       dsect
.define       anop
.* Variable Container Block (VCB)
&prefix.fix   ds  0a
&prefix.next  ds  a                    -> next block
&prefix.prev  ds  a                    <- previous block
&prefix.size  ds  a                    size of block
&prefix.dataa ds  a                    address of data
.* keep namel and datal together and right before fixl
&prefix.rec   ds  0a                   start of external record
&prefix.namel ds  a                    length of variable name
&prefix.datal ds  a                    size of data
&prefix.fixl  equ *-&prefix.fix        length of fixed area
&prefix.var   equ *                    begin variable section
&prefix.name  ds  c                    name of variable
*VCBdata      ds  v                    start of data
              Mend

* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
*              VCBANCHR : anchor data block                           *
* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
             Macro
             VCBAnchr &DSECT=YES
             lclc  &s
&s           setc  Upper('&dsect')
             aif   ('&s' ne 'YES').dsectn
* VCB anchor block, pointed to by the Name/Token service
VCBAnchr     dsect
             ago   .dsectx
.dsectn      anop
VCBAnchr     ds   0a
.dsectx      anop
VCBAeye      ds   cl8                 name
VCBAflgs1    ds   x                   flags
VCBAtrace    equ  1                   trace
VCBArsv1     ds   xl3                 for future use
VCBAaqh      ds   a                   -> active queue head
VCBAaqt      ds   a                   -> active queue tail
VCBAaqn      ds   a                   number of elements on active que
VCBAfqh      ds   a                   -> free queue head
VCBAfqt      ds   a                   -> free queue tail
VCBAfqn      ds   a                   number of elements on free queue
VCBAmaxdl    ds   a                   max length of VCB data
VCBAcsrp     ds   a                   cursor (last_key) pointer
.* internal VCBs
             VCB  ds,prefix=VCBAH     Pseudo VCB: Head of active queue
             VCB  ds,prefix=VCBAT     Pseudo VCB: Tail of active queue
             VCB  ds,prefix=VCBFH     Pseudo VCB: Head of free queue
             VCB  ds,prefix=VCBFT     Pseudo VCB: Tail of free queue
VCBAuser     ds   4a                  for caller
VCBAcpl      ds   0d                  call parameter list
VCBAwrk      ds   5d                  some work (10 fullwords)
VCBAcpll     equ  *-VCBAcpl           parameter list size
VCBAvmaxnl   ds   a                   max length name
VCBAvmaxdl   ds   a                   max length data
VCBAvmaxndl  ds   a                   max length name+data
VCBAfw       ds   a                   internal work
VCBAdw       ds   d                   internal work
VCBAsa1      ds   18a                 savearea for module
VCBAsa2      ds   18a                 savearea for module
VCBAsa3      ds   18a                 savearea for module
VCBAsa4      ds   18a                 savearea for module
VCBAsan      equ  *                   savearea end
VCBAtrsa0    ds   18a                 savearea for trace
VCBAtrname   ds   cl9                 for internal tracing
VCBAtrrec    ds   cl160               for internal tracing
* work areas for VCBloc
VCBAlocsn    ds    cl(256)
VCBAlocvn    ds    cl(256)
* work areas for VCBFmtNd
VCBAFmtNdr   ds   cl150
             ds   0d
VCBAnchrl    equ  *-VCBAnchr          length
             Mend

* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
*              VCBAACQ  : Acquire storage                             *
* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
         Macro
&mlbl    VCBAACQ &init=no,&anchorr=
         lclc  &ar,&s
         gblc  &$$vcbanchor,&$$vcbsp
&mlbl    STORAGE OBTAIN,LENGTH=VCBAnchrl,SP=&$$vcbsp,CALLRKY=YES,loc=31
         aif   (k'&anchorr eq 0).arn
         lr    &anchorr,r1
         using VCBAnchr,&anchorr
.arn     anop
&s       setc  Upper('&init')
         aif   ('&s '(1,1) ne 'Y').initn
         VCBAinit
.initn   anop
.x       Mend

* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
*              VCBAINIT : Initialize anchor block                     *
* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
         Macro
         VCBAINIT &p1
         lclc  &what
         aif   (k'&p1 eq 0).all
&what    setc  Upper('&p1')
         aif   ('&what' eq 'ALL').all
         aif   ('&what' eq 'ACTIVE').act
         aif   ('&what' eq 'FREE').free
         mnote 8,*** Invalid parm &p1'
.all     anop
&ahat    setc  'ALL'
         la    r14,VCBAnchr            target address
         lr    r0,r14                  = source address
         la    r15,VCBAnchrl           target size
         sr    r1,r1                   source size and pad
         mvcl  r14,r0                  all binary zeroes
         mvc   VCBAeye,=cl8'VCBANCHR'
.act     anop
*setup active head
         la    r1,1
         st    r1,VCBAHnamel
         st    r1,VCBAHdatal
         la    r14,VCBAHfix
         st    r14,VCBAaqh
         st    r14,VCBAcsrp            cursor = first
         st    r14,VCBATprev           back ptr
*setup active tail
         la    r1,1
         st    r1,VCBATnamel           size=1
         st    r1,VCBATdatal           size=1
         mvi   VCBATname,X'FF'         tail name
         la    r14,VCBATfix
         st    r14,VCBAaqt
         st    r14,VCBAHnext           fwd ptr
         xc    VCBAaqn,VCBAaqn         count=0
         aif   ('&what' eq 'ACTIVE').x only active
.free    anop
*setup free head
         la    r1,1
         st    r1,VCBFHnamel           size=1
         st    r1,VCBFHdatal           size=1
         la    r14,VCBFHfix
         st    r14,VCBAfqh
         st    r14,VCBFTprev           back ptr
*setup free tail
         la    r1,1
         st    r1,VCBFTnamel
         st    r1,VCBFTdatal
         la    r14,VCBFTfix
         st    r14,VCBAfqt
         st    r14,VCBFHnext           fwd ptr
         xc    VCBAfqn,VCBAfqn         count=0
         aif   ('&what' eq 'FREE').x   only free
.x       Mend

* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
*              VCBHOOK  : set or update hook                          *
* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
         Macro
         VCBHOOK &vcb=,&csr=
.* hook work VCB onto chain
         lclc  &l,&q,&r1,&r2
&q       setc  (UPPER '&syslist(1)')
&r1      setc  (UPPER '&vcb')
&r2      setc  (UPPER '&csr')
         aif   ('&r1' ne 'R15' and '&r2' ne 'R15').onoff
         mnote 8,'R15 is used internally'
         mexit
.onoff   aif   ('&q' eq 'ON' ).on
         aif   ('&q' eq 'OFF').off
         mnote 8,'VCBHOOK invalid parm: &q'
         mexit
.on      anop
         l     r15,vcbnext-vcb(,&csr)    current next
         st    r15,vcbnext-vcb(,&vcb)    set fwd in new
         st    &csr,vcbprev-vcb(,&vcb)   set bwd in new
         st    &vcb,vcbnext-vcb(,&csr)   set fwd in current
         st    &vcb,vcbprev-vcb(,r15)    set bwd in next
         Mexit
.off     anop
         l     r15,vcbnext-vcb(,&vcb)    current next
         mvc   vcbprev-vcb(4,r15),vcbprev-vcb(&vcb)
         l     r15,vcbprev-vcb(,&vcb)    current prev
         mvc   vcbnext-vcb(4,r15),vcbnext-vcb(&vcb)
* beware of the system cursor
         if    (c,&vcb,eq,VCBAcsrp),then=(st,r15,VCBAcsrp)
         Mend

* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
*        VCBLOCATE: Find VCB with matching key                        *
* name=(address,length)                                               *
* returns if r15=0 then r1 -> VCB                                     *
* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
         Macro
         VCBLOCATE &name=,&anchor=
         lclc  &nd,&nl
&na      setc  '&name(1)'
&nl      setc  '&name(2)'
         gblc  &$$vcbanchor,&gblsetpc
         VCBsetgp C,&anchor,&$$vcbanchor
         VCBCall VCBLoc,name=(&na,&nl),anchor=&gblsetpc
         Mend

* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
*           VCBSCAN  : Scan the VCB chain for given key/prefix        *
* It will execute the 'onmatch' value when match is found, i.e.       *
* ONMATCH=(BAL,R4,GOTMATCH) and continue scan afterwards.             *
* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
         Macro
        zVCBSCAN &vcbr=r1,&varname=,&onmatch=,&testsub=,&anchor=,      c
               &generic='N'
         gblc  &VCBsubname,&subtrace,&gblsetpc
         lclc  &l,&m1,&m2,&m3,&tsub,&s,&va,&vl
.* varname=(length,address)
&va      setc  '&varname(1)'
&vl      setc  '&varname(2)'
&l       setc  'VSC&SYSNDX'
&m1      setc  '&onmatch(1)'
&m2      setc  '&onmatch(2)'
&m3      setc  '&onmatch(3)'
&tsub    setc  (UPPER '&testsub')
.*--
         if    (VCBAaqh,eq,VCBAcsrp)      no entries               0001
           sr    r15,r15                                           0001
           j     &l.X                                              0001
         endif                                                     0001
.*--
*List all
         $la   r2,&vl                     load length
         If    (ltr,r2,r2,z)              all?
           VCBtrcX 'VCBscan all'
           l     &vcbr,VCBAaqh
           Do    Until,(c,&vcbr,eq,VCBAaqt) until tail end
             if    (c,&vcbr,ne,VCBAaqh),then=(&m1,&m2,&m3)
             aif   ('&testsub' eq '').tsub10n
             bas   r14,&testsub
             if    (ltr,r15,r15,nz),then=leave
.tsub10n     anop
             l     &vcbr,VCBnext
           Enddo
           sr    r15,r15
           j     &l.X
         Endif
.*--
*List descrete varname = VCBLOC
         $la    r1,&generic
         If  (cli,0(r1),ne,c'Y')
           VCBtrcX 'VCBscan descrete = VCBLOC'
           $la   r14,&va                  name
           $la   r15,&vl                  length
           stm   r14,r15,VCBAclp
           la    r1,VCBAclp
           VCBsetgp C,&anchor,&gblsetpc
           VCBCall VCBLoc,anchor=&gblsetpc
           lr    &vcbr,r1
           if    (ltr,r15,r15,z),then=(&m1,&m2,&m3)
           j     &l.X
         Endif
.*--
*Must be search by generic name
         $la   r14,&vl                  length
         st    r14,VCBAfw
         bctr  r14,0                      as machine
         $la   r15,&va                  name
         stm   r14,r15,VCBAclp
         VCBtrcX begin
         l     r2,VCBAfw
         if    (clfi,r2,gt,20),then=(la,r2,20)
         StrMake  VCBAtrrec,'VCBscan generic ',                        c
               (VCBAfw,4,cvxd),' ',(&va,(r2)),reg=r3
         VCBtrcX end
         sr    r15,r15                  preset rc
         l     &vcbr,VCBAaqh            queue head
         l     &vcbr,VCBnext            first real VCB
         Do    While,(c,&vcbr,ne,VCBAaqt)  until tail
           l     r2,VCBnamel
           if    (clfi,r2,gt,20),then=(la,r2,20)
           VCBtrcX begin
           StrMake VCBAtrrec,'name: ',(VCBname,(r2)),' ',              c
               (VCBnamel,4,cvxd),reg=r3
           VCBtrcX end
           if    (clc,VCBAclp,le,VCBnamel)
             VCBtrcX 'length ok'
             lm    r14,r15,VCBAclp         mch length, address
             ex    r14,&l.C                check name against VCB
             if    (gt),then=leave         VCBname is high
             if    (eq)
               VCBtrcX 'name ok'
               &m1 &m2,&m3
               aif   ('&testsub' eq '').tsub20n
               if    (ltr,&testsub,&testsub,nz),then=leave
.tsub20n anop
             endif
           else
             VCBtrcX 'length not ok'
           endif
           l     &vcbr,VCBnext
         Enddo
         sr    r15,r15
         j     &l.X

&l.C     clc   VCBvar(*-*),0(r15)
&l.X     ds    0a
         MEND

* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
*           VCBGET : get named entry                                  *
* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
         Macro
         VCBGET &name=,&data=,&anchor=
         gblc  &$$vcbanchor,&gblsetpc
         lcla  &l
         lclc  &na,&nl,&da,&dl
&na      setc  '&name(1)'
&nl      setc  '&name(2)'
         aif   ('&na'(1,1) ne '''').nln
&l       seta  (k'&na)-2
&nl      setc  '&l'
.nln     anop
&da      setc  '&data(1)'
&dl      setc  '&data(2)'
         aif   (k'&dl gt 0).dln
&dl      setc  'l''&da'
.dln     anop
.* getloc syntax: name=(len,adr)
         $la   r14,&na
         $la   r15,&nl
         $la   r0,&da
         $la   r1,&dl
         stm   r14,r1,VCBAcpl
         la    r1,VCBAcpl
         VCBsetgp C,&anchor,&$$vcbanchor
         VCBCall VCBget,anchor=&gblsetpc
         ltr   r15,r15
         Mend

* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
*           VCBGETNEXT  : Locate next matching VCB, optionally        *
*                         return data.                                *
* See module VCBNEXT for call, return and parmlist                    *
* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
         Macro
         VCBGETNEXT &name=(0,0),&data=(0,0),&anchor=,&generic=,&ptr=
.* name=(address,length) data=(address,length)
.* parm field..
.*    a  name-length
.*    a  name-address
.*    a  data-length
.*    a  data-address
.*    a  address of Y (generic) or 'N' (descrete)
.*    a  address of VCB pointer
         gblc  &$$vcbanchor,&gblsetpc
         lclc  &l,&m1,&m2,&m3,&tsub,&s,&va,&vl,&lanchr
         VCBsetgp C,&anchor,&$$vcbanchor
         $la   r1,&gblsetpc          -> anchor
         la    r1,VCBAcpl-VCBAnchr(,r1) -> cpl
         $la   r14,&name(1)          length
         $la   r15,&name(2)          address
         stm   r14,r15,0(r1)
         $la   r14,&data(1)          length
         $la   r15,&data(2)          address
         stm   r14,r15,8(r1)
         $la   r14,&generic
         $la   r15,&ptr
         stm   r14,r15,16(r1)
         $la   r0,&gblsetpc
         Call  VCBGETNX
         ltr   r15,r15
         MEND

* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
*           VCBPUT : write named entry                                *
* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
         Macro
         VCBPUT &name=,&data=,&anchor=
         gblc  &$$vcbanchor,&gblsetpc
         lcla  &l
         lclc  &na,&nl,&da,&dl
         aif   (k'&name eq 0 or k'&data eq 0).err1
&na      setc  '&name(1)'
&nl      setc  '&name(2)'
         aif   ('&na'(1,1) ne '''').nln
&l       seta  (k'&na)-2
&nl      setc  '&l'
.nln     anop
&da      setc  '&data(1)'
&dl      setc  '&data(2)'
         aif   (k'&dl gt 0).dln
&dl      setc  'l''&da'
.dln     anop
         $la   r14,&na
         $la   r15,&nl
         $la   r0,&da
         $la   r1,&dl
         stm   r14,r1,VCBAcpl
         la    r1,VCBAcpl
         VCBsetgp C,&anchor,&$$vcbanchor
         VCBCall VCBput,anchor=&gblsetpc
         ltr   r15,r15
         mexit
.err1    mnote 8,'** name or data parm missing'
         Mend

* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
*              VCBCOMPSTR                                             *
* compare 2 strings of possible unequal length                        *
* max length for compare is 256 bytes                                 *
* 1. compare using shortest length                                    *
* 2. if equal then compare lengths                                    *
* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
         Macro
         VCBCompStr &str1,&str2
         lclc  &l
&l       setc  'VC&sysndx'
         $la   r1,&str1(2)           length of string 1
         $la   r0,&str2(2)           length of string 2
         cr    r1,r0                 test length
         jnh   &l.B                  l'str1 le l'str2
         lr    r1,r0                 use the shorter
&l.B     bctr  r1,0
         $la   r14,&str1(1)          address of string 1
         $la   r15,&str2(1)          address of string 2
         ex    r1,&l.C
         jne   &l.C+6                use compare cond
         $la   r1,&str1(2)           length of string 1
         cr    r1,r0                 compare lengths
         j     &l.C+6
&l.C     clc   0(*-*,r14),0(r15)
         Mend

* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
*              VCBTRACE : Generate trace record                       *
* initially a dummy macro, to be re-created by the caller             *
* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
         MACRO
         VCBTrace
.* dummy macro, must be replaced by proper macro in mainline pgm
         MEND

         MACRO
         VCBTrcX  &text
         gblc  &$$vcbtrace
         lclc  &q
&q       setc  Upper('&text')
         aif   ('&q' eq 'BEGIN').begin
         aif   ('&q' eq 'END').end
         if    (tm,VCBAflgs1,VCBAtrace,o)
           aif   (k'&text eq 0).go
           clear VCBAtrrec
           mvlit VCBAtrrec,&text
.go        stm   r0,r15,VCBAtrsa0
           la    r1,VCBAtrrec
*call VCBtrace
           VCBtrace
           lm    r0,r15,VCBAtrsa0
         endif
         mexit
.begin   if    (tm,VCBAflgs1,VCBAtrace,o)
           clear VCBAtrrec
         mexit
.end       stm   r0,r15,VCBAtrsa0
           la    r1,vcbatrrec
*call VCBtrace
           VCBtrace
           lm    r0,r15,VCBAtrsa0
         endif
         mexit
         MEND

* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
*                              modules                                *
* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
         Macro
         VCBMODUL
         gblc  &$$vcbkeepnum,&$$vcbkeepmaxw,&$$vcbsp
         lclc  &vcbkeepn,&vcbkeepmw
&vcbkeepn setc '&$$vcbkeepnum'
         aif   (k'&$$vcbkeepnum gt 0).keepnn
&vcbkeepn setc '10'
.keepnn  anop
&vcbkeepmw setc '&$$vcbkeepmaxw'
         aif   (k'&$$vcbkeepmaxw gt 0).keepmwn
&vcbkeepmw setc '4096'
.keepmwn anop
* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
*              VCBAlc: find free space or get new VCB                 *
*              entry:r1 = l'data                                      *
*              exit: r1 -> VCB or 0                                   *
* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *

VCBAlc   VCBEntry anchorr=r8
         lr    r6,r1                    save size of name/data
         srl   r6,5                     round up to
         sll   r6,5                      to nearest
         la    r6,32(,r6)                   multipla of adjust factor
         if    (c,r6,gt,VCBAmaxdl)      if gt current max data len
           st     r6,VCBAmaxdl          then update max data len
         endif
         la    r6,VCBfixl(r6)           add base

         $cvd  r6,VCBAtrrec+12,len=6
         VCBtrcX 'VCBAlc sz'

* any suitable entries on the 'free' chain?
         if    (icm,r2,15,VCBAfqn,nz)  number of free VCBs > 0 ?

* scan 'free' chain to see if we have a big enough free entry
           using VCB,r4
           l     r4,VCBAfqh               -> start of 'free' chain
           Do    While,(c,r4,ne,VCBAfqt)
             if    (c,r6,le,VCBsize)       if size is ok
* move free VCB to active
               l     r15,VCBAfqn           decrease
               bctr  r15,0                   free VCB
               st    r15,VCBAfqn               count
               VCBtrcX begin
               StrMake VCBAtrrec,'VCBAlc found free ',((r4),4,cvxd),   c
               reg=r3
               VCBtrcX end
               VCBHOOK OFF,vcb=r4
               l     r15,VCBAaqn           increase
               la    r15,1(,r15)             active VCB
               st    r15,VCBAaqn               count
               lr    r1,r4                 -> VCB
               VCBExit rc=0
             endif
             l     r4,VCBnext             try next
           Enddo
           drop  r4

         endif

*create a new VCB
         VCBtrcX 'VCBAlc new'
         la    r5,8                 initial rc
         STORAGE OBTAIN,LENGTH=(R6),SP=&$$vcbsp,CALLRKY=YES,COND=YES,  c
               loc=31
         if    (ltr,r15,r15,z)
           lr    r4,r1
           st    r1,VCBAfw
           VCBtrcX begin
           StrMake VCBAtrrec,'VCBAlc new VCB:',(VCBAfw,4,cvxd),        c
               reg=r2
           VCBtrcX end
           lr    r1,r4
           using VCB,r1
           xc    VCBfix(VCBfixl),VCBfix
           st    r6,VCBsize
           drop  r1
           sr    r5,r5
           l     r15,VCBAaqn           number of active VCBs
           la    r15,1(,r15)           count up
           st    r15,VCBAaqn           update
         endif

         VCBExit rc=(r5),final
VCBAlcWrk1 ds  4a

* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
*              VCBLoc: find existing VCB by name                      *
* <logic>                                                             *
* The search is using the cursor set by VCBPUT or first               *
*                                                                     *
* at entry r1 -> search value: a(nameaddr,namelen)                    *
*                                                                     *
* if search_key lt cursor then search from queue head                 *
* else search from cursor                                             *
*                                                                     *
* if found then                                                       *
*   r1->VCB                                                           *
*   return 0                                                          *
* else                                                                *
*   r1->VCBprev                                                       *
*   return 4                                                          *
*                                                                     *
*        r12: local base                                              *
*        r11: main module area                                        *
*        r10: global storage                                          *
*        r09: local call                                              *
*        r08 -> VCBanchor                                             *
*        r07 -> VCB queue                                             *
*        r06 -> name to locate                                        *
*        r05 -> length of name                                        *
*        r04 -> machine length of name                                *
*                                                                     *
* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *

         Macro
         LocGetVn
         gblc  &$$vcbkeepnum,&$$vcbkeepmaxw,&$$vcbsp
         l     r15,VCBnamel
         bctr  r15,0
         clear a=VCBAlocvn
         mvc   VCBAlocvn(*-*),VCBname
         ex    r15,*-6
         Mend

         Using VCB,r7
VCBLoc   VCBEntry anchorr=r8

         clear a=VCBAlocsn
         lm    r2,r3,0(r1)              name addr, length
         bctr  r3,0                     machine length
         mvc   VCBAlocsn(*-*),0(r2)     copy name to work
         ex    r3,*-6
         VCBtrcX begin
         StrMake VCBAtrrec,'VCBLOC search ',(VCBAlocsn,1(r3))
         VCBtrcX end

*search before or after cursor
         l     r7,VCBAcsrp              load cursor
         LocGetVn
         VCBtrcX begin
         StrMake VCBAtrrec,'csr ',(VCBAlocvn,30),' ',(vcbacsrp,4,cvxd)
         VCBtrcX end
         if    (clc,VCBAlocsn,lt,VCBAlocvn)
           l     r7,VCBAaqh             use queue start
           VCBtrcX 'VCBLOC use qh'
         else
           VCBtrcX 'VCBLOC use csr'
         endif
* l r7,VCBAaqh
*        if    (c,r7,eq,VCBAaqh),then=(l,r7,VCBnext)

*search forward from r7
         Do    inf

           lr    r1,r7
           VCBcall VCBFmtNd,anchor=(r8)
           VCBtrcX begin
           mvlit VCBAtrrec,'VCBLOC'
           mvc   VCBAtrrec+7(110),0(r1)
           mvi   VCBAtrrec+61,c':'
           VCBtrcX end

           LocGetVn
           clc   VCBAlocsn,VCBAlocvn
           if    (eq)
             VCBtrcX 'VCBLOC match'
             la    r5,0                  set rc
             leave
           endif
           if    (l)
             VCBtrcX 'VCBLOC overshoot'
             l     r7,VCBprev
             la    r5,4                  set rc
             leave
           endif
           l     r7,VCBnext
           if    (c,r7,eq,VCBAaqt)
             VCBtrcX 'VCBLOC no match'
             l     r7,VCBprev
             la    r5,4                  set rc
             leave
           endif

         Enddo

         if    (ltr,r7,r7,z)             shouldn't happen, but still..
           VCBtrcX 'VCBLOC reset to qh'
           l     r7,VCBAaqh
           la    r5,4
         endif

         st    r7,VCBAfw
         VCBtrcX begin
         StrMake VCBAtrrec,'VCBLOC csr ',(VCBAfw,4,cvxd),reg=r3
         VCBtrcX end

         lr    r1,r7
         VCBExit rc=(r5),final

         drop  r7

*-------------------------- VCBPUT -----------------------------------*
*---------------------------------------------------------------------*
* Copy name and data to VCB                                           *
* VCB will created if no suitable                                     *
* Input data are defined by rnvvar/rnvvarl and vardataa/vardatal      *
* At entry:                                                           *
*   r1 -> a(namelen,nameadr,datalen,dataadr)                          *
*                                                                     *
*---------------------------------------------------------------------*
*---------------------------------------------------------------------*
VcbPutParm Dsect
VcbPutNa   ds    a
VcbPutNl   ds    a
VcbPutDa   ds    a
VcbPutDl   ds    a

VCBPut   VCBEntry Anchorr=r8
         lr    r9,r1
         Using VCBPutParm,r9

* update anchor length fields
         if    (VcbPutNl,gt,VCBAvmaxnl)
           mvc   VCBAvmaxnl,VcbPutNl
         endif
         if    (VcbPutDl,gt,VCBAvmaxdl)
           mvc   VCBAvmaxdl,VcbPutDl
         endif
         l     r14,VcbPutNl    name length
         a     r14,VcbPutDl    plus data length
         if    (c,r14,gt,VCBAvmaxndl)
           st    r14,VCBAvmaxndl
         endif

*log REXX data
         lm    r2,r5,VCBputparm
         VCBtrcX begin
         StrMake VCBAtrrec,'vputdata ',reg=r7,                         c
               (VCBputnl+2,2,cvd,4),':',(VCBputdl+2,2,cvd,6),          c
               ' ',((r2),(r3),,20),':',((r4),(r5),,35)
         VCBtrcX end

*  VCBLOC entry  r1 -> a(length),a(->name)
VCBputp  equ   VCBAwrk+16
         mvc   VCBputp(4),VCBputna
         mvc   VCBputp+4(4),VCBputnl
         la    r1,VCBputp
         VCBCall VCBLoc,anchor=(r8)
         lr    r6,r15                   save locate result
         lr    r7,r1                    save locate cursor
         st    r6,VCBAfw
         VCBtrcX begin
         StrMake VCBAtrrec,'VCBLoc result ',(VCBAfw,4,cvxd),reg=r2
         VCBtrcX end

         if    (ltr,r6,r6,z)              found
*-check size
           using VCB,r7
           VCBtrcX 'VCBPut var on chain'
           l     r2,VCBPutDl
           if    (c,r2,le,VCBdatal)       big enough??
             la    r2,VCBvar              target addr
             a     r2,VCBnamel            -> data section
             l     r14,VCBPutDa           source addr
             if    (icm,r15,15,VCBPutDl,nz) source length
               lr    r3,r15                 target length
               mvcl  r2,r14                 get data
             endif
             mvc   VCBdatal,VCBPutDl      copy length
             st    r7,VCBAcsrp            update cursor
             VCBExit rc=0
           endif
           VCBtrcX begin
           mvlit  VCBAtrrec,'VCBPUT insuf sz VCBPutDl ........ VCBdatal+
               '
           $cvd  r2,VCBAtrrec+26,len=8
           l     r3,VCBdatal
           $cvd  r3,VCBAtrrec+44,len=8
           VCBtrcX end
           drop  r7
         endif

         if    (ltr,r6,r6,z)              found but not sufficient
           lr   r1,r7                     -> VCB
           l    r7,VCBprev-vcb(,r7)
           st   r7,VCBAcsrp               updte system cursor
           VCBCall VCBDel,anchor=(r8)     delete
         endif
         la    r5,8                     preset rc

         l     r2,VCBPutNl              name length
         l     r3,VCBPutDl              data length
         lr    r1,r2                    length of name
         ar    r1,r3                    add data length
         lr    r4,r1
         st    r1,VCBAfw
         VCBtrcX begin
         StrMake VCBAtrrec,'VCBPut alloc sz ',(VCBAfw,4,cvxd)
         VCBtrcX end
         lr    r1,r4

         VCBCall VCBAlc,anchor=(r8)     Go get a VCB

         lr    r3,r15
         lr    r4,r1
         st    r15,VCBAfw
         VCBtrcX begin
         StrMake VCBAtrrec,'VCBPut alloc rc ',(VCBAfw,4,cvxd)
         VCBtrcX end
         lr    r1,r4
         lr    r15,r3

         ltr   r15,r15
         if    (z)                      got on
           lr    r3,r1
           VCBtrcX 'VCBPut VCBalc ok'
           lr    r1,r3
           st    r1,VCBAcsrp            update cursor
           VCBHOOK ON,vcb=r1,csr=r7     on to chain
           lr    r7,r1                  -> new VCB
           st    7,VCBAfw
           VCBtrcX begin
           StrMake VCBAtrrec,'VCBPut update ',(VCBAfw,4,cvxd),reg=r2
           VCBtrcX end
           using VCB,r7
           l     r2,VCBPutNl
           st    r2,VCBnamel
           l     r3,VCBPutDl
           st    r3,VCBdatal
           la    r14,VCBvar               -> name
           ar    r14,r2                   -> data
           st    r14,VCBdataa             save address
           bctr  r2,0                     mch length
           l     r14,VCBPutNa
           mvc   VCBvar(*-*),0(r14)       get name
           ex    r2,*-6                   get data
           if    (ltr,r3,r3,nz)           data present??
             la    r2,VCBvar+1(r2)        -> data section
             l     r14,VCBPutDa           source
             lr    r15,r3                 length
             mvcl  r2,r14                 get data
           endif
           drop  r7
           lr    r1,r7                    copy VCB address
           sr    r5,r5
         endif

         VCBExit rc=(r5)
*VCBPutP  ds    4a
         ltorg
         drop  r8,r9

* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
*              VCBDel: delete VCB                                     *
*   move VCB from active to free queue, or free storage               *
*                                                                     *
* at entry                                                            *
*  r0 -> VCB anchor                                                   *
*  r1 -> VCB to logically remove                                      *
*                                                                     *
* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *

         Using VCB,r6
VCBDel   VCBEntry anchorr=r8

*-from current (active) queue
         lr    r6,r1
         VCBHOOK OFF,vcb=r6
         VCBtrcX 'VCBDEL unhooked from active'
         l     r15,VCBAaqn              decrease
         bctr  r15,0                      number of
         st    r15,VCBAaqn                 active VCBs

         l     r15,VCBAfqn              number of free VCBs
         l     r4,VCBsize
* keep only a limited number, and only smaller blocks
         if    (clfi,r15,lt,&vcbkeepn),and,(clfi,r4,le,&vcbkeepmw)
           l     r5,VCBAFqh             'free' queue head
           VCBHOOK ON,vcb=r6,csr=r5
           VCBtrcX 'VCBDEL hooked on free'
           l     r15,VCBAfqn            increase
           la    r15,1(,r15)              number of
           st    r15,VCBAfqn               free VCBs
         else
           if    (ltr,r4,r4,nz)
             STORAGE RELEASE,LENGTH=(4),ADDR=(6),                      c
               SP=&$$vcbsp,CALLRKY=YES
             VCBtrcX 'VCBDEL freemained'
           endif
         endif

         VCBExit final,rc=0
         drop  r6

* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
* VCBDelAc : delete all active VCBs, leaving free VCBs                *
* at entry                                                            *
*  r0 -> VCB anchor                                                   *
* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
VCBDelAc VCBEntry anchorr=r8
*
         if    (VCBAaqn,eq,=a(0))
           VCBtrcX 'vcbdelalc empty aq'
           VCBExit rc=0
         endif
*
         VCBtrcX 'vcbdel active q'
*
         using VCB,r6
         l     r6,VCBAaqh                 -> header
         l     r6,VCBnext                 -> 1st real
         do    forever
           l     r5,VCBnext               -> next
           lr    r1,r6
           VCBCall VCBDel,anchor=(r8)    Go delete VCB
           if    (c,r5,eq,VCBAaqt),then=leave  dont drop trail
           lr    r6,r5
         enddo
         drop  r6
*
         VCBExit final,rc=0

* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
* VCBDelAl : delete all VCBs from one anchor                          *
* Essentially VCBDROP without dropping the anchor too.                *
* at entry                                                            *
*  r0 -> VCB anchor                                                   *
* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
VCBDelAl VCBEntry anchorr=r8
*
         if    (VCBAaqn,ne,=a(0))
           VCBtrcX 'vcbdelall active q'
           la    r1,VCBAaqh
           VCBCall VCBDropQ,anchor=(r8)    Go drop queue
           VCBAinit active
         else
           VCBtrcX 'vcbdelall empty aq'
         endif
*
         if    (VCBAfqn,ne,=a(0))
           VCBtrcX 'vcbdelall free q'
           la    r1,VCBAfqh
           VCBCall VCBDropQ,anchor=(r8)    Go drop queue
           VCBAInit free
         else
           VCBtrcX 'vcbdelall empty fq'
         endif
*
         VCBExit final,rc=0

* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
*              VCBDrop : delete entire storage structure              *
* at entry                                                            *
*  r0 -> VCB anchor                                                   *
* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
VCBDrop  VCBEntry anchorr=r8
         clc   VCBAeye,=cl8'VCBANCHR'
         je    VCBDrop1
         abend 1
VCBdrop1 ds    0h

*---------------------------------------------------------------------*
*        release queues                                               *
*---------------------------------------------------------------------*

         VCBtrcX 'vcbdrop active q'
         la    r1,VCBAaqh
         VCBCall VCBDropQ,anchor=(r8)    Go drop queue

         VCBtrcX 'vcbdrop free q'
         la    r1,VCBAfqh
         VCBCall VCBDropQ,anchor=(r8)    Go drop queue

         VCBtrcX 'release anchor'
         la    r2,VCBAnchrl
         STORAGE RELEASE,ADDR=(8),LENGTH=(2),                          c
               SP=&$$vcbsp,CALLRKY=YES

*        VCBExit final,trace=n
* VCBEXIT TRACE=Y (default) test/updates fields in the anchor block,
* which normally leads to an abend S0C4
         sr    r15,r15
         pr    ,
         ltorg
         drop  r8,r12

* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
*              VCBDropQ: delete queue (active or free)                *
* at entry                                                            *
*  r0 -> VCB anchor                                                   *
*  r1 -> VCB queue pointer                                            *
* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
         Using VCB,r6
VCBDropQ VCBEntry anchorr=r8
         lr    r7,r1                      save queue pointer
* r7 -> a(queue-head,queue-trail)
         l     r6,0(,r7)                  -> 1st VCB
         do    until,(ltr,r5,r5,z)
           l     r5,VCBnext               -> next
           if    (c,r5,eq,4(r7)),then=leave  dont drop trail
           st    r6,VCBAfw
           VCBtrcX begin
           StrMake VCBAtrrec,'vcba ',(VCBAfw,4,cvxd),                  c
               ' sz ',(VCBsize,4,cvxd)
           VCBtrcX end
           if    (icm,r4,15,VCBsize,nz)
             STORAGE RELEASE,LENGTH=(4),ADDR=(6),                      c
               SP=&$$vcbsp,CALLRKY=YES
           endif
           lr    r6,r5
         enddo
         VCBExit final
         drop  r6

*---------------------------------------------------------------------*
*---------------------------------------------------------------------*
* Locate named VCB, return data if requeted                           *
*                                                                     *
* At entry:                                                           *
*   r1 -> a(nameaddr)                                                 *
*         a(namelen)                                                  *
*         a(dataaddr)  optional                                       *
*         a(datalen)   optional                                       *
*                                                                     *
* At exit:                                                            *
*   r1 -> VCB if r15 = 0 or 2                                         *
*   r15 00  VCB located, data returned if requested                   *
*   r15 01  VCB not found                                             *
*   r15 02  VCB found, data buffer too small, data truncated          *
*                                                                     *
*---------------------------------------------------------------------*
*---------------------------------------------------------------------*
         using VCB,r7
VCBGet   VCBEntry anchorr=r8
         lr    r9,r1
         sr    r6,r6
* getloc syntax: name=(addr,len)
         lm    r2,r5,0(r1)
         VCBLocate name=((r2),(r3)),anchor=(r8)
         if    (nz)                    not found
           VCBExit rc=1
         endif
* get data, r1 -> VCB
         lr    r7,r1             save VCB addr
         if    (icm,r15,15,VCBdatal,z)  if data eq NULL
           VCBExit rc=0          fine then
         endif
         if    (cr,r15,gt,r5)    check data buffer size
           lr    r15,r5          use max
           la    r6,2            set 'truncation'
         endif
         lr    r5,r15            copy data length
         la    r2,VCBname        address of name
         a     r2,VCBnamel       add length of name, -> data src
         if    (clfi,r15,le,255)  small data?
           bctr  r15,0             mch len of data
           mvc   0(*-*,r4),0(r2)   get data
           ex    r15,*-6
         else    ,               data length gt 255
           lr    r14,r4          -> target
           lr    r3,r15          copy length
           mvcl  r14,r2          copy data
         endif
         lr    r0,r5             copy data length
         lr    r1,r7             copy VCB address
         VCBExit final,rc=(r6)
         drop  r7

*---------------------------------------------------------------------*
*---------------------------------------------------------------------*
* Locate next VCB with matching name (generic or descrete).           *
* Return data in buffer if requested.                                 *
*                                                                     *
* At entry:                                                           *
*   r1 -> see dsect below                                             *
*                                                                     *
* At exit:                                                            *
*   r1 -> VCB or zero                                                 *
*   r15 00  VCB located, data returned if requested                   *
*   r15 01  VCB not found                                             *
*   r15 02  VCB found, data buffer too small                          *
*                                                                     *
*---------------------------------------------------------------------*
*---------------------------------------------------------------------*
VcbGnWrk    Dsect
*parameter mapping
VcbGnWna    ds    a     name address
VcbGnWnl    ds    a     name length
VcbGnWda    ds    a     data address
VcbGnWdl    ds    a     data length
VcbGnWgen   ds    a     -> 'Y' or 'N'
VcbGnWptr   ds    a     -> latest VCB

         using  VCB,r7
         using  VCBGnWrk,r10
VCBGetNx VCBEntry anchorr=r8
         lr    r10,r1

         VCBtrcX begin
         if    (vcbgnwnl,ne,=a(0))      no name = all entries
           l     r4,vcbgnwna
           l     r5,vcbgnwnl
           if    (clfi,r5,gt,40),then=(la,r5,40)
           l     r2,VcbGnwgen
           StrMake  VCBAtrrec,'generic ',((r2),1),                     c
               ' name ',((4),(5))
         else
           StrMake  VCBAtrrec,'all entries'
         endif
         VCBtrcX end

*First time around?
         l     r7,VcbGnWptr               -> VCB ptr
         if    (icm,r7,15,0(r7),z)        1st time around?
           VCBtrcX '1st time around'
           if    (=a(0),eq,VCBAaqn)       empty list?
             la    r0,1                   reason
             VCBexit rc=1
           endif
           l     r7,VCBAaqh               use header
         endif

*Next sequential?               a
         if    (vcbgnwnl,eq,=a(0))        all entries ?
           VCBtrcX 'next sequential'
           l     r7,VCBnext               next
           if    (c,r7,eq,VCBAaqt)        past last?
             la    r0,1                   reason
             VCBexit rc=1
           endif

*Locate next entry if not all
* r9 -> generic Y or N
* r8 -> VCB anchor
* r7 -> current VCB
* r6 :  real name length
* r5 :  machine name length
* r4 -> name
         else                             no name = all entries
           VCBtrcX 'next by key'
           l     r4,VcbGnWna              name
           l     r6,VcbGnWnl              name length
           lr    r5,r6
           bctr  r5,0                     machine length
           l     r9,VcbGnwgen             -> N/Y generic option
           if    (cli,0(r9),ne,c'Y'),then=(sr,r9,r9)  zero = N

*Locate VCB with matching name
           Do    forever
             vcbtrcx 'next'
             l     r7,VCBnext               next
             if    (c,r7,eq,VCBAaqt)        past last?
               la    r0,1                   reason
               VCBexit rc=1
             endif
             VCBtrcX begin
             l     r3,VCBnamel              name length
             if    (clfi,r3,gt,40),then=(la,r3,40)
             StrMake VCBAtrrec,'VCBname ',(VCBName,(r3))
             VCBtrcX end

* check for within range (by key value)
             lr    r2,r6                    name length
             if    (c,r2,gt,VCBnamel),then=(l,r2,VCBnamel) use small
             bctr  r2,0                     machine length
             ex    r2,VcbGnExCn             check name against VCBname
             if    (gt)                     lt => not there yet
               VCBtrcX 'key high'
               iterate
             endif
             if    (lt)                     gt => overshoot
               VCBtrcX 'key low'
               la    r0,1                   reason
               VCBexit rc=1
             endif

* check value if generic
             if  (ltr,r9,r9,nz)           generic ?
               VCBtrcX 'check generic'
               if    (c,r6,le,VCBnamel)   length le?
                 if    (ex,r5,VcbGnExCn,eq),then=leave name match?
               endif
* check value if descrete
             else                         not generic
               VCBtrcX 'check descrete'
               if    (c,r6,eq,VCBnamel)   length must be eq
                 if    (ex,r5,VcbGnExCn,eq),then=leave name match?
               endif
             endif

           Enddo

         Endif

         l     r2,VcbGnWptr               -> ptr
         st    r7,0(,r2)                  save ptr
         lr    r1,r7                      copy ptr

*Return data if requested
         if    (icm,r3,15,VcbGnWdl,z)     no data requested
           la    r0,4
           VCBExit rc=0
         endif
         if    (c,r3,lt,VCBdatal)         no fit
           VCBExit rc=2
         endif
         l     r2,VCBGnWda                -> target buffer
         l     r5,VCBDatal                source data length
         st    r5,VCBGnWdl                save as target length
         la    r4,VCBname                 -> source name
         a     r4,VCBnamel                -> source data
         if    (clfi,r5,le,256)           short buffer
           bctr  r5,0                     mch length
           mvc   0(*-*,r2),0(r4)
           ex    r5,*-6
         else
           lr    r3,r5
           mvcl  r2,r4
         endif
         l     r1,VcbGnWptr               -> ptr
         l     r1,0(,r1)                  -> VCB
         VCBExit rc=0

VcbGnZero dc    a(0)
VcbGnExCn clc   0(*-*,r4),VCBname
         ltorg
         drop  r7,r8,r10

 ago .vcbzcsrn
* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
*              VCBZCsr: set the cursor                                *
*   r1->VCB                                                           *
* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
VCBZCSR  VCBEntry anchorr=r8
         Using VCB,r1
         st    r1,VCBAcsrp              pointer
         l     r2,VCBnamel              name length
         bctr  r2,0
         clear VCBAcsrv
         mvc   VCBAcsrv(*-*),VCBname
         ex    r2,*-6
         drop  r1
         VCBExit final
.vcbzcsrn anop

* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
*        VCBFmtNd : format name/data part of VCB                      *
*        at entry  r0 -> VCB anchor                                   *
*                  r1 -> VCB                                          *
*        at exit   r1 -> formatted record                             *
*        registers:                                                   *
*          r9 :  base                                                 *
*          r7 -> VCB                                                  *
*          r8 -> VCBAnchor                                            *
*          r5 -> pos in formatted record                              *
* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
         Using VCB,r7
VCBFmtNd VCBEntry anchorr=r8
         lr    r7,r1
         clear VCBAfmtndr
         la    r5,VCBAfmtndr

         st    r7,VCBAfw
         strc2x from=(VCBAfw,4),to=(r5)
         if    (c,r7,eq,VCBAaqh)
            mvi   8(r5),c'<'
         endif
         if    (c,r7,eq,VCBAaqt)
            mvi   8(r5),c'>'
         endif
         la    r5,9(,r5)

         l     r2,VCBnamel         <<--
         cvd   r2,VCBAdw
         unpk  0(4,r5),VCBAdw+6(2)
         oi    3(r5),x'f0'
         la    r5,5(,r5)

         l     r3,VCBdatal
         cvd   r3,VCBAdw
         unpk  0(4,r5),VCBAdw+6(2)
         oi    3(r5),x'f0'
         la    r5,5(,r5)

         la    r4,VCBvar
         if    (clfi,r2,gt,35)             vname length
           mvc   0(34,r5),0(r4)
           mvi   34(r5),c'+'
         else
           bctr  r2,0
           mvc   0(*-*,r5),0(r4)           vname lt 35
           ex    r2,*-6
         endif
         la    r5,36(,r5)

         a     r4,VCBnamel                -> data
         if    (ltr,r3,r3,nz)
           if    (clfi,r3,gt,75)          vname length
             mvc   0(74,r5),0(r4)
             mvi   74(r5),c'+'
           else
             bctr  r3,0
             mvc   0(*-*,r5),0(r4)           vname lt 35
             ex    r3,*-6
           endif
         endif

         la    r1,VCBAfmtndr
         VCBExit final

         drop  r7

         MEND
