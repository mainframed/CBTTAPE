* 25/08/04 enq/deq around wait
* 25/03/05 TDUMP
* 18/11/05 LOGGER support
* 21/11/05 VTOC access
* 13/01/06 Browse Logger
* 16/11/06 RMODE warning from binder
* 05/10/07 store IEATDUMP reason code
* 21/04/08 name/token service in user/problem state
* 19/11/08 SRB callback
* 21/11/08 baseless code
* 24/11/08 WLM enclave
* 04/03/10 OBTAIN DSCB
* 16/07/10 LOGGER browse TIME search
* 16/08/11 OBTAIN EADSCB=OK for EAV volumes
* 17/11/11 GetToken in SYSTEM_LEVEL
* 19/12/11 IEATDUMP with DDNAME
* 10/01/12 cleanup register
* 06/03/12 TESTAUTH DIAGNOSE extension
* 10/09/12 CAMLST SEEK for OBTAIN
         MACRO
&LABEL   $$ASMIF &TYPE=PROGRAM
         AIF ('&TYPE' EQ 'PROGRAM').PROGRAM
         AIF ('&TYPE' EQ 'MSG').MSG
         AIF ('&TYPE' EQ 'DOC').DOC
.DOC     ANOP
***********************************************************************
*                                                                     *
* asmif                                                               *
*                                                                     *
* function:                                                           *
*  asm interfcae routines                                             *
*  called from the c++ mvsif module                                   *
* processing:                                                         *
*  the function code defines the  functions to execute                *
*                                                                     *
*                                                                     *
* register assignment :                                               *
* r13 , temp save from asm_save                                       *
*                                                                     *
*                                                                     *
* the routine is getting the control in problem state,  user key      *
*                                                                     *
* the module is reentrant                                             *
*                                                                     *
* amode(31) , rmode(any)                                              *
*                                                                     *
* change :                                                            *
*                                                                     *
***********************************************************************
         MEXIT
.PROGRAM TITLE ' asmif asm interfcae module'
         PUSH PRINT
         PRINT OFF
         COPY  IEABRC
         COPY  $$SYSVAR
         COPY  ASMMSP
&BASELESS SETB 1
         POP  PRINT
* 16/11/06 RMODE warning from binder
ASMIF    CSECT
ASMIF    AMODE 31
ASMIF    RMODE ANY
* 16/11/06 RMODE warning from binder
***********************************************************************
*                                                                     *
* asmif                                                               *
*                                                                     *
* function:                                                           *
*  asm     interfcae routines                                         *
*  called from the c++ mvsif module                                   *
* processing:                                                         *
*  the function code defines the  functions to execute                *
*                                                                     *
*                                                                     *
* register assignment :                                               *
*                                                                     *
*                                                                     *
*                                                                     *
* the routine is getting the control in problem state,  user key      *
*                                                                     *
* the module is reentrant                                             *
*                                                                     *
* amode(31) , rmode(any)                                              *
*                                                                     *
***********************************************************************
         SPACE 1
MAX_ECBS  EQU   128*20             max ecb
MAX_ASM_BUFFER  EQU 4080           page - prefix size
MAX_ASM_SOCKETS EQU 1024           max sockets
MAX_ASM_MUTEX   EQU 1024           max mutex
VRL_LEN         EQU   28           VRL len
*        iarvrl   ,                VRL map
         IARVRL   ,                VRL map
FRRAREA  DSECT
FRRSAVE  DC    18A(0)
FRRSDUMPX_L SDUMPX MF=L
FRRAREA_L   EQU *-FRRAREA
         SPACE 1
ASMDSECT DSECT
ASM_SAVE DC    18A(0)              save in asm
ASM_MVS      DC A(0)               mvs object pointer
ASM_BASEREGS DC 4A(0)              base regs
ASM_CRAB     DC A(0)               crab pointer
ASM_RC       DC F'0'               function return
ASM_REASON   DC F'0'               function reason code
ASM_IEANTCR  DC A(0)               ieantcr address
ASM_IEANTRT  DC A(0)               ieantrt address
ASM_IEANTDL  DC A(0)               ieantdl address
ASM_TIMX     DC  16A(0)            timer exit area
ASM_TIMER_ECBP  DC A(0)            timer ecb pointer
ASM_EVENT0_ECBP DC A(0)            event0 ecb
ASM_EVENT1_ECBP DC A(0)            event1 ecb
ASM_EVENT2_ECBP DC A(0)            event2 ecb
ASM_EVENT3_ECBP DC A(0)            event3 ecb
ASM_TIMER_ECB  DC A(0)             timer ecb
ASM_FUNCTION_CODE DC AL1(0)        function code
ASM_KEY      DC AL1(0)             psw key save
* 19/11/08 SRB callback
ASM_SRB_MODE DC AL1(0)             srb mode flag
ASM_SRB_SAVE DC 16A(0)             srb register save area
ASM_SRB_RETURN DC F'0'             srb return address
* 19/11/08 SRB callback
             DC 0F'0'              align it
ASM_PARMS    DC 8A(0)              parameters
             SPACE  3
ASM_CALLLIST DC 8A(0)              call parameters
ASM_WORK     DC CL128' '           work area
ASM_JOBNAME  DC CL8' '             jobname
ASM_PROGRAMNAME DC CL8' '          actual programname
ASM_WORKECBS DC A(0)               start of work ecb pool
ASM_WORKECBP DC A(0)               work ecb pointer
ASM_WORKECBE DC A(0)               work ecb end address
*ms_iarvservl iarvserv mf=(l,asm_iarv)  iarvserv list form
ASM_IARVSERVL IARVSERV MF=(L,ASM_IARV)  iarvserv list form
*ms_aleservl  aleserv  mf=l             aleserv  list form
ASM_ALESERVL  ALESERV  MF=L             aleserv  list form
*ms_enql     enq (0,0,e,0,step),mf=l   list enq
ASM_ENQL     ENQ (0,0,E,0,STEP),MF=L   list enq
ASM_OPTION   DC 4A(0)              option fields
ASM_SLEEP    DC D'0'               double word for timer
ASM_IARVRL   DC (VRL_LEN)X'00'     iarvrl area
ASM_IARVRLA  DC A(0)               iarvrl area address
*ms_extract_l extract mf=l         extract list form
ASM_EXTRACT_L EXTRACT MF=L         extract list form
*ms_post_l    post ascb=0,ecbkey=yes,mf=l list form
ASM_POST_L    POST ASCB=0,ECBKEY=YES,MF=L list form
ASM_COMPTR   DC A(0)               comm area pointer
ASM_COMTOKEN DC A(0)               comm token
ASM_COMECBPT DC A(0)               stop/modify ecb pointer
ASM_WTOL WTO  '01234567890123456789012345678901234567890123456789012345*
               678901234567890123456789012345678901234567890123456789',*
               ROUTCDE=(21),DESC=(6),MF=L
ASM_WTOL_TEXT_LENGTH EQU 110       text length
ASM_BPX1    DC  32A(0)             BPX1 parm list
ASM_BPX1_RETVAL  DC F'0'           return value
ASM_BPX1_RETCODE DC F'0'           return code
ASM_BPX1_RSNCODE DC F'0'           reason code
ASM_BPX1_LIST_LENGTH_R DC A(0)     list length read
ASM_BPX1_LIST_LENGTH_W DC A(0)     list length write
ASM_BPX1_LIST_LENGTH_E DC A(0)     list length exception
ASM_BPX1_NUMFDS      DC A(0)       number of FD's
ASM_BPX1_TIMEOUT     DC A(0)       timeout pointer
ASM_BPX1_OPTION      DC A(0)       option value
ASM_STCK    DC D'0'                stck area
*           ieatdump mf=(l,asm_ieatdump)
            IEATDUMP MF=(L,ASM_IEATDUMP)
ASM_TDUMP_NAME DC    AL1(0)        name length
               DC    CL100' '      name
ASM_TDUMP_DESC DC    AL1(0)        desc length
               DC    CL100' '      desc
* 18/11/05 LOGGER support
ASM_STREAMNAME       DC CL26' '    stream name
ASM_STREAMTOKEN      DC XL16'00'   stream token
ASM_LOGGER_LENGTH    DC A(0)
ASM_LOGGER_BUFFER    DC A(0)      logger buffer pointer
ASM_LOGGER_BUFFLEN   DC A(0)      buffer length
ASM_LOGGER_BUFFER_OFFSET DC A(0)  actual buffer offset
ASM_LOGGER_BROWSE_TOKEN  DC  A(0) browse token
ASM_LOGGER_DIRECTION     DC  A(0) browse direction 2-3
*       ixgconn  mf=(l,asm_ixgconn)
        IXGCONN  MF=(L,ASM_IXGCONN)
*       ixgwrite mf=(l,asm_ixgwrite)
        IXGWRITE MF=(L,ASM_IXGWRITE)
*       ixgbrwse mf=(l,asm_ixgbrwse)
        IXGBRWSE MF=(L,ASM_IXGBRWSE)
* 16/07/10 LOGGER browse TIME search
ASM_LOGGER_CONVVAL DC 16X'00'
ASM_LOGGER_STCK    DC 16X'00'
*sm_logger_convtod convtod mf=l
ASM_LOGGER_CONVTOD CONVTOD MF=L
* 16/07/10 LOGGER browse TIME search
* 19/11/08 SRB callback
*       IEAMSCHD MF=(L,ASM_IEAMSCHD)
        IEAMSCHD MF=(L,ASM_IEAMSCHD)
ASM_IEAMSCHD_COMP DC F'0'        IEAMSCHD comp
ASM_IEAMSCHD_CODE DC F'0'        IEAMSCHD code
ASM_IEAMSCHD_RSN  DC F'0'        IEAMSCHD reason
* 19/11/08 SRB callback
ASM_ANSAREA DC          XL(ANSAA_LEN)'00'
* 18/11/05 LOGGER support
* 21/11/05 VTOC access
ASM_VTOC   DC   0D'0'              vtoc access
ASM_VTOC_DCB    DC A(0)            DCB address below the line
ASM_VTOC_DDNAME DC CL8' '          DDNAME
ASM_VTOC_FILTER DC CL44' '         name filter
*SM_VTOC_OPENLIST OPEN (0,INPUT),MF=L list form for open
ASM_VTOC_OPENLIST OPEN (0,INPUT),MF=L list form for open
ASM_VTOC_FCL     DC       XL(FCLHDLEN+FCLDSNEL)'00'
ASM_VTOC_BFL     DC       XL(BFLHLN+BFLELN)'00'
*SM_VTOC_CVAFFILT CVAFFILT MF=L,BRANCH=NO,FLTAREA=KEEP
ASM_VTOC_CVAFFILT CVAFFILT MF=L,BRANCH=NO,FLTAREA=KEEP
ASM_VTOC_BUFFER  DC       XL(F1DSCB_SIZE)'00'
* 04/03/10 OBTAIN DSCB
ASM_CAMLST DC    4A(0)
* 04/03/10 OBTAIN DSCB
* 21/11/05 VTOC access
* 06/03/12 TESTAUTH DIAGNOSE extension
ASM_TESTAUTH DC A(0)
ASM_DIAGNOSE_FLAG DC A(0)
ASM_DIAGNOSE_ADDR DC A(0)
ASM_DIAGNOSE_LENGTH EQU 4095
ASM_DIAGNOSE_FIX    EQU 1
ASM_DIAGNOSE_DONTSWAP EQU 2
ASM_DIAGNOSE_KEEP   EQU   4
ASM_DIAGNOSE_ALL    EQU   7
ASM_VSMLIST_ASCBADDR DC A(0)       address of the ascb
ASM_VSMLIST_MYASCBID DC H'0'       my own ASCB id
ASM_VSMLIST_MYASCB DC F'0'         address of my ASCB
ASM_VSMLIST_MYTCB DC F'0'          my own TCB addr
ASM_VSMLIST_STORAGE DC A(0)        SRB work area address
         SPACE 1
*
* eq symbols for the branch table
*
         $$    SWITCH=ASM_FUNCTION_CODE,SWTYPE=BINARY,DSECT=YES,       *
               CASE=(CLEANUP,                                          *
               GETTOKEN,                                               *
               CREATETOKEN,                                            *
               DELETETOKEN,                                            *
               ALLOCATEPAGES,                                          *
               FREEPAGES,                                              *
               ENQ,                                                    *
               DEQ,                                                    *
               SLEEP,                                                  *
               GETECB,                                                 *
               WAIT,                                                   *
               POST,                                                   *
               RESET,                                                  *
               SELECT,                                                 *
               CONNECTSHMEM,                                           *
               DISCONNECTSHMEM,                                        *
               OPER,                                                   *
               WTO,                                                    *
               MALLOC,                                                 *
               FREE,                                                   *
               SVC,                                                    *
               ATTACHMVS,                                              *
               CLOCK,                                                  *
               TIMEUSED,                                               *
               TDUMP,                                                  *
               LOGGER,                                                 *
               VTOC,                                                   *
               SRB,                                                    *
               WLM,                                                    *
               OBTAIN,                                                 *
               TESTAUTH,                                               *
               DIAGNOSE,                                               *
               VSMLIST)
ASM_MUTEX_VECTOR  DC (MAX_ASM_MUTEX/32)A(0)
ASM_LENGTH   EQU *-ASMDSECT        dsect length
*        cregs
         CREGS
         USING PSA,R0              base on psa
         SPACE 5
* SRB work area in sp 245 address passed in parm
         SPACE 1
SRBWORK  DSECT
SRBWORK_SAVESYS DS 18F              secondary save in the SRB
SRBWORK_ECB DC A(0)     SRB complete srbwork_ecb
SRBWORK_STOKEN DS D                 stoken value
SRBWORK_ALET   DS A                 alet value
*rbworK_LALESERV ALESERV MF=L       list form
SRBWORK_LALESERV ALESERV MF=L       list form
SRBWORK_RETCODE DS F                return code from aleserv
SRBWORK_MYASCB DS F                 my own ASCB addr
SRBWORK_REPLY_ADDRESS DC A(0)
SRBWORK_REPLY_LENGTH  DC A(0)
                DC     0D'0'
SRBWORK_VSMLIST_REPLY  DC 8192X'00'
SRBWORK_VSMLIST_REPLY_LENGTH EQU *-SRBWORK_VSMLIST_REPLY
SRBWORKL EQU   *-SRBWORK           length of the work area
         SPACE 1
DDDUMM       DSECT
             SPACE 1
ASM_BUFFER   DSECT                 SOCKET dynamic dsect
ASM_BUFFER_SOCKET    DC A(0)       socket number
ASM_BUFFER_OFFSET    DC A(0)       offset in the buffer
ASM_BUFFER_REMAINDER DC A(0)       remainder length
ASM_BUFFER_          DC A(0)       buffer received length
ASM_BUFFER_BUFFER    DC (MAX_ASM_BUFFER)X'00'
ASM_BUFFER_LENGTH    EQU *-ASM_BUFFER
             SPACE 1
PAGE_SIZE    EQU 4096              page size
*        BPXYSEL  ,
         BPXYSEL  ,
***      USING CRAB,R12            base on crab
         USING ASMDSECT,R7         base on asm
* 19/11/08 SRB callback
ASMIF    CSECT
         LR    R0,R1               save r1
         L     R1,0(,R1)           back asm base
         LA    R1,0(,R1)           off high order byte
         LTR   R1,R1               test it
         JZ    ASMIF_PROLOG        if not created yet
         CLI   ASM_SRB_MODE-ASM_SAVE(R1),1 SRB mode
         JNE   ASMIF_PROLOG        if not created yet
         ST    R14,12(,R13)        return address save
         STM   R2,R12,28(R13)      registers
         L     R14,ASM_SRB_RETURN-ASM_SAVE(,R1)
         ST    R13,4(,R1)          backchain LE DSA
         BR    R14
ASMIF_PROLOG LR R1,R0
         STM   R14,12,12(R13)      save all in higher save
         LARL  R11,DATAASMIF       base on data
         USING (DATAASMIF,DATAASMIFEND),R11 assign base
         L     R7,0(,R1)           back asm base
         LA    R7,0(,R7)           off high order byte
         LTR   R7,R7               test it
         BZ    ASMIF_INIT          if not created yet
* 10/01/12 cleanup register
         SR    R8,R8
         IC    R8,ASM_FUNCTION_CODE
         BRASL R14,ASMIF_PROCESS   call process
         LTR   R8,R8
         BNZ   ASMIF_RETURN_NOCLEANUP
         L     R14,12(,R13)
         LM    R2,R12,28(R13)     back regs
         BALR  R1,R14
ASMIF_RETURN_NOCLEANUP DS 0H
* 10/01/12 cleanup register
         LR    R13,R7              save area adress
         B     ASMIF_EXIT          branch out
         LTORG
ASMIF_INIT DS 0H
*        storage obtain,length=asm_length,checkzero=yes
         STORAGE OBTAIN,LENGTH=ASM_LENGTH,CHECKZERO=YES
         LR    R7,R1               set addr
         LR    R0,R1               same in 0
         CHI   R15,X'14'           already cleared
         JE    ASMIF_CLEARED       jump if cleared
         L     R1,=A(ASM_LENGTH)   length here
         MVCL  R0,R14              clear storage
ASMIF_CLEARED DS 0H
         ST    R7,8(,R13)          chain new save
         ST    R12,ASM_CRAB        save crab
         ST    R13,4(,R7)          save higher save area
         LA    R13,ASM_SAVE        get temp save
         DROP  R7                  drop asm base
         USING ASM_SAVE,R13        base on asm area
         MVC   ASM_TIMX(MDL_TIMXL),MDL_TIMX copy timer exit
         MVC   ASM_ENQL(MDL_ENQLL),MDL_ENQL copy enq list
         LOAD  EP=IEANTCR          load token create
         ST    R0,ASM_IEANTCR      save address
         LOAD  EP=IEANTRT          load token retrieve
         ST    R0,ASM_IEANTRT      save address
         LOAD  EP=IEANTDL          load token delete
         ST    R0,ASM_IEANTDL      save address
         L     R2,PSATOLD          tcb address
         USING TCB,R2              get tcb addr
         L     R14,TCBTIO          get tiot add
         USING TIOT1,R14           base on tiot1
         MVC   ASM_JOBNAME,TIOCNJOB copy jobname
         MVC   ASM_PROGRAMNAME,=CL8' ' init it
* 06/03/12 TESTAUTH DIAGNOSE extension
         MVC   ASM_TESTAUTH,=F'-1' init TESTAUTH
         BRASL R14,TESTAUTH_INTERN  call TESTAUTH
* 06/03/12 TESTAUTH DIAGNOSE extension
         L     R14,TCBRBP          get highest rb pointer
         DROP  R14                 drop reg
         USING RBBASIC,R14         base on rb
ASMIF_RBLOOP TM RBSTAB1,B'11000000' check rb type
         BZ    ASMIF_PRB           branch  if it is a prb
ASMIF_RBNEXT TM RBSTAB2,RBTCBNXT   test link tcb pointer
         BO    ASMIF_PRBOK         branch if it is the last
         L     R14,RBLINK          get rb link
         LTR   R14,R14             test it
         BNZ   ASMIF_RBLOOP        branch if more
         B     ASMIF_PRBOK         branch out if none
ASMIF_PRB L    R15,RBCDE           get cde addr
         LTR   R15,R15             test it
         BZ    ASMIF_RBNEXT        branch if zero
         USING CDENTRY,R15         base on cde
         MVC   ASM_PROGRAMNAME,CDNAME move program name
         DROP  R14,R15             drop temp regs
ASMIF_PRBOK DS 0H
         LR    R15,R7              back asm address
ASMIF_EXIT DS   0H                 back from here
         L     R13,4(,R13)         higher save address
         L     R14,12(,R13)
         LM    R2,R12,28(R13)     back regs
         BALR  R1,R14
         DROP  R13
.EPLOG   ANOP
ASMIF_PROCESS BAKR     R14,0       all in stack
         USING ASMDSECT,R7         base on asm
         ST    R7,8(,R13)          chain new save
         ST    R12,ASM_CRAB        save crab
         ST    R13,4(,R7)          save higher save area
         LA    R13,ASM_SAVE        get temp save
         XC    ASM_RC(8),ASM_RC    clear rc
         DROP  R7                drop asm base
         USING ASM_SAVE,R13      base on asm area
         $$    SWITCH=ASM_FUNCTION_CODE,SWTYPE=BINARY, SECT=ASMDSECT,  *
               CASE=(CLEANUP,                                          *
               GETTOKEN,                                               *
               CREATETOKEN,                                            *
               DELETETOKEN,                                            *
               ALLOCATEPAGES,                                          *
               FREEPAGES,                                              *
               ENQ,                                                    *
               DEQ,                                                    *
               SLEEP,                                                  *
               GETECB,                                                 *
               WAIT,                                                   *
               POST,                                                   *
               RESET,                                                  *
               SELECT,                                                 *
               CONNECTSHMEM,                                           *
               DISCONNECTSHMEM,                                        *
               OPER,                                                   *
               WTO,                                                    *
               MALLOC,                                                 *
               FREESTOR,                                               *
               SVC,                                                    *
               ATTACHMVS,                                              *
               CLOCK,                                                  *
               TIMEUSED,                                               *
               TDUMP,                                                  *
               LOGGER,                                                 *
               VTOC,                                                   *
               SRB_,                                                   *
               WLM,                                                    *
               OBTAIN,                                                 *
               TESTAUTH,                                               *
               DIAGNOSE,                                               *
               VSMLIST)
         MVC   ASM_RC,=A(128)      get code
         DC    A(0)
         PR    ,                   return back
         USING ASM_SAVE,R13      base on asm area
*---------------------------------------------------------------------*
* gettoken - ask for the name/token pair                              *
* +0     name pointer                                                 *
* +4     retrieved token address                                      *
* back : r15 = ieantrt return code                                    *
*---------------------------------------------------------------------*
GETTOKEN_CALLED BAKR R14,0
GETTOKEN DS    0H
         LM    R2,R3,ASM_PARMS     name/token pointers
         LR    R1,R2               same in r1
         BRASL R14,COPYSTR         copy it
         LA    R2,ASM_WORK         addr in work
* 17/11/11 GetToken in SYSTEM_LEVEL
         MVC   ASM_OPTION,=A(IEANT_SYSTEM_LEVEL)
*        MVC   ASM_OPTION,=A(IEANT_HOME_LEVEL)
* 17/11/11 GetToken in SYSTEM_LEVEL
         L     R15,ASM_IEANTRT     get retrieve addr
*        call  (15),(asm_option,(r2),(r3),asm_rc),   call              *
               MF=(E,ASM_CALLLIST),                                    *
               ID=0001
         CALL  (15),(ASM_OPTION,(R2),(R3),ASM_RC), call                *
               MF=(E,ASM_CALLLIST),                                    *
               ID=0001
         STM   R15,R0,ASM_RC       save return/reason
         PR    ,                   return back
*---------------------------------------------------------------------*
* createtoken - create a system level name/token pair                 *
* +0     name pointer                                                 *
* +4     retrieved token address                                      *
* back : r15 = ieantcr return code                                    *
*---------------------------------------------------------------------*
CREATETOKEN_CALLED BAKR R14,0
CREATETOKEN DS 0H
* 21/04/08 name/token service in user/problem state
***      MVC   ASM_OPTION(8),=A(IEANT_SYSTEM_LEVEL,IEANT_NOPERSIST)
         MVC   ASM_OPTION(8),=A(IEANT_HOME_LEVEL,IEANT_NOPERSIST)
         L     R15,ASM_IEANTCR     create address
         LM    R2,R3,ASM_PARMS     nam/token pointers
         LR    R1,R2               same in r1
         BRASL R14,COPYSTR         copy it
         LA    R2,ASM_WORK         addr in work
*        call  (15),(asm_option,(r2),(r3),asm_option+4,asm_rc),        *
               MF=(E,ASM_CALLLIST),                                    *
               ID=0002
         CALL  (15),(ASM_OPTION,(R2),(R3),ASM_OPTION+4,ASM_RC),        *
               MF=(E,ASM_CALLLIST),                                    *
               ID=0002
         STM   R15,R0,ASM_RC       save return/reason
         PR    ,                   return back
*---------------------------------------------------------------------*
* deletetoken - delete a system level name/token pair                 *
* +0     name pointer                                                 *
* back : r15 = ieantdl return code                                    *
*---------------------------------------------------------------------*
DELETETOKEN DS 0H
*        modeset mode=sup        supervisor state
         MODESET MODE=SUP        supervisor state
         MVC   ASM_OPTION,=A(IEANT_HOME_LEVEL)
         L     R15,ASM_IEANTDL     delete address
*        $$setkey key=zero,save=asm_key key key=zero and save it
***      $$SETKEY KEY=ZERO,SAVE=ASM_KEY key key=zero and save it
         L     R2,ASM_PARMS        name pointer
         LR    R1,R2               same in r1
         BRASL R14,COPYSTR         copy it
         LA    R2,ASM_WORK         addr in work
*        call  (15),(asm_option,(r2),asm_rc), call                     *
               MF=(E,ASM_CALLLIST),                                    *
               ID=0003
         CALL  (15),(ASM_OPTION,(R2),ASM_RC), call                     *
               MF=(E,ASM_CALLLIST),                                    *
               ID=0003
         STM   R15,R0,ASM_RC       save return/reason
*        $$setkey back,save=asm_key key key=zero and save it
***      $$SETKEY BACK,SAVE=ASM_KEY key key=zero and save it
*        modeset mode=prob       supervisor state
         MODESET MODE=PROB       supervisor state
         PR    ,                   return back
* 21/04/08 name/token service in user/problem state
*---------------------------------------------------------------------*
* allocatepages - allocate pages on page bndry for shmem serv         *
* +0     size required                                                *
* back : r15 = storage return code                                    *
*---------------------------------------------------------------------*
ALLOCATEPAGES DS    0H
         LM    R2,R3,ASM_PARMS     requested size and address
         A     R2,=A(PAGE_SIZE-1)  add page size
         N     R2,=X'0FFFF000'     and round
*        storage obtain,                                               *
               LENGTH=(R2),                                            *
               ADDR=0(,R3),                                            *
               BNDRY=PAGE,                                             *
               LOC=(ANY,ANY)
         STORAGE OBTAIN,                                               *
               LENGTH=(R2),                                            *
               ADDR=0(,R3),                                            *
               BNDRY=PAGE,                                             *
               LOC=(ANY,ANY)
         ST    R15,ASM_RC          save return/reason
         PR    ,                   return back
*---------------------------------------------------------------------*
* freepages - free pages on page bndry for shmem serv                 *
* +0     size  to free                                                *
* +4     address                                                      *
* back : r15 = ieantcr return code                                    *
*---------------------------------------------------------------------*
FREEPAGES DS   0H
         LM    R2,R3,ASM_PARMS     requested size and address
         A     R2,=A(PAGE_SIZE-1)  add page size
         N     R2,=X'0FFFF000'     and round
*        storage release,                                              *
               LENGTH=(R2),                                            *
               ADDR=(R3)
         STORAGE RELEASE,                                              *
               LENGTH=(R2),                                            *
               ADDR=(R3)
         ST    R15,ASM_RC          save return/reason
         PR    ,                   return back
*---------------------------------------------------------------------*
* enq -  enq exclusive for reource                                    *
* +0     major name                                                   *
* +4     minor name                                                   *
* +8     minor name length                                            *
* +c     max wait in milli sec                                        *
* back : r15 = ieantcr return code                                    *
*---------------------------------------------------------------------*
ENQ      DS    0H
         LM    R2,R5,ASM_PARMS    requested size and address
         AGO   .UNCOND
*
*  onyl uncond wait here
*
         LTR   R5,R5              test wait time
*only    bz    enq_uncond         if infinite wait uncond
         B     ENQ_UNCOND         if infinite wait uncond
         SR    R0,R0              clear r0
         LR    R1,R5              here the max time
         D     R0,=A(10)          divide it
         ST    R1,ASM_PARMS       save it
ENQ_LOOP DS 0H
*        enq   ((r2),(r3),e,(r4),systems),ret=use,                     *
               MF=(E,ASM_ENQL)
         ENQ   ((R2),(R3),E,(R4),SYSTEMS),RET=USE,                     *
               MF=(E,ASM_ENQL)
         LTR   R15,R15            test return
         BZ    ENQ_XX             branch if ok
         SR    R14,R14            clear reg
         IC    R14,3(15)          get code
         LR    R15,R14            here also
         CH    R14,=Y(4)          test return code
         BH    ENQ_XX             branc if error
         BL    ENQ_00             here also ok
         LTR   R5,R5              test time left
         BNP   ENQ_FF             if no more time
         BRASL R14,SLEEP_INTERN   to sleep
         S     R5,ASM_PARMS       decr it
         B     ENQ_LOOP          try again
.UNCOND  DS    0H
ENQ_UNCOND DS 0H
*        enq   ((r2),(r3),e,(r4),systems),ret=none,                    *
               MF=(E,ASM_ENQL)
         ENQ   ((R2),(R3),E,(R4),SYSTEMS),RET=NONE,                    *
               MF=(E,ASM_ENQL)
         LTR   R15,R15           test rc
         BZ    ENQ_00            branch if ok
         ICM   R15,15,0(R15)     get code
         N     R15,=X'000000FF'  get it proper
         B     ENQ_XX            branch out
ENQ_00   SR    R15,R15           clear reg
         B     ENQ_XX            branch out
ENQ_08   LA    R15,8             get code
         B     ENQ_XX            branch out
ENQ_FF   L     R15,=F'-1'        get code
ENQ_XX   ST    R15,ASM_RC       back code
         PR    ,                   branch back
*---------------------------------------------------------------------*
* deq -  deq resource                                                 *
* +0     major name                                                   *
* +4     minor name                                                   *
* +8     minor name length                                            *
* back : r15 = ieantcr return code                                    *
*---------------------------------------------------------------------*
DEQ      LM    R2,R4,ASM_PARMS     get parms
*        deq   ((r2),(r3),(r4),systems),ret=none,                      *
               MF=(E,ASM_ENQL)     deq resoure
         DEQ   ((R2),(R3),(R4),SYSTEMS),RET=NONE,                      *
               MF=(E,ASM_ENQL)     deq resoure
         LTR   R15,R15           test rc
         BZ    DEQ_XX            branch if ok
         ICM   R15,15,0(R15)     get code
         N     R15,=X'000000FF'  get it proper
DEQ_XX   ST    R15,ASM_RC        save code
         PR    ,                   return back
*---------------------------------------------------------------------*
* SVC -  SVC call                                                     *
* +0     SVC number                                                   *
* +4     parm list                                                    *
* back : r15 = ieantcr return code                                    *
*---------------------------------------------------------------------*
SVC      LM    R0,R1,ASM_PARMS     get parms
         LR    R2,R0              get SVC
         EX    R2,SVC_EXE         exec SVC
SVC_XX   ST    R15,ASM_RC        save code
         PR    ,                 return back
*---------------------------------------------------------------------*
* attachmvs - ATTACH an MVS subtask as processs                       *
* +0     program name length                                          *
* +4     program name                                                 *
* +8     parm length                                                  *
* +12    parm                                                         *
* back : r15 = ieantcr return code                                    *
*---------------------------------------------------------------------*
ATTACHMVS LM   R2,R5,ASM_PARMS     get parms
*        call  bpx1atm,                                                *
               ((R2),                                                  *
               (R3),                                                   *
               (R4),                                                   *
               (R5),                                                   *
               =A(0),                                                  *
               =A(0),                                                  *
               ASM_BPX1_RETVAL,                                        *
               ASM_BPX1_RETCODE,                                       *
               ASM_BPX1_RSNCODE),                                      *
               VL,MF=(E,ASM_BPX1)
         CALL  BPX1ATM,                                                *
               ((R2),                                                  *
               (R3),                                                   *
               (R4),                                                   *
               (R5),                                                   *
               =A(0),                                                  *
               =A(0),                                                  *
               ASM_BPX1_RETVAL,                                        *
               ASM_BPX1_RETCODE,                                       *
               ASM_BPX1_RSNCODE),                                      *
               VL,MF=(E,ASM_BPX1)
         L     R15,ASM_BPX1_RETCODE get reason
         ST    R15,ASM_REASON    save it
         L     R15,ASM_BPX1_RETVAL  get code
         ST    R15,ASM_RC        save it
         PR    ,                 return back
         PR    ,                 return back
*---------------------------------------------------------------------*
* clock - ask for STCK                                                *
* +0     stck reply addres                                            *
*---------------------------------------------------------------------*
CLOCK    L     R2,ASM_PARMS       get parms
         STCK  0(R2)              get clock
         SR    R15,R15
         PR    ,
*---------------------------------------------------------------------*
* timeused return the used CPU time in long long MIC                  *
* +0     timeused reply address                                       *
*---------------------------------------------------------------------*
TIMEUSED L     R2,ASM_PARMS       get parms
*        timeused storadr=(r2),cpu=TOD,LINKAGE=SYSTEM
         TIMEUSED STORADR=(R2),CPU=TOD,LINKAGE=SYSTEM
         LM   R0,R1,0(R2)          get tod
         SRDL R0,12                proper pos
         STM  R0,R1,0(R2)          back in MIC
         SR    R15,R15
         PR    ,
*---------------------------------------------------------------------*
* issue an IEATDUMP                                                   *
* +0     name pattern                                                 *
* +4     dump title
* +8     DDNAME flag
*---------------------------------------------------------------------*
TDUMP    MVC   ASM_TDUMP_NAME(L'TDUMP_DEF_NAMEL+1),TDUMP_DEF_NAME
         MVC   ASM_TDUMP_DESC(L'TDUMP_DEF_DESCL+1),TDUMP_DEF_DESC
         L     R1,ASM_PARMS       get parms
         LTR   R1,R1              test
         JZ    TDUMP_NAME_OK      if o.k.
         LA    R3,ASM_TDUMP_NAME  target
         BRASL R14,STRLEN         length
         LTR   R15,R15            test length
         JNP   TDUMP_NAME_OK      if default
         CHI   R15,100            o.k ?
         JL    TDUMP_NAME         jump if o.k
         LHI   R15,100            set def
TDUMP_NAME STC R15,ASM_TDUMP_NAME store
         BCTR  R15,0              decr
         EX    R15,TDUMP_COPY     copy
TDUMP_NAME_OK DS 0H
         L     R1,ASM_PARMS+4     get parms
         LTR   R1,R1              test length
         JZ    TDUMP_DESC_OK      if ok
         LA    R3,ASM_TDUMP_DESC  target
         BRASL R14,STRLEN         length
         LTR   R15,R15            test length
         JNP   TDUMP_DESC_OK      if default
         CHI   R15,100            o.k ?
         JL    TDUMP_DESC         jump if o.k
         LHI   R15,100            set def
TDUMP_DESC STC R15,ASM_TDUMP_DESC store
         BCTR  R15,0              decr
         EX    R15,TDUMP_COPY     copy
* 19/12/11 IEATDUMP with DDNAME
TDUMP_DESC_OK DS 0H
  If  (CLC,ASM_PARMS+8,NE,ZERO)
*        IEATDUMP DDNAME=ASM_TDUMP_NAME+1,                             *
               HDR=ASM_TDUMP_DESC,                                     *
               MF=(E,ASM_IEATDUMP,COMPLETE)
         IEATDUMP DDNAME=ASM_TDUMP_NAME+1,                             *
               HDR=ASM_TDUMP_DESC,                                     *
               MF=(E,ASM_IEATDUMP,COMPLETE)
  Else
* 05/10/07 STORE IEATDUMP REASON CODE
*        IEATDUMP dsn=ASM_TDUMP_NAME,                                  *
               HDR=ASM_TDUMP_DESC,                                     *
               MF=(E,ASM_IEATDUMP,COMPLETE)
         IEATDUMP DSN=ASM_TDUMP_NAME,                                  *
               HDR=ASM_TDUMP_DESC,                                     *
               MF=(E,ASM_IEATDUMP,COMPLETE)
  Endif
* 19/12/11 IEATDUMP with DDNAME
         ST    R15,ASM_RC
         ST    R0,ASM_REASON
         LTR   R15,R15
         BZ    TDUMP_NODUMP
TDUMP_NODUMP DS 0H
* 05/10/07 store IEATDUMP reason code
         PR    ,                 return back
* 18/11/05 LOGGER support
* 13/01/06 browse logger
*---------------------------------------------------------------------*
* LOGGER support                                                      *
* +0 0 connect to logger stream                                       *
*   -1 discoonect                                                     *
*    1 log a request                                                  *
*    2 read logger from oldtoyoung                                    *
*    3 read log from youngtoold (parm+8 contain addr , length)        *
*    a stream to log                                                  *
* +4 stream or logger name address                                    *
* +8 length of the stream                                             *
* +c time stemp field pointer                                         *
*    +0 binary time value in .01 sec                                  *
*    +4 DATE in YYYYDDD    char format                                *
*---------------------------------------------------------------------*
LOGGER   LM    R2,R4,ASM_PARMS     get parms
         L     R5,ASM_PARMS+16     get time
         SR    R15,R15             clear return
         LTR   R2,R2               test code
         JM    LOGGER_DISCO        disconnect
         JP    LOGGER_LOG          log
         LTR   R4,R4               test length
         JNP   LOGGER_08           return if not o.k.
         MVC   ASM_STREAMNAME,BLANKS init stream name
         CHI   R4,L'ASM_STREAMNAME TEST LENGTH
         JL    *+8                  jump if ok.k
         LHI   R4,L'ASM_STREAMNAME GET LENGTH
         AHI   R4,-1               decr it
         EX    R4,LOGGER_SETSTREAM set stream
         CLC   ASM_STREAMNAME,BLANKS active
         JE    LOGGER_08           if no stream name
         XC    ASM_STREAMTOKEN,ASM_STREAMTOKEN
*        ixgconn request=connect,                                      *
               STREAMNAME=ASM_STREAMNAME,                              *
               STREAMTOKEN=ASM_STREAMTOKEN,                            *
               AUTH=WRITE,                                             *
               ANSAREA=ASM_ANSAREA,                                    *
               ANSLEN==A(L'ASM_ANSAREA),                               *
               RETCODE=ASM_RC,                                         *
               MF=(E,ASM_IXGCONN)
         IXGCONN REQUEST=CONNECT,                                      *
               STREAMNAME=ASM_STREAMNAME,                              *
               STREAMTOKEN=ASM_STREAMTOKEN,                            *
               AUTH=WRITE,                                             *
               ANSAREA=ASM_ANSAREA,                                    *
               ANSLEN==A(L'ASM_ANSAREA),                               *
               RETCODE=ASM_RC,                                         *
               MF=(E,ASM_IXGCONN)
         LTR   R15,R15             test code
         JNZ   LOGGER_ERROR
*        stimer wait,bintvl=logger_onesec wait a sec
***      STIMER WAIT,BINTVL=LOGGER_ONESEC wait a sec
         J     LOGGER_00           jump out
LOGGER_DISCO DS 0H
         NC    ASM_STREAMTOKEN,ASM_STREAMTOKEN
         JZ    LOGGER_XX           jump if no
*        ixgconn request=disconnect,                                   *
               STREAMTOKEN=ASM_STREAMTOKEN,                            *
               ANSAREA=ASM_ANSAREA,                                    *
               ANSLEN==A(L'ASM_ANSAREA),                               *
               RETCODE=ASM_RC,                                         *
               MF=(E,ASM_IXGCONN)
         IXGCONN REQUEST=DISCONNECT,                                   *
               STREAMTOKEN=ASM_STREAMTOKEN,                            *
               ANSAREA=ASM_ANSAREA,                                    *
               ANSLEN==A(L'ASM_ANSAREA),                               *
               RETCODE=ASM_RC,                                         *
               MF=(E,ASM_IXGCONN)
         LTR   R15,R15             test code
         JNZ   LOGGER_ERROR        jump out
         J     LOGGER_00           jump back
LOGGER_LOG DS 0H
         NC    ASM_STREAMTOKEN,ASM_STREAMTOKEN
         JZ    LOGGER_XX           return if not
         CHI   R2,1                check if log
         JH    LOGGER_BROWSE       jump if browse
         LTR   R4,R4               test length
         JNP   LOGGER_08           jump if not positive
         LTR   R3,R3               test data
         JZ    LOGGER_08           jump if not data
         ST    R4,ASM_LOGGER_LENGTH save length
*        ixgwrite buffer=(r3),                                         *
               BLOCKLEN=ASM_LOGGER_LENGTH,                             *
               MODE=ASYNCNORESPONSE,                                   *
               ANSAREA=ASM_ANSAREA,                                    *
               ANSLEN==A(L'ASM_ANSAREA),                               *
               STREAMTOKEN=ASM_STREAMTOKEN,                            *
               MF=(E,ASM_IXGWRITE)
         IXGWRITE BUFFER=(R3),                                         *
               BLOCKLEN=ASM_LOGGER_LENGTH,                             *
               MODE=ASYNCNORESPONSE,                                   *
               ANSAREA=ASM_ANSAREA,                                    *
               ANSLEN==A(L'ASM_ANSAREA),                               *
               STREAMTOKEN=ASM_STREAMTOKEN,                            *
               MF=(E,ASM_IXGWRITE)
         J     LOGGER_XX           jump if ok
* 13/01/06 Logger Browse
LOGGER_BROWSE DS  0H
         LTR  R3,R3                test addr pointer
         JZ    LOGGER_08           jump if zero
         LTR   R4,R4               test length addr
         JZ    LOGGER_08           jump if zero
         XC    0(4,R3),0(R3)       no addr
         XC    0(4,R4),0(R4)       no length
         CLC   ASM_LOGGER_BUFFER,ZERO check buff
         JNZ   LOGGER_BROWSE_STARTED jump if alaredy got
         MVC   ASM_LOGGER_BUFFLEN,LOGGER_MAX_BUFFER
         L     R4,ASM_LOGGER_BUFFLEN get length
*        storage obtain,length=(r4)
         STORAGE OBTAIN,LENGTH=(R4)
         LTR   R15,R15             test return
         JNZ   LOGGER_08           if no storage
         ST    R1,ASM_LOGGER_BUFFER save buffer address
         MVC   ASM_LOGGER_BUFFER_OFFSET,=A(0)
         CHI   R2,2                oldest requested
         JNE   LOGGER_BROWSE_START_YOUNGEST start youngest
         CLC   ZERO,ASM_PARMS+12   active
         JNE   LOGGER_BROWSE_START_OLDEST_ALL jump if not
*        IXGBRWSE REQUEST=START,                                       *
               OLDEST,                                                 *
               STREAMTOKEN=ASM_STREAMTOKEN,                            *
               BROWSETOKEN=ASM_LOGGER_BROWSE_TOKEN,                    *
               MODE=SYNC,                                              *
               VIEW=ACTIVE,                                            *
               RETCODE=ASM_RC,                                         *
               RSNCODE=ASM_REASON,                                     *
               ANSAREA=ASM_ANSAREA,                                    *
               ANSLEN==A(L'ASM_ANSAREA),                               *
               MF=(E,ASM_IXGBRWSE)
         IXGBRWSE REQUEST=START,                                       *
               OLDEST,                                                 *
               STREAMTOKEN=ASM_STREAMTOKEN,                            *
               BROWSETOKEN=ASM_LOGGER_BROWSE_TOKEN,                    *
               MODE=SYNC,                                              *
               VIEW=ACTIVE,                                            *
               RETCODE=ASM_RC,                                         *
               RSNCODE=ASM_REASON,                                     *
               ANSAREA=ASM_ANSAREA,                                    *
               ANSLEN==A(L'ASM_ANSAREA),                               *
               MF=(E,ASM_IXGBRWSE)
         J     LOGGER_BROWSE_START_CHECK check start
LOGGER_BROWSE_START_OLDEST_ALL DS 0H
*        IXGBRWSE REQUEST=START,                                       *
               OLDEST,                                                 *
               STREAMTOKEN=ASM_STREAMTOKEN,                            *
               BROWSETOKEN=ASM_LOGGER_BROWSE_TOKEN,                    *
               MODE=SYNC,                                              *
               VIEW=ALL,                                               *
               RETCODE=ASM_RC,                                         *
               RSNCODE=ASM_REASON,                                     *
               ANSAREA=ASM_ANSAREA,                                    *
               ANSLEN==A(L'ASM_ANSAREA),                               *
               MF=(E,ASM_IXGBRWSE)
         IXGBRWSE REQUEST=START,                                       *
               OLDEST,                                                 *
               STREAMTOKEN=ASM_STREAMTOKEN,                            *
               BROWSETOKEN=ASM_LOGGER_BROWSE_TOKEN,                    *
               MODE=SYNC,                                              *
               VIEW=ALL,                                               *
               RETCODE=ASM_RC,                                         *
               RSNCODE=ASM_REASON,                                     *
               ANSAREA=ASM_ANSAREA,                                    *
               ANSLEN==A(L'ASM_ANSAREA),                               *
               MF=(E,ASM_IXGBRWSE)
         J     LOGGER_BROWSE_START_CHECK check start
LOGGER_BROWSE_START_YOUNGEST DS 0H
         CHI   R2,3                oldest requested
         JNE   LOGGER_BROWSE_START_SEARCH   start search
         CLC   ZERO,ASM_PARMS+12   active
         JNE   LOGGER_BROWSE_START_YOUNGEST_ALL jump if not
*        IXGBRWSE REQUEST=START,                                       *
               YOUNGEST,                                               *
               STREAMTOKEN=ASM_STREAMTOKEN,                            *
               BROWSETOKEN=ASM_LOGGER_BROWSE_TOKEN,                    *
               MODE=SYNC,                                              *
               VIEW=ACTIVE,                                            *
               RETCODE=ASM_RC,                                         *
               RSNCODE=ASM_REASON,                                     *
               ANSAREA=ASM_ANSAREA,                                    *
               ANSLEN==A(L'ASM_ANSAREA),                               *
               MF=(E,ASM_IXGBRWSE)
         IXGBRWSE REQUEST=START,                                       *
               YOUNGEST,                                               *
               STREAMTOKEN=ASM_STREAMTOKEN,                            *
               BROWSETOKEN=ASM_LOGGER_BROWSE_TOKEN,                    *
               MODE=SYNC,                                              *
               VIEW=ACTIVE,                                            *
               RETCODE=ASM_RC,                                         *
               RSNCODE=ASM_REASON,                                     *
               ANSAREA=ASM_ANSAREA,                                    *
               ANSLEN==A(L'ASM_ANSAREA),                               *
               MF=(E,ASM_IXGBRWSE)
         J     LOGGER_BROWSE_START_CHECK check start
LOGGER_BROWSE_START_YOUNGEST_ALL  DS 0H
*        IXGBRWSE REQUEST=START,                                       *
               YOUNGEST,                                               *
               STREAMTOKEN=ASM_STREAMTOKEN,                            *
               BROWSETOKEN=ASM_LOGGER_BROWSE_TOKEN,                    *
               MODE=SYNC,                                              *
               VIEW=ALL,                                               *
               RETCODE=ASM_RC,                                         *
               RSNCODE=ASM_REASON,                                     *
               ANSAREA=ASM_ANSAREA,                                    *
               ANSLEN==A(L'ASM_ANSAREA),                               *
               MF=(E,ASM_IXGBRWSE)
         IXGBRWSE REQUEST=START,                                       *
               YOUNGEST,                                               *
               STREAMTOKEN=ASM_STREAMTOKEN,                            *
               BROWSETOKEN=ASM_LOGGER_BROWSE_TOKEN,                    *
               MODE=SYNC,                                              *
               VIEW=ALL,                                               *
               RETCODE=ASM_RC,                                         *
               RSNCODE=ASM_REASON,                                     *
               ANSAREA=ASM_ANSAREA,                                    *
               ANSLEN==A(L'ASM_ANSAREA),                               *
               MF=(E,ASM_IXGBRWSE)
         J     LOGGER_BROWSE_START_CHECK check start
* 16/07/10 LOGGER browse TIME search
LOGGER_BROWSE_START_SEARCH DS 0H
         LHI   R2,2                oldest requested
         LTR  R5,R5
         JZ   LOGGER_BROWSE
         XC    ASM_LOGGER_CONVVAL,ASM_LOGGER_CONVVAL
         MVC   ASM_LOGGER_CONVVAL(4),0(R5)
         PACK  ASM_LOGGER_CONVVAL+8(5),4(9,R5)
         XC    ASM_LOGGER_CONVVAL+12,ASM_LOGGER_CONVVAL+12
*        convtod TIMETYPE=bin,datetype=yyyyddd,todval=asm_logger_stck, *
               CONVVAL=ASM_LOGGER_CONVVAL,MF=(E,ASM_LOGGER_CONVTOD)
         CONVTOD TIMETYPE=BIN,DATETYPE=YYYYDDD,TODVAL=ASM_LOGGER_STCK, *
               CONVVAL=ASM_LOGGER_CONVVAL,MF=(E,ASM_LOGGER_CONVTOD)
**       CLC   ZERO,ASM_PARMS+12   active
**       JNE   LOGGER_BROWSE_START_SEARCH_ALL  jump if not
*        IXGBRWSE REQUEST=START,                                       *
               STREAMTOKEN=ASM_STREAMTOKEN,                            *
               BROWSETOKEN=ASM_LOGGER_BROWSE_TOKEN,                    *
               MODE=SYNC,                                              *
               VIEW=ACTIVE,                                            *
               SEARCH=ASM_LOGGER_STCK,                                 *
               GMT=NO,                                                 *
               RETCODE=ASM_RC,                                         *
               RSNCODE=ASM_REASON,                                     *
               ANSAREA=ASM_ANSAREA,                                    *
               ANSLEN==A(L'ASM_ANSAREA),                               *
               MF=(E,ASM_IXGBRWSE)
         IXGBRWSE REQUEST=START,                                       *
               STREAMTOKEN=ASM_STREAMTOKEN,                            *
               BROWSETOKEN=ASM_LOGGER_BROWSE_TOKEN,                    *
               MODE=SYNC,                                              *
               VIEW=ACTIVE,                                            *
               SEARCH=ASM_LOGGER_STCK,                                 *
               GMT=NO,                                                 *
               RETCODE=ASM_RC,                                         *
               RSNCODE=ASM_REASON,                                     *
               ANSAREA=ASM_ANSAREA,                                    *
               ANSLEN==A(L'ASM_ANSAREA),                               *
               MF=(E,ASM_IXGBRWSE)
         J     LOGGER_BROWSE_START_CHECK check start
LOGGER_BROWSE_START_SEARCH_ALL  DS 0H
*        IXGBRWSE REQUEST=START,                                       *
               STREAMTOKEN=ASM_STREAMTOKEN,                            *
               BROWSETOKEN=ASM_LOGGER_BROWSE_TOKEN,                    *
               MODE=SYNC,                                              *
               VIEW=ALL,                                               *
               SEARCH=ASM_LOGGER_STCK,                                 *
               GMT=NO,                                                 *
               RETCODE=ASM_RC,                                         *
               RSNCODE=ASM_REASON,                                     *
               ANSAREA=ASM_ANSAREA,                                    *
               ANSLEN==A(L'ASM_ANSAREA),                               *
               MF=(E,ASM_IXGBRWSE)
         IXGBRWSE REQUEST=START,                                       *
               STREAMTOKEN=ASM_STREAMTOKEN,                            *
               BROWSETOKEN=ASM_LOGGER_BROWSE_TOKEN,                    *
               MODE=SYNC,                                              *
               VIEW=ALL,                                               *
               SEARCH=ASM_LOGGER_STCK,                                 *
               GMT=NO,                                                 *
               RETCODE=ASM_RC,                                         *
               RSNCODE=ASM_REASON,                                     *
               ANSAREA=ASM_ANSAREA,                                    *
               ANSLEN==A(L'ASM_ANSAREA),                               *
               MF=(E,ASM_IXGBRWSE)
* 16/07/10 LOGGER browse TIME search
LOGGER_BROWSE_START_CHECK DS 0H
         CHI   R15,4               maybe o
         JH    LOGGER_ERROR        error
         SR    R15,R15             clear reg
         ST    R2,ASM_LOGGER_DIRECTION savedirection
LOGGER_BROWSE_STARTED DS 0H
         CLC   ASM_LOGGER_BUFFER_OFFSET,ZERO  check offset
         JNE   LOGGER_READCURSOR_INBLOCK jump if in the block
         MVC   ASM_LOGGER_BUFFER_OFFSET,=A(8) init offset
         ICM   R3,15,ASM_LOGGER_BUFFER   get buffer addr
         CLI   ASM_LOGGER_DIRECTION+3,2  oldtoyoung requested
         JNE   LOGGER_READCURSOR_YOUNGEST start youngest
*        IXGBRWSE REQUEST=READCURSOR,                                  *
               DIRECTION=OLDTOYOUNG,                                   *
               STREAMTOKEN=ASM_STREAMTOKEN,                            *
               BROWSETOKEN=ASM_LOGGER_BROWSE_TOKEN,                    *
               BUFFER=(R3),                                            *
               BUFFLEN=ASM_LOGGER_BUFFLEN,                             *
               MULTIBLOCK=YES,                                         *
               RETBLOCKINFO=YES,                                       *
               MODE=SYNC,                                              *
               RETCODE=ASM_RC,                                         *
               ANSAREA=ASM_ANSAREA,                                    *
               ANSLEN==A(L'ASM_ANSAREA),                               *
               RSNCODE=ASM_REASON,                                     *
               MF=(E,ASM_IXGBRWSE)
         IXGBRWSE REQUEST=READCURSOR,                                  *
               DIRECTION=OLDTOYOUNG,                                   *
               STREAMTOKEN=ASM_STREAMTOKEN,                            *
               BROWSETOKEN=ASM_LOGGER_BROWSE_TOKEN,                    *
               BUFFER=(R3),                                            *
               BUFFLEN=ASM_LOGGER_BUFFLEN,                             *
               MULTIBLOCK=YES,                                         *
               RETBLOCKINFO=YES,                                       *
               MODE=SYNC,                                              *
               RETCODE=ASM_RC,                                         *
               RSNCODE=ASM_REASON,                                     *
               ANSAREA=ASM_ANSAREA,                                    *
               ANSLEN==A(L'ASM_ANSAREA),                               *
               MF=(E,ASM_IXGBRWSE)
         J     LOGGER_READCURSOR_CHECK check start
LOGGER_READCURSOR_YOUNGEST DS 0H
*        IXGBRWSE REQUEST=READCURSOR,                                  *
               DIRECTION=YOUNGTOOLD,                                   *
               STREAMTOKEN=ASM_STREAMTOKEN,                            *
               BROWSETOKEN=ASM_LOGGER_BROWSE_TOKEN,                    *
               BUFFER=(R3),                                            *
               BUFFLEN=ASM_LOGGER_BUFFLEN,                             *
               MULTIBLOCK=YES,                                         *
               RETBLOCKINFO=YES,                                       *
               MODE=SYNC,                                              *
               RETCODE=ASM_RC,                                         *
               RSNCODE=ASM_REASON,                                     *
               ANSAREA=ASM_ANSAREA,                                    *
               ANSLEN==A(L'ASM_ANSAREA),                               *
               MF=(E,ASM_IXGBRWSE)
         IXGBRWSE REQUEST=READCURSOR,                                  *
               DIRECTION=YOUNGTOOLD,                                   *
               STREAMTOKEN=ASM_STREAMTOKEN,                            *
               BROWSETOKEN=ASM_LOGGER_BROWSE_TOKEN,                    *
               BUFFER=(R3),                                            *
               BUFFLEN=ASM_LOGGER_BUFFLEN,                             *
               MULTIBLOCK=YES,                                         *
               RETBLOCKINFO=YES,                                       *
               MODE=SYNC,                                              *
               RETCODE=ASM_RC,                                         *
               RSNCODE=ASM_REASON,                                     *
               ANSAREA=ASM_ANSAREA,                                    *
               ANSLEN==A(L'ASM_ANSAREA),                               *
               MF=(E,ASM_IXGBRWSE)
LOGGER_READCURSOR_CHECK DS 0H
         CHI   R15,8               maybe o
         JL    LOGGER_READCURSOR_OK if acceptable
         JH    LOGGER_ERROR        error
         CHI   R0,X'0848'          check r0
         JNE   LOGGER_ERROR        if not, error
LOGGER_READCURSOR_NOMORE DS 0H
         ICM   R3,15,ASM_LOGGER_BUFFER get buffer address
         JZ    LOGGER_READCURSOR_END_NOFREE
         L     R4,ASM_LOGGER_BUFFLEN get length
*        storage release,addr=(r3),length=(r4)
         STORAGE RELEASE,ADDR=(R3),LENGTH=(R4)
         XC    ASM_LOGGER_BUFFER,ASM_LOGGER_BUFFER clear
LOGGER_READCURSOR_END_NOFREE DS 0H
*        IXGBRWSE REQUEST=END,                                         *
               STREAMTOKEN=ASM_STREAMTOKEN,                            *
               BROWSETOKEN=ASM_LOGGER_BROWSE_TOKEN,                    *
               RETCODE=ASM_RC,                                         *
               RSNCODE=ASM_REASON,                                     *
               ANSAREA=ASM_ANSAREA,                                    *
               ANSLEN==A(L'ASM_ANSAREA),                               *
               MF=(E,ASM_IXGBRWSE)
         IXGBRWSE REQUEST=END,                                         *
               STREAMTOKEN=ASM_STREAMTOKEN,                            *
               BROWSETOKEN=ASM_LOGGER_BROWSE_TOKEN,                    *
               RETCODE=ASM_RC,                                         *
               RSNCODE=ASM_REASON,                                     *
               ANSAREA=ASM_ANSAREA,                                    *
               ANSLEN==A(L'ASM_ANSAREA),                               *
               MF=(E,ASM_IXGBRWSE)
        CHI    R15,4               test code
        JH     LOGGER_ERROR        jump if in error
        LA     R15,4               set code
        ST     R15,ASM_RC          set code
        J      LOGGER_XX           jump back
LOGGER_READCURSOR_OK      DS 0H
LOGGER_READCURSOR_INBLOCK DS 0H
        L      R4,ASM_LOGGER_BUFFER_OFFSET get offset
        ICM    R3,15,ASM_LOGGER_BUFFER block address
        JZ     LOGGER_08           if no addr
        USING  IXGBRMHD,R3         base on header
        LA     R4,0(R3,R4)         actual block address
        USING  IXGBRMLT,R4         base on log block
        MVC    ASM_LOGGER_BUFFER_OFFSET,IXGBRMLT_NEXTOFFSET next off
        TM     IXGBRMLT_FLAGS,IXGBRMLT_DATARETURNED data returned
        JO     LOGGER_READCURSOR_DATA   no more data
***LOOP*J      LOGGER_READCURSOR_INBLOCK try it
        J      LOGGER_READCURSOR_NOMORE  it
LOGGER_READCURSOR_DATA DS 0H
        TM     IXGBRMLT_FLAGS,IXGBRMLT_RETBLOCKINFO info returned
        JZ     LOGGER_READCURSOR_NOINFO
        LA     R5,IXGBRMLT_RETINFOEND  start of data
        J      LOGGER_READCURSOR_DO jump to nextoffset
LOGGER_READCURSOR_NOINFO DS 0H
        LA     R5,IXGBRMLT_COMMONEND adress of the block
LOGGER_READCURSOR_DO DS 0H
       CLC     ASM_LOGGER_BUFFER_OFFSET,IXGBRMHD_LASTBRMLTOFFSET
       JNE     LOGGER_READCURSOR_NOTLAST
***    MVC     IXGBRMLT_NEXTOFFSET,ZERO
LOGGER_READCURSOR_NOTLAST DS 0H
        L      R6,IXGBRMLT_NEXTOFFSET length of block
        AR     R6,R3               next addr
        SR     R6,R5               length of block
        LM     R1,R2,ASM_PARMS+4   get addr buff
        ST     R5,0(R1)            save addr
        ST     R6,0(R2)            save length
        J     LOGGER_00           jump out
LOGGER_ERROR DS 0H
*       DC     A(0)
LOGGER_08 LA   R15,8               get code
         J     LOGGER_XX           jump out
LOGGER_00 SR   R15,R15             set code
LOGGER_XX DS 0H
         ST    R15,ASM_RC       back code
         ST    R0,ASM_REASON    back reason
         PR     ,
         DROP  R3,R4               drop regs
* 21/11/05 VTOC access
*---------------------------------------------------------------------*
* VTOC access                                                         *
* +0 request type                                                     *
*    0 connect , open                                                 *
*    1 next , gives back the next entry                               *
* +4 address of the DDNAME allocated to the volume                    *
* +8 address of the dataset mask to retrieve  , +0 length (1 byte)    *
* +c address of are to return the DSCB                                *
* return : 0 DSCB returned , and more exist                           *
*          4 last DSCB returned, no more                              *
*          8 no DSCB found                                            *
*         12 error occured                                            *
*---------------------------------------------------------------------*
         USING IHADCB,R6           base on DCB
         USING IEFJFCBN,R5         base on JFCB
         USING FCL_MAP,ASM_VTOC_FCL  base on FCL
         USING BFL_MAP,ASM_VTOC_BFL  base on bfl
         USING CVAFFILT_MAP,ASM_VTOC_CVAFFILT base on CVAFFILT
VTOC     LM    R2,R5,ASM_PARMS     get parms
         XC    ASM_REASON,ASM_REASON  clear resaon
         LTR   R2,R2               test request
         JP    VTOC_NEXT           if next request
         JM    VTOC_GOT_LAST       if the last entry
         LA    R0,1                first parm
         LTR   R3,R3               test DDNAME addr
         JZ    VTOC_ERR_PARM       jump if no DDNAME
         LA    R0,2                second parm
         LTR   R4,R4               test name
         JZ    VTOC_ERR_PARM       jump if invalid
         LA    R0,3                third parm
         LTR   R5,R5               test DSCB return address
         JZ    VTOC_ERR_PARM       jump if invalid
         MVC   ASM_VTOC_DDNAME,0(3) copy DDNAME
         MVC   ASM_VTOC_FILTER,0(R4) copy filter
*        storgae obtain,LENGTH=VTOC_MODEL_DCB_LENGTH+184,LOC=BELOW
         STORAGE OBTAIN,LENGTH=VTOC_MODEL_DCB_LENGTH+184,LOC=BELOW
         ST    R1,ASM_VTOC_DCB     save
         LTR   R6,R1               test storage
         JZ    VTOC_ERR_STORAGE    if no storage
         LHI   R2,VTOC_MODEL_DCB_LENGTH-1 get length
         EX    R2,VTOC_COPY_DCB    copy dcb
         MVC   DCBDDNAM,ASM_VTOC_DDNAME copy DDNAME
         LA    R5,VTOC_MODEL_DCB_LENGTH(,R6) after DCB
         OI    ASM_VTOC_OPENLIST,X'80' indicate end of list
         LA    R4,(VTOC_MODEL_DCB_LENGTH+176)(,R6) open list
         LA    R1,4(,R4)           exit list addr
         STCM  R1,7,DCBEXLSA       save exit list addr
         ST    R5,0(R1)            save exit addr
         MVI   0(R1),X'87'         indicate JFCB exit
         MVI   0(R4),X'80'         open list
*        rdjfcb ((r6)),mf=(e,(r4))
         RDJFCB ((R6)),MF=(E,(R4))
         LTR   R15,R15             test code
         JNZ   VTOC_ERR_RDJFCB     jump if RDJFCB error
         MVI   JFCBDSNM,X'04'      init first byte
         MVC   JFCBDSNM+1(43),JFCBDSNM copy rest
*        open  ((r6),input),mf=(e,(r4)),type=j
         OPEN  ((R6),INPUT),MF=(E,(R4)),TYPE=J
         TM    DCBOFLGS,DCBOFOPN   test open flag
         JZ    VTOC_ERR_OPEN       jump if open error
         MVC   ASM_VTOC_CVAFFILT(VTOC_MODEL_CVAFFL),VTOC_MODEL_CVAFFILT
         XC    ASM_VTOC_FCL(FCLHDLEN+FCLDSNEL),ASM_VTOC_FCL   init fcl
         MVC   FCLID,=CL4'FCL'       set fcl id
         MVC   FCLCOUNT,=H'1'        set number of fcl elements
         LA    R2,FCLHDEND           r2 addr of fcl elemnent
         USING FCLDSN,R2             establish addressability
         MVC   FCLDSNLG,ASM_VTOC_FILTER set length
         LA    R1,ASM_VTOC_FILTER+1  filter address
         ST    R1,FCLDSNA            set addr(dsn pattern)
         MVC   FCLDSNLG,ASM_VTOC_FILTER set length
         DROP  R2
         XC    ASM_VTOC_BFL(BFLHLN+BFLELN),ASM_VTOC_BFL clear
         MVI   BFLHNOE,1             one buffe
         OI    BFLHFL,BFLHDSCB       identify as dscb bufr elemnt
         LA    R2,ASM_VTOC_BFL+BFLHLN first buffer
         USING BFLE,R2               establish addressability
         OI    BFLEFL,BFLECHR        request cchhr on return
         MVI   BFLELTH,F1DSCB_SIZE   set bufr lngth to full dscb
         LA    R1,ASM_VTOC_BUFFER    get buffer address
         ST    R1,BFLEBUF            set addr(dscb buffer)
         DROP  R2
         SR    R1,R1               clear r1
         ICM   R1,7,DCBDEBA        get deb addr
         ST    R1,CVDEB            save in CVAF parm list
*        cvaffilt access=read,                                         *
               FCL=ASM_VTOC_FCL,                                       *
               BUFLIST=ASM_VTOC_BFL,                                   *
               MF=(E,ASM_VTOC_CVAFFILT)
         CVAFFILT ACCESS=READ,                                         *
               FCL=ASM_VTOC_FCL,                                       *
               BUFLIST=ASM_VTOC_BFL,                                   *
               MF=(E,ASM_VTOC_CVAFFILT)
VTOC_CHECK  LTR R15,R15            test return
         JZ    VTOC_GOT_LAST       jump if the last one
         CHI   R15,4               check if rc4
         JNE   VTOC_CVAFFILT_ERR   jump if filter error
         CLI   CVSTAT,STAT001      nothing found
         JE    VTOC_08             jump if it is
         CLI   CVSTAT,STAT064      more
         JNE   VTOC_CVAFFILT_ERR   jump if any other error
         J     VTOC_COPY_DSCB      jump to copy DSCB
VTOC_NEXT      DS                  0H
*        cvaffilt access=resume,                                       *
               MF=(E,ASM_VTOC_CVAFFILT)
         CVAFFILT ACCESS=RESUME,                                       *
               MF=(E,ASM_VTOC_CVAFFILT)
         J     VTOC_CHECK          jump to check
VTOC_GOT_LAST DS 0H
         NC    ASM_VTOC_DCB,ASM_VTOC_DCB already closed
         JZ    VTOC_00             jump if so
*        cvaffilt accESS=RLSE,fcl=0,BUFLIST=0,FLTAREA=NOKEEP,          *
               MF=(E,ASM_VTOC_CVAFFILT)
         CVAFFILT ACCESS=RLSE,FCL=0,BUFLIST=0,FLTAREA=NOKEEP,          *
               MF=(E,ASM_VTOC_CVAFFILT)
*        close ((r6)),mf=(e,asm_vtoc_openlist),mode=31
         CLOSE ((R6)),MF=(E,ASM_VTOC_OPENLIST),MODE=31
*        storage release,addr=asm_vtoc_dcb,                            *
               LENGTH=VTOC_MODEL_DCB_LENGTH+184
         STORAGE RELEASE,ADDR=ASM_VTOC_DCB,                            *
               LENGTH=VTOC_MODEL_DCB_LENGTH+184
         XC    ASM_VTOC_DCB,ASM_VTOC_DCB release DCB arae
         LA    R15,4               get return code
         J     VTOC_COPY_DSCB+2    jump to copy
VTOC_COPY_DSCB SR R15,R15          clear rc
         ICM   R0,15,ASM_PARMS+12  target address
         LHI   R1,F1DSCB_SIZE      get DSCB size
         LA    R2,ASM_VTOC_BUFFER  from address
         LR    R3,R1               same length
         MVCL  R0,R2               copy DSCB
         J     VTOC_XX             jump out
VTOC_ERR_RDJFCB    MVI ASM_REASON+2,6 JFCB error
         J     VTOC_12             jump out
VTOC_ERR_OPEN    MVI ASM_REASON+2,5 open error
         J     VTOC_12             jump out
VTOC_ERR_STORAGE MVI ASM_REASON+2,4 no storage
         J     VTOC_12             jump out
VTOC_CVAFFILT_ERR DS 0H
         MVC   ASM_REASON+3(1),CVSTAT copy status code
         J     VTOC_12             jump out
VTOC_ERR_PARM STC R0,ASM_REASON+2 set reason
         J     VTOC_12             jump out
VTOC_12  LA    R15,12              get code
         J     VTOC_XX             jump out
VTOC_08  LA    R15,8               get code
         J     VTOC_XX             jump out
VTOC_00  SR    R15,R15             get code
VTOC_XX  DS    0H                  return back
         ST    R15,ASM_RC          back code
         PR    ,                   return back
* 19/11/08 SRB callback
*---------------------------------------------------------------------*
* SRB call                                                            *
* call an SRB routine and from the SRB call back a C function         *
* +0 function addres to call                                          *
* +4 paramter area address                                            *
*                                                                     *
*---------------------------------------------------------------------*
SRB_     DS   0H
         PR    ,
* 24/11/08 WLM enclave
*---------------------------------------------------------------------*
* WLM service create/delete enclave                                   *
* +0     SUBSYSTEM name                                               *
* back : r15 = return code                                            *
*----------------- ---------------------------------------------------*
WLM      PR    ,
* 24/11/08 WLM enclave
* 04/03/10 OBTAIN DSCB
*---------------------------------------------------------------------*
* OBTAIN routine                                                      *
* +0 dataset name                                                     *
* +4 volser                                                           *
* +8 F1DSCB area                                                      *
*---------------------------------------------------------------------*
         SPACE 1
OBTAIN   DS    0H
         LM    R1,R2,ASM_PARMS
         LHI   R15,-1
         ICM   R1,15,ASM_PARMS
         JZ    OBTAIN_XX
  If  (CLI,0(R1),GE,C' ')
         OC    0(44,R1),BLANKS
         ICM   R1,15,ASM_PARMS+4
         JZ    OBTAIN_XX
         OC    0(6,R1),BLANKS
         MVC   ASM_CAMLST(CAMLST_L),CAMLST copy camlst
         MVC   ASM_CAMLST+4(12),ASM_PARMS
* 16/08/11 OBTAIN EADSCB=OK for EAV volumes
*        OBTAIN asm_camlst,EADSCB=OK ISSUE OBTAIN
         OBTAIN ASM_CAMLST,EADSCB=OK ISSUE OBTAIN
* 16/08/11 OBTAIN EADSCB=OK for EAV volumes
  Else
* 10/09/12 CAMLST SEEK for OBTAIN
         ICM   R1,15,ASM_PARMS+4
         JZ    OBTAIN_XX
         OC    0(6,R1),BLANKS
         MVC   ASM_CAMLST(CAMLST_L),CAMLST_SEEK copy camlst
         MVC   ASM_CAMLST+4(12),ASM_PARMS
* 16/08/11 OBTAIN EADSCB=OK for EAV volumes
*        OBTAIN asm_camlst,EADSCB=OK ISSUE OBTAIN
         OBTAIN ASM_CAMLST,EADSCB=OK ISSUE OBTAIN
  Endif
* 10/09/12 CAMLST SEEK for OBTAIN
OBTAIN_XX DS 0H
         ST    R15,ASM_RC          back code
         PR    ,
         SPACE 1
* 04/03/10 OBTAIN DSCB
*---------------------------------------------------------------------*
* sleep  wait for n ms                                                *
* +0     wait time in ms                                              *
* back : r15 = ieantcr return code                                    *
*---------------------------------------------------------------------*
SLEEP_INTERN BAKR R14,0          all in linkage stack
SLEEP    L     R1,ASM_PARMS      get in msec
         LTR   R1,R1             test it
         BZ    SLEEP_00          if no time
         BNP   SLEEP_08          if invalid parm
         BRASL R14,MILLSEC       call mill sec conv
*        stimer wait,micvl=asm_sleep     wait here
         STIMER WAIT,MICVL=ASM_SLEEP     wait here
SLEEP_00 SR    R15,R15           clear return
         B     SLEEP_XX          branch out
SLEEP_08 LA    R15,8             get code
SLEEP_XX ST    R15,ASM_RC        set rc
         PR    ,                 return back
*---------------------------------------------------------------------*
* getecb get a work ecb address                                       *
* back : r15 = ieantcr return code                                    *
*---------------------------------------------------------------------*
GETECB   L     R2,ASM_PARMS      get in msec
         L     R3,ASM_WORKECBP   get pointer
         CLC   0(4,R2),ZERO      init or free
         BNE   GETECB_FREE       if free
         L     R3,ASM_WORKECBS   get start
GETECB_FIND_LOOP DS 0H
         CLC   0(4,R3),ZERO      empty
         BE    GETECB_FIND       branch if yes
         LA    R3,20(,R3)        inr addr
         C     R3,ASM_WORKECBE   check imit
         BNL   GETECB_08         if in error
         B     GETECB_FIND_LOOP try next
GETECB_FIND DS 0H
         MVC   0(4,R3),=F'-1'    reserved flag
         LA    R3,4(,R3)         proper start
         ST    R3,0(R2)          store it
         B     GETECB_00         branch out
GETECB_FREE L  R3,0(,R2)         get addr
         SH    R3,=Y(4)          decr it
         C     R3,ASM_WORKECBS   if lower
         BL    GETECB_08         error
         C     R3,ASM_WORKECBE   if lower
         BH    GETECB_08         error
         XC    0(20,R3),0(R3)    clean slot
GETECB_00 SR   R15,R15           clear reg
         B     GETECB_XX         branch out
GETECB_08 LA   R15,8             get code
GETECB_XX ST   R15,ASM_RC        save rc
         PR    ,                 return back
*---------------------------------------------------------------------*
* wait for an event or give up after n ms                             *
* +0     wait time in ms                                              *
* +4     ecb pointer's                                                *
* back : r15 = ieantcr return code                                    *
*---------------------------------------------------------------------*
WAIT     L     R2,ASM_PARMS      get parms
         LTR   R2,R2             test time
         BZ    WAIT_TIME_VALID   if zero valid
         BM    WAIT_TIME_INVALID if infinite
         C     R2,ADAY           check it
         BL    WAIT_TIME_VALID   if o.k.
WAIT_TIME_INVALID DS 0H
         L     R2,ADAY           get it
WAIT_TIME_VALID DS 0H
         ST    R2,ASM_PARMS      save time value
         LA    R2,ASM_PARMS+4    next ECB
         LA    R3,ASM_EVENT0_ECBP-4 next pointer
         LA    R4,4              max count
         LA    R5,ASM_CALLLIST   temp addr
         XC    ASM_CALLLIST(32),ASM_CALLLIST
WAIT_ECBP_LOOP CLC 0(4,R2),ZERO  end of list
         BE    WAIT_ECBP_LOOP_END branch if it is
         LA    R3,4(,R3)         next ECBP
         L     R1,0(R2)          get ECB addr
         TM    0(R1),X'40'       is it posted
         BO    WAIT_COMPLETED    if complete
*26/04/04
         NC    0(4,R1),=X'7FFFFFFF' off wait flag
         ST    R1,0(,R3)          store in the list
*25/08/04
*        enq   (wait_maj,0(r3),e,4,step),mf=(e,asm_enql)
         ENQ   (WAIT_MAJ,0(R3),E,4,STEP),MF=(E,ASM_ENQL)
         ST    R3,0(,R5)         save it
         LA    R5,4(,R5)         next
*25/08/04
         LA    R2,4(,R2)         next ECBP
         BCT   R4,WAIT_ECBP_LOOP try it
WAIT_ECBP_LOOP_END DS 0H
         OI    0(R3),X'80'       high order on
         LA    R4,ASM_TIMER_ECB  get timer ecb
         ST    R4,ASM_TIMER_ECBP set it
         XC    ASM_TIMER_ECB,ASM_TIMER_ECB cear ecb
         LA    R5,ASM_TIMX       get timx addr
         L     R1,ASM_PARMS      time here
         BRASL R14,MILLSEC       call millsec routine
*        stimer real,(r5),micvl=asm_sleep get address
         STIMER REAL,(R5),MICVL=ASM_SLEEP get address
*        wait  ecblist=asm_timer_ecbp,linkage=system
         WAIT  ECBLIST=ASM_TIMER_ECBP,LINKAGE=SYSTEM
*        ttimer cancel           cancel timer
         TTIMER CANCEL           cancel timer
*25/08/04
         LA    R15,ASM_EVENT0_ECBP get ecb pointer
         LA    R14,4             max ecb
WAIT_POSTED_LOOP ICM R1,15,0(R15) get next
         LA    R1,0(,R1)         get rid of high order
         LTR   R1,R1             test it
         BZ    WAIT_POSTED_TIME  if no more
         TM    0(R1),X'40'       is it posted
         BO    WAIT_COMPLETED    if complete
         LA    R15,4(,R15)       next ecbp
         BCT   R14,WAIT_POSTED_LOOP try it
WAIT_POSTED_TIME DS 0H
         TM    ASM_TIMER_ECB,X'40' timer occured
         BO    WAIT_08           if timer expired
WAIT_COMPLETED DS 0H
         LTR   R1,R1             test r1
         BZ    WAIT_00           branch over
         NC    0(4,R1),=X'3FFFFFFF' clear wait and post flags
WAIT_00  SR    R15,R15           clear code
         ICM   R15,15,0(R1)      get code
         B     WAIT_XX           branch back
WAIT_08  L     R15,=F'-1'        get code
WAIT_XX  ST    R15,ASM_RC        back code
*25/08/04
         LA    R5,ASM_CALLLIST    get ecb pointer
         LA    R4,4              max ecb
WAIT_DEQ_LOOP ICM R3,15,0(R5) get next
         BZ    WAIT_DEQ_DONE     if no more
         NC    0(4,R3),=X'7FFFFFFF' off high bit
*        deq   (wait_maj,0(r3),4,step),mf=(e,asm_enql)
         DEQ   (WAIT_MAJ,0(R3),4,STEP),MF=(E,ASM_ENQL)
         LA    R5,4(,R5)       next ecbp
         BCT   R4,WAIT_DEQ_LOOP try it
WAIT_DEQ_DONE DS 0H
*        LR    R15,R5            back rc
         PR    ,                 return back
*        DROP  R2
*---------------------------------------------------------------------*
* post for an event                                                   *
* +0     ECB pointer                                                  *
* +4     post code                                                    *
* back : r15 = returrn code                                           *
*---------------------------------------------------------------------*
         USING EVENT_TOKEN,R4    base on even token
POST     LM    R4,R5,ASM_PARMS   get parms
         L     R6,0(R4)            get ecb
         LTR   R6,R6               test ECB
         BM    POSTBR_X            if already in wait
         N     R6,=X'3FFFFFFF'     off wait post bit
         L     R1,=X'40000000'     get posted
         OR    R1,R5               get code
         CS    R6,R1,0(R4)         check it
         BZ    POSTED_X            branch if ok
         LTR   R6,R6               test wait bit
         BM    POSTBR_X            branch if in wait
         N     R6,=X'40000000'     test if already posted
         BZ    POSTBR_X            branch to post if not
         STCM  R5,7,1(R4)          set new code
         B     POSTED_X            branch out
POSTBR_X DS 0H
*        post  (r4),(r5)           issue POST
         POST  (R4),(R5)           issue POST
POSTED_X MVC   ASM_RC,ZERO         clear rc
         B     POST_XX             branch out
POSTERR_X MVC  ASM_RC,=A(8)        set code
POST_XX  L     R15,ASM_RC          get code
         PR    ,                   return
         DROP  R4
*---------------------------------------------------------------------*
* reset reset event  ecb                                              *
* +0     event token pointer                                          *
* back : r15 = returrn code                                           *
*---------------------------------------------------------------------*
         USING EVENT_TOKEN,R4    base on even token
RESET    LM    R4,R5,ASM_PARMS   get parms
         L     R3,EVENT_TOKEN_ECBP   get ecb pointer
****     xc    0(4,r3),0(r3)      leave as it is
         SR    R15,R15            clear ret
         L     R15,ASM_RC          get code
         PR    ,                   return
         DROP  R4
* 06/03/12 TESTAUTH DIAGNOSE extension
*---------------------------------------------------------------------*
* TESTAUTH test if APF authorized                                     *
* back : r15 = returrn code                                           *
*---------------------------------------------------------------------*
TESTAUTH_INTERN BAKR R14,0
TESTAUTH  DS  0H
  If  (ICM,R15,15,ASM_TESTAUTH,M)
*         testauth fctn=1
          TESTAUTH FCTN=1
          ST  R15,ASM_TESTAUTH
  Else
          ICM  R15,15,ASM_TESTAUTH
  Endif
          PR   ,
* 06/03/12 TESTAUTH DIAGNOSE extension
*---------------------------------------------------------------------*
* DIAGNOSE test if APF authorized                                     *
* +0     diag x'0204' code                                            *
* +4     reply area address
* back : r15 = returrn code                                           *
*---------------------------------------------------------------------*
DIAGNOSE LM    R2,R3,ASM_PARMS     get parms
  Do  LABEL=DIAGNOSE_LEAVE
    If  (ICM,R15,15,ASM_TESTAUTH,Z)
*        modeset mode=sup,key=zero supervisor state
         MODESET MODE=SUP,KEY=ZERO supervisor state
      If  (NC,ASM_DIAGNOSE_FLAG,=A(ASM_DIAGNOSE_FIX),Z)
        If  (ICM,R4,15,ASM_DIAGNOSE_ADDR,Z)
*        storage obtain,length=asm_diagnose_length,bndry=page
         STORAGE OBTAIN,LENGTH=ASM_DIAGNOSE_LENGTH,BNDRY=PAGE
          If  (LTR,R15,R15,NZ)
            Asmleave  DIAGNOSE_LEAVE
          Endif
  ST  R1,ASM_DIAGNOSE_ADDR
  LR  R4,R1
        Endif
* PGSER R,FIX,A=(R4),EA=4095(,R4),ECB=0
  PGSER R,FIX,A=(R4),EA=4095(,R4),ECB=0
        If  (LTR,R15,R15,NZ)
          Asmleave  DIAGNOSE_LEAVE
        Endif
  OC  ASM_DIAGNOSE_FLAG,=A(ASM_DIAGNOSE_FIX)
      Endif
      If  (NC,ASM_DIAGNOSE_FLAG,=A(ASM_DIAGNOSE_DONTSWAP),Z)
* sysevent dontswap
  SYSEVENT DONTSWAP
        If  (LTR,R15,R15,NZ)
          Asmleave  DIAGNOSE_LEAVE
        Endif
  OC  ASM_DIAGNOSE_FLAG,=A(ASM_DIAGNOSE_DONTSWAP)
      Endif
  LR  R3,R2
  LRA R2,0(,R4)
  DIAG R2,R3,X'0204'
  L    R0,ASM_PARMS+4
  LHI  R1,4095
  LR  R5,R1
  LR   R2,R4
  MVCL R0,R4
      If  (NC,ASM_DIAGNOSE_FLAG,=A(ASM_DIAGNOSE_KEEP),Z)
* SYSEVENT OKSWAP
  SYSEVENT OKSWAP
  NC   ASM_DIAGNOSE_FLAG,=A(ASM_DIAGNOSE_ALL-ASM_DIAGNOSE_DONTSWAP)
* PGSER R,FREE,A=(R4),EA=4095(,R4),ECB=0
  PGSER R,FREE,A=(R4),EA=4095(,R4),ECB=0
  NC   ASM_DIAGNOSE_FLAG,=A(ASM_DIAGNOSE_ALL-ASM_DIAGNOSE_FIX)
*        storage release,length=asm_diagnose_length,addr=(r2)
         STORAGE RELEASE,LENGTH=ASM_DIAGNOSE_LENGTH,ADDR=(R2)
  XC    ASM_DIAGNOSE_ADDR,ASM_DIAGNOSE_ADDR
      Endif
* modeset mode=prob,key=nzero
  MODESET MODE=PROB,KEY=NZERO
  SR   R15,R15
    Endif
  Enddo
 PR ,
***********************************************************************
* VSMLIST                                                             *
*  function : the routine  builds an SRB and schedules it             *
*             issue a VSMLIST commandinthe traget address space       *
*             XM communication                                        *
* parms :                                                             *
* +0 target ascb address                                              *
* +4 reply area                                                       *
* +8 reply area  length                                               *
***********************************************************************
VSMLIST  L     R2,ASM_PARMS       gett parms
         ST    R2,ASM_VSMLIST_ASCBADDR save ASCB addr
         L     R1,X'10'            get cvt addr
         L     R1,CVTTCBP-CVT(R1)  get TCB list addr
         MVC   ASM_VSMLIST_MYTCB,4(R1) save the TCB addr
         L     R1,12(R1)           get my ASCB addr
         ST    R1,ASM_VSMLIST_MYASCB save ascb addr
         MVC   ASM_VSMLIST_MYASCBID,ASCBASID-ASCB(R1)
  Do
*        MODESET MODE=SUP,KEY=ZERO  into key0 sup state
         MODESET MODE=SUP,KEY=ZERO  into key0 sup state
*        GETMAIN RU,LV=SRBSIZE+SRBWORKL,SP=245 from SQA
         GETMAIN RU,LV=SRBSIZE+SRBWORKL,SP=245 from SQA
         ST    R1,ASM_VSMLIST_STORAGE
         LR    R9,R1               base on SRB area
         USING SRBSECT,R9          assign base
         LA    R8,SRBSIZE(,R9)     base on srb work area
         USING SRBWORK,R8          assign base on srb work area
         XC    SRBSECT(SRBSIZE),SRBSECT clear area
         MVC   SRBID,=CL4'SRB'     set id
         MVC   SRBASCB,ASM_VSMLIST_ASCBADDR  save ascb addr
         MVC   SRBPASID,ASM_VSMLIST_MYASCBID set my ascb id
         MVC   SRBPTCB,ASM_VSMLIST_MYTCB set TCB addr for PURGEDQ
         LARL  R2,XMSRB            get SRB addr
         BSM   R2,0                set mode
         ST    R2,SRBEP            move entry
         LARL  R2,XMFRR            get FRR addr
         BSM   R2,0                set mode
         ST    R2,SRBRMTR          set it resoure manager
         ST    R2,SRBFRRA           and FRR
         ST    R8,SRBPARM          same as work area
         MVC   SRBWORK_REPLY_ADDRESS(8),ASM_PARMS+4 set addr/length
*        ALESERV EXTRACTH,STOKEN=srbwork_stoken,                       *
               MF=(E,SRBWORK_LALESERV)
         ALESERV EXTRACTH,STOKEN=SRBWORK_STOKEN,                       *
               MF=(E,SRBWORK_LALESERV)
    If  (LTR,R15,R15,NZ)
      Asmleave
    Endif
         XC    SRBWORK_ECB,SRBWORK_ECB clear srbwork_ecb
         MVC   SRBWORK_MYASCB,ASM_VSMLIST_MYASCB move ascb addr
*        SETLOCK TEST,TYPE=LOCAL,BRANCH=(HELD,VSMLIST_LOCK)
         SETLOCK TEST,TYPE=LOCAL,BRANCH=(HELD,VSMLIST_LOCK)
*        SETLOCK OBTAIN,TYPE=LOCAL,REGS=USE,MODE=UNCOND
         SETLOCK OBTAIN,TYPE=LOCAL,REGS=USE,MODE=UNCOND
VSMLIST_LOCK    DS 0H
*        SCHEDULE SRB=(R9),SCOPE=GLOBAL schedule the SRB
         SCHEDULE SRB=(R9),SCOPE=GLOBAL schedule the SRB
*        SETLOCK RELEASE,TYPE=LOCAL,REGS=USE
         SETLOCK RELEASE,TYPE=LOCAL,REGS=USE
*        WAIT  ECB=srbwork_ecb wait for SRB completion
         WAIT  ECB=SRBWORK_ECB wait for SRB completion
         MVC   ASM_RC,SRBWORK_RETCODE
         MVC   ASM_REASON,SRBWORK_REPLY_ADDRESS+4
  Enddo
  If  (ICM,R9,15,ASM_VSMLIST_STORAGE,NZ)
*        FREEMAIN RU,A=(R9),LV=SRBSIZE+SRBWORKL,SP=245 free the SRB
         FREEMAIN RU,A=(R9),LV=SRBSIZE+SRBWORKL,SP=245 free the SRB
         XC     ASM_VSMLIST_STORAGE,ASM_VSMLIST_STORAGE
  Endif
*        MODESET MODE=PROB,KEY=NZERO back to user key problem state
         MODESET MODE=PROB,KEY=NZERO back to user key problem state
         PR ,
         TITLE 'XMSRB SRB routine to get back the primary STOKEN'
         SPACE 5
* at entry the SRB routine is in supervisor state , primary ASC
* the regsisters area :
* r0 address of the SRB
* r1 same as SRB parm
* r14 return address
* r15 entry address
         SPACE 1
         USING ASCB,R12
XMSRB    LARL  R11,DATAASMIF       base on data
         LR    R9,R14              save the return addr
         LR    R8,R1               base on the work area
         USING SRBWORK,R8          assign on parm area
         L     R12,PSAAOLD
         LA    R13,SRBWORK_SAVESYS
  Do  LABEL=VSMLOOP
*        ALESERV ADD,STOKEN=SRBWORK_STOKEN,                            *
               ALET=SRBWORK_ALET,CHKEAX=NO,ACCESS=PUBLIC,              *
               AL=PASN,                                                *
               MF=(E,SRBWORK_LALESERV)
         ALESERV ADD,STOKEN=SRBWORK_STOKEN,                            *
               ALET=SRBWORK_ALET,CHKEAX=NO,ACCESS=PUBLIC,              *
               AL=PASN,                                                *
               MF=(E,SRBWORK_LALESERV)
    If  (LTR,R15,R15,NZ)
      Asmleave
    Endif  BRANCH if not ok
         XC   SRBWORK_VSMLIST_REPLY(4),SRBWORK_VSMLIST_REPLY
         SETLOCK TEST,TYPE=LOCAL,BRANCH=(HELD,XMSRB_LOCKHELD)
         SETLOCK OBTAIN,TYPE=LOCAL,REGS=USE,MODE=UNCOND
XMSRB_LOCKHELD  DS 0H
         LHI  R15,4
         LM   R6,R7,SRBWORK_REPLY_ADDRESS
        L   R12,ASCBRCTP
        DROP R12
    Do  WHILE=(CHI,R15,EQ,4)
*        VSMLIST SP=PVT,tcb=((r12),all),space=free,                    *
               LOC=31,LINKAGE=BRANCH,                                  *
               PVTSP=ALL,                                              *
               WKAREA=(SRBWORK_VSMLIST_REPLY,                          *
               SRBWORK_VSMLIST_REPLY_LENGTH)
         VSMLIST SP=PVT,TCB=((R12),ALL),SPACE=FREE,                    *
               LOC=31,LINKAGE=BRANCH,                                  *
               PVTSP=ALL,                                              *
               WKAREA=(SRBWORK_VSMLIST_REPLY,                          *
               SRBWORK_VSMLIST_REPLY_LENGTH)
      If  (CHI,R15,LE,4)
        SAC 512
         SYSSTATE ASCENV=AR indicate for macro's
         LM    R0,R1,SRBWORK_VSMLIST_REPLY+4
         LAM   R0,R0,ZERO
         LAM   R6,R6,SRBWORK_ALET
         MVCL  R6,R0
         SYSSTATE ASCENV=P  indicate for macro's
         SAC 0
      Else
        Asmleave  VSMLOOP
      Endif
    Enddo
         ST     R15,SRBWORK_RETCODE
    STM   R6,R7,SRBWORK_REPLY_ADDRESS
  Enddo
*        SETLOCK RELEASE,TYPE=LOCAL,REGS=USE
         SETLOCK RELEASE,TYPE=LOCAL,REGS=USE
*        ALESERV delete,alet=srbwork_alet,                             *
               CHKEAX=NO,                                              *
               MF=(E,SRBWORK_LALESERV)
         ALESERV DELETE,ALET=SRBWORK_ALET,                             *
               CHKEAX=NO,                                              *
               MF=(E,SRBWORK_LALESERV)
    If  (LTR,R15,R15,NZ)
          DC A(0)
    Endif
            LA    R1,SRBWORK_ECB      get srbwork_ecb addr
            L     R2,SRBWORK_ECB      get srbwork_ecb contents
            L     R15,=X'40000000'    get post code
  If  (LTR,R2,R2,NM)
    Do  WHILE=(CS,R2,R15,NZ,SRBWORK_ECB)
    Enddo
  Else
         LR     R10,R15            get post code
         SR    R0,R0               CLEAR srbwork_ecb KEY REG
         ICM   R10,8,=X'80'        indicate XM post
         L     R7,=X'80000000'     indicate XMPOST
         L     R12,=X'80000000'    indicate XM post
         LA    R11,SRBWORK_ECB     get the srbwork_ecb addr
         OR    R11,R7
         L     R13,SRBWORK_MYASCB  address of the ascb
         L     R15,CVTPTR          get cvt addr
         L     R15,CVT0PT01-CVT(,R15) get post addr
         BALR  R14,R15
         LARL  R11,DATAASMIF       base on data
  Endif
         BR    R9                  branch back to the control program
*
* SRB FRR error routine
*
XMFRR    DC    0D'0'
         BR    R14                back to the control program
*---------------------------------------------------------------------*
* bselect   determines the number of ready file descriptors           *
* int        select(int nfds, fd_set *readfds, fd_set *writefds,      *
*            fd_set *exceptfds, const struct timeval *timeout);       *
* back : r15 = return code        0                                   *
*---------------------------------------------------------------------*
         SPACE 1
SELECT  DS    0H                 CALL TO CHECK
         LM    R2,R6,ASM_PARMS     get parms
         ST    R2,ASM_BPX1_NUMFDS  store num of FDs
         LR    R0,R2               number of fd's
         SRL   R0,3                divide by 8
         ST    R0,ASM_BPX1_LIST_LENGTH_R store into list
         ST    R0,ASM_BPX1_LIST_LENGTH_W store into list
         ST    R0,ASM_BPX1_LIST_LENGTH_E store into list
         LTR   R3,R3               test first addr
         BNZ   *+14                if o.k.
         LA    R3,ZERO             get zero addr
         XC    ASM_BPX1_LIST_LENGTH_R,ASM_BPX1_LIST_LENGTH_R no r
         LTR   R4,R4               test first addr
         BNZ   *+14                if o.k.
         LA    R4,ZERO             get zero addr
         XC    ASM_BPX1_LIST_LENGTH_W,ASM_BPX1_LIST_LENGTH_E no w
         LTR   R5,R5               test first addr
         BNZ   *+14                if o.k.
         LA    R5,ZERO             get zero addr
         XC    ASM_BPX1_LIST_LENGTH_E,ASM_BPX1_LIST_LENGTH_E no e
         ST    R6,ASM_BPX1_TIMEOUT set timeout
         MVC   ASM_BPX1_OPTION,=A(SEL#BITSBACKWARD) copy option
         XC    ASM_BPX1_RETVAL(12),ASM_BPX1_RETVAL clear return
*        call  bpx1sel,                                                *
               (ASM_BPX1_NUMFDS,                                       *
               ASM_BPX1_LIST_LENGTH_R,                                 *
               (R3),                                                   *
               ASM_BPX1_LIST_LENGTH_W,                                 *
               (R4),                                                   *
               ASM_BPX1_LIST_LENGTH_E,                                 *
               (R5),                                                   *
               ASM_BPX1_TIMEOUT,                                       *
               =A(0),                                                  *
               ASM_BPX1_OPTION,                                        *
               ASM_BPX1_RETVAL,                                        *
               ASM_BPX1_RETCODE,                                       *
               ASM_BPX1_RSNCODE),                                      *
               VL,MF=(E,ASM_BPX1)
         CALL  BPX1SEL,                                                *
               (ASM_BPX1_NUMFDS,                                       *
               ASM_BPX1_LIST_LENGTH_R,                                 *
               (R3),                                                   *
               ASM_BPX1_LIST_LENGTH_W,                                 *
               (R4),                                                   *
               ASM_BPX1_LIST_LENGTH_E,                                 *
               (R5),                                                   *
               ASM_BPX1_TIMEOUT,                                       *
               =A(0),                                                  *
               ASM_BPX1_OPTION,                                        *
               ASM_BPX1_RETVAL,                                        *
               ASM_BPX1_RETCODE,                                       *
               ASM_BPX1_RSNCODE),                                      *
               VL,MF=(E,ASM_BPX1)
         L     R15,ASM_BPX1_RETCODE get reason
         ST    R15,ASM_REASON    save it
         L     R15,ASM_BPX1_RETVAL  get code
         ST    R15,ASM_RC        save it
         PR    ,                 return back
        SPACE 1
*---------------------------------------------------------------------*
* connectshmem connect a target to a share group                      *
* +0     shmem token pointer                                          *
* +4     area address                                                 *
* back : r15 = ieantcr return code                                    *
*---------------------------------------------------------------------*
         USING SHMEM_TOKEN,R2    base on shmem token
         USING  VRL,R4           base on iarvrl
CONNECTSHMEM DS 0H
*        modeset mode=sup        supervisor state
         MODESET MODE=SUP        supervisor state
*        $$setkey key=zero,save=asm_key key key=zero
         $$SETKEY KEY=ZERO,SAVE=ASM_KEY key key=zero
         LM    R2,R3,ASM_PARMS   get parms
         LA    R4,ASM_IARVRL     base on iarvrl area
         XC    0(VRLLEN,R4),0(R4) clear iarvrl dsect
         MVC   VRLSVSA,SHMEM_TOKEN_ADDR copy sourece addr
         L     R5,SHMEM_TOKEN_ASCB get ascb
         USING ASCB,R5           base on ascb
         L     R5,ASCBASSB       get assb addr
         USING ASSB,R5           base on assb
*        aleserv add,stoken=assbstkn,alet=vrlsstkn+4,chkeax=no,        *
               MF=(E,ASM_ALESERVL)
         ALESERV ADD,STOKEN=ASSBSTKN,ALET=VRLSSTKN+4,CHKEAX=NO,        *
               MF=(E,ASM_ALESERVL)
         L     R0,SHMEM_TOKEN_LGTH get length
         A     R0,=A(PAGE_SIZE-1)  add page size
         N     R0,=X'0FFFF000'     and round
         SRL   R0,12             in pages
         ST    R0,VRLNUMPG       number of pages
         L     R5,PSAAOLD        get target ascb
         USING ASCB,R5           base on ascb
         L     R5,ASCBASSB       get assb addr
         USING ASSB,R5           base on assb
*        aleserv add,stoken=assbstkn,alet=vrltstkn+4,chkeax=no,        *
               MF=(E,ASM_ALESERVL)
         ALESERV ADD,STOKEN=ASSBSTKN,ALET=VRLTSTKN+4,CHKEAX=NO,        *
               MF=(E,ASM_ALESERVL)
         ST    R3,VRLTVSA        copy taget address
         ST    R4,ASM_IARVRLA    set addr
         LA    R4,ASM_IARVRLA    set pointer to it
*        iarvserv share,ranglist=(r4),                                 *
               TARGET_VIEW=SHAREDWRITE,                                *
               MF=(E,ASM_IARVSERVL)
         IARVSERV SHARE,RANGLIST=(R4),                                 *
               TARGET_VIEW=SHAREDWRITE,                                *
               MF=(E,ASM_IARVSERVL)
         STM   R15,R0,ASM_RC     save return/reason code
*        $$setkey back,save=asm_key back to user
         $$SETKEY BACK,SAVE=ASM_KEY back to user
*        modeset mode=prob       supervisor state
         MODESET MODE=PROB       supervisor state
         PR
         DROP  R4,R5             drop work regs
*---------------------------------------------------------------------*
* disconnectshmem disconnect from a shared group                      *
* +0     shmem token pointer                                          *
* +4     area address                                                 *
* back : r15 = ieantcr return code                                    *
*---------------------------------------------------------------------*
         USING SHMEM_TOKEN,R2    base on shmem token
         USING  VRL,R4           base on iarvrl
DISCONNECTSHMEM LM R2,R3,ASM_PARMS get parms
         LA    R4,ASM_IARVRLA    set pointer to it
*        modeset mode=sup        supervisor state
         MODESET MODE=SUP        supervisor state
*        $$setkey key=zero,save=asm_key key key=zero
         $$SETKEY KEY=ZERO,SAVE=ASM_KEY key key=zero
*        aleserv delete,alet=vrlsstkn+4,                               *
               MF=(E,ASM_ALESERVL)
         ALESERV DELETE,ALET=VRLSSTKN+4,                               *
               MF=(E,ASM_ALESERVL)
*        aleserv delete,alet=vrltstkn+4,                               *
               MF=(E,ASM_ALESERVL)
         ALESERV DELETE,ALET=VRLTSTKN+4,                               *
               MF=(E,ASM_ALESERVL)
*        iarvserv unshare,ranglist=(r4),                               *
               RETAIN=NO,                                              *
               MF=(E,ASM_IARVSERVL)
         IARVSERV UNSHARE,RANGLIST=(R4),                               *
               RETAIN=NO,                                              *
               MF=(E,ASM_IARVSERVL)
         STM   R15,R0,ASM_RC     save return/reason code
*        $$setkey back,save=asm_key back to user
         $$SETKEY BACK,SAVE=ASM_KEY back to user
*        modeset mode=prob       supervisor state
         MODESET MODE=PROB       supervisor state
         PR
         DROP R4
*---------------------------------------------------------------------*
* cleanup free asm area , delete modules                              *
* back : r15 = ieantcr return code                                    *
*---------------------------------------------------------------------*
CLEANUP  DS    0H
         CLC   ASM_IEANTCR,ZERO    is there ieantcr
         BE    CLEANUP_NOCR        branch if no
         DELETE EP=IEANTCR         delete it
CLEANUP_NOCR DS 0H
         CLC   ASM_IEANTRT,ZERO    is there ieantcr
         BE    CLEANUP_NORT        branch if no
         DELETE EP=IEANTRT         delete it
CLEANUP_NORT DS 0H
         CLC   ASM_IEANTDL,ZERO    is there ieantcr
         BE    CLEANUP_NODL        branch if no
         DELETE EP=IEANTDL         delete it
CLEANUP_NODL DS 0H
CLEANUP_NOTCPIP DS 0H
         SR    R3,R3              clear reg
         ICM   R3,15,ASM_WORKECBS get start
         BZ    CLEANUP_NOCSA     if no csa allocated
*        modeset mode=sup        supervisor state
         MODESET MODE=SUP        supervisor state
*        $$setkey key=zero,save=asm_key key key=zero and save it
         $$SETKEY KEY=ZERO,SAVE=ASM_KEY key key=zero and save it
*        storage release,length=max_ecbs,addr=(r3),key=8,sp=231
         STORAGE RELEASE,LENGTH=MAX_ECBS,ADDR=(R3),KEY=8,SP=231
*        $$setkey back,save=asm_key key key=zero and save it
         $$SETKEY BACK,SAVE=ASM_KEY key key=zero and save it
*        modeset mode=prob       supervisor state
         MODESET MODE=PROB       supervisor state
CLEANUP_NOCSA DS 0H
  If  (NC,ASM_DIAGNOSE_FLAG,=A(ASM_DIAGNOSE_KEEP),O),AND,              *
               (CLC,ASM_TESTAUTH,EQ,ZERO)
* modeset mode=sup,key=zero
  MODESET MODE=SUP,KEY=ZERO
* SYSEVENT OKSWAP
  SYSEVENT OKSWAP
  NC   ASM_DIAGNOSE_FLAG,=A(ASM_DIAGNOSE_ALL-ASM_DIAGNOSE_DONTSWAP)
    If  (ICM,R4,15,ASM_DIAGNOSE_ADDR,NZ)
* PGSER R,FREE,A=(R4),EA=4095(,R4),ECB=0
  PGSER R,FREE,A=(R4),EA=4095(,R4),ECB=0
  NC   ASM_DIAGNOSE_FLAG,=A(ASM_DIAGNOSE_ALL-ASM_DIAGNOSE_FIX)
*        storage release,length=asm_diagnose_length,addr=(r2)
         STORAGE RELEASE,LENGTH=ASM_DIAGNOSE_LENGTH,ADDR=(R2)
  XC    ASM_DIAGNOSE_ADDR,ASM_DIAGNOSE_ADDR
    Endif
* modeset mode=prob,key=nzero
  MODESET MODE=PROB,KEY=NZERO
  Endif
*        storage release,length=asm_length,addr=(r7) release
         STORAGE RELEASE,LENGTH=ASM_LENGTH,ADDR=(R7) release
         SR     R15,R15           clear all
         PR
*---------------------------------------------------------------------*
* oper operator communication                                         *
* +0     area pointer                                                 *
* +4     area length                                                  *
* back : r15 = return code        0 start/modify command              *
*                                 4 stop command                      *
*---------------------------------------------------------------------*
         USING COMLIST,R4        base on comlist
         USING CIBNEXT,R5        base on cib
OPER     DS    0H
         CLC   ASM_COMPTR,ZERO   already init
         BNE   OPER_COMMAND      if already done
         LA    R2,ASM_EXTRACT_L  get list form address
         LA    R3,ASM_COMPTR     comand pointer
*        extract (r3),'S',mf=(e,(r2)),fields=comm extract comm
         EXTRACT (R3),'S',MF=(E,(R2)),FIELDS=COMM extarct comm
         SR    R4,R4             clear r4
         ICM   R4,15,ASM_COMPTR get com ptr
         BZ    OPER_RET_08       if in error
         L     R5,COMCIBPT       get cib pointer
         BRASL R14,OPER_CIB      process data
*        qedit origin=comcibpt,cibctr=9  prepare for comand
         QEDIT ORIGIN=COMCIBPT,CIBCTR=9  prepare for comand
         B     OPER_RET_00       branch out
OPER_COMMAND DS 0H
         SR    R4,R4             clear r4
         ICM   R4,15,ASM_COMPTR get com ptr
         SR    R5,R5             clear it
         ICM   R5,15,COMCIBPT       get cib pointer
         BZ    OPER_COMMAND_WAIT wait if nothing
         CLI   CIBVERB,CIBSTOP   stop commad
         BE    OPER_RET_04       branch if it is
OPER_COMMAND_WAIT DS 0H
         L     R2,COMECBPT       get ecb pointer
         TM    0(R2),X'40'       if posted
         BO    OPER_COMMAND_PROCESS branch if yes
*        wait ecb=(r2)           issue wait
         WAIT ECB=(R2)           issue wait
OPER_COMMAND_PROCESS DS  0H
         L     R5,COMCIBPT       get cib pointer
         CLI   CIBVERB,CIBSTOP   stop commad
         BE    OPER_RET_04       branch if it is
         BRASL R14,OPER_CIB      process it
         B     OPER_RET_XX       branch out
OPER_RET_00 SR R15,R15           clear reg
         B     OPER_RET_XX       branch back
OPER_RET_04 LA R15,4             get code
         B     OPER_RET_XX       branch back
OPER_RET_08 LA R15,8             get code
OPER_RET_XX DS 0H                branch back
         STM   R15,R0,ASM_RC       save return/reason
         PR    ,                 back
OPER_CIB BAKR  R14,0             all in stack
         SR    R15,R15           clear ret
OPER_CIB_DO LTR   R5,R5             test cib
         BZ    OPER_CIB_RET      back if no
         LA    R15,4             get code
         CLI   CIBVERB,CIBSTOP   modify commad
         BE    OPER_CIB_RET      branch if stop
         CLI   CIBVERB,CIBMODFY  modify commad
         BNE   OPER_CIB_FREE     branch if not
         LM    R2,R3,ASM_PARMS   get data length
         LTR   R2,R2             test addr
         BZ    OPER_CIB_FREE     if no data
         LA    R14,CIBDATA       get data
         LH    R15,CIBDATLN      get length
         CR    R3,R15            check length
         BL    *+6               if lower
         LR    R3,R15            set data length
         MVCL  R2,R14            copy text
         MVI   0(R2),X'00'       keep hapy c++
OPER_CIB_FREE DS 0H
*        qedit origin=comcibpt,block=(r5) prepare for comand
         QEDIT ORIGIN=COMCIBPT,BLOCK=(R5) prepare for comand
         ICM   R5,15,0(R5)     next
         BNZ   OPER_CIB_DO       try it
         SR    R15,R15           now ok
OPER_CIB_RET PR ,                back
         DROP  R4                drop it
         DROP  R5                drop cib
*---------------------------------------------------------------------*
* wto  operator communication                                         *
* +0     area pointer                                                 *
* +4     area length                                                  *
* +8     descriptor code                                              *
* back : r15 = return code        0                                   *
*---------------------------------------------------------------------*
WTO      DS    0H
         MVC   ASM_WTOL(MDL_WTOL_L),MDL_WTOL copy wtol
         LM    R2,R4,ASM_PARMS     get parms
         SR    R15,R15             get code
         L     R14,=X'00010000'    code
         SRDL  R14,0(R4)           shit it
         STH   R14,ASM_WTOL+138  higher part
         ST    R15,ASM_WTOL+140  lower part
         LA    R4,ASM_WTOL+4       to addr
         LA    R5,ASM_WTOL_TEXT_LENGTH max text length
         ICM   R3,8,BLANKS         get pad
         MVCL  R4,R2               copy text
*        wto   mf=(e,asm_wtol)     issue wto
         WTO   MF=(E,ASM_WTOL)     issue wto
         SR    R15,R15             test return
         PR    ,                   branch back
*---------------------------------------------------------------------*
* malloc allocate the storage under the jstcb                         *
* +0     area length                                                  *
* +4     rely addr                                                    *
* back : r15 = return code        0                                   *
*---------------------------------------------------------------------*
MALLOC   DS    0H
*        modeset mode=sup        supervisor state
         MODESET MODE=SUP        supervisor state
         USING   TCB,R2          base on tcb
         L     R2,PSATOLD        get tcb
         L     R2,TCBJSTCB       get jstcb addr
         LM    R3,R4,ASM_PARMS   get size reply
         LA    R3,8(,R3)         add head
*        storage obtain,tcbaddr=(r2),length=(r3)
         STORAGE OBTAIN,TCBADDR=(R2),LENGTH=(R3)
         ST    R3,0(R1)          save length
         MVC   4(4,R1),=C'stor'  add id
         LA    R1,8(,R1)         proper addr
         ST    R1,0(,R4)         set back
         LR    R5,R15            save rc
*        modeset mode=prob       supervisor state
         MODESET MODE=PROB       supervisor state
         LR    R15,R5            save rc
         ST    R15,ASM_RC        set result
         PR    ,                 return back
*---------------------------------------------------------------------*
* free   free allocated storage under the jstcb                       *
* +0     area address                                                 *
* back : r15 = return code        0                                   *
*---------------------------------------------------------------------*
FREESTOR DS    0H
*        modeset mode=sup        supervisor state
         MODESET MODE=SUP        supervisor state
         USING   TCB,R2          base on tcb
         L     R2,PSATOLD        get tcb
         L     R2,TCBJSTCB       get jstcb addr
         L     R3,ASM_PARMS      get addr
         SR    R15,R15           clear ret
         LTR   R3,R3             test it
         BNP   FREESTOR_OUT      if nothing to freestor
         SH    R3,=Y(8)          proper addr
         L     R4,0(,R3)         get length
         CLC   4(4,R3),=C'stor'  check it
         BNE   FREESTOR_OUT      if not
*        storage release,tcbaddr=(r2),addr=(r3),length=(r4)
         STORAGE RELEASE,TCBADDR=(R2),ADDR=(R3),LENGTH=(R4)
FREESTOR_OUT LR R5,R15           save rc
*        modeset mode=prob       supervisor state
         MODESET MODE=PROB       supervisor state
         LR    R15,R5            save rc
         ST    R15,ASM_RC        set result
FREESTOR_RET PR ,                return back
FREESTOR_ABEND DC A(0)           abend here
*---------------------------------------------------------------------*
* millsec  convert microsec to millsec and store                      *
*---------------------------------------------------------------------*
MILLSEC  BAKR   R14,0            save in stack
         SR    R2,R2             clear r0
         LR    R3,R1             get it
         M     R2,=A(1000)       in micro sec
         LA    R3,1(,R3)         add one ( no zero time )
         SLDL  R2,12             into mic form
         STM   R2,R3,ASM_SLEEP   save it
         PR    ,                 return back
*---------------------------------------------------------------------*
* copystr  - copy string routine                                      *
*---------------------------------------------------------------------*
COPYSTR  BAKR  R14,0               all in satck
         MVC   ASM_WORK,BLANKS     blank out
         LA    R2,ASM_WORK         output addr
         LA    R3,64               max length
COPYSTR_LOOP CLI 0(R1),0           end of string
         BE    COPYSTR_00          back if yes
         MVC   0(1,R2),0(R1)       copy a byte
         LA    R1,1(,R1)           incr from
         LA    R2,1(,R2)           incr to
         BCT   R3,COPYSTR_LOOP     in loop
COPYSTR_00 PR ,                    back
*---------------------------------------------------------------------*
* strlen  - he length of the null term string                         *
*---------------------------------------------------------------------*
STRLEN   BAKR  R14,0              all in satck
         LA    R2,256             max length
STRLEN_LOOP CLI 0(R1),0           string term
         BE    STRLEN_BREAK       if it is
         LA    R1,1(,R1)          next char
         BCT   R2,STRLEN_LOOP     try if more
STRLEN_BREAK LA R15,256           here also
         EREG  R1,R1             back from stack
         SR    R15,R2            get length
         PR    .                 back to caller
         TITLE 'data areas '
*---------------------------------------------------------------------*
* DATA area                                                           *
*---------------------------------------------------------------------*
*        $$DBASE
         $$DBASE
         LTORG
*dl_enql     enq (0,0,e,0,step),mf=l   list enq
MDL_ENQL     ENQ (0,0,E,0,STEP),MF=L   list enq
MDL_ENQLL EQU *-MDL_ENQL            enq length
         SPACE 3
BLANKS   DC    CL128' '            long blank
ZERO     DC    A(0)                zero
NULLS    DC    XL8'00'
KEY8     EQU   8                   key 8 user key
         LTORG
*dl_wtol wto  '01234567890123456789012345678901234567890123456789012345*
               678901234567890123456789012345678901234567890123456789',*
               ROUTCDE=(21),DESC=(6),MF=L
MDL_WTOL WTO  '01234567890123456789012345678901234567890123456789012345*
               678901234567890123456789012345678901234567890123456789',*
               ROUTCDE=(21),DESC=(6),MF=L
MDL_WTOL_L EQU *-MDL_WTOL           text length
SVC_EXE  SVC   *-*               exec only
TDUMP_COPY MVC 1(*-*,R3),0(R1)    copy text
TDUMP_DEF_NAME   DC AL1(L'TDUMP_DEF_NAMEL)
TDUMP_DEF_NAMEL  DC C'ISIS.TDUMP.D&&YYMMDD..T&&HHMMSS..&&SYSNAME..&&JOB*
               NAME.'
TDUMP_DEF_DESC   DC AL1(L'TDUMP_DEF_DESCL)
TDUMP_DEF_DESCL  DC C'ISIS default '
VTOC_COPY_DCB MVC 0(*-*,R6),VTOC_MODEL_DCB copy model DCB
*TOC_MODEL_DCB DCB DSORG=PS,MACRF=(R)
VTOC_MODEL_DCB DCB DSORG=PS,MACRF=(R)
VTOC_MODEL_DCB_LENGTH EQU *-VTOC_MODEL_DCB
*TOC_MODEL_CVAFFILT CVAFFILT MF=L,FLTAREA=KEEP
VTOC_MODEL_CVAFFILT CVAFFILT MF=L,FLTAREA=KEEP
VTOC_MODEL_CVAFFL EQU *-VTOC_MODEL_CVAFFILT
LOGGER_ONESEC      DC A(100*1)            one sec
LOGGER_SETSTREAM   MVC ASM_STREAMNAME(*-*),0(R3) copy straem
*OGGER_MAX_BUFFER  DC  A(1024*128) max logger buffer
LOGGER_MAX_BUFFER  DC  A(1024*1024*8) max logger buffer
WLM_CONNTKN_KEY  DC X'00'         connection token key
WLM_ENCLAVE_TOKENNAME DC C'WLM_ENCLAVE'
ADAY     DC    A(24*60*60*1000)  a day in milli sec
WAIT_MAJ DC    CL8'WAITMAJOR'    ENQ/DEQ MAJOR NAME
* 04/03/10 OBTAIN DSCB
*AMLST   CAMLST SEARCH,0,0,0
CAMLST   CAMLST SEARCH,0,0,0
CAMLST_L EQU    *-CAMLST
* 04/03/10 OBTAIN DSCB
* 10/09/12 CAMLST SEEK for OBTAIN
*amlst_seek CAMLST SEEK,0,0,0
CAMLST_SEEK CAMLST SEEK,0,0,0
CAMLST_SEEK_L EQU *-CAMLST_SEEK
* 10/09/12 CAMLST SEEK for OBTAIN
         SPACE 1
         SPACE 1
* timer exit modell
         SPACE 1
         PUSH USING
         DROP R13
MDL_TIMX BALR R15,0               timer exit area
         USING ASM_TIMX+2,R15     temp base  base
         STM   R14,R12,12(R13)     save regs
         LA    R2,ASM_TIMER_ECB   get ecb addr
         POST  (R2)                post ecb
         LM    R14,R12,12(R13)     save regs
         BSM   0,R14                 return back
         DROP  R15
MDL_TIMXL EQU *-MDL_TIMX   routine length
         POP   USING
         TITLE  ' refrenced dsects '
         GBLB &PRINT
&PRINT   SETB 1
         $$GLOBAL IARVRL=NO
         PRINT GEN
         SPACE 1
* event token dsect
EVENT_TOKEN  DSECT
EVENT_TOKEN_ASCB DC A(0)         ascb pointer
EVENT_TOKEN_TCB  DC A(0)         tcb pointer
EVENT_TOKEN_ECBP DC A(0)         ecb pointer
EVENT_TOKEN_ECB  DC A(0)         event ecb
         SPACE 1
* event token dsect
SHMEM_TOKEN  DSECT
SHMEM_TOKEN_ASCB DC A(0)         ascb pointer
SHMEM_TOKEN_ADDR DC A(0)         source address
SHMEM_TOKEN_LGTH DC A(0)         source length
SHMEM_TOKEN_     DC A(0)         reserved
         PRINT NOGEN
         MEXIT
.MSG     TITLE ' messages for qnetasm '
         MEND
