./ ADD NAME=$$README 0100-02143-02143-1556-00028-00028-00000-BC0THOR
************************************************************************
* CCLASS: the C Language class library. This class is intended for use *
*         with a C Language compiler/editor/development environment on *
*         a PC, and specifically uses the Borland Turbo-C product,     *
*         which was inexpensive, powerful, and easy to use when the    *
*         course was developed.                                        *
************************************************************************
$$readme  This file.
BINSRCH   Sample C subroutine for searching a sequential file binarily.
CIRCLE    Sample C main program to compute diameter, area given radius.
CONGRATS  Text for a congratulations letter to students on completion.
CONTENTS  Text for the table of contents for the course.
CRITIQUE  Text for a course critique to be filled out by students.
DUMPHEX   Sample C main program to print a file in hex and character.
GENLDAT2  Sample C subroutine to perform date reformatting.
HANDBOOK  Text of the primary handout for the students for the course.
HELLO2    Sample C main program: the traditional "Hello World!" program.
KEYVALU   Sample C program to display the hex value for a keypress.
LOADSTRG  Sample C main program to read/display strings.
MENU10    Sample C main program to display a menu and obtain a request.
SKELETON  Sample C program that can be used to develop a new program.
STRUCT9   Sample C code to demonstrate use os structures and unions.
SYLLABUS  Text for a course syllabus.
TEMPCONV  Sample C main program to convert temperatures F to/from C.
VER2EDIT  Text describing Turbo-C Version 2 Editor commands.
VER2LSN1  Text for first lesson using Turbo-C version 2 on the PC.
VER3EDIT  Text describing Turbo-C++ Version 3 Editor commands.
VER3LSN1  Text for the first lesson using Turbo-C version 3 on the PC.
./ ADD NAME=BINSRCH  0100-02144-02144-0950-00076-00076-00000-BC0THOR
/****************************************************************/
/*          binsrch.c, a binary search function                 */
/* caller supplies:                                             */
/*    (1) a pointer to the FILE to be searched (must be OPEN).  */
/*    (2) a pointer to the key argument used for the search.    */
/*    (3) length of each record in the file (int).              */
/*    (4) length of the key in the records (int).               */
/*    (5) relative position of the key in the record (int, 0+). */
/*    (6) a pointer to the callers record return area.          */
/* function returns:                                            */
/*    (1) an int whose value is -1 if the record is found or    */
/*        0 of it is not found.                                 */
/*    (2) the record found, if the search was successful.       */
/*                                                              */
/* Author R Thornton, October, 1993                             */
/****************************************************************/
#include <stdio.h>

int binsrch(FILE *rf,
			char *arg_key,
			int recdleng,
			int keyleng,
			int keyloc,
			char *record)
{

  long int file_size;             /* file length in bytes */
  long int max_slots;             /* number records in file */
  long int curr_slot  = 0;        /* current record slot number */
  long int curr_offset = 0;       /* current offset increment */
  long int file_offset;           /* computed file offset */
  int      compare = 0;           /* current compare indicator */
  int      result = 0;            /* result indicator */

  result = 0;                     /* set up for not found */
  if(fseek(rf,0,SEEK_END) != 0)   /* set file pointer to end of file */
	return(result);               /* terminate if error */
  if((file_size = ftell(rf)) == -1L) /* get file size in bytes */
	return(result);               /* terminate if error */
  max_slots = file_size / recdleng;  /* compute number records in file */
  curr_slot = 0;                 /* set initial slot number */
  curr_offset = max_slots - 1;   /* set initial offset increment */
  compare = -1;                  /* set compare for low */
  while(curr_offset != 1) {
	curr_offset ++;              /* add 1 to insure rounding high */
	curr_offset /= 2;            /* offset / 2 (rounded high */
	if(compare < 0) {            /* if last key read was low */
	  curr_slot += curr_offset;     /* add offset increment */
	  if(curr_slot >= max_slots) {  /* if result past end of file */
		compare = 1;                   /* set compare to high */
		continue;                      /* and continue to while */
	  }
	  else ;
	}
	else {                       /* if last key read was high */
	  curr_slot -= curr_offset;     /* subtract offset increment */
	  if(curr_slot < 0) {           /* if result prior to 1st slot */
		compare = -1;                  /* set compare to low */
		continue;                      /* and continue to while */
	  }
	  else ;
	}
	file_offset = curr_slot * recdleng;   /* compute file offset */
	if((fseek(rf,file_offset,0)) != 0)    /* position in file */
	  break;                              /* terminate if error */
	fread(record,recdleng,1,rf);          /* read the record */
	if((compare=memcmp(record+keyloc,arg_key,keyleng)) == 0) { /* found? */
	  result = -1;
	  break;                                          /* yes, quit */
	}
  }
  return(result);
}



./ ADD NAME=CIRCLE   0100-02144-02144-0950-00083-00083-00000-BC0THOR
          /******************************************************************/
          /*                         circle.c                               */
          /* circle.c: displays area, circumference, and volume of a sphere */
          /* when given the radius.                                         */
          /******************************************************************/

          #include <stdio.h>               /* include standard I/O header   */
          #include <math.h>                /* include math header for float */

          #define PI 3.14159               /* define PI = 3.14159           */

          float area, circumference, volume; /* define global float vrbls   */

          /******************************************************************/
          /* function prototypes                                            */
          /******************************************************************/
          float calculate_area(double radius);
          float calculate_circumference(double diameter);
          float calculate_volume(double radius);

          /******************************************************************/
          /* main function: initial entry point to the program. The radius  */
          /* of the circle of interest is expected to be typed on the       */
          /* command line following the program name.                       */
          /******************************************************************/

          main(int argc, char *argv[]) {   /* function header for main      */

            double radius;                 /* define radius                 */

            if(argc != 2) {                /* got two command line strings? */
              printf("Usage is: circle radius\n"); /* no, explain how to use*/
              exit(1);                     /* and terminate                 */
            }
            radius = atof(argv[1]);        /* convert 2nd string to double  */

            area = calculate_area(radius); /* compute circle area           */
            circumference = calculate_circumference(2 * radius); /* circumf.*/
            volume = calculate_volume(radius); /* and volume                */

            printf("The radius given is %f\n",radius); /* display radius    */
            printf("Area is %f\n",area);               /* area,             */
            printf("Circumference is %f\n",circumference); /* circumference,*/
            printf("Volume is %f\n",volume);           /* and volume        */
          }                                /* end of main function          */

          /******************************************************************/
          /* calculate_area computes the area of a circle, given the radius */
          /* and returns it to the caller as a float.                       */
          /******************************************************************/
          float calculate_area(double rad) { /* calculate_area function head*/

            float answer;                  /* define answer field           */

            answer = PI * rad * rad;       /* compute area of circle        */

            return(answer);                /* return area of circle         */
          }                                /* end calculate_area function   */

          /******************************************************************/
          /* calculate_circumference computes the circumference of a circle,*/
          /* given the diameter.                                            */
          /******************************************************************/

          float calculate_circumference(double diameter) { /* function hdr  */

            return(PI * diameter);         /* compute, return circumference */
          }                                /* end of calcualte_circumference*/

          /******************************************************************/
          /* calculate_volume computes the volume of a sphere, given its    */
          /* radius.                                                        */
          /******************************************************************/

          float calculate_volume(double r) { /* calculate_volume header     */

            float rcubed, vol;             /* define rcubed, vol            */

            rcubed = r * r * r;            /* compute rcubed                */
            vol = (4 * rcubed) / 3;        /* compute volume of sphere      */
            return(vol);                   /* return computed volume        */
          }                                /* end of calcualte_volume func  */

./ ADD NAME=CONGRATS 0100-02144-02144-0950-00060-00060-00000-BC0THOR
                                   August 22nd, 1994

         Congratulations on completing the class in Elementary C Programming.
         This represents a significant amount of effort and time, and can be
         valuable to you if you follow up with practice in writing programs in
         C. Without practice, you will quickly forget the language and how to
         use the Integrated Development Environment to build and test
         programs.

         A working knowledge of the C language will help you in many ways, as
         it is the underlying code in many Client-Server applications. The
         UNIX operating system is itself written in C, and the command line
         language, as well as Shell Script programming is heavily C oriented.
         Blue Cross already has application systems in place in the telephone
         Voice Response system and in a number of areas in HCS. In a vendor
         supplied OCR Scanner system Richard Womble deals with the vendor has
         agreed to supply C source code we can maintain, saving $6,000 per
         year in maintenance fees. There are also a number of IBM RS6000
         systems either installed or planned for Blue Cross. These systems are
         supplied with an operating system called AIX, which is the IBM
         version of UNIX. Lin Merritt is currently writing C programs to
         extract performance data which will be fed into his capacity planning
         processes. Other opportunities will be available for those who
         maintain their skills in C programming, I am sure.

         While higher level languages such as Power Builder will likely be
         preferred for new applications at Blue Cross, an understanding of C
         can help you understand the concepts and syntax used by other Client-
         Server components.

         Please try to write several small programs soon to help solidify your
         knowledge. In the appendices to your class handouts you will find
         information on cursor positioning for the IBM PC, information on
         processing special keys (such as function keys) when reading from the
         keyboard on an IBM PC, and three programs written in C that offer
         examples of C programming. One program is the binary search routine
         now being used with the VRU system. The second program is a file dump
         that produces output in hex and character format. The third program
         is a skeleton you can use in building your own programs. It contains
         input, output, and print files and some common supporting functions.
         You might consider enhancing these programs as an exercise. A sub-
         program (function) called GENLDAT2 is available for anyone who may be
         interested. This is functionally similar to the mainframe subroutine
         of the same name. Also, a library of small C source programs is
         available. If you'd like a copy, send me a blank 3.5" disk at mail
         drop 02A.

         When you find the time, I would appreciate the course critique
         returned to me at mail drop 02A.

         Thanks very much,







         Dick Thornton
         Instructor
./ ADD NAME=CONTENTS 0100-02144-02144-0950-00114-00114-00000-BC0THOR
         ******************************************************************
         *                    Elementary C Programming                    *
         ******************************************************************
                                  TABLE OF CONTENTS

         Lesson 1  - Installation, Customizing, and Checkout: ......... 1
                     Installing the compiler and integrated
                     development environment, customizing the
                     compiler and IDE, running under OS/2, create,
                     compile, and execute a short program.

         Lesson 2  - Basic Structure of C Programs: Syntax,   ......... 3
                     comments, program organization, functions,
                     the main() function, function Prototypes,
                     preprocessor directives, escape sequences.

         Lesson 3  - Variables, Operators, and printf: Lifetime ....... 7
                     and visibility, definition syntax, types of
                     variables, naming variables, initializing
                     variables, arithmetic operators, increment
                     and decrement operators, printf() syntax and
                     use.

         Lesson 4  - Include, Define, and Functions: Syntax, .......... 12
                     parameters, prototype, returning values,
                     passing data (by reference, by value),
                     external variables.

         Lesson 5  - Arrays, Strings, and Constants: Defining and ..... 18
                     initializing arrays, strings, and constants.

         Lesson 6  - Relational and Logical Operators and ............. 21
                     Decisions: Relational operators, logical
                     operators, if statements, and logical
                     expressions.

         Lesson 7  - Loops and Keyboard Input Functions For loops, .... 25
                     while loops, do while loops, break and
                     continue statements, getc, getch, getche and
                     gets functions.

         Lesson 8  - Pointers: Referring to elements of arrays, ....... 32
                     sending to functions, pointers to pointers.

         Lesson 9  - Structures and Unions and the sizeof keyword: .... 37
                     Structures, unions, unions of structures,
                     structures including unions, use of sizeof.

         Lesson 10 - Switch statements and the conditional operator. .. 42

         Lesson 11 - Advanced Variables: Pointer notation for ......... 45
                     structures, enumerated data type, typedef,
                     type conversion and casting.


                                         i

         ******************************************************************
         *                    Elementary C Programming                    *
         ******************************************************************
                                  TABLE OF CONTENTS

         Lesson 12 - Files and I/O Part 1: Types of disk I/O, ......... 50
                     standard (stream) I/O, binary mode and text
                     mode.

         Lesson 13 - Files and I/O Part 2: Record I/O, random ......... 55
                     access, using handles.

         Lesson 14 - Miscellaneous topics: The goto statement, ........ 60
                     labels, models, separate compilation,
                     projects, bitwise operators, operator
                     precedence,

         APPNDX A  - Turbo C Editor Navigation and Hot Key Guide ...... 65

         APPNDX B  - Data Definitions - COBOL vs C .................... 66

         APPNDX C  - Cross-Reference to Turbo C Library Functions ..... 69

         APPNDX D  - Key Codes for the IBM PC ......................... 80

         APPNDX E  - ANSI.SYS Screen/Cursor Control ................... 83

         APPNDX F  - ANSI.SYS and Attribute Control ................... 84

         APPNDX G  - Keywords and Operators in C ...................... 85

         hello2.c  - Version of "Hello, World!" program ............... 87

         circle.c  - Circle/sphere calculations program ............... 89

         tempconv.c- Temperature conversion program ................... 91

         loadstrg.c- Program to store strings in memory ............... 93

         struct9.c - Structure usage program .......................... 94

         menu10.c  - Menu program ..................................... 96

         dumphex.c - File dump program ................................ 99

         skeleton.c- Skeleton program for development ................. 103

         binsrch.c - Binary search of a file function ................. 111

         genldat2.c- Generalized date function ........................ 113

         keyvalu.c - Program to display key values .................... 124



                                         ii

./ ADD NAME=CRITIQUE 0100-02144-02144-0950-00253-00253-00000-BC0THOR
                                    Course Critique

         Course Name: Elementary C Programming

         Instructor:  Dick Thornton

         Dates: July 18th, 1994 through August 19th, 1994

         Please help me make this a better class by taking a few minutes to
         provide thoughtful answers to the following questions. If you wish,
         feel free to make any comments concerning the class that you feel
         would improve it.

         I. Course schedule. What schedule would best fit your personal work
            habits?
            (1) As it was presented (9:00-11:30 Monday, Wednesday, and Friday
                for 5 weeks.
            (2) 8:30 - 12:00 two days per week for 5 weeks.
            (3) 8:30 - 4:30 one day per week for 5 weeks.
            (4) 8:30 - 4:30 five consecutive days.
            (5) 8:30 - 4:30 two days per week for 2.5 weeks.
            (6) Other (specify):

         II. Do you feel the 5-week class duration was:
            (1) Too long. Should have been:
            (2) Too short. Should have been:
            (3) About the right duration.

         III. Regarding the length of each session:
            (1) Sessions too long. Should have been:
            (2) Sessions were too short. Should have been:
            (3) Sessions were about the right length.

          IV. Number of breaks per session:
            (1) There were too many breaks. Should have been about:
            (2) There were too few breaks. Should have been about:
            (3) Two breaks per session was about right

           V. Length of breaks:
            (1) Too long, should be more like:
            (2) Too short. Should be about:
            (3) 10 minute breaks were about right.

          VI. How well do you understand the following C topics?
              Use the scale like this:

                 0. What??? Did we go over something like that?
                 1. I remember seeing it, but probably couldn't understand it
                    in someone else's program, and certainly couldn't use it.
                 2. Somewhat comfortable with it. Could understand it if found
                    in someone else's program, but would not want to try to
                    code my own.
                 3. I understand it well, would have no trouble understanding
                    it in someone else's program. I could code it with help
                    from a book or the IDE's help functions.
                 4. I understand it very well if seen in another program and
                    feel I could probably code it reasonably well in most
                    cases without help.
                 5. No problem!

               (   ) Use of the Turbo C IDE editor
               (   ) Use of the HELP and Language Help features of the IDE
               (   ) Use of the Turbo C IDE in compiling programs
               (   ) Use of the Turbo C IDE in running programs
               (   ) Use of the Turbo C IDE in testing programs
               (   ) Basic C language syntax: forming names, ending
                     statements, writing simple C instructions.
               (   ) Organization of C programs: where to put variable
                     definitions, procedure statements, functions, requirement
                     for the main function, etc.
               (   ) Function prototypes: what they are, how to write them.
               (   ) Turbo C library functions: how to find which to use, how
                     to use them using course materials and the IDE.
               (   ) #include statements: what they do, how to code them, how
                     to find the required header for a library function.
               (   ) #define statements: what they do, how to code them
               (   ) Escape sequences: what they are and how to code them in
                     printf for newline, carriage-return, etc.
               (   ) Simple variables: how to define variables of the built-in
                     types, such as char, int, long, float, double.
               (   ) Simple variables: how to provide initial values when
                     defining them.
               (   ) Arithmetic operators (+, -, *, /, %) what they mean and
                     how to use them in simple expressions.
               (   ) Using the assignment operator (=) to move data into a
                     variable.
               (   ) Increment and decrement operators (++ and --): what they
                     mean and how to use them as either prefix or postfix.
               (   ) The printf function: how to use it to display text and
                     formatted variables.
               (   ) Function calls: how to code them.
               (   ) Functions: how to code your own.
               (   ) Values returned by library functions: using the IDE to
                     find what is returned.
               (   ) Returning a value from your own function: how to write
                     the code to return the value.
               (   ) How to code a function call to obtain the value returned
                     by the function.
               (   ) Passing addresses to a function so that it can modify
                     data in the calling function: coding the function itself
                     and the call to it.
               (   ) Defining global variables: where and how.
                 0. What???
                 1. Very weak understanding, no way I could code it.
                 2. Some understanding, but couldn't code my own.
                 3. Understand fairly well, could code with help.
                 4. Understand very well, probably code it without help.
                 5. No problem!

               (   ) References to global variables in a separately
                     compiled program. (Not the program in which they are
                     defined.)
               (   ) Defining an array of simple data types, such as int,
                     float, etc.
               (   ) Specifying initial values for an array of simple
                     variables.
               (   ) Defining and giving an initial value for a string.
               (   ) Using the standard library functions for string
                     manipulation.
               (   ) Simple conditional (if) statements using ordinary
                     relational operators (==, <, <=, >, >=, !=).
               (   ) Using boolean if statements such as: if(switch) ...
               (   ) Understanding the negation operator and how it affects
                     boolean expressions such as: if(!switch) ...
               (   ) Compound relational conditions using the && and ||
                     operators.
               (   ) Using an if statement that performs more than one
                     instruction.
               (   ) Using an else statement.
               (   ) Using nested if - else constructs.
               (   ) Using a for loop statement: coding the parameters and
                     body of the loop.
               (   ) Using a while loop statement: coding the parameters and
                     body of the loop.
               (   ) Using a do ... while statement: coding the parameters and
                     body of the loop.
               (   ) Using a never-ending while statement.
               (   ) Breaking out of a loop using the break instruction.
               (   ) Terminating processing in a given iteration of a
                     loop and returning to the top to begin the next iteration
                     using the continue keyword.
               (   ) Reading characters from the keyboard using the getch and
                     getche library functions.
               (   ) Reading strings from the keyboard using the gets
                     library function.
               (   ) Defining pointers.
               (   ) Using a pointer to access an array.
               (   ) Using an array name as a pointer.
               (   ) Defining a structure: what a structure is, syntax for
                     declaring and defining one.
               (   ) Using the dot operator to refer to fields within a
                     structure or union.
               (   ) Declaring a structure and later using the declaration to
                     define one.
               (   ) Specifying initial values for the fields in a structure
                     when it is defined.
               (   ) Defining an array of structures.
               (   ) Using brackets and the dot operator to refer to a field
                     within an element of an array of structures.
               (   ) Specifying initial values for the fields in the members
                     of an array of structures.
                 0. What???
                 1. Very weak understanding, no way I could code it.
                 2. Some understanding, but couldn't code my own.
                 3. Understand fairly well, could code with help.
                 4. Understand very well, probably code it without help.
                 5. No problem!

               (   ) Declaring a union: what a union is, syntax for declaring
                     and defining one.
               (   ) Declaring a structure containing another structure.
               (   ) Declaring a union containing several structures.
               (   ) Using the sizeof keyword to get the size of a structure
                     of union.
               (   ) Using a switch statement: specifying the switch variable
                     and the body of the switch.
               (   ) Specifying cases within the body of the switch statement.
               (   ) Understanding how cases work in a switch statement.
               (   ) Using the default keyword in a switch statement.
               (   ) Using the break statement is a switch statement.
               (   ) Using the conditional operator (max = (i<j) ? i : j;)
               (   ) Using pointer notation for structures.
               (   ) Using the enumerated data type for condition name
                     processing: syntax for definition.
               (   ) Specifying enum condition names in if statements.
               (   ) Specifying a value for an enum data item using condition
                     names.
               (   ) Using the typedef statement to create a new data type.
               (   ) Using a data type created by a typedef when defining a
                     data field of the new type.
               (   ) Understanding how C converts between different data types
                     included in an expression.
               (   ) Using type casting (coercion) to force C to convert a
                     variable to another form before use.
               (   ) Understand the difference between binary mode and test
                     mode in file processing.
               (   ) Understand the difference between standard (stream) I/O
                     and system level I/O.
               (   ) Use the FILE type to create a pointer for use by stream
                     I/O functions.
               (   ) Using the fopen library function to open stream files.
               (   ) Using the getc library function to read a stream file in
                     character-by-character input mode.
               (   ) Using the fread library function to read stream files in
                     record mode input.
               (   ) Using the putc library function to write stream files
                     character-by-character.
               (   ) Using the fprintf function for formatted output to a
                     stream file.
               (   ) Using the fwrite library function to write records to
                     stream files.
               (   ) Using fclose to close stream files.
               (   ) Using the return value from getc and fread to detect end
                     of file.
               (   ) Using the perror library function to print an error
                     message when an I/O error occurs.
               (   ) Using the ferror library function to determine when an
                     error has occurred during file I/O.
               (   ) Using the exit keyword to terminate a program.
                 0. What???
                 1. Very weak understanding, no way I could code it.
                 2. Some understanding, but couldn't code my own.
                 3. Understand fairly well, could code with help.
                 4. Understand very well, probably code it without help.
                 5. No problem!

               (   ) Using the fseek library function to position to a
                     specific location within a file for random I/O.
               (   ) Defining the handle for use by system level I/O.
               (   ) Understanding you cannot mix library functions between
                     stream I/O and system level I/O.
               (   ) Knowing how to tell that a given library function is for
                     use with stream I/O or system level I/O.
               (   ) Using library functions open, read, write, and close in
                     system level I/O for files.
               (   ) Using the goto statement and defining labels for its use.
               (   ) Understanding Turbo C models for use with PC's.
               (   ) Understanding how to separately compile sub-programs.
               (   ) Understanding how to use the project function in the IDE
                     to link several separately compiled programs to build an
                     executable module.
               (   ) Using bitwise operators (&, |, ^, <<, >>, ~).
               (   ) Understanding operator precedence and associativity and
                     how it affects expression interpretation in C.


         VII. Would you like to see a follow-on class given in C++ which would
              Object-Orientation concepts such as objects, inheritance,
              polymorphism and overloading?


        VIII. Please feel free to add any other comments or suggestions you
              feel might make this a better class. Thank you.
./ ADD NAME=DUMPHEX  0100-02144-02144-0950-00179-00179-00000-BC0THOR
        /******************************************************************/
        /*                         dumphex.c                              */
        /* dumphex.c displays and optionally prints the content of a file */
        /* in hex and character, 16-bytes per line. user specifies the    */
        /* name of the file to dump on the command line.                  */
        /******************************************************************/

        #include <stdio.h>               /* include standard I/O header   */
        #include <stdlib.h>              /* include standard lib header   */

        /******************************************************************/
        /* main function: on entry the number of command line arguments   */
        /* is available in argc, while argv is an array of strings, which */
        /* contains the command line arguemnts. The first command line    */
        /* string ([0]) is always the program name.                       */
        /******************************************************************/

        void main(int argc, char *argv[]) {

        /******************************************************************/
        /*               define global work fields                        */
        /******************************************************************/
        char prntlin[68];                     /* print line */
        unsigned char ch;                     /* character work field */
        unsigned char prtsw='\0';             /* print switch */
        unsigned int j,l,row=0;               /* work fields */
        int i,k;                              /* work fields */
        unsigned long bytno=0,tot=0;          /* work fields */

        /******************************************************************/
        /*               function prototypes                              */
        /******************************************************************/
        void atox(unsigned char, char[], char[]);  /* function prototype */

        /******************************************************************/
        /*               FILE pointer definitions                         */
        /******************************************************************/
        FILE *infil,*outfil;                  /* FILE pointers */

        /******************************************************************/
        /*        end of data definitions, begin processing               */
        /******************************************************************/

        prntlin[0]='\n';                      /* put newline in print line */
        prntlin[67]='\0';                     /* insure valid string */

        /*******************************************************************/
        /* If command line has two strings (1="dumphex", 2=filename), open */
        /* the input file, otherwise display the proper syntax to use and  */
        /* terminate the program.                                          */
        /*******************************************************************/

        if(argc!=2) {
            printf("\nSYNTAX: dumphex [d:][\path\]filename[.ext]");
            exit(1);
        }
        if((infil=fopen(argv[1],"rb"))==NULL) {
            printf("\nCan't open the input file, %s",argv[1]);
            exit(1);
        }

        /*******************************************************************/
        /* Ask user if the file dump is to be printed or only displayed on */
        /* the screen. If print is requested, set the print switch and open*/
        /* the print file and print a header line.                         */
        /*******************************************************************/

        printf("\nDo you want to print the file (y/n): ");
        while((prtsw!='y')&&(prtsw!='n'))
            prtsw=getche();
        if(prtsw=='n')
            prtsw='\0';
        if(prtsw)
            if((outfil=fopen("prn","w"))==NULL) {
                printf("\nCan't open the printer file.");
                exit(0);
            }
            else {
                fputs("\n     ***** Hex/Character Dump of: ",outfil);
                fputs(argv[1],outfil);
                fputs(" *****\n",outfil);
            }
        /*******************************************************************/
        /* Build a line of print containing the offset from the beginning  */
        /* of the file, 8 groups of 2 hex bytes each, and the printable    */
        /* ASCII characters for them.                                      */
        /*******************************************************************/
        do {
            for(i=1;i<67;i++)        /* pre-clear the print */
            prntlin[i]=' ';              /* line to blanks */
            /***************************************************************/
            /* Calculate and print the file offset in hex at left of line. */
            /***************************************************************/
            ch=bytno/65536;
            atox(ch,&prntlin[1],&prntlin[2]);
            ch=(bytno%65536)/256;
            atox(ch,&prntlin[3],&prntlin[4]);
            ch=bytno%256;
            atox(ch,&prntlin[5],&prntlin[6]);
            bytno+=16;
            /***************************************************************/
            /* Read characters from the file and copy them into the        */
            /* printable character portion of the print line (positions    */
            /* 52-67).                                                     */
            /***************************************************************/
            i=51;
            while((i<67)&&(k=getc(infil))!=EOF) {
                prntlin[i++]=k;
                tot+=1;
            }
            /***************************************************************/
            /* Convert the characters in print line positions 52-67 to hex */
            /* (2 hex digits per character) and use the hex digits to make */
            /* eight groups of 2-bytes (4 print positions). Single spaces  */
            /* are placed between each group of 2 bytes with a double space*/
            /* in the center.                                              */
            /***************************************************************/
            for(j=51,l=9;j<i;j++) {
                atox(prntlin[j],&prntlin[l],&prntlin[l+1]);
                l+=2;
                if(l==13||l==18||l==23||l==34||l==39||l==44)
                    l+=1;
                if(l==28)
                    l+=2;
            }
            /***************************************************************/
            /* Scan the character area of the print line (positions 52-67) */
            /* and replace non-printable characters with periods.          */
            /***************************************************************/
            for(j=51;j<i;j++)
                if((prntlin[j]<' ')||(prntlin[j]>'z'))
                    prntlin[j]='.';
            /***************************************************************/
            /* Display the line on the screen. If the print switch is on,  */
            /* print it, too. Check to see if we are at the bottom of the  */
            /* screen. If so, ask the user whether to continue or to quit. */
            /***************************************************************/
            printf("%s",prntlin);
            if(prtsw)
                fputs(prntlin,outfil);
            row += 1;                       /* increment row counter */
            if(row >= 22) {                 /* if end of screen: */
                row = 0;                        /* reset row counter */
                printf("\nEnter Q to quit or press ENTER to continue: ");
                ch = getchar();                 /* get response */
                if((ch == 'q') || (ch == 'Q'))
                    exit(1);                /* quit if Q entered */
            }
        }
        while(k!=EOF);                      /* end of d... while */

        /*******************************************************************/
        /* End of file to be dumped. Print totals, close files, and        */
        /* terminate normally.                                             */
        /*******************************************************************/

        printf("\n\nTotal bytes in file = %d.\n",tot);
        if(prtsw) {
            fputs("\n\nTotal bytes in file = ",outfil);
            itoa(tot,prntlin,10);
            fputs(prntlin,outfil);
            fputs("\n\n\n",outfil);
            fclose(outfil);
        }
        fclose(infil);
        }

        /******************************************************************/
        /* function to convert a character to two printable hex digits    */
        /******************************************************************/

        void atox(unsigned char ch,  char *hi, char *lo) {

            char hextbl[]="0123456789ABCDEF";

            *hi=hextbl[ch/16];      /* convert high-order hex digit */
            *lo=hextbl[ch%16];      /* convert low-order hex digit */
        }

./ ADD NAME=GENLDAT2 0100-02144-02144-0950-00524-00524-00000-BC0THOR
          /*****************************************************************/
          /*                         genldat2.c                            */
          /* This function provides the caller with a table of information */
          /* concerning a specified date. The caller places a date in one  */
          /* of the Julian or Gregorian fields of the DATEGENL structure   */
          /* and an indicator of the type date sent in the datyp field, and*/
          /* invokes genldat2(), which fills in all the remaining fields in*/
          /* the DATEGENL structure. A pointer to DATEGENL is passed to    */
          /* this function by the caller.                                  */
          /*****************************************************************/

          #include <string.h>

          struct DATEGENL {
            enum {
              julian_yyyyddd_sent = 'j',
              gregorian_mmddyyyy_sent = 'g',
              gregorian_yyyymmdd_sent = 'y'
            } datyp;                          /* date supplied type        */
            enum {
              successful_conversion = ' ',
              error_in_data_supplied = 'e',
            } daterr;                         /* result indicator          */
            enum {
              Monday = '1',
              Tuesday = '2',
              Wednesday = '3',
              Thursday = '4',
              Friday = '5',
              Saturday = '6',
              Sunday = '7'
            } daywk;                          /* day of week indicator     */
            enum {
              not_a_holiday = ' ',
              New_Years_Day = '1',
              Christmas_Eve = '2',
              Good_Friday = '3',
              Memorial_Day = '4',
              Independence_Day = '5',
              Labor_Day = '6',
              Thanksgiving_Day = '7',
              Friday_After_Thanksgiving = '8',
              Christmas_Day = '9',
            } holiday;                        /* holiday indicator         */
            enum {
              not_leap_year = '0',
              leap_year = '1',
            } yeartyp;                        /* year type                 */
            char juldate[8];                     /* julian date yyyyddd    */
            char gregmdy[9];                     /* gregorian date mmddyyyy*/
            char gregymd[9];                     /* gregorian date yyyymmdd*/
            char litdate[19];                    /* literal date, eg:      */
                                                    /* May 9, 2002         */
            char julslash[9];                    /* julian date yy/ddd     */
            char grgslash[11];                   /* gregorian:  mm/dd/yyyy */
            char daylit[10];                     /* literal day of week eg:*/
                                                    /* Sunday              */
            char monthlit[10];                   /* literal month, eg: July*/
          };

          /*****************************************************************/
          /* yeardata contains data about this year: day of week for       */
          /* January 1st, leap year indicator, and holiday dates. Format:  */
          /*   byte1: day of week for Jan 1: 0=Monday - 6=Sunday           */
          /*   byte2: leap year indicator: 1 = leap year else 0            */
          /*   remainder: holiday fields of 5 bytes each. Format of each:  */
          /*          byte1: holiday type indicator (same as p->holiday)   */
          /*          bytes 2-5: MMDD date of the holiday                  */
          /* tblukup() locates data for this year and initializes this area*/
          /*****************************************************************/
          struct year_entry2 {
            char jan1_day;
            char leap_year_ind;
            struct {
              char holiday_type;
              char holiday_mmdd[5];
            } holiday_table[9];
          } yeardata;

          /*****************************************************************/
          /* function prototypes                                           */
          /*****************************************************************/
          void genldat2(struct DATEGENL *p);
          void julian_sent(struct DATEGENL *p);
          void gregorian_sent(struct DATEGENL *p);
          void datcomn(struct DATEGENL *p);
          void tblukup(struct DATEGENL *p);


          void genldat2(struct DATEGENL *p) {

            p->daterr = ' ';                       /* clear error indicator*/
            p->holiday = ' ';                       /* clear holiday indic */
            if(p->datyp == julian_yyyyddd_sent) {   /* julian date sent    */
              julian_sent(p);
              return;
            }
            else
              if((p->datyp == gregorian_mmddyyyy_sent) || /* gregorian sent*/
                  (p->datyp == gregorian_yyyymmdd_sent)) {
                gregorian_sent(p);
                return;
              }
              else {                        /* invalid date type specified */
                p->daterr = 'e';
                return;
              }
          }                                       /* end function genldat2 */

          /*****************************************************************/
          /* The gregcvrt[] table is used in converting between julian and */
          /* gregorian dates. It contains the day numbers corresponding to */
          /* the first day of each month. The gregcv1 table contains leap  */
          /* year values, while the gregcv0 table contains normal year     */
          /* values. the appropriate values are moved to gregcvrt[] by the */
          /* tblukup() function.                                           */
          /*****************************************************************/
          int gregcvrt[13];

          static int gregcv0[13] = {0, 31, 59, 90, 120, 151, 181, 212, 243,
                                    273, 304, 334, 999};

          static int gregcv1[13] = {0, 31, 60, 91, 121, 152, 182, 213, 244,
                                    274, 305, 335, 999};

          /*****************************************************************/
          /* julian_sent(): main function to handle julian date sent       */
          /*****************************************************************/
          void julian_sent(struct DATEGENL *p) {
            int i, julday;

            /* ----- julian date must be 7 bytes long ---------------------*/
            if(strlen(p->juldate) != 7) {
              p->daterr = 'e';
              return;
            }

            /* ----- century must be 19 or 20 -----------------------------*/
            if(((p->juldate[0] == '1') && (p->juldate[1] == '9')) ||
                ((p->juldate[0] == '2') && (p->juldate[1] == '0')))
               ;
            else {
              p->daterr = 'e';
              return;
            }

            /* --- julian date must consist entirely of decimal digits --- */
            for(i=2; i<7; i++)
              if((p->juldate[i] < '0') || (p->juldate[i] > '9')) {
                p->daterr = 'e';
                return;
            }

            /* ----- move julian year to gregorian year fields ----------- */
            for(i = 0; i < 4; i++) {
              p->gregmdy[i+4] = p->juldate[i];  /* year to greg mdy        */
              p->gregymd[i] = p->juldate[i];    /* year to greg ymd        */
            }

            /* ----- go get year table data ------------------------------ */
            tblukup(p);

            /* ----- julian day must be 1 - 366 -------------------------- */
            julday = atoi(&p->juldate[4]);      /*get julian day to integer*/
            if((julday > 0 ) && (julday < 366))
              ;
            else
              if((julday == 366) && (p->yeartyp == leap_year))
                ;
              else {
                p->daterr = 'e';
                return;
              }

            /* ----- build gregorian mmdd fields ------------------------- */
            i = 0;
            while(gregcvrt[i] < julday)       /* look up  for month and day*/
            i++;
            julday -= gregcvrt[i - 1];     /* deduct days to start of month*/
            p->gregymd[4] = (i / 10) | '0';        /* build gregorian month*/
            p->gregymd[5] = (i % 10) | '0';
            p->gregymd[6] = (julday / 10) | '0';  /* build greg day of mnth*/
            p->gregymd[7] = (julday % 10) | '0';
            memcpy(&p->gregmdy[0], &p->gregymd[4], 4);    /*copy month, day*/
            datcomn(p);                           /* finish processing date*/
            return;
          }                                    /* end function julian_sent */

          /*****************************************************************/
          /* The grgvldy[] table contains the number of days in each month.*/
          /* It is used in validating the gregorian date.                  */
          /*****************************************************************/
          static int grgvldy[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31,
                                    30, 31};

          /*****************************************************************/
          /* gregorian_sent(): main function to handle gregorian date sent.*/
          /*****************************************************************/
          void gregorian_sent(struct DATEGENL *p) {

            int i, day, mth;

            /* ----- make both gregorian dates the same date ------------- */
            if(p->datyp == gregorian_mmddyyyy_sent) {
              memcpy(&p->gregymd[0], &p->gregmdy[4], 4); /* copy year      */
              memcpy(&p->gregymd[4], &p->gregmdy[0], 4); /* copy mmdd      */
              p->gregymd[8] = '\0';
            }
            else {
              memcpy(&p->gregmdy[0], &p->gregymd[4], 4); /* copy mmdd      */
              memcpy(&p->gregmdy[4], &p->gregymd[0], 4); /* copy year      */
              p->gregmdy[8] = '\0';
            }

            /* ----- gregorian date must be 8 bytes long ----------------- */
            if((strlen(p->gregmdy) == 8) && (strlen(p->gregymd) == 8))
              ;
            else {
              p->daterr = 'e';
              return;
            }

            /* ----- century must be 19 or 20 ---------------------------- */
            if(((p->gregmdy[4] == '1') && (p->gregmdy[5] == '9')) ||
                  ((p->gregmdy[4] == '2') && (p->gregmdy[5] == '0')))
              ;
            else {
              p->daterr = 'e';
              return;
            }

            /* ----- all 8 bytes must be decimal digits ------------------ */
            for(i=0; i<8; i++)
              if((p->gregmdy[i] < '0') || (p->gregmdy[i] > '9')) {
                p->daterr = 'e';
                return;
              }

            /* ----- day must be > 0 ------------------------------------- */
            day = ((p->gregmdy[2] - '0') * 10) + (p->gregmdy[3] - '0');
            if(day)
              ;
            else {
              p->daterr = 'e';
              return;
            }

            /* ----- month must be 01 to 12 ------------------------------ */
            mth = ((p->gregmdy[0] - '0') * 10) + (p->gregmdy[1] - '0');
            if((mth) && (mth < 13))
              ;
            else {
              p->daterr = 'e';
              return;
            }

            /* ----- perform year table lookup function ------------------ */
            tblukup(p);

            /* ----- check for valid day within the month ---------------- */
            i = grgvldy[mth - 1];
            if(day > i)
            if(p->yeartyp == leap_year)
              if(day == 29)
                ;
              else {
                p->daterr = 'e';
                return;
              }
            else {
              p->daterr = 'e';
              return;
            }

            /* ----- build julian date from gregorian -------------------- */
            memcpy(&p->juldate[0], & p->gregymd[0], 4);
            i = (gregcvrt[mth - 1]) + day;
            p->juldate[4] = ((i / 100) + '0');
            i %= 100;
            p->juldate[5] = ((i / 10) + '0');
            i %= 10;
            p->juldate[6] = i + '0';
            p->juldate[7] = '\0';

            /* ----- go finish date processing --------------------------- */
            datcomn(p);
            return;
          }                                 /* end function gregorian_sent */

          /*****************************************************************/
          /* The julmo[] table contains the literal month names.           */
          /*****************************************************************/
          static char julmo[12][10] = {{"January"},{"February"},{"March"},
                                       {"April"},{"May"},{"June"},{"July"},
                                       {"August"},{"September"},{"October"},
                                       {"November"},{"December"}};

          /*****************************************************************/
          /* The dwktbl[] table contains the literal day of week names.    */
          /*****************************************************************/
          static char dwktbl[7][10] = {{"Monday"},{"Tuesday"},{"Wednesday"},
                                       {"Thursday"},{"Friday"},{"Saturday"},
                                       {"Sunday"}};

          /*****************************************************************/
          /* datcomn(): common date processing.                            */
          /*****************************************************************/
          void datcomn(struct DATEGENL *p) {

            int i, j;

            /* ----- build the julslash date field ----------------------- */
            memmove(&p->julslash[0], &p->juldate[0], 4);
            p->julslash[4] = '/';
            strcpy(&p->julslash[5], &p->juldate[4]);

            /* ----- build the grgslash date field ----------------------- */
            memmove(&p->grgslash[0], &p->gregmdy[0], 2);
            p->grgslash[2] = '/';
            memmove(&p->grgslash[3], &p->gregmdy[2], 2);
            p->grgslash[5] = '/';
            strcpy(&p->grgslash[6], &p->gregmdy[4]);

            /* determine whether this date is a holiday and set indicator  */
            for(i = 0; i < 9; i++)
              if(!strcmp(yeardata.holiday_table[i].holiday_mmdd,&p->gregymd[4]))
{
                p->holiday = yeardata.holiday_table[i].holiday_type;
                break;
              }

            /* ----- build the litdate field ----------------------------- */
            i = ((atoi(&p->juldate[4])) + (yeardata.jan1_day - '0')) % 7;
            if(i == 0) i = 7;
            p->daywk = i | '0';                 /* move day of week number */
            strcpy(p->daylit, dwktbl[i-1]);    /* move day of week literal */
            i = (((p->gregmdy[0]) - '0') * 10) + ((p->gregmdy[1]) - '0');
            strcpy(p->monthlit, julmo[i - 1]);          /* move month name */
            strcpy(p->litdate, p->monthlit);                 /* month name */
            i = 2;
            while(p->litdate[++i]);
            p->litdate[i++] = ' ';
            if(p->gregmdy[2] != '0')
              p->litdate[i++] = p->gregmdy[2];
            p->litdate[i++] = p->gregmdy[3];                        /* day */
            p->litdate[i++] = ',';                                /* comma */
            p->litdate[i++] = ' ';                                /* blank */
            memcpy(&p->litdate[i], p->gregymd, 4);                 /* year */
            p->litdate[i + 4] = '\0';
          }                                        /* end function datcomn */

          /*****************************************************************/
          /* yeartbl1 contains subscript values (0-13) to yeartbl2. When   */
          /* the next is 6 or 13, January 1st next year falls on Saturday, */
          /* and will be observed on December 31st of this year (the       */
          /* preceding Friday).                                            */
          /*****************************************************************/
          static int yeartbl1[201] = {
                              1,2,3,4,12,0,1,2,10,5,          /* 1900-1909 */
                              6,0,8,3,4,5,13,1,2,3,           /* 1910-1919 */
                              11,6,0,1,9,4,5,6,7,2,           /* 1920-1929 */
                              3,4,12,0,1,2,10,5,6,0,          /* 1930-1939 */
                              8,3,4,5,13,1,2,3,11,6,          /* 1940-1949 */
                              0,1,9,4,5,6,7,2,3,4,            /* 1950-1959 */
                              12,0,1,2,10,5,6,0,8,3,          /* 1960-1969 */
                              4,5,13,1,2,3,11,6,0,1,          /* 1970-1979 */
                              9,4,5,6,7,2,3,4,12,0,           /* 1980-1989 */
                              1,2,10,5,6,0,8,3,4,5,           /* 1990-1999 */
                              13,0,1,2,10,5,6,0,8,3,          /* 2000-2009 */
                              4,5,13,1,2,3,11,6,0,1,          /* 2010-2019 */
                              9,4,5,6,7,2,3,4,12,0,           /* 2020-2029 */
                              1,2,10,5,6,0,8,3,4,5,           /* 2030-2039 */
                              13,1,2,3,11,6,0,1,9,4,          /* 2040-2049 */
                              5,6,7,2,3,4,12,0,1,2,           /* 2050-2059 */
                              10,5,6,0,8,3,4,5,13,1,          /* 2060-2069 */
                              2,3,11,6,0,1,9,4,5,6,           /* 2070-2079 */
                              7,2,3,4,12,0,1,2,10,5,          /* 2080-2089 */
                              6,0,8,3,4,5,6,0,1,2,            /* 2090-2099 */
                              3 };                                 /* 2100 */

          /*****************************************************************/
          /* yeartbl2 contains data about the year: day of week for January*/
          /* 1st, leap year indicator, and holiday dates. Format is:       */
          /*   byte1: day of week for Jan 1: 0=Monday - 6=Sunday           */
          /*   byte2: leap year indicator: 1 = leap year else 0            */
          /*   bytes 3-42: holiday fields of 5 bytes each. Format of each: */
          /*          byte1: holiday type indicator (same as p->holiday)   */
          /*          bytes 2-5: MMDD date of the holiday                  */
          /* entry 7 type is pre-set for Good Friday, and entry 8 is       */
          /* pre-set for a possible New Year's Day observed when Jan1 of   */
          /* next year is Saturday                                         */
          /*****************************************************************/
          static struct year_entry2 yeartbl2[14]={
            {'6','0',{{'1',"0102"},{'4',"0529"},{'5',"0704"},{'6',"0904"},
                      {'7',"1123"},{'8',"1124"},{'9',"1225"},{'3',"0000"},
                      {' ',"1231"}}},
            {'0','0',{{'1',"0101"},{'4',"0528"},{'5',"0704"},{'6',"0903"},
                      {'7',"1122"},{'8',"1123"},{'9',"1225"},{'3',"0000"},
                      {' ',"1231"}}},
            {'1','0',{{'1',"0101"},{'4',"0527"},{'5',"0704"},{'6',"0902"},
                      {'7',"1128"},{'8',"1129"},{'9',"1225"},{'3',"0000"},
                      {' ',"1231"}}},
            {'2','0',{{'1',"0101"},{'4',"0526"},{'5',"0704"},{'6',"0901"},
                      {'7',"1127"},{'8',"1128"},{'9',"1225"},{'3',"0000"},
                      {' ',"1231"}}},
            {'3','0',{{'1',"0101"},{'4',"0525"},{'5',"0703"},{'6',"0907"},
                      {'7',"1126"},{'8',"1127"},{'9',"1225"},{'3',"0000"},
                      {' ',"1231"}}},
            {'4','0',{{'1',"0101"},{'4',"0531"},{'5',"0705"},{'6',"0906"},
                      {'7',"1125"},{'8',"1126"},{'9',"1224"},{'3',"0000"},
                      {' ',"1231"}}},
            {'5','0',{{' ',"0000"},{'4',"0530"},{'5',"0704"},{'6',"0905"},
                      {'7',"1124"},{'8',"1125"},{'9',"1226"},{'3',"0000"},
                      {' ',"1231"}}},
            {'6','1',{{'1',"0102"},{'4',"0528"},{'5',"0704"},{'6',"0903"},
                      {'7',"1122"},{'8',"1123"},{'9',"1225"},{'3',"0000"},
                      {' ',"1231"}}},
            {'0','1',{{'1',"0101"},{'4',"0527"},{'5',"0704"},{'6',"0902"},
                      {'7',"1128"},{'8',"1129"},{'9',"1225"},{'3',"0000"},
                      {' ',"1231"}}},
            {'1','1',{{'1',"0101"},{'4',"0526"},{'5',"0704"},{'6',"0901"},
                      {'7',"1127"},{'8',"1128"},{'9',"1225"},{'3',"0000"},
                      {' ',"1231"}}},
            {'2','1',{{'1',"0101"},{'4',"0525"},{'5',"0703"},{'6',"0907"},
                      {'7',"1126"},{'8',"1127"},{'9',"1225"},{'3',"0000"},
                      {' ',"1231"}}},
            {'3','1',{{'1',"0101"},{'4',"0531"},{'5',"0705"},{'6',"0906"},
                      {'7',"1125"},{'8',"1126"},{'9',"1224"},{'3',"0000"},
                      {' ',"1231"}}},
            {'4','1',{{'1',"0101"},{'4',"0530"},{'5',"0704"},{'6',"0905"},
                      {'7',"1124"},{'8',"1125"},{'9',"1226"},{'3',"0000"},
                      {' ',"1231"}}},
            {'5','1',{{'1',"0000"},{'4',"0529"},{'5',"0704"},{'6',"0904"},
                      {'7',"1123"},{'8',"1124"},{'9',"1225"},{'3',"0000"},
                      {' ',"1231"}}}
          };

          /*****************************************************************/
          /* The goodfri[] table contains the dates of Good Friday for each*/
          /* year from 1900 to 2099. An index to the table can be computed */
          /* as: year - 1900.                                              */
          /*****************************************************************/
          static struct {
            char good_friday_mmdd[5];     /* month-day date of Good Friday */
          } goodfri[200] = {
               {"0413"},{"0405"},{"0328"},{"0410"},{"0401"},  /* 1900-1904 */
               {"0421"},{"0413"},{"0329"},{"0417"},{"0409"},  /* 1905-1909 */
               {"0325"},{"0414"},{"0405"},{"0321"},{"0410"},  /* 1910-1914 */
               {"0402"},{"0421"},{"0406"},{"0329"},{"0418"},  /* 1915-1919 */
               {"0402"},{"0325"},{"0414"},{"0330"},{"0418"},  /* 1920-1924 */
               {"0410"},{"0402"},{"0415"},{"0406"},{"0329"},  /* 1925-1929 */
               {"0418"},{"0403"},{"0325"},{"0414"},{"0330"},  /* 1930-1934 */
               {"0419"},{"0410"},{"0326"},{"0415"},{"0407"},  /* 1935-1939 */
               {"0322"},{"0411"},{"0403"},{"0423"},{"0407"},  /* 1940-1944 */
               {"0330"},{"0419"},{"0404"},{"0326"},{"0415"},  /* 1945-1949 */
               {"0407"},{"0323"},{"0411"},{"0403"},{"0416"},  /* 1950-1954 */
               {"0408"},{"0330"},{"0419"},{"0404"},{"0327"},  /* 1955-1959 */
               {"0415"},{"0331"},{"0420"},{"0412"},{"0327"},  /* 1960-1964 */
               {"0416"},{"0408"},{"0324"},{"0412"},{"0404"},  /* 1965-1969 */
               {"0327"},{"0409"},{"0331"},{"0420"},{"0412"},  /* 1970-1974 */
               {"0328"},{"0416"},{"0408"},{"0324"},{"0413"},  /* 1975-1979 */
               {"0404"},{"0417"},{"0409"},{"0401"},{"0420"},  /* 1980-1984 */
               {"0405"},{"0328"},{"0417"},{"0401"},{"0324"},  /* 1985-1989 */
               {"0413"},{"0329"},{"0417"},{"0409"},{"0401"},  /* 1990-1994 */
               {"0414"},{"0405"},{"0328"},{"0410"},{"0402"},  /* 1995-1999 */
               {"0421"},{"0413"},{"0329"},{"0418"},{"0409"},  /* 2000-2004 */
               {"0325"},{"0414"},{"0406"},{"0321"},{"0410"},  /* 2005-2009 */
               {"0402"},{"0422"},{"0406"},{"0329"},{"0418"},  /* 2010-2014 */
               {"0403"},{"0325"},{"0414"},{"0330"},{"0419"},  /* 2015-2019 */
               {"0410"},{"0402"},{"0415"},{"0407"},{"0329"},  /* 2020-2024 */
               {"0418"},{"0403"},{"0326"},{"0414"},{"0330"},  /* 2025-2029 */
               {"0419"},{"0411"},{"0326"},{"0415"},{"0407"},  /* 2030-2034 */
               {"0323"},{"0411"},{"0403"},{"0423"},{"0408"},  /* 2035-2039 */
               {"0330"},{"0419"},{"0404"},{"0327"},{"0415"},  /* 2040-2044 */
               {"0407"},{"0323"},{"0412"},{"0403"},{"0416"},  /* 2045-2049 */
               {"0408"},{"0331"},{"0419"},{"0404"},{"0327"},  /* 2050-2054 */
               {"0416"},{"0331"},{"0420"},{"0412"},{"0328"},  /* 2055-2059 */
               {"0416"},{"0408"},{"0324"},{"0413"},{"0404"},  /* 2060-2064 */
               {"0327"},{"0409"},{"0401"},{"0420"},{"0412"},  /* 2065-2069 */
               {"0328"},{"0417"},{"0408"},{"0324"},{"0413"},  /* 2070-2074 */
               {"0405"},{"0417"},{"0409"},{"0401"},{"0421"},  /* 2075-2079 */
               {"0405"},{"0328"},{"0417"},{"0402"},{"0324"},  /* 2080-2084 */
               {"0413"},{"0329"},{"0418"},{"0409"},{"0401"},  /* 2085-2089 */
               {"0414"},{"0406"},{"0328"},{"0410"},{"0402"},  /* 2090-2094 */
               {"0422"},{"0413"},{"0329"},{"0418"},{"0410"}   /* 2095-2099 */
            };

          /*****************************************************************/
          /* tblukup(): performs year table lookups using the gregmdy year.*/
          /* The data entry found is moved to the yeardata area.           */
          /*****************************************************************/
          void tblukup(struct DATEGENL *p) {
            int i, j, *q;
            char char_year[5];

            /* ----- compute the year table index = year - 1900 ---------- */
            memcpy(char_year, p->gregymd, 4);
            char_year[4] = '\0';
            i = atoi(char_year);                    /* convert year to int */
            i -= 1900;                      /* deduct 1900 for index value */
            j = yeartbl1[i];             /* get index to second year table */

            /* - move entry for the specified year to the yeardata field - */
            yeardata = yeartbl2[j];              /* copy data for the year */

            /* - move the Good Friday date to the yeardata holiday table - */
            strcpy(yeardata.holiday_table[7].holiday_mmdd,
                                               goodfri[i].good_friday_mmdd);

            /* if next year begins on Saturday, make December 31 a holiday */
            if((yeartbl1[i+1] == 6) || (yeartbl1[i+1] == 13)) {
              yeardata.holiday_table[8].holiday_type = '1';} /* 12/31 NewYr*/

            /* ----- set year type in dategenl structure ----------------- */
            p->yeartyp = yeardata.leap_year_ind; /* year type to dategenl  */

            /* ----- set correct values in the gregcvrt() table ---------- */
            q = gregcv0;
            if(p->yeartyp == leap_year)
            q = gregcv1;
            for(i = 0; i < 13; i++)
              gregcvrt[i] = *q++;
            }                                      /* end function tblukup */

./ ADD NAME=HANDBOOK 0100-02144-02144-0950-05773-05773-00000-BC0THOR

          *----------------------------------------------------------------*
          *                    Elementary C Programming            LESSON01*
          *----------------------------------------------------------------*
                       Installation, Customizing, and Checkout

         I. Install Turbo C++ Version 1.3 Second Edition (DOS)

            A. Basic installation on hard drive (must have 6MB free)
               1. Put Disk 1 in the A drive
               2. Type A:INSTALL and press ENTER
               3. Press ENTER to continue with installation
               4. Press ENTER for Source Drive is A
               5. Arrow down to Start Installation, press ENTER
               6. Remove/Insert disks as requested until all 5 are done
               7. At end press ENTER until the C:> DOS prompt appears

            B. Make source and output directories
               1. Type following lines (ENTER after each):
                         CD C:\TC
                         MD CSOURCE
                         MD OUTPUT

            C. Set up DOS System files using a file editor. Be sure to use
               a simple ASCII editor such as EDLIN or DOS's EDIT, not one
               like WordPerfect which adds control information to the file.
               1.Put FILES=20 (or more) in CONFIG.SYS
               2.Add ;C:\TC\BIN;C:\TC\OUTPUT to path in AUTOEXEC.BAT
               3.Create C:\TC.BAT containing the following lines:
                         CD C:\TC\CSOURCE
                         C:\TC\BIN\TC

            D. Customize the Turbo C++ environment
               1. At the C:\> prompt, type TC. This should start Turbo C++
                  which will display a window with information about Turbo C++
                  and with OK at the bottom. Press ENTER to continue.
               2. Activate the Options pull-down menu by typing Alt-O or
                  F10/O.
               3. Type D to activate the Directories window.
               4. Tab to the Output Directories window and type C:\TC\OUTPUT
                  then press ENTER.
               5. Activate the Options pull-down menu again using Alt-O or
                  F10/O then type S for the save window, then press ENTER to
                  save the updated options.

        II. Test the Turbo C++ Version 1.3 Second Edition Installation

            A. Re-Boot the system to bring in the updated system files.

            B. At the C:\> prompt, type TC. This should start Turbo C++
               which will display a window with information about Turbo C++
               and with OK at the bottom. Press ENTER to continue.

            C. Create, compile, and execute a short program.
               1. Start a Turbo C++ session by typing TC and pressing ENTER.
               2. Open a file by typing Alt-F/O or just F3
               3. The name window will contain *.C initially. Ignore this
                  and type HELLO.C which will replace the *.C, then press
                  ENTER.
               4. An EDIT window will open with a double line around it,
                  showing it is the "active" window. HELLO.C will appear
                  centered at the top.
               5. Type the following lines (ENTER after each line):
                        /* hello.c --- Hello, World! */
                        #include <stdio.h>
                        main() {
                          printf("Hello, World!\n");
                        }
               6. Save this source program by pressing F2.
               7. Compile and link (Make) the program by pressing F9.
               8. A window should appear saying "Success Press Any Key".
               9. Press any key.
              10. The edit screen reappears with a MESSAGE screen at the
                  bottom. The double line is on the MESSAGE screen, which is
                  now the "active" screen. The messages include a warning
                  concerning function returning a value. Note that the arrow
                  keys move you around in the MESSAGE window, NOT the edit
                  window. This message is only a warning and the program will
                  run o.k. as-is, however we will fix the warning later.
              11. Switch to the EDIT window by pressing F6
              12. To run the program, press Alt-R/R or Ctrl-F9. The program
                  will execute. Since it writes to the screen, your screen
                  will blink momentarily.
              13. To view the output of the program press Alt-F5. You should
                  see Hello, World! as the last line displayed. To return to
                  Turbo C++, press any key.

            D. Exercise some other IDE functions
               1. Insert the word void before the main function header:
                        void main() {
               2. Compile and link (Make) the program by pressing F9.
               3. A window should appear saying "Success Press Any Key".
               4. Press any key.
               5. The edit screen should reappear as the active window with
                  a double line around it.
               6. Move the cursor to one of the letters in the word printf
                  and press Ctrl-F1 for HELP concerning this function.
               7. Scroll down the HELP window using the arrow keys and/or
                  the PgUp and PgDn keys. Note the amount of information
                  given for the printf function.
               8. Press Alt-X to exit from Turbo C++.

          *----------------------------------------------------------------*
          *                    Elementary C Programming            LESSON02*
          *----------------------------------------------------------------*
                            Basic Structure of C Programs

         I. Basic Organization of C programs (refer to hello2.c listing)

            A. Explanatory comments (optional, but traditional).

            B. Preprocessor commands as needed (#include, #define, etc).

            C. Function Prototypes as needed.

            D. Global variables and constants.

            E. Processing functions.
               1. Function header.
               2. Any or all the statements listed in A-D above.
               3. C language processing instructions.
               4. One and only one function must be named main.

        II. Syntax.

            A. General.
               1. Extra white space is ignored by the compiler.
               2. At least one blank is often needed around a word to make
                  it identifiable to the compiler.
               3. The C language is case sensitive. The words TXT, Txt,
                  TxT, txT, and txt are all different.

            B. Comments.
               1. Comments begin with /* and continue to the next */.
               2. Missing or misspelled */ can cause ugly problems.
               3. Ctrl-Q [ is handy to locate the ending */.

            C. Preprocessor commands.
               1. All begin with # followed by the command name.
               2. Command names are always in lower case.
               3. Have no ending semicolon.
               4. #include is similar to COBOL COPY.
               5. #define causes the first operand to be replaced by the
                  second operand before compilation begins.

            D. Function Prototypes.
               1. Pre-define user functions to insure proper use.
               2. Specify the data returned, if any.
               3. Specify the type, number, and order of parameters passed
                  when the function is invoked.

            E. Global variables and constants.
               1. Begin with a type or type modifier such as int, char,
                  unsigned, long, float, const, etc.
               2. Contain the name of the variable or constant.
               3. Use square brackets to identify arrays and give array
                  dimensions.
               4. Always end with a semicolon.

            F. Processing functions.
               1. Have function headers very similar to their prototypes.
               2. Parameters are contained within parentheses following the
                  function name.
               2. Do not end with a semicolon.
               3. Processing instructions are enclosed within curly braces.
               4. Missing or extra curly braces cause compile errors.
               5. Ctrl-Q [ is handy to locate the ending curly brace.

            G. Processing statements.
               1. Most processing statements end with a semicolon.
               2. May be grouped as a block within Curly Braces.
               3. Semicolons are not usually used following the ending
                  brace of a block of instructions.
               4. Square brackets enclose subscripts
               5. Double quotes enclose string constants
               6. Single quotes enclose character constants
               7. Escape sequences are used to specify special characters.
                  They begin with a backslash followed by a letter or
                  sometimes digits. Examples are:
                        \n   = newline (hex 0A)
                        \t   = tab (hex 09)
                        \b   = backspace (hex 08)
                        \r   = carriage return (hex 0D)
                        \f   = form feed (hex 0C)
                        \'   = single quote (apostrophe)
                        \"   = double quote
                        \\   = back-slash
                        \xdd = a hexadecimal value where each d is 0-F


       III. See APPNDXB for a comparison of COBOL and C data definitions.

        IV. Hands-On Session (refer to APPNDXA for Editor keys):
            A. Get into Turbo C's IDE:
                    cd c:\tc\csource
                    tc

            B. Load hello2.c into the IDE Edit window:
                    F3
                    c:\tc\csource\hello2.c

            C. Insert some source code errors:
               1. Change #define to #degine on line 4
               2. Change main() to maiin() on line 10
               3. Delete the ending " on line 19.
               4. Delete the ending right parenthesis on line 22

            D. Attempt to run the program: Ctrl-F9

            E. An error message appears: press any key to remove it.

            F. Screen now has Edit window above, but Message window below and
               it is the active window. Press the arrow keys and see how the
               display is affected. Note that the Edit window cursor moves to
               the line containing the error.

            G. Correct the "Unknown preprocessor directive ..." error:
                     Press F6 until the Message Window is active
                     Use the up and down arrow keys to highlight the
                     "Unknown Preprocessor ..." message.
                     Press F6 to activate the Edit Window.
                     Change the word "degine" to "define"

            H. Correct the "Undefined symbol White ..." error:
                     Press F6 to activate the Message Window.
                     Press the down arrow key to highlight the next error.
                     Note that this error was caused by the misspelled
                     preprocessor directive above.

            I. Correct the "Unterminated string ..." error:
                     Press the down arrow key to highlight the next error.
                     Press F6 to activate the Edit Window.
                     Insert the ending " just after the \n at the end of the
                     line. Note that the End key is handy to jump to the end
                     of the line.

            J. Correct the "Function call missing ) ..." error:
                     Press F6 to activate the Message Window.
                     Press the down arrow key to highlight the next error.
                     Press F6 to activate the Edit Window.
                     Missing (unbalanced) parentheses, braces, brackets,
                     quotes, apostrophes, comment delimiters and so forth
                     can be difficult to find. To exercise use of the editor
                     here:
                        Place the cursor on the ending ")" on line 22.
                        Press Ctrl-Q [ to find the matching "(".
                        Now press Ctrl-Q } to get back to the original ")".
                     Add a new ")" just before the ending ";" om line 22.
                     Put the cursor on the new ")" just added and again
                     enter Ctrl-Q [ to locate the matching "(". This should
                     now land on the "(" after printf.

            K. Attempt to run the program again: Ctrl-F9
            L. An error message appears: press any key to remove it.

            M. Correct the "Undefined label _main ..."
                     First, note that this is a Linker error, not a compiler
                     error.
                     You should also be aware that most function names are
                     prefixed by an underscore by the compiler, so the
                     missing label is really "main".
                     Finally, the C language requires one and only one
                     function named "main" to exist in an executable module,
                     as this is the initial entry point where execution
                     begins.
                     Since the IDE has no way to tell where the "main"
                     function may be, it does not identify a source line to
                     be changed.
                     Press F6 to activate the Edit Window.
                     Use the PgUp, PgDn, and arrow keys to locate line 10.
                     change maiin to main

            N. Before executing the program see if you can guess what the
               output will be:
               1. How many lines of output will there be?
               2. What will the output say?

            O. Attempt to run the program: Ctrl-F9

            P. Run is successful, use Alt-F5 to check output.

          *----------------------------------------------------------------*
          *                    Elementary C Programming            LESSON03*
          *----------------------------------------------------------------*
                           Variables, Operators, and printf


         I. Fundamental C data definitions.

            A. Characteristics of variables and constants.
               1. Lifetime of a variable is the length of time it exists.
               2. Visibility, also called scope, refers to the parts of a
                  program in which a variable can be recognized.
               3. Automatic variables are also called local variables or
                  dynamic local variables. Automatic variables are defined
                  within the body of a function. They are created when the
                  function is entered for execution and destroyed when
                  execution returns to the caller of the function. Because of
                  this, they cannot retain values across calls to the
                  function. Automatic variables are visible only within the
                  function in which they are defined, so the names of
                  automatic variables can be reused in many functions in a
                  program with each function using its own version.
               4. External variables are also referred to as global variables.
                  They can be referenced by name in any function within a
                  program. They are created when the executable program is
                  created and last for the duration of the program's execution
                  so that their content is retained across any function call.
                  The contents of a global variable may be set or changed by
                  any function. External variables must be defined outside any
                  function. An external variable is automatically visible to
                  all functions which follow its definition in the same source
                  program file. Functions which precede the definition in the
                  same source program file, and functions which are separately
                  compiled must declare the external variable with an extern
                  statement before it can be used. For example, suppose the
                  variable abc is defined in source program abcmain.c outside
                  any function (normally before any function definition), and
                  it is to be used in another source program called abcsubr.c:
                  a. In abcmain.c, before any function is defined we might see
                              int abc;       /* global variable abc */
                  b. Then in order to use this variable in the separate source
                     program abcsubr.c, the variable abc would be declared:
                              extern int abc;  /* declare the global abc */
               5. Static variables are defined within a function using the
                  static qualifier:
                              static int holdits_value;
                  Like automatic variables, a static variable can be seen only
                  within the function in which it is defined. The static
                  variable is created when the function is initially entered
                  for execution and remains in existence for the duration of
                  execution of the program. If the defining function returns
                  and is later called again, the static variable will contain
                  the last value placed in it.

            B. Types of variables
               1. char is a single byte which can hold one character in the
                  local character set of the machine being used.
               2. int represents an integer of the natural size of integers on
                  the machine being used.
               3. float is a single-precision floating point number.
               4. double is a double-precision floating point number.
               5. The physical memory size required for a given type of
                  variable is not specified by the C language, but rather by
                  machine being used. The range of values for a numeric item
                  depends on its size. Here are some common machines and the
                  variable sizes used:

                          DEC       Honeywell   IBM 370     IBM
                          PDP-11    6000        MAINFRAME   PC

                          ASCII     ASCII       EBCDIC      ASCII
                  char     8 bits    9 bits      8 bits      8 bits
                  int     16        36          32          16
                  short   16        36          16          16
                  long    32        36          32          32
                  float   32        36          32          32
                  double  64        72          64          64

               6. For the IBM PC, the basic data types can hold the following
                  numeric values:
                  char (1 byte) signed range is -128 to +127
                                unsigned range is 0 to 255
                  int  (2 bytes) signed range is -32,768 to +32,767
                                 unsigned range is 0 to 65,535
                  short is same as int on the PC
                  long (4 bytes) signed range is -2,147,483,648 to
                                                 +2,147,483,647
                  float (4 bytes) exponent has a range of 10**-38 to 10**+38
                                  mantissa has up to 6 digits of precision
                  double (8 bytes) exponent has a range of 10**-308 to
                                   10**+308 while the mantissa has up to 15
                                   digits of precision
            C. Syntax for defining basic variables.
               1. Storage class specifier. Optional, but when specified may be
                  auto, static, extern, register, or typedef.
               2. Type modifier is also optional. It may be short, long, or
                  unsigned.
               3. Type specifier is required and may be char, short, int,
                  long, unsigned, float, double, struct specifier, union
                  specifier, or typedef name. Note that short, long, and
                  unsigned may optionally be followed by int so that these
                  modifiers can act alone as specifiers.
               4. Name is the identifier used to refer to the variable in
                  procedure statements. Names may contain a-z (both upper and
                  lower case), digits 0-9 and the underscore. The first
                  character must be a letter or underscore. Names may contain
                  any number of characters, but only the first 31 will be used
                  by the compiler.
               5. When an array is defined, a pair of square brackets follows
                  the name. The number of occurrences may be contained within
                  the brackets.
               6. An initial value may be supplied for the variable. If so, is
                  is specified following an = sign following the preceding
                  definition.
               7. The variable definition is terminated with a semicolon.

            D. Initializing variables
               1. If an initial value is given, it is preceded by an = sign.
               2. Single characters (including escape sequences) are
                  surrounded in single quotes (apostrophes). Examples:
                        char ltr = 'a';
                        char carriage_return_character '\r';
                        char hex_byte = '\x9D';
               3. Integer values may have an optional sign followed by decimal
                  digits to make a value between -32768 and 32767. Unsigned
                  integers can be from 0 to 65535. Examples:
                       int countr;
                       int negval = -6339;
                       int posval = 32767;
                       unsigned int maxval = 65535;
               4. Long values may have an optional sign followed by decimal
                  digits to form a value in the range -2147483648 to
                  2147483647. An unsigned long can be from 0 to 4294967295.
                  Examples:
                       long bignum;
                       unsigned long = 4123456789;
                       long negnbr = -60;
               5. Float values contain decimal points and can contain an
                  optional sign followed by a value in decimal notation or in
                  exponential notation. Float values have up to 6 digits of
                  precision and an exponent range from -38 to +38. Examples:
                       float fltnum;
                       float smlnbr = 99.99;    -or-   float smlnbr = 9999E-2;
                       float lrgnbr = 320000.0; -or-   float lrgnbr = 3.2E5;
               6. Double values are identical to float except in range. The
                  double has up to 15 digits of precision and an exponent
                  range of -308 to +308.

        II. Arithmetic and assignment operators used in C

            A. Arithmetic Operators:
               1. Addition: +
               2. Subtraction: -
               3. Multiplication: *
               4. Division: /
               5. Remainder: %
               6. Unary - permitted, but not unary +

            B. Increment and decrement operators
               1. Increment: ++
               2. Decrement: --
               3. Prefix means apply before using the variable
               4. Postfix means to use the variable in the expression as-is,
                  then apply the increment or decrement.

            C. Assignment Operators
               1. Set variable to the value of an expression: =
               2. Add a value to present content of a variable: +=
               3. Subtract a value from present content of a variable: -=
               4. Multiply present content of a variable: *=
               5. Divide into present content of a variable: /=

       III. The printf function

            A. The printf() function is used to display information on the
               screen. The output data may contain constant text interspersed
               with formatted data from variables.

            B. The parameter data passed to printf is somewhat confusing, as
               it is in two parts. The first portion contains a character
               string enclosed in double quotation marks. This first portion
               provides all the constant text and identifies where to place
               and how to format any data from variables. The second portion
               of the parameter data contains the variables which are to be
               used in the first portion. For example:
                    printf("Variable abc\'s data here: %d",abc);
               Note the first portion is a character string enclosed within
               quotes. The second portion names the variable to be mapped into
               the first portion. In the first portion, the position for a
               variable is identified by a % followed by the formatting rules.
               In this case, the %d indicates a decimal number is to be
               included from the variable given in the second part. A comma
               separates the two parts following the quote ending the first
               part. In this case, the variable to be used is called abc.

            C. Some format specifiers used with printf
               1. %d specifies signed decimal from an int
               2. %ld specifies signed decimal from a long
               3. %X specifies upper-case hexadecimal from an int
               4. %u specifies unsigned decimal from an int
               5. %c specifies a single character from a char
               6. %s specifies characters from a null-terminated string
               7. %f specifies decimal from a float
               8. %e specifies decimal from a double
               9. %p specifies a pointer value

            D. Width modifiers immediately follow the % if used.
               1. Flags or modifiers
                  a. - prints left justified in the field
                  b. + prints a number with a sign always
                  c. 0 causes leading zero fill
               2. Minimum field width. If output size is less than this it
                  will be right justified with leading blanks unless a flag is
                  used to change this default.
               3. A period may be given followed by the number of decimal
                  places to be displayed.

        IV. Hands-On Session: (see APPNDXA for editor keys):

            A. Invoke Turbo C++.
               1. At the DOS prompt type:
                        tc
               2. Type Alt-F3 to clear the current edit window.
               3. Press F3 to get the Load a File Window.
               4. Type:
                        d:\tc\csource\circle.c

            B. Find all global and automatic variables.

            C. Find any arithmetic operators. What are they?

            D. What types of variables are used in the program?

            E. How is a floating point variable specified in printf?

            F. Use the pair matching function of the editor to locate the
               ending brace for the main function.

            G. Use the language help function of the editor to learn more
               about the atof function. What does it return? Is it portable?

            H. Run the program and check the output screen? Why did you get
               that output? Use the Run menu pull-down to enter a radius value
               as an argument, then re-run. Is the output correct now?

          *----------------------------------------------------------------*
          *                    Elementary C Programming            LESSON04*
          *----------------------------------------------------------------*
                            Include, Define, and Functions

         I.  General.

             A. Program organization.
                1. Comments optionally precede code to describe the
                   program.
                2. Preprocessor statements.
                   a. #include.
                      1. Identify header files to be included in the
                         program.
                      2. Header files never print with the #include'ing
                         program, but may be viewed via the editor if
                         desired.
                      3. Statements in #include'd headers acts exactly as
                         though it were coded there by the programmer.
                      4. When the header file is a standard library header
                         supplied with the compiler it will be found in the
                         standard include file. In this case, the name is
                         included in angle brackets:
                                  #include <stdio.h>
                      5. When a user-written header file is to be included,
                         it is included within double quotation marks. If
                         it will be found in the current source program
                         directory, only the file name is needed, otherwise
                         a full path is required:
                                  #include "d:\tc\myheaders\vruhead.h"
                   b. #define statements.
                      1. Can be used to provide a replacement of one word
                         by another. This is useful in areas which may
                         change to permit a single point of change to
                         simplify maintenance. For example, a table may
                         increase in size over time. To minimize
                         maintenance problems caused by cahnges, you might
                         code:
                                  #define NUM_STATES 48
                         This would cause the preprocessor to scan for all
                         occurrences of the string NUM_STATES and replace
                         each with 48. This would be done prior to
                         compilation. For example, the following code would
                         be affected:
                                  int state_population[NUM_STATES];

                                  for(i=0;i<NUM_STATES;i++)
                      2. It is traditional, but not required, to use all
                         upper-case names for #define'd names.
                      3. If a name is given with no value, it is considered
                         to be "defined" for use by the #ifdef and #ifndef
                         directives. The #ifdef statement is true if the
                         following name is defined. The #ifndef statement is
                         true if the following name is not defined.
                         Consider a small header file called myhdr.h which
                         defines some global variables:

                                 /* define global variables */
                                 #ifdef MAIN
                                   int i;         /* index 1 */
                                   int j;         /* index 2 */
                                   float total;   /* sales total */
                                 #endif MAIN

                                 #ifndef MAIN
                                   extern int i;         /* index 1 */
                                   extern int j;         /* index 2 */
                                   extern float total;   /* sales total */
                                 #endif MAIN
                         In the main source program we would #define MAIN
                         so that the globals will be defined:
                                /* main program */
                                #define MAIN
                                #include "myhdr.h"
                                void main() {
                                .
                                .
                                .
                         And in a separate source module we want externs,
                         so MAIN is not #define'd:
                                /* called functions module */
                                #include "myhdr.h"
                                int subfun1(int req, char typ, float fig) {
                                .
                                .
                                .
                3. Function prototypes can be anywhere outside any function
                   and prior to the first call to the function.

                4. Global data can be defined anywhere outside any function
                   and prior to the first reference to it. If a global
                   variable is not defined in the same source module and
                   before the first reference to it, the field must be
                   declared with an extern to prevent the compiler from
                   flagging the reference as an undefined variable.

                5. Every executable program must have function named main.
                   1. This is always the entry point to an executable
                      program.
                   2. The only valid parameters on the main function are the
                      command line parameters. In modern C these are
                      usually coded as:
                                 void main(int argv, char *argv[])
                   3. In the original C, the parameters for a function had
                      to be defined following the header, so this is the
                      way they appeared:
                                 main(argc, argv)
                                 int argc;    /* number strings */
                                 char *argv[]; /* array of strings */
                   4. Traditionally, argc and argv are the names given to
                      the command line parameters received by the main
                      function, however they may be called any desired
                      name.
                   5. The argc parameter is an int that contains the number
                      of strings entered on the command line when the
                      program was invoked. The argv aprameter is an array
                      of strings containing everything entered on the
                      command line. For example, assume a program was
                      invoked by entering the following command:
                                 prvmaint old_provider new_provider prv_rpt
                      In this case, since four strings were entered, argc
                      would contain a 4 and argv would contain an array of
                      pointers to the four strings "prvmaint",
                      "old_provider", New_provider" and "prv_rpt".

             B. Function organization.
                1. Comments are optionally provided to explain the purpose
                   of the function.
                2. A function header identifies the function to the
                   compiler and gives information about what kind of data
                   (if any) will be returned by the function, and about the
                   parameters received on entry.
                3. Argument definitions are enclosed in parentheses. They
                   show the order and names of the parameters, and may also
                   contain the full definitions for parameters in modern
                   compilers. In older compilers, the parameter fields must
                   be separately defined following the function header and
                   before the opening brace for the body.
                4. Preprocessor statements such as #include and #define may
                   be used if needed.
                5. Body of function.
                   a. Is enclosed within braces.
                   b. Data definitions precede processing instructions.
                   c. Processing instructions follow data definitions.
                   d. A closing brace ends the body. No final semicolon is
                      used.

        II.  Syntax.

             A. Prototype.
                1. Return value.
                   a. Only a single value is possible.
                   b. Can be a basic C type (int, char, float, long, double).
                   c. Void can be used if no value is returned.
                   d. Can be a user defined struct or union (not in
                      original C).
                   e. Arrays cannot be returned.
                   f. Pointers
                2. Parameter field.
                   a. Enclosed in parentheses.
                   b. Specifies order of parameters.
                   c. Specifies types of parameters.
                   d. Optionally names parameters
                3. Termination is a semicolon.

             B. Header.
                1. Return value same as in prototype.
                2. Parameter field
                   a. May be same as in prototype.
                   b. If parameter arguments are not defined within the
                      parameter field parentheses, they must be defined
                      prior to the opening brace for the body of the
                      function.
                3. Function body.
                   a. Enclosed in braces following the header and any
                      input parameter definitions.
                   b. Contains the data and instructions which comprise the
                      function.
                   c. Data definitions must precede the first executable
                      instruction in any block of instructions bounded by
                      braces.
                4. Termination is the ending brace for the body. There is
                   no ending semicolon.

             C. Reference (calling the function)
                1. Return value
                   a. Void is never specified on a call.
                   b. The value returned by a function can be ignored by
                      merely not referring to it in the call.
                   c. When a returned value is to be used, a variable must
                      be coded followed by the call to the function. When
                      the function returns, the value is copied into the
                      variable specified. For example, given a function
                      whose prototype is:
                                             int sum(int, int);
                      To get the value returned into a variable called
                      total, you would code:
                                             total = sum(cost1, cost2);
                2. Parameter field.
                   a. Parameter field is enclosed within parentheses.
                   b. Names the data fields to be passed to the function.
                   c. Data fields must be passed in the same order they are
                      specified on the prototype and header statements.
                   d. Data fields passed must have the types specified on
                      the prototype statement.
                3. Termination is a semicolon after the parameter field.

       III.  Passing data to and from functions.

             A. Passing by value.
                1. Except for arrays, a copy is made of a data item passed
                   to a called function.
                2. The called function cannot change the original data
                   field in the calling function for non-arrays unless a
                   pointer is passed to it.

             B. Passing by reference.
                1. This is the method used by COBOL. A pointer is passed
                   which contains the address of the original data field(s)
                   in the calling program.
                2. Any changes made by the called program affect the
                   original data field in the calling program.
                3. This method of reference is always used by c for arrays
                   and can always be done, if desired, by passing a pointer
                   rather than a data name.

             C. Returning values.
                1. This is of limited value, as only one value can be
                   returned.
                2. As noted above, input parameter fields can be changed by
                   a called function when the parameter is an array, or
                   when a pointer is passed.
                3. A global variable can be modified by the called function
                   which can be used by the caller on return. When global
                   variables are to be changed they are not specified in
                   the called function's parameter list (or a copy would be
                   passed).
                4. The return statement is used to return a value to the
                   function's caller. Syntax for the return statement looks
                   like a function call, as the return value or an
                   expression containing it are in parentheses following
                   the return keyword:
                                return(volume);

             D. Terminating functions and programs.
                1. The return keyword can be used to immediately terminate
                   a function and return to the caller with a value.
                2. The exit keyword can be used to terminate a program and
                   pass a value which can be tested by the batch file (PC)
                   or shell program (UNIX and AIX) which invoked the
                   program. This is analogous to the return code used by
                   mainframe JCL. The exit statement is coded like a
                   function call with a parenthesized value following the
                   exit keyword. For example, to terminate a program and
                   return a value of 3:
                                         exit(3);
                3. A function automatically returns to its caller if
                   control passes to the ending brace for the body of the
                   function. If the function is main, this will also result
                   in program termination.

             E. External variables.
                1. External variables (global variables) are those defined
                   outside any function. They are often defined prior to
                   the first function is a source module, but may occur
                   between functions or after the last function in the
                   source module.
                2. Global variables can be used by any function in the same
                   source module that follows the definition.
                3. While global variables are accessible by any function in
                   an executable program, they can be referenced directly
                   only by those functions defined in the same source
                   module following the definition. In separate source
                   modules or functions preceding the definition of the
                   global variable, an extern statement must be used to
                   declare use of the variable.



        IV.  For a listing of the library functions provided by Turbo C,
             see APPNDXC.

          *----------------------------------------------------------------*
          *                    Elementary C Programming            LESSON05*
          *----------------------------------------------------------------*
                            Arrays, Strings, and Constants

         I. Arrays.

            A. Arrays are defined by enclosing the number of occurrences
               within square brackets following the name.

            B. When initial values are supplied, the square brackets may be
               empty, and the compiler will use the number of values supplied
               as the number of occurrences. If a number of occurrences is
               given in the square brackets this is used in creating the
               array. Examples:

                 int year_counts[12];   /* an array of 12 int counters */
                 float week_vals[] = {0.0, 12.3, 2.9, 41.6, 17.1};
                 char text_line[5] = {'t', 'e', 'x', 't', '\0'};
                 long multi_lvl[3][4] = {{5, 1, 99, 67},
                                         {33, 2195, 703, 1},
                                         {23945, 0, 0, 193}};

            C. Array elements are referenced in the same manner they are
               defined: by use of square brackets. When referring to an array
               element, however, the brackets must contain the number of
               the element. Unlike COBOL, C begins with 0 so that the first
               element of the array year_counts would specified as:
                            year_counts[0]

            D. Since the bracketed subscript value begins with 0, the last
               element in an array is one less than the number of occurrences.
               For example, the last element of the array text_line would be
               coded:
                             text_line[7]

            E. The array name when used without a bracketed subscript is
               valid, and is treated by C as a pointer to the first element of
               the array. Use of pointers is covered later.

        II. Strings.

            A. Strings are not a real data type in C, but are handled as arrays
               of characters. Even so, strings can be defined by enclosing the
               string characters between double quotation marks. For example,
               the array above called text_line could have been defined as
               follows:
                           char text_line = "text";

            B. Strings in C are null-terminated. That is,each string ends with
               a null character ('\0') which occupies a byte. Whenever a
               string is specified within double quotation marks, the C
               compiler will append a null to the string so that it will
               occupy one byte more than the number of characters between
               quotes. This must be accounted for or overlays will occur.
               Examples:

                  char strg[12];       /* 11-char and 1 null string */
                  char fild_str[] = "abc";  /* 3 char and 1 null string */
                  char strg_aray[4][9] = {"Dick",
                                          "Jane",
                                          "Harry",
                                          "James"};

       III. Constants

            A. Constants can be specified within a statement as self-defining
               values in the same way they are given as initial values: a
               single character will appear between apostrophes, an integer as
               a string of decimal digits, a float including a decimal point,
               and a string between double quotes. Some examples are:
                       a_vrbl = 'w';
                       carr_rtrn = '\r';
                       record_counter += 1;
                       cost_factor = 23.97378;


            B. The const keyword can be used with one of the standard data
               types to create an unchangeable constant. Constants are often
               given names in capital letters. Examples:
                       const char NEW_LINE = '\n';
                       const float PI = 3.14159;
                       const int CON5 = 5;
        IV. Hands-on

            A. Start an IDE session in Turbo C++ using program circle.c:
               1. Type TC on the command line at the DOS prompt and press the
                  ENTER key.
               2. When the IDE window appears, type Alt-F3 to close the
                  program window unless it contains circle.c.
               3. On the Load A File screen type d:\tc\csource\circle.c and
                  press ENTER. This should bring the circle.c program into the
                  edit window.

            B. Trace a few lines of the program:
               1. Press F7 (trace). You should see the program compile, then
                  the edit screen will scroll to the line containing the
                  header for the main function, which will be highlighted.
               2. Press F7 again. The if( ... statement is highlighted.
               3. Press F7 again. The printf( ... statement is highlighted.
               4. F7 again causes the screen to flash and the exit statement
                  is highlighted.
               5. F7 again terminates the test.
               6. Now press Alt-F5 to view the screen and you should see a
                  message showing "Usage is circle radius."
               7. Press any key to return to the IDE.

            C. Set the command line argument for the circle program and
               execute it.
               1. Press Alt-r to activate the Run window, then A for the
                  Program Arguments window. Type a radius value of 12.5 into
                  the window and press ENTER.
               2. Now press Ctrl-F9 to execute the program. You should see the
                  screen flash as the output is written.
               3. Press Alt-F5 to view the screen. There should be four lines
                  showing the radius given, the area of the circle, the
                  circumference of the circle, and the volume of a sphere with
                  that radius.

            D. Exercise the breakpoint and evaluate features of the debugger:
               1. Scroll to line 21 beginning "area = ..." and place the
                  cursor on any letter in the word radius, then press Ctrl-F7.
                  This should bring up a Watch window showing radius. Press
                  ENTER to accept this watch. Now the active window is a watch
                  window showing radius is an undefined symbol. That's o.k.,
                  as it will be valid when filled later.
               2. Press F6 which activates the Message window. Press Alt-F3 to
                  delete it. Press F6 until the edit window is active. With
                  the cursor still on line 21 press Ctrl-F8 to set a
                  breakpoint. The line should be highlighted now.
               3. Press Ctrl-F9 to execute to the breakpoint. Turbo C will
                  then execute  up to line 21, and stop. Now press F6 until
                  the watch window appears at the bottom. You should see that
                  radius is now valid and contains 12.5.
               4. Press F8, which will execute the area = statement and
                  advance to the circumference = statement.
               5. Move the cursor up to the word area on line 21 and press
                  Ctrl-F4. This will bring up an Evaluate and Modify window
                  that has the word area in the expression field. Press ENTER
                  to see the value contained in the area field. The result
                  field will now show 490.8734. Press the tab key twice to
                  activate the New Value window, then type 123.456 and press
                  ENTER, then ESC to get back to the edit window.
               6. Execute the program again using Ctrl-F9. It will complete
                  and terminate, as there are no more breakpoints. Press Alt-
                  F5 to see the screen and you can see the area is now
                  123.456001, reflecting the change you made to the area
                  field before it was displayed.

          *----------------------------------------------------------------*
          *                    Elementary C Programming            LESSON06*
          *----------------------------------------------------------------*
                    Relational and Logical Operators and Decisions

         I. Relational Operators <, >, <=, >=, ==, !=

            A. These operators are used with comparisons in expressions.
               The <, >, <=, and >= operators are used in the normal sense
               of less than, greater than, less than or equal to, and
               greater than or equal to, respectively.

            B. Note particularly the == operator. This is used to mean "is
               equal to". The = operator is the assignment of values
               operator, and does not mean the same thing at all. For
               example:

                       a = b     <- This means move b to a
                       a == b    <- This means compare a to b and set the
                                    result to true (1) if they are equal or
                                    false (0) if they are not equal.

            C. The "not equal to" operator is != in C.

        II. Logical Operators &&, ||, !

            A. The AND (&&) operator is used between two condition
               expressions to show that the net result will be true only if
               the first condition AND the second condition are true. If
               either condition expression is false, the entire condition
               is false. For example, the condition:
                          ((a > 0) && (a < 10))
               will be true if a is a number between 1 and 9. If a is 0 or
               negative, the first condition expression is false, and if a
               is 10 or more the second expression is false.

            B. The OR (||) operator is used between two condition
               expressions to show that the net result will be true if
               either the first condition OR the second condition is true.
               If either condition expression is true, the entire condition
               is true. The overall condition is false only of both
               expressions are false. For example, the condition:
                          ((a > 0) || (b < 10))
               will be true if a is a number greater than 0 OR if b is a
               number less than 10.

            C. The ! (negation) operator is a unary operator used to
               reverse the value of an expression. That is, if the
               following expression is true, ! makes it false and vice-
               versa.

       III. Decision statements
            A: The if statement:
               1. The if is followed by a parenthesized conditional
                  expression. The expression is evaluated and, if true, the
                  following action is taken. For example, to move the value
                  of the variable base_cost to the variable amount when the
                  variable quantity_sold is greater than zero:
                      if(quantity_sold > 0)
                        amount = base_cost;

               2. The conditional expression used may be quite complex with
                  multiple parenthesized conditions interconnected with
                  AND's and OR's. For example:
                      if((((amount > 0) && (cost < 20.00)) ||
                          (quantity < 200)) && (state == 43))
                             total = quantity * amount;
               3. Boolean expressions are common in C. These use a single
                  variable as a conditional expression, which can appear
                  strange at first. When a boolean condition is specified,
                  the content of the variable is tested for 0. If it is
                  zero, the condition is false, otherwise it is true.
                  Notice that only zero is false, all other values positive
                  and negative are considered true. The following statement
                  will be true if the variable quantity is not zero:
                           if(quantity)
                              amount = quantity * price;

               4. Another area that commonly causes problems occurs when
                  the = (assignment of values) operator is used instead of
                  the == (is equal to) operator. This may result in an
                  instruction that compiles without error, but produces
                  incorrect results and can be difficult to debug.Consider
                  the following instruction:
                      if(a = b)  c++;
                  As written, the compiler views this as an assignment of
                  values (move b into a) followed by a boolean test of the
                  resulting content of a. The content of variable a is
                  tested for a value of zero: if it is zero the if
                  statement is "false" and no action will be taken. If a is
                  non-zero it is "true", and the variable c will be
                  incremented. The correct way to code this would be:
                      if(a == b) c++;
                  so that c is incremented only if a is equal to b.

               5. If more than one statement must be executed when an if is
                  true, the several instructions must be grouped by use of
                  braces following the conditional expression. There is no
                  semicolon following the ending brace. An example is:
                      if(a == b) {
                          amount = 6;
                          quantity = amount + 3;
                          i++;
                          strcat(descript,"Made in USA");
                      }

               6. An else may be used immediately following the
                  statement (or block) for the true action. As with the if,
                  else can have only a single statement unless a block of
                  instructions is enclosed in braces. For example:
                      if(i > 16)
                        tbl_ent[i] = 0;
                      else {
                        i++;
                        tbl_ent[j] = 16;
                      }

               7. When if - else instructions are nested, it may be
                  difficult to identify which if a given else belongs to.
                  Indentation helps a lot, but can also be misleading if
                  not done properly. The rule is that an else belongs to
                  the nearest previous if that does not have an else. For
                  example:
                     if(a = b)
                       if(i = 0)
                         if(k = 0)
                           if(x = 9) {
                              amount++;
                              cost = cost_tbl[5];
                           }
                         else
                           x++;
                  Notice that the programmer evidently expects the else to
                  match with the if(k = 0) due to its indentation. However,
                  the nearest previous if without an else is the if(x = 9),
                  and the else will be executed with that if, not the
                  earlier one.

        IV. Hands-On.
            A. Start a Turbo C session and begin a new program called
               tempconv.c.
            B. Enter an introductory comment.
            C. Include the stdio.h header.
            D. Define the name MAX_ENTRIES to be 3.
            E. Define a global floating point variable called fahrenheit.
            F. Define an array of floating point variables called celcius
               that contains MAX_ENTRIES. Initialize the entries to -12.5,
               32.0, and 212.0.
            G. Define a global integer named i.
            H. Make a prototype for a function called compute_fahrenheit
               which returns nothing and accepts no parameters on entry.
            J. In the main function, set i to 0. If the celcius value
               referenced by i is positive, call the compute-fahrenheit
               function, then print a message showing the i'th entry of the
               celcius table as the celcius temperature, and the variable
               named fahrenheit as the fahrenheit equivalent.
            K. Repeat step J. with i = 1.
            L. Repeat step J. with i = 2.
            M. Enter an introductory comment for the compute_fahrenheit
               function.
            N. Type the function header for the compute_fahrenheit
               function.
            P. Compute fahrenheit = 9/5 * celcius + 32 for the particular
               value of celcius designated by the index, i.
            Q. Compile and execute your program.
            R. Verify correct output by viewing the DOS screen.
            S. For additional practice, write another program that converts
               fahrenheit to celcius. Make the variables automatic rather
               than global. Pass the fahrenheit temperature to the compute
               function and have it return the celcius value as a float.
               For negative temperatures, print a message stating the
               negative temperature is being rejected.

          *----------------------------------------------------------------*
          *                    Elementary C Programming            LESSON07*
          *----------------------------------------------------------------*
                          Loops and Keyboard Input Functions

         I. The for loop:

            A. The for loop is probably used more than any other loop
               instruction in C programs. It provides for initialization of
               the loop control variable, loop termination control, and
               updating the loop control variable. The for loop is most
               suitable for use when a fixed number of loops is desired and
               the number is known in advance.
               When
               the loop can terminate at any time dependent on outside
               conditions, the while loop is preferred.

            B. Syntax for the for loop is:
                    for(expr1; expr2; expr3) body;

            C. The three expressions given parenthetically are separated by
               semicolons. All the expressions are optional, but the
               semicolons are not. This is the minimum code valid for a for
               loop:
                         for(;;);

            D. expr1 is an expression executed ONCE just before the loop
               processing begins. It is usually an assignment statement
               used to initialize the loop control variable prior to
               entering the loop. Suppose an integer named i is to be used
               as the loop control variable and that it is to begin with
               the value zero:
                         for(i=0; i<50; i++)
                           c = getche();

               If no loop variable initialization is needed, expr1 can be
               omitted, but not its ending semicolon:
                        for(;i<50;i++)
                           c++;
               It is possible to include several initialization
               instructions in expr1. When this is done, the individual
               statements are separated by commas and they will be executed
               left-to-right. If we want to initialize i to 0 and j to 5 we
               could code:
                         for(i=0, j=5; i<50; i++)
                           week_ctr[i]++;

            E. expr2 is an expression evaluated BEFORE EACH PASS through
               the body of the for loop. When expr2 evaluates false the
               loop terminates and execution continues with the statement
               following the for loop. When the expression evaluates as
               true, the body of the loop is executed. If the expression is
               false to begin with, the statement body will not execute at
               all. When the loop control variable is used also as an index
               against a table, it must begin at zero in order to see the
               first entry. The final value will be one less than the
               number of array elements. For example, to search a table of
               39 struct elements we might code:
                         for(i=0; i<39; i++)
                            if(strcmp(paytbl[i].lastname, "jones")) {
                               paytbl[i].total++;
                               break;
                            }

               When expr2 is omitted, the for loop is considered never
               ending and must be terminated by other means, such as break,
               continue, return, exit, etc. A never ending for loop might
               be coded:
                         for(i=0;;i++)
                           if((strlen(record)) == 0)
                             break;

            F. expr3 is an expression that is executed AFTER EACH PASS
               through the instruction body. It is ordinarily used to
               increment the loop variable. It is also possible to process
               an array in reverse by decrementing the loop variable:
                         for(i=38; i>=0; i--)
                           aray[i] = '\0';

               If the loop control variable is maintained by code in the
               body, the third expression can be omitted:
                         for(;i<50;)
                           c++;

            G. The body is a single instruction or a block of instructions
               enclosed in braces. The ending brace is not followed by a
               semicolon. Be sure you do not place a semicolon after the
               closing parenthesis of the for loop expressions, as this
               terminates the for immediately, and the body will be
               executed once after the for loop completes (if it ever
               does):
                         for(i=0; i<39; i++);
                           counter_array[i] = 0;
               The above would result in looping 39 times with no action
               taken. Subsequently, i would be 39 and the 40th element of
               counter_array would be incremented.

            H. A for loop is often used for processing serially against an
               array. For example, to zero out all 50 elements of an array
               if int's called state_pop:
                            for(i=0;i<50;i++)
                              state_pop[i] = 0;
               In this for loop, the loop variable, i, is initially set to
               zero. Next, i is compared to 50. If i is less than 50 the
               first (i=0) element is set to zero. After the body statement
               is executed, the third expression is executed, which adds 1
               to i. Now the new value of i is compared to 50 and so on
               until i becomes 50. When i becomes 50 the for loop
               terminates and execution proceeds with the instruction
               following the for loop.


        II. The while loop.

            A. The while loop contains a loop termination control
               expression only. Initialization and control of any variables
               must be done by the programmer. While loops are second in
               popularity only to the for loop. While loops are preferred
               when the loop can terminate at any time dependent on outside
               conditions, such as I/O.

            B. Syntax for the for while loop is:
                       while(control_expression) body;

            C. The control_expression is evaluated before each execution if
               the body of the loop. If the expression evaluates false
               (zero) control passes to the statement following the while
               loop. If it is true (non-zero) the body of the while is
               executed. Any initialization must be done prior to the while
               statement, and any loop control processing must be done
               within the body of the loop. The while loop is like a for
               loop using only the middle expression.

            D. As with the for loop, a single instruction or a group of
               instructions enclosed in braces constitutes the body of the
               loop. A while loop with a body composed of two instructions
               might be:
                        while(i > 0) {
                           a = b;
                           c++;
                        }

            E. If a semicolon is coded following closing parenthesis of the
               while expression, there is no body, and the loop may be
               infinite if the body process is required to develop the
               ending condition. For example:
                          i=90;
                          while(i);
                             ctr[i--] = 0;
               would result in a never ending loop, since i cannot be set
               to zero to make the loop expression false.

            F. A common form of the while is used when the ending condition
               cannot easily be specified. In this case, a never ending
               while is deliberately specified with the termination
               testing done in the body of the  loop. For example:
                   while(1) {
                     if(end_of_input) break;
                     i++;
                     printf("Loop continues");
                   }
               In this case, the loop termination control expression is
               (1). When evaluated, this will never be false (zero), so the
               loop is never ending. In this case the break instruction is
               often used to exit from the loop. In addition, the return
               and exit instructions could be used. The never ending while
               loop may have any non-zero constant value. Another common
               value is:
                     while(-1) ...

       III. The do ... while loop.

            A. The do ... while loop begins with an instruction or block of
               instructions that is always done at least once with the
               controlling while instruction following this. The do ...
               while loop is less popular than for and while, but is often
               used when the instructions must be executed at least once.

            B. Syntax for the for do ... while loop is:
                       do {
                           instructions ...
                       }
                       while(control_expression);

            C. This construct begins with the reserved word do followed by
               one instruction or a block of instructions enclosed in
               braces. Following the instruction is a while statement that
               is exactly like the normal while except that it has no
               following body of instructions. Instead, control passes back
               to the do if the while expression is true. When the while
               expression is false control falls through to the next in-
               line instruction. The do ... while construct is useful when
               the loop body must always be executed at least once.
               Example:
                       do
                         a+=5;
                         claim_total = 0;
                         strcpy(social_security,"000-00-0000");
                       while(a <= 95);

        IV. The break instruction.

            A. The break instruction is used to break out of the smallest
               enclosing while, do, for, or switch statement. Control
               passes to the statement following the terminated statement.

            B. Syntax of the break statement is:
                     break;

            C. At times it may be necessary to break out of a loop prior to
               the normal termination. Example:
                     while(more_records) {
                        for(i=0;i<99;i++) {
                          if(inventory[i].item_number > search_item)
                            break;
                          if(inventory[i].item_number == search_item) {
                            inventory[i].quantity--;
                            break;
                          }
                        fread(input_file,inventory_record);
                     }
               In this example, the inventory table is searched for an
               item. Since the table is in item number order, it is
               unnecessary to continue the search when the table item is
               greater than the search item number, so a break is issued.
               Also, when the matching item is found, quantity is
               decremented, and the for loop is terminated with a break
               rather than continuing the search. After the for loop is
               terminated, control passes to the fread and processing
               continues within the while loop, which is not affected by
               the break in this instance.

         V. The continue instruction.

            A. The continue instruction is used to cause control to pass to
               the end of the smallest enclosing while, do, or for
               statement so that the next iteration will be initiated. In
               this case, the loop is not terminated.

            B. It is often efficient to continue execution for a given
               table element  when it can be seen that it is not of
               interest to the process. While nested if logic can usually
               handle these situations, it may be clearer to merely
               continue with the next table element. Example:
                      for(i=0<i<95;i++) {
                        if(tbl_el[i].type != '6') continue;
                        i++;
                        tbl_el[i].qty++;
                      }
               Here, only table entries having type = '6' are desired. If
               entry type is not 6, control passes to the end of the loop
               and the third expression of the for loop (i++) is executed,
               then the second expression is tested for the next iteration.

        VI. The getch() and getche() functions (see APPNDXD for codes).

            A. These functions are used to read data typed in at the
               keyboard and return the next key typed with no buffering.
               Special keys, such as function keys, are returned as a two-
               character sequence: the first character of the pair is zero
               and the second is the scan code for the key pressed. The
               getch and getche functions are identical except that getche
               echoes the key pressed to the screen while getch does not.

            B. Syntax is:
                     unsigned char c;
                     c = getch();
                        -or-
                     c = getche();

            C. The character field returned is usually defined as an
               unsigned char to permit use of all possible key values. An
               example of processing key entry until the character 'q' is
               pressed is:
                           unsigned char c = 0;

                           where((c=getche()) != 'q') {
                             amount = 0;
                             qty += 5;
                           }

       VII. The gets() function.

            A. The gets function reads a string from the keyboard and
               places the characters typed in a string variable in memory
               until a newline character is typed. The newline character is
               not included in the string, but the string is terminated
               with a null (\0). Control returns to the caller after the
               newline is pressed.

            B. Syntax for the gets function:
                            char string[80];

                            gets(string);

            C. Since the gets function handles backspace, delete, and other
               editing, it can greatly simplify processing as compared to
               using getch or getche to read the string one byte at a time.
               An example of use is:
                            char name[20];

                            printf("Enter your name: ");
                            gets(name);
                            printf("Your name is %s\n",name);

      VIII. Hands-On.
            A. Start a Turbo-C IDE session and begin a program named
               lesson7.c.
            B. Enter an identifying comment, include the stdio.h header,
               and begin the main function.
            C. Build an array of strings and initialize it to contain the
               following names: Amy, Beverly, Carl, David, Elizabeth,
               Frank, Georgie, Harold, Imelda, John, Karla, Leonard, and
               Queen. Make each entry 12 bytes long. Partial example:
                    char names[26][12] = {{"Amy"},{"Beverly"},
                                          {"Carl"},{"David"},
                                           ...
                                          {"Leonard"},{"Queen"}};
            D. Define an integer to be used as an index for the table
               search.
            E. Define a 20-byte string for the user's name.
            F. Ask the user for their name using the printf function.
            G. Read the user's name into your name field using the gets
               function.
            H. Use a for loop to search the table of names:
               1. If the name is found, use a printf to type a message such
                  "Congratulations, you are among the chosen few", then
                  terminate the for loop using a break statement.
               2. If the name is not found in the table, use printf to type
                  a message such as "Sorry, you are not allowed".

          *----------------------------------------------------------------*
          *                    Elementary C Programming            LESSON08*
          *----------------------------------------------------------------*
                                       Pointers

         I. Defining pointers.
            A. Pointers are usually defined by use of the * operator. While
               * is also used as an arithmetic operator, the C compiler
               identifies the meaning from context. In a data definition
               statement, a * preceding the variable's name means the
               variable is a pointer. To define a pointer to integers, you
               might see:
                            int *intptr;
               Likewise, to create a pointer to floats, characters, or
               doubles:
                            float *fltp;
                            char *p;
                            double *dp;
               Note that the pointer itself is an int. The compiler wants
               to know the data type pointed to for pointer arithmetic.

            B. Array and string names are pointers. As mentioned
               previously, the name of a string when used without brackets
               is an address constant which points to the first entry of
               the array. Because of this, you get a free pointer to an
               array whenever an array is defined.

            C. Pointer constants are usually not defined by the programmer,
               but are inherent attributes of data fields. That is, any
               data field has an address and that address cannot be
               changed: it is a constant value.

        II. Initializing pointer variables.

            A. Like most other data fields, a pointer field will contain
               zero at creation time if it is defined globally, or as a
               static local variable. When defined as a local (automatic)
               variable, its initial value is undefined.

            B. The & operator can be used to obtain the address of a data
               item. This is the method usually used to provide an initial
               value for a pointer variable. For example, at definition
               time we could create a pointer variable called pv that
               contained the address of an integer field named abc:
                         int *pv = &abc;
               Likewise, to assign the address of a float field named fdt
               to a pointer named fp we could code:
                          fp = &fdt;
               Notice that we do not use the * operator when referring to
               the pointer variable as a data field. Also, it is not
               required that an address be assigned to a variable defined
               as a pointer. That is, if px and py are are defined as
               pointers to integers, and abc is an int, it would be
               syntactically correct to specify:
                          px = 43;
                          px = abc;
                          px = py;

            C. The address 0 (zero) is considered invalid, so that a
               pointer containing zero does not contain a valid address.
               This fact is used by many functions that return pointers. If
               the function fails, it will often return zero, which is not
               a valid pointer.

       III. Using pointers to address data fields.

            A. Pointer arithmetic works a little differently than int or
               float arithmetic. Since pointers are defined as pointers to
               a particular data type (int, char, etc), their values change
               at the same rate as the size of the data type they point to.
               For example, an int on the PC is 2 bytes long. If pn is
               defined as a pointer to int and the following is coded:
                           pn = 32;
                           pn++;
               the final value of pn will be 37. When you increment a
               pointer, you add the length of of the data types it points
               to. Likewise if you decrement the pointer, its value will be
               reduced by the length of the data type it points to. The
               same logic applies when using addition and subtraction. As
               example, if pf is a pointer to float and the following is
               coded:
                            pf = 12;
                            pf += 7;
               the final value of pf will be 40. This is because a float is
               4 bytes long, so the length of 7 floats is 28 bytes.
               12 + 28 = 40.

            B. Using the * operator with a pointer to address data is
               called indirection. Ordinarily, when a data field named x is
               referenced, the meaning is "data contained in the variable
               x". However, when x is defined as a pointer and *x is used
               in a data reference, the meaning becomes "data pointed
               to by x". For example, to add one to an int called ctr using
               a pointer called p we could code:
                             p = &ctr;    /* p now points to ctr */
                             *p++;        /* add 1 to ctr */

            C. Pointers can be used to address array elements instead of
               using brackets with subscripts. For example, if you want to
               increment the third element of an array of ints called ctr
               using the bracket method, you might code:
                             ctr[2]++;
               A pointer to int called pc which had been initialized to
               contain the address of the first element of ctr could be
               used instead:
                             *(pc+2)++;


        IV. Sending pointers to functions.

            A. Normally, C passes by value. That is, when a variable is
               passed to a function, a copy is made of the data, and the
               copy is used by the called function. This protects data from
               casual modification by other functions. If a pointer is
               passed to a function, however, the function can use the
               pointer to modify the original data in the calling program's
               area. To pass a pointer, you can define a pointer, assign
               the desired address to it and put it in the called function
               parameter list. Alternatively, you can simply use the &
               operator with the data name in the function parameter list.
               For example to pass the address of (a pointer to) a data
               field called colr_cnt to a function called set_video:
                               set_video(&colr_cnt);

            B. Another means of passing pointers to called functions occurs
               when an array is passed. By C definition, the name of an
               array is the address of its first element. When an array
               name is coded in a function parameter list, a pointer
               variable is created for use by the called function and it is
               initialized with the address of the array.

            C. Displaying the content of a pointer is simple using printf.
               Since a pointer is an int, it can be printed using the %d
               specifier for a decimal value. If the pointer value is
               desired in hexadecimal, use the %p specifier.

         V. Using pointers to pointers (double indirection).

            A. An array of strings of varying length can be very
               inefficient in memory, especially when most of the strings
               are short, but a few are very long. For example, consider a
               table containing the names Ann, Ted, Jim, Sylvester, Abe,
               Bill, Sid, Tom, and Ben. In order to make an array of these
               names, each entry must be long enough to hold the longest
               entry, in this case 10 bytes while most of the names would
               require only 4 bytes. The normal definition would be like:
                         char name_tbl[9][10] = {{"Ann"},{Ted"},
                                                 {"Sylvester"},{"Abe"},
                                                 {"Bill"},{"Sid"},{"Tom"},
                                                 {"Ben"}};
               If we create a table of pointers to strings instead, we can
               save a lot of memory. This is because a pointer requires
               only two bytes of memory, and the strings can then be placed
               into areas of the right size for each. To define an array of
               pointers to strings we can code:
                         char *name_ptr[] = {{"Ann"},{Ted"},
                                             {"Sylvester"},{"Abe"},
                                             {"Bill"},{"Sid"},{"Tom"},
                                             {"Ben"}};
               In this definition, name_ptr is an array ([]) of pointers
               (*) to characters (char).

            B. Double indirection.
               1. In double indirection, we refer to a pointer to a
                  pointer, which is defined above. We can choose to use
                  array notation to refer to the strings, or a combination
                  of pointer and array notation, or pure pointer notation.
               2. Using pure array notation to point to the first character
                  of each string, where i is an int value between 0 and 7
                  we could process the first byte of one of the strings by:
                          name_ptr[i][0] = 'A';
                  To refer to the string itself, only the first set of
                  brackets would be needed:
                          printf("The name is %s.\n",name_ptr[i]);
               3. Using pure mixed notation to point to the first character
                  of each string, where i is an int value between 0 and 7
                  we could process the first byte of one of the strings by:
                          *(name_ptr+i)[0] = 'A';
                  To refer to the string itself, only the first part is
                  needed:
                          printf("The name is %s.\n",*(name_ptr+i));
               4. Using pure pointer notation to point to the first character
                  of each string, where i is an int value between 0 and 7
                  we could process the first byte of one of the strings by:
                          *(*(name_ptr)) = 'A';
                  And to refer to the string itself:
                          printf("The name is %s.\n",*(name_ptr+i));

        VI. Hands-On session: write a program to read up to 100 strings
            from the keyboard and then display them on the screen.
            A. Use the gets function to read the strings.
            B. Do not display any string until all been read.
            C. Define one single area where strings will be read. When
               a string of zero length, or 100 strings have been entered,
               display them in the same order they were entered.
            D. To determine the length of the string read, use the strlen
               function. To learn how to use this function and which header
               file it needs, use ctrl-F1.
            E. If the string length is > 0, dynamically obtain some memory
               to hold the string and save a pointer to this in an array of
               pointers.
            F. Define an array of 101 pointers to characters to hold the
               addresses of the strings.
            G. The malloc function can be used to obtain an area of memory.
               The memory size should be one more than the size returned by
               strlen, to account for the ending null. To use learn about
               malloc and its header, use ctrl-F1.
            H. Save the memory pointer returned by malloc in the next
               element of the pointer table.
            I. Move the string read to the memory obtained by malloc using
               the strcpy function (use ctrl-F1 to learn about it).
            J. When a string of zero length is read, or when 100 strings
               have been read, stop reading and begin displaying the
               strings.
            K. To display the strings, get the pointers from the pointer
               table and use the printf function to display them.

          *----------------------------------------------------------------*
          *                    Elementary C Programming            LESSON09*
          *----------------------------------------------------------------*
                           Structures and Unions and Sizeof

         I. Structures.

            A. In C terms, a structure is a new data type defined by the
               programmer. It may contain any combination of any of the
               data types known to C at that time: int, char, float, other
               structures, unions, etc.

            B. Structures are declared/defined by use of the struct
               keyword. Following the struct keyword is an optional name
               that can be used to identify this structure type, then a
               pair of braces enclosing the data definitions comprising the
               structure. Following the closing brace is an optional name
               that is used to define and reserve storage for the
               structure. A semicolon follows the declaration. Example:
                        struct personnel_record {
                          int   id_nbr;
                          char  last_name[20];
                          char  first_name[12];
                          char  middle_initial;
                          char  sex;
                          char  birth_date[7];
                          int   nbr_dependents;
                          float salary;
                        } employee, *p;
               The above structure declares a structure of type
               personnel_record. This new data type contains the fields
               id_nbr, last_name, first_name, middle_initial, sex,
               birth_date, nbr_dependents, and salary. The data name
               employee is defined, reserving an area for one of these
               personnel_record structures. In addition, the data name p is
               defined as a pointer to type personnel_record and storage is
               reserved for this pointer.

            C. Once the structure is declared, it can be used in later
               definitions and within other declarations. For example, to
               define another personnel_record structure called
               hold_employee:
                          struct personnel_record hold_employee;
               And to create an array of 25 of these structures:
                          struct personnel_record emp_tbl[25];

            D. The dot operator is used to refer to data fields within a
               structure. The structure name (not the structure type) is
               used, followed by a dot, then the field. For using the
               definitions above, we might move the salary from the
               employee structure to the hold_employee structure by:
                          hold_employee.salary = employee.salary;

            E. Structures can be initialized at the time of definition, if
               desired. To do so, the definition is followed by an = sign
               and a set of braces enclosing the values for the individual
               fields which are separated by commas. A semicolon terminates
               the value group. for example, using the structure declared
               in B. above:
                 struct personnel_record employee = {1259,"Thornton","Dick",
                                                     'N','M',"351027",3,
                                                     35000.00};


        II. Unions.

            A. The union is used to redefine an area. Many data types may
               be identified within a union, only one of which may occupy
               it at any given time. The size of the union in bytes is
               equal to the size of the largest of the included fields.

            B. A union is defined in much the same way as a structure. The
               word union is optionally followed by a union type name by
               which other occurrences of this union type can be defined.
               Next is the content of the union enclosed within braces.
               Following the content is a field name is this declaration is
               also to define one of these unions, and a semicolon ends the
               definition. For example, to define a union which might
               contain an int named count or a struct of type
               personnel_record named emp:
                    union myunion {
                        int count;
                        char full_name[35];
                        float amount;
                    } redf;
               At any given time, this union could contain the int count or
               the string named full_name or the float named amount. Other
               fields could have been included, as well.

            C. Fields within the union are accessed via the dot operator,
               just as with the structure. To set the count field to 0 in
               the union above:
                     redf.count = 0;

            D. As with structures, if a union type name is supplied, it can
               be used in later definitions. Using the declaration in B.,
               we can create another occurrence of the same union called
               secundo:
                     union myunion secundo;

       III. Complex structures and unions.

            A. Unions may also contain structures within them. For example:
                     union red2 {
                       float quantity;
                       struct personnel_record emp;
                     };
               The dot operator must be applied twice to refer to fields
               within the emp structure in the red2 union. To set salary to
               36000.00, for example:
                     redf.emp.salary = 36000.00;

            B. Structures may include unions, too. For example:
                      struct {
                         int item_nbr;
                         char description[23];
                         char item_type;
                         union {
                           int legs;
                           float weight;
                           float girth;
                           long surface_area;
                         } size;
                         int minimum_order_quantity;
                         float cost;
                       } inv;
               Notice that no structure type name is given, nor is a union
               type name given. This is acceptable, as the structure and
               union are unique within the program, and will not be
               referenced by type anywhere else. Both the structure and the
               included union have field names, however, as it would be
               impossible to refer to thier fields without names.

               The dot operator must be applied twice to get at fields
               within the union named size. For example to set surface area
               to 5090617:
                           inv.size.surface_area = 5090617;

            C. Arrays of structures are quite common, and are defined as
               you would expect, using the structure type name, structure
               name, and brackets enclosing the number of occurrences.
               Using the personnel_record structure type, an array of 18 of
               these structures could be created by:
                   struct personnel_record emp[18];
               To refer to a particular entry in the array, use brackets
               following the structure name, then a dot and the field name.
               To set id_nbr to 8734 in the third entry of the array:
                   emp[2].id_nbr = 8734;

        IV. The sizeof keyword.
            A. Syntax for the sizeof keyword is like that for a function
               call: the object name is in parentheses following the sizeof
               keyword:
                           sizeof(object)

            B. The sizeof keyword returns the size of the object as an int
               value. This is often used in declarations, I/O reads and
               writes, memory moves, dynamic storage allocations, and so
               forth. By using sizeof, you do not have to manually compute
               the size of arrays and unions. In addition, using sizeof
               rather than hard-coded sizes saves effort when maintenance
               changes affect the size of structures or unions. Examples of
               sizeof use:
                          printf("the size of an int is %d\n",sizeof(int));
                          p = (struct abc)malloc(sizeof(struct abc));
                          memcpy(area1,area2,sizeof(area1));

            C. The object supplied to sizeof can be a type name (int,
               float, struct abc, union xyz, etc), or a variable name. The
               length returned will be the defined length of the variable.
               If the variable is a structure, the length of the structure
               is returned. If the variable is an array (or string), the
               length of the array as defined is given. Examples of use
               with a structure:
                                 struct abc {
                                   int iii;
                                   float fff;
                                   char sss[15];
                                 } def;

                                 struct abc ghi[10];

                                 sizeof(def)        /* returns 21 */
                                 sizeof(abc)        /* error: abc is
                                                       undefined  */
                                 sizeof(struct abc) /* returns 21 */
                                 sizeof(ghi)        /* returns 210 */

            D. When sizeof is given the name of an array or string, it
               returns the defined length of the array or string, not the
               length of the string that currently occupies the array. To
               find the length of the occupying string, use the strlen
               function, not the sizeof keyword. For example:

                                 char stg[33] = "Dick";

                                 sizeof(stg)       /* returns 33 */
                                 strlen(stg)       /* returns 4 */

        IV. Hands on session.

            A. Start a Turbo-C edit session with struct9.c. This program
               declares an array of 12 structures which contain employee
               data. The elements are initialized to zeros, then data is
               obtained from the keyboard to fill the structures until all
               12 are filled or the user enters an employee number of zero.

            B. Make the following additions to the program (before the
               final brace which ends the main function):
               1. Display a heading line:
                  EMP#   NAME          RATE    HOURS     PAY
               2. Print one line for each table entry where pay_grade is an
                  'h'.
               3. Each line should contain the employee number, name,
                  hourly rate, hours worked, and pay amount which is hours
                  worked times rate. Line up the fields under their heading
                  columns. Each decimal field should print with 2 decimals.
               4. Display 3 blank lines to separate the reports.
               5. Display a heading line:
                  EMP#   NAME          SALARY     PAY
               6. Print one line for each table entry where pay_grade is
                  not 'h'.
               7. Each line should contain the employee number, name,
                  annual salary, and pay amount which is annual salary
                  divided by 52. Line up the fields under their heading
                  columns. Each decimal field should print with 2 decimals.

          *----------------------------------------------------------------*
          *                    Elementary C Programming            LESSON10*
          *----------------------------------------------------------------*
                               More Control Statements

         I. The switch statement.

            A. The switch statement is roughly equivalent to a GO TO
               DEPENDING ON statement in COBOL. Switch has, as a parameter,
               a variable which is used to select the various "cases". The
               body of the switch statement contains the cases, which
               relate values of the switch variable to actions. Switch
               statements are quite common in C programs, and are used
               wherever a single data field may contain several different
               values which drive processing.

               1. Syntax: the keyword switch is followed by a variable name
                  in parentheses. The body of the switch statement comes
                  next, and is surrounded in braces. There is no semicolon
                  at the end of the switch body. Within the body of the
                  switch are case statements and optionally a default
                  statement with their associated processing statements.
                  Each case statement gives a single value for the switch
                  variable followed by a colon and the processing
                  statements to be executed when the switch variable has
                  that value. An optional default statement can be included
                  to handle the "none of the above" situation. Example:

                      switch(record_type) {
                        case '1':
                        case '5':
                           n = strlen(company_name);
                           pop_ctr[n]++;
                           break;
                        case '2':
                           i++;
                        case '3':
                           amount = qty * price;
                           break;
                        case '7':
                           break;
                        default:
                           printf("%c is invalid for record type",
                                  record_type);
                      }

               2. In the switch above, record_type is defined as a single
                  character field, so the case values are given as
                  characters: single characters enclosed in single quotes.
                  If the switch variable is an int, the case values would
                  have been decimal numbers.

               3. The processing statements following the default statement
                  are executed if processing reaches that statement.

               4. Once a case statement is matched, all following
                  processing statements are executed until a break
                  statement is encountered or the ending brace of the
                  switch body is reached. In the example above, if case
                  '2': is matched, the instructions following case '2' and
                  case '3' are all executed, since no break occurs until
                  the end of the case '3' statements.

            B. The conditional operator is an unusual construct that allows
               you to specify a condition and set a variable to one value
               if the condition is true, or to a second value if it is
               false. The conditional operator is used a moderate amount so
               you need to be able to recognize it.

               1. Syntax: the variable to be changed is specified, followed
                  by the = sign. A parenthesized condition follows the =
                  sign. After the condition is a ?, then the value to be
                  placed in the variable if the condition tests true. After
                  this there is a : followed by the value to be set in the
                  variable if the condition tests false. The entire
                  statement ends with a semicolon. Example:

                           max = (i > j) ? i : j;

                  This statement tests the condition (i > j). If it is
                  true, max is set to the value in i, otherwise it is set
                  to the value in j.

        II. Hands-on session.

            A. Write a program in C which will send the following menu to
               the screen and accept a one-character response from the
               keyboard:
                             A = add two numbers

                             S = subtract two numbers

                             M = multiply two numbers

                             D = divide one number into another

                             Q = quit

            B. To erase the screen you can printf("\x1B[2J"); or better
               yet, #define CLEAR "\x1B[2J" and then printf(CLEAR); Before
               this will work, you will have to include DEVICE=ANSI.SYS in
               your config.sys file for DOS.

            C. Use a switch statement to execute one of four functions
               which you will write to perform the indicated operation.

            D. Write four functions, one for each arithmetic operation.
               Each function should ask for the two numbers, perform the
               indicated operation, display the result, and wait for the
               user to press a key before returning to the main function.

            E. The main function should continue to display the menu and
               process the response until the letter q is entered. A while
               loop would be useful here.

            F. You should provide for entry of either uppercase or
               lowercase letters at the menu.

            G. Since the functions contain a lot of common code, you may
               want to cut and paste. To do this, put the cursor on the
               first byte to be copied. Hold the shift key down and use the
               arrow keys to highlight the entire area to be copied. Now
               press and hold the shift key, then the Del key. This will
               cut the marked area out of the program. Do not move the
               cursor, but again press and hold shift, then press the Ins
               key once. This should bring back the marked block. Move the
               cursor to the location where you want a copy, then press and
               hold shift, then press Ins once. You should now have the
               marked block showing. To unmark the block press and hold the
               Ctrl key, then the k key followed by the h key.

          *----------------------------------------------------------------*
          *                    Elementary C Programming            LESSON11*
          *----------------------------------------------------------------*
                                  Advanced Variables

         I. Pointer notation for structures.

            A. While the dot operator and array notation can be used to
               refer to elements of structures, a special pointer notation
               is also available that can often simplify references when
               using a pointer. To use this notation, an arrow is used
               between the pointer and structure element. The arrow is
               composed of the dash followed by the greater-than sign. For
               example, if p is a pointer to a structure that contains a
               field named cash, it can be referenced as:
                               p->cash

            B. Only one structure pointer reference seems possible in a
               single data field reference. For example, given the
               following definitions:

                   struct cov {
                     char type;
                     int  days;
                     float ded;
                   } *pc

                   struct sub {
                     char id[10].
                     char name[33];
                     struct cov covrg[3];
                     float ytd_claims;
                   } *ps, subr[90];

               A structure of type cov is declared and a pointer called pc
               is defined for it. Another structure of type sub is declared
               which contains an array of three elements of struct cov as
               well as other fields. A pointer called ps and a 90-element
               array of struct sub are defined. A reference to the
               ytd field could be made as either of the following:

                 ps = subr;                    i = 0;
                 ps->ytd = 1250.75     -OR-    sub[i].ytd = 1250.75;

               Notice that ps must be initialized to point to one of the
               elements in the subr array before it can be used
               meaningfully. Below are two ways in which the field named
               type in the covrg array within struct sub can be referenced:

                  pc = covrg                  j = 0;
                  pc->type = 'c';    -OR-     sub[i].covrg[j].type = 'c';

               The structure pointer notation here is much more compact
               than the method using the dot operator, however it is more
               difficult to understand what the pc-> means than it is to
               interpret the sub[i].covrg[j].

        II. The enumerated data type is similar to the 88 level condition
            name of COBOL in that it allows reference to the content of a
            field using a meaningful name, rather than the actual value.
            The enumerated data type is always an int, however it may be
            treated as a single character.

            A. Syntax of the enumerated data type begins with the enum
               keyword. An optional name follows the enum keyword which
               names the enum data type if it is referenced in a later
               declaration or definition. The names to be used for various
               values follow enclosed within braces. Following the closing
               brace is an optional name to be used in reference to the
               item if it is being defined. A semicolon terminates the
               enum. The names given in the braces may be assigned specific
               values using an = sign. If no value is given for name, it is
               assigned a numerical value 1 greater than the preceding
               name. The first name is assigned the value zero if no value
               is provided. Names are separated by commas within the
               braces. Example:
                               enum jobs {
                                  janitor,
                                  junior_programmer = 10,
                                  programmer,
                                  programmer_analyst,
                                  senior_programmer,
                                  supervisor = 50,
                                  manager,
                                  director
                               } job;
               The name janitor will be associated with the value zero for
               the field named job. Junior_programmer will be associated
               with 10, programmer with 11, programmer_analyst with 12,
               senior_programmer with 13, supervisor with 50, manager with
               51, and director with 52. If no values had been assigned,
               janitor would have been zero, junior_programmer one,
               programmer two, etc. All the names could have been assigned
               values, if desired.

            B. In COBOL, a condition name is used directly, as in:

                   IF JANITOR PERFORM HOURLY-PAY-ROUTINE.

               This construction is not allowed in C. Rather, the field
               name is used with a relational operator and the value name.
               The equivalent C statement might be:

                   if(job = janitor) hourly_pay_routine();

            C. An advantage of the C enum over COBOL's 88 levels is that
               the names may be used in statements other than comparisons.
               For example,

                   IF JOB < MANAGER
                      MOVE PROGRAMMER-ANALYST TO JOB.

               would be illegal in COBOL, but not in C. The statement:

                   if(job < manager)
                     job = programmer_analyst;

               is perfectly acceptable in C.

            D. Certain restrictions may apply to use of the enum data type
               and associated names. One book says that decimal values
               cannot be directly assigned to enum variables. In other
               words, stating:

                              job = manager;

               should be legal, while

                              job = 50;

               should produce a compiler error. I found that Turbo C does
               not consider this an error. The same book noted that the
               only valid relational comparison operators for use with enum
               types are == and !=. In fact, Turbo C will honor < and
               probably all others.

       III. The typedef keyword is used to provide another name for an
            existing data type a data type. This can sometimes improve
            program readability, but should be used with caution, as the
            maintenance programmer may be confused when a strange name is
            used where a data type name is expected.

            A. Syntax for the typedef begins with the reserved word typedef
               followed by the existing data type, then the new data type
               name to be used. The statement ends with a semicolon. Two
               examples follow. The first provides a new type name for
               unsigned char and the second for struct payrec:

                    typedef unsigned char BYTE;

                    typedef struct payrec payrecd;

            B. With these new names, definition for data items can be
               written differently. The following shows the original
               definition followed by a definition using the new name. Both
               are valid, and both result in identical data definitions:

                    unsigned char c;        /* original (still valid */
                    BYTE c;                 /* using new type name */

                    struct payrec payroll_record;   /* original way */
                    payrecd payroll_record;   /* using new type name */

        IV. Type conversion and casting.

            A. While C ordinarily handles mixed data types in an expression
               properly, there are pitfalls, and it is a good idea to
               maintain a single data type throughout an expression, if
               possible: that is, use only int or only long or only float
               or only double. When mixed types are used, the compiler
               converts the variables to compatible types before doing the
               indicated operations. When mixed variable types are used,
               the compiler converts from a lower type to a higher type
               before the operation where the ranking from lowest to
               highest is:

                            (lowest) char
                                     int
                                     long
                                     float
                           (highest) double

            B. When an expression containing mixed variable types is
               calcualted, the eventual answer will be of the type of the
               highest data type used anywhere in the expression. If the
               result field is of lower data type, the answer must be
               scaled back to this lower type and can result in loss of
               precision or a completely incorrect result.

            C. Typecasting is a method of forcing the compiler to convert a
               variable to another data type. This is often done when a
               variable to be passed to a function is not of the type
               required by the function. In order to cast a variable as
               another type, enter the desired data type in parentheses
               before the data name being used. For example, assume you
               want to find the square root of an int field called bignum,
               but the sqroot() function being used expects its input
               parameter to be a long:

                    root2 = sqroot( (long)bignum);

               In the statement above, the compiler will convert the int
               named bignum to a long before passing it to the sqroot
               function.

         V. Hands-on session.

            A. Call up the program menu10.c in the Turbo C IDE.

            B. In the global area, declare an enum called req that defines
               ADD as 'a', SUBTRACT as 's', MULTIPLY as 'm', and DIVIDE as
               'd'.

            C. Define a new data type called REQUEST for the enum above.

            D. Define an array of 12 structures named memo. Each structure
               element should contain one item of the new data type
               REQUEST called request, a float called number1, a float
               called number2, and a float called answer.

            E. Define a pointer to the array above. Call the pointer pm.
               You can do this as part of the array definition or as a
               separate statement.

            F. In the main() function, begin with an instruction to put the
               address of the first element of memo into the pointer called
               pm.

            G. In each of the processing routines, add_numbers();
               subtract_numbers(), multiply_numbers(), and
               divide_numbers(), add the following code:

               1. Put the appropriate value for ADD, SUBTRACT, MULTIPLY, or
                  DIVIDE into the request item within the element of the
                  memo array pointed to by pointer pm. Use structure
                  pointer notation (->).

               2. After the first number is obtained, put its value into
                  the number1 field pointed to by pm.

               3. After the second number is obtained, put its value into
                  the number2 field pointed to by pm.

               4. After the answer is calculated, put its value into the
                  answer field pointed to by pm.

               5. Update the pm pointer to point to the next element in the
                  memo array.

               6. Back in the main() function, after a Q is entered and the
                  while loop is terminated, add a loop to run through the
                  memo array and display each element that contains data.
                  Display the word corresponding to the value in the
                  request field and display all the number fields with 2
                  decimals and identifiers.

          *----------------------------------------------------------------*
          *                    Elementary C Programming            LESSON12*
          *----------------------------------------------------------------*
                                 Files and I/O Part 1

         I. Types of disk I/O:

            A. Standard (stream) I/O: most commonly used, wider range of
               commands, easier to use, automatic buffering.
               1. Character I/O: fopen, getc, putc, fclose
               2. String I/O: gets, puts
               3. Formatted I/O: fprintf, fscanf
               4. Record I/O: fread, fwrite

            B. System I/O: fewer ways to handle data, more primitive
               system, more work required of programmer, no buffering,
               often more efficient in memory usage, faster I/O.
               1. Buffer I/O: read, write

        II. Modes of file I/O

            A. Binary mode
               1. Add "b" after type letter in fopen or default
               2. Data written and read without change.
               3. Signals EOF when all file bytes read.

            B. Text mode
               1. Add "t" after type letter in fopen
               2. A newline character (hex 0A, decimal 10) is changed to
                  CR/LF before writing record.
               3. Changes a CR/LF into a newline when reading.
               4. Signals EOF when all file bytes have been read OR a Ctrl-
                   Z character is read (hex 1A, 26 decimal).

       III. Using the stream I/O functions

            A. Preparing for standard (stream) I/O
               1. #include <stdio.h>
               2. Defining the pointer to the file:
                  FILE *fptr;

            B. Opening the file:
               1. Gives system the name of the file, how we plan to process
                  it. System builds FILE structure, buffer. FILE structure
                  contains file info such as current size, buffer
                  locations, current location in file (file pointer).
               2. fptr = fopen("filename","r");
                   "r" = read, must exist
                   "w" = write over or create
                   "a" = append to or create
                   "r+" = read/write, must exist
                   "w+" = read/write over or create
                   "a+" = read/append or create
                   "rb", "wb", "ab", "rb+", "wb+", "ab+" for binary mode
                   "rt", "wt", "at", "rt+", "wt+", "at+" for text mode
               4. Standard coding for file open combines the open with a
                  test to see if it was successful, and error handling if
                  it was unsuccessful, for example:

                        if((fptr = fopen(argv[1],"r")) == NULL) {
                          perror("Open failed for input file");
                          exit(1);
                        }

               5. The following strings are predefined filenames (reserved
                  names) which can be used for the standard devices on an
                  IBM PC or clone:
                   "in" = standard input device (keyboard)
                   "out" = standard output device (display)
                   "err" = standard error device (display
                   "aux" = standard auxiliary device (serial port)
                   "prn" = standard printing device (parallel printer)

            C. Reading from a stream file (after it has been opened):
               1. For reading one-character-at-a-time from a stream:
                           ch=getc(fptr);
                  a. At end of file, ch == EOF, and EOF is -1, therefore ch
                     must be defined as an int:
                           int ch;
                  b. Read statements are often contained within a while
                     loop that controls overall execution of the program:

                          while((ch=getc(fptr)) != EOF) {
                            program
                              execution
                                statements
                          }

               2. For reading a string from a stream file the fgets
                  function is used. This function reads a string of
                  characters from the (open) file and copies them into a
                  storage area provided by the programmer. Reading
                  continues until a newline (\n) is read or a designated
                  maximum number of bytes (-1) have been read. The newline
                  character (if found) is placed in the storage area. A
                  null is added following the last character read to form a
                  true string. If successful, fgets returns a pointer to
                  the string read, otherwise a NULL is returned. When a
                  NULL is returned, an error may have occurred, or end-of-
                  file. The feof function can test for end-of-file, while
                  ferror can test for errors. For example, when reading a
                  file of 79-byte (maximum) strings, you might code:
                       while((fgets(string_area,80,fptr) != NULL) {
                          record
                            processing
                              statements
                       }
                       if(ferror(fptr) != 0) {
                         perror("Error occurred reading file");
                         fclose(fptr);
                         exit(1);
                       }
                       else {
                         fclose(fptr);
                         exit(0);
                      }
               3. Formatted input can be handled by use of the fscanf
                  function. This can be used in reverse of the way printf
                  writes formatted output. The scanf functions are tricky
                  to use, offer little help to the programmer or user, and
                  cause your system to lock up if coded improperly. Other
                  functions can probably be used to greater advantage in
                  any given situation. The following instruction would read
                  three data fields from an open file pointer fptr. The
                  first field will be considered a string, and will be
                  placed in the field defined as name. The second field
                  will be considered a decimal number and will be placed in
                  the field called code. The third field will be considered
                  a floating point number and will be converted and placed
                  in the height field. Note that field ADDRESSES must be
                  specified, not field names. If you forget this, you will
                  probably have to reboot your machine to get out of a
                  lockup after you run the program.

                        fscanf(fptr,"%s %d %f",name,&code,&height);

               4. Reading "records" from stream files is very much like
                  reading fixed-length records in a mainframe COBOL
                  program. You provide an area to contain the record(s)
                  read, the length of the record, the number of records to
                  be read and the pointer to the (open) file. The fread
                  function returns an int containing the number of records
                  read. For example, to read a single (1) record into the
                  structure named record from the file pointed to by fptr,
                  you could code:

                    while(fread(&record, sizeof(record), 1, fptr) == 1) {
                      record
                        processing
                          statements
                    }
                   if(ferror(fptr) {
                     perror("Error reading input file");
                     fclose(fptr;
                     exit(1);
                   }

            D. Writing data into a standard (stream) file:
               1. Writing characters one-by-one:

                    putc(ch,fptr);

               2. Writing strings to an (open) stream file uses the fputs
                  function. The programmer must provide a field containing
                  a normal null-terminated string to be written to the
                  file. The terminating null is not written to the file. If
                  a newline or any other data is to be written, the
                  programmer must provide it in the string area, as nothing
                  will be added by fputs . For example, to write a string
                  contained in a field called string_area to an open stream
                  pointed to by fptr:

                            fputs(string_area,fptr);

               3. Formatted output is written using the fprintf function.
                  This function is almost identical to the printf function
                  that should be familiar by now. The only difference is
                  that fprintf requires the name of the file to be written
                  to. As with printf, you will have to include your own
                  newline character, if desired. For example, If the (open)
                  stream file pointed to by fptr is to be used, you might
                  code:

                  fprintf(fptr,"%s %d %f\n",name,code,height);

               4. Record I/O to an open stream file uses the fwrite
                  function. This is very much like the fread function and
                  requires the address of the area containing the record to
                  be written (oftem a structure), the length of the record,
                  the number of consecutive records to be written (usually
                  1), and the pointer to the open stream file. An example,
                  writing a single (1) structure called record to a stream
                  file pointed to by fptr is:

                         fwrite(&record, sizeof(record), 1, fptr);

            E. Closing a stream file:
               1. Characters left in buffers, but not yet physically
                  written are sent to the file, then communications areas
                  used for the file are freed (FILE structure, buffer).
               2. The function fclose is used to close a stream file. All
                  that is needed is the pointer to the open stream file:

                        fclose(fptr);

        IV. Hands-on session.

            A. Bring struct9.c into the Turbo C IDE.

            B. Define a pointer to a stream file called fptr.

            C. Use the fopen function to open the file for binary mode
               where you will write the file. Choose an open option that
               will write over the file if it exists, or create it if it
               does not exist.

            D. After each emp structure is built, write it to your file
               using the fwrite function.

            E. When all  emp structures have been written and there is no
               more input to be processed, use fclose to close the stream
               file, then fopen to read it back in binary mode.

            F. Read each structure in the file using the fread function and
               display the data for each using the printf function.

          *----------------------------------------------------------------*
          *                    Elementary C Programming            lesson13*
          *----------------------------------------------------------------*
                                 Files and I/O Part 2

         I. Random Access

            A. File pointer: A pointer to a byte within a file. Normally
               set to beginning of file when the file is opened file is
               opened except for append it is set to end of file. The file
               pointer is maintained within the FILE structure and is
               updated when the file is read or written.

            B. The fseek function can be used to update the file pointer
               directly. See binsrch.c in this handout.

               1. Like many other C functions, fseek is often written with
                  an if statement to handle errors. An int is returned with
                  zero if the pointer is moved successfully, or non-zero if
                  it failed. Parameters required by fseek are the pointer
                  to the open FILE structure, the new pointer offset and a
                  "whence" integer which shows where the offset is measured
                  from. Example:

                       if(fseek(fptr, offset, 0) != 0) {
                         perror("Unable to set file pointer");
                         exit(1);
                       }

               2. The offset field must be a long. If a constant is
                  specified, add the letter l behind the number: 346l, for
                  example.

               3. The third parameter is the "whence" field. It is an
                  integer containing a 0, 1, or 2 showing how to apply the
                  offset:
                   0 = from beginning of file
                   1 = from current position of file pointer
                   2 = from end of file

               4. The names SEEK_SET, SEEK_CUR, and SEEK_END can be used
                  rather than the digits 0, 1, and 2 if desired.

               5. Once the file pointer is set using fseek, the next read
                  or write function begins at that point in the file.

            C. The ftell function can be used to find where the pointer is
               located within the file at the time the ftell is executed.
               This can be used to note where a record will be written.
               1. The only parameter needed by ftell is a pointer to the
                  open FILE structure. The ftell function returns a long
                  containing the current offset of the pointer from the
                  beginning of the file. If fp is defined as a pointer to
                  FILE, offset is defined as a long integer, and the
                  associated file has been opened, you could get the byte
                  location of the next byte to be processed in the file
                  with:

                                      offset ftell(fp);

        II. System level I/O.

            A. System level I/O is an older, more primitive form of I/O
               that requires more work on the part of the programmer, but
               can sometimes provide faster file access with reduced memory
               usage. Only one type of data transfer is available, called
               buffered I/O, which is very similar to the record I/O method
               used in stream I/O. Be careful not to mix stream I/O and
               system level I/O functions for a file in the same program,
               as they are not compatible.

            B. Setting up for system level I/O:

               1. First, include the header files containing the function
                  prototypes and definitions needed:

                       #include <io.h>         /* function prototypes */
                       #include <fcntl.h>      /* O_FLAGS defines     */
                       #include <sys\stat.h>   /* S_FLAGS defines     */

               2. Define an integer for the file handle. Unlike stream I/O
                  which uses a pointer to FILE, system I/O uses a simple
                  int which contains a file number assigned by the
                  operating system. For example, if you want to refer to
                  the file as infile:

                       int infile;             /* define the handle */

               3. Since some of the system I/O functions return the number
                  of bytes processed, you will need an integer field to
                  contain this returned value:

                       int bytes;              /* nbr bytes read/written */

               4. With system level I/O, the programmer must set up a
                  buffer. Traditionally, the buffer used is a multiple of
                  the physical sector size used on the disk. In PC's this
                  is 512 bytes, so a multiple of 512 bytes is most
                  efficient. For a single buffer, you might code:

                       char buff[512];        /* data buffer */

            C. Opening the file for system level I/O is similar to stream
               file open processing. For system I/O, the function used is
               open, and the data returned is a handle (file number).
               1. Syntax for the open function is much like that for stream
                  I/O. The value returned is an int called a handle that is
                  merely a file number used by the operating system to
                  identify the file. If the open fails, a -1 is returned.
                  The first parameter passed is a character string
                  containing the file name. The second parameter is the
                  mode, which is specified using "O_FLAGS". The third
                  parameter is required if a file is to be created. It is
                  called the file permissions, and is set up by use of
                  "S_FLAGS". The O_FLAGS and S_FLAGS are combined by use of
                  the bitwise OR operator, rather than by commas. For
                  example, to open a file named "claim_err" for output,
                  creating the file if it does not exist, and writing in
                  binary mode with permission given to read and write the
                  file:

                  if((infile = open("claim_err",O_CREAT | O_WRONLY |
                                    O_BINARY, S_IREAD | S_IWRITE)) < 0) {
                    perror("Unable to open claim_err File: ");
                    exit(1);
                  }

               2. The following O_FLAGS are defined in fcntl.h:
                    O_RDONLY   Open for reading only
                    O_WRONLY   Open for writing only
                    O_RDWR     Open for reading and writing
                    O_APPEND   Open for appending. File pointer will be set
                               to end of file before each write.
                    O_CREAT    Has no effect if the file already exists. If
                               it does not exist, the file is created with
                               the file access permissions given by the
                               S_FLAGS.
                    O_EXCL     Used with O_CREAT to return an error if the
                               file already exists.
                    O_TRUNC    If the file exists, its length is truncated
                               to zero.
                    O_BINARY   Open file in binary mode.
                    O_TEXT     Open file in text mode.

               3. The following S_FLAGS are defined in sys\stat.h:
                    S_IWRITE   Permission to write
                    S_IREAD    Permission to read

               4. Some file handles are pre-defined by the operating
                  system, and do not have to be opened. These are:

                    0 = stdin (keyboard)
                    1 = stdout (display)
                    2 = stderr (display)
                    3 = stdaux (serial port)
                    4 = stdprn (printer)
               5. In order to specify the file mode for pre-defined files,
               you can use the setmode function with either O_BINARY or
               O_TEXT. For example to set stdprn to binary mode:

                    setmode(4,O_BINARY);


            C. Reading a file using system level I/O uses the read
               function. This function returns an int containing the number
               of bytes read if it was successful, zero if end of file was
               encountered, or -1 if an error occurred. The parameters
               passed include the file handle, a pointer to the buffer, and
               an unsigned int value containing the number of bytes to
               read. Reading begins at the location of the file pointer.
               Using the examples given above so far, to read infile:

                    while((bytes = read(infile, buff, 512)) > 0) {
                       statements
                         to process
                           data in file
                    }
                    if(bytes < 0) {
                      perror("Error reading infile");
                      exit(1);
                    }

            D. Writing a file using system level I/O uses the write
               function. This function returns an int containing the number
               of bytes written if it was successful, or -1 if an error
               occurred. The parameters passed include the file handle, a
               pointer to the buffer, and an unsigned int value containing
               the number of bytes to be written. Writing begins at the
               location of the file pointer. Using the examples given above
               so far, to write to a file whose handle is outhndl:

                   if((write(outhndl,buff,512)) < 0) {
                     perror("Error writing to outhndl");
                     exit(1);
                   }


            E. Writing a file using system level I/O uses the close
               function. The only parameter required is the file handle.
               For example, to close the file above:

                   close(outhndl);

       III. Hands-on session.

            A. Begin a new program in the TurboC IDE (Alt-F, N).

            B. Use stream I/O for this program.

            C. Define a structure which will contain an enum for
               day_of_week such that Sunday is 0, Monday is 1, ... Saturday
               is 6. The second field in the structure should be a floating
               point variable called temperature. Call the defined
               structure temprec.

            D. Set up and open a binary output file which will contain
               records of type struct temprec.

            E. Write procedure statements to get day_of_week and
               temperature pairs from the keyboard and put the data into
               the temprec structure. Quit when an invalid value is entered
               for day_of_week.

            F. Write each temprec structure to disk.

            G. After completion (invalid day_of_week entered), close the
               file for output and reopen it for input.

            H. Ask the user for a number indicating the day_of_week to be
               processed. Accept only 0-6 and keep asking until a valid
               entry is given.

            I. Using the day_of_week entered, read the file and accumulate
               the total number of records for the specified day and a
               total of the temperatures for that day.

            J. At end of file, compute th average temperature for that day
               and display a message like:

               There were xxx yyyyyyyy days. Average temperature was zzz.zz

               Where xxx is the total number of the specified days,
               yyyyyyyy is the spelled-out equivalent of the day requested
               (for example, if 1 was entered, the message should say
               Monday), and zzz.zz is the average temperature with 2
               decimal places.

          *----------------------------------------------------------------*
          *                    Elementary C Programming            LESSON14*
          *----------------------------------------------------------------*
                                 Miscellaneous Topics

         I. The goto statement and labels

            A. A label provides a name for a location in a program which is
               to be the destination for a goto statement. A label follows
               the rules for names in C programs, and is followed by a
               colon. The label may be on a line by itself, or other code
               may follow it on the same line if desired. To create a label
               called Error_End, code:

                           Error_end:

            B. The goto statement is followed by the name of a label in the
               program. The label may be defined before or after the goto,
               but both must exist within the same function. The following
               would be correct if Error_end and Executive_routine were
               both defined as labels within the same function:

                          if(error)
                            goto Error_end;
                          else
                            goto Executive_routine;

            C. The goto statement is seldom seen in C programs and its use
               is discouraged owing to its potential for creating
               unmanageable "spaghetti" code.

        II. Memory Models.

            A. Turbo C has a number of memory models for the PC due to its
               segmented memory. It is best to choose the smallest model
               possible, as the size of pointers and code necessary to
               support them increase with the larger models. Memory model
               specification is set by use of the Options pull-down (Alt-
               O), then the Compiler choice followed by the code generation
               selection. To set the model, enter Alt-x, where x is the
               first letter of the model desired. Press enter to set this
               model (it will be saved across sessions).

            B. The models available, in ascending size order, are:
               Tiny:  Limits total memory for the entire program to 64K.
               Small: Limits total memory for data to 64K and total memory
                      for code to 64K for a maximum program size of 128K.
                      A good choice for small programs.
               Compact: Limit memory used for code to 64K but allow as much
                      memory as needed for data storage. Probably best for
                      a program with a lot of data storage requirements.
               Medium: Limit memory used for data to 64K but allow as much
                      as needed for code.
               Large: Allow as much memory as needed for both code and
                      data.
               Huge: Reserved for use by programs which have a single data
                      item (usually an array) that itself exceeds 64K.

       III. Separate Compilation (Projects)

            A. When programs are written into separate source programs and
               are separately compiled, they must all be pulled together
               into a single module for execution. There are several
               requirements for this to work properly:

               1. Subroutines, or sub-functions are those called by other
                  functions. They cannot be called main(), as there can be
                  only one function called main() in an executable module.
                  For this reason, you cannot link a subroutine, as the
                  linker builds executable modules. It expects to find one-
                  and-only-one main() function. The subroutine has no main
                  function, so a linker error is produced. The solution is
                  to only compile the sub-programs. This creates an object
                  module which can later be linked with other separately
                  compiled object modules to create an executable program.
                  Object modules have names ending with .obj and will be
                  found in your output directory after any compile.

               2. An executable module must have one-and-only-one main()
                  function. This is because execution begins at the main()
                  function in every executable C program.

               3. User-written header files may also be needed by some or
                  all of the programs.

               4. Global variables can be defined in only one of the
                  compiled modules. In other modules which are separately
                  compiled, the global variables must be declared as
                  extern.

            B. The make utility is a program supplied by most C compiler
               vendors that permits specification of all the source
               modules, header files, and object modules that will be used
               to create an executable program. In addition to merely
               putting the pieces together, make will test them to see if
               they are current or require re-compiling or re-linking. This
               saves you the trouble of remembering what has been changed.
               The TurboC IDE has a make facility built into it called the
               project manager. It is simple to use, and is described in
               your User's Guide.

        IV. Bitwise Operators &, |, ^, ~, >>, <<

            A. Bitwise operators specify operations that actually change
               the content of a variable.

            B. The AND operator (&) is binary, causing the right hand
               operand to be AND'ed against the left operand, setting the
               result in the left operand. The AND operates at the bit
               level, comparing the operands left-to-right one bit at a
               time. When the corresponding bits in both operands are on,
               the bit remains on in the left operand, otherwise it is
               turned off (set to zero). The AND can be used to turn off
               selected bits in a field. For example, if the variable h
               originally contained 0x47, it will contain 0x43 after:
                         h & 0xFD

            C. The OR operator (|) is binary, causing the right hand
               operand to be OR'ed against the left operand, setting the
               result in the left operand. The OR operates at the bit
               level, comparing the operands left-to-right one bit at a
               time. When the corresponding bits in both operands are off,
               the bit remains off in the left operand, otherwise it is
               turned on (set to one). The OR can be used to turn
               individual bits on in a field. For example, if variable p
               originally contained 0x13, it will contain 0x93 after:
                         p | 0x80;

            D. The EXCLUSIVE OR operator (^) is binary, causing the right
               hand operand to be EXCLUSIVE OR'ed against the left operand,
               setting the result in the left operand. The EXCLUSIVE OR
               operates at the bit level, comparing the operands left-to-
               right one bit at a time. When the corresponding bits in both
               operands are opposite, the bit is turned on (set to one) in
               the left operand. When the corresponding bits in both
               operands are the same, the bit is turned off (set to zero).
               For example, if variable s originally contains 0x16 it will
               contain 0x8A after:
                         s ^ 0x9C;

            E. The bitwise COMPLEMENT operator (~) is unary. It scans the
               following field bit-by-bit, changing zeroes to ones and ones
               to zeros. Two consecutive COMPLEMENT operations to the same
               field returns the original value. For example, if the
               variable q originally contained 0xCC, it will contain 0x33
               after:
                         ~q;
            F. The bitwise shift operators are unary, and shift the
               following field right (>>) or left (<<) the number of bits
               specified following the shift operator. The bit shifted out
               is lost, and a zero is inserted in the opposite end of the
               field (except for negative signed fields shifted right). For
               example, if the variable f contained 0x05 originally, it
               will contain 0x14 after:
                          f << 2;
               Also, if variable u is an unsigned char field which
               contained 0x05 initially, it will contain 0x01 after:
                          u >> 2;

            G. For signed fields, the high-order bit is considered to be
               the sign, and is zero for positive values or one for
               negative values. When a right shift is done on a signed
               field (including char's) and the field contains a negative
               value, the bit shifted out is lost, however, a one bit is
               shifted in from the left.

         V. Operator precedence and associativity.

            A. When an expression contains several operators, some rule
               must be provided to account for the order in which they are
               to be processed. Those processed first or earlier are said
               to be of higher precedence than those of later or last use.
               In addition, some operators are associated with what follows
               to their right, while others are associated with that which
               preceded them on the left. This is called associativity. The
               chart below lists all the C operators from highest
               precedence (top of list) to lowest precedence (bottom of
               list). Where more than one operator is on a line the
               operators have equal precedence and are evaluated in the
               order found.

                OPERATORS                     ASSOCIATIVITY
                () [] -> .                    Left-to-Right
                ! ~ ++ -- - (type) * & sizeof Right-to-Left
                * / %                         Left-to-Right
                + -                           Left-to-Right
                << >>                         Left-to-Right
                < <= > >=                     Left-to-Right
                == !=                         Left-to-Right
                &                             Left-to-Right
                ^                             Left-to-Right
                |                             Left-to-Right
                &&                            Left-to-Right
                ||                            Left-to-Right
                ?:                            Right-to-Left
                = += -= etc.                  Right-to-Left
                ,                             Left-to-Right
            B. Precedence has a dramatic effect on the result of boolean
               and arithmetic expression evaluation, as well as the
               interpretation of declarations. It is best to use
               parentheses to force grouping of portions of an expression,
               even when you are sure of the order. This makes the process
               clearer to maintenance programmers and is less likely to
               create problems if the statement requires later
               modification.

               1. Consider the statement
                      i = a + b * c;
                  Since * is of higher priority than either = or + it is
                  evaluated first, and the product of b and c is calculated
                  and held. Next, as + is of higher precedence than =, it
                  is evaluated now so that a is added to the previously
                  computed product of b and c. This result is held.
                  Finally, the = operator is processed so that the value of
                  i is set to the held result. The effect is as though we
                  had written:

                      i = a + (b * c);

               2. Notice that [] is of higher precedence than * so that the
                  following declarations have different meanings:
                      int *pa[];
                      int(*pa)[];

                  In the first, we read "pa is an array of pointers to
                  integers".

                  In the second, *pa is in parentheses, so that must be
                  evaluated first and we read "pa is a pointer" followed by
                  "to an array" and finally "of integers".

          ******************************************************************
          *       Turbo C Editor Navigation and Hot Key Guide    APPENDIX A*
          ******************************************************************

         EDIT CURSOR MOVEMENTS             EDIT MISCELLANEOUS
         Beginning of Line  = Home         Delete a Line      = Ctrl-Y
         End of Line        = End          Delete to EOL      = Ctrl-Q Y
         Top of Window      = Ctrl-Home
         Bottom of Window   = Ctrl-End     EDIT BLOCK OPERATIONS
         Top of File        = Ctrl-PgUp    Mark a Block       = Shift-arrow
         Bottom of File     = Ctrl-PgDn    Copy a Cut Block   = Shift-Ins
         Set Bookmark n     = Ctrl-K n     Delete Marked Block= Ctrl-Del
         Go To Bookmark n   = Ctrl-Q n     Cut Marked Block   = Shift-Del-Ins
         Pair Match Forward = Ctrl-Q ]     Paste Marked Block = Shift-Ins
         Pair Match Back    = Ctrl-Q [     Hide/Display Block = Ctrl-K H
         Search             = Ctrl-Q F     Print Marked Block = Ctrl-K P
         Repeat Last Search = Ctrl-L       Read Block On Disk = Ctrl-K R
         Search and Replace = Ctrl-Q A     Write Block to Disk= Ctrl-K W
         Go to Next Window  = F6
                                           DEBUGGING
         GENERAL                           Trace Execution Into = F7
         Help                 = F1         Trace Execution Over = F8
         Language Help        = Ctrl-F1    Execute to Cursor    = F2
         Exit Turbo C         = Alt-X      Toggle Breakpoint    = Ctrl-F8
         Return to Prior Menu = Esc        Add Watch            = Ctrl-F7
         Save Current File    = F2         Evaluate             = Ctrl-F4
         Activate Menu Bar    = F10        View Program Output  = Alt-F5
         Open a File to Edit  = F3
         Zoom Active Window   = F5         Reference: Turbo C User's Guide
         Compile and Make     = F9                    Chapter 9

          ******************************************************************
          *               Elementary C Programming                  APPNDXB*
          ******************************************************************
                       Data Definitions -  COBOL vs C:

         05 FLD1   PIC X.                   The C definition for a single
         char fld1;                         character first gives the data
                                            type which is the lower-case
                                            word char followed by the
                                            field name, which may be any
                                            mix of upper and lower case.
                                            The statement is terminated by
                                            a semicolon.

         05 FLD2   PIC X VALUE 'A'.         The value for a single character
         char fld2 = 'A'.                   is coded in the same way as it
                                            is in COBOL: enclosed in single
                                            quotes. When a value is coded
                                            it is preceded by an = rather
                                            than the word VALUE, as in
                                            COBOL.


         05 FLD3   PIC X(5).                The C language does not have a
         char fld3[5].                      data type for character strings.
                            Instead, a character
                                            string is treated as a
                                            character array. The square
                                            brackets contain the number of
                                            characters in the array.

         05 FLD4   PIC X(6) VALUE 'CONTENT'.  While C does not recognize a
         char fld4[7] = "CONTENT";          character string as a data type,
                               it does provide a way to
                                            encode a character string by
                                            enclosing the string within
                                            double quotation marks. In C, a
                                            true string is null-terminated.
                                            That is, a binary zero is added
                                            at the end to identify the end
                                            of the string. For this reason,
                                            the C string definition
                                            requires one character more
                                            than the number of characters
                                            in the string itself.

         05 FLD5   PIC S9(4).               A signed integer (whole number
         int fld5;                          without decimals) is defined
                                            in C using the int data type.
                                            The int can hold a value
                                            between -32,768 and +32,767.
                                            The value is kept in binary.

         05 FLD6   PIC 9(4).                An unsigned integer field must
         unsigned int fld6;                 have the word unsigned as a
                                            qualifier. An unsigned int can
                                            contain a value from 0 to
                                            65535.
         05 FLD7   PIC S9(4) value -60.     This example shows how to give
         int fld7 = -60.                    an initial value for an int. A
                                            negative value is shown. The +
                                            is NOT used when specifying a
                                            positive value, however.

         05 FLD8   PIC 9(10).               For unsigned integer values
         unsigned long fld8;                over 65,535 or for signed
                                            integer values outside the
                                            range 32,768 to +32,767 the
                                            long int must be used. When
                                            long is specified the int is
                                            implied and can be omitted.
                                            An unsigned long can contain
                                            values from 0 to 4,294,967,295.

         05 FLD9   PIC S9(8) value +19372.  Values are given for long
         long fld9 = 19372;                 fields in the same way as for
                                            int fields: a decimal value
                                            following an = sign. The signed
                                            long can hold values from -
                                            2,147,483,648 to
                                            +2,147,483,647.

         05 FLD10  PIC S9(5)V99 VALUE +96.73. When a number requires
         float fld10 = 96.73;               decimals, the float and double
                                            data types are used in C. The
                                            float type is a single
                                            precision floating point field
                                            that can contain positive and
                                            negative values from 10**-38 to
                                            10**+38.

         05 FLD11  PIC 9(18)V9(5).          For very large numbers, the
         double fld11;                      double type is used. It is a
                                            floating point field that can
                                            contain positive and negative
                                            numbers with decimal points in
                                            the range 10**-308 to 10**+308.


         05 FLD12  PIC X OCCURS 10 TIMES.   In C, an array is defined by
         char fld12[10];                    placing the number of
                                            occurrences in square brackets
                                            following the field name. C
                                            supports multi-level arrays
                                            which are specified by
                                            consecutive bracketed
                                            occurrence values, for example,
                                            int aray3[5][12][73];

         05 FLD13  PIC S9(5) OCCURS 50 TIMES. An array of long integers is
         long fld13[50];                    specified in the same manner.

         05 FLD14A PIC X(8).                Data redefinition in C is done
         05 FLD14B PIC 9(8) REDEFINES FLD14A.  using the union. A union
                                            definition may contain any
         union un_dcl_nam {                 number of data fields, but only
           char fld14a[8];                  one will be present at any
           long fld14b;                     given time. The size allocated
         } un_def_nam;                      to the union is that of the
                                            largest field contained within
                                            it. Note that curly braces
                                            surround the included fields.
                                            The name following the word
                                            union is the generic name
                                            applied to the union and is
                                            optional, though outside
                                            references cannot be made to it
                                            unless the generic name is
                                            supplied. The name following
                                            the ending curly brace is also
                                            optional, but must be used if
                                            storage is to be set aside for
                                            the union, as this is the name
                                            used to refer to the union.

         01 REC1.                           In C, records are called
            05 FLDR1  PIC X.                structures. Unions and
            05 FLDR2  PIC S9(3).            structures allow the programmer
            05 FLDR3  PIC X(8).             define new data types. Unlike
            05 FLDR4  PIC 9(7)V999.         unions, structures contain all
                                            the fields defined within them.
         struct rec1 {                      A structure may contain other
           char fldr1;                      structures and unions within it
           int fldr2;                       and a union may contain other
           char fldr3[8];                   unions and structures within
           unsigned float fldr4;            This is because C recognizes
         };                                 unions and structures as new
                                            data types. As with the union,
                                            a name following the struct
                                            keyword is optional and can be
                                            used to define the structure at
                                            other points. A name following
                                            the ending curly brace is also
                                            optional, but required for
                                            definitions where storage is
                                            set aside, and this name is
                                            used in references to the
                                            structure.

          ******************************************************************
          *                    Elementary C Programming             APPNDXC*
          ******************************************************************
                     Cross-Reference to Turbo C Library Functions

                             *** LIBRARY CATEGORIES ***

                       MEMORY MANIPULATION <mem.h> <string.h>

                       CHARACTER CLASSIFICATION <ctype.h>

                       CHARACTER CONVERSION <ctype.h>

                       DATA CONVERSION <stdlib.h>

                       DIRECTORY MANIPULATION <dir.h>

                       FILE MANIPULATION <io.h> <stdio.h>

                       GRAPHICS <graphics.h>

                       DRAWING AND ANIMATION <graphics.h>

                       COMBINING GRAPHICS AND TEXT <graphics.h>

                       TEXT MODE ROUTINES <conio.h>

                       STREAM ORIENTED FILE I/O <stdio.h>

                       LOW-LEVEL FILE I/O <io.h>

                       CONSOLE AND PORT I/O <conio.h>

                       MATH <math.h>

                       Memory Allocation <alloc.h>

                       String Manipulation <string.h>

                       Searching and Sorting <stdlib.h>

                       Process Control <process.h>

                       System Calls <dos.h>

                       Time <time.h> <dos.h>

         Notes: (1) The normal header file is shown in angle brackets <>
                (2) D indicates functions available for DOS/PC
                (3) U indicates functions available on UNIX
                (4) A indicates ANSI compatible functions
                           *** MEMORY MANIPULATION <mem.h> <string.h> ***

     DU. memccpy           Copy one memory area to another
     DUA memchr            Search for a character in a memory area
     DUA memcmp            Compare two areas of memory
     DUA memcpy            Copy one memory area to another
     DU. memicmp           Compare two areas of memory ignoring case
     DUA memmove           Move one memory area to another
     DUA memset            Set all bytes of a buffer to a given character
     D?? movedata          Move memory area to another segment
     D?? setmem            Set all bytes of a buffer to a given character
     DU. swab              Swap adjacent bytes in a memory area

                           *** CHARACTER CLASSIFICATION <ctype.h> ***

     DUA isalnum           True if character is alphanumeric
     DUA isalpha           True if character is alphabetic
     DU. isascii           True if character is ASCII
     DUA iscntrl           True if character is a control character
     DUA isdigit           True if character is a decimal digit
     DUA isgraph           True if character is a graphical character
     DUA islower           True if character is a lowercase letter
     DUA isprint           True if character is printable
     DUA ispunct           True if character is punctuation
     DUA isspace           True if character is a blank
     DUA isupper           True if character is an uppercase letter
     DUA isxdigit          True if character is a hexadecimal digit

                           *** CHARACTER CONVERSION <ctype.h> ***

     DU. toascii           Convert character to ASCII
     DU. _tolower          Convert character to lowercase
     DUA tolower           Convert character to lowercase (checks upper)
     DU. _toupper          Convert character to uppercase
     DUA toupper           Converts character to uppercase

                           *** DIRECTORY MANIPULATION <dir.h> ***

     DU. chdir             Change current directory to a given path
     D.. getcwd            Returns name of current working directory
     D?? mkdir             Create a directory using given path name
     D?? rmdir             Delete a specified directory
     D.. searchpath        Locate named file in current path directories

                           *** DATA CONVERSION <stdlib.h> ***

     DUA atof              Convert string to floating point value
     DUA atoi              Convert string to integer
     DUA atol              Convert string to long integer
     DU. ecvt              Convert double to a string
     DU. fcvt              Convert double to string rounded
     DU. gcvt              Convert double to a string
     D?? itoa              Convert integer to a string
     D?? ltoa              Convert long integer to string by radix
     DUA strtod            Convert string to a float
     DUA strtol            Convert string to a long integer
     D.A strtoul           Convert string to unsigned long
     D?? ultoa             Convert unsigned long to a string

                           *** MEMORY ALLOCATION <alloc.h> ***

     DU. brk               Set a new break value
     DUA calloc            Allocate an array and init all elements to 0
     D.. coreleft          Return amount of available memory
     D.. farcalloc         Alloc an array of elements in the far heap
     D.. farcore           Get amount of available memory
     D.. farfree           Free a block of memory alloc from far heap
     D.. farmalloc         Allocate a block of memory from far heap
     D.. farrealloc        Reallocate a block of memory
     DUA free              Free a block of memory
     DUA malloc            Allocate a block of memory
     DUA realloc           Reallocate (adjust size) of a block of memory
     DU. sbrk              Allocate memory by adjusting the break value

                           *** FILE MANIPULATION <io.h> <stdio.h> ***

     DU. access            Check permission settings for specified file
     DU. chmod             Change permission settings for specified file
     D.. chsize            Change size of a file
     D?? filelength        Get size of specified file in bytes
     D.. fnmerge           Construct DOS path name
     D.. fnsplit           Split DOS pathname into sub-strings
     D?? fstat             Get file status information
     D?? isatty            Check if a handle denotes a file or a device
     D.. lock              Lock parts of a file open for sharing
     DU. mktemp            Generate a unique temporary file name
     DUA remove            Delete a named file
     D.A rename            Rename a file
     DU. setmode           Set file translation mode for an open file
     D?? stat              Get file status information for a file
     D?? umask             Set file permission mask
     DU. unlink            Delete a file
     D.. unlock            Unlock previously locked parts of a file

                           *** GRAPHICS <graphics.h>***

     D.. closegraph        Close Turbo C graphics package
     D.. detectgraph       Detect graphics hardware
     D.. getarccoords      Get coordinates of endpoints of an arc
     D?? getaspectratio    Get the aspect ratio of the screen
     D.. getbkcolor        Get the background color number
     D.. getcolor          Get the current drawing color
     D?? pallettetype      Get default pallette of current graphics driver
     D.. getdrivername     Get name of current graphics driver
     D.. getfillpattern    Get current fill pattern
     D.. getfillsettings   Get current fill style and fill color
     D.. getgraphmode      Get the current graphics mode number
     D.. getlinesettings   Get the current line style and thickness
     D.. getmaxcolor       Get the maximum color number for current mode
     D.. getmaxmode        Get maximum mode number for current driver
     D.. getmaxx           Get the maximum x coordinate
     D.. getmaxy           Get the maximum y coordinate
     D.. getmodename       Get descriptive name of current mode
     D.. getmoderange      Get the low and high mode numbers
     D.. getpallette       Get the current pallette setting
     D.. getpallettesize   Get the number of colors in current pallette
     D.. getviewsettings   Get the current viewport settings
     D.. getx              Get x coordinate current position
     D.. gety              Get y coordinate current position
     D.. graphdefaults     Reset graphics package to default settings
     D.. grapherrormsg     Get the error message for the given error code
     D.. _graphfreemem     User-defined memory deallocation routine
     D.. _graphgetmem      User-defined memory allocation routine
     D.. graphresult       Get result code of the graphics operation
     D.. initgraph         Initialize the Turbo C graphics package
     D.. installuserdriver Install a new BGI driver in the graphics system
     D.. registerbgidriver Register a preloaded graphics driver
     D.. restorecrtmode    Go from a graphics mode to a text mode
     D.. setactivepage     Set the active page
     D.. setallpallette    Redefine entire pallettein EGA/VGA
     D.. setaspectratio    Set the aspect ratio
     D.. setbkcolor        Set a new background color
     D.. setcolor          Set a new drawing color
     D.. setfillpattern    Select a new fill pattern and color
     D.. setfillstyle      Choose a predefined fill style and color
     D.. setgraphbufsize   Set buffer size or internal buffer
     D.. setgraphmode      Select a graphics mode
     D.. setlinestyle      Select a line style and thickness
     D.. setpallette       Redefine a single color in the pallette
     D.. setrgbpallette    Define a color in the IBM 8514 adapter
     D.. setviewport       Define a viewport
     D.. setvisualpage     Select the graphics page to be displayed
     D.. setwritemode      Set the writing mode for line drawings

                           *** DRAWING AND ANIMATION <graphics.h> ***

     D.. arc               Draw a circular arc of specified extent
     D.. bar               Draw a filled rectangular bar
     D.. bar3d             Draw a filled 3-d rectangular bar
     D.. circle            Draw a circle given center and radius
     D.. cleardevice       Clear the screen
     D.. clearviewport     Clear the current viewport
     D.. drawpoly          Draw a number of line segments
     D.. ellipse           Draw an ellipse
     D.. fillellipse       Draw a filled ellipse
     D.. fillpoly          Draw a filled polygon
     D.. floodfill         Fill an enclosed area
     D.. getimage          Save rectangular screen image in a buffer
     D.. getpixel          Get the pixel value at a screen coordinate
     D.. imagesize         Compute bytes needed to save an image
     D.. line              Draw a line between two points
     D.. linerel           Draw a line to a point at a specified offset
     D.. lineto            Draw a line to another point
     D.. moverel           Move to a point at a specified offset
     D.. moveto            Move to a new point
     D.. pieslice          Draw a filled pie slice
     D.. putimage          Restore saved image from buffer
     D.. putpixel          Set a pixel to a specified color
     D.. rectangle         Draw a rectangle
     D.. sector            Draw a filled elliptical sector

                  *** COMBINING GRAPHICS AND TEXT <graphics.h> ***

     D.. gettextsettings   Get current settings for graphics text
     D.. installuserfont   Install a new stroke font in the graphics system
     D.. outtext           Draw a string using current font
     D.. outtextxy         Draw a text string at a given point
     D.. settextjustify    Select text justification
     D.. settextstyle      Select font and character size
     D.. setusercharsize   Set the scaling factor for characters
     D.. textheight        Get the height of a text string in pixels
     D.. textwidth         Get the width of a string in pixels
     D.. registerbgifont   Register a preloaded font
     D.. registerfarbgifont Register a preloaded font (far data)

                           *** TEXT MODE ROUTINES <conio.h> ***

     D.. clreol            Erase to the end of the line
     D.. clrscr            Erase the screen in text mode
     D.. delline           Delete the line on which the cursor rests
     D.. gettext           Save a portion of text screen in a buffer
     D.. gettextinfo       Get text mode settings
     D.. gotoxy            Move cursor to a specific location
     D.. highvideo         Turn on high intensity bit
     D.. insline           Insert a line
     D.. lowvideo          Turn off high intensity bit
     D.. movetext          Copy one on-screen rectangle to another
     D.. normvideo         Set the text attribute to its normal setting
     D.. puttext           Restore saved text to the screen
     D.. textattr          Set text attribute
     D.. textbackground    Select background attribute
     D.. textcolor         Select foreground text attribute
     D.. textmode          Set a new text mode
     D.. wherex            Get x-coordinate of cursor
     D.. wherey            Get y-coordinate of cursor
     D.. window            Define a text window

                           *** STREAM ORIENTED FILE I/O <stdio.h> ***

     DUA clearerr          Clear error indicator of stream file
     DUA fclose            Close a stream file
     DU. fcloseall         Close all open stream files
     DU. fdopen            Open a file for stream I/O using its handle
     DUA feof              Check if end of file occurred on a stream
     DUA ferror            Check for stream file I/O errors
     DUA fflush            Write out (flush) buffer to stream file
     DUA fgetc             Get a character from a stream file
     DU. fgetchar          Read a character from stdin
     D.A fgetpos           Get the current position in a stream file
     DUA fgets             Read a string from a stream file
     DU. fileno            Get the handle of a stream file
     DU. flushall          Flush all buffers for all open stream files
     DUA fopen             Open a stream file for buffered I/O
     DUA fprintf           Write formatted output to a stream file
     DUA fputc             Write a character to a stream file
     DU. fputchar          Write a character to stdout
     DUA fputs             Write a string to a stream file
     DUA fread             Read stream file data into a buffer
     DUA freopen           Reassign a stream file pointer to another file
     DUA fscanf            Read input from a stream file
     DUA fseek             Set current position in a stream file
     D.A fsetpos           Set current position in a stream file
     DUA ftell             Get current location in a stream file
     DU. fwrite            Write data to a stream file
     DUA getc              Read a character from a stream file
     DUA getchar           Read a character from stdin
     DUA gets              Read a line from stdin
     DU. getw              Read a binary integer from a stream file
     DUA printf            Write data to stdout
     DUA putc              Write a character to a stream file
     DUA putchar           Write a character to stdout
     DUA puts              Write a string to stdout
     DU. putw              Write a binary integer to a stream file
     DUA rewind            Rewind a file
     DUA scanf             Read formatted input from stdin
     DUA setbuf            Set up a new buffer for the stream file
     DUA setvbuf           Set up new buffer and buffer level for stream
     DUA sprintf           Write formatted output to a string
     DUA sscanf            Read formatted input from a string
     DUA tmpfile           Open a temporary file
     DUA tmpnam            Get temporary file name
     DUA ungetc            Push back character into stream file's buffer
     DUA vprintf           Write formatted output to a stream file
     DU. vfscanf           Read formatted input from a stream file
     DUA vprintf           Write formatted output to stdout
     DUA vscanf            Read formatted input from stdin
     DU. vsprintf          Write formatted output to a string
     D.. vsscanf           Read formatted input from a string

                           *** LOW-LEVEL FILE I/O <io.h> ***

     DU. close             Close a file opened for low-level I/O
     DU. creat             Create a new file with specified permissions
     D.. creatnew          Create a new file if none exists
     D.. creattemp         Create a temporary file
     DU. dup               Create a second handle for a low-level file
     DU. dup2              Reassign a handle to an open low-level file
     D?? eof               Check for end of file on a low-level file
     DU. lseek             Go to a specified position in a low-level file
     DU. open              Open a file for low-level I/O
     DU. read              Read data from a file opened for low-level I/O
     DU. sopen             Open a file for shared access'
     DU. tell              Get current position in a low-level file
     DU. write             Write data to a file opened for low-level I/O

                           *** CONSOLE AND PORT I/O <conio.h> ***

     D.. cgets             Read a string from the console
     D.. cprintf           Write formatted output to console
     D.. cputs             Write a string to the console
     DU. cscanf            Read formatted input from the console
     D.. getch             Read a character from the keyboard without echo
     D.. getche            Read a character from the keyboard with echo
     DU. getpass           Prompt for a password and read it without echo
     D.. inport            Read two bytes from specified I/O port address
     D.. inportb           Read a byte from specified I/o port address
     D?? kbhit             Determine if any key has been pressed
     D.. outport           Write two bytes to specified I/O port address
     D.. outportb          Write a byte to specified I/O port address
     D.. putch             Write a character to the screen
     DU. ungetch           Push back last character into keyboard buffer

                           *** MATH <math.h> ***

     DUA abs               Get absolute value of an integer
     DUA acos              Compute arc cosine
     DUA asin              Compute arc sine
     DUA atan              Compute arc tangent
     DUA atan2             Compute arc tangent of a fraction
     DU. cabs              Compute magnitude of a complex number
     DUA ceil              Get the smallest integral value exceeding
     D.. _clear87          Clear the floating point status word
     D.. _control87        Set a new floating point control word
     DUA cos               Compute arc cosine of angle in radians
     DUA cosh              Compute hyperbolic cosine
     D.A div               Divide one integer by another
     DUA exp               Compute exponential
     DUA fabs              Compute absolute value
     DUA floor             Get largest integral value less than
     D.A fmod              Divide giving integral quotient and remainder
     D.. _fpreset          Reset floating point package
     DUA frexp             Break float into mantissa and exponent
     DU. hypot             Compute hypotenuse of a right triangle
     DUA labs              Find absolute value of a long
     DUA ldexp             Builds a double from mantissa and exponent
     D.A ldiv              Divide one long by another
     DUA log               Compute log of a double
     DUA log10             Compute log to the base 10 of a double
     D?? _lrotl            Rotate a long left a specified nbr of bytes
     D?? _lrotr            Rotate a long right a specified nbr of bytes
     D.. matherr           handle math errors (you can write your own)
     D?? _matherr          handle math errors
     D?? max               Macro to get a maximum of two arguments
     D?? min               Macro to get a minimum of two arguments
     D?? modf              Breaks double to fractional and integer parts
     DUA pow               Compute a number raised to a power
     DU. pow10             Compute 10 raised to a specified power
     DUA rand              Get a random integer 0 to 32,767,236
     D?? random            Get random number between 0 and specified max
     D?? randomize         Set a seed for the random number generator
     D?? _rotl             Rotate an integer left a specified nbr bytes
     D?? _rotr             Rotate an integer right a specified nbr bytes
     DUA sin               Compute sine of an angle in radians
     DUA sinh              Compute hyperbolic sine of a double
     DUA sqrt              Compute square root of a double
     DUA srand             Set new seed for random nbr generator
     D.. _status87         Get the floating point status word
     DUA tan               Compute tangent of an angle in radians
     DUA tanh              Compute hyperbolic tangent of a double

                           *** STRING MANIPULATION <string.h> ***

     DU. stpcpy            Copy one string to another
     DUA strcat            Concatenate one string to another
     DUA strchr            Search a string for a specified character
     DUA strcmp            Compare two strings
     D?? strcmpi           Compare two strings ignoring case
     DUA strcpy            Copy one string to another
     DUA strcspn           Find 1st occur of a char one strg to another
     DU. strdup            Create duplicate copy of a string
     D?? strerror          Get error message for given error number
     D.A _strerror         Get error message for last error
     D?? stricmp           Compare two strings ignoring case
     DUA strlen            Get length of a string
     D?? strlwr            Convert string to lowercase
     DUA strncat           Append chars from one string to another
     DUA strncmp           Compare 1st n chars of two strings
     D?? strncmpi          Compare 1st n chars of 2 strgs ignoring case
     DUA strncpy           Copy 1st n chars of one string to another
     D?? strnicmp          Compare 1st n chars of 2 strings ignoring case
     D?? strnset           Set 1st n chars of a string to given character
     DUA strpbrk           Locate 1st occur of any char one strg to other
     DUA strrchr           Find last occur of given char in a string
     D?? strrev            Reverse order of characters in a string
     D?? strset            Set all characters in a string to given char
     DUA strspn            Locate 1st char in one string not in other

                           *** PROCESS CONTROL <process.h> ***

     DUA strstr            Find 1st occur of one string in another
     DUA strtok            Get tokens from a string
     D?? strupr            Convert string to uppercase
     DUA abort             Abort a process
     DUA assert            Abort a process if expression is false
     D.A atexit            Set up functions to call when process ends
     D.. exec              Launch a child process (pass command line)
     D.. execle            Launch a child (pass cmd line & environment)
     D.. execlp            Launch a child (use PATH, pass cmd line)
     D.. execlpe           Launch a child (use PATH, pass cmd line, env)
     D.. execv             Launch a child (pass argument vector)
     D.. execve            Launch a child (pass arg vector & environment)
     D.. execvp            Launch child (use PATH, pass arg vector)
     D.. execvpe           Launch child (use PATH, pass arg vect, env)
     DU. exit              Terminate process after flushing all buffers
     DUA _exit             Terminate process without flushing buffers
     DUA getenv            Get definition of environment variable
     DUA longjmp           Return by restoring a saved stack environment
     DUA perror            Print error message for last system error
     DU. putenv            Insert new definition into environment table
     DUA raise             Generate a C signal (exception)
     DUA setjmp            Save the stack environment for use by longjmp
     D.A signal            Establish a signal handler
     D?? spawn             Spawn child process (pass cmd line)
     D?? spawnle           Spawn child (pass cmd line & environment)
     D?? spawnlp           Spawn child (use PATH, pass cmd line)
     D?? spawnlpe          Spawn child (use PATH, pass cmd line, env)
     D?? spawnv            Spawn child (pass arg vector)
     D?? spawnve           Spawn child (pass arg vector & env)
     D?? spawnvp           Spawn child (use PATH, pass arg vector)
     D?? spawnvpe          Spawn child (use PATH, pass arg vector & env)
     DUA system            Execute an MS-DOS command
                           *** SEARCHING AND SORTING <stdlib.h> ***

     DUA bsearch           Perform binary search
     D?? lfind             Search linearly for given keyword
     DU. lsearch           Search linearly for a given keyword
     DUA qsort             Use quicksort algorithm to sort an array


                           *** SYSTEM CALLS <dos.h> ***

     D.. absread           Read from logical disk sectors using int 25h
     D.. abswrite          Write to logical disk sectors using int 26h
     D.. allocmem          Get memory from DOS (function 48h)
     D.. bdos              Call DOS functions using only DX and AL
     D.. bdosptr           Call DOS functions needing pointer DS:DX
     D.. bioscom           Access BIOS RS232C services int 14h)
     D.. biosdisk          Access the BIOS disk services (int 13h)
     D.. biosequip         Get equipment flag (int 11h)
     D.. bioskey           Access BIOS keyboard services (int 16h)
     D.. biosmemory        Get memory size in KB (int 12h)
     D.. biosprint         Access BIOS printer services (int 17h)
     D.. biostime          Get time of day clock (int 1Ah)
     D.. _chmod            Change attributes of a file
     D.. _close            Close file (DOS function 3Eh)
     D.. _creat            Create a file - erases existing (DOS 3Ch)
     D.. country           Get/set country dependent date/time formats
     D.. ctrlbrk           Install a control-break handler
     D.. delay             Wait a specified nbr milliseconds
     D.. disable           Turn off interrupts (with CLI)
     D.. dosexterr         Get extended error info (function 59h)
     D.. dostounix         Convert date and time from DOS to UNIX format
     D.. __emit__          Embed 8086 opcodes and operands in code
     D.. enable            Enable interrupts (using STI)
     D.. findfirst         Find 1st occur of a file (DOS 4Eh)
     D.. findnext          Find next occurrence of file (func 4Fh)
     D.. FP_OFF            Macro to get offset of a far pointer
     D.. FP_SEG            Macro to get segment address of far pointer
     D.. freemem           Free memory to DOS (function 49h)
     D.. geninterrupt      Generate specified software interrupt
     D.. getcbrk           Use DOS function 33h to get ctrl-brk check flag
     D.. getcurdir         Get the current directory for specified drive
     D.. getdate           Get date (function 2Ah)
     D.. getdfree          Get size of free and used space on disk
     D.. getdisk           Get current drive number (function 19h)
     D.. getdta            Get the address of the disk transfer area
     D.. getfat            Get file allocation table (FAT) info
     D.. getfatd           Get FAT information for default drive
     D.. getftime          Get modification time of file (func 57h)
     D.. getpsp            Get segment address of Program Segment Prefix
     D.. getswitchar       Use DOS function 37h to get current switch char
     D.. gettime           Get time (DOS function 2Ch)
     D.. getverify         Get current setting of VERIFY flag
     D.. interrupt         Get address of handler for int nbr (func 35h)
     D.. harderr           Set up a handler for critical errors
     D.. hardresume        Return to DOS from critical error handler
     D.. hardretn          Return to appl from critical error handler
     D.. ioctl             Use DOS function 44h for IOCTL of device drivers
     D.. int86             Generate 80x86 software interrupts
     D.. int86x            Generate 80x86 software interrupts
     D.. intdos            Generate int 21h to access DOS functions
     D.. intdosx           Generate int 21h to access DOS functions
     D.. intr              Generate any 80x86 software interrupt
     D.. keep              Terminate and stay resident (DOS func 31h)
     D.. MK_FP             Make a far pointer out of segment and offset
     D.. nosound           Turn off the PC's speaker
     D.. _open             Open a file (DOS function 3Dh)
     D.. parsfnm           Parse a file name using FCB (DOS func 29h)
     D.. peek              Get word at specified segment and offset address
     D.. peekb             Get byte at specified segment and offset address
     D.. poke              Copy value into word at specified address
     D.. pokeb             Copy value into byte at specified address
     D.. _read             Read binary data from file (func 3Fh)
     D.. randbrd           Read records from file using FCB (DOS func 27h)
     D.. randwr            Write records to file using FCB (DOS func 28h)
     D.. segread           Read the segment registers
     D.. setblock          Alter size of allocated memory (func 4Ah)
     D.. setcbrk           Set the ctrll-brk check flg (DOS func 33h)
     D.. setdate           Set the date (function 2Bh)
     D.. setdisk           Set the current drive (function 0Eh)
     D.. setdta            Set up a Disk Transfer Area for FCB file I/O
     D.. setftime          Set the file modification time (func 57h)
     D.. setswitchar       Use DOS function 37h to set new switch char
     D.. settime           Set the system time (function 2Dh)
     D.. setvect           Set up new handler for given int nbr (func 25h)
     D.. setverify         Set the VERIFY flag
     DU. sleep             Wait a specified number of seconds
     D.. sound             Turn on the PC's speaker at given frequency
     D.. unixtodos         Convert time from UNIX to DOS format
     D.. _write            Write binary data to file (Function 40h)

                           *** TIME <time.h> <dos.h>***

     DUA asctime           Convert time from struct tm to string
     D.A clock             Get elapsed processor time in clock ticks
     DUA ctime             Convert binary time to string
     DUA difftime          Compute difference between two times in seconds
     DU. ftime             Get current time in a timeb struct
     DUA gmtime            Get Greenwich Mean Time in a tm struct
     DUA localtime         Get the local time in a tm struct
     DU. stime             Get the system time and date
     DUA time              Get current times as seconds since 1/1/1970
     DU. tzset             Set global variables from env vrbl TZ

          *********************************************************************
          *                   Elementary C Programming                 APPNDXD*
          *********************************************************************
                              Key Codes for the IBM PC

         When reading from the keyboard, normal printable ASCII characters are
         returned as would be expected in a single character variable. When a
         special key is pressed, however, it is returned as a 2-character
         sequence. The first character returned is a null (\0). This is a sign
         that a non-ASCII key was pressed, and its scan code will be presented
         by the next read to the keyboard. The scan code relates to the
         physical position of the key on the keyboard. Here is a list of the
         key codes for the IBM PC. All key code values are given in decimal.
         When the code is a scan code for an extended key code it is shown in
         angle brackets. See keyvalu.c for a program to obtain key values.

         KEY          ALONE   WITH CTRL   WITH ALT WITH SHIFT  SHIFTED

         j             106          10       <36>         74      J
         k             107          11       <37>         75      K
         l             108          12       <38>         76      L
         ;(semicolon)   59           .       <39>         58      :
         '(apostrophe)  39           .       <40>         34      "
         Enter          13          10       <28>         13
         z             122          26       <44>         90      Z
         x             120          24       <45>         88      X
         c              99           3       <46>         67      C
         v             118          22       <47>         86      V
         b              98           2       <48>         66      B
         n             110          14       <49>         78      N
         m             109          13       <50>         77      M
         , (comma)      44           .       <51>         60      <
         . (period)     46           .       <52>         62      >
         /              47           .       <53>         63      ?
         Space          32          32         .          32
         Up Arrow      <72>       <141>     <152>          .
         Left Arrow    <75>       <115>     <155>          .
         Down Arrow    <80>       <145>     <160>          .
         Right Arrow   <77>       <116>     <157>          .
         - (dash)       45          31      <130>         95      underscore
         =              61           .      <131>         43      +
         Backspace       8         127       <14>          8
         Ins           <82>       <146>     <162>        <82>
         Home          <71>       <119>      OS/2        <71>
         PgUp          <73>       <132>     <153>        <73>
         Tab             9        <148>      OS/2        <15>
         q             113          17      <16>          81      Q
         w             119          23      <17>          87      W
         e             101           5      <18>          69      E
         r             114          18      <19>          82      R
         t             116          20      <20>          84      T
         KEY          ALONE   WITH CTRL   WITH ALT WITH SHIFT  SHIFTED

         y             121          25      <21>          89      Y
         u             117          21      <22>          85      U
         i             105           9      <23>          73      I
         o             111          15      <24>          79      O
         p             112          16      <25>          80      P
         [ (L. Bracket) 91          27      <26>         123      { (L. Brace)
         ] (R. Bracket) 93          29      <27>         125      } (R. Brace)
         \              92          28      <43>         124      | (Logic OR)
         Del           <83>       <147>    <163>         <83>
         End           <79>       <117>    <159>         <79>
         PgDn          <81>       <118>    <161>         <81>
         a              97           1      <30>          65      A
         s             115          19      <31>          83      S
         d             100           4      <32>          68      D
         f             102           6      <33>          70      F
         g             103           7      <34>          71      G
         h             104           8      <35>          72      H
         Esc            27         OS/2     OS/2         OS/2
         F1            <59>        <94>    <104>         <84>
         F2            <60>        <95>    <105>         <85>
         F3            <61>        <96>    <106>         <86>
         F4            <62>        <97>    <107>         <87>
         F5            <63>        <98>    <108>         <88>
         F6            <64>        <99>    <109>         <89>
         F7            <65>       <100>    <110>         <90>
         F8            <66>       <101>    <111>         <91>
         F9            <67>       <102>    <112>         <92>
         F10           <68>       <103>    <113>         <93>
         F11          <133>       <137>    <139>        <135>
         F12          <134>       <138>    <140>        <136>
         PrtScn          .           .         .           .
         Scroll Lock     .           .         .           .
         Pause           .           .         .           .
                        96           .       <41>        126      ~ (Tilde)
         1              49           .      <120>         33      !
         2              50          <3>     <121>         64      @
         3              51           .      <122>         35      #
         4              52           .      <123>         36      $
         5              53           .      <124>         37      %
         6              54           .      <125>         94      ^ (carat)
         7              55           .      <126>         38      &
         8              56           .      <127>         42      *
         9              57           .      <128>         40      (
         0              48           .      <129>         41      )
         KEY          ALONE   WITH CTRL   WITH ALT WITH SHIFT  SHIFTED

                        (Keypad - NumLock OFF)
         /              47        <149>     <164>         47
         *              42        <150>      <55>         42
         -              45        <142>      <74>         45
         7             <71>       <119>        7           .      Home
         8             <72>       <141>        8           .      Up Arrow
         9             <73>       <132>        9           .      PgUp
         4             <75>       <115>        4           .      Left Arrow
         5             <76>       <143>        5          53
         6             <77>       <116>        6           .      Right Arrow
         1             <79>       <117>        1           .      End
         2             <80>       <145>        2           .      Down Arrow
         3             <81>       <118>        3           .      PgDn
         0             <82>          .         .           .      Ins
         Del           <83>          .         .           .      . (period)
         +              43        <144>      <78>         43
         Enter          13          10      <166>         13

                        (Keypad - NumLock ON)
         /              47        <149>     <164>         47
         *              42        <150>      <55>         42
         -              45        <142>      <74>         45
         7              55        <119>        7           .      Home
         8              56        <141>        8           .      Up Arrow
         9              57        <132>        9           .      PgUp
         4              52        <115>        4           .      Left Arrow
         5              53        <143>        5          76
         6              54        <116>        6           .      Right Arrow
         1              49        <117>        1           .      End
         2              50        <145>        2           .      Down Arrow
         3              51        <118>        3           .      PgDn
         0              48           .         .           .      Ins
         Del            46           .         .           .      . (period)
         +              43        <144>      <78>         43
         Enter          13          10      <166>         13

          *********************************************************************
          *                   Elementary C Programming                 APPNDXE*
          *********************************************************************
                           ANSI.SYS Screen/Cursor Control

         ANSI.SYS is an optional device driver supplied with DOS that permits
         use of "escape sequences" to control cursor positioning and screen
         control. To install it, edit the CONFIG.SYS file and add the line:
                     DEVICE=ANSI.SYS
         then re-boot the computer. After installation, ANSI.SYS checks all
         characters sent to the screen for special "escape sequences"
         beginning with the Esc key value of hex 1B (\x1B) followed by a left
         bracket. The characters following the ESC and left bracket define the
         operation to be performed. Because they are cryptic and easily mis-
         keyed, they are often set up using #define statements so that more
         readable names may be used in printf statements. Here are some of the
         more common ones:

         #define CLEAR "\x1B[2J"
         #define ERASE_EOL "\x1B[K"
         #define CURSOR_UP "\x1B[A"
         #define CURSOR_DOWN "\x1B[B"
         #define CURSOR_RIGHT "\x1B[C"
         #define CURSOR_LEFT "\x1B[D"
         #define POSITION_CURSOR "\x1B[%d;%df"
         #define SAVE_CURSOR_POSITION "\x1B[s"
         #define RESTORE_CURSOR "\x1B[u"
         #define CURSOR_UP_NROWS "\x1B[%dA"
         #define CURSOR_DOWN_NROWS "\x1B[%dB"
         #define CURSOR_RIGHT_NCOLS "\x1B[%dC"
         #define CURSOR_LEFT_NCOLS "\x1B[%dD"


         To use these definitions, just place them in the parameter for a
         printf. Notice that the surrounding quotes are included in the
         definition. Here are some examples:

         printf(CLEAR);           /* clear screen, home cursor */
         printf(ERASE_EOL);       /* erase from cursor to end of line */
         printf(CURSOR_UP);       /* move cursor up one line */
         printf(CURSOR_DOWN);     /* move cursor down one line */
         printf(CURSOR_RIGHT);    /* move cursor right one column */
         printf(CURSOR_LEFT);     /* move cursor left one column */
         printf(POSITION_CURSOR,row,col);  /* move cursor to the row number */
                                  /* contained in the int variable row and  */
                                  /* the column number contained in the int */
                                  /* variable col.                          */
         printf(CURSOR_UP_NROWS,i); /* Move cursor up i rows */
         printf(CURSOR_DOWN_NROWS,7); /* Move cursor down 7 rows */
         printf(CURSOR_RIGHT_NCOLS,j); /* move cursor right j columns */
         printf(CURSOR_LEFT_NCOLS,3); /* move cursor left 3 columns */

          *********************************************************************
          *                   Elementary C Programming                 APPNDXF*
          *********************************************************************
                           ANSI.SYS and Attribute Control

         ANSI.SYS also contains escape sequences to permit setting screen
         character attributes. Every character in display memory is stored as
         a pair of bytes, one containing the character value itself, and the
         other its attributes. Here is how to define the escape sequence for
         setting attribute characters and the attributes themselves:

         #define NORMAL    "\x1B[0dm"
         #define BOLD      "\x1B[1dm"
         #define UNDERLINE "\x1B[4dm"
         #define BLINK     "\x1B[5dm"
         #define REVERSE   "\x1B[7dm"
         #define INVISIBLE "\x1B[8dm"

         Once a particular attribute has been turned on, all characters
         printed from that point on will have the specified attribute until
         the NORMAL attribute is written to reset it. Because of this,
         attributes can be combined by consecutively issuing them.

         To use the definitions above, include them as strings in a printf
         statement, using %s at the point where they are to become effective.
         For example:

              printf("Normal %s Blink %s back to normal",BLINK,NORMAL);

         will create a display line with the word Blink blinking. Since the
         NORMAL attribute is issued after the word Blink, the remaining
         characters will be in normal mode. To display the word WIERD as a
         reversed video blinking field, code:

              printf("%s %s WIERD",BLINK,REVERSE);

         Since the NORMAL attribute was not issued following this display, the
         reversed-video-blinking will continue to be applied to all characters
         displayed until NORMAL is re-established.

          *********************************************************************
          *                   Elementary C Programming                 APPNDXG*
          *********************************************************************
                             Keywords and Operators in C

                              Reserved Keywords
         int             integer data type
         char            character data type
         float           single precision floating point data type
         double          double precision floating point data type
         struct          structure data type
         union           union data type
         long            long integer data type
         short           short integer data type
         unsigned        unsigned data type modifier
         auto            automatic data type modifier
         extern          external data type modifier
         register        register data type
         typedef         creates a new data type
         static          static data type modifier
         goto            goto a label
         return          return from a function
         sizeof          returns length of an object
         break           breaks out of a loop
         continue        jumps back to beginning of loop
         if              conditional statement
         else            conditional statement
         for             loop statement
         do              loop statemdnt
         while           loop statement
         switch          process control statement
         case            identifies a switch statement case
         default         default processing for a switch
         entry           Reserved, not currently used
                      Operators in C (in precedence order)

         ()  []  .  ->                groups, membership

         -  ~  !  *  &                unary

         ++  --  sizeof  casts        unary

         *  /  %                      multiplicative

         +  -                         additive

         <<  >>                       shift

         <  >  <=  >=                 relational

         ==  !=                       equality

         &                            bitwise AND

         ^                            bitwise exclusive OR

         |                            bitwise inclusive OR

         &&                           logical AND

         ||                           logical OR

         ?:                           conditional

         =  *=  /=  %=  +=  -=        assignment

         <<=  >>=  &=  ^=  |=         assignment

         ,                            series

          *********************************************************************
          *                   Elementary C Programming                hello2.c*
          *********************************************************************

          /***************************************************************/
          /*                   hello2.c                                  */
          /* hello2.c is version2 of the Hello, World! program           */
          /***************************************************************/

          #include <stdio.h>;              /* include standard I/O header*/

          #define White 623                /* White is 623               */

          int print_count(int count);      /* print_count prototype      */

          char hello[] = "hello, zorld!\n"; /* string with initial value */

          /***************************************************************/
          /* main function: initial program entry point                  */
          /***************************************************************/

          void main() {                    /* function header for main   */

            int count = White;             /* define count = 623         */
            char picx = 'W';               /* define picx = 'W'          */

            hello[7] = picx;               /* move picx to string[7]     */
            printf("%s",hello);            /* display modified string    */
            printf                         /* printf                     */
                  (                           /* with                    */
                   "White space is ignored\n"    /* many                 */
                                              )     /* imbedded          */
                                                ;      /* spaces         */

         /****************************************************************/
         /* The printf below displays the number returned by the         */
         /* print_count function. Notice that no variable is used on the */
         /* right side of the parameter, but only a call to print_count. */
         /* this is because a function call IS what it returns.          */
         /****************************************************************/

            printf("The print_count() function returned %d\n",
                    print_count(count));   /* print print_count's return */
         }                                 /* end of main function       */

         /****************************************************************/
         /* print_count: display value of the count field and return an  */
         /* integer value to the caller.                                 */
         /****************************************************************/

         int print_count(int white) {   /* print_count's function header */

           int ret_valu;                   /* define ret_valu            */

           /**************************************************************/
           /* The printf below displays the integer value received as a  */
           /* parameter on entry. Note that it is passed by the caller as*/
           /* a field called count, but is called white on entry to the  */
           /* print_count function. Also note that the #define for White */
           /* does not affect this, as it begins with a lower case w.    */
           /**************************************************************/
           printf("The value of the count field is: %d\n",white);

           ret_valu = white % 600;         /* ret_valu is remainder value*/
           return(ret_valu);               /* return ret_valu to caller  */
        }                                  /* end of print_count function*/

          *********************************************************************
          *                   Elementary C Programming                circle.c*
          *********************************************************************

          /******************************************************************/
          /*                         circle.c                               */
          /* circle.c: displays area, circumference, and volume of a sphere */
          /* when given the radius.                                         */
          /******************************************************************/

          #include <stdio.h>               /* include standard I/O header   */
          #include <math.h>                /* include math header for float */

          #define PI 3.14159               /* define PI = 3.14159           */

          float area, circumference, volume; /* define global float vrbls   */

          /******************************************************************/
          /* function prototypes                                            */
          /******************************************************************/
          float calculate_area(double radius);
          float calculate_circumference(double diameter);
          float calculate_volume(double radius);

          /******************************************************************/
          /* main function: initial entry point to the program. The radius  */
          /* of the circle of interest is expected to be typed on the       */
          /* command line following the program name.                       */
          /******************************************************************/

          main(int argc, char *argv[]) {   /* function header for main      */

            double radius;                 /* define radius                 */

            if(argc != 2) {                /* got two command line strings? */
              printf("Usage is: circle radius\n"); /* no, explain how to use*/
              exit(1);                     /* and terminate                 */
            }
            radius = atof(argv[1]);        /* convert 2nd string to double  */

            area = calculate_area(radius); /* compute circle area           */
            circumference = calculate_circumference(2 * radius); /* circumf.*/
            volume = calculate_volume(radius); /* and volume                */

            printf("The radius given is %f\n",radius); /* display radius    */
            printf("Area is %f\n",area);               /* area,             */
            printf("Circumference is %f\n",circumference); /* circumference,*/
            printf("Volume is %f\n",volume);           /* and volume        */
          }                                /* end of main function          */

          /******************************************************************/
          /* calculate_area computes the area of a circle, given the radius */
          /* and returns it to the caller as a float.                       */
          /******************************************************************/
          float calculate_area(double rad) { /* calculate_area function head*/

            float answer;                  /* define answer field           */

            answer = PI * rad * rad;       /* compute area of circle        */

            return(answer);                /* return area of circle         */
          }                                /* end calculate_area function   */

          /******************************************************************/
          /* calculate_circumference computes the circumference of a circle,*/
          /* given the diameter.                                            */
          /******************************************************************/

          float calculate_circumference(double diameter) { /* function hdr  */

            return(PI * diameter);         /* compute, return circumference */
          }                                /* end of calcualte_circumference*/

          /******************************************************************/
          /* calculate_volume computes the volume of a sphere, given its    */
          /* radius.                                                        */
          /******************************************************************/

          float calculate_volume(double r) { /* calculate_volume header     */

            float rcubed, vol;             /* define rcubed, vol            */

            rcubed = r * r * r;            /* compute rcubed                */
            vol = (4 * rcubed) / 3;        /* compute volume of sphere      */
            return(vol);                   /* return computed volume        */
          }                                /* end of calcualte_volume func  */

          *********************************************************************
          *                   Elementary C Programming              tempconv.c*
          *********************************************************************

         /***************************************************************/
         /*                         tempconv.c                          */
         /* tempconv.c converts a celcius temperature to the equivalent */
         /* fahrenheit temperature and displays both temperatures. The  */
         /* celcius temperatures are contained in a table within the    */
         /* program, and only positive temperatures produce a display.  */
         /***************************************************************/

         #include <stdio.h>              /* include standard I/O header */

         #define MAX_ENTRIES 3           /* define MAX_ENTRIES = 3      */

         float fahrenheit;               /* define fahrenheit           */
         float celcius[MAX_ENTRIES] = {-12.5, 32.0, 212.0}; /* celcius  */
         int i;                          /* define i                    */

         void compute_fahrenheit(void);  /* compute_fahrenheit prototype*/


         /***************************************************************/
         /* main function: initial entry point for program              */
         /***************************************************************/

         void main() {

           i = 0;                        /* set i to zero               */
           if(celcius[i] > 0.0) {        /* positive celcius value?     */
             compute_fahrenheit();          /* yes, go convert          */
             printf("%f celcius = %f fahrenheit\n",celcius[i],fahrenheit);
           }

           i = 1;                        /* set i to one                */
           if(celcius[i] > 0.0) {        /* positive celcius value?     */
             compute_fahrenheit();          /* yes, go convert          */
             printf("%f celcius = %f fahrenheit\n",celcius[i],fahrenheit);
           }

           i = 2;                        /* set i to two                */
           if(celcius[i] > 0.0) {        /* positive celcius value?     */
             compute_fahrenheit();          /* yes, go convert          */
             printf("%f celcius = %f fahrenheit\n",celcius[i],fahrenheit);
           }

         }                               /* end of main function        */

         /***************************************************************/
         /* compute_fahrenheit: compute the fahrenheit equivalent to a  */
         /* celcius temperature.                                        */
         /***************************************************************/

         void compute_fahrenheit(void) {  /* compute_fahrenheit header  */
           /*************************************************************/
           /* The calculation below computes the fahrenheit equivalent  */
           /* of a celcius temperature as:                              */
           /*    fahrenheit = (9/5 * celcius) + 32                      */
           /*************************************************************/
           fahrenheit = ((((celcius[i]) * 9) / 5) + 32);
         }                               /* end of compute_fahrenheit   */

          *********************************************************************
          *                   Elementary C Programming              loadstrg.c*
          *********************************************************************

          /******************************************************************/
          /*                        loadstrg.c                              */
          /* loadstrg.c reads up to 100 character strings from the keyboard */
          /* into memory, then displays them after the last one is entered. */
          /******************************************************************/

          #include <stdio.h>                 /* include standard I/O header */
          #include <stdlib.h>                /* include standard lib header */
          #include <string.h>                /* include string header       */

          /******************************************************************/
          /* main function: initial entry point to the program. reads the   */
          /* strings into storage areas obtained individually for each one. */
          /* After the last string (user presses enter with no data), all   */
          /* the stored strings are displayed.                              */
          /******************************************************************/

          main() {                           /* function header for main    */

            char *p[101];                    /* p is array of ptrs to chars */
            int i,l;                         /* define work subscripts      */
            char string[80];                 /* define work string          */

            for(i=0;i<100;i++) {             /* loop for up to 100 strings  */
              gets(string);                    /* read string into work area*/
              if(!(l = strlen(string))) break; /* if null string, break loop*/
              *(p+i) = (char *)malloc(l+1);    /* else get storage to hold  */
              strcpy(*(p+i),string);           /* and copy string to storage*/
            }

            *(p+i) = 0;                      /* 0 = end of array pointers   */

            for(i=0;i<100;i++) {             /* loop to display strings     */
              if(!p[i]) break;                  /* if end of table, break   */
              printf("%s\n",*(p+i));            /* else display the string  */
            }
          }                                  /* end of main function        */

          *********************************************************************
          *                   Elementary C Programming               struct9.c*
          *********************************************************************

          /******************************************************************/
          /*                       struct9.c                                */
          /* struct9.c is an exercise in the use of structures and          */
          /* unions.                                                        */
          /******************************************************************/

          #include <stdio.h>         /* include standard I/O header         */
          #include <stdlib.h>        /* include standard library header     */
          #include <string.h>        /* include string header               */

          /******************************************************************/
          /* main function: initial entry point to the program.             */
          /******************************************************************/

          void main() {              /* function header for main            */

            struct {                 /* define a structure                  */
              int emp_nbr;
              char last_name[12];
              char pay_grade;
              union {                   /* which contains a union           */
                struct {                   /* which includes a structure,   */
                  float hours_worked;
                  float hourly_rate;
                } hourly;
                float annual_salary;       /* and a float                   */
              } pay_data;                  /* union name is pay_data        */
            } emp[12];               /* structure array name is emp         */

            int i,a;                 /* define work integers                */
            char string[80];         /* define work string                  */

            for(i=0;i<12;i++) {      /* loop to clear out all emp elements  */
              emp[i].emp_nbr = 0;
              emp[i].last_name[0] = '\0';
              emp[i].pay_grade = 'h';
              emp[i].pay_data.hourly.hours_worked = 0.0;
              emp[i].pay_data.hourly.hourly_rate = 0.0;
            }

            for(i=0;i<12;i++) {      /* loop to build emp elements          */
              printf("\nEnter emp_nbr for #%d: ",i+1); /* ask for emp_nbr   */
              gets(string);                            /* read it to string */
              emp[i].emp_nbr = atoi(string);           /* and convert to int*/
              if(!(emp[i].emp_nbr)) break;  /* if emp_nbr is zero, break out*/
              printf("\nEnter last name: ");   /* ask for last name         */
              gets(string);                    /* read last name into string*/
              string[11] = '\0';               /* truncate to 11 byte name  */
              strcpy(emp[i].last_name,string); /* copy last name to element */
              printf("\nEnter pay grade, h if hourly, s if salaried: ");
              emp[i].pay_grade = getche();    /* read pay grade into element*/
              /**************************************************************/
              /* if pay_grade is for hourly, ask for, read in, convert, and */
              /* put into the element the hourly rate and hours worked.     */
              /**************************************************************/
              if(emp[i].pay_grade == 'h') {
                printf("\nEnter hourly rate, dollars and cents: ");
                gets(string);
                emp[i].pay_data.hourly.hourly_rate = atof(string);
                printf("\nEnter hours worked with 2 decimal places: ");
                gets(string);
                emp[i].pay_data.hourly.hours_worked = atof(string);
              }
              /**************************************************************/
              /* if pay_grade is not for hourly, assumption is that it is   */
              /* for salaried. Ask for, read in, convert, and move annual   */
              /* salary to the array element.                               */
              /**************************************************************/
              else {
                printf("\nEnter annual salary, dollars and cents: ");
                gets(string);
                emp[i].pay_data.annual_salary = atof(string);
              }
            }
          }                                   /* end of main function       */

          *********************************************************************
          *                   Elementary C Programming                menu10.c*
          *********************************************************************


          /******************************************************************/
          /*                         menu10.c                               */
          /* menu10.c displays a menu asking the user for an a, s, m, or d  */
          /* as a request to add, subtract, multiply, or divide two numbers.*/
          /* Four functions handle each type of request, each asking for the*/
          /* numbers, reading the numbers from the keyboard, performing the */
          /* keyboard, performing the arithmetic, and displaying results.   */
          /******************************************************************/

                               /**********************/
          /********************* header file includes ***********************/
                               /**********************/
          #include <stdio.h>
          #include <math.h>

                               /**********************/
          /*********************       defines        ***********************/
                               /**********************/
          #define CLEAR "\x1B[2J"

                               /**********************/
          /*********************  global data fields  ***********************/
                               /**********************/
          float num1,num2;
          float sum,difference,product,quotient,remainder;
          char string[80];
          unsigned char c;

                               /**********************/
          /********************* function prototypes  ***********************/
                               /**********************/
          void add_numbers(void);
          void subtract_numbers(void);
          void multiply_numbers(void);
          void divide_numbers(void);

                                /*********************/
          /*********************     main function    ***********************/
          /*** display menu, read request and call appropriate function *****/
             /**********************************************************/
          void main() {
            c = ' ';
            while((c != 'q') & (c != 'Q')) {                /* display menu */

              printf(CLEAR);
              printf("\n\n\n\n        A = add numbers");
              printf("\n\n        S = subtract numbers");
              printf("\n\n        M = multiply numbers");
              printf("\n\n        D = divide numbers");
              printf("\n\n        Q = quit");
              printf("\n\n            ");

              switch(c=getch()) {                           /* read request */
                case 'q':
                case 'Q':
                  break;
                case 'a':
                case 'A':
                  add_numbers();
                  break;
                case 's':
                case 'S':
                  subtract_numbers();
                  break;
                case 'm':
                case 'M':
                  multiply_numbers();
                  break;
                case 'd':
                case 'D':
                  divide_numbers();
                  break;
              }
            }
          }

                                /**********************/
          /*********************  add_numbers function **********************/
          /************* add two numbers and display the sum ****************/
                       /*************************************/
          void add_numbers() {
            printf(CLEAR);
            printf("\n\n\n\n        Enter First number: ");
            gets( string);
            num1 = atof(string);
            printf("\n\n\n\n        Enter Second number: ");
            gets( string);
            num2 = atof(string);
            sum = num1 + num2;
            printf("\n\n\n        %f + %f = %f",num1,num2,sum);
            printf("\n\n        Press any key to continue");
            getch();
          }

                            /****************************/
          /******************  subtract_numbers function ********************/
          /******** subtract two numbers and display the difference *********/
                  /*************************************************/
          /* subtract two numbers and display the difference */
          void subtract_numbers(void) {
            printf(CLEAR);
            printf("\n\n\n\n        Enter First number: ");
            gets( string);
            num1 = atof(string);
            printf("\n\n\n\n        Enter Second number: ");
            gets( string);
            num2 = atof(string);
            difference = num1 - num2;
            printf("\n\n\n        %f - %f = %f",num1,num2,difference);
            printf("\n\n        Press any key to continue");
            getch();
          }

                             /***************************/
          /******************* multiply_numbers function ********************/
          /******** multiply two numbers and display the product ************/
                  /**********************************************/
          /* multiply two numbers and display the product */
          void multiply_numbers(void) {

            printf(CLEAR);
            printf("\n\n\n\n        Enter First number: ");
            gets( string);
            num1 = atof(string);
            printf("\n\n\n\n        Enter Second number: ");
            gets( string);
            num2 = atof(string);
            product = num1 * num2;
            printf("\n\n\n        %f * %f = %f",num1,num2,product);
            printf("\n\n        Press any key to continue");
            getch();
          }

                                /**********************/
          /********************  divide_numbers function ********************/
          /********* divide two numbers and display the quotient ************/
                   /*********************************************/
          /* divide two numbers and display the quotient and remainder */
          void divide_numbers(void) {
            printf(CLEAR);
            printf("\n\n\n\n        Enter First number: ");
            gets( string);
            num1 = atof(string);
            printf("\n\n\n\n        Enter Second number: ");
            gets( string);
            num2 = atof(string);
            quotient = num1 / num2;
            printf("\n\n\n        %f / %f = %f",num1,num2,quotient);
            printf("\n\n        Press any key to continue");
            getch();
          }

          *********************************************************************
          *                   Elementary C Programming               dumphex.c*
          *********************************************************************

        /******************************************************************/
        /*                         dumphex.c                              */
        /* dumphex.c displays and optionally prints the content of a file */
        /* in hex and character, 16-bytes per line. user specifies the    */
        /* name of the file to dump on the command line.                  */
        /******************************************************************/

        #include <stdio.h>               /* include standard I/O header   */
        #include <stdlib.h>              /* include standard lib header   */

        /******************************************************************/
        /* main function: on entry the number of command line arguments   */
        /* is available in argc, while argv is an array of strings, which */
        /* contains the command line arguemnts. The first command line    */
        /* string ([0]) is always the program name.                       */
        /******************************************************************/

        void main(int argc, char *argv[]) {

        /******************************************************************/
        /*               define global work fields                        */
        /******************************************************************/
        char prntlin[68];                     /* print line */
        unsigned char ch;                     /* character work field */
        unsigned char prtsw='\0';             /* print switch */
        unsigned int j,l,row=0;               /* work fields */
        int i,k;                              /* work fields */
        unsigned long bytno=0,tot=0;          /* work fields */

        /******************************************************************/
        /*               function prototypes                              */
        /******************************************************************/
        void atox(unsigned char, char[], char[]);  /* function prototype */

        /******************************************************************/
        /*               FILE pointer definitions                         */
        /******************************************************************/
        FILE *infil,*outfil;                  /* FILE pointers */

        /******************************************************************/
        /*        end of data definitions, begin processing               */
        /******************************************************************/

        prntlin[0]='\n';                      /* put newline in print line */
        prntlin[67]='\0';                     /* insure valid string */

        /*******************************************************************/
        /* If command line has two strings (1="dumphex", 2=filename), open */
        /* the input file, otherwise display the proper syntax to use and  */
        /* terminate the program.                                          */
        /*******************************************************************/

        if(argc!=2) {
            printf("\nSYNTAX: dumphex [d:][\path\]filename[.ext]");
            exit(1);
        }
        if((infil=fopen(argv[1],"rb"))==NULL) {
            printf("\nCan't open the input file, %s",argv[1]);
            exit(1);
        }

        /*******************************************************************/
        /* Ask user if the file dump is to be printed or only displayed on */
        /* the screen. If print is requested, set the print switch and open*/
        /* the print file and print a header line.                         */
        /*******************************************************************/

        printf("\nDo you want to print the file (y/n): ");
        while((prtsw!='y')&&(prtsw!='n'))
            prtsw=getche();
        if(prtsw=='n')
            prtsw='\0';
        if(prtsw)
            if((outfil=fopen("prn","w"))==NULL) {
                printf("\nCan't open the printer file.");
                exit(0);
            }
            else {
                fputs("\n     ***** Hex/Character Dump of: ",outfil);
                fputs(argv[1],outfil);
                fputs(" *****\n",outfil);
            }
        /*******************************************************************/
        /* Build a line of print containing the offset from the beginning  */
        /* of the file, 8 groups of 2 hex bytes each, and the printable    */
        /* ASCII characters for them.                                      */
        /*******************************************************************/
        do {
            for(i=1;i<67;i++)        /* pre-clear the print */
            prntlin[i]=' ';              /* line to blanks */
            /***************************************************************/
            /* Calculate and print the file offset in hex at left of line. */
            /***************************************************************/
            ch=bytno/65536;
            atox(ch,&prntlin[1],&prntlin[2]);
            ch=(bytno%65536)/256;
            atox(ch,&prntlin[3],&prntlin[4]);
            ch=bytno%256;
            atox(ch,&prntlin[5],&prntlin[6]);
            bytno+=16;
            /***************************************************************/
            /* Read characters from the file and copy them into the        */
            /* printable character portion of the print line (positions    */
            /* 52-67).                                                     */
            /***************************************************************/
            i=51;
            while((i<67)&&(k=getc(infil))!=EOF) {
                prntlin[i++]=k;
                tot+=1;
            }
            /***************************************************************/
            /* Convert the characters in print line positions 52-67 to hex */
            /* (2 hex digits per character) and use the hex digits to make */
            /* eight groups of 2-bytes (4 print positions). Single spaces  */
            /* are placed between each group of 2 bytes with a double space*/
            /* in the center.                                              */
            /***************************************************************/
            for(j=51,l=9;j<i;j++) {
                atox(prntlin[j],&prntlin[l],&prntlin[l+1]);
                l+=2;
                if(l==13||l==18||l==23||l==34||l==39||l==44)
                    l+=1;
                if(l==28)
                    l+=2;
            }
            /***************************************************************/
            /* Scan the character area of the print line (positions 52-67) */
            /* and replace non-printable characters with periods.          */
            /***************************************************************/
            for(j=51;j<i;j++)
                if((prntlin[j]<' ')||(prntlin[j]>'z'))
                    prntlin[j]='.';
            /***************************************************************/
            /* Display the line on the screen. If the print switch is on,  */
            /* print it, too. Check to see if we are at the bottom of the  */
            /* screen. If so, ask the user whether to continue or to quit. */
            /***************************************************************/
            printf("%s",prntlin);
            if(prtsw)
                fputs(prntlin,outfil);
            row += 1;                       /* increment row counter */
            if(row >= 22) {                 /* if end of screen: */
                row = 0;                        /* reset row counter */
                printf("\nEnter Q to quit or press ENTER to continue: ");
                ch = getchar();                 /* get response */
                if((ch == 'q') || (ch == 'Q'))
                    exit(1);                /* quit if Q entered */
            }
        }
        while(k!=EOF);                      /* end of d... while */

        /*******************************************************************/
        /* End of file to be dumped. Print totals, close files, and        */
        /* terminate normally.                                             */
        /*******************************************************************/

        printf("\n\nTotal bytes in file = %d.\n",tot);
        if(prtsw) {
            fputs("\n\nTotal bytes in file = ",outfil);
            itoa(tot,prntlin,10);
            fputs(prntlin,outfil);
            fputs("\n\n\n",outfil);
            fclose(outfil);
        }
        fclose(infil);
        }

        /******************************************************************/
        /* function to convert a character to two printable hex digits    */
        /******************************************************************/

        void atox(unsigned char ch,  char *hi, char *lo) {

            char hextbl[]="0123456789ABCDEF";
            *hi=hextbl[ch/16];      /* convert high-order hex digit */
            *lo=hextbl[ch%16];      /* convert low-order hex digit */
        }

          *********************************************************************
          *                   Elementary C Programming              skeleton.c*
          *********************************************************************

         /*******************************************************************/
         /*                     skeleton.c                                  */
         /*                                                                 */
         /* generic c program that includes an input file, output file,     */
         /* print file, and common processing functions:                    */
         /*  main       = executive routine: overall program control        */
         /*  mainline   = mainline processing control                       */
         /*  initialize = open files, set up headers and call headings      */
         /*  readrec    = read input file records and count them            */
         /*  writerec   = write output file records and count them          */
         /*  printline  = print detail, clear print line, call headings     */
         /*  headings   = print heading lines for new page                  */
         /*  edit       = edit numbers with commas, decimal points, etc     */
         /*  terminate  = close files, print totals, stop execution         */
         /*                                                                 */
         /*                                                                 */
         /* Author R Thornton September 1993                                */
         /*******************************************************************/

         #include <stdio.h>
         #include <stdlib.h>
         #include <time.h>

         void initialize(int argc, char *argv[]);  /* initialization func   */
         void mainline(void);                  /* mainline function         */
         void terminate(void);                 /* termination function      */
         void readrec(void);                   /* read next input file rec  */
         void writerec(void);                  /* write record to out file  */
         void printline(void);                 /* print a line to rept file */
         int edit(char output[], char pattern[], char number[]); /* edit fnc*/
         void headings(void);                  /* print report heading      */

         FILE *infile, *outfile, *prtfile;     /* file handle pointers      */

         char innam[81];                       /* input file name           */
         char outnam[81];                      /* output file name          */
         char prtnam[81] = "prn";              /* print file name           */

         char prtline[135];                    /* print line buffer         */
         char inrecord[256];                   /* input file record area    */
         char outrecord[256];                  /* output file record area   */

         char *h1ptr;                          /* heading line 1 pointer    */
         struct {                              /* first heading line        */
           char hdr_skip;                        /* form feed               */
           char hdr_date[10];                    /* report date             */
           char ctr1[45];                        /* centering blanks        */
           char title_line[21];                  /* centered report title   */
           char ctr2[45];                        /* centering blanks        */
           char page_lit[5];                     /* page literal            */
           char page_nbr[6];                     /* page number             */
           char newline;                         /* newline character       */
           char null_byte;                       /* terminating null        */
         } header1;

         int i;                                /* general purpose int       */
         char number[32];                      /* ascii numbers for edit()  */
         int morerecs = -1;                    /* input end-of-file switch  */
         long incount = 0;                     /* input record counter      */
         long outcount = 0;                    /* output record counter     */
         int linecnt = 0;                      /* print line counter        */
         int pagecnt = 0;                      /* print page counter        */
         struct tm *t;                         /* pointer to time structure */
         time_t seconds;                       /* current timer value       */

         /*******************************************************************/
         /* executive routine: overall program control                      */
         /*******************************************************************/
         void main(int argc, char *argv[]) {
            initialize(argc, argv);            /* open files                */
            while(morerecs)                    /* perform mainline until    */
               mainline();                     /* no more records           */
            terminate();                       /* close files               */
            exit(0);                           /* quit                      */
         }
         /*******************************************************************/
         /* mainline function: process input file until no more records.    */
         /*******************************************************************/
         void mainline(void) {
            strcpy(prtline,inrecord);          /* move input record to print*/
            printline();                       /* and print it              */
            strcpy(outrecord,inrecord);       /* move input record to output*/
            writerec();                        /* write an output record    */
            readrec();                         /* read next input record    */
         }
         /*******************************************************************/
         /* initialization: open files, read first input record.            */
         /*******************************************************************/
         void initialize(int argc, char *argv[]) {
           if(argc == 3) {                     /* if two filenames given:   */
             strcpy(&innam,argv[1]);             /* 1st is input filename   */
             strcpy(&outnam,argv[2]);            /* 2nd is output filename  */
           }
           else
             if(argc == 4) {                   /* if three filenames given: */
               strcpy(&innam,argv[1]);           /* 1st is input filename   */
               strcpy(&outnam,argv[2]);          /* 2nd is output filename  */
               strcpy(&prtnam,argv[3]);          /* 3rd is print file name  */
             }
             else {                            /* if neither 2 nor 3 given: */
               printf("\nEnter input file spec: "); /* ask for input filenam*/
               gets(innam);                         /* and read it in       */
               printf("\nEnter output file spec: "); /* ask for output filen*/
               gets(outnam);                        /* and read it in       */
               printf("\nEnter output file spec (or prn): "); /* ask for prt*/
               gets(prtnam);                        /* and read it in       */
             }
           if((infile=fopen(innam,"rb")) == NULL) { /* open input           */
             printf("Can't open file %s.",innam);   /* open failed message  */
             exit(1);                               /* terminate            */
           }
           if((outfile=fopen(outnam,"wb")) == NULL) { /* open output        */
             printf("Can't open file %s.",outnam);
             exit(1);
           }
           if((prtfile=fopen(prtnam,"w"))==NULL) { /* open print file       */
             printf("\nCan't open the printer file."); /* open failed msg   */
             exit(1);                                  /* terminate         */
           }
           h1ptr = (char *)&header1;               /* point to header1 line */
           for(i=0;i<133;i++)                      /* clear header line     */
             h1ptr[i] = ' ';                         /* to all spaces       */
           header1.hdr_skip = '\f';              /* form feed to header line*/
           memcpy(header1.title_line,"SKELETON REPORT TITLE",21); /* copy hd*/
           timezone = 5 * 60 * 60;               /* set local time for e.s.t*/
           daylight = -1;                        /* indicate daylit sav time*/
           time(&seconds);                       /* time in secs            */
           t = localtime(&seconds);              /* local time to tm struct */
           sprintf(header1.hdr_date,"%2d\/%2d\/%2d",
                                       t->tm_mon,t->tm_mday,t->tm_year);
           header1.hdr_date[8] = ' ';            /* clear terminating null  */
           memcpy(header1.page_lit,"PAGE ",5);   /* PAGE literal to header  */
           prtline[133] = '\0';                 /* terminal null to prt line*/
           headings();                           /* write first heading     */
           readrec();                        /* read first input file record*/
         }
         /*******************************************************************/
         /* read next input file record. at end of file, set morerecs switch*/
         /*******************************************************************/
         void readrec() {
           if(fgets(inrecord,255,infile) == NULL) /* read input until eof   */
             morerecs = 0;                      /* set switch at end of file*/
           if(morerecs)                           /* if not at end of file  */
           incount++;                               /* add 1 to records read*/
         }
         /*******************************************************************/
         /* write a record to the output file                               */
         /*******************************************************************/
         void writerec() {
           fputs(outrecord,outfile);             /* write output record     */
           outcount++;                           /* add 1 to records written*/
         }
         /*******************************************************************/
         /* write a line to the printer                                     */
         /*******************************************************************/
         void printline() {
           prtline[133] = '\n';            /* terminal newline to print line*/
           prtline[134] = '\0';            /* terminal null to print line   */
           fputs(prtline,prtfile);         /* write print line              */
           linecnt++;                      /* add 1 to line counter         */
           if(linecnt > 56)                /* if end of page                */
             headings();                     /* write heading lines         */
           else                            /* otherwise                     */
             for(i=0;i<133;i++)              /* clear print line            */
               prtline[i] = ' ';               /* to all spaces             */
         }
         /*******************************************************************/
         /* write a report heading                                          */
         /*******************************************************************/
         void headings() {
           linecnt = 0;                      /* clear line counter          */
           pagecnt++;                        /* add 1 to page counter       */
           sprintf(number,"%d",pagecnt);     /* convert to printable nbr    */
           edit(header1.page_nbr,"zz,zz9",number); /* page nbr to hdr line  */
           header1.newline = '\n';           /* terminal newline to hdr     */
           header1.null_byte = '\0';         /* terminal null to header     */
           fputs((char *)&header1,prtfile);  /* write header line           */
           for(i=0;i<133;i++)                /* clear print line            */
             prtline[i] = ' ';                 /* to all spaces             */
           prtline[133] = '\n';              /* ending newline to print line*/
           prtline[134] = '\0';              /* terminal null to print line */
           fputs(prtline,prtfile);           /* blank line after heading    */
         }

         /*******************************************************************/
         /* The edit function provides numeric report editing, including    */
         /* leading zero suppression, check protection, floating $, leading */
         /* or trailing minus sign, insertion of commas, decimal points and */
         /* other non-numeric fields. The first parameter is the address of */
         /* the edited output, whose size will be the same as the pattern.  */
         /* The second parameter is the editing pattern which must be a true*/
         /* null-terminated string containing the edit pattern. The third   */
         /* is the number to be edited, a null-terminated string containing */
         /* only digits 0-9 except the first position, which is a -, if the */
         /* number is negative. The pattern may be up to 64 characters, and */
         /* the number to be edited may contain up to 32 characters. The    */
         /* number may not contain more significant digits than there are   */
         /* digit select characters in the pattern. If there are more digits*/
         /* selected by the pattern than there are in the number, leading   */
         /* zeros will be assumed. In the pattern, the first character may  */
         /* be:      $ (floating dollar sign)                               */
         /*          * (check protection)                                   */
         /*          - (floating minus sign)                                */
         /* The body of the edit pattern will be composed of digit select   */
         /* characters (z and 9) and other characters, handled as follows:  */
         /*          z (zero suppression output is a blank in this position */
         /*             until significance is set by receipt of a significan*/
         /*             digit or a 9 in the pattern. After significance is  */
         /*             set, output is a digit from the number.)            */
         /*          9 (output is a digit from the number and significance  */
         /*             is set, even if the digit is a leading zero.)       */
         /*        other characters in the pattern will be output as-is afte*/
         /*             significance is set, but will be output as blanks   */
         /*             before significance is set.                         */
         /* Characters in the pattern following the last digit select will  */
         /* be output as-is if the number is negative, otherwise output will*/
         /* be blanks for these pattern positions.                          */
         /*                                                                 */
         /* When * check protection is selected, output will be *, rather   */
         /* than blanks as mentioned above.                                 */
         /*                                                                 */
         /* An integer is returned to indicate success or errors:           */
         /*                 0 = successful edit                             */
         /*                 1 = pattern too long (over 64 characters)       */
         /*                 2 = too many digits selected (over 32)          */
         /*                 3 = no output digits selected in pattern        */
         /*                 4 = number contains non-numeric data            */
         /*                 5 = number has more digits than the pattern     */
         /*                                                                 */
         /* Examples:                            nbr=             outf=     */
         /*    err=edit(outf,"zz,zz9.99-",nbr);  0                     0.00 */
         /*                                      123                   1.23 */
         /*                                      562983            5,629.83 */
         /*                                      -4675                46.75-*/
         /*    err=edit(outf,"$,$$$.$$",nbr);    0                          */
         /*                                      123                  $1.23 */
         /*                                      562983           $5,629.83 */
         /*                                      -4675               $46.75 */
         /*    err=edit(outf,"***.**",nbr);      0                          */
         /*                                      123                 **1.23 */
         /*                                      562983   err = 5           */
         /*                                      -4675               *46.75 */
         /*    err=edit(outf,"--,--9.99",nbr);   0                     0.00 */
         /*                                      123                   1.23 */
         /*                                      562983            5,629.83 */
         /*                                      -46.75              -46.75 */
         /*                                                                 */
         /* Author R Thornton April 1989                                    */
         /*******************************************************************/
         /**/
         int edit(char output[], char pattern[], char number[]) {
           char float_val = ' ';
           char fill_val = ' ';
           char sign_val = ' ';
           int signif = 0;
           int psize = 0;
           int pdig = 0;
           int plast = 0;
           int ndig = 0;
           char nbr[33];
           char ch= ' ';
           int po=0;
           int n=0;

         /*******************************************************************/
         /* examine pattern: set up float and fill, count size and digits   */
         /*******************************************************************/
           if(((ch=pattern[0]) == '$') || (ch == '*') || (ch == '-'))
             float_val = ch;
           if(ch == '*')
             fill_val = '*';
           while((ch=pattern[po]) != '\0') {
            if((ch == 'z') || (ch == '9')) {
               pdig++;
               plast = po;
             }
             psize++;
             po++;
           }
           if(psize > 63)
             return(1);
           if(pdig > 32)
             return(2);
           if(!pdig)
             return(3);

         /*******************************************************************/
         /* examine number: set up sign, count digits, check numeric.       */
         /* set error if more digits than pattern, move right justified     */
         /*******************************************************************/
           if(number[0] == '-') {
             sign_val = '-';
             n = 1;
           }
           while((ch=number[n]) != '\0') {
             if((ch < '0') || (ch > '9'))
               return(4);
             ndig++;
             n++;
           }
           if(ndig > pdig)
             return(5);
           for(po=0;po<(pdig-ndig);po++)
             nbr[po] = '0';
           if(sign_val == ' ')
             n = 0;
           else
             n=1;
           for(;po<pdig;po++,n++)
             nbr[po] = number[n];

         /********************************************************************/
         /* scan across the pattern, setting the corresponding output        */
         /* byte from pattern, fill, or amt depending on the pattern         */
         /* character and state of significance.                             */
         /********************************************************************/
           if(float_val != ' ') {
             output[0] = ' ';
             po = 1;
           }
           else
             po = 0;
           n = 0;
           while((po <= plast)) {
             ch = pattern[po];
             if(ch == 'z') {
               if(signif) {
                 output[po] = nbr[n];
                 n++;
               }
               else {
                 if(nbr[n] == '0') {
                   output[po] = fill_val;
                   n++;
                 }
                 else {
                   output[po] = nbr[n];
                   signif = -1;
                   n++;
                   if(float_val == ' ')
                     ;
                   else
                     if((float_val == '$') || (sign_val == '-'))
                       output[po-1] = float_val;
                 }
               }
             }
             else if(ch == '9') {
               output[po] = nbr[n];
               if(!signif) {
                 signif = -1;
                 if(float_val == ' ')
                   ;
                 else
                   if((float_val == '$') || (sign_val == '-'))
                     output[po-1] = float_val;
               }
               n++;
             }
             else {
               if(signif)
                 output[po] = pattern[po];
               else
                 output[po] = fill_val;
             }
             po++;
           }
           while((ch=pattern[po]) != '\0') {
             if(sign_val == ' ')
               output[po++] = fill_val;
             else
               output[po++] = pattern[po];
           }
           return(0);
         }

         /*******************************************************************/
         /* termination: close files                                        */
         /*******************************************************************/
         void terminate() {
           sprintf(number,"%ld",incount);    /* convert input count to ascii*/
           edit(prtline, "zz,zzz,zz9", number); /* edit number to prtline   */
           strcpy(prtline+10," input records read"); /* message to prt      */
           printline();                      /* print count                 */
           sprintf(number,"%ld",outcount);   /* convert input count to ascii*/
           edit(prtline, "zz,zzz,zz9", number); /* edit number to prtline   */
           strcpy(prtline+10," output records written"); /* message to prt  */
           printline();                      /* print count                 */
           fclose(infile);                   /* close input file            */
           fclose(outfile);                  /* close output file           */
           fclose(prtfile);                  /* close print file            */
         }

          *********************************************************************
          *                   Elementary C Programming               binsrch.c*
          *********************************************************************

          /****************************************************************/
          /*          binsrch.c: a binary file search function            */
          /* caller supplies:                                             */
          /*    (1) a pointer to the FILE to be searched (must be OPEN).  */
          /*    (2) a pointer to the key argument used for the search.    */
          /*    (3) length of each record in the file (int).              */
          /*    (4) length of the key in the records (int).               */
          /*    (5) relative position of the key in the record (int, 0+). */
          /*    (6) a pointer to the callers record return area.          */
          /* function returns:                                            */
          /*    (1) an int whose value is -1 if the record is found or    */
          /*        0 of it is not found.                                 */
          /*    (2) the record found, if the search was successful.       */
          /*                                                              */
          /* Author R Thornton, October, 1993                             */
          /****************************************************************/
          #include <stdio.h>

          int binsrch( FILE *rf, char *arg_key, int recdleng, int keyleng,
                       int keyloc, char *record ) {

            long int file_size;             /* file length in bytes */
            long int max_slots;             /* number records in file */
            long int curr_slot  = 0;        /* current record slot number */
            long int curr_offset = 0;       /* current offset increment */
            long int file_offset;           /* computed file offset */
            int      compare = 0;           /* current compare indicator */
            int      result = 0;            /* result indicator */

            result = 0;                     /* set up for not found */
            if(fseek(rf,0,SEEK_END) != 0)   /* set file pointer to end of file *
/
              return(result);               /* terminate if error */
            if((file_size = ftell(rf)) == -1L) /* get file size in bytes */
              return(result);               /* terminate if error */
            max_slots = file_size / recdleng;  /* compute number records in file
 */
            curr_slot = 0;                 /* set initial slot number */
            curr_offset = max_slots - 1;   /* set initial offset increment */
            compare = -1;                  /* set compare for low */
            while(curr_offset != 1) {
              curr_offset ++;              /* add 1 to insure rounding high */
              curr_offset /= 2;            /* offset / 2 (rounded high */
              if(compare < 0) {            /* if last key read was low */
                curr_slot += curr_offset;     /* add offset increment */
                if(curr_slot >= max_slots) {  /* if result past end of file */
                  compare = 1;                   /* set compare to high */
                  continue;                      /* and continue to while */
                }
                else ;
              }
              else {                       /* if last key read was high */
                curr_slot -= curr_offset;     /* subtract offset increment */
                if(curr_slot < 0) {           /* if result prior to 1st slot */
                  compare = -1;                  /* set compare to low */
                  continue;                      /* and continue to while */
                }
                else ;
              }
              file_offset = curr_slot * recdleng;   /* compute file offset */
              if((fseek(rf,file_offset,0)) != 0)    /* position in file */
                break;                              /* terminate if error */
              fread(record,recdleng,1,rf);          /* read the record */
              if((compare=memcmp(record+keyloc,arg_key,keyleng)) == 0) { /* foun
d? */
                result = -1;
                break;                                          /* yes, quit */
              }
            }
            return(result);
          }

          *********************************************************************
          *                   Elementary C Programming              genldat2.c*
          *********************************************************************

          /*****************************************************************/
          /*                         genldat2.c                            */
          /* This function provides the caller with a table of information */
          /* concerning a specified date. The caller places a date in one  */
          /* of the Julian or Gregorian fields of the DATEGENL structure   */
          /* and an indicator of the type date sent in the datyp field, and*/
          /* invokes genldat2(), which fills in all the remaining fields in*/
          /* the DATEGENL structure. A pointer to DATEGENL is passed to    */
          /* this function by the caller.                                  */
          /*****************************************************************/

          #include <string.h>

          struct DATEGENL {
            enum {
              julian_yyyyddd_sent = 'j',
              gregorian_mmddyyyy_sent = 'g',
              gregorian_yyyymmdd_sent = 'y'
            } datyp;                          /* date supplied type        */
            enum {
              successful_conversion = ' ',
              error_in_data_supplied = 'e',
            } daterr;                         /* result indicator          */
            enum {
              Monday = '1',
              Tuesday = '2',
              Wednesday = '3',
              Thursday = '4',
              Friday = '5',
              Saturday = '6',
              Sunday = '7'
            } daywk;                          /* day of week indicator     */
            enum {
              not_a_holiday = ' ',
              New_Years_Day = '1',
              Christmas_Eve = '2',
              Good_Friday = '3',
              Memorial_Day = '4',
              Independence_Day = '5',
              Labor_Day = '6',
              Thanksgiving_Day = '7',
              Friday_After_Thanksgiving = '8',
              Christmas_Day = '9',
            } holiday;                        /* holiday indicator         */
            enum {
              not_leap_year = '0',
              leap_year = '1',
            } yeartyp;                        /* year type                 */
            char juldate[8];                     /* julian date yyyyddd    */
            char gregmdy[9];                     /* gregorian date mmddyyyy*/
            char gregymd[9];                     /* gregorian date yyyymmdd*/
            char litdate[19];                    /* literal date, eg:      */
                                                    /* May 9, 2002         */
            char julslash[9];                    /* julian date yy/ddd     */
            char grgslash[11];                   /* gregorian:  mm/dd/yyyy */
            char daylit[10];                     /* literal day of week eg:*/
                                                    /* Sunday              */
            char monthlit[10];                   /* literal month, eg: July*/
          };

          /*****************************************************************/
          /* yeardata contains data about this year: day of week for       */
          /* January 1st, leap year indicator, and holiday dates. Format:  */
          /*   byte1: day of week for Jan 1: 0=Monday - 6=Sunday           */
          /*   byte2: leap year indicator: 1 = leap year else 0            */
          /*   remainder: holiday fields of 5 bytes each. Format of each:  */
          /*          byte1: holiday type indicator (same as p->holiday)   */
          /*          bytes 2-5: MMDD date of the holiday                  */
          /* tblukup() locates data for this year and initializes this area*/
          /*****************************************************************/
          struct year_entry2 {
            char jan1_day;
            char leap_year_ind;
            struct {
              char holiday_type;
              char holiday_mmdd[5];
            } holiday_table[9];
          } yeardata;

          /*****************************************************************/
          /* function prototypes                                           */
          /*****************************************************************/
          void genldat2(struct DATEGENL *p);
          void julian_sent(struct DATEGENL *p);
          void gregorian_sent(struct DATEGENL *p);
          void datcomn(struct DATEGENL *p);
          void tblukup(struct DATEGENL *p);


          void genldat2(struct DATEGENL *p) {

            p->daterr = ' ';                       /* clear error indicator*/
            p->holiday = ' ';                       /* clear holiday indic */
            if(p->datyp == julian_yyyyddd_sent) {   /* julian date sent    */
              julian_sent(p);
              return;
            }
            else
              if((p->datyp == gregorian_mmddyyyy_sent) || /* gregorian sent*/
                  (p->datyp == gregorian_yyyymmdd_sent)) {
                gregorian_sent(p);
                return;
              }
              else {                        /* invalid date type specified */
                p->daterr = 'e';
                return;
              }
          }                                       /* end function genldat2 */

          /*****************************************************************/
          /* The gregcvrt[] table is used in converting between julian and */
          /* gregorian dates. It contains the day numbers corresponding to */
          /* the first day of each month. The gregcv1 table contains leap  */
          /* year values, while the gregcv0 table contains normal year     */
          /* values. the appropriate values are moved to gregcvrt[] by the */
          /* tblukup() function.                                           */
          /*****************************************************************/
          int gregcvrt[13];

          static int gregcv0[13] = {0, 31, 59, 90, 120, 151, 181, 212, 243,
                                    273, 304, 334, 999};

          static int gregcv1[13] = {0, 31, 60, 91, 121, 152, 182, 213, 244,
                                    274, 305, 335, 999};

          /*****************************************************************/
          /* julian_sent(): main function to handle julian date sent       */
          /*****************************************************************/
          void julian_sent(struct DATEGENL *p) {
            int i, julday;

            /* ----- julian date must be 7 bytes long ---------------------*/
            if(strlen(p->juldate) != 7) {
              p->daterr = 'e';
              return;
            }

            /* ----- century must be 19 or 20 -----------------------------*/
            if(((p->juldate[0] == '1') && (p->juldate[1] == '9')) ||
                ((p->juldate[0] == '2') && (p->juldate[1] == '0')))
               ;
            else {
              p->daterr = 'e';
              return;
            }

            /* --- julian date must consist entirely of decimal digits --- */
            for(i=2; i<7; i++)
              if((p->juldate[i] < '0') || (p->juldate[i] > '9')) {
                p->daterr = 'e';
                return;
            }

            /* ----- move julian year to gregorian year fields ----------- */
            for(i = 0; i < 4; i++) {
              p->gregmdy[i+4] = p->juldate[i];  /* year to greg mdy        */
              p->gregymd[i] = p->juldate[i];    /* year to greg ymd        */
            }

            /* ----- go get year table data ------------------------------ */
            tblukup(p);

            /* ----- julian day must be 1 - 366 -------------------------- */
            julday = atoi(&p->juldate[4]);      /*get julian day to integer*/
            if((julday > 0 ) && (julday < 366))
              ;
            else
              if((julday == 366) && (p->yeartyp == leap_year))
                ;
              else {
                p->daterr = 'e';
                return;
              }

            /* ----- build gregorian mmdd fields ------------------------- */
            i = 0;
            while(gregcvrt[i] < julday)       /* look up  for month and day*/
            i++;
            julday -= gregcvrt[i - 1];     /* deduct days to start of month*/
            p->gregymd[4] = (i / 10) | '0';        /* build gregorian month*/
            p->gregymd[5] = (i % 10) | '0';
            p->gregymd[6] = (julday / 10) | '0';  /* build greg day of mnth*/
            p->gregymd[7] = (julday % 10) | '0';
            memcpy(&p->gregmdy[0], &p->gregymd[4], 4);    /*copy month, day*/
            datcomn(p);                           /* finish processing date*/
            return;
          }                                    /* end function julian_sent */

          /*****************************************************************/
          /* The grgvldy[] table contains the number of days in each month.*/
          /* It is used in validating the gregorian date.                  */
          /*****************************************************************/
          static int grgvldy[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31,
                                    30, 31};

          /*****************************************************************/
          /* gregorian_sent(): main function to handle gregorian date sent.*/
          /*****************************************************************/
          void gregorian_sent(struct DATEGENL *p) {

            int i, day, mth;

            /* ----- make both gregorian dates the same date ------------- */
            if(p->datyp == gregorian_mmddyyyy_sent) {
              memcpy(&p->gregymd[0], &p->gregmdy[4], 4); /* copy year      */
              memcpy(&p->gregymd[4], &p->gregmdy[0], 4); /* copy mmdd      */
              p->gregymd[8] = '\0';
            }
            else {
              memcpy(&p->gregmdy[0], &p->gregymd[4], 4); /* copy mmdd      */
              memcpy(&p->gregmdy[4], &p->gregymd[0], 4); /* copy year      */
              p->gregmdy[8] = '\0';
            }

            /* ----- gregorian date must be 8 bytes long ----------------- */
            if((strlen(p->gregmdy) == 8) && (strlen(p->gregymd) == 8))
              ;
            else {
              p->daterr = 'e';
              return;
            }

            /* ----- century must be 19 or 20 ---------------------------- */
            if(((p->gregmdy[4] == '1') && (p->gregmdy[5] == '9')) ||
                  ((p->gregmdy[4] == '2') && (p->gregmdy[5] == '0')))
              ;
            else {
              p->daterr = 'e';
              return;
            }

            /* ----- all 8 bytes must be decimal digits ------------------ */
            for(i=0; i<8; i++)
              if((p->gregmdy[i] < '0') || (p->gregmdy[i] > '9')) {
                p->daterr = 'e';
                return;
              }

            /* ----- day must be > 0 ------------------------------------- */
            day = ((p->gregmdy[2] - '0') * 10) + (p->gregmdy[3] - '0');
            if(day)
              ;
            else {
              p->daterr = 'e';
              return;
            }

            /* ----- month must be 01 to 12 ------------------------------ */
            mth = ((p->gregmdy[0] - '0') * 10) + (p->gregmdy[1] - '0');
            if((mth) && (mth < 13))
              ;
            else {
              p->daterr = 'e';
              return;
            }

            /* ----- perform year table lookup function ------------------ */
            tblukup(p);

            /* ----- check for valid day within the month ---------------- */
            i = grgvldy[mth - 1];
            if(day > i)
            if(p->yeartyp == leap_year)
              if(day == 29)
                ;
              else {
                p->daterr = 'e';
                return;
              }
            else {
              p->daterr = 'e';
              return;
            }

            /* ----- build julian date from gregorian -------------------- */
            memcpy(&p->juldate[0], & p->gregymd[0], 4);
            i = (gregcvrt[mth - 1]) + day;
            p->juldate[4] = ((i / 100) + '0');
            i %= 100;
            p->juldate[5] = ((i / 10) + '0');
            i %= 10;
            p->juldate[6] = i + '0';
            p->juldate[7] = '\0';

            /* ----- go finish date processing --------------------------- */
            datcomn(p);
            return;
          }                                 /* end function gregorian_sent */

          /*****************************************************************/
          /* The julmo[] table contains the literal month names.           */
          /*****************************************************************/
          static char julmo[12][10] = {{"January"},{"February"},{"March"},
                                       {"April"},{"May"},{"June"},{"July"},
                                       {"August"},{"September"},{"October"},
                                       {"November"},{"December"}};

          /*****************************************************************/
          /* The dwktbl[] table contains the literal day of week names.    */
          /*****************************************************************/
          static char dwktbl[7][10] = {{"Monday"},{"Tuesday"},{"Wednesday"},
                                       {"Thursday"},{"Friday"},{"Saturday"},
                                       {"Sunday"}};

          /*****************************************************************/
          /* datcomn(): common date processing.                            */
          /*****************************************************************/
          void datcomn(struct DATEGENL *p) {

            int i, j;

            /* ----- build the julslash date field ----------------------- */
            memmove(&p->julslash[0], &p->juldate[0], 4);
            p->julslash[4] = '/';
            strcpy(&p->julslash[5], &p->juldate[4]);

            /* ----- build the grgslash date field ----------------------- */
            memmove(&p->grgslash[0], &p->gregmdy[0], 2);
            p->grgslash[2] = '/';
            memmove(&p->grgslash[3], &p->gregmdy[2], 2);
            p->grgslash[5] = '/';
            strcpy(&p->grgslash[6], &p->gregmdy[4]);

            /* determine whether this date is a holiday and set indicator  */
            for(i = 0; i < 9; i++)
              if(!strcmp(yeardata.holiday_table[i].holiday_mmdd,&p->gregymd[4]))
{
                p->holiday = yeardata.holiday_table[i].holiday_type;
                break;
              }

            /* ----- build the litdate field ----------------------------- */
            i = ((atoi(&p->juldate[4])) + (yeardata.jan1_day - '0')) % 7;
            if(i == 0) i = 7;
            p->daywk = i | '0';                 /* move day of week number */
            strcpy(p->daylit, dwktbl[i-1]);    /* move day of week literal */
            i = (((p->gregmdy[0]) - '0') * 10) + ((p->gregmdy[1]) - '0');
            strcpy(p->monthlit, julmo[i - 1]);          /* move month name */
            strcpy(p->litdate, p->monthlit);                 /* month name */
            i = 2;
            while(p->litdate[++i]);
            p->litdate[i++] = ' ';
            if(p->gregmdy[2] != '0')
              p->litdate[i++] = p->gregmdy[2];
            p->litdate[i++] = p->gregmdy[3];                        /* day */
            p->litdate[i++] = ',';                                /* comma */
            p->litdate[i++] = ' ';                                /* blank */
            memcpy(&p->litdate[i], p->gregymd, 4);                 /* year */
            p->litdate[i + 4] = '\0';
          }                                        /* end function datcomn */

          /*****************************************************************/
          /* yeartbl1 contains subscript values (0-13) to yeartbl2. When   */
          /* the next is 6 or 13, January 1st next year falls on Saturday, */
          /* and will be observed on December 31st of this year (the       */
          /* preceding Friday).                                            */
          /*****************************************************************/
          static int yeartbl1[201] = {
                              1,2,3,4,12,0,1,2,10,5,          /* 1900-1909 */
                              6,0,8,3,4,5,13,1,2,3,           /* 1910-1919 */
                              11,6,0,1,9,4,5,6,7,2,           /* 1920-1929 */
                              3,4,12,0,1,2,10,5,6,0,          /* 1930-1939 */
                              8,3,4,5,13,1,2,3,11,6,          /* 1940-1949 */
                              0,1,9,4,5,6,7,2,3,4,            /* 1950-1959 */
                              12,0,1,2,10,5,6,0,8,3,          /* 1960-1969 */
                              4,5,13,1,2,3,11,6,0,1,          /* 1970-1979 */
                              9,4,5,6,7,2,3,4,12,0,           /* 1980-1989 */
                              1,2,10,5,6,0,8,3,4,5,           /* 1990-1999 */
                              13,0,1,2,10,5,6,0,8,3,          /* 2000-2009 */
                              4,5,13,1,2,3,11,6,0,1,          /* 2010-2019 */
                              9,4,5,6,7,2,3,4,12,0,           /* 2020-2029 */
                              1,2,10,5,6,0,8,3,4,5,           /* 2030-2039 */
                              13,1,2,3,11,6,0,1,9,4,          /* 2040-2049 */
                              5,6,7,2,3,4,12,0,1,2,           /* 2050-2059 */
                              10,5,6,0,8,3,4,5,13,1,          /* 2060-2069 */
                              2,3,11,6,0,1,9,4,5,6,           /* 2070-2079 */
                              7,2,3,4,12,0,1,2,10,5,          /* 2080-2089 */
                              6,0,8,3,4,5,6,0,1,2,            /* 2090-2099 */
                              3 };                                 /* 2100 */

          /*****************************************************************/
          /* yeartbl2 contains data about the year: day of week for January*/
          /* 1st, leap year indicator, and holiday dates. Format is:       */
          /*   byte1: day of week for Jan 1: 0=Monday - 6=Sunday           */
          /*   byte2: leap year indicator: 1 = leap year else 0            */
          /*   bytes 3-42: holiday fields of 5 bytes each. Format of each: */
          /*          byte1: holiday type indicator (same as p->holiday)   */
          /*          bytes 2-5: MMDD date of the holiday                  */
          /* entry 7 type is pre-set for Good Friday, and entry 8 is       */
          /* pre-set for a possible New Year's Day observed when Jan1 of   */
          /* next year is Saturday                                         */
          /*****************************************************************/
          static struct year_entry2 yeartbl2[14]={
            {'6','0',{{'1',"0102"},{'4',"0529"},{'5',"0704"},{'6',"0904"},
                      {'7',"1123"},{'8',"1124"},{'9',"1225"},{'3',"0000"},
                      {' ',"1231"}}},
            {'0','0',{{'1',"0101"},{'4',"0528"},{'5',"0704"},{'6',"0903"},
                      {'7',"1122"},{'8',"1123"},{'9',"1225"},{'3',"0000"},
                      {' ',"1231"}}},
            {'1','0',{{'1',"0101"},{'4',"0527"},{'5',"0704"},{'6',"0902"},
                      {'7',"1128"},{'8',"1129"},{'9',"1225"},{'3',"0000"},
                      {' ',"1231"}}},
            {'2','0',{{'1',"0101"},{'4',"0526"},{'5',"0704"},{'6',"0901"},
                      {'7',"1127"},{'8',"1128"},{'9',"1225"},{'3',"0000"},
                      {' ',"1231"}}},
            {'3','0',{{'1',"0101"},{'4',"0525"},{'5',"0703"},{'6',"0907"},
                      {'7',"1126"},{'8',"1127"},{'9',"1225"},{'3',"0000"},
                      {' ',"1231"}}},
            {'4','0',{{'1',"0101"},{'4',"0531"},{'5',"0705"},{'6',"0906"},
                      {'7',"1125"},{'8',"1126"},{'9',"1224"},{'3',"0000"},
                      {' ',"1231"}}},
            {'5','0',{{' ',"0000"},{'4',"0530"},{'5',"0704"},{'6',"0905"},
                      {'7',"1124"},{'8',"1125"},{'9',"1226"},{'3',"0000"},
                      {' ',"1231"}}},
            {'6','1',{{'1',"0102"},{'4',"0528"},{'5',"0704"},{'6',"0903"},
                      {'7',"1122"},{'8',"1123"},{'9',"1225"},{'3',"0000"},
                      {' ',"1231"}}},
            {'0','1',{{'1',"0101"},{'4',"0527"},{'5',"0704"},{'6',"0902"},
                      {'7',"1128"},{'8',"1129"},{'9',"1225"},{'3',"0000"},
                      {' ',"1231"}}},
            {'1','1',{{'1',"0101"},{'4',"0526"},{'5',"0704"},{'6',"0901"},
                      {'7',"1127"},{'8',"1128"},{'9',"1225"},{'3',"0000"},
                      {' ',"1231"}}},
            {'2','1',{{'1',"0101"},{'4',"0525"},{'5',"0703"},{'6',"0907"},
                      {'7',"1126"},{'8',"1127"},{'9',"1225"},{'3',"0000"},
                      {' ',"1231"}}},
            {'3','1',{{'1',"0101"},{'4',"0531"},{'5',"0705"},{'6',"0906"},
                      {'7',"1125"},{'8',"1126"},{'9',"1224"},{'3',"0000"},
                      {' ',"1231"}}},
            {'4','1',{{'1',"0101"},{'4',"0530"},{'5',"0704"},{'6',"0905"},
                      {'7',"1124"},{'8',"1125"},{'9',"1226"},{'3',"0000"},
                      {' ',"1231"}}},
            {'5','1',{{'1',"0000"},{'4',"0529"},{'5',"0704"},{'6',"0904"},
                      {'7',"1123"},{'8',"1124"},{'9',"1225"},{'3',"0000"},
                      {' ',"1231"}}}
          };

          /*****************************************************************/
          /* The goodfri[] table contains the dates of Good Friday for each*/
          /* year from 1900 to 2099. An index to the table can be computed */
          /* as: year - 1900.                                              */
          /*****************************************************************/
          static struct {
            char good_friday_mmdd[5];     /* month-day date of Good Friday */
          } goodfri[200] = {
               {"0413"},{"0405"},{"0328"},{"0410"},{"0401"},  /* 1900-1904 */
               {"0421"},{"0413"},{"0329"},{"0417"},{"0409"},  /* 1905-1909 */
               {"0325"},{"0414"},{"0405"},{"0321"},{"0410"},  /* 1910-1914 */
               {"0402"},{"0421"},{"0406"},{"0329"},{"0418"},  /* 1915-1919 */
               {"0402"},{"0325"},{"0414"},{"0330"},{"0418"},  /* 1920-1924 */
               {"0410"},{"0402"},{"0415"},{"0406"},{"0329"},  /* 1925-1929 */
               {"0418"},{"0403"},{"0325"},{"0414"},{"0330"},  /* 1930-1934 */
               {"0419"},{"0410"},{"0326"},{"0415"},{"0407"},  /* 1935-1939 */
               {"0322"},{"0411"},{"0403"},{"0423"},{"0407"},  /* 1940-1944 */
               {"0330"},{"0419"},{"0404"},{"0326"},{"0415"},  /* 1945-1949 */
               {"0407"},{"0323"},{"0411"},{"0403"},{"0416"},  /* 1950-1954 */
               {"0408"},{"0330"},{"0419"},{"0404"},{"0327"},  /* 1955-1959 */
               {"0415"},{"0331"},{"0420"},{"0412"},{"0327"},  /* 1960-1964 */
               {"0416"},{"0408"},{"0324"},{"0412"},{"0404"},  /* 1965-1969 */
               {"0327"},{"0409"},{"0331"},{"0420"},{"0412"},  /* 1970-1974 */
               {"0328"},{"0416"},{"0408"},{"0324"},{"0413"},  /* 1975-1979 */
               {"0404"},{"0417"},{"0409"},{"0401"},{"0420"},  /* 1980-1984 */
               {"0405"},{"0328"},{"0417"},{"0401"},{"0324"},  /* 1985-1989 */
               {"0413"},{"0329"},{"0417"},{"0409"},{"0401"},  /* 1990-1994 */
               {"0414"},{"0405"},{"0328"},{"0410"},{"0402"},  /* 1995-1999 */
               {"0421"},{"0413"},{"0329"},{"0418"},{"0409"},  /* 2000-2004 */
               {"0325"},{"0414"},{"0406"},{"0321"},{"0410"},  /* 2005-2009 */
               {"0402"},{"0422"},{"0406"},{"0329"},{"0418"},  /* 2010-2014 */
               {"0403"},{"0325"},{"0414"},{"0330"},{"0419"},  /* 2015-2019 */
               {"0410"},{"0402"},{"0415"},{"0407"},{"0329"},  /* 2020-2024 */
               {"0418"},{"0403"},{"0326"},{"0414"},{"0330"},  /* 2025-2029 */
               {"0419"},{"0411"},{"0326"},{"0415"},{"0407"},  /* 2030-2034 */
               {"0323"},{"0411"},{"0403"},{"0423"},{"0408"},  /* 2035-2039 */
               {"0330"},{"0419"},{"0404"},{"0327"},{"0415"},  /* 2040-2044 */
               {"0407"},{"0323"},{"0412"},{"0403"},{"0416"},  /* 2045-2049 */
               {"0408"},{"0331"},{"0419"},{"0404"},{"0327"},  /* 2050-2054 */
               {"0416"},{"0331"},{"0420"},{"0412"},{"0328"},  /* 2055-2059 */
               {"0416"},{"0408"},{"0324"},{"0413"},{"0404"},  /* 2060-2064 */
               {"0327"},{"0409"},{"0401"},{"0420"},{"0412"},  /* 2065-2069 */
               {"0328"},{"0417"},{"0408"},{"0324"},{"0413"},  /* 2070-2074 */
               {"0405"},{"0417"},{"0409"},{"0401"},{"0421"},  /* 2075-2079 */
               {"0405"},{"0328"},{"0417"},{"0402"},{"0324"},  /* 2080-2084 */
               {"0413"},{"0329"},{"0418"},{"0409"},{"0401"},  /* 2085-2089 */
               {"0414"},{"0406"},{"0328"},{"0410"},{"0402"},  /* 2090-2094 */
               {"0422"},{"0413"},{"0329"},{"0418"},{"0410"}   /* 2095-2099 */
            };

          /*****************************************************************/
          /* tblukup(): performs year table lookups using the gregmdy year.*/
          /* The data entry found is moved to the yeardata area.           */
          /*****************************************************************/
          void tblukup(struct DATEGENL *p) {
            int i, j, *q;
            char char_year[5];

            /* ----- compute the year table index = year - 1900 ---------- */
            memcpy(char_year, p->gregymd, 4);
            char_year[4] = '\0';
            i = atoi(char_year);                    /* convert year to int */
            i -= 1900;                      /* deduct 1900 for index value */
            j = yeartbl1[i];             /* get index to second year table */

            /* - move entry for the specified year to the yeardata field - */
            yeardata = yeartbl2[j];              /* copy data for the year */

            /* - move the Good Friday date to the yeardata holiday table - */
            strcpy(yeardata.holiday_table[7].holiday_mmdd,
                                               goodfri[i].good_friday_mmdd);

            /* if next year begins on Saturday, make December 31 a holiday */
            if((yeartbl1[i+1] == 6) || (yeartbl1[i+1] == 13)) {
              yeardata.holiday_table[8].holiday_type = '1';} /* 12/31 NewYr*/

            /* ----- set year type in dategenl structure ----------------- */
            p->yeartyp = yeardata.leap_year_ind; /* year type to dategenl  */

            /* ----- set correct values in the gregcvrt() table ---------- */
            q = gregcv0;
            if(p->yeartyp == leap_year)
            q = gregcv1;
            for(i = 0; i < 13; i++)
              gregcvrt[i] = *q++;
            }                                      /* end function tblukup */

          *********************************************************************
          *                   Elementary C Programming               keyvalu.c*
          *********************************************************************

            /*****************************************************************/
            /*                           keyvalu.c                           */
            /* keyvalu.c shows the decimal, hex, and character values for any*/
            /* key pressed alone or in combination with Ctrl, Alt, or Shift. */
            /*****************************************************************/

            #include <stdio.h>            /* include header for standard I/O */

            unsigned char c;              /* define c                        */
            int qcnt;                     /* define qcnt                     */

            /*****************************************************************/
            /* main function: this is the initial entry point to the program */
            /*****************************************************************/

            void main() {                 /* function header for main        */

              /***************************************************************/
              /* display instructions for the user                           */
              /***************************************************************/
              printf("\nPress any single key alone or in combination with ");
              printf("\nCtrl, Alt, or Shift to see the decimal, hex, and ");
              printf("\nprintable values for the key.");
              printf("\nTo terminate press q four times in succession.\n\n");

              /***************************************************************/
              /* This never ending while loop runs until the user types the  */
              /* letter q four times in succession. This is the main process */
              /* loop that gets the key(s) pressed and produces a display    */
              /* giving the key values in decimal, hex, and character forms. */
              /***************************************************************/
              while(1) {                      /* loop forever                */
                c = getch();                  /* read a key into c           */
                if(c == 0) {                  /* if c is zero, it is extended*/
                  c = getch();                   /* code, so read scan code  */
                                                 /* and display extended code*/
                  printf("Extended key scan code: %d (%02X) %s\n",c,c,"N/A");
                }
                else                          /* if key read is not zero     */
                                              /* display normal key values   */
                printf("Normal: %d (%02X) %c\n",c,c,c);
                if(c == 'q') {                /* if key pressed is a q       */
                  if(qcnt == 3)                  /* and this is the 3rd q    */
                    break;                          /* break out of the while*/
                  else                        /* otherwise, if not the 3rd   */
                    qcnt++;                      /* increment q counter      */
                }
                else                          /* otherwise, if not a q       */
                  qcnt = 0;                      /* clear the q counter      */
              }
            }                                 /* end of main function        */

./ ADD NAME=HELLO2   0100-02144-02144-0950-00063-00063-00000-BC0THOR
          /***************************************************************/
          /*                   hello2.c                                  */
          /* hello2.c is version2 of the Hello, World! program           */
          /***************************************************************/

          #include <stdio.h>;              /* include standard I/O header*/

          #define White 623                /* White is 623               */

          int print_count(int count);      /* print_count prototype      */

          char hello[] = "hello, zorld!\n"; /* string with initial value */

          /***************************************************************/
          /* main function: initial program entry point                  */
          /***************************************************************/

          void main() {                    /* function header for main   */

            int count = White;             /* define count = 623         */
            char picx = 'W';               /* define picx = 'W'          */

            hello[7] = picx;               /* move picx to string[7]     */
            printf("%s",hello);            /* display modified string    */
            printf                         /* printf                     */
                  (                           /* with                    */
                   "White space is ignored\n"    /* many                 */
                                              )     /* imbedded          */
                                                ;      /* spaces         */

         /****************************************************************/
         /* The printf below displays the number returned by the         */
         /* print_count function. Notice that no variable is used on the */
         /* right side of the parameter, but only a call to print_count. */
         /* this is because a function call IS what it returns.          */
         /****************************************************************/

            printf("The print_count() function returned %d\n",
                    print_count(count));   /* print print_count's return */
         }                                 /* end of main function       */

         /****************************************************************/
         /* print_count: display value of the count field and return an  */
         /* integer value to the caller.                                 */
         /****************************************************************/

         int print_count(int white) {   /* print_count's function header */

           int ret_valu;                   /* define ret_valu            */

           /**************************************************************/
           /* The printf below displays the integer value received as a  */
           /* parameter on entry. Note that it is passed by the caller as*/
           /* a field called count, but is called white on entry to the  */
           /* print_count function. Also note that the #define for White */
           /* does not affect this, as it begins with a lower case w.    */
           /**************************************************************/
           printf("The value of the count field is: %d\n",white);

           ret_valu = white % 600;         /* ret_valu is remainder value*/
           return(ret_valu);               /* return ret_valu to caller  */
        }                                  /* end of print_count function*/

./ ADD NAME=KEYVALU  0100-02144-02144-0950-00052-00052-00000-BC0THOR
            /*****************************************************************/
            /*                           keyvalu.c                           */
            /* keyvalu.c shows the decimal, hex, and character values for any*/
            /* key pressed alone or in combination with Ctrl, Alt, or Shift. */
            /*****************************************************************/

            #include <stdio.h>            /* include header for standard I/O */

            unsigned char c;              /* define c                        */
            int qcnt;                     /* define qcnt                     */

            /*****************************************************************/
            /* main function: this is the initial entry point to the program */
            /*****************************************************************/

            void main() {                 /* function header for main        */

              /***************************************************************/
              /* display instructions for the user                           */
              /***************************************************************/
              printf("\nPress any single key alone or in combination with ");
              printf("\nCtrl, Alt, or Shift to see the decimal, hex, and ");
              printf("\nprintable values for the key.");
              printf("\nTo terminate press q four times in succession.\n\n");

              /***************************************************************/
              /* This never ending while loop runs until the user types the  */
              /* letter q four times in succession. This is the main process */
              /* loop that gets the key(s) pressed and produces a display    */
              /* giving the key values in decimal, hex, and character forms. */
              /***************************************************************/
              while(1) {                      /* loop forever                */
                c = getch();                  /* read a key into c           */
                if(c == 0) {                  /* if c is zero, it is extended*/
                  c = getch();                   /* code, so read scan code  */
                                                 /* and display extended code*/
                  printf("Extended key scan code: %d (%02X) %s\n",c,c,"N/A");
                }
                else                          /* if key read is not zero     */
                                              /* display normal key values   */
                printf("Normal: %d (%02X) %c\n",c,c,c);
                if(c == 'q') {                /* if key pressed is a q       */
                  if(qcnt == 3)                  /* and this is the 3rd q    */
                    break;                          /* break out of the while*/
                  else                        /* otherwise, if not the 3rd   */
                    qcnt++;                      /* increment q counter      */
                }
                else                          /* otherwise, if not a q       */
                  qcnt = 0;                      /* clear the q counter      */
              }
            }                                 /* end of main function        */

./ ADD NAME=LOADSTRG 0100-02144-02144-0950-00038-00038-00000-BC0THOR
          /******************************************************************/
          /*                        loadstrg.c                              */
          /* loadstrg.c reads up to 100 character strings from the keyboard */
          /* into memory, then displays them after the last one is entered. */
          /******************************************************************/

          #include <stdio.h>                 /* include standard I/O header */
          #include <stdlib.h>                /* include standard lib header */
          #include <string.h>                /* include string header       */

          /******************************************************************/
          /* main function: initial entry point to the program. reads the   */
          /* strings into storage areas obtained individually for each one. */
          /* After the last string (user presses enter with no data), all   */
          /* the stored strings are displayed.                              */
          /******************************************************************/

          main() {                           /* function header for main    */

            char *p[101];                    /* p is array of ptrs to chars */
            int i,l;                         /* define work subscripts      */
            char string[80];                 /* define work string          */

            for(i=0;i<100;i++) {             /* loop for up to 100 strings  */
              gets(string);                    /* read string into work area*/
              if(!(l = strlen(string))) break; /* if null string, break loop*/
              *(p+i) = (char *)malloc(l+1);    /* else get storage to hold  */
              strcpy(*(p+i),string);           /* and copy string to storage*/
            }

            *(p+i) = 0;                      /* 0 = end of array pointers   */

            for(i=0;i<100;i++) {             /* loop to display strings     */
              if(!p[i]) break;                  /* if end of table, break   */
              printf("%s\n",*(p+i));            /* else display the string  */
            }
          }                                  /* end of main function        */

./ ADD NAME=MENU10   0100-02144-02144-0950-00152-00152-00000-BC0THOR
          /******************************************************************/
          /*                         menu10.c                               */
          /* menu10.c displays a menu asking the user for an a, s, m, or d  */
          /* as a request to add, subtract, multiply, or divide two numbers.*/
          /* Four functions handle each type of request, each asking for the*/
          /* numbers, reading the numbers from the keyboard, performing the */
          /* keyboard, performing the arithmetic, and displaying results.   */
          /******************************************************************/

                               /**********************/
          /********************* header file includes ***********************/
                               /**********************/
          #include <stdio.h>
          #include <math.h>

                               /**********************/
          /*********************       defines        ***********************/
                               /**********************/
          #define CLEAR "\x1B[2J"

                               /**********************/
          /*********************  global data fields  ***********************/
                               /**********************/
          float num1,num2;
          float sum,difference,product,quotient,remainder;
          char string[80];
          unsigned char c;

                               /**********************/
          /********************* function prototypes  ***********************/
                               /**********************/
          void add_numbers(void);
          void subtract_numbers(void);
          void multiply_numbers(void);
          void divide_numbers(void);

                                /*********************/
          /*********************     main function    ***********************/
          /*** display menu, read request and call appropriate function *****/
             /**********************************************************/
          void main() {
            c = ' ';
            while((c != 'q') & (c != 'Q')) {                /* display menu */

              printf(CLEAR);
              printf("\n\n\n\n        A = add numbers");
              printf("\n\n        S = subtract numbers");
              printf("\n\n        M = multiply numbers");
              printf("\n\n        D = divide numbers");
              printf("\n\n        Q = quit");
              printf("\n\n            ");

              switch(c=getch()) {                           /* read request */
                case 'q':
                case 'Q':
                  break;
                case 'a':
                case 'A':
                  add_numbers();
                  break;
                case 's':
                case 'S':
                  subtract_numbers();
                  break;
                case 'm':
                case 'M':
                  multiply_numbers();
                  break;
                case 'd':
                case 'D':
                  divide_numbers();
                  break;
              }
            }
          }

                                /**********************/
          /*********************  add_numbers function **********************/
          /************* add two numbers and display the sum ****************/
                       /*************************************/
          void add_numbers() {
            printf(CLEAR);
            printf("\n\n\n\n        Enter First number: ");
            gets( string);
            num1 = atof(string);
            printf("\n\n\n\n        Enter Second number: ");
            gets( string);
            num2 = atof(string);
            sum = num1 + num2;
            printf("\n\n\n        %f + %f = %f",num1,num2,sum);
            printf("\n\n        Press any key to continue");
            getch();
          }

                            /****************************/
          /******************  subtract_numbers function ********************/
          /******** subtract two numbers and display the difference *********/
                  /*************************************************/
          /* subtract two numbers and display the difference */
          void subtract_numbers(void) {
            printf(CLEAR);
            printf("\n\n\n\n        Enter First number: ");
            gets( string);
            num1 = atof(string);
            printf("\n\n\n\n        Enter Second number: ");
            gets( string);
            num2 = atof(string);
            difference = num1 - num2;
            printf("\n\n\n        %f - %f = %f",num1,num2,difference);
            printf("\n\n        Press any key to continue");
            getch();
          }

                             /***************************/
          /******************* multiply_numbers function ********************/
          /******** multiply two numbers and display the product ************/
                  /**********************************************/
          /* multiply two numbers and display the product */
          void multiply_numbers(void) {

            printf(CLEAR);
            printf("\n\n\n\n        Enter First number: ");
            gets( string);
            num1 = atof(string);
            printf("\n\n\n\n        Enter Second number: ");
            gets( string);
            num2 = atof(string);
            product = num1 * num2;
            printf("\n\n\n        %f * %f = %f",num1,num2,product);
            printf("\n\n        Press any key to continue");
            getch();
          }

                                /**********************/
          /********************  divide_numbers function ********************/
          /********* divide two numbers and display the quotient ************/
                   /*********************************************/
          /* divide two numbers and display the quotient and remainder */
          void divide_numbers(void) {
            printf(CLEAR);
            printf("\n\n\n\n        Enter First number: ");
            gets( string);
            num1 = atof(string);
            printf("\n\n\n\n        Enter Second number: ");
            gets( string);
            num2 = atof(string);
            quotient = num1 / num2;
            printf("\n\n\n        %f / %f = %f",num1,num2,quotient);
            printf("\n\n        Press any key to continue");
            getch();
          }

./ ADD NAME=SKELETON 0100-02144-02144-0950-00393-00393-00000-BC0THOR
         /*******************************************************************/
         /*                     skeleton.c                                  */
         /*                                                                 */
         /* generic c program that includes an input file, output file,     */
         /* print file, and common processing functions:                    */
         /*  main       = executive routine: overall program control        */
         /*  mainline   = mainline processing control                       */
         /*  initialize = open files, set up headers and call headings      */
         /*  readrec    = read input file records and count them            */
         /*  writerec   = write output file records and count them          */
         /*  printline  = print detail, clear print line, call headings     */
         /*  headings   = print heading lines for new page                  */
         /*  edit       = edit numbers with commas, decimal points, etc     */
         /*  terminate  = close files, print totals, stop execution         */
         /*                                                                 */
         /*                                                                 */
         /* Author R Thornton September 1993                                */
         /*******************************************************************/

         #include <stdio.h>
         #include <stdlib.h>
         #include <time.h>

         void initialize(int argc, char *argv[]);  /* initialization func   */
         void mainline(void);                  /* mainline function         */
         void terminate(void);                 /* termination function      */
         void readrec(void);                   /* read next input file rec  */
         void writerec(void);                  /* write record to out file  */
         void printline(void);                 /* print a line to rept file */
         int edit(char output[], char pattern[], char number[]); /* edit fnc*/
         void headings(void);                  /* print report heading      */

         FILE *infile, *outfile, *prtfile;     /* file handle pointers      */

         char innam[81];                       /* input file name           */
         char outnam[81];                      /* output file name          */
         char prtnam[81] = "prn";              /* print file name           */

         char prtline[135];                    /* print line buffer         */
         char inrecord[256];                   /* input file record area    */
         char outrecord[256];                  /* output file record area   */

         char *h1ptr;                          /* heading line 1 pointer    */
         struct {                              /* first heading line        */
           char hdr_skip;                        /* form feed               */
           char hdr_date[10];                    /* report date             */
           char ctr1[45];                        /* centering blanks        */
           char title_line[21];                  /* centered report title   */
           char ctr2[45];                        /* centering blanks        */
           char page_lit[5];                     /* page literal            */
           char page_nbr[6];                     /* page number             */
           char newline;                         /* newline character       */
           char null_byte;                       /* terminating null        */
         } header1;

         int i;                                /* general purpose int       */
         char number[32];                      /* ascii numbers for edit()  */
         int morerecs = -1;                    /* input end-of-file switch  */
         long incount = 0;                     /* input record counter      */
         long outcount = 0;                    /* output record counter     */
         int linecnt = 0;                      /* print line counter        */
         int pagecnt = 0;                      /* print page counter        */
         struct tm *t;                         /* pointer to time structure */
         time_t seconds;                       /* current timer value       */

         /*******************************************************************/
         /* executive routine: overall program control                      */
         /*******************************************************************/
         void main(int argc, char *argv[]) {
            initialize(argc, argv);            /* open files                */
            while(morerecs)                    /* perform mainline until    */
               mainline();                     /* no more records           */
            terminate();                       /* close files               */
            exit(0);                           /* quit                      */
         }
         /*******************************************************************/
         /* mainline function: process input file until no more records.    */
         /*******************************************************************/
         void mainline(void) {
            strcpy(prtline,inrecord);          /* move input record to print*/
            printline();                       /* and print it              */
            strcpy(outrecord,inrecord);       /* move input record to output*/
            writerec();                        /* write an output record    */
            readrec();                         /* read next input record    */
         }
         /*******************************************************************/
         /* initialization: open files, read first input record.            */
         /*******************************************************************/
         void initialize(int argc, char *argv[]) {
           if(argc == 3) {                     /* if two filenames given:   */
             strcpy(&innam,argv[1]);             /* 1st is input filename   */
             strcpy(&outnam,argv[2]);            /* 2nd is output filename  */
           }
           else
             if(argc == 4) {                   /* if three filenames given: */
               strcpy(&innam,argv[1]);           /* 1st is input filename   */
               strcpy(&outnam,argv[2]);          /* 2nd is output filename  */
               strcpy(&prtnam,argv[3]);          /* 3rd is print file name  */
             }
             else {                            /* if neither 2 nor 3 given: */
               printf("\nEnter input file spec: "); /* ask for input filenam*/
               gets(innam);                         /* and read it in       */
               printf("\nEnter output file spec: "); /* ask for output filen*/
               gets(outnam);                        /* and read it in       */
               printf("\nEnter output file spec (or prn): "); /* ask for prt*/
               gets(prtnam);                        /* and read it in       */
             }
           if((infile=fopen(innam,"rb")) == NULL) { /* open input           */
             printf("Can't open file %s.",innam);   /* open failed message  */
             exit(1);                               /* terminate            */
           }
           if((outfile=fopen(outnam,"wb")) == NULL) { /* open output        */
             printf("Can't open file %s.",outnam);
             exit(1);
           }
           if((prtfile=fopen(prtnam,"w"))==NULL) { /* open print file       */
             printf("\nCan't open the printer file."); /* open failed msg   */
             exit(1);                                  /* terminate         */
           }
           h1ptr = (char *)&header1;               /* point to header1 line */
           for(i=0;i<133;i++)                      /* clear header line     */
             h1ptr[i] = ' ';                         /* to all spaces       */
           header1.hdr_skip = '\f';              /* form feed to header line*/
           memcpy(header1.title_line,"SKELETON REPORT TITLE",21); /* copy hd*/
           timezone = 5 * 60 * 60;               /* set local time for e.s.t*/
           daylight = -1;                        /* indicate daylit sav time*/
           time(&seconds);                       /* time in secs            */
           t = localtime(&seconds);              /* local time to tm struct */
           sprintf(header1.hdr_date,"%2d\/%2d\/%2d",
                                       t->tm_mon,t->tm_mday,t->tm_year);
           header1.hdr_date[8] = ' ';            /* clear terminating null  */
           memcpy(header1.page_lit,"PAGE ",5);   /* PAGE literal to header  */
           prtline[133] = '\0';                 /* terminal null to prt line*/
           headings();                           /* write first heading     */
           readrec();                        /* read first input file record*/
         }
         /*******************************************************************/
         /* read next input file record. at end of file, set morerecs switch*/
         /*******************************************************************/
         void readrec() {
           if(fgets(inrecord,255,infile) == NULL) /* read input until eof   */
             morerecs = 0;                      /* set switch at end of file*/
           if(morerecs)                           /* if not at end of file  */
           incount++;                               /* add 1 to records read*/
         }
         /*******************************************************************/
         /* write a record to the output file                               */
         /*******************************************************************/
         void writerec() {
           fputs(outrecord,outfile);             /* write output record     */
           outcount++;                           /* add 1 to records written*/
         }
         /*******************************************************************/
         /* write a line to the printer                                     */
         /*******************************************************************/
         void printline() {
           prtline[133] = '\n';            /* terminal newline to print line*/
           prtline[134] = '\0';            /* terminal null to print line   */
           fputs(prtline,prtfile);         /* write print line              */
           linecnt++;                      /* add 1 to line counter         */
           if(linecnt > 56)                /* if end of page                */
             headings();                     /* write heading lines         */
           else                            /* otherwise                     */
             for(i=0;i<133;i++)              /* clear print line            */
               prtline[i] = ' ';               /* to all spaces             */
         }
         /*******************************************************************/
         /* write a report heading                                          */
         /*******************************************************************/
         void headings() {
           linecnt = 0;                      /* clear line counter          */
           pagecnt++;                        /* add 1 to page counter       */
           sprintf(number,"%d",pagecnt);     /* convert to printable nbr    */
           edit(header1.page_nbr,"zz,zz9",number); /* page nbr to hdr line  */
           header1.newline = '\n';           /* terminal newline to hdr     */
           header1.null_byte = '\0';         /* terminal null to header     */
           fputs((char *)&header1,prtfile);  /* write header line           */
           for(i=0;i<133;i++)                /* clear print line            */
             prtline[i] = ' ';                 /* to all spaces             */
           prtline[133] = '\n';              /* ending newline to print line*/
           prtline[134] = '\0';              /* terminal null to print line */
           fputs(prtline,prtfile);           /* blank line after heading    */
         }

         /*******************************************************************/
         /* The edit function provides numeric report editing, including    */
         /* leading zero suppression, check protection, floating $, leading */
         /* or trailing minus sign, insertion of commas, decimal points and */
         /* other non-numeric fields. The first parameter is the address of */
         /* the edited output, whose size will be the same as the pattern.  */
         /* The second parameter is the editing pattern which must be a true*/
         /* null-terminated string containing the edit pattern. The third   */
         /* is the number to be edited, a null-terminated string containing */
         /* only digits 0-9 except the first position, which is a -, if the */
         /* number is negative. The pattern may be up to 64 characters, and */
         /* the number to be edited may contain up to 32 characters. The    */
         /* number may not contain more significant digits than there are   */
         /* digit select characters in the pattern. If there are more digits*/
         /* selected by the pattern than there are in the number, leading   */
         /* zeros will be assumed. In the pattern, the first character may  */
         /* be:      $ (floating dollar sign)                               */
         /*          * (check protection)                                   */
         /*          - (floating minus sign)                                */
         /* The body of the edit pattern will be composed of digit select   */
         /* characters (z and 9) and other characters, handled as follows:  */
         /*          z (zero suppression output is a blank in this position */
         /*             until significance is set by receipt of a significan*/
         /*             digit or a 9 in the pattern. After significance is  */
         /*             set, output is a digit from the number.)            */
         /*          9 (output is a digit from the number and significance  */
         /*             is set, even if the digit is a leading zero.)       */
         /*        other characters in the pattern will be output as-is afte*/
         /*             significance is set, but will be output as blanks   */
         /*             before significance is set.                         */
         /* Characters in the pattern following the last digit select will  */
         /* be output as-is if the number is negative, otherwise output will*/
         /* be blanks for these pattern positions.                          */
         /*                                                                 */
         /* When * check protection is selected, output will be *, rather   */
         /* than blanks as mentioned above.                                 */
         /*                                                                 */
         /* An integer is returned to indicate success or errors:           */
         /*                 0 = successful edit                             */
         /*                 1 = pattern too long (over 64 characters)       */
         /*                 2 = too many digits selected (over 32)          */
         /*                 3 = no output digits selected in pattern        */
         /*                 4 = number contains non-numeric data            */
         /*                 5 = number has more digits than the pattern     */
         /*                                                                 */
         /* Examples:                            nbr=             outf=     */
         /*    err=edit(outf,"zz,zz9.99-",nbr);  0                     0.00 */
         /*                                      123                   1.23 */
         /*                                      562983            5,629.83 */
         /*                                      -4675                46.75-*/
         /*    err=edit(outf,"$,$$$.$$",nbr);    0                          */
         /*                                      123                  $1.23 */
         /*                                      562983           $5,629.83 */
         /*                                      -4675               $46.75 */
         /*    err=edit(outf,"***.**",nbr);      0                          */
         /*                                      123                 **1.23 */
         /*                                      562983   err = 5           */
         /*                                      -4675               *46.75 */
         /*    err=edit(outf,"--,--9.99",nbr);   0                     0.00 */
         /*                                      123                   1.23 */
         /*                                      562983            5,629.83 */
         /*                                      -46.75              -46.75 */
         /*                                                                 */
         /* Author R Thornton April 1989                                    */
         /*******************************************************************/
         /**/
         int edit(char output[], char pattern[], char number[]) {
           char float_val = ' ';
           char fill_val = ' ';
           char sign_val = ' ';
           int signif = 0;
           int psize = 0;
           int pdig = 0;
           int plast = 0;
           int ndig = 0;
           char nbr[33];
           char ch= ' ';
           int po=0;
           int n=0;

         /*******************************************************************/
         /* examine pattern: set up float and fill, count size and digits   */
         /*******************************************************************/
           if(((ch=pattern[0]) == '$') || (ch == '*') || (ch == '-'))
             float_val = ch;
           if(ch == '*')
             fill_val = '*';
           while((ch=pattern[po]) != '\0') {
            if((ch == 'z') || (ch == '9')) {
               pdig++;
               plast = po;
             }
             psize++;
             po++;
           }
           if(psize > 63)
             return(1);
           if(pdig > 32)
             return(2);
           if(!pdig)
             return(3);

         /*******************************************************************/
         /* examine number: set up sign, count digits, check numeric.       */
         /* set error if more digits than pattern, move right justified     */
         /*******************************************************************/
           if(number[0] == '-') {
             sign_val = '-';
             n = 1;
           }
           while((ch=number[n]) != '\0') {
             if((ch < '0') || (ch > '9'))
               return(4);
             ndig++;
             n++;
           }
           if(ndig > pdig)
             return(5);
           for(po=0;po<(pdig-ndig);po++)
             nbr[po] = '0';
           if(sign_val == ' ')
             n = 0;
           else
             n=1;
           for(;po<pdig;po++,n++)
             nbr[po] = number[n];

         /********************************************************************/
         /* scan across the pattern, setting the corresponding output        */
         /* byte from pattern, fill, or amt depending on the pattern         */
         /* character and state of significance.                             */
         /********************************************************************/
           if(float_val != ' ') {
             output[0] = ' ';
             po = 1;
           }
           else
             po = 0;
           n = 0;
           while((po <= plast)) {
             ch = pattern[po];
             if(ch == 'z') {
               if(signif) {
                 output[po] = nbr[n];
                 n++;
               }
               else {
                 if(nbr[n] == '0') {
                   output[po] = fill_val;
                   n++;
                 }
                 else {
                   output[po] = nbr[n];
                   signif = -1;
                   n++;
                   if(float_val == ' ')
                     ;
                   else
                     if((float_val == '$') || (sign_val == '-'))
                       output[po-1] = float_val;
                 }
               }
             }
             else if(ch == '9') {
               output[po] = nbr[n];
               if(!signif) {
                 signif = -1;
                 if(float_val == ' ')
                   ;
                 else
                   if((float_val == '$') || (sign_val == '-'))
                     output[po-1] = float_val;
               }
               n++;
             }
             else {
               if(signif)
                 output[po] = pattern[po];
               else
                 output[po] = fill_val;
             }
             po++;
           }
           while((ch=pattern[po]) != '\0') {
             if(sign_val == ' ')
               output[po++] = fill_val;
             else
               output[po++] = pattern[po];
           }
           return(0);
         }

         /*******************************************************************/
         /* termination: close files                                        */
         /*******************************************************************/
         void terminate() {
           sprintf(number,"%ld",incount);    /* convert input count to ascii*/
           edit(prtline, "zz,zzz,zz9", number); /* edit number to prtline   */
           strcpy(prtline+10," input records read"); /* message to prt      */
           printline();                      /* print count                 */
           sprintf(number,"%ld",outcount);   /* convert input count to ascii*/
           edit(prtline, "zz,zzz,zz9", number); /* edit number to prtline   */
           strcpy(prtline+10," output records written"); /* message to prt  */
           printline();                      /* print count                 */
           fclose(infile);                   /* close input file            */
           fclose(outfile);                  /* close output file           */
           fclose(prtfile);                  /* close print file            */
         }

./ ADD NAME=STRUCT9  0100-02144-02144-0950-00076-00076-00000-BC0THOR
          /******************************************************************/
          /*                       struct9.c                                */
          /* struct9.c is an exercise in the use of structures and          */
          /* unions.                                                        */
          /******************************************************************/

          #include <stdio.h>         /* include standard I/O header         */
          #include <stdlib.h>        /* include standard library header     */
          #include <string.h>        /* include string header               */

          /******************************************************************/
          /* main function: initial entry point to the program.             */
          /******************************************************************/

          void main() {              /* function header for main            */

            struct {                 /* define a structure                  */
              int emp_nbr;
              char last_name[12];
              char pay_grade;
              union {                   /* which contains a union           */
                struct {                   /* which includes a structure,   */
                  float hours_worked;
                  float hourly_rate;
                } hourly;
                float annual_salary;       /* and a float                   */
              } pay_data;                  /* union name is pay_data        */
            } emp[12];               /* structure array name is emp         */

            int i,a;                 /* define work integers                */
            char string[80];         /* define work string                  */

            for(i=0;i<12;i++) {      /* loop to clear out all emp elements  */
              emp[i].emp_nbr = 0;
              emp[i].last_name[0] = '\0';
              emp[i].pay_grade = 'h';
              emp[i].pay_data.hourly.hours_worked = 0.0;
              emp[i].pay_data.hourly.hourly_rate = 0.0;
            }

            for(i=0;i<12;i++) {      /* loop to build emp elements          */
              printf("\nEnter emp_nbr for #%d: ",i+1); /* ask for emp_nbr   */
              gets(string);                            /* read it to string */
              emp[i].emp_nbr = atoi(string);           /* and convert to int*/
              if(!(emp[i].emp_nbr)) break;  /* if emp_nbr is zero, break out*/
              printf("\nEnter last name: ");   /* ask for last name         */
              gets(string);                    /* read last name into string*/
              string[11] = '\0';               /* truncate to 11 byte name  */
              strcpy(emp[i].last_name,string); /* copy last name to element */
              printf("\nEnter pay grade, h if hourly, s if salaried: ");
              emp[i].pay_grade = getche();    /* read pay grade into element*/
              /**************************************************************/
              /* if pay_grade is for hourly, ask for, read in, convert, and */
              /* put into the element the hourly rate and hours worked.     */
              /**************************************************************/
              if(emp[i].pay_grade == 'h') {
                printf("\nEnter hourly rate, dollars and cents: ");
                gets(string);
                emp[i].pay_data.hourly.hourly_rate = atof(string);
                printf("\nEnter hours worked with 2 decimal places: ");
                gets(string);
                emp[i].pay_data.hourly.hours_worked = atof(string);
              }
              /**************************************************************/
              /* if pay_grade is not for hourly, assumption is that it is   */
              /* for salaried. Ask for, read in, convert, and move annual   */
              /* salary to the array element.                               */
              /**************************************************************/
              else {
                printf("\nEnter annual salary, dollars and cents: ");
                gets(string);
                emp[i].pay_data.annual_salary = atof(string);
              }
            }
          }                                   /* end of main function       */

./ ADD NAME=SYLLABUS 0100-02144-02144-0950-00090-00090-00000-BC0THOR
         ******************************************************************
         *            Elementary C Programming                    SYLLABUS*
         ******************************************************************
                      Course Syllabus                                Page 1

         Objectives:  On completion, the student should be able to
                      understand, write, compile, test, and execute simple
                      programs using the C language.

         Audience:    Persons who plan to code in the C language,
                      analyze programs written in C, design systems that
                      might include C programs, or who wish to expand their
                      general data processing skills to prepare for Client
                      Server environments.

         Prereq's:    Students should have recent applications coding
                      experience in some second or third generation
                      compiled computer language such as Basic, COBOL,
                      Pascal, C, Fortran, PL/I, etc.



                                          Course Content

         Session 1  - Installation, Customizing, and Checkout:
                      Installing the compiler and integrated development
                      environment, customizing the compiler and IDE, running
                      under OS/2, create, compile, and execute a short program.

         Session 2  - Basic Structure of C Programs:
                      Syntax, comments, program organization, functions, the
                      main() function, function Prototypes, preprocessor
                      directives, escape sequences.

         Session 3  - Variables, Operators, and printf:
                      Lifetime and visibility, definition syntax, types of
                      variables, naming variables, initializing variables,
                      arithmetic operators, increment and decrement
                      operators, printf() syntax and use.

         Session 4  - Include, Define, and Functions:
                      Syntax, parameters, prototype, returning values,
                      passing data (by reference, by value), external
                      variables.

         Session 5  - Arrays, Strings, and Constants:
                      Defining and initializing arrays, strings, and
                      constants.

         Session 6.   Relational and Logical Operators and Decisions:
                      Relational operators, logical operators, if
                      statements, and logical expressions.

         Session 7  - Loops and Keyboard Input Functions
                      For loops, while loops, do while loops, break and
                      continue statements, getc, getch, getche and
                      gets functions.

         ******************************************************************
         *            Elementary C Programming                    SYLLABUS*
         ******************************************************************
                      Course Syllabus                                Page 2

         Session 8  - Pointers:
                      Referring to elements of arrays, sending to functions,
                      pointers to pointers.

         Session 9  - Structures and Unions:
                      Structures, unions, unions of structures, structures
                      including unions.

         Session 10 - Switch statements and the conditional operator.

         Session 11 - Advanced Variables:
                      Pointer notation for structures, enumerated data type,
                      typedef, type conversion and casting.

         Session 12 - Files and I/O Part 1:
                      Types of disk I/O, standard (stream) I/O, binary mode
                      and text mode.

         Session 13 - Files and I/O Part 2:
                      Record I/O, random access, using handles.

         Session 14 - Miscellaneous topics:
                      The goto statement, labels, models, separate
                      compilation, projects, bitwise operators, operator
                      precedence,


./ ADD NAME=TEMPCONV 0100-02144-02144-0950-00059-00059-00000-BC0THOR
         /***************************************************************/
         /*                         tempconv.c                          */
         /* tempconv.c converts a celcius temperature to the equivalent */
         /* fahrenheit temperature and displays both temperatures. The  */
         /* celcius temperatures are contained in a table within the    */
         /* program, and only positive temperatures produce a display.  */
         /***************************************************************/

         #include <stdio.h>              /* include standard I/O header */

         #define MAX_ENTRIES 3           /* define MAX_ENTRIES = 3      */

         float fahrenheit;               /* define fahrenheit           */
         float celcius[MAX_ENTRIES] = {-12.5, 32.0, 212.0}; /* celcius  */
         int i;                          /* define i                    */

         void compute_fahrenheit(void);  /* compute_fahrenheit prototype*/


         /***************************************************************/
         /* main function: initial entry point for program              */
         /***************************************************************/

         void main() {

           i = 0;                        /* set i to zero               */
           if(celcius[i] > 0.0) {        /* positive celcius value?     */
             compute_fahrenheit();          /* yes, go convert          */
             printf("%f celcius = %f fahrenheit\n",celcius[i],fahrenheit);
           }

           i = 1;                        /* set i to one                */
           if(celcius[i] > 0.0) {        /* positive celcius value?     */
             compute_fahrenheit();          /* yes, go convert          */
             printf("%f celcius = %f fahrenheit\n",celcius[i],fahrenheit);
           }

           i = 2;                        /* set i to two                */
           if(celcius[i] > 0.0) {        /* positive celcius value?     */
             compute_fahrenheit();          /* yes, go convert          */
             printf("%f celcius = %f fahrenheit\n",celcius[i],fahrenheit);
           }

         }                               /* end of main function        */

         /***************************************************************/
         /* compute_fahrenheit: compute the fahrenheit equivalent to a  */
         /* celcius temperature.                                        */
         /***************************************************************/

         void compute_fahrenheit(void) {  /* compute_fahrenheit header  */
           /*************************************************************/
           /* The calculation below computes the fahrenheit equivalent  */
           /* of a celcius temperature as:                              */
           /*    fahrenheit = (9/5 * celcius) + 32                      */
           /*************************************************************/
           fahrenheit = ((((celcius[i]) * 9) / 5) + 32);
         }                               /* end of compute_fahrenheit   */

./ ADD NAME=VER2EDIT 0100-02144-02144-0950-00060-00060-00000-BC0THOR
  *****************************************************************************
  *                           TURBO-C EDITOR COMMANDS              EDITOR2.002*

  *****************************************************************************

  Cursor Left                Left Arrow       Insert Mode toggle         Ins

  Cursor Right               Right Arrow      Bookmark, Set 0-3          cL0-3

  Cursor Up                  Up Arrow         Bookmark, Move to 0-3      cK0-3

  Cursor Down                Down Arrow       Move to Previous Pos       cKP

  Cursor to Left of Line     Home             Line, Insert               cJ

  Cursor to Right of Line    End              Line, Delete               cD

  Cursor to Top of Screen    cHome            Line, Erase to End         cE

  Cursor to Bottom of Screen cEnd             Line, Restore              cKR

  Cursor to Top of File      cT               Find Matching }, ], )      c]

  Cursor to Bottom of File   cB               Find Match Prev {, [, (    c[

  Screen Scroll Up           cW               Find String                cF

  Screen Scroll Down         cZ               Find & Replace             cR

  Screen Page Up             PgUp             Find, Repeat               cU

  Screen Page Down           PgDn               B=Backward, W=Whole Words,

  Block, Mark Begin          cS                 G=Global, L=Local in Block

  Block, Mark End            cV                 N=Auto Replace, U=Ignore Case

  Block, Move to Begin       cQ               Character, Delete          Del

  Block, Move to End         cA               Character, Delete Left     Backspa
ce
  Block, Hide/Show toggle    cH               Tab                        Tab

  Block, Copy Above Cursor   cC               Tab, toggle                cKT

  Block, Move Above Cursor   cG               Autoindent toggle          sTab

  Block, Delete              cY               Unindent toggle            cKX

  Block, Read From Disk      cN               Insert Control Char        cKC

  Block, Write to Disk       cO               Optimal Fill toggle        cKB

  Block, Indent              cKI              Abort Operation            Esc

  Block, Unindent            cKU              Exit Editor                cX

  Block, Print               cP               Language Help              cF1


./ ADD NAME=VER2LSN1 0100-02144-02144-0950-00139-00139-00000-BC0THOR
         *----------------------------------------------------------------*
         *                    Elementary C Programming         LESSON2.001*
         *----------------------------------------------------------------*
                          Session 1 - Getting Started                Page 1

         I.  Install Turbo C Version 2.0 (DOS).
             A. Put the INSTALL disk in the A drive.
             B. Enter a:install
                1. At first window press ENTER to continue
                2. At second window press ENTER to use drive A for input
                3. At third window press the down-arrow about 7 times until
                   the START INSTALLATION selection is highlighted, then
                   press ENTER.
                4. Follow directions until installation is complete.
             D. Check to see that CONFIG.SYS contains FILES=20 or more. If
                not, add it using an ASCII editor (NOT WP).
             E. Edit AUTOEXEC.BAT and add to the PATH list:
                        ;C:\TC;C:\TC\OUTPUT
             F. Create subdirectories CSOURCE and OUTPUT under the TC
                directory:
                1. Enter cd c:\tc
                2. Enter md c:\csource
                3. Enter md c:\output
             G. Re-boot the machine to make the updated CONFIG.SYS and
                AUTOEXEC.BAT active.
             H. Configure Turbo C for your environment.
                1. Enter cd c:\tc\csource
                2. Enter tc
                3. When the TURBO C window appears enter Alt-O
                4. When the Options pull-down appears, enter D
                5. When the directories window appears, enter O
                6. In the Output Directory window, enter C:\TC\OUTPUT
                7. Enter T
                8. In the Turbo C Directory window, enter C:\TC\CSOURCE
                9. Press Esc to get back to the Options window, then press
                   S to save.
                10. Enter C:\TC\CSOURCE
                11. Press Esc to return to the EDIT window.
             I. References
                1. Turbo C User's Guide pages 10-12.

         II. Test the Turbo C installation.
             A. Enter Alt-F to get the File pull-down.
             B. Enter N for a new source file
             C. Enter the following program (observe case):
                 /* hello.c -- Hello, World! */
                 #include <stdio.h>
                 main() {
                   printf("\nHello, World!");
                 }
             D. To save the program enter Alt-F to get the File pull-down,
                then W to get the New Name window and enter hello.c as the
                name of the program.
             E. Press Ctrl-F9 to compile and run the program. If all goes
                well you will see a compile window, then a linker window,
                then a flicker as the program executes, then the EDIT screen.
                If you're having a bad day, you may get an error. Fix the code
                and try again.
         *----------------------------------------------------------------*
         *                    Elementary C Programming         LESSON2.001*
         *----------------------------------------------------------------*
                          Session 1 - Getting Started                Page 2

             F. To check the program output enter Alt-F5. This should show you
                the DOS command screen with the display showing:
                      Hello, World!
             G. Press any key to return to the Integrated Development
                Environment (IDE).
             H. References: Turbo C User's Guide page 10.

         III. Using the Integrated Development Environment.
             A. To activate the menu bar, press F10 then use the left and
                right arrow keys to select the desired pull-down. You can also
                enter Alt- followed by the first letter of the desired pull-
                down (A, E, R, C, P, O, D, or B) to go directly.
             B. Along the bottom of the IDE screen you can see some of the F-
                key values. If you press and hold the Alt key a few seconds
                the values change to the Alt-f-key values.
             C. F1 is the HELP key and gives information on use of the editor.
                To exit HELP, press Esc.
             D. Move the cursor to any letter within the word printf on the
                edit screen, then press Ctrl-F1. This gives language help for
                the item under the cursor. If the item selected has no help, a
                general screen is presented with two selectable items:
                keywords and header files. When in the language help area you
                can use the arrow keys to select other related topics. Press
                enter at any of these to display the related topic. To exit
                language help, press Esc.
             E. You may notice your IDE screen has two windows showing, a
                large one at the top with the name Edit and a smaller one near
                the bottom with the name Watch. The Edit window has a double
                line across the top, showing it is the "active" window. If you
                press F6, the Watch window will become the "active" window.
                You can use the F6 key to switch between any windows on the
                screen. To make the "active" window occupy the full screen,
                press F5, the "zoom" key. To restore it to the smaller size,
                press F5 again.
             F. Another useful key is F9, which does a Make on your program.
                This is equivalent to a compile and link - very handy.
             G. Alt-F5 is used to switch displays to the DOS screen so you can
                see the output of programs run while in the IDE. Pressing any
                key returns you to the IDE.
             H. The C language uses a lot of symbol pairs, such as (), {}, [],
                "", and /* */. It is often important to be able to identify
                the matching symbol within a pair. To do this, put the cursor
                on one of the symbols, then press Ctrl-Q-[. The display will
                scroll if necessary and the cursor will be on the opposite
                symbol of the pair.
             I. References: Turbo C User's Guide chapters 3 and 7.
         *----------------------------------------------------------------*
         *                    Elementary C Programming         LESSON2.001*
         *----------------------------------------------------------------*
                          Session 1 - Getting Started                Page 3
         IV. Turbo C Utilities
             A. Utility programs are executed outside the IDE at the normal
                DOS prompt.
             B. The TOUCH utility is used to force the compiler to recompile a
                program. This is sometimes necessary, as the compiler compares
                the file dates to decide if a compile is necessary, and if it
                decides the current program is current it will not recompile.
             C. GREP is a general purpose file searching program.
             D. TCINST can be used to change many installation options, but it
                is of most use in changing the Editor key uses. When you enter
                tcinst, an installation menu appears. Choose the Editor
                Commands selection. A scrollable window of Editor command keys
                appears which shows primary commands on the left and secondary
                on the right. Use arrow keys to select the command to change,
                then press enter and type in the change, then press enter to
                make it active or Esc to ignore the changes. Typing R will
                restore all commands to their default values. Pressing F4
                rotates between wordstar-like, ignore case, and verbatim. When
                changes are complete, enter Esc, then Q to quit and save, then
                Y to save or N to exit without saving. Making changes can
                provide much improved operation, however the manual and help
                screens will no longer be correct for the changed keys.
             E. References: Turbo C Reference Guide pages 22, 509, 565-569,
                481.


./ ADD NAME=VER3EDIT 0100-02144-02144-0950-00037-00037-00000-BC0THOR

                      ***** TURBO-C++ EDITOR COMMANDS *****

*************************************************************************
* Cursor to Left of Line     Home    Bookmark, Set 0-3          cL0-3 *
* Cursor to Right of Line    End     Bookmark, Move to 0-3      cK0-3 *
* Cursor to Top of Screen    cHome   Move to Previous Pos       cS    *
* Cursor to Bottom of Screen cEnd    Line, Insert               cJ    *
* Cursor to Top of File      cT      Line, Delete               cD    *
* Cursor to Bottom of File   cB      Line, Erase to End         cE    *
* Screen Scroll Up           cW      Find Matching }, ], )      c]    *
* Screen Scroll Down         cZ      Find String                cF    *
* Block, Mark Begin          cLfAr   Find & Replace             cR    *
* Block, Mark End            cRgAr   Find Next Occurrence       cU    *
* Block, Hide/Show toggle    cPgDn   Language Help              cF1   *
* Block, Copy                cC                                       *
* Block, Move                cG                                       *
* Block, Delete              cY                                       *
* Block, Read From Disk      cN                                       *
* Block, Write to Disk       cO      C:\TC3\DOC\DICK.TEM              *
*************************************************************************
















./ ADD NAME=VER3LSN1 0100-02144-02144-0950-00099-00099-00000-BC0THOR
         *----------------------------------------------------------------*
         *                    Elementary C Programming         LESSON3.001*
         *----------------------------------------------------------------*
                             Session 1 - Getting Started            Page 1

         I. Session 1
            A. Install Turbo C++ Version 3.0 (DOS)
               .Must have 10,000,000 bytes free on hard drive
               .Put Disk 1 in the A drive
               .Type A:INSTALL and press ENTER
               .Press ENTER for Source Drive is A
               .Arrow down to Start Installation, press ENTER
               .Remove/Insert disks as requested until all 5 are done
               .At end press ENTER, then ESC to get out of README
            B. Make source and output directories
               .Type following lines (ENTER after each):
                CD C:\TC
                MD CSOURCE
                MD OUTPUT
            C. If running a DOS window under OS2:
               .Right click on ICON for the DOS window to be used.
               .Left click on Open
               .Left click on Settings
               .Left click on Session
               .Left click on DOS Settings
               .Left click on DOS_AUTOEXEC
               .Note name in the Value: window at right. This is the name
                of the AUTOEXEC.BAT file for this session.
               .Scroll window until DPMI_DOS_API appears.
               .Left click on DPMI_DOS_API
               .Left click on right end of the Value: window.
               .Left click on ENABLED
               .Left click on Save (bottom left)
               .Double-click on upper left of Generic - Settings window
            D. Set up DOS System files using a file editor. Be sure to use
               a simple ASCII editor such as EDLIN or DOS's EDIT, not one
               like WordPerfect which adds control information to the file.
               .Put FILES=20 (or more) in CONFIG.SYS
               .Add ;C:\TC\BIN;C:\TC\OUTPUT to path in AUTOEXEC.BAT
               .Create C:\TC.BAT containing the following lines:
                CD C:\TC\CSOURCE
                C:\TC\BIN\TC
                CD C:\
            E. Re-Boot the system to bring in the updated system files. If
               you are running DOS under OS2, just close the session and
               reopen it.
            F. At the C:\> prompt, type TC. This should start Turbo C++
               which will display a window with information about Turbo C++
               and with OK at the bottom. Press ENTER to continue.
            G. Activate the Options pull-down menu by typing Alt-O or
               F10/O.
            H. Type D to activate the Directories window.
            I. Tab to the Output Directories window and type C:\TC\OUTPUT
               (do not press ENTER).
            J. Tab to the Source Directories window and type C:\TC\CSOURCE
               then press ENTER.
            K. The pull-downs will disappear, leaving the Options menu
               selection highlighted. Press ENTER for the pull-down, then
               type S for the save window, then press ENTER to save.
         *----------------------------------------------------------------*
         *                    Elementary C Programming         LESSON3.001*
         *----------------------------------------------------------------*
                             Session 1 - Getting Started            Page 2

            L. Create, compile, and execute a short program.
               .Start a Turbo C++ session by typing TC and pressing ENTER.
               .Open a file by typing Alf-F/O or just F3
               .The name window will contain *.CPP initially. Ignore this
                and type HELLO.C which will replace the *.CPP, then press
                ENTER.
               .An EDIT window will open with a double line around it,
                showing it is the "active" window. HELLO.C will appear
                centered at the top.
               .Type the following lines (ENTER after each line):
                main() {
                  printf("Hello, World!");
                }
               .Save this source program by pressing F2.
               .Compile and link (Make) the program by pressing F9.
               .A window should appear saying "Success Press Any Key".
                Press any key.
               .The edit screen reappears with a MESSAGE screen at the
                bottom. The double line is on the MESSAGE screen, which is
                the "active" screen. The messages include a warning
                concerning function returning a value. Note that the arrow
                keys move you around in the MESSAGE window.
               .Switch to the EDIT window by pressing F6
               .Move the cursor to one of the letters in the word printf
                and press Ctrl-F1 for HELP concerning this function.
               .Scroll down the HELP window until you see the Return Value
                header. This explains the value returned by printf.
               .Since we only got a warning, the program should execute. To
                run the program, press Alt-R/R or Ctrl-F9. The program will
                execute. Since it writes to the screen, your screen will
                blink momentarily.
               .To view the output of the program press Alt-F5. You should
                see Hello, World! as the last line displayed. To return to
                Turbo C++, press any key.
               .Press Alt-X to exit from Turbo C++.
