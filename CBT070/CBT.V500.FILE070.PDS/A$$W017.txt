++USERMOD (A$$W017)   /*
      THIS USERMOD IS TO INSTALL THE
      PCS NUMBER VALIDATION SVC

      SVC = 226 - TYPE 4

      MOD HISTORY:
          07/27/88 - INITIAL BUILD
                                                     07/27/88 BRM  */.
++VER (Z038) FMID(A$$SVCS) .
++JCLIN .
//A$$W017 JOB WC07N0323,'W1-5311  CR SINGER'
//LPASVC  EXEC LINKS,
// PARM='NCAL,LIST,XREF,LET,REUS,RENT,AMODE=31,RMODE=ANY,AC=1',
//    UNIT='3380',SER=IPLXXX,N=SYS2,NAME=HSSLPA,P1=' ',
//    MOD=,P2=' ',OBJ=OBJPDS01,CLASS=T
//SYSLIN   DD  *
   INCLUDE SYSPUNCH(WCSVC226)
   NAME WCSVC226(R)
/*
++MAC (PCSVER) DISTLIB(ASAMPLIB) SYSLIB(SYS3MAC).
         MACRO
&NAME    PCSVER  &PCS,&LOGID,&MF=I
.**********************************************************************
.*       VALIDATE GENERAL DYNAMICS PCS ACCOUNTING NUMBERS             *
.**********************************************************************
.*                                                                    *
.*       PCSVER  PCS@,LOGID@,MF=                                      *
.*                                                                    *
.*    PCS    - ADDRESS OF PCS NUMBER TO BE VALIDATED.                 *
.*             THIS PARAMETER IS REQUIRED.                            *
.*                                                                    *
.*    LOGID  - ADDRESS OF LOGON-ID TO BE VALIDATED IN                 *
.*             CONJUCTION WITH THE PCS NUMBER.                        *
.*             THIS PARAMETER IS OPTIONAL.                            *
.*                                                                    *
.*    MF=I         -INCLUDE FORM.                                     *
.*       L         -LIST FORM                                         *
.*       (E,PARM@) -EXECUTE FORM. PARM@ IS ADDRESS OF PARAMETER       *
.*                  LIST.                                             *
.*                                                                    *
.*    ALL ADRESSES MAY BE AN RX-TYPE OR REGISTER-TYPE.                *
.*                                                                    *
.**********************************************************************
.*
         LCLA  &P#SW,&P1SW,&P2SW
         LCLC  &RR0,&RR4
.*
.*             &P#SW SETTINGS ARE
.*              1  -  PCS PARM PASSED
.*              2  -  PCS AND LOGON-ID PARMS PASSED
.*
.*             &P1SW SETTINGS ARE (PCS PARAMETER):
.*              1  -  ADDRESS TYPE IS REGISTER
.*              2  -  ADDRESS TYPE IS RX-TYPE
.*
.*
.*             &P2SW SETTINGS ARE (LOGOIN-ID PARAMETER):
.*              1  -  ADDRESS TYPE IS REGISTER
.*              2  -  ADDRESS TYPE IS RX-TYPE
.*
&P#SW    SETA  0                        SET DEFAULT
&P1SW    SETA  0                        SET DEFAULT REGISTER ADDR
&P2SW    SETA  0                        SET DEFAULT REGISTER ADDR
.* *****************************************************************
.* PARSE PARAMETERS
.* *****************************************************************
         AIF   ('&PCS' EQ '').CHKLOGS
&P1SW    SETA  1
&P#SW    SETA  1
         AIF   ('&PCS'(1,1) EQ '(').CHKLOGS
&P1SW    SETA  2
.CHKLOGS ANOP
         AIF   ('&LOGID' EQ '').CHKMFS
&P2SW    SETA  1
&P#SW    SETA  2
         AIF   ('&LOGID'(1,1) EQ '(').CHKMFS
&P2SW    SETA  2
.*
.CHKMFS  ANOP
         AIF   ('&MF' EQ 'I').MFINCL    IF MF=E GOTO .MFINCL
         AIF   ('&MF' EQ 'L').MFLIST    IF MF=E GOTO .MFLIST
         AIF   (N'&MF NE 2).BADPARM     IF MF= INVALID GOTO .BADPARM
         AIF   ('&MF(1)' EQ 'E').MFEXEC IF MF=E GOTO .MFEXEC
         AGO   .BADPARM
.*
.MFINCL  ANOP
.*
         AIF   (&P#SW EQ 0).NOPCS
.*
         CNOP  0,4                ALIGN TO FULLWORD BOUNDARY
.*
         AIF   (&P#SW EQ 1).DOP1             ONLY PCS PARM PASSED
.* *****************************************************************
.*       PCS AND LOGON-ID PARAMETERS PASSED TO MACRO
.* *****************************************************************
         AIF   (&P1SW NE &P2SW).DOMIX        ADDR-TYPE MIXED ?
         AIF   (&P1SW EQ 1).DOREG            ADDR-TYPES REGISTER ?
         LA    1,&PCS             -> PCS NUMBER
         ST    1,*+16             STORE PCS ADDR IN PARM
         LA    1,&LOGID           -> LOGON-ID
         ST    1,*+12             STORE LOGON-ID ADDR IN PARM
         AGO   .P2END
.DOREG   ANOP
         ST    &PCS,*+12          STORE PCS ADDR IN PARM
         ST    &LOGID,*+12        STORE LOGON-ID ADDR IN PARM
         AGO   .P2END
.DOMIX   ANOP
         AIF   (&P1SW EQ 1).DOMIX2
         LA    1,&PCS             -> PCS NUMBER
         ST    1,*+12             STORE PCS ADDR IN PARM
         ST    &LOGID,*+12        STORE LOGON-ID ADDR IN PARM
         AGO   .P2END
.DOMIX2  ANOP
         ST    &PCS,*+16          STORE PCS ADDR IN PARM
         LA    1,&LOGID           -> LOGON-ID
         ST    1,*+12             STORE LOGON-ID ADDR IN PARM
         AGO   .P2END
.P2END   ANOP
         BAL   1,*+12             PARM ADDR IN REG 1
&NAME    DS    F                  PARM1 - PCS ->
         DS    F                  PARM2 - LOGON-ID ->
         SVC   226                VALIDATE PCS NUMBER
         MEXIT
.* *******************************************************************
.*       ONLY PCS PARAMETER PASSED TO MACRO
.* *******************************************************************
.DOP1    ANOP
         AIF   (&P1SW EQ 1).P1ST             IF REG PASSED GO TO P1ST
.*
.*       PCS PARAMETER IS AN RX-TYPE ADDRESS
.*
         LA    1,&PCS             -> PCS NUMBER
         ST    1,*+8              STORE PCS ADDR IN PARM
         AGO   .P1END
.P1ST    ANOP
.*
.*       PCS PARAMETER IS A REGISTER
.*
         ST    &PCS,*+8           STORE PCS ADDR IN PARM
         AGO   .P1END
.*
.P1END   ANOP
         BAL   1,*+12             PARM ADDR IN REG 1
&NAME    DS    F                  PARM 1
         DC    A(0)               PARM 2
         SVC   226                VALIDATE PCS NUMBER
.*
         MEXIT
.* *******************************************************************
.* MF=L SPECIFIED
.* *******************************************************************
.MFLIST  ANOP
         AIF   ('&NAME' EQ '').NONAME
         AIF   (&P#SW EQ 0).NOPCS
         AIF   (&P1SW EQ 1 OR &P2SW EQ 1).NORX
         AIF   (&P#SW EQ 2).MFLTWO
.* **********************************
.* BUILD PARAMETER LIST OF PCS@     *
.* **********************************
&NAME    DC    A(&PCS)            PARM 1
         DC    A(0)               PARM 2
.*
         MEXIT
.*
.MFLTWO  ANOP
.* ******************************************
.* BUILD PARAMETER LIST OF PCS@ AND LOGONID *
.* ******************************************
&NAME    DC    A(&PCS)            PARM 1
         DC    A(&LOGID)          PARM 2
.*
         MEXIT
.*
.* *****************************************************************
.*       PCS AND LOGON-ID PARAMETERS PASSED TO MACRO
.* *****************************************************************
         AIF   (&P1SW NE &P2SW).DOMIX        ADDR-TYPE MIXED ?
         AIF   (&P1SW EQ 1).DOREG            ADDR-TYPES REGISTER ?
         AGO   .MFINCL
.* *******************************************************************
.* MF=E SPECIFIED
.* *******************************************************************
.*
.MFEXEC  ANOP
         AIF   (&P#SW EQ 0).MFEGO
         AIF   (&P1SW EQ 2).MFEP1RX          IF PCS@ = RX TYPE
.* **********************************
.* PCS@ = REGISTER TYPE             *
.* **********************************
         AIF   ('&MF(2)'(1,1) EQ '(').P1RX1RR IF PARM@ = REG TYPE
         ST    &PCS,&MF(2)        STORE PCS ADDRESS IN PARM AREA
         AIF   (&P#SW EQ 2).MFEP2GO
         AGO   .MFEGO
.P1RX1RR ANOP
&RR0     SETC  '0'.'&MF(2)'
         ST    &PCS,&RR0          STORE PCS ADDRESS IN PARM AREA
         AIF   (&P#SW EQ 2).MFEP2GO
         AGO   .MFEGO
.MFEP1RX ANOP
.* **********************************
.* PCS@ = RX TYPE                   *
.* **********************************
         AIF   ('&MF(2)'(1,1) EQ '(').P1RX2RX IF PARM@ = REG TYPE
         LA    1,&PCS             GET PCS ADDRESS
         ST    1,&MF(2)           STORE PCS ADDRESS IN PARM
         AIF   (&P#SW EQ 2).MFEP2GO
         AGO   .MFEGO
.P1RX2RX ANOP
&RR0     SETC  '0'.'&MF(2)'
         LA    1,&PCS             GET PCS ADDRESS
         ST    1,&RR0             STORE PCS ADDRESS IN PARM
         AIF   (&P#SW EQ 2).MFEP2GO
         AGO   .MFEGO
.*
.MFEP2GO ANOP
         AIF   (&P2SW EQ 2).MFEP2RX          IF LOGID@ = RX TYPE
.* **********************************
.* LOGID@ = REGISTER TYPE           *
.* **********************************
         AIF   ('&MF(2)'(1,1) EQ '(').P2RX1RR IF PARM@ = REG TYPE
         ST    &LOGID,&MF(2)+4    STORE LOGON-ID ADDRESS IN PARM AREA
         AGO   .MFEGO
.P2RX1RR ANOP
&RR4     SETC  '4'.'&MF(2)'
         ST    &LOGID,&RR4        STORE LOGON-ID ADDRESS IN PARM AREA
         AGO   .MFEGO
.MFEP2RX ANOP
.* **********************************
.* LOGID@ = RX TYPE                 *
.* **********************************
         AIF   ('&MF(2)'(1,1) EQ '(').P2RX2RX IF PARM@ = REG TYPE
         LA    1,&LOGID           GET PCS ADDRESS
         ST    1,&MF(2)+4         STORE PCS ADDRESS IN PARM
         AGO   .MFEGO
.P2RX2RX ANOP
&RR4     SETC  '4'.'&MF(2)'
         LA    1,&LOGID           GET PCS ADDRESS
         ST    1,&RR4             STORE PCS ADDRESS IN PARM
         AGO   .MFEGO
.*
.MFEGO   ANOP
         AIF   ('&MF(2)'(1,1) EQ '(').MFEREG   IF REGISTER BRANCH OUT
         LA    1,&MF(2)           PARM ADDR IN REG 1
&NAME    SVC   226                VALIDATE PCS NUMBER
         MEXIT
.MFEREG  ANOP
         AIF   ('&MF(2)'(1,3) EQ '(1)').MFESVC
         LR    1,&MF(2)           PARM ADDR IN REG 1
.MFESVC  ANOP
&NAME    SVC   226                VALIDATE PCS NUMBER
         MEXIT
.*
.NOPCS   ANOP
         MNOTE  8,'*** PCS PARAMETER MISSING ***'
         MEXIT
.*
.NORX    ANOP
         MNOTE  8,'***MF=L: PARAMETERS MUST BE RX-TYPE ADDR ***'
         MEXIT
.*
.NONAME  ANOP
         MNOTE  8,'*** LABEL NAME IS MISSING ***'
         MEXIT
.*
.BADPARM ANOP
         MNOTE  8,'*** INVALID MF PARAMETER SPECIFIED ***'
         MEXIT
.*
.NOEPARM ANOP
         MNOTE  8,'*** PARAMETER ADDRESS ON MF=E MISSING ***'
         MEXIT
.*
.FINI    ANOP
         MEXIT
         MEND
++SRC (WCSVC226) DISTLIB(ASRCLIB)  .
*
*   SEVERAL INSTREAM MACROS ARE FIRST. REAL CODE STARTS AT LINE 143800
*
         MACRO
         $POPI
.*********************************************************************
.*********************************************************************
.*       1.  $POPI    POP LABELS FOR THE IF-ELSE-ENDIF MACROS        *
.*********************************************************************
         GBLC  &$LBL
         GBLA  &$LIFNDX,&$LVLI,&$STACKI(50)
&$LBL    SETC  '$LIF&$STACKI(&$LVLI)'
&$LVLI   SETA  &$LVLI-1
         MEND
         MACRO
         $PUSHI
.*********************************************************************
.*********************************************************************
.*       1.  $PUSHI    PUSH LABELS FOR THE IF-ELSE-ENDIF MACROS      *
.*********************************************************************
         GBLC  &$LBL
         GBLA  &$LIFNDX,&$LVLI,&$STACKI(50)
.*
.*       1. RETURNS A NEW LABEL IN $LBL.
.*       2. SETS THIS LABEL ON TOP OF THE STACK
.*
&$LIFNDX SETA  &$LIFNDX+1     INCREMENT INDEX
&$LVLI   SETA  &$LVLI+1       INCREMANT LEVEL
&$LBL    SETC  '$LIF&$LIFNDX'      SET LABEL VALUE
&$STACKI(&$LVLI) SETA &$LIFNDX     SET CURRENT INDEX ON CURRENT LEVEL
         MEND
         MACRO
         $UPSEL
.*********************************************************************
.* $UPSEL    PUSH LABELS FOR THE SELECT-WHEN-OTHERWISE MACROS        *
.*********************************************************************
         GBLC  &$LBSEL
         GBLA  &$SELNDX,&$LVSEL,&$STKSEL(50)
.*
.*       1. RETURNS A NEW LABEL IN $LBSEL.
.*       2. SETS THIS LABEL ON TOP OF THE STACK
.*
&$SELNDX SETA  &$SELNDX+1           INCREMENT INDEX
&$LVSEL  SETA  &$LVSEL+1            INCREMANT LEVEL
&$LBSEL  SETC  '$ESEL&$SELNDX'      SET LABEL VALUE
&$STKSEL(&$LVSEL) SETA &$SELNDX     SET CURRENT INDEX ON CURRENT LEVEL
         MEND
         MACRO
         $UPWHEN
.*********************************************************************
.* $UPWHEN   PUSH LABELS FOR THE SELECT-WHEN-OTHERWISE MACROS        *
.*********************************************************************
         GBLC  &$LBWIN
         GBLA  &$WINDEX,&$LVWIN,&$STKWIN(50)
.*
.*       1. RETURNS A NEW LABEL IN $LBWIN.
.*       2. SETS THIS LABEL ON TOP OF THE STACK
.*
&$WINDEX SETA  &$WINDEX+1           INCREMENT INDEX
&$LVWIN  SETA  &$LVWIN+1            INCREMANT LEVEL
&$LBWIN  SETC  '$WHEN&$WINDEX'      SET LABEL VALUE
&$STKWIN(&$LVWIN) SETA &$WINDEX     SET CURRENT INDEX ON CURRENT LEVEL
         MEND
         MACRO
         ELSE
.*********************************************************************
.*********************************************************************
.*       ELSE                                                        *
.*********************************************************************
         GBLC  &$LBL
         GBLA  &$LIFNDX,&$LVLI,&$STACKI(50)
         LCLC  &X
         $POPI
&X       SETC  '&$LBL'
         $PUSHI
         B     &$LBL
&X       DS    0H
         MEND
         MACRO
         ENDIF
.*********************************************************************
.*********************************************************************
.*       ENDIF                                                       *
.*********************************************************************
         GBLC  &$LBL
         GBLA  &$LIFNDX,&$LVLI,&$STACKI(50)
         $POPI
&$LBL    DS    0H
         MEND
         MACRO
         ENDSEL
.*********************************************************************
.*       ENDSEL  EXIT POINT FOR SELECT/WHEN/ENDSEL CONSTRUCT         *
.*               1. GENERATE ENDSELECT LABEL                         *
.*********************************************************************
         GBLC  &$LBSEL
         GBLA  &$SELNDX,&$LVSEL,&$STKSEL(50)
         LCLC  &X
&X       SETC  '&$LBSEL'
&X       DS    0H
         MEND
         MACRO
         ENDWHEN
.*********************************************************************
.*       ENDWHEN EXIT POINT FOR WHEN/ENDWHEN CONSTRUCT               *
.*               1. BRANCH TO ENDSELECT LABEL                        *
.*********************************************************************
         GBLC  &$LBSEL
         GBLA  &$SELNDX,&$LVSEL,&$STKSEL(50)
         B     &$LBSEL
         MEND
         MACRO
.*********************************************************************
.*       EXIT         USED TO RETURN TO CALLERS                      *
.*             1. EXIT 8               --RETURN CODE IS 8            *
.*             2. EXIT (15)            --RETURN CODE IN REG15        *
.*             3. EXIT 8,FREE,R3,LEN   --RETURN CODE IS 8,           *
.*                                       FREEMAIN AREA ADDR BY R3,   *
.*                                       LEN = FULLWORD AREA NAME    *
.*                                             CONTAINING LL TO FREE *
.*********************************************************************
&NAME    EXIT  &RC,&FREE,&REG=,&SVLEN=
         LCLC  &REG1,&REG2,&REGSW,&RCSW
&REG1    SETC  '14'
&REG2    SETC  '12'
&REGSW   SETC  ' '
&RCSW    SETC  ' '
         SPACE
         AIF   ('&REG' EQ '').NOREG
         AIF   (N'&REG GT 2).REGPL
         AIF   (N'&REG EQ 1).REGONE
&REG1    SETC  '&REG(1)'
&REG2    SETC  '&REG(2)'
         AGO   .NOREG
.REGPL   ANOP
         MNOTE 4,'***** MORE THAN 2 ''REG'' OPERANDS, ENTRY IGNORED'
         AGO   .NOREG
.REGONE  ANOP
&REG1    SETC  '&REG(1)'
&REGSW   SETC  '1'
.NOREG   ANOP
&NAME    L     13,4(,13)                GET ADDR OF PREV SAVE CHAIN
         STM   15,1,16(13)              SAVE PARAM REGS
         AIF   ('&FREE' EQ '').RCCK     IS FREE PARAMETER PRESENT
         AIF   ('&FREE' EQ 'FREE').DOF  IS FREE PARAMETER VALID
         MNOTE 8,******** ''FREE'' PARAMETER IS NOT VALID AND IS IGNOREX
               D
         AGO   .RCCK
.DOF     ANOP
         L     1,8(,13)                 GET SAVE AREA ADDRESS
         AIF   ('&SVLEN' EQ '').DOFA
         L     0,&SVLEN                 LENGTH TO FREE IN REG 0
         AGO   .DOFB
.DOFA    ANOP
         LA    0,72                     LENGTH TO FREE
.DOFB    ANOP
         FREEMAIN R,LV=(0),A=(1)        ISSUE FREEMAIN
.RCCK    ANOP
         XC    8(4,13),8(13)            DE-CHAIN CURRENT ENTRY
         AIF   ('&RC' EQ '').NORC
         AIF   ('&RC'(1,1) EQ '(').REGRC
         AIF   ('&RC' GT '4095').BADRC
&RCSW    SETC  '1'
         AGO   .NORC
.REGRC   ANOP
&RCSW    SETC  '2'
         AGO   .NORC
.BADRC   ANOP
         MNOTE 4,'***** RETURN CODE (RC) GREATER THAN 4095, ENTRY IGNORX
               ED'
         AGO   .NORC
.*
.NORC    ANOP
         AIF   ('&RCSW' NE ' ').TYPE2
         AIF   ('&REGSW' EQ '1').TYPE1A
         RETURN (&REG1,&REG2)
         SPACE
         MEXIT
.TYPE1A  ANOP
         RETURN (&REG1)
         SPACE
         MEXIT
.*
.TYPE2   ANOP
         AIF   ('&RCSW' NE '1').TYPE3
         AIF   ('&REGSW' EQ '1').TYPE2A
         RETURN (&REG1,&REG2),RC=&RC
         SPACE
         MEXIT
.TYPE2A  ANOP
         RETURN (&REG1),RC=&RC
         SPACE
         MEXIT
.*
.TYPE3   ANOP
         AIF   ('&RC(1)' EQ '15').IS15
         AIF   ('&RC(1)' EQ 'R15').IS15
         LR    15,&RC(1)                SHIFT RETURN CODE TO REG 15
         AGO   .RTN3
.IS15    ANOP
         L     15,16(,13)               RESTORE REG 15
.RTN3    AIF   ('&REGSW' EQ '1').TYPE3A
         RETURN (&REG1,&REG2),RC=(15)
         SPACE
         MEXIT
.TYPE3A  ANOP
         RETURN (&REG1),RC=(15)
         SPACE
         MEND
         MACRO
&LABEL   GOTO  &LB,&TEST,&R
&LABEL   JUMP  &LB,&TEST,&R
         MEND
         MACRO
         IF    &P1,&P2,&P3,&P4
.*********************************************************************
.*       1.  IF    CLI,A,NE,B                                        *
.*       2.  IF    (CLI,A,NE,B),AND,(CLC,A,E,B)                      *
.*       3.  IF    (CLI,A,NE,B),OR,(CLC,A,E,B)                       *
.*********************************************************************
         LCLC  &SYM
         GBLC  &$LBL
         GBLA  &$LIFNDX,&$LVLI,&$STACKI(50)
         AIF   ('&P1'(1,1) EQ '(').COMPLEX
         AIF   ('&P3' NE 'EQ').CHKEQ2
.*********************************************************************
.*                                        CONVERT 'EQ' TO 'E'        *
.*********************************************************************
&SYM     SETC  'E '
         AGO   .SIMPLE
.CHKEQ2  ANOP
         AIF   ('&P3' NE '=').CHKGT1
.*********************************************************************
.*                                        CONVERT '=' TO 'E'         *
.*********************************************************************
&SYM     SETC  'E '
         AGO   .SIMPLE
.CHKGT1  ANOP
         AIF   ('&P3' NE 'GT').CHKGT2
.*********************************************************************
.*                                        CONVERT 'GT' TO 'H'        *
.*********************************************************************
&SYM     SETC  'H '
         AGO   .SIMPLE
.CHKGT2  ANOP
         AIF   ('&P3' NE '>').CHKLT1
.*********************************************************************
.*                                        CONVERT '>'  TO 'H'        *
.*********************************************************************
&SYM     SETC  'H '
         AGO   .SIMPLE
.CHKLT1  ANOP
         AIF   ('&P3' NE 'LT').CHKLT2
.*********************************************************************
.*                                        CONVERT 'LT' TO 'L'        *
.*********************************************************************
&SYM     SETC  'L '
         AGO   .SIMPLE
.CHKLT2  ANOP
         AIF   ('&P3' NE '<').CHKON
.*********************************************************************
.*                                        CONVERT '<'  TO 'L'        *
.*********************************************************************
&SYM     SETC  'L '
         AGO   .SIMPLE
.CHKON   ANOP
         AIF   ('&P3' NE 'ON').CHKOFF
.*********************************************************************
.*                                       CONVERT 'ON'  TO 'O'        *
.*********************************************************************
&SYM     SETC  'O '
         AGO   .SIMPLE
.CHKOFF  ANOP
         AIF   ('&P3' NE 'OFF').CHKDFLT
.*********************************************************************
.*                                      CONVERT 'OFF'  TO 'Z'        *
.*********************************************************************
&SYM     SETC  'Z '
         AGO   .SIMPLE
.CHKDFLT ANOP
.*********************************************************************
.*                              BRANCH CODE = SUPPLIED PARAMETER     *
.*********************************************************************
&SYM     SETC  '&P3'
.SIMPLE  ANOP
         &P1   &P2,&P4
         B&SYM *+8
         $PUSHI
         B     &$LBL
         MEXIT
.COMPLEX ANOP
         AIF   ('&P1(3)' NE 'EQ').AAAEQ2
.*********************************************************************
.*                                        CONVERT 'EQ' TO 'E'        *
.*********************************************************************
&AAA     SETC  'E '
         AGO   .BBBEQ1
.AAAEQ2  ANOP
         AIF   ('&P1(3)' NE '=').AAAGT1
.*********************************************************************
.*                                        CONVERT '=' TO 'E'         *
.*********************************************************************
&AAA     SETC  'E '
         AGO   .BBBEQ1
.AAAGT1  ANOP
         AIF   ('&P1(3)' NE 'GT').AAAGT2
.*********************************************************************
.*                                        CONVERT 'GT' TO 'H'        *
.*********************************************************************
&AAA     SETC  'H '
         AGO   .BBBEQ1
.AAAGT2  ANOP
         AIF   ('&P1(3)' NE '>').AAALT1
.*********************************************************************
.*                                        CONVERT '>'  TO 'H'        *
.*********************************************************************
&AAA     SETC  'H '
         AGO   .BBBEQ1
.AAALT1  ANOP
         AIF   ('&P1(3)' NE 'LT').AAALT2
.*********************************************************************
.*                                        CONVERT 'LT' TO 'L'        *
.*********************************************************************
&AAA     SETC  'L '
         AGO   .BBBEQ1
.AAALT2  ANOP
         AIF   ('&P1(3)' NE '<').AAAON
.*********************************************************************
.*                                        CONVERT '<'  TO 'L'        *
.*********************************************************************
&AAA     SETC  'L '
         AGO   .BBBEQ1
.AAAON   ANOP
         AIF   ('&P1(3)' NE 'ON').AAAOFF
.*********************************************************************
.*                                       CONVERT 'ON'  TO 'O'        *
.*********************************************************************
&AAA     SETC  'O '
         AGO   .BBBEQ1
.AAAOFF  ANOP
         AIF   ('&P1(3)' NE 'OFF').AAADFLT
.*********************************************************************
.*                                      CONVERT 'OFF'  TO 'Z'        *
.*********************************************************************
&AAA     SETC  'Z '
         AGO   .BBBEQ1
.AAADFLT ANOP
.*********************************************************************
.*                                BRANCH COND = SUPPLIED PARAMETER   *
.*********************************************************************
&AAA     SETC  '&P1(3)'
         AGO   .BBBEQ1
.BBBEQ1  ANOP
         AIF   ('&P3(3)' NE 'EQ').BBBEQ2
.*********************************************************************
.*                                        CONVERT 'EQ' TO 'E'        *
.*********************************************************************
&BBB     SETC  'E '
         AGO   .CMPCONT
.BBBEQ2  ANOP
         AIF   ('&P3(3)' NE '=').BBBGT1
.*********************************************************************
.*                                        CONVERT '=' TO 'E'         *
.*********************************************************************
&BBB     SETC  'E '
         AGO   .CMPCONT
.BBBGT1  ANOP
         AIF   ('&P3(3)' NE 'GT').BBBGT2
.*********************************************************************
.*                                        CONVERT 'GT' TO 'H'        *
.*********************************************************************
&BBB     SETC  'H '
         AGO   .CMPCONT
.BBBGT2  ANOP
         AIF   ('&P3(3)' NE '>').BBBLT1
.*********************************************************************
.*                                        CONVERT '>'  TO 'H'        *
.*********************************************************************
&BBB     SETC  'H '
         AGO   .CMPCONT
.BBBLT1  ANOP
         AIF   ('&P3(3)' NE 'LT').BBBLT2
.*********************************************************************
.*                                        CONVERT 'LT' TO 'L'        *
.*********************************************************************
&BBB     SETC  'L '
         AGO   .CMPCONT
.BBBLT2  ANOP
         AIF   ('&P3(3)' NE '<').BBBON
.*********************************************************************
.*                                        CONVERT '<'  TO 'L'        *
.*********************************************************************
&BBB     SETC  'L '
         AGO   .CMPCONT
.BBBON   ANOP
         AIF   ('&P3(3)' NE 'ON').BBBOFF
.*********************************************************************
.*                                       CONVERT 'ON'  TO 'O'        *
.*********************************************************************
&BBB     SETC  'O '
         AGO   .CMPCONT
.BBBOFF  ANOP
         AIF   ('&P3(3)' NE 'OFF').BBBDFLT
.*********************************************************************
.*                                      CONVERT 'OFF'  TO 'Z'        *
.*********************************************************************
&BBB     SETC  'Z '
         AGO   .CMPCONT
.BBBDFLT ANOP
.*********************************************************************
.*                         BRANCH CODE = SUPPLIED PARAMETER          *
.*********************************************************************
&BBB     SETC  '&P3(3)'
         AGO   .CMPCONT
.CMPCONT ANOP
         AIF   ('&P2' EQ 'AND').CAND
         AIF   ('&P2' EQ 'OR').COR
         MNOTE *,'CONNECTOR MUST BE ''AND'' OR ''OR'''
         MEXIT
.CAND    ANOP
         &P1(1) &P1(2),&P1(4)
         B&AAA *+8
         $PUSHI
         B     &$LBL
         &P3(1) &P3(2),&P3(4)
         B&BBB *+8
         B     &$LBL
         MEXIT
.COR     ANOP
         &P1(1) &P1(2),&P1(4)
         B&AAA  $T&SYSNDX
         &P3(1) &P3(2),&P3(4)
         B&BBB  $T&SYSNDX
         $PUSHI
         B     &$LBL
$T&SYSNDX DS   0H
         MEXIT
         MEND
         MACRO
&LABEL   JUMP  &LB,&TEST,&R
         LCLA  &N
         LCLC  &LBL,&OP1,&OP2
         AIF   (T'&LABEL EQ 'O').NOLBL
&LABEL   EQU   *
.NOLBL   ANOP
         AIF   (T'&R EQ 'O').SETLBL
&LBL     SETC  '0(0,&LB)'
         AGO   .CONT
.SETLBL  ANOP
&LBL     SETC  '&LB'
&N       SETA  N'&LB
         AIF   (&N GT 1).IND
         AGO   .CONT
.IND     ANOP
         AIF   ('&LB(1)'(1,1) EQ '(').LA1
         AIF   ('&LB(1)'(1,2) EQ '0(').LA2
         AGO   .NOLA1
.LA1     ANOP
&OP1     SETC  '0'.'&LB(1)'
         AGO   .DOLA1
.LA2     ANOP
&OP1     SETC  '&LB(1)'
.DOLA1   ANOP
         SETRA 15,&OP1
         AGO   .NXT1
.NOLA1   ANOP
         SETRA 15,&LB(1)
.NXT1    ANOP
         AIF   (T'&LB(2) EQ 'F').FW
         AIF   (T'&LB(2) EQ 'H').HW
         AIF   ('&LB(2)'(1,1) EQ '(').LA3
         AIF   ('&LB(2)'(1,2) EQ '0(').LA4
         AGO   .NOLA2
.LA3     ANOP
&OP2     SETC  '0'.'&LB(2)'
         AGO   .DOLA2
.LA4     ANOP
&OP2     SETC  '&LB(2)'
.DOLA2   ANOP
         SETRA 14,&OP2
         AGO   .NXT2
.NOLA2   ANOP
         SETRA 14,&LB(2)
.NXT2    ANOP
         AGO   .IND2
.FW      ANOP
         SETR  14,&LB(2)
         AGO   .IND2
.HW      ANOP
         SETR  14,&LB(2)
.IND2    ANOP
         DECR  14
         SLL   14,2
         INCRR 15,14
&LBL     SETC  '0(0,15)'
.CONT    ANOP
         AIF   (T'&TEST EQ 'O').UNCBR
         AIF   ('&TEST' EQ 'FALSE').BNEQ
         AIF   ('&TEST' EQ 'TRUE').BEQ
         AIF   ('&TEST' EQ 'PLUS').BPL
         AIF   ('&TEST' EQ 'MINUS').BM
         AIF   ('&TEST' EQ 'ZERO').BZ
         AIF   ('&TEST' EQ 'LOW').BL
         AIF   ('&TEST' EQ 'HIGH').BH
         AIF   ('&TEST' EQ 'GT' OR '&TEST' EQ 'HT').BH
         AIF   ('&TEST' EQ 'LT').BL
         AIF   ('&TEST' EQ 'NGT' OR '&TEST' EQ 'NHT').BNH
         AIF   ('&TEST' EQ 'NLT').BNL
         AIF   ('&TEST' EQ 'NLOW').BNL
         AIF   ('&TEST' EQ 'NHIGH').BNH
         AIF   ('&TEST' EQ 'NPLUS').BNPL
         AIF   ('&TEST' EQ 'NMINUS').BNM
         AIF   ('&TEST' EQ 'NZERO').BNZ
         AIF   ('&TEST' EQ 'EQUAL').BEQ
         AIF   ('&TEST' EQ 'NEQUAL').BNEQ
         AIF   ('&TEST'(1,3) EQ 'ONE').BONE
         AIF   ('&TEST'(1,3) EQ 'MIX').BMIX
         AIF   ('&TEST'(1,4) EQ 'NONE').BNONE
         AIF   ('&TEST'(1,4) EQ 'NMIX').BNMIX
         AIF   ('&TEST' EQ '=').BEQ
         AIF   ('&TEST' EQ '>').BH
         AIF   ('&TEST' EQ '<').BL
         AIF   ('&TEST' EQ 'NOT=').BNEQ
         AIF   ('&TEST' EQ 'NOT>').BNH
         AIF   ('&TEST' EQ 'NOT<').BNL
         AIF   ('&TEST' EQ '¬=').BNEQ
         AIF   ('&TEST' EQ '¬>').BNH
         AIF   ('&TEST' EQ '¬<').BNL
         AIF   ('&TEST' EQ '<=' OR '&TEST' EQ '=<').BNH
         AIF   ('&TEST' EQ '>=' OR '&TEST' EQ '=>').BNL
         AIF   ('&TEST'(1,3) EQ 'POS').BPL
         AIF   ('&TEST'(1,3) EQ 'NEG').BM
         AIF   ('&TEST'(1,4) EQ 'NPOS').BNPL
         AIF   ('&TEST'(1,4) EQ 'NNEG').BNM
         AIF   ('&TEST' EQ '+').BPL
         AIF   ('&TEST' EQ '-').BM
         AIF   ('&TEST' EQ 'NOT+' OR '&TEST' EQ '¬+').BNPL
         AIF   ('&TEST' EQ 'NOT-' OR '&TEST' EQ '¬-').BNM
         AIF   ('&TEST' EQ 'NE').BNEQ
         AIF   ('&TEST' EQ 'EQ').BEQ
         AIF   ('&TEST' EQ 'NM').BNM
         AIF   ('&TEST' EQ 'NP').BNPL
         AIF   ('&TEST' EQ 'NL').BNL
         AIF   ('&TEST' EQ 'NZ').BNZ
         AIF   ('&TEST' EQ 'NTRUE').BNEQ
         AIF   ('&TEST' EQ 'NFALSE').BEQ
         MNOTE 1,'INVALID OR UNDEFINED TEST CODE - &TEST'
.BEQ     ANOP
         BE    &LBL
         MEXIT
.BNEQ    ANOP
         BNE   &LBL
         MEXIT
.BPL     ANOP
         BP    &LBL
         MEXIT
.BM      ANOP
         BM    &LBL
         MEXIT
.BZ      ANOP
         BZ    &LBL
         MEXIT
.BL      ANOP
         BL    &LBL
         MEXIT
.BH      ANOP
         BH    &LBL
         MEXIT
.BNL     ANOP
         BNL   &LBL
         MEXIT
.BNH     ANOP
         BNH   &LBL
         MEXIT
.BNPL    ANOP
         BNP   &LBL
         MEXIT
.BNM     ANOP
         BNM   &LBL
         MEXIT
.BNZ     ANOP
         BNZ   &LBL
         MEXIT
.BONE    ANOP
         BO    &LBL
         MEXIT
.BMIX    ANOP
         BM    &LBL
         MEXIT
.BNONE   ANOP
         BNO   &LBL
         MEXIT
.BNMIX   ANOP
         BNM   &LBL
         MEXIT
.UNCBR   ANOP
         B     &LBL
         MEND
         MACRO
         SELECT
.*********************************************************************
.*       SELECT  BEGIN SELECT/WHEN/ENDSEL SEQUENCE                   *
.*               1. CREATE ENDSELECT LABEL                           *
.*               2. CREATE NEXT WHEN LABEL AND BRANCH TO IT          *
.*********************************************************************
         GBLC  &$LBSEL
         GBLA  &$SELNDX,&$LVSEL,&$STKSEL(50)
         $UPSEL
         GBLC  &$LBWIN
         GBLA  &$WINDEX,&$LVWIN,&$STKWIN(50)
         $UPWHEN
         B     &$LBWIN
         MEND
         MACRO
&NAME    SETUP &T=,&C=,&BASE=,&ENTRY=,&SV=,&SVLEN=
.**********************************************************************
.**********************************************************************
.*           GENERAL PROGRAM SETUP AND INITIALIZATION MACRO           *
.**********************************************************************
.*                                                                    *
.* PGNAME SETUP T=Y,C=Y,BASE=(XX,XX,XX),ENTRY=NNNN,SV=SSSS,R=RR,      *
.*               SVLEN=NNNN                                           *
.*                                                                    *
.*    PGNAME - NAME OF MODULE                                         *
.*           - IF OMITTED AND 'C' IS CODED 'Y' -                      *
.*             THE NAME FROM THE PRECEDING START, CSECT, OR           *
.*             DSECT WILL BE USED AS THE MODULE NAME.                 *
.*             IF THERE IS STILL NO NAME, AN ERROR WILL BE            *
.*             GENERATED.                                             *
.*           - IF OMITTED AND 'C' IS NOT CODED 'Y' -                  *
.*             NO MODULE NAME NEED BE CODED.                          *
.*                                                                    *
.*    T      - IF 'T=Y', THE PROGRAM LISTING WIL BE TITLED            *
.*             ON EACH PAGE.                                          *
.*                                                                    *
.*    C      - IF 'C' OMITTED OR 'C=Y', A CSECT WILL BE               *
.*             GENERTATED, ELSE NO CSECT WILL BE GENERATED.           *
.*                                                                    *
.*    BASE   - THE BASE REGISTERS TO BE USED IN THE MODULE.           *
.*             IF MORE THAN ONE BASE, THE LIST MUST BE ENCLOSED       *
.*             IN PARENTHESES.                                        *
.*           - IF OMITTED REG 12 WILL BE ASSIGNED.                    *
.*                                                                    *
.*    ENTRY  - THE LABEL OF THE INSTRUCTION TO WHICH CONTROL IS       *
.*             TO BE TRANSFERRED AFTER THE MACRO IS EXECUTED.         *
.*           - IF OMITTED, THE NEXT SEQUENTIAL INSTRUCTION WILL       *
.*             RECEIVE CONTROL.                                       *
.*                                                                    *
.*    SV     - NAME TO BE ASSIGNED TO THE SAVE AREA.                  *
.*           - IF OMITTED, SAVE1, SAVE2, ETC. WILL BE USED AS         *
.*             SAVE AREA NAMES.                                       *
.*           - IF ENCLOSED IN PARENTHESIS, GENERATE A SAVE AREA WITH  *
.*             THE NAME SUPPLIED WITHIN THE PARENTHESIS.              *
.*           - IF CODED AS (0), A GETMAIN WILL BE ISSUED FOR THE SAVE *
.*             AREA, AND NO NAME WILL BE ASSIGNED TO THE AREA.        *
.*             (THE CORRESPONDING EXIT SHOULD INDICATE A FREEMAIN).   *
.*                                                                    *
.*    SVLEN  - IF SV=(0) IS CODED, SVLEN MAY BE USED TO INDICATE THE  *
.*             LENGTH OF THE AREA TO BE ACQUIRED. (THE CORRESPONDING  *
.*             EXIT MACRO SHOULD ALSO SUPPLY THE SVLEN OPERAND). IT   *
.*             SHALL BE THE PROBLEM PROGRAM RESPONSIBILITY TO INSURE  *
.*             THAT THE LENGTH IS AT LEAST 72 BYTES.                  *
.*                                                                    *
.**********************************************************************
.*
         GBLA  &JR                      MACRO USAGE COUNT
         LCLC  &JRS                     NAME OF SAVE AREA
         LCLC  &TYPE,&S,&K
         LCLA  &I,&CNT,&PTR,&CSW,&TSW
         LCLA  &SVSW,&ERSW
.*
.*             &SVSW SETTINGS ARE
.*              0  -  &SV OMITTED                 CREATE SAVE AND NAME
.*              1  -  &SV = NAME, NO PARENTHESIS  CREATE SAVE WITH NAME
.*              2  -  &SV = ()                    CREATE SAVE AND NAME
.*              3  -  &SV = (NAME)                NO SAVE AND USE NAME
.*              4  -  &SV = (0)                   GETMAIN AND NO NAME
.*
&JR      SETA  &JR+1
         AIF   (T'&SV EQ 'O').SV3       CHECK FOR OMITTED
         AIF   ('&SV'(1,1) EQ '(').SV1  CHECK FOR PAREN
&SVSW    SETA  1
.SV2     ANOP
&JRS     SETC  '&SV(1)'                 USE INPUT NAME FOR SAVE AREA
         AGO   .SVEND
.SV3     ANOP
&JRS     SETC  'SAVE&JR'                GENERATE NAME FOR SAVE AREA
         AGO   .SVEND
.SV1     ANOP
&SVSW    SETA  2
&JRS     SETC  '&SV(1)'
         AIF   ('&JRS' EQ '').SV3
         AIF   ('&JRS' EQ '0').SV4
&SVSW    SETA  3
         AGO   .SVEND
.SV4     ANOP
&SVSW    SETA  4
.SVEND   ANOP
.*
.*             CHECK IF CSECT WANTED
         AIF   (T'&C EQ 'O').C
         AIF   ('&C'(1,1) NE 'Y').NOC
.*
.*             GET CSECT NAME
.C       ANOP
&TYPE    SETC  '&SYSECT'
         AIF   (T'&NAME EQ 'O').NONM
&TYPE    SETC  '&NAME'
.NONM    AIF   ('&TYPE' NE '').HVNM
&ERSW    SETA  1              SET LABEL ERROR SWITCH
.*
.*             DETERMINE LENGTH OF CSECT NAME AND SET &K = TO SPACES
.*              WITH LENGTH OF 9 - LENGTH OF CSECT NAME
.HVNM    ANOP
&I       SETA  1
.CTR     AIF   ('&TYPE'(1,&I) EQ '&TYPE').LSET
&I       SETA  &I+1
         AGO   .CTR
.LSET    ANOP
&I       SETA  9-&I
&S       SETC  '        '
&K       SETC  '&S'(1,&I)
         AGO   .CKCNT
.*
.*             SET CSECT SW OFF SINCE NOT REQUESTED
.NOC     ANOP
&CSW     SETA  1
.*
.*             CHECK IF TITLE REQUESTED
.CKCNT   AIF   (T'&T EQ 'O').NOT
         AIF   ('&T'(1,1) NE 'Y').NOT
.*             IF NO CSECT - NO TITLE
.CKT     AIF   (&CSW EQ 1).NOCSECT
         TITLE '&TYPE.&K.&TYPE.&K.&TYPE.&K.&TYPE.&K.&TYPE.&K.&TYPE.&K.&X
               TYPE.&K.&TYPE.&K.&TYPE.&K.&TYPE.&K.&TYPE'
.NOT     AIF   (&CSW EQ 1).NOCSECT
         AIF   ('&NAME' EQ '').PREVNM
.*
.*             GENERATE CSECT
&TYPE    CSECT
&S       SETC  '&TYPE'
         AGO   .CKR
.PREVNM  ANOP
&S       SETC  'SETUP&JR'               CREATE DS NAME FOR ADDRESSING
&S       DS    0H
         AGO   .CKR
.NOCSECT ANOP
.*
.*             GENERATE DS WHEN NO CSECT WANTED
&NAME    DS    0H
.*
.*             CHECK FOR REGISTER EQUATES
.CKR     AIF   (&JR NE 1).NOEQ
         SPACE 2
***********************************************************************
*                                                                     *
*                          REGISTER  EQUATES                          *
*                                                                     *
***********************************************************************
*                                                                     *
R0       EQU   0 .                                                    *
R1       EQU   1 .                                                    *
R2       EQU   2 .                                                    *
R3       EQU   3 .                                                    *
R4       EQU   4 .                                                    *
R5       EQU   5 .                                                    *
R6       EQU   6 .                                                    *
R7       EQU   7 .                                                    *
R8       EQU   8 .                                                    *
R9       EQU   9 .                                                    *
R10      EQU   10 .                                                   *
R11      EQU   11 .                                                   *
R12      EQU   12 .                                                   *
R13      EQU   13 .                                                   *
R14      EQU   14 .                                                   *
R15      EQU   15 .                                                   *
*                                                                     *
***********************************************************************
.NOEQ    SPACE 2
.*
.*             GENERATE 'SAVE' - CSECT REQUEST DETERMINES TYPE OF SAVE
         AIF   (&CSW EQ 1).SAVEB
         AIF   (&JR NE 1).SAVEA
         SAVE  (14,12),,&TYPE.&SYSDATE..&SYSTIME
         AGO   .CKBASE
.SAVEA   ANOP
         SAVE  (14,12),,&TYPE
         AGO   .CKBASE
.SAVEB   ANOP
         SAVE  (14,12)
         AIF   ('&NAME' EQ '').SETAST
&S       SETC  '&NAME'
         AGO   .CKBASE
.SETAST  ANOP
.*
.*             DETERMINE HOW BASE REGISTER INITIALIZATION IS TO BE DONE
.*
.*             IF FALL INTO 'SETAST' WILL INITIALIZE BY 'BALR'
&S       SETC  '*'
         AIF   (T'&BASE EQ 'O').BALR12
         BALR  &BASE(1),0    LOAD BASE REGISTER
         AGO   .CKBASE
.BALR12  ANOP
         BALR  12,0         LOAD BASE REGISTER
.*
.*             INITIALIZE BASE REG BY LOADING IT WITH REG 15 AFTER
.*              USING GENERATED
.CKBASE  AIF   (T'&BASE NE 'O').HVBASE
         USING &S,12         BASE REGISTER USAGE
         AIF   ('&S' EQ '*').L6
         LR    12,15          LOAD BASE REGISTER
         AGO   .L6
.*
.*             GENERATE USING
.HVBASE  ANOP
&CNT     SETA  N'&BASE
         AIF   (&CNT EQ 1).B1
         AIF   (&CNT EQ 2).B2
         AIF   (&CNT EQ 3).B3
         AIF   (&CNT EQ 4).B4
         AIF   (&CNT EQ 5).B5
.B6      USING &S,&BASE(1),&BASE(2),&BASE(3),&BASE(4),&BASE(5),&BASE(6)
         AGO   .CKS
.B5      USING &S,&BASE(1),&BASE(2),&BASE(3),&BASE(4),&BASE(5)
         AGO   .CKS
.B4      USING &S,&BASE(1),&BASE(2),&BASE(3),&BASE(4)
         AGO   .CKS
.B3      USING &S,&BASE(1),&BASE(2),&BASE(3)
         AGO   .CKS
.B2      USING &S,&BASE(1),&BASE(2)
         AGO   .CKS
.B1      USING &S,&BASE(1)
.CKS     AIF   ('&S' EQ '*').RLOAD
         LR    &BASE(1),15   LOAD PRIMARY BASE REGISTER
         AIF   (&SVSW EQ 3).RLOAD
         AIF   (&SVSW EQ 4).RLOAD
         AGO   .L6
.RLOAD   ANOP
.*
.*             GENERATE CONTENTS OF SECONDARY BASE REGS AFTER 'BALR'
.*              LOAD OF PRIMARY BASE OR IF HAVE NO SAVE AREA NAME.
&PTR     SETA  2
.SLOAD   AIF   (&PTR GT &CNT).L6
         LA    &BASE(&PTR),4095(,&BASE(&PTR-1)) LOAD NEXT BASE REGISTER
         LA    &BASE(&PTR),1(,&BASE(&PTR))
&PTR     SETA  &PTR+1
         AGO   .SLOAD
.*
.*             CHAINING
.L6      ANOP
         AIF   (&SVSW EQ 4).GETMAIN
         ST    13,&JRS+4     SET BACK CHAIN
         LA    15,&JRS       POINT R15 AT CURRENT SAVE AREA
         ST    15,8(,13)     SET FORWARD CHAIN
         L     15,16(,13)    RESTORE R15
         LA    13,&JRS       POINT R13 AT CURRENT SAVE AREA
.*
.*             GENERATE SECONDARY BASE REGISTER LOADS AFTER 'LOAD REG'
.*              OF PRIMARY
.L0      AIF   ('&S' EQ '*').L4
         AIF   (&SVSW EQ 3).L4
&PTR     SETA  1
.L1      AIF   (&PTR GE &CNT).L4
&I       SETA  72+4*(&PTR-1)
         L     &BASE(&PTR+1),&JRS+&I LOAD FOLLOWING BASE REGISTER
&PTR     SETA  &PTR+1
         AGO   .L1
.*
.*             ISSUE GETMAIN FOR SAVEAREA
.*
.GETMAIN ANOP
         AIF   ('&SVLEN' EQ '').GETMA
         L     0,&SVLEN
         AGO   .GETMB
.GETMA   ANOP
         LA    0,72          LENGTH OF GETMAIN
.GETMB   ANOP
         GETMAIN R,LV=(0)    DO GETMAIN
         XC    0(72,1),0(1)  CLEAR SAVE AREA
         ST    13,4(,1)      SET BACK CHAIN
         ST    1,8(,13)      SET FORWARD CHAIN
         LM    13,1,8(13)    SET UP SAVE REG AND RESTORE PARAM REGS
.*
.*             DETERMINE ENTRY
.L4      ANOP
         AIF   (T'&ENTRY EQ 'O').NOENT  CHECK IF ENTRY CODED
         B     &ENTRY        BRANCH TO PGM ENTRY POINT
         AGO   .MAKESA
.NOENT   ANOP
&TYPE    SETC  '&SYSNDX'(2,3)           GET LAST 3 POSITIONS OF &SYSNDX
&TYPE    SETC  'SETUP&TYPE'             CREATE BRANCH NAME
         AIF   (&SVSW EQ 3).MAKESA      CHECK IF BRANCH NECESSARY
         AIF   (&SVSW EQ 4).MAKESA      CHECK IF BRANCH NECESSARY
         B     &TYPE          BRANCH TO PGM ENTRY POINT
.*
.*             SAVE AREA SETUP
.MAKESA  ANOP
*
         AIF   (&SVSW EQ 3).MACEND      SHALL SAVEAREA BE GENERATED
         AIF   (&SVSW EQ 4).MACEND      SHALL SAVEAREA BE GENERATED
&JRS     DS    18F            SAVE AREA
         AIF   ('&S' EQ '*').MACEND
&PTR     SETA  1
.S3      AIF   (&PTR GE &CNT).S4
         DC    A(&S+4096*&PTR)
&PTR     SETA  &PTR+1
         AGO   .S3
.S4      ANOP
*
.MACEND  AIF   (T'&ENTRY NE 'O').DONE
         AIF   (&SVSW EQ 3).DONE
         AIF   (&SVSW EQ 4).DONE
&TYPE    EQU   *
.DONE    ANOP
         AIF   (&ERSW NE 1).FINI
         MNOTE 12,'*** SETUP LABEL MISSING ***'
.FINI    ANOP
         EJECT
         MEND
         MACRO
         WHEN &P1,&P2,&P3,&P4
.*********************************************************************
.*       1.  WHEN       CLI,A,NE,B                                   *
.*       2.  WHEN       (CLI,A,NE,B),AND,(CLC,A,E,B)                 *
.*       3.  WHEN       (CLI,A,NE,B),OR,(CLC,A,E,B)                  *
.*       4.  WHEN       OTHERWISE                                    *
.*********************************************************************
         GBLC  &$LBWIN
         GBLA  &$WINDEX,&$LVWIN,&$STKWIN(50)
&$LBWIN  DS    0H
         AIF   ('&P1'(1,1) EQ '(').COMPLEX
         AIF   ('&P1' EQ 'OTHERWISE').OTHER
         AIF   ('&P3' NE 'EQ').CHKEQ2
.*********************************************************************
.*                                        CONVERT 'EQ' TO 'E'        *
.*********************************************************************
&SYM     SETC  'E '
         AGO   .SIMPLE
.CHKEQ2  ANOP
         AIF   ('&P3' NE '=').CHKGT1
.*********************************************************************
.*                                        CONVERT '=' TO 'E'         *
.*********************************************************************
&SYM     SETC  'E '
         AGO   .SIMPLE
.CHKGT1  ANOP
         AIF   ('&P3' NE 'GT').CHKGT2
.*********************************************************************
.*                                        CONVERT 'GT' TO 'H'        *
.*********************************************************************
&SYM     SETC  'H '
         AGO   .SIMPLE
.CHKGT2  ANOP
         AIF   ('&P3' NE '>').CHKLT1
.*********************************************************************
.*                                        CONVERT '>'  TO 'H'        *
.*********************************************************************
&SYM     SETC  'H '
         AGO   .SIMPLE
.CHKLT1  ANOP
         AIF   ('&P3' NE 'LT').CHKLT2
.*********************************************************************
.*                                        CONVERT 'LT' TO 'L'        *
.*********************************************************************
&SYM     SETC  'L '
         AGO   .SIMPLE
.CHKLT2  ANOP
         AIF   ('&P3' NE '<').CHKON
.*********************************************************************
.*                                        CONVERT '<'  TO 'L'        *
.*********************************************************************
&SYM     SETC  'L '
         AGO   .SIMPLE
.CHKON   ANOP
         AIF   ('&P3' NE 'ON').CHKOFF
.*********************************************************************
.*                                       CONVERT 'ON'  TO 'O'        *
.*********************************************************************
&SYM     SETC  'O '
         AGO   .SIMPLE
.CHKOFF  ANOP
         AIF   ('&P3' NE 'OFF').CHKDFLT
.*********************************************************************
.*                                      CONVERT 'OFF'  TO 'Z'        *
.*********************************************************************
&SYM     SETC  'Z '
         AGO   .SIMPLE
.CHKDFLT ANOP
.*********************************************************************
.*                              BRANCH CODE = SUPPLIED PARAMETER     *
.*********************************************************************
&SYM     SETC  '&P3'
.SIMPLE  ANOP
         &P1   &P2,&P4
         B&SYM *+8
         $UPWHEN
         B     &$LBWIN
         MEXIT
.OTHER   ANOP
         MEXIT
.COMPLEX ANOP
         AIF   ('&P1(3)' NE 'EQ').AAAEQ2
.*********************************************************************
.*                                        CONVERT 'EQ' TO 'E'        *
.*********************************************************************
&AAA     SETC  'E '
         AGO   .BBBEQ1
.AAAEQ2  ANOP
         AIF   ('&P1(3)' NE '=').AAAGT1
.*********************************************************************
.*                                        CONVERT '=' TO 'E'         *
.*********************************************************************
&AAA     SETC  'E '
         AGO   .BBBEQ1
.AAAGT1  ANOP
         AIF   ('&P1(3)' NE 'GT').AAAGT2
.*********************************************************************
.*                                        CONVERT 'GT' TO 'H'        *
.*********************************************************************
&AAA     SETC  'H '
         AGO   .BBBEQ1
.AAAGT2  ANOP
         AIF   ('&P1(3)' NE '>').AAALT1
.*********************************************************************
.*                                        CONVERT '>'  TO 'H'        *
.*********************************************************************
&AAA     SETC  'H '
         AGO   .BBBEQ1
.AAALT1  ANOP
         AIF   ('&P1(3)' NE 'LT').AAALT2
.*********************************************************************
.*                                        CONVERT 'LT' TO 'L'        *
.*********************************************************************
&AAA     SETC  'L '
         AGO   .BBBEQ1
.AAALT2  ANOP
         AIF   ('&P1(3)' NE '<').AAAON
.*********************************************************************
.*                                        CONVERT '<'  TO 'L'        *
.*********************************************************************
&AAA     SETC  'L '
         AGO   .BBBEQ1
.AAAON   ANOP
         AIF   ('&P1(3)' NE 'ON').AAAOFF
.*********************************************************************
.*                                       CONVERT 'ON'  TO 'O'        *
.*********************************************************************
&AAA     SETC  'O '
         AGO   .BBBEQ1
.AAAOFF  ANOP
         AIF   ('&P1(3)' NE 'OFF').AAADFLT
.*********************************************************************
.*                                      CONVERT 'OFF'  TO 'Z'        *
.*********************************************************************
&AAA     SETC  'Z '
         AGO   .BBBEQ1
.AAADFLT ANOP
.*********************************************************************
.*                                BRANCH COND = SUPPLIED PARAMETER   *
.*********************************************************************
&AAA     SETC  '&P1(3)'
         AGO   .BBBEQ1
.BBBEQ1  ANOP
         AIF   ('&P3(3)' NE 'EQ').BBBEQ2
.*********************************************************************
.*                                        CONVERT 'EQ' TO 'E'        *
.*********************************************************************
&BBB     SETC  'E '
         AGO   .CMPCONT
.BBBEQ2  ANOP
         AIF   ('&P3(3)' NE '=').BBBGT1
.*********************************************************************
.*                                        CONVERT '=' TO 'E'         *
.*********************************************************************
&BBB     SETC  'E '
         AGO   .CMPCONT
.BBBGT1  ANOP
         AIF   ('&P3(3)' NE 'GT').BBBGT2
.*********************************************************************
.*                                        CONVERT 'GT' TO 'H'        *
.*********************************************************************
&BBB     SETC  'H '
         AGO   .CMPCONT
.BBBGT2  ANOP
         AIF   ('&P3(3)' NE '>').BBBLT1
.*********************************************************************
.*                                        CONVERT '>'  TO 'H'        *
.*********************************************************************
&BBB     SETC  'H '
         AGO   .CMPCONT
.BBBLT1  ANOP
         AIF   ('&P3(3)' NE 'LT').BBBLT2
.*********************************************************************
.*                                        CONVERT 'LT' TO 'L'        *
.*********************************************************************
&BBB     SETC  'L '
         AGO   .CMPCONT
.BBBLT2  ANOP
         AIF   ('&P3(3)' NE '<').BBBON
.*********************************************************************
.*                                        CONVERT '<'  TO 'L'        *
.*********************************************************************
&BBB     SETC  'L '
         AGO   .CMPCONT
.BBBON   ANOP
         AIF   ('&P3(3)' NE 'ON').BBBOFF
.*********************************************************************
.*                                       CONVERT 'ON'  TO 'O'        *
.*********************************************************************
&BBB     SETC  'O '
         AGO   .CMPCONT
.BBBOFF  ANOP
         AIF   ('&P3(3)' NE 'OFF').BBBDFLT
.*********************************************************************
.*                                      CONVERT 'OFF'  TO 'Z'        *
.*********************************************************************
&BBB     SETC  'Z '
         AGO   .CMPCONT
.BBBDFLT ANOP
.*********************************************************************
.*                         BRANCH CODE = SUPPLIED PARAMETER          *
.*********************************************************************
&BBB     SETC  '&P3(3)'
         AGO   .CMPCONT
.CMPCONT ANOP
         AIF   ('&P2' EQ 'AND').CAND
         AIF   ('&P2' EQ 'OR').COR
         MNOTE *,'CONNECTOR MUST BE ''AND'' OR ''OR'''
         MEXIT
.CAND    ANOP
         &P1(1) &P1(2),&P1(4)
         B&AAA  *+8
         $UPWHEN
         B     &$LBWIN
         &P3(1) &P3(2),&P3(4)
         B&BBB  *+8
         B     &$LBWIN
         MEXIT
.COR     ANOP
         &P1(1) &P1(2),&P1(4)
         B&AAA  $T&SYSNDX
         &P3(1) &P3(2),&P3(4)
         B&BBB  $T&SYSNDX
         $UPWHEN
         B     &$LBWIN
$T&SYSNDX DS   0H
         MEND
         EJECT
         TITLE 'SVC 226 - VALIDATE PCS ACCOUNTING NUMBER'
WCSVC226 CSECT
*
*  THIS SVC VALIDATES THE PASSED PCS NUMBER AGAINST THE PCS TABLE
*  LOCATED IN EXTENDED CSA.
*
*  AT ENTRY, REG 1 MUST POINT TO A PARAMETER LIST CONTAINING:
*       WORD 1:  ADDRESS OF THE PCS NUMBER TO BE VALIDATED
*       WORD 2:  ADDRESS OF THE LOGON-ID NAME (OPTIONAL)
*
*  AT EXIT, REG 15 WILL CONTAIN THE RETURN CODE VALUE OF:
*       0  = VALIDATION SUCCESSFUL
*       4  = PCS TABLE HAS BEEN MARKED 'INVALID'
*            OR TABLE NOT LOCATED IN STORAGE
*       8  = LOGON-ID NOT ALLOWED TO USE PCS NUMBER
*      12  = PCS NUMBER NOT VALID
   EJECT
*
R0       EQU   0                            STD
R1       EQU   1                            STD
R2       EQU   2                            BASE PARM AREA
R3       EQU   3                            WORK REG
R4       EQU   4                            WORK REG
R5       EQU   5                            WORK REG
R6       EQU   6                            BASE REG
R7       EQU   7                            -> PASSED PCS NUMBER
R8       EQU   8                            -> PCS TABLE
R9       EQU   9                            -> PASSED LOGON-ID
R10      EQU   10                           WORK REG
R11      EQU   11                           WORK REG
R12      EQU   12                           WORK REG
R13      EQU   13                           BASE 'WORK AREA'
R14      EQU   14                           RETURN ADDR TO CALLER
R15      EQU   15                           RETURN CODE
*
  USING WCSVC226,R6                         ON ENTRY R6 -> MODULE
  USING WORK,R13                            BASE WORK AREA
  USING PARMS,R2                            BASE PARMS
*
  LR    R2,R1                               -> PASSED PARMS
*
  PRINT NOGEN
  LA    R0,WORKLEN
  GETMAIN R,LV=(0)                          GET AREA FOR SAVE
  LR    R13,R1                              -> WORK AREA
*
  XC    0(WORKLEN,R13),WORK                 CLEAR WORK AREA
*
  ST    R14,SAVE                            SAVE RETURN ADDRESS
*
  EJECT
  XR    R15,R15                             ZERO RETURN CODE
  STH   R15,RETCODE                         INIT RC = 0
***********************************************************************
* ADDRESS PCS TABLE IN EXTENDED CSA                                   *
***********************************************************************
  L     R8,16(0)                            -> CVT
  L     R3,CVTUSER-CVT(R8)                  -> C9605TAB MODULE
  L     R8,C96PCS@-C9605(R3)                -> CSA PCS_TABLE
  SPACE 3
***********************************************************************
* CHECK IF PCS_TABLE PRESENT AND ACTIVE                               *
***********************************************************************
  IF   (CLI,TBLSTAT-TABLE(R8),NE,OFF),OR,   IF PCS_TABLE INVALID THEN  X
               (CLC,TBLEYE-TABLE(L'TBLEYE,R8),NE,EYECATCH)
    LH    R15,FOUR                          SET RETCODE = 4
    STH   R15,RETCODE                       SAVE RC
    GOTO  PGMEXIT                           AND EXIT FROM PROGRAM
  ENDIF
***********************************************************************
* VALIDATE PASSED PCS NUMBER AGAINST PCS_TABLE                        *
***********************************************************************
  XR    R4,R4                               CLEAR REG
  L     R5,TABLE-TBLSIZE(R8)                GET LENGTH OF PCS_TABLE
  LA    R3,L'TBLENTRY                       GET LENGTH OF TABLE ENTRY
***********************************************************************
* --- FIND NUMBER OF TABLE ENTRIES                                    *
***********************************************************************
  DR    R4,R3                               GET LENGTH OF TABLE ENTRY
*                                             R4 = REMAINDER
*                                             R5 = QUOTIENT
  BCTR  R5,0                                SUBTRACT HEADER ENTRY
***********************************************************************
* --- INIT HI-TABLE-INDEX AND LOW-TABLE-INDEX                         *
***********************************************************************
  ST    R5,HIINDEX                          HI INDEX = # TBL ENTRIES
  LA    R4,1                                LOW INDEX = 1
  ST    R4,LOWINDEX                         SAVE IT
***********************************************************************
* --- INIT CURRENT-TABLE-INDEX (CURRENT POSITION IN TABLE) POINTER    *
***********************************************************************
  SRL   R5,1(0)                             DIVIDE BY 2 (FIND MIDDLE)
  ST    R5,CURINDEX                         SAVE CURRENT TABLE INDEX
***********************************************************************
* COMPARE PASSED PCS NUMBER TO CURRENT PCS_TABLE ENTRY                *
***********************************************************************
COMPARE DS 0H
  XR    R4,R4                               CLEAR REG
  L     R5,CURINDEX                         CURRENT TABLE INDEX
  LA    R3,L'TBLENTRY                       GET LENGTH OF TABLE ENTRY
  MR    R4,R3                               GET ADDR-INDEX TO TABLE
  LA    R5,0(R5,R8)                         -> CURRENT TABLE ENTRY
  L     R7,PCS@                             -> ARGUMENT PCS NUMBER
  CLC   0(L'TBLENTRY,R5),0(R7)              MATCH ?
  BH    TBLHIGH                             ... GO LOWER TABLE ->
  BL    TBLLOW                              ... GO RAISE TABLE ->
***********************************************************************
* PCS TABLE MATCH ... EXIT FROM PGM RC=0                              *
***********************************************************************
  GOTO  CHKUSER                             GO CHECK LOGON-ID USE
  EJECT
***********************************************************************
* ADJUST CURRENT TABLE POINTER "DOWNWARD"                             *
***********************************************************************
TBLHIGH DS 0H
  L     R5,CURINDEX                         CURRENT TABLE INDEX
  ST    R5,HIINDEX                          RESET HI TABLE INDEX
  L     R4,LOWINDEX                         GET LOW TABLE INDEX
  SR    R5,R4                               GET NEW INDEX RANGE
  IF    CH,R5,EQ,ZERO                       IF NO MORE ENTRIES THEN
    GOTO  NOFIND                            ... PCS NOT IN TABLE
  ENDIF
  IF    CH,R5,LT,FOUR                       IF RANGE LESS THAN 4 THEN
    L     R4,HIINDEX                        ... SINGLE STEP THRU
    BCTR  R4,0                              ... REMAINDING TABLE
    ST    R4,CURINDEX                       ... ENTRIES
    ST    R4,HIINDEX                        RESET NEW TABLE HI
  ELSE
    SRL   R5,1(0)                           DIVIDE BY 2
    AR    R5,R4                             ADD TO LOW INDEX
    ST    R5,CURINDEX                       AND SAVE NEW CURRENT INDEX
  ENDIF
  GOTO  COMPARE                             GO COMPARE NEXT ENTRY
  SPACE 3
***********************************************************************
* ADJUST CURRENT TABLE POINTER "UPWARD"                               *
***********************************************************************
TBLLOW  DS 0H
  L     R4,CURINDEX                         CURRENT TABLE INDEX
  ST    R4,LOWINDEX                         RESET LOW TABLE INDEX
  L     R5,HIINDEX                          GET HI TABLE INDEX
  SR    R5,R4                               GET NEW INDEX RANGE
  IF    CH,R5,EQ,ZERO                       IF NO MORE ENTRIES THEN
    GOTO  NOFIND                            ... PCS NOT IN TABLE
  ENDIF
  IF    CH,R5,LT,FOUR                       IF RANGE LESS THAN 4 THEN
    LA    R4,1(R4)                          ... SINGLE STEP THRU
    ST    R4,CURINDEX                       ... REMAINING TABLE
    ST    R4,LOWINDEX                       ... ENTRIES
  ELSE
    SRL   R5,1(0)                           DIVIDE BY 2
    AR    R5,R4                             ADD TO LOW INDEX
    ST    R5,CURINDEX                       AND SAVE NEW CURRENT INDEX
  ENDIF
  GOTO  COMPARE                             GO COMPARE NEXT ENTRY
  SPACE 3
***********************************************************************
* PCS NUMBER IS NOT IN TABLE                                          *
***********************************************************************
NOFIND  DS 0H
  LH    R15,TWELVE                          SET RETCODE = 12
  STH   R15,RETCODE                         SET RETCODE = 12
  GOTO  PGMEXIT                             AND EXIT FROM PROGRAM
  EJECT
***********************************************************************
* CHKUSER:   PROC.                                                    *
*   - IF LOGON-ID PASSED, VALIDATE IF USER IS USING PROPER PCS NUMBER *
***********************************************************************
CHKUSER DS 0H
*                                           R7 -> TO PCS NUMBER
  L     R3,LOGID@                           R3 -> LOGON-ID NAME
*
  IF    CH,R3,EQ,ZERO                       IF LOGID@ = 0 THEN
    GOTO  PGMEXIT                           ... EXIT FROM PROGRAM
  ENDIF
*-------------------------------------------------------------*
*  PREVENT TSO JOBS FROM USING PRODUCTION PUCS  DDAAYSS8      *
*   WHERE: DD = DIVISION                                      *
*          AA = APPLICATION                                   *
*           Y = ALWAYS 'P'                                    *
*          SS = PROJECT SERIES 88-99                          *
*           8 = ALWAYS '8'                                    *
*-------------------------------------------------------------*
USR040   DS    0H
         CLI   4(R7),C'P'         *PRODUCTION PUCS?
         BC    NE,USR050          *NO, CONTINUE CHECK
         CLI   7(R7),C'8'         *DOUBLE CHECK. PROD PUCS?
         BC    EQ,FLUSH           *YES, NOT ALLOWED - FLUSH JOB
USR050   DS    0H
         LA    R5,IDTABLE         *ADDRESS OF DSD ID'S
USR060   DS    0H
         CLC   0(3,R3),0(R5)      *IS THIS A DSD ID?
         BC    EQ,USR100          *YES, GO CHECK ACCOUNT NUM
         LA    R5,3(R5)           *POINT TO NEXT TABLE ENTRY
         CLC   TABLEND(3),0(R5)   *END OF DSD ID TABLE?
         BC    NE,USR060          *NO, CHECK NEXT ENTRY
         LA    R5,FCIDS           *ADDR OF FORT WORTH DSD IDS
USR065   DS    0H
         CLC   1(3,R3),0(R5)      *IS THIS A DSD ID?
         BC    EQ,USR100          *YES, GO CHECK ACCOUNT NUM
         LA    R5,3(R5)           *POINT TO NEXT TABLE ENTRY
         CLC   TABLEND(3),0(R5)   *END OF DSD ID TABLE?
         BC    NE,USR065          *NO, CHECK NEXT ENTRY
*-------------------------------------------------------------*
* CHECK NON-DSD ID FOR VALID ACCOUNT NUMBER (PUCS)  DDAAZXXXX *
*   WHERE: DD = DIVISION                                      *
*          AA = APPLICATION                                   *
*           Z = ALWAYS 'Z' - OPEN SHOP INDICATOR              *
*        XXXX = 2, 3, OR 4 NUMERICS                           *
*-------------------------------------------------------------*
USR070   DS    0H
         CLI   4(R7),C'Z'         *OPEN SHOP INDICATOR PRESENT?
         BC    EQ,PGMEXIT         *YES, LOGONID CAN USE PCS
         B     FLUSH              *INVALID ACCT NUM - FLUSH JOB
         SPACE 1
*-------------------------------------------------------------*
*   CHECK DSD ID FOR VALID PCS ACCOUNT NUMBER  DDAAYSSPTTSS   *
*                                            (ANY 12 DIGITS)  *
*   OR VALID PUCS NUMBER  DDAAZXXXX                           *
*     WHERE: DD = DIVISION - DSD ID (EG: WC, EC, FC )         *
*            AA = APPLICATION (01 THRU 09)                    *
*             Z = 'N' FOR NON-BILLABLE                        *
*          XXXX = 2, 3, OR 4 NUMERICS                         *
*-------------------------------------------------------------*
USR100   DS    0H
         CLI   4(R7),C'N'         *PUCS NON-BILLABLE?
         BC    NE,USR120          *NO SEE IF PCS NUMBER
         LA    R5,IDTABLE         *ADDRESS OF DSD ID'S
USR110   DS    0H
         CLC   0(2,R7),1(R5)      *IS THIS A DSD ID?
         BC    EQ,PGMEXIT         *YES, LOGONID OK
         LA    R5,3(R5)           *POINT TO NEXT TABLE ENTRY
         CLC   TABLEND(3),0(R5)   *END OF DSD ID TABLE?
         BC    NE,USR110          *NO, CHECK NEXT ENTRY
         LA    R5,FCIDS           *ADDR OF FORT WORTH DSD IDS
USR115   DS    0H
         CLC   0(2,R7),0(R5)      *IS THIS A DSD ID?
         BC    EQ,PGMEXIT         *YES, LOGONID OK
         LA    R5,3(R5)           *POINT TO NEXT TABLE ENTRY
         CLC   TABLEND(3),0(R5)   *END OF DSD ID TABLE?
         BC    NE,USR115          *NO, CHECK NEXT ENTRY
*-----     CHECK IF ACCOUNT NUMBER IS A 12 DIGIT PCS     -----*
USR120   DS    0H
         SLR   R12,R12            *PREPARE FOR COUNT
         LR    R10,R7             *R10 -> PCS NUMBER
USR130   DS    0H
         CLI   0(R10),C' '        *END OF ACCOUNT NUMBER?
         BC    EQ,USR140          *YES, GO CHECK COUNT
         LA    R10,1(R10)         *POINT TO NEXT ACCT CHAR
         LA    R12,1(R12)         *ADD TO COUNT
         CH    R12,TWELVE         *COUNT > 12 ?
         BC    GT,FLUSH           *YES, INVALID USE
         B     USR130             *CONTINUE CHECKING FOR END
USR140   DS    0H
         LA    R11,12             *NUMBER OF CHARS IN VALID PCS
         CR    R12,R11            *VALID PCS?
         BC    EQ,PGMEXIT         *YES, LOGONID CAN USE PCS
*
FLUSH    DS    0H
*        USER CANNOT USE PCS NUMBER
  LH    R15,EIGHT                           SET RETCODE = 8
  STH   R15,RETCODE                         SET RETCODE = 8
  GOTO  PGMEXIT                             AND EXIT FROM PROGRAM
  EJECT
***********************************************************************
* PGMEXIT:   PROC.                                                    *
*   - EXIT FROM PROGRAM                                               *
***********************************************************************
PGMEXIT DS   0H
  L     R14,SAVE                            RESTORE R14
  LH    R5,RETCODE                          SAVE RETURN CODE
  LA    R0,WORKLEN                          R0 = WORK AREA LENGTH
  LA    R1,WORK                             R1 -> WORK AREA
*
  FREEMAIN R,LV=(0),A=(R1)                  FREE GETMAINED AREA
*
  XR    R0,R0                               R0 = 0
  XR    R1,R1                               R1 = 0
  LR    R15,R5                              R15 = RETURN CODE
*
  BR    R14                                 RETURN TO CALLER
*
  EJECT
***********************************************************************
*  CONSTANT DATA DEFINITIONS                                          *
***********************************************************************
*
ZERO     DC    H'0'                         HALFWORD ZERO
FOUR     DC    H'4'                         HALFWORD FOUR
EIGHT    DC    H'8'                         HALFWORD EIGHT
TWELVE   DC    H'12'                        HALFWORD TWELVE
EYECATCH DC    CL10'PCS TABLE'              TABLE EYECATCHER
*
IDTABLE  DC    C'$EC'
         DC    C'$WC'
         DC    C'$WP'
TABLEND  DC    C'FFF'
*
FCIDS    DC    C'FCA'
         DC    C'FCD'
         DC    C'FCE'
         DC    C'FCF'
         DC    C'FCG'
         DC    C'FCH'
         DC    C'FCI'
         DC    C'FCJ'
         DC    C'FCM'
         DC    C'FCO'
         DC    C'FCP'
         DC    C'FCQ'
         DC    C'FCR'
         DC    C'FCS'
         DC    C'FCT'
         DC    C'FCW'
         DC    C'FCZ'
         DC    C'FFF'
*
  SPACE  3
***********************************************************************
*  EQUATED DATA DEFINITIONS                                           *
***********************************************************************
GT       EQU   2                            A HIGH
LT       EQU   4                            A LOW
NE       EQU   7                            A NOT EQUAL B
EQ       EQU   8                            A EQUAL B
GE       EQU   11                           A NOT LOW
LE       EQU   13                           A NOT HIGH
OFF      EQU   X'00'                        SWITCH-OFF INDICATOR
ON       EQU   X'FF'                        SWITCH-ON INDICATOR
  LTORG
  EJECT
***********************************************************************
*  MAP PROGRAM WORKING STORAGE AREA (FOR REENTRABILITY)               *
***********************************************************************
WORK      DSECT
*
          DS    2F
SAVE      DS    16F
*
CURINDEX  DS    F                           -> CURRENT TABLE ENTRY
LOWINDEX  DS    F                           -> LOWEST TABLE ENTRY
HIINDEX   DS    F                           -> HIGHEST TABLE ENTRY
*
RETCODE   DS    H                           RETURN CODE
*
WORKLEN   EQU   *-WORK
*
***********************************************************************
*  MAP IN-STORAGE PCS_TABLE                                           *
***********************************************************************
TABLE     DSECT                             PCS STORAGE TABLE MAP
TBLHDR    DS   0F                           BEGIN TABLE HEADER
TBLSIZE   DS    F                           SIZE OF TABLE
TBLSTAT   DS    X                           STATUS FLAG
*                                           X'00' = TABLE VALID
*                                           X'FF' = TABLE INVALID
TBLEYE    DS    CL10                        EYECATCHER 'PCS TABLE '
TBLENTRY  DS    CL15                        1ST TABLE ENTRY
*
TBLHDRLL  EQU   TBLENTRY-TBLHDR             LENGTH OF TABLE HEADER
  EJECT
***********************************************************************
*  MAP PARAMETER LIST                                                 *
***********************************************************************
PARMS     DSECT                             PARAMETER LIST DSECT
PCS@      DS    F                           -> PCS NUM (15 BYTE AREA)
LOGID@    DS    F                           -> LOGON-ID (8 BYTE AREA)
          SPACE 3
***********************************************************************
*  MAP C9605TAB CONTROL BLOCK                                         *
***********************************************************************
C9605     DSECT                             BEGIN MAP OF C9605TAB
          DS    4F                          FILLER
C96PCS@   DS    F                           -> PCS TABLE
          SPACE 3
***********************************************************************
*  MAP OS CVT                                                         *
***********************************************************************
          CVT  DSECT=YES                    GENERATE CVT DSECT
*
          END
