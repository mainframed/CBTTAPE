STRINGIT CSECT
STRINGIT AMODE 31
STRINGIT RMODE ANY
*
*   This program is used by the STRING macro to convert fields
*   to the required format and to put them into the output area.
*
*   Note that on return from this program register 1 contains the
*   address of the byte in the output area after the strung data.
*
*   Input parameters generated by the STRING macro are
*     1, address of a series of format indicators terminated by x'FF'
*     2, address of output area
*     3, length of the output area
*     4, address of a 32 byte work area
*
*     5, address of input field
*     6, length of input field
*
*   Parameters 4 and 5 repeat for as many indicators as there are in
*   the list pointed to by parameter 1
*
*   note that this program does not have it's own save area because
*   it does not call anything and it needs to be re-entrant
*
         SAVE  (14,12)                   * save callers registers
         PRINT OFF
         YREGS
         PRINT ON
         LR    R12,R15                   * copy base address
         USING STRINGIT,R12
         LR    R10,R1                    * copy parameter address
         LM    R3,R6,0(R10)              * load first 4 parameters
*                              R3    string of output indicators
*                              R4    address of output field
*                              R5    length of output field
*                              R6    work area in caller
         USING WORKAREA,R6
         MVC   GLOB_IND,0(R3)        * copy global indicators
         LA    R3,L'GLOB_IND(,R3)    * point passed global indicators
         AR    R5,R4                 * point after output field
         LA    R7,16(,R10)     R7    * point to first address/length
*
         CLI   PAD_FRST,C'0'
         BNH   GO_AGAIN              * no initial pad char
         PACK  DOUB_WORD,PAD_FRST
         CVB   R1,DOUB_WORD
         LA    R4,0(R1,R4)           * point passed initial pad char
*
GO_AGAIN DS    0H
         LM    R8,R9,0(R7)           Get details of next field
*
*        if the length in R9 is negative it means that R8 contains
*        the value to be displayed not the address of the value
*
         LTR   R9,R9                     * test R9
         BP    IS_POS                    * if positive then use it
         LPR   R9,R9                     * make positive
         ST    R8,FULL_WORD              * save 32 bit value
         LA    R8,FULL_WORD              * and point to it
*
IS_POS   DS    0H
*
         CLI   0(R3),C'X'                * Hex output required
         BE    HEX_OUT
*
         CLI   0(R3),C'B'                * Binary output required
         BE    BIN_OUT
*
         CLI   0(R3),C'P'                * Pack output required
         BE    PACK_OUT
*
         CLI   0(R3),C'I'                * Integer output required
         BE    INT_OUT
*
         CLI   0(R3),C'U'                * Unsigned integer required
         BE    UINT_OUT
*
         CLI   0(R3),C'S'                * Small Int output required
         BE    SINT_OUT
*
         CLI   0(R3),C'V'                * Small unsigned int required
         BE    VINT_OUT
*
*        assume it must be character
*
*        Just copy the character value to the output area
*
CHAR_OUT DS    0H
         LA    R1,0(R9,R4)               * point after receiving
         CR    R1,R5                     * is the output full
         BNL   OVERFLOW                  * yes error
*
         BCTR  R9,0                      * -1 for execute
         EX    R9,MVC_IT                 * execute the move
         LA    R4,1(R9,R4)               * point past data copied
         B     DONE_IT
*
*        Take the value and convert to hexadecimal display
*
HEX_OUT  DS    0H
         LR    R2,R9                     * copy sending length
         SLL   R2,1                      * multiply by 2
         LA    R1,0(R2,R4)               * point after receiving
         CR    R1,R5                     * is the output full
         BNL   OVERFLOW                  * yes error
*
HEX_OUT1 DS    0H
         MVC   WORK2(1),0(R8)            * copy one byte
         UNPK  WORK3,WORK2               * UNPK two bytes to three
         TR    WORK3(2),TR_TAB-240       * convert to displayable
         MVC   0(2,R4),WORK3             * copy to receiver
         LA    R4,2(,R4)                 * move past output bytes
         LA    R8,1(,R8)                 * move past input byte
         BCT   R9,HEX_OUT1               * do next byte
         B     DONE_IT
*
*        Take the value and convert to binary display
*        This puts the byte into the low byte of register 1 and then
*        for each iteration of the inner loop moves the next bit into
*        the low bit of byte three of the register and stores it.
*        So as the loop progresses the bit values become bytes in
*        the output string.
*
BIN_OUT  DS    0H
         LR    R2,R9                     * copy sending length
         SLL   R2,3                      * multiply by 8
         LA    R1,0(R2,R4)               * point after receiving
         CR    R1,R5                     * is the output full
         BNL   OVERFLOW                  * yes error
*
BIN_OUT1 DS    0H
         IC    R1,0(R8)                  * get a byte
         LR    R14,R4                    * copy output address
         LA    R15,8                     * 8 bits to a byte
*
BIN_OUT2 DS    0H
         SLA   R1,1                      * slide left 1 bit
         STCM  R1,2,0(R14)               * store third byte
         NI    0(R14),1                  * switch of all but right bit
         LA    R14,1(,R14)               * next output byte
         BCT   R15,BIN_OUT2              * process next bit
*
         OC    0(8,R4),ZONES             * make zoned decimal
         LA    R4,8(,R4)                 * move past output bytes
         LA    R8,1(,R8)                 * move past input byte
         BCT   R9,BIN_OUT1               * do next byte
         B     DONE_IT
*
*        Input is packed convert to numeric display
*
PACK_OUT DS    0H
         LR    R2,R9                     * copy sending length
         SLL   R2,1                      * multiply by 2
         LA    R1,0(R2,R4)               * point after receiving
         CR    R1,R5                     * is the output full
         BNL   OVERFLOW                  * yes error
*
         LR    R1,R9                     * get length of field
         BCTR  R1,0                      * less 1 for execute
         LR    R15,R1                    * copy for CP
         SLL   R15,4                     * left one nibble
         LR    R2,R9                     * get length of field
         BCTR  R2,0                      * subtact for EX and sign
         SLL   R2,1                      * multiply by 2
         LA    R14,0(R2,R4)              * position to last digit
         SLL   R2,4                      * left one nibble
         OR    R1,R2                     * merge lengths
         EX    R1,UNPK_IT                * unpack data
         OI    0(R14),X'F0'              * make last digit numeric
         EX    R15,CP_IT                 * check if negative
         BL    P_NEG                     * branch negative
         MVI   1(R14),C'+'
         B     P_DONE
P_NEG    DS    0H
         MVI   1(R14),C'-'
P_DONE   DS    0H
*
*        the following code is to remove leading zeroes, I know I
*        could have built an edit pattern and executed an edit
*        instruction but I thought this was easier. Also having a pad
*        character would increase the size of the output field.
*
         CLI   NUM_ZERO,C'Y'             * show leading zeroes
         BE    P_DONEX                   * they are there
         LR    R1,R4                     * get address of output
         LR    R2,R9                     * get length of field
         BCTR  R2,0                      * subtract 1
         SLL   R2,1                      * multiply by 2
P_CHK0   CLI   0(R1),C'0'                * is this byte zero
         BNE   P_DONEX                   * no so job done
         MVI   0(R1),C' '                * blank it
         LA    R1,1(,R1)                 * next byte
         BCT   R2,P_CHK0                 * check next
P_DONEX  DS    0H
         LA    R4,2(,R14)                * move past output bytes
         B     DONE_IT
*
*        Input is integer convert to numeric display
*
INT_OUT  DS    0H
         LA    R1,11(,R4)                * point after receiving
         CR    R1,R5                     * is the output full
         BNL   OVERFLOW                  * yes error
*
         L     R1,0(R8)                  * get integer value
         CVD   R1,DOUB_WORD
         CP    DOUB_WORD,=P'0'
         BL    I_NEG
         MVI   10(R4),C'+'
         B     I_DONE
I_NEG    DS    0H
         MVI   10(R4),C'-'
I_DONE   DS    0H
         OI    DOUB_WORD+7,X'0F'
         UNPK  0(10,R4),DOUB_WORD
         CLI   NUM_ZERO,C'Y'             * show leading zeroes
         BE    I_DONEX                   * they are there
         LR    R1,R4                     * get address of output
         LA    R2,9                      * get length to check
I_CHK0   CLI   0(R1),C'0'                * is this byte zero
         BNE   I_DONEX                   * no so job done
         MVI   0(R1),C' '                * blank it
         LA    R1,1(,R1)                 * next byte
         BCT   R2,I_CHK0                 * check next
I_DONEX  DS    0H
         LA    R4,11(,R4)                * move past output bytes
         B     DONE_IT
*
*        Input is un-signed integer convert to numeric display
*
UINT_OUT DS    0H
         LA    R1,10(,R4)                * point after receiving
         CR    R1,R5                     * is the output full
         BNL   OVERFLOW                  * yes error
*
         L     R1,0(R8)                  * get integer value
         SRL   R1,1                      * divide by 2
         CVD   R1,DOUB_WORD              * convert to decimal
         MP    DOUB_WORD,=P'2'           * multiply by 2
         TM    3(R8),X'01'               * was low bit on
         BZ    U_DONE
         AP    DOUB_WORD,=P'1'           * add the one back in
U_DONE   DS    0H
         OI    DOUB_WORD+7,X'0F'         * set the sign
         UNPK  0(10,R4),DOUB_WORD        * unpack the value
         CLI   NUM_ZERO,C'Y'             * show leading zeroes
         BE    U_DONEX                   * they are there
         LR    R1,R4                     * get address of output
         LA    R2,9                      * get length to check
U_CHK0   CLI   0(R1),C'0'                * is this byte zero
         BNE   U_DONEX                   * no so job done
         MVI   0(R1),C' '                * blank it
         LA    R1,1(,R1)                 * next byte
         BCT   R2,U_CHK0                 * check next
U_DONEX  DS    0H
         LA    R4,10(,R4)                * move past output bytes
         B     DONE_IT
*
*        Input is small integer convert to numeric display
*
SINT_OUT DS    0H
         LA    R1,6(,R4)                 * point after receiving
         CR    R1,R5                     * is the output full
         BNL   OVERFLOW                  * yes error
*
         LH    R1,0(R8)                  * get small integer value
         CVD   R1,DOUB_WORD
         CP    DOUB_WORD,=P'0'
         BL    S_NEG
         MVI   5(R4),C'+'
         B     S_DONE
S_NEG    DS    0H
         MVI   5(R4),C'-'
S_DONE   DS    0H
         OI    DOUB_WORD+7,X'0F'
         UNPK  0(5,R4),DOUB_WORD
         CLI   NUM_ZERO,C'Y'             * show leading zeroes
         BE    S_DONEX                   * they are there
         LR    R1,R4                     * get address of output
         LA    R2,4                      * get length to check
S_CHK0   CLI   0(R1),C'0'                * is this byte zero
         BNE   S_DONEX                   * no so job done
         MVI   0(R1),C' '                * blank it
         LA    R1,1(,R1)                 * next byte
         BCT   R2,S_CHK0                 * check next
S_DONEX  DS    0H
         LA    R4,6(,R4)                 * move past output bytes
         B     DONE_IT
*
*        Input is un-signed small integer convert to numeric display
*
VINT_OUT DS    0H
         LA    R1,5(,R4)                 * point after receiving
         CR    R1,R5                     * is the output full
         BNL   OVERFLOW                  * yes error
*
         ICM   R1,3,0(R8)                * get small unsigned int val
         CVD   R1,DOUB_WORD
         OI    DOUB_WORD+7,X'0F'
         UNPK  0(5,R4),DOUB_WORD
         CLI   NUM_ZERO,C'Y'             * show leading zeroes
         BE    V_DONEX                   * they are there
         LR    R1,R4                     * get address of output
         LA    R2,4                      * get length to check
V_CHK0   CLI   0(R4),C'0'                * is this byte zero
         BNE   V_DONEX                   * no so job done
         MVI   0(R1),C' '                * blank it
         LA    R1,1(,R1)                 * next byte
         BCT   R2,V_CHK0                 * check next
V_DONEX  DS    0H
         LA    R4,5(,R4)                 * move past output bytes
         B     DONE_IT
*
*        Processed that pair of address/length values - any more
*
DONE_IT  DS    0H
         LA    R3,1(,R3)                 * point to next indicator
         CLI   0(R3),X'FF'               * finished ?
         BE    GO_BACK                   * then goback
*
         LA    R7,8(,R7)                 * next pair of addresses
         CLI   PAD_DING,C'Y'             * any pad characted ?
         BNE   GO_AGAIN                  * not so go again
         MVC   0(1,R4),PAD_DING+1        * copy pad character
         LA    R4,1(,R4)                 * jump past pad
         B     GO_AGAIN                  * process next
*
*        Return to calling program setting R1 to the output byte after
*        the last byte used.
*
GO_BACK  DS    0H
         ST    R4,4(,R10)                * save current output address
*                                        * in parameter list
         LM    R14,R12,12(R13)           * restore callers registers
         XR    15,15                     * set return code
         L     R1,4(,R1)                 * retrieve current output adr
*                                        * from parameter list
         BR    R14                       * return to caller
*********
*
* error routine
*
* There is no room in the output area for the input value so abend
*
OVERFLOW DS    0H
         WTO   'STRINGIT - output overflow detected',                  /
               ROUTCDE=11,MCSFLAG=HRDCPY
         ABEND 500,DUMP,STEP             * ,REASON=1
*********
*
* storage
*
WORKAREA       DSECT
DOUB_WORD      DS    D
FULL_WORD      DS    F
WORK2          DS    CL2
WORK3          DS    CL3
GLOB_IND       DS    CL15
               ORG   GLOB_IND
PAD_DING       DS    CL2             * pad details  (Y/N + value)
PAD_FRST       DS    CL1             * pad first value   (numeric)
NUM_ZERO       DS    CL1             * output numeric leading zeroes
               ORG
*
STRINGIT       CSECT
ZONES          DC    C'00000000'
TR_TAB         DC    C'0123456789ABCDEF'
MVC_IT         MVC   0(1,R4),0(R8)
UNPK_IT        UNPK  0(1,R4),0(1,R8)
CP_IT          CP    0(1,R8),=P'0'
*
               LTORG
*
               END
