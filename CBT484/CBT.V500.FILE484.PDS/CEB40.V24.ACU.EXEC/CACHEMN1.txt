/*  rexx exec to drive Amdahl Cache Utility   -----------------------*/
/*  (C) COPYRIGHT AMDAHL CORPORATION  1995. All Rights Reserved      */
/*  written:  January 1994                                           */
/*  author :  Chuck Baumann                                          */
/*  Panels :  CSHMAN1 CSHMAN2 CSHMAN3 CSHMAN4 CSHMAN5 CSHMAN6 CSHOPT */
/*  Panels :  CSHPERF                                                */
/*  Help   :  CSHHMAN1 CSHHMN11 CSHHMN12 CSHHMAN2 CSHHMAN3 CSHHOPT   */
/*  Externs:  CASHMAN, DEVTYPE, SLEEP (assembler modules)            */
/*  Message:  CSHM00, CSHM01, CSHM02                                 */
/*  Changes:  V1.0 -- Initial functions                              */
/*  94/02/02  V1.1 -- Libdef support added, SaveJCL bug fixed        */
/*  94/02/09          Retain table position, NVS help, NVS status    */
/*  94/02/09          Err msg to indicate blank volser for online dev*/
/*  94/02/10          Add Status to device panel to brws subsys stat */
/*  94/02/10          Correct = to continue if stat is already set   */
/*  94/02/10          Code to prevent split screen multiple sessions.*/
/*  94/06/07  V1.2 -- Code added to include model number on dev panl.*/
/*  94/06/07          Bug corrected for controller CFW status.       */
/*  94/06/08          Code modified to parse 3880 report correctly.  */
/*  94/06/08          Code added to reset tables following abend.    */
/*  94/06/16  V1.2a - Typo corrected on TBCREATE SMSTAB              */
/*  94/06/16          LIBDEF statements moved to beginning of EXEC   */
/*  94/06/16          LIBDEF added for ISPTLIB and ISPTABL           */
/*  94/06/16          Duplex logic corrected(dual copy)              */
/*-------------------------------------------------------------------*/
/*                    3880 corrections                               */
/*  94/06/27          Parse logic changed for 3880 controllers       */
/*  94/07/05          3880 device recognition logic updated          */
/*  94/07/05          3880 device refresh     logic updated          */
/*-------------------------------------------------------------------*/
/*  94/07/21  V1.3  - Enhanced logic to handle blank volsers         */
/*  94/07/21          Improved error messages for table failures     */
/*  94/07/25          Changed to allocate (libdef) unique table dsn  */
/*  94/07/25          Call to clean_up added prior to any exit       */
/*  94/08/13          Chng to pin data detection due to IBM omission.*/
/*  94/09/07          Moved model lookup from DEVTYPE to CACHEMN1    */
/*                    (user can add new models to Lookup_Model)      */
/*                    (or change how model is displayed)             */
/*  94/10/19          Added common procedure to execute commands     */
/*-------------------------------------------------------------------*/
/*  94/10/22  V2.0  - Added logic/screens to display cache performnce*/
/*                    statistics. (delta of stop - start)            */
/*                    Can display stats in foreground or background. */
/*  94/11/08          Correct sorting order for 3990 devices.        */
/*  94/11/29  V2.1  - Correct errors in Cache Write algorithms.      */
/*                    Modify panel field edits for cache perf window.*/
/*                    Modify Options logic to recognize new values.  */
/*  94/12/01          Modify logic to correct missing controller due */
/*                    to Rexx exponential interpretation.            */
/*  94/12/07  V2.2  - Return error codes from DEVTYPE and display msg*/
/*  95/01/03          Correct logic for HITS option not recognized   */
/*  95/01/03          HAPPY BIRTHDAY CACHEMAN ( 1 year old)          */
/*  95/01/14          Correct logic for initializing VERDEV & VERCTL */
/*-------------------------------------------------------------------*/
/*  95/01/20  V2.3  - Add Hits logic to Device panel                 */
/*  95/01/20          Add logging of calls to DEVTYPE                */
/*  95/01/20          Add undocumented commands to query usage detail*/
/*  95/01/20          SMF IEFU84 will be bundled (optional)          */
/*  95/01/22          DCACHE command added                           */
/*  95/01/22          Moved code to check ZCMD to common procedure   */
/*  95/01/22          Wrote new exec Cachemn0/compiled Rexx loadmods */
/*  95/01/22          Moved main LIBDEFS to CACHEMN0                 */
/*  95/01/25          Changed duplex pair to report CCA & not DDC    */
/*  95/02/01          Modify REFRESH logic to update device panel    */
/*  95/02/02          EXCEPT command added (exceptional conditions)  */
/*  95/02/02          Add logic to invoke CACHEMAN RESET (split scr) */
/*  95/02/02          Add logic to invoke WHAT's NEW panel           */
/*  95/02/03          Modify some 3880 logic for condition codes.    */
/*  95/02/04          Expose options values so they are updated.     */
/*  95/02/09          Add selection by Group (user defined groups).  */
/*  95/02/09          Created CACHEGRP exec for selection groups.    */
/*  95/03/14          Correct bug with testing of tbchan for selctn. */
/*-------------------------------------------------------------------*/
/*  95/04/03  V2.4  - Add logic to disable logging when log file full*/
/*  95/05/01          Made hilevel_qual a global var for alloc dsns. */
/*  95/05/30          Added SORT primary command for Ctlr panel.     */
/*  95/06/26          Changed Lookup_Model to use MDR devtype code   */
/*                    from DCE of UCB (don't need to alloc volume)   */
/*  95/07/10          Correct bug for display of Configured Cach stg */
/*-------------------------------------------------------------------*/
/*  95/09/07  V2.41 - Add logic to report SS stg and NVS stg correct */
/*                    from 3990-6 enhanced mode controller           */
/*  96/02/15          Expand field for NVS storage to 4 bytes        */
/*-------------------------------------------------------------------*/
/*  97/03/24  V2.42 - Expand field for NVS storage to 5 bytes (9999M)*/
/*-------------------------------------------------------------------*/
/*  97/08/06  V2.43 - Configured storage reported in bytesK          */
/*                    convert to bytes and then do normal processing */
/*-------------------------------------------------------------------*/
/*  98/01/12  V2.44 - Corrected logic for storage in bytesK          */
/*                    convert to bytes and then do normal processing */
/*                    Add logic to allow append to existing groups   */
/*                    (for members containing controllers on more    */
/*                     than one screen)                              */
/*-------------------------------------------------------------------*/
arg parm

hold_msg = msg('OFF')      /* turn off messages while exec is running*/
sorted = 'N'
/*-------------------------------------------------------------------*/
/* Version of exec    (displayed in title of panels)                 */
/*        Change to identify which version is being used             */
/*-------------------------------------------------------------------*/
address 'ISPEXEC' 'VGET (VERS) PROFILE'
prior_version = vers       /* Will test to see if first time new rlse*/
vers  = 'V2.44'            /* Ver of Cacheman(displayed on panels)   */
vdate = '99/11/12'         /* Date of last update */
address 'ISPEXEC' 'VPUT (VERS) PROFILE'

signal on HALT             /* Trap PA1/ATTN keys */

/*-------------------------------------------------------------------*/
/*  allocate a unique table dataset for each Cacheman user           */
/*  This prevents an enqueue failure if two users are using Cacheman */
/*  at the same time.  The table dataset is used to save data that   */
/*  will be displayed on the screen.                                 */
/*-------------------------------------------------------------------*/

userid = sysvar(sysuid)         /* used in Query_Info panel */
hilevel_qual = userid

tdsn  = "'"hilevel_qual".CACHEMAN.ISPTABL'"
tbl_exists = sysdsn(tdsn)
if tbl_exists = 'DATASET NOT FOUND'
then do
       address 'TSO' 'FREE FI(CACHTMP)'
       address 'TSO' 'ALLOC FI(CACHTMP) DA('tdsn') ,
       NEW CATALOG TRACKS SPACE(3,1) DIR(5) RECFM(F,B) LRECL(80) ,
       BLKSIZE(6160)'
       if rc > 0
       then do
              say 'Allocation of a table dataset failed.'
              say 'DSN= 'tdsn
              say 'Correct problem or manually allocate ' tdsn
              say 'and then re-invoke the exec'
              call Clean_up
              return
            end
       address 'TSO' 'FREE FI(CACHTMP)'
     end
address 'ISPEXEC' "LIBDEF ISPTLIB DATASET ID("tdsn")"
address 'ISPEXEC' "LIBDEF ISPTABL DATASET ID("tdsn")"

/*-------------------------------------------------------------------*/
/* Check variable in profile pool to tst if this application is      */
/* already active on another logical screen.                         */
/* If YES and split screen is active, then disallow second invocation*/
/*-------------------------------------------------------------------*/
address 'ISPEXEC' 'VGET (ZSPLIT) SHARED'
address 'ISPEXEC' 'VGET (CACHACT,CACHUSE) PROFILE'
if cachact = 'YES' & zsplit = 'YES' & parm ¬= 'RESET'
then do
       address 'ISPEXEC' 'SETMSG MSG(CSHM018) COND'
       return
     end
else do
       if datatype(cachuse) = 'NUM'
       then cachuse = cachuse + 1
       else cachuse = 1
       cachact = 'YES'
       address 'ISPEXEC' 'VPUT (CACHACT,CACHUSE) PROFILE'
     end
/*-------------------------------------------------------------------*/
/* if user's profile version is different from value in this exec it */
/* must be the first time the user is using this new release. Tell   */
/* them what is new in this release. (will also be true if users     */
/* profile is somehow deleted)                                       */
/*-------------------------------------------------------------------*/
if prior_version ¬= vers
then do
       address 'ISPEXEC' 'DISPLAY PANEL(CSHWNEW) CURSOR(ZCMD)'
     end

/*-------------------------------------------------------------------*/
/* Return ERRORs to the dialog for handling                          */
/* Close all tables (even if not open) in case of previous abend     */
/*-------------------------------------------------------------------*/
address 'ISPEXEC' 'CONTROL ERRORS RETURN'
address 'ISPEXEC' 'TBCLOSE EXCEPT'
address 'ISPEXEC' 'TBCLOSE MEMBTAB'
address 'ISPEXEC' 'TBCLOSE VOLTABLE'
address 'ISPEXEC' 'TBCLOSE SSGTAB'
address 'ISPEXEC' 'TBCLOSE CHTTAB'
address 'ISPEXEC' 'TBCLOSE CSTTABLE'
address 'ISPEXEC' 'TBCLOSE DEVTAB'
address 'ISPEXEC' 'TBCLOSE SMSTAB'
/*-------------------------------------------------------------------*/
/* Get option variables from the profile pool.  If they don't already*/
/* exist display the option panel so user can set (CSHOPT)           */
/*-------------------------------------------------------------------*/

address 'ISPEXEC' 'VGET (CACHVW CACHLOG CACHREF CACHST CACHSCNT ,
       CACHSPIN CACHSRAT CACHMB CACHSDV CACHDSTG CACHDCNT CACHDPIN ,
       CACHDSUB CACHDDUP ATCACH ATCFW ATNVS CACHCNF CACHXCP) PROFILE'
if rc ¬= 0
then call Set_Options
else call Set_Verifies

/*-------------------------------------------------------------------*/
/* Was logging requested in options? If yes then allocate a new or   */
/* existing log file of format sysuid.CACHE.LOG.                     */
/*-------------------------------------------------------------------*/

if CACHLOG = 'YES'
then do
       ldsn  = "'"hilevel_qual".CACHE.LOG'"
       log_exists = sysdsn(ldsn)
       if log_exists = 'OK'
       then do
              address 'TSO' 'ALLOC FI(CACHLG) DA('ldsn') MOD KEEP'
              if rc > 0
              then do
                     CACHLOG = 'NO'
                     emsg = 'CSHM005' /* logfile alloc fail */
                   end
            end
       else do
              cmd = 'ALLOC FI(CACHLG) DA(' || ldsn || ') NEW '
              cmd = cmd 'CATALOG TRACKS SPACE(3,3) RECFM(F,B) '
              cmd = cmd 'BLKSIZE(6160)'
              address 'TSO' cmd
              if rc > 0
              then do
                     CACHLOG = 'NO'
                     emsg = 'CSHM005' /* logfile alloc fail */
                   end
            end
       queue date('U') time() '********* New Session **********'
       address 'TSO' 'EXECIO 1 DISKW CACHLG'
     end


/*-------------------------------------------------------------------*/
/* Save the value of the PFKEY selected for refreshing the screen    */
/* so it can be restored to the original value on exit.              */
/* Terminals with 12 PFKEYS still use the variables 13-24 to handle  */
/* the settings.                                                     */
/*-------------------------------------------------------------------*/
address 'ISPEXEC' 'VGET (CACHREF,ZKEYS) PROFILE'

pfk_num = cachref
if pfk_num < 13 & zkeys = 12
then pfk_num = cachref + 12

pfkey = 'ZPF'||right(pfk_num,2,'0')

address 'ISPEXEC' 'VGET ('pfkey') PROFILE'
saved_pfk = value(pfkey)
interpret pfkey '= ''REF'''
address 'ISPEXEC' 'VPUT ('pfkey') PROFILE'

/*-------------------------------------------------------------------*/
/*  Use outtrap to get output from LISTDATA commands                 */
/*-------------------------------------------------------------------*/
  dummy = outtrap('rline.','*','NOCONCAT')

  grplist = '¢'                   /* initialize with attrib char   */
  vergrp  = ''

  address 'TSO' 'LISTD' tdsn 'MEM'

  do i = 7 to rline.0             /* first 6 lines are data set info */
    member = strip(rline.i,'B',' ')
    if substr(member,1,1) = 'G'
    then do
           name = substr(member,2,length(member)-1)
           vergrp = vergrp || ',' || name
           grplist = grplist left(name,9)
         end
  end
  vergrp = strip(vergrp,'L',',')        /* get rid of the leading , */
  address 'ISPEXEC' 'VPUT (GRPLIST,VERGRP) SHARED'
/*-------------------------------------------------------------------*/
/* Create table of every req online dasd. This will be used to issue */
/* the LISTDATA cmds to build a table w/status of each unique subsys */
/* Cashman is an assembler routine that displays a panel to allow    */
/* selected volsers or unit addresses to be included in the table it */
/* constructs (VOLTAB).  This table will be used to select contrlrs  */
/* to be displayed on main panel.                                    */
/*-------------------------------------------------------------------*/
do forever     /* this loop is exited when PF3 is entered in CASHMAN */
  saved_ssid = 0            /*--Initialized variables--*/
  new_tbssst = ''           /*--Initialized variables--*/
  new_tbsdst = ''           /*--Initialized variables--*/
  new_tbnvst = ''           /*--Initialized variables--*/
  emsg       = ''           /*--Initialized variables--*/
  grpname    = ''

  address 'ISPEXEC' 'SELECT PGM(CASHMAN)'
  if rc = 8             /* PF3 was pressed on selection panel */
  then do
         call Clean_up
         return
       end

  address 'ISPEXEC' 'VGET (GRPNAME) SHARED'
  if grpname ¬= ''
  then do
         member = 'G' || grpname
         address 'ISPEXEC' 'TBOPEN' member
         if rc ¬= 0
         then do
                grpname = ''
                ctlr.0 = 0
                address 'ISPEXEC' 'SETMSG MSG(CSHM033) COND'
              end
         else do
                rows = 0
                address 'ISPEXEC' 'TBSORT' member 'FIELDS(TADDR,N,A)'
                address 'ISPEXEC' 'TBQUERY' member 'ROWNUM(ROWS)'
                if rows = 0
                then grpname = ''
                else ctlr.0 = rows
                do i = 1 to rows
                  address 'ISPEXEC' 'TBSKIP' member
                  address 'ISPEXEC' 'TBGET' member
                  ctlr.i = tbu
                end
                address 'ISPEXEC' 'TBCLOSE' member
              end
       end

/*-------------------------------------------------------------------*/
/*  Subsystem Storage Table will contain all information shown on    */
/*  Controller panel.                                                */
/*-------------------------------------------------------------------*/
  address 'ISPEXEC' 'TBCREATE SSGTAB ,
  NAMES(TBMDL,TBSSID,TBSSSTG,TBSSAVL,TBNVSAVL,TBNVSSTG,TBSSST,TBSDST, ,
       TBNVST,TBV,TBU,TBDTYP,TBPIN,TBOFF,TBUD,TBSSIDD) NOWRITE REPLACE'
  if rc > 4
  then do
         say 'Creation of subsystem table SSGTAB failed - rc = ' rc
         call Clean_up
         return
       end

/*-------------------------------------------------------------------*/
/*  Issue the LISTDATA commands for each unique entry in the VOLTABLE*/
/*-------------------------------------------------------------------*/
  address 'ISPEXEC' 'TBOPEN VOLTABLE NOWRITE SHARE'
  if rc ¬= 0
  then do
         say 'Open of volser table VOLTABLE failed - rc = ' rc
         call Clean_up
         return
       end
  address 'ISPEXEC' 'TBQUERY VOLTABLE ROWNUM(ROWS)'

  old_addr = 0
  i = 1
  do rows
     address 'ISPEXEC' 'TBSKIP VOLTABLE'  /* position to next line   */
     address 'ISPEXEC' 'TBGET  VOLTABLE'  /* read row from table     */
     addr = substr(tbchan,1,3)            /* compare first 3 digits  */
     d_addr = x2d(addr)                   /* because 0Ex is exponent */
     if grpname ¬= ''
     then if x2d(substr(ctlr.i,1,3)) ¬= d_addr
          then iterate
          else if i < ctlr.0
               then i = i + 1

     if d_addr ¬= old_addr                /* probably new controller */
     then do
            old_addr = d_addr
            call List_Stat TBVOL TBDEVT 'TBADD' TBCHAN
          end
  end

  address 'ISPEXEC' 'TBCLOSE VOLTABLE'

  if rows = 0             /* if voltable had no entries */
  then do
         address 'ISPEXEC' 'SETMSG MSG(CSHM010) COND'
         rc = 8           /* this will exit gracefully w/no panel */
       end
  if CACHXCP = 'YES'      /* CACHXCP set on OPTions panel         */
  then call Cachxcpt      /* can also use EXCEPT command to see   */

  select_group = 0

/*-------------------------------------------------------------------*/
/*  Display PANEL until PF3 or END command issued                    */
/*-------------------------------------------------------------------*/
  do while rc < 8
    if datatype(ZTDTOP) = 'NUM' & sorted = 'N'
    then do
           address 'ISPEXEC' 'TBTOP SSGTAB'
           address 'ISPEXEC' 'TBSKIP SSGTAB ROW('ZTDTOP')'
         end
    sorted = 'N'
    pan  = 'CSHMAN1'

    if emsg = ''
    then address 'ISPEXEC' 'TBDISPL SSGTAB PANEL('pan') CURSOR(ACT)'
    else address 'ISPEXEC' 'TBDISPL SSGTAB PANEL('pan') CURSOR(ACT) ,
         MSG('emsg')'
    if rc > 8
    then do
           say 'Table display failed - panel or message was not found'
           say 'Panel = ' pan   'Emsg = ' emsg
           call Clean_up
           return
         end

    emsg = ''
    sel = 'Y'

    first_member = 1
    do while sel = 'Y'       /* ZTDSELS is the system variable which */
      if ZTDSELS ¬= 0        /* contains a count of the number of    */
      then                   /* lines that were modified in the table*/
        do
          select

            when ACT = CACHST
            then do
                   cmdl = 'LISTDATA STATUS VOL('TBV') UNIT('TBDTYP')'
                   call Execute_Cmd 4
                   if result < 5
                   then call Browse_Tmp
                 end

            when ACT = CACHSCNT
            then do
                   cmdl = 'LISTDATA COUNTS VOL('TBV')'
                   cmdl = cmdl || ' UNIT('TBDTYP') SUBSYSTEM'
                   call Execute_Cmd 4
                   if result < 5
                   then call Browse_Tmp
                 end

            when ACT = CACHMB     /* add to a select group */
            then do
                   select_group = 1
                   taddr = x2d(tbu)
                   if first_member
                   then do
                          first_member = 0
                          address 'ISPEXEC' 'TBCREATE MEMBTAB ,
                            NAMES(TBMDL,TBSSID,TBU,TADDR,TCM) ,
                            NOWRITE REPLACE'
                          address 'ISPEXEC' 'TBADD MEMBTAB'
                        end
                   else do
                          address 'ISPEXEC' 'TBADD MEMBTAB'
                        end
                 end

            when ACT = CACHSRAT
            then do
                   if tbmdl = '3880'
                   then emsg = 'CSHM020' /* not valid cmd 3880 */
                   else do
                          call Confirm_CachPerf
                          if result = 0
                          then
                            do
                              rtype = 'SUBSYSTEM'
                              address 'ISPEXEC' 'VGET (CMODE) PROFILE'
                      address 'ISPEXEC' 'VGET (SAMPTIME,NUMINT) SHARED'
                              if cmode = 'F'  /* do it foreground */
                              then
                                do
                                  cmdl = 'LISTDATA COUNTS VOL('TBV')'
                             cmdl = cmdl || ' UNIT('TBDTYP') SUBSYSTEM'
                                  call Execute_Cmd 0
                                  if result = 0
                                  then call Get_Cache_Rates ,
                                            rtype tbv tbdtyp
                                end
                              else
                              if cmode = 'B'  /* do it in batch   */
                              then call Batch_CachPerf
                            end
                        end
                 end

            when ACT = CACHSDV
            then do
                   call Get_Dev_Info TBV TBDTYP
                   call Dev_Process
                   address 'ISPEXEC' 'TBCLOSE DEVTAB'
                 end
/*---------------------------------------------------------------*/
/* if ACT is blank, the user modified some field to change the   */
/* status of cache or NVS.  Save the three input fields and 'get'*/
/* the original row.  Compare the values to see which changed    */
/* and then issue the correct SETCACHE command.                  */
/*---------------------------------------------------------------*/
            when ACT = ' '
            then do
                   new_tbssst = tbssst
                   new_tbsdst = tbsdst
                   new_tbnvst = tbnvst
                   call Bld_Setcache_Cmd
                 end
/*---------------------------------------------------------------*/
/* if ACT is '=', the user wants to make the same changes to the */
/* status of cache or NVS for another controller. Check to see   */
/* if a valid change was made first.  Then apply the same changes*/
/* to the new controller.                                        */
/*---------------------------------------------------------------*/
            when ACT = '='
            then do
                   if new_tbssst ¬= '' ,
                    | new_tbsdst ¬= '' ,
                    | new_tbnvst ¬= ''
                   then call Bld_Setcache_Cmd
                   else emsg = 'CSHM004'   /* no change to repeat */
                 end

            when ACT = CACHSPIN
            then do
                   if tbmdl = '3880'
                   then emsg = 'CSHM020' /* not valid cmd 3880 */
                   else do
                          rline.0 = 0  /* problem w/outtrap*/
                          cmdl = 'LISTDATA PINNED VOL('TBV')'
                          cmdl = cmdl || ' UNIT('TBDTYP') SUBSYSTEM'
                          call Execute_Cmd 4
                          if result = 4 & rline.0 = 0
                          then emsg = 'CSHM012'
                          else call Browse_Tmp
                        end
                 end

            when ACT = CACHDSTG
            then do
                   if tbmdl = '3880'
                   then emsg = 'CSHM020' /* not valid cmd 3880 */
                   else do
                          call Confirm_Destage
                          if result ¬= 0
                          then nop
                          else do
                                 setc_cmd = 'DESTAGE'
                                 call Exec_Setcache tbv setc_cmd
                               end
                        end
                 end

            otherwise nop
          end
          if ZTDSELS = 1     /* processed last line with action */
          then if select_group  /* user has selected controllers */
               then do          /* to create a selection group   */
                      address 'ISPEXEC' 'CONTROL DISPLAY SAVE'

                      call 'CACHEGRP' tdsn

                      address 'ISPEXEC' 'CONTROL DISPLAY RESTORE'
                      address 'ISPEXEC' 'TBCLOSE MEMBTAB'
                      select_group = 0
                      first_member = 1
                    end
/*---------------------------------------------------------------*/
/* A TBDISPL with no panel parameter will decrement the value    */
/* of ZTDSELS (selected/modified lines) by one and position the  */
/* table to the next corresponding record.                       */
/*---------------------------------------------------------------*/
          if emsg = ''
          then address 'ISPEXEC' 'TBDISPL SSGTAB CURSOR(ACT)'
          else address 'ISPEXEC' 'TBDISPL SSGTAB CURSOR(ACT) ,
               MSG('emsg')'
          emsg = ''
        end
      else sel = 'N'
    end

    call Process_ZCMD 'CTL'
  end

  address 'ISPEXEC' 'TBCLOSE SSGTAB'
end

call Clean_up
return

/*-------------------------------------------------------------------*/
/*-------------------------------------------------------------------*/
/*     SUBROUTINES start here                                        */
/*-------------------------------------------------------------------*/
/*-------------------------------------------------------------------*/
/*     Execute_Cmd    starts here                                    */
/*     Common logic to issue the actual LISTDATA cmd and test retcd. */
/*-------------------------------------------------------------------*/
Execute_Cmd:
arg expected_rc

  address 'TSO' cmdl
  cc = rc
  if rc > expected_rc
  then do
         call Rc8_Display rc cmdl
         rc = 0
       end
  call WriteLog cc cmdl
return(cc)
/*-------------------------------------------------------------------*/
/*     Dev_Process    starts here                                    */
/*     Logic to handle mods to devices on device panel               */
/*-------------------------------------------------------------------*/
Dev_Process:
procedure expose tbmdl tbssst tbsdst tbnvst cachlog cachst cachsdv ,
   cachspin cachscnt cachdstg cachdcnt cachdpin cachddup cachdsub ,
   cachsrat new_thcach new_thdfw emsg rline. cachcnf act_3880. ,
   cachmb vdate verdev verctl tdsn hilevel_qual userid

address 'ISPEXEC' 'CONTROL DISPLAY SAVE'
address 'ISPEXEC' 'TBSORT  DEVTAB FIELDS(TDECAD)'

emsg    = ''

do while rc < 8
  if datatype(ZTDTOP) = 'NUM'
  then do
         address 'ISPEXEC' 'TBTOP DEVTAB'
         address 'ISPEXEC' 'TBSKIP DEVTAB ROW('ZTDTOP')'
       end
  if emsg = ''
  then address 'ISPEXEC' 'TBDISPL DEVTAB PANEL(CSHMAN3) CURSOR(LOP)'
  else address 'ISPEXEC' 'TBDISPL DEVTAB PANEL(CSHMAN3) CURSOR(LOP) ,
                 MSG('emsg')'
  if rc > 8
  then do
         say 'Table display failed - panel or message was not found'
         say 'Panel = CSHMAN3  Emsg = ' emsg
         call Clean_up
         exit
       end
  emsg = ''
  sel = 'Y'
  do while sel = 'Y'
    if ZTDSELS ¬= 0
    then do
           call Devtype TVOLSR
           dev_result = result
           cc = c2d(substr(dev_result,9,1))
           if cc ¬= 0
           then call Process_Devtype_Err result
           cmdl = 'call Devtype' TVOLSR
           call WriteLog cc cmdl

           devcyl = substr(dev_result,6,2)
           tmod = Lookup_model(substr(dev_result,3,1) devcyl)
           devt = substr(tmod,1,4)
          select
           when LOP = CACHDSUB
           then do
                  cmdl = 'LISTDATA STATUS VOL('TVOLSR') UNIT('devt')'
                  call Execute_Cmd 4
                  if result < 5
                  then call Browse_Tmp
                end
           when LOP = CACHDPIN
           then do
                  if tbmdl = '3880'
                  then emsg = 'CSHM020' /* not valid cmd 3880 */
                  else do
                         cmdl = 'LISTDATA PINNED VOL('TVOLSR')'
                         cmdl = cmdl 'UNIT('devt') DEVICE'
                         call Execute_Cmd 4
                         if result = 4
                         then emsg = 'CSHM012'   /* no pinned data */
                         else call Browse_Tmp
                       end
                end
           when LOP = CACHDCNT
           then do
             cmdl = 'LISTDATA COUNTS VOL('TVOLSR') UNIT('devt') DEVICE'
                  address 'TSO' cmdl
                  call Execute_Cmd 4
                  if result < 5
                  then call Browse_Tmp
              end
           when LOP = CACHDDUP
           then do
                  if tbmdl = '3880'
                  then emsg = 'CSHM020' /* not valid cmd 3880 */
                  else do
                         address 'ISPEXEC' 'CONTROL DISPLAY SAVE'
                         call 'CACHEDUP' tvolsr devt tad cachlog cachcnf
                         address 'ISPEXEC' 'CONTROL DISPLAY RESTORE'
                       end
              end
           when LOP = CACHSRAT
           then do
                  if tbmdl = '3880'
                  then emsg = 'CSHM020' /* not valid cmd 3880 */
                  else do
                         call Confirm_CachPerf
                         if result = 0
                         then
                           do
                             rtype = 'DEVICE'
                             address 'ISPEXEC' 'VGET (CMODE) PROFILE'
                     address 'ISPEXEC' 'VGET (SAMPTIME,NUMINT) SHARED'
                             if cmode = 'F'  /* do it foreground */
                             then
                               do
                                 cmdl = 'LISTDATA COUNTS VOL('TVOLSR')'
                                 cmdl = cmdl 'UNIT('devt') DEVICE'
                                 call Execute_Cmd 0
                                 if result = 0
                                 then call Get_Cache_Rates ,
                                           rtype tvolsr devt
                               end
                             else
                             if cmode = 'B'  /* do it in batch   */
                             then call Batch_CachPerf
                           end
                       end
                end
/*---------------------------------------------------------------*/
/* if LOP is blank, the user modified some field to change the   */
/* status of cache or DFW.  Save the two   input fields and 'get'*/
/* the original row.  Compare the values to see which changed    */
/* and then issue the correct SETCACHE command.                  */
/*---------------------------------------------------------------*/
           when LOP = ' '
           then do
                  new_thcach = thcach
                  new_thdfw   = thdfw
                  call Bld_Setc_Dev_Cmd
                end
/*---------------------------------------------------------------*/
/* if LOP is '=', the user wants to make the same changes to the */
/* status of cache or DFW for another device.     Check to see   */
/* if a valid change was made first.  Then apply the same changes*/
/* to the new device.                                            */
/*---------------------------------------------------------------*/
             when LOP = '='
             then do
                    if new_thcach ¬= '' ,
                     | new_thdfw ¬= ''
                    then call Bld_Setc_Dev_Cmd
                    else emsg = 'CSHM004'   /* no change to repeat */
                  end
             otherwise nop
           end
           if emsg = ''
           then address 'ISPEXEC' 'TBDISPL DEVTAB CURSOR(LOP)'
           else address 'ISPEXEC' 'TBDISPL DEVTAB CURSOR(LOP) ,
                MSG('emsg')'
           emsg = ''
         end
    else sel = 'N'
  end
  call Process_ZCMD 'DEV'
end

address 'ISPEXEC' 'CONTROL DISPLAY RESTORE'
return

/*-------------------------------------------------------------------*/
/*     Merge_3880_Info starts here                                   */
/*-------------------------------------------------------------------*/
Merge_3880_Info:
procedure expose tad tvolsr thcach thdfw thdup thpin thpri thsec ,
                 tscach tsdfw tscfw tdecad rline. act_3880.
arg Ltable Lssst

thdfw = 'N/A'
thpri = ''
thsec = ''
thdup = 'N/A'
thpin = 'N/A'
tsdfw = 'N/A'
tscfw = 'N/A'
thcach = '???'
indx   = 0

do i = 2 to rline.0
  parse var rline.i word1 word2 .
  if word1 = 'VOLUME'
  then do
         call Devtype word2
         dev_result = result
         cc = c2d(substr(dev_result,9,1))
         if cc ¬= 0
         then call Process_Devtype_Err result
         cmdl = 'call Devtype' word2
         call WriteLog cc cmdl

         tvolsr = word2
         devcyl = substr(dev_result,6,2)
         tmod = Lookup_model(substr(dev_result,3,1) devcyl)
         tad = right(c2x(substr(dev_result,1,2)),4,'0')
         tmp = substr(tad,3,1)
         tmp = x2d(tmp)
         if tmp // 2 = 0
         then offset = 0
         else offset = 16
         ix = indx + offset

         tdecad = right(x2d(tad),5,'0')
         thcach = act_3880.ix
         indx = indx + 1

         call Actual_Status thcach thdfw Lssst 'N/A' 'N/A'
         parse var result tscach .
         address 'ISPEXEC' 'TBADD DEVTAB'
         i = i + 16      /* skip other report output lines  */
       end
end
return

/*-------------------------------------------------------------------*/
/*     Merge_Hdwr_Info starts here                                   */
/*-------------------------------------------------------------------*/
Merge_Hdwr_Info:
procedure expose tad tvolsr thcach thdfw thdup thpin thpri thsec ,
                 tscach tsdfw tscfw tdecad rline.
arg Ltable Lssst Lsdst Lnvst


thpin  = ' NO'
address 'ISPEXEC' 'TBOPEN SMSTAB'
do i = 3 to rline.0
  parse var rline.i word1 word2 .
  if word1 = 'VOLUME'
  then do
         call Get_SMS_Info word2    /* word2 is the volser */
         parse var result  tad tvolsr tsdup tspin tsdupst tsddc tscca
         tdecad = right(x2d(tad),5,'0')

         call Devtype tvolsr
         dev_result = result
         cc = c2d(substr(dev_result,9,1))
         if cc ¬= 0
         then call Process_Devtype_Err result
         cmdl = 'call Devtype' tvolsr
         call WriteLog cc cmdl

         devcyl = substr(dev_result,6,2)
         tmod = Lookup_model(substr(dev_result,3,1) devcyl)
         thpin = tspin   /* get info from SMS ctl blks until */
                         /* Listdata Counts report is fixed  */
         i = i + 16      /* skip other report output lines  */
       end

  select
    when word1 = 'DEVICE'
    then do
           parse var rline.i . 'CACHING:' cach .
           if cach = 'ACTIVE'
           then thcach = 'ON'
           else thcach = 'OFF'
         end
    when word1 = 'DASD'
    then do
           parse var rline.i . 'WRITE:' dfw .
           if dfw = 'ACTIVE'
           then thdfw = 'ON'
           else thdfw = 'OFF'
         end
    when word1 = 'DUPLEX'
    then do
           thpri = ''
           thsec = ''
           parse var rline.i . 'PAIR:' dup .
           if dup = 'NOT'
           then thdup = ' NO'
           else
           if substr(dup,1,3) = 'PRI'
           then do
                  thpri = 'YES'
                  thdup = substr(tsdupst,1,3)
                  thsec = right(tscca,3)
                end
           else
           if substr(dup,1,3) = 'SEC'
           then do
                  thsec = 'YES'
                  thdup = substr(tsdupst,1,3)
                  thpri = right(tscca,3)
                end
           else thdup = substr(dup,1,3)
         end
    when word1 = 'PINNED'
    then thpin = 'YES'
    when word2 = 'STORAGE'
    then do
           call Actual_Status thcach thdfw Lssst Lsdst Lnvst
           parse var result tscach tsdfw tscfw
           address 'ISPEXEC' 'TBADD DEVTAB'
           thpin = ' NO'
           i = i + 1
         end
    otherwise nop
  end
end
call Actual_Status thcach thdfw Lssst Lsdst Lnvst
parse var result tscach tsdfw tscfw
address 'ISPEXEC' 'TBADD DEVTAB'     /* write last record into table */
address 'ISPEXEC' 'TBCLOSE SMSTAB'
return

/*-------------------------------------------------------------------*/
/*  This procedure will check both device and controller status to   */
/*  determine the actual/overall caching status of this device.      */
/*-------------------------------------------------------------------*/
Actual_Status:
procedure expose rline.
arg Lhcach Lhdfw Lssst Lsdst Lnvst

cache = 'OFF'
nvs   = 'OFF'
cfw   = 'OFF'
if Lhcach = 'ON' & Lssst = 'ON'
then do
       cache = 'ON'
       if Lhdfw = 'ON' & Lnvst = 'ON'
       then do
              nvs = 'ON'
              if Lsdst = 'ON'
              then cfw = 'ON'
            end
     end
line = cache nvs cfw
return(line)

/*-------------------------------------------------------------------*/
/*     Bld_3880_Dev_Info starts here                                 */
/* Creates a table which contains caching status of dasd devices     */
/* connected to this 3880 controller.                                */
/*-------------------------------------------------------------------*/
Bld_3880_Dev_Info:
procedure expose rline. act_3880.

do i = 1 to rline.0
  parse var rline.i word1 word2 .
  if word1 = 'FOR' & word2 = 'DEVICES'
  then do
         parse var rline.i . 'DEVICES' act_ln1
         do j = 0 to 31
            act_3880.j = 'OFF'
         end
         do j = 1 to words(act_ln1)
            indx =  word(act_ln1, j)
            indx = x2d(indx)
            act_3880.indx = 'ON '
         end
         i = i + 1
         act_ln2 = rline.i
         do j = 1 to words(act_ln2)
            indx =  word(act_ln2, j)
            indx = x2d(indx)
            act_3880.indx = 'ON '
         end
         i = rline.0      /* skip rest of output lines */
       end
end
return

/*-------------------------------------------------------------------*/
/*     Bld_SMS_Info starts here                                      */
/* Creates a table in ascending order by volser that will be matched */
/* with the hardware information for the corresponding volser.       */
/*-------------------------------------------------------------------*/
Bld_SMS_Info:
procedure expose rline.

address 'ISPEXEC' 'TBCREATE SMSTAB KEYS(TVOLSR) ,
         NAMES(TAD,TSDUP,TSDUPST,TSCCA,TSDDC,TSPIN) WRITE REPLACE'

do i = 1 to rline.0
  parse var rline.i word1 .
  if word1 = 'DEV'
  then do
         do j = i + 1 to rline.0
           parse var rline.j tad tvolsr . . tscach ,
                     tsdfw tsdup
           if word(tsdup,1) = 'NO'
           then parse var tsdup tsdup tspin tsnvs
           else
           if word(tsdup,1) = 'PRI' | word(tsdup,1) = 'SEC'
           then parse var tsdup tsdup tsdupst tspin tsnvs . tscca tsddc
           if tad = '3990' | tad = 'DEVICE' | tad = 'SUBSYSTEM' ,
              | substr(tad,1,3) = '...' | tad = 'DEV'
           then nop                /* skip the page break headings */
           else address 'ISPEXEC' 'TBADD SMSTAB'
         end
         i = rline.0
       end
end
address 'ISPEXEC' 'TBSORT  SMSTAB FIELDS(TVOLSR)'
address 'ISPEXEC' 'TBCLOSE SMSTAB'
return

/*-------------------------------------------------------------------*/
/*     Bld_Status_Info starts here                                   */
/* Creates a table in ascending order by string that will be show    */
/* status of all devices in string for Cache, DFW, and duplex.       */
/* Funky logic because of the way I chose to list strings. One       */
/* controller may have multiple strings so keep track of duplicate   */
/* DSTATUS reports and exclude from the table.                       */
/*-------------------------------------------------------------------*/
Bld_Status_Info:
procedure expose rline. chan dv0 dv1 dv2 dv3 dv4 dv5 dv6 dv7 dv8 dv9 ,
                 dva dvb dvc dvd dve dvf last_unit_address

dv0 = '...'
dv1 = '...'
dv2 = '...'
dv3 = '...'
dv4 = '...'
dv5 = '...'
dv6 = '...'
dv7 = '...'
dv8 = '...'
dv9 = '...'
dva = '...'
dvb = '...'
dvc = '...'
dvd = '...'
dve = '...'
dvf = '...'
write = 'N'
save_chan = 0
do i = 1 to rline.0
  parse var rline.i word1 .
  if word1 = 'DEV'
  then
    do
      do j = i + 1 to rline.0
        if substr(rline.j,8,1) ¬= ' '  /* volser might be blank */
        then parse var rline.j uadr . . . cach dfw duplex
        else parse var rline.j uadr . . cach dfw duplex

        if uadr = '3990' | uadr = 'DEVICE' | uadr = 'SUBSYSTEM' ,
           | substr(uadr,1,3) = '...' | uadr = 'DEV'
        then iterate            /* skip the page break headings */

        if x2d(uadr) < last_unit_address
        then leave           /* don't waste time on duplicates */
        else last_unit_address = x2d(uadr)

        next_chn = substr(uadr,1,length(uadr)-1)
        next_chn = next_chn || 0
        d_chan = x2d(next_chn)        /* remember 0E0 is exponent */
        if save_chan ¬= d_chan & save_chan > 0
        then do
               pline = chan dv0 dv1 dv2 dv3 dv4 dv5 dv6 dv7 dv8
               pline = pline dv9 dva dvb dvc dvd dve dvf
               queue pline
               address 'TSO' 'EXECIO' queued() 'DISKW CSHDCST (FINIS'
               address 'ISPEXEC' 'TBADD STATTAB'
               write = 'N'
               dv0 = '...'
               dv1 = '...'
               dv2 = '...'
               dv3 = '...'
               dv4 = '...'
               dv5 = '...'
               dv6 = '...'
               dv7 = '...'
               dv8 = '...'
               dv9 = '...'
               dva = '...'
               dvb = '...'
               dvc = '...'
               dvd = '...'
               dve = '...'
               dvf = '...'
             end

        chan = substr(uadr,1,length(uadr)-1)
        chan = chan || 0
        save_chan = d_chan
        pos_in_string = substr(uadr,length(uadr),1)
        vardev = 'DV' || pos_in_string
        if word(duplex,1) = 'NO'
        then parse var duplex duplex pin nvs
        else
        if word(duplex,1) = 'PRI' | word(duplex,1) = 'SEC'
        then parse var duplex duplex . pin nvs .
        val = substr(cach,1,1)||substr(dfw,1,1)||substr(duplex,1,1)
        interpret vardev '= val'
        write = 'Y'
      end
      i = rline.0
      if write = 'Y'
      then do
             pline = chan dv0 dv1 dv2 dv3 dv4 dv5 dv6 dv7 dv8
             pline = pline dv9 dva dvb dvc dvd dve dvf
             queue pline
             address 'TSO' 'EXECIO' queued() 'DISKW CSHDCST (FINIS'
             address 'ISPEXEC' 'TBADD STATTAB'
             write = 'N'
           end
    end
end

return

/*-------------------------------------------------------------------*/
/*     Bld_Setcache_Cmd starts here                                  */
/*-------------------------------------------------------------------*/
Bld_Setcache_Cmd:
procedure expose new_tbssst new_tbsdst new_tbnvst emsg ,
                 tbssst tbsdst tbnvst cachlog rline. cachcnf

/* Get the original value from the table and compare to the new value*/
/* If the new value is different AND NOT null, this field was changed*/
/* Null signifies that the field was not changed (used by = logic)   */

address 'ISPEXEC' 'TBGET SSGTAB'
if tbssst ¬= new_tbssst & new_tbssst ¬= ''
then do
       if new_tbssst = 'YES' | new_tbssst = 'ON' ,
        | new_tbssst = 'ONF' | new_tbssst = 'YFF'
       then do
              setc_cmd = 'SUBSYSTEM ON'
              new_tbssst = 'ON'
            end
       else
       if new_tbssst = 'OFF' | new_tbssst = 'NO' ,
        | new_tbssst = 'OF'  | new_tbssst = 'NN'
       then do
              setc_cmd = 'SUBSYSTEM OFF'
              new_tbssst = 'OFF'
            end
       else emsg = 'CSHM001'
       if emsg = ''
       then do
              call Exec_Setcache tbv setc_cmd
              if result = 0
              then do
                     tbssst = new_tbssst
                     address 'ISPEXEC' 'TBPUT SSGTAB ORDER'
                   end
            end
     end
else nop             /* new_tbssst = ''    nothing changed */
if tbsdst ¬= new_tbsdst & new_tbsdst ¬= ''
then do
       if tbmdl = '3880'
       then emsg = 'CSHM020'    /* not valid command for 3880s */
       else
       if new_tbsdst = 'YES' | new_tbsdst = 'ON' ,
        | new_tbsdst = 'ONF' | new_tbsdst = 'YFF'
       then do
              setc_cmd = 'CACHEFW ON'
              new_tbsdst = 'ON'
            end
       else
       if new_tbsdst = 'NO' | new_tbsdst = 'OFF' ,
        | new_tbsdst = 'OF' | new_tbsdst = 'NN'
       then do
              setc_cmd = 'CACHEFW OFF'
              new_tbsdst = 'OFF'
            end
       else emsg = 'CSHM002'
       if emsg = ''
       then do
              call Exec_Setcache tbv setc_cmd
              if result = 0
              then do
                     tbsdst = new_tbsdst
                     address 'ISPEXEC' 'TBPUT SSGTAB ORDER'
                   end
            end
     end
else nop            /* new_tbsdst = ''  nothing changed */
if tbnvst ¬= new_tbnvst & new_tbnvst ¬= ''
then do
       if tbmdl = '3880'
       then emsg = 'CSHM020'    /* not valid command for 3880s */
       else
       if new_tbnvst = 'YES' | new_tbnvst = 'ON' ,
        | new_tbnvst = 'ONF' | new_tbnvst = 'YFF'
       then do
              setc_cmd = 'NVS ON'
              new_tbnvst = 'ON'
            end
       else
       if new_tbnvst = 'NO' | new_tbnvst = 'OFF' ,
        | new_tbnvst = 'OF' | new_tbnvst = 'NN'
       then do
              setc_cmd = 'NVS OFF'
              new_tbnvst = 'OFF'
            end
       else emsg = 'CSHM001'
       if emsg = ''
       then do
              call Exec_Setcache tbv setc_cmd
              if result = 0
              then do
                     tbnvst = new_tbnvst
                     address 'ISPEXEC' 'TBPUT SSGTAB ORDER'
                   end
            end
     end
else nop            /* new_tbnvst = '' nothing changed */
return

/*-------------------------------------------------------------------*/
/*     Bld_Setc_Dev_Cmd starts here                                  */
/*-------------------------------------------------------------------*/
Bld_Setc_Dev_Cmd:
procedure expose new_thcach new_thdfw emsg thcach thdfw cachlog ,
                 tbssst tbsdst tbnvst rline. cachcnf

/* Get the original value from the table and compare to the new value*/
/* If the new value is different AND NOT null, this field was changed*/
/* Null signifies that the field was not changed (used by = logic)   */

address 'ISPEXEC' 'TBGET DEVTAB'
tbv = tvolsr
if thcach ¬= new_thcach & new_thcach ¬= ''
then do
       if new_thcach = 'YES' | new_thcach = 'ON' ,
        | new_thcach = 'ONF' | new_thcach = 'YFF'
       then do
              setc_cmd = 'DEVICE ON'
              new_thcach = 'ON'
            end
       else
       if new_thcach = 'NO' | new_thcach = 'OFF' | new_thcach = 'OF' ,
        | new_thcach = 'OF' | new_thcach = 'NN'
       then do
              setc_cmd = 'DEVICE OFF'
              new_thcach = 'OFF'
            end
       else emsg = 'CSHM001'
       if emsg = ''
       then do
              call Exec_Setcache tbv setc_cmd
              if result = 0
              then do
                     thcach = new_thcach
                     call Actual_Status thcach thdfw tbssst tbsdst ,
                          tbnvst
                     parse var result tscach tsdfw tscfw
                     address 'ISPEXEC' 'TBPUT DEVTAB'
                   end
            end
     end
else nop           /* new_thcach = '' nothing changed */
if thdfw ¬= new_thdfw & new_thdfw ¬= ''
then do
       if new_thdfw = 'ON'  | new_thdfw = 'YES' ,
        | new_thdfw = 'ONF' | new_thdfw = 'YFF'
       then do
              setc_cmd = 'DASDFW ON'
              new_thdfw = 'ON'
            end
       else
       if new_thdfw = 'OFF' | new_thdfw = 'NO' ,
        | new_thdfw = 'OF'  | new_thdfw = 'NN'
       then do
              setc_cmd = 'DASDFW OFF'
              new_thdfw = 'OFF'
            end
       else emsg = 'CSHM001'
       if emsg = ''
       then do
              call Exec_Setcache tbv setc_cmd
              if result = 0
              then do
                     thdfw = new_thdfw
                     call Actual_Status thcach thdfw tbssst tbsdst ,
                          tbnvst
                     parse var result tscach tsdfw tscfw
                     address 'ISPEXEC' 'TBPUT DEVTAB'
                   end
            end
     end
else nop            /* new_thdfw = '' nothing changed */
return

/*-------------------------------------------------------------------*/
/*     Exec_Setcache starts here                                     */
/*-------------------------------------------------------------------*/
Exec_Setcache:
procedure expose rline. cachlog cachcnf
arg Lvolsr Lcmd

/* Devtype is a user written external REXX function (assembler) that */
/* will return the devicetype (3380 or 3390 or 33??) and model in    */
/* RESULT.  DEVICETYPE is the first 4 chars of result.               */

  cc = 0
  call Devtype Lvolsr
  dev_result = result
  cc = c2d(substr(dev_result,9,1))

  if cc ¬= 0
  then call Process_Devtype_Err result
  cmdl = 'call Devtype' Lvolsr
  call WriteLog cc cmdl

  devcyl = substr(dev_result,6,2)
  tmod = Lookup_model(substr(dev_result,3,1) devcyl)
  devt = substr(tmod,1,4)
  if CACHCNF = 'YES'
  then do
         zwinttl = 'SETCACHE' Lcmd 'VOL('Lvolsr') UNIT('devt')'
         address 'ISPEXEC' 'ADDPOP ROW(9)'
         address 'ISPEXEC' 'DISPLAY PANEL(CSHSETC) CURSOR(ZCMD)'
         cc = rc
         address 'ISPEXEC' 'REMPOP'
       end
  if cc = 0
  then do
         cmdl = 'SETCACHE' Lcmd 'VOL('Lvolsr') UNIT('devt')'
         call Execute_Cmd 0
         cc = result
       end

return(cc)

/*-------------------------------------------------------------------*/
/*     Display_Cache_Stat starts here                                */
/* Creates table of all devices CACHE, DFW, DUPlex status and        */
/* displays it in a grid format.                                     */
/*-------------------------------------------------------------------*/
Display_Cache_Stat:
procedure expose rline. emsg hilevel_qual

address 'ISPEXEC' 'TBCREATE STATTAB ,
         NAMES(CHAN,DV0,DV1,DV2,DV3,DV4,DV5,DV6,DV7,DV8,DV9,DVA,DVB, ,
               DVC,DVD,DVE,DVF) NOWRITE REPLACE'
timex = time()
parse var timex hh ':' mm ':' ss
dyntm = 'T'hh||mm||ss
oname = "'"hilevel_qual".CACHEST."dyntm"'"
address 'TSO' 'ALLOC FI(CSHDCST) DA('oname') MOD CATALOG TRACKS ,
       SPACE(1,1) RECFM(F,B) LRECL(80) BLKSIZE(6160)'
if rc ¬= 0
then do
       title = 'Output File Allocate Failed'
       call Rc8_Display rc title
     end
else do
       pline = 'STR  0   1   2   3   4   5   6   7   8   9   A   B   C'
       pline = pline '  D   E   F'
       queue pline
     end

/*-------------------------------------------------------------------*/
/*  Issue the LISTDATA DSTATUS  for each unique entry in the CSTTABLE*/
/*-------------------------------------------------------------------*/
  address 'ISPEXEC' 'TBOPEN CSTTABLE NOWRITE SHARE'
  if rc ¬= 0
  then do
         say 'Open of volser table CSTTABLE failed - rc = ' rc
         call Clean_up
         exit
       end
  address 'ISPEXEC' 'TBQUERY CSTTABLE ROWNUM(ROWS)'

  do rows
     address 'ISPEXEC' 'TBSKIP CSTTABLE'  /* position to next line   */
     address 'ISPEXEC' 'TBGET  CSTTABLE'  /* read row from table     */
     cmdl = 'LISTDATA DSTATUS VOL('tvol') UNIT('tdevice') SUBSYSTEM'
     call Execute_Cmd 12
     call Bld_Status_Info
  end

  emsg = 'CSHM027'
  address 'TSO' 'FREE FI(CSHDCST)'
  address 'ISPEXEC' 'TBCLOSE CSTTABLE'
  address 'ISPEXEC' 'TBTOP STATTAB'
  pan  = 'CSHMAN6'
  address 'ISPEXEC' 'CONTROL DISPLAY SAVE'
  do while rc ¬= 8
    if emsg = ''
    then address 'ISPEXEC' 'TBDISPL STATTAB PANEL('pan')'
    else address 'ISPEXEC' 'TBDISPL STATTAB PANEL('pan') MSG('emsg')'
  end
  address 'ISPEXEC' 'CONTROL DISPLAY RESTORE'
  address 'ISPEXEC' 'TBCLOSE STATTAB'

return

/*-------------------------------------------------------------------*/
/*     Get_Dev_Info starts here                                      */
/* Creates DEVTAB and extracts data from LISTDATA commands.          */
/*-------------------------------------------------------------------*/
Get_Dev_Info:
procedure expose rline. act_3880. tbmdl tbssst tbsdst tbnvst tdecad ,
          cachlog
arg Ltbv Ltbdtyp

table = 'DEVTAB'

if substr(tbmdl,1,4) = '3990'
then do
       cmdl = 'LISTDATA DSTATUS VOL('Ltbv') UNIT('Ltbdtyp') SUBSYSTEM'
       call Execute_Cmd 0
       call Bld_SMS_Info
     end
else do  /* for 3880 */
       cmdl = 'LISTDATA STATUS VOL('Ltbv') UNIT('Ltbdtyp')'
       call Execute_Cmd 4
       call Bld_3880_Dev_Info
     end

cmdl = 'LISTDATA COUNTS VOL('Ltbv') UNIT('Ltbdtyp') SUBSYSTEM'
call Execute_Cmd 4

address 'ISPEXEC' 'TBCLOSE DEVTAB'
address 'ISPEXEC' 'TBCREATE DEVTAB ,
         NAMES(TAD,TVOLSR,THCACH,THDFW,THDUP,THPIN,THPRI, ,
         THSEC,TSCACH,TSDFW,TSCFW,TDECAD,TMOD) WRITE REPLACE'
if rc > 4
then do
       if rc = 8
       then say 'DEVTAB table already exists.'
       else
       if rc = 12
       then say 'Table in use by another user. Enqueue failed'
       else
       if rc = 16
       then say 'Write mode specified & table input lib not allocated'
       else say 'Severe error'

       say 'Creation of DEVTAB failed - rc = ' rc
       call Clean_up
       exit
     end
if substr(tbmdl,1,4) = '3990'
then call Merge_Hdwr_Info table tbssst tbsdst tbnvst
else call Merge_3880_Info table tbssst

address 'ISPEXEC' 'TBSORT  DEVTAB FIELDS(TDECAD)'

return

/*-------------------------------------------------------------------*/
/*     Get_SMS_Info starts here                                      */
/* Returns SMS info from the SMS table.                              */
/*-------------------------------------------------------------------*/
Get_SMS_Info:
procedure expose rline. tdecad
arg Lvolser

tvolsr = Lvolser
address 'ISPEXEC' 'TBGET SMSTAB'
if rc > 0
then do
       address 'ISPEXEC' 'SETMSG MSG(CSHM021)'
       tdecad = tdecad + 1
       tad = d2x(tdecad)
       tvolsr = '      '
       tsdup  = ''
       tsdupst = ''
       tsddc   = ''
       tscca   = ''
       tspin   = ''
     end
tline = tad tvolsr tsdup tspin tsdupst tsddc tscca

return(tline)

/*-------------------------------------------------------------------*/
/*     Browse_Tmp     starts here                                    */
/*     Logic to handle mods to devices on device panel               */
/*-------------------------------------------------------------------*/
Browse_Tmp:
procedure expose rline. hilevel_qual

do i = 1 to rline.0
  queue rline.i
end
timex = time()
parse var timex hh ':' mm ':' ss
dyntm = 'T'hh||mm||ss
oname = "'"hilevel_qual".STATUS."dyntm"'"
address 'TSO' 'ALLOC FI(CSHSTAT) DA('oname') NEW CATALOG TRACKS ,
  SPACE(2,1) RECFM(F,B) LRECL(80) BLKSIZE(6160)'
if rc = 0
then do
       address 'TSO' 'EXECIO' queued() 'DISKW CSHSTAT'
       address 'TSO' 'EXECIO 0 DISKW CSHSTAT (FINIS'
       call Browse_Dsn oname
       address 'TSO' 'FREE FI(CSHSTAT)'
       address 'TSO' 'DELETE' oname
     end
else do
       title = 'Output File Allocate Failed'
       call Rc8_Display rc title
     end
return

/*-------------------------------------------------------------------*/
/*     BrwsDataSet    starts here                                    */
/*-------------------------------------------------------------------*/
Browse_Dsn:
procedure expose rline.
arg Lname

  address 'ISPEXEC' 'CONTROL DISPLAY SAVE'
  address 'ISPEXEC' 'BROWSE DATASET('Lname')'
  if rc >= 12
  then address 'ISPEXEC' 'SETMSG MSG(CSHM006)'
  address 'ISPEXEC' 'CONTROL DISPLAY RESTORE'
return

/*-------------------------------------------------------------------*/
/*     Parse_Listd   starts here                                     */
/*-------------------------------------------------------------------*/
ParseListd:
procedure expose rline. saved_ssid act_3880. cachlog
arg Ltable Luaddr Ldevtyp Lfunc Lvolser

tbpin = ' NO'    /* initialize because PINNED is not in 3880-23 rpt*/
tbsdst = 'N/A'   /* initialize because CFW is n/a   for 3880s      */
tbnvst = 'N/A'   /* initialize because NVS is n/a   for 3880s      */
do i = 1 to rline.0
  parse var rline.i tok1 tok2 tok3 tok4 .
  select
     when tok1 = '3990'
     then do
            model = ''
            parse var rline.i . 'MODEL' model
            model = strip(model,'B',' ')
            tbmdl = tok1 || '-' || model
          end
     when tok1 = '3380' | tok1 = '3350'
     then do
            tbmdl = '3880   '
            tbv   = Lvolser
            /* the type of 3880 controller is not in report output */
          end
     when tok1 = 'VOLUME'
     then do
            tbv = tok2
          end
     when tok2 = 'ID'
     then do
            parse var rline.i . 'X' ssid .
            ssid = strip(ssid,'B',"'")
/* convert to hex to avoid xxEx being interpreted as exponential num */
            if saved_ssid = x2d(ssid)
            then return          /* don't bother to process anythng*/
            else do
                   tbssid = right(ssid,4,0)
                   tbssidd = x2d(tbssid)
                 end
          end

/* if subsytem storage < 32M then this is a 3990-6 enhanced mode ctlr*/
/* and the value returned is in kilobytes. Convert it to bytes */
/* version 2.43 since 3990-6 enhanced mode  now reports amounts in K */

     when tok1 = 'CONFIGURED'
     then do
            parse var rline.i . ssstg nvsstg .
            if pos('K',ssstg) > 0
            then do
                   ssstg = strip(ssstg,'T','K')
                   ssstg = ssstg * 1024
                 end
            if pos('K',nvsstg) > 0
            then do
                   nvsstg = strip(nvsstg,'T','K')
                   nvsstg = nvsstg * 1024
                 end

            if ssstg < (32 * 1048576)
            then do
                   ssstg = ssstg * 1024
                   enhanced_ss = 1
                 end
            else enhanced_ss = 0

            tbssstg = ssstg / 1048576
            tbssstg = format(tbssstg,4,0) ||'M'
            tbssstg = right(tbssstg,5)
            if substr(tbmdl,1,4) = '3990'
            then do
/* if nonvoltl storage < 4M then this is a 3990-6 enhanced mode ctlr*/
/* and the value returned is in kilobytes. Convert it to bytes */
                   if nvsstg < (4 * 1048576)
                   then do
                           enhanced_nvs = 1
                           nvsstg = nvsstg * 1024
                        end
                   else enhanced_nvs = 0
                   tbnvsstg = nvsstg / 1048576
                   tbnvsstg = format(tbnvsstg,4,0) ||'M'
                   tbnvsstg = right(tbnvsstg,5)
                 end
            else tbnvsstg = 'N/A'
          end
     when tok1 = 'AVAILABLE'
     then do
            parse var rline.i . ssavl nvsavl .
            if enhanced_ss
            then ssavl = ssavl * 1024

            if pos('K',ssavl) > 0
            then do
                   ssavl = strip(ssavl,'T','K')
                   ssavl = ssavl * 1024
                 end

            if pos('K',nvsavl) > 0        /* ie   596k    */
            then do
                   nvsavl = strip(nvsavl,'T','K')
                   nvsavl = nvsavl * 1024
                 end

            if ssavl > 1048576
            then do
                   ssavl = ssavl / 1048576
                   tbssavl = format(ssavl,4,0)||'M'
                 end
            else
            if ssavl > 1024
            then do
                   ssavl = ssavl / 1024
                   tbssavl = format(ssavl,4,0)||'K'
                 end
            else tbssavl = right(ssavl,4)
            if substr(tbmdl,1,4) = '3990'
            then do
                   if datatype(nvsavl) = 'NUM' & nvsavl > 1048576
                   then do
                          nvsavl = nvsavl / 1048576
                          tbnvsavl = format(nvsavl,4,0)||'M'
                        end
                   else
                   if datatype(nvsavl) = 'NUM' & nvsavl > 1024
                   then do
                          nvsavl = nvsavl / 1024
                          tbnvsavl = format(nvsavl,4,0)||'K'
                        end
                   else tbnvsavl = 'N/A'
                 end
            else tbnvsavl = 'N/A'
          end
     when tok1 = 'PINNED'
     then do
            parse var rline.i . sspin nvspin .
            tbsspin = right(sspin,10)
            tbnvspin = right(nvspin,10)
            if tbsspin > 0
            then tbpin = 'YES'
            else tbpin = ' NO'
          end
     when tok1 = 'OFFLINE'
     then do
            parse var rline.i . ssoff nvsoff .
            tbssoff = right(ssoff,10)
            if tbssoff > 0
            then tboff = 'YES'
            else tboff = ' NO'
            if substr(tbmdl,1,4) = '3990'
            then tbnvsoff = right(nvsoff,10)
            else tbnvsoff = right('N/A',10)
          end
     when tok1 = 'SUBSYSTEM' & tok2 = 'CACHING'
     then do
            parse var rline.i . 'STATUS:' ssst ssst2 ssst3 .
            if ssst = 'ACTIVE'
            then ssst = 'ON'
            else
            if substr(ssst,1,2) = 'DE' & ssst2 = 'ERROR'
            then ssst = 'ERR'
            else
            if substr(ssst,1,2) = 'DE' & ssst2 = 'FAILED'
            then ssst = 'DFL'         /* deactivation failed */
            else ssst = ' OFF'
            tbssst = strip(ssst,'B',' ')
          end
     when tok1 = 'OVERALL' & tok2 = 'CACHING'
     then do
            parse var rline.i . 'STATUS' ssst .
            if ssst = 'ACTIVE'
            then ssst = 'ON'
            else ssst = ' OFF'
            tbssst = strip(ssst,'B',' ')
          end
     when tok1 = 'SD'
     then do
            parse var rline.i . 'CONDITIONS:' sdst
            parse var sdst t1 t2 t3 t4 t5
            if t1 = 'CACHE' & t2 = 'FAST' & t3 = 'WRITE'
            then do
                   if t4 = 'ACTIVE'
                   then sdst = 'ON'
                   else
                   if t4 = 'DISABLED'
                   then sdst = 'OFF'
                 end
            else
            if t1 = 'SUBSYSTEM' & t2 = 'DISABLED'
            then sdst = 'DIS'
            else sdst = 'OFF'
            tbsdst = strip(sdst,'B',' ')
          end
     when tok1 = 'NVS' | tok1 = 'NON-VOLATILE'
     then do
            parse var rline.i . 'STATUS:' nvst nvst2 nvst3
            if nvst = 'ACTIVE'
            then nvst = 'ON'
            else
            if nvst2 = 'ERROR'
            then nvst = 'ERR'
            else
            if nvst2 = 'FAILED'
            then nvst = 'DFL'
            else
            if nvst = 'DISABLED'
            then nvst = 'DIS'
            else nvst = 'OFF'
            tbnvst = strip(nvst,'B',' ')
            i = rline.0      /* skip rest of output lines */
          end
     otherwise nop
  end
  tbu = Luaddr
  tbud = x2d(tbu)         /* for sort key purposes */
  tbdtyp = Ldevtyp
end

/* convert to hex to avoid xxEx being interpreted as exponential num */
saved_ssid = x2d(tbssid)
address 'ISPEXEC' Lfunc 'SSGTAB ORDER'

return

/*-------------------------------------------------------------------*/
/*     Get_Cache_Rates starts here                                   */
/*-------------------------------------------------------------------*/
Get_Cache_Rates:
procedure expose rline. tbv tbdtyp interval samptime cachlog
arg ctlr_or_dev vol dtype
ix = 1
timex = time()
parse var timex hh ':' mm ':' ss
int_time.ix = hh * 3600 + mm * 60 + ss
call Parse_Counts ix
cc = 0
  do while cc < 8
    address 'ISPEXEC' 'TBCREATE CHTTAB ,
           NAMES(VOLSER,IO,CACHABLE,TOTHIT,DFWPCT,RW,RHIT,DFWHIT, ,
         CFWHIT,STAGE,DFWRETRY,BYPASS,INHIBIT,ADDR) NOWRITE REPLACE'
    if rc > 4
    then
      do
        say 'Creation of cache hit table CHTTAB failed - rc = ' rc
        call Clean_up
        exit
      end
    timex = time()
    parse var timex hh ':' mm ':' ss
    timex = hh * 3600 + mm * 60 + ss

    if int_time.ix + samptime > timex
    then this_interval = int_time.ix + samptime - timex
    else this_interval = 0
    if this_interval > 0
    then call Sleep this_interval

    ix = ix + 1
    timex = time()
    parse var timex hh ':' mm ':' ss
    int_time.ix = hh * 3600 + mm * 60 + ss
    cmdl = 'LISTDATA COUNTS VOL('vol') UNIT('dtype')' ctlr_or_dev
    call Execute_Cmd 0
    call Parse_Counts ix
    ctlr_bzer = 0
    ctlr_ezer = 0
    ctlr_aone = 0
    ctlr_bone = 0
    ctlr_cone = 0
    ctlr_done = 0
    ctlr_eone = 0
    ctlr_ftwo = 0
    ctlr_fthr = 0
    ctlr_ffive = 0
    iy = ix - 1
    interval = int_time.ix - int_time.iy
    do j = 1 to v
      bzer = b0.ix.j - b0.iy.j
      ctlr_bzer = ctlr_bzer + bzer

      czer = c0.ix.j - c0.iy.j       /* CFW total */

      ezer = e0.ix.j - e0.iy.j
      ctlr_ezer = ctlr_ezer + ezer

      aone = a1.ix.j - a1.iy.j
      ctlr_aone = ctlr_aone + aone
      bone = b1.ix.j - b1.iy.j
      ctlr_bone = ctlr_bone + bone
      cone = c1.ix.j - c1.iy.j
      ctlr_cone = ctlr_cone + cone

      done = d1.ix.j - d1.iy.j
      done = done + czer            /* following CRR report */
      ctlr_done = ctlr_done + done

      eone = e1.ix.j - e1.iy.j
      ctlr_eone = ctlr_eone + eone

      ftwo = f2.ix.j - f2.iy.j
      ctlr_ftwo = ctlr_ftwo + ftwo
      fthr = f3.ix.j - f3.iy.j
      ctlr_fthr = ctlr_fthr + fthr
      ffive = f5.ix.j - f5.iy.j
      ctlr_ffive = ctlr_ffive + ffive
      volser = vol.ix.j
      addr   = adr.ix.j
      io  = format((aone + cone + ftwo + fthr) / interval,,1)

      if (aone + done) > 0
      then cachable = format(((bone + eone) / (aone + done)) * 100,,1)
      else cachable = 0

      if (aone + cone + ftwo + fthr) > 0
      then tothit = format((bone + eone)/ ,
                    (aone + cone + ftwo + fthr) * 100,,1)
      else tothit = 0

      if done > 0
      then dfwpct = format((eone / done) * 100,,1)
      else dfwpct = 0

      dfwhit = format(done / interval,,1)
      cfwhit = format((bzer + ezer) / interval,,1)
      stage  = format((aone - bone + done - eone)/ interval,,1)

      if cone > 0
      then rw = format(aone / cone,,2)
      else rw = 0
      rhit   = format(bone / interval,,1)

      dfwretry = format(ffive / interval,,1)
      bypass = format(fthr / interval,,1)
      inhibit = format(ftwo / interval,,1)
      address 'ISPEXEC' 'TBADD CHTTAB'
    end
    volser = ' TOTAL'
    addr   = 00
    io  = format((ctlr_aone + ctlr_cone + ctlr_ftwo + ctlr_fthr) ,
          / interval,,1)

    if (ctlr_aone + ctlr_done) > 0
    then cachable = format(((ctlr_bone + ctlr_eone) / ,
                    (ctlr_aone + ctlr_done)) * 100,,1)
    else cachable = 0
    if (ctlr_aone + ctlr_cone + ctlr_ftwo + ctlr_fthr) > 0
    then tothit = format((ctlr_bone + ctlr_eone) / ,
           (ctlr_aone + ctlr_cone + ctlr_ftwo + ctlr_fthr) ,
             * 100,,1)
    else tothit = 0
    if ctlr_done > 0
    then dfwpct = format((ctlr_eone / ctlr_done) * 100,,1)
    else dfwpct = 0
    dfwhit = format(ctlr_done / interval,,1)
    cfwhit = format((ctlr_bzer + ctlr_ezer) / interval,,1)
    stage  = format((ctlr_aone - ctlr_bone + ,
             ctlr_done - ctlr_eone) / interval,,1)

    if ctlr_cone > 0
    then rw = format(ctlr_aone / ctlr_cone,,2)
    else rw = 0
    rhit   = format(ctlr_bone / interval,,1)
    dfwretry = format(ctlr_ffive / interval,,1)
    bypass = format(ctlr_fthr / interval,,1)
    inhibit = format(ctlr_ftwo / interval,,1)
    address 'ISPEXEC' 'TBADD CHTTAB'

    address 'ISPEXEC' 'TBSORT CHTTAB FIELDS(ADDR,N,A)'
    address 'ISPEXEC' 'CONTROL DISPLAY SAVE'
    address 'ISPEXEC' 'TBDISPL CHTTAB PANEL(CSHMAN5)'
    cc = rc
    address 'ISPEXEC' 'CONTROL DISPLAY RESTORE'
    address 'ISPEXEC' 'TBCLOSE CHTTAB'
  end
return

Parse_Counts:
v = 0
write1 = ''
do i = 1 to rline.0
  parse var rline.i tok1 .
  select
     when tok1 = 'VOLUME'
     then do
            v = v + 1
            parse var rline.i . vol.ix.v . . xaddr
            xaddr = substr(xaddr,2,length(xaddr)-1)
            xaddr = strip(xaddr,'B',"'")
            adr.ix.v = x2d(xaddr)
            i = i + 7
          end
     when tok1 = 'CACHE'
     then do
            parse var rline.i . 'WRITE' . b0.ix.v c0.ix.v . e0.ix.v .
            if datatype(e0.ix.v) ¬= 'NUM' then e0.ix.v = 0
          end

     when tok1 = 'TOTALS'
     then do
            parse var rline.i . a1.ix.v b1.ix.v c1.ix.v ,
                                d1.ix.v e1.ix.v .
            i = i + 1
          end
     when tok1 = 'INHIBIT'
     then do
            parse var rline.i 'LOADING' f2.ix.v .
          end
     when tok1 = 'BYPASS'
     then do
            parse var rline.i 'CACHE' f3.ix.v .
            i = i + 2
          end
     when tok1 = 'DASD'
     then do
            parse var rline.i 'RETRIES' f5.ix.v .
            i = i + 4
          end
     otherwise nop
  end
end
return

/*-------------------------------------------------------------------*/
/*     Lookup_Model   starts here                                    */
/*     MDR device type codes                                         */
/*     Hex      (Dec)                                                */
/*     x'11'      17            3350                                 */
/*     x'14'      20            3380-A                               */
/*     x'1B'      27            3380-E                               */
/*     x'1C'      28            3380-D                               */
/*     x'21'      33            3380-J                               */
/*     x'23'      35            3380-K                               */
/*     x'24'      36            3390-3                               */
/*     x'26'      38            3390-1                               */
/*     x'27'      39            3390-2                               */
/*     x'32'      50            3390-9   w/2724'x data & alt cyls    */
/*     x'32'      50            6395-5   w/13D4'x data & alt cyls    */
/*                                                                   */
/*-------------------------------------------------------------------*/
Lookup_Model:
arg MDR_code cyls_in_hex

select
  when MDR_code = '11'x    then type = '3350  '
  when MDR_code = '14'x    then type = '3380-A'
  when MDR_code = '1B'x    then type = '3380-E'
  when MDR_code = '1C'x    then type = '3380-D'
  when MDR_code = '21'x    then type = '3380-J'
  when MDR_code = '23'x    then type = '3380-K'
  when MDR_code = '24'x    then type = '3390-3'
  when MDR_code = '26'x    then type = '3390-1'
  when MDR_code = '27'x    then type = '3390-2'
  when MDR_code = '32'x
       then if cyls_in_hex = '13D4'x
            then type = '3390-5'
            else
            if cyls_in_hex = '2724'x
            then type = '3390-9'
            else type = '3390-x'
  otherwise do
              type = '?'
              mdrmsg = c2x(MDR_code)
              address 'ISPEXEC' 'SETMSG MSG(CSHM022) COND'
            end
end
return(type)

/*-------------------------------------------------------------------*/
/*     List_Stat      starts here                                    */
/*-------------------------------------------------------------------*/
List_Stat:
procedure expose act saved_ssid cachlog rline.
arg Lvolser Ldevt Lfunc Laddr

cmdl = 'LISTDATA STATUS VOL('Lvolser') UNIT('Ldevt')'
call Execute_Cmd 12
if result < 5                /* 3880s return 4 for SD offline */
then do
       act   = ''
       table = 'SSGTAB'
       call ParseListd table Laddr Ldevt Lfunc Lvolser
     end
return

/*-------------------------------------------------------------------*/
/*     Confirm_Destage starts here                                   */
/*-------------------------------------------------------------------*/
Confirm_Destage:
procedure expose rline.
/* Use a PopUp window to prompt for confirmation before DESTAGE      */

   address 'ISPEXEC' 'ADDPOP ROW(10)'
   zwinttl = 'Destage Confirmation'
   address 'ISPEXEC' 'DISPLAY PANEL(CSHDSTG) CURSOR(ZCMD)'
   cc = rc
   address 'ISPEXEC' 'REMPOP'
return(cc)

/*-------------------------------------------------------------------*/
/*     Confirm_CachPerf starts here                                  */
/*-------------------------------------------------------------------*/
Confirm_CachPerf:
procedure expose rline.
/* Use a PopUp window to prompt for foreground or background Cache   */
/* Performance statistics                                            */

   address 'ISPEXEC' 'ADDPOP ROW(10)'
   zwinttl = 'Cache Performance Stats'
   address 'ISPEXEC' 'DISPLAY PANEL(CSHPERF) CURSOR(ZCMD)'
   cc = rc
   address 'ISPEXEC' 'REMPOP'
return(cc)

/*-------------------------------------------------------------------*/
/*     Batch_CachPerf starts here                                    */
/*-------------------------------------------------------------------*/
Batch_CachPerf:
  address 'ISPEXEC' 'FTOPEN TEMP'
  address 'ISPEXEC' 'FTINCL CSHSKEL2'
  if rc = 0
  then
    do
      address 'ISPEXEC' 'FTCLOSE'
      address 'ISPEXEC' 'VGET (ZTEMPF)'
      address 'TSO' 'SUBMIT '''ztempf''''
      cc = 0
    end
return

/*-------------------------------------------------------------------*/
/*     Process_Devtype_Err starts here                               */
/*-------------------------------------------------------------------*/
Process_Devtype_Err:
procedure expose cc
arg Lresult

  if cc = 2                 /* invalid device type  */
  then
    do
      newdev = c2x(substr(Lresult,10,1))
      address 'ISPEXEC' 'SETMSG MSG(CSHM023) COND'
    end
  else
  if cc = 4                 /* DEVTYPE macro failed */
  then
    do
      address 'ISPEXEC' 'SETMSG MSG(CSHM024) COND'
    end
  else
  if cc = 8                 /* allocation or deallocation failed */
  then
    do
      address 'ISPEXEC' 'SETMSG MSG(CSHM025) COND'
    end
return

/*-------------------------------------------------------------------*/
/*     Set_Options  starts here                                      */
/*     display screen to prompt for new values                       */
/*     panel does the VPUT to add these to the profile               */
/*-------------------------------------------------------------------*/
Set_Options:
   address 'ISPEXEC' 'DISPLAY PANEL(CSHOPT)'
   rc = 0

   address 'ISPEXEC' 'VGET (CACHVW CACHLOG CACHREF CACHST CACHSCNT ,
       CACHSPIN CACHSRAT CACHMB CACHSDV CACHDSTG CACHDCNT CACHDPIN ,
       CACHDSUB CACHDDUP ATCACH ATCFW ATNVS CACHCNF CACHXCP) ASIS'
   call Set_Verifies
return

Set_Verifies:
/*-------------------------------------------------------------------*/
/* verctl and verdev are used for VER strings in the )PROC sections  */
/* of panels CSHMAN1 and CSHMAN3                                     */
/*-------------------------------------------------------------------*/
 verctl = CACHST||','||CACHSCNT||','||CACHSDV||','||CACHSPIN||','
 verctl = verctl||CACHSRAT||','||CACHDSTG||','||CACHMB||','' '',''='''

 verdev = CACHDCNT||','||CACHDPIN||','||CACHDSUB||','||CACHDDUP
 verdev = verdev||','||CACHSRAT||','' '',''='''
return

/*-------------------------------------------------------------------*/
/*     Rc8_Display    starts here                                    */
/* Use a PopUp window to display the error messages from the IDCAMS  */
/* functions.                                                        */
/*-------------------------------------------------------------------*/
Rc8_Display:
procedure expose rline.
arg Lretcode Ltitle

   cc = lretcode
   address 'ISPEXEC' 'TBCREATE ERRTB NAMES(XLINE) NOWRITE REPLACE'
   do i = 1 to rline.0
      xline = rline.i
     address 'ISPEXEC' 'TBADD ERRTB'
   end
   address 'ISPEXEC' 'ADDPOP ROW(9)'
   zwinttl = Ltitle
   address 'ISPEXEC' 'TBTOP ERRTB'
   address 'ISPEXEC' 'TBDISPL ERRTB PANEL(CSHERRP) CURSOR(ZCMD)'
   address 'ISPEXEC' 'REMPOP'
   address 'ISPEXEC' 'TBCLOSE ERRTB'
return

/*-------------------------------------------------------------------*/
/*     Process_ZCMD   starts here                                    */
/*-------------------------------------------------------------------*/
Process_ZCMD:
procedure expose rline. act_3880. tbmdl tbssst tbsdst tbnvst tdecad ,
         tbu cachlog zcmd saved_ssid emsg vdate verdev verctl cachvw ,
         cachlog cachref cachst cachscnt cachspin cachsrat cachsdv ,
         cachdstg cachdcnt cachdpin cachdsub cachddup atcach atcfw ,
         atnvs cachcnf cachxcp tdsn ldsn hilevel_qual sorted userid
arg Lsection

   if substr(ZCMD,1,3) = 'REF'     /* refresh controller status */
   then do
          if Lsection = 'DEV'
          then do
                 address 'ISPEXEC' 'TBGET  SSGTAB'
                 call Get_Dev_Info TBV TBDTYP
               end

          if Lsection = 'CTL'
          then saved_ssid = 0
          address 'ISPEXEC' 'TBQUERY SSGTAB ROWNUM(ROWS) ,
                             POSITION(CROW)'
          address 'ISPEXEC' 'TBTOP SSGTAB'
          do rows
            address 'ISPEXEC' 'TBSKIP SSGTAB'
            address 'ISPEXEC' 'TBGET  SSGTAB'
            call List_Stat TBV TBDTYP 'TBPUT' TBU
          end
          address 'ISPEXEC' 'TBTOP SSGTAB'
          address 'ISPEXEC' 'TBSKIP SSGTAB ROW('CROW')'
        end
   else
   if substr(ZCMD,1,3) = 'NEW'     /* check for What's new request */
   then do
          address 'ISPEXEC' 'DISPLAY PANEL(CSHWNEW) CURSOR(ZCMD)'
        end
   else
   if substr(ZCMD,1,3) = 'EXC'     /* check for exceptional status */
   then do
          call 'CACHXCPT'
        end
   else
   if substr(ZCMD,1,3) = 'MEM'     /* invoke member selection proc */
   then do
          call 'CACHEGRP' tdsn
        end
   else
   if ZCMD = 'OPT'
   then do
          /* restore value to previous used PFKEY */
          interpret pfkey '= saved_pfk'
          address 'ISPEXEC' 'VPUT ('pfkey') PROFILE'

          call Set_Options

          address 'ISPEXEC' 'VGET (CACHREF,ZKEYS) PROFILE'
          pfk_num = cachref
          if pfk_num < 13 & zkeys = 12
          then pfk_num = cachref + 12
          pfkey = 'ZPF'||right(pfk_num,2,'0')
          address 'ISPEXEC' 'VGET ('pfkey') PROFILE'
          saved_pfk = value(pfkey)
          interpret pfkey '= ''REF'''
          address 'ISPEXEC' 'VPUT ('pfkey') PROFILE'
          rc = 0
        end
   else
   if substr(ZCMD,1,3) = 'VDA'     /* query version date */
   then call Query_Info
   else
   if substr(ZCMD,1,3) = 'SOR' & Lsection = 'CTL'  /* display order */
   then do
          sorted = 'Y'
          address 'ISPEXEC' 'VGET (OBJECT,VALUE) SHARED'
          if object = 'SSID'
          then if value= 'D'
              then address 'ISPEXEC' 'TBSORT SSGTAB FIELDS(TBSSIDD,N,D)'
              else address 'ISPEXEC' 'TBSORT SSGTAB FIELDS(TBSSIDD,N,A)'
          else
          if object = 'CACHE' | object = 'MEM'
          then if value= 'D'
               then address 'ISPEXEC' 'TBSORT SSGTAB ,
                             FIELDS(TBSSSTG,C,D,TBUD,N,A)'
               else address 'ISPEXEC' 'TBSORT SSGTAB ,
                             FIELDS(TBSSSTG,C,A,TBUD,N,A)'
          else
          if object = 'NVS'
          then if value= 'D'
               then address 'ISPEXEC' 'TBSORT SSGTAB ,
                             FIELDS(TBNVSSTG,C,D,TBUD,N,A)'
               else address 'ISPEXEC' 'TBSORT SSGTAB ,
                             FIELDS(TBNVSSTG,C,A,TBUD,N,A)'
          else address 'ISPEXEC' 'TBSORT SSGTAB FIELDS(TBUD,N,A)'
        end
   else
   if substr(ZCMD,1,3) = 'DCA'     /* display cache status of all */
   then do
          address 'ISPEXEC' 'SELECT PGM(CACHSTAT)'
          call Display_Cache_Stat
        end
return

/*-------------------------------------------------------------------*/
/*     WriteLog       starts here                                    */
/*-------------------------------------------------------------------*/
WriteLog:
procedure expose cachlog rline.
arg Lretcode Lcmdline

 if CACHLOG = 'YES'
 then do
        queue date('U') time() 'RC='right(Lretcode,2)  Lcmdline
        address 'TSO' 'EXECIO 1 DISKW CACHLG (FINIS'
        if rc > 0
        then do
               CACHLOG = 'NO'
               address 'ISPEXEC' 'SETMSG MSG(CSHM036) COND'
             end
      end

return

/*-------------------------------------------------------------------*/
/*     Query_Info     starts here                                    */
/*-------------------------------------------------------------------*/
Query_Info:
  zwinttl = 'Cacheman Information'
  address 'ISPEXEC' 'ADDPOP ROW(4)'
  address 'ISPEXEC' 'DISPLAY PANEL(CSHINFO)'
  address 'ISPEXEC' 'REMPOP'
return

/*-------------------------------------------------------------------*/
/*     Cleanup        starts here                                    */
/*-------------------------------------------------------------------*/
Clean_up:

if CACHLOG = 'YES'
then do
       address 'TSO' 'EXECIO 0 DISKW CACHLG (FINIS'
       address 'TSO' 'FREE FI(CACHLG)'
     end
interpret pfkey '= saved_pfk'
address 'ISPEXEC' 'VPUT ('pfkey') PROFILE'
dummy = msg(hold_msg)
address 'ISPEXEC' 'LIBDEF ISPTLIB'
address 'ISPEXEC' 'LIBDEF ISPTABL'
cachact = 'NO'
address 'ISPEXEC' 'VPUT (CACHACT) PROFILE'
return

HALT:
address 'ISPEXEC' 'TBCLOSE' table
address 'ISPEXEC' 'TBCLOSE SSGTAB'
call Clean_up
exit

SYNTAX:
say 'Syntax  on line' sigl
say 'RC =' rc
return
