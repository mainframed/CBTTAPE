         TITLE 'DYNAMIC ALLOCATION INTERFACE'
*
*   CREATE A VERB TABLE ENTRY
*
         MACRO
         VENT  &VERB,&NUMBER
         LCLA  &LABEL
&LABEL   SETA  &SYSNDX
         DC    AL1(L'#&LABEL)
         DC    AL1(&NUMBER)
#&LABEL  DC    C'&VERB'
         MEND
         SPACE 3
*
*   CREATE A KEYWORD TABLE ENTRY
*   &KEYWORD  - THE DYNAM KEYWORD
*   &UAL      - THE DYNAM KEYWORD UNAMBIGOUS LENGTH
*   &KEY      - THE SVC99 TEXT UNIT KEY
*   &PARM     - THE SVC99 TEXT UNIT PARM
*   &PARMLEN  - THE SVC99 TEXT UNIT PARM LENGTH
*
         MACRO
         KENT  &KEYWORD,&UAL,&KEY,&PARM,&PARMLEN
         GBLA  &OFFSET
         LCLA  &LABEL
         LCLC  &LEN
&LEN     SETC  '0'
&LABEL   SETA  &SYSNDX
         DC    AL1(L'#&LABEL)
         DC    X'&UAL'
         AIF   (T'&PARM EQ 'O').NOPARM
         AIF   ('&PARM' NE 'SUBTABLE').KENT003
         DC    AL1(&OFFSET+240)
&OFFSET  SETA  &OFFSET+1
&LEN     SETC  '1'
         AGO   .KENT001
.KENT003 ANOP
         DC    X'&PARM'
&LEN     SETC  '1'
         AGO   .KENT001
.NOPARM  ANOP
         DC    AL1(0)
.KENT001 ANOP
         AIF   (T'&PARMLEN EQ 'O').KENT002
&LEN     SETC  '&PARMLEN'
.KENT002 ANOP
         DC    AL1(&LEN)
         DC    AL2(&KEY)
#&LABEL  DC    C'&KEYWORD'
         MEND
         EJECT
*
*   CREATE A KEYWORD HASH TABLE ENTRY
*
         MACRO
         BEGIN &CHAR
BEGIN&CHAR DS  0X
         MEND
         SPACE 3
*
*   CREATE THE KEYWORD TABLE HASH INDEX
*
         MACRO
         INDEX
KYWDINDX DS    0F                 ALIGN ON FULLWORD BOUNDARY
         DC    A(BEGINA)
         DC    A(BEGINB)
         DC    A(BEGINC)
         DC    A(BEGIND)
         DC    A(BEGINE)
         DC    A(BEGINF)
         DC    A(BEGING)
         DC    A(BEGINH)
         DC    A(BEGINI)
         DC    7A(0)
         DC    A(BEGINJ)
         DC    A(BEGINK)
         DC    A(BEGINL)
         DC    A(BEGINM)
         DC    A(BEGINN)
         DC    A(BEGINO)
         DC    A(BEGINP)
         DC    A(BEGINQ)
         DC    A(BEGINR)
         DC    8A(0)
         DC    A(BEGINS)
         DC    A(BEGINT)
         DC    A(BEGINU)
         DC    A(BEGINV)
         DC    A(BEGINW)
         DC    A(BEGINX)
         DC    A(BEGINY)
         DC    A(BEGINZ)
         MEND
         EJECT
*
*   BEGIN A NEW SUBTABLE
*   SET COUNT OF # OF ENTRIES FOR PREVIOUS SUBTABLE
*   REMEMBER ENTRY POINT
*
         MACRO
         BEGINSUB                 &SUBNAME
         GBLC  &SUBLIST(30)       LIST OF SUBTABLE ENTRIES
         GBLA  &SUBCT(30)         LIST OF SUBTABLE ENTRY COUNTS
         GBLA  &SUBINDX           CURRENT SUBTABLE
         GBLA  &SUBSENT           # ENTRIES IN CURRENT SUBTABLE
         AIF   (&SUBINDX EQ 0).SUB0001 FIRST INVOCATION
&SUBCT(&SUBINDX) SETA &SUBSENT
&SUBSENT SETA  0
.SUB0001 ANOP
&SUBINDX SETA  &SUBINDX+1
&SUBLIST(&SUBINDX) SETC '&SUBNAME'
&SUBNAME DS    0X
         MEND
         SPACE 3
*
*   ADD LAST SUBTABLE DEFINITION TO SUBTABLE LIST
*
         MACRO
         ENDSUB
         GBLA  &SUBCT(30)
         GBLA  &SUBINDX
         GBLA  &SUBSENT
&SUBCT(&SUBINDX) SETA &SUBSENT
         MEND
         EJECT
*
*       GENERATE THE INDEX FOR ALL SUBTABLES
*
         MACRO
&LABEL   SUBINDEX
         GBLC  &SUBLIST(30)
         GBLA  &SUBCT(30)
         GBLA  &SUBINDX
         LCLA  &X
         AIF   (&SUBINDX LE 15).NOERR
         MNOTE 16,'ONLY 16 SUBTABLES PERMITTED'
.NOERR   ANOP
&LABEL   DS    0F
.LOOP    ANOP
         AIF   (&X EQ &SUBINDX).#1
&X       SETA  &X+1
         DC    AL1(&SUBCT(&X)),AL3(&SUBLIST(&X))
         AGO   .LOOP
.#1      ANOP
         MEND
         SPACE 3
*
*   BUILD AN ENTRY IN A SUBTABLE
*
         MACRO
         SENT  &KEY,&VALUE
         GBLA  &SUBSENT
         LCLA  &LABEL
&SUBSENT SETA  &SUBSENT+1
&LABEL   SETA  &SYSNDX
         DC    AL1(L'#&LABEL)
         DC    XL2'&VALUE'
#&LABEL  DC    C'&KEY'
         MEND
         EJECT
*
*   BUILD A TABLE USED TO BUILD A DICB
*
         MACRO
&LABEL   DICBTAB1
&LABEL   DS    0H
         DC    X'000400010008',XL8'00' DDNAME
         DC    X'00050001002C',XL44'00' DSNAME
         DC    X'000600010008',XL8'00' MEMBER NAME
         DC    X'000700010001',X'00' STATUS
         DC    X'000800010001',X'00' DISPOSITION
         DC    X'000900010001',X'00'  CONDITIONAL DISPOSITION
         DC    X'000A00010002',XL2'00' DSORG
         DC    X'000B00010002',XL2'00' LIMIT SPECIFICATION
         DC    X'000C00010001',X'00' ATTRIBUTE SPECIFICATION
         DC    X'000D00010001',X'00' LAST ENTRY SPECIFICATION
         DC    X'000E00010001',X'00' DATA SET TYPE
         MEND
         MACRO
&LABEL   DICBTAB2
&LABEL   DS    0H
         DC    X'005500010008',XL8'00' DDNAME
         DC    X'00560001002C',XL44'00' DSNAME
         DC    X'005700010002',XL2'00' DSORG
         DC    X'005D00010006',XL6'00' VOLSER
         MEND
         EJECT
***********************************************************************
*
*   THIS ROUTINE PROVIDES AN INTERFACE BETWEEN A HIGH LEVEL
*   LANGUAGE SUCH AS FORTRAN, PL/1 OR COBOL, AND THE OPERATING
*   SYSTEM DYNAMIC ALLOCATION ROUTINES.
*
*   INSTALLATION: UNIVERSITY OF MANITOBA COMPUTER CENTRE
*   AUTHOR:       GERRY DUECK
*   DATE WRITTEN: SUMMER 1978
*   MODS:         ADDITION OF ALLOCR VERB.
*                 LOTS OF MUCKING ABOUT TO MAKE THIS PROGRAM
*                 CONSISTENT WITH ITS DOCUMENATION.
*                   ROD ZAZUBEK FEB 1979
*   DOCUMENTATION: COMPLETE DOCUMENTATION ON THE USE OF DYNAM IS
*                  AVAILABLE IN SYS4.DOCUMENT.TEXT(DYNAM)
*   ATTRIBUTES:   RENT
*   HINTS:        PUT THIS PROGRAM SOMEWHERE IN THE LINK LIST.
*
*   PARAMETERS
*      1 - WORK AREA. THE FIRST WORD OF THIS WORK AREA MUST CONTAIN
*          THE LENGTH OF THE AREA. A MINIMUM OF 100 BYTES IS REQUIRED.
*          IF THE LENGTH IS ZERO, AND 'INIT' IS NOT SPECIFIED (SEE
*          PARM 2) THEN A WORK AREA IS OBTAINED AND USED FOR THIS
*          CALL ONLY. THE WORKAREA IS FREED BEFORE RETURNING TO THE
*          CALLER.
*      2 - REQUEST VERB. THIS FIELD IS DELIMITED BY A BLANK.
*          IF THE REQUEST VERB IS 'INIT' THEN ALL THIS CALL
*          DOES IS TO ALLOCATE A WORK AREA FOR SUBSEQUENT
*          CALLS. IF THE VERB IS 'END' THEN THIS WORK AREA
*          IS FREED.
*      3 AND SUBSEQUENT PARAMETERS.
*        - CHARACTER STRINGS CONSISTING OF KEYWORD/VALUE PAIRS
*          SEPARATED BY '=' AND DELIMITED BY ' ', ';'.
*          END OF STRING IS DETERMINED BY ';'
*          END OF LIST IS INDICATED BY THE HIGH ORDER BIT OF
*          THE PARAMETER ADDRESS.
*      AT LEAST 3 PARAMETERS ARE ASSUMED FOR ALL VERBS OTHER THAN
*      'INIT' AND 'END'
*
*   WORK AREA.
*      THE WORK AREA CONTAINS 5 SECTIONS:
*         - WORK AREA CONTROL BLOCK.
*         - DAIRFAIL PARAMETER LIST.
*         - DYNAMIC ALLOCATION REQUEST BLOCK.
*         - TEXT UNITS.
*         - TEXT POINTERS.
*      THE TEXT POINTERS ARE STACKED AT THE BOTTOM OF THE WORK AREA.
*      THE TEXT UNITS ARE HEAPED AFTER THE REQUEST BLOCK.
*
*  ENTRY OPTIONS:
*     IF VERB = 'INIT' THEN
*        GET WORK AREA
*        PLACE ADDRESS IN PARM 1
*        SET FIRST BYTE OF PARM 1 TO X'0F' TO INDICATE
*           THAT THIS IS A GETMAINED AREA
*        RETURN
*     ELSE IF VERB = 'END' THEN
*        FREE THE AREA POINTED TO BY PARM ONE
*        RETURN
*     ELSE IF PARM 1 = 0 THEN
*        GETMAIN AREA
*        PERFORM ALLOCATION
*        FREMAIN AREA
*        RETURN
*     ELSE IF HIGH ORDER BYTE OF PARM 1 IS X'0F' THEN
*        DEREFENCE WORK AREA POINTER
*        PERFORM COMMAND
*     ELSE
*        PERFORM COMMAND USING USER SUPPLIED WORK AREA
*
*   THREE TABLES ARE USED TO BUILD TEXT UNITS FOR SVC99.
*
*   VERB TABLE:
*      THERE ARE ONLY 7 VERBS USED BY SVC99, AND SINCE SOME OF
*      THESE ARE INFORMATION VERBS (IE THEY RETURN INFO) THEY ARE
*      NOT SUPPORTED BY THIS INTERFACE SINCE THERE IS NO TRIVIAL
*      MEANS OF RETURNING INFORMATION TO THE CALLER. THE VERB MUST
*      BE AT LEAST AS LONG AS THE LENGTH SPECIFIED IN ITS CORRESONDING
*      TABLE ENTRY. ACCESS TO THIS TABLE IS BY LINEAR SEARCH AND THE
*      RESULT IS A ONE BYTE FIELD CONTAINING THE VERB CODE. TABLE
*      ENTRIES ARE OF VARIABLE LENGTH WITH THE FIRST BYTE CONTAINING
*      THE LENGTH OF THE VARIABLE PART. THE LENGTH OVERHEAD IS 2.
*
*   KEYWORD TABLE:
*      THE KEYWORD TABLE IS VERY LONG, AND THE ENTRIES ARE VARIABLE
*      LENGTH SO A BINARY SEARCH IS OUT OF THE QUESTION (UNLESS YOU
*      HAD A TAG POINTING TO EACH TABLE ENTRY -- HMMMMM...) AND A
*      LINEAR SEARCH IS TOO SLOW. A PRIMITIVE HASH TABLE IS USED
*      IN WHICH THERE IS AN ENTRY FOR EVERY LETTER AND A POINTER
*      TO THE FIRST KEYWORD TABLE ENTRY WHOSE KEYWORD STARTS WITH
*      THAT LETTER. THE KEYWORD TABLE IS SORTED ALPHABETICALLY
*      AND THE HASH TABLE IS BUILT BY INSERTING A BEGIN MACRO
*      EVERY TIME A CHANGE IN FIRST LETTER OCCURS. WHEN PERFORMING
*      A SEARCH ON THIS TABLE, COMPARISONS ARE MADE TO THE LENGTH
*      OF THE KEYWORD SPECIFIED BY THE USER. WHEN A MATCH IS FOUND,
*      THE LENGTH OF THE KEYWORD IS COMPARED TO THE MINIMUM LENGTH
*      SPECIFIED IN THE TABLE ENTRY. IT MUST BE AT LEAST THIS LONG
*      IN ORDER TO BE UNAMBIGOUS.
*
*   KEYWORD SUBTABLE:
*     SOME OF THE ENTRIES IN THE KEYWORD TABLE REQUIRE MORE INFORMATION
*      AND FOR THESE A POINTER TO A SUBTABLE IS SUPPLIED. THIS POINTER
*      IS AN INDEX INTO ANOTHER TABLE MUCH LIKE THE HASH TABLE AND IS
*      ONLY ONE BYTE, SO ONLY 16 SUBTABLES CAN OCCUR.
*
*   BUILDING A TEXT UNIT:
*      AFTER FINDING THE KEYWORD IN THE KEYWORD TABLE, A VARIETY
*      OF EVENTS CAN OCCUR. THIS IS BECAUSE IBM IN ITS INFINITE
*      WISDOM CANNOT DECIDE ON A SIMPLE STRUCTURE FOR TEXT UNITS.
*      SOME HAVE PARAMETERS THAT ARE PLI TYPE CHAR VAR, SOME ARE
*      VARIABLE LENGTH BINARY VALUES, SOME HAVE NO PARAMETERS, ETC.
*      THE FOLLOWING ALGORITHM IS USED TO BUILD THE TEXT UNIT:
*
*      IF THE USER SUPPLIED A PARM THEN
*         IF A NON ZERO LENGTH IS SPECIFIED IN THE KEYWORD TABLE THEN
*            CREATE A TEXT UNIT WITH A VARIABLE LENGTH BINARY VALUE
*         ELSE
*            CREATE A TEXT UNIT WITH A VARIABLE LENGTH STRING VALUE
*      ELIF THE PARM VALUE SUPPLIED IN THE KEYWORD TABLE IS >= X'F0'
*         CREATE A TEXT UNIT USING THE LENGTH AND VALUE SUPPLIED
*         IN THE SUBTABLE ENTRY CORRESSPONDING TO THE USER SUPPLIED
*         VALUE
*      ELSE
*         CREATE A TEXT UNIT USING A LENGTH OF 1 AND THE VALUE
*         SUPPLIED IN THE KEYWORD TABLE
*
*      THIS ALGORITHM WORKS WELL ENOUGH EXCEPT FOR TWO KLUGES:
*      CONCATENATION AND MULTI-VALUED KEYWORDS SUCH AS RECFM.
*
*      FOR CONCATENATION, THE TEXT UNIT MUST CONTAIN A VARIABLE
*      NUMBER OF VARIABLE LENGTH CHARACTER STRINGS SHOVED TOGETHER.
*      IF A ',' OCCURS AFTER A VALUE,THEN THE NEXT VALUE IS SCANNED AND
*      CONCATENATED TO THE CURRENT ONE. THIS ASSUMES THAT THE TEXT UNIT
*      IS ONE FOR WHICH CONCATENATED STRINGS ARE REQUIRED. IT IS UP TO
*      THE USER TO SUPPLY CORRECT DATA.
*
*      FOR THE SPECIAL KEYWORDS RECFM AND OPTCD, EACH LETTER OF THE
*      VALUE IS INDIVIDUALLY LOOKED UP IN THE SUBTABLE AND THE VALUE
*      THUS OBTAINED IS OR'ED WITH THE VALUE ALREADY IN THE TEXT UNIT.
*      IE RECFM=FBA = X'80' | X'10' | X'04' = X'94'
*
*   RETURN CODES AND DIAGNOSTICS:
*      IF THE RETURN CODE FROM SVC99 IS NOT ZERO THEN A PARAMETER
*      BLOCK FOR DAIRFAIL IS BUILT. DAIRFAIL IS CALLED AND THE
*      DIAGNOSTIC THAT IT GENERATES IS WRITTEN TO THE JOB LOG (WTP).
*
*      THE INTERFACE ALSO HAS ITS OWN RETURNS CODES FOR ERRORS IS
*      DETECTS IN THE USERS PARAMETER LIST. THESE START AT 4 HIGHER
*      THAN THE RETURN CODES FROM SVC99.
*
*      THE RETURN CODE IS RETURNED BOTH IN REGISTER 15 AND IN THE
*      SECOND WORD OF THE WORKAREA, IF IT STILL EXISTS AT THE END
*      OF THE ROUTINE.
*
*   SVC99 RETURN CODES (SEE SPL:JOB MANAGEMENT PAGE 34)
*      00 SUCCESSFULL COMPLETION
*      04 ENVIRONMENT, RESOURCE FAILURE, SYSTEM ROUTINE
*      08 REQUEST DENIED BY INSTALLATION VALIDATION ROUTINE
*      12 INVALID PARAMETER LIST
*
*   INTERFACE RETURN CODES
*      16 INVALID VERB
*      20 INVALID KEYWORD
*      24 WORK AREA OVERFLOW
*      28 VALUE NOT FOUND IN SUBTABLE: INVALID VALUE
*
***********************************************************************
         EJECT
WORKAREA DSECT
WALEN    DS    F                  LENGTH OF WORK AREA
WAS99RC  DS    A                  VALUE OF RETURN CODE FROM SVC 99
WADWORD  DS    D                  DOUBLE WORD FOR PACKS
WABOTTOM DS    A                  END OF WORK AREA
WAKYSTRT DS    A                  START OF KEYWORD
WAVALAD  DS    A                  START OF VALUE
WAVBSTRT DS    A                  START OF VERB
WAS99RB  DS    A                  POINTER TO REQUEST BLOCK
WADFID   DS    XL2                CALLER IDENTIFIER FOR DAIR FAIL
WADFDSCT DS    A                  ADDR OF DSECT FOR CALLING DAIR FAIL
WAZEROES DS    A                  ADDRESS OF IKJEFF02
WALASTTU DS    A                  ADDRESS OF END OF LAST TEXT UNIT
WAALLOCR DS    XL1                IS THIS AN ALLOCR VERB
WATRUE   EQU   X'FF'
WASAVE   DS    18F                SAVE AREA FOR DAIRFAIL
WAEND    EQU   *                  END OF DSECT
         SPACE 1
VERBTABL DSECT
VTVLEN   DS    X                  LENGTH OF VERB
VTVERB   DS    X                  VERB CODE
VTVSTR   DS    0C                 VERB STRING
VTVEND   EQU   *
         SPACE 1
KYWDTABL DSECT
KYWDLEN  DS    X                  KEYWORD LENGTH
KYWDMIN  DS    X                  MINIMUM UNAMBIGOUS LENGTH
KYWDPARM DS    X                  SPECIAL PARAMETER
KYNOPARM EQU   X'00'              FLAGS NO PARM
KYWDPMLN DS    X                  LENGTH OF PARM IF FIXED LENGTH
KYWDKEY  DS    2X                 KEYWORD KEY
KYWDSTRG DS    0C                 KEYWORD STRING
         ORG   KYWDPARM
KYWDSUBT DS    X                  FLAG A SUBTABLE FOR THIS ENTRY
KYWDSUBF EQU   X'F0'              FLAGS A SUBTABLE
         ORG
         SPACE 1
VALUTABL DSECT
VALULEN  DS    X                  LENGTH OF STRING IN THIS ENTRY
VALUPARM DS    2X                 PARAMETER VALUE FOR TEXT UNIT
VALUSTRG DS    0C                 ENTRY STRING
         SPACE 1
CHAR     DSECT
CH       DS    C
         EJECT
DICB1    DSECT
DIDDN    DS    XL14               DDNAME
DIDSN    DS    XL50               DSNAME
DIMEM    DS    XL14               MEMBER NAME
DISTAT   DS    XL7                STATUS
DIDISP   DS    XL7                NORMAL DISPOSITION
DICDISP  DS    XL7                CONDITIONAL DISPOSITION
DIDSORG  DS    XL8                DSORG
DILIMIT  DS    XL8                NUMBER RESOURCES TO BE FREED
DIATTR   DS    XL7                ATTRIBUTE SPECIFICATION
DILAST   DS    XL7                LAST ENTRY SPECIFICATION
DITYPE   DS    XL7                DATA SET TYPE (DUMMY,TERMINAL,OTHER)
DILEN1   EQU   *-DICB1
DICB2    DSECT
DIDDN2   DS    XL14
DIDSN2   DS    XL50
DIDSORG2 DS    XL8
DIVOL2   DS    XL12
DILEN2   EQU   *-DICB2
         EJECT
         IEFZB4D0
         EJECT
         IEFZB4D2
         EJECT
         IKJEFFDF DFDSECT=YES
         EJECT
@WA      EQU   11                 BASE ADDRESS FOR WORK AREA
@RB      EQU   10                 BASE ADDRESS FOR REQUEST BLOCK
@TP      EQU   9                  BASE ADDRESS FOR TEXT POINTERS
@TU      EQU   8                  TEXT UNIT
@CH      EQU   7                  POINTER INTO PARM STRING
@VTE     EQU   6                  VERB TABLE ENTRY
@KTE     EQU   6                  KEYWORD TABLE ENTRY
LENGTH   EQU   5
@DF      EQU   5                  BASE ADDRESS FOR DFDSECT
         SPACE 1
DYNAM    CSECT
         USING DYNAM,12           ADDRESSIBILITY FOR CSECT
         SAVE  (14,12),,DYNAM-MARCH-22-1979
         LR    R12,R15            GET BASE FOR CSECT
         SPACE 1
         USING WORKAREA,@WA       ADDRESSIBILITY FOR WORK AREA
         USING S99RB,@RB          ADDRESSIBILITY FOR REQUEST BLOCK
         USING S99TUPL,@TP        ADDRESSIBILITY FOR TEXT POINTERS
         USING S99TUNIT,@TU       ADDRESSIBILITY FOR TEXT UNITS
         USING CHAR,@CH
         USING VERBTABL,@VTE      ADDRESSIBILITY FOR VERB TABLE
         USING DFDSECTD,@DF       ADDRESSIBILITY FOR DAIRFAIL DSECT
         SPACE 1
*
**   DECODE ENTRY OPTIONS
*
         L     R2,4(R1)           ADDRESS OF VERB
         CLC   0(4,R2),=C'INIT'
         BE    INITCODE
         CLC   0(3,R2),=C'END'
         BE    ENDCODE
         L     @WA,0(R1)          ADDRESS OF WORK AREA
         OC    WALEN,WALEN        IS IT 0?
         BNZ   WORKGOT            NOPE
         LR    R2,R1              SAVE R1
         GETMAIN R,LV=2048
         L     R3,0(R2)           ADDR OF PARM 1
         ST    R1,0(R3)           SAVE ADDRESS
         MVI   0(R3),X'0E'        MARK TO BE FREED AFTER ALLOCATE
         L     @WA,0(R3)          GET ADDRESS
         LA    R3,2048            LENGTH OF WORKAREA
         ST    R3,WALEN           SET LENGTH
         LR    R1,R2              RESTORE R1
         B     WORKSET
WORKGOT  CLI   WALEN,X'0F'        IS THIS THE ADDRESS OF A WORK AREA?
         BNE   WORKSET            NOPE, USER SUPPLIED AREA
         L     @WA,WALEN          YES, DEREFENCE IT
WORKSET  DS    0H
*
**   SET UP WORK AREA
*
         L     @TP,WALEN          GET LENGTH
         LR    R2,@WA             ADDRESS OF WORK AREA
         LR    R3,@TP             LENGTH
         LR    R4,R2              FROM ADDR FOR ZAP
         XR    R5,R5
         MVCL  R2,R4              ZAP WORK AREA
         LR    R15,R13            ADDR OF CALLERS SAVE
         LA    R13,WASAVE
         ST    R13,8(R15)         FORE LINK
         ST    R15,4(R13)         BACK LINK
         ST    @TP,WALEN
         AR    @TP,@WA            + ADDRESS = END OF WORK AREA
         ST    @TP,WABOTTOM
         LA    @RB,WAEND          BEGINNING OF REQUEST BLOCK
         ST    @RB,WADFDSCT       ADDRESS OF DFDSECTD
         LA    @RB,DFLEN(@RB)     POINT PAST DFDSECTD
         ST    @RB,WAS99RB        ADDRESS OF REQUEST BLOCK
         LA    @TU,S99RBEND       BEGINNING OF TEXT UNIT HEAP
         MVI   S99RBLN,X'14'      LENGTH OF RB
*
**  EXAMINE THE VERB PARAMETER
*
         L     @CH,4(R1)          GET SECOND PARM
         LA    @VTE,VERBTAB       FIRST ENTRY IN VERB TABLE
         SR    R2,R2
VERBLOOP DS    0H
         C     @VTE,VERBTEND      END OF TABLE?
         BE    FAILVERB           YES, VERB NOT FOUND
         IC    R2,VTVLEN          GET LENGTH OF VERB
         BCTR  R2,0               LESS 1
         EX    R2,VERBCLC         MATCH?
         BE    VERBPOOL           YES
         LA    @VTE,VTVSTR+1(R2)  GET NEXT ENTRY
         B     VERBLOOP
VERBCLC  CLC   VTVSTR,CH
VERBPOOL DS    0H
         CLC   CH(6),=C'ALLOCR'   VERB = ALLOCR?
         BNE   VERBEND
         MVI   WAALLOCR,WATRUE    SET ALLOCR FLAG
VERBEND  DS    0H
         MVC   S99VERB,VTVERB     MOVE IN VERB CODE
*
*  SCAN OFF KEYWORD PARAMETERS.
*
         CLI   4(R1),X'80'        END OF PARM LIST?
         BE    FAILKEY
         LA    R1,8(R1)           POINT TO THIRD PARAMETER
         CLI   S99VERB,S99VRBIN   VERB = INFO?
         BE    RETINFO            YUP
         CLI   WAALLOCR,WATRUE    VERB = ALLOCR?
         BE    RETALLOC
         B     PARMLOOP           NOPE, START LOOP
*
**   SET UP THE TEXT UNITS FOR DYNAMIC INFORMATION RETRIEVAL
**   THIS IS FOR THE INFO AND ALLOCR VERBS
*
RETINFO  DS    0H
         LA    R2,DILEN1(@TU)     POINT TO END OF DICB
         MVC   0(DILEN1,@TU),DICBS1 MOVE IN MODEL TEXT UNITS
         B     RETLOOP
RETALLOC DS    0H
         LA    R2,DILEN2(@TU)     POINT TO END OF DICB2
         MVC   0(DILEN2,@TU),DICBS2 MOVE IN MODEL TEXT UNITS
RETLOOP  DS    0H
         S     @TP,=F'4'          POINT TO TUPTR ENTRY
         ST    @TU,S99TUPTR       SET POINTER
         LH    R3,S99TULNG        GET LENGTH OF PARM FIELD
         LA    @TU,S99TUPAR(R3)   POINT TO NEXT TEXT UNIT
         CR    @TU,R2             END OF DICB?
         BNE   RETLOOP
         CLI   0(R1),X'80'        LAST PARM?
         BE    PARMPOOL           YES
         LA    R1,4(R1)           POINT TO NEXT PARM
PARMLOOP DS    0H
         L     @CH,0(R1)          GET ADDRESS OF STRING
         LA    @CH,0(@CH)         ZERO TOP BYTE
STRINGLP DS    0H                 START OF STRING LOOP
STRING01 DS    0H
         CLI   CH,C';'            END OF STRING
         BE    STRINGPL           YES, GOTO END OF STRING LOOP
         CLI   CH,C','            COMMA?
         BE    STRING02
         CLI   CH,C' '            BLANK?
         BNE   STRING03
STRING02 LA    @CH,1(@CH)         GET NEXT CHAR
         B     STRING01
STRING03 DS    0H
         LA    R2,15             LENGTH OF LONGEST KEYWORD
         ST    @CH,WAKYSTRT       SAVE START ADDRESS
KEYSLOOP DS    0H
         CLI   CH,C'='            END OF KEYWORD?
         BE    KEYSPOOL
         CLI   CH,C','
         BE    KEYSPOOL
         CLI   CH,C';'
         BE    KEYSPOOL
         CLI   CH,C' '
         BE    KEYSPOOL
         LA    @CH,1(@CH)         GET NEXT CHAR
         BCT   R2,KEYSLOOP
         B     FAILKEY            KEY WORD FAILED
         USING KYWDTABL,@KTE      ADDRESSIBILITY FOR KEY WORD TABLE
KEYSPOOL DS    0H
*
** KEYWORD - SCAN OFF AND LOOK UP A KEYWORD
*
KEYWORD  DS    0H
         L     R3,WAKYSTRT        GET FIRST CHR IN WORD
         CLI   0(R3),C'A'
         BL    FAILKEY            INVALID KEYWORD
         CLI   0(R3),C'Z'
         BH    FAILKEY            INVALID KEYWORD
         IC    R2,0(R3) GET FIRST CHAR
         S     R2,=F'193'         SUBTRACT OFF VALUE OF 'A'
         SLL   R2,2               TIMES 4
         L     @KTE,KYWDINDX(R2)  GET ADDRESS OF FIRST ENTRY WITH
*                                 SAME FIRST LETTER
         LR    LENGTH,@CH
         S     LENGTH,WAKYSTRT    LENGTH OF KEYWORD
         BCT   LENGTH,KEYLOOP     LESS ONE FOR EXECUTE
         B     FAILKEY
KEYLOOP  DS    0H
         CLC   KYWDSTRG(1),0(R3)  CHECK FIRST CHAR
         BNE   FAILKEY            NO LONGER IN CORRECT PART OF TABLE
         EX    LENGTH,KEYCLC      COMPARE KEYWORD TO ENTRY
         BE    KEYPOOL
         IC    R2,KYWDLEN         GET LENGTH OF ENTRY
         LA    @KTE,KYWDSTRG(R2)  GET NEXT ENTRY
         B     KEYLOOP
KEYCLC   CLC   KYWDSTRG,0(R3)
KEYPOOL  DS    0H
         IC    R2,KYWDMIN         GET MIMINUM UNAMBIGOUS LENGTH
         LA    LENGTH,1(LENGTH)   LENGTH :=+ 1
         CR    LENGTH,R2          CHECK LENGTH
         BL    FAILKEY            KEY WORD TOO SHORT
         MVC   S99TUKEY,KYWDKEY
         LA    R4,S99TULNG        ADDRESS OF LENGTH FIELD
         ST    R4,WALASTTU        SAVE IT
         CLI   CH,C'='            DID THE USER SUPPLY A PARM
         BNE   SPECPARM           IF NOT, THEN PARM IS IN TABLE
VALUNEXT DS    0H
         LA    @CH,1(@CH)         POINT PAST '='
         ST    @CH,WAVALAD
VALULOOP DS    0H
         CLI   CH,C' '            BLANK?
         BE    VALUPOOL           YES, END OF VALUE
         CLI   CH,C','            COMMA?
         BE    VALUPOOL           YES, END OF VALUE
         CLI   CH,C';'            SEMI?
         BE    VALUPOOL           YES, END OF VALUE
         LA    @CH,1(@CH)         GET NEXT VALUE
         B     VALULOOP
VALUPOOL DS    0H
         LR    LENGTH,@CH
         S     LENGTH,WAVALAD     LENGTH OF VALUE
         L     R4,WALASTTU
         STH   LENGTH,0(R4)       SAVE LENGTH
         BCTR  LENGTH,0
         BM    TEXTNUM            DONT MOVE VALUE IF NULL
         L     R3,WAVALAD         GET START OF VALUE
         CLI   KYWDSUBT,KYWDSUBF  IS THERE A SUBTABLE?
         BNL   SUBTLKUP           YES
         CLI   KYWDPMLN,KYNOPARM  IS THERE A LENGTH SUPPLIED?
         BNE   CONVALUE
         L     R4,WALASTTU
         LA    R4,2(R4)           POINT TO PARAMETER FIELD
         EX    LENGTH,VALUEMVC
         B     TEXTNUM
VALUEMVC MVC   R0(0,R4),0(R3)
SUBTLKUP DS    0H
@SUBT    EQU   4
*
**   R3 POINTS TO VALUE
**   R2 # OF ENTRIES IN SUBTABLE
**   R15 USED FOR IC,STC
*
         XR    R15,R15
         XR    R2,R2
         IC    R2,KYWDSUBT        GET SUBTABLE INDEX POINTER
         N     R2,=F'15'          GET RID OF FLAG BITS
         SLL   R2,2               TIMES 4
         L     @SUBT,VALUINDX(R2) ADDR OF SUBTABLE
         USING VALUTABL,@SUBT     ADDRESSIBILITY FOR SUBTABLE ENTRIES
         IC    R2,VALUINDX(2)     # ENTRIES IN SUBTABLE
         CLC   KYWDSTRG(5),=C'RECFM' SPECIAL CASE FOR RECFM
         BE    SPECCASE
         CLC   KYWDSTRG(5),=C'OPTCD' AND FOR OPTION CODE
         BE    SPECCASE
SUBTLOOP DS    0H
         EX    LENGTH,SUBTCLC     COMPARE ENTRIES
         BE    SUBTPOOL           ENTRY FOUND
         IC    R15,VALULEN        GET LENGTH OF THIS ENTRY
         LA    @SUBT,VALUSTRG(R15) GET NEXT ENTRY
         BCT   R2,SUBTLOOP        REPEAT IF NOT AT END OF TABLE
         B     FAILVALU
SUBTPOOL DS    0H
         LA    LENGTH,1(LENGTH)   LENGTH +:= 1
         CR    LENGTH,R15         CORRECT VALUE LENGTH
         BNE   FAILVALU
         IC    R2,KYWDPMLN        GET PARM LENGTH
         STC   R2,S99TULNG+1      SAVE IT IN TEXT UNIT
         IC    R2,CONVMASK(R2)    GET STCM MASK
         ICM   R3,3,VALUPARM      GET VALUE
         EX    R2,CONVSTCM        STCM R3,CONVMASK(R2),S99TUPAR
         B     TEXTNUM
SUBTCLC  CLC   VALUSTRG,0(R3)
*
**   THIS CODE HANDLES THE SPECIAL CASE FOR KEYWORDS THAT CAN HAVE
**   MORE THAN ONE VALUE SPECIFIED. EG 'RECFM=FBA'.
**   THE INDIVIDUAL VALUES ARE OR'ED TOGETHER
*
SPECCASE DS    0H
         LR    R0,@SUBT           SAVE ADDR OF START OF SUBTABLE
         LR    R15,R2             SAVE # SUBTABLE ENTRIES
         L     @CH,WAVALAD        POINT TO FIRST VALUE
         LA    LENGTH,1(LENGTH)   CORRECT LENGTH
SPECLOOP DS    0H
         CLC   CH,VALUSTRG        COMPARE CHAR WITH VALUE STRING
         BE    SPECPOOL           FOUND
         LA    @SUBT,VALUSTRG+1   NEXT ENTRY
         BCT   R2,SPECLOOP        REPEAT WITH NEW ENTRY
         B     FAILVALU           NO MORE ENTRIES LEFT
SPECPOOL DS    0H
         OC    S99TUPAR(1),VALUPARM+1
         LA    @CH,CH+1           NEXT CHAR IN USER SUPPLIED VALUE
         LR    @SUBT,R0           RESTORE SUBTABLE ADDR
         LR    R2,R15             RESTORE SUBTABLE ENTRY COUNT
         BCT   LENGTH,SPECLOOP
         MVC   S99TULNG+1(1),KYWDPMLN MOVE IN LENGTH
         B     TEXTNUM            FINISHED
*
**   SUPPLY THE PARAMETER VALUE FOR THE TEXT UNIT FROM THE KEYWRD TABLE
*
SPECPARM DS    0H
         CLI   KYWDPARM,KYNOPARM  IS THERE A SPECIAL PARM?
         BE    TEXTFINI
         MVC   S99TULNG+1(1),KYWDPMLN MOVE IN LENGTH
         MVC   S99TUPAR(1),KYWDPARM MOVE IN SPECIAL PARM
         B     TEXTNUM
*
**   THE USER SUPPLIED VALUE IS TO BE CONVERTED TO BINARY AND RIGHT
**   JUSTIFIED IN A FIELD WHOSE LENGTH IS SUPPLIED IN THE KEYWORD TABLE
*
CONVALUE DS    0H
         LA    R2,WADWORD-1+L'WADWORD POINT 1 BYTE BEFOR END OF WADWORD
         SR    R2,LENGTH          POINT TO CORRECT ADDR FOR MVC
         XC    WADWORD,WADWORD
         EX    LENGTH,CONVMVC     MOVE VALUE
         PACK  WADWORD,WADWORD    CONVERT TO PACKED DECIMAL
         CVB   R3,WADWORD         CONVERT TO BINARY
         MVC   S99TULNG+1(1),KYWDPMLN MOVE IN KYWDPARM
         XR    R2,R2
         IC    R2,S99TULNG+1      GET SPECIAL PARM
         IC    R2,CONVMASK(R2)    SET BYTE 2 FOR STCM INST
         EX    R2,CONVSTCM        STCM R3,MASK(2),S99TUPAR
         B     TEXTNUM
CONVMVC  MVC   0(0,R2),0(R3)
CONVSTCM STCM  0,0,S99TUPAR
CONVMASK DC    X'303133373F'
*
**   SET THE NUMBER FIELD IN THE TEXTUNIT
*
TEXTNUM  DS    0H
         LH    R2,S99TUNUM        NUMBER OF KEYS IN THIS TEXT UNIT
         LA    R2,1(R2)           + ONE
         STH   R2,S99TUNUM        SAVE IT
         CLI   CH,C','            IS THERE ANOTHER PARAMETER?
         BNE   TEXTFINI           NO
         L     R4,WALASTTU        ADDRESF OF LENGTH FIELD FOR LAST TU
         AH    R4,0(R4)           ADD LENGTH OF PARAMETER
         LA    R4,2(R4)           + 2 FOR LENGTH FIELD
         ST    R4,WALASTTU        = ADDRESS OF NEXT LENGTH FIELD
         B     VALUNEXT           PROCESS NEXT VALUE
*
**   COMLETE THE TEXT UNIT.
**   CHECK FOR WAORK AREA OVERFLOW.
**   ADD A NEW POINTER THE THE TEXTPOINTERS
*
TEXTFINI DS    0H
         L     R2,WALASTTU        ADDRESS OF LENGTH FIELD
         AH    R2,0(2)            + LENGTH OF PARM
         LA    R2,2(2)            + TWO FOR LENGTH FIELD
         S     @TP,=F'4'          POINT TO NEW TEXT POINTER
         CR    R2,@TP             CHECK FOR OVERFLOW
         BH    FAILOVFL           WORKAREA OVERFLOW
         ST    @TU,S99TUPTR       SAVE ADDR OF TU
         LR    @TU,R2             POINT TO NEW TEXT UNIT
         B     STRINGLP
STRINGPL DS    0H                 END OF STRING LOOP
         CLI   0(R1),X'80'        LAST PARM?
         BE    PARMPOOL           YES
         LA    R1,4(R1)           POINT TO NEXT PARM
         B     PARMLOOP
PARMPOOL DS    0H
         EJECT
         ST    @TP,S99TXTPP       SET TEXT POINTER FIELD IN RB
         L     @TP,WABOTTOM       GET END OF WORKAREA
         S     @TP,=F'4'          POINT TO LAST PARM
         MVI   S99TUPTR,S99TUPLN  SET LAST TP FLAG
         LA    R1,WAS99RB         GET ADDR OF REQUEST BLOCK
         OI    0(R1),S99RBPND     TURN ON FIRST BIT OF S99RBP
SVC99    DYNALLOC                 CALL DYNAMIC ALLOCATION RTN
         LTR   R15,R15
         BNE   DAIRFAIL
         CLI   S99VERB,S99VRBIN   VERB = INFO?
         BE    INFODECO           YES, DECODE IT
         CLI   WAALLOCR,WATRUE    VERB = ALLOCR?
         BE    INFODECO
         B     RETURN
DAIRFAIL DS    0H
         L     @DF,WADFDSCT       ADDRESS OF DFDSECT
         ST    @RB,DFS99RBP       ADDRESS OF SVC99 REQUEST BLOCK
         ST    R15,WAS99RC        SVC 99 RETURN CODE
         LA    R2,WAS99RC         GET ADDR OF IT
         ST    R2,DFRCP
         LA    R2,WADFID          ADDR OF DIFD
         ST    R2,DFIDP
         MVI   WADFID,DFWTP       SPECIFY WRITE TO PROGRAMMER
         MVI   WADFID+1,DFSVC99   FROM SVC 99
         LA    R2,WAZEROES
         ST    R2,DFJEFF02        ADDR OF ADDR OF IKJEFF02 (NOT KNOWN)
         LR    R1,@DF
         LINK  EP=IKJEFF18        CALL DAIRFAIL
         L     R15,WAS99RC        RESTORE RETURN CODE
         B     RETURN
         EJECT
*
**   INITIALIZATION CODE
*
INITCODE DS    0H
         LR    R2,R1
         GETMAIN R,LV=2048        GETMAIN AREA
         L     R3,0(R2)           ADDRESS OF PARM ONE
         ST    R1,0(R3)           SAVE ADDRESS
         MVI   0(R3),X'0F'        INDICATE GETMAINED AREA
         L     R3,0(R3)           POINT TO AREA
         LA    R4,2048            LENGTH
         ST    R4,0(R3)           SET LENGTH
         XR    R15,R15            SET RC
         XC    4(4,R3),4(R3)      ZERO WAS99RC
         LM    R14,R12,12(R13)    RESTORE REGS
         XR    R15,R15            SET RETURN CODE
         XR    R0,R0
         BR    R14                RETURN
ENDCODE  DS    0H
         LR    R2,R1              SAVE REG 1
         L     R3,0(R1)           ADDRESS OF PARM 1
         L     R3,0(R3)           ADDRESS TO BE FREED
         L     R4,0(R3)           LENGTH TO BE FREED
         FREEMAIN R,A=(3),LV=(4)
         LM    R14,R12,12(R13)    RESTORE REGS
         XR    R15,R15            SET RETURN CODE
         XR    R0,R0
         BR    R14                RETURN
         EJECT
*
**   DECODE INFO RETURNED BY SVC99
*
INFODECO DS    0H
         L     R1,4(R13)
         L     R1,24(R1)          RECOVER R1
         L     R1,8(R1)           POINT TO THIRD PARM
         L     @TU,S99TUPTR       POINT TO FIRST TEXT UNIT
         CLI   WAALLOCR,WATRUE    VERB = ALLOCR?
         BE    INFO1
         LA    R0,DILEN1(@TU)     POINT TO END OF DICB
         LA    R4,DICBS1          ADDRESS OF DICB MODEL
         B     INFO2
INFO1    DS    0H
         LA    R0,DILEN2(@TU)     POINT TO END OF DICB
         LA    R4,DICBS2          ADDRESS OF DICB MODEL
INFO2    DS    0H
INFOLOOP DS    0H
         LH    R3,S99TULNG        GET LENGTH
         BCTR  R3,0               LESS ONE FOR EXECUTE
         LTR   R3,R3
         BL    INFOLEN
         EX    R3,INFOMVC
INFOLEN  LH    R3,S99TULNG-S99TUNIT(,R4) GET MAX PARM LENGTH
         AR    R1,R3              POINT TO NEXT INFO PARM
         LA    @TU,S99TUPAR(R3)   NEXT TEXT UNIT
         LA    R4,S99TUPAR-S99TUNIT(R3,4) NEXT TEXT UNIT IN MODEL
         CR    @TU,R0             END OF INFO TU'S?
         BNE   INFOLOOP
         XR    R15,R15            SET RETURN CODE
         B     RETURN
INFOMVC  MVC   0(0,R1),S99TUPAR
         SPACE 3
FAILVERB DS    0H
         LA    R15,16
         B     RETURN
FAILKEY  DS    0H
         LA    R15,20
         B     RETURN
FAILVALU DS    0H
         LA    R15,28
         B     RETURN
FAILOVFL DS    0H
         LA    R15,24
         B     RETURN
         EJECT
RETURN   DS    0H
         ST    R15,WAS99RC        RETURN CODE
         L     R13,4(R13)         RESTORE SAVEAREA ADDR
         ST    R15,16(R13)        SET RETURN CODE
         L     R1,24(R13)         RESTORE R1
         L     R1,0(R1)           ADDR OF PARM 1
         CLI   0(R1),X'0E'        IS AREA TO BE FREED?
         BNE   RETURN01
         LR    R2,R1              SAVE R1
         L     R1,0(R1)           ADDR TO BE FREED
         FREEMAIN R,LV=2048,A=(1)
         LR    R1,R2              RESTORE R1
         XC    0(4,R1),0(R1)      SET PARM 1 TO ZEROES
RETURN01 DS    0H
         LM    R14,R12,12(R13)    RESTORE REGS
         LR    R0,R15
         BR    R14                RETURN
         EJECT
         PRINT NOGEN
         INDEX
VERBTAB  DS    0H
         VENT  ALLOC,S99VRBAL
         VENT  ALLOCR,S99VRBAL
         VENT  UNALLOC,S99VRBUN
         VENT  CONCAT,S99VRBCC
         VENT  UNCONCAT,S99VRBDC
         VENT  REMOVE,S99VRBRI
         VENT  DDALLOC,S99VRBDN
         VENT  INFO,S99VRBIN
VERBMARK DS    0X
VERBTEND DC    A(VERBMARK)
         SPACE 1
KYWDTAB  DS    0H
         BEGIN A
         KENT  ABE,3,DALEROPT,20
         KENT  ACC,3,DALEROPT,80
         KENT  AL,2,DALLABEL,40
         KENT  ALIGNMENT,3,DALFCBAV,08
         KENT  ALX,3,DALSPFRM,02
         KENT  AUL,3,DALLABEL,48
         BEGIN B
         KENT  BLKSIZE,3,DALBLKSZ,,2
         KENT  BLOCK,3,DALBLKLN,,3
         KENT  BLP,3,DALLABEL,10
         KENT  BUFALN,4,DALBFALN,SUBTABLE
         KENT  BUFIN,4,DALBUFIN,,2
         KENT  BUFL,4,DALBUFL,,2
         KENT  BUFMAX,4,DALBUFMX,,1
         KENT  BUFNO,4,DALBUFNO,,1
         KENT  BUFOFF,5,DALBUFOF,,1
         KENT  BUFOUT,5,DALBUFOU,,1
         KENT  BUFRQ,4,DALBUFRQ,,1
         KENT  BUFSZ,4,DALBUFSZ,,2
         KENT  BUFTEK,4,DALBFTEK,SUBTABLE
         BEGIN C
         KENT  CATLG,2,DALNDISP,02
         KENT  CCATLG,2,DALCDISP,02
         KENT  CDELETE,2,DALCDISP,04
         KENT  CHARSET,2,DALUVRFY
         KENT  CKEEP,2,DALCDISP,08
         KENT  CLOSE,2,DALCLOSE
         KENT  CODE,3,DALCODE,SUBTABLE
         KENT  CONTIG,3,DALSPFRM,08
         KENT  CONVERT,4,DALCNVRT
         KENT  COPIES,3,DALCOPYS,,1
         KENT  CUNCATLG,2,DALCDISP,01
         KENT  CYL,2,DALCYL
         BEGIN D
         KENT  DCBDD,5,DALDCBDD
         KENT  DCBDS,5,DALDCBDS
         KENT  DDNAME,2,DALDDNAM
         KENT  DELETE,2,DALNDISP,04
         KENT  DIRECTORY,2,DALDIR,,3
         KENT  DSNAME,3,DALDSNAM
         KENT  DSORG,3,DALDSORG,SUBTABLE,2
         KENT  DSSEQ,3,DALDSSEQ,,2
         KENT  DUMMY,2,DALDUMMY
         KENT  D1600,5,DALDEN,C3
         KENT  D6250,5,DALDEN,D3
         KENT  D800,4,DALDEN,83
         BEGIN E
         KENT  EXPIRY,1,DALEXPDT
         BEGIN F
         KENT  F,1,DALRECFM,80
         KENT  FA,2,DALRECFM,84
         KENT  FAS,3,DALRECFM,8C
         KENT  FB,2,DALRECFM,C0
         KENT  FBA,3,DALRECFM,C4
         KENT  FBAS,4,DALRECFM,9C
         KENT  FBM,3,DALRECFM,C2
         KENT  FBMS,4,DALRECFM,8A
         KENT  FBS,3,DALRECFM,98
         KENT  FM,2,DALRECFM,82
         KENT  FMS,3,DALRECFM,8A
         KENT  FOLDMODE,3,DALUFOLD
         KENT  FORMS,3,DALFCBIM
         KENT  FS,2,DALRECFM,88
         BEGIN G
         BEGIN H
         KENT  HOLD,1,DALSHOLD
         BEGIN I
         KENT  INPUT,1,DALINOUT,40
         BEGIN J
         BEGIN K
         KENT  KEEP,3,DALNDISP,08
         KENT  KEYLEN,3,DALKYLEN,,1
         BEGIN L
         KENT  LIMCT,2,DALLIMCT,,3
         KENT  LRECL,2,DALLRECL,,2
         KENT  LTM,2,DALLABEL,21
         BEGIN M
         KENT  MEMBER,2,DALMEMBR
         KENT  MOD,3,DALSTATS,02
         KENT  MODE,4,DALMODE,SUBTABLE
         KENT  MSVGP,2,DALMSVGP
         KENT  MXIG,2,DALSPFRM,04
         BEGIN N
         KENT  NCP,2,DALNCP,,1
         KENT  NEW,3,DALSTATS,04
         KENT  NEWCLASS,4,DUNOVCLS
         KENT  NEWHOLD,4,DUNOVSHQ
         KENT  NEWNOHOLD,4,DUNOVSNH
         KENT  NEWREMOTE,4,DUNOVSUS
         KENT  NL,2,DALLABEL,01
         KENT  NSL,3,DALLABEL,04
         BEGIN O
         KENT  OLD,3,DALSTATS,01
         KENT  OPTCD,2,DALOPTCD,SUBTABLE
         KENT  OUTLIM,4,DALOUTLM,,3
         KENT  OUTPUT,3,DALINOUT,80
         BEGIN P
         KENT  PARALLEL,3,DALPARAL
         KENT  PASSREAD,5,DALPASPR,10
         KENT  PASSWORD,6,DALPASSW
         KENT  PASSWRITE,6,DALPASPR,30
         KENT  PERMANENT,2,DALPERMA
         KENT  PERMCONCAT,5,DCCPERMC
         KENT  PRIMARY,4,DALPRIME,,3
         KENT  PRIVATE,4,DALPRIVT
         KENT  PRTSP,3,DALPRTSP,SUBTABLE
         BEGIN Q
         KENT  QNAME,1,DALQNAME
         BEGIN R
         KENT  RECFM,3,DALRECFM,SUBTABLE
         KENT  RELNO,3,DINRELNO,,2
         KENT  REMOTE,3,DALSUSER
         KENT  REMOVE,5,DUNREMOV
         KENT  RETENTION,3,DALRETPD,,2
         KENT  RLSE,2,DALRLSE
         KENT  ROUND,2,DALROUND
         BEGIN S
         KENT  SECONDARY,3,DALSECND,,3
         KENT  SHR,2,DALSTATS,08
         KENT  SKP,2,DALEROPT,40
         KENT  SL,2,DALLABEL,02
         KENT  SUL,3,DALLABEL,08
         KENT  SYSOFORM,5,DALSFMNO
         KENT  SYSOPROG,5,DALSPGNM
         KENT  SYSOUT,5,DALSYSOU
         BEGIN T
         KENT  TERMFILE,2,DALTERM
         KENT  TRK,3,DALTRK
         KENT  TRTCH,3,DALTRTCH,SUBTABLE
         BEGIN U
         KENT  U,1,DALRECFM,C0
         KENT  UCS,2,DALUCS
         KENT  UNALLOC,3,DUNUNALC
         KENT  UNCATLG,3,DALNDISP,01
         KENT  UNICOUNT,4,DALUNCNT,,1
         KENT  UNIT,4,DALUNIT
         BEGIN V
         KENT  V,1,DALRECFM,40
         KENT  VA,2,DALRECFM,44
         KENT  VAS,3,DALRECFM,4C
         KENT  VB,2,DALRECFM,50
         KENT  VBA,3,DALRECFM,64
         KENT  VBAS,4,DALRECFM,5C
         KENT  VBM,3,DALRECFM,62
         KENT  VBMS,4,DALRECFM,5A
         KENT  VBS,3,DALRECFM,58
         KENT  VERIFY,2,DALFCBAV,04
         KENT  VM,2,DALRECFM,42
         KENT  VMS,3,DALRECFM,4A
         KENT  VOLUME,3,DALVLSER
         KENT  VOLCOUNT,4,DALVLCNT,,1
         KENT  VOLREF,4,DALVLRDS
         KENT  VOLSEQ,4,DALVLSEQ,,2
         KENT  VS,2,DALRECFM,48
         BEGIN W
         BEGIN X
         BEGIN Y
         BEGIN Z
KYWDMARK DS    0X
KYWDTEND DC    A(KYWDMARK)
         BEGINSUB BFALN           OFFSET 00
         SENT  F,01
         SENT  D,02
         BEGINSUB BFTEK           OFFSET 04
         SENT  D,08
         SENT  E,10
         SENT  R,20
         SENT  S,40
         SENT  A,60
         BEGINSUB CODE
         SENT  T,02
         SENT  A,04
         SENT  C,08
         SENT  B,10
         SENT  F,20
         SENT  I,40
         SENT  N,80
         BEGINSUB DSORG
         SENT  TQ,0020
         SENT  TX,0040
         SENT  GS,0080
         SENT  PO,0200
         SENT  MQ,0400
         SENT  CQ,0800
         SENT  CX,1000
         SENT  DA,2000
         SENT  PS,4000
         SENT  POU,0300
         SENT  DAU,2100
         SENT  PSU,4100
         SENT  TCAM,0004
         SENT  VSAM,0008
         BEGINSUB MODE
         SENT  E,40
         SENT  C,80
         SENT  ER,50
         SENT  EO,60
         SENT  CR,90
         SENT  CO,A0
         BEGINSUB OPTCD           OFFSET 04
         SENT  R,01
         SENT  T,02
         SENT  Z,04
         SENT  A,08
         SENT  Q,08
         SENT  F,10
         SENT  H,10
         SENT  O,10
         SENT  C,20
         SENT  E,20
         SENT  B,40
         SENT  U,40
         SENT  W,80
         BEGINSUB PRTSP
         SENT  0,01
         SENT  1,09
         SENT  2,11
         SENT  3,19
         BEGINSUB RECFM
         SENT  M,02
         SENT  R,02
         SENT  A,04
         SENT  G,04
         SENT  S,08
         SENT  B,10
         SENT  D,20
         SENT  T,20
         SENT  V,40
         SENT  F,80
         SENT  U,C0
         BEGINSUB TRTCH
         SENT  C,13
         SENT  E,23
         SENT  T,3B
         SENT  ET,2B
         ENDSUB
VALUINDX SUBINDEX
DICBS1   DICBTAB1
DICBS2   DICBTAB2
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         END
