//ASTEST02 JOB (SYS),'ASSIST IVP TEST #2',CLASS=S,MSGCLASS=X
//*
//TESTPROG EXEC ASSIST
//SYSIN DD *
$JOB   ASSIST  PROGTEST,NOLOAD     COMMENTS
*        ========== MEDIUM - LONG PROGRAM TESTS ==========
*        ========== MEDIUM - LONG PROGRAM TESTS ==========
*        ========== MEDIUM - LONG PROGRAM TESTS ==========
*        ========== MEDIUM - LONG PROGRAM TESTS ==========
*
*        THESE PROGRAMS ARE STUDENT-WRITTEN PROJECTS FROM VARIOUS
*        PROGRAMMING COURSES, ILLUSTRATING BOTH RUNNING PROGRAMS AND
*        PROGRAMS WITH TYPICAL EXECUTION ERRORS.
*        THEY ARE IN MORE-OR-LESS ASCENDING ORDER BY SIZE, RANGING
*        FROM ABOUT 400 CARDS TO OVER 1000 CARDS.       A USEFUL PARM
*        FIELD FOR THIS RUN MIGHT BE THE FOLLOWING:
*        PARM='T=10,R=2000,RD=500,TD=1,TX=5,RX=2000'   (360/67)
*        (BATCH MUST ALSO BE CODED OF COURSE)
*        THE FOLLOWING OPTIONS MIGHT USEFULLY BE TRIED TO OBSERVE
*        THEIR EFFECTS:    NOLIST   CMPRS    LARGE
*        ========== MEDIUM - LONG PROGRAM TESTS ==========
*        ========== MEDIUM - LONG PROGRAM TESTS ==========
*        ========== MEDIUM - LONG PROGRAM TESTS ==========
*        ========== MEDIUM - LONG PROGRAM TESTS ==========
$JOB   ASSIST  PROGTEST,NERR=10
*        *** SAMPLE PROGRAM FROM DATA STRUCTURES COURSE.  313 STMTS,
*        WITH 8 ERRORS.
*        CMPSC 404.1 - FALL 1970 - PSU - INSTRUCTOR - R.VARNEY.
*        PROGRAM CAUSED ASSIST ABEND  10/29/70 - 0C2
*  IN THIS CSECT THE FOLLOWING REGISTERS WERE USED AS FOLLOWS :
*        REG 1   PASSES LOCATION OF LAVS TO MAIN CSECT
*        REG 2   FIRST IT IS USED TO SET UP LINKS IN LAVS AND THEN IT IS THE
*                   NUMBER OF ZIP CODES OFF EACH CARD
*        REG 3   LOCATION OF ZIP CODES READ IN
*        REG 4   USED TO SET THE LAST LINK IN ALIST TO ZERO
*        REG 5    SAVES THE BASE REGISTER FROM MAIN CSECT
*        REG 6    NUMBER OF ZIP CODES IN LIST
*        REG 7 AND REG 8   USED TO PRINT LISTS
*        REG 10   USED TO SET UP LINKS IN LAVS
*        REG 11   LOCATION OF NEXT AVAILABLE SPACE
*        REG 12   BASE REGISTER
*        REG 13   LOCATION OF WHERE TO SAVE REGISTERS
*        REG 14   LOCATION OF WHERE TO RETURN TO FROM MAIN CSECT
*        REG 15   LOCATION OF WHERE TO BRANCH TO IN MAIN CSECT
*
*
*
INOUT    CSECT
         BALR      12,0
         USING     *,12
         ST        14,SAV14
* THE FOLLOWING CODE LINKS THE WORDS IN LAVS
         LA        11,LAVS
         L         2,=F'199'
APE      LR        10,11
         A         11,=F'8'
         STH       11,6(10)
         S         2,=F'1'
         BP        APE
         STH       2,6(11)
         A         11,=F'8'
* STORES LOCATION OF NEXT AVAILABLE SPACE NOT IN LINKED LIST
         ST     11,NLAVS
         STH       2,LAVS+6
         STH       2,LAVS+14
*
* READS IN ZIP CODES OF FIRST COMPANY, PRINTS THEM OUT AND STORES THEM IN
*   LINKED LIST
*
         LA        11,LAVS+16
         SR        4,4
         SR        6,6
         XPRNT     LL1,21
         LA        10,LAVS
READ     XREAD     CARD,80
         L         2,=F'16'
         LA        3,CARD
STATE    CLC       0(5,3),BLANK
CHANGE   BE        STOP
         CH        11,=H'0'
         BE        MORE
         MVC       1(5,11),0(3)
         XPRNT     0(11),6
         A         6,=F'1'
         STH       11,6(10)
         MVC       LINK(2),6(11)
         STH       4,6(11)
         LR        10,11
         LH        11,LINK
         A         3,=F'5'
         S         2,=F'1'
         BZ        READ
         B         STATE
*
* SENDS LIST TO MAIN CSECT TO BE SORTED IN ASCENDING ORDER
STOP     LA        10,LAVS+8
         ST        6,LAVS
         LA        1,LAVS
         LA        13,SAVIO
         L         15,=V(MAIN)
         BALR      14,15
*  MAIN CSECT RETURNS HERE AND PRINTS LIST IN ASCENDING ORDER WITHOUT
*    ANY DUPLICATES
UP       LA        7,LAVS
         LH        8,6(7)
         XPRNT     L1,55
DOWN     XPRNT     0(8),6
         LH        7,6(8)
         LR        8,7
         CH        7,=H'0'
         BNE       DOWN
*
* READS IN SECOND LIST OF ZIP CO PRINTS THEM OUT AND PUTS THEM IN LINKED LIST
         SR        6,6
         XPRNT     LL2,21
READ1    XREAD     CARD,80
         L         2,=F'16'
         LA        3,CARD
STATE1   CLC       0(5,3),BLANK
         BE        STOPS
         CH        11,=H'0'
         BE        MORE
         MVC       1(5,11),0(3)
         XPRNT     0(11),6
         A         6,=F'1'
         STH       11,6(10)
         MVC       LINK(2),6(11)
         STH       4,6(11)
         LR        10,11
         LH        11,LINK
         A         3,=F'5'
         S         2,=F'1'
         BZ        READ1
         B         STATE1
*
* SENDS LIST TO MAIN CSECT TO BE SORTED IN ASCENDING ORDER
STOPS    LA        1,LAVS+8
         LA        13,SAVIO
         L         15,=V(MAIN)
         BALR      14,15
*  MAIN CSECT RETURNS HERE AND PRINTS LIST IN ASCENDING ORDER WITHOUT
* ANY DUPLICATES.
         LA        7,LAVS+8
         LH        8,6(7)
         XPRNT     L2,55
DOWN1    XPRNT     0(8),6
         LH        7,6(8)
         LR        8,7
         CH        7,=H'0'
         BNE       DOWN1
*
* SENDS TWO LISTS TO MAIN CSECT TO BE MERGED
MEG      LA        1,LAVS
         LA        13,SAVIO
         L         15,=V(MERGE)
         BALR      14,15
*
* RETURNS MERGED LIST AND PRINTS IT OUT
         SR        7,7
         LH        7,LAVS+6
         XPRNT     LM,47
AREA     XPRNT     0(7),6
         LH        7,6(7)
         CH        7,=H'0'
         BNE       AREA
* RETURNS LISTS TO AVAILABLE SPACE
ABCD     L         2,NLAVS
         STH       2,6(7)
         LA        3,LAVS
         ST        3,NLAVS
ABC      L         14,SAV14
         BR        14
MORE     XPRNT     ERR,14
         B         ABCD
ERR      DC          C' NO MORE SPACE'
LL1   DC  C'1THE EASTERN COMPANY.'
LL2   DC  C'1THE WESTERN COMPANY.'
L1  DC  C'1THE FOLLOWING ZIP CODES ARE FROM THE EASTERN COMPANY: '
L2  DC  C'1THE FOLLOWING ZIP CODES ARE FROM THE WESTERN COMPANY: '
LM  DC  C'1THE FOLLOWING ZIP CODES ARE THE COMBINED LIST : '
         LTORG
CARD     DS        80C
BLANK    DC        5C' '
LINK     DS        H
SAV14    DS        F
SAVIO    DS        18F
X        DS        F
NLAVS    DS        F
LAVS     DC        1600C' '
*
*
*
* THE FOLLOWING SECTION OF CODE USES THE REGISTERS AS FOLLOWS :
*        REG  1    LOCATION OF LAVS
*        REG  2    POINTER
*        REG  3    NEXT LOCATION TO PUT IN ORDER
*        REG   4   DUMMY
*        REG  5    USED TO SAVE BASE REGISTER WHEN BRANCHING BACK
*        REG  6    NUMBER OF ZIP CODES IN LIST
*        REG 7 AND REG 8   DUMMY USED TO PUT LIST IN ORDER
*        REG  9    DUMMY TO DECREASE LIST
*        REG  10   LOCATION OF LAVS
*
*
MAIN     CSECT
         ENTRY     MERGE
         STM       14,12,12(13)
         BALR      12,0
         USING     *,12
         ST        13,SAVM
* THE FOLLOWING SECTION OF CODE SORTS A LIST AND PUTS IT IN ASCENDING ORDER.
         SR        4,4
         SR        10,10
         SR        2,2
         SR        3,3
         SR        7,7
         SR        8,8
         SR        9,9
* IF ONLY ONE ZIP CODE IN LIST, YOU ARE FINISHED
         C         6,=F'1'
         BE        END
*
*
* A LIST IS SET UP WITHIN THE LIST PASSED FROM INOUT CSECT.   THE FIRST
* TWO NUMBERS IN THE ORGINAL LIST ARE PUT IN ASCENDING ORDER AND LINKED TOGETHER
* AND ALSO LINKED TO THE HEADER CELL.   THE LAST ONE IS SET TO ZERO.
* REGISTER 3 POINTS TO THE NEXT ZIP CODE IN THE ORGINAL LIST.   IT IS THEN
* COMPARED TO EACH ZIP CODE IN THE NEW LIST AND IS PUT IN ITS PROPER PLACE
* (ASCENDING ORDER) BY CHANGING THE LINKS.
*
*
         LH        2,6(1)
         LH        3,6(2)
         LR        10,1
         STH       4,6(2)
ON       CLC       1(5,2),1(3)
         BH        KHANGE
         CLC       1(5,2),1(3)
         BE        EQUAL
         CLC       6(2,2),=H'0'
         BE        NEXT
         LR        10,2
         LH        2,6(10)
         B         ON
* END OF NEW LIST, SO ADD ZIP CODE AT END.
NEXT     STH       3,6(2)
         LH        7,6(3)
         STH       4,6(3)
         LR        3,7
         B         MON
* PUTS NUMBER IN LIST.
KHANGE   LH        8,6(10)
         STH       3,6(10)
         LH        7,6(3)
         STH       8,6(3)
         LR        2,3
         LR        3,7
* IS IT THE END OF THE ORGINAL LIST?
MON      CH        7,=H'0'
         BE        END
         CLC       1(5,2),1(3)
         BNH       ON
         LH        2,6(1)
         LR        10,1
         B         ON
* ELEMINATES ANY DUPLICATES.
EQUAL    LH        3,6(3)
         L         9,0(1)
         S         9,=F'1'
         ST        9,0(1)
         B         MON
* RETURNS TO INOUT CSECT.
END      L         13,SAVM
         ST        12,40(13)
         LM        14,12,12(13)
         BR        14
*
*
* IN THE FOLLOWING SECTION THE REGISTERS ARE USED AS FOLLOWS:
*        REG 2   LOCATION OF A ZIP CODE IN FIRST LIST
*        REG 3   LOCATION OF A ZIP CODE IN SECOND LIST
*        REG 4   LOCATION OF A ZIP CODE IN THE MERGED LIST.
*        REG 11  NUMBER OF ZIP CODES IN MERGED LIST.
*
* THIS SECTION OF CODE MERGES THE TWO LISTS TOGETHER IN ASCENDING ORDER.
* IT COMPARES THE FIRST ZIP CODE IN EACH LIST.   THE SMALLER IS LINKED TO
* THE HEADER CELL.   IT THEN TAKES THE NEXT ZIP CODE IN THAT LIST AND COMPARES
* IT TO THE OTHER'S FIRST ZIP CODE.   IT LINKS THE SMALLER ONE TO THE MERGED
* LIST AND CONTINUES UNTIL ONE OF THE LISTS IS EXAUSTED.   THEN IT LINKS THE
* ZIP CODE OF THE OTHER LIST TO THE MERGED LIST AND THEN YOU ARE FINISHED
* SINCE THE REST OF THE OTHER LIST IS ALREADY LINKED TOGETHER IN ASCENDING ORDER
*
*
MERGE    STM       14,12,12(13)
         LR        12,5
         ST        13,SAVM
         SR        2,2
         SR        3,3
         SR        4,4
         SR        11,11
         L         11,0(1)
         A         11,8(1)
         ST        11,0(1)
         LH        2,6(1)
         LH        3,14(1)
         LR        4,1
GO       CLC       1(5,2),1(3)
         BNL       LIST2
         STH       2,6(4)
         LR        4,2
         CLC       6(2,4),=H'0'
         BE        DONE1
         LH        2,6(4)
         B         GO
LIST2    CLC       1(5,2),1(3)
         BE        SAME
         STH       3,6(4)
         LR        4,3
         CLC       6(2,4),=H'0'
         BE        DONE2
         LH        3,6(4)
         B         GO
* FIRST LIST RAN OUT
DONE1    STH       3,6(4)
         B         RETURN
* SECOND LIST RAN OUT
DONE2    STH       2,6(4)
         B         RETURN
* ELEMINATES ANY DUPLICATES
SAME     L         11,0(1)
         S         11,=F'1'
         ST        11,0(1)
         LH        2,6(2)
         B         GO
* RETURNS TO INOUT CSECT
RETURN   L         13,SAVM
         LM        14,12,12(13)
         BR        14
SAVM     DS        F
         LTORG
         END
$ENTRY
100221522261607070832370519112236071705519111068307520102110176041525216
161421612717043179811790119112168231680116802606371795417815161423030208
100362710219034454020215415230381010100120005253050702901601022101804306
274011001002116941203183306830021731390230060019611850543215
466246813154956731029863260637100178411463074441394901677027631245280179
477216060144115631665030310005482263720363167441066252577002532025320148
875441001863105940885240661607622029001791364915039472030309482047700160
7522144501600625320460507
$JOB   ASSIST  PROGTEST,
         TITLE 'FINAL PROJECT - CMPSC 102 - WINTER 70 - MIKE HUNDLEY'
*        *** THS PROGRAM SHOULD EXECUTE 3778 INSTRUCTIONS, PRINT ABOUT
*        HALF A PAGE OF OUTPUT, THEN RETURN NORMALLY.
*        *** IT IS A TYPICAL FINAL PROJECT FROM SEVERAL YEARS AGO.
         PRINT NOGEN
INPUT    CSECT
         B     12(15)
         DC    X'7'
         DC    CL7'INPUT  '
         BALR  12,0
         USING *,12
         ST    14,RETURN
         LA    2,PROGRAM
         XPRNT =CL40'1*** INPUT DATA CARDS ***',40
READIN   XREAD CARD
         XPRNT CARD-4,84
         MVC   0(80,2),CARD
         CLC   10(3,2),=C'END'
         BE    NOMORE
         LA    2,80(2)
         B     READIN
NOMORE   LA    2,DATAAREA
READDATA XREAD BUFFER,4           READ DATA FOR PSEUDO PROGRAM
         XPRNT BUFFER-1,5
         MVC   0(4,2),BUFFER       MOVE DATUM TO DATAAREA
         CLC   0(2,2),=C'**'
         BE    ENTER
         LA    2,4(2)
         B     READDATA
ENTER    LA    1,PROGRAM
         LA    0,DATAAREA
         LA    13,SAVE
         L     15,=V(PASS1)
         BALR  14,15
         LTR   0,0
         BNM   DONE
         XPRNT =CL40'3***OBJECT CODE***',40
PRINT    MVC   BUFFER(4),0(1)     MOVE OBJECT CODE TO PRINT BUFFER
         XPRNT BUFFER-4,8
         LA    1,4(1)
         CLC   0(4,1),=4C'*'
         BNE   PRINT
DONE     L     14,RETURN
         BR    14
RETURN   DS    F
INPUTCC  DC    4C' '
CARD     DS    20F
SAVE     DS    18F
OUTPUTCC DC    4C' '
BUFFER   DS    F
PROGRAM  DC    2000C' '
DATAAREA DC    160C'0'
         LTORG
PASS1    CSECT
         PRINT NOGEN
         B     12(15)
         DC    X'7'
         DC    CL7'PASS1  '
         STM   14,12,12(13)
         BALR  12,0
         USING *,12
R10      EQU   10
         ST    13,SAVE1+4
         ST    1,PROGADD
         SR    5,5
         LR    7,1
         LA    11,TABLE
         LA    2,1
         LA    R10,11
NEXTCARD CLC   10(3,7),=C'END'
         BE    LASTCARD
         CLC   0(8,7),=8C' '
         BE    NOLABEL
         LA    3,7(7)
         CLI   0(7),C'A'
         BL    ERROR
         CLI   0(7),C'Z'
         BH    ERROR
         SR    6,6
         LA    4,1(7)
BLANK    CLI   0(4),C' '
         BE    FLAG
         CLI   0(4),C'A'
         BL    ERROR
         CLI   0(4),C'9'
         BH    ERROR
         LTR   6,6
         BNZ   ERROR
         BXLE  4,2,BLANK
         B     DOUBLEA
FLAG     BCTR  6,0
         BXLE  4,2,BLANK
DOUBLEA  LA    9,TABLE
COMPARE  CLC   0(8,7),0(9)
         BE    DUPLABEL
         BXLE  9,R10,COMPARE
         MVC   0(8,11),0(7)
CVDEC    LA    14,PDECIMAL
         CVD   5,PDECIMAL
         UNPK  UNPACA(8),6(2,14)
         OI    UNPACA+7,X'F0'
         MVC   8(3,11),UNPACA+5
         LA    11,11(11)
ERROR    NOP   NOLABEL
DUPLABEL NOP   NOLABEL
NOLABEL  CLC   10(2,7),=C'DS'
         BE    CVBINARY
         LA    5,4(5)
DONEA    LA    7,80(7)
         B     NEXTCARD
CVBINARY MVC   PDECIMAL(8),13(7)
         PACK  PDECIMAL(8),PDECIMAL
         CVB   14,PDECIMAL
         SLL   14,2
         AR    5,14
         B     DONEA
LASTCARD MVC   0(8,11),=8C'*'
         LA    1,=A(TABLE,PROGADD)
         LA    13,SAVE1
         L     15,=V(PASS2)
         BALR  14,15
         L     13,SAVE1+4
         LM    2,12,28(13)
         L     14,12(13)
         BR    14
PROGADD  DS    F
PDECIMAL DS    D
UNPACA   DS    D
SAVE1    DS    18F
TABLE    DC    2000C' '
         LTORG
PASS2    CSECT
         PRINT NOGEN
         B     12(15)
         DC    X'7'
         DC    CL7'PASS2  '
         STM   14,12,12(13)
         BALR  12,0
         USING *,12
         ST    13,SAVE2+4
         ST    0,DATAADD
         L     9,0(1)             LOAD ADDRESS OF TABLE
         L     7,4(1)             LOAD ADDRESS OF PSEUDO PROGRAM
         L     7,0(7)
         S     7,=F'80'
         LA    5,OBJECT-4
         SR    0,0
NEWLOOP  LA    5,4(5)
NEWCARD  LA    7,80(7)
         CLC   10(3,7),=C'END'
         BE    ENDOFOPS
         CLC   10(6,7),=C'BRANCH'
         BE    BRANCH2
         CLC   20(1,7),=C','
         BE    BRANCH2
         CLC   10(2,7),=C'DC'
         BE    DC2
         CLC   10(2,7),=C'DS'
         BE    DS2
         CLC   10(4,7),=C'HALT'
         BE    HALTA
         LA    2,OPSCONTS
         LA    15,9
SCANOPS  CLC   0(5,2),10(7)
         BE    INSERTOP
         LA    2,6(2)
         BCT   15,SCANOPS
         MVI   0(5),C'?'
         BCTR  0,0
         B     SCANLABS
DS2      MVC   DOUBLE2(8),13(7)
         PACK  DOUBLE2(8),DOUBLE2
         CVB   14,DOUBLE2
         SLL   14,2
         AR    5,14
         B     NEWCARD
DC2      MVC   0(4,5),19(7)
         B     NEWLOOP
HALTA    MVI   0(5),C'H'
         B     NEWLOOP
BRANCH2  LA    10,3
         LA    11,ZHL
CHECK    CLC   0(1,11),19(7)
         BE    INSERT
         LA    11,1(11)
         BCT   10,CHECK
         LA    11,1(11)
         BCTR  0,0
INSERT   MVC   0(1,5),3(11)
SHIFTLAB MVC   19(8,7),21(7)
         B     SCANLABS
INSERTOP MVC   0(1,5),5(2)
SCANLABS LR    3,9
CHECK2   CLC   0(8,3),19(7)
         BE    CODE
         LA    3,11(3)
         CLC   0(8,3),=8C'*'
         BNE   CHECK2
         MVC   1(3,5),QUESTION
         B     NEWLOOP
CODE     MVC   1(3,5),8(3)
         B     NEWLOOP
ENDOFOPS MVC   0(4,5),=4C'*'
         LA    1,OBJECT
         LTR   0,0
         BNM   EXECUTE
         B     RETURNA
EXECUTE  L     15,=V(INTERP)
         L     0,DATAADD
         LA    13,SAVE2
         BALR  14,15
RETURNA  L     13,SAVE2+4
         LM    2,12,28(13)
         L     14,12(13)
         BR    14
DATAADD  DS    F
SAVE2    DS    18F
OPSCONTS DC    C'RD   R'
         DC    C'ADD  A'
         DC    C'SUB  S'
         DC    C'LOAD L'
         DC    C'STORET'
         DC    C'WRT  W'
         DC    C'MULT M'
         DC    C'DIV  D'
         DC    C'GOTO G'
ZHL      DC    C'ZHL'
ERROROP  DC    C'#+-?'
QUESTION DC    C'???'
         DS    0F
OBJECT   DC    400C'0'
DOUBLE2  DS    D
         LTORG
INTERP   CSECT
         PRINT NOGEN
         B     12(15)
         DC    X'7'
         DC    CL7'INTERP '
         STM   14,12,12(13)
         BALR  12,0
         USING *,12
         ST    13,SAVE3+4
         LR    13,0
         LR    10,1
ACC      EQU   3
         S     10,=F'4'
TOP      LA    10,4(10)
TOP2     L     9,0(10)
         SLDL  8,8
         STC   8,OPCODE
         ST    9,OPERAND
         PACK  DOUBLE(8),OPERAND(3)
         CVB   7,DOUBLE
*********XSNAP LABEL='AFTER CVB         ',STORAGE=(OP,SAVE3)
         L     5,=F'13'
         LA    4,OPTAB
UP       CLC   0(1,4),OPCODE
         BE    DOWN
         LA    4,1(4)
         BCT   5,UP
         XPRNT =CL40'0** INVALID OP CODE **',40
         B     STOP
DOWN     S     4,=A(OPTAB)
         SLA   4,2
         A     4,=A(CODEADD)
         L     4,0(4)
         BR    4
CVTBIN   AR    7,1
         CLI   0(7),C'-'
         BE    MINUSNUM
         PACK  DOUBLE(8),0(4,7)
         CVB   6,DOUBLE
*********XSNAP LABEL='AFTER CVTBIN'
         BR    14
MINUSNUM PACK  DOUBLE(8),1(3,7)
         CVB   15,DOUBLE
         LCR   6,15
         BR    14
STORE    AR    7,1
         CVD   ACC,DOUBLE
         UNPK  UNPACK(8),DOUBLE+6(2)
         OI    UNPACK+7,X'F0'
         LTR   ACC,ACC
         BNL   POSITIVE
         MVI   UNPACK+4,C'-'
POSITIVE MVC   0(4,7),UNPACK+4
*********XSNAP LABEL='AFTER STORE',STORAGE=(*0(1),*160(1))
         B     TOP
READ     AR    7,1
         MVC   0(4,7),0(13)
         CLC   0(2,13),=C'**'
         BE    NODATA
         LA    13,4(13)
         B     TOP
NODATA   XPRNT =CL50'0** ATTEMPT TO READ BEYOND END OF FILE **',50
         B     STOP
GOTO     LA    10,0(7,1)
         B     TOP2
LOAD     BAL   14,CVTBIN
         LR    ACC,6
         B     TOP
DIV      BAL   14,CVTBIN
         LR    2,ACC
         SRA   2,31
         DR    2,6
         B     TOP
ADD      BAL   14,CVTBIN
         AR    ACC,6
         B     TOP
SUB      BAL   14,CVTBIN
         SR    ACC,6
         B     TOP
ZERO     LTR   ACC,ACC
         BNE   TOP
         LA    10,0(7,1)
         B     TOP2
HIGH     LTR   ACC,ACC
         BNH   TOP
         LA    10,0(7,1)
         B     TOP2
LOW      LTR   ACC,ACC
         BNL   TOP
         LA    10,0(7,1)
         B     TOP2
MULT     BAL   14,CVTBIN
         MR    2,6
         B     TOP
WRITE    AR    7,1
         CLI   0(7),C'-'
         BE    NEGATIVE
         MVC   PLUS+2(4),0(7)
         XPRNT PLUS,6
         B     TOP
NEGATIVE MVC   MINUS+1(4),0(7)
         XPRNT MINUS,5
         B     TOP
HALT     XPRNT =CL40'0**** EXECUTION COMPLETED ****',40
STOP     L     13,SAVE3+4
         LM    2,12,28(13)
         L     14,12(13)
         BR    14
PLUS     DC    C'0+0000'
MINUS    DC    5C'0'
OPTAB    DC    C'ASLTRWMD#+-GH'
OP       DS    F
OPCODE   DS    C
OPERAND  DS    F
DOUBLE   DS    D
UNPACK   DS    D
SAVE3    DS    18F
CODEADD  DC    A(ADD,SUB,LOAD,STORE,READ,WRITE,MULT,DIV,ZERO,HIGH,LOW)
         DC    A(GOTO,HALT)
         LTORG
         END
$ENTRY
          RD       HERE
THERE     LOAD     CNT
          SUB      ONE
          STORE    CNT
          BRANCH   Z,DONE
          RD       HERE1
          LOAD     HERE
          SUB      HERE1
          BRANCH   L,SWITCH
          GOTO     THERE
SWITCH    LOAD     HERE1
          STORE    HERE
          GOTO     THERE
DONE      WRT      HERE
          HALT
HERE      DS        1
HERE1     DS        1
CNT       DC          5
ONE       DC          1
          END
5249
6521
1234
5340
6845
**
$JOB   ASSIST  PROGTEST
*        *** FIRST OF SERIES OF THREE RELATED PROGRAMS.
*        PSU CMPSC 102 - SUMMER 1970 - FINAL PROJECT
*        *** USER PROGRAM PRINTS TWO PAGES OF OUTPIT, EXECUTES
*        19508 INSTRUCTIONS, THEN ABENDS WITH 0C4 ERROR AND DUMPS.
*        *** EXAMPLE OF FINAL PROJECT WITH AN EXECUTION - TIME ERROR
MAIN     CSECT
         ENTRY     STORE
         ENTRY     COUNTER
         BALR      12,0
         USING     *,12
         ST        14,SAV14
         SR        4,4            POINTER IN ARRAY OF INPUT
         SR        5,5            COUNTER OF NUMBER OF CARDS READ.
         XPRNT     CONT,56        PRINTS LABEL FOR INPUT
TOP      XREAD     ARRAY,80       READS ALL OF INPUT CARDS
         CLC       ARRAY(2),=C'##'     LOOKS FOR FLAG CARD
         BE        BRPASS1
         XPRNT     CC,81          ECHO CHECKS ALL OF THE INPUT CARDS
         LA        3,STORE(4)     LOADS THE ADDRESS OF THE ARRAY
*                                      CONTAINING THE FIRST 40 COLUMNS
*                                      OF EACH INPUT CARD.
         MVC       0(40,3),ARRAY  PUTS FIRST 40 COLUMNS INTO THE ARRAY
         A         4,=F'40'       INCREASES POINTER IN THE ARRAY
         A         5,=F'1'        INCREASES THE CARD COUNTER
         B         TOP            RETURNS TO READ THE NEXT CARD
*                                 COMES HERE IF FLAG CARD IS READ
BRPASS1  ST        5,COUNTER      STORES THE CARD COUNTER
         L         15,=V(PASS1A)  LOADS ADDRESS OF CSECT BEIBG CALLED
         LA        13,SAVMAIN     LOADS REGISTER STORAGE LOCATION
         BALR      14,15          BRANCHES TO CSECT PASS1A
         L         14,SAV14
         B         14
SAV14    DS        F
CONT     DC        C'1THIS IS THE PROGRAM READ INTO THE PASS1, PASS2'
         DC        C'COMPILER'
CC       DC        C' '
ARRAY    DS        80C
COUNTER  DS        F
SAVMAIN  DS        18F
         LTORG
STORE    DS        1000F
         PRINT OFF
PASS1A   CSECT
         ENTRY     LEGAL
         ENTRY     LOCTN
         STM       14,12,12(13)
         BALR      12,0
         USING     *,12
         ST        13,SAVPAS1A+4
         L         2,=V(STORE)    LOADS ADDRESS OF STORAGE INTO
         L         3,=V(STORE)    REGISTERS 2 AND 3
         SR        4,4            FLAG REGISTER FOR ERRORS.
         SR        7,7            POINTER IN LABEL TABLE.
         SR        9,9            POINTER  IN LOCATION COUNTER TABLE.
         SR        10,10          LOCATION COUNTER REGISTER
TOP1A    CLC       0(1,2),=C' '   CHECKS FOR A LABEL.
         BE        NOLABEL
         SR        6,6
         CLC       0(1,2),=C'A'   CHECKS FOR LEGALITY OF LABEL
         BL        ILLEGAL        IF CONDITIONS ARE NOT MET, BRANCH TO
         CLC       0(1,2),=C'Z'        PRINT ERROR STATEMENT
         BH        ILLEGAL
         CLC       1(1,2),=C'1'
         BL        ILLEGAL
         CLC       2(2,2),=C': '
         BNE       ILLEGAL
*                                 GET HERE IF LEGAL LABEL CONDITIONS A
*                                      RE MET.
         LA        8,LEGAL(7)     LOADS ADDRESS OF NEXT ENTRY POINT FO
*                                      R A LEGAL LABEL.
UP1A     LA        5,LEGAL(6)     LOADS ADDRESS OF LABEL TO BE COMPARE
         CLC       0(2,2),0(5)    COMPARES INPUT LABEL TO LABEL TABLE
         BE        DUPLAB         IF EQUAL, BRANCHES TO PRINT ERROR.
         A         6,=F'2'        INCREASES POINTER TO NEXT LABEL.
         CR        7,6            CHECKS FOR END OF LABEL TABLE.
         BH        UP1A
         MVC       0(2,8),0(2)    PUTS INPUT LABEL INTO TABLE.
         SR        6,6
REG6     C         6,=F'0'        CHECKS FLAG REGISTER
         BE        RG6            BRANCHES IF EQUAL
         LR        8,10           SAVE LOCATION COUNTER
         CVD       10,AN          CHANGES LOC. CTR. TP DECIMAL
         UNPK      ANY(8),AN+4(4) UNPACKS LOC. CTR.
         L         10,ANY+4       PUTS LOC. CTR. IN REG. 10
         A         10,=F'48'      CHANGES SIGN FROM A C TO A F
         L         11,PTR         LOADS PTR. OF LOCATION TABLE
*                                      CORRESPONDING TO THE INPUT
         ST        10,LTN(11)     PUTS BASE 10 LOOKING LOC. CTR. IN TB
         A         11,=F'4'       INCREASES PTR. IN TABLE
         ST        11,PTR         SAVES POINTER
         LR        10,8           RESTORES LOCATION COUNTER
*                                 THIS SECTION CHECKS FLAG REGISTER
*                                      AND RETURNS TO PROPER POINT.
         C         6,=F'1'
         BE        LL
         C         6,=F'2'
         BE        LL1
         C         6,=F'3'
         BE        LL2
         C         6,=F'4'
         BE         LL3
         B         LL4
*                  THIS PART INSERTS LOCATION COUNTER INTO TABLE
*                                 CORRESPONDING TO LABEL INSERTED.
RG6      LR        11,10
         LR        8,10           SAVES LOCATION COUNTER
         SR        10,10          CLEARS REG. SO THAT IT WILL CONTAIN
*                                      REMAINDER AFTER DIVISION
         D         10,=F'10'      DIVIDES LOC. CTR. BY 10
         ST        10,LC1         SAVES THE REMAINDER
         SR        10,10          CLEARS REG. 10 FOR NEXT REMAINDER
         D         10,=F'10'      DIVIDES LOC. CTR. BY 10 AGAIN
         ST        10,LC2         SAVES THE REMAINDER
         SLL       11,8           MULTIPLIES VALUE IN 11 BY 256
         ST        11,LC3         STORES RESULT IN LC3
         L         11,LC2         PUTS SECOND REMAINDER IN REG. 11
         SLL       11,4           MULTIPLIES IT BY 16
         L         10,LC1         PUTS FIRST REMAINDER IN REG. 10
         AR        10,11          ADDS PARTS OF NEW LOC.CTR.
         A         10,LC3         ADDS REST OF NEW LOC. CTR.
NO       ST        10,LOCTN(9)
         LR        10,8           RESTORES LOC. CTR.
         LA        7,2(7)         INCREASES LABEL TABLE POINTER.
         LA        9,4(9)         INCREASES LOCATION COUNTR TABLE PTR.
         LA        2,4(2)          INCREASE INPUT POINTER.
*        COMES HERE IF THERE IS NO LABEL AND LOOKS FOR THE OPCODE.
NOLABEL  CLC       0(1,2),=C' '   CHECKS FOR OPCODE
         BNE       LOOK           BRANCHES WHEN FINDS OPCODE
         LA        2,1(2)              INCREASES INPUT POINTER
         B         NOLABEL        RETURNS AND CHECKS FOR OPCODE
*                  COMES HERE IF OPCODE IS FOUND.
LOOK     CLC       0(1,2),MCODE   CHECKS FOR A BRANCH STATEMENT
         BNE       LOOK1          IF NOT BRANCHES AND CHECKS FOR YIELD
         LA        6,1            SETS UP A FLAG REGISTER
         B         REG6           BRANCHES TO CHANGE LOC. CTR.
LL       A         10,=F'6'       ADDS 6 TO LOC. CTR. FOR BRANCH
         B         CLEANUP        BRANCHES TO PREPARE FOR NEW INPUT
LOOK1    CLC       0(1,2),MCODE+1 CHECKS FOR A YIELD STATEMENT
         BNE       LOOK2          IF NOT, BRANCHES AND CHECKS FOR DC.
         LA        6,2            SETS UP A FLAG REGISTER
         B         REG6           BRANCHES TO CHANGE LOC. CTR.
LL1      A         10,=F'2'       ADDS 2 TO LOC. CTR. FOR YIELD
         B         CLEANUP        BRANCHES TO PREPARE FOR NEW INPUT
LOOK2    CLC       0(2,2),MCODE+6 CHECKS FOR DC STATEMENT
         BNE       LOOK3          IF NOT, BRANCHES AND LOOKS FOR DS
         LA        2,2(2)         IF SO, INCREASES INPUT PTR. PAST OPC
OUT1A    CLC       0(1,2),=C' '   CHECKS FOR OPERAND
         BNE       OUT            BRANCHES WHEN FINDS OPEFAND
         LA        2,1(2)         IF NOT, INCREASE INPUT PTR.
         B         OUT1A          RETURNS AND CHECKS FOR OPERAND
*                                 GETS HERE WHEN FINDS OPERAND
OUT      CLC       0(1,2),=C'C'    LOOKS FOR A "C"
         BNE       FULLWORD       IF NOT, ASSUMES A "F"
         LA        2,2(2)         INCREASES INPUT POINTER PAST QUOTE
         SR        5,5            SETS UP COUNTER OF NO. OF CHARACTERS
OUTADD   CLC       0(1,2),=X'7D'  SEARCHES FOR SECOND QUOTE.
         BE        ADD            IF FOUND, ADDS NUMBER TO LOC. CTR.
         A         5,=F'1'        ADDS 1 TO CHARACTER COUNTER
         LA        2,1(2)         INCREASES INPUT POINTER.
         B         OUTADD         RETURNS AND LOOKS FOR QUOTE.
ADD      LA        6,3            SETS UP A FLAG REGISTER
         B         REG6           BRANCHES TO CHANGE LOC. CTR.
LL2      AR        10,5           ADDS VALUE CALCULATED IN REG 5 TO
*                                      LOCATION COUNTER
         B         CLEANUP         BRANCHES TO PREPARE FOR NEW INPUT.
FULLWORD LR        11,10          SAVES LOCATION COUNTER.
*                                 THIS PART IS FOR A DC FULLWORD.
FULWD1A  SRL       10,2           CHECKS LOC. CTR. FOR FULLWORD
         SLL       10,2           BOUNDARY
         CR        11,10
         BE        FULL1A         IF ON A FULLWORD, ADDS TO LOC. CTR.
         A         10,=F'4'       PUTS LOC. CTR. ON A FULLWORD BNDARY.
FULL1A   LA        6,4
         B         REG6
LL3      A         10,=F'4'       ADDS 4 TO LOC. CTR. FOR FULLWORD
*                                      INSTRUCTION OR CONSTANT
         B         CLEANUP        BRANCHES TO PREPARE FOR NEW INPUT
LOOK3    CLC       0(2,2),MCODE+8 CHECKS FOR DS STATEMENT
         BNE       LOOK4          IF NOT, CHECKS FOR END STATEMENT
         LA        2,2(2)         IF SO, INCREASE INPUT PTR. PAST OPCO
CHECK1A  CLC       0(1,2),=C' '   CHECKS FOR OPERAND
         BNE       CHECK          BRANCHES WHEN FINDS OPERAND
         LA        2,1(2)         IF NOT, INCREASES INPUT PTR.
         B         CHECK1A        RETURNS TO CHECK FOR OPERAND
*                                 GETS HERE WHEN FINDS OPERAND.
CHECK    CLC       0(1,2),=C'C'   CHECKS FOR A "C"
         BNE       MOVE            IF NOT, BRANCHES TO CHECK FOR A "F"
         LA        6,5            SETS UP A FLAG REGISTER
         B         REG6           BRANCHES TO CHANGE LOC. CTR.
LL4      A         10,=F'1'       ADDS 1 TO LOC. CTR. FOR CONSTANT
         B         CLEANUP        BRANCHES TO PREPARE FOR NEW INPUT.
MOVE     CLC       0(1,2),=C'F'   LOOKS FOR A "F"
         BNE       SEARCH         IF NOT, ASSUMES A NUMBER.
         B         FULWD1A
SEARCH   SR        5,5            REGISTER USED TO CONTAIN NUM BER
SEARCH1   IC       5,0(2)         PUTS FIRST NUMBER INTO REGISTER
         LA        2,1(2)         INCREASES INPUT COUNTER
         CLI       0(2),C'Z'      CHECKS TO SEE IF NEXT COLUMN IS A NO
         BNH       DETER          IF NOT, CHECKS FOR "C" OR "F"
         SLL       5,8            IF SO, MAKES ROOM IN REGISTER FOR IT
         B         SEARCH1         RETURNS TO INSERT THE NUMBER
DETER    CLI       0(2),C'C'      CHECKS FOR A "C"
         BNE       DETERF         IF NOT, ASSUMES A "F"
         ST        5,AN+4         STORES THE NUMBER
         PACK      ANY(8),AN+4(4) PACKES NUMBER
          CVB       5,ANY         CHANGES THE NUMBER TO BINARY
         B         ADD            BRANCHES TO PRINT SECTION
DETERF   ST        5,AN+4         STORES THE NUMBER
         PACK      ANY(8),AN+4(4) PACKES NUMBER
         CVB       5,ANY          CHANGES THE NUMBER TO BINARY
         SLL       5,2                 MULTIPLIES IT BY 4 SINCE IT IS
*                                 THE NUMBER OF FULLWORDS
DTRF     LR        11,10
        SRL        10,2
         SLL       10,2
         CR        11,10
         BE        ADD
         A         10,=F'4'
          B          ADD
LOOK4    CLC       0(3,2),MCODE+10 CHECKS FOR END STATEMENT
         BE        ENDF           IF SO BRANCHES TO COMPLETE PASS1
         LR        11,10
         SRL       10,1
         SLL       10,1
         CR        11,10
         BE        FULL1A
         A         10,=F'2'
         B         FULL1A
CLEANUP  LA        3,40(3)        MOVES POINTER OF INPUT TO NEXT CARD
         LA        2,0(3)         PUTS THIS ADDRESS INTO REGISTER 2
         B         TOP1A          RETURNS TO EVALUATED NEXT CARD
ILLEGAL  XPRNT     CCO,31         PRINTS ERROR STATEMENT FOR ILLEGAL
*                                      LABEL
         A         4,=F'1'        PUTS A VALUE INTO FLAG REGISTERSO
*                                      THAT WHEN WE ARE DONE WITH PASS
*                                      1 WE WILL RETURN TO MAIN PROGRA
*                                      M INSTEAD OF GOING TO PASS2
         B         NOLABEL        BRANCHES TO EVALUATE OPCODE FOR CARD
DUPLAB   XPRNT     COC,33         PRINTS ERROR FOR DUPLICATE LAVEL
         A         4,=F'1'        SAME AS ABOVE
         B         NOLABEL        SAME AS ABOVE
ENDF     LA        7,TABLE        LOADS ADD. OF STORAGE THAT WILL CONT
*                                      AIN LOCATION AND INPUT
         L         2,=V(STORE)    LOADS ADDRESS OF INPUT
         LA        3,LTN          LOADS ADD. OF LOCATION TABLE
         L         5,=V(COUNTER)  LOADS ADD. OF NUMBER OF CARDS
         L         6,0(5)         LOADS NUMBER OF CARDS
         S         6,=F'1'        SUBTRACTS 1 CAUSE END STATEMENT IS
*                                      NOT IN THIS PART.
         XPRNT     CNT,20
         XPRNT     CTN,32
EN       MVC       0(4,7),0(3)    PUTS LOCATION INTO STORAGE
         MVC       8(40,7),0(2)   PUTS INPUT CARD INTO STORAGE
         XPRNT     TABLE-1,49     PRINTS LOCATION AND INPUT
         LA        2,40(2)        INCREASES TO NEXT CARD
         LA        3,4(3)         INCREASES TO NEXT LOCATION
         BCT       6,EN           CHECKS NUMBER OF CARDS AND BRANCHES
         LA        1,ADDPASS1     IF NO ERROR, WE LOAD THE ADRESSES OF
*                                      OF THE LABEL TABLE AND THE LOC.
*                                      CTR. TABLE
         LA        13,SAVPAS1A    LOAD THE ADDRESS OF THE STORAGE LOC.
*                                      FOR PASS1 REGISTERS.
         L         15,=V(PASS2)   LOAD PASS2 CSECT
         BALR      14,15          BRANCH TO PASS2
RETURN   L         13,SAVPAS1A+4   LOADS ADDRESS OF MAIN PROGRAM REG.
         LM        14,12,12(13)    RESTORES MAIN PROGRAM REGISTERS
         BR        14             BRANCHES BACK TO MAIN PROGRAM
LEGAL    DS        30H
LOCTN    DS        30F
MCODE    DC        C'BYIELDDCDSEND'
NUMBER   DS        F
AN       DS        D
ANY      DS        D
CCO      DC        C'0***ERROR***   -  ILLEGAL LABEL'
COC      DC        C'0***ERROR***   -  DUPLICATE LABEL'
SAVPAS1A DS        18F
ADDPASS1 DC        A(LEGAL)
         DC        A(LOCTN)
LC1      DS        F
LC2      DS        F
LC3      DS        F
CNT      DC        C'1THIS IS A TABLE OF:'
CTN      DC        C'0LOCATION                  INPUT'
         DC        C'    '
TABLE    DC        12F'0'
PTR      DC        F'0'
LTN      DS        500F
         LTORG
PASS2    CSECT
         STM       14,12,12(13)
         BALR      12,0
         USING     *,12
         ST        13,SAVPAS2+4
         LM        3,4,0(1)       LOADS ADDRESS OF LABEL TABLE IN REG3
*                                 PUT ADD. OF LOC. CTR. TABLE IN REG 4
         L         2,=V(STORE)    PUTS ADDRESS OF INPUT IN REG. 2
         LA        9,0(2)         PUTS ADDRESS OF INPUT IN REG. 9
         SR        5,5            POINTER IN MEMORY FOR MACHINE CODE
UP2      SR        10,10          CLEARED TO CONTAIN MACHINE CODE
         CLC       0(1,2),=C' '   CHECKS FOR A LABEL
         BE        OVERPAS2       IF NOT, BRANCHES TO CHECK FOR IPCODE
         LA        2,3(2)         IF SO, BRANCHES OVER LABEL
OVERPAS2 LA        2,1(2)         INCREASES INPUT POINTER
         CLC       0(1,2),=C' '   CHECKS FOR OPCODE
         BE        OVERPAS2       IF NOT, RETURN TO REPEAT SEARCH
         CLC       0(2,2),R       IF SO CHECKS FOR LD STATEMENT
         BNE       ST             IF NOT LD, CHECKS FOR ST STATEMENT
         IC        10,S           IF LD, PUTS HEX OPCODE IN REG 10
BEFORE1  LA        2,2(2)         INCREASES INPUT POINTER OVER OPCODE
         B         LOOKOPR        RETURNS TO ASSEMBLE DISPLACEMENT
ST       CLC       0(2,2),R+2     CHECKS FOR ST STATEMENT
         BNE       A              IF NOT, CHECKS FOR ADD STATEMENT
         IC        10,S+1         IF SO, PUTS HEX OPCODE IN REG. 10
L        B         BEFORE1        RETURNS TO ASSEMBLE DISPLACEMENT
A        CLC       0(1,2),R+4     CHECKS FOR ADD STATEMENT
         BNE       SUB            IF NOT, CHECKS FOR S STATEMENT
         IC        10,S+2         IF SO, PUTS HEX OPCODE IN REG. 10
BEFORE2  LA        2,1(2)         INCREASES INPUT POINTER OVER OPCODE
         B         LOOKOPR        RETURNS TO ASSEMBLE DISPLACEMENT
SUB      CLC       0(1,2),R+5     CHECKS FOR S STATEMENT
         BNE       MT             IF NOT, CHECKS FOR MT STATEMENT
         IC        10,S+3         IF SO, PUTS HEX OPCODE IN REG. 10
         B         BEFORE2        RETURNS TO ASSEMBLE DISPLACEMENT
MT       CLC       0(2,2),R+6     CHECKS FOR MT STATEMENT
         BNE       DV             IF NOT, CHECKS FOR DV STATEMENT
         IC        10,S+4         IF SO, PUTS HEX OPCODE IN REG. 10
         B         BEFORE1        RETURNS TO ASSEMBLE DISPLACEMENT
DV       CLC       0(2,2),R+8     CHECKS FOR DV STATEMENT
         BNE       GO             IF NOT, CHECKS FOR GO STATEMENT
         IC        10,S+5         IF SO, PUTS HEX OPCODE IN REG. 10
         B         BEFORE1        RETURNS TO ASSEMBLE DISPLACEMENT
GO       CLC       0(2,2),R+10    CHECK FOR GO STATEMENT
         BNE       RD1            IF NOT, CHECKS FOR RD1 STATEMENT
         IC        10,S+6         IF SO, PUTS HEX OPCODE IN REG. 10
         B         BEFORE1        RETURNS TO ASSEMBLE DISPLACEMENT
RD1      CLC       0(3,2),R+12    CHECKS FOR RD1 STATEMENT
         BNE       RD             IF NOT, CHECKS FOR RD STATEMENT
         IC        10,S+7         IF SO, PUTS HEX OPCODE IN REG. 10
         LA        2,3(2)         INCREASES INPUT POINTER PAST OPCODE
         B         LOOKOPR        RETURNS TO ASSEMBLE DISPLACEMENT
RD       CLC       0(2,2),R+15    CHECKS FOR RD STATEMENT
         BNE       WRT1           IF NOT, CHECKS FOR WRT1 STATEMENT
         IC        10,S+8         IF SO, PUTS HEX OPCODE IN REG. 10
         LA        2,2(2)         INCREASES INPUT POINTER PAST OPCODE
         B         LKOPRND        RETURNS TO ASSEMBLE DISPLACEMENT
WRT1     CLC       0(4,2),R+17    CHECKS FOR WRT1 STATEMENT
         BNE       WRT            IF NOT, CHECKS FOR WRT STATEMENT
         IC        10,S+9         IF SO, PUTS HEX OPCODE IN REG. 10
         LA        2,4(2)         INCREASES INPUT POINTER PAST OPCODE
         B         LOOKOPR        RETURNS TO ASSEMBLE DISPLACEMENT
WRT      CLC       0(3,2),R+21    CHECKS FOR WRT STATEMENT
         BNE       B              IF NOT, CHECKS FOR B STATEMENT
         IC        10,S+10        IF SO, PUTS HEX OPCODE IN REG. 10
         LA        2,3(2)         INCREASES INPUT POINTER PAST OPCODE
         B         LKOPRND        RETURNS TO ASSEMBLE DISPLACEMENT
B        CLC       0(1,2),R+24    CHECKS FOR B STATEMENT
         BNE       YIELD          IF NOT, CHECKS FOR YIELD STATEMENT
HIGH2    LA        2,1(2)         IF SO, INCR. INPUT PTR. PAST OPCODE
         CLC       0(1,2),=C' '   CHECKS FOR OPERAND
         BE        HIGH2          IF NOT, RETURNS TO CHECK NEXT COLUMN
         LA        10,0(3)        IF SO, PUT ADD. OF LABEL TABLE IN 10
         LA        6,3            COUNTER OF OPERANDS THAT WILL DECRES
         LA        11,LA          ADD. OF STORAGE FOR L1 IN REG. 11
         LA        8,0(4)         ADD. OF LOC. CTR. TABLE IN REG. 8
HIGH4    CLC       0(2,2),0(3)    COMPARES L1 TO LABEL TABLE
         BE        HIGH3          WHEN LABEL IS FOUND, BRANCH
         LA        3,2(3)         IF NOT, INCREASE PTR. TO NEXT LABEL
         LA        4,4(4)         INCREASE PTR. TO NEXT LOC. CTR.
         B         HIGH4          RETURN FOR NEXT COMPAARISON
*                                 COMES HERE WHEN FINDS LABEL
HIGH3    MVC       0(2,11),2(4)   MOVES VALUE OF LOCATION INTO LA
         LA        2,3(2)         IMCREASES INPUT POINTER TO NEXT OPER
         LA        11,2(11)       ADD. OF STORAGE FOR L2 IN REG. 11
         LA        3,0(10)        RESETS LABEL TABLE POINTER
         LA        4,0(8)          RESETS LOC. CTR. TABLE POINTER
         BCT       6,HIGH4        DECREASES COUNTER OF OPERANDS, CHECK
*                                      S AND BRANCHES TO EVALUATE NEXT
*                                      OPERAND.
         LH        6,LB           PUTS SECOND OPERAND IN REG. 6
         LH        7,LC           PUTS THIRD OPERAND IN REG. 7
         SLL       7,20           MOVES THIRD OPERAND TO LEFT PART OF7
         SLDL      6,12           MOVES SECOND AND THIRD INTO REG.6
         ST        6,NUM
         LA        10,BRNCH       LOADS REG. 10 WITH STORAGE FOR MACHI
*                                      NE CODE OF B STATEMENT
         MVC       0(1,10),S+11   PUTS HEX OPCODE INTO FIRST BYTE OF
*                                      THE MACHINE CODE STORAGE LOCATI
         MVC        3(3,10),NUM+1 STORES SECOND AND THIRD OPERAND LOCA
*                                      TIONS STARTING AT FOURTH BYTE
         MVC       1(2,10),LA     STORES FIRST OPRND. LOC. AT SECOND
*                                      BYTE
*                  THIS SECTION CHECKS LOC. CTR. FOR HALFWORD BOUNDARY
         LR        6,5
         SRL       5,1
         SLL       5,1
         CR        6,5
         BE        HIGH5
         A         5,=F'2'
*                  GETS HERE WHEN LOCATION COUNTER IS SET
HIGH5    LA        7,MEMORY(5)    LOADS REG. 7 WITH ADDRESS OF MEMORY
*                                   WHERE MACHINE CODE WILL GO
         MVC       0(6,7),0(10)   PUTS MACHINE CODE INTO MEMORY
         A         5,=F'6'        INCREASES POINTER IN MEMORY
         B         DONE           BRANCHES TO OUTPUT STATEMENTS
YIELD    CLC       0(5,2),R+25    CHECKS FOR YIELD STATEMENT
         BNE       DS             IF NOT. CHECKS FOR DS STATEMENT
*                                 THIS SECTION MAKES SURE LOCATION COU
*                                      NTER IS ON HALFWORD BOUNDARY
         LR        6,5
         SRL       5,1
         SLL       5,1
         CR        6,5
         BE        HIGH6
         A         5,=F'2'
*                  GETS HERE WHEN LOCATION COUNTER IS SET
HIGH6    LA        7,MEMORY(5)    LOADS REG. 7 WITH ADD. OF MEMORY WHE
*                                      RE MACHINE CODE WILL GO
         MVC       0(2,7),S+12    PUTS MACHINE CODE INTO MEMORY
         A         5,=F'2'        INCREASES POINTER IN MEMORY
         B         DONE           BRANCHES TO OUTPUT STATEMENTS
DC       CLC       0(2,2),R+30    CHECKS FOR DC STATEMENT
         BNE       DS             IF NOT, CHECKS FOR DS STATEMENT
         LA        2,2(2)         OF SO INCREASES INPUT PTR. PAST OPCD
DC2      CLC       0(1,2),=C' '   CHECKS FOR OPERAND
         BNE       DC1            BRANCHES WHEN FINDS OPERAND
         LA        2,1(2)         INCREASES INPUT PTR.
         B         DC2            RETURNS TO CHECK FOR OPERAND
DC1      CLC       0(1,2),=C'C'   CHECKS FOR A "C" IN OPERAND
         BNE       DC3            IF NOT, CHECKS FOR A "F"
         LA        2,1(2)         IOF SO, INCREASES PAST THE "C"
         SR        6,6            CLEARS A REGISTER THAT WILL BE A POI
*                                 NTER IN AN AREA OF STORAGE THAT WILL
*                                 CONTAIN THE CHARACTERS WITHIN THE "S
         LA        2,1(2)         INCREASES INPUT PTR. PAST THE QUOTE
DC5      LA        7,MEMORY(5)    LOADS REG. M WITH ADDRESS OF MEMORY
*                                      WHERE MACHINE CODE WILL GO.
         MVC       0(1,7),0(2)    PUTS FIRST CHARACTER IN MEMORY
         LA        10,DFCNST(6)   LOADS REG. 10 WITH ADDRESS OF STORAG
*                                      E WHERE CHARACTERS WILL BE STOR
         MVC       0(1,10),0(2)   PUTS FIRST CHARACTER INTO STORAGE
         A         6,=F'1'        INCREASES STORAGE POINTER
         A         5,=F'1'        INCREASES MEMORY POINTER
         LA        2,1(2)         INCREASES INPUT POINTER
         CLC       0(1,2),=X'7D'  CHECKS FOR QUOTE
         BNE       DC5            IF NOT, RETURNS TO INSERT CHARACTER
         B         DONE           IF SO, BRANCHES TO OUTPUT
DC3      CLC       0(1,2),=C'F'   CHECKS FOR A "F"
         BNE       OUTDC          IF NOT, BRANCHES TO PRINT ERROR.
         LA        2,2(2)         IF SO, INCREASES INPUT PTR. PAST QUO
DC6      IC        10,0(2)        PUTS FIRST CHARACTER IN REG. 10
         LA        2,1(2)         INCREASES TO NEXT INPUT CHARACTER
         CLC       0(1,2),=X'7D'  CHECKS FOR A QUOTE
         BE        DC8            IF SO, BRANCHES TO INSERT IN MEMORY
         SLL       10,4           IF NOT, MOVES VALUE IN 10 TO THE LEF
*                                      T TO MAKE ROOM FOR NEXT CHARATR
         B         DC6            BRANCHES TO INSERT NEXT CHARACTER
*        THIS SECTION MAKES SURE LOC. CTR. IS ON FULL WORD BOUNDARY
DC8      LR        6,5
         SRL       5,2
         SLL       5,2
         CR        6,5
         BE        DC7
         A         5,=F'4'
*                  GETS HERE WHEN LOCATION COUNTER IS SET
DC7      ST        10,MEMORY(5)   PITS FULLWORD CONSTANT IN MEMORY
         A         5,=F'4'        INCREASES LOCATION COUNTER
         B         DONE           BRANCHES TO OUTPUT
DS       CLC       0(2,2),R+32    CHECKS FOR DS STATEMENT
         BNE       END            IF NOT, CHECKS FOR END STATEMENT
         LA        2,2(2)         IF SO, INCREASES PAST OPCODE
DS1      CLC       0(1,2),=C' '   CHECKS FOR OPERAND
         BNE       OPCODS         BRANCHES WHEN FINDS OPERAND
         LA        2,1(2)         IF NOT, INCREASE INPUT POINTER
         B         DS1            RETURN TO CHECK FOR OPERAND
OPCODS   CLC       0(1,2),=C'C'   CHECKS FOR A "C"
         BNE       DS2            IF NOT, CHECKS FOR A "F"
         A         5,=F'1'        IF SO, INCREASES LOC. CTR. FOR TYE C
         B         DONE           BRAN HES TO OUTPUT
DS2      CLC       0(1,2),=C'F'   CHECKS FOR A "F"
         BNE       DS3            IF NOT, ASSUMES A VALUE
         LR        6,5            IF SO, CHECKS LOC. CTR. FOR FULLWORD
         SRL       5,2                 BOUNDARY
         SLL       5,2
         CR        6,5
         BE        DS4
         A         5,=F'4'
DS4      A         5,=F'4'        INCREASES LOC. CTR. FOR THE "F"
         B         DONE           BRANCHES TO OUTPUT
DS3      IC        10,0(2)        PUT FIRST VALUE IN REG 10
         LA        2,1(2)         INCREASES INPUT POINTER
         CLC       0(1,2),=C'Z'   CHECKS TO SEE IF INPUT IS ANOTHER NO
         BNH       DS5            IF NOT, BRANCHES TO CHECK FOR C &F
         SLL       10,8
         B         DS3            RETURNS TO INSERT VALUE
DS5      CLC       0(1,2),=C'C'   CHECKS FOR A "C"
         BNE       DS6            IF NOT, ASSUMES A "F"
         ST        10,CHANGE      IF SO, WE CHANGE THE VALUE TO
         XDECI     10,CHANGE           HEX FOR ADDING TO LOC. CTR.
         AR        5,10           ADDS VALUE TO LOC. CTR.
         B         DONE           BRANCHES TO OUTPTU
DS6      LR        6,5            MAKES SURE LOC. CTR. IS ON FULLWORD
         SRL       5,2            BOUNDARY FOR THE "F"
         SLL       5,2
         CR        6,5
         BE        DS7
         A         5,=F'4'
DS7      ST        10,CHANGE      CHANGES THE VALUE TO HEX
         XDECI     10,CHANGE           FOR ADDING TO THE LOC. CTR.
         SLL       10,2           MULTIPLIES VALUE BY 4 SINCE IT IS
*                                      THE NUMBER OF FULLWORDS
         AR        5,10           ADDS VALUE TO THE LOC. CTR.
         B         DONE           BRANCHES TO THE OUTPUT
END      B         FINISH
*                  THIS PART FINISHES MACHINE CODE FOR ALL OPCODES
*                                 EXCEPT READS, WRITES, DS, DC, END, B
*                                 , AND YIELD.
LOOKOPR  CLC       0(1,2),=C' '   CHECKS FOR OPERAND
         BNE       OPR1           BRANCHES WHEN FINDS OPERAND
         LA        2,1(2)         IF NOT, INCREASES INPUT POINTER
         B         LOOKOPR        RETURNS TO CHECK FOR OPERAND
OPR1     L         3,=V(LEGAL)
         L         4,=V(LOCTN)
OPR3     CLC       0(2,2),0(3)    CHECKS OPERAND WITH LABEL TABLE
         BE        OPR2           IF EQUAL, BRANCHES TO INSERT LOCATIO
         LA        3,2(3)         IF NOT, INCREASES TO NEXT LABEL
         LA        4,4(4)         INCREASES TO NEXT LOCATION
         B         OPR3           RETURNS TO COMPARE OPERAND
OPR2     SLL       10,24          MOVES HEXOPCODE TO PROPER POSITION
         LA        7,MEMORY(5)
         ST        10,NUM
         MVC       0(1,7),NUM
         MVC       2(2,7),2(4)
         MVC       1(1,7),=X'00'
         A         5,=F'4'        INCREASES LOC. CTR. BY 4
         B         DONE           BRANCHES TO OUTPUT
*                  THIS PART FINISHES MACHINE CODE FOR READS AND WRITE
LKOPRND  CLC       0(1,2),=C' '   CHECKS FOR OPERAND
         BNE       LK1            BRANCHES WHEN FINDS OPERAND
         LA        2,1(2)         IF NOT, INCREASES INPUT POINTER
         B         LKOPRND        RETURNS TO CHECK FOR OPERAND
LK1      L         3,=V(LEGAL)
         L         4,=V(LOCTN)
LK3      CLC       0(2,2),0(3)    CHECKS OPERAND WITH LABEL TABLE
         BE        LK2            IF EQUAL, BRANCHES TO CHECK LENGTH
         LA        3,2(3)         IF NOT, INCREASES TO NEXT LABEL
         LA        4,4(4)         INCREASES TO NEXT LOACTION
         B         LK3            RETURNS TO COMPARE OPERAND
LK2      LA        2,3(2)         INCREASE INPUT POINTER TO LENGTH
LK4      IC        7,0(2)         PUTS A NUMBER OF LENGTH INTO REG. 7
         LA        2,1(2)         INCREASES TO NEXT VALUE OF LENGTH
         CLC       0(1,2),=C' '   CHECKS TO SEE THAT THERE IS A VALUE
         BE        LK5            IF NOT, BRANCHES TO FINISH MACHINE C
         SLL       7,8
         B         LK4            RETURNS TO INSERT THE VALUE
LK5      ST        7,NUM+4
         PACK      NUM2(8),NUM1+4(4)
         L         7,NUM2+4
         SRL       7,4
         SLL       10,8
         AR        10,7           PUTS LENGTH IN REG. 10
         SLL       10,16          MOVES HEX OPCODE AND LENGTH TO MAKE
*                                      ROOM FOR DISPLACEMENT
         ST        10,MEMORY(5)   STORES MACHINE CODE IN MEMORY
         LA       7,MEMORY(5)
         MVC       1(1,7),=X'00'
         MVC       2(2,7),2(4)
         A         5,=F'4'        INCREASES LOC. CTR. BY 4
DONE     LA        9,40(9)        INCREASES INPUT PTR. TO NEXT CARD
         LA        2,0(9)         RESETS INPUT POINTER
         B         UP2            RETURNS TO DO PASS2 ON NEXT CARD
FINISH   XPRNT     CCT,59
         XDUMP     MEMORY,2000    PRINTS THE MACHINE CODE.
         L         13,SAVPAS2+4
         LM        14,12,12(13)
         BR        14
OUTDC    XPRNT     CCC,33
         B         DONE
ERROR    XPRNT     OCO,32
         B         DONE
        PRINT      ON
SAVPAS2  DS        18F
LA       DS        H
LB       DS        H
LC       DS        H
BRNCH    DS        3H
DFCNST   DS        33C
R        DC        C'LDSTASMTDVGORD1RDWRT1WRTBYIELDDCDSEND'
S        DC        X'4142515253541122213231131500'
NUM      DS        F
CHANGE   DS        F
NUM1     DS        D
NUM2     DS        D
CCC      DC        C'0***ERROR***   -  ILLEGAL OPERAND'
OCO      DC        C'0***ERROR***   -  ILLEGAL OPCODE'
         LTORG
CCT      DC        C'1THIS IS THE STORAGE FOR THE PROGRAM READ INTO '
         DC        C'THE COMPILER'
         DS        0F
MEMORY   DC        2000X'EE'
         END
$ENTRY
    RD1    M1
   RD1  N1
    WRT1    M1
     WRT1 N1
  LD  M1
     S         N1
    B  B1,B1,A1
A1: LD M1
  ST       T1
 LD N1
      ST    M1
  LD       T1
    ST  N1
B1:     LD  N1
   DV   M1
     MT     M1
   ST  Q2
    LD     N1
   S Q2
   B        B2,D1,B2
B2:     ST    T2
   LD M1
   ST   N1
       LD   T2
                ST        M1
       GO       B1
D1: WRT M5,31
       WRT1  M1
 YIELD
M1:   DS   1F
N1:    DS    1F
T1: DS 2F
T2:     DS     10F
M5:    DC  C'THE GREATEST COMMON'
     DC   C' DIVISOR IS:'
Q2:   DC    F'0'
                          END
##
$JOB   ASSIST  PROGTEST
*        *** SECOND IN SERIES OF RELATED PROGRAMS.
*        *** SIMILAR TO PREVIOUS PROGRAM - NOTE INCREASED SPACE
*        REQUIREMENTS DUE TO SEQUNCED CARD INPUT.
*        PROGRAM PRINTS TWO PAGES, EXECUTES 19508 INSTRUCTIONS, ABENDS
*        WITH 0C4 LIKE PREVIOUS PROGRAM.
*        PSU CMPSC 102 - SUMMER 1970 - FINAL PROJECT
MAIN     CSECT
         ENTRY     STORE
         ENTRY     COUNTER
         BALR      12,0
         USING     *,12
         ST        14,SAV14
         SR        4,4            POINTER IN ARRAY OF INPUT
         SR        5,5            COUNTER OF NUMBER OF CARDS READ.
         XPRNT     CONT,56        PRINTS LABEL FOR INPUT
TOP      XREAD     ARRAY,80       READS ALL OF INPUT CARDS
         CLC       ARRAY(2),=C'##'     LOOKS FOR FLAG CARD
         BE        BRPASS1
         XPRNT     CC,81          ECHO CHECKS ALL OF THE INPUT CARDS
         LA        3,STORE(4)     LOADS THE ADDRESS OF THE ARRAY
*                                      CONTAINING THE FIRST 40 COLUMNS
*                                      OF EACH INPUT CARD.
         MVC       0(40,3),ARRAY  PUTS FIRST 40 COLUMNS INTO THE ARRAY
         A         4,=F'40'       INCREASES POINTER IN THE ARRAY
         A         5,=F'1'        INCREASES THE CARD COUNTER
         B         TOP            RETURNS TO READ THE NEXT CARD
*                                 COMES HERE IF FLAG CARD IS READ
BRPASS1  ST        5,COUNTER      STORES THE CARD COUNTER
         L         15,=V(PASS1A)  LOADS ADDRESS OF CSECT BEIBG CALLED
         LA        13,SAVMAIN     LOADS REGISTER STORAGE LOCATION
         BALR      14,15          BRANCHES TO CSECT PASS1A
         L         14,SAV14
         B         14
SAV14    DS        F
CONT     DC        C'1THIS IS THE PROGRAM READ INTO THE PASS1, PASS2'
         DC        C'COMPILER'
CC       DC        C' '
ARRAY    DS        80C
COUNTER  DS        F
SAVMAIN  DS        18F
         LTORG
STORE    DS        1000F
PASS1A   CSECT
         ENTRY     LEGAL
         ENTRY     LOCTN
         STM       14,12,12(13)
         BALR      12,0
         USING     *,12
         ST        13,SAVPAS1A+4
         L         2,=V(STORE)    LOADS ADDRESS OF STORAGE INTO
         L         3,=V(STORE)    REGISTERS 2 AND 3
         SR        4,4            FLAG REGISTER FOR ERRORS.
         SR        7,7            POINTER IN LABEL TABLE.
         SR        9,9            POINTER  IN LOCATION COUNTER TABLE.
         SR        10,10          LOCATION COUNTER REGISTER
TOP1A    CLC       0(1,2),=C' '   CHECKS FOR A LABEL.
         BE        NOLABEL
         SR        6,6
         CLC       0(1,2),=C'A'   CHECKS FOR LEGALITY OF LABEL
         BL        ILLEGAL        IF CONDITIONS ARE NOT MET, BRANCH TO
         CLC       0(1,2),=C'Z'        PRINT ERROR STATEMENT
         BH        ILLEGAL
         CLC       1(1,2),=C'1'
         BL        ILLEGAL
         CLC       2(2,2),=C': '
         BNE       ILLEGAL
*                                 GET HERE IF LEGAL LABEL CONDITIONS A
*                                      RE MET.
         LA        8,LEGAL(7)     LOADS ADDRESS OF NEXT ENTRY POINT FO
*                                      R A LEGAL LABEL.
UP1A     LA        5,LEGAL(6)     LOADS ADDRESS OF LABEL TO BE COMPARE
         CLC       0(2,2),0(5)    COMPARES INPUT LABEL TO LABEL TABLE
         BE        DUPLAB         IF EQUAL, BRANCHES TO PRINT ERROR.
         A         6,=F'2'        INCREASES POINTER TO NEXT LABEL.
         CR        7,6            CHECKS FOR END OF LABEL TABLE.
         BH        UP1A
         MVC       0(2,8),0(2)    PUTS INPUT LABEL INTO TABLE.
         SR        6,6
REG6     C         6,=F'0'        CHECKS FLAG REGISTER
         BE        RG6            BRANCHES IF EQUAL
         LR        8,10           SAVE LOCATION COUNTER
         CVD       10,AN          CHANGES LOC. CTR. TP DECIMAL
         UNPK      ANY(8),AN+4(4) UNPACKS LOC. CTR.
         L         10,ANY+4       PUTS LOC. CTR. IN REG. 10
         A         10,=F'48'      CHANGES SIGN FROM A C TO A F
         L         11,PTR         LOADS PTR. OF LOCATION TABLE
*                                      CORRESPONDING TO THE INPUT
         ST        10,LTN(11)     PUTS BASE 10 LOOKING LOC. CTR. IN TB
         A         11,=F'4'       INCREASES PTR. IN TABLE
         ST        11,PTR         SAVES POINTER
         LR        10,8           RESTORES LOCATION COUNTER
*                                 THIS SECTION CHECKS FLAG REGISTER
*                                      AND RETURNS TO PROPER POINT.
         C         6,=F'1'
         BE        LL
         C         6,=F'2'
         BE        LL1
         C         6,=F'3'
         BE        LL2
         C         6,=F'4'
         BE         LL3
         B         LL4
*                  THIS PART INSERTS LOCATION COUNTER INTO TABLE
*                                 CORRESPONDING TO LABEL INSERTED.
RG6      LR        11,10
         LR        8,10           SAVES LOCATION COUNTER
         SR        10,10          CLEARS REG. SO THAT IT WILL CONTAIN
*                                      REMAINDER AFTER DIVISION
         D         10,=F'10'      DIVIDES LOC. CTR. BY 10
         ST        10,LC1         SAVES THE REMAINDER
         SR        10,10          CLEARS REG. 10 FOR NEXT REMAINDER
         D         10,=F'10'      DIVIDES LOC. CTR. BY 10 AGAIN
         ST        10,LC2         SAVES THE REMAINDER
         SLL       11,8           MULTIPLIES VALUE IN 11 BY 256
         ST        11,LC3         STORES RESULT IN LC3
         L         11,LC2         PUTS SECOND REMAINDER IN REG. 11
         SLL       11,4           MULTIPLIES IT BY 16
         L         10,LC1         PUTS FIRST REMAINDER IN REG. 10
         AR        10,11          ADDS PARTS OF NEW LOC.CTR.
         A         10,LC3         ADDS REST OF NEW LOC. CTR.
NO       ST        10,LOCTN(9)
         LR        10,8           RESTORES LOC. CTR.
         LA        7,2(7)         INCREASES LABEL TABLE POINTER.
         LA        9,4(9)         INCREASES LOCATION COUNTR TABLE PTR.
         LA        2,4(2)          INCREASE INPUT POINTER.
*        COMES HERE IF THERE IS NO LABEL AND LOOKS FOR THE OPCODE.
NOLABEL  CLC       0(1,2),=C' '   CHECKS FOR OPCODE
         BNE       LOOK           BRANCHES WHEN FINDS OPCODE
         LA        2,1(2)              INCREASES INPUT POINTER
         B         NOLABEL        RETURNS AND CHECKS FOR OPCODE
*                  COMES HERE IF OPCODE IS FOUND.
LOOK     CLC       0(1,2),MCODE   CHECKS FOR A BRANCH STATEMENT
         BNE       LOOK1          IF NOT BRANCHES AND CHECKS FOR YIELD
         LA        6,1            SETS UP A FLAG REGISTER
         B         REG6           BRANCHES TO CHANGE LOC. CTR.
LL       A         10,=F'6'       ADDS 6 TO LOC. CTR. FOR BRANCH
         B         CLEANUP        BRANCHES TO PREPARE FOR NEW INPUT
LOOK1    CLC       0(1,2),MCODE+1 CHECKS FOR A YIELD STATEMENT
         BNE       LOOK2          IF NOT, BRANCHES AND CHECKS FOR DC.
         LA        6,2            SETS UP A FLAG REGISTER
         B         REG6           BRANCHES TO CHANGE LOC. CTR.
LL1      A         10,=F'2'       ADDS 2 TO LOC. CTR. FOR YIELD
         B         CLEANUP        BRANCHES TO PREPARE FOR NEW INPUT
LOOK2    CLC       0(2,2),MCODE+6 CHECKS FOR DC STATEMENT
         BNE       LOOK3          IF NOT, BRANCHES AND LOOKS FOR DS
         LA        2,2(2)         IF SO, INCREASES INPUT PTR. PAST OPC
OUT1A    CLC       0(1,2),=C' '   CHECKS FOR OPERAND
         BNE       OUT            BRANCHES WHEN FINDS OPEFAND
         LA        2,1(2)         IF NOT, INCREASE INPUT PTR.
         B         OUT1A          RETURNS AND CHECKS FOR OPERAND
*                                 GETS HERE WHEN FINDS OPERAND
OUT      CLC       0(1,2),=C'C'    LOOKS FOR A "C"
         BNE       FULLWORD       IF NOT, ASSUMES A "F"
         LA        2,2(2)         INCREASES INPUT POINTER PAST QUOTE
         SR        5,5            SETS UP COUNTER OF NO. OF CHARACTERS
OUTADD   CLC       0(1,2),=X'7D'  SEARCHES FOR SECOND QUOTE.
         BE        ADD            IF FOUND, ADDS NUMBER TO LOC. CTR.
         A         5,=F'1'        ADDS 1 TO CHARACTER COUNTER
         LA        2,1(2)         INCREASES INPUT POINTER.
         B         OUTADD         RETURNS AND LOOKS FOR QUOTE.
ADD      LA        6,3            SETS UP A FLAG REGISTER
         B         REG6           BRANCHES TO CHANGE LOC. CTR.
LL2      AR        10,5           ADDS VALUE CALCULATED IN REG 5 TO
*                                      LOCATION COUNTER
         B         CLEANUP         BRANCHES TO PREPARE FOR NEW INPUT.
FULLWORD LR        11,10          SAVES LOCATION COUNTER.
*                                 THIS PART IS FOR A DC FULLWORD.
FULWD1A  SRL       10,2           CHECKS LOC. CTR. FOR FULLWORD
         SLL       10,2           BOUNDARY
         CR        11,10
         BE        FULL1A         IF ON A FULLWORD, ADDS TO LOC. CTR.
         A         10,=F'4'       PUTS LOC. CTR. ON A FULLWORD BNDARY.
FULL1A   LA        6,4
         B         REG6
LL3      A         10,=F'4'       ADDS 4 TO LOC. CTR. FOR FULLWORD
*                                      INSTRUCTION OR CONSTANT
         B         CLEANUP        BRANCHES TO PREPARE FOR NEW INPUT
LOOK3    CLC       0(2,2),MCODE+8 CHECKS FOR DS STATEMENT
         BNE       LOOK4          IF NOT, CHECKS FOR END STATEMENT
         LA        2,2(2)         IF SO, INCREASE INPUT PTR. PAST OPCO
CHECK1A  CLC       0(1,2),=C' '   CHECKS FOR OPERAND
         BNE       CHECK          BRANCHES WHEN FINDS OPERAND
         LA        2,1(2)         IF NOT, INCREASES INPUT PTR.
         B         CHECK1A        RETURNS TO CHECK FOR OPERAND
*                                 GETS HERE WHEN FINDS OPERAND.
CHECK    CLC       0(1,2),=C'C'   CHECKS FOR A "C"
         BNE       MOVE            IF NOT, BRANCHES TO CHECK FOR A "F"
         LA        6,5            SETS UP A FLAG REGISTER
         B         REG6           BRANCHES TO CHANGE LOC. CTR.
LL4      A         10,=F'1'       ADDS 1 TO LOC. CTR. FOR CONSTANT
         B         CLEANUP        BRANCHES TO PREPARE FOR NEW INPUT.
MOVE     CLC       0(1,2),=C'F'   LOOKS FOR A "F"
         BNE       SEARCH         IF NOT, ASSUMES A NUMBER.
         B         FULWD1A
SEARCH   SR        5,5            REGISTER USED TO CONTAIN NUM BER
SEARCH1   IC       5,0(2)         PUTS FIRST NUMBER INTO REGISTER
         LA        2,1(2)         INCREASES INPUT COUNTER
         CLI       0(2),C'Z'      CHECKS TO SEE IF NEXT COLUMN IS A NO
         BNH       DETER          IF NOT, CHECKS FOR "C" OR "F"
         SLL       5,8            IF SO, MAKES ROOM IN REGISTER FOR IT
         B         SEARCH1         RETURNS TO INSERT THE NUMBER
DETER    CLI       0(2),C'C'      CHECKS FOR A "C"
         BNE       DETERF         IF NOT, ASSUMES A "F"
         ST        5,AN+4         STORES THE NUMBER
         PACK      ANY(8),AN+4(4) PACKES NUMBER
          CVB       5,ANY         CHANGES THE NUMBER TO BINARY
         B         ADD            BRANCHES TO PRINT SECTION
DETERF   ST        5,AN+4         STORES THE NUMBER
         PACK      ANY(8),AN+4(4) PACKES NUMBER
         CVB       5,ANY          CHANGES THE NUMBER TO BINARY
         SLL       5,2                 MULTIPLIES IT BY 4 SINCE IT IS
*                                 THE NUMBER OF FULLWORDS
DTRF     LR        11,10
        SRL        10,2
         SLL       10,2
         CR        11,10
         BE        ADD
         A         10,=F'4'
          B          ADD
LOOK4    CLC       0(3,2),MCODE+10 CHECKS FOR END STATEMENT
         BE        ENDF           IF SO BRANCHES TO COMPLETE PASS1
         LR        11,10
         SRL       10,1
         SLL       10,1
         CR        11,10
         BE        FULL1A
         A         10,=F'2'
         B         FULL1A
CLEANUP  LA        3,40(3)        MOVES POINTER OF INPUT TO NEXT CARD
         LA        2,0(3)         PUTS THIS ADDRESS INTO REGISTER 2
         B         TOP1A          RETURNS TO EVALUATED NEXT CARD
ILLEGAL  XPRNT     CCO,31         PRINTS ERROR STATEMENT FOR ILLEGAL
*                                      LABEL
         A         4,=F'1'        PUTS A VALUE INTO FLAG REGISTERSO
*                                      THAT WHEN WE ARE DONE WITH PASS
*                                      1 WE WILL RETURN TO MAIN PROGRA
*                                      M INSTEAD OF GOING TO PASS2
         B         NOLABEL        BRANCHES TO EVALUATE OPCODE FOR CARD
DUPLAB   XPRNT     COC,33         PRINTS ERROR FOR DUPLICATE LAVEL
         A         4,=F'1'        SAME AS ABOVE
         B         NOLABEL        SAME AS ABOVE
ENDF     LA        7,TABLE        LOADS ADD. OF STORAGE THAT WILL CONT
*                                      AIN LOCATION AND INPUT
         L         2,=V(STORE)    LOADS ADDRESS OF INPUT
         LA        3,LTN          LOADS ADD. OF LOCATION TABLE
         L         5,=V(COUNTER)  LOADS ADD. OF NUMBER OF CARDS
         L         6,0(5)         LOADS NUMBER OF CARDS
         S         6,=F'1'        SUBTRACTS 1 CAUSE END STATEMENT IS
*                                      NOT IN THIS PART.
         XPRNT     CNT,20
         XPRNT     CTN,32
EN       MVC       0(4,7),0(3)    PUTS LOCATION INTO STORAGE
         MVC       8(40,7),0(2)   PUTS INPUT CARD INTO STORAGE
         XPRNT     TABLE-1,49     PRINTS LOCATION AND INPUT
         LA        2,40(2)        INCREASES TO NEXT CARD
         LA        3,4(3)         INCREASES TO NEXT LOCATION
         BCT       6,EN           CHECKS NUMBER OF CARDS AND BRANCHES
         LA        1,ADDPASS1     IF NO ERROR, WE LOAD THE ADRESSES OF
*                                      OF THE LABEL TABLE AND THE LOC.
*                                      CTR. TABLE
         LA        13,SAVPAS1A    LOAD THE ADDRESS OF THE STORAGE LOC.
*                                      FOR PASS1 REGISTERS.
         L         15,=V(PASS2)   LOAD PASS2 CSECT
         BALR      14,15          BRANCH TO PASS2
RETURN   L         13,SAVPAS1A+4   LOADS ADDRESS OF MAIN PROGRAM REG.
         LM        14,12,12(13)    RESTORES MAIN PROGRAM REGISTERS
         BR        14             BRANCHES BACK TO MAIN PROGRAM
LEGAL    DS        30H
LOCTN    DS        30F
MCODE    DC        C'BYIELDDCDSEND'
NUMBER   DS        F
AN       DS        D
ANY      DS        D
CCO      DC        C'0***ERROR***   -  ILLEGAL LABEL'
COC      DC        C'0***ERROR***   -  DUPLICATE LABEL'
SAVPAS1A DS        18F
ADDPASS1 DC        A(LEGAL)
         DC        A(LOCTN)
LC1      DS        F
LC2      DS        F
LC3      DS        F
CNT      DC        C'1THIS IS A TABLE OF:'
CTN      DC        C'0LOCATION                  INPUT'
         DC        C'    '
TABLE    DC        12F'0'
PTR      DC        F'0'
LTN      DS        500F
         LTORG
PASS2    CSECT
         STM       14,12,12(13)
         BALR      12,0
         USING     *,12
         ST        13,SAVPAS2+4
         LM        3,4,0(1)       LOADS ADDRESS OF LABEL TABLE IN REG3
*                                 PUT ADD. OF LOC. CTR. TABLE IN REG 4
         L         2,=V(STORE)    PUTS ADDRESS OF INPUT IN REG. 2
         LA        9,0(2)         PUTS ADDRESS OF INPUT IN REG. 9
         SR        5,5            POINTER IN MEMORY FOR MACHINE CODE
UP2      SR        10,10          CLEARED TO CONTAIN MACHINE CODE
         CLC       0(1,2),=C' '   CHECKS FOR A LABEL
         BE        OVERPAS2       IF NOT, BRANCHES TO CHECK FOR IPCODE
         LA        2,3(2)         IF SO, BRANCHES OVER LABEL
OVERPAS2 LA        2,1(2)         INCREASES INPUT POINTER
         CLC       0(1,2),=C' '   CHECKS FOR OPCODE
         BE        OVERPAS2       IF NOT, RETURN TO REPEAT SEARCH
         CLC       0(2,2),R       IF SO CHECKS FOR LD STATEMENT
         BNE       ST             IF NOT LD, CHECKS FOR ST STATEMENT
         IC        10,S           IF LD, PUTS HEX OPCODE IN REG 10
BEFORE1  LA        2,2(2)         INCREASES INPUT POINTER OVER OPCODE
         B         LOOKOPR        RETURNS TO ASSEMBLE DISPLACEMENT
ST       CLC       0(2,2),R+2     CHECKS FOR ST STATEMENT
         BNE       A              IF NOT, CHECKS FOR ADD STATEMENT
         IC        10,S+1         IF SO, PUTS HEX OPCODE IN REG. 10
L        B         BEFORE1        RETURNS TO ASSEMBLE DISPLACEMENT
A        CLC       0(1,2),R+4     CHECKS FOR ADD STATEMENT
         BNE       SUB            IF NOT, CHECKS FOR S STATEMENT
         IC        10,S+2         IF SO, PUTS HEX OPCODE IN REG. 10
BEFORE2  LA        2,1(2)         INCREASES INPUT POINTER OVER OPCODE
         B         LOOKOPR        RETURNS TO ASSEMBLE DISPLACEMENT
SUB      CLC       0(1,2),R+5     CHECKS FOR S STATEMENT
         BNE       MT             IF NOT, CHECKS FOR MT STATEMENT
         IC        10,S+3         IF SO, PUTS HEX OPCODE IN REG. 10
         B         BEFORE2        RETURNS TO ASSEMBLE DISPLACEMENT
MT       CLC       0(2,2),R+6     CHECKS FOR MT STATEMENT
         BNE       DV             IF NOT, CHECKS FOR DV STATEMENT
         IC        10,S+4         IF SO, PUTS HEX OPCODE IN REG. 10
         B         BEFORE1        RETURNS TO ASSEMBLE DISPLACEMENT
DV       CLC       0(2,2),R+8     CHECKS FOR DV STATEMENT
         BNE       GO             IF NOT, CHECKS FOR GO STATEMENT
         IC        10,S+5         IF SO, PUTS HEX OPCODE IN REG. 10
         B         BEFORE1        RETURNS TO ASSEMBLE DISPLACEMENT
GO       CLC       0(2,2),R+10    CHECK FOR GO STATEMENT
         BNE       RD1            IF NOT, CHECKS FOR RD1 STATEMENT
         IC        10,S+6         IF SO, PUTS HEX OPCODE IN REG. 10
         B         BEFORE1        RETURNS TO ASSEMBLE DISPLACEMENT
RD1      CLC       0(3,2),R+12    CHECKS FOR RD1 STATEMENT
         BNE       RD             IF NOT, CHECKS FOR RD STATEMENT
         IC        10,S+7         IF SO, PUTS HEX OPCODE IN REG. 10
         LA        2,3(2)         INCREASES INPUT POINTER PAST OPCODE
         B         LOOKOPR        RETURNS TO ASSEMBLE DISPLACEMENT
RD       CLC       0(2,2),R+15    CHECKS FOR RD STATEMENT
         BNE       WRT1           IF NOT, CHECKS FOR WRT1 STATEMENT
         IC        10,S+8         IF SO, PUTS HEX OPCODE IN REG. 10
         LA        2,2(2)         INCREASES INPUT POINTER PAST OPCODE
         B         LKOPRND        RETURNS TO ASSEMBLE DISPLACEMENT
WRT1     CLC       0(4,2),R+17    CHECKS FOR WRT1 STATEMENT
         BNE       WRT            IF NOT, CHECKS FOR WRT STATEMENT
         IC        10,S+9         IF SO, PUTS HEX OPCODE IN REG. 10
         LA        2,4(2)         INCREASES INPUT POINTER PAST OPCODE
         B         LOOKOPR        RETURNS TO ASSEMBLE DISPLACEMENT
WRT      CLC       0(3,2),R+21    CHECKS FOR WRT STATEMENT
         BNE       B              IF NOT, CHECKS FOR B STATEMENT
         IC        10,S+10        IF SO, PUTS HEX OPCODE IN REG. 10
         LA        2,3(2)         INCREASES INPUT POINTER PAST OPCODE
         B         LKOPRND        RETURNS TO ASSEMBLE DISPLACEMENT
B        CLC       0(1,2),R+24    CHECKS FOR B STATEMENT
         BNE       YIELD          IF NOT, CHECKS FOR YIELD STATEMENT
HIGH2    LA        2,1(2)         IF SO, INCR. INPUT PTR. PAST OPCODE
         CLC       0(1,2),=C' '   CHECKS FOR OPERAND
         BE        HIGH2          IF NOT, RETURNS TO CHECK NEXT COLUMN
         LA        10,0(3)        IF SO, PUT ADD. OF LABEL TABLE IN 10
         LA        6,3            COUNTER OF OPERANDS THAT WILL DECRES
         LA        11,LA          ADD. OF STORAGE FOR L1 IN REG. 11
         LA        8,0(4)         ADD. OF LOC. CTR. TABLE IN REG. 8
HIGH4    CLC       0(2,2),0(3)    COMPARES L1 TO LABEL TABLE
         BE        HIGH3          WHEN LABEL IS FOUND, BRANCH
         LA        3,2(3)         IF NOT, INCREASE PTR. TO NEXT LABEL
         LA        4,4(4)         INCREASE PTR. TO NEXT LOC. CTR.
         B         HIGH4          RETURN FOR NEXT COMPAARISON
*                                 COMES HERE WHEN FINDS LABEL
HIGH3    MVC       0(2,11),2(4)   MOVES VALUE OF LOCATION INTO LA
         LA        2,3(2)         IMCREASES INPUT POINTER TO NEXT OPER
         LA        11,2(11)       ADD. OF STORAGE FOR L2 IN REG. 11
         LA        3,0(10)        RESETS LABEL TABLE POINTER
         LA        4,0(8)          RESETS LOC. CTR. TABLE POINTER
         BCT       6,HIGH4        DECREASES COUNTER OF OPERANDS, CHECK
*                                      S AND BRANCHES TO EVALUATE NEXT
*                                      OPERAND.
         LH        6,LB           PUTS SECOND OPERAND IN REG. 6
         LH        7,LC           PUTS THIRD OPERAND IN REG. 7
         SLL       7,20           MOVES THIRD OPERAND TO LEFT PART OF7
         SLDL      6,12           MOVES SECOND AND THIRD INTO REG.6
         ST        6,NUM
         LA        10,BRNCH       LOADS REG. 10 WITH STORAGE FOR MACHI
*                                      NE CODE OF B STATEMENT
         MVC       0(1,10),S+11   PUTS HEX OPCODE INTO FIRST BYTE OF
*                                      THE MACHINE CODE STORAGE LOCATI
         MVC        3(3,10),NUM+1 STORES SECOND AND THIRD OPERAND LOCA
*                                      TIONS STARTING AT FOURTH BYTE
         MVC       1(2,10),LA     STORES FIRST OPRND. LOC. AT SECOND
*                                      BYTE
*                  THIS SECTION CHECKS LOC. CTR. FOR HALFWORD BOUNDARY
         LR        6,5
         SRL       5,1
         SLL       5,1
         CR        6,5
         BE        HIGH5
         A         5,=F'2'
*                  GETS HERE WHEN LOCATION COUNTER IS SET
HIGH5    LA        7,MEMORY(5)    LOADS REG. 7 WITH ADDRESS OF MEMORY
*                                   WHERE MACHINE CODE WILL GO
         MVC       0(6,7),0(10)   PUTS MACHINE CODE INTO MEMORY
         A         5,=F'6'        INCREASES POINTER IN MEMORY
         B         DONE           BRANCHES TO OUTPUT STATEMENTS
YIELD    CLC       0(5,2),R+25    CHECKS FOR YIELD STATEMENT
         BNE       DS             IF NOT. CHECKS FOR DS STATEMENT
*                                 THIS SECTION MAKES SURE LOCATION COU
*                                      NTER IS ON HALFWORD BOUNDARY
         LR        6,5
         SRL       5,1
         SLL       5,1
         CR        6,5
         BE        HIGH6
         A         5,=F'2'
*                  GETS HERE WHEN LOCATION COUNTER IS SET
HIGH6    LA        7,MEMORY(5)    LOADS REG. 7 WITH ADD. OF MEMORY WHE
*                                      RE MACHINE CODE WILL GO
         MVC       0(2,7),S+12    PUTS MACHINE CODE INTO MEMORY
         A         5,=F'2'        INCREASES POINTER IN MEMORY
         B         DONE           BRANCHES TO OUTPUT STATEMENTS
DC       CLC       0(2,2),R+30    CHECKS FOR DC STATEMENT
         BNE       DS             IF NOT, CHECKS FOR DS STATEMENT
         LA        2,2(2)         OF SO INCREASES INPUT PTR. PAST OPCD
DC2      CLC       0(1,2),=C' '   CHECKS FOR OPERAND
         BNE       DC1            BRANCHES WHEN FINDS OPERAND
         LA        2,1(2)         INCREASES INPUT PTR.
         B         DC2            RETURNS TO CHECK FOR OPERAND
DC1      CLC       0(1,2),=C'C'   CHECKS FOR A "C" IN OPERAND
         BNE       DC3            IF NOT, CHECKS FOR A "F"
         LA        2,1(2)         IOF SO, INCREASES PAST THE "C"
         SR        6,6            CLEARS A REGISTER THAT WILL BE A POI
*                                 NTER IN AN AREA OF STORAGE THAT WILL
*                                 CONTAIN THE CHARACTERS WITHIN THE "S
         LA        2,1(2)         INCREASES INPUT PTR. PAST THE QUOTE
DC5      LA        7,MEMORY(5)    LOADS REG. M WITH ADDRESS OF MEMORY
*                                      WHERE MACHINE CODE WILL GO.
         MVC       0(1,7),0(2)    PUTS FIRST CHARACTER IN MEMORY
         LA        10,DFCNST(6)   LOADS REG. 10 WITH ADDRESS OF STORAG
*                                      E WHERE CHARACTERS WILL BE STOR
         MVC       0(1,10),0(2)   PUTS FIRST CHARACTER INTO STORAGE
         A         6,=F'1'        INCREASES STORAGE POINTER
         A         5,=F'1'        INCREASES MEMORY POINTER
         LA        2,1(2)         INCREASES INPUT POINTER
         CLC       0(1,2),=X'7D'  CHECKS FOR QUOTE
         BNE       DC5            IF NOT, RETURNS TO INSERT CHARACTER
         B         DONE           IF SO, BRANCHES TO OUTPUT
DC3      CLC       0(1,2),=C'F'   CHECKS FOR A "F"
         BNE       OUTDC          IF NOT, BRANCHES TO PRINT ERROR.
         LA        2,2(2)         IF SO, INCREASES INPUT PTR. PAST QUO
DC6      IC        10,0(2)        PUTS FIRST CHARACTER IN REG. 10
         LA        2,1(2)         INCREASES TO NEXT INPUT CHARACTER
         CLC       0(1,2),=X'7D'  CHECKS FOR A QUOTE
         BE        DC8            IF SO, BRANCHES TO INSERT IN MEMORY
         SLL       10,4           IF NOT, MOVES VALUE IN 10 TO THE LEF
*                                      T TO MAKE ROOM FOR NEXT CHARATR
         B         DC6            BRANCHES TO INSERT NEXT CHARACTER
*        THIS SECTION MAKES SURE LOC. CTR. IS ON FULL WORD BOUNDARY
DC8      LR        6,5
         SRL       5,2
         SLL       5,2
         CR        6,5
         BE        DC7
         A         5,=F'4'
*                  GETS HERE WHEN LOCATION COUNTER IS SET
DC7      ST        10,MEMORY(5)   PITS FULLWORD CONSTANT IN MEMORY
         A         5,=F'4'        INCREASES LOCATION COUNTER
         B         DONE           BRANCHES TO OUTPUT
DS       CLC       0(2,2),R+32    CHECKS FOR DS STATEMENT
         BNE       END            IF NOT, CHECKS FOR END STATEMENT
         LA        2,2(2)         IF SO, INCREASES PAST OPCODE
DS1      CLC       0(1,2),=C' '   CHECKS FOR OPERAND
         BNE       OPCODS         BRANCHES WHEN FINDS OPERAND
         LA        2,1(2)         IF NOT, INCREASE INPUT POINTER
         B         DS1            RETURN TO CHECK FOR OPERAND
OPCODS   CLC       0(1,2),=C'C'   CHECKS FOR A "C"
         BNE       DS2            IF NOT, CHECKS FOR A "F"
         A         5,=F'1'        IF SO, INCREASES LOC. CTR. FOR TYE C
         B         DONE           BRAN HES TO OUTPUT
DS2      CLC       0(1,2),=C'F'   CHECKS FOR A "F"
         BNE       DS3            IF NOT, ASSUMES A VALUE
         LR        6,5            IF SO, CHECKS LOC. CTR. FOR FULLWORD
         SRL       5,2                 BOUNDARY
         SLL       5,2
         CR        6,5
         BE        DS4
         A         5,=F'4'
DS4      A         5,=F'4'        INCREASES LOC. CTR. FOR THE "F"
         B         DONE           BRANCHES TO OUTPUT
DS3      IC        10,0(2)        PUT FIRST VALUE IN REG 10
         LA        2,1(2)         INCREASES INPUT POINTER
         CLC       0(1,2),=C'Z'   CHECKS TO SEE IF INPUT IS ANOTHER NO
         BNH       DS5            IF NOT, BRANCHES TO CHECK FOR C &F
         SLL       10,8
         B         DS3            RETURNS TO INSERT VALUE
DS5      CLC       0(1,2),=C'C'   CHECKS FOR A "C"
         BNE       DS6            IF NOT, ASSUMES A "F"
         ST        10,CHANGE      IF SO, WE CHANGE THE VALUE TO
         XDECI     10,CHANGE           HEX FOR ADDING TO LOC. CTR.
         AR        5,10           ADDS VALUE TO LOC. CTR.
         B         DONE           BRANCHES TO OUTPTU
DS6      LR        6,5            MAKES SURE LOC. CTR. IS ON FULLWORD
         SRL       5,2            BOUNDARY FOR THE "F"
         SLL       5,2
         CR        6,5
         BE        DS7
         A         5,=F'4'
DS7      ST        10,CHANGE      CHANGES THE VALUE TO HEX
         XDECI     10,CHANGE           FOR ADDING TO THE LOC. CTR.
         SLL       10,2           MULTIPLIES VALUE BY 4 SINCE IT IS
*                                      THE NUMBER OF FULLWORDS
         AR        5,10           ADDS VALUE TO THE LOC. CTR.
         B         DONE           BRANCHES TO THE OUTPUT
END      B         FINISH
*                  THIS PART FINISHES MACHINE CODE FOR ALL OPCODES
*                                 EXCEPT READS, WRITES, DS, DC, END, B
*                                 , AND YIELD.
LOOKOPR  CLC       0(1,2),=C' '   CHECKS FOR OPERAND
         BNE       OPR1           BRANCHES WHEN FINDS OPERAND
         LA        2,1(2)         IF NOT, INCREASES INPUT POINTER
         B         LOOKOPR        RETURNS TO CHECK FOR OPERAND
OPR1     L         3,=V(LEGAL)
         L         4,=V(LOCTN)
OPR3     CLC       0(2,2),0(3)    CHECKS OPERAND WITH LABEL TABLE
         BE        OPR2           IF EQUAL, BRANCHES TO INSERT LOCATIO
         LA        3,2(3)         IF NOT, INCREASES TO NEXT LABEL
         LA        4,4(4)         INCREASES TO NEXT LOCATION
         B         OPR3           RETURNS TO COMPARE OPERAND
OPR2     SLL       10,24          MOVES HEXOPCODE TO PROPER POSITION
         LA        7,MEMORY(5)
         ST        10,NUM
         MVC       0(1,7),NUM
         MVC       2(2,7),2(4)
         MVC       1(1,7),=X'00'
         A         5,=F'4'        INCREASES LOC. CTR. BY 4
         B         DONE           BRANCHES TO OUTPUT
*                  THIS PART FINISHES MACHINE CODE FOR READS AND WRITE
LKOPRND  CLC       0(1,2),=C' '   CHECKS FOR OPERAND
         BNE       LK1            BRANCHES WHEN FINDS OPERAND
         LA        2,1(2)         IF NOT, INCREASES INPUT POINTER
         B         LKOPRND        RETURNS TO CHECK FOR OPERAND
LK1      L         3,=V(LEGAL)
         L         4,=V(LOCTN)
LK3      CLC       0(2,2),0(3)    CHECKS OPERAND WITH LABEL TABLE
         BE        LK2            IF EQUAL, BRANCHES TO CHECK LENGTH
         LA        3,2(3)         IF NOT, INCREASES TO NEXT LABEL
         LA        4,4(4)         INCREASES TO NEXT LOACTION
         B         LK3            RETURNS TO COMPARE OPERAND
LK2      LA        2,3(2)         INCREASE INPUT POINTER TO LENGTH
LK4      IC        7,0(2)         PUTS A NUMBER OF LENGTH INTO REG. 7
         LA        2,1(2)         INCREASES TO NEXT VALUE OF LENGTH
         CLC       0(1,2),=C' '   CHECKS TO SEE THAT THERE IS A VALUE
         BE        LK5            IF NOT, BRANCHES TO FINISH MACHINE C
         SLL       7,8
         B         LK4            RETURNS TO INSERT THE VALUE
LK5      ST        7,NUM+4
         PACK      NUM2(8),NUM1+4(4)
         L         7,NUM2+4
         SRL       7,4
         SLL       10,8
         AR        10,7           PUTS LENGTH IN REG. 10
         SLL       10,16          MOVES HEX OPCODE AND LENGTH TO MAKE
*                                      ROOM FOR DISPLACEMENT
         ST        10,MEMORY(5)   STORES MACHINE CODE IN MEMORY
         LA       7,MEMORY(5)
         MVC       1(1,7),=X'00'
         MVC       2(2,7),2(4)
         A         5,=F'4'        INCREASES LOC. CTR. BY 4
DONE     LA        9,40(9)        INCREASES INPUT PTR. TO NEXT CARD
         LA        2,0(9)         RESETS INPUT POINTER
         B         UP2            RETURNS TO DO PASS2 ON NEXT CARD
FINISH   XPRNT     CCT,59
         XDUMP     MEMORY,2000    PRINTS THE MACHINE CODE.
         L         13,SAVPAS2+4
         LM        14,12,12(13)
         BR        14
OUTDC    XPRNT     CCC,33
         B         DONE
ERROR    XPRNT     OCO,32
         B         DONE
SAVPAS2  DS        18F
LA       DS        H
LB       DS        H
LC       DS        H
BRNCH    DS        3H
DFCNST   DS        33C
R        DC        C'LDSTASMTDVGORD1RDWRT1WRTBYIELDDCDSEND'
S        DC        X'4142515253541122213231131500'
NUM      DS        F
CHANGE   DS        F
NUM1     DS        D
NUM2     DS        D
CCC      DC        C'0***ERROR***   -  ILLEGAL OPERAND'
OCO      DC        C'0***ERROR***   -  ILLEGAL OPCODE'
         LTORG
CCT      DC        C'1THIS IS THE STORAGE FOR THE PROGRAM READ INTO '
         DC        C'THE COMPILER'
         DS        0F
MEMORY   DC        2000X'EE'
         END
$ENTRY
    RD1    M1
   RD1  N1
    WRT1    M1
     WRT1 N1
  LD  M1
     S         N1
    B  B1,B1,A1
A1: LD M1
  ST       T1
 LD N1
      ST    M1
  LD       T1
    ST  N1
B1:     LD  N1
   DV   M1
     MT     M1
   ST  Q2
    LD     N1
   S Q2
   B        B2,D1,B2
B2:     ST    T2
   LD M1
   ST   N1
       LD   T2
                ST        M1
       GO       B1
D1: WRT M5,31
       WRT1  M1
 YIELD
M1:   DS   1F
N1:    DS    1F
T1: DS 2F
T2:     DS     10F
M5:    DC  C'THE GREATEST COMMON'
     DC   C' DIVISOR IS:'
Q2:   DC    F'0'
                          END
##
$JOB   ASSIST  PROGTEST
*        PSU CMPSC 102 - SUMMER 1970 - FINAL PROJECT
*        *** THIRD IN SERIES OF RELATEC PROGRAMS.
*        *** ILLUSTRATES SPEED DIFFERENCE IF PRINT TURNED OFF,
*        *** COMPARE WITH PREVIOUS PROGRAM.
*        *** ALSO ILLUSTRATES EXECUTION TIME ERROR.
*        PRINTS ABOUT THREE PAGES OF OUPUT, EXECUTES 15394 INSTRU TS.
*        THEN TERMINATES WITH 0C4 ERROR.
MAIN     CSECT
*      DOROTHY GRIFFITHS
*    CS 102.1  TERM PROJECT
         PRINT OFF
         BALR      11,0
         USING     BASE,11,12
BASE     L         12,ADCON
         ST        14,SAV14
         SR        3,3
RUN      XPRNT     =CL13'1THE INPUT IS',13
         SR        2,2
LOOP1    XREAD     INPUT1,80
         XPRNT     CC1,81         PRINT OUT INPUT1
         LA        9,INPUT1       PUT ADDRESS ON INPUT1 IN 9
         LA        10,MEMO(2)     INPUT CONTAINS LABEL OF CARD READ
         MVC       0(40,10),0(9)  MOVE THE INPUT INTO SRORAGE ARRAY
         LA        2,40(2)        INCREASE INDEX TO MEMO
         CLC       INPUT1(2),=C'##' TEST IF LAST CARD WAS READ
         BNE       LOOP1          START READING A NEW DATA CARD
         LA        1,JOBADD       PUT ADDRESS OF ARRAYS TO BE MOVED
         L         15,=V(PASS1)   PUT ENTRANCE POINT IN 15
         LA        13,SAVMAIN     PUT ADDRESS OF SAVE AREA IN 13
         BALR      14,15          BRANCK
         LA        1,JOBADD
         L         15,=V(PASS2)
         BALR      14,15
         XDUMP     OPTAB,1000
         LA        3,1(3)
         C         3,=F'3'
         BE        COMPLET
         MVI       TABLE,X'00'
         MVC       TABLE+1(200),TABLE
         MVI       OPTAB,X'EE'
         MVC       OPTAB+1(240),OPTAB
         B         RUN
COMPLET  L         14,SAV14
         BR        14
SAV14    DS        F
ADCON    DC        A(BASE+4096)
MEMO     DC        2000X'EE'
TABLE    DC        100H'0'
ADTAB    DS        100F
         DS        3C
CC1      DC        C'0'
INPUT1   DS        80C
JOBADD   DC        A(MEMO)
         DC        A(ADTAB)
         DC        A(TABLE)
         DC        A(OPTAB)
OPTAB    DC        2000X'EE'
SAVMAIN  DS        18F
         LTORG
PASS1    CSECT
         STM       14,12,12(13)
         BALR      11,0
         USING     BASE1,11,12
BASE1    L         12,ADCON1
         ST        13,SAVPAS1+4
         LM        2,5,0(1)
        SR    9,9
        ST    9,LOC
TOP      MVC       INPUT(40),0(2) PUT MEMO IN HERE TO COMPARE IT
         CLC       INPUT(2),=C'##' TEST IF PASS ONE IS FINISHES
         BE        OUT            START PASS 2 IF 1 IS FINISHED
         CLI       INPUT,C' '     CHECK IF THERE IS A LABEL
         BE        OPER           IF NOT CHECK OPERATOR
         CLI       INPUT,C'A'     CHECK IF FIRST VALUE IS LESS THANA
         BL        ILABLE         IF SO GO TO ILLEGAL TABLE
         CLI       INPUT,C'Z'     CHECK IF FIRST VALUE GREATER THAN Z
         BH        ILABLE         IF SO GO TO ILT
         CLI       INPUT+1,C'1'   CHECK SECOND CHARACTER IN STRING
*                                 AGAINST 1
         BL        ILABLE         IF LESS THAN 1 PUT IN ILT
         CLI       INPUT+1,C'9'   CHECK SECOND CHARACTER IN STRING
*                                 AGAINST 9
         BH        ILABLE         IF GREATER PUT IN ILT
         CLC       INPUT+2(2),CODE CHECK LAST 2 CHARACTERS AGAINST:
*                                 AND A BLANK
         BNE       ILABLE         IF NOT EQUAL PUT IN ILT
*                                 BE MOVED TO THE TABLE
         LR        6,4            PUT LOCATION OF TABLE IN REG 6
LOOP2    CLC       INPUT(2),0(6)  SEE IF THE LABLE ON CARD IS IN TABLE
         BE        ILABLE         IF IT IS IT IS AN ILLEGAL LABLE
         CLC       0(2,6),=X'0000'  TEST IF THIS IS THE RIGHT SPOT
         BE        RECORD         IF IT IS STORE IT
         LA        6,2(6)         INCREASE TO NEXT SPOT ON TABLE
         B         LOOP2          NOW GO THROUGH THE TEST AGAIN
RECORD   MVC       0(2,6),INPUT
         L         9,LOC          THIS STORES DEC NUM IN ADTAB
         CVD       9,SPACE        CHANGE THE NUMBER TO  A DEC NUMBER
         UNPK      DOUBLE(8),SPACE+4(4) TEMPERARY FOR PRINT OUT
         OI        DOUBLE+7,X'F0' GET RID OF THE SIGN
         XPRNT     CARG,41
         XPRNT     DOUBLE,8
         L         9,SPACE+4      PUT THE DEC VALUE IN REG 9
         SRL       9,4            SHIFT OFF SIGN BITS
         ST        9,SPACE        PUT JUST THE DEC NUM IN SPACE
         MVC       0(4,3),SPACE
         LA        3,4(3)         INCREASE TO NEXT SPOT IN ADTAB
OPER     SR        10,10          REG 10 WILL BE USED AS A POINTER
*                                 TO INPUT
JUMP     LA        9,INPUT(10)
         CLI       0(9),C' '   SEE WHERE ROW OF BLANKS END
         BE        FOUND          IF SO GO TO FIND OPERATOR
         LA        10,1(10)       INCREASE TO NEXT COLUMN
         B         JUMP           TEST FOR SECOND BLANK
FOUND    CLI       0(9),C' '      SEE IF FIRST BLANK HAS BEEN READ
         BNE       OPERAND
         LA        10,1(10)
         LA        9,INPUT(10)    COMPARE NEXT COLUMN
         B         FOUND          COMPARE NEXT COLUMN
ILABLE   XPRNT     CARG,40        PRINT IT OUT
         XPRNT     =CL14' ILLEGAL LABEL',14
         B         INC            EXIT ON THIS CARD
OPERAND  CLI       0(9),C'B'
         BNE       CON            IF NOT GO TO CONTINUE TO CHECK
         L         8,LOC          INCREASE LOCATION COUNTER BY 6 IF IT
         LA        8,6(8)         INCREASE LOC COUNTER BY 6
         ST        8,LOC
         B         INC            GO TO NEXT INPUT
CON      CLC       0(5,9),=C'YIELD' SEE IF IT IS A YIELD STATEMENT
         BNE       CON1           GO TO SEE IF IT IS A DS
         L         8,LOC          ADD 2 TO LOCATION COUNTER FOR YIELD
         LA        8,2(8)         INCREASE LOC COUNTER BY 2
         ST        8,LOC
         B         INC            GO TO NEXT INPUT
CON1     CLC       0(2,9),=C'DS'  TEST IF  IT IS  A DS STATEMENT
         BNE       CHAR           IF NOT GO TO SEE IF IT IS A DC
         LA        10,2(10)       IF IT IS THEN INCREASE LOCATION
*                                 COUNTER PAST DS
         XDECI     7,INPUT(10)    CONVERT TO HEX THE DUP FACTOR
CIRC     LA        9,INPUT(10)    PUT LOCATION ON CARD IN REG 9
         CLI       0(9),C'F'      TEST IF IT IS A FULLWORD INST
         BE        FULWORD        IF IT IS THEN THIS WAS A FULLWORD
         CLI       0(9),C'C'
         BE        SYMBOL         BRANCH TO CHARACTER LOOP
         LA        10,1(10)       INCREASE TO NEXT COLUMN ON CARD
         B         CIRC
FULWORD  C         7,=F'0'        SEE IF THERE WAS NO DUP FACTOR
         BNE       FIN            IF THERE WAS JUST BRANCH
         LA        7,1(7)         ADD 1 TO REG 7 TO MULT IDENTITY
FIN      L         8,LOC          THIS LOOP INCREASES LOCATION COUNTER
*                                 BY 4 TIMES THE DUP FACTOR
         LR        6,8            THIS TEST IF LOCATION IS ON A FULLWOR
*                                 BOUNDARY
         SRL       8,2            FILL IT WITH ZEROES
         SLL       8,2            MOVE OFF LAST BYTE
         CR        6,8            TEST IF THEY ARE THE SAME
         BE        DIV
         LA        8,4(8)         PUT IN NUMBER DIVISABLE BY FOUR
DIV      SLA       7,2       MULTIPLY 7 BY FOUR
         AR        8,7
         ST        8,LOC
         B         INC            GO ON TO NEXT INPUT
SYMBOL   C         7,=F'0'        TEST IF THERE WAS A DUP FACTOR
         BNE       MORE           IF SO JUST GO ON
         LA        7,1(7)         ADD MULT IDENTITY TO REG 7
MORE     L         8,LOC          THIS LOOP INCREASES LOCATION COUNTER
*                                 BY DUP FACTOR FOR DS
         AR        8,7
         ST        8,LOC
         B         INC            GO ON TO NEXT CARD
CHAR     CLC       0(2,9),=C'DC'  TEST IF IT IS A DC STATEMENT
         BE        CONST          BRANCH IF IT IS
         L         8,LOC          THIS LOOP ADDS FOUR ON TO LOCATION
*                                 FOR ALL OPERATORS EXCEPT THOSE ABOVE
         LA        8,4(8)
         ST        8,LOC
INC      LA        2,40(2)        INCREASE TO NEXT LOCATION IN MEMO
         B         TOP            GO DO THE NEXT ONE
CONST    LA        10,2(10)       INCREASE LOCATION COUNTER
         XDECI     7,INPUT(10)    PUT DUP FACTOR IN REG 10
RETURN   LA        9,INPUT(10)    PUT NEW ADDRESS IN REG 9
         CLI       0(9),C'F'      TEST FOR A FULL WORD
         BE        FULWORD        BRANCH IF SO
         CLI       0(9),C'C'      TEST FOR A CHARACTER
         BE        LETTER         BRANCH IF SO
         LA        10,1(10)       INCREASE TO NEXT COLUMN
         B         RETURN         GO COMPARE NEW COLUMN
LETTER   CLI       0(9),C''''
         BE        COUNT
         LA        10,1(10)       INCREASE TO NEXT COLUMN
         LA        9,INPUT(10)    PUT NEW LOCATION IN 9
         B         LETTER         GO TO TEST NEXT COLUMN
COUNT    SR        8,8            REG 8 WILL CONTAIN # OF BYTEX TO LEAV
ADD      LA        8,1(8)         INCREASE COUNTER
         LA        10,1(10)       INCREASE TO NEXT POSITION ON CARD
         LA        9,INPUT(10)    PUT NEW LOCATION IN 9
         CLI       0(9),C''''
         BNE       ADD            BRANCH TO FIND FAST '
         SR        6,6            REG 6 USED IN MULTIPLICATION
         MR        6,8            MULTIPLY REG 7 TIMES 8
         A         7,LOC
         ST        7,LOC
         B         INC
OUT      L         13,SAVPAS1+4
         LM        14,12,12(13)
         BR        14
SAVPAS1  DS        18F
ADCON1   DC        A(BASE1+4096)
CARG     DC        C'0'
INPUT    DS        40C
LOC      DC        F'0'
SPACE    DS        D
DOUBLE   DS        D
CODE     DC        C': '
         LTORG
PASS2    CSECT
         STM       14,12,12(13)
         BALR      11,0
         USING     BASE2,11,12
BASE2    L         12,ADCON2
         ST        13,SAVPAS2+4
         LM        2,5,0(1)
        SR    9,9
         ST    9,COUNTER
START    LR        7,2            REG 7 WILL BE POSITION IN MEMO
WHERE    CLI       0(7),C' '
         BE        FIND           IF FOUND GO TO CHECK NEXT ONE
         LA        7,1(7)         IF NOT BLANK INCREASE POINTER
         B         WHERE          BRANCH TO CHECK IT OUT
FIND     CLI       0(7),C' '
         BNE       OPC            IF NOT YOU ARE AT THE OPERAND
         LA        7,1(7)         INCREASE POINTER
         B         FIND           GO TO CHECK THIS SPACE
OPC      LA        6,CARD         PUT ADDRESS OF CARD IN 6
         MVC       0(5,6),=C'     ' MOVE ALL BLANKS INTO CARD TO TEST
CHECK    CLI       0(7),C'A'      SEE IF THIS IS A LETTER
         BL        EXIT           TOTAL OPERATER IN CARD THEN BRANCH
         CLI       0(7),C'Z'      SEE IF IT IS A LTTTER
         BH        EXIT           TOTAL OPERATOR IN CARD THEN BRANCH
         MVC       0(1,6),0(7)    PUT THE OPERATOR IN CARD
         A         7,=F'1'        INCREASE POINTER IN CARD
         A         6,=F'1'        INCREASE TO NEXT BYTE IN CARD
         B         CHECK          GO BACK TO COMPARE NEXT COLUMN
EXIT     SR        10,10          REG 10 IS INDEX TO OPERATE
         MVC       0(1,6),0(7)    MOVE INTO LAST SPOT
         LA        8,OPERATE      PUT LOCATION OF OPERATOR IN 8
         LA        6,CARD         PUT ODD OF CARD IN REG 6
         CLC       0(5,6),=C'END  '
         BNE       THERE
         MVC       STOR(40),0(2)  IF IT IS A N END STATE PRINT OUT
         XPRNT     CC4,66
         B         PAS2END
THERE    CLC       0(5,6),=C'DC   '
         BE        DC
         CLC       0(5,6),=C'DS   '
         BE        DS
COMPARE  CLC       0(5,6),0(8)    SEE IF CARD IS SAME AS OPCODE
         BE        NUMBER         IF SO BRANCH
         LA        8,5(8)         INCREASE INDEX TO OPERATE
         LA        10,1(10)
         B         COMPARE
NUMBER   LA        6,OPCODE(10)   PUT ADDRESS OF OPERATOR IN 6
         MVC       0(1,5),0(6)    MOVE INTO CORRECT SPOT IN OBTAB
         LA        6,CARD
         CLC       0(5,6),=C'YIELD'
         BNE       TEST           IF NOT CONTINUE TESTING
         L         8,COUNTER      PUT THE PRES LOCATION IN 8
         CVD       8,TWIN         PUT THE DECIMAL VALUE TO BE PRINTED
         L         10,TWIN+4      THIS IS TO GET RID OF THE SIGN NIBBLE
         ST        10,TEMP        PUT HERE TO GET READY TO UNPACK
         UNPK      TWIN(8),TEMP(4) PUT IN A FORM TO BE PRINTED OUT
         OI        TWIN+7,X'F0'   TEST TO GET SIGN OF F
         XPRNT     CC2,9
         MVC       STOR(40),0(2)  PUT INSTRUCTION IS STOR
         XPRNT     CC4,66
         LA        8,2(8)         ADD IN 8 2 FOR YIELD
         ST        8,COUNTER      PUT NEXT LOCAT&ON &NTO COUNTER
         MVC       1(1,5),=X'00'
         LA        5,2(5)
         B         FINISH
TEST     CLC       0(5,6),=C'B    '
         BNE       NBRANCH
LOCATE   CLI       0(7),C' '
         BE        BLANK
         LA        7,1(7)         INCREASE TO NEXT COLUMN
         B         LOCATE         GO CHECK NEXT COLUMN FOR BLANK
BLANK    CLI       0(7),C' '
         BNE       ADLAB
         LA        7,1(7)         INCREASE TO NEXT BYTE
         B         BLANK
ADLAB    LR        8,4            PUT TABLE ASDRESS IN REG 8
         LR        9,3            PUT IN ADDREAS OF ADTAB
CIRCLE   CLC       0(2,7),0(8)    TEST IF RIGHT LABLE IN TABLE
         BE        RIGHT          RRANCH IF IT IS
         LA        8,2(8)         INCREASE INDEX TO TABLE
         LA        9,4(9)         INCREASE INDEX TO ADTAB
         B         CIRCLE         BRANCH TO CHECK AGAIN
RIGHT    MVC       TEMP(4),0(9)   PUT ADDRESS OF LABLE IN TEMP
         SR        10,10          REG 10 IS COUNTER FOR BYTE POSITION
         LA        5,1(5)         INCREASE INDEX TO APATB
         MVC       0(2,5),TEMP+2
         LA        5,2(5)         INCRAASE INDEX TO OPTAB
         LA        6,TEMP
SECOND   LA        7,3(7)         INCREASE COLUMN POINTER
         LR        8,4            PUT ADDRESS OF TABLE IN 8
         LR        9,3            PUT ADDRESS OF ADTAB IN 9
AGAIN    CLC       0(2,7),0(8)    SEE IF IT IS THE RIGHT LABLE
         BE        EXACT
         LA        8,2(8)         INCREASE INDEX TO TABLE
         LA        9,4(9)         INCREASE INDEX TO ADTAB
         B         AGAIN
EXACT    MVC       0(2,6),2(9)    PUT ADDRESS IN TEMP
         LA        6,2(6)         INCREASE TO FOURTH BYTE OF TEMP
         LA        10,1(10)       INCREASE TO NEXT POSITION
         C         10,=F'2'       IF 2 BYTES HAVE BEEN LOADED WE ASE
*                                 THROUGH
         BNE       SECOND
         LH        8,TEMP         PUT FIRST LOCATION IN 8
         LH        9,TEMP+2       SECOND LOCATION IN 9
         SLL       9,20           KNOCK OFF FIRST 20 BYTES
         SLDL      8,12           MOVE IT OVER
         ST        8,TEMP
         MVC       0(3,5),TEMP+1  STORE IN APTAB
         LA        5,3(5)         INCREASE INDEX TO OPTAB
         LR        6,5            PUT NEW ADDRESS OF OPTAB IN 6
         S         6,=F'6'        SUBTRACT 6 TO GET TO FIRST BYTE
         L         8,COUNTER      PUT THE PRES LOCATION IN 8
         CVD       8,TWIN         PUT THE DECIMAL VALUE TO BE PRINTED
         L         10,TWIN+4      THIS IS TO GET RID OF THE SIGN NIBBLE
         ST        10,TEMP        PUT HERE TO GET READY TO UNPACK
         UNPK      TWIN(8),TEMP(4) PUT IN A FORM TO BE PRINTED OUT
         OI        TWIN+7,X'F0'   TEST TO GET SIGN OF F
         XPRNT     CC2,9
         MVC       STOR(40),0(2)  MOVE INPUT INTO SROR
         XPRNT     CC4,66
         LA        8,6(8)         ADD 6 FOR A BRANCH
         ST        8,COUNTER      PUT NEXT LOCATION INTO COUNTER
         B         FINISH
DS       MVC       STOR(40),0(2)  PUT INSTRUCTION IN STORE
         L         8,COUNTER      PUT THE PRES LOCATION IN 8
         XDECI     6,0(7)         TEST FOR DUP FACTOR
         LA        9,STOR+4
         C         6,=F'0'        IF NO DUP FACTOR PUT MULTIPLICATION
*                                 IDENTIFIER IN IT
         BNE       OUTPUT
         LA        6,1(6)
OUTPUT   CVD       8,TWIN              PREPARE TO BE PRINTED AS DECIMAL
         L         10,TWIN+4      THIS IS TO GET RID OF THE SIGN NIBBLE
         ST        10,TEMP        PUT HERE TO GET READY TO UNPACK
         UNPK      TWIN(8),TEMP(4) PUT IN A FORM TO BE PRINTED OUT
         OI        TWIN+7,X'F0'   TEST TO GET SIGN OF F
         XPRNT     CC2,9
         XPRNT     CC4,66
FUN      CLI       0(9),C'F'
         BE        YES
         CLI       0(9),C'C'
         BE        YEA
         LA        9,1(9)
         B         FUN
YES      LR        9,6
         M         8,=F'4'
         L         8,COUNTER      PUT THE PRES LOCATION IN 8
         AR        8,9
         ST        8,COUNTER
         AR        5,9
         B         FINISH
YEA      LR        8,6
         AR        5,6            ADD DUP FACTOR TO INDEX OF OPTAB
         L         8,COUNTER
         AR        8,6
         ST        8,COUNTER
         B         FINISH
NBRANCH  CLC       0(5,6),=C'RD   '
         BNE       WRITE
         LA        7,2(7)         INCREASE POINTER TO COLUMN
SAME     CLI       0(7),C' '
         BE        ORBIT
         LA        7,1(7)         INCREASE POINTER TO MEMO
         B         SAME
ORBIT    LA        7,1(7)         INCREASE POINTER
         CLI       0(7),C' '
         BE        ORBIT
         LR        8,4            PUT ADDRESS OF TABLE IN 8
         LR        9,3            PUT ADDRESS OF ADTAB IN 9
TURN     CLC       0(2,7),0(8)    TEST IF THIS IS RIGHT LABLE
         BE        CORRECT
         LA        8,2(8)         INCREASE TO NEXT LABLE
         LA        9,4(9)         INCREASE TO NEXT ADDRESS
         B         TURN
CORRECT  LR        6,5            PUT THE ADDRESS OF OBTAB IN 6
         LA        7,3(7)         INCREASE POINTER
         LA        6,1(6)         INCREASE INDEX TO OBTAB
         MVC       0(2,6),0(7)    MOVE LENGHT TO OBTAB
         LA        6,1(6)         INCREASE INDEX TO OBTAB
         MVC       0(2,6),0(9)    MOVE LOCATION IN LAST 3 BYTES
         MVC       STOR(40),0(2)  PUT INSTRUCTION IN STORE
         L         8,COUNTER      PUT THE PRES LOCATION IN 8
         CVD       8,TWIN         PUT THE DECIMAL VALUE TO BE PRINTED
         L         10,TWIN+4      THIS IS TO GET RID OF THE SIGN NIBBLE
         ST        10,TEMP        PUT HERE TO GET READY TO UNPACK
         UNPK      TWIN(8),TEMP(4) PUT IN A FORM TO BE PRINTED OUT
         OI        TWIN+7,X'F0'   TEST TO GET SIGN OF F
         XPRNT     CC2,9
         XPRNT     CC4,66
         LA        8,4(8)         ADD 4 FOR ALL OTHERS
         ST        8,COUNTER
         LA        5,4(5)         INCREASE TO NEXT OPTAB LOCATION
         B         FINISH
WRITE    CLC       0(5,6),=C'WRT  '
         BE        SAME           THE WRT IS ASSEMBLED LIKE RD
         B         LEAVE
DC       LA        7,2(7)
         MVC       STOR(40),0(2)  MOVE INSTRUCTION INTO STORE
         CVD       8,TWIN         PUT THE DECIMAL VALUE TO BE PRINTED
         L         10,TWIN+4      THIS IS TO GET RID OF THE SIGN NIBBLE
         ST        10,TEMP        PUT HERE TO GET READY TO UNPACK
         UNPK      TWIN(8),TEMP(4) PUT IN A FORM TO BE PRINTED OUT
         OI        TWIN+7,X'F0'   TEST TO GET SIGN OF F
         XPRNT     CC2,9
         XPRNT     CC4,66
         ST        10,TWIN+4      PUT THE LOCATION BACK IN TWIN
         XDECI     6,0(7)         CONVERT THE DUP FACTOR INTO HEX
         LA        9,STOR+4       PUT THE ADDRESS OF STORE IN REG 9
         C         6,=F'0'        SEE IF DUP FACTOR WAS 0
         BNE       WHAT           IF NOT BRANCH AROUND
         A         6,=F'1' PUT MULT IDENTITY IN REG 6
WHAT     CLI       0(9),C'F'
         BE        F              IF SO BRANCH
         CLI       0(9),C'C'
         BE        C              IF SO BRANCH
         LA        9,1(9)         ADD 1 TO MOVE TO NEXT COLUMN IN STOR
         B         WHAT           TEST THIS COLUMN
F        LA        9,2(9)         ADD 2 TO GET PAST THE F
         LA        8,TEMP         TEMP WILL HOLD NUMBER TO BE STORED
         L         7,COUNTER
         LR      10,7        THIS IS TO TEST IF IT IS ON A FULL W BOUND
         SRL       7,2            MOVE OVER TO LOWEST MULT OF 4
         SLL       7,2            MOVE BACK TO RIGHT SPOT
         CR        10,7           TEST IFA THE VALUE HAS CHANGED
         BE        PUT            IF NOT IT IS A MULTIPLE
         LA        7,4(7)
PUT      MVC       0(1,8),0(9)
         LA        8,1(8)         INCREASE INDEV TO TEMP
         LA        9,1(9)         INCREASE POINTER OF COLUMN
         CLI       0(9),C''''
         BNE       PUT
         MVC       0(4,5),=X'00000000'
         L         8,TEMP         PUT CHARACTER IN 8
         LR        10,8           SEE IF IT IS IN THE LAST BYTE YET
GEE      SRL       8,8
         SLL       8,8
         CR        10,8
         BNE       OK
         SRL       8,8
         B         GEE
OK       ST        8,TEMP
         MVC       0(4,5),TEMP    MOVE IT INTO OPTAB
         LA        5,4(5)         INCREASE INDEX TO OPTAB
         LA        7,4(7)         INCREASE COUNTER BY 4
         BCT       6,PUT          TEST IF DUP FACTOR IS DNOE DUP
         ST        7,COUNTER      PUT LOCATION BACK IN COUNTER
PRIN     LA        5,1(5)         INCREASE POINTER TO OPTAB
         B         FINISH
C        LA        9,2(9)         GO PAST THE C'
         LA        8,9            PUT ORIGINAL LOCATION IN 8
LOOK     MVC       0(1,5),0(9)    MOVE FIRST MUMBER INTO OPTAB
         LA        5,1(5)         INCREASE INDEX TO OPTAB
         CLI       0(9),C''''
         BE        DUN            IF SO BRANCH
         LA        9,1(9)         GO TO NEXT COLUMN
         B         LOOK           BRANCH TO MOVE IT
DUN      CLC       0(4,6),=F'0'   DEE IF THERE WAS A DUP FACTOR
         BNE       PRIN           IF NOT GO TO PRIN
         LR        9,8            PUT ORIGINAL INST PLACE IN REG 9
         BCT       6,GEE
         B         PRIN           BRANCH TO PRIN IF IT IS
LEAVE    CLI       0(7),C' '
         BE        LAB            IF BLANK IS FOUND TAKE BRANCH
         LA        7,1(7)
         B         LEAVE
LAB      LA        7,1(7)         INCREASE INDEX TO MEMO
         CLI       0(7),C' '
         BE        LAB
         SR        9,9            REG 9 WILL BE USED AS LOCATION TO AD
         LR        6,4            REG 6 CONTAINS ADDRESS OF TABLE
HERE     CLC       0(2,7),0(6)    SEE IF THIS IS REGHT LABLE
         BE        LOCATON        IF SO BRANCH TO LOCATON
         LA        9,4(9)         INCREASE INDEX TO ADTAB
         LA        6,2(6)         INCREASE INDEX TO TABLE
         B         HERE
LOCATON  AR        9,3            ADDRESS TO CORRECT SPOT IN ADTAB
         L         8,COUNTER      PUT THE PRES LOCATION IN 8
         MVC       STOR(40),0(2)
         CVD       8,TWIN
         L         10,TWIN+4      THIS IS TO GET RID OF THE SIGN NIBBLE
         ST        10,TEMP        PUT HERE TO GET READY TO UNPACK
         UNPK      TWIN(8),TEMP(4) PUT IN A FORM TO BE PRINTED OUT
         OI        TWIN+7,X'F0'   TEST TO GET SIGN OF F
         XPRNT     CC2,9
         XPRNT     CC4,66
         LA        8,4(8)         ADD 4 FOR ADD OTHERS
         ST        8,COUNTER
         LA        5,1(5)         INCREASE INDEX TO ABTAB
         MVC       CARD(4),0(9)   PUT IT INTO CARD TO BE STORED AND
*                                 PRINTED OUT
         MVC       0(3,5),CARD+1
         LA        5,3(5)         ADD TO GET TO THE END OF THE OBTAB
FINISH   LA        2,40(2)        ADD 40 TO NEXT SPOT IN MEMO
         B         START          GO TO BEGINNING
PAS2END  L         13,SAVPAS2+4
         LM        14,12,12(13)
         BR        14
SAVPAS2  DS        18F
ADCON2   DC        A(BASE2+4096)
CC3      DC        C'      '
CARD     DC        5C' '
         DS        1C
TEMP     DS        F
         DS        0D
         DS        15C
CC2      DC        C' '
TWIN     DS        D
COUNTER  DC        F'0'
CC4      DC        C'+'
         DC        29C' '
STOR     DS        40C
OPERATE  DC        C'RD   RD1  WRT  WRT1 LD   ST   A    S    MT   DV  '
         DC        C' GO   B    YIELD'
OPCODE   DC        X'21223132414251525354111315'
         LTORG
         PRINT ON
         END
$ENTRY
         RD        H1,60
         WRT       H1,60
         RD        H2,25
U2:      RD1       A1
         LD        A1
         B         U9,U3,U3
U3:      RD1       B1
         RD1       C1
         WRT       H2,25
         WRT1      A1
         WRT1      B1
         WRT1      C1
         GO        U4
A1:      DS        F
B1:      DS        F
C1:      DS        F
U4:      MT        C1
         MT        F1
         ST        Z1
         LD        B1
         MT        B1
         S         Z1
         B         L1,L2,L3
L1:      WRT       M1,13
         GO        U2
U9:      YIELD
L2:      LD        A1
         MT        T1
         ST        Z2
         LD        B1
         S         B1
         S         B1
         DV        Z2
         ST        X1
         WRT       M2,14
         WRT1      X1
         GO        U2
L3:      WRT       M3,20
         GO        U2
Z1:      DC        1F'0'
H1:      DS        45C
H2:      DS        25C
T1:      DC        1F'2'
F1:      DC        F'4'
Z2:      DS        6C
         DC        1F'0'
M1:      DC        C'NO REAL ROOTS'
M2:      DC        C'A DOUBLE ROOT:'
M3:      DC        C'TWO REAL ROOTS EXIST'
X1:      DC        1F'-1'
                                 END
##
   RD      A1,1
   WRT    A1,1
          RD1    A2
    WRT1             A2
    RD1    A3
     RD1    A4
A5:  LD      A1
      A  A1
  ST  A1
    S   A2
   MT   A1
    DV  A3
 GO A4
A4:  S A3
     B     A4,A5,A4
        YIELD
A1:      DS        1C
A2:      DS        3C
A3:      DC        1F'0'
A4:      DC        1F'1'
                                END
##
    RD1    M1
   RD1  N1
    WRT1    M1
     WRT1 N1
  LD  M1
     S         N1
    B  B1,B1,A1
A1: LD M1
  ST       T1
 LD N1
      ST    M1
  LD       T1
    ST  N1
B1:     LD  N1
   DV   M1
     MT     M1
   ST  Q2
    LD     N1
   S Q2
   B        B2,D1,B2
B2:     ST    T2
   LD M1
   ST   N1
       LD   T2
                ST        M1
       GO       B1
D1: WRT M5,31
       WRT1  M1
 YIELD
M1:   DS   1F
N1:    DS    1F
T1: DS 2F
T2:     DS     10F
M5:    DC 1C'THE GREATEST COMMON'
     DC  1C' DIVISOR IS:'
Q2:   DC   1F'0'
                          END
##
$JOB   ASSIST  PROGTEST
         TITLE   'FIRST PASS'
*        *** SAMPLE FINAL PROJECT - 1ST ASSEMBLER LANGUAGE COURSE.
*        460+ STATEMENTS, , APPROX 150 INPUT DATA CARDS,
*        USER PROGRAM PRINTS 4 PAGES OF OUTPUT, EXECUTES 10411
*        INSTRUCTIONS, THEN RETURNS NORMALLY.
*        CMPSC 410.1 - FALL 1970 - PSU-INSTRUCTOR -C.HUGHES.
TOPAL    CSECT
         B       10(,15)
         DC      X'05'
         DC      CL5'TOPAL'
         STM     14,12,12(13)
         BALR    12,0
         USING   *,12
         ST      13,SAVE
         XREAD   CARD,32           READ CARD
         BNM     JOB
         XPRNT   =CL29'0ALL JOBS HAVE BEEN PROCESSED',29
         L       13,SAVE
         LM      14,15,12(13)
         LM      2,12,28(13)
         MVI     12(13),X'FF'
         BR      14
JOB      CLC     CARD(2),=C'$$'    IS IT A JOB CARD?
         BE      ID
         XPRNT   =CL44'1****JOB CARD MISSING***********************',44
ID       XPRNT   =CL1'1',1         CC TO NEXT PAGE
         MVC     IMAGE(32),CARD
         XPRNT   CC2,33
*
* SET POINTERS AND LOCATION COUMTERS AND SET UP DSECT ADDRESSABILITY
*
         L       10,=V(CDEA)       LOAD ADDRESS OF CODE AREA
CRDL     EQU     2                 CARD AREA L C
CDEL     EQU     4                 CODE AREA L C
SYTL     EQU     3                 SYMBOL TABLE L C
         L       CRDL,=V(CRD)      LOAD ADDRESS OF CARD IMAGE AREA
         L       CDEL,=V(CDEA)     LOAD ADDRESS OF CODE AREA
         L       SYTL,=V(SYT)      LOAD ADDRESS OF SYMBOL TABLE
         USING   SYTFORM,SYTL
         USING   CRDFORM,CRDL
*
* ZERO OUT SYMBOL AREA
*
         LM      5,9,AREA2
         LA      0,20
         LA      1,480
         SR      11,11
LOOP1    STM     5,9,0(SYTL)
         LA      SYTL,20(SYTL)
         BXLE    11,0,LOOP1
*
* ZERO OUT CODE AREA
*
         LA      1,780
         SR      11,11
LOOP2    STM     5,9,0(CDEL)
         LA      CDEL,20(CDEL)
         BXLE    11,0,LOOP2
* RESET LOCATION COUNTERS
         L       SYTL,=V(SYT)
         L       CDEL,=V(CDEA)
         MVC     EX,TRUE           ALLOW EXECUTION
         B       READ2
READ     LA      CRDL,32(CRDL)     UP DATE CARD AREA L C
READ2    XREAD   CARD,32
*
* BUILD CARD IMAGE TABLE
*
         MVC     0(32,CRDL),CARD   STORE CARD IN CARD TABLE
         CLI     CARD,C'*'
         BE      READ              BRANCH TO READ NEXT CARD
         MVI     FLAG,X'00'
         CLC     CARD+9(3),=C'END'
         BE      PASS2             BRANCH TO SECOND PASS
*
* BUILD  SYMBOL  TABLE
*
         CLI     CARD,C' '         IS THERE A  LABEL?
         BE      PROCESS
         L       SYTL,=V(SYT)
COMP     CLC     CARD(8),SYMBOL    COMPARE WITH SYMBOL TABLE
         BNE     ZERO
         MVC     EX,FALSE          SET NO EXECUTE FLAG
         OI      FLAG,X'80'        PUT ERROR FLAG IN CARD AREA
         B       DCON
ZERO     CLI     SYMBOL,X'0'       CHECK FOR END OF SYMBOL TAVLE
         BE      STORE
         LA      SYTL,10(SYTL)     INCREMENT SYMBOL TABLE
         B       COMP
STORE    MVC     SYMBOL(8),CARD
*
* PROCESS DCON CARDS
*
DCON     CLC     CARD+9(4),=C'DCON'   IS IT A DCON CARD
         BNE     NODCON               FIND DCON CARD
* ALIGN CODE LOCATION COUNTER TO FULL WORD BOUNDARY
         LCR     9,CDEL
         N       9,=X'00000003'
         AR      CDEL,9
         XDECI   5,CARD+14         CONVERT TO BINARY
         ST      5,0(CDEL)         STORE DCON NUMBER IN CODE AREA
* STORE  NUMBER  LOCATION IN SYMBOL TABLE
         SR      CDEL,10
         ST      CDEL,DISP
         AR      CDEL,10
         OC      SYMBOL+6(4),DISP
         OI      FLDISP,X'80'      PUT DCON FLAG IN SYMBOL TABLE
         LA      CDEL,4(CDEL)      UPDATE CODE AREA L C
         B       READ
*
* BUILD CODE AREA
*
NODCON   SR      CDEL,10
         ST      CDEL,DISP
         AR      CDEL,10
         OC      SYMBOL+6(4),DISP
* SET REGISTERS
PROCESS  LA      6,DICT
         LA      9,72
         LA      8,8
         SR      5,5
         LA      7,=A(ADD,SUB,MUL,DIV,OUT,IN,MOVE,STOP,BRM,BR)
* SEARCH FOR OPCODE
PROCED   CLC     CARD+9(4),0(6)
         BE      OK
         LA      7,4(7)            INCREMENT ADDRESS REGISTER
         LA      6,8(6)            INCREMENT DISPLACEMENT REGISTER
         BXLE    5,8,PROCED
* IF NOT THERE INSERT ERROR CONTROLS
         MVC     EX,FALSE
         OI      FLAG,X'40'
         B       READ
* GET CODE LENGTH AND MOVE CODE TO CODE AREA
OK       XDECI   9,4(6)
         L       14,0(7)
         EX      9,MOVADD
         LA      9,1(9)
         AR      CDEL,9            UPDATE LOCATION COUNTER
         B       READ
         TITLE   'SECOND PASS'
PASS2    LA      5,LOOKUP
* RESET POINTERS
         L       CRDL,=V(CRD)
         L       CDEL,=V(CDEA)
         B       PRNT
*
* PROCESS CODE
*
CRDIM    LA      CRDL,32(CRDL)     GET NEXT CARD
PRNT     MVC     IMAGE(32),LABEL
         XPRNT   CC2,33
*
* CHECK FOR COMMENT CARD
*
         CLI     LABEL,C'*'
         BE      CRDIM
*
* LOOK FOR ERROR FLAGS AND PRINT ERROR MESSAGES
*
         CLI     FLAG,X'40'
         BNE     MDL
         MVC     EX,FALSE
         XPRNT   =CL44' ****ILLEGAL OPCODE*************************',44
         B       CRDIM
MDL      CLI     FLAG,X'80'
         BNE     MDLS
         MVC     EX,FALSE
         XPRNT   =CL44' ****MULTIPLY DEFINED SYMBOL****************',44
         B       CRDIM
MDLS     CLI     FLAG,X'C0'
         BNE     COM
         MVC     EX,FALSE
         XPRNT   =CL44' ****ILLEGAL OPCODE AND MULT DEFINED SYMBOL*',44
         B       CRDIM
*
* CHECK OPCODE FOR END, STOP AND DCON
*
COM      CLC     OPCODE(3),=C'END'
         BE      EXECUTE
         CLC     OPCODE(4),=C'STOP'
         BNE     CONT
         LA      CDEL,L'STOP(CDEL)
         B       CRDIM
CONT     CLC     OPCODE(4),=C'DCON'
         BNE     AADD
* ALIGN LC TO FULL WORD BOUNDARY
         LCR     9,CDEL
         N       9,=X'00000003'
         AR      CDEL,9
         LA      CDEL,4(CDEL)
         B       CRDIM
*
* PROCESS CODE FOR MUL SUB AND ADD STATEMENT
*
AADD     CLC     OPCODE(3),=C'ADD'
         BE      LREG
         CLC     OPCODE(3),=C'SUB'
         BE      LREG
         CLC     OPCODE(3),=C'MUL'
         BNE     CINOUT
LREG     MVC     CHAR(8),OP1
         BALR    7,5               BRANCH TO LOOKUP ROUTINE
         MVC     FL,FLDISP
         NI      FL,X'80'
         CLI     FL,X'80'
         BE      FILL10
         XPRNT   =CL44' ****USING STATEMENT LABEL AS OPERAND*******',44
         MVC     EX,FALSE
FILL10   OC      2(2,CDEL),FLDISP
         OC      10(2,CDEL),FLDISP
         MVC     CHAR(8),OP2
         BALR    7,5               BRANCH TO LOOKUP ROUTINE
         MVC     FL,FLDISP
         NI      FL,X'80'
         CLI     FL,X'80'
         BE      FILL11
         XPRNT   =CL44' ****USING STATEMENT LABEL AS OPERAND*******',44
         MVC     EX,FALSE
FILL11   OC      6(2,CDEL),FLDISP
         LA      CDEL,12(CDEL)
         B       CRDIM
*
* PROCESS CODE FOR IN AND OUT STATEMENT
*
CINOUT   CLC     OPCODE(2),=C'IN'
         BE      BLK
         CLC     OPCODE(3),=C'OUT'
         BNE      ADIVD
BLK      MVC     CHAR(8),OP1
         BALR    7,5               BRANCH TO LOOKUP ROUTINE
         MVC     FL,FLDISP
         NI      FL,X'80'
         CLI     FL,X'80'
         BE      FILL9
         XPRNT   =CL44' ****USING STATEMENT LABEL AS OPERAND*******',44
         MVC     EX,FALSE
FILL9    OC      2(2,CDEL),FLDISP
         LA      CDEL,6(CDEL)
         B       CRDIM
*
* PROCESS CODE FOR DIV STATEMENT
*
ADIVD    CLC     OPCODE(3),=C'DIV'
         BNE     ABRM
         MVC     CHAR(8),OP1
         BALR    7,5               BRANCH TO LOOKUP ROUTINE
         MVC     FL,FLDISP
         NI      FL,X'80'
         CLI     FL,X'80'
         BE      FILL8
         XPRNT   =CL44' ****USING STATEMENT LABEL AS OPERAND*******',44
         MVC     EX,FALSE
FILL8    OC      2(2,CDEL),FLDISP
         OC      14(2,CDEL),FLDISP
         MVC     CHAR(8),OP2
         BALR    7,5               BRANCH TO LOOKUP ROUTINE
         MVC     FL,FLDISP
         NI      FL,X'80'
         CLI     FL,X'80'
         BE      FILL7
         XPRNT   =CL44' ****USING STATEMENT LABEL AS OPERAND*******',44
         MVC     EX,FALSE
FILL7    OC      10(2,CDEL),FLDISP
         LA      CDEL,16(CDEL)
         B       CRDIM
*
* PROCESS CODE FOR BRM STATEMENT
*
ABRM     CLC     OPCODE(3),=C'BRM'
         BNE     ABR
         MVC     CHAR(8),OP2
         BALR    7,5               BRANCH TO LOOKUP ROUTINE
         MVC     FL,FLDISP
         NI      FL,X'80'
         CLI     FL,X'00'
         BE      FILL
         XPRNT   =CL44' ****ATTEMPT TO BRANCH TO DATA**************',44
         MVC     EX,FALSE
FILL     OC      8(2,CDEL),FLDISP
         MVC     CHAR(8),OP1
         BALR    7,5               BRANCH TO LOOKUP ROUTINE
         MVC     FL,FLDISP
         NI      FL,X'80'
         CLI     FL,X'80'
         BE      FILL6
         XPRNT   =CL44' ****USING STATEMENT LABEL AS OPERAND*******',44
         MVC     EX,FALSE
FILL6    OC      2(2,CDEL),FLDISP
         LA      CDEL,10(CDEL)
         B       CRDIM
*
* PROCESS CODE FOR BR STATEMENT
*
ABR      CLC     OPCODE(2),=C'BR'
         BNE     AMOVE
         MVC     CHAR(8),OP1
         BALR    7,5               BRANCH TO LOOKUP ROUTINE
         MVC     FL,FLDISP
         NI      FL,X'80'
         CLI     FL,X'00'
         BE      FILL2
         XPRNT   =CL44' ****ATTEMPT TO BRANCH TO DATA**************',44
         MVC     EX,FALSE
FILL2    OC      2(2,CDEL),FLDISP
         LA      CDEL,4(CDEL)
         B       CRDIM
*
* PROCESS CODE FOR MOVE STATEMENT
*
AMOVE    CLC     OPCODE(4),=C'MOVE'
         BNE     CRDIM
         MVC     CHAR(8),OP1
         BALR    7,5               BRANCH TO LOOKUP ROUTINE
         MVC     FL,FLDISP
         NI      FL,X'80'
         CLI     FL,X'80'
         BE      FILL5
         XPRNT   =CL44' ****USING STATEMENT LABEL AS OPERAND*******',44
         MVC     EX,FALSE
FILL5    OC      2(2,CDEL),FLDISP
         MVC     CHAR(8),OP2
         BALR    7,5               BRANCH TO LOOKUP ROUTINE
         MVC     FL,FLDISP
         NI      FL,X'80'
         CLI     FL,X'80'
         BE      FILL3
         XPRNT   =CL44' ****USING STATEMENT LABEL AS OPERAND*******',44
         MVC     EX,FALSE
FILL3    OC      4(2,CDEL),FLDISP
         LA      CDEL,6(CDEL)
         B       CRDIM
         TITLE   'EXECUTE ROUTINE'
EXECUTE  CLC     EX,FALSE
         BNE     DMP
         XPRNT   =CL44' ****JOB NOT EXECUTED***********************',44
* GO TO $* CARD
SCH1     XREAD   CARD,32
         CLC     CARD(2),=C'$*'
         BNE     SCH1
         BR      12
DMP      XDUMP   0(,10),800
* SET REGISTERS
         LA      9,OUTPUT
          LA     8,INPUT
* BRANCH TO CODE
         BALR    11,10
         XDUMP   0(10),800
* CHECK FOR END OF DATA
         XREAD   CARD,32
         CLC     CARD(2),=C'$*'
         BNE     MGS
         BR      12
MGS      XPRNT   =CL44' ****ALL DATA WAS NOT READ******************',44
* GO TO $* CARD
SCH2     XREAD   CARD,32
         CLC     CARD(2),=C'$*'
         BNE     SCH2
         BR      12
         TITLE   'SYMBOL TABLE LOOKUP ROUTINE'
LOOKUP   L       SYTL,=V(SYT)
LOOK     CLC     SYMBOL(8),CHAR
         BE      0(7)
         LA      SYTL,10(SYTL)
         CLI     SYMBOL,X'0'
         BNE     LOOK
         XPRNT   =CL44' ****ILLEGAL OPERAND************************',44
         MVC     EX,FALSE
          B       CRDIM
         TITLE   'INPUT ROUTINE'
INPUT    XREAD   CARD,32
         CLC     CARD(2),=C'$*'
         BNE     CONV
         XDUMP   0(,10),800
         XPRNT   =CL44' ****ATTEMPT TO READ BEYOND END OF DATA*****',44
         BR      12
CONV     ST      1,REG1
         XDECI   0,CARD
         L       1,REG1
         ST      0,0(1)
         BR      7
         TITLE   'OUTPUT ROUTINE'
OUTPUT    XPRNT   =CL15'0THE NUMBER IS:',15
         XDECO   1,DATA
         XPRNT   CC,13
         BR      7
         TITLE    'DEFINED CONSTANT AND STORAGES'
ADD      DC      X'5800A0005A00A0005000A000'
SUB      DC      X'5800A0005B00A0005000A000'
MUL      DC      X'5810A0005C00A0005010A000'
DIV      DC      X'5800A0008E0000205D00A0005010A000'
OUT      DC      X'5810A0000579'
IN       DC      X'4110A0000578'
MOVE     DC      X'D203A000A000'
STOP     DC      X'07FB'
BRM      DC      X'5800A00012004740A000'
BR       DC      X'47F0A000'
EX       DS      C
TRUE     DC      X'01'
FALSE    DC      X'00'
AREA2    DC      5F'0'
CARD     DS      CL32
         DS      3C
CC2      DC      C' '
IMAGE    DS      32C
         DS      3C
CC       DC      C'0'
DATA     DS      12C
DISP     DS      F
REG1     DS      F
CHAR     DS      8C
DICT     DC      C'ADD 0011SUB 0011MUL 0011DIV 0015OUT 0005IN  0005MOVE1
               0005STOP0001BRM 0009BR  0003'
MOVADD   MVC     0(0,CDEL),0(14)
SAVE     DS      F
FL       DS      C
         LTORG
         TITLE  'CARD IMAGE CSECT'
CRD      CSECT
         DS      50CL32
CRDFORM  DSECT
LABEL    DS      CL9
OPCODE   DS      CL5
OP1      DS      CL9
OP2      DS      CL8
FLAG     DS      CL1
         TITLE  'SYMBOL TABLE CSECT'
SYT      CSECT
         DS      50CL10
SYTFORM  DSECT
SYMBOL   DS      CL8
FLDISP   DS      CL2
         TITLE  'CODE AREA CSECT'
CDEA     CSECT
         DS      50CL16
         END
$ENTRY
$$          'SMITH J^JOB1'
* DONT FORGET TO SUPPLY THE PROPER DELIMITERS
* THIS IS PROGRAM NUMBER 1
* RECOGNIZE THIS ONE ?
* COMPUTE N!
*        *    *        *
         IN   N
         OUT  N
         MOVE NFAC     N
         MOVE M        N
         SUB  N        ONE
* LOOP TO DO COMPUTATION
LOOP     SUB  N        ONE
         BRM  N        DONE
         SUB  M        ONE
         MUL  NFAC     M
         BR   LOOP
DONE     OUT  NFAC
         STOP
N        DCON 0
M        DCON 0
NFAC     DCON 0
ONE      DCON 1
         END
5
$*
$$          'SMITH J^JOB2'
* THIS IS PROGRAM NUMBER 2
* PROGRAM FINDS MAX & MIN OF SET
* OF INTEGERS<10000000. MIN IS
* MULT BY 5,MAX IS DIV BY 4
* AND SUM OF RESULTS PRINTED. -1
* READ IN HALTS PROGRAM
*        *    *        *
LOOP1    IN   N
         BRM  N        QUIT
         MOVE TEMP     N
         SUB  TEMP     MAX
* IF NEG RESULT OLD MAX STANDS
         BRM  TEMP     TRYMIN
         MOVE MAX      N
TRYMIN   MOVE TEMP     N
         SUB  TEMP     MIN
* IF NEG RESULT THEN NEW MIN
         BRM  TEMP     NEWMIN
         BR   LOOP1
NEWMIN   MOVE MIN      N
         BR   LOOP1
N        DCON 0
MAX      DCON -4
MIN      DCON 10000000
TEMP     DCON 0
FOUR     DCON 4
FIVE     DCON 5
QUIT     MUL  MIN      FIVE
         DIV  MAX      FOUR
         ADD  MIN      MAX
         OUT  MIN
         STOP
         END
200   DATA
         20     DATA
                5000      DATA
  18    DATA
         64     DATA
     2    DATA
          -1       DATA TRAILER
$*
$$          'SMITH J^JOB3'
* PROGRAM NUMBER 2 WITH ERRORS
*        *    *        *
LOOP1    IN   N
         BRM  N        QUIT
         MOVE TEMP     N
         SUB  TEMP     MAX
* IF NEG RESULT OLD MAX STANDS
         BRM  TEMP     TRYMIN
         MOVE MAX      N
TRYMIN   MOVE TEMP     N
         SUB  TEMP     TRYMIN
* IF NEG RESULT THEN NEW MIN
         BRM  TEMP     NEWMIN
         BR   MAX
NEWMIN   MOVE MIN      N
         BR   LOOP1
N        DCON 0
MAX      DCON -4
TEMP     DCON 0
FOUR     DCON 4
FIVE     DCON 5
MAX      DCON 1000000
QUIT     MUL  MIN      FIVE
         STM  MAX      FOUR
         ADD  MIN      MAX
         OUT  MIN
         STOP
         END
200   DATA
         20     DATA
                5000      DATA
  18    DATA
         64     DATA
     2    DATA
          -1       DATA TRAILER
$*
$$          'SMITH J^JOB4'
* PROGRAM NUMBER 1 WITH ERRORS
*        *    *        *
         IN   N
         OUT  N
         MOVE NFAC     N
         MOVE M        N
         SUB  N        ONE
* LOOP TO DO COMPUTATION
LOOP     SUB  N        ONE
         BRM  DONE
         SUB  M        ONE
         MUL  NFAC     M
         BR   POOL
DONE     OUT  NFAC
         STOP
N        DCON 0
M        DCON 0
NFAC     DCON 0
ONE      DCON 1
         END
$*
$JOB   ASSIST  PROGTEST
*        *** SAMPLE FINAL PROJECT - 1ST ASSEMBLER COURSE - 500 STMTS,
*        150-200 CARDS ARE READ BY THE STUDENT PROGRAM.
*        USER PROGRAM PRINTS 6-7 PAGES OF OUTPUT, EXECUTES 15240 INSTS.
*        THEN TERMINATES NORMALLY.
*        CMPSC 410.1 - FALL 1970 - PSU-INSTRUCTOR -C.HUGHES.
MAIN     CSECT
         USING *,15
START    XREAD CARD,32       READ TOPAL JOB CARD
         BM STOP             BRANCH ON /*
         CLC CARD(2),SIGN    $$  ???
         BE PRINT
         B LOAD
STOP     XPRNT =C'1ALL TOPAL PROGRAMS PROCESSED',28
         BR 14               ALL TOPAL PROCESSED
PRINT    XPRNT =C'1****TOPAL****TOPAL****TOPAL****TOPAL****',41
         XPRNT CARDT,33      READ TOPAL CARD
         L 4,=X'00000000'    SETTING SYMBOL
         L 6,=X'00000001'    TABLE TO BLANKS
         L 7,=X'000001F4'
         L 3,=V(SYMBOLT)     LOAD ADDRESS OF SYMBOL TABLE
BXL      MVI 0(3),C' '       MOVE BLANKS TO TABLE
         LA 3,1(3)
         BXLE 4,6,BXL        BRANCH TILL TABLE IS FULL
         L 4,=X'00000000'    SETTING CARDAREA
         L 6,=X'00000001'    TO BLANKS
         L 7,=X'00000640'
         L 5,=V(CARDAREA)    LOAD ADDRESS OF CARDAREA
BXT      MVI 0(5),C' '       MOVE BLANKS TO AREA
         LA 5,1(5)
         BXLE 4,6,BXT        BRANCH TILL FULL
         L 4,=X'00000000'
         L 6,=X'00000001'
         L 7,=X'00000320'    SETTING CODEAREA TO
         L 10,=V(CODEAREA)   BLANKS
BXD      MVI 0(10),C' '      MOVE BLANKS
         LA 10,1(10)
         BXLE 4,6,BXD
LOAD     L 4,ZERO            SETTING LOCATION COUNTER TO ZERO
         L 10,=V(CODEAREA)   LOAD ADDRESS OF CODEAREA
         L 5,=V(CARDAREA)    LOAD ADDRESS OF CARDAREA
CID      XREAD CARD,32       READ TOPAL CARD
         MVC 0(32,5),CARD    MOVE CARD IMAGE TO CARDAREA
         MVI 31(5),X'00'     SET FLAG TO 0
         CLI CARD,C'*'       COMMENT CARD
         BE A
         B B                 NOT COMMENT CARD
A        LA 5,32(5)          UPDATE CARDAREA
         B CID               READ ANOTHER CARD
B        CLC CARD+9(3),END   END CARD ?
         BE PASS2
         L 7,=V(LOOKUP)      LOAD ADDRESS OF LOOKUP TABLE
         BALR 11,7
         LA 5,32(5)          UPDATE CARDAREA
         B CID
PASS2    L 10,=V(CODEAREA)   LOAD REGISTERS FOR PASS 2
         MVI 31(5),X'00'     SET END CARD TO NO ERRORS
         L 5,=V(CARDAREA)
         L 4,ZERO
AAT      LA 6,PRNT-3         LOAD ADDRESS OF AREA TO PRINT OUT OF
         MVC 0(31,6),0(5)    MOVE CARD IMAGE TO PRINT AREA
         XPRNT PRNTT,32      PRINT CARD IMAGE
         CLI 0(5),C'*'       COMMENT CARD ?
         BE AAY
         CLI 31(5),X'40'     ILLEGAL OPCODE ?
         BE AAA
         CLI 31(5),X'00'     NO ERRORS ?
         BE AAD
         CLI 31(5),X'80'     ILLEGAL OPCODE AND MULTI SYMBOL ?
         BE AAC
         CLI 31(5),X'C0'     MULTI SYMBOL ?
         BE AAZ
AAA      XPRNT =C'0ERROR******ILLEGAL OPCODE******ERROR',37
         MVI EX,X'FF'        NO EXECUTE
         B AAY
AAC      XPRNT =C'0ERROR*****MULTIPLY DEFINED SYMBOL AND ILLEGAL OPCODEX
               ******ERROR',64
         MVI EX,X'FF'        NO EXECUTE
         B AAY
AAZ      XPRNT =C'0ERROR****MULTIPLY DEFINED SYMBOL IN LABEL FIELD****EX
               RROR',57
         MVI EX,X'FF'        NO EXECUTE
AAY      LA 5,32(5)          UPDATE CARDAREA
         B AAT
AAD      CLI 0(5),C'*'       COMMENT CARD ?
         BNE AAQ
         LA 5,32(5)          UPDATE CARDAREA
         B AAT
AAQ      CLC 9(3,5),END      END STATEMENT ?
         BNE AAM
         B EXEC              IS END CATD SO EXECUTE PROGRAM
AAM      CLC 9(4,5),STP      STOP CARD ?
         BNE AAN
         A 4,=X'00000002'    STOP CARD SO UPDATE LOCATION COUNTER
         LA 10,2(10)         UPDATE CODEAREA
         LA 5,32(5)          UPDATE CARDAREA
         B AAT
AAN      CLC 9(4,5),SPP      DCON CARD ?
         BNE AAW
         ST 4,TEST           DCON CARD SO TEST TO SEE IF ON FULL WORD
         TM TEST+3,B'00000011'
         BZ TUM              ON FULL WORD
         LA 10,2(10)         NOT FULLWORD SO UPDATE TO FULLWORD
         A 4,=X'00000002'    LOCATION COUNTER
TUM      LA 5,32(5)          UPDATE CARDAREA
         LA 10,4(10)         UPDATE CODEAREA
         A 4,=X'00000004'
         B AAT
AAW      L 3,=V(SYMBOLT)     LOAD ADDRESS OF SYMBOL TABLE
AAAB     CLC 14(8,5),0(3)    OPERAND IN TABLE ?
         BE AAU
         CLI 0(3),C' '       END OF TABLE ?
         BE AAAA
         LA 3,10(3)          UPDATE SYMBOL TABLE
         B AAAB
AAAA     XPRNT =C'0ERROR*****ILLEGAL OPERAND*****ERROR',37
         MVI EX,X'FF'        NO EXECUTE
         LA 5,32(5)          UPDATE CARDEEA
         B AAT
AAU      MVC DISA(1),9(3)    MOVE ADDRESS OF  OPERAND TO STORAGE
         CLC 9(3,5),A3       BRM CARD ?
         BE GOAH
         CLC 9(2,5),A7       BR CARD ?
         BNE GOAHD
         CLI 8(3),X'00'      INSTRUVTION ?
         BE GOAH3
         XPRNT =C'0ERROR****BRANCH TO DATA AREA****ERROR',38
         B GOAH
GOAHD    CLI 8(3),X'80'      DATA AREA ?
         BNE GOAH1
         B GOAH
GOAH1    XPRNT =C'0ERROR****TREATING AN INSTRUCTION AS DATA****ERROR',5X
               0
GOAH     L 3,=V(SYMBOLT)     LOAD ADDRESS OF SYMBOL TABLE
         CLI 23(5),X'40'     SECOND OPERAND OR NOT ?
         BE GOAH3
AAAC     CLC 23(8,5),0(3)    OPERAND IN TABLE ?
         BE OR
         CLI 0(3),C' '       END OF TABLE ?
         BE AAAA
         LA 3,10(3)          UPDATE SYMBOL TABLE
         B AAAC
OR       MVC DISB(1),9(3)    STORE ADDRESS OF SECOND OPERAND
         CLC 9(3,5),A3       BRM CARD ?
         BNE GOAHD1
         CLI 8(3),X'00'      INSTRUCTION ?
         BE GOAH3
         XPRNT =C'0ERROR****BRANCH TO DATA AREA****ERROR',38
         B GOAH3
GOAHD1   CLI 8(3),X'80'      DATA AREA ?
         BNE GOAH2
         B GOAH3
GOAH2    XPRNT =C'0ERROR****TREATING AN INSTRUCTION AS DATA****ERROR',5X
               0
GOAH3    CLC 9(3,5),A1       ADD CARD ?
         BE A11
         CLC 9(3,5),A2       DIV CARD ?
         BE A12
         CLC 9(3,5),A3       BRM CARD ?
         BE A13
         CLC 9(3,5),A4       SUB CARD ?
         BE A14
         CLC 9(3,5),A5       OUT CARD ?
         BE A15
         CLC 9(4,5),A6       MOVE CARD ?
         BE A16
         CLC 9(2,5),A7       BR CARD ?
         BE A17
         CLC 9(3,5),A9       MUL CARD ?
         BE A18
         CLC 9(2,5),A10      IN CARD ?
         BE A19
         XPRNT =C'0ERROR*****ILLEGAL OPCODE*****ERROR',36
         LA 5,32(5)          UPDATE CARDAREA
         B AAT
A11      OC 3(1,10),DISA     OR IN ADDRESSES INTO MACHINE CODE AREA
         OC 7(1,10),DISB
         OC 11(1,10),DISA
         LA 10,12(10)
         A 4,=X'0000000C'
         LA 5,32(5)
         B AAT
A12      OC 3(1,10),DISA     OR IN ADDRESS INTO MACHINE CODE AREA
         OC 11(1,10),DISB
         OC 15(1,10),DISA
         LA 10,16(10)
         A 4,=X'0000000F'
         LA 5,32(5)
         B AAT
A13      OC 3(1,10),DISA     OR IN ADDRESS INTO MACHINE CODE AREA
         OC 9(1,10),DISB
         LA 10,10(10)
         A 4,=X'0000000A'
         LA 5,32(5)
         B AAT
A14      OC 3(1,10),DISA     OR IN ADDRESS INTO MACHINE CODE AREA
         OC 7(1,10),DISB
         OC 11(1,10),DISA
         LA 10,12(10)
         A 4,=X'0000000C'
         LA 5,32(5)
         B AAT
A15      OC 3(1,10),DISA     OR IN ADDRESS INTO MACHINE CODE AREA
         LA 10,6(10)
         A 4,=X'00000006'
         LA 5,32(5)
         B AAT
A16      OC 3(1,10),DISA     OR IN ADDRESS INTO MACHINE CODE AREA
         OC 5(1,10),DISB
         LA 10,6(10)
         A 4,=X'00000006'
         LA 5,32(5)
         B AAT
A17      OC 3(1,10),DISA     OR IN ADDRESS INTO MACHINE CODE AREA
         LA 10,4(10)
         A 4,=X'00000004'
         LA 5,32(5)
         B AAT
A18      OC 3(1,10),DISA     OR IN ADDRESS INTO MACHINE CODE AREA
         OC 7(1,10),DISB
         OC 11(1,10),DISA
         LA 10,12(10)
         A 4,=X'0000000C'
         LA 5,32(5)
         B AAT
A19      OC 3(1,10),DISA     OR IN ADDRESS INTO MACHINE CODE AREA
         LA 10,6(10)
         A 4,=X'00000006'
         LA 5,32(5)
         B AAT
EXEC     CLI EX,X'FF'        EXECUTE ?
         BNE QTGO
         XPRNT =C'0PROGRAM TERMINATION DUE TO ERROR IN PROGRAM',44
QT       XREAD CARD,32       READ TOPAL DATA CARDS TILL $* CARD
         CLC CARD(2),FT      $*  ???
         BE FTA
         B QT
FTA      B START
QTGO     L 10,=V(CODEAREA)   LOAD ADDRESS OF CODEAREA
         XPRNT =C'0GENERATED CODE FOR TOPAL PROGRAM',33
         XDUMP 0(10),200     DUMP CODAREA
         L 8,=V(INPUT)       LOAD ADDRESS OF INPUT ROUTINE
         L 9,=V(OUTPUT)      LOAD ADDRESS OF OUTPUT ROUTINE
         BALR 11,10
         L 10,=V(CODEAREA)   LOAD ADDRESS OF CODEAREA
         XPRNT =C'0GENERATED CODE FOR TOPAL PROGRAM',33
         XDUMP 0(10),200     DUMP CODEAREA
         XREAD CARD,32       READ TOPAL CARD
         CLC CARD(2),FT      $$  ???
         BE START
         XPRNT =C'0PROGRAM TERMINATED BEFORE ALL DATA READ',43
PDQ      XREAD CARD,32       READ TOPAL CARDS TILL $* CARD
         CLC CARD(2),FT      $*  ???
         BE START
         B PDQ
SIG      DC C'/*'
SIGN     DC C'$$'
END      DC C'END'
CARDT    DC C'0'
CARD     DC 32C' '
         DS 0F
ZERO     DC X'00000000'
PRNTT    DC C'0'
PRNT     DS 32F
EX       DS F
STP      DC C'STOP'
SPP      DC C'DCON'
DISA     DS F
DISB     DS F
TEST     DS F'0'
A1       DC C'ADD'
A2       DC C'DIV'
A3       DC C'BRM'
A4       DC C'SUB'
A5       DC C'OUT'
A6       DC C'MOVE'
A7       DC C'BR'
A9       DC C'MUL'
A10      DC C'IN'
FS       DC  X'FF'
FT       DC C'$*'
         LTORG
         SPACE 5
LOOKUP   CSECT               LOOKUP ROUTINE
         STM 14,12,12(13)    STORE REGISTERS
         BALR 7,0
         USING *,7
         CLC 9(4,5),DCON     DCON CARD ?
         BE ET
         CLI 0(5),X'40'      LABEL ?
         BE G
ET       L 3,=V(SYMBOLT)     LOAD ADDRESS OF SYMBOL TABLE
         CLI 0(5),X'40'      LABEL ?
         BE DCO
E        CLI 0(3),C' '       LABEL IN TABLE ?
         BE D
         CLC 0(8,5),0(3)     CARD LABEL EQUAL TO  TABLE LABEL
         BE FALSE
         LA 3,10(3)          UPDATE SYMBOL TABLE
         B E
FALSE    MVI 31(5),X'80'     MULTIPLY DEFINED LABEL
         B G
D        MVC 0(8,3),0(5)     MOVE LABEL TO SYMBOL TABLR
DCO      CLC 9(4,5),DCON     DCON CARD ?
         BE F
         ST 4,QR             STORE LOCATION COUNTER
         LA 9,QR
         MVC 8(2,3),2(9)     MOVE ADDRESS INTO SYMBOL TABLE
         MVI 8(3),X'00'      INSTRUCTION
         B G
F        CLI 0(5),X'40'      ILLEGAL  OPCODE ?
         BE H
H        XDECI 12,14(5)
         ST 12,CVB           CONVERT TO BINARY THE  DCON
         ST 4,TESTT          TEST LOCATION COUNTER FOR FULLWORD
         TM TESTT+3,B'00000011'
         BZ TUMM
         LA 10,2(10)         NOT FULLWORD SO UPDATE
         A 4,=X'00000002'
TUMM     MVC 0(4,10),CVB     MOVE DCON TO CODEAREA
         ST 4,QR             STORE LOCATION COUNTER
         LA 9,QR
         MVC 8(2,3),2(9)     MOVE ADDRESS TO SYMBOL TABLE
         MVI 8(3),X'80'      DATA AREA
         LA 10,4(10)
         A 4,=X'00000004'
         BR 11
G        L 9,=V(CODEAR)      LOAD ADDRESS OF CODE ROUTINE
         BR 9
DCON     DC C'DCON'
CVB      DS F
QR       DS F
TESTT    DS F'0'
         LTORG
         SPACE 5
CODEAR   CSECT               CODE ROUTINE
         STM 14,12,12(13)
         BALR 7,0
         USING *,7
         CLC 9(3,5),AB       ADD CARD ?
         BE K
         CLC 9(3,5),BB       DIV CARD ?
         BE M
         CLC 9(3,5),CB       BRM CARD ?
         BE C1
         CLC 9(3,5),DB       SUB CARD ?
         BE D1
         CLC 9(3,5),EB       OUT CARD ?
         BE E1
         CLC 9(4,5),FB       MOVE CARD ?
         BE F1
         CLC 9(2,5),GB       BR CARD ?
         BE G1
         CLC 9(4,5),HB       STOP CARD ?
         BE H1
         CLC 9(3,5),IB       MUL CARD ?
         BE I
         CLC 9(2,5),JB       IN CARD ?
         BE J
         CLI 31(5),X'80'     DATA  MULTIPLY DEFINED LABEL ?
         BE CS
         MVI 31(5),X'40'     ILLEGAL OPCODE
         B CP
CS       MVI 31(5),X'C0'     MOVE ERROR FLAG TO CARD AREA
CP       BR 11
K        MVC 0(12,10),Z      MOVE MACHINE CODE TO CODEAREA
         LA 10,12(10)
         A 4,=X'0000000C'
         B L
M        MVC 0(16,10),Y      MOVE MACHINE CODE TO CODEAREA
         LA 10,16(10)
         A 4,=X'0000000F'
         B L
C1       MVC 0(10,10),X      MOVE MACHINE CODE TO CODE AREA
         LA 10,10(10)
         A 4,=X'0000000A'
         B L
D1       MVC 0(12,10),W      MOVE MACHINE CODE TO CODEAREA
         LA 10,12(10)
         A 4,=X'0000000C'
         B L
E1       MVC 0(6,10),V       MOVE MACHINE CODE TO CODEAREA
         LA 10,6(10)
         A 4,=X'00000006'
         B L
F1       MVC 0(6,10),U       MOVE MACHINE CODE TO CODEAREA
         LA 10,6(10)
         A 4,=X'00000006'
         B L
G1       MVC 0(4,10),T       MOVE MACHINE CODE TO CODEAREA
         LA 10,4(10)
         A 4,=X'00000004'
         B L
H1       MVC 0(2,10),S       MOVE MACHINE CODE TO CODEAREA
         LA 10,2(10)
         A 4,=X'00000002'
         B L
I        MVC 0(12,10),R      MOVE MACHINE CODE TO CODEAEA
         LA 10,12(10)
         A 4,=X'0000000C'
         B L
J        MVC 0(6,10),Q       MOVE MACHINE CODE TO CODEAREA
         LA 10,6(10)
         A 4,=X'00000006'
L        BR 11               RETURN TO MAIN CSECT
AB       DC C'ADD'
BB       DC C'DIV'
CB       DC C'BRM'
DB       DC C'SUB'
EB       DC C'OUT'
FB       DC C'MOVE'
GB       DC C'BR'
HB       DC C'STOP'
IB       DC C'MUL'
JB       DC C'IN'
Z        DC X'5800A0005A00A0005000A000'
Y        DC X'5800A0008E00A0205D00A0005010A000'
X        DC X'5800A00012004740A000'
W        DC X'5800A0005B00A0005000A000'
V        DC X'5810A0000579'
U        DC X'D203A000A000'
T        DC X'47F0A000'
S        DC X'07FB'
R        DC X'5810A0005C00A0005010A000'
Q        DC X'4110A0000578'
         LTORG
         SPACE 5
INPUT    CSECT               INPUT ROUTINE
         STM 14,12,12(13)
         BALR 12,0
         USING *,12
         LR 6,1              LOAD REGISTER WITH ADDRESS OF DATA AREA
         XREAD CARD1,32      READ TOPAL DATA CARD
         CLC CARD1(2),SIG1   $*  ???
         BNE GO
         L 10,=V(CODEAREA)   LOAD ADDRESS OF CODEAREA
         XDUMP 0(10),200     DUMP CODEAREA
         XPRNT =C'0ATTEMPT TO READ BEYOND END OF DATA',35
         BR 11
GO       XDECI 12,CARD1      CONVERT DATA TO BINARY
         ST 12,0(6)          STORE BINARY DATA IN DATA AREA
         BR 7
SIG1     DC C'$*'
CARD1    DC 32C' '
         LTORG
         SPACE 5
OUTPUT   CSECT               OUTPUT ROUTINE
         STM 14,12,12(13)
         BALR 2,0
         USING *,2
         XDECO 1,OUTNUM      CONVERT OUTPUT TO DECIMAL
         XPRNT =C'0TOPAL PROGRAM OUTPUT',21
         XPRNT OUT           PRINT OUTPUT
         BR 7
OUT      DC C'0'
OUTNUM   DC 12C' '
         DC 120C' '
         LTORG
         SPACE 5
CODEAREA CSECT               STORAGE FOR MACHINE CODE GENERATED
         DS 0F
         DS 200CL4' '
         SPACE 5
CARDAREA CSECT               STORAGE FOR TOPAL CARDS READ
         DS 0F
         DS 400CL4' '
         SPACE 5
SYMBOLT  CSECT               STORAGE FOR SYMBOL TABLE
         DS 0F
         DS 125CL4' '
         END
$ENTRY
$$     SMITH, JOHN- JOB 1
* THIS IS PROGRAM NUMBER 1
* RECOGNIZE THIS ONE ?
* COMPUTE N!
*        *    *        *
         IN   N
         OUT  N
         MOVE NFAC     N
         MOVE M        N
         SUB  N        ONE
* LOOP TO DO COMPUTATION
LOOP     SUB  N        ONE
         BRM  N        DONE
         SUB  M        ONE
         MUL  NFAC     M
         BR   LOOP
DONE     OUT  NFAC
         STOP
N        DCON 0
M        DCON 0
NFAC     DCON 0
ONE      DCON 1
         END
     5
$*
$$    HOOVER,JAMES-JOB 1
* THIS IS PROGRAM NUMBER 2
* PROGRAM FINDS MAX & MIN OF SET
* OF INTEGERS<10000000. MIN IS
* MULT BY 5,MAX IS DIV BY 4
* AND SUM OF RESULTS PRINTED. -1
* READ IN HALTS PROGRAM
*        *    *        *
LOOP1    IN   N
         BRM  N        QUIT
         MOVE TEMP     N
         SUB  TEMP     MAX
* IF NEG RESULT OLD MAX STANDS
         BRM  TEMP     TRYMIN
         MOVE MAX      N
TRYMIN   MOVE TEMP     N
         SUB  TEMP     MIN
* IF NEG RESULT THEN NEW MIN
         BRM  TEMP     NEWMIN
         BR   LOOP1
NEWMIN   MOVE MIN      N
         BR   LOOP1
N        DCON 0
MAX      DCON -4
MIN      DCON 10000000
TEMP     DCON 0
FOUR     DCON 4
FIVE     DCON 5
QUIT     MUL  MIN      FIVE
         DIV  MAX      FOUR
         ADD  MIN      MAX
         OUT  MIN
         STOP
         END
200   DATA
         20     DATA
                5000      DATA
  18    DATA
         64     DATA
     2    DATA
          -1       DATA TRAILER
$*
$$    HAGG,JOSEPH-JOB 1
* PROGRAM NUMBER 2 WITH ERRORS
*        *    *        *
LOOP1    IN   N
         BRM  N        QUIT
         MOVE TEMP     N
         SUB  TEMP     MAX
* IF NEG RESULT OLD MAX STANDS
         BRM  TEMP     TRYMIN
         MOVE MAX      N
TRYMIN   MOVE TEMP     N
         SUB  TEMP     TRYMIN
* IF NEG RESULT THEN NEW MIN
         BRM  TEMP     NEWMIN
         BR   MAX
NEWMIN   MOVE MIN      N
         BR   LOOP1
N        DCON 0
MAX      DCON -4
TEMP     DCON 0
FOUR     DCON 4
FIVE     DCON 5
MAX      DCON 1000000
QUIT     MUL  MIN      FIVE
         STM  MAX      FOUR
         ADD  MIN      MAX
         OUT  MIN
         STOP
         END
200   DATA
         20     DATA
                5000      DATA
  18    DATA
         64     DATA
     2    DATA
          -1       DATA TRAILER
$*
$$    WILSON,DUD-JOB 1
* PROGRAM NUMBER 1 WITH ERRORS
*        *    *        *
         IN   N
         OUT  N
         MOVE NFAC     N
         MOVE M        N
         SUB  N        ONE
* LOOP TO DO COMPUTATION
LOOP     SUB  N        ONE
         BRM  DONE
         SUB  M        ONE
         MUL  NFAC     M
         BR   POOL
DONE     OUT  NFAC
         STOP
N        DCON 0
M        DCON 0
NFAC     DCON 0
ONE      DCON 1
         END
    5
$*
$JOB   ASSIST  PROGTEST
*        *** FINAL PROJECT - FIRST ASSEMBLER COURSE.
*        493 STMTS, , EXECUTES 14375 INSTRUCTIONS, THEN TERMINATES
*        *** WITH 0C4 AND DUMPS.
*        CMPSC 410.1 - FALL 1970 - PSU-INSTRUCTOR -C.HUGHES.
TOPAL    CSECT
         B         10(,15)
         DC        X'05'
         DC        CL5'TOPAL'
         STM       14,12,12(13)
         BALR      12,0
         USING     *,12              SET UP BASE REG.
PASSTWO  LR        5,13
         LA        13,SAVE
         ST        13,8(5)
         ST        5,4(13)
TOPALX   XREAD     CARD,80           READ FOR JOB CARD OR /* CARD
         BZ        TEST              IF NOT /* CARD BRANCH TO TEST
         XPRNT     =C'1ALL JOBS HAVE BEEN PROCESSED,CONTROL BEING RETURN
               NED TO ASSEMBLER',65
         B         RESTORE
TEST     CLC       CARD(2),=C'$$'    TEST FOR JOB CARD
         BE        GO                IF JOB CARD GO AHEAD
         XPRNT     =C'1****ABNORMAL TERMINATION-NO JOB CARD',37
         B         RESTORE           RETURN CONTROL TO ASSEMBLER
GO       XPRNT     =C'1',1           SKIP TOP OF PAGE
         XPRNT     CARD-1,81         PRINT USER JOB AND ID CARD
*      INITIALIZE  SYMBOL TABLE TO BLANKS
         L         2,=V(SYMBOLTB)    LOAD ADDRESS OF SYMBOL TABLE
         L         3,=F'125'
         L         4,=C'    '
BLNKOUT  ST        4,0(2)            STORE BLANKS
         LA        2,4(2)            INCREMENT REGISTER
         BCT       3,BLNKOUT         DECREASE COUNTER BY ONE
* INITIALIZE CODE AREA TO HEX F'S
         L         2,=V(CODETB)      LOAD ARDRESS OF CODE TABLE
         L         4,=X'FFFFFFFF'    LOAD REGISTER WITH HEX F'S
         L         3,=F'200'
FOUT     ST        4,0(2)            LOAD TABLE INITIALLY
         LA        2,4(2)            INCREMENT
         BCT       3,FOUT            SUB. ONE FROM COUNTER
* INITIALIZE CARD AREA TO BLANKS
         L         2,=V(CARDTB)      LAOD ADDRESS OF CARD TABLE
         L         3,=F'400'
         L         4,=C'    '        LOAD REG. WITH BLANKS
BOUT     ST        4,0(2)            LOAD TABLE
         LA        2,4(2)            INCREMENT TABLE ADDRESS
         BCT       3,BOUT            SUB ONE FROM COUNTER
         L         6,=C'GO  '        LOAD REG TO SHOW GO WITH EXECUTION
* READ IN TOPAL CARDS
         L         10,=V(CODETB)     LOAD ADDRESS OF CODETABLE
         L         5,=V(CARDTB)      LOAD ADDRESS OF CARD TABLE
         USING     CARDFORM,5        FLOATING DSECT OVER CARD TABLE
         USING     CODEDS,10         FLOATING DSECT OVER CODE TABLE
         SR        3,3               ZERO OUT FOR LOCATION COUNTER
READCARD XREAD     CARDTP,31         READ IN TOPAL CARD
         MVC       LABEL(31),CARDTP  PUT IN CARD TABLE
         CLI       CARDTP,C'*'       COMMENT CARD ?
         BNE       ENDCD             NO,TEST FOR END CARD
         LA        5,32(5)           INCREMENT CARD TABLE ADDRESS
         B         READCARD          READ IN NEXT CARD
ENDCD    CLC       =CL5'END',OPCODE  END CARD ?
         BNE       LABELED
         CL        6,=C'NOGO'
         BNE       PASS2
         OI        FLAG,B'00001000'
PASS2    L         15,=V(PASTWO)
         BALR      14,15
         B         TOPALX
LABELED  CLC       =CL9' ',LABEL     LABEL ?
         BE        DCONST
         L         2,=V(SYMBOLTB)    LOAD ADDRESS OF SYMBOL TABLE
         USING     SYMBOLDS,2        FLOATING DSECT OVER SYMBOL TABLE
TESTSBL  CLC       =CL8' ',SYMBOL    TEST FOR NO SYMBOL IN TABLE
         BE        STORESBL
         CLC       SYMBOL(8),LABEL   TEST FOR DUPLICATE LABEL
         BNE       INCRE
         L         6,=C'NOGO'        NO EXECUTION
         OI        FLAG,B'00001000'  FLAG CARD AREA
         B         DCONST
INCRE    LA        2,10(2)           INCREMENT ADDRESS
         B         TESTSBL
STORESBL MVC       SYMBOL(8),LABEL   PUT LABEL IN SYMBOL TABLE
         CLC       =CL5'DCON',OPCODE TEST IF DCON
         BE        STDC
         STH       3,FLDISP          ENTER DISPLACEMENT
         B         DCONST
STDC     LCR       9,3               SET TO FULL WORD BOUNDARY
         N         9,=X'00000003'
         AR        3,9
         STH       3,FLDISP          ENTER DISPLACEMENT
         OI        FLDISP,B'10000000' SET FLAG THAT DCON
         B         CONVERT
DCONST   CLC       =CL5'DCON',OPCODE  DCON?
         BNE       NOTDCON
CONVERT  XDECI     7,OPND1
         LCR       9,10              SET TO FULL WORD BOUNDARY
         N         9,=X'00000003'
         AR        10,9
         ST        7,CODE             STORE VALUE OF DCON IN CODE AREA
         LA        3,4(3)            INCRE LOC COUNTER
         LA        10,4(10)          INCRE TABLE ADDRESS
         LA        5,32(5)           INCREMENT CARD TABLE ADDRESS
         B         READCARD
NOTDCON  CLC       =CL5'ADD',OPCODE  ADD INST ?
         BNE       NOTADD
         MVC       CODE(L'ADD),ADD   MOVE ADD CODE INTO TABLE
INCRECT  LA        3,12(3)           INCRE LOC COUNTER
         LA        10,12(10)         INCRE TABLE ADD.
         LA        5,32(5)           INCREMENT CARD TABLE ADDRESS
         B         READCARD
NOTADD   CLC       =CL5'SUB',OPCODE  SUB INST ?
         BNE       NOTSUB
         MVC       CODE(L'SUB),SUB    MOVE SUB CODE INTO TABLE
         B         INCRECT
NOTSUB   CLC       =CL5'MUL',OPCODE  MUL INST ?
         BNE       NOTMUL
         MVC       CODE(L'MUL),MUL   MOVE CODE INTO TABLE
         B         INCRECT
NOTMUL   CLC       =CL5'DIV',OPCODE  DIVIDE INST ?
         BNE       NOTDIV
         MVC       CODE(L'DIV),DIV   MOVE CODE ONTO TABLE
         LA        3,16(3)           INCRE LOC COUNTER
         LA        10,16(10)         INCRE ADDRESS
         LA        5,32(5)           INCREMENT CARD TABLE ADDRESS
         B         READCARD
NOTDIV   CLC       =CL5'OUT',OPCODE  OUT INST ?
         BNE       NOTOUT
         MVC       CODE(L'OUT),OUT   MOVE CODE INTO TABLE
INOUT    LA        3,6(3)            INCRE LOC COUNTER
         LA        10,6(10)          INCRE ADDRESS
         LA        5,32(5)           INCREMENT CARD TABLE ADDRESS
         B         READCARD
NOTOUT   CLC       =CL5'IN',OPCODE   IN INST ?
         BNE       NOTIN
         MVC       CODE(L'IN),IN     LOAD CODE INTO TABLE
         B         INOUT
NOTIN    CLC       =CL5'BRM',OPCODE  BRM INST ?
         BNE       NOTBRM
         MVC       CODE(L'BRM),BRM   MOVE CODE INTO TABLE
         LA        3,10(3)           INCRE LOC COUNTER
         LA        10,10(10)         INCRE ADDRESS
         LA        5,32(5)           INCREMENT CARD TABLE ADDRESS
         B         READCARD
NOTBRM   CLC       =CL5'BR',OPCODE   BR INST ?
         BNE       NOTBR
         MVC       CODE(L'BR),BR
         LA        3,4(3)            INCRE LOC COUNTER
         LA        10,4(10)          INCRE ADDRESS
         LA        5,32(5)           INCREMENT CARD TABLE ADDRESS
         B         READCARD
NOTBR    CLC       =CL5'MOVE',OPCODE  MOVE INST ?
         BNE       NOTMOVE
         MVC       CODE(L'MOVE),MOVE  MOVE CODE INTO TABLE
         B         INOUT
NOTMOVE  CLC       =CL5'STOP',OPCODE    STOP INST ?
         BNE       NOTANY
         MVC       CODE(L'STOP),STOP
         LA        3,2(3)            INCRE LOC COUNTER
         LA        10,2(10)          INCRE ADDRESS
         LA        5,32(5)           INCREMENT CARD TABLE ADDRESS
         B         READCARD
NOTANY   L         6,=C'NOGO'
         OI        FLAG,B'00000100'  SET FLAG,ILLEGAL OPCODE
         LA        5,32(5)           INCREMENT CARD TABLE ADDRESS
         B         READCARD
RESTORE  L         13,4(13)
         LM        2,12,28(13)
         L         14,12(13)
         MVI       12(13),X'FF'
         B         14
SAVE     DC        18F'0'
ADD      DC        X'5800A0005A00A0005000A000'
SUB      DC        X'5800A0005B00A0005000A000'
MUL      DC        X'5810A0005C00A0005010A000'
DIV      DC        X'5800A0008E0000205D00A0005010A000'
OUT      DC        X'5810A0000579'
IN       DC        X'4110A0000578'
BRM      DC        X'5800A00012004740A000'
MOVE     DC        X'D203A000A000'
BR       DC        X'47F0A000'
STOP     DC        X'07FB'
         DC        C' '
CARD     DS        80C
CARDTP   DS        31C
         LTORG
PASTWO   CSECT
         B         12(,15)
         DC        X'07'
         DC        CL7'PASTWO'
         STM       14,12,12(13)
         BALR      12,0
         USING     *,12
         LA        8,INPUT           LOAD ADD OF INPUT
         LA        9,OUTPUT          LOAD ADD OF OUTPUT
         L         6,=C'GO  '        DETERMINES EXECUTION
         L         10,=V(CODETB)     LOAD ADD OF CODE TABLE
         L         5,=V(CARDTB)      LOAD ADD OF CARD TABLE
         USING     CARDFORM,5        FLOATING DSECT OVER CARD TABLE
         USING     CODEDS,10         FLOATING DSECT OVER CODE TABLE
         B         *+8               BRANCH AROUND INCREMENT
READTB   LA        5,32(5)           INCRE CARD TABLE LOC
         MVC       PRNTLB(31),LABEL
         XPRNT     PRNTLB-1,32       PRINT CARD IMAGE
         CLI       FLAG,X'40'        TEST FOR ERROR PASSONE
         BE        COMMENT           NO ERRORS PASSONE
         CLI       FLAG,X'44'        ILLEGAL OPCODE ?
         BNE       TESTC0
         XPRNT     =C' **** ILLEGAL  OPCODE',21
         B         READTB            READ NEXT CARD IMAGE
TESTC0   CLI       FLAG,X'4C'        ERROR?
         BNE       READTB            READ NEXT CARD IMAGE
         XPRNT     =C' **** MULTIPLY  DEFINED SYMBOL &&ILLEGAL OPCODE',4
               48
         B         READTB            READ NEXT CARD IMAGE
COMMENT  CLI       LABEL,C'*'        COMMENT CARD ?
         BE        READTB            READ NEXT CARD IMAGE
         CLC      =CL5'END',OPCODE   END CARD ?
         BE        EXECUTE           EXECUTE PROGRAM
         CLC      =CL5'STOP',OPCODE  STOP CARD ?
         BNE       DCONSTX
         LA        10,2(10)
         B         READTB            READ NEXT CARD IMAGE
DCONSTX  CLC      =CL5'DCON',OPCODE  DCON CARD ?
         BNE       OPERANDS
         LCR       4,10              PUT ON FULL WORD BOUNDARY
         N         4,=X'00000003'
         AR        10,3
         LA        10,4(10)          INCRE CODE TABLE ADD
         B         READTB            READ NEXT CARD IMAGE
OPERANDS CLI       FLAG,X'48'        CORRECR LABEL ?
         B         *+10
         XPRNT     =C' **** MULTIPLY  DEFINED LABEL',29
         L         4,=X'0000000E'
         BAL       14,LOOKUP         DO LOOKUP FOR SYMBOL
         MVC       TEST1(2),FLDISP
         MVC       DISP1(2),FLDISP
         NI        TEST1,B'11110000'
         NC        DISP1,B'0000111111111111'
         L         4,=X'00000017'
         BAL       14,LOOKUP         DO SYMBOL LOOKUP
         MVC       TEST2(2),FLDISP
         MVC       DISP2(2),FLDISP
         NI        TEST2,B'11110000'
         NC        DISP2,B'0000111111111111'
         CLC      =CL5'ADD',OPCODE   ADD STATEMENT ?
         BE        AMSST
         CLC      =CL5'SUB',OPCODE   SUB ST ?
         BE        AMSST
         CLC      =CL5'MUL',OPCODE   MUL ST ?
         BE        AMSST
         CLC      =CL5'DIV',OPCODE   DIV ST ?
         BE        DIVST
         CLC      =CL5'OUT',OPCODE   OUT ST ?
         BE        OUTINST
         CLC      =CL5'IN',OPCODE    IN ST ?
         BE        OUTINST
         CLC      =CL5'BRM',OPCODE   BRM ST ?
         BE        BRMST
         CLC      =CL5'MOVE',OPCODE  MOVE ST ?
         BE        MOVEST
         CLI       TEST1,B'11000000'
         BNE       TESTAG
         LA        10,4(10)          INCRE CODE LOC
UNDSYMER XPRNT     =C' **** UNDEFINE D SYMBOL ERROR',29
         L         6,=C'NOGO'
         B         READTB            READ NEXT CARD IMAGE
TESTAG   CLI       TEST1,B'10000000'
         BNE       STBRCOD
         LA        10,4(10)
BRDCONER XPRNT     =C' **** ILLEGAL BRANCH TO DATA',28
         L         6,=C'NOGO'
         B         READTB            READ NEXT CARD IMAGE
STBRCOD  OC        CODE+2(2),DISP1   STORE DISP
         LA        10,4(10)
         B         READTB            READ NEXT CARD IMAGE
AMSST    CLI       TEST1,B'11000000'
         BNE       CAMS              TEST 2ND OPERAND
INAMS    LA        10,12(10)         INCRE LOC COUNTER
         B         UNDSYMER
CAMS     CLI       TEST2,B'11000000'  ILLEGAL OPND ?
         BE        INAMS
         CLI       TEST1,B'01000000'
         BNE       CCAMS
INCRAMS  LA        10,12(10)         INCRE LOC
LADCONER XPRNT     =C' **** LABEL USED AS DCON-ILLEGAL',32
         B         READTB            READ NEXT CARD IMAGE
CCAMS    CLI       TEST2,B'01000000'
         BE        INCRAMS
         OC        CODE+2(2),DISP1   STORE DISP
         OC        CODE+6(2),DISP2   STORE DISP
         OC        CODE+10(2),DISP1  STORE DISP
         LA        10,12(10)         INCRE LOC COUNTER
         B         READTB            READ NEXT CARD IMAGE
DIVST    CLI       TEST1,B'11000000'  ILL OPND ?
         BNE       CDIV              TEST 2ND OPND
INDIV    LA        10,16(10)         INCRE LOC COUNTER
         B         UNDSYMER
CDIV     CLI       TEST2,B'11000000'
         BE        INDIV
         CLI       TEST1,B'01000000'
         BNE       CCDIV
STDIV    LA        10,16(10)
         B         LADCONER
CCDIV    CLI       TEST2,B'01000000'
         BE        STDIV
         OC        CODE+2(2),DISP1
         OC        CODE+10(2),DISP2  STORE DISP
         OC        CODE+14(2),DISP1  STORE DISP
         LA        10,16(10)
         B         READTB            READ NEXT CARD IMAGE
OUTINST  CLI       TEST1,B'11000000'
         BNE       COUT
INOUTX   LA        10,6(10)
         B         UNDSYMER
COUT     CLI       TEST1,B'01000000'
         BNE       STINOUT
TSTMV    LA        10,6(10)
         B         LADCONER
STINOUT  OC        CODE+2(2),DISP1   STORE DISP
         B         READTB            READ NEXT CARD IMAGE
BRMST    CLI       TEST1,B'11000000'
         BNE       CBRM
STBRM    CLI       TEST1,B'01000000'
         BNE       STOBRM
         LA        10,10(10)
         B         LADCONER
CBRM     LA        10,10(10)
         B         UNDSYMER
         CLI       TEST2,B'11000000'
         BE        CBRM
         CLI       TEST2,B'10000000'  ILLEGAL BRANCH
         BNE       STBRM
         LA        10,10(10)
         B         BRDCONER
STOBRM   OC        CODE+2(2),DISP1   STORE DISP
         OC        CODE+8(2),DISP2   STORE DISP
         LA        10,10(10)
         B         READTB            READ NEXT CARD IMAGE
MOVEST   CLI       TEST1,B'11000000'
         BE        INOUTX
         CLI       TEST2,B'11000000'  ILL OPND
         BE        INOUTX
         CLI       TEST1,B'01000000'
         BE        TSTMV
         CLI       TEST2,B'01000000'
         BE        TSTMV
         OC        CODE+2(2),DISP1   STORE DISP
         OC        CODE+4(2),DISP2   STORE DISP
         LA        10,6(10)
         B         READTB            READ NEXT CARD IMAGE
LOOKUP   L         2,=V(SYMBOLTB)
         USING     SYMBOLDS,2        FLOATING DSECT OVER SYMBOL TABLE
         B         *+8
INCREX   LA        2,10(2)           INCRE LOC
         CLC      =CL8' ',SYMBOL     LOC BLANK ?
         BE        ERROR
         CLC       0(4,5),SYMBOL
         BNE       INCREX
         BR        14                RETURN
ERROR    OI        FLDISP,B'11000000' SET FLAG
         BR        14                RETURN
EXECUTE  CLI       FLAG,X'48'
         BE        TERMIN            TERMINAT PROGRAM
         ST        6,TEST3
         CLC      =CL4'NOGO',TEST3   TEST FOR ABORTION
         BNE       NOTERMIN
TERMIN   XPRNT     =C' ****PROGRAM  TERMINATED DUE TO ERRORS',38
READAG   XREAD     CARDX,80
         CLC      =CL2'$*',CARDX     $* CARD ?
         BNE       READAG            READ TILL FIND $* CARD
         B         RESTORE2          RETURN TO TOPAL
NOTERMIN L         10,=V(CODETB)     LOAD ADD CODE TABLE
         XPRNT     =C'1 DUMP OF CODE ',15
         XDUMP     0(10),800
         XPRNT     =C'1',1
         L         10,=V(CODETB)
         BALR      11,10             EXECUTE CODE
         XPRNT     =C'1 DUMP OF CODE ',15
         L         10,=V(CODETB)
         XDUMP     0(10),800
         XREAD     CARDX,80
         CLC      =CL2'$*',CARDX
         BE        RESTORE2
         XPRNT     =C' **** ERROR-AL L CARDS WERE NOT PROCESSED',41
         B         READAG
OUTPUT   L         1,0(1)
         XDECO     1,OUTX
         XPRNT     OUTX-1
         BR        7
INPUT    XREAD     CARDX,80
         CLC      =CL2'$*',CARDX
         BNE       CONVERTX
         XPRNT     =C' **** PROGRAM  ABORTED-READ BEYOND END OF FILE',46
               6
         XPRNT     =C'1  DUMP OF CODE',15
         L         10,=V(CODETB)
         XDUMP     0(10),800
         B         RESTORE2
CONVERTX LR        3,1
         L         3,0(3)
         XDECI     3,CARDX
         BR        7
RESTORE2 LM        2,12,28(13)
         L         14,12(13)
         BR        14
CARDX    DS        80C
TEST1    DC        H'0'
TEST2    DC        H'0'
DISP1    DC        H'0'
DISP2    DC        H'0'
TEST3    DC        F'0'
         DC        C' '
OUTX     DC        F'0'
         DC        C' '
PRNTLB   DS        31C
         LTORG
CODETB   CSECT
         DS        50CL16' '
CODEDS   DSECT
CODE     DS        CL16
SYMBOLTB CSECT
         DS        50CL10' '
SYMBOLDS DSECT
SYMBOL   DS        CL8
FLDISP   DS        CL2
CARDTB   CSECT
         DS        50CL32' '
CARDFORM DSECT
LABEL    DS        CL9
OPCODE   DS        CL5
OPND1    DS        CL9
OPND2    DS        CL8
FLAG     DS        CL1
         END
$ENTRY
$$             ' PROGRAM NUMBER 2 '
* THIS IS PROGRAM NUMBER 2
* PROGRAM FINDS MAX & MIN OF SET
* OF INTEGERS<10000000. MIN IS
* MULT BY 5,MAX IS DIV BY 4
* AND SUM OF RESULTS PRINTED. -1
* READ IN HALTS PROGRAM
*        *    *        *
LOOP1    IN   N
         BRM  N        QUIT
         MOVE TEMP     N
         SUB  TEMP     MAX
* IF NEG RESULT OLD MAX STANDS
         BRM  TEMP     TRYMIN
         MOVE MAX      N
TRYMIN   MOVE TEMP     N
         SUB  TEMP     MIN
* IF NEG RESULT THEN NEW MIN
         BRM  TEMP     NEWMIN
         BR   LOOP1
NEWMIN   MOVE MIN      N
         BR   LOOP1
N        DCON 0
MAX      DCON -4
MIN      DCON 10000000
TEMP     DCON 0
FOUR     DCON 4
FIVE     DCON 5
QUIT     MUL  MIN      FIVE
         DIV  MAX      FOUR
         ADD  MIN      MAX
         OUT  MIN
         STOP
         END
200   DATA
         20     DATA
                5000      DATA
  18    DATA
         64     DATA
     2    DATA
          -1       DATA TRAILER
$*
$$             ' PROGRAM NUMBER 3 '
* PROGRAM NUMBER 2 WITH ERRORS
*        *    *        *
LOOP1    IN   N
         BRM  N        QUIT
         MOVE TEMP     N
         SUB  TEMP     MAX
* IF NEG RESULT OLD MAX STANDS
         BRM  TEMP     TRYMIN
         MOVE MAX      N
TRYMIN   MOVE TEMP     N
         SUB  TEMP     TRYMIN
* IF NEG RESULT THEN NEW MIN
         BRM  TEMP     NEWMIN
         BR   MAX
NEWMIN   MOVE MIN      N
         BR   LOOP1
N        DCON 0
MAX      DCON -4
TEMP     DCON 0
FOUR     DCON 4
FIVE     DCON 5
MAX      DCON 1000000
QUIT     MUL  MIN      FIVE
         STM  MAX      FOUR
         ADD  MIN      MAX
         OUT  MIN
         STOP
         END
200   DATA
         20     DATA
                5000      DATA
  18    DATA
         64     DATA
     2    DATA
          -1       DATA TRAILER
$*
$$             ' PROGRAM NUMBER 4 '
* PROGRAM NUMBER 1 WITH ERRORS
*        *    *        *
         IN   N
         OUT  N
         MOVE NFAC     N
         MOVE M        N
         SUB  N        ONE
* LOOP TO DO COMPUTATION
LOOP     SUB  N        ONE
         BRM  DONE
         SUB  M        ONE
         MUL  NFAC     M
         BR   POOL
DONE     OUT  NFAC
         STOP
N        DCON 0
M        DCON 0
NFAC     DCON 0
ONE      DCON 1
         END
    5
$*
$JOB   ASSIST  PROGTEST
*        *** FINAL PROJECT - FIRST ASSEMBLER COURSE.  THIS IS A
*        FINAL WORKING VERSION OF THE PREVIOUS PROGRR
*        FINAL WORKING VERSION OF THE PREVIOUS PROGRAM.
*        545 STMTS,  PRINTS 10 PAGES, EXECUTES 26539 INSTRUCTIONS,
*        THEN QUITS NORMALLY.
*        CMPSC 410.1 - FALL 1970 - PSU-INSTRUCTOR -C.HUGHES.
TOPAL    CSECT
         B         10(,15)
         DC        X'05'
         DC        CL5'TOPAL'
         STM       14,12,12(13)
         BALR      12,0
         USING     *,12              SET UP BASE REG.
* SET UP REGISTER SAVE AREA
PASSTWO  LR        5,13
         LA        13,SAVE
         ST        13,8(5)
         ST        5,4(13)
* TEST AREA FOR /* CARD OR USER $$ JOB CARD
TOPALX   XREAD     CARD,80           READ FOR JOB CARD OR /* CARD
         BZ        TEST              IF NOT /* CARD BRANCH TO TEST
         XPRNT     =C'1ALL JOBS HAVE BEEN PROCESSED,CONTROL BEING RETURN
               NED TO ASSEMBLER',65
         B         RESTORE
TEST     CLC       CARD(2),=C'$$'    TEST FOR JOB CARD
         BE        GO                IF JOB CARD GO AHEAD
         XPRNT     =C'1****ABNORMAL TERMINATION-NO JOB CARD',37
         B         RESTORE           RETURN CONTROL TO ASSEMBLER
GO       XPRNT     =C'1',1           SKIP TOP OF PAGE
         XPRNT     CARD-1,81         PRINT USER JOB AND ID CARD
*      INITIALIZE  SYMBOL TABLE TO BLANKS
         L         2,=V(SYMBOLTB)    LOAD ADDRESS OF SYMBOL TABLE
         L         3,=F'125'
         L         4,=C'    '
BLNKOUT  ST        4,0(2)            STORE BLANKS
         LA        2,4(2)            INCREMENT REGISTER
         BCT       3,BLNKOUT         DECREASE COUNTER BY ONE
* INITIALIZE CODE AREA TO HEX F'S
         L         2,=V(CODETB)      LOAD ARDRESS OF CODE TABLE
         L         4,=X'FFFFFFFF'    LOAD REGISTER WITH HEX F'S
         L         3,=F'200'
FOUT     ST        4,0(2)            LOAD TABLE INITIALLY
         LA        2,4(2)            INCREMENT
         BCT       3,FOUT            SUB. ONE FROM COUNTER
* INITIALIZE CARD AREA TO BLANKS
         L         2,=V(CARDTB)      LAOD ADDRESS OF CARD TABLE
         L         3,=F'400'
         L         4,=C'    '        LOAD REG. WITH BLANKS
BOUT     ST        4,0(2)            LOAD TABLE
         LA        2,4(2)            INCREMENT TABLE ADDRESS
         BCT       3,BOUT            SUB ONE FROM COUNTER
         L         6,=C'GO  '        LOAD REG TO SHOW GO WITH EXECUTION
         EJECT
* READ IN TOPAL CARDS
         L         10,=V(CODETB)     LOAD ADDRESS OF CODETABLE
         L         5,=V(CARDTB)      LOAD ADDRESS OF CARD TABLE
         USING     CARDFORM,5        FLOATING DSECT OVER CARD TABLE
         USING     CODEDS,10         FLOATING DSECT OVER CODE TABLE
         SR        3,3               ZERO OUT FOR LOCATION COUNTER
* READ IN TOPAL CARD AND TEST PARAMETERS
READCARD XREAD     CARDTP,31         READ IN TOPAL CARD
         MVC       LABEL(31),CARDTP  PUT IN CARD TABLE
         CLI       CARDTP,C'*'       COMMENT CARD ?
         BNE       ENDCD             NO,TEST FOR END CARD
         LA        5,32(5)           INCREMENT CARD TABLE ADDRESS
         B         READCARD          READ IN NEXT CARD
ENDCD    CLC       =CL5'END',OPCODE  END CARD ?
         BNE       LABELED
         CL        6,=C'NOGO'
         BNE       PASS2
         OI        FLAG,B'00001000'
* BRANCH TO PASS TWO
PASS2    L         15,=V(PASTWO)
         BALR      14,15
         B         TOPALX
LABELED  CLC       =CL9' ',LABEL     LABEL ?
         BE        DCONST
* SYMBOL STORAGE ROUTINE
         L         2,=V(SYMBOLTB)    LOAD ADDRESS OF SYMBOL TABLE
         USING     SYMBOLDS,2        FLOATING DSECT OVER SYMBOL TABLE
TESTSBL  CLC       =CL8' ',SYMBOL    TEST FOR NO SYMBOL IN TABLE
         BE        STORESBL
         CLC       SYMBOL(8),LABEL   TEST FOR DUPLICATE LABEL
         BNE       INCRE
         L         6,=C'NOGO'        NO EXECUTION
         OI        FLAG,B'00001000'  FLAG CARD AREA
         B         DCONST
INCRE    LA        2,10(2)           INCREMENT ADDRESS
         B         TESTSBL
STORESBL MVC       SYMBOL(8),LABEL   PUT LABEL IN SYMBOL TABLE
         CLC       =CL5'DCON',OPCODE TEST IF DCON
         BE        STDC
         STH       3,FLDISP          ENTER DISPLACEMENT
         B         DCONST
STDC     LCR       9,3               SET TO FULL WORD BOUNDARY
         N         9,=X'00000003'
         AR        3,9
         STH       3,FLDISP          ENTER DISPLACEMENT
         OI        FLDISP,B'10000000' SET FLAG THAT DCON
         B         CONVERT
         SPACE     5
* TEST & STORE AREA FOR OPCODES
* TEST & STORE AREA FOR DCON OPCODE
DCONST   CLC       =CL5'DCON',OPCODE  DCON?
         BNE       NOTDCON
CONVERT  XDECI     7,OPND1
         LCR       9,10              SET TO FULL WORD BOUNDARY
         N         9,=X'00000003'
         AR        10,9
         ST        7,CODE             STORE VALUE OF DCON IN CODE AREA
         LA        3,4(3)            INCRE LOC COUNTER
         LA        10,4(10)          INCRE TABLE ADDRESS
         LA        5,32(5)           INCREMENT CARD TABLE ADDRESS
         B         READCARD
* TEST & STORE AREA FOR ADD OPCODE
NOTDCON  CLC       =CL5'ADD',OPCODE  ADD INST ?
         BNE       NOTADD
         MVC       CODE(L'ADD),ADD   MOVE ADD CODE INTO TABLE
INCRECT  LA        3,12(3)           INCRE LOC COUNTER
         LA        10,12(10)         INCRE TABLE ADD.
         LA        5,32(5)           INCREMENT CARD TABLE ADDRESS
         B         READCARD
* TEST & STORE AREA FOR SUBTRACT OPCODE
NOTADD   CLC       =CL5'SUB',OPCODE  SUB INST ?
         BNE       NOTSUB
         MVC       CODE(L'SUB),SUB    MOVE SUB CODE INTO TABLE
         B         INCRECT
* TEST & STORE AREA FOR MULTIPLY OPCODE
NOTSUB   CLC       =CL5'MUL',OPCODE  MUL INST ?
         BNE       NOTMUL
         MVC       CODE(L'MUL),MUL   MOVE CODE INTO TABLE
         B         INCRECT
* TEST & STORE AREA FOR DIVIDE OPCODE
NOTMUL   CLC       =CL5'DIV',OPCODE  DIVIDE INST ?
         BNE       NOTDIV
         MVC       CODE(L'DIV),DIV   MOVE CODE ONTO TABLE
         LA        3,16(3)           INCRE LOC COUNTER
         LA        10,16(10)         INCRE ADDRESS
         LA        5,32(5)           INCREMENT CARD TABLE ADDRESS
         B         READCARD
* TEST & STORE AREA FOR OUT OPCODE
NOTDIV   CLC       =CL5'OUT',OPCODE  OUT INST ?
         BNE       NOTOUT
         MVC       CODE(L'OUT),OUT   MOVE CODE INTO TABLE
INOUT    LA        3,6(3)            INCRE LOC COUNTER
         LA        10,6(10)          INCRE ADDRESS
         LA        5,32(5)           INCREMENT CARD TABLE ADDRESS
         B         READCARD
* TEST & STORE AREA FOR IN  OPCODE
NOTOUT   CLC       =CL5'IN',OPCODE   IN INST ?
         BNE       NOTIN
         MVC       CODE(L'IN),IN     LOAD CODE INTO TABLE
         B         INOUT
* TEST & STORE AREA FOR BRANCH ON MINUS OPCODE
NOTIN    CLC       =CL5'BRM',OPCODE  BRM INST ?
         BNE       NOTBRM
         MVC       CODE(L'BRM),BRM   MOVE CODE INTO TABLE
         LA        3,10(3)           INCRE LOC COUNTER
         LA        10,10(10)         INCRE ADDRESS
         LA        5,32(5)           INCREMENT CARD TABLE ADDRESS
         B         READCARD
* TEST & STORE AREA FOR BRANCH OPCODE
NOTBRM   CLC       =CL5'BR',OPCODE   BR INST ?
         BNE       NOTBR
         MVC       CODE(L'BR),BR
         LA        3,4(3)            INCRE LOC COUNTER
         LA        10,4(10)          INCRE ADDRESS
         LA        5,32(5)           INCREMENT CARD TABLE ADDRESS
         B         READCARD
* TEST & STORE AREA FOR MOVE OPCODE
NOTBR    CLC       =CL5'MOVE',OPCODE  MOVE INST ?
         BNE       NOTMOVE
         MVC       CODE(L'MOVE),MOVE  MOVE CODE INTO TABLE
         B         INOUT
* TEST & STORE AREA FOR STOP OPCODE
NOTMOVE  CLC       =CL5'STOP',OPCODE    STOP INST ?
         BNE       NOTANY
         MVC       CODE(L'STOP),STOP
         LA        3,2(3)            INCRE LOC COUNTER
         LA        10,2(10)          INCRE ADDRESS
         LA        5,32(5)           INCREMENT CARD TABLE ADDRESS
         B         READCARD
* TEST & STORE AREA FOR ILLEGAL OPCODE
NOTANY   L         6,=C'NOGO'
         OI        FLAG,B'00000100'  SET FLAG,ILLEGAL OPCODE
         LA        5,32(5)           INCREMENT CARD TABLE ADDRESS
         B         READCARD
* RESTORE REGISTERS AND RETURN CONTROL TO ASSEMBLER
RESTORE  L         13,4(13)
         LM        2,12,28(13)
         L         14,12(13)
         MVI       12(13),X'FF'
         BR        14
         EJECT
SAVE     DC        18F'0'
ADD      DC        X'5800A0005A00A0005000A000'
SUB      DC        X'5800A0005B00A0005000A000'
MUL      DC        X'5810A0005C00A0005010A000'
DIV      DC        X'5800A0008E0000205D00A0005010A000'
OUT      DC        X'5810A0000579'
IN       DC        X'4110A0000578'
BRM      DC        X'5800A00012004740A000'
MOVE     DC        X'D203A000A000'
BR       DC        X'47F0A000'
STOP     DC        X'07FB'
         DC        C' '
CARD     DS        80C
CARDTP   DS        31C
         LTORG
         EJECT
* PASS TWO AND SAVE AREA SETUP FOR PASS TWO
PASTWO   CSECT
         B         12(,15)
         DC        X'07'
         DC        CL7'PASTWO'
         STM       14,12,12(13)
         BALR      12,0
         USING     *,12
         LA        8,INPUT           LOAD ADD OF INPUT
         LA        9,OUTPUT          LOAD ADD OF OUTPUT
         L         6,=C'GO  '        DETERMINES EXECUTION
         L         10,=V(CODETB)     LOAD ADD OF CODE TABLE
         L         5,=V(CARDTB)      LOAD ADD OF CARD TABLE
         USING     CARDFORM,5        FLOATING DSECT OVER CARD TABLE
         USING     CODEDS,10         FLOATING DSECT OVER CODE TABLE
         B         *+8               BRANCH AROUND INCREMENT
* READ CARD IMAGE FROM CARD TABLE
READTB   LA        5,32(5)           INCRE CARD TABLE LOC
         MVC       PRNTLB(31),LABEL
         XPRNT     PRNTLB-1,32       PRINT CARD IMAGE
* TEST FOR ERRORS FROM PASS ONE
         CLI       FLAG,X'40'        TEST FOR ERROR PASSONE
         BE        COMMENT           NO ERRORS PASSONE
         CLI       FLAG,X'44'        ILLEGAL OPCODE ?
         BNE       TESTC0
         XPRNT     =C' **** ILLEGAL  OPCODE',21
         B         READTB            READ NEXT CARD IMAGE
TESTC0   CLI       FLAG,X'4C'        ERROR?
         BNE       COMMENT
         XPRNT     =C' **** MULTIPLY  DEFINED SYMBOL &&ILLEGAL OPCODE',4
               48
         B         READTB            READ NEXT CARD IMAGE
* TEST FOR CERTAIN OPCODES
COMMENT  CLI       LABEL,C'*'        COMMENT CARD ?
         BE        READTB            READ NEXT CARD IMAGE
         CLC      =CL5'END',OPCODE   END CARD ?
         BE        EXECUTE           EXECUTE PROGRAM
         CLC      =CL5'STOP',OPCODE  STOP CARD ?
         BNE       DCONSTX
         LA        10,2(10)
         B         READTB            READ NEXT CARD IMAGE
DCONSTX  CLC      =CL5'DCON',OPCODE  DCON CARD ?
         BNE       OPERANDS
         CLI       FLAG,X'48'        CORRECR LABEL ?
         BNE       *+10
         XPRNT     =C' **** MULTIPLY  DEFINED LABEL',29
         LCR       4,10              PUT ON FULL WORD BOUNDARY
         N         4,=X'00000003'
         AR        10,4
         LA        10,4(10)          INCRE CODE TABLE ADD
         B         READTB            READ NEXT CARD IMAGE
OPERANDS CLI       FLAG,X'48'        CORRECR LABEL ?
         BNE       *+10
         XPRNT     =C' **** MULTIPLY  DEFINED LABEL',29
* BRANCH TO LOOKUP ROUTINE FOR DISPLACEMENTS
         MVC       OPERAND(8),OPND1
         BAL       14,LOOKUP         DO LOOKUP FOR SYMBOL
         MVC       TEST1(2),FLDISP
         MVC       DISP1(2),FLDISP
         NI        TEST1,B'11110000'
         MVC       OPERAND(8),OPND2
         BAL       14,LOOKUP         DO SYMBOL LOOKUP
         MVC       TEST2(2),FLDISP
         MVC       DISP2(2),FLDISP
         NI        TEST2,B'11110000'
         SPACE     5
* FIND CORRESPONDING OPCODE
         CLC      =CL5'ADD',OPCODE   ADD STATEMENT ?
         BE        AMSST
         CLC      =CL5'SUB',OPCODE   SUB ST ?
         BE        AMSST
         CLC      =CL5'MUL',OPCODE   MUL ST ?
         BE        AMSST
         CLC      =CL5'DIV',OPCODE   DIV ST ?
         BE        DIVST
         CLC      =CL5'OUT',OPCODE   OUT ST ?
         BE        OUTINST
         CLC      =CL5'IN',OPCODE    IN ST ?
         BE        OUTINST
         CLC      =CL5'BRM',OPCODE   BRM ST ?
         BE        BRMST
         CLC      =CL5'MOVE',OPCODE  MOVE ST ?
         BE        MOVEST
* TEST AREA FOR ILLEGAL CODING , ALSO STORES DISPLACEMENTS IN CODE AREA
* TEST & STORE DISPLACEMENT AREA FOR BR OPCODE
         CLI       TEST1,B'11000000'
         BNE       TESTAG
         LA        10,4(10)          INCRE CODE LOC
UNDSYMER XPRNT     =C' **** UNDEFINED  SYMBOL ERROR',29
         L         6,=C'NOGO'
         B         READTB            READ NEXT CARD IMAGE
TESTAG   CLI       TEST1,B'10000000'
         BNE       STBRCOD
         LA        10,4(10)
BRDCONER XPRNT     =C' **** ILLEGAL BRANCH TO DATA',28
         L         6,=C'NOGO'
         B         READTB            READ NEXT CARD IMAGE
STBRCOD  OC        CODE+2(2),DISP1   STORE DISP
         LA        10,4(10)
         B         READTB            READ NEXT CARD IMAGE
* TEST & STORE DISPLACEMENT AREA FOR ADD,SUB,MUL OPCODES
AMSST    CLI       TEST1,B'11000000'
         BNE       CAMS              TEST 2ND OPERAND
INAMS    LA        10,12(10)         INCRE LOC COUNTER
         B         UNDSYMER
CAMS     CLI       TEST2,B'11000000'  ILLEGAL OPND ?
         BE        INAMS
         CLI       TEST1,X'00'
         BNE       CCAMS
INCRAMS  LA        10,12(10)         INCRE LOC
LADCONER XPRNT     =C' **** USING INSTRUCTION AS DATA ',32
         B         READTB            READ NEXT CARD IMAGE
CCAMS    CLI       TEST2,X'00'
         BE        INCRAMS
         OC        CODE+2(2),DISP1   STORE DISP
         OC        CODE+6(2),DISP2   STORE DISP
         OC        CODE+10(2),DISP1  STORE DISP
         LA        10,12(10)         INCRE LOC COUNTER
         B         READTB            READ NEXT CARD IMAGE
* TEST & STORE DISPLACEMENT AREA FOR DIV OPCODE
DIVST    CLI       TEST1,B'11000000'  ILL OPND ?
         BNE       CDIV              TEST 2ND OPND
INDIV    LA        10,16(10)         INCRE LOC COUNTER
         B         UNDSYMER
CDIV     CLI       TEST2,B'11000000'
         BE        INDIV
         CLI       TEST1,X'00'
         BNE       CCDIV
STDIV    LA        10,16(10)
         B         LADCONER
CCDIV    CLI       TEST2,X'00'
         BE        STDIV
         OC        CODE+2(2),DISP1
         OC        CODE+10(2),DISP2  STORE DISP
         OC        CODE+14(2),DISP1  STORE DISP
         LA        10,16(10)
         B         READTB            READ NEXT CARD IMAGE
* TEST & STORE DISPLACEMENT AREA FOR OUT AND IN OPCODES
OUTINST  CLI       TEST1,B'11000000'
         BNE       COUT
INOUTX   LA        10,6(10)
         B         UNDSYMER
COUT     CLI       TEST1,X'00'
         BNE       STINOUT
TSTMV    LA        10,6(10)
         B         LADCONER
STINOUT  OC        CODE+2(2),DISP1   STORE DISP
         LA        10,6(10)
         B         READTB            READ NEXT CARD IMAGE
* TEST & STORE DISPLACEMENT AREA FOR BRM OPCODE
BRMST    CLI       TEST1,B'11000000'
         BE        CBRM
STBRM    CLI       TEST1,X'00'
         BNE       STOBRM
         LA        10,10(10)
         B         LADCONER
CBRM     LA        10,10(10)
         B         UNDSYMER
         CLI       TEST2,B'11000000'
         BE        CBRM
         CLI       TEST2,B'10000000'  ILLEGAL BRANCH
         BNE       STBRM
         LA        10,10(10)
         B         BRDCONER
STOBRM   OC        CODE+2(2),DISP1   STORE DISP
         OC        CODE+8(2),DISP2   STORE DISP
         LA        10,10(10)
         B         READTB            READ NEXT CARD IMAGE
* TEST & STORE DISPLACEMENT AREA FOR MOVE OPCODE
MOVEST   CLI       TEST1,B'11000000'
         BE        INOUTX
         CLI       TEST2,B'11000000'  ILL OPND
         BE        INOUTX
         CLI       TEST1,X'00'
         BE        TSTMV
         CLI       TEST2,X'00'
         BE        TSTMV
         OC        CODE+2(2),DISP1   STORE DISP
         OC        CODE+4(2),DISP2   STORE DISP
         LA        10,6(10)
         B         READTB            READ NEXT CARD IMAGE
         SPACE     5
* SYMBOL LOOKUP TABLE FOR DISPLACEMENTS
LOOKUP   L         2,=V(SYMBOLTB)
         USING     SYMBOLDS,2        FLOATING DSECT OVER SYMBOL TABLE
         B         *+8
INCREX   LA        2,10(2)           INCRE LOC
         CLC      =CL8' ',SYMBOL     LOC BLANK ?
         BE        ERROR
         CLC       SYMBOL(8),OPERAND
         BNE       INCREX
         BR        14                RETURN
ERROR    OI        FLDISP,B'11000000' SET FLAG
         BR        14                RETURN
         SPACE     5
* EXECUTE CODE AREA
EXECUTE  CLI       FLAG,X'48'
         BE        TERMIN            TERMINAT PROGRAM
         ST        6,TEST3
         CLC      =CL4'NOGO',TEST3   TEST FOR ABORTION
         BNE       NOTERMIN
* AREA TO TERMINATE TOPAL PROGRAM
TERMIN   XPRNT     =C' ****PROGRAM  TERMINATED DUE TO ERRORS',38
READAG   XREAD     CARDX,80
         CLC      =CL2'$*',CARDX     $* CARD ?
         BNE       READAG            READ TILL FIND $* CARD
         B         RESTORE2          RETURN TO TOPAL
* AREA TO EXECUTE TOPAL PROGRAM
NOTERMIN L         10,=V(CODETB)     LOAD ADD CODE TABLE
         XPRNT     =C'1 DUMP OF CODE ',15
         XDUMP     0(10),800
         XPRNT     =C'3',1
         L         10,=V(CODETB)
         BALR      11,10             EXECUTE CODE
         XPRNT     =C'3 DUMP OF CODE ',15
         L         10,=V(CODETB)
         XDUMP     0(10),800
         XREAD     CARDX,80
         CLC      =CL2'$*',CARDX
         BE        RESTORE2
         XPRNT     =C' ****WARNING-ALL CARDS WERE NOT PROCESSED',41
         B         READAG
         SPACE     5
* OUTPUT ROUTINE
OUTPUT   XDECO     1,OUTX
         XPRNT     OUTX-16,30
         BR        7
* INPUT ROUTINE
INPUT    XREAD     CARDX,80
         CLC      =CL2'$*',CARDX
         BNE       CONVERTX
         XPRNT     =C' **** PROGRAM  ABORTED-READ BEYOND END OF FILE',46
               6
         XPRNT     =C'3  DUMP OF CODE',15
         L         10,=V(CODETB)
         XDUMP     0(10),800
         B         RESTORE2
CONVERTX LR        3,1
         XDECI     4,CARDX
         ST        4,0(,3)
         BR        7
* RESTORE REGISTERS FRO PASS TWO AND RETURN TO PASS ONE
RESTORE2 LM        2,12,28(13)
         L         14,12(13)
         BR        14
         EJECT
OPERAND  DS        8C
CARDX    DS        80C
TEST1    DC        H'0'
TEST2    DC        H'0'
DISP1    DC        H'0'
DISP2    DC        H'0'
TEST3    DC        F'0'
         DC        CL16'0THE OUTPUT IS  '
OUTX     DC        F'0'
         DC        C' '
PRNTLB   DS        31C
         LTORG
         EJECT
* CONTROL SECTIONS FOR STORAGE OF TABLES
* ALSO DSECTS FOR FLOATING DSECT OVER THE RESPECTIVE CONTROL STORAGE
* SECTIONS
CODETB   CSECT
         DS        50CL16' '
CODEDS   DSECT
CODE     DS        CL16
SYMBOLTB CSECT
         DS        50CL10' '
SYMBOLDS DSECT
SYMBOL   DS        CL8
FLDISP   DS        CL2
CARDTB   CSECT
         DS        50CL32' '
CARDFORM DSECT
LABEL    DS        CL9
OPCODE   DS        CL5
OPND1    DS        CL9
OPND2    DS        CL8
FLAG     DS        CL1
         END
$ENTRY
$$             ' PROGRAM NUMBER 1 '
* DONT FORGET TO SUPPLY THE PROPER DELIMITERS
* THIS IS PROGRAM NUMBER 1
* RECOGNIZE THIS ONE ?
* COMPUTE N!
*        *    *        *
         IN   N
         OUT  N
         MOVE NFAC     N
         MOVE M        N
         SUB  N        ONE
* LOOP TO DO COMPUTATION
LOOP     SUB  N        ONE
         BRM  N        DONE
         SUB  M        ONE
         MUL  NFAC     M
         BR   LOOP
DONE     OUT  NFAC
         STOP
N        DCON 0
M        DCON 0
NFAC     DCON 0
ONE      DCON 1
         END
     5
$*
$$             ' PROGRAM NUMBER 2 '
* THIS IS PROGRAM NUMBER 2
* PROGRAM FINDS MAX & MIN OF SET
* OF INTEGERS<10000000. MIN IS
* MULT BY 5,MAX IS DIV BY 4
* AND SUM OF RESULTS PRINTED. -1
* READ IN HALTS PROGRAM
*        *    *        *
LOOP1    IN   N
         BRM  N        QUIT
         MOVE TEMP     N
         SUB  TEMP     MAX
* IF NEG RESULT OLD MAX STANDS
         BRM  TEMP     TRYMIN
         MOVE MAX      N
TRYMIN   MOVE TEMP     N
         SUB  TEMP     MIN
* IF NEG RESULT THEN NEW MIN
         BRM  TEMP     NEWMIN
         BR   LOOP1
NEWMIN   MOVE MIN      N
         BR   LOOP1
N        DCON 0
MAX      DCON -4
MIN      DCON 10000000
TEMP     DCON 0
FOUR     DCON 4
FIVE     DCON 5
QUIT     MUL  MIN      FIVE
         DIV  MAX      FOUR
         ADD  MIN      MAX
         OUT  MIN
         STOP
         END
200   DATA
         20     DATA
                5000      DATA
  18    DATA
         64     DATA
     2    DATA
          -1       DATA TRAILER
$*
$$             ' PROGRAM NUMBER 3 '
* PROGRAM NUMBER 2 WITH ERRORS
*        *    *        *
LOOP1    IN   N
         BRM  N        QUIT
         MOVE TEMP     N
         SUB  TEMP     MAX
* IF NEG RESULT OLD MAX STANDS
         BRM  TEMP     TRYMIN
         MOVE MAX      N
TRYMIN   MOVE TEMP     N
         SUB  TEMP     TRYMIN
* IF NEG RESULT THEN NEW MIN
         BRM  TEMP     NEWMIN
         BR   MAX
NEWMIN   MOVE MIN      N
         BR   LOOP1
N        DCON 0
MAX      DCON -4
TEMP     DCON 0
FOUR     DCON 4
FIVE     DCON 5
MAX      DCON 1000000
QUIT     MUL  MIN      FIVE
         STM  MAX      FOUR
         ADD  MIN      MAX
         OUT  MIN
         STOP
         END
200   DATA
         20     DATA
                5000      DATA
  18    DATA
         64     DATA
     2    DATA
          -1       DATA TRAILER
$*
$$             ' PROGRAM NUMBER 4 '
* PROGRAM NUMBER 1 WITH ERRORS
*        *    *        *
         IN   N
         OUT  N
         MOVE NFAC     N
         MOVE M        N
         SUB  N        ONE
* LOOP TO DO COMPUTATION
LOOP     SUB  N        ONE
         BRM  DONE
         SUB  M        ONE
         MUL  NFAC     M
         BR   POOL
DONE     OUT  NFAC
         STOP
N        DCON 0
M        DCON 0
NFAC     DCON 0
ONE      DCON 1
         END
    5
$*
$$     ' PROGRAM 1 WITH NO DATA CARDS '
* COMPUTE N !
         IN   N
         OUT  N
         MOVE NFAC     N
         MOVE M        N
         SUB  N        ONE
* LOOP TO DO COMPUTATION
LOOP     SUB  N        ONE
         BRM  N        DONE
         SUB  M        ONE
         MUL  NFAC     M
         BR   LOOP
DONE     OUT  NFAC
         STOP
N        DCON          0
M        DCON          0
NFAC     DCON          0
ONE      DCON          1
         END
$*
$$      ' PROGRAM 1 WITH EXTRA DATA CARDS '
* DONT FORGET TO SUPPLY THE PROPER DELIMITERS
* THIS IS PROGRAM NUMBER 1
* RECOGNIZE THIS ONE ?
* COMPUTE N!
*        *    *        *
         IN   N
         OUT  N
         MOVE NFAC     N
         MOVE M        N
         SUB  N        ONE
* LOOP TO DO COMPUTATION
LOOP     SUB  N        ONE
         BRM  N        DONE
         SUB  M        ONE
         MUL  NFAC     M
         BR   LOOP
DONE     OUT  NFAC
         STOP
N        DCON 0
M        DCON 0
NFAC     DCON 0
ONE      DCON 1
         END
     5
      4
$*
$JOB   ASSIST  PROGTEST
*        *** FINAL PROJECT - FIRST ASSEMBLER COURSE.   1044 STMTS,
*        USER PROGRAM PRINTS  APPROX 2 PAGES OF OUTPUT, THEN ABENDS
*        WITH 0C4 COMPLETION CODE AFTER 48931 INSTRUCTIONS EXECUTED.
*        **NOTE** REQUIRES  APPROX 6.5 SECONDS TOTAL TIME ON 360/67.
*        UNDER NOLARGE,NOCMPRS, ASSEMBLER REQUIRES  78 BYTES/STMT,
*        AND ASSEMBLES AT RATE OF 371 STMTS/SECOND (2.814 SECS).
*        EXECUTION OF 48931 INSTRUCTIONS REQUIRED 2.970 SECONDS, AT
*        RATE 16475 PER SECOND.
*        TOTAL DYNAMIC STORAGE REQUIRED WAS  APPROX 82K.
         TITLE 'CONSTRUCTION OF ASSEMBLER FOR CS 410'
DRIVER   CSECT
         BALR   12,0
         USING  *,12
         LA     7,LABT       FOR USE A BASE FOR DUMMY CSECT
         LA     2,DATAAD
         ST     14,SAV14
         LA     6,SOURC      REGISTER 6 WILL BE USED TO RECORD ADDRESS
*                            OF FIRST CARD STORED
         LR     3,6          REGISTER 3 WILL BE USED TO RECORD ADDRESS
*                            OF LAST CARD READ
         LA     13,SAVDR     LOAD REGISTER 13 WITH ADDRESS OF DRIVER'S
         LA     10,LABT        LOAD ADDRESS OF LABLE TABLE IN REG 10
         LA     11,OUTP      USE REGISTER 11 TO INDICATE LOCATION OF
*                            CODED PROGRAM
         LA     5,BYPASS     LOAD ADDRESS OF FINAL OPERATION FOR USE
*                            IN EVENT OF ERR DISCOVERY IN SUBROUTINE
         MVI     ESLET+X'C1',X'AA'  PLACE LETTER IN PLACE OF 0 FOR
*                            TEST
         MVI     ESLET+X'C2',X'BB'  PLACE LETTER IN PLACE OF 0 FOR
*                            TEST
         MVI     ESLET+X'C3',X'CC'  PLACE LETTER IN PLACE OF 0 FOR
*                            TEST
         MVI     ESLET+X'C4',X'DD'  PLACE LETTER IN PLACE OF 0 FOR
*                            TEST
         MVI     ESLET+X'C5',X'EE'  PLACE LETTER IN PLACE OF 0 FOR
*                            TEST
         MVI     ESLET+X'C6',X'FF'  PLACE LETTER IN PLACE OF 0 FOR
*                            TEST
         MVI     ESLET+X'C7',X'11'  PLACE LETTER IN PLACE OF 0 FOR
*                            TEST
         MVI     ESLET+X'C8',X'11'  PLACE LETTER IN PLACE OF 0 FOR
*                            TEST
         MVI     ESLET+X'C9',X'11'  PLACE LETTER IN PLACE OF 0 FOR
*                            TEST
         MVI     ESLET+X'D1',X'11'  PLACE LETTER IN PLACE OF 0 FOR
*                            TEST
         MVI     ESLET+X'D2',X'11'  PLACE LETTER IN PLACE OF 0 FOR
*                            TEST
         MVI     ESLET+X'D3',X'11'  PLACE LETTER IN PLACE OF 0 FOR
*                            TEST
         MVI     ESLET+X'D4',X'11'  PLACE LETTER IN PLACE OF 0 FOR
*                            TEST
         MVI     ESLET+X'D5',X'11'  PLACE LETTER IN PLACE OF 0 FOR
*                            TEST
         MVI     ESLET+X'D6',X'11'  PLACE LETTER IN PLACE OF 0 FOR
*                            TEST
         MVI     ESLET+X'D7',X'11'  PLACE LETTER IN PLACE OF 0 FOR
*                            TEST
         MVI     ESLET+X'D8',X'11'  PLACE LETTER IN PLACE OF 0 FOR
*                            TEST
         MVI     ESLET+X'D9',X'11'  PLACE LETTER IN PLACE OF 0 FOR
*                            TEST
         MVI     ESLET+X'E2',X'11'  PLACE LETTER IN PLACE OF 0 FOR
*                            TEST
         MVI     ESLET+X'E3',X'11'  PLACE LETTER IN PLACE OF 0 FOR
*                            TEST
         MVI     ESLET+X'E4',X'11'  PLACE LETTER IN PLACE OF 0 FOR
*                            TEST
         MVI     ESLET+X'E5',X'11'  PLACE LETTER IN PLACE OF 0 FOR
*                            TEST
         MVI     ESLET+X'E6',X'11'  PLACE LETTER IN PLACE OF 0 FOR
*                            TEST
         MVI     ESLET+X'E7',X'11'  PLACE LETTER IN PLACE OF 0 FOR
*                            TEST
         MVI     ESLET+X'E8',X'11'  PLACE LETTER IN PLACE OF 0 FOR
*                            TEST
         MVI     ESLET+X'E9',X'11'  PLACE LETTER IN PLACE OF 0 FOR
*                            TEST
         MVI     ESNUM+X'F1',X'11'  PLACE NUMBER IN PLACE OF 0 FOR
*                            TEST
         MVI     ESNUM+X'F2',X'22'  PLACE NUMBER IN PLACE OF 0 FOR
*                            TEST
         MVI     ESNUM+X'F3',X'33'  PLACE NUMBER IN PLACE OF 0 FOR
*                            TEST
         MVI     ESNUM+X'F4',X'44'  PLACE NUMBER IN PLACE OF 0 FOR
*                            TEST
         MVI     ESNUM+X'F5',X'55'  PLACE NUMBER IN PLACE OF 0 FOR
*                            TEST
         MVI     ESNUM+X'F6',X'66'  PLACE NUMBER IN PLACE OF 0 FOR
*                            TEST
         MVI     ESNUM+X'F7',X'77'  PLACE NUMBER IN PLACE OF 0 FOR
*                            TEST
         MVI     ESNUM+X'F8',X'88'  PLACE NUMBER IN PLACE OF 0 FOR
*                            TEST
         MVI     ESNUM+X'F9',X'99'  PLACE NUMBER IN PLACE OF 0 FOR
*                            TEST
         XPRNT  INPUT,11     PRINT TITLE FOR INPUT ECHO CHECK
INIT     XREAD  CARDA,40     READ INITIAL CARD
         XPRNT  CRG,41       ECHO CHECK
CKBEG    CLC    CARDA(5),BEGCK     DETERMINE IF THIS IS THE START OF
*                            THE PROGRAM
         BE     FIRST        IF SO, CONTINUE WITH REMAINDER OF
*                            THE PROGRAM
         XPRNT  BADBIG,47    IF ANY PROGRAM CARD IS BEFORE BEGIN,
*                            PRINT, 'ERROR - SHOULD START WITH BEGIN
*                            OR BEGIN JOB', AND -
         B      INIT         GO TO NEXT CARD
FIRST    XREAD  CARDA,40     READ CARD
         BM     P            IF NO MORE CARDS, GO TO NEXT STEP
         XPRNT  CRG,41       ECHO CHECK
         MVC    0(40,3),CARDA PUT CONTENTS OF CARD INTO AREA (SOURCE)
*                            ADDRESSED BY REGISTER 3
         LA     3,40(3)      INCREMENT ADDRESS OF ARRAY TO ACCOMODATE
*                            NEXT CARD AND -
         B      FIRST        REPEAT STEPS OF FIRST LOOP
P        L      15,ADDR      LOAD ADDRESS OF PASS 1 IN REGISTER 15
         BALR   14,15        GO TO PASS1 CSECT
         L      15,ADDTWO    LOAD ADDRESS OF PASS 2 IN REGISTER 15
         BALR   14,15        GO TO PASS2 CSECT
         L      15,ADDINT    LOAD ADDRESS OF INTERP IN REGISTER 15
         BALR   14,15        GO TO INTERPRETER CSECT
BYPASS   BR     14
SAV14    DS     F
INPUT    DC     C' INPUT DATA'
CRG      DC     C' '
CARDA    DS     40C
BADBIG   DC     C' (ERROR-SHOULD START WITH - BEGIN OR BEGIN JOB)'
ADDR     DC     V(PASS1)
ADDTWO   DC     V(PTWO)
ADDINT   DC     V(INTERP)
SAVDR    DS     18F
BEGCK    DC     C'BEGIN'
LABT     DS     150F
ESNUM    DC     256X'00'
ESLET    DC     256X'00'
DATAAD   DS     F
OUTP     DC     1000X'EE'
SOURC    DS     4000C
         EJECT
PASS1    CSECT
         STM    14,12,12(13)
         BALR   12,0
         USING  *,12
         ST     13,SAVP1+4
         USING  TESECT,7
         LR     13,3         USE REG 13 TO CHECK FOR GROSS OVERRUNS
*                            (IE NOT EVEN ONE ## CARD
         LR     15,10        PLACE ADDRESS OF LABTAB IN REG 15 FOR
*                            USE IN THIS PASS ONLY
         SR     14,14        CLEAR REG 14 FOR USE IN ERROR CHECK
         LA     10,6(10)     INCREMENT LABLE COUNTER TO POINT TO NEXT
*                            LOCATION FOR FIRST TIME THROUGH
         XPRNT  LABONE,9     PRINT TITLE FOR PASS 1 OUTPUT
         B      F            SKIP NEXT STEP FOR FIRST ADDRESS AS IT IS
*                            ALREADY CORRECT
NEXTCD   LA     6,40(6)      INCREMENT ARRAY ADDRESS BY 1 'CARD'
         CLR    6,13         COMPARE REGISTERS TO DETERMINE IF ENTIRE
*                            SOURCE HAS BEEN READ
         BE     NOEND        IF SO, THERE IS NO END CARD (##), SO
*                            GO TO ERROR ROUTINE
F        LR     4,6          EXAMINE EACH COLUMN OF EACH CARD THAT
*                            IS STORED IN ARRAY SOURCE USING REGISTER
*                            4 AS A COLUMN COUNTER. TO BEGIN, PLACE
*                            ADDRESS OF 'THE CARD' (ARRAY INCREMENT)
*                            TO BE READ INTO REGISTER 4
         BCTR   6,0          DECREMENT  FOR CARRAIGE CONTROL (TEST)
         XPRNT  0(6),40      PASS 1 ECHO CHECK
         LA     6,1(6)       INCREMENT 1 TO RETURN REGISTER 6 TO PROPER
*                            ADDRESS
         CLC  0(2,4),=C'##'  CHECK TO DETERMINE IF THIS IS THE CODE FOR
         BE     ENDONE       END CARD- BRANCH TO NEXT STEP
         CLC    0(1,4),=C' ' DETERMINE IF 1ST COLUMN HAS A LABLE,
         BE     CKOP         IF NOT, BRANCH TO CHECK OF OPERATION CODE
*                            SEQUENCE
         LR     5,15         INITIALIZE ADDR OF RECORDED TABLES FOR
*                            CHECK PURPOSES
CKDUP    CLC    0(2,4),0(5)  IF CARD HAS A LABLE, CHECK TO SEE IF IT
*                            HAS BEEN PREVIOUSLY RECORDED
         BE     DUP          IF SO, BRANCH TO ERROR ROUTINE
         LA     5,6(5)       INCREMENT 6 BYTES TO THE ADDRESS OF NEXT
*                            LABLE TO BE CHECKED
         CLR    5,10         COMPARE REG 5 WITH REG 10 TO SEE IF ALL
*                            LABLES HAVE BEEN CHECKED
         BNE    CKDUP        IF NOT EQUAL, CONTINUE CHECK
         MVC    0(2,10),0(4)   MOVE LABLE ADDRESSED BY REG 4 TO FIRST
*                            2 BYTES OF PORTION OF LABLE TABLE
*                            ADDRESSED BY REG 10
         ST     11,LOCCTR    PLACE CONTENTS OF REG 11 (LOCATION
*                            COUNTER ADDRESS OF LABLE) AT LOCCTR
         MVC    2(4,10),LOCCTR MOVE LOCATION COUNTER ADDRESS NEXT TO
*                            CORRESPONDING LABLE IN LABLE TABLE
         LA     10,6(10)     INCREMENT LABLE TABLE BY 6 BYTES IN
*                            PREPARATION FOR NEXT LABLE
         B      CKLET        GO TO NEXT CHECK
DUP      XPRNT  BADLAB,26    IF LABLE USED IN PROGRAM HAS BEEN USED
*                            FOR SOME OTHER PURPOSE, PRINT, 'ERROR -
*                            DUPLICATE LABLE' AND -
         LA     14,=F'1'     RECORD THE FACT THAT THERE IS AN ERROR
         B         NEXTCD    GO BACK AND READ NEXT CARD
CKLET    TRT    0(1,4),TESLET DETERMINE IF FIRST CHARACTER IN LABLE
*                            IS A LETTER -  IF SO
         BC     2,CKNUM      BRANCH TO NEXT CHECK
         XPRNT  BADONE,41    IF FIRST CHARACTER OF LABLE IS NOT A
*                            LETTER, PRINT: ERROR, INVALID LABLE
*                            FIRST CHARACTER
         LA     14,=F'1'     RECORD THE FACT THAT THERE IS AN ERROR
CKNUM    LA     4,1(4)       INCREMENT COLUMN COUNTER BY 1
         TRT    0(1,4),TESNUM DETERMINE IF THE SECOND  CHARACTER IN
*                      LABLE IS A NUMBER -  IF SO
         BC     2,CKBL       BRANCH TO NEXT CHECK
         XPRNT  BADTWO,42    IF SECOND CHARACTER OF LABLE IS NOT
*                            A NUMBER, PRINT : ERROR - INVALID LABLE
*                            SECOND CHARACTER
         LA     14,=F'1'     RECORD THE FACT THAT THERE IS AN ERROR
CKBL     LA     4,1(4)       INCREMENT COLUMN COUNTER BY 1
         CLC    0(1,4),=C' ' TEST FOR BLANK. IF SO -
         BE     SEARCH       BEGIN SEARCH, OTHERWISE
         XPRNT  BADLEN,50    IF LABLE IS TOO LONG, PRINT ERROR MESSAGE
         LA     14,=F'1'     RECORD THE FACT THAT THERE IS AN ERROR
SEARCH   LA     4,1(4)       INCREMENT COLUMNCOUNTER
         CLC    0(1,4),=C' ' TEST FOR BLANK. IF NOT -
         BE     SEARCH        SEARCH AGAIN
         CLC   0(2,4),=C'DS' DETERMINE IF THIS IS A DS STATEMENT
         BE     DSDC         IF SO, BRANCH TO DS AND DC SEQUENCE
         CLC   0(2,4),=C'DC' DETERMINE IF THIS IS A DC STATEMENT
         BNE    CKOPLA       IF NOT, IT IS NEITHER A DC OR DS STATEMENT
*                            SO BRANCH TO CHECK OF OPERATIONS SEQUENCE
DSDC     LA     4,2(4)       IF IT IS A DS OR DC STATEMENT, INCREMENT
*                            ADDRESS BY 2 SO AS TO POINT TO THE BLANK
*                            AFTER DC OR DS
         SR     8,8          CLEAR REGISTER 8 FOR USE IN MULTIPLICATION
*                            SEQUENCE
         LA     9,=F'1'      PLACE INITIAL DUPLICATION FACTOR IN REG 9
BLN      CLC    0(1,4),=C' ' TEST FOR BLANK. IF SO -
         LA     4,1(4)       INCREMENT CARD COUNTER
         BE     BLN          AND CONTINUE SEARCH
         TRT    0(1,4),TESNUM  DETERMINE IF THIS IS A DUPLICATION
*                            FACTOR
         BC     2,TESTF      IF NOT, CHECK FULL WORD SEQUENCE
         IC     3,0(4)       PLACE IN REG 3 THE CONTENTS (1 BYTE)
*                            OF STORAGE ADDRESSED BY REG 4
IADD     LA     4,1(4)       INCREMENT CARD COUNTER
         TRT    0(1,4),TESNUM  DETERMINE IF THIS IS A DUPLICATION
*                            FACTOR
         BC     2,TESTF      IF NOT, CHECK FULL WORD SEQUENCE
         LA     3,=F'10'     OTHERWISE PLACE A 10 IN REGISTER 3 AND
         MR     8,3          MULTIPLY PREVIOU DUPLICATION FACTOR
*                            BY 10
         IC     3,0(4)       PLACE IN REG 3 THE CONTENTS (1 BYTE)
*                            OF STORAGE ADDRESSED BY REG 4
         AR     9,3          ADD CONTENTS OF 3 TO CONTENTS OF 9
         B      IADD         BRANCH TO TOP AND REPEAT THE PROCESS
TESTF    CLC    0(1,4),=C'F' DETERMINE IF THIS IS A FULL WORD SYMBOL
         BE     FULLST       IF SO, BRANCH TO FULL WORD SEQUENCE
         CLC    0(1,4),=C'C' DETERMINE IF THIS IS A CONSONANT SYMBOL
         BE     CONST        IF SO, BRANCH TO CONSONANT SEQUENCE
         LA     14,=F'1'     RECORD THE FACT THAT THERE IS AN ERROR
         B      NEXTCD       IF NOT A C,F, OR NUMBER, IT IS IN ERROR
*                            SO GO TO NEXT CARD
FULLST   LA     3,=F'4'      LOAD REG3 WITH A 4 FOR THE 4 BYTES
*                            OF STORAGE PER FULL WORD
         MR     8,3          MULTIPLY DUPLICATION FACTOR BY 4 TO DETER-
*                            MINE THE AMOUNT OF STORAGE TO RESERVE
*                            (ANSWER IN REG 9)
         AR     11,9         INCREMENT STORAGE ADDRESS IN REGISTER
*                            11 BY REQUIRED AMOUNT OF STORAGE
         SR     8,8          CLEAR REGISTER 8
         LR     9,11         LOAD ADDRESS OF STORAGE LOCATION
*                            INTO REG 9
         D      8,=F'4'      DIVIDE ADDRESS OF STORAGE BY 4 TO FIND
*                            IF ON A FULL WORD BOUNDARY
*        AR     11,8         ADD ANY REMAINDER TO ADDRESS OF STORAGE
*                            LOCATION TO INSURE FULL WORD 'STARTED'ON
*                            FULL WORD BOUNDARY
         B         NEXTCD    GO BACK AND READ NEXT CARD
CONST     LA    3,=F'1'      LOAD A 1 IN REG3 AND USE AS A SPACE COUNT
CO       LA     4,1(4)       INCREMENT ADDRESS BY 1 SO AS TO POINT TO
*                            COLUMN AFTER C
         CLC    0(1,4),=C'''' ? THERE AN APOSTROPHE ?
         BNE    CONDUP       IF NOT, GO DIRECTLY TO CONSIDERATION
*                            OF DUPLICATION FACTOR
APSEQ    LA     4,1(4)       OTHERWISE, INCREMENT COLUMN COUNTER BY 1
*                            AND SEARCH FOR NEXT APOSTROPHE
         CLC     0(1,4),=C'''' IS THIS THE SECOND APOSTROPHE?
         BE     CONDUP       IF SO, BRANCH TO NEXT STEP
         LA     3,1(3)       OTHERWISE INCREMENT SPACE COUNTER IN
*                            REGISTER 3 AND
         B      APSEQ           CONTINUE
CONDUP    MR    8,3          MULTIPLY DUPLICATION FACTOR IN REG 3 BY
*                            NUMBER OF SPACES IF ANY, BETWEEN APOST.
*                            TO GIVE TOTAL LENGTH OF STORAGE REQUIRED
         AR     11,9         INCREMENT ADDRESS IN REGISTER 11 BY
*                            THIS AMOUNT
         B         NEXTCD    GO BACK AND READ NEXT CARD
CKOP     LA     4,1(4)       INCREMENT CARD COUNTER
         CLC    0(1,4),=C' ' TEST FOR BLANK
         BE     CKOP         IF  SO, CONTINUE SEARCH
CKOPLA   CLC  0(2,4),=C'LD'  CHECK TO DETERMINE IF THIS IS THE CODE FOR
         BE     OKOP         LOAD    - BRANCH TO NEXT STEP
         CLC  0(2,4),=C'ST'  CHECK TO DETERMINE IF THIS IS THE CODE FOR
         BE     OKOP         STORE   - BRANCH TO NEXT STEP
         CLC  0(2,4),=C'AD'  CHECK TO DETERMINE IF THIS IS THE CODE FOR
         BE     OKOP         ADD     - BRANCH TO NEXT STEP
         CLC  0(2,4),=C'SB'  CHECK TO DETERMINE IF THIS IS THE CODE FOR
         BE     OKOP         SUBTRACT- BRANCH TO NEXT STEP
         CLC  0(2,4),=C'MT'  CHECK TO DETERMINE IF THIS IS THE CODE FOR
         BE     OKOP         MULTIPLY- BRANCH TO NEXT STEP
         CLC  0(2,4),=C'DV'  CHECK TO DETERMINE IF THIS IS THE CODE FOR
         BE     OKOP         DIVIDE  - BRANCH TO NEXT STEP
         CLC  0(2,4),=C'GT'  CHECK TO DETERMINE IF THIS IS THE CODE FOR
         BE   OKOP           GO TO   - BRANCH TO NEXT STEP
         CLC  0(2,4),=C'IF'  CHECK TO DETERMINE IF THIS IS THE CODE FOR
         BE     OKOP         IF      - BRANCH TO NEXT STEP
         CLC  0(2,4),=C'RD'  CHECK TO DETERMINE IF THIS IS THE CODE FOR
         BE     OKOP         READ    - BRANCH TO NEXT STEP
         CLC  0(2,4),=C'WT'  CHECK TO DETERMINE IF THIS IS THE CODE FOR
         BE     OKOP         WRITE, IF SO BRANCH TO NEXT STEP
         CLC  0(2,4),=C'HT'  CHECK TO DETERMINE IF THIS IS THE CODE FOR
         BE     OKOP         HALT    - BRANCH TO NEXT STEP
         CLC  0(3,4),=C'END' CHECK TO DETERMINE IF THIS IS THE CODE FOR
         BE     NEXTCD       END CARD - IF SO TAKE NO ACTION BUT
*                            CHECK NEXT CARD FOR ##
         XPRNT   BADOP,34    IF OPERATIONS CODE USED IN PROGRAM
*                            DOES NOT MATCH ANY OF THE VALID OPER-
*                            ATIONS CODES, PRINT,INVALID OPERATIONS
*                            CODE, AND -
         LA     14,=F'1'     RECORD THE FACT THAT THERE IS AN ERROR
         B      NEXTCD       READ THE NEXT CARD
OKOP     LA     11,3(11)     OPERATIONS OF THIS TYPE REQUIRE THREE
*                            BYTES OF STORAGE. THEREFORE, THE
*                            ADDRESS OF THE STORAGE LOCATION IS
*                            INCREMENTED BY THREE TO GIVE THE ADDRESS
*                            OF THE NEXT AVAILABLE BYTE OF STORAGE
         B      NEXTCD       PASS 1 COMPLETED FOR THIS CARD, READ NEXT
NOEND    XPRNT  BADEND,25    IF THERE IS NO ## CARD, PRINT ERROR -
*                            MISSING ## CARD
         LA     14,=F'1'     RECORD THE FACT THAT THERE IS AN ERROR
ENDONE   LA     2,=F'1'      LOAD REG 2 FOR ERROR CHECK
         CR     2,14         DETERMINE IF AN ERROR HAS BEEN RECORDED
         L      13,SAVP1+4
         LA     6,40(6)      INCREMENT SOURCE ARRAY BY 1 CARD
         ST     6,ADDATA     STORE ADDRESS OF FIRST DATA CAR FOR
*                            USE BY INTERPRETER
         LM     14,12,12(13)
         BR     14
ERRORF   LR     14,5         RETURN TO A DIFFERENT LOCATION IN MAIN
*                            STORAGE BECOUSE OF ERROR FOUND IN PROGRAM
         BR     14
SAVP1    DS     18F
LOCCTR   DS     F
LABONE   DC     C' PASS ONE'
BADLAB   DC     C' (ERROR - DUPLICATE LABLE)'
BADONE   DC     C' (ERROR - INVALID LABLE: FIRST CHARACTER)'
BADTWO   DC     C' (ERROR - INVALID LABLE: SECOND CHARACTER)'
BADLEN   DC     C' (ERROR - INVALID LABLE: OVER TWO CHARACTERS LONG)'
BADOP    DC     C' (ERROR - INVALID OPERATIONS CODE)'
BADEND   DC     C' ERROR - MISSING ## CARD)'
         LTORG
         EJECT
PTWO     CSECT
         STM    14,12,12(13)
         BALR   12,0
         USING  *,12
         USING  TESECT,7
       ST       13,SAVTWO+4
         XPRNT  LABTWO,9     PRINT TITLE FOR PASS 2 OUTPUT
         LR     15,10        PLACE ADDRESS OF LABTAB IN REG 15 FOR
*                            USE IN THIS PASS ONLY
         B      ERSTE        SKIP NEXT STEP FOR FIRST ADDRESS AS IT IS
*                            ALREADY CORRECT
NCARD    LA     6,40(6)      INCREMENT ARRAY ADDRESS BY 1 'CARD'
         CLR    6,7          COMPARE REGISTERS TO DETERMINE IF ENTIRE
*                            SOURCE HAS BEEN READ
         BE     ENDTWO       IF SO, THERE IS NO END CARD (##), BUT
*                            JOB OF PASS IS FINISHED
ERSTE    LR     4,6          EXAMINE EACH COLUMN OF EACH CARD THAT
*                            IS STORED IN ARRAY SOURCE USING REGISTER
*                            4 AS A COLUMN COUNTER. TO BEGIN, PLACE
*                            ADDRESS OF 'THE CARD' (ARRAY INCREMENT)
*                            TO BE READ INTO REGISTER 4
         BCTR   6,0          DECREMENT  FOR CARRAIGE CONTROL (TEST)
         XPRNT  0(6),40      PASS 2 ECHO CHECK
         LA     6,1(6)       INCREMENT 1 TO RETURN REGISTER 6 TO PROPER
*                            ADDRESS
         CLC  0(2,4),=C'##'  CHECK TO DETERMINE IF THIS IS THE CODE FOR
         BE     ENDTWO       END CARD- BRANCH TO NEXT STEP
         CLC    0(1,4),=C' ' DETERMINE IF 1ST COLUMN HAS A LABLE,
         BE     OPSEQ        IF NOT, BRANCH TO CHECK OF OPERATION CODE
*                            SEQUENCE
         LR     5,15         INITIALIZE ADDR OF RECORDED TABLES FOR
*                            CHECK PURPOSES
         LA     4,1(4)       IF CARD HAS A LABLE, INCREMENT COUNTER
*                            BY 2 TO GET PAST LABLE AND THEN AGAIN
CKBLAN   LA     4,1(4)       INCREMENT COLUMN COUNTER BY 1
         CLC    0(1,4),=C' ' TEST FOR BLANK. IF SO -
         BE     CKBLAN        SEARCH AGAIN . OTHERWISE -
         CLC   0(2,4),=C'DS' DETERMINE IF THIS IS A DS STATEMENT
         BE     DSDCSQ       IF SO, BRANCH TO DS AND DC SEQUENCE
         CLC   0(2,4),=C'DC' DETERMINE IF THIS IS A DC STATEMENT
         BNE    COMOP        IF NOT, IT IS NEITHER A DC OR DS STATEMENT
*                            SO BRANCH TO CHECK OF OPERATIONS SEQUENCE
DSDCSQ   LA     4,2(4)       IF IT IS A DS OR DC STATEMENT, INCREMENT
*                            ADDRESS BY 2 SO AS TO POINT TO THE BLANK
*                            AFTER DC OR DS
         SR     8,8          CLEAR REGISTER 8 FOR USE IN MULTIPLICATION
*                            SEQUENCE
         LA     9,=F'1'      PLACE INITIAL DUPLICATION FACTOR IN REG 9
BLAN     CLC    0(1,4),=C' ' TEST FOR BLANK. IF SO -
         LA     4,1(4)       INCREMENT CARD COUNTER
         BE     BLAN         AND CONTINUE SEARCH
         TRT    0(1,4),TESNUM  DETERMINE IF THIS IS A DUPLICATION
*                            FACTOR
         BC     2,TCON       IF NOT, CHECK CONSONANT SEQUENCE
         IC     3,0(4)       PLACE IN REG 3 THE CONTENTS (1 BYTE)
*                            OF STORAGE ADDRESSED BY REG 4
IADDR    LA     4,1(4)       INCREMENT CARD COUNTER
         TRT    0(1,4),TESNUM  DETERMINE IF THIS IS A DUPLICATION
*                            FACTOR
         BC     2,TCON       IF NOT, CHECK CONSONANT SEQUENCE
         LA     3,=F'10'     OTHERWISE PLACE A 10 IN REGISTER 3 AND
         MR     8,3          MULTIPLY PREVIOU DUPLICATION FACTOR
*                            BY 10
         IC     3,0(4)       PLACE IN REG 3 THE CONTENTS (1 BYTE)
*                            OF STORAGE ADDRESSED BY REG 4
         AR     9,3          ADD CONTENTS OF 3 TO CONTENTS OF 9
         B      IADDR        BRANCH TO TOP AND REPEAT THE PROCESS
TCON     CLC    0(1,4),=C'C' DETERMINE IF THIS IS A CONSONANT SYMBOL
         BE     CONSON       IF SO, BRANCH TO CONSONANT SEQUENCE
FULLSQ   SR     8,8          CLEAR REGISTER 8
         LR     9,11         LOAD ADDRESS OF STORAGE LOCATION
*                            INTO REG 9
         D      8,=F'4'      DIVIDE ADDRESS OF STORAGE BY 4 TO FIND
*                            IF ON A FULL WORD BOUNDARY
*        AR     11,8         ADD ANY REMAINDER TO ADDRESS OF STORAGE
*                            LOCATION TO INSURE FULL WORD 'STARTS 'ON
*                            FULL WORD BOUNDARY
         SR     3,3               CLEAR  REG3 AND USE AS A SPACE COUNT
         LA     4,1(4)       INCREMENT ADDRESS BY 1 SO AS TO POINT TO
*                            COLUMN AFTER F
         CLC    0(1,4),=C'''' ? THERE AN APOSTROPHE ?
         BNE    NOFUAP       IF NOT, GO TO NO APOSTROPHE SEQUENCE
         LA      11,4(11)     INCREMENT STORAGE FOR CONTENTS OF FULL W
FSECAP   LA     4,1(4)       OTHERWISE, INCREMENT COLUMN COUNTER BY 1
*                            AND SEARCH FOR NEXT APOSTROPHE
BOY      CLC     0(1,4),=C'''' IS THIS THE SECOND APOSTROPHE?
         BE     FAPF         IF SO, BRANCH TO NEXT STEP
         LA     3,1(3)       OTHERWISE INCREMENT SPACE COUNTER IN
*                            REGISTER 3 AND
FAPF     LR     2,3          SAVE COUNT OF DIGITS
         B      FSECAP       CONTINUE SEARCH
FAPFND   BCTR   4,0          DECREMENT COLUMN COUNTER TO POINT TO
*                            SIGNIFICANT CHARACTER
         MVC    0(1,11),0(4)   MOVE A BYTE FROM CONTENTS OF CARD
*                            STORAGE TO CODE STORAGE
         BCTR    11,0        DECREMENT  CODE STORAGE FOR NEXT BYTE
         BCTR     3,0        DEREMENT COUNTER BY 1
         CL     3,=F'0'      HAS EVERYTHING BEEN MOVED?
         BE     FULLDU       IF SO BRANCH TO CONSIDERATION OF ANY DUP-
*                            LICATION FACTORS
         B      FAPFND       OTHERWISE CONTINUE SEARCH
FULLDU   AR     11,2         RETURN ADDRESS OF NEXT  OPEN STORE TO
*                            CORRECT AMOUNT
          CL    8,=F'1'       IS DUPLICATION REQUIRED?
         BE     NCARD        IF NOT GO BACK TO NEXT CARD
         BCTR    8,0         OTHERWISE DECREMENT DUPLICATION
*                            FACTOR COUNTER AND
         BCTR   4,0          DECREMENT COLUMN COUNTER
         LA      11,4(11)     INCREMENT STORAGE FOR CONTENTS OF FULL W
         B      BOY          CONTINUE
NOFUAP   LA     3,=F'4'      LOAD REG3 WITH A 4 FOR THE 4 BYTES
*                            OF STORAGE PER FULL WORD
         MR     8,3          MULTIPLY DUPLICATION FACTOR BY 4 TO DETER-
*                            MINE THE AMOUNT OF STORAGE TO RESERVE
*                            (ANSWER IN REG 9)
         AR     11,9         INCREMENT STORAGE ADDRESS IN REGISTER
*                            11 BY REQUIRED AMOUNT OF STORAGE
         B      NCARD        GO BACK AND READ NEXT CARD
CONSON   SR     3,3               CLEAR  REG3 AND USE AS A SPACE COUNT
         LA     4,1(4)       INCREMENT ADDRESS BY 1 SO AS TO POINT TO
*                            COLUMN AFTER C
         CLC    0(1,4),=C'''' ? THERE AN APOSTROPHE ?
         BNE    NOAPOS       IF NOT, GO TO NO APOSTROPHE SEQUENCE
APSEQU   LA     4,1(4)       OTHERWISE, INCREMENT COLUMN COUNTER BY 1
*                            AND SEARCH FOR NEXT APOSTROPHE
         CLC     0(1,4),=C'''' IS THIS THE SECOND APOSTROPHE?
         BE     DUPCON       IF SO, BRANCH TO NEXT STEP
         LA     3,1(3)       OTHERWISE INCREMENT SPACE COUNTER IN
*                            REGISTER 3 AND
         MVC     0(1,11),0(4)  MOVE A BYTE FROM CONTENTS OF DC
*                            STORAGE TO CODE STORAGE
         LA     11,1(11)
DUPCON    CL    8,=F'1'       IS DUPLICATION REQUIRED?
DCFINI   BE     NCARD        GO BACK AND READ NEXT CARD
         BCTR    8,0         OTHERWISE DECREMENT DUPLICATION
*                            FACTOR COUNTER AND
         SR     4,3          RETURN COLUMN COUNTER TO BLANK AFTER
*                            FIRST APOSTROPHE
         BCTR   4,0          DECREMENT COL COUNTER BY AN OTHER 1
         SR      3,3         CLEAR REGISTER 3 FOR NEXT SEQUENCE
         B      APSEQU          CONTINUE
NOAPOS   AR     11,9         INCREMENT ADDRESS IN REG 11 BY REQUIRED
*                              AMOUNT
         B      NCARD        GO BACK AND READ NEXT CARD
OPSEQ    LA     4,1(4)       INCREMENT CARD COUNTER
         CLC    0(1,4),=C' ' TEST FOR BLANK
         BNE    OPSEQ        IF NOT, CONTINUE SEARCH
         LA     4,1(4)       INCREMENT CARD COUNTER
COMOP    CLC  0(2,4),=C'LD'  CHECK TO DETERMINE IF THIS IS THE CODE FOR
         BE     LOAD         LOAD    - BRANCH TO NEXT STEP
         CLC  0(2,4),=C'ST'  CHECK TO DETERMINE IF THIS IS THE CODE FOR
         BE     STORE        STORE   - BRANCH TO NEXT STEP
         CLC  0(2,4),=C'AD'  CHECK TO DETERMINE IF THIS IS THE CODE FOR
         BE     ADD          ADD     - BRANCH TO NEXT STEP
         CLC  0(2,4),=C'SB'  CHECK TO DETERMINE IF THIS IS THE CODE FOR
         BE     SUBTR        SUBTRACT- BRANCH TO NEXT STEP
         CLC  0(2,4),=C'MT'  CHECK TO DETERMINE IF THIS IS THE CODE FOR
         BE     MULT         MULTIPLY- BRANCH TO NEXT STEP
         CLC  0(2,4),=C'DV'  CHECK TO DETERMINE IF THIS IS THE CODE FOR
         BE     DIVIDE       DIVIDE  - BRANCH TO NEXT STEP
         CLC  0(2,4),=C'GT'  CHECK TO DETERMINE IF THIS IS THE CODE FOR
         BE        GOTO      GO TO   - BRANCH TO NEXT STEP
         CLC  0(2,4),=C'IF'  CHECK TO DETERMINE IF THIS IS THE CODE FOR
         BE     IFXX         IF      - BRANCH TO NEXT STEP
         CLC  0(2,4),=C'RD'  CHECK TO DETERMINE IF THIS IS THE CODE FOR
         BE     READXX       READ    - BRANCH TO NEXT STEP
         CLC  0(2,4),=C'WT'  CHECK TO DETERMINE IF THIS IS THE CODE FOR
         BE     WRITXX       WRITE   - BRANCH TO NEXT STEP
         CLC  0(2,4),=C'HT'  CHECK TO DETERMINE IF THIS IS THE CODE FOR
         BE     HALTXX       HALT    - BRANCH TO NEXT STEP
         CLC  0(3,4),=C'END' CHECK TO DETERMINE IF THIS IS THE CODE FOR
         BE     ENDTWO       END CARD- BRANCH TO NEXT STEP
         B      NCARD        IF OPERATION CODE IS INVALID, IGNORE
*                            SAME AND GO TO NEXT CARD
LOAD     LA     4,3(4)       INCREMENT PAST OP CODE AND FIRST BLANK
LBLK     CLC    0(1,4),=C' ' DETERMINE IF BLANK
         BNE    LAORI        IF NOTDETERMINE IF A OR I
         LA     4,1(4)       OTHERWISE INCREMENT COUNTER AND
         B      LBLK         SEARCH AGAIN
LAORI    CLC    0(1,4),=C'A' DETERMINE IF AN A
         BE     LISA         IF SO GO TO NEXT STEP
         MVI    0(11),X'1F'  PLACE APPROPRIATE OPERATIONS CODE
*                            IN FIRST BYTE OF STORAGE
         B      STADD        GO TO NEXT STEP
LISA     MVI    0(11),X'10'  PLACE APPROPRIATE OPERATIONS CODE
*                            IN LEFT PORTION OF FIRST BYTE OF STORAGE
*                            LOCATION (ZERO IN RIGHT HALF)
         B      STADD        GO TO NEXT STEP
STORE    LA     4,3(4)       INCREMENT PAST OP CODE AND FIRST BLANK
STBLK    CLC    0(1,4),=C' ' DETERMINE IF BLANK
         BNE    STAORI       IF NOTDETERMINE IF A OR I
         LA     4,1(4)       OTHERWISE INCREMENT COUNTER AND
         B      STBLK        SEARCH AGAIN
STAORI   CLC    0(1,4),=C'A' DETERMINE IF AN A
         BE     STISA        IF SO GO TO NEXT STEP
         MVI    0(11),X'2F'  PLACE APPROPRIATE OPERATIONS CODE
*                            IN FIRST BYTE OF STORAGE
         B      STADD        GO TO NEXT STEP
STISA    MVI    0(11),X'20'  PLACE APPROPRIATE OPERATIONS CODE
*                            IN LEFT PORTION OF FIRST BYTE OF STORAGE
*                            LOCATION (ZERO IN RIGHT HALF)
         B      STADD        GO TO NEXT STEP
ADD      LA     4,3(4)       INCREMENT PAST OP CODE AND FIRST BLANK
ABLK     CLC    0(1,4),=C' ' DETERMINE IF BLANK
         BNE    AAORI        IF NOTDETERMINE IF A OR I
         LA     4,1(4)       OTHERWISE INCREMENT COUNTER AND
         B      ABLK         SEARCH AGAIN
AAORI    CLC    0(1,4),=C'A' DETERMINE IF AN A
         BE     AISA         IF SO GO TO NEXT STEP
         MVI    0(11),X'3F'  PLACE APPROPRIATE OPERATIONS CODE
*                            IN FIRST BYTE OF STORAGE
         B      STADD        GO TO NEXT STEP
AISA     MVI    0(11),X'30'  PLACE APPROPRIATE OPERATIONS CODE
*                            IN LEFT PORTION OF FIRST BYTE OF STORAGE
*                            LOCATION (ZERO IN RIGHT HALF)
         B      STADD        GO TO NEXT STEP
SUBTR    LA     4,3(4)       INCREMENT PAST OP CODE AND FIRST BLANK
SBBLK    CLC    0(1,4),=C' ' DETERMINE IF BLANK
         BNE    SBAORI       IF NOTDETERMINE IF A OR I
         LA     4,1(4)       OTHERWISE INCREMENT COUNTER AND
         B      SBBLK        SEARCH AGAIN
SBAORI   CLC    0(1,4),=C'A' DETERMINE IF AN A
         BE     SUISA        IF SO GO TO NEXT STEP
         MVI    0(11),X'4F'  PLACE APPROPRIATE OPERATIONS CODE
*                            IN FIRST BYTE OF STORAGE
         B      STADD        GO TO NEXT STEP
SUISA    MVI    0(11),X'40'  PLACE APPROPRIATE OPERATIONS CODE
*                            IN LEFT PORTION OF FIRST BYTE OF STORAGE
*                            LOCATION (ZERO IN RIGHT HALF)
         B      STADD        GO TO NEXT STEP
MULT     LA     4,3(4)       INCREMENT PAST OP CODE AND FIRST BLANK
MBLK     CLC    0(1,4),=C' ' DETERMINE IF BLANK
         BNE    MAORI        IF NOTDETERMINE IF A OR I
         LA     4,1(4)       OTHERWISE INCREMENT COUNTER AND
         B      MBLK         SEARCH AGAIN
MAORI    CLC    0(1,4),=C'A' DETERMINE IF AN A
         BE     MISA         IF SO GO TO NEXT STEP
         MVI    0(11),X'5F'  PLACE APPROPRIATE OPERATIONS CODE
*                            IN FIRST BYTE OF STORAGE
         B      STADD        GO TO NEXT STEP
MISA     MVI    0(11),X'50'  PLACE APPROPRIATE OPERATIONS CODE
*                            IN LEFT PORTION OF FIRST BYTE OF STORAGE
*                            LOCATION (ZERO IN RIGHT HALF)
         B      STADD        GO TO NEXT STEP
DIVIDE   LA     4,3(4)       INCREMENT PAST OP CODE AND FIRST BLANK
DBLK     CLC    0(1,4),=C' ' DETERMINE IF BLANK
         BNE    DAORI        IF NOTDETERMINE IF A OR I
         LA     4,1(4)       OTHERWISE INCREMENT COUNTER AND
         B      DBLK         SEARCH AGAIN
DAORI    CLC    0(1,4),=C'A' DETERMINE IF AN A
         BE     DISA         IF SO GO TO NEXT STEP
         MVI    0(11),X'6F'  PLACE APPROPRIATE OPERATIONS CODE
*                            IN FIRST BYTE OF STORAGE
         B      STADD        GO TO NEXT STEP
DISA     MVI    0(11),X'60'  PLACE APPROPRIATE OPERATIONS CODE
*                            IN LEFT PORTION OF FIRST BYTE OF STORAGE
*                            LOCATION (ZERO IN RIGHT HALF)
         B      STADD        GO TO NEXT STEP
GOTO     MVI    0(11),X'70'  PLACE APPROPRIATE OPERATIONS CODE
         B      STADD        GO TO NEXT STEP
IFXX     LA     4,3(4)       INCREMENT PAST OP CODE AND FIRST BLANK
IBLK     CLC    0(1,4),=C' ' DETERMINE IF BLANK
         BNE    IFHZL        IF NOTDETERMINE IF H, Z OR L
         LA     4,1(4)       OTHERWISE INCREMENT COUNTER AND
         B      IBLK         SEARCH AGAIN
IFHZL    CLC    0(1,4),=C'H' DETERMINE IF AN H
         BE     IFH          BRANCH TO NEXT STEP
         CLC    0(1,4),=C'Z' DETERMINE IF AN Z
         BE     IFZ          BRANCH TO NEXT STEP
IFL      MVI    0(11),X'81'  PLACE APPROPRIATE OPERATIONS CODE
*                            IN FIRST BYTE OF STORAGE
         B      STADD        GO TO NEXT STEP
IFZ      MVI    0(11),X'82'  PLACE APPROPRIATE OPERATIONS CODE
*                            IN FIRST BYTE OF STORAGE
         B      STADD        GO TO NEXT STEP
IFH      MVI    0(11),X'83'  PLACE APPROPRIATE OPERATIONS CODE
*                            IN FIRST BYTE OF STORAGE
         B      STADD        GO TO NEXT STEP
HALTXX   MVI    0(11),X'00'  PLACE APPROPRIATE OPERATIONS CODE
*                            IN LEFT PORTION OF FIRST BYTE OF STORAGE
*                            LOCATION (ZERO IN RIGHT HALF)
         LA     11,1(11)     INCREMENT STORAGE ADDRESS AND
         MVI    0(11),X'00'  FILL THIS BYTE WITH ZEROS
         LA     11,1(11)     INCREMENT STORAGE ADDRESS AND
         MVI    0(11),X'00'  FILL THIS BYTE WITH ZEROS
         LA     11,1(11)     INCREMENT STORAGE ADDRESS AND
         B      NCARD        GO BACK AND READ NEXT CARD
READXX   LA     4,3(4)       INCREMENT PAST OP CODE AND FIRST BLANK
RBLK     CLC    0(1,4),=C' ' DETERMINE IF BLANK
         BNE    RIORC        IF NOTDETERMINE IF I OR C
         LA     4,1(4)       OTHERWISE INCREMENT COUNTER AND
         B      RBLK         SEARCH AGAIN
RIORC    CLC    3(1,4),=C'I' READ PAST LABLE NAME AND COMMA TO FIND IF
         BE     RISA         I. IF SO  GO TO NEXT STEP
         LA     4,3(4)       INCREMENT ADDRESS SO AS TO GET PAST
*                            LABLE NAME AND COMMA (IF A C)
RI10     CLC    0(2,4),=C'10' IF NOT, IT IS A CHARACTER SO CHECK IF
*                            A 2 DIGIT NUMBER
         BNE    RI11         IF NOT, TRY NEXT I DIGIT NUMBER
         MVI    0(11),X'BA'  PLACE APPROPRIATE OPERATIONS CODE
         B      DEC3
RI11     CLC    0(2,4),=C'11' IF NOT, IT IS A CHARACTER SO CHECK IF
*                            A 2 DIGIT NUMBER
         BNE    RI12         IF NOT, TRY NEXT I DIGIT NUMBER
         MVI    0(11),X'BB'  PLACE APPROPRIATE OPERATIONS CODE
         B      DEC3
RI12     CLC    0(2,4),=C'12' IF NOT, IT IS A CHARACTER SO CHECK IF
*                            A 2 DIGIT NUMBER
         BNE    RI13         IF NOT, TRY NEXT I DIGIT NUMBER
         MVI    0(11),X'BC'  PLACE APPROPRIATE OPERATIONS CODE
         B      DEC3
RI13     CLC    0(2,4),=C'13' IF NOT, IT IS A CHARACTER SO CHECK IF
*                            A 2 DIGIT NUMBER
         BNE    RI14         IF NOT, TRY NEXT I DIGIT NUMBER
         MVI    0(11),X'BD'  PLACE APPROPRIATE OPERATIONS CODE
         B      DEC3
RI14     CLC    0(2,4),=C'14' IF NOT, IT IS A CHARACTER SO CHECK IF
*                            A 2 DIGIT NUMBER
         BNE    RI15         IF NOT, TRY NEXT I DIGIT NUMBER
         MVI    0(11),X'BE'  PLACE APPROPRIATE OPERATIONS CODE
         B      DEC3
RI15     CLC    0(2,4),=C'15' IF NOT, IT IS A CHARACTER SO CHECK IF
         BNE    RTEST        IF NOT, TRY TEST OF SINGLE DIGIT NUMS
         MVI    0(11),X'BF'  PLACE APPROPRIATE OPERATIONS CODE
         B      DEC3
RTEST    TRT    0(1,4),TESNUM   FIND WHICH NUMBER (ANSWER IN REG 2)
         SRDL   2,4          PUSH NIBBLE WITH NUMBER INTO REG 3
         LA     2,=B'1011'   PLACE OP CODE SYMBOL IN REG 2
         SLDL   2,4          SHIFT OP CODE A NIBBLE TO LEFT AND ADD
*                            PREVIOUSLY STOREED NUMBER IN REG 3
         STC    2,0(11)      PLACE UNSIGNED OP CODE + NUM IN STORAGE
         B      DEC3
RISA     LA     4,4(4)       INCREMENT ADDRESS TO GET PAST LABLE,
*                            COMMA AND I
         TRT    0(1,4),TESNUM   FIND WHICH NUMBER (ANSWER IN REG 2)
         SRDL   2,4          PUSH NIBBLE WITH NUMBER INTO REG 3
         LA     2,=B'1010'   PLACE OP CODE SYMBOL IN REG 2
         SLDL   2,4          SHIFT OP CODE A NIBBLE TO LEFT AND ADD
*                            PREVIOUSLY STOREED NUMBER IN REG 3
         STC    2,0(11)      PLACE UNSIGNED OP CODE + NUM IN STORAGE
         B      DEC4
WRITXX   LA     4,3(4)       INCREMENT PAST OP CODE AND FIRST BLANK
WBLK     CLC    0(1,4),=C' ' DETERMINE IF BLANK
         BNE    WIORC        IF NOTDETERMINE IF I OR C
         LA     4,1(4)       OTHERWISE INCREMENT COUNTER AND
         B      WBLK         SEARCH AGAIN
WIORC    CLC    3(1,4),=C'I' READ PAST LABLE NAME AND COMMA TO FIND IF
         BE     WISA         I. IF SO  GO TO NEXT STEP
         LA     4,3(4)       INCREMENT ADDRESS SO AS TO GET PAST
*                            LABLE NAME AND COMMA (IF A C)
WI10     CLC    0(2,4),=C'10' IF NOT, IT IS A CHARACTER SO CHECK IF
*                            A 2 DIGIT NUMBER
         BNE    WI11         IF NOT, TRY NEXT I DIGIT NUMBER
         MVI    0(11),X'DA'  PLACE APPROPRIATE OPERATIONS CODE
         B      DEC3
WI11     CLC    0(2,4),=C'11' IF NOT, IT IS A CHARACTER SO CHECK IF
*                            A 2 DIGIT NUMBER
         BNE    WI12         IF NOT, TRY NEXT I DIGIT NUMBER
         MVI    0(11),X'DB'  PLACE APPROPRIATE OPERATIONS CODE
         B      DEC3
WI12     CLC    0(2,4),=C'12' IF NOT, IT IS A CHARACTER SO CHECK IF
*                            A 2 DIGIT NUMBER
         BNE    WI13         IF NOT, TRY NEXT I DIGIT NUMBER
         MVI    0(11),X'DC'  PLACE APPROPRIATE OPERATIONS CODE
         B      DEC3
WI13     CLC    0(2,4),=C'13' IF NOT, IT IS A CHARACTER SO CHECK IF
*                            A 2 DIGIT NUMBER
         BNE    WI14         IF NOT, TRY NEXT I DIGIT NUMBER
         MVI    0(11),X'DD'  PLACE APPROPRIATE OPERATIONS CODE
         B      DEC3
WI14     CLC    0(2,4),=C'14' IF NOT, IT IS A CHARACTER SO CHECK IF
*                            A 2 DIGIT NUMBER
         BNE    WI15         IF NOT, TRY NEXT I DIGIT NUMBER
         MVI    0(11),X'DE'  PLACE APPROPRIATE OPERATIONS CODE
         B      DEC3
WI15     CLC    0(2,4),=C'15' IF NOT, IT IS A CHARACTER SO CHECK IF
*                            A 2 DIGIT NUMBER
         BNE    WTEST        IF NOT, TRY TEST OF SINGLE DIGIT NUMS
         MVI    0(11),X'DF'  PLACE APPROPRIATE OPERATIONS CODE
         B      DEC3
WTEST    TRT    0(1,4),TESNUM   FIND WHICH NUMBER (ANSWER IN REG 2)
         SRDL   2,4          PUSH NIBBLE WITH NUMBER INTO REG 3
         LA     2,=B'1101'   PLACE OP CODE SYMBOL IN REG 2
         SLDL   2,4          SHIFT OP CODE A NIBBLE TO LEFT AND ADD
*                            PREVIOUSLY STOREED NUMBER IN REG 3
         STC    2,0(11)      PLACE UNSIGNED OP CODE + NUM IN STORAGE
         B      DEC3
WISA     LA     4,4(4)       INCREMENT ADDRESS TO GET PAST LABLE,
*                            COMMA AND I
         TRT    0(1,4),TESNUM   FIND WHICH NUMBER (ANSWER IN REG 2)
         SRDL   2,4          PUSH NIBBLE WITH NUMBER INTO REG 3
         LA     2,=B'1100'   PLACE OP CODE SYMBOL IN REG 2
         SLDL   2,4          SHIFT OP CODE A NIBBLE TO LEFT AND ADD
*                            PREVIOUSLY STOREED NUMBER IN REG 3
         STC    2,0(11)      PLACE UNSIGNED OP CODE + NUM IN STORAGE
DEC4     BCTR   4,0          DECREMENT COUNTER TO POINT TO LABLE
DEC3     BCTR   4,0          DECREMENT COUNTER TO POINT TO LABLE
         BCTR   4,0          DECREMENT COUNTER TO POINT TO LABLE
         BCTR   4,0          DECREMENT COUNTER TO POINT TO LABLE
STADD    LA     4,2(4)       INCREMENT COLUMN COUNTERPAST A ORF AND
*                            COMMA SO AS TO POINT TO OPERAND LABLE
         LA     11,1(11)     INCREMEN\ ADDRESS OF CODE STORAGE (OUTP.)
         LR       5,15    PLACE ADDRESSS OF LABLETABLE IN REG 5
EXLTAB   CLC    0(2,4),0(10) EXAMINE A LABLE IN LABLE TABLE TO SEE IF
*                            ITIS THE ONE DESIRED
         BE     LABFND       IF SO GO TO LABLE FOUND STEP
         LA     10,6(10)     OTHERWISE INCREMENT LABLE COUNTER AND
         B      EXLTAB       CONTINUE SEARCH
LABFND   PACK   PCODE(2),0(4,4)    PACK ADDRESS +
         L      2,PCODE      PLACE PACKED CODE + NUM BACK IN REG 2
         SRL    2,4          ELIMINATE SIGN BITS FROM ADDRESS
         STC    2,0(11)      PLACE ADDRESS SEGMENT IN STORAGE
         LA     11,1(11)     INCREMENT STORAGE ADDRESS AND
         STC    2,0(11)      PLACE ADDRESS SEGMENT IN STORAGE
         B      NCARD        GO BACK AND READ NEXT CARD
ENDTWO   L      13,SAVTWO+4
         LM     14,12,12(13)
         BR     14
UCODE    DS     F
PCODE    DS     F
SAVTWO   DS     18F
LABTWO   DC     C' PASS TWO'
         LTORG
         EJECT
         TITLE 'CONSTRUCTION OF ASSEMBLER AND INTERPRETER FOR CS 410'
INTERP   CSECT
         STM    14,12,12(13)
         BALR   12,0
         USING  *,12
         ST     13,SAVINT+4
         USING  TESECT,7
         XPRNT  LABINT,12    PRINT TITLE OF INTERPRETER OUTPUT
         LR     15,11        USE REG 11 AS A 'BASEREGISTER' FOR CODE
*                            TABLE. PLACE ADDRESS OF CODE TABLE IN REG
*                            15 AND USE LATTER TO POINT TO NEXT STEP
         B      AUSSER       SKIP THIS STEP THE FIRST TIME
NACHST   LA     15,3(15)     INCREMENT COUNTER TO POINT TO NEXT STEP
AUSSER   CLI    0(15),X'00'    DETERMINE IF PROGRAM HAS ENDED,(HALT
*                            STATEMENT CODE)
         BE     ENDINT       IF SO, BRANCH TO PROGRAM COMPLETION SEQ
         IC     4,1(15)      PLACE LEFT HALF OF PURE PACKED ADDRESS
*                            OF OPERAND FROM CODE STORAGE INTO REG4
          SLL   4,8          MAKE ROOM FOR REST OF ADDRESSS
         IC     4,2(15)      PLACE RIGHTHALF OF PURE PACKED ADDRESS
*                            OF OPERAND FROM CODE STORAGE INTO REG4
         L      5,=C'5555'   PLACE X 'F5' IN REG 5
         SLDL   4,4          SHIFT NIBBLE WITH F FROMREG 5 TO REG4
         ST     4,PKADDR
         UNPK    UNADDR(4),PKADDR(3) UNPACK AND PLACE IN  TEMP STORAGE
         CLI    0(15),X'10'
         BE        LDASEQ
         CLI    0(15),X'1F'
         BE     LDISEQ
         CLI    0(15),X'20'
         BE     STASEQ
         CLI    0(15),X'2F'
         BE     STISEQ
         CLI    0(15),X'30'
         BE     ADASEQ
         CLI    0(15),X'3F'
         BE     ADISEQ
         CLI    0(15),X'40'
         BE     SBASEQ
         CLI    0(15),X'4F'
         BE     SBISEQ
         CLI    0(15),X'50'
         BE     MTASEQ
         CLI    0(15),X'5F'
         BE     MTISEQ
         CLI    0(15),X'60'
         BE     DVASEQ
         CLI    0(15),X'6F'
         BE     DVISEQ
         CLI    0(15),X'70'
         BE     GTSEQ
         CLI    0(15),X'81'
         BE     IFLSEQ
         CLI    0(15),X'82'
         BE     IFZSEQ
         CLI    0(15),X'83'
         BE     IFHSEQ
         SR     9,9          IF IT IS NOT ONE OF THE ABOVE, IT IS A
*                            READ OR WRITE STATEMENT. SO CLEAR
*                            REG 9 FOR NEXT STEP
         SR     8,8
         IC     8,0(15)      PLACE OP CODE AND LENGTH IN REG 8
         SRDL   8,4          LEAVE OP CODE IN REG 8 AND PLACE LENGTH
*                            TO BE READ OR WRITEN IN REG 9
         ST     8,OPER
         LA     2,OPER
         L      8,=X'FFFFFFFF'  LOAD REG 8 WITH ONES
         SRDL   8,4          MOVE AN 'F' INTO REGISTER 9 NEXT TO
*                            PURE LENGTH (UNDER 10) TO GIVE DECIMAL
         SRL    9,24         MOVE LENGTH TO FAR RIGHT OF REG 9
         ST     9,LENGTH     PLACE THE DECIMAL REPRESENTATION OF THE
*                            LENGTH TO BE READ OR WRITTEN INTO STORAGE
         LA     9,LENGTH
         SR     8,8
TRY10    CLI    0(9),X'FA'
         BNE    TRY11
         LA     8,=C'0010'
         B      LENOK
TRY11    CLI    0(9),X'FB'
         BNE    TRY12
         LA     8,=C'0011'
         B      LENOK
TRY12    CLI    0(9),X'FC'
         BNE    TRY13
         LA     8,=C'0012'
         B      LENOK
TRY13    CLI    0(9),X'FD'
         BNE    TRY14
         LA     8,=C'0013'
         B      LENOK
TRY14    CLI    0(9),X'FE'
         BNE    TRY15
         LA     8,=C'0014'
         B      LENOK
TRY15    CLI    0(9),X'FF'
         BNE     LENFND     OPER CONTAINS A 'REAL' DECIMAL
         LA     8,=C'0015'
         B      LENOK
LENFND   L      8,0(9)
         LR     1,8
LENOK    ST     8,0(9)
         SR     9,9
         CLI    0(2),X'0A'
         BE     RDISEQ
         CLI    0(2),X'0C'
         BE     WTISEQ
         CLI    0(2),X'0D'
         BE     WTCSEQ
RDCSEQ   CLC    0(2,3),=C'##'   DETERMINE IF ALL THE DATA CARDS AVE
         BE     ENDINT       BEEN READ. IF SO, TERMINATE THE PROGRAM
MORC     MVC    0(1,15),0(3)   MOVE A BYTE OF
*                                       THE DESIRED NUMBER OF COLUMNS
*                            FROM THE 'DATA' CARD TO'STORAGE'
         LA     15,1(15)
         LA     3,1(3)
         CR     8,9
         BE     NXTC
         BCTR   8,0
         B      MORC
NXTC     SR     3,1
         LA     3,40(3)      INCREMENT THE ARRAY TO POINT TO NEXT DATA
         B      AUSSER
RDISEQ   CLC    0(2,3),=C'##'   DETERMINE IF ALL THE DATA CARDS AVE
         BE     ENDINT       BEEN READ. IF SO, TERMINATE THE PROGRAM
MORI     MVC    0(1,15),0(3)   MOVE A BYTE OF
*                                       THE DESIRED NUMBER OF COLUMNS
*                            FROM THE 'DATA' CARD TO'STORAGE'
         LA     15,1(15)
         LA     3,1(3)
         CR     8,9
         BE     NXTI
         BCTR   8,0
         B      MORI
NXTI     SR     3,1
         LA     3,40(3)      INCREMENT THE ARRAY TO POINT TO NEXT DATA
         B      AUSSER
WTCSEQ   XPRNT  UNADDR(11),15      TRANSLATE INTO ASSEMBLER
         B      NACHST       GO TO THE NEXT STEP IN PROGRAM
WTISEQ   XPRNT  UNADDR(11),8       TRANSLATE INTO ASSEMBLER
         B      NACHST       GO TO THE NEXT STEP IN PROGRAM
LDASEQ   L      1,UNADDR(11) TRANSLATE NEW LANGUAGE INTO ASSEMPLER
         B      NACHST       GO TO THE NEXT STEP IN PROGRAM
LDISEQ   L      3,UNADDR(11) TRANSLATE NEW LANGUAGE INTO ASSEMBLER
         B      NACHST       GO TO THE NEXT STEP IN PROGRAM
STASEQ   ST     1,UNADDR(11) TRANSLATE NEW LANGUAGE INTO ASSEMBLER
         B      NACHST       GO TO THE NEXT STEP IN PROGRAM
STISEQ   ST     3,UNADDR(11) TRANSLATE NEW LANGUAGE INTO ASSEMBLER
         B      NACHST       GO TO THE NEXT STEP IN PROGRAM
ADASEQ   A      1,UNADDR(11) TRANSLATE NEW LANGUAGE INTO ASSEMBLER
         B      NACHST       GO TO THE NEXT STEP IN PROGRAM
ADISEQ   A      3,UNADDR(11) TRANSLATE NEW LANGUAGE INTO ASSEMPLER
         B      NACHST       GO TO THE NEXT STEP IN PROGRAM
SBASEQ   S      1,UNADDR(11) TRANSLATE NEW LANGUAGE INTO ASSEMPLER
         B      NACHST       GO TO THE NEXT STEP IN PROGRAM
SBISEQ   S      3,UNADDR(11) TRANSLATE NEW LANGUAGE INTO ASSEMPLER
         B      NACHST       GO TO THE NEXT STEP IN PROGRAM
MTASEQ   M      2,UNADDR(11) TRANSLATE NEW LANGUAGE INTO ASSEMPLER
         LR     1,3
         B      NACHST       GO TO THE NEXT STEP IN PROGRAM
MTISEQ   M      2,UNADDR(11) TRANSLATE NEW LANGUAGE INTO ASSEMPLER
         B      NACHST       GO TO THE NEXT STEP IN PROGRAM
DVASEQ   D      2,UNADDR(11) TRANSLATE NEW LANGUAGE INTO ASSEMPLER
         LR     1,3
         B      NACHST       GO TO THE NEXT STEP IN PROGRAM
DVISEQ   D      2,UNADDR(11) TRANSLATE NEW LANGUAGE INTO ASSEM!LER
         B      NACHST       GO TO THE NEXT STEP IN PROGRAM
GTSEQ    LA     15,UNADDR(11)  TRANSLATE INTO ASSEMBLER
         B      AUSSER       GO TO NEXT STEP SKIPPING INCREMENT STEP
IFLSEQ   SR     2,2          CLEAR REG 2 SO IT IS 0 FOR COMPARISON
         CR     1,2          COMPARE REG 1 (ACCUMULATOR)  WITH 0
         BNL    NACHST       GO TO NEXT STEP IN PROGRAM
         LA     15,UNADDR(11)  TRANSLATE INTO ASSEMBLER
         B      AUSSER       GO TO NEXT STEP SKIPPING INCREMENT STEP
IFZSEQ   SR     2,2          CLEAR REG 2 SO IT IS 0 FOR COMPARISON
         CR     1,2          COMPARE REG 1 (ACCUMULATOR ) WITH 0
         BNE    NACHST       GO TO NEXT STEP IN PROGRAM
         LA     15,UNADDR(11)  TRANSLATE INTO ASSEMBLER
         B      AUSSER       GO TO NEXT STEP SKIPPING INCREMENT STEP
IFHSEQ   SR     2,2          CLEAR REG 2 SO IT IS 0 FOR COMPARISON
         CR     1,2          COMPARE REG 1 (ACCUMULATOR)  WITH 0
         BNH    NACHST       GO TO NEXT STEP IN PROGRAM
         LA     15,UNADDR(11)  TRANSLATE INTO ASSEMBLER
         B      AUSSER       GO TO NEXT STEP SKIPPING INCREMENT STEP
ENDINT   L      13,SAVINT+4
         LM     14,12,12(13)
         BR     14
SAVINT   DS      18F
UNADDR   DS     F
PKADDR   DS     F
OPER     DS     F
LENGTH   DC     C'0001'
         LTORG
LABINT   DC     C' INTERPRETER'
      EJECT
TESECT   DSECT
LABTAB   DS      150F
TESNUM   DC     256X'00'
TESLET   DC     256X'00'
ADDATA   DS     F
SOURCE   DS      4000C
OUTPUT   DC     1000X'EE'
         EJECT
                END
$ENTRY
BEGIN JOB
     WT   H1,15C
     LD   I,Z1   Z1=0
T5   RD   T1,I4   READ A NUMBER
      LD   A,T1
    IF  Z,D1   IF ZERO=>LAST NUMBER
     WT   T1,I5
   LD I,I1   INDEX INTO A1 ARRAY
   ST  A,A1  STORE T1 IN ARRAY A1
 AD    I,F1   KICK UP INDEX
    ST  I,I1   SAVE INDEX FOR NEXT LOOP
    LD  I,Z1  INDEX=0
    GT  T5   GO TO READ AGAIN
T1   DS   F
Z1   DC   F'0'
I1   DC   F'0'
F1   DC   F'4'
H1  DC  C'THE NUMBERS ARE'
D1  LD  A,I1  LOAD VALUE OF INDEX
  DV A,F1
     ST   A,N1   N1=NUMBER OF #'S
    LD  I,Z1   INDEX=0
   ST  I,I1    I1=0
   WT   H2,11C
T6 LD I,I1   LOAD INDEX
   LD  A,A1 GET VALUE FROM ARRAY
     MT  A,A1   SQUARE THE VALUE
   AD    I,F1   KICK UP INDEX
     ST   I,I1   SAVE INDEX
     LD   I,Z1   INDEX=0
     ST   A,T1
     WT   T1,I10   WRITE SQUARED NUMBER
     LD   A,S1   LOAD THE SUM
     AD    A,T1   SUM THE SQUARES
     ST   A,S1    SAVE THE SUM
   LD   A,N1 N1= NUMBER OF TIMES TO LOOP
    SB   A,C1   SUBTRACT ONE
    ST   A,N1    SAVE COPY OF N1
   IF   H,T6  IF POSITIVE THEN LOOP
    WT  H3,14C
    WT  S1,I8   WRITE THE SUM OF SQUARES
    HT       STOP
N1 DC F'0'
C1  DC 2F'1'
H2  DC  C'SQUARES ARE'
S1           DC          F'0'
H3   DC   C'SUM OF SQUARES'
A1  DC       20F'0'
    END
##
  30
   2
   4
  25
##
