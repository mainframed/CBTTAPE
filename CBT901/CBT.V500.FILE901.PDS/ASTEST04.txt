//ASTEST04 JOB (SYS),'ASSIST IVP TEST #4',CLASS=S,MSGCLASS=X
//*
//TESTPROG EXEC ASSIST
//SYSIN DD *
$JOB   ASSIST       MACRO=F
***********************************************************************
*                                                                     *
*              SET OF JOBS - ILLUSTRATES MACRO PROCESSOR UNDER        *
*              REASONABLE AND NORMAL OPERATIONS - WITH SOME ACTUAL    *
*              PROGRAM WRITTEN PREVIOUSLY.                            *
***********************************************************************
         TITLE 'MACRO ILLUSTRATION TEST'
         MACRO
&L       @DOUB &REG,&TIMES
         AIF   (&TIMES LT 1).ZERO
         AIF   (&TIMES EQ 1).AR
&L       SLL   &REG,&TIMES
         MEXIT
.AR      ANOP
&L       AR    &REG,&REG
.ZERO    MEND
         SPACE 3
         MACRO
&L       MULT  &OUT,&IN,&BY
         LCLA  &X,&BP,&DC,&SL,&WORK
         LCLC  &AR,&SR
         LCLB  &B(33)
         AIF   (&BY NE 0).NOTZERO
         MNOTE ,'*** MULT ***   JUST WHAT ARE YOU TRYING TO DO ??? ***'
&L       SR    &OUT,&OUT
         MEXIT
         SPACE 1
.NOTZERO AIF   (&BY GT 0).PLUS
         LCR   &OUT,&IN
&AR      SETC  'SR'
&SR      SETC  'AR'
&X       SETA  0-&BY
         AGO   .CONVERT
.PLUS    LR    &OUT,&IN
&AR      SETC  'AR'
&SR      SETC  'SR'
&X       SETA  &BY
.CONVERT ANOP
&B(33)   SETB  (0)
&B(32)   SETB  (0)
&BP      SETA  31
.CONLOOP ANOP
&WORK    SETA  &X
&X       SETA  &X/2
&WORK    SETA  &WORK-2*&X
&B(&BP)  SETB  (&WORK)
&BP      SETA  &BP-1
         AIF   (&BP GT 0).CONLOOP
         AIF   (&X NE 0).BLEWIT
&DC      SETA  0
.FIRST   ANOP
&BP      SETA  &BP+1
         AIF   ( NOT &B(&BP)).FIRST
.HEAD    AIF   (&B(&BP+1) AND &B(&BP+2)).SHIFTY
         @DOUB &OUT,&DC
         &AR   &OUT,&IN
&DC      SETA  1
&BP      SETA  &BP+1
         AGO   .FOOT
.SHIFTY  ANOP
&WORK    SETA  &DC-1
         @DOUB &OUT,&WORK
&DC      SETA  1
         &AR   &OUT,&IN
&SL      SETA  0
.SCAN    ANOP
&SL      SETA  &SL+1
&BP      SETA  &BP+1
         AIF   (&B(&BP)).SCAN
         SLL   &OUT,&SL
         &SR   &OUT,&IN
.FOOT    AIF   (&B(&BP)).HEAD
&BP      SETA  &BP+1
&DC      SETA  &DC+1
         AIF   (&BP LT 32).FOOT
&WORK    SETA  &DC-2
         @DOUB &OUT,&WORK
         SPACE 2
         MEXIT
.BLEWIT  MNOTE 16,'*** MULT ***  INTERNAL MACRO ERROR, SOMEBODY GOOFED'
         MEND
         SPACE 3
* THE CORRECT CODE FOR THE FOLLOWING MACRO IS AS FOLLOWS
*        LR    1,2           1*
*        SLL   1,5           (2**5)=32*
         MULT  1,2,32
* THE CORRECT CODE FOR THE FOLLOWING MACRO IS AS FOLLOWS
*        LR    2,3           1*
*        SLL   2,2           (2**2)=4*
LABEL1   MULT  2,3,4
* THE CORRECT CODE FOR THE FOLLOWING MACRO IS AS FOLLOWS
*        LR    5,4           1*
*        AR    5,5           2*
*        AR    5,4           +1=3*
THREE    MULT  5,4,3
* THE CORRECT CODE FOR THE FOLLOWING MACRO IS AS FOLLOWS
*        LR    6,8           1*
*        SLL   6,6           (2**6)=64*
*        SR    6,8           -1=63*
         MULT  6,8,63
* THE FOLLOWING NUMBERS WERE PICKED OUT OF THE AIR SO WHO KNOWS
* WHAT THEY WILL PRODUCE, BUT IT CAN BE CHECKED
         MULT  3,5,7238
         MULT  5,6,5570
         END
$JOB   ASSIST       MACRO=F
         TITLE 'MACRO - PA DEMAINE - SOLID SYSTEM'
******************************** REIDC *********************AUGUST/1970
           MACRO
&J         REIDC &FMT,&VAR,&LEN=$,&SAV=$,&MSG=$,&CC=0
*XXXXXXXXXXXXXXXXXXXXXXXXXXXX    REIDC     XXXXXXXXXXXXXXXXXXXXXXXXXXXX
*---REIDC IS THE CALLING ROUTINE FOR FORMATTED INPUT FROM CARDS.
*---&FMT IS THE LIST OF FORMATS TO BE USED DURING THE READ.
*---&VAR IS THE LIST OF VARIABLES TO BE READ (USE LIST FORM ).
*---&LEN IS A FULL WORD TO STORE THE NUMBER OF BYTES READ.
*---&SAV IS A SAVEAREA FROM USER OR DEFINED IN ROUTINE.
*---&MSG IS A 132 BYTE WORKAREA FOR PRINTING MESSAGES FROM READ.
*---&CC IS A CARRIAGE CONTROL CHARACTER TO BE USED WHEN PRINT. MESS.
*----------------------------------------------------------------------
           LCLA  &FLG,&NV,&CFMT,&CVAR,&C1,&C2,&C3,&C4,&C5
           LCLC  &NAM1,&NAM2
           SPACE 2
.* SET FLAG AND COUNT FOR SET SYMBOLS &FLG AND &NV.
&FLG       SETA  N'&SYSLIST
&NV        SETA  N'&VAR
.* CHECK IF THE COUNTS ARE IN THE PROPER RANGE.
           AIF   (K'&FMT EQ 0 OR K'&VAR EQ 0).ARGERR
           AIF   (&FLG LT 2 OR &FLG GT 6).ARGERR
           AIF   (&NV LT 1 OR &NV GT 8).VARERR
*** ALIGN THE CODE ON A WORD BOUNDARY.
           CNOP  0,4
.* DETERMINE HOW THE SAVEAREA FOR REGISTERS IS TO BE SET UP.
           AIF   ('&SAV'(1,1) EQ '$').MAC1
.* USE SAVEAREA PROVIDED BY THE USER (&SAV).
&J         STM   14,1,&SAV      .              *SAVE REGISTERS FOR I/O.
&FLG       SETA  1
           AGO   .MAC2
.* DEFINE SAVEAREA WITHIN THIS MACRO.
.MAC1      ANOP
&J         STM   14,1,DA&SYSNDX. .             *SAVE REGISTERS FOR I/O.
&FLG       SETA  2
.* CREATE ARGUMENT LIST FOR I/O ROUTINE.
.MAC2      ANOP
&C1        SETA  1
&C2        SETA  0
&C3        SETA  4
           B     EA&SYSNDX. .             *BRANCH AROUND ARGUMENT LIST.
AA&SYSNDX  DC    F'&NV.' .             *NUMBER OF VARIABLES TO BE READ.
           DC    A(CA&SYSNDX.) .          *ADDRESS OF THE READ FORMATS.
.* CREATE ADDRESSES FOR EACH OF THE VARIABLES.
.MAC3      AIF   ('&VAR(&C1)'(1,1) EQ '*').MAC4
           AIF   ('&VAR(&C1)'(1,8) EQ 'GENERATE').MAC3A
           AIF   ('&VAR(&C1)'(1,8) EQ 'NOSCREEN').MAC3A
           AIF   ('&VAR(&C1)'(1,7) EQ 'JLRSKIP').MAC3A
           AIF   ('&VAR(&C1)'(1,7) EQ 'NUMDIAG').MAC3A
           AIF   ('&VAR(&C1)'(1,7) EQ 'KLENGTH').MAC3A
           AIF   ('&VAR(&C1)'(1,7) EQ 'LLENGTH').MAC3A
           AIF   ('&VAR(&C1)'(1,7) EQ 'NEWFILE').MAC3A
           AIF   ('&VAR(&C1)'(1,6) EQ 'JLGATE').MAC3A
           AIF   ('&VAR(&C1)'(1,6) EQ 'JVALUE').MAC3A
           AIF   ('&VAR(&C1)'(1,6) EQ 'MVALUE').MAC3A
           AIF   ('&VAR(&C1)'(1,6) EQ 'RSKIPS').MAC3A
           AIF   ('&VAR(&C1)'(1,6) EQ 'NTASKS').MAC3A
           AIF   ('&VAR(&C1)'(1,6) EQ 'SECURE').MAC3A
           AIF   ('&VAR(&C1)'(1,6) EQ 'LEXCON').MAC3A
           AIF   ('&VAR(&C1)'(1,6) EQ 'OUTPXT').MAC3A
           AIF   ('&VAR(&C1)'(1,6) EQ 'RNOSEG').MAC3A
           AIF   ('&VAR(&C1)'(1,5) EQ 'TGATE').MAC3A
           AIF   ('&VAR(&C1)'(1,5) EQ 'NJOBS').MAC3A
           AIF   ('&VAR(&C1)'(1,5) EQ 'NFORM').MAC3A
           AIF   ('&VAR(&C1)'(1,5) EQ 'INPXT').MAC3A
           AIF   ('&VAR(&C1)'(1,5) EQ 'LEXNO').MAC3A
           AIF   ('&VAR(&C1)'(1,4) EQ 'RNOS').MAC3A
           AIF   ('&VAR(&C1)'(1,4) EQ 'MODE').MAC3A
           AIF   ('&VAR(&C1)'(1,2) EQ 'LJ').MAC3A
           AIF   ('&VAR(&C1)'(1,2) NE 'NV').MAC3B
.* ARGUMENT IS SYMBOLIC ADDRESS (USE VDCON FOR ADDRESS).
.MAC3A     DC    V(&VAR(&C1).) .         *ADDRESS OF SYMBOLIC ARGUMENT.
           AGO   .MAC5
.* ARGUMENT IS SYMBOLIC ADDRESS (USE ADCON FOR ADDRESS).
.MAC3B     DC    A(&VAR(&C1).) .         *ADDRESS OF SYMBOLIC ARGUMENT.
           AGO   .MAC5
.* ARGUMENT IS IN REGISTER NOTATION (DEFINE STORAGE FOR LATER USE).
.MAC4      DC    F'0' .             *ADDRESS FOR REGISTER NOTATION ARG.
&C2        SETA  &C2+1
.* SEE IF ALL ARGUMENTS HAVE BEEN PROCESSED.
.MAC5      ANOP
&C3        SETA  &C3+4
&C1        SETA  &C1+1
           AIF   (&C1 LE &NV).MAC3
.* ARGUMENT LIST SET UP FOR VARIABLES - SEE IF PRINT MESSAGE IS WANTED.
           AIF   ('&MSG'(1,1) EQ '$').MAC6
.* PRINT OUT READ MESSAGE DURING EXECUTION.
.*   DEFINE THE CARRIAGE CONTROL CHAR. AND ADDRESS OF MACRO BEGIN.
           AIF   ('&MSG'(1,1) EQ '*').MAC5A
&NAM1      SETC  '&MSG'
           DC    CL1'&CC.',AL3(AA&SYSNDX.-8)
&C4        SETA  1
           AGO   .MAC5B
.MAC5A     ANOP
&NAM1      SETC  '&MSG'(2,8)
           DC    CL1'&CC.',AL3(0)
&C4        SETA  2
.MAC5B     AIF   ('&NAM1'(1,4) EQ 'DASH').MAC5C
           AIF   ('&NAM1'(1,5) EQ 'BLANK').MAC5C
           AIF   ('&NAM1'(1,5) EQ 'WORKA').MAC5C
           DC    A(&NAM1.)
           AGO   .MAC5D
.MAC5C     DC    V(&NAM1.)
.MAC5D     ANOP
&C3        SETA  &C3+8
           AIF   (&C4 EQ 2).MAC6
.*         DEFINE STORAGE FOR THE VARIABLE LIST SYMBOLS.
&CVAR      SETA  (K'&VAR+1)/2*2
           AIF   (&CVAR LE 50).LESS
&CVAR      SETA  50
.LESS      ANOP
BA&SYSNDX  DC    CL&CVAR.'&VAR.'
.* DEFINE STORAGE FOR THE FORMAT LIST SYMBOLS.
.MAC6      ANOP
&CFMT      SETA  (K'&FMT+1)/2*2
CA&SYSNDX  DC    CL10'&FMT.'
.* DEFINE SAVEAREA FOR REGISTERS IF REQUESTED.
           AIF   (&FLG NE 2).MAC7
           DS    0F
DA&SYSNDX  DS    4F .                          *SAVEAREA FOR REGISTERS.
.* END OF STORAGE DEFINITION - CONTINUE EXECUTION.
.MAC7      ANOP
EA&SYSNDX  EQU   * .                *CONTINUE EXECUTION AFTER ARG LIST.
           AIF   (&C2 EQ 0).MAC11
.* MUST LOAD ADDRESS OF REGISTER NOTATION ARGUMENTS.
&C1        SETA  1
&C5        SETA  8
.MAC8      AIF   ('&VAR(&C1)'(1,1) NE '*').MAC10
&NAM1      SETC  '&VAR(&C1)'(2,8)
&NAM2      SETC  '        '
           AIF   (K'&VAR(&C1)-9 LE 0).MAC9
&NAM2      SETC  '&VAR(&C1)'(10,8)
.MAC9      LA    0,&NAM1&NAM2 .              *LOAD ADDRESS OF VARIABLE.
           ST    0,AA&SYSNDX.+&C5 .    *STORE ADDRESS IN ARGUMENT LIST.
&C2        SETA  &C2-1
.MAC10     ANOP
&C5        SETA  &C5+4
&C1        SETA  &C1+1
           AIF   (&C2 GT 0).MAC8
.* FINISHED LOADING ARGUMENT LIST - SET END OF LIST FLAG.
.*  SEE IF AN ORG INSTRUCTION CAN MARK END OF ARGLIST.
.*  IF PRINTING MESSAGES DURING EXECUTION, CAN USE ORG TO MARK LIST.
.MAC11     AIF   ('&MSG'(1,1) EQ '$').MAC13
.* SET LOC COUNTER BACK TO MARK LIST END.
.MAC12     ORG   AA&SYSNDX.+&C3.
           DC    X'80' .                 *TAG END END OF ARGUMENT LIST.
           ORG
           AGO   .MAC14
.*  IF LAST ARG IS NON-REGISTER NOTATION - CAN USE ORG TO TAG LIST.
.MAC13     AIF   ('&VAR(&NV)'(1,1) NE '*').MAC12
.*  LAST ARG USING REG NOTATION - GENERATE EXEC INSTR TO TAG LIST.
           MVI   AA&SYSNDX.+&C3.,X'80' .  *TAG END OF LIST DURING EXEC.
.* PRINT READ MESSAGE DURING EXECUTION.
.MAC14     AIF   (&C4 NE 1).MAC15
*** SET UP MESSAGE TO BE OUTPUT DURING THE READ OPERATION.
           MVI   &MSG.+52,C' ' .               *BLANK OUT THE WORKAREA.
           MVC   &MSG.+53(79),&MSG.+52
           MVC   &MSG.(52),=CL52' **READ IN AFTER STATEMENT        . INX
               FORMATION FOR'
           MVC   &MSG.+52(&CVAR.),BA&SYSNDX. .    *MOVE IN VAR SYMBOLS.
           MVC   &MSG.+105(7),=CL7'FORMAT=' .        *MOVE FORMAT INFO.
           MVC   &MSG.+113(&CFMT.),CA&SYSNDX. .   *MOVE FORMAT SYMBOLS.
.MAC15     ANOP
*** BRANCH TO THE READ ROUTINE TO PERFORM THE READ OPERATION.
           LA    1,AA&SYSNDX. .         *LOAD ADDRESS OF ARGUMENT LIST.
           L     15,=V(REID) .                  *LOAD ADDRESS OF SREID.
           BALR  14,15 .                     *EXECUTE THE READ ROUTINE.
           AIF   ('&LEN'(1,1) EQ '$').MAC16
           ST    0,&LEN .               *RETURN LENGTH OF DATA TO USER.
.MAC16     AIF   (&FLG EQ 2).MAC17
.* RELOAD REGISTERS FROM &SAV (USER SAVEAREA).
           LM    14,1,&SAV      .                *RELOAD I/O REGISTERS.
           AGO   .MAC18
.* RELOAD REGISTERS FROM SAVEAREA DEFINED IN THIS ROUTINE.
.MAC17     LM    14,1,DA&SYSNDX. .               *RELOAD I/O REGISTERS.
           AGO   .MAC18
.* ERROR IN ARGUMENT LIST - DO NOT GENERATE READ ROUTINE CODE.
.ARGERR    MNOTE 2,'ARGUMENT LIST IMPROPERLY FORMED.'
           AGO   .ERR1
.* ERROR IN LIST OF VARIABLES - DO NOT GENERATE READ CODE.
.VARERR    MNOTE 2,'NUMBER OF VARIABLES TO READ EXCEEDS LIMITS.'
.ERR1      ANOP
*** READ STATEMENT WILL BE REPLACED BY A 'NOPR 1' INSTRUCTION
*** DUE TO THE ERROR IN DEFINING MACRO PROTOTYPE.
&J         NOPR  1 .                      *REPLACES THE READ STATEMENT.
.MAC18     ANOP
*XXXXXXXXXXXXXXXXXXXXXXXXXXXX  END REIDC   XXXXXXXXXXXXXXXXXXXXXXXXXXXX
           SPACE 2
           MEND
******************************** REIDC ********************************
         USING *,15
         REIDC *I,(X,Y,Z),LEN=JI,SAV=SAVEAREA,MSG=MESSAGE
JI       DS    F
X        DS    F
Y        DS    F
Z        DS    F
SAVEAREA DC    18F'0'
MESSAGE  DS    33F
         ENTRY REID
REID     DS    F
         END
$JOB   ASSIST       MACRO=F
*        ***NOTE*** ILLUSTRATES ERROR IN HANDKING OF KEYWORD DEFAULTS
*        WHICH ARE ALSO SUBLISTS.
*              EARLY ASSIGNMENT - CMPSC 411 - STUDENT-WRITTEN PROGRAM
*                                  - DAVID COLEMAN - SUMMER 1972.
         TITLE 'MACRO QSAVE'
         MACRO
&NAME    QSAVE &REGS=(14,12),&BASE=12,&SA=*
.*
.**********************************************************************
.*
.*       MACRO QSAVE - CS411 - SUMMER 72.
.*       QSAVE IS A LINKAGE MACRO WRITTEN ACCORDING TO SPECS
.*                                 IN CS411MC1.
.*       &SA IS SPECIFIED AS IN PSU MACRO 'XSAVE'.
.*
.**********************************************************************
.*
         GBLC  &SAVE               &SAVE USED BY QRETURN.
         LCLA  &LENGTH,&DISP,&LENGTH1
         LCLC  &NAME1,&BASER,&A
         SPACE
         USING *,15 .              TEMPORARY BASE REGISTER.
.**********************************************************************
.*
.*       GENERATE IDENTIFICATION FIELD.
.*
.**********************************************************************
&LENGTH  SETA  K'&NAME             OBTAIN COUNT OF NAME FIELD.
&NAME1   SETC  '&NAME'             STORE NAME FIELD.
         AIF   (&LENGTH NE 0).ID   BRANCH IF &NAME EXISTED.
&NAME1   SETC  '&SYSECT'           USE CSECT NAME INSTEAD.
.*       COUNT CHARACTERS IN CSECT NAME.
.TOP     ANOP
&LENGTH  SETA  (&LENGTH+1)         ADD 1 TO COUNT.
         AIF   ('&SYSECT'(1,&LENGTH) EQ '&SYSECT'(1,&LENGTH+1)).ID
         AGO   .TOP                LOOK FOR NEW CHARACTER.
.ID      ANOP
&LENGTH1 SETA  (&LENGTH/2*2+1)     MAKE LENGTH ODD.
&NAME    B     5+&LENGTH1.(,15) .  BRANCH AROUND ID.
         DC    X'&LENGTH1' .       ID CONVENTION.
         DC    CL&LENGTH1'&NAME1'
.**********************************************************************
.*
.*       SAVE PASSED REGISTERS - ONLY ONE PAIR IS ALLOWED.
.*
.**********************************************************************
&DISP    SETA  (&REGS(1)-14)       EXTABLISH DISPLACEMENT OF 1ST REG.
         AIF   (&DISP GE 0).POSITIV
&DISP    SETA  (&DISP+16)          MAKE # POSITIVE.
.POSITIV ANOP
&DISP    SETA  (&DISP*4+12)        THIS IS DISPLACEMENT.
         STM   &REGS(1),&REGS(2),&DISP.(13) . SAVE PASSED REGISTERS.
.**********************************************************************
.*
.*       LINK SAVE AREAS
.*
.**********************************************************************
&SAVE    SETC  '&SA'               TO BE USED BY QRETURN.
         AIF   ('&SAVE' EQ 'NO').BASE   'NO'=NO SA LINKAGE.
         AIF   ('&SAVE' NE '*').LINK    BRANCH IF NAME GIVEN.
&SAVE    SETC  '&SYSECT'(1,3).'&SYSNDX'.'S'    GENERATE SAVE AREA NAME.
.LINK    LA    15,&SAVE     .      GET SAVE AREA ADDRESS.
         ST    15,8(13) .          POINTER TO LOW SAVE AREA.
         ST    13,4(15) .          POINTER TO HIGH SAVE AREA.
         LR    13,15 .             ADDRESS OF LOW SAVE AREA.
.BASE    ANOP
&BASER   SETC  '&BASE'
         AIF   (&BASE LE 12).USING     BRANCH IF B.R. IS LEGAL.
         MNOTE 4,'***WARNING*** REGISTER &BASE CANNOT BE USED AS A BASEX
               REGISTER: REGISTER 12 USED INSTEAD'
&BASER   SETC  '12'
.USING   BALR  &BASER,0 .          SET UP NEW BASE.
         DROP  15                  DELETE TEMPORARY.
         USING *,&BASER .          NEW USING.
         SPACE
         MEND
         TITLE 'MACRO QCALL'
         MACRO
&NAME    QCALL &ENTRY,&ARGS
.*
.**********************************************************************
.*
.*       MACRO QCALL - CS411 - SUMMER 72.
.*       QCALL IS A LINKAGE MACRO WRITTEN ACCORDING TO SPECS IN CS411MA
.*       QCALL IS A LINKAGE MACRO WRITTEN ACCORDING TO SPECS
.*             GIVEN IN CS411MC19
.*             GIVEN IN CS411MC1.
.*
.**********************************************************************
.*
         LCLA  &KOUNT,&TEMPA
         LCLC  &LSTNAME
         SPACE
&NAME    DS    0H .                PROVIDE LABEL IN GENERATED CODE.
.**********************************************************************
.*
.*       DECIPHER ARGUMENT (2ND) OPERAND.
.*
.**********************************************************************
         AIF   (N'&ARGS EQ 0).BRANCH   BRANCH IF 2ND OPERAND MISSINGC
         AIF   ('&ARGS'(1,1) NE '(').ADDNAME   BRANCH IF NOT A SUBLIST.
&LSTNAME SETC  'LIST'.'&SYSNDX'    CREATE UNIQUE ADDRESS LIST NAME.
         AGO   .LR1
.ADDNAME ANOP
&LSTNAME SETC  '&ARGS'             USE ADDRESS LIST NAME FROM MACRO.
.LR1     LA    1,&LSTNAME .        R1==>ADDRESS OF ADDRESS LIST.
.**********************************************************************
.*
.* IS TRANSFER OF CONTROL WANTED.
.*
.**********************************************************************
.BRANCH  AIF   (N'&ENTRY EQ 0).STORE BRANCH IF NO TRANSFER WANTED.
         L     15,=V(&ENTRY) .     SUBROUTINE ADDRESS.
         BALR  14,15 .             CALL ROUTINE.
.**********************************************************************
.*
.*       DECIDE IF ADDRESS MUST BE CREATED.
.*
.**********************************************************************
         AIF   (N'&ARGS EQ 0).END  BRANCH IF NO ARGUMENTS PASSED.
.STORE   AIF   ('&ARGS'(1,1) NE '(').END   BRANCH IF ARGS NOT LISTED.
&TEMPA   SETA  (4*N'&ARGS)         SIZE OF ADDRESS LIST.
         B     &LSTNAME+&TEMPA .   BRANCH AROUND ADDRESS LIST.
&KOUNT   SETA  1                   COUNTER FOR LOOP.
&LSTNAME DS    0F .                TOP OF ADDRESS LIST.
.TOP     AIF   (&KOUNT EQ N'&ARGS).LAST   BRANCH FOR NO MORE ARGS.
         DC    A(&ARGS(&KOUNT)) .  PUT ADDRESS OF ARGUMENT INTO LIST.
&KOUNT   SETA  &KOUNT+1
         AGO   .TOP
.LAST    DC    X'80',AL3(&ARGS(&KOUNT)) .     FLAG LAST ADDRESS.
.END     ANOP
         SPACE
         MEND
         TITLE 'MACRO QRETURN.'
         MACRO
&NAME    QRETURN &REGS=(14,12),&SA=
.*
.**********************************************************************
.*       MACRO QRETURN - CS411 - SUMMER 72.
.*       QRETURN IS A LINKAGE MACRO WRITTEN ACCORDING TO SPECS
.*             GIVEN IN CS411MC1.
.*       SA IS APECIFIED SAME AS IN PSU MACRO 'XRETURN'.
.*
.**********************************************************************
.*
         GBLC  &SAVE               CONTAINS INFO FROM MACRO QSAVE.
         LCLA  &DISP
         SPACE
&NAME    DS    0H .                DEFINE LABEL.
         AIF   ('&SA' EQ 'NO').RGS  BRANCH IF NO SAVE AREA PRESENT.
         L     13,4(13) .          RESTORE PREVIOUS SA POINTER.
.**********************************************************************
.*
.*       RESTORE CALLING PROGRAM'S REGISTERS.
.*
.**********************************************************************
.RGS     ANOP
&DISP    SETA  (&REGS(1)-14)       ESTABLISH DISPLACEMENT IN SAVE AREA.
         AIF   (&DISP GE 0).POSITIV
&DISP    SETA  (&DISP+16)          MAKE # POSITIVE.
.POSITIV ANOP
&DISP    SETA  (&DISP*4+12)        THIS IS DISPLACEMENT.
         LM    &REGS(1),&REGS(2),&DISP.(13) . RESTORE PASSED REGISTER.
         MVI   12(13),X'FF' .      FLAG RET IN HSA.
         BR    14 .                RETURN CONTROL TO CALLING PROGRAM.
.**********************************************************************
.*
.*       DECIDE IF A SAVE AREA IS TO BE GENERATED.
.*
.**********************************************************************
         AIF   ('&SA' EQ 'NO').END     BRANCH FOR NO.
         AIF   (K'&SA EQ 0).END    DEFAULT
         AIF   ('&SA' EQ '*' OR '&SA' EQ '&SAVE').SKIP      NEW LABEL?
&SA      DS    0F .                LABEL FROM QRETURN.
.SKIP    ANOP
&SAVE    DC    18F'0'              DEFINE SAVE AREA.
.END     ANOP
         SPACE
         MEND
         TITLE 'TEST OF LINKAGE MACROS.'
MAINPRG  CSECT
         QSAVE REGS=(14,12)     USE VALUES
         QCALL SUBX,ADDRX
         QCALL SUBY
GOBACK   QRETURN SA=*
ADDRX    QCALL ,(MAINPRG,GOBACK)
         LTORG
SUBXCS   CSECT
         ENTRY SUBX,SUBY
SUBX     QSAVE SA=SUBXSA
         CNOP  2,4                 CNOP FOR NASTINESS
         QCALL SUB1,(SUBX)
         QCALL SUB2
SUBRET   QRETURN SA=SUBXSA
SUBY     QSAVE SA=NO
         XPRNT =CL50'0*** AT SUBY *****',50
         QRETURN  SA=NO
         LTORG
SUB1     CSECT
         QSAVE BASE=13
         QRETURN  SA=*
SUB2     CSECT
         QSAVE BASE=15,REGS=(2,12)
         QRETURN SA=*,REGS=(2,12)
$ENTRY
$JOB   ASSIST       MACRO=F
***********************************************************************
***********************************************************************
**********************************************************************
*                                                                     *
*              FOLLOWING DECKS ILLUSTRATE MACROS FROM ASSEMBLER       *
*        MANUAL OR ELSE VARIOUS CONDTIONAL ASSEMBLY OPERATION.        *
*                                                                     *
**********************************************************************
**********************************************************************
**********************************************************************
         TITLE 'ILLUSTRATE MACROS:  ASSEMBLER MANUAL SECTION 6'
         MACRO
&NAME    MOVE  &TO,&FROM
&NAME    ST    2,SAVE
         L     2,&FROM
         ST    2,&TO
         L     2,SAVE
         MEND
         SPACE 1
         MACRO
&NAME    MOVE1 &TY,&P,&TO,&FROM
&NAME    ST&TY 2,SAVEAREA
         L&TY  2,&P&FROM
         ST&TY 2,&P&TO
         L&TY  2,SAVEAREA
         MEND
         SPACE 1
         MACRO
&NAME    MOVE2 &P,&S,&R1,&R2
&NAME    ST    &R1,&S.(&R2)
         L     &R1,&P.B
         ST    &R1,&P.A
         L     &R1,&S.(&R2)
         MEND
         SPACE 1
         USING *,15
HERE     MOVE  FIELDA,FIELDB
LABEL    MOVE  IN,OUT
SAVE     DS    F
FIELDA   DS    D
FIELDB   DS    D
IN       DS    F
OUT      DS    F
         SPACE 1
         MOVE1 D,FIELD,A,B
SAVEAREA DS    D
         SPACE 2
HERE2    MOVE2 FIELD,SAVE,2,4
         END
$JOB   ASSIST       MACRO=F
         MACRO
         ADDX  &NUMBER,&REG
.*             ILLUSTRATES SETA, SUBLISTS.
         LCLA  &LAST
&LAST    SETA  N'&NUMBER
         L     &REG,&NUMBER(1)
         A     &REG,&NUMBER(&LAST)
         ST    &REG,&NUMBER(1)
         MEND
         SPACE 1
         USING *,15
         ADDX  (A,B,C,D,E),3
A        DS    F
E        DS    F
         END
$JOB   ASSIST       MACRO=F
         MACRO
         ATTRIB    &ARG
.*   THIS MACRO ILLUSTRATES ATTRIBUTES ALLOWED:
.*   T'  (N,O, OR U ONLY);  K'; AND N'
         LCLA  &K,&N
         LCLC      &T
&T       SETC  T'&ARG
&K       SETA  K'&ARG
&N       SETA  N'&ARG
         MNOTE '&&ARG = &ARG: T'' = &T; K'' = &K; N'' = &N.'
         MEND
         SPACE 1
         ATTRIB ,             OMITTED ARGUMENT
         ATTRIB 20            SELF-DEFINING TERM
         ATTRIB X'20'         ANOTHER SELF-DEFINING TERM
         ATTRIB FULLWORD      TYPE IS U, UNLIKE STNDRD ASMS
FULLWORD DS    F
         ATTRIB ()             NULL SUBLIST
         ATTRIB (1,2,3,4,5)
         ATTRIB (FULLWORD,1)   NOTE TYPE ATTRIBUTE
         ATTRIB 2(10,12)
         ATTRIB A(2)
         ATTRIB 'A''B'
         ATTRIB ' '
         ATTRIB ''
         SPACE  1
         ATTRIB (A,B,C,D,E)
         ATTRIB (A,,C,D,E)
         ATTRIB (A,B,C,D)      4 OPERANDS
         ATTRIB (A,B,C,D,,)    6 OPERANDS
         END
$JOB   ASSIST       MACRO=F
         TITLE 'ILLUSTRATE SETX STATEMENTS'
         MACRO
&LABEL   SET   &ARG1,&ARG2,&ARG3
.*             ILLUSTRATE SETX STATEMENTS.
         LCLA  &A1,&A2
         LCLB  &B1,&B2
         LCLC  &C1,&C2
         MNOTE *,'INITIAL VALUES: &A1,&A2; &B1,&B2; &C1,&C2'
         AIF   (T'&ARG1 NE 'N').X1
&A1      SETA  &ARG1(1)            NOTE T' TAKEN FROM 1ST OF SUBLIST
.X1      AIF   (T'&ARG2 NE 'N').X2
&A1      SETA  &A1+&ARG2(1)
.X2      AIF   (T'&ARG3 NE 'N').X3
&A1      SETA  &A1+&ARG3(1)
.X3      MNOTE *,'&&A1 = &&ARG1+&&ARG2+&&ARG3 = &A1.'
.*
&A2      SETA  (K'&ARG1+K'&ARG2+K'&ARG3)*N'&ARG1
         MNOTE *,'&&A2 = &A2'
&C1      SETC  'ABC'.'DEF'
&C2      SETC  '&ARG1&ARG2&ARG3'
         MNOTE *,'&&C1 = &C1;  &&C2 = &C2.'
&C1      SETC  '&C1'(2,4)
&C2      SETC  'ABCDEFGHIJKLMNOPQRSTUVWXYZ'(26,1)
         MNOTE *,'&&C1 = &C1; &&C2 = &C2'
&C1      SETC  'ABCDE'.'&C1'(2,2)
&C2      SETC  'ABCDE&C1'(2,2)
         MNOTE *,'&&C1 = &C1; &&C2 = &C2'
&B1      SETB  ('&ARG1' EQ '&ARG2' AND '&ARG3' EQ '0')
&B2      SETB  (&B1 OR 0)
         MNOTE *,'&&B1 = &B1; &&B2 = &B2'
&B1      SETB  (&A1 EQ &A1)
&B2      SETB  (&A1 GT &A1)
         MNOTE *,'&&B1 = &B1; &&B2 = &B2  (0,1)'
         MEND
         SPACE 2
         SET   1,3,5
         SET   (20,10),(20,10),X
         SET   =F'20',ABCDEFGHIJKLMNOPQRSTUVWXYZ,0
        SET   X'20',C'0',B'00000001'
         END
$JOB   ASSIST       MACRO=F
         TITLE 'ILLUSTRATE ARITHMETIC OPERATIONS IN SETA OPERATIONS'
         MACRO
&LABEL   SETAX &A
.*             ILLUSTRATES ARITHMETIC OPERATIONS
.*             IN SETA OPERATIONS.
         GBLA  &W,&X,&Y,&Z
         LCLA  &I,&J,&K,&L
         MNOTE *,'INITIAL VALUES: W=&W; X=&X; Y=&Y; Z=&Z'
&W       SETA  &A+&W
&I       SETA  &I+1
         MNOTE *,'W=A+W = &W;  I = I+1 = &I'
.*             SUBTRACTION
&X       SETA  &X-&A
&J       SETA  &J-1
         MNOTE *,'X=X-A = &X;  J=J-1 = &J'
.*             MULTIPLICATION
&Y       SETA  (&Y+1)*&A
&K       SETA  2*(&K+1)
         MNOTE *,'Y=(Y+1)*A = &Y;  K=2*(K+1) = &K'
.*             DIVISION
&Z       SETA  (&Z+20)/&A
&L       SETA  10/(&L+2)          SHOULD = 5
         MNOTE *,'Z=(Z+20)/A = &Z;  L = 10/(L+2) = &L'
.*             PARENTHESES.
&I       SETA  (((((0)))))
&J       SETA  1+2*3                  =7
&K       SETA  (1+2)*3            =9
&L       SETA  (((&J+&K)/4+1)+0*&L)+10    = 5+10 = 15
         MNOTE *,'I,J,K,L = &I,&J,&K,&L'
         MNOTE *,'END VALUES: W,X,Y,Z: &W,&X,&Y,&Z'
         MEND
         SPACE 2
         SETAX 10
         SETAX X'A'
         SETAX B'00001010'
         END
$JOB   ASSIST       MACRO=F
         TITLE 'TEST SETB INSTRUCTION'
         MACRO
         SETBX &A,&B,&C
         GBLB  &W,&X,&Y,&Z
         LCLB  &D,&E,&F,&TRUE,&FALSE
         LCLA  &I,&J
         LCLC  &Q,&R
.*
         MNOTE *,'INITIAL VALUES: W,X,Y,Z = &W,&X,&Y,&Z'
&FALSE   SETB  0                   FALSE VALUE
&TRUE    SETB  1                   TRUE VALUE
&W       SETB  (NOT &W)           INVERSION
&X       SETB  (&W AND &TRUE)
&Y       SETB  (&W OR  &FALSE)
&Z       SETB  (
1M 7150
&Z       SETB  (&TRUE  OR &TRUE AND NOT &TRUE)   SHOULD BE 0
         MNOTE *,'W,X,Y,Z = &W,&X,&Y,&Z'
.*             COMPARISONS, CHARACTER OPERATIONS
&D       SETB  ('&Q' EQ '&R')      COMPARE NULL STRINGS
&Q       SETC  'ABCDEFGH'
&E       SETB  ('&Q' EQ 'ABCDEFGH')    TRUE
&R       SETC  '&Q'
&F       SETB  ('&Q'(1,3) EQ '&R'(1,3))
         MNOTE *,'D,E,F = &D,&E,&F  (1,1,1)'
&D       SETB  ('&Q'(2,5) GT '&Q'(1,4))    FALSE
&E SETB (&I+1 EQ &J+1)              TRUE
&F SETB (&I+1 GT &J)                TRUE
 MNOTE *,'D,E,D = &D,&E,&F (0,1,1)
 MEND
 SPACE 1
 SETBX 1
 END
$JOB   ASSIST       MACRO=F
         TITLE 'DEMONSTRATE SETC'
         MACRO
&LABEL   SETCX &A,&B,&C
         GBLC  &W,&X,&Y
         LCLC  &D,&E,&F
         LCLA  &I,&J
         MNOTE *,'INITIAL VALUES: W/X/Y: &W/&X/&Y'
.*             TRANSFER, CONCATENATION.
&D       SETC  '&A'               TRANSFER
&E       SETC  '&A&B'             CONCAT, NO PERIODS
&F       SETC  '&A.&B'            CONCAT, WITH PERIOD'
         MNOTE *,'D/E/F = &D/&E/&F'
&W       SETC  '&A'.'&W'          CONCAT, QUOTES EACH
&X       SETC  '&A&X'
&Y       SETC  '&A&A&A&A&A&A&A&A&A&A'  LONGGER THAN 8 BYTES
         MNOTE *,'W/X/Y = &W/&X/&Y'
.*             SUBSTRING OPERATIONS
&D       SETC  '123456789'(8,2)         89
&I       SETA  &C                       89 ALSO
&D       SETC  '123456789'(97-&I,2+1*&I-&I)  89 ALSO
&E       SETC  '123456789'(9,2)         JUST 9
         MNOTE *,'C/I/D/E = &C/&I/&D/&E  (89/89/89/9)'
         MEND
         SPACE 1
         SETCX A,B,C
         SETCX D,E,F
         SETCX (1,2,3,4,5,6,7,8,9),,ABCDEF
         END
$JOB   ASSIST       MACRO=F
         TITLE 'AIF, AGO, ACTR'
         MACRO
         ATRAN &I
         LCLA  &J,&K
         ACTR  &I                  LIMIT ON #
         AGO   .X    DEFINITE
         MNOTE *,'SHOULD NOT BE PRINTED'
.X       AIF   (&I NE &I).Y            DEFINITELY NOT
         MNOTE *,'THIS MUST BE PRINTED'
.Y       AIF   (&I EQ &I).Z            DEFINITE GO
         MNOTE *,'MUST NOT BE PRINTED'
.Z       ANOP
         MNOTE *,'AT THIS PT, THERE HAVE BEEN 2 SUCCESSFUL AGO/AIF'
.LOOP     ANOP
&J       SETA  &J+1
         MNOTE *,'J = &J'
         AGO   .LOOP               LOOP UNTIL ACTR GETS IT
         MEND
         ATRAN 8
         END
$JOB   ASSIST       MACRO=F
***********************************************************************
***********************************************************************
**********************************************************************
*                                                                     *
*              IN NEXT GROUP OF JOBS, ERRORS, WEIRD STATEMENTS,       *
*              ETC ARE SHOWN.                                         *
*                                                                     *
***********************************************************************
**********************************************************************
**********************************************************************
         TITLE 'ZERO DIVIDE, OVERFLOW TEST - DURING EXPANSION'
         MACRO
         TESTZDIV
.*  TESTS ZERO DIVIDE AND FIXED POINT OVERFLOW ERROR CONDITIONS
         LCLA  &I,&J
&I       SETA  2147483647
         MNOTE *,' FOLLOWING MESSAGE OCCURS WHEN ZERO DIVIDE OCCURS'
&J       SETA  &I/&J
         MNOTE *,'FOLLOWING MESSAGE OCCURS WHEN FXD PNT OVRFLW OCCURS'
&J       SETA  &I+1
         MEND
         SPACE 1
         TESTZDIV
         END
$JOB   ASSIST       MACRO=F
         TITLE 'SHOW COMBINED EDIT / EXPANSION ERRORS'
         MACRO
         TESTSUBS &A
.*  TESTS VARIOUS SUBSCRIPT ERROR CONDITIONS
         LCLA  &ARRAY(10)
         LCLC  &C
.*  FOLLOWING MESSAGE OCCURS WHEN DIMENSION EXCEEDS LIMIT OF 2500
         LCLA &EXCEED(2501)
.*  FOLLOWING MESSAGE OCCURS WHEN DUPLICATE VARIABLE SYMBOL NAME IS
.*  USED
         LCLB  &ARRAY
.*  FOLLOWING MESSAGE OCCURS WHEN SUBSCRIPT OMITTED FROM DIMENSIONED
.*  VARIABLE
&ARRAY   SETA  13
         MNOTE *,'FOLLOWING MESSAGE OCCURS WHEN INDEX VALUE EXCEEDS ARR#
               AY SIZE'
&ARRAY(20)  SETA  20
          MNOTE *,'FOLLOWING MESSAGE OCCURS WHEN SUBSCRIPT VALUE IS NON#
               ARITHMETIC'
&ARRAY(&A)  SETA  100
.*  FOLLOWING MESSAGE OCCURS WHEN ILLEGAL SUBSCRIP  IS USED IN
.*  DIMENSIONED VARIABLE
&ARRAY(3)   SETA  &ARRAY(/E)
.*   FOLLOWING MESSAGES OCCUR WHEN WRONG NUMBER OF SUBSCRIPTS USED
&C       SETC  '&A'(3)
&C       SETC  '&A(2,2)'
         MEND
         SPACE 1
         TESTSUBS  NONDECIMALSTRING
         END
$JOB   ASSIST       MACTR=10,MNEST=5,MACRO=F
         TITLE 'ILLUSTRATE MACTR,MNEST OPTIONS'
         MACRO
         TESTXCED
.*  THIS MACRO TESTS EXCESSIVE NESTED MACRO CALLS
         GBLB  &FLAG
         AIF   (&FLAG).SKIP
&FLAG    SETB  (1)
         MNOTE *,'FOLLOWING MESSAGE OCCURS WHEN NUMBER OF NESTED MACRO #
               CALLS EXCEEDS MSTMG'
.SKIP    ANOP
         TESTXCED
         MNOTE *,'NEVER PRINT - WHOLE NEST CANCELED'
         MEND
         SPACE 1
         MACRO
         LOOPER
         LCLA  &I
.LOOP    ANOP
&I       SETA  &I+1                INCREMENT NOW
         MNOTE *,'&&I = &I'
         AGO   .LOOP               LOOP UNTIL ACTR GETS US
         MEND
         SPACE 1
         TESTXCED
         SPACE 1
         LOOPER
         END
$JOB   ASSIST       MACRO=F,MSTMG=20
         TITLE 'ILLUSTRATE MSTMG OPTION'
         MACRO
         GEN6
         MNOTE *,'1'
         MNOTE *,'2'
         MNOTE *,'3'
         MNOTE *,'4'
         MNOTE *,'5'
         MNOTE *,'6'
         MEND
         GEN6
         GEN6
         GEN6
         GEN6
         GEN6
         END
$JOB   ASSIST       MACRO=F
         MACRO
         TESTCHAR &A
         LCLA     &I
         LCLB     &B
         LCLC     &C
.*   FOLLOWING MESSAGE OCCURS WHEN CHAR EXPRESSION DOES NOT START
.*   WITH QUOTE
&C       SETC  ABCDE
.*   FOLLOWING MESSAGE OCCURS WHEN CHAR EXPRESSION DOES NOT END
.*   WITH QUOTE
&C       SETC  'ABCDE
.*   FOLLOWING MESSSAGE OCCURS WHEN TYPES ARE MIXED IN SET STMT
&C       SETA   12
.*   FOLLOWING MESSAGES OCCUR WHEN OPERAND NOT COMPATIBLE WITH
.*   OPERATOR
&B       SETB  (NOT &C)
&B       SETB  (&B AND &I*&A)
         MEND
         END
$JOB   ASSIST       MACRO=F
         MACRO
         TESTDNAM
         MEND
         SPACE 1
         MACRO
         TESTDNAM
.*   ABOVE MESSAGE OCCURS WHEN DUPLICATE NAME IS USED IN
.*   MACRO PROTOTYPE STMT.  DUMMY NAME SUBBED AND ASSEMBLY CONTINUES
         MEND
         SPACE 1
         MACRO
         AB*X
.*   ABOVE MESSAGE OCCURS WHEN ILLEGAL SYMBOL IS USED FOR MACRO
.*   NAME.  DUMMY NAME IS SUBBED AND ASSEMBLY CONTINUES.
         MEND
         SPACE 1
         MACRO
         TESTOPR1  &A=3427,&B
.*   ABOVE MESSAGE OCCU9S WHEN POSITIONAL OPRND FOLLOWS KEYWORD
         MEND
         SPACE 1
         MACRO
         TESTOPR2   &A=Z=347
.*   ABOVE MESSAGE OCCURS WHEN OPERAND VALUE IN PROTOTYPE STMT OR
.*   MACRO CALL DOES NOT CONFORM TO IBM GC28-6514 SECTION 8.
         MEND
         SPACE 1
         MACRO
&LABEL   TESTLABL
         MNOTE *,'ABOVE MESSAGE OCCURS WHEN OPERAND VALUE ASSIGNED TO  #
               LABEL FIELD SYMBOLIC PARAMETER IS NOT ORDINARY SYMBOL'
         MEND
         SPACE 1
(234)    TESTLABL
         END
$JOB   ASSIST       MACRO=F
         MACRO
         TESTSEQ
.*   FOLLOWING MESSAGE OCCURS WHEN ILLEGAL SEQUENCE SYMBOL IS USED
         AGO  LOOP1
         AGO  .LOOP1
         AGO   .LOOP1              UNDEFINED
         AGO   .OOP2               ALSO UNDEFINED
.*   FOLLOWING MESSAGE OCCURS WHEN SEQUENCE SYMBOL IS UNDEFINED
         MEND
         END
$JOB   ASSIST       MACRO=F
         MACRO
         TESTXPND  &A
         LCLA    &I
         LCLB    &B
         LCLC    &C
.*   FOLLOWING MESSAGE OCCURS WHEN SET SYMBOL DEFINITIONS OCCUR
.*   OUT OF ORDER
         GBLA    &Z
         MNOTE *,'FOLLOWING MESSAGE OCCURS WHEN ILLEGAL CONVERSION -   #
                CHAR TO BINARY - IS ATTEMPTED.'
&C       SETC  'ABCD'
&I       SETA  &C
         MNOTE *,'FOLLOWING MESSAGE OCCURS WHEN ILLEGAL CONVERSION -   #
                CHAR TO BOOLEAN - IS ATTEMPTED'
&B       SETB  (&A)
         MNOTE *,'FOLLOWING MESSAGE OCCURS WHEN ILLEGAL CONVERSION -   #
                BINARY TO BOOLEAN - IS  ATTEMPTED.'
&I       SETA  100
&B       SETB  (&I)
         MNOTE *,'FOLLOWING MESSAGE OCCURS WHEN ILLEGAL ATTRIBUTE USE  #
                IS ATTEMPTED.'
&B       SETB  (T'&A)
         MEND
         SPACE 1
         TESTXPND  WXYZ
         END
$JOB   ASSIST       MACRO=F
         MACRO
         TESTCONT  &A=1234,&B=2345,                                    #
               &C=5000,&D=6000,                                        #
               &E=7000,&F=8000,                                        #
               &G=9000,&H=9000,                                        #
               &I=12000,                                               #
               &J=13000,                                               #
               &K=14000,                                               #
               &L=15000       AN INDEFINITE NBR OF CONT CARDS ARE OKAY
         MNOTE *,' PARAM VALUES ARE &A, &B, &C, &D, &E, &F, &G, &H, &I,#
                &J, &K AND &L'
         MEND
         SPACE 1
         TESTCONT  A=12,B=30,C=20,                                     #
               D=45,F=34,                                              #
               E=6,                                                    #
               G=78,H=90,                                              #
               I=99,                                                   #
               J=17,                                                   #
               K=74,                                                   #
               L=43
        END
$JOB   ASSIST       MACRO=F
         MACRO
         TSTCONT1  &A=(AAAAAAAAAAAAAAAAAAA,BBBBBBBBBBBBBB,CCCCCCCCCCCCC#
               CCC,DDDDDDDDDDDDDDDDDD,EEEEEEEEEEEEE,FFFFFFFFFFFFF,GGGGG#
               GGGGGGGGG,HHHHHHHHHHH,IIIIIIIIIIIIIIIIII,JJJJJJJJJJJJJJJ#
               JJJJJ,KKKKKKKKKKK)
.*   ABOVE ERROR MESSAGE ILLUSTRATES RESTRICTION ON ASSIST CONTINUATION
.*   CARDS, I.E. THE 3RD, 6TH, 9TH ETC CONTINUATION CARDS CANNOT END IN
.*   THE MIDDLE OF AN OPERAND, THEY MUST BE OF THE NON-STANDARD CONTIN-
.*   UATION FORMAT
         MEND
         MACRO
         TSTCONT2  &A=(AAAAAAAAAAA,BBBBBBBBB,CCCCCCCCCC,DDDDDDDDDD,UVVV#
               VVVVVVVVV,WWWWWWWWWWW,XXXXXXXXXXXXXXXXX,YYYYYYYYYYYYY,ZZ#
               ZZZZZZZZZZZZZZ),&B=ABCDEFGHIJKLIMONPQRSTUVWXYZ,         #
               &C=(111111111,222222222,333333333,444444444,555555555,66#
               6666666,777777777,888888888,999999999,123456789,23456789#
               0,345678901,456789012)
.*   ABOVE EXAMPLE ILLUSTRATES HOW EVERY 3RD CARD SHOULD END ON WITH
.*   NON-STANDARD FORMAT.  REGULAR CONTINUATION CAN THEN PICK UP AGAIN
.*   FOR SUCCEEDING TWO CARDS
.*   THE SAME RESTRICTION APPLIES TO A MACRO CALL AS TO THE PROTOTYPE
.*   STATEMENT
         MEND
 TSTCONT2 A=1,B=2,C=3
 TSTCONT1 A=1
 END
$JOB   ASSIST       MACRO=F
         TITLE 'TEST FOR NASTY COMMENTS, CONTINUATIONS'
         MACRO
         TESTCMMT  &A=20,&B=30,                                        #
               &C=40,                                                  #
               &D=50,&E=60
          LCLA  &I
          MNOTE *,' SYM PARAMS ARE &A, &B, &C, &D AND &E.'
           MEND
         MACRO
         TESTCMMU &A=,                  PARAMATER A                    #
               &B=10,&C=20              PARMS B,C
         DC    C' &&A = &A,  &&B = &B, &&C = &C . XXXXXXXXXXXX XXXXXXXX#
               XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXABCDEFGHIJKL#
               MNOPQRSTUVWXYZ'
         MNOTE *,'*****************************************************#
               &A,&B,&C ***********************************************#
               X '
         TESTCMMT B=10,C=105,           THIS IS A COMMENT ON INNER MAC #
               A=&A
          MEND
         SPACE 2
          TESTCMMT   A=100,B=200,                                      #
               C=300,D=400,                                            #
               E=500
         TESTCMMU A=X,B=Y,              ANOTHER COMMENT                #
                  C=500                 COMMENT
                                               TESTCMMT        A=101,B=#
               102,C=103
         TESTCMMT A=101,                                               #
               C=102,                                                  #
               B=103
         TESTCMMU A=1000,S=2000,C=3000       COMMENTS
         END
$JOB   ASSIST       MACRO=F
**********************************************************************
**********************************************************************
**********************************************************************
**********************************************************************
**********************************************************************
**********************************************************************
**********************************************************************
**********************************************************************
**********************************************************************
*                                                                     *
*              WARNING:   FOLLOWING JOBS REQUIRE THE MACRO LIBRARY    *
*              PROCESSOR, AND SOME MAY REQUIRE CERTAIN MACROS TO BE   *
*              AVAILABEL  (SUCH AS XSAVE, XRETURN, ETC).              *
*                                                                     *
*              JOBS USING IBM MACROS MAY REQUIRE EXORBITANT AMOUNTS   *
*              OF MEMORY, DUE ESPECIALLY TO IHBERMAC, ETC.            *
*              HOWEVER, THEY DO ASSEMBLE IN 280 K REGION OR LESS      *
*              AND WE HAVE ACTUALLY RUN THEM.                         *
**********************************************************************
***********************************************************************
***********************************************************************
**********************************************************************
**********************************************************************
**********************************************************************
         TITLE 'ILLUSTRATE XSAVE,XRETURN'
         MACRO
         GETMAIN
.*             FAKE GETAMIN, SINCE WHILE XSAVE CALLS IT, IT IS NOT    *
.*       GOING TO USE IT.  IF GETMAIN COMES IN, SO WILL IHBERMAC.     *
         MEND
         MACRO
         FREEMAIN
.*       FAKE FREEMAIN, FOR XRETURN, SAME AS GETMAIN.
         MEND
         SPACE 1
         MACRO
&LABEL   XCALL &ENTRY,&ADLIST
.*             SIMPLE CALL, GET AROUND REGUALR CALL
&LABEL   DS    0H                  DEFINE LABEL
         AIF   ('&ADLIST' EQ '').X
         L     15,=V(&ENTRY)
         LA    1,=A&ADLIST         REQUIRES WHOLE LIST
.X       BALR  14,15               CALL ROUTINE
         MEND
*SYSLIB  XSAVE,XRETURN             MENTION, SINCE NOT BEFORE
         SPACE 2
MAIN     CSECT
         XSAVE
         XCALL SUB1,(MAIN1,MAIN2)
         XRETURN SA=*
MAIN1    DS    F
MAIN2    DS    F
         LTORG
SUB1     CSECT
         XSAVE TR=NO,BR=13
SUB1RET  XRETURN
         END
$ENTRY                             EXECUTE THE PROGRAM
$JOB   ASSIST       MACRO=F
         TITLE 'QSAM I/O MACROS'
*              THIS PROGRAM GOBBLES CORE.
         MACRO
&LABEL    IHBERMAC &A,&B,&C,&D,&E,&F,&G
.*        STUPID FAKE IHBERMAC
         MNOTE *,'IHBERMAC: &A,&B,&C,&D,&E,&F,&G'
         MEND
*              NOTE:  MACROS CALLED FOR SPEARATELY, SO CAN SEE HOW
*              LONG THEY ARE WITHOUT LISTING THEM.
*SYSLIB OPEN
*SYSLIB  CLOSE
*SYSLIB GET
*SYSLIB  PUT
*SYSLIB DCB
         USING *,15
         OPEN  (XDCB,INPUT)
         OPEN  (YDCB,OUTPUT)
         GET   XDCB
         PUT   YDCB,(0)            OUTPUT
         CLOSE (XDCB,,YDCB)
XDCB     DCB   DDNAME=X,MACRF=GL,EODAD=XDCB,LRECL=80,DSORG=PS
YDCB     DCB   DDNAME=Y,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FA,BUFNO=4
         END
$JOB   ASSIST       MACRO=F
*
*        THESE PROGRAMS TEST THE ERROR DETECTIO CODE AS WELL AS
*        THE NORMAL RETRIEVAL LOGIC INCORPORATED INTO MOCOMSYS
*        THESE ROUTINES ALSO TEST THE XXIOCO RETRIEVAL LOGIC
*
*
*        INNER MACRO CALL NOT ON THE SYSLIB CARD
*
*
         MACRO
         MCALL &RTNE
         CALL  &RTNE
         MEND
         SPACE 5
*        NEXT STMT PULLS IN: CALL,SAVE,RETURN,IHBERMAC, ETC.
*SYSLIB  SAVE,RETURN
         EJECT
TEST1    CSECT
         USING TEST1,15
         SAVE  (14,12)
         ST    13,TEST1SV+12
         LA    13,TEST1SV
         MCALL SUB1
         L     13,TEST1SV+12
         RETURN (14,12)
TEST1SV  DS    18F
         LTORG
         DROP  15
SUB1     CSECT
         USING SUB1,15
         SAVE  (14,12)
         ST    13,SUB1SV+12
         LA    13,SUB1SV
*              NEXT STMT MUST BE FLAGGED, DID NOT MENTION XSNAP.
         XSNAP LABEL='SUB1 ENTERED'
         L     13,SUB1SV+12
         RETURN (14,12)
SUB1SV   DS    18F
         DROP  15
         END
$JOB   ASSIST       MACRO=F
*        THIS PROGRAM IS COMPLETELY UNEXECUTABLE
*        IT TEST THE LIBRARY SEARCH FACILITY AND THE
*        MACRO DEFINITION AND EXPANSION PHASES OF THE ASSIST
*        ASSEMBLER SYSTEM
*
*
*        MACROS USED FOR THE TEST:
         EJECT
*SYSLIB  ATTACH                    USES ENTRY1 AND DCBDUMMY
         EJECT
*SYSLIB  CHAP                      USES NO LOCAL ADDRESS
         EJECT
*SYSLIB  CHKPT                     USES NO LOCAL ADDRESS
         EJECT
*SYSLIB  DELETE                    USES ENTRY1
         EJECT
*SYSLIB  9XR                       TESTS MOCOMSYS SCAN LOGIC
*                                  FOR ILLEGAL FIRST CHARACTER
         EJECT
*SYSLIB  DXR                       USES NO LOCAL ADDRESSES
*SYSLIB  EXTRACT                   USES A 7-WORD, ALINED AREA, ANSER
*SYSLIB  GTRACE                    USES GDATA ADDRESS
*SYSLIB  LINK                      USES ENTRY1
*SYSLIB  SEGLD                     USES EXTERN
*SYSLIB  SPIE                      USES INTERADD
*SYSLIB  STATUS                    USES TCBDUM
*SYSLIB  STATUE                    TEST MOCOMSYS NO FIND ERROR
*SYSLIB  XCTL                      USES ENTRY1 AND DCBDUMMY
*SYSLIB  DETACH                    USES TCBDUM
*
*
*        NEXT TEST THE ACTION OF A BLANK SYSLIB CARD
*
         MACRO
         MCALL &RTNE
         CALL  &RTNE
         MEND
*SYSLIB
*SYSLIB  SAVE.RETURN               BAD DELIMITER
*SYSLIB  SAVE,RETURN               FOR LINKAGE AND ADDRESSABILITY
*
WIERD    CSECT
         USING TEST,15             SET UP ADDRESSABILITY
         SAVE (14,12)
*        BEGIN TEST OF MACRO EXPANSION CODE
         MCALL SUB1
         ATTACH    EP=ENTRY1,DCB=DCBDUMMY,HIARCHY,1,SZERO=YES
         ATTACH    EP=ENTRY1,DCB=DCBDUMMY,HIARCHY=1,SZERO=YES
         CHAP  -1,'S'
         CHKPT CANCEL,(3),'S'
         DELETE EP=ENTRY1
         DETACH TCBDUM,STAE=YES
         DXR   0,4
         EXTRACT                   ANSER,'S',FIELDS=ALL
         GTRACE DATA=GDATA,LNG=4,ID=7,FID=0
         LINK  EP=ENTRY1,EPLOC=(5),ID=57,HIARCHY=0
         SEGLD EXTERN
         SPIE  INTERSDD,((1,14))
         SPIE  INTERADD,((1,14))
         STATUS STOP,TCB=TCBDUM
         XCTL  (2,12),EP=ENTRY1,DCB=DCBDUMMY,HIARCHY=1
*SYSLIB  DCB                       GET THE DCB MACRO
         RETURN (14,12)
         DS    0F
DCBDUMMY DS    F
ENTRY1   DS    F
TCBDUM   DS    F
ANSER    DS    7F
EXTERN   DS    F
INTERADD DS    F
*
*        END
*        END OF WIERD MACRO TEST PROGRAM
*
SUB1     CSECT
         USING SUB1,14
         SAVE  (14,12)
*SYSLIB  CHAP                      MORE WIERD TESTING
         RETURN
         END   WIERD
$JOB
*        THE FOLLOEING CODE MULTIPLIES TWO SPARSE MATRICES WHICH ARE
*        LOADED INTO STORAGE AS ORTHAGONAL ARRAYS.  IF A MATRIX ELEMENT
*        IS ZERO, IT IS NOT KEPT AND ITS ABSENCE INDICATES A VALUE
*        OF ZERO FOR THAT NODE.
*              MATRIX NODES HAVE THE FOLLOWING FORM:
*                                 WORD 1-->THE MATRIX VALUE
*                                 WORD 2-->THE ROW LINK
*                                 WORD 3-->THE COLUMN LINK
*                                 WORD 4-->SUBSCRIPT VALUES OF THE NODE
*              THE ROW HEADERS LOOK LIKE:
*                                 WORD 1-->THE HEADER FLAG
*                                 WORD 2-->THE LINK(TO THE LAST NODE
*                                 IN THE ROW).
*                                 WORD 3-->ROW SUBSCRIPT
*                                 WORD 4-->UNUSED
*              THE COLUMN HEADERS LOOK LIKE:
*                                 WORD 1-->HEADER FLAG
*                                 WORD 2-->THE LINK(AS ABOVE)
*                                 WORD 3-->COLUMN SUBSCRIPT
*                                 WORD 4-->UNUSED
*              THE OUTPUT STACK HEADERS LOOK LIKE:
*                                 WORD 1-->UNUSED
*                                 WORD 2-->HEADER FLAG
*                                 WORD 3-->SUBSCRIPT VALUES
*                                 WORD 4-->THE RIGHT LINK
*              THE OUTPUT STACK NODES LOOK LIKE:
*                                 WORD 1-->LEFT LINK
*                                 WORD 2-->PARTIAL VALUE
*                                 WORD 3-->SUBSCRIPT VALUES
*                                 WORD 4-->THE RIGHT LINK
*        AS THE MULTIPLY PORTION OF THE PROGRAM DEVELOPES A PARTIAL
*        PRODUCT OF THE PRODUCT MATRIX, IT IS PUSHED ONTO THE FRONT
*        OF A STACK.  THE STACK IS A RIGHT CIRCULAR, DOUBLY LINKED
*        LIST.  SINCE THE MULTIPLY ALGORITHM DEVELOPS THE PRODUCT
*        MATRIX FROM LAST ELEMENT TO FIRST, LOADING THE STACK FROM THE
*        FRONT DEVELOPES THE PRODUCT MATRIX IN STORAGE IN THE PROPER
*        ORDER.
*              DATA TO THE PROGRAM:
*        1.    'M' IN COL. 1 OF A CARD(OMIT FOR FIRST MATRIX PAIR)
*        2.    MATRIX DIMENSIONS(INTEGER NUMBERS 0<I>51, SEPARATED BY
*              AT LEAST ONE BLANK)
*        3.    ROW 1 OF MATRIX 'A', EACH VALUE SEPARATED BY A BLANK
*              LAST VALUE FOLLOWED BY: A BLANK, AND THE CHARACTER 'E'
*        4.    ROW 2 AS ABOVE, ETC.
*        5.    '*' IN COL. 1 TO DELIMIT MATRICES
*        6.    VALUES OF MATRIX 'B' AS ABOVE
*        7.    SAME AS 1 ABOVE TO DELIMIT MATRICES
*
*
*
*
*
MAIN     CSECT
         BALR  12,0
         USING *,12
         ST    14,SAV14
*
*
*              GENERATE A LIST OF  AVAILABLE SPACE LINKED THRU AVAIL
*
*
BEGIN    XPRNT =CL5'1',5
         XPRNT =CL22'0MATRIX DIMENSIONS ARE',22
         LA    4,500              LOOP CONTROL FOR INITIAL LINKAGE
         LA    2,WORKAREA         R2<--ADDRESS OF WORKING AREA
         ST    2,AVAIL            STORE START OF AVAILABLE NODES
         LR    3,2                COPY FOR CORRECT LINKAGE
START    LA    3,16(3)            INCREMENT TO NEXT NODE FOR LINK
         ST    3,4(2)             LINK WITH PREVIOUS NODE
         LA    2,16(2)            ACCESS NEXT NODE FOR LINKUP
         BCT   4,START            LOOP
         MVC   0(4,2),=X'00000000'       GROUND LAST NODE
*
*
*              INPUT, CONVERT, AND SAVE EACH MATRIX PARAMETER CARD
*              CHECK FOR MATRIX COMPATIBILITY
*              ECHO PRINT EACH PARAMETER CARD
*
*
         XREAD CARD,80            READ MATRIX PARAMETER CARD
         XPRNT CARD-1,50          ECHO PRINT INPUT
         XPRNT =CL50'0ECHO CHECK ON INPUT MATRICES',50
         BM    STOP               ON LAST CARD OF DECK END EXECUTION
         XDECI 2,CARD             COVERT ROW PARAM. MATRIX A
         XDECI 3,0(1)             CONVERT COL. PARAM MATRIX A
         XDECI 4,0(1)             CONVERT ROW PARAM. MATRIX B
         XDECI 5,0(1)             CONVERT COL. PARAM. MATRIX B
         STM   2,5,ROWA           STORE FOR LATER USE
         ST    4,ROWBI            STORE ROWB FOR LATER USE
         CR    3,4                ARE MATRICES COMPATIBLE
         BE    SKIP               YES-- SKIP ERROR OUTPUT
         XPRNT =CL100'***ERROR*** MARICES ARE NOT COMPATIBLE; AND CANNOT
               T BE MULTIPLIED',100
         XPRNT =CL50'   MATRIX DIMENSIONS ARE:',50
         XDECO 2,EMESS+26         CONVERT MATRIX DIMENSIONS FOR OUTPUT
         XDECO 3,EMESS+43
         XDECO 4,EMESS+77
         XDECO 5,EMESS+94
         XPRNT EMESS,106          PRINT MATRIX  DIMENSIONS
DUMP     XREAD CARD,1             LOOK FOR MATRIX DELIMITER
         CLI   CARD,C'M'
         BE    BEGIN
         B     DUMP
*
*
*              DEVELOPE TABLES OF ARRAY HEADER ADDRESSES
*                  TABRA-->ROW HEADER TABLE MATRIX 'A'
*                  TABCA-->COLUMN HEADER TABLE MATRIX 'A'
*                  TABRB-->ROW HEADERS OF MATRIX 'B'
*                  TABCB-->COLUMN HEADERS TABLE OF MATRIX 'B'
*
*
SKIP     L     3,AVAIL            SET AVAIL TO FIRST NODE
         LA    10,ROWA            ADDRESS OF IMAX,JMAX,KMAX,LMAX
         LA    11,TABRA           ADDRESS OF HEADER TABLES
         LA    4,4                OUTER LOOP CONTROL
OUTER    LR    9,11               NEW REG. TO INDEX INTO EACH TABLE
         SR    1,1                COUNTER FOR EACH INDEX
         L     2,0(10)            SUCCESIVE DIMENSIONS IN R2
INNER    LA    1,1(1)             INCREMENT INDEX
         L     3,AVAIL            P<--AVAIL
         CLC   4(3),=F'0'         LOOK FOR LAST NODE
         BE    OVFLOW             IF FOUND OVERFLOW HAS OCCURRED
         MVC   AVAIL(4),4(3)      OTHERWISE; AVAIL<--LINK(AVAIL)
         ST    3,0(9)             HEADER ADDRESS IN HEADER TABLE
         ST    1,8(3)             INDEX VALUE IN HEADER
         MVC   0(4,3),=C'HEAD'    VALUE(HEADER)<--HEADER FLAG
         ST    3,4(3)             LINK HEADER TO ITSELF(EMPTY LIST)
         LA    9,4(9)             NEXT CELL OF HEADER TABLE
         BCT   2,INNER            LOOP TO INNER LOOP
         LA    10,4(10)           GET NEXT DIMENSION
         LA    11,200(11)         GET NEXT HEADER TABLE
         BCT   4,OUTER            LOOP TO OUTER ATEP
*
*
*              DEVELOPE A TABLE OF OUTPUT STACK HEADER ADDRESSES
*                  TABSTK--> STACK HEADER TABLE
*
*
         LA    5,TABSTK           REFERENCE STACK HEADER TABLE
         LA    1,0                ZERO R1 FOR ROW INDEX
         L     2,ROWA             NUMBER OF STACKS=ROWA
STACK    LA    1,1(1)             INCREMENT INDEX COUNTER
         L     3,AVAIL            P<--AVAIL
         CLC   4(3),=F'0'         IS IT LAST NODE?
         BE    OVFLOW             YES--OVERFLOW
         MVC   AVAIL(4),4(3)      N/-- AVAIL<--LINK(AVAIL)
         ST    3,0(5)             PUT HEADER ADDRESS IN TABLR
         STH   1,8(3)             PUT ROW INDEX IN HEADER
         MVC   4(4,3),=C'HEAD'    PUT HEADER FLAG IN HEADER
         ST    3,12(3)            LINK HEADER TO ITSELF FOR EMPTY LIST
         LA    5,4(5)             GET NEXT PLACE IN TABLE
         BCT   2,STACK            CONTINUE UNTILL ROWA=0
*
*
*              INPUT, CONVERT, AND STORE THE MATRIX ELEMENTS INTO
*              THE ORTHAGONAL ARRAY
*              IF AN ELEMENT EQUALS ZERO NO SPACE IS SAVED FOR THAT
*              ELEMENT
*
*
         LA    5,TABRA            INITIALIZE FOR ARRAY LOADING
         LR    6,5                OPERATIONS ON MATRIX 'A'
         LA    8,TABCA
         LR    9,8
NEWMTRX  L     10,0(9)            COL. HEADER ADDRESS IN R10
STRTNWR  L     7,0(6)             ROW HEADER ADDRESS IN R7
NEWCARD  LA    4,CARD             USE R4 FOR MULTIPLE READ OFF A CARD
         XREAD 0(4),80            READ A DATA CARD
         XPRNT CARD-1,81          ECHO PRINT THE ROW OF A MATRIX
         CLI   CARD,C'M'          HAS MATRIX INPUT ENDED
         BE    MULT               YES--THEN MULTIPLY THE MATRICES
         CLC   0(1,4),=C'*'       LOOK FOR MATRIX SEPARATER
         BE    MATRIXB            IF FOUND--LOAD ARRAY 'B'
NEXTELEM XDECI 11,0(4)            CONVERT FROM CARD TO HEX
         LR    4,1                KEEP XDECI MOVING IN CARD
         BO    NEWROW             END OF CURRENT ROW, GET NEW ROW
         LTR   11,11              IS VALUE ZERO?
         BZ    NEWCOL             YES<- GOTO NEXT COLUMN OF THIS ROW
         L     2,AVAIL            TEMP<--AVAIL
         MVC   AVAIL(4),4(2)      AVAIL<--LINK(AVAIL)
         ST    11,0(2)            VALUE(AVAIL)<--ELEMENT
         MVC   4(4,2),4(7)        ROWLINK(AVAIL)<--LINK(ROWHEADER
         MVC   8(4,2),4(10)       COLLINK(AVAIL)<--LINK(COLHEADER)
         ST    2,4(7)             LINK(ROWHEADER)<--AVAIL
         ST    2,4(10)            LINK(COLHEADER)<--AVAIL
         MVC   14(2,2),10(7)      ROWINDEX(AVAUL)<-- ROW INDEX
         MVC   12(2,2),10(10)     COLINDEX(AVAIL)<--COL. INDEX
NEWCOL   LA    9,4(9)             DISPLACE TO NEXT HEADER IN COL. TABLE
         L     10,0(9)            RETREIVE NEW HEADER ADDRESS IN R10
         B     NEXTELEM
NEWROW   LR    9,8                RESTART ROW ACCESSING TABCA
         LA    6,4(6)             GET NEXT ROW HEADER FROM LIST
         B     NEWMTRX            RESTART LOADING LOOP
MATRIXB  LA    5,TABRB            INITIALIZE FOR ARRAY LOADING
         LR    6,5                OPERATIONS ON ARRAY 'B'
         LA    8,TABCB
         LR    9,8
         B     NEWMTRX
*
*
*              THIS SECTION USES THE HEADER TABLES AS A STARTING POINT
*              AND MULTIPLIES THE TWO SPARSE MATRICES.  IF A ROW OF
*              MATRIX 'A' OR A COLUMN OF MATRIX 'B' ARE ALL ZEROS
*              OR IF A CORRESPONDING NODE DOES NOT EXIST IN EITHER
*              MATRIX, THAT NODE OR ROW OF OUTPUT IS SKIPPED AND THE
*              NEXT ROW-COLUMN PAIR OR NODE-NODE PAIR IS CONSIDERED.
*
*
MULT     XPRNT =CL50'0THE PRODUCT MATRIX IS',50
TEMP     EQU   14                 EQUATE THESE REGISTERS TO LABLES AT
RESULT   EQU   2                  LEFT FOR EASE IN IMPLEMENTING
I        EQU   3                  MULTIPLY OPERATION
J        EQU   4
K        EQU   5
L        EQU   6
         SR    14,14              TEMP<--0
         LR    RESULT,TEMP        RESULT<--0
         LM    I,L,ROWA           I<-IMAX,J<-JMAX,K<-KMAX,L<-LMAX
         LA    7,TABRA            REFERENCE HEADER TABLES FOR
         LA    8,TABCB            INDEXING INTO THE MATRICES
         SLL   L,2                DISPLACEMENT INTO THE TABLES
         AR    8,L                DISPLACE INTO TABLE
         S     8,=F'4'            CORRECT DISPLACEMENT FOR LAST ENTRY
         SRL   L,2                FOR LOOPING PURPOSES
BOTTOM   SLL   I,2                CORRECT TO BYTES,IMAX&LMAX FOR PROPER
         AR    7,I                DISPLACE INTO TABLES
         S     7,=F'4'            CORRECT DISPLACEMENT FOR LAST ENTRY
         SRL   I,2                RESTORE TO DECIMAL EQUIVALENT
         L     10,0(8)            R10<--HEADER (LMAX) ADDRESS
         L     13,4(10)           GET LAST NODE OF LIST
         ST    13,LASTNODE        SAVE FOR USE IN LOOP
START1   L     9,0(7)             R9<--HEADER(IMAX) ADDRESS
         L     11,4(9)            INDEX I TH NODE OF MATRIX A
CHECK    CR    10,13              IS COL(I) OF MATRIX B EMPTY
         BE COLNULL               YES--CONTINUE AT COLNULL
         CR    9,11               IS ROW(I) OF MATRIX A EMPTY
         BE    ROWNULL            YES--CONTINUE TA ROWNULL
         CH    I,14(11)           IS NODE THE I,J TH NODE OF A
         BNE   ROWZIP             NO--RECOVER AT ROWZIP
         CH    J,12(11)
         BNE   ROWZIP
         CH    K,14(13)           IS NODE K,L TH NODE OF B
         BNE   COLZIP             NO--RECOVER AT COLZIP
         CH    L,12(13)
         BNE   COLZIP
MULTPLY  L     15,0(11)           TEMP<--A(I,J)*B(K,L)
         M     TEMP,0(13)
         AR    RESULT,15          RESULT<--RESULT+TEMP
         BCTR  J,0                DECREMENT J & K FOR NEXT STAGE
         BCTR  K,0
         LTR   J,J                IS J ZERO
         BNP   JUMP1              YES--THEN GO TO JUMP FOR OUTPUT
TAKLINK  L     11,4(11)           TAKE LINK TO NEXT NODE IN BOTH MAT.
         L     13,8(13)
         B     CHECK              CHECKK IF THESE NODES ARE CORRECT
JUMP1    LTR   RESULT,RESULT      IF RESULT=0
         BZ    DECI               SKIP INSERTING RESULT IN OUT LIST
         BAL   15,INSERT          IF NOT--GO TO INSERT & OUTPUT RESULT
DECI     L     J,COLA             J<--JMAX
         L     K,ROWB             K<--KMAX
         SR    RESULT,RESULT      RESULT<--0
         L     13,LASTNODE        PREPARE MATRIX B FOR NEXT OPERATION
         BCTR  I,0                DECREMENT I FOR OPERATION CONTROL
         LTR   I,I                IS I=0
         BZ    DECL               GO TO DECL AND GET NEW COL IN B
         S     7,=F'4'            OTHERWISE GET NEXT ROW OF A
         B     START1             AND CONTINUE
COLNULL  CR    9,11               SINCE ROW(I) OF A IS EMPTY TESTTO
*                                 SEE IF CORRISPONDING COL OF B IS
*                                 ALSO EMPTY
         BE    DECL               IF IT IS GO TO DECL AND CONTINUE
         B     DECI               OTHERWISE--GO TO DECI AND CONTINUE
COLZIP   CH    I,14(11)           SINCE CORRECT NODE EXISTS IN MATRIX A
*                                 BUT NOT IN MATRIX B,  TEST FOR AT
*                                 LEAST ONE NODE IN  ROW(I) OF A
         BE    ROWLINK            IF IT EXISTS, TAKE A LINK IN A
COUT     BCTR  J,0                IF NOT, DECREMENT J & K AND CONTINUE
         BCTR  K,0
         B     CHECK
ROWLINK  L     11,4(11)           TAKE A LINK IN MATRIX A AND
         B     COUT               MAINTAIN LOOP CONTROLS AT COUT
*
*
*        SAME LOGIC FOR THE CASE WHEN  THE CORRECT NODE EXISTS IN
*        MATRIX B BUT NOT IN MATRIX A
*
*
ROWZIP   CH    K,14(13)
         BE    COLINK
ROUT     BCTR  J,0
         BCTR  K,0
         B     CHECK
COLINK   L     13,8(13)
*
         BCTR  J,0
         BCTR  K,0
         B     CHECK
*
*        LOGIC FOR ROWNULL IS THE SAME AS USED IN SECTION HEADED BY
*        COLNULL
*
*
ROWNULL  BCTR  J,0
         BCTR  K,0
         LTR   J,J
         BNP   JUMP1
         B     TAKLINK
*
*
*        LOGIC USED IN DECL SAME AS IN DECI
*
*
DECL     BCTR  L,0
         LTR   L,L
         BZ    OUTPUT
         S     8,=F'4'
         LA    7,TABRA
         L     I,ROWA
         B     BOTTOM
*
*
*              WHEN MULT DEVELOPES A PARTIAL PRODUCT, IT IS GIVEN TO
*              INSERT AND IS PUSHED ON THE FRONT OF THE OUTPUT STACK
*
*
INSERT   STM   0,9,SAVMAIN        PROTECT SOME REGS. TO USE LOCALLY
         L     1,TABSTK           ACCESS FIRST TABLE ENTRY
LOOK     CH    I,8(1)             IS HEADER THE I TH HEADER
         BE    LOCATED            YES--GO TO LOCATED
         LA    1,16(1)            NO--FIND NEXT HEADER
         B     LOOK               CONTINUE
LOCATED  L     7,AVAIL            P<--AVAIL
         CLC   4(4,7),=F'0'       IF LINK(P)=0
         BE    OVFLOW             THEN OVERFLOW
         MVC   AVAIL(4),4(7)      AVAIL<--LINK(AVAIL)
         C     1,12(1)            DOES LINK(HEADER)=HEADER ADDRESS
         BE    OPEN               YES--THEN OPEN THE LIST
         ST    1,0(7)             OTHERWISE; LLINK(P)<--HEADER ADDRESS
         MVC   12(4,7),12(1)      RLINK(P)<--RLINK(HEADER)
         L     3,12(1)            LINK TO NEXT AVAIL NODE IN R3
         ST    7,0(3)             RLINK(LLINK(HEADER))<--P
         ST    7,12(1)            RLINK(HEADER)<--P
BACK     ST    RESULT,4(7)        VALUE(P)<--RESULT
         STH   I,8(7)             ROWINDEX(P)<--I
         STH   L,10(7)            COLINDEX(P)<--L
         LM    0,9,SAVMAIN        RESTORE REGS. FOR RETURN
         BR    15                 RETURN
OPEN     MVC   12(4,7),12(1)      RLINK(P)<--RLINK(HEADER)
         MVC   0(4,7),12(1)       LLINK(P)<--RLINK(HEADER)
         ST    7,12(1)            RLINK(HEACER)<--P
         B     BACK               RETURN VIA BACK
*
*
*              WHEN MULTIPLICATION OPERATIONS ARE COMPLETEED, THE NEXT
*              SECTION OUTPUTS THE PRODUCT MATRIX AS STORED IN THE
*              ROW STACKS DEVELOPED AT INSERT
*
*
OUTPUT   L     1,TABSTK           ACCESS TABLE OF STACK HEADERS
         LA    2,ROWOUT2+3        R2<--ADD. OF BUFFER TO OUTPUT
         LA    10,COLOUT2+3       PRODUCT MATRIX
         L     3,ROWA             R3= NUMBER OF ROWS IN PRODUCT MATRIX
OUTLOOP  C     1,12(1)            IS LIST FOR ROW(I) EMPYT
         LR    14,1               COPY HEADER ADD. FOR EMPTY TEST
         BE    NOVALUES           YES--PRINT MESS AND CONTINUE
         L     9,12(1)            GET FIRST NODE OF CURRENT ROW
OUTNEXT  L     6,4(9)             TEMP<--VALUE(NODE)
         XDECO 6,OUTTEMP          CONVERT FOR OUTPUT
         MVC   0(4,2),OUTTEMP+8   PUT SIGNIFICANT PORTIOM OF NUMBER
*                                 INTO OUTPUT BUFFER
         LA    2,4(2)             GET NEXT USABLE PORTION OF BUFFER
         LH    6,10(9)            R6<--COL. INDEX
         XDECO 6,OUTTEMP          CONVERT FOT OUTPUT
         MVC   1(2,10),OUTTEMP+10 MOVE TO RIGHT IN COL BUFFER
         LA    10,4(10)           GET NEXT PORTION OF COL. BUFFER
         C     14,12(9)           ARE WE DONE--RLINK(NODE)=HEADER
         BE    DONE               YES--PRINT COMPLETED ROW & CONTINUE
         L     9,12(9)            ACCESS JTH NODE OF CURRENT ROW
         B     OUTNEXT            DO ABOVE FOR ALL NODES(I) OF EACH
*                                 ROW
DONE     LH    6,8(1)             R6<--ROW VALUE OF CURRENT ROW
         XDECO 6,OUTTEMP          CONVERT TO OUTPUT
         MVC   ROWOUT+3(2),OUTTEMP+10   MOVE INDEX INTO BUFFER
         XPRNT COLOUT,133         PRINT COL. INDICATOR
         XPRNT ROWOUT,133         PRINT COMPLETED ROW
         MVC   ROWOUT2(130),BLANK BLANK OUT WORKIG AREA OF BUFFER
         MVC   COLOUT2(130),BLANK BLANK OUT WORKIG AREA OF BUFFER
         XPRNT SKIP,3             SKIP 3 LINES
         LA    1,16(1)            ACCESS NEXT HEADER IN HEADER TABLE
         LA    2,ROWOUT2+3        RE-INITIALIZE OUTPUT AREA
         LA    10,COLOUT2+3       RE-INITIALIZE OUTPUT AREA
JUMP     BCT   3,OUTLOOP          LOOP IMAX TIMES
         XREAD CARD,10            LOOK FOR CONTROL CARDS OF NEXT
         BM    STOP               MATRIX OPERATION...IF /* FOUND STOP
         B     BEGIN              IF NOT--RESTART PROGRAM AT BEGIN
STOP     L     14,SAV14           PUT ASSIST RETURN ADDRESS IN R14
         XPRNT =CL5'1',5          SKIP A PAGE TO CLEAR OUTPUT
         BR    14                 RETURN TO ASSIST
NOVALUES XPRNT =CL50'0NO NON-ZERO ELEMENTS IN NEXT ROW',50
         B     DONE
OVFLOW   XPRNT =CL50'0OVERFLOW HAS OCCURRED, STOP EXECUTION',50
         B     STOP
         LTORG
SAV14    DS    F
AVAIL    DS    F
LASTNODE DS    F
ROWA     DS    F
COLA     DS    F
ROWB     DS    F
COLB     DS    F
ROWBI    DS    F
SAVMAIN  DS    18F
TABRA    DS    50F
TABCA    DS    50F
TABRB    DS    50F
TABCB    DS    50F
TABSTK   DS    50F
         DC    CL8' '              PROVIDE BLANKS FOR PRINTING
CARD     DS    80C
OUTTEMP  DS    12C
COLOUT   DC    C'0J='
COLOUT2  DC    130C' '
ROWOUT   DC    C'0I='
ROWOUT2  DC    130C' '
SKIP3    DC    C'0  '
EMESS    DC    C'0     MATRIX ONE----> ROW=            ;COL=           1
                ;MATRIX TWO-----> ROW=            ;COL=            '
BLANK    DC    130C' '
         DS    0D
WORKAREA DS    9000C
         END
$ENTRY
 3 2 2 4
1 0 E
3 4 E
0 6 E
*
0 8 9 10 E
0 12 0 14 E
M

3 3 3 3
0 0 0 E
4 5 6 E
7 8 9 E
*
9 0 7 E
6 0 4 E
3 0 1 E
M
M
3 3 3 3
1 2 3  E
4 5 6 E
7 8 9 E
*
9 8 7 E
6 5 4 E
3 2 1 E
M
M
3 2 2 3
1 2 E
3 4 E
5 6 E
*
7 8 9 E
10 11 12 E
M
M
1 3 3 1
1 2 3 E
*
4 E
5 E
6 E
M
M
1 1 1 1
4 E
*
4 E
M
M
1 8 8 1
0 0 0 0 0 0 0 0 E
*
1 E
0 E
0 E
0 E
0 E
0 E
0 E
0 E
M
M
3 2 2 5
1 2 E
3 4 E
5 6 E
*
1 2 3 4 5 E
6 7 8 9 10 E
M
M
$JOB   ASSIST   MACRO=F
         MACRO
&LABEL   QSAVE     &REGS=(14,12),&BASE=12,&SA=*
         GBLC      &SAVADDR
         LCLA      &DISP,&CNTR,&TBASE
         LCLC      &NAME
&LABEL   DS        0F .                     DEFINE LABEL, ALLIGN
         AIF       (&BASE EQ 13).ERROR .    IF BASE IS R13,R14, OR R15
         AIF       (&BASE EQ 14).ERROR .    ILLEGAL, SET DEFAULT VALUE
         AIF       (&BASE NE 15).OKAY
.ERROR   MNOTE     'ILLEGAL BASE REGISTER'
&TBASE   SETA      12
         AGO       .SKIP
.OKAY    ANOP
&TBASE   SETA      &BASE
.SKIP    USING     *,15
&CNTR    SETA      0-1
         AIF       ('&LABEL' EQ '').CSECTNM
.AGAIN   ANOP
&CNTR    SETA      &CNTR+2
         AIF       ('&LABEL'(1,&CNTR) LT '&LABEL').AGAIN
&NAME    SETC      '&LABEL'
         AGO       .IDFIELD
.CSECTNM ANOP
&CNTR    SETA      &CNTR+2
         AIF       ('&SYSECT'(1,&CNTR) LT '&SYSECT').CSECTNM
&NAME    SETC      '&SYSECT'
.IDFIELD B         1+&CNTR+4(,15)
         DC        X'&CNTR',CL.&CNTR'&NAME'
         AIF       (&REGS(1) EQ 14).ASPECAL .IS &REGS(1) 14 OR 15
         AIF       (&REGS(1) NE 15).AREGULR .IF YES GO TO ASPECAL
.ASPECAL ANOP
&DISP    SETA      ((&REGS(1)-14)*4)+12 .   DISPLACEMENT FOR R14&R15
         AGO       .ARESUME
.AREGULR ANOP
&DISP    SETA      (&REGS(1)*4)+20 .   DISPLACEMENT FOR R0-R12
.ARESUME STM       &REGS(1),&REGS(2),&DISP.(13). SAVE REGISTERS
         AIF       ('&SA' EQ 'NO').NOSAVE .SIP SAVE AREA
         AIF       ('&SA' EQ '*').DEFAULT
&SAVADDR SETC      '&SA'
         AGO       .AROUND
.DEFAULT ANOP
&SAVADDR SETC      '&SYSECT'(1,3).'&SYSNDX'(2,3).'S' .GENERATE NAME
.AROUND  LA        &TBASE,&SAVADDR .        GET SAVE AREA ADDR
         ST        &TBASE,8(13) .           PTR TO NEW SAVE AREA
         ST        13,4(&TBASE) .           PTR TO OLD SAVE AREA
         LR        13,&TBASE .              GET IN RIGHT SAVE AREA
.NOSAVE  BALR      &TBASE,0
         DROP      15 .                     DELETE TEMP BASE REG
         USING     *,&TBASE .               USING NEW BASE REG
         MEND
         SPACE     5
         MACRO
&LABEL   QRETURN   &REGS=(14,12),&SA=*
         GBLC      &SAVADDR
         LCLA      &DISP
&LABEL   DS        0H .                     DEFINE LABEL, ALLIGN
         AIF       (&REGS(1) EQ 14).BSPECAL .IS REG(1) 14 OR 15
         AIF       (&REGS(1) NE 15).BREGULR .IF YES GO TO BSPECAL
.BSPECAL ANOP
&DISP    SETA      ((&REGS(1)-14)*4)+12 . DISPLACDMENT FOR R14&R15
         AGO       .BRESUME
.BREGULR ANOP
&DISP    SETA      (&REGS(1)*4)+20 .        DISPLACEMENT FOR R0-R12
.BRESUME AIF       ('&SA' EQ 'NO').NORESTR
         L         13,4(13) .               RESTORE PREVIOUS SA PTR
         LM        &REGS(1),&REGS(2),&DISP.(13) .STANDARD REG RESTORA
         BR        14 .                     RETURN TO CALLER
&SAVADDR DC        18F'0' .                 SAVE AREA, USING GENERATED
         MEXIT
.NORESTR LM        &REGS(1),&REGS(2),&DISP.(13) .STANDARD REG RESTORA
         BR        14 .                     RETURN TO CALLER
         MEND
         SPACE     5
         MACRO
&LABEL   FREEHDR   &NUMBER,&LENGTH
         GBLA      &FREENUM(20),&FREELEN(20),&FREECTR
         GBLB      &FREEOFF
         AIF       (&FREEOFF).ERROR2
         AIF       (&FREECTR GE 20).ERROR1
&FREECTR SETA      &FREECTR+1
&LABEL   DC        A(FR&FREECTR)
&FREENUM(&FREECTR) SETA &NUMBER
&FREELEN(&FREECTR) SETA &LENGTH
         MEXIT
.ERROR1  MNOTE     8,'***MORE THAN 20 CALLS MADE ON FREEHDR**'
&FREEOFF SETB      1
         MEXIT
.ERROR2  MNOTE     *,'***FREEHDR HAS BEEN DISABLED**'
         MEND
         SPACE     3
         MACRO
         FREEAREA
         GBLA      &FREENUM(20),&FREELEN(20),&FREECTR,&FRCTR
         AIF       (&FREECTR GT &FRCTR). MORE
         MNOTE     *,'**CALL TO FREEAREA RESULTED IN NO PROCESSING**'
         MEXIT
.MORE    ANOP
&FRCTR   SETA      &FRCTR+1
FR&FRCTR DS        0F
.NEXT    AIF       (&FREENUM(&FRCTR) LE 1).LAST
         DC        A(*+4*(&FREELEN(&FRCTR)+1)),&FREELEN(&FRCTR)F'0'
&FREENUM(&FRCTR)   SETA &FREENUM(&FRCTR)-1
         AGO       .NEXT
.LAST    DC        A(0),&FREELEN(&FRCTR)F'0'
         AIF       (&FRCTR LT &FREECTR).MORE
         MEND
         SPACE     3
         MACRO
&LABEL   LISTHDR
&LABEL   DC        4F'0'
         MEND
         SPACE     3
         MACRO
&LABEL   GETFREE   &FRHDR,&REG,&END
&LABEL   L         &REG,&FRHDR .            GET PTR TO TOP
         LTR       &REG,&REG .              IS LIST EMPTY
         BZ        &END .                   YES, TAKE EXCEPTION EXIT
         MVC       &FRHDR.(4),0(&REG) .     NO, DELINK
         MEXIT
&END     SR        0,0
         MEND
         SPACE     3
         MACRO
&LABEL   PUTFREE   &FRHDR,&REG
&LABEL   MVC       0(4,&REG),&FRHDR .       RETURN NODE
         ST        &REG,&FRHDR .            TO TOP OF FREE LIST
         MEND
         SPACE     3
         MACRO
&LABEL   PUTNODE   &HDR,&REG,&KEY=4,&KEYLEN=4,&LENGTH=0,&MSG=
         GBLB      &NOTRC
         LCLC      &SVAREA,&LAB
&SVAREA  SETC      '&SYSECT'(1,3).'&SYSNDX'.'S'
&LAB     SETC      '&SYSECT'(1,3).'&SYSNDX'.'L'
         STM       1,3,&SVAREA .            SAVE R1, R2, R3
         LR        3,&REG .                 ADDR OF NODE TO BE PUT IN
         LA        1,&HDR
         L         &KEYLEN,&KEY.(1)
         LA        &KEYLEN,1(&KEYLEN) .     ADD 1 TO CURRENT LEN CNTR
         ST        &KEYLEN,&KEY.(1)
         C         &KEYLEN,&LENGTH.(1) .    IF CURRENT LENGTH
         BNH       *+8 .                    IS GREATER THAN MAX
         ST        &KEYLEN,&LENGTH.(1) .    THEN CHANGE MAX
&LAB     LR        &KEYLEN,1 .              TRANSVERSE LIST
         L         1,0(1)
         LTR       1,1 .                    IF WE ARE AT END
         BZ        *+14 .                   PUT NEW NODE HERE
         CLC       &KEY.(2,1),&KEY.(3) .    SHOULD NODE GO IN
         BNH       &LAB .                   NOT YET
         ST        1,0(3) .                 PUT IN NEW NODE
         ST        3,&HDR
         LR        &REG,3
         LM        1,3,&LAB .               RESTORE R1,R2,R3
         AIF       (&NOTRC EQ 1).NOTRACE .  OMIT TRACE
         AIF       (K'&MSG EQ 0).HDR .      PRINT HDR IF NO MSG
         XPRNT     =CL(13+K'&MSG)'0ADDITION TO &MSG',13+K'&MSG
         AGO       .DUMP
.HDR     XPRNT     =CL(13+K'&HDR)'0ADDITION TO &HDR',13+K'&HDR
.DUMP    XDUMP     &KEY.(&REG),&LENGTH
         XDUMP
.NOTRACE B         &SVAREA+12
&SVAREA  DC        3F'0'
         MEND
         SPACE     3
         MACRO
&LABEL   DELETE    &HDR,&REG,&END,&LENGTH=0,&MSG=
         GBLB      &NOTRC
         LCLC      &SVAREA,&LABM,&LABE,&LABL
&SVAREA  SETC      '&SYSECT'(1,3).'&SYSNDX'.'S'
&LABM    SETC      '&SYSECT'(1,3).'&SYSNDX'.'M'
&LABE    SETC      '&SYSECT'(1,3).'&SYSNDX'.'E'
&LABL    SETC      '&SYSECT'(1,3).'&SYSNDX'.'L'
         STM       1,3,&SVAREA .            SAVE R1, R2, R3
         LR        3,&REG
         LA        1,&HDR
&LABL    LR        &HDR,1 .                 TRANSVERSE LIST
         L         1,0(1)
         LTR       1,1 .                    IF DONE, ITEM
         BZ        &LABM .                  WAS NOT IN LIST
         CR        1,3
         BNE       &LABL .                  TRY NEXT NODE
         MVC       0(4,&REG),0(1) .         GOT IT NOW DELINK
         LA        1,&HDR .                 UPDATE LENGTH
         L         &REG,4(1)
         BCTR      &REG,0
         ST        &REG,4(1)
         LM        1,3,&SVAREA .            RESTORE R1, R2, R3
         AIF       (&NOTRC EQ 1).NO
         XPRNT     =CL(15+K'&HDR)'0DELETION FROM &HDR',15+K'&HDR
.NO      XDUMP
         B         &LABE
&SVAREA  DC        3F'0'
&LABM    LM        1,3,&SVAREA .            RESTORE R1, R2, R3
         B         &END
&LABE    EQU       *
&END     SR        0,0
         MEND
         SPACE     3
         MACRO
&LABEL   POP       &HDR,&REG,&END,&LENGTH=0,&MSG=
&LABEL   L         &REG,&HDR .              ADDR OF NODE TO REMOVE
&LABEL   DELETE    &HDR,&REG,&END,LENGTH=&LENGTH,MSG=&MSG
         MEND
         MACRO
         SETGBL    &CATNO=1,&IONO=1,&NOTRACE=NO
         GBLA      &CAT,&ION
         GBLB      &NOTRC
&CAT     SETA      &CATNO
&ION     SETA      &IONO
&NOTRC   SETB      0
         AIF       ('&NOTRACE' EQ 'NO').DONE
&NOTRC   SETB      1
.DONE    MEND
         SPACE     3
         MACRO
         LISTS
         GBLA      &CAT,&ION
.* GENERATE LIST HEADERS
         CRLISTS   CATHDR,&CAT
         CRLISTS   IOQHDR,&ION
         MEND
         SPACE     3
         MACRO
         CRLISTS   &PREFIX,&NUM
         LCLA      &COUNT
.MORE    ANOP
&COUNT   SETA      &COUNT+1
&PREFIX&COUNT LISTHDR
         AIF       (&COUNT LT &NUM).MORE
         MEND
         SETGBL
DATA     CSECT
EVQFR    FREEHDR   3,3
DQFR     FREEHDR   18,3
         LISTS
RJQHDR   LISTHDR
EVQHDR   LISTHDR
         FREEAREA
DQEL     DSECT
DQLINK   DS        F
DQKEY    DS        CL8
EVQEL    DSECT
EVQLINK  DS        F
EVQKEY   DS        CL8
         TITLE     'TEST'
         PRINT     GEN
TEST     CSECT
         QSAVE      ,
         L         11,DATAADR
         USING     DATA,11
         USING     EVQEL,1
         USING     DQEL,3
         GETFREE   EVQFR,ERROR
         MVC       EVQKEY,EVENT1
         PUTNODE   EVQHDR,1,KEYLEN=6,LENGTH=8
         GETFREE   EVQFR,1,ERROR
         MVC       EVQKEY,EVENT2
         PUTNODE   EVQHDR,1,KEYLEN=6,LENGTH=8
         GETFREE   EVQFR,1,ERROR
         MVC       EVQKEY,EVENT1
         PUTNODE   EVQHDR,1,KEYLEN=6,LENGTH=8
         LR        2,1
         GETFREE   EVQFR,1,UNDER1
         B         ERROR
UNDER1   XDUMP     EVQHDR,16
         DELETE    EVQHDR,2,ERROR,LENGTH=8
         PUTFREE   EVQFR,2
         DELETE    EVQFR,2,OK
         B         ERROR
OK       GETFREE   EVQHDR,1,ERROR
         MVC       EVQKEY,EVENT3
         SETGBL    NOTRACE=YES
         PUTNODE   EVQHDR,1,KEYLEN=6
         SETGBL    NOTRACE=NO
CONTINUE POP       EVQHDR,1,DONE,LENGTH=8
         PUTFREE   EVQFR,1
         B         CONTINUE
DONE     LA        5,JQE1
GETMORE  GETFREE   DQFR,3,UNDER2
         MVC       DQKEY,0(5)
         PUTNODE   CATHDR1,3,KEYLEN=2,LENGTH=8,MSG='CAT'
         SETGBL    NOTRACE=YES
         GETFREE   DQFR,3,ERROR
         MVC       DQKEY,0(5)
         PUTNODE   RJQHDR,3,KEY=6,KEYLEN=2
         GETFREE   DQFR,3,ERROR
         MVC       DQKEY,0(5)
         PUTNODE   IOQHDR1,3,KEY=8,KEYLEN=2
         LA        5,8(5)
         B         GETMORE
         SETGBL    NOTRACE=NO
UNDER2   POP       CATHDR1,1,ALLDONE,LENGTH=8
         POP       RJQHDR,1,ERROR,LENGTH=8
         POP       IOQHDR1,1,ERROR,LENGTH=8
         B         UNDER2
ERROR    XPRNT     =CL6'0ERROR',6
ALLDONE  XDUMP     CATHDR1,64
         QRETURN   SA=*
EVENT1   DC        F'5',H'1,2'
EVENT2   DC        F'6',H'0,0'
EVENT3   DC        F'5',H'0,0'
JQE1     DC        H'1,2,3,1'
         DC        H'2,3,1,2'
         DC        H'3,1,2,3'
         DC        H'3,2,1,4'
         DC        H'2,1,3,5'
         DC        H'1,3,2,6'
DATAADR  DC        V(DATA)
         END       TEST
$JOB   ASSIST   MACRO=F
         MACRO
&LABEL   QRETURN     &REGS=(14,12),&SA=*
         GBLC  &SAVL
         LCLA  &D
&LABEL   DS    0H  .               LABEL
         AIF   ('&SA' EQ 'NO').NOSAV
         L     13,4(13)  .         GET OLD POINTER
.NOSAV   AIF   (T'&REGS(1) NE 'N').EREG
&D       SETA  &REGS(1)*4+20
         AIF   (&D LE 75).LOADA
&D       SETA  &D-64
.LOADA   AIF   (N'&REGS NE 2).LOAD1
         LM    &REGS(1),&REGS(2),&D.(13)  .   RESTORE REGS
         AGO   .RET
.LOAD1   AIF   (N'&REGS NE 1).EREG
         L     &REGS(1),&D.(13)   .     SAVE ONLY ONE REG
.RET     BR    14  .               RETURN
         AIF   ('&SA' NE 'NO').GOON
         MEXIT
.GOON    AIF   ('&SA' NE '*').USEN
&SAVL    DC    18F'0'  .           SAVE AREA
         MEXIT
.USEN    ANOP
&SA      DC    18F'0'  .           SAVE AREA
         MEXIT
.EREG    MNOTE 8,'***REGISTERS CANNOT BE RETURNED-SPECIFICATION ERROR'
         MEND
         MACRO
&LABEL   QSAVE &REGS=(14,12),&BASE=12,&SA=*
         GBLA  &GINS
         GBLC  &SAVL
         LCLA  &LABLN,&BRDIST,&D
         LCLC  &LAB2,&BAS2
&LAB2    SETC '&LABEL'
&LABLN   SETA  K'&LABEL
&BAS2    SETC '&BASE'
         USING *,15  .             SET UP TEMP ADDS
         AIF   (&LABLN NE 0).LAB
         CSTLNG &SYSECT
&LABLN   SETA  &GINS
.LAB     ANOP
&LAB2    SETC '&SYSECT'
&BRDIST  SETA  (&LABLN+2)/2*2+4
&LABEL   B     &BRDIST.(,15)  .      CONVENTIONS FOR NAME
         DC    X'&LABLN',CL(&LABLN)'&LAB2'
         AIF   (T'&REGS(1) NE 'N').EREG
&D       SETA  &REGS(1)*4+20
         AIF   (&D LE 75).STOREA
&D       SETA  &D-64
.STOREA  AIF   (N'&REGS NE 2).STORE1
         STM   &REGS(1),&REGS(2),&D.(13)   .     SAVE CALLERS REGS
         AGO   .SAVE
.STORE1  AIF   (N'&REGS NE 1).EREG
         ST    &REGS(1),&D.(13)  .***ONLY ONE REG SAVED
.SAVE    AIF   ('&BAS2' LE '12').OK
         MNOTE 4,'***REG &BASE NOT A LEGAL BASE REG-REG 12 USED'
&BAS2    SETC  '12'
.OK      AIF   ('&SA' EQ 'NO').NOSAV
         AIF   ('&SA' NE '*').USEN
&SAVL    SETC  '&SYSECT'(1,3).'&SYSNDX.S'
         LA    &BAS2,&SAVL
         AGO   .SETSAV
.USEN    LA    &BAS2,&SA    .      SAVE AREA CONVENTIONS
.SETSAV  ST    &BAS2,8(13)
         ST    13,4(&BAS2)
         LR    13,&BAS2
.NOSAV   BALR  &BAS2,0   .             ADDRESSABILITY
         DROP  15
         USING *,&BAS2
         MEXIT
.EREG    MNOTE 8,'***REGISTERS NOT SAVED DUE TO SPEDC ERROR'
         MEND
         MACRO
         CSTLNG &NAME
         GBLA  &GINS
&GINS    SETA  K'&NAME
         MEND
         MACRO
         SETGBL  &TR
         GBLB  &NOTRC
         AIF   ('&TR' NE 'NO').GOON
&NOTRC   SETB  1
.GOON    MEND
         MACRO
&LABEL   FREEHDR    &NUMBER,&LENGTH
         GBLA  &FREENUM(20),&FREELEN(20),&FREECTR
         GBLB  &FREEOFF
         AIF   (&FREEOFF).ERROR2
         AIF   (&FREECTR GE 20).ERROR1
&FREECTR SETA  &FREECTR+1
&LABEL   DC    A(FR&FREECTR)
&FREENUM(&FREECTR)      SETA       &NUMBER
&FREELEN(&FREECTR)  SETA  &LENGTH
         MEXIT
.ERROR1  MNOTE 8,'**MORE THAN 20 CALLS MADE ON FREEHDR**'
&FREEOFF SETB  1
         MEXIT
.ERROR2  MNOTE *,'**FREEHDR HAS BEEN DISABLED**'
         MEND
         MACRO
         FREEAREA
         GBLA  &FREENUM(20),&FREELEN(20),&FREECTR,&FRCTR
         AIF   (&FREECTR GT &FRCTR).MORE
         MNOTE *,'**CALL TO FREEAREA RESULTED IN NO PROCESSING**'
         MEXIT
.MORE    ANOP
&FRCTR   SETA  &FRCTR+1
FR&FRCTR DS    0F
.NEXT    AIF   (&FREENUM(&FRCTR) LE 1).LAST
         DC    A(*+4*(&FREELEN(&FRCTR)+1)),&FREELEN(&FRCTR)F'0'
&FREENUM(&FRCTR)  SETA             &FREENUM(&FRCTR)-1
         AGO   .NEXT
.LAST    DC    A(0),&FREELEN(&FRCTR)F'0'
         AIF   (&FRCTR LT &FREECTR).MORE
         MEND
         MACRO
&LABEL   LISTHDR
&LABEL   DC    4F'0'
         MEND
         MACRO
&LABEL   GETFREE  &FRHDR,&REG,&END
&LABEL   L     &REG,&FRHDR  .GET LINK TO NODE
         LTR   &REG,&REG   .         IS IT THE NULL LIKN
         BZ    &END   .            IF SO THERE IS NO LINL
         MVC   &FRHDR.(4),0(&REG)  .   DELINK
         MEND
         MACRO
&LABEL   PUTFREE  &FRHDR,&REG
&LABEL   MVC   0(4,&REG),&FRHDR   .      RETURN NODE
         ST    &REG,&FRHDR   .     NEW TOP LINK
         MEND
         MACRO
&LABEL   PUTNODE  &HDR,&REG,&KEY=4,&KEYLEN=4,&LENGTH=0,&MSG=
         GBLB  &NOTRC
         LCLA  &KONT
         LCLC  &CHAR
&LABEL   DS    0H    .             DEFINE LABEL
         CNOP  0,4  .              ASSURE CORRECT ALIGNMENT
         STM   14,0,EP&SYSNDX.A+4  .     SAVE WORKING REGS
         LA    0,&HDR     .        PARAMETER
         ST    0,EP&SYSNDX.A+16  .     STORE PARAM
         LR    0,&REG              TRANSFER FOR CALL
         L     15,EP&SYSNDX.A  .     ENTRYPOINT
         BALR  14,15  .            GO TO SUBR
EP&SYSNDX.A    DC    V(PUTNODE)
         DC    4F'0'   .           SAVE AREA
         DC    AL1(&KEYLEN)
         DC    AL3(&KEY)
         LM    14,0,4(14)  .       RESTORE SECOND SET OF REGS
         AIF   (&NOTRC).NOTR
&CHAR    SETC '&HDR'
&KONT    SETA  K'&HDR
         AIF   (K'&MSG EQ 0).GENP
&CHAR    SETC '&MSG'
&KONT    SETA  K'&MSG
.GENP    ANOP
&KONT    SETA  &KONT+13
         XPRNT =CL&KONT' ADDITION TO &CHAR',&KONT
         AIF   (&LENGTH EQ 0).REGO
         XDUMP 4(&REG),&LENGTH  .    DUMP THE NODE
.REGO    XDUMP ,  .                DUMP REGS
.NOTR    MEND
         MACRO
&LABEL   DELETE  &HDR,&REG,&END,&LENGTH=0,&MSG=
         GBLB  &NOTRC
         LCLA  &KONT
         LCLC  &CHAR
&LABEL   DS    0H
         CNOP  0,4  .              ASSURE CORRECT ALIGNMENT
         STM   14,0,ENT&SYSNDX.D+4  .    SAVE FIRST REGS
         LA    0,&HDR
         ST    0,ENT&SYSNDX.D+16
         LR    0,&REG  .           SAVE REG TO CSECT
         L     15,ENT&SYSNDX.D   .       ENTRYPOINT
         BALR  14,15  .            CALL SUBR
ENT&SYSNDX.D   DC  V(DELETE)
         DC    4F'0'  .            CONTROL BLOCK SAVE AREA
         LTR   15,15               .            TEST FOR RESULTS
         LM    14,0,4(14)  .       RETURN TOP LEVEL REGS
         BNZ   &END                IF WAS NOT GO TO END
         AIF   (&NOTRC).NOTR
&CHAR    SETC '&HDR'
&KONT    SETA  K'&HDR
         AIF   (K'&MSG EQ 0).GENP
&CHAR    SETC '&MSG'
&KONT    SETA  K'&MSG
.GENP    ANOP
&KONT    SETA  &KONT+15
         XPRNT =CL&KONT' DELETION FROM &CHAR',&KONT
         XDUMP ,  .                DUMP REGS
.NOTR    MEND
         PRINT ON
         MACRO
&LABEL   POP   &HDR,&REG,&END,&LENGTH=0,&MSG=
&LABEL   L     &REG,&HDR     .     MAKE IT THE FIRAST NODE
         DELETE  &HDR,&REG,&END,LENGTH=&LENGTH,MSG=&MSG
         MEND
         MACRO
         SETGBL  &CATNO=1,&IONO=1,&NOTRACE=NO
         GBLA  &CAT,&ION
         GBLB  &NOTRC
&CAT     SETA  &CATNO
&ION     SETA  &IONO
&NOTRC   SETB  0
         AIF   ('&NOTRACE' EQ 'NO').DONE
&NOTRC   SETB  1
.DONE    MEND
         MACRO
         LISTS
         GBLA  &CAT,&ION
.* GENERATE LIST HEADERS
         CRLISTS  CATHDR,&CAT
         CRLISTS  IOQHDR,&ION
         MEND
         MACRO
         CRLISTS  &PREFIX,&NUM
         LCLA  &COUNT
.MORE    ANOP
&COUNT   SETA  &COUNT+1
&PREFIX&COUNT  LISTHDR
         AIF   (&COUNT LT &NUM).MORE
         MEND
PUTNODE  CSECT
*        ROUTINE TO PUT A NODE INTO A LIST BY KEYWORD
*        USES SPECIAL NON-DESTRUSTIVE LINKAGE
         USING PUTNODE,15          ADDRESSABILITY
         STM   1,7,PUSAVE          SAVE WORKING REGS
         SR    7,7                 CLEAR A EREG
         IC    7,20(14)            GET &KEYLEN
         LR    3,0                 TRANS R0 TO A USEABLE REG
         L     4,20(14)            GET KEY
         LA    6,0(4,3)            FOR OPERATIONAL EASE
         L     1,16(14)            ADDR OF &HDR
         L     2,4(1)              INCREMENT
         LA    2,1(2)              LENGTH CNTR
         ST    2,4(1)              STORE NEW CURRENT LENGTH
         C     2,8(1)              IS LENGTH>MAX
         BNH   PUNOCHNG            IF NOT DONT CHANGE
         ST    2,8(1)              UPDATE MAX
PUNOCHNG LR    2,1                 SAVE R1
         L     1,0(1)              GET LIMK
         LTR   1,1                 IS IT THE NULL LINK
         BZ    PUNEW0              IF SO WE ARE DONE
         LA    5,0(1,4)            SET UP ADDR FOR EX
         EX    7,PUCLC             COMPARE KEYS
         BNH   PUNOCHNG            IF NOT HIGH TRY SOME MORE
PUNEW0   ST    1,0(3)              PUT IN NEW NODE
         ST    3,0(2)              AND LINK UP
         LM    1,7,PUSAVE          RESTORE
         B     28(14)              RETURN
PUCLC    CLC   0(0,5),0(6)         USED BY EX
PUSAVE   DC    7F'0'               SAVE AREA
DELETE   CSECT
*        ROUTINE TO DELETE A GIVEN NODE FROM A LIST
*        USES SPECIAL NON-DESTRUSTIVE LINKAGE
         USING DELETE,15           ADDRESSABILITY
         STM   1,3,DESAV           SAVE WORKING REGS
         L     1,16(14)            ADDR OF &HDR
         LR    3,1                 COPY REG 1
DETOPL   LR    2,1                 COPY REG 1
         L     1,0(1)              LINK
         LTR   1,1                 IS IT END
         BZ    DENOTL              IF SO WE ARE DONE
         CR    1,0                 IS IT THE ONE
         BNE   DETOPL              IF NOT TRY AGAIN
         MVC   0(4,2),0(1)         DELINK NODE
         L     2,4(3)              UPDATE LENGCH
         BCTR  2,0                 BY DECREMENT BY 1
         ST    2,4(3)              STORE NEW LENGTH
         SR    15,15               SET FLAG--NORMAL RETURN
DERETL   LM    1,3,DESAV           RETURN WORKING REGS
         B     20(14)              RETURN
DENOTL   LA    15,1                SET RETUNR CODE--ITEM NOT IN LIST
         B     DERETL
DESAV    DS    3F'0'               SAVE AREA
         SETGBL
DATA     CSECT
EVQFR    FREEHDR 3,3
DQFR     FREEHDR  18,3
         LISTS
RQJHDR   LISTHDR
EVQHDR   LISTHDR
         FREEAREA
DQEL     DSECT
DQLINK   DS    F
DQKEY    DS    CL8
EVQEL    DSECT
EVQLINK  DS    F
EVQKEY   DS    CL8
         TITLE 'TEST'
         PRINT GEN
TEST     CSECT
         QSAVE
         L     11,DATAADR
         USING DATA,11
         USING EVQEL,1
         USING DQEL,3
         GETFREE  EVQFR,1,ERROR
         MVC   EVQKEY,EVENT1
         PUTNODE  EVQHDR,1,KEYLEN=6,LENGTH=8
         GETFREE  EVQFR,1,ERROR
         MVC   EVQKEY,EVENT1
         PUTNODE  EVQHDR,1,KEYLEN=6,LENGTH=8
         GETFREE  EVQFR,1,ERROR
         MVC   EVQKEY,EVENT1
         PUTNODE  EVQHDR,1,KEYLEN=6,LENGTH=8
         LR    2,1
         GETFREE  EVQFR,1,UNDER1
         B     ERROR
UNDER1   XDUMP EVQHDR,16
         DELETE  EVQHDR,2,ERROR,LENGTH=8
         PUTFREE  EVQFR,2
         DELETE  EVQHDR,2,OK
         B     ERROR
OK       GETFREE  EVQHDR,1,ERROR
         MVC   EVQKEY,EVENT3
         SETGBL  NOTRACE=YES
         PUTNODE  EVQHDR,1,KEYLEN=6
         SETGBL  NOTRACE=NO
CONTINUE POP   EVQHDR,1,DONE,LENGTH=8
         PUTFREE  EVQFR,1
         B     CONTINUE
DONE     LA    5,JQE1
GETMORE  GETFREE  DQFR,3,UNDER2
         MVC   DQKEY,0(5)
         PUTNODE  CATHDR1,3,KEYLEN=2,LENGTH=8,MSG='CAT'
         SETGBL  NOTRACE=YES
         GETFREE  DQFR,3,ERROR
         MVC   DQKEY,0(5)
         PUTNODE  RJQHDR,3,KEY=6,KEYLEN=2
         GETFREE  DQFR,3,ERROR
         MVC   DQKEY,0(5)
         PUTNODE  IOQHDR1,3,KEY=8,KEYLEN=2
         LA    5,8(5)
         B     GETMORE
         SETGBL  NOTRACE=NO
UNDER2   POP   CATHDR1,1,ALLDONE,LENGTH=8
         POP   RJQHDR1,1,ERROR,LENGTH=8
         POP   IOQHDR1,1,ERROR,LENGTH=8
         B     UNDER2
ERROR    XPRNT =CL6'0ERROR',6
ALLDONE  XDUMP CATHDR1,64
         QRETURN
EVENT1   DC    F'5',H'1,2'
EVENT2   DC    F'6',H'0,0'
EVENT3   DC    F'5',H'0,0'
JQE1     DC    H'1,2,3,1'
         DC    H'2,3,1,2'
         DC    H'3,1,2,3'
         DC    H'3,2,1,4'
         DC    H'2,1,3,5'
         DC    H'1,3,2,6'
DATAADR  DC    V(DATA)
         LTORG
         END   TEST
$JOASSIST  MACRO=F
         CSECT
         BALR  11,0
         USING *,11
         SR       6,6
         SR       7,7
         XREAD    CARD
         XDUMP  OVER,300
         L        7,=A(CARD)
OVER     CLI      0(7),C' '
         LA       7,1(7)
         BE       SS
         B        OVER
SS       LA       6,LAST
OK       MVC      0(1,6),0(7)
         LA       6,1(6)
         LA       7,1(7)
         CLI      0(7),C' '
         BNE      OK
         L        7,=A(CARD)
         IC       6,C' '
         LA       6,1(6)
ANEW     MVC      0(1,6),0(7)
         CLI      0(7),C' '
PRNT     XPRNT    LAST-1,81
         BE       PRNT
         LA       7,1(7)
         LA       6,1(6)
         B        ANEW
         BR       14
         DC       C'1'
LAST     DS       CL80' '
CARD     DS       CL80
         END
$ENTRY
LINDA BURNS
$JOASSIST MACRO=F
         MACRO
&LABEL   DEFLIST   &N
         LCLA      &CNT
&CNT     SETA      &N-2
LISTHEAD DC        A(&LABEL)
&LABEL   DC        A(*+80),72C' ',A(0)
.LOOP    DC        A(*+80),72C' ',A(*-76)
&CNT     SETA      &CNT-1
         AIF       (&CNT NE 0).LOOP
         DC        A(0),72C' ',A(*-76)
         MEND
         EJECT
MAIN     CSECT
BEGIN    STM       14,12,12(13)
         BALR      12,0
         USING     *,12
SSN      EQU       4
NAME     EQU       16
STATUS   EQU       14
ADDR     EQU       46
FLINK    EQU       0
BLINK    EQU       76
         LA        5,LISTHEAD
         L         5,0(5)
         MVC       SSN(5),SELECT
READ     XREAD     CARD,80
         BC        7,EOF
         MVC       TEMP(10),CARD
         MVI       TEMP+10,C' '
         XDECI     2,TEMP
         ST        2,DULLW
         C         2,SSN(5)
         BC        8,ERROR
         BC        2,HIGH
         L         5,FLINK(5)
MOVE     MVC       SSN(5),DULLW
         MVC       STATUS(5),ISTATUS
         MVC       NAME(5),INAME
         MVC       ADDR(5),IADDR
         B         READ
HIGH     MVC       TCARD(72),0(5)
         L         5,FLINK(5)
         MVC       0(72,5),TCARD
         L         5,BLINK(5)
         B         MOVE
EOF      LR        4,5
         LA        5,LIST1
PRINT    MVC       OSTATUS,STATUS(5)
         MVC       ONAME,NAME(5)
         MVC       OADDR,ADDR(5)
         L         3,SSN(5)
         CVD       3,DOUBLE
         XPRNT     LINE,132
         L         5,0(5)
         CR        5,4
         BC        11,EOJ
         B         PRINT
ERROR    MVC       LINE,LINE-1
         MVC       LINE(16),=C'THIS IS AN ERROR'
         XPRNT     LINE,132
EOJ      BR        14
         DC        C' '
LINE     DS        0CL132
         DC        17C' '
OSSN     DC        10C' '
         DC        17C' '
OSTATUS  DC        2C' '
DC       9C' '
ONAME    DC        30C' '
         DC        9C' '
OADDR    DC        30C' '
         DC        8C' '
CARD     DS        0CL80
ISSN     DS        CL10
ISTATUS  DS        CL2
INAME    DS        CL30
IADDR    DS        CL30
         DS        CL8
SELECT   DC        F'9999999999'
DULLW    DS        D
DOUBLE   DS        D
TEMP     DS        CL10
TCARD    DS        CL76
         LTORG
LIST1    DEFLIST   50
         END
$ENTRY
THIS IS ANY OLD CARD
$JOASSIST  MACRO=F
         MACRO
&LABEL   POP   &HDR,&REG,&END,&LENGTH,&MSG
.*
.*       THIS IS MACRO POP. IT TAKES A NODE OFF OF THE TOP OF THE
.*       LINKED LIST.
.*
.*       &HDR -ADDRESS OF THE HEADER OF THE LINKED LIST.
.*       &REG -REGISTER WITH HEADER OF LINKED LIST.
.*       &END -THIS IS THE LABEL OF SOME INSTRUCTION.
.*       &LENGTH -NUMBER OF BYTES OF DATA PORTION OF NODE ADDED.
.*       &MSG -A QUOTED STRING OF CHARACTERS.
.*
         L     &REG,&HDR           LOAD HDR INTO REG.
&LABEL   DELETE &HDR,&REG,&END,&LENGTH,&MSG
         MEND
         MACRO
&LABEL   GETFREE &FRHDR,&REG,&END
.*
.*       THIS MACRO GETS A FREE NODE FROM THE FREE LIST WHOSE HEADER
.*       IS AT &FRHDR.
.*
.*       &REG -REGISTER INTO WHICH ADDRESS OF NODE IS PLACED.
.*       &END -AREA OF CODE TO BE GENERATED IF GETFREE FAILS TO GET
.*       ANY FREE SPACE FROM THE LIST.
.*       &LABEL -LABEL TO BE PLACED IN FIRST INSTRUCTION OF GEN. CODE.
.*       &FRHDR -IS A RELOCATABLE EXPRESSION.
.*       &REG -ABSOLUTE EXPRESSION BETWEEN 1 AND 15.
.*       &END -LABEL OF SOME INSTRUCTION.
.*
&LABEL   L     &REG,&FRHDR         GET POINTER TO THE TOP.
         LTR   &REG,&REG           TEST TO SEE IF LIST NULL.
         BZ    &END                IF YES TAKE THE EXIT.
         MVC   &FRHDR.(4),0(&REG)  NO DELINK   TOP CELL.
         MEND
         MACRO
&LABEL   PUTFREE &FRHDR,&REG
.*
.*       THE PUTFREE MACRO RETURNS A NODE TO THE FREE LIST. THE
.*           HEADER IS AT &FRHDR. THE ADDRESS OF THE NODE IS IN &REG.
.*
.*       &REG -NUMBER BETWEEN 1 AND 15.
.*       &FRHDR - THIS IS A RELOCATEABLE EXPRESSION.
.*
&LABEL   DS    OH
         MVC   0(4,&REG),&FRHDR    RETURN THE NODE TO LIST.
         ST    &REG,&FRHDR         PUT IT ON THE VERY FRONT.
         MEND
         MACRO
&LABEL   PUTNODE &HDR,&REG,&KEY,&KEYLEN,&LENGTH,&MSG
.*
.*       PUTNODE PUTS A NODE INTO LINKED LIST WITH HEADER AT &HDR.
.*       THE NODES ADDRESS IS FOUND IN &REG. THE INSERTION IS BY ASCEND
.*       ING ORDER AT AN OFFSET OF &KEY BYTES FROM BEGINNING OF NODE.
.*       LENGTH OF KEY IS SPECIFIED BY KEYLEN. THE LIST LENGTH WILL BE
.*       UPDATED.
.*
.*       &LABEL -THIS IS A LABEL.
.*       &REG - THIS IS ABSOLUTE EXPRESSION BETWEEN 1 AND 15.
.*       &HDR - THIS TELLS WHERE HEADER IS.
.*       &KEY - ABSOLUTE EXPRESSION AS DEFINED ABOVE
.*       &KEYLEN -ABSOLUTE EXPRESSION AS DEFINED ABOVE.
.*       &LENGTH -ABSOLUTE EXPRESSION AS DEFINED ABOVE.
.*       &MSG - THIS IS A QUOTED STRING OF CHARACTERS.
.*
         LCLC  &PUT
&PUT     SETC  'PUT0001'
&LABEL   STM   1,3,&PUT.'S'        SAVE REGISTERS 1,2,AND3.
         LR    3,&REG              LOAD REGISTER 3 INTO REGISTER 5.
         LA    1,&HDR
         L     2,4(1)              ADD ONE TO CURRENT LENGTH COUNTER.
         LA    2,1(2)
         ST    2,4(1)
         C     2,&LENGTH(1)        IS CURRENT LENGTH GREATER THAN MAX.
         BNH   *+&LENGTH
         ST    2,&LENGTH(1)        YES, THEN CHANGE MAX.
&PUT.'L' LR    2,1                 TRANSVERSE THE LIST.
         L     1,0(1)
         LTR   1,1                 ARE WE AT THE END.
         BZ    *+14                END REACHED, PUT NEW NODE HERE.
         CLC   4(KEYLEN,1),4(3)    COMPARE TO SEE IF NODE GOES IN.
         BNH   &PUT.'L'            FT DOES NOT GO IN YET.
         ST    1,0(3)              STORE REGISTER 1 ZERO BEYOND 3.
         ST    3,&HDR              STORE REGISTER 3 INTO &HDR.
         LR    &REG,3              RELOAD REGISTER 3 INTO &REG.
         LM    1,3,&PUT.'S'        RESTORE REGISTERS 1,2,AND3.
         XPRNT =CL(13+3)' ADDITION TO &MSG ',13+3
         XDUMP 4(&REG),&LENGTH
         B     &PUT.'S'+12
&PUT.'S' DC    3F'0'
         MEND
         MACRO
&LABEL   DELETE &HDR,&REG,&END,&LENGTH,&MSG
.*
.*       THE DELETE MACRO DELETES A NODE FROM THE LINKED LIST.
.*
.*       &REG -ADDRESS OF NODE TO BE DELETED.
.*       &HDR -HEADER OF LINKED LIST.
.*       &END -THIS IS LABEL OF SOME INSTRUCTION TO WHICH TO BRANCH.
.*       &LENGTH -LENGTH OF BYTES OF NODE TO BE DELETED.
.*       &MSG -THIS IS A MESSAGE.
.*
         LCLC  &PUT
&PUT     SETC  'DEL0005'
         STM   1,3,&PUT.'S'        SAVE REGISTERS 1,2,AND3.
         LR    3,&REG
         LA    1,&HDR
&PUT.'L' LR    &REG,1              TRANSVERSE THE LIST.
         L     1,0(1)
         LTR   1,1                 CHECK TO SEE IF DONE.
         BZ    &PUT.'M'            YES,ITEM NOT IN LIST.
         CR    1,3
         BNE   &PUT.'L'            TRY THE NEXT NODE.
         MVC   0(4,&REG),0(1)      GOT THE NODE, NOW DELINK IT.
         LA    1,&HDR              UPDATE THE LENGTH NOW.
         L     &REG,4(1)
         BCTR  &REG,0
         ST    &REG,4(1)
         LM    ',3,&PUT.'S'        RESTORE REGISTERS 1,2,AND3.
         XPRNT =CL(15+5)' DELETION FROM &HDR ',15+5
         XDUMP                     JUST REGISTERS
         B     &PUT.'E'
&PUT.'S' DC    3F'0'
&PUT.'M' LM    1,3,&PUT.'S'        RESTORE REGISTERS 1,2,AND3.
         B     &END
&PUT.'E' EQU   *
         MEND
         MACRO
&LABEL   DUMPLIST &HDR,&NUM,&LEN,&MSG
.*
.*       THIS MACRO DUMPS THE FIRST &LEN BYTES BEYOND LINK OF EACH OF
.*       THESE UP TO &NUM FIRST NODE IN LINKED LIST WHOSE HEADER=&HDR.
.*       THE MESSAGE 'DUMP OF &HDR' OR 'DUMP OF MSG' IS PRINTED AS
.*       PRELUDE TO DUMP. EACH NODE IS LABELED THRU XSNAP BY THE STRING
.*       'NEXT NODE'
.*
&LABEL   XSNAP LABEL='DUMP OF PMSG'
         LCLC  &PUT
         STM   1,2,DMP0007S        SAVE REGISTERS 1 AND 2.
         L     1,&HDR
         LA    2,&NUM
&PUT     SETC  'DMP0007'
&PUT.'L' LTR   1,1                 IF AT THE END THEN QUIT.
         BZ    &PUT.'E'
         XSNAP T=NO,LABEL='NEXT NODE',STORAGE-(*4(1),*&NUM(1))
         L     1,0(1)
         BCT   2,&PUT.'L'          GET THE NEXT NODE
         B     &PUT.'E'
&PUT.'S' DC    2F'0'
&PUT.'E' LM    1,2,&PUT.'S'
         MEND
        MACRO
         SETGBL  &NOTRACE=NO
         GBLA      &CAT,&ION
         GBLB      &NOTRC
&CAT     SETA    1
&ION     SETA    1
&NOTRC   SETB      0
         AIF       ('&NOTRACE' EQ 'NO').DONE
&NOTRC   SETB      1
.DONE    MEND
         MACRO
         LISTS
         GBLA      &CAT,&ION
.* GENERATE LIST HEADERS
         CRLISTS   CATHDR,&CAT
         CRLISTS   IOQHDR,&ION
         MEND
         MACRO
         CRLISTS   &PREFIX,&NUM
         LCLA      &COUNT
.MORE    ANOP
&COUNT   SETA      &COUNT+1
&PREFIX&COUNT      LISTHDR
         AIF       (&COUNT LT &NUM).MORE
         MEND
         SETGBL
DATA     CSECT
EVQFR    FREEHDR   3,3
DQFR     FREEHDR   18,3
         LISTS
RJQHDR   LISTHDR
EVQHDR   LISTHDR
         FREEAREA
DQEL     DSECT
DQLINK   DS        F
DQKEY    DS        CL8
EVQEL    DSCET
EVQLINK  DS        F
EVQKEY   DS        CL8
         TITLE     'TEST'
         PRINT     GEN
TEST     CSECT
         QSAVE ,                   OR WHAT HAVE (BR=12)
         L         11,DATAADR
         USING     DATA,11
         USING     EVQEL,1
         USING     DQEL,3
         GETFREE   EVQFR,1,ERROR
         MVC       EVQKEY,EVENT1
         PUTNODE   EVQHDR,1,KENLEN=6,LENGTH=8
         GETFREE   EVQFR,1,ERROR
         MVC       EVQKEY,EVENT2
         PUTNODE   EVQHDR,1,KENLEN=6,LENGTH=8
         GETFREE   EVQFR,1,ERROR
         MVC       EVQKEY,EVENT1
         PUTNODE   EVQHDR,1,KEYLEN=6,LENGTH=8
         LR        2,1
         GETFREE   EVQFR,1,UNDER1
         B         ERROR
UNDER1   XDUMP     EVQHDR,16
         DELETE    EVQHDR,2,ERROR,LENGTH=8
         PUTFREE   EVQFR,2
         DELETE    EVQHDR,2,OK
         B         ERROR
OK       GETFREE   EVQHDR,1,ERROR
         MVC       EVQKEY,EVENT3
         SETGBL    NOTRACE=YES
         PUTNODE   EVQHDR,1,KEYLEN=6
         SETGBL    NOTRACE=NO
CONTINUE POP       EVQHDR,1,DONE,LENGTH=8
         PUTFREE   EVQFR,1
         B         CONTINUE
DONE     LA        5,JQE1
GETMORE  GETFREE   DQFR,3,UNDER2
         MVC       DQKEY,0(5)
         PUTNODE   CATHDR1,3,KEYLEN=2,LENGTH=8,MSG='CAT'
         SETGBL    NOTRACE=YES
         GETFREE   DQFR,3,ERROR
         MVC       DQKEY,0(5)
         PUTNODE   RJQHDR,3,KEY=6,KEYLEN=2
         GETFREE   DQFR,3,ERROR
         MVC       DQKEY,0(5)
         PUTNODE   IOQHDR1,3,KEY=8,KEYLEN=2
         LA        5,8(5)
         B         GETMORE
         SETGBL    NOTRACE=NO
UNDER2   POP       CATHDR1,1,ALLDONE,LENGTH=8
         POP       RJQHDR,1,ERROR,LENGTH=8
         POP       IOQHDR1,1,ERROR,LENGTH=8
         B         UNDER2
ERROR    XPRNT     =CL6'OERROR',6
ALLDONE  XDUMP     CATHDR1,64
         QRETURN   SA=*
EVENT1   DC        F'5',H'1,2'
EVENT2   DC        F'6',H'0,0'
EVENT3   DC        F'5',H'0,0'
JQE1     DC        H'1,2,3,1'
         DC        H'2,3,1,2'
         DC        H'3,1,2,3'
         DC        H'3,2,1,4'
         DC        H'2,1,3,5'
         DC        H'1,3,2,6'
         DC        V(DATA)
         END       TEST
         MACRO
&LABEL   FREEHDR   &NUMBER,&LENGTH
         GBLA      &FREENUM(20),&FREELEN(20),&FREECTR
         GBLB      &FREEOFF
         AIF       (&FREEOFF).ERROR2
         AIF       (&FREECTR GE 20).ERROR1
&FREECTR SETA      &FREECTR+1
&LABEL   DC        A(FR&FREECTR)
&FREENUM(&FREECTR) SETA &NUMBER
&FREELEN(&FREECTR) SETA &LENGTH
         MEXIT
.ERROR1 MNOTE 8,'**MORE THAN 20 CALLS MADE ON FREEHDR**'
&FREEOFF SETB      1
         MEXIT
.ERROR2 MNOTE *,'**FREEHDR HAS BEEN DISABLED**'
         MEND
         MACRO
         FREEAREA
         GBLA      &FREENUM(20),&FREELEN(20),&FREECTR,&FRCTR
         AIF       (&FREECTR GT &FRCTR).MORE
         MNOTE *,'**CALL TO FREEAREA RESULTED IN NO PROCESSING**'
         MEXIT
.MORE    ANOP
&FRCTR   SETA      &FRCTR+1
FR&FRCTR DS        0F
.NEXT    AIF       (&FREENUM(&FRCTR) LE1).LAST
         DC        A(*+4*(&FREELEN(&FRCTR)+1)),&FREELEN(&FRCTR)F'0'
&FREENUM(&FRCTR) SETA &FREENUM(&FRCTR)-1
         AGO       .NEXT
.LAST    DC        A(0),&FREELEN(&FRCTR)F'0'
         AIF       (&FRCTR LT &FREECTR).MORE
         MEND
DATA     CSECT
FRLIST1  FREEHDR   200,10
FRLIST2  FREEHDR   75,3
         FREEAREA
MAIN     CSECT
         XSAVE
         L         11,=V(DATA)
         USING     DATA,11
         END
$JOASSIST  MACRO=F
         MACRO
&LABEL   GETFREE   &FRHDR,&REG,&END
&LABEL   L     &REG,&FRLIST1       GET POINTER TO TOP
         LTR   &REG,&REG           IS LIST EMPTY
         BZ    &END                YES, TAKE ERROR RETURN
         MVC   &FRHDR(4),0(&REG)   NO,DELINK
*        TOP CELL
         MEND
         MACRO
&LABEL   PUTFREE   &FRHDR,&REG
&LABEL   MVC   0(4,&REG),&FRHDR    RETURN NODE
         ST    &REG,&FRHDR         NODE TO TOPE OF LIST
         MEND
         MACRO
&LABEL   PUTNODE   &HDR,&REG,&KEY,
&LABEL   PUTNODE   &HDR,&REG,&KEY=4,&KEYLEN=4,&LENGTH=0,&MSG=
&LABEL   STM   1,3,PUT&SYSNDX.S    SAVE R1,R2,R3
         LR    3,&EEG
         LR    3,&REG              ADDR OF NODE TO BE ADDED
         LA    1,&HDR              ADDR OF HEADER TO LINKED LIST
         L     2,4(1)              GET CURRENT LENGTH COUNTER
         LA    2,1(2)              ADD
         LA    2,1(2)              ADD ONE TO CURRENT LENGTH COUNTER
         ST    2,4(1)              SAVE UPDATED LENGTH COUNTER
         C     2,8(1)              CONPARE CURRENT TO MAX LENGTH LIST
         C
         BNH   *+8
         ST    2,8(1)              STRE
         ST    2,8(1)              STORE NEW MAX LIST LENGTH
PUT&SYSNDX.L   LR  2,1             TRAVERSE LIST
         L     1,0(1)
         LTR   1,1                 CHECK FOR END OF LIST
         BZ    *+14
         BZ    *+14                END, PUT NEW NODE HERE
         CLC   &KEY(&KEYLENG
         CLC   &KEY(&KEYLEN,1),&KEY(3)           SHOULD NEW NODE GO IN
         BNH   PUT&SYSNDX.L        NOT YET

         ST    1,0(3)              PUT IN NEW NODE
         ST    3,0(2)
         LR    5,3
         LM    1,3,PUT&SYSNDX.S    RESTORE R1,R2,R3
         MEND
         MACRO
&LABEL   DELETE    &HDR,&REG,&END,&LENGTH=0,&MSG=
&LABEL   STM   1,3,DEL&SYSNDX.S    SAVE R1,R2,R3
         LR    3,2                 NODE ADDR INTO REGISTER
         L
         LA    1,&HDR              ADDR OF HEADER TO LINKED LIST
DEL&SYSNDX.L   LR  2,1             TRAVERSE LIST
         6     1,0(1)              GET LINK
         LTR   1,1                 CHECK FOR NULL LINK - END OF LIST
         BZ    DEL&SYSNDX.M        ITEM NOT IN LIST
         CR    1,3                 TEST LINKS
         BNE   DEL&SYSNDX.L        TRY NEXT NODE
         MVC   0(4,2),0(1)         GOT IT, NOW DELETE
         LA    1,&HDR              HEADER ADDR
         L     2,4(1)              LIST LENGTH
         BCTR  2,0                 LENGTH=LENGTH-1
         ST    2,4(1)
         LM    1,3,DEL&SYSNDX.S    RESTORE R1-R3
         B     DEL&SYSNDX.E        BRANCH AROUND DC
DEL&SYSNDX.S   DC  3F'0'           REGISTER SAVE AREA
DEL&SYSNDX.M   LM  1,3,DEL&SYSNDX.S    RESTORE REG
         B     &END                ERROR RETURN
DEL&SYSNDX.E   EQU *
         MEND
         MACRO
&LABEL   POP   &HDR,&REG,&END,&LENGTH=0,&MSG=
&LABEL   L     &REG,&HDR
&LABEL   DELETE    &HDR,&REG,&END,LENGTH=&LENGTH,MSG=&MSG
         MEND
         MACRO
&LABEL   FREEHDR   &NUMBER,&LENGTH
         GBLA  &FREENUM(20),&FREELEN(20),&FREECTR
         GBLB  &FREEOFF
         AIF   (&FREEOFF).ERROR2
         AIF   (&FREECTR GE 20).ERROR1
&FREECTR SET   &FREECTR+1
&LABEL   DC    A(FR&FREECTR)
&FREENUM(&FREECTR) SETA      &NUMBER
&FREELEN(&FREECTR) SETA      &LENGTH
         MEXIT
.ERROR1  MNOTE 8,'**MORE THAN 20 CALLS MADE ON FREEHDR**'
&FREEOFF SETB  1
         MEXIT
.ERROR2  MNOTE *,'**FREEHDR HAS BEEN DISABLED**'
         MEND
         MACRO
         FREEAREA
         GBLA  &FREENUM(20),&FREELEN(20),&FREECTR,&FRCTR
         AIF   (&FREECTR GT &FRCTR).MORE
         MNOTE *,'**CALL TO FREEAREA RESULTED IN NO PROCESSING**'
         MEXIT
.MORE    ANOP
&FRCTR   SETA  &FRCTR+1
FR&FRCTR DC    0F
.NEXT    AIF   (&FREENUM(&FRCTR) LE 1).LAST
         DC    A(*+4*(&FREELEN(&FRCTR)+1)),&FREELEN(&FRCTR)F'0'
&FREENUM(&FRCTR)   SETA      &FREENUM(&FRCTR)-1
         AGO   .NEXT
.LAST    DC    A(0),&FREELEN(&FRCTR)F'0'
         AIF   (&FRCTR LT &FREECTR).MORE
         MEND
         MACRO
&LABEL   LISTHDR
&LABEL   DC    4F'0'
         MEND
         MACRO
         SETGBL    &CATNO=1,&IONO=1,&NOTRACE=NO
         GBLA  &CAT,&ION
         GBLB  &NOTRAC
&CAT     SETA  &CATNO
&ION     SETA  &IONO
&NOTRAC  SETB  0
         AIF   ('&NOTRACE' EQ 'NO').DONE
&NOTRAC  SETB  1
.DONE    MEND
         MACRO
         LISTS
         GBLA  &CAT,&ION
.*             GENERATE LIST HEADERS
         CRLISTS   CATHDR,&CAT
         CRLISTS   IOQHDR,&ION
         MEND
         MACRO
         CRLISTS   &PREFIX,&NUM
         LCLA  &COUNT
.MORE    ANOP
&COUNT   SETA  &COUNT+1
&PREFIX&COUNT  LISTHDR
         AIF   (&COUNT LT &NUM).MORE
         MEND
         SETGBL
DATA     CSECT
EVQFR    FREEHDR   3,3
DQFR     FREEHDR   18,3
         LISTS
RJQHDR   LISTHDR
EVQHDR   LISTHDR
         FREEAREA
DQEL     DSECT
DQLINK   DS    F
DQKEY    DS    CL8
EVQEL    DSECT
EVQLINK  DS    F
EVQKEY   DS    CL8
TITLE    'TEST'
         PRINT GEN
TEST     CSECT
         QSAVE ,                   OR WHAT HAVE (BR=12)
         L     11,DATAADR
         USING DATA,11
         USING EVQEL,1
         USING DQEL,3
         GETFREE   EVQFR,1,ERROR
         MVC   EVQKEY,EVENT1
         PUTNODE   EVQHDR,1,KEYLEN=6,LENGTH=8
         GETFREE   EVQFR,1,ERROR
         MVC   EVQKEY,EVENT2
         PUTNODE   EVQHDR,1,KEYLEN=6,LENGTH=8
         GETFREE   EVQFR,1,ERROR
         MVC   EVQKEY,EVENT1
         PUTNODE   EVQHDR,1,KEYLEN=6,LENGTH=8
         LR    2,1
         GETFREE   EVQFR,1,UNDER1
         B     ERROR
UNDER1   XDUMP EVQHDR,16
         DELETE    EVQHDR,2,ERROR,LENGTH=8
         PUTFREE   EVQFR,2
         DELETE    EVQHDR,2,OK
         B     ERROR
OK       GETFREE   EVQHDR,1,ERROR
         MVC   EVQKEY,EVENT3
         SETGBL    NOTRACE=YES
         PUTNODE   EVQHDR,1,KEYLEN=6
         SETGBL    NOTRACE=NO
CONTINUE POP   EVQHDR,1,DONE,LENGTH=8
         PUTFREE   EVQFR,1
         B     CONTINUE
DONE     LA    5,JQE1
GETMORE  GETFREE   DQFR,3,UNDER2
         MVC   DQKEY,0(5)
         PUTNODE   CATHDR1,3,KEYLEN=2,LENGTH=8,MSG='CAT'
         SETGBL    NOTRACE=YES
         GETFREE   DQFR,3,ERROR
         MVC   DQKEY,0(5)
         PUTNODE   RJQHDR,3,KEY=6,KEYLEN=2
         GETFREE   DQFR,3,ERROR
         MVC   DQKEY,0(5)
         PUTNODE   IOQHDR1,3,KEY=8,KEYLEN=2
         LA    5,8(5)
         B     GETMORE
         SETGBL    NOTRACE=NO
UNDER2   POP   CATHDR1,1,ALLDONE,LENGTH=8
         POP   RJQHDR,1,ERROR,LENGTH=8
         POP   IOQHDR1,1,ERROR,LENGTH=8
         B     UNDER2
ERROR    XPRNT =CL6'0ERROR',6
ALLDONE  XDUMP CATHDR1,64
         QRETURN   SA=*            OR WHAT HAVE YOU
EVENT1   DC    F'5',H'1,2'
EVENT2   DC    F'6',H'0,0'
EVENT3   DC    F'5',H'0,0'
JQE1     DC    H'1,2,3,1'
         DC    H'2,3,1,2'
         DC    H'3,1,2,3'
         DC    H'3,2,1,4'
         DC    H'2,1,3,5'
         DC    H'1,3,2,6'
DATAADR  DC    V(DATA)
         END   TEST
$JOASSIST  MACRO=F
         MACRO
&NAME    $TRT  &FIELD,&TAB,&LEN=15
         SPACE 3
.*
.*       $TRT WILL
.*       1)   DO A TRT STARTING AT &FIELD WHICH MAY BE ANY OPERAND
.*       VALID AS SECOND OPERAND IN AN LA INSTRUCTION.
.*       2)  THE NUMBER OF BYTES SCANNED WILL BE PLACED IN GPR 0.
.*       3)    &TAB IS THE TABLE FOR THE TRT.
.*       4)  THE NUMBER OF BYTES TO BE SCANNED IS IN THE REGISTER
.*       SPECIFIED IN THE &LEN KEYWORD PARAMETER.  AFTER THE $TRT
.*       THIS REGISTER WILL HAVE THE NUMBER OF BYTES NOT SCANNED.
.*       5) THE CC , GPR 1, &GPR 2 HAVE THEIR USUAL VALUES AFTER A TRT.
.*
&NAME    STM   2,3,$TRT&SYSNDX-8   .      SAVE REGS
         LA    3,&FIELD .          3 -> FIELD
         LR    2,&LEN .            GET LENGTH
         BCTR  2,0 .               SET FOR EXECUTE
         B     $TRT&SYSNDX .       BR AROUND INST & SAVE AREA
         CNOP  2,4 .               GET PROPER ALIGNMENT
         TRT   0(0,3),&TAB .          ACT TRT
         DS    2F .                SAVEAREA
$TRT&SYSNDX EX 2,*-14 .            DO TRT
         BNZ   *+18 .              NON ZERO TAB BYTES?
         LR    0,&LEN .            NO
         LA    &LEN,0 .            SET 0 AND &LEN TO PROPER VALS
         LM    2,3,$TRT&SYSNDX-8 .       RESTORE REGS
         B     *+22 .              DONE
         STC   2,$TRT&SYSNDX-5 .      SAVE FUNCTION BYTE
         BALR  2,0 .               SAVE CC
         SR    3,1 .               COMPUTE -(LEN SCANNED)
         LCR   0,3 .               LEN SCANNED
         SR    &LEN,0 .            LEN REMAINING
         SPM   2 .                 RESET CC
         LM    2,3,$TRT&SYSNDX-8 .       SAVE REGS
         SPACE 3
         MEND
         SPACE 5
         MACRO
&NAME    TRTAB &FILL,&TABLE=
         LCLA  &N,&I,&K,&N1
         LCLC  &A
         SPACE 3
&NAME    DC    256FL1'&FILL'
&I       SETA  1
&N       SETA  N'&TABLE
         AIF   (&N/2*2 EQ &N).BACK
         MNOTE 8,'ODD NUMBER OF ARGS FOR TABLE INVALID'
.BACK    AIF   (&I GE &N).END
&K       SETA  K'&TABLE(&I)
         AIF   (&K EQ 1).NOTSPEC
         AIF   ('&TABLE(&I)'(1,1)  NE  '@').STRING
&K       SETA  &K-1
&A       SETC  '&TABLE(&I)'(2,&K)
         AIF   (&K GT 2).NOT2DIG
         AIF   ('&A' EQ 'BL').BL
         AIF   ('&A' EQ 'LP').LP
         AIF   ('&A' EQ 'RP').RP
         AIF   ('&A' EQ 'QT').QT
         AGO   .INVALID
.BL      ORG   &NAME+C' '
         DC    FL1'&TABLE(&I+1)'
         AGO   .BOT
.LP      ORG   &NAME+C'('
         DC    FL1'&TABLE(&I+1)'
         AGO   .BOT
.RP      ORG   &NAME+C')'
         DC    FL1'&TABLE(&I+1)'
.QT      ORG   &NAME+C''''
         DC    FL1'&TABLE(&I+1)'
         AGO   .BOT
.NOT2DIG AIF   (&K GT 3).NOT3DIG
         AIF   ('&A' EQ 'NUM').NUM
         AIF   ('&A' EQ 'COM').COM
         AIF   ('&A' EQ 'AMP').AMP
         AGO   .INVALID
.NUM     ORG   &NAME+C'0'
         DC    10FL1'&TABLE(&I+1)'
         AGO   .BOT
.COM     ORG   &NAME+C','
         DC    FL1'&TABLE(&I+1)'
         AGO   .BOT
.AMP     ORG   &NAME+C'&&'
         DC    FL1'&TABLE(&I+1)'
         AGO   .BOT
.NOT3DIG AIF   ('&A' NE 'ALPHA').INVALID
.ALPHA   ORG   &NAME+C'A'
         DC    9FL1'&TABLE(&I+1)'
         ORG   &NAME+C'J'
         DC    9FL1'&TABLE(&I+1)'
         ORG   &NAME+C'S'
         DC    8FL1'&TABLE(&I+1)'
         AGO   .BOT
.STRING  ANOP
&A       SETC  '&TABLE(&I)'(&K,1)
         ORG   &NAME+C'&A'
         DC    FL1'&TABLE(&I+1)'
&K       SETA  &K-1
         AIF   (&K GE 1).STRING
         AGO   .BOT
.NOTSPEC ORG &NAME+C'&TABLE(&I)'
         DC    FL1'&TABLE(&I+1)'
.BOT     ANOP
&I       SETA  &I+2
         AGO   .BACK
.INVALID MNOTE 8,'INVALID KEYWORD OR MULTIPLE CHAR ARG IN LIST'
         AGO   .BOT
.END     ORG
         SPACE 3
         MEND
         SPACE 5
         MACRO
         CALL  &NAME
         CNOP  0,4
         B     *+8
I&SYSNDX DC    V(&NAME)
         L     15,I&SYSNDX
         BALR  14,15
         MEND
         SPACE 5
         MACRO
&NAME    XBACK
         LCLA  &DISP,&N1,&N2,&N3,&N,&TEMP
         SPACE 3
&NAME    L     13,4(13)
&N       SETA  N'&SYSLIST
         AIF   (&N GT 0).BACK
         L     14,12(13)
         LM    2,12,28(13)
.DONE    BR    14
         LTORG
         SPACE 3
         MEXIT
.BACK    ANOP
&N1      SETA  &N1+1
         AIF   (&N1 GT &N).DONE
&N2      SETA  N'&SYSLIST(&N1)
         AIF   (&N2 LE 0 OR &N2 GT 2).ERR1
&TEMP    SETA  &SYSLIST(&N1,1)
         AIF   (&TEMP LT 0 OR &TEMP GT 15).ERR2
         AIF   (&TEMP LT 14).LOW
&DISP    SETA  12+(&TEMP-14)*4
         AGO   .X2
.LOW     ANOP
&DISP    SETA  20+&TEMP*4
.X2      AIF   (&N2 EQ 2).A2
         L     &TEMP,&DISP.(13)
         AGO   .X3
.A2      LM    &TEMP,&SYSLIST(&N1,2),&DISP.(13)
.X3      ANOP
&N2      SETA  0
         AGO   .BACK
.ERR1    MNOTE 8,'NUMBER OF ARGS IN SUBLIST MUST BE 1 OR 2'
         MEXIT
.ERR2    MNOTE 8,'REGISTER SPECIFICATION NOT BETWEEN 0 AND 16'
         MEND
         SPACE 5
         MACRO
&NAME    XGO   &ACONSA=,&ENTRY=
         LCLA  &###DISP
         LCLB  &ENT
         SPACE 3
         AIF   ('&ENTRY' EQ 'ENTRY').ENTER
         AIF   ('&ACONSA' EQ '').X1
&ENT     SETB  1
&###DISP SETA  4
.X1      TITLE '******** &NAME CSECT ***************************'
&NAME    CSECT
         B     14(0,15)
         DC    X'09',CL9'&NAME '
         STM   14,12,12(13)
         LR    14,13
         BAL   13,96+&###DISP.(15)
         USING *,13
         DC    18F'-1'
         AIF   (NOT &ENT).BACK
&ACONSA  DC    A(*-72)
.BACK    ST    14,4(13)
         ST    13,8(14)
         L     14,12(14)
         SPACE 3
         MEXIT
.ENTER   CNOP  0,4
         TITLE '******** &NAME ENTRY ********************************'
&NAME    DS    0H
         ENTRY &NAME
         B     0(0,15)
         DC    X'09',CL9'&NAME '
         STM   14,12,12(13)
         LR    14,13
         USING &SYSECT+24,13
         L     13,28(15)
         B     *+8
&ACONSA  DC    A(&SYSECT+24)
         AGO   .BACK
         MEND
         SPACE 5
         PRINT ON
         PRINT NOGEN
***********************************************************************
***********************************************************************
*              THIS PROGRAM CONTAINS EVERYTHING REQUIRED  PLUS  THE
*        ADDED FEATURES OF A LINKED CLASS FIELD AND NOTIFICATION OF A
*        DELETION OR A MODIFICATION. LIST HEADS ARE USED FOR THE CODE2,
*        CLASS, MAGIC NUMBER, AND THE SEX FIELDS.  THE ONLY LIMITATION
*        IS THAT NON-BLANK FIELDS ARE ASSUMED FOR INITIAL READ IN. THIS
*        PROGRAM HAS THE CAPABILITY TO LINK A FILE OF 200 CARDS, INDEX
*        25 DIFFERENT CODE 2 AND CLASS FIELDS.  ALL ERRORS ARE DETECTED
*        AND FLAGGED WITH ONLY THE SEVEREST CAUSING TERMINATION OF THE
*        PROGRAM
***********************************************************************
***********************************************************************
MAIN     XGO
***********************************************************************
******************* EQUATES REGISTERS TO SYMBOLIC NAMES ***************
***********************************************************************
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
CONREG   EQU   12
CLASSREG EQU   R4
POINTREG EQU   R5
AVAILREG EQU   R6
ADVCDE2  EQU   R7
NODELINK EQU   R8
PREG     EQU   R9
MAGNOREG EQU   R10
CLASINFO EQU   2
CLASSADD EQU   4
CODEINF2 EQU   0
CODELIK2 EQU   4
***********************************************************************
******************* SET UP A PSUEDO DSECT FOR SYMBOLIC  ***************
*******************  ADDRESSING IN ASSIST                **************
***********************************************************************
NAMELINK EQU   0
CODE2LL  EQU   4
CODE2LR  EQU   8
FSEXLINK EQU   12
MSEXLINK EQU   16
MAGNOL   EQU   20
MAGNOR   EQU   24
CLASSLIK EQU   28
NAME     EQU   32
SEX      EQU   51
MAGNUM   EQU   52
CLASS    EQU   61
CODE1    EQU   63
CODE2    EQU   68
***********************************************************************
*******************  INITIALLY CLEARS THE REGISTERS *******************
***********************************************************************
         SR    R0,R0
         SR    R1,R1
         SR    R2,R2
         SR    R3,R3
         SR    R4,R4
         SR    R5,R5
         SR    R6,R6
         SR    R7,R7
         SR    R8,R8
         SR    R9,R9
         SR    R10,R10
         SR    R11,R11
***********************************************************************
         USING CONSTANT,CONREG,R11
         L     CONREG,=V(CONSTANT)
         LA    R11,4095(CONREG)
         LA    R11,1(R11)
         LA    POINTREG,LAMDA
         LA    R3,LAVS
         LA    PREG,P
         LR    AVAILREG,R3
         ST    POINTREG,PTR
         ST    R3,AVAIL
         MVC   P(4),LAMDA
         MVI   STATFLAG,C'0'       INITIATIIZE STATE OF OPERATIONS FLAG
***********************************************************************
******************* LINKS AVAILABLE SPACE TOGETHER ********************
***********************************************************************
LINKLAVS CLC   0(3,R3),LAMDA
          BE  INIREAD
         LA    R3,72(R3)
         ST    R3,LAVS(R4)
         LA    R4,72(R4)
         B     LINKLAVS
INIREAD  XREAD CARD,80
         MVI   FLAG,C'0'           RESET THE FLAG
         CLC   CARD+1(5),STARS     LOOK FOR END OF DATA SET
         BE    EOFPRINT            PRINT OUT THE LISTS
***********************************************************************
*******************  READS IN AND DETECTS OVERFLOW ********************
*******************  AND EMPTY LIST TO SET LIST HEADS *****************
***********************************************************************
NAMEIN   CLC   LAMDA(4),AVAIL      SEE IF STORAGE IS EXHAUSTED
         BE    OVERFLOW            IT IS, SO GO TO OVERFLOW
         CLC   P(4),LAMDA          SEE IF THE LIST IS EMPTY
         BE    LISTMT              IT IS,  SO GO TO LISTMT
         MVC   AVAIL(4),NAMELINK(AVAILREG)   ADVANCE AVAIL
         CALL  MOVER               INSERT INTO NODE FOR ADDING TO LIST
         B     SEXFIND
***********************************************************************
*******************PRINTS LISTS FOR PARTS  A&B*************************
***********************************************************************
EOFPRINT EQU   *
         XPRNT NAMEHEAD,124
         XPRNT SPECNAME,133        PRINT THE SECOND HEADER
EOFLOOP  EQU   *
         MVC   FILES+11(19),NAME(PREG)
         MVC   FILES+44(1),SEX(PREG)
         MVC   FILES+61(9),MAGNUM(PREG)
         MVC   FILES+86(2),CLASS(PREG)
         MVC   FILES+102(5),CODE1(PREG)
         MVC   FILES+121(3),CODE2(PREG)
         L     PREG,NAMELINK(PREG)
         C     PREG,P
         BE    FINPRINT
         XPRNT FILES,133           NOW PRINT THE SEPARATE FILES
         B     EOFLOOP
FINPRINT EQU   *
         XPRNT FILES,133           PRINT ALL LISTS FORMED
         XPRNT CD2HEAD,132         PRINT THE CODE2 HEADER
         MVC   NAMEDUMP+1(39),BLANKS   CLEAR THE OUTPUT AREA
         LA    NODELINK,HDCODE2+4
         ST    NODELINK,STOREIN
         L     NODELINK,HDCODE2+4
         ST    NODELINK,NODLKST
PRINTCD2 MVC   NAMEDUMP+1(19),NAME(NODELINK)     MOVE THE NAME IN
         MVC   NAMEDUMP+36(3),CODE2(NODELINK)    MOVE THE CODE2 IN
         XPRNT NAMEDUMP,40
         CLC   NODLKST(4),CODE2LR(NODELINK)
         BE    CREMENT
         L     NODELINK,CODE2LR(NODELINK)
         B     PRINTCD2
CREMENT  L     NODELINK,STOREIN
         LA    NODELINK,8(NODELINK)
         ST    NODELINK,STOREIN
         L     R2,STOREIN
         MVC   NODLKST(4),0(R2)
         CLC   0(4,NODELINK),ZEROS
         BE    NOWEND
         CLC   0(4,NODELINK),PLUSES
         BE    NOWEND
         CLC   0(4,NODELINK),MINUS
         BE    CREMENT
         L     NODELINK,0(NODELINK)
         XPRNT =C'-',1
         BNE   PRINTCD2
NOWEND   EQU   *
         XPRNT MAGHEAD,128         PRINT THE MAGIC # HEADING
         L     NODELINK,HDMAGNO
         MVC   NAMEDUMP+1(39),BLANKS   CLEAR THE OUTPUT AREA
MAGPRINT MVC   NAMEDUMP+1(19),NAME(NODELINK)     MOVE NAME IN FOR OUTPT
         MVC   NAMEDUMP+30(9),MAGNUM(NODELINK)   MOVE THE MAGIC # IN
         XPRNT NAMEDUMP,40
         CLC   MAGNOR(4,NODELINK),HDMAGNO
         BE    MORE
         L     NODELINK,MAGNOR(NODELINK)
         B     MAGPRINT
MORE     EQU   *
         CLC   HDFSEX(4),LAMDA
         BE    NOFEM
         XPRNT FEMHEAD,132         PRINT THE FEMALE HEADING
         MVC   NAMEDUMP+1(39),BLANKS             CLEAR THE OUTPUT AREA
         L     NODELINK,HDFSEX
FEMLOOP  MVC   NAMEDUMP+1(19),NAME(NODELINK)     MOVE THE NAME IN
         MVC  NAMEDUMP+30(1),SEX(NODELINK)       MOVE THE SEX IN
         XPRNT NAMEDUMP,40
         CLC   FSEXLINK(4,NODELINK),LAMDA
         BE    NOWMALE             GO TO PRINT THE MALE LIST
         L     NODELINK,FSEXLINK(NODELINK)
         B     FEMLOOP
NOFEM    XPRNT NFEM,132
         BE    NOWMALE             GO TO PRINT THE MALE LIST
NOWMALE  EQU   *
         CLC   HDMSEX,LAMDA        SEE IF THE LIST IS EMPTY
         BE    NOMALE              IT IS EMPTY
         XPRNT MALEHEAD,128        PRINT THE MALE HEADER
         MVC   NAMEDUMP+1(39),BLANKS             CLEAR OUTPUT AREA
         L     NODELINK,HDMSEX     SET THE INDEX REGISTER
MALLOOP  MVC   NAMEDUMP+1(19),NAME(NODELINK)     MOVE THE NAME IN
         MVC  NAMEDUMP+30(1),SEX(NODELINK)       MOVE THE SEX IN
         XPRNT NAMEDUMP,40
         CLC   MSEXLINK(4,NODELINK),LAMDA        SEE IF END OF LIST
         BE    NWCLASS             NOW PRINT THE CLASS
         L     NODELINK,MSEXLINK(NODELINK)       INCREMENT NODELINK REG
         B     MALLOOP             CONTINUE
NOMALE   XPRNT NMALE,131
         BE    NWCLASS             NOW PRINT THE CLASS
NWCLASS  EQU   *
         XPRNT CLASHEAD,127
         MVC   NAMEDUMP+1(39),BLANKS   CLEAR THE OUTPUT AREA
         LA    CLASSREG,HDCLASS    RESET THE CLASS REGISTER FOR OUTPUT
BIGCLOOP CLC   CLASINFO(6,CLASSREG),ZEROS        SEE IF DONE
         BE    UPDATEER
         CLC   0(8,CLASSREG),PLUSES              SEE IF DONE
         BE    UPDATEER
         L     NODELINK,CLASSADD(CLASSREG)       INITIALIZE REGISTER
CLOOPRNT MVC   NAMEDUMP+1(19),NAME(NODELINK)     MOVE THE NAME IN
         MVC   NAMEDUMP+31(2),CLASS(NODELINK)    MOVE THE CLASS IN
         XPRNT NAMEDUMP,40
         CLC   CLASSLIK(4,NODELINK),LAMDA
         BE    UPCLASS
         L     NODELINK,CLASSLIK(NODELINK)
         B     CLOOPRNT
UPCLASS  LA    CLASSREG,8(CLASSREG)
         XPRNT =C'-',1             SPACE DOWN 3
         B     BIGCLOOP
***********************************************************************
*******************FINAL PRINTER **************************************
***********************************************************************
FINALPTR EQU   *
         L     NODELINK,HDFSEX     INITIALIZE THE REGISTER
         MVC   NAMEDUMP+1(39),BLANKS
         XPRNT FFEMPRIT,131        PRINT THE HEADER
FFEMLOOP CLC   MAGNUM(9,NODELINK),FIVES          SEE IF MAGIC # > 5'S
         BH    FEMFPRNT            >,  SET FLAG AND PRINT OUT
FINCFIN  CLC   FSEXLINK(4,NODELINK),LAMDA        ALL GIRLS GONE ????
         BE    CKFLAG              WERE THERE ANY
         L     NODELINK,FSEXLINK(NODELINK)       INCREMENT REGISTER
         B     FFEMLOOP            TRY AGAIN
CKFLAG   CLI   FEMFLAG,C'0'        WAS THERE ANY
         BE    NOCHICS             NO!!
         BNE   NEXTFINA
NOCHICS  XPRNT NOCHIC,131
         B     NEXTFINA            NEXT FINAL OUTPUT
FEMFPRNT MVI   FEMFLAG,C'1'        SET A FLAG
         MVC   NAMEDUMP+1(19),NAME(NODELINK)     MOVE THE NAME IN
         MVC   NAMEDUMP+22(1),SEX(NODELINK)      MOVE THE SEX IN
         MVC   NAMEDUMP+30(9),MAGNUM(NODELINK)   MOVE THE MAGIC # IN
         XPRNT NAMEDUMP,40
         B     FINCFIN             SEE IF ANY MORE
NEXTFINA EQU   *
         MVI   FEMFLAG,C'0'        RESET THE FLAG
         XPRNT FCLASOUT,132        PRINT THE HEADER
         MVC   NAMEDUMP+1(39),BLANKS             CLEAR OUTPUT AREA
         LA    CLASSREG,HDCLASS    INITIALIZE POINTER
ONEMT    CLC   CLASINFO(2,CLASSREG),SEVEN        > 07 ???
         BH    NACLASSP            IF PRINT THE FILE
         CLC   CLASINFO(6,CLASSREG),ZEROS        DONE ???
         BE    CLFCHEC             SEE IF THERE WERE ANY
         CLC   0(8,CLASSREG),PLUSES              DONE ?????
         BE    CLFCHEC             WERE THERE ANY ???
         LA    CLASSREG,8(CLASSREG)    INCREMENT CLASS POINTER
         B     ONEMT               TRY AGAIN
NACLASSP MVI   FEMFLAG,C'1'        SET A FLAG
         L     NODELINK,CLASSADD(CLASSREG)       SET TO FIRST NODE
INCREMLP MVC   NAMEDUMP+1(19),NAME(NODELINK)     MOVE NAME IN
         MVC   NAMEDUMP+25(2),CLASS(NODELINK)    MOVE CLASS IN
         XPRNT NAMEDUMP,40
         CLC   CLASSLIK(4,NODELINK),LAMDA        LAST ONE ???
         BE    LOOPCREM            GO BACK FOR MORE
         L     NODELINK,CLASSLIK(NODELINK)       SET TO THE NEXT NODE
         B     INCREMLP            GET NEXT ONE
LOOPCREM LA    CLASSREG,8(CLASSREG)              INCREMENT LIST HEAD
         B     ONEMT               LOOK AGAIN
CLFCHEC  CLI   FEMFLAG,C'1'        WHERE THERE ANY ???
         BL    PRNTERCL            NO, SO PRINT MESSAGE
         B     STOP                FINISHED!!!!!!!!!!!!!!!!!!!
PRNTERCL XPRNT NOCHIC,131
         B     STOP                FINISHED !!!!!!!!!!!!!!!
***********************************************************************
*******************  BEGINNING OF PART B, INSERT, MODIFY **************
*******************  AND DELETION FROM THE LIST          **************
***********************************************************************
UPDATEER EQU   *
UPREAD   XREAD CARD,80
         BNZ    FINALPTR           GO PRINT THE FINAL OUTPUT
         SR    R2,R2               CLEAR REGISTER 2 FOR INDEX BRANCH
         CLC   CARD+1(5),STARS     SEE IF END OF UPDATING OF FILE
         BE    FPRINTND
         MVC   FAKENODE(72),BLANKS CLEAR THE NODE FOR UPDATING
***********************************************************************
*******************  INDEX BRANCH TO TYPE OF OPERATION   **************
***********************************************************************
         TR    CARD+41(1),OPTAB    CHANGE LETTER INTO A NUMERIC
         IC    R2,CARD+41          INSERT FOR INDEX BRANCH
         B     *+0(R2)             INDEX BRANCH TO OPERATION
         B     ADDER               GO TO ADD ROUTINE
         B     DELETER             GO TO DELETE ROUTINE
         B     MODFYER             GO TO MODIFY ROUTINE
         B     DOWHAT              UNDEFINED OPERATION IS SPECIFIED
***********************************************************************
*******************  ADDITION PART OF PART B         ******************
***********************************************************************
ADDER    EQU   *
         MVI   STATFLAG,C'1'       SET TO ADD STATE
         B     NAMEIN
***********************************************************************
*******************  DELETION PART WHICH IN CASE OF AN ****************
*******************  EMPTY LIST BYPASSES ANY DELETION  ****************
*******************  UNTIL THERE IS SOMETHING TO DELETE  **************
******************** AND GIVES NOTIFICATION OF COMPLETE  **************
******************** EMPTYING OF THE LIST                **************
***********************************************************************
DELETER  EQU   *
         CLC   P,LAMDA             SEE IF EMPTY LIST
         BE    UPREAD              LIST EMPTY, NO DELETIONS ALLOWED
         L     PREG,P              RESET NEEDED REGISTERS
         L     POINTREG,PTR
         CALL  SAMENAME            FIND NODE = AND ONE BEFORE
         CLI   DFFLAG,C'4'         CHECK TO SEE IF IN LIST
         BE    UPREAD              NOT IN LIST SO GET NEXT CARD
         L     R1,NMADSTOR         LOAD FOR PRINT OUT
         MVC   NAMEDUMP+1(39),NAME(R1)
         CLI   DFFLAG,C'2'         IS IT THE END NODE???
         BE    PTCHANGE            YES
         BH    SOLONG              LAST NODE, SO TELL HIM
         CLI   DFFLAG,C'1'         SEE IF FIRST NODE
         BE    PCHANGE             IF YES, GO TO PCHANGE
CALLSTUF EQU   *
         CALL  DNL                 NAME LINK DELETER
         CALL  DSL                 SEX LINK DELETER
         CALL  DM#L                MAGIC NUMBER DELETER
         CALL  DCLASS              CLASS LINK DELETER
         CALL  DC#2L               CODE2 LINK DELETER
         B     INCLAVS             NOW INCREMENT AVAILABLE SPACE
***********************************************************************
*******************  CHANGES THE POSITION OF CRITICAL POINTERS ********
***********************************************************************
PCHANGE  L     PREG,NAMELINK(PREG) SET PREG TO NEXT NODE
         ST    PREG,P              SAVE THIS ADDRESS
         B     CALLSTUF            NOW DELETE
PTCHANGE L     R2,TEMPNAME         SET R2 TO THE NODE
         ST    PREG,NAMELINK(R2)   SET THE NEW FIRST
         LR    POINTREG,R2         SET NEW END POINTER
         ST    POINTREG,PTR        NOW SAVE IN PTR
         B     CALLSTUF
SOLONG   MVC   P,LAMDA             SET P TO EMPTY LIST
         XPRNT STAR,133
         XPRNT GOODBYE,131
         XPRNT STAR,133
         B     INCLAVS             DON'T DELETE, JUST INCREMENT
***********************************************************************
*******************  RETURNS THE NODES TO LAVS ************************
***********************************************************************
INCLAVS  L     NODELINK,NMADSTOR   SET NODELINK FOR RETURN TO LAVS
         MVC   NAMELINK(4,NODELINK),AVAIL        SET NAMELINK TO AVAIL
         ST    NODELINK,AVAIL      UPDATE AVAIL
         XPRNT =CL26' THE FILE BEING DELETED IS',26
         XPRNT NAMEDUMP,40
         B     UPREAD              WHATS NEXT UPDATE
***********************************************************************
*******************  MODIFY SECTION WITH FEATURES OF NOTI- ************
*******************  FICATION OF A BLANK MODIFY FIELD, AN  ************
*******************  UNDEFINED MODIFY CODE, AND ATTEMPTED  ************
*******************  MODIFICATION OF AN NONEXISTANT FILE   ************
***********************************************************************
MODFYER  EQU   *
         ST    AVAILREG,AVADST     SAVE NEXT NODE LOCATION
         SR    R2,R2               RECLEAR REGISTER 2 FOR INDEX BRANCH
         CLC   CARD+49(19),BLANKS  SEE IF BLANK MOD FIELD
         BE    FDBLANK             IF SO  PRINT MESSAGE AND LEAVE
         TR    CARD+43(1),OPOP     TRANSLATE BYTE FOR BRANCH
         IC    R2,CARD+43          INSERT FOR BRANCH
         B     *+0(R2)             INDEX BRANCH
         B     FDNAME              NAME MODIFICATION
         B     FDSEX               SEX MODIFICATION
         B     FDMAGNO             MAGIC # MODIFICATION
         B     FDCLASS             CLASS MODIFICATION
         B     FDCODE1             CODE1 MODIFICATION
         B     FDCODE2             CODE2 MODIFICATION
         B     FDERROR             INVALID MODIFICATION
FDERROR  MVC   NAMEDUMP+1(19),CARD+1   GET READY FOR MESSAGE
         XPRNT ERFIELD,131
         XPRNT NAMEDUMP,20
         XPRNT =C'-',1
         B     UPREAD
FDBLANK  MVC   NAMEDUMP+1(19),CARD+1
         XPRNT ERBLANK,129
         XPRNT NAMEDUMP,20
         XPRNT =C'-',1
         B     UPREAD
***********************************************************************
******************** MODIFIES THE NAME FIELD             **************
***********************************************************************
FDNAME   EQU   *
         CALL  SAMENAME            FIND THE NODE WITH SAME NAME FIELD
         CALL  DNL                 DELETE THE NAME
         L     AVAILREG,NMADSTOR   SET AVAILREG TO NODE FOR SUBROUTINES
         MVC   NAME(19,AVAILREG),CARD+49         INSERT NEW NAME
         CALL  FINAPLAC            NOW LINK THE NEW NAME
         B     MODBACK             GET READY TO LEAVE
***********************************************************************
******************** MODIFIES THE SEX FIELD              **************
***********************************************************************
FDSEX    EQU   *
         CALL  SAMENAME            FIND THE NODE WITH SAME NAME FIELD
         CALL  DSL                 DELETE THE SEX
         L     AVAILREG,NMADSTOR   SET AVAILREG TO NODE FOR SUBROUTINES
         MVC   SEX(1,AVAILREG),CARD+49           INSERT THE NEW SEX
         CALL  SEXLINK             LINK THE NEW SEX TO THE LIST
         B     MODBACK             GET READY TO LEAVE
***********************************************************************
******************** MODIFIES THE MAGIC NUMBER           **************
***********************************************************************
FDMAGNO  EQU   *
         CALL  SAMENAME            FIND THE NODE WITH SAME NAME FIELD
         CALL  DM#L                DELETE THE MAGIC NUMBER
         L     AVAILREG,NMADSTOR   SET AVAILREG TO NODE FOR SUBROUTINES
         MVC   MAGNUM(9,AVAILREG),CARD+49        INSERT THE NEW MAGIC #
         CALL  MAG#LINK            NOW LINK IN THE NEW MAGIC NUMBER
         B     MODBACK             GET READY TO LEAVE
***********************************************************************
******************** MODIFIES THE CLASS FIELD            **************
***********************************************************************
FDCLASS  EQU   *
         CALL  SAMENAME            FIND THE NODE WITH SAME NAME FIELD
         CALL  DCLASS              DELETE THE CLASS STANDING
         L     AVAILREG,NMADSTOR   SET AVAILREG TO NODE FOR SUBROUTINES
         MVC   CLASS(2,AVAILREG),CARD+49         INSERT THE NEW CLASS
         CALL  CLASLINK            NOW LINK IT IN
         B     MODBACK             GET READY TO LEAVE
***********************************************************************
******************** MODIFIES THE CODE1 FIELD            **************
***********************************************************************
FDCODE1  EQU   *
         CALL  SAMENAME            FIND THE NODE WITH SAME NAME FIELD
         L     AVAILREG,NMADSTOR   SET AVAILREG TO NODE FOR SUBROUTINES
         MVC   CODE1(5,AVAILREG),CARD+49         INSERT THE NEW CODE1
         B     MODBACK             GET READY TO LEAVE
***********************************************************************
******************** MODIFIES THE CODE2 FIELD            **************
***********************************************************************
FDCODE2  EQU   *
         CALL  SAMENAME            FIND THE NODE WITH SAME NAME FIELD
         CALL  DC#2L               DELETE THE CODE2 OF THE NODE
         L     AVAILREG,NMADSTOR   SET AVAILREG TO NODE FOR SUBROUTINES
         MVC   CODE2(3,AVAILREG),CARD+49         INSERT THE NEW CODE2
         CALL  COD2LINK            LINK IT IN THE RIGHT PLACE
         B     MODBACK             GET READY TO LEAVE
***********************************************************************
******************** PRINTS A MESSAGE TELLING OF MODIFICATION  ********
***********************************************************************
MODBACK  MVC   NAMEDUMP+1(39),NAME(AVAILREG)     MOVE IN FOR OUTPUT
         XPRNT FDMOD,131           PRINT THE HEADING
         XPRNT NAMEDUMP,40         PRINT THE FILE
         L     AVAILREG,AVADST     RESET AVAILREG
         B     UPREAD              GET THE NEXT CARD
DOWHAT   EQU   *
         MVC   NAMEDUMP+1(39),CARD MOVE THE NAME IN FOR ERROR MESSAGE
         XPRNT WROP,131            PRINT ERROR MESSAGE
         XPRNT NAMEDUMP,40
         B     UPREAD              GET THE NEXT CARD
FPRINTND XPRNT STAR,133            TO DRAW ONE'S ATTENTION TO THE MESS.
         XPRNT STAR,133
         XPRNT UPDFILE,131         PRINT AN UPDATE COMPLETION MESSAGE
         XPRNT STAR,133
         XPRNT STAR,133
         B     EOFPRINT            PRINT THE UPDATED LISTS
STOP     DC    H'0'
***********************************************************************
***********************************************************************
******************** INITIALIZES THE LINKS AND LIST HEADS IN A ********
******************** COMPLETELY EMPTY LIST               **************
***********************************************************************
LISTMT   EQU   *
         SR    CLASSREG,CLASSREG
         MVC   P,AVAIL             EMPTY LIST,   INITIALIZE POINTERS
         L     PREG,P
         MVC   PTR,AVAIL
         L     POINTREG,PTR
         LR    NODELINK,AVAILREG
         MVC   AVAIL(4),NAMELINK(POINTREG)         ADVANCE AVAIL
         MVC   NAMELINK(4,AVAILREG),PTR          SET PTR TO FIRST NODE
         MVC   NAME(19,AVAILREG),CARD+1          MOVE NAME IN
         CLI   CARD+20,C'M'        CHECK FOR MALE SEX
         BE    MALEMT              HE IS,  SO GO TO MALEMT
         ST    NODELINK,HDFSEX     SHE ISN'T,  SO DO A FEMALE
         MVC   FSEXLINK(4,AVAILREG),LAMDA        SET THE SEX LINK-LAMDA
         MVI   SEX(AVAILREG),C'F'  PUT A F IN THE SEX FIELD
         B     NUMBMT              NOW GO TO MAGIC NUMBER INSERTER
MALEMT   ST    NODELINK,HDMSEX     STORE THE ADDRESS OF NODE
         MVC   MSEXLINK(4,AVAILREG),LAMDA        SET SEXLINK TO LAMDA
         MVI   SEX(AVAILREG),C'M'  SET SEX FIELD TO A M
NUMBMT   ST    NODELINK,MAGNOR(AVAILREG)         SET DOUBLE LINKS
         ST    NODELINK,MAGNOL(AVAILREG)
         ST    AVAILREG,HDMAGNO    SAVE NODE'S ADDRESS
         MVC   MAGNUM(9,AVAILREG),CARD+21        INSERT MAGIC NUMBER
CLASSMT  LA    CLASSREG,HDCLASS
         MVC   CLASS(2,AVAILREG),CARD+30         INSERT THE CLASS
         MVC   CLASINFO(2,CLASSREG),CARD+30      PUT IN CLASS INDEX
         ST    AVAILREG,CLASSADD(CLASSREG)       PUT ADDRESS IN INDEX
         MVC   CLASSLIK(4,AVAILREG),LAMDA        SET NODE LINK TO LAMDA
CODE1MT  MVC   CODE1(5,AVAILREG),CARD+32         INSERT THE CODE1
CODE2MT  MVC   HDCODE2+1(3),CARD+37  PUT CODE2 IN CODE2 INDEX
         LA    ADVCDE2,HDCODE2     PUT THE ADDRESS IN ADVANCE REGISTER
         ST    NODELINK,CODE2LR(AVAILREG)        SET INITIAL LINKS
         ST    NODELINK,CODE2LL(AVAILREG)
         ST    NODELINK,CODELIK2(ADVCDE2)        PUT ADDRESS IN INDEX
         MVC   CODE2(3,AVAILREG),CARD+37         PUT CODE2 IN NODE
         LR    POINTREG,AVAILREG   UPDATE THE LINKAGE POINTERS
         ST    POINTREG,PTR
         L     AVAILREG,AVAIL
         B     INIREAD             GET THE NEXT FILE
OVERFLOW XPRNT NOROOM,126          PRINT ERROR MESSAGE
         DC    H'0'                TERMINATE WITH A SOC-1
***********************************************************************
SEXFIND  EQU   *
***********************************************************************
******************** CALLS THE LINKING SUBROUTINES AND   **************
******************** DETERMINES THE STATE OF OPERATION   **************
***********************************************************************
         CALL  FINAPLAC            LINK THE NAME FIELD
         CLI   FLAG,C'1'           CHECK STATE OF FLAG
         BE    INIREAD
         L     PREG,P              RESET FRONT POINTER
         L     POINTREG,PTR        RESET THE END OF LIST POINTER
         CALL  SEXLINK             CALL MY SEX LINKER
         CALL  MAG#LINK            CALL MY MAGIC NUMBER LINKER
         CALL  CLASLINK            LINK THE CLASS FIELD
         CALL  COD2LINK            CALL MY CODE2 LINKER
         L     AVAILREG,AVAIL      UPDATE THE POINTERS AND REGISTERS
         LA    ADVCDE2,HDCODE2     RESET ADVANCE REGISTER
         CLI   STATFLAG,C'1'       SEE IF IN UPDATE STATE
         BE    UPDATEER            YES,  SO GO TO UPDATE
         B     INIREAD             GET THE NEXT CARD
         LTORG
***********************************************************************
MOVER    XGO
***********************************************************************
*            INSERT ALL INFORMATION FROM THE CARD INTO STORAGE
***********************************************************************
         MVC   NAME(19,AVAILREG),CARD+1
         MVC   SEX(1,AVAILREG),CARD+20
         MVC   MAGNUM(9,AVAILREG),CARD+21
         MVC   CLASS(2,AVAILREG),CARD+30
         MVC   CODE1(5,AVAILREG),CARD+32
         MVC   CODE2(3,AVAILREG),CARD+37
         XBACK
***********************************************************************
***********************************************************************
******************** LINKS THE NAME FIELD IN CIRCULAR LIST ************
***********************************************************************
FINAPLAC XGO
         CLC   NAME(19,AVAILREG),NAME(POINTREG)   COMPARE THE NAMES
         BE    OOPS                IF THEY ARE EQUAL, THEN DOUBLE ENTRY
         BH    SETNALK
         L     POINTREG,NAMELINK(POINTREG)       SET TO NEXT NODE
         B     NWCHECK
NWCHECK  EQU   *
         CLC   NAME(19,AVAILREG),NAME(POINTREG)   COMPARE THE NAMES
         BL    FIRST
         B     INCRMNT
INCRMNT  L     POINTREG,NAMELINK(POINTREG)       SET TO NEXT NODE
         CLC   NAME(19,AVAILREG),NAME(POINTREG)   COMPARE THE NAMES
         BL    BEFORE1             FIND THE PRECEEDING NAME NODE
         B     INCRMNT
BEFORE1  ST    POINTREG,TEMPNAME   SAVE THE NEXT NODE > ADDRESS
         LR    POINTREG,PREG       SET POINTER TO THE BEGINNING OF LIST
FOR1LOOP CLC   NAMELINK(4,POINTREG),TEMPNAME     FIND ONE BEFORE
         BE    RESET               WHEN FOUND GO AND LINK IT
         L     POINTREG,NAMELINK(POINTREG)       ADVANCE POINTER
         B     FOR1LOOP            TRY AGAIN,  PLEASE
FIRST    EQU   *
         L     PREG,P              RESET THE FIRST POINTER
         L     POINTREG,PTR        RESET THE POINTER REGISTER
         ST    AVAILREG,NAMELINK(POINTREG)       LINK BETWEEN
         ST    PREG,NAMELINK(AVAILREG)           LINK TO LAST FIRST
         ST    AVAILREG,P          UPDATE THE FIRST POINTER
         B     NAMEBACK            LEAVE
RESET    MVC   NAMELINK(4,AVAILREG),NAMELINK(POINTREG)
         ST    AVAILREG,NAMELINK(POINTREG)
         B     NAMEBACK            LEAVE
SETNALK  MVC   NAMELINK(4,AVAILREG),NAMELINK(POINTREG)
         ST    AVAILREG,NAMELINK(POINTREG)
         ST    AVAILREG,PTR
         B     NAMEBACK
OOPS     EQU   *
         MVC   AGAINAME(19),CARD+1
         XPRNT DOUBENTR,125
         MVI   FLAG,C'1'           SET THE FLAG FOR DOUBENTRY
         B     NAMEBACK            LEAVE
STORADD  ST    POINTREG,NMADSTOR
NAMEBACK EQU   *
         XBACK
***********************************************************************
******************** LINKS THE SEX FIELD IN A LIST  *******************
***********************************************************************
SEXLINK  XGO
         LR    NODELINK,AVAILREG   SET NODELINK REGISTER FOR LINKING
         CLI   SEX(AVAILREG),C'M'  IS IT A MALE ??
         BE    CHCHDM              YES,  CHECK HDMSEX
         CLI   SEX(AVAILREG),C'F'  SEE IF A FEMALE
         BE    CHCHDF              YES IT IS
         B     AWHAT               WHAT OR WHO IS IT???
CHCHDM   CLC   HDMSEX,LAMDA        SEE IF FIRST MALE
         BE    SETHDM              YES,  SO SET HDMSEX
         L     R4,HDMSEX           NO,  SO LOAD THE ADDRESS INTO R4
         LA    R4,MSEXLINK(R4)     SET R4 TO THE LINK OF THE NEXT MALE
SEXLOOPM CLC   0(4,R4),LAMDA       FIND THE LAST MALE
         BE    INSETMSX            FOUND SO LINK NEW ENTRY
         L     R4,0(R4)            NOT FOUND--->UPDATE ADDRESS
         LA    R4,MSEXLINK(R4)     SET R4 TO THE LINK OF THE NEXT MALE
         B     SEXLOOPM            TRY AGAIN
INSETMSX ST    NODELINK,0(R4)      LINK IN THE NEW ENTRY
         MVC   MSEXLINK(4,NODELINK),LAMDA
         B     SEXBACK             FINISHED SO LEAVE
SETHDM   ST    NODELINK,HDMSEX     SET MALE INDEX
         MVC   MSEXLINK(4,NODELINK),LAMDA        SET NODE LINK TO LAMDA
         B     SEXBACK             FINISHED, SO LEAVE
CHCHDF   CLC   HDFSEX,LAMDA        SEE IF FIRST FEMALE
         BE    SETHDF              YES,  SET THE FEMALE INDEX
         L     R4,HDFSEX           NO,  FIND THE LAST FEMALE
         LA    R4,FSEXLINK(R4)     SET R4 TO THE LINK OF  NEXT FEMALE
SEXLOOPF CLC   0(4,R4),LAMDA       IS THIS THE LAST FEMALE???
         BE    INSETFSX            YES,,  INSERT AND LINK HER
         L     R4,0(R4)            NOT FOUND--->UPDATE ADDRESS
         LA    R4,FSEXLINK(R4)     SET R4 TO THE LINK OF NEXT FEMALE
         B     SEXLOOPF            TRY AGAIN
SETHDF   ST    NODELINK,HDFSEX     SET THE FEMALE SEX INDEX
         MVC   FSEXLINK(4,NODELINK),LAMDA        SET NODE LINK TO LAMDA
         B     SEXBACK             NOW LEAVE
INSETFSX ST    NODELINK,0(R4)      SET LINK TO NEW FEMALE
         MVC   FSEXLINK(4,NODELINK),LAMDA        SET HER LINK TO LAMDA
         B     SEXBACK             LEAVE
AWHAT    MVC   WHATSEX(19),NAME(AVAILREG)        MOVE THE NAME IN
         XPRNT NOSEX,131
SEXBACK  EQU   *
         XBACK
***********************************************************************
******************** LINKS THE MAGIC NUMBER IN A DOUBLY  **************
******************** LINKED CIRCULAR LIST                **************
***********************************************************************
MAG#LINK XGO
         L     MAGNOREG,HDMAGNO    SET # REGISTER TO THE FIRST NUMBER
         CLC   MAGNUM(9,AVAILREG),MAGNUM(MAGNOREG)    COMPARE 1ST ORDER
         BL    NEWFIRST            LESS THAN,  GO TO NEWFIRST
         B     MAGCHECK
MAG#LOOP L     MAGNOREG,MAGNOR(MAGNOREG)         UPDATE ADDRESS
         CLC   MAGNUM(9,AVAILREG),MAGNUM(MAGNOREG)   COMPARE FOR ORDER
         BL    MAG#INST            IT <,  SO LINK AND INSERT
MAGCHECK CLC   MAGNOR(4,MAGNOREG),HDMAGNO        SEE IF LAST ONE
         BE    LASTONE
         BNE   MAG#LOOP
LASTONE  MVC   MAGNOR(4,AVAILREG),MAGNOR(MAGNOREG)
         ST    MAGNOREG,MAGNOL(AVAILREG)
         ST    AVAILREG,MAGNOR(MAGNOREG)
         L     MAGNOREG,MAGNOR(AVAILREG)
         ST    AVAILREG,MAGNOL(MAGNOREG)
         B     MAG#OUT
MAG#INST ST    MAGNOREG,MAGNOR(AVAILREG)
         MVC   MAGNOL(4,AVAILREG),MAGNOL(MAGNOREG)
         ST    AVAILREG,MAGNOL(MAGNOREG)              SET LINKS
         L    MAGNOREG,MAGNOL(AVAILREG)
         ST    AVAILREG,MAGNOR(MAGNOREG)
         B     MAG#OUT             LEAVE
NEWFIRST ST    AVAILREG,HDMAGNO    SET INDEX TO FIRST NUMBER
         MVC   MAGNOL(4,AVAILREG),MAGNOL(MAGNOREG)
         ST    MAGNOREG,MAGNOR(AVAILREG)
         ST    AVAILREG,MAGNOL(MAGNOREG)
         L     MAGNOREG,MAGNOL(AVAILREG)
         ST    AVAILREG,MAGNOR(MAGNOREG)
         B     MAG#OUT             LEAVE
MAG#OUT  EQU   *
         XBACK
***********************************************************************
******************** LINKS THE CLASS FIELD IN A LIST     **************
***********************************************************************
CLASLINK XGO
         LA    CLASSREG,HDCLASS    RESET THE CLASS REGISTER
CLASCHEC CLC   0(8,CLASSREG),PLUSES  SEE IF INDEX IS FULL
         BE    NOCLASPE
         CLC   0(8,CLASSREG),ZEROS   SEE IF EMPTY SPACE IS PRESENT
         BE    INSTCLAS
         CLC   CLASINFO(2,CLASSREG),CLASS(AVAILREG)     IS IT A OLD ONE
         BE    NOWCLAIN            YES,  SO INSERT
         LA    CLASSREG,8(CLASSREG)  INCREMENT CLASS REGISTER
         B     CLASCHEC
NOCLASPE MVC   CLASFILE(19),NAME(AVAILREG)       MOVE NAME INTO CLASFLE
         XPRNT NCLASPCE,113
         XPRNT CLASFILE+19,131
         ST    AVAILREG,AVAIL      UNSET ADVANCED AVAIL
         DC    H'0'                TERMINATE WITH A SOC---1
INSTCLAS MVC   CLASINFO(2,CLASSREG),CLASS(AVAILREG)    PUT IN INDEX
         ST    AVAILREG,CLASSADD(CLASSREG)       PUT ADDRESS IN INDEX
         MVC   CLASSLIK(4,AVAILREG),LAMDA        SET NODE LINK TO LAMDA
         B     CLASBACK            LEAVE
NOWCLAIN L     R3,CLASSADD(CLASSREG)   INITIALIZE R3
CLASLOOP CLC   CLASSLIK(4,R3),LAMDA              SEE IF LAST ONE
         BE    EARCLASS            YES,  SO NOW INSERT
         L     R3,CLASSLIK(R3)     UPDATE SEARCH ADDRESS
         B     CLASLOOP            TRY AGAIN
EARCLASS ST    AVAILREG,CLASSLIK(R3)   SET LAST NODE TO NEW NODE ADDRES
         MVC   CLASSLIK(4,AVAILREG),LAMDA        SET NODE LINK TO LAMDA
         B     CLASBACK            LEAVE
CLASBACK EQU   *
         XBACK
***********************************************************************
***********************************************************************
******************** LINKS THE CODE2 FIELDS IN A DOUBLY  **************
******************** LINKED CIRCULAR LIST                **************
***********************************************************************
COD2LINK XGO
CDECHECK CLC   1(3,ADVCDE2),PLUSES SEE IF CODE2 INDEX IS FULL
         BE    NOSPACE             IT IS,  PRINT AN ERROR MESSAGE
         CLC   1(3,ADVCDE2),ZEROS  IS IT A NEW CODE ?????
         BE    INSTCOD2            YES,  SO INSERT IT IN THE INDEX
         CLC   1(3,ADVCDE2),CODE2(AVAILREG)      IS IT A NEW CODE ??
         BE    NOWINCD2            NO, SO PUT WITH OLD
         LA    ADVCDE2,8(ADVCDE2)  KEEP LOOKING
         B     CDECHECK
NOSPACE  MVC   CD2FILE(19),NAME(AVAILREG)        MOVE FOR OUTPUT
         XPRNT CD2SPACE,123
         ST    AVAILREG,AVAIL      UNSET THE NEW AVAIL ADDRESS
         DC    H'0'                TERMINATE WITH A SOC--1
INSTCOD2 MVC   1(3,ADVCDE2),CODE2(AVAILREG)      PUT CODE2 IN INDEX
         ST    AVAILREG,CODELIK2(ADVCDE2)        SET LINKS
         ST    AVAILREG,CODE2LL(AVAILREG)
         ST    AVAILREG,CODE2LR(AVAILREG)
         B     CD#2OUT             LEAVE
NOWINCD2 L     ADVCDE2,CODELIK2(ADVCDE2)         POINTS TO FIRST CODE2
         ST    ADVCDE2,TEMPCOD2    STORE FOR COMPARISON
CD2LOOP  CLC   TEMPCOD2,CODE2LR(ADVCDE2)         FIND LAST SIMILIAR CD2
         BE    INCODE2             FOUND!!!!!
         L     ADVCDE2,CODE2LR(ADVCDE2)          NO,  LOOK AGAIN
         B     CD2LOOP
INCODE2  EQU   *
         MVC   CODE2LR(4,AVAILREG),CODE2LR(ADVCDE2)      SET LINKS
         ST    AVAILREG,CODE2LR(ADVCDE2)
         ST    ADVCDE2,CODE2LL(AVAILREG)
         L     ADVCDE2,TEMPCOD2    RESET CODE2 INDEX REGISTER
         ST    AVAILREG,CODE2LL(ADVCDE2)
         B     CD#2OUT             LEAVE
CD#2OUT  EQU   *
         XBACK
***********************************************************************
***********************************************************************
******************** FINDS THE SAME NAME AND THE ONE     **************
******************** BEFORE FOR DELETION OR MODIFICATION  *************
***********************************************************************
SAMENAME XGO
         LA    AVAILREG,FAKENODE   SET AVAILREG TO FAKE NODE ADDRESS
         MVC   NAME(19,AVAILREG),CARD+1          MOVE NAME ITO FAKE NOD
         LR    NODELINK,PREG       SET NODELINK TO FIRST NODE IN LIST
         CR    PREG,POINTREG       SEE IF LAST NODE
         BE    LASTNODE            YES IT IS
SAMELOOP CLC   NAME(19,AVAILREG),NAME(NODELINK)
         BE    CHEKPT              IF =,CHECK FOR POSITION IN LIST
         L     NODELINK,NAMELINK(NODELINK)       NOT =, SO COMPARE NEXT
         CR    PREG,NODELINK       IS IT IN THE LIST??
         BE    AHA                 NO IT IS NOT IN THE LIST
         B     SAMELOOP            COMPARE AGAIN
CHEKPT   ST    NODELINK,NMADSTOR   SAVE THE ADDRESS OF THE NODE-EQUAL
         CR    PREG,NODELINK       IS IT THE FIRST NODE ??
         BE    DELFIRST            YES
         CR    POINTREG,NODELINK   IS IT THE LAST NODE??
         BE    DELELAST            YES
         B     FINDBFOR            NO SPECIAL POSITION SO JUST FIND 1B4
FINDBFOR L     NODELINK,NAMELINK(NODELINK)     TRY NEXT NODE
         CLC   NAMELINK(4,NODELINK),NMADSTOR      SEE IF ONE B4
         BE    BEFOUND             THIS IS THE ONE!!
         B     FINDBFOR            TRY AGAIN
DELFIRST MVI   DFFLAG,C'1'         SET A FLAG
         B     SAMEBACK            LEAVE
DELELAST MVI   DFFLAG,C'2'         SET FLAG AND FIND ONE BEFORE
         B     FINDBFOR
LASTNODE ST    NODELINK,NMADSTOR   SAVE ADDRESS
         MVI   DFFLAG,C'3'         SET FLAG
         B     SAMEBACK            LEAVE
BEFOUND  ST    NODELINK,TEMPNAME   SAVE ADDRESS OF NODE BEFORE
         B     SAMEBACK            LEAVE
AHA      MVC   MICFIN(19),NAME(AVAILREG)
         XPRNT NOFILE,133          PRINT MESSAGE OF NOT IN LIST
         MVI   DFFLAG,C'4'         SET FLAG
SAMEBACK EQU   *
         XBACK
***********************************************************************
******************** DELETES THE NAME FIELD               *************
***********************************************************************
DNL      XGO
         L     NODELINK,TEMPNAME   SET TO NAME B4
         L     R4,NMADSTOR         SET TO THE NODE
         MVC   NAMELINK(4,NODELINK),NAMELINK(R4)     DELETE THE NAME
         XBACK
***********************************************************************
******************** DELETES THE SEX FIELD               **************
***********************************************************************
DSL      XGO
         L     NODELINK,NMADSTOR   SET TO THE NODE
         CLI   SEX(NODELINK),C'M'  SEE IF A MALE
         BE    DM                  YES, SO WORK ON MALE LIST
         L     R4,HDFSEX           NO SO IT IS A FEMALE
CFSEX    CR    R4,NODELINK         IS SHE THE LAST FEMALE??
         BE    CHECKITF            SEE IF LAST NODE IN SUBLIST
         C     NODELINK,FSEXLINK(R4)   SEE IF THE END FEMALE
         BE    LINKARF             YES, DELINK HER
         L     R4,FSEXLINK(R4)     NO, SO TRY NEXT LINKED NODE
         B     CFSEX               TRY AGAIN
DM       L     R4,HDMSEX           SET TO ADDRESS IN LIST HEAD
         CR    NODELINK,R4         SEE IF LAST MALE
         BE    CHECKITM            IS IT THE LAST 1 IN SUBLIST ???
CMSEX    C     NODELINK,MSEXLINK(R4)         SEE IF END MALE
         BE    LINKARM             YES!!
         L     R4,MSEXLINK(R4)     NO---SET R4 TO NEXT LINKED MALE
         B     CMSEX               TRY AGAIN
LINKARM  MVC   MSEXLINK(4,R4),MSEXLINK(NODELINK)   LINK AROUND
         B     DSLBACK
THATSITF MVC   HDFSEX,LAMDA
         B     DSLBACK
THATSITM MVC   HDMSEX,LAMDA        SET LIST HEAD TO LAMDA
         B     DSLBACK
CHECKITF CLC   FSEXLINK(4,NODELINK),LAMDA        LAST ONE ???
         BE    THATSITF            YES SO SET HDFSEX TO LAMDA
         MVC   HDFSEX(4),FSEXLINK(NODELINK)      NO SO SET THIS IN HDFS
         B     LINKARF             NOW DELETE
CHECKITM CLC   MSEXLINK(4,NODELINK),LAMDA        SEE IF LAST ONE
         BE    THATSITM
         MVC   HDMSEX(4),MSEXLINK(NODELINK)      SO SET THE MALE LIST H
         B     LINKARM             NOW DELETE
LINKARF  MVC   FSEXLINK(4,R4),FSEXLINK(NODELINK)    LINK AROUND
DSLBACK  XBACK
***********************************************************************
******************** DELETES THE MAGIC NUMBER FIELD      **************
***********************************************************************
DM#L     XGO
         L     R4,NMADSTOR         SET TO NODE
         L     NODELINK,NMADSTOR   ALSO SET TO THE NODE
         L     NODELINK,MAGNOR(NODELINK)         SET TO THE RIGHT LINK
         L     R4,MAGNOL(R4)       SET TO THE LEFT LINK
         CLC   HDMAGNO(4),NMADSTOR SEE IF FIRST ONE
         BE    SETHDMAG            YES,  SO SET HDMAGNO
SETML    ST    NODELINK,MAGNOR(R4) LINK AROUND
         ST    R4,MAGNOL(NODELINK) LINK AROUND
         B     DM#LBACK
SETHDMAG ST    NODELINK,HDMAGNO    SET THE MAGIC # LIST HEAD
         B     SETML               NOW DELETE
DM#LBACK EQU   *
         XBACK
***********************************************************************
******************** DELETES THE CLASS FIELD             **************
***********************************************************************
DCLASS   XGO
         L     NODELINK,NMADSTOR   SET TO THE NODE
         LA    R4,HDCLASS+2        SET R4 TO INFO FEILD OF CLASS HEAD
DCLASLOP LR    R3,R4               SAVE FOR LATER
         CLC   CLASS(2,NODELINK),0(R4)           SEE IF OF SAME CLASS
         BE    NOWTLINK            IF OF SAME CLASS , THEN FIND NODE
         LA    R4,8(R4)            SET TO NEXT CLASS FIELD
         B     DCLASLOP
NOWTLINK L     R4,2(R4)            SET TO THE ADDRESS OF FIRST CLNODE
         CR    R4,NODELINK         SEE IF LAST ONE
         BE    CHECKITC            SEE IF LAST ONE LEFT
DLINLOOP C     NODELINK,CLASSLIK(R4)     IS THIS THE NODE BEFORE???
         BE    LINKARC             IF YES, THEN LINK AROUND
         L     R4,CLASSLIK(R4)     NO, SO TRY NEXT LINKED NODE
         B     DLINLOOP            TRY AGAIN
THATSALL MVC   0(6,R3),ZEROS       RESET CLASS LIST HEAD
         B     DC#LBACK            NOW LEAVE
CHECKITC CLC   CLASSLIK(4,NODELINK),LAMDA        IS IT THE LAST ONE
         BE    THATSALL            YES IT IS THE LAST ONE OF THIS CLASS
         MVC   2(4,R3),CLASSLIK(NODELINK)        UPDATE THE CLASS INDEX
LINKARC  MVC   CLASSLIK(4,R4),CLASSLIK(NODELINK)     LINK AROUND
DC#LBACK EQU   *
         XBACK
***********************************************************************
******************** DELETES THE CODE2 FIELD             **************
***********************************************************************
DC#2L    XGO
         LA    R4,HDCODE2+1        SET TO INFO FIELD OF CODE2 INDEX
         L     NODELINK,NMADSTOR   SET TO THE NODE
FINDCD#2 CLC   CODE2(3,NODELINK),0(R4)           SEE IF OF SAME CODE2
         BE    CD#FOUND            YES,? THEN FIND LINK
         LA    R4,8(R4)            SEE IF IT IS THE NEXT ONE
         LR    R3,R4               SAVE FOR LATER
         B     FINDCD#2
CD#FOUND L     R4,3(R4)            LOAD THE FIRST SIMILAR ADDRESS IN R4
         CR    R4,NODELINK         SEE IF LAST ONE
         BE    CHECKC#2            SEE IF THE LAST ONE IN SUBLIST
         LR    R4,NODELINK         SET R4
         L     NODELINK,CODE2LR(NODELINK)        LINK AROUND
         L     R4,CODE2LL(R4)
         ST    NODELINK,CODE2LR(R4)    SET LINKS AROUND
         ST    R4,CODE2LL(NODELINK)    SET LINKS AROUND
         B     C#2LBACK            LEAVE
CHECKC#2 CLC   3(4,R3),CODE2LR(NODELINK)         IS IT THE LAST ONE
         BE    THATACD2            YES?  GO SET LIST HEAD
         MVC   3(4,R3),CODE2LR(NODELINK)         UPDATE THE LIST HEAD
         B     C#2LBACK
THATACD2 MVC   0(7,R3),MINUS       RESET THE LIST HEAD TO THE NULL LINK
C#2LBACK EQU   *
         XBACK
***********************************************************************
CONSTANT CSECT
OPTAB    TRTAB 16,TABLE=(A,4,D,8,M,12)
OPOP     TRTAB 28,TABLE=(1,4,2,8,3,12,4,16,5,20,6,24)
FEMFLAG  DC    C'0'
DFFLAG   DC    C'0'
STATFLAG DS    C
FLAG     DS    C
BLANKS   DC    CL72' '
LAMDA    DC    CL10'-1-1-1-1-1'
STARS    DC    CL19'*******************'
MINUS    DC    CL8'--------'
PLUSES   DC    CL8'++++++++'
CD2HEAD  DC    C'1',49C'*',CL33'THE LIST OF SIMILIAR CODE2 FIELDS',49C'1
               *'
MAGHEAD  DC    C'1',38C'*',CL53'THE LIST ACCORDING TO MAGIC NUMBER IN A1
               SCENDING ORDER',38C'*'
FEMHEAD  DC    C'1',47C'*',CL35'THE LIST OF ALL FEMALES IN THE FILE',491
               C'*'
NFEM     DC    C'2',44C'/',CL43'THE LIST OF FEMALES ON FILE IS NONEXIST1
               ANT',44C'/'
MALEHEAD DC    C'1',47C'*',CL33'THE LIST OF ALL MALES IN THE FILE',47C'1
               *'
NMALE    DC    C'2',45C'/',CL40'THE LIST OF MALES ON FILE IN NONEXISTAN1
               TANT',45C'/'
CLASHEAD DC    C'1',40C'*',CL46'THE LIST OF PEOPLE WITH IDENTICAL CLASS1
                FIELDS',40C'*'
NAMEHEAD DC    C'1',40C'*',CL43'THE LIST IN ALPHABETICAL ORDER BY LAST 1
               NAME',40C'*'
NAMEDUMP DC    C'0'
         DS    CL39
SPECNAME DC    C'0',17C' ',CL4'NAME',21C' ',CL3'SEX',13C' '
         DC    CL12'MAGIC NUMBER',13C' ',CL5'CLASS',13C' ',CL5'CODE1',11
               3C' ',CL5'CODE2',15C' '
FILES    DC    133C' '
DOUBENTR DC    C'+',5C'/',CL11'THE FILE OF',3C' '
AGAINAME DS    CL19
         DC    3C' ',CL56'IS ALREADY IN THE ORIGINAL FILE SO IT HAS NOT1
                BEEN ADDED',8C'*',CL15'CHECK YOUR DATA',7C'*'
NCLASPCE DC    C'0',10C'*',CL81'THE SPACE FOR CLASS INDEXING IS EXHAUST1
               ED, THE FILE BEING READ IN AT OVERFLOW WAS',3C' '
CLASFILE DS    CL19
         DC    C' ',40C'*',CL50'PROBABLE CAUSE---CLASS IN DATA OTHER TH1
               AN 01--->13',40C'*'
CD2SPACE DC    C'1',10C'*',CL93'THE SPACE FOR CODE2 INDEXING IS EXHAUST1
               ED, THE FILE BEING READ IN AT THE TIME OF OVERFLOW WAS'
CD2FILE  DS    CL19
         DC    8C'*'
NOROOM   DC    C' ',20C'*',CL5'ERROR',15C'*',CL50'THOU LAVS RUNNETH OVE1
               R AVAILABLE ALLOCATED STORAGE',35C'*'
NOSEX    DC    C'2',15C'/',CL24'THE PERSON WHOSE NAME IS',3C' '
WHATSEX  DS    CL19
         DC    3C' ',CL70'IS OF THE NEUTER SEX, THEREFORE HAS NOT BEEN 1
               ADDED TO THE ORIGINAL LIST',15C'/'
NOFILE   DC    C'2',24C'?',CL11'THE FILE OF',3C' '
MICFIN   DS    CL19
         DC    3C' ',CL48'CAN NOT BE DELETED BECAUSE IT IS NOT IN THE L1
               IST',24C'?'
GOODBYE  DC    48C' ',CL36'THE LIST HAS BEEN EMPTIED COMPLETELY',47C' '
ERFIELD  DC    C' ',CL5'ERROR',7C'-',CL79'THE FOLLOWING FILE TO BE MODI1
               FIED CONTAINS AN INVALID FIELD MODIFICATION NUMBER',5C'*2
               ',CL27'THIS CARD HAS BEEN BYPASSED',6C'-'
ERBLANK  DC    C' ',25C'*',CL5'ERROR',3C'-',CL70'THE FOLLOWING FILE HAS1
                BEEN BYPASSED DUE TO A BLANK MODIFICATION FIELD',25C'*'
FDMOD    DC    C'-',25C'*',CL24'THE FILE NOW MODIFIED IS',81C'*'
WROP     DC    C'2',17C'/',CL5'ERROR',3C'-',CL88'AN UNDEFINED OPERATION1
                WAS SPECIFIED IN COL. 42, THE CARD THAT FOLLOWS HAS BEE2
               N BYPASSED',17C'/'
UPDFILE  DC    C'0',35C' ',CL60'THE UPDATING AND MODIFICATION OF THE LI1
               ST HAS BEEN COMPLETED',35C' '
FCLASOUT DC    C'1',35C'*',CL66'THE FOLLOWING LIST CONTAINS PERSONS WHO1
               SE CLASS IS GREATER THAN 07',30C'*'
NOCHIC   DC    C'0',56C'!',CL18'THIS LIST IS EMPTY',56C'!'
FFEMPRIT DC    C'1',25C'*',CL69'THE FOLLOWING LIST CONTAINS ALL GIRLS W1
               ITH MAGIC NUMBERS GREATER THAN',3C' ',9C'5',25C'*'
STAR     DC    C' ',132C'*'
ZEROS    DC    CL10'0000000000'
FAKENODE DC    CL72' '
SEVEN    DC    CL2'07'
FIVES    DC    CL9'555555555'
         DS    0F
NODLKST  DC    CL4'0000'
STOREIN  DC    CL4'0000'
HDMAGNO  DC    CL4'-1-1'
HDFSEX   DC    CL4'-1-1'
HDMSEX   DC    CL4'-1-1'
HDCLASS  DC    25CL8'00000000'
         DC    CL8'++++++++'
HDCODE2  DC    25CL8'00000000'
HDCODEND DC    CL8'++++++++'
CARD     DS    CL80
P        DS    CL4
PTR      DC    CL4'0000'
AVAIL    DC    CL4'0000'
TEMPCOD2 DS    F
AVADST   DC    CL4'0000'
NMADSTOR DC    CL4'0000'
TEMPNAME DC    CL4'0000'
LAVS     DC    200CL72' '
         DC    CL10'-1-1-1-1-1'
         END
$ENTRY
6HADDEN JOHN DANIEL M226621106GRCMPSCS25CMPSCS25404 01             33570
6HELSEL BARBARA JEANF16242231309CMPSCS25CMPSCS25404 01             33570
6QUAMMEN GERALD A   M19940708508CMPSCS25CMPSCS25404 01             33570
6RUSSONIELLO VINCENTM17842659008CMPSCS25CMPSCS25404 01             33570
6HICKS ROBERT W     M19036492309CMPSCS25CMPSCS25404 01             33570
6HOLZER PAUL LOUIS  M17038543507CMPSCS25CMPSCS25404 01             33570
6HOSTETLER CLETUS L M280267240GRCMPSCS25CMPSCS25404 01             33570
6SCHOKA ANDREW M    M157302377GRN DEGY30CMPSCS25404 01             33570
6SEIFRIT GEORGE EARLM20038844410CMPSCS25CMPSCS25404 01             33570
6TURNBULL MICHAEL G M17638198509CMPSCS25CMPSCS25404 01             33570
6WARRICK THOMAS R   M178407063GRCMPSCS25CMPSCS25404 01             33570
6WEISSER PAUL T     M20442083508CMPSCS25CMPSCS25404 01             33570
6WEISBERG ARVIN MILEM16440250809CMPSCS25CMPSCS25404 01             33570
6RIGHI EARL THOMAS JM20840146308CMPSCS25CMPSCS25404 01             33570
6JOHN RHYS DAVID    M19038036109CMPSCS25CMPSCS25404 01             33570
6COPE CLARENCE GILL M18140918308CMPSCS25CMPSCS25404 01             33570
6DIGGINS CHARLES F  M19242162708CMPSCS25CMPSCS25404 01             33570
6ELLIOTT WILLIAM IIIM080320606GRCMPSCS25CMPSCS25404 01             33570
6HUNDY MICHAEL J    M172328223AEADJ  Y05CMPSCS25404 01             33570
6RIVELL RICHARD     M14036301710CMPSCS25CMPSCS25404 01             33570
6LANGE BETTYLOU     F053403527GRCMPSCS25CMPSCS25404 01             33570
6CLARK RICHARD A    M329383268GRCMPSCS25CMPSCS25404 01             33570
6MOON BYRON JOHN II M18640627609CMPSCS25CMPSCS25404 01             33570
6BANGE CLAIR JOHN JRM174365058GRCMPSCS25CMPSCS25404 01             33570
6NELSON KEVIN ERIK  M18138124008CMPSCS25CMPSCS25404 01             33570
6KALIN RICHARD STUARM479408587GRCMPSCS25CMPSCS25404 01             33570
6MULLAN KATHLEEN K  F17242864808CMPSCS25CMPSCS25404 01             33570
6AUKER CHARLES W    M189360098UESC   S90CMPSCS25404 01             33570
6TILEY JANE LOUISE  F04838578908CMPSCS25CMPSCS25404 01             33570
6NICKESON KENNETH E M18442360908CMPSCS25CMPSCS25404 01             33570
6COCHRAN JOHN L     M17442164008CMPSCS25CMPSCS25404 01             33570
6STEWART BARBARA JEAF17042446211MATH S30CMPSCS25404 01             33570
6RAPHAEL BARRY S    M046346440ADADJ  Y05CMPSCS25404 01             33570
6CARELLI DENNIS JOHNM16042669808CMPSCS25CMPSCS25404 01             33570
6NAPOLEON FRANK L   M19240483308CMPSCS25CMPSCS25404 01             33570
6MILFORD MARK TERENCM20338549008CMPSCS25CMPSCS25404 01             33570
6CATON ROBERT GEORGEM16242355511CMPSCS25CMPSCS25404 01             33570
6SKERCHOCK JOHN A   M16442239911CMPSCS25CMPSCS25404 01             33570
6STALTER IRA A JR   M184366253GRCMPSCS25CMPSCS25404 01             33570
6STOCKMAN GEORGE C  M191348516GRCMPSCS25CMPSCS25404 01             33570
6EDGAR LUCINDA ANN  F208367961AEADJ  Y05CMPSCS25404 01             33570
6BECKER THOMAS JOSEPM18340977508CMPSCS25CMPSCS25404 01             33570
6LEARMONT ELIZABETH F392463876GRCMPSCS25CMPSCS25404 01             33570
6EICHHOLTZ ROBERT JRM18838547008CMPSCS25CMPSCS25404 01             33570
6LINZ PAUL RICHARD  M19336714513SOC  L92CMPSCS25404 01             33570
6KENEPP PAUL L      M185303508GECMPSCS25CMPSCS25404 01             33570
6WILSON DEBORAH     F20738510909CMPSCS25CMPSCS25404 01             33570
6BLACK SANDRA       F18638210910ADVT L01CMPSCS25404 01             33570
6MACEYUNAS PAUL J   M041389959GRCMPSCS25CMPSCS25404 01             33570
6BLAKE WILLIAM C    M48158304106E E  G25CMPSCS25404 01             33570
6MAGILL DONALD RAY  M20530675810CMPSCS25CMPSCS25404 01             33570
6MAURER THOMAS A    M210369617GRCMPSCS25CMPSCS25404 01             33570
6MC CALL KEITH R    M18142569105CMPSCS25CMPSCS25404 01             33570
6STUMP WILLIAM HUNTEM17742909608CMPSCS25CMPSCS25404 01             33570
6BRONG DOUGLAS G    M20340141012COUN T01CMPSCS25404 01             33570
6THOMAS GREGORY DALEM17040925808CMPSCS25CMPSCS25404 01             33570
6BENNETT IAN G      M264864999AEADJ  Y05CMPSCS25404 01             33570
6LIPP H ANNE        F18638242907CMPSCS25CMPSCS25404 01             33570
6BLACK KARL DEAN    M523502468GRCD FRJ01CMPSCS25404 01             33570
6BLUNT CHARLES R    M579466035GECMPSCS25CMPSCS25404 01             33570
6OLIVIERI LAURA A   F05138716208CMPSCS25CMPSCS25404 01             33570
6LYLE THOMAS JOSEPH M16242982508CMPSCS25CMPSCS25404 01             33570
6PAULHAMUS RICHARD EM183407013GRCMPSCS25CMPSCS25404 01             33570
6PEARSON MARY WINDERF223721061GRCMPSCS25CMPSCS25404 01             33570
6ELSTON JAY COLLIN  M19436461908CMPSCS25CMPSCS25404 01             33570
6FRY STANLEY B      M161422090AEADJ  Y05CMPSCS25404 01             33570
6GIBBONS JOHN J     M20634189111ZOOL S96CMPSCS25404 01             33570
6GINGERICH JEFFREY ZM17338784114ARCH B10CMPSCS25404 01             33570
6GORE GEORGE ROLAND M18340649710CMPSCS25CMPSCS25404 01             33570
 ******
6LEARMONT ELIZABETH F392463876GRCMPSCS25CMP3CS254567890123         33570
6IAMADUMMYENTRY!!!  M18138124008CMPSCS25CAPSCS25404 01             33570
6STUMP WILLIAM HUNTEM17742909608CMPSCS25CMP2CS254F4 01             33570
6FRY STANLEY B      M161422090AEADJ  Y05CDPSCS25404 01             33570
6LYLE THOMAS JOSEPH M16242982508CMPSCS25CMP1CS254SLYLER THOMAS JOSEPH570
6TILEY JANE LOUISE  F04838578908CMPSCS25CMP4CS254NONE              33570
6BLUNT CHARLES R    M579466035GECMPSCS25CMP4CS254Y0501             33570
*******
$JOB ASSIST MACRO=F
         MACRO
&LABEL   QSAVE &REGS,&BASE,&SA
.*
.*       QSAVE GIVES STANDARD LINKAGE CONVENTIONS FOR A CSECT.
.*
.*       BASE=NUMBER -THIS IS THE BASE REGISTER. DEFAULT IS REGISTER 12
.*                    REGISTER 13,14,15 ARE ILLEGAL
.*       REGS=(CNT1,CNT2) -THESE ARE REGISTERS TO BE SAVED.
.*                    THE DEFAULT VALUE IS 14,12.
.*       SA=VALUE -TAKES CARE OF SAVE AREA NAME AND ITS PROPER LINKAGE
.*                 IF VALUE=NO - THEN THERE IS NO SAVEAREA CREATED.
.*                 IF VALUE=NAME SAVE AREA LINKAGE WILL BE DONE AND
.*                      ITS ADDRESS PLACED IN REGISTER 13.
.*                 IF VALUE=* -SAVE AREA NAME IS FIRST 3 LETTERS OF
.*                      CSECT NAME FOLLOWED BY A UNIQUE NUMBER AND AN
.*                      'S'. THIS IS DEFINED AS GBLC TO BE USED BY
.*                      QRETURN LATER.
.*
.*       &SANAME - SAVE AREA NAME GENERATED IF VALUE=*. USED BY QRETURN
.*       &DISPLT -DISPLACEMENT FOR ST OR STM INSTRUCTIONS.
.*       &REGNUM -REGISTER NUMBER USED TO DETERMINE DISPLACEMENT.
.*       &BASERG -BASE REGISTER IS DEFAULTED TO 12.
.*       &NAME   -CSECT OR LABEL IDENTIFICATION NAME
.*       &NUMBER -LENGTH OF BRANCH AND CSECT IDENTIFICATION NAME.
.*
         GBLC  &SANAME
         LCLA  &DISPLT,&REGNUM,&NUMBER,&BASERG
         LCLC  &NAME
&BASERG  SETA  12
&DISPLT  SETA  12
&REGNUM  SETA  14
.*
.*       DEFINE LABEL IN DC AND BRANCH INSTRUCTIONS.
.*
&LABEL   DS    OH
         USING *,15                TEMPORARY BASE REGISTER.
         AIF   (T'&LABEL EQ '0').NACSECT     IF NO LABEL,USE CSECT NAME
&NAME    SETC  '&LABEL'            IDENTIFICATION NAME =&LABEL
         AGO   .AROUND             BRANCH TO MAKE ID.
.NACSECT AIF   ('&SYSECT' EQ '').CHECK13  NO CSECT,USE NO ID.
&NAME    SETC  '&SYSECT'           ID NAME = NAME OF CSECT.
.AROUND  ANOP
&NUMBER  SETA  6+((K'&NAME+1)/2)*2 LENGTH OF BRANCH
         B     &NUMBER.(,15)       BRANCH AROUND THE ID.
&NUMBER  SETA  &NUMBER
         DC    AL1(&NUMBER),CL&NUMBER'&NAME' DEFINE THE ID NAME .
.*
.*       SET UP THE DISPLACEMENT REQUIRED FOR THE PROPER STORAGE OF
.*       REGISTERS AND THE ST OR STM INSTRUCTIONS.
.*
.CHECK13 AIF   (&REGS(1) NE 13).AGAIN
         MNOTE 0,'**ERROR-REGISTER 13 WAS FIRST REGISTER OF THE PAIR**'
&REGNUM  SETA  14                  WE SHALL USE REGISTER 14 INSTEAD.
         AGO   .GOON               GO ON TO .GOON
.AGAIN   AIF   (&REGS(1) EQ &REGNUM).GOON    GO ON IF REG(1) EQUALS 14
&DISPLT  SETA  &DISPLT+4           DISPLACEMENT IS NOW INCREASED.
&REGNUM  SETA  &REGNUM+1           INCREASE THE REGISTER NUMBER.
         AIF   (&REGNUM NE 16).AGAIN  IF WE HAVE 16 START NOW AT 0
&REGNUM  SETA  0
         AGO   .AGAIN              CONTINUE FOR 0 THROUGH 12
.GOON    AIF   ('&REGS(2)' NE '').PUTSTM    REG(2) NOT NULL GO PUTSTM
         ST    &REGNUM,&DISPLT.(13)  SAVE THIS REGISTER
         AGO   .SAVEIT             GO TO SAVEIT
.PUTSTM  STM   &REGNUM,&REGS(2),&DISPLT.(13)   DO STORE MULTIPLE
.*
.*       GET THE NAME OF THE SAVE AREA PLUS THE POINTERS TO NEW AND
.*       OLD SAVE AREAS. UNIQUE NAME GENERATED IF NO SA VALUE IS
.*       PRESCRIBED.
.*
.SAVEIT  AIF   ('&SA' EQ 'NO').BASERT   NO SA VALUE IS TO BE HAD.
         AIF   ('&SA' EQ '*').CSECTNA   SA=*,GO TO GET A SAVE AREA NAME
&SANAME  SETC  '&SA'                    SAVE AREA NAME IS DEFINED
         AGO   .DOLINK             GO TO SET SAVE AREA POINTERS.
.CSECTNA ANOP
         AIF   ('&SYSECT' EQ '').NULCECT    NULL CSECT
&SANAME  SETC  '&SYSECT'(1,3).'&SYSNDX'.'S' GENERATE SAVE AREA NAME
         AGO   .DOLINK
.NULCECT ANOP
&SANAME  SETC  'SAV&SYSNDX'
.DOLINK  AIF   (&BASE GT 12).CONTIN  SET THE SAVE AREA POINTERS.
&BASERG  SETA  &BASE               WORK REGISTERS FOR SAVE AREA.
.CONTIN  LA    &BASERG,&SANAME     GET SAVE AREA ADDRESS
         ST    &BASERG,8(13)       POINTER TO THE NEW SAVE AREA.
         ST    13,4(&BASERG)       POINTER TO OLD SAVE AREA.
         LR    13,&BASERG          GET THE NEW SAVE AREA.
.*
.*       WE NOW TAKE CARE F
.*       WE NOW TAKE CARE OF THE BASE REGISTER. REGISTERS 13,14,AND 15
.*       ARE INVALID BASE REGISTERS. REGISTER 12 IS DEFAULT VALUE.
.*
.BASERT  AIF   (&BASE GT 12).ERROR2  INVALID BASE REGISTER SPECIFIED.
         AIF   ('&BASE' EQ '').NEWBASE  NO BASE SPECIFIED,USE 12.
&BASERG  SETA  &BASE
.NEWBASE BALR  &BASERG,0                SET UP NEW BASE REGISTER.
         USING *,&BASERG                NEW USING
         DROP  15                  DROP THE TEMPORARY BASE REGISTER.
         AGO   .STOP               BRANCH TO THE END.
.ERROR2  MNOTE 0,'**ERROR INVALID BASE REGISTER 12 IS USED**'
&BASERG  SETA  12                  SET BASE REGISTER TO 12
         AGO   .NEWBASE            GO TO NEWBASE.
.STOP    MEND                      END
        MACRO
&LABEL   QRETURN &REGS,&SA
.*
.*       QRETURN GENERATES STANDARD LINKAGE FOR AN EXIT FROM A CSECT.
.*
.*       REGS=(CNT1,CNT2)  THIS CONTAINS THE REGISTERS TO BE RESTORED.
.*          THE DEFAULT VALUE WILL BE (14,12)
.*       SA=VALUE -THIS CONTROLS THE SAVE AREA LINKAGE AND ITS NAME.
.*          VALUE=NO NO SAVE AREA IS CREATED
.*          VALUE=NAME  THE NAME IS GIVEN TO THE SAVE AREA AND NORMAL
.*             LINKAGE OCCURS.
.*          VALUE=*     A NAME IS GIVEN TO SAVE AREA AND LINKAGE OCCURS
.*
.*       &SANAME -SAVE AREA NAME IF GENERATED (PASSED FROM QSAVE).
.*       &DISPLT -DISPLACEMENT FOR LOAX AND LOAD MULTIPLE INSTRUCTIONS.
.*       &REGNUM -REGISTER NUMBER USED TO DETERMINE DISPLACEMENT.
         GBLC  &SANAME
         LCLA  &DISPLT,&REGNUM
.*
&DISPLT  SETA  12
&REGNUM  SETA  14
&LABEL   DS    OH                  DEFINE THE LABEL
         L     13,4(13)            RESTORE OUR OLD SAVE AREA POINTER.
.*
.*       CHECK FOR THE SAVE AREA. IF NONE,RESTORE REGISTER 13 AND GO
.*       TO STOP
.*
         AIF   ('&SA' NE 'NO').CHECK
         AGO   .STOP
.*
.*       SET THE AMOUNT OF DISPLACEMENT FOR THE LOAD OR LOAD MULTIPLE
.*       INSTRUCTIONS.
.*
.CHECK   AIF   (&REGS(1) NE 13).AGAIN   GO TO AGAIN IF REGS (1) NOT 13.
         MNOTE 0,'**WARNING REGISTER 13 IS PART OF REGISTER PAIR**'
&REGNUM  SETA  14                  NOW WE USE REGISTER 14.
         AGO   .DONE               IGNORE THIS IF REGISTER 13 WAS FIRST
.AGAIN   AIF   (&REGS(1) EQ &REGNUM).DONE   IF REGS(1) IS 14 GO TO DONE
&DISPLT  SETA  &DISPLT+4           INCREMENT THE DISPLACEMENT
&REGNUM  SETA  &REGNUM+1           INCREMENT THE NUMBER REGISTER.
         AIF   (&REGNUM NE 16).AGAIN    IF REGNUM NOT 16 GO TO AGAIN.
&REGNUM  SETA  0                   SET REGNUM TO ZERO
         AGO   .AGAIN              GO TO AGAIN.
.DONE    AIF   ('&REGS(2)' NE '').DOLM  IF REGS(2) NOT ZERO,GO TO DOLM
         L     &REGNUM,&DISPLT.(13)     RESTORE THE ONE REGISTER.
         AGO   .SAAREA
.DOLM    LM    &REGNUM,&REGS(2),&DISPLT.(13) RESTORE ALL THE REGISTERS.
.*
.*       SAVE AREA WITH NAME FROM QSAVE(&SANAME).RETURN TO CALL PROGRAM
.*
.SAAREA  BR    14                  RETURN TO CALL
&SANAME  DC    18F'0'              SAVE AREA IS DEFINED.
         MEXIT
.STOP    BR    14                  RETURN TO CALL
         MEND                      END
         MACRO
&LABEL   QCALL &NAME,&LIST
.*
.*       NAME=NAME OF THE ENTRY
.*       LIST= NAME OF THE ADDRESS LIST.
.*
.*       &NUMBER =THIS IS THE COUNTER TO COUNT NUMBER PARAMETERS IN LIS
.*       &LASTNUM =THIS IS NUMBER OF LAST NUMBER IN LIST.
.*       &IDENTY  =THIS IS THE UNIQUE NAME
.*
         LCLA  &NUMBER,&LASTNUM
         LCLC  &IDENTY
&NUMBER  SETA  1                   SET NUMBER TO 1.
&LASTNUM SETA  ('&LIST
&LABEL   DS    OH                  DEFINE THE LABEL.
.*
.*       THIS TAKES CARE OF PART2 OR JUST AN ENTRY NAME.
.*
         AIF   ('&LIST' EQ '').AR1 THIS CHECKS FOR THE NULL LIST.
.*
.*       THIS TAKES CARE OF PART3 OR AN ENTRY NAME AND ADDRESS LIST
.*       NAME.
.*
         AIF   ('&LIST'(1,1) NE '(').AR2     THIS IS FOR NO PARAMETERS.
.*
.*       THIS TAKES CARE OF PART 1 AND 4. THIS IS AN ENTRY NAME AND AN
.*       ARGUMENT LIST.
.*
         CNOP  0,4                 SET ON A FULL WORD BOUNDARY9
         B     *+&LASTNUM*4+4      DO A BRANCH AROUND THE LIST
&IDENTY  SETC  'PARM&SYSNDX'       THIS GIVES US THE UNIQUE NAME.
.AGAIN   AIF   (&LASTNUM EQ &NUMBER).LASTP
         AIF   (&NUMBER EQ 1).FIRSTP         CHECK FOR FIRST PARAMETER
.FIRSTP  ANOP
&IDENTY  DC    A(&LIST(&NUMBER))   NOT THE LAST PARAMETER.
&IDENTY  SETC  ''                  SET THE IDENTY TO ONE.
&NUMBER  SETA  &NUMBER+1           INCREASE  NUMBER BY 1.
         AGO   .AGAIN              GO TO AGAIN
.LASTP   ANOP
&IDENTY  DC    X'80',AL3 (&LIST(&NUMBER))   THIS DOES THE LAST PARAMER.
.*
.*       THIS DOES PART IS ARGUMENT LIST
.*
         AIF   ('&NAME' EQ '').STOP
.*
.*       THIS DOES PART 4 ENTRY NAME AND ARGUMENT LIST.
.*
         LA    1,&IDENTY           THIS GETS YOU THE PARAMETER LIST ADD
         AGO   .AR2                GO GET THE ENTRY NAME.
.AR1     LA    1,&LIST             GET THE PARAMETER LIST ADDRESS.
.AR2     AIF   ('&NAME' EQ '').ERROR1   THIS CHECKS FOR THE NAME.
         L     15,=V(&NAME)        GET ENTRY POINT ADDRESS WITH V ADCON
         BALR  14,15               BRANCH TO THE SUBPROGRAM.
         AGO   .STOP               BRANCH TO STOP
.ERROR1  MNOTE 0,'**THERE IS NO ENTRY POINT ADDRESS**'
.STOP    MEND                      THIS IS THE END.
MAINPRG  CSECT
         QSAVE
         QCALL SUBX,ADDRX
         QCALL SUBY
GOBACK   QRETURN   SA=*
ADDRX    QCALL ,(MAINPRG,BOBACK)
         LTORG
SUBXCS   CSECT
         ENTRY SUBX,SUBY
SUBX     QSAVE SA=SUBXSA,BASE=11,REGS=(14,11)
         CNOP  2,4
         QCALL SUB1,(SUBX)
         QCALL SUB2
SUBRET   QRETURN SA=SUBXSA,REGS=(14,11)
SUBY     QSAVE SA=NO
         XPRNT =CL50'0************ AT SUBY ************',50
         QRETURN SA=NO
         LTORG
SUB1     CSECT
         QSAVE BASE=13
         QRETURN SA=*
SUB2     CSECT
         QSAVE BASE=15,REGS=(2,12)
         QRETURN SA=*,REGS=(2,12)
         END
$JOB ASSIST MACRO=F
         MACRO
         SETGBL &TRACE=,&LSNAP=,&STSNAP=
         GBLB  &NOTRC,&NOLSNAP,&NOSNAP GLOBALS FOR DEBUG, LISTSNAP,
.*                                   AND STSNAP
&NOTRC   SETB  (T'&TRACE EQ 'O' AND &NOTRC OR '&TRACE' EQ 'OFF')
&NOLSNAP SETB  (T'&LSNAP EQ 'O' AND &NOLSNAP OR 'LSNAP' EQ 'OFF')
&NOSNAP  SETB  (T'&STSNAP EQ 'O' AND &NOSNAP OR '&STSNAP' EQ 'OFF')
         MEND
         EJECT
         MACRO
&LABEL   POP   &HDR,&REG,&END,&LENGTH=48,&MSG=
&LABEL   L     &REG,&HDR .          GET ADDRESS TOP ELEMENT
         AIF   (T'&END EQ 'O').NOTEST  SEE IF SHOULD DO EMPTY TEST
         LTR   &REG,&REG .              TEST FOR NULL LINK
         BZ    &END  .          IF EMPTY LIST, BRANCH OUT
.NOTEST  ANOP
         STM   0,1,POP&SYSNDX.S .    SAVE REGS THAT ARE CHANGED
         L     0,0(&REG) .           GET SECOND TO TOP NODE
         ST    0,&HDR    .           POINT HEAD TO 2ND NODE
         LA    1,&HDR    .           GET ADDRESS OF HEADER
         L     0,4(1) .           GET CURRENT LIST LENGTH
         BCTR  0,0 .              DECREMENT LENGTH BY 1
         ST    0,4(1) .           STORE UPDATED LENGTH
         LM    0,1,POP&SYSNDX.S .    RESTORE REGISTERS
         B     POP&SYSNDX.S+8 .       BRANCH AROUND SAVE AREA
POP&SYSNDX.S DC    2F'0' .           SAVE AREA FOR REGS 0 AND 1
         DEBUG POP,&HDR,&MSG,4(&REG),&LENGTH
         MEND
         SPACE 3
         MACRO
&LABEL   PUTFREE &FRHDR,&REG
&LABEL   MVC   0(4,&REG),&FRHDR .    RETURNED NODE ==> FREE LIST
         ST    &REG,&FRHDR .          FREE LIST HEAD ==> RETURNED NODE
         SPACE 1
         MEND
         EJECT
         MACRO
&LABEL   DELETE &HDR,&REG,&END,&LENGTH=48,&MSG=
&LABEL   STM   14,1,DEL&SYSNDX.S .    SAVE REGS THAT ATE CHANGED
         LR    0,&REG .              LOAD @ OF NODE TO BE DELETED
         LA    1,&HDR    .        LOAD ADDRESS OF LIST HEAD
         L     15,=V(DELETE) .    LOAD ADDR NODE DELETION ROUTINE
         CNOP  2,4 .              FOR ALIGNMENT OF SAVE AREA
         BALR  14,15 .            LINK TO DELETION ROUTINE
         LM    14,1,8(14) .       RELOAD REGISTERS
         B     &END  .          NODE NOT IN LIST, BRANCH OUT
DEL&SYSNDX.S DC    4F'0' .            SAVE AREA FOR REGS 14-1
         LM    14,1,8(14) .       RELOAD REGISTERS FOR NORMAL RETURN
         DEBUG DELETION,&HDR,&MSG,4(&REG),&LENGTH
         SPACE 1
         MEND
         SPACE 2
         MACRO
         SYSGEN &CPU=1,&MEM=64,&IONO=1,&DISKQ=10,&CATNO=1,&JQLOOK=NO
         GBLA  &CPN,&MMS,&ION     # CPU'S, MEM SIZE, # CHANNELS
         GBLA  &DQN,&CAT          SIZE OF DISK QUEUE, # CATEGORY Q'S
         GBLB  &LOOK              TRUE IF INITIATOR MAY LOOK AHEAD
&CPN     SETA  &CPU
&MMS     SETA  &MEM
&ION     SETA  &IONO
&DQN     SETA  &DISKQ
&CAT     SETA  &CATNO
&LOOK    SETB  ('&JQLOOK' EQ 'YES')
         MEND
         SPACE 2
         MACRO
&LABEL   PUTNODE &HDR,&REG,&KEY=4,&KEYLEN=2,&LENGTH=48,&MSG=,&WORK=15
         AIF   (&KEYLEN EQ 0).SHORT    TEST IF SIMPLE INSERT OR ORDERED
&LABEL   STM   14,1,PUT&SYSNDX.S .    STORE REGS THAT ARE CHANGED
         LR    0,&REG .              LOAD ADDR OF NODE TO BE ADDED
         LA    1,&HDR    .        LOAD ADDRESS OF LIST HEAD
         L     15,=V(PUTNODE) .   LOAD @ NODE INSERTION ROUTINE
         CNOP  2,4 .              FOR FULLWORD ALIGNMENT OF SAVE AREA
         BALR  14,15 .            LINK TO NODE INSERTION ROUTINE
PUT&SYSNDX.S DC    4F'0' .            SAVE AREA FOR REGS 14-1
         CLC   &KEY.(&KEYLEN,2),&KEY.(1) .              CLC FOR PUTNODE
         LM    14,1,0(14) .       RESTORE REGISTERS
         AGO   .END               BRANCH AROUND SIMPLE INSERT
.SHORT   ANOP
&LABEL   ST    ZERO,0(&REG) .        ZERO LINK TO OTHER JOBS
         ST    ZERO,0(&REG) .        ZERO LINK TO OTHER JOBS
         LA    &WORK,&HDR    .       GET ADDRESS OF HEADER
         MVI   7(&WORK),X'01' .       INDICATE PROCESSOR BEING USED
.END     DEBUG ADDITION,&HDR,&MSG,4(&REG),&LENGTH
         MEND
         EJECT
         MACRO
&LABEL   GETFREE &FRHDR,&REG,&END
&LABEL   L     &REG,&FRHDR   .       GET TOP ELEMENT OFF FREE LIST
         LTR   &REG,&REG .              TEST FOR EMPTY LIST
         BZ    &END    .         NO FREE NODES; TAKE ALTERNATE EXIT
         MVC   &FRHDR.(4),0(&REG) .    MOVE STACK POINTER DOWN
         SPACE 1
         MEND
         EJECT
         MACRO
         DEBUG &PREFIX,&HDR,&MSG,&LOC,&LEN
         GBLB  &NOTRC             FALSE IF TRACE IS ON
         LCLA  &LN
         LCLC  &NAME              EITHER &MSG OR &HDR
         AIF   (&NOTRC).END       TEST FOR TRACE OFF
         AIF   ('&MSG' EQ '').HDRMSG   USE &HDR IF &MSG OMITTED
&NAME    SETC  '&MSG'(2,K'&MSG-2) STRIP QUOTES OFF &MSG
&LN      SETA  K'&MSG-2
         AGO   .GENTR
.HDRMSG  ANOP
&NAME    SETC  '&HDR'             PUT &HDR INTO &NAME
&LN      SETA  K'&HDR
.GENTR   XPRNT =C'0NODE &PREFIX AT &NAME',18+&LN
         XDUMP &LOC,&LEN
.END     MEND
         SPACE 2
         MACRO
         CRLISTS &PREFIX,&NUM
         LCLA  &COUNT
         LCLA  &SUM               # EVENT QUEUE ELEMENTS
.MORE    ANOP
&COUNT   SETA  &COUNT+1
&PREFIX&COUNT  DC    4F'0'.                LIST HEADER
         AIF   (&COUNT LT &NUM).MORE
         MEND
         EJECT
         MACRO
         LISTS
         GBLA  &MMS,&DQN,&CAT,&ION,&CPN     DECLARE GLOBALS
.*       GENERATE LIST HEADERS
EVQ      DC    4F'0'              EVENT QUEUE HEADER
RJQ      DC    4F'0'              READY JOB QUEUE HEADER
         CRLISTS DQ,&CAT          LIST HEADERS FOR CATEGORY QUEUES
         CRLISTS IOQ,&ION         LIST HEADERS FOR CHANNEL WAIT QUEUES
         CRLISTS CHAN,&ION        LIST HEADERS FOR CHANNEL USE QUEUES
         CRLISTS CPU,&CPN         LIST HEADERS FOR CPU USING QUEUES
EVQFR    DC    A(FR1)
JQEFR    DC    A(FR2)
MMS      DC    F'&MMS' .          MEMORY SIZE
HEADERS  DC    AL4(2+&CPN+&ION+&ION+&CAT) .      NUMBER OF HEADERS
CAT      DC    F'&CAT' .             NUMBER OF CATEGORIES
ION      DC    F'&ION' .             NUMBER OF I/O CHANNELS
MEMTABLE DC    &MMS.CL12'    U'   MEMORY TABLE
HOLES    DC    &MMS.F'0' .           TABLE OF HOLES IN MEMORY
&SUM     SETA  &CPN+&ION+4        GET SIZE OF EVENT QUEUE
FR1      FREEAREA &SUM,2          AREA FOR EVENT QUEUE
FR2      FREEAREA &DQN,12            AREA FOR JQE'S
         MEND
         SPACE 3
         MACRO
&LABEL   FREEAREA &NUM,&DATA
         LCLA  &I                 LOCAL COUNTER
&LABEL   DS    0F .               DEFINE FREE LIST
&I       SETA  &NUM               GET NUMBER OF NODES TO GENERATE
.NEXT    AIF   (&I LE 1).LAST     SEE IF AT END YET
         DC    A(*+4*(&DATA+1)),&DATA.F'0'
&I       SETA  &I-1               DECREMENT COUNTER
         AGO   .NEXT              GO DO NEXT NODE
.LAST    DC    A(0),&DATA.F'0'
         SPACE 1
         MEND
         EJECT
         MACRO
&LABEL   QRETURN &REGS=(14,9),&SA=*
         GBLC  &SANAME            SAVE AREA GENERATED BY QSAVE
&LABEL   DS    0H .               DEFINE LABEL
         AIF   ('&SA' EQ 'NO').LM NO SAVE AREA NO R13 RESTORE
         L     13,4(13) .         GET POINTER TO BACK SAVE AREA
.LM      AIF   (&REGS(1) GE 14).R1415  DIFF. CODE IF RESTORE 14-15
         LM    &REGS(1),&REGS(2),(&REGS(1)+5)*4(13) . RESTORE REGS
         AGO   .BR14              GENERATE BRANCH BACK
.R1415   LM    &REGS(1),&REGS(2),(&REGS(1)-11)*4(13) RESTORE REGS
.BR14    BR    14 .               RETURN TO CALLING ROUTINE
         AIF   ('&SA' EQ '').END  NO SAVE AREA, THEN DONE
         AIF   ('&SA' EQ 'NO').END
         AIF   ('&SA' NE '*').SA  SA=* ==> USE GENERATED NAME
&SANAME  DC    18F'0' .           SAVE AREA, USING GENERATED NAME
         AGO   .END
.SA      ANOP
&SA      DC    18F'0' .           GENERATE SAVE AREA
.END     SPACE 1
         MEND
         EJECT
         MACRO
&LABEL   IDENT &NAME
         LCLA  &LIDENT            LENGTH OF LABEL OR NAME
         AIF   ('&LABEL' EQ '').SYSECT IF LABEL OMITTED, USE CSECT NAME
&LIDENT  SETA  K'&LABEL/2*2+1     MAKE LENGTH OF LABEL ODD
&LABEL   B     *+5+&LIDENT .            BRANCH AROUND IDENTIFIER
         DC    X'&LIDENT',CL&LIDENT'&LABEL' .  ENTRY NAME
         MEXIT
.SYSECT  ANOP
&LIDENT  SETA  K'&NAME/2*2+1      MAKE CSECT NAME LENGTH ODD
         B     *+5+&LIDENT .            BRANCH AROUND IDENTIFIER
         DC    X'&LIDENT',CL&LIDENT'&NAME' .  ENTRY NAME
         MEND
         EJECT
         MACRO
&LABEL   QSAVE &REGS=(14,9),&BASE=9,&SA=*
         GBLC  &SANAME            NAME OF GENERATED SAVE AREA
         LCLA  &BR                BASE REGISTER TO BE USED
         AIF   (&BASE GE 13).BERROR    BASE REG CANNOT BE > 12
&BR      SETA  &BASE              USE &BASE AS BASE REGISTER
         AGO   .U15               BRANCH AROUND BASE REG ERROR RESET
         MNOTE *,'NOT UNLESS AN ERROR IN ASSIST'
.BERROR  MNOTE *,'&BASE IS ILLEGAL BASE REGISTER. VALUE CHANGED TO 12.'
&BR      SETA  12                 USE 12 AS BASE REGISTER
.U15     USING *,15 .             FOR TEMPORARY ADDRESSIBILITY
&LABEL   IDENT &SYSECT            GENERATE IDENTIFIER
         AIF   (&REGS(1) GE 14).R1415  IF SAVE REGS 14-15, DIFF. CODE
         STM   &REGS(1),&REGS(2),(&REGS(1)+5)*4(13) . SAVE REGS
         AGO   .SAVEA
.R1415   STM   &REGS(1),&REGS(2),(&REGS(1)-11)*4(13) SAVE REGS
.SAVEA   AIF   ('&SA' EQ 'NO').BASEREG NO SAVE AREA, DO BASE REG
         AIF   ('&SA' EQ '*').GENSA    GENERATE NAME IF SA=*
&SANAME  SETC  '&SA'              USE NAME PROVIDED
         AGO   .R13FIX
.GENSA   ANOP
&SANAME  SETC  '&SYSECT'(1,3).'&SYSNDX.S'   GENERATE SAVE AREA NAME
.R13FIX  LR    &BR,13 .            SAVE OLD POINTER
         LA    13,&SANAME  .      GET ADDRESS NEW AREA
         ST    13,8(&BR) .         PUT NEW POINTER IN OLD AREA
         ST    &BR,4(13) .         STORE POINTER TO OLD SAVE AREA
.BASEREG BALR  &BR,0 .             LOAD BASE REGISTER
         USING *,&BR .             DECLARE BASE REGISTER
         DROP  15 .               END TEMPORARY ADDRESSIBILITY
         SPACE 1
         MEND
         EJECT
         MACRO
&LABEL   QCALL &ENTRY,&ARG
         LCLA  &CTR               COUNTER FOR ARG LIST GENERATION
         LCLA  &ARGLEN            # OF ITEMS IN ARGUMENT LIST
         AIF   ('&ENTRY' EQ '').LABELF NO ENTRY PT. PUT LABEL ON DS  F
&LABEL   DS    0H .               DEFINE LABEL
         AIF   ('&ARG' EQ '').L15 NO ARG LIST, GENERATE L AND BALR
         AIF   ('&ARG'(1,1) NE '(').LA1     GET ARG LIST @ IN REG 1
         CNOP  0,4 .              ALIGN ARGUMENT LIST ON FULLWORD
&ARGLEN  SETA  N'&ARG             GET NUMBER OF ARGUMENTS
         BAL   1,*+4+4*&ARGLEN .        LOAD ARG LIST @ AND BRANCH OVER
         AGO   .ARGLIST           GO GENERATE ARGUMENT LIST
.LABELF  ANOP
&LABEL   DS    0F .               ALIGN ARGUMENT LIST TO FULLWORD
.ARGLIST ANOP
&CTR     SETA  1                  INITIALIZE COUNTER
.TEST    AIF   (&CTR GE N'&ARG).LAST   TEST FOR LAST ARGUMENT
         DC    A(&ARG(&CTR)) .       ARGUMENT FOR CALLED PROGRAM
&CTR     SETA  &CTR+1             INCREMENT COUNTER
         AGO   .TEST              TEST FOR LAST ARGUMENT
.LAST    DC    X'80',AL3(&ARG(&CTR)) .LAST ARG; VL FLAG SET TO 1
         AIF   ('&ENTRY' EQ '').END    DONE IF NO ENTRY POINT
         AGO   .L15               GENERATE CODE TO L AND BALR
.LA1     LA    1,&ARG     .       LOAD ADDRESS OF REMOTE ARGUMENT LIST
.L15     L     15,=V(&ENTRY)   .  GET ADDRESS OF ENTRY POINT
         BALR  14,15 .            LINK TO CALLED ROUTINE
.END     SPACE 1
         MEND
         PRINT ON
         EJECT
         SYSGEN CATNO=2
PROCJCL  CSECT
         ENTRY PUTNODE,DELETE,EVQINIT,ARRIVE
         DS    55CL80
         ORG   PROCJCL+X'7C0'
PUTNODE  DS    0H
         ORG   PROCJCL+X'802'
DELETE   DS    0H
         ORG   PROCJCL+X'870'
EVQINIT  DS    0H
         ORG   PROCJCL+X'A88'
ARRIVE   DS    0H
         ORG
LOADER   CSECT
         QSAVE REGS=(14,2),BASE=2
         LA    0,55
         L     1,=A(PROCJCL)
LOADREAD XREAD 0(1),72
         LA    1,72(1)
         BCT   0,LOADREAD
         QCALL MAIN
         QRETURN
         LTORG
         TITLE 'GLOBAL CSECT'
GCSECT   CSECT
         USING GCSECT,12          FOR ADDRESSIBILITY OF GBL TABLE
ZERO     EQU   10                 WILL CONTAIN ZERO AT EXECUTION TIME
SYSTIME  EQU   11                 SYSTEM CLOCK
COMLINE  DC    C'-  COMMENT: '
COMCARD  DS    CL80               SPACE FOR COMMENT CARD
CARDLINE DC    CL12' '            LINE TO PRINT CARD IMAGE
CARD     DC    80C' ',C' #'       SPACE FOR CARD AND BYTES TO STOP TRT
ERRLINE  DC    CL12' ',82C'-',3C' '    ONE - IS CHANGED TO $ TO POINT
*                                    TO ERROR IN CARD IMAGE
ERRMSG   DS    CL33               SPACE FOR ERROR MESSAGE
BATCHTBL DS    0F                 KEYWORD DESCRIPTOR TBL FOR $B CARDS
         DC    CL3'CPP',B'00000001',X'03',AL3(CPP),X'02',AL3(CPPST)
         DC    CL3'CPS',B'00000101',X'03',AL3(CPS),X'03',AL3(CPSST)
         DC    CL3'INP',B'00000101',X'02',AL3(INP),X'01',AL3(INPST)
         DC    CL3'INS',B'00000001',X'01',AL3(INS),X'02',AL3(INSST)
         DC    CL3'IOS',B'00000101',X'03',AL3(IOS),X'03',AL3(IOSST)
         DC    CL3'JAR',B'00001000',X'00',AL3(JAR),X'00',AL3(0)
         DC    CL3'MMA',B'00000001',X'03',AL3(MMA),X'03',AL3(MMAST)
         DC    CL3'MMJ',B'00000100',X'00',AL3(MMJ),X'00',AL3(0)
         DC    CL3'RPS',B'00000100',X'00',AL3(RPS),X'00',AL3(0)
         DC    CL3'XXX',B'00000010',X'00',AL3(XXX),X'00',AL3(0)
BATCHOP  DS    0F                 SPACE FOR OPERANDS FROM $B CARDS
CPP      DC    2F'0'
CPS      DC    2F'0'
INP      DC    2F'0'
INS      DC    2F'0'
IOS      DC    2F'0'
JAR      DC    F'0'
MMA      DC    2F'0'
MMJ      DC    F'0'
RPS      DC    F'0'
XXX      DC    F'0'
BTCHDFLT DC    F'0,2,1,0,1,0,0,1,1'    $BATCH CARD DEFAULTS
         DC    F'0,0,0,1,15,999999999,0'
CPPST    DC    C'YES',X'00'       STRING TABLES FOR $B CARDS
         DC    C'NO ',X'00'
CPSST    DC    C'IBC',X'01'
         DC    C'CBC',X'01'
         DC    C'C  ',X'00'
INPST    DC    C'MS',X'00'
INSST    DC    C'C',X'00'
         DC    C'R',X'00'
IOSST    EQU   CPSST
MMAST    DC    C'CNF',X'00'
         DC    C'CNB',X'00'
         DC    C'S  ',X'00'
         SPACE 2
JOBTBL   DS    0F                 KEYWORD DESCRIPTOR TBL FOR $J CARDS
         DC    CL3'CHI',B'00000100',A(JCHI),A(0)
         DC    CL3'CHL',B'00001000',A(JCHL),A(0)
         DC    CL3'CHN',B'00000100',A(JCHAN),A(0)
         DC    CL3'CTN',B'00000100',A(JCAT),A(0)
         DC    CL3'MEM',B'00000100',A(JMEM),A(0)
         DC    CL3'PRI',B'00000100',A(JPRI),A(0)
         DC    CL3'TIM',B'00000100',A(JTIME),A(0)
JOBOP    DS    0F                 SPACE FOR OPERANDS FROM $J CARDS
JTIME    DC    F'1'
JMEM     DC    F'1'
JPRI     DC    F'999999999'
JCAT     DC    F'1'
JCHAN    DC    F'1'
JCHI     DC    F'999999999'
JCHL     DC    F'0'
JOBDFLT  DC    F'1,1,999999999,2,4,999999999,0' $JOB CARD DEFAULTS
COLUMN   DS    F                  COLUMN TO BEGIN PROCESSING CARD
DBLWRK   DS    D                  DOUBLE WORD FOR CVD'S
FORTIME  DS    F                  SYSTIME TIME FOR FORTRAN REPORTS
FORTURN  DS    F                  TURNAROUND TIME FOR FORTRAN REPORTS
FMEMRES  DS    F                  MEMORY RESIDENCE TIME FOR REPORTS
FORTJOB  DS    H                  JOB NUMBER FOR FORTRAN REPORTS
OVERLAP  DS    F                  TOTAL AMOUNT OF TIME A CPU AND CHAN
*                                    WERE BUSY AT THE SAME TIME
AVJOBMEM DS    F                  (AVERAGE # OF JOBS IN MEM)*(CURRENT
*                                    SYSTEM TIME)
JOBFLOW  DS    F                  SUM OF TURNAROUND TIMES FOR ALL JOBS
*                                 TERMINATED TO DATE
BADJOB   DS    F                  NUMBER OF BAD JOBS IN THIS BATCH
JQEUSED  DS    F'0'               NUMBER OF JQE'S BEING USED
JOBIM    DC    F'0'               # OF JOBS CURRENTLY IN MEMORY
JOB#     DC    H'0'               NUMBER OF THE LAST JOB READ
BATCH#   DC    PL2'0'             BATCH #
STAT#    DS    PL2                STATUS REPORT NUMBER
EDWRK    DS    CL11               WORK AREA FOR EDITS
EQOUTHEX DC    C'0123456789ABCDEF'     HEX OUTPUT TR TABLE
HEXTBL   EQU   EQOUTHEX-240       TO ADDRESS HEX TABLE
EOF      DC    X'00'              SET TO 01 WHEN END OF FILE IS FOUND
INHIBIT  DC    C'F'               SET TO T IF ALL JQE'S ARE BEING USED
JOBLAST  DC    C'F'               SET TO T WHEN LAST JOB IN BATCH FOUND
CATL     DC    X'01'              CATEGORY LAST INITIATED FROM
JOBARG   QCALL ,(JOBTBL,L7)       ARGUMENT LIST TO CALL PROCJCL FOR $J
L7       DC    F'7'               LENGTH OF JOB TABLE
BATCHARG QCALL ,(BATCHTBL,L10)    ARGS TO CALL PROCJCL FOR $BATCH
L10      DC    F'10'              LENGTH OF $B ARG TABLE
         LISTS
         TITLE 'DSECTS'
LISTHEAD DSECT                    FORMAT OF 4 WORD LIST HEADER
TOP      DS    A                  POINTER TO TOP NODE
LLEN     DS    F                  CURRENT NUMBER OF NODES IN LIST
MAXLEN   DS    F                  MAX LENGTH LIST HAS EVER HAD
AVGLEN   DS    F                  AVERAGE Q LENGTH * TOTAL TIME
         SPACE 2
EVQEL    DSECT                    FORMAT EVENT QUEUE NODE
         DS    F                  LINK TO NEXT EVENT
EVTIME   DS    F                  TIME OF EVENT
EV#      DS    H                  EVENT NUMBER
EVFLAG   DS    H                  EVENT FLAGS
         SPACE 2
JQEL     DSECT                    FORMAT JOB QUEUE ELEMENT
         DS    F                  LINK TO NEXT JQE
JOBID    DS    H                  JOB IDENTIFICATION NUMBER
CHAN     DS    H                  CHANNEL JOB WILL USE
TIME     DS    F                  CPU TIME REQUESTED, IN MILLISECONDS
TIMREM   DS    F                  CPU TIME REMAINING UNTIL TERMINATION
CPUPRI   DS    H                  PRIORITY FOR USING THE CPU
IOPRI    DS    H                  PRIORITY FOR USING A CHANNEL
CHI      DS    F                  INTERVAL BETWEEN CHANNEL INTERRUPTS
COMPCHI  DS    F                  TIME UNTIL NEXT CHANNEL INTERRUPT
CHL      DS    F                  LENGTH OF EACH CHANNEL USAGE
INDQ     DS    F                  TIME ENTERED SYSTEM
CPS#IO   DS    H                  # I/O REQUESTS IN LAST CPS INTERVAL
IOS#IO   DS    H                  # I/O REQUESTS IN LAST IOS INTERVAL
MEMPTR   DS    0F                 POINTER TO THE FIRST MEMORY BLOCK
MEM      DS    H                  # OF MEMORY BLOCKS REQUESTED
INITPRI  DS    H                  INITIATION PRIORITY
EVPTR    DS    F                  POINTER TO NEXT EVENT FOR THIS JOB
INITIME  DS    F                  TIME INITIATED
         TITLE 'MAIN ROUTINE'
MAIN     CSECT
         QSAVE REGS=(14,12)
         SR    ZERO,ZERO          PUT 0 IN ZERO
         L     12,=V(GCSECT)      GET ADDR OF GLOBAL TABLE
         USING GCSECT,12
         XPRNT =CL30'1 OS/411   JAMES WYLLIE',30
         XPRNT =C'1',1            SKIP TO A NEW PAGE
MREAD    XREAD CARD,80            READ NEXT CARD
         BM    MAINRET            DONE IF ENDFILE
         B     MBATCH             BRANCH AROUND END FILE TEST
MAINM2   CLI   EOF,X'01'          TEST FOR END OF FILE
         BE    MAINRET            IF END OF FILE; THEN DONE
MBATCH   CLC   CARD(2),=C'$B'     TEST FOR $BATCH CARD
         BE    MEVALB             GO CALL PROCJCL IF $B CARD
         CLC   CARD(2),=C'$C'     TEST FOR COMMENT CARD
         BNE   MERROR             ERROR IF NOT $C OR $B
         SPACE 1
         MVC   COMCARD,CARD       MOVE COMMENT TO COMMENT PRINT AREA
         XPRNT COMLINE,92         PRINT FIRST COMMENT
         MVI   CARDLINE,C' '      MOVE BLANK TO CARRIAGE CONTROL
MCOMREAD XREAD CARD,80            READ NEXT CARD
         BM    MAINRET            DONE IF END FILE
         CLI   CARD,C'$'          TEST FOR CONTROL CARD
         BE    MBATCH             TEST IF CONTROL CARD IS $B
         XPRNT CARDLINE,92        PRINT COMMENT CONTINUATION
         B     MCOMREAD           GO READ NEXT CARD
         SPACE 1
MERROR   XPRNT =C'-EXPECTING $B OR $C CARD.  THE FOLLOWING CARD WAS FOUX
               ND:',56            PRINT ERROR MESSAGE
         XPRNT CARD-1,81          PRINT BAD CARD
         B     MREAD              GO READ NEXT CARD
         SPACE 1
MEVALB   MVC   COLUMN,=F'7'       SET START COLUMN FOR PROCJCL
         MVC   BATCHOP(64),BTCHDFLT    SET $B DEFAULTS
         QCALL PROCJCL,BATCHARG   CALL PROCJCL FOR $B CARDS
         B     *+8                IF GOOD, BRANCH AROuND BAD CARD BR
         B     MAINM2             BAD $BATCH CARD, GO CHECK EOF
         QCALL BEGINB             PRINT BEGINNING OF BATCH REPORT
         SPACE 1
MJTYPE   CLC   CARD(2),=C'$J'     TEST FOR JOB CARD IN BUFFER
         BE    MEVALJ             IF $J, GO CALL PROCJCL FOR $J
         CLC   CARD(2),=C'$C'     TEST IF COMMENT CARD IN BUFFER
         BE    MJCOMM             DUMP COMMENTS  IF FOUND
         CLC   CARD(2),=C'$B'     TEST FOR $B IN BUFFER
         BE    EMPTYB             EMPTY BATCH IF NO $J CARDS
         XPRNT =C'-EXPECTING $J, $B, OR $C CARD.  THE FOLLOWING CARD WAX
               S FOUND:',61
         XPRNT CARD-1,81          PRINT BAD CARD
         XREAD CARD,80            READ NEXT CARD
         BNM   MJTYPE             NOT EOF; FIND TYPE OF CARD
MEOF     MVI   EOF,X'01'          TURN ON ENDFILE FLAG
         B     EMPTYB             PRINT EMPTY BATCH MESSAGE
         SPACE 1
MJCOMM   MVC   COMCARD,CARD       MOVE COMMENTS TO COMMENT PRINT AREA
         XPRNT COMLINE,92         PRINT FIRST COMMENT
         MVI   CARDLINE,C' '      MOVE BLANK CARRIAGE CONTROL IN
MJCOMRD  XREAD CARD,80            READ NEXT CARD
         BM    MEOF               GO SET EOF FLAG AND PRINT EMPTY BATCH
         CLI   CARD,C'$'          TEST FOR CONTROL CARD
         BE    MJTYPE             FIND TYPE OF CONTROL CARD
         XPRNT CARDLINE,92        PRINT COMMENT CONTINUATION
         B     MJCOMRD            GO READ NEXT CARD
         SPACE 1
MEVALJ   MVC   COLUMN,=F'5'       SET START COLUMN FOR PROCJCL
         MVC   JOBOP(28),JOBDFLT  SET $J DEFAULTS
         QCALL PROCJCL,JOBARG     CALL PROCJCL TO EVALUATE $J CARD
         B     MMTEST             GOOD $J; CHECK MEM NOT > &MMS
MBADJOB  L     3,BADJOB           ADD ONE TO COUNT OF BAD JOBS IN BATCH
         LA    3,1(3)
         ST    3,BADJOB
         CLI   EOF,X'01'          CHECK FOR ENDFILE
         BNE   MJTYPE             IF NOT EOF, THEN TEST FOR A JOB CARD
         SPACE 1
EMPTYB   XPRNT =C'-THERE WERE NO VALID $JOB CARDS IN THE PRECEDING BATCX
               H.  NO SIMULATIONS WERE DONE.',82 PRINT EMPTY BATCH MSG
         B     MAINM2             GO TEST FOR END OF FILE
         SPACE 2
MMTEST   CLC   JMEM,MMS           TEST FOR MEMORY REQUEST TOO HIGH
         BNH   MAINM1             IF WITHIN RANGE, GO DO SIMULATION
         XPRNT =C'-A JOB REQUESTED TOO MUCH MEMORY.  IGNORED.',43
         B     MBADJOB            GO INC COUNT OF BAD JOBS
MAINM1   SR    SYSTIME,SYSTIME    SET SYSTEM TIME TO ZERO
         MVI   INHIBIT,C'F'       NOT ALL JQE'S IN USE
         MVI   JOBLAST,C'F'       NOT LAST JOB IN BATCH
         STH   ZERO,JOB#          SET JOB NUMBER TO 0
*        ZERO MAXIMUM LENGTH AND AVERAGE LENGTH FIELDS OF QUEUE HEADERS
         L     5,HEADERS          GET NUMBER OF HEADERS TO BLANK
         LA    4,EVQ              GET START ADDRESS OF HEADERS
MHEADBL  STM   ZERO,SYSTIME,8(4)  ZERO MAX AND AVG LENGTH FIELDS
         LA    4,16(4)            INCREMENT POINTER
         BCT   5,MHEADBL          DECREMENT AND TEST COUNTER
         SPACE 1
*        MUST REINITIALIZE MEMORY TABLE
         LA    4,MEMTABLE         GET BEGIN ADDRESS OF TABLE
         L     5,MMS              GET NUMBER OF CELLS TO CLEAR
MEMBLANK ST    ZERO,8(4)          BLANK OUT CELL IN MEMORY TABLE
         LA    4,12(4)            INCREMENT POINTER
         BCT   5,MEMBLANK         DECREMENT COUNTER AND LOOP
         SPACE 1
         AP    BATCH#,=PL1'1'     INCREMENT BATCH NUMBER
         ZAP   STAT#,=P'0'        ZERO STATUS REPORT NUMBER
         MVC   CATL,CAT+3         SET LAST CAT INITIATED FROM TO &CAT
         ST    ZERO,OVERLAP       ZERO CHANNEL-CPU CONCURRENCY TIME
         STM   ZERO,SYSTIME,AVJOBMEM   ZERO AVG # JOBS IN MEM AND TOTAL
*                                    TURNAROUND TIME
         SPACE 2
         QCALL EVQINIT            INITIALIZE EVENT QUEUE
         QCALL EVENT              PERFORM SIMULATION
         QCALL ENDBATCH           WRITE END OF BATCH REPORT
         B     MAINM2             GO TEST FOR END FILE
         SPACE 2
MAINRET  QRETURN REGS=(14,12)
         LTORG
         TITLE 'I/O REQUEST'
IOREQ    CSECT
*        AT ENTRY, REG 2 CONTAINS THE ADDRESS OF THE EVENT QUEUE
*        ELEMENT ASSOCIATED WITHE THE I/O REQUEST
         QSAVE
         USING EVQEL,2            TO ADDRESS EVENT QUEUE ELEMENT
         LH    1,EVFLAG           GET (CPU#-1)*16
         POP   CPU1(1),3,MSG='IOREQ'   FREE CORRECT CPU
         USING JQEL,3             TO ADDRESS THE JQE
         L     1,CHAN             GET CHANNEL # JOB WILL USE
         SLA   1,4                MULT BY 16 TO GET INDEX INTO CHAN HDR
         L     0,CHAN1-12(1)      GET LENGTH OF CHANNEL QUEUE
         LTR   0,0                LENGTH = 0 IF CHANNEL IDLE;
         BNZ   IORWAIT                   = 1 IF BUSY
         PUTNODE CHAN1-16(1),3,KEYLEN=0,MSG='IOR CHAN' ASSIGN CHANNEL
         GETFREE EVQFR,2,ERROR    GET A FREE EVENT QUEUE NODE
         LR    0,SYSTIME          COMPUTE TIME FINISHED USING CHANNEL
         A     0,CHL
         ST    0,EVTIME           SET TIME OF CHANNEL TERMINATION
         LA    0,3                GET # FOR I/O TERMINATION
         STH   0,EV#              PUT EVENT TYPE INTO NODE
         STH   1,EVFLAG           PUT (CHAN#)*16 INTO EVENT FLAG
         PUTNODE EVQ,2,KEYLEN=6,LENGTH=8,MSG='REQ TERM' SCHED CHAN TERM
         MSTATUS 3,I              SET MEMORY USAGE FLAGS TO I
         B     IOREQEND
         SPACE 2
*        CHANNEL IS BUSY, MUST ENQUEUE JOB ON I/O WAIT QUEUE
IORWAIT  PUTNODE IOQ1-16(1),3,KEY=18,MSG='I/O WAIT' PUT JOB INTO I/O Q
         MSTATUS 3,W              SET MEMORY BLOCK USAGE FLAGS TO WAIT
IOREQEND QRETURN
         LTORG
         DROP  2,3
         TITLE 'I/O TERMINATOR'
IOTERM   CSECT
*        AT ENTRY, REG 2 CONTAINS THE ADDRESS OF THE EVENT QUEUE
*        ELEMENT ASSOCIATED WITH THIS I/O TERMINATION
         USING EVQEL,2            TO ADDRESS EVENT QUEUE ELEMENT
         LH    3,EVFLAG           GET CHANNEL# * 16
         POP   CHAN1-16(3),1,MSG='I/O TERM'      FREE CHANNEL
         USING JQEL,1             TO ADDRESS JOB QUEUE ELEMENT
         LH    4,CPS#IO           UPDATE # I/O REQUESTS FOR CPS
         LA    4,1(4)
         STH   4,CPS#IO
         LH    4,IOS#IO           UPDATE # I/O REQUESTS FOR IOS
         LA    4,1(4)
         STH   4,IOS#IO
         ST    ZERO,COMPCHI       SET COMPUTED CHI TO 0 AWAITING CPU
         PUTNODE RJQ,1,KEY=16,MSG='I/O TO R'  PUT JOB BACK INTO RJQ
         MSTATUS 1,R              FIX UP MEMORY STATUS FLAGS FOR READY
         POP   IOQ1-16(3),1,IOTEND,MSG='I/O NEXT' GET NEXT JOB FOR CHAN
         PUTNODE CHAN1-16(3),1,KEYLEN=0,MSG='IOT CHAN'CHAN TO NEXT
         MSTATUS 1,I              SET MEM STATUS FLAGS TO I/O WAIT
         GETFREE EVQFR,2,ERROR    GET A FREE EVENT QUEUE NODE
         L     0,CHL              COMPUTE TIME JOB DONE WITH CHANNEL
         AR    0,SYSTIME
         ST    0,EVTIME           SET TIME OF CHANNEL TERMINATION
         LA    0,3                GET # FOR I/O TERMINATION
         STH   0,EV#              SET EVENT TYPE TO I/O TERMINATION
         STH   3,EVFLAG           PUT CHANNEL #16 INTO EVQ ELEMENT
         STH   3,EVFLAG           PUT CHANNEL# * 16 INTO EVQ ELEMENT
IOTEND   QRETURN
         LTORG
         DROP  1,2                END ADDRESSIBILITY OF QUEUE ELEMENTS
         END   LOADER
/*
$ENTRY
 00  PROCJCL  } &}3M ] }3}&       { j A3    k-{*\ {* *k {*  K      ~  K
    kB    { ! BYk              w\ {  &    n${     j A3    \ {* *  {  0
k C nB      j A3    K A  :k$ *\ {  bk- * 0 o\      0 o                N
       }     r       0      n=     YkK      j       k          2 6 0 2 0
   0  j                    \   0          n -    -N   -    +
 - 0             d   0        &0  P     k          2 : 0   0   0   0  j
      k               \ {  &    k C     q }   n${     j A3   M\ {* *  {
 0               0  j            0  j        - k    j        0  j
 - k    j       &        0 o        nA     %n9     %nF   }  n0     %
 0               M   & &   &           0        n0&    yn9&  } m   &
 { & &     y   6K A    0  K A    0  K A    0  K A    0  K A  & 0  K A
 0  K A  k 0  K A    0  K A  M 0  K A  5 0  K A    0  K A    0  K A    0
  K A  `k$ ;j A3 \ !\ {* *\ {  bk- ;k  #\ {  &   kn${    o   hk0 #\
\ {* * 0  k C  }  q }     55555555555555
                                              K  y     y  2    y2  y  55
5555555555555550123456789


                                                                 5555555
$JOB   ASSIST       MACRO=F
         TITLE 'QDEFL MACRO - DEFINE A LIST OF NODES'
         MACRO
&LABEL   QDEFL &NUMBER,&LENGTH,&MESSAGE
         LCLA  &MSGK,&NNODES
         LCLC  &XLABEL
         ACTR  100
.*
.*
.*THIS MACRO GENERATES &NUMBER NODES, EACH OF TOTAL LENGTH &LENGTH
.*  BYTES (INCLUDING 4-BYTE LINK), LINKED TOGETHER, WITH KEY/DATA AREAS
.*  INITIALIZED TO BLANKS, AND PRECEDED BY AN OPTIONAL MESSAGE.
.*&NUMBER IS A SELF-DEFINING TERM OF VALUE >0, GIVING THE NUMBER OF
.*  NODES TO BE GENERATED.
.*&LENGTH IS ANY ABSOLUTE EXPRESSION GIVING A LENGTH FOR EACH NODE.
.*  CODE GENERATED ALLOWS FOR ROUNDING THIS TO A 4-MULTIPLE.
.*&MESSAGE IS A STRING ENCLOSED IN QUOTES.  IF OMITTED, THE LIST ONLY
.*  IS CREATED, BUT IF PRESENT, THE MESSAGE STRING IS GENERATED AS
.*  A C-TYPE CONSTANT, ROUNDED UP TO A 4-MULTIPLE, AND PLACED ON
.*  A FULLWORD BOUNDARY PRECEDING THE LIST.  IT IS USED FOR DEBUGGING
.*  (I.E., TO LOCATE A LIST IN MEMORY IN A DUMP).
.*&LABEL IS GENERATED ON OR BEFORE THE FIRST NODE GENERATED.
.*
.*
&XLABEL  SETC  '&LABEL'
         AIF   (T'&MESSAGE EQ 'O').NOMSG . IS THERE A MESSAGE?
&MSGK    SETA  ((K'&MESSAGE+3)/4)*4 .  MESSAGE LENGTH TO A 4-MULTIPLE.
         DC    0F'0',CL&MSGK&MESSAGE .  DEBUGGING MESSAGE FOR THIS LIST
.NOMSG   ANOP
&NNODES  SETA  &NUMBER-1 .        NUMBER OF NODES TO CREATE LESS ONE.
.ONELEFT AIF   ('&NNODES' LT '1').LASTNOD . IS THIS THE LAST NODE?
&XLABEL  DC    A(*+((&LENGTH+3)/4)*4),CL(&LENGTH-4)' ' . SET UP A NODE.
.*                                LESS LINK POINTER OF 4 BYTES.
&XLABEL  SETC  '' .               NULL THE LABEL.
&NNODES  SETA  &NNODES-1 .        DECREMENT NODES TO DO.
         AGO   .ONELEFT .         GO CHECK IF THERE IS ONLY ONE MORE.
.LASTNOD ANOP
&XLABEL  DC    A(0),CL(&LENGTH-4)' ' . POINTER OF LAST NODE IS ZERO.
         MEND
         TITLE 'QHED MACRO - DEFINE A LIST HEADER'
         MACRO
&LABEL   QHED  &LISTNAM
         ACTR  50
.*
.*
.*IF &LISTNAM IS CODED, THIS MACRO DEFINES A HEADER CONTAINING THE
.*  ADDRESS OF THIS LIST, OTHERWISE IT IS A HEADER CELL HAVING A VALUE
.*  OF 0, I.E., DEFINING AN EMPTY LIST.
.*FOR DEBUG PURPOSES, THIS MACRO GENERATES A MESSAGE '&LABEL LIST
.*  HEADER' IMMEDIATELY PRECEDING THE HEADER WORD.
.*
.*
         DC    0F'0',CL16'&LABEL HEADER' . DEBUGGING HEADER.
         AIF   (T'&LISTNAM EQ 'O').NULLNAM . IS THERE A HEADER NAME?
&LABEL   DC    A(&LISTNAM) .      SET UP HEADER WITH ADDRESS OF LIST.
         MEXIT
.NULLNAM ANOP
&LABEL   DC    A(0) .             SET UP HEADER WITH NULL LIST.
         MEND
         TITLE 'QNEXT MACRO - GET ADDRESS OF NEXT NODE IN LIST'
         MACRO
&LABEL   QNEXT &RND,&ADDR,&RLK=,&END=
.*
.*
.*THIS MACRO SETS REGISTER &RND TO THE ADDRESS OF THE NEXT NODE IN
.*  A LIST, GIVEN THAT &ADDR INDICATES THE ADDRESS OF A NODE WHOSE LINK
.*  FIELD POINTS TO THE NEXT NODE.  IF DESIRED, THE VALUE IN &RND MAY
.*  BE SAVED INTO REGISTER &RLK BEFORE &RND IS CHANGED (USEFUL FOR LIST
.*  SEARCH AND INSERT OPERATIONS).  IF &END IS SPECIFIED, A TEST IS
.*  MADE AND BRANCH TAKEN IF THERE ARE NO MORE NODES IN THE LIST.
.*&RND IS A REGISTER EQU SYMBOL OR NUMBER, INTO WHICH WILL BE LOADED
.*  THE ADDRESS OF THE NEXT NODE.
.*&ADDR IF SPECIFIED AT ALL, IS AN RX-TYPE ADDRESS OF THE LINK FIELD
.*  WHICH ADDRESSES THE NEXT NODE.  THE WORD AT THIS ADDRESS IS TO BE
.*  LOADED INTO &RND.  IF OMITTED ENTIRELY, IT IS TO BE ASSUMED THAT
.*  &RND CONTAINS THE ADDRESS OF THE LINK ALREADY.
.*&RLK IF SPECIFIED, GIVES THE NAME OR NUMBER OF A REGISTER INTO WHICH
.*  &RND SHOULD BE SAVED BEFORE IT IS CHANGED.
.*&END IF SPECIFIED, GIVES A STATEMENT LABEL, IN WHICH CASE THE VALUE
.*  NEWLY LOADED INTO &RND IS TO BE TESTED, AND IF FOUND = 0, A BRANCH
.*  TAKEN TO THE GIVEN STATEMENT LABEL.
.*NOTE THAT 'LINK' IS ASSUMED TO BE THE LINK DISPLACEMENT.
.*
.*
         LCLC  &XLABEL
         ACTR  50
&XLABEL  SETC  '&LABEL'
         AIF   (T'&RLK EQ 'O').NOWORKR . IS THERE A WORK REGISTER?
&XLABEL  LR    &RLK,&RND .        SAVE NEXT NODE REGISTER.
&XLABEL  SETC  '' .               NULL THE LABEL.
.NOWORKR AIF   (T'&ADDR EQ 'O').NOADDR . IS THERE AN ADDR OF THE LINK?
&XLABEL  L     &RND,&ADDR+LINK .  ADDR OF THE LINK FIELD.
&XLABEL  SETC  '' .               NULL THE LABEL.
         AGO   .ENDTEST .         GO TEST FOR END ENTRY.
.NOADDR  ANOP
&XLABEL  L     &RND,LINK(,&RND) . SET TO POINT TO NEXT NODE.
.ENDTEST AIF   (T'&END EQ 'O').NOEND .   IS THE END OPTION REQUESTED?
         LTR   &RND,&RND .        SET THE CONDITION CODE TO TEST
         BZ    &END .                FOR LAST NODE, BRANCH IF YES.
         MEXIT
.NOEND   MEND
         TITLE 'QPOP MACRO - POP THE FIRST ELEMENT OF A LIST'
         MACRO
&LABEL   QPOP  &RND,&HDR,&END=
.*
.*
.*QPOP SETS REGISTER &RND TO THE ADDRESS OF THE FIRST NODE IN THE LIST
.*  BEGUN BY HEADER AT ADDRESS &HDR, TAKING BRANCH TO &END= IF THE LIST
.*  IS EMPTY.
.*&RND SPECIFIES REGISTER TO BE SET TO ADDRESS OF NODE.
.*&HDR USUALLY SPECIFIES THE NAME OR OTHER RX-ADDRESS OF THE HEADER
.*  CELL OF A LIST.
.*&END IF SPECIFIED, REQUESTS CODE TO TEST THE LINK JUST LOADED INTO
.*  &RND, AND BRANCH TO THE LABEL SPECIFIED IF IT IS ZERO.
.*NOTICE 'LINK' IS ASSUMED TO BE THE LINK DISPLACEMENT.
.*MACROS  USED : QNEXT.
.*
.*
         ACTR  50
&LABEL   QNEXT &RND,&HDR,END=&END
         MVC   LINK+&HDR.(4),LINK(&RND) . POINT HEADER TO NEW TOP NODE.
         MEND
         TITLE 'QPUSH MACRO - PUSH A NODE ONTO THE BEGINNING OF A LIST'
         MACRO
&LABEL   QPUSH &RND,&HDR
.*
.*
.*&RND CONTAINS THE ADDRESS OF A NODE, WHICH IS PUSHED ONTO THE LIST
.*  BEGUN AT &HDR.
.*&RND SPECIFIES A REGISTER NAME OR NUMBER.
.*&HDR IS A NAME OF A HEADER CELL.
.*NOTICE 'LINK' IS ASSUMED TO BE THE LINK DISPLACEMENT.
.*
.*
         ACTR  50
&LABEL   MVC   LINK(4,&RND),&HDR .   MOVE HEADER POINTER TO NEW NODE.
         ST    &RND,&HDR .        SET HEADER POINTER TO POINT TO
*                                    NEW NODE.
         MEND
         TITLE 'QSRCH MACRO - LIST SEARCH AND INSERT NODE IN SEQUENCE'
         MACRO
&LABEL   QSRCH &RND,&HDR,&RGW=(RWK1,RWK2),&KO=4,&KL=KEYL
.*
.*
.*THIS MACRO SEARCHES THE LIST BEGUN BY HEADER &HDR, WHICH IS LINKED
.*  IN ASCENDING ORDER BY KEY FIELDS, FOR THE CORRECT PLACE TO INSERT
.*  THE NODE ADDRESSED BY REGISTER &RND.  THE KEY FIELDS ARE AT OFFSET
.*  &KO, AND ARE &KL BYTES LONG.  &RGW GIVES TWO REGISTERS WHICH MAY BE
.*  USED IF NEEDED FOR TEMPORARY WORK REGISTERS WITHOUT DISTURBING
.*  ANYTHING.
.*&RND GIVES ADDRESS OF THE NODE TO BE INSERTED.
.*&HDR IS THE NAME OF THE LIST HEADER CELL.
.*&RGW GIVES THE NAMES/NUMBERS OF 2 REGISTERS WHICH CAN SAFELY BE USED
.*  AS TEMPORARY WORK REGISTERS, AND DESTROYED BY THE MACRO.
.*&KO GIVES A NUMBER (OR EQU SYMBOL) OF THE OFFSET IN BYTES FROM THE
.*  BEGINNING OF THE NODE TO THE KEY FIELD IN THE NODE.
.*&LK IS THE LENGTH (NUMBER OR EQU VALUE) OF THE KEY FIELD.
.*NOTE THAT THE NODE TO BE INSERTED IS INSERTED AFTER ANY NODES WHICH
.*  HAVE THE SAVE KEY VALUE.
.*NOTICE RWK1, RWK2, AND LINK AND KEYL ARE ASSUMED TO BE SET IN THE
.*  MAIN PROGRAM BY EQU'S.
.*
.*
         LCLC  &LOOP,&SETLINK
         ACTR  50
&LOOP    SETC  '&SYSECT'(1,2).'&SYSNDX'.'LP' . MAKE UP A LOOPING NAME.
&SETLINK SETC  '&LOOP'(1,6).'SL' .   MAKE UP A BRANCHING NAME.
&LABEL   LA    &RGW(1),&HDR .     ADDR OF HEADER TO WORK REGISTER 1.
&LOOP    LR    &RGW(2),&RGW(1) .  SAVE IT FOR LINKING.
         L     &RGW(1),LINK(,&RGW(1)) . POINTER TO NEXT NODE.
         LTR   &RGW(1),&RGW(1) .  SET CONDITION CODE TO SEE IF THIS IS
         BZ    &SETLINK .            THE LAST NODE.  IF SO, BRANCH.
         CLC   &KO.(&KL,&RGW(1)),&KO.(&RND) . IS THIS THE PLACE TO PUT
         BNH   &LOOP .            NODE IN?  IF NOT GO PROCESS NEXT NODE
&SETLINK ST    &RGW(1),LINK(,&RND) . SET NEW NODE POINTER TO NEXT NODE
.*                                   IN ORIGINAL SEQUENCE.
         ST    &RND,LINK(,&RGW(2)) . SET NODE POINTER IN NODE BEFORE
.*                                   INSERTED NEW NODE TO POINT TO
.*                                   NEW NODE.
         MEND
         TITLE 'QSNAP MACRO - PRINT THE CONTENTS OF A LIST'
         MACRO
&LABEL   QSNAP &HDR,&MSG,&RGW=(RWK1,RWK2),&COUNT=4095,&LEN=20
.*
.*
.*THIS MACRO DUMPS THE LIST BEGINNING AT THE HEADER &HDR, USING XSNAP
.*  WITH A MESSAGE &MSG PRINTED.  THE WORK REGISTERS NEEDED ARE GIVEN
.*  BY &RGW, AND UP TO &COUNT NODES ARE PRINTED.
.*&HDR IS NAME OF LIST HEADER.
.*&MSG IS QUOTED STRING USED AS TITLE FOR LIST OUTPUT.
.*&RGW SPECIFIES NAMES/NUMBERS OF 2 REGISTERS WHICH MAY BE ERASED.
.*&COUNT SPECIFIES THE MAXIMUM NUMBER OF NODES TO BE PRINTED.
.*&LEN IS AN ABSOLUTE EXPRESSION GIVING NODE LENGTH IN BYTES.
.*NOTICE RWK1 AND RWK2 ARE ASSUMED TO BE SET IN MAIN PROGRAM BY EQU'S
.*MACROS REQUIRED: QNEXT,XSNAP.
.*
.*
         LCLC  &LOOP,&ENDADDR
         ACTR  50
&ENDADDR SETC  '&SYSECT'(1,2).'&SYSNDX'.'EN' . UNIQUE BRANCH NAME.
&LOOP    SETC  '&ENDADDR'(1,6).'LP' . UNIQUE LOOPING NAME.
&LABEL   LA    &RGW(1),&COUNT .   SET MAXIMUM NODES TO BE PRINTED.
         LA    &RGW(2),&HDR .     GET ADDRESS OF LIST HEADER.
&LOOP    QNEXT &RGW(2),END=&ENDADDR . GO TO NEXT NODE.
         XSNAP LABEL=&MSG,T=NO,STORAGE=(*0(&RGW(2)),*&LEN.(&RGW(2)))
         BCT   &RGW(1),&LOOP .    LOOP BACK TO GO TO NEXT NODE.
&ENDADDR EQU   *
         MEND
         SPACE 2
*              DUMMY MACROS TO SPEED PROCESSSING.
         MACRO
         GETMAIN
*              SAVE FROM XSAVE.
         MEND
         MACRO
         FREEMAIN
*        SAVE FROM XRETURN.
         MEND
         MACRO
         XSNAP
         XSNAP &LABEL=,&STORAGE=,&T=,&IF=
         XDUMP
         MEND
*SYSLIB XSAVE,XRETURN,EQUREGS
         TITLE 'TEST LIST MACROS MAIN PROGRAM'
         SPACE 3
TENODES  DSECT
TELINK   DS    A                  LINK TO NEXT NODE.
TEKEY    DS    CL8                KEY ORDERING FIELD.
TEDATA   DS    CL12               NODE'S DATA.
NODELEN  EQU   ((*-TELINK+3)/4)*4    NODE LENGTH, TO A 4-MULTIPLE.
         SPACE 3
         SPACE 2
*THIS TEST PROGRAM DOES THE FOLLOWING:
*  1)DEFINES A LIST OF 15 EMPTY NODES CALLED FREE LIST, EACH WITH
*  8-BYTE KEY AND 12-BYTE DATA AREAS.  ALSO DEFINES TWO EMPTY LISTS,
*  LISTA AND LISTB.  (I.E. THESE ARE NAMES OF HEADERS).
*  2)READS IN 10 DATA CARDS, EACH OF WHICH CONTAINS KEY AND DATA FOR
*  A SINGLE NODE IN COLUMNS 1-20.  AFTER EACH CARD IS READ, AN EMPTY
*  NODE IS OBTAINED FROM THE FREE LIST, FILLED WITH THE KEY AND DATA
*  JUST READ (AND A DSECT IS USED TO REFER TO THESE FIELDS AT THIS
*  POINT), THEN IT IS ENTERED IN LISTA.
*  3)DUMPS LISTS FREE, LISTA, AND LISTB.
*  4)READS IN 5 CARDS, EACH WITH A KEY VALUE ON COLUMNS 1-8.  SEARCHES
*  LISTA FOR THE SAME KEY VALUE.  IF NOT FOUND, PRINTS A MESSAGE.
*  IF FOUND, FIRST REMOVES THE NODE FROM LISTA, THEN PUSHES IT ONTO
*  BEGINNING OF LISTB.
*  5)POPS EACH NODE OF LISTA, PRINTS EACH AS IT IS OBTAINED, THEN
*  PLACES THE NODE BACK ONTO THE FREE LIST, UNTIL LISTA IS EMPTY.
*  6)PERFORMS SAME ACTION AS IN 5, BUT FOR LISTB.
*MACROS REQUIRED: XSNAP, XPRNT.
         SPACE 2
         PRINT NOGEN
         EQUREGS
LINK     EQU   0                  OFFSET OF THE LINK FIELD IN A NODE.
KEYO     EQU   4                  COMMON OFFSET TO KEY FIELD.
KEYL     EQU   8                  MOST COMMON KEY LENGTH.
RWK1     EQU   5                  TEMPORARY WORK REG.
RWK2     EQU   6                  ANOTHER TEMPORARY WORK REG.
TESTLIST CSECT
         XSAVE ,                  ESTABLISH ENTRY LINKAGE, BASE=R12.
         SPACE 2
*READ IN 10 CARDS AND INSERT THEM IN LISTA.
         SPACE 2
         LA    R2,10              NUMBER OF CARDS TO BE READ.
         PRINT NOGEN
         XPRNT =CL80'-HERE ARE THE 10 CARDS TO GO ONTO LIST A:',80
TEREAD1  XREAD TECARD,20          GET A CARD.
         XPRNT TECC,TECHOLEN      ECHO PRINT THE CARDS.
         PRINT GEN
         QPOP  R3,TEFREE,END=TEDUMMY  GET A FREE NODE, TEST END FEATURE
         USING TENODES,R3         DESECT SET UP TO MOVE DATA.
TEDUMMY  MVC   TEKEY,TECARDK      KEY IN FREE NODE GETS KEY ON CARD.
         MVC   TEDATA,TECARDD     DATA IN FREE NODE GETS DATA ON CARD.
         QSRCH R3,TELISTA         INSERT THIS NODE IN LIST A.
         XSNAP STORAGE=(TEFREE,TECARDMS),IF=(R2,H,=F'6',C)
         BCT   R2,TEREAD1         HAVE 10 CARDS BEEN READ?
         DROP  R3
         SPACE 2
*DUMP LISTS FREE, LISTA, AND LISTB.
         SPACE 2
         QSNAP TEFREE,'LIST OF FREE NODES',COUNT=16,LEN=NODELEN
         QSNAP TELISTA,'LIST A',COUNT=16,LEN=NODELEN
         QSNAP TELISTB,'LIST B',COUNT=16,LEN=NODELEN
         SPACE 2
*READ IN 5 CARDS, SEARCH LISTA FOR THAT KEY, IF NOT FOUND, PRINT A
*  MESSAGE SAYING SO; IF FOUND, MOVE THE NODE FROM LIST A TO LIST B.
         SPACE 2
         LA    R2,5               NUMBER OF CARDS TO BE READ IN.
         PRINT NOGEN
         XPRNT =CL80'-HERE ARE THE 5 CARDS TO BE LIST A SEARCHED:',80
TEREAD2  XREAD TECARD,20          GET CARD.
         XPRNT TECC,TECHOLEN      ECHO PRINT THE CARD.
         PRINT GEN
         LA    R3,TELISTA         BEGINNING OF LIST TO BE SEARCHED.
TENEXT   QNEXT R3,RLK=RWK1,END=TELAST1
         CLC   TECARDK,4(R3)      IF THE NODE KEY AND THE INPUT CARD
         BE    TEFOUND               KEY ARE SAME, THERE IS A MATCH.
         B     TENEXT             GO BACK TO LOOK AT NEXT NODE.
TELAST1  CLC   TECARDK,4(R3)      IF THE NODE KEY AND THE INPUT CARD
         BE    TEFOUND               KEY ARE SAME, THERE IS A MATCH.
         PRINT NOGEN
         XPRNT TECC,TEMSGLEN      PRINT A NOT FOUND MESSAGE.
         PRINT GEN
         B     TENEWCRD           GO PROCESS NEXT CARD, IF ANY.
TEFOUND  MVC   LINK(4,RWK1),LINK(R3) REMOVE FOUND NODE FROM LIST.
         QPUSH R3,TELISTB         INSERT FOUND NODE IN LIST.
         XSNAP STORAGE=(TEFREE,TECARDMS)
TENEWCRD BCT   R2,TEREAD2         GO READ NEXT CARD TO BE SEARCHED.
         SPACE 2
*POP EACH NODE OF LISTA AND PRINT AS OBTAINED, THEN PUT ON FREE LIST.
         SPACE 2
         PRINT NOGEN
         XPRNT =CL40'0LIST A FOLLOWS:',40
         PRINT GEN
TEPOPA   QPOP  R3,TELISTA,END=TESTOPOP
         MVC   TEPRNODE(NODELEN-4),4(R3) MOVE TO PRINT AREA LESS LINK.
         PRINT NOGEN
         XPRNT TECCPN,TECCPNL     PRINT THE NODE.
         PRINT GEN
         B     TEPOPA             GO BACK TO POP NEXT NODE.
         PRINT NOGEN
         SPACE 2
*POP EACH NODE OF LISTB AND PRINT AS OBTAINED, THEN PUT ON FREE LIST.
         SPACE 2
TESTOPOP XPRNT =CL40'0LIST B FOLLOWS:',40
         PRINT GEN
TEPOPB   QPOP  R3,TELISTB,END=TESTOPB  TAKE A NODE OFF LIST B.
         MVC   TEPRNODE(NODELEN-4),4(R3)  MOVE TO PRINT AREA LESS LINK.
         PRINT NOGEN
         XPRNT TECCPN,TECCPNL     PRINT THIS NODE.
         PRINT GEN
         B     TEPOPB             GO BACK TO POP NEXT NODE.
         PRINT NOGEN
TESTOPB  XRETURN SA=*
         PRINT  GEN
         DROP  12
         SPACE 3
         LTORG
         SPACE 3
TEFREE   QHED  TELIST1            HEADER FOR LIST OF FREE NODES.
TELIST1  QDEFL 15,NODELEN,'FREE NODES FOR TEST'
TELISTA  QHED  ,                  HEADER FOR LIST A.
TELISTB  QHED  ,                  HEADER FOR LIST B.
TECC     DC    CL1'0'             CARRIAGE CONTROL FOR PRINTING CARDS.
TECARD   EQU   *                  CARD IMAGE AREA HAS 2 NAMES.
TECARDK  DC    CL8' '             CARD IMAGE KEY.
TECARDD  DC    CL12' '            CARD IMAGE DATA.
TECHOLEN EQU   *-TECC             LENGTH OF ECHO PRINT MESSAGE.
TECARDMS DC    CL24' MATCHING NODE NOT FOUND'
TEMSGLEN EQU   *-TECC             LENGTH OF PRINT MESSAGE.
         SPACE 2
TECCPN   DC    CL1' '             NODE PRINT CARRIAGE CONTROL CHAR.
TEPRNODE DC    CL132' '           NODE PRINT AREA.
TECCPNL  EQU   *-TECCPN           LENGTH OF THE NODE PRINT LINE.
         END   TESTLIST
$ENTRY
CCCCCCCCTEST CARD 1
AAAAAAAATEST CARD 2
DDDDDDDDTEST CARD 3
FFFFFFFFTEST CARD 4
BBBBBBBBTEST CARD 5
ZZZZZZZZTEST CARD 6
XXXXXXXXTEST CARD 7
GGGGGGGGTEST CARD 8
KKKKKKKKTEST CARD 9
EEEEEEEETEST CARD 10
NOTFOUNDTEST CARD 11
ZZZZZZZZTEST CARD 12
AAAAAAAATEST CARD 13
AAAAAAAATEST CARD 14
KKKKKKKKTEST CARD 15
$JOB ASSIST MACRO=F
         TITLE '*** DCBDUMP - FORMATTED DUMP OF DATA CONTROL BLOCK ***'
         MACRO
         IHBERMAC
         MEND
*SYSLIB DCBD
         PRINT NOGEN
*
*        SET UP SYMBOLIC NAMES FOR SYSTEM CONTROL BLOCKS
*        USING I-B-M STANDARD MACROS TO AVOID PROBLEMS WITH
*              FUTURE OPERATING SYSTEMS.
*
*
         DCBD  DSORG=PS
         SPACE 4
IHACVT   DSECT
CVTTCBP  DS    F
CVTPTR   EQU   16
         SPACE 4
IHATCBP  DSECT
TCBPNTCB DS    F
TCBPCTCB DS    F
         SPACE 4
IHATCB   DSECT
         DS    3F
TCBTIO   DS    F
         SPACE 4
IHATIOT  DSECT
         DS    F
         SPACE 3
BS       DSECT ,                   BYTE SCANER PARM FIELD
BSBYTE   DS    A                   ADRS OF BYTE TO BE SCANNED
BSOUT    DS    A                   START ADRS OF OUTPUT FIELD
BSLIST   DS    A                   LIST HEADER OF OPTION DESCRIPTION
BSLEN    DS    F                   EFFECTIVE LENGTH OF OUTPUT FIELD
BSADD    DS    F                   SPACE BETWEEN OUTPUT FIELDS
         SPACE 3
BITFLG   DSECT ,                   BIT PATTERN DESCRIPTION
BFLINK   DS    A                   LINK TO NEXT NODE
BFMASK   DS    C                   MASK ON SOURCE BYTE
BFMATCH  DS    C                   PATTERN BEING CHECKED FOR
BFOUT    DS    0C                  MESSAGE FOR THIS BIT PATTERN
         EJECT
DCBDUMP  CSECT
         USING *,15
         STM   0,15,SAVEALL        SAVE ALL REGS
         CNOP  0,4
         BAL   13,PGMSTART
         DROP  15
         USING *,13
         DC    18F'0'
SAVEALL  DS    16F
PGMSTART EQU   *
         ST    1,SAVEPARM
         L     Z,0(1)                  LOAD ADDRESS OF D-C-B
         USING IHADCB,Z                ADDRESSABILITY WITH DCBD
         SPACE 10
*        FIND DDNAME AND STATUS
*
         MVC   STATUS(3),=C'NOT'
         LA    A,DCBDDNAM
         TM    DCBOFLGS,X'10'
         BZ    CLOSED
         L     A,CVTPTR                CVT POINTER
         USING IHACVT,A
         L     A,CVTTCBP               ADDRESS OF T-C-B
         USING IHATCBP,A
         L     A,TCBPCTCB
         USING IHATCB,A
         L     A,TCBTIO                ADDRESS OF T-I/O-T
         USING IHATIOT,A
         LH    B,DCBTIOT               T-I/O-T OFFSET
         LA    A,4(A,B)
         MVC   STATUS(3),STATUS-1
CLOSED   MVC   DDNAME(8),0(A)
*
         XPRNT LINE1,LEN1
         EJECT
         XPRNT HEADER2
         LA    A,96(Z)             END OF D-C-B
         ST    A,ENDDCB
         LM    A,C,=A(DUMPLINE+20,9,DUMPLINE+47)
         LR    E,Z
OUTLOOP  LR    D,A
INLOOP   UNPK  0(9,D),0(5,E)
         MVI   8(D),X'FE'
         LA    E,4(E)
         BXLE  D,B,INLOOP
         TR    DUMPLINE+20(36),HEXTAB
         XPRNT DUMPLINE
         C     E,ENDDCB
         BL    OUTLOOP
         EJECT
*        BLKSIZE, LRECL, RECFM
*
*              BLOCK SIZE
         LH    A,DCBBLKSI
         CVD   A,DWORD
         MVC   BLKSIZE(6),EDIT
         ED    BLKSIZE(6),DWORD+5
*              LOGICAL RECORD LENGTH
         LH    A,DCBLRECL
         CVD   A,DWORD
         ED    LRECL(6),DWORD+5
*              RECORD FORMAT
         SR    A,A
         IC    A,DCBRECFM
         SRL   A,6
         LA    A,FORMATS(A)
         MVC   RECFM(1),0(A)
         LA    A,RECFM+1
         TM    DCBRECFM,B'00100000'
         BZ    *+12
         MVI   0(A),C'T'
         LA    A,1(A)
         TM    DCBRECFM,B'00010000'
         BZ    *+12
         MVI   0(A),C'B'
         LA    A,1(A)
         IC    B,DCBRECFM
         SLL   B,29
         SRL   B,31
         LA    B,PCCC(B)
         MVC   0(1,A),0(B)
         SPACE 3
* MACRO FORMAT,ACCESS METHOD
         MVC   MACRF,BLANKS
         SPACE 1
         TM    DCBMACR,B'10000000' TEST FOR EXCP
         BO    EXCP
         SPACE 1
         TM    DCBMACR,B'11000000' TEST FOR BSAM
         BNZ   NOTBSAM
         TM    DCBMACR+1,B'11000000'
         BZ    BSAM
NOTBSAM  EQU   *
         SPACE 1
         TM    DCBMACR,B'10100000' CHECK FOR QSAM
         BNZ   NOTQSAM
         TM    DCBMACR+1,B'10100000'
         BZ    QSAM
NOTQSAM  EQU   *
         SPACE 1
         MVC   ACCESS,=CL8' INVALID'
         B     MACRFXX
         SPACE 1
EXCP     MVC   ACCESS,=CL8'    EXCP'
         B     MACRFXX
         SPACE 1
BSAM     MVC   ACCESS,=CL8'    BSAM'
         LM    A,B,=A(MAC1BS1,MAC2BS1)
         B     MACRFDMP
         SPACE 1
QSAM     MVC   ACCESS,=CL8'    QSAM'
         LM    A,B,=A(MAC1QS1,MAC2QS1)
*        B     MACRFDMP
         SPACE 1
MACRFDMP LR    1,A                 BYTE 1 MACRF CODES
         LA    D,DCBMACRF          ADRS OF DCBMACRF
         ST    D,0(1)              STORE FOR BYTESCAN
         BAL   14,BYTESCAN
         L     C,NEXTADRS
         MVC   0(C),C','
         LA    C,1(C)
         LR    1,B                 BYTE 2 MACRF CODES
         USING BS,1
         ST    C,BSOUT
         DROP  1
         LA    D,DCBMACRF+1
         ST    D,0(1)
         BAL   14,BYTESCAN
         L     C,NEXTADRS
         MVC   0(C),C')'
MACRFXX  EQU   *
*
         XPRNT LINE2,LEN2
         MVC   RECFM(5),RECFM-1
         EJECT
*        BFALN, BFTEK, BUFCB, BUFL, BUFNO
*
*              BUFFER ALIGNMENT
         IC    A,DCBBFALN
         SLL   A,30
         SRL   A,27
         LA    A,ALIGN(A)
         MVC   BFALN(5),0(A)
*              BUFFERING TECHNIQUE
         IC    A,DCBBFTEK
         SLL   A,25
         SRL   A,29
         LA    A,TECH(A)
         MVC   BFTEK(1),0(A)
*              BUFFER CONTROL BLOCK ADDRESS
         L     A,DCBBUFCB
         LA    A,0(A)
         ST    A,FULL
         UNPK  DWORD(7),FULL+1
         TR    DWORD(6),HEXTAB
         MVC   BUFCB(6),DWORD
*              BUFFER LENGTH
         LH    A,DCBBUFL
         CVD   A,DWORD
         MVC   BUFL(6),EDIT
         ED    BUFL(6),DWORD+5
*              NUMBER OF BUFFERS
         SR    A,A
         IC    A,DCBBUFNO
         CVD   A,DWORD
         MVC   BUFNO(4),EDIT
         ED    BUFNO(4),DWORD+6
*
         XPRNT LINE3,LEN3
         EJECT
*        DSORG, EODAD, EROPT
*
*              DATA SET ORGANIZATION
         LA    1,DCBDSORG
         MVC   LRECL(6),EDIT
         BAL   14,BASE2
         SLL   1,1
         LA    A,ORGANS(1)
         MVC   DSORG(2),0(A)
*              END OF DATA ADDRESS
         L     A,DCBEODAD
         LA    A,0(A)
         ST    A,FULL
         UNPK  DWORD(7),FULL+1(4)
         TR    DWORD(6),HEXTAB
         MVC   EODAD(6),DWORD
*              ERROR OPTION
         LA    1,DCBEROPT
         BAL   14,BASE2
         SLL   1,2
         LA    A,ERRORS(1)
         MVC   EROPT(3),0(A)
         SPACE 3
* DCBOPTCD
         MVC   OPTCD,BLANKS
         L     1,=A(DMPOPTCD)
         LA    A,DCBOPTCD
         ST    A,0(1)
         BAL   14,BYTESCAN
*
         XPRNT LINE4,LEN4
         SPACE 3
*
*        OUTPUT DCB CIND FLAGS
*
* CLEAR OUTPUT BUFFER
         LM    A,B,=A(CINDOUT,CINDSAVE)
         MVC   0(133,A),0(B)
         LM    A,C,=A(CINDOUT+133,133,CINDOUT+7*133)
         MVI   0(A),C' '
CINDBLNK MVC   1(133,A),0(A)
         BXLE  A,B,CINDBLNK
         SPACE 1
* CALL BYTESCAN SUBROUTINE TO FILL IN OUTPUT FIELDS
         L     1,=A(DMPCND1)
         LA    A,DCBCIND1          ADRS OF CIND 1 BYTE
         ST    A,0(1)              STORE IN PARM FOR BYTESCAN
         BAL   14,BYTESCAN
         L     1,=A(DMPCND2)
         LA    A,DCBCIND2          ADRS OF CIND BYTE 2
         ST    A,0(1)              STORE IN PARM FOR BYTESCAN
         BAL   14,BYTESCAN
         SPACE 1
* PRINT OUTPUT BUFFER
         LM    A,C,=A(CINDOUT,133,CINDOUT+7*133)
CINDPRNT XPRNT 0(A),133
         BXLE  A,B,CINDPRNT
         EJECT
*              THAT'S ALL FOLKS
         L     1,SAVEPARM          PARM LIST ADRS
         CLI   0(1),X'80'          END OF LIST
         BE    PGMEXIT
         LA    1,4(1)              NEXT LIST ELEMENT
         B     PGMSTART
         SPACE 1
PGMEXIT  LM    0,15,SAVEALL
         SPM   14
         BR    14
         SPACE 10
BYTESCAN DS    0H
         STM   14,12,12(13)
         USING BS,1
         LM    A,E,BS              LOAD PARM REGS
         USING BITFLG,C
BSLOOP   MVC   BSWORK,0(A)         WORK ON SOURCE BYTE
         NC    BSWORK,BFMASK       PATTERN MASK
         CLC   BSWORK,BFMATCH      COMPARE WITH WANTED PATTERN
         BNE   BSNEXT                   NO MATCH
         EX    D,MVC1              MOVE MESSAGE TO OUTPUT FIELD
         AR    B,E                 NEXT ADRS IN OUTPUT BUFFER
BSNEXT   L     C,BFLINK            NEXT NODE ADRS
         LTR   C,C                 END OF LIST ???
         BNZ   BSLOOP                   NO
         ST    B,NEXTADRS
         LM    14,12,12(13)
         BR    14
MVC1     MVC   0(*-*,B),BFOUT      MOVE MESSAGE TO OUTPUT FIELD
NEXTADRS DS    A                   NEXT ADRS OF OUTPUT BUFFER
BSWORK   DS    CL1
         SPACE 10
A        EQU   3
B        EQU   4
C        EQU   5
D        EQU   6
E        EQU   7
F        EQU   8
Z        EQU   11
*
LINE     DC    10C' '
         DS    8CL9
LEN      EQU   *-LINE
*
DWORD    DS    D
EDIT     DC    C' ',15X'20'
FULL     DS    F
HEXTAB   EQU   *-239
         DC    C' 0123456789ABCDEF'
LINE1    DC    0D'0',C'0'
         DC    C'DDNAME='
DDNAME   DC    CL8' ',C' '
STATUS   DC    CL3' ',C' OPEN'
LEN1     EQU   *-LINE1
         DC    (133-LEN1)C' '
         SPACE 1
LINE2    DC    0D'0',C'0'
         DC    C' BLKSIZE='
BLKSIZE  DC    CL6' '
         DC    C' LRECL='
LRECL    DC    CL6' '
         DC    C' RECFM='
RECFM    DC    CL5' '
ACCESS DC CL8' ',C' ACCESS METHOD'
         DC    C' MACRF=('
MACRF    DC    CL14' '
LEN2     EQU   *-LINE2
         DC    (133-LEN2)C' '
         SPACE 1
LINE3    DC    0D'0',C'0'
         DC    C' BFALN='
BFALN    DC    CL5' '
         DC    C' BFTEK='
BFTEK    DC    CL1' '
         DC    C' BUFCB='
BUFCB    DC    CL6' '
         DC    C' BUFL='
BUFL     DC    CL6' '
         DC    C' BUFNO='
BUFNO    DC    CL4' '
LEN3     EQU   *-LINE3
         DC    (133-LEN3)C' '
         SPACE 1
LINE4    DC    0D'0',C'0'
         DC    C' DSORG='
DSORG    DC CL3' '
         DC    C' EODAD='
EODAD    DC    CL6' '
         DC    C' EROPT='
EROPT    DC    CL3' '
         DC    C' OPTCD='
OPTCD    DS    CL8
LEN4     EQU   *-LINE4
         DC    (133-LEN4)C' '
ALIGN    DC    CL8' ',CL8'F-DCB',CL8'D',CL8'F-DD'
TECH     DC    C' ERES A '
FORMATS  DC    C' VFU'                 RECORD FORMATS
PCCC     DC    C' MA '                 PRINTER CARRIAGE CONTROL CHAR
BLANKS   DC    256C' '
ORGANS   DC    C'  ISPSDA******POU **'
ERRORS   DC    C'    ACC SKP ABE ',6C'*** '
         EJECT
BASE2    LA    A,8
BTEST    LA    B,POWERS(A)
         CLC   0(1,B),0(1)
         BE    BOKAY
         BCT   A,BTEST
         LA    A,9
BOKAY    LR    1,A
         BR    14
POWERS   DC    AL1(0,128,64,32,16,8,4,2,1)
SAVEPARM DS    A                   PARM LIST ADRS
ENDDCB   DS    A                   END OF D-C-B
HEADER2  DC    CL133'0CORE IMAGE        +0       +4       +8       +12(\
               C)'
DUMPLINE DC    CL133'             DD(XX)'
*
         LTORG
DMPCND1  DC    A(DCBCIND1-IHADCB,CINDOUT+10,CND1LST1,49,133)
DMPCND2  DC    A(DCBCIND2-IHADCB,CINDOUT+76,CND2LST1,49,133)
CND1LST1 DC    A(CND1LST2),X'80',X'80',CL50'TRACK OVERFLOW - NO DATA WR\
               ITTEN'
CND1LST2 DC    A(CND1LST3),X'40',X'40',CL50'SEARCH DIRECT'
CND1LST3 DC    A(CND1LST4),X'20',X'20',CL50'END OF VOLUMNE - EOB'
CND1LST4 DC    A(CND1LST5),X'10',X'10',CL50'END OF VOLUMNE - CHANNEL EN\
               D APPENDAGE'
CND1LST5 DC    A(CND1LST6),X'01',X'01',CL50'EXCHANGE BUFFERING SUPPORTE\
               D'
CND1LST6 EQU   0
CND2LST1 DC    A(CND2LST2),X'80',X'80',CL50'STOW PREFORMED'
CND2LST2 DC    A(CND2LST3),X'40',X'40',CL50'LAST I/O WAS WRITE RECORD 0\
               '
CND2LST3 DC    A(CND2LST4),X'20',X'20',CL50'CLOSE IN PROGRESS'
CND2LST4 DC    A(CND2LST5),X'10',X'10',CL50'PERMANENT I/O ERROR'
CND2LST5 DC    A(CND2LST6),X'08',X'08',CL50'OPEN ACQUIRED BUFFER POOL'
CND2LST6 DC    A(CND2LST7),X'04',X'04',CL50'CHAINED SCHEDULING SUPPORTE\
               D'
CND2LST7 DC    A(CND2LST8),X'02',X'02',CL50'F-E-O-V BIT'
CND2LST8 DC    A(CND2LST9),X'01',X'01',CL50'THIS IS A QSAM DCB'
CND2LST9 EQU   0
CINDSAVE DC    C'0',CL66'DCBCIND1',CL66'DCBCIND2'
CINDOUT  DS    8CL133
         SPACE
DMPOPTCD DC    A(DCBOPTCD-IHADCB,OPTCD,OPTCD1,0,1)
OPTCD2   DC    A(OPTCD3),X'40',X'40',C'U'
OPTCD3   DC    A(OPTCD4),X'20',X'20',C'C'
OPTCD4   DC    A(OPTCD5),X'10',X'10',C'H'
OPTCD5   DC    A(OPTCD6),X'08',X'08',C'Q'
OPTCD6   DC    A(OPTCD7),X'04',X'04',C'Z'
OPTCD7   DC    A(OPTCD8),X'02',X'02',C'T'
OPTCD8   EQU   0
         SPACE 1
MAC1BS1  DC    A(MAC1BS2),X'2020',C'R'
MAC1BS2  DC    A(MAC1BS3),X'0404',C'P'
MAC1BS3  DC    A(MAC1BS4),X'0202',C'C'
MAC1BS4  EQU   0
         SPACE 1
MAC2BS1  DC    A(MAC2BS2),X'2020',C'W'
MAC2BS2  DC    A(MAC2BS3),X'0808',C'L'
MAC2BS3  DC    A(MAC2BS4),X'0404',C'P'
MAC2BS4  DC    A(MAC2BS5),X'0202',C'C'
MAC2BS5  DC    A(MAC2BS6),X'0101',C'X'
MAC2BS6  EQU   0
         SPACE 1
MAC1QS1  DC    A(MAC1QS2),X'4040',C'G'
MAC1QS2  DC    A(MAC1QS3),X'1010',C'M'
MAC1QS3  DC    A(MAC1QS4),X'0808',C'L'
MAC1QS4  DC    A(MAC1QS5),X'0404',C'T'
MAC1QS5  DC    A(MAC1QS6),X'0202',C'C'
MAC1QS6  DC    A(MAC1QS7),X'0101',C'D'
MAC1QS7  EQU   0
         SPACE 1
MAC2QS1  DC    A(MAC2QS2),X'4040',C'P'
MAC2QS2  DC    A(MAC2QS3),X'1010',C'M'
MAC2QS3  DC    A(MAC2QS4),X'0808',C'L'
MAC2QS4  DC    A(MAC2QS5),X'0404',C'T'
MAC2QS5  DC    A(MAC2QS6),X'0202',C'C'
MAC2QS6  DC    A(MAC2QS7),X'0101',C'D'
MAC2QS7  EQU   0
         END
