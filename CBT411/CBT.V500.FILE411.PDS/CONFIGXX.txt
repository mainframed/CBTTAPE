CONFIGXX TITLE 'Construct CONFIGxx Member'
*-------------------------------------------------------------------*
* Name            : CONFIGXX
*
* Function        : This program will construct the CONFIGxx member
*                   based on the active system.
*                   The idea being that this program is run when you
*                   are satisfied that the system has everything
*                   online that you need.
*
*                   The output is written to the PARMLIB DDName
*
* Example JCL     : //CONFIG   EXEC PGM=CONFIGXX
*                   //STEPLIB  DD   DISP=SHR,DSN=some.dataset
*                   //PARMLIB  DD   DISP=SHR,DSN=SYS1.PARMLIB(CONFIG00)
*
*
* IBM Macros Used : MODID, STORAGE, TIME, UCBSCAN, UCBDEVN, UCBINFO,
*                   OPEN, PUT, CLOSE
*                   DCB, CVT, IEFUCBOB, IOSDPATH, IARRCE, IHAASCB,
*                   IHAASXB, IHAACEE
*
* Attributes      : Amode(31)
*                   Rmode(24)
*                   NORENT
*                   NOREUS
*                   NOREFR
*                   AC(0)
*
* Register Usage  :
*
* R1  -
* R2  - Device Type Table
* R3  - Work
* R4  - UCB
* R5  - CVT
* R6  - RCE
* R7  - Work
* R8  - Work
* R9  - Path Info Array
* R10 - Branch and Link
* R11 - Branch and Link
* R12 - Base reg
* R13 - Workarea
* R14 -
*
*
*-------------------------------------------------------------------*
* Changes
* 02/11/1999  Rob Scott     Code Written                         V1.0
* 23/02/2000  Rob Scott     Added the "CHP" cards                V1.1
* 17/05/2002  Bob Rutledge  Generate "OFFLINE" cards             V1.2
*                           Use ICHPT for "CHP" cards
*                           Swap Stage 4 and Stage 5
* 27/05/2002  Rob Scott     Cater for no ESTOR                   V1.3
*                           Include 'ONLINE' keyword on
*                           DEV statements for online devices
*-------------------------------------------------------------------*
CONFIGXX CSECT
CONFIGXX AMODE 31
CONFIGXX RMODE 24
         BAKR  R14,R0                 linkage stack
         LAE   R12,0(R15,0)           set R12 as base
         USING CONFIGXX,R12           address it
         MODID ,                      eyecatcher
GETWORK  EQU   *
*--------------------------------------------------------------------*
* Get some workarea storage and init to zeros.
*--------------------------------------------------------------------*
         STORAGE OBTAIN,              get the workarea storage         X
               LENGTH=WORKLEN,        this much                        X
               ADDR=(R13),            address in r13                   X
               SP=0,KEY=8,            subpool 0 storage key 8          X
               LOC=BELOW,             below the line                   X
               COND=NO                unconditional
         USING WORKAREA,R13           address workarea
         LR    R14,R13                Copy workarea address
         L     R15,=A(WORKLEN)        Get length of workarea
         XR    R0,R0                  Clear
         XR    R1,R1                  Clear
         MVCL  R14,R0                 Init to zeros
         MVC   4(4,R13),=C'F1SA'      set label in savearea
INIT     EQU   *
*--------------------------------------------------------------------*
* Open the PARMLIB dataset and write a comment indicating the
* time and date of the generation.
*--------------------------------------------------------------------*
         OPEN  (PARMLIB,(OUTPUT))     Open the dataset
         L     R5,CVTPTR              Get the CVT
         USING CVTMAP,R5              Address it
         TIME  DEC,TIMEDATE,          get time and date                X
               DATETYPE=YYYYMMDD,     ..in format yyyymmdd             X
               LINKAGE=SYSTEM
         MVC   OUTREC(80),BLANKS      Blank the time
         MVC   OUTREC(40),HEADER0     Copy in the header
         PUT   PARMLIB,OUTREC
         MVC   OUTREC(40),HEADER1     Blank the time
         MVC   OUTREC+2(34),=CL34'Generated by the CONFIGXX program'
         PUT   PARMLIB,OUTREC
         MVC   OUTREC(80),BLANKS      Blank the time
         MVC   OUTREC(40),HEADER1     Blank the time
         MVC   OUTREC+2(32),=CL32'     Date : yyyy/mm/dd'
         LA    R0,4                   Set length (yyyymmdd)
         LA    R1,TIMEDATE+8          Point to the hex
         LA    R15,UWORK              Point to the output
         BAL   R14,HEX2CHAR           Make printable
         MVC   OUTREC+14(4),UWORK     Copy in YYYY
         MVC   OUTREC+19(2),UWORK+4   Copy in MM
         MVC   OUTREC+22(2),UWORK+6   Copy in DD
         PUT   PARMLIB,OUTREC
         MVC   OUTREC(80),BLANKS      Blank the time
         MVC   OUTREC(40),HEADER1     Blank the time
         MVC   OUTREC+2(32),=CL32'     Time : hh.mm.ss'
         LA    R0,3                   Set length (hhmmss)
         LA    R1,TIMEDATE            Point to the hex
         LA    R15,UWORK              Point to the output
         BAL   R14,HEX2CHAR           Make printable
         MVC   OUTREC+14(2),UWORK     Copy in HH
         MVC   OUTREC+17(2),UWORK+2   Copy in MM
         MVC   OUTREC+20(2),UWORK+4   Copy in SS
         PUT   PARMLIB,OUTREC
         MVC   OUTREC(80),BLANKS      Blank the time
         MVC   OUTREC(40),HEADER1     Blank the time
         MVC   OUTREC+2(32),=CL32'     User : '
GETUSER  EQU   *
         L     R15,0(R5)              Get the TCB words
         L     R15,12(R15)            Get the ASCB
         L     R15,ASCBASXB-ASCB(R15) Get the ASXB
         L     R15,ASXBSENV-ASXB(R15) Get the ACEE address
         MVC   OUTREC+14(8),ACEEUSRI-ACEE(R15)
         PUT   PARMLIB,OUTREC
         MVC   OUTREC(40),HEADER0     Copy in the header
         PUT   PARMLIB,OUTREC
STAGE1   EQU   *
*--------------------------------------------------------------------*
* Stage One : Get the CPUs and for each one write out
*             a "CPU (x)" or "CPU (x),OFFLINE record
*--------------------------------------------------------------------*
         L     R6,CVTPCCAT            Get the PCCAT
         XR    R3,R3                  Clear
LOOPPCCA EQU   *
         MVC   OUTREC(80),BLANKS      Yes - blank line
         MVC   OUTREC(7),CPU          Move in 'CPU (x)'
         STCM  R3,B'0001',UWORK       Store CPU number
         LA    R0,1                   Set length for HEX2CHAR
         LA    R1,UWORK               Point to input
         LA    R15,SWORK              Point to output
         BAL   R14,HEX2CHAR           Convert to hex
         MVC   OUTREC+5(1),SWORK+1    Move in the CPU number
         ICM   R8,B'1111',0(R6)       Is there a PCCA ?
         BNZ   ISCPU                  Yes - card is OK
         MVC   OUTREC+7(8),=C',OFFLINE' Mark CP to be offline
ISCPU    EQU   *
         PUT   PARMLIB,OUTREC         Write it out
         LA    R3,1(R3)               Inc CPU count
         C     R3,=F'16'              last one ?
         BNL   STAGE2                 yes - exit
         LA    R6,4(R6)               Get next PCCA
         B     LOOPPCCA
STAGE2   EQU   *
*--------------------------------------------------------------------*
* Stage Two : Get the STOR value and write out a "STOR 0M-nnnM"
*             record
*--------------------------------------------------------------------*
         L     R15,CVTRLSTG           Get the Real Storage (K)
         LA    R15,1(R15)             Add one
         SRL   R15,10                 Divide by 1024 = Mb
         CVD   R15,DWORK              Convert to decimal
         MVC   UWORK(8),MASK          Copy in the mask
         ED    UWORK(8),DWORK+4       Make printable
         MVC   OUTREC(80),BLANKS      Blank the line
         MVC   OUTREC(8),STOR         Add 'STOR 0M-'
         MVI   UWORKLEN,8             Set max length of UWORK
         BAL   R10,STRIP              and strip leading chars
         LA    R1,OUTREC+8            Point to target area
         LA    R15,SWORK              Point to source
         XR    R14,R14                Clear
         IC    R14,SWORKLEN           Get the length
         BCTR  R14,R0                 -1 for execute
         EX    R14,MOVEDATA           Move it in
         XR    R14,R14                Clear
         IC    R14,SWORKLEN           Get the length
         AR    R1,R14                 Go to end of card
         MVI   0(R1),C'M'             add 'M' for Mb
         PUT   PARMLIB,OUTREC         Write out the record
STAGE3   EQU   *
*--------------------------------------------------------------------*
* Stage Three : Get the ESTOR value and write out a "ESTOR 0M-nnnM"
*--------------------------------------------------------------------*
         L     R6,CVTRCEP             get address of rce
         USING RCE,R6                 address it
         ICM   R15,B'1111',RCEESPL    Get the # expanded frames
         BZ    STAGE4
         SLL   R15,2                  x4 = amount in K
         SRL   R15,10                 Divide by 1024 = Mb
         CVD   R15,DWORK              Convert to decimal
         MVC   UWORK(8),MASK          Copy in the mask
         ED    UWORK(8),DWORK+4       Make printable
         MVC   OUTREC(80),BLANKS      Blank the line
         MVC   OUTREC(9),ESTOR        Add 'ESTOR 0M-'
         MVI   UWORKLEN,8             Set max length of UWORK
         BAL   R10,STRIP              and strip leading chars
         LA    R1,OUTREC+9            Point to target area
         LA    R15,SWORK              Point to source
         XR    R14,R14                Clear
         IC    R14,SWORKLEN           Get the length
         BCTR  R14,R0                 -1 for execute
         EX    R14,MOVEDATA           Move it in
         XR    R14,R14                Clear
         IC    R14,SWORKLEN           Get the length
         AR    R1,R14                 Go to end of card
         MVI   0(R1),C'M'             add 'M' for Mb
         PUT   PARMLIB,OUTREC         Write out the record
STAGE4   EQU   *
*--------------------------------------------------------------------*
* Stage Four  : Scan thru the CHPID array and write out a "CHP (xx)"
*               or "CHP (xx),OFFLINE" record for each channel
*--------------------------------------------------------------------*
         MVC   OUTREC(80),BLANKS      Blank the line
         MVC   OUTREC(40),HEADER0     Write a header
         PUT   PARMLIB,OUTREC         Write the record
         MVC   OUTREC(40),HEADER1     Write a header
         MVC   OUTREC+2(22),HEADER2
         PUT   PARMLIB,OUTREC         Write the record
         MVC   OUTREC(40),HEADER0     Write a header
         PUT   PARMLIB,OUTREC         Write the record
         L     R2,CVTICHPT            Point to channel array
         XR    R11,R11                Clear
LOOPCHAN EQU   *
         TM    0(R2),X'80'            Channel valid ?
         BZ    NEXTCHAN               No - get next
         MVC   OUTREC(80),BLANKS      Blank the line
         MVC   OUTREC(8),CHP          Move in model
         ST    R11,DWORK              Store channel number
         LA    R0,1                   Length of channel number
         LA    R1,DWORK+3             Point to device type
         LA    R15,OUTREC+5           Point to output area
         BAL   R14,HEX2CHAR           Convert to EBCDIC
         TM    0(R2),X'20'            Channel online ?
         BO    ISCHAN                 Yes - all set
         MVC   OUTREC+8(8),=C',OFFLINE' No - mark as offline
ISCHAN   EQU   *
         PUT   PARMLIB,OUTREC         Write the record
NEXTCHAN EQU   *
         LA    R2,1(R2)               Point to next channel
         LA    R11,1(R11)             add one to CHPid number
         C     R11,=F'256'            end yet?
         BL    LOOPCHAN
STAGE5   EQU   *
*--------------------------------------------------------------------*
* Stage Five  : Scan thru the UCBs and write out a "DEV (uuuu),(xx)",
*               "DEV (uuuu),OFFLINE" or "DEV (uuuu),(xx),OFFLINE
*               record for each device class
*--------------------------------------------------------------------*
         LA    R2,DEVTABLE            Point to device type table
LOOPDEVT EQU   *
         CLI   0(R2),X'FF'            End of table
         BE    RETURN                 Yes - finished
         MVC   OUTREC(80),BLANKS      Blank the line
         MVC   OUTREC(40),HEADER0     Write a header
         PUT   PARMLIB,OUTREC         Write the record
         MVC   OUTREC(40),HEADER1     Write a header
         MVC   OUTREC+2(22),1(R2)
         PUT   PARMLIB,OUTREC         Write the record
         MVC   OUTREC(40),HEADER0     Write a header
         PUT   PARMLIB,OUTREC         Write the record
         MVC   DEVCID(1),0(R2)        Copy in device class
*
         LA    R4,UCBAREA             Point to copy of UCB
         USING UCBCMSEG,R4            address it
         XC    WORKUCB,WORKUCB        Clear UCB workarea
UNITSCAN EQU   *
         UCBSCAN COPY,                Perform UCBSCAN                  X
               WORKAREA=WORKUCB,      Use this workarea                X
               UCBAREA=UCBAREA,       Copy UCB here                    X
               CMXTAREA=CMXTAREA,     UCB Common extension             X
               DEVCID=DEVCID,         Only find this device class      X
               DEVN=0,                Start at beginning               X
               RANGE=ALL,             Include 4-digit devices          X
               DYNAMIC=YES            and dynamic UCBs
         C     R15,=F'4'              check rc
         BH    UNITSCAN               If RC > 4 ignore
         BE    UNITFINI               If RC = 4 then finished
         MVC   VOLSER(6),UCBVOLI      Copy the Volser
         UCBDEVN DEVN=UNITADDR        Get the unit address
*
         MVC   OUTREC(80),BLANKS      Blank the line
         MVC   OUTREC(36),DEV         Setup the 'DEV' statement
         MVC   OUTREC+5(4),UNITADDR   copy in the unit address
         MVC   OUTREC+56(5),=C'Devt='
         TM    UCBSTAT,UCBONLI        Is it Online ?
         BNO   DEVPATHS               No - don't write volser
         CLI   DEVCID,X'20'           Is it DASD ?
         BNE   DEVPATHS               No - don't write volser
         MVC   OUTREC+45(4),=CL4'Vol='
         MVC   OUTREC+49(6),VOLSER
DEVPATHS EQU   *
         LA    R0,4                   Length of UCBTYP
         LA    R1,UCBTYP              Point to device type
         LA    R15,OUTREC+61          Point to output area
         BAL   R14,HEX2CHAR           Convert to EBCDIC
         MVC   OUTREC2,OUTREC         Copy the output card
         TM    UCBSTAT,UCBONLI        Is the device online ?
         BNO   DEVOFFLN               No - go mark device offline
         LA    R8,OUTREC+12           Point to first path in record
         LA    R10,OUTREC2+12         And in the other record too
         UCBINFO PATHINFO,            Get path information             X
               PATHAREA=PATHAREA,     Put in this area                 X
               DEVN=UCBCHAN           Use the device addr in the UCB
         LA    R9,PATHAREA            Point to path area
         USING PATH,R9                address it
         ICM   R3,B'1111',PATH#CHPIDS Get number of paths
         LA    R9,PATHCHPID           Point to path array
         USING PATHCHPIDARRAY,R9      Address it
LOOPPATH EQU   *
         TM    PATHBITS,PATHLPM+PATHPAM Online ?
         BNO   PTHOFFLN               No - mark the path offline
*
         LA    R0,1                   set length for HEX2CHAR
         LA    R1,PATHCHPID+1         Point to path number
         LR    R15,R8                 Point to output area
         BAL   R14,HEX2CHAR           Write out CHPid
         MVI   2(R8),C','             add a comma
         LA    R8,3(R8)               Point to next path
         B     NEXTPATH               Go see if there are more paths
PTHOFFLN EQU   *
         LA    R0,1                   set length for HEX2CHAR
         LA    R1,PATHCHPID+1         Point to path number
         LR    R15,R10                Point to output area
         BAL   R14,HEX2CHAR           Write out CHPid
         MVI   2(R10),C','            add a comma
         LA    R10,3(R10)             Point to next path
NEXTPATH EQU   *
         LA    R9,28(R9)              Get next path
         BCT   R3,LOOPPATH            Loop for all
ENDPATH  EQU   *
         BCTR  R8,R0                  Go back a space
         MVC   0(8,R8),=C'),ONLINE'
*
         PUT   PARMLIB,OUTREC         Write the record out
         LA    R0,OUTREC2+12          First path slot
         CR    R10,R0                 Any offline paths ?
         BE    UNITSCAN               No - look for another device
         BCTR  R10,0                  Yes - back up over the comma
         MVC   0(9,R10),=C'),OFFLINE' Terminate the offline card
         PUT   PARMLIB,OUTREC2        And write it
         B     UNITSCAN               Look for another device
DEVOFFLN EQU   *
         TM    UCBFLB,UCBNOCON        Is this device connected?
         BO    UNITSCAN               No subchannel, skip the device
         MVC   OUTREC+10(8),=C',OFFLINE' Mark path to be offline
         PUT   PARMLIB,OUTREC         Send the card along
         B     UNITSCAN               Onward
*
UNITFINI EQU   *
         LA    R2,23(R2)              Point to next entry
         B     LOOPDEVT
*
RETURN   EQU   *
         CLOSE (PARMLIB)              Close the dataset
         STORAGE RELEASE,             free workarea storage            X
               LENGTH=WORKLEN,        this much                        X
               ADDR=(R13),            address in r13                   X
               SP=0,KEY=8,            subpool 0 storage key 8          X
               COND=NO                unconditional
         XR    R15,R15                Clear RC
         PR
*
STRIP    EQU   *
*-------------------------------------------------------------------*
* Routine to strip leading blanks from the UWORK field and place
* result in the SWORK field.
* UWORKLEN contained the source length
* SWORKLEN contained the result length
*-------------------------------------------------------------------*
         XR    R0,R0                  Clear
         IC    R0,UWORKLEN            Get max loop
         LA    R1,UWORK               Point to 1st char
         LA    R15,SWORK              Point to output area
         MVC   SWORK(8),BLANKS        Blank it out
         XR    R14,R14                Clear
STRIPCLI EQU   *
         CLI   0(R1),C' '             Is it a blank ?
         BE    STRIPBLK               Yes - no copy performed
         MVC   0(1,R15),0(R1)         No - copy the data in
         LA    R15,1(R15)             and adjust pointers...
         LA    R1,1(R1)
         LA    R14,1(R14)             add to chars copied
         BCT   R0,STRIPCLI            Loop for all
         B     STRIPEXT               and quit
STRIPBLK EQU   *
         LA    R1,1(R1)               Point to next input char
         BCT   R0,STRIPCLI            and loop round
STRIPEXT EQU   *
         STCM  R14,B'0001',SWORKLEN   Store length
         BR    R10
*
HEX2CHAR EQU   *
*--------------------------------------------------------------------*
* Convert a hex string to EBCDIC
* Regs on entry :
*   R0  :  Length of entry
*   R1  :  Hex string
*   R15 :  Output area
* Regs used within routine
*   R7  :  Work reg
*--------------------------------------------------------------------*
LEFTHALF EQU   *
         XR    R7,R7                  Clear
         ICM   R7,B'0001',0(R1)       Load up a byte (000000ab)
         SRL   R7,4                   Remove last 4 bits (0000000a)
LEFTNUM  EQU   *
         CH    R7,=H'9'               00000000 - 00000009 ?
         BH    LEFTLTTR               higher - must be A-F
         AH    R7,=H'240'             xlate to F0-F9
         B     LEFTDONE
LEFTLTTR EQU   *
         AH    R7,=H'183'             xlate to C1-C6
LEFTDONE EQU   *
         STCM  R7,B'0001',0(R15)      Store in token
         LA    R15,1(R15)             Point to next char
RGHTHALF EQU   *
         XR    R7,R7                  Clear
         ICM   R7,B'0001',0(R1)       Load up a byte (000000ab)
         SLL   R7,28                  Remove first 4 bits (b0000000)
         SRL   R7,28                  and reset           (0000000b)
RGHTNUM  EQU   *
         CH    R7,=H'9'               00000000 - 00000009 ?
         BH    RGHTLTTR               higher - must be A-F
         AH    R7,=H'240'             xlate to F0-F9
         B     RGHTDONE
RGHTLTTR EQU   *
         AH    R7,=H'183'             xlate to C1-C6
RGHTDONE EQU   *
         STCM  R7,B'0001',0(R15)      Store in token
         LA    R15,1(R15)             Point to next char
         LA    R1,1(R1)               Point to next token byte
         BCT   R0,LEFTHALF            Loop for all bytes
         BR    R14                    return
*
*
*-------------------------------------------------------------------*
* Constants, Variables and DSECTs
*-------------------------------------------------------------------*
*
MOVEDATA MVC   0(0,R1),0(R15)         Executed MOVE
         LTORG
*
PARMLIB  DCB   DDNAME=PARMLIB,MACRF=PM,DSORG=PS,RECFM=FB,LRECL=80
*
CPU      DC    CL7'CPU (x)'
STOR     DC    CL8'STOR 0M-'
ESTOR    DC    CL9'ESTOR 0M-'
DEV      DC    CL36'DEV (uuuu),(                        '
CHP      DC    CL8'CHP (xx)'
*
MASK     DC    XL8'4020202020202120'
BLANKS   DC    CL80' '
HEADER0  DC    CL40'*--------------------------------------*'
HEADER1  DC    CL40'*                                      *'
HEADER2  DC    CL22'Channel Path Section'
DEVTABLE DC    X'80',CL22'TAPE Device Section'
         DC    X'20',CL22'DASD Device Section'
         DC    X'41',CL22'CTC Device Section'
         DC    X'40',CL22'COMMS Device Section'
         DC    X'10',CL22'DISP Device Section'
         DC    X'08',CL22'UNITREC Device Section'
         DC    X'04',CL22'CHAR Device Section'
         DC    X'FF',CL22'***End of Table***'
*
WORKAREA DSECT
SAVEAREA DS    18F                    save area
DWORK    DS    D                      Packed work field
TIMEDATE DS    2D                     Area for Time+Date
DEVCID   DS    X                      Device class ID
UWORKLEN DS    X                      Length of UWORK
UWORK    DS    CL8                    Unpacked work field
SWORKLEN DS    X                      Length of SWORK
SWORK    DS    CL8                    Stripped field
OUTREC   DS    CL80                   PARMLIB record
OUTREC2  DS    CL80                   Another for offline paths
         DS    0D
VOLSER   DS    CL6                    Volser
UNITADDR DS    CL4                    Unit address
         DS    0D
UCBRC    DS    F                      Return code from UCBSCAN
UCBRSN   DS    F                      Reason code from UCBSCAN
         DS    0D
UCBAREA  DS    CL48                   area to get UCB copy
UCBPAREA DS    CL48                   area to get UCB prefix copy
CMXTAREA DS    CL32                   area to get CMXT copy
WORKUCB  DS    CL100                  UCBSCAN workarea
         DS    0D
PATHAREA DS    CL256                  Area for path info
WORKLEN  EQU   *-WORKAREA
*
         CVT DSECT=YES,LIST=NO        CVT
         IEFUCBOB                     UCB
         IOSDPATH
         IARRCE
         IHAASCB
         IHAASXB
         IHAACEE
*
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         END
