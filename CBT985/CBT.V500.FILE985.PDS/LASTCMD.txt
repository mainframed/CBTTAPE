/* rexx */
 trace o
/* Get last command or previous commands.                    */

/* Used as a called rexx:                                    */
/* In calling program:                                       */
/* cmd = lastcmd()  obtains last command.                    */
/* cmd = lastcmd(1) obtains last command (same as previous)  */
/* cmd = lastcmd(2) obtains second most recent command       */
/* cmd = lastcmd(n) obtains the n-th command                 */
/*               starting from the most recent command,      */
/*               cycling thru the command stack as           */
/*               Command ==> retrieve                        */

/* On command line:                                          */
/* Command ===> tso lastcmd     <-- last command             */
/* Command ===> tso lastcmd 2   <-- next to last command     */
/* or cycle to last command if command stack contains only   */
/* one command.                                              */

/* Example of use:                                           */
/* When displaying a member list                             */
/*           VIEW      BOZO.PDS                              */
/*   Command ===> s * rexx01 AA BB                           */
/*              Name     Prompt                              */
/*   _________ MBR1                                          */
/*   _________ MBR2                                          */
/*   rexx01 executes on all members of the library.          */
/*   When it executes MBR1, it receives as only parameter    */
/*   'BOZO.PDS(MBR1)' and has no knowledge of AA BB.         */
/*   The last command in the command stack is:               */
/*   s * rexx01 AA BB                                        */
/*   AA BB is obtained by rexx01 with subword(lastcmd(),4).  */
/*   AA may possibly be an edit macro using parameter BB.    */

/*   There exist a rexx called retp which simulates          */
/*   Command ===> retp                                       */
/*   and undocumented                                        */
/*   address tso 'ispvcall status end'                       */
/*   which writes the ISPF command stack in a dataset        */
/*   allocated to ddname ispvcall                            */
/*   (default userid.ISPVCALL.TRACE).                        */
/*   cf. http://enterprisesystemsmedia.com ispvcall          */
/*   A parameter QUIET as in ISPDPTRC and ISPFTTRC, would    */
/*   be nice for ISPVCALL.                                   */

parse arg n .

/* ____ Argument validity check ____________________________ */
if n = '' then n = 1             /* last command             */
if datatype(n)  <> 'NUM' then do /* invalid argument         */
   parse source . . source .
   say source": There must be no argument or"
   say "      one numeric argument."
   say source": eg. cmd = lastcmd()  <-- most recent command"
   say source": eg. cmd = lastcmd(2) <-- second most recent command"
   say source": First argument provided was "word(arg(1),1)"."
   zispfrc = 16
   address ispexec 'vput zispfrc'
   exit zispfrc
end /* invalid argument                                      */
/* ____ End of argument validity check _____________________ */

 address ispexec; 'control errors return'; zerrmsg=''

 /* According to ISPF User's Guide:                                */
 /* "To force a return to the top of the stack,                    */
 /* clear the command field and press Enter."                      */
 /*                                                                */
 /* We use a specialized panel to do it that we name 'xispcmde'.   */
 /* This panel is imbedded in the source between *PANEL            */
 /* and *ENDPANEL                                                  */
 /* zcmd field in panel is initialized to ''.                      */
 /* 'control nondispl enter' was tried unsuccesfully.              */

    mypanel = 'xispcmde' /* panel between *PANEL and *ENDPANEL     */
    call panel mypanel /* copy imbedded panel to temp lib, libdef  */
    "control display lock"
    "display panel("mypanel")"
 /* Cycle thru command stack with 'retrieve'.                      */
 do i = 1 to n
    stack = 'retrieve'
    'display panel(ispcmde) command(stack)'
        retrieve_command_rc = rc
        call check_rc retrieve_command_rc,0,'retrieve command 'i
 end
    res = zcmd /* last retrieved command                           */

 /* Return to the top of the stack.                                */
    "control display lock"
    "display panel("mypanel")"
    call panel         /* libdef, free                             */

 address /* from ispexec                                           */
 if sysvar('sysnest') = 'YES' then return res /* nested            */
 else do                               /*    not nested            */
    select /* according to n                                       */
      when n = 1 then say "Last command: "res
      when n = 2 then say "Second most recent command: "res
      otherwise do /* n-th command                                 */
        say n"th command starting from last command and cycling: "
        say res
        end /* n-th command                                        */
    end /* select according to n                                   */
    zispfrc = 0
    address ispexec 'vput zispfrc'
    exit
 end                                   /*     not nested           */

/* __ Panel to issue commands with zcmd initialized to '' _________*/
/* delimited by *panel and *endpanel                               */
/*                                                                 */
/* It is placed in an unexecuted part of the rexx.                 */
/*                                                                 */
/* call panel 'xispcmde'                                           */
/* will extract what is between *panel and *endpanel               */
/* place it as a member named 'xispcmde' of a temporary library    */
/* and libdef this library.                                        */

*panel
)attr format(mix)
     _ type(input) caps(off) just(left)
)body cmd(zcmd) asis
     _zcmd


+
)init
&zcmd = ''
)reinit
&zcmd = ''
)proc
)end
*endpanel

/*_________________________________________________________________*/
panel: procedure expose set_panel
parse arg panel

 if set_panel = 1 then signal unset_panel
 set_panel = 1    /* switch                                        */

 set_panel:
 address tso

/* Extract imbedded panel into panel. stem _______________________ */
 panel.  = ''        /* initialize                                 */
 panel.0 = 0
 count= 0 /* panel stem index                                      */
 skip = 'yes'
 do i = 1 to sourceline()
    line = sourceline(i)
    select
      when translate(left(line,6)) = '*PANEL'     then skip = 'no'
      when translate(left(line,9)) = '*ENDPANEL'  then leave
      when skip = 'no' then do
        count = count + 1
        panel.count = line
        iterate
      end /* when skip = 'no'                                      */
      otherwise nop
    end /* select                                                  */
 end /* do i = 1 to sourceline()                                   */
 panel.0 = count
/* End of extract imbedded panel into panel. stem ________________ */

/*________  Allocate temporary panel library ______________________*/
   call bpxwdyn "alloc rtddn(paneldd) rtdsn(panelds) new",
                "dsntype(library,2) space(1,1) dir(1) tracks",
                "recfm(f,b) lrecl(80)"

        if result <> 0 then do /* allocation failed                */
           say
           say "Error in allocating panel library.",
               "Bpxwdyn rc = "result
           if datatype s99msg.0 = 'NUM' then
              if s99msg.0 > 0           then
                 do k = 1 to s99msg.0
                    say "  "s99msg.i
                 end /* do k = 1 to s99msg.0                            */
           call check_rc result,0,'bpxwdyn paneldd'
        end /* if result <> 0                                           */
/*________  End of allocate temporary panel library _______________*/

/* Reallocate paneldd,                                             */
/* will be used by execio (sequential) and libdef (partitioned)    */
   "alloc fi(paneldd) da('"panelds"("panel")') shr reuse "
         realloc_paneldd_rc = rc
         call check_rc realloc_paneldd_rc,0,'realloc paneldd'

/* Copy panel into temporary library member                        */
   address mvs "execio * diskw paneldd (stem panel. fini"
         execio_rc = rc
         call check_rc execio_rc,0,'execio'
   address /* from tso                                             */

/* Libdef temporary library                                        */
   address ispexec; 'control errors return';zerrmsg=''
     "libdef ispplib library id(paneldd) stack"
         libdef_paneldd_rc = rc
         call check_rc libdef_paneldd_rc,0,'libdef paneldd'
   address /* from ispexec                                         */

   return

 unset_panel:
     set_panel = 0    /* switch                                    */
     address ispexec "libdef ispplib  "
         libdef_rc = rc
         call check_rc libdef_rc,0,'libdef'
     msg_prev = msg('off')
       address tso   "free file(paneldd)"
     msg_off  = msg(msg_prev)
   return

/*_ End of panel procedure ________________________________________*/
 check_rc:

  /* call example:    call check_rc rc,0,'libdef isptlib'  */
  /* In case of error:
  ZEDMSGNO (message identifier), ZEDISMSG (short message text) and ZEDILMSG
  */
  if arg(1)<=arg(2) then return
  /* ISPEXEC or ISREDIT error:                             */
  if ZERRSM   <> 'ZERRSM'   then say 'ZERRSM   = 'ZERRSM
  if ZERRLM   <> 'ZERRLM'   then say 'ZERRLM   = 'ZERRLM
  if ZEDMSGNO <> 'ZEDMSGNO' then say 'ZEDMSGNO = 'ZEDMSGNO
  if ZEDISMSG <> 'ZEDISMSG' then say 'ZEDISMSG = 'ZEDISMSG
  if ZEDILMSG <> 'ZEDILMSG' then say 'ZEDILMSG = 'ZEDILMSG
  say 'rc = 'arg(1)
  if debug='DEBUG' then
    say 'FUNC='arg(3) 'RC='arg(1) 'ZERRMSG='zerrmsg
  zispfrc = 16
  address ispexec 'vput zispfrc'
  exit zispfrc
 /*________________________________________________________*/
