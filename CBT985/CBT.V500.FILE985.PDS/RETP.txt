/* rexx */
trace o
 parse source . . rexxname .

/* Get last command or previous commands.                    */

/* Used as a called rexx:                                    */
/* In calling program:                                       */
/* str = retp()  obtains last command in a string.           */
/* str = retp(1) obtains the last command (same as retp() ). */
/* str = retp(n) obtains the n-th most recent command        */
/*               (until the 25th most recent command).       */

/* str = retp('all') gives the previous commands             */
/* in a string.                                              */
/* Commands are separated by ' ; '                           */
/* Commands are the commands with at least one non space     */
/* character as would be given by                            */
/* Command ===> retp                                         */
/* in the same order                                         */
/* and their leading and trailing spaces have been stripped. */
/* Example: "tso time ; save ; cut   aa"                     */
/*           The most recent command is "tso time"           */

/* We assume that the number of previous commands            */
/* displayed by                                              */
/* Command ===> retp                                         */
/* is 25.                                                    */
/* (It corresponds to a default ISPF configuration           */
/*  parameter RETRIEVE_COMMAND_STACK_SIZE of 512.            */
/*  cf. Command ===> tso ispcconf   and option 1)            */

/* ========================================================= */
/* ___ Examples of code in calling program ________________
/*     to obtain previous commands.                          */
lastcmd = retp()

str = retp('all')
/* Last non empty 25 commands separated by ' ; '             */
/* string str to stem cmd.                                   */
cmd.  = ''       /* initialize                               */
cmd.0 = 0
if str <> '' then do
   str = str' ; '
   do i = 1 while pos(' ; ',str) > 0
      parse var str cmd.i ' ; ' str   /* split str           */
   end
   cmd.0 = i - 1
end /* if str <> ''                                          */

do i = 1 to cmd.0; say cmd.i; end     /* check               */

   ___ End of exampled of code in calling program __________ */
/* ========================================================= */

/* On command line:                                          */
/* Command ===> tso retp all                                 */
/* Command ===> tso retp 2                                   */

/* ____ Process as either a rexx or an edit macro __________ */

address isredit
'macro (parm)'
isr_rc = rc
if isr_rc = 0 then signal process_as_an_edit_macro /* then exit    */
/* if isr_rc = 0 then parm contains a number from 1 to 25 or 'ALL' */
else address /* resume previous environment                  */

/* I am a rexx                                               */
/* ____ Copy ispretp panel to temporary dataset ____________ */
/*      Edit it by calling myself as an edit macro.          */
/*      ispretp )INIT will contain selected command number   */
/*      and .resp = enter.                                   */
/*      Display panel ispcmde issuing retp command.          */
/*      retp command uses ispretp modified panel and         */
/*      ispcmde zcmd variable will contain selected command: */
/*                                                           */
/*      stack = "retp"                                       */
/*      "display panel(ispcmde) command(stack)"              */
/*      /* modified panel ispretp is used by retp */         */
/*      command = zcmd /* zcmd is a variable of ispcmde */   */
/*      /* no panel shown */                                 */
/* _________________________________________________________ */

parse arg parm .

/* ____ Argument validity check ____________________________ */
parm = translate(parm)
if parm = '' then parm = 1 /* last command                   */
if (datatype(parm)  <> 'NUM'     &,
    parm            <> 'ALL')    !,
   (datatype(parm)  =  'NUM'     & ,
    parm > 25)                       then do
   parse source . . rexxname .
   say rexxname": There must be no argument or"
   say "      one numeric argument from 1 to 25 or"
   say "      one argument with value 'ALL'."
   say rexxname": eg. str = retp()      <-- most recent command"
   say rexxname": eg. str = retp(2)     <-- second most recent command"
   say rexxname": eg. str = retp('all') <-- all commands"
   say rexxname": First argument provided was "word(arg(1),1)"."
   if sysvar('sysnest') = 'NO' then do   /* not nested       */
      zispfrc = 0
      address ispexec 'vput zispfrc'
      exit zispfrc
   end                                   /* not nested       */
   else do                               /*     nested       */
      say rexxname": Empty string returned."
      return ''
   end                                   /*     nested       */
end /* invalid argument                                      */
/* ____ End of argument validity check _____________________ */

/* ____ Copy ispretp panel to temporary dataset ____________ */
 address ispexec; 'control errors return';zerrmsg=''

 "lminit dataid(dd1) ddname(ispplib) enq(shr)"
         lmninit1_rc = rc
         call check_rc lminit1_rc,0,'lminit ispplib'

 call allocate_ddout
 "lminit dataid(dd2) ddname(ddout) enq(shr)"
         lmninit2_rc = rc
         if lmninit2_rc <> 0 then call lmfree_dd1
         call check_rc lminit2_rc,0,'lminit ddout'

 "lmcopy fromid("dd1") todataid("dd2") frommem(ispretp)"
         lmcopy_rc = rc
         if lmcopy_rc <> 0 then do
            say 'Copy error.'
            say 'lmcopy_rc = 'lmcopy_rc
            call say_lmcopy_error
            call lmfree_dd1
            call lmfree_dd2
            call check_rc lmcopy_rc,0,'lmcopy'
         end /* if lmcopy_rc <> 0                          */

 call lmfree_dd1
         if lmfree1_rc <> 0 then
            call check_rc lmfree1_rc,0,'lmfree dd1'

 /* Make ispretp modified panel to be selected first       */
 "libdef ispplib library id(ddout) stack"
        libdef1_rc = rc
        if libdef1_rc <> 0 then do
           say 'Libdef with id(ddout) error.'
           say 'libdef rc = 'libdef1_rc
           call lmfree_dd2
           call check_rc libdef1_rc,0,'libdef with id(ddout)'
        end /* if libdef1_rc <> 0                          */

/* ____ End of copy ispretp panel to temporary dataset ___ */

  cmd. = '' /* non empty command lines stem                */
  k = 0  /* counter for cmd.                               */
  do i = 1 to 25
     if parm <> 'ALL' & parm <> i then iterate

/* parm = 'ALL' or parm = i                                */
/* ____ Edit member ispretp in temporary dataset _________ */
/*      to get i-th command                                */
 "edit dataid("dd2") member(ispretp) macro("rexxname") parm(i)"
         edit_rc = rc
         if edit_rc <> 0 then do
            say 'Edit error.'
            say 'edit_rc = 'edit_rc
            call lmfree_dd2
            call check_rc edit_rc,0,'edit'
         end /* if edit_rc <> 0                            */

 /* Refresh panel cache after editing panel ispretp        */
 /* more than once (was not in cache after first edition). */
 if parm = 'ALL' & i > 1 then call refresh_panel_cache
/* ____ End of edit member ispretp in temporary dataset __ */
/* ____ Issue retp _______________________________________ */

  stack = "retp" /* variable compulsary                    */
     /* Using modified panel ISPRETP with                  */
     /* retsel = i and .resp = enter                       */
     /* added at end of )INIT section.                     */

 /*  address tso "ispdptrc"      <-- for debugging         */
     "display panel(ispcmde) command(stack)"
 /*  command in zcmd                                       */
 /*  address tso "ispdptrc"      <-- for debugging         */

/* ____ End of issue retp ________________________________ */

     cmd = strip(zcmd) /* zcmd result from retp (ispcmde field) */
     if cmd <> '' then do
        k = k + 1
        cmd.k = cmd
     end /* if cmd <> ''                                   */
  end /* do i = 1 to 25                                    */
  cmd.0 = k

  "libdef ispplib"
             libdef2_rc = rc
             call check_rc libdef2_rc,0,'second libdef'

  call lmfree_dd2
          if lmfree2_rc <> 0 then
             call check_rc lmfree2_rc,0,'lmfree dd2'

  x = msg("off")
  address tso
    "free dd(ddout)"
    "delete '"dsnout"'"
  address
  x = msg(x)

  /* stem cmd. to string str (str returned)                */
  str = ''
  do i = 1 to cmd.0
     str = str' ; 'cmd.i
  end /* do i = 1 to cmd.0                                 */

  /* remove ' ; ' at start                                 */
  if str <> '' then str = substr(str,4)

  address
  if sysvar('sysnest') = 'NO' then do /* not nested        */
     if parm = 'ALL' then
       do i = 1 to cmd.0
          say 'i =' right(i,2) cmd.i
       end /* do i = 1 to cmd.0                            */
     else select /* on parm value                          */
       when parm = 1 then say 'Most recent command: 'str
       when parm = 2 then say 'Second most recent command: 'str
       when parm = 3 then say 'Third most recent command: 'str
       otherwise say parm'-th most recent command: 'str
     end /* select on parm value                           */
     zispfrc = 0
     address ispexec 'vput zispfrc'
     exit zispfrc
  end /* if sysvar('sysnest') = 'NO'     not nested        */
  else return str /* nested                                */

  /* end of rexx processing                                */

/* _______________________________________________________ */

 process_as_an_edit_macro:
 trace o

 '(mbr)  = member'

 l1 = "*rexx(*)"
 l2 = "  retsel = '"parm"'"
 l3 = "*endrexx"
 l4 = ".resp = enter"
 /* Edition of ispretp )INIT:                               */
 /* Find first occurence of '.resp'  in column 1.           */
 /* If found, insert panel rexx just before .resp           */
 /* If .resp not found,                                     */
 /* find first occurence of ')PROC ' in column 1.           */
 /*      If found, insert panel rexx and .resp              */
 /*      just before )PROC                                  */

 string = '.resp'
 "find '"string"' 1 first"
 find_rc = rc
 /*
 Return codes:
 0 Normal completion
 4 String not found
 12 Syntax error
 20 Severe error
 */
 if find_rc = 0 then do /* .resp already present           */
     /* Insert panel rexx before .resp                     */
     do k = 1 to 3
   /*  "line_before .zcsr = '"l1"'"                        */
       "line_before .zcsr = '"value('l'k)"'"
     end /* do k = 1 to 3                                  */
 end /* .resp already present                              */
 else do /* .resp not present (first time panel edited)    */
    string = ')PROC '
    "find '"string"' 1 first"
    find_rc = rc
    select /* according to find_rc for )PROC               */

      when find_rc = 0 then do /* )PROC found              */

     /* Insert panel rexx and .resp before )PROC           */
        do k = 1 to 4
          "line_before .zcsr = '"value('l'k)"'"
        end /* do k = 1 to 4                               */

      end /* when find_rc = 0     )PROC found              */

      when find_rc = 4 then do /* string was not found     */
        say 'Member 'right(mbr,8)', find rc = 'find_rc
        say 'String = 'string' was not found.'
        'can'
      end /* when find_rc = 4                              */

      otherwise do /* find_rc = 12 or 20                   */
        say 'Member 'right(mbr,8)', find rc = 'find_rc
        if find_rc = 12 then say 'Syntax error'
        if find_rc = 20 then say 'Severe error'
        'can'
      end /* otherwise                                     */

    end /* select according to find_rc for )PROC           */
 end     /* .resp not present                              */

 'save'
 'end'

 exit 0 /* from edit macro processing                      */

 /* _____ Following routines used by rexx processing _____ */

 check_rc: /* used by rexx */

  /* call example:    call check_rc rc,0,'libdef isptlib'  */
  /* In case of error:
  ZEDMSGNO (message identifier), ZEDISMSG (short message text) and ZEDILMSG
  */
  if arg(1)<=arg(2) then return
  /* ISPEXEC or ISREDIT error:                             */
  if ZERRSM   <> 'ZERRSM'   then say 'ZERRSM   = 'ZERRSM
  if ZERRLM   <> 'ZERRLM'   then say 'ZERRLM   = 'ZERRLM
  if ZEDMSGNO <> 'ZEDMSGNO' then say 'ZEDMSGNO = 'ZEDMSGNO
  if ZEDISMSG <> 'ZEDISMSG' then say 'ZEDISMSG = 'ZEDISMSG
  if ZEDILMSG <> 'ZEDILMSG' then say 'ZEDILMSG = 'ZEDILMSG
  /* "LMCLOSE DATAID("dataid")" */
  say 'rc = 'arg(1)
  if debug='DEBUG' then
    say 'FUNC='arg(3) 'RC='arg(1) 'ZERRMSG='zerrmsg
  zispfrc = 16
  address ispexec 'vput zispfrc'
  exit zispfrc
 /*________________________________________________________*/

allocate_ddout: procedure expose rexxname prefix dsnout

ran  = right(random(1,99999),5,'0')
call set_up_prefix /* create prefix for new file           */
 parse source . . rexxname .
dsnout   = prefix"."rexxname".R"ran
msg_prev = msg('off')
address tso "alloc file(ddout) da('"dsnout"') new catalog",
       "dsorg(po) dsntype(library 2) tracks space(5,5) dir(5)",
       "recfm(f b) lrecl(80) blksize(0) reuse"
alloc_rc = rc
/* zerrmsg = '' */                           /* debug */
/* call check_rc alloc_rc,0,'alloc ddout' */ /* debug */
if alloc_rc <> 0 then do
   say rexxname "could not allocate ddout."
   say "We exit with code 16."
   say "alloc rc = "alloc_rc
   zispfrc = 16
   address ispexec 'vput zispfrc'
   exit zispfrc
end /* if alloc_rc <> 0                                     */
msg_off  = msg(msg_prev)

return
/* End of allocate_ddout                                    */

/*__________________________________________________________*/

 set_up_prefix:

 /* Set up new output file prefix.                                    */
 prefix = sysvar('syspref')              /* tso profile prefix        */
 uid    = sysvar('sysuid')               /* tso userid                */
 if prefix = '' then prefix = uid        /* use uid if null prefix    */
 if prefix <> '' & prefix <> uid then    /* different prefix than uid */
    prefix = prefix'.'uid                /* use prefix.uid            */

 return
 /*___________________________________________________________________*/

 say_lmcopy_error: procedure expose lmcopy_rc
   select /* according to lmcopy return code                          */
     when lmcopy_rc = 0 then return /* for completeness               */
     when lmcopy_rc = 4 then do
          say "The 'from' data set is empty or"
          say "no members matched the specified pattern",
              "in the 'from' data set."
     end /* when lmcopy_rc = 4                                        */
     when lmcopy_rc = 8 then do
          say "The from-member-name was not found or"
          say "the same name was specified for to-member-name and",
          say "from-member-name."
     end /* when lmcopy_rc = 8                                        */
     when lmcopy_rc = 10 then do
          say "No data set is associated with the given data ID."
     end /* when lmcopy_rc = 10                                       */
     when lmcopy_rc = 12 then do
          say "One of these:"
          say "A like-named member already exists in the 'to' data set"
          say "  and the Replace option was not specified"
          say "One or more members of the 'to' data set are 'in use',"
          say "  either by you or by another user, and could not be copied"
          say "Invalid data set organization"
          say "Data set attribute invalid for copying or copying packed data"
          say "Open error"
          say "LOCK parameter is specified"
     end /* when lmcopy_rc = 12                                       */
     when lmcopy_rc = 16 then do
          say "Truncation error."
     end /* when lmcopy_rc = 16                                       */
     when lmcopy_rc = 20 then do
          say "Severe error."
     end /* when lmcopy_rc = 20                                       */
     otherwise nop
   end /* select according to lmcopy return code                      */
   return
 /*___________________________________________________________________*/

 lmfree_dd1:

 "lmfree dataid("dd1")"
 lmfree1_rc = rc
 return
/*____________________________________________________________________*/

 lmfree_dd2:

 "lmfree dataid("dd2")"
 lmfree2_rc = rc
 return
/*____________________________________________________________________*/

refresh_panel_cache: procedure
/* Refresh panel cache method from                         */
/* http://ibmmainframes.com/about59391.html                */
/* Author: Stefan  Germany                                 */
/* Thank you Stefan.                                       */
  address ispexec
  do i = 1 to 12
     /* non display, simulate END key                      */
     "control nondispl end"
     /* isr00301 isr00302 ... isr00312 reflist panels      */
     "display panel(isr003"right(i,2,'0')")"
  end /* do i = 1 to 12                                    */
  address
return
/*_________________________________________________________*/
