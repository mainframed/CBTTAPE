/* rexx */
 trace o

 /* Obtain duplicate member names for specified libraries                   */
 /* using ISRDDN DUP                                                        */

 if sysvar(sysispf) <> 'ACTIVE' then do
   say rexxname 'must be invoked from ISPF, terminating!'
   exit 12
 end
 zerrmsg=''
 parse source . . rexxname .    /* rexxname in upper case                   */

 /*_________________________________________________________________________*/
 /* Obtain dsnames                                                          */
 call set_up_panel /* contains libdef ispplib dataset id( ) stack           */
 address ispexec
 'control errors return'
 'display panel(panel)'  /* obtain dsnames                                  */
 drc = rc
 address
 if drc = 8 then do    /* user pressed PF3   Do not process  Abandon        */
    'end'              /* exit edit macro mode                              */
    call remove_panel  /* contains libdef ispplib                           */
    exit 0
 end /* if drc = 8        user pressed PF3                                  */
 call remove_panel /* contains libdef ispplib                               */

 /*_________________________________________________________________________*/
 /* Set up dsname list                                                      */
 dsnlist = ''
 do i = 1 to 16
    interpret "dsn = dsn"i
    select /* add quotes if necessary                                       */
      when dsn         = ''  then iterate
      when left(dsn,1) = "'" then dsnlist = dsnlist dsn
      otherwise                   dsnlist = dsnlist "'"dsn"'"
    end /* select                                                           */
 end /* do i = 1 to 16                                                      */

 /*_________________________________________________________________________*/
 /* Allocate $DUP                                                           */
 "alloc shr reuse fi($DUP) da("dsnlist")"
 alloc_rc = rc
 call check_rc alloc_rc,0,'alloc fi($DUP)'

 /*_________________________________________________________________________*/
 /* Search for duplicate member names using ISRDDN                          */

 address ispexec
 "control errors return"
 zparm = 'only $DUP;dup'  /* 'o $DUP;dup' or 'dup $DUP'                     */
 "select pgm(isrddn) newappl(isr) suspend scrname(ddlist) parm(&zparm)"
 if zerrmsg <> '' then 'setmsg msg('zerrmsg')'
 address
 "free dd($DUP)"
 exit 0

 /*_________________________________________________________________________*/
 /* Called subroutines                                                      */

 check_rc:
  /* call example:    call check_rc rc,0,'libdef isptlib'                   */
  /* In case of error:
  ZEDMSGNO (message identifier), ZEDISMSG (short message text) and ZEDILMSG
  */
  if arg(1)<=arg(2) then return                        /* rc=0              */
  if zerrmsg <> '' then address ispexec 'setmsg msg('zerrmsg')'
  /* ISPEXEC or ISREDIT error:                                              */
  if ZERRSM   <> 'ZERRSM'   then say 'ZERRSM   = 'ZERRSM
  if ZERRLM   <> 'ZERRLM'   then say 'ZERRLM   = 'ZERRLM
  if ZEDMSGNO <> 'ZEDMSGNO' then say 'ZEDMSGNO = 'ZEDMSGNO
  if ZEDISMSG <> 'ZEDISMSG' then say 'ZEDISMSG = 'ZEDISMSG
  if ZEDILMSG <> 'ZEDILMSG' then say 'ZEDILMSG = 'ZEDILMSG
  if debug='DEBUG' then
    say 'FUNC='arg(3) 'RC='arg(1)
  else say 'rc = 'arg(1)
  exit arg(1)

 set_up_panel:
  /* build panel for displ                                                  */
  address tso
  newstack
   queue ')attr'
   queue '~ type(text)   intens(low)  color(blue)    skip(on)'
   queue '_ type(text)   intens(low)  color(turq)    skip(on)'
   queue '] type(text)   intens(low)  color(yellow)  skip(on)'
   queue '< type(input)  intens(high) color(yellow)  caps(off)'
   queue '! type(text)   intens(low)  color(green)   skip(on)   hilite(reverse)'
   queue '+ type(nt)'
   queue ')body'
   queue ']                C H E C K    F O R   D U P L I C A T E S'
   queue '_                                                               '
   queue '    To leave: press PF3.                                        '
   queue '    Please enter the library dataset names with possible        '
   queue '    duplicate member names.                                     '
   queue '    Dsnames are fully qualified in upper case with or without quotes.'
   queue '_                                                               '
   queue '   !dsn1  = <dsn1                                        +'
   queue '   !dsn2  = <dsn2                                        +'
   queue '   !dsn3  = <dsn3                                        +'
   queue '   !dsn4  = <dsn4                                        +'
   queue '   !dsn5  = <dsn5                                        +'
   queue '   !dsn6  = <dsn6                                        +'
   queue '   !dsn7  = <dsn7                                        +'
   queue '   !dsn8  = <dsn8                                        +'
   queue '   !dsn9  = <dsn9                                        +'
   queue '   !dsn10 = <dsn10                                       +'
   queue '   !dsn11 = <dsn11                                       +'
   queue '   !dsn12 = <dsn12                                       +'
   queue '   !dsn13 = <dsn13                                       +'
   queue '   !dsn14 = <dsn14                                       +'
   queue '   !dsn15 = <dsn15                                       +'
   queue '   !dsn16 = <dsn16                                       +'
   queue ')init'
   queue '   vget (dsn1,dsn2,dsn3,dsn4,dsn5,dsn6,dsn7,dsn8) profile'
   queue '   vget (dsn9,dsn10,dsn11,dsn12,dsn13,dsn14,dsn15,dsn16) profile'

   /* Customization (in comment)
   /* Specific rexx DUPCOPY                                        */
   queue '   if (&dsn2 = &Z)                                       '
   queue '       &dsn2 = "XXX.XXXX.COPYLIB"                        '
   /* End, specific rexx DUPCOPY                                   */
      End, customization (in comment)                              */

   queue '   .cursor = dsn1'
   queue ')reinit'
   queue '   refresh(*)'
   queue ')proc'
   queue "   ver (&dsn1,dsname)"
   queue "   ver (&dsn2,dsname)"
   queue "   ver (&dsn3,dsname)"
   queue "   ver (&dsn4,dsname)"
   queue "   ver (&dsn5,dsname)"
   queue "   ver (&dsn6,dsname)"
   queue "   ver (&dsn7,dsname)"
   queue "   ver (&dsn8,dsname)"
   queue "   ver (&dsn9,dsname)"
   queue "   ver (&dsn10,dsname)"
   queue "   ver (&dsn11,dsname)"
   queue "   ver (&dsn12,dsname)"
   queue "   ver (&dsn13,dsname)"
   queue "   ver (&dsn14,dsname)"
   queue "   ver (&dsn15,dsname)"
   queue "   ver (&dsn16,dsname)"
   queue '   vput (dsn1,dsn2,dsn3,dsn4,dsn5,dsn6,dsn7,dsn8) profile'
   queue '   vput (dsn9,dsn10,dsn11,dsn12,dsn13,dsn14,dsn15,dsn16) profile'
   queue ')end'

   address tso
   ddnm = 'dd'random(1,99999)
   /* temporary ispllib library                                             */
   ispltemp = userid()"."rexxname"."ispltemp"."ddnm
   "alloc file("ddnm") unit(vio) reuse tracks space(1,1) dir(1)",
   "recfm(f b) lrecl(80) blksize(0) dsn('"ispltemp"')"
   ddnm1 = 'dd'random(1,99999)
   "alloc file("ddnm1") dsn('"ispltemp"(panel)') shr reuse"
   "execio" queued() "diskw "ddnm1" (finis"
   delstack

   /* Check content
   "execio * diskr "ddnm1" (stem abc. finis"
   do i = 1 to abc.0; say "abc " i abc.i; end
   */

   address ispexec
   "libdef ispplib dataset id(",
     "'"ispltemp"'",
     ") stack"

   address /* resume environment                                            */
 return

 remove_panel:
   address ispexec "libdef ispplib"

   address tso
   xmsg = msg(off)
     "free dd(ddnm ddnm1)"
     "delete '"ispltemp"'"
   xmsg = msg(xmsg)         /* reset                                        */
   address /* resume environment                                            */

 return
