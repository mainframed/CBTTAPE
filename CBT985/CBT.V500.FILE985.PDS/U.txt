/* rexx */
trace o
/*________________________________________________________________*/
/*                                                                */
/* Edit macro executing a z/OS Unix command.                      */
/*________________________________________________________________*/


/*________________________________________________________________*/
/*                                                                */
/* Help starts                                                    */
/* u is an edit macro executing a z/OS Unix command.              */
/*                                                                */
/* Input to the z/OS Unix command is the                          */
/* presently edited file.                                         */
/* The result of the z/OS Unix command, if not empty,             */
/* replaces the presently edited file,                            */
/* unless a supplementary keyword 'info' is added .               */
/* If 'info' is added to the Unix command (anywhere)              */
/* the result of the Unix command is placed into infolines.       */
/*                                                                */
/* The user may cancel the result with:                           */
/* Command ===> can                                               */
/* or restore the previous content of a library member with:      */
/* Command ===> u r  (or u re, u res, u rest etc... or u u)       */
/* or save the result.                                            */
/*                                                                */
/* If the word 'info', in mixed case, does not appear at right    */
/* of u, then edit macro u by default, saves the previous content */
/* of a non empty edited library member in another member         */
/* called 'SAVEU' before replacing this member                    */
/* by the result of an Unix command.                              */
/*                                                                */
/* If keyword 'info', in mixed case, is placed anywhere after u,  */
/* then the result of an Unix command                             */
/* does not replace the content but is added                      */
/* at top of member or sequential file, as infolines.             */
/* These infolines may be deleted with RES or made datalines with */
/* line commands MD and MDD.                                      */
/* The previous content is unchanged and saved in member 'SAVEU'. */
/*                                                                */
/* Examples of use in View or Edit:                               */
/*                                                                */
/* Command ===> u           (or u help)        <- shows help      */
/* Command ===> u u         (or u r or u re)   <- restore         */
/* Command ===> u cut -c 1-10                  <- first 10 char   */
/* Command ===> u cut -c 1-10,12-              <- col 11 disappears */
/* Command ===> u sed 's/A.*b/DEF/g'           <- case sensitive  */
/* Command ===> u iconv -f 1047 -t 1147        <- Unix to French  */
/* Command ===> u awk '{print $1}'             <- Keep 1st field  */
/* Command ===> u cal 2020                     <- all year        */
/* Command ===> u cal sep 1752                 <- missing days    */
/* Command ===> u man sed                                         */
/* Command ===> u man sed | cut -c 1-80                           */
/* Command ===> zexpand                                           */
/*     u cat "//'BOZO.CNTL(HAYSTACK)'" | grep -E 'N.*dle'         */
/* Command ===> u cut -c 1-10 info   <- infolines, no replacement */
/* Command ===> u info cut -c 1-10   <- infolines, no replacement */
/* Command ===> u man woman info     <- infolines, no replacement */
/* Command ===> u ls -al oedit       <- oedit temporary result    */
/* Command ===> u oedit man awk      <- oedit temporary result    */
/* oedit is used for long output lines and u may be reissued.     */
/* Non empty temporary result replaces member or sequential file. */
/* Command ===> can                  <- not to SAVE u's result    */
/* Command ===> u s (or u sa, u sav) <- explicit save in 'SAVEU'  */
/* edit macro u used to process z/OS Unix commands in member:     */
/*            BOZO.CNTL(A)                                        */
/* Command ===> u sh                  or ===> u sh info           */
/* ****** *********************                                   */
/* 000001 whoami                                                  */
/* 000002 pwd                                                     */
/* 000003 printenv                                                */
/* ****** *********************                                   */
/* Help ends                                                      */
/*________________________________________________________________*/
/*                                                                */

/* for bpxwunix command codepage:                                 */
lc_all = "En_US.IBM-1140"  /* lc_all = "Fr_FR.IBM-1147"           */
parse source . . rexxname .    /* rexxname in upper case          */

address isredit
'macro (parm)' /* parm may be up to 200 characters in mixed case  */
call check_parm                /* for help                        */

/* SAVE or RESTORE                                                */
W1 = translate(word(parm,1))
/* If first word of parm translated to uppercase begins by 'S'    */
   if abbrev('SAVE',W1,1)    then do /* explicit save             */
      call save
      exit 0
   end /* if abbrev('SAVE',W1,1)        explicit save             */
/* If first word of parm translated to uppercase begins by 'R'    */
/* or is rexxname (Command ===> u u) then restore                 */
   if abbrev('RESTORE',W1,1) !,      /* or                        */
      W1 = rexxname          then do /* restore                   */
      call restore
      exit 0
   end /* if abbrev('RESTORE',W1,1)           restore             */

/* Set up z/OS Unix command to execute:                           */
/* temp is a temporary file in /tmp                               */
/* /tmp is normally automatically cleaned.                        */
/* It will be copied to replace the presently edited file         */
/* then deleted (not moved to avoid a possible confirmation       */
/* panel).                                                        */
temp = '/tmp/temp'random(1,99999)  /* temporary file              */
if info = "no"
   /* Use of temp file is possibly faster than using stem stdout. */
   /* We use stem stdout. only when infolines have to be created. */
   then cmd = parm '>' temp /* redirect standard output to temp   */
   else cmd = parm          /* stdout. to be written as infolines */
/* Copy content of presently edited file into stack.              */
trace_previous = trace("o") /* no trace                           */
'(last) = linenum .zl'
drop line.
do i = 1 to last
   '(li)  = line 'i
   line.i = li
end /* do i = 1 to last                                           */
line.0 = last
trace(trace_previous)

/* Issue z/OS unix command.                                       */
call set_env /* z/OS Unix environment variables                   */
drop stderr.; stderr.0 = 0    /* initialize standard error stem   */
drop stdout.; stdout.0 = 0    /* used only if info = "yes"        */
call bpxwunix cmd,line.,stdout.,stderr.,env.
bpxwunix_rc = rc

call check_for_error
drop line. stderr.

call save      /* save of a library member in member 'SAVEU'      */

if info = "no" then do /* no word 'info' after u, default case    */

   /* Using oedit: Command ===> u cal 2020 oedit                  */
   /* Content of member not replaced if temp made empty with oedit */
   if oedit = "yes" then address tso "oedit '"temp"'"

   member_replaced = "no"
   if size(temp) > 0 then do
      /* Remove all file content.                                 */
      'del all .zf .zl'

      /* Copy temporary file then delete it.                      */
      'copy 'temp after .zf
      member_replaced = "yes"
      call delete_temp_file
   end /* if size(temp) > 0                                       */

end /* if info = "no"      no word 'info' after u, default case   */
else do /* info = "yes"    word 'info' after u                    */

   /* Insert stdout. as infolines at top of edited member or      */
   /* sequential file.                                            */
   do i = stdout.0 to 1 by -1
      stdout = stdout.i
      'line_after 0 = infoline (stdout)'
   end /* do i = stdout.0 to 1 by -1                              */
   drop stdout.

end     /* info = "yes"    word 'info' after u                    */

'(member) = member'         /* Check if editing a library member. */
if member <> '' &,          /* library member                     */
   member_replaced = "yes" then do
   zedsmsg = 'u u <- to restore'   /* top right corner            */
   zedlmsg = 'You may issue Command ===> can or Command ===> save',
             'or Command ===> u restore'
end /* if member <> '' and replaced                               */
else do /* not a library member                                   */
   zedsmsg = ''
   zedlmsg = ''
end     /* not a library member                                   */
address ispexec "setmsg msg(isrz000)"

exit 0
/*________________________________________________________________*/
/*                                                                */
check_parm:

/* Check for special keywords: HELP, OEDIT, INFO                  */
/* OEDIT: oedit the temporary file temp.                          */
/*        if this file made empty, no change to edited member.    */
/* INFO : Do not create a temporary file.                         */
/*        stdout. written at top edited member as infolines.      */

upper_parm = translate(parm) /* parm in uppercase                 */
W1 = word(upper_parm,1)      /* first word of upper_parm          */
if W1 = ''      !,     /* no parm or first word in list           */
   wordpos(W1,'HELP -H --HELP ? /H') > 0 !, /* or 'HELP somewhere */
   wordpos('HELP',upper_parm) > 0  then do
     call show_help
     exit 0
end /* if help needed                                             */

oedit = 'no' /* Shall we oedit the temporary file?                */
             /* If empty, it will not replace the edited member.  */
k = wordpos('OEDIT',upper_parm)
if k > 0 then do /* oedit present in parm                         */
   oedit = "yes"
   parm = delword(parm,k,1)  /* remove oedit from parm            */
end /* oedit present in parm                                      */

info = 'no' /* Is string 'info' in mixed case, present in parm?   */
            /* If yes, sandard output is placed at top of edited  */
            /* member as infolines, and                           */
            /* edited member is not saved and not changed.        */
            /* If string 'info' in mixed case, is not present     */
            /* in parm then edited member is saved and replaced.  */
/* Default behavior is to save and replace.                       */
/* We should add 'info' not to (save and replace).                */
k = wordpos('INFO',upper_parm)
if k > 0 then do /* info present in parm                          */
   info = "yes"
   parm = delword(parm,k,1)  /* remove info from parm             */
end /* info present in parm                                       */

return
/*________________________________________________________________*/
/*                                                                */
set_env:

env.0 = 3
env.1 = "PATH=.:/bin:usr/local/bin"
env.2 = "LC_ALL="lc_all
env.3 = "_BPX_SHAREAS=MUST" /* ddname friendly, e.g. cat DD:DD01  */
                            /* awk ... < cat "dd:dd01(mbr)"       */

return
/*________________________________________________________________*/
/*                                                                */
check_for_error: procedure expose rexxname bpxwunix_rc stderr. env. temp

  if stderr.0 > 0 then do /* stderr.0 was expected                */
     say rexxname": Execution of 'cmd' failed."
     /* For debug:
     do i = 1 to stderr.0
        say 'stderr.'i' = 'stderr.i
     end /* do i = 1 to stderr.0                                  */
     */
     /* Insert stderr. as infolines at top of edited member or    */
     /* sequential file.                                          */
     do i = stderr.0 to 1 by -1
        stderr = stderr.i
        'line_after 0 = infoline (stderr)'
     end /* do i = stderr.0 to 1 by -1                            */

     if info = "no" then call delete_temp_file

     zispfrc = 16
     address ispexec 'vput zispfrc'
     exit zispfrc
  end /* if stderr.0 > 0, stderr.0 was expected                   */

return
/*________________________________________________________________*/
/*                                                                */
delete_temp_file: procedure expose env. temp

  drop stderr2.; stderr2.0 = 0
  cmd2 = 'rm 'temp /* remove temporary file                       */
  call bpxwunix cmd2,,,stderr2.,env.
     do i = 1 to stderr2.0 /* stderr2.0 is expected               */
        say 'stderr2.'i' = 'stderr2.i
     end /* do i = 1 to stderr2.0                                 */
  drop env.

return
/*________________________________________________________________*/
/*                                                                */
save:

  /* If a library member, save it in member 'SAVEU'               */
  address isredit
    '(member) = member'
    'isredit (recs) = linenum .zl'   /* recs is total line number */
    if member <> '' & recs <> 0 then do
       save_member = 'SAVE'strip(left(rexxname,2))
       /* if rexxname = 'U' then save_member = 'SAVEU'            */
       'repl ('save_member') .zf .zl' /* create if does not exist */
       zedsmsg = member' saved in 'save_member
       /*         ----+----1----+----2----   zedsmsg max 24 char  */
       zedlmsg = 'Backup copy created in member 'save_member'.'
    end /* if member <> '' and is non empty                       */
    else do /* file edited not a library member                   */
       zedsmsg = 'Only for non empty mbr'
       zedlmsg = 'Save command available only to save',
                 'a non empty library member.'
    end /* file edited not a library member                       */
  address /* from isredit                                         */

  address ispexec "setmsg msg(isrz000)"

return
/*________________________________________________________________*/
/*                                                                */
restore:

  /* If a library member, restore it from member 'SAVEU'.         */
  address isredit
    '(member) = member'
    if member <> '' then do
       save_member = 'SAVE'strip(left(rexxname,2))
       /* if rexxname = 'U' then save_member = 'SAVEU'            */
       'del all .zf .zl' /* delete all present content            */
       'copy ('save_member') after .zf'  /* restore               */
       zedsmsg = 'Member restored'
       /*         ----+----1----+----2----   zedsmsg max 24 char  */
       zedlmsg = 'Member restored from backup copy 'save_member
    end /* if member <> ''                                        */
    else do /* file edited not a library member                   */
       zedsmsg = 'Only for member'
       zedlmsg = 'Restore command available only to restore',
                 'a library member.'
    end /* file edited not a library member                       */
  address /* from isredit                                         */

  address ispexec "setmsg msg(isrz000)"

return
/*________________________________________________________________*/

size:
/* Size in bytes of a regular file.                    */
/* -1 if unknown, 0 if empty                           */
/* Example of call:                                    */
/*   temp = '/u/bozo/test01.txt'                       */
/*   size = size(temp)                                 */
parse arg path

/* call syscalls 'ON' */
parse source . . . . . . envir .
/* envir: host command environment                     */
if envir <> 'SH' then
   if syscalls('ON') > 3 then
      do
      say 'Unable to establish the SYSCALL environment'
      say 'Return code : 'rc
      return -1      /* -1: cannot obtain size         */
      end

address syscall
  syscmd ='stat (path) st.'
  syscmd /* execute *                                  */
  syscmd_rc = rc
  call syscall_rc /* will return ok or nok             */
address /* from syscall                                */

if ok & st.0 <> 0 then ret = st.st_size
                  else ret = -1
return ret

/*_____________________________________________________*/
syscall_rc: procedure expose syscmd syscmd_rc retval errno errnojr,
                             ok nok /* <- output       */

nok = syscmd_rc<>0 ! retval<0 ! retval=0 & (errno<>0 ! errnojr<>0)
ok  = 1 - nok            /* ok  boolean, 1 if true     */

if nok then do
   say 'syscall command = 'syscmd
   say

   /* not_OK information string                        */
   not_OK = '(rc<>0 ! retval<0 ! retval=0 & (errno<>0 ! errnojr<>0))'
   say 'not_OK = 'not_OK

   say 'syscall rc                   =  'syscmd_rc
   say 'syscall return value retval  = 'retval
   say 'syscall return code  errno   = 'errno
   say 'syscall reason code  errnojr = 'errnojr

   'strerror' errno errnojr 'err.' /* address syscall propagated */
   /* if rc=0 & retval>=0 then do                      */
   if datatype(err.0) = 'NUM' then
      if err.0 > 0 then do
         if err.se_errno  <> '' & err.se_errno  <> 'ERR.SE_ERRNO'  then
            say '   errno   : 'err.se_errno
         if err.se_reason <> '' & err.se_reason <> 'ERR.SE_REASON' then
            say '   errnojr : 'err.se_reason
         if err.se_action <> '' & err.se_action <> 'ERR.SE_ACTION' then
            say '   action  : 'err.se_action
      end /* if err.0 > 0                              */
   say
end /* if nok                                          */

return
/*___________________________________________________________________*/

show_help:

 say ' Help for 'rexxname':'
 /* Show help between 'Help starts' and 'Help ends'                  */
 help = 'no'
 line_counter = 0
 do i = 1 to sourceline()
    if pos('Help starts',sourceline(i)) > 0 then do
       help = "yes"
       iterate
    end /* if pos('Help starts',sourceline(i)) > 0                   */
    if pos('Help ends',sourceline(i)) > 0 then leave
    if help = 'yes' then do /* record sourceline(i)                  */
       line_counter = line_counter + 1
       line.line_counter = sourceline(i)
    end /* if help = 'yes'                                           */
 end /* do i = 1 to sourceline()                                     */
 line.0 = line_counter
 call visualize
return
/*___________________________________________________________________*/

 visualize: procedure expose line. rexxname
 /* Visualize.                                                */
 if line.0 > 0 then do
    if sysvar(sysispf) <> 'ACTIVE' then do
       do i = 1 to line.0
          say line.i
       end /* do i = 1 to line.0                              */
       zispfrc = 0
       exit zispfrc
    end /* if sysvar(sysispf) <> 'ACTIVE'                     */
    else do /*       ispf ACTIVE                              */

       /* Allocate visualization file.                        */
       address tso
       ran  = right(random(1,99999),5,'0')
       ddnm = 'dd'ran                          /* choose random ddname */
       call set_up_prefix /* create prefix for new file                */
       dsnprint = prefix"."rexxname".R"ran
       msg_prev = msg('off')
       "alloc file("ddnm") da('"dsnprint"') new catalog",
       "tracks space(5,5) reuse lrecl(132) recfm(f b) blksize(0)"
       alloc_rc = rc
       if alloc_rc <> 0 then do
          say rexxname "could not allocate the visualization file."
          say "We exit with code 16."
          say "alloc rc = "alloc_rc
          zispfrc = 16
          address ispexec 'vput zispfrc'
          exit zispfrc
       end /* if alloc_rc <> 0                                */
       msg_off  = msg(msg_prev)
       /* End of allocate visualization file.                 */

       /* Write on visualization file.                        */
       "execio" line.0  "diskw" ddnm "(stem line. finis"
       execio_rc = rc
       if execio_rc <> 0 then do
          say rexxname "could not write on visualization file."
          say "We exit with code 16."
          say "execio rc = "execio_rc
          zispfrc = 16
          address ispexec 'vput zispfrc'
          exit zispfrc
       end /* if execio_rc <> 0                               */
       /* End of write on visualization file.                 */

       /* Visualize.                                          */
       zedsmsg = 'F3 to exit'  /* top right corner            */
       zedlmsg = 'To exit, press F3.',
                 'Temporary help file will be deleted.'
       ispexec "setmsg msg(isrz000)"
       ispexec "view dataset('"dsnprint"')"
       /* End of visualize.                                   */

       /* Clean up.                                           */
       msg_prev = msg('off')
          "free fi("ddnm")"
          "del  '"dsnprint"'"
       msg_off  = msg(msg_prev)     /* reset                  */
       /* End of clean up.                                    */

    end /* ispf ACTIVE                                        */
 end /* if line.0 > 0                                         */

 return
 /*___________________________________________________________________*/

 set_up_prefix:

 /* Set up new output file prefix.                                    */
 prefix = sysvar('syspref')              /* tso profile prefix        */
 uid    = sysvar('sysuid')               /* tso userid                */
 if prefix = '' then prefix = uid        /* use uid if null prefix    */
 if prefix <> '' & prefix <> uid then    /* different prefix than uid */
    prefix = prefix'.'uid                /* use prefix.uid            */

 return
 /*___________________________________________________________________*/
