  /* rexx */
  /* trace r                                                      */

  /*______________________________________________________________*/
  /* Convert non migrated library from                            */
  /* PDS            to PDS or PDSE version 1 or PDSE version 2,   */
  /* PDSE version 1 to PDS or PDSE version 1 or PDSE version 2,   */
  /* PDSE version 2 to PDS or PDSE version 1 or PDSE version 2,   */
  /* to unload or reload a library.                               */
  /* Defaut is conversion to PDSE version 2.                      */
  /* It is possible to add parameters to output allocation.       */
  /*                                                              */
  /* It can compress a PDS and change the PDSE version 2 maxgens  */
  /* parameter.                                                   */
  /*______________________________________________________________*/
  /*                                                              */

  /* Individual convert a pds or a pdse version 1 to              */
  /*  a pdse version 2 with the implied or specified              */
  /*  maxgens parameter.                                          */

  parse arg parm               /* upper case                      */
  parse source . . rexxname .

  help_only = 'no'
  if length(parm) = 0     then help_only = 'yes'
  if pos('HELP',parm) > 0 then help_only = 'yes'
  if pos('-H',parm) > 0   then help_only = 'yes'

  wpos = wordpos('SIMULATE',parm)
  if wpos > 0 then do
     simulate = 'yes'
     parm = delword(parm,wpos) /* clean up parm                  */
  end /* if wpos > 0 */
  else simulate = 'no'

  if sysvar(sysenv)  = 'BACK' !,
     sysvar(sysnest) = 'YES' !,
     help_only       = 'yes'       then do

  say "__________________________________________________________"
  say "V2 converts to PDSE version 2 by default."
  say "V2 works on levels",
      "with * and % and possible supplementary qualifiers.    "
  say
  say "Examples of use in ISPF 3.4:                           "
  say "Convert to DSNTYPE(LIBRARY,2):                         "
  say "V2       USER01.LOAD1      <-- Default MAXGENS         "
  say "//V2     USER01.LOAD2      <-- Group convert           "
  say "         USER01.LOAD3          with default MAXGENS    "
  say "//       USER01.LOAD4                                  "
  say "V2 / 0   USER01.LOAD5      <-- Convert with MAXGENS=0  "
  say "V2 / 2   USER01.LOAD6      <-- Convert with MAXGENS=2  "
  say "Convert to DSNTYPE(LIBRARY,1):                         "
  say "V2 / DSNTYPE(LIBRARY,1)                                "
  say "Convert to PDS:                                        "
  say "V2 / DSNTYPE(PDS) DIR(500)                             "
  say "If a rexx such as VIEWIT is available                  "
  say " (VIEWIT: rexx to outtrap, execute parm, outtrap",
  say "and view what was said):                               "
  say "viewit v2 /7931.LOAD4                                  "
  say
  say "Examples of use on Command line:                       "
  say "Command ===> TSO V2               <-- HELP             "
  say "Command ===> TSO V2 AB.CDEF.CNTL  <-- Default MAXGENS  "
  say "Command ===> TSO V2 AB.*.C%EF.**.*ABC* SIMULATE        "
  say "Command ===> TSO V2 AB.*.C%EF.**.*ABC*                 "
  say "             * any number of characters                "
  say "             % exactly one character                   "
  say "             ** any number of qualifiers including zero"
  say "             *ABC* any qualifier with ABC inside       "
  say "Command ===> TSO V2 AB.CDEF.** 3  <-- MAXGENS=3        "
  say "Command ===> tso viewit v2 USER01.load*",
                   "dir(500) blksize(32760) dsntype(pds)"
  say "Command ===> tso viewit v2 ab.cdef.cntl dsntype(library,1)"
  say
  say "If used, parameter MAXGENS must be less or equal to"
  say " IGDSMSxx PARMLIB parameter MAXGENS_LIMIT of "maxgens_limit()
  /* Cf.   D SMS,OPTIONS        SET SMS,MAXGENS_LIMIT=9          */
  say "__________________________________________________________"

  end /* if sysvar(sysenv) = 'BACK' or nested or help_only = 'yes' */

  if help_only = 'yes' then exit

  /* Library of type 2:                                          */
  /* maxgens is the number of member generations                 */
  /*         with the oldest deleted.                            */
  /*         If not specified, then system default               */
  /*         (parameter MAXGENS_LIMIT( ) in MACLIB(IGDSMSXX)).   */
  /* maxgens of 1 means member plus one generation               */

  /* This rexx does not process dsnames ending                   */
  /* in .V2- or .ANC- as it creates itself temporary             */
  /* datasets ending this way, in order to protect from a loop.  */

  say
  say "Command processed: "rexxname arg(1)

  trace o
  parse var parm level rest
  /* arg(1) is stripped and is read only.                        */
  /* Please note that we process a level and not a dsname.       */
  /* Any further qualifiers will be included.                    */
  /* rest, if present, is used for output allocation.            */

  level = strip(level,,"'") /* remove surrounding quotes if any  */

  /* Process rest.                                               */
  /* If rest begins by a numeric, this numeric is maxgens.       */
  maxgens = '' /*     default                                    */
  if datatype(word(rest,1)) = 'NUM' then do
     maxgens = " maxgens("word(rest,1)")"
     rest    = subword(rest,2)
  end /* if datatype(word(rest,1)) = 'NUM'                       */
  if pos('DSNTYPE',rest) = 0 then               /* default       */
     rest = 'DSNTYPE(LIBRARY,2) 'rest
  /* Pick up extra control parameters in rest                    */
  /* (for added functionalities):                                */

  /* if NOCONTROL added to parameters, no verification of        */
  /*    migration status.                                        */
  /* Example:                                                    */
  /* Command ===> tso v2 USER01.load 3 nocontrol                 */
  /*   If USER01.LOAD is LIBRARY version 2 maxgens 2,            */
  /*                  will be maxgens 3.                         */
  wpos = wordpos('NOCONTROL',rest)
  if wpos > 0 then do
     nocontrol = 'yes'
     rest = delword(rest,wpos) /* clean up rest                  */
  end /* if wpos > 0 */
  else nocontrol = 'no'

  /* if DSNTYPE added to parameters, override of                 */
  /* default output file DSNTYPE(LIBRARY,2)                      */
  /* (for instance to change a LIBRARY version 2 to a PDS        */
  /* when possible).                                             */
  /* Examples:                                                   */
  /* Command ===> tso v2 USER01.load dsntype(pds) dir(500)       */
  /*   If USER01.LOAD is PDS or LIBRARY, will be PDS,            */
  /*                  if PDS, will be compressed.                */
  /* Command ===> tso v2 USER01.load dsntype(library,1)          */
  /*_____________________________________________________________*/
  /*                                                             */
  address ispexec
  'control errors return'

  /*                  S T U C T U R E

   lmdinit            provide a level
      lmdlist           obtain dataset
        convert to PDSE version 2
   lmdfree

  */

  "lmdinit listid(lidv)  level("level")"
  lmdinitrc = rc
  if lmdinitrc = 0 then
    do /* lmdinit OK                                             */
      dsn = "                  "
      keepon = "yes"
      do until keepon = "no "
        "lmdlist listid("lidv") option(list) dataset(dsn) stats(yes)"
        lmdlistrc = rc
        select /* according to lmdlistrc                         */
          when lmdlistrc = 0  then do /* dsn found               */
               saveenv = address()
               address TSO
                 call process  /* dsn                            */
               address value saveenv
            end /* lmdlistrc = 0  dataset found                  */
          when lmdlistrc = 8 then keepon = "no " /* end of list  */
          otherwise /* lmdlistrc not 0 and not 8, error          */
               say_error('lmdlist' lmdlistrc 'dsn')
        end /* select according to lmdlistrc                     */
      end /* do until keepon = "no "                             */
      "lmdfree listid("lidv")"
    end /* lmdinitrc = 0                                         */
  else /* lmdinit failed                                         */
         say_error('lmdinit' lmdinitrc 'level')
  zispfrc = 0
  "vput zispfrc"
  exit zispfrc
  /*_____________________________________________________________*/
  say_error: procedure expose level dsn zerrlm
    parse arg function thisrc atlevel
    say
    say function' error:'
    if atlevel = 'dsn' then say 'dsn    = 'dsn
                       else say 'level  = 'level
    say function' failed with rc = 'thisrc
    say         "ZERRLM  = '"strip(zerrlm)"'"
    say
    zispfrc = 16
    "vput zispfrc"
    exit zispfrc
  /*_____________________________________________________________*/

  process:

    if simulate = 'yes' then do
       say "Sysdsn('"dsn"') = "sysdsn("'"dsn"'")
       enq_number = whohas(dsn) /* how many enqueues?            */
       if enq_number > 0 then do
          say " Contention on '"dsn"':",
               enq_number' enqueue(s).'
       end /* if enq_number > 0                                  */
       else say ' No enqueue.'
       say
       return
    end /* if simulate = 'yes'                                   */

    if checkdsn(dsn) > 0 then return

    /* Convert.                                                  */

    if nocontrol = 'no' then do /* control on by default         */

       /* Comment
       /* In older, more restrictive version                     */
       /* (now, we permit unloaded libraries and PDSE version 2):*/
       /* Do not process if not a PDS or a library:              */
          if pos(strip(zdldsntp),'PDS LIBRARY') = 0     then return
       /* Do not process if library but not version 1:           */
          if strip(zdldsntp) = 'LIBRARY' & zdldsnv <> 1 then return
       End of comment                                            */

       /* Do not process if migrated                             */
       /* or on volume with name containing 'MIG':               */
          if strip(zdlmigr) = 'YES'                     then return
          if pos('MIG',zdlvol) > 0                      then return
    end /* if nocontrol = 'no'     control on by default         */

    /* Avoid loop on temporary datasets .V2- and .ANC-           */
    if right(dsn,4) = '.V2-'                            then return
    if right(dsn,5) = '.ANC-'                           then return

  /*                  S T U C T U R E

   0) Should return to process next dsn at first problem.
   1) Allocate dsn.V2- using dsn as a model.
   2) Copy dsn on dsn.V2- with iebcopy.
   3) Check if no enqueue on dsn with d grs
         if enqueue, a) delete dsn.V2-,
                     b) return to process next dsn.
   4) Rename dsn in dsn.ANC- with ALTER NEWNAME,
      possible because of no enqueue.
   5) Rename dsn.V2- in dsn with ALTER NEWNAME
   6) Delete dsn.ANC-
   7) Return to process next dsn.

  */

    say
    say "dsn = "dsn
    say 'in process'

    time_stamp = t!!time('s')
    dsnprint = userid()."IEBCOPY."time_stamp   /* SYSPRINT file  */

    x = msg("off")      /* quiet delete                          */
    "delete '"dsnprint"' scratch purge"   /* avoid duplicate     */
    y = msg(x)          /* reset msg status                      */
    "allocate fi(SYSPRINT) da('"dsnprint"') reuse",
    "new catalog",
    "lrecl(125) recfm(v b a) blksize(27875)",
    "space(1 1) tracks"

    x = msg("off")      /* quiet free                            */
    "free     fi(SYSUT1)   da('"dsn"')"
    y = msg(x)          /* reset msg status                      */
    "allocate fi(SYSUT1)   da('"dsn"')    shr         reuse"

    x = msg("off")      /* quiet free and delete attempt         */
    "free     fi(SYSUT2)"
    "delete '"dsn".V2-' scratch purge"   /* avoid duplicate      */
    y = msg(x)          /* reset msg status                      */

    /* ucount(1) to avoid multi-volume                           */
    "allocate fi(SYSUT2)   da('"dsn".V2-') new catalog reuse ucount(1)",
                        "like('"dsn"')",
                        maxgens,   /* default empty              */
                        rest       /* default DSNTYPE(LIBRARY,2) */
    arc = rc
    if arc > 0 then do
       say "Allocate of new file "dsn".V2- gave code "arc
       say dsn" *** unchanged ***"
       return  /* process next dsn                               */
    end /* if arc > 0                                            */

    lib = "sys1.linklib"
    "call '"lib"(iebcopy)' 'COPY' "
    xrc = rc                /* save iebcopy return code          */

    if sysvar(sysenv) = 'FORE' then do /* View IEBCOPY sysprint  */
       "ispexec lminit dataid(dd1) dataset('"dsnprint"') enq(shr)"
       "ispexec view   dataid("dd1")"
       "ispexec lmfree dataid("dd1")"
    end /* if sysvar(sysenv) = 'FORE'                            */

    x = msg("off")  /* quiet free, delete                        */
    "free fi(SYSUT1,SYSUT2)" /* free fdn, dsn.V2-                */
    "delete '"dsnprint"' scratch purge"
    y = msg(x)

    /* if iebcopy ok: check for enqueues before dsn rename       */
    /*                rename     dsn into old dsn                */
    /*                rename new dsn into     dsn                */
    /*                delete old dsn                             */
    /*                delete dsnprint                            */
    if xrc = 0 then do /* iebcopy ok                             */

    /* Check for enqueues on dsn after iebcopy ok and            */
    /* before rename dsn.                                        */
    /* If number of enqueues on dsn positive,                    */
    /*    do not rename dsn, clean up and process next dsn       */
      enq_number = whohas(dsn) /* how many enqueues?             */
      if enq_number > 0 then do
         say "IEBCOPY ok but there exists",
             "contention on "dsn
         say "No rename possible."
         say dsn" *** unchanged ***"

         x = msg("off")      /* quiet delete attempt             */
         "delete '"dsn".V2-' scratch purge"
               frc = rc
         y = msg(x)          /* reset msg status                 */

         if frc > 0 then do
            /* Could not delete temporary copy dsn.V2-           */
            say "The temporary copy "dsn".V2-",
                "could also not be deleted."
            say "Code "frc" at delete time."
            say "Extra copy "dsn".V2- present."
         end /* if frc > 0                                       */
         else say "Temporary copy removed."

         x = msg("off")
         "delete '"dsnprint"' scratch purge"
         y = msg(x)
         return /* process next dsn                              */
      end /* if enq_number > 0                                   */
    /* End of checking for enqueues on dsn after iebcopy ok and  */
    /* before rename dsn.                                        */

      /* iebcopy ok and no enqueues on dsn                       */
      x = msg("off")      /* quiet alter                         */
      /* most sensitive part of the code:                        */
      "alter  '"dsn"' newname('"dsn".ANC-')"
            brc = rc
      y = msg(x)          /* reset msg status                    */
            if brc > 0 then do
               say "IEBCOPY ok"
               say "Copy "dsn".V2- created"
               say "but "dsn" could not be renamed into "dsn".ANC-"
               say "Code "brc" at rename time"
               say dsn" *** unchanged ***"
               return
            end /* if brc > 0                                    */
      x = msg("off")      /* quiet alter                         */
      "alter  '"dsn".V2-' newname('"dsn"')"
            crc = rc
      y = msg(x)          /* reset msg status                    */
            if crc > 0 then do
               say "IEBCOPY ok"
               say dsn" was renamed into "dsn".ANC-"
               say "but "dsn".V2- could not renamed into "dsn
               say "and gave code "crc
               return
            end /* if crc > 0                                    */
      say "IEBCOPY return code = "xrc
      x = msg("off")      /* quiet delete attempt                */
      "delete '"dsn".ANC-' scratch purge"
            drc = rc
      y = msg(x)          /* reset msg status                    */
            if drc > 0 then do
               say "IEBCOPY ok but delete of ",
                   "old "dsn".ANC- not done"
               say "code "drc" at delete time."
               say dsn" changed and correct"
               return
            end /* if drc > 0                                    */

      message = dsn" changed to"maxgens rest
      message_length = length(message)
      say copies('_',message_length)
      say
      say message
      say copies('_',message_length)

      x = msg("off")      /* quiet delete attempt                */
      /*  Attempt to delete IEBCOPY SYSPRINT:                    */
      "delete '"dsnprint"' scratch purge"
      y = msg(x)          /* reset msg status                    */
      return
    end /* if xrc = 0  iebcopy ok                                */

    else do          /* xrc <> 0 iebcopy ko                      */
    /* if iebcopy ko keep old dsn not modified                   */
    /*               keep new V2 file                            */
    /*               keep dsnprint                               */
               say "IEBCOPY return code = "xrc
               say dsn" not modified"
               say "New file "dsn".V2- kept"
               say "IEBCOPY SYSPRINT kept"
               return                     /* xrc <> 0 iebcopy ko */
    end /* if xrc <> 0  iebcopy ko                               */
    return

  /*_____________________________________________________________*/
    whohas: procedure

    dsn = word(arg(1),1)    /* first word                        */
    dsn = strip(dsn,,"'")   /* remove surrounding quotes if any  */
    upper dsn
    /*___________________________________________________________*/
    /*                                                           */
    /* Set up commands                                           */

    drop command.
    command.0 = 1
    command.1 = left('D GRS,RES=(SYSDSN,'dsn')',80)
    /*___________________________________________________________*/
    /*                                                           */
    /* Execute command                                           */
    /* Result in isfulog. stem                                   */

     rc = isfcalls("on")                    /* access = on       */
     isfcons = "sdsf"random()               /* console = sdsfxxx */
     isfdelay = 1 /* Wait 1 second before retrieving results     */
     /* isfulog.0 = 2 if isfdelay = 0  delay is necessary        */
     address sdsf isfslash "("command.") (wait)"
     xrc = rc                  /* save return code               */
     rc = isfcalls("off")                   /* access = off      */

     if xrc > 0 then do
        say "execution of "
        do i = 1 to command.0
          say '  'command.i
        end /* do i = 1 to command.0                             */
        say "gave code "xrc
        say "Continue as if no enqueue on "dsn
        return 0
     end /* if xrc > 0                                           */
     /*__________________________________________________________*/
    /*                                                           */
     /* Examine result                                           */

     /* Search for 'NO REQUESTORS'                               */
       do i = 2 to isfulog.0
          if pos('NO REQUESTORS',isfulog.i) > 0 then do
             enq_count = 0
             leave
          end /* if pos('NO REQUESTORS',isfulog.i) > 0           */
       end /* do i = 2 to isfulog.0                              */

       if enq_count = 0 then return 0 /* zero owner              */

       enq_count = isfulog.0 - 5 /* number of owners             */

       /* List owners                                            */
          say 'Contention analysis for 'dsn':'
          do i = 2 to isfulog.0
             say isfulog.i
          end /* do i = 2 to isfulog.0                           */

       return enq_count     /* return number of owners           */
  /*_____________________________________________________________*/
    maxgens_limit:

      cvt = c2d(storage(10,4))
      cvtdfa = c2d(storage(d2x(cvt + 1216),4))
      /* cvt + 4c0 */
      dfamgen = c2d(storage(d2x(cvtdfa + 76),4))
      /* dfa + 4c */
      return dfamgen       /* system maxgens limit               */
  /*_____________________________________________________________*/
    checkdsn: procedure expose rexxname
    /* Check syntax and existence.                               */
    /* dsn assumed in upper characters                           */
    parse arg dsn

    dsn_msg = sysdsn("'"dsn"'")
    if dsn_msg <> 'OK' then do
       say "Dsname "dsn" is not correct: "dsn_msg
       say "___________________________________________________________"
       say " "
       say "Error in "rexxname
       say "       dsname = "dsn
       say "Do not process."
       say "___________________________________________________________"
       say " "
       return 4
    end /* if sysdsn("'"dsn"'") <> 'OK'                          */

    return 0
