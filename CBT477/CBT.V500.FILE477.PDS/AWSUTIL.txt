//AWSUTIL  JOB
//ASM      EXEC PGM=ASMA90,PARM='OBJECT,NODECK'
//SYSPRINT DD SYSOUT=*
//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB
//         DD DISP=SHR,DSN=SYS1.MODGEN
//SYSUT1   DD UNIT=VIO,SPACE=(TRK,(30,30))
//SYSLIN   DD DISP=(,PASS),DSN=&&SYSLIN,SPACE=(TRK,(1,1))
//SYSIN    DD *
***********************************************************************
* AWSUTIL - AWS Format Tape File generation utility - V1.1            *
*                                                                     *
* Copyright (C) 2000  Brandon Hill                                    *
*                                                                     *
* This program is free software; you can redistribute it and/or       *
* modify it under the terms of the GNU General Public License.        *
*                                                                     *
* This program is distributed in the hope that it will be useful,     *
* but WITHOUT ANY WARRANTY; including all implied warranties.         *
*                                                                     *
* For more information, see the complete GPL at: www.gnu.org          *
*                                                                     *
* Please report any bugs and/or enhancements to blh@flybird.com       *
*                                                                     *
* Revision History:                                                   *
*                                                                     *
* Date     Vers Comments                                              *
* -------- ---- -----------------------------------                   *
* 06/13/00 V1.0 Initial Release...                                    *
* 08/22/00 V1.1 Added GET to use QSAM to read a file                  *
*                                                                     *
* Abstract:                                                           *
*                                                                     *
* This is a fairly comprehensive program for creating virtual tape    *
* files.  Labels can be generated.  Tape marks can be written.        *
* Any dataset that can be accessed by BSAM can be copied.  Any real   *
* tape device can have either a single file, or the entire tape       *
* copied.                                                             *
*                                                                     *
* Commands are read from SYSIN and status and errors are written to   *
* SYSPRINT.  The AWS TAPE image is written to SYSOUT as a VB file     *
* that is suitable to be copied with FTP in binary mode to any other  *
* system.                                                             *
*                                                                     *
* Any number of DD statements representing sequential data and tapes  *
* may be specified and read via the appropriate statements in SYSIN.  *
*                                                                     *
*                                                                     *
* Jcl Example:                                                        *
*                                                                     *
* //MAKETAPE EXEC PGM=AWSUTIL                                         *
* //STEPLIB  DD DISP=SHR,DSN=my.load.library                          *
* //SYSPRINT DD SYSOUT=*                                              *
* //SYSOUT   DD DISP=(,CATLG),SPACE=(TRK,(15,15)),DSN=my.dsn.name     *
* //INDATA   DD DISP=SHR,DSN=my.input.sequential.data                 *
* //INTAPE   DD DISP=OLD,DNS=my.real.tape.file                        *
* //SYSIN    DD *                                                     *
* READ INDATA                                                         *
* TAPEMARK                                                            *
* TAPEFILE INTAPE                                                     *
* TAPEMARK                                                            *
* /*                                                                  *
*                                                                     *
* Summary of supported SYSIN commands:                                *
*                                                                     *
* READ     ddname                                                     *
*                                                                     *
*  Perform BSAM read from ddname and convert each block to AWS TAPE   *
*  format.  Works on whatever BSAM will read.  Maximum BLKSIZE        *
*  is 32760.                                                          *
*                                                                     *
* GET      ddname                                                     *
*                                                                     *
*  Perform QSAM read from ddname and convert each record to AWS TAPE  *
*  format.  Works on whatever QSAM will read.  Maximum BLKSIZE        *
*  is 32760.                                                          *
*                                                                     *
* TAPEFILE ddname                                                     *
*                                                                     *
*  Perform EXCP read from a real tape device and convert each block   *
*  to AWS TAPE format.  Only works on a tape device.  Maximum BLKSIZE *
*  is 65535.  This command stops reading when a tape mark is read.    *
*  Therefore, only the current tape file is processed.  If BLP were   *
*  used, only the tape headers would be processed.                    *
*                                                                     *
* TAPEALL  ddname                                                     *
*                                                                     *
*  Perform EXCP read from a real tape device and convert each block   *
*  to AWS TAPE format.  Only works on a tape device.  Maximum BLKSIZE *
*  is 65535.  This command rewinds the tape and reads until an error  *
*  condition is returned.  This effectively copies the entire contents*
*  of the tape.  BLP is not necessary, as a Rewind command is sent    *
*  before the tape is read.  Tape marks are duplicated as they are    *
*  encountered.                                                       *
*                                                                     *
*  NOTE: Because end of reel reflectors are rarely effective, this    *
*        command can run a tape off the reel on a 3420 type drive.    *
*        3480/3490/3590 type drives have better stopping mechanisms.  *
*        You have been warned.                                        *
*                                                                     *
* TAPEMARK                                                            *
*                                                                     *
*  Write a tape mark to the output file.  This is usually used to     *
*  separate individual files on a tape.  Two consecutive tape marks   *
*  sometimes signals the end of the tape.                             *
*                                                                     *
* VERIFY                                                              *
*                                                                     *
*  Print a message after each command verifying that the command was  *
*  executed ok.  This merely prints a message.  It has no effect on   *
*  the integrity of the data.  Because SYSOUT should be directed to   *
*  disk, there should be no data integrity problems, anyway.          *
*                                                                     *
* ASCII                                                               *
*                                                                     *
*  All subsequent labels generated are converted to ASCII before they *
*  are written.  This only affects labels.  All data is copied        *
*  exactly as it is read no matter the setting of this command.       *
*                                                                     *
* EBCDIC                                                              *
*                                                                     *
*  All subsequent labels generated are not to be converted before they*
*  are written.  The implication is that the data is still in EBCDIC  *
*  format.  This only affects labels.  All data is copied exactly as  *
*  it is read no matter the setting of this command.                  *
*                                                                     *
* VOL1, HDR1 - HDR2, EOF1 - EOF2, EOV1 - EOV2, UHL1 - UHL8, UTL1- UTL8*
*                                                                     *
*  These commands write 80 byte labels to the tape image.  The format *
*  of the labels is controlled by the ASCII and EBCDIC commands.      *
*  Except for the first 4 bytes of each input line, none of the data  *
*  is checked to make sure it is a valid tape label.  It is up to the *
*  user to provide correctly formatted labels as desired.             *
*                                                                     *
*  Essentially, the entire 80 byte input record is written to the     *
*  AWS TAPE image as is (or converted to ASCII if the flag is set)    *
*                                                                     *
***********************************************************************
         MACRO
&LABEL   SETRC &SYM
&LABEL   CLC   MAXRC,&SYM                             | Check for
         BNL   *+4+6                                  |  ERR>MAX
         MVC   MAXRC,&SYM                             |
         MEND
         MACRO
&LABEL   PRMSG &MSG,&INIT=NO,&INCPTR=YES,&LEN=0
         LCLA  &L
         LCLC  &LIT
         AIF   ('&INIT' EQ 'YES').INIT
         AIF   ('&MSG'(1,1) EQ '=').LIT
.SYM     ANOP
&L       SETA  &LEN
         AIF   (&L NE 0).MOVESYM
&L       SETA  L'&MSG
.MOVESYM ANOP
&LABEL   MVC   0(&L.,1),&MSG                          | Move data
         AIF   ('&INCPTR' EQ 'NO').EXITSYM
         LA    1,&L.(,1)                              | Bump pointer
.EXITSYM MEXIT
.LIT     ANOP
&L       SETA  &LEN
         AIF   (&L NE 0).MOVELIT
&L       SETA  K'&MSG-4
         AIF   ('&MSG'(2,1) EQ 'C').MOVELIT
&L       SETA  &L/2
         AIF   ('&MSG'(2,1) EQ 'X').MOVELIT
&LIT     SETC  '&MSG'(1,2)
         MNOTE 8,'UNSUPPORTED LITERAL: &LIT'
         MEXIT
.MOVELIT ANOP
&LABEL   MVC   0(&L.,1),&MSG                          | Move data
         AIF   ('&INCPTR' EQ 'NO').EXITLIT
         LA    1,&L.(,1)                              | Bump pointer
.EXITLIT MEXIT
.INIT    ANOP
         AIF   ('&MSG' EQ '').DEFCC
&LABEL   MVI   OUTANSI,&MSG                           | Set CC
         AGO   .CLRBUF
.DEFCC   ANOP
&LABEL   MVI   OUTANSI,ANSI#1L                        | Default CC
.CLRBUF  ANOP
         MVI   OUTBUFF,C' '                           | Clear Buffer
         MVC   OUTBUFF+1(L'OUTBUFF-1),OUTBUFF         |
         LA    1,OUTBUFF                              | Set Pointer
         MEND
         TITLE 'AWSUTIL - Generate AWSTAPE format tape image'
AWSUTIL  CSECT
         STM   14,12,12(13)                           | Entry
         LR    12,15                                  |
         USING AWSUTIL,12                             |
         GETMAIN R,LV=72                              |
         ST    13,4(,1)                               |
         ST    1,8(,13)                               |
         LR    13,1                                   |
         SPACE
         OPEN  (SYSPRINT,OUTPUT)                      | Open SYSOUT
         LTR   15,15                                  |
         BNZ   PRINTERR                               |
         SPACE
         PRMSG ANSI#TOP,INIT=YES                      | Page header
         PRMSG =C'AWSUTIL V1.1 PROGRAM STARTED'       |
         PUT   SYSPRINT,OUTLINE                       |
         SPACE
         PRMSG INIT=YES                               | Blank line
         PUT   SYSPRINT,OUTLINE                       |
         SPACE
         OPEN  SYSIN                                  | Open SYSIN
         LTR   15,15                                  |
         BNZ   INPUTERR                               |
         SPACE
         OPEN  (SYSOUT,OUTPUT)                        | Open SYSOUT
         LTR   15,15                                  |
         BNZ   SYSOUTER                               |
         SPACE
         XC    PREVBLOK,PREVBLOK                      | Reset counters
         XC    CURRBLOK,CURRBLOK                      |
         SPACE
         GETMAIN R,LV=OUTBLKL+4                       | Put Buffer
         LR    10,1                                   |
         SPACE
MAINLOOP DS    0H
         SPACE
         GET   SYSIN,INLINE                           | Get a line
         SPACE
         PRMSG ANSI#1L,INIT=YES                       |
         CLI   VERIFY$,X'00'                          | Skip?
         BE    *+8                                    |
         MVI   OUTANSI,ANSI#2L                        |
         SPACE
         PRMSG =C'>>> '                               | Redisplay
         PRMSG INLINE                                 |
         PUT   SYSPRINT,OUTLINE                       |
         SPACE
         MVC   INVERB,=CL8' '                         | Erase tokens
         MVC   INARG1,=CL8' '                         |
         SPACE
         LA    0,L'INLINE                             | Buffer to scan
         LA    1,INLINE                               |
         SPACE
PARSET1A CLI   0(1),C' '                              | Skip past space
         BNE   PARSET1                                |
         LA    1,1(,1)                                |
         BCT   0,PARSET1A                             |
         B     PARSEXX                                |
         SPACE
PARSET1  LA    2,L'INVERB                             | Fill Verb
         LA    3,INVERB                               |
         SPACE
PARSET1X CLI   0(1),C' '                              | Copy data
         BE    PARSET2A                               |
         LTR   2,2                                    |
         BNP   PARSET1Y                               |
         MVC   0(1,3),0(1)                            |
         SH    2,=H'1'                                |
         LA    3,1(,3)                                |
PARSET1Y LA    1,1(,1)                                |
         BCT   0,PARSET1X                             |
         B     PARSEXX                                |
         SPACE
PARSET2A CLI   0(1),C' '                              | Skip past space
         BNE   PARSET2                                |
         LA    1,1(,1)                                |
         BCT   0,PARSET2A                             |
         B     PARSEXX                                |
         SPACE
PARSET2  LA    2,L'INARG1                             | Fill Arg1
         LA    3,INARG1                               |
         SPACE
PARSET2X CLI   0(1),C' '                              | Copy data
         BE    PARSEXX                                |
         LTR   2,2                                    |
         BNP   PARSET2Y                               |
         MVC   0(1,3),0(1)                            |
         SH    2,=H'1'                                |
         LA    3,1(,3)                                |
PARSET2Y LA    1,1(,1)                                |
         BCT   0,PARSET2X                             |
         SPACE
PARSEXX  DS    0H
         SPACE
         CLI   INVERB,C'*'                            | Comment?
         BE    MAINLOOP                               |
         SPACE
*
* Check command name and call routine
*
         SPACE
         CLC   INVERB,=CL8'TAPEMARK'                  | TAPEMARK cmd
         L     11,=A(@TAPEMRK)                        |
         BZR   11                                     |
         SPACE
         CLC   INVERB,=CL8'READ'                      | READ cmd
         L     11,=A(@READ)                           |
         BZR   11                                     |
         SPACE
         CLC   INVERB,=CL8'GET'                       | GET cmd
         L     11,=A(@GET)                            |
         BZR   11                                     |
         SPACE
         CLC   INVERB,=CL8'TAPEFILE'                  | TAPEFILE cmd
         L     11,=A(@TAPE)                           |
         BZR   11                                     |
         SPACE
         CLC   INVERB,=CL8'TAPEALL'                   | TAPEALL cmd
         L     11,=A(@TAPE)                           |
         BZR   11                                     |
         SPACE
         CLC   INVERB,=CL8'ASCII'                     | ASCII command
         L     11,=A(@LABLFRM)                        |
         BZR   11                                     |
         SPACE
         CLC   INVERB,=CL8'EBCDIC'                    | EBCDIC command
         L     11,=A(@LABLFRM)                        |
         BZR   11                                     |
         SPACE
         CLC   INVERB,=CL8'VERIFY'                    | VERIFY command
         L     11,=A(@VERIFY)                         |
         BZR   11                                     |
         SPACE
*
* Check command name for tape label identifier
*
         SPACE
         LA    0,LABELS#                              | Setup loop
         LA    1,LABELS                               |
         L     11,=A(@LABELS)                         |
         SPACE
LABELOOP CLC   INVERB(4),0(1)                         | Check for
         BER   11                                     |  label id
         SPACE
         LA    1,4(,1)                                | Check next
         BCT   0,LABELOOP                             |
         SPACE
*
* Command is not supported, report error
*
         SPACE
         PRMSG ANSI#3L,INIT=YES                       | Print Err
         PRMSG =C'ERROR: COMMAND VERB "'              |
         PRMSG INVERB                                 |
         PRMSG =C'" IS UNKNOWN'                       |
         PUT   SYSPRINT,OUTLINE                       |
         SPACE
         SETRC ERR$ERR                                | Error
         SPACE
         B     MAINLOOP                               | Loop
         SPACE
INPUTERR DS    0H
         SPACE
         PRMSG ANSI#3L,INIT=YES                       | Print Err
         PRMSG =C'FATAL: UNABLE TO OPEN DD=SYSIN'     |
         PUT   SYSPRINT,OUTLINE                       |
         SPACE
         SETRC ERR$FATL                               | Fatal Error
         SPACE
         B     CLOSEOUT                               |
         SPACE
SYSOUTER DS    0H
         SPACE
         PRMSG ANSI#3L,INIT=YES                       | Print Err
         PRMSG =C'FATAL: UNABLE TO OPEN DD=SYSOUT'    |
         PUT   SYSPRINT,OUTLINE                       |
         SPACE
         SETRC ERR$FATL                               | Fatal Error
         SPACE
         B     CLOSEIN
         SPACE
CLOSE    DS    0H
         SPACE
         FREEMAIN R,LV=OUTBLKL+4,A=(10)               | Free Put Buff
         SPACE
         CLOSE SYSOUT                                 | Try to close
         LTR   15,15                                  |
         BZ    CLOSEIN                                |
         SPACE
         PRMSG ANSI#3L,INIT=YES                       | Print Err
         PRMSG =C'FATAL: ERROR CLOSING DD=SYSOUT'     |
         PUT   SYSPRINT,OUTLINE                       |
         SPACE
         SETRC ERR$FATL                               | Fatal Error
         SPACE
CLOSEIN  DS    0H
         SPACE
         CLOSE SYSIN                                  | Close input
         SPACE
CLOSEOUT DS    0H
         SPACE
         PRMSG ANSI#3L,INIT=YES                       | Final Line
         PRMSG =C'AWSUTIL PROGRAM TERMINATED, MAX RC' |
         PRMSG =X'40202120',INCPTR=NO                 |
         LH    0,MAXRC                                |
         CVD   0,DWORD                                |
         ED    0(4,1),DWORD+6                         |
         PRMSG =C'='                                  |
         PUT   SYSPRINT,OUTLINE                       |
         SPACE
         CLOSE SYSPRINT                               | Close output
         SPACE
         B     RETURN
         SPACE
RETURN   LR    1,13                                   | Exit with rc
         L     13,4(,1)                               |
         FREEMAIN R,LV=72,A=(1)                       |
         LH    15,MAXRC                               |
         L     14,12(13)                              |
         LM    0,12,20(13)                            |
         BR    14                                     |
         SPACE
PRINTERR DS    0H
         SPACE
         SETRC ERR$FATL                               | Fatal Error
         SPACE
         B     RETURN                                 |
         SPACE
         DROP  12
         SPACE
OUTBLKL  EQU   4096                                   | block length
         SPACE
ANSI#TOP EQU C'1'
ANSI#3L  EQU C'-'
ANSI#2L  EQU C'0'
ANSI#1L  EQU C' '
         LTORG
         TITLE 'Common Storage'
         SPACE
DWORD    DS    1D                                     | DoubleWord
ECB      DS    1F                                     | General ECB
         SPACE
MAXRC    DC    H'0'                                   | Maximum RC
ERR$ERR  DC    H'8'                                   | error rc
ERR$FATL DC    H'16'                                  | fatal rc
         SPACE
VERIFY$  DC    X'00'                                  | Verify off
         SPACE
ASCIILBL DC    X'00'                                  | ASC/EBC labels
         SPACE
OUTLINE  DS    0CL133' '                              | Output buffer
OUTANSI  DS    CL1' '                                 |
OUTBUFF  DS    CL132' '                               |
         SPACE
INLINE   DS    CL80' '                                | Input buffer
         SPACE
INVERB   DS    CL8' '                                 |
INARG1   DS    CL8' '                                 |
         SPACE
PREVBLOK DS    F
CURRBLOK DS    F
AWS#MARK EQU   X'40'
AWS#REC  EQU   X'80'+X'20'
         SPACE
LABELS   DC    C'VOL1HDR1EOV1EOF1HDR2EOV2EOF2'        | All valid
         DC    C'UHL1UHL2UHL3UHL4UHL5UHL6UHL7UHL8'    |  80 byte
         DC    C'UTL1UTL2UTL3UTL4UTL5UTL6UTL7UTL8'    |   labels
LABELS#  EQU   (*-LABELS)/4
         SPACE
         IEZIOB DSECT=NO                              | IOB
         SPACE
SYSPRINT DCB   DDNAME=SYSPRINT,                                        +
               MACRF=PM,                                               +
               DSORG=PS,                                               +
               LRECL=133,                                              +
               RECFM=FBA
SYSIN    DCB   DDNAME=SYSIN,                                           +
               MACRF=GM,                                               +
               DSORG=PS,                                               +
               LRECL=80,                                               +
               RECFM=FB,                                               +
               EODAD=CLOSE
SYSOUT   DCB   DDNAME=SYSOUT,                                          +
               MACRF=PM,                                               +
               DSORG=PS,                                               +
               LRECL=OUTBLKL+4,                                        +
               RECFM=VB
         SPACE
         LTORG
         SPACE
         TITLE '@VERIFY - toggle verify flag'
         SPACE
@VERIFY  CSECT
         USING @VERIFY,11
         USING AWSUTIL,12
         SPACE
         CLI   VERIFY$,X'00'                          | Check flag
         BE    VFY$ON                                 |
         SPACE
         MVI   VERIFY$,X'00'                          |
         SPACE
         PRMSG ANSI#1L,INIT=YES                       | Print
         PRMSG =C'VERIFY FLAG IS NOW OFF'             |
         PUT   SYSPRINT,OUTLINE                       |
         SPACE
         B     MAINLOOP
         SPACE
VFY$ON   DS    0H
         SPACE
         MVI   VERIFY$,X'FF'                          | Turn on flag
         SPACE
         PRMSG ANSI#1L,INIT=YES                       | Print
         PRMSG =C'VERIFY FLAG IS NOW ON'              |
         PUT   SYSPRINT,OUTLINE                       |
         SPACE
         B     MAINLOOP
         SPACE
         DROP  11,12
         SPACE
         LTORG
         TITLE '@LABLFRM - set ASCII or EBCDIC labels'
         SPACE
@LABLFRM CSECT
         USING @LABLFRM,11
         USING AWSUTIL,12
         SPACE
         CLC   INVERB,=CL8'ASCII'
         BE    LAB$ASC
         SPACE
         MVI   ASCIILBL,X'00'
         SPACE
         CLI   VERIFY$,X'00'                          | Check flag
         BE    MAINLOOP                               |
         SPACE
         PRMSG ANSI#1L,INIT=YES                       | Print
         PRMSG =C'EBCDIC LABELS SELECTED'             |
         PUT   SYSPRINT,OUTLINE                       |
         SPACE
         B     MAINLOOP
         SPACE
LAB$ASC  DS    0H
         SPACE
         MVI   ASCIILBL,X'FF'
         SPACE
         CLI   VERIFY$,X'00'                          | Check flag
         BE    MAINLOOP                               |
         SPACE
         PRMSG ANSI#1L,INIT=YES                       | Print
         PRMSG =C'ASCII LABELS SELECTED'              |
         PUT   SYSPRINT,OUTLINE                       |
         SPACE
         B     MAINLOOP
         SPACE
         DROP  11,12
         SPACE
         LTORG
         SPACE
         TITLE '@TAPEMRK - write a tapemark to the AWS tape'
         SPACE
@TAPEMRK CSECT
         USING PUTBUFF,10
         USING @TAPEMRK,11
         USING AWSUTIL,12
         SPACE
         MVC   PUTRDW,=AL2(6+4)                       | Setup RDW
         XC    PUTCLR,PUTCLR                          |
         SPACE
         MVC   PREVBLOK,CURRBLOK                      | Cycle bloks
         XC    CURRBLOK,CURRBLOK                      |
         SPACE
         MVC   PUTCURL,CURRBLOK+3                     | Reverse byte
         MVC   PUTCURH,CURRBLOK+2                     |  order
         SPACE
         MVC   PUTPRVL,PREVBLOK+3                     | Reverse byte
         MVC   PUTPRVH,PREVBLOK+2                     |  order
         SPACE
         MVI   PUTFLG1,AWS#MARK                       | Tape Mark
         XC    PUTFLG2,PUTFLG2
         SPACE
         PUT   SYSOUT,PUTBUFF                         | Put record
         SPACE
         CLI   VERIFY$,X'00'                          | Skip?
         BE    MAINLOOP                               |
         SPACE
         PRMSG ANSI#1L,INIT=YES                       | Print info
         PRMSG =C'WRITE TAPE MARK OK'                 |
         PUT   SYSPRINT,OUTLINE                       |
         SPACE
         B     MAINLOOP                               | Back to loop
         SPACE
         DROP  10,11,12
         SPACE
         LTORG
         TITLE '@LABELS - write 80 byte tape label to AWS tape'
         SPACE
@LABELS  CSECT
         USING PUTBUFF,10
         USING @LABELS,11
         USING AWSUTIL,12
         SPACE
         MVC   PUTRDW,=AL2(80+6+4)                    | Setup RDW
         XC    PUTCLR,PUTCLR                          |
         SPACE
         MVC   PREVBLOK,CURRBLOK                      | Cycle bloks
         MVC   CURRBLOK,=F'80'                        |
         SPACE
         MVC   PUTCURL,CURRBLOK+3                     | Reverse byte
         MVC   PUTCURH,CURRBLOK+2                     |  order
         SPACE
         MVC   PUTPRVL,PREVBLOK+3                     | Reverse byte
         MVC   PUTPRVH,PREVBLOK+2                     |  order
         SPACE
         MVI   PUTFLG1,AWS#REC                        | Data Block
         XC    PUTFLG2,PUTFLG2                        |
         SPACE
         MVC   PUTDATA(L'INLINE),INLINE               | Copy record
         SPACE
         CLI   ASCIILBL,X'00'                         | Check for
         BE    LAB$PUT                                |  ASCII
         SPACE
         XLATE PUTDATA,80,TO=A                        | Xlate 2 ASCII
         SPACE
LAB$PUT  DS    0H
         SPACE
         PUT   SYSOUT,PUTBUFF                         | Put record
         SPACE
         CLI   VERIFY$,X'00'                          | Skip?
         BE    MAINLOOP                               |
         SPACE
         PRMSG ANSI#1L,INIT=YES                       | Print info
         PRMSG =C'WRITE LABEL '                       |
         PRMSG INVERB,LEN=4                           |
         PRMSG =C' OK'                                |
         PUT   SYSPRINT,OUTLINE                       |
         SPACE
         B     MAINLOOP                               | Back to loop
         SPACE
         DROP  10,11,12
         SPACE
         LTORG
         TITLE '@READ - read records from input to AWS tape'
         SPACE
@READ    CSECT
         USING PUTBUFF,10
         USING @READ,11
         USING AWSUTIL,12
         SPACE
         MVC   RD$INDCB+DCBDDNAM-IHADCB(8),=CL8'INPUT'  Default name
         SPACE
         CLI   INARG1,C' '                            | Check DDNAME
         BE    *+10                                   |
         MVC   RD$INDCB+DCBDDNAM-IHADCB(8),INARG1     | Set DDNAME
         SPACE
         MVC   RD$INDD,RD$INDCB+DCBDDNAM-IHADCB       | Save DDNAME
         SPACE
         OPEN  RD$INDCB                               | Open DD
         LTR   15,15                                  |
         BNZ   RD$OERR                                |
         SPACE
         CLI   VERIFY$,X'00'                          | Skip?
         BE    RD$START                               |
         SPACE
         PRMSG ANSI#1L,INIT=YES                       | Print it
         PRMSG =C'OPEN COMPLETE FOR INPUT DD='        |
         PRMSG RD$INDD                                |
         PUT   SYSPRINT,OUTLINE                       |
         SPACE
RD$START DS    0H
         SPACE
         XC    RD$BLK,RD$BLK                          | Clear counter
         SPACE
         GETMAIN R,LV=65536                           | Get buffer
         LR    9,1                                    |
         SPACE
RD$LOOP  DS    0H
         SPACE
         READ  RD$CHK,SF,RD$INDCB,(9)                 | Read block
         CHECK RD$CHK                                 |
         SPACE
         LH    3,RD$INDCB+DCBBLKSI-IHADCB             | Calc block
         L     2,RD$CHK+16                            |  length
         SH    3,14(,2)                               |
         LR    2,9                                    |
         SPACE
         MVC   PREVBLOK,CURRBLOK                      | Cycle bloks
         ST    3,CURRBLOK                             |
         SPACE
         MVC   PUTRDW,=AL2(6+4)                       | Setup RDW
         XC    PUTCLR,PUTCLR                          |
         SPACE
         MVC   PUTCURL,CURRBLOK+3                     | Reverse byte
         MVC   PUTCURH,CURRBLOK+2                     |  order
         SPACE
         MVC   PUTPRVL,PREVBLOK+3                     | Reverse byte
         MVC   PUTPRVH,PREVBLOK+2                     |  order
         SPACE
         MVI   PUTFLG1,AWS#REC                        | Record
         XC    PUTFLG2,PUTFLG2
         SPACE
         PUT   SYSOUT,PUTBUFF                         | Put record
         SPACE
RD$LLOP  DS    0H
         SPACE
         LR    1,3                                    | Current
         CH    1,=AL2(OUTBLKL)                        |  output
         BNH   *+8                                    |   length
         LH    1,=AL2(OUTBLKL)                        |
         SPACE
         LA    0,4(,1)                                | Setup RDW
         STCM  0,B'0011',PUTRDW                       |
         XC    PUTCLR,PUTCLR                          |
         SPACE
         LA    0,PUTRDW+4                             | Move data
         MVCL  0,2                                    |
         SPACE
         PUT   SYSOUT,PUTBUFF                         | PUT data
         SPACE
         LTR   3,3                                    | Check for
         BP    RD$LLOP                                |  more data
         SPACE
         L     0,RD$BLK                               |
         AH    0,=H'1'                                |
         ST    0,RD$BLK                               |
         SPACE
         B     RD$LOOP                                |
         SPACE
*
* End of input data
*
         SPACE
RD$EOD   DS    0H
         SPACE
         CLI   VERIFY$,X'00'                          | Skip?
         BE    RD$CLOSE                               |
         SPACE
         PRMSG ANSI#1L,INIT=YES                       | Print info
         PRMSG =C'READ OK, BLOCKS PROCESSED'          |
         PRMSG =X'402020206B2020206B202120',INCPTR=NO |
         L     0,RD$BLK                               |
         CVD   0,DWORD                                |
         ED    0(12,1),DWORD+3                        |
         PRMSG =C'='                                  |
         PUT   SYSPRINT,OUTLINE                       |
         SPACE
RD$CLOSE DS    0H
         SPACE
         FREEMAIN R,LV=65536,A=(9)                    | Free buffer
         SPACE
         CLOSE RD$INDCB                               | Try to close
         LTR   15,15                                  |
         BZ    RD$CLOSD                               |
         SPACE
         PRMSG ANSI#3L,INIT=YES                       | Print it
         PRMSG =C'FATAL: ERROR CLOSING INPUT DD='     |
         PRMSG RD$INDD                                |
         PUT   SYSPRINT,OUTLINE                       |
         SPACE
         SETRC ERR$FATL                               | Fatal Error
         SPACE
         B     CLOSE                                  | Just leave
         SPACE
RD$CLOSD DS    0H
         SPACE
         CLI   VERIFY$,X'00'                          | Skip?
         BE    MAINLOOP                               |
         SPACE
         PRMSG ANSI#1L,INIT=YES                       | Print it
         PRMSG =C'CLOSE COMPLETE FOR INPUT DD='       |
         PRMSG RD$INDD                                |
         PUT   SYSPRINT,OUTLINE                       |
         SPACE
         B     MAINLOOP                               | Back to main
         SPACE
RD$OERR  DS    0H
         SPACE
         PRMSG ANSI#3L,INIT=YES                       | Print it
         PRMSG =C'ERROR: ERROR OPENING INPUT DD='     |
         PRMSG RD$INDD                                |
         PUT   SYSPRINT,OUTLINE                       |
         SPACE
         SETRC ERR$ERR                                | Error
         SPACE
         B     MAINLOOP                               | Back to main
         SPACE
         DROP  10,11,12
         SPACE
RD$BLK   DS    F                                      | Block Count
RD$INDCB DCB   DDNAME=INPUT,                                           +
               MACRF=R,                                                +
               DSORG=PS,                                               +
               EODAD=RD$EOD
RD$INDD  DS    CL8' '
         LTORG
         TITLE '@GET - get records from input to AWS tape'
         SPACE
@GET     CSECT
         USING PUTBUFF,10
         USING @GET,11
         USING AWSUTIL,12
         SPACE
         MVC   GT$INDCB+DCBDDNAM-IHADCB(8),=CL8'INPUT'  Default name
         SPACE
         CLI   INARG1,C' '                            | Check DDNAME
         BE    *+10                                   |
         MVC   GT$INDCB+DCBDDNAM-IHADCB(8),INARG1     | Set DDNAME
         SPACE
         MVC   GT$INDD,GT$INDCB+DCBDDNAM-IHADCB       | Save DDNAME
         SPACE
         OPEN  GT$INDCB                               | Open DD
         LTR   15,15                                  |
         BNZ   GT$OERR                                |
         SPACE
         CLI   VERIFY$,X'00'                          | Skip?
         BE    GT$START                               |
         SPACE
         PRMSG ANSI#1L,INIT=YES                       | Print it
         PRMSG =C'OPEN COMPLETE FOR INPUT DD='        |
         PRMSG GT$INDD                                |
         PUT   SYSPRINT,OUTLINE                       |
         SPACE
GT$START DS    0H
         SPACE
         XC    GT$BLK,GT$BLK                          | Clear counter
         SPACE
         GETMAIN R,LV=65536                           | Get buffer
         LR    9,1                                    |
         SPACE
GT$LOOP  DS    0H
         SPACE
         GET   GT$INDCB,(9)                           | Read block
         SPACE
         LH    3,GT$INDCB+DCBLRECL-IHADCB             | Calc block
         LR    2,9                                    |  length
         SPACE
         MVC   PREVBLOK,CURRBLOK                      | Cycle bloks
         ST    3,CURRBLOK                             |
         SPACE
         MVC   PUTRDW,=AL2(6+4)                       | Setup RDW
         XC    PUTCLR,PUTCLR                          |
         SPACE
         MVC   PUTCURL,CURRBLOK+3                     | Reverse byte
         MVC   PUTCURH,CURRBLOK+2                     |  order
         SPACE
         MVC   PUTPRVL,PREVBLOK+3                     | Reverse byte
         MVC   PUTPRVH,PREVBLOK+2                     |  order
         SPACE
         MVI   PUTFLG1,AWS#REC                        | Record
         XC    PUTFLG2,PUTFLG2
         SPACE
         PUT   SYSOUT,PUTBUFF                         | Put record
         SPACE
GT$LLOP  DS    0H
         SPACE
         LR    1,3                                    | Current
         CH    1,=AL2(OUTBLKL)                        |  output
         BNH   *+8                                    |   length
         LH    1,=AL2(OUTBLKL)                        |
         SPACE
         LA    0,4(,1)                                | Setup RDW
         STCM  0,B'0011',PUTRDW                       |
         XC    PUTCLR,PUTCLR                          |
         SPACE
         LA    0,PUTRDW+4                             | Move data
         MVCL  0,2                                    |
         SPACE
         PUT   SYSOUT,PUTBUFF                         | PUT data
         SPACE
         LTR   3,3                                    | Check for
         BP    GT$LLOP                                |  more data
         SPACE
         L     0,GT$BLK                               |
         AH    0,=H'1'                                |
         ST    0,GT$BLK                               |
         SPACE
         B     GT$LOOP                                |
         SPACE
*
* End of input data
*
         SPACE
GT$EOD   DS    0H
         SPACE
         CLI   VERIFY$,X'00'                          | Skip?
         BE    GT$CLOSE                               |
         SPACE
         PRMSG ANSI#1L,INIT=YES                       | Print info
         PRMSG =C'GET OK, RECORDS PROCESSED'          |
         PRMSG =X'402020206B2020206B202120',INCPTR=NO |
         L     0,GT$BLK                               |
         CVD   0,DWORD                                |
         ED    0(12,1),DWORD+3                        |
         PRMSG =C'='                                  |
         PUT   SYSPRINT,OUTLINE                       |
         SPACE
GT$CLOSE DS    0H
         SPACE
         FREEMAIN R,LV=65536,A=(9)                    | Free buffer
         SPACE
         CLOSE GT$INDCB                               | Try to close
         LTR   15,15                                  |
         BZ    GT$CLOSD                               |
         SPACE
         PRMSG ANSI#3L,INIT=YES                       | Print it
         PRMSG =C'FATAL: ERROR CLOSING INPUT DD='     |
         PRMSG GT$INDD                                |
         PUT   SYSPRINT,OUTLINE                       |
         SPACE
         SETRC ERR$FATL                               | Fatal Error
         SPACE
         B     CLOSE                                  | Just leave
         SPACE
GT$CLOSD DS    0H
         SPACE
         CLI   VERIFY$,X'00'                          | Skip?
         BE    MAINLOOP                               |
         SPACE
         PRMSG ANSI#1L,INIT=YES                       | Print it
         PRMSG =C'CLOSE COMPLETE FOR INPUT DD='       |
         PRMSG GT$INDD                                |
         PUT   SYSPRINT,OUTLINE                       |
         SPACE
         B     MAINLOOP                               | Back to main
         SPACE
GT$OERR  DS    0H
         SPACE
         PRMSG ANSI#3L,INIT=YES                       | Print it
         PRMSG =C'ERROR: ERROR OPENING INPUT DD='     |
         PRMSG GT$INDD                                |
         PUT   SYSPRINT,OUTLINE                       |
         SPACE
         SETRC ERR$ERR                                | Error
         SPACE
         B     MAINLOOP                               | Back to main
         SPACE
         DROP  10,11,12
         SPACE
GT$BLK   DS    F                                      | Block Count
GT$INDCB DCB   DDNAME=INPUT,                                           +
               MACRF=GM,                                               +
               DSORG=PS,                                               +
               EODAD=GT$EOD
GT$INDD  DS    CL8' '
         LTORG
         TITLE '@TAPE - Copy tape via excp to AWS tape'
         SPACE
@TAPE    CSECT
         USING PUTBUFF,10
         USING @TAPE,11
         USING AWSUTIL,12
         SPACE
         MVC   TP$INDCB+DCBDDNAM-IHADCB(8),=CL8'INPUT' | Default name
         SPACE
         CLI   INARG1,C' '                            | Check DDNAME
         BE    *+10                                   |
         MVC   TP$INDCB+DCBDDNAM-IHADCB(8),INARG1     | Set DDNAME
         SPACE
         MVC   TP$INDD,TP$INDCB+DCBDDNAM-IHADCB       | Save DDNAME
         SPACE
         OPEN  TP$INDCB                               | Open DD
         LTR   15,15                                  |
         BNZ   TP$OERR                                |
         SPACE
         XR    1,1                                    |
         ICM   1,B'0111',TP$INDCB+DCBDEBA-IHADCB      | DEB <-- DCB
         ICM   1,B'0111',DEBSUCBB-DEBBASIC(1)         | UCB <-- DEB
         SPACE
         CLI   UCBTBYT3-UCBOB(1),UCB3TAPE             | Check for tape
         BNE   TP$NOTAP                               |
         SPACE
*
* The 02 command is read forward on all tape drives except 3590
* The 06 command is read forward on 3590 tape drives
*
         MVI   TP$READ,X'02'                          | Read Forward
         CLC   =X'78048083',UCBTYP-UCBOB(1)           | 3590?
         BNE   *+8                                    |
         MVI   TP$READ,X'06'                          | Read Forward
         SPACE
         CLI   VERIFY$,X'00'                          | Skip?
         BE    TP$START                               |
         SPACE
         PRMSG ANSI#1L,INIT=YES                       | Print it
         PRMSG =C'OPEN COMPLETE FOR INPUT DD='        |
         PRMSG TP$INDD                                |
         PUT   SYSPRINT,OUTLINE                       |
         SPACE
TP$START DS    0H
         SPACE
         CLC   INVERB,=CL8'TAPEALL'                   | If TAPEALL,
         BNE   TP$GETM                                |  rewind tape
         SPACE
         XC    IOB,IOB
         MVI   IOBFLAG1,B'11000010'                   | Init IOB
         MVI   IOBFLAG2,B'00100000'                   |
         LA    0,ECB                                  |
         STCM  0,B'0111',IOBECBPB                     | Point to ECB
         LA    0,TP$INDCB                             |
         STCM  0,B'0111',IOBDCBPB                     | Point to DCB
         LA    0,TP$REW                               |
         STCM  0,B'0111',IOBSTRTB                     | Point to CCW
         SPACE
         EXCP  IOBSTDRD                               | Execute ch prog
         LTR   15,15                                  |
         BNZ   TP$EXCPE                               |
         SPACE
         WAIT  ECB=ECB                                | Wait for I/O
         SPACE
TP$GETM  DS    0H
         SPACE
         GETMAIN R,LV=65536                           | Get buffer
         LR    9,1                                    |
         SPACE
         STCM  9,B'0111',TP$READ+1                    | Save buf addr
         SPACE
         XC    TP$BLK,TP$BLK                          | Clear counter
         SPACE
TP$LOOP  DS    0H
         SPACE
         XC    IOB,IOB
         MVI   IOBFLAG1,B'11000010'                   | Init IOB
         MVI   IOBFLAG2,B'00100000'                   |
         LA    0,ECB                                  |
         STCM  0,B'0111',IOBECBPB                     | Point to ECB
         LA    0,TP$INDCB                             |
         STCM  0,B'0111',IOBDCBPB                     | Point to DCB
         LA    0,TP$READ                              |
         STCM  0,B'0111',IOBSTRTB                     | Point to CCW
         SPACE
         EXCP  IOBSTDRD                               | Execute ch prog
         LTR   15,15                                  |
         BNZ   TP$EXCPE                               |
         SPACE
         WAIT  ECB=ECB                                | Wait for I/O
         SPACE
         TM    IOBUSTAT,IOBUSB7                       | Check for
         BZ    TP$DATA                                |  Tape Mark
         SPACE
         CLC   INVERB,=CL8'TAPEFILE'                  | Leave if only
         BE    TP$EOD                                 |  1 file
         SPACE
         XR    2,2                                    | Clear ptr
         XR    3,3                                    |  and len
         SPACE
         B     TP$WRITE                               |
         SPACE
TP$DATA  DS    0H
         SPACE
         CLI   ECB,X'7F'                              | I/O err?
         BNE   TP$EOD                                 |
         SPACE
         L     3,=X'0000FFFF'                         | Record length
         XC    DWORD(4),DWORD                         |
         MVC   DWORD+2(2),IOBCSW+5                    |
         S     3,DWORD                                |
         SPACE
         LR    2,9                                    | Block Pointer
         SPACE
TP$WRITE DS    0H
         SPACE
         MVC   PREVBLOK,CURRBLOK                      | Cycle bloks
         ST    3,CURRBLOK                             |
         SPACE
         MVC   PUTRDW,=AL2(6+4)                       | Setup RDW
         XC    PUTCLR,PUTCLR                          |
         SPACE
         MVC   PUTCURL,CURRBLOK+3                     | Reverse byte
         MVC   PUTCURH,CURRBLOK+2                     |  order
         SPACE
         MVC   PUTPRVL,PREVBLOK+3                     | Reverse byte
         MVC   PUTPRVH,PREVBLOK+2                     |  order
         SPACE
         MVI   PUTFLG1,AWS#REC                        | Record
         LTR   3,3                                    |
         BP    *+8                                    |
         MVI   PUTFLG1,AWS#MARK                       | or tapemark
         XC    PUTFLG2,PUTFLG2                        |
         SPACE
         PUT   SYSOUT,PUTBUFF                         | Put record
         SPACE
TP$LLOP  DS    0H
         SPACE
         LTR   3,3                                    | Check for
         BNP   TP$BLKC                                |  more data
         SPACE
         LR    1,3                                    | Current
         CH    1,=AL2(OUTBLKL)                        |  output
         BNH   *+8                                    |   length
         LH    1,=AL2(OUTBLKL)                        |
         SPACE
         LA    0,4(,1)                                | Setup RDW
         STCM  0,B'0011',PUTRDW                       |
         XC    PUTCLR,PUTCLR                          |
         SPACE
         LA    0,PUTRDW+4                             | Move data
         MVCL  0,2                                    |
         SPACE
         PUT   SYSOUT,PUTBUFF                         | PUT data
         SPACE
         B     TP$LLOP
         SPACE
TP$BLKC  L     0,TP$BLK                               |
         AH    0,=H'1'                                |
         ST    0,TP$BLK                               |
         SPACE
         B     TP$LOOP                                |
         SPACE
*
* End of input data
*
         SPACE
TP$EOD   DS    0H
         SPACE
         CLI   VERIFY$,X'00'                          | Skip?
         BE    TP$CLOSE                               |
         SPACE
         PRMSG ANSI#1L,INIT=YES                       | Print info
         PRMSG =C'READ OK, BLOCKS PROCESSED'          |
         PRMSG =X'402020206B2020206B202120',INCPTR=NO |
         L     0,TP$BLK                               |
         CVD   0,DWORD                                |
         ED    0(12,1),DWORD+3                        |
         PRMSG =C'='                                  |
         PUT   SYSPRINT,OUTLINE                       |
         SPACE
TP$CLOSE DS    0H
         SPACE
         FREEMAIN R,LV=65536,A=(9)                    | Free buffer
         SPACE
         CLOSE TP$INDCB                               | Try to close
         LTR   15,15                                  |
         BZ    TP$CLOSD                               |
         SPACE
         PRMSG ANSI#3L,INIT=YES                       | Print it
         PRMSG =C'FATAL: ERROR CLOSING INPUT DD='     |
         PRMSG TP$INDD                                |
         PUT   SYSPRINT,OUTLINE                       |
         SPACE
         SETRC ERR$FATL                               | Fatal Error
         SPACE
         B     CLOSE                                  | Just leave
         SPACE
TP$CLOSD DS    0H
         SPACE
         CLI   VERIFY$,X'00'                          | Skip?
         BE    MAINLOOP                               |
         SPACE
         PRMSG ANSI#1L,INIT=YES                       | Print it
         PRMSG =C'CLOSE COMPLETE FOR INPUT DD='       |
         PRMSG TP$INDD                                |
         PUT   SYSPRINT,OUTLINE                       |
         SPACE
         B     MAINLOOP                               | Back to main
         SPACE
TP$OERR  DS    0H
         SPACE
         PRMSG ANSI#3L,INIT=YES                       | Print it
         PRMSG =C'ERROR: ERROR OPENING INPUT DD='     |
         PRMSG TP$INDD                                |
         PUT   SYSPRINT,OUTLINE                       |
         SPACE
         SETRC ERR$ERR                                | Error
         SPACE
         B     MAINLOOP                               | Back to main
         SPACE
TP$NOTAP DS    0H
         SPACE
         CLOSE TP$INDCB                               | Try to close
         SPACE
         PRMSG ANSI#3L,INIT=YES                       | Print it
         PRMSG =C'ERROR: INPUT DD='                   |
         PRMSG TP$INDD                                |
         PRMSG =C' IS NOT ON A TAPE DEVICE'           |
         PUT   SYSPRINT,OUTLINE                       |
         SPACE
         SETRC ERR$ERR                                | Error
         SPACE
         B     MAINLOOP                               | Back to main
         SPACE
TP$EXCPE DS    0H
         SPACE
         PRMSG ANSI#3L,INIT=YES                       | Print it
         PRMSG =C'ERROR: EXCP ERROR ON INPUT DD='     |
         PRMSG TP$INDD                                |
         PUT   SYSPRINT,OUTLINE                       |
         SPACE
         SETRC ERR$ERR                                | Error
         SPACE
         B     TP$CLOSE                               | Back to main
         SPACE
         DROP  10,11,12
         SPACE
TP$BLK   DS    F                                      | Block Count
TP$INDCB DCB   DDNAME=INPUT,                                           +
               MACRF=E,                                                +
               EODAD=TP$EOD
TP$INDD  DS    CL8' '
         SPACE
TP$READ  DC    0D'0',X'02',AL3(0),X'2000',AL2(65535)  | Read   CCW
TP$REW   DC    0D'0',X'07',AL3(0),X'6000',AL2(1)      | Rewind CCW
         DC          X'03',AL3(0),X'2000',AL2(1)      | Nop    CCW
         SPACE
         LTORG
         TITLE 'DESCTs'
PUTBUFF  DSECT
PUTRDW   DS    1H
PUTCLR   DS    1H
PUTCURL  DS    1B
PUTCURH  DS    1B
PUTPRVL  DS    1B
PUTPRVH  DS    1B
PUTFLG1  DS    1B
PUTFLG2  DS    1B
PUTDATA  DS    0B
         DCBD  DSORG=PS
         IEZDEB
         IEFUCBOB
         END
/*
//*
//* Link edit the program
//*
//LKED     EXEC PGM=IEWL,COND=(4,LT)
//SYSLIN   DD DISP=(OLD,DELETE),DSN=&&SYSLIN
//SYSLMOD  DD DISP=(,PASS),DSN=&&SYSLMOD(AWSUTIL),SPACE=(TRK,(1,1,1))
//SYSUT1   DD UNIT=VIO,SPACE=(TRK,(30,30))
//SYSPRINT DD SYSOUT=*
//*
//* Run the program
//*
//*  This is a simple test to see if things are ok.  It should create
//* a simple SL tape with a single 80 byte record read from INPUT
//*
//AWSUTIL  EXEC PGM=*.LKED.SYSLMOD,COND=(4,LT)
//SYSPRINT DD SYSOUT=*
//SYSOUT   DD SYSOUT=* <--- REPLACE WITH ACTUAL DATASET
//INPUT    DD *
Test record
//SYSIN    DD *
VERIFY
VOL1MYTAPE                               TAPE OWNER
HDR1SYS1.TEST.DATA   MYTAPE00010001      0001640001640000000IBM OS/VS 370
HDR2F00080000800TAPEJOB1/TAPESTEP
TAPEMARK
READ INPUT
TAPEMARK
EOF1SYS1.TEST.DATA   MYTAPE00010001      0001640001640000001IBM OS/VS 370
EOF2F00080000800TAPEJOB1/TAPESTEP
TAPEMARK
TAPEMARK
/*
//
