CALC     TITLE 'DESK CALCULATOR'
***********************************************************************
***********************************************************************
**                                                                   **
**  PROGRAM NAME:  CALC                                              **
**                                                                   **
**  AUTHOR:        ?                                                 **
**                                                                   **
**  DATE:          ?                                                 **
**                                                                   **
**  INSTALLATION:  ?                                                 **
**                                                                   **
**  PURPOSE:       ?                                                 **
**                                                                   **
**  HISTORY:       THIS PROGRAM USED TO BE AN URSA PROCESSOR AT CCN. **
**                 IT WAS THEN CONVERTED TO A TSO COMMAND AT CCN.    **
**                                                                   **
**                 I STRONGLY RECOMMEND THAT YOU GIVE UP ANY         **
**                 PERVERSE THOUGHTS OF CLEANING UP THIS TRAVESTY.   **
**                 ... BE THANKFUL THAT YOU CAN EVEN GET IT TO WORK. **
**                                                                   **
**  UPDATES:                                                         **
**     02/21/80 LDW   1) MAKE THIS TURKEY ASSEMBLE WITHOUT THE       **
**                       "BATCH" OPTION (WHICH THE IFOX ASSEMBLER    **
**                       DOES NOT HAVE!!!)                           **
**                    2) COPY UNIQUE MACROS INLINE                   **
**                    3) CHANGE TO STANDARD SYMBOLIC REGISTERS       **
**                                                                   **
***********************************************************************
***********************************************************************
         TITLE 'C A L C  -  STUPID MACROS'
         MACRO
&NAME    BCE   &FINDADS,&REG,&CHR
.*$MACRO=BCE        DATE=04/00/79       SOURCE=UCLA
.*       THE BCE MACRO WILL COMPARE &REG WITH THE LIST OF CHARACTERS
.*       GIVEN IN &CHR. IF AN EQUAL MATCH HAS BEEN MADE, CONTROL
.*       WILL PASS TO &FINDADS.
.*       THE CONTENTS OF R0 WILL BE DESTROYED BY THE MACRO, AND
.*       &REG MUST HAVE ZEROS IN THE HIGH ORDER THREE BYTES.
         LCLA  &COUNT
         LCLC  &X
&COUNT   SETA  1
&NAME    SR    R0,R0
.LOOP    AIF   ('&CHR(&COUNT)'(1,1) NE 'X').CHAR
&X       SETC  '&CHR(&COUNT)'(2,2)
         IC    R0,=X'&X'
         AGO   .CR
.CHAR    IC    R0,=C&CHR(&COUNT)
.CR      CR    R0,&REG
         BE    &FINDADS
&COUNT   SETA  &COUNT+1
         AIF   (&COUNT LE N'&CHR).LOOP
         MEND
         SPACE 3
         MACRO
&NAME    ZGPR  &REG
.*.
.*$MACRO=ZGPR       DATE=04/00/79       SOURCE=UCLA
.*       THE ZGPR MACRO WILL ZERO THE GPR'S GIVEN IN THE LIST &REG.
.*.
         LCLA  &LENGTH,&COUNT
&LENGTH  SETA  N'&REG+1
&COUNT   SETA  1
         AIF   ( '&NAME' EQ '' ).LOOP
&NAME    EQU   *
.LOOP    SR    &REG(&COUNT),&REG(&COUNT)
&COUNT   SETA  &COUNT+1
         AIF   ( '&COUNT' LT '&LENGTH' ).LOOP
         MEND
         SPACE 3
         MACRO
&NAME    ADDG  &REG,&NO
.*.
.*$MACRO=ADDG       DATE=04/00/79       SOURCE=UCLA
.*       THE ADDG MACRO WILL ADD &NO TO &REG. &NO MUST BE A NUMBER
.*       LESS THAN 4096 AND &REG MUST BE A NUMBER BETWEEN 1 AND 15.
.*.
&NAME    LA    &REG.,&NO.(&REG.)
         MEND
         SPACE 3
         MACRO
&NAME    PLOP  &REG
.*.
.*$MACRO=PLOP       DATE=04/00/79       SOURCE=UCLA
.*       PLOP WILL PLACE THE ENTITY INTO A STACK POINTED TO BY
.*       GPR &REG.
.*.
&NAME    STM   R15,R1,0(&REG.)
         ADDG  &REG,12
         MEND
         SPACE 3
         MACRO
&NAME    STACKO &REG,&ENDLOC
.*.
.*$MACRO=STACKO     DATE=04/00/79       SOURCE=UCLA
.*       THE SCACKO MACRO WILL POP ONE ENTITY FROM THE STRING THAT
.*       IS THE RESULT OF SCAN 1 OR 2.
.*       &REG IS THE POINTER TO THE NEXT CONTROL BYTE.
.*       &ENDLOC IS THE TRANSFER POINT IF AN EOB IS FOUND.
.*       THE RESULT OF THE POP IS THAT R0 AND R1 CONTAIN THE
.*       ENTITY AND GPR 15 CONTAINS THE CONTROL BYTE.
.*       OPERATORS ARE FOUND IN ONLY THE LOW ORDER BYTE IN R1.
.*         (THE EOB OPERATOR WILL BE FOUND IN THE SAME PLACE
.*          AS OTHER OPERATORS AFTER THE TRANSFER.)
.*       LITERALS OCCUPY BOTH GPR'S.
.*       LABELS ARE RIGHT ADJUSTED IN R1.
.*.
&NAME    ZGPR  R15                   CLEAR REGISTER
         IC    R15,0(&REG.)          GET CONTROL BYTE.
         LR    R14,R15               TRANSFER IT.
         ADDG  &REG,1                ADD ONE TO COUNT.
         N     R14,=F'128'           TEST FOR OPERATOR.
         BZ    OPO&SYSNDX            YES, A OPERATOR.
         LR    R14,R15               NO, TRANSFER CONTROL BYTE.
         N     R14,=F'64'            TEST FOR OPERAND
         BZ    OPN&SYSNDX            YES, A LABEL OPERAND.
         LA    R14,8                 NO, A LITERAL OPERAND.
L1&SYSNDX SLDL R0,8                  SHIFT.
         IC    R1,0(&REG.)           GET NEXT CHARACTER.
         ADDG  &REG,1                ADD ONE TO COUNT.
         BCT   R14,L1&SYSNDX         BRANCH AND COUNT.
         B     L3&SYSNDX             TERMINATE.
OPO&SYSNDX ZGPR R0                   OPERATOR. CLEAR R0.
         ZGPR  R1                    AND ONE.
         IC    R1,0(&REG.)           GET THE OPERATOR.
         ADDG  &REG,1                AND ADD ONE TO THE COUNT.
         BCE   &ENDLOC,R1,X26        IS IT AN EOB...
         B     L3&SYSNDX             NO, TERMINATE.
OPN&SYSNDX ZGPR R0                   OPERAND, OR LABEL THAT IS.
         ZGPR  R1                    CLEAR REGISTERS.
         LR    R14,R15               GET COUNT LENGTHE.
         N     R14,=F'15'            EDIT.
L2&SYSNDX SLDL R0,8                  SHIFT
         IC    R1,0(&REG.)           GET CHARACTR.
         ADDG  &REG,1                ADD ONE TO COUNT.
         BCT   R14,L2&SYSNDX         BRANCH AND COUNT.
L3&SYSNDX EQU  *                     THIS IS THE END.
         MEND
         SPACE 3
         MACRO
&NAME    POPP  &REG,&ENDLOC
.*.
.*$MACRO=POPP       DATE=02/00/80       SOURCE=LDW
.*$MACRO=POP        DATE=04/00/79       SOURCE=UCLA
.*       THE POP MACRO WILL POP ONE ENTITY FROM THE GENERAL
.*       STACKS POINTED TO BY GPR &REG. IF AN EOB IS FOUND, CONTROL
.*       WILL TRANSFER TO &ENDLOC.
.*       AN EOB WILL BE FOUND IN THE ENTITY REGISTER AFTER THE
.*       TRANSFER.
&NAME    SH    &REG,=H'12'
         LM    R15,R1,0(&REG.)
         LR    R14,R15
         N     R14,=F'128'
         BM    GO&SYSNDX
         BCE   NO&SYSNDX,R1,X26
         B     GO&SYSNDX
NO&SYSNDX ADDG &REG,12
         B     &ENDLOC
GO&SYSNDX EQU  *
         MEND
         SPACE 3
         MACRO
&NAME    CHR   &END
.*.
.*$MACRO=CHR        DATE=04/00/79       SOURCE=UCLA
.*       THE CHR MACRO WILL PICK UP ONE CHARACTER FROM THE POINTER
.*       IN R4. IF THE CHARACTER IS A BLANK, IT WILL BE IGNORED.
.*       IF THE CHARACTER IS AN EOB, CONTROL WILL TRANSFER TO &END.
.*.
&NAME    ZGPR  R3
         IC    R3,0(R4)
         ADDG  R4,1
         C     R3,=F'64'     BLANK
         BE    &NAME
         C     R3,=F'38'     EOB
         BE    &END
         MEND
         SPACE 3
         MACRO
&NAME    SCANC &LIST,&LENGTH,&FINDADS
.*.
.*$MACRO=SCANC      DATE=04/00/79       SOURCE=UCLA
.*
.*       THE SCANC MACRO WILL SCAN &LIST FOR THE CHARACTER PRESENT
.*       IN R3. &LENGTH IS THE LENGTH OF THE LIST AND &FINDADS IS
.*       THE TRANSFER ADDRESS IF A MATCH IS MADE.
.*         R0  IS USED FOR THE TEST CHR. FROM THE LIST.
.*         R1  IS THE INDEX OF &LIST.
.*         R3  IS THE SCAN CHARACTER.
.*         GPR R14 IS THE INCREMENT GPR.
.*         GPR 15 IS THE UPPER LIMIT GPR.
.*.
&NAME    ZGPR  (R0,R1)
         LA    R14,1
         LA    R15,&LENGTH-1
GET&SYSNDX IC  R0,&LIST.(R1)
         CR    R0,R3
         BE    &FINDADS
         BXLE  R1,R14,GET&SYSNDX
         MEND
         SPACE 3
         MACRO
&NAME    LOOKUP
.*.
.*$MACRO=LOOKUP     DATE=04/00/79       SOURCE=UCLA
.*.
&NAME    BAL   R14,LOOK
         MEND
         EJECT
         MACRO
&LBL     TSENTRY &Z,&BASE=R12,&SYMREG=YES,&PL=,&GETMAIN=0,&MACRO=,     X
               &DSECT=NO,&LOAD=,&MAP=,&PARSE=,&EXIT=,&SP=1,&EPS=
.*.
.*$MACRO=TSENTRY    DATE=04/00/79       SOURCE=UCLA
.*
.* LAST UPDATED:
.*  WDD:  1/11/77 - ADD EPS=, SUPPORT MULTIPLE ENTRY POINTS
.*  WDD:      /76 - ADD EXIT=, EXIT ROUTINE GENERATION
.*  WDD:      /76 - ADD BASE=(BASE1,BASE2), PROVISION FOR 2ND BASE REG
.*.
         GBLB  &GDAIRM,&GPARSEM         FLAGS TO AVOID DUPLICATES
         GBLB  &GDAIR,&GPARSE           DAIR OR PARSE LOADED
         LCLA  &A,&J
         LCLB  &C,&P,&D,&I,&M
         LCLC  &PARNAME                 ENTRY PARM IF PARSE LOADED
         LCLA  &X,&N,&X1
         LCLC  &COM,&ADD
&N       SETA  N'&EPS                   NO. OF ALTERNATE ENTRY POINTS
&ADD     SETC  '&LBL'
&PARNAME SETC  ''
         SPACE 2
TSDSECT  DSECT
TSAVE    DS    18F                      SAVE AREA
         TSCPPL
         AIF   ('&PL' EQ '').L12
TSECB    DS    F                        ECB FOR THE TSO SERVICES
&A       SETA  1
.L1      AIF   ('&PL(&A)' NE 'CSCAN').L2
&C       SETB  1
         AGO   .L7
.L2      AIF   ('&PL(&A)' NE 'PARSE').L3
&P       SETB  1
         AGO   .L7
.L3      AIF   ('&PL(&A)' NE 'DAIR').L4
&D       SETB  1
         AGO   .L7
.L4      AIF   ('&PL(&A)' NE 'IO').L5
&I       SETB  1
         AGO   .L7
.L5      AIF   ('&PL(&A)' NE 'MESSAGE').L6
&M       SETB  1
         AGO   .L7
.L6      MNOTE 4,'UNKNOWN PL PARAMETER = &PL(&A)'
.L7      ANOP
&A       SETA  &A+1
         AIF   (&A LE N'&PL).L1
         AIF   ('&PARSE(2)' EQ '').L7E
&M       SETB  1                        GENERATE THE MESSAGE STUFF
.L7E     AIF   (NOT &C).L8
         TSCSPL
.L8      AIF   (NOT &P).L9
         TSPPL
.L9      AIF   (NOT &D).L10
         TSDAPL
DAPBAREA DS    22F *                    AREA FOR DAIR PARAMETER BLOCK
         TSDMPL
.L10     AIF   (NOT &I).L11
         TSIOPL
.L11     AIF   (NOT &M).L12
         TSMPL
.L12     ANOP
&J       SETA  0
.L12L    ANOP
&J       SETA  &J+1
         AIF   ('&LOAD(&J)'  EQ  '').L12Z
&LOAD(&J) DS   F
         AGO   .L12L
.L12Z    AIF   ('&MACRO' NE 'YES').L12A
         SPACE 2
***********************************************************************
*                                                                     *
*        DYNAMIC STORAGE DEFINED BY USER TSWORK MACRO                 *
*                                                                     *
***********************************************************************
         SPACE
         DS    0D                       BEGIN ON DOUBLE WORD BOUNDARY
         TSWORK
.L12A    AIF   ('&GETMAIN' EQ '0').L12B
TSWORK   DS    0D                       POINTER TO USER WORK AREA
.L12B    ANOP
TSDSECTL DS    0D
         AIF   ( NOT &D ).NODM
         AIF   ( &GDAIRM ).NODM
&GDAIRM  SETB  1                        SET 1 TIME FLAG
         EJECT
         IKJDAP08
DAPB08L  EQU   *-DAPB08 *               LENGTH OF DAPB08 BLOCK
         EJECT
         IKJDAP18
DAPB18L  EQU   *-DAPB18 *               LENGTH OF DAPB18 BLOCK
         SPACE 3
         IKJDAP1C
DAPB1CL  EQU   *-DAPB1C *               LENGTH OF DAPB1C BLOCK
         EJECT
         IKJDAP30
DAPB30L  EQU   *-DAPB30 *               LENGTH OF DAPB30 BLOCK
.NODM    ANOP
&J       SETA  0
         AGO   .L32B
.L32L    ANOP
         MNOTE *,'GENERATED DSECT FOR &MAP(&J) '
.L32B    ANOP
&J       SETA  &J+1
         AIF   ('&MAP(&J)'  EQ  '').L32Z
         EJECT
         AIF   ('&MAP(&J)' EQ 'ECT').ECT
         AIF   ('&MAP(&J)' EQ 'PBE').PBE
         AIF   ('&MAP(&J)' EQ 'PSCB').PSCB
         AIF   ('&MAP(&J)' EQ 'UPT').UPT
         AIF   ('&MAP(&J)' EQ 'DSE').DSE
         AIF   ('&MAP(&J)' EQ 'JSCB').JSCB
         AIF   ('&MAP(&J)' EQ 'TSCVT').TSCVT
         AIF   ('&MAP(&J)' EQ 'TJB').TJB
         AIF   ('&MAP(&J)' EQ 'TJBX').TJBX
         AIF   ('&MAP(&J)' EQ 'TSB').TSB
         AIF   ('&MAP(&J)' EQ 'TCB').TCB
         AIF   ('&MAP(&J)' EQ 'CVT').CVT
         AIF   ('&MAP(&J)' EQ 'ECTX').ECTX
         AIF   ('&MAP(&J)' EQ 'TAT').TAT
         AIF   ('&MAP(&J)' EQ 'UVT').UVT
         AIF   ('&MAP(&J)' EQ 'DAPB00').DAPB00
         AIF   ('&MAP(&J)' EQ 'DAPB04').DAPB04
         AIF   ('&MAP(&J)' EQ 'DAPB10').DAPB10
         AIF   ('&MAP(&J)' EQ 'DAPB14').DAPB14
         AIF   ('&MAP(&J)' EQ 'DAPB2C').DAPB2C
         AIF   ('&MAP(&J)' EQ 'DAPB34').DAPB34
         AIF   ('&MAP(&J)' EQ 'PDEDSECT').PDEDS
         MNOTE 4,'UNSUPPORTED MAP PARAMETER &MAP(&J) '
         AGO   .L32L
.ECT     IKJECT
         AGO   .L32L
.ECTX    ECTX
         AGO   .L32L
.PBE     PBE
         AGO   .L32L
.PSCB    IKJPSCB
         AGO   .L32L
.UPT     IKJUPT
         AGO   .L32L
.DSE     IKJDSE
         AGO   .L32L
.TSB     IKJTSB
         AGO   .L32L
.UVT     ANOP
UVT      DSECT
         CCNUVT
         AGO   .L32L
.TCB     IKJTCB
         AGO   .L32L
.CVT     ANOP
CVT      DSECT
         CVT
         AGO   .L32L
.JSCB    IEZJSCB
         AGO   .L32L
.TSCVT   IKJTSCVT
         AGO   .L32L
.TJB     IKJTJB
         AGO   .L32L
.TJBX    IKJTJBX
         AGO   .L32L
.DAPB00  IKJDAP00
DAPB00L  EQU   *-DAPB00                 LENGTH OF DAPB00
         AGO   .L32L
.DAPB04  IKJDAP04
DAPB04L  EQU   *-DAPB04                 LENGTH OF DAPB04
         AGO   .L32L
.DAPB10  IKJDAP10
DAPB10L  EQU   *-DAPB10                 LENGTH OF DAPB10
         AGO   .L32L
.DAPB14  IKJDAP14
DAPB14L  EQU   *-DAPB14                 LENGTH OF DAPB14
         AGO   .L32L
.DAPB2C  IKJDAP2C
DAPB2CL  EQU   *-DAPB2C                 LENGTH OF DAPB10
         AGO   .L32L
.DAPB34  IKJDAP34
DAPB34L  EQU   *-DAPB34                 LENGTH OF DAPB34
         AGO   .L32L
.PDEDS   PDEDSECT
         AGO   .L32L
.TAT     CCNUID
         EJECT
TAT      DSECT
         CCNTAT
         AGO   .L32L
.L32Z    AIF   ('&SYMREG' NE 'YES').L13
         SPACE 2
***********************************************************************
*                                                                     *
*                   DEFINE SYMBOLIC REGISTERS                         *
*                                                                     *
***********************************************************************
         SPACE 2
R0       EQU   0                        THE SYMBOLIC REGISTERS
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
.L13     AIF   ('&DSECT' NE 'NO').L19
         EJECT
&LBL     CSECT
         TSAVE (14,12),,*
         AIF   (&N EQ 0).ONEENT         IF ONLY ONE ENTRY POINT
&COM     SETC  'TSE&SYSNDX.C'
.*       MVI   16(R13),0                PRIMARY ENTRY POINT NUMBER * 4
         XR    R4,R4                    PRIMARY ENTRY POINT NUMBER * 4
         B     &COM-&LBL.(R15)          GO TO COMMON ENTRY
&X       SETA  1
.ELOOP   ANOP
         SPACE 2
         ENTRY &EPS(&X)                 ALTERNATE ENTRY POINT
&EPS(&X) SAVE  (14,12),,*
.*       MVI   16(R13),&X*4             ENTRY POINT NUMBER * 4
         LA    R4,&X*4                  ENTRY POINT NUMBER * 4
&X1      SETA  &X+1                     X + 1
         AIF   (&X1 GT &N).EDONE        IF NEXT IS NULL, NO BRANCH
         B     &COM-&EPS(&X)(R15)       GO TO COMMON ENTRY
&X       SETA  &X+1                     NEXT ENTRY POINT
         AGO   .ELOOP                   PROCESS NEXT ENTRY
.EDONE   SPACE 2
&COM     BALR  &BASE(1),0               LOAD BASE REGISTER
&ADD     SETC  'TSE&SYSNDX.B'
&ADD     EQU   *                        PROGRAM BASE LOCATION
         USNGX &ADD,&BASE(1)            COMMON PROGRAM ADDRESSIBLITY
         AGO   .MULTENT                 JOIN COMMON
.ONEENT  USNGX &ADD,&BASE(1)            ESTABLISH PROGRAM
         LR    &BASE(1),R15             ADDRESSIBLITY
.MULTENT AIF   ('&BASE(2)' EQ '').NOBASE2
         LA    &BASE(2),4095(&BASE(1))  EXTEND PROGRAM ADDRESSIBLITY
         LA    &BASE(2),1(&BASE(2))     WITH 2ND PROGRAM BASE REGISTER
         USNGX &ADD+4096,&BASE(2)
         AIF   ('&BASE(3)' EQ '').NOBASE2
         MNOTE 8,'BASE REGISTER &BASE(3) WAS NOT ESTABLISHED'
         MNOTE 8,'ONLY 2 BASE REGISTERS ARE SUPPORTED'
.NOBASE2 LR    R5,R1                    SAVE PTR TO CPPL
         GETMAIN R,LV=TSDSECTL-TSDSECT+&GETMAIN,SP=&SP
         ST    R13,4(R1)                DO SAVE AREA CHAINING
         ST    R1,8(R13)
         LR    R13,R1                   ESTABLISH ADDRESSABILITY
         USNGX TSDSECT,R13              FOR THE TSDSECT
         MVC   CPPL(CPPLL),0(R5)        COPY CPPL TO TS AREA
         AIF   (NOT(&C OR &P OR &D OR &I OR &M)).L18A
         L     R1,CPPLUPT               GET PTR TO UPT
         L     R2,CPPLECT               GET PTR TO ECT
         LA    R3,TSECB                 GET PTR TO ECB
         SR    R0,R0                    CLEAR ECB
         ST    R0,TSECB
         AIF   (NOT &C).L14
         STM   R1,R3,CSPL               INITIALIZE CSPL
         ST    R0,CSFLG                 ZERO CSFLG
         LA    R0,CSFLG
         ST    R0,CSPLFLG
         LA    R0,CSOA
         ST    R0,CSPLOA
.L14     AIF   (NOT &P).L15
         STM   R1,R3,PPL                INITIALIZE PPL. UPT,ECT,ECB
         LA    R0,TSPARANS              ADRS OF PARSE ANSWER PLACE
         ST    R0,PPLANS                POINTER TO ADRS OF PARSE ANSWER
         ST    R13,PPLUWA               PARSE USER WORK AREA POINTER
         XC    TSPARANS(4),TSPARANS     TO AVOID DUPLICATE IKJRLSA
.L15     AIF   (NOT &D).L16
         STM   R1,R3,DAPL               INITIALIZE DAPL
         L     R0,CPPLPSCB              GET PTR TO PSCB
         ST    R0,DAPLPSCB              SET POINTER TO PSCB
.L16     AIF   (NOT &I).L17
         STM   R1,R3,IOPL               INITIALIZE IOPL
.L17     AIF   (NOT &M).L18A
         ST    R3,MPLECB                INITIALIZE MPL, PTR TO ECB
         LA    R0,CPPL                  ADDRESS OF CPPL
         ST    R0,MPLCPPL               PTR TO CPPL
         LA    R0,MPLCSECT              PTR TO MESSAGE CSECT
         ST    R0,MPLCSECP              PTR TO MESSAGE CSECT ADDRESS
         XC    MPLSW(MPLZL),MPLSW       INITIALIZE REMAINING MPL TO 0
.L18A    ANOP
&J       SETA  0
.L72L    ANOP
&J       SETA  &J+1
         AIF   ('&LOAD(&J)'  EQ  '').L72Z
         SPACE 2
         LOAD  EP=&LOAD(&J)
         ST    R0,&LOAD(&J)
         MNOTE *,'MODULE  &LOAD(&J) LOADED'
         AIF   ('&LOAD(&J)'  NE  'IKJDAIR').L72P
&GDAIR   SETB  1                        INDICATE DAIR LOADED
         AGO   .L72L
.L72P    AIF   ('&LOAD(&J)'  NE  'IKJPARS').L72L
&GPARSE  SETB  1                        PARSE WAS LOADED
&PARNAME SETC  'IKJPARS'
         AGO   .L72L
.L72Z    AIF   ('&PARSE(1)'   EQ '').L57K
         SPACE 2
***********************************************************************
*                                                                     *
*        PARSE THE COMMAND LINE                                       *
*                                                                     *
***********************************************************************
         SPACE 2
         TSPARSE CBUF=(CPPLCBUF,I),PCL=(=V(&PARSE(1)),I),              *
               SYNAD=&PARSE(2),ENTRY=&PARNAME
         MNOTE *,'COMMAND LINE WILL BE PARSED'
.L57K    AIF   ('&PARSE(2)' EQ '' AND '&EXIT' EQ '').L18
         B     TSE&SYSNDX
         AIF   ('&PARSE(2)'  EQ  '' OR &GPARSEM EQ 1).L57M
         SPACE 3
***********************************************************************
*                                                                     *
*        PARSE ERROR ANALYSIS SUBROUTINE                              *
*                                                                     *
***********************************************************************
         TSPARERR
         MNOTE  *,'PARSE ERROR ANALYSIS ROUTINE GENERATED'
&GPARSEM SETB  1                        PARSE ERROR ANALYSIS GENERATED
.L57M    AIF   ('&EXIT' EQ '').L58K
         SPACE 2
***********************************************************************
*                                                                     *
*        COMMAND PROCESSOR EXIT                                       *
*                                                                     *
***********************************************************************
        MNOTE *,' BRANCH TO &EXIT WITH RC IN R15 TO EXIT'
         SPACE 2
&EXIT(1) EXIT  RC=(15),LV=TSDSECTL-TSDSECT+&GETMAIN,SP=&SP
.L58K    SPACE 2
TSE&SYSNDX DS  0H
.L18     AIF   (&N EQ 0).L18W
         LR    R15,R4                   SET ENTRY POINT NUMBER * 4
         MNOTE *,' REGISTER 15 CONTAINS ENTRY POINT NUMBER * 4'
         SPACE
.L18W    MNOTE *,' THE FOLLOWING BASE REGISTERS HAVE BEEN ESTABLISHED'
         MNOTE *,' '
         MNOTE *,'         USING TSDSECT,R13'
         MNOTE *,'         USING &ADD,&BASE(1) '
         AIF   ('&BASE(2)' EQ '').L19
         MNOTE *,'         USING &ADD+4096,&BASE(2)'
.L19     SPACE 4
         MEND
         SPACE 5
         MACRO
&LBL     EXIT  &LV=72,&SP=1,&RC=0,&SVC3=NO
.*$MACRO=EXIT       DATE=04/00/79       SOURCE=UCLA
&LBL     LR    R1,R13                   SAVE FREEMAIN ADD
         L     R13,4(R13)               UNCHAIN
         AIF   ('&RC' EQ '&RC(1)').L0
         ST    &RC(1),16(R13)            SAVE RETURN CODE
.L0      ANOP
         FREEMAIN R,LV=&LV,A=(1),SP=&SP
         LM    R14,R12,12(R13)
         AIF   ('&RC' EQ '&RC(1)').L00
         AGO   .L2
.L00     AIF   ('&RC' EQ '0').L1
         LA    R15,&RC
         AGO   .L2
.L1      ANOP
         SR    R15,R15
.L2      AIF   ('&SVC3' NE 'YES').L3
         SVC   3
         MEXIT
.L3      ANOP
         BR    R14
         MEND
         TITLE 'C A L C  -  THE DRIVER FOR THE DESK CALCULATOR.'
         MACRO
         TSWORK
TPUTSAVE DS    5F                       REGISTER SAVE AREA
TGETLEN  DS    H                        LENGTH OF LAST TGET
         DS    H                        UNUSED
TMPMAC   TMPMAC MF=L                    REMOTE LIST FOR TMPMAC
TMPMACL  EQU   *-TMPMAC                 LENGTH OF THE LIST
CSTEMP   DS    F                        POINTER TO 4K
CALCFLAG DS    F
CSUSER   DS    26D
         DS    D
         DS    18F
         DS    F
         DS    F
CSSTOR   DS    900X
PFLAG    DS    X
         DS    3X
CARD     DS    (CHRMAX+5)X
PSTACK   DS    (FACTOR)X
         DS    0D
OUTSTAK  DS    144X
BUFF     EQU   CARD
         MEND
         SPACE 2
         MACRO
&LABEL   SETUP &FAKE
         AIF   ('&LABEL' EQ '').END
&LABEL   DS    0H
.END     MEND
         SPACE 2
*        ASSEMBLY PARAMETERS
LINEMAX  EQU   2                     THE MAXIMUM NUMBER OF LINES INPUT
FACTOR   EQU   LINEMAX*220+10
CHRMAX   EQU   LINEMAX*40            THE MAXIMUM NUMBER OF CHARS INPUT
         EJECT
CALC     TSENTRY BASE=R12,MACRO=YES,EXIT=EXIT,GETMAIN=4096,MAP=ECT
F0       EQU   0
F2       EQU   2
F4       EQU   4
F6       EQU   6
         EJECT
         XC    CALCFLAG(4),CALCFLAG
         XC    PFLAG(1),PFLAG           CLEAR FLAGS
         XC    CSUSER(250),CSUSER       CLEAR USER STORE
         XC    CSUSER+250(250),CSUSER+250   AND MORE...
         SPACE 2
         LA    R0,TSWORK                ADDRESS OF 4K GETMAINED  *WDD*
         ST    R0,CSTEMP                IN CSTEMP                *WDD*
         L     R0,=XL4'08260000'     INITILIZE SAVE STACK.
         ST    R0,CSSTOR             AT THIS POINT.
         SPIE  PROGERR,(12,15)          SET UP SPIE EXIT          *WDD*
         L     R1,CPPLECT               ADDRESS OF ECT            *WDD*
         TM    ECTSWS-ECT(R1),ECTNOPD   OPERANDS PRESENT          *WDD*
         BO    MAIN2                    NO                       *WDD*
         MVI   BUFF,X'03'               PRIME THE BUFFER         *WDD*
         MVC   BUFF+1(CHRMAX),BUFF      FOR 81 CHARACTERS        *WDD*
         L     R15,CPPLCBUF             POINTER TO CBUF          *WDD*
         LH    R1,0(R15)                LENGTH OF CBUF           *WDD*
         LH    R2,2(R15)                OFFSET TO OPERANDS
         AH    R2,=H'4'                 RELATIVE TO CBUF
         SR    R1,R2                    LENGTH OF OPERANDS
         BNP   MAIN2                                              *WDD*
         STH   R1,TGETLEN               SIMULATE THE TGET LENGTH  *WDD*
         LA    R15,0(R2,R15)            POINT AT OPERANDS         *WDD*
         BCTR  R1,0                     -1 FOR EXECUTE
         EX    R1,#MVC#
#MVC#    MVC   BUFF(0),0(R15)           == EXECUTED MVC ===
         LH    R1,TGETLEN
         B     MAIN3
         EJECT
         INUSE
MAIN2    EQU   *                     YES...
         L     R1,CPPLECT               ADDRESS OF ECT            *WDD*
         TM    ECTSWS-ECT(R1),ECTNOPD   OPERANDS PRESENT ?        *WDD*
         BZ    LEAVE                    ES  ... LEAVE
*WDD*    LA    R2,MSG                SET UP REG 2
         SETUP                       NOW THE HEADING.
         TPUTX 'CALC: ',ASIS         WAS'ENTER EQUATION;'
         SPACE 3
MAIN1    EQU   *                        WAITING FOR A REPLY.
         MVI   BUFF,X'03'
         MVC   BUFF+1(CHRMAX),BUFF      TOTAL OF 81 BYTES
         LA    R1,BUFF                  INPUT BUFFER ADDRESS
         LA    R0,CHRMAX-1              MAXIMUM LENGTH TO READ
         O     R1,=X'80000000'          INDICATE TGET
         TGET  (1),(0),R                GET A STRING
         SPACE 2
         BXH   R15,R15,MAIN2            ON ANY ERROR  OR ATTENTION
         LTR   R1,R1                    WAS ANYTHING READ ?
         BZ    MAIN2                    NO
         STH   R1,TGETLEN               LENGTH OF STRING
         SPACE
MAIN3    LA    R15,BUFF                 FOLD THE INPUT TO UPPER CASE
UPPERL   OI    0(R15),X'40'             FOLD THIS CHARACTER
         LA    R15,1(R15)               POINT TO NEXT CHARACTER
         BCT   R1,UPPERL                LOOP FOR STRING LENGTH
         EJECT
         INUSE
         CLC   BUFF(6),=C'POLISH'    HOW ABOUT POLISH....
         BE    POLISHF               YES...
         CLC   BUFF(6),=C'RESUME'    DID HE SAY RESUME...
         BE    RESUME                YES...
         CLC   BUFF(3),=C'END'
         BE    LEAVE                 YES...
         CLC   BUFF(4),=C'AUTO'
         BE    AUTO
         CLC   BUFF(3),=C'DO '       DID HE SAY DO    ...         *WDD*
         BE    DO                    YES...                       *WDD*
         CLC   BUFF(4),=C'HELP'      DID HE SAY HELP  ...         *WDD*
         BE    HELP                  YES...                       *WDD*
         CLI   BUFF,C'?'                ? ENTERED                 *WDD*
         BNE   NOSUBCMD                 NO                        *WDD*
         SPACE 2
         TPUTX 'ENTER AN EQUATION, SUBCOMMAND OR END'             *WDD*
         B     MAIN2                                              *WDD*
POLISHF  OI    PFLAG,X'01'
         B     MAIN2
RESUME   NI    PFLAG,X'FE'              TURN OFF POLISH
         B     MAIN2
AUTO     XI    CALCFLAG,B'10000000'
         B     MAIN2
LEAVE    XR    R15,R15                  ZERO RETURN CODE
         B     EXIT                     AND EXIT
         EJECT
NOSUBCMD XC    OUTSTAK(8),OUTSTAK    CLEAR OUTPUT AREA FOR US.
         LA    R1,BUFF               GET THE ADDRESS OF THE BUFFER.
         LR    R2,R1                 IN BOTH PLACES.
         ZGPR  R0                    CLEAR SOME GPR'S
         ZGPR  R3                    ...
         ZGPR  R8                    ...
         ZGPR  R9                    ...
         LA    R4,X'03'              GET A CURSOR.                  SSL
         LA    R5,X'15'              AND OTHER CHARACTERS.
         LA    R6,X'7F'              ...
         LA    R7,X'40'              ...
LOOP1    IC    R0,0(R1)              GET EACH CHARACTER
         CR    R0,R4                 AND GO AROUND THE STORE IF
         BE    FOUND                 IT BELONGS TO THE SPECIAL
         CR    R0,R5                 GROUP.
         BE    ADD                   ...
         CR    R0,R6                 ...
         BE    ADD                   ...
         CR    R0,R7                 ...
         BE    ADD                   ...
         STC   R0,0(R2,R3)           OK. STORE THE CHARACTER.
         ADDG  R3,1                  ADD ONE TO THE COUNT.
         C     R3,=A(CHRMAX+1)
         BE    CALC$ERO              YES...
         ADDG  R8,1                  ADD ONE TO POSITIONAL COUNT.
         C     R8,=F'40'             IS IT AT 40...
         BL    ADD                   NO
         ZGPR  R8                    YES, ZERO IT...
         ADDG  R9,1                  ADD ONE TO THE LINE COUNT.
ADD      ADDG  R1,1                  ADD ONE TO INPUT LOC.
         B     LOOP1                 GO BACK.
FOUND    C     R3,=F'0'              NO COUNT OF CHARACTERS...
         BE    MAIN2                 YES...                      *WDD*
         TM    CALCFLAG,B'10000000'
         BZ    NOUSE
         LA    R1,0(R2,R3)
         S     R3,=F'1'
         LA    R15,0(R2,R3)
         CLI   R0(R15),C':'
         BE    NOPRT
         CLI   0(R15),C';'
         BE    NOPRT
         MVC   0(5,R1),USEITT
         LA    R3,6(R3)
         LA    R14,5
         B     NOUSEA
NOPRT    MVC   0(4,R1),USEITT+1
         LA    R3,5(R3)
         LA    R14,4
NOUSEA   LA    R8,0(R14,R8)
         C     R8,=F'40'
         BL    NOUSE
         S     R8,=F'40'
         ADDG  R9,1
NOUSE    EQU   *
         LA    R0,38                 SET UP LAST CHARACTER
         STC   R0,0(R2,R3)           STORE IT
         L     R15,CSTEMP
         USNGX STACKS,R15
         LA    R1,TS1
         ST    R1,A1T1
         ST    R1,A2T1
         LA    R1,TS2
         ST    R1,A1T2
         LA    R1,TS3
         ST    R1,A1T3
         ST    R1,A2T3
         LA    R1,TS4
         ST    R1,A1T4
         ST    R1,A2T4
         DROPX R15
         LA    R1,CARD               RESTORE ADDRESS OF CARD.
         ST    R1,LIST1              STOER IT IN LIST ONE.
         LA    R1,PSTACK             GET ADDRESS OF STACK.
         ST    R1,LIST1+4            STORE IT IN LIST ONE
         L     R1,=A(LIST1)          GET ARGUMENT ADDRESS.
         L     R15,=V(PGEN)          AND ADDRESS OF POLISH GENERATOR
         BALR  R14,R15               GO THERE
         LTR   R15,R15               TEST REG R15 AT RETURN
         BC    6,CALC$ERR            NO ZERO MEANS ERROR.
         TM    PFLAG,1               TEST FOR POLISH.
         BO    PDISP                 YES... DISPLAY POLISH LINE.
         LA    R1,PSTACK             GET ADDRESS OF POLISH STACK
         ST    R1,LIST2              STORE IT IN LIST TWO
         LA    R1,CSUSER             GET ADDRESS OF USER
         ST    R1,T1                 STORE IN IN LIST TWO
         LA    R1,OUTSTAK            GET ADDRESS OF OUTPUT AREA
         ST    R1,T2                 STORE IT IN LIST TWO
         L     R1,=A(LIST2)          GET ARGUMENT ADDRESS
         STM   R2,R13,SPIESAVE                                    *WDD*
         L     R15,=V(XCUTER)        AND ADDRESS OF INTERPRETER
         BALR  R14,R15               GO THERE
         LTR   R15,R15               TEST REGISTER R15
         BC    6,CALC$ERR            NON ZERO MEANS ERROR
         LA    R1,64                 GET A BLANK
         LTR   R8,R8                 TEST POSITIONAL COUNT.
         BZ    LOOP2                 IF ZERO THE END OF A LINE
LOOP3A   STC   R1,0(R2,R3)           FILL OUT THE LINE WITH
         ADDG  R3,1                  BLANKS
         ADDG  R8,1                  ...
         C     R8,=F'40'             AT END OF LINE...
         BL    LOOP3A                NO...
         ADDG  R9,1                  ADDONE TO LINE COUNT.
LOOP2    LR    R4,R3                 TRANSFER CHARACTER COUNT.
LOOP4    STC   R1,0(R2,R3)           CONTINUE FILLING SCREEN
         ADDG  R3,1                  IMMAGE WITH BLANKS
         C     R3,=F'479'            ...
         BNH   LOOP4                 ...
         AR    R2,R4                 FIND FIRST OUTPUT POINT
         LA    R3,OUTSTAK            GET ADDRESS OF OUTPUT AREA
         LR    R10,R9                TRANSFER LINE COUNT.
LOOP31   C     R10,=F'12'            ARE WE AT THE END OF THE SCREEN...
         BE    EOB1                  YES...
         LM    R15,R1,0(R3)          GET THE OUTPUT RESUMT.
         LTR   R15,R15               IS IT A XERO LAGEL
         BZ    EOB1
         ADDG  R3,12                 ADD TO INPUT COUNT.
         ADDG  R10,1                 NO, ADD ONE TO LINE COUNT.
         ZGPR  R5                    NO, CLEAR GPRS...
         ZGPR  R14                   ...
SHIFT1$  SLDL  R14,8                 SHIFT CHARACTER INTO R14
         LTR   R14,R14               IS IS ZERO
         BZ    SHIFT1$               YES, BRANCH BACK.
STORE1   STC   R14,0(R2,R5)          NO, STOER IT
         ADDG  R5,1                  ADD ONE TO COUNT
         ZGPR  R14                   ZERO GPR R14
         SLDL  R14,8                 SHIFT ONE MORE
         LTR   R14,R14               IS IT ZERO
         BP    STORE1                NO, STORE IT.
         LA    R14,126               GET AN EQUALS SIGN.
         STC   R14,4(R2)             STORE IT AWAY.
         LA    R5,6(R2)              GET A NEW ADDRESS.
         STM   R0,R1,STORE           STORE OUTPUT IN STORAGE.
         LD    F6,STORE              GET INTO FPR 6.
         LTDR  F0,F6                 TEST FOR ZERO...
         BZ    CALCZERO              ...
         BP    GOON1                 GO THERE IS POSITIVE.
         LPDR  F0,F0                 MAKE IT POSITIVE.
         MVI   0(R5),C'-'            MOVE IN THE MINUS SIGN.
GOON1    ADDG  R5,1                  ADDONE TO COUNT.
         CE    F0,=E'1E10'           IS THE NUMBER GREATER THAN 10
         BH    EOUT                  YES...
         CE    F0,=E'1E-3'           IS THE NUMBER LESS AND 0.0001
         BL    EOUT                  YES...
         BAL   R14,OUTCNV            OTHERWISE OUTPUT F FORMAT.
         B     LOOP3                 GO AROUND THIS CODE.
EOUT     EQU   *                     EXPONENTIAL OUTPUT.
         ZGPR  R9                    CLEAR GPR R9
         CE    F0,=E'1'
         BL    NEGEXP
TEST$    CE    F0,=E'10'
         BL    GOON2
         DD    F0,=D'10'
         ADDG  R9,1
         B     TEST$
GOON2    BAL   R14,OUTCNV
         B     EXPOUT
NEGEXP   CE    F0,=E'1'
         BH    GOON3
         ADDG  R9,1
         MD    F0,=D'10'
         B     NEGEXP
GOON3    BAL   R14,OUTCNV
         LNR   R9,R9
EXPOUT   LTR   R9,R9
         BZ    ZERO1
         MVI   24(R2),C'E'
         LTR   R9,R9
         BP    GOGO
         MVI   25(R2),C'-'
         LPR   R9,R9
GOGO     CVD   R9,STORE
         UNPK  26(2,R2),STORE+6(R2)
         OI    27(R2),X'F0'
ZERO1    B     LOOP3
CALCZERO MVC   7(3,R2),=C'0.0'
LOOP3    MVC   20(4,R2),24(R2)          MOVE EXPON LEFT 4 BYTES  *WDD*
         MVC   24(4,R2),=C'    '        AND BLANK OLD EXPONENT   *WDD*
*        THIS GETS RID OF 4 DIGITS WHICH ARE NOT WITHIN THE ACCURACY
         ADDG  R2,40
         B     LOOP31
         SPACE 2
OUTCNV   SR    R4,R4
         SR    R15,R15
         BCTR  R4,0
REDUC    CD    F0,=D'10'
         BL    LESS
         DD    F0,=D'10'
         ADDG  R15,1
         BCT   R4,REDUC
LESS     LPR   R4,R4
         STE   F0,T
         MVC   T+1(3),=XL3'0'
         AD    F0,T
         SR    R6,R6
OLOOP    BCT   R6,FRC
         BR    R14
FRC      SDR   F2,F2
         LE    F2,=XL4'4E000000'
         AWR   F2,F0
         STD   F2,WORD
         AD    F2,=D'0'
         SDR   F0,F2
         BP    SET
         LTR   R4,R4
         BP    SET
         TM    WORD+7,X'FF'
         BZR   R14
SET      MD    F0,=D'10'
         OI    WORD+7,X'F0'
         MVC   0(1,R5),WORD+7
         LA    R5,1(R5)
         BCT   R4,OLOOP
         MVI   0(R5),C'.'
         LA    R5,1(R5)
         LA    R6,16
         SR    R6,R15
         B     OLOOP
EOB1     C     R10,=F'10'
         BNH   PUTOUT
         L     R15,0(R3)
         LTR   R15,R15
         BZ    CALC$EOB
         SH    R2,=H'2'
         MVC   0(1,R2),=C'*'
CALC$EOB ZGPR  R2
WRITE    EQU   *
         TPUTX BUFF,479,MF=B
         BAL   R14,$TPUTX               PUT BUFFER 40 CHAR AT A TIME
         B     MAIN2
         SPACE 2
PUTOUT   LA    R3,BUFF
         SR    R2,R3
         TPUTX BUFF,(R2),MF=B
         BAL   R14,$TPUTX               PUT THE BUFFER TO TERMINAL
         B     MAIN2                    WAS MAIN1                *WDD*
         SPACE 2
PDISP    EQU   *
         LA    R1,64
         LTR   R8,R8
         BZ    LOOP5
LOOP5A   STC   R1,0(R2,R3)
         ADDG  R3,1
         ADDG  R8,1
         C     R8,=F'40'
         BL    LOOP5A
LOOP5    EQU   *
         LA    R4,PSTACK
CALC$GET STACKO R4,ENDDISP
         LR    R14,R15
         N     R14,=F'128'
         BZ    DISPOP
         N     R15,=F'64'
         BZ    PUTT
         LA    R1,123
         B     PUTT
DISPOP   BCE   CALC$EXP,R1,'%'
         B     PUTT
CALC$EXP LH    R1,=C'**'
PUTT     EQU   *
         ZGPR  R0
         LTR   R1,R1
         BNZ   SHIFTT
         LA    R1,C' '
SHIFTT   SLDL  R0,8
         LTR   R0,R0
         BZ    SHIFTT
STOREE   STC   R0,0(R2,R3)
         ZGPR  R0
         ADDG  R3,1
         SLDL  R0,8
         LTR   R0,R0
         BNZ   STOREE
         LA    R1,64
         STC   R1,0(R2,R3)
         ADDG  R3,1
         B     CALC$GET
ENDDISP  LA    R1,64
ENDLOOP  STC   R1,0(R2,R3)
         ADDG  R3,1
         C     R3,=F'479'
         BL    ENDLOOP
         B     WRITE
         EJECT
         INUSE
CALC$ERO LA    R15,7
         LA    R1,38
         STC   R1,0(R2,R3)
         BCTR  R2,0
CALC$ERR LR    R9,R15
         LTR   R8,R8
         BZ    LOOP21
         LA    R1,64
LOOP3B   STC   R1,0(R2,R3)
         ADDG  R3,1
         ADDG  R8,1
         C     R8,=F'40'
         BL    LOOP3B
LOOP21   LR    R4,R3
LOOP41   STC   R1,0(R2,R3)
         ADDG  R3,1
         C     R3,=F'479'
         BNH   LOOP41
         AR    R2,R4
         C     R9,=F'16'
         BL    KNOWN
         IC    R8,ALPHANUM(R9)
         STC   R8,ERMSG+4
         MVC   0(40,R2),ERMSG
CALC$BKK SETUP
         ADDG  R2,40
         LA    R3,BUFF
         SR    R2,R3
         TPUTX BUFF,(R2),MF=B
         BAL   R14,$TPUTX               GO TPUT THE BUFFER
         B     MAIN1
         SPACE 2
KNOWN    SLL   R9,2
         L     R8,ATABLE(R9)
         MVC   0(40,R2),0(R8)
         ADDG  R2,40
         MVC   0(40,R2),MSSG
         B     CALC$BKK
         EJECT
         INUSE
         USNGX PROGERR,R15
PROGERR  LM    R3,R4,4(R1)
         SRL   R4,24
         LA    R5,BACK
         SLL   R5,8
         SRDL  R4,8
         ST    R5,8(R1)
         BR    R14
         DROPX R15
         SPACE 2
         DROPX R12                                                *WDD*
BACK     LR    R14,R3                   SAVE REGISTER R3
         BALR  R15,0                    GET SOME ADDRESSIBLITY    *WDD*
         USNGX *,R15                                              *WDD*
         LM    R2,R13,SPIESAVE          RESTORE REGISTERS         *WDD*
         DROPX R15                      NOT NEEDED               *WDD*
         USNGX CALC,R12                 PGM ADDRSIBLITY NOW R12  *WDD*
*WDD*    L     R13,4(R13)
*WDD*    LM    R2,R12,28(R13)
         LR    R9,R14
         N     R9,=XL4'F'
         LTR   R8,R8
         BZ    LOOP22
         LA    R1,64
LOOP32   STC   R1,0(R2,R3)
         ADDG  R3,1
         ADDG  R8,1
         C     R8,=F'40'
         BL    LOOP32
LOOP22   LR    R4,R3
LOOP42   STC   R1,0(R2,R3)
         ADDG  R3,1
         C     R3,=F'479'
         BNH   LOOP42
         AR    R2,R4
         LR    R5,R2
         LR    R2,R9
         SLL   R2,2
         L     R1,BTABLE(R2)
         MVC   0(40,R5),MESS1
         MVC   40(40,R5),0(R1)
         LA    R2,80(R5)
         MVC   0(40,R2),MSSG
         B     CALC$BKK                 GO WRITE MESSAGE
         SPACE
SPIESAVE DC    13F'0'                   REGS FOR SPIE RECOVERY  *WDD*
         EJECT
         INUSE
*******************************************************************WDD*
*
* HELP         HELP SUBCOMMAND
*
* INPUT        BUFF - THE BUFFER
*
*******************************************************************WDD*
         SPACE 2
HELP     LH    R3,TGETLEN               LENGTH OF BUFFER
         TMPMAC CMD=(BUFF,(R3)),EXEC=YES,DCB=0,STACK=YES,CMDFAIL=MSG,  $
               MF=(E,TMPMAC),CMDLIB=YES,SCMD=YES,STAX=YES
         SPACE 2
         B     MAIN2                    GO READ NEW INPUT
         EJECT
         INUSE
*******************************************************************WDD*
*
* DO           SEGMENT TO DO A TSO COMMAND AS A SUBCOMMAND
*
* INPUT        BUFF - THE BUFFER
*
*******************************************************************WDD*
         SPACE 2
DO       LH    R3,TGETLEN               LENGTH OF BUFFER
         SH    R3,=H'3'                 - LENGTH OF COMMAND NAME
         BNP   MAIN2                    NO OPERANDS WERE PRESENT
         SPACE 2
         TPUTX 'DOING'
         SPACE 2
         TMPMAC CMD=(BUFF+3,(R3)),EXEC=YES,DCB=0,STACK=YES,CMDFAIL=MSG,$
               MF=(E,TMPMAC),STAX=YES
         SPACE 2
         TPUTX 'DONE'
         B     MAIN2                    GO READ NEW INPUT
         EJECT
         INUSE
*******************************************************************WDD*
*
* $TPUTX       SUBROUTINE TO DISPLAY THE OUTPUT BUFFER
*              AT 40 BYTES PER LINE
*
* INPUT        R1 - POINTS TO BUFFER
*              R0 - CONTAINS LENGTH TO DISPLAY
*
*******************************************************************WDD*
         SPACE 2
$TPUTX   STM   R14,R2,TPUTSAVE          SAVE REGISTERS
         LA    R14,0(R1)                POINTER TO OUTPUT BUFFER
         LR    R2,R0                    LENGTH OF THE STRING
         B     TPUTX1                   BEGIN
         SPACE
TPUTXL   TPUT  (R14),(0)                PUT PART OF STRING
TPUTXNO  LA    R14,40(R14)              POINT AT NEXT 40 CHAR
         S     R2,=F'40'                SUBTRACT 40 FROM LENGTH
         BNP   $TPUTXX                  IF NEG OR ZERO, DONE
         SPACE
TPUTX1   LA    R0,40                    MAXIMUM LENGTH OF LINE
         CR    R2,R0                    REMAINING LENGTH > 40 ?
         BH    *+6                      YES
         LR    R0,R2                    NO, USE REMAINDER
         LR    R1,R0                    LENGTH OF THIS LINE
         LR    R15,R14                  STRING POINTER
TPUTXL1  CLI   0(R15),C' '              DO NOT PRINT BLANK LINES
         BNE   TPUTXL                   AT LEAST ONE NON BLANK
         LA    R15,1(R15)               POINT AT NEXT CHARACTER
         BCT   R1,TPUTXL1
         B     TPUTXNO                  SKIP THIS LINE
         SPACE
$TPUTXX  LM    R14,R2,TPUTSAVE          RESTORE REGISTERS
         BR    R14                      RETURN TO CALLER
         EJECT
         INUSE
*ETUPT   TIME  BIN
*WDD*    MVI   BMES3+3,C'A'
*WDD*    LPR   R1,R0
*WDD*    SR    R0,R0
*WDD*    D     R0,=F'360000'
*WDD*    C     R1,=F'12'
*WDD*    BL    GOOK
*WDD*    BE    *+8
*WDD*    S     R1,=F'12'
*WDD*    MVI   BMES3+3,C'P'
*WDD*    WAS GOOK EQU *
*WDD*    CVD   R1,BDTIME
*WDD*    UNPK  BMES1+1(2),BDTIME+6(2)
*WDD*    OI    BMES1+2,X'F0'
*WDD*    LPR   R1,R0
*WDD*    SR    R0,R0
*WDD*    D     R0,=F'6000'
*WDD*    CVD   R1,BDTIME
*WDD*    UNPK  BMES2(2),BDTIME+6(2)
*WDD*    OI    BMES2+1,X'F0'
*WDD*    LPR   R1,R0
*WDD*    SR    R0,R0
*WDD*    D     R0,=F'100'
*WDD*    CVD   R1,BDTIME
*WDD*    UNPK  BMES3(2),BDTIME+6(2)
*WDD*    OI    BMES3+1,X'F0'
*WDD*    MVC   27(12,R2),BMES1
*WDD*    MVI   39(R2),C' '
*WDD*    TM    CSALTFLG+1,X'01'         TEST FOR MESSAGE WAITING
*WDD*    BZ    *+8
*WDD*    MVI   39(R2),C'*'
*WDD*    BR    R14
*MES1    DC    C'   .'
*MES2    DC    C'  .'
*MES3    DC    C'   AM'
         EJECT
ALPHANUM DC    C'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
USEITT   DC    C';USE:'
WORD     DS    D
SAVE     DS    F
MSSG     DC    CL40'RE-ENTER EQUATION: '
         CNOP  0,8
T        DS    F
         DC    F'4'
STORE    EQU   *
BDTIME   DS    D
ERMSG    DC    CL40'ERR= , RE-ENTER EQUATION:'
ATABLE   DC    F'0'
         DC    A(M1)
         DC    A(M2)
         DC    A(M3)
         DC    A(M4)
         DC    A(M5)
         DC    A(M6)
         DC    A(M7)
         DC    A(M8,M9,M10,M11,M12,M13,M14,M15)
AREA     DS    16X
         CNOP  0,4
LIST1    EQU   *
         DC    F'0'
         DC    F'0'
A1T1     DC    F'0'
A1T2     DC    F'0'
A1T3     DC    F'0'
A1T4     DC    F'0'
LIST2    EQU   *
         DC    F'0'
A2T1     DC    F'0'
A2T3     DC    F'0'
T1       DC    F'0'
A2T4     DC    F'0'
T2       DC    F'0'
MESS1    DC    CL40'*** A PROGRAM INTERRUPTION HAS OCCURRED.'
BTABLE   DC    A(N0)
         DC    A(N1,N2,N3,N4,N5,N6,N7,N8,N9,N10,N11,N12,N13,N14,N15)
         LTORG
STACKS   DSECT
         CNOP  0,8
TS1      DS    (FACTOR*3)X
         CNOP  0,8
TS2      DS    (FACTOR*3)X
         CNOP  0,8
TS3      DS    (FACTOR*3)X
         CNOP  0,8
TS4      DS    4F
         EJECT
CALC     CSECT
M1       DC    CL40'*** ILLEGAL CHARACTER ENCOUNTERED.'
M2       DC    CL40'*** LABEL TOO LONG.'
M3       DC    CL40'*** PROGRAM ERROR '
M4       DC    CL40'*** UNBALANCED PARENTHESIS.'
M5       DC    CL40'*** LITERAL TOO LARGE.'
M6       DC    CL40'*** ILLEGAL OPERATOR SEQUENCE.'
M7       DC    CL40'*** EQUATION TOO LONG.'
M8       DC    CL40'*** ILLEGAL USE OF LITERAL.'
M9       DC    CL40'*** TOO MANY OPERANDS FOR FUNCTION.'
M10      DC    CL40'*** NEGATIVE SQRT NOT ALLOWED.'
M11      DC    CL40'*** ILLEGAL KEY-WORD.'
M12      DC    CL40'*** UNRECOGNIZED FUNCTION.'
M13      DC    CL40'*** OVERFLOW OF SAVE AREA.'
M14      DC    CL40'*** EXPONENTIAL GREATER THAN 174.67309.'
M15      DC    CL40'*** LOG OF NUMBER LE ZERO NOT ALLOWED.'
N0       DC    CL40'    IMPRECISE INTERRUPT'
N1       DC    CL40'    MASKABLE'
N2       EQU   N1
N3       EQU   N1
N4       EQU   N1
N5       EQU   N1
N6       EQU   N1
N7       EQU   N1
N8       EQU   N1
N9       EQU   N1
N10      EQU   N1
N11      EQU   N1
N12      DC    CL40'    EXPONENT OVERFLOW'
N13      EQU   N1
N14      EQU   N1
N15      DC    CL40'    FLOATING-POINT DIVIDE'
         LTORG
*        END
         TITLE 'THE E X E C U T E R.'
*        PRINT NOGEN
XCUTER   CSECT
*        ARGUMENTS ( POINTER IN R0. )
*        1) ADDRESS OF POLISH INPUT STRING.
*        2) ADDRESS OF EXECUTER STACK.
*        3) ADDRESS OF HOLD STACK.
*        4) ADDRESS OF USER STORAGE AREA.
*        5) ADDRESS OF TEMPORARY STOREAGE AREA ( 2 DOUBLE WORDS )
*        6) ADDRESS OF OUTPUT STACK.
*
*        NOTE ON THE FLAG REGISTER.
*
*        BIT   MEANING
*
*        1     COMMA FOUND
*        2     USE IN EFFECT
*        4     MULTIPLE USE KEY WORD FOUND.
*        8     EQUALS SIGN FOUND IN THIE EQUATION.
*        16    SIMI-COLON FOUND (OR COLON)
*        32    INTERRUPT (BOMB OUT)
*        64    END OF RUN - ANY UNSTORED VARIABLES...
*
         STM   R14,R12,12(R13)
         LR    R12,R15
         USING XCUTER,R12
         LR    R2,R1
POLISH   EQU   R3
STACK    EQU   R4
USER     EQU   R5
TEMP     EQU   R6
FLAGS    EQU   R7
OPERR    EQU   R8
COMMAS   EQU   R9
OUTPUT   EQU   R10
SAVER    EQU   R11
         L     POLISH,0(R2)
         L     STACK,4(R2)
         L     USER,12(R2)
         L     TEMP,16(R2)
         L     OUTPUT,20(R2)
         L     COMMAS,8(R2)
         ST    R13,4(USER)
         ST    USER,8(USER)
         LR    R13,USER
         ADDG  USER,72
         ZGPR  (R0,R15)
         LA    R1,38
         PLOP  COMMAS
         ZGPR  FLAGS
         USING UAREA,USER
         SR    R14,R14
         ST    R14,SAVCT
MAIN4    ZGPR  R0
         LA    R1,38
         ZGPR  R15
         PLOP  STACK
MAIN     STACKO POLISH,THATSALL
         LR    R14,R15
         N     R14,=F'128'
         BZ    OPER
         PLOP  STACK
         B     MAIN
OPER     LR    OPERR,R1
         BCE   COMMA3,R1,','
         BCE   EQUALS,R1,'='
         BCE   COLON,R1,':'
         BCE   SIMI,R1,';'
         BCE   MAIN,R1,'&&'
         BCE   UNIRARY,R1,'_'
         BCE   FUNC,R1,'|'
         POPP  STACK,ERR1
         LOOKUP
         STM   R0,R1,0(TEMP)
         LD    F2,0(TEMP)
         POPP  STACK,ERR1
         LOOKUP
         STM   R0,R1,8(TEMP)
         LD    F0,8(TEMP)
         BCE   PLUS,OPERR,'+'
         BCE   MINUS,OPERR,'-'
         BCE   MULT,OPERR,'*'
         BCE   DIV,OPERR,'/'
         BCE   XCUT$EXP,OPERR,'%'
ERR1     EQU   *
ERR3     LA    R0,3
XCUT$ERR L     R13,4(R13)
         ST    R0,16(R13)
         LM    R14,R12,12(R13)
         BR    R14
UNIRARY  POPP  STACK,ERR1
         LOOKUP
         STM   R0,R1,0(TEMP)
         LD    F0,0(TEMP)
         LCDR  F0,F0
X$STORE  STD   F0,0(TEMP)
         LM    R0,R1,0(TEMP)
         LA    R15,192
         PLOP  STACK
         B     MAIN
PLUS     ADR   F0,F2
         B     X$STORE
MINUS    SDR   F0,F2
         B     X$STORE
MULT     MDR   F0,F2
         B     X$STORE
DIV      DDR   F0,F2
         B     X$STORE
XCUT$EXP EQU   *
         LD    F0,8(TEMP)
         L     R15,ADLOG
         BALR  R14,R15
         LTR   R0,R15
         BP    XCUT$ERR
         MD    F0,0(TEMP)
         L    R15,ADEXP
         BALR  R14,R15
         LTR   R0,R15
         BP    XCUT$ERR
         B     X$STORE
COMMA3   LR    R14,FLAGS
         N     R14,=F'1'
         BM    COMMA1
         O     FLAGS,=F'1'
         L     COMMAS,8(R2)
         ZGPR  (R0,R15)
         LA    R1,38
         PLOP  COMMAS
         POPP  STACK,ERR1
         STM   R15,R1,0(TEMP)
         POPP  STACK,ERR6
         PLOP  COMMAS
         LM    R15,R1,0(TEMP)
COMMA4   PLOP  COMMAS
         B     MAIN
COMMA1   POPP  STACK,ERR1
         B     COMMA4
BLNK     L     R15,=C'____'
         LM    R0,R1,0(TEMP)
         LR    R14,FLAGS
         N     R14,=F'64'
         BM    STOREIT
         CLC   SAVCT(4),=F'0'
         BNE   MAIN
         B     STOREIT
EQUALS   O     FLAGS,=F'8'
         POPP  STACK,ARND
         LOOKUP
         STM   R0,R1,0(TEMP)
         STM   R0,R1,$$$$
         POPP  STACK,BLNK
         N     R15,=F'64'
         BM    ERR2
         LTR   R1,R1
         BZ    ERR3
         LR    OPERR,R1
         ZGPR  R0
SHIFT    SLDL  R0,8
         LTR   R0,R0
         BZ    SHIFT
         LR    R1,R0
         N     R1,=F'16'
         BM    TWOS
         LR    R1,R0
         N     R1,=F'32'
         BM    THREES
         LA    R1,R0
         B     SETUP
TWOS     LA    R1,9
         B     SETUP
THREES   LA    R1,17
SETUP    N     R0,=F'15'
         AR    R1,R0
         S     R1,=F'1'
         SLL   R1,3
         LA    R15,MSTORAGE(R1)
         LM    R0,R1,0(TEMP)
         STM   R0,R1,0(R15)
         CLC   SAVCT(4),=F'0'
         BNE   MAIN
         LR    R15,OPERR
STOREIT  L     R14,20(R2)
         ADDG  R14,144
         CR    OUTPUT,R14
         BNL   ARND
         PLOP  OUTPUT
         ZGPR  R15
         ST    R15,0(OUTPUT)
ARND     EQU   *
         LR    R14,FLAGS
         N     R14,=F'64'
         BM    RETURN
         LR    R14,FLAGS
         N     R14,=F'16'
         BM    XCUT$BKK
         B     MAIN
COLON    POPP  STACK,TRYHOLD
         N     R15,=F'64'
         BM    ERR2
         LTR   R1,R1
         ZGPR  R15
COMP     L     R14,KEYWDS(R15)
         C     R14,ENDWD
         BE    NONE
         ADDG  R15,8
         CR    R14,R1
         BNE   COMP
         L     R14,ADS(R15)
         BR    R14
TRYHOLD  POPP  COMMAS,XCUT$BKK
         LOOKUP
         STM   R0,R1,0(TEMP)
         LD    F6,0(TEMP)
         LPDR  F6,F6
         AW    F6,=X'4E00000000000000'
         STD   F6,0(TEMP)
         L     R14,4(TEMP)
         ST    R14,SAVCT
         POPP  COMMAS,ERR6
         N     R15,=F'64'
         BM    ERR2
         O     FLAGS,=F'4'
         ZGPR  R15
COMP1    L     R14,KEYWDS(R15)
         C     R14,ENDWD
         BE    NONE
         ADDG  R15,8
         CR    R14,R1
         BNE   COMP1
         L     R14,ADS(R15)
         BR    R14
         CNOP  0,8
KEYWDS   DC    C'SAVE'
ADS      EQU   *-8
         DC    A(XCUTSAVE)
         DC    C'LOOP'
         DC    A(USE)
         DC    X'0'
         DC    C'USE'
         DC    A(USE)
         DC    C'TACK'
         DC    A(TACK)
         DC    C'DISP'
         DC    A(DISP)
ENDWD    DC    F'0'
SIMI     O     FLAGS,=F'16'
         LR    R14,FLAGS
         N     R14,=F'8'
         BZ    EQUALS
XCUT$BKK N     FLAGS,=X'FFFFFFE6'
         L     STACK,4(R2)
         B     MAIN4
ERR2     LA    R0,8
         B     XCUT$ERR
ERR6     LA    R0,6
         B     XCUT$ERR
NONE     LA    R0,11
         B     XCUT$ERR
FUNCTION EQU   R8
FUNC     POPP  STACK,ERR1
         LR    FUNCTION,R1
         C     FUNCTION,=C'SQRT'
         BE    SQRT
         LA    R15,FNAME
LOOP99   C     FUNCTION,0(R15)
         BE    FOUND99
         CLC   0(4,R15),ENDNAME
         BE    ALLONES
         ADDG  R15,8
         B     LOOP99
ALLONES  EQU   *
ERR7     EQU   *
         LA    R0,12
         B     XCUT$ERR
FOUND99  L     FUNCTION,4(R15)
         LTR   FUNCTION,FUNCTION
         BZ    ERR7
         LR    R14,FLAGS
         N     R14,=F'1'
         BM    ERR4
         POPP  STACK,ERR1
         LOOKUP
         STM   R0,R1,0(TEMP)
         LD    F0,0(TEMP)
         LR    R15,FUNCTION
         BALR  R14,R15
         LTR   R0,R15
         BP    XCUT$ERR
         B     X$STORE
         CNOP  0,4
FNAME    DC    X'00',C'LOG'
ADLOG    DC    V(DLOG)
         DC    X'00',C'EXP'
ADEXP    DC    V(DEXP)
         DC    C'LG10'
         DC    V(DLOG10)
         DC    C'EXIT'
         DC    A(XCUTEXIT)
         DC    X'00',C'ABS'
         DC    V(ABS)
         DC    X'00',C'DEG'
         DC    V(DEG)
         DC    X'00',C'RAD'
         DC    V(RAD)
         DC    X'00',C'SIN'
         DC    V(DSIN)
         DC    X'00',C'COS'
         DC    V(DCOS)
         DC    X'00',C'TAN'
         DC    V(DTAN)
         DC    C'CTAN'
         DC    V(DCTAN)
         DC    C'ATAN'
         DC    V(DATAN)
         DC    C'ASIN'
         DC    V(DARSIN)
         DC    C'ACOS'
         DC    V(DARCOS)
         DC    C'BOOL'
         DC    V(BOOL)
ENDNAME  DC    CL4'    '
XCUTEXIT LTDR  F0,F0
         BP    X$STORE
         XC    SAVCT(4),SAVCT
         B     THATSALL
SQRT     LR    R14,FLAGS
         N     R14,=F'1'
         BM    ERR4
         POPP  STACK,ERR1
         LOOKUP
         STM   R0,R1,0(TEMP)
         LD    F2,0(TEMP)
         LTDR  F2,F2
         BM    ERR5
         LTDR  F0,F2
         BZ    X$STORE
         SR    R1,R1
         IC    R1,0(TEMP)
         LA    R1,65(R1)
         SRA   R1,1
         STC   R1,0(TEMP)
         LD    F0,0(TEMP)
         LA    R1,8
SQLOOP1  LDR   F4,F2
         DDR   F4,F0
         ADR   F4,F0
         HDR   F0,F4
         BCT   R1,SQLOOP1
         B     X$STORE
ERR4     LA    R0,9
         B     XCUT$ERR
ERR5     LA    R0,10
         B     XCUT$ERR
XCUTSAVE EQU   *
         LA    SAVER,SAREA
         ST    SAVER,SAV
ENTER    LA    OPERR,SAREA+900
GETTYPE  IC    R1,0(POLISH)
         ADDG  POLISH,1
         CR    SAVER,OPERR
         BE    XCUT$ERO
         STC   R1,0(SAVER)
         ADDG  SAVER,1
         LR    R14,R1
         N     R14,=F'128'
         BZ    OPER1
         LR    R14,R1
         N     R14,=F'64'
         BZ    OPRN
         LA    R14,8
GETLIT   IC    R1,0(POLISH)
         STC   R1,0(SAVER)
         ADDG  POLISH,1
         CR    SAVER,OPERR
         BE    XCUT$ERO
         ADDG  SAVER,1
         BCT   R14,GETLIT
         B     GETTYPE
OPRN     LR    R14,R1
         N     R14,=F'15'
         B     GETLIT
OPER1    ZGPR  R1
         IC    R1,0(POLISH)
         ADDG  POLISH,1
         BCE   SIMMI,R1,';'
         BCE   SIMMI,R1,':'
         BCE   XCUT$EOB,R1,X26
         CR    SAVER,OPERR
         BE    XCUT$ERO
         STC   R1,0(SAVER)
         ADDG  SAVER,1
         B     GETTYPE
SIMMI    IC    R1,=C';'
         LA    R0,3(SAVER)
         CR    R0,OPERR
         BNL   XCUT$ERO
         STC   R1,0(SAVER)
         LA    R1,8
         STC   R1,R1(SAVER)
         LA    R1,38
         STC   R1,2(SAVER)
         ADDG  SAVER,1
         ST    SAVER,SAV
         B     XCUT$BKK
TACK     EQU   *
         L     SAVER,SAV
         B     ENTER
XCUT$EOB IC    R1,=C';'
         LA    R0,3(SAVER)
         CR    R0,OPERR
         BNL   XCUT$ERO
         STC   R1,0(SAVER)
         LA    R1,8
         STC   R1,1(SAVER)
         LA    R1,38
         STC   R1,2(SAVER)
         ADDG  SAVER,1
         ST    SAVER,SAV
         B     THATSALL
XCUT$ERO L     SAVER,SAV
         LA    R1,8
         STC   R1,0(SAVER)
         LA    R1,38
         STC   R1,1(SAVER)
         LA    R0,13
         B     XCUT$ERR
DISP     EQU   *
         LA    R0,12
         B     XCUT$ERR
USE      LR    R14,FLAGS
         N     R14,=F'4'
         BZ    USEIT
         L     R14,SAVCT
         LTR   R14,R14
         BZ    XCUTZERO
         LR    R14,FLAGS
         N     R14,=F'32'
         BM    USEIT0
         L     R14,SAVCT
         S     R14,=F'1'
         N     R14,=F'1023'
         ST    R14,SAVCT
         N     R14,=F'15'
         BNZ   USEIT
*WDD*    CSDEF
XCUTER   CSECT
         L     OPERR,4(R13)
         L     OPERR,64(OPERR)
*WDD*    USING CS,OPERR
*WDD*    WAITE CONSOLE,TIME=0
*WDD*    TM    104(OPERR),2
*WDD*    BO    THATSIT
USEIT    O     FLAGS,=F'2'
         LR    SAVER,POLISH
         LA    POLISH,SAREA
         B     XCUT$BKK
USEIT0   XC    SAVCT(4),SAVCT
         B     USEIT
THATSIT  O     FLAGS,=F'32'
         XC    SAVCT(4),SAVCT
         B     USEIT
THATSALL LR    R14,FLAGS
         N     R14,=F'2'
         BM    RESTORE
         O     FLAGS,=F'64'
         LR    R14,FLAGS
         N     R14,=F'8'
         BZ    EQUALS
RETURN   EQU   *
         L     R13,4(R13)
         SR    R0,R0
         ST    R0,16(R13)
         LM    R14,R12,12(R13)
         BR    R14
RESTORE  LR    POLISH,SAVER
         LR    R14,FLAGS
         N     R14,=F'4'
         BM    USE
XCUTZERO EQU   *
         N     FLAGS,=X'FFFFFFE0'
         L     STACK,4(R2)
         B     MAIN4
LOOK     N     R15,=F'64'
         BM    RET
         LTR   R1,R1
         BZ    ERR3
         ZGPR  R0
SHIFT1   SLDL  R0,8
         LTR   R0,R0
         BZ    SHIFT1
         C     R0,=F'91'
         BE    $$$
         LR    R1,R0
         N     R1,=F'16'
         BM    TWOSL
         LR    R1,R0
         N     R1,=F'32'
         BM    THREESL
         LA    R1,R0
         B     SETUPL
TWOSL    LA    R1,9
         B     SETUPL
THREESL  LA    R1,17
SETUPL   N     R0,=F'15'
         AR    R1,R0
         S     R1,=F'1'
         SLL   R1,3
         LA    R15,MSTORAGE(R1)
         LM    R0,R1,0(R15)
RET      BR    R14
$$$      LM    R0,R1,$$$$
         BR    R14
         CNOP  0,4
         DC    X'FFFFFFFE'              (MSK1)
MSK2     DC    X'FFFFFFFD'
*******  DC    C'COPYRIGHT 1966 BY JAMES R. LEWIS'
         LTORG
UAREA    DSECT
MSTORAGE DS    26D
$$$$     DS    D
SAV      DS    F
SAVCT    DS    F
SAREA    DS    900X
*        END
         TITLE 'P G E N  -  THE POLISH COMPILER.'
***********************************************************************
***********************************************************************
**                                                                   **
**                                                                   **
**        CCCCC                                                      **
**       C                                                           **
**       C                                                           **
**       C                                                           **
**       C       O M P I L E R                                       **
**        CCCCC                                                      **
**                                                                   **
**                                                                   **
**                           BY JAMES R. LEWIS, AUGUST 1966          **
**                                                                   **
***********************************************************************
***********************************************************************
*        ARGUMENTS OF THE ROUTINE..
*          1) ADDRESS OF CARD IMAGE.
*          2) ADDRESS OF POLISH STACK.
*          3) ADDRESS OF A TEMPORARY STORAGE AREA.
*          4) ''
*          5) ''
*          6) TRIPLE WORD FOR STORAGE.
***********************************************************************
*
*     GENERAL REMARKS...
*
*          THIS ROUTINE WILL CONVERT AN INPUT EQUATION INTO AN STRING
*        OF ENTITIES CONSISTING OF OPERANDS AND OPERATORS. THE OPERANDS
*        CAN BE OF TWO FORMS, LABELS AND LITERALS. THE INPUT STRING
*        IS SCANED THREE TIMES. THE FIRST SCAN IDENTIFIES THE
*        OPERATORS, OPERANDS, AND LITERALS. AS THE RESULT OF THE FIRST
*        SCAN, EACH ENTITY, AS IT CAN NOW BE CALLED, IS PRECEEDED BY
*        A CONTROL BYTE. THIS CONTROL BYTE CAN THEN BE INTERPRETED BY
*        OTHER PASSES AND OTHER ROUTINES. THE RECOGNITION OF THE
*        DIFFERENT ENTITIES IS AS FOLLOWS..
*             1) OPERATORS ARE RECOGNIZED AS BELONGING TO A SET OF
*                10 CHARACTERS, NAMELY...
*                  ( ) + - * / = , COLON AND SIMI-COLON.
*                  EXPONENTIATION IS RECOGNIZED BY '**'.
*                  IN ADDITION TO THE ABOVE OPERATORS, SEVERAL
*                OPERATORS ARE CREATED BY THE PROGRAM FOR INTERNAL
*                AND EXTERNAL USE. LEFT AND RIGHT PARENTHESIS FOR
*                FUNCTION NOTATION ARE CONVERTED DURING SCAN ONE AND
*                TWO TO LEFT AND RIGHT BRACKETS. THESE APPEAR ON THE
*                GRAPHIC CHARACTER SET AS LESS-THAN AND GREATER-THAN
*                SYMBOLS.
*                  THE FUNCTION NOTATION OPERATOR IS INSERTED DURING
*                THE THIRD AND FINAL SCAN. THIS OPERATOR IS A CONCAT-
*                TINATION SIGN. (THE BEST GRAPHIC SYMBOL FOR A DOWNWARD
*                ARROW.)
*                  THE EXPONENTIATION OPERATOR IS CONVERTED INTO
*                A '%'.
*                  THE FINAL OPERATOR IN THE INPUT STRING MUST
*                BE AN EOB. THE EOB IS THEN PLACED IN THE OUTPUT
*                STRING TO INDICATE THE END OF THAT STRING.
*             2) OPERANDS MUST HAVE A LETTER AS THE FIRST CHARACTER
*                IN THE FIELD. A LETTER OR NUMBER MAY BE USED
*                THEREAFTER. LABELS MAY BE NO LONGER THAN FOUR
*                CHARACTERS.
*             3) IF THE FIRST CHARACTER OF THE FIELD IS A NUMBER OR
*                A DECIMAL POINT, THE ENTITY IS CONSIDERED A LITERAL.
*                LITERALS MAY BE OF THE FORM...
*
*                  NNN
*                  NNN.NNN
*                  NNNENN
*                  NNN.NNNENN
*                  NNNE+NN
*                  NNNE-NN
*                  NNN.NNNE+NN
*                  NNN.NNNE-NN
*
*                  WHERE...
*                   NNN IS A FIELD OF INTEGERS UP TO 9 DIGITS.
*                   NN IS AN EXPONENT OF RANGE -78 TO +75.
*                   . IS A DECIMAL POINT.
*                   E IS THE EXPONENTIATION SIGN.
*
*             4) A FUNCTION OPERAND IS RECOGNIZED BY A LEFT
*                PARENTHESIS FOLLOWING THE OPERAND.
*
***********************************************************************
*
*        OPERATOR HIERARCHY TABLE.
*
*        HIERARCHY     OPERATOR
*        0             COLON AND SIMI-COLON.
*        1             (
*        2             )
*        3             =
*        4             , AND RIGNT BRACKET
*        5             + -
*        6             * /
*        7             **
*        8             LEFT BRACKET.
*
***********************************************************************
         EJECT
***********************************************************************
*
*        REGISTER ASSIGNMENTS.
*
*        GENERAL
*         REGISTER     USE
*         0            SCRATCH
*         1            SCRATCH
*         2            ARGUMENT REGISTER.
*         11           RESERVED
*         12           BASE REGISTER
*         13           NOT USED
*         14           SCRATCH
*         15           SCRATCH
*
*        FIRST SCAN (ENTITY CREATION)
*         REGISTER     USE
*         3            INCOMING CHARACTER
*         4            POINTER TO NEXT INPUT CHARACTER
*         5            POINTER TO OUTPUT STRING
*         6            SCRATCH
*         7            SCRATCH
*         8            SCRATCH
*         9            SCRATCH
*         10           SCRATCH
*
*        THIRD SCAN (POLISH CREATION)
*         REGISTER     USE
*         3            POINTER TO ENTITY STRING
*         4            POINTER TO POLISH STACK
*         5            POINTER TO OPERATOR STACK
*         6            POINTER TO HOLD STACK
*         7            POINTER TO TEMPORARY TRIPLE WORD
*         8            COMPILATION FLAGS (SEE THAT SECTION)
*         9            SCRATCH
*         10           HIERARCHY OF LAST OPERATOR
*
***********************************************************************
         EJECT
***********************************************************************
*
*        FORMAT OF THE CONTROL BYTE...
*
*        BITS
*          0    1    2-7
*        *******************
*        * F1 * F2 * COUNT *
*        *******************
*
*        WHERE...
*              F1 IS THE OPERAND FLAG. A 1 INDICATES THAT THIS
*              IS AN OPERAND ENTITY.
*              F2 IS THE LITERAL FLAG. IF THE OPERAND FLAG IS ON,
*              F2 INDICATES A LITERAL.
*              COUNT SERVES TWO PURPOSES.
*                1) COUNT IS THE LENGTH OF AN OPERAND, AND
*                2) COUNT IS THE HEIRARCHY OF AN OPERATOR.
*              LITERALS HAVE AN IMPLIED LENGTH OF 8.
*
*        EXAMPLES...
*
*        10000001
*              OPERAND OF LENGTH ONE.
*        11000000
*              LITERAL OPERAND.
*        00000011
*              OPERATOR OF HEIRARCHY 3.
*
***********************************************************************
         TITLE 'P G E N  - THE POLISH STRING GENERATOR'
*        PRINT NOGEN
PGEN     CSECT
*        INITILIZATION...
         STM   R14,R12,12(R13)
         LR    R2,R1                 TRANSFER ARGUMENT REGISTER.
         LR    R12,R15
         USING PGEN,R12
         L     R4,0(R2)              GET THE FIRST ARGUMENT
*                                     - THE INPUT CARD IMAGE.
         L     R5,4(R2)              GET THE SECOND ARGUMENT
*                                     - THE ENTITY STACK.
PGEN$GET CHR   GETEND                GET THE CHARACTERS
GET1     SCANC LETTERS,27,OPERAND
         SCANC OPS,R10,OPERATOR      TEST FOR AN OPERATOR.
         SCANC DIGITS,R11,LITERAL    TEST FOR A LITERAL.
         LA    R0,1                  CHARACTER NOT FOUND...
*                                     - MUST BE ILLEGAL.
PGEN$ERR ST    R0,16(R13)
         LM    R14,R12,12(R13)
         BR    R14
*        ERROR CODES IN R0.
*          1 ILLEGAL CHARACTER FOUND.
*          2 OPERAND TOO LONG.
*          3 PROGRAM ERROR.
*          4 UNBALANCED PARENS.
*          5 LITERAL TO LARGE.
*          6 ILLEGAL OPERATOR COMBINATION.
         TITLE 'O P E R A N D  PROCESSOR'
OPERAND  ZGPR  (R7,R9,R10)           INITILIZATION FOR OPERAND.
         LR    R8,R3                 SAVE FIRST CHARACTER.
OPRNDGET CHR   OPEND                 GET NEXT CHARACTER.
         SCANC OPS,R10,OPRNDEND      IS IT AN OPERATOR...
         SCANC LETTERS,37,OPGO
*                                     - (36 THIS TIME)
         LA    R0,R1                 ILLEGAL CHARACTER...
         B     PGEN$ERR              BRANCH TO LOCAL ERROR ROUTINE.
OPGO     EQU   *                     IT IS AN OPERAND CHARACTER.
         LR    R9,R3                 MOVE IT UP
         SLL   R9,24                 REMOVE HIGH ORDER BYTES
         SLDL  R8,8                  CONCATINATE WITH SAVED PART.
         ADDG  R10,1                 ADD ONE TO COUNT.
         B     OPRNDGET              GET NEXT CHARACTER.
OPEND    EQU   *                     DUAL PURPOSE ROUTINE.
OPRNDEND ADDG  R10,1                 ADD ONE TO COUNT.
         LA    R0,2                  SET UP ERROR CODE.
         C     R10,=F'4'             ABOVE FOUR CHARACTERS, AND
         BH    PGEN$ERR              ITS AN ILLEGAL LABEL.
         LR    R1,R10                SET UP COUNT FOR MANIPULATION
         SLL   R1,3                  MULTIPLY BY 8.
         SRDL  R8,0(R1)              SHIFT LABEL AROUND.
         O     R10,=F'128'           SET UP CONTROL BYTE.
         STC   R10,0(R5)             STORE CONTROL BYTE FOR OPERAND.
         ADDG  R5,1                  INCREMENT POINTER.
         LR    R11,R10               SAVE COUNT.
         N     R11,=F'127'           USE ONLY COUNT.
         S     R11,=F'1'             SUBTRACT FOR BXLE.
         AR    R11,R5                ADD CURRENT ADDRESS.
         LA    R10,1                 INCREMENT.
OPRNDLOP ZGPR  R8                    CLEAR GPR 8
         SLDL  R8,8                  GET CHARACTER.
         STC   R8,0(R5)              STORE CHARACTER IN OUTPUT
         BXLE  R5,R10,OPRNDLOP       DO LOOP...
         BCE   LBRA,R3,'('           SEE IF WE HAVE A FUNCTION
         BCE   GETEND,R3,X26         OR AN EOB
         B     OPERATOR              GO TO OPERATOR.
         TITLE 'O P E R A T O R   PROCESSOR'
OPERATOR BCE   LPAR,R3,'('           THIS IS A SERIES OF TESTS
         BCE   RPAR,R3,')'           TO DETERMINE WHAT KIND OF
         BCE   PGENPLUS,R3,'+'           OPERATOR WE HAVE...
         BCE   MINS,R3,'-'           .
         BCE   MUL,R3,'*'            .
         BCE   PGENDIV,R3,'/'        .
         BCE   PGENEQAL,R3,'='       .
         BCE   COMMA2,R3,','          .
         BCE   CNTRL,R3,(':',';')    .
         LA    R0,3                  SET UP ERROR CODE.
         B     PGEN$ERR              BRANCH TO LOCAL ERROR ROUTINE.
PGENDIV  EQU   *                     DIVISION AND MULTIPLICATION
MUL      LR    R8,R3                 HAVE SAME HEIRARCHY.
A0001    CHR   OPEREND               GET NEXT CHARACTER.
         BCE   PGEN$EXP,R3,'*'          IS IT AN ASTERISCKS.
         LA    R0,6                  SET UP HEIRARCHY
         B     OPERSTO1              GO TO SPECIAL ROUTINE
LPAR     LA    R0,1                  FROH HERE ON DOWN,
         B     OPERSTO               JUST SET UP HEIRARCHY,
RPAR     LA    R0,2                  SPECIAL OPERATORS, AND
         B     OPERSTO               STORE IN OUTPUT STREAM.
MINS     EQU   *                     .
PGENPLUS LA    R0,5                  .
         B     OPERSTO               .
PGEN$EXP BCE   PGENILL,R8,'/'        .
         LA    R0,7                  .
         LA    R3,108                .
         B     OPERSTO               .
PGENEQAL LA    R0,3                  .
         B     OPERSTO               .
COMMA2   LA    R0,4                  .
         B     OPERSTO               .
LBRA     LA    R0,8                  .
         LA    R3,76                 .
         B     OPERSTO               .
CNTRL    ZGPR  R0                    .
OPERSTO  STC   R0,0(R5)              STORE CONTROL BYTE
         STC   R3,1(R5)              STORE OPERATOR.
         ADDG  R5,2                  ADD IN 2 TO ADDRESS.
         B     PGEN$GET              GO BACK FOR MORE.
OPEREND  EQU   *                     END ON AN OPERATOR.
OPERSTO1 STC   R0,0(R5)              STORE CONTROL BYTE.
         STC   R8,1(R5)              STORE OPERATOR.
         ADDG  R5,2                  ADD TWO.
         BCE   GETEND,R3,X26         EOB GOES OUT...
         B     GET1                  GO BACK SPECIAL WAY.
         TITLE 'L I T E R A L  PROCESSOR'
LITERAL  ZGPR  (R6,R7,R8,R9,R10)     INITILIZATION FOR LITERAL.
         BCE   DECIMAL,R3,'.'        IS IT JUST A DECIMAL
         LR    R7,R3                 NO, SAVE FIRST CHARACTER.
         N     R7,=F'15'             CLEAR OFF ZONE BITS.
LITGET   CHR   ENDLIT                GET NEXT CHARACTER.
LITTEST  EQU   *
         SCANC DIGITS,R12,LITOK      DIGITS OR NOT.
         B     LITEND                NOT A DIGIT, END OF LITERAL.
LITOK    BCE   DECIMAL,R3,'.'        IS THE CHRACTER A DECIMAL
         BCE   EXPLIT,R3,'E'         OR AN E
         N     R3,=F'15'             REMOVE ZONE BITS.
         M     R6,=F'10'             MULTIPLY SAVED RESULT..
         LA    R0,5                  SET UP ERROR CODE
         LTR   R6,R6                 TEST REGISTER 6 FOR OVERFLOW.
         BP    PGEN$ERR              GO TO LOCAL ERROR ROUTINE.
         AR    R7,R3                 ADD IN CURRENT DIGIT
         ZGPR  R0                    SET UP GPR R0
         LR    R1,R10                GET CURRENT COUNT.
         SLDL  R0,24                 SHIFT TO FIND COUNT.
         SRL   R1,24                 LETS LOOK AT CONTROL BITS...
         N     R1,=F'2'              IF 2 BIT IS ON, WE HAVE
         BM    LITGET                AN EXPONENT AND MUST NOT ADD ONE
         LR    R1,R10                TO GPR R10'S COUNT FIELD
         SLL   R1,24                 SHIFT TO RESTORE...
         A     R0,=F'1'              ADD ONE TO R0
         SRDL  R0,24                 RESTORE GPR
         LR    R10,R1                SHIFT BACK TO GPR R10.
         B     LITGET                GO GET NEXT CHARACTER.
DECIMAL  LA    R0,1                  DECIMAL POINT FOUND...
         LR    R1,R10                HAVE WE BEEN HERE BEFORE...
         N     R1,=F'1'              TEST IT
         BM    PGEN$ERR              YES... GO TO LOCAL ERROR ROUTINE.
         LR    R8,R7                 SAVE WHOLE PART.
         O     R10,=F'1'             SET UP FLAG.
         ZGPR  (R6,R7)               RESET GPR 6 AND 7
         N     R10,=XL4'FF'          ZERO THE COUNT
         B     LITGET                GO BACK FOR MORE.
EXPLIT   LA    R0,1                  EXPONENT LITERAL.
         LR    R1,R10                GET FLAGS...
         N     R1,=F'2'              HAVE WE BEEN HERE BEFORE...
         BM    PGEN$ERR              YES... GO TO LOCAL ERROR ROUTINE
         LR    R1,R10                GET FLAGS AGAIN
         N     R1,=F'1'              IS THIS A FRACTION OR WHOLE
         BM    EXPOK                 FRACTION, GO...
         LR    R8,R7                 SAVE WHOLE
         B     A00021                GO AROUND.
EXPOK    EQU   *                     IT IS A FRACTION
         LR    R9,R7                 SAVE FRACTION
A00021   O     R10,=F'2'             SET FLAG.
A0002    CHR   EXPERR                GET NEXT CHARACTER FOR SIGN
         ZGPR  R6                    SET UP GPR 6
         ZGPR  R7                    AND 7
         BCE   LITGET,R3,'+'         IF IT IS A PLUS
         BCE   MINEXP,R3,'-'         OR A MINUS...
         B     LITTEST
EXPERR   LA    R0,1                  SET UP ERROR CODE
         B     PGEN$ERR              GO TO LOCAL ERROR ROUTINE.
MINEXP   O     R10,=F'8'             MINUS EXPONENT... SET FLAG.
         B     LITGET                GO BACK FOR MORE.
ENDLIT   O     R10,=F'4'             THE END OF A LITERAL
*                                     - SET FLAG FOR END OF INPUT
LITEND   LR    R1,R10                GET FLAGS...
         N     R1,=F'3'              TEST FOR FRACTION OR EXP.
         BM    WHOLE8                NEITHER
         LR    R1,R7                 EITHER - SHIFT FROM GPR 8
         B     WHOLE                 GO AROUND
WHOLE8   LR    R1,R8                 GET FROM SAVE GPR.
WHOLE    L     R6,28(R2)             PICK UP A STORAGE LOCATION
*                                    THIS LOCATION MUST BEGIN ON A
*                                    DOUBLE WORD BOUNDRY.
         ZGPR  R0                    SET UP GPR R0
         SDR   F0,F0                 SET UP FPR 0
         XC    0(16,R6),0(R6)        CLEAR THS STORAGE AREA
         LD    F2,=D'10.'            LOAD THE FP 10
         LTR   R1,R1                 TEST FOR A ZERO WHOLE PART.
         BZ    FRAC                  GO TO FRACTION
         L     R0,MASK               LOAD THE MASK
         STM   R0,R1,0(R6)           STORE UNNORMALIZED NUMBER.
         LD    F0,0(R6)              LOAD INTO FPR 0.
         AD    F0,MASK               ADD IN A UNNORMALIZED ZERO
         STD   F0,0(R6)              STORE THE WHOLE PART OF THE
*                                    LITERAL AS A FLOATING POINT
*                                    NUMBER.
FRAC     LR    R1,R10                FRACTION . GET FLAGS.
         N     R1,=F'1'              WHERE IS THE FRACTION
         BZ    EXPON                 THERE IS NO FRACTION
         LR    R1,R10                GET FLAGS...
         N     R1,=F'2'              WAS THERE AN EXPONENT...
         BM    FRAC9                 YES...
         LPR   R1,R7                 NO GET FROM NORMAL REGISTER.
         B     FRACGO                BRANCH AROUND...
FRAC9    LPR   R1,R9                 GET POSITIVE FRACTION
FRACGO   LTR   R1,R1                 SEE IF THE FRACTION WAS ZERO.
         BZ    EXPON                 YES...
         L     R0,MASK               NO, GET MASK.
         STM   R0,R1,8(R6)           STORE THE UNNORMALIZED NUMBER
         LD    F0,8(R6)               LOAD INTO FPR 0
         AD    F0,MASK                ADD THE UNNORMALIZED AERO
         LR    R1,R10                GET COUNT.
         ZGPR  R0                    ZERO GPR R0
         SLDL  R0,24                 SHIFT IN COUNT
LOOPFRAC DDR   F0,F2                 DIVIDE BY TEN
         S     R0,=F'1'              SUBTRACT 1 FROM COUNT
         BP    LOOPFRAC              GO IF THERE IS STILL SOME MORE
         AD    F0,0(R6)              ADD IN WHOLE PART.
EXPON    LR    R1,R10                EXPONENT TEST FLAGS...
         N     R1,=F'2'              SEE IF THERE WAS AN EXPONENT...
         BZ    NOEXP                 NO...
EXPLOOP  LTR   R7,R7                 TEST EXPONENT REGISTER...
         BZ    NOEXP                 GO IF ZERO
         LA    R0,5                  GET ERROR FLAG.
         LR    R1,R10                GET FLAGS
         N     R1,=F'8'              TEST FOR NEGITIVE EXPONENT
         BZ    EXP1                  NOT NEGITIVE...
EXP2     DDR   F0,F2                 DIVIDE BY 10.0
         BCT   R7,EXP2               BRANCH ON COUNT
         B     NOEXP                 GO AROUND
EXP1     CD    F0,=D'7.2E74'         POSITIVE EXPONENT...
*                                    COULD IT BE TOO LARGE.
         BH    PGEN$ERR              GO TO LOCAL ERROR IF TO LARGE.
         MDR   F0,F2                 MULTIPLY BY 10.0
         BCT   R7,EXP1               BRANCH ON COUNT LESS
NOEXP    STD   F0,0(R6)              STORE RESULT IN STORAGE
         LA    R0,192                GET LITERAL CONTROL BYTE.
         STC   R0,0(R5)              STORE IT IN OUTPUT.
         ADDG  R5,1                  ADD ONE FOR THE CONTROL
         L     R1,0(R6)              LOAD FIRST HALF OF LITERAL
         LA    R7,4                  GET COUNT
EXPPUT   SLDL  R0,8                  SHIFT AND COUNT
         STC   R0,0(R5)              STORE CHARACTER.
         ADDG  R5,1                  ADD TO POINTER.
         BCT   R7,EXPPUT             BRANCH ON COUNT.
         L     R1,4(R6)              GET SECOND HALF.
         LA    R7,4                  GET COUNT
EXPPUT1  SLDL  R0,8                  SHIFT BY 8 BITS
         STC   R0,0(R5)              STORE CHARACTER.
         ADDG  R5,1                  ADD ONE TO POINTER.
         BCT   R7,EXPPUT1            BRANCH ON COUNT
         N     R10,=F'4'             TEST FOR EOB
         BM    GETEND                YES... END OF INPUT
         B     GET1                  GO BACK
GETEND   EQU   *                     END OF INPUT AND FIRST SCAN
         LA    R0,8                  CREATE EOB CONTROL BYTE.
         STC   R0,0(R5)               STORE THE CONTROL BYTE
         LA    R0,38                 GET A NEW EOB.
         STC   R0,1(R5)              STORE EOB.
         TITLE 'P G E N  - THE POLISH STRING GENERATOR'
*        NOTE ON GPR 8
*          BIT 1 INDICATES AN '=' SIGN HAS BEEN FOUND IN THIS EQUATION
*          BIT 2 INDICATES THE PREVIOUS ENTITY WAS AN OPERATOR.
*          BIT 3 INDICATES THE PREVIOUS OPERATOR WAS AN '**'.
*          BIT 4 INDICATES A COMMA SERIES WAS FOUND.
*          BIT 5 INDICATES THAT AN OPERATOR HAS BEEN FOUND
         ZGPR  (R0,R8)               SET UP GPR R0 AND 8
         LA    R15,8                 SET UP EOB CONTROL BYTE
         LA    R1,38                 AND EOB CHARACTER.
         L     R3,4(R2)              ENTITY STRING
         L     R4,8(R2)              POLISH STACK
         L     R5,12(R2)             OPERATOR STACK
         L     R6,16(R2)             HOLD STACK
         PLOP  R4                    SET UP POLISH STACK.
         PLOP  R5                    SET UP OPERATOR STACK
         PLOP  R6                    SET UP HOLD STACK.
         B     PGENUTS
PGENGET  STACKO R3,PGENDONE          GET A ENTITY
PGENGET1 LR    R14,R15               GET CONTROL BYTE
         N     R14,=F'128'           TEST THE TYPE FOR OPERATOR
         BZ    PGENOPO               BRANCH IF OPERATOR
PGENOPN  PLOP  R4                    PLACE IN LIFO STACK
         N     R8,MSK                TURN OFF OPERATOR PREVIOUS FLAG
PGENTST  STACKO R3,PGENDONE          GET ENTITY
         LR    R14,R15               SEE OF IT IS AN OPERATOR
         N     R14,=F'128'           OR AN OPERAND
         BM    PGENOPN               OPERAND
         BCE   PGENEXP,R1,'%'        IS IT AN EXPONENT.
PGENOP   EQU   *                     SWITCHING
         L     R7,20(R2)             TEMPORARY TRIPLE WORD.
         PLOP  R7                    STARTS HERE
         LR    R10,R15               SAVE HIERARCHY
PGENTST1 POPP  R5,PGENOP1            GET AN OPERATOR
         CR    R15,R10               TEST IT WITH THE OLD OPERATOR.
         BC    10,PGENMOVE           IF GREATER THAN OR EQUAL
         PLOP  R5                    OTHERWISE IT GOES BACK
         POPP  R7,PGENERR1           GET OLD OPERATOR
         B     PGENOPO               GO TO OPERATOR PROCESSOR
PGENMOVE BCE   UNBAL,R1,('(','|')
         ZGPR  R0
         PLOP  R4
         B     PGENTST1              BRANCH BACK FOR MORE MOVES.
PGENEXP  LR    R9,R8                 EXPONENTIAL OPERATOR
         N     R9,=F'4'              ARE WE THE FIRST TIME HERE
         BZ    PGENOP                YES
         B     PGENOPO               NO
PGENOP1  POPP  R7,PGENERR1           RESTORE THE OLD OPERATOR
PGENOPO  BCE   PGENEQU,R1,'='        TEST FOR EQUALS SIGH
         BCE   PGENCTL,R1,(':',';')  COLON OR SIMI-COLON
         BCE   PGENCOMM,R1,','       COMMA
         O     R8,=F'16'             TURN ON OPERATOR FLAG.
         BCE   PGENLBRA,R1,'<' LBRA
         BCE   PGENRPAR,R1,')'
PGENBKK  EQU   *
         PLOP  R5                    PLACE OPERATOR IN STACK
         BCE   PGENLPAR,R1,'('       LEFT PAREN TEST.
         LR    R9,R8                 GET FLAGS
         N     R9,=F'2'              TEST FOR TWO OPERATORS IN A ROW
         BM    PGENILL               YES...
         BCE   PGENUTS,R1,','        TEST FOR A COMMA
         O     R8,=F'2'              TURN ON THE OPERATOR FLAG.
         N     R8,MSK1               TURN OFF EXP FLAG.
         BCE   PGENFLG,R1,'%'        SEE IF THE CURRENT OPERATOR IS **
         B     PGENGET               NO, GO BACK
PGENCOMM EQU   *                     COMMA OPERATOR
         O     R8,=F'8'              TURN ON COMMA FLAG.
         B     PGENBKK               GO BACK....
PGENLPAR N     R8,MSK                LEFT PAREN... TURN OFF OPERATOR
*                                    FLAG FOR UNIARY OPERATORS.
         B     PGENUTS               GO TO UNIARY TEST.
PGENFLG  O     R8,=F'4'              FLAG FOR EXPONENT OPERATOR '**'
         B     PGENGET               GO BACK
PGENCTL  LR    R10,R1                COLON OR SIMI-COLON OPERATOR
PGENCTL2 POPP  R5,PGENCTL3           GET SAVED OPERATORS
         BCE   UNBAL,R1,'|'
         BCE   UNBAL,R1,'('          IS IT A RIGHT PARENTHESIS
         PLOP  R4                    PLACE IN POLISH STACK.
         B     PGENCTL2              LOOP
PGENCTL3 ZGPR  (R8,R15)              RE-SET GPR R8 AND R15
         LR    R1,R10                GET OPERATOR
         ZGPR  R15                   CLEAR CONTROL BYTE FOR OPER.
         PLOP  R4                    STORE IT AWAY.
         B     PGENUTS
PGENLBRA PLOP  R5                    SAVE LEFT BRACKET.
         POPP  R4,PGENERR1           GET OPERAND FOR FUNCTION
         PLOP  R6                    HOLD IT.
         ZGPR  R0                    LETS CREATE THE GOOD OLD
         LA    R1,X'4F'              DOWNWARD ARROW
         LA    R15,0                 AND ITS CONTROL BYTE
         PLOP  R5                    STORE IT IN THE OPERATOR STACK
         B     PGENUTS               GO FOR NEXT OPERATOR.
PGENSOK  POPP  R5,UNBAL              GET NEXT OPERATOR
         BCE   PGENROK,R1,'<' LBRA
         B     UNBAL                 BAD EQUATION...
PGENROK  POPP  R6,PGENERR1           POP HOLD STACK
         PLOP  R4                    PUT IT IN THE POLISH STACK...
         LA    R0,0                  SET UP ARROW
         LA    R1,X'4F'              THIS IS THE HEX FOR IT...
         LA    R15,0                 AND THE CONTROL BYTE.
         PLOP  R4                    PUT IN THE POLISH STACK.
         B     PGENTST               GO BACK FOR MORE.
PGENRPAR LR    R9,R8                 A RIGHT PARENTHESIS... GET FLAGS
         N     R9,=F'2'              TEST FOR TRAILING OPERATORS.
         BM    PGENILL               GO TO ERROR
         POPP  R5,UNBAL              GET SAVED OPERATOR
         BCE   PGENSOK,R1,'|' ARROW OR SPEAR.
         BCE   PGENTST,R1,'('        IF IT IS NOT A PARENTHESIS '('
UNBAL    LA    R0,4                  UNBALANCED... SET UP ERROR CODE
         B     PGEN$ERR              GO TO LOCAL ERROR ROUTINE.
PGENEQU  LR    R9,R8                 EQUAL SIGN... GET FLAGS...
         N     R9,=F'25'
         BM    PGENILL               EITHER IS AN ERROR.
         O     R8,=F'1'              TURN ON FLAG FOR EQUALS.
         PLOP  R5                    PUT IT IN THE OPERATOR STACK.
PGENUTS  STACKO R3,PGENDONE          GET NEXT ENTITY
         LR    R14,R15               TRANSFER CONTROL BYTE
         N     R14,=F'128'           TEST FOR OPERATOR
         BM    PGENOPN               NOT AN OPERATOR, OK
         BCE   PGENOPO,R1,'('        IF AN OPERATOR, IT MUST BE
         BCE   PGENUNIR,R1,'+'       A LEFT PARENTHESIS, A PLUS SIGN,
         BCE   PGENUNIS,R1,'-'       OR A MINUS SIGN.
         B     PGENILL               OTHERWISE GO TO ERROR
PGENUNIR IC    R1,AMPER              UNIARY PLUS SIGH
         B     PGENOPO               GO BACK
PGENUNIS IC    R1,=C'_'              UNIARY MINUS SIGN.
         B     PGENOPO               GO BACK.
PGENILL  LA    R0,6                  ILLEGAL OPERATOR SEQUENCE...
         B     PGEN$ERR              GO TO LOCAL ERROR ROUTINE.
PGENERR1 LA    R0,3                  A PROGRAM ERROR... CAN IT HAPPEN
         B     PGEN$ERR              GO TO LOCAL ERROR ROUTINE.
PGENDONE N     R8,=F'2'              END OF GENERATION... TEST FOR
*                                    TRAILING OPERATORS...
         BM    PGENILL               GO TO LOCAL ERROR
PGENDONN POPP  R5,PGENDON1           GET THE NEXT OPERATOR IN STACK
         BCE   UNBAL,R1,'|'
         BCE   UNBAL,R1,'('          IS IT A PARENTHESIS...
         PLOP  R4                    IF NOT, STORE IT AWAY...
         B     PGENDONN              GO BACK FOR MORE
PGENDON1 L     R3,4(R2)
*                                    OUTPUT.
         PLOP  R4                    STORE THE EOB RECORD.
         L     R4,8(R2)              GET THE ADDRESS OF THE INPUT.
         ADDG  R4,12                 ADD 12 FOR THE EOB.
PGENDON2 LM    R15,R1,0(R4)          GET THE ENTITY.
         ADDG  R4,12                 INCREMENT POINTER.
         LR    R14,R15               TRANSFER THE CONTROL BYTE...
         N     R14,=F'128'           TEST FOR OPERAND...
         BM    PGENGO                YES
         BCE   PGENEND,R1,X26  EOB
PGENGO   EQU   *                     OTHER THAN EOB...
         STC   R15,0(R3)             STORE THE CONTROL BYTE
         ADDG  R3,1                  INCREMENT POINTER TO OUTPUT
         LR    R14,R15               GET FLAGS
         N     R14,=F'128'           TEST FOR OPERATOR
         BZ    PGENOPP               GO IF OPERATOR...
         LR    R14,R15               GET THE FLAGS
         N     R14,=F'64'            TEST FOR A LITERAL
         BZ    PGENOPNN              GO IF NOT A LITERAL
         LA    R14,4                 GET A COUNT
         LR    R11,R0                AND FIRST HALF OF THE LITERAL
L11      SLDL  R10,8                 SHIFT EACH CHARACTER.
         STC   R10,0(R3)             AND STORE IT
         ADDG  R3,1                  INCREMENT POINTER TO OUTPUT
         BCT   R14,L11               BRANCH ON COUNT (4)
         LA    R14,4                 GET NEXT COUNT
         LR    R11,R1                AND SECOND HALF ON LITERAL
L12      SLDL  R10,8                 SHIFT THE CHARACTER...
         STC   R10,0(R3)             STORE IT AWAY
         ADDG  R3,1                  ADD ONE TO THE POINTER
         BCT   R14,L12               BRANCH ON COUNT (4)
         B     PGENDON2              GO BACK FOR NEXT ENTITY...
PGENOPP  STC   R1,0(R3)              OPERATOR... STORE IT
         ADDG  R3,1                  INCREMENT THE POINTER...
         B     PGENDON2              GO FOR THE NEXT ENTITY...
PGENOPNN LR    R14,R15               OPERAND
         N     R14,=F'15'            HOW LONG IS IT...
         SLL   R14,3                 MULTIPLY BY EIGHT.
         LR    R0,R1                 EXCHANGE ONE INTO ZERO
         SRDL  R0,0(R14)             SHIFT OVER N CHARACTERS...
         SRL   R14,3                 DIVIDE COUNT BY EIGHT...
L13      SLDL  R0,8                  GET EACH CHARACTER
         STC   R0,0(R3)              STORE IT AWAY
         ADDG  R3,1                  INCREMENT POINTER...
         BCT   R14,L13               BRANCH ON COUNT(N)
         B     PGENDON2              GO GET NEXT ENTITY.
PGENEND  EQU   *                     END OF OUTPUT
         STC   R15,0(R3)             STORE CONTROL BYTE.
         STC   R1,1(R3)              AND THE EOB
         SR    R0,R0
         ST    R0,16(R13)
         LM    R14,R12,12(R13)
         BR    R14
         CNOP  0,8
MSK      DC    X'FFFFFFFD'
MSK1     DC    X'FFFFFFFB'
MASK     DC    X'4E00000000000000'
LETTERS  DC    C'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
         DC    C'$'
DIGITS   DC    C'0123456789.E'
OPS      DC    C'()+-*/=,;:'
AMPER    DC    X'50'
*****    DC    C'COPYRIGHT 1966 BY JAMES R. LEWIS'
         LTORG
*        END
         TITLE 'ABS, CON, RAD, DEG, BOOL'
ABS      CSECT
         LPDR  F0,F0
         SR    R15,R15
         BR    R14
         SPACE
         ENTRY RAD
         ENTRY DEG
         SPACE
CON      CSECT
RAD      EQU   *
         USING RAD,R15
         DD    F0,RFACTOR
         SR    R15,R15
         BR    R14
         SPACE
DEG      EQU   *
         USING DEG,R15
         MD    F0,RFACTOR
         SR    R15,R15
         BR    R14
RFACTOR  DC    D'57.29577951308232'
         SPACE
BOOL     CSECT
         USING BOOL,R15
         LTDR  F0,F0
         BH    BOOL$ONE
         SDR   F0,F0
         SR    R15,R15
         BR    R14
BOOL$ONE LD    F0,=D'1.0'
         SR    R15,R15
         BR    R14
         LTORG
*        END
         TITLE 'ARCSIN-ARCCOSINE FUNCTION'
IHCLASCN CSECT
*        ARCSIN-ARCCOSINE FUNCTION (LONG)
*              1. IF X BETWEEN 0 AND 1/2, COMPUTE ACRSIN BY POLYNOMIAL
*              2. IF X BETWEEN 1/2 AND 1,
*              ARSIN(X) = PI/2-2*ARSIN(SQRT((1-X)/2))
*              3. IF X NEGATIVE, ARSIN(X) = -ARSIN(/X/)
*              4. ARCOS(X) = PI/2-ARSIN(X)
         ENTRY DARSIN
         ENTRY DARCOS
         SPACE
GRT      EQU   R7                      PREVIOUS SAVE AREA POINTER
         SPACE
         USING *,R15
DARCOS   EQU   *
         STM   R14,GRT,12(R13)         SAVE REGISTERS
         MVI   SWICH1+1,X'00'          SAVE REGS, SET SWICH1 TO 'BC 0'
         LA    R15,DARSIN-DARCOS(R15)  ADJUST BASE REGISTER
         USING DARSIN,R15              AND JOIN COMMON CIRCUIT
         B     JOIN$1
         SPACE
DARSIN   EQU   *
         STM   R14,GRT,12(R13)         SAVE REGISTERS
         MVI   SWICH1+1,X'F0'          SAVE REGS, SET SWICH1 TO 'BC 15'
         SPACE
JOIN$1   EQU   *
         LR    R6,R15                  SWITCH BASE REGISTER TO GRB
         USING DARSIN,R6
         DROP  R15
         SPACE
         STD   F0,ARG#A
         LPER  F0,F0                   /X/
         CD    F0,LASCNONE
         BC    2,LASCNERR              IF /X/ GREATER THAN 1, ERROR
         MVI   SWICH2+1,X'10'
         CE    F0,HALFASCN             IF /X/ SMALLER THAN 1/2, SET SWI
         BC    12,POLYN                TO 'BC 1' AND SKIP TO POLYNOM SE
         SPACE
         MVI   SWICH2+1,X'80'          IF /X/ GREATER THAN 1/2,
         HDR   F0,F0                   SET SWICH2 TO 'BC 8' AND
         SD    F0,HALFASCN             COMPUTE SQRT((1-X)/2)
         LPER  F0,F0
         LTDR  R2,F0
         BZ    SQFIN
         SR    R1,R1
         IC    R1,ARG#A
         LA    R1,65(R1)
         SRA   R1,1
         STC   R1,ARG#A
         LD    F0,ARG#A
         LA    R1,8
SQLOOP2  LDR   F4,F2
         DDR   F4,F0
         ADR   F4,F0
         HDR   F0,F4
         BCT   R1,SQLOOP2
SQFIN    EQU   *
         SPACE
POLYN    LDR   R2,F0                   COMPUTE ARSIN(X) OR
         MDR   F2,F2                   ARSIN(SQRT((1-X)/2))
         SDR   F4,F4                   BY A POLYNOMIAL OF FORM
         LM    R3,R5,INDEX
LOOP     AD    F4,COEF(R3)             ARSIN(Z) = Z+C1*Z**3+C2*Z**5
         MDR   F4,R2                   +...+C12*Z**25
         BXLE  R3,R4,LOOP
         MDR   F4,F0
         ADR   F0,F4
         SPACE
         TM    SWICH1+1,X'80'          IF ARSIN WANTED AND BIG /X/,
SWICH2   BC    1,SKIP                  SUBTRACT F0 FROM PI/4
         BC    1,*+8                   IF ARCOS WANTED AND SMALL /X/,
         SD    F0,PIOV4#1              SUBTRACT F0 FROM PI/2
         SD    F0,PIOV4#1              EXTRA STEPS ARE EMPLOYED
         LPER  F0,F0                   TO RETAIN ACCURACY
SKIP     TM    SWICH2+1,X'80'          IF /X/ WAS BIG, DOUBLE F0 TO GE
         BZ    *+6                     2*ARSIN(SQRT((1-X)/2)), OR
         ADR   F0,F0                   PI/2-2*ARSIN)SQRT((1-X)/2))
         SPACE
         TM    ARG#A,X'80' (SIGN)%
         BZ    FIN                     IF NEGATIVE AND ARSIN, CHANGE SI
         LNER  F0,F0                   IF NEG AND ARCOS, SUBTRACT FROM
SWICH1   B     FIN                     ='BC 15,FIN' FOR ARSIN, 'BC 0,FI
         AD    F0,PI#ASCN              FOR ARCOS
         SPACE
FIN      LM    R14,GRT,12(R13)         RESTORE REGISTERS
         SR    R15,R15
         BR    R14
         SPACE
         CNOP  0,4
LASCNERR LM    R14,GRT,12(R13)
         LA    R15,20
         BR    R14
         SPACE
ARG#A    DS    D
COEF     DC    X'3F829434AE2563EF'      0.3187962129808229E-1
         DC    X'BF424DB5FD243711'     -0.1618739213360045E-1
         DC    X'3F4FED5AB9F625B1'      0.1951346817021131E-1
         DC    X'3F1ABE782B17D797'      0.6529302032040626E-2
         DC    X'3F31D950B3793EDF'      0.1217013858656887E-1
         DC    X'3F38DF501DA5EEFF'      0.1388484282722024E-1
         DC    X'3F471B0C5D335967'      0.1735977964127353E-1
         DC    X'3F5BA27AD75504B9'      0.2237174973316874E-1
         DC    X'3F7C71CB34A39F66'      0.3038195969768495E-1
         DC    X'3FB6DB6D9FB55B40'      0.4464285680599894E-1
         DC    X'4013333333376F72'      0.7500000000385202E-1
         DC    X'402AAAAAAAAAA5CF'      0.1666666666666494
PIOV4#1  EQU   *
PIOV     DC    X'40C90FDAA22168C2'     PI/4
PI#ASCN  DC    X'413243F6A8885A31'     PI
LASCNONE DC    X'4110000000000000'
HALFASCN DC    X'4080000000000000'
INDEX    EQU   *-4
         DC    F'8'
         DC    F'88'
         LTORG
*        END
         TITLE 'ARCTANGENT FUNCTION'
IHCLATN2 CSECT
*
*        ARCTANGENT FUNCTION  (LONG, 2 ENTRY POINTS)
*              1. REDUCE THE CASE TO THE 1ST OCTANT BY USING
*              ATAN(-X=-ATAN(X), ATAN(1/X)=P1/2-ATAN(X)
*              2. REDUCE FURTHER TO THE CASE /X/ LESS THAN TAN(PI/12)
*              BY ATAN(X)=PI/6+ATAN(X*SQRT3-1)/(X+SQRT3)).
*              3. FOR THE BASIC RANGE (X LESS THAN TAN(PI/12)), USE
*              A CONTINUED FRACTION APPROXIMATION
*              4. DATAN2 ENTRY REQUIRES A PAIR OF ARGUMENTS Y AND X,
*              AND COMPUTES ATAN(Y/X).  ANSWER IS IN (-PI,PI)
         SPACE
         ENTRY DATAN
         ENTRY DATAN2
         SPACE
GRX      EQU   R14
         SPACE
         USING *,R15
DATAN2   EQU   *
         STM   R14,R15,12(R13)         SAVE REGISTERS
         MVI   ATN2FLAG,1              SAVE R14, R15 AND SET FLAG
         LA    R15,DATAN-DATAN2(R15)   ADJUST BASE REGISTER AND SKIP
         USING DATAN,R15
         B     MERGE1
         SPACE
DATAN    EQU   *
         STM   R14,R15,12(R13)         SAVE REGISTERS
         MVI   ATN2FLAG,0              SAVE R14,R15 AND RESET FLAG
MERGE1   EQU   *
         STE   F0,ATN2SIGN             SAVE ITS SIGN
         TM    ATN2FLAG,1
         BZ    ATAN1                   IF DATAN ENTRY, SKIP TO MAIN CIR
         SPACE
         STE   R2,XSIGN                SAVE ITS SIGN
         LM    R0,R1,ATN2SIGN          IF X2=0, OR IF /X1/X2/ IS GREATE
         N     R1,MASK1                THAN 2**56, GIVE + OR -P1/2 AS
         BZ    VERTL                   ANSWER TO AVOID IBFINT TROUBLE
         N     R0,MASK1
         SR    R0,R1
         C     R0,BIAS
         BL    NORML1
VERTL    LTER  F0,F0
         BZ    LATN2ERR                IF X1=X2=0, ERROR
         LD    F0,PIOV2
         BP    ATN2EXIT
         LCER  F0,F0
         B     ATN2EXIT
         SPACE
NORML1   DDR   F0,R2
         STE   F0,ATN2SIGN             JOIN MAIN CIRCUTI WITH X=X1/X2
         SPACE
ATAN1    LPER  F0,F0                   MAIN CIRCUIT.  FORCE SIGN POSIT
         SR    R1,R1                   R1 FOR DISTINGUISHING CASES
         CE    F0,ATN2ONE
         BL    SKIP1
         LD    R2,ATN2ONE              IF X GREATER THAT 1, TAKE INVER
         DDR   R2,F0                   AND INCREMEMENT R1 BY 16
         LDR   F0,R2
         LA    R1,16
         SPACE
SKIP1    CE    F0,TAN15
         BC    12,SKIP2
         LDR   R2,F0                   IF X GREATER THAN TAN(PI/12),
         MD    F0,RT3M1                REDUCE X TO (X*SQRT3-1)/(X+SQRT3
         SD    F0,HALFATN2
         SD    F0,HALFATN2             COMPUTE X*SQRT3-1 AS
         ADR   F0,F2                   X*(SQRT3-1)-0.5-0.5+X
         AD    R2,RT3                  TO GAIN ACCURACY
         DDR   F0,R2
         LA    R1,8(R1)                INCREMENT R1 BY 8
         SPACE
SKIP2    LDR   F6,F0                   COMPUTE ATAN OF REDUCED ARGUMENT
         MDR   F0,F0
         LDR   R2,F0                   ATAN(X) = X(1+F*XSQ)
         AD    R2,BETA4
         LD    F4,ALPHA4               F = A1/(B1+XSQ+A2/(B2+XSQ+A3
         DDR   F4,R2                   /(B3+XSQ+A4/(B4+XSQ))..)
         ADR   F4,F0
         AD    F4,BETA3
         LD    R2,ALPHA3
         DDR   R2,F4
         ADR   R2,F0
         AD    R2,BETA2
         LD    F4,ALPHA2
         DDR   F4,R2
         ADR   F4,F0
         AD    F4,BETA1
         LD    R2,ALPHA1
         DDR   R2,F4
         MDR   F0,R2
         MDR   F0,F6
         ADR   F0,F6
         SPACE
         C     R1,SXTEN                DEPENDING ON THE CASE EITHER ADD
         BL    *+10                    0 OR PI/6 OR SUBTRACT FROM PI/3
         LCER  F0,F0                   PI/2.  DO LATTER IN 2 STEPS
         AD    F0,PO2M1-16(R1)
         AD    F0,ATN2ZERO(R1)
         TM    ATN2SIGN,X'80'          IF SIGN WAS NEGATIVE,
         BZ    *+6                     ANSWER IS NEGATIVE
         LCER  F0,F0
         TM    ATN2FLAG,1
         BZ    ATN2EXIT                IF DATAN ENTRY SKIP TO EXIT
         SPACE
         TM    XSIGN,X'80'             DATAN2 CASE
         BZ    ATN2EXIT                IF X2 IS POSITIVE, SKIP TO EXIT
         LD    R2,PI#ATN2              OTHERWISE SUBTRACT OR ADD PI
         LTDR  F0,F0                   DEPENDING ON THE SIGN OF F0
         BP    *+6
         LCER  R2,R2
         SDR   F0,R2
         SPACE
ATN2EXIT L     GRX,12(R13)
         SR    R15,R15
         BR    R14
         SPACE
ATN2FLAG DS    C
         SPACE
         CNOP  0,4
LATN2ERR L     R14,12(R13)
         LA    R15,19
         BR    R14
         SPACE
         DS    0D
PI#ATN2  DC    X'413243F6A8885A31'
RT3M1    DC    X'40BB67AE8584CAA8'     SQRT(3)-1
RT3      DC    X'411BB67AE8584CAB'     SQRT(3)
ALPHA1   DC    X'C0D5F788DF6CB457'      -0.8358083291502266
BETA1    DC    X'414D42F041242098'       4.828842405755528
ALPHA2   DC    X'C1DD6E91F2AD24DF'     -13.839494655565710
BETA2    DC    X'4168C2DCB9C0437F'       6.547573781576119
ALPHA3   DC    X'C1138256FCDD5CB6'      -1.219321239235610
BETA3    DC    X'41224D09A3EFF7AC'       2.143808021908152
ALPHA4   DC    X'C0145A9C5C07FB43'      -0.07950761076788829
BETA4    DC    X'4114451896975D03'       1.266869152304765
PO2M1    DC    X'40921FB54442D184'     90 DEGREES MINUS ONE
         DC    X'408C152382D73658'     60 DEGREES MINUS HALF
ATN2ZERO DC    D'0'                    0
         DC    X'40860A91C16B9B2D'     30 DEGREES
ATN2ONE  DC    X'4110000000000000'
HALFATN2 DC    X'4080000000000000'
PIOV2    DC    X'411921FB54442D18'     90 DEGREES
TAN15    DC    X'40449851'
BIAS     DC    X'0E000000'
SXTEN    DC    F'16'
ATN2SIGN DS    F
XSIGN    DS    F
MASK1    DC    X'7FFFFFFF'
         LTORG
*        END
         TITLE 'EXPONENTIAL FUNCTION'
EXPONNTL CSECT
*        EXPONENTIAL FUNCTION (LONG)
         ENTRY DEXP
         SPACE
         USING *,R15
DEXP     EQU   *
         STM   R14,R3,12(R13)
         CE    F0,EXPO#MAX
         BH    EXPONERR
         CE    F0,EXPO#MIN
         BC    12,SMALL
         SPACE
         DD    F0,LOGE2#1
         STE   F0,EXPOSIGN
         LER   R2,F0
         AU    R2,SCALER1
         STE   R2,FIELDS
         SDR   R2,R2
         AE    R2,FIELDS
         SDR   F0,R2
         L     R2,FIELDS
         SPACE
         TM    EXPOSIGN,X'80'
         BO    READY1
         SD    F0,ONO16
         LA    R2,1(R2)
         LCR   R2,R2
         SPACE
READY1   SR    R3,R3
         SRDL  R2,4
         SRL   R3,25
         SRDL  R2,2
         SLL   R2,24
         LCR   R0,R2
         SR    R2,R2
         SLDL  R2,2
         SPACE
         LDR   R2,F0
         ME    F0,C6
         AD    F0,C5
         MDR   F0,R2
         AD    F0,C4
         MDR   F0,R2
         AD    F0,C3
         MDR   F0,R2
         AD    F0,C2
         MDR   F0,R2
         AD    F0,C1
         MDR   F0,R2
         AD    F0,C0A
         AD    F0,C0A
         SPACE
         LTR   R3,R3
         BZ    SKIP5
         CE    F0,EXPONONE
         BL    SKIP4
         LD    F0,MCONST-8(R3)
         B     SKIP5
SKIP4    MD    F0,MCONST-8(R3)
SKIP5    LTR   R2,R2
         BZ    SKIP3
         HDR   F0,F0
         BCT   R2,*-2
SKIP3    STD   F0,EXPOSIGN
         A     R0,EXPOSIGN
         ST    R0,EXPOSIGN
         SDR   F0,F0
         AD    F0,EXPOSIGN
         SPACE
EXPOEXIT LM    R2,R3,28(R13)
         SR    R15,R15
         BR    R14
         SPACE
SMALL    SDR   F0,F0
         B     EXPOEXIT
         SPACE
EXPONERR LA    R15,R14
         LM    R2,R3,28(R13)
         BR    R14
EXPOSIGN DS    D
FIELDS   EQU   EXPOSIGN+4
LOGE2#1  DC    X'40B17217F7D1CF79'
ONO16    DC    X'4010000000000000'
EXPONONE DC    X'41100000'
C6       DC    X'3D9E0F1E'
C5       DC    X'3E575D42BB7276D4'
C4       DC    X'3F276553A5F9BC94'
C3       DC    X'3FE35846A61AEE7A'
C2       DC    X'403D7F7BFF0289DE'
C1       DC    X'40B17217F7D1CC79'
C0A      DC    X'4080000000000000'
MCONST   DC    X'40F5257D152486CC'
         DC    X'40EAC0C6E7DD2439'
         DC    X'40E0CCDEEC2A94E1'
         DC    X'40D744FCCAD69D6B'
         DC    X'40CE248C151F8481'
         DC    X'40C5672A115506DB'
         DC    X'40BD08A39F580C57'
         DC    X'40B504F333F9DE65'
         DC    X'40AD583EEA42A14B'
         DC    X'40A5FED6A9B15139'
         DC    X'409EF5326091A112'
         DC    X'409837F0518DB8A9'
         DC    X'4091C3D373AB11C3'
         DC    X'408B95C1E3EA8BD7'
         DC    X'4085AAC367CC487B'
SCALER1  DC    X'45000000'
EXPO#MAX DC    X'42AEAC4E'
EXPO#MIN DC    X'C2B437DF'
         LTORG
*        END
         TITLE 'LOGARITHMIC FUNCTION'
LOGRTHMC CSECT
*        LOGARITHMIC FUNCTION (LONG)
         SPACE
         ENTRY DLOG
         ENTRY DLOG10
         SPACE
         SPACE
         USING *,R15
DLOG10   EQU   *
         STM   R14,R3,12(R13)
         MVI   LOGFLAG,1
         LA    R15,DLOG-DLOG10(R15)
         USING DLOG,R15
         B     MERGE2
         SPACE
DLOG     EQU   *
         STM   R14,R3,12(R13)
         MVI   LOGFLAG,0
MERGE2   STD   F0,DBUFF
         LM    R0,R1,DBUFF
         LTR   R2,R0
         BC    12,LOGERROR
         SRDL  R2,24
         SLL   R2,2
         STH   R2,IPART+2
         SR    R2,R2
         SLDL  R2,4
         IC    R2,TABLE(R2)
         SLDL  R0,0(R2)
         STM   R0,R1,DBUFF
         MVI   DBUFF,X'40'
         SPACE
         LA    R1,8
         LD    F0,DBUFF
         CE    F0,LIMIT
         BH    READY2
         SR    R1,R1
         LA    R2,1(R2)
         SPACE
READY2   LDR   R2,F0
         SD    F0,HALFLOG
         SD    F0,LOGZERO(R1)
         AD    R2,HALFLOG(R1)
         DDR   F0,R2
         STD   F0,DBUFF
         SPACE
         MDR   F0,F0
         LDR   R2,F0
         MD    R2,C7#LOG
         AD    R2,C6#LOG
         MDR   R2,F0
         AD    R2,C5#LOG
         MDR   R2,F0
         AD    R2,C4#LOG
         MDR   R2,F0
         AD    R2,C3#LOG
         MDR   R2,F0
         AD    R2,C2#LOG
         MDR   R2,F0
         AD    R2,C1#LOG
         MDR   R2,F0
         LD    F0,DBUFF
         MDR   R2,F0
         ADR   R2,F0
         ADR   R2,F0
         SPACE
         LD    F0,IPART
         LA    R2,256(R2)
         STH   R2,IPART+2
         SE    F0,IPART
         MD    F0,LOGE2#2
         ADR   F0,R2
         SPACE
         TM    LOGFLAG,X'1'
         BZ    *+8
         MD    F0,LOGTE
         LM    R2,R3,28(R13)
         SR    R15,R15
         BR    R14
         SPACE
LOGFLAG  DS    C
         SPACE
LOGERROR LA    R15,15
         LM    R2,R3,28(R13)
         BR    R14
         SPACE
DBUFF    DS    D
IPART    DC    X'4600000000000000'
TABLE    DC    X'0303020201010101'
LOGZERO  DC    X'0000000000000000'
HALFLOG  DC    X'4080000000000000'
         DC    X'4110000000000000'
C7#LOG   DC    X'4025E9B17CA9B973'
C6#LOG   DC    X'40273337E26DBA7F'
C5#LOG   DC    X'402E8CD32A425C06'
C4#LOG   DC    X'4038E38A00083F6B'
C3#LOG   DC    X'4049249251450212'
C2#LOG   DC    X'40666666665EBAA3'
C1#LOG   DC    X'40AAAAAAAAAAAD6C'
LOGE2#2  DC    X'40B17217F7D1CF7B'
LOGTE    DC    X'406F2DEC549B943A'
LIMIT    DC    X'40B504F3'
ACOM     DC    F'0'
         LTORG
*        END
         TITLE 'SINE/COSINE FUNCTIONS'
IHCLSCN  CSECT
*
*        SINE/COSINE FUNCTIONS (LONG)
*              1. DIVIDE MAGNITUDE OF ARG BY PI/4 TO FIND OCTANT
*                   AND FRACTION
*              2. IF COSINE, ADD 2 TO OCTANT NUMBER
*                 IF SINE FOR NEGATIVE ARG, ADD 4 TO OCTANT NUMBER
*              3. COMPUTE SINE OR COSINE OF FRACTION*PI/4 DEPENDING
*                   ON THE OCTANT
*              4. IF OCTANT NUMBER IS FOR LOWER PLANE, MAKE SIGN -
         SPACE
         ENTRY DCOS
         ENTRY DSIN
         SPACE
         SPACE
         USING *,R15
DCOS     EQU   *
         STM   R14,R15,12(R13)
         LA    R0,2                    OCTANT CRANK OF 2 TO R0
         LA    R15,DSIN-DCOS(R15)      ADJUST BASE REGISTER
         USING DSIN,R15                AND JOIN MAIN CIRCUIT
         B     MERGE3
         SPACE
DSIN     EQU   *
         STM   R14,R15,12(R13)
         SR    R0,R0                   ARGUMENT ADDRESS TO R1
         LTDR  F0,F0
         BNL   *+8
         LA    R0,4
         SPACE
MERGE3   EQU   *
         LPER  F0,F0                   FORCE SIGN OF ARG TO +
         CE    F0,LSCN#MAX
         BC    10,LSCN$ERR             ERROR IF /X/ GRT THAN OR = PI*2*
         SPACE
         DD    F0,PIOV4#2              DIVIDE BY PI/4 AND SEPARATE INTE
         LDR   R2,F0                   PART AND FRACTION PART OF QUOTIE
         AW    R2,SCALER2              FORCE CHARACTERISTIC X'4E'
         STD   R2,ARG                  INTEGER PART UNNORMALIZED = OCTA
         SDR   R2,R2
         AD    R2,ARG                  INTEGER PART NORMALIZED
         SDR   F0,R2
         AL    R0,ARG+4                ADJUST OCTANT NUMBER WITH CRANK
         ST    R0,OCTNT#1              AND SAVE IT
         SPACE
         TM    OCTNT#1+3,X'01'         IF ODD OCTANT, TAKE COMPLEMENT
         BZ    EVEN$1                  OF FRACTION TO OBTAIN MODIFIED A
         SD    F0,HALFLSCN
         SD    F0,HALFLSCN             SUBTRACT 1 IN 2 STEPS
         SPACE
EVEN$1   LPDR  F4,F0
         SR    R1,R1                   R1 = 0 FOR COSINE POLYNOMIAL
         TM    OCTNT#1+3,X'03'         THIS IS FOR OCTANT 2,3,6, OR 7
         BM    *+8                     IF OCTANT 1,4,5, OR 8, USE SINE
         LA    R1,8                    POLYNOMIAL.  R1 = 8
         SPACE
         MDR   F0,F0                   COMPUTE SIN OR COS OF MODIFIED A
         LDR   R2,F0                   USING PROPER CHEBYSHEV INTERPOLA
         MD    F0,C7#LSCN(R1)          POLYNOMIAL
         AD    F0,C6#LSCN(R1)
         MDR   F0,F2                   SIN(X)/X POLYN OF DEGREE 6 IN XS
         AD    F0,C5#LSCN(R1)          COS(X)   POLYN OF DEGREE 7 IN XS
         MDR   F0,R2
         AD    F0,C4#LSCN(R1)
         MDR   F0,R2
         AD    F0,C3#LSCN(R1)
         MDR   F0,R2
         AD    F0,C2#LSCN(R1)
         MDR   F0,R2
         AD    F0,C1#LSCN(R1)
         SPACE
         LTR   R1,R1
         BZ    COSF
         MDR   F0,F4                   COMPLETE SIN POLYNOMIAL BY
         B     LSCNSIGN                MULTIPLYING BY X
         SPACE
COSF     MDR   F0,R2                   COMPLETE COS POLYNOMIAL
         AD    F0,HALFLSCN             (ONE MORE DEGREE)
         AD    F0,HALFLSCN             ADD 1 IN 2 STEPS
         SPACE
LSCNSIGN TM    OCTNT#1+3,X'04'         IF MODIFIED OCTANT IS IN
         BZ    *+6                     LOWER PLANE, SIGN IS NEGATIVE
         LNER  F0,F0
         SPACE
         SR    R15,R15
         BR    R14
         SPACE
         CNOP  0,4
LSCN$ERR LA    R15,16
         BR    R14
         SPACE
ARG      DS    D
SCALER2  DC    X'4E00000000000000'
C7#LSCN  DC    X'B66C992E84B6AA37'
         DC    X'3778FCE0E5AD1685'     S6
C6#LSCN  DC    X'387E731045017594'
         DC    X'B978C01C6BEF8CB3'     S5
C5#LSCN  DC    X'BA69B47B1E41AEF6'
         DC    X'3B541E0BF684B527'     S4
C4#LSCN  DC    X'3C3C3EA0D06ABC29'
         DC    X'BD265A599C5CB632'     S3
C3#LSCN  DC    X'BE155D3C7E3C90F8'
         DC    X'3EA335E33BAC3FBD'     S2
C2#LSCN  DC    X'3F40F07C206D6AB1'
         DC    X'C014ABBCE625BE41'     S1
C1#LSCN  DC    X'C04EF4F326F91777'     LAST DGT REDUCED BY 2
PIOV4#2  DC    X'40C90FDAA22168C2'     S0
HALFLSCN DC    X'4080000000000000'     1/2 = C0/2
LSCN#MAX DC    X'4DC90FDA'
OCTNT#1  DS    F
         LTORG
*        END
         TITLE 'TANGENT/COTANGENT FUNCTIONS'
IHCLTNCT CSECT
*        TANGENT-COTANGENT FUNCTION (LONG)
*              1. DIVIDE MAGNITUDE OF ARG BY PI/4 TO FIND OCTANT AND
*              FRACTION.  REDUCED ARGUMENT W IS EITHER THIS
*              FRACTION OR ITS COMPLEMENT.  THE MAGNITUDE OF
*              ANSWER IS EITHER TAN(W*PI/4) OR COT(W*PI/4)
*              2. IF /ARG/ IS EQUAL OR GREATER THAN PI*2**50, ERROR1
*              3. IF COTAN IS WANTED, AND IF /ARG/ IS EQUAL OR SMALLER
*              THAN 2**(-252), ERROR2
*              4. IF ARG IS SO CLOSE TO ONE OF SINGULARITIES OF THE
*              FUNCTION THAT THE COMBINED EFFECT OF COMPUTATIONAL
*              ERROR AND MINIMAL INPUT ERROR CAN CAUSE RELATIVE
*              ERROR OF 1/5, ERROR2 IS GIVEN
         SPACE
         ENTRY DTAN
         ENTRY DCTAN
         ENTRY QDTAN                   FOR MODIFICATION OF ERROR CONTRO
         SPACE
         SPACE
         USING *,R15
DCOTAN   EQU   *
DCTAN    EQU   *
         STM   R14,R15,12(R13)         SAVE REGISTERS
         MVI   SWICH,X'97'             SET INSTRUCTION AT SWICH TO XI
         LA    R15,DTAN-DCOTAN(R15)    ADJUST BASE REGISTER
         USING DTAN,R15                AND JOIN COMMON CIRCUIT
         B     MERGE4
         SPACE
DTAN     EQU   *
         STM   R14,R15,12(R13)         SAVE REGISTERS
         MVI   SWICH,X'91'             SET INSTRUCTION AT SWICH TO TM
         SPACE
MERGE4   EQU   *
         STE   F0,ARG#T
         LPER  F0,F0                   /ARG/
         CE    F0,LTNCTMAX
         BC    10,ERROR1               IF /ARG/ TOO BIG, GIVE ERROR1
         DD    F0,PIOV4#3
         STE   F0,OCTNT#2
         MVC   TEST(1),OCTNT#2         GIVE CHAR OF QUOTIENT TO TESTING
         CE    F0,LTNCTONE
         BC    10,NORML2               IF QUOTIENT HAS INTEGER PART, SK
         SPACE
         MVI   OCTNT#2+7,X'00'         SET LOW PART OCTANT TO 0
         TM    SWICH,X'02'             IF PURE FRACTION
         BZ    JOIN$2                  AND IF TAN ENTRY, SKIP
         CE    F0,MIN                  IF PURE FRACTION AND COTAN ENTRY
         BH    JOIN$2                  SKIP ONLY WHEN NO DANGER OF OVER
         SPACE
         CNOP  0,4
ERROR2   LA    R15,18
         BR    R14
         SPACE
NORML2   LDR   R2,F0                   IF QUOTIENT HAS INTEGER PART,
         AW    R2,CH4E                 ISOLATE IT IN R2 (UNNORMALIZED)
         STD   R2,OCTNT#2              SAVE IT (LAST BITS ARE FOR OCTAN
         SDR   R2,R2                   NORMALIZE IT IN R2 AND
         AD    R2,OCTNT#2              SUBTRACT IT FROM F0 TO
         SDR   F0,R2                   OBTAIN FRACTION PART IN F0
JOIN$2   TM    OCTNT#2+7,X'01'
         BZ    EVEN$2                  IF EVEN OCTANT, MODIF ARG W IS R
         SD    F0,HALFLTNC             IF ODD OCTANT, W=1-FRACTION
         SD    F0,HALFLTNC
EVEN$2   LPDR  F6,F0                   LEAVE W IN F6
SWICH    XI    OCTNT#2+7,X'01'         XI IF COTAN ENTRY, TM IF TAN ENT
         MDR   F0,F0                   I.E., IF COTAN, REVERSE LAST BIT
         LDR   F4,F0                   OF OCTANT.  THIS ACTION REDUCES
         MD    F0,A3                   COTAN ENTRY TO TAN ENTRY
         AD    F0,A2
         MDR   F0,F4                   COMPUTE FACTORS P(W) AND Q(W)
         AD    F0,A1                   BY POLYNOMIALS OF THE FORM
         MDR   F0,F4
         AD    F0,A0                   P(W) = A0*W+A1*W**3
         MDR   F0,F6                   +A2*W**5+A3*W**7
         LDR   R2,F4
         AD    F2,B3                   Q(W) = B0+B1*W**2
         MDR   F2,F4                   +B2*W**4+B3*W**6+W**8
         AD    R2,B2
         MDR   R2,F4
         AD    R2,B1
         MDR   R2,F4
         AD    R2,B0
         TM    OCTNT#2+7,X'03'
         BM    COTN
         DDR   F0,F2                   IF OCTANT IS 0 OR 3 (MOD 4),
         B     LTNCSIGN                THE ANSWER IS TAN(W*PI/4=P(W)/Q(
         SPACE
COTN     CD    F6,TEST                 IF OCTANT IS 1 OR 2 (MOD 4), AND
         BC    12,ERROR2               W IS TOO SMALL, SINGULARITY TROU
         DDR   R2,F0                   OTHERWISE, THE ANSWER IS
         LDR   F0,R2                   COTAN(W*PI/4)=Q(W)/P(W)
         SPACE
LTNCSIGN TM    OCTNT#2+7,X'02'         IF OCTANT IS 2 OR 3 (MOD 4)
         BZ    *+6                     CHANGE SIGN OF ANSWER
         LCER  F0,F0
         TM    ARG#T,X'80'
         BZ    *+6                     CHANGE SIGN OF ANSWER
         LCER  F0,F0
         SR    R15,R15
         BR    R14
         SPACE
         SPACE
         CNOP  0,4
ERROR1   LA    R15,17
         BR    R14
         SPACE
OCTNT#2  DS    D
PIOV4#3  DC    X'40C90FDAA22168C2'     PI/4
HALFLTNC DC    X'4080000000000000'
CH4E     DC    X'4E00000000000000'     UNNORM ZERO FOR SCALING
TEST     DC    X'00000000'             WITH EXPN P GIVEN TO TEST,
QDTAN    DC    X'00000008'             VALUE OF 2 WORDS = 2**(4P-53)
A0       DC    X'46A6C4EF86458B3D'      0.1092939152449866E+8 RDD UP
A1       DC    X'C5DB82BFF1D367E5'     -0.8991159965395029E+6
A2       DC    X'443799624FA939C4'     0.1423338402803097E+5
A3       DC    X'C22DB88919A77DCD'     -0.4572084198321481E(2
B0       DC    X'46D456557D27917A'      0.1391573348888501E+8
B1       DC    X'C63D20D20D5EE18A'     -0.4006098052229019E+7
B2       DC    X'45212A3F3063FBCA'      0.1358439493141017E+6
B3       DC    X'C33F931E00B5BF01'     -0.1017194824895807E+4
LTNCTMAX DC    X'4DC90FDA'             PI*2**50
MIN      DC    X'02145F31'             (4/PI)*2**-252
LTNCTONE DC    X'41100000'
ARG#T    DS    F
         LTORG
         END
