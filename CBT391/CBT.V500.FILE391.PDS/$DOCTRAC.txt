TRACE390 - An Assembler Level Trace Routine


Function

The TRACE390 routine is used to trace a program's execution at the
assembly level. Each instruction is printed after it is executed
displaying various data related to the execution of the instruction.

Description

TRACE390 retains control of the traced program after it is called
and executes the traced program's instructions until it detects that
it is tracing itself at which point it returns control.

Control

On entry, register one contains one of the following values:

0            Turn tracing off, if tracing is not on then do nothing.

-1           Invoke trace with parameter list containing zeroes in
             all positions.

-2           Same as for -1 except flag Flg$GDSN is assumed to be
             set.

Other        The value in register one is the address of a variable
             length parameter list in the format shown in the table
             below.

If register 1 is non-zero, tracing is toggled (i.e. if it is off,
it will be turned on and vice versa).

Offset     Type       Description

+0         A          Address of Bit Flags Word
+4         A          Address of Print Range(s) Table
+8         A          Address of Break Point(s) Table
+C         A          Address of Watchpoint(s) Table
+10        A          Address of Execution Profile Table
+14        A          Address of Instruction Count Table
+18        A          Address of Output DD Name

Register 14 contains the address of the first instruction to be
traced, with the high order bit specifying the addressing mode of
the traced program. Note that the BAL instruction will set the high
order bit in the linkage register in AMODE=24, so should not be used
to invoke this module.

The parameter list and parameters passed to TRACE390 may reside
anywhere in virtual storage. The dsects for the various table
entries are generated by macro TRCTBLS.

Note: ALL addresses specified in the parameters are treated as 31
bit values, it is up to the user to ensure that there is no
extraneous bits set in the top byte. The high order bit should only
be set to signify "end of list" or that an user exit should be
entered with AMODE=31.

Bit Flags Word

This is a fullword containing the initial status flags to be used by
the trace routine. Equates for the flags are found in macro TRCFLAGS,
the flags specified in the first byte are:

Flg$PrHdr           x'80'     Print page header at top of each page.

Flg$Print           x'40'     Instruction printing is enabled.

Flg$PrCurInst       x'20'     Print current instruction even if
                              Flg$Print is off, this flag is normally
                              only set by user exits and is turned off
                              at the end of each instruction.

Flg$TrDLI           x'10'     Trace code within DL/I calls.

Flg$PrBAL           x'08'     Turn Flg$PrCurInst on for BAL, BALR,
                              BAS, BASR and BASSM.

Flg$PrRet           x'04'     Turn Flg$PrCurInst on for BSM, and
                              BCR instructions in which the branch
                              was taken.

Flg$Spin            x'02'     If set on entry to TRACE390 and output
                              is directed to a SYSOUT dataset, will
                              spin off the output when tracing is
                              turned off. If set on return from an
                              user exit, will close and re-open output
                              dataset before printing the next output
                              line. If output is to a SYSOUT dataset,
                              the closed dataset will be spun off
                              before it is re-opened.

Flg$Call            x'01'     Turn on Flg$PrCurInst for SVC, and for
                              BALR, BASR and BASSM instructions which
                              use R14 and R15, with R15 pointing at a
                              branch instruction jumping around module
                              identification information.  The flags
                              used in the second byte are:

Flg$PICT            x'80'     Print contents of the instruction count
                              table(s) on exit from trace. Where trace
                              is to be invoked multiple times, this
                              flag should be set on the last entry to
                              trace otherwise you will get the
                              table(s) printed multiple times.

Flg$NCFP            x'40'     Setting this flag disables counting
                              of floating point instructions.

Flg$PEPT            x'20'     Print contents of the execution profile
                              table(s) on exit from trace. Where trace
                              is to be invoked multiple times, this
                              flag should be set on the last entry to
                              trace otherwise you will get the tables
                              printed multiple times.

Flg$NPNE            x'10'     Suppress printing of execution counts of
                              instructions that were never executed.

Flg$NALC            x'08'     Do not dynamically allocate output
                              dataset if the DD name entry was not
                              found in the TIOT. If this occurs,
                              tracing is disabled.

Flg$GDSN            x'04'     Allocate a cataloged dataset to hold the
                              trace output, the name of the dataset is
                              of the form:

                              TESTHOG.T370.asname.Ddate.Ttime.Sseq

                              where:
                              asname  The name of the address space in
                                      which TRACE390 is executing
                              date    The Julian date when the first
                                      output line was written
                              time    The time (hhmmss) when the first
                                      output line was written
                              seq     This 3 character field is the
                                      hundredths of seconds from the
                                      time plus a single hex digit (in
                                      case you spin off multiple output
                                      datasets within the space of the
                                      same hundredth of a second!).

Flg$NoPrEMC         x'02'     Do not print BC, BCR and BRC
                              instructions in extended mnemonic
                              format.

x'01'               Reserved

The other two bytes are reserved and must be set to zeros. If the
flag word address is zero, a default of Flg$PrHdr+Flg$Print will be
used.

Print Range(s) Table

This table containing range(s) of addresses for which traced
instructions will be printed. Instructions traced, which are not
within any specified range, will not be printed. If the table
address is zero or this parameter is not supplied, all traced
instructions will be printed.

The table consists of one or more 8 byte entries in the format shown
below. Entries are mapped by DSECT PrtEntry.

Offset     Type       Name       Description

+0         A          PrtStart   Start Address of Print Range
+4         A          PrtEnd     End Address of Print Range

The end of the table is specified by setting the high order bit of
the in the PrtStart field.

Break Point(s) Table

The break point table allows programmers to obtain control when the
instruction pointer reaches a specified location (or locations).
This table consists of one or more 8 bytes in the format shown in
the table below.  Entries are mapped by DSECT BptEntry.

Offset     Type       Name       Description

+0         A          BptAddr    Break Point Address
+4         A          BptExit    AMODE/EPA of breakpoint exit.

Setting the high order bit in the BtpAddr field of the last table
entry specifies the end of the table.  If the table address is zero
or this parameter is not supplied, there are no breakpoints.  See
Breakpoint/Watchpoint Exits below for details on Breakpoint exits.

Watch Point Table

This table defines a range (or ranges) of storage at which the user
wants to trap storage alterations. If the table address is zero or
this parameter is not supplied, no watch points are set.  This table
consists of one or more 16 byte entries in the format shown below.
Entries are mapped by dsect WPTENTRY.

Offset     Type       Name       Description

+0         A          WptStart   Watch Point Address
+4         A          WptEnd     Watch Point End Address
+8         F          WptALET    ALET of watchpoint range
+C         A          WptExit    AMODE/EPA of Watch Point Exit

Setting the high order bit in the WPTSTART field of the last table
entry specifies the end of the table.  The exit routine is invoked
prior to the execution of the instruction that will alter any byte
in the address range specified with the exit.

Profiler Table

The profiler table is used to obtain information on the where a
program is spending its time. The table contains one or more 24 byte
entries in the format shown below. Entries are mapped by dsect
PRFENTRY.

Offset     Type       Name       Description

+0         A          PRFTABLE   Address of Profile Data Table
+4         F          PRFINTVL   Profile Range Sub-Interval Size
+8         A          PRFSTART   Start Address of Profile Range
+C         A          PRFEND     End Address of Profile Range
+10        CL8        PRFIDENT   Profile Range Identifier.

Setting the high order bit in the PRFTABLE field of the last table
entry specifies the end of the table.  If the table address is zero
or not supplied, no profiling will be done.

The Sub-Interval Size is the size of the interval which the profile
range will be sub-divided into. The minimum value for this field is
four.

The Profiler Data Table is a block of unsigned fullwords containing
the count of instructions executed within the relative sub-interval.
The number of fullwords in this table is equal to:

        CEIL(End Address - Start Address)/(Sub Interval Size))

It is the user's responsibility to initialize the data table to
zeros, TRACE390 will not zero the table so it can be invoked
multiple times with the same parameter list to give the caller
cumulative counts.  The identifier is used when TRACE390 prints the
contents of the data table and is printed with the title line.

Instruction Count Table

This table is used to count the number of times an instruction is
executed within an address range.  If the table address is zero or
not supplied, no instruction counting is done. The table contains
one or more 20 byte entries in the format shown below. Entries are
mapped by dsect IN#ENTRY.

Offset     Type       Name       Description

+0         A          IN#TABLE   Address of Instruction Count Data
+4         A          IN#START   Start Address of Count Range
+8         A          IN#END     End Address of Count Range
+C         CL8        IN#IDENT   Count Range Identifier.

The end of the table is specified by setting the high order bit in
the IN#TABLE field of the last table entry.

The instruction count data area consists of 1024 fullwords, it is
the callers responsibility to initialize the count data to zeros.
TRACE390 will not zero the table so it can be invoked multiply times
with the same parameter list to give the caller cumulative counts.
Each fullword is considered to be a 32 bit unsigned number.

The count table is indexed by the first byte of the instruction code
so counts of two byte opcodes with equal first bytes are merged.

The identifier is used when TRACE390 prints the contents of the data
table and is printed with the title line.

Output DD Name

This is an 8-byte character string to be used as the DD name which
trace will write its output to. If this parameter is zero or not
supplied, the output DD name will default to SYSTRACE.

Invoking TRACE390

The trace routine should always be invoked using the instructions
        LA    R01,parmlist        (or SLR  R01,R01 to disable Trace)
        CALL  TRACE               Toggle/Disable Trace

The csect TRACE is actually a stub that will load TRACE390 on first
time through and branch to it. If not the first time through, it
will just branch to TRACE390.  This gives us a standard interface to
the trace routine for callers above and below the 16M line.  TRACE is
also link-edited as RMODE=ANY so linking it into your program make
your program RMODE=24.

Note: The csect TRACE is NOT re-entrant since it needs to store the
EPA of TRACE390.  TRACE390 must reside below the line since it must
run with AMODE=24 while processing AMODE=24 code so it cannot be
link-edited into modules which are loaded above the 16M line, this
is not a problem for TRACE.

Since TRACE390 is dynamically loaded at run time, it must reside in
either the link list or your JOBLIB/STEPLIB.

Exit Conditions

On exit, the registers and the condition code are restored to the
values they had after the last instruction traced.

All output written by the trace routine is written to a user DD name
(or SYSTRACE if no DD name was supplied). If no DD statement was
supplied for the trace output dataset, it will be dynamically
allocated as a SYSOUT=* dataset (unless the caller set the Flg$NALC
flag). The dataset has the following attributes:
LRECL=133,BLKSIZE=0,RECFM=FBA

Example of output produced by TRACE390 is shown in member
$EXTRACE.

The following fields are printed with each instruction executed
(assuming that printing is enabled):

. Current addressing mode and location counter (bits 32-63 of PSW)
. Current Address Space Control (ASC) mode, one of:
    P - Primary-space mode
    S - Secondary-space mode
    A - Access-register mode
    H - Home-space mode
. Instruction image (in hex)
. Condition Code (displayed as mask bit value)
. An arrow is printed for each successful branch instruction, the
  arrow indicates the relative direction of the branch, i.e.,
    <- : branching to a lower address
    -> : branching to a higher address
    <> : branch to the current instruction (looping?)
. Instruction Mnemonic
. Instruction Operand(s)
. For SVC instructions, the name(s) of the macro(s) normally used to
  generate the SVC.
. Contents of first register operand (R1)
. Contents of second register operand (R2) (or contents of R1+1 if a
  double register operand)
. Effective address of first storage operand (or contents of R2 if a
  double register operand)
. First Operand storage contents (up to 8 bytes) (or contents of
  R2+1 if a double register operand)
. First Operand storage contents (Second half of double word)
. Effective address of Second storage operand
. Second Operand storage contents (up to 8 bytes)
. For BALR/BASR/BASSM instructions using registers 14 and 15 as
  operands, the module-id information (if present).
. Module-id information will not be printed for BASSM instructions
  which switch from AMODE=24 to AMODE=31 where the target of the
  branch is above the 16M line.

The following information is printed for each execution profile table:
. The offset from the start of the range to the sub-interval.
. The start-end addresses of the sub-interval.
. The number of instructions executed within the sub-interval.
. The percentage of instructions executed in the sub-interval
  (compared to the total over that range).

The following information is printed for each instruction count table:
. Operation Code (in hex)
. Instruction Mnemonic
. Number of instructions executed in the count range
. The percentage value of the number of this instruction compared to
  the total number of instructions executed in the count range.

The instructions are printed in order of operation code.

Breakpoint/WatchPoint Exits

Both Breakpoint and WatchPoint exits are invoked before execution of
the instruction in question. On entry to the exit, the contents of
the registers are:

R01 - Address of a 9 fullword fixed length parameter list.
R13 - Address of a 18 fullword register save area.
R14 - Return address to TRACE390
R15 - Entry point address to exit

The parameter list pointed at by R01 is in the format shown in the
following table.

Offset     Type       Description

+0         A          Address of Bit Flags Fullword
+4         A          Address of traced program's general registers
+8         A          Address of the traced program's access registers
+C         A          Address of traced program's Condition Code
+10        A          Address of traced program's PSW Bits 32-63
+14        A          Address of Address of Storage to be Altered
+18        A          AMODE/EPA of the Trace Output Routine
+1C        A          Address of Output Routine's Data Area
+20        A          AMODE/EPA of the Storage Dump Routine

1. The address of the status flags word, this flag word was
   described at the beginning of this document.  The exit may modify
   these flags to change processing by the trace routine. Note that
   setting flag Flg$PrCurInst will result in printing of the current
   instruction (only), even if printing is disabled or the instruction
   is not in a valid instruction print range.

2. The address of a 16-fullword area containing the traced programs
   general registers, stored in the sequence R00-R15. The exit may
   modify any/all of the registers.

3. The address of a 16-fullword area containing the traced programs
   access registers, stored in the sequence AR00-AR15. The exit may
   modify any/all of the registers.

4. The address of a byte containing the traced programs current
   condition code. The condition code is stored in bits 6-7 of the
   byte, bits 0-5 are zeros and must remain so. The exit may modify the
   condition code.

5. The address of a fullword containing bits 32-63 of the traced
   programs PSW, i.e. its addressing mode and current location counter.
   Breakpoint exits may change the addressing mode and/or location
   counter, changes to this field by WatchPoint exits are ignored.

6. The address of a fullword containing the address of the byte of
   storage about to be altered. For breakpoint exits, this fullword
   contains zero.

7. The address of a routine used to write to output to the trace
   dataset. Callers in any amode/rmode may use this routine. This
   routine must be invoked via BASSM R14,R15, and the caller must
   provide a save-area pointed at by R13.

8. The address of a 133-byte area used by the trace output routine
   as the data area to be printed. This is the actual I/O area used by
   TRACE390 to build output lines so the user could set the carriage
   control byte to C'1' to generate page skips so as to break up the
   output into logical sections.

9. The address of a routine which a user exit may invoke to produce
   a formatted dump of virtual storage (output is sent to the trace
   dataset) and may be used by callers in any amode/rmode. On entry, it
   expects the starting address of the storage to dump in register 0
   and the length of the storage to be dumped (in fullwords) in
   register 1. This routine must be invoked via BASSM R14,R15, and the
   caller must provide a save-area pointed at by R13.

Note that calling this routine will clear the contents of the output
routine's data area as it is used by the dump routine.

All exits are invoked using BASSM R14,R15 so should return to the
trace routine via a BSM 0,R14 instruction. The traced programs
floating point registers remain in the actual floating-point
registers on entry to an exit, the exit may change any/all of the
floating point registers.

If the exit wants to write to the trace output dataset, it should
use the following code:

         L     R02,24(,R01)         Point to output buffer
         MVC   0(133,R02),outdata   Move data to output buffer
         L     R15,20(,R01)         Address of TRACE's PUT routine
         BASSM R14,R15              Go do PUT

All registers are restored on return from the PUT routine.

To spin-off (or reuse) the output dataset, the exit merely needs to
set Flg$SPIN in the first byte of the status word i.e.

SPINEXIT DS    0H                   Spinoff or reuse output dataset
         L     R15,0(,R01)          Load address of status flags
         OI    0(R15),Flg$SPIN      Turn on spinoff flag
         SLR   R15,R15              Set zero return code
         BSM   0,R14                Return to TRACE

On return from a user exit, R00-R14 must be restored, R15 holds the
return code, a value of zero to indicate continuation of tracing,
any other value will turn tracing off. If tracing is turned off, it
will be turned off after the current instruction is executed.

Messages

Data set closed by ESTAE, abending PSW is hhhhhhhh hhhhhhhh
-----------------------------------------------------------

An abend occurred at the indicated PSW address, the TRACE390 ESTAE
routine successfully closed the SYSPRINT dataset before allowing the
abend to percolate.

This message is issued when the abend occurs during execution of an
instruction which TRACE390 is not controlling, i.e.
. DL/1 code not traced by TRACE390
. Code being executed under a different RB (normally a result of
  executing a SVC)
. Bad code within TRACE390 itself

Data set closed by ESTAE, abending while tracing instruction at
---------------------------------------------------------------
address aaaaaaaa
----------------

TRACE390 abended while attempting to execute an instruction copied
from the indicated address. The TRACE390 ESTAE routine successfully
closed the SYSPRINT dataset before allowing the abend to percolate.

TRC001 Status flags invalid, bytes 3-4 are non-zero, Flags=hhhhhhhh
-------------------------------------------------------------------

The second 2 bytes of the flag word in the parameter list are
currently reserved for future use and should be set to zero but
TRACE390 found the indicated values there.  Ensure that you are
passing a correct parameter list to TRACE390.

TRC002 Invalid tttt table entry, Start(ssssssss) GT End(eeeeeeee)
-----------------------------------------------------------------

A table entry was found with a start range higher than the end
range. Note that the end of table marker should be on the start of
range address.

TRC003 User Supplied DDNAME dddddddd is invalid
-----------------------------------------------

The user supplied DD name with which to replace SYSTRACE contains
characters which are not valid in a DD name.

TRC004 End of parmlist not found at seventh parameter
-----------------------------------------------------

TRACE390 expects a maximum of 7 parameters to be passed to it but
the seventh parameter was processed without finding the high order
bit set in a parameter address.

TRC005 DYNALLOC error, Verb=vv, RC=rr, Error=eeee, Info=iiii,
-------------------------------------------------------------
DDNAME=dddddddd
---------------

A dynamic allocation request failed while attempting to allocate or
deallocate the trace output dataset.  Refer to the OS/390 MVS
Authorized Assembler Services Guide manual for details on the
returned error information.

TRC006 Attempt to ESTAE failed, RC=rr
-------------------------------------

TRACE390's attempt to establish an ESTAE to trap abends returned the
indicated return code, zero was the expected return code.  Contact
Umbrella Support.

TRC007 Dataset OPEN failed on DDNAME dddddddd
---------------------------------------------

An OPEN for output failed for the indicated DD.

TRC008 DDNAME "dddddddd" not found in task I/O table
----------------------------------------------------

The indicated DD was not found in the Task I/O Table and flag
TRC$NARC was not specified.

TRC009 Unable to return to traced program, no valid base register
-----------------------------------------------------------------

During trace termination, a register must be used as a base for the
branch back to the code being traced. No register was found which
could be used for this purpose.

This can occur if the traced program issues an SVC which branches
back into the traced program to where tracing is turned off before
the SVC returns. An example of this is PEM linking to SORT which
then calls PEM as a SORT exit.

TRC010 Profile sub-interval of iiiiiiii is invalid
--------------------------------------------------

The profiler sub-interval must have a value not less than 4.

TRC011 Zero table address is invalid in tttttttt entry
------------------------------------------------------

A zero address is not allowed for a profiler or instruction count
data table.

TRC012 Bit zero set in tttttttt address (aaaaaaaa)
--------------------------------------------------

The high order bit of an address field was set where it was not
permitted. The high order bit may only be used in exit EPA's to
indicate the exit is to be invoked with AMODE=31, or to mark the
last entry of a table.

TRC013 tttttttt entry at address aaaaaaaa has an exit EPA of zero
-----------------------------------------------------------------

A table entry was found in which the exit routine's address was
zero, which is not permitted.

Exception Conditions

A U3579 abend will result from any of the following conditions:
    1. Attempt to ESTAE failed
    2. Invalid output DD name passed to program.
    3. Trace output DCB could not be opened.
    4. Invalid parameter list passed to TRACE390.

The actual cause of the abend will be displayed on the job log via a
WTO message immediately before issuing the ABEND.

Note: 3579 is used as it is in the range of codes reserved by IMS
for customer usage.

Restrictions (and known bugs)

The following is a list of known problems and restrictions in the
use of the trace routine:

. Does not support privileged instructions
. Does not support vector instructions
. Does not support binary floating point instructions.
. WatchPoints are only triggered by (non-SVC) instructions executed
  under the control of TRACE390, therefore if the DL/I trace flag is
  off, storage altered by DL/I will not trigger a call to the watch
  point exit. Storage altered by SVC and PC instructions never trigger
  watchpoint exits.
. WatchPoints are not triggered by UPT instructions.
. Tracing of DL/I calls is only be disabled for entries to DL/I via
  BALR, BASR and BASSM with R14,R15 as operands. If a BASSM
  instruction is used which switches from AMODE=24 to AMODE=31 with
  the branch target above the 16MB line, DL/I tracing cannot be
  disabled.

Components

Name       Type       Description

TRACE      Program    Stub for linking to traced program
TRACE390   Program    Main trace routine
TRCTBLS    Macro      Dsects for parameters passed to TRACE390
TRCFLAGS   Macro      Equates for bit switches used by TRACE390

 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Credits

Author:    Bernard Schoch, Comnet Computer Center
Debugged 03/22/74 by Claude Schoch
Converted for 370 instructions and extended floating point
instructions by Claude Schoch 2/12/75

Enhanced and supported by:
    Lionel Silva
    US Postal Data Center
    850 Cherry Avenue
    San Bruno, CA 94097-9330
    (415) 876-9142

Enhanced again by:
    Robert Ngan (October 1987)
    Environment Technical Support,
    Databank Systems (NZ) Ltd.
    Wellington,
    New Zealand.

in the following areas:
    . Support 370/XA instructions
    . Support programs running in AMODE=31
    . Support RMODE=ANY code and data
    . Support semi and non privileged X'B2' instructions
    . Trap storage alteration at user specified addresses
      (watchpoints)
    . Restrict instructions printed to user specified ranges
    . Allow caller to specify breakpoints
    . Allow (optional) suppression of DL/I code trace
    . Correct format of packed decimal operands for printing
    . Prevent instruction fetches off the end of the program
    . Trace program/subroutine call and return type branches
    . Print module identification data on CALL type branches
    . Gather program execution profile information
    . Count number of instructions executed in user defined ranges
    . Dynamically allocate output dataset if not pre-allocated

Enhanced by:
Robert Ngan (November 1989)
Integrated Systems Support,
Great Western Bank.
19860 Plummer Street,
Chatsworth, CA 91311
in the following area(s):

    . Allow dynamic allocation of cataloged output dataset

Enhanced by:
Robert Ngan (October 1999)
CSC Financial Services Group,
Dallas, TX 75063
in the following area(s):

    . Support access-register ASC mode programs and the use of access
      registers
    . Support tracing of BAKR and PR instructions
    . Support move-page facility
    . Support string-instruction facility
    . Support immediate-and-relative facility.
    . Support compare-and-move-extended facility
    . Support checksum facility
    . Support trap facility
    . Print BC, BCR and BRC instructions in extended mnemonic format

Reporting Problems

Bug reports should be emailed to Robert Ngan at:

  Robert_Ngan@csc.com

Original Program Source

A Compiler Generator (Appendix 2)
by W M McKeeman, J J Horning and D B Wortman.
Prentice Hall. (c) 1970.

Library of Congress Catalog Number 76-117205
ISBN 013-155077-2

Original program source available from: www.cs.toronto.edu/XPL/xpl.zip
