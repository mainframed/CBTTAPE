

       START UNDERSCORE = EX PT LOS
       END       "        EX PT LOC
       SKIP PAGE          !T+99     (LOWER CASE T)



   !t+99
                  ***** GENERAL INFORMATION *****

1. "DIALOGUE MANAGER" IS A RELATIVELY NEW FEATURE OF, AND RUNS UNDER
   THE NEW PRODUCT KNOWN AS "ISPF". WHAT YOU ARE USED TO CALLING
   "¬SPF¢" HAS BEEN RENAMED TO "¬PDF¢", AND IT, TOO, RUNS UNDER
   ISPF. DIALOGUE MANAGER IS A SORT OF POOR MANS' CICS; THE POINT OF
   IT IS TO ALLOW A PERSON TO BUILD A SYSTEM THAT WILL DISPLAY PANELS
   TO AN END-USER, GET THAT USER TO FILL IN ANY NEEDED INFORMATION (IN
   BUILT-IN INPUT FIELDS IN THE PANELS), AND THEN RETURN THAT
   INFORMATION TO SOME SORT OF PROCESSING PROGRAM WHICH HANDLES
   IT IN THE USUAL MANNER - UPDATE DISK FILES, PERFORM CALCULATIONS,
   ETC. OR, MAYBE THE USER FURNISHES SOME SORT OF SEARCH
   KEY TO THE PROCESSING PROGRAM WHICH IN TURN RETURNS TO
   THE USER WHATEVER INFORMATION HE NEEDS, VIA MORE PANEL DISPLAYS.
   AN ENTIRE SYSTEM OF PROGRAMS AND PANELS IS COLLECTIVELY REFERRED
   TO AS A "DIALOGUE".  A WELL WRITTEN "DIALOGUE" WILL LOOK AND ACT VERY MUCH
   LIKE PDF. BEAR IN MIND THAT IT'S JUST A DISPLAY MECHANISM - I.E.
   YOU CANNOT WRITE A COMPLETE PRODUCTIVE SYSTEMS JUST USING THE
   DIALOGUE MANAGER. IT'S ALMOST ALWAYS NECESSARY TO WRITE A PROBLEM
   PROGRAM TO DO WHATEVER PROCESSING YOU NEED DONE, WITH THE PROGRAM
   USING THE DIALOGUE MANAGER TO DO THE SCREEN DISPLAYING, DATA
   COLLECTION, SIMPLE EDITING, ETC.

   THERE ARE A NUMBER OF ADVANTAGES TO USING DIALOGUE MANAGER:

   A. EVERY DIALOGUE RUNS UNDER TSO/ISPF, AND THEREFORE IN A REGION
      OF ITS OWN.  THIS MEANS THAT WE DON'T HAVE TO WORRY ABOUT
      ONE USER'S DIALOGUE DAMAGING ANOTHER'S ACCIDENTALLY, AND YOU DON'T
      HAVE TO WORRY ABOUT DEVELOPING YOUR DIALOGUE ON A "TEST" SYSTEM
      AND THEN HAVING IT CHECKED OUT BEFORE TRANSFER TO A "PRODUCTION"
      SYSTEM. ¬A DIALOGUE CAN'T DAMAGE ANYTHING EXCEPT ITSELF.¢

   B. PANEL LAYOUT, DESIGN, AND TESTING COULDN'T BE ANY NICER OR
      EASIER.  YOU CAN LITERALLY GO FROM CHANGING A PANEL TO SEEING
      HOW THE CHANGES LOOK IN A SECOND OR TWO, VIA THE SPLIT SCREEN
      FUNCTION.

   C. ASSUMING THAT YOU GET A LITTLE EDUCATION FIRST, AND DON'T GO
      HOG-WILD WITH ALL THE FANCY FEATURES - WHICH ARE MOSTLY NOT
      NECESSARY ANYWAY - THE REST OF DIALOGUE MANAGER IS REALLY
      FAIRLY EASY TO USE, ONCE YOU GET USED TO IT. THE IMPORTANT
      THING TO KEEP IN MIND IS THAT THERE ARE A LOT OF COMPLICATED
      UNNECESSARY FEATURES BUILT INTO IT, AND IF YOU GET TANGLED UP
      IN THESE IT CAN MAKE LIFE MISERABLE. TRYING TO LEARN IT FROM
      THE IBM MANUAL IS NOT A GOOD IDEA, BECAUSE IT TENDS TO GET
      YOU INVOLVED IN FEATURES THAT YOU DON'T NEED.

   D. THERE ARE A NUMBER OF INTERACTIVE DEBUGGING FACILITIES TO
      HELP YOU AS YOU TEST YOUR SYSTEM - INCLUDING THE ABILITY TO
      SET "BREAKPOINTS", DISPLAY VARIABLE POOLS , VIEW THE PDF
      LOG, ETC. SOME OF THESE USER AIDS ARE A LITTLE CONFUSING TO USE
      AND SOME DON'T WORK ALL THAT WELL, BUT THEY ARE AVAILABLE, AND
      BETTER THAN NOTHING.

   E. SINCE USING DIALOGUE MANAGER TO DEVELOP A SYSTEM IS VERY MUCH
      LIKE PDF, IT HAS A NATURAL "FEEL" TO IT, AND LESS TIME IS
      WASTED ADJUSTING TO A DIFFERENT WAY OF DOING THINGS.

2. THERE ARE TWO MANUALS YOU MUST HAVE:

    A. "ISPF DIALOGUE MANAGEMENT SERVICES", IBM PUBLICATION NUMBER
       SC34-2088-1.  THIS IS THE MANUAL I'LL REFER TO AS THE "REFERENCE
       MANUAL".

    B. "ISPF DIALOGUE MANAGEMENT SERVICES EXAMPLES", PUBLICATION NUMBER
       SC34-2085-1.

   IF YOU TAKE THE CSD CLASS IN DIALOGUE MANGER, YOU'LL GET BOTH THESE
   BOOKS AS PART OF THE REGISTRATION COST.  OTHERWISE YOU HAVE TO
   ORDER THEM YOURSELF DIRECTLY FROM IBM; THE COST OF THE SET IS
   SOMEWHERE AROUND $20.00.

3. ALTHOUGH THE EXAMPLES IN THE 2ND MANUAL MENTIONED IN 1.B ARE PRETTY
   RIDICULOUS WHEN YOU SEE THEM RUNNING, THE BOOK ITSELF IS VERY
   HANDY WHEN YOU NEED TO SEE HOW TO ACTUALLY CODE THE VARIOUS SERVICES
   OF DIALOGUE MANAGER.  THE LAYOUT OF THIS MANUAL CAN BE VERY CON-
   FUSING; JUST KEEP IN MIND THAT THE ENTIRE BOOK CONSISTS OF ONLY TWO
   SEPARATE EXAMPLES, BUT EACH EXAMPLE IS A COMPLETE "SYSTEM" -- I.E.
   THEY ARE SHOWING ALL THE PANELS, MESSAGES, PROGRAMS, ETC. THAT YOU
   WILL NEED.  MOREOVER, EACH EXAMPLE IS SHOWN IN EACH OF FIVE LANGUAGES -
   -COBOL, CLIST, PL/1, FORTRAN AND EXEC2.  (EXEC2 IS NOT AVAILABLE ON
   OUR SYSTEM, SO IGNORE THOSE EXAMPLES)

4. IN BOTH MANUALS, YOU'LL SEE SECTIONS ABOUT AND REFERENCES TO "DOS",
   "VSE", "VM" AND "EXEC" OR "EXEC2" - IGNORE THESE AS THEY DON'T
   APPLY TO OUR SHOP.  ONLY THE SECTIONS CONCERNING "MVS" NEED CONCERN
   YOU.

5. IT'S NOT ADVISABLE TO TRY TO USE DIALOGUE  MANAGER WITHOUT SOME
   EDUCATION FIRST.  CSD WILL OFFER CLASSES IN ITS USE, AND WILL
   PROBABLY ALSO OFFER SELF STUDY COURSES.

6. THE SECOND IBM EXAMPLE, IN FOUR OF THE FIVE LANGUAGES SHOWN IN THE
   BOOK (COBOL, PL/1, FORTRAN, AND CLIST) IS ACTUALLY RUNNING.  THIS
   EXAMPLE WAS ALSO CONVERTED TO ASSEMBLER AND IS RUNNABLE.  SEE BUZZY
   IF YOU WANT TO SEE THESE EXAMPLES RUN, OR RUN THEM YOURSELF.  WE ALSO
   HAVE THE FIRST EXAMPLE RUNNING IN CLIST.


   !t+99
                      ***** DO'S & DON'TS *****

1. ¬DON'T MIX LANGUAGES;¢ THERE IS NOTHING PHYSICALLY STOPPING A
   PERSON FROM DESIGNING A DIALOGUE THAT CONTAINS A LONG CHAIN OF
   MENUS, PANELS, INTERLEAVED WITH ASSORTED PROGRAMS WRITTEN IN PL/1,
   FORTRAN, COBOL, ASSEMBLER AND CLIST.  JUST REMEMBER THAT
   WHEN THINGS GO SOUR AND YOU END UP WITH A DUMP, THE MESS
   IS GOING TO BE COMPLICATED ENOUGH WHAT WITH BOTH TSO AND ISPF/
   DIALOGUE MANAGER IN THERE, ALONG WITH YOUR CODE.  MOREOVER,
   MULTI-LANGUAGE SYSTEMS ARE A NIGHTMARE TO MAINTAIN OR MODIFY
   FOR WHOEVER INHERITS THEM IN THE FUTURE. THE ONE EXCEPTION TO
   THIS RULE INVOLVES OPENING YOUR OWN DATASETS SUCH AS MASTERFILES,
   TRAN FILES, WORK FILES, ETC.  IF IT'S NOT POSSIBLE TO ISSUE THE
   ALLOCATE STATEMENTS FOR THESE FILES VIA A CLIST EXECUTED
   ¬BEFORE¢ YOUR DIALOGUE IS STARTED, YOU CAN CALL A SPECIAL CLIST
   OF YOUR OWN, FROM YOUR PROGRAM AS IT'S RUNNING, AND THAT CLIST
   CAN TAKE CARE OF FREEING/ALLOCATING ANY NEEDED DATASETS. THIS IS
   DONE VIA A CALL TO ISPLINK WITH THE "SELECT" OPTION.

2. IF AT ALL POSSIBLE, STICK TO THE LANGUAGE YOU ARE MOST FAMILIAR
   WITH - COBOL OR PL/1 FOR MOST PEOPLE. YOU'RE GOING TO HAVE ENOUGH
   TROUBLE LEARNING THE QUIRKS OF DIALOGUE MANAGER WITHOUT HAVING TO
   FIGHT THOSE OF A NEW LANGUAGE AT THE SAME TIME.

3. AVOID LINEAR DESIGN SEQUENCES, SUCH AS THE FOLLOWING, AS MUCH
   POSSIBLE:
     PROG1 CALLS PANEL 1 WHICH CALLS PROG 2 WHICH CALLS PANEL 2
     WHICH CALLS PROG 3 . . . . . , ETC.
     THE BEST DESIGNS ARE THOSE WITH ONE LARGE WELL DOCUMENTED
     AND SUBROUTINED CENTRAL PROGRAM THAT DISPLAYS ALL PANELS,
     AND THE PANELS ALWAYS RETURN TO THAT PROGRAM.  HOWEVER, THERE IS
     NOTHING WRONG WITH CHAINING PANELS (PANEL 1 CALLING PANEL 2,
     ETC.), AS LONG AS YOU DON'T GET TOO CARRIED AWAY WITH IT.

4. ¬DON'T DESIGN CROWDED, HYPER-COMPLICATED PANELS¢; KEEP THEM
   SIMPLE AND CLEAN.  THE MORE THAT YOUR SYSTEM LOOKS LIKE AND
   ACTS LIKE THE REST OF SPF THE BETTER.  THERE ARE SOME
   EXCELLENT COMMON SENSE SUGGESTIONS ON PANEL DESIGN IN YOUR
   REFERENCE MANUAL (SC34-2088-1) IN CHAPTER 7, UNDER THE SECTION
   TITLED "FORMATTING GUIDELINES", PAGES 190 - 192.

5. IF YOU ARE USING A PROGRAM WRITTEN IN ONE OF THE STANDARD
   LANGUAGES (COBOL, PL/1, ETC) INSTEAD OF CLIST YOU'LL ALSO HAVE TO
   USE "VDEFINE", "VREPLACE", AND "VCOPY" IN ORDER TO GET
   VARIABLES IN AND OUT OF YOUR PROGRAM.  YOU HAVE TO BE
   EXTREMELY CAREFUL WITH THESE SERVICES, PARTICULARLY "VCOPY".
   THE CRITICAL ITEM IS THE LENGTH PARAMETER; IF YOU PASS A
   LENGTH PARAMETER THAT IS TOO LONG, "ISPLINK" WILL COPY THE
   VARIABLE DATA INTO THE SECTION YOU SPECIFIED, BUT WILL OVERLAY
   OTHER UNRELATED DATA OR LOGIC IN THE PROCESS.  THIS CAN CAUSE
   SOME PRETTY NASTY DUMPS THAT WILL BE DIFFICULT TO DEBUG IN A
   HIGH LEVEL LANGUAGE.

6. IN DESIGNING PANELS ¬DON'T USE THE ")ATTR/DEFAULT" STATEMENT UNLESS
   IT IS COMPLETELY UNAVOIDABLE¢.  STICK WITH THE DEFAULTS ATTRIBUTE
   CHARACTERS - "%, +, _".  CHANGING THEIR VALUES IS JUST GOING
   TO MAKE THINGS CONFUSING FOR BOTH YOU AND ANYONE ELSE WHO HAS
   TO WORK ON YOUR SYSTEM IN THE FUTURE. THE DEFAULT VALUES ARE:
        "+" ---> PROTECTED FIELD, LOW INTENSITY
        "%" ---> PROTECTED FIELD, HIGH INTENSITY
        "_" ---> UNPROTECTED (INPUT) FIELD

7. GENERALLY YOU'LL NEED TO START YOUR DIALOGUE VIA A TSO CLIST;
   IN THIS INITIAL CLIST YOU SHOULD  ALLOCATE/DEALLOCATE
   ANY DATASETS YOUR DIALOGUE WILL BE NEEDING. HOWEVER, IT IS POSSIBLE
   TO BUILD ADDITIONAL CLISTS INTO YOUR DIALOGUE, CALLING THEM FROM
   EITHER A PANEL, OR YOUR PROGRAM. AVOID DOING THIS UNLESS YOU:

   A. NEED TO DYNAMICALLY ALLOCATE/DEALLOCATE DATASETS FOR YOUR
      DIALOGUE; CLIST IS THE ONLY WAY YOU CAN DO THIS.

   B. ARE ALREADY EXPERIENCED WITH CLISTS

   C. DON'T CARE ABOUT THE EFFICIENCY, RESPONSE TIME, OR COST.

   ¬CLISTS ARE SLOW AND INEFFICIENT¢, DUE MOSTLY TO THE FACT THAT, LIKE
   BASIC, THE CLIST PROCESSOR IS AN INTERPRETER AS OPPOSED TO A
   COMPILER.  THIS MEANS THAT EACH SOURCE STATEMENT MUST BE
   RE-TRANSLATED TO MACHINE LANGUAGE EACH AND EVERY TIME THAT
   THAT STATEMENT IS PASSED THROUGH.

   ALTHOUGH CLIST IS FAIRLY EASY TO USE - IF YOU MANAGE TO
   LIVE THROUGH THE LEARNING PROCESS - LEARNING IT ISN'T EASY
   BECAUSE THE MANUALS ARE SO POOR.  MOREOVER IT IS QUITE
   SIMILAR TO A NUMBER OF OTHER LANGUAGES IN SYNTAX (BASIC,
   PANEL LANGUAGE, PL/1), ETC, BUT THERE ARE A NUMBER OF
   ARBITRARY, UNNECESSARY SYNTACTICAL DIFFERENCES THAT MAKE
   IT VERY CONFUSING WHEN YOU'RE WORKING WITH BOTH CLIST AND A
   LANGUAGE SIMULTANEOUSLY.  FOR EXAMPLE, THE FOLLOWING
   STATEMENTS ARE EXACTLY EQUIVALENT:

     IF &NAME = THEN DO    (CLIST - BLANK IS IMPLIED)

     IF (&NAME = ' ')      (PANEL LANGUAGE - BLANK IS EXPLICIT)

     IF NAME = ' '         (PL/1 - BLANK IS EXPLICIT)

8. SINCE THERE ARE NO RESTRICTIONS AS TO WHAT TYPE OF FUNCTION
   IS AT THE HEAD OF A DIALOGUE, (YOU CAN MAKE THE FIRST ITEM
   TO GET CONTROL IN YOUR DIALOGUE A MENU, PANEL, PROGRAM, OR
   CLIST), AND SINCE PDF ITSELF ALWAYS BEGINS WITH A MENU PANEL
   (WITH GOOD REASON), YOU'LL FIND THAT MOST OF THE IBM EXAMPLES
   ALWAYS START WITH A MENU THAT CALLS A PROGRAM THAT CALLS
   PANELS, ETC.  THIS IS NOT ALWAYS A GOOD IDEA.  JUST REMEMBER
   THAT EACH TIME YOUR USER WORKS HIS WAY BACK AND FORTH BETWEEN
   THAT MENU AND THE PANELS, THE SYSTEM HAS TO GO THROUGH A LOT
   OF OVER-HEAD IN RE-LOADING AND TERMINATING THE PROGRAM.
   SOMETIMES IT IS BETTER TO BEGIN WITH A PROGRAM, AND HAVE IT
   ALTERNATELY DISPLAY THE MAIN MENU AND THE WORKING PANELS.  AS A
   GENERAL RULE, IF YOUR DIALOGUE IS LARGE AND COMPLICATED, SUCH
   THAT YOU DON'T WANT TO WRITE ONE MONSTER PROGRAM TO DO ALL THE
   WORK, THEN DESIGN BY THE IBM METHOD - THE TOP OF THE CHAIN BEING
   A MENU, WITH EACH MENU CHOICE CALLING A DIFFERENT PROGRAM, WHICH
   IN TURN DISPLAYS ITS OWN PANELS.  ON THE OTHER HAND, IF ALL YOUR
   PROCESSING CAN BE BUILT INTO ONE REASONABLY SIZED PROGRAM, THEN
   MAKE THAT PROGRAM THE STARTING POINT IN YOUR DIALOGUE AND HAVE IT
   DISPLAY BOTH THE MAIN MENU AND PANELS.

9. BE SURE TO PICK A CLEAR, MEANINGFUL, NAMING CONVENTION FOR YOUR
   DIALOGUE, AND FOLLOW IT FOR EVERYTHING - PANELS, PROGRAMS,
   MESSAGES, CLISTS, SKELETONS, ETC.  WHEN YOU CHOOSE ONE, KEEP IN
   MIND THE RESTRICTIONS ON MESSAGE IDS AND MESSAGE LIBRARY MEMBER
   NAMES. FOR EXAMPLE, THE PANVALET FUNCTION IN PDF (FUNCTION 8)
   HAS ALL OF ITS FUNCTIONS NAMED WITH A PREFIX OF "PANPDF".

10. ¬DON'T CLUTTER UP THE PROFILE DATASET¢. THE MORE VARIABLES THAT
   PROGRAMMERS "VPUT" INTO A USER'S PROFILE, THE MESSIER THINGS ARE
   GOING TO GET.  MOREOVER, VARIABLES WILL STAY IN A PROFILE  FOREVER
   - OLD UNUSED VARIABLES WILL NOT BE CLEANED OUT AUTOMATICALLY, AND
   THERE IS NO IBM UTILITY TO DELETE THEM. SO, DON'T USE THE PROFILE
   DATSET AS  CASUAL CATCH-ALL.  THE PROPER USE FOR IT IS TO SAVE
   CRITICAL INFORMATION, SO THAT IT CAN BE CARRIED ACROSS FROM THE
   END OF ONE SESSION TO THE BEGINNING OF THE NEXT.  REMEMBER THAT
   EACH USER OF YOUR APPLICATION MAY POSSIBLY BE USING OTHER
   DIALOGUE MANAGER APPLICATIONS, AND IF YOU AND THE PROGRAMMER THAT
   DEVELOPED THE OTHER DIALOGUE BOTH HAPPEN TO PICK THE SAME NAME FOR
   A VARIABLE AND BOTH DO A VPUT TO THE PROFILE DATASET, THE TWO OF
   YOU ARE GOING TO TAKE TURNS WIPING OUT EACH OTHER'S VALUE IN THAT
   PARTICULAR USER'S PROFILE. THAT MEANS YOU HAD BEST BE VERY CAREFUL
   TO PICK UNIQUE NAMES FOR ANY VARIABLES THAT YOU INTEND TO VPUT
   INTO THE PROFILE DATASET. PROBABLY THE BEST METHOD IS TO EMBED
   SOMETHING LIKE AGENCY NUMBER IN YOUR VARIABLE NAME TO MAKE IT
   UNIQUE.

11. WHEN YOU USE THE VARIOUS FUNCTIONS OF ISPLINK, STICK TO THE
   SIMPLE STRAIGHT-FORWARD OPTIONS - I.E. "MOVE" MODE, "CHARACTER"
   MODE, ETC. MOVE MODE WORKS WITH VARIABLES DIRECTLY IN THE STORAGE
   OF YOUR PROGRAM, USING THE FIELD NAMES THAT YOU HAVE CHOSEN.
   "LOCATE" MODE BYPASSES THE NAMES AND MERELY PROVIDES YOU WITH
   THE ¬ADDRESSES¢ OF THE VARIABLES, AND IS BOUND TO BE MORE
   COMPLICATED IN A HIGH LEVEL LANGUAGE. CHARACTER MODE TRANSFERS
   ALL DATA STRICTLY AS EBCIDIC CHARACTERS, AND ONCE THE DATA IS
   IN YOUR STORAGE YOU CAN CONVERT IT AS YOU NORMALLY DO FOR YOUR
   LANGUAGE - I.E. TO BINARY, PACKED DECIMAL, FLOATING POINT, ETC.
   SINCE YOU'RE ALREADY FAMILIAR WITH CONVERSION IN THE HIGH LEVEL
   LANGUAGE YOU USE, USING CHARACTER WILL AVOID ALL THE COMPLICATIONS
   AND THE LEARNING CURVE ASSOCIATED WITH HAVING ISPLINK DO THE
   CONVERSIONS AND TRYING TO GET YOUR PROGRAM FIELDS DEFINED PROPERLY
   TO MATCH. MOREOVER, THE CONVERSION HAS TO BE DONE EITHER WAY, AND I
   DOUBT THAT THERE WILL BE ANY DIFFERENCE IN OVERALL EFFICIENCY.

12. WHEN ALLOCATING YOUR PANEL, MESSAGE, SKELETON, AND CLIST LIBRARIES
   MAKE THE RECORD LENGTH 80 AND THE BLOCK SIZE 6160. THE BLOCK SIZE
   IS IMPORTANT AS YOUR LIBRARIES WILL BE THE FIRST IN A CONCATENATION
   STRING FOR EACH SPF DD STATEMENT, AND MUST THE THE LARGEST FOR
   PURPOSES OF BUFFER ALLOCATION.
   !t+99
              ********* PANEL DESIGN *********

1. ¬PANELS CAN BE BUILT AND SAVED VIA NORMAL PDF EDIT AND SAVE USING
   ANY 80 BYTE LIBRARY¢. YOU COULD BUILD THEM IN YOUR TSO LIB AND THEN
   COPY THEM INTO YOUR PANEL LIBRARY LATER, BUT IT IS BETTER TO
   BUILD THEM DIRECTLY INTO YOUR PANEL LIBRARY IN THE FIRST PLACE.

2. FUNCTION 7.2 IS DESIGNED TO CHECK INDIVIDUAL PANELS FOR ERRORS
   ¬WITHOUT ACTUALLY GOING ON TO EXECUTE ANY OF THE ASSOCIATED PROGRAMS
   OR CLISTS¢. ALTHOUGH BUILDING PANELS IS EASY, THE ERROR DIAGNOSTICS
   IN 7.2 ARE WORTHLESS, WHEN YOU DO MAKE A MISTAKE. LUCKILY, THE
   POSSIBLE MISTAKES ARE QUITE LIMITED; FOLLOWING ARE THE MAJOR ONES:

     A. ¬COLUMNS 73 - 80 MUST BE BLANK ON ANY SORT OF COMMAND IN PANEL
        LANGUAGE¢ - E.G. ")INIT", ")VER", ETC. SINCE THESE COLUMNS DO
        NOT DISPLAY DURING EDIT UNLESS YOU SHIFT THE SCREEN RIGHT,
        THE MISTAKE ISN'T EASILY SEEN. THE EASIEST WAY TO GET INTO
        THIS SITUATION, WITHOUT REALIZING IT, IS BY HAVING "NUM ON"
        IN YOUR PROFILE, CAUSING TSO LINE NUMBERS TO BE AUTOMATICALLY
        BUILT IN 73-80. THIS ONLY APPLIES TO PANEL LANGUAGE COMMANDS -
        WHICH ARE NOT VISIBLE WHEN THE PANEL IS USED. IT IS OK
        TO USE 73-80 ON DISPLAYABLE PANEL LINES.

     B. ¬A PANEL CANNOT BE LONGER THAN THE LENGTH OF YOUR PHYSICAL
        SCREEN, VERTICALLY¢. DON'T GET THE IDEA THAT YOU CAN BUILD LONG
        PANELS, AND THEN USE THE SCROLL KEY TO DISPLAY THE BOTTOM HALF
        DURING EXECUTION - THIS ISN'T ALLOWED. YOU'LL JUST HAVE
        TO BREAK THE LARGE PANEL UP INTO SMALLER ONES, CHAINING THEM
        TOGETHER.

     C. THE ")" IN PANEL LANGUAGE COMMANDS MUST START IN POSITION
        1: OTHERWISE YOU'LL EITHER END UP WITH ONE OF THE MYSTERY ERROR
        MESSAGES, OR IT WILL TREAT THE COMMAND AS DISPLAYABLE DATA.

     D. A FIELD OF ANY TYPE (INPUT, OUTPUT-PROTECTED, ETC) HAS A
        SPECIAL SYMBOL TO MARK ITS START - E.G. "+,%,_". ¬HOWEVER
        THERE IS NO SPECIAL SYMBOL TO MARK THE END OF THE FIELD¢;
        THE THING THAT TERMINATES A FIELD IS THE SPECIAL SYMBOL
        MARKING THE START OF THE NEXT FIELD. THIS CAN PARTICULARLY
        CAUSE TROUBLE ON INPUT FIELDS, SO MAKE SURE YOU EXPLICITLY
        TERMINATE THEM. FOR EXAMPLE:  "_INPUTFLD+" WHERE THE "+"
        TERMINATES AND SETS THE LENGTH OF THE VARIABLE "INPUTFLD"
        TO 8 POSITIONS - NEITHER THE "_" NOR THE "+" COUNT.

     E. THE LENGTH OF THE VARIABLE ASSOCIATED WITH AN INPUT FIELD IS
        AUTOMATICALLY SET TO MATCH THE LENGTH OF THE NAME. IN THE
        EXAMPLE ABOVE, THE LENGTH OF "INPUTFLD" IS 8 CHARACTERS,
        AND IF A USER WERE TO TYPE INTO THIS FIELD IN A RUNNING
        DIALOGUE, THEY WOULD BE ABLE TO ENTER A FULL 8 CHARACTERS.
        THIS CAN CAUSE INCONVENIENCE, AS IT IS A GOOD IDEA TO
        PICK NAMES FOR INPUT VARIABLES THAT ARE LONG ENOUGH TO BE
        DESCRIPTIVE, EVEN WHEN THE LENGTH YOU WANT FOR THE VARIABLE
        ITSELF IS MUCH SHORTER. THERE ISN'T ANY CLEAN WAY AROUND
        THIS PROBLEM, THAT I'VE FOUND YET, ANYWAY. ONE METHOD IS TO
        PASS THE TOO-LONG VARIABLE THROUGH TO THE PROGRAM, AND EDIT
        IT FOR LENGTH THERE, LETTING THE PROGRAM RE-DISPLAY THE
        PANEL WITH AN ERROR MESSAGE IF THE FIELD IS TOO LONG. A BETTER
        METHOD, IS TO USE AN INPUT VARIABLE OF THE RIGHT LENGTH BUT
        WITH A MEANINGLESS NAME, AND THEN TRANSFER ITS VALUE TO
        ANOTHER VARIABLE WITH A MEANINGFUL NAME IN THE ")PROC"
        SECTION, AS IN THE FOLLOWING EXAMPLE:

        .
        .
        +MAN NUMBER:_ABCD+          (ENTER 4 DIGIT MAN #)
        .
        .
        )PROC
        &CSDMAN# = &ABCD
        .
        .

     F. FAILING TO INDENT PROPERLY WHEN USING USING THE "IF"
        COMMAND IN PANEL LANGUAGE WILL CAUSE A LOGIC ERROR.
        REMEMBER THERE IS NO "END" ASSOCIATED WITH "IF",
        LIKE THERE IS IN CLIST OR PL/1. THE WAY THAT THE "IF" COMMAND
        WORKS IS AS FOLLOWS: IF THE CONDITION SPECIFIED IN THE "IF"
        COMMAND IS MET, THEN THE SYSTEM WILL  EXECUTE ANY IMMEDIATELY
        FOLLOWING STATEMENTS THAT ARE INDENTED ONE OR MORE POSITIONS
        TO THE RIGHT OF THE "I" IN THE "IF". OTHERWISE, IT WILL SKIP
        ALL THE INDENTED STATEMENTS AND EXECUTE THE NEXT STATEMENT IT
        CAN FIND THAT BEGINS IN THE SAME COLUMN AS THE "I", OR TO THE
        LEFT OF IT.
             THE "IF" INDENTATION PROBLEM IS ESSENTIALLY EXTREMELY
        POOR DESIGN, BUT THERE IS NOTHING WE CAN DO TO CORRECT IT;
        YOU'LL JUST HAVE TO LIVE WITH IT.

     G. FAILING TO PUT YOUR CONDITION IN PARENTHESES - THEY ARE NOT
        OPTIONAL. FOR EXAMPLE:

        IF (&FIELD = 'A')





   !t+99
                      ***** POOLS *****

     ¬PROBABLY THE MOST IMPORTANT OF THE UNIQUE IDEAS IN DIALOGUE
MANAGER IS THAT OF "VARIABLE POOLS"¢. A POOL IS SIMPLY A MEANS OF
GETTING DATA FROM ONE FUNCTION (PANEL, MENU, PROGRAM OR CLIST) OF
A DIALOGUE TO ANOTHER, WITHOUT GETTING INVOLVED IN "SENDING"
DATA BACK AND FORTH BETWEEN FUNCTIONS, WHICH WOULD INVOLVE SOME
SORT OF ADDRESSING SCHEME; THAT WOULD, IN TURN, COMPLICATE THINGS WHEN
IT CAME TIME TO ADD OR MODIFY FUNCTIONS.  THERE ARE 3+ TYPES OF POOLS
YOU CAN USE:

     1. THE LOWEST LEVEL IS THE "FUNCTION POOL" WHICH COMES IN TWO
        TYPES; HOWEVER, THE DISTINCTION IS KIND OF SILLY AS YOU
        HANDLE THE TWO IDENTICALLY.  THE FIRST TYPE IS THE "IMPLICIT
        FUNCTION POOL"; ONE OF THESE WILL BE BUILT AUTOMATICALLY FOR
        EACH AND EVERY FUNCTION (PANEL, MENU, PROGRAM OR CLIST) IN
        YOUR "DIALOGUE", AND WILL CONTAIN THE NAMES AND CONTENTS OF
        EVERY VARIABLE IN THAT FUNCTION.  THE "EXPLICIT FUNCTION
        POOL" APPLIES ONLY TO FUNCTIONS THAT ARE PROGRAMS (COBOL,
        FORTRAN, PL/1, OR ASSEMBLER) AND IS CREATED ONLY WHEN THE
        PROGRAM DOES ONE OR MORE "VDEFINES". A PROGRAM CAN HAVE
        BOTH TYPES SIMULTANEOUSLY. AS LONG AS A VARIABLE REMAINS
        ONLY IN A PARTICULAR FUNCTION POOL, ONLY THAT FUNCTION
        CAN USE IT. "VPUT" AND "VGET" ARE USED TO COPY VARIABLES
        AND THEIR VALUES FROM POOL TO POOL.

     2. THE NEXT LEVEL IS THE "SHARED VARIABLE POOL". THERE IS JUST
        ONE OF THESE FOR YOUR ENTIRE SYSTEM OR "DIALOGUE", AND AS
        THE NAME IMPLIES ANY FUNCTION CAN GET AT ANY VARIABLE IN IT,
        BUT NOT DIRECTLY.  VARIABLES GET INTO THE SHARED POOL WHEN
        ANY PARTICULAR FUNCTION ISSUES A "VPUT" TO COPY ONE OR
        MORE OF ITS FUNCTION POOL VARIABLES (AND THEIR RESPECTIVE
        CONTENTS) TO THE SHARED POOL. SO, VARIABLES GET THERE
        ¬ONLY WHEN THE FUNCTION THAT ORIGINALLY OWNED THEM PUTS
        THEM THERE¢.  ANYTHING IN THE SHARED POOL CAN BE ACCESSED
        BY ANY OTHER FUNCTION, BUT THE FUNCTION THAT WANTS IT MUST
        SPECIFICALLY ASK FOR THOSE VARIABLES BY NAME BY ISSUING
        A "VGET", WHICH COPIES THE REQUESTED VARIABLES/CONTENTS TO
        THAT FUNCTION'S (AND ONLY THAT FUNCTION'S) FUNCTION POOL.
        ONE PARTIAL EXCEPTION TO THE ABOVE IS FOR MENUS AND PANELS.
        ANYTHING IN THE SHARED POOL IS AUTOMATICALLY COPIED TO ALL
        OF THE INDIVIDUAL FUNCTION POOLS FOR ALL MENUS AND PANELS.
        HOWEVER, THE OPPOSITE DOES NOT HOLD TRUE; A MENU/PANEL HAS
        TO ISSUE A "VPUT" TO PUT THINGS INTO THE SHARED POOL; THEY
        WILL NOT TRANSFER AUTOMATICALLY IN THAT DIRECTION.

     3. THE LAST TYPE OF VARIABLE POOL IS THE "PROFILE POOL". THIS
        POOL IS BUILT FROM ALL THE VARIABLES AND THEIR ASSOCIATED
        DATA EXTRACTED FROM THE "PROFILE" OF THE USER WHO HAS
        ACTUALLY SIGNED ON TO YOUR DIALOGUE AT THE TIME IT RUNS.
        CONVERSELY, WHEN THE USER ENDS YOUR DIALOGUE, HIS PROFILE
        IS REWRITTEN WITH ALL THE OLD (AND POSSIBLY SOME NEW)
        VARIABLES AND THEIR CONTENTS THAT EXIST IN THE PROFILE
        POOL AT THAT TIME. VARIABLES CAN BE COPIED BACK AND FORTH
        BETWEEN THE PROFILE POOL AND THE SHARED POOL USING VGET
        AND VPUT. THEY CAN'T BE COPIED DIRECTLY TO OR FROM A FUNCTION
        POOL HOWEVER; YOU HAVE TO DO THAT INDIRECTLY VIA THE SHARED
        POOL, AND TWO SETS OF VPUTS OR VGETS.

     4. THAT TAKES CARE OF THE POOLS, AND IF YOU'RE USING A TSO CLIST
        TO DO YOUR PROCESSING THAT'S AS FAR AS YOU NEED TO GO.
        DUE TO THE FACT THAT A CLIST IS NOT COMPILED (AS IS ANY
        NORMAL PROGRAM), BUT RATHER IS INTERPRETED INTERACTIVELY,
        A CLIST CAN CREATE, GET AT, AND CHANGE ANY VARIABLE IN ITS
        FUNCTION POOL MERELY BY USING IT. THIS IS DEFINITELY NOT
        TRUE FOR ANY OTHER TYPE OF PROGRAM - ASSEMBLER, COBOL,
        PL/1 OR FORTRAN.  ¬FOR THESE YOU MUST GO THROUGH AN EXTRA
        STEP, IN ADDITION TO THE ABOVE, IN ORDER TO ACCESS
        DIRECTLY (CHANGE THE VALUE OF) ONE OR MORE VARIABLES¢. THE
        COMMANDS THAT YOU MUST ISSUE IN YOUR PROGRAMS AND WHAT THEY
        DO ARE AS FOLLOWS:

        A. "VDEFINE" BUILDS A ¬BRAND NEW VARIABLE¢ AND SETS ITS INITIAL
           VALUE, IN ITS CORRESPONDING FUNCTION POOL. IT GETS THE VALUE
           TO USE FROM WHATEVER YOU INITIALIZED THE FIELD TO BE IN YOUR
           PROGRAM, AND YOU EFFECTIVELY PASS THE ADDRESS OF THIS FIELD
           AS ONE OF THE PARAMETERS WHEN YOU INVOKE "VDEFINE". THIS
           SERVICE MOVES DATA IN AN OUTWARD DIRECTION - I.E. FROM YOUR
           PROGRAM TO THE FUNCTION POOL.

        B. "VCOPY" COPIES AN ¬OLD¢ (PRE-EXISTING) VARIABLE'S CONTENTS
           OR VALUE FROM THE CORRESPONDING FUNCTION POOL INTO A
           SPOT IN YOUR PROGRAM THAT YOU HAVE DESIGNATED, USING THE
           LENGTH YOU FURNISHED. DATA IS MOVED IN AN INWARD DIRECTION
           - I.E. FROM THE FUNCTION POOL TO YOUR PROGRAM.

        C. "VREPLACE" CHANGES THE VALUE OF AN ¬OLD VARIABLE¢ IN THE
           CORRESPONDING FUNCTION POOL, TO A NEW VALUE THAT YOU
           HAVE SET IN THE DESIGNATED FIELD OF YOUR PROGRAM.
           IN OTHER WORDS IT COPIES THE DATA YOU'VE GOT IN ONE OF
           YOUR PROGRAMS FIELDS INTO ONE OF THE VARIABLES IN THE
           FUNCTION POOL. VREPLACE MOVES DATA IN AN OUTWARD
           DIRECTION - FROM THE PROGRAM TO THE FUNCTION POOL.





   !t+99
                     ***** ISPLINK & ISPEXEC *****

ANY TIME YOU WANT TO USE ANY SERVICE PROVIDED BY THE
DIALOGUE MANAGER, YOU MUST REQUEST IT IN A SPECIAL WAY.  THERE ARE
MANY SERVICES AVAILABLE (SEE CHAPTER 6 OF YOUR REFERENCE MANUAL);
TYPICAL ONES WOULD BE:

   "VPUT"
   "VGET"
   "VDEFINE"
   "CONTROL"
   "EDIT"

THESE SERVICES ARE THE ONLY MEANS OF CONTROLLING THE MOVEMENT OF YOUR
VARIABLES BETWEEN POOLS, DEFINING NEW VARIABLES, ETC.  THE WAY THE
SERVICES ARE INVOKED DIFFERS DEPENDING ON THE LANGUAGE YOU'RE
USING:

1. FOR TSO CLIST YOU MUST USE THE KEYWORD "ISPEXEC" FOLLOWED BY
   THE NAME OF THE SERVICE YOU WANT (E.G. "VPUT", "SELECT", ETC).
   FOLLOWING THAT YOU MUST SPECIFY ALL THE REQUIRED AND OPTIONAL
   PARAMETERS PECULIAR TO THAT PARTICULAR SERVICE.

2. FOR ALL OTHER LANGUAGES (ASSEMBLER, PL/1, COBOL, FORTRAN), YOU
   CANNOT USE "ISPEXEC" OR ANY OTHER KEYWORD; YOU MUST ISSUE A STANDARD
   "CALL" WITHIN YOUR PROGRAM TO A MODULE (PROGRAM) WHOSE NAME
   IS "ISPLINK".  WHEN YOU ISSUE THE CALL YOU HAVE TO PROVIDE
   A PARAMETER LIST CONTAINING THE NAME OF THE SERVICE DESIRED
   ALONG WITH VARIOUS OTHER PARAMETERS REQUIRED FOR THAT PAR-
   TICULAR SERVICE.  ALTHOUGH THE PHRASE "CALL" IS IDENTICAL IN ALL
   FOUR LANGUAGES, THE SYTAX NECESSARY TO POINT TO THE PARM LIST
   VARIES. - SEE THE FOLLOWING SECTION "SAMPLE USAGE OF ISPLINK
   & ISPEXEC".

3. FOR THOSE SERVICES THEY DO HAVE IN COMMON, (WHICH IS MOST OF THEM)
   ISPEXEC AND A CALL TO ISPLINK DO EXACTLY THE SAME THING.  THE
   REASON THAT NOT EVERY SERVICE IS COMMON TO BOTH IS SIMPLY
   BECAUSE CERTAIN SERVICES WILL BE PERFORMED AUTOMATICALLY BY
   CLIST, SO THAT THERE IS NO NEED TO USE ISPEXEC FOR THESE.
   EXAMPLES OF SERVICES NOT NECESSARY ARE: "VDEFINE", "VCOPY",
   AND "VREPLACE". MOREOVER, THEY ARE NOT ONLY UNNECESSARY, THEY
   ARE ILLEGAL.

4. WHEN YOU COMPILE YOUR SOURCE CODE, YOU MUST PROVIDE A DD
   STATEMENT, OR DSN VIA SYMBOLIC SUBSTITUTION, SO THAT THE LINKAGE
   EDITOR CAN INCLUDE THE NECESSARY INTERFACE MODULE TO ISPLINK.
   SEE "SAMPLE JCL FOR COMPILING".



   !t+99
                    ***** TESTING & PRODUCTION *****

1. FOR EITHER TESTING OR PRODUCTION YOU'RE GOING TO NEED A NUMBER
   OF LIBRARIES TO PUT YOUR PANELS, PROGRAMS AND MESSAGES IN.  YOU
   WILL NOT BE ALLOWED TO PUT YOUR THINGS INTO THE CSD ISPF/PDF PRODUC-
   TION LIBRARIES.  SO, IT WILL BE NECESSARY TO GO THROUGH A SERIES OF
   "FREE/ALLOCATE" STEPS IN ORDER TO CONCATENATE YOUR LIBRARIES TO
   THE CSD SPF/PDF LIBRARIES.  THIS CAN BE DONE VIA A TSO CLIST AND
   COULD EVEN BE HANDLED AUTOMATICALLY FOR YOU OR YOUR USER IF YOU
   NAME THE CLIST "@LOGON".  WE HAVE PROVIDED A SUB-FUNCTION UNDER
   "CSD UTILITIES" ON THE PDF PRIMARY OPTION MENU THAT WILL BUILD A
   CLIST FOR YOU.

   THE EASIEST WAY TO TEST AND DEVELOP A NEW DIALOGUE IS VIA PDF
   FUNCTION 7.1 WHICH WILL RUN AN ENTIRE DIALOGUE, INCLUDING ALL THE
   PANELS, PROGRAMS, ETC.  (FUNCTION 7.2 CAN BE USED TO DISPLAY ONLY
   INDIVIDUAL PANELS, BOTH TO CHECK FOR ERRORS AND TO EXAMINE THEM
   FOR APPEARANCE). REMEMBER, THOUGH, THE ERROR MESSAGES YOU GET ARE
   EXTREMELY POOR - YOU'D BETTER KNOW WHAT YOU'RE DOING.

   ONE OF THE NICEST PARTS OF DE-BUGGING A DIALOGUE IS THE ABILITY
   TO USE SPLIT SCREEN UNDER PDF.  FOR EXAMPLE, ON THE TOP SCREEN
   YOU CAN CHOOSE 7.1 AND RUN YOUR DIALOGUE UNTIL YOU REACH THE
   PANEL YOU'RE INTERESTED IN FIXING.  AT THIS POINT YOU CAN SWITCH
   TO THE LOWER SCREEN, EDIT THAT SAME PANEL, MAKE YOUR CHANGES, AND
   SAVE THEM.  NOW SWITCH BACK TO THE TOP HALF, PRESS "END" ONCE AND
   THEN "ENTER" TO SEE THE NEWLY MODIFIED PANEL.  SWITCHING BACK AND
   FORTH LIKE THIS MAKES PANEL DESIGN EXTREMELY CONVENIENT.

   WHEN YOU'RE READY TO PUT YOUR DIALOGUE INTO PRODUCTION YOU HAVE
   TWO MAIN THINGS TO WORRRY ABOUT:

   A.  GETTING ALL YOUR LIBRARIES ALLOCATED; THIS CAN BE DONE EXACTLY
       AS OUTLINED FOR TEST ABOVE. YOU'LL ALSO NEED TO DO ALLOCATES
       FOR ANY OF YOUR OWN DATASETS - MASTERFILES REQUIRED BY YOUR
       SYSTEM, WORK FILES, ETC.

   B.  SINCE YOU WILL NOT BE ALLOWED TO ADD YOUR DIALOGUE AS AN OPTION
       ON THE MAIN SPF/PDF PANEL, YOU'RE GOING TO HAVE TO HAVE SOME
       SMOOTH SIMPLE MEANS FOR YOUR USER TO GET INTO YOUR DIALOGUE.
       TECHNICALLY THERE IS NO REASON WHY YOU CAN'T USE 7.1 FOR
       PRODUCTION, AND YOU ARE FREE TO DO SO IF YOU LIKE, BUT IT'S NOT
       REAL TIDY.  A BETTER METHOD IS TO ENTER YOUR DIALOGUE DIRECTLY
       FROM TSO, SKIPPING THE ISPF/PDF PRIMARY OPTION MENU ALTOGETHER.
       SINCE YOU ARE PROBABLY GOING TO NEED TO ALLOCATE DATASETS ANYWAY,
       THE USER WILL ENTER THE NAME OF YOUR CLIST AFTER THE TSO READY
       PROMPT, AND YOU CAN ISSUE THE ISPSTART WITHIN THAT CLIST.
       FOLLOWING ARE THE THREE FORMS OF ISPSTART:

       ISPSTART PANEL(PANLNAME)
              - OR -
       ISPSTART CMD(CLISTNM)
              - OR -
       ISPSTART PGM(PROGNAME)

       (DEPENDING ON WHETHER YOUR DIALOGUE BEGINS WITH A MENU/
       PANEL, CLIST, OR PROGRAM)



       YOU CAN ALSO PASS A PARM IF YOU LIKE:

       ISPSTART PGM(PGMNAME) PARM(XX......XX)

     THIS "ISPSTART" BUSINESS IS SORT OF A BACK DOOR INTO ISPF, AND
DOES NOT GO THROUGH THE NORMAL MENUS YOU'RE USED TO SEEING - WHICH ARE
REALLY A PART OF PDF ANYWAY. FOR PRODUCTION PURPOSES, YOU MIGHT
COMBINE ALL OF THE FREE AND ALLOCATE STATEMENTS NECESSARY ALONG WITH
THE CALL TO ISPSTART INTO ONE CLIST. LET'S SAY YOU NAME YOUR CLIST
"PRODJOB"; THEN ALL YOUR USER WOULD HAVE TO DO IS TYPE "%PRODJOB"
IMMEDIATELY AFTER THE TSO "READY" PROMPT, AND THE NEXT THING HE WOULD
SEE WOULD BE YOUR FIRST PANEL OR MENU.  IF YOU NAME THIS PARTICULAR
CLIST "@LOGON", THEN HE WOULDN'T HAVE TO TYPE ANYTHING; JUST LOGGING
ON WOULD TAKE HIM STRAIGHT INTO YOUR DIALOGUE.  JUST REMEMBER THOUGH
IF YOU USE THE "@LOGON" METHOD, THE USER WON'T BE ABLE TO DO ANYTHING
ELSE BUT YOUR DIALOGUE.  YOU MAY GET INTO A SITUATION WHERE YOU NEED
TO COMBINE BOTH IDEAS - FOR EXAMPLE YOU MIGHT NEED TO USE "@LOGON"
TO FREE AND REALLOCATE THE CLIST LIBRARY, SO THAT WHEN THE USER
TYPES IN "%PRODJOB" THE SYSTEM GETS "PRODJOB" FROM YOUR SPECIAL
CLIST LIBRARY.


   !t+99
                    ***** FILE TAILORING *****

"FILE TAILORING" IS A SPECIAL FATURE OF THE DIALOGUE MANAGER
THAT YOU MOST LIKELY WILL NOT HAVE ANY USE FOR.  THE REASON IT
EVEN EXISTS IS BECAUSE PDF NEEDS AND USES IT, AND APPARENTLY IBM
DECIDED THAT AS LONG AS IT WAS NECESSARY FOR PDF, THEY MIGHT JUST
AS WELL DESIGN IT IN SUCH A WAY THAT IT COULD BE USED AS A FEATURE
OF DIALOGUE MANAGER.

¬THE MAIN PURPOSE OF FILE TAILORING IS TO ALLOW DYNAMIC BUILDING OF
JCL STREAMS¢.  IN OPERATION IT IS VERY SIMILAR TO THE ASSEMBLER
MACRO PROCESSOR.

YOU HAVE TO START OUT WITH WHAT IS CALLED A "SKELETON FILE" WHICH
MUST BE A MEMBER OF A SPECIAL "SKELTON LIBRARY".  THE MEMBER WILL
CONTAIN A NUMBER OF JCL STATEMENTS THAT DON'T LOOK QUITE RIGHT,
SINCE ANY POSITION THAT WOULD NORMALLY CONTAIN A JCL
PARAMETER MIGHT CONTAIN A SYMBOLIC VARIABLE INSTEAD.  FOR EXAMPLE:

   //&DDNAME  DD  SYSOUT=&CLASS

WOULD BE A VALID JCL PROTOTYPE STATEMENT IN A SKELETON FILE.
"&DDNAME" AND "&CLASS" ARE BOTH VARIABLES THAT WILL BE SUBSTITUTED
TO SOME FINAL VALUE.  THE SUBSTITUTION WILL BE DONE FROM ANY
CORRESPONDING VARIABLES FOUND IN THE VARIABLE POOLS.  THESE ARE
THE SAME POOLS THAT YOU WOULD BE USING TO DISPLAY PANELS, ETC.
THIS PART OF FILE TAILORING IS VERY SIMILAR TO THE SYMBOLIC
SUBSTITUTION PROCESS THAT YOU'RE USED TO USING WHEN YOU BUILD
"PROCS" FOR BATCH JOBS.

THE SECOND PART OF FILE TAILORING IS A CONDITIONAL PROCESS - A
SORT OF PICK AND CHOOSE DEPENDING ON THE VALUE OF A VARIABLE YOU
HAVE CHOSEN.  THE BASIC IDEA IS THAT YOU INCLUDE A LOT OF EXTRA JCL
PROTOTYPE STATEMENTS IN YOUR SKELETON FILE (MEMBER) AND THEN
DYNAMICALLY CHOOSE WHICH PROTOTYPE STATEMENT (OR GROUP OF STATEMENTS)
YOU WANT TO USE, DEPENDING ON THE VALUE OF ONE OF YOUR VARIABLES.

IN ORDER TO CONTROL THIS PROCESS THERE IS NATURALLY GOING TO BE
ANOTHER "LANGUAGE" TO LEARN, WHICH I'LL CALL "SKELETON LANGUAGE".
IT'S PRETTY SIMPLE:

   ")SEL XXXXX" MARKS THE START OF A JCL PROTOTYPE STATEMENT OR
   GROUP OF STATEMENTS FOR POSSIBLE INCLUSION OR EXCLUSION.  THE
   "XXXXX" REPRESENTS SOME SORT OF LOGICAL OPERATION THAT
   DETERMINES WHETHER OR NOT THAT GROUP IS TO BE "SELECTED".

   ")ENDSEL" SIMPLY MARKS THE END OF A "SELECT" GROUP.

   ")CM" IS USED FOR COMMENTS.

   ")IM XXXXXXXX" STANDS FOR "IMBED" AND ALLOWS YOU TO INCLUDE,
   OR COPY INTO THAT SPOT, AN ENTIRELY DIFFERENT MEMBER FROM YOUR
   SKELETON LIBRARY, WITH A MEMBER NAME OF "XXXXXXXX".  THIS
   INCLUDED MEMBER COULD BE READY TO GO JCL, OR IT MIGHT REQUIRE
   SOME MORE SELECTION AND VARIABLE SUBSTITUTION PROCESSING.

HERE'S A SHORT EXAMPLE; LET'S SAY YOU WANT TO BUILD A JCL STREAM
OF SOME SORT, AND DEPENDING ON THE CHOICES YOUR USER MAKES ON A
PANEL YOU MAY NEED TO INCLUDE AN EXTRA STEP TO DELETE A DATASET:
   .
   .
   )SEL &DELETE = YES
   // EXEC PGM=IEFBR14
   //DD1 DD DSN=&USERDSN,DISP=(OLD,DELETE)
   )ENDSEL
   .
   .

THE TWO JCL STATEMENTS ARE INCLUDED IN THE FINAL PRODUCT ONLY IF
THE VARIABLE "&DELETE" EXISTS IN ONE OF THE POOLS AND HAS A VALUE
OF "YES".  "&USERDSN" WILL BE SUBSTITUTED TO WHATEVER VALUE IT
HAS IN WHICHEVER POOL IT IS LOCATED IN.

THE FINAL OUTPUT FROM THE FILE TAILORING PROCESS WILL BE WRITTEN
TO THE "FILE TAILORING OUTPUT LIBRARY"; FROM THERE IT CAN BE
SUBMITTED AS A JOB, EITHER MANUALLY, OR AUTOMATICALLY VIA A
SUBMIT COMMAND IN A TSO CLIST.

THERE IS NOTHING SAYING YOU HAVE TO LIMIT FILE TAILORING TO BUILD TO
JCL; YOU COULD PUT MOST ANY KIND OF STATEMENTS YOU LIKE IN A
SKELETON LIBRARY MEMBER, BUT IT'S MOST COMMON USE IS JCL BUILDING.
NATURALLY THERE'S MORE TO IT THAN WHAT I'VE OUTLINED HERE, AND
IF YOU DECIDE TO USE IT, YOU'D BEST STUDY THE VARIOUS SECTIONS
OF YOUR REFERENCE MANUAL ON FILE TAILORING.



   !t+99
                    ***** TABLE I/O *****

TABLE I/O IS A SERVICE OF DIALOGUE MANAGER THAT LOOKS PRETTY NICE
AT FIRST GLANCE, BUT THE DEEPER YOU GET INTO IT, THE MORE YOU REALIZE
THAT IT CAN BE TRICKY TO USE AND IS REALLY QUITE COMPLICATED.  WORST
OF ALL IS THE FACT THAT IT IS NOT ACCESSIBLE BY ANYTHING BUT
DIALOGUE MANAGER, A FACT THAT YOUR REFERENCE MANUAL FAILS TO MENTION.

¬ALL TABLE I/O IS CAPABLE OF DOING, REALLY, IS READING AND WRITING
RECORDS INTO A DATASET¢.  THE TROUBLE LIES IN THE FACT THAT IT DOES
SO IN SUCH A FASHION THAT ALTHOUGH IT IS PHYSICALLY POSSIBLE TO READ THE
RECORDS WITH A NORMAL BATCH JOB, THE DATA IS SO SCRAMBLED THAT
YOU'RE GOING TO HAVE TO WRITE (AND DEBUG) A LOT OF CODE IN ORDER
TO PUT YOUR DATA BACK IN USABLE FORM. IN OTHER WORDS, ANY DATA YOU
SAVE USING TABLE I/O, CAN'T BE USED BY ANYTHING EXCEPT ANOTHER SESSION
OF DIALOGUE MANAGER. THERE IS AN AUXILIARY FUNCTION REFERRED TO AS
"TABLE DISPLAY"; WITH THIS YOU CAN CAUSE THE DIALOGUE MANAGER TO
DISPLAY YOUR TABLE I/O DATA FIELDS, USING SPECIAL MAPS WHICH YOU'VE
PREDEFINED.

ALL IN ALL, IT'S FAR MORE TROUBLE THAN IT'S WORTH.  IT'S MUCH SIMPLER
TO BUILD, READ, AND WRITE RECORDS YOURSELF, USING VARIABLES
RETURNED FROM DISPLAY PANELS TO BUILD THOSE RECORDS.  THE ONLY
CONSIDERATION IS THAT ANY FILES YOU OPEN WILL HAVE TO HAVE BEEN PRE-
ALLOCATED BEFORE YOUR DIALOGUE STARTS.  YOU CAN DO THIS IN THE SAME
CLIST THAT YOU USE TO CONCATENATE YOUR PANEL LIBRARIES.

IF YOU DO DECIDE TO USE THE TABLE I/O FEATURE, YOU'D BEST SPEND A
LOT OF TIME STUDYING THE VARIOUS SECTIONS IN YOUR REFERENCE MANUAL
ON "TABLE SERVICES".



   !t+99
                    ***** MESSAGES *****


DIALOGUE MANAGER HAS A VERY NICE, WELL DESIGNED MEANS OF
DISPLAYING MESSAGES.  THEY ARE HANDLED AND DISPLAYED EXACTLY LIKE
PDF DOES - I.E. - A SHORT MESSAGE IN THE UPPER RIGHT HAND CORNER,
FOLLOWED BY A LONGER EXPANDED MESSAGE A COUPLE LINES DOWN FROM
THE TOP IF THE USER PRESSES HELP.

YOU MUST BUILD YOUR MESSAGES IN RELATED GROUPS, EACH GROUP BEING
SAVED AS A MEMBER IN YOUR MESSAGE LIBRARY.  THE MESSAGE ID MUST
BEGIN IN COLUMN ONE FOR THE FIRST (SHORT) MESSAGE LINE.  EITHER
FORM OF THE MESSAGE CAN CONTAIN SYMBOLIC VARIABLES WHICH WILL BE
REPLACED BY THE CURRENT VALUE OF THAT VARIABLE FROM THE VARIABLE
POOLS.  MAX LENGTH OF SHORT MESSAGES (AFTER SUBSTITUTION) IS
24 CHARACTERS; FOR LONG MESSAGES IT'S 78.

ALL MESSAGES IN A MEMBER MUST BE KEPT IN ASCENDING ORDER BY MESSAGE
ID.  MOREOVER, THERE HAS TO BE A STRANGE CONVOLUTED RELATIONSHIP
BETWEEN THE MESSAGE IDS YOU USE AND THE NAME OF THE MEMBER WHERE
YOU STORE THOSE MESSAGES; READ THE "MESSAGE LIBRARY" SECTION IN
REFERENCE MANUAL CAREFULLY BEFORE YOU SET UP EITHER YOUR MESSAGE
ID PREFIXES OR MEMBER NAMES. THE MANUAL HAS SOME GOOD EXAMPLES OF
MESSAGES SET UP IN A MEMBER OF A MESSAGE LIBRARY.


   !t+99
           ****** TESTING VIA FUNCTION 7 *****

       IN ORDER TO MAKE TESTING A COMPLICATED DIALOGUE A LITTLE
EASIER, DIALOGUE MANAGER OFFERS SOME TEST/DEBUG FEATURES. THESE
CAN BE USED INTERACTIVELY - I.E. YOU CAN VIEW AND CHANGE THINGS
AS THEY ARE OCCURRING WITHIN YOUR DIALOGUE.
     THE FIRST OF THESE AIDS YOU'LL NEED TO UNDERSTAND IS THAT OF
BREAKPOINTS. THERE IS NOTHING NEW ABOUT THE IDEA, AS LOTS OF
COMPILERS AND INTERPRETERS OFFER BREAKPOINTS IN VARIOUS FORMS.
THE BASIC IDEA IS SIMPLY THAT OF GIVING YOU A MEANS OF STOPPING
EXECUTION OF SOMETHING AT CERTAIN POINTS THAT YOU PICK, AND ALSO
ALLOWING YOU TO VIEW AND MODIFY THE CONTENTS OF VARIOUS FIELDS.
BEAR IN MIND THAT THIS CASE IS DIFFERENT IN THAT YOUR DIALOGUE
IS A MIXTURE OF YOUR PROGRAMS, PANELS, AND CALLS TO THE DIALOGUE
MANAGER VIA ISPLINK. WHAT THIS MEANS IS THAT BREAKPOINTS
CANNOT BE SET WITHIN YOUR PROGRAM CODE ITSELF, BUT MUST OCCUR
WHEN THE DIALOGUE MANAGER HAS CONTROL - I.E. WHEN YOU GIVE
UP CONTROL VIA THE CALLS TO ISPLINK THAT YOUR PROGRAM ISSUES.
     SOME OF THE TERMS USED ASSOCIATED WITH BREAKPOINT CAN BE
CONFUSING. SINCE YOU'LL NEED TO UNDERSTAND THEM IN ORDER TO
SET UP YOUR BREAKPOINTS PROPERLY, WE'D BEST GET THEM STRAIGHT.
WHEN THE IBM MANUAL OR THE BREAKPOINT PANEL TALKS ABOUT "FUNCTION"
THEY MEAN A PROGRAM OR CLIST. SINCE YOU'LL PROBABLY ONLY HAVE ONE
OF THESE, YOU CAN SPECIFY "ALL" (THE DEFAULT) FOR FUNCTION.
"SERVICE" REFERS TO THNGS LIKE VGET, VPUT, DISPLAY, ETC.
"QUALIFICATION" (SEE BELOW) REFERS TO THE PARTICULAR PARAMETER
COMBINATION USED FOR A PARTICULAR SERVICE.
     HERE'S HOW YOU USE IT: BEFORE STARTING UP YOUR DIALOGUE
GO TO FUNCTION 7.8 AND SPECIFY THE NAME OF THE SERVICE WITHIN
ISPLINK THAT YOU WANT TO BREAK AT - E.G. "VPUT", "VGET", ETC.
KEEP IN MIND THAT YOU MAY NOT BE ABLE TO CHOOSE A SPECIFIC "VPUT"
OR "VGET"; WHEN YOU RUN YOUR DIALOGUE YOU MAY BE FORCED TO STOP AT
EACH AND EVERY OCCURRENCE. YOU CAN ALSO SPECIFY WHETHER YOU
WANT THE BREAKPOINT TO OCCUR BEFORE THE REQUESTED SERVICE IS
PERFORMED, AFTER IT'S PERFORMED, OR BOTH. YOU CAN SET MORE THAN
ONE SERVICE THAT YOU WISH TO BREAK ON. THERE IS AN ADDITIONAL
LEVEL YOU CAN SPECIFY FOR BREAKPOINT IF YOU WANT, CALLED
"QUALIFICATION". LET'S SAY YOU SET A BREAKPOINT FOR THE SERVICE
"VGET", BUT UNFORTUNATELY YOU HAVE A WHOLE BUNCH OF VGETS IN
VARIOUS PLACES IN YOUR PROGRAM. THE WAY THINGS STAND, BREAKPOINT
IS GOING TO STOP ON EVERY ONE OF THEM, EVEN THOUGH THERE MAY ONLY
BE ONE YOU'RE INTERESTED IN. SOMETIMES YOU CAN CUT THIS DOWN
USING "QUALIFICATION". WHEN IN THE BREAKPOINT SCREEN TYPE IN
"QUAL" ON THE PRIMARY COMMAND LINE; THIS WILL GIVE YOU A NEW
SCREEN WHICH WILL ALLOW YOU TO SPECIFY "QUALIFICATION PARAMETER
VALUES". WHAT THAT MEANS IS THAT IF YOU CAN FIND SOMETHING UNIQUE
ABOUT THE PARAMETER LIST BEING PASSED BY THE PARTICULAR VGET
YOU NEED TO STOP ON, YOU CAN SPECIFY THAT INFORMATION AND THUS
ELIMINATE STOPPING NEEDLESSLY ON THE IRRELEVANT VGETS.  WHEN
YOU'RE DONE, THE "RESUME" COMMAND WILL RETURN YOU TO THE ORIGINAL
BREAKPOINT PANEL.
    NEXT, GO TO FUNCTION 7.1 AND VIA THAT PANEL GET YOUR DIALOGUE
STARTED. IT WILL RUN JUST AS IT NORMALLY DOES UNTIL DIALOGUE MANAGER
SENSES A REQUEST FOR ONE OF THE SERVICES YOU SET AS A BREAKPOINT,
AT WHICH POINT YOUR NORMAL SCREEN DISAPPEARS, AND YOU GET A SPECIAL
"BREAKPOINT SCREEN"; AT THIS POINT YOU CAN DO ALL SORTS OF THINGS,
SUCH AS DISPLAYING THE VALUES OF THE VARIABLES IN THE VARIOUS POOLS,
MODIFYING THOSE VALUES, DISPLAYING THE SPF LOG, ETC, ETC. WHEN
YOU'RE READY, YOU CAN ENTER "G" FOR GO ON THE BREAKPOINT SCREEN
AND RETURN TO RUNNING YOUR DIALOGUE, USING THE NEW VALUES YOU'VE
OVVERRIDDEN. ANYTIME YOU NEED TO ADD, DELETE, OR MODIFY YOUR BREAK-
POINTS YOU CAN. WHATEVER BREAKPOINTS YOU SPECIFY WILL HOLD AS LONG
AS YOU STAY WITHIN FUNCTION 7; IF YOU LEAVE 7, THEY'LL ALL BE
LOST.

     ANOTHER AID IS KNOWN AS "TRACE"; FUNCTION 7.7 WILL ALLOW YOU TO
TO START A TRACE ON EITHER OR BOTH OF TWO TYPES OF ITEMS: FUNCTIONS
AND VARIABLES. A FUNCTION IS ONE OF THE SERVICES OF ISPLINK - E.G/
VCOPY, SETMSG, VREPLACE, ETC.  YOU JUST ENTER THE NAME OF THE
PARTICULAR FUNCTION YOU WANT TO TRACE IN 7.7.1. FOR A VARIABLE
TRACE YOU'LL NEED TO ENTER THE NAME OF THE DESIRED VARIABLE IN
7.7.2. YOU CAN SIMALTANEOUSLY TRACE MORE THAN ONE FUNCTION OR
VARIABLE AT A TIME.
     THE TRACE ITSELF WILL BE IN THE SPF LOG DATASET, AND YOU
CAN DISPLAY THE LOG VIA 7.5. BE SURE TO KEEP THE TRACE AS SHORT
AND SIMPLE AS POSSIBLE, AVOIDING TRACING OF MULTIPLE VARIABLES
AT ONCE, AS TRACE CAN PRODUCE AN AMAZING AMOUNT OF OUTPUT IN THE
LOG, AND IT GETS DIFFICULT TO TELL WHAT'S WHAT IF YOU'RE NOT
CAREFUL. ONE VERY IMPORTANT POINT TO NOTE IS THAT OUR STANDARD
TSO PROC PRE-ALLOCATES THE LOG DATASET TO SYSOUT, FOR REASONS OF
EFFICIENCY; UNFORTUNATELY, SPF CANNOT BROWSE A SYSOUT DATASET,
WHICH MAKES BOTH THE LOG AND THE TRACE FUNCTION WORTHLESS FOR
ONLINE/INTERACTIVE PURPOSES. YOU CAN GET AROUND THIS PROBLEM BY
FREEING THE LOG ¬BEFORE¢ YOU ENTER SPF, WHICH ALLOWS SPF TO
DYNAMICALLY ALLOCATE THE LOG TO A NORMAL DISK DATASET, SO THAT
IT CAN BE BROWSED; WHEN YOU LEAVE SPF IT WILL DISPLAY A SPECIAL
SCREEN THAT WILL LET YOU EITHER PRINT THE LOG OR THROW IT AWAY.
THE FORMAT OF THE TSO FREE COMMAND YOU'LL NEED IS:

     FREE FI(ISPLOG)

     ONE THING THAT'S ODD ABOUT FUNCTION 7, AND WHICH CAN TRIP YOU
UP IS THE USE OF SPLIT SCREEN. THE TEMPTATION IS TO SPLIT SCREEN WHILE
YOU'RE TESTING A DIALOGUE, AND USE THE NEW HALF TO GO TO ONE OF THE
SUBFUNCTIONS OF 7 IN ORDER TO SET BREAKPOINTS, DISPLAY VARIABLES, ETC.
¬THIS DOESN'T WORK¢; THE REASON IS THAT WHEN YOU SPLIT SCREEN YOU GET
A NEW VARIABLE POOL AND NEW BREAKPOINT CONTROL TO GO WITH THE NEW
SCREEN, AND ANY MODIFICATIONS YOU MAKE TO IT WILL ¬NOT¢ AFFECT THE
VARIABLE POOL AND BREAKPOINTS OF THE OLD HALF WHERE YOUR DIALOGUE IS
RUNNING.
   !t+99

               ***** USING ISPEXEC/ISPLINK *****

     THE FOLLOWING SECTIONS CONTAIN NOTES AND EXAMPLES ON OBTAINING
SERVICES FROM THE DIALOGUE MANAGER VIA ISPEXEC AND ISPLINK. ISPEXEC
IS USED ONLY WITHIN A CLIST. ISPEXEC AND ISPLINK BOTH DO EXACTLY
THE SAME THING, WITH THE EXCEPTION NOTED BELOW; THE REASON FOR THE
DIFFERENCE IS SIMPLY BECAUSE YOU CAN'T ISSUE A "CALL" WITHIN A
CLIST LIKE YOU CAN IN A PROGRAMMING LANGUAGE, SO THEY INVENTED A
NEW CLIST KEYWORD FUNCTION, "ISPEXEC", WHICH ALLOWS YOU TO REQUEST
SERVICES FROM DIALOGUE MANAGER. ALTHOUGH THE SYNTAX FOR ISPEXEC IS
DIFFERENT THAT THAT FOR CALLING ISPLINK, THE ONLY REAL DIFFERENCE
IS DUE TO THE FACT THAT SOME OF THE SERVICES YOU REQUEST VIA
ISPLINK (SUCH AS VCOPY, VDEFINE, VREPLACE, ETC) ARE NOT NECESSARY
- AND THEREFORE INVALID - FOR ISPEXEC, SINCE THE CLIST PROCESSOR
TAKES CARE OF THESE AUTOMATICALLY.  FOR ALL THE STANDARD PROGRAMMING
LANGUAGES (COBOL, FORTRAN, PL/1 AND ASSEMBLER), YOU HAVE TO ISSUE A
CALL TO ISPLINK ("ISPLNK" FOR FORTRAN), PASSING A PARAMETER LIST THAT
WILL INDICATE THE PARTICULAR SERVICE YOU WANT, AND THE OPTIONS FOR
THAT SERVICE. ONLY THE COMMONLY USED SERVICES ARE COVERED - FOR
EXAMPLE ALL SERVICES RELATED TO TABLE I/O HAVE BEEN OMITTED.
MOREOVER, NOT ALL THE OPTIONS FOR ANY GIVEN SERVICE ARE COVERED -
JUST THE COMMONLY USED ONES, SINCE THIS WRITE-UP IS¬NOT¢ INTENDED TO
BE A REPLACEMENT FOR YOUR REFERENCE MANUAL.
   !t+99

                     ***** CONTROL *****

     THE CONTROL SERVICE IS CALLED TO SET OVERALL OPERATING CONDITIONS
FOR YOUR DIALOGUE. YOU'LL NEED TO USE IT AT LEAST ONCE AT THE BEGINNING
OF YOUR PROGRAM/CLIST IF YOU WANT DIALOGUE MANAGER TO RETURN TO YOU
WHEN A SEVERE ERROR IS ENCOUNTERED. IF YOU SPECIFY THE RETURN OPTION,
DIALOGUE MANAGER WILL RETURN TO YOUR PROGRAM OR CLIST IF THE RETURN
CODE IS 0 -> 20; WITH THE CANCEL OPTION, IF THE RETURN CODE FROM ANY
SERVICE IS 12 OR GREATER, YOUR ENTIRE DIALOGUE IS CANCELLED.

     SAMPLES IN VARIOUS LANGUAGES:

     ISPEXEC CONTROL ERRORS RETURN     (CLIST)











     CONTROL PERFORMS A NUMBER OF OTHER FUNCTIONS AS WELL, SUCH AS
SIMULATING ENTER/END KEYS FOR PANEL TESTING, SETTING THE BEGINNING
POSITION FOR TERMINAL LINE MODE OUTPUT, ETC. THE LATTER IS USED TO
CONTROL WHERE ON YOUR PANEL THAT TSO BEGINS WRITING ITS MESSAGES/
OUTPUT WHEN YOU INVOKE A TSO FUNCTION. IN OTHER WORDS, YOU CAN USE
IT TO KEEP TSO FROM WRITING ALL OVER THE TOP OF YOUR PANELS. SEE
YOUR REFERENCE MANUAL.
   !t+99

                     ***** DISPLAY *****

     THE DISPLAY SERVICE IS HOW YOU GO ABOUT DISPLAYING ONE OF THE
PANELS FROM YOUR PROGRAM. NOTE THAT CONTROL WILL ALWAYS RETURN TO THAT
PROGRAM FROM THE PANEL - I.E. THE PANEL CAN'T CALL ANOTHER PANEL OR
ANOTHER PROGRAM; CONTRAST THIS WITH THE "SELECT" SERVICE. IF YOU WANT,
YOU CAN ALSO SPECIFY A MESSAGE YOU WANT DISPLAYED WITH THE PANEL,
AND/OR CONTROL THE POSITION OF THE CURSOR; THESE TWO FUNCTIONS ARE
OPTIONAL.

     SAMPLES IN VARIOUS LANGUAGES:

     ISPEXEC DISPLAY PANEL(PANEL-NAME) MSG(MESSAGE-ID) CURSOR(FIELDNAME)











   !t+99

                     ***** EDIT *****

     THE EDIT SERVICE ALLOWS YOU TO CALL THE REGULAR PDF EDITOR
DIRECTLY - I.E. WITHOUT DISPLAYING THE MEMBER SELECTION SCREEN. YOUR
USER WILL BE ABLE TO DO MOST ANYTHING THAT HE COULD DO IN PDF EDIT,
AND THE SCREEN WILL LOOK EXACTLY LIKE PDF EDIT. CONSEQUENTLY, IT'S
A GOOD IDEA TO USE THE "SETMSG" SERVICE BEFORE YOU USE EDIT, TO
DISPLAY A MESSAGE INFORMING THE USER THAT HE'S ONLY TEMPORARILY IN
PDF EDIT AND WILL RETURN TO YOUR DIALOGUE. THE FOLLOWING EXAMPLES
ASSUME THE DATASET IS CATALOGUED. BE SURE TO PUT THE QUOTES AROUND
THE DSN IN CASE ONE OF YOUR USERS HAS TSO PREFIX ON.

     SAMPLES IN VARIOUS LANGUAGES:

     ISPEXEC EDIT DATASET('YOUR-DSN')     (CLIST)











   !t+99

                     ***** BROWSE *****

     THE BROWSE SERVICE WORKS EXACTLY LIKE THE EDIT SERVICE, EXCEPT THAT
YOU ENTER PDF BROWSE INSTEAD.

     SAMPLES IN VARIOUS LANGUAGES:

     ISPEXEC BROWSE DATASET('YOUR-DSN')











   !t+99
                     ***** LOG *****

     THE LOG SERVICE IS USED TO TAKE ONE OF THE MESSAGES IN YOUR
MESSAGE LIBRARY AND WRITE IT TO THE SPF LOG FOR THAT USER. THIS CAN
BE HANDY FOR BUILDING AND TESTING A NEW DIALOGUE, BUT DOESN'T MAKE
MUCH SENSE FOR A PRODUCTION DIALOGUE UNLESS YOU SET UP YOUR END USERS
SPF OPTIONS TO PRINT THE LOG, AND THEN HAVE SOMEBODY EXAMINING THOSE
LOGS.

     SAMPLES IN VARIOUS LANGUAGES:

     ISPEXEC LOG MSG(YOUR-MESSAGE-ID)












   !t+99
                     ***** SELECT *****

     SELECT IS ONE OF THE MORE IMPORTANT SERVICES, AND HAS TWO MAIN
USES: THE FIRST IS TO ALLOW YOU TO DISPLAY A PANEL, BUT UNLIKE
THE "DISPLAY" SERVICE, THE PANEL DOES ¬NOT¢ HAVE TO IMMEDIATELY
RETURN TO THE POINT WHERE THE SELECT WAS ISSUED. IN OTHER WORDS,
THE PANEL CAN IN TURN INVOKE ANOTHER PANEL OR ANOTHER PROGRAM.
MOREOVER, BY USING THE "OPT" PARAMETER, YOU CAN SELECT A PANEL AND
PASS IT AN OPTION THAT IS VALID FOR IT, AND THAT OPTION WILL BE
INVOKED WITHOUT ACTUALLY DISPLAYING THE PANEL.
     THE SECOND USE FOR SELECT IS THAT OF PASSING CONTROL TO ANOTHER
PROGRAM OR CLIST. FOR EXAMPLE, LET'S SAY YOUR COBOL PROGRAM REACHES
A POINT WHERE IT DECIDES ITS NECESSARY TO DYNAMICALLY FREE/ALLOCATE
A SPECIAL DATASET. YOU CANNOT DO A FREE OR ALLOCATE WITHIN A COBOL
PROGRAM, BUT YOU CAN WITHIN A CLIST. SO, YOU BUILD A SPECIAL CLIST
TO DO THE JOB, AND THEN CALL ISPLINK/SELECT TO PASS CONTROL TO THE
CLIST. SINCE YOU CAN PASS A PARM TO THE CLIST, YOU COULD HAVE THE
CLIST DO A NUMBER OF DIFFERENT FUNCTIONS, CONTROLLED BY THE PARM.
     SINCE YOU COULD USE SELECT TO CALL ANOTHER COBOL PROGRAM,
OR YOU COULD ALSO USE A REGULAR COBOL CALL TO DO THE SAME THING,
YOU'RE PROBABLY WONDERING WHAT DIFFERENCE IT MAKES WHICH METHOD
YOU PICK.  IT DEFINITELY DOES MAKE A DIFFERENCE, AND THE GENERAL
RULE TO FOLLOW IS THIS: IF THE PROGRAM YOU'RE CALLING HAS NOTHING
TO DO WITH DIALOGUE MANAGER - I.E. HAS NO CALLS TO ISPLINK - THEN
YOU CAN PASS CONTROL TO IT EITHER BY USING A STANDARD COBOL CALL
OR THROUGH ISPLINK/SELECT. A TYPICAL EXAMPLE OF THIS WOULD BE
CALLING A GENERAL PURPOSE DATE CONVERSION ROUTINE. BUT, IF THE
CALLED PROGRAM CONTAINS CALLS TO ISPLINK, ¬THEN YOU HAVE TO USE
THE ISPLINK/SELECT METHOD¢. NATURALLY, THE SAFEST METHOD IS TO
ALWAYS USE SELECT TO PASS CONTROL, BUT IT'S BOUND TO ADD SOME
OVERHEAD. HOWEVER, FAILING TO USE IT WHEN IT'S NEEDED CAN RESULT
IN SOME VERY STRANGE BUGS AND MESSY SCREENS.

     SAMPLES IN VARIOUS LANGUAGES:










   !t+99
                     ***** SETMSG *****

     SETMSG IS A SPECIAL PURPOSE SERVICE THAT ALLOWS YOU TO SPECIFY
THE MESSAGE ID OF ONE OF THE MESSAGES YOU'VE BUILT IN YOUR MESSAGE
LIBRARY, AND THAT MESSAGE WILL BE DISPLAYED ON THE ¬NEXT¢ PANEL
THAT GETS DISPLAYED, ¬REGARDLESS OF WHETHER OR NOT THAT NEXT PANEL
BELONGS TO YOU.¢ ONE PLACE YOU'VE PROBABLY SEEN THIS USED IS BY
THE EDIT FUNCTION OF PDF. LET'S SAY YOU'RE IN EDIT, AND GO UP TO THE
PRIMARY COMMAND LINE AND TYPE IN "END" OR HIT PF3. WHEN YOU NEXT
SEE THE EDIT SELECT SCREEN, THERE WILL BE A "XXXXXXXX SAVED" MESSAGE IN
THE UPPER RIGHT HAND CORNER. THAT MESSAGE GOT THERE BECAUSE EDIT
REQUESTED THE SETMSG SERVICE.

     SAMPLES IN VARIOUS LANGUAGES:










   !t+99
                     ***** VCOPY *****

     VCOPY IS A VERY IMPORTANT SERVICE THAT YOU'LL PROBABLY BE
USING A LOT. ¬IT DOES NOT APPLY TO CLISTS, AND THEREFORE IS INVALID
FOR ISPEXEC¢. VCOPY IS THE LAST STEP IN A CHAIN OF SERVICES THAT
ARE NECESSARY TO GET DATA FROM A PANEL INTO YOUR PROGRAM; IT IS
THE SERVICE THAT COPIES THE VALUES OF THE VARIABLES YOU REQUEST
FROM THE FUNCTION POOL FOR YOUR PROGRAM ¬INTO THE STORAGE AREA
OF YOUR PROGRAM¢ THAT YOU'VE DESIGNATED.  VCOPY CAN CAUSE YOU A
LOT OF HEADACHES IF YOU'RE NOT CAREFUL OR IF YOU DON'T KNOW WHAT
YOU'RE DOING.  THIS IS BECAUSE IT IS QUITE CAPABLE OF CHEERFULLY
OVERLAYING ALL SORTS OF GOOD DATA IN YOUR PROGRAM IF YOU CODE
THE CALL IMPROPERLY. DEPENDING ON WHAT GETS OVERLAID IN YOUR PROGRAM,
THIS COULD RESULT IN GARBAGE BEING DISPLAY ON SUBSEQUENT SCREENS,
INCORRECT OUTPUT FROM YOUR PROGRAM, OR OUTRIGHT ABENDS THAT WILL
NOT BE EASY TO DEBUG IN A HIGH LEVEL LANGUAGE.

FOLLOWING ARE THE IMPORTANT THINGS TO KEEP IN MIND:

     A. YOU CAN COPY MORE THAN ONE VARIABLE AT A TIME; THIS IS A
        GOOD IDEA AS IT ELIMINATES THE OVERHEAD OF MULTIPLE CALLS
        TO ISPLINK.  HOWEVER, COPYING MULTIPLE VARIABLES AT A TIME
        CAN MAKE THE SITUATION EVEN RISKIER IN TERMS OF OVERLAYING
        DATA, BECAUSE OF THE WAY DIALOGUE MANAGER HANDLES THE MOVE.
     B. IN THE PARAMETER LIST YOU MUST SPECIFY THREE KEY THINGS;
        THE FIRST IS A CHARACTER LIST OF THE ¬NAMES OF THE VARIABLES
        IN THE VARIABLE POOL¢; (THIS IS ¬NOT¢ A LIST OF THE NAMES
        OF THE FIELDS IN YOUR PROGRAM WHERE THE DATA WILL BE PUT).
        THE SECOND IS A CONTIGUOUS GROUP OF FULLWORDS; EACH FULLWORD
        MUST CONTAIN, IN BINARY, THE LENGTH OF THE DATA THAT YOU
        EXPECT FOR THE ASSOCIATED VARIABLE. THE THIRD THING IS ONE
        LARGE CONTIGUOUS STORAGE AREA IN YOUR PROGRAM WHERE THE
        VARIABLES THEMSELVES WILL ACTUALLY BE COPIED. YOU'LL
        PROBABLY WANT TO MAKE THIS A STRUCTURE WITH THE HIGHEST
        LEVEL REPRESENTING THE OVERALL LARGE AREA, AND THE LOWER
        LEVELS REPRESENTING EACH INDIVIDUAL VARIABLE. THE IMPORTANT
        THING TO REMEMBER IS THAT ¬ISPLINK IS NOT AWARE OF YOUR
        LOWER LEVEL ELEMENTS¢; IN OTHER WORDS IT IS NOT DOING
        INDIVIDUAL MOVES FROM EACH VARIABLE INTO EACH ONE OF YOUR
        LOWER LEVEL ELEMENTS. WHAT IT IS DOING IS MOVING THE FIRST
        VARIABLE YOU REQUESTED INTO THE BEGINNING ADDRESS OF THE
        LARGE STORAGE AREA, THEN ADDING THE LENGTH THAT YOU
        SPECIFIED FOR THAT VARIABLE TO THE BEGINNING ADDRESS TO
        DEVELOP THE ADDRESS FOR THE SECOND VARIABLE, WHICH IT
        THEN MOVES IN, AND SO ON. NOTE THAT IT WILL USE THE LENGTH
        YOU SPECIFIED EVEN IF THE VARIABLE IS TOO SHORT TO FILL IT.
        A SHORT VARIABLE IS LEFT JUSTIFIED AND RIGHT BLANK FILLED.
        CONSEQUENTLY YOU HAVE TO MAKE SURE THAT THE LENGTH ARRAY
        YOU SET UP MATCHES EXACTLY THE STRUCTURE YOU SET UP, AND
        YOU DON'T MODIFY ONE WITHOUT MODIFYING THE OTHER. REMEMBER
        THAT NEITHER THE COBOL COMPILER NOR ISPLINK WILL CHECK TO
        MAKE SURE THIS IS CORRECT; YOU'LL HAVE TO DO IT YOURSELF.
        LIKEWISE, YOU CAN'T JUST UP AND DEFINE A NEW FIELD IN
        THE STRUCTURE WITHOUT MODIFYING BOTH THE LENGTH ARRAY AND
        THE VARIABLE NAME LIST TO MATCH. NOR CAN YOU STICK A
        FIELD IN THAT STRUCTURE THAT ISN'T INTENDED TO RECEIVE
        A VARIABLE; IF YOU DO, IT WILL GET WIPED AND THE REST OF
        YOUR STRUCTURE FROM THERE ON DOWN WILL BE OUT OF WHACK.
        C. A PARTICULARLY CRITICAL AND TRICKY QUIRK OF THIS SERVICE
        IS THE LENGTH ARRAY YOU SPECIFY; ¬ISPLINK MODIFIES THIS
        EVERY TIME YOU CALL IT¢. THIS MEANS THAT YOU HAVE TO
        RE-INITIALIZE THE LENGTH ARRAY ¬BEFORE YOUR LOGIC PASSES
        THROUGH THAT PARTICULAR CALL AGAIN¢. THE REASON FOR THIS IS
        FAIRLY SIMPLE; SINCE VARIABLES CAN (AND OFTEN ARE) SHORTER
        THAN THEIR DEFINED LENGTH, ISPLINK WILL STORE INTO THE ARRAY
        THE ACTUAL LENGTH OF THAT VARIABLE AT THAT TIME, IN ¬BINARY¢.
        THIS IS HANDY AS IT SAVES YOU HAVING TO SCAN EACH VARIABLE TO
        DETERMINE ITS LENGTH. IT CAN ALSO BE DISASTEROUS IF YOU FORGET
        TO REINITIALIZE THE ARRAY, SINCE ON THE NEXT CALL IT WILL BE
        MOVING VARIABLES INTO YOUR STRUCTURE USING SHORT LENGTHS LEFT
        OVER FROM THE PREVIOUS CALL, AND THESE WILL NO LONGER MATCH
        YOUR LOWER LEVEL ELEMENTS. THE BEST WAY TO HANDLE THIS IS
        TO MAKE EACH LOW LEVEL ELEMENT IN YOUR PROGRAM THE EXACT SAME
        LENGTH AS THE DEFINED (MAXIMUM) LENGTH OF ITS CORRESPONDING
        VARIABLE IN YOUR PANEL DEFINITION, AND THEN RE-INITIALIZE
        THE LENGTH ARRAY BEFORE EACH CALL.
        D. THE BOOK SHOWS TWO DIFFERENT MODES OF OPERATION FOR
        VCOPY - "MOVE" AND "LOCATE". STAY AWAY FROM LOCATE, WHICH
        UNFORTUNATELY IS THE DEFAULT. LOCATE MODE IS DESIGNED TO
        RETURN THE ¬ADDRESSES¢ OF THE VARIABLES TO THE PROGRAM,
        WHICH CAN BE CLUMSY TO HANDLE IN A HIGH LEVEL LANGUAGE.
        MOVE MODE ACTUALLY PLACES THE VARIABLES VALUES IN YOUR
        STORAGE, AS OUTLINED ABOVE. ONCE YOU GET TO THIS STAGE, IT'S
        NOT A BIT DIFFERENT FROM READING A CARD INTO A STRUCTURE.

     SAMPLES IN VARIOUS LANGUAGES:










   !t+99
                     ***** VDEFINE *****
     THE VDEFINE SERVICE IS ONE THAT ALTHOUGH IT MAY APPEAR OTHERWISE,
YOU SHOULDN'T NEED TO USE VERY OFTEN. THE BASIC IDEA IS THE SAME AS
THAT OF "VREPLACE" - I.E. DATA IS TRANSFERRED ¬FROM YOUR PROGRAM TO
THE FUNCTION POOL¢. THE MAIN DIFFERENCE IS THAT WITH VDEFINE YOU
ARE ¬CREATING A NEW VARIABLE IN THE POOL THAT DID NOT EXIST BEFORE¢,
AS WELL AS SETTING THE VALUE OF THAT VARIABLE, WHEREAS VREPLACE MERELY
CHANGES THE CONTENTS OF A VARIABLE THAT ALREADY EXISTS IN THE POOL.
THE REASON THAT YOU SHOULDN'T GENERALLY NEED VDEFINE IS BECAUSE
IT IS SIMPLER AND LESS MESSY TO LET ALL VARIABLES BE ¬IMPLICITLY¢
DEFINED IN THE PANEL WHERE THEY ARE TO BE USED ANYWAY, AND THEN LET
VPUT AND VGET RIPPLE THEM THROUGHOUT THE FUNCTION POOLS AND THE
SHARED POOL.
     IF YOU DO FIND A NEED TO USE IT, KEEP IN MIND THAT IF YOU DECIDE
TO VDEFINE MORE THAN ONE VARIABLE PER CALL TO ISPLINK THAT ¬ALL OF THE
VARIABLES IN THAT CALL MUST HAVE EXACTLY THE SAME LENGTH AND THE SAME
FORMAT¢.  THIS RESTRICTION MAKES VDEFINE PRETTY IMPRACTICAL TO USE
BECAUSE MOST PRACTICAL SYSTEMS AREN'T SO LUCKY THAT ALL THEIR
VARIABLES ARE THE SAME LENGTH. NATURALLY YOU CAN GET AROUND THIS
BY SETTING UP AS MANY VDEFINES AS YOU HAVE VARIABLES, OR GROUPING
THEM BY LENGTH, BUT THIS IS BOUND TO CAUSE A LOT OF NEEDLESS OVERHEAD
DUE TO THE MULTIPLE CALLS TO ISPLINK, AND DOESN'T MAKE YOUR CODE
ANY EASIER TO FOLLOW EITHER. IF YOU TRY TO IGNORE THIS RESTRICTION,
YOU'LL FIND THAT ISPLINK WILL TREAT ALL YOUR VARIABLES AS THOUGH
THEY ¬ARE¢ THE SAME LENGTH, AND YOU'LL WIND UP WITH SCRAMBLED
VARIABLES AND MAYBE AN ABEND, TOO.
     THE REFERENCE MANUAL SHOWS A NUMBER OF DIFFERENT "FORMATS" YOUR
DATA CAN HAVE, AND ISPLINK IS CAPABLE OF CONVERTING THESE VARIOUS
FORMATS TO CHARACTER SO THAT A PANEL CAN DISPLAY THEM. MY ADVICE
IS TO STICK STRICTLY TO CHARACTER FORMAT, AND TAKE CARE OF ANY
CONVERSIONS YOURSELF WITHIN THE LANGUAGE YOU'RE USING, WHERE YOU'RE
FAMILIAR WITH WHAT YOU'RE DOING; IN OTHERWORDS GET EVERYTHING
CONVERTED TO CHARACTER ¬BEFORE¢ YOU CALL ISPLINK.
     THERE ARE FOUR ITEMS IN THE PARAMETER LIST THAT YOU HAVE TO PASS
TO ISPLINK FOR VDEFINE. THE FIRST IS A LIST OF NAMES YOU WANT ASSIGNED
TO THE VARIABLES WHEN THEY'RE PUT IN THE FUNCTION POOL. BEAR IN MIND
THAT THESE ¬ARE NOT¢ NECESSARILY GOING TO BE THE NAMES THAT YOU ASSIGN
TO THE FIELDS IN THE PROGRAM. THE SECOND ITEM IS THE NAME OF THE
OVERALL AREA IN YOUR PROGRAM STORAGE WHERE THE ¬VALUES¢ YOU WANT
ASSIGNED TO THE VARIABLES WILL BE. THIS AREA HAS TO BE BIG ENOUGH
(AND CONTIGUOUS!) TO CONTAIN ALL THE VALUES TOGETHER, ONE AFTER THE
OTHER. AGAIN, REMEMBER THAT EVEN THOUGH YOU MAY SUB-MAP THIS STORAGE
SO YOU CAN REFERENCE INDIVIDUAL VARIABLES WITHIN YOUR PROGRAM, ISPLINK
PAYS ABSOLUTELY NO ATTENTION TO THIS SUBMAPPING. THE THIRD ITEM
IS THE FORMAT YOUR DATA IS IN, WHICH SHOULD BE "CHAR". THE FOURTH ITEM
IS A SINGLE BINARY FULLWORD CONTAINING THE LENGTH, AND AS NOTED ABOVE
IT REPRESENTS THE LENGTH OF ANY VARIABLE SINCE THEY ALL HAVE TO BE
IDENTICAL IN LENGTH.
     VDEFINE IS ANOTHER OF THE ISPLINK SERVICES THAT IS NOT NECESSARY
IN CLIST, AND IS IN FACT AN INVALID PARAMETER FOR ISPEXEC.

     SAMPLES IN VARIOUS LANGUAGES:









   !t+99
                     ***** VDELETE *****

     VDELETE IS ANOTHER SERVICE YOU PROBABLY WON'T NEED. IT'S PURPOSE
IS TO REMOVE A VARIABLE FROM THE PROGRAM'S FUNCTION POOL, WHICH ALSO
REMOVES THE VARIABLES VALUE AS WELL, NATURALLY. NOTE THAT IT ONLY
DOES THIS FOR THE PROGRAM'S FUNCTION POOL, ¬NOT¢ FOR SHARED POOL,
THE PROFILE POOL, OR SOME OTHER FUNCTION POOL. FOR MOST SYSTEMS,
YOU CAN SIMPLY BLANK OUT THE CONTENTS OF A VARIABLE USING "VREPLACE"
IF YOU NO LONGER NEED IT, EITHER TEMPORARILY OR PERMANENTLY. USING
VDEFINE AND VDELETE TO CREATE/INITIALIZE AND ELIMINATE A VARIABLE
OVER AND OVER IS GOING TO DRIVE UP OVERHEAD MORE THAN SIMPLY BLANKING
IT OUT AND LEAVING IT ALONE UNTIL YOU NEED IT AGAIN.
     VDELETE IS NEITHER NEEDED NOR VALID FOR CLIST/ISPEXEC. THE
ONLY PARAMETER YOU NEED PASS IT IS JUST A STANDARD NAMELIST CONTAINING
THE NAMES OF THE VARIABLES TO BE DELETED.

     SAMPLES IN VARIOUS LANGUAGES:






   !t+99
                     ***** VGET*****

     VGET IS A SERVICE YOU'LL USE A LOT. ITS PURPOSE IS TO COPY
AN ALREADY EXISTING VARIABLE FROM EITHER THE SHARED POOL OR THE
PROFILE POOL INTO THE FUNCTION POOL FOR YOUR PROGRAM. NOTE THAT THIS
DOES NOT MEAN THAT IT COPIES THE VARIABLES VALUE INTO YOUR PROGRAM
ITSELF - YOU HAVE TO USE "VCOPY" TO DO THAT AS SHOWN ABOVE. IF
THE VARIABLE ALREADY EXISTS IN YOUR PROGRAM'S FUNCTION POOL, VGET
WILL UPDATE IT; OTHERWISE IT CREATES AND INITIALIZES IT.
     THERE ARE TWO PARAMETERS FOR VGET; THE FIRST IS A STANDARD
NAMELIST CONTAINING THE NAMES OF ALL THE VARIABLES YOU WANT DONE.
DO AS MANY AS YOU CAN PER VGET IN ORDER TO AVOID NEEDLESS OVERHEAD.
THE SECOND SPECIFIES WHICH SOURCE POOL YOU HAVE IN MIND; "SHARED"
CAUSES VGET TO LOOK ONLY IN THE SHARED POOL FOR THE VARIABLES,
WHILE "PROFILE" RESTRICTS IT TO LOOKING IN THE PROFILE POOL. A THIRD
CHOICE, "ASIS" WILL CAUSE IT TO LOOK IN BOTH, THE ORDER OF SEARCH
BEING THE SHARED POOL FIRST, AND IF IT'S NOT THERE THEN THE
PROFILE POOL.

     SAMPLES IN VARIOUS LANGUAGES:

