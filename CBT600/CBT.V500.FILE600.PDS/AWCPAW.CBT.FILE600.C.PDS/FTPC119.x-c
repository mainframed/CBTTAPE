#pragma title("FTPC119 - SMF type 119 (FTP) print/WTO")
#pragma comment(copyright,"FTPC119 - ©Paul Wells (Saudi Aramco) 2002")

/**********************************************************************
*
*  Name: FTPC119 (C language source)
*
*
*  Abstract:
*
*     A C language program which processes SMF type 119 FTP records.
*
*     The program has 2 modes of operation, selected by compile
*     and link edit options: EXITMODE and TESTMODE.
*
*     In EXITMODE, FTPC119 uses Systems Programming C facilities to run
*     as an SMF IEFU83/84 exit to format and WTO the SMF FTP records.
*
*     In TESTMODE, FTPC119 (load module FTPT119) runs as a standard
*     C main program in batch to print the SMF FTP records to
*     standard output.
*
*
*  Operation:
*
*     EXITMODE
*     --------
*     On entry R1 points to the address of the SMF record being
*     written by the system. The chkrec() function is called to
*     verify that it is a valid type 119 FTP record. Type 119
*     subtypes 3/70/72 are processed. All other records
*     are ignored and control returns to the system with RC=0
*     to allow the SMF record to be written.
*
*     For a valid FTP record an output area is allocated, dartn()
*     then a subtype-specific function is called to format
*     the SMF data to be suitable for WTO. The data fields processed
*     in the FTP Client (C), FTP Server (S) and FTP Server logon
*     failure (L) records is as follows.
*
*      WTO    C/S/L Description          SMF 119 Name  Example
*      ---    ----- -----------          ------------  -------
*      cm=    C/S/L Subcommand (RFC959)  C: fccmd      cm=STOR
*                                        S: fscmd
*                                        L: (derived)
*      ty=    S     File type            fsftype       ty=SEQ
*      lr=    C/S   Last reply to client C: fclreply   lr=250
*                                        S: fslreply
*      cp=    C     Local port           fcclport      cp=1064
*      cf=    C     Foreign port         fccrport      cf=21
*      rp=    S/L   Remote port          S: fscrport   rp=4608
*                                        L: ffrport
*      lp=    S/L   Local port           S: fsclport   lp=21
*                                        L: fflport
*      sa=    C/S/L C: Local IP address  C: fcclip     sa=10.13.80.11
*                   S: Remote IP address S: fsclip
*                   L: Remote IP address L: ffrip
*      sl=    C/S/L C: Remote IP address C: fccrip     sl=10.1.160.220
*                   S: Local IP address  S: fscrip
*                   L: Local IP address  L: fflip
*      su=    C/S/L C: Remote userid     C: fcruser    su=AWCPAW
*                   S: Local userid      S: fssuser
*                   L: Local userid      L: ffuserid
*             C/S   Data format          C: fctype     ASCII
*                                        S: fstype
*             C/S   Mode                 C: fcmode     Stream
*                                        S: fsmode
*             C/S   Structure            C: fcstruct   File
*                                        S: fsstruct
*             C/S   Dataset type         C: fcdstype   Seq
*                                        S: fsdsttype
*      trs=   C/S   Start time           C: fcstime    trs=08:09:08.87
*                                        S: fsstime
*      dur=   C/S   Duration             C: fcdur      dur=00:00:00.02
*                                        S: fsdur
*      tbc=   C/S   Byte count           C: fcbytes    tbc=5924
*                                        S: fsbytes
*      rt=    C/S   Rate                 (derived)     rt=296.20kb/sec
*      hst=   C/S   Host name            C: fchostname hst=tso03
*                                        S: fshostname
*      stc=   C     Local userid         fcluser       stc=AWCPAW
*      asn=   C     Address space        asname        asn=AWCPAWFT
*      dsn=   C/S   1st Dataset name     C: fcfilename dsn=AWCPAW.TEMP
*                                        S: fsfilename1
*      ds2=   S     2nd Dataset name     fsfilename2   ds2=AWCPAW.TEMP2
*      reas=  L     Logon failure reason ffreason      reas=1(password
*                                                      not valid)
*
*     Once formatted, the data is passed to an external assembler
*     subroutine to issue the WTO to the operating system. The
*     format of the output in the syslog will be similar
*     to the following.
*
*  FTPC119-02I FTP Client cm=RETR lr=226 cp=1146 cf=21 sa=10.1.160.220
*  sl=10.1.43.57 su=anonymou ASCII Stream File Seq trs=08:33:52.04
*  dur=00:00:04.09 tbc=160638 rt=39.28kb/sec hst=tso03 stc=AWCPAW
*  asn=AWCHOLDD dsn=SYSM.OS390.HOLDDATA(MONTH)
*
*     Once the WTO is issued the program frees storage for the
*     output area and returns to the operating system with RC=0
*     to allow the SMF record to be written.
*
*     TESTMODE
*     --------
*     In TESTMODE a 32K buffer is allocated for processing the
*     SMF records. The SMFDD DD is opened as an input file
*     and an SMF record is read from it. The chkrec() function is called
*     to verify that it is a valid type 119 FTP record. Type 119
*     subtypes 3/70/72 are processed. All other records
*     are ignored and control returns to the system. Rejected
*     records are reported to STDERR output.
*
*     For a valid FTP record an output area is allocated, dartn()
*     then a subtype-specific function is called to format
*     the SMF data to be suitable for output. The data fields are
*     identical to those described above for EXITMODE.
*
*     Once formatted, the data is output to STDOUT via the printf
*     function. The formating is almost identical to that described
*     above for EXITMODE. The difference being that the data is
*     prefixed by the system and date/time from the SMF record.
*
*     Control then returns back, another SMF record is read
*     and processed and so on until end of file. At EOF the SMFDD
*     is closed, storage is freed and control returns to the operating
*     system.
*
*
*  Environment:
*
*     IBM compatible mainframe
*
*     IBM OS/390, z/OS or subsequent operating system with C compiler
*
*     A minimum level of z/OS 1.2 (HIP6120 TCPIP fmid) is required
*     for the SMF type 119 formats supported by this program.
*
*     The program has been tested on a z/OS 1.2 system. On
*     z/OS 1.2 type 119 is the new TCPIP SMF record. Type 119
*     records are much better strucutured than 118 records and provide
*     IPv6 support and will be the basis for further enhancements by
*     IBM. Type 119 records can be produced in parallel with the 118
*     records for the time being at least.
*
*
*  Compilation:
*
*     EXITMODE & TESTMODE
*     -------------------
*     If the C compiler is available, sample JCL
*     AWCPAW.CBT.FILE600.C.PDS(FTPC119C) can be used to compile the
*     program. 2 object modules are output: FTPC119 for EXITMODE
*     and FTPT119 for TESTMODE.
*
*     The FTPC119 compile is for SPC (Systems Programming C)
*     and must specify the NOSTART option. It must not specify
*     RENT, since RENT is not supported in SPC. The code is naturally
*     re-entrant in any case.
*
*     The FTPT119 compile is a standard C main program compile
*     and can specify TEST for use with the LE debugger.
*
*
*  Installation:
*
*     EXITMODE & TESTMODE
*     -------------------
*     To ensure that SMF 119 FTP records are being created the
*     following tasks must be completed.
*
*      1) For client FTP records ensure that SYS1.TCPPARMS(PROFILE)
*         or equivalent includes this statement.
*
*         SMFCONFIG TYPE119 FTPCLIENT
*
*         This statement can be present in addition to
*         SMFCONFIG FTPCLIENT (for type 118 records) if required.
*
*      2) For all types of server records ensure that
*         SYS1.TCPPARMS(FTPSDATA) or equivalent contains the
*         statements as follows. (SMFJES and SMFSQL are optional)
*
*         SMF           TYPE119         ; SMF records (new type 119)
*         SMFJES        TYPE119         ; SMF filetype=jes (type 119)
*         SMFSQL        TYPE119         ; SMF filetype=sql (type 119)
*
*         These statements can be present in addition to those
*         for type 118 records, if required.
*
*     EXITMODE
*     --------
*     To install the SMF exits for EXITMODE, complete the following.
*
*      1) Ensure type 119 records are being written (above).
*
*      2) Link edit FTPC119 into a linklist library and refresh
*         LLA if necessary. Sample JCL is in
*         AWCPAW.CBT.FILE600.C.PDS(FTPC119L). The FTPC119 load module
*         is used in EXITMODE.
*
*         The FPTC119 link edit must specify CEE.SCEESPC
*         first in its SYSLIB concatenation for SPC support. Object
*         module EDCXSPRT must be explicitly included for the
*         SPC version of the sprintf function. Assembler object modules
*         MLWTO, SPRNTLL and EDCXFGS should also be included for the
*         mlwto(),sprntll() and malloc()/free() functions respectively.
*
*      3) Optionally install the SMF exit test program FTPCTST
*         which is contained in AWCPAW.CBT.FILE600.ASM.PDS. This
*         program can be used to test the WTO functions of the
*         program before it is installed as an SMF exit.
*
*      4) Ensure that exits IEFU83 and IEFU84 are being called
*         for all address spaces by coding these exits in
*         all SYS or SUBSYS statements in SYS1.PARMLIB(SMFPRMxx) e.g.
*
*         SYS(NOTYPE(..,..,..,..),
*             EXITS(IEFU83,IEFU84,.....,......,),..........,........)
*         SUBSYS(STC,NOTYPE(..,..,..,..),
*             EXITS(IEFU83,IEFU84,.....,......,),..........,........)
*
*         Including the exits in SUBSYS(STC) is required and ommitting
*         it is a likely reason for the exits not being invoked.
*
*         Note that IEFU83 is required for FTP server records
*         whereas IEFU84 is required for client records.
*         It is recommended to install both.
*
*      5) Update SYS1.PARMLIB(PROGxx) to load the exits
*         via the dynamic exit facility, e.g.
*
*         EXIT ADD EXITNAME(SYS.IEFU83) MODNAME(FTPC119)
*         EXIT ADD EXITNAME(SYS.IEFU84) MODNAME(FTPC119)
*
*      6) Dynamically install via the SETPROG operator
*         command e.g.
*
*         SETPROG EXIT,ADD,EXITNAME=SYS.IEFU83,MODNAME=FTPC119
*         SETPROG EXIT,ADD,EXITNAME=SYS.IEFU84,MODNAME=FTPC119
*
*         Or alternatively IPL to activate the exits via PROGxx.
*
*     TESTMODE
*     --------
*     FTPC119 should be link edited into any load library. Sample
*     JCL is in AWCPAW.CBT.FILE600.C.PDS(FTPC119L). The FTPT119 load
*     module is used in TESTMODE.
*
*
*  Invocation:
*
*     EXITMODE
*     --------
*     When installed (as recommended) as both an IEFU83 and IEFU84
*     system SMF exit, the program will be entered for every SMF record
*     written, except those written in cross memory mode that
*     would be processed by IEFU85. (There is no point installing
*     the program as an IEFU85 exit as there are no FTP records
*     written in this mode.)
*
*     In IEFU83/84 the linkage conventions are as follows.
*     (From z/OS MVS Installation Exits SA22-7593-01)
*
*      The contents of the registers on entry to IEFU83/84 are:
*
*      Register  Contents
*      0/2-12    Not applicable
*      1         Address of the parameter list
*      13        Register save area
*      14        Return address
*      15        Entry point address of IEFU84
*
*      Register 1 points to the following address:
*
*      Word 1    The address of the record that SMF is to write. The
*                first four bytes of this record are the
*                record descriptor word.
*
*      Upon return from IEFU83/84 processing, the register contents
*      must be:
*
*      Register  Contents
*      0-14      Same as at entry
*      15        One of the following return codes:
*
*      Value of 4 SMF is not to write the record to the SMF data set.
*      Other than 4 SMF is to write the record to the SMF data set.
*
*
*     The EXITMODE function can be tested by program FTPCTST without
*     installing FTPC119 as an SMF exit. FTPCTST is contained in
*     AWCPAW.CBT.FILE600.ASM.PDS and can be invoked by the JCL
*     in AWCPAW.CBT.FILE600.ASM.PDS(FTPCTSTJ). This JCL requires
*     an SMF input file of type 119 SMF records.
*
*
*     TESTMODE
*     --------
*     In TESTMODE FTPC119 (load module FTPT119) is invoked via
*     batch JCL and runs against an SMF input dataset.
*     Sample JCL can be found in
*     AWCPAW.CBT.FILE600.C.PDS(FTPT119J).
*     In TESTMODE FTPC119 (load module FTPT119) has 2 switches:
*       -r to resolve IP addresses via a nameserver
*       -e to echo the switch options to stdout
*
*     Sample JCL for an SMF type 119 extract is in
*     AWCPAW.CBT.FILE600.C.PDS(SMFX119J).
*
*
*  Notes:
*
*     Writeable static variables cannot be used in SPC mode because it
*     violates reentrancy. This type of variable is statically linked
*     into the program and if modified in SPC mode, an abend0c4 will
*     result.
*
*     In SPC mode, the program runs with #pragma (FTPC119,nolib)
*     which means that the program cannot use any C library functions.
*     This is essential because invocation of library functions may
*     involve external module loads or other SVCs which cannot be
*     tolerated in an SMF exit.
*
*     The record length of this source is greater than 80. The source
*     is best stored in a VB255 PDS.
*
*
*  Author: Paul Wells
*          Saudi Aramco Box 12959
*          Dhahran 31311
*          Saudi Arabia
*
*  Email:  paul.wells@aramco.com
*
*  History:
*
*     PW 06/Jun/2005 - Update for APAR PK01634 which added
*                      blank filling for the PDS member fields.
*     PW 22/Mar/2004 - smf119ft_fsdur and smf119ft_fcdur can be
*                      invalid if the ftp spans midnight.
*                      The fix for APAR PQ87028 is required to
*                      rectify this. The fmtrate routine was amended
*                      to attempt to trap invalid durations and report
*                      them as n/a.
*     PW 15/Mar/2004 - For subtype 72 (FTP server logon failure) the
*                      local IP address (sl=) and remote IP address
*                      (sa=) output fields were transposed. The
*                      ftff.smf119ft_ffrip and ftff.smf119ft_fflip
*                      SMF fields were swapped to be consistent
*                      with the documentation and the old SMF type 118
*                      subtype 72 output.
*     PW 07/Mar/2004 - Included comment to state that the RENT compile
*                      option is required in TESTMODE.
*     PW 01/Mar/2004 - In TESTMODE for SMF type 119 a program switch
*                      (-r) is added which causes IP addresses to
*                      be resolved to a domain name. The display will
*                      show the domain name (if found) followed by
*                      the IP address in brackets. A -e switch is also
*                      added to echo the switch options to stdout
*                      if required.
*     PW 11/Feb/2004 - IBM changed ftfc.smf119ft_fclreply from
*                      binary to EBCDIC with APAR PQ80090. The code
*                      was changed to allow for both data formats.
*     PW 30/Mar/2003 - Comments updated
*     PW 30/Oct/2002 - Changed fmtdsn function to use unsigned short
*                      int type rather than size_t.
*     PW 18/Sep/2002 - Original
*
***********************************************************************/

/* Include standard C header files */
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <limits.h>

#ifndef TESTMODE                       /* Not compiled for TESTMODE? */

 #define EXITMODE                      /* Default compile is EXITMODE (for SMF exit) */
 #pragma runopts("TRAP(OFF),HEAP(8K,32K,ANY),STACK(8K,32K,ANY)")
                                       /* TRAP(OFF) sets ESTAE/ESPIE off for SMF exit
                                          8K for Heap is sufficient in exit mode
                                          8K for Stack is sufficient in exit mode */
 #pragma environment(FTPC119,nolib)    /* Define entry point for
                                          SMF exit. The C library is
                                          not available. */
 #include <spc.h>                      /* SPC headers */

#else

 #define _OE_SOCKETS                   /* BSD-like socket interface */
 #include <unistd.h>                   /* Some standard Unix functions */
 #include <netdb.h>                    /* Network database operations */
 #include <sys/socket.h>               /* Sockets definitions */
 #include <decimal.h>                  /* Packed decimals used in TESTMODE */
 #include <stdio.h>                    /* File functions used in TESTMODE */

#endif

#include "ds119r12.h"                  /* z/OS 1.2 TCPIP SMF 119 record */

/* DSECTs from SMF record 119 not converted by C DSECT utility
   due to DSECTS having length 0 i.e.
EDC5515 00 HDRSKIP option value greater than length for section SMF119FT_FSHN
EDC5515 00 HDRSKIP option value greater than length for section SMF119FT_FSA1
EDC5515 00 HDRSKIP option value greater than length for section SMF119FT_FSA2
EDC5515 00 HDRSKIP option value greater than length for section SMF119FT_FCAN
 */
struct smf119ft_fshn {                 /* FTP Server Transfer Completion Hostname */
 unsigned char smf119ft_fshostnameÝ255¨;
};
struct smf119ft_fsa1 {                 /* FTP Server Transfer Completion 1st Associated Dataset File Name */
 unsigned char smf119ft_fsfilename1Ý1024¨;
};
struct smf119ft_fsa2 {                 /* FTP Server Transfer Completion 2nd Associated Dataset File Name */
 unsigned char smf119ft_fsfilename2Ý1024¨;
};
struct smf119ft_fcan {                 /* FTP Client Transfer Completion Associated Dataset File Name */
 unsigned char smf119ft_fcfilenameÝ1024¨;
};


typedef union {
#ifdef TESTMODE                        /* Compiled for TESTMODE? */
 struct {                              /* 1st union is a mapping for a 32K record buffer in TESTMODE */
  unsigned short int lrecl;            /* Record length */
  unsigned short int seg;
  char iobufferÝ32764¨;                /* Record buffer */
 } rec;
#endif
 struct {                              /* 2nd union in TESTMODE (1st in EXITMODE) is the whole SMF record */
  struct smf119header ft1;             /* SMF header */
  struct smf119sdefsect ft2;           /* SMF self defining section */
  struct smf119sd3triples ft3;         /* SMF section for record with at least 3 triples */
  struct smf119sd4triples ft4;         /* SMF section for record with at least 4 triples */
  struct smf119sd5triples ft5;         /* SMF section for record with 5 triples */
 } fts;
} SMFREC;

#define fth1 sr->fts.ft1               /* Shortcut for header */
#define fth2 sr->fts.ft2               /* Shortcut for self defining section */
#define fth3 sr->fts.ft3               /* Shortcut for self defining section 2 */
#define fth4 sr->fts.ft4               /* Shortcut for self defining section 3 */
#define fth5 sr->fts.ft5               /* Shortcut for self defining section 4 */

typedef struct {
 struct smf119ident ftsid;             /* TCPIP SMF record identification section */
} FTIDENT;
#define ftid srid->ftsid               /* Shortcut for ID section */

typedef struct {                       /* Output data buffer for WTO or printf */
  unsigned short int len;              /* Length of output */
  char lineÝ3072¨;                     /* Output data */
} WTOLINE;

/* Prototype global functions */
char *mnb(char *,const char *,unsigned int);
char *timrtn(char *,unsigned int);
char *fmtipv6(char *,unsigned short int,const char *);
char *fmtrate(char *,unsigned long long,unsigned int);
char *testhdr(SMFREC *,char *);
unsigned short int fmtdsn(char *,const char *,const char *,const char *,unsigned short int,unsigned short int);
void sprntll(char *,long long);       /* External format 64 bit integer function */
int ftpc119a(SMFREC *);
#define __isleap(year)    \
 ((year) % 4 == 0 && ((year) % 100 != 0 || (year) % 400 == 0))


/* The following is defined in SMF exit mode only.*/
#ifdef EXITMODE                        /* Compiled for SMF exit mode? */

void mlwto(WTOLINE *);                 /* Multi-line WTO assembler function */

 #include "div@bsd.h"                  /* Non-library version of div() for EXITMODE.
                                          Required because we cannot call C library functions in an SMF exit.*/
#else
int ftpt119a(int,char **);             /* TESTMODE entry function */
char runflag=0;                        /* run flags (Switches) in writable static area (requires RENT compile option) */
 #define rf_error 0x01                 /* switch error switch */
 #define rf_resolve 0x02               /* resolve switch */
 #define rf_ques 0x20                  /* -? */
 #define rf_echo 0x40                  /* echo some messages to stdout */
#endif


/* main()/FTPC119()
   Main program entry points */
#ifdef TESTMODE                        /* Compiled for TESTMODE ?*/
int main(int argc,char *argvÝ¨) {      /* Standard C entry point for TESTMODE */
#else                                  /* Else SMF exit mode */
int FTPC119() {                        /* FTPC119 entry point for SMF exit mode ? */
#endif

 SMFREC *smfptr;                       /* Pointer to SMF data */
 int rc=0;

#ifdef TESTMODE                        /* Compiled for TESTMODE ?*/
 char ch1Ý255¨;

 if(ftpt119a(argc,argv)) {             /* Call TESTMODE entry */
  if(runflag&rf_error) return -1;      /* return -1 if error */
  else return 0;
 }
 if((runflag&rf_resolve)&&gethostname(ch1,sizeof(ch1))) {
  runflag&=(255-rf_resolve);
  fprintf(stderr,"FTPC119 - resolve suppressed due to failure of gethostname call\n");
 }

 smfptr=malloc(sizeof(SMFREC));        /* Alloc storage for SMF record */
 if(!smfptr) {                         /* Storage OK ? */
  fprintf(stderr,"FTPC119 - malloc for smfptr %u bytes failed\n",sizeof(SMFREC));
  return(-1);                          /* Error if sotrage alloc failure */
 }
 rc=ftpc119a(smfptr);                  /* Call SMF record processing routine */
 free(smfptr);                         /* Free the storage */
#else                                  /* Else SMF exit mode */
 smfptr=*(SMFREC **)__xregs(1);        /* In SMF exit SMF record address is pointed to by Reg 1 */
 ftpc119a(smfptr);                     /* Call SMF record processing routine */
#endif

 return(rc);                           /* Return rc (rc only meaningful in TESTMODE) */
}


/* ftpc119a()
   Main SMF record processing routine */
int ftpc119a(SMFREC *smfptr) {

 WTOLINE *datline;                     /* Pointer to output data */
 int chkrec(SMFREC *,unsigned int);    /* Prototype function */
 void dartn(SMFREC *,WTOLINE *);       /* Prototype function */

#ifdef TESTMODE                        /* Compiled for TESTMODE ?*/
 unsigned short int lrecl;             /* SMF record length */
 unsigned int recctr=0;                /* Record counter */
 char recflag=0;                       /* FTP record found flag */
 FILE *fp;                             /* File pointer */
#endif

 datline=malloc(sizeof(WTOLINE));      /* GETMAIN output area */

#ifdef TESTMODE                        /* Compiled for TESTMODE ?*/
 fp=fopen("dd:SMFDD","rb,type=record"); /* Open file */
 if(!fp) {
  fprintf(stderr,"FTPC119 - dd:SMFDD open failed\n");
  return(-1);                          /* Error if open not OK */
 }

 do {
  lrecl=fread(smfptr->rec.iobuffer,1,sizeof(smfptr->rec.iobuffer),fp); /* Read SMF input file */
  if(!lrecl) continue;                 /* If no record continue do loop */
  else recctr++;                       /* Increment record count */
  smfptr->rec.lrecl=lrecl+4;           /* Set real record length */
  if(chkrec(smfptr,recctr)) continue;  /* If not valid FTP SMF record, continue do loop */
  else recflag=1;                      /* Set record found flag */
  dartn(smfptr,datline);               /* Format data in the record */
 } while(!feof(fp));                   /* Exit loop at EOF */

 if(!recflag) {                        /* Any calid records found? */
  fprintf(stderr,"FTPC119 - no valid FTP SMF records in dd:SMFDD\n");
  return(4);                           /* Set RC4 if no records */
 }

 fclose(fp);                           /* Close input file */
#endif

#ifdef EXITMODE                        /* Compiled for SMF exit mode? */
 if(chkrec(smfptr,0)) return(0);       /* If not a valid record exit program */
 dartn(smfptr,datline);                /* Format data in the record */
 mlwto(datline);                       /* Call multi-line WTO routine */
#endif

 free(datline);                        /* Free output area */

 return(0);                            /* Normal return RC0 */
}


/* chkrec()
   Check that the SMF record is a valid FTP type 119 record */
int chkrec(SMFREC *sr,unsigned int recctr) {

 unsigned short int subtype;

 if(fth1.smf119hdtype!=119) {          /* Type 119 record ? */
#ifdef TESTMODE                        /* Compiled for TESTMODE? */
  fprintf(stderr,"FTPC119 - SMFDD record #%u SMF type %u %s",
   recctr,fth1.smf119hdtype,"ignored - not TCPIP type 119\n");
#endif
  return(1);                           /* Return RC1 (skip) */
 }

 subtype=*((unsigned short int *)fth1.smf119hdsubtype); /*  Get SMF record subtype */

 switch(subtype) {                     /* Check for FTP subtype */
  case 3: case 70: case 72:
   break;
  default:                             /* Default not an FTP subtype */
#ifdef TESTMODE                        /* Compiled for TESTMODE? */
   fprintf(stderr,"FTPC119 - SMFDD record #%u SMF type %u subtype %u %s",
    recctr,fth1.smf119hdtype,subtype,
    "ignored - not an FTP subtype\n");
#endif
   return(1);                          /* Return RC1 (skip) */
 }

 return(0);                            /* Return RC0 (process) */
}


/* dartn()
   Call function to format the SMF record for WTO/printf */
void dartn(SMFREC *sr,WTOLINE *dl) {

 int st03rtn(SMFREC *,char *);         /* Prototype function */
 int st70rtn(SMFREC *,char *);         /* Prototype function */
 int st72rtn(SMFREC *,char *);         /* Prototype function */
 unsigned short int len,subtype;
 char databufÝ4096¨;

 subtype=*((unsigned short int *)fth1.smf119hdsubtype); /*  Get SMF record subtype */

 if(subtype==smf119hdst_ftpclient) {   /* FTP client record ? */
  st03rtn(sr,databuf);                 /* Yes, call subtype 3 function */
 }
 else if(subtype==smf119hdst_ftpserver) { /* FTP server record ? */
  st70rtn(sr,databuf);                 /* Yes, call subtype 70 function */
 }
 else if(subtype==smf119hdst_ftplogonf) { /* FTP logon record  ? */
  st72rtn(sr,databuf);                 /* Yes, call subtype 72 function */
 }

#ifdef TESTMODE                        /* Compiled for TESTMODE? */
 printf("%s\n",databuf);               /* Output the data */
#endif

 strcpy(dl->line,databuf);             /* Copy data to output buffer */
 dl->len=strlen(dl->line);             /* Set length of data */

return;
}


/* st03rtn()
   Format SMF type 119 subtype 3 (FTP client) */
int st03rtn(SMFREC *sr,char *currbuf) {

 FTIDENT *srid=0;                      /* TCPIP SMF record identification section */
 typedef struct {                      /* FTP Client Transfer Completion */
  struct smf119ft_fc ftsfc;
 } FT_FC;
 FT_FC *srd1=0;
#define ftfc srd1->ftsfc               /* Shortcut */

 typedef struct {                      /* FTP Client Transfer Completion Associated Dataset File Name */
  struct smf119ft_fcan ftsfcan;
 } FT_FCAN;
 FT_FCAN *srd2=0;
#define ftfcan srd2->ftsfcan           /* Shortcut */

 typedef struct {                      /* FTP Client Transfer Completion SOCKS section */
  struct smf119ft_fcso ftsfcso;
 } FT_FCSO;
 FT_FCSO *srd3=0;
#define ftfcso srd3->ftsfcso           /* Shortcut */

 unsigned short int len,tripleft;
 char ch1Ý255¨,ch2Ý255¨,ch3Ý80¨,ch4Ý80¨,
  outfmÝ7¨,outmoÝ11¨,outstÝ5¨,outdtÝ11¨;

 tripleft=*((unsigned short int *)fth2.smf119sd_trn); /* Get no. of triples */

 if(tripleft) {                        /* Any more triples ? */
  if(*((unsigned short int *)fth2.smf119idlen)) /* If length > 0 then set pointer to this triple */
   srid=(FTIDENT *)((char *)sr+*((unsigned int *)fth2.smf119idoff));
  tripleft-=1;                         /* Decrement triple count */
 }
 if(tripleft) {                        /* Any more triples ? */
  if(*((unsigned short int *)fth2.smf119s1len)) /* If length > 0 then set pointer to this triple */
   srd1=(FT_FC *)((char *)sr+*((unsigned int *)fth2.smf119s1off));
  tripleft-=1;                         /* Decrement triple count */
 }
 if(tripleft) {                        /* Any more triples ? */
  if(*((unsigned short int *)fth3.smf119s2len)) /* If length > 0 then set pointer to this triple */
   srd2=(FT_FCAN *)((char *)sr+*((unsigned int *)fth3.smf119s2off));
  tripleft-=1;                         /* Decrement triple count */
 }
 if(tripleft) {                        /* Any more triples ? */
  if(*((unsigned short int *)fth4.smf119s3len)) /* If length > 0 then set pointer to this triple */
   srd3=(FT_FCSO *)((char *)sr+*((unsigned int *)fth4.smf119s3off));
  tripleft-=1;                         /* Decrement triple count */
 }

#ifdef TESTMODE                        /* Compiled for TESTMODE? */
 len=sprintf(currbuf,                  /* Format system id, date/time for TESTMODE */
  "%s ",testhdr(sr,ch1));
 currbuf+=len;                         /* Bump output buffer */
#endif

 len=sprintf(currbuf,                  /* Format command */
  "%s %s%s ",
  "FTPC119-02I FTP Client",
  "cm=",mnb(ch1,ftfc.smf119ft_fccmd,sizeof(ftfc.smf119ft_fccmd)));
 currbuf+=len;                         /* Bump output buffer */

 /* APAR PQ80090 code */
 if(*((unsigned int *)ftfc.smf119ft_fclreply) > 4026531839) {
  len=sprintf(currbuf,                  /* Format last reply */
   "%s%s ",
   "lr=",mnb(ch1,ftfc.smf119ft_fclreply,sizeof(ftfc.smf119ft_fclreply)));
  currbuf+=len;                         /* Bump output buffer */
 }
 else {
  len=sprintf(currbuf,                  /* Format last reply */
   "%s%u ",
   "lr=",*((unsigned int *)ftfc.smf119ft_fclreply));
  currbuf+=len;                         /* Bump output buffer */
 }

 len=sprintf(currbuf,                  /* Format ports */
  "%s%u %s%u ",
  "cp=",*((unsigned short int *)ftfc.smf119ft_fcclport),
  "cf=",*((unsigned short int *)ftfc.smf119ft_fccrport));
 currbuf+=len;                         /* Bump output buffer */

 switch(ftfc.smf119ft_fctype) {        /* Format data format */
  case smf119ft_fctypeascii: strcpy(outfm," ASCII"); break;
  case smf119ft_fctypeebcdic: strcpy(outfm," EBCDIC"); break;
  case smf119ft_fctypeimage: strcpy(outfm," Bin"); break;
  case smf119ft_fctypedbyte: strcpy(outfm," DBCS"); break;
  case smf119ft_fctypeucs2: strcpy(outfm," UCS-2"); break;
  default: sprintf(outfm," fm=%c\0",ftfc.smf119ft_fctype);
 }
 switch(ftfc.smf119ft_fcmode) {        /* Format mode */
  case smf119ft_fcmodeblock: strcpy(outmo," Block"); break;
  case smf119ft_fcmodecmpress: strcpy(outmo," Cmprs"); break;
  case smf119ft_fcmodestream: strcpy(outmo," Stream"); break;
  default: sprintf(outmo," mo=%c\0",ftfc.smf119ft_fcmode);
 }
 switch(ftfc.smf119ft_fcstruct) {      /* Format structure */
  case smf119ft_fcstructfile: strcpy(outst," File"); break;
  case smf119ft_fcstructrec: strcpy(outst," Rec"); break;
  default: sprintf(outst," st=%c\0",ftfc.smf119ft_fcstruct);
 }
 switch(ftfc.smf119ft_fcdstype) {      /* Format file type */
  case smf119ft_fcdstypeseq: strcpy(outdt," Seq"); break;
  case smf119ft_fcdstypepds: strcpy(outdt," PDS"); break;
  case smf119ft_fcdstypehfs: strcpy(outdt," HFS"); break;
  default: sprintf(outdt," dt=%c\0",ftfc.smf119ft_fcdstype);
 }


 len=sprintf(currbuf,                  /* Format IP addrs, userid, file type flags, start time */
  "%s%s %s%s %s%s%s%s%s%s %s%s ",
  "sa=",fmtipv6(ch1,sizeof(ch1),ftfc.smf119ft_fcclip),
  "sl=",fmtipv6(ch2,sizeof(ch2),ftfc.smf119ft_fccrip),
  "su=",
  mnb(ch3,ftfc.smf119ft_fcruser,sizeof(ftfc.smf119ft_fcruser)),
  outfm,outmo,outst,outdt,
  "trs=",timrtn(ch4,*((unsigned int *)ftfc.smf119ft_fcstime)));
 currbuf+=len;                         /* Bump output buffer */

 len=sprintf(currbuf,                  /* Format rate, host name, userid, jobname */
  "%s %s%s %s%s %s%s",
  fmtrate(ch1,
   *((unsigned long long *)ftfc.smf119ft_fcbytes),
   *((unsigned int *)ftfc.smf119ft_fcdur)),
  "hst=",mnb(ch4,ftfc.smf119ft_fchostname,sizeof(ftfc.smf119ft_fchostname)),
  "stc=",mnb(ch2,ftfc.smf119ft_fcluser,sizeof(ftfc.smf119ft_fcluser)),
  "asn=",mnb(ch3,ftid.smf119ti_asname,sizeof(ftid.smf119ti_asname)));
 currbuf+=len;                         /* Bump output buffer */

 if(srd3) {                            /* SOCKS triple present ? */
  len=sprintf(currbuf,                 /* Format SOCKS information */
   " %s%s %s%s %s%u",
   "sip=",fmtipv6(ch1,sizeof(ch1),ftfcso.smf119ft_fccip),
   "spt=",*((unsigned short int *)ftfcso.smf119ft_fccport),
   "spr=",ftfcso.smf119ft_fccprot);
  currbuf+=len;                        /* Bump output buffer */
 }

 if(srd2) {                            /* DSN triple present ? */
  len=fmtdsn(currbuf," dsn=",ftfcan.smf119ft_fcfilename,ftfc.smf119ft_fcm1,*((unsigned short int *)fth3.smf119s2len),sizeof(ftfc.smf119ft_fcm1)); /* Copy dataset name */
  currbuf+=len;                        /* Bump output buffer */
 }

return(0);
}


/* st70rtn()
   Format SMF type 119 subtype 70 (FTP server) */
int st70rtn(SMFREC *sr,char *currbuf) {

 FTIDENT *srid=0;                      /* TCPIP SMF record identification section */
 typedef struct {                      /* FTP Server Transfer Completion */
  struct smf119ft_fs ftsfs;
 } FT_FS;
 FT_FS *srd1=0;
#define ftfs srd1->ftsfs               /* Shortcut */

 typedef struct {                      /* FTP Server Transfer Completion Hostname */
  struct smf119ft_fshn ftsfshn;
 } FT_FSHN;
 FT_FSHN *srd2=0;
#define ftfshn srd2->ftsfshn           /* Shortcut */

 typedef struct {                      /* FTP Server Transfer Completion First Associated Dataset File Name */
  struct smf119ft_fsa1 ftsfsa1;
 } FT_FSA1;
 FT_FSA1 *srd3=0;
#define ftfsa1 srd3->ftsfsa1           /* Shortcut */

 typedef struct {
  struct smf119ft_fsa2 ftsfsa2;        /* FTP Server Transfer Completion Second Associated Dataset File Name */
 } FT_FSA2;
 FT_FSA2 *srd4=0;
#define ftfsa2 srd4->ftsfsa2           /* Shortcut */

 unsigned short int len,tripleft;
 char ch1Ý255¨,ch2Ý255¨,ch3Ý80¨,ch4Ý80¨,
  outfmÝ7¨,outmoÝ11¨,outstÝ5¨,outdtÝ11¨;

 tripleft=*((unsigned short int *)fth2.smf119sd_trn); /* Get no. of triples */

 if(tripleft) {                        /* Any more triples ? */
  if(*((unsigned short int *)fth2.smf119idlen)) /* If length > 0 then set pointer to this triple */
   srid=(FTIDENT *)((char *)sr+*((unsigned int *)fth2.smf119idoff));
  tripleft-=1;                         /* Decrement triple count */
 }
 if(tripleft) {                        /* Any more triples ? */
  if(*((unsigned short int *)fth2.smf119s1len)) /* If length > 0 then set pointer to this triple */
   srd1=(FT_FS *)((char *)sr+*((unsigned int *)fth2.smf119s1off));
  tripleft-=1;                         /* Decrement triple count */
 }
 if(tripleft) {                        /* Any more triples ? */
  if(*((unsigned short int *)fth3.smf119s2len)) /* If length > 0 then set pointer to this triple */
   srd2=(FT_FSHN *)((char *)sr+*((unsigned int *)fth3.smf119s2off));
  tripleft-=1;                         /* Decrement triple count */
 }
 if(tripleft) {                        /* Any more triples ? */
  if(*((unsigned short int *)fth4.smf119s3len)) /* If length > 0 then set pointer to this triple */
   srd3=(FT_FSA1 *)((char *)sr+*((unsigned int *)fth4.smf119s3off));
  tripleft-=1;                         /* Decrement triple count */
 }
 if(tripleft) {                        /* Any more triples ? */
  if(*((unsigned short int *)fth5.smf119s4len)) /* If length > 0 then set pointer to this triple */
   srd4=(FT_FSA2 *)((char *)sr+*((unsigned int *)fth5.smf119s4off));
  tripleft-=1;                         /* Decrement triple count */
 }

#ifdef TESTMODE                        /* Compiled for TESTMODE? */
 len=sprintf(currbuf,                  /* Format system id, date/time for TESTMODE */
  "%s ",testhdr(sr,ch1));
 currbuf+=len;                         /* Bump output buffer */
#endif

 len=sprintf(currbuf,                  /* Format command, file type,last reply, ports */
  "%s %s%s %s%s %s%s %s%u %s%u ",
  "FTPC119-01I FTP Server",
  "cm=",mnb(ch1,ftfs.smf119ft_fscmd,sizeof(ftfs.smf119ft_fscmd)),
  "ty=",mnb(ch2,ftfs.smf119ft_fsftype,sizeof(ftfs.smf119ft_fsftype)),
  "lr=",mnb(ch3,ftfs.smf119ft_fslreply,sizeof(ftfs.smf119ft_fslreply)),
  "rp=",*((unsigned short int *)ftfs.smf119ft_fscrport),
  "lp=",*((unsigned short int *)ftfs.smf119ft_fsclport));
 currbuf+=len;                         /* Bump output buffer */

 if(memcmp(ftfs.smf119ft_fscmd,"REN",3)&&
  memcmp(ftfs.smf119ft_fscmd,"DELE",4)) { /* Not rename/delete ? */
  switch(ftfs.smf119ft_fstype) {       /* Format data format */
   case smf119ft_fstypeascii: strcpy(outfm," ASCII"); break;
   case smf119ft_fstypeebcdic: strcpy(outfm," EBCDIC"); break;
   case smf119ft_fstypeimage: strcpy(outfm," Bin"); break;
   case smf119ft_fstypedbyte: strcpy(outfm," DBCS"); break;
   case smf119ft_fstypeucs2: strcpy(outfm," UCS-2"); break;
   default: sprintf(outfm," fm=%c\0",ftfs.smf119ft_fstype);
  }
  switch(ftfs.smf119ft_fsmode) {       /* Format mode */
   case smf119ft_fsmodeblock: strcpy(outmo," Block"); break;
   case smf119ft_fsmodecmpress: strcpy(outmo," Cmprs"); break;
   case smf119ft_fsmodestream: strcpy(outmo," Stream"); break;
   default: sprintf(outmo," mo=%c\0",ftfs.smf119ft_fsmode);
  }
  switch(ftfs.smf119ft_fsstruct) {     /* Format structure */
   case smf119ft_fsstructfile: strcpy(outst," File"); break;
   case smf119ft_fsstructrec: strcpy(outst," Rec"); break;
   default: sprintf(outst," st=%c\0",ftfs.smf119ft_fsstruct);
  }
  switch(ftfs.smf119ft_fsdsttype) {    /* Format file type */
   case smf119ft_fsdstypeseq: strcpy(outdt," Seq"); break;
   case smf119ft_fsdstypepds: strcpy(outdt," PDS"); break;
   case smf119ft_fsdstypehfs: strcpy(outdt," HFS"); break;
   default: sprintf(outdt," dt=%c\0",ftfs.smf119ft_fsdsttype);
  }
 }
 else {                                /* Else set nulls */
  *outfm='\0';
  *outmo='\0';
  *outst='\0';
  *outdt='\0';
 }

 len=sprintf(currbuf,                  /* Format IP addrs, userid, file type flags, start time */
  "%s%s %s%s %s%s%s%s%s%s %s%s",
  "sa=",fmtipv6(ch1,sizeof(ch1),ftfs.smf119ft_fsclip),
  "sl=",fmtipv6(ch2,sizeof(ch2),ftfs.smf119ft_fscrip),
  "su=",
  mnb(ch3,ftfs.smf119ft_fssuser,sizeof(ftfs.smf119ft_fssuser)),
  outfm,outmo,outst,outdt,
  "trs=",timrtn(ch4,*((unsigned int *)ftfs.smf119ft_fsstime)));
 currbuf+=len;                         /* Bump output buffer */

 if(memcmp(ftfs.smf119ft_fscmd,"REN",3)&&
  memcmp(ftfs.smf119ft_fscmd,"DELE",4)) { /* Not rename/delete ? */
  len=sprintf(currbuf,                  /* Format rate */
   " %s",
   fmtrate(ch1,
    *((unsigned long long *)ftfs.smf119ft_fsbytes),
    *((unsigned int *)ftfs.smf119ft_fsdur)));
  currbuf+=len;                        /* Bump output buffer */
 }

 if(srd2) {                            /* Hostname triple present ? */
  len=sprintf(currbuf," hst=");
  currbuf+=len;                        /* Bump output buffer */
  strncpy(currbuf,ftfshn.smf119ft_fshostname,*((unsigned short int *)fth3.smf119s2len)); /* Copy host name */
  currbuf+=*((unsigned short int *)fth3.smf119s2len);
  *currbuf=0;
 }

 if(srd3) {                            /* 1st DSN triple present ? */
  len=fmtdsn(currbuf," dsn=",ftfsa1.smf119ft_fsfilename1,ftfs.smf119ft_fsm1,*((unsigned short int *)fth4.smf119s3len),sizeof(ftfs.smf119ft_fsm1)); /* Copy 1st DSN */
  currbuf+=len;                        /* Bump output buffer */
  if(srd4) {                           /* 2nd DSN triple present ? */
   len=fmtdsn(currbuf," ds2=",ftfsa2.smf119ft_fsfilename2,ftfs.smf119ft_fsm2,*((unsigned short int *)fth5.smf119s4len),sizeof(ftfs.smf119ft_fsm2)); /* Copy 2nd DSN */
   currbuf+=len;                       /* Bump output buffer */
  }
 }

return(0);
}


/* st72rtn()
   Format SMF type 119 subtype 72 (FTP server logon failure) */
int st72rtn(SMFREC *sr,char *currbuf) {

 FTIDENT *srid=0;                      /* TCPIP SMF record identification section */
 typedef struct {                      /* FTP Server Logon Failure */
  struct smf119ft_ff ftsff;
 } FT_FF;
 FT_FF *srd1=0;
 #define ftff srd1->ftsff              /* Shortcut */

 unsigned short int len,tripleft;
 char ch1Ý255¨,ch2Ý255¨,ch3Ý80¨;

 tripleft=*((unsigned short int *)fth2.smf119sd_trn); /* Get no. of triples */

 if(tripleft) {                        /* Any more triples ? */
  if(*((unsigned short int *)fth2.smf119idlen)) /* If length > 0 then set pointer to this triple */
   srid=(FTIDENT *)((char *)sr+*((unsigned int *)fth2.smf119idoff));
  tripleft-=1;                         /* Decrement triple count */
 }
 if(tripleft) {                        /* Any more triples ? */
  if(*((unsigned short int *)fth2.smf119s1len)) /* If length > 0 then set pointer to this triple */
   srd1=(FT_FF *)((char *)sr+*((unsigned int *)fth2.smf119s1off));
  tripleft-=1;                         /* Decrement triple count */
 }

#ifdef TESTMODE                        /* Compiled for TESTMODE? */
 len=sprintf(currbuf,                  /* Format system id, date/time for TESTMODE */
  "%s ",testhdr(sr,ch1));
 currbuf+=len;                         /* Bump output buffer */
#endif

 len=sprintf(currbuf,                  /* Format ports */
  "%s %s%u %s%u ",
  "FTPC119-03I FTP Server cm=LOGN",
  "lp=",*((unsigned short int *)ftff.smf119ft_fflport),
  "rp=",*((unsigned short int *)ftff.smf119ft_ffrport));
 currbuf+=len;                         /* Bump output buffer */

 len=sprintf(currbuf,                  /* Format IP addrs, userid failure reason */
  "%s%s %s%s %s%s %s%u",
  "sa=",fmtipv6(ch1,sizeof(ch1),ftff.smf119ft_ffrip),
  "sl=",fmtipv6(ch2,sizeof(ch2),ftff.smf119ft_fflip),
  "su=",
  mnb(ch3,ftff.smf119ft_ffuserid,sizeof(ftff.smf119ft_ffuserid)),
  "reas=",ftff.smf119ft_ffreason);
 currbuf+=len;                         /* Bump output buffer */

 switch(ftff.smf119ft_ffreason) {      /* Format failure reason text */
  case smf119ft_ffreasoninvalid: strcpy(currbuf,"(password not valid)"); break;
  case smf119ft_ffreasonexpired: strcpy(currbuf,"(password expired)"); break;
  case smf119ft_ffreasonrevoked: strcpy(currbuf,"(userid revoked)"); break;
  case smf119ft_ffreasonnoaccess: strcpy(currbuf,"(no server access)"); break;
  case smf119ft_ffreasonexit: strcpy(currbuf,"(FTCHKPWD rejected logon)"); break;
  case smf119ft_ffreasonexcess: strcpy(currbuf,"(excessive bad passwords)"); break;
  case smf119ft_ffreasongroupid: strcpy(currbuf,"(groupid process failed)"); break;
  case smf119ft_ffreasonunknown: strcpy(currbuf,"(userid is unknown)"); break;
  default: ;
 }

return(0);
}


/* fmtipv6()
   Format an IP address in (either V4 or V6) */
char *fmtipv6(char *out,unsigned short int ilen,const char *in) {

 unsigned long long ipw1w2=*(unsigned long long *)in;
 unsigned int ipw3=*(((unsigned int *)in)+2);
 unsigned short int remlen=ilen,tlen;
 char *outpos=out;
#ifdef TESTMODE                        /* Compiled for TESTMODE? */
 struct hostent *hp=0;
#endif

 if((!ipw1w2)&&(ipw3=65535)) {              /* IPv4 address ? */
#ifdef TESTMODE                        /* Compiled for TESTMODE? */
  if(runflag&rf_resolve)
   hp=gethostbyaddr(((unsigned char *)in)+12,4,AF_INET);
  if(hp) {
   tlen=strlen(hp->h_name);
   if(remlen>(tlen+1)) {
    outpos+=sprintf(outpos,"%s(",hp->h_name);
    remlen-=(tlen+1);
   }
  }
  if(remlen>17) {
#endif
   outpos+=sprintf(outpos,                  /* Format IPv4 address */
    "%u.%u.%u.%u",
    *(((unsigned char *)in)+12),
    *(((unsigned char *)in)+13),
    *(((unsigned char *)in)+14),
    *(((unsigned char *)in)+15));
#ifdef TESTMODE                        /* Compiled for TESTMODE? */
   if(hp) outpos+=sprintf(outpos,"%s",")");
  }
#endif
 }
 else {                                     /* Else IPv6 address */
  sprintf(outpos,
   "%04X:%04X:%04X:%04X:%04X:%04X:%04X:%04X", /* Format IPv6 address */
   *((unsigned short int *)in),
   *(((unsigned short int *)in)+1),
   *(((unsigned short int *)in)+2),
   *(((unsigned short int *)in)+3),
   *(((unsigned short int *)in)+4),
   *(((unsigned short int *)in)+5),
   *(((unsigned short int *)in)+6),
   *(((unsigned short int *)in)+7));
 }

 return out;
}


/* fmtrate()
   Format the duration and data transmission rate */
char *fmtrate(char *out,
 unsigned long long inbytes,
 unsigned int indur) {

 double dur=indur,bytes=inbytes,rate=0;
 char *outrate="kb/sec",ch1Ý80¨,*outpos=out;
 unsigned short int len;
 div_t x1;

 /* Maximum duration accepted is about 31 days to intercept
    invalid durations prior to the fix for APAR PQ87028 */
 if(dur>0x0FFFFFFF) {                   /* > 31:01:39:14.55 ? */
  dur=0;
  len=sprintf(outpos,                   /* Format duration */
   "%s ",
   "dur=n/a");
 }
 else {
  len=sprintf(outpos,                   /* Format duration */
   "%s%s ",
   "dur=",timrtn(ch1,(unsigned int)dur));
 }
 outpos+=len;                          /* Bump output area */

 if(dur) {                             /* duration > 0 ? */
  rate=(bytes/(dur/100))/1000;         /* Set rate in kb/sec */
  if(rate>=1000) {                     /* Rate > 1000 kb/sec */
   rate/=1000;                         /* Yes, set rate in mb/sec */
   outrate="mb/sec";
  }
 }

 sprntll(ch1,inbytes);                 /* Format 64 bit byte count */

 if(*ch1) {                            /* Running on z/Arch and returned value ? */
  len=sprintf(outpos,"%s%s ","tbc=",ch1); /* On z/OS values up to 9223372036854775807 formatted correctly */
 }
 else {                                /* Else, not running on z/Arch so use old method */
  if(*((unsigned int *)&inbytes)) {    /* Bytes > 4294967295 ? */
/* Different code for EXITMODE and TESTMODE because
   sprintf type FP cannot be used in SPC mode without
   the library. APAR PQ45794 */
#ifdef TESTMODE                        /* Compiled for TESTMODE? */
   len=sprintf(outpos,"%s%.2e ","tbc=",bytes); /* > 4294967295 so in TESTMODE we can use sprintf FP formatting */
#else
   len=sprintf(outpos,"tbc=(>4gb)");   /* > 4294967295 but in EXITMODE we just cop out */
#endif
  }
  else len=sprintf(outpos,"%s%u ","tbc=",*((unsigned int *)&inbytes+1)); /* < 4294967295 so format right half of 64 bit int */
 }
 outpos+=len;                          /* Bump output area */

/* Different code for EXITMODE and TESTMODE because
   sprintf type FP cannot be used in SPC mode without
   the library. APAR PQ45794 */
#ifdef TESTMODE                        /* Compiled for TESTMODE? */
 if(rate>0) sprintf(outpos,"%s%.2f%s","rt=",rate,outrate); /* Format rate */
 else strcpy(outpos,"rt=n/a");
#else
 if(!(rate>0)||((rate*100)>UINT_MAX)) strcpy(outpos,"rt=n/a"); /* Rate*100 exceeds unsigned max ? */
 else {
  x1=div(((unsigned int)(rate*100+.5)),100); /* Determine rate in SMF exit mode */
  sprintf(outpos,"%s%u.%02u%s","rt=",x1.quot,x1.rem,outrate); /* Format rate */
 }
#endif

 return out;                           /* Return output string */
}


/* fmtdsn()
   Format a dataset name and member */
unsigned short int fmtdsn(char *out,const char *dsntag,const char *indsn,const char *inmem,unsigned short int dsnlen,unsigned short int memlen) {

 char *outpos=out,ch1Ý80¨;
 unsigned short int len,len2=0;

 len=sprintf(outpos,dsntag);
 outpos+=len; len2+=len;

 strncpy(outpos,indsn,dsnlen);
 outpos+=dsnlen; len2+=dsnlen;

/* 2005/06/06 Update for APAR PK01634 which added
   blank filling */
 if(*inmem&&!(*inmem==' ')) {
  len=sprintf(outpos,
   "%c%s%c",
   '(',mnb(ch1,inmem,memlen),')');
  outpos+=len; len2+=len;
 }
 else *outpos=0;

 return len2;
}


#ifdef TESTMODE                        /* Compiled for TESTMODE? */
/* ftpt119a()
   TESTMODE entry function */
int ftpt119a(int argc,char *argvÝ¨) {

 int x=argc-1,retval=0;
 char *ptr;

 if(!x) return retval;                   /* return 0 if no switches */

 for(x=1;x<argc;x++) {                   /* loop through switches */
  if((*argvÝx¨=='-')) {                  /* valid switch ? */
   for(ptr=argvÝx¨+1;*ptr;ptr++) {       /* loop through each switch */
    switch(*ptr) {                       /* select switches */
     case '?':                           /* -? switch?*/
      runflag|=rf_ques;                  /* set ques flag */
      retval=-1;                         /* set err flag */
      break;                             /* skip */
     case 'r':                           /* resolve switch?*/
      runflag|=rf_resolve;               /* set resolve flag */
      break;                             /* skip */
     case 'R':                           /* resolve switch?*/
      runflag|=rf_resolve;               /* set resolve flag */
      break;                             /* skip */
     case 'e':                           /* echo switch?*/
      runflag|=rf_echo;                  /* set echo flag */
      break;                             /* skip */
     case 'E':                           /* echo switch?*/
      runflag|=rf_echo;                  /* set echo flag */
      break;                             /* skip */
     default:                            /* all else is error */
      fprintf(stderr,"FTPC119 - Invalid switch %s\n",ptr);
      runflag|=rf_error;                 /* set err flag */
      retval=-1;                         /* set err flag */
    }
    if(retval) break;             /* skip rest of switch if error */
   }
   if(retval) break;              /* skip remaining switches if error */
  }
  else {                                  /* not valid switch */
   fprintf(stderr,"FTPC119 - Invalid switch %s\n",argvÝx¨);
   runflag|=rf_error;                 /* set err flag */
   retval=-1;                         /* set err flag */
   break;                        /* skip remaining switches if error */
  }
 }                                       /* end loop through switches */

 if(retval) {                            /* switches OK ? */
  if(!(runflag&rf_ques)) {               /* -? on ? */
   fprintf(stderr,"FTPC119 - Error in switches\n");
  }
  fprintf(stderr,"FTPC119 - Switches: -re\n");
 }
 else {
  if(runflag&rf_echo) {
   printf("FTPC119 - SMF type 119 FTP batch print program\n");
   if(runflag&rf_resolve)
    printf("FTPC119 - resolve IP address switch is on\n");
   else
    printf("FTPC119 - resolve IP address switch is off\n");
  }
 }

 return retval;
}


/* testhdr()
   Add the system id and date/time to message for TESTMODE */
char *testhdr(SMFREC *sr,char *out) {

 char *currbuf=out,ch1Ý80¨;
 unsigned short int len;
 div_t x1;
 struct tm tim;
 struct tm *datconv(int,int,struct tm *);

 x1=div(*((decimal(7,0) *)fth1.smf119hddate),1000); /* Get Juilan date stored in packed decimal format */
 datconv(x1.quot,x1.rem,&tim);         /* Convert date to C tm structure format */

 memcpy(currbuf,fth1.smf119hdsid,sizeof(fth1.smf119hdsid)); /* Copy system id */
 currbuf+=sizeof(fth1.smf119hdsid);    /* Bump output buffer */

 len=sprintf(currbuf,                  /* Format system id, date/time for TESTMODE */
  " %u/%02u/%02u %s",
  tim.tm_year+1900,tim.tm_mon+1,tim.tm_mday,
  timrtn(ch1,*((unsigned int *)fth1.smf119hdtime)));
 currbuf+=len;                         /* Bump output buffer */

 return out;
}


/* datconv()
   Convert a date from Julan format into C tm structure format */
struct tm *datconv(int yr,int jd,struct tm *tim) {

 char montabÝ12¨={31,28,31,30,31,30,31,31,30,31,30,31};
 char monctr=0;
 int jdctr=1,dyctr=1;

 memset((char *)tim,'\0',sizeof(tim)); /* Initialise tm structure */
 tim->tm_yday=jd-1;
 tim->tm_year=yr;
 yr+=1900;
 montabÝ1¨+=__isleap(yr);        /* Set Feb to 29 days on leap years */

 for(;jdctr<=jd;dyctr++,jdctr++) {
  tim->tm_mon=monctr;
  tim->tm_mday=dyctr;
  if(montabÝmonctr¨==dyctr) {
   dyctr=0;
   monctr++;
  }
 }

 return tim;
}
#endif


/* mnb()
   Copy a space delimited string up to a max length */
char *mnb(char *out,const char *in,unsigned int len) {

 char *ptr1=out;

 for(;*in!=' '&&*in&&len;ptr1++,in++,len--) *ptr1=*in;
 *ptr1='\0';

 return out;
}


/* timrtn()
   Format a binary time in HH:MM:SS.TH format */
char *timrtn(char *tim_out,unsigned int tim_in) {

 div_t x1,x2,x3;

 x1=div(tim_in,60*60*100);
 x2=div(x1.rem,60*100);
 x3=div(x2.rem,100);
 sprintf(tim_out,"%02u:%02u:%02u.%02u\0",
  x1.quot,x2.quot,x3.quot,x3.rem);

 return tim_out;
}


