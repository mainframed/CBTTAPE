//MSC0195$ JOB (H2803302,S08,,4),'STORAGE MAP',REGION=1M,TIME=(,4)
//  EXEC ASMPCL,PDS='CAREY.LOAD',NAME=MSC0195$
//P.SYSIN DD *
         TITLE 'STGMAP -- Display Major MVS/XA Virtual Storage Areas.'
*---------------------------------------------------------------------*
*
*  CSECT NAME: STGMAP
*
*     PURPOSE: DISPLAYS WHERE MAJOR MVS/XA VIRTUAL STORAGE AREAS
*              BEGIN AND END.
*
*  ATTRIBUTES: ENTRY AND EXIT IN AMODE(24): AMODE(31) EXCEPT WHEN
*              USING QSAM SERVICES.
*              NON-REENTRANT, UNAUTHORIZED, PROBLEM STATE AND KEY.
*
*     Warning: This module contains lowercase text. Use caution
*              when editing.
*
*     HISTORY:  11/8/85 -- JCB -- ORIGINALLY WRITTEN
*
*---------------------------------------------------------------------*
         SPACE 1                      |
         MACRO ,                      |
&TAG     GENTAG &TEXT                 |
         AIF   ('&TAG' EQ '').BADTAG  |
&TAG     DS  X                        |
#GT&SYSNDX  DC  C&TEXT                |
         ORG   &TAG                   |
         DC    AL1(L'#GT&SYSNDX.)     |
         ORG ,                        |
         MEXIT ,                      |
.BADTAG  MNOTE 8,'GENTAG REQUIRES A LABEL.'
         MEND ,                       |
         SPACE 1                      |
 BLOCK         NAME=STGMAP,           |                                *
               TYPE=PROGRAM,          |                                *
               OPTIONS=(*NORENT,XA,MODE), Turn on AMODE support        *
               AMODE=24,              | AMODE on entry                 *
               SMWA=STCSMWA           | SMWA for AMODE switching
         SPACE 1                      |
  OPEN  (SYSPRINT,(OUTPUT))           | get something to write with
  IF    (TREG,R15,NZ)                 | if sysprint dd is missing
   ABEND 1                            |  figure it out: you're a
  ENDIF                               |   system programmer.
  BLOCK NAME=PROCESS,AMODE=31         | Switch to amode(31)
   FILL  STCLINE,C' '                 |
   CALLSUB SIMPLE_PRINT               | write blank line
   MVC   STCTAG(L'STCHDRA),STCHDRA    |
   MVC   STCDASH(L'STCHDRB),STCHDRB   |
   CALLSUB SIMPLE_PRINT               | write header line
   FILL  STCTAG,C' ',LENGTH=L'STCHDRA |
   FILL  STCDASH,C'-'                 | write top of the 'box'
   MVI   STCBAR1,C'|'                 |
   MVI   STCBAR2,C'|'                 |
   MVI   STCBAR3,C'|'                 |
   CALLSUB SIMPLE_PRINT               | write header line
   FILL  STCLINE,C' '                 |
         SPACE 1                      |
   L     R10,CVTPTR                   | base on cvt
   USING CVT,R10                      |
   L     R9,CVTSMEXT                  | base on 1st cvt extension
   USING CVTVSTGX,R9                  |
   L     R8,CVTGDA                    | base on gda. it's amode(31)
   USING GDA,R8                       | get how big private area is:
   L     R1,GDAECSA                   |  get a(ext. csa start)
   AL    R1,GDAECSAS                  |  add its size
   ST    R1,STCF                      |  that's it.
   CALLSUB     PRINT_LINE,            | print ext. private stuff       *
               (STCEPA,STCF,=X'7FFFFFFF'),  (assume top is 7fffffff)   *
               PL=(STCPL,12)          |
         SPACE 1                      |
   L     R1,GDAECSA                   | get the start
   ST    R1,STCF                      | save for amode 24 code
   AL    R1,GDAECSAS                  | add its size
   BCTR  R1,0                         | make it print 'xxxxfff' addr
   ST    R1,STCF+4                    | save that too
   CALLSUB     PRINT_LINE,            | print ext. csa numbers         *
               (STCECSA,STCF,STCF+4), |                                *
               PL=(STCPL,12)          |
         SPACE 1                      |
   IF    (CLC,CVTEMLPS,NE,=F'0')      | if there's some extended
    CALLSUB    PRINT_LINE,            |  mlpa around, print that.      *
               (STCEMLPA,CVTEMLPS,CVTEMLPE),                           *
               PL=(STCPL,12)          |
   ENDIF                              |
   CALLSUB     PRINT_LINE,            | print eflpa numbers            *
               (STCEFLPA,CVTEFLPS,CVTEFLPE),                           *
               PL=(STCPL,12)          |
   CALLSUB     PRINT_LINE,            | print eplpa numbers            *
               (STCEPLPA,CVTEPLPS,CVTEPLPE),                           *
               PL=(STCPL,12)          |
         SPACE 1                      |
   L     R1,GDAESQA                   | get where it starts
   ST    R1,STCF                      | stuff for amode 24 code
   AL    R1,GDAESQAS                  | add its length
   BCTR  R1,0                         | make it print xxxxfff address
   ST    R1,STCF+4                    | stuff
   CALLSUB     PRINT_LINE,            | print esqa numbers             *
               (STCESQA,STCF,STCF+4), |                                *
               PL=(STCPL,12)          |
         SPACE 1                      |
   CALLSUB     PRINT_LINE,            | print extended read/write      *
               (STCERWN,CVTERWNS,CVTERWNE),  nucleus numbers           *
               PL=(STCPL,12)          |
   CALLSUB     PRINT_LINE,            | print read-only nucleus        *
               (STCRON,CVTRONS,CVTRONE),     numbers. note this is     *
               PL=(STCPL,12)          |    what straddles 16m.
   CALLSUB     PRINT_LINE,            | print read/write nuc below     *
               (STCRWN,CVTRWNS,CVTRWNE),     16m numbers.              *
               PL=(STCPL,12)          |
         SPACE 1                      |
   L     R1,GDASQA                    |  get start address
   ST    R1,STCF                      |  save for amode(24) code
   AL    R1,GDASQASZ                  |  add ending address
   BCTR  R1,0                         |  make it print xxxxfff addr
   ST    R1,STCF+4                    |  save that too
   CALLSUB     PRINT_LINE,            | print sqa numbers.             *
               (STCSQA,STCF,STCF+4),  |                                *
               PL=(STCPL,12)          |
         SPACE 1                      |
   CALLSUB     PRINT_LINE,            | print plpa numbers             *
               (STCPLPA,CVTPLPAS,CVTPLPAE),                            *
               PL=(STCPL,12)          |
   CALLSUB     PRINT_LINE,            | print flpa numbers             *
               (STCFLPA,CVTFLPAS,CVTFLPAE),                            *
               PL=(STCPL,12)          |
   IF    (CLC,CVTMLPAS,NE,=F'0')      | if there's any mlpa around
    CALLSUB    PRINT_LINE,            |  print its stuff too.          *
               (STCMLPA,CVTMLPAS,CVTMLPAE),                            *
               PL=(STCPL,12)          |
   ENDIF                              |
         SPACE 1                      |
   L     R1,GDACSA                    |  get start address
   ST    R1,STCF                      |  save for later.
   LR    R5,R1                        |  save another copy.
   AL    R1,GDACSASZ                  |  add length
   BCTR  R1,0                         |  make it print xxxxfff addr
   ST    R1,STCF+4                    |  stuff.
   CALLSUB     PRINT_LINE,            | print csa numbers              *
               (STCCSA,STCF,STCF+4),  |                                *
               PL=(STCPL,12)          |
         SPACE 1                      |
   BCTR  R5,0                         | knock 1 off top of csa
   ST    R5,STCF                      | stuff for parmlist
   CALLSUB     PRINT_LINE,            | print private area numbers     *
               (STCPA,=F'4096',STCF), |                                *
               PL=(STCPL,12)          |
   CALLSUB     PRINT_LINE,            | print psa size for the         *
               (STCPSA,=F'0',=F'4095'),  hell of it                    *
               PL=(STCPL,12)          |
   FILL  STCLINE,C' '                 | blank line
   CALLSUB SIMPLE_PRINT               | write blank line
   MVC   STCLINE(L'TX1),TX1           | print messages about how
   CALLSUB SIMPLE_PRINT               |  to use csa value to see if
   MVC   STCLINE(L'TX2),TX2           |   csa growth is about to munch
   CALLSUB SIMPLE_PRINT               |    another 1M segment.
   MVC   STCLINE(L'TX3),TX3           |
   CALLSUB SIMPLE_PRINT               |
   FILL  STCLINE,C' '                 | final blank line
   CALLSUB SIMPLE_PRINT               | write blank line
  ENDBLK BLOCK=PROCESS                | end of amode 31 mainline
  CLOSE (SYSPRINT)                    | close up and quit.
 ENDBLK BLOCK=STGMAP,RC=0             |
         TITLE 'STGMAP -- Print a detail line'
*---------------------------------------------------------------------*
*
*  SUBROUTINE: PRINT_LINE
*     PURPOSE: WRITE A DETAIL LINE ABOUT AN AREA OF VIRTUAL STORAGE
*       INPUT: ON ENTRY, R1 POINTS TO ADDRESSES OF:
*                .. A(TAG TEXT)  -- INCLUDING LENGTH BYTE
*                .. A(AREA START) - WHERE SAID AREA BEGINS
*                .. A(AREA END)  -- WHERE SAID AREA STOPS
*      OUTPUT: DETAIL LINE WRITTEN TO SYSPRINT WITH ABOVE INFORMATION,
*              ALONG WITH SIZE OF AREA IN DECIMAL K.
*
*---------------------------------------------------------------------*
         SPACE 1                      |
 BLOCK       NAME=PRINT_LINE,         |                                *
               TYPE=SUBROUTINE,       |                                *
               SAVE=(R0,R15,STCSAVE), |                                *
               AMODE=24               |
  LM    R2,R4,0(R1)                   | load up parms
  FILL  STCLINE,C' '                  | wipe printline
  MVC   STCTAG,STCDOTS                | lay some dots in tag area
  MVI   STCBAR1,C'|'                  | put the bars in
  MVI   STCBAR2,C'|'                  |
  MVI   STCBAR3,C'|'                  |
  L8    R1,0(R2)                      | get length of tag
  BCTR  R1,0                          |  minus 1 for execute
  EXI   R1,(MVC,STCTAG(0),1(R2))      | move in tag
  LR    R1,R3                         | point r1 at start address
  CALLSUB CONVERT_HEX                 | convert to printable hex
  MVC   STCVAL1,STCUNPK               | move out starting value
  LR    R1,R4                         | point r1 at end address
  CALLSUB CONVERT_HEX                 | convert it too
  MVC   STCVAL2,STCUNPK               | move out to printline.
  L     R1,0(R4)                      | get end address value
  SL    R1,0(R3)                      | subtract starting address
  AL    R1,=F'1023'                   | round up 1k-1
  SRL   R1,10                         | divide by 1024
  CVD   R1,STCD                       | make it packed
  MVC  STCVAL3,=XL9'402020202020202120' lay out edit mask
  ED    STCVAL3,STCD+4                | make pretty decimal number
  MVI   STCVAL3+L'STCVAL3,C'K'        | hang a k on it
  PUT   SYSPRINT,STCLINE              |  and print it.
 ENDBLK BLOCK=PRINT_LINE              |
         TITLE 'STGMAP -- Simple print subroutine'
*---------------------------------------------------------------------*
*
*  ON ENTRY, STCLINE CONTAINS TEXT TO BE WRITTEN TO SYSPRINT.
*
*  THE ONLY REASON THIS IS A SUBROUTINE IS TO ALLOW THE MAIN PORTION
*  OF STGMAP TO RUN AMODE 31.
*
*---------------------------------------------------------------------*
 BLOCK       NAME=SIMPLE_PRINT,       |                                *
               TYPE=SUBROUTINE,       |                                *
               SAVE=(R14,STCR14),     |                                *
               AMODE=24               |
  PUT   SYSPRINT,STCLINE              |
 ENDBLK BLOCK=SIMPLE_PRINT            |
         TITLE 'STGMAP -- Hex-EBCDIC value converter'
*---------------------------------------------------------------------*
*
*  ON ENTRY, R1 -> A FULLWORD VALUE TO CONVERT.
*  ON EXIT, STCUNPK(8) WILL CONTAIN THE EDITED EBCDIC EQUIVALENT.
*  NO REGISTERS ARE SAVED: R1 AND R15 ARE DESTROYED.
*
*---------------------------------------------------------------------*
 BLOCK NAME=CONVERT_HEX,TYPE=SUBROUTINE
  UNPK  STCUNPK(9),0(5,R1)            | unpack 1r%
  TR    STCUNPK(8),STCHEXTR           | 'fa' -> 'c1', etc
  LA    R1,STCUNPK                    | eat the zeros off the front:
  LA    R15,L'STCUNPK-1               | make sure we can leave one
  LOOP  BCT                           | loop thru result:
   LEAVE LOOP=*,(CLI,0(R1),NE,C'0')   |  nonzero? quit.
   MVI   0(R1),C' '                   |  blank it out
   LA    R1,1(R1)                     |  next one
  ENDLOOP BCT,R15                     | go thru all but last one.
 ENDBLK BLOCK=CONVERT_HEX             |
*
STCLINE  DC    CL80' '                |
STCTAG   EQU   STCLINE+2,26           |
STCDASH  EQU   STCLINE+30,44          |
STCBAR1  EQU   STCLINE+29             |
STCVAL1  EQU   STCLINE+33,8           |
STCBAR2  EQU   STCLINE+46             |
STCVAL2  EQU   STCLINE+51,8           |
STCBAR3  EQU   STCLINE+61             |
STCVAL3  EQU   STCLINE+63,9           |
         SPACE 1                      |
STCHDRA  DC    C'MVS/XA Virtual Storage Map'
STCHDRB  DC    C'  Start Address |  End Address | Size in K'
STCDOTS  DC    C' . . . . . . . . . . . . .'
         SPACE 1                      |
TX1 DC C'    To determine the amount of storage available in common sto*
               rage'                  |
TX2 DC C'    below 16M before another 1M segment is allocated, subtract*
                the'                  |
TX3 DC C'    first CSA= value in IEASYS00 from the CSA size value shown*
                here.'                |
         SPACE 1                      |
STCEPA   GENTAG 'Extended Private Area '
STCECSA  GENTAG 'Extended CSA '       |
STCEMLPA GENTAG 'Extended MLPA '      |
STCEFLPA GENTAG 'Extended FLPA '      |
STCEPLPA GENTAG 'Extended PLPA '      |
STCESQA  GENTAG 'Extended SQA '       |
STCERWN  GENTAG 'Extended R/W Nucleus '
STCRON   GENTAG 'Read-Only Nucleus '  |
STCRWN   GENTAG 'Read-Write Nucleus ' |
STCSQA   GENTAG 'System Queue Area '  |
STCPLPA  GENTAG 'Pageable LPA '       |
STCFLPA  GENTAG 'Fixed LPA '          |
STCMLPA  GENTAG 'Modified LPA '       |
STCCSA   GENTAG 'Common Storage Area '
STCPA    GENTAG 'Private Area '       |
STCPSA   GENTAG 'Prefixed Save Area ' |
         SPACE 1                      |
STCSAVE  DS    16F                    |
STCSMWA  DS    2F                     |
STCR14   DS    F                      |
         SPACE 1                      |
         DS    0D                     |
STCF     DS    0F                     |
STCD     DS    D                      |
         SPACE 1                      |
STCPL    DS    3F                     |
         SPACE 1                      |
SYSPRINT DCB DDNAME=SYSPRINT,LRECL=80,RECFM=FB,BLKSIZE=6160,           *
               DSORG=PS,MACRF=PM      |
         SPACE 1                      |
STCUNPK  DS    CL8,C                  |
         DC    C'0123456789ABCDEF'    |
         ORG   *-256                  |
STCHEXTR DS    CL256                  |
         ORG   ,                      |
         LTORG                        |
         PRINT NOGEN                  |
CVTMAP   CVT   DSECT=YES              |
         IHAGDA                       |
         PRINT GEN                    |
         END   ,                      |
//C.SYSLIB DD
//         DD
//         DD DSN=SYS1.AMODGEN,DISP=SHR
//L.SYSIN  DD *
 ALIAS STGMAP                         |
 NAME MSC0195$(R)                     |
//
