//SALBERTK JOB CLASS=B,MSGCLASS=X,NOTIFY=XSDMN
//*
//*
//ASMHCL  PROC
//C      EXEC  PGM=IEV90,PARM=OBJECT,REGION=5M
//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR
//SYSUT1   DD  UNIT=(SYSDA,SEP=SYSLIB),SPACE=(CYL,(10,5)),DSN=&SYSUT1
//SYSPUNCH DD  SYSOUT=B,DCB=(BLKSIZE=800),SPACE=(CYL,(5,5,0))
//SYSPRINT DD SYSOUT=X,DCB=(BLKSIZE=3509),UNIT=(,SEP=(SYSUT1,SYSPUNCH))
//SYSLIN   DD  DISP=(,PASS),UNIT=SYSDA,SPACE=(CYL,(5,5,0)),            *
//             DCB=(BLKSIZE=400),DSN=&&LOADSET
//L    EXEC  PGM=IEWL,PARM='MAP,LET,LIST,NCAL',REGION=2M,COND=(8,LT,C)
//SYSLIN   DD  DSN=&&LOADSET,DISP=(OLD,DELETE)
//         DD  DDNAME=SYSIN
//SYSLMOD DD DISP=(,PASS),UNIT=SYSDA,SPACE=(CYL,(2,1,2)),DSN=&GOSET(GO)
//SYSUT1   DD  UNIT=SYSDA,SPACE=(CYL,(3,2)),DSN=&SYSUT1
//SYSPRINT DD  SYSOUT=X,DCB=(RECFM=FB,BLKSIZE=3509)
//  PEND
//*
//LOOK    EXEC ASMHCL
//C.SYSLIB DD DSN=SYS1.MACLIB,DISP=SHR
//         DD DSN=SYS1.MODGEN,DISP=SHR
//C.SYSIN DD *
         TITLE 'LOOK --  STORAGE ALTER/DISPLAY'
*
**
**       THIS VERSION OF LOOK SUPPORTS MULTIPLE ADDRESS SPACE
**       INVESTIGATION.
**
**       THIS VERSION DOES NOT YET SUPPORT ALTER CAPABILITY
**
**       THIS VERSION IS CONFIGURED TO RUN AND RESIDE ABOVE THE LINE
**
*
         MACRO
&N       HEX   &TO,&FROM
&N       UNPK  TEMP1(9),&FROM.(5,R6)
         MVC   &TO.(8,R4),TEMP1
         TR    &TO.(8,R4),HEXTAB
         MEND
LOOK     CSECT
LOOK     AMODE 31
LOOK     RMODE ANY
*  INITIALIZE THE PROGRAM
         SAVE  (14,12)
         LR    R11,R15                 PERMANENT BASE
         USING LOOK,R11
         LA    R9,2048(R11)            GET A SECOND BASE REG
         LA    R9,2048(R9)
         USING LOOK+4096,R9
         L     R1,16(0)             GET THE CVT
         L     R1,0(R1)             SHIFT REG ONCE AGAIN
         L     R1,4(R1)             GET THE CURRENT TCB
         L     R1,12(R1)            GET TCB + 12 TIOT ADDRESS
         CLC   0(5,R1),=C'XSDMN'
         BNE   ENDIT3
         GETMAIN R,LV=WORKLEN,SP=1,LOC=(BELOW,ANY)          XA
         LR    R10,R1
         LR    R2,R10                  WORK AREA START
         L     R3,=A(WORKLEN)          LENGTH TO CLEAR
         SR    R5,R5                   ZERO PAD BYTE, LENGTH 2
         MVCL  R2,R4                   CLEAR THE WORK AREA
         USING WORKAREA,R10
         LA    R4,QDINIT
         LA    R3,QDISPLN              GET LENGTH
         LA    R2,QDISPLAY             POINT AT START
         LR    R5,R3                   SET FROM LENGTH
         MVCL  R2,R4                   INIT DISPLAY
         ST    R13,SAVE+4              CHAIN THE SAVE AREAS
         LA    R15,SAVE
         ST    R15,8(R13)
         LR    R13,R15                 NEW SAVE AREA
         STM   R9,R11,BASE1        SAVE FIRST THREE REGS FOR AREA
         ST    R13,BASR13          AND ORIGINAL R13
         LA    R1,50*HISTLEN           GET LENGTH OF HIST TBL
         GETMAIN R,SP=2,LV=(1)
         ST    R1,HISTORY              SAVE ADDRESS
         STFSMODE ON,INITIAL=YES       TELL TSO WE ARE FULLSCREEN
*
*        SET SUPERVISOR MODE IF AUTHORIZED
*
         OI    FLAGS,NOAUTH            SET NOT AUTHORIZED
         L     R1,=A(WORKLN)           GET LENGTH OF CAS BUFFER
         ST    R1,CSALEN               SET LENGTH AND SP0
         TESTAUTH FCTN=1               ARE WE AUTHORIZED
         LTR   R15,R15
         BNZ   NOTAUTH                 IF NOT SKIP CODE
         MVI   CSALEN,241              SET CSA SP
         NI    FLAGS,255-NOAUTH        MARK AUTHORIZED
         MODESET MODE=SUP              SET TO SUP MODE
NOTAUTH  DS    0H
*
*        SETUP ESTAE IN CORRECT MODE
*
         ESTAE EREXIT,PARAM=(R10),MF=(E,ESTAE)
*
*        INITIALIZE ASID POINTERS
*
         MVC   ASIDLN,ASIDFMT          SET MESSAGE
         L     R1,16                   GET CVT
         L     R2,0(R1)                GET TCBWORDS
         L     R1,12(R2)               GET OLD ASCB ADDR (MINE)
         USING ASCB,R1
         MVC   MYASID,ASCBASID         MOVE IN MY ASID
         MVC   CURASID,MYASID
         DROP  R1
         XC    CSAASID,CSAASID         CLEAR THE CSA BUFFER INDIC
         XC    CSASTAR,CSASTAR
         XC    CSAEND,CSAEND
         L     R0,CSALEN               GET LENGTH AND SP FOR CSA BUFFER
         GETMAIN R,LV=(0)
         ST    R1,CSAWORK              SAVE ADDR OF CSA BUFFER
         LR    R8,R1                   SET PROPER POINTER
         USING WORK,R8
         MVC   MYTCB,4(R2)             SAVE ADDR OF MY TCB
         MVC   MYASCB,12(R2)           SAVE ADDR OF MY ASCB
         LA    R1,BUF                  POINT TO TRUE BUFFER
         ST    R1,CSABUF
         LA    R0,SRBCCD               POINT TO CSA SRB CODE AREA
         LA    R1,SRBCODE              AND LENGTH OF CODE
         LR    R3,R1
         LA    R2,D#SRBCD              POINT TO CSECT CODE
         MVCL  R0,R2                   MOVE SRB CODE TO CSA
         B     ISCAN1                  GO AND PROCESS
         DROP  R8
         EJECT
***********************************************************************
*
*   INPUT SCAN
*
***********************************************************************
         SPACE 2
ISCAN    CLC   SAVEASID,ASIDLN1        DID USER CHANGE ASID
         BE    ISCAN1                  NOPE
*
*        FORMAT AND SAVE USER ASID
*
         MVC   TEMP1(4),ASIDLN1        GET USER INFO
         OC    TEMP1(4),=CL4' '        MAKE UPPER CASE
         TR    TEMP1(4),HEXTAB         MAKE PACKABLE
         PACK  TEMP2(3),TEMP1(5)
         MVC   CURASID,TEMP2           GET NEW ASID
ISCAN1   MVC   INPSAVE,INPLINE         SAVE LAST USER INPUT
ISCAN2   LA    R3,INPLINE              POINT TO START OF INPUT
         LA    R1,SCANTAB              COMMAND TABLE
         NI    FLAGS,255-INDFLAG-IND31 TURN OFF INDIRECT FLAG
         MVC   MSGLINE,TITLE           CLEAR OUT ERROR MSG
SCANLOOP L     R2,4(R1)                GET TABLE ENTRY
         CLC   0(1,R1),ENDTAB          SEE IF END OF TABLE
         BE    NUMSCAN                 IF YES, ASSUME NUMERIC INPUT
         CLC   0(1,R1),INPLINE         SEE IF COMMAND FOUND
         BER   R2                      IF YES, GO TO COMM ROUINE
         LA    R1,8(R1)                NEXT ENTRY ADDRESS
         B     SCANLOOP
SCANTAB  DS    0F                      COMMAND TABLE
         DC    CL4' ',A(FORMAT)
         DC    CL4'I',A(INDIR)
         DC    CL4'J',A(INDIR31)
         DC    CL4'>',A(FWD)
         DC    CL4'<',A(BACK)
         DC    CL4'=',A(DEFINE)
         DC    CL4',',A(NUMSCAN)
         DC    CL4'M',A(MODE)
         DC    CL4'L',A(LINK)
         DC    CL4'O',A(OVERLAY)
         DC    CL4'R',A(REFRESH)
ENDTAB   DC    X'FF'                   END OF TABLE INDICATOR
         SPACE 2
***********************************************************************
*
*     FORMAT THE OUTPUT SCREEN
*
***********************************************************************
         SPACE 2
FORMAT   LA    R3,INPLINE              CURSOR ADDRESS
         MVC   INPLINE,BLANKS          CLEAR INPUT LINE
FORMAT2  BAL   R14,ERASE               CLEAR THE SCREEN
         LH    R2,CURRENT              HISTORY TABLE POINTER
         A     R2,HISTORY              POINT AT HISTORY TABLE ENTRY
         USING HIST,R2                 IDENTIFY HISTORY ENTRY FORMAT
         L     R4,HISTADDR             GET ADDRESS TO DISPLAY
         TM    HISTCBHP,X'80'          IS THIS A CB MAP IN USE
         BO    CBHIT                   IF SO THE PROCESS IT
         CLC   =X'7FFFFFFF',HISTCBHP   SUPPRESSED CB USAGE
         BE    NOCB
         DROP  R2
         SPACE 2
*----------------------------------------------------------------------
*
*        SEE IF CONTROL BLOCK MAP EXISTS
*
*----------------------------------------------------------------------
         SPACE 2
DUMP     L     R5,=V(CBMACS)           GET START OF INDEX
         LTR   R5,R5                   ANY VALUE
         BZ    NOCB                    NOPE
         USING CBH,R5                  ADDRESS THE CONTROL BLK HEADER
DUMPCB   CLC   =F'0',CBHNEXT           SEE IF END OF INDEX
         BE    NOCB                    IF YES, NO CB FOUND
         L     R2,CBHVOFF              GET CB IDENTIFIER OFFSET
         AR    R2,R4                   ADD DISPLAY ADDRESS
         SR    R3,R3                   CLEAR A REGISTER FOR IC
         IC    R3,CBHVLEN              GET LENGTH
         LR    R0,R3                   PUT IN 0 FOR GETSTOR
         LA    R1,DUMPDATA             TARGET ADDR
         BAL   R14,GETSTOR             FETCH THE DATA
         B     NOTCB                   BR IF NO DATA FOUND
         B     NOTCB                   BR IF PARTIAL DATA FOUND
         BCTR  R3,0                    GET MACHINE LENGTH
         EX    R3,CBFNDIT              LOOK FOR VALIDATION FIELD
         BE    CBHIT                   BR IF YES, CB WAS FOUND
NOTCB    L     R5,CBHNEXT              NEXT INDEX ENTRY
         B     DUMPCB                  AND CHECK FOR MORE CB'S
CBFNDIT  CLC   CBHVAL(*-*),DUMPDATA    SEE IF IDENTIFIER MATCH
         DROP  R5
         SPACE 2
*----------------------------------------------------------------------
*
* IF NO CONTROL BLOCK TO BE SHOWN, JUST USE DUMP FORMAT
*
*----------------------------------------------------------------------
         SPACE 2
NOCB     LR    R2,R4                   COPY ADDR TO DISPLAY
         TM    MODEFLAG,ALIGN          QUADWORD ALIGNMENT WANTED
         BZ    DUMPNOA                 BR IF NOT
         N     R2,=XL4'FFFFFFF0'       ROUND DOWN FOR DISPLAY
DUMPNOA  TM    MODEFLAG,MIDDUMP        PUT ADDR INCENTER OF SCREEN?
         BZ    DUMPNOM                 BR IF NOT
         SH    R2,=H'128'              IF YES, BACK UP QUAD WORDS
* R2 NOW HAS FIRST ADDRESS TO DISPLAY
DUMPNOM  LA    R0,256                  LENGTH TO FETCH
         LA    R1,DUMPDATA             TARGET ADDRESS
         BAL   R14,GETSTOR             GO FETCH THE DATA
         NOP   0                       RETURN IF NO DATA FOUND
         NOP   0                       RETURN IF PARTIAL DATA FOUND
         LA    R6,DUMPDATA             POINT TO DATA TO DISPLAY
         LA    R4,OUT1                 FIRST OUTPUT LINE ADDR
         LA    R5,16                   NO. OF LINES TO DISPLAY
DUMPLOOP EQU   *                       FORMAT THE DISPLAY
         STCM  R2,15,TEMP2             ADDRESS TO SHOW
         UNPK  TEMP1(9),TEMP2(5)       CONVERT BINARY TO HEX
         MVC   0(8,R4),TEMP1
         TR    0(8,R4),HEXTAB
         HEX   12,0                    CONVERT FIRST WORD TO HEX
         HEX   22,4                    SECOND WORD TO HEX
         HEX   32,8                    THIRD WORD
         HEX   42,12                   FOURTH AND LAST WORD TO HEX
         MVI   52(R4),C'*'             FRAME THE EBCDIC DISPLAY
         MVI   69(R4),C'*'             FRAME THE OTHER SIDE
         MVC   53(16,R4),0(R6)         COPY THE EBCDIC DATA
         TR    53(16,R4),VALCHAR       DELETE INVALID CHARS
         LA    R2,16(R2)               NEXT LINE ADDR
         LA    R6,16(R6)               NEXT DATA AREA
         LA    R4,80(R4)               NEXT OUTPUT LINE
         BCT   R5,DUMPLOOP             GO DO NEXT LINE
         SPACE 2
*----------------------------------------------------------------------
*
* NOW BLANK OUT THE SCREEN WHERE THE PAGE DIDN'T EXIST
*
*----------------------------------------------------------------------
         SPACE 2
         LA    R4,OUT1                 POINT TO FIRST OUTPUT LINE
         SH    R2,=H'256'              FIRST ADDRESS DISPLAYED
         LA    R5,16                   NUMBER OF LINES DISPLAYED
BLLOOP   LA    R15,15(R2)              LAST ADDRESS ON CURRENT LINE
         CLC   LOGOOD,HIGOOD           ARE WE IN A WRAP CONDITION
         BH    BLLP0                   YES SO SKIP NOLINE CHECK
         C     R2,HIGOOD               IF START>=HIGH
         BNL   NOLINE                     THEN BLANK ENTIRE LINE
BLLP0    C     R2,LOGOOD               IF START<LOW & END>=LOW
         BNL   BLLP1                      THEN HI GOOD AND LOW NEEDS
*                                                  BLANK
         C     R15,LOGOOD
         BNL   HIMIX
BLLP1    C     R2,HIGOOD               IF START<HIGH & END>HIGH
         BNL   BLLP2                      THEN LOW GOOD AND BLANK
*                                                HIGH
         C     R15,HIGOOD
         BH    LOWOK
BLLP2    DS    0H                      LINE OK OTHERWISE
         B     BLOOPEND
* BOTH LOW AND HIGH MISSING -- BLANK ENTIRE LINE
NOLINE   MVI   12(R4),C' '             START OF DATA
         MVC   13(57,R4),12(R4)        CLEAR THE LINE
         B     BLOOPEND                GO CHECK ANOTHER LINE
* BR HERE IF LOW END GOOD, HIGH MAY BE  MISSING
LOWOK    S     R15,HIGOOD              # OF BYTES TO BLANK
* THE FOLLOWING CODE TAKES CARE OF LOW STORAGE WRAP
         CH    R15,=H'15'              MORE THAN 15 BYTES TO CLEAR
         BH    BLOOPEND                IF YES, IT WRAPPED, NO CLEAR
         LR    R1,R15                  COPY # TO BLANK
         SRL   R1,2                    FIND # OF WORDS
         SLL   R1,1                    TWO BLANKS PER WORD
         AR    R1,R15                  ADD NUMBER OF HEX CHARS
         AR    R1,R15                  WHICH IS TWICE THE # OF BYTES
         LA    R6,50(R4)               POINT JUST AFTER HEX DATA
         SR    R6,R1                   FIRST BYTE TO CLEAR
         BCTR  R1,0                    REDUCE BY 1 FOR EXEXUTE
         EX    R1,CLEARMVC             CLEAR HEX SIDE
         LA    R6,69(R4)               POINT TO TRAILING *
         SR    R6,R15
         EX    R15,CLEARMVC            CLEAR EBCDIC AND *
         MVI   0(R6),C'*'              NOTE END OF EBCDIC DATA
         B     BLOOPEND                GO CHECK NEXT LINE
* COME HERE WHEN HI END GOOD AND LOW END MISSING
HIMIX    L     R15,LOGOOD              LOWEST GOOD ADDR
         SR    R15,R2                  NUMBER OF BYTES TO CLEAR
         LR    R1,R15                  COPY # TO CLEAR
         SRL   R1,2                    # OF WORDS TO CLEAR
         SLL   R1,1                    NUMBER OF IMBEDDED BLANKS
         AR    R1,R15                  ADD # OF HEX CHARS
         AR    R1,R15
         BCTR  R1,0                    REDUCE BY 1 FOR MVC
         LA    R6,12(R4)               START OF HEX DATA
         EX    R1,CLEARMVC             AND CLEAR THE HEX DATA
         LA    R6,52(R4)               POINT TO FIRST * ON LINE
         EX    R15,CLEARMVC            CLEAR * AND EBCDIC DATA
         LA    R6,52(R4,R6)            POINT TO FIRST CLEARED BYTE
         MVI   0(R6),C'*'              AND DROP IN A *
BLOOPEND LA    R4,80(R4)               POINT TO NEXT LINE
         LA    R2,16(R2)               ADDRESS ON NEXT LINE
         BCT   R5,BLLOOP               AND SCAN ALL LINES
         SPACE 2
*----------------------------------------------------------------------
*
*  PUT IN ARROWS TO POINT TO DESIRED DATA
*
*----------------------------------------------------------------------
         SPACE 2
         LA    R4,OUT1                 ADDR OF FIRST LINE
         TM    MODEFLAG,MIDDUMP        DOES IT BELONG IN THE MIDDLE
         BZ    ARRTOP                  BR IF NOT
         LA    R4,OUT9                 POINT TO MIDDLE LINE
ARRTOP   SR    R1,R1                   ASSUME NO QUADWORD ALIGNMENT
         TM    MODEFLAG,ALIGN          WAS ASSUMPTION CORRECT
         BZ    ARRALIGN                BR IF YES, ELSE GET OFFSET
         LA    R1,15                   MASK FOR LOW 4 BITS
         NR    R1,R2                   GET BYTE OFFSET FOR ARROW
* FIRST DO THE EBCDIC SIDE
ARRALIGN LA    R15,51(R4)              BYTE BEFORE FIRST *
         EX    R1,MOVEMVC              MOVE THE DATA BACK
         AR    R15,R1                  ADDR OF LAST BYTE MOVED
         MVI   1(R15),C'>'             PUT IN THE ARROW
* NOW MOVE THE HEX SIDE
         SR    R0,R0                   CLEAR HIGH ORDER BITS
         SLDL  R0,30                   WHICH WORD IS TO BE MOVED
         SRL   R1,30                   NUMBER OF BYTES TO BE MOVED
         LR    R15,R0                  COPY OFFSET OF WORD TO MOVE
         MH    R15,=H'10'              EACH WORD TAKES UP 10 BYTES
         LA    R15,10(R4,R15)          POINT IN FRONT OF WORD TO MOVE
         SLL   R1,R1                   NUMBER OF HEX DIGITS TO MOVE
         EX    R1,MOVEMVC              MOVE THE DATA BACK
         AR    R15,R1                  POINT TO PALCE FOR ARROW
         MVI   1(R15),C'>'             AND PUT IT THERE
* FALL  THRU TO SHOW THE SCREEN
         EJECT
*
* DISPLAY THE PAGE AND CHECK FOR END REQUEST
*
DISPLAY  UNPK  TEMP1(5),CURASID(3)     FORMAT CURRENT ASID
         MVC   ASIDLN1(4),TEMP1        AND PUT ON SCREEN
         TR    ASIDLN1(4),HEXTAB
         MVC   SAVEASID,ASIDLN1        SAVE FORMATED VERSION
         MVC   KEYS,KEY1               SETUP PFK
         MVC   KEYS+80,KEY2                 INFO LINE
*
TPUTSCRN DS    0H
         LA    R0,QDSLNG
         TPUT  QDSCREEN,(0),FULLSCR MF=(E,QTPUT)
         XC    INPLINE,INPLINE
         XC    PFREPLY,PFREPLY
         TGET  PFREPLY,69,ASIS MF=(E,QTGET)
         LR    R3,R1                   SAVE INPUT LENGTH
         CH    R15,=H'12'     IS INPUT LONGER THAN BUFFER?
         BNE   NOCLEAR        NO. CONTINUE.
         TCLEARQ INPUT        CLEAR THE QUEUE
NOCLEAR  DS    0H
         LA    R1,PFREPLY+3            POINT AT FIRST BYTE
         SH    R3,=H'3'                ADJUST LENGTH
*
**       HANDLE ASID IF NECESSARY
*
         CLC   0(3,R1),=X'1140F9'      IS THIS ASID MODIFICATION
         BNE   NOASID                  NO SO SKIP
         LA    R1,3(R1)                POINT AT FIRST BYTE
         SH    R3,=H'3'                ADJUST LENGTH
         LR    R2,R1                   SAVE START ADDRESS
ASIDLOOP CLI   0(R1),X'11'             LOOK FOR START FIELD
         BE    HAVEASID
         LA    R1,1(R1)                BUMP POINTER
         BCT   R3,ASIDLOOP
HAVEASID LR    R15,R1                  MOVE POINTER
         SR    R15,R2                  GET LENGTH
         BZ    NOASID
         MVC   ASIDLN1,=CL4' '
         LA    R4,ASIDLN1+4            GET TO ADDRESS +4
         SR    R4,R15                      - REAL LENGTH
         BCTR  R15,0                   GET MACHINE LENGTH
         EX    R15,MOVERPLY
NOASID   DS    0H
         LTR   R3,R3                   ANY DATA LEFT
         BZ    ENDINP
         CLC   0(3,R1),=X'11C15C'      CHECK FOR START OF FIELD
         BNE   ENDINP                  IF NOT HERE THEN SKIP
         LA    R1,3(R1)                POINT AT FIRST BYTE
         SH    R3,=H'3'                ADJUST LENGTH
         LR    R2,R1                   SAVE START ADDRESS
RPLYLOOP CLI   0(R1),X'11'             LOOK FOR START FIELD
         BE    HAVERPLY
         LA    R1,1(R1)                BUMP POINTER
         BCT   R3,RPLYLOOP
HAVERPLY LR    R15,R1                  MOVE POINTER
         SR    R15,R2                  GET LENGTH
         BZ    NOASID
         LA    R4,INPLINE              GET TO ADDRESS
         BCTR  R15,0                   GET MACHINE LENGTH
         EX    R15,MOVERPLY
ENDINP   OC    INPLINE,=CL63' '        MAKE UPPERCASE
         SPACE 2
         IC    R4,PFCODE
         XR    R5,R5
         CLI   PFCODE,X'7D'      ENTER?
         BE    ENTER             /YES - TREAT AS ENTER
         CLI   PFCODE,X'F0'      TEST-REQ/SYS-REQ?
         BE    ENTER             /YES - TREAT AS ENTER
         CLI   PFCODE,X'01'      OTHER KIND OF SYS-REQ?
         BE    ENTER             /YES - TREAT AS ENTER
         CLI   PFCODE,X'6C'      PA1?
         BE    ENDIT             /YES - TERMINATE
         CLI   PFCODE,X'6E'      PA2?
         BE    TPUTSCRN          /YES - GO RESHOW SCREEN
         CLI   PFCODE,X'6B'      PA3?  (TCAM GENERATED)
         BE    TPUTSCRN          /YES - GO RESHOW SCREEN
         N     R4,=X'0000000F'   EXTRACT PF-KEY NUMBER
         CH    R4,=H'12'
         BH    ENTER            "ENTER" KEY
         BCTR  R4,0
         SLL   R4,2              TIMES SIZE OF AN ENTRY
         B     PFKEYTAB(R4)
PFKEYTAB B     HELP                    PF1
         B     DISPLAY                 PF2
         B     ENDIT                   PF3    QUIT
         B     DISPLAY                 PF4
         B     REPEAT                  PF5    REPEAT COMMAND
         B     DISPLAY                 PF6
         B     UP                      PF7    SCROLL UP
         B     DOWN                    PF8    SCROLL DOWN
         B     BACK                    PF9    SCROLL BACKWARDS
         B     FWD                     PF10   SCROLL FORWARDS
         B     DISPLAY                 PF11
         B     DISPLAY                 PF12
MOVERPLY MVC   0(0,R4),0(R2)           **EXECUTED**
         EJECT
ENTER    CLC   =C'END',INPLINE         SEE IF END TYPED
         BNE   ISCAN                   IF NOT, GO LOOK AT INPUT
* CLEAN UP AND GO AWAY
ENDIT    LM    R0,R1,CSALEN            GET SP, LEN, AND ADDR
         LTR   R1,R1                   WAS BUFFER GOTTEN
         BZ    ENDIT1                  NOPE
         FREEMAIN R,LV=(0),A=(1)       FREE BUFFER
ENDIT1   TM    FLAGS,NOAUTH            ARE WE AUTHORIZED
         BO    ENDIT2                  NOPE
         MODESET MODE=PROB             RESET MODE
ENDIT2   DS    0H
         STFSMODE OFF                  RESET FULLSCREEN
         L     R13,SAVE+4              GET ORIGINAL SAVE AREA
         FREEMAIN R,LV=WORKLEN,SP=1,A=(R10)
ENDIT3   RETURN (14,12),RC=0
         EJECT
*----------------------------------------------------------------------
*
* CBHIT  -- CONTROL BLOCK FORMATTING ROUTINE
* AT ENTRY:
*              R4 HAS ADDRESS TO DISPLAY (OFFSET 0 - MAIN SEGMENT)
*              R5 HAS CONTROL BLOCK HEADER ADDRESS
*
*----------------------------------------------------------------------
         SPACE 2
CBHIT    LH    R2,CURRENT              GET HISTORY TABLE POINTER
         A     R2,HISTORY              GET ENTRY ADDRESS
         USING HIST,R2                 SETUP FORMAT OF ENTRY
         ICM   R6,15,HISTCBSP          LAST SEGMENT DISPLAYED
         BNZ   CBHIT2                  BR IF A CONTINUING DISPLAY
         USING CBH,R5                  ADDRESS HEADER BLOCK
         L     R6,CBHCBSP              ELSE GET FIRST SEG ADDRESS
         ST    R6,HISTCBSP             AND SAVE FOR LATER
         ST    R5,HISTCBHP             AND SAVE FOR LATER
         OI    HISTCBHP,X'80'          NOTE CB FORMAT ROUTINE IN USE
*   GET BLOCK NAME AND HANDLE ANY SEGMENT INDIRECTION
CBHIT2   DS    0H
         USING CBS,R6
         L     R5,HISTCBHP             POINT TO CB HEADER
         MVC   MSGLINE+36(8),CBHNAME   MOVE IN CB NAME
         STCM  R4,15,TEMP2             SAVE ADDRESS OF BLOCK
         UNPK  TEMP1(9),TEMP2(5)          AND CONVERT
         TR    TEMP1(8),HEXTAB               TO HEX
         MVC   MSGLINE+26(8),TEMP1     MOVE IN ADDRESS OF BLOCK
         DROP  R2,R5
         CLC   =H'0',CBSILEN           IS THIS SEGMENT INDIRECT
         BE    CBHIT3                  IF NOT THEN SKIP CODE
         LH    R0,CBSILEN              GET LENGTH TO FETCH (ALWAYS 4
         LA    R1,DUMPDATA             WHERE TO PUT IT
         LH    R2,CBSIOFF              GET INDIRECT OFFSET
         AR    R2,R4                   GET TRUE MAIN BLOCK ADDRESS
         BAL   R14,GETSTOR             GET THE INDIRECT WORD
         B     NOCB                    BR IF NO DATA FETCHED
         B     NOCB                    BR IF PARTIAL DATA FETCHED
         L     R4,DUMPDATA             RESET THE ADDR TO DUMD
         LH    R2,CURRENT
         A     R2,HISTORY              GET ADDR OF ENTRY
         ST    R4,HISTSADR-HIST(R2)    SAVE SEGMENT ADDRESS
CBHIT3   DS    0H
         LH    R0,CBSDLEN              LENGTH TO FETCH
         LA    R1,DUMPDATA             TARGET ADDRESS
         LH    R2,CBSDOFF              OFFSET TO FETCH
         AR    R2,R4                   ADD START OF CB ADDRESS
         BAL   R14,GETSTOR             GO FETCH THE DATA
         B     NOCB                    BR IF NO DATA FETCHED
         B     NOCB                    BR IF PARTIAL DATA FETCHED
         LA    R5,OUT1-80              START OF SCREEN
         LA    R2,DUMPDATA             POINT TO DATA BUFFER
         SH    R2,CBSDOFF              BACKUP TO VIRTUAL CB ORIGIN
         LA    R6,CBSLEN(R6)           POINT AT FIRST CB FIELD
         USING CBF,R6
CBLOOP   DS    0H
         LH    R1,CBFLINE              GET LINE NUMBER
         MH    R1,=H'80'               TIMES LINE LENGTH
         AH    R1,CBFCOLM              PLUS THE COLUMN NUMBER
         AR    R1,R5                   PLUS START OF LINE
         MVC   0(8,R1),CBFNAME         SET NAME FIELD
         LA    R1,8(R1)                SKIP NAME
         LH    R14,CBFOFFS             GET OFFSET INTO CB
         AR    R14,R2                  GET ADDRESS IN FETCHED DATA
         SR    R15,R15                 CLEAR REGISTER
         IC    R15,CBFDLEN             GET LENGTH OF DATA ITEM
*   FORMAT CHARACTER AS DISPLAY AND REST AS HEX
         CLI   CBFTYPE,C'C'            WHAT IS TYPE
         BNE   CBFLOOP                 IF NOT CHARACTER THEN DO HEX
         BCTR  R15,0                   GET MACHINE LENGTH
         EX    R15,CBMVC               MOVE IN DATA
         B     CBFEND
CBFLOOP  MVC   TEMP2(1),0(R14)         MOVE IN DATA BYTE
         UNPK  TEMP1(3),TEMP2(2)
         TR    TEMP1(2),HEXTAB
         MVC   0(2,R1),TEMP1           MOVE IN CONVERTED BYTE
         LA    R1,2(R1)                BUMP OUTPUT ADDRESS
         LA    R14,1(R14)              BUMP INPUT ADDRESS
         BCT   R15,CBFLOOP             KEEP LOOPINT
CBFEND   LA    R6,CBFLEN(R6)           BUMP TO NEW FIELD
         CLC   0(4,R6),=F'0'           END OF SEGMENT
         BNE   CBLOOP                  IF NOT THEN KEEP GOING
         B     DISPLAY                 ALL DONE SO DISPLAY IT
         DROP  R6
         SPACE 1
CBMVC    MVC   0(0,R1),0(R14)          **EXECUTED** MOVE IN DATA
         SPACE 2
*----------------------------------------------------------------------
*
*  GET ADDRESS OF CURRENT CONTROL BLOCK SEGMENT
*     ON EXIT R2 = ADDR OF THIS CONTROL BLOCK SEGMENT
*
*----------------------------------------------------------------------
GETCURAD DS    0H
         LH    R2,CURRENT              GET HIST TABLE OFFSET
         A     R2,HISTORY              GET ENTRY
         USING HIST,R2
         CLC   =F'0',HISTSADR          IS SEGMENT A SECONDARY SEGMENT
         BE    GCA1                    NOPE, SO SKIP CODE
         L     R2,HISTSADR             GET ADDRESS OF BLOCK
         BR    R14
GCA1     L     R2,HISTADDR             GET MAIN BLOCK ADDR
         BR    R14
         DROP  R2
         EJECT
***********************************************************************
*
* COMMAND ROUTINES
*
         SPACE 2
*----------------------------------------------------------------------
*
* HELP -- DISPLAY HELP INFORMATION
*
*----------------------------------------------------------------------
         SPACE 2
HELP     DS    0H
         LA    R1,16*80
         LR    R3,R1
         L     R2,=A(HELPMSG)      POINT AT FROM
         LA    R0,OUT1
         MVCL  R0,R2
         B     DISPLAY
         SPACE 2
*----------------------------------------------------------------------
*
* REFRESH -- REFETCH THE CORE AND REDISPLAY IT
*
*----------------------------------------------------------------------
         SPACE 2
REFRESH  OI    FLAGS,RFRSH             SET REFRESH FLAG
         B     FORMAT                  REFORMAT SCREEN
         SPACE 2
*----------------------------------------------------------------------
*
* OVERLAY  --  MANIPULATE CONTROL BLOCK FORMATTING
*
*----------------------------------------------------------------------
         SPACE 2
OVERLAY  CLC   =C'NULL',INPLINE+1      SEE IF NO FORMATTING WANTED
         BE    OVERNULL                BR IF YES
         L     R5,=V(CBMACS)           GET CB MAP INDEX
         LTR   R5,R5                   ANY MAPS
         BZ    OVERNULL                IF NOT TREAT AS NULL OVERLAY
         USING CBH,R5                  SETUP ADDRESSABILITY
OVERLOOP CLC   =F'0',CBHNEXT           END OF CONTROL BLOCKS
         BE    FORMAT                  IF YES, IGNORE COMMAND
         CLC   INPLINE+1(8),CBHNAME    SEE IF CB MATCH
         BE    OVERHIT                 BR IF YES
         L     R5,CBHNEXT              ELSE POINT TO NEXT ENTRY
         B     OVERLOOP                AND KEEP LOOKING
OVERHIT  L     R6,CBHCBSP              START SEG ADDR FOR CB FOUND
         LH    R2,CURRENT              CURRENT HIST TABLE ENTRY OFFSET
         A     R2,HISTORY              GET ENTRY ADDRESS
         USING HIST,R2                 SETUP ENTRY FORMAT
         ST    R5,HISTCBHP             POINT AT HEADER
         ST    R6,HISTCBSP             POINT AT SEGMENT(FIRST)
         OI    HISTCBHP,X'80'          MARK AS CB
         XC    HISTSADR,HISTSADR       CLEAR SEC SEG ADDR
         B     FORMAT                  GO SHOW IT
         SPACE 1
OVERNULL LH    R2,CURRENT              CURRENT HIST TABLE ENTRY OFFSET
         A     R2,HISTORY              POINT AT CURRENT ENTRY
         MVC   HISTCBHP,=X'7FFFFFFF'   SUPPRESS CB OVERLAY
         B     FORMAT                  GO SHOW STORAGE
         DROP  R5,R2
         SPACE 2
*----------------------------------------------------------------------
*
* DOWN -- SCROLL DOWN 256 BYTES OR NEXT CTRL BLK SEGMENT
*
*----------------------------------------------------------------------
         SPACE 2
DOWN     LH    R2,CURRENT              CURRENT HIST TABLE POINTER
         A     R2,HISTORY              POINT TO HIST TABLE ENTRY
         USING HIST,R2                 SETUP ENTRY FORMAT
         TM    HISTCBHP,X'80'          SEE IF THIS IS A CB DISPLAY
         BO    DOWNCB                  BR IF YES
         L     R1,HISTADDR             ELSE GET ADDR TO SHOW
         AH    R1,=H'256'              AND MOVE DOWN ONE SCREEN
         ST    R1,HISTADDR             AND REPLACE IN HIST TABLE
         B     FORMAT                  GO DISPLAY IT
DOWNCB   L     R1,HISTCBSP             GET CB SEGMENT ADDR
         L     R1,CBSNEXT-CBS(R1)      GET NEXT SEG ADDR
         ST    R1,HISTCBSP             AND PUT IN HIST TABLE
         XC    HISTSADR,HISTSADR       CLEAR SEC SEG ADDR
         B     FORMAT                  GO SHOW IT
         DROP  R2
         SPACE 2
*----------------------------------------------------------------------
*
* UP   -- SCROLL UP   256 BYTES OR PREV CTRL BLK SEGMENT
*
*----------------------------------------------------------------------
         SPACE 2
UP       LH    R2,CURRENT              CURRENT HIST TABLE POINTER
         A     R2,HISTORY              POINT TO HIST TABLE ENTRY
         USING HIST,R2                 SETUP FORMAT OF ENTRY
         TM    HISTCBHP,X'80'          SEE IF THIS IS A CB DISPLAY
         BO    UPCB                    BR IF YES
         L     R1,HISTADDR             ELSE GET ADDR TO SHOW
         SH    R1,=H'256'              AND MOVE UP ONE SCREEN
         ST    R1,HISTADDR             AND REPLACE IN HIST TABLE
         B     FORMAT                  GO DISPLAY IT
UPCB     L     R1,HISTCBSP             GET CB SEGMENT ADDR
         L     R1,CBSPREV-CBS(R1)      GET PREV SEG ADDR
         ST    R1,HISTCBSP             AND PUT IN HIST TABLE
         XC    HISTSADR,HISTSADR       CLEAR SEC SEG ADDR
         B     FORMAT                  GO SHOW IT
         DROP  R2
         SPACE 2
*----------------------------------------------------------------------
*
* REPEAT -- REPEAT LAST INPUT LINE
*
*----------------------------------------------------------------------
         SPACE 2
REPEAT   MVC   INPLINE(52),INPSAVE     COPY SAVED INPUT
         B     ISCAN2                  AND PROCESS IT
         SPACE 2
*----------------------------------------------------------------------
*
* LINK -- LINK TO LABELED CONTROL BLOCK FIELD
*
*----------------------------------------------------------------------
         SPACE 2
LINK     LH    R2,CURRENT              CURRENT HIST TABLE POINTER
         A     R2,HISTORY              POINT TO HIST TABLE ENTRY
         USING HIST,R2                 SETUP FORMAT OF ENTRY
         TM    HISTCBHP,X'80'          SEE IF CB FORMATTING IN USE
         BO    LINK2                   BR IF YES
LINKERR  MVC   MSGLINE,LINKMSG         NOTE ERROR IN LINK
         B     FORMAT                  AND RESHOW SCREEN
LINK2    L     R3,HISTCBSP             GET CURRENT CB SEG ADDRESS
         LA    R5,0(R3)                CLEAR FLAGS AND SETUP FOR COMP
         USING CBS,R4
LINK2A   LR    R4,R3                   SAVE THE START OF SEG ADDR
         LA    R3,CBSLEN(R3)           POINT PAST SEG HEADER
         USING CBF,R3
LINK3    CLC   CBFNAME(4),=F'0'        END OF SEGMENT
         BE    LINK4
         CLC   CBFNAME,INPLINE+1       DOES NAME MATCH
         BE    LINKFND                 IF SO THEN FOUND
         LA    R3,CBFLEN(R3)           POINT PAST THIS ONE
         B     LINK3                   KEEP LOOKING
LINK4    DS    0H
         L     R3,CBSNEXT              POINT TO NEXT SEGMENT
         CR    R3,R5                   ARE WE BACK AT START
         BNE   LINK2A                  IF NOT KEEP GOING
         B     LINKERR                 IF NOT THEN ISSUE ERROR
         DROP  R4,R2
* A MATCH HAS  BEEN FOUND. FETCH THE  ADDRESS TO LINK TO
LINKFND  DS    0H
         SR    R0,R0                   CLEAR FOR IC
         IC    R0,CBFDLEN              LENGTH OF ITEM  MINUS 1
         LA    R1,DUMPDATA             ADDR TO PLACE DATA IN
         BAL   R14,GETCURAD            GET ADDR OF CURRENT SEGMENT
         AH    R2,CBFOFFS              OFFSET OF ITEM TO FETCH
         BAL   R14,GETSTOR             FETCH THE  ADDRESS
         B     LINKERR                 BR IF DATA CANT BE FETCHED
         B     LINKERR                 BR IF DATA CANT BE FETCHED
         BAL   R15,FWDSUB              UPDATE HIST TABLE TO NEXT
         L     R0,DUMPDATA             LOAD ADDRESS THAT WAS FETCHED
         SR    R15,R15                 NOW ADJUST THE
         IC    R15,CBFDLEN               FETCHED DATA
         LA    R1,4                        SO THAT
         SR    R1,R15                        IT IS RIGHT
         BNP   LF1                             JUSTIFIED IN
         SLL   R1,3                              REGISTER IF
         SRL   R0,0(R1)                            LESS THAN 4
LF1      DS    0H                                    BYTES
         LH    R2,CURRENT              NEW HIST TABLE POINTER
         A     R2,HISTORY              GET ENTRY ADDRESS
         USING HIST,R2
         ST    R0,HISTADDR             SAVE NEW ADDRESS
         XC    HISTCBHP,HISTCBHP          AND
         XC    HISTCBSP,HISTCBSP            CLEAR
         XC    HISTSADR,HISTSADR               REST
         B     FORMAT                  GO FORMAT THE NEW CB
         DROP  R3,R2
         SPACE 2
*----------------------------------------------------------------------
*
*  SET INDIRECT FLAG
*
*----------------------------------------------------------------------
         SPACE 2
INDIR31  OI    FLAGS,IND31             SET FLAG
INDIR    OI    FLAGS,INDFLAG           SET FLAG
         LA    R3,1(R3)                UPDATE SCAN POINTER
         CLI   INPLINE+1,C' '          USE CURRENT ADDRESS
         BNE   NUMSCAN                 IF NO, GO SCAN INPUT ADDRESS
         BAL   R14,GETCURAD
         LR    R4,R2                   MOVE TO RIGHT REGISTER
         B     ENDNUM
         SPACE 2
***********************************************************************
*
*  ESTABLISH SCREEN MODE
*
***********************************************************************
         SPACE 2
MODE     CLC   =C'1 ',INPLINE+1        MODE ONE TEST
         BE    MODE1                   BR IF YES
         CLC   =C'2 ',INPLINE+1        CHECK FOR MODE TWO
         BNE   INVAL                   IF NOT EITHER, INVALID
         NI    MODEFLAG,255-MIDDUMP    MODE 2 MEANS BACKUP 0
         B     FORMAT
MODE1    OI    MODEFLAG,MIDDUMP        MODE 1 MEANS BACK UP 7 LINES
         B     FORMAT
INVAL    MVC   MSGLINE,MODEMSG
         B     FORMAT
         SPACE 2
***********************************************************************
*
*  MANIPULATE HISTORY TABLE
*
***********************************************************************
         SPACE 2
FWD      BAL   R15,FWDSUB              FORWARD 1 IN HIST TABLE
         B     FORMAT
         SPACE
FWDSUB   LH    R1,CURRENT              CURRENT ENTRY INDEX
         LA    R1,HISTLEN(R1)
         CH    R1,=AL2(50*HISTLEN)     SEE IF WRAP NEEDED
         BL    FWDEND                  BR IF NOT
         SR    R1,R1                   WRAP TO BEGINNING
FWDEND   STH   R1,CURRENT              STORE NEW OFFSET
         BR    R15                     RETURN TO CALLER
         SPACE 1
BACK     LH    R1,CURRENT
         SH    R1,=AL2(HISTLEN)        BACK UP ONE ENTRU
         BNM   BACKEND                 BR IF NO BACKWARD WRAP
         LA    R1,49*HISTLEN           ELSE GO TO END OF TABLE
BACKEND  STH   R1,CURRENT              SAVE RESULT
         B     FORMAT
         SPACE 2
***********************************************************************
*
*   ADD ENTRY TO SYMBOL TABLE
*
***********************************************************************
         SPACE 2
DEFINE   LA    R15,50                  NUMBER OF TABLE ENTRIES
         LA    R2,NAMES                START OF TABLE
DEFLOOP1 CLI   0(R2),X'0'              SEE IF UNUSED ENTRY
         BE    NSPACE                  BR IF SPACE FOUND
         LA    R2,12(R2)               NEXT ENTRY ADDR
         BCT   R15,DEFLOOP1            TRY ALL ENTRIES
         MVC   MSGLINE,SYMFULL         TABLE IS FULL
         B     FORMAT
NSPACE   LA    R15,9                   MAX LENGTH +1
         LA    R0,INPLINE+1            ADDR OF FIRST BYTE
         LR    R1,R0                   COPY SYMBOL ADDR
DEFLOOP2 CLI   0(R1),C' '              SEE IF END OF SYM
         BE    DEFEND                  BR IF YES
         LA    R1,1(R1)                POINT TO NEXT BYTE
         BCT   R15,DEFLOOP2            CONTINUE FOR 9 BYTES
DEFBAD   MVC   MSGLINE,DEFMSG          SYMBOL TOO LONG OR TOO SHORT
         B     FORMAT2                 DISPLAY WITH CURSOR AT ERROR
DEFEND   SR    R1,R0                   SYMBOL LENGTH
         BZ    DEFBAD                  NULL SYMBOL ILLEGAL
         BCTR  R1,R0                   FOR EXECUTE
         MVC   0(8,R2),=CL8' '         CLEAR TABLE ENTRY
         EX    R1,DEFMOVE              MOVE SYMBOL
         LH    R1,CURRENT              GET CURRENT ADDRESS
         A     R1,HISTORY
         L     R1,HISTADDR-HIST(R1)
         ST    R1,8(R2)                STORE WITH SYMBOL
         B     FORMAT
DEFMOVE  MVC   0(0,R2),INPLINE+1       EXECUTED TO MOVE SYMBOL
         SPACE 2
***********************************************************************
*
*  SCAN THE ADDRESS EXPRESSION
* REGISTER USAGE
* R2 LAST NUMBER SCANNED
* R3 SCAN POINTER
* R4 CURRENT OUTPUT VALUE
* R5 LAST OPERATOR SCANNED
*
***********************************************************************
         SPACE 2
NUMSCAN  DS    0H
         BAL   R14,GETCURAD            CURRENT ENTRY IS DEFAULT
         LR    R4,R2                   CURRENT ENTRY IS DEFAULT
         LA    R5,0                    ASSUME DEFAULT TO BE TAKEN
         CLI   0(R3),C'+'              SEE 2F PREFIX PLUS
         BNE   NOTPLUS                 BR IF NOT
         LA    R5,2                    INDICATE PLUS OPERATOR
         B     NUMOP                   GO TO ADV POINTER
NOTPLUS  CLI   0(R3),C'-'              IS IT PREFIX MINUS
         BNE   NUMLOOP                 BR IF NOT, USE DEFAULT AS LOAD
         LA    R5,4                    INDI"ATE MINUS OPERATOR
NUMOP    LA    R3,1(R3)                POINT TO NEXT INPUT BYTE
NUMLOOP  CLI   0(R3),C','              SEE IF NAME INDICATED
         BE    NAMESCAN                BR IF YES
         TRT   0(9,R3),NUMTAB          SEARCH FOR DELIMITER
         LR    R6,R3                   SAVE START OF NUMBER
         BC    8,BADSTUFF              BR IF INPUT TOO LONG
         LR    R3,R1                   UPDATE SCAN POINTER
         SR    R1,R6                   GET LENGTH OF INPUT
         BZ    BADSTUFF                BR IF ZERO INPUT
         MVC   TEMP1(8),=CL8' '        CLEAR TEMP AREA
         LA    R15,TEMP1+8             RIGHT JUSTIFY INPUT
         SR    R15,R1                  POINT TO RIGHT SPOT IN TEMP AREA
         BCTR  R1,0                    PREPARE FOR EX
         EX    R1,HEXMOVE              MOVE INPUT RIGHT JUSTIFIED
         TR    TEMP1(8),HEXTAB         TRANSLATE TO HEX
         PACK  TEMP2(5),TEMP1(9)       CONVERT HEX TO BINARY
         ICM   R2,15,TEMP2             NEW DISPLAY ADDRESS
NUMDELIM EX    0,OPER(R5)              EXECUTE PREVIOUS OPERATOR
         CLI   0(R3),C' '              IS DELIM A BLANK
         BE    ENDNUM                  IF YES, END SCAN
         LA    R5,2                    PLUS OPERATOR CODE
         CLI   0(R3),C'+'              IS OPER L PLUS
         BE    NUMOP                   BR IF YES TO CONTINUE SAAN
         LA    R5,4                    MINUS CODE
         CLI   0(R3),C'-'              IS OPER MINUS
         BE    NUMOP                   BR IF YES
         MVC   MSGLINE,INVALOP         ELSE BAD DELIMITER
         B     FORMAT2                 DISPLAY WITH CURSOR AT ERROR
ENDNUM   TM    FLAGS,INDFLAG           IS THIS AN INDIRECT REQ
         BZ    NOTIND                  BR IF NOT
         TM    FLAGS,IND31             DO WE WANT 31 BIT INDIRECT{
         BO    *+8                     SKIP CLEAR IF YES
         ICM   R4,8,=X'00'             CLEAR TOP BYTE
         LR    R2,R4                   SET ADDR TO GET FROM
         LA    R0,4                    NUMBER OF BYTES TO GET
         LA    R1,DUMPDATA             WHERE TO PUT IT
         BAL   R14,GETSTOR             DO MEMORY FETCH
         B     BADIND                  NONE GOT
         B     BADIND                  SOME BUT NOT ALL GOT
         L     R4,DUMPDATA             DO THE INDIRECT
         N     R4,=X'7FFFFFFF'         TURN OFF TOP BIT ALWAYS
NOTIND   BAL   R15,FWDSUB              UPDATE HISTORY POINTR
         LH    R2,CURRENT              NEW HIST TABLE POINTER
         A     R2,HISTORY              GET ENTRY ADDRESS
         USING HIST,R2
         ST    R4,HISTADDR             SAVE NEW ADDRESS
         XC    HISTCBHP,HISTCBHP          AND
         XC    HISTCBSP,HISTCBSP            CLEAR
         XC    HISTSADR,HISTSADR               REST
         B     FORMAT
         DROP  R2
BADIND   MVC   MSGLINE,BADIMSG         MOVE IN MESSAGE
         B     FORMAT                  GO AND REDISPLAY
         SPACE 2
* SCAN INPUT FOR A NAME IN THE SYMBOL TABOL
NAMESCAN LA    R3,1(R3)                SKIP OVER COMMA
         LR    R1,R3                   COPY INPUT POINTER
         LA    R15,9                   MAX LENGTH +1
NAMELOOP CLI   0(R1),C'A'              SEE IF VALID CHAR
         BL    NAMEEND                 BR IF NOT, DELIM FOUND
         LA    R1,1(R1)                POINT TO NEXT BYTE
         BCT   R15,NAMELOOP            ALLOW EIGHT BYTES PLUS DELIM
NAMEBAD  MVC   MSGLINE,NAMEMSG         NULL NAME OR NAME TOO LONG
         B     FORMAT2                 DISPLAY WITH CURSOR AT ERROR
NAMEEND  SR    R1,R3                   FIND LENGTH
         BZ    BADSTUFF                BR IF TOO SHORT
         MVC   TEMP1(8),=CL8' '        CLEAÂ¢  WORK AREA
         BCTR  R1,0                    SET UP FOR EX
         EX    R1,NAMEMOVE             MOVE TO WORK AREA, BLANK PAD
         LA    R3,1(R3,R1)             UPDATE POINTER
         LA    R15,50                  ENTRIES IN SYM TABLE
         LA    R1,NAMES                START OF SYM TABLE
NAMELP2  CLC   TEMP1(8),0(R1)          SEE IF NAME IN TABLE
         BE    NAMEFIND                BR IF YES
         LA    R1,12(R1)               POINT TO NEXT ENTRY
         BCT   R15,NAMELP2             BR IF ANY ENTRIES LEFT
         B     NAMEBAD                 BR IF NONE LEFT, UNDEFUNED SYM
NAMEFIND L     R2,8(R1)                GET >YMBOL VALUE
         B     NUMDELIM                USE IN EXPRESSION
*  THESE INSTRUCTIONS ARE THE OBJECT OF AN EXECUTE
OPER     LR    R4,R2                   USE HIST TABLE AS DEFAULT INPUT
         AR    R4,R2                   PLUS OPERATOR
         SR    R4,R2                   MINUS OPERATOR
HEXMOVE  MVC   0(0,R15),0(R6)          RIGHT JUSTIFY INPUT DATA
NAMEMOVE MVC   TEMP1(1),0(R3)          PAD NAME WITH BLANKS BY MOVING
         SPACE
BADSTUFF MVC   MSGLINE,ERRMSG          NOTE BAD INPUT
         B     FORMAT2                 DISPLAY WITH CURSOR AT ERROR
         SPACE 2
***********************************************************************
*
*  PROGRAM CHECK EXIT
*
***********************************************************************
         SPACE 2
         DROP  R9,R11
         USING *,R15               SET TEMP BASE
EREXIT   DS    0H                  ESTAE EXIT
         C     R0,=F'12'
         BER   R14                 SKIP IF NOT SDWA
         STM   R14,R12,12(R13)     SAVE REGISTERS
         LR    R4,R1               SAVE ADDR OF SDWA
         USING SDWA,R4             SAVE ADDR
         L     R10,SDWAPARM        GET PARM LIST
         LR    R12,R15             SAVE BASE REGISTER
         DROP  R15
         USING EREXIT,R12
ER200    L     R11,BASE1           GET FIRST BASE
         L     R9,BASE2            GET SECOND BASE
         USING LOOK,R11,R9         RESET BASE
         TM    FLAGS,GETINPG           IS A GETSTOR IN PROGRESS
         BZ    SPIEOTR                 NOPE OTHER ERROR
         L     R8,CSAWORK          SETUP REG 8
         USING WORK,R8                 IF FROM GETSTOR THEN R8 POINTS
*                                      TO WORK
         TM    FLAG1,FG1MOVE           ARE WE IN MOVE INSTR
         BZ    SPIEOTR                 NOPE
         CLI   SDWAICD1,X'04'          PROTECTION??
         BNE   ER250                   IF NOT THEN TRY OTHERS
*        IF PROTECTION THEN DATA TO POINT OF ERROR
*        HAS BEEN MOVED SO JUST ADJUST LENGTH
         L     R2,LENGTH
         S     R2,SDWAGR01             GET LENGTH NOT MOVED
         ST    R2,LENGTH               SAVE MOVED LENGTH
         B     ER300                   ALL DONE
*        IF ADDRESSING EXCEPTION THEN
*        REGISTERS NOT ALWAYS UPDATED (PER POPS)
*        BUT THE TRANSLATION ADDR IS CLOSE.
*        ALSO NO DATA MAY HAVE BEEN MOVED.
*        (WE ARE DEALING HERE WITH WHAT MAY BE "MODEL DEPENDENT"
*        FEATURES)
ER250    DS    0H
         L     R2,SDWATRAN             GET BAD ADDRESS
         N     R2,=X'7FFFF000'         MAKE GOOD
         S     R2,ADDR                 LESS START ADDR
         LTR   R2,R2                   ANY GOOD LENGTH
         BNP   ER300                   NOPE
         C     R2,LENGTH               MAKE SURE IT IS REASONABLE
         BH    ER300                   SKIP IF NOT
         ST    R2,LENGTH               SAVE AS GOTTEN LENGTH
         LR    R3,R2                   SETUP LENGTH
         LR    R7,R2
         L     R2,ADDR                 GET FROM ADDR
         LA    R6,BUF                  GET TO ADDRESS
         MVCL  R6,R2
ER300    MVC   ESRUB,=X'0074'     FLAG TO RESET REGS
         LR    R1,R4               RESET SDWA POINTER
         SETRP REGS=(14,12),DUMP=NO,RC=4,RETADDR=GOTBACK,              X
               RETREGS=YES,RUB=ESRUB,FRESDWA=YES,RECORD=NO
         DROP  R8,R4
*PIEOTR  MVC   MSGLINE,PCMSG           TELL USER OF PC
*        B     ER300                   SET RETURN FROM GETSTOR
SPIEOTR  DS    0H
         LR    R1,R4                   RESTORE SDWA REG
         SETRP REGS=(14,12),DUMP=NO,RC=0,RECORD=NO
         DROP  R12
         SPACE 2
*----------------------------------------------------------------------
*
* ERASE  --  CLEAR THE SCREEN BUFFER
*
*----------------------------------------------------------------------
         SPACE 2
ERASE    SAVE  (2,5)                   NEED SOME WORK REGS
         LA    R2,OUT1                 START OF AREA TO CLEAR
         LA    R3,80*16                LENGTH TO CLEAR
         LA    R5,C' '                 FILL CHAR
         SLL   R5,24                   MAKE PAD BYTE AND CLEAR SOURCE
         MVCL  R2,R4                   PROPAGATE BLANKS
         RETURN (2,5)                  RESTORE REGS AND RETURN
         EJECT
* EXECUTED INSTRUCTIONS AND CONSTANTS
CLEARMVC MVC   0(0,R6),BLANKS          CLEAR SOME SPACE
MOVEMVC  MVC   0(0,R15),1(R15)         MOVE DATA BACKWARDS
***********************************************************************
*
*
*        FETCH SOME STORAGE
*
*              R0  =  LENGTH TO FETCH <=256
*              R1  => WHERE TO PUT IT
*              R2  => WHERE TO GET IT FROM
*
*
***********************************************************************
GETSTOR  SAVE  (14,8)                  SAVE REGS
*
*        CHECK IF DATA IS IN BUFFER
*
         CLC   CSAASID,CURASID         WANT SAME ASID
         BNE   GETMORE                 NOPE
         C     R2,CSASTAR              CHECK FOR BEGINNING
         BL    GETMORE
         LR    R15,R0                  GET LENGTH
         AR    R15,R2                  GET END ADDRESS
         C     R15,CSAEND              CHECK FOR END
         BH    GETMORE                 NOPE NOT IN BUFFER
         TM    FLAGS,RFRSH             IS IT REFRESH REQUEST
         BO    GETMORE                 REGET THE CORE
MOVEBUF  L     R15,CSASTAR             GET VIRT ADDR OF BUFFER
         SR    R2,R15                  GET DISPLACEMENT IN BUFFER
         A     R2,CSABUF               POINT TO BUFFER
         LR    R3,R0                   MOVE LENGTH
         LR    R0,R1                   SET "TO" ADDR
         LR    R1,R3                   SET LENGTH
         MVCL  R0,R2
         LM    R14,R3,12(R13)          RESTORE REGS
         B     8(R14)                  RETURN ALL GOTTEN
GETMORE  DS    0H
         NI    FLAGS,255-RFRSH         TURN OFF FLAG
         MVC   CSAASID,CURASID         SET ASID OF CSABUFFER CONTENTS
         L     R8,CSAWORK              POINT TO CSA AREA
         USING WORK,R8                 SETUP ADDRESSABILITY
         MVI   FLAG1,0                 CLEAR FLAGS
         MVI   FLAG2,0
         ST    R2,ADDR                 SAVE ADDR TO GET CORE FROM
         ST    R2,CSASTAR              SET CSA VIRT BUFFER ADDR
         MVC   LENGTH,=F'4096'         GET WHOLE PAGE
         CLC   CURASID,MYASID          ARE WE IN THIS ADDR SPACE
         BNE   DOSRB                   IF NOT USE SRB
*
*        INVOKE SRB CODE AS SUBROUTINE
*
         OI    FLAG1,FG1SUBR           FLAG AS SUBROUTINE
         LA    R1,DMYPRMS              SETUP DUMMY FRR PARMS
         ST    R1,FRRPRMS
         XC    DMYPRMS,DMYPRMS
         LR    R1,R8                   SETUP PARM REGISTER
         LA    R15,D#SRBCD             SETUP ENTRY REGISTER
         LA    R14,GOTBACK             SETUP RETURN REGISTER
         OI    FLAGS,GETINPG           FLAG GETSTOR IN PROGRESS
         BR    R15                     GO TO IT
*
*        IF AUTHORIZED FOR SRB MODE ...
*
DOSRB    TM    FLAGS,NOAUTH            ARE WE AUTHORIZED
         BO    FAIL2                   NOPE
*
*        VALIDATE ASID ...
*
         L     R2,CVTPTR               POINT TO CVT
         LH    R1,CSAASID              GET ASID
         L     R2,CVTASVT-CVTMAP(R2)   POINT TO ASVT
         USING ASVT,R2                 SETUP ADDRESSABILITY
         C     R1,ASVTMAXU             IS IT TOO BIG
         BH    FAIL3                   SET INVALID ASID
         SLL   R1,2                    ASID*4
         LA    R1,ASVTENTY-4(R1)       POINT AT DESIRED ENTRY
         MVC   TOASCB,0(R1)            SAVE ASCB ADDR
         TM    TOASCB,ASVTAVAL         IS THIS ASCB EXISTANT
         BO    FAIL3                   NOPE
         LA    R3,SRBAREA     POINT AT THE SRB
         DROP  R2
         L     R2,TOASCB               GET ASCB ADDR
         USING ASCB,R2                 SETUP ADDRESSABILITY
         TM    ASCBRCTF,ASCBOUT        IS ASCB SWPPED OUT
         BO    FAIL3                   YES SO DONOT TRY TO TOUCH IT
         DROP  R2
*
*        INITIALIZE THE SRB AND INVOKE AS SRB
*
         USING SRBSECT,R3
         XC    SRBAREA,SRBAREA  CLEAR THE SRB
         MVC   SRBID,=C'SRB '  SET EBCDIC ID
         MVC   SRBASCB,TOASCB SET ASCB ADDR TO RUN IN
         BASR  R0,0           GET ADDRESSING MODE
         N     R0,=X'80000000'  LEAV ONLY ADDRESSING MODE
         LA    R1,SRBCCD      POINT AT SRB CODE IN CSA
         OR    R1,R0          PUT ADDRESSING MODE IN
         ST    R1,SRBEP       SAVE ENTRY POINT
         ST    R8,SRBPARM     SAVE PARM ADDR AS WORK AREA
         LA    R1,D#RMTR-D#SRBCD(R1)  GET RESOURCE MGR TERMINATION
         OR    R1,R0
         ST    R1,SRBRMTR     AND SAVE IT
         XC    ECB,ECB                 CLEAR THE ECBS FOR THE WAITLIST
         XC    ECB2,ECB2
         LA    R0,ECB
         LA    R1,ECB2
         STM   R0,R1,ECBLIST
         MVI   ECBLIST+4,X'80'
*
*        NOW ISSUE TIMER INCASE SRB NEVER POSTS US
*
         STIMER REAL,D#STX,BINTVL==A(300)  WAIT 3 SECONDS
         MODESET KEY=ZERO
         SCHEDULE SRB=(R3),SCOPE=GLOBAL ISSUE SRB
         MODESET KEY=NZERO
         L     R2,=C'ABCD'             SET KEY IN REG
         LA    R3,ECB2                 AND ADDR TO POST IN STIMER
         WAIT  ECBLIST=ECBLIST
         TTIMER CANCEL
*
*        WE ARE BACK FROM EITHER TIMER OR SRB OR SUB
*
GOTBACK  L     R8,CSAWORK              POINT AT CSA AREA
         NI    FLAGS,255-GETINPG       TURN OFF GET IN PROGRESS
         TM    FLAG1,FG1SUBR           IS THIS A SUB CALL
         BO    GOTBK2                  IF SO IGNORE SOME ERRORS
         TM    FLAG1,FG1SRDN           DID SRB TERMINATE GOOD
         BZ    FAIL                    NOPE SO ERROR MSG
         TM    FLAG2,FG2PSTR+FG2PURG+FG2ERRR AN ERRORS
         BNZ   FAIL                    IF SO ERROR MESSAGE
GOTBK2   DS    0H
*
*        NOW MOVE INFO OUT OF CSA BUFFER
*
         L     R2,12+12(R13)           GET ORIG R1 INTO R2 (DEST ADDR)
         L     R3,12+8(R13)            GET DESIRED LENGTH
         L     R4,CSABUF               POINT TO BUFFER
         L     R5,LENGTH               GET ACTUAL LENGTH MOVED
*
*        NOTE THAT ORIG(R2) IS EFFECTIVELY AT R4
*        FIRST BYTE DESIRED IS FIRST BYTE IN BUFFER
*
         MVCL  R2,R4                   MOVE IN CORE
         L     R2,CSASTAR              GET START LOC
         A     R2,LENGTH               PLUS LENGTH MOVED
         ST    R2,CSAEND               SET CORRECT END ADDR
         MVC   LOGOOD,CSASTAR          SET LOW RANGE DISPLAYABLE
         MVC   HIGOOD,CSAEND           AND HIGH RANGE
         MVC   12+12(4,R13),LENGTH     SET GOTTEN LENGTH
         LM    R14,R8,12(R13)          RESTORE REGS
         LTR   R1,R1                   ANY LENGTH GOTTEN
         BZR   R14                     IF NOT THEN EXIT +0
         CR    R0,R1                   ALL DESIRED GOTTEN
         BH    4(R14)                  IF NOT ALL THEN +4
         B     8(R14)                  ALL DESIRED GOTTEN THEN +8
*
*        IF ANY ERRORS GIVE ERROR MSG AND RETURN +0
*
FAIL     DS    0H
         DC    H'0'
         MVC   MSGLINE,SRBMSG          MOVE IN MESSAGE
         MVC   CURRENT+2(2),FLAG1
         B     FAILALL                 GO TO COMMON ROUTINE
*
*        IF NOT AUTHORIZED TO DISPLAY OTHER ASIDS GIVE MSG AND RESET
*
FAIL2    DS    0H
         MVC   MSGLINE,AUTHMSG         MOVE IN MESSAGE
         B     FAILALL                 GO TO COMMON ROUTINE
*
*        IF ASID IS NOT VALID OR SWAPPED OUT GIVE MSG AND RESET
*
FAIL3    DS    0H
         MVC   MSGLINE,BDASMSG         MOVE IN MESSAGE
FAILALL  DS    0H                      COMMON FAILURE ROUTINE
         MVC   CSASTAR,=F'0'           CLEAR THE START
         MVC   CSAEND,=F'0'              AND END ADDR
         MVC   CSAASID,=H'0'               AND THE ASID
         MVC   CURASID,MYASID          RESET ASID AVAIL
         RETURN (14,8)
*
*        STIMER EXIT ROUTINE
*        ITS PURPOSE IS TO POST THE ECB AT ECB2 AND WAKE UP THE
*        LOOK PROCESSOR IF THE SRB FAILS.  TO DO THIS WE MUST
*        FIND THE ADDRESS OF THE ECB WHICH IS SAVED IN R3 OF
*        THE RB ABOVE THE WAIT.  IN THAT RB, R2 IS SET TO 'ABCD'.
*
         USING *,R12
D#STX    SAVE  (14,12)                 SAVE REGISTERS
         LR    R12,R15                 SET BASE REG
         L     R3,CVTPTR               POINT AT CVT
         L     R3,0(R3)                POINT AT TCB WORDS
         L     R3,0(R3)                POINT AT MY TCB
         L     R3,0(R3)                POINT AT MY RB
         USING RBBASIC,R3
D#STX1   DS    0H                      NOW LOOK FOR KEY IN REG2
         CLC   RBGRS2,=C'ABCD'         IS THE KEY HERE
         BE    D#STX2                  YES
         TM    XSTAB2,RBTCBNXT         TEST TCB FLAG
         BO    D#STX3                  IF NOT FOUND PROPER RB
         L     R3,RBLINK               POINT AT PREVIOUS RB
         B     D#STX1
D#STX2   L     R2,RBGRS3               GET ADDR OF ECB TO POST
         POST  (R2)                    WAKE UP LOOK
         RETURN (14,12)
*
*        IF WE CANT FIND THE RB THEN DUMP
*
D#STX3   DC    H'0'
         DROP  R12,R3
         LTORG
         TITLE 'LOOK --  STORAGE ALTER/DISPLAY - SRB MODE CODE'
         DROP  R9
D#SRBCD  DS    0D
*
*        THIS CODE PERFORMS THE FOLLOWING FUNCTIONS
*              1 ESTABLISHES AN FRR FOR ERROR RECOVERY
*              2 VERIFIES THAT THE ADDRESSES THAT ARE NEEDED DO
*                EXIST.
*              3 PERFORM THE MODIFICATION IF ALLOW AND NECESSARY
*              4 SAVE THE PROPER CORE FOR DUMPING.
*              5 CROSS-MEMORY POST THE MAIN COMMAND PROCESSOR
*
         USING WORK,R8
         USING D#SRBCD,R7
         LR    R8,R1          SET THE MAIN PARM DSECT
         LR    R7,R15         SET THE BASE REGISTER
         ST    R14,ASRBRTN    SAVE RETURN ADDR
         TM    FLAG1,FG1SUBR  IS THIS A SUBROUTINE CALL
         BO    D#SRB1         YES SO SKIP FRR
         LA    R5,D#FRRCD     POINT AT FRR CODE
         SETFRR  A,FRRAD=(R5),WRKREGS=(2,3),PARMAD=(R4)
         ST    R4,FRRPRMS     SAVE ADDR OF FRRPRMS
*
*        NOW INIT THE FRR PARM AREA AND VALIDATE THE INPUT ADDR
*
D#SRB1   L     R2,FRRPRMS     ACCESS THE 6 WORK PARM AREA
         STM   R7,R8,0(R2)    SAVE BASE AND WORK REGS
*
*        MOVE MEMORY
*
         L     R2,ADDR                 SET START ADDR
         LA    R0,BUF                  POINT AT BUFFER
         L     R1,LENGTH               GET DESIRED LENGTH
         LR    R3,R1                   SET LENGTH
         OI    FLAG1,FG1MOVE           INDICATE IN MOVE
         MVCL  R0,R2                   MOVE IN CORE
         NI    FLAG1,255-FG1MOVE       NOTE NOT IN MOVE
*
*        NOW WE TERMINATE PROCESSING BY DOING A CROSS
*        MEMORY POST IF NOT IN SUBROUTINE MODE
*
FRRRTY   TM    FLAG1,FG1SUBR  IS THIS SUBROUTINE MODE
         BO    D#EXIT         IF SO THEN EXIT
         SETFRR  D,WRKREGS=(2,3)
FRRPOST  L     R10,=A(X'40000000') SET CODE FOR POST
         LR    R9,R8          SAVE WORK POINTER IN SAFE REG
         LA    R11,ECB        ADDR OF ECB TO POST
         ICM   R11,8,=X'80'   FLAG AS XMPOST
         LA    R12,D#POSTR    SET POST ERROR RETURN
         L     R13,MYASCB     ASCB TO POST
         L     R15,CVTPTR     POINT AT CVT
         L     R15,CVT0PT01-CVTMAP(R15)    GET POST ENTRY POINTR
         BALR  R14,R15        GO DO POST
         DROP  R7             KILL MAIN ADDRESS
         USING *,R14          SET TEMP BASE
D#PRTN   LR    R8,R9          RESET BASE OF WORK
         SL    R14,=A(D#PRTN-D#SRBCD)  NOW HAVE CORRECTED BASE
         LR    R7,R14         SET TO PROPER REG
         DROP  R14
         USING D#SRBCD,R7     RESET MAIN BASE
         OI    FLAG1,FG1SRDN  FLAG SRB AS COMPLETED
D#EXIT   L     R14,ASRBRTN    RESTORE RETURN ADDR
         BR    R14            EXIT
         SPACE 5
*
*        POST ERROR ROUTINE  .. FLAG ERROR AND LET TIMER
*        WAKE UP TASK
*
D#POSTR  LR    R8,R9          RESET WORK BASE
         OI    FLAG2,FG2PSTR  FLAG POST ERROR
         BR    R14            RETURN TO D#PRTN
         TITLE 'LOOK --  STORAGE ALTER/DISPLAY - FRR FOR SRB'
D#FRRCD  DS    0D
         L     R2,0(R1)       POINT AT PARM AREA
         LM    R7,R8,0(R2)    SET BASE REGS
         TM    FLAG1,FG1MOVE  ARE WE IN VALIDATION
         BZ    D#FRR1         NOPE
*
*        MOVE INCOMPLETE
*
         NI    FLAG1,255-FG1MOVE       TURN OFF FLAG
         CLI   SDWAICD1-SDWA(R1),X'04' PROTECTION??
         BNE   D#FRR0A                 IF NOT THEN TRY OTHERS
*        IF PROTECTION THEN DATA TO POINT OF ERROR
*        HAS BEEN MOVED SO JUST ADJUST LENGTH
         L     R2,LENGTH
         S     R2,SDWAGR01-SDWA(R1)    GET LENGTH NOT MOVED
         ST    R2,LENGTH               SAVE MOVED LENGTH
         B     D#FRR0                  ALL DONE
*        IF ADDRESSING EXCEPTION THEN
*        REGISTERS NOT ALWAYS UPDATED (PER POPS)
*        BUT THE TRANSLATION ADDR IS CLOSE.
*        ALSO NO DATA MAY HAVE BEEN MOVED.
*        (WE ARE DEALING HERE WITH WHAT MAY BE "MODEL DEPENDENT"
*        FEATURES)
D#FRR0A  DS    0H
         L     R2,SDWATRAN-SDWA(R1)    GET BAD ADDRESS
         N     R2,=X'7FFFF000'         GET PAGE BOUNDARY
         S     R2,ADDR                 LESS START ADDR
         LTR   R2,R2                   ANY GOOD LENGTH
         BNP   D#FRR0                  NOPE
         C     R2,LENGTH               MAKE SURE IT IS REASONABLE
         BH    D#FRR0                  SKIP IF NOT
         ST    R2,LENGTH               SAVE AS GOTTEN LENGTH
         LR    R3,R2                   SETUP LENGTH
         LR    R7,R2
         L     R2,ADDR                 GET FROM ADDR
         LA    R6,BUF                  GET TO ADDRESS
         MVCL  R6,R2
D#FRR0   OI    FLAG2,FG2IVLD  SET FLAG FOR MESSAGE
         SETRP RECORD=NO,RC=4,RETADDR=FRRRTY,REGS,DUMP=NO,             X
               RETREGS=YES,FRESDWA=YES
         BR    R14            EXIT
         SPACE 5
*
*        ALL OTHER ERRORS
*
D#FRR1   OI    FLAG2,FG2ERRR  SET FLAG FOR MESSAGES
         SETRP RECORD=YES,RC=4,RETADDR=FRRRTY,REGS,DUMP=YES,           X
               RETREGS=YES,FRESDWA=YES
         BR    R14            EXIT
         TITLE 'LOOK --  STORAGE ALTER/DISPLAY - RESOURCE MGR. CLEANUP'
*
*        THIS ROUTINE RECEIVES CONTROL IF THE SRB MUST BE
*        PURGED.
*
D#RMTR   DS    0H
         USING *,R15
         LR    R7,R15         SET BASE REGISTER
         SL    R7,=A(D#RMTR-D#SRBCD)   BY COMPUTATION
         DROP  R15
         USING D#SRBCD,R7
         LR    R8,R2          SET UP POINTER TO WORK
         ST    R14,ASRBRTN    SAVE RETURN ADDR
         OI    FLAG2,FG2PURG  SET PURGED
         B     FRRPOST        GO AND POST TO CLEAN UP
         LTORG
ENDSRB   EQU   *
SRBCODE  EQU   *-D#SRBCD               LENGTH OF SRB CODE
         TITLE 'LOOK --  STORAGE ALTER/DISPLAY - MESSAGES, CONSTANTS'
KEY1 DC CL80'1= HELP      2=           3= END        4=           5= REX
               PEAT  6=          '
KEY2 DC CL80'7= BACKWORD  8= FORWARD   9= HIST BWD  10= HIST FWD 11=   X
                    12=          '
* ERROR MESSAGE FOR BAD INPUT
TITLE    DC    CL79' '
MODEMSG  DC    CL79'***** INVALID MODE'
INVALOP  DC    CL79'***** INVALID OPERATOR'
SYMFULL  DC    CL79'***** SYMBOL TABLE IS FULL'
NAMEMSG  DC    CL79'***** UNDEFINED SYMBOL'
DEFMSG   DC    CL79'***** NULL SYMBOL OR SYMBOL TOO LONG'
PCMSG    DC    CL79'***** PROGRAM CHECK'
LINKMSG  DC    CL79'***** LINK FAILED'
SRBMSG   DC    CL79'***** SRB DATA FETCH FAILED'
AUTHMSG  DC    CL79'***** LOOK NOT CURRENTLY AUTHORIZED. REQUEST DENIEDX
               .'
BDASMSG  DC    CL79'***** ASID INVALID OR SWAPPED OUT.'
BADIMSG  DC    CL79'***** INDIRECT FAILED.'
ASIDFMT  DC    CL13'DISPLAY ASID='
HEXTAB   DC    256C' '                 GENERAL HEX CONVERSION TABLE
ERRMSG   DC    CL79'INVALID ADDRESS -- TRY AGAIN'
BLANKS   DC    CL79' '
         EJECT
         ORG   HEXTAB+C'A'             INPUT CONVERSION
         DC    X'0A0B0C0D0E0F'
         ORG   HEXTAB+C'0'             OUTPUT CONVERSION
         DC    C'0123456789ABCDEF'
         ORG
* HEX INPUT TRT TABLE
NUMTAB   DC    256X'1'
         ORG   NUMTAB+C'A'
         DC    6X'0'
         ORG   NUMTAB+C'0'
         DC    10X'0'
         ORG
VALCHAR  DC    256C'.'                 TRANSLATE TO VALID CHARS
         ORG   VALCHAR+C' '
         DC    C' '
         ORG   VALCHAR+C'Â¢'
         DC    C'Â¢.<(+|&&'
         ORG   VALCHAR+C'!'
         DC    C'!$*);Â¬-/'
         ORG   VALCHAR+C','
         DC    C',%_.?'
         ORG   VALCHAR+C':'
         DC    C':#@''="'
         ORG   VALCHAR+C'A'
         DC    C'ABCDEFGHI'
         ORG   VALCHAR+C'J'
         DC    C'JKLMNOPQR'
         ORG   VALCHAR+C'S'
         DC    C'STUVWXYZ'
         ORG   VALCHAR+C'0'
         DC    C'0123456789'
         ORG
         LTORG
         SPACE 2
*        SCREEN DEFINITION AREA
QDINIT   DS    0D             START OS DISPLAY WORK AREA
         DC    F'0'           ORIG SCREEN DEPTH
         DC    F'0'           ORIG SCREEN LINESZ
         DC    H'80'          LENGTH OF DISPLAY LINE
         DC    PL2'21'        LINES PER SCREEN
         DS    0D
         DS    0CL69
         DC    CL6' '
         DC    CL63' '
         DC    CL63' '        CORRECTED DATA FROM SCREEN
         DS    0C             DISPLAY SCREEN
         DC    X'27'          CONTROL
         DC    X'F5'          ERASE/WRITE
         DC    X'C1115D7F1140403C404000' CLEAR SCREEN
         DC    CL43'LOOK COMMAND - DISPLAY AND ZAP MEMORY' TITLE LINE
         DC    CL13'DISPLAY ASID='
         DC    X'1DC8'        MARK NEXT FIELD AS INPUT FIELD
         DC    CL4' '         IN/OUT FOR ASID
         DC    X'1DF0'        TERMINATE INPUT FIELD
         DC    X'11'          SET BUFFER ADDRESS
         DC    X'C150'        (2,1)
         DC    C'ENTER CMD -'     REPLY PROMPT
         DC    X'1DC8'        MARK NEXT FIELD AS INPUT FIELD
         DC    X'13'          SET CURSOR ADDRESS
         DC    X'11'          SET BUFFER ADDRESS
         DC    X'C25B'        (2,76)
         DC    X'1DF0'        TERMINATE INPUT FIELD
         DC    X'11'          SET BUFFER ADDRESS
         DC    X'C260'        (3,1)
         DC    C'LAST CMD  - '
         DC    CL63' '        PREVIOUS COMMAND
         DC    X'11'          SET BUFFER ADDRESS
         DC    X'C3F0'        (4,1)
         DC    CL79' '
         DC    C' '
         DC    16CL80' '      MESSAGE TEXT AREA
         DC    2CL80' '
         DC    2CL80' '       PFK DISPLAY AREA
HELPMSG  DS    0H
 DC CL80'LOOK IS A REAL TIME CORE DISPLAY AND FORMATING PROGRAM. IT ALSX
               O HAS THE         '
 DC CL80'CAPABILITY OF DISPLAYING MEMORY IN ANY ADDRESS SPACE (IF AUTHOX
               RIZED).           '
 DC CL80'                                                              X
                                 '
 DC CL80'THE VALID COMMANDS ARE:                                       X
                                 '
 DC CL80'IEXP  24 BIT INDIRECT                 | JEXP  31 BIT INDIRECT X
                                 '
 DC CL80'>     FORWARD                         | <     BACLWORD        X
                                 '
 DC CL80'=SYM  DEFINE CURRENT ADDRESS AS ''SYM'' | ,SYM  REDISPLAY COREX
                AT ''SYM''           '
 DC CL80'M0/M1 FLIP BETWEEN TOP AND CENTER     | LNAME INDIRECT THRU COX
               NTROL BLOCK FIELD '
 DC CL80'OCB   FORMAT AS ''CB'' CONTROL BLOCK    | R     REFRESH DISPLAX
               YED STORAGE         '
 DC CL80'                                                              X
                                 '
 DC CL80'WHERE ''EXP'' IS OF THE FORM:                                 X
                                   '
 DC CL80'    <+/->HHHH<+/-HHHH<+/-HHHH...>>                            X
                                 '
 DC CL80'AND ''HHHH'' IS A 1 TO 8 DIGIT HEX NUMBER.                    X
                                   '
 DC CL80'                                                              X
                                 '
 DC CL80'                                                              X
                                 '
 DC CL80'                                                              X
                                 '
         TITLE 'LOOK --  STORAGE ALTER/DISPLAY - WORK AREAS, DSECTS'
*----------------------------------------------------------------------
*
* HIST -- HISTORY ENTRY FOR ONE OR MORE PREVIOUS ENTRIES
*
*----------------------------------------------------------------------
         SPACE 2
HIST     DSECT
HISTADDR DS    A                       ADDR OF STORAGE/MAIN CB ADDRES
HISTCBHP DS    A                       0 IF NO CB
*                                      X'7FFFFFFF' IF OVERLAY NULL
*                                      ADDR OF CBH IF CB DISPLAYED
HISTCBSP DS    A                       ADDR OF CBS DISPLAYED
HISTSADR DS    A                       ADDR OF STORAGE FOR THIS SEG
HISTLEN  EQU   *-HIST                  LENGTH OF ENTRY
         SPACE 5
*----------------------------------------------------------------------
*
* CBH  -- CONTROL BLOCK HEADER  -  ONE FOR EACH DIFFERENT CONTROL BLK
*
*----------------------------------------------------------------------
         SPACE 2
CBH      DSECT
CBHNEXT  DS    A                       ADDR OF NEXT CONTROL BLOCK OR 0
CBHVOFF  DS    A                       OFFSET OF VALIDATION FIELD
CBHCBSP  DS    A                       ADDR OF FIRST SEG DESCIPTOR
CBHNAME  DS    CL8                     NAME OF BLOCK
CBHVLEN  DS    X                       LENGTH OF VALIDATION FIELD
CBHVAL   DS    0X                      VALIDATION DATA
         SPACE 5
*----------------------------------------------------------------------
*
* CBS  -- CONTROL BLOCK SEGMENT
*
*----------------------------------------------------------------------
         SPACE 2
CBS      DSECT
CBSPREV  DS    A                       ADDRESS OF PREVIOUS SEGMENT
CBSNEXT  DS    A                       ADDRESS OF NEXT SEGMENT
CBSDLEN  DS    AL2                     LENGTH OF DATA TO FETCH
CBSDOFF  DS    AL2                     OFFSET OF DATA TO FETCH
CBSILEN  DS    AL2                     LENGTH OF INDIRECT TO FETCH
CBSIOFF  DS    AL2                     OFFSET OF INDIRECT TO FETCH
CBSLEN   EQU   *-CBS                   LENGTH OF SEGMENT HEADER
         SPACE 5
*----------------------------------------------------------------------
*
* CBF  -- CONTROL BLOCK FIELD
*
*----------------------------------------------------------------------
         SPACE 2
CBF      DSECT
CBFNAME  DS    CL8                     NAME OF FIELD
CBFTYPE  DS    CL1                     TYPE OF NAME
CBFDLEN  DS    XL1                     LENGTH OF DATA TO DISPLAY
CBFOFFS  DS    H                       OFFSET INTO BLOCK START
CBFLINE  DS    H                       LINE NUMBER TO PUT ON
CBFCOLM  DS    H                       COLUMN TO START IN
CBFLEN   EQU   *-CBF
         EJECT
*----------------------------------------------------------------------
*
*   MAIN DYNAMIC WORK AREA
*
*----------------------------------------------------------------------
WORKAREA DSECT
SAVE     DS    18F
HISTORY  DS    F                       HISTORY TABLE ADDRESS
NAMES    DS    150F                    SYMBOL TABLE
CURRENT  DS    H                       HIST TABLE OFFSET
ESTAE    ESTAE 1,PARAM=0,MF=L      ROOM FOR ESTAE PARM LIST
         DS    0F,H                SPACER
ESRUB    DS    H                   BIT INDICATOR SHOULD BE X'0074'
BASE1    DS    F                   FIRST BASE REG
BASR10   DS    F                   NROMAL R10
BASE2    DS    F                   SECOND BASE REG
BASR13   DS    F                   NORMAL R13
TEMP1    DS    CL9                     CONVERSION WORK AREA
TEMP2    DS    CL9                     CONVERSION WORK AREA
LOGOOD   DC    F'0'
HIGOOD   DC    XL4'FFFFF123'
CSALEN   DS    F                       SP AND LEN OF CSA WORK AREA
CSAWORK  DS    A                       ADDRESS OF CSA WORKAREA
CSABUF   DS    A                       ADDRESS OF CSA DATA BUFFER FOR
*                                      SRB
CSASTAR  DS    A                       USERS ADDR OF BEGINNING OF
*                                      BUFFER DATA
CSAEND   DS    A                       USERS ADDR OF END OF BUFFER DATA
CSAASID  DS    H                       USERS ASID FOR BUFFER DATA
MYASID   DS    H                       DCMS ASID
CURASID  DS    H                       DISPLAYED CORE ASID
SAVEASID DS    CL4                     FORMATED VERSION OF CURASID
FLAGS    DS    X                       ASSORTED FLAGS
INDFLAG  EQU   X'80'                   INDIRECT IN PROGRESS
NOAUTH   EQU   X'40'                   IF ON THEN NOT AUTHORIZED
GETINPG  EQU   X'20'                   ON IF GETSTOR IN PROGRESS (SUBR)
RFRSH    EQU   X'10'                   ON TO REFRESH CSA BUFFER
IND31    EQU   X'08'                   31 BIT INDIRECT IN PROGRESS
MODEFLAG DS    X                       USER OPTION FLAGS
MIDDUMP  EQU   X'80'                   ON TO FORCE DISPLAY BACK 8 LINES
ALIGN    EQU   X'40'                   ON TO ALIGN DUMP ON QUADWORD
         SPACE 2
*        SCREEN DEFINITION AREA
QDISPLAY DS    0D             START OS DISPLAY WORK AREA
QDOSZR0  DC    F'0'           ORIG SCREEN DEPTH
QDOSZR1  DC    F'0'           ORIG SCREEN LINESZ
QDLNELEN DC    H'80'          LENGTH OF DISPLAY LINE
QDLNES   DC    PL2'21'        LINES PER SCREEN
         DS    0D
PFREPLY  DS    0CL69
PFCODE   DC    CL6' '
PFTXT    DC    CL63' '
INPLINE  DC    CL63' '        CORRECTED DATA FROM SCREEN
QDSCREEN DS    0C             DISPLAY SCREEN
         DC    X'27'          CONTROL
         DC    X'F5'          ERASE/WRITE
         DC    X'C1115D7F1140403C404000' CLEAR SCREEN
         DC    CL43'LOOK COMMAND - DISPLAY AND ZAP MEMORY' TITLE LINE
ASIDLN   DC    CL13'DISPLAY ASID='
         DC    X'1DC8'        MARK NEXT FIELD AS INPUT FIELD
ASIDLN1  DC    CL4' '         IN/OUT FOR ASID
         DC    X'1DF0'        TERMINATE INPUT FIELD
         DC    X'11'          SET BUFFER ADDRESS
         DC    X'C150'        (2,1)
         DC    C'ENTER CMD -'     REPLY PROMPT
         DC    X'1DC8'        MARK NEXT FIELD AS INPUT FIELD
         DC    X'13'          SET CURSOR ADDRESS
         DC    X'11'          SET BUFFER ADDRESS
         DC    X'C25B'        (2,76)
         DC    X'1DF0'        TERMINATE INPUT FIELD
         DC    X'11'          SET BUFFER ADDRESS
         DC    X'C260'        (3,1)
         DC    C'LAST CMD  - '
INPSAVE  DC    CL63' '        PREVIOUS COMMAND
         DC    X'11'          SET BUFFER ADDRESS
         DC    X'C3F0'        (4,1)
MSGLINE  DC    CL79' '
         DC    C' '
OUT1     DC    16CL80' '      MESSAGE TEXT AREA
OUT9     EQU   OUT1+(8*80)
         DC    2CL80' '
KEYS     DC    2CL80' '       PFK DISPLAY AREA
QDISPLN  EQU   *-QDISPLAY     LENGTH OF ENTIRE DISPLAY
QDSLNG   EQU   *-QDSCREEN     LENGTH OF SCREEN BUFFER
*
**       AREA TO HOLD DATA RETURNED BY GETSTOR
*
DUMPDATA DS    XL4096                  DATA RETURNED BY GETSTOR
WORKLEN  EQU   *-WORKAREA
         EJECT
         PRINT NOGEN
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
*        END
         IHAASCB
         IHAASVT
         IHAFRRS
         IHAPSA
         IHASDWA
         IHASRB
         IHARB
         CVT   DSECT=YES
         EJECT
*
*        CSA AREA WORK AREA
*
WORK     DSECT
WORKSTRT DS    0D
DOUBLE   DS    2F
DMYPRMS  DS    6F             DUMMY AREA FOR FRR PARMS FOR SUBR MODE
FRRPRMS  DS    F              ADDRESS OF 6 WORD FRR PARM
ASRBRTN  DS    F              RETURN ADDR FOR SRB CODE
MYASCB   DS    F              ASCB ADDR OF MAIN ROUTINE
MYTCB    DS    F              TCB ADDRESS FOR MAIN ROUTINE
TOASCB   DS    F              ASCB ADDR OF SRB ROUTINE
ECB      DS    F              ECB FOR MAIN ROUTINE TO WAIT ON
ECB2     DS    F              ECB FOR STIMER TO POST
ECBLIST  DS    2F
LENGTH   DS    F              LENGTH OF STORAGE TO DUMP
SRBAREA  DS    ((SRBSIZE+3)/4)F  THE SRB ITSELF
ADDR     DS    F              ADDRESS TO PROCESS AT
ASID     DS    H              ASID OF TOASCB
FLAG1    DS    X
FG1DUMP  EQU   X'80'
FG1REP   EQU   X'40'
FG1MOVE  EQU   X'20'                   IF ON DOING MVCL FOR DATA
FG1SRDN  EQU   X'02'          IF ON SRB HAS TERMINATED
FG1SUBR  EQU   X'01'
FLAG2    DS    X
FG2NVER  EQU   X'01'          VERIFICATION FAILED
FG2IVLD  EQU   X'02'          VALIDATION FAILED
FG2ERRR  EQU   X'04'          DISASTER OCCURED IN SRB
FG2PURG  EQU   X'08'          SRB WAS PURGED
FG2PSTR  EQU   X'10'          IF ON THEN SRB POST HAD ERROR
SRBCCD   DS    0D                      ALIGN SRB CODE ON DBL WORD
         DS    (SRBCODE)X
         DS    0D                      ALIGN BUFFER
BUF      DS    4096X
WORKLN   EQU   *-WORKSTRT
         END
//L.SYSLMOD DD DSN=TEST.PGM.LOAD(LOOK),DISP=SHR
//L.SYSIN DD *
   INCLUDE SYSLIB(LOOK)
//SYSLIB DD DSN=XSDMN.PROD.LOAD,DISP=SHR

   SETCODE      AC(1)
