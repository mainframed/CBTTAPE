//MSC0150$ JOB (H2803302,S17,,8),'S17 ASSEMBLE&LINK',TIME=(,4)
/*JOBPARM Q=T,I
// EXEC ASMPCL,COPT=',RENT',LOPT=',RENT',
//     PDS='SYS1.LINK2LIB',NAME=MSC0150$,COND=(0,NE)
//P.SYSIN    DD  *
MSC0150 TITLE 'STRUCTURED MACRO LISTING PROGRAM'
*---------------------------------------------------------------------*
*  Copyright 2011 by Clemson University Research Foundation           *
*                                                                     *
*  Licensed under the Apache License, Version 2.0 (the "License");    *
*  you may not use this file except in compliance with the License.   *
*  You may obtain a copy of the License in this library as member     *
*  $LICENSE, or from                                                  *
*                                                                     *
*      http://www.apache.org/licenses/LICENSE-2.0                     *
*                                                                     *
*  Unless required by applicable law or agreed to in writing,         *
*  software distributed under the License is distributed on an "AS    *
*  IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *
*  express or implied.  See the License for the specific language     *
*  governing permissions and limitations under the License.           *
*---------------------------------------------------------------------*
*---------------------------------------------------------------------*
*
*  CSECT: MSC0150
*
*  COPYRIGHT: (C) COPYRIGHT CLEMSON UNIVERSITY 1983, 1988.
*
*  ABSTRACT: THIS PROGRAM READS AN ASSEMBLER SOURCE PROGRAM CONTAINING
*            THE CLEMSON STRUCTURED MACROS AND PRODUCES A LISTING
*            WITH TITLING, SPACING, AND NESTING INFORMATION.  THE
*            ASSEMBLER SOURCE IS WRITTEN TO DDNAME SYSPUNCH FOR
*            FURTHER PROCESSING BY THE ASSEMBLER.  SOME ERROR CHECKING
*            IS DONE FOR STRUCTURAL PROBLEMS BUT THIS CHECKING
*            IS BY NO MEANS EXTENSIVE.
*
*  FILES: SYSIN    - SOURCE INPUT FILE
*         SYSPRINT - LISTING FILE
*         SYSPUNCH - SOURCE OUTPUT FILE
*
*  RETURN CODES:  0 - GOOD
*                 4 - A WARNING ERROR WAS ENCOUNTERED
*                 8 - A ERROR WAS ENCOUNTERED
*                16 - A SEVERE ERROR CAUSED THE PROGRAM TO TERMINATE
*
*  ATTRIBUTES: REENTRENT, AMODE 24, RMODE 24
*
*  DEPENDENCIES: DEFAULT ICTL IS REQUIRED FOR SYSIN.  THIS ASSMEMBLY
*                REQUIRES THE CLEMSON STRUCTURED MACROS.
*
*  METHOD OF OPERATION:
*
*     OPEN FILES
*     READ FIRST SYSIN RECORD
*     DO WHILE NOT END OF FILE ON SYSIN
*       WRITE RECORD TO SYSPUNCH
*       IF NOT COMMENT CARD OR CONTINUED LINE
*         SCAN FOR OPCODE
*         IF OPCODE IS ONE OF THE STRUCTURED MACRO THAT START OR END
*           A STRUCTURE OR MACRO OR MEND , DO NESTING AND UNNESTING
*           PROCESSING FOR LISTING
*         ELSEIF 'SPACE', 'TITLE', OR 'EJECT', DO APPROPRIATE
*           LISTING PROCESSING
*       ENDIF
*       DO CONTINUATION PROCESSING
*       PRINT TITLE AND HEADING IF OVERFLOW
*       PRINT LINE IF APPROPRIATE
*       READ NEXT SYSIN RECORD
*     ENDDO
*     CLOSE FILES
*     RETURN
*
*  MODULE ACTIVITY:  MGG 07/29/83 NEW
*                    MGG 09/04/84 FIXED TITLE STATMENT PROCESSING.
*                                 PUT IN CONTINUED STATEMENT CHECK.
*                                 INSTREAM MACRO SUPPORT
*                                 GENERAL CLEANUP
*                    MGG 01/29/87 RESTRUCTURED AND REMOVED @CN.
*                    MGG  8/08/88 ADDED SMLIST SUPPORT              @C4
*---------------------------------------------------------------------*
  EJECT                               |
 BLOCK NAME=MSC0150,TYPE=PROGRAM,OPTIONS=(*PWA),SUBOPTS=*SWA,       @C4$
               BASEREG=(R12,R11)      |                             @C4
* *-------------------------------------------------------------------*
* *  INITIALIZE THE PROGRAM WORK AREA.
* *-------------------------------------------------------------------*
  CALLSUB INITIALIZE_PWA              | INITIALIZE PWA
* *-------------------------------------------------------------------*
* *  OPEN SOURCE INPUT AND OUTPUT FILES AND PRINT FILE.
* *-------------------------------------------------------------------*
  MVC   PWADIN,PSDDIN                 | MOVE SYSIN DCB TO PWA
  MVC   PWADOUT,PSDDOUT               | MOVE SYSPUNCH DCB TO PWA
  MVC   PWADPRT,PSDDPRT               | MOVE SYSPRINT DCB TO PWA
  MVC   PWAOPN3,PSDOPN3               | MOVE OPEN LIST FORM TO PWA
  OPEN  (PWADIN,INPUT,PWADOUT,OUTPUT,PWADPRT,OUTPUT),MF=(E,PWAOPN3)
  ERREXIT (TBIT,PWADIN+DCBOFLGS-IHADCB,DCBOFOPN,OFF),CODE=0
  ERREXIT (TBIT,PWADOUT+DCBOFLGS-IHADCB,DCBOFOPN,OFF),CODE=1
  ERREXIT (TBIT,PWADPRT+DCBOFLGS-IHADCB,DCBOFOPN,OFF),CODE=2
* *-------------------------------------------------------------------*
* *  PRINT LISTING UNTIL END OF FILE ON SYSIN.
* *-------------------------------------------------------------------*
  CALLSUB READ_SYSIN_AND_WRITE_SRCOUT | DO PRIMING READ
  LOOP WHILE,NOT,(TBIT,PWAF1EOF)      | LOOP WHILE NOT END OF FILE
*  *------------------------------------------------------------------*
*  *  IF NOT A COMMENT CARD, SEARCH FOR AN OPCODE ON THE LINE AND
*  *  DO THE APPROPRIATE LISTING PROCESSING.
*  *------------------------------------------------------------------*
   IF (CLI,PWATEXT,NE,C'*'),AND,      |  IF NOT A COMMENT CARD         $
               (CLC,PWATEXT(2),NE,=C'.*')
    LA    R1,PWALNE                   |   POINT R1 TO START OF TEXT
    LA    R15,PWATEXT+L'PWATEXT       |   POINT R15 TO LAST BYTE
    LA    R14,1                       |   SET INCREMENT TO 1
    LOOP  BXLE                        |   USE BXLE TO FIND THE
     LEAVE LOOP=*,(CLI,0(R1),EQ,X'40')     FIRST BLANK AFTER
    ENDLOOP BXLE,R1,R14               |    AN OPTIONAL TAG
    XC    PWAAOPR,PWAAOPR             |   CLEAR POINTER TO OPCODE
    LOOP  BXH,R1,R14                  |   SEARCH FOR NONBLANK
     IF  (CLI,0(R1),NE,X'40')         |    IF NONBLANK FOUND
      ST    R1,PWAAOPR                |     SAVE POINTER TO OPCODE
      CALLSUB PROCESS_OPCODE          |     PROCESS THE OPCODE
      LEAVE LOOP=*                    |     LEAVE SEARCH FOR OPCODE
     ENDIF                            |    ENDIF
    ENDLOOP BXH                       |   END OF SEARCH
   ENDIF                              |  ENDIF
*  *------------------------------------------------------------------*
*  *  IF A STATEMENT IS CONTINUED, PROCESS CONTINUATION LINES.
*  *------------------------------------------------------------------*
   IF (CLI,PWACONT,NE,X'40')          |  IF CONTINUED STATEMENT
    CALLSUB PROCESS_CONTINUATION_LINES    PROCESS CONTINUATION LINES
   ENDIF                              |  ENDIF
*  *------------------------------------------------------------------*
*  *  IF THE NOWRITE FLAG IS NOT SET,  PRINT A STATEMENT LINE.
*  *------------------------------------------------------------------*
   IF (TBIT,PWAF1NOW,OFF)             |  IF NO WRITE FLAG IS OFF
    CALLSUB PRINT_STATEMENT_LINE      |   PRINT STATEMENT
   ENDIF                              |  ENDIF
   RBIT  PWAF1NOW                     |  RESET NOWRITE FLAG
*  *------------------------------------------------------------------*
*  *  READ NEXT STATEMENT
*  *------------------------------------------------------------------*
   IF NOT,(TBIT,PWAF1EOF)             |  IF NOT END OF FILE
    CALLSUB READ_SYSIN_AND_WRITE_SRCOUT   GET NEXT RECORD
   ENDIF                              |  ENDIF
*  *------------------------------------------------------------------*
  ENDLOOP WHILE                       | ENDLOOP
* *-------------------------------------------------------------------*
* *  IF STRUCTURAL LEVEL IS NON-ZERO, ISSUE ERROR MESSAGE.
* *-------------------------------------------------------------------*
  IF (CLC,PWANSTL,NE,=H'0')           | IF LEVEL NOT ZERO
   PUT   PWADPRT,PSDERLVL             |  ISSUE ERROR MESSAGE
   IF (CLI,PWAMAXRC,LT,8)             |  IF MAX RETURN CODE < 8
    MVI   PWAMAXRC,8                  |   MOVE 8 TO MAX RETURN CODE
   ENDIF                              |  ENDIF
  ENDIF                               | ENDIF
* *-------------------------------------------------------------------*
* *  CLOSE FILES AND RETURN WITH MAXIMUM RETURN CODE.
* *-------------------------------------------------------------------*
  MVC   PWAOPN3,PSDOPN3               | MOVE OPEN LIST FORM TO PWA
  CLOSE (PWADIN,,PWADOUT,,PWADPRT),MF=(E,PWAOPN3) CLOSE FILES
* *-------------------------------------------------------------------*
* *  SET RETURN CODE.
* *-------------------------------------------------------------------*
  SLR   R15,R15                    CLEAR R15
  IC    R15,PWAMAXRC               LOAD MAXIMUM RETURN CODE
* *-------------------------------------------------------------------*
 ENDBLK BLOCK=MSC0150,RC=(R15)  END OF PROGRAM BLOCK
 EJECT                                |
**--------------------------------------------------------------------*
**  EODAD EXIT - FOR SYSIN FILE
**--------------------------------------------------------------------*
 SPACE 1                              |
 BLOCK NAME=EODADIN,TYPE=SUBROUTINE,OPTIONS=*NOSUBOPTS
  SBIT  PWAF1EOF                      | SET END OF FILE FLAG
 ENDBLK BLOCK=EODADIN                 |
 EJECT                                |
**--------------------------------------------------------------------*
**  SUBROUTINE: INITIALIZE_PWA
**
**  THIS SUBROUTINE INITIALIZES FIELDS IN THE PWA.
**--------------------------------------------------------------------*
 BLOCK TYPE=SUBROUTINE,NAME=INITIALIZE_PWA
  ZAP   PWALNUM,=P'999'               | FORCE TITLES
  ZAP   PWAPGN,=P'0'                  | SET PAGE NUMBER TO ZERO
  ZAP   PWAMNL,=P'0'                  | SET MACRO NESTING LEVEL TO ZERO
  FILL  PWANSTK,X'40'                 | INITIALIZE NESTING STACK
  MVC   PWAT,PSDT                     | INITIALIZE TITLE LINE
  MVC   PWAH,PSDH                     | INITIALIZE HEADING LINE
  TIME  ,                             | GET TIME
  ST    R1,PWAD                       | STORE DATE
  MVC   PWAHDTE,PSDMDTE               | MOVE MASK FOR DATE
  ED    PWAHDTE,PWAD+1                | EDIT DATE INTO HEADING LINE
  ST    R0,PWAD                       | STORE TIME
  MVC   PWAHTME,PSDMTME               | MOVE EDIT MASK FOR TIME
  ED    PWAHTME,PWAD                  | EDIT TIME INTO HEADING LINE
  MVC   PWAL,PSDL                     | INITIALIZE TEXT LINE
  MVC   PWABLINE,PSDBLINE             | INITIALIZE BLANK LINE
 ENDBLK BLOCK=INITIALIZE_PWA          |
 EJECT                                |
**--------------------------------------------------------------------*
**  SUBROUTINE: PROCESS_OPCODE
**
**  THIS SUBROUTINE WILL CHECK TO SEE IF THE OPCODE POINTED TO
**  BY REGISTER 1 IS ONE OF THE STRUCTURED MACROS, TITLE, EJECT,
**  SPACE, MACRO OR MEND AND TAKE THE APPROPRIATE LISTING ACTIONS.
**  IF THE OPCODE IS ONE OF THE MACROS THAT START A STRUCTURE, CALLS
**  NEST.  IF IT IS ONE OF THE MACROS THAT END A STRUCTURE, CALL
**  UNNEST.  IF WE ARE INSIDE A MACRO DEFINITION,  ALL THAT IS LOOKED
**  FOR IS MEND AND MACRO MNEMONICS.
**--------------------------------------------------------------------*
 BLOCK TYPE=SUBROUTINE,NAME=PROCESS_OPCODE
  IF (CP,PWAMNL,GT,=P'0')             | IF MACRO NESTING IS NON-ZERO
   IF (CLC,=C'MEND ',EQ,0(R1))        |  IF 'MEND'
    CALLSUB UNNEST,('M')              |   CALL UNNEST
    SP    PWAMNL,=P'1'                |   DEC MACRO NESTING LVL
   ELSEIF (CLC,=C'MACRO ',EQ,0(R1))   |  ELSE IF 'MACRO'
    CALLSUB NEST,('M')                |   CALL NEST
    AP    PWAMNL,=P'1'                |   INC MACRO NESTING LVL
   ENDIF                              |  ENDIF
  ELSEIF (CLC,=C'BLOCK ',EQ,0(R1))    | ELSEIF 'BLOCK'
   CALLSUB NEST,('B')                 |  CALL NEST
  ELSEIF (CLC,=C'ENDBLK ',EQ,0(R1))   | ELSEIF 'ENDBLK'
   CALLSUB UNNEST,('B')               |  CALL UNNEST
  ELSEIF (CLC,=C'CASEBLK ',EQ,0(R1))  | ELSEIF 'CASEBLK'
   CALLSUB NEST,('C')                 |  CALL NEST
  ELSEIF (CLC,=C'ENDCASE ',EQ,0(R1))  | ELSEIF 'ENDCASE'
   CALLSUB UNNEST,('C')               |  CALL UNNEST
  ELSEIF (CLC,=C'IF ',EQ,0(R1))       | ELSEIF 'IF'
   CALLSUB NEST,('I')                 |  CALL NEST
  ELSEIF (CLC,=C'ENDIF ',EQ,0(R1))    | ELSEIF 'ENDIF'
   CALLSUB UNNEST,('I')               |  CALL UNNEST
  ELSEIF (CLC,=C'LOOP ',EQ,0(R1))     | ELSEIF 'LOOP'
   CALLSUB NEST,('L')                 |  CALL NEST
  ELSEIF (CLC,=C'ENDLOOP ',EQ,0(R1))  | ELSEIF 'ENDLOOP'
   CALLSUB UNNEST,('L')               |  CALL UNNEST
  ELSEIF (CLC,=C'MACRO ',EQ,0(R1))    | ELSEIF 'MACRO'
   CALLSUB NEST,('M')                 |  CALL NEST
   AP    PWAMNL,=P'1'                 |  UP MACRO NESTING LEVEL
  ELSEIF (CLC,=C'MEND ',EQ,0(R1))     | ELSEIF 'MEND'
   MVC   PWALMSG(26),=C'>E-4 MEND OUTSIDE OF MACRO'
   IF (CLI,PWAMAXRC,LT,4)             |  IF MAX RETURN CODE < 4
    MVI   PWAMAXRC,4                  |   SET RETURN CODE TO 4
   ENDIF                              |  ENDIF
  ELSEIF (CLC,=C'TITLE ',EQ,0(R1))    | ELSEIF 'TITLE'
   CALLSUB PROCESS_TITLE              |  PROCESS TITLE
  ELSEIF (CLC,=C'SPACE ',EQ,0(R1))    | ELSEIF 'SPACE'
   CALLSUB PROCESS_SPACE              |  PROCESS SPACE
  ELSEIF (CLC,=C'EJECT ',EQ,0(R1))    | ELSEIF 'EJECT'
   ZAP   PWALNUM,=P'999'              |  CAUSE TITLE TO PRINT
   SBIT  PWAF1NOW                     |  INDICATE NO WRITE
  ELSEIF (CLC,=C'END ',EQ,0(R1))      | ELSEIF 'END'
   SBIT  PWAF1EOF                     |  INDICATE END OF FILE
  ELSEIF (CLC,=C'SMLIST ',EQ,0(R1))   | ELSEIF 'SMLIST'             @C4
   CALLSUB PROCESS_SMLIST             |  PROCESS SMLIST COMMAND     @C4
  ENDIF                               | ENDIF
 ENDBLK BLOCK=PROCESS_OPCODE          |
  EJECT                               |
**--------------------------------------------------------------------*
**  SUBROUTINE - PROCESS_TITLE
**
**  IF 'TITLE' IS THE OPCODE, ISOLATE THE TITLE, MOVE IT TO THE TITLE
**  LINE, AND FORCE OVERFLOW.  THIS CODE HANDLES DOUBLE QUOTES BUT
**  DOES NOT AND IN FACT CAN NOT HANDLE SYMBOLIC VARIABLE
**  SUBSTITUTION.  IF THIS CODE DETECTS A SYNTAX ERROR, THE MOVE OF
**  THE TITLE IS TERMINATED BUT NO SYNTAX ERROR IS ISSUED.
**--------------------------------------------------------------------*
 BLOCK TYPE=SUBROUTINE,NAME=PROCESS_TITLE
* *-------------------------------------------------------------------*
* *  IF NAME FIELD IS NON-BLANK AND NOT A SEQUENCE SYMBOL AND AN
* *  IDENTIFICATION IS SPECIFIED IN THE NAME FIELD OF THE TITLE
* *  STATEMENT AND WE HAVE NOT ALREADY DONE SO, MOVE THE
* *  IDENTIFICATION TO THE MODEL OUTPUT TITLE LINE.
* *-------------------------------------------------------------------*
  IF (CLI,PWATEXT,NE,C'.'),AND,       | IF NAME FIELD IS NOT A         $
               (CLI,PWATEXT,NE,X'40'),AND, SEQUENCE SYMBOL OR BLANK    $
               (CLI,PWATID,EQ,X'40')  |    AND THIS IS THE 1ST TIME
   L     R3,PWAAOPR                   |  POINT R3 TO 'TITLE'
   LA    R2,PWALNE                    |  POINT R2 TO START OF LINE
   SLR   R3,R2                        |  CALC LENGTH BEFORE 'TITLE'
   LA    R4,PWATID                    |  POINT TO ID IN TITLE LINE
   LA    R5,L'PWATID                  |  LOAD R5 WITH LENGTH OF ID
   ICM   R3,B'1000',=X'40'            |  FILL CHAR IS SPACE
   MVCL  R4,R2                        |  MOVE ID TO TITLE
  ENDIF                               | ENDIF
* *-------------------------------------------------------------------*
* *  BLANK OUT PLACE TO PUT TITLE IN MODEL TITLE OUTPUT LINE AND
* *  POINT R4 TO PLACE, LOAD R5 WITH LENGTH OF PLACE, AND POINT R1
* *  TO FIRST NON-BLANK AFTER 'TITLE'.
* *-------------------------------------------------------------------*
  FILL  PWATDTA,X'40'                 | BLANK OUT PLACE TO PUT TITLE
  LA    R4,PWATDTA                    | POINT R4 TO PLACE
  LA    R5,L'PWATDTA                  | LOAD R5 WITH IT'S LENGTH
  L     R1,PWAAOPR                    | POINT R1 TO 'TITLE'
  LA    R1,5(,R1)                     | POINT R1 PAST 'TITLE'
  LA    R14,1                         | SET INCREMENT TO 1
  LA    R15,PWATEXT+L'PWATEXT         | POINT R15 TO LAST BYTE
  LOOP  BXH,R1,R14                    | SEARCH FOR NON-BLANK
   LEAVE LOOP=*,(CLI,0(R1),NE,X'40')  |  PAST 'TITLE'
  ENDLOOP BXH                         | END SEARCH
* *-------------------------------------------------------------------*
* *  IF THERE WAS A NON-BLANK AND IT IS A QUOTE, MOVE TITLE TO
* *  MODEL TITLE OUTPUT LINE ONE BYTE AT A TIME.
* *-------------------------------------------------------------------*
  IF (CLR,R1,LT,R15),AND,(CLI,0(R1),EQ,C'''')
   LA    R1,1(,R1)                    |  POINT R1 PAST QUOTE
   LOOP BCT                           |  LOOP FOR EACH BYTE
*   *-----------------------------------------------------------------*
*   *  IF WE HAVE SCANNED TO THE END OF THE TEXT AREA ON THE CARD
*   *  AND IT IS A CONTINUATION,  READ ANOTHER CARD AND REESTABLISH
*   *  R1 AND R15.  IF END OF FILE ON SYSIN, CONSIDER MOVE COMPLETE.
*   *-----------------------------------------------------------------*
    IF (CLR,R1,GE,R15)                |   IF AT END OF TEXT AREA
     LEAVE LOOP=*,(CLI,PWACONT,EQ,X'40')   FINISHED IF NOT CONTINUATION
     CALLSUB READ_SYSIN_AND_WRITE_SRCOUT   READ A NEW RECORD
     LEAVE LOOP=*,(TBIT,PWAF1EOF)     |    FINISHED IF EOF
     LA    R1,PWATEXT+16-1            |    POINT R1 TO COL 16
     LA    R14,1                      |    REESTABLISH R14
     LA    R15,PWATEXT+L'PWATEXT      |    REESTABLISH R15
    ENDIF                             |   ENDIF
*   *-----------------------------------------------------------------*
*   *  IF NEXT CHARACTER IN INPUT RECORD IS A QUOTE, INCREMENT TO
*   *  NEXT CHARACTER.  IF NEXT CHARACTER IS NOT A QUOTE, ASSUME
*   *  THE MOVE IS COMPLETE EVEN IF IT IS A NON-SPACE.
*   *-----------------------------------------------------------------*
    IF (CLI,0(R1),EQ,C'''')           |   IF QUOTE
     LA    R1,1(,R1)                  |    INCREMENT POINTER
     IF (CLR,R1,GE,R15)               |    IF AT END OF CARD
      LEAVE LOOP=*,(CLI,PWACONT,EQ,X'40')   THROUGH IF NOT CONTINUATION
      CALLSUB READ_SYSIN_AND_WRITE_SRCOUT   READ A NEW RECORD
      LEAVE LOOP=*,(TBIT,PWAF1EOF)    |     FINISHED IF EOF
      LEAVE LOOP=*,(CLI,PWATEXT+16-1,NE,C'''')
      LA    R1,PWATEXT+16-1           |     POINT R1 TO COL 16
      LA    R14,1                     |     REESTABLISH R14
      LA    R15,PWATEXT+L'PWATEXT     |     REESTABLISH R15
     ELSE                             |    ELSEIF NEXT CHAR IS NOT AN
      LEAVE LOOP=*                    |     QUOTE, LEAVE LOOP
     ENDIF                            |    ENDIF
    ENDIF                             |   ENDIF
*   *-----------------------------------------------------------------*
*   *  MOVE ONE CHARACTER TO OUTPUT AREA AND ADJUST POINTERS.
*   *-----------------------------------------------------------------*
    MVC   0(1,R4),0(R1)               |   MOVE A CHARACTER
    LA    R1,1(,R1)                   |   BUMP POINTER INTO INPUT
    LA    R4,1(,R4)                   |   BUMP POINTER INTO OUTPUT
   ENDLOOP BCT,R5                     |  ENDLOOP
  ENDIF                               | ENDIF
* *-------------------------------------------------------------------*
  ZAP   PWALNUM,=P'999'               | CAUSE TITLE TO PRINT
  SBIT  PWAF1NOW                      | INDICATE NO WRITE
 ENDBLK BLOCK=PROCESS_TITLE           |ENDBLK
  EJECT                               |
**--------------------------------------------------------------------*
**  SUBROUTINE - PROCESS_SPACE
**
**  IF SPACE IS OPCODE, ISOLATE NUMBER OF LINES TO SPACE AND PRINT
**  BLANK LINES IF NECESSARY.
**--------------------------------------------------------------------*
 BLOCK TYPE=SUBROUTINE,NAME=PROCESS_SPACE
  L     R1,PWAAOPR                    | POINT R1 TO OPCODE FIELD
  LA    R14,1                         | SET INCREMENT TO 1
  LA    R15,PWATEXT+L'PWATEXT         | POINT R15 TO LAST BYTE
  LA    R0,1                          | ASSUME ONE SPACE
  LA    R1,5(,R1)                     | POINT R1 PAST 'SPACE'
  LOOP  BXH,R1,R14,NAME=SCANSP        | SCAN FOR NUMBER AFTER SPACE
   IF (CLI,0(R1),NE,X'40')            |  IF NON-BLANK FOUND
    LR   R2,R1                        |   SAVE ADDRESS IN R2
    LOOP BXH,R1,R14                   |   SCAN FOR NEXT BLANK
     IF (CLI,0(R1),EQ,X'40')          |    IF NEXT BLANK FOUND
      SLR   R1,R2                     |     CALC LENGTH OF NON-BLANKS
      IF (CH,R1,LT,=H'3')             |     IF LENGTH < 3
       BCTR  R1,0                     |      PACK INTO
       EXI   R1,(PACK,PWAD,0(*-*,R2)) |      .PWAD
      ELSE                            |     IF LENGTH >= 3
       ZAP   PWALNUM,=P'999'          |      FORCE EJECT ON NEXT PRINT
      ENDIF                           |     ENDIF
      LEAVE LOOP=SCANSP               |     LEAVE SCANSP
     ELSE                             |    ELSE IF NOT BLANK
      LEAVE LOOP=*,                   |     JUST TAKE DEFAULT OF       $
               (CLI,0(R1),LT,C'0'),OR,       ONE IF NON-NUMERIC        $
               (CLI,0(R1),GT,C'9')    |      ENCOUNTERED
     ENDIF                            |    ENDIF
    ENDLOOP BXH                       |   ENDLOOP
    LEAVE LOOP=SCANSP                 |   LEAVE SCANSP
   ENDIF                              |  ENDIF
  ENDLOOP BXH,LOOP=SCANSP             | ENDLOOP
* *-------------------------------------------------------------------*
* *  GENERATE SPACING
* *-------------------------------------------------------------------*
  LR    R2,R0                         | R2 = COUNT ON 'SPACE'
  LEAVE BLOCK=*,(CP,PWALNUM,GT,PSDLPP)  LEAVE IF OVERFLOW
  MVC   PWABLCC,PWALCC                | PUT BLANK LINES BASED ON
  PUT   PWADPRT,PWABLINE              | .CC IN STATMENT LINE
  MVI   PWALCC,X'40'                  | SET STMT LINE TO SINGLE SPACE
  BCTR  R2,0                          | ADJUST COUNT
  AP    PWALNUM,=P'1'                 | ADD ONE TO LINE NUMBER
  LOOP WHILE,(TREG,R2,NZ)             | SET CC FOR NEXT LINE
   IF (CH,R2,EQ,=H'1')                |  IF ONE SPACE
    AP    PWALNUM,=P'1'               |   ADD 1 TO LINE NUMBER
    MVI   PWALCC,C'0'                 |   SET CC TO DOUBLE SPACE
    LEAVE LOOP=*                      |   LEAVE LOOP
   ENDIF                              |  ENDIF
   IF (CH,R2,EQ,=H'2')                |  IF TWO SPACES
    AP    PWALNUM,=P'2'               |   ADD 2 TO LINE NUMBER
    MVI   PWALCC,C'-'                 |   SET CC TO TRIPLE SPACE
    LEAVE LOOP=*                      |   LEAVE LOOP
   ENDIF                              |  ENDIF
   AP    PWALNUM,=P'3'                |  ADD 3 TO LINE NUMBER
   SH    R2,=H'3'                     |  SUB 3 FROM SPACING
   LEAVE LOOP=*,(CP,PWALNUM,GT,PSDLPP)   LEAVE IF OVERFLOW
   MVI   PWABLCC,C'-'                 |  SET CC TO TRIPLE SPACE
   PUT   PWADPRT,PWABLINE             |  PUT 3 BLANK LINES
  ENDLOOP WHILE                       | KEEP LOOPING IF MORE
  SBIT  PWAF1NOW                      | INDICATE NO WRITE
 ENDBLK BLOCK=PROCESS_SPACE           |ENDBLK
 EJECT                                |
**------------------------------------------------------------------@C4
**  SUBROUTINE - PROCESS_SMLIST                                     @C4
**                                                                  @C4
**  IF SMLIST IS OPCODE, PROCESS THE LISTING OPTIONS.               @C4
**                                                                  @C4
**------------------------------------------------------------------@C4
 BLOCK TYPE=SUBROUTINE,NAME=PROCESS_SMLIST                          @C4
  L     R1,PWAAOPR                    | POINT R1 TO OPCODE FIELD    @C4
  LA    R14,1                         | SET INCREMENT TO 1          @C4
  LA    R15,PWATEXT+L'PWATEXT         | POINT R15 TO LAST BYTE      @C4
  LA    R0,1                          | ASSUME ONE SPACE            @C4
  LA    R1,6(,R1)                     | POINT R1 PAST 'SMLIST'      @C4
  LOOP  BXH,R1,R14                    | SCAN FOR NUMBER AFTER SPACE @C4
   IF (CLI,0(R1),NE,X'40')            |  IF NON-BLANK FOUND         @C4
    LR    R2,R15                      |   CALCULATE                 @C4
    SLR   R2,R1                       |    REMAINING LENGHT         @C4
    IF (CH,R2,GE,=H'11'),AND,         |   IF OPERAND IS             @C4$
               (CLC,=C'CONVERT=YES',EQ,0(R1))  CONVERT=YES          @C4
     SBIT  PWAF1CUP                   |    TURN CONVERSION ON       @C4
    ELSEIF (CH,R2,GE,=H'10'),AND,     |   ELSE IF OPERAND IS        @C4$
               (CLC,=C'CONVERT=NO',EQ,0(R1))   CONVERT=NO           @C4
     RBIT  PWAF1CUP                   |    TURN CONVERSION OFF      @C4
    ELSE                              |   ELSE                      @C4
     MVC   PWALMSG,=CL27'>E-8 INVALID SMLIST STATEMENT'  ERROR      @C4
     IF (CLI,PWAMAXRC,LT,8)           |    IF HIGHEST RC < 8        @C4
      MVI  PWAMAXRC,8                 |     SET HIGHEST TO 8        @C4
     ENDIF                            |    ENDIF                    @C4
    ENDIF                             |   ENDIF                     @C4
    LEAVE LOOP=*                      |   LEAVE LOOP                @C4
   ENDIF                              |  ENDIF                      @C4
  ENDLOOP BXH                         | ENDLOOP                     @C4
 ENDBLK BLOCK=PROCESS_SMLIST          |ENDBLK                       @C4
 EJECT                                |                             @C4
**--------------------------------------------------------------------*
**  SUBROUTINE - PROCESS_CONTINUATION_LINES
**
**  THIS SUBROUTINE PROCESSES CONTINUATION LINES AND ISSUES WARNING
**  MESSAGES FOR POSSIBLE CONTINUATION ERRORS.  A POSSIBLE
**  CONTINUATION ERROR IN WHEN COLUMN 16 OF A CONTINUATION CARD IS
**  BLANK WHEN IT IS NOT PART OF A QUOTED STRING.
**
**--------------------------------------------------------------------*
 BLOCK TYPE=SUBROUTINE,NAME=PROCESS_CONTINUATION_LINES
  L     R1,PWAAOPR                    | POINT R1 TO OPCODE FIELD
* *-------------------------------------------------------------------*
* *  IF NOT A CONDITIONAL ASSEMBLY STATEMENT, CHECK FOR POSSIBLE
* *  CONTINUATION ERRORS.
* *-------------------------------------------------------------------*
  IF           (CLC,0(4,R1),NE,=C'AGO '),AND,                          $
               (CLC,0(4,R1),NE,=C'AIF '),AND,                          $
               (CLC,0(5,R1),NE,=C'GBLA '),AND,                         $
               (CLC,0(5,R1),NE,=C'GBLB '),AND,                         $
               (CLC,0(5,R1),NE,=C'GBLC '),AND,                         $
               (CLC,0(5,R1),NE,=C'LCLA '),AND,                         $
               (CLC,0(5,R1),NE,=C'LCLB '),AND,                         $
               (CLC,0(5,R1),NE,=C'LCLC '),AND,                         $
               (CLC,0(5,R1),NE,=C'SETA '),AND,                         $
               (CLC,0(5,R1),NE,=C'SETB '),AND,                         $
               (CLC,0(5,R1),NE,=C'SETC ')
*  *------------------------------------------------------------------*
*  *  SEARCH FOR SPACE PAST MNEUMONIC.
*  *------------------------------------------------------------------*
   LA    R14,1                        |  LOAD R14 WITH INCREMENT
   LA    R15,PWATEXT+L'PWATEXT        |  POINT R15 TO BYTE AFTER TEXT
   LOOP BXH,R1,R14                    |  SEARCH FOR BLANK
    LEAVE LOOP=*,(CLI,0(R1),EQ,X'40') |   COMPLETE IF FOUND
   ENDLOOP BXH                        |  END OF SEARCH
*  *------------------------------------------------------------------*
*  *  SCAN CHARACTER BY CHARACTER THRU RECORDS
*  *------------------------------------------------------------------*
   LOOP BXH,R1,R14,NAME=SCAN_RECORD   |
*   *-----------------------------------------------------------------*
*   *  IF A COMMA IS FOUND THAT IS FOLLOWED BY A SPACE, READ
*   *  NEXT LINE AND IF COLUMN 16 IS BLANK, WARN OF A POSSIBLE
*   *  ERROR.
*   *-----------------------------------------------------------------*
    IF (CLI,0(R1),EQ,C',')            |   IF COMMA FOUND
     LA   R2,1(,R1)                   |    POINT R2 TO NEXT BYTE
     IF (CLR,R2,GE,R15),OR,           |    IF END OF CARD OR SPACE     $
               (CLI,0(R2),EQ,X'40')   |
      CALLSUB READ_CONTINUATION_LINE  |     READ CONTINUATION
      LEAVE LOOP=SCAN_RECORD,(TREG,R15,NZ)  LEAVE IF READ UNSUCCESSFUL
      IF (CLI,PWATEXT+16-1,EQ,X'40')  |     IF COL 16 BLANK
       MVC   PWALMSG(23),=C'>E-4 COLUMN 16 IS BLANK' MOVE IN ERROR MSG
       IF (CLI,PWAMAXRC,LT,4)         |      IF MAX RETURN CODE < 4
        MVI   PWAMAXRC,4              |       SET MAX TO 4
       ENDIF                          |      ENDIF
       LEAVE LOOP=SCAN_RECORD         |      STOP SCAN OF RECORD
      ENDIF                           |     ENDIF
      LEAVE BLOCK=*,(CLI,PWACONT,EQ,X'40')  STOP SCAN IF NOT CONTINUED
      LA    R1,PWATEXT+16-1           |     POINT R1 TO COL 16
      LA    R14,1                     |     REESTABLISH R14
      LA    R15,PWATEXT+L'PWATEXT     |     REESTABLISH R15
     ENDIF                            |    ENDIF
    ENDIF                             |   ENDIF
*   *-----------------------------------------------------------------*
*   *  IF QUOTE IS FOUND THAT IS NOT PRECEEDED BY A SPECIAL CHARACTER
*   *  OTHER THAN '&' FOLLOWED BY THE CHARACTER 'L', SEARCH FOR THE
*   *  ENDING QOUTE.  AN ERROR IS WARNED OF IF COLUMN 71 IS A SINGLE
*   *  QUOTE AND COLUMN 16 OF THE NEXT CARD IS A SPACE.
*   *-----------------------------------------------------------------*
    IF (CLI,0(R1),EQ,C'''')           |   IF QUOTE FOUND
     LR    R2,R1                      |    POINT R2 TWO BYTES
     SL    R2,=F'2'                   |     BEFORE CURRENT CHARACTER
     LA    R3,=C'+-,=.*()''/ '        |    POINT R3 TO SPECIAL CHARS
     LA    R4,11                      |    LOAD R4 WITH NUMBER OF CHARS
     LOOP BCT                         |    CHECK TO SEE IF CHARACTER
      LEAVE LOOP=*,(CLC,0(1,R2),EQ,0(R3))   TWO BYTES BEFORE CURRENT
      LA    R3,1(,R3)                 |     CHARACTER IS ONE OF THE
     ENDLOOP BCT,R4                   |     SPECIAL CHARS EXCEPT &
     LA     R3,0                      |    ZERO R0 WITHOUT CHANGING CC
     IF NE,OR,(CLI,1(R2),NE,C'L')     |    IF NOT SPECIAL FOLLOWED BY L
      LOOP BXH,R1,R14                 |     SCAN FOR OTHER QUOTE
       LA    R2,1(,R1)                |      POINT R2 TO NEXT BYTE
       IF (CLR,R2,GE,R15)             |      IF OUT OF CHAR ON THIS LIN
        CALLSUB READ_CONTINUATION_LINE READ CONTINUATION LINE
        LEAVE LOOP=SCAN_RECORD,(TREG,R15,NZ) LEAVE IF READ FAILED
        LA    R1,PWATEXT+16-1         |      POINT R1 TO COL 16
        LA    R14,1                   |      REESTABLISH R14
        LA    R15,PWATEXT+L'PWATEXT   |      REESTABLISH R15
        IF (CLM,R3,B'0001',EQ,=C'''') |      IF LAST CHAR WAS QUOTE
         IF (CLI,PWATEXT+16-1,EQ,X'40')       IF COL 16 IS BLANK
          MVC   PWALMSG(23),=C'>E-4 COLUMN 16 IS BLANK' MOVE ERR MSG
          IF (CLI,PWAMAXRC,LT,4)      |        IF MAX RC < 4
           MVI   PWAMAXRC,4           |         SET MAX RC TO 4
          ENDIF                       |        ENDIF
         ENDIF                        |       ENDIF
         LEAVE BLOCK=*,(CLI,PWACONT,EQ,X'40')
         LEAVE LOOP=*,(CLI,PWATEXT+16-1,NE,C'''') LEAVE IF NOT ''
        ELSE                          |      ELSE
         LEAVE BLOCK=*,(CLI,PWACONT,EQ,X'40')
         LEAVE LOOP=*,(CLI,1(R1),NE,C'''')    LEAVE IF NOT ''
         LA    R1,1(,R1)              |       SKIP SECOND '
        ENDIF                         |      ENDIF
       ENDIF                          |     ENDIF
       IC    R3,1(,R1)                |     LOAD R3 WITH NEXT BYTE
      ENDLOOP BXH                     |    ENDLOOP
     ENDIF                            |   ENDIF
    ENDIF                             |  ENDIF
*   *-----------------------------------------------------------------*
*   *  LEAVE IF SPACE FOUND OUTSIDE OF QUOTES.
*   *-----------------------------------------------------------------*
    LEAVE LOOP=*,(CLI,0(R1),EQ,X'40') |
   ENDLOOP BXH,LOOP=SCAN_RECORD       |  ENDLOOP
  ENDIF                               | ENDIF
* *-------------------------------------------------------------------*
* *  EAT REST OF CONTINUATION LINES.
* *-------------------------------------------------------------------*
  LOOP WHILE,NOT,(TBIT,PWAF1EOF),AND, | LOOP UNTIL END OF CONTINUATION $
               (CLI,PWACONT,NE,X'40') |  LINES
   CALLSUB READ_CONTINUATION_LINE     |  READ A CONTINUATION LINE
  ENDLOOP WHILE                       | ENDLOOP
 ENDBLK BLOCK=PROCESS_CONTINUATION_LINES
 EJECT                                |
**--------------------------------------------------------------------*
**  SUBROUTINE - READ_CONTINUATION_LINE
**
**  PRINT LAST LINE AND READ CONTINUATION LINE.  IF COL 1-15 IS
**  NOT BLANK, ISSUE A WARNING.
**--------------------------------------------------------------------*
 BLOCK TYPE=SUBROUTINE,NAME=READ_CONTINUATION_LINE
  CALLSUB PRINT_STATEMENT_LINE        | PRINT STATEMENT LINE
  CALLSUB READ_SYSIN_AND_WRITE_SRCOUT | GET NEXT RECORD
  LA    R15,8                         | ASSUME 8 RETURN CODE FOR SUB
  LEAVE BLOCK=*,(TBIT,PWAF1EOF)       | LEAVE IF END OF FILE
  SLR   R15,R15                       | ASSUME 0 RETURN CODE FOR SUB
  IF (CLI,PWATEXT,NE,X'40'),OR,       | IF COLUMN 1-15 IS NOT BLANK    $
               (CLC,PWATEXT+1(15-1),NE,PWATEXT)
   MVC   PWALMSG(26),=C'>E-4 COLUMN 1-16 NOT BLANK'
   IF (CLI,PWAMAXRC,LT,4)             |  IF PROGRAM RETURN CODE < 4
    MVI   PWAMAXRC,4                  |   SET PROGRAM RETURN CODE TO 4
   ENDIF                              |  ENDIF
  ENDIF                               | ENDIF
 ENDBLK BLOCK=READ_CONTINUATION_LINE  |
 EJECT                                |
**--------------------------------------------------------------------*
**  SUBROUTINE - READ_SYSIN_AND_WRITE_SRCOUT
**
**  READ A RECORD FROM SYSIN AND PLACE IT IN THE PWA.
**--------------------------------------------------------------------*
 BLOCK TYPE=SUBROUTINE,NAME=READ_SYSIN_AND_WRITE_SRCOUT
* *-----------------------------------------------------------------@C4
* *  GET A RECORD FROM THE SYSIN FILE AND IF NOT AT END OF FILE,    @C4
* *  PROCESS IT.                                                    @C4
* *-----------------------------------------------------------------@C4
  GET   PWADIN                        | GET RECORD FROM SYSIN
  IF NOT,(TBIT,PWAF1EOF)              | IF NOT END OF FILE ON SYSIN
*  *----------------------------------------------------------------@C4
*  *  MAKE TWO COPIES OF THE RECORD, ONE TO ALTER AND ONE TO LEAVE  @C4
*  *  ALONE.                                                        @C4
*  *----------------------------------------------------------------@C4
   MVC   PWALNE,0(R1)                 |  MOVE RECORD TO PWA
   MVC   PWAUNALT,0(R1)               |  MOVE UNALTERED RECORD TO PW@C4
*  *----------------------------------------------------------------@C4
*  *  IF TRANSLATION IS ON, TRANSLATE LOWER CASE TO UPPER IF IT IS N@C4
*  *  WITHIN A "ED STRING.                                          @C4
*  *----------------------------------------------------------------@C4
   IF (TBIT,PWAF1CUP),AND,            |  IF CONVERSION IS ON        @C4$
               (CLI,PWATEXT,NE,C'*'),AND, AND NOT COMMENT LINE      @C4$
               (CLC,=C'.*',NE,PWATEXT)                              @C4
    LA    R1,PWATEXT                  |   POINT R1 TO TEXT          @C4
    LA    R14,1                       |   SET INCREMENT TO 1        @C4
    LA    R15,L'PWATEXT+PWATEXT-1     |   POINT R15 TO TEXT         @C4
    LOOP  BXLE                        |   LOOP THROUGH LINE         @C4
     IF (TBIT,PWAF1QT)                |    IF WORKING ON QUOTED STNG@C4
      IF (CLI,0(R1),EQ,C'"')          |     IF DOUBLE QUOTE         @C4
       RBIT  PWAF1QT                  |      RESET "INSIDE QUOTED"  @C4
       MVI   0(R1),C''''              |      CHANGE TO SINGLE QUOTE @C4
      ENDIF                           |     ENDIF                   @C4
     ELSEIF (CLI,0(R1),EQ,C'"')       |    ELSEIF DOUBLE QUOTE      @C4
      SBIT PWAF1QT                    |     TURN ON "INSIDE QUOTED" @C4
      MVI  0(R1),C''''                |     CHANGE TO SINGLE QUOTE  @C4
     ELSE                             |    ELSE                     @C4
      TR   0(1,R1),S01_TRT_TABLE      |     TRANSLATE TO UPPER      @C4
     ENDIF                            |    ENDIF                    @C4
    ENDLOOP BXLE,R1,R14               |   ENDLOOP                   @C4
   ENDIF                              |  ENDIF                      @C4
*  *----------------------------------------------------------------@C4
*  *  IF THIS IS NOT A CONTINUED LINE AND THE QUOTED FLAG IS STILL O@C4
*  *  CONSIDER IT AN ERROR AND TURN OFF THE FLAG.                   @C4
*  *----------------------------------------------------------------@C4
   IF (TBIT,PWAF1QT),AND,(CLI,PWACONT,EQ,C' ') IF UNMATCHED QUOTE   @C4
    MVC   PWALMSG,=CL27'>E-8 ENDING QUOTE EXPECTED'  ERROR          @C4
    IF (CLI,PWAMAXRC,LT,8)            |         SET MAX             @C4
     MVI  PWAMAXRC,8                  |           RETURN            @C4
    ENDIF                             |           CODE              @C4
    RBIT  PWAF1QT                     |         RESET "INSIDE QUOTE"@C4
   ENDIF                              |        ENDIF                @C4
*  *----------------------------------------------------------------@C4
*  *  WRITE THE MODIFIED COPY OF THE RECORD TO THE OUTPUT FILE.     @C4
*  *----------------------------------------------------------------@C4
   PUT   PWADOUT,PWALNE               |  PUT COPY OF RECORD IN SRCOU@C4
  ENDIF                               | ENDIF
 ENDBLK BLOCK=READ_SYSIN_AND_WRITE_SRCOUT
 SPACE 1                              |                             @C4
         PSD ,                        |                             @C4
S01_TRT_TABLE DC 256AL1(*-S01_TRT_TABLE)                            @C4
         ORG   S01_TRT_TABLE+C'a'     |                             @C4
         DC    C'ABCDEFGHI'           |                             @C4
         ORG   S01_TRT_TABLE+C'j'     |                             @C4
         DC    C'JKLMNOPQR'           |                             @C4
         ORG   S01_TRT_TABLE+C's'     |                             @C4
         DC    C'STUVWXYZ'            |                             @C4
         ORG   ,                      |                             @C4
         ENDPSD ,                     |                             @C4
 EJECT                                |
**------------------------------------------------------------------
**  SUBROUTINE - PRINT_STATEMENT_LINE
**
**  IF A PAGE OVERFLOW OCCURS,  SKIP TO THE TOP OF A NEW PAGE
**  AND PRINT NEW TITLE AND HEADING LINES.  PAGE OVERFLOW IS
**  FORCED IN VARIOUS PARTS OF THIS PROGRAM BY SETTING CURRENT
**  LINE NUMBER TO 999.  PRINT THE PRE-PREPARED OUTPUT LINE THEN
**  CLEAR THE MESSAGE AREA IN THE LINE AND RESET THE CARRIAGE
**  CONTROL TO SINGLE SPACING.
**------------------------------------------------------------------
 BLOCK TYPE=SUBROUTINE,NAME=PRINT_STATEMENT_LINE
  IF (CP,PWALNUM,GT,PSDLPP)           | IF PAGE OVERFLOW THEN
   AP    PWAPGN,=P'1'                 |  ADD ONE TO PAGE NUMBER
   MVC   PWATPGN,PSDMPGN              |  MOVE PAGE NUM MASK TO TITLE
   ED    PWATPGN,PWAPGN               |  EDIT PAGE NUMBER INTO TITLE
   PUT   PWADPRT,PWAT                 |  PUT TITLE LINE
   PUT   PWADPRT,PWAH                 |  PUT HEADING LINE
   MVI   PWALCC,C'0'                  |  NEXT LINE SHOULD DOUBLE SPACE
   ZAP   PWALNUM,=P'5'                |  SET LINE NUMBER
  ENDIF                               | ENDIF
  MVC   PWALTEXT,PWAUNALT             | MOVE LINE TO OUTPUT LINE    @C4
  PUT   PWADPRT,PWAL                  | PUT LINE
  FILL  PWALMSG,X'40'                 | CLEAR MESSAGE
  MVI   PWALCC,X'40'                  | RESET TO SINGLE SPACEING
  AP    PWALNUM,=P'1'                 | ADD ONE TO LINE NUMBER
 ENDBLK BLOCK=PRINT_STATEMENT_LINE    |
 EJECT                                |
**--------------------------------------------------------------------*
**  SUBROUTINE - NEST
**
**  PARAMETERS - (CL1-TYPE)
**
**  THE ONE BYTE TYPE PASSED IS PUSHED ON THE NESTING STACK.  IF THE
**  STACK DOES NOT OVERFLOW, THE CURRENT NESTING LEVEL AND A GROUP OF
**  16 BYTE FROM SIZE DIV 16 * 16 INTO THE STACK ARE MOVED TO THE
**  PRINT LINE.  IF THE STACK OVERFLOWS, AN ERROR MESSAGE IS MOVED TO
**  THE MESSAGE AREA OF THE PRINT LINE AND *'S MOVED WHERE THE 16
**  BYTES OF THE STACK WOULD HAVE BEEN MOVED.
**--------------------------------------------------------------------*
   SPACE 1                            |
 BLOCK NAME=NEST,TYPE=SUBROUTINE      |
  L     R1,0(,R1)                     | POINT R1 TO ONLY PARAMETER
  IC    R0,0(,R1)                     | INSERT TYPE PASSED IN R0
  LH    R15,PWANSTL                   | LOAD LENGTH OF STACK
  IF (CH,R15,LT,=Y(L'PWANSTK))        | IF STACK WILL NOT OVERFLOW
   STC   R0,PWANSTK(R15)              |  STORE BYTE ON STACK
   SRA   R15,4                        |  DIVIDE LENGTH BY 16
   SLA   R15,4                        |  CALCULATE LENGTH / 16 * 16
   LA    R15,PWANSTK(R15)             |  POINT R15 TO GROUP TO 16 BYTES
   MVC   PWALNST,0(15)                |  MOVE GROUP TO PRINT LINE
  ELSE                                | IF STACK OVERFLOWED
   FILL  PWALNST,C'*'                 |  MOVE *'S TO NESTING PART OF LI
   MVC   PWALMSG(19),=C'>E-4 STACK OVERFLOW' MOVE ERROR MESSAGE
   IF (CLI,PWAMAXRC,LT,4)             |  IF MAX RETURN CODE < 4
    MVI   PWAMAXRC,4                  |   MOVE 4 TO MAX RETURN CODE
   ENDIF                              |  ENDIF
  ENDIF                               | ENDIF
  LH    R15,PWANSTL                   | LOAD LENGTH OF STACK
  LA    R15,1(,R15)                   | INCREMENT
  STH   R15,PWANSTL                   | STORE NEW LENGTH OF STACK
  CVD   R15,PWAD                      | CONVERT NESTING DEPTH TO DEC
  UNPK  PWALNL,PWAD                   | UNPACK INTO LINE
  OI    PWALNL+L'PWALNL-1,X'F0'       | REMOVE SIGN
  MVI   PWALPLS,X'40'                 | MOVE SPACE TO >16 FLAG
  IF (CH,R15,GT,=H'16')               | IF DEPTH > 16
   MVI   PWALPLS,C'+'                 |  MOVE PLUS SIGN TO >16 FLAG
  ENDIF                               | ENDIF
 ENDBLK BLOCK=NEST                    |
 EJECT                                |
**--------------------------------------------------------------------*
**  SUBROUTINE - UNNEST
**
**  PARAMETERS - (CL1-TYPE)
**
**  THE ONE BYTE TYPE PASSED SHOULD BE EQUAL TO THE TOP ELEMENT ON THE
**  NESTING STACK.  IF IT MATCHES, THE ELEMENT IS POPPED OFF THE
**  STACK.  IF NOT, AN ERROR MESSAGE IS MOVED TO THE PRINT LINE.  IN
**  BOTH CASES,  16 BYTES OF THE STACK ARE MOVE TO THE PRINT LINE AS
**  DISCRIBED IN SUBROUTINE NEST.
**--------------------------------------------------------------------*
   SPACE 1                            |
 BLOCK NAME=UNNEST,TYPE=SUBROUTINE    |
  L     R1,0(,R1)                     | POINT R1 TO ONLY PARAMETER
  IC    R0,0(,R1)                     | INSERT TYPE PASSED IN R0
  LH    R15,PWANSTL                   | LOAD LENGTH OF STACK
  BCTR  R15,0                         | SUBTRACT 1
  IF (TREG,R15,NM)                    | IF STACK HAS NOT UNDERFLOWED
   IF (CH,R15,LT,=Y(L'PWANSTK))       |  IF STACK IS NOT IN OVERFLOW
    LA    R1,PWANSTK(R15)             |   POINT R1 TO TO ELEMENT OF STK
    IF (CLM,R0,B'0001',EQ,0(R1))      |   IF TOP ELEMENT IS CORRECT
     STH   R15,PWANSTL                |    STORE NEW LENGTH OF STACK
     CVD   R15,PWAD                   |    CONVERT NESTING DEPTH TO DEC
     UNPK  PWALNL,PWAD                |    UNPACK INTO LINE
     OI    PWALNL+L'PWALNL-1,X'F0'    |    REMOVE SIGN
     MVI   PWALPLS,X'40'              |    MOVE SPACE TO >16 FLAG
     IF (CH,R15,GT,=H'16')            |    IF DEPTH > 16
      MVI   PWALPLS,C'+'              |     MOVE PLUS SIGN TO >16 FLAG
     ENDIF                            |    ENDIF
     MVI   0(R1),X'40'                |    BLANK OUT OLD ELEMENT
     BCTR  R15,0                      |    SUB 1 FROM R15
     SRA   R15,4                      |    DIVIDE LENGTH BY 16
     SLA   R15,4                      |    CALCULATE LENGTH / 16 * 16
     IF M                             |    IF NEGATIVE
      LA    R15,0                     |     SET R15 TO ZERO
     ENDIF                            |    ENDIF
     LA    R15,PWANSTK(R15)           |    POINT R15 TO 16 BYTE GROUP
     MVC   PWALNST,0(15)              |    MOVE GROUP TO PRINT LINE
    ELSE                              |   IF TOP ELEMENT NOT CORRECT
     MVC   PWALMSG(20),=C'>E-8 NESTING PROBLEM' MOVE ERROR MESSAGE
     IF (CLI,PWAMAXRC,LT,8)           |    IF MAX RC < 8
      MVI   PWAMAXRC,8                |     SET MAX RC TO 8
     ENDIF                            |    ENDIF
    ENDIF                             |   ENDIF
   ELSE                               |  IF STACK IS STILL OVERFLOWED
    STH   R15,PWANSTL                 |   SAVE NEW LENGTH OF STACK
    CVD   R15,PWAD                    |   CONVERT NESTING DEPTH TO DEC
    UNPK  PWALNL,PWAD                 |   UNPACK INTO LINE
    OI    PWALNL+L'PWALNL-1,X'F0'     |   REMOVE SIGN
   ENDIF                              |  ENDIF
  ELSE                                | IF STACK WILL UNDERFLOW
   MVC   PWALMSG(22),=C'>E-8 NESTING UNDERFLOW' MOVE ERROR MESSAGE
   IF (CLI,PWAMAXRC,LT,8)             |  IF MAX RETURN CODE < 8
    MVI   PWAMAXRC,8                  |   MOVE 8 TO MAX RETURN CODE
   ENDIF                              |  ENDIF
  ENDIF                               | ENDIF
 ENDBLK BLOCK=UNNEST                  |
 EJECT                                |
**--------------------------------------------------------------------*
**  ERREXIT (UNNAMED)
**
**  WTO ERROR MESSAGE BASED ON CODE IN R14
**
**--------------------------------------------------------------------*
   SPACE 1                            |
 BLOCK TYPE=ERREXIT                   |ERREXIT (UNNAMED)
  MVC   PWAOPNER,PSDOPNER             | MOVE WTO LIST FORM TO PWA
  CASEBLK REG=R14                     | MOVE DDNAME FAILING TO WTO MSG
  CASE 0                              | CASE 0
   MVC   PWAEDDN,=CL8'SYSIN'          |  SYSIN DATASET OPEN ERROR
  CASE 1                              | CASE 1
   MVC   PWAEDDN,=CL8'SYSPUNCH'       |  SYSPUNCH DATASET OPEN ERROR
  CASE 2                              | CASE 2
   MVC   PWAEDDN,=CL8'SYSPRINT'       |  SYSPRINT DATASET OPEN ERROR
  ENDCASE                             | ENDCASE
  WTO   MF=(E,PWAOPNER)               | USE WTO TO ISSUE MESSAGE
  LA    R15,16                        | SET BASE RETURN CODE
 ENDBLK ,                             |ENDBLK
         TITLE 'PROGRAM STATIC DATA'  |
         PSD                          |
PSDOPNER WTO   'ERROR OPENING DDNAME=........',MF=L,ROUTCDE=11
PSDEDDN  EQU   PSDOPNER+4+21,8,C'C'   | TAG FOR DDNAME
PSDOPNER_LENGTH EQU *-PSDOPNER        | LENGTH OF WTO LIST FORM
         SPACE 1                      |
PSDMTME  DC    X'402120',C':',X'2020' | MASK FOR TIME
PSDMDTE  DC    X'402120',C'.',X'202020' MASK FOR DATE
PSDMPGN  DC    X'402020202120'        | MASK FOR PAGE
         SPACE 1                      |
PSDLPP   DC    PL2'60'                | MAXIMUM LINES PER PAGE
         SPACE 1                      |
*        TITLE LINE
PSDT     DC    CL137' '               | TITLE LINE 1
         ORG   PSDT                   | ORG TO START OF TITLE LINE
         DC    AL2(137)               | LENGTH OF LINE
         DC    AL2(0)                 |
         DC    C'1'                   | SKIP TO TOP OF PAGE
PSDTID   DC    CL8' '                 | ID FROM TITLE
         DC    C' '                   | SPACE
PSDTDTA  DC    CL100' '               | DATA FROM TITLE STATEMENT
         DC    CL12' '                | TIME
         DC    C' PAGE'               | C'PAGE'
PSDTPGN  DC    CL6' '                 | PAGE NUMBER
         ORG   ,                      |
         SPACE 1                      |
*        HEADING LINE
PSDH     DC    CL137' '               | PRINT LINE
         ORG   PSDH                   | ORG TO START OF LINE
         DC    AL2(137)               |
         DC    AL2(0)                 |
         DC    C'-'                   | CC
         DC    CL3'LVL'               | NESTING DEPTH
         DC    C' '                   | SPACE
         DC    C'+'                   | PLUS SIGN IF DEEPER THAN 16
         DC    CL16'    NESTING     ' | NESTING INFO
         DC    C'  '                  |
         DC    CL80' SOURCE STATEMENT'  TEXT OF LINE
         DC    C'  '                  |
         DC    C'MSC0150$ V1R4 '      | PROGRAM VERSION AND RELEASE @C4
PSDHTME  DC    CL6' '                 | TIME
PSDHDTE  DC    CL7' '                 | DATE
         ORG   ,                      |
         SPACE 1                      |
*        LINE
PSDL     DC    CL137' '               | PRINT LINE
         ORG   PSDL                   | ORG TO START OF LINE
         DC    AL2(137)               |
         DC    AL2(0)                 |
PSDLCC   DC    C' '                   | CC
PSDLNL   DC    CL3' '                 | NESTING LEVEL
         DC    C' '                   | SPACE
PSDLPLS  DC    C' '                   | PLUS SIGN IF DEEPER THAN 16
PSDLNST  DC    CL16' '                | NESTING INFO
         DC    C' |'                  |
PSDLTEXT DC    CL80' '                | TEXT OF LINE
         DC    C'| '                  |
PSDLMSG  DC    CL27' '                | MESSAGE
         ORG   ,                      |
         SPACE 1                      |
*        BLANK LINE USED IN SPACING
PSDBLINE DC    AL2(6),AL2(0)          | BLANK LINE
PSDBLCC  DC    C' '                   | CC
         DC    C' '                   | BLANK FOR BLANK LINE
PSDBLINE_LENGTH EQU *-PSDBLINE        | LENGTH OF BLANK LINE
         SPACE 1                      |
*        NOT AT LEVEL ZERO ERROR MESSAGE
PSDERLVL DC    AL2(45),AL2(0),C'0>E-8 ENDING STRUCTURAL LEVEL IS NON-ZE$
               RO'                    |
         SPACE 1                      |
*        LITERAL POOL                                               @C4
         LTORG ,                      |                             @C4
         SPACE 1                      |                             @C4
PSDOPN3  OPEN  (*,,*,,*),MF=L         |
PSDOPN3_LENGTH EQU *-PSDOPN3          |
         SPACE 3                      |
PSDDIN   DCB   DDNAME=SYSIN,MACRF=GL,EODAD=EODADIN,DSORG=PS
PSDDIN_LENGTH EQU *-PSDDIN            |
         SPACE 3                      |
PSDDOUT  DCB   DDNAME=SYSPUNCH,MACRF=PM,LRECL=80,DSORG=PS,RECFM=FB
PSDDOUT_LENGTH EQU *-PSDDOUT          |
         SPACE 3                      |
PSDDPRT  DCB   DDNAME=SYSPRINT,MACRF=PM,LRECL=137,                     $
               RECFM=VBA,DSORG=PS     |
PSDDPRT_LENGTH EQU *-PSDDPRT          |
         SPACE 3                      |
         ENDPSD ,                     |                             @C4
         TITLE 'DSECTS'               |
         PUSH  PRINT                  |
         PRINT NOGEN                  |
         DCBD  DSORG=PS               |
         POP   PRINT                  |
         SPACE 3                      |
         TITLE 'PROGRAM WORK AREA'    |
         PWA                          |
PWAD     DS    D                      | WORK DOUBLE WORD
PWAAOPR  DS    A                      | ADDRESS OF OPERATION FIELD
PWAF1    DS    BL1                    | BIT FLAG
PWAF1EOF EQU   B'10000000'            |   END OF FILE ON SYSIN
PWAF1NOW EQU   B'01000000'            |   DO NOT WRITE
PWAF1QT  EQU   B'00100000'            |   INSIDE OF A QUOTED STRING @C4
PWAF1CUP EQU   B'00010000'            |   CONVERT TO UPPER IS ON    @C4
PWALNUM  DS    PL2                    | LINE NUMBER (TITLES FIRST TIME)
PWAPGN   DS    PL3                    | PAGE NUMBER
PWAMNL   DS    PL3                    | MACRO NESTING LEVEL
PWAMAXRC DS    X                      | MAXIMUM RETURN CODE
PWANSTK  DS    CL256                  | NESTING STACK
PWANSTL  DS    H                      | DISP OF NEXT ELEMENT ON STACK
*        INPUT LINE
PWALNE   DS    0CL80                  | INPUT LINE
PWATEXT  DS    CL71                   | LINE TEXT
PWACONT  DS    C                      | CONTINUE
         DS    CL8                    | LINE NUMBER
*        TITLE LINE
PWAT     DS    CL(L'PSDT)             | TITLE LINE 1
PWATID   EQU   PWAT+PSDTID-PSDT,L'PSDTID,C'C'      SEE PSDTID
PWATDTA  EQU   PWAT+PSDTDTA-PSDT,L'PSDTDTA,C'C'    SEE PSDTDTA
PWATPGN  EQU   PWAT+PSDTPGN-PSDT,L'PSDTPGN,C'C'    SEE PSDTPGN
*        HEADING LINE
PWAH     DS    CL(L'PSDH)             | HEADING LINE
PWAHTME  EQU   PWAH+PSDHTME-PSDH,L'PSDHTME,C'C'    SEE PSDHTME
PWAHDTE  EQU   PWAH+PSDHDTE-PSDH,L'PSDHDTE,C'C'    SEE PSDHDTE
*        UNALTERED LINE                                             @C4
PWAUNALT DS    CL80                   | UNALTERED PRINT LINE        @C4
*        LINE
PWAL     DS    CL(L'PSDL)             | PRINT LINE
PWALCC   EQU   PWAL+PSDLCC-PSDL,L'PSDLCC,C'C'      SEE PSDLCC
PWALNL   EQU   PWAL+PSDLNL-PSDL,L'PSDLNL,C'C'      SEE PSDLNL
PWALPLS  EQU   PWAL+PSDLPLS-PSDL,L'PSDLPLS,C'C'    SEE PSDLPLS
PWALNST  EQU   PWAL+PSDLNST-PSDL,L'PSDLNST,C'C'    SEE PSDLNST
PWALTEXT EQU   PWAL+PSDLTEXT-PSDL,L'PSDLTEXT,C'C'  SEE PSDLTEST
PWALMSG  EQU   PWAL+PSDLMSG-PSDL,L'PSDLMSG,C'C'    SEE PSDLMSG
*        BLANK LINE USED IN SPACING
PWABLINE DS    CL(PSDBLINE_LENGTH)    | BLANK LINE
PWABLCC  EQU   PWABLINE+PSDBLCC-PSDBLINE,L'PSDBLCC SEE PSDBLCC
*        ERROR WTO STORAGE
         DS    0F                     | INSURE FULLWORD ALIGNMENT
PWAOPNER DS    CL(PSDOPNER_LENGTH)    |
PWAEDDN  EQU   PWAOPNER+PSDEDDN-PSDOPNER           SEE PSDEDDN
*        DCB STORAGE
         DS    0F                     | INSURE FULLWORD ALIGNMENT
PWAOPN3  DS    XL(PSDOPN3_LENGTH)     |
         DS    0D                     | INSURE DOUBLEWORD ALIGNMENT
PWADIN   DS    XL(PSDDIN_LENGTH)      |
         DS    0D                     | INSURE DOUBLEWORD ALIGNMENT
PWADOUT  DS    XL(PSDDOUT_LENGTH)     |
         DS    0D                     | INSURE DOUBLEWORD ALIGNMENT
PWADPRT  DS    XL(PSDDPRT_LENGTH)     |
         ENDPWA ,                     |
         END     ,                    |
