//TCS1028A JOB (12345),'SELECTIT ASMLINK',MSGCLASS=X,
//             USER=TCS1028,PASSWORD=SPFLITE
//ASM      EXEC PGM=ASMA90,PARM='OBJECT,NODECK,USING(WARN(8))'
//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR
//         DD DSN=SYS1.MODGEN,DISP=SHR
//SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,(20,5)),DSN=&SYSUT1
//SYSPUNCH DD SYSOUT=*
//SYSPRINT DD SYSOUT=*
//SYSLIN   DD UNIT=SYSDA,SPACE=(CYL,(20,5)),DSN=&OBJ,DISP=(,PASS)
//SYSIN DD *
SELECTIT TITLE 'Program Memory/Module structure'
*
*---------------------------------------------------------------------+
*                                                                     |
* Overview                                                            |
* ========                                                            |
*                                                                     |
* SELECTIT is a utility which provides a wide variety of functions    |
* related to copying, printing and/or modifying datasets.  Any and all|
* SELECTIT functions can be combined in a single run or requested     |
* individually, as you desire.                                        |
*                                                                     |
* SELECTIT can sequentially read up to 9 input files (sequential,     |
* partitioned, ISAM, or keyed VSAM) and selectively create any number |
* of output files.                                                    |
*                                                                     |
* You may use SELECTIT to copy records (with or without alteration of |
* the records) and/or print them.                                     |
*                                                                     |
* Features                                                            |
* ========                                                            |
*                                                                     |
* ** File Copy Copy a record from an input file to an output file     |
*    (unconditionally).                                               |
*                                                                     |
* ** Selective Copy Copy a record only if your supplied condition is  |
*    met.                                                             |
*                                                                     |
* ** Limit Copy Copy a limited number of records (possibly in         |
*    conjunction with a user supplied condition).                     |
*                                                                     |
* ** File print Print record(s) from an input file.                   |
*                                                                     |
* ** Alter Data Replace the data in any portion of the record with    |
*    your supplied constant data, data from other locations in the    |
*    record or data from SELECTIT provided variables (date, jobname,  |
*    datasetname, etc.).                                              |
*                                                                     |
* ** Record reformat A record can be completely reformatted, fields   |
*    can be modified, deleted and/or added.                           |
*                                                                     |
* Changes                                                             |
* =======                                                             |
*                                                                     |
* 2019/04/09 Peter Glanzmann (peter@glanzmann.org)                    |
*            Support EAV volumes (Extended Address Volumes)           |
*                                                                     |
*---------------------------------------------------------------------+
* Send questions, suggestions and/or bug reports to:                  |
*                                                                     |
* gddeluca@gmail.com                                                  |
*                                                                     |
* George D. Deluca                                                    |
* 116-2075 Amherst Heights Drive                                      |
* Burlington, Ontario                                                 |
* L7P 5B8                                                             |
* Canada                                                              |
*---------------------------------------------------------------------+
* This program is free software: you can redistribute it and/or       |
* modify it under the terms of the GNU General Public License as      |
* published by the Free Software Foundation, either version 3 of      |
* the License, or (at your option) any later version.                 |
*                                                                     |
* This program is distributed in the hope that it will be useful,     |
* but WITHOUT ANY WARRANTY; without even the implied warranty of      |
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the        |
* GNU General Public License for more details.                        |
*                                                                     |
* You should have received a copy of the GNU General Public License   |
* along with this program. If not, see <http://www.gnu.org/licenses/> |
*---------------------------------------------------------------------+
*
*---------------------------------------------------------------------+
*    Memory layout for SELECTIT
*    ==========================
*
*    +--------------------------+
*    | Initialization and procs | <-- Base R12,R11
*    | which must be addressable|
*    | to all other routines.   |
*    +--------------------------+
*    | Asynch STAE abend exit   |
*    +--------------------------+
*    | Proc 1                   | <-- Base R8 (Opt.R10 during compile)
*    +--------------------------+
*    .    Other $PROC's ...     . <-- Base R8
*    .      .     .             .      .   .
*    V      V     V             V      V   V
*    +--------------------------+
*    | Proc n                   |
*    +--------------------------+
*    | Savearea and global data | <-- Base R13
*    +--------------------------+
*    | Unaddressable Data areas |
*    +--------------------------+
*
         TITLE 'Program MACRO definitions'
*---------------------------------------------------------------------+
*        $SKIP - Force skip to the end of this sentence.              |
*---------------------------------------------------------------------+
         MACRO
&NAME    $SKIP
&NAME    AP    COMNTCTL,=P'1'
         NI    PCTF1,255-ACTIVE
         L     R8,=A(MAINCOMP)
         B     8(R8)
         MEND
*---------------------------------------------------------------------+
*        $ERR - Issue messages to the user.                           |
*---------------------------------------------------------------------+
         MACRO
&NAME    $ERR  &ERRNO,&LEVEL,&SKIP,&SAVE=NO,&TYPE=MSG,&GO=,&FLAG=YES
&NAME    LA    R1,ERR&ERRNO
         LA    R2,&LEVEL
         AIF   ('&FLAG' EQ 'YES').SKFL
         OI    PCTF4,NOFLAG
.SKFL    AIF   ('&SAVE' EQ 'NO').NO
         SR    R3,R3
         AGO   .BAL
.NO      ANOP
         LA    R3,1
.BAL     AIF   ('&TYPE' NE 'STAT').BALBAL
         OI    PCTF1,STAT
.BALBAL  ANOP
         $CALL ERRSTORE
         AIF   (T'&SKIP EQ 'O').SEEGO
         $SKIP
         AGO   .MEXIT
.SEEGO   AIF   ('&GO' EQ '').MEXIT
         B     &GO
.MEXIT   MEND
*---------------------------------------------------------------------+
*        $ADD  - Add code blocks to the compiled program              |
*---------------------------------------------------------------------+
         MACRO
&NAME    $ADD  &L,&LOC
&NAME    LA    R1,&L
         LA    R2,&LOC
         $CALL PGMSTUFF
         MEND
         EJECT
*---------------------------------------------------------------------+
*        $TXT   - Generate message text blocks.                       |
*---------------------------------------------------------------------+
         MACRO
         $TXT  &N,&L,&T,&TYPE=STD
         LCLA  &A
         GBLA  &ERRCNT
         AIF   ('&TYPE' NE 'END').STD
&ERRCNT  SETA  &ERRCNT+1
*
ERRTX&ERRCNT EQU *
ERRTBL   DS    0F
&A       SETA  1
.ERRLOOP AIF   (&A GE &ERRCNT).MEXIT
         DC    A(ERRTX&A)
&A       SETA  &A+1
         AGO   .ERRLOOP
.STD     ANOP
&A       SETA  &N
&A       SETA  &A+1
ERRTX&N  DC    AL1(ERRTX&A-ERRTX&N-2),C&T
ERR&L    EQU   &N
         AIF   (&N LT &ERRCNT).MEXIT
&ERRCNT  SETA  &N
.MEXIT   MEND
         EJECT
*---------------------------------------------------------------------+
*        Misc. minor macros                                           |
*---------------------------------------------------------------------+
         MACRO
&NAME    $INC  &LABEL
&NAME    L     R14,&LABEL
         AH    R14,=H'1'
         ST    R14,&LABEL
         MEND
*
*
         MACRO
         $KW   &ID,&KW,&F1=0,&F2=0,&F3=0,&D1=A(0),&D2=A(0),&D3=A(0)
         LCLA  &A
         DC    A(0)
&A       SETA  K'&KW
         AIF   (&A GT 10).KWER
         DC    H'&A'
         DC    CL10'&KW'
         DC    AL1(&F1,&F2,&F3)
&A       SETA  K'&ID
         AIF   (&A GT 2).IDER
         DC    X'&ID'
         DC    &D1
         DC    &D2
         DC    &D3
         MEXIT
.KWER    MNOTE 8,'$KW ERROR IN KEYWORD OPERAND'
         MEXIT
.IDER    MNOTE 8,'$KW ERROR IN ID OPERAND'
         MEXIT
         MEND
         EJECT
*---------------------------------------------------------------------+
*        Subroutine Support Macros                                    |
*---------------------------------------------------------------------+
         MACRO
&NAME    $CALL &PROC
         LCLA  &A,&B
&A       SETA  N'&SYSLIST
&NAME    L     R15,=A(&PROC)
         ST    R8,4(R15)
         AIF   (&A EQ 1).BALR
&B       SETA  2
.LOOP    AIF   (&B GT &A).BALR
         AIF   ('&SYSLIST(&B)'(1,1) EQ '(').REG
         LA    R14,&SYSLIST(&B)
         ST    R14,(&B+1)*4(R15)
         AGO   .BBUMP
.REG     ST    &SYSLIST(&B),(&B+1)*4(R15)
.BBUMP   ANOP
&B       SETA  &B+1
         AGO   .LOOP
.BALR    BALR  R8,0
         LA    R8,14(,R8)
         ST    R8,0(R15)
         LR    R8,R15
         B     8(R8)
         MEND
         MACRO
*
&NAME    $RET  &DISP
         LCLA  &D
&D       SETA  &DISP
&NAME    L     R15,0(R8)
         AIF   (&D EQ 0).BR
         LA    R15,&D.(,R15)
.BR      L     R8,4(R8)
         BR    R15
         MEND
*
         MACRO
&NAME    $PROC &NUM
         LCLA  &A
&A       SETA  0
         AIF   (T'&NUM EQ 'O').NUN
&A       SETA  &NUM
.NUN     DS    0F
         USING *,R8
&NAME    DC    2A(0)
         AIF   (&A EQ 0).MEND
         B     *+((&A+1)*4)
         DS    &A.F
.MEND    MEND
*
         MACRO
&NAME    $PEND
         PRINT OFF
         LTORG
         DROP  R8
         PRINT ON
         MEND
         TITLE 'Initialization'
SELECTIT CSECT
         PRINT NOGEN
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
AREG     EQU   4
BREG     EQU   6
OREG     EQU   5
PCTBASE  EQU   13
*---------------------------------------------------------------------+
*        Register Usage                                               |
*               R0  --  Work                                          |
*               R1  --  Work                                          |
*               R2  --  Work                                          |
*               R3  --  Work                                          |
*               R4  --  Work / A-REG                                  |
*               R5  --  Work / O-REG                                  |
*               R6  --  Work / B-REG                                  |
*               R7  --  Work / FCB base usually, but not always       |
*               R8  --  Base for independent Procs                    |
*               R9  --  Work                                          |
*               R10 --  Param ptr in compiled code/Base during compile|
*               R11 --  Program Base                                  |
*               R12 --     "     "                                    |
*               R13 --  Savearea and data area base                   |
*               R14 --  Work                                          |
*               R15 --  Work                                          |
*---------------------------------------------------------------------+
         EJECT
*---------------------------------------------------------------------+
*        Get ourselves addressable etc.                               |
*---------------------------------------------------------------------+
         B     SKIPCOPR-SELECTIT(,R15)
         DC    C'SELECTIT'
         DC    CL44' (C) Copyright G.D. Deluca. 1974, 2013'
         DC    CL8'&SYSDATE'
*
SKIPCOPR STM   R14,R12,12(R13)     Setup base regs etc
         LR    R12,R15             .
         USING SELECTIT,R12,R11    .
         L     R2,FOURK            .
         LR    R11,R12             .
         AR    R11,R2              .
         L     R8,SAVEADDR         .
         ST    R13,4(R8)           .
         ST    R8,8(R13)           .
         LR    R13,R8              .
         USING SAVEAREA,R13        Set some USINGs
         USING SELDSECT,R15
         USING FCBDSECT,R7
         L     R1,0(R1)            Got a PARM field?
         LH    R3,0(R1)            Get it's length
         LTR   R3,R3               Any?
         BZ    NOPARM              No
         CLC   2(7,R1),=C'OPTIONS' Silly twit specify OPTIONS itself?
         BNE   NOOPT               No, O.K.
         LA    R1,8(,R1)           Yes, step over it
         SH    R3,=H'8'            Adjust length
         BNP   NOPARM              Skip if that was all
*
NOOPT    BCTR  R3,0                -1 for EX
         EX    R3,*+4              Move it
         MVC   PARMDATA+8(0),2(R1)
         LA    R4,PARMDATA+8(R3)
         CLI   0(R4),C'.'          Does it have a .
         BE    *+8                 Yes, don't add another
         MVI   1(R4),C'.'          No, terminate with period
         LA    R3,9(,R3)           Adjust length
         ST    R3,GETSCLN          Save for GETWORD
         LA    R3,PARMDATA         Point at OPTIONS statement now
         ST    R3,GETPTR           Save for GETWORD
         ST    R3,GETIMAGE         Save for error processors
         ST    R3,GETWSTRT         .
         OI    PCTF1,DFLTFLAG      Set default flag
         LM    R3,R6,GETDPTRS      Shift default pointers right
         STM   R3,R6,GETDPTRS+4    .
         MVC   GETDPTRS(4),=F'-1'  Flag as PARM 1st
         MVC   LINE+17(110),PARMDATA
         MVC   LINE(5),=C'00000'
         OI    PCTF4,PWAITING
         LA    R14,PARMDATA        Yes, search PARMDATA
         LA    R15,110             .
         CLC   =C'PDSMODE(ON)',0(R14)
         BE    *+16                Got it, go set PDSMODE
         LA    R14,1(,R14)         No, loop through field
         BCT   R15,*-14            .
         B     NOPARM              No present, ignore PDSMODE
         OI    PCTF8,PDSMODE       PDSMODE found, set flag
*
NOPARM   B     MAINPGM             Continue
*
SAVEADDR DC    A(SAVEAREA)
FOURK    DC    F'4096'
         TITLE 'Super Main line'
*---------------------------------------------------------------------+
*        This is the supposed Main line of the beast.                 |
*---------------------------------------------------------------------+
MAINPGM  $CALL INITPROC  Go do all the basic initialization stuff     |
         $CALL INITIODD  Go OPEN up our standard files                |
*                                                                     |
REDOSLCT $CALL INISLECT  Set the program mode based on the DD's found |
         $CALL MAINCOMP  Compile the user's requests now.             |
*                                                                     |
REDOCOPY $CALL COPYDATA  O.K. Now go do I/O (Our real purpose in life)|
*                                                                     |
ADDSTATS $CALL EOJ       Various places will come here to terminate   |
         B     REDOCOPY  If EOJ returns, PDSMODE active, member loop  |
*---------------------------------------------------------------------+
         TITLE 'STAE retry routine'
*---------------------------------------------------------------------+
*        STAE retry comes here if ABEND was a User abend or an abend  |
*        while executing in, or on behalf of, the user's program.     |
*                                                                     |
*        All the recovery consists of is:                             |
*              a) Re-load a good set of registers                     |
*              b) Dump the active record at the time of abend         |
*                 if not still in COMPILE phase.                      |
*              c) Terminate with appropriate messages                 |
*---------------------------------------------------------------------+
*
ABNDRCVR L     R1,0(R1)            Get address of STAESAVE
         LM    R0,R15,0(R1)        Reload regs
         TM    PCTF7,TIMEBOMB      Timer forced ABEND?
         BZ    ABNDTCMP            No, continue
         $ERR  LOOPR,16,FLAG=NO    Issue 'why' message before ABND one
*
ABNDTCMP TM    PCTF4,COMPILE       Still in COMPILE mode?
         BO    ADDSTATS            Yes, skip record dump & Msgs
         TM    PCTF1,EXEC          Executing in Compiled program?
         BZ    ADDSTATS            No, also skip
         MVC   TRADDR,PCTINPT1     Move address of record for DMPIT
         L     R15,PCTINPL1        Fudge length of record for DMPIT
         ST    R15,TRLGTH
         LA    R14,TRFLAG-1          "   R15(R14) for DMPIT
         $CALL DMPIT               Go dump record now
*
ABNDJABN $ERR  ABND,16,GO=ADDSTATS,FLAG=NO Issue ABEND message
         TITLE 'CONTAINS - See if record contains a field.'
*---------------------------------------------------------------------+
*        Do initialization for the scan.                              |
*---------------------------------------------------------------------+
*
CONTAINS STM   R4,R6,CONTSAVE      Save everything
         SR    R15,R15             Clear R15
         ST    R5,OREGM            Save OREG in memory
         ICM   R5,12,=X'0000'      Clear hi order bytes in OREG
         TM    PCTIOFLG,IOFLOATA   Is A operand floating?
         BO    *+10                Yes, R4/R6 are O.K.
         XR    R4,R6               No, swap R4/R6 around
         XR    R6,R4               .
         XR    R4,R6               .
         STCM  R4,8,CONTFILE+3     Replace file number
         LA    R4,0(,R4)           Purify hi-bytes of param regs
         LA    R6,0(,R6)           .
         XC    TRTABLE,TRTABLE     Clear TRT table
         IC    R15,0(R6)           Get first char from B-operand
         LA    R15,TRTABLE(R15)    Point at it's loc in TRT table
         MVI   0(R15),X'FF'        Make it non-zero
         SR    R15,R15             Clear R15 again
         L     R15,CONTFILE        Insert file number
         SLL   R15,2               x 4
         L     R5,PCTINPL1-4(R15)  Get length of current record
         L     R7,PCTINPT1-4(R15)  Load start address of record
         ST    R7,CONTSADR         Save start address locally
         AR    R5,R7               Point at last byte of record
         LR    R15,R4              Get start of scan
         AH    R15,OREGBLEN        Add length of literal
         CR    R15,R5              Room in record to find this?
         BH    CONTNFND            Whoops, not this one!
         LR    R7,R5               Get end of record
         SR    R7,R4               Calc remaining length of record
         BCTR  R7,0                -1 for EX
         LH    R5,OREGBLEN         Get literal length
         BCTR  R5,0                -1 for EX
         EJECT
*---------------------------------------------------------------------+
*        Do tests while length is > 256.                              |
*---------------------------------------------------------------------+
*
CONTLP1  CLM   R7,14,ZEROS         Is length > 256?
         BE    CONTLAST            No, go test remaining chunk
         LR    R1,R4               Swap address to R1
         LA    R15,255             Set for 256 bytes
         LR    R9,R4               Save start scan address
*
CONTLP2  EX    R15,CONTTRT         Look for 1st char
         BZ    CONTLPB             Not there, bump
         TM    PCTIOFLG,IOMASK     Masking?
         BNO   CONTNCM1            No, do normal compare
         EX    R5,CONTM1           Do MASK type test
         EX    R5,CONTM2           .
         EX    R5,CONTM3           .
         EX    R5,CONTM4           .
         B     CONTNCM2            Re-enter common code
*
CONTNCM1 EX    R5,CONTCOMP         Got it, is the rest there
*
CONTNCM2 BE    CONTEQ              Yep, return with = set
         LA    R1,1(,R1)           No, step over this one
         LR    R0,R1               Calc length searched
         SR    R0,R9               .
         SR    R15,R0              Subt from length remaining
         BNP   CONTLPB             None left, go to outer loop
         LR    R9,R1               Save new start scan
         B     CONTLP2             Loop back
*
CONTLPB  LA    R4,256(,R4)         Bump to next 256 byte chunk
         SH    R7,=H'256'          Decr count
         B     CONTLP1             Loop back
         EJECT
*---------------------------------------------------------------------+
*        Do tests for the remaining portion 256 or less.              |
*---------------------------------------------------------------------+
*
CONTLAST LR    R1,R4               Swap address to R1
         LR    R15,R7              Get length
         SR    R15,R5              Reduce by length of argument
         LR    R9,R4               Save start scan
*
CONTLP3  EX    R15,CONTTRT         Look for 1st char
         BZ    CONTNFND            Not there, exit
         TM    PCTIOFLG,IOMASK     Masking?
         BNO   CONTLCM1            No, do normal compare
         EX    R5,CONTM1           Do MASK type test
         EX    R5,CONTM2           .
         EX    R5,CONTM3           .
         EX    R5,CONTM4           .
         B     CONTLCM2            Re-enter common code
*
CONTLCM1 EX    R5,CONTCOMP         Got 1st char, is the rest there?
*
CONTLCM2 BE    CONTEQ              Yep, return with = set
         LA    R1,1(,R1)           No, step over this one
         LR    R0,R1               Calc length searched
         SR    R0,R9               .
         SR    R15,R0              Subt from length remaining
         BNP   CONTNFND            None left, go to outer loop
         LR    R9,R1               Save new start scan
         B     CONTLP3             Loop back
*---------------------------------------------------------------------+
*        Do needed stuff, set CC, and exit now.                       |
*---------------------------------------------------------------------+
*
CONTNFND CR    R4,R6               Force unequal compare
         LM    R4,R6,CONTSAVE      Reload all the regs
         BR    R14                 End return
*
CONTEQ   LA    R5,1(,R5)           Convert length back to actual
         ST    R5,PCTSCLEN         Save length of found item
         AR    R5,R1               Point at last byte of found
         S     R5,CONTSADR         Calc offset in record
         ST    R5,PCTPLOCE         Save it for PLOC
         ST    R5,PCTFLOCE         Save it for FLOC
         S     R1,CONTSADR         Calc offset to found
         LA    R1,1(,R1)           Make it actual
         ST    R1,PCTPLOC          And save it
         CR    R7,R7               Force equal compare
         LM    R4,R6,CONTSAVE      Reload all the regs
         BR    R14                 End return
         EJECT
*
CONTTRT  TRT   0(0,R1),TRTABLE     Executed
CONTCOMP CLC   0(0,R1),0(R6)       Executed
CONTM1   MVC   WORDTXT(0),0(R6)    Move literal to work area
CONTM2   TR    WORDTXT(0),MASKTBL  Translate to 00 or FF
CONTM3   NC    WORDTXT(0),0(R1)    AND in chars to compare
CONTM4   CLC   WORDTXT(0),0(R6)    Now do the compare
CONTSADR DS    F
CONTFILE DC    F'0'
CONTSAVE DS    3F
         DS    0H
         TITLE 'DCOPYDAT - Deferred copy of I/P buffer'
*---------------------------------------------------------------------+
*     Copying the primary input buffer to the output buffer as soon   |
*     as it's read can add considerable overhead if the record ends   |
*     up never being selected for output.  This is particularly true  |
*     of variable records with an unusually large LRECL (like SMF),   |
*     since the move does a fill to the maximum record length.        |
*                                                                     |
*     Instead, the buffer is not copied until some function really    |
*     needs it.  The DEFRCOPY flag is used to control whether the     |
*     record has already been copied or not.  A 'BAL   R14,DCOPYDAT'  |
*     is inserted in the compiled program in front of any function    |
*     which requires that the output buffer have been set up.         |
*---------------------------------------------------------------------+
*
DCOPYDAT TM    PCTF6,DEFRCOPY      Copy needed?
         BZR   R14                 No, return
         TM    PCTBFCDF,COPYBUFF   Is COPYBUFF the default?
         BZR   R14                 No, skip it then
         NI    PCTF6,255-DEFRCOPY  Yes, kill flag and do it
         ST    R14,DBL             Save return
         L     R0,PCTINPT1         Get address of INPUT1 record
         L     R1,PCTINPL1         Get length of INPUT1 record
         ST    R1,PCTOBUFL         Set as length of rec in O/P buffer
         L     R14,PCTOUTPT        Setup
         LH    R15,DCBHLREC        An MVCL
         ICM   R1,8,PCTPADCH       Put in the specified fill character
         MVCL  R14,R0              Move input record to output area
         L     R14,DBL             Get return address
         BR    R14                 Return
         TITLE 'HEXIT - Convert operands to hex'
*---------------------------------------------------------------------+
*        Convert data to EBCDIC hex.                                  |
*---------------------------------------------------------------------+
*
HEXIT    LA    OREG,0(,OREG)       Clear hi-byte of OREG
*
HEXITLP  MVC   DBL(1),0(BREG)      Format 2 bytes into msg
         UNPK  0(1,AREG),DBL(1)
         MVO   DBL(1),DBL(1)
         UNPK  1(1,AREG),DBL(1)
         MVZ   0(2,AREG),ZEROS
         TR    0(2,AREG),SNPTR
         LA    BREG,1(,BREG)       Bump to next byte
         LA    AREG,2(,AREG)
         BCT   OREG,HEXITLP        And loop if not done
         BR    R14                 Return
         TITLE 'LINPRINT - PRINT a line'
*---------------------------------------------------------------------+
*        Print a single line                                          |
*---------------------------------------------------------------------+
*
LINPRINT ST    R14,LINS14          Save return addr
         ST    R7,LINS7            Save any current FCB address
         ICM   R7,15,PCTPFCB       Point at printer FCB
         BZ    LINCLR
         TM    FCBF1,FCBOPEN       Is SYSPRINT available?
         BZ    LINCLR              No, continue
*
LINCNTIT SP    LINECT,=P'1'        Count line
         BNP   LINPGHD             And do page heads if needed
*
LINTTRAC TM    PCTF4,COMPILE       During compile phase?
         BO    LINPUT              Yes, print it first
         CLI   TRLINE+31,C' '      Anything waiting in TRACE line?
         BE    LINPUT              No, just print normally
         LA    R14,TRLINE-1        Yes, lets print it 1st
         BAL   R15,LINEDO          .
         MVC   TRLINE,BLANKS       Reset the TRACE line
         MVC   TRPOS,=A(TRLINE+31) .
         B     LINCNTIT            Go count the inserted line
*
LINPUT   LA    R14,LINE-1          Put out requested line
         BAL   R15,LINEDO
         CLC   TRLINE(132),BLANKS  Anything waiting in ERROR line?
         BE    LINCLR              No, just exit normally
         LA    R14,TRLINE-1        Yes, lets print it then
         BAL   R15,LINEDO          .
         MVC   TRLINE,BLANKS       Reset the ERROR line
         SP    LINECT,=P'1'        Count line
*
LINCLR   MVC   LINE(132),BLANKS    Blank line
         L     R14,LINS14          Restore return reg
         L     R7,LINS7            Restore FCB pointer
         BR    R14
         EJECT
*---------------------------------------------------------------------+
*        Page heading routine                                         |
*---------------------------------------------------------------------+
*
LINPGHD  ZAP   LINECT,=P'52'       Reset line count
         L     R14,LINHDA3         Get potential ruler line address
         C     R14,=A(LINHD3)      Is it in use?
         BNE   *+16                No, skip footing logic
         B     *+8                 NOP/B 1st time switch
         BAL   R15,LINEDO          Go print footing
         NI    *-7,X'0F'           Flip 1st time switch
         L     R14,LINHDA1         Get 1st pghd addr
         AP    LINPGCT,=P'1'       Count page
         MVC   129(4,R14),=X'40202120'
         ED    129(4,R14),LINPGCT
         BAL   R15,LINEDO          And print it
         L     R14,LINHDA2         Get 2nd pghd addr
         BAL   R15,LINEDO          And print it
         L     R14,LINHDA3         Get 3rd pghd address
         BAL   R15,LINEDO          Print it
         L     R14,=A(LINHD9)
         BAL   R15,LINEDO          Space the headings
         B     LINTTRAC            Now do the original line
         EJECT
*---------------------------------------------------------------------+
*        Print the actual lines based on SYSPRINT's RECFM/LRECL       |
*---------------------------------------------------------------------+
*
LINEDO   STM   R0,R15,LINEDORG     Save regs
         TM    FCBRECFM,X'C0'
         BO    LINEDOST            Set length if RECFM=U
         LH    R9,FCBDCB+DCBLRECL  Get length into R9
         TM    FCBRECFM,X'80'
         BO    LINENDO             Skip if RECFM=F
*
LINEDOST LR    R1,R14              R1 --> line to print
         LA    R1,0(,R1)           Purify the hi-byte
         LA    R4,133(R14)         R4 --> end of line+1
         L     R5,=A(TRTBLB)       R5 --> blank TRT table
         L     R6,=A(TRTBLNB)      R6 --> non-blank TRT table
*
LINEDTRT TRT   0(134,R1),0(R5)     Find next blank
         LR    R9,R1               Save loc as last blank
         TRT   0(134,R1),0(R6)     Find a non-blank
         CR    R1,R4               Is it still inside line
         BL    LINEDTRT            Yes, keep going
         SR    R9,R14              No, calc effective lgth of line
         LTR   R9,R9
         BNZ   *+8
         LA    R9,1
         STH   R9,FCBDCB+DCBLRECL  Stuff in DCB
         TM    FCBDCB+DCBRECFM,X'C0' RECFM=U
         BO    LINENDO             Yes, no RDW need be built
         LA    R9,4(,R9)           Add 4 for a RDW
         SH    R14,=H'4'           Backup to RDW area
         STH   R9,0(R14)           Put length in RDW
         STH   R9,FCBDCB+DCBLRECL  And in DCB
*
LINENDO  LA    R3,FCBDCB           Point at DCB
         LR    R2,R14              Save address of data
         PUT   (R3)                Put the record (Get buffer loc)
         LH    R15,FCBDCB+DCBLRECL Get length of record
         EX    R15,*+4             Move it to buffer
         MVC   0(0,R1),0(R2)       .
         LM    R0,R15,LINEDORG     Restore regs
         BR    R15                 Return
         EJECT
*---------------------------------------------------------------------+
*        Print routine work areas                                     |
*---------------------------------------------------------------------+
         DC    X'00000000'         Reserved for possible RDW
         DC    C' '                Print
LINE     DC    CL132' '            Line
         DC    C'X'                Don't remove
LINHDA1  DC    A(LINHD1)           Addr of 1st hding
LINHDA2  DC    A(LINHD2)             "   " 2nd   "
LINHDA3  DC    A(LINHD2A)            "   " 3rd   "
LINECT   DC    P'01'               Line counter
LINPGCT  DC    PL2'0'              Page counter
LINS14   DS    F
LINS7    DS    F
LINEDORG DS    16F
         TITLE 'OPROUTE - SELECT O/P control routine'
*---------------------------------------------------------------------+
*        OPROUTE is CALLed by the compiled SELECT statement code      |
*        when the SELECT contains either/or PRINT(...) or TODD(...).  |
*                                                                     |
*        On entry R15 points at the SELECT control area, see the      |
*        DSECT SELDSECT for it's layout.                              |
*---------------------------------------------------------------------+
*
OPROUTE  STM   R0,R15,OPRSAVE      Save all regs
         ICM   R1,15,$SELBCTR      Get BY(...) counter
         BZ    OPRSBYOK            It's zero we can output it
         BCTR  R1,0                Non-zero, decrement it
         ST    R1,$SELBCTR         And store it back
         B     OPRINS              Then goto next sentence
*
OPRSBYOK MVC   $SELBCTR,$SELBREC   Reset the count
         TM    $SELF1,CHAR+HEX     Any print requested?
         BZ    OPRSTCPY            No, go see if copy called for
         LR    R14,R15             Protect R15 from $CALL
         $CALL DMPIT               Yes, go do it
         L     R15,OPRSAVE+60      Restore R15
*
OPRSTCPY TM    $SELF1,COPY         Is copy requested?
         BZ    OPRETURN            No, no more to do, return
         L     R7,$SELOFCB         Point at FCB
         LR    R14,R15             Protect R15 from $CALL
         $CALL CPYIT               Go copy it
*
OPRETURN LM    R0,R15,OPRSAVE      Restore all regs
         BR    R14                 And return
         EJECT
*---------------------------------------------------------------------+
*        De-activate a SELECT command when done                       |
*---------------------------------------------------------------------+
*
OPRISHUT MVC   $SELNREC,ZEROS      Set count to zero
         L     R1,PCTMACNT         Get address of master active count
         BCTR  R1,0                Decrement it
         ST    R1,PCTMACNT         And put it back
         NI    PCTF5,255-SHUTSEL   Reset the switch
*
OPRINS   LM    R0,R15,OPRSAVE      Restore regs
         L     R14,$SELNXTS        Get address of next sentence
         BR    R14                 And go to it
         TITLE 'REPLACE - do the fancy types of ALTER'
*---------------------------------------------------------------------+
*        This code performs all the unusual types of ALTER to do      |
*        with 'floating' fields and/or DLM type source fields.        |
*---------------------------------------------------------------------+
*
REPLACE  LR    R3,R14              Save return temporarily
         BAL   R14,DCOPYDAT        Go copy data if needed
         LR    R14,R3              Restore R14
         STM   R4,R6,REPLSAV1      Save execution code registers
         MVC   PCTFLCHG,ZEROS      Zero length difference
         MVC   REPLSCLN,PCTSCLEN   Set default 'scan found length'
         ST    OREG,OREGM          Put OREG into memory
         CLI   OREGALEN,X'00'      An A-operand length specified?
         BE    *+16                No, skip
         MVC   REPLSCLN,ZEROS      Yes, swap it in
         MVC   REPLSCLN+3(1),OREGALEN
         TM    PCTIOFLG,IODLML     A DLM type ALTER?
         BZ    REPLREPL            No, OREGBLEN is correct already
*---------------------------------------------------------------------+
*        We don't yet know how long the source field is. (i.e. a DLM  |
*        type ALTER.  This logic performs the needed scan to          |
*        determine that now and set OREGBLEN to whatever it finds.    |
*---------------------------------------------------------------------+
         LR    R3,R6               Working copy of B-operand
         CLM   R6,8,=X'00'         A buffer index in R6?
         BNE   REPLBUFL            Yes, go do it
         LA    R15,256             No, set 256 byte default
         B     REPLSTLN            Continue with it
*
REPLBUFL LR    R15,R6              Isolate I/P file number index
         SRL   R15,24              and multiply it by 4
         SLL   R15,2               .
         LA    R1,PCTINPT1-4(R15)  Point at address of this buffer
         L     R1,0(R1)            Now point at the buffer
         LA    R15,PCTINPL1-4(R15) Point at length of this buffer
         L     R15,0(R15)          Get length of record
         AR    R15,R1              Point at end of rec +1
         TM    PCTIOFLG,IOFLOATB   Floating B-operand?
         BZ    REPLNOBA            No, skip
         TM    PCTIOFLG,IONOBADJ   NO B adjust?
         BO    REPLNOBA            Correct, skip
         AL    R3,PCTPLOC          Adjust location by PLOC
         BCTR  R3,0                -1 (PLOC is next byte)
*
REPLNOBA LA    R3,0(,R3)           Clear hi byte of R6
         SR    R15,R3              Calc remaining portion of record
         BNP   REPLEXIT            Negative, ignore it
         LA    R1,256              Check against max
         CR    R15,R1              .
         BNH   *+6                 <= 256, use it
         LR    R15,R1              > swap 256 into it
*
REPLSTLN BCTR  R15,0               -1 for EX
         EX    R15,REPLTRT         Look for delimiter
         BZ    REPLEXIT            Do nothing if none
         SR    R1,R3               Calc length found
         LTR   R1,R1               Zero?
         BZ    REPLEXIT            Yes, exit
         STH   R1,OREGBLEN         Save as if passed to us
         TM    PCTIOFLG,IONOEXPC   No expand/compress?
         BZ    REPLREPL            No
         ST    R1,REPLSCLN         Yes, make this the 'scan length'
*---------------------------------------------------------------------+
*        We now have the length, either passed to us or calculated    |
*        by the above code based on the DLM logic.                    |
*---------------------------------------------------------------------+
*
REPLREPL MVC   PCTFLEN+2(2),OREGBLEN Save ALTER's length
         TM    PCTIOFLG,IOFLOATA   Floating A-operand
         BZ    REPLRNOA            No, skip
         TM    PCTIOFLG,IONOAADJ   No A adjust?
         BO    REPLRNOA            Correct, skip
         AL    R4,PCTPLOC          Yes, add PLOC then
         BCTR  R4,0                -1 (PLOC is one past found)
*
REPLRNOA TM    PCTIOFLG,IOFLOATB   Floating B-operand
         BZ    REPLRNOB            No, skip
         TM    PCTIOFLG,IONOBADJ   No B adjust?
         BO    REPLRNOB            Correct, skip
         AL    R6,PCTPLOC          Yes, add PLOC then
         BCTR  R6,0                -1 (PLOC is one past found)
*---------------------------------------------------------------------+
*        Now see if any expand or contraction of the record is needed |
*        based on the lengths of the A and B operands.                |
*---------------------------------------------------------------------+
*
REPLRNOB TM    PCTIOFLG,IONOEXPC   NOEXPC asked for?
         BO    REPLEQUL            Yes, ignore expand contract
         TM    PCTIOFLG,IOFLOATA   Floating A-operand?
         BO    REPLTSTL            Yes, go compare lengths
         CLI   OREGALEN,X'00'      Called with A-operand length?
         BE    REPLEQUL            No, continue via EQUL
*
REPLTSTL CLC   OREGBLEN,REPLSCLN+2 Compare replace and found lengths
         BH    REPLEXPN            High, go expand
         BL    REPLCONT            Low, go contract
         EJECT
*---------------------------------------------------------------------+
*        Expand/Contract has either been done or skipped, the         |
*        B-operand is now moved into place.                           |
*---------------------------------------------------------------------+
*
REPLEQUL LA    R4,0(,R4)           Purify pointer regs
         LA    R6,0(,R6)           .
         SR    R3,R3               Isolate I/P file number index
         IC    R3,REPLSAV1         and multiply it by 4
         SLL   R3,2                .
         LA    R2,PCTINPT1-4(R3)   Point at address of this buffer
         L     R2,0(R2)            Now point at the buffer
         LA    R3,PCTINPL1-4(R3)   Point at length of buffer
         L     R3,0(R3)            Now load buffer length
         AR    R3,R2               Point 1 past buffer
         SH    R3,OREGBLEN         Reduce by length of move
         SR    R3,R4               and by starting location
         BM    REPL0C4             Sorry, you lose
         LH    R15,OREGBLEN        Get the length now
         BCTR  R15,0               -1 for EX
         EX    R15,REPLMVEQ        Move the data
         LA    R4,1(R4,R15)        Point at last byte of moved data + 1
         SR    R4,R2               Calc offset of last byte+1
         ST    R4,PCTFLOCT         Save as FLOCTERM
*
REPLEXIT LM    R4,R6,REPLSAV1      Reload execution code regs
         BR    R14                 And return
*
REPL0C4  $ERR  BUFFR,16,FLAG=NO    Issue error msg
         OI    PCTF1,EXEC          Say we're in user's program
         ABEND 16                  Issue User abend
*
REPLTRT  TRT   0(0,R3),0(OREG)
REPLMVEQ MVC   0(0,R4),0(R6)       .
         EJECT
*---------------------------------------------------------------------+
*        Replace a field (expand record to make room 1st)             |
*---------------------------------------------------------------------+
*
REPLEXPN LH    R15,OREGBLEN        Calc difference in lengths
         S     R15,REPLSCLN        .
         ST    R15,PCTFLCHG        Save for FLCHG keyword
         LR    R15,R4              Isolate Dest. buffer number
         SRL   R15,24              and multiply it by 4
         SLL   R15,2               .
         LA    R7,PCTINPL1-4(R15)  Point at length of this buffer
         L     R3,0(R7)            Get length
         A     R3,PCTFLCHG         Adjust by expand amount
         CLM   R4,8,=X'0A'         In UBUFF's or I/P buffers?
         BNE   REPLNBFA            Yes, don't adjust them
         CH    R3,DCBHLREC         Are we passing the max?
         BH    REPL0C4             Yes, kill the sucker
         ST    R3,0(R7)            Put adjusted length back
*
REPLNBFA L     R7,0(R7)            Get adjusted length of the record
         LA    R2,PCTINPT1-4(R15)  Point at address of this buffer
         L     R2,0(R2)            Now point at the buffer
         AR    R2,R7               Point at end of O/P buffer
         BCTR  R2,0                -1
         TM    PCTIOFLG,IOFLOATA   Floating A-operand?
         BO    REPLFLCL            Yes, do floating calculation
         LA    R1,PCTINPT1-4(R15)  Get address of this buffer again
         L     R1,0(R1)            .
         LA    R15,0(,R4)          Get operand address
         SR    R15,R1              Calc its offset
         SR    R7,R15              Reduce length by offset
         S     R7,PCTFLCHG         And by difference
         BNP   REPL0C4             Better not be negative
         BCTR  R7,0                One more
         B     REPLENDA            Go calc end address
*
REPLFLCL TM    PCTIOFLG,IONOAADJ   Skip A adjust?
         BO    *+8
         S     R7,PCTPLOC          Adjust length by offset
         S     R7,PCTFLCHG         Also less difference
         BNP   REPL0C4             Better not be negative
         BCTR  R7,0                -1
*
REPLENDA LR    R3,R2               Create end address of source
         S     R3,PCTFLCHG         .
         LA    R0,256              Put const 256 in R0
         SR    R2,R0               Decr by initial 256
         SR    R3,R0               .
*
REPLEX1  CR    R7,R0               More that 256 to move?
         BL    REPLEX2             No
         MVC   TRTABLE(256),0(R3)  Shift one chunk using TRTABLE
         MVC   0(256,R2),TRTABLE   As a temp area
         SR    R2,R0               Decr by another 256
         SR    R3,R0               .
         SR    R7,R0               Also decr count
         B     REPLEX1             Loop till less than 256 left
*
REPLEX2  AR    R2,R0               Add back the 'one too many'
         AR    R3,R0               .
         SR    R2,R7               Less remaining length
         SR    R3,R7               .
         EX    R7,*+4              Shift last chunk
         MVC   TRTABLE(0),0(R3)    .
         EX    R7,*+4              .
         MVC   0(0,R2),TRTABLE     .
         B     REPLEQUL            Go copy data
         EJECT
*---------------------------------------------------------------------+
*        Replace a field (contract record around it)                  |
*---------------------------------------------------------------------+
*
REPLCONT STM   R4,R6,REPLSAV2      Save for a while
         LR    R15,R4              Isolate Dest. buffer number
         SRL   R15,24              and multiply it by 4
         SLL   R15,2               .
         LTR   R15,R15             Better not be zero
         BNZ   *+6                 O.K. continue
         DC    H'0'                Just S0C1 for now
         LA    R2,PCTINPT1-4(R15)  Point at pointer to this buffer
         L     R2,0(R2)            Now point at the buffer
         TM    PCTIOFLG,IOFLOATA   Floating A-operand?
         BZ    REPLFIXI            No
         TM    PCTIOFLG,IONOAADJ   No A adjust?
         BO    REPLFIXI            No
         A     R2,PCTPLOC          Add offset into record
         BCTR  R2,0                -1 (PLOC is one past)
         B     REPLCDIF            Now go calc difference
*
REPLFIXI LR    R2,R4               For fixed just get A-operand
         LA    R2,0(,R2)           Purify hi-byte
*
REPLCDIF L     R0,REPLSCLN         Calc difference in lengths
         SH    R0,OREGBLEN         .
         LCR   R0,R0               Change sign
         ST    R0,PCTFLCHG         Save for FLCHG KW
         LCR   R0,R0               Back again
         LR    R6,R2               Calc input location
         AR    R6,R0               .
         LA    R3,PCTINPL1-4(R15)  Calc. destination length
         L     R3,0(R3)            Load the length of record
         TM    PCTIOFLG,IOFLOATA   Floating A-operand?
         BZ    REPLFIXL            No
         TM    PCTIOFLG,IONOAADJ   No A adjust?
         BO    REPLFIXL            No
         S     R3,PCTPLOC          Less offset
         B     REPLCSRL            Go calc source length
*
REPLFIXL LA    R7,0(,R4)           Get orig dest. loc.
         LA    R1,PCTINPT1-4(R15)  Point at pointer to this buffer
         L     R1,0(R1)            Now point at the buffer
         SR    R7,R1               Calc its offset
         SR    R3,R7               Adjust length
*
REPLCSRL LR    R7,R3               Calc source length
         SR    R7,R0               .
         ICM   R7,8,PCTPADCH       Insert specified fill character
         MVCL  R2,R6               Shift it left
         LM    R4,R6,REPLSAV2      Restore regs
         B     REPLEQUL            Go copy data
*
REPLSCLN DS    F
REPLSAV1 DS    3F
REPLSAV2 DS    3F
         TITLE 'TRACE - Trace compiled Pgm logic'
*---------------------------------------------------------------------+
*        List STMNT # and WORD # on SYSPRINT                          |
*---------------------------------------------------------------------+
*
TRACE    MVC   PCTLAST,0(R14)      Save the stmnt./word #
         LA    R14,4(,R14)         Adjust the pseudo base
         TM    PCTF7,DBTRACE       Return immed. if no TRACE
         BZR   R14                 Goback +4 around data
         STM   R14,R1,TRSV         Save regs
         LM    R14,R15,TRPOS       Get pointers to TRACE line
         MVI   0(R14),C'<'         Stuff in delims
         MVI   9(R14),C'>'         .
         MVI   5(R14),C'/'         .
         LH    R0,PCTLAST          Pickup stmnt number
         CVD   R0,DBL
         UNPK  1(4,R14),DBL+5(3)   Put it in TRACE line
         OI    4(R14),X'F0'        Make it pretty
         LH    R0,PCTLAST+2        Pick up word number
         CVD   R0,DBL
         UNPK  6(3,R14),DBL+6(2)   Put it in print line
         OI    8(R14),X'F0'        Make it pretty
         MVC   TRLINE(30),=C'Trace . . . . . . . . . . . . '
         LA    R14,10(,R14)        Bump to next position
         CR    R14,R15             Time to print?
         BL    TRACEXIT            No, not yet
         MVC   LINE,TRLINE         Yes, then
         MVC   TRLINE,BLANKS       Blank line
         BAL   R14,LINPRINT        Print it
         LA    R14,TRLINE+31       Then reset pointer
*
TRACEXIT ST    R14,TRPOS           Save position for next time
         LM    R14,R1,TRSV         Reload regs
         BR    R14                 And return
         TITLE 'SUBRETN - Do a GOBACK'
*---------------------------------------------------------------------+
*        Pick  up the address saved by GOSUB and go to it             |
*---------------------------------------------------------------------+
*
SUBRETN  STM   R14,R1,SUBSSAVE     Save regs
         L     R1,PCTSUBSV         Get next place to save it
         SH    R1,=H'4'            Backup 1 entry
         C     R1,=A(SUBSAVE1)     Too far?
         BL    SUBRABND            Yes, blow it all up
         ST    R1,PCTSUBSV         Save new save address
         L     R14,0(R1)           Pickup the address to go to
         BR    R14                 And go to it
*
SUBRABND $ERR  BAKEX,16,FLAG=NO    Issue error msg
         OI    PCTF1,EXEC          Say we're in user's program
         ABEND 16                  Issue User abend
         TITLE 'SUBSAVE - Save return address for a GOSUB'
*---------------------------------------------------------------------+
*        Setup the return address for a GOSUB command                 |
*---------------------------------------------------------------------+
*
SUBSAVE  STM   R14,R1,SUBSSAVE     Save regs
         LA    R0,8(R14)           Calc return address to save
         L     R1,PCTSUBSV         Get next place to save it
         ST    R0,0(R1)            Save the return
         LA    R1,4(,R1)           Bump to next save slot
         C     R1,=A(SUBSAVE2)     Too far?
         BE    SUBSABND            Yes, blow it all up
         ST    R1,PCTSUBSV         Save new save address
         LM    R14,R1,SUBSSAVE     Reload regs
         BR    R14                 And return
*
SUBSABND $ERR  SUBEX,16,FLAG=NO    Issue error msg
         OI    PCTF1,EXEC          Say we're in user's program
         ABEND 16                  Issue User abend
*
SUBSSAVE DS    4F
         TITLE 'Crutch routines'
*---------------------------------------------------------------------+
*              Addressability type crutches                           |
*---------------------------------------------------------------------+
*
MAINGEOS L     R8,=A(MAINCOMP)     Get base of proc set up
         B     MAINGEOX-MAINCOMP(R8) go to entry point
*
MAINGOK  L     R8,=A(MAINCOMP)     Get base of proc set up
         B     MAINGOKX-MAINCOMP(R8) go to entry point
*
INICHOOS L     R8,=A(INISLECT)     Get base of proc set up
         B     INICHOOX-INISLECT(R8) go to entry point
*
EODAD    L     R8,=A(COPYDATA)     Get base of proc set up
         B     COPEOFIN-COPYDATA(R8) go to entry point
*---------------------------------------------------------------------+
*        Misc routines  for ALTER  (ALTER needs more addressability)  |
*---------------------------------------------------------------------+
*
ALTNERR  $ERR  BADN,8,SKIP         Say bad numerics
*
ALTTBT   $ERR  BADAT,8,SKIP        Issue err msg
*
ALTLCONF $ERR  LCONF,8,SKIP        Issue err msg
*---------------------------------------------------------------------+
*              Duplicate code type crutches                           |
*---------------------------------------------------------------------+
*
EXITGEOS TM    PCTF4,IFNXSENT      Genning within an IF?
         BZ    MAINGEOS            No, leave now
         $CALL POPIF               Yes, POP one next sentence pointer
         NI    PCTF4,255-IFNXSENT  and clear the flag
         B     MAINGEOS            Now leave
*
EXITGOK  TM    PCTF4,IFNXSENT      Genning within an IF?
         BZ    MAINGOK             No, leave now
         $CALL POPIF               Yes, POP one next sentence pointer
         NI    PCTF4,255-IFNXSENT  and clear the flag
         B     MAINGOK             Now leave
         TITLE 'Compiled code support routines'
*---------------------------------------------------------------------+
*        Following instructions are EXecuted by compiled code         |
*---------------------------------------------------------------------+
*
COMPMVC  MVC   0(0,AREG),0(BREG)   Executed by compiled code
COMPNC   NC    0(0,AREG),0(BREG)   .
COMPOC   OC    0(0,AREG),0(BREG)   .
COMPXC   XC    0(0,AREG),0(BREG)   .
COMPTR   TR    0(0,AREG),0(BREG)   .
COMPCLC  CLC   0(0,AREG),0(BREG)   .
COMPCP   CP    0(0,AREG),0(0,BREG) .
COMPCR   CR    R0,R1               .
COMPTM   TM    0(AREG),0           .
COMPMSK1 MVC   TRTABLE(0),0(BREG)  .
COMPMSK2 TR    TRTABLE(0),MASKTBL  .
COMPMSK3 NC    TRTABLE(0),0(AREG)  .
COMPMSK4 CLC   TRTABLE(0),0(BREG)  .
         EJECT
*---------------------------------------------------------------------+
*        Following 'mini' routines aid compiled code addressability   |
*        problems by avoiding need for BALR R14,0's all the time      |
*---------------------------------------------------------------------+
*---------------------------------------------------------------------+
*        Called by BAL   R14,COMPGOTO      Transfer Ctl. to GOTO adr. |
*                  DC    A(where-to-go)                               |
*---------------------------------------------------------------------+
*
COMPGOTO TM    PCTF7,TIMEFLAG      STIMER needed?
         BZ    COMPGGO             No, just GOTO
*
COMPGTIM NI    PCTF7,255-TIMEFLAG  Clear flag
         ST    R14,DBL             Save R14
         STIMER TASK,TIMEEXIT,TUINTVL=ONESEC Re-issue STIMER
         L     R14,DBL             Reload R14
*
COMPGGO  ICM   R14,15,0(R14)       Pick up GOTO address
         BR    R14                 Go to it
*---------------------------------------------------------------------+
*        Called by BAL   R10,COMP10X4      Set R10 -> 4 bytes of data |
*                  DC    A(data)           and continue at R10+4      |
*---------------------------------------------------------------------+
*
COMP10X4 B     4(R10)              Branch around data
*---------------------------------------------------------------------+
*        Called by BAL   R7,COMP7X4        Set R7  -> 4 bytes of data |
*                  DC    A(data)           and continue at R7+4       |
*---------------------------------------------------------------------+
*
COMP7X4  B     4(R7)               Branch around data
*---------------------------------------------------------------------+
*        Called by BAL   R15,COMP15X4      Set R15 -> 4 bytes of data |
*                  DC    A(data)           and continue at R15+4      |
*---------------------------------------------------------------------+
*
COMP15X4 B     4(R15)              Branch around data
*---------------------------------------------------------------------+
*        Called by BAL   R15,COMP15X8      Set R15 -> 8 bytes of data |
*                  DC    A(data1)          and continue at R15+8      |
*                  DC    A(data2)                                     |
*---------------------------------------------------------------------+
*
COMP15X8 B     8(R15)              Branch around data
         TITLE 'DCB exit lists and OPEN exits'
         PUSH  USING
         DROP  R7
         USING FCBDSECT,R4
*---------------------------------------------------------------------+
*        SYSIN exit list                                              |
*---------------------------------------------------------------------+
*
INXLST   DS    0F
         DC    X'05',AL3(INOPEX)
         DC    X'87',AL3(JFCB)
*
INOPEX   DS    0H
         CLC   DCBBLKSI(2,R1),ZEROS
         BNER  R14
         MVC   DCBBLKSI(2,R1),=H'80'
         BR    R14
         EJECT
*---------------------------------------------------------------------+
*        SYSPRINT exit list                                           |
*---------------------------------------------------------------------+
*
PRXLST   DS    0F
         DC    X'05',AL3(PROPEX)
         DC    X'87',AL3(JFCB)
*
PROPEX   LR    R4,R1                      Copy DCB pointer
         LA    R3,FCBDCB-FCBCHAIN         Calc pos of DCB in FCB
         SR    R4,R3                      Backup to start of FCB
         LR    R2,R1                      Save R1
         MVC   DDNAME,FCBDDNAM            Setup and
         DEVTYPE DDNAME,DEVTAB            Get device type
         LR    R1,R2                      Restore R1
         NI    DCBRECFM(R1),X'FD'         Setup as ASA
         OI    DCBRECFM(R1),X'04'         .
         TM    DCBRECFM(R1),X'C0'         Any RECFM setup/
         BNZ   *+8                        Yes, leave alone
         OI    DCBRECFM(R1),X'90'         No, make it FB
         TM    DCBRECFM(R1),X'C0'         RECFM=U?
         BO    PROS133                    Yes
         TM    DCBRECFM(R1),X'80'         RECFM=F?
         BO    PROS133                    Yes
         B     PROS137                    No, must be RECFM=V
*
PROS133  MVC   PROLRECL,=H'133'           Set 133 defaults
         MVC   PROBLKSI,=H'133'
         B     PROCOMN
*
PROS137  MVC   PROLRECL,=H'137'           Set 137 defaults
         MVC   PROBLKSI,=H'141'
*
PROCOMN  TM    DEVTAB+2,X'28'             Tape/DASD device
         BZ    PROCTEST                   No, leave unblocked
         TM    DCBRECFM(R1),X'10'         Blocked RECFM?
         BZ    PROCTEST                   No, also leave alone
         MVC   PROBLKSI,=H'0'             Else let system assign it
*
PROCTEST CLC   DCBLRECL(2,R1),PROLRECL    Sufficient LRECL?
         BL    PROSLREC                   No, go give it one
         CLC   DCBBLKSI(2,R1),ZEROS       A blocksize?
         BNER  R14                        Yes, leave it alone
*
PROSLREC MVC   DCBLRECL(2,R1),PROLRECL    Setup LRECL/BLKSIZE
         MVC   DCBBLKSI(2,R1),PROBLKSI
         BR    R14
         EJECT
*---------------------------------------------------------------------+
*         INPUTn exit list                                            |
*---------------------------------------------------------------------+
*
UT1LIST  DS    0F
         DC    X'05',AL3(UT1EX)
         DC    X'87',AL3(JFCB)
*
UT1EX    LR    R4,R1                      Copy DCB pointer
         LA    R3,FCBDCB-FCBCHAIN         Calc pos of DCB in FCB
         SR    R4,R3                      Backup to start of FCB
         ST    R4,OPEXFCBP                Save FCB pointer
         TM    FCBF2,FCB1ST               First time?
         BO    UT1B                       No
         OI    FCBF2,FCB1ST               Turn it on for next time
         CLC   FCBJFCB(9),=C'NULLFILE '   Is the file dummied?
         BNE   UT1NDMY                    No, skip next bit
         CLC   FCBDDNAM,MDINPT1+2         Is it INPUT1
         BE    UT1NDMY                    Skip if it is
         CLC   DCBBLKSI(2,R1),ZEROS       Any BLKSIZE?
         BNE   *+10                       Yes, skip
         MVC   DCBBLKSI(2,R1),DEFBLKSI    No, give it one
         CLC   DCBLRECL(2,R1),ZEROS       Any LRECL?
         BNE   *+10                       Yes, skip
         MVC   DCBLRECL(2,R1),DCBBLKSI(R1) No, give it one
         CLI   DCBRECFM(R1),X'00'         Any RECFM?
         BNE   *+10                       Yes, skip
         MVC   DCBRECFM(1,R1),DEFRECFM    No, give it one
*
UT1NDMY  OI    DCBOFLAG(R1),X'08'         Turn on user concat in DCB
         TM    DCBRECFM(R1),X'80'         RECFM U or F?
         BOR   R14                        Yes, done
         TM    DCBRECFM(R1),X'48'         RECFM VBS/VS ?
         BNOR  R14                        No, done
         OI    DCBBFTEK(R1),X'60'         Make BFTEK=A
         BR    R14                        Now leave
*
UT1B     OI    FCBF2,FCBRREAD             Turn on reread sw
         L     R3,=A(FASTCONC)
         OI    1(R3),X'F0'                Also SW in FASTCOPY route
         MVC   FCBRECAD,=A(0)             Zero ptr to record
         NI    DCBBFTEK(R1),255-X'20'     BFTEK=A off
         TM    DCBRECFM(R1),X'80'         RECFM U or F?
         BO    UT1C                       Yes, skip over
         TM    DCBRECFM(R1),X'48'         RECFM VBS/VS ?
         BNO   UT1C                       No, skip over
         OI    DCBBFTEK(R1),X'60'         Make BFTEK=A
*
UT1C     ST    R14,OPEXSV14               Save return address
         CLC   FCBDDNAM,MDINPT1+2         Is it INPUT1
         BNE   UT1CST                     Skip if not
         TM    PCTF3,FAST                 Doing a fast copy
         BZ    *+12                       No
         ST    R7,FCBCOUNT                Yes, store counter right now
         ST    R7,FCBCREC                 .
*
UT1CST   L     R7,OPEXFCBP                Get pointer to FCB
         L     R3,FCBCOUNT                Format prev dataset stats
         CVD   R3,DBL                     Count
         MP    DBL,=P'10'          Shift it for ED
         MVC   ERRCWORK(11),=X'4020206B2020206B202120'
         ED    ERRCWORK(11),DBL+3  Put count in msg
         L     R2,=A(ERRTX37)      Get msg addressable
         MVC   1(10,R2),ERRCWORK+1 Copy edited data
         MVC   33(8,R2),FCBDDNAM          Put DDname in message
         MVC   46(54,R2),FCBDSNAM          "  Dsname
         $ERR  SPACE,0,TYPE=STAT,FLAG=NO
         $ERR  MSG37,0,SAVE=YES,TYPE=STAT,FLAG=NO
         L     R7,OPEXFCBP
         $CALL MSG52FMT
         B     UT1NOM52
         $ERR  MVOLS,0,SAVE=YES,TYPE=STAT,FLAG=NO
*
UT1NOM52 L     R7,OPEXFCBP
         $CALL MSG39FMT
         $ERR  MSG39,0,SAVE=YES,TYPE=STAT,FLAG=NO
*
UT1EXIT  L     R14,OPEXSV14
         BR    R14
         EJECT
*---------------------------------------------------------------------+
*        OUTPUT1 / anynamedd exit list                                |
*---------------------------------------------------------------------+
UT2LIST  DS    0F
         DC    X'05',AL3(UT2EX)
         DC    X'87',AL3(JFCB)
*
UT2EX    LR    R4,R1                      Copy DCB pointer
         LA    R3,FCBDCB-FCBCHAIN         Calc pos of DCB in FCB
         SR    R4,R3                      Backup to start of FCB
         CLI   DCBRECFM(R1),X'00'         Any RECFM there ?
         BNE   *+10                       Yes, skip
         MVC   DCBRECFM(1,R1),DEFRECFM    No, stuff it
         TM    DCBRECFM(R1),X'C0'         Undefined?
         BO    UT2LRLOK                   Yes, ignore LRECL setting
         CLC   DCBLRECL(2,R1),ZEROS       LRECL?
         BNE   UT2LRLOK                   Yes, leave alone
         MVC   DCBLRECL(2,R1),DEFLRECL    Stuff in DEFLRECL
         L     R3,WKTIOT                  Get TIOT address
         AH    R3,DCBDDNAM(R1)            Point at our TIOT entry
         STM   R0,R15,SWASAVE             Save everything
         LA    R1,12(R3)                  -> JFCB token
         L     R2,=A(GTSWABLK)            Get routine address
         BALR  R14,R2                     Go get block
         LM    R0,R15,SWASAVE             Load everything
         L     R3,=A(SWABLKA)             Get SWA block address
         TM    4+X'44'(R3),X'20'          SYSOUT flagged in JFCBTSDM?
         BZ    UT2LRLOK                   No, use normal default
         LH    R3,DCBLRECL(R1)            Get LRECL
         TM    DCBRECFM(R1),X'40'         Variable?
         BZ    *+8                        No, skip
         LA    R3,4(,R3)                  Yes, add 4 for RDW
         STH   R3,DCBBLKSI(R1)            Stuff into BLKSIZE
*
UT2LRLOK CLC   DCBBLKSI(2,R1),ZEROS       BLKSIZE?
         BNE   UT2BLKOK                   Yes, skip
         TM    PCTF8,CBLKSIZE             No, Asked to Copy it?
         BZ    UT2BLKOK                   No again, skip the copy
         MVC   DCBBLKSI(2,R1),DEFBLKSI    Else, copy the BLKSIZE
*
UT2BLKOK L     R15,PCT1DCB                Point at INPUT1 DCB
         TM    DCBRECFM(R1),X'80'         RECFM U or F?
         BO    UT2B                       Yes, skip over
         TM    DCBRECFM(R1),X'48'         RECFM VBS/VS ?
         BNO   UT2B                       No, skip over
         OI    DCBBFTEK(R1),X'60'         Make BFTEK=A
*
UT2B     BR    R14
         POP   USING
         TITLE 'Commonly addressable error msgs'
*---------------------------------------------------------------------+
*        Commonly addressable error routines                          |
*---------------------------------------------------------------------+
*
BADLITBT $ERR  LITBT,8,SKIP
*
BADLITBH $ERR  LITBH,8,SKIP
*
BADLITBL $ERR  LITBL,8,SKIP
*
BADLITBQ $ERR  LITBQ,8,SKIP
*
BADLITBN $ERR  LITBN,8,SKIP
*
BADNUMB  $ERR  BADN,8,SKIP
*
BADLGTH  $ERR  BLGTH,8,SKIP
*
BADSYSPR WTO   'SELECTIT - NO SYSPRINT, BUT PRINT AND/OR DEBUG REQUESTSX
                ARE PRESENT',                                          X
               ROUTCDE=(11),MCSFLAG=HRDCPY
         ABEND 12
*
BADKWORD $ERR  BADKW,8,SKIP        Invalid keyword found
*
BADKWVAL $ERR  BKWV,8,SKIP
*
BADOPTYP $ERR  BADOP,8,SKIP        Invalid operand format
*
BADDCB   $SKIP
*
BADIO    $ERR  CLOSI,16,FLAG=NO    Issue error msg
         OI    PCTF1,EXEC          Say we're in user's program
         ABEND 16                  Force User abend
         TITLE 'Literal Pool for Main program'
         LTORG
         TITLE 'Asynch STAE exit routine'
*---------------------------------------------------------------------+
*        See if ABEND is in user's pgm or in main program             |
*---------------------------------------------------------------------+
         DS    0H
         PUSH  USING
         DROP
         USING *,R15
*
ABNDEXIT STM   R14,R12,12(R13)     Save systems regs
         L     R7,0(R1)            Get address of PCT
*
ABNDFORC NOP   ABNDRETN            Force abend if TRACE or DEBUG
         TM    PCTF4-PCT(R7),ABENDING Have we been here before?
         BO    ABNDRETN            Yes, let abend get rid of us
         MVC   PCTABEND-PCT(4,R7),4(R1) Save ABEND code
         OI    PCTF4-PCT(R7),ABENDING Show STAE occurred
         TM    7(R1),X'FF'         Any user abend?
         BNZ   ABNDRETR            Yes, go the retry route
         TM    5(R1),X'FF'         S00x ABEND?
         BZ    ABNDRETN            Let it continue
         TM    PCTF1-PCT(R7),EXEC  Is execution in user pgm
         BZ    ABNDRETN            No, tell ABEND to continue
*
ABNDRETR NI    PCTABEND-PCT(R7),X'7F' Remove DUMP option
         MVC   20(4,R13),=A(ABNDRCVR) Set retry address in R0
         MVC   0(4,R1),=A(STAESAVE) Provide address of good regs
         LM    R2,R7,=A(ERRTX44,PCTCOUNT,DBL,PCTLAST,PCTCOUNT,SNPTR)
         TM    7(R1),X'FF'         User abend?
         BZ    ABNDFMSY            No, system
         LH    R8,6(R1)            Get user abend number
         CVD   R8,ABNDDBL          Format it
         UNPK  7(3,R2),ABNDDBL+6(2)
         OI    9(R2),C'0'          .
         B     ABNDCONT            Continue
*
ABNDFMSY UNPK  7(3,R2),5(2,R1)     Format abend code into MSG44
         MVZ   7(3,R2),=X'000000'
         TR    7(3,R2),0(R7)       Translate to hex
*
ABNDCONT L     R7,0(R6)            Format record number into MSG44
         CVD   R7,0(R4)
         UNPK  28(8,R2),3(5,R4)
         OI    35(R2),X'F0'
         LH    R7,0(R5)            Format STMNT # into msg44
         CVD   R7,0(R4)
         UNPK  58(4,R2),5(3,R4)
         OI    61(R2),X'F0'
         LH    R7,2(R5)            Format WORD # into msg44
         CVD   R7,0(R4)
         UNPK  72(3,R2),6(2,R4)
         OI    74(R2),X'F0'
         RETURN (14,12),RC=4       Return and call for retry
*
ABNDRETN RETURN (14,12),RC=0       Return and continue with ABEND
*
ABNDDBL  DS    D
         LTORG
         DROP  R15
         POP   USING
         TITLE 'Asynch TIMER exit routine'
*---------------------------------------------------------------------+
*        See if user is working i. e. not looping.                    |
*---------------------------------------------------------------------+
         DS    0H
         PUSH  USING
         DROP
         USING *,R15
*
TIMEEXIT STM   R14,R12,12(R13)     Save systems regs
         LM    R3,R4,=A(PCTF4,PCTF7) Point at some flags
         TM    0(R3),IODONE        Some I/O done?
         BZ    TIMEABND            No, force termination
         NI    0(R3),255-IODONE    Reset IODONE flag
         OI    0(R4),TIMEFLAG      Say we want STIMER re-issued
         RETURN (14,12),RC=0       Return from exit
*
TIMEABND OI    0(R4),TIMEBOMB      Set timer failure flag
         ABEND 16
         LTORG
         DROP  R15
         POP   USING
         TITLE 'ADDSTAT - Terminate the FCBs now'
*---------------------------------------------------------------------+
*        Loop down FCB chain and do termination processing for        |
*        each FCB (Except SYSPRINT, otherwise it becomes very         |
*        difficult to display statistics and end-of-job messages)     |
*---------------------------------------------------------------------+
*
ADDSTAT  $PROC
         LA    R7,PCTFCB           Point at start of chain
*
ADDCHN   LR    R3,R7               Swap regs
         ICM   R7,15,0(R3)         Get next FCB
         BZ    ADDEXIT             None, leave
         CLC   FCBDDNAM,MDSYSP+2   Is this the SYSPRINT file
         BE    ADDCHN              Yes, dont process it right now
         TM    PCTF8,PDSMODE       Are we in PDSMODE?
         BZ    ADDCALL             No, simply shutdown the FCB
         TM    FCBF2,FCBPDS        Yes, is this a PDS mode file?
         BZ    ADDCHN              No, ignore it
*
ADDCALL  $CALL ADDPROC,(R7)        Process it
         B     ADDCHN              Loop
*
ADDEXIT  $RET  0                   Return
         $PEND
         TITLE 'ADDPROC - CLOSE an FCB and create msgs'
*---------------------------------------------------------------------+
*        CLOSE an FCB and create statistics messages for it           |
*---------------------------------------------------------------------+
*
ADDPROC  $PROC 1
         L     R7,12(R8)           Get FCB address
         CLC   FCBDDNAM,MDSYSP+2   Is this the SYSPRINT file
         BE    ADDNCLS             Yes, dont close it yet
         TM    FCBF1,FCBCLOSD      Already CLOSEd?
         BO    ADDNCLS             Yes
         OI    FCBF1,FCBCLOSD      Say we're closing it
         TM    FCBDCB+48,X'10'     Is DCB open?
         BZ    ADDNCLS             No, also skip close
         LA    R2,FCBDCB           Get address of FCBDCB
         RDJFCB ((R2))             Go read JFCB
         MVC   FCBJFCB,JFCB        Save it
         CLOSE ((R2))              Now close it
         TM    FCBF2,FCBPDS        PDS mode?
         BO    ADDNCLS             Yes, skip FREEPOOL
         FREEPOOL (R2)             Free its buffers
*
ADDNCLS  TM    FCBF1,FCBSTATS      Allowed?
         BZ    ADDPEX0             No, skip
         TM    FCBF2,FCBPDS        Yes, is this a PDS mode file?
         BZ    ADDCKROM            No, go check for room
         TM    PCTF8,PDSSTATS      PDS STATS requested?
         BZ    ADDPEX0             No, skip these messages
*
ADDCKROM NI    FCBF1,255-FCBSTATS  Kill until another OPEN happens
         CP    =P'4',LINECT        Room on page?
         BL    *+10                Yes, skip
         ZAP   LINECT,=P'1'        No, force page head
         L     R1,FCBCOUNT         Get output count
         CVD   R1,DBL              Convert it
         MP    DBL,=P'10'          Shift it for ED
         MVC   ERRCWORK(11),=X'4020206B2020206B202120'
         ED    ERRCWORK(11),DBL+3  Put count in msg
         L     R2,=A(ERRTX37)      Get msg addressable
         MVC   1(10,R2),ERRCWORK+1 Copy edited data
         MVC   20(10,R2),=C'output to '
         TM    FCBF2,FCBINPUT      Is this an input file?
         BZ    *+10                No, leave as 'written to'
         MVC   20(10,R2),=C'Read from ' Yes, alter message
         MVC   33(8,R2),FCBDDNAM   Put DDname in message
         MVC   46(54,R2),FCBDSNAM  Put DSNAME in msg
         TM    FCBF2,FCBPDS        Is this a PDS mode file?
         BZ    ADDIMSPC            No, DSNAME is just fine
         TM    PCTF8,PDSMODE       If PDSMODE off, we're doing EOJ
         BO    ADDIMSPC            No, also DSNAME is O.K.
         MVC   46(54,R2),BLANKS    Yes, elim member from message
         MVC   46(44,R2),FCBJFCB   .
*
ADDIMSPC $ERR  SPACE,0,TYPE=STAT,FLAG=NO
         $ERR  MSG37,0,SAVE=YES,TYPE=STAT,FLAG=NO Stack msg
         $CALL MSG52FMT            Go format MSG52
         B     ADDNO52B            None, skip
         $ERR  MVOLS,0,SAVE=YES,TYPE=STAT,FLAG=NO
*
ADDNO52B $CALL MSG39FMT            Go format MSG39 and return
         $ERR  MSG39,0,SAVE=YES,TYPE=STAT,FLAG=NO
*
ADDPEX0  TM    PCTF8,PDSMODE       PDS mode?
         BZ    ADDPEX00            No, skip right out
         TM    FCBF2,FCBPDS        PDS mode on this FCB?
         BZ    ADDPEX00            No, skip right out
         L     R2,PCTMEMBC         Get next member address
         CLC   0(8,R2),=8X'FF'     Another member to do?
         BE    ADDPEX00            No, don't reset the FCB
         OI    FCBF1,FCBDOPEN      Yes, reset for future OPEN
         NI    FCBF1,255-FCBOPEN-FCBCLOSD
         NI    FCBF2,255-FCBEOF-FCBRREAD-FCB1ST
         MVC   FCBCREC,ZEROS
         TM    PCTF8,PDSSTATS      PDS STATS requested?
         BZ    ADDPEX00            No, skip these messages
         MVC   FCBCOUNT,ZEROS
*
ADDPEX00 $RET  0                   Go back
         $PEND
         TITLE 'ALTER command processor'
*---------------------------------------------------------------------+
*        A L T E R   C o m m a n d   P r o c e s s o r                |
*---------------------------------------------------------------------+
*
ALTER    $PROC
         LA    R10,4095(,R8)
         LA    R10,1(,R10)
         USING ALTER+4096,R10
         USING KWDSECT,R14
         OI    PCTF1,ACTIVE        Show command active
         OI    PCTF3,COMPALTR      Let OPGEN know its ALTER
         MVC   PCTPOPLS,ZEROS      Clear last POP'ed address
         MVC   OREGM,ZEROS         Clear the OREG work area
         MVC   ALTAKWLN,ZEROS      Clear the KW A-operand length
         MVI   PCTIOFLG,X'00'      Clear IO flags
         MVI   PCTIOFL2,X'00'      .
         NI    PCTF1,255-DCOPYGEN  Clear DCOPYDAT genned flag
         NI    PCTF3,255-OPKWLEN   Clear OPKWLEN flag
         $CALL DBGADD              Go add DEBUG code
*---------------------------------------------------------------------+
*        Get and process the destination operand (A-operand) unless   |
*        its the COPYBUFF keyword, in which case split off elsewhere. |
*---------------------------------------------------------------------+
         $CALL GETNEXT             Go get the dest. operand
         TM    WFLAG1,WWRD1        Possible buffer operand?
         BNO   ALTSTDEF            No, continue
         TM    WRD1F2,OPRKW+OPRKWV Valid KW. e.g. UBUFFx?
         BNO   ALTSTDEF            No, go skip COPYBUFF logic
         TM    WRD1F2,OPRKWOP      A KW(...) type?
         BO    ALTTRCB             Yes, try COPYBUFF(...) type
         LA    R14,WRD1KW1         No, see what keyword then
         CLI   KWNUM,X'E5'         INPUTx?
         BE    ALTGBNO             Yes, got an INPUTx buffer
         CLI   KWNUM,X'E4'         UBUFFx ?
         BE    ALTGBNO             Yes, got a UBUFFx
         CLI   KWNUM,X'E3'         OBUFF ?
         BNE   ALTSTDEF            No, skip
*
ALTGBNO  L     R1,KWD3             Get buffer index
         SLL   R1,2                x 4
         ST    R1,ALTGUONX         Stuff in area
         B     ALTCBFO             Continue, got buffer address
*
ALTTRCB  TM    WRD1F2,OPRKW+OPRKWV+OPRKWOP Maybe, a valid KW and fmt?
         BNO   ALTSTDEF            No, continue
         LA    R14,WRD1KW1         Point at KW answer area
*
ALTSTDEF MVI   WFLAG2,WAOP+WPREFOK+WTRLR Say what operand types are OK
         $CALL OPGEN               Go gen code for the A-operand
         B     BADOPTYP            +0 Invalid, kill it
         MVC   ALTGDISP,OPGDISPL   Save generated displacement
         MVC   ALTGABUF,OPGBASE    Save generated A-operand buffer
         CLI   ALTGABUF,X'0A'      O/P buffer?
         BE    ALTSGDCP            Yes, add deferred copy code
         CLI   ALTGABUF,X'01'      Primary I/P buffer?
         BNE   ALTSNDCP            No, skip
*
ALTSGDCP $ADD  4,DCOPM010          Add test for deferred copy
         OI    PCTF1,DCOPYGEN      Remember DCOPYDAT genned
*
ALTSNDCP TM    WFLAG1,WWRD1        Got basic word?
         BZ    ALTGNTYP            No, skip
         TM    WRD1F2,OPRKW+OPRKWV A valid keyword?
         BNO   ALTGNTYP            No, skip
         CLI   WRD1KW1+(KWNUM-KWDSECT),X'AC' Was it RCODE?
         BNE   ALTGNTYP            No, skip
         $ADD  4,ALTGRCST          Yes, remember user altered it
         EJECT
*---------------------------------------------------------------------+
*        Now get the type of ALTER to be performed.                   |
*---------------------------------------------------------------------+
*
ALTGNTYP $CALL GETNEXT             +4 Code genn'ed O.K., get next word
         TM    WFLAG1,WWRD1        Got one?
         BZ    ALTTBT              No, error
         TM    WFLAG1,WPREF+WWRD2+WTRLR Any bad sub-fields?
         BNZ   ALTTBT              Yes, sorry
         TM    WRD1F2,OPRKW+OPRKWV Is it a valid KW?
         BNO   ALTTBT              No, sorry
         LA    R14,WRD1KW1         Point at KW answer area
         TM    KWF1,KWALTER        Valid for ALTER sub-command?
         BZ    ALTTBT              No, sorry again
         MVC   ALTD1,KWD1          Save the answer words
         MVC   ALTD3,KWD3          .
         CLC   ALTD1,=F'40'        See if a CV, XC, or EDITx type
         BL    ALTICK              No, skip
         CLI   OREGALEN,X'00'      Better have an A length then
         BE    BADLGTH             No, sorry
         EJECT
*---------------------------------------------------------------------+
*        Get the source field for the ALTER.                          |
*---------------------------------------------------------------------+
*
ALTICK   $CALL GETNEXT             Get the source operand
         MVI   WFLAG2,WBOP+WPREFOK+WTRLROK+WIPDEF+WLITOK
         $CALL OPGEN               Go gen code for the B-operand
         B     BADOPTYP            +0 Invalid, kill it
         ST    R1,ALTBOPCD         +4 Save address of generated code
         CLI   OPGBASE,X'0A'       Output buffer?
         BNE   ALTTRTI             No, skip
         TM    PCTF1,DCOPYGEN      Yes, already genned DCOPYDAT code?
         BO    ALTTRTS             Yes, skip
         $ADD  4,DCOPM010          Add test for deferred copy
         OI    PCTF1,DCOPYGEN      Remember DCOPYDAT genned
*
ALTTRTI  CLI   OPGBASE,X'01'       See if input buffer
         BL    ALTTRTS             No
         CLI   OPGBASE,X'09'       .
         BH    ALTTRTS             No
         OI    PCTF1,IPCOPY        Yes, set for I/P copies
*
ALTTRTS  CLC   ALTD1,=F'20'        Is this TRANSLATE?
         BNE   ALTGEN              No, go gen remainder of code
         TM    WRD1F2,OPRLIT       Yes, should have been a literal
         BNO   BADOPTYP            No, sorry
         TM    LITL+3,X'01'        Was literal an even # characters
         BO    BADLITBL            No, sorry
         L     R15,=A(TRTBLDIT)    Get static change table
         MVC   TRTABLE,0(R15)      Swap to working table
         L     R1,LITL             Get length of literal
         L     R5,LITA             Get address of literal
*
ALTTRLP  SR    R15,R15             Clear work reg
         IC    R15,0(R5)           Get 'old' character
         LA    R15,TRTABLE(R15)    Point at its' position
         MVC   0(1,R15),1(R5)      Put in new character
         LA    R5,2(,R5)           Bump
         BCTR  R1,0
         BCT   R1,ALTTRLP          Loop till done
         LA    R2,TRTABLE          Point at new table
         LA    R3,256              Set length
         LR    R4,R3               .
         $CALL LITSTUFF            Go insert in litpool
         XC    TRTABLE,TRTABLE     Reset TRTABLE for PARSE
         L     R1,ALTBOPCD         Get address of generated B code
         MVC   OPGBASE-OPGCODE(4,R1),LITA Swap to new literal addr.
         TM    TRLRF2,OPRNUM       Numeric?
         BZ    ALTGEN              No, assume its a KW length
         MVC   OREGBLEN,TRLRNUM1+2 Yes, set its' length in
         B     ALTGEN              Continue
*
ALTBOPCD DS    F                   Save addr. of generated B code
         EJECT
*---------------------------------------------------------------------+
*        Code to point at operands is in place, now generate the      |
*        required code based on the type of ALTER.                    |
*---------------------------------------------------------------------+
*
ALTGEN   TM    PCTIOFLG,IODLML     Got a DLM?
         BO    ALTGLGTH            Yes, continue
         CLC   OREGBLEN,=H'0'      Or a B-operand length
         BNE   ALTGLGTH            Yes, skip following
         CLI   OREGALEN,X'00'      Or an A-operand length
         BNE   ALTGLGTH            Yes, skip following
         TM    PCTF3,OPKWLEN       KW type length?
         BO    ALTGLGTH            Yes, skip
         EJECT
*---------------------------------------------------------------------+
*        O.K. we now have the length (or DLM operand), first filter   |
*        out the types that need floating type logic.  i.e. the       |
*        stuff supported by REPLACE.                                  |
*---------------------------------------------------------------------+
*
ALTGLGTH TM    PCTIOFLG,IOFLOATA+IOFLOATB Any floating operands?
         BNZ   ALTGFLT             Yes, go different path
         CLC   ALTD1,=F'24'        See if an ADD/SUB, CV.. or EDITx ?
         BL    ALTGLGTS            .
         CLC   ALTD1,=F'80'        .
         BNH   ALTGDOBR            Yes, skip additional tests
*
ALTGLGTS TM    PCTF3,OPKWLEN       KW length operand?
         BO    ALTGDOBR            Yes, skip
         CLC   ALTAKWLN,ZEROS      A fixed length KW A-operand?
         BE    ALTGDLMT            No, skip
         CLC   OREGBLEN,ALTAKWLN+2 Better be the same as B-operand
         BNE   BADLGTH             No? Sorry
*
ALTGDLMT TM    PCTIOFLG,IODLML     A DLM type copy?
         BO    ALTGFLT             Yes, also go to float logic
         CLC   ALTD1,=F'4'         COPY?
         BNE   ALTGLNTS            No, skip
         SR    R1,R1               Lets see if NE to B-operand
         ICM   R1,1,OREGALEN       Get the length
         BZ    ALTGLNTS            It's zero, skip
         CH    R1,OREGBLEN         Same as B-operand?
         BE    ALTGLNTS            Yes, continue
         CLC   OREGBLEN,ZEROS      Because B-length is zero?
         BNE   ALTGFLT             No, different length, go to float
         MVC   OREGBLEN+1(1),OREGALEN Swap A-length over B-length
         MVI   OREGALEN,X'00'      and clear A-length
*---------------------------------------------------------------------+
*        Checkout the lengths of the ALTER to prevent the user        |
*        causing grief later by modifying data outside the buffer     |
*        limits.  Yes, I know this doesn't catch all possibilities    |
*        but its better than not checking at all.                     |
*---------------------------------------------------------------------+
*
ALTGLNTS L     R1,ALTGDISP         Get displacement
         CLC   ALTD1,=F'40'        A CV.. type?
         BL    ALTGLABL            No, go add B-operand length
         SR    R2,R2               Clear a reg
         IC    R2,OREGALEN         Get A-operand length
         AR    R1,R2               Add to displ.
         B     ALTGBFLT            Continue
*
ALTGLABL AH    R1,OREGBLEN         Add length of move
*
ALTGBFLT CLI   ALTGABUF,X'00'      Is dest a buffer?
         BE    ALTGDOBR            No, skip next tests
         CLI   ALTGABUF,X'0A'      A user buffer?
         BNH   ALTGLNLR            No, do LRECL test
         C     R1,PCTUBFSZ         Yes, test against size of user buffs
         BNH   ALTGDOBR            No, continue
         $ERR  BUFFX,8,SKIP,FLAG=YES  Yes, kill it
*
ALTGLNLR CH    R1,DCBALREC         New high-water mark?
         BNH   ALTGDOBR            No, continue
         STH   R1,DCBALREC         Yes, save it
         MVC   DCBASNO,GETCTR1     and the statement/word number
         MVC   DCBAWNO,GETCTR2     .
         EJECT
*---------------------------------------------------------------------+
*        The KWD3 field for KWALTER types is the address of the       |
*        routine to handle it.     ALTD3 was used to save it.         |
*---------------------------------------------------------------------+
*
ALTGDOBR L     R1,ALTD3            Pickup KW table subcommand index
         BR    R1                  Branch via D3 address
         EJECT
*---------------------------------------------------------------------+
*        Gen the code for the various types of ALTER now.             |
*---------------------------------------------------------------------+
*
ALTGCOPY TM    PCTF3,OPKWLEN       A KW length operand?
         BZ    ALTGCPLT            No
         $ADD  4,ORLLCOD           Yes, stuff code for it
         B     ALTGMVL             And use MVCL type copy
*
ALTGCPLT LH    R1,OREGBLEN         Get the length of the COPY
         CH    R1,=H'256'          See if MVCL is needed
         BH    ALTGM256            Yes,
         BCTR  R1,0                Reduce length for use in EX
         STH   R1,OREGBLEN         Put back in OREGBLEN
         MVC   ORLMVID,PCTIOFLG    Jam in IO flag byte
         $ADD  ORLM999-ORLCODE,ORLCODE Put OREG code into pgm
         $ADD  12,ALTGMMVC         Stuff in EX of MVC
         B     EXITGEOS            Go gen the close-off code
*
ALTGM256 MVI   OREGALEN,X'00'      Clear any A-operand length
         MVI   OREGFLAG,X'00'      and Flag byte
         MVC   ORLMVID,PCTIOFLG    Jam in IO flag byte
         $ADD  ORLM999-ORLCODE,ORLCODE Put OREG code into pgm
*
ALTGMVL  $ADD  8,ALTGMVL1          Stuff in MVCL
         B     EXITGEOS            Go gen the close-off code
*
ALTGAND  BAL   R5,ALTGTSTL         Go process length value
         $ADD  4,ALTGMAND          Stuff in EX of NC
         B     EXITGEOS            Go gen the close-off code
*
ALTGOR   BAL   R5,ALTGTSTL         Go process length value
         $ADD  4,ALTGMOR           Stuff in EX of OC
         B     EXITGEOS            Go gen the close-off code
*
ALTGXOR  BAL   R5,ALTGTSTL         Go process length value
         $ADD  4,ALTGMXOR          Stuff in EX of XC
         B     EXITGEOS            Go gen the close-off code
*
ALTGTRAN BAL   R5,ALTGTSTL         Go process length value
         $ADD  4,ALTGMTR           Stuff in EX of TR
         B     EXITGEOS            Go gen the close-off code
*
ALTGTSTL ST    R5,ALTGTSVR         Save return
         TM    PCTF3,OPKWLEN       KW length operand?
         BO    ALTGTSTK            Yes, alternate code
         LH    R1,OREGBLEN         Get the length of the operation
         CH    R1,=H'256'          See if too big
         BH    BADLGTH             Yes, kill it
         BCTR  R1,0                Reduce length for use in EX
         STH   R1,OREGBLEN         Put back in OREGBLEN
         MVC   ORLMVID,PCTIOFLG    Jam in IO flag byte
         $ADD  ORLM999-ORLCODE,ORLCODE Put OREG code into pgm
         L     R5,ALTGTSVR         Pick up return
         BR    R5                  Return
*
ALTGTSTK $ADD  6,ORLLCOD           Add code to load length
         MVC   ORLMVID,PCTIOFLG    Jam in IO flag byte
         $ADD  4,ORLMVI            Add setting of PCTIOFLG
         L     R5,ALTGTSVR         Get return address
         BR    R5                  Return
         EJECT
*---------------------------------------------------------------------+
*        Gen the code for a floating ALTER.                           |
*---------------------------------------------------------------------+
*
ALTGFLT  CLC   ALTD1,=F'4'         COPY request
         BNE   ALTTBT              No, sorry
         MVC   ORLMVID,PCTIOFLG    Jam in IO flag byte
         TM    PCTIOFLG,IODLML     A DLM type?
         BO    ALTGFLDL            Yes, skip length test
         TM    PCTF3,OPKWLEN       A KW length operand?
         BO    ALTGFLKW            Yes
         LH    R1,OREGBLEN         Get the length of the COPY
         CH    R1,=H'256'          See if too big
         BH    BADLGTH             Yes, kill it
*
ALTGFLDL $ADD  ORLM999-ORLCODE,ORLCODE Put OREG code into pgm
         $ADD  4,ALTGMREP          Stuff in BAL to REPLACE code
         B     EXITGEOS            Go stuff close off code
*
ALTGFLKW $ADD  4,ORLLCOD           Add KW load length code
         $ADD  4,ORLMVI            Add code to set it
         $ADD  4,ALTGMREP          Stuff in BAL to REPLACE code
         B     EXITGEOS            Done
         EJECT
*---------------------------------------------------------------------+
*        Gen the code for the Arithmetic/Convert type of ALTER's      |
*---------------------------------------------------------------------+
*
ALTGPLUS BAL   R5,ALTGTBLA         Put in code to pick up A-operand
         BAL   R5,ALTGTBLB         Put in code to pick up B-operand
         $ADD  2,ALTGMAR           Put in code to ADD them
         BAL   R5,ALTGSBLA         Put in code to store answer
         B     EXITGEOS            Done
*
ALTGSUBT BAL   R5,ALTGTBLA         Put in code to pick up A-operand
         BAL   R5,ALTGTBLB         Put in code to pick up B-operand
         $ADD  2,ALTGMSR           Put in code to SUBT them
         BAL   R5,ALTGSBLA         Put in code to store answer
         B     EXITGEOS            Done
*
ALTGMULT BAL   R5,ALTGTBLA         Put in code to pick up A-operand
         BAL   R5,ALTGTBLB         Put in code to pick up B-operand
         $ADD  2,ALTGMMR           Put in code to MULT them
         BAL   R5,ALTGSBLA         Put in code to store answer
         B     EXITGEOS            Done
*
ALTGDIV  BAL   R5,ALTGTBLA         Put in code to pick up A-operand
         BAL   R5,ALTGTBLB         Put in code to pick up B-operand
         $ADD  4,ALTGMDR           Put in code to DIVIDE them
         BAL   R5,ALTGSBLA         Put in code to store answer
         B     EXITGEOS            Done
*
ALTGAP   BAL   R5,ALTGTPLA         Go prepare lengths
         STC   R1,ALTGMAP+1        Shove length in instruction
         $ADD  6,ALTGMAP           Put instr. in pgm
         B     EXITGEOS            Done
*
ALTGSP   BAL   R5,ALTGTPLA         Go prepare lengths
         STC   R1,ALTGMSP+1        Shove length in instruction
         $ADD  6,ALTGMSP           Put instr. in pgm
         B     EXITGEOS            Done
*
ALTGEDTB BAL   R5,ALTGTBLB         Go make code to put B in R2
         $ADD  4,ALTGMCV2          CVD R2 into DBL
         $ADD  6,ALTGMED1          Move EDIT mask to DBL2
         $ADD  6,ALTGMED3          EDIT DBL into DBL2
         B     ALTGEDMR            Go to common code
*
ALTGEDB$ BAL   R5,ALTGTBLB         Go make code to put B in R2
         $ADD  4,ALTGMCV2          CVD R2 into DBL
         $ADD  12,ALTGMED2         EDIT DBL into DBL2
         B     ALTGEDMR            Go to common code
*
ALTGEDTP BAL   R5,ALTGTCVL         Get B length into R1
         BCTR  R1,0                -1 for machine length
         O     R1,=A(7*16)         OR in length of DBL
         STC   R1,ALTGMZAP+1       Stuff lengths into instr.
         $ADD  6,ALTGMZAP          ZAP B-operand into DBL
         $ADD  6,ALTGMED1          Move EDIT mask to DBL2
         $ADD  6,ALTGMED3          EDIT DBL into DBL2
         B     ALTGEDMR            Go to common code
*
ALTGEDP$ BAL   R5,ALTGTCVL         Get B length into R1
         BCTR  R1,0                -1 for machine length
         O     R1,=A(7*16)         OR in length of DBL
         STC   R1,ALTGMZAP+1       Stuff lengths into instr.
         $ADD  6,ALTGMZAP          ZAP B-operand into DBL
         $ADD  12,ALTGMED2         EDIT DBL into DBL2
*
ALTGEDMR CLI   OREGALEN,X'00'      An A length ?
         BE    BADLGTH             No, sorry
         SR    R1,R1               Clear a reg.
         IC    R1,OREGALEN         Get the A length
         LA    R2,16               Get length of DBL2
         SR    R2,R1               Calc displ. into DBL2
         AH    R2,=S(DBL2)         Create Base/Displ of instr
         STH   R2,ALTGMMD2+4       Put into instr.
         BCTR  R1,0                Reduce length by 1
         STC   R1,ALTGMMD2+1       Put it into instr.
         $ADD  6,ALTGMMD2          Stuff instr. into pgm
         B     EXITGEOS            Done
*
ALTGCVXC SR    R5,R5               Check out lengths
         IC    R5,OREGALEN         Get A length
         LH    R4,OREGBLEN         Get B length
         AR    R4,R4               Double B
         CR    R5,R4               Better be equal
         BNE   BADLGTH             Sorry
         $ADD  ORLM999-ORLCODE,ORLCODE Put OREG code into pgm
         $ADD  4,ALTGMHEX          Stuff in BAL to HEXIT code
         B     EXITGEOS            Done
*
ALTGCVZP BAL   R5,ALTGTCVL         Go Check lengths
         BAL   R5,ALTGGPAK         Make code to put B into DBL
         BAL   R5,ALTGGMDS         Make code to move DBL to A
         B     EXITGEOS            Done
*
ALTGCVZB BAL   R5,ALTGTCVL         Go Check lengths
         BAL   R5,ALTGGPAK         Make code to put B into DBL
         $ADD  4,ALTGMCV1          Make code to get B into R1
         CLI   OREGALEN,X'04'      Test for valid binary length
         BH    BADLGTH             Sorry
         BAL   R5,ALTGSBLA         Make code to put answer into A
         B     EXITGEOS            Done
*
ALTGCVPZ BAL   R5,ALTGTPLA         Go prepare A/B lengths
         STC   R1,ALTGMUP1+1       Stuff lengths into instr.
         $ADD  6,ALTGMUP1          Stuff UNPK into pgm
         BAL   R5,ALTGGOI          Make code to correct sign
         B     EXITGEOS            Done
*
ALTGCVPB BAL   R5,ALTGTCVL         Go check lengths
         BCTR  R1,0                -1 for machine length
         O     R1,=A(7*16)         OR in length of DBL
         STC   R1,ALTGMZAP+1       Stuff lengths into instr.
         $ADD  6,ALTGMZAP          Stuff UNPK into pgm
         $ADD  4,ALTGMCV1          Stuff CVB into pgm
         CLI   OREGALEN,X'04'      Test for valid binary length
         BH    BADLGTH             Sorry
         BAL   R5,ALTGSBLA         Make code to put answer into A
         B     EXITGEOS            Done
*
ALTGCVBP BAL   R5,ALTGTBLB         Go make code to put B in R2
         $ADD  4,ALTGMCV2          CVD R2 into DBL
         CLI   OREGALEN,X'00'      An A length ?
         BE    BADLGTH             No, sorry
         BAL   R5,ALTGGMDS         Make code to move DBL to A
         B     EXITGEOS            Done
*
ALTGCVBZ BAL   R5,ALTGTBLB         Go make code to put B in R2
         $ADD  4,ALTGMCV2          CVD R2 into DBL
         $ADD  6,ALTGMUP2          UNPK DBL to DBL2
         CLI   OREGALEN,X'00'      An A length ?
         BE    BADLGTH             No, sorry
         SR    R1,R1               Clear a reg.
         IC    R1,OREGALEN         Get the A length
         LA    R2,16               Get length of DBL2
         SR    R2,R1               Calc displ. into DBL2
         AH    R2,=S(DBL2)         Create Base/Displ of instr
         STH   R2,ALTGMMD2+4       Put into instr.
         BCTR  R1,0                Reduce length by 1
         STC   R1,ALTGMMD2+1       Put it into instr.
         $ADD  6,ALTGMMD2          Stuff instr. into pgm
         BAL   R5,ALTGGOI          Make code to correct sign
         B     EXITGEOS            Done
         EJECT
*---------------------------------------------------------------------+
*        Misc. support routines for CV.. code creation                |
*---------------------------------------------------------------------+
*
ALTGGPAK ST    R5,ALTGTSVR         Save return
         BCTR  R1,0                Make B length an instr length
         O     R1,=A(7*16)         OR in the length of DBL
         STC   R1,ALTGMPAK+1       Stuff in instr
         $ADD  6,ALTGMPAK          Put instr in program
         B     ALTGBEX             Return
*
ALTGGMDS ST    R5,ALTGTSVR         Save return
         SR    R1,R1               Clear a reg.
         IC    R1,OREGALEN         Get the A length
         LA    R2,8                Get length of DBL
         SR    R2,R1               Calc displ. into DBL
         AH    R2,=S(DBL)          Create Base/Displ of instr
         STH   R2,ALTGMMDS+4       Put into instr.
         BCTR  R1,0                Reduce length by 1
         STC   R1,ALTGMMDS+1       Put it into instr.
         $ADD  6,ALTGMMDS          Stuff instr. into pgm
         B     ALTGBEX             Return
*
ALTGGOI  ST    R5,ALTGTSVR         Save return
         SR    R1,R1               Clear a reg.
         IC    R1,OREGALEN         Get the A length
         BCTR  R1,0                -1 to calc displ. for OI
         STC   R1,ALTGMOI+3        Stuff into instr.
         $ADD  4,ALTGMOI           Put OI into pgm
         B     ALTGBEX             Return
*---------------------------------------------------------------------+
*        Length checker for the CV.. routines                         |
*---------------------------------------------------------------------+
*
ALTGTCVL ST    R5,ALTGTSVR         Save return
         CLI   OREGALEN,X'00'      Better have an A length
         BE    BADLGTH             None, kill it
         LH    R1,OREGBLEN         No, swap in B length
         CH    R1,=H'16'           Test against max
         BH    BADLGTH             Too high
         LTR   R1,R1               Zero?
         BZ    BADLGTH             Also no good
         B     ALTGBEX             Return with B-length in R1
         EJECT
*---------------------------------------------------------------------+
*        PACKed length support routine for ADDP/SUBP                  |
*---------------------------------------------------------------------+
*
ALTGTPLA ST    R5,ALTGTSVR         Save return
         SR    R1,R1               Clear R1
         ICM   R1,1,OREGALEN       Any A length?
         BNZ   *+8                 Yes, skip
         LH    R1,OREGBLEN         No, swap in B length
         CH    R1,=H'16'           Test against max
         BH    BADLGTH             Too high
         BCTR  R1,0                -1 for instr. length
         SLL   R1,4                Shift to A-operand location
         LH    R2,OREGBLEN         Swap in B length
         CH    R2,=H'16'           Test against max
         BH    BADLGTH             Too high
         BCTR  R2,0                -1 for instr. length
         OR    R1,R2               .
         B     ALTGBEX             Return
         EJECT
*---------------------------------------------------------------------+
*        Length checker/generate routines for Binary ADD/SUB logic.   |
*---------------------------------------------------------------------+
*
ALTGTBLA ST    R5,ALTGTSVR         Save return
         LA    R2,4                Set for A-operand
         SR    R1,R1               Clear R1
         ICM   R1,1,OREGALEN       Any A length?
         BNZ   ALTGTLTT            Yes, skip
         LH    R1,OREGBLEN         No, swap in B length
         STC   R1,OREGALEN         .
         B     ALTGTLTT            Skip into common code
*
ALTGTBLB ST    R5,ALTGTSVR         Save return
         LA    R2,8                Set for B-operand
         SR    R1,R1               Clear R1
         ICM   R1,3,OREGBLEN       Get length
         BZ    BADLGTH             Kill it if zero
*
ALTGTLTT CH    R1,=H'4'            Test against max
         BH    BADLGTH             Yes, kill it
         SLL   R1,2                x 4
         B     *(R1)               Branch by length of operand
         B     ALTGOL1             Length = 1
         B     ALTGOL2             Length = 2
         B     ALTGOL3             Length = 3
         B     ALTGOL4             Length = 4
*
ALTGOL1  B     *(R2)               Branch by A/B operand type
         B     ALTGOL1A            A
         B     ALTGOL1B            B
*
ALTGOL1A $ADD  6,ALTGML1A          Stuff in code
         B     ALTGBEX             Return
*
ALTGOL1B $ADD  6,ALTGML1B          Stuff in code
         B     ALTGBEX             Return
*
ALTGOL2  B     *(R2)               Branch by A/B operand type
         B     ALTGOL2A            A
         B     ALTGOL2B            B
*
ALTGOL2A $ADD  4,ALTGML2A          Stuff in code
         B     ALTGBEX             Return
*
ALTGOL2B $ADD  4,ALTGML2B          Stuff in code
         B     ALTGBEX             Return
*
ALTGOL3  B     *(R2)               Branch by A/B operand type
         B     ALTGOL3A            A
         B     ALTGOL3B            B
*
ALTGOL3A $ADD  6,ALTGML3A          Stuff in code
         B     ALTGBEX             Return
*
ALTGOL3B $ADD  6,ALTGML3B          Stuff in code
         B     ALTGBEX             Return
*
ALTGOL4  B     *(R2)               Branch by A/B operand type
         B     ALTGOL4A            A
         B     ALTGOL4B            B
*
ALTGOL4A $ADD  4,ALTGML4A          Stuff in code
         B     ALTGBEX             Return
*
ALTGOL4B $ADD  4,ALTGML4B          Stuff in code
         B     ALTGBEX             Return
*
ALTGSBLA ST    R5,ALTGTSVR         Save return
         SR    R1,R1               Clear R1
         IC    R1,OREGALEN         Get length
         SLL   R1,2                x 4
         B     *(R1)               Branch by length of operand
         B     ALTGBSL1            Length = 1
         B     ALTGBSL2            Length = 2
         B     ALTGBSL3            Length = 3
         B     ALTGBSL4            Length = 4
*
ALTGBSL1 $ADD  4,ALTGMS1A          Shove in code
         B     ALTGBEX             Return
*
ALTGBSL2 $ADD  4,ALTGMS2A          Shove in code
         B     ALTGBEX             Return
*
ALTGBSL3 $ADD  4,ALTGMS3A          Shove in code
         B     ALTGBEX             Return
*
ALTGBSL4 $ADD  4,ALTGMS4A          Shove in code
*
ALTGBEX  L     R5,ALTGTSVR         Pick up return
         BR    R5                  Return
         EJECT
*---------------------------------------------------------------------+
*   Generate the code for the ALTER COPYBUFF(.......) command.        |
*---------------------------------------------------------------------+
*
ALTCBFO  CLI   KWNUM,X'E4'         Was it UBUFFx?
         BNE   ALTCBBF             No, skip
         L     R1,KWD3             Get index again
         SLL   R1,2                x 4
         LA    R1,PCTINPL1-4(R1)   Point at length field
         MVC   0(4,R1),=F'-1'      Flag as GETMAIN needed
*
ALTCBBF  $CALL GETNEXT             Get next word (better be COPYBUFF!)
         TM    WFLAG1,WWRD1        Got a word?
         BNO   ALTTBT              No, error
         TM    WRD1F2,OPRKW+OPRKWV+OPRKWOP Maybe, a valid KW and fmt?
         BNO   ALTTBT              No, error
         LA    R14,WRD1KW1         Point at KW answer area
*
ALTCBUFD CLC   ALTGUONX,=F'40'     OBUFF destination ?
         BNE   ALTCNDBC            No, then no deferred buffer copy
         $ADD  4,DCOPM010          Yes, add test for deferred copy
         OI    PCTF1,DCOPYGEN      and remember it
*
ALTCNDBC TM    WRD1F2,OPRKWOPV     Valid (...) KW. i.e. (UBUFFx)?
         BZ    ALTCBFCB            No, go try as a DDname
         LA    R14,WRD1KW2         Yes, point at answer area
         CLI   KWNUM,X'E5'         INPUTx?
         BE    ALTCBBUF            Yes
         CLI   KWNUM,X'E4'         UBUFFx ?
         BE    ALTCBBUF            Yes
         CLI   KWNUM,X'E3'         OBUFF  ?
         BNE   ALTCBFCB            No, again treat as DDname
*
ALTCBBUF L     R1,KWD3             Get buffer index
         SLL   R1,2                x 4
         ST    R1,ALTGUINX         Stuff in
         CLI   KWNUM,X'E4'         UBUFFx ?
         BNE   *+14                Yes
         LA    R1,PCTINPL1-4(R1)   Point at length field
         MVC   0(4,R1),=F'-1'      Flag as GETMAIN needed
         $ADD  ALTGUBF9-ALTGUBF1,ALTGUBF1 Point at UBUFFx
         $ADD  ALTGMLO3-ALTGMLO1,ALTGMLO1 Point at output buffer
         CLC   ALTGUONX,=F'40'     OBUFF destination?
         BNE   ALTCBSOD            No
         $ADD  18,ALTSOBL1         Yes, alter OBUFF length
*
ALTCBSOD $ADD  ALTGMLO9-ALTGMLO3,ALTGMLO3 Complete code
         B     ALTCBCLS            Go gen the close-off code
*
ALTCBFCB $CALL DCBI1BLD,WRD1L2     Go get FCB address
         B     BADDCB              +0 error, kill it
         STCM  R1,7,OPGBASE+1      Save FCB address
         MVC   OPGBASE(1),FCBFILNO+1-FCBDSECT(R1) Save file number
         MVC   ALTGMFCB,OPGBASE    Copy FCB address
         $ADD  ALTGMLF9-ALTGMLF1,ALTGMLF1 Point at input buffer
         $ADD  ALTGMLO3-ALTGMLO1,ALTGMLO1 Point at output buffer
         CLC   ALTGUONX,=F'40'     OBUFF destination?
         BNE   ALTCBFOD            No
         $ADD  18,ALTSOBL1         Yes, alter OBUFF length
*
ALTCBFOD $ADD  ALTGMLO9-ALTGMLO3,ALTGMLO3 Point at output buffer
*
ALTCBCLS $ADD  6,ALTGMML1          MVCL it
         OI    PCTF1,IPCOPY        Force alternate O/P buffer.
         B     EXITGEOS            Go gen the close-off code
         EJECT
*---------------------------------------------------------------------+
*        ALTER command work areas and model code                      |
*---------------------------------------------------------------------+
*
         DS    0F
ALTGUBF1 BAL   R10,COMP10X4        Skip over ADCON
ALTGUINX DC    XL4'00'             BUFFx index x 4
ALTGUBF2 ICM   R15,15,0(R10)       Load buffer index
ALTGUBF3 L     R2,PCTINPT1-4(R15)  Get address of record
ALTGUBF4 L     R3,PCTINPL1-4(R15)  Get length of input record
ALTGUBF9 EQU   *
*
ALTGMLF1 BAL   R10,COMP10X4        Skip over ADCON
ALTGMFCB DC    XL4'00'             Address of FCB
ALTGMLF2 ICM   R15,15,0(R10)       Point R15 at FCB
ALTGMLF3 L     R2,FCBRECAD-FCBDSECT(R15) Get address of record
ALTGMLF4 LH    R3,FCBLRECL-FCBDSECT(R15) Get length of input record
ALTGMLF9 EQU   *
*
ALTGMLO1 BAL   R10,COMP10X4        Skip over ADCON
ALTGUONX DC    XL4'00'             BUFFx index x 4
ALTGMLO2 ICM   R15,15,0(R10)       Load buffer index
ALTGMLO3 L     R4,PCTINPT1-4(R15)  Get address of record
ALTGMLO4 L     R5,PCTINPL1-4(R15)  Get length of input record
ALTGMLO9 EQU   *
*
ALTSOBL1 BALR  R10,0               Get temp addressability
ALTSOBL2 CH    R3,DCBHLREC         Ensure not bigger than OBUFF
ALTSOBL3 BNH   12(R10)  (*+8)      Its not, skip next instr
ALTSOBL4 LH    R3,DCBHLREC         It is, use DCBHLREC instead
ALTSOBL5 ST    R3,PCTINPL1-4(R15)  Update OBUFF length
*
ALTGMML1 ICM   R3,8,PCTPADCH       Insert fill character
ALTGMML2 MVCL  R4,R2               Move the data
*
ALTGMVL1 ST    OREG,PCTFLEN        Save length of ALTER's move
ALTGMVL2 LR    R3,R5               Copy length for MVCL
ALTGMVL3 MVCL  AREG,BREG           Move the data
*
ALTGML1A SR    R1,R1               Clear work reg
         IC    R1,0(AREG)          Get value
ALTGML1B SR    R2,R2               Clear work reg
         IC    R2,0(BREG)          Get value
ALTGML2A LH    R1,0(AREG)          Get value
ALTGML2B LH    R2,0(BREG)          Get value
ALTGML3A SR    R1,R1               Clear work reg
         ICM   R1,7,0(AREG)        Get value
ALTGML3B SR    R2,R2               Clear work reg
         ICM   R2,7,0(BREG)        Get value
ALTGML4A L     R1,0(AREG)          Get value
ALTGML4B L     R2,0(BREG)          Get value
*
ALTGMS1A STC   R1,0(AREG)          Store value
ALTGMS2A STH   R1,0(AREG)          Store value
ALTGMS3A STCM  R1,7,0(AREG)        Store value
ALTGMS4A ST    R1,0(AREG)          Store value
*
ALTGMAR  AR    R1,R2               Add the two
ALTGMSR  SR    R1,R2               Subtract the two
ALTGMMR  MR    R0,R2               Multiply them
ALTGMDR  SR    R0,R0               Clear R0
         DR    R0,R2               Divide them
ALTGMAP  AP    0(0,AREG),0(0,BREG) ADD packed
ALTGMSP  SP    0(0,AREG),0(0,BREG) SUB packed
*
ALTGMPAK PACK  DBL,0(0,BREG)       PACK B-operand
ALTGMMDS MVC   0(0,AREG),DBL+0     Move DBL to A-operand
ALTGMCV1 CVB   R1,DBL              CVB DBL to R1
ALTGMCV2 CVD   R2,DBL              CVD R2 to DBL
ALTGMUP1 UNPK  0(0,AREG),0(0,BREG) UNPK B-operand to A-operand
ALTGMOI  OI    0(AREG),C'0'        OI for correct zone
ALTGMZAP ZAP   DBL,0(0,BREG)       Packed B-operand to DBL
ALTGMUP2 UNPK  DBL2(16),DBL(8)     UNPK entire DBL to DBL2
ALTGMMD2 MVC   0(0,AREG),DBL2+0    Move DBL2 to A-operand
ALTGMED1 MVC   DBL2(16),ALTGEDT1   Move EDIT mask1
ALTGMED2 MVC   DBL2(16),ALTGEDT2   Move EDIT mask2
ALTGMED3 ED    DBL2(16),DBL+2      EDIT DBL into DBL2
         $PEND
         DROP  R10
         TITLE 'CKCOMENT - Handle comment control'
*---------------------------------------------------------------------+
*        Routine skips to number of end of sentences                  |
*        specified in nest counter COMNTCTL                           |
*        or puts routine into skip mode if a label                    |
*        of the type '*:' is found in WORDTXT.                        |
*---------------------------------------------------------------------+
*
CKCOMENT $PROC
         USING KWDSECT,R14
         CP    COMNTCTL,=P'0'      In skip mode already?
         BNE   CKCEOS2             Yes, go see if nested
         TM    WFLAG1,WPREF        Is this prefixed?
         BZ    CKCOEX              No, leave now
         TM    WFLAG1,WWRD1+WWRD2+WTRLR+WPLUS+WMINUS If any other
         BNZ   CKCOEX              present its not a simple *:
         TM    PREFF2,OPRKW+OPRKWV With a valid keyword?
         BNO   CKCOEX              No, leave now
         LA    R14,PREFKW1
         CLI   KWNUM,COMMENT       A comment?
         BNE   CKCOEX              No, leave now
         AP    COMNTCTL,=P'1'      Yes, start nest count
*
CKCGNEXT L     R8,=A(GETNEXT)      Reset back to GETNEXT
         B     8(R8)               And go for next word
*
CKCOEX   $RET  0
*
CKCEOS2  CLC   WORDL,ZEROS         Is this end of sentence?
         BNE   CKCNEST             No, go test for nested comments
         SP    COMNTCTL,=P'1'      Decrement nest count
         B     CKCGNEXT            And go for next word
*
CKCNEST  TM    WFLAG1,WPREF        Is this prefixed?
         BZ    CKCGNEXT            No, leave now
         TM    WFLAG1,WWRD1+WWRD2+WTRLR+WPLUS+WMINUS If any other
         BNZ   CKCGNEXT            present its not a simple *:
         TM    PREFF2,OPRKW+OPRKWV With a valid keyword?
         BNO   CKCGNEXT            No, leave now
         LA    R14,PREFKW1
         CLI   KWNUM,COMMENT       A comment?
         BNE   CKCGNEXT            No, leave now
         AP    COMNTCTL,=P'1'      Yes, bump nest count
         B     CKCGNEXT            And go back for a word
         DROP  R14
         $PEND
         TITLE 'CLOSE - Command processor'
*---------------------------------------------------------------------+
*        C L O S E   C o m m a n d    P r o c e s s o r               |
*---------------------------------------------------------------------+
*
CLOSE    $PROC
         $CALL DBGADD              Go add DEBUG code
*
CLOSLOOP $CALL GETNEXT             Get next word, (if any).
         CLC   WORDL,=H'0'         End of sentence?
         BE    EXITGOK             Yes, go to common command exit
         TM    WFLAG1,WPREF+WTRLR  Invalid format?
         BNZ   BADKWORD            Yes, kill it
         TM    WFLAG1,WWRD1        Got WRD1?
         BNO   BADKWORD            Yes, kill it
         TM    WRD1F2,OPRKW+OPRKWV Valid KW?
         BNO   BADOPTYP            No, kill it
         LA    R14,WRD1KW1         Point at KW answer area
         USING KWDSECT,R14
         TM    KWF1,KWOPRAND+KWSUBVAL Valid type?
         BNO   BADKWORD            No, sorry
         CLI   KWNUM,X'9A'         Valid CLOSE KW?
         BE    CLOSBR              Yes, continue
         CLI   KWNUM,X'9B'         Valid CLOSE KW?
         BE    CLOSBR              Yes, continue
         B     BADKWORD            No, kill it
*
CLOSBR   L     R2,KWD2             Get address of routine
         BR    R2                  Branch by type
*---------------------------------------------------------------------+
*        Process the INPUT(ddname) operand                            |
*---------------------------------------------------------------------+
*
CLOSINPT TM    WRD1F2,OPRKWOP      Got a (...) operand?
         BZ    BADOPTYP            No, sorry
         OI    PCTF3,INPUT         Make this DDname count
         $CALL DCBI1BLD,WRD1L2     Go setup input DCB
         B     BADDCB              Error, too bad
         ST    R1,CLOSFCBA         Save address of FCB area
         B     CLOSGEN             Go gen some code
*---------------------------------------------------------------------+
*        Process the OUTPUT(ddname) operand                           |
*---------------------------------------------------------------------+
*
CLOSOUTP TM    WRD1F2,OPRKWOP      Got a (...) operand?
         BZ    BADOPTYP            No, sorry
         NI    PCTF3,255-INPUT     Reset input type
         $CALL DCBO1BLD,WRD1L2     Go setup output DCB
         B     BADDCB              Error, too bad
         ST    R1,CLOSFCBA         Save address of FCB area
*---------------------------------------------------------------------+
*        Gen the CLOSE code now                                       |
*---------------------------------------------------------------------+
*
CLOSGEN  $ADD  CLOSDONE-CLOSBALR,CLOSBALR Add the code
         B     CLOSLOOP            Loop for next operand
*
*---------------------------------------------------------------------+
*        CLOSE routine work area and model code                       |
*---------------------------------------------------------------------+
*
         CNOP  2,4                 So CLOSADDA is aligned
CLOSBALR BALR  R14,0               Get local addressability
CLOSCALL STM   R0,R15,CLOSSAVE-CLOSCALL(R14) Get ADDPROC address
         ICM   R15,15,CLOSADDA-CLOSCALL(R14) Get ADDPROC address
         ST    R8,4(R15)           Save this PROC's base
         MVC   12(4,R15),CLOSFCBA-CLOSCALL(R14) Setup passed param
         BALR  R8,0                Calc my return address
         LA    R8,14(,R8)          .
         ST    R8,0(R15)           Save at +0 in called routine
         LR    R8,R15              Make called routine addressable
         B     8(R8)               Go to it
         BALR  R14,0               Get addressable again
CLOSSKIP LM    R0,R15,CLOSSAVE-CLOSSKIP(R14) Reload regs
         B     CLOSDONE-CLOSCALL(R14) Skip constants
CLOSFCBA DC    4X'00'              Location of FCB for this DD
CLOSADDA DC    A(ADDPROC)          ADDPROC routine address
CLOSSAVE DC    16A(0)              Save area
CLOSDONE EQU   *
*
CLOSNOPS $ERR  NOOPS,8,GO=MAINGOK  Yes, kill it and continue
*
CLOSDDN  $ERR  BDDN,8,SKIP
         DROP  R14
         $PEND
         TITLE 'COPYDATA - Do some real I/O for the user'
*---------------------------------------------------------------------+
*        Initialize for an actual run                                 |
*---------------------------------------------------------------------+
*
COPYDATA $PROC
         MVC   PCTPGMS,PCTPGM      Copy so COPEOF.. doesn't swap in 0
*
COPYFILE ICM   R1,15,PCTMACNT      Get master active count
         BNZ   COPSETUP            Yes, go ahead
         TM    PCTF6,OPCHECK       Told about the no-I/O?
         BZ    COPSETUP            Yes, don't give an error
         $ERR  NOOP,12,GO=ADDSTATS,FLAG=NO No, terminate now
*
COPSETUP TM    PCTF1,IPCOPY        I/P copies?
         BZ    COPSTART            No, need no O/P buffer then
         LH    R0,DCBHLREC         Use output high LRECL
         ST    R0,PCTOBUFL         Set in the length
         AH    R0,=H'4'            Get room for possible RDW
         CLC   PCTOUTPT,ZEROS      Already got O/P buffer?
         BNE   COPSTART            Yes, don't get another
         GETMAIN R,LV=(0)          Get a work area
         LA    R1,4(,R1)           Step over possible RDW
         ST    R1,PCTOUTPT         And save its address
         TITLE 'COPYDATA - Data Main Line'
*---------------------------------------------------------------------+
*        This is the actual main data reading mainline                |
*                                                                     |
*        Changes to the following should be watched carefully.        |
*        Every instr. added to this code has a significant            |
*        impact on performance.                                       |
*---------------------------------------------------------------------+
*
COPSTART NI    PCTF4,255-COMPILE   Say compile is done
         MVC   PCTCFLAG,PCTBFCDF   Copy buffer copy default to start
         TM    PCTF2,DINPUT1       Did we get an INPUT1 DD?
         BZ    COPREAL             No, pass control to user
         $CALL FASTCOPY            If FASTCOPY returns, it means it
*                                  couldn't do it, we take over again
         L     R7,PCT1FCB          Point at INPUT1 FCB for 1st read
*
COPREAD  TM    PCTF7,TIMEFLAG      Is STIMER needed?
         BZ    COPREAD2
         STIMER TASK,TIMEEXIT,TUINTVL=ONESEC Set a timer interval
         NI    PCTF7,255-TIMEFLAG  Say STIMER not needed
*
COPREAD2 TM    FCBF2,FCBEOF        Already hit EOF?
         BO    COPEOFER            Yes, too bad
         TM    FCBF1,FCBCLOSD      CLOSED?
         BO    BADIO               Yes, too bad!
         LA    R2,FCBDCB           Point at DCB to be read
         GET   (R2)                Get next record
         TM    FCBF2,FCBRREAD      Re-read needed for concatenation
         BZ    COPR1STR            No
         NI    FCBF2,255-FCBRREAD  Turn off reread sw
         RDJFCB ((R2))             Get the new JFCB for the file
         MVC   FCBJFCB,JFCB        Save the new JFCB
         $CALL JFCNAME,FCBDSECT    Go build a full dsname
         MVC   FCBORECF,FCBDCB+DCBRECFM And some other things
         MVC   FCBRECFM,FCBORECF
         MVC   FCBOBLK,FCBDCB+DCBBLKSI
         MVC   FCBBLKSI,FCBOBLK
         TM    FCBRECFM,X'C0'      Undefined?
         BNO   *+10                No
         MVC   FCBDCB+DCBLRECL(2),FCBDCB+DCBBLKSI
         MVC   FCBOLREC,FCBDCB+DCBLRECL
         MVC   FCBLRECL,FCBOLREC
         MVC   FCBULREC,FCBOLREC
         MVC   FCBCOUNT,ZEROS      Reset count of records read
         MVC   FCBNVOLS(31),FCBJFCB+JFCBNVOL-JFCB
         CLC   FCBLRECL,DCBHLREC   Is this a new hi-water mark
         BNH   COPSROUT            No, continue
         CLC   PCTINPT1,PCTOUTPT   Are we running with 2 buffers?
         BE    COPSROUT            No, skip the buffer swap
         LA    R2,4                Get +4 into a reg
         LH    R0,FCBLRECL         Yes, get size of the new one
         AR    R0,R2               +4 for possible RDW
         GETMAIN R,LV=(0)          Go get it
         L     R14,PCTOUTPT        Point at old buffer
         SR    R14,R2              -4 for RDW area
         LH    R15,DCBHLREC        Get old buffer length
         AR    R0,R2               +4 for possible RDW
         STM   R14,R15,DBL         Save old location/length for a bit
         AR    R1,R2               Adjust new address for possible RDW
         ST    R1,PCTOUTPT         Save address of new buffer
         SR    R1,R2               Adjust back for MVCL
         LR    R0,R1               Swap for MVCL regs
         LH    R1,FCBLRECL         .
         AR    R1,R2               .
         MVCL  R0,R14              Copy the old buffer data
         L     R0,DBL+4            Free the old buffer
         L     R1,DBL              .
         FREEMAIN R,LV=(0),A=(1)   .
         MVC   DCBHLREC,FCBLRECL   Set new hi-water mark
*
COPSROUT LR    R5,R7               Save R7 around SETROUTE
         $CALL SETROUTE            Go setup output routes
         LR    R7,R5               Reload R7
         B     COPREAD             And go do it
*
COPR1STR L     R14,FCBRECPT        Get address of I/P record save area
         ST    R1,0(R14)           Save address of record read in PCT
         ST    R1,FCBRECAD         and in it's FCB
         MVC   FCBLRECL,FCBDCB+DCBLRECL Save LRECL
         TM    FCBRECFM,X'C0'      An undefined record?
         BNO   COPTIO2             No, skip this bit
         CLC   FCBLRECL,FCBOBLK    Is blocksize read invalid?
         BNH   COPTIO2             No, leave it alone
         MVC   FCBLRECL,FCBOBLK    Yes, correct it right now
         MVC   FCBDCB+DCBLRECL(2),FCBOBLK Before it causes problems
*
COPTIO2  MVC   FCBLRECL,FCBDCB+DCBLRECL Save LRECL read
         MVC   FCBULREC,FCBDCB+DCBLRECL Also for user
         L     R14,FCBLENPT        Get address of I/P reclen save area
         MVC   2(2,R14),FCBLRECL   Save length of record just read
         OI    PCTF4,IODONE        Say we did some I/O
         CLC   FCBDDNAM,MDINPT1+2  Is this INPUT1?
         BNE   COPBCOPY            No, skip unique INPUT1 stuff
         $INC  PCTCOUNT            Update CREC counter
         TM    PCTF1,IPCOPY        Separate Output buffer?
         BZ    COPDFBUF            No, default O/P to I/P buffer
         TM    PCTBFCDF,COPYBUFF   AUTOCOPY(YES)?
         BZ    COPBCOPY            No, see if specific request
         TM    PCTCFLAG,COPYBUFF   COPYBUFF request?
         BZ    COPRDONE            No, ignore copies
         OI    PCTF6,DEFRCOPY      Yes, try for the deferred mode
         B     COPRDONE            Continue
*
COPBCOPY TM    PCTCFLAG,COPYBUFF   COPYBUFF request?
         BZ    COPRDONE            No, ignore copies
*
COPBDOIT LR    R2,R1               Do
         L     R4,PCTOUTPT         Setup
         LH    R3,FCBLRECL         For
         STH   R3,PCTOBUFL+2       Save length of rec on O/P buffer
         LH    R5,DCBHLREC         An MVCL
         ICM   R3,8,PCTPADCH       Put in specified fill char
         MVCL  R4,R2               Move input record to output area
         NI    PCTF6,255-DEFRCOPY  Kill any deferred copy
         B     COPRDONE            Continue
*
COPDFBUF ST    R1,PCTOUTPT         Make O/P buffer = I/P buffer
         MVC   PCTOBUFL+2(2),FCBLRECL Save length of rec on O/P buffer.
*
COPRDONE $INC  FCBCOUNT            Count the record
         $INC  FCBCREC             .
*
COPTRACE TM    PCTF7,DBIOTRAC      DEBUG IOTRACE?
         BZ    COPDUMP             No
         MVC   LINE(5),=C'Input'   Move in heading
         MVC   LINE+6(23),TRHD     .
         MVC   LINE+7(8),FCBDDNAM  Fill in data
         L     R1,FCBCREC          Get current record number
         CVD   R1,DBL
         ED    LINE+20(8),DBL+4    Edit record number into line
         MVI   LINE+20,C'('        Insert (
         BAL   R14,LINPRINT        Print line
*
COPDUMP  TM    PCTF7,DBDUMP        DEBUG DUMP?
         BZ    COPREAL             No
         MVC   TRADDR,FCBRECAD     Move address of record for DMPIT
         LH    R15,FCBLRECL        Get length of record
         ST    R15,TRLGTH          for DMPIT
         LA    R14,TRFLAG-1        Fudge R15(R14) for DMPIT
         $CALL DMPIT               Go dump record
         EJECT
*---------------------------------------------------------------------+
*        The user's compiled program is given control here            |
*        and will normally give control back at the label COPRETN.    |
*---------------------------------------------------------------------+
*
COPREAL  OI    PCTF1,EXEC          Show execution in user pgm
         L     R14,PCTPGM          Get address of compiled pgm
         BR    R14                 And go to it
*
COPRETN  MVC   PCTCFLAG(12),0(R15) Save I/P control addressses
         NI    PCTF1,255-EXEC      Show EXEC in main pgm
         ICM   R7,15,PCTIPFCB      Point at FCB to be read
         BZ    COPNOUT1            Null, then no INPUT1 present
         TM    FCBF1,FCBOPEN       OPEN?
         BZ    COPDFOPN            No, go see if Deferred OPEN
*
COPCOPMD TM    PCTF3,ALL           SELECT's 'ALL' present?
         BO    COPREAD             Yes, go back and read then
         TM    PCTF6,OPCHECK       Told about the no-I/O?
         BZ    COPREAD             Yes, don't give an error
         ICM   R1,15,PCTMACNT      Get master active count
         BNZ   COPREAD             Non-zero, go do the read
         B     ADDSTATS            Zero, we're all done
*
COPNOUT1 L     R1,=A(ERRTX33)      Point at error message
         MVC   4(8,R1),MDINPT1+2   Move in DDname
         $ERR  NOUT,12,SAVE=YES,FLAG=NO No, kill
         B     ADDSTATS            Terminate
*---------------------------------------------------------------------+
*        FCB is not OPEN, if Deferred, try it now                     |
*---------------------------------------------------------------------+
*
COPDFOPN TM    FCBF1,FCBDOPEN      A Deferred file?
         BZ    COPDFER1            No, whoops!
         TM    PCTF8,PDSMODE       Global PDSMODE?
         BZ    COPDIONR            No, normal OPEN
         TM    FCBF2,FCBPDS        Is this FCB in PDS mode?
         BNO   COPDIONR            No, skip
         L     R2,PCTMEMBC         Get current 'member' name
         MVC   FCBJFCB+44(8),0(R2) Stuff in member name
         LA    R2,8(,R2)           Bump
         ST    R2,PCTMEMBC         Save back for next time
         OI    FCBJFCB+86,X'01'    Flag as a member
         OI    FCBJFCB+52,X'08'    Don't re-write JFCB during OPEN
         $CALL JFCNAME,FCBDSECT    Go build a full dsname
         MVC   JFCB,FCBJFCB        Swap to common area
         LA    R2,FCBDCB           OPEN it now
         OPEN  ((R2),INPUT),TYPE=J .
         B     COPDIOTS            Continue
*
COPDIONR LA    R2,FCBDCB           Point at DCB
         OPEN  ((R2),INPUT)        And open it
*
COPDIOTS TM    48(R2),X'10'        Open O.K. ?
         BNO   COPDFER2            No, whoops again!
         OI    FCBF1,FCBOPEN+FCBSTATS Flag as open STATS allowed
         TM    FCBDCB+17,X'4F'     Is this a terminal file?
         BNO   *+16                No
         MVC   FCBDSNAM,BLANKS     Blank FCBDSNAM
         MVC   FCBDSNAM(8),=C'TERMFILE' And insert termfile
         LH    R1,FCBDCB+DCBLRECL  Save DCBDATA
         STH   R1,FCBLRECL
         STH   R1,FCBOLREC
         LH    R1,FCBDCB+DCBBLKSI
         STH   R1,FCBBLKSI
         STH   R1,FCBOBLK
         MVC   FCBRECFM,FCBDCB+DCBRECFM
         MVC   FCBORECF,FCBRECFM
         MVC   FCBNVOLS(31),FCBJFCB+JFCBNVOL-JFCB
         B     COPCOPMD            Go see if READ to do
*
COPDFER1 $ERR  DOP1,20,FLAG=NO     Tell user
         B     ADDSTATS            Terminate
*
COPDFER2 L     R1,=A(ERRTX76)      Insert DDname into message
         MVC   15(8,R1),FCBDDNAM   .
         $ERR  DOP1,20,SAVE=YES,FLAG=NO  Tell user
         B     ADDSTATS            Terminate
         TITLE 'COPYDATA - End of file on INPUTn'
*---------------------------------------------------------------------+
*        EOF occurred on one of the INPUTn files                      |
*---------------------------------------------------------------------+
*
COPEOFIN NI    PCTF1,255-EXEC      Show exec in main pgm
         TM    PCTF3,FAST          FASTCOPY?
         BZ    COPEOFNR            No
         L     R2,PCT1FCB          Yes, save counters really quick
         ST    R7,FCBCOUNT-FCBDSECT(R2) Before we clobber them
         ST    R7,FCBCREC-FCBDSECT(R2)  .
         L     R7,PCT2FCB          .
         ST    R9,FCBCOUNT         .
         ST    R9,FCBCREC          .
         B     COPEOFNF            Skip filling record
*
COPEOFNR LH    R5,FCBLRECL         Get length of the record
         CLI   FCBDCB+17,X'4F'     Terminal file?
         BNE   *+10                No, continue
         MVC   FCBRECAD,ZEROS      Yes, pretend no buffer
         ICM   R4,15,FCBRECAD      Get address of record
         BNZ   COPEOFFL            Yes, go fill it with FF's
         LTR   R5,R5               No, got a length even?
         BNZ   *+8                 Yes, use it
         LH    R5,DCBHLREC         No, use our hi-water lrecl then
         GETMAIN R,LV=(R5)         Get area if we don't have one
         ST    R1,FCBRECAD         Save it's address
         LR    R4,R1               Now put in R4 and continue
*
COPEOFFL LR    R2,R4               Point at something
         SR    R3,R3               Clear length
         ICM   R3,8,PCTEOFFL       Pick up EOF fill character
         MVCL  R4,R2               Fill it
*
COPEOFNF OI    FCBF2,FCBEOF        Say we're at EOF
         MVC   PCTPGM,PCTPGMS      Correct resume address
         L     R14,PCTIPEOF        Get user's EOF address
         BR    R14
*
COPEOFER L     R2,=A(ERRTX38)      Point at error msg
         MVC   27(8,R2),FCBDDNAM   Stuff in DDname
         LH    R7,PCTLAST          Format STMNT # into msg
         CVD   R7,DBL              .
         UNPK  58(4,R2),DBL+5(3)   .
         OI    61(R2),X'F0'        .
         LH    R7,PCTLAST+2        Format WORD # into msg
         CVD   R7,DBL              .
         UNPK  72(3,R2),DBL+6(2)   .
         OI    74(R2),X'F0'        .
         $ERR  PEOF,12,GO=ADDSTATS,FLAG=NO Msg and terminate
         $PEND
         TITLE 'CPYIT put record to an Output file'
*---------------------------------------------------------------------+
*        Put selected records to the specified output file.           |
*---------------------------------------------------------------------+
*
CPYIT    $PROC
         STM   R0,R15,CPYSV        Save a few regs
         LR    R15,R14             Swap control reg
         TM    FCBF1,FCBOPEN       Already OPEN?
         BO    CPYOPEN             Yes, continue
*---------------------------------------------------------------------+
*        This  FCB isn't OPEN, must be a deferred one, OPEN it now    |
*---------------------------------------------------------------------+
         TM    FCBF2,FCBPDS        Is this FCB in PDS mode?
         BNO   CPYONOPN            No, skip
         MVC   FCBJFCB+44(8),PCTOMEMB Stuff in member name
         OI    FCBJFCB+86,X'01'    Flag as a member
         OI    FCBJFCB+52,X'08'    Don't re-write JFCB during OPEN
         $CALL JFCNAME,FCBDSECT    Go build a full dsname
         MVC   JFCB,FCBJFCB        Swap to common area
         LA    R2,FCBDCB           OPEN it now
         OPEN  ((R2),OUTPUT),TYPE=J .
         B     CPYOOPTS            Continue
*
CPYONOPN LA    R2,FCBDCB           Point at DCB
         OPEN  ((R2),OUTPUT)       Open the file
*
CPYOOPTS TM    FCBDCB+48,X'10'     O. K. ?
         BNO   CPYDOPR1            No, too bad
         OI    FCBF1,FCBOPEN+FCBSTATS Flag as open STATS allowed
         TM    FCBDCB+17,X'4F'     Is this a terminal file?
         BNO   *+16                No
         MVC   FCBDSNAM,BLANKS     Blank FCBDSNAM
         MVC   FCBDSNAM(8),=C'TERMFILE' And flag as terminal
         MVC   FCBLRECL,FCBDCB+DCBLRECL Save LRECL
         MVC   FCBOLREC,FCBLRECL
         MVC   FCBULREC,FCBLRECL
         MVC   FCBBLKSI,FCBDCB+DCBBLKSI BLKSIZE
         MVC   FCBRECFM,FCBDCB+DCBRECFM And RECFM
         MVC   FCBOBLK,FCBBLKSI
         MVC   FCBORECF,FCBRECFM
*
CPYSETR  $CALL SDCBROUT,(R7)       Go assign I/P - O/P route
         RDJFCB ((R2))             Go get JFCB again (after OPEN)
         LTR   R15,R15             O.K. ?
         BNZ   CPYDOPR1            No, error please
         MVC   FCBJFCB,JFCB        Save the JFCB again
         MVC   FCBNVOLS(31),FCBJFCB+JFCBNVOL-JFCB
         CLC   DDNAME,MDOUTP1+2    Is this OUTPUT1?
         BNE   CPYOPEN             No, just exit then
         ST    R7,PCT2FCB          Save address of OUTPUT1 FCB
         LA    R2,FCBDCB           Point at DCB itself
         ST    R2,PCT2DCB          Save it
*---------------------------------------------------------------------+
*        O.K. Now write the record                                    |
*---------------------------------------------------------------------+
*
CPYOPEN  LM    R0,R15,CPYSV        Reload regs
         LR    R15,R14             Swap control reg
         TM    FCBF1,FCBCLOSD      CLOSED?
         BO    BADIO               Yes, too bad!
         $INC  FCBCOUNT            Count the record
         $INC  FCBCREC             .
         OI    PCTF4,IODONE        Say we did some I/O
*        MVC   CPYULREC,FCBULREC   Save current ULREC
*
CPYTRACE TM    PCTF7,DBIOTRAC      I/O TRACE?
         BZ    CPYREAL             No
         MVC   LINE(6),=C'Output'  Move headings
         MVC   LINE+6(23),TRHD     .
         MVC   LINE+7(8),FCBDDNAM  Fill in data
         L     R1,FCBCREC          Get current record number
         CVD   R1,DBL
         ED    LINE+20(8),DBL+4    Edit record number into line
         MVI   LINE+20,C'('        Insert (
         BAL   R14,LINPRINT        Print line
         L     R15,CPYSV+56        Restore R15
*
CPYREAL  CLC   $SELLGTH,ZEROS      A LENGTH(...) override?
         BE    CPYUCHK             No
         MVC   FCBULREC,$SELLGTH+2 Swap in the override
*
CPYUCHK  CLC   FCBULREC,FCBOLREC   Has user created crappy LRECL?
         BH    CPYABND             Yes, fail him now
         EX    R0,FCBROUTE         Go to correct O/P route
*
CPYRFF   PUT   FCBDCB              Get std size O/P buffer area
         LR    R2,R1               O/P loc is gotten buffer
         LH    R3,FCBLRECL         O/P length is O/P LRECL
         L     R4,PCTOUTPT         I/P loc is standard buffer
         LR    R5,R3               I/P length is O/P LRECL
         B     CPYRR5T             Go do MVCL
*
CPYRFV   L     R5,PCTOBUFL         I/P length is lngth of O/P buffer
         L     R4,PCTOUTPT         I/P loc is standard buffer
         LH    R2,FCBULREC         See if user gave us an LRECL
         LTR   R2,R2               Zero (Not provided)
         BNZ   CPYRFVX             Non-zero, skip
         LA    R2,4(,R5)           Calc O/P length (including RDW)
         CH    R2,FCBOLREC         If length greater than O/P
         BNH   *+8                 Then set
         LH    R2,FCBOLREC         It to the output LRECL
*
CPYRFVX  STH   R2,FCBDCB+DCBLRECL  Stuff in O/P DCB
         PUT   FCBDCB              Get O/P buffer area
         STH   R2,0(R1)            Put O/P length in RDW
         LR    R3,R2               Calc O/P length for MVCL
         SH    R3,=H'4'            As (LRECL-RDW)
         MVC   2(2,R1),ZEROS       Complete RDW
         LA    R2,4(,R1)           O/P loc is standard + 4
         B     CPYRR5T             Go do MVCL
*
CPYRFU   L     R5,PCTOBUFL         I/P length is curr buff length
         LH    R3,FCBULREC         See if user gave us an LRECL
         LTR   R3,R3               Zero (Not provided)
         BNZ   CPYRFUX             Non-zero, skip
         LR    R3,R5               O/P length = I/P length
         CH    R3,FCBOLREC         If length greater than O/P
         BNH   *+8                 Then set
         LH    R3,FCBOLREC         It to the output LRECL
*
CPYRFUX  STH   R3,FCBDCB+DCBLRECL  Put length in FCBDCB
         PUT   FCBDCB              Get O/P area in buffer
         LR    R2,R1               O/P loc is gotten buffer
         L     R4,PCTOUTPT         I/P loc is standard buffer
         B     CPYRR5T             Go do MVCL
*
CPYRVF   PUT   FCBDCB              Get O/P area in buffer
         LR    R2,R1               O/P loc is gotten buffer
         LH    R3,FCBLRECL         O/P length is O/P LRECL
         L     R4,PCTOUTPT         Get normal I/P loc
         LH    R5,0(R4)            Get normal length of I/P record
         SH    R5,=H'4'            I/P length = standard - 4 (less RDW)
         LA    R4,4(,R4)           I/P loc = standard+4 (over RDW)
         B     CPYRR5T             Go do MVCL
*
CPYRVV   L     R4,PCTOUTPT         I/P loc is standard buffer
         LH    R3,FCBULREC         See if user gave us an LRECL
         LTR   R3,R3               Zero (Not provided)
         BNZ   CPYRVVX             Non-zero, skip
         LH    R3,0(R4)            O/P length = I/P RDW length
         CH    R3,FCBOLREC         If length greater than O/P LRECL
         BNH   *+8                 Then set
         LH    R3,FCBOLREC         It to the output LRECL
*
CPYRVVX  STH   R3,0(R4)            Stuff altered length in RDW
         STH   R3,FCBDCB+DCBLRECL  Stuff LRECL in FCBDCB
         PUT   FCBDCB              Get O/P area in buffer
         LR    R2,R1               O/P loc is gotten buffer
         LR    R5,R3               I/P length = O/P length
         B     CPYRR5T             Go do MVCL
*
CPYRVU   L     R4,PCTOUTPT         Get standard I/P loc
         LH    R3,FCBULREC         See if user gave us an LRECL
         LTR   R3,R3               Zero (Not provided)
         BNZ   CPYRVUX             Non-zero, skip
         LH    R3,0(R4)            Get I/P RDW length
         SH    R3,=H'4'            O/P length = I/P RDW - 4 (less RDW)
         CH    R3,FCBOLREC         If length greater than O/P
         BNH   *+8                 Then set
         LH    R3,FCBOLREC         It to the output LRECL
*
CPYRVUX  STH   R3,FCBDCB+DCBLRECL  Stuff length in FCBDCB
         PUT   FCBDCB              Get O/P area in buffer
         LR    R2,R1               O/P loc is gotten buffer
         LA    R4,4(,R4)           I/P loc is standard + 4 (less RDW)
         LR    R5,R3               I/P length is I/P RDW - 4 (less RDW)
         B     CPYRR5T
*
CPYRUF   EQU   CPYRFF              Ditto logic for CPYRFF
*
CPYRUV   EQU   CPYRFV              Ditto logic for CPYRFV
*
CPYRUU   EQU   CPYRFU              Ditto logic for CPYRFU
*
CPYRR5T  TM    PCTF7,DBDUMP        DEBUG DUMP on?
         BZ    CPYRR5M             No
         STCM  R4,15,TRADDR        Set dump addresses
         STCM  R3,15,TRLGTH        and length
         LA    R14,TRFLAG-1        Fudge R15(R14)
         $CALL DMPIT               Go dump record
*
CPYRR5M  ICM   R5,8,PCTPADCH       Stuff in fill char
         MVCL  R2,R4               Do the move
*        MVC   FCBULREC,CPYULREC   Restore user's LRECL for this file
         MVC   FCBULREC,ZEROS      Reset the User's LRECL to zero
         LM    R0,R15,CPYSV        Restore regs
         $RET  0                   Go back
*
CPYABND  $ERR  LRECX,16,FLAG=NO    Issue error msg
         ABEND 16                  Force User abend
*
CPYDOPR1 L     R1,=A(ERRTX76)      Insert DDname into message
         MVC   15(8,R1),FCBDDNAM   .
         $ERR  DOP1,20,SAVE=YES,FLAG=NO  Tell user
         B     ADDSTATS            Terminate
*
CPYULREC DC    H'0'
         EJECT
*---------------------------------------------------------------------+
* DCBRTBL   -  Copy routine select table                              |
*                                                                     |
*              1st byte has RECFM bits of INPUT1                      |
*              2nd byte has RECFM bits of output anynameDD            |
*              B instr. following is ultimately executed              |
*---------------------------------------------------------------------+
DCBRTBL  DS    0F
         DC    X'C0C0'
         B     CPYRUU
         DC    X'C080'
         B     CPYRFU
         DC    X'C040'
         B     CPYRVU
         DC    X'C000'
         B     CPYRUU
         DC    X'80C0'
         B     CPYRUF
         DC    X'8080'
         B     CPYRFF
         DC    X'8040'
         B     CPYRVF
         DC    X'8000'
         B     CPYRUF
         DC    X'40C0'
         B     CPYRUV
         DC    X'4080'
         B     CPYRFV
         DC    X'4040'
         B     CPYRVV
         DC    X'4000'
         B     CPYRUV
         DC    X'00C0'
         B     CPYRUU
         DC    X'0080'
         B     CPYRFU
         DC    X'0040'
         B     CPYRVU
DCBRTBLE EQU   *
         DC    X'0000'                     Default entry
         B     CPYRUU
         $PEND
         TITLE 'CVOTOFCB - Get FCB address for sub-operand'
*---------------------------------------------------------------------+
*        Convert a sub-operand to an FCB address in OPGBASE           |
*        ==================================================           |
*                                                                     |
*        Called:   $CALL CVOTOFCB,operand                             |
*                                                                     |
*        Operands: operand  - Pointer to a standard sub-operand       |
*                             area. (See OPRDSECT for layout          |
*                                                                     |
*        Returns:  +0 if unable to complete successfully              |
*                  +4 if completed O.K.                               |
*                                                                     |
*                  If O.K. OPGBASE has been completed.                |
*---------------------------------------------------------------------+
*
CVOTOFCB $PROC 1
         USING OPRDSECT,R3
         L     R3,12(R8)
         TM    OPRF2,OPRNUM        Numeric?
         BNO   CVOOPDD             No, try as an O/P DD
         CLC   PREFL,=H'6'         Correct length for INPUTn
         BNE   CVOOPDD             No, treat as O/P DD
         CLC   OPRL(8),MDINPT1     INPUT1?
         BE    CVOIPGO             Yes, treat as I/P then
         CLC   OPRTXT(5),=C'INPUT' INPUTn?
         BE    CVOIPGO             Yes, treat as I/P then
         B     CVOOPDD             Better be O/P then
*
CVOIPGO  L     R1,OPRNUM1          Load number then
         CH    R1,=H'9'            Test against max
         BH    CVOEX0              Sorry
         CH    R1,=H'1'            Test against Min
         BL    CVOEX0              Error if zero or neg
         STC   R1,OPGBASE          Stuff file number in
         OI    PCTF3,INPUT         Official Input file
*
CVOIPDD  $CALL DCBI1BLD,PREFL      Go get FCB address
         B     BADDCB              +0 Verrrry sorrrry
         NI    PCTF3,255-INPUT     +4 Remove flag
         B     CVOSVAD             Go save address
*
CVOOPDD  $CALL DCBO1BLD,PREFL      Go get FCB address
         B     BADDCB              +0 Verrrry sorrrry
         MVI   OPGBASE,X'0A'       +4 Insert pseudo file number 10
*
CVOSVAD  STCM  R1,7,OPGBASE+1      Save in code
CVOEX4   $RET  4                   And exit
*
CVOEX0   $RET  0                   Return with error
         DROP  R3
         $PEND
         TITLE 'DBGADD - Add TRACE DEBUG code'
*---------------------------------------------------------------------+
*        Add TRACE logic to the compiled program                      |
*---------------------------------------------------------------------+
*
DBGADD   $PROC
         ZAP   DBL,GETCTR1         Convert
         CVB   R1,DBL              Stmnt # to binary
         STH   R1,DBGMSNO          Stuff in model code
         ZAP   DBL,GETCTR2         Do also the word number
         CVB   R1,DBL
         STH   R1,DBGMWNO          Save it
         $ADD  DBGM999-DBGMADR,DBGMADR Stuff it in pgm
         $RET  0                   Return
*---------------------------------------------------------------------+
*        DEBUG routine model code                                     |
*---------------------------------------------------------------------+
DBGMADR  BAL   R14,TRACE           Go to TRACE (Returns +4)
DBGMSNO  DC    XL2'00'             Stmnt #
DBGMWNO  DC    XL2'00'             Word #
DBGM999  EQU   *
         $PEND
         TITLE 'DCBx1BLD - Build I/O control blocks'
*---------------------------------------------------------------------+
*        Prepare control blocks for an input or output file           |
*---------------------------------------------------------------------+
*
DCBI1BLD $PROC 1
         NI    PCTF6,255-OUTPUT    Set to input processing
         L     R2,12(R8)           Pick up pointer to 'word'
         $CALL DCBCBLD             Perform common logic
         B     DCBI1RT0            If returned +0 then also return +0
         $RET  4                   Return +4 if returned to +4
*
DCBI1RT0 $RET  0                   Return +0
         $PEND
*
DCBO1BLD $PROC 1
         OI    PCTF6,OUTPUT        Set to output processing
         L     R2,12(R8)           Pick up pointer to 'word'
         $CALL DCBCBLD             Perform common logic
         B     DCBO1RT0            If returned +0 then also return +0
         $RET  4                   Return +4 if returned to +4
*
DCBO1RT0 $RET  0                   Return +0
         $PEND
*
DCBCBLD  $PROC
         MVC   DDNAME,BLANKS       Blank DDname
         LH    R1,0(R2)            Get length of DDname
         BCTR  R1,0                -1 for EX
         EX    R1,*+4              Move it
         MVC   DDNAME(0),2(R2)     .
         LA    R3,PCTFCB           Load address of start of FCB chain
*
DCBCCHLP ICM   R7,15,0(R3)         Load next FCB address
         BZ    DCBCEOCH            End of chain?, go add one to it
         CLC   DDNAME,FCBDDNAM     See if we have this DDname already
         BNE   DCBCCHN             No, try the next FCB
*---------------------------------------------------------------------+
*        The FCBINPUT/FCBOUTPT can only be off if this FCB was        |
*        created by an OPTIONS DEFER(ddname) request (which of course |
*        has no way of knowing whether its INPUT or OUTPUT)           |
*---------------------------------------------------------------------+
         TM    FCBF2,FCBINPUT+FCBOUTPT I/O mode already set?
         BNZ   DCBTMODE            Yes, make sure we match
         TM    PCTF6,OUTPUT        No, set it then
         BO    *+12                .
         OI    FCBF2,FCBINPUT      .
         B     DCBCEOCH            .
         OI    FCBF2,FCBOUTPT      .
         B     DCBCEOCH            Go fill in more of the FCB
*
DCBTMODE TM    PCTF6,OUTPUT        Asked for as output?
         BZ    DCBCICHK            No, input, see if thats what it is
         TM    FCBF2,FCBOUTPT      Yes, is FCB output?
         BZ    DCBCBDMD            No, bad mode then
         B     DCBCCHEX            Yes, exit then
*
DCBCICHK TM    FCBF2,FCBINPUT      FCB better be input
         BO    DCBCCHEX            Yes, we can exit
*
DCBCCHEX LR    R1,R7               Yes, put FCB address in R1
         $RET  4                   And return +4
*
DCBCBDMD $ERR  BADMD,8,SKIP        Issue error message
*
DCBCCHN  LR    R3,R7               Setup for chaining
         B     DCBCCHLP            And try again
*---------------------------------------------------------------------+
*        Fill in an FCB                                               |
*---------------------------------------------------------------------+
*
DCBCEOCH DEVTYPE DDNAME,DEVTAB     Get device type of DDname
         LTR   R15,R15             O.K. ?
         BNZ   DCBCER1             No
         LTR   R7,R7               Are we here cause no FCB exists?
         BZ    DCBCGMIT            Right, go get an FCB
         TM    FCBF1,FCBDOPEN      Deferred OPEN type?
         BO    DCBCFFCB            Yes, also don't need GETMAIN
         TM    FCBF2,FCBPDS        Or PDSMODE type?
         BO    DCBCFFCB            Yes, also don't need GETMAIN
*
DCBCGMIT LA    R0,FCBLNGTH         Set length for GETMAIN
         GETMAIN R,LV=(0)          Get an FCB area
         LR    R7,R1               Put address of FCB in R7
         ST    R7,0(R3)            Add to FCB chain
         MVI   FCBCHAIN,X'00'      Zero area
         MVC   FCBCHAIN+1(FCBDSNAM-FCBDSECT),FCBCHAIN
         MVC   FCBDDNAM,DDNAME     Insert DDname
         OI    FCBF1,FCBSTATS      Allow STATS at least once
         NI    PCTF3,255-DCBOPT    DCB no longer optional
*
DCBCFFCB L     R2,=A(MDLSODCB)     Point at any old DCB
         MVC   DCBDDNAM(8,R2),DDNAME Set DDname in DCB
         RDJFCB ((R2))             Go get JFCB (if present)
         LTR   R15,R15             O.K. ?
         BNZ   DCBIER1             No, error please
         MVC   FCBJFCB,JFCB        Save the JFCB
         $CALL JFCNAME,FCBDSECT    Go build full dsname
         MVC   FCBRECFM,JFCRECFM   Set in JFCB values
         MVC   FCBLRECL,JFCLRECL   .
         MVC   FCBBLKSI,JFCBLKSI   .
         MVC   FCBDSORG,JFCDSORG   Save DSORG in FCB
*
DCBCIOSW TM    PCTF6,OUTPUT        Building output blocks?
         BO    DCBCOSET            Yes, go there to complete it
         $CALL DCBI2BLD            Input, go finish there
         B     DCBCRT0             If returned +0 then also return +0
         $RET  4                   Return +4 if returned to +4
*
DCBCER1  TM    PCTF3,DCBOPT        Is DDname optional?
         BO    DCBCER1X            Yes, don't issue error message
         L     R1,=A(ERRTX33)      Point at error message
         MVC   4(8,R1),DDNAME      Move in DDname
         $ERR  NOUT,12,SAVE=YES    No, kill
*
DCBCER1X NI    PCTF3,255-DCBOPT    Remove DCBOPT flag now
         $RET  0                   Return +0 for error
*
DCBCRT0  $RET  0                   Return +0
*
DCBCOSET $CALL DCBO2BLD            Go complete as output file
         B     DCBCRT0             If returned +0 then also return +0
         $RET  4                   Return +4 if returned to +4
         $PEND
         EJECT
*---------------------------------------------------------------------+
*        Common preparation done, now complete as an input file       |
*---------------------------------------------------------------------+
*
DCBI2BLD $PROC
         CLI   DEVTAB+2,X'20'      DASD device?
         BNE   DCBIUTS             No, then its got to be seq.
         OBTAIN OBTCMLST,EADSCB=OK Yes, then go get it's DSCB
         LTR   R15,R15             O.K. ?
         BNZ   DCBIER2             No, verry sorry
         L     R1,OBTCMLST+12      Get DSCB address
         MVC   FCBDSORG,DS1DSORG-44(R1) Save DSORG from DSCB
         CLC   FCBRECFM,ZEROS      Any RECFM yet?
         BNE   *+10
         MVC   FCBRECFM,DS1RECFM-44(R1) Save RECFM from DSCB
         CLC   FCBLRECL,ZEROS      Any LRECL yet?
         BNE   *+10
         MVC   FCBLRECL,DS1LRECL-44(R1) Save LRECL from DSCB
         CLC   FCBBLKSI,ZEROS      Any BLKSI yet?
         BNE   *+10
         MVC   FCBBLKSI,DS1BLKSI-44(R1) Save BLKSI from DSCB
*
DCBIUTS  L     R2,=A(MDLSIDCB)     Point at QSAM DCB
*
DCBIMV   MVC   FCBDCB,0(R2)        Move DCB into the FCB
         OI    FCBF2,FCBINPUT      Flag as input DCB
         MVC   FCBDCB+DCBDDNAM(8),FCBDDNAM
         TM    PCTF3,INPUT         An official input file?
         BZ    DCBIOPEN            No, just go open it
         NI    PCTF3,255-INPUT     Yes, reset it then
         CLC   FCBDDNAM,MDINPT1+2  Validate DDname
         BE    DCBITPO             .
         CLC   FCBDDNAM(5),=C'INPUT'
         BNE   DCBIBDD             .
         CLC   FCBDDNAM+6(2),BLANKS
         BNE   DCBIBDD             .
         CLI   FCBDDNAM+5,C'2'     .
         BL    DCBIBDD             .
         TM    FCBDDNAM+5,X'F0'    .
         BNO   DCBIBDD             .
         OI    PCTF1,IPCOPY        Treat as I/P copy run
         B     DCBICNVT            Continue
*
DCBITPO  TM    PCTF8,PDSMODE       Was PDSMODE specified?
         BZ    DCBICNVT            No, skip all this
         CLC   FCBJFCB+44(8),BLANKS A Member name?
         BNE   DCBICNVT            Yes, leave as sequential
         TM    FCBDSORG,X'02'      PO dataset?
         BZ    DCBICNVT            No, leave as sequential
         OI    FCBF2,FCBPDS        Yes, mark for PDSMODE processing
         $CALL DIRREAD             then read PDS Directory
         B     DCBITR0             +0 Error reading directory
*
DCBICNVT IC    R2,FCBDDNAM+5       Convert it
         N     R2,=X'0000000F'     .
         STH   R2,FCBFILNO         And save in FCB
         SLL   R2,2                x 4
         LA    R1,PCTINPT1-4(R2)   Point at PCT record address area
         ST    R1,FCBRECPT         Save its address
         LA    R1,PCTINPL1-4(R2)   Point at PCT record length area
         ST    R1,FCBLENPT         Save its address
         SR    R1,R1               Clear reg
         ST    R1,FCBRECAD         Clear record address field
         B     DCBIOPEN            Now go open it
*
DCBIBDD  $ERR  MAXI,12,GO=DCBIER1X Sorry, you get a message
         EJECT
*---------------------------------------------------------------------+
*        Open input DCB and save some data about it                   |
*---------------------------------------------------------------------+
*
DCBIOPEN TM    FCBF1,FCBDOPEN      Deferred OPEN?
         BO    DCBIEX              Yes, skip this stuff for now
         TM    PCTF8,PDSMODE       PDSMODE?
         BZ    DCBINRM             No, normal OPEN
         CLC   FCBDDNAM,MDINPT1+2  INPUT1 DDname
         BNE   DCBINRM             No, skip
         TM    PCTF8,PDSEMPTY      Is INPUT1 empty of members?
         BO    DCBIEX              Skip the OPEN
         L     R2,PCTMEMBC         Get current 'member' name
         MVC   FCBJFCB+44(8),0(R2) Stuff in member name
         MVC   PCTIMEMB,0(R2)      Stuff as global I/P member
         MVC   PCTOMEMB,0(R2)      Stuff in global O/P member
         LA    R2,8(,R2)           Bump
         ST    R2,PCTMEMBC         Save back for next time
         OI    FCBJFCB+86,X'01'    Flag as a member
         OI    FCBJFCB+52,X'08'    Don't re-write JFCB during OPEN
         $CALL JFCNAME,FCBDSECT    Go build a full dsname
         MVC   JFCB,FCBJFCB        Swap to common area
         LA    R2,FCBDCB           OPEN it now
         OPEN  ((R2),INPUT),TYPE=J .
         B     DCBIOPNT            Continue
*
DCBINRM  LA    R2,FCBDCB           Point at DCB
         OPEN  ((R2),INPUT)        And open it
*
DCBIOPNT TM    48(R2),X'10'        Open O.K. ?
         BNO   DCBIER3             Yes
         OI    FCBF1,FCBOPEN+FCBSTATS Flag as open STATS allowed
         TM    FCBDCB+17,X'4F'     Is this a terminal file?
         BNO   *+16                No
         MVC   FCBDSNAM,BLANKS     Blank FCBDSNAM
         MVC   FCBDSNAM(8),=C'TERMFILE' And insert termfile
         LH    R1,FCBDCB+DCBLRECL  Save DCBDATA
         STH   R1,FCBLRECL
         STH   R1,FCBOLREC
         LH    R1,FCBDCB+DCBBLKSI
         STH   R1,FCBBLKSI
         STH   R1,FCBOBLK
         MVC   FCBRECFM,FCBDCB+DCBRECFM
         MVC   FCBORECF,FCBRECFM
         CLC   DCBHLREC,FCBLRECL   New high LRECL ??
         BNL   *+10                Still O. K.
         MVC   DCBHLREC,FCBLRECL   Save the new high value
         MVC   FCBNVOLS(31),FCBJFCB+JFCBNVOL-JFCB
*
DCBIEX   LR    R1,R7               Pass FCB address back in R1
         $RET  4                   Return +4, all O.K.
*
DCBIER1  TM    PCTF3,DCBOPT        Is DDname optional?
         BO    DCBIER1X            Yes, don't issue error message
         L     R1,=A(ERRTX33)      Point at error message
         MVC   4(8,R1),DDNAME      Move in DDname
         $ERR  NOUT,12,SAVE=YES    No, kill
*
DCBIER1X NI    PCTF3,255-DCBOPT    Remove DCBOPT flag now
*
DCBITR0  $RET  0                   Return +0 for error
*
DCBIER2  L     R1,=A(ERRTX34)      Point at error message
         MVC   19(8,R1),DDNAME     Insert DDname
         $ERR  DSUT,12,SAVE=YES    No, kill the step
         $RET  0                   Return +0 for error
*
DCBIER3  L     R1,=A(ERRTX29)      Point at error text
         MVC   17(8,R1),DDNAME     Stuff in DDname
         $ERR  ODCB,12,SAVE=YES    No, issue err msg
         $RET  0                   Return +0 for error
         $PEND
         EJECT
*---------------------------------------------------------------------+
*        Common preparation done, now complete as an output file      |
*---------------------------------------------------------------------+
*
DCBO2BLD $PROC
         OI    FCBF2,FCBOUTPT      Flag as output FCB
         L     R2,=A(MDLSODCB)     Point at model sequential DCB
         CLI   DEVTAB+2,X'20'      Is it DASD?
         BNE   DCBOMV              No, must be seq
         OBTAIN OBTCMLST,EADSCB=OK Yes, then go get it's DSCB
         LTR   R15,R15             O.K. ?
         BNZ   DCBOER2             No, verry sorry
         L     R1,OBTCMLST+12      Get DSCB address
         MVC   FCBDSORG,DS1DSORG-44(R1) Save DSORG from DSCB
         TM    PCTF8,PDSMODE       Was PDSMODE specified?
         BZ    DCBOMV              No, skip all this
         CLC   FCBJFCB+44(8),BLANKS A Member name?
         BNE   DCBOMV              Yes, leave as sequential
         TM    FCBDSORG,X'02'      PO dataset?
         BZ    DCBOMV              No, leave as sequential
         OI    FCBF2,FCBPDS        Yes, mark for PDSMODE processing
         OI    FCBF1,FCBDOPEN      and set FCB to deferred OPEN
         B     DCBOMV              Continue
*
DCBOMV   MVC   FCBDCB,0(R2)        Move in model output DCB
         MVC   FCBDCB+DCBDDNAM(8),FCBDDNAM
         TM    FCBF1,FCBDOPEN      Deferred OPEN ?
         BO    DCBORETN            Yes, skip this for now
         LA    R2,FCBDCB           Point at DCB
         OPEN  ((R2),OUTPUT)       Open the file
         TM    FCBDCB+48,X'10'     O. K. ?
         BNO   DCBOER3             No, too bad
         OI    FCBF1,FCBOPEN+FCBSTATS Flag as open STATS allowed
         TM    FCBDCB+17,X'4F'     Is this a terminal file?
         BNO   *+16                No
         MVC   FCBDSNAM,BLANKS     Blank FCBDSNAM
         MVC   FCBDSNAM(8),=C'TERMFILE' And flag as terminal
         MVC   FCBLRECL,FCBDCB+DCBLRECL Save LRECL
         MVC   FCBOLREC,FCBLRECL
         MVC   FCBBLKSI,FCBDCB+DCBBLKSI BLKSIZE
         MVC   FCBRECFM,FCBDCB+DCBRECFM And RECFM
         MVC   FCBOBLK,FCBBLKSI
         MVC   FCBORECF,FCBRECFM
         CLC   DEFLRECL,ZEROS      Got a default LRECL yet?
         BE    DCBOSETR            No, skip
         CLC   DCBHLREC,FCBLRECL   New high LRECL ??
         BNL   DCBOSETR            Still O. K.
         MVC   DCBHLREC,FCBLRECL   Save the new high value
         CLC   FCBLRECL,DEFLRECL   Is this LRECL > DEFLRECL?
         BNH   DCBOSETR            No, continue
         OI    PCTF1,IPCOPY        Yes, force 2 buffers
*
DCBOSETR $CALL SDCBROUT,(R7)       Go assign I/P - O/P route
         RDJFCB ((R2))             Go get JFCB again (after OPEN)
         LTR   R15,R15             O.K. ?
         BNZ   DCBOER3             No, error please
         MVC   FCBJFCB,JFCB        Save the JFCB again
         MVC   FCBNVOLS(31),FCBJFCB+JFCBNVOL-JFCB
         CLC   DDNAME,MDOUTP1+2    Is this OUTPUT1?
         BNE   DCBORETN            No, just exit then
         ST    R7,PCT2FCB          Save address of OUTPUT1 FCB
         LA    R2,FCBDCB           Point at DCB itself
         ST    R2,PCT2DCB          Save it
*
DCBORETN LR    R1,R7               Pass FCB address back in R1
         $RET  4                   Return now
*
DCBOER1  TM    PCTF3,DCBOPT        Is DDname optional?
         BO    DCBOER1X            Yes, don't issue error message
         L     R1,=A(ERRTX33)      Point at error message
         MVC   4(8,R1),DDNAME      Move in DDname
         $ERR  NOUT,12,SAVE=YES    No, kill
*
DCBOER1X NI    PCTF3,255-DCBOPT    Remove DCBOPT flag now
         $RET  0                   Return +0 for error
*
DCBOER2  L     R1,=A(ERRTX34)      Point at error message
         MVC   19(8,R1),DDNAME     Insert DDname
         $ERR  DSUT,12,SAVE=YES    No, kill the step
         $RET  0                   Return +0 for error
*
DCBOER3  L     R1,=A(ERRTX29)      Point at error text
         MVC   17(8,R1),DDNAME     Stuff in DDname
         $ERR  ODCB,12,SAVE=YES    No, issue err msg
         $RET  0                   Return +0 for error
         $PEND
         TITLE 'DEBUG - Command processor'
*---------------------------------------------------------------------+
*        D E B U G    C o m m a n d   P r o c e s s o r               |
*---------------------------------------------------------------------+
*
DEBUG    $PROC
         USING KWDSECT,R14
         MVC   PCTPOPLS,ZEROS      Clear last POP'ed address
         TM    PCTF2,DSYSPRT       Better have a SYSPRINT DD then
         BZ    BADSYSPR            No, velly sully!
*---------------------------------------------------------------------+
*        Loop for each DEBUG operand                                  |
*---------------------------------------------------------------------+
*
DEBLOOP  $CALL GETNEXT             Go get next word
         CLC   WORDL,=H'0'         End of sentence?
         BE    EXITGOK             Yes, exit
         TM    WFLAG1,WPREF+WTRLR  Invalid format?
         BNZ   BADOPTYP            Yes, kill it
         TM    WRD1F2,OPRKW+OPRKWV+OPRKWOP+OPRKWOPV Valid KW(...)?
         BNO   BADKWORD            No, kill it
         LA    R14,WRD1KW1         Point at KW answer area
         TM    KWF1,KWOPRAND       A valid type?
         BZ    BADKWORD            No, sorry
         MVN   KWNUM,=X'00'        Clear lo-order nibble
         CLI   KWNUM,X'60'         Valid debug KW?
         BNE   BADKWORD            No, sorry
         L     R2,KWD2             Get address of routine
         BR    R2                  Branch by type
*---------------------------------------------------------------------+
*        Process the IOTRACE(..) operand                              |
*---------------------------------------------------------------------+
*
DEBIOTR  $CALL DBGADD              Go add DEBUG code
         LA    R14,WRD1KW2         Point at KW answer area for sub-op
         L     R2,KWD2             Get type index
         B     *(R2)               Branch by type
         B     DEBIOTON            ON
         B     DEBIOTOF            OFF
         B     DEBIOTIN            INIT
*
DEBIOTON $ADD  4,DEBMITON          Add code
         B     DEBLOOP             Keep on truckin'
*
DEBIOTOF $ADD  4,DEBMITOF          Add code
         B     DEBLOOP             Keep on truckin'
*
DEBIOTIN OI    PCTF7,DBIOTRAC      Turn on I/O trace right now
         B     DEBLOOP             Keep on truckin'
*---------------------------------------------------------------------+
*        Process the IODUMP(...) operand                              |
*---------------------------------------------------------------------+
*
DEBIODM  $CALL DBGADD              Go add DEBUG code
         LA    R14,WRD1KW2         Point at KW answer area for sub-op
         L     R2,KWD2             Get type index
         B     *(R2)               Branch by type
         B     DEBIODON            ON
         B     DEBIODOF            OFF
         B     DEBIODIN            INIT
*
DEBIODON $ADD  4,DEBMIDON          Add code
         B     DEBLOOP             Keep on truckin'
*
DEBIODOF $ADD  4,DEBMIDOF          Add code
         B     DEBLOOP             Keep on truckin'
*
DEBIODIN OI    PCTF7,DBIOTRAC+DBDUMP Turn on I/O trace & dump now
         B     DEBLOOP             Keep on truckin'
*---------------------------------------------------------------------+
*        Process the TRACE(....) operand                              |
*---------------------------------------------------------------------+
*
DEBTRAC  $CALL DBGADD              Go add DEBUG code
         LA    R14,WRD1KW2         Point at KW answer area for sub-op
         L     R2,KWD2             Get type index
         B     *(R2)               Branch by type
         B     DEBTRON             ON
         B     DEBTROF             OFF
         B     DEBTRIN             INIT
*
DEBTRON  $ADD  4,DEBMTRON          Add code
         B     DEBLOOP             Keep on truckin'
*
DEBTROF  $ADD  4,DEBMTROF          Add code
         B     DEBLOOP             Keep on truckin'
*
DEBTRIN  OI    PCTF7,DBTRACE       Turn on Trace now
         B     DEBLOOP             Keep on truckin'
*---------------------------------------------------------------------+
*        Process the SUPPORT(ON) operand                              |
*---------------------------------------------------------------------+
*
DEBSUPP  LA    R14,WRD1KW2         Point at KW answer area for sub-op
         CLC   KWD2,=F'4'          'ON'
         BNE   BADKWVAL            No, sorry
         ICM   R1,15,PGMIC         A program started?
         BNZ   DEBSUPER            Yes, sorrry!
         L     R1,=A(ABNDFORC)     Let abends complete
         OI    1(R1),X'F0'         .
         L     R15,=A(MAINETRC)    Point at flag
         NI    1(R15),X'0F'        Force snap of program area
         GETMAIN R,LV=400          Get a support table area
         MVC   0(4,R1),HEXFFS      Stuff in delimiter
         ST    R1,PCTSUPP1         Save its address
         ST    R1,PCTSUPP2         ... Twice
         B     DEBLOOP             Keep on truckin'
*
DEBSUPER $ERR  SUPER,8,SKIP        Kill it
         EJECT
*---------------------------------------------------------------------+
*        DEBUG  routine work areas                                    |
*---------------------------------------------------------------------+
*
DEBMITOF NI    PCTF7,255-DBIOTRAC-DBDUMP Turn off I/O trace and dump
DEBMITON OI    PCTF7,DBIOTRAC      Turn on I/O trace
DEBMIDON OI    PCTF7,DBIOTRAC+DBDUMP Turn on I/O trace and dump
DEBMIDOF NI    PCTF7,255-DBDUMP    Turn off I/O dump
DEBMTRON OI    PCTF7,DBTRACE       Turn on logic trace
DEBMTROF NI    PCTF7,255-DBTRACE   Turn off logic trace
         DROP  R14
         $PEND
         TITLE 'DIRREAD - Read PDS Directory into memory'
*---------------------------------------------------------------------+
*        In PDSMODE, Read INPUT1 Directory                            |
*---------------------------------------------------------------------+
*
DIRREAD  $PROC
         MVC   DIRINPUT+DCBDDNAM(8),MDINPT1+2 Pick up correct DDNAME
         OPEN  (DIRINPUT,INPUT)    OPEN directory
         TM    DIRINPUT+48,X'10'
         BZ    DIROERR             No good, error message
         SR    R2,R2               Count Dir blocks
*
DIRLOOP1 GET   DIRINPUT            Get a block
         LA    R2,1(,R2)           Count it
         B     DIRLOOP1            Loop
*
DIREOD1  CLOSE DIRINPUT            Close
         MVC   DIRINPUT+DCBEODAD(3),=AL3(DIREOD2) Swap EOD address
         OPEN  (DIRINPUT,INPUT)    Start over
         LA    R2,1(,R2)           Insurance space
         MH    R2,=H'160'          8 * (# membs / block) = table size
         GETMAIN R,LV=(R2)         Get a member storage area
         ST    R1,PCTMEMBT         Save its address
         ST    R1,PCTMEMBC         and as 'current'
         LR    R2,R1               Work Reg
*
DIRLOOP2 GET   DIRINPUT            Get a record
         LH    R3,0(R1)            Pickup length of data in block
         AR    R3,R1               Create ptr to last+1
         LA    R4,2(R1)            Point at 1st members dir data
*
DIRCEOF  CLC   0(8,R4),=8X'FF'     End of directory
         BE    DIREOD2             Yes, end list
         TM    11(R4),X'80'        ALIAS name?
         BO    DIRCNEXT            Yes, skip it
         MVC   0(8,R2),0(R4)       No, save in table
         LA    R2,8(,R2)           Bump to next location
*
DIRCNEXT IC    R1,11(R4)           And step to next member in dir
         N     R1,=X'0000001F'     Clear rubbish bits to leave length
         SLL   R1,1                Convert from Hwords to bytes
         LA    R4,12(R4,R1)        Step to next dir location
         CR    R4,R3               Check against last location
         BNL   DIRLOOP2            If block done, go get another
         B     DIRCEOF             Go check for logical EOF
*
DIREOD2  MVC   0(8,R2),=8X'FF'     Terminate member list
         CLOSE (DIRINPUT)          Close Directory
         FREEPOOL DIRINPUT         Free its buffers
         C     R2,PCTMEMBT         Empty directory?
         BE    DIREMPTY            Yes, kill it
         $RET  4                   Return O.K.
*
DIROERR  L     R1,=A(ERRTX29)      Point at error text
         MVC   17(8,R1),MDINPT1+2  Stuff in DDname
         $ERR  ODCB,12,SAVE=YES    No, issue err msg
         $RET  0                   Return +0 for error
*
DIREMPTY $ERR  PEMPT,8,SAVE=YES,FLAG=NO Issue err msg
         OI    PCTF8,PDSEMPTY      Remember we're empty
         $RET  4                   Continue RC=8 will cause termnate
*
DIRINPUT DCB   DDNAME=INPUT1,DSORG=PS,EODAD=DIREOD1,MACRF=GL,          X
               RECFM=F,LRECL=256,BLKSIZE=256
         $PEND
         TITLE 'DMPIT - Dump selected record to SYSPRINT'
*---------------------------------------------------------------------+
*        Print output record in the requested format                  |
*---------------------------------------------------------------------+
*
DMPIT    $PROC
         STM   R0,R15,DMPSV        Save regs in DMPSV
         LR    R15,R14             Put ctl reg back in R15
         NOP   DMPGO               First time sw
         OI    *-3,X'F0'           Set it
         MVC   LINHDA3,=A(LINHD3)  Swap page heads
         ZAP   LINECT,=P'1'        Force new page
*
DMPGO    ZAP   NEEDCNT,=P'1'       See how many lines needed
         TM    $SELF1,CHAR         CHAR?
         BZ    *+10                No
         AP    NEEDCNT,=P'1'       +1
         TM    $SELF1,HEX          HEX?
         BZ    *+10                No
         AP    NEEDCNT,=P'2'       +2
         MVC   LINE(6),=C'Record'  Setup ident info
         MVC   LINE+15(6),=C'Length'
         L     R1,PCTCOUNT         Get record number
         CVD   R1,DBL              Convert it
         MVC   LINE+6(8),=X'4020202020202120'
         ED    LINE+6(8),DBL+4
         L     R1,PCTOUTPT         Get address of rec to print
         MVC   DMPLRECL,PCTOBUFL+2 Put length in work field
         TM    DEFRECFM,X'80'      Fixed or undefined?
         BO    DMPSEETR            Yes, see if overridden
         TM    DEFRECFM,X'40'      Variable?
         BNO   DMPSEETR            No, skip
         MVC   DMPLRECL,0(R1)      Yes, use RDW length
*
DMPSEETR TM    $SELF1,SPTR         Special IODUMP request
         BZ    DMPSEELN            No, see if LENGTH(...) override
         ICM   R1,15,TRADDR        Yes, get alternate address
         MVC   DMPLRECL,TRLGTH+2   and get alternate length
         B     DMPSTADD            Go process with these values
*
DMPSEELN CLC   $SELLGTH,ZEROS      An override?
         BE    DMPSTADD            No, continue
         MVC   DMPLRECL,$SELLGTH+2 Yes, copy it
*
DMPSTADD ST    R1,DMPADDR          Put address of rec in work field
         CLC   DMPLRECL,DCBHLREC   Over absolute max LRECL?
         BNH   *+10                No, continue
         MVC   DMPLRECL,DCBHLREC   Yes, set it to max
         LH    R1,DMPLRECL         Get length of record
         CVD   R1,DBL              Convert it
         MVC   LINE+24(6),=X'402020202120'
         ED    LINE+24(6),DBL+5
*
DMPFMTLP CP    NEEDCNT,LINECT      Enough lines left on page?
         BL    *+10                Yes, continue
         ZAP   LINECT,=P'1'        No, force page head
         TM    $SELF1,CHAR         Is CHAR dump wanted?
         BZ    DMPNOCH             No, go see if HEX wanted
         BAL   R14,DMPMV           Yes, move data to line
         LTR   R1,R1               Zero length?
         BZ    *+12                Yes, skip right to print
         L     R15,=A(TRTBLC)      Get address of char TR table
         EX    R1,DMPTR1           Get rid of unprintable
         BAL   R14,LINPRINT        And print it
         L     R15,DMPSV+56        Restore R15
*
DMPNOCH  TM    $SELF1,HEX          HEX wanted?
         BZ    DMPLOOP             No, print is done,see if rec is done
         BAL   R14,DMPMV           Yes, go move the data
         LTR   R1,R1               Zero length?
         BZ    *+12                Yes, skip right to print
         L     R15,=A(TRTBLLH)     Get LH TR table address
         EX    R1,DMPTR1           Convert to hex
         BAL   R14,LINPRINT        And print it
         BAL   R14,DMPMV           Go move it again
         LTR   R1,R1               Zero length?
         BZ    *+12                Yes, skip right to print
         L     R15,=A(TRTBLRH)     Get RH TR table address
         EX    R1,DMPTR1           Convert to hex
         BAL   R14,LINPRINT        And print it
*
DMPLOOP  LH    R1,DMPLRECL         Get LRECL
         CH    R1,=H'100'          Did it all fit on last line?
         BNH   DMPEXIT             Yes, exit
         LA    R2,100              Put 100 in a reg
         SR    R1,R2               Subt 100 from remaining data to prt
         STH   R1,DMPLRECL         And put it back
         L     R1,DMPADDR          Then get dump address
         AR    R1,R2               Bump by 100
         ST    R1,DMPADDR          And put it back too
         L     R15,DMPSV+56        Restore R15
         ICM   R2,7,PCTOUTPT+1     Get original start addr
         TM    $SELF1,SPTR         Special IODUMP request
         BZ    *+8                 No, R1 is O.K.
         ICM   R2,15,TRADDR        Yes, get alternate address
         SR    R1,R2               Calc current offset
         CVD   R1,DBL              Convert it
         OI    DBL+6,X'0F'         Truncate to 100's
         UNPK  LINE+27(3),DBL+5(2) Put in line
         B     DMPFMTLP            Then loop back
*
DMPMV    LH    R1,DMPLRECL         Get LRECL
         CH    R1,=H'100'          Check against max line length
         BNH   *+8                 Will fit OK
         LA    R1,100              Won't fit, set to 100
         LTR   R1,R1               Zero?
         BZ    DMPMVEX
         BCTR  R1,0                Set it up for EX
         L     R2,DMPADDR          Get from address
         EX    R1,*+4              Move to print line
         MVC   LINE+31(0),0(R2)    .
*
DMPMVEX  LA    R3,LINE+31(R1)      Point 1 byte past end of data
         MVI   1(R3),C'|'          Put in delimiter
         MVI   LINE+30,C'|'
         BR    R14
*
DMPEXIT  ICM   R7,15,PCTPFCB       Point at printer FCB
         BZ    DMPEXIT2            Skip if none
         $INC  FCBCOUNT            Count recs printed
         $INC  FCBCREC             .
*
DMPEXIT2 LM    R0,R15,DMPSV
         $RET  0
NEEDCNT  DC    P'55'
         $PEND
         TITLE 'ELSE - Command processor'
*---------------------------------------------------------------------+
*        E L S E   C o m m a n d   P r o c e s s o r                  |
*---------------------------------------------------------------------+
*
ELSE     $PROC
         USING KWDSECT,R14
         ICM   R3,15,PCTPOPLS      Get last POP'ed address
         BNZ   ELSOK               Non-zero, continue
         $ERR  BELSE,8,SKIP        Zero, too bad
*
ELSOK    $ADD  ELSGM999-ELSGMBAL,ELSGMBAL Stuff in chain code
         LA    R1,4(,R1)           Point at Adcon
         $CALL PUSHIF              Save its address
         OI    PCTF4,IFNXSENT      Set to have it resolved later
         $ADD  0,*                 Get I.C.
         ICM   R3,15,PCTPOPLS      Get last POP'ed address again
         ST    R1,0(R3)            Make prev. Nxt Sent point here
         SR    R1,R1               Clear R1
         ST    R1,PCTPOPLS         Clear PCTPOPLS
         $CALL GETNEXT             Get the next word
         TM    WFLAG1,WPREF+WWRD2+WTRLR Eliminate invalid sub-operands
         BNZ   ELSEBD              .
         TM    WFLAG1,WWRD1        Better have this one
         BZ    ELSEBD              Nope, sorry
         TM    WRD1F2,OPRKW+OPRKWV Valid Keyword?
         BZ    ELSEBD              Nope, sorry
         LA    R14,WRD1KW1         Point at KW answer area
         TM    KWF1,KWIFTRU        Valid in context?
         BZ    ELSEBD              No, sorry
         L     R8,KWD3             Get addr of routine
         B     8(R8)               And go to it
*
ELSEDO   DS    CL8                 Make compatible with a $PROC
         NI    PCTF4,255-IFNXSENT  Ensure flag is off
         B     MAINGEOS            Go get the period.
*
ELSEBD   $ERR  BELSB,8,SKIP
*
ELSGMBAL BAL   R14,COMPGOTO        Off to the GOTO support routine
ELSGMADC DC    XL4'00'             Adcon
ELSGM999 EQU   *
         DROP  R14
         $PEND
         TITLE 'END - Command processor'
*---------------------------------------------------------------------+
*        E N D   C o m m a n d   P r o c e s s o r                    |
*---------------------------------------------------------------------+
*
END      $PROC
         ICM   R0,15,PCTNEST       Nest counter > 0
         BP    ENDISOK             Yes, good
         $ERR  BADDO,8,SKIP        No, too bad
*
ENDISOK  $CALL POPIF               POP one next sentence pointer
         B     MAINGEOS            Go finish with period (.)
         $PEND
         TITLE 'EOJ - End of job routines'
*---------------------------------------------------------------------+
*        Enter here on program termination                            |
*---------------------------------------------------------------------+
*
EOJ      $PROC
*
EOJCADD  $CALL ADDSTAT             Go close outputs and build stat msgs
         TM    PCTF8,PDSMODE       PDSMODE?
         BZ    EOJKTIME            No, continue shutdown
         CLI   PCTRC+3,X'08'       RC type shutdown?
         BNL   EOJKTIME            Yes, keep shutting down
         L     R2,PCTMEMBC         Get next member address
         CLC   0(8,R2),=8X'FF'     All done?
         BE    EOJPDSMD            Yes, PDSMODE all done
         L     R7,PCT1FCB          Point at INPUT1 FCB
         L     R2,PCTMEMBC         Get current 'member' name
         MVC   FCBJFCB+44(8),0(R2) Stuff in member name
         MVC   PCTIMEMB,0(R2)      Stuff as global I/P member
         MVC   PCTOMEMB,0(R2)      Stuff in global O/P member
         LA    R2,8(,R2)           Bump
         ST    R2,PCTMEMBC         Save back for next time
         OI    FCBJFCB+86,X'01'    Flag as a member
         OI    FCBJFCB+52,X'08'    Don't re-write JFCB during OPEN
         $CALL JFCNAME,FCBDSECT    Go build a full dsname
         MVC   JFCB,FCBJFCB        Swap to common area
         LA    R2,FCBDCB           OPEN it now
         OPEN  ((R2),INPUT),TYPE=J .
         TM    48(R2),X'10'        Open O.K. ?
         BNO   EOJIER3             Yes
         OI    FCBF1,FCBOPEN+FCBSTATS Flag as open STATS allowed
*---------------------------------------------------------------------+
*        Reset other stuff for Loopback processing                    |
*---------------------------------------------------------------------+
         MVC   PCTCOUNT,ZEROS      Master CREC
         MVC   PCTOBUFL,ZEROS      Length in OBUFF
         MVC   PCTFLCHG(28),ZEROS  Floating field support
         MVC   PCTPOPLS,ZEROS      POP ctr
         MVC   PCTNEST,ZEROS       Nest ctr
         MVI   PCTNEXT,X'00'       Next sentence stack
         MVC   PCTNEXT+1(79),PCTNEXT
         ICM   R2,15,PCTRESET      Get reset chain
         BZ    EOJRET0             None? O.K. exit then
         L     R3,4(R2)            Get address of where to reset
         MVC   0(4,R3),8(R2)       Stuff in reset value
         ICM   R2,15,0(R2)         Chain onward
         BNZ   *-14                Loop till done
*
EOJRET0  $RET  0                   Return for next member
*
EOJIER3  L     R1,=A(ERRTX29)      Point at error text
         MVC   17(8,R1),FCBDDNAM   Stuff in DDname
         $ERR  ODCB,12,SAVE=YES    No, issue err msg
*
EOJPDSMD NI    PCTF8,255-PDSMODE   Kill PDS mode now
         OI    PCTF8,PDSSTATS      Now say we want stats
         B     EOJCADD             Loop back for full shutdown
*
EOJKTIME TTIMER CANCEL             Cancel outstanding STIMER
         ICM   R7,15,PCTPFCB       Now point at SYSPRINT FCB
         BZ    EOJUCTRS            Skip if not there
         $CALL ADDPROC,(R7)        Else process it now (i.e. last)
*
EOJUCTRS TM    PCTF7,UCTRDUMP      UCTRx dump wanted?
         BZ    EOJSEEAB            No
         CLI   PCTUCTRA,X'00'      See if all counters are zero
         BNE   EOJUINIT            No, go dump them
         CLC   PCTUCTRA((4*26)-1),PCTUCTRA+1
         BE    EOJSEEAB            Yes, all zero, skip
*
EOJUINIT $ERR  SPACE,0,TYPE=STAT,FLAG=NO
         $ERR  UCTRH,0,TYPE=STAT,FLAG=NO   Init with heading
         $ERR  SPACE,0,TYPE=STAT,FLAG=NO
         LA    R3,PCTUCTRA         Point at counters
         SR    R4,R4               Clear index
         LA    R5,26               Set count
         L     R14,=A(ERRTX66+12)  Point at message
*
EOJULP   CLC   0(4,R3),ZEROS       Is the counter zero?
         BE    EOJULB              Yes, bump to next
         MVC   0(4,R14),=C'Uctr'   Build counter I.D.
         LA    R15,=C'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
         LA    R15,0(R15,R4)
         MVC   4(1,R14),0(R15)     Move counter I.D. in
         MVC   5(12,R14),=X'402020206B2020206B202021'
         L     R0,0(R3)            Get value
         CVD   R0,DBL
         EDMK  5(12,R14),DBL+3     Put number in
         BNM   *+10                If negative
         BCTR  R1,0                backup and
         MVI   0(R1),C'-'          stick in a minus
         LA    R14,31(,R14)        Bump in message line
         C     R14,=A(ERRTX66+60)  Time to print it
         BL    EOJULB              No, bump
         STM   R0,R15,EOJUSAVE     Save regs a while
         $ERR  UCTRL,0,TYPE=STAT,FLAG=NO,SAVE=YES
         LM    R0,R15,EOJUSAVE     Restore regs
         L     R14,=A(ERRTX66+12)  Point at message
         MVC   0(60,R14),BLANKS    Clear line
*
EOJULB   LA    R3,4(,R3)           Next counter
         LA    R4,1(,R4)           Next index number
         BCT   R5,EOJULP           Loop till done
         C     R14,=A(ERRTX66+12)  Something to print
         BE    EOJSEEAB            No, skip
         $ERR  UCTRL,0,TYPE=STAT,FLAG=NO
*
EOJSEEAB TM    PCTF4,ABENDING      Have we ABENDed?
         BZ    EOJRETN             No, issue return code
*
EOJCMNAB L     R1,=A(ERRTX67)      Point at message
         MVC   32(15,R1),=C'Abend code S...'
         TM    PCTABEND+3,X'FF'    User abend?
         BZ    EOJCMNSY            No, system
         MVC   43(5,R1),=C'U....'  Alter message
         LH    R2,PCTABEND+2       Get user abend number
         CVD   R2,DBL              Format it
         UNPK  43(5,R1),DBL+5(3)   .
         OI    47(R1),C'0'         .
         MVI   43(R1),C'U'         .
         B     EOJCMNMS            Continue
*
EOJCMNSY UNPK  44(3,R1),PCTABEND+1(2) Format abend code
         MVZ   44(3,R1),=XL3'00'   .
         L     R15,=A(SNPTR)       .
         TR    44(3,R1),0(R15)     .
*
EOJCMNMS $ERR  SPACE,0,TYPE=STAT,FLAG=NO
         $ERR  EJRC,0,TYPE=STAT,FLAG=NO
         $CALL ERPRINT             Go print diagnostics
         STAE  0                   Remove STAE
         SR    R0,R0               Then do ABEND all over again
         L     R1,PCTABEND         Get original ABEND code
         ABEND (1)                 ABEND
*
EOJRETN  TM    PCTF6,USERRC        Has user changed RCODE?
         BO    EOJEXIT             Yes, just issue as a RC
*
EOJRC    L     R15,PCTRC           Pickup return code
         CH    R15,=H'8'           How bad?
         BL    EOJEXIT             Not very
         MVC   PCTABEND,PCTRC      Swap RC into Abend code
         B     EOJCMNAB            Continue
*
EOJEXIT  L     R1,=A(ERRTX67)      Get address of message
         L     R2,PCTRC            Get return code
         CVD   R2,DBL              Get ready to ED
         MVC   36(6,R1),=X'402020202120'
         ED    36(6,R1),DBL+5
         $ERR  SPACE,0,TYPE=STAT,FLAG=NO
         $ERR  EJRC,0,TYPE=STAT,FLAG=NO
         $CALL ERPRINT             Go print diagnostics
         L     R15,PCTRC           Terminate with return code
         L     R13,4(R13)
         RETURN (14,12),RC=(15)
*
EOJUSAVE DS    16F
         $PEND
         TITLE 'ERPRINT - Process the error Msg Queue'
*---------------------------------------------------------------------+
*        Process the error message queue onto SYSPRINT                |
*        or if SYSPRINT not avail, then WTO or TPUT them.             |
*---------------------------------------------------------------------+
*
ERPRINT  $PROC
         LA    R2,PCTERCHN         Get start of err msg chain
         CLC   LINHDA3,=A(LINHD2A) Has normal hding been replaced?
         BE    ERPPSPCC            No, then leave alone
         CLI   TRLINE+31,C' '      Something in TRACE line
         BE    ERPNTRAC            No
         LA    R14,TRLINE-1        Yes, lets print it 1st
         BAL   R15,LINEDO          .
         MVC   TRLINE,BLANKS       Reset the TRACE line
         MVC   TRPOS,=A(TRLINE+31) .
*
ERPNTRAC MVC   LINHDA3,=A(LINHD4)  Swap page heads
         ZAP   LINECT,=P'1'        Force next to page heads
         B     ERPPBUMP            Go print msgs
*
ERPPSPCC BAL   R14,LINPRINT
         BAL   R14,LINPRINT
*
ERPPBUMP ICM   R2,15,0(R2)         Get next message on chain
         BZ    ERPPSTAT            Done, see if both chains done
         TM    PCTF5,STATPRNT      Printing stats?
         BO    ERPGSTR             Yes, skip formatting stmnt/word #
         UNPK  LINE(5),4(3,R2)     Put STMNT # in print line
         OI    LINE+4,X'F0'        Set good zone
         UNPK  LINE+10(3),7(3,R2)  Put word number in line
         OI    LINE+12,X'F0'       Set good zone
         CLC   =C'09999     999',LINE If EOF type errors
         BNE   *+10                then
         MVC   LINE(13),BLANKS     Blank them also
*
ERPGSTR  ICM   R1,15,12(R2)        Load text string address
         BZ    ERPPTBL             None, do it the old way
         BCTR  R1,0
         IC    R14,12(R2)          Load length too
         BCTR  R14,0               Less one
         B     ERPPMVMS            And go move it
*
ERPPTBL  IC    R1,11(R2)           Pickup err msg code
         SLL   R1,2                X 4
         L     R14,=A(ERRTBL-4)    Point at error table
         AR    R1,R14              Bump to Adcon of this msg
         L     R1,0(R1)            Point at message itself
         IC    R14,0(R1)           Get length of message
*
ERPPMVMS LA    R15,LINE+17         Set default move address
         TM    PCTF5,STATPRNT      Doing stats msgs?
         BNO   *+8                 No, R15 is O.K.
         SH    R15,=H'11'          Yes, shift left a bit
         EX    R14,*+4             Move message to line
         MVC   0(0,R15),1(R1)      .
         TM    PCTF2,DSYSPRT       Is SYSPRINT available?
         BO    ERPPPRNT            Yes, go use it
         CLI   10(R2),X'08'        What severity level is this
         BNH   ERPPBUMP            Trivial, ignore WTO'ing it
         L     R1,=A(ERRWTL+4)     Locate WTO MF=L data
         MVC   11(100,R1),LINE+17  Move print line to WTO text
         TM    PCTF1,TSOSTEP       Is this a TSO step?
         BZ    ERPPDWTO            No, do a WTO
         TPUT  (1),115             Yes, do a TPUT to the user
         B     ERPPBUMP            And go back
*
ERPPDWTO OC    11(100,R1),BLANKS   Uppercase it
         SH    R1,=H'4'            Backup to ctl data
         WTO   MF=(E,(1))          WTO it
         B     ERPPBUMP            Then go back for next
*
ERPPPRNT BAL   R14,LINPRINT        Then print it
         B     ERPPBUMP            And go back
*
ERPPSTAT TM    PCTF5,STATPRNT      Printing stats?
         BO    ERPCPRT             Yes, we're done, go close SYSPRINT
         OI    PCTF5,STATPRNT      Force exit the next time thru
         LA    R2,PCTSTCHN         Get start of statistics chain
         BAL   R14,LINPRINT        Yes, space a bit
         BAL   R14,LINPRINT        .
         B     ERPPBUMP            Continue
*
ERPCPRT  ICM   R7,15,PCTPFCB       Now see if SYSPRINT is around
         BZ    ERPPEX              No, return
         TM    FCBDCB+48,X'10'     Is SYSPRINT even OPEN?
         BZ    ERPPEX              No, return
         LA    R2,FCBDCB           Point at DCB
         CLOSE ((R2))              Close it
         FREEPOOL (R2)             Free its buffers
*
ERPPEX   $RET  0                   Return
         $PEND
         TITLE 'ERRSTORE - Save message for later printing'
*---------------------------------------------------------------------+
*        Add error msg to message queue                               |
*        for later printing at end of compile                         |
*---------------------------------------------------------------------+
*
ERRSTORE $PROC
         STC   R1,ERRCDSTF+1       Put error code in MVI for later
         STC   R2,ERRLVSTF+1       Put level code in the other MVI
         LA    R1,ERRCWORK         Point at work area
         MVC   12(4,R1),ZEROS      Set text pointer to zero for now
         MVC   4(3,R1),GETCTR1     Put STMNT # in error message
         MVC   7(3,R1),GETCTR2     Put WORD # in
         TM    PCTF4,NOFLAG        Don't flag this error?
         BO    ERRCDSTF            Correct
         LA    R14,TRLINE+17       Underline error word
         LR    R15,R14             .
         A     R14,GETPTR          .
         S     R14,GETIMAGE        .
         BCTR  R14,0               .
         A     R15,GETWSTRT        .
         S     R15,GETIMAGE        .
         MVI   0(R15),C'#'         Flag location with error
         LA    R15,1(,R15)         Bump
         CR    R15,R14             Done?
         BNH   *-10                No, loop
         CLC   LINE+6(9),=C'* Error *' Already flagged as an error?
         BE    ERRCDSTF            Yes, skip
         MVC   LINE+6(9),=C'* Error *' Flag error
         CLI   ERRLVSTF+1,X'00'    Just a warning message?
         BNE   ERRCDSTF            No, error, leave it alone
         MVC   LINE+6(9),=C'Warning >' Alter it to a warning
*
ERRCDSTF MVI   11(R1),0            Put in error msg code
         NI    PCTF4,255-NOFLAG    Clear NOFLAG
*
ERRLVSTF MVI   10(R1),0            Put in severity level
         CLC   PCTRC+3(1),10(R1)   Higher than last RC?
         BH    ERRTSAVE            No, see if save needed
         MVC   PCTRC+3(1),10(R1)   Yes, swap it
*
ERRTSAVE LTR   R3,R3               Save requested?
         BNZ   ERRCHNIT            No, go chain entry
         EJECT
*---------------------------------------------------------------------+
*        Save the requested message in the literal pool               |
*---------------------------------------------------------------------+
         L     R14,=A(ERRTBL-4)    Get address of error table
         IC    R2,11(R1)           Get err numb.
         SLL   R2,2                X 4
         AR    R14,R2              Bump into Adcon table
         L     R14,0(R14)          Point at text string
         IC    R3,0(R14)           Pickup length of string
         LA    R3,1(,R3)           Make it actual for lit routine
         LR    R4,R3               Its needed in both regs
         LA    R2,1(R14)           Point at actual start of text
         ST    R1,ERRSV1           Save a few regs
         MVC   LITR,=F'1'          Set repeat to 1
         $CALL LITSTUFF            Go save in LITPOOL
         L     R1,ERRSV1           Restore regs
         MVC   13(3,R1),LITA+1     Save abs. loc of text
         MVC   12(1,R1),LITL+3     Save its length
*
ERRCHNIT TM    PCTF1,STAT          What type of msg is this
         BO    ERRLASTA            Statistics
         LA    R2,PCTERCHN         Get start of err msg chain
         B     ERRFEND             And start search
*
ERRLASTA LA    R2,PCTSTCHN         Get start of stat chain
         NI    PCTF1,255-STAT      Reset stat flag
*
ERRFEND  CLC   0(4,R2),ZEROS       Look for end of chain
         BE    ERRSTF              Got it, go add to chain
         L     R2,0(R2)            Get addr of element
         B     ERRFEND             Continue looking for end
*
ERRSTF   ST    R2,ERRSV1           Save end for a while
         LA    R3,16               Setup to save work area
         LR    R4,R3
         LA    R2,ERRCWORK
         MVC   LITR,=F'1'          Set repeat to 1
         $CALL LITSTUFF            Go put it in LITPOOL
         L     R2,ERRSV1           Restore end address
         L     R1,LITA             Get address where stored
         ST    R1,0(R2)            Add new area to chain
         SR    R2,R2               Set R2 to zero
         ST    R2,0(R1)            And set new chain terminator
*
ERRTTEST TM    PCTF1,TSOSTEP       Is this a TSO step?
         BZ    ERRSEX              No, just return
         L     R14,PCTIDCB         Get address of SYSIN DCB
         TM    17(R14),X'4F'       Is SYSIN a termfile?
         BNO   ERRSEX              No, just return
         CLI   ERRCWORK+10,X'00'   An error
         BE    ERRSEX              No
         CLI   TRLINE,C' '         Anything waiting in TRACE line?
         BE    ERRTMSK             No, just print normally
         L     R7,PCTPFCB          Yes, point at SYSPRINT FCB
         LA    R14,TRLINE-1        and print it 1st
         BAL   R15,LINEDO          .
         MVC   TRLINE,BLANKS       Reset the TRACE line
         MVC   TRPOS,=A(TRLINE+31) .
*
ERRTMSK  MVI   ERRTMSG,C' '                Blank error build area
         MVC   ERRTMSG+1(131),ERRTMSG      .
         UNPK  ERRTMSG(5),ERRCWORK+4(3)    Put STMNT # in print line
         OI    ERRTMSG+4,X'F0'             Set good zone
         UNPK  ERRTMSG+10(3),ERRCWORK+7(3) Put word number in errtmsg
         OI    ERRTMSG+12,X'F0'            Set good zone
         CLC   =C'09999     999',ERRTMSG   If EOF type errors
         BNE   *+10                        Then
         MVC   ERRTMSG(13),BLANKS          Clear it
         L     R14,=A(ERRTBL-4)    Get address of error table
         IC    R2,ERRCWORK+11      Get err numb.
         SLL   R2,2                X 4
         AR    R14,R2              Bump into Adcon table
         L     R14,0(R14)          Point at text string
         IC    R3,0(R14)           Pickup length of string
         EX    R3,*+4              Move it
         MVC   ERRTMSG+17(0),1(R14)
         TPUT  ERRTMSG,L'ERRTMSG   TPUT it right now
*
ERRSEX   $RET  0                   Exit
         $PEND
         TITLE 'FASTCOPY - High performance I/O routine'
*---------------------------------------------------------------------+
*        Test to see if fast copy is possible                         |
*---------------------------------------------------------------------+
*
FASTCOPY $PROC
         TM    PCTF8,PDSMODE       Never FASTCOPY in PDSMODE
         BO    FASTRET0            .
         TM    PCTF6,TRYFAST       Should FAST even be attempted?
         BO    FASTTEST            Yes, let's see if we can do it
*
FASTRET0 NI    PCTF6,255-TRYFAST   Never do FASTTEST
         $RET  0                   No, go back to normal route
*
FASTTEST L     R7,PCT2FCB          Get OUTPUT1 control area
         MVC   DBL(1),FCBRECFM     Copy OUTPUT1 RECFM
         MVC   DBL+2(2),FCBLRECL            And LRECL
         L     R7,PCT1FCB          Get INPUT1 control area
         CLC   FCBLRECL,DBL+2      Are UT1/UT2 LRECL's the same?
         BNE   FASTRET0            Not same, ignore fast copy
         MVC   DBL+1(1),FCBRECFM   Copy UT1's RECFM
         NC    DBL(2),=X'C0C0'     Clear rubbish bits from RECFM's
         CLC   DBL(1),DBL+1        Are UT1/UT2 RECFM's the same?
         BNE   FASTRET0            No, ignore fast copy
*---------------------------------------------------------------------+
*        Now let's worry about unlike concatenations                  |
*---------------------------------------------------------------------+
         L     R2,WKTIOT           Start by getting TIOT address
         LA    R2,24(,R2)          Step over header area
*
FASTTLOP CLC   4(8,R2),FCBDDNAM    Look for the INPUT1 entry
         BE    FASTTFND            Got it
         SR    R1,R1               Clear wkreg
         IC    R1,0(R2)            Insert length of this TIOT entry
         AR    R2,R1               Bump to next entry
         CLC   0(4,R2),ZEROS       End of TIOT?
         BE    FASTRET0            Never happens, lets pretend it didnt
         B     FASTTLOP            Not end, loop back till found
*
FASTTFND SR    R1,R1               Clear wkreg again
         IC    R1,0(R2)            Get length of entry
         AR    R2,R1               Step to next entry
         CLC   0(4,R2),ZEROS       End of TIOT
         BE    FASTREAD            Yes, so no concats, do it fast way
         CLC   4(8,R2),BLANKS      Blank? (concat)
         BNE   FASTREAD            No, again use fast route
         STM   R0,R15,SWASAVE      Save everything
         LA    R1,12(R2)           -> JFCB token
         L     R2,=A(GTSWABLK)     Get routine address
         BALR  R14,R2              Go get block
         LM    R0,R15,SWASAVE      Load everything
         L     R3,=A(SWABLKA)      Get address of SWA block
         LA    R3,4(,R3)           Step over header
         MVC   JFCB,0(R3)          Copy JFCB
         CLI   JFCRECFM,X'00'      Any RECFM in JFCB?
         BE    FASTTDSD            No, see if its DASD
         MVC   DBL+1(1),JFCRECFM   Compare RECFM's of UT2 and UT1
         NC    DBL(2),=X'C0C0'     Clear rubbish bits
         CLC   DBL(1),DBL+1        Same RECFM's
         BNE   FASTRET0            No, dont use FASTREAD
         CLC   JFCLRECL,ZEROS      Any LRECL in JFCB?
         BE    FASTTDSD            No see if DASD
         CLC   DBL+2(2),JFCLRECL   Same LRECL?
         BNE   FASTRET0            No, use regular read
         B     FASTTFND            Yes, this ones OK, see if any more
*---------------------------------------------------------------------+
*        JFCB didn't contain enough data to let us decide,            |
*        see if DASD, and if so, get DSCB in to check.                |
*---------------------------------------------------------------------+
*
FASTTDSD L     R3,16(R2)           Get UCB address
         TM    18(R3),X'20'        Is it DASD?
         BZ    FASTRET0            No, cant tell, must use slow way
         OBTAIN OBTCMLST,EADSCB=OK Try to get DSCB
         LTR   R15,R15             O.K. ?
         BNZ   FASTRET0            No, dont care why, use slow route
         L     R3,OBTCMLST+12
         CLI   DS1RECFM-44(R3),X'00' Any RECFM?
         BE    FASTRET0            No, must use slow route
         MVC   DBL+1(1),DS1RECFM-44(R3) Compare RECFM's
         NC    DBL(2),=X'C0C0'     Clear rubbish bits
         CLC   DBL(1),DBL+1        Same RECFM's
         BNE   FASTRET0            No, dont use FASTREAD
         CLC   DS1LRECL-44(2,R3),ZEROS Any LRECL in DSCB?
         BE    FASTRET0            No can't do
         CLC   DBL+2(2),DS1LRECL-44(R3) Same LRECL?
         BNE   FASTRET0            No, use regular read
         B     FASTTFND            Yes, go see if more concat
         EJECT
*---------------------------------------------------------------------+
*        This is the FASTCOPY main loop.  It has been optimized       |
*        to use the minimum possible instructions / record.           |
*                                                                     |
*        Exit from this loop is only at end-of-file to label EODAD.   |
*---------------------------------------------------------------------+
*
FASTREAD SR    R9,R9               Clear FCB counters
         SR    R7,R7               .
         LA    R6,1                Constant 1
         OI    PCTF3,FAST          Say we're in fast route
         NI    PCTF4,255-COMPILE   Say compile is done
         L     R2,PCT1DCB          Get address of input DCB
         L     R3,PCT2DCB          Get address of output DCB
*
FASTLOOP GET   (R2)                Get next record (GET LOCATE)
*
FASTCONC NOP   FASTRR              BR if re-read needed for concat
         LR    R4,R1               Put record address in R4
         AR    R7,R6               Count input records
         LH    R5,DCBLRECL(R2)     Get LRECL of input record
         STH   R5,DCBLRECL(R3)     Stuff LRECL in output DCB
         PUT   (R3)                Get output buffer addr (PUT LOCATE)
         LR    R14,R1              Set up for MVCL to output buffer
         LR    R15,R5              .
         MVCL  R14,R4              Move record to output buffer
         AR    R9,R6               Count output records
         B     FASTLOOP            Loop-de-loop
*
FASTRR   NI    FASTCONC+1,X'0F'    Turn off reread sw
         RDJFCB ((R2))             Get the new JFCB for INPUT1
         L     R5,PCT1FCB          Point at INPUT1 FCB
         PUSH  USING               Get temp FCB addressability
         DROP  R7                  .
         USING FCBDSECT,R5         .
         MVC   FCBJFCB,JFCB        Save the new JFCB
         $CALL JFCNAME,FCBDSECT    Go build a full dsname
         MVC   FCBORECF,FCBDCB+DCBRECFM And some other things
         MVC   FCBRECFM,FCBORECF
         TM    FCBRECFM,X'C0'      Undefined?
         BNO   *+10                No
         MVC   FCBDCB+DCBLRECL(2),FCBDCB+DCBBLKSI
         MVC   FCBOBLK,FCBDCB+DCBBLKSI
         MVC   FCBBLKSI,FCBOBLK
         MVC   FCBOLREC,FCBDCB+DCBLRECL
         MVC   FCBLRECL,FCBOLREC
         MVC   FCBNVOLS(31),FCBJFCB+JFCBNVOL-JFCB
         SR    R7,R7               Clear input count
         B     FASTLOOP            And go read next record
         POP   USING               Restore normal addressability
         $PEND
         TITLE 'GETNEXT - Get next word to compile'
*---------------------------------------------------------------------+
*        Get next word for Compiler                                   |
*---------------------------------------------------------------------+
*
GETNEXT  $PROC
         $CALL GETWORD             Go get a word
         CLC   WORDL,HEXFFS        End of file??
         BE    GETNEOF             Yes, its end of source deck
         CLC   WORDL,=X'7FFF'      Bad cont. at end of file?
         BE    GETNMISS            Yes, tell of it
         CLC   WORDL,=X'7FFE'      Still in comment mode?
         BE    GETCMISS            Yes, tell of it
         $CALL PARSE,WORDL         Go parse it for the caller
         $CALL CKCOMENT            Go handle command comments
         $RET  0                   Return now
*
GETNEOF  L     R8,=A(MAINCOMP)     Get compiler addressable
         B     MAINENDC-MAINCOMP(R8) Return
*
GETNMISS L     R8,=A(MAINCOMP)     Get compiler addressable
         B     MAINENDM-MAINCOMP(R8) Return
*
GETCMISS L     R8,=A(MAINCOMP)     Get compiler addressable
         B     MAINCMS-MAINCOMP(R8) Return
         $PEND
         TITLE 'GETWORD - Read SYSIN'
*---------------------------------------------------------------------+
*        This routine reads SYSIN and returns a 'word'                |
*        at a time to the main line. Continuations are                |
*        handled by this routine, the caller need not concern         |
*        themselves with them.                                        |
*---------------------------------------------------------------------+
*
GETWORD  $PROC
         TM    PCTF1,DFLTFLAG      Are we processing default SYSIN
         BO    GETWEOST            Yes, ignore open type crap
         TM    PCTF3,DEFREOF       A deferred EOF waiting?
         BZ    GETWEOST            No
         MVC   WORDL,HEXFFS        Yes
*
GETWEX0  $RET  0
*
GETWEOST TM    PCTF6,EOS           End of sentence?
         BZ    GETWCDPT            No
         MVC   WORDL,ZEROS         Yes, set lgth to zero to say E.O.S.
         NI    PCTF6,255-EOS       Reset switch to normal value
         B     GETWEX0             And return to caller
*
GETWTBG  $ERR  WTBIG,8,FLAG=NO     Kill current word
*
GETWCDPT MVC   WORDL,ZEROS         Reset word area
         MVC   GETWDPT,=A(WORDTXT) Reset Ptr to start of area
         SR    R15,R15
         ICM   R3,15,GETSCLN       Get curr length left to scan
         BNZ   GETWSCNI            Go scan if we have something
*
GETWNCRD TM    PCTF1,DFLTFLAG      Processing default SYSIN
         BZ    GETWRCRD            No, get a real card
         TM    PCTF4,PWAITING      Previous line waiting?
         BZ    *+12                No
         BAL   R14,LINPRINT        Yes, Print it
         NI    PCTF4,255-PWAITING  and clear flag
         ICM   R1,15,GETDPTRS      Get next pointer
         BM    GETWEODP            If -ve, the  it was PARM
         BZ    GETWEODT            If zero its pseudo EOF
         MVC   GETDPTRS(16),GETDPTRS+4 Shift to next card image ptr
         B     GETWPSTR            Skip over real GET
*
GETWEODP NI    PCTF1,255-DFLTFLAG  Remove default flag
         MVC   GETDPTRS(16),GETDPTRS+4 Shift to next card image ptr
         MVC   GETPTR(8),ZEROS     Clear pointers
         B     REDOSLCT            Restart select process
*
GETWRCRD TM    PCTF4,PWAITING      Previous line waiting?
         BZ    *+12                No
         BAL   R14,LINPRINT        Yes, Print it
         NI    PCTF4,255-PWAITING  and clear flag
         L     R2,PCTIDCB          Point at SYSIN DCB
         GET   (R2)                Get a card
         LA    R1,0(R1)            Purify address
         ST    R1,GETIMAGE         Save where it starts
         ST    R1,GETWSTRT         .
         L     R2,PCTIFCB          Point at SYSIN FCB
         $INC  FCBCOUNT-FCBDSECT(R2) Count records
         $INC  FCBCREC-FCBDSECT(R2)  .
         OI    PCTF6,EOD           Set sw to say we got at least 1 card
*
GETWPSTR LA    R1,0(R1)            Purify it
         ST    R1,GETPTR           Save its loc. as start scan addr
         AP    GETCTR1,=P'1'       Count card
         SP    GETCTR2,GETCTR2     Reset word number on card
         UNPK  LINE(5),GETCTR1     Put stmnt number in line
         OI    LINE+4,X'F0'        Make it pretty
         MVC   LINE+17(80),0(R1)   Move to print line
         OI    PCTF4,PWAITING      Remember to print it
         MVC   GETSCLN,=F'71'      Set scan length
         EJECT
*---------------------------------------------------------------------+
*        Main scanning loop                                           |
*---------------------------------------------------------------------+
*
GETWSCNI LM    R3,R4,GETPTR        Get length to scan
         L     R14,=A(TRTBLNB)     Point at TRT table
         EX    R4,GETFTRT          Scan for 1st non-blank
         BZ    GETWNCRD            No chars, go get another card
         AP    GETCTR2,=P'1'       Count word on card
         LA    R1,0(R1)            Purify address
         ST    R1,GETWSTRT         Save start loc of word
         LR    R2,R1               Put found loc in work reg
         SR    R2,R3               Calc length of blanks
         SR    R4,R2               Subt it from tot length of scan left
         BNM   *+6                 Skip if positive
         SR    R4,R4               Zero if its gone negative
         ST    R4,GETSCLN          And store it
         LA    R1,0(R1)            Purify it
         ST    R1,GETPTR           Also alter start scan address
*
GETWSCAN LM    R3,R4,GETPTR        Load scan regs
         SR    R2,R2               Clear R2 for BR table
         L     R14,=A(TRTBLDLM)    Point at TRT table
         EX    R4,GETFTRT          Look for delimiters
         BZ    GETWNDLM            None? go handle this
         B     *(R2)               Do BR table depending on char found
         B     GETWBLNK            Blank
         B     GETWPERD            Period
         B     GETWQUOT            Quote
*
GETWNDLM L     R2,GETWDPT          Get next loc in word area
         EX    R4,GETMV1           Move entire data to word area
         EX    R4,GETOR2           Uppercase it
         LA    R2,1(R2,R4)         Step over data moved
         ST    R2,GETWDPT          And save as next loc
         C     R2,=A(WORDTXT+270)  Gotten too big?
         BH    GETWTBG             Yes, kill it
         TM    PCTF4,PWAITING      Previous line waiting?
         BZ    *+12                No
         BAL   R14,LINPRINT        Yes, Print it
         NI    PCTF4,255-PWAITING  and clear flag
         L     R2,PCTIDCB          Get address of SYSIN DCB
         GET   (R2)                Go get another card
         LA    R1,0(R1)            Purify address
         ST    R1,GETIMAGE         Save where it starts
         ST    R1,GETWSTRT         .
         L     R2,PCTIFCB          Point at SYSIN FCB
         $INC  FCBCOUNT-FCBDSECT(R2) Count records
         $INC  FCBCREC-FCBDSECT(R2)  .
         LA    R1,0(R1)            Purify it
         ST    R1,GETPTR           Reset pointer
         AP    GETCTR1,=P'1'       Count it
         SP    GETCTR2,GETCTR2     Reset word number
         UNPK  LINE(5),GETCTR1     Put STMNT # in line
         OI    LINE+4,X'F0'        Set good zone
         MVC   LINE+17(80),0(R1)   Put in print line
         OI    PCTF4,PWAITING      Remember
         MVC   GETSCLN,=F'70'      Reset scan length
         B     GETWSCAN            Go resume scan
*
GETWBLNK LA    R1,0(R1)            Purify it
         ST    R1,GETPTR           Save for next entry
         SR    R1,R3               Calc length of word found
         SR    R4,R1               Deduct from remaining length
         BNM   *+6                 Skip if positive
         SR    R4,R4               Zero if its gone negative
         ST    R4,GETSCLN          Save new length
         LTR   R1,R1               Is length zero?
         BZ    GETWDEX             Yes, exit now
         BCTR  R1,0                Minus one
         L     R2,GETWDPT          Get next loc in word area
         EX    R1,GETMV1           Move found word to word area
         EX    R1,GETOR2           Uppercase it
         LA    R2,1(R2,R1)         Step over moved word
         ST    R2,GETWDPT          And save it
         B     GETWDEX             And exit
*
GETWPERD LA    R1,1(,R1)           Step over period
         ST    R1,GETPTR           And save it
         SR    R1,R3               Calc length
         SR    R4,R1               Subt from tot length
         BNM   *+6                 Skip if positive
         SR    R4,R4               Zero if its gone negative
         ST    R4,GETSCLN          Save new length
         SH    R1,=H'2'            Adjust length
         BM    GETWTMPY            If single per. see if word empty
         L     R2,GETWDPT          Get next loc in word area
         EX    R1,GETMV1           Move the word
         EX    R1,GETOR2           Uppercase it
         LA    R2,1(R2,R1)         Step over the word
         ST    R2,GETWDPT          Save new loc
         OI    PCTF6,EOS           Set end of sent. switch
         B     GETWDEX             And exit
*
GETWTMPY CLC   GETWDPT,=A(WORDTXT) Anything in word?
         BE    GETWEOST+8          No, leave now
         OI    PCTF6,EOS
         B     GETWDEX             And leave with that word
*---------------------------------------------------------------------+
*        Handle quoted words                                          |
*---------------------------------------------------------------------+
*
GETWQUOT SR    R1,R3               Calc length
         SR    R4,R1               Subt from length
         LTR   R1,R1               Any data before the quote?
         BZ    *+8                 No, skip
         EX    R1,GETOR1           Uppercase stuff before quotes
         LA    R3,1(R3,R1)         Create new temp start scan addr
*
GETWSQUT L     R14,=A(TRTBLQ)      Point at TRT table
         EX    R4,GETFTRT          Try to find next quote
         BZ    GETWNO2Q            None on this card
         CLI   1(R1),C''''         Is the next also a quote
         BE    GETWDBLQ            Yes, go handle double quotes
         L     R3,GETPTR           Get start of original scan
         LR    R14,R1              Put end addr in work reg
         LA    R14,1(,R14)         Adjust it
         ST    R14,GETPTR          And store it
         SR    R1,R3               Calc length up to end quote
         L     R4,GETSCLN          Get original length
         SR    R4,R1               Deduct it from total length
         BCTR  R4,0                Another
         L     R2,GETWDPT          Get next loc in word area
         EX    R1,GETMV1           Move up to end quote to word area
         LA    R2,1(R2,R1)         Step over
         ST    R2,GETWDPT          And save it for next time
         ST    R4,GETSCLN          Save length also
         B     GETWSCAN
*
GETWDBLQ L     R3,GETPTR           Get original start scan addr
         LR    R14,R1              Put end loc in work reg
         LA    R14,2(,R14)         Bump over quotes
         ST    R14,GETPTR          Save for resume scan
         SR    R1,R3               Calc length
         SR    R4,R1               Reduce amount remaining
         BCTR  R4,0                One more for EX
         L     R2,GETWDPT          Get next loc in word area
         EX    R1,GETMV1           Move to word area
         LA    R2,1(R2,R1)         Step over
         ST    R2,GETWDPT          And save it
         ST    R4,GETSCLN          Save length
         L     R3,GETPTR           Get back start scan addr
         B     GETWSQUT            And resume scan
*
GETWNO2Q L     R2,GETWDPT          Get next loc in word area
         LM    R3,R4,GETPTR        Get orig scan params
         EX    R4,GETMV1           And use them to do move all
         LA    R2,1(R2,R4)         Step over
         ST    R2,GETWDPT          And save it
         C     R2,=A(WORDTXT+270)  Gotten too big?
         BH    GETWTBG             Yes, kill it
         TM    PCTF4,PWAITING      Previous line waiting?
         BZ    *+12                No
         BAL   R14,LINPRINT        Yes, Print it
         NI    PCTF4,255-PWAITING  and clear flag
         L     R2,PCTIDCB          Get address of SYSIN DCB
         GET   (R2)                Get another card
         LA    R1,0(R1)            Purify address
         ST    R1,GETIMAGE         Save where it starts
         ST    R1,GETWSTRT         Save where it starts
         L     R2,PCTIFCB          Point at SYSIN FCB
         $INC  FCBCOUNT-FCBDSECT(R2) Count records
         $INC  FCBCREC-FCBDSECT(R2)  .
         LA    R1,0(R1)            Purify it
         ST    R1,GETPTR           Save cards address
         AP    GETCTR1,=P'1'       Count card
         SP    GETCTR2,GETCTR2     Reset word number
         UNPK  LINE(5),GETCTR1     Put STMNT # in line
         OI    LINE+4,X'F0'        Pretty it up
         MVC   LINE+17(80),0(R1)   Put in line
         OI    PCTF4,PWAITING      And print it
         MVC   GETSCLN,=F'70'      Reset length
         LM    R3,R4,GETPTR        Load scan regs
         B     GETWSQUT            Go continue scan for 2nd quote
*
GETWDEX  L     R2,GETWDPT          Get next loc in word area
         LA    R3,WORDTXT          Get start address
         SR    R2,R3               Calc length of word
         STH   R2,WORDL            Put length in word prefix
         B     GETWEX0             And exit
         EJECT
*---------------------------------------------------------------------+
*        End-of-file on SYSIN                                         |
*---------------------------------------------------------------------+
*
GETWEODT TM    PCTF6,EOD           If input occurred, keep going
         BO    GETWEODX            .
         OI    PCTF6,EOD           Set SW back
         ICM   R2,15,PCTIDCB       Get address of SYSIN DCB
         BZ    INICHOOS            Skip if none
         TM    48(R2),X'10'        OPEN?
         BZ    INICHOOS            No, skip CLOSE then
         CLOSE ((R2))              Close the file
         FREEPOOL (R2)             Free its buffers
         B     INICHOOS            Go choose default option
*
GETWEODX CLC   GETWDPT,=A(WORDTXT) Anything in word??
         BE    GETWGEOD            No, clean EOD occurred
         MVC   WORDL,=X'7FFF'      Yes, missing continuation
         B     GETWCLOS
*
GETWGEOD TM    PCTF1,ACTIVE        Is a command still active?
         BZ    GETWEOOK            No, then all's well
         OI    PCTF3,DEFREOF       Set deferred end of file
         MVC   WORDL,ZEROS
         ICM   R2,15,PCTIDCB       Get address of SYSIN DCB
         BZ    GETWEX0             Skip if none
         L     R2,PCTIDCB          Get address of SYSIN DCB
         TM    48(R2),X'10'        OPEN?
         BZ    GETWEX0             No, skip CLOSE then
         CLOSE ((R2))
         FREEPOOL (R2)             Free its buffers
         B     GETWEX0
*
GETWEOOK CP    COMNTCTL,=P'0'      Inside a comment?
         BE    GETSTEO             No, continue
         MVC   WORDL,=X'7FFE'      Yes, flag it
         B     GETWCLOS            now continue
*
GETSTEO  MVC   WORDL,HEXFFS        Flag as end of file
*
GETWCLOS TM    PCTF1,DFLTFLAG      Default processing?
         BO    GETWEX0
         ICM   R2,15,PCTIDCB       Get address of SYSIN DCB
         BZ    GETWEX0             Skip if none
         TM    48(R2),X'10'        OPEN?
         BZ    GETWEX0             No, skip CLOSE then
         CLOSE ((R2))              Close input
         FREEPOOL (R2)             Free its buffers
         B     GETWEX0             And exit
*
GETWEOFX MVC   WORDL,HEXFFS
         B     GETWEX0
         $PEND
         TITLE 'GOBACK - Command processor'
*---------------------------------------------------------------------+
*        G O B A C K    C o m m a n d    P r o c e s s o r            |
*---------------------------------------------------------------------+
*
GOBACK   $PROC
         USING KWDSECT,R14
         $CALL DBGADD              Go add DEBUG code
         $ADD  4,GOBKBAL1          Put branch code into program
         B     EXITGEOS            Go to common command exit
*
*---------------------------------------------------------------------+
*        GOSUB routine work areas                                     |
*---------------------------------------------------------------------+
*
GOBKBAL1 BAL   R14,SUBRETN         Off to SUBRETN support routine
         DROP  R14
         $PEND
         TITLE 'GOSUB - Command processor'
*---------------------------------------------------------------------+
*        G O S U B   C o m m a n d    P r o c e s s o r               |
*---------------------------------------------------------------------+
*
GOSUB    $PROC
         USING KWDSECT,R14
         $CALL DBGADD              Go add DEBUG code
*
GOSBGWRD OI    PCTF4,LABLLOOK      Say we're looking for a LABEL:
         $CALL GETNEXT             Go get next word
         TM    WFLAG1,WPREF+WTRLR  Eliminate invalid sub-operands
         BNZ   BADOPTYP            .
         TM    WFLAG1,WWRD1        Better have this one
         BZ    GOSBNOPS            Nope, sorry
         TM    WRD1F2,OPRKW+OPRKWV Valid Keyword?
         BZ    GOSBBLD             Nope, sorry
         LA    R14,WRD1KW1         Point at KW answer area
         TM    KWF1,KWNOISE        Eliminate 'noise' words
         BO    GOSBGWRD            .
         B     GOSBBLD             No, put it in code
*
GOSBNOPS $ERR  NOOPS,8,GO=MAINGOK  Yes, kill it and continue
*
GOSBBLD  TM    WRD1F2,OPRPTR       If operand is PTR type, fudge 1st 8
         BNO   GOSBSTUF            Yes, noise, get next word
         MVC   WRD1L,=H'8'         Set length to max
         L     R15,WRD1ADDR        Get address of operand
         MVC   WRD1TXT,0(R15)      Copy leading characters of string
*
GOSBSTUF $ADD  12,GOSBBAL1         Put branch code into program
         LA    R1,8(,R1)           -> Adcon to be resolved later
         $CALL LBLOGEN,WRD1L,(R1)  Go add to unresolved table
         B     EXITGEOS            Go to common command exit
*
*---------------------------------------------------------------------+
*        GOSUB routine work areas                                     |
*---------------------------------------------------------------------+
*
GOSBBAL1 BAL   R14,SUBSAVE         Off to SUBSAVE support routine
GOSBBAL2 BAL   R14,COMPGOTO        Off to GOTO support routine
GOSBADCN DC    4X'00'              Adcon to be stuffed
         DROP  R14
         $PEND
         TITLE 'GOTO - Command processor'
*---------------------------------------------------------------------+
*        G O T O   C o m m a n d   P r o c e s s o r                  |
*---------------------------------------------------------------------+
*
GOTO     $PROC
         USING KWDSECT,R14
         $CALL DBGADD              Go add DEBUG code
*
GOTOGWRD OI    PCTF4,LABLLOOK      Say we're looking for a LABEL:
         $CALL GETNEXT             Go get next word
         TM    WFLAG1,WPREF+WTRLR  Eliminate invalid sub-operands
         BNZ   BADOPTYP            .
         TM    WFLAG1,WWRD1        Better have this one
         BZ    GOTONOPS            Nope, sorry
         TM    WRD1F2,OPRKW+OPRKWV Valid Keyword?
         BZ    GOTOBLD             Nope, sorry
         LA    R14,WRD1KW1         Point at KW answer area
         TM    KWF1,KWNOISE        Eliminate 'noise' words
         BO    GOTOGWRD            .
         B     GOTOBLD             No, put it in code
*
GOTONOPS $ERR  NOOPS,8,GO=MAINGOK  Yes, kill it and continue
*
GOTOBLD  TM    WRD1F2,OPRPTR       If operand is PTR type, fudge 1st 8
         BNO   GOTOSTUF            Yes, noise, get next word
         MVC   WRD1L,=H'8'         Set length to max
         L     R15,WRD1ADDR        Get address of operand
         MVC   WRD1TXT,0(R15)      Copy leading characters of string
*
GOTOSTUF $ADD  8,GOGMBAL           Put branch code into program
         LA    R1,4(,R1)           -> Adcon to be resolved later
         $CALL LBLOGEN,WRD1L,(R1)  Go add to unresolved table
         B     EXITGEOS            Go to common command exit
*
*---------------------------------------------------------------------+
*        GOTO routine work areas                                      |
*---------------------------------------------------------------------+
*
GOGMBAL  BAL   R14,COMPGOTO        Off to GOTO support routine
GOGMADCN DC    4X'00'              Adcon to be stuffed
         DROP  R14
         $PEND
         TITLE 'IF - Command processor'
*---------------------------------------------------------------------+
*        I F   C o m m a n d   P r o c e s s o r                      |
*---------------------------------------------------------------------+
*
IF       $PROC
         USING KWDSECT,R14
         MVC   PCTPOPLS,ZEROS      Clear last POP'ed address
         OI    PCTF1,ACTIVE        Show command active
         MVC   OREGM,ZEROS         Clear OREGM area
         MVI   PCTIOFLG,X'00'      Clear IO flags
         MVI   PCTIOFL2,X'00'      .
         NI    PCTF5,255-IFAOPG-IFBOPG-IFRELG Clear operand flags
         NI    PCTF3,255-OPKWLEN   .
         CLC   IFTRUCH,ZEROS       TRUE/AND tables gotten yet?
         BNE   IFADBG              Yes, keep going
         GETMAIN R,LV=8192         No, get one then
         ST    R1,IFTRUCH          Save 'TRUE' table address
         MVC   0(4,R1),HEXFFS      Set delimiter
         AH    R1,=H'4096'         Bump to reach 'AND' table
         ST    R1,IFANDCH          Save 'AND' table address
         MVC   0(4,R1),HEXFFS      Set delimiter
         AH    R1,=H'4096'         Bump to reach 'AND' table
         ST    R1,IFTAEND          Save end address
*
IFADBG   $CALL DBGADD              Go add DEBUG code
         $ADD  8,IFGMBAL1          Create code to point at next sent.
         LA    R1,4(,R1)           Point at next sent Adcon
         $CALL PUSHIF              Then save its address
         OI    PCTF4,IFNXSENT      Flag to complete it
*---------------------------------------------------------------------+
*        Get the operands for an IF command                           |
*---------------------------------------------------------------------+
*
         $CALL GETNEXT             Go get the A-operand
         MVI   WFLAG2,WAOP+WPREFOK+WTRLROK+WIPDEF+WLITOK Set bld flags
         MVI   OREGALEN,X'00'      Zero A-operand length
         $CALL OPGEN               Go gen code for the A-operand
         B     BADOPTYP            +0 Invalid, kill it
         OI    PCTF5,IFAOPG        +4 Code genn'ed O.K., remember that
         CLI   OPGBASE,X'0A'       OBUFF operand?
         BNE   IFNOCPG             No
         $ADD  4,DCOPM010          Yes, stuff in deferred copy
         OI    PCTF1,DCOPYGEN      Remember we did it
*
IFNOCPG  TM    PCTIOFLG,IOFLOATA   Is it a floating A-operand?
         BZ    IFNEXTC             No, continue
         CLI   OREGALEN,X'00'      An A length?
         BNE   BADLGTH             Yes, sorry
*
IFNEXTC  $CALL GETNEXT             Get type of test to do
*
IFRELOOK TM    WFLAG1,WWRD1        Got one?
         BZ    IFBIFT              No, error
         TM    WFLAG1,WPREF+WWRD2+WTRLR Any bad sub-fields?
         BNZ   IFBIFT              Yes, sorry
         TM    WRD1F2,OPRKW+OPRKWV Is it a valid KW?
         BNO   IFBIFT              No, sorry
         LA    R14,WRD1KW1         Point at KW answer area
         TM    KWF1,KWIFREL        Valid for IF relation test?
         BZ    IFBIFT              No, see if implied
*
IFSAVED1 MVC   IFD1,KWD1           Save the answer word
         OI    PCTF5,IFRELG        Remember we got the test operand
         MVC   OREGBLEN,ZEROS      Zero B-operand status
         NI    PCTIOFLG,255-IOFLOATB
         $CALL GETNEXT             Get the B-operand
*
IFSEEBOP MVI   WFLAG2,WBOP+WPREFOK+WTRLROK+WIPDEF+WLITOK
         MVC   OREGBLEN,ZEROS      Zero B-operand length
         $CALL OPGEN               Go gen code for the B-operand
         B     BADOPTYP            +0 Invalid, kill it
         CLI   OPGBASE,X'0A'       +4 OBUFF operand?
         BNE   IFNOBCP             No
         TM    PCTF1,DCOPYGEN      Already done?
         BO    IFNOBCP             Yes, skip
         $ADD  4,DCOPM010          Yes, stuff in deferred copy
         OI    PCTF1,DCOPYGEN      Remember we did it
*
IFNOBCP  CLI   IFD1+1,X'02'        O.K. Is this a MASK type
         BNE   IFDUN1              No, see if we can try Imply
         TM    WRD1F2,OPRLIT       Yes, B-op must be a literal
         BZ    IFIMASK             It isn't, kill it
         OI    PCTIOFLG,IOMASK     Set flag then for CONTAINS
         L     R15,LITL            Get length of literal
         L     R14,LITA            Get it's address
         TM    PCTIOFLG,IOFLOATA   Floating A-op?
         BZ    *+12
         CLI   0(R14),C'?'         Leading ?
         BE    IFIMASK1            Yes, kill it
         CLI   0(R14),C'?'         Mask character?
         BNE   *+8                 No
         MVI   0(R14),X'00'        Make null
         LA    R14,1(,R14)         Bump
         BCT   R15,*-16            Loop
*
IFDUN1   TM    PCTF5,IFBOPG        Done a complete B-operand set?
         BZ    IFGEN1              No, go generate something Now
*
IFIMPLY  $CALL GETNEXT             Get next word
         OI    PCTF4,IFDONEW       Say we've got the next word
         TM    WFLAG1,WWRD1        Got one?
         BZ    IFGEN1              No, -> IFGEN1, error found later
         TM    WFLAG1,WPREF+WWRD2+WTRLR Any bad sub-fields?
         BNZ   IFGEN1              Yes,-> IFGEN1, error found later
         TM    WRD1F2,OPRKW+OPRKWV Is it a valid KW?
         BNO   IFGEN1              No, -> IFGEN1, error found later
         LA    R14,WRD1KW1         Point at KW answer area
         TM    KWF1,KWIFREL        Valid for IF relation test?
         BZ    IFGEN1              No, -> IFGEN1, error found later
         $ADD  2,OPGSWAP1          Swap B-reg to A-reg
         NI    PCTF4,255-IFDONEW   Clear word gotten flag
         MVC   OREGALEN,OREGBLEN+1 Swap B values to A and zero B
         MVC   OREGBLEN,ZEROS      .
         NI    PCTIOFLG,255-IOFLOATA
         TM    PCTIOFLG,IOFLOATB   .
         BZ    *+8                 .
         OI    PCTIOFLG,IOFLOATA   .
         NI    PCTIOFLG,255-IOFLOATB
         NI    PCTIOFLG,255-IONOAADJ
         TM    PCTIOFLG,IONOBADJ   .
         BZ    *+8                 .
         OI    PCTIOFLG,IONOAADJ   .
         NI    PCTIOFLG,255-IONOBADJ
         NI    PCTF5,255-IFRELG    Forget we had a rel. test
         B     IFRELOOK            Done, continue with relation
*
IFBIFT   TM    PCTF5,IFAOPG+IFRELG Got A-op and test type?
         BNO   IFBIF               No, sorry
         B     IFSEEBOP            Yes, see if valid B-op
         EJECT
*---------------------------------------------------------------------+
*        Start generating the code for the IF test type               |
*---------------------------------------------------------------------+
*
IFGEN1   $CALL DBGADD              Add some more DEBUG code
         OI    PCTF5,IFBOPG        Remember we've Genn'd something
         TM    PCTIOFLG,IOFLOATA+IOFLOATB Both floating?
         BO    IFFLOATR            Yes, error
         CLI   IFD1+1,X'01'        A TM type of test?
         BE    IFGENTM             Yes, go do it
         SR    R1,R1               Clear R1
         ICM   R1,1,OREGALEN       Get A-operand length
         BZ    IFGENSB             None, See if B
         CLC   OREGBLEN,ZEROS      A B-length?
         BNE   IFGABSM             Yes, make sure they're the same
         MVC   OREGBLEN+1(1),OREGALEN Swap to B-length
         MVI   OREGALEN,X'00'      Zero A-length
         B     IFGENIO             Continue
*
IFGABSM  CH    R1,OREGBLEN         Same as B-operand length?
         BNE   BADLGTH             No, error
         B     IFGENIO             Yes, continue
*
IFGENSB  TM    PCTF3,OPKWLEN       A KW length field?
         BO    IFGENIO             Yes, who cares about OREGBLEN
         CLC   OREGBLEN,ZEROS      Better be one here!
         BE    BADLGTH             No, terrible
*
IFGENIO  MVC   ORLMVID,PCTIOFLG    Jam in IO flag byte
         TM    PCTF3,OPKWLEN       A KW length operand?
         BZ    IFGENION            No, do normal length load
         $ADD  4,ORLLCOD           Yes, Add code for it
         $ADD  4,ORLMVI            .
         TM    PCTIOFLG,IOFLOATA+IOFLOATB Floating?
         BNZ   IFCNTAIN            Yes, go do it
         $ADD  2,ORLLCODB          Add BCTR now
         B     IFGENMTS            Skip
*
IFGENION $ADD  ORLM999-ORLCODE,ORLCODE Stuff in OREG code
         TM    PCTIOFLG,IOFLOATA+IOFLOATB Floating?
         BNZ   IFCNTAIN            Yes, go do it
         MVI   OREGALEN-ORLCODE(R1),X'00' Clear any A-operand length
         MVI   OREGFLAG-ORLCODE(R1),X'00' and Flag byte
         SR    R2,R2               Clear a reg
         ICM   R2,3,OREGBLEN-ORLCODE(R1) Get the length
         CH    R2,=H'256'          Validate length
         BH    BADLGTH             Sorry, too big
         BCTR  R2,0                -1 for EX
         STCM  R2,3,OREGBLEN-ORLCODE(R1) Put it back
*
IFGENMTS CLI   IFD1+1,X'02'        A MASK type?
         BE    IFGMASK             Yes, go do it
         TM    PCTIOFLG,IOPACKED   A packed compare?
         BO    IFGEN1CP            Yes, gen that type then
         TM    PCTIOFL2,IOUCTRX    A UCTRx compare?
         BO    IFGEN1CR            Yes, gen that type then
*---------------------------------------------------------------------+
*        Generate code for a 'normal' compare                         |
*---------------------------------------------------------------------+
         $ADD  4,IFGMCLC           No, insert a EX of CLC then
         B     IFGENTST            and go insert test code
*---------------------------------------------------------------------+
*        Generate code for a 'packed' compare                         |
*---------------------------------------------------------------------+
*
IFGEN1CP LH    R15,OREGBLEN        Get the length
         BCTR  R15,0               -1 for EX
         SLL   R15,4               Shift left 4 bits
         LH    R14,OREGBLEN        Get length again
         BCTR  R14,0               -1 for EX
         OR    R15,R14             OR both 4 bit lengths together
         STC   R15,OREGBLEN+1-ORLCODE(R1) Modify in the compile area
         $ADD  4,IFGMCP            Insert a EX of CP then
         B     IFGENTST            and go insert test code
*---------------------------------------------------------------------+
*        Generate code for a 'fullword' compare                       |
*---------------------------------------------------------------------+
*
IFGEN1CR $ADD  12,IFGMLR0          Insert the load and compare code
         B     IFGENTST            and go insert test code
         EJECT
*---------------------------------------------------------------------+
*        Generate code for the IF ... ON/OFF/MIX ... tests            |
*---------------------------------------------------------------------+
*
IFGENTM  TM    PCTIOFLG,IOFLOATA+IOFLOATB Floating operands?
         BNZ   IFBFLOAT            Yes, kill it
         $ADD  8,IFGMTM1           Add code for TM type test
         B     IFGENTST            Go add code to test result
*---------------------------------------------------------------------+
*        Generate code for the IF ... MASK ...                        |
*---------------------------------------------------------------------+
*
IFGMASK  $ADD  16,IFGMMSK1         Add code for MASK type test
         B     IFGENTST            Go add code to test result
*---------------------------------------------------------------------+
*        Generate code for the IF 0 ..... (Contains) logic            |
*---------------------------------------------------------------------+
*
IFCNTAIN CLI   IFD1,X'80'          Must be = or = for CONTAINS
         BE    *+12                = is O.K., continue
         CLI   IFD1,X'70'          = ?
         BNE   IFBFLOAT            No, sorry
         $ADD  4,IFGMCNT1          Add code to goto CONTAIN
         B     IFGENTST            Go add code to test result
*---------------------------------------------------------------------+
*        Generate code to test the result of the compare              |
*---------------------------------------------------------------------+
*
IFGENTST $ADD  IFGM999-IFGMBAL2,IFGMBAL2 Add code to test result
         LA    R1,IFGMTAAD-IFGMBAL2(,R1) Point at true/and Adcon
         ST    R1,IFTADSV          And save it
         LA    R1,IFGMTEST-IFGMTAAD(,R1) Point at BCR inst
         ST    R1,IFBCRSV          And save it
         OC    1(1,R1),IFD1        Set correct mask bits
         EJECT
*---------------------------------------------------------------------+
*        Code generation complete, see what to do next                |
*---------------------------------------------------------------------+
*
IFGDONE  TM    PCTF4,IFDONEW       Word 'gotten' already?
         BO    IFGDONE2            Yes, don't do it again then
         $CALL GETNEXT             Go get another word
*
IFGDONE2 NI    PCTF4,255-IFDONEW   Reset the flag
         TM    WFLAG1,WPREF+WWRD2+WTRLR Eliminate invalid sub-operands
         BNZ   IFBREL              .
         TM    WFLAG1,WWRD1        Better have this one
         BZ    IFBREL              Nope, sorry
         TM    WRD1F2,OPRKW+OPRKWV Valid Keyword?
         BZ    IFBREL              Nope, sorry
         LA    R14,WRD1KW1         Point at KW answer area
         TM    KWF1,KWNOISE        Eliminate 'noise' words
         BO    IFGDONE             .
         TM    KWF1,KWIFTRU        Valid in context?
         BZ    IFBREL              No, sorry
         L     R2,KWD2             Get addr of routine
         BR    R2                  And go to it
*
IFOR     BAL   R14,IFAATRU         Go add to TRUE chain
         $ADD  0,*                 Get current inst counter
         BAL   R14,IFANDCLR        Make AND's point here
         NI    PCTF3,255-OPKWLEN   .
         B     IFNEXTC             And loop back
*
IFAND    BAL   R14,IFAAAND         Go add to AND chain
         L     R14,IFBCRSV         Get address of last BCR inst
         XC    1(1,R14),FOXZERO    Reverse mask bits
         NI    PCTF3,255-OPKWLEN   .
         B     IFNEXTC             And loop back
*
IFDO     MVC   IFEXR,=A(MAINGEOS-8) Set exit address
         NI    PCTF4,255-IFNXSENT  Clear complete next sentence
         B     IFCMDCM
*
IFGOTO   MVC   IFEXR,=A(GOTO)      Set exit address
         B     IFCMDCM
*
IFALTER  MVC   IFEXR,=A(ALTER)     Set exit address
         B     IFCMDCM
*
IFCLOSE  MVC   IFEXR,=A(CLOSE)     Set exit address
         B     IFCMDCM
*
IFDEBUG  MVC   IFEXR,=A(DEBUG)     Set exit address
         B     IFCMDCM
*
IFGNEXT  MVC   IFEXR,=A(NEXTREC)   Set exit address
         B     IFCMDCM
*
IFGOSUB  MVC   IFEXR,=A(GOSUB)     Set exit address
         B     IFCMDCM
*
IFGOBACK MVC   IFEXR,=A(GOBACK)    Set exit address
         B     IFCMDCM
*
IFSELECT MVC   IFEXR,=A(SELECT)    Set exit address
         EJECT
*---------------------------------------------------------------------+
*        Generate close off code for the IF                           |
*---------------------------------------------------------------------+
*
IFCMDCM  BAL   R14,IFAATRU         Add to true chain
         $ADD  0,*                 Get currect inst counter
         BAL   R14,IFANDCLR        Point all AND's here
         $ADD  6,IFGMLDNS          Stuff in GOTO next sentence
         $ADD  0,*                 Get current inst counter
         BAL   R14,IFTRUCLR        Point all TRUE's here
*
IFCMDEX  L     R8,IFEXR            Go to continue address
         B     8(R8)               Enter it
         EJECT
*---------------------------------------------------------------------+
*        Stack routines for TRUE/AND address chains                   |
*---------------------------------------------------------------------+
*
IFAAAND  L     R1,IFANDCH          Get start of 'AND' table
         L     R0,IFTAEND          Get end address of table
         SH    R0,=H'4'            - 1
         B     IFAATL              And enter common code
*
IFAATRU  L     R1,IFTRUCH          Get start of 'TRUE' table
         L     R0,IFANDCH          Get end address of table
         SH    R0,=H'4'            - 1
*
IFAATL   CLC   0(4,R1),=4X'FF'     At end yet
         BE    IFAATF              Yes
         LA    R1,4(,R1)           No, bump
         B     IFAATL              And loop back
*
IFAATF   CR    R1,R0               Check for overflow
         BNL   IFTCMPLX            Too complex
         MVC   0(4,R1),IFTADSV     Save address
         MVC   4(4,R1),=4X'FF'     Set new end marker
         BR    R14
*---------------------------------------------------------------------+
*        Process TRUE/AND address stacks                              |
*---------------------------------------------------------------------+
*
IFTRUCLR L     R2,IFTRUCH          Get address of tbl
*
IFTRULP  CLC   0(4,R2),=4X'FF'     End yet?
         BE    IFTRURST            Yes, leave
         L     R3,0(R2)            Point at Adcon loc
         ST    R1,0(R3)            Stuff it
         LA    R2,4(,R2)           Bump to next
         B     IFTRULP             And loop
*
IFTRURST L     R2,IFTRUCH          Get start of tbl
         MVC   0(4,R2),=4X'FF'     Reset to null
         BR    R14
*
IFANDCLR L     R2,IFANDCH          Get address of tbl
*
IFANDLP  CLC   0(4,R2),=4X'FF'     End yet?
         BE    IFANDRST            Yes, leave
         L     R3,0(R2)            Point at Adcon loc
         ST    R1,0(R3)            Stuff it
         LA    R2,4(,R2)           Bump to next
         B     IFANDLP             And loop
*
IFANDRST L     R2,IFANDCH          Get start of tbl
         MVC   0(4,R2),=4X'FF'     Reset to null
         BR    R14
         EJECT
*---------------------------------------------------------------------+
*        IF error message routines                                    |
*---------------------------------------------------------------------+
*
IFNERR   $ERR  BADN,8,SKIP
*
IFBIF    $ERR  BIF,8,SKIP
*
IFBREL   $ERR  IFREL,8,SKIP
*
IFFLOATR $ERR  FLOAT,8,SKIP
*
IFBFLOAT $ERR  BFLOAT,8,SKIP
*
IFIMASK  $ERR  IMASK,8,SKIP
*
IFIMASK1 $ERR  IMASK1,8,SKIP
*
IFTCMPLX $ERR  TCMPL,8,SKIP
         EJECT
*---------------------------------------------------------------------+
*        IF routine work areas                                        |
*---------------------------------------------------------------------+
IFD1     DC    A(0)                Saved value of KWD1 from KW lookup
IFTRUCH  DC    A(0)                Table of TRUE Adcons to stuff
IFANDCH  DC    A(0)                Table of AND Adcons to stuff
IFTAEND  DC    A(0)                End of TRUE/AND tables
IFTADSV  DC    A(0)                Address of true Adcon for this blk
IFBCRSV  DC    A(0)                Address of BCR inst for this block
*
IFGMBAL1 BAL   R10,COMP10X4        Get over the next sentence Adcon
IFGMNSAD DC    4X'00'              Next sentence Adcon
*
IFGMCLC  EX    OREG,COMPCLC        Execute the CLC
IFGMCP   EX    OREG,COMPCP         Execute the CP
IFGMLR0  ICM   R0,15,0(AREG)       Get value into R0
IFGMLR1  ICM   R1,15,0(BREG)       Get value into R1
IFGMCR   EX    0,COMPCR            Execute the CR
*
IFGMTM1  IC    BREG,0(BREG)        Get the immediate data into BREG
IFGMTM2  EX    BREG,COMPTM         EXecute a TM instruction
*
IFGMCNT1 BAL   R14,CONTAINS        Go let CONTAINS test it
*
IFGMMSK1 EX    OREG,COMPMSK1       Move literal to work area
IFGMMSK2 EX    OREG,COMPMSK2       Translate to 00 or FF
IFGMMSK3 EX    OREG,COMPMSK3       AND in chars to compare
IFGMMSK4 EX    OREG,COMPMSK4       Now do the compare
*
IFGMLDNS L     R14,0(R10)          Get address of next sentence
IFGMGONS BR    R14                 And go to it
*
IFGMBAL2 BAL   R7,COMP7X4          Get pointer to TRUE/AND adcon
IFGMTAAD DC    4X'00'              TRUE/AND Adcon
IFGMLDGT L     R14,0(R7)           Get address to GOTO
IFGMTEST BCR   0,R14               Test result (mask is stuffed later)
IFGM999  EQU   *
         DROP  R14
         $PEND
         TITLE 'INISLECT - Set basic program mode'
*---------------------------------------------------------------------+
*        Select mode based on what combination of DD's found          |
*---------------------------------------------------------------------+
*
INISLECT $PROC
         TM    PCTF1,DFLTFLAG      Has DFLTFLAG been set for PARM?
         BO    INISEX              Yes, go compile the PARM field
         TM    PCTF2,DSYSIN        If SYSIN is present and not DUMMY
         BO    INISEX              Return to do compile
*
INICHOOX TM    PCTF2,DINPUT1+DOUTPUT1 If both INPUT1 and OUTPUT1 here
         BO    INICOPY             Go setup for COPY ALL default
         TM    PCTF2,DINPUT1+DSYSPRT If INPUT1 and SYSPRINT then
         BO    INIDUMP             Go setup for DUMP ALL default
         $ERR  NULLR,12,GO=ADDSTATS,FLAG=NO Say why exist and terminate
*
INICOPY  OI    PCTF1,DFLTFLAG      Set flag to show defaults are used
         OI    PCTF6,TRYFAST       Force to test for fast copy route
         B     INISEX              Return now
*
INIDUMP  OI    PCTF1,DFLTFLAG      Set default flag
         MVC   GETDPTRS+4(4),GETDPTRS+12 Setup dump default
*
INISEX   $RET   0                  Return (Back to do compile)
         TITLE 'INITIODD - Initialize our own DDnames'
*---------------------------------------------------------------------+
*        Initialize SYSPRINT                                          |
*---------------------------------------------------------------------+
*
INITIODD $PROC
         PUSH  USING               Temporarily use R1 to
         DROP  R7
         USING FCBDSECT,R1         Address FCB's
*
INIPRINT L     R2,=A(MDLSODCB)     Point at model DCB
         MVC   DCBEXLST(3,R2),=AL3(PRXLST) Setup SYSPRINT EXLST
         OI    PCTF3,DCBOPT        Say DCB is optional
         $CALL DCBO1BLD,MDSYSP     Go build I/O blocks
         B     INIUT1              +0 no DD found/OPEN failed
         LA    R15,PCTPFCB         Point at print FCB save area
         ST    R1,0(R15)           Save address of print FCB
         LA    R2,FCBDCB           Point at DCB
         ST    R2,PCTPDCB          Save it's address
         OI    PCTF2,DSYSPRT       Flag as SYSPRINT present
         EJECT
*---------------------------------------------------------------------+
*        Initialize INPUT1                                            |
*---------------------------------------------------------------------+
*
INIUT1   L     R2,=A(MDLSODCB)     Reset output model to normal
         MVC   DCBEXLST(3,R2),=AL3(UT2LIST) Reset normal EXLST
         OI    PCTF3,INPUT+DCBOPT  Set to optional input file
         $CALL DCBI1BLD,MDINPT1    Go build I/O control blocks
         B     INIUT2              +0 no DD found/OPEN failed
         ST    R1,PCT1FCB          Save address of INPUT1 FCB
         ST    R1,PCTIPFCB         Set as 1st input FCB address
         OI    PCTF2,DINPUT1       Flag as present
         LA    R2,FCBDCB           Point at DCB itself
         ST    R2,PCT1DCB          Save it
         MVC   DEFRECFM,FCBRECFM   Save default DCB parameters
         MVC   DEFLRECL,FCBLRECL   .
         MVC   DEFBLKSI,FCBBLKSI   .
         CLC   DEFLRECL,ZEROS      Zero LRECL (RECFM=U)??
         BNE   *+10                No
         MVC   DEFLRECL,DEFBLKSI   Yes, use BLKSIZE
         L     R2,=A(LINHD1T)      Get address of pghead title area
         MVC   0(54,R2),FCBDSNAM   Stuff in DSNAME as default
         EJECT
*---------------------------------------------------------------------+
*        Initialize OUTPUT1                                           |
*---------------------------------------------------------------------+
*
INIUT2   MVC   DDNAME,MDOUTP1+2    Setup for OUTPUT1
         NI    PCTF3,255-INPUT     Remove official INPUT status
         DEVTYPE DDNAME,DEVTAB     See if DD is present
         LTR   R15,R15             Well?
         BNZ   INISYSIN            No, skip to SYSIN
         OI    PCTF2,DOUTPUT1      Yes, flag as present
*---------------------------------------------------------------------+
*        Initialize SYSIN                                             |
*---------------------------------------------------------------------+
*
INISYSIN L     R2,=A(MDLSIDCB)     Point at model DCB
         MVC   DCBEXLST(3,R2),=AL3(INXLST) Setup SYSIN EXLST
         OI    PCTF3,DCBOPT        Say DCB is optional
         $CALL DCBI1BLD,MDSYSI     Go build I/O control blocks
         B     INIMCLR             +0 no DD found/open failed
         ST    R1,PCTIFCB          Save address of SYSIN FCB
         LA    R2,FCBDCB           Point at DCB
         ST    R2,PCTIDCB          Save it's address
         MVC   DCBEODAD(3,R2),=AL3(GETWEODT) Set EOD address
         TM    FCBDCB+17,X'4F'     Is SYSIN a TERMFILE?
         BNO   INIDMY              No, go see if DUMMY
         LR    R2,R1               Save R1 over TPUT
         TPUT  TSOREADY,L'TSOREADY Prompt TSO user
         LR    R1,R2               Restore R1
         B     INIIDN              Go say SYSIN is here
*
INIDMY   CLC   FCBDSNAM(9),=C'NULLFILE ' Dummied?
         BE    INIMCLR             Yes, treat as not here
*
INIIDN   OI    PCTF2,DSYSIN        Flag as present
*
INIMCLR  L     R2,=A(MDLSIDCB)     Point at model DCB
         MVC   DCBEXLST(3,R2),=AL3(UT1LIST) Reset normal exlst
         POP   USING               Restore normal usings
         $RET  0
         $PEND
         TITLE 'INITPROC - Initialization routines'
*---------------------------------------------------------------------+
*        Build some data about job for page headings.                 |
*---------------------------------------------------------------------+
*
INITPROC $PROC
         $CALL KWRDINIT            Go initialize the KW table
         EXTRACT WKTIOT,FIELDS=(TSO,TIOT)
         L     R1,WKTIOT+4         Get TSO word
         TM    0(R1),X'80'         TSO?
         BZ    *+8                 No, skip over
         OI    PCTF1,TSOSTEP       Yes, flag it
         $CALL TIMEPROC            Go get date and time
         L     R1,16               -> CVT
         L     R9,204(R1)          -> CCVT (Leave in R9)
         LA    R7,PCT              -> PCT
         L     R1,WKTIOT           Get TIOT address
         L     R2,=A(LINHD1)       Get address of 1st page head
         MVC   11(4,R2),PCTVERNO   Move in version number
         MVC   38(8,R2),0(R1)      Complete with JOB/$PROC/STEP names
         MVI   46(R2),C'/'         .
         MVC   47(8,R2),8(R1)      .
         CLC   16(8,R1),BLANKS     .
         BE    *+14                .
         MVI   55(R2),C'/'         .
         MVC   56(8,R2),16(R1)     .
         MVC   19(3,R2),TIMEWORK+10 Month
         MVC   23(2,R2),TIMEWORK+8  Day
         MVI   25(R2),C'/'
         MVC   26(2,R2),TIMEWORK+13 Year
         MVC   29(5,R2),TIMEWORK+24 Time
         L     R15,X'21C'          -> TCB
         TM    20(R15),X'84'       Test mode?
         BNZ   INITPEX             Yes, skip STAE
         STAE  ABNDEXIT,,PARAM=PCT Setup to trap ABENDS
         LTR   R15,R15             Accepted?
         BZ    STAEOK              Yes
         $ERR  NOSTA,12,GO=ADDSTATS,FLAG=NO No, issue msg
*
STAEOK   STM   R0,R15,STAESAVE     Save good set of regs
*
INITPEX  $RET  0                   Done
         $PEND
         TITLE 'INTLBLS - Generate internal labels'
*---------------------------------------------------------------------+
*        Labels 'RETURN' and 'EOJ' are inserted here                  |
*---------------------------------------------------------------------+
*
INTLBLS  $PROC
         CLC   LBLOUT,ZEROS        Any unresolved labels?
         BE    INTNRETN            No, dont put RETURN in
         $CALL LBLGEN,INTRETN      Go put label into pgm
*
INTNRETN $CALL DBGADD              Go add DEBUG code
         $ADD  INTG499-INTGRET1,INTGRET1 Then put in pgm code
         LA    R2,INTGREST-INTGRET1(,R1) Point at resume address
         ST    R2,INTGRESM-INTGRET1(,R1) Stuff in code
         MVC   INTGFCBA-INTGRET1(4,R1),PCT1FCB Stuff in INPUT1 FCB
         MVC   INTGRESM-INTGRET1(1,R1),PCTBFCDF Stuff in COPYBUFF def.
         LA    R2,INTGEOFA-INTGRET1(,R1)
         L     R3,=A(NXTEOFD)
         $CALL LBLOGEN,(R3),(R2)
         LA    R2,PCTIPEOF
         L     R3,=A(NXTEOFD)
         $CALL LBLOGEN,(R3),(R2)
         CLC   LBLOUT,ZEROS        Any unresolved labels?
         BE    INTNEOJ             No, don't put EOJ in
         $CALL LBLGEN,INTEOJ       And EOJ label
*
INTNEOJ  $ADD  8,INTGEOJ1          Stuff in GOTO EOJ
         $RET  0                   Return
*
*---------------------------------------------------------------------+
*        Internal label creation work areas                           |
*---------------------------------------------------------------------+
         CNOP  2,4
*
INTGRET1 BALR  R15,0               Get locally addressable
INTGSAVE MVC   PCTPGMS,PCTPGM      Save PCTPGM address
INTGSWAP MVC   PCTPGM,INTGRESM-INTGSAVE(R15) Swap in our resume address
INTGBALR BAL   R15,COPRETN-COPYDATA(R8) Go to COPRETN to read record
INTGRESM DC    XL4'00'             Address of code to resume at
INTGFCBA DC    A(0)                Address of FCB area
INTGEOFA DC    A(ADDSTATS)         Address of EOF label
INTGREST MVC   PCTPGM,PCTPGMS      Restore original PCTPGM address
INTGLADD L     R14,PCTPGM          Get PCTPGM address
INTGBR   BR    R14                 And go to it
INTG499  EQU   *                   End of model code
         CNOP  0,4
*
INTGEOJ1 BAL   R14,COMPGOTO        Off to the GOTO support
INTGEOJ2 DC    A(ADDSTATS)         Adcon
INTRETN  DC    H'6',CL10'RETURN'
INTEOJ   DC    H'3',CL10'EOJ'
*
         DS    0F
INTULADD BAL   R14,COMPGOTO        Use GOTO support routine
INTUADCN DC    4X'00'              Adcon
         $PEND
         TITLE 'JFCNAME - Build full DSNAME for messages'
*---------------------------------------------------------------------+
*        Pretty up the DSNAME in an FCB area                          |
*        ===================================                          |
*                                                                     |
*        Called:   $CALL JFCNAME,fcb                                  |
*                                                                     |
*        Operands: fcb     - the address of the FCB to be processed   |
*                                                                     |
*        Returns +0 on completion                                     |
*---------------------------------------------------------------------+
*
JFCNAME  $PROC 1                   One param passed
         L     R7,12(R8)           Get FCB address
         MVC   FCBDSNAM,FCBJFCB    Put in DSNAME from JFCB
         MVC   FCBDSNAM+44(10),BLANKS Blank rest
         TM    FCBJFCB+86,X'01'    Member ??
         BZ    JFCNEX              No, we're done, go back now
         L     R15,=A(TRTBLB)      Point at TRT table
         TRT   FCBDSNAM(45),0(R15) Look for blank (must be there)
         MVI   0(R1),C'('          Now build member name
         MVC   1(8,R1),FCBJFCB+44  .
         TRT   1(9,R1),0(R15)      .
         MVI   0(R1),C')'          .
*
JFCNEX   $RET  0                   And leave
         $PEND
         TITLE 'KWRDINIT - Keyword Table Initialize'
*---------------------------------------------------------------------+
*        Initialize the KW lookup table                               |
*        ==============================                               |
*                                                                     |
*        Called:   $CALL KWRDINIT                                     |
*                                                                     |
*        Operands: none.                                              |
*                                                                     |
*        Returns:  +0 on completion                                   |
*                                                                     |
*        Notes:    This routine must be called before any KW lookups  |
*                  are performed. It's purpose is to initialize the   |
*                  lookup hash table.                                 |
*---------------------------------------------------------------------+
*
KWRDINIT $PROC
         L     R4,=A(KWTBL)        Get address of KW table
         LA    R5,KWTBLL/KWENTL    Get number of entries in table
         USING KWDSECT,R4
*
KWRDILP  L     R6,=A(KWHASH)       Get address of KW hash table
         ICM   R1,15,KWL           Hash the KW name
         X     R1,KWL+4            .
         X     R1,KWL+8            .
         SR    R0,R0               Clear R0 for divide
         D     R0,=F'67'           Calc hash table index
         SLL   R0,2                Index x 4
KWDT1    AR    R6,R0               Add hash table address
         LR    R15,R6              Swap regs
         ICM   R6,15,0(R15)        Find end of chain
         BNZ   *-6                 .
         ST    R4,0(R15)           Stuff entry into chain
         LA    R4,KWENTL(,R4)      Next KW entry
         BCT   R5,KWRDILP          Loop till all done
         $RET  0
         $PEND
         DROP  R4
         TITLE 'KWRDSRCH - Keyword Search Routine'
*---------------------------------------------------------------------+
*        Lookup a word in the KW table.                               |
*        ==============================                               |
*                                                                     |
*        Called:   $CALL KWRDSRCH,word,answer                         |
*                                                                     |
*        Operands: word     - A standard 'word' area.                 |
*                              i.e.  H'nn',C'text'                    |
*                                                                     |
*                  answer   - KW answer area. See KWDSECT for the     |
*                             mapping of this area.                   |
*                                                                     |
*        Returns:  +0 if not found                                    |
*                  +4 if found                                        |
*                                                                     |
*        Notes:    The routine KWRDINIT must be called BEFORE any     |
*                  call to this routine.                              |
*---------------------------------------------------------------------+
*
KWRDSRCH $PROC 2                   Receives 2 parameters
         STM   R1,R3,KWRDSAVE      Save the regs we use
         L     R1,16(R8)           Get address of area to receive ans
         MVC   0(KWENTL,R1),ZEROS  Clear the answer area
         L     R3,12(R8)           Point at name to be found
         L     R2,=A(KWHASH)       Get address of KW hash table
         MVC   KWRDWORK+2(10),=CL10' '
         LH    R1,0(R3)            Get length of search arg
         CH    R1,=H'10'           Test against max KW length
         BH    KWMISS              Too long, pass back 'not found'
         LA    R1,1(,R1)           Adjust it
         EX    R1,*+4              Move it
         MVC   KWRDWORK(0),0(R3)   .
*---------------------------------------------------------------------+
*        Hash the name to be looked up.                               |
*---------------------------------------------------------------------+
         ICM   R1,15,KWRDWORK      Hash up the name
         X     R1,KWRDWORK+4       .
         X     R1,KWRDWORK+8       .
         SR    R0,R0               Get ready for divide
         D     R0,=F'67'           Calc hash table index
         SLL   R0,2                Remainder x 4
         AR    R2,R0               Add hash table address
         USING KWDSECT,R2
*---------------------------------------------------------------------+
*        Search the hash chains for the name.                         |
*---------------------------------------------------------------------+
*
KWRDCHN  ICM   R2,15,KWCHAIN       Chain to next
         BZ    KWMISS              If zero then not found
         CLC   KWRDWORK(12),KWL    Is this the one?
         BNE   KWRDCHN             No, point at next in chain
         L     R1,16(R8)           Get address of area to receive ans
         MVC   0(KWENTL,R1),KWCHAIN Pass back the answer
         CP    COMNTCTL,=P'0'      In comment/skip mode?
         BNE   KWRDEX              Yes, don't test comment words.
*
KWRDEX   LM    R1,R3,KWRDSAVE      Reload regs
         $RET  4                   Exit found
*
KWMISS   LM    R1,R3,KWRDSAVE      Reload regs
         $RET  0                   Return +0 for an error
KWRDSAVE DS    3F
KWRDWORK DS    H'0',CL10' '
         DROP  R2
         $PEND
         TITLE 'LBLGEN - Label generate/lookup routines'
*---------------------------------------------------------------------+
*        Add an entry to the label table pointing at current I.C.     |
*        ========================================================     |
*                                                                     |
*        Called:   $CALL LBLGEN,word                                  |
*                                                                     |
*        Operands: word     - is standard 'word' format               |
*                               i.e. H'nn',C'text'                    |
*                                                                     |
*        Returns:  +0 on completion                                   |
*---------------------------------------------------------------------+
*
LBLGEN   $PROC 1
         L     R1,12(R8)           Get address of passed parameter
         LH    R2,0(R1)            Pickup length of label
         BCTR  R2,0                Less 1 for EX command
         CH    R2,=H'7'            Too long?
         BNH   *+8                 No
         LA    R2,7                Yes, force it to 8 bytes
         MVC   LBLHOLD,BLANKS      Clear hold area
         CLC   0(2,R1),=H'10'      Over max in-line data?
         BNH   LBLGENM             No, continue
         ICM   R1,15,2(R1)         Yes, get pointer to data
         SH    R1,=H'2'            Adjust it
*
LBLGENM  EX    R2,*+4              Move passed label
         MVC   LBLHOLD(0),2(R1)    .
         ICM   R4,15,LBLIN         Get start of label in table
         BNZ   LBLSLOOP            Search it if we have one
         GETMAIN R,LV=2040,SP=1    Else, get 1st block
         LR    R4,R1               Put it in R4
         ST    R1,LBLIN            And save it
         MVC   LBLINCT,=F'170'     Set max avail. count in area
         MVI   0(R4),X'FF'         Set end flag at start of table
*
LBLSLOOP CLI   0(R4),X'FF'         Is this the end
         BE    LBLTEND             Yes, go stuff in new label
         CLI   0(R4),X'FE'         No, maybe its a chain flag
         BNE   *+12                Not this, try equal labels
         L     R4,8(R4)            Its a chain, pick it up
         B     LBLSLOOP            And keep searching
         CLC   LBLHOLD,0(R4)       Is it a duplicate label
         BNE   LBLSBMP             No, keep looking for end of table
         $ERR  LBLDP,8             Flag with warning message
*
LBLGEX   $RET  0                   And return
*
LBLSBMP  LA    R4,12(,R4)          Bump up to next entry
         B     LBLSLOOP            And continue search
*
LBLTEND  L     R2,LBLINCT          See how many entries left in table
         CH    R2,=H'2'            Almost at end
         BL    LBLCHN              Yes, go get a new area and chain it
         BCTR  R2,0                Reduce number remaining
         ST    R2,LBLINCT          And save it
         $ADD  0,*                 Go get current inst. counter
         ST    R1,8(R4)            Put it in entry
         MVC   0(8,R4),LBLHOLD     Put in the label
         MVI   12(R4),X'FF'        Put new end DLM in next entry
         B     LBLGEX              And exit
*
LBLCHN   MVI   0(R4),X'FE'         Make this a chain entry
         GETMAIN R,LV=2040         Get another block
         ST    R1,8(R4)            Put its address in chain area
         MVC   LBLINCT,=F'170'     Reset number entries
         LR    R4,R1               Swap regs
         MVI   0(R4),X'FF'         Make it look like end of tbl
         B     LBLTEND             Re-enter normal logic
         $PEND
         TITLE 'LBLOGEN - Add entry to unresolved table'
*---------------------------------------------------------------------+
*        Add an entry to the unresolved label table                   |
*        ==========================================                   |
*                                                                     |
*        Called:   $CALL LBLOGEN,word,address                         |
*                                                                     |
*        Operands: word     - is standard 'word' format               |
*                               i.e. H'nn',C'text'                    |
*                                                                     |
*                  address  - address of the fullword to eventually   |
*                             be completed with the address of the    |
*                             label in 'word'                         |
*                                                                     |
*        Returns:  +0 on completion                                   |
*---------------------------------------------------------------------+
*
LBLOGEN  $PROC 2                   Passed 'word', address as parameters
         L     R1,12(R8)           Get address of word
         LH    R2,0(R1)            Pickup length of label
         BCTR  R2,0                Less 1 for EX command
         CH    R2,=H'7'            Too long?
         BNH   *+8                 No
         LA    R2,7                Yes, force it to 8 bytes
         MVC   LBLHOLD,BLANKS      Clear hold area
         CLC   0(2,R1),=H'10'      Over max in-line data?
         BNH   LBLOGENM            No, continue
         ICM   R1,15,2(R1)         Yes, get pointer to data
         SH    R1,=H'2'            Adjust it
*
LBLOGENM EX    R2,*+4              Move passed label
         MVC   LBLHOLD(0),2(R1)
         ICM   R4,15,LBLOUT        Get start of label in table
         BNZ   LBLOSLP             Search it if we have one
         GETMAIN R,LV=2033,SP=1    Else, get 1st block
         LR    R4,R1               Put it in R4
         ST    R1,LBLOUT           And save it
         MVC   LBLOUTCT,=F'107'    Set max avail. count in area
         MVI   0(R4),X'FF'         Set end flag at start of table
*
LBLOSLP  CLI   0(R4),X'FF'         Is this the end
         BE    LBLOTEND            Yes, go stuff in new label
         CLI   0(R4),X'FE'         No, maybe its a chain flag
         BNE   LBLOSBMP            No, keep looking for end
         L     R4,8(R4)            Its a chain, pick it up
         B     LBLOSLP             And keep searching
*
LBLOSBMP LA    R4,19(,R4)          Bump up to next entry
         B     LBLOSLP             And continue search
*
LBLOTEND L     R2,LBLOUTCT         See how many entries left in table
         CH    R2,=H'2'            Almost at end
         BL    LBLOCHN             Yes, go get a new area and chain it
         BCTR  R2,0                Reduce number remaining
         ST    R2,LBLOUTCT         And save it
         L     R1,16(R8)           Go get address to be completed
         ST    R1,8(R4)            Put it in entry
         MVC   0(8,R4),LBLHOLD     Put in the label
         MVC   12(3,R4),GETCTR1    Put in statement number
         MVC   15(3,R4),GETCTR2    Put in word no
         MVI   19(R4),X'FF'        Put new end DLM in next entry
         $RET  0                   And exit, we're done
*
LBLOCHN  MVI   0(R4),X'FE'         Make this a chain entry
         GETMAIN R,LV=2033         Get another block
         ST    R1,8(R4)            Put its address in chain area
         MVC   LBLOUTCT,=F'107'    Reset number entries
         LR    R4,R1               Swap regs
         MVI   0(R4),X'FF'         Make it look like end of tbl
         B     LBLOTEND            Re-enter normal logic
         $PEND
         TITLE 'LBLRESLV - Process unresolved labels'
*---------------------------------------------------------------------+
*        Process unresolved label table                               |
*---------------------------------------------------------------------+
*
LBLRESLV $PROC
         ICM   R1,15,LBLOUT        Get start of unresolved labels
         BZ    LBLRDONE            None? exit
*
LBLRESL1 CLI   0(R1),X'FF'         End of table?
         BE    LBLRDONE            Yes, we're done
         CLI   0(R1),X'FE'         Chain to new GETMAIN block?
         BNE   *+12                No, go process it
         L     R1,8(R1)            Yes, load address of next block
         B     LBLRESL1            And loop back
         ICM   R2,15,LBLIN         Now get address of full label table
         BZ    LBLNOTF             No table, then its unresolved
*
LBLRESL2 CLI   0(R2),X'FF'         End of table?
         BE    LBLNOTF             Yes, then its not there
         CLI   0(R2),X'FE'         Chain to new GETMAIN block?
         BNE   *+12                No, go test this entry
         L     R2,8(R2)            Yes, pickup address of next block
         B     LBLRESL2            And loop back
         CLC   0(8,R1),0(R2)       Do labels match???
         BE    LBLRESFN            Yes, we've found it
         LA    R2,12(,R2)          No, bump to next entry
         B     LBLRESL2            And loop backk
*
LBLRESFN L     R3,8(R1)            Get address to be completed
         MVC   0(4,R3),8(R2)       Move in desired address
         LA    R1,19(,R1)          Bump to next unresolved entry
         B     LBLRESL1            And loop back
*
LBLNOTF  MVC   GETCTR1(6),12(R1)   Stuff back original source loc.
         STM   R1,R2,LBLSV12       Save loop control regs
         $ERR  UNRES,8,FLAG=NO     Issue error message
         LM    R1,R2,LBLSV12       Get back loop control regs
         LA    R1,19(,R1)          Bump to next unresolved
         B     LBLRESL1            And loop back
*
LBLRDONE ICM   R1,15,LBLOUT        Any table to free?
         BNZ   LBLRFREE            Yes, go free it
         ICM   R1,15,LBLIN         Any table here?
         BZ    LBLREX              No, we can leave
*
LBLRFREE FREEMAIN R,SP=1           Yes, free it/them
*
LBLREX   $RET  0                   And then leave
         $PEND
         TITLE 'LITPOOL - Process literals'
*---------------------------------------------------------------------+
*        Decode and generate a Literal in the Literal pool            |
*        =================================================            |
*                                                                     |
*        Called:   $CALL LITPOOL,word                                 |
*                                                                     |
*        Operands: word     - is standard 'word' format               |
*                               i.e. H'nn',C'text'                    |
*                                                                     |
*        Returns:  +0   Success                                       |
*                  +4   Bad literal type                              |
*                  +8   Odd number or invalid hex characters          |
*                  +12  Incorrect length specified                    |
*                  +16  Incorrect use of quotes                       |
*                  +20  Non-numeric value in numeric literal          |
*                                                                     |
*        Notes:    All answers are in the following areas:            |
*                                                                     |
*                  LITL     - Length of the Literal                   |
*                  LITT     - The type of literal (C,X,P,F,H)         |
*                  LITA     - The absolute address of the literal.    |
*---------------------------------------------------------------------+
*
LITPOOL  $PROC 1
         L     R7,12(R8)           Pickup passed param address
         MVC   LITR,=F'1'          Set default repeat count
*
LITREDO  LH    R0,0(R7)            R0 - length of input
         LA    R1,2(,R7)           R1 - address of input
         CH    R0,=H'10'           If length > 10 then get pointer
         BNH   *+8                 No, skip
         ICM   R1,15,2(R7)         Yes, load it's pointer
         ST    R1,LITSTRTT         Save start of text address
         LR    R14,R1              Put addr in usable reg
         LR    R3,R0               Ditto for length
         BCTR  R3,0                Convert length for EX
         L     R15,=A(TRTBLQ)      Point at TRT table
         EX    R3,LITFQ            Look for 1st quote
         BNZ   LIT1Q               Got the 1st one
*
LITQERR  $RET  16                  Return +16
*
LIT1Q    ST    R1,LIT1STQ          Save its address
         LR    R2,R14              Setup to scan out repeat factor
         L     R15,=A(TRTBLN)      .
         TM    0(R2),X'F0'         Leading numeric
         BNO   LIT1QO              No, no repeat factor then
         EX    R3,LITTR            Extract repeat factor
         LR    R2,R1               .
         SR    R1,R14              .
         BCTR  R1,0                .
         EX    R1,LITRPACK         .
         LH    R15,0(R7)           Adjust WORD length
         SR    R15,R1              .
         BCTR  R15,0               .
         STH   R15,0(R7)           .
         BCTR  R15,0               Shift WORD
         L     R3,LITSTRTT         Pick up addr. of start of lit. text
         MVC   0(0,R3),0(R2)       .
         EX    R15,*-6             .
         CVB   R1,DBL              Binary repeat factor
         ST    R1,LITR             Save it
         B     LITREDO             Continue as if not there
*
LIT1QO   LR    R2,R14              Put start of data in R2
         AR    R2,R0               And add length
         BCTR  R2,0                Backup one to get last char
         ST    R2,LIT2NDQ          Save its address
         CLI   0(R2),C''''         See if its really a quote
         BNE   LITQERR             No, possible error
         BCTR  R2,0                Backup one
         C     R2,LIT1STQ          Make sure its not a null lit
         BE    LITQERR             If it is reject it
         LR    R1,R14              Get back start of data
         C     R1,LIT1STQ          Start with a quote?
         BE    *+8                 Yes, skip looking for length operand
         BAL   R14,LITCHEKL        Go check length operand
         LM    R2,R3,LIT1STQ       Lets setup regs for data portion
         SR    R3,R2               Calc length
         BCTR  R3,0                Minus one
         LA    R2,1(,R2)           Step over opening quote
         LH    R4,LITLGTH          Pickup length operand length
         LTR   R4,R4               Zero?
         BNZ   LITNOLGT            No, there was a length operand, skip
         LR    R4,R3               Else set to length of data
         C     R1,LIT1STQ          Start with a quote?
         BE    LITDFALT            Yes, default to C type literal
         B     LITNOLGT            Continue
         EJECT
*---------------------------------------------------------------------+
*        Check type of literal request                                |
*---------------------------------------------------------------------+
*
LITNOLGT MVC   LITT,0(R1)          Save type of literal for caller
         CLI   0(R1),C'C'          Then see what it is
         BE    LITC
         CLI   0(R1),C'P'
         BE    LITP
         CLI   0(R1),C'X'
         BE    LITX
         CLI   0(R1),C'H'
         BE    LITH
         CLI   0(R1),C'F'
         BE    LITF
*
LITBTYPE $RET  4                   Return +4
*---------------------------------------------------------------------+
*        Check for, and process literal length operand                |
*---------------------------------------------------------------------+
*
LITCHEKL MVC   LITLGTH,ZEROS       Reset length
         CLI   1(R1),C'L'          Is there a length operand
         BE    LITLEXTR            Yes go extract it
         CLI   1(R1),C''''         If no L then next must be quote
         BER   R14                 Yes, return with zero length
*
LITLERR  $RET  12                  Return +12
*
LITLEXTR L     R2,LITZERO          Set reg to C'0000'
         LA    R3,2(R1)            Setup for loop
*
LITLNXT  CLI   0(R3),C'0'          Test numeric
         BL    LITLERR
         CLI   0(R3),C'9'
         BH    LITLERR
         SLL   R2,8                Its numeric, make room in reg
         IC    R2,0(R3)            And insert it
         LA    R3,1(,R3)           Bump reg
         CLI   0(R3),C''''         End of length field?
         BNE   LITLNXT             No, loop back
         ST    R2,LITW1            Store result
         PACK  DBL,LITW1           Pack it
         CVB   R2,DBL              Then to binary
         STH   R2,LITLGTH          And save it
         C     R2,=F'256'          Test for max
         BNHR  R14                 OK, go back
*
LITBL    $RET  12                  Return +12
         EJECT
*---------------------------------------------------------------------+
*        Character type literals                                      |
*---------------------------------------------------------------------+
*
LITC     MVI   LITFILL,C' '        Set fill char
*
LITCDEFF $CALL LITSTUFF            Go find place in literal pool
         $RET  0                   Return +0
*---------------------------------------------------------------------+
*        Packed decimal type literals                                 |
*---------------------------------------------------------------------+
*
LITP     MVI   LITFILL,X'00'       Set fill char
         CLI   0(R2),C'-'          Is value negative?
         BNE   LITPNNEG            No, skip over neg logic
         LA    R2,1(,R2)           Step over sign
         BCTR  R3,0                Adjust length
         BCTR  R3,0                And again
         L     R14,=A(TRTBLN)      Get address of TRT table
         EX    R3,LITTNUM          See if num.
         BNZ   LITNNUM             No
         CH    R3,=H'14'           Length OK?
         BH    LITLERR             No, kill it
         LA    R14,0(R2,R3)        Find low order digit
         MVZ   0(1,R14),=X'D0'     Set overpunch
         B     LITPCOMM
*
LITPNNEG BCTR  R3,0                Set for EX
         CH    R3,=H'14'           Length OK?
         BH    LITLERR             No, kill it
         CLC   LITLGTH,=H'8'       Check override length too
         BH    LITLERR
         L     R14,=A(TRTBLN)      Point at TRT table
         EX    R3,LITTNUM          See if valid numerics
         BNZ   LITNNUM             No, kill it
*
LITPCOMM EX    R3,LITPACK          Yes, process it
         LA    R3,1(,R3)           Set R3 back to actual
         TM    DBL+7,X'0F'         Is sign + (F)
         BNO   *+10                No
         MVN   DBL+7(1),=X'0C'     Yes, make it a + (C)
         SRL   R3,1                Calc number of packed bytes
         LA    R3,1(,R3)
         LA    R2,DBL+8            Now point at correct loc in DBL
         SR    R2,R3
         CLC   LITLGTH,ZEROS       Any  overriding length?
         BNE   LITPSTFF            Yes, use it, its in R4 already
         LR    R4,R3               Else use length of actual data
*
LITPSTFF $CALL LITSTUFF            Go store in literal pool
         $RET  0                   Return +0
         EJECT
*---------------------------------------------------------------------+
*        Full/Halfword type literals                                  |
*---------------------------------------------------------------------+
*
LITF     LA    R4,4                Set length
         OI    PCTF5,FWTYPE        Set sw to say fullword
         B     LITFH               Enter shared logic
*
LITH     LA    R4,2                Set length
*
LITFH    CLI   0(R2),C'-'          Negative value?
         BNE   LITFNNEG            No, skip over neg logic
         LA    R2,1(,R2)           Step over sign
         BCTR  R3,0                Drop length
         BCTR  R3,0                And again
         L     R14,=A(TRTBLN)      Point at TRT table
         EX    R3,LITTNUM          See if numeric
         BNZ   LITNNUM             And reject if not
         LA    R14,0(R2,R3)        Find low order digit
         MVZ   0(1,R14),=X'D0'     Set negative sign
         B     LITFTLG             Go continue testing
*
LITFNNEG BCTR  R3,0                Setup for EX
         L     R14,=A(TRTBLN)      Point at TRT table
         EX    R3,LITTNUM          Is it numeric
         BNZ   LITNNUM             No kill it
*
LITFTLG  CH    R3,=H'14'           Check for max
         BH    LITLERR             Too big reject it
         EX    R3,LITPACK
         CP    DBL,=P'2147483647'  Test fullword limits
         BH    LITNNUM             If outside treat an non numeric
         CP    DBL,=P'-2147483648'
         BL    LITNNUM
         CVB   R0,DBL              Make it binary
*
LITFHTST TM    PCTF5,FWTYPE        Fullword type?
         BO    LITFSTR             Yes
         STH   R0,DBL
         B     LITFSTF             Go stuff it
*
LITFSTR  ST    R0,DBL              Do fullword store
         NI    PCTF5,255-FWTYPE    Reset switch
*
LITFSTF  LA    R2,DBL              Set Ptr to dbl
         LR    R3,R4
         $CALL LITSTUFF            Go store it
         $RET  0                   Return +0
         EJECT
*---------------------------------------------------------------------+
*        Hexadecimal type literals                                    |
*---------------------------------------------------------------------+
*
LITX     MVI   LITFILL,X'00'       Set fill char
         ST    R3,DBL              Put length in memory
         TM    DBL+3,X'01'         Is it an even number
         BNO   LITXEVN             Yes, continue
*
LITBHEX  $RET  8                   Return +8
*
LITXEVN  LR    R5,R2               Setup loop regs
         LR    R9,R2
         SRL   R3,1                Set loop count
*
LITXLOOP L     R14,=A(TRTBLX)      Get address of TR table
         TR    0(2,R9),0(R14)      Translate to 00 to 0F
         TM    0(R9),X'F0'         Test for invalid hex chars
         BO    LITBHEX
         TM    1(R9),X'F0'
         BO    LITBHEX
         PACK  0(0,R5),0(0,R9)     Do LH nibble
         OC    0(0,R5),1(R9)       Do RH nibble
         LA    R5,1(,R5)           Bump up
         LA    R9,2(,R9)
         BCT   R3,LITXLOOP         And loop if more
         LR    R3,R5               Now calc new length
         SR    R3,R2
         CLC   LITLGTH,ZEROS       Was a length coded?
         BNE   LITXSTFF            Yes, use the value in R4
         LR    R4,R3               Else swap it from R3
*
LITXSTFF $CALL LITSTUFF            Go store it
         $RET  0                   Return +0
*
LITNNUM  $RET  20                  Return +20
*
LITDFALT MVI   LITT,C'C'           Setup defaults
         MVI   LITFILL,C' '        .
         MVC   LITLGTH,ZEROS       .
         B     LITCDEFF            Go process with these defaults
*
LITSTRTT DS    F                   Real start of literal text
LITTR    TRT   0(0,R2),0(R15)
LITRPACK PACK  DBL,0(0,R14)
LITFQ    TRT   0(0,R1),0(R15)
         $PEND                     And return
         TITLE 'LITSTUFF - Save things in Literal Pool'
*---------------------------------------------------------------------+
*        Store prosessed literal in the literal pool                  |
*        *** Note: LITSTUFF may be entered to save any                |
*                  value in a getmained area                          |
*                  Calling seq. is -  R2 --> text                     |
*                                  -  R3 --> length of text           |
*                                  -  R4 --> length of text           |
*---------------------------------------------------------------------+
*
LITSTUFF $PROC
         LR    R15,R4              Calc total size of literal
         MH    R15,LITR+2          .
         ST    R15,LITL            Save it
         CH    R15,=H'256'         Too big?
         BH    BADLITBL            Yes, sorry
         STM   R2,R4,LITSRSV       No, save regs for repeat loop
         C     R15,PCTGMLIT        Enough room in this block?
         BNH   LITSTSV             Go store in this block
         GETMAIN R,LV=1024         Go get a block
         L     R15,=A(MAINETRC)    Point at trace flag
         TM    1(R15),X'F0'        Is support active?
         BO    LITNOSUP            No
         L     R15,PCTSUPP2        Get place to store it
         ST    R1,0(R15)           Save it
         OI    0(R15),X'80'        Flag as litpool block
         MVC   4(4,R15),HEXFFS     Stuff in new delim
         LA    R15,4(,R15)         Bump to next slot
         ST    R15,PCTSUPP2        Save for next time
*
LITNOSUP ST    R1,PCTGMLIT+4       Store address of block
         ST    R1,PCTGMLIT+8       Save begin block address
         MVC   PCTGMLIT(4),=F'1024' Set available length
*
LITSTSV  L     R1,PCTGMLIT+4
         ST    R1,LITA             Save absolute address of lit
*
LITSRLP  LR    R9,R1               Get addr in litpool
         AR    R1,R4
         ST    R1,PCTGMLIT+4
         L     R1,PCTGMLIT
         SR    R1,R4
         ST    R1,PCTGMLIT
         CR    R3,R4               More char. than lgth. operand??
         BNH   LITSPST             No, go spread
         SR    R2,R3               Change pointer to input data
         SR    R2,R4
         LR    R3,R4               Show new length of input
*
LITSPST  MVC   0(1,R9),LITFILL
         BCTR  R4,0                Set length for fill spread
         LTR   R4,R4               Is length long enough to need spread
         BZ    LITSPDN             No, skip over
         BCTR  R4,0                Adjust it one more
         EX    R4,*+4              Spread with fill char
         MVC   1(0,R9),0(R9)
         LA    R4,1(,R4)           Put R4 back
*
LITSPDN  CLI   LITFILL,C' '        What kind of align, right or left
         BE    LITSSRDY
         AR    R9,R4               Adjust address for right align
         SR    R9,R3
         LA    R9,1(,R9)
*
LITSSRDY BCTR  R3,0                Adjust for EX
         CR    R3,R4               Select smaller of two regs
         BL    LITSDOEX            R3 is OK use it
         LR    R3,R4               Else load and use R4
*
LITSDOEX EX    R3,*+4              Put in literal pool
         MVC   0(0,R9),0(R2)
         L     R15,LITR            Get repeat count
         BCTR  R15,0               - 1
         ST    R15,LITR            Save repeat count
         LTR   R15,R15             Done?
         BZ    LITSREX             Yes, exit
         LM    R2,R4,LITSRSV       No, reload regs
         L     R1,PCTGMLIT+4       Get next address in pool
         B     LITSRLP             And do it again
*
LITSREX  MVC   LITR,=F'1'          Ensure it defaults to 1
         $RET  0                   Return
         $PEND
         TITLE 'MAINCOMP - Compiler main line'
*---------------------------------------------------------------------+
*        Main  line for the Compile phase                             |
*---------------------------------------------------------------------+
*
MAINCOMP $PROC
         USING KWDSECT,R14
*
MAINNWD  $CALL GETNEXT             Go get next word
*
MAINDATA TM    WFLAG1,WPREF        Is word prefixed?
         BZ    MAINWDS             No, then it's not labelled
         TM    WFLAG1,WWRD1+WWRD2+WTRLR Other sub-fields?
         BNZ   MAINWDS             Yes, not a valid label then
         TM    PREFF2,OPRKW+OPRKWV Was it a valid keyword?
         BNO   MAINADDL            No, go add as label
         LA    R14,PREFKW1         Yes, point at KW answer area
         CLI   KWNUM,RESERVED      Is this a reserved label?
         BE    MAINRWD             Yes, sorry
*
MAINADDL $CALL LBLGEN,PREFL        Go generate internal label
         B     MAINNWD             And go back for next word
*
MAINRWD  $ERR  RSVDWD,8,SKIP       Kill it
*---------------------------------------------------------------------+
*        Check command type                                           |
*---------------------------------------------------------------------+
*
MAINWDS  TM    WFLAG1,WPREF+WWRD2+WTRLR Other sub-fields?
         BNZ   MAINBCMD            Yes, sorry about that
         TM    WRD1F2,OPRKW+OPRKWV A valid keyword?
         BNO   MAINBCMD            No, sorry
         LA    R14,WRD1KW1         Point at KW answer area
         TM    KWF1,KWMAJ          A major command?
         BZ    MAINBCMD            No, sorry
         NI    PCTF3,255-COMPALTR  Kill ALTER flag
         L     R8,KWD3             Get addr of routine
         B     8(R8)               And go to it
*
MAINBCMD CLC   WORDL,=H'0'         Caused by null sentence?
         BNE   MAINBCMR            No, real error
         $ERR  EXTP,4              Yes, tell user that
         B     MAINNWD             Continue
*
MAINBCMR $ERR  BADC,8,SKIP         Not found? issue error message
*
MAINRUN  L     R8,PCTMAINC         Get routine addressable
         B     MAINENDC-MAINCOMP(R8) Go to it
         EJECT
*---------------------------------------------------------------------+
*        Ensure that next 'word' is end-of-sentence                   |
*        and issue error message if it isn't                          |
*---------------------------------------------------------------------+
*
MAINGEOX NI    PCTF1,255-ACTIVE    Show command no longer active
         $CALL GETNEXT             Go get next word
         CLC   WORDL,ZEROS         Should be end of sentence
         BE    MAINNWD             O.K. Start next sentence
         $ERR  NOPER,0,GO=MAINDATA,FLAG=NO NO, Msg and assume period
*
MAINGOKX NI    PCTF1,255-ACTIVE    Show command no longer active
         B     MAINNWD             And go for next
         DROP  R14
         TITLE 'MAINCOMP - Compiler - End of Input routine'
*---------------------------------------------------------------------+
*        End of command input to compiler                             |
*---------------------------------------------------------------------+
*
MAINCMS  $ERR  CCLOS,8,FLAG=NO     Issue error and terminate
         B     MAINENDC            Skip
*
MAINENDM $ERR  MCONT,8,FLAG=NO     Issue error and terminate
*
MAINENDC ZAP   GETCTR1,=P'1'       Set GETCTRS to EOF status to stop
         ZAP   GETCTR2,=P'1'       STMNT/WORD #'s in error messages
         $CALL INTLBLS             Go add internal labels to pgm
         $CALL LBLRESLV            Go process unresolved labels
         CLC   DCBALREC,ZEROS      A deferred LRECL test to do?
         BE    MAINNLTS            No, skip
         CLC   DCBALREC,DCBHLREC   Did something pass the high-water?
         BNH   MAINNLTS            No, we're O.K.
         MVC   GETCTR1,DCBASNO     Yes, swap in it's statement/word #
         MVC   GETCTR2,DCBAWNO     .
         $ERR  BUFFX,8,FLAG=NO     and issue error message now
*
MAINNLTS ZAP   GETCTR1,=P'9999'    Do again, LBLRESLV may have reset
         ZAP   GETCTR2,=P'999'     them if it detects errors.
         $ERR  MSG40,0,TYPE=STAT,FLAG=NO   Init statistics msg chain
         $ERR  SPACE,0,TYPE=STAT,FLAG=NO   With headings
         ICM   R0,15,PCTNEST       Still an IF stack?
         BNP   MAINRCTS            No
         $ERR  NODO,8,FLAG=NO      Yes, kill it
*
MAINRCTS TM    PCTF4,PWAITING      Previous line waiting?
         BZ    *+12                No
         BAL   R14,LINPRINT        Yes, Print it
         NI    PCTF4,255-PWAITING  and clear flag
         CLI   PCTRC+3,X'08'       What is highest RC so far
         BL    MAINETRC            Less than 8, O.K. To start copy
         $ERR  TERM,12,GO=ADDSTATS,FLAG=NO 8+, set to 12 and terminate
*
MAINETRC B     MAINUBFS            No-op if DEBUG
         $CALL SNAPIT              SNAP our code
*
MAINUBFS LA    R2,PCTUBFL1         Point at address of user buffers
         LA    R3,26               Set count
         LA    R4,PCTUBFA          Point at 1st buffer address
*
MAINUBFL CLC   0(4,R2),=F'-1'      Buffer needed here
         BE    MAINUBFG            Yes, go get one
*
MAINUBFB LA    R2,4(,R2)           No, bump
         LA    R4,4(,R4)           .
         BCT   R3,MAINUBFL         Loop till all examined
         B     MAINCEX             Exit now
*
MAINUBFG L     R0,PCTUBFSZ         Get size of buffer
         ST    R0,0(R2)            Save length
         GETMAIN R,LV=(0)          Go get one
         ST    R1,0(R4)            Save its address
         B     MAINUBFB            Continue
*
MAINCEX  GETMAIN R,LV=12           Get a RESET block
         MVC   0(4,R1),PCTRESET    Add to RESET chain
         ST    R1,PCTRESET         .
         LA    R0,PCTMACNT         Add address to be reset
         ST    R0,4(R1)            .
         MVC   8(4,R1),PCTMACNT    Add value to be put back
         $RET  0                   Compile done
         TITLE 'MSG39FMT - Format FCB stats message'
*---------------------------------------------------------------------+
*        Format the statistics message for an FCB                     |
*---------------------------------------------------------------------+
*
MSG39FMT $PROC
         ICM   R2,8,FCBORECF       Get RECFM
         SRL   R2,30               Shift to Lo-order
         LA    R1,=C'*VFU'         Point at string
         AR    R1,R2               Now point at specific character
         L     R2,=A(ERRTX39)      Address message
         MVC   28(5,R2),BLANKS     Clear RECFM area
         MVC   28(1,R2),0(R1)      Stuff in RECFM
         L     R1,=A(ERRTX39)      Address message
         LA    R2,29(,R1)          Point past it
*
MSGTB    TM    FCBORECF,X'10'      Blocked ?
         BNO   MSGTS
         MVI   0(R2),C'B'
         LA    R2,1(R2)
*
MSGTS    TM    FCBORECF,X'08'      Spanned ?
         BNO   MSGTA
         MVI   0(R2),C'S'
         LA    R2,1(R2)
*
MSGTA    TM    FCBORECF,X'04'      ASA ?
         BNO   MSGTM
         MVI   0(R2),C'A'
         LA    R2,1(R2)
*
MSGTM    TM    FCBORECF,X'02'      Machine ?
         BNO   MSGTT
         MVI   0(R2),C'M'
         LA    R2,1(R2)
*
MSGTT    TM    FCBORECF,X'20'      Track overflow ?
         BNO   MSGREX
         MVI   0(R2),C'T'
         LA    R2,1(R2)
*
MSGREX   LH    R2,FCBOLREC         Get LRECL
         CVD   R2,DBL              Convert it
         UNPK  42(5,R1),DBL+5(3)   Put in msg
         OI    46(R1),X'F0'        Pretty it up
         LH    R2,FCBOBLK          Get BLKSIZE
         CVD   R2,DBL              Convert it
         UNPK  58(5,R1),DBL+5(3)   Put it in msg
         OI    62(R1),X'F0'        Pretty it up
         MVC   18(2,R1),=C'PS'     Set to PS for now
         $RET  0                   Now return
         $PEND
         TITLE 'MSG52FMT - Format FCB volsers'
*---------------------------------------------------------------------+
*        Format the volser's used for an FCB                          |
*---------------------------------------------------------------------+
*
MSG52FMT $PROC
         MVC   FCBNVOLS(31),FCBJFCB+JFCBNVOL-JFCB
         L     R1,=A(ERRTX52)      Get address of text
         LA    R2,21(,R1)          Point at list-7
         MVI   7(R2),C' '          Blank it out
         MVC   8(34,R2),7(R2)
         CLI   FCBNVOLS,X'00'      Any volumes?
         BE    MSG52EX0            No, return and say so
         MVI   MSG52CLS,C')'       Set close default
         CLI   FCBNVOLS,X'05'      More than 5
         BNH   MSG52LOW            No
         MVI   MSG52CLS,C'+'       Yes, change default close character
         MVI   FCBNVOLS,X'05'      And force to only 1st 5 vols
*
MSG52LOW SR    R1,R1               Clear BCT reg
         IC    R1,FCBNVOLS         Get number of volsers
         LA    R3,FCBVOLS-6        Init for loop
*
MSG52LOP LA    R2,7(,R2)           Bump in MSG52
         LA    R3,6(,R3)           Bump in FCBVOLS
         MVC   0(6,R2),0(R3)       Move in one volser
         MVI   6(R2),C','          And a comma
         BCT   R1,MSG52LOP         And loop back if not done
         MVC   6(1,R2),MSG52CLS    If done, close off string
         $RET  4                   And go back +4
*
MSG52EX0 $RET  0                   Return +0
         $PEND
         TITLE 'GETNEXT - Command processor'
*---------------------------------------------------------------------+
*        G E T N E X T   C o m m a n d   P r o c e s s o r            |
*---------------------------------------------------------------------+
*
NEXTREC  $PROC
         USING KWDSECT,R14
         MVC   PCTPOPLS,ZEROS      Clear last POP'ed address
         $CALL DBGADD              Go add DEBUG code
         MVC   NXTEOF(12),NXTEOFD  Set EOF default
         MVC   NXTGFCBA,PCT1FCB    And FCB default
         MVI   NXTBFTYP,X'00'      Set default to NOCOPYBUFF
         MVI   NXTFLAG,X'00'       Reset flag
*---------------------------------------------------------------------+
*        Loop processing all GETNEXT operands                         |
*---------------------------------------------------------------------+
*
NEXTLOOP $CALL GETNEXT             Get next word, (if any).
         CLC   WORDL,=H'0'         End of sentence?
         BE    NEXTGEN             Yes, go gen some stuff
         TM    WFLAG1,WPREF+WTRLR  Invalid format?
         BNZ   BADKWORD            Yes, kill it
         TM    WFLAG1,WWRD1        Got WRD1?
         BNO   BADKWORD            Yes, kill it
         TM    WRD1F2,OPRKW+OPRKWV Valid KW?
         BNO   BADOPTYP            No, kill it
         LA    R14,WRD1KW1         Point at KW answer area
         TM    KWF1,KWOPRAND+KWSUBVAL Valid type?
         BNO   BADKWORD            No, sorry
         CLI   KWNUM,X'26'         Handle the COPYBUFF KW collision
         BE    NEXTBR              .
         MVN   KWNUM,=X'00'        Clear lo-order nibble
         CLI   KWNUM,X'70'         Valid NEXTREC KW?
         BNE   BADKWORD            No, sorry
*
NEXTBR   L     R2,KWD2             Get address of routine
         BR    R2                  Branch by type
*---------------------------------------------------------------------+
*        Process the COPYBUFF operand                                 |
*---------------------------------------------------------------------+
*
NEXTBUFF TM    WRD1F2,OPRKWOPV     Valid sub-operand?
         BZ    BADKWORD            No, sorry
         LA    R14,WRD1KW2         Yes, point at answer area
         CLI   KWNUM,X'3F'         ON/OFF YES/NO ?
         BNE   BADKWORD            Sorry
         L     R2,KWD2             Pick up Yes/No index
         B     *(R2)               Branch
         B     NEXTBFYS            YES/ON
         B     NEXTBFNO            NO/OFF
*
NEXTBFNO MVI   NXTBFTYP,X'00'      Flag as COPYBUFF(NO)
         B     NEXTBFDN            Continue
*
NEXTBFYS MVI   NXTBFTYP,X'80'      Flag as COPYBUFF(YES)
*
NEXTBFDN OI    NXTFLAG,NXTBSEEN    Flag as COPYBUFF seen
         OI    PCTF1,IPCOPY        Force separate output buffer
         B     NEXTLOOP            Continue
*---------------------------------------------------------------------+
*        Process the EOF(label) operand                               |
*---------------------------------------------------------------------+
*
NEXTEOF  TM    WRD1F2,OPRKWOP      Got a (...) operand?
         BZ    BADOPTYP            No, sorry
         MVC   NXTEOF(12),WRD1L2   Swap on top of default
         B     NEXTLOOP            Keep on truckin'
*---------------------------------------------------------------------+
*        Process the FILE(ddname) operand                             |
*---------------------------------------------------------------------+
*
NEXTFILE TM    WRD1F2,OPRKWOP      Got a (...) operand?
         BZ    BADOPTYP            No, sorry
         OI    PCTF3,INPUT         Make this DDname count
         OI    NXTFLAG,NXTFSEEN    Flag as FILE(...) seen
         TM    NXTFLAG,NXTBSEEN    COPYBUFF(YES/NO) seen?
         BO    NEXTSDCB            Yes, go set DCB address
         CLC   WRD1TXT2(6),MDINPT1+2 Is this INPUT1?
         BNE   NEXTSDCB            No, skip
         MVC   NXTBFTYP,PCTBFCDF   Set COPYBUFF as per default
*
NEXTSDCB $CALL DCBI1BLD,WRD1L2     Go setup input DCB
         B     BADDCB              Error, too bad
         ST    R1,NXTGFCBA         Save address of FCB area
         B     NEXTLOOP            Continue
         EJECT
*---------------------------------------------------------------------+
*        Now generate the code for GETNEXT                            |
*---------------------------------------------------------------------+
*
NEXTGEN  TM    NXTFLAG,NXTFSEEN    Was FILE(...) seen?
         BO    NEXTGNIT            Yes, leave BUFFCOPY alone
         TM    NXTFLAG,NXTBSEEN    COPYBUFF specified?
         BO    NEXTGNIT            Yes, don't default it
         MVC   NXTBFTYP,PCTBFCDF   No, set COPYBUFF as per default
*
NEXTGNIT MVC   NXTGRESM(1),NXTBFTYP Set buffer type
         $ADD  NXTG999-NXTGBAL1,NXTGBAL1
         LA    R2,NXTGREST-NXTGBAL1(,R1) Get resume address
         STCM  R2,7,NXTGRESM-NXTGBAL1+1(R1) Shove in pgm area
         LA    R2,NXTGEOFA-NXTGBAL1(,R1) Set up EOF address
         $CALL LBLOGEN,NXTEOF,(R2) .
         B     EXITGOK             Go to common command exit
*        EJECT
*---------------------------------------------------------------------+
*        GETNEXT routine work areas                                   |
*---------------------------------------------------------------------+
         CNOP  2,4
*
NXTGBAL1 BALR  R15,0               Get locally addressable
NXTGSAVE MVC   PCTPGMS,PCTPGM      Save PCTPGM address
NXTGSWAP MVC   PCTPGM,NXTGRESM-NXTGSAVE(R15) Swap in resume address
NXTGBAL2 BAL   R15,COPRETN-COPYDATA(R8) Go to 'COPRETN' to read record
NXTGRESM DC    XL4'00'             Address of code to resume at
NXTGFCBA DC    XL4'00'             Address of FCB area
NXTGEOFA DC    XL4'00'             Address of EOF label
NXTGREST MVC   PCTPGM,PCTPGMS      Restore original PCTPGM address
NXTG999  EQU   *                   End of model code
NXTEOFD  DC    H'3',CL10'EOJ'      Default value for reset
NXTEOF   DC    H'0',CL10' '        Current GETNEXT EOF value
NXTBFTYP DC    X'00'               COPYBUFF type requested
NXTFLAG  DC    X'00'               Scanning flags
NXTBSEEN       EQU   X'80'         COPYBUFF/NOCOPYBUFF seen
NXTFSEEN       EQU   X'40'         FILE(...) seen
         DROP  R14
         $PEND
         TITLE 'OPBLDPRF - Build base pointer for an oprand'
*---------------------------------------------------------------------+
*        Build OPGEN's base pointer based of the prefix or a default  |
*        ===========================================================  |
*                                                                     |
*        Called:   $CALL OPBLDPRF                                     |
*                                                                     |
*        Operands: none                                               |
*                                                                     |
*        Returns:  +0 if unable to complete successfully              |
*                  +4 if completed O.K.                               |
*                                                                     |
*                  If O.K. OPGBASE has been completed.                |
*                                                                     |
*        Notes:    Assumes the following variables are setup on       |
*                  input:                                             |
*                                                                     |
*                  WFLAG1    - Basic answers about what was found     |
*                              i.e. Prefix, word, trailer,            |
*                              +/- operand, etc.                      |
*                  WFLAG2    - What is allowable in context and       |
*                              options re: genn'ed code.              |
*                  PREF....  - From PARSE. | \                        |
*                  WRD1....  -   "    "    |==\   Mapped by           |
*                  WRD2....  -   "    "    |==/   OPRDSECT            |
*                  TRLR....  -   "    "    | /                        |
*---------------------------------------------------------------------+
*
OPBLDPRF $PROC
         USING KWDSECT,R14
         TM    WFLAG1,WPREF        Was a prefix coded?
         BO    OPBDECOD            Yes, go process it
         OI    WFLAG1,WPREF        No, lets build a default
         TM    WFLAG2,WIPDEF       Should we default an INPUT1?
         BZ    OPBDEFOP            No, make it the O/P buffer
         MVC   PREFNUM1,=F'1'      Create an INPUT1 prefix
         MVI   PREFF2,OPRNUM       .
         B     OPBDECOD            Continue
*
OPBDEFOP MVC   PREFL,=H'5'         Create an OBUFF prefix
         MVC   PREFTXT,=C'OBUFF'   .
         MVI   PREFF2,OPRKW+OPRKWV .
         $CALL KWRDSRCH,PREFL,PREFKW1 Go get it's KW entry
         B     *+4                 +0 Errors are impossible, ignore it
*
OPBDECOD TM    PREFF2,OPRKW+OPRKWV A valid keyword?
         BNO   OPBNTO              No, then should be a ddname type
         LA    R14,PREFKW1         Point at KW answer area
         CLI   KWNUM,X'E3'         Was it OBUFF: ?
         BNE   OPBTUB              No, try UBUFFx
         MVC   OPGBASE,=A(PCTOUTPT-(FCBRECAD-FCBDSECT)) Kludge addr.
         MVI   OPGBASE,X'0A'       .
         TM    WFLAG2,WIPDEF       Is this an INPUT reference?
         BZ    OPBEX4              No, just exit, else,
*
OPBSFLG  OI    PCTF1,IPCOPY        Flag for two buffers
*
OPBEX4   $RET   4                  And return
*
OPBEX0   $RET  0                   Return with error
*
OPBNTO   TM    PREFF2,OPRNUM       Numeric?
         BZ    OPBNTOC             No, just call
         CLC   PREFNUM1,=F'1'      The silly one?
         BE    OPBNTOD1            Yes
         BL    OPBEX0              Zero? Kill it
         CLC   PREFNUM1,=F'9'      Over max?
         BH    OPBEX0              Yes, also kill it
         MVC   PREFL,=H'6'         No
         MVC   PREFTXT,=C'INPUT'   Build it
         MVC   PREFTXT+5,PREFNUM1+3
         OI    PREFTXT+5,X'F0'
         B     OPBNTOC             Done, go call
*
OPBNTOD1 MVC   PREFL(12),MDINPT1   Set default
*
OPBNTOC  $CALL CVOTOFCB,PREFNUM1   Go get the prefix's FCB address
         B     OPBEX0              +0 Error, couldn't convert
         B     OPBEX4              And exit now
*
OPBTUB   CLI   KWNUM,X'E4'         Was it UBUFFx?
         BNE   OPBEX0              No, kill it
         MVC   OPGBASE,KWD2        Move base address
         MVC   OPGBASE(1),KWD3+3   And buffer index
         L     R1,KWD3             Get index again
         SLL   R1,2                x 4
         LA    R1,PCTINPL1-4(R1)   Point at length field
         MVC   0(4,R1),=F'-1'      Flag as GETMAIN needed
         B     OPBEX4              Now exit
         DROP  R14
         $PEND
         TITLE 'OPGEN - Gen code to point at an operand'
*---------------------------------------------------------------------+
*        Generate the code to point at an operand                     |
*        ========================================                     |
*                                                                     |
*        Called:   $CALL OPGEN                                        |
*                                                                     |
*        Operands: none                                               |
*                                                                     |
*        Returns:  +0 if unable to complete successfully              |
*                  +4 if completed O.K.                               |
*                                                                     |
*        Notes:    Assumes the following variables are setup on       |
*                  input:                                             |
*                                                                     |
*                  WFLAG1    - Basic answers about what was found     |
*                              i.e. Prefix, word, trailer,            |
*                              +/- operand, etc.                      |
*                  WFLAG2    - What is allowable in context and       |
*                              options re: genn'ed code.              |
*                  PREF....  - From PARSE. | \                        |
*                  WRD1....  -   "    "    |==\   Mapped by           |
*                  WRD2....  -   "    "    |==/   OPRDSECT            |
*                  TRLR....  -   "    "    | /                        |
*---------------------------------------------------------------------+
*
OPGEN    $PROC
         USING KWDSECT,R14
*---------------------------------------------------------------------+
*        Check the basic validity of the operands.                    |
*---------------------------------------------------------------------+
         TM    WFLAG1,WPREF        Validate the operands
         BZ    *+12                to ensure we don't have any
         TM    WFLAG2,WPREFOK      sub-fields we shouldn't have.
         BZ    OPGENEX0
         TM    WFLAG1,WWRD1
         BZ    OPGVLTRL
         TM    WRD1F2,OPRLIT
         BZ    OPGVLTRL
         TM    WFLAG2,WLITOK
         BZ    OPGENEX0
*
OPGVLTRL TM    WFLAG1,WTRLR
         BZ    OPGSTAB
         TM    WFLAG2,WTRLROK
         BO    OPGSTAB             Operands look O.K., continue
*
OPGENEX0 $RET  0                   Return +0 to show error status
         EJECT
*---------------------------------------------------------------------+
*        Setup to gen either A-operand or B-operand as requested.     |
*---------------------------------------------------------------------+
*
OPGSTAB  NC    OPGICM1(L'OPGMASK),OPGMASK Clear out prev regs from code
         TM    WFLAG2,WAOP         AREG requested?
         BZ    *+14                No, BREG
         OC    OPGICM1(L'OPGMASK),OPGAREG Set to AREG
         B     *+10                Continue
         OC    OPGICM1(L'OPGMASK),OPGBREG Set to BREG
         MVC   OPGBASE,ZEROS       Zero base/displacement
         MVC   OPGDISPL,ZEROS      .
*---------------------------------------------------------------------+
*        If a literal, then gen it and exit.                          |
*---------------------------------------------------------------------+
         TM    WRD1F2,OPRLIT       A literal?
         BZ    OPGTNUM             No, go try as numeric
         TM    WFLAG2,WIPDEF       A source field?
         BZ    OPGBDDST            No, kill it
*
OPGGLIT  $CALL LITPOOL,WRD1L       Go try it as a literal
         B     OPGLITOK            +00 O.K.
         B     BADLITBT            +04 Bad type
         B     BADLITBH            +08 Bad Hex
         B     BADLITBL            +12 Bad length
         B     BADLITBQ            +16 Bad quotes
         B     BADLITBN            +20 Bad numerics
*
OPGLITOK MVC   OPGBASE,LITA        Create pointer to literal
         MVC   OPGDISPL,ZEROS      Set displacement to zero
         $ADD  OPGICM2-OPGCODE,OPGCODE Add code to program
         ST    R1,OPGCADDR         Save code address
         NI    PCTIOFLG,255-IOPACKED Set packed flag as appropriate
         CLI   LITT,C'P'           A packed decimal literal
         BNE   *+8                 No, skip
         OI    PCTIOFLG,IOPACKED   Yes, remember that
         L     R15,LITL            Pick up length
         TM    WFLAG2,WAOP         A-operand?
         BZ    *+12                No, skip
         BAL   R14,OPGALCON        Go set A if no conflicts
         B     OPGOPLEN            Continue
         BAL   R14,OPGBLCON        Go set B if no conflicts
         B     OPGOPLEN            Go see if length is overridden
*
OPGENEX4 L     R1,OPGCADDR         Pass back address of genn'ed code
         $RET  4
         EJECT
*---------------------------------------------------------------------+
*        Not a literal, try a numeric address next                    |
*---------------------------------------------------------------------+
*
OPGTNUM  TM    WRD1F2,OPRNUM       Is it numeric?
         BZ    OPGTKW              No, go try as a KW
         ICM   R1,15,WRD1NUM1      Get the number
         BNZ   OPGMREL             If non-zero, go make relative
         ST    R1,OPGDISPL         Stuff it in code
         IC    R1,WFLAG2           Now set IOFLOATA/IOFLOATB in flags
         N     R1,=A(WAOP+WBOP)    depending on which of WAOP/WBOP are
         STC   R1,*+5              on in WFLAG2. Note: The EQU's must
         OI    PCTIOFLG,0          be the same for this to work.
         OI    WFLAG2,WPMOK        Allow +/- operands
         B     OPGDOPRF            Continue
*
OPGMREL  BCTR  R1,0                Make it relative
         ST    R1,OPGDISPL         Save in code
*---------------------------------------------------------------------+
*        Had a  number, go process it's prefix (or default)           |
*---------------------------------------------------------------------+
*
OPGDOPRF $CALL OPBLDPRF            Go setup prefix (i.e. OPGBASE)
         B     OPGENEX0            +0 Error, something wrong in prefix
         L     R1,OPGBASE          +4 Now adjust base -> record address
         AL    R1,=A(FCBRECAD-FCBDSECT)
         ST    R1,OPGBASE          Put it back
         TM    WFLAG1,WPLUS+WMINUS +4 O.K. then, was a +- value coded?
         BNZ   OPGPMT              Yes, go see if valid
         CLC   OPGDISPL,=F'1'      Was this pos 1-2 of the buffer?
         BH    OPGSTUFF            No, continue
         CLI   OPGBASE,X'01'       INPUT1 buffer?
         BE    *+12                Yes, see if RECFM=V
         CLI   OPGBASE,X'0A'       OBUFF  buffer?
         BNE   OPGSTUFF            No, skip
         TM    DEFRECFM,X'80'      RECFM=F or U?
         BO    OPGSTUFF            Yes, skip
         OI    PCTF1,IPCOPY        No, V, force two buffers
*
OPGSTUFF $ADD  OPGENDC-OPGCODE,OPGCODE No, add code to program
         ST    R1,OPGCADDR         Save code address
         B     OPGOPLEN            and exit
         EJECT
*---------------------------------------------------------------------+
*        If a  +/- adjustment present, validate and process it.       |
*---------------------------------------------------------------------+
*
OPGPMT   TM    WFLAG2,WPMOK        Is +/- allowable?
         BZ    OPGENEX0            No, sorry
         TM    WRD2F2,OPRNUM       Is +/- value numeric
         BZ    OPGPMTK             No, go try KW
         L     R14,WRD2NUM1        Yes, get it in register
         TM    WFLAG1,WPLUS        Was it plus?
         BO    *+6                 Yes, leave alone
         LCR   R14,R14             No, change its sign
         L     R1,OPGDISPL         Yes, adjust OPGDISPL
         AR    R1,R14              .
         ST    R1,OPGDISPL         .
         B     OPGSTUFF            Go stuff code and exit
*
OPGPMTK  TM    WRD2F2,OPRKW+OPRKWV Is +/- operand a valid KW?
         BNO   OPGENEX0            No, kill it
         LA    R14,WRD2KW1         Yes, point at KW answer area
         TM    KWF2,KWPMVALU       A valid +/- KW ?
         BZ    OPGENEX0            No, sorry about that
         CLI   KWGTYPE,KWPCTFLD    A PCT field?
         BNE   OPGENEX0            Sorry, it's the only one supported
         $ADD  OPGENDC-OPGCODE,OPGCODE Now add code to program
         ST    R1,OPGCADDR         Save code address
         MVC   OPGADD1+2-OPGCODE(2,R1),KWD1+2   Copy displ. to ADD1
         OI    OPGADD1+2-OPGCODE(R1),PCTBASE*16 OR in the PCTBASE
         TM    WFLAG2,WAOP         Genning A-operand?
         BZ    *+12                No, B, skip
         OI    PCTIOFLG,IONOAADJ   Yes, say no adjust
         B     OPGOPLEN            Continue
         OI    PCTIOFLG,IONOBADJ   Don't adjust B-operand
         B     OPGOPLEN            and exit
*---------------------------------------------------------------------+
*        If a  KW operand, process that.                              |
*---------------------------------------------------------------------+
*
OPGTKW   TM    WRD1F2,OPRKW+OPRKWV Valid keyword?
         BNO   OPGENEX0            No, sorry, you lose
         LA    R14,WRD1KW1         Point at KW answer area
         TM    KWF2,KWOPRPTR       Valid as an operand pointer?
         BZ    OPGENEX0            No, lose again!
         TM    KWF2,KWPMADJ        Is is +/- adjustable?
         BZ    OPGTKWPM            No, skip
         OI    WFLAG2,WPMOK        Yes, remember it
         B     OPGTKWI             Continue
*
OPGTKWPM TM    WFLAG1,WPLUS+WMINUS Were +/- specified?
         BNZ   BADOPTYP
*
OPGTKWI  CLI   KWNUM,X'E2'         UCTRx KW?
         BNE   *+8                 No, skip
         OI    PCTIOFL2,IOUCTRX    Set for CR type compare
         TM    WFLAG2,WIPDEF       A source field?
         BO    OPGTKWBR            Yes, any keyword is valid
         TM    KWF2,KWDEST         No, dest, is this KW valid as DEST
         BZ    OPGBDDST            No, error
         CLI   KWNUM,X'E2'         UCTRx KW?
         BNE   *+12                No, skip
         OI    PCTF7,UCTRDUMP      Set for UCTRx dump at EOJ
         OI    PCTIOFL2,IOUCTRX    Set for CR type compare
         MVC   ALTAKWLN,KWD3       Save KW length to match B-operand
         B     OPGTKWBR            Yes, continue
*
OPGBDDST $ERR  BDDST,8,SKIP        No way Jose'
         EJECT
*---------------------------------------------------------------------+
*        Branch by type of KW entry.                                  |
*---------------------------------------------------------------------+
*
OPGTKWBR SR    R15,R15             Clear a reg
         IC    R15,KWGTYPE         Get type index
         B     *(R15)              Branch by type
         B     OPGKWFCB            FCBFLD type
         B     OPGKWFCB            FCBPTR type
         B     OPGKWADR            ADRFLD type
         B     OPGKWADR            ADRPTR type
         B     OPGKWPCT            PCTFLD type
         B     OPGKWPCT            PCTADR type
*---------------------------------------------------------------------+
*        An FCB based KW.                                             |
*---------------------------------------------------------------------+
*
OPGKWFCB TM    WFLAG1,WPREF        Is there a prefix?
         BO    OPGKWT4C            Yes, skip
         MVC   PREFL(10),MDINPT1   No, fudge as INPUT1
         MVC   PREFNUM1,=F'1'      .
         OI    PREFF2,OPRNUM+OPRSPECN
*
OPGKWT4C $CALL CVOTOFCB,PREFNUM1   Go get it's FCB address
         B     OPGENEX0            +0 Couldn't do it
         LA    R14,WRD1KW1         +4 O.K. Point at KW answer area
         L     R1,OPGBASE          Adjust by offset in FCB
         AL    R1,KWD1             .
         ST    R1,OPGBASE          Stuff it back
         L     R15,KWD3            Pick up length
         TM    WFLAG2,WAOP         A-operand?
         BZ    *+12                No, skip
         BAL   R14,OPGALCON        Go set A if no conflicts
         B     *+8                 Continue
         BAL   R14,OPGBLCON        Go set B if no conflicts
*
OPGKWSTF $ADD  OPGICM2-OPGCODE,OPGCODE Now add code to program
         ST    R1,OPGCADDR         Save code address
         LA    R14,WRD1KW1         Point at KW answer area
         CLI   KWGTYPE,KWFCBPTR    Is it an indirect address?
         BNE   OPGKWNIN            No, skip indirect load
         $ADD  4,OPGICM2           Add the indirect load
*
OPGKWNIN TM    WFLAG1,WPLUS+WMINUS Was a +/- operand coded?
         BZ    OPGOPLEN            No, exit
         BAL   R14,OPGPMADJ        Go process +/- adjustment
         B     OPGOPLEN            Then exit
         EJECT
*---------------------------------------------------------------------+
*        A fixed address KW.                                          |
*---------------------------------------------------------------------+
*
OPGKWADR MVC   OPGBASE,KWD1        Put address in code
         L     R15,KWD3            Pick up length
         TM    WFLAG2,WAOP         A-operand?
         BZ    *+12                No, skip
         BAL   R14,OPGALCON        Go set A if no conflicts
         B     *+8                 Continue
         BAL   R14,OPGBLCON        Go set B if no conflicts
*
OPGKWAST $ADD  OPGICM2-OPGCODE,OPGCODE Now add code to program
         ST    R1,OPGCADDR         Save code address
         LA    R14,WRD1KW1         Point at KW answer area
         CLI   KWGTYPE,KWADRPTR    Is it an indirect address?
         BNE   OPGKWNNN            No, skip indirect load
         $ADD  4,OPGICM2           Add the indirect load
*
OPGKWNNN TM    WFLAG1,WPLUS+WMINUS Was a +/- operand coded?
         BZ    OPGOPLEN            No, exit
         BAL   R14,OPGPMADJ        Go process +/- adjustment
         B     OPGOPLEN            and exit
*---------------------------------------------------------------------+
*        A PCT based KW.                                              |
*---------------------------------------------------------------------+
*
OPGKWPCT TM    KWF2,KWOFFSET       A keyword type offset?
         BO    OPGKWPOF            Yes, split off here
*
OPGKWPNK LA    R1,PCT              Convert displ. to actual addr
         A     R1,KWD1             .
         ST    R1,OPGBASE          Save in code
         L     R15,KWD3            Pick up length
         TM    WFLAG2,WAOP         A-operand?
         BZ    *+12                No, skip
         BAL   R14,OPGALCON        Go set A if no conflicts
         B     *+8                 Continue
         BAL   R14,OPGBLCON        Go set B if no conflicts
*
OPGKWPST $ADD  OPGICM2-OPGCODE,OPGCODE Now add code to program
         ST    R1,OPGCADDR         Save code address
         LA    R14,WRD1KW1         Point at KW answer area
         CLI   KWGTYPE,KWPCTPTR    Is it an indirect address?
         BNE   OPGKWNPN            No, skip indirect load
         $ADD  4,OPGICM2           Add the indirect load
*
OPGKWNPN TM    WFLAG1,WPLUS+WMINUS Was a +/- operand coded?
         BZ    OPGOPLEN            No, exit
         BAL   R14,OPGPMADJ        Go process +/- adjustment
         B     OPGOPLEN            and exit
*
OPGKWPOF TM    WFLAG1,WPREF        Better have a prefix
         BZ    OPGKWPNK            No, back to the old way
         $CALL OPBLDPRF            Go setup prefix (i.e. OPGBASE)
         B     OPGENEX0            +0 Error, something wrong in prefix
         MVC   ALTAKWLN,ZEROS      +4 Forget now that it was a KW
         LA    R14,WRD1KW1         Point at KW answer area
         L     R1,OPGBASE          Now adjust base -> record address
         AL    R1,=A(FCBRECAD-FCBDSECT)
         ST    R1,OPGBASE          Put it back
         TM    WFLAG2,WAOP         A-operand?
         BZ    *+12                No, skip
         MVI   OREGALEN,X'00'      Yes, clear A length then
         B     *+10                Continue
         MVC   OREGBLEN,ZEROS      Zero B then
         $ADD  OPGENDC-OPGCODE,OPGCODE Add code to program
         ST    R1,OPGCADDR         Save code address
         LA    R14,WRD1KW1         Point at KW answer area
         L     R15,KWD1            Get displacement of field in PCT
         AL    R15,=X'0000D000'    Add base of R13 for PCT
         STCM  R15,3,OPGADD1+2-OPGCODE(R1) Modify compiled code
         $ADD  2,OPGBCTR           Add BCTR to cnvrt relative->actual
         TM    WFLAG2,WAOP         AREG requested?
         BO    OPGKWPOV            Yes, model code was correct
         MVI   1(R1),BREG*16       No, swap it to BCTR BREG,0
         B     OPGOPLEN            Continue
*
OPGKWPOV TM    PCTF3,COMPALTR      Compiling an ALTER command?
         BZ    OPGOPLEN            No, continue
         CLI   OPGBASE,X'01'       INPUT1 buffer?
         BE    *+12                Yes, see if RECFM=V
         CLI   OPGBASE,X'0A'       OBUFF  buffer?
         BNE   OPGOPLEN            No, skip
         TM    DEFRECFM,X'80'      RECFM=F or U?
         BO    OPGOPLEN            Yes, skip
         OI    PCTF1,IPCOPY        No, V, force two buffers
         B     OPGOPLEN            Continue
         EJECT
*---------------------------------------------------------------------+
*        Do the +/- adjustment for a KW if present and allowed.       |
*---------------------------------------------------------------------+
*
OPGPMADJ TM    WFLAG2,WPMOK        Yes, allowed?
         BZ    OPGENEX0            No, sorry
         TM    WRD2F2,OPRNUM       Numeric?
         BZ    OPGENEX0            No, sorry
         $ADD  4,OPGADD1           Add the adjust code
         MVC   2(2,R1),=X'F004'    Point ADD1 @ OPGDISPL
         L     R1,OPGCADDR         Load basic code address
         L     R2,WRD2NUM1         Get adjust number
         TM    WFLAG1,WPLUS        Positive?
         BO    *+6                 Yes, skip complement
         LCR   R2,R2               Make negative
         ST    R2,OPGDISPL-OPGCODE(R1) Shove in code
         BR    R14                 Return
*---------------------------------------------------------------------+
*        See if optional length operand/DLM is present.               |
*---------------------------------------------------------------------+
*
OPGOPLEN TM    WFLAG1,WTRLR        Is there even a trailer?
         BZ    OPGENEX4            No, exit then
         TM    TRLRF2,OPRNUM       A number?
         BZ    OPGOTLIT            No, go see if a literal
         L     R15,TRLRNUM1        Pick up length
         TM    WFLAG2,WAOP         A-operand?
         BZ    *+12                No, skip
         BAL   R14,OPGALCON        Go set A if no conflicts
         B     *+8                 Continue
         BAL   R14,OPGBLCON        Go set B if no conflicts
         B     OPGENEX4            Now exit
*
OPGOTLIT TM    TRLRF2,OPRLIT       Is it a literal then ?
         BNO   OPGOLKW             No, see if a KW
         $CALL LITPOOL,TRLRL       Yep, go put in LITPOOL
         B     OPGDLMLK            +00 O.K.
         B     BADLITBT            +04 Bad type
         B     BADLITBH            +08 Bad Hex
         B     BADLITBL            +12 Bad length
         B     BADLITBQ            +16 Bad quotes
         B     BADLITBN            +20 Bad numerics
*
OPGDLMLK MVC   OPGLITSV,LITA       Save address of the literal
         L     R6,LITL             Get number of bytes
         LA    R3,256              Go get 256 bytes in Literal pool
         LR    R4,R3               .
         LA    R2,TRTABLE          .
         $CALL LITSTUFF            Go get it
         L     R5,OPGLITSV         Get address of the original literal
         L     R2,LITA             Get address of gotten area
         XC    0(256,R2),0(R2)     Clear it
         L     R15,LITA            Pick up address of DLM table
         TM    WFLAG2,WAOP         A-operand?
         BO    BADOPTYP            Yes, shouldn't have been
         BAL   R14,OPGBLCON        Go set B if no conflicts
         MVC   OREGDLMT,LITA+1     Put DLM table address in OREGDLMT
         OI    PCTIOFLG,IODLML     Set flag
*
OPGOLLTL SR    R3,R3               Clear a reg.
         IC    R3,0(R5)            Pick up the next character in DLM
         AR    R3,R2               Index into TRTABLE
         MVI   0(R3),X'FF'         Make it a DLM
         LA    R5,1(,R5)           Bump
         BCT   R6,OPGOLLTL
         B     OPGENEX4            Now we can exit
*
OPGOLKW  TM    TRLRF2,OPRKW+OPRKWV Valid KW?
         BNO   BADOPTYP            No, sorry
         LA    R14,TRLRKW1         Yes, point at KW answer area
         CLI   KWNUM,X'30'         An '='
         BNE   OPGOLKW2            No, one last chance coming up
         OI    PCTIOFLG,IONOEXPC   Yes, set NOEXPC flag then
         B     OPGENEX4            And exit
*
OPGOLKW2 TM    KWF2,KWOFFSET       Allowable KW length?
         BNO   BADOPTYP            No, sorry about that
         TM    PCTF3,OPKWLEN       Already have one?
         BO    ALTLCONF            Yes, too bad
         L     R15,KWD1            Get displacement of field in PCT
         AL    R15,=X'0000D000'    Add base of R13 for PCT
         STCM  R15,3,ORLLCOD+2     Modify code to be inserted
         OI    PCTF3,OPKWLEN       Flag as KW length operand
         B     OPGENEX4            and exit
*---------------------------------------------------------------------+
*        Test for length conflicts (OPGALCON for A-operand)           |
*                                  (OPGBLCON for B-operand)           |
*                                                                     |
*        Entered: R15 - Potential new value                           |
*                 R14 - Return address                                |
*---------------------------------------------------------------------+
*
OPGALCON CLI   OREGALEN,X'00'      A-operand already set?
         BE    OPGALSET            No, just go set it thene
         TM    WFLAG2,WIPDEF       Yes, source field?
         BZ    OPGLCONF            No, Dest, kill it
*
OPGALSET STC   R15,OREGALEN        Set in the length
         BR    R14                 and go back
*
OPGBLCON CLC   OREGBLEN,=H'0'      B-operand already set?
         BE    OPGBLSET            No, just go set it thene
         TM    WFLAG2,WIPDEF       Yes, source field?
         BZ    OPGLCONF            No, Dest, kill it
*
OPGBLSET STCM  R15,7,OREGDLMT      Set in the length/DLM table address
         BR    R14                 and go back
*
OPGLCONF $ERR  LCONF,8,SKIP        Kill this one
*
OPGLITSV DS    F
         DROP  R14
         $PEND
         TITLE 'OPTIONS - Command processor'
*---------------------------------------------------------------------+
*        O P T I O N S   C o m m a n d   P r o c e s s o r            |
*---------------------------------------------------------------------+
*
OPTIONS  $PROC
         ICM   R1,15,PGMIC         Has program started?
         BZ    OPTLOOP             No, all is well, continue
         $ERR  BDOPT,8,SKIP        Yes, sorry, ignored
         USING KWDSECT,R14
*---------------------------------------------------------------------+
*        Loop for each OPTIONS operand                                |
*---------------------------------------------------------------------+
*
OPTLOOP  $CALL GETNEXT             Go get next word
         CLC   WORDL,=H'0'         End of sentence?
         BE    OPTEXIT             Yes, exit
         TM    WFLAG1,WPREF+WTRLR  Invalid format?
         BNZ   BADOPTYP            Yes, kill it
         TM    WRD1F2,OPRKW+OPRKWV+OPRKWOP Valid KW(...)?
         BNO   BADKWORD            No, kill it
         LA    R14,WRD1KW1         Point at KW answer area
         TM    KWF1,KWOPRAND       A valid type?
         BZ    BADKWORD            No, sorry
         CLI   KWNUM,X'91'         CBLKSIZE(91) is outside 4x range
         BE    OPTDOBR             So we keep going
         MVN   KWNUM,=X'00'        Clear lo-order nibble
         CLI   KWNUM,X'40'         Valid OPTIONS KW?
         BNE   BADKWORD            No, sorry
*
OPTDOBR  L     R2,KWD2             Get address of routine
         BR    R2                  Branch by type
         EJECT
*---------------------------------------------------------------------+
*        Process the CBLKSIZE(...) operand                            |
*---------------------------------------------------------------------+
*
OPTCBLK  TM    WRD1F2,OPRKWOPV     Valid KW sub-operand?
         BZ    BADKWORD            No, sorry
         LA    R14,WRD1KW2         Point at KW answer area for sub-op
         CLI   KWNUM,X'3F'         ON/OFF?
         BNE   BADKWORD            No, kill it
         L     R2,KWD2             Get type index
         B     *(R2)               Branch by type
         B     OPTCBON             ON/YES
         B     OPTCBOFF            OFF/NO
*
OPTCBON  OI    PCTF8,CBLKSIZE      Ensure CBLKSIZE is ON
         B     OPTLOOP             Keep on truckin'
*
OPTCBOFF NI    PCTF8,255-CBLKSIZE  Set for NO stats
         B     OPTLOOP             Keep on truckin'
*---------------------------------------------------------------------+
*        Process the MEMBSTAT(...)  operand                           |
*---------------------------------------------------------------------+
*
OPTPDSST TM    WRD1F2,OPRKWOPV     Valid KW sub-operand?
         BZ    BADKWORD            No, sorry
         LA    R14,WRD1KW2         Point at KW answer area for sub-op
         CLI   KWNUM,X'3F'         ON/OFF?
         BNE   BADKWORD            No, kill it
         L     R2,KWD2             Get type index
         B     *(R2)               Branch by type
         B     OPTPDON             ON/YES
         B     OPTPDOFF            OFF/NO
*
OPTPDON  OI    PCTF8,PDSSTATS      Ensure STATS is ON
         B     OPTLOOP             Keep on truckin'
*
OPTPDOFF NI    PCTF8,255-PDSSTATS  Set for NO stats
         B     OPTLOOP             Keep on truckin'
*---------------------------------------------------------------------+
*        Process the OPCHECK(...) operand                             |
*---------------------------------------------------------------------+
*
OPTOPCHK TM    WRD1F2,OPRKWOPV     Valid KW sub-operand?
         BZ    BADKWORD            No, sorry
         LA    R14,WRD1KW2         Point at KW answer area for sub-op
         CLI   KWNUM,X'3F'         ON/OFF?
         BNE   BADKWORD            No, kill it
         L     R2,KWD2             Get type index
         B     *(R2)               Branch by type
         B     OPTOPCON            ON/YES
         B     OPTOPCOF            OFF/NO
*
OPTOPCON OI    PCTF6,OPCHECK       Ensure OPCHECK is ON
         B     OPTLOOP             Keep on truckin'
*
OPTOPCOF NI    PCTF6,255-OPCHECK   Set for NO checking
         B     OPTLOOP             Keep on truckin'
         EJECT
*---------------------------------------------------------------------+
*        Process the AUTOCOPY(...) operand                            |
*---------------------------------------------------------------------+
*
OPTAUTO  TM    WRD1F2,OPRKWOPV     Valid KW sub-operand?
         BZ    BADKWORD            No, sorry
         LA    R14,WRD1KW2         Point at KW answer area for sub-op
         CLI   KWNUM,X'3F'         ON/OFF?
         BNE   BADKWORD            No, kill it
         L     R2,KWD2             Get type index
         B     *(R2)               Branch by type
         B     OPTAUON             ON/YES
         B     OPTAUOFF            OFF/NO
*
OPTAUON  OI    PCTBFCDF,COPYBUFF   Ensure COPYBUFF is on
         B     OPTLOOP             Keep on truckin'
*
OPTAUOFF NI    PCTBFCDF,255-COPYBUFF Set for NO COPYBUFF
         B     OPTLOOP             Keep on truckin'
         EJECT
*---------------------------------------------------------------------+
*        Process the OBFORCE(...)  operand                            |
*---------------------------------------------------------------------+
*
OPTOBFOR TM    WRD1F2,OPRKWOPV     Valid KW sub-operand?
         BZ    BADKWORD            No, sorry
         LA    R14,WRD1KW2         Point at KW answer area for sub-op
         CLI   KWNUM,X'3F'         ON/OFF?
         BNE   BADKWORD            No, kill it
         L     R2,KWD2             Get type index
         B     *(R2)               Branch by type
         B     OPTOBON             ON/YES
         B     OPTOBOFF            OFF/NO
*
OPTOBON  OI    PCTF1,IPCOPY        Force two buffers
         B     OPTLOOP             Keep on truckin'
*
OPTOBOFF B     OPTLOOP             Ignore OFF requests
         EJECT
*---------------------------------------------------------------------+
*        Process the UBSIZE(nnn)   operand                            |
*---------------------------------------------------------------------+
*
OPTUBUF  TM    WRD1F2,OPRKWOPV     Valid KW sub-operand?
         BZ    BADKWORD            No, sorry
         LA    R14,WRD1KW2         Point at KW answer area for sub-op
         TM    KWF2,KWNUMFUG       Numeric?
         BZ    BADKWVAL            No, sorry
         ICM   R1,15,WRD1NUM2      Yes, see if zero
         BZ    BADKWVAL            It is, sorry
         ST    R1,PCTUBFSZ         Save for use then
         B     OPTLOOP             Continue
*---------------------------------------------------------------------+
*        Process the PARM(xx...)   operand                            |
*---------------------------------------------------------------------+
*
OPTPARM  LH    R14,WRD1L2          Get length of field
         LA    R15,WRD1TXT2        Point at data string
         CLI   0(R15),C''''        Quoted string?
         BNE   OPTPNQU             No, skip down
         LA    R15,1(,R15)         Yes, strip off the quotes
         BCTR  R14,0               .
         BCTR  R14,0               .
*
OPTPNQU  CH    R14,=H'8'           Make sure not too long
         BH    BADKWVAL            .
         BCTR  R14,0               -1 for EX
         EX    R14,*+4             Move it to PCT field
         MVC   PCTUPARM(0),0(R15)  .
         B     OPTLOOP             Continue
         EJECT
*---------------------------------------------------------------------+
*        Process the EOFFILL(...)  operand                            |
*---------------------------------------------------------------------+
*
OPTEOFF  LA    R1,PCTEOFFL         Point at answer area
         B     OPTLITER            Go to common code
*---------------------------------------------------------------------+
*        Process the PADCHAR(...)  operand                            |
*---------------------------------------------------------------------+
*
OPTPADCH LA    R1,PCTPADCH         Point at answer area
*---------------------------------------------------------------------+
*        Process the literal operands for EOFFILL/PADCHAR             |
*---------------------------------------------------------------------+
*
OPTLITER ST    R1,OPTPSAVE         Save answer address for a while
         $CALL LITPOOL,WRD1L2      Go put in literal pool
         B     OPTLITOK            +0  Good
         B     BADLITBT            +4  Type no good
         B     BADLITBH            +8  HEX no good
         B     BADLITBL            +12 Length no good
         B     BADLITBQ            +16 Quotes no good
         B     BADLITBN            +20 Numeric no good
*
OPTLITOK L     R2,LITA             Point at literal
         L     R1,OPTPSAVE         Point at answer area
         MVC   0(1,R1),0(R2)       Copy 1st character
         B     OPTLOOP             Done
         EJECT
*---------------------------------------------------------------------+
*        Process EOFLABEL(...) operand                                |
*---------------------------------------------------------------------+
*
OPTEOFL  L     R1,=A(NXTEOFD)      Point at answer area
         LA    R2,WRD1L2           Point at text
         CLC   WRD1L2,=H'10'       Within limits?
         BH    OPTLBLSL            No, do specially
         MVC   0(12,R1),WRD1L2     Copy to answer area
         B     OPTLOOP             Done
*
OPTLBLSL MVC   0(2,R1),=H'10'      Set default length
         L     R2,WRD1TXT2         Point at data
         MVC   2(10,R1),0(R2)      Copy 1st 10 bytes
         B     OPTLOOP             Done
*---------------------------------------------------------------------+
*        Process the DEFER(ddname) operand                            |
*---------------------------------------------------------------------+
*
OPTDEFER TM    WRD1F2,OPRKWOP      Got a sub-operand?
         BZ    BADOPTYP            No, error
         MVC   DDNAME,BLANKS       Align in 8 byte area
         LH    R15,WRD1L2          .
         BCTR  R15,0               .
         EX    R15,*+4             .
         MVC   DDNAME(0),WRD1TXT2  .
         CLC   WRD1L2(8),MDINPT1   Is it INPUT1?
         BE    OPTBDDN             That's a no-no
         CLC   WRD1L2(7),MDSYSI    Is it SYSIN?
         BE    OPTBDDN             That's a no-no
         CLC   WRD1L2(10),MDSYSP   Is it SYSPRINT?
         BE    OPTBDDN             That's a no-no
         LA    R3,PCTFCB           Load address of start of FCB chain
*
OPTFCBLP ICM   R7,15,0(R3)         Load next FCB address
         BZ    OPTFCBNW            End of chain?, go add one to it
         CLC   DDNAME,FCBDDNAM     See if we have this DDname already
         BE    OPTLOOP             Yes, skip out
         LR    R3,R7               Setup for chaining
         B     OPTFCBLP            And try again
*---------------------------------------------------------------------+
*        GETMAIN and build an FCB                                     |
*---------------------------------------------------------------------+
*
OPTFCBNW LA    R0,FCBLNGTH         Set length for GETMAIN
         GETMAIN R,LV=(0)          Get an FCB area
         LR    R7,R1               Put address of FCB in R7
         ST    R7,0(R3)            Add to FCB chain
         MVI   FCBCHAIN,X'00'      Zero area
         MVC   FCBCHAIN+1(FCBDSNAM-FCBDSECT),FCBCHAIN
         MVC   FCBDDNAM,DDNAME     Insert DDname
         OI    FCBF1,FCBDOPEN+FCBSTATS Flag as def. OPEN + Stats
         MVC   DCBHLREC,=H'32764'  Set max default high lrecl
         B     OPTLOOP             Go get another kw
*---------------------------------------------------------------------+
*        Process the PDSMODE operand                                  |
*                                                                     |
*              N.B. This just gives this code something to do while   |
*                   processing the OPTIONS statement since PDSMODE    |
*                   MUST be specified via the PARM field. If this     |
*                   stub were not here, OPTIONS would flag it as an   |
*                   invalid keyword. See PARM field handling.         |
*---------------------------------------------------------------------+
*
OPTPDSMD TM    WRD1F2,OPRKWOPV     Valid KW sub-operand?
         BZ    BADKWORD            No, sorry
         LA    R14,WRD1KW2         Point at KW answer area for sub-op
         CLI   KWNUM,X'3F'         ON/OFF?
         BNE   BADKWORD            No, kill it
         L     R2,KWD2             Get type index
         B     *(R2)               Branch by type
         B     OPTPDSON            ON/YES
         B     OPTPDSOF            OFF/NO
*
OPTPDSON OI    PCTF8,PDSMODE       Set PDSMODE on
         B     OPTLOOP             Keep on truckin'
*
OPTPDSOF NI    PCTF8,255-PDSMODE   Set PDSMODE off
         B     OPTLOOP             Keep on truckin'
*
OPTBDDN  $ERR  BDDN,8,SKIP
*
OPTEXIT  B     EXITGOK             We're done
OPTPSAVE DS    F                   Temp save area
         $PEND
         TITLE 'PARSE - Parse a "word"'
*---------------------------------------------------------------------+
*        Parse a passed word into it's component pieces               |
*        ==============================================               |
*                                                                     |
*        Called:   $CALL PARSE,word                                   |
*                                                                     |
*        Operands: word     - is standard 'word' format               |
*                               i.e. H'nn',C'text'                    |
*                                                                     |
*        Returns:  +0 on completion                                   |
*                                                                     |
*        Notes:    All answers are in the following areas:            |
*                                                                     |
*                  WFLAG1    - Basic answers about what was found     |
*                              i.e. Prefix, word, trailer,            |
*                              +/- operand, etc.                      |
*                                                                     |
*                  PREF....  - These areas are completed if the       |
*                  WRD1....  - WFLAG1 status says they were detected. |
*                  WRD2....  - Residual data may be present and must  |
*                  TRLR....  - be ignored if no valid WFLAG1 is on.   |
*                                                                     |
*                              These areas are mapped by OPRDSECT.    |
*---------------------------------------------------------------------+
*
PARSE    $PROC 1
         L     R6,12(R8)           Point R6 at passed area
         SR    R3,R3               Clear previous status
         SR    R4,R4               .
         SR    R5,R5               .
         STM   R3,R5,PREFNUM1      .
         STM   R3,R5,WRD1NUM1      .
         STM   R3,R5,WRD2NUM1      .
         STM   R3,R5,TRLRNUM1      .
         MVI   PREFF1,WPREF        Reset type flags
         MVI   WRD1F1,WWRD1        .
         MVI   WRD2F1,WWRD2        .
         MVI   TRLRF1,WTRLR        .
         MVI   WFLAG1,X'00'        .
         LH    R3,0(R6)            R3 > Length of word being processed
         LA    R4,2(R6)            R4 > Start of word
         MVI   TRTABLE+C':',X'08'  Reset TRTABLE delimiters
         MVI   TRTABLE+C'''',X'04' .
         MVI   TRTABLE+C'/',X'14'  .
         MVI   TRTABLE+C'+',X'0C'  .
         MVI   TRTABLE+C'-',X'10'  .
         MVI   TRTABLE+C' ',X'18'  .
         MVI   TRTABLE+C'(',X'1C'  .
         MVI   TRTABLE+C')',X'1C'  .
         LA    R7,WRD1NUM1         Set default operand area
         ST    R7,PARSDFLT         .
         PUSH  USING
         USING OPRDSECT,R7         Make it addressable
*---------------------------------------------------------------------+
*        Do some fudges for LABEL:  handling
*---------------------------------------------------------------------+
         LR    R6,R4               See if last is a :
         LR    R5,R3               .
         TM    PCTF4,LABLLOOK      Looking for a LABEL?
         BO    PARSLABL            Yes
         LR    R15,R6              .
         AR    R15,R5              .
         BCTR  R15,0               .
         CLI   0(R15),C':'         .
         BNE   PARSSVST            No, continue
         LR    R1,R15              Make it look like TRT result
         LR    R15,R6              Ensure no other : inside word
         CLI   0(R15),C':'         .
         BE    PARSSVST            .
         LA    R15,1(,R15)         .
         CR    R15,R1              .
         BNE   *-14                .
         B     PARSCOLN            .
*
PARSLABL NI    PCTF4,255-LABLLOOK  Kill flag
         B     PARSNDLM            Treat as one big word
         EJECT
*---------------------------------------------------------------------+
*        Main PARSE Scanning Loop
*---------------------------------------------------------------------+
*
PARSSVST LR    R6,R4               Setup working scan registers
         LTR   R5,R3               .
         BZ    PARSEEX             Exit if nothing left
*
PARSSCAN BCTR  R5,0                -1 for EX
         SR    R2,R2               Clear R2
         SR    R1,R1               and R1
         EX    R5,PARSTRT1         Look for a delimiter
         BZ    PARSNDLM            None, do default processing
         B     *(R2)               Got a DLM, branch accordingly
         B     PARSQT              ' (Quote) detected
         B     PARSCOLN            : (Colon)     "
         B     PARSPLUS            + (Plus)      "
         B     PARSMINS            - (Minus)     "
         B     PARSSLSH            / (Slash)     "
         B     PARSNDLM              (Blank)     "
         B     PARSPARN            () Parenthesis
*---------------------------------------------------------------------+
*        Parenthesis detected, kill some delimiters
*---------------------------------------------------------------------+
*
PARSPARN MVI   TRTABLE+C':',X'00'  Clear some delimiters
         MVI   TRTABLE+C'+',X'00'  .
         MVI   TRTABLE+C'-',X'00'  .
         MVI   TRTABLE+C' ',X'18'  .
         MVI   TRTABLE+C'(',X'00'  .
         MVI   TRTABLE+C')',X'00'  .
         B     PARSSVST            Start scan over
*---------------------------------------------------------------------+
*        No delimiter, remaining text goes to the default
*---------------------------------------------------------------------+
*
PARSNDLM L     R7,PARSDFLT         Pick up the default answer area
         OC    WFLAG1,OPRF1        Set WFLAG1
         STH   R3,OPRL             Set the 'word' in the default
         CH    R3,=H'10'           See if 'word' will fit
         BH    *+14                No, make it a pointer then
         MVC   OPRTXT,0(R4)        Yes, copy to operand area
         B     PARSDFTY            and go to type it
         ST    R4,OPRADDR          Save pointer to it
         OI    OPRF2,OPRPTR        Flag it as pointer type
*
PARSDFTY CP    COMNTCTL,=P'0'      In SKIP mode?
         BNE   PARSEEX             Yes, just exit
         $CALL TYPEOPER,(R7)       Go set the type flags
         TM    OPRF1,WWRD1         Is this the 'main' word?
         BZ    PARSEEX             No, just exit
         TM    OPRF2,OPRKWOP       KW(...) type?
         BZ    PARSEEX             No, exit
         OI    WFLAG1,WWRD2        Yes, flag it
         B     PARSEEX             and exit
         EJECT
*---------------------------------------------------------------------+
*        Quote found, process it                                      |
*---------------------------------------------------------------------+
*
PARSQT   LR    R15,R1              Calc displacement of quote
         SR    R15,R6              .
         SR    R5,R15              Adjust remaining length
         BZ    PARSNDLM            If null, bail out
         CLI   1(R1),C''''         Double quote?
         BNE   PARSNDQT            No
         LA    R1,1(,R1)           Yes, step over it
         SH    R5,=H'1'            Reduce length one more
         BZ    PARSNDLM            If null, bail out
*
PARSNDQT BCTR  R5,0                -1 for EX length
         L     R15,=A(TRTBLQ)      Get address of quote TRTable
         LA    R1,1(,R1)           Step over the 1st quote
         EX    R5,PARSTRT3         Look for end quote
         BZ    PARSNDLM            None, bail out
         LR    R15,R1              Calc displacement of ending quote
         SR    R15,R4              .
         LR    R5,R3               Pick up original length again
         SR    R5,R15              Adjust remaining length
         BCTR  R5,0                Fudge
         LTR   R5,R5               See if zero
         BZ    PARSNDLM            If null, bail out
         LA    R6,1(,R1)           Swap to working scan reg
         B     PARSSCAN            Resume scanning
*---------------------------------------------------------------------+
*        Colon found, process it
*---------------------------------------------------------------------+
*
PARSCOLN MVI   TRTABLE+C':',X'00'  Remove : from delimiter status
         LA    R7,WRD1NUM1         Setup next default
         ST    R7,PARSDFLT         .
         LA    R7,PREFNUM1         Swap operand to PREF area
         B     PARSDO1             Go save answer values
         EJECT
*---------------------------------------------------------------------+
*        Plus/ Minus found, process them
*---------------------------------------------------------------------+
*
PARSPLUS OI    WFLAG1,WPLUS        Remember PLUS
         B     *+8                 Skip MINUS entry point
*
PARSMINS OI    WFLAG1,WMINUS       Remember Minus
         MVI   TRTABLE+C'+',X'00'  Remove +/- from delimiter status
         MVI   TRTABLE+C'-',X'00'  .
         LA    R7,WRD2NUM1         Setup next default
         ST    R7,PARSDFLT         .
         LA    R7,WRD1NUM1         Use WRD1 area for answer
         B     PARSDO1             Go setup answer area
*---------------------------------------------------------------------+
*        Slash found, process it
*---------------------------------------------------------------------+
*
PARSSLSH MVI   TRTABLE+C'/',X'00'  Remove / from delimiter status
         L     R7,PARSDFLT         Pickup default answer area address
         LA    R15,TRLRNUM1        Setup next default
         ST    R15,PARSDFLT        .
         B     PARSDO1             Go setup answer area
         EJECT
*---------------------------------------------------------------------+
*        Setup answers for 1 sub-operand
*---------------------------------------------------------------------+
*
PARSDO1  LR    R15,R1              Calc length of operand
         SR    R15,R4              .
         BZ    PARSDO1A            Skip if null operand
         OC    WFLAG1,OPRF1        Set WFLAG1
         STH   R15,OPRL            Save in operand area
         CH    R15,=H'10'          See if 'word' will fit
         BH    *+14                No, make it a pointer then
         MVC   OPRTXT,0(R4)        Yes, copy to operand area
         B     PARSDO1A            continue
         ST    R4,OPRADDR          Save pointer to it
         OI    OPRF2,OPRPTR        Flag it as pointer type
*
PARSDO1A SR    R3,R15              Adjust main 'word' length
         BCTR  R3,0                Less 1 for delimiter
         LA    R4,1(R4,R15)        Adjust pointer to 'word'
         LTR   R3,R3               Any left?
         BZ    PARSDOTY            No, just type the one we've got
         LTR   R15,R15             Was null operand found?
         BZ    PARSSVST            Yes, forget typeing it then
*
PARSDOTY CP    COMNTCTL,=P'0'      In SKIP mode?
         BE    PARSDXTY            No, do typing
         CLC   WORDL,=H'2'         Don't miss the *: for nested comment
         BNE   PARSSVST            Can't be, skip
         CLC   WORDTXT(2),=C'*:'   Is this it?
         BNE   PARSSVST            Yes, do a full parse
*
PARSDXTY $CALL TYPEOPER,(R7)       Go type it
         B     PARSSVST            Resume for next operand
*
PARSEEX  $RET  0                   Return
*
PARSDFLT DS    F
PARSTRT1 TRT   0(0,R6),TRTABLE
PARSTRT2 TRT   0(0,R6),0(R15)
PARSTRT3 TRT   0(0,R1),0(R15)
PARSPAK1 PACK  DBL,0(0,R1)
PARSMV1  MVC   WORDTXT(0),1(R4)
         DROP  R7
         POP   USING
         $PEND
         TITLE 'PGMSTUFF - Add code to the program'
*---------------------------------------------------------------------+
*        Insert code into the 'compiled' program                      |
*        =======================================                      |
*                                                                     |
*        Called:   $CALL PGMSTUFF                                     |
*                                                                     |
*        Input:    R1      - the length of the code to be inserted    |
*                            N.B.  A length of zero (0) is taken to   |
*                                  be a request for the current       |
*                                  location counter.                  |
*                                                                     |
*                  R2      - the address of the code to be inserted   |
*                                                                     |
*        Returns:  +0      - on completion                            |
*                                                                     |
*                  R1      - Will contain the location of the inserted|
*                            code in the compiled program or of the   |
*                            location counter if length=0 passed.     |
*---------------------------------------------------------------------+
*
PGMSTUFF $PROC
         LTR   R5,R1               Test length of code
         BNZ   PGMFNDAD            There's something there
         ICM   R1,15,PGMIC         Zero means a req. for curr. I.C.
         BNZ   PGMEX               If one exists, return with it
         B     PGMGMAIN            Else go get one
*
PGMEX    $RET  0
*
PGMFNDAD LA    R3,PGMLINKE-PGMLINKS(,R1) Add safety factor to length
         C     R3,PGMRESID         Is there room for code + safety code
         BNH   PGMSTSV             Yes, go store it
*
PGMGMAIN GETMAIN R,LV=1024         No, get a new 1k area
         L     R15,=A(MAINETRC)    Get flag address
         TM    1(R15),X'F0'        Is support active?
         BO    PGMNOSUP            No
         L     R15,PCTSUPP2        Get place to store it
         ST    R1,0(R15)           Save it
         MVC   4(4,R15),HEXFFS     Stuff in new delim
         LA    R15,4(,R15)         Bump to next slot
         ST    R15,PCTSUPP2        Save for next time
*
PGMNOSUP MVC   PGMRESID,=F'1024'   Set new available size
         CLC   PGMIC,ZEROS         First pgm area?
         BNE   PGMADCHN            No, go chain it
         ST    R1,PCTPGM           Yes, save start of pgm in pct
         ST    R1,PGMIC            And save as new I.C.
         LTR   R5,R5               Is this only an I.C. Request
         BZ    PGMEX               Yes, leave now
         B     PGMSTSV             No, go stuff in code
*
PGMADCHN ST    R1,PGMMADCN         Store new GM area
         L     R4,PGMIC            Get addr of old I.C.
         ST    R1,PGMIC            Swap to new one
         MVC   0(PGMLINKE-PGMLINKS,R4),PGMLINKS Store link code
*
PGMSTSV  BCTR  R5,0                Reduce count for EX
         L     R1,PGMIC            Get loc to store
         LR    R3,R1               Let R1 stay at start of code
         EX    R5,*+4              Move model code to pgm area
         MVC   0(0,R3),0(R2)       .
         LA    R3,1(R5,R3)         Create new I.C. Address
         ST    R3,PGMIC            And save it
         L     R3,PGMRESID         Get residual count
         SR    R3,R5               Reduce by amount used
         BCTR  R3,0
         ST    R3,PGMRESID         And save it
         B     PGMEX               Return, we're done
         $PEND
         TITLE 'PUSHIF/POPIF - Routines for IF processing'
*---------------------------------------------------------------------+
*        PUSHIF/POPIF routines                                        |
*---------------------------------------------------------------------+
*
PUSHIF   $PROC
         USING KWDSECT,R14
         L     R2,PCTNEST          Get nest count
         CH    R2,=H'19'           At limit?
         BNL   PUSHERR             Yes, sorry
         LA    R2,1(,R2)           +1
         ST    R2,PCTNEST          Save it back
         SLL   R2,2                Index x 4
         LA    R2,PCTNEXT-4(R2)    Point at stack item
         ST    R1,0(R2)            Save address in stack
         $RET  0                   Return
*
PUSHERR  $ERR  NESTH,8,SKIP        Kill it
         $PEND
*
POPIF    $PROC
         ICM   R2,15,PCTNEST       Get nest count
         BZ    POPEX               Ignore zero, nesting error
         LR    R1,R2               Copy it for BCTR
         BCTR  R1,0                -1
         ST    R1,PCTNEST          Save it back
         SLL   R2,2                Index x 4
         L     R4,PCTNEXT-4(R2)    Now get the address to be stuffed
         $ADD  0,*                 Get current I.C.
         ST    R1,0(R4)            Save in pointed-to location
         ST    R4,PCTPOPLS         Save the last POP'ed position
*
POPEX    $RET  0                   Return
         $PEND
         TITLE 'SDCBROUT - Select Output route for DCB'
*---------------------------------------------------------------------+
*        Select an output route for an FCB                            |
*        =================================                            |
*                                                                     |
*        Called:   $CALL SDCBROUT,fcb                                 |
*                                                                     |
*        Operands: fcb     - the address of the FCB to be processed   |
*                                                                     |
*        Returns:  +0 on completion                                   |
*                                                                     |
*                  FCBROUTE will be set to the appropriate address    |
*                           of the routine to copy between the RECFM  |
*                           of INPUT1 and the RECFM of the passed FCB.|
*---------------------------------------------------------------------+
*
SDCBROUT $PROC 1
         L     R7,12(R8)           Pick up passed param
         MVC   SDCBRWK(1),FCBDCB+DCBRECFM Build search key
         MVI   SDCBRWK+1,X'C0'     Set default to Undefined
         ICM   R15,15,PCT1DCB      Point at INPUT1 DCB
         BZ    *+10                Skip if no input RECFM avail.
         MVC   SDCBRWK+1(1),DCBRECFM(R15)
         NC    SDCBRWK,=X'C0C0'    Kill rubbish bits
         LA    R3,(DCBRTBLE-DCBRTBL)/6 Set limit on loop
         L     R4,=A(DCBRTBL)      Point at table
*
SDCBLOOP CLC   0(2,R4),SDCBRWK     Look for our match
         BE    SDCBFND             Got it
         LA    R4,6(,R4)           Else, bump
         BCT   R3,SDCBLOOP         Loop, fall through R4 is at default
*
SDCBFND  MVC   FCBROUTE,2(R4)      Setup output route in FCB
         $RET  0                   Leave
*
SDCBRWK  DC    X'0000'
         $PEND
         TITLE 'SELECT - Command processor'
*---------------------------------------------------------------------+
*        S E L E C T   C o m m a n d   P r o c e s s o r              |
*---------------------------------------------------------------------+
*
SELECT   $PROC
         MVC   PCTPOPLS,ZEROS      Clear last POP'ed address
         $CALL DBGADD              Go add DEBUG code
         MVI   SELF1,X'00'         Blank out work areas
         MVC   SELF2(SELGLDEX-SELF2),SELF1
         MVC   SELNREC,=X'7FFFFFFF' Stuff max value for RECS
         MVC   SELGOTOA,ZEROS      Clear any prior GOTO
         OI    PCTF1,ACTIVE        Show command active
*---------------------------------------------------------------------+
*        Loop for each SELECT operand                                 |
*---------------------------------------------------------------------+
*
SELLOOP  $CALL GETNEXT             Go get next word
         CLC   WORDL,=H'0'         End of sentence?
         BE    SELEOS              Yes
         TM    WFLAG1,WPREF+WTRLR  Invalid format?
         BNZ   BADOPTYP            Yes, kill it
         TM    WFLAG1,WWRD1        Better have this on
         BZ    BADOPTYP            No, sorry
         TM    WRD1F2,OPRKW+OPRKWV Valid KW?
         BNO   BADKWORD            No, kill it
         LA    R14,WRD1KW1         Point at KW answer area
         TM    KWF1,KWNOISE        Noise word?
         BO    SELLOOP             Yes, ignore it
         CLI   KWNUM,X'52'         Handle the GOTO collision
         BE    SELBR               .
         MVN   KWNUM,=X'00'        Clear lo-order nibble
         CLI   KWNUM,X'80'         Valid SELECT KW?
         BNE   BADKWORD            No, sorry
*
SELBR    L     R2,KWD1             Get address of routine
         BR    R2                  Branch by type
*---------------------------------------------------------------------+
*        Process the RECS(...) operand                                |
*---------------------------------------------------------------------+
*
SELRECS  TM    WRD1F2,OPRKWOP      Do we have a sub-operand
         BZ    BADOPTYP            No, sorry
         TM    WRD1F2,OPRKWOP+OPRKWOPV Valid KW?
         BNO   SELRECSN            No, go try as numeric
         LA    R14,WRD1KW2         Point at KW answer area
         CLI   KWNUM,X'93'         Is it (ALL) ?
         BNE   SELRECSN            No, see if numeric
         MVC   SELNREC,=X'7FFFFFFF' Stuff max value
         OI    PCTF3,ALL           Turn on permanent active bit
         B     SELLOOP             And loop back
*
SELRECSN LA    R2,SELNREC          Point at location to receive answer
         SR    R3,R3               Set adjustment to zero
         B     SELNUMBR            Go to common code
*---------------------------------------------------------------------+
*        Process the SREC(...) operand                                |
*---------------------------------------------------------------------+
*
SELSREC  LA    R2,SELSRECD         Point at location to receive answer
         SR    R3,R3               Set adjustment to zero
         B     SELNUMBR            Go to common code
*---------------------------------------------------------------------+
*        Process the BY(...) operand                                  |
*---------------------------------------------------------------------+
*
SELBY    LA    R2,SELBREC          Point at location to receive answer
         L     R3,=F'-1'           Set adjustment to -1
         B     SELNUMBR            Go to common code
*---------------------------------------------------------------------+
*        Process the LENGTH(...) operand                              |
*---------------------------------------------------------------------+
*
SELDLEN  LA    R2,SELNLGTH         Point at location to receive answer
         SR    R3,R3               Set adjustment to zero
         B     SELNUMBR            Go to common code
*---------------------------------------------------------------------+
*        Process numeric (...) operands                               |
*---------------------------------------------------------------------+
*
SELNUMBR TM    WRD1F2,OPRKWOPV     Do we have a sub-operand
         BZ    BADOPTYP            No, sorry
         TM    WRD1KW2+(KWF2-KWDSECT),KWNUMFUG Got a number
         BZ    BADKWVAL            No good
         ICM   R1,15,WRD1NUM2      Pick up the value
         BZ    BADKWVAL            Zero is no good
         AR    R1,R3               Adjust the value as needed
         ST    R1,0(R2)            Save it if OK
         B     SELLOOP             Go for another kw
*---------------------------------------------------------------------+
*        Process the TODD(...) operand                                |
*---------------------------------------------------------------------+
*
SELTODD  TM    WRD1F2,OPRKWOP      Got a sub-operand?
         BZ    BADOPTYP            No, error
         CLC   WRD1L2(10),MDSYSP   Is it SYSPRINT?
         BE    SELBDDN             SYSPRINT is a no-no
         $CALL DCBO1BLD,WRD1L2     No, go build DCB's etc
         B     BADDCB              Leave if NFG
         ST    R1,SELODCB          Save Ptr to O/P cntl area
         OI    SELF1,COPY          Activate copy
         B     SELLOOP             Go get another kw
         EJECT
*---------------------------------------------------------------------+
*        Process the GOTO(...) operand                                |
*---------------------------------------------------------------------+
*
SELGOTO  TM    WRD1F2,OPRKWOP      Got a sub operand?
         BO    SELGOTOS            Yes, go that route
*
SELGOTON $CALL GETNEXT             No, get next word then
         CLC   WORDL,=H'0'         End of sentence?
         BE    BADOPTYP            Yes, kill it
         TM    WRD1F2,OPRKW+OPRKWV Valid Keyword?
         BZ    SELGOTOP            Nope, sorry
         LA    R14,WRD1KW1         Point at KW answer area
         TM    KWF1,KWNOISE        Eliminate 'noise' words
         BO    SELGOTON            .
*
SELGOTOP LA    R2,WORDL            Point at the word
         B     SELGOTOM            Continue
*
SELGOTOS LA    R2,WRD1L2           Point at sub-operand
*
SELGOTOM CLC   0(2,R2),=H'80'      Too long?
         BNH   *+10                No, skip
         MVC   0(2,R2),=H'80'      Yes, shorten it
         MVC   SELGOTOH-2(82),0(R2) Now save it
         MVC   SELGOTOA,=F'1'      Flag as present
         B     SELLOOP
*---------------------------------------------------------------------+
*        Process the PRINT(...) operand                               |
*---------------------------------------------------------------------+
*
SELPRINT TM    WRD1F2,OPRKWOP      Do we have a sub-operand
         BZ    BADOPTYP            No, sorry
         TM    WRD1F2,OPRKWOP+OPRKWOPV Valid KW?
         BNO   SELRECSN            No, go try as numeric
         TM    PCTF2,DSYSPRT       Yes, better have a SYSPRINT DD then
         BZ    BADSYSPR            No, sorry
         LA    R14,WRD1KW2         Point at KW answer area
         CLI   KWNUM,X'94'         See if valid
         BL    BADKWORD            Sorry
         CLI   KWNUM,X'96'         .
         BH    BADKWORD            .
         OC    SELF1,KWD1          OR in the PRINT bits
         B     SELLOOP             And get next kw
         EJECT
*---------------------------------------------------------------------+
*        End of SELECT sentence processing                            |
*---------------------------------------------------------------------+
*
SELEOS   NI    PCTF1,255-ACTIVE    Turn off active flag
         EJECT
*---------------------------------------------------------------------+
*        Generate code for the SELECT sentence.                       |
*---------------------------------------------------------------------+
*
SELGEN   TM    SELF1,CHAR+HEX+COPY Any output requested
         BZ    SELTGOTO            No, was GOTO specified
         $ADD  4,DCOPM010          Add test for deferred copy
*
SELBACTV $INC  PCTMACNT            Count one more active SELECT
         B     SELBLDIT            Then go generate some code
*
SELTGOTO CLC   SELGOTOA,ZEROS      Was GOTO specified?
         BNE   SELTLEN             Yes, see if LENGTH(..) coded
         $ERR  SELWY,8,GO=MAINGOK  Error msg and goto next sentence
*
SELTLEN  CLC   SELNLGTH,ZEROS      This should be zeros then
         BE    SELBACTV            Correct, continue
         $ERR  ILLOG,4,GO=SELBACTV Message and let it continue
*
SELBLDIT CLC   SELNLGTH,ZEROS      A LENGTH(...) specified?
         BE    *+8                 No, skip
         OI    PCTF1,IPCOPY        Yes, force alternate buffer
         $ADD  SELGICRC-SELGBAL1,SELGBAL1
         LA    R15,SELNEXTS-SELGBAL1(,R1) Point at next sent Adcon
         ST    R15,SELSNEXT        And save it
         LA    R2,SELNREC-SELGBAL1(,R1) Point at RECS value
         GETMAIN R,LV=12           Get a RESET block
         MVC   0(4,R1),PCTRESET    Add to RESET chain
         ST    R1,PCTRESET         .
         ST    R2,4(R1)            Add address to be reset
         MVC   8(4,R1),0(R2)       Add value to be put back
         CLC   SELNREC,=X'7FFFFFFF' (ALL) recs?
         BE    SELTSREC            Yes, dont build count logic
         CLC   SELNREC,=F'-1'      Count set?
         BE    SELTSREC            No, skip build as well
*
SELBCOUN $ADD  SELGCRTS-SELGICRC,SELGICRC
*
SELTSREC CLC   SELSRECD,ZEROS      Start record?
         BE    SELTF1              No, ignore start rec code
*
SELBSREC $ADD  SELGBALO-SELGCRTS,SELGCRTS
*
SELTF1   TM    SELF1,CHAR+HEX+COPY Any outputs?
         BNZ   SELBOUTP            Yes, go gen output code
         CLC   SELBREC,ZEROS       Any BY (...) count ?
         BE    SELTKEY             No, skip the output code
*
SELBOUTP $ADD  SELGBCT1-SELGBALO,SELGBALO
*
SELTKEY  CLC   SELNREC,=X'7FFFFFFF' (ALL) ?
         BE    SELZGOTO            Yes, dont count
         CLC   SELNREC,=F'-1'      Count set?
         BE    SELZGOTO            No, skip genning code
*
SELBDECR $ADD  SELGLGO-SELGBCT1,SELGBCT1
*
SELZGOTO CLC   SELGOTOA,ZEROS      Was GOTO specified?
         BE    SELBNS              No, we're done
         $ADD  8,SELGLGO
         LA    R2,4(,R1)
         $CALL LBLOGEN,SELGOTOH-2,(R2) Go add to unresolved table
*
SELBNS   $ADD  0,*                 Get next IC
         L     R2,SELSNEXT         Get address of next sent Adcon
         ST    R1,0(R2)            Stuff address of next sent. in
         B     EXITGOK             Go to common command exit
         EJECT
*---------------------------------------------------------------------+
*        SELECT Error message routines                                |
*---------------------------------------------------------------------+
*
SELBADPT $ERR  BADPT,8,SKIP
*
SELBDDN  $ERR  BDDN,8,SKIP
         $PEND
         TITLE 'SETROUTE - Alter O/P ROUTES FOR ALL FCB''S'
*---------------------------------------------------------------------+
*        Process each FCB to reselect an output route                 |
*---------------------------------------------------------------------+
*
SETROUTE $PROC
         USING FCBDSECT,R7
         LA    R7,PCTFCB           Init to start of chain
*
SETCHAIN ICM   R7,15,0(R7)         Get next item on chain
         BZ    SETREX              Done? exit
         TM    FCBF2,FCBINPUT      An input DCB?
         BO    SETCHAIN            Yes, skip this one
         $CALL SDCBROUT,(R7)       No, process this FCB
         B     SETCHAIN            And loop back
*
SETREX   $RET  0                   Exit
         DROP  R7
         $PEND
         TITLE 'SNAPIT - SNAP compiled code'
*---------------------------------------------------------------------+
*        Snap generated program if in DEBUG SUPPORT(ON) mode          |
*        ===================================================          |
*                                                                     |
*        Called:   $CALL SNAPIT                                       |
*                                                                     |
*        Returns:  +0 on completionn                                  |
*---------------------------------------------------------------------+
SNAPIT   $PROC
         L     R5,PCTSUPP1         Get start of 1k blocks
*
SNPLP    CLC   0(4,R5),HEXFFS      End?
         BE    SNAPEX              Yes
         MVC   LINE(16),=C'Program Block >>'
         TM    0(R5),X'80'         Litpool block
         BZ    *+10                No, skip
         MVC   LINE(13),=C'Litpool Block'
         L     R2,0(R5)            Lower bound address
         LA    R2,0(R2)            Purify register
         LR    R4,R2               Upper bound address
         A     R4,=F'1024'         .
         SH    R4,=H'4'            .
         LA    R5,4(,R5)           Bump to next block
*
SNPLN    ST    R2,DBL              Put address into memory
         LR    R14,R4              Calc length left
         SR    R14,R2              .
         CH    R14,=H'32'          Still 32 bytes left?
         BL    SNPDO
         CLC   0(32,R2),ZEROS      Stop this block if all zeros
         BE    SNPLP
*
SNPDO    UNPK  LINE+17(7),DBL(5)   Put into print line
         TR    LINE+17(6),SNPTR-240
         MVI   LINE+23,C' '
         MVI   LINE+98,C'|'        Border characters
         MVI   LINE+131,C'|'       .
         MVC   LINE+99(32),0(R2)   EBCDIC version
         L     R1,=A(TRTBLC)       Get address of pretty chars
         TR    LINE+99(32),0(R1)   Eliminate crappy chars
         LA    R1,LINE+25
         LA    R0,8                Line counter
*
SNPAL    CR    R2,R4               At end of dump yet ?
         BH    SNPOUT
         C     R0,=F'4'            Check if halfway (add a
         BNE   *+8                 blank if we are)
         LA    R1,1(R1)
         MVC   DBL(4),0(R2)
         UNPK  0(9,R1),DBL(5)
         TR    0(8,R1),SNPTR-240
         MVI   8(R1),C' '
         LA    R1,9(,R1)
         LA    R2,4(,R2)
         BCT   R0,SNPAL
*
SNPOUT   STM   R0,R5,SNPREGS       Save regs
         BAL   R14,LINPRINT        Put the line
         LM    R0,R5,SNPREGS       Reload regs
         MVC   LINE,BLANKS         Blank it - not needed mostly
         CR    R2,R4               See if have more to dump
         BNH   SNPLN               Yes continue
         B     SNPLP               Loop till done
*
SNAPEX   $RET  0
         $PEND
         TITLE 'TIMEPROC - Get Time and date'
*---------------------------------------------------------------------+
*        Make a 'pretty' version of the current Time/Date             |
*        ================================================             |
*                                                                     |
*        Called:   $CALL TIMEPROC                                     |
*                                                                     |
*        Returns:  +0 on completion                                   |
*                                                                     |
*        Note:     On completion the TIMEWORK area is formatted as    |
*                  follows:                                           |
*                              X'yydddhhmmssmmmmm'                    |
*                              C'ddMTHyy (yyddd) hh:mm:ss.mmmmm'      |
*                              C'ccccmmdd'                            |
*---------------------------------------------------------------------+
*
TIMEPROC $PROC
         TIME  STCK,DBL,LINKAGE=SYSTEM Get the CLOCK
         L     R1,16               -> CVT
         L     R1,304(R1)          Get time zone constant
         AL    R1,DBL              Adjust STCK value
         ST    R1,DBL              .
         STCKCONV STCKVAL=DBL,CONVVAL=STCKWORK Convert it
*------- Build yydddhhmmssth000 in  1st 8 bytes------------------------
         L     R0,STCKWORK+8       Get R0=0yyyyddd
         L     R1,STCKWORK             R1=        hhmmssth
         SLDL  R0,12                R0/R1=yydddhhmmsth0000
         O     R1,=X'0000000F'
         STM   R0,R1,TIMEWORK      Save in answer area
*------- Build yyyymmdd in TIMECENT -----------------------------------
         STCKCONV STCKVAL=DBL,CONVVAL=STCKWORK, Convert again          X
               DATETYPE=YYYYMMDD
         SR    R0,R0               Get R0=00000000
         L     R1,STCKWORK+8           R1=        yyyymmdd
         SLDL  R0,4                 R0/R1=0000000yyyymmdd0
         O     R1,=X'0000000F'      R0/R1=0000000yyyymmdds
         STM   R0,R1,DBL2          Store in work area
         UNPK  TIMECENT(8),DBL2+3(5) Unpack it to answer area
*------- Edit to readable characters ----------------------------------
         UNPK  TIMEWORK+8(2),DBL2+6(2)
         SRL   R1,8                R1=0yyyymm0
         O     R1,=X'0000000F'     R1=0yyyymms
         N     R1,=X'00000FFF'     R1=00000mms
         SR    R0,R0               Get R0=00000000
         STM   R0,R1,DBL2          Make an index
         CVB   R1,DBL2             .
         MH    R1,=H'3'            .
         LA    R1,MTHTAB-3(R1)     Index into table
         MVC   TIMEWORK+10(3),0(R1) Move it
         OC    TIMEWORK+10(3),=C'    ' Uppercase it
         MVC   TIMEWORK+13(2),TIMECENT+2
         MVC   DBL2+5(3),TIMEWORK
         OI    DBL2+7,X'0F'
         UNPK  TIMEWORK+17(5),DBL2+5(3)
*------- Edit hh:mm:ss.hhhhh ------------------------------------------
         MVC   TIMEHMSH-2(L'EDITPAT1),EDITPAT1
         LM    R0,R1,TIMEWORK
         SRDL  R0,8
         STM   R0,R1,DBL2
         ED    TIMEHMSH-2(L'EDITPAT1),DBL2+3
         MVC   TIMEHMSH-2(2),=C') ' Replace clobbered chars
         $RET  0                   Return to caller
         $PEND
         TITLE 'TYPEOPER - Type an operand found by PARSE'
*---------------------------------------------------------------------+
*        Do detailed typeing of a sub-operand found by PARSE          |
*        ===================================================          |
*                                                                     |
*        Called:   $CALL TYPEOPER,operarea                            |
*                                                                     |
*        Operands: operarea - is operand area as defined by OPRDSECT  |
*                                                                     |
*        Returns:  +0 on completion                                   |
*                                                                     |
*        Notes:    The detailed fields of the operand area are        |
*                  completed by this routine.                         |
*                                                                     |
*                  OPRF2     - Operand type flags.                    |
*                  OPRKW1    - Completed if operand is a KW and has   |
*                              been successfully found in the KW      |
*                              table.                                 |
*                  OPRKW2    - Ditto OPRKW1 if the sub-operand is a   |
*                              KW.  Also set if suboperand is numeric.|
*                              KWNUMFUG is on and the number is in    |
*                              OPRNUM2.                               |
*---------------------------------------------------------------------+
*
TYPEOPER $PROC 1
         USING OPRDSECT,R7
         L     R7,12(R8)           Pick up passed area
         LH    R5,OPRL             Copy length value
         BCTR  R5,0                -1 for EX
         LA    R6,OPRTXT           Point at text
         TM    OPRF2,OPRPTR        An indirect type?
         BZ    *+8                 No
         L     R6,OPRADDR          Yes, pick up it's pointer
*---------------------------------------------------------------------+
*        Try as a normal numeric type.                                |
*---------------------------------------------------------------------+
*
TYPETRYN L     R15,=A(TRTBLN)      Get addr. of Num TRT table
         EX    R5,TYPETRT1         See if all numeric
         BNZ   TYPETRYS            No, go see if special numeric
         EX    R5,TYPEPAK1         Yes, convert it
         CVB   R1,DBL              .
         ST    R1,OPRNUM1          Save answer
         OI    OPRF2,OPRNUM        Set NUM flag
         B     TYPEEXIT            and exit
*---------------------------------------------------------------------+
*        Try as a special numeric type.                               |
*---------------------------------------------------------------------+
*
TYPETRYS L     R15,=A(TRTBLNN)     Get TRTable address
         EX    R5,TYPETRT1         See if any numerics
         BZ    TYPETRYK            No, go treat as KW then
         LR    R2,R1               Calc remaining length of numerics
         SR    R2,R6               .
         LR    R14,R5              .
         SR    R14,R2              .
         L     R15,=A(TRTBLN)      Get addr. of Num TRT table
         EX    R14,TYPETRT2        See if remainder is all numeric
         BNZ   TYPETRYK            No, then treat as KW
         EX    R14,TYPEPAK2        Yes, convert it
         CVB   R1,DBL              .
         ST    R1,OPRNUM1          Save answer
         OI    OPRF2,OPRNUM+OPRSPECN Set NUM flag
         B     TYPEEXIT            and exit
*---------------------------------------------------------------------+
*        Now try the KW type route.                                   |
*---------------------------------------------------------------------+
*
TYPETRYK LR    R15,R6              Point at start of word
         LA    R14,10              Set length limit
         CH    R5,=H'9'            If length of word is < 10
         BH    *+8                 Leave R14 at it's maximum
         LA    R14,1(,R5)          Else set R14 based on length of word
*
TYPEBRLP CLI   0(R15),C''''        Look for ' (Maybe a literal)
         BE    TYPESTLI            Yes, ' preceeds (, it's a literal
         CLI   0(R15),C'('         Look for (
         BE    TYPEGBRK            Got one, go extract value
         LA    R15,1(,R15)         No, bump
         BCT   R14,TYPEBRLP        Loop
         OI    OPRF2,OPRKW         Flag as some kind of KW
         B     TYPENSKW            No sub-KW, just process this one
*
TYPEGBRK OI    OPRF2,OPRKW         Flag as some kind of KW with operand
         TM    OPRF2,OPRPTR        Is this a pointer type?
         BZ    *+14                No, skip
         NI    OPRF2,255-OPRPTR    Yes, convert back to normal type
         MVC   OPRTXT,0(R6)        Copy data back to OPRTXT
         LH    R14,OPRL            Get orig length of word
         STM   R14,R15,TYPESAVE    Save for a while
         LR    R2,R15              Save address of (
         SR    R15,R6              Calc length of KW
         STH   R15,OPRL            Reset OPRL
         B     TYPEKWLK            Go lookup KW
*
TYPENSKW STM   R14,R15,TYPESAVE    Save for a while
         EJECT
*---------------------------------------------------------------------+
*        Go see if the KW is in the KW table.                         |
*---------------------------------------------------------------------+
*
TYPEKWLK $CALL KWRDSRCH,OPRL,OPRKW1
         B     *+12                +0 > Invalid KW
         OI    OPRF2,OPRKWV        +4 > Remember its a valid KW
         B     TYPESEO2            Go see if sub-operand
*---------------------------------------------------------------------+
*        Not in KW table, try operand prefix as numeric.              |
*---------------------------------------------------------------------+
         LH    R5,OPRL             Get length of it again
         BCTR  R5,0                -1 for EX's
         L     R15,=A(TRTBLN)      Point at TRT table
         LA    R6,OPRTXT           and at data
         TM    OPRF1,OPRPTR        .
         BZ    *+8                 .
         L     R6,OPRADDR          .
         EX    R5,TYPETRT1         See if all numeric
         BNZ   TYPEKWSP            No, See if special numeric then
         EX    R5,TYPEPAK1         Yes, convert it
         CVB   R1,DBL              .
         ST    R1,OPRNUM1          Save it
         OI    OPRF1,OPRNUM        Flag as a NUM operand
         NI    OPRF1,255-OPRKW     Remove KW flag
         B     TYPESEO2
*---------------------------------------------------------------------+
*        Operand prefix wasn't numeric, try special numeric.          |
*---------------------------------------------------------------------+
*
TYPEKWSP L     R15,=A(TRTBLNN)     Get TRTable address
         EX    R5,TYPETRT1         See if any numerics
         BZ    TYPETRYL            No, go try as literal
         LR    R2,R1               Calc remaining length of numerics
         SR    R2,R6               .
         SR    R5,R2               .
         L     R15,=A(TRTBLN)      Get addr. of Num TRT table
         EX    R5,TYPETRT2         See if remainder is all numeric
         BNZ   TYPESEO2            No, then treat as KW
         EX    R5,TYPEPAK2         Yes, convert it
         CVB   R1,DBL              .
         ST    R1,OPRNUM1          Save answer
         OI    OPRF2,OPRNUM+OPRSPECN Set NUM flag
         NI    OPRF1,255-OPRKW     Remove KW flag
         EJECT
*---------------------------------------------------------------------+
*        See if we had a sub-operand.                                 |
*---------------------------------------------------------------------+
*
TYPESEO2 LM    R14,R15,TYPESAVE    Restore regs
         LTR   R14,R14             Sub-operand?
         BZ    TYPETRYL            No, go try the literal
         OI    OPRF2,OPRKWOP       Remember we had a sub-operand
         LR    R5,R14              Swap original length to R5
         SH    R5,OPRL             Calc length of remaining bit
         SH    R5,=H'2'            Less 2 more for ()
         BNP   BADKWVAL            If -ve, kill it
         STH   R5,OPRL2            Save it
         MVC   OPRTXT2,1(R15)      Move text
         CH    R5,=H'10'           Is this a biggy?
         BNH   TYPESBKW            No, go see if KW
         LA    R15,1(,R15)         Adjust R15
         STCM  R15,15,OPRTXT2      Save in TXT2 as a pointer
         B     TYPEEXIT            And exit
*---------------------------------------------------------------------+
*        See if sub-operand was a KW.                                 |
*---------------------------------------------------------------------+
*
TYPESBKW $CALL KWRDSRCH,OPRL2,OPRKW2
         B     TYPEOPNM            +0 > Invalid KW
         OI    OPRF2,OPRKWOPV      +4 > It's valid
         B     TYPEEXIT            Exit, we're done
*---------------------------------------------------------------------+
*        Sub-operand wasn't a KW, try as numeric then.                |
*---------------------------------------------------------------------+
*
TYPEOPNM LH    R5,OPRL2            Get length of it again
         BCTR  R5,0                -1 for EX's
         L     R15,=A(TRTBLN)      Point at TRT table
         LA    R6,OPRTXT2          and at data
         NI    OPRKW2+(KWF2-KWDSECT),255-KWNUMFUG Clear KWNUMFUG
         EX    R5,TYPETRT1         See if all numeric
         BNZ   TYPEEXIT            No, forget it
         EX    R5,TYPEPAK1         Yes, convert it
         CVB   R1,DBL              .
         ST    R1,OPRNUM2          Save it
         OI    OPRF2,OPRKWOPV      Say KW2 area is valid
         OI    OPRKW2+(KWF2-KWDSECT),KWNUMFUG Say OPRNUM2 is valid
         MVI   OPRKW2+(KWNUM-KWDSECT),X'00'   Clear any valid KW numb.
         B     TYPEEXIT
         EJECT
*---------------------------------------------------------------------+
*        Last  see if it's a literal type.                            |
*---------------------------------------------------------------------+
*
TYPETRYL L     R15,=A(TRTBLQ)      Get address of quote TRTable
         EX    R5,TYPETRT1         See if any quotes
         BZ    TYPEDFKW            No, call it a KW
*
TYPESTLI OI    OPRF2,OPRLIT        Yes, flag as a literal
*
TYPEEXIT $RET  0                   Exit now
*
TYPEDFKW OI    OPRF2,OPRKW         Flag as some kind of KW
         B     TYPEEXIT
*
TYPETRT1 TRT   0(0,R6),0(R15)
TYPETRT2 TRT   0(0,R1),0(R15)
TYPEPAK1 PACK  DBL,0(0,R6)
TYPEPAK2 PACK  DBL,0(0,R1)
TYPESAVE DS    2F
         DROP  R7
         $PEND
         TITLE 'Data areas'
         ORG   SELECTIT+((*-SELECTIT+31)/32*32)
*---------------------------------------------------------------------+
*        Program control table                                        |
*---------------------------------------------------------------------+
*
PCT      DS    0F
SAVEAREA DS    18F
PCTHEAD  DC    C'================================'
         DC    C'=     SELECTIT VERSION 1.0b    ='
         DC    C'================================'
PCTVERNO EQU   PCTHEAD+55,4,C'C'
         PRINT NOGEN
*
PCTF1    DC    X'00'
DCOPYGEN       EQU         X'80'   ALTER has genned DCOPYDAT test
DFLTFLAG       EQU         X'40'   No SYSIN, default images used
TSOSTEP        EQU         X'20'   This is a TSO step
IPCOPY         EQU         X'08'   ALTER copies from I/P record
ACTIVE         EQU         X'04'   Compiler is processing a command
EXEC           EQU         X'02'   Program is executing in user pgm
STAT           EQU         X'01'   Msg to be processed to stat chain
PCTF2    DC    X'00'
DSYSPRT        EQU         X'80'   SYSPRINT DD is present
DSYSIN         EQU         X'40'   SYSIN    DD is present
DINPUT1        EQU         X'20'   INPUT1   DD is present
DOUTPUT1       EQU         X'10'   OUTPUT1  DD is present
PCTF3    DC    AL1(0)
DEFREOF        EQU         X'80'   Deferred end of file on SYSIN
FAST           EQU         X'20'   Doing a FASTCOPY route
INPUT          EQU         X'10'   Input is an 'official' one
DCBOPT         EQU         X'08'   DDname to be built is optional
ALL            EQU         X'04'   Copy 'ALL' present somewhere
OPKWLEN        EQU         X'02'   Length operand is a KW field
COMPALTR       EQU         X'01'   Compiling an ALTER command
PCTF4    DC    AL1(COMPILE+IODONE)
NOFLAG         EQU         X'80'   Don't flag error line
PWAITING       EQU         X'40'   Cmd print line waiting
COMPILE        EQU         X'20'   Executing in compile phase
LABLLOOK       EQU         X'10'   GETNEXT looking for a LABEL:
ABENDING       EQU         X'08'   Pgm is shutting down after an abend
IFDONEW        EQU         X'04'   IF has gotten the TRUE word
IFNXSENT       EQU         X'02'   IF requires next sentence completed
IODONE         EQU         X'01'   Set whenever I/O is done
PCTF5    DC    X'00'
SHUTSEL        EQU         X'80'   Forces shutdown of SELECT block
FWTYPE         EQU         X'40'   Fullword/Halfword literal switch
IFAOPG         EQU         X'20'   IF code to -> A-op genned
IFRELG         EQU         X'10'   IF has gotten test operand
IFBOPG         EQU         X'08'   IF has gotten B-op at least once
STATPRNT       EQU         X'04'   ERPRINT processing stats msg chain
PCTF6    DC    AL1(OPCHECK)
OUTPUT         EQU         X'80'   DCB build is building an output set
TRYFAST        EQU         X'40'   Make attempt at FASTCOPY route
EOS            EQU         X'20'   End of sentence
EOD            EQU         X'10'   Real end of SYSIN occurred
USERRC         EQU         X'08'   User has modified RCODE
OPCHECK        EQU         X'04'   Check for real O/P requests
DEFRCOPY       EQU         X'02'   Deferred I/P -> O/P copy
PCTF7    DC    AL1(TIMEFLAG)
DBDUMP         EQU         X'80'   DEBUG DUMP flag
DBIOTRAC       EQU         X'40'   DEBUG IO Trace flag
DBTRACE        EQU         X'20'   DEBUG Logic Trace flag
UCTRDUMP       EQU         X'08'   UCTRx print at EOJ
TIMEFLAG       EQU         X'02'   TIMEEXIT wants STIMER issued
TIMEBOMB       EQU         X'01'   TIMEEXIT has forced an abend
PCTF8    DC    X'00'               Still more flags
PDSMODE        EQU         X'80'   We're in PDS Mode processing
PDSEMPTY       EQU         X'40'   I/P PDS has no members
PDSSTATS       EQU         X'20'   Full PDS Stats wanted
CBLKSIZE       EQU         X'10'   CBLKSIZE(YES) specified
PCTIOFLG DC    X'00'
IOFLOATA       EQU         X'80'   A-operand is floating
IOFLOATB       EQU         X'40'   B-operand is floating
IODLML         EQU         X'20'   DLM type copy, OREGDLMT -> Table
IONOEXPC       EQU         X'10'   No Expand/Contract on ALTER
IOPACKED       EQU         X'08'   A or B operand is Packed Decimal
IOMASK         EQU         X'04'   An IF MASK function
IONOAADJ       EQU         X'02'   Don't adjust A-operand in REPLACE
IONOBADJ       EQU         X'01'   Don't adjust B-operand in REPLACE
PCTIOFL2 DC    X'00'
IOUCTRX        EQU         X'80'   A or B operand is a UCTR
PCTABEND DC    A(0)                ABEND code saved by STAE exit
PCTPFCB  DC    A(0)                Address of SYSPRINT FCB
PCTIFCB  DC    A(0)                Address of SYSIN    FCB
PCT1FCB  DC    A(0)                Address of INPUT1   FCB
PCT2FCB  DC    A(0)                Address of OUTPUT1  FCB
PCTPDCB  DC    A(0)                Address of SYSPRINT DCB
PCTIDCB  DC    A(0)                Address of SYSIN    DCB
PCT1DCB  DC    A(0)                Address of INPUT1   DCB
PCT2DCB  DC    A(0)                Address of OUTPUT1  DCB
PCTCFLAG DC    X'00'               GETNEXT copy flag
COPYBUFF       EQU       X'80'     COPYBUFF requested
PCTIPRET DC    AL3(COPRETN)        Current I/P return address
PCTIPFCB DC    A(0)                Current I/P FCB address
PCTIPEOF DC    A(ADDSTATS)         Current I/P EOF address
PCTGMLIT DC    3A(0)               Litpool GETMAIN control area
PCTLAST  DC    A(0)                Last stmnt # entered in execution
PCTPGM   DC    A(0)                Start address of 'compiled' pgm
PCTPGMS  DC    A(0)                Saved PCTPGM during 'GETNEXT'
PCTERCHN DC    A(0)                Start of error message chain
PCTSTCHN DC    A(0)                Start of statistics msg chain
PCTFLCHG DC    F'0'  |\            Difference in lgths last ALTER 0
PCTSCLEN DC    F'0'  | \           Length of last 'IF' scan found
PCTPLOC  DC    F'0'  |  \          I/P offset of last 'IF' scan found
PCTPLOCE DC    F'0'  |Keep togeth. I/P offset of IF scan end(PLOCEND)
PCTFLOCE DC    F'0'  |  /          I/P offset of IF scan end(FLOCEND)
PCTFLOCT DC    F'0'  | /           O/P offset last byte mvd (FLOCTERM)
PCTFLEN  DC    F'0'  |/            Length of last ALTER COPY
PCTRC    DC    F'0'                Highest return code
PCTUBFSZ DC    F'1024'             Default size of UBUFFx areas
PCTINPT1 DC    A(0)                Address of Input buffers
PCTINPT2 DC    A(0)                .
PCTINPT3 DC    A(0)                .
PCTINPT4 DC    A(0)                .
PCTINPT5 DC    A(0)                .
PCTINPT6 DC    A(0)                .
PCTINPT7 DC    A(0)                .
PCTINPT8 DC    A(0)                .
PCTINPT9 DC    A(0)                .
PCTOUTPT DC    A(0)                Address of output record
PCTUBFA  DC    A(0)                Address of user buffers
PCTUBFB  DC    A(0)                .
PCTUBFC  DC    A(0)                .
PCTUBFD  DC    A(0)                .
PCTUBFE  DC    A(0)                .
PCTUBFF  DC    A(0)                .
PCTUBFG  DC    A(0)                .
PCTUBFH  DC    A(0)                .
PCTUBFI  DC    A(0)                .
PCTUBFJ  DC    A(0)                .
PCTUBFK  DC    A(0)                .
PCTUBFL  DC    A(0)                .
PCTUBFM  DC    A(0)                .
PCTUBFN  DC    A(0)                .
PCTUBFO  DC    A(0)                .
PCTUBFP  DC    A(0)                .
PCTUBFQ  DC    A(0)                .
PCTUBFR  DC    A(0)                .
PCTUBFS  DC    A(0)                .
PCTUBFT  DC    A(0)                .
PCTUBFU  DC    A(0)                .
PCTUBFV  DC    A(0)                .
PCTUBFW  DC    A(0)                .
PCTUBFX  DC    A(0)                .
PCTUBFY  DC    A(0)                .
PCTUBFZ  DC    A(0)                .
PCTINPL1 DC    9F'0'               Lengths of current I/P records
PCTOBUFL DC    F'0'                Current length of rec in O/P buffer
PCTUBFL1 DC    26F'0'              Length's of user buffers
PCTMACNT DC    F'0'                Master active count
PCTCOUNT DC    F'0'                Current record number of INPUT1
PCTFCB   DC    A(0)                Start of FCB chain
PCTFILNO DC    F'0'                Input file number
PCTMAINC DC    A(MAINCOMP)         Address of main Compiler logic
PCTSUPP1 DS    F                   SUPPORT(ON) Getmain values
PCTSUPP2 DS    F                   SUPPORT(ON) Getmain values
PCTPOPLS DC    A(0)                Last POP'ed Next sentence adcon
PCTNEST  DC    F'0'                Count of nested IF's
PCTNEXT  DC    20A(0)              Stack of next sentences.
PCTUCTRA DC    F'0'                User counters A -> Z
PCTUCTRB DC    F'0'                .
PCTUCTRC DC    F'0'                .
PCTUCTRD DC    F'0'                .
PCTUCTRE DC    F'0'                .
PCTUCTRF DC    F'0'                .
PCTUCTRG DC    F'0'                .
PCTUCTRH DC    F'0'                .
PCTUCTRI DC    F'0'                .
PCTUCTRJ DC    F'0'                .
PCTUCTRK DC    F'0'                .
PCTUCTRL DC    F'0'                .
PCTUCTRM DC    F'0'                .
PCTUCTRN DC    F'0'                .
PCTUCTRO DC    F'0'                .
PCTUCTRP DC    F'0'                .
PCTUCTRQ DC    F'0'                .
PCTUCTRR DC    F'0'                .
PCTUCTRS DC    F'0'                .
PCTUCTRT DC    F'0'                .
PCTUCTRU DC    F'0'                .
PCTUCTRV DC    F'0'                .
PCTUCTRW DC    F'0'                .
PCTUCTRX DC    F'0'                .
PCTUCTRY DC    F'0'                .
PCTUCTRZ DC    F'0'                .
PCTBFCDF DC    AL1(COPYBUFF)       COPYBUFF default for INPUT1
PCTEOFFL DC    X'FF'               Buffer fill character at EOF
PCTPADCH DC    X'40'               Buffer fill character (Buffers)
PCTSUBSV DC    A(SUBSAVE1)         Current stack pointer
PCTIMEMB DC    CL8' '              I/P Member in PDSMODE
PCTOMEMB DC    CL8' '              O/P Member name to create
PCTMEMBT DC    A(0)                Address of member table
PCTMEMBC DC    A(0)                'Current' member name
PCTRESET DC    A(0)                Address of reset chain
PCTUPARM DC    CL8' '              User PARM field
         EJECT
*---------------------------------------------------------------------+
*        Miscellaneous work areas                                     |
*---------------------------------------------------------------------+
ONESEC   DC    F'38400'
HEXFFS   DC    X'FFFFFFFF'
         CNOP  2,4
         DS    C
FOXZERO  DC    X'F0'               Must be in front of zeros
ZEROS    DC    32X'00'
SNPTR    DC    C'0123456789ABCDEF'
SNPREGS  DS    6F
DBL      DC    D'0'
         DC    D'0'                Don't move, used by TIME STCK
DBL2     DS    2D
ALTAKWLN DC    F'0'
ALTGTSVR DS    F
DEFLRECL DC    H'0'
DEFBLKSI DC    H'0'
DEFRECFM DC    X'00'
PROLRECL DC    H'0'
PROBLKSI DC    H'0'
COMNTCTL DC    P'000'              Comment nest counter
IFEXR    DC    A(0)
STAESAVE DS    16F
OPRSAVE  DS    16F
CPYSV    DS    16F
DMPSV    DS    16F
ALTGEDT1 DC    X'4020206B2020206B2020206B20212060'
ALTGEDT2 DC    X'402020206B2020206B2021204B202060'
ERRSV1   DS    F
ERRCWORK DC    16X'00'
DDNAME   DS    CL8
DEVTAB   DS    2F
OPEXSV14 DS    F
OPEXFCBP DS    F
JFCB     DS    CL176
OBTCMLST CAMLST SEARCH,JFCB,JFCBVOLS,DSCB
DCBHLREC DC    H'0'
DCBALREC DC    H'0'
DCBASNO  DC    PL3'0'
DCBAWNO  DC    PL3'0'
DMPADDR  DS    F
DMPLRECL DS    H
TRSV     DS    4F
WKTIOT   DS    2F
         CNOP  2,4                 Align the next
         DC    X'00'               few fields
TRFLAG   DC    AL1(DUMP+SPTR)
TRADDR   DC    XL4'00'
TRLGTH   DC    XL4'00'
MSG52CLS DC    C' '
TSOREADY DC    C'SELECTIT.. Ready'
TRHD     DC    C'(........) Rec ',X'20202020202120',C')'
ERRTMSG  DC    CL132' '
MDSYSP   DC    H'8',C'SYSPRINT',AL2(DSYSPRT)
MDSYSI   DC    H'5',C'SYSIN   ',AL2(DSYSIN)
MDINPT1  DC    H'6',C'INPUT1  ',AL2(DINPUT1)
MDOUTP1  DC    H'7',C'OUTPUT1 ',AL2(DOUTPUT1)
         DC    X'00000000'
TRLINE   DC    CL133' '
         DC    C'X'
TRPOS    DC    A(TRLINE+31)        Current position in trace line
TREND    DC    A(TRLINE+131)       End of trace line
*
STCKWORK DS    XL16                Work area for STCKCONV
*
TIMEWORK DS    0D
TIMEXVAL DC    XL8'00'
TIMEDMY  DC    CL7' '
         DC    C' '
TIMEYDDD DC    CL7'(     )'
         DC    C' '
TIMEHMSH DC    CL14' '
         DC    C' '
TIMECENT DC    C'        '
EDITPAT1 DC    X'402120207A20207A20204B2020202020'
MTHTAB   DC    C'JanFebMarAprMayJunJulAugSepOctNovDec'
SWASAVE  DS    16F
         TITLE 'PARSE work areas'
*---------------------------------------------------------------------+
*        PARSE routine areas.                                         |
*---------------------------------------------------------------------+
*
*              WFLAG1 is set by PARSE to show what was 'seen'
*
WFLAG1   DC    X'00'
WPREF          EQU   X'80'         Prefix is present
WWRD1          EQU   X'40'         WRD1   is present
WWRD2          EQU   X'20'         WRD2   is present
WTRLR          EQU   X'10'         TRLR   is present
WPLUS          EQU   X'08'         WRD1/WRD2 connected by +
WMINUS         EQU   X'04'         WRD1/WRD2 connected by -
*
*              WFLAG2 set by caller of OPGEN to say what's wanted/O.K.
*
WFLAG2   DC    X'00'
WAOP           EQU   X'80'         Generate an A-operand
WBOP           EQU   X'40'         Generate a  B-operand
WPREFOK        EQU   X'20'         Prefixing is allowed
WTRLROK        EQU   X'10'         Trailers are allowed
WPMOK          EQU   X'08'         +/- operands allowed
WLITOK         EQU   X'04'         Literals are allowed
WIPDEF         EQU   X'02'         I/O default to Input (else Output)
*
*---------------------------------------------------------------------+
*   If the 1st 12 bytes of these 4 scan areas change then the code at |
*   the beginning of PARSE which clears them must also be altered.    |
*---------------------------------------------------------------------+
*
PREFNUM1 DC    F'0'                Prefix area
PREFNUM2 DC    F'0'
PREFF1   DC    X'00'
PREFF2   DC    X'00'
PREFL    DC    H'0'
PREFTXT  DC    CL10' '
PREFADDR EQU   PREFTXT,4,C'A'
PREFL2   DC    H'0'
PREFTXT2 DC    CL10' '
PREFKW1  DS    CL(KWENTL)
PREFKW2  DS    CL(KWENTL)
*
WRD1NUM1 DC    F'0'                Main word area
WRD1NUM2 DC    F'0'
WRD1F1   DC    X'00'
WRD1F2   DC    X'00'
WRD1L    DC    H'0'
WRD1TXT  DC    CL10' '
WRD1ADDR EQU   WRD1TXT,4,C'A'
WRD1L2   DC    H'0'
WRD1TXT2 DC    CL10' '
WRD1KW1  DS    CL(KWENTL)
WRD1KW2  DS    CL(KWENTL)
*
WRD2NUM1 DC    F'0'                +/- word area
WRD2NUM2 DC    F'0'
WRD2F1   DC    X'00'
WRD2F2   DC    X'00'
WRD2L    DC    H'0'
WRD2TXT  DC    CL10' '
WRD2ADDR EQU   WRD2TXT,4,C'A'
WRD2L2   DC    H'0'
WRD2TXT2 DC    CL10' '
WRD2KW1  DS    CL(KWENTL)
WRD2KW2  DS    CL(KWENTL)
*
TRLRNUM1 DC    F'0'                Trailer word area
TRLRNUM2 DC    F'0'
TRLRF1   DC    X'00'
TRLRF2   DC    X'00'
TRLRL    DC    H'0'
TRLRTXT  DC    CL10' '
TRLRADDR EQU   TRLRTXT,4,C'A'
TRLRL2   DC    H'0'
TRLRTXT2 DC    CL10' '
TRLRKW1  DS    CL(KWENTL)
TRLRKW2  DS    CL(KWENTL)
         TITLE 'Code generation work areas'
*---------------------------------------------------------------------+
*        Data work areas for generation of operand addresses.         |
*---------------------------------------------------------------------+
         DS    0F
ORLCODE  BAL   R15,COMP15X4        BAL over data
OREGM    DS    0F
OREGALEN DC    X'00'               Length of A-operand
OREGDLMT DS    0AL3(0)             Address of DLM TRT table
OREGFLAG DC    X'00'               Flag? Spare for now
OREGBLEN DC    H'0'                Length of B-operand
ORLICM   ICM   OREG,15,0(R15)      Load OREG
ORLMVI   MVI   PCTIOFLG,0          Restore PCTIOFLG
ORLMVID  EQU   *-3,1,C'X'          Data portion of prev instr.
ORLM999  EQU   *                   End of OREG code
*
ORLLCOD  ICM   OREG,15,0           Load KW data as length operand
ORLLCODB BCTR  OREG,0              -1 for EX (Sometimes)
         DS    0F
*
OPGCODE  BAL   R15,COMP15X8        BAL over data
OPGBASE  DC    A(0)                Base value for ICM1 and ICM2 below
*                                  Hi byte of OPGBASE has the file
*                                  ID when we're pointing at a file
*                                  buffer, or 00 when pointing at a
*                                  literal or fixed memory location.
OPGDISPL DC    F'0'                Displacement value
OPGICM1  ICM   AREG,15,0(R15)      Load base value into register
OPGICM2  ICM   AREG,7,1(AREG)      Do indirect load
OPGADD1  AL    AREG,4(,R15)        Add displacement
OPGENDC  EQU   *
*
OPGBCTR  BCTR  AREG,0              Decr. when KW displacement used
*
OPGSWAP1 LR    AREG,BREG           Swap value to correct reg
*
OPGMASK  DS    0XL12               Mask to clear AREG/BREG from instr.
OPGMASK1 DC    X'FF0FFFFF'         ICM 1
OPGMASK2 DC    X'FF0F0FFF'         ICM 2
OPGMASK3 DC    X'FF0FFFFF'         AL
*
OPGAREG  DS    0XL12               Model to set to AREG
OPGAREG1 DC    X'00',AL1(AREG*16),X'0000'          ICM 1
OPGAREG2 DC    X'00',2AL1(AREG*16),X'00'           ICM 2
OPGAREG3 DC    X'00',AL1(AREG*16),X'0000'          AL
*
OPGBREG  DS    0XL12               Model to set to BREG
OPGBREG1 DC    X'00',AL1(BREG*16),X'0000'          ICM 1
OPGBREG2 DC    X'00',2AL1(BREG*16),X'00'           ICM 2
OPGBREG3 DC    X'00',AL1(BREG*16),X'0000'          AL
*
OPGCADDR DS    F                   Address where code stuffed
         EJECT
*---------------------------------------------------------------------+
*        SELECT routine work areas                                    |
*---------------------------------------------------------------------+
SELSNEXT DS    F                   Temp save next sent Adcon address
         DS    0F
*
SELGBAL1 BAL   R15,SELGLDEX-SELGBAL1(R14) Get addressable
SELID    DC    X'CC'               Control block ID
SELF1    DC    X'00'               SELECT flag 1
CHAR           EQU         X'80'   CHAR dump requested
HEX            EQU         X'40'   HEX   "      "
DUMP           EQU         X'C0'   HEX/CHAR dump requested
COPY           EQU         X'20'   Copy to output DD requested
SPTR           EQU         X'10'   Special pointers for IODUMP
SELF2    DC    X'00'               SELECT flag 2
SELF3    DC    X'00'               SELECT flag 3
SELSRECD DC    F'0'                SREC record number
SELBREC  DC    F'0'                BY record number
SELBCTR  DC    F'0'                BY record counter
SELNREC  DC    F'0'                Number of records
SELODCB  DC    A(0)                Address of output ctl area
SELNEXTS DC    A(0)                Address of next sentence
SELNLGTH DC    F'0'                Data length for this select
SELGLDEX LM    R2,R3,$SELNXTS      Load exit addresses
SELGSWP1 LR    R14,R2              Put next sent in R14
SELGICRC ICM   R1,15,$SELNREC      Load number of records
SELGTZ1  BZR   R14                 If zero, go next sentence
SELGCRTS CLC   $SELSREC,PCTCOUNT   At start rec yet?
SELGNSSK BHR   R14                 No, go to next sentence
SELGBALO BAL   R14,OPROUTE         Bal to copy output control
SELGBCT1 BCTR  R1,0                Decrement number of recs
SELGSTNR ST    R1,$SELNREC         And store it back
SELGBALT BALR  R7,0                Get addressable for SELGUPSK
SELGALLT LTR   R1,R1               All records selected?
SELGUPSK BNZ   SELGLGO-SELGALLT(R7) Skip over table flag update
SELGLMAC L     R1,PCTMACNT         Get master actv count
SELGBCT2 BCTR  R1,0                Decr. It
SELGSMAC ST    R1,PCTMACNT         Store it back
SELGLGO  BAL   R14,COMPGOTO        Go via GOTO support routine
SELGOTOA DC    XL4'00'             GOTO address
SELGM999 EQU   *
         DC    H'0'
SELGOTOH DC    CL80' '             Hold for actual GOTO name
         DS    0F
SELSKDF  DC    AL1(63),AL3(ZEROC)
SELEKDF  DC    AL1(63),AL3(FFFF)
         TITLE 'EXecuted instructions'
*---------------------------------------------------------------------+
*        EXecuted instructions                                        |
*---------------------------------------------------------------------+
DMPTR1   TR    LINE+31(0),0(R15)
GETFTRT  TRT   0(0,R3),0(R14)
GETMV1   MVC   0(0,R2),0(R3)
GETOR1   OC    0(0,R3),BLANKS
GETOR2   OC    0(0,R2),BLANKS
KEYCOMP  CLC   0(0,R1),0(R2)
LITTNUM  TRT   0(0,R2),0(R14)
LITPACK  PACK  DBL,0(0,R2)
         TITLE 'Extra ALTER work areas'
*---------------------------------------------------------------------+
*        ALTER command work areas and model code                      |
*---------------------------------------------------------------------+
ALTD1    DC    F'0'                Save for KWD1 answer value
ALTD3    DC    F'0'                Save for KWD3 answer value
ALTGDISP DC    F'0'                Displacement of A-operand
ALTLITSV DC    F'0'                Save for address of DLM literal
ALTGABUF DC    X'00'               Buffer index of A-operand
*
ALTGMMVC EX    OREG,COMPMVC        Execute MVC instruction
ALTGMST1 LA    OREG,1(,OREG)       Make length actual again
ALTGMST2 ST    OREG,PCTFLEN        Save as ALTER's length
ALTGMAND EX    OREG,COMPNC         Execute NC  instruction
ALTGMOR  EX    OREG,COMPOC         Execute OC  instruction
ALTGMXOR EX    OREG,COMPXC         Execute XC  instruction
ALTGMTR  EX    OREG,COMPTR         Execute TR  instruction
*
ALTGMREP BAL   R14,REPLACE         Go do replace
*
ALTGMHEX BAL   R14,HEXIT           Go do Hex conversion
*
ALTGRCST OI    PCTF6,USERRC        Remember user altered RCODE
         TITLE 'Model Code and Associated work areas'
DCOPM010 BAL   R14,DCOPYDAT        See if deferred copy needed
*---------------------------------------------------------------------+
*        Getword routine work areas                                   |
*---------------------------------------------------------------------+
GETPTR   DC    A(0)                Ptr to next loc in card
GETSCLN  DC    A(0)                Length to scan
GETWDPT  DC    A(0)                Next available loc in 'word'
GETCTR1  DC    PL3'0'              Count of cards read
GETCTR2  DC    PL3'0'              Count of word in a card
GETDPTRS DC    A(GETDF1,GETDF2,0,GETDF3,0)
GETIMAGE DC    A(0)                Ptr to start of card
GETWSTRT DC    A(0)                Ptr to start of word
         EJECT
*---------------------------------------------------------------------+
*        LITPOOL routine work areas                                   |
*---------------------------------------------------------------------+
LIT1STQ  DS    F                   Loc. Of 1st quote
LIT2NDQ  DS    F                   Loc. Of 2nd quote
LITZERO  DC    C'0000'             Const. Must be on word boundary
LITW1    DS    F                   Work field
LITFILL  DS    C                   Fill char if lgth > supplied value
LITL     DS    F                   Effective length of processed lit.
LITA     DS    A                   Absolute address of literal
LITR     DC    F'1'                Literal repeat factor
LITSRSV  DS    3F                  Repeat regs save area
LITLGTH  DC    H'0'                Temp work value of lit. Length
LITT     DC    C' '                Type of last literal processed
*
*---------------------------------------------------------------------+
*        PGMSTUFF routine work areas                                  |
*---------------------------------------------------------------------+
PGMIC    DC    F'0'                Instruction counter
PGMRESID DC    F'0'                Remaining area in curr. Getmain
PGMRSTRT DC    2F'0'               Save in case restart invoked
*
*        NOTE! The following link code MUST NOT alter the cc!
*
         DS    0F
PGMLINKS BALR  R14,0               Get locally addressable
         L     R14,6(R14)          Load address of next block
         BR    R14                 Go to it
PGMMADCN DC    4X'00'              Address to be stuffed
PGMLINKE EQU   *                   End of linkage code
*
*---------------------------------------------------------------------+
*        Label table routine work areas                               |
*---------------------------------------------------------------------+
LBLHOLD  DC    CL8' '              Temp hold of label to be added
LBLIN    DC    A(0)                Start of label table in
LBLINCT  DC    F'0'                Number of empty entries in tbl
LBLOUT   DC    A(0)                Start of unresolved label table
LBLOUTCT DC    F'0'                Number of empty entries in tbl
LBLSV12  DC    A(0,0)              Save for R1,R2
         EJECT
*---------------------------------------------------------------------+
*        Miscellaneous equates                                        |
*---------------------------------------------------------------------+
DCBDEVT  EQU   17
DCBDSORG EQU   26
DCBBFTEK EQU   32
DCBEODAD EQU   33
DCBRECFM EQU   36
DCBEXLST EQU   37
DCBDDNAM EQU   40
DCBOFLAG EQU   48
DCBMACRF EQU   50
DCBOPTCD EQU   52
DCBBLKSI EQU   62
DCBRECAD EQU   76
DCBEXCD1 EQU   80
DCBLRECL EQU   82
DS1DSORG EQU   82
DS1RECFM EQU   84
DS1BLKSI EQU   86
DS1LRECL EQU   88
JFCDSNAM EQU   JFCB,44,C'C'
JFCBELNM EQU   JFCB+44,8,C'C'
JFCLRECL EQU   JFCB+62,2,C'H'
JFCBIND1 EQU   JFCB+86,1,C'X'
JFCDSORG EQU   JFCB+98,2,C'X'
JFCRECFM EQU   JFCB+100,1,C'X'
JFCBLKSI EQU   JFCB+102,2,C'H'
JFCBNVOL EQU   JFCB+117,1,C'X'
JFCBVOLS EQU   JFCB+118,30,C'C'
         TITLE 'Big crap'
BLANKS   DC    CL133' '
PARMDATA DC    CL120'OPTIONS '
MASKTBL  DC    X'00',255X'FF'
TRTABLE  DC    XL256'00'
WORDL    DC    H'0'
WORDTXT  DS    CL300
SUBSAVE1 DS    50A(0)              GOSUB stack
SUBSAVE2 EQU   *                   End of stack
         TITLE 'SWA Block access'
*---------------------------------------------------------------------+
*        Routine to get a block from SWA                              |
*---------------------------------------------------------------------+
         PUSH  USING
         DROP
         USING GTSWABLK,R2
*
GTSWABLK ST    R14,GTSWARET        Save ret address
         LA    R0,ZBAREA           Init pointer
         ST    R0,ZBPTR            to area for SWAREQ
         MVC   SWVA-ZB505+ZBAREA,0(R1) Copy token
         L     R1,=A(*+6+X'80000000')  31-bit mode
         BSM   R0,R1               ...
         SWAREQ EPA=ZBPTR,FCODE=RL, Get block                          X
               UNAUTH=YES,                                             X
               MF=(E,SWALIST)
         LTR   R15,R15             Got block ?
         BNZ   GTSWAXIT            No - err exit
         L     R15,SWPFXPTR-ZB505+ZBAREA Get blk prefix addr
         L     R1,SWLNGTH-ZB505+ZBAREA   Get block len
         AH    R1,SWPFXLTH-ZB505+ZBAREA  + prefix len
         BCTR  R1,0                      -1 for "EX"
         MVC   SWABLKA(0),0(R15)   Move prefix + block
         EX    R1,*-6              ...
         SLR   R15,R15             Set rc=0
*
GTSWAXIT LA    R1,*+6              24-bit
         BSM   R0,R1               ...
         L     R14,GTSWARET        Load return address
         BR    R14                 Exit, rc= R15
GTSWARET DS    A
*
SWALIST  SWAREQ MF=L
*
ZBAREA   DS    CL(L'SWAEPAX)       SWA manager work area
ZBPTR    DS    F
SWABLKA  DS    CL256
         LTORG
         POP   USING
         TITLE 'Unaddressable (Normally) Data areas'
*---------------------------------------------------------------------+
*        Error message text strings                                   |
*---------------------------------------------------------------------+
         PRINT NOGEN
         $TXT  1,RSVDWD,'Reserved label used.'
         $TXT  2,BADC,'Invalid command type.'
         $TXT  3,NOPER,'Period missing, assumed.'
         $TXT  4,BADAT,'Invalid ALTER type code.'
         $TXT  5,BADN,'Invalid numeric operand.'
         $TXT  6,LITBT,'Invalid literal type.'
         $TXT  7,LITBH,'Invalid HEX value.'
         $TXT  8,LITBL,'Invalid literal length.'
         $TXT  9,LITBQ,'Invalid use of quotes in literal.'
         $TXT  10,LITBN,'Invalid numeric value in literal.'
         $TXT  11,LBLDP,'Duplicate label encountered, ignored.'
         $TXT  12,UNRES,'Unresolved label.'
         $TXT  13,BDDST,'Operand invalid as a destination field'
         $TXT  14,BADPT,'Invalid PRINT request.'
         $TXT  15,BADKW,'Invalid keyword found.'
         $TXT  16,NODO,'No ''END'' encountered for a ''DO'' group or inX
               complete ''IF'' command.'
         $TXT  17,BKEY,'Invalid KEY operand.'
         $TXT  18,LCONF,'Conflicting length operands detected'
         $TXT  19,BKWV,'Invalid value for a KEYWORD operand.'
         $TXT  20,NESTH,'IF/DO nesting level exceeded.'
         $TXT  21,KFULL,'More than 100 key ranges specified.'
         $TXT  22,SP06,' '
         $TXT  23,SELWY,'SELECT command has NO purpose to exist.'
         $TXT  24,BIF,'Invalid operator for ''IF''.'
         $TXT  25,IFREL,'Invalid ''IF'' connector or conditional commanX
               d'
         $TXT  26,NULLR,'No SYSIN found and unable to generate internalX
                defaults.'
         $TXT  27,SP05,' '
         $TXT  28,BADDO,'''END'' is allowed only as part of a ''DO'' grx
               oup.'
         $TXT  29,ODCB,'OPEN failure on XXXXXXXX'
         $TXT  30,TERM,'Run cancelled due to compile time diagnostics.'
         $TXT  31,MCONT,'Missing continuation card(s) at EOF on SYSIN.'
         $TXT  32,NOOPS,'Invalid or missing operand.'
         $TXT  33,NOUT,'No XXXXXXXX DD statement is present.'
         $TXT  34,DSUT,'OBTAIN failure on XXXXXXXX Dsname.'
         $TXT  35,MAXI,'Input DD must be INPUT1 thru INPUT9.'
         $TXT  36,BACTV,'SYSIN EOF has caused an incomplete command.'
         $TXT  37,MSG37,' 9,999,999 Records read from DD=xxxxxxxx DSN= X
                                                                       X
                '
         $TXT  38,PEOF,'READ past end of file on (XXXXXXXX) during StatX
               ement No. 9999 Word No. 999'
         $TXT  39,MSG39,'           DSORG=XX  RECFM=XXXXX   LRECL=99999X
                  BLKSIZE=99999 '
         $TXT  40,MSG40,'           **** Input / Output  Statistics  byX
                 DDname ****'
         $TXT  41,IUNK,'Unknown error occurred on INPUT1'
         $TXT  42,IIO,'Permanent I/O error on INPUT1'
         $TXT  43,IBKEY,'KEY                      cannot be found, willX
                try next range.'
         $TXT  44,ABND,'ABEND XXX on record number 99999999 during StatX
               ement No. 9999 Word No. 999'
         $TXT  45,NOSTA,'STAE setup not successful.'
         $TXT  46,SPACE,' '
         $TXT  47,NOOP,'No OUTPUT functions requested, run cancelled.'
         $TXT  48,FLOAT,'Both Source and Destination may not be Floatinx
               g operands'
         $TXT  49,BADMD,'DDname used as both INPUT and OUTPUT.'
         $TXT  50,WTBIG,'Excessively long word ignored, Check for invalX
               id quoted strings.'
         $TXT  51,LOOPR,'User Abend forced due to loop detection in useX
               r commands.'
         $TXT  52,MVOLS,'           On volume(s) - (111111,222222,33333X
               3,444444,555555)'
         $TXT  53,BDDN,'Invalid use of DDname.'
         $TXT  54,SUPER,'SUPPORT(ON) must occur before any executable sX
               tatements'
         $TXT  55,SP01,' '
         $TXT  56,SP02,' '
         $TXT  57,IMASK,'MASK is only allowed with literal operands.'
         $TXT  58,IMASK1,'? may not be the first char. of MASK literal.X
               '
         $TXT  59,BADOP,'Invalid operand format or usage.'
         $TXT  60,BFLOAT,'Invalid floating operand request'
         $TXT  61,BLGTH,'Invalid length operand'
         $TXT  62,BUFFR,'User Abend forced due to ALTER command ''reachX
               ing'' outside buffer limits'
         $TXT  63,BUFFX,'Location + length is larger than maximum BUFFEX
               R size'
         $TXT  64,BDOPT,'OPTIONS statement must be the very first commaX
               nd'
         $TXT  65,UCTRH,'           **** User Counters  (Zero values noX
               t shown) ****'
         $TXT  66,UCTRL,'                                              X
                                                       '
         $TXT  67,EJRC,'           SELECTIT ended with RC =            X
                           '
         $TXT  68,LRECX,'User Abend forced due to detection of Output fX
               ile LRECL greater than maximum.'
         $TXT  69,BELSE,'Incorrectly placed ELSE.'
         $TXT  70,BELSB,'Unsupported command following ELSE.'
         $TXT  71,CCLOS,'Unterminated comment sentence at EOF on SYSIN.X
               '
         $TXT  72,ILLOG,'Illogical combination of operands.'
         $TXT  73,SP07,' '
         $TXT  74,TCMPL,'Maximum AND/OR limit in an IF has been excededX
               .'
         $TXT  75,EXTP,'Extraneous period detected, ignored.'
         $TXT  76,DOP1,'User Abend forced due to DEFER OPEN logic failuX
               re.'
         $TXT  77,DOP2,'DEFER OPEN of xxxxxxxx failed. Run terminated.'
         $TXT  78,CLOSI,'I/O directed to file which has been closed.'
         $TXT  79,SP03,' '
         $TXT  80,SP04,' '
         $TXT  81,SUBEX,'Too many GOSUBs without accompanying GOBACKs hX
               ave been issued.'
         $TXT  82,BAKEX,'Too many GOBACKs without accompanying GOSUBs hX
               ave been issued.'
         $TXT  83,PEMPT,'No members in input dataset for PDS mode proceX
               ssing.'
         $TXT  TYPE=END
         PRINT NOGEN
         EJECT
*---------------------------------------------------------------------+
*        Miscellaneous translate tables                               |
*---------------------------------------------------------------------+
TRTBLDLM DC    64X'00',X'04',10X'00',X'08',49X'00',X'0C',130X'00'
TRTBLNB  DC    64X'FF',X'00',191X'FF'
TRTBLB   DC    64X'00',X'FF',191X'00'
TRTBLQ   DC    125X'00',X'FF',130X'00'
TRTBLN   DC    240X'FF',10X'00',6X'FF'
TRTBLX   DC    129X'FF',X'0A0B0C0D0E0F'
         DC    58X'FF',X'0A0B0C0D0E0F',41X'FF'
         DC    X'00010203040506070809',6X'FF'
TRTBLNN  DC    240X'00',10X'FF',6X'00'
TRTBLLH  DC    16C'0',16C'1',16C'2',16C'3',16C'4',16C'5',16C'6'
         DC    16C'7',16C'8',16C'9',16C'A',16C'B',16C'C',16C'D'
         DC    16C'E',16C'F'
TRTBLRH  DC    16C'0123456789ABCDEF'
TRTBLC   DC    74C' ',C'.<(+|&&',9C' ',C'!$*);-/',8C' ',C',%_>?'
         DC    9C' ',C'`:#@''="'
         DC    C' abcdefghi {     jklmnopqr }      stuvwxyz',22C' '
         DC    C'{ABCDEFGHI      }JKLMNOPQR      \ STUVWXYZ      '
         DC    C'0123456789|     '
TRTBLDIT DC    256AL1(*-TRTBLDIT)
*---------------------------------------------------------------------+
*        Miscellaneous work fields                                    |
*---------------------------------------------------------------------+
FFFF     DC    64X'FF'
ZEROC    DC    64X'00'
DSCB     DS    CL148
         DS    0H
         DC    X'00000000'
LINHD1   DC    CL133'1SELECTIT (xxxx)'
         ORG   LINHD1+125
         DC    C'Page'
         ORG
         DC    C'X',X'00000000'
LINHD2   DC    CL133' (C) Copyright G.D. Deluca 1974, 2019'
         DC    C'X',X'00000000'
LINHD2A  DC    CL133'-Stmnt #  Word #  C o m m a n d s   /   M e s s a X
               g e s   . . .'
         DC    C'X',X'00000000'
LINHD3   DC    CL32' '
         DC    C'----+----1----+----2----+----3----+----4----+----5----X
               +----6----+----7----+----8----+----9----+----0 '
         DC    C'X',X'00000000'
LINHD4   DC    CL133'-Stmnt #  Word #  M e s s a g e . . . . .'
         DC    C'X',X'00000000'
LINHD9   DC    CL133'-',C'X'
LINHD1T  EQU   LINHD1+70
         EJECT
*
KWTBL    DS    0F
         $KW   E0,*
COMMENT        EQU   X'E0'
         $KW   E1,RETURN
         $KW   E1,EOJ
RESERVED       EQU   X'E1'
         $KW   30,=,F1=KWIFREL,D1=X'80000000'
         $KW   31,>,F1=KWIFREL,D1=X'20000000'
         $KW   34,>=,F1=KWIFREL,D1=X'B0000000'
         $KW   32,<,F1=KWIFREL,D1=X'40000000'
         $KW   35,<=,F1=KWIFREL,D1=X'D0000000'
         $KW   33,<>,F1=KWIFREL,D1=X'70000000'
         $KW   31,<=,F1=KWIFREL,D1=X'20000000'
         $KW   32,>=,F1=KWIFREL,D1=X'40000000'
         $KW   33,=,F1=KWIFREL,D1=X'70000000'
         $KW   34,<,F1=KWIFREL,D1=X'B0000000'
         $KW   35,>,F1=KWIFREL,D1=X'D0000000'
         $KW   27,ADD,F1=KWALTER,D1=F'24',D3=A(ALTGPLUS)
         $KW   29,ADDP,F1=KWALTER,D1=F'32',D3=A(ALTGAP)
         $KW   93,ALL,F1=KWSUBVAL
         $KW   53,ALTER,F1=KWMAJ+KWIFTRU,D2=A(IFALTER),D3=A(ALTER)
         $KW   23,AND,F1=KWALTER+KWIFTRU,D1=F'8',D2=A(IFAND),          X
               D3=A(ALTGAND)
         $KW   49,AUTOCOPY,F1=KWOPRAND+KWSUBVAL,D2=A(OPTAUTO)
         $KW   C7,BLKSIZE,F1=KWOPRAND,F2=KWOPRPTR,F3=KWFCBFLD,         X
               D1=A(FCBBLKSI-FCBDSECT),D3=F'2'
         $KW   82,BY,F1=KWOPRAND+KWSUBVAL,D1=A(SELBY)
         $KW   22,C,F1=KWALTER,D1=F'4',D3=A(ALTGCOPY)
         $KW   91,CBLKSIZE,F1=KWOPRAND+KWSUBVAL,D2=A(OPTCBLK)
         $KW   CF,CENTURY,F1=KWOPRAND,F2=KWOPRPTR,F3=KWADRFLD,         X
               D1=A(TIMECENT),D3=F'2'
         $KW   96,CHAR,F1=KWSUBVAL,D1=AL1(CHAR,0,0,0)
         $KW   5D,CLOSE,F1=KWMAJ+KWIFTRU,D2=A(IFCLOSE),D3=A(CLOSE)
         $KW   22,COPY,F1=KWALTER,D1=F'4',D3=A(ALTGCOPY)
         $KW   26,COPYBUFF,F1=KWALTER+KWOPRAND+KWSUBVAL,D2=A(NEXTBUFF)
         $KW   C0,CREC,F1=KWOPRAND,F2=KWOPRPTR,F3=KWFCBFLD,            X
               D1=A(FCBCREC-FCBDSECT),D3=F'4'
         $KW   2F,CVBP,F1=KWALTER,D1=F'56',D3=A(ALTGCVBP)
         $KW   2F,CVBZ,F1=KWALTER,D1=F'60',D3=A(ALTGCVBZ)
         $KW   2F,CVZB,F1=KWALTER,D1=F'44',D3=A(ALTGCVZB)
         $KW   2F,CVZP,F1=KWALTER,D1=F'40',D3=A(ALTGCVZP)
         $KW   2F,CVPB,F1=KWALTER,D1=F'52',D3=A(ALTGCVPB)
         $KW   2F,CVPZ,F1=KWALTER,D1=F'48',D3=A(ALTGCVPZ)
         $KW   2F,CVXC,F1=KWALTER,D1=F'64',D3=A(ALTGCVXC)
         $KW   AB,DATALEN,F1=KWOPRAND,F2=KWOPRPTR+KWDEST,F3=KWFCBFLD,  X
               D1=A(FCBULRFW-FCBDSECT),D3=F'4'
         $KW   A3,DATETIME,F1=KWOPRAND,F2=KWOPRPTR+KWPMADJ,F3=KWADRFLD,X
               D1=A(TIMEWORK),D3=F'8'
         $KW   A7,DAY,F1=KWOPRAND,F2=KWOPRPTR,F3=KWADRFLD,             X
               D1=A(TIMEWORK+8),D3=F'2'
         $KW   CA,DCB,F1=KWOPRAND,F2=KWOPRPTR+KWPMADJ,F3=KWFCBFLD,     X
               D1=A(FCBDCB-FCBDSECT),D3=F'4'
         $KW   54,DEBUG,F1=KWMAJ+KWIFTRU,D2=A(IFDEBUG),D3=A(DEBUG)
         $KW   4C,DEFER,F1=KWOPRAND+KWSUBVAL,D2=A(OPTDEFER)
         $KW   27,DIV,F1=KWALTER,D1=F'24',D3=A(ALTGDIV)
         $KW   51,DO,F1=KWIFTRU,D2=A(IFDO),D3=A(ELSEDO)
         $KW   C2,DSNAME,F1=KWOPRAND,F2=KWOPRPTR+KWPMADJ,F3=KWFCBFLD,  X
               D1=A(FCBJFCB-FCBDSECT),D3=F'44'
         $KW   C5,DSNAMEX,F1=KWOPRAND,F2=KWOPRPTR+KWPMADJ,F3=KWFCBFLD, X
               D1=A(FCBDSNAM-FCBDSECT),D3=F'54'
         $KW   C4,DSORG,F1=KWOPRAND,F2=KWOPRPTR,F3=KWFCBFLD,           X
               D1=A(FCBDSORG-FCBDSECT),D3=F'1'
         $KW   94,DUMP,F1=KWSUBVAL,D1=AL1(DUMP,0,0,0)
         $KW   2B,EDITP,F1=KWALTER,D1=F'68',D3=A(ALTGEDTP)
         $KW   2C,EDITB,F1=KWALTER,D1=F'72',D3=A(ALTGEDTB)
         $KW   2D,EDITP$,F1=KWALTER,D1=F'76',D3=A(ALTGEDP$)
         $KW   2E,EDITB$,F1=KWALTER,D1=F'80',D3=A(ALTGEDB$)
         $KW   5C,ELSE,F1=KWMAJ,D3=A(ELSE)
         $KW   59,END,F1=KWMAJ,D3=A(END)
         $KW   71,EOF,F1=KWOPRAND+KWSUBVAL,D2=A(NEXTEOF)
         $KW   44,EOFFILL,F1=KWOPRAND+KWSUBVAL,D2=A(OPTEOFF)
         $KW   46,EOFLABEL,F1=KWOPRAND+KWSUBVAL,D2=A(OPTEOFL)
         $KW   30,EQ,F1=KWIFREL,D1=X'80000000'
         $KW   70,FILE,F1=KWOPRAND+KWSUBVAL,D2=A(NEXTFILE)
         $KW   D6,FLCHG,F1=KWOPRAND,F2=KWOPRPTR,F3=KWPCTFLD,           X
               D1=A(PCTFLCHG-PCT),D3=F'4'
         $KW   D7,FLEN,F1=KWOPRAND,F2=KWOPRPTR+KWOFFSET,               X
               F3=KWPCTFLD,D1=A(PCTFLEN-PCT),D3=F'4'
         $KW   D2,FLOC,F1=KWOPRAND,F2=KWOPRPTR+KWOFFSET,               X
               F3=KWPCTFLD,D1=A(PCTPLOC-PCT),D3=F'4'
         $KW   D3,FLOCEND,F1=KWOPRAND,F2=KWOPRPTR+KWOFFSET,            X
               F3=KWPCTFLD,D1=A(PCTFLOCE-PCT),D3=F'4'
         $KW   D5,FLOCTERM,F2=KWPMVALU+KWOFFSET,                       X
               F3=KWPCTFLD,D1=A(PCTFLOCT-PCT),D3=F'4'
         $KW   34,GE,F1=KWIFREL,D1=X'B0000000'
         $KW   56,GETNEXT,F1=KWMAJ+KWIFTRU,D2=A(IFGNEXT),D3=A(NEXTREC)
         $KW   52,GO,F1=KWMAJ+KWIFTRU+KWOPRAND+KWSUBVAL,D1=A(SELGOTO), X
               D2=A(IFGOTO),D3=A(GOTO)
         $KW   52,GOTO,F1=KWMAJ+KWIFTRU+KWOPRAND+KWSUBVAL,             X
               D1=A(SELGOTO),D2=A(IFGOTO),D3=A(GOTO)
         $KW   9C,GOBACK,F1=KWMAJ+KWIFTRU,D2=A(IFGOBACK),D3=A(GOBACK)
         $KW   9C,GOSUB,F1=KWMAJ+KWIFTRU,D2=A(IFGOSUB),D3=A(GOSUB)
         $KW   31,GT,F1=KWIFREL,D1=X'20000000'
         $KW   95,HEX,F1=KWSUBVAL,D1=AL1(HEX,0,0,0)
         $KW   57,IF,F1=KWMAJ,D3=A(IF)
         $KW   AD,IMEMBER,F1=KWOPRAND,F2=KWOPRPTR,F3=KWADRFLD,         X
               D1=A(PCTIMEMB),D3=F'8'
         $KW   92,INIT,F1=KWSUBVAL,D2=F'12'
         $KW   9A,INPUT,F1=KWOPRAND+KWSUBVAL,D2=A(CLOSINPT)
         $KW   63,IODUMP,F1=KWOPRAND+KWSUBVAL,D2=A(DEBIODM)
         $KW   62,IOTRACE,F1=KWOPRAND+KWSUBVAL,D2=A(DEBIOTR)
         $KW   C3,JFCB,F1=KWOPRAND,F2=KWOPRPTR+KWPMADJ,F3=KWFCBFLD,    X
               D1=A(FCBJFCB-FCBDSECT),D3=F'176'
         $KW   A0,JOBNAME,F1=KWOPRAND,F2=KWOPRPTR,F3=KWADRFLD,         X
               D1=A(LINHD1+38),D3=F'8'
         $KW   A4,JULIAN,F1=KWOPRAND,F2=KWOPRPTR,F3=KWADRFLD,          X
               D1=A(TIMEWORK+17),D3=F'5'
         $KW   87,LENGTH,F1=KWOPRAND+KWSUBVAL,D1=A(SELDLEN)
         $KW   AA,LINECTR,F1=KWOPRAND,F2=KWOPRPTR+KWDEST,F3=KWADRFLD,  X
               D1=A(LINECT),D3=F'2'
         $KW   C1,LRECL,F1=KWOPRAND,F2=KWOPRPTR+KWDEST,F3=KWFCBFLD,    X
               D1=A(FCBOLREC-FCBDSECT),D3=F'2'
         $KW   35,LE,F1=KWIFREL,D1=X'D0000000'
         $KW   32,LT,F1=KWIFREL,D1=X'40000000'
         $KW   3E,MASK,F1=KWIFREL,D1=X'80020000'
         $KW   4D,MEMBSTAT,F1=KWOPRAND+KWSUBVAL,D2=A(OPTPDSST)
         $KW   3F,MIX,F1=KWIFREL,D1=X'40010000'
         $KW   A6,MONTH,F1=KWOPRAND,F2=KWOPRPTR,F3=KWADRFLD,           X
               D1=A(TIMEWORK+10),D3=F'3'
         $KW   CD,MONTHNUM,F1=KWOPRAND,F2=KWOPRPTR,F3=KWADRFLD,        X
               D1=A(TIMECENT+4),D3=F'2'
         $KW   27,MULT,F1=KWALTER,D1=F'24',D3=A(ALTGMULT)
         $KW   23,N,F1=KWALTER,D1=F'8',D3=A(ALTGAND)
         $KW   33,NE,F1=KWIFREL,D1=X'70000000'
         $KW   32,NGE,F1=KWIFREL,D1=X'40000000'
         $KW   35,NGT,F1=KWIFREL,D1=X'D0000000'
         $KW   31,NLE,F1=KWIFREL,D1=X'20000000'
         $KW   34,NLT,F1=KWIFREL,D1=X'B0000000'
         $KW   3F,NO,F1=KWIFREL+KWOPRVAL,D1=X'80010000',D2=F'8'
         $KW   C8,NVOLS,F1=KWOPRAND,F2=KWOPRPTR,F3=KWFCBFLD,           X
               D1=A(FCBNVOLS-FCBDSECT),D3=F'1'
         $KW   25,O,F1=KWALTER,D1=F'12',D3=A(ALTGOR)
         $KW   48,OBFORCE,F1=KWOPRAND+KWSUBVAL,D2=A(OPTOBFOR)
         $KW   E3,OBUFF,F1=KWOPRAND,D2=A(PCTOUTPT-(FCBRECAD-FCBDSECT)),X
               D3=F'10'
         $KW   3F,OFF,F1=KWIFREL+KWOPRVAL,D1=X'80010000',D2=F'8'
         $KW   AE,OMEMBER,F1=KWOPRAND,F2=KWOPRPTR+KWDEST,F3=KWADRFLD,  X
               D1=A(PCTOMEMB),D3=F'8'
         $KW   3F,ON,F1=KWIFREL+KWOPRVAL,D1=X'10010000',D2=F'4'
         $KW   42,OPCHECK,F1=KWOPRAND+KWSUBVAL,D2=A(OPTOPCHK)
         $KW   5B,OPTIONS,F1=KWMAJ,D3=A(OPTIONS)
         $KW   25,OR,F1=KWALTER+KWIFTRU,D1=F'12',D2=A(IFOR),           X
               D3=A(ALTGOR)
         $KW   9B,OUTPUT,F1=KWOPRAND+KWSUBVAL,D2=A(CLOSOUTP)
         $KW   45,PADCHAR,F1=KWOPRAND+KWSUBVAL,D2=A(OPTPADCH)
         $KW   4F,PARM,F1=KWOPRAND,D2=A(OPTPARM)
         $KW   4E,PDSMODE,F1=KWOPRAND,D2=A(OPTPDSMD)
         $KW   D1,PLOC,F2=KWPMVALU,F3=KWPCTFLD,                        X
               D1=A(PCTPLOC-PCT),D3=F'4'
         $KW   D4,PLOCEND,F2=KWPMVALU,F3=KWPCTFLD,                     X
               D1=A(PCTPLOCE-PCT),D3=F'4'
         $KW   86,PRINT,F1=KWOPRAND+KWSUBVAL,D1=A(SELPRINT)
         $KW   A2,PROCNAME,F1=KWOPRAND,F2=KWOPRPTR,F3=KWADRFLD,        X
               D1=A(LINHD1+56),D3=F'8'
         $KW   21,R,F1=KWALTER,D1=F'4',D3=A(ALTGCOPY)
         $KW   AC,RCODE,F1=KWOPRAND,F2=KWOPRPTR+KWDEST,F3=KWPCTFLD,    X
               D1=A(PCTRC-PCT),D3=F'4'
         $KW   C6,RECFM,F1=KWOPRAND,F2=KWOPRPTR,F3=KWFCBFLD,           X
               D1=A(FCBRECFM-FCBDSECT),D3=F'2'
         $KW   80,RECS,F1=KWOPRAND+KWSUBVAL,D1=A(SELRECS)
         $KW   5A,RUN,F1=KWMAJ,D3=A(MAINRUN-8)
         $KW   55,SELECT,F1=KWMAJ+KWIFTRU,D2=A(IFSELECT),D3=A(SELECT)
         $KW   81,SREC,F1=KWOPRAND+KWSUBVAL,D1=A(SELSREC)
         $KW   A1,STEPNAME,F1=KWOPRAND,F2=KWOPRPTR,F3=KWADRFLD,        X
               D1=A(LINHD1+47),D3=F'8'
         $KW   28,SUB,F1=KWALTER,D1=F'28',D3=A(ALTGSUBT)
         $KW   2A,SUBP,F1=KWALTER,D1=F'36',D3=A(ALTGSP)
         $KW   60,SUPPORT,F1=KWOPRAND+KWSUBVAL,D2=A(DEBSUPP)
         $KW   20,T,F1=KWALTER,D1=F'20',D3=A(ALTGTRAN)
         $KW   50,THEN,F1=KWNOISE+KWIFTRU,D2=A(IFGDONE)
         $KW   A8,TIME,F1=KWOPRAND,F2=KWOPRPTR,F3=KWADRFLD,            X
               D1=A(TIMEWORK+24),D3=F'5'
         $KW   85,TODD,F1=KWOPRAND+KWSUBVAL,D1=A(SELTODD)
         $KW   61,TRACE,F1=KWOPRAND+KWSUBVAL,D2=A(DEBTRAC)
         $KW   20,TRANSLATE,F1=KWALTER,D1=F'20',D3=A(ALTGTRAN)
         $KW   43,UBSIZE,F1=KWOPRAND+KWSUBVAL,D2=A(OPTUBUF)
         $KW   E4,UBUFFA,F1=KWOPRAND,D2=A(PCTUBFA-(FCBRECAD-FCBDSECT)),X
               D3=F'11'
         $KW   E4,UBUFFB,F1=KWOPRAND,D2=A(PCTUBFB-(FCBRECAD-FCBDSECT)),X
               D3=F'12'
         $KW   E4,UBUFFC,F1=KWOPRAND,D2=A(PCTUBFC-(FCBRECAD-FCBDSECT)),X
               D3=F'13'
         $KW   E4,UBUFFD,F1=KWOPRAND,D2=A(PCTUBFD-(FCBRECAD-FCBDSECT)),X
               D3=F'14'
         $KW   E4,UBUFFE,F1=KWOPRAND,D2=A(PCTUBFE-(FCBRECAD-FCBDSECT)),X
               D3=F'15'
         $KW   E4,UBUFFF,F1=KWOPRAND,D2=A(PCTUBFF-(FCBRECAD-FCBDSECT)),X
               D3=F'16'
         $KW   E4,UBUFFG,F1=KWOPRAND,D2=A(PCTUBFG-(FCBRECAD-FCBDSECT)),X
               D3=F'17'
         $KW   E4,UBUFFH,F1=KWOPRAND,D2=A(PCTUBFH-(FCBRECAD-FCBDSECT)),X
               D3=F'18'
         $KW   E4,UBUFFI,F1=KWOPRAND,D2=A(PCTUBFI-(FCBRECAD-FCBDSECT)),X
               D3=F'19'
         $KW   E4,UBUFFJ,F1=KWOPRAND,D2=A(PCTUBFJ-(FCBRECAD-FCBDSECT)),X
               D3=F'20'
         $KW   E4,UBUFFK,F1=KWOPRAND,D2=A(PCTUBFK-(FCBRECAD-FCBDSECT)),X
               D3=F'21'
         $KW   E4,UBUFFL,F1=KWOPRAND,D2=A(PCTUBFL-(FCBRECAD-FCBDSECT)),X
               D3=F'22'
         $KW   E4,UBUFFM,F1=KWOPRAND,D2=A(PCTUBFM-(FCBRECAD-FCBDSECT)),X
               D3=F'23'
         $KW   E4,UBUFFN,F1=KWOPRAND,D2=A(PCTUBFN-(FCBRECAD-FCBDSECT)),X
               D3=F'24'
         $KW   E4,UBUFFO,F1=KWOPRAND,D2=A(PCTUBFO-(FCBRECAD-FCBDSECT)),X
               D3=F'25'
         $KW   E4,UBUFFP,F1=KWOPRAND,D2=A(PCTUBFP-(FCBRECAD-FCBDSECT)),X
               D3=F'26'
         $KW   E4,UBUFFQ,F1=KWOPRAND,D2=A(PCTUBFQ-(FCBRECAD-FCBDSECT)),X
               D3=F'27'
         $KW   E4,UBUFFR,F1=KWOPRAND,D2=A(PCTUBFR-(FCBRECAD-FCBDSECT)),X
               D3=F'28'
         $KW   E4,UBUFFS,F1=KWOPRAND,D2=A(PCTUBFS-(FCBRECAD-FCBDSECT)),X
               D3=F'29'
         $KW   E4,UBUFFT,F1=KWOPRAND,D2=A(PCTUBFT-(FCBRECAD-FCBDSECT)),X
               D3=F'30'
         $KW   E4,UBUFFU,F1=KWOPRAND,D2=A(PCTUBFU-(FCBRECAD-FCBDSECT)),X
               D3=F'31'
         $KW   E4,UBUFFV,F1=KWOPRAND,D2=A(PCTUBFV-(FCBRECAD-FCBDSECT)),X
               D3=F'32'
         $KW   E4,UBUFFW,F1=KWOPRAND,D2=A(PCTUBFW-(FCBRECAD-FCBDSECT)),X
               D3=F'33'
         $KW   E4,UBUFFX,F1=KWOPRAND,D2=A(PCTUBFX-(FCBRECAD-FCBDSECT)),X
               D3=F'34'
         $KW   E4,UBUFFY,F1=KWOPRAND,D2=A(PCTUBFY-(FCBRECAD-FCBDSECT)),X
               D3=F'35'
         $KW   E4,UBUFFZ,F1=KWOPRAND,D2=A(PCTUBFZ-(FCBRECAD-FCBDSECT)),X
               D3=F'36'
         $KW   E2,UCTRA,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X
               F3=KWPCTFLD,D1=A(PCTUCTRA-PCT),D3=F'4'
         $KW   E2,UCTRB,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X
               F3=KWPCTFLD,D1=A(PCTUCTRB-PCT),D3=F'4'
         $KW   E2,UCTRC,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X
               F3=KWPCTFLD,D1=A(PCTUCTRC-PCT),D3=F'4'
         $KW   E2,UCTRD,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X
               F3=KWPCTFLD,D1=A(PCTUCTRD-PCT),D3=F'4'
         $KW   E2,UCTRE,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X
               F3=KWPCTFLD,D1=A(PCTUCTRE-PCT),D3=F'4'
         $KW   E2,UCTRF,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X
               F3=KWPCTFLD,D1=A(PCTUCTRF-PCT),D3=F'4'
         $KW   E2,UCTRG,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X
               F3=KWPCTFLD,D1=A(PCTUCTRG-PCT),D3=F'4'
         $KW   E2,UCTRH,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X
               F3=KWPCTFLD,D1=A(PCTUCTRH-PCT),D3=F'4'
         $KW   E2,UCTRI,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X
               F3=KWPCTFLD,D1=A(PCTUCTRI-PCT),D3=F'4'
         $KW   E2,UCTRJ,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X
               F3=KWPCTFLD,D1=A(PCTUCTRJ-PCT),D3=F'4'
         $KW   E2,UCTRK,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X
               F3=KWPCTFLD,D1=A(PCTUCTRK-PCT),D3=F'4'
         $KW   E2,UCTRL,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X
               F3=KWPCTFLD,D1=A(PCTUCTRL-PCT),D3=F'4'
         $KW   E2,UCTRM,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X
               F3=KWPCTFLD,D1=A(PCTUCTRM-PCT),D3=F'4'
         $KW   E2,UCTRN,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X
               F3=KWPCTFLD,D1=A(PCTUCTRN-PCT),D3=F'4'
         $KW   E2,UCTRO,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X
               F3=KWPCTFLD,D1=A(PCTUCTRO-PCT),D3=F'4'
         $KW   E2,UCTRP,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X
               F3=KWPCTFLD,D1=A(PCTUCTRP-PCT),D3=F'4'
         $KW   E2,UCTRQ,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X
               F3=KWPCTFLD,D1=A(PCTUCTRQ-PCT),D3=F'4'
         $KW   E2,UCTRR,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X
               F3=KWPCTFLD,D1=A(PCTUCTRR-PCT),D3=F'4'
         $KW   E2,UCTRS,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X
               F3=KWPCTFLD,D1=A(PCTUCTRS-PCT),D3=F'4'
         $KW   E2,UCTRT,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X
               F3=KWPCTFLD,D1=A(PCTUCTRT-PCT),D3=F'4'
         $KW   E2,UCTRU,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X
               F3=KWPCTFLD,D1=A(PCTUCTRU-PCT),D3=F'4'
         $KW   E2,UCTRV,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X
               F3=KWPCTFLD,D1=A(PCTUCTRV-PCT),D3=F'4'
         $KW   E2,UCTRW,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X
               F3=KWPCTFLD,D1=A(PCTUCTRW-PCT),D3=F'4'
         $KW   E2,UCTRX,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X
               F3=KWPCTFLD,D1=A(PCTUCTRX-PCT),D3=F'4'
         $KW   E2,UCTRY,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X
               F3=KWPCTFLD,D1=A(PCTUCTRY-PCT),D3=F'4'
         $KW   E2,UCTRZ,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X
               F3=KWPCTFLD,D1=A(PCTUCTRZ-PCT),D3=F'4'
         $KW   AF,USERPARM,F1=KWOPRAND,F2=KWOPRPTR,F3=KWADRFLD,        X
               D1=A(PCTUPARM),D3=F'8'
         $KW   C9,VOLSER,F1=KWOPRAND,F2=KWOPRPTR+KWPMADJ,F3=KWFCBFLD,  X
               D1=A(FCBVOLS-FCBDSECT),D3=F'6'
         $KW   24,X,F1=KWALTER,D1=F'16',D3=A(ALTGXOR)
         $KW   24,XOR,F1=KWALTER,D1=F'16',D3=A(ALTGXOR)
         $KW   A5,YEAR,F1=KWOPRAND,F2=KWOPRPTR,F3=KWADRFLD,            X
               D1=A(TIMEWORK+13),D3=F'2'
         $KW   CE,FULLYEAR,F1=KWOPRAND,F2=KWOPRPTR,F3=KWADRFLD,        X
               D1=A(TIMECENT),D3=F'4'
         $KW   3F,YES,F1=KWIFREL+KWOPRVAL,D1=X'10010000',D2=F'4'
KWTBLL   EQU   *-KWTBL
KWHASH   DC    70A(0)
         EJECT
*
         PRINT NOGEN
MDLSIDCB DCB   DDNAME=INPUT1,DSORG=PS,EODAD=EODAD,EXLST=UT1LIST,       X
               MACRF=GL
MDLSODCB DCB   DDNAME=OUTPUT1,DSORG=PS,EXLST=UT2LIST,MACRF=PL
*
GETDF1   DC    CL80'*: The following default has been generated.'
GETDF2   DC    CL80'   SELECT RECS(ALL) TODD(OUTPUT1).'
GETDF3   DC    CL80'   SELECT RECS(ALL) PRINT(DUMP).'
*
ERRWTL   WTO   'SELECTIT -                                             X
                                                                       X
                  ',ROUTCDE=(11),MCSFLAG=HRDCPY,MF=L
SELCODE  EQU   *
         PRINT GEN
         TITLE 'FCBDSECT'
*---------------------------------------------------------------------+
*        FCBDSECT - Map the FCB (File Control Block) area             |
*---------------------------------------------------------------------+
*
FCBDSECT DSECT
FCBCHAIN DS    A                   Chain to next FCB
FCBDDNAM DS    CL8                 External DDname
FCBCOUNT DS    F                   Count of records (per file)
FCBCREC  DS    F                   Count of records (CREC)
FCBROUTE DS    XL4                 EXecuted branch instr for routing
FCBDSORG DS    X                   DSORG
FCBRECFM DS    X                   RECFM
FCBF1    DS    X                   Status flag 1
FCBDOPEN       EQU         X'80'   Deferred OPEN requested
FCBOPEN        EQU         X'40'   OPEN complete successfully
FCBCLOSD       EQU         X'20'   CLOSE done already
FCBSTATS       EQU         X'10'   O.K. to produce stats
FCBF2    DS    X                   Status flag 2
FCBINPUT       EQU         X'80'   FCB is for an input file
FCBOUTPT       EQU         X'40'   FCB is for an output file
FCBEOF         EQU         X'20'   EOF has occurred
FCBRREAD       EQU         X'10'   Unlike re-read switch
FCB1ST         EQU         X'08'   First time switch
FCBPDS         EQU         X'04'   PDSMODE active
FCBRECAD DS    A                   Address of I/P record address
FCBRECPT DS    A                   Address of record address in PCT
FCBLENPT DS    A                   Address of record length in PCT
FCBULRFW DS    H                   Filler to allow ULREC to be fullwd
FCBULREC DS    H                   User's LRECL
FCBLRECL DS    H                   LRECL
FCBBLKSI DS    H                   BLKSIZE
FCBOLREC DS    H                   Open time LRECL
FCBOBLK  DS    H                     "   "   BLKSIZE
FCBFILNO DS    H                   Index of file number
FCBORECF DS    X                   Open time RECFM
FCBDSNAM DS    CL54                DSNAME
FCBNVOLS DS    X                   Number of volumes
FCBVOLS  DS    5CL6                Volume serial numbers
FCBJFCB  DS    CL176               JFCB
         DS    0F
FCBDCB   DS    CL256               Actual DCB area
FCBLNGTH EQU   *-FCBDSECT          Length of area
         TITLE 'SELDSECT'
*---------------------------------------------------------------------+
*        SELDSECT - Map the SELECT control area.                      |
*---------------------------------------------------------------------+
*
SELDSECT DSECT
$SELID   DC    X'CC'               Control block ID
$SELF1   DC    X'00'               SELECT flag 1
$SELF2   DC    X'00'               SELECT flag 2
$SELF3   DC    X'00'               SELECT flag 3
$SELSREC DC    F'0'                START record number
$SELBREC DC    F'0'                BY record number
$SELBCTR DC    F'0'                BY record counter
$SELNREC DC    F'0'                Number of records
$SELOFCB DC    A(0)                Address of output FCB area
$SELNXTS DC    A(0)                Address of next sentence
$SELLGTH DC    F'0'                Data length for this select
         TITLE 'OPRDSECT'
*---------------------------------------------------------------------+
*        OPRDSECT - Map the operand answer area.                      |
*---------------------------------------------------------------------+
*
OPRDSECT DSECT                     Map of operand scan area
*
OPRNUM1  DC    F'0'                Numeric value of main operand
OPRNUM2  DC    F'0'                Numeric value of sub-operand
*
OPRF1    DC    X'00'               Flag to be OR'ed with WFLAG1
OPRF2    DC    X'00'               Status of this operand
OPRNUM         EQU   X'80'         Operand is Numeric
OPRSPECN       EQU   X'40'            "    "  Commented numeric
OPRLIT         EQU   X'20'            "    "  a Literal
OPRKW          EQU   X'10'            "    "  a KW type
OPRKWV         EQU   X'08'            "    KW is valid
OPRKWOP        EQU   X'04'            "    is a KW(operand) type
OPRKWOPV       EQU   X'02'            "    KW(operand) is valid
OPRPTR         EQU   X'01'         Use OPRADDR to -> text
*
OPRL     DC    H'0'                Length of operand
OPRTXT   DS    0CL10' '            Actual operand if <= 10 bytes
OPRADDR  DC    A(0)                -> operand if > 10 bytes
         DC    XL6'00'             Pad to length of OPRTXT
OPRL2    DC    H'0'                Length of (...) sub-operand
OPRTXT2  DS    CL10' '             Actual (..) operand
*---------------------------------------------------------------------+
*        OPRKW1/OPRKW2 below are mapped by KWDSECT.                   |
*---------------------------------------------------------------------+
*
OPRKW1   DS    CL(KWENTL)          If oper. is KW, entry from KW table
OPRKW2   DS    CL(KWENTL)          If val. sub-oper, it's KW table ent.
         TITLE 'KWDSECT'
*---------------------------------------------------------------------+
*        KWDSECT - Map an entry in the KW table.                      |
*---------------------------------------------------------------------+
*
KWDSECT  DSECT                     Map of Keyword Table
*
KWCHAIN  DS    A                   Hash chain
*
KWL      DS    H                   Length of keyword
KWKW     DS    CL10                Keyword
*
KWF1     DS    X                   Status of the keyword
*
KWMAJ          EQU   X'80'         KW is major command
KWALTER        EQU   X'40'         KW is ALTER subcommand
KWIFREL        EQU   X'20'         KW is IF relational test
KWIFTRU        EQU   X'10'         KW is IF True path
KWOPRAND       EQU   X'08'         KW is Operand specifier
KWOPRVAL       EQU   X'04'         KW is Operand value
KWNOISE        EQU   X'02'         KW is a 'noise' word
KWSUBVAL       EQU   X'01'         KW may have sub-operands
*
KWF2     DS    X                   KW flag 2
KWNUMFUG       EQU   X'80'         Fudge when (...) is numeric (..NUM2)
KWPMVALU       EQU   X'40'         Valid as a +/- adjustment
KWPREVAL       EQU   X'20'         Value is prefixable
KWOPRPTR       EQU   X'10'         Valid as an operand location
KWPMADJ        EQU   X'08'         KW location may be +/- adjusted
KWDEST         EQU   X'04'         KW data may be modified (else R/O)
KWOFFSET       EQU   X'02'         Field may be used as a buffer offset
*
KWGTYPE  DS    X                   KW type of code to Gen.
KWFCBFLD       EQU   4             Actual data is in the FCB at offset
*                                  of KWD1, length is in KWD3.
KWFCBPTR       EQU   8             Actual data pointed to by FCB field
*                                  at offset KWD1, length is in KWD3.
KWADRFLD       EQU   12            Actual data is pointed to by the
*                                  addr in KWD1, length is in KWD3.
KWADRPTR       EQU   16            KWD1 points at the pointer to the
*                                  actual data, length is in KWD3.
KWPCTFLD       EQU   20            Data is in the PCT at the offset
*                                  in KWD1, length is in KWD3.
KWPCTPTR       EQU   24            Data is pointed to by the PCT field
*                                  at the offset in KWD1, length KWD3
*
KWNUM    DS    X                   Keyword number
*
KWD1     DS    XL4                 Data 1
KWD2     DS    A                   Data 2
KWD3     DS    A                   Data 3
KWENTL   EQU   *-KWDSECT
*---------------------------------------------------------------------+
*        For SWA block access                                         |
*---------------------------------------------------------------------+
         IEFZB505 LOCEPAX=YES
SWAL     EQU   *-ZB505
         CVT   DSECT=YES
         IEFJESCT
         IEFQMIDS
         END   SELECTIT
/*
//LINK    EXEC PGM=IEWL,PARM='MAP,LET,LIST,NCAL'
//SYSLIN   DD  DSN=&OBJ,DISP=(OLD,DELETE)
//SYSUT1   DD  UNIT=SYSDA,SPACE=(CYL,(3,2)),DSN=&SYSUT1
//SYSPRINT DD  SYSOUT=*
//SYSLMOD  DD  DSN=TCS1028.LOAD(SELECTIT),DISP=SHR
//
