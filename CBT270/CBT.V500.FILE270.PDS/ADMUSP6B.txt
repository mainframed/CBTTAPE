        /* DATA SET 761GSUSP6  AT LEVEL 002 AS OF 09/28/87    */
 ADMUSP6:PROCEDURE(PARMLIST) OPTIONS(MAIN);
         DECLARE PARMLIST CHAR(100) VARYING;
 /********************************************************************/
 /*                      ADMUSP6                                     */
 /*                                                                  */
 /*       APPLICATION TO PLOT THE DATA IN A NAMED FILE USING         */
 /*                THE 'CHART' UTILITY.                              */
 /*                                                                  */
 /*                                                                  */
 /*  INPUT PARAMETERS:                                               */
 /*                                                                  */
 /*           MEM            PDS MEMBER NAME CONTAINING DATA         */
 /*           PRT            PRINTER NAME FOR PRINTING GRAPH         */
 /*           FMT            NAME OF CHART FORMAT                    */
 /*           DEP            PRINTER DEPTH (ROWS) TO PRINT           */
 /*           WID            PRINTER WIDTH (COLS) TO PRINT           */
 /*           COP            NUMBER OF COPIES TO PRINT               */
 /*           HED            PRINTER HEADER PAGE CONTROL             */
 /*           VOF            PRINTER VERTICAL OFFSET                 */
 /*           HOF            PRINTER HORIZONTAL OFFSET               */
 /*           UNT            PRINTER LAYOUT PARAMETER UNITS          */
 /*                                                                  */
 /*   THE PROGRAM REQUIRES THAT PARAMETERS "MEM" AND "PRT            */
 /*   BE SPECIFIED.  THE REMAINDER ARE OPTIONAL.                     */
 /*                                                                  */
 /*  PARAMETER FORMAT:                                               */
 /*     '/MEM=''XXXXXX'',FMT=''XXX'',PRT=''XXXXXXXX'',COP=2;'        */
 /*     (CHARACTER STRING OPTIONS MUST BE DOUBLE QUOTED!!!)          */
 /*                                                                  */
 /*                 .......*****........                             */
 /*                                                                  */
 /*   DATA FILE FORMAT:                                              */
 /*       THE FILE MUST CONSIST OF A NUMBER OF (80 BYTE)             */
 /*       RECORDS WHICH GIVE A TABLE OF DATA TO BE PLOTTED.          */
 /*       THE RECORDS ARE FORMATTED AS FOLLOWS:                      */
 /*                                                                  */
 /*        RECORD 1.                                                 */
 /*           CONTAINS THE CHART HEADING.                            */
 /*           LEADING AND TRAILING BLANKS ARE REMOVED FROM THE       */
 /*           TEXT SUPPLIED IN THE RECORD AND THE RESULTING          */
 /*           STRING IS USED TO TITLE THE GENERATED CHART.           */
 /*                                                                  */
 /*        RECORD 2.                                                 */
 /*           CONTAINS THE COLUMN HEADINGS OF THE TABLE,             */
 /*           WHICH WILL FORM THE CHART KEYS.  THESE KEYS            */
 /*           MUST BE SINGLE WORDS (WITHOUT IMBEDDED BLANKS)         */
 /*           OF NOT MORE THAN 32 CHARACTERS.                        */
 /*           OCCURRENCES OF UNDERSCORE CHARACTERS (_)               */
 /*           IN A WORD ARE REPLACED BY BLANKS SO THAT               */
 /*           BLANK CHARACTERS MAY BE GENERATED IN THE KEY           */
 /*           TEXT IF REQUIRED.                                      */
 /*                                                                  */
 /*           ONE WORD SHOULD BE PROVIDED FOR EACH DATA COLUMN       */
 /*           TO BE PLOTTED (EXCEPT THE FIRST WHICH IS USED AS       */
 /*           THE X DATA).                                           */
 /*                                                                  */
 /*        RECORDS 3 - N                                             */
 /*           CONTAIN THE TABLE OF DATA.    EACH RECORD              */
 /*           CONTAINS ONE TABLE ROW.  THE FIRST WORD IS THE         */
 /*           'X VALUE' FOR THE ROW, FURTHER WORDS ARE THE Y         */
 /*           VALUES.  THERE SHOULD BE ONE Y VALUE FOR EACH          */
 /*           KEY SPECIFIED ON THE KEY RECORD (RECORD 2).            */
 /*           X VALUES MAY BE NUMERIC OR ALPHANUMERIC.  Y VALUES     */
 /*           MUST BE NUMERIC, THAT IS THEY SHOULD BE CONVERTIBLE    */
 /*           TO FLOATING POINT NUMBERS BY THE NORMAL PL/I           */
 /*           CHARACTER TO ARITHMETIC CONVERSION.                    */
 /*                                                                  */
 /*      SAMPLE DATA MIGHT BE:                                       */
 /*                                                                  */
 /*               HISTORY OF RESULTS FOR XYZ LTD.                    */
 /*                   COSTS       SALES                              */
 /*        1975        320         120                               */
 /*        1976        330         340                               */
 /*        1977        430         520                               */
 /*        1978        550         630                               */
 /*        1979        620         640                               */
 /*                                                                  */
 /*                                                                  */
 /********************************************************************/
 DECLARE


   1 ADMTPCS,                     /* PANEL CONTROL STRUCTURE.        */
    2 PCSLEVEL           /* NUMBER IDENTIFYING THE CHART LEVEL USED. */
        FIXED BIN(31)    /* 1 = CHART UTILITY RELEASE 3 ONWARDS      */
         INIT(1),
    2 PCSDISP            /* 0 = THE DATA CONTAINED IN "DATA_CONTROL" */
        FIXED BIN(31)    /*     "X", "Y", "KEYS", "LABELS" AND       */
         INIT(4),        /*     "HEADING" IS SAVED ONTO THE FILE     */
                         /*     INDICATED BY PCSDNAME. NO PANELS ARE */
                         /*     PRESENTED BEFORE RETURNING TO THE    */
                         /*     APPLICATION PROGRAM.                 */
                         /* 1 = THE "HOME" PANEL IS PRESENTED TO THE */
                         /*     OPERATOR.                            */
                         /* 2 = THE DISPLAY PANEL IS PRESENTED TO    */
                         /*     THE OPERATOR USING THE SUPPLIED DATA */
                         /*     AND CHART FORMAT. THE OPERATOR THEN  */
                         /*     HAS THE CHOICE OF THE "HOME" PANEL,  */
                         /*     OR RETURNING TO THE APPLICATION      */
                         /*     PROGRAM.                             */
                         /* 3 = THE DISPLAY PANEL IS PRESENTED TO    */
                         /*     THE OPERATOR USING THE SUPPLIED DATA */
                         /*     AND CHART FORMAT. THE "HOME" PANEL   */
                         /*     IS NOT AVAILABLE, BUT THE "PRINT",   */
                         /*     "HELP" AND "SAVE" FUNCTIONS MAY BE   */
                         /*     AVAILABLE.                           */
                         /* 4 = THE DATA CONTAINED IN "DATA_CONTROL" */
                         /*     "X", "Y", "KEYS", "LABELS" AND       */
                         /*     "HEADING" IS PRINTED (1 COPY).       */
                         /*     RETURN IS MADE DIRECTLY TO THE       */
                         /*     APPLICATION PROGRAM.                 */
    2 PCSHELP            /* 0 = PF KEY ASSIGNMENTS ARE NOT DISPLAYED */
        FIXED BIN(31)    /*     INITIALLY ON THE DISPLAY PANEL. THIS */
           INIT(0),      /*     SETTING MAY BE CHANGED BY USE OF     */
                         /*     ENTER WHENEVER THE DISPLAY PANEL IS  */
                         /*     PRESENTED.                           */
                         /* 1 = PF KEY ASSIGNMENTS ARE DISPLAYED     */
                         /*     INITIALLY ON THE DISPLAY PANEL. THIS */
                         /*     SETTING MAY BE CHANGED BY USE OF     */
                         /*     ENTER WHENEVER THE DISPLAY PANEL IS  */
                         /*     PRESENTED.                           */
                         /* IGNORED IF PCSDISP=0, OR IF PCSDISP=4.   */
    2 PCSISOL            /* 0 = SAVE AND RESTORE MENU PANELS ARE     */
        FIXED BIN(31)    /*     MADE AVAILABLE TO THE OPERATOR.      */
          INIT(1),       /* 1 = SAVE AND RESTORE MENU PANELS ARE NOT */
                         /*     MADE AVAILABLE TO THE OPERATOR.      */
                         /* IGNORED IF PCSDISP=0 OR PCSDISP=4.       */
    2 PCSFNAME CHAR(8)   /* NAME OF PREVIOUSLY SAVED CHART FORMAT TO */
          INIT('*'),     /* BE USED INITIALLY. THE NAME '*' IS       */
                         /* RESERVED TO INDICATE THE DEFAULT CHART   */
                         /* FORMAT. IGNORED IF PCSDISP=0.            */
    2 PCSDNAME CHAR(8)   /* FOR PCSDISP=0, THE NAME UNDER WHICH THE  */
          INIT('*'),     /* CHART DATA CONTAINED IN "DATA_CONTROL",  */
                         /* "X", "Y", "KEYS", "LABELS" AND "HEADING" */
                         /* IS TO BE SAVED.                          */
                         /* FOR PCSDISP¬=0, THE NAME OF A PREVIOUSLY */
                         /* SAVED CHART DATA FILE TO BE USED INIT-   */
                         /* -IALLY OR FOR PRINTING. THE NAME '*'     */
                         /* INDICATES THAT THE DATA CONTAINED IN     */
                         /* "DATA_CONTROL", "X", "Y", "KEYS",        */
                         /* "LABELS" AND "HEADING" IS TO BE USED.    */
    2 PCSPAIR            /* 0 = "X" AND "Y" DATA GROUPS ARE NOT      */
        FIXED BIN(31)    /*     PAIRED. THERE IS ONLY ONE "X" DATA   */
           INIT(0),      /*     GROUP, OR SET OF "LABELS", WHICH IS  */
                         /*     PLOTTED AGAINST EACH "Y" DATA GROUP. */
                         /*     IN THIS MODE OF OPERATION, THERE MAY */
                         /*     BE RESTRICTIONS ON THE NUMBER OF "Y" */
                         /*     DATA GROUPS WHICH CAN BE DISPLAYED   */
                         /*     AT ANY ONE TIME.                     */
                         /* 1 = "X" AND "Y" DATA GROUPS ARE PAIRED.  */
                         /*     FOR EACH "Y" DATA GROUP THERE IS A   */
                         /*     UNIQUE "X" DATA GROUP AGAINST WHICH  */
                         /*     IT IS PLOTTED WHEN SELECTED. IN THIS */
                         /*     MODE OF OPERATION, SOME SHADING      */
                         /*     OPTIONS MAY BE IGNORED WHEN          */
                         /*     DISPLAYED. IF "LABELS" ARE PROVIDED  */
                         /*     INSTEAD OF "X", THEN EACH "Y" DATA   */
                         /*     GROUP IS MATCHED VALUE FOR LABEL     */
                         /*     AGAINST "LABELS" UNTIL THE DATA      */
                         /*     GROUP IS EXHAUSTED.                  */
                         /* IGNORED IF PCSDISP¬=0 AND PCSDNAME¬='*'. */
    2 PCSNC              /* MAXIMUM NO. OF DATA GROUPS. FOR          */
        FIXED BIN(31)    /* PCSPAIR=1, THE NUMBER OF DATA GROUPS FOR */
           INIT(0),      /* WHICH STORAGE IS PROVIDED IN "X" (FOR    */
                         /* PCSLABL=0) AND "Y", AND ALSO THE NO. OF  */
                         /* VALUES IN "DATA_CONTROL". FOR PCSPAIR=0, */
                         /* THE NUMBER OF DATA GROUPS FOR WHICH      */
                         /* STORAGE IS PROVIDED IN "Y". RANGE 0      */
                         /* THROUGH 999.                             */
                         /* IGNORED IF PCSDISP¬=0 AND PCSDNAME¬='*'. */
    2 PCSNE              /* MAXIMUM NO. OF ELEMENTS. THE NUMBER OF   */
        FIXED BIN(31)    /* VALUES (PER DATA GROUP) FOR WHICH        */
           INIT(0),      /* STORAGE IS PROVIDED IN "X" (FOR          */
                         /* PCSLABL=0) AND "Y", AND ALSO THE NO. OF  */
                         /* LABELS IN "LABELS" (FOR PCSLABL¬=0).     */
                         /* RANGE 0 THROUGH 999.                     */
                         /* IGNORED IF PCSDISP¬=0 AND PCSDNAME¬='*'. */
    2 PCSKEYL            /* LENGTH OF EACH STRING IN "KEYS". RANGE 0 */
        FIXED BIN(31)    /* THROUGH 132.                             */
           INIT(0),      /* IGNORED IF PCSDISP¬=0 AND PCSDNAME¬='*', */
                         /* OR IF PCSNC = 0.                         */
    2 PCSLABL            /* LENGTH OF EACH STRING IN "LABELS". RANGE */
        FIXED BIN(31)    /* 0 THROUGH 132.                           */
          INIT(0),       /* IGNORED IF PCSDISP¬=0 AND PCSDNAME¬='*', */
                         /* OR IF PCSNE=0.                           */
    2 PCSHEADL           /* LENGTH OF THE CHART "HEADING". RANGE 0   */
        FIXED BIN(31)    /* THROUGH 132.                             */
          INIT(0),       /* IGNORED IF PCSDISP¬=0 AND PCSDNAME¬='*'. */
    2 PCSPNAME CHAR(8)   /* PRINTER DESTINATION NAME. ' ' INDICATES  */
          INIT(' '),     /* NO PRINTER. '*' INDICATES THAT THE NAME  */
                         /* IS UNKNOWN, IN WHICH CASE THE OPERATOR   */
                         /* IS PROMTED FOR THE NAME AS REQUIRED).    */
                         /* IGNORED IF PCSDISP=0. THESE RESERVED     */
                         /* NAMES ARE NOT VALID FOR PCSDISP=4.       */
                         /********************************************/
                         /* NOTE THAT THE DEFINITION OF THE NEXT     */
                         /* TWO FIELDS HAVE BEEN CHANGED TO          */
                         /* 'FLOAT DEC(6) FROM RELEASE 3 ONWARD      */
                         /********************************************/
    2 PCSPRDEP           /* DEPTH IN ROWS OF THE CHART AREA ON THE   */
        FLOAT DEC(6)     /* PRINTER. RANGE 1 THROUGH 132. IGNORED IF */
          INIT(64),      /* PCSDISP=0, OR IF PCSPNAME=' ', OR IF     */
                         /* PCSPNAME='*'.                            */
    2 PCSPRWID           /* WIDTH IN COLUMNS OF THE CHART AREA ON THE*/
        FLOAT DEC(6)     /* PRINTER. RANGE 1 THROUGH 132. IGNORED IF */
          INIT(120),     /* PCSDISP=0, OR IF PCSPNAME=' ', OR IF     */
                         /* PCSPNAME='*'.                            */
    2 PCSPCOPY           /* NO. OF COPIES REQUIRED FOR PRINT.        */
        FIXED BIN(31)    /* IGNORED IF PCSDISP¬=4.                   */
          INIT(1),
                             /****************************************/
                             /* THE REMAINING FIELDS ARE NEW FROM    */
                             /* RELEASE 3 ONWARDS. THEY ARE NOT USED */
                             /* IN THIS APPLICATION, EXCEPT PCSUNIT  */
                             /****************************************/
    2 PCSPHEAD FIXED BIN(31) /* PRINTER HEADER PAGE CONTROL          */
               INIT(0),      /* 0 = DEFAULT, HEADER PAGE OUTPUT      */
    2 PCSPVOFF FLOAT DEC(6)  /* PRINTER VERTICAL OFFSET (ROWS)       */
               INIT(0),      /*                                      */
    2 PCSPHOFF FLOAT DEC(6)  /* PRINTER HORIZONTAL OFFSET (COLUMNS)  */
               INIT(0),      /*                                      */
    2 PCSPUNIT FIXED BIN(31) /* PRINTER LAYOUT PARAMETER UNITS       */
               INIT(4),      /* 4 = ROWS AND COLUMNS                 */
    2 PCSDUMMY FIXED BIN(31) /* RESERVED                             */
               INIT(0),      /*                                      */
    2 PCSDYNAM CHAR(8)       /* DIRECTORY LISTING OBJECT NAME        */
               INIT(' '),    /*                                      */
    2 PCSDYTYP FIXED BIN(31) /* DIRECTORY LISTING OBJECT TYPE        */
               INIT(0),      /* 0 = DEFAULT, NO INITIAL LIST         */
    2 PCSDYTYQ FIXED BIN(31) /* DIRECTORY LISTING OBJECT SUBTYPE     */
               INIT(0),      /* 0 = DEFAULT                          */
    2 PCSDYLIB CHAR(8)       /* DIRECTORY LISTING OBJECT LIBRARY     */
               INIT(' '),    /*                                      */
    2 PCSEXPL  FIXED BIN(31) /* INITIAL EXPERIENCE LEVEL VALUE       */
               INIT(0);      /* 0 = DEFAULT, STANDARD LEVEL          */
 /********************************************************************/
 /*     END OF PANEL CONTROL STRUCTURE (PCS) DEFINITION.             */
 /********************************************************************/

1 DECLARE
 /********************************************************************/
 /*                                                                  */
 /*       VARIOUS LOCAL VARIABLES                                    */
 /*                                                                  */
 /********************************************************************/
   END_OF_FILE BIT(1),   /* END OF FILE INDICATOR                    */
   RETCODE FIXED BIN(31),/* RETURN CODE FROM READ/ CLOSE             */
   RETCODE1 FIXED BIN(31),/* RETURN CODE FROM OPEN                   */
   EXIT BIT(1),          /* FLAG USED TO INDICATE EXIT REQUIRED      */
   ONSOURCE BUILTIN,     /* FORCE IT TO BE BUILTIN                   */
   FILE_NAME   CHAR(8)   /* DATA FILE NAME                           */
    INIT('        '),
   LABELLEN FIXED BIN(15),/* LENGTH OF X LABELS.                     */
   MEM    CHAR(8)        /* PDS MEMBER NAME CONTAINING DATA          */
    INIT('        '),
   PRT    CHAR(8)        /* PRINTER NAME FOR PRINTING GRAPH          */
    INIT('        '),
   FMT    CHAR(8)        /* NAME OF CHART FORMAT                     */
    INIT('*       '),
   DEP    FLOAT DEC(6)   /* PRINTER DEPTH (ROWS) TO PRINT            */
    INIT(64),
   WID    FLOAT DEC(6)   /* PRINTER WIDTH (COLS) TO PRINT            */
    INIT(120),
   COP    FIXED BIN(31)  /* NUMBER OF COPIES TO PRINT                */
    INIT(1),
   HED    FIXED BIN(31)  /* PRINTER HEADER PAGE CONTROL              */
    INIT(0),
   VOF    FLOAT DEC(6)   /* PRINTER VERTICAL OFFSET                  */
    INIT(0),
   HOF    FLOAT DEC(6)   /* PRINTER HORIZONTAL OFFSET                */
    INIT(0),
   UNT    FIXED BIN(31)  /* PRINTER LAYOUT PARAMETER UNITS           */
    INIT(4),
   DEB    CHAR(3)        /* DEBUG MODE FLAG                          */
    INIT('OFF'),
   PROCOPT_LIST(10) FIXED BIN(31), /* PROCESSING OPTIONS LIST        */
   NAME_LIST(1) CHAR(8)            /* DEVICE CONTROL NAME LIST       */
     INIT('        ');

1 DECLARE                /* ENTRY POINTS FOR ASSEMBLER I/O ROUTINES  */
   ADMUSP6O ENTRY(CHARACTER(8),
                  FIXED BIN(31)) OPTIONS(INTER ASSEMBLER),
   ADMUSP6C ENTRY (FIXED BIN(31)) OPTIONS(INTER ASSEMBLER),
   ADMUSP6R ENTRY(POINTER,
                   FIXED BIN(31)) OPTIONS(INTER ASSEMBLER),

   ERRPROC  EXTERNAL ENTRY,/*EXTERNAL ERROR HANDLING PROCEDURE       */

   DUMMY POINTER;        /* DUMMY VARIABLE                           */

 DECLARE  (              /* GDDM ENTRY POINTS USED, REENTRANT FORM*/
  ASCGET ENTRY(*,  BIN FIXED(31),BIN FIXED(31),CHAR(*)               ),
  ASCPUT ENTRY(*,  BIN FIXED(31),BIN FIXED(31),*                     ),
  ASDFMT ENTRY(*,  BIN FIXED(31),BIN FIXED(31),(*,*)BIN FIXED(31)    ),
  ASFCUR ENTRY(*,  BIN FIXED(31),BIN FIXED(31),BIN FIXED(31)         ),
  ASDFLT ENTRY(*,  BIN FIXED(31),(*) BIN FIXED(31)                   ),
  ASQMOD ENTRY(*,  BIN FIXED(31),BIN FIXED(31),BIN FIXED(31),
                   BIN FIXED(31)                                     ),
  ASFMOD ENTRY(*,  BIN FIXED(31),BIN FIXED(31)                       ),
  ASREAD ENTRY(*,  BIN FIXED(31),BIN FIXED(31),BIN FIXED(31)         ),

  FSALRM ENTRY(*                                                     ),
  FSINR  ENTRY(*                                                     ),
  FSTERM ENTRY(*                                                     ),
  FSEXIT ENTRY(*,  ENTRY,BIN FIXED(31)                               ),
  DSOPEN ENTRY(*,  BIN FIXED(31),BIN FIXED(31),CHAR(8),
                   BIN FIXED(31),(*)BIN FIXED(31) CONN,
                   BIN FIXED(31),(*)CHAR(8) CONN                     ),
                                  /* OPEN DEVICE                     */
  DSUSE  ENTRY(*,  BIN FIXED(31),BIN FIXED(31)                       ),
                                  /* SPECIFY DEVICE USAGE            */
  CHART  ENTRY(                                                      )
         )OPTIONS(ASM,INTER);

  DECLARE                          /* GDDM ANCHOR BLOCK              */
    1 AB,
       2  AABSC   FIXED BIN(15),   /* SEVERITY CODE                  */
       2  AABEC   FIXED BIN(15),   /* ERROR CODE                     */
       2  AABAP   POINTER,         /* GDDM ANCHOR                    */
       2  MESSAGE CHARACTER(60)    /* MESSAGE TEXT RETURNED FROM     */
            INIT(' ');             /* ERROR PROCEDURE                */


1/********************************************************************/
 /*                                                                  */
 /*       MAIN PROGRAM                                               */
 /*                                                                  */
 /********************************************************************/
   CALL FSINR(AB);       /* INITIALISE GDDM FOR RE-ENTRANT CODE      */
   CALL FSEXIT(AB,ERRPROC ,4);     /* CAUSE ERRORS TO CALL ERRPROC   */

   /******************************************************************/
   /*   EXTRACT PARAMETER LIST DATA AND PLACE IN ADMTPCS             */
   /******************************************************************/
   GET STRING(PARMLIST)
       DATA(MEM,PRT,FMT,DEP,WID,COP,HED,VOF,HOF,UNT,DEB);
   FILE_NAME = MEM;                           /* NAME OF DATA FILE   */
   PCSPNAME  = PRT;                           /* PRINTER NAME        */
   PCSFNAME  = FMT;
   PCSPRDEP  = DEP;
   PCSPRWID  = WID;
   PCSPCOPY  = COP;
   PCSPHEAD  = HED;
   PCSPVOFF  = VOF;
   PCSPHOFF  = HOF;
   PCSPUNIT  = UNT;

   /******************************************************************/
   /*   READ AND PROCESS DATA FROM FILE                              */
   /******************************************************************/
   CALL GET_FILE;                             /* GET DATA FROM FILE  */
   PCSLABL = LABELLEN;                        /* SET LABEL LENGTH    */

   IF DEB = 'ON' THEN
     PUT DATA(ADMTPCS);         /* DEBUG MODE DISPLAY                */

   /******************************************************************/
   /*   OPEN DUMMY DEVICE FOR BATCH INVOCATION                       */
   /******************************************************************/
   CALL DSOPEN(AB,11,   1,   'L79A3',   0,PROCOPT_LIST,   1,NAME_LIST);
   CALL DSUSE(AB,1,11);            /* USE DEVICE 11 AS PRIMARY       */

   /******************************************************************/
   /*   INVOKE CHART                                                 */
   /******************************************************************/
   CALL CHART(AB,               /* CALL CHART UTILITY WITH RESULT.   */
             ADMTPCS,           /* CONTROL STRUCTURE.                */
             DATA_CONTROL,      /* DATA CONTROL VECTOR (NONE).       */
             XDATA,             /* X DATA                            */
             YDATA,             /* Y DATA                            */
             KEYS,              /* KEYS                              */
             XLABELS,           /* DATA LABELS                       */
             HEADING);          /* HEADING                           */

   IF DEB = 'ON' THEN
     PUT DATA(AB);              /* DEBUG MODE DISPLAY                */

   CALL FSTERM(AB);             /* TERMINATE GDDM                    */
 /********************************************************************/
 /*      END OF MAIN PROGRAM                                         */
 /********************************************************************/

1DECLARE
  HEADING CHAR(132),               /* STRING OF CHARACTERS FORMING   */
                                   /* THE HEADING.                   */
  HEADLEN FIXED BIN(31),           /* LENGTH OF HEADING              */
  XINDEX FIXED BIN(15),            /* LAST POSITION USED IN XDATA    */
  YINDEX FIXED BIN(15),            /* LAST POSITION USED IN YDATA    */
  XLABELS CHAR(15000),             /* STRING CONTAINING X LABELS     */
  XNUMERIC BIT(1),                 /* INDICATES X IS ENTIRELY NUMERIC*/
  NOFILE   BIT(1),                 /* INDICATES NO FILE FOUND        */
  XDATA(6000) FLOAT,               /* ARRAY CONTAINING X DATA        */
  YDATA(6000) FLOAT,               /* ARRAY CONTAINING Y DATA        */
  DATA_CONTROL(100) FIXED BIN(31), /* ARRAY CONTAINING NE VALS       */
  COLUMNS  FIXED BIN(15),          /* NUMBER OF DATA COLUMNS WANTED  */
  ROWS     FIXED BIN(15),          /* NUMBER OF DATA ROWS FOUND      */
  KEYS CHAR(400),                  /* STRING OF CHARACTERS CONTAINING*/
                                   /* THE KEYS.  CONTAINS ALL KEYS   */
                                   /* CONCATENATED TOGETHER.         */
  KEYLEN FIXED BIN(15),            /* LENGTH OF EACH KEY.            */
                                   /* (NUMBER IS GIVEN BY COLUMNS)   */
  KEYCOUNT FIXED BIN(15),          /* COUNT OF KEYS DISCOVERED       */

  CURRENT_TOKEN CHARACTER(32) VARYING,/* CURRENT INPUT TOKEN         */
  INREC CHARACTER(32767)           /* CURRENT INPUT RECORD           */
         VARYING BASED(RECPTR),    /*   WDPSC      */
  CHARINDEX FIXED BIN(15);         /* INDEX TO CURRENT POSITION      */


1GET_FILE: PROCEDURE;
 /********************************************************************/
 /*  READS THE INPUT FILE.                                           */
 /*        THIS CONSISTS OF:                                         */
 /*           THE HEADING CARD (CONTAINING THE PLOT TITLE)           */
 /*           THE KEYS CARD    (CONTAINING THE DATA DESCRIPTIONS)    */
 /*           DATA CARDS       (CONTAINING THE X AND Y DATA)         */
 /*                                                                  */
 /*  IT SETS (SOMETIMES BY SUBROUTINES):                             */
 /*                                                                  */
 /*  HEADING TO THE HEADING TEXT,  HEADLEN TO THE HEADING LENGTH     */
 /*  KEYS    TO THE KEY     TEXT,  KEYLEN  TO THE KEY     LENGTH     */
 /*  ROWS  TO THE NUMBER OF ROWS OF INPUT DATA.                      */
 /*  COLUMNS TO THE NUMBER OF COLUMNS (COMPONENTS+1)                 */
 /*  XLABELS TO THE XDATA LABELS,  YDATA TO THE YDATA VALUES         */
 /*  XDATA   TO THE XDATA VALUES IF THEY ARE NUMERIC.                */
 /*  XNUMERIC INDICATES THIS HAS BEEN DONE.                          */
 /********************************************************************/
   CALL ADMUSP6O(FILE_NAME,RETCODE1);/* OPEN THE INPUT FILE          */
   IF RETCODE1 = 4 THEN           /* CHECK ITS EXISTENCE            */
     MESSAGE = 'DATA FILE NOT FOUND';
   IF RETCODE1 = 8 THEN           /* CHECK ITS EXISTENCE            */
     MESSAGE = 'DATA FILE OPEN ERROR';

   IF MESSAGE = '' THEN            /* IF NO ERROR                    */
     CALL GET_HEAD;                /* READ IN HEADING DATA           */

   IF MESSAGE = '' THEN            /* IF NO ERROR                    */
     CALL GET_KEYS;                /* READ IN THE KEY DATA           */

   COLUMNS = KEYCOUNT+1;           /* THERE IS ONE COLUMN FOR EACH   */
                                   /* KEY GIVEN PLUS ONE FOR XDATA   */
   IF MESSAGE = '' THEN            /* IF NO ERROR                    */
     CALL GET_MATRIX;              /* READ IN THE INPUT MATRIX       */

   IF MESSAGE = '' THEN            /* IF ALL WENT WELL:              */
    DO;                            /* RECORD THE DATA IN CHART       */
                                   /* CONTROL STRUCTURE.             */
  IF NG > 0 THEN DO;
     PCSNE = MAXNE;                /* SET NUMBER OF ELEMENTS         */
     PCSNC = NG   ;                /* SET NUMBER OF COMPONENTS       */
                 END;
            ELSE DO;
     PCSNE = ROWS;                 /* SET NUMBER OF ELEMENTS         */
     PCSNC = KEYCOUNT;             /* SET NUMBER OF COMPONENTS       */
                 END;
     IF PCSNE > 0 & XNUMERIC='1'B THEN PCSNE=PCSNE*-1;
     PCSHEADL = HEADLEN;           /* HEADING LENGTH                 */
     PCSKEYL =  KEYLEN;            /* KEY ITEM LENGTH                */
     PCSLABL =  LABELLEN;          /* LABEL LENGTH                   */
    END;
   ELSE
    DO;                            /* IF THERE IS A MESSAGE FROM     */
     PCSNE = 0;                    /* THE FILE FETCH, SET THE ROWS   */
     PCSNC = 0;                    /* AND COLUMNS TO ZERO.           */
    END;                           /* (CAN CALL CHART WITH NO DATA)  */

   IF RETCODE1 < 4 THEN
      CALL ADMUSP6C(RETCODE);      /* CLOSE THE INPUT FILE           */
 END;                              /* OF GET FILE PROCEDURE          */


1GET_HEAD: PROCEDURE;
 /********************************************************************/
 /*  READS A SINGLE INPUT RECORD CONTAINING THE HEADING TEXT.        */
 /*  LEADING AND TRAILING BLANKS ARE IGNORED.                        */
 /*   - SETS HEADING TO THE TEXT, HEADLEN TO THE LENGTH.             */
 /********************************************************************/

  CALL ADMUSP6R(RECPTR,RETCODE);   /* FETCH THE HEADING RECORD       */
  IF RETCODE > 0 THEN              /* IF RETURN CODE NON ZERO,       */
    DO;                            /* DIAGNOSE -                     */
      IF RETCODE = 4 THEN
        MESSAGE = 'NO HEADING RECORD';
      ELSE
        MESSAGE = 'ERROR READING FILE';
    END;
  ELSE                             /* OK, RECORD FETCHED             */
   DO;                             /* THERE IS A RECORD THERE:       */
    CHARINDEX = 1;                 /* SET INITIAL POSITION           */

    /*****************************************************************/
    /*  SCAN OVER ANY INITIAL BLANKS                                 */
    /*****************************************************************/
    DO WHILE ((SUBSTR(INREC,CHARINDEX,1) = ' ')
         & (CHARINDEX ¬> LENGTH(INREC)));
      CHARINDEX = CHARINDEX + 1;
    END;

    /*****************************************************************/
    /*  SET HEADING LENGTH, ASSUMING THERE ARE NO TRAILING BLANKS    */
    /*****************************************************************/
    HEADLEN = LENGTH(INREC) - CHARINDEX + 1;

    /*****************************************************************/
    /*   EITHER INPUT CHARACTER IS NON BLANK OR CHARINDEX            */
    /*   IS GREATER THAN THE INPUT RECORD LENGTH.                    */
    /*    - IN FORMER CASE, SCAN BACKWARDS FROM END OF RECORD.       */
    /*****************************************************************/

    IF CHARINDEX ¬> LENGTH(INREC) THEN

      /***************************************************************/
      /*   REDUCE HEADLEN UNTIL THE LAST CHARACTER IS NOT A BLANK.   */
      /***************************************************************/

      DO WHILE (SUBSTR(INREC,CHARINDEX+HEADLEN-1,1) = ' ');
        HEADLEN = HEADLEN -1;
      END;

    /*****************************************************************/
    /*   MOVE HEADING INTO RESERVED SPACE.                           */
    /*****************************************************************/
    HEADING = SUBSTR(INREC,CHARINDEX,HEADLEN);
   END;
 END;                              /* OF GET HEADING PROCEDURE       */


1GET_KEYS: PROCEDURE;
 /********************************************************************/
 /*  READS THE TOKENS FROM A SINGLE INPUT RECORD FOR THE KEY DATA.   */
 /*  EACH TOKEN IS A KEY AND THERE SHOULD BE THE SAME NUMBER OF Y    */
 /*  DATA COLUMNS.                                                   */
 /********************************************************************/

  KEYLEN = 0;                      /* INITIALISE KEY LENGTH          */
  KEYCOUNT = 0;                    /* AND NUMBER OF KEYS             */
  CHARINDEX = 1;                   /* INITIALISE CHARACTER INDEX     */

  CALL ADMUSP6R(RECPTR,RETCODE);   /* FETCH THE KEY RECORD           */
  IF RETCODE > 0 THEN              /* IF NON ZERO RETURN */
    DO;                            /* DIAGNOSE -                     */
      IF RETCODE = 4 THEN
        MESSAGE = 'NO KEY DATA SUPPLIED';
      ELSE
        MESSAGE = 'ERROR READING FILE';
    END;
  ELSE                             /* OK, RECORD FETCHED             */
   DO UNTIL(CURRENT_TOKEN = '');   /* UNTIL END OF KEYS              */

     CALL GET_TOKEN;               /* GET THE KEY                    */
     IF CURRENT_TOKEN ¬= '' THEN   /* IF IT IS A REAL ONE:           */
                                   /* APPEND IT TO THE KEY LIST      */
       CALL APPEND(KEYS,KEYCOUNT,KEYLEN,CURRENT_TOKEN);
   END;                            /* OF KEY FETCH LOOP              */
 END;                              /* OF GET KEYS PROCEDURE         */


1GET_MATRIX:PROCEDURE;
 /********************************************************************/
 /*  READS THE RECTANGULAR DATA ARRAY FROM THE INPUT FILE.           */
 /*     EACH CARD CONTAINS 1 ROW OF DATA, THAT IS ONE X VALUE        */
 /*     AND COLUMNS Y VALUES.                                        */
 /*  THE X VALUES MAY BE NUMERIC OR ALPHANUMERIC.  THE Y VALUES      */
 /*  MUST BE NUMERIC.                                                */
 /*  AN ALPHANUMERIC VALUE MAY BE ANY TOKEN.  A NUMERIC VALUE        */
 /*  MAY BE ANY TOKEN WHICH PL/I WILL CONVERT TO FLOAT.              */
 /********************************************************************/
  DECLARE
    I  FIXED BIN(15);              /* LOCAL INDEX                    */

  XINDEX = 0;                      /* INITIALISE THE ROW INDEX       */
  ALLROWS = 0;
  YINDEX = 0;                      /* THE INDEX TO YDATA             */
  NG = 0;
  MAXNE = 0;
  ROWS   = 0;                      /* COUNT OF MATRIX ROWS           */
  LABELLEN = 0;                    /* AND LENGTH OF X LABELS         */

  ON CONVERSION                    /* IF THERE IS A CONVERSION ERROR */
    BEGIN;                         /* IN THE DATA EXTRACTION, REPLACE*/
      ONSOURCE = '0';              /* WITH 0 AND DIAGNOSE            */
      MESSAGE = 'NON NUMERIC Y VALUE FOUND IN DATA';
    END;

  END_OF_FILE = '0'B;
  DO WHILE(END_OF_FILE = '0'B      /* WHILE THERE IS MORE DATA       */
         & MESSAGE = '');          /* AND NO ERROR IS FOUND.         */
    CALL ADMUSP6R(RECPTR,RETCODE);    /* FETCH NEXT INPUT RECORD     */
    IF RETCODE  > 0 THEN              /* IF NON ZERO RETURN          */
      DO;                             /* DIAGNOSE -                  */
         DATA_CONTROL(NG) = ROWS;
         IF ROWS > MAXNE THEN
           MAXNE = ROWS;
       IF RETCODE = 4 THEN DO;
         END_OF_FILE = '1'B;
                           END;
       ELSE
         MESSAGE = 'ERROR READING FILE';
      END;
    ELSE                            /* OK, RECORD FETCHED             */
     DO;
      CALL GET_TUPLE;              /* EXTRACT MATRIX ROW             */
      ROWS = ROWS + 1;             /* AND COUNT THE NUMBER OF ROWS   */
     END;

  END;                             /* OF RECORD LOOP                 */

 IF NG =  0 THEN DO;
   PCSPAIR = 0;
   CALL TRANSPOSE(YDATA,ROWS,COLUMNS-1); /*TRANSPOSE THE Y MATRIX   */
                 END;
            ELSE PCSPAIR = 1;
 /********************************************************************/
 /*   ATTEMPT TO CONVERT THE XLABELS TO NUMERIC DATA                 */
 /*   IN XDATA.                                                      */
 /********************************************************************/

  ON CONVERSION
    BEGIN;                         /* IF A CONVERSION ERROR OCCURS,  */
      XNUMERIC = '0';              /* SET FLAG TO NON NUMERIC        */
      GOTO DONE;                   /* AND STOP PROCESSING            */
    END;

  XNUMERIC = '1'B;               /* ASSUME IT WILL WORK SUCCESSFULLY */
  DO I = 0 TO ALLROWS-1;         /* PROCESS ALL XLABELS              */
                                 /* CONVERTING THEM TO NUMERIC       */
    XDATA(I+1) = SUBSTR(XLABELS,I*LABELLEN+1,LABELLEN);
  END;
 DONE:                           /* PROCESSING FINISHED              */
  REVERT CONVERSION;
 END;                            /* OF GET MATRIX PROCEDURE          */


1GET_TUPLE: PROCEDURE;
 /********************************************************************/
 /*  READS A MATRIX ROW FROM A SINGLE INPUT RECORD.                  */
 /*  THE FIRST TOKEN ON THE CARD IS THE XLABEL AND IS CONCATENATED   */
 /*  INTO THE XLABEL ARRAY.   THE REMAINING TOKENS ARE CONVERTED     */
 /*  TO NUMERIC AND PLACED IN THE YDATA ARRAY.                       */
 /*  THE NUMBER OF ITEMS EXPECTED  IS  THE VARIABLE COLUMNS.         */
 /********************************************************************/
  DCL I FIXED BIN(15);             /* INDEX TO ITEMS FETCHED         */

  CHARINDEX = 1;                   /* INITIALISE CHARACTER POINTER   */
 /********************************************************************/
 /*  FIRST DO THE FIRST COLUMN, WHICH GOES INTO XLABELS.             */
 /********************************************************************/
  IF XINDEX+1 > HBOUND(XDATA,1) THEN /* CHECK WHETHER TOO MANY ITEMS.*/
   MESSAGE = 'TOO MANY DATA ITEMS';/* AND IF SO DIAGNOSE IT.         */

  CALL GET_TOKEN;                  /* GET THE ITEM                   */
  IF (CURRENT_TOKEN = '=NG') | (CURRENT_TOKEN = '=NG') THEN DO;
     CALL GET_TOKEN;               /* GET THE KEY                    */
     IF CURRENT_TOKEN ¬= '' THEN   /* IF IT IS A REAL ONE:           */
                                   /* APPEND IT TO THE KEY LIST      */
       CALL APPEND(KEYS,KEYCOUNT,KEYLEN,CURRENT_TOKEN);
     DATA_CONTROL(NG) = ROWS;
     NG = NG + 1 ;
     IF ROWS > MAXNE THEN MAXNE = ROWS;
     ROWS = -1;
     COLUMNS = 2;
                                END;
                           ELSE DO;
     ALLROWS = ALLROWS + 1;

  IF XINDEX <= HBOUND(XDATA,1) THEN/* PROVIDED IT WILL FIT THE ARRAY */
                                   /* APPEND TOKEN TO LABEL LIST     */
    CALL APPEND(XLABELS,XINDEX,LABELLEN,CURRENT_TOKEN);

 /********************************************************************/
 /*  THEN DO THE REMAINING COLUMNS WHICH GO INTO YARRAY.             */
 /********************************************************************/

  DO I = 2 TO COLUMNS;             /* FOR ALL COLUMNS EXPECTED,      */

   YINDEX = YINDEX + 1;            /* INCREMENT YINDEX FOR NEXT SLOT */
   IF YINDEX > HBOUND(YDATA,1) THEN /*CHECK WHETHER TOO MANY ITEMS.  */
    MESSAGE = 'TOO MANY DATA ITEMS';/*AND ASSIGN IT INTO YDATA ARRAY */

   CALL GET_TOKEN;                 /* GET THE ITEM                   */
   IF YINDEX <= HBOUND(YDATA,1)    /* PROVIDED IT WILL FIT THE ARRAY */
   THEN
    YDATA(YINDEX) = CURRENT_TOKEN; /* ASSIGN IT IN (MAY NOT CONVERT) */

  END;                             /* OF Y VALUE EXTRACTION          */
                                END;
 END;                              /* OF GET TUPLE PROCEDURE         */


1GET_TOKEN: PROCEDURE;
 /********************************************************************/
 /*  READS A SINGLE TOKEN FROM THE INPUT RECORD AND PLACES           */
 /*  IT IN CURRENT_TOKEN.                                            */
 /*  A TOKEN IS EITHER:                                              */
 /*     AS SERIES OF UP TO 32 ALPHANUMERIC CHARACTERS WITHOUT        */
 /*      IMBEDDED BLANKS.                                            */
 /*  OR A NULL STRING   (INDICATING NO INPUT).                       */
 /*   IF AN _ CHARACTER IS FOUND IT IS CHANGED TO A BLANK            */
 /********************************************************************/

 DECLARE
   TOKEN_START FIXED BIN(15);      /* INDEX OF FIRST CHARACTER       */
                                   /* IN THE TOKEN                   */
 /********************************************************************/
 /*  SCAN OVER ANY INITIAL BLANKS                                    */
 /********************************************************************/
 DO WHILE ((SUBSTR(INREC,CHARINDEX,1) = ' ')
         & (CHARINDEX ¬> LENGTH(INREC)));
   CHARINDEX = CHARINDEX + 1;
 END;
 /********************************************************************/
 /*  NOW EITHER INPUT CHARACTER IS NON BLANK OR CHARINDEX            */
 /*  IS GREATER THAN THE INPUT RECORD LENGTH.                        */
 /*    - IN FORMER CASE, SCAN TO NEXT BLANK.                         */
 /********************************************************************/
 IF CHARINDEX ¬> LENGTH(INREC) THEN
  DO;                              /* THE INPUT POSITION IS VALID    */
    TOKEN_START = CHARINDEX;       /* NOTE TOKEN START               */
                                   /* SCAN TO THE END OF THE TOKEN   */
                                   /* IE TO NEXT NON BLANK           */
    DO WHILE ((SUBSTR(INREC,CHARINDEX,1) ¬= ' ')
             & (CHARINDEX ¬> LENGTH(INREC)));
                    /* REPLACE ANY  _ BY BLANK */
      IF SUBSTR(INREC,CHARINDEX,1)  = '_' THEN
         SUBSTR(INREC,CHARINDEX,1)  = ' ';
      CHARINDEX = CHARINDEX + 1;
    END;
                                   /* COPY TOKEN TO CURRENT_TOKEN    */
    CURRENT_TOKEN = SUBSTR(INREC,TOKEN_START,CHARINDEX-TOKEN_START);
  END;
 ELSE                              /* INPUT POSITION INVALID,        */
    CURRENT_TOKEN = '';            /* SET CURRENT TOKEN TO NULL      */
 END;                              /* OF GET TOKEN PROCEDURE         */


1APPEND:PROCEDURE(STRING_ARRAY,ITEMS,STRING_LENGTH,TOKEN);
 /********************************************************************/
 /*   CONCATENTATES A TOKEN ONTO A STRING ARRAY.                     */
 /*     - THE STRING ARRAY IS A STRING CONTAINING ZERO OR MORE       */
 /*       TOKENS.  THESE ARE ALL CONCATENATED TOGETHER AND EACH IS   */
 /*       PADDED TO THE LENGTH OF THE LONGEST TOKEN.                 */
 /*     - THE STRING ARRAY, THE ITEM COUNT AND THE STRING LENGTH     */
 /*       ARE ALL SET BY THE PROCEDURE.                              */
 /********************************************************************/
 DECLARE
    STRING_ARRAY CHAR(*),          /* THE CHARACTER STRING CONTAINING*/
                                   /* THE TOKENS.                    */
    ITEMS         FIXED BIN(15),   /* THE NUMBER OF TOKENS ALREADY   */
                                   /* HELD IN THE STRING ARRAY.      */
    STRING_LENGTH FIXED BIN(15),   /* THE LENGTH OF TOKENS IN THE    */
                                   /* STRING ARRAY.                  */
    TOKEN CHAR(32) VARYING,        /* THE TOKEN TO BE ADDED.         */

    NEWLENGTH    FIXED BIN(15),    /* TEMPORARY TO CONTAIN NEW LEN   */
    I            FIXED BIN(15);    /* TEMPORARY COUNTER              */

 IF LENGTH(TOKEN) > STRING_LENGTH  THEN
   DO;
    /*****************************************************************/
    /*  THE NEW TOKEN IS LONGER THAN THE OLD ONES, SO REFORMAT       */
    /*  THE STRING ARRAY FOR THE LONGER TOKENS.                      */
    /*****************************************************************/
    NEWLENGTH = LENGTH(TOKEN);            /* NEW STRING LENGTH       */
    IF NEWLENGTH*ITEMS > LENGTH(STRING_ARRAY) THEN
      MESSAGE = 'TOO MUCH STRING DATA';
    ELSE                           /* IF ENOUGH ROOM THEN            */
     DO;
      DO I = ITEMS-1 TO 0 BY -1;   /*      PROCESS ALL STRINGS BY    */
                                   /*      MOVING THEM ABOUT         */
        SUBSTR(STRING_ARRAY,I*NEWLENGTH+1,NEWLENGTH)
            = SUBSTR(STRING_ARRAY,I*STRING_LENGTH+1,STRING_LENGTH);
      END;
      STRING_LENGTH = NEWLENGTH;   /*  AND RESET STRING LENGTH.      */
     END;
   END;                            /*        END OF KEY REFORMAT     */
 /********************************************************************/
 /* NOW INSERT THE NEW KEY, EXPANDING TO KEYLEN.                     */
 /********************************************************************/
 ITEMS = ITEMS + 1;                /* INCREASE ITEM COUNT.           */
 IF STRING_LENGTH*ITEMS > LENGTH(STRING_ARRAY) THEN
    MESSAGE = 'TOO MUCH STRING DATA';
 ELSE                              /* IF THERE IS ENOUGH ROOM THEN:  */
                                   /* INSERT THE TOKEN               */
  SUBSTR(STRING_ARRAY,(ITEMS-1)*STRING_LENGTH+1,STRING_LENGTH) = TOKEN;
 END;                              /* OF APPEND PROCEDURE            */


1TRANSPOSE: PROCEDURE(INARRAY,ROWS,COLUMNS);
 /********************************************************************/
 /*   TRANSPOSES THE MATRIX INARRAY.                                 */
 /*     - THE ARRAY IS ASSUMED TO HAVE ROWS ROWS AND COLUMNS         */
 /*       COLUMNS.                                                   */
 /*     - ON INPUT IT IS STORED WITH THE ROW INDEX VARYING MOST      */
 /*       RAPIDLY. ON OUTPUT THE COLUMN INDEX VARIES MOST RAPIDLY    */
 /********************************************************************/
 DECLARE
    INARRAY (*) FLOAT,             /* THE INPUT ARRAY.               */
    ROWS          FIXED BIN(15),   /* THE NUMBER OF ROWS OF DATA     */
    COLUMNS       FIXED BIN(15),   /* THE NUMBER OF COLUMNS          */
    (I,J)         FIXED BIN(15),   /* TEMPORARY INDEXES              */
    TEMP(ROWS*COLUMNS) FLOAT;      /* TEMPORARY USED IN CONVERSION   */

    DO I = 0 TO ROWS-1;            /* TRANSPOSE THE MATRIX INTO TEMP */
      DO J = 0 TO COLUMNS-1;
        TEMP(J*ROWS+I+1) = INARRAY(I*COLUMNS+J+1);
      END;
    END;
    DO I = 1 TO ROWS*COLUMNS;      /* AND COPY IT BACK TO INARRAY    */
        INARRAY(I) = TEMP(I);
    END;
 END;                              /* OF TRANSPOSE PROCEDURE         */


 END;                              /* OF ADMUSP6                     */
*PROCESS;


1ERRPROC : PROCEDURE(AB,ERRORBLOCK) OPTIONS(COBOL);
 /********************************************************************/
 /*   PROCEDURE NOMINATED AS ERROR EXIT BY AN FSEXIT CALL.           */
 /*     - RECEIVES CONTROL WHEN AN ERROR IS DETECTED.                */
 /*       THE PARAMETER PASSED IS NOT IN ACCEPTABLE PL/I FORMAT      */
 /*       SO THE PROCEDURE IS DECLARED OPTIONS COBOL                 */
 /*     - THE APPLICATION ANCHOR BLOCK PASSED BY GDDM CONTAINS       */
 /*       THE ADDRESS OF THE MESSAGE AREA IN THE USER EXTENSION.     */
 /*       THIS AREA IS SET TO THE MESSAGE TEXT.                      */
 /*     - THE PROCEDURE IS INCLUDED IN THE MAIN COMPILATION FOR      */
 /*       CONVENIENCE, HOWVER LOGICALLY IT IS EXTERNAL.              */
 /********************************************************************/
 DECLARE
   1 ERRORBLOCK,                   /* THAT PART OF REQUIRED          */
      2 SEVERITY FIXED BIN(31),    /* THE ERROR SEVERITY             */
      2 NUMBER   FIXED BIN(31),    /* THE ERROR NUMBER               */
      2 FNAME    CHARACTER(8),     /* THE FUNCTION NAME              */
      2 MSGLEN   FIXED BIN(31),    /* MESSAGE LENGTH                 */
      2 MSGTEXT  CHARACTER(80);    /* MESSAGE TEXT                   */
 DECLARE                          /* GDDM ANCHOR BLOCK              */
    1 AB,
       2  AABSC   FIXED BIN(15),   /* SEVERITY CODE                  */
       2  AABEC   FIXED BIN(15),   /* ERROR CODE                     */
       2  AABAP   CHARACTER(4),    /* GDDM ANCHOR, ACTUALLY A POINTER*/
       2  MESSAGE CHARACTER(60);   /* MESSAGE TEXT RETURNED          */

   MESSAGE = SUBSTR(MSGTEXT,1,LENGTH(MESSAGE));
 END;                              /* OF ERRPROC  PROCEDURE          */
