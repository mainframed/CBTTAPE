        /* DATA SET 761KKUSP6  AT LEVEL 002 AS OF 10/04/83    */
 ADMUSP6:PROCEDURE OPTIONS(MAIN);
 /********************************************************************/
 /*                      ADMUSP6                                     */
 /*                                                                  */
 /*       APPLICATION TO PLOT THE DATA IN A NAMED FILE USING         */
 /*                THE 'CHART' UTILITY.                              */
 /*                                                                  */
 /*                                                                  */
 /*       THE FILE MUST CONSIST OF A NUMBER OF (80 BYTE)             */
 /*       RECORDS WHICH GIVE A TABLE OF DATA TO BE PLOTTED.          */
 /*       THE RECORDS ARE FORMATTED AS FOLLOWS:                      */
 /*                                                                  */
 /*        RECORD 1.                                                 */
 /*           CONTAINS THE CHART HEADING.                            */
 /*           LEADING AND TRAILING BLANKS ARE REMOVED FROM THE       */
 /*           TEXT SUPPLIED IN THE RECORD AND THE RESULTING          */
 /*           STRING IS USED TO TITLE THE GENERATED CHART.           */
 /*                                                                  */
 /*        RECORD 2.                                                 */
 /*           CONTAINS THE COLUMN HEADINGS OF THE TABLE,             */
 /*           WHICH WILL FORM THE CHART KEYS.  THESE KEYS            */
 /*           MUST BE SINGLE WORDS (WITHOUT IMBEDDED BLANKS)         */
 /*           OF NOT MORE THAN 32 CHARACTERS.                        */
 /*           OCCURRENCES OF UNDERSCORE CHARACTERS (_)               */
 /*           IN A WORD ARE REPLACED BY BLANKS SO THAT               */
 /*           BLANK CHARACTERS MAY BE GENERATED IN THE KEY           */
 /*           TEXT IF REQUIRED.                                      */
 /*                                                                  */
 /*           ONE WORD SHOULD BE PROVIDED FOR EACH DATA COLUMN       */
 /*           TO BE PLOTTED (EXCEPT THE FIRST WHICH IS USED AS       */
 /*           THE X DATA).                                           */
 /*                                                                  */
 /*        RECORDS 3 - N                                             */
 /*           CONTAIN THE TABLE OF DATA.    EACH RECORD              */
 /*           CONTAINS ONE TABLE ROW.  THE FIRST WORD IS THE         */
 /*           'X VALUE' FOR THE ROW, FURTHER WORDS ARE THE Y         */
 /*           VALUES.  THERE SHOULD BE ONE Y VALUE FOR EACH          */
 /*           KEY SPECIFIED ON THE KEY RECORD (RECORD 2).            */
 /*           X VALUES MAY BE NUMERIC OR ALPHANUMERIC.  Y VALUES     */
 /*           MUST BE NUMERIC, THAT IS THEY SHOULD BE CONVERTIBLE    */
 /*           TO FLOATING POINT NUMBERS BY THE NORMAL PL/I           */
 /*           CHARACTER TO ARITHMETIC CONVERSION.                    */
 /*                                                                  */
 /*      SAMPLE DATA MIGHT BE:                                       */
 /*                                                                  */
 /*               HISTORY OF RESULTS FOR XYZ LTD.                    */
 /*                   COSTS       SALES                              */
 /*        1975        320         120                               */
 /*        1976        330         340                               */
 /*        1977        430         520                               */
 /*        1978        550         630                               */
 /*        1979        620         640                               */
 /*                                                                  */
 /*                 .......*****........                             */
 /*                                                                  */
 /*   THE PROGRAM DISPLAYS AN ALPHANUMERIC PANEL REQUESTING          */
 /*   THE FOLLOWING INFORMATION:                                     */
 /*                                                                  */
 /*       1: THE NAME OF THE FILE CONTAINING THE TABLE TO BE         */
 /*          PLOTTED.                                                */
 /*                                                                  */
 /*       2: THE NAME OF A CHART FORMAT TO BE USED FOR THE           */
 /*          PLOT.                                                   */
 /*          (IF AN * IS INSERTED, THE DEFAULT FORMAT IS USED        */
 /*           BY CHART)                                              */
 /*                                                                  */
 /*       3: WHETHER A LINE GRAPH OF A BAR CHART IS TO BE PRODUCED.  */
 /*          IF A LINE GRAPH IS SELECTED, THE X VALUES ARE PASSED    */
 /*          AS NUMERIC DATA (ASSUMING THIS IS POSSIBLE).            */
 /*          THIS TYPE MAY BE USED FOR SURFACE CHARTS AND HISTOGRAMS.*/
 /*          NON-NUMERIC X VALUES CANNOT BE USED ON A LINE GRAPH     */
 /*          SINCE ALPHANUMERIC X LABELS CANNOT BE SPECIFIED FOR     */
 /*          A LINE GRAPH.                                           */
 /*                                                                  */
 /*          IF A BAR CHART IS SELECTED, THE X VALUES ARE PASSED     */
 /*          AS LABELS. THIS FORM IS ALSO SUITABLE FOR PIE CHARTS.   */
 /*                                                                  */
 /*       4: WHETHER THE CHART IS TO BE DISPLAYED OR JUST PRINTED    */
 /*                                                                  */
 /*   ONCE THE PANEL IS COMPLETED (ASSUMING THE INTERRUPT IS         */
 /*   BY A KEY OTHER THAN PF 3), THE DATA FILE IS FETCHED            */
 /*   (IF A NEW ONE IS ENTERED) AND PROVIDED THERE ARE NO ERRORS     */
 /*   THE CHART UTILITY IS CALLED.   THIS IS INSTRUCTED TO PLOT      */
 /*   THE DATA IMMEDIATELY.   THE USER CAN RETURN TO THE INITIAL     */
 /*   PANEL BY USING THE 'EXIT' KEY FROM CHART.  ALTERNATIVELY       */
 /*   HE MAY CHOOSE TO MODIFY THE FORMAT USING THE 'HOME' KEY,       */
 /*   WHEN ALL THE FACILITIES OF CHART ARE AVAILABLE.                */
 /*                                                                  */
 /*                                                                  */
 /*   THE UTILITY IS TERMINATED BY PF 3/15.                          */
 /*                                                                  */
 /********************************************************************/
 DECLARE


   1 ADMTPCS,                     /* PANEL CONTROL STRUCTURE.        */
    2 PCSLEVEL           /* NUMBER IDENTIFYING THE CHART LEVEL USED. */
        FIXED BIN(31)    /* THE LEVEL NUMBER MAY CHANGE WITH FUTURE  */
         INIT(0),        /* RELEASES IF THE CALL PARAMETER FORMAT    */
                         /* CHANGES. MUST BE ZERO.                   */
    2 PCSDISP            /* 0 = THE DATA CONTAINED IN "DATA_CONTROL" */
        FIXED BIN(31)    /*     "X", "Y", "KEYS", "LABELS" AND       */
         INIT(2),        /*     "HEADING" IS SAVED ONTO THE FILE     */
                         /*     INDICATED BY PCSDNAME. NO PANELS ARE */
                         /*     PRESENTED BEFORE RETURNING TO THE    */
                         /*     APPLICATION PROGRAM.                 */
                         /* 1 = THE "HOME" PANEL IS PRESENTED TO THE */
                         /*     OPERATOR.                            */
                         /* 2 = THE DISPLAY PANEL IS PRESENTED TO    */
                         /*     THE OPERATOR USING THE SUPPLIED DATA */
                         /*     AND CHART FORMAT. THE OPERATOR THEN  */
                         /*     HAS THE CHOICE OF THE "HOME" PANEL,  */
                         /*     OR RETURNING TO THE APPLICATION      */
                         /*     PROGRAM.                             */
                         /* 3 = THE DISPLAY PANEL IS PRESENTED TO    */
                         /*     THE OPERATOR USING THE SUPPLIED DATA */
                         /*     AND CHART FORMAT. THE "HOME" PANEL   */
                         /*     IS NOT AVAILABLE, BUT THE "PRINT",   */
                         /*     "HELP" AND "SAVE" FUNCTIONS MAY BE   */
                         /*     AVAILABLE.                           */
                         /* 4 = THE DATA CONTAINED IN "DATA_CONTROL" */
                         /*     "X", "Y", "KEYS", "LABELS" AND       */
                         /*     "HEADING" IS PRINTED (1 COPY).       */
                         /*     RETURN IS MADE DIRECTLY TO THE       */
                         /*     APPLICATION PROGRAM.                 */
    2 PCSHELP            /* 0 = PF KEY ASSIGNMENTS ARE NOT DISPLAYED */
        FIXED BIN(31)    /*     INITIALLY ON THE DISPLAY PANEL. THIS */
           INIT(1),      /*     SETTING MAY BE CHANGED BY USE OF     */
                         /*     ENTER WHENEVER THE DISPLAY PANEL IS  */
                         /*     PRESENTED.                           */
                         /* 1 = PF KEY ASSIGNMENTS ARE DISPLAYED     */
                         /*     INITIALLY ON THE DISPLAY PANEL. THIS */
                         /*     SETTING MAY BE CHANGED BY USE OF     */
                         /*     ENTER WHENEVER THE DISPLAY PANEL IS  */
                         /*     PRESENTED.                           */
                         /* IGNORED IF PCSDISP=0, OR IF PCSDISP=4.   */
    2 PCSISOL            /* 0 = SAVE AND RESTORE MENU PANELS ARE     */
        FIXED BIN(31)    /*     MADE AVAILABLE TO THE OPERATOR.      */
          INIT(0),       /* 1 = SAVE AND RESTORE MENU PANELS ARE NOT */
                         /*     MADE AVAILABLE TO THE OPERATOR.      */
                         /* IGNORED IF PCSDISP=0 OR PCSDISP=4.       */
    2 PCSFNAME CHAR(8)   /* NAME OF PREVIOUSLY SAVED CHART FORMAT TO */
          INIT('*'),     /* BE USED INITIALLY. THE NAME '*' IS       */
                         /* RESERVED TO INDICATE THE DEFAULT CHART   */
                         /* FORMAT. IGNORED IF PCSDISP=0.            */
    2 PCSDNAME CHAR(8)   /* FOR PCSDISP=0, THE NAME UNDER WHICH THE  */
          INIT('*'),     /* CHART DATA CONTAINED IN "DATA_CONTROL",  */
                         /* "X", "Y", "KEYS", "LABELS" AND "HEADING" */
                         /* IS TO BE SAVED.                          */
                         /* FOR PCSDISP¬=0, THE NAME OF A PREVIOUSLY */
                         /* SAVED CHART DATA FILE TO BE USED INIT-   */
                         /* -IALLY OR FOR PRINTING. THE NAME '*'     */
                         /* INDICATES THAT THE DATA CONTAINED IN     */
                         /* "DATA_CONTROL", "X", "Y", "KEYS",        */
                         /* "LABELS" AND "HEADING" IS TO BE USED.    */
    2 PCSPAIR            /* 0 = "X" AND "Y" DATA GROUPS ARE NOT      */
        FIXED BIN(31)    /*     PAIRED. THERE IS ONLY ONE "X" DATA   */
           INIT(0),      /*     GROUP, OR SET OF "LABELS", WHICH IS  */
                         /*     PLOTTED AGAINST EACH "Y" DATA GROUP. */
                         /*     IN THIS MODE OF OPERATION, THERE MAY */
                         /*     BE RESTRICTIONS ON THE NUMBER OF "Y" */
                         /*     DATA GROUPS WHICH CAN BE DISPLAYED   */
                         /*     AT ANY ONE TIME.                     */
                         /* 1 = "X" AND "Y" DATA GROUPS ARE PAIRED.  */
                         /*     FOR EACH "Y" DATA GROUP THERE IS A   */
                         /*     UNIQUE "X" DATA GROUP AGAINST WHICH  */
                         /*     IT IS PLOTTED WHEN SELECTED. IN THIS */
                         /*     MODE OF OPERATION, SOME SHADING      */
                         /*     OPTIONS MAY BE IGNORED WHEN          */
                         /*     DISPLAYED. IF "LABELS" ARE PROVIDED  */
                         /*     INSTEAD OF "X", THEN EACH "Y" DATA   */
                         /*     GROUP IS MATCHED VALUE FOR LABEL     */
                         /*     AGAINST "LABELS" UNTIL THE DATA      */
                         /*     GROUP IS EXHAUSTED.                  */
                         /* IGNORED IF PCSDISP¬=0 AND PCSDNAME¬='*'. */
    2 PCSNC              /* MAXIMUM NO. OF DATA GROUPS. FOR          */
        FIXED BIN(31)    /* PCSPAIR=1, THE NUMBER OF DATA GROUPS FOR */
           INIT(0),      /* WHICH STORAGE IS PROVIDED IN "X" (FOR    */
                         /* PCSLABL=0) AND "Y", AND ALSO THE NO. OF  */
                         /* VALUES IN "DATA_CONTROL". FOR PCSPAIR=0, */
                         /* THE NUMBER OF DATA GROUPS FOR WHICH      */
                         /* STORAGE IS PROVIDED IN "Y". RANGE 0      */
                         /* THROUGH 999.                             */
                         /* IGNORED IF PCSDISP¬=0 AND PCSDNAME¬='*'. */
    2 PCSNE              /* MAXIMUM NO. OF ELEMENTS. THE NUMBER OF   */
        FIXED BIN(31)    /* VALUES (PER DATA GROUP) FOR WHICH        */
           INIT(0),      /* STORAGE IS PROVIDED IN "X" (FOR          */
                         /* PCSLABL=0) AND "Y", AND ALSO THE NO. OF  */
                         /* LABELS IN "LABELS" (FOR PCSLABL¬=0).     */
                         /* RANGE 0 THROUGH 999.                     */
                         /* IGNORED IF PCSDISP¬=0 AND PCSDNAME¬='*'. */
    2 PCSKEYL            /* LENGTH OF EACH STRING IN "KEYS". RANGE 0 */
        FIXED BIN(31)    /* THROUGH 132.                             */
           INIT(0),      /* IGNORED IF PCSDISP¬=0 AND PCSDNAME¬='*', */
                         /* OR IF PCSNC = 0.                         */
    2 PCSLABL            /* LENGTH OF EACH STRING IN "LABELS". RANGE */
        FIXED BIN(31)    /* 0 THROUGH 132.                           */
          INIT(0),       /* IGNORED IF PCSDISP¬=0 AND PCSDNAME¬='*', */
                         /* OR IF PCSNE=0.                           */
    2 PCSHEADL           /* LENGTH OF THE CHART "HEADING". RANGE 0   */
        FIXED BIN(31)    /* THROUGH 132.                             */
          INIT(0),       /* IGNORED IF PCSDISP¬=0 AND PCSDNAME¬='*'. */
    2 PCSPNAME CHAR(8)   /* PRINTER DESTINATION NAME. ' ' INDICATES  */
          INIT('*'),     /* NO PRINTER. '*' INDICATES THAT THE NAME  */
                         /* IS UNKNOWN, IN WHICH CASE THE OPERATOR   */
                         /* IS PROMTED FOR THE NAME AS REQUIRED).    */
                         /* IGNORED IF PCSDISP=0. THESE RESERVED     */
                         /* NAMES ARE NOT VALID FOR PCSDISP=4.       */
    2 PCSPRDEP           /* DEPTH IN ROWS OF THE CHART AREA ON THE   */
        FIXED BIN(31)    /* PRINTER. RANGE 1 THROUGH 132. IGNORED IF */
          INIT(64),      /* PCSDISP=0, OR IF PCSPNAME=' ', OR IF     */
                         /* PCSPNAME='*'.                            */
    2 PCSPRWID           /* WIDTH IN COLUMNS OF THE CHART AREA ON THE*/
        FIXED BIN(31)    /* PRINTER. RANGE 1 THROUGH 132. IGNORED IF */
          INIT(120),     /* PCSDISP=0, OR IF PCSPNAME=' ', OR IF     */
                         /* PCSPNAME='*'.                            */
    2 PCSPCOPY           /* NO. OF COPIES REQUIRED FOR PRINT.        */
        FIXED BIN(31)    /* IGNORED IF PCSDISP¬=4.                   */
          INIT(1);
 /********************************************************************/
 /*     END OF PANEL CONTROL STRUCTURE (PCS) DEFINITION.             */
 /********************************************************************/

1 DECLARE
 /********************************************************************/
 /*                                                                  */
 /*       VARIOUS LOCAL VARIABLES                                    */
 /*                                                                  */
 /********************************************************************/


   END_OF_FILE BIT(1),   /* END OF FILE INDICATOR                    */
   RETCODE FIXED BIN(31),/* RETURN CODE FROM READ/ CLOSE             */
   RETCODE1 FIXED BIN(31),/* RETURN CODE FROM OPEN                   */
   EXIT BIT(1),          /* FLAG USED TO INDICATE EXIT REQUIRED      */
   ONSOURCE BUILTIN,     /* FORCE IT TO BE BUILTIN                   */
   FILE_NAME   CHAR(8)   /* DATA FILE NAME                           */
    INIT('        '),
   PRINTER_NAME CHAR(8)  /* DATA FILE NAME                           */
    INIT('*       '),
   FORMAT_TYPE CHAR(1)   /* '1' IF BAR CHART TYPE FORMAT             */
    INIT('1'),           /* '2' IF LINE GRAPH TYPE FORMAT            */
   OPTION      CHAR(1)   /* '1' IF DISPLAY REQUIRED                  */
    INIT('1'),           /* '2' IF PRINT ONLY REQUIRED               */
   LABELLEN FIXED BIN(15),/* LENGTH OF X LABELS.                     */

                         /* ENTRY POINTS FOR ASSEMBLER I/O ROUTINES  */
   ADMUSP6O ENTRY(CHARACTER(8),
                  FIXED BIN(31)) OPTIONS(INTER ASSEMBLER),
   ADMUSP6C ENTRY (FIXED BIN(31)) OPTIONS(INTER ASSEMBLER),
   ADMUSP6R ENTRY(POINTER,
                   FIXED BIN(31)) OPTIONS(INTER ASSEMBLER),

   ERRPROC  EXTERNAL ENTRY,/*EXTERNAL ERROR HANDLING PROCEDURE       */

   DUMMY POINTER;        /* DUMMY VARIABLE                           */

 DECLARE  (              /* GDDM ENTRY POINTS USED, REENTRANT FORM*/

  ASCGET ENTRY(*,  BIN FIXED(31),BIN FIXED(31),CHAR(*)               ),
  ASCPUT ENTRY(*,  BIN FIXED(31),BIN FIXED(31),*                     ),
  ASDFMT ENTRY(*,  BIN FIXED(31),BIN FIXED(31),(*,*)BIN FIXED(31)    ),
  ASFCUR ENTRY(*,  BIN FIXED(31),BIN FIXED(31),BIN FIXED(31)         ),
  ASDFLT ENTRY(*,  BIN FIXED(31),(*) BIN FIXED(31)                   ),
  ASQMOD ENTRY(*,  BIN FIXED(31),BIN FIXED(31),BIN FIXED(31),
                   BIN FIXED(31)                                     ),
  ASFMOD ENTRY(*,  BIN FIXED(31),BIN FIXED(31)                       ),
  ASREAD ENTRY(*,  BIN FIXED(31),BIN FIXED(31),BIN FIXED(31)         ),

  FSALRM ENTRY(*                                                     ),
  FSINR  ENTRY(*                                                     ),
  FSTERM ENTRY(*                                                     ),
  FSEXIT ENTRY(*,  ENTRY,BIN FIXED(31)                               ),
  CHART  ENTRY(                                                      )
         )OPTIONS(ASM,INTER);

  DECLARE                          /* GDDM ANCHOR BLOCK              */
    1 AB,
       2  AABSC   FIXED BIN(15),   /* SEVERITY CODE                  */
       2  AABEC   FIXED BIN(15),   /* ERROR CODE                     */
       2  AABAP   POINTER,         /* GDDM ANCHOR                    */
       2  MESSAGE CHARACTER(60)    /* MESSAGE TEXT RETURNED FROM     */
            INIT(' ');             /* ERROR PROCEDURE                */
1/********************************************************************/
 /*                                                                  */
 /*       MAIN PROGRAM                                               */
 /*                                                                  */
 /********************************************************************/

   CALL FSINR(AB);       /* INITIALISE GDDM FOR RE-ENTRANT CODE      */
                         /* CAUSE ERRORS TO CALL ERRPROC  AND PLACE  */
   CALL FSEXIT(AB,ERRPROC ,4);
                         /* IF SEVERITY >= WARNING                   */
   CALL SCFORMAT;        /* FORMAT THE SCREEN FOR THE INITIAL PANEL  */
   EXIT = '0'B;          /* INITIALISE EXIT FLAG                     */

   DO UNTIL (EXIT = '1'B); /* REPEAT UNTIL EXIT REQUESTED            */

    CALL SCREAD;         /* FILL IN SCREEN PANEL WITH DEFAULT DATA   */
                         /* AND READ USER'S INPUT.                   */
    IF EXIT = '0'B THEN
     DO;
      IF FORMAT_TYPE = '1' THEN    /* IF BAR CHART TYPE FORMAT       */
        PCSLABL = LABELLEN;        /* THEN SET LABEL LENGTH          */
      ELSE                         /* OTHERWISE                      */
        PCSLABL = 0;               /* SET 0 SO THAT X DATA IS USED.  */

    IF PCSDISP = 4 & PRINTER_NAME = '*' THEN
       PCSPNAME = FILE_NAME;       /* SET PRINTER NAME TO THE SAME   */
    ELSE                          /*  AS THE DATA FILE NAME IF IT    */
       PCSPNAME = PRINTER_NAME;   /*  IS NOT SPECIFIED AND NEEDED.   */
                                  /*  THIS IS SENSIBLE ON CMS ONLY - */
                                  /*  BUT FOR TSO IT DOES NOT CAUSE  */
                                  /*  ANY PROBLEMS EXCEPT THAT       */
                                  /*  THE WRONG DIAGNOSTIC IS        */
                                  /*  GENERATED.                     */
                                  /*  OTHERWISE SET AS GIVEN.        */
      CALL CHART(AB,              /* CALL CHART UTILITY WITH RESULT. */
                ADMTPCS,          /* CONTROL STRUCTURE.              */
                DATA_CONTROL,     /* DATA CONTROL VECTOR (NONE).     */
                XDATA,            /* X DATA                          */
                YDATA,            /* Y DATA                          */
                KEYS,             /* KEYS                            */
                XLABELS,          /* DATA LABELS                     */
                HEADING);         /* HEADING                         */
     END;                         /* OF CHART CALL                   */
   END;                  /* OF MAIN LOOP                             */

   CALL FSTERM(AB);      /* TERMINATE GDDM                           */
1DECLARE  (                      /* INPUT FIELD IDENTIFIERS:         */
    DATAF INIT(1),                 /* INPUT FIELD NAME FOR PLOT DATA */
    FORMF INIT(2),                 /* INPUT FIELD NAME FOR CHART FMT */
    FTYPF INIT(3),                 /* INPUT FIELD FOR FORMAT TYPE    */
    HEADF INIT(20),                /* OUTPUT ONLY FIELD FOR HEADING  */
    FOOTF INIT(21),                /* OUTPUT ONLY FIELD FOR FOOTING  */
    MSGF  INIT(22),                /* OUTPUT ONLY FIELD FOR MESSAGE  */
    OPTF  INIT(23),                /* FIELD FOR FUNCTION OPTIONS     */
    PRTF  INIT(24)                 /* FIELD FOR PRINTER NAME         */
           ) FIXED BIN(31) STATIC;
 SCFORMAT:PROCEDURE;
   /******************************************************************/
   /*                                                                */
   /*       FORMAT THE SCREEN TO CONTAIN FIELDS CONTAINING:          */
   /*                                                                */
   /*             1 THE NAME OF FILE TO BE PLOTTED                   */
   /*             2 THE NAME OF THE CHART FORMAT                     */
   /*             3 THE TYPE OF THE CHART FORMAT                     */
   /*                                                                */
   /*                                                                */
   /******************************************************************/

   /******************************************************************/
   /*    DEFINE THE DEFAULT ATTRIBUTES                               */
   /******************************************************************/
   DECLARE
    DFLTS(9) FIXED BIN(31) STATIC INIT
      ( /* FIELD TYPE */  0,  /* INPUT OUTPUT */
        /* INTENSITY  */  0,  /* NORMAL       */
        /* COLOUR     */  0,  /* MONOCHROME   */
        /* SYMBOL SET */  0,  /* STANDARD     */
        /* HIGHLIGHT  */  0,  /* NORMAL       */
        /* END ATTR.  */  0,  /* AUTOSKIP     */
        /* NULLS OUT  */  0,  /* NO           */
        /* BLANKS IN  */  2,  /* YES          */
        /* TRANSLATION*/  1   /* UPPER CASE   */ );
   /******************************************************************/
   /*    DEFINE THE SCREEN FORMAT ARRAY                              */
   /******************************************************************/
   DECLARE
    FORMAT(22,8) FIXED BIN(31)
     INIT(
    /* FIELD-ID, ROW ,COLUMN, DEPTH , WIDTH, TYPE , INTENSITY,COLOUR */
       HEADF   ,  1  ,  30  ,   1   ,  20  ,  2   ,    2     ,   7  ,
       FOOTF   ,  20 ,  30  ,   1   ,  20  ,  2   ,    2     ,   7  ,
       MSGF    ,  2  ,  10  ,   1   ,  60  ,  2   ,    2     ,   2  ,
       101     ,  9  ,  20  ,   1   ,  19  ,  2   ,    1     ,   1  ,
       102     ,  10 ,  20  ,   1   ,  19  ,  2   ,    1     ,   1  ,
       103     ,  12 ,  20  ,   1   ,  19  ,  2   ,    1     ,   1  ,
       106     ,  12 ,  50  ,   1   ,  19  ,  2   ,    1     ,   1  ,
       107     ,  13 ,  50  ,   1   ,  19  ,  2   ,    1     ,   1  ,
       108     ,  3  ,  20  ,   1   ,  19  ,  2   ,    1     ,   1  ,
       109     ,  3  ,  50  ,   1   ,  19  ,  2   ,    1     ,   1  ,
       110     ,  4  ,  50  ,   1   ,  19  ,  2   ,    1     ,   1  ,
       111     , 15  ,  20  ,   1   ,  19  ,  2   ,    1     ,   1  ,
       112     , 15  ,  50  ,   1   ,  19  ,  2   ,    1     ,   1  ,
       113     ,  10 ,  50  ,   1   ,  19  ,  2   ,    1     ,   1  ,
       115     ,   5 ,  50  ,   1   ,  19  ,  2   ,    1     ,   1  ,
       116     ,   6 ,  50  ,   1   ,  19  ,  2   ,    1     ,   1  ,
       117     ,   7 ,  50  ,   1   ,  19  ,  2   ,    1     ,   1  ,
       DATAF   ,  9  ,  40  ,   1   ,   8  ,  0   ,    1     ,   4  ,
       FORMF   ,  10 ,  40  ,   1   ,   8  ,  0   ,    1     ,   4  ,
       FTYPF   ,  12 ,  40  ,   1   ,   1  ,  1   ,    1     ,   4  ,
       OPTF    ,  3  ,  40  ,   1   ,   1  ,  1   ,    1     ,   4  ,
       PRTF    , 15  ,  40  ,   1   ,   8  ,  0   ,    1     ,   4  ),

   /******************************************************************/
   /*    DEFINE STATIC CONTENT OF FIELDS                             */
   /******************************************************************/
    1 CONTENT,

     2 FIELD(16) FIXED BIN(31)  INIT    /* FIELD IDENTIFIERS          */
     (HEADF,101,102,103,106,107,108,109,110,111,112,113,
                                            115,116,117,FOOTF),

     2 VALUE(16)  CHAR(19)         INIT /* CONSTANT CONTENTS          */
      ( 'CHART IMPORT PANEL ',   /* HEADF*/
        'CHART NAME      ==>',   /* 101  */
        'FORMAT NAME     ==>',   /* 102  */
        'X-DATA TYPE     ==>',   /* 103  */
        '1- CHARACTER LABELS',   /* 106  */
        '2- NUMERIC VALUES  ',   /* 107  */
        'SELECT OPTION   ==>',   /* 108  */
        '1-SHOW IMPORT CHART',   /* 109  */
        '2-PRINT IMPORT ONLY',   /* 110  */
        'PRINTER NAME    ==>',   /* 111  */
        '(FOR OPTION 2)     ',   /* 112  */
        '(ENTER NAME OR *)  ',   /* 113  */
        '3-LOAD IMPORT CHART',   /* 115  */
        '4-LOAD SAVED CHART ',   /* 116  */
        '5-SHOW SAVED CHART ',   /* 117  */
        'USE PF 3/15 TO EXIT');    /* FOOTF*/

   /******************************************************************/
   /*    FORMAT THE SCREEN AND FILL IN CONSTANT DATA -               */
   /*            HEADINGS AND FIELD DESCRIPTORS                      */
   /******************************************************************/

                                   /*     SET DEFAULTS               */
   CALL ASDFLT(AB,HBOUND(DFLTS,1),DFLTS);
   CALL ASDFMT(AB,HBOUND(FORMAT,1),HBOUND(FORMAT,2),FORMAT);


   DO I = 1 TO HBOUND(FIELD,1);    /* DO ALL CONTENT ARRAY -         */
     CALL ASCPUT(AB,FIELD(I),      /*   FIELD   ID                   */
                 LENGTH(VALUE(I)), /*   LENGTH OF STRING             */
                 VALUE(I));        /*   INITIAL STRING               */
   END;
 END;                              /* OF SCREEN FORMAT PROCEDURE     */
1SCREAD:PROCEDURE;
   /******************************************************************/
   /*                                                                */
   /*       THIS PROCEDURE INITIALISES THE PREPARED SCREEN PANEL     */
   /*       FROM THE DEFAULT DATA IN THE STRUCTURE ADMPCS            */
   /*       DISPLAYS IT TO THE TERMINAL OPERATOR AND READS           */
   /*       ANY MODIFICATIONS HE MAKES.   IF AN ERROR IS             */
   /*       DETECTED, THE MESSAGE IS DISPLAYED AND NEW INPUT         */
   /*       IS AWAITED.  THE CYCLE IS REPEATED UNTIL THERE ARE       */
   /*       NO DETECTED ERRORS.                                      */
   /*                                                                */
   /******************************************************************/

  DECLARE                /* LOCAL  VARIABLES                         */
   PICZ9 PICTURE 'Z9',   /* PICTURE USED AS FORMAT FOR NUMERIC OUTPUT*/
   CHARS CHAR(2),        /* TEMPORARY USED FOR NUMNERIC INPUT        */
   ATTYPE FIXED BIN(31), /* TYPE OF KEY USED TO CAUSE INTERRUPT      */
   ATMOD  FIXED BIN(31), /* KEY NUMBER USED                          */
   COUNT  FIXED BIN(31), /* COUNT OF MODIFIED FIELDS                 */
   FIELD_ID FIXED BIN(31),/* FIELD NUMBER MODIFIED BY THE USER       */
   LEN1   FIXED BIN(31), /* LENGTH  RETURNED BY QMOD (NOT USED)      */
   LEN2   FIXED BIN(31); /* NON NULL LENGTH RETURNED BY QMOD         */

   DO UNTIL(MESSAGE = '');         /* DO UNTIL THERE IS AGAIN NO MSG */

   /******************************************************************/
   /*       ADD VARYING SCREEN DATA FROM THE DATA IN ADMTPCS         */
   /*       AS DEFAULTS FOR THE USER.                                */
   /******************************************************************/

    CALL ASCPUT(AB,DATAF,8,FILE_NAME);/*  THE FILE NAME              */

    CALL ASCPUT(AB,FORMF,8,PCSFNAME); /*  THE FORMAT NAME            */

    CALL ASCPUT(AB,FTYPF,1,FORMAT_TYPE);/* THE FORMAT TYPE           */

    CALL ASCPUT(AB,OPTF,1,OPTION); /* INSERT THE SELECTED OPTION     */

    CALL ASCPUT(AB,PRTF,8,PRINTER_NAME);/* INSERT PRINTER NAME       */


                                   /*  INSERT ANY MESSAGE IN THE     */
                                   /*  MESSAGE LINE.                 */
   CALL ASCPUT(AB,MSGF,LENGTH(MESSAGE),MESSAGE);

   IF MESSAGE ¬= '' THEN            /* THERE WAS AN ERROR -          */
      CALL FSALRM(AB);              /* RING THE ALARM                */

   MESSAGE = '';                    /* THEN CLEAR MSG FOR NEXT TIME  */
1  /******************************************************************/
   /*                                                                */
   /*       READ THE SCREEN , EXTRACT THE DATA AND TAKE APPROPRIATE  */
   /*       ACTION:                                                  */
   /*             1 THE NAME OF DATA FILE.                           */
   /*                - READ THE FILE                                 */
   /*             2 THE NAME OF THE CHART FORMAT                     */
   /*             3 THE TYPE OF THE CHART FORMAT                     */
   /*                - CONVERT X DATA TO CORRECT TYPE                */
   /*             4 THE WIDTH OF THE PRINTOUT                        */
   /*             5 THE DEPTH OF THE PRINTOUT                        */
   /*                                                                */
   /******************************************************************/

   CALL ASFCUR(AB,DATAF,1,1);     /* POSITION THE CURSOR ON FILE     */
   CALL ASREAD(AB,ATTYPE,ATMOD,COUNT);/* AND READ THE SCREEN.        */

   IF (ATTYPE = 1) & (ATMOD = 3 | ATMOD = 15) THEN
      EXIT= '1'B;                  /* PF 3/15 WAS USED, INDICATE EXIT*/
   ELSE                            /* PF 3/15 NOT USED:              */
    DO;                            /* PROCESS INPUT FIELDS:          */
      DO UNTIL(FIELD_ID = 0);      /* UNTIL ALL FIELDS PROCESSED     */
                                   /* EXTRACT NEXT MODIFIED FIELD    */
                                   /* INTO FIELD_ID.                 */
       CALL ASQMOD(AB,1,FIELD_ID,LEN1,LEN2);

       /**************************************************************/
       /*    FIELD_ID NOW CONTAINS A FIELD NUMBER MODIFIED BY THE    */
       /*    USER.  TEST WHICH ONE IT IS AND TAKE APPROPRIATE        */
       /*    ACTION.                                                 */
       /**************************************************************/
       IF FIELD_ID = DATAF THEN
        DO;                        /* EXTRACT THE DATA NAME FROM THE */
         CALL ASCGET(AB,DATAF,8,FILE_NAME);
         IF OPTION < 4 THEN                         /*       WDPSC   */
         CALL GET_FILE;            /* PANEL AND FETCH IN THE DATA    */
        END;

       IF FIELD_ID = FORMF THEN
        DO;                        /* EXTRACT THE FORMAT             */
         CALL ASCGET(AB,FORMF,8,PCSFNAME);
        END;

       IF FIELD_ID = FTYPF THEN
        DO;                        /* EXTRACT THE FORMAT TYPE        */
         CALL ASCGET(AB,FTYPF,1,FORMAT_TYPE);
        END;


       IF FIELD_ID = OPTF THEN
        DO;                        /* EXTRACT THE OPTION             */
         CALL ASCGET(AB,OPTF,1,OPTION);
        END;


       IF FIELD_ID = PRTF THEN
        DO;                        /* EXTRACT THE PRINTER NAME       */
         CALL ASCGET(AB,PRTF,8,PRINTER_NAME);
        END;



     END;                           /* OF FIELD PROCESSING LOOP      */
    /*****************************************************************/
    /*       TEST IF NUMERIC X DATA FORMAT IS REQUESTED AND IF SO    */
    /*       WHETHER DATA HAS BEEN MARKED SUITABLE.                  */
    /*****************************************************************/
    IF (FORMAT_TYPE = '2') & (XNUMERIC = '0'B) THEN
     DO;                           /* IMPROPER REQUEST, DIAGNOSE:    */
      IF  MESSAGE = ''  THEN
         MESSAGE = 'X DATA NOT NUMERIC';
      CALL ASFMOD(AB,FTYPF,1);     /* SET FIELD MODIFIED, SO IT      */
     END;                          /* MUST BE MODIFIED               */

    IF (FORMAT_TYPE ¬= '1') & (FORMAT_TYPE ¬= '2') THEN
     DO;                           /* IMPROPER REQUEST, DIAGNOSE:    */
      IF  MESSAGE = ''  THEN
         MESSAGE = 'X DATA TYPE MUST BE 1 OR 2';
      CALL ASFMOD(AB,FTYPF,1);     /* SET FIELD MODIFIED, SO IT      */
     END;                          /* MUST BE CORRECTED              */

    PCSDNAME = '*';

    IF OPTION = '1' THEN           /* IF OPTION 1 SELECTED, DISPLAY  */
      PCSDISP = 2;                 /* THE CHART                      */
    ELSE
     IF OPTION = '2' THEN          /* IF OPTION 2 SELECTED, PRINT    */
       PCSDISP = 4;                /* ONLY.                          */
    ELSE
     IF OPTION = '3' THEN          /* IF OPTION 3 SELECTED, LOAD     */
       PCSDISP = 1;                /* ONLY.                          */
    ELSE
     IF OPTION = '4' THEN          /* IF OPTION 4 SELECTED, LOAD     */
       DO;
       PCSDISP = 1;                /* ONLY.                          */
       PCSDNAME = FILE_NAME;
       END;
    ELSE
     IF OPTION = '5' THEN          /* IF OPTION 2 SELECTED, PRINT    */
       DO;
       PCSDISP = 2;                /* ONLY.                          */
       PCSDNAME = FILE_NAME;
       END;
    ELSE
     DO;                           /* OPTION INVALID  , DIAGNOSE:    */
      IF  MESSAGE = ''  THEN
         MESSAGE = 'OPTION MUST BE 1 THROUGH 5';
      CALL ASFMOD(AB,OPTF,1);      /* SET FIELD MODIFIED             */
     END;
   END;                            /* OF GET DATA LOOP               */
  END;                             /* OF DATA EXTRACTION             */
 END;                              /* OF SCREEN READ PROCEDURE       */
1DECLARE
  HEADING CHAR(132),               /* STRING OF CHARACTERS FORMING   */
                                   /* THE HEADING.                   */
  HEADLEN FIXED BIN(31),           /* LENGTH OF HEADING              */
  XINDEX FIXED BIN(15),            /* LAST POSITION USED IN XDATA    */
  YINDEX FIXED BIN(15),            /* LAST POSITION USED IN YDATA    */
  XLABELS CHAR(15000),             /* STRING CONTAINING X LABELS     */
  XNUMERIC BIT(1),                 /* INDICATES X IS ENTIRELY NUMERIC*/
  NOFILE   BIT(1),                 /* INDICATES NO FILE FOUND        */
  XDATA(6000) FLOAT,               /* ARRAY CONTAINING X DATA        */
  YDATA(6000) FLOAT,               /* ARRAY CONTAINING Y DATA        */
  DATA_CONTROL(100) FIXED BIN(31), /* ARRAY CONTAINING NE VALS       */
  COLUMNS  FIXED BIN(15),          /* NUMBER OF DATA COLUMNS WANTED  */
  ROWS     FIXED BIN(15),          /* NUMBER OF DATA ROWS FOUND      */
  KEYS CHAR(400),                  /* STRING OF CHARACTERS CONTAINING*/
                                   /* THE KEYS.  CONTAINS ALL KEYS   */
                                   /* CONCATENATED TOGETHER.         */
  KEYLEN FIXED BIN(15),            /* LENGTH OF EACH KEY.            */
                                   /* (NUMBER IS GIVEN BY COLUMNS)   */
  KEYCOUNT FIXED BIN(15),          /* COUNT OF KEYS DISCOVERED       */

  CURRENT_TOKEN CHARACTER(32) VARYING,/* CURRENT INPUT TOKEN         */
  INREC CHARACTER(32767)           /* CURRENT INPUT RECORD           */
         VARYING BASED(RECPTR),    /*   WDPSC      */
  CHARINDEX FIXED BIN(15);         /* INDEX TO CURRENT POSITION      */
                                   /*  IN INPUT RECORD               */




1GET_FILE: PROCEDURE;

 /********************************************************************/
 /*  READS THE INPUT FILE.                                           */
 /*        THIS CONSISTS OF:                                         */
 /*           THE HEADING CARD (CONTAINING THE PLOT TITLE)           */
 /*           THE KEYS CARD    (CONTAINING THE DATA DESCRIPTIONS)    */
 /*           DATA CARDS       (CONTAINING THE X AND Y DATA)         */
 /*                                                                  */
 /*  IT SETS (SOMETIMES BY SUBROUTINES):                             */
 /*                                                                  */
 /*  HEADING TO THE HEADING TEXT,  HEADLEN TO THE HEADING LENGTH     */
 /*  KEYS    TO THE KEY     TEXT,  KEYLEN  TO THE KEY     LENGTH     */
 /*  ROWS  TO THE NUMBER OF ROWS OF INPUT DATA.                      */
 /*  COLUMNS TO THE NUMBER OF COLUMNS (COMPONENTS+1)                 */
 /*  XLABELS TO THE XDATA LABELS,  YDATA TO THE YDATA VALUES         */
 /*  XDATA   TO THE XDATA VALUES IF THEY ARE NUMERIC.                */
 /*  XNUMERIC INDICATES THIS HAS BEEN DONE.                          */
 /********************************************************************/
   CALL ADMUSP6O(FILE_NAME,RETCODE1);/* OPEN THE INPUT FILE          */
   IF RETCODE1 = 4 THEN           /* CHECK ITS EXISTENCE            */
     MESSAGE = 'DATA FILE NOT FOUND';
   IF RETCODE1 = 8 THEN           /* CHECK ITS EXISTENCE            */
     MESSAGE = 'DATA FILE OPEN ERROR';

   IF MESSAGE = '' THEN            /* IF NO ERROR                    */
     CALL GET_HEAD;                /* READ IN HEADING DATA           */

   IF MESSAGE = '' THEN            /* IF NO ERROR                    */
     CALL GET_KEYS;                /* READ IN THE KEY DATA           */

   COLUMNS = KEYCOUNT+1;           /* THERE IS ONE COLUMN FOR EACH   */
                                   /* KEY GIVEN PLUS ONE FOR XDATA   */
   IF MESSAGE = '' THEN            /* IF NO ERROR                    */
     CALL GET_MATRIX;              /* READ IN THE INPUT MATRIX       */

   IF MESSAGE = '' THEN            /* IF ALL WENT WELL:              */
    DO;                            /* RECORD THE DATA IN CHART       */
                                   /* CONTROL STRUCTURE.             */
  IF NG > 0 THEN DO;
     PCSNE = MAXNE;                /* SET NUMBER OF ELEMENTS         */
     PCSNC = NG   ;                /* SET NUMBER OF COMPONENTS       */
                 END;
            ELSE DO;
     PCSNE = ROWS;                 /* SET NUMBER OF ELEMENTS         */
     PCSNC = KEYCOUNT;             /* SET NUMBER OF COMPONENTS       */
                 END;
     PCSHEADL = HEADLEN;           /* HEADING LENGTH                 */
     PCSKEYL =  KEYLEN;            /* KEY ITEM LENGTH                */
     PCSLABL =  LABELLEN;          /* LABEL LENGTH                   */
    END;
   ELSE
    DO;                            /* IF THERE IS A MESSAGE FROM     */
     PCSNE = 0;                    /* THE FILE FETCH, SET THE ROWS   */
     PCSNC = 0;                    /* AND COLUMNS TO ZERO.           */
    END;                           /* (CAN CALL CHART WITH NO DATA)  */

   IF RETCODE1 < 4 THEN
      CALL ADMUSP6C(RETCODE);      /* CLOSE THE INPUT FILE           */
 END;                              /* OF GET FILE PROCEDURE          */


1GET_HEAD: PROCEDURE;

 /********************************************************************/
 /*  READS A SINGLE INPUT RECORD CONTAINING THE HEADING TEXT.        */
 /*  LEADING AND TRAILING BLANKS ARE IGNORED.                        */
 /*   - SETS HEADING TO THE TEXT, HEADLEN TO THE LENGTH.             */
 /********************************************************************/

  CALL ADMUSP6R(RECPTR,RETCODE);   /* FETCH THE HEADING RECORD       */
  IF RETCODE > 0 THEN              /* IF RETURN CODE NON ZERO,       */
    DO;                            /* DIAGNOSE -                     */
      IF RETCODE = 4 THEN
        MESSAGE = 'NO HEADING RECORD';
      ELSE
        MESSAGE = 'ERROR READING FILE';
    END;
  ELSE                             /* OK, RECORD FETCHED             */
   DO;                             /* THERE IS A RECORD THERE:       */
    CHARINDEX = 1;                 /* SET INITIAL POSITION           */

    /*****************************************************************/
    /*  SCAN OVER ANY INITIAL BLANKS                                 */
    /*****************************************************************/
    DO WHILE ((SUBSTR(INREC,CHARINDEX,1) = ' ')
         & (CHARINDEX ¬> LENGTH(INREC)));
      CHARINDEX = CHARINDEX + 1;
    END;

    /*****************************************************************/
    /*  SET HEADING LENGTH, ASSUMING THERE ARE NO TRAILING BLANKS    */
    /*****************************************************************/
    HEADLEN = LENGTH(INREC) - CHARINDEX + 1;

    /*****************************************************************/
    /*   EITHER INPUT CHARACTER IS NON BLANK OR CHARINDEX            */
    /*   IS GREATER THAN THE INPUT RECORD LENGTH.                    */
    /*    - IN FORMER CASE, SCAN BACKWARDS FROM END OF RECORD.       */
    /*****************************************************************/

    IF CHARINDEX ¬> LENGTH(INREC) THEN

      /***************************************************************/
      /*   REDUCE HEADLEN UNTIL THE LAST CHARACTER IS NOT A BLANK.   */
      /***************************************************************/

      DO WHILE (SUBSTR(INREC,CHARINDEX+HEADLEN-1,1) = ' ');
        HEADLEN = HEADLEN -1;
      END;

    /*****************************************************************/
    /*   MOVE HEADING INTO RESERVED SPACE.                           */
    /*****************************************************************/
    HEADING = SUBSTR(INREC,CHARINDEX,HEADLEN);
   END;
 END;                              /* OF GET HEADING PROCEDURE       */
1GET_KEYS: PROCEDURE;

 /********************************************************************/
 /*  READS THE TOKENS FROM A SINGLE INPUT RECORD FOR THE KEY DATA.   */
 /*  EACH TOKEN IS A KEY AND THERE SHOULD BE THE SAME NUMBER OF Y    */
 /*  DATA COLUMNS.                                                   */
 /********************************************************************/


  KEYLEN = 0;                      /* INITIALISE KEY LENGTH          */
  KEYCOUNT = 0;                    /* AND NUMBER OF KEYS             */
  CHARINDEX = 1;                   /* INITIALISE CHARACTER INDEX     */

  CALL ADMUSP6R(RECPTR,RETCODE);   /* FETCH THE KEY RECORD           */
  IF RETCODE > 0 THEN              /* IF NON ZERO RETURN */
    DO;                            /* DIAGNOSE -                     */
      IF RETCODE = 4 THEN
        MESSAGE = 'NO KEY DATA SUPPLIED';
      ELSE
        MESSAGE = 'ERROR READING FILE';
    END;
  ELSE                             /* OK, RECORD FETCHED             */
   DO UNTIL(CURRENT_TOKEN = '');   /* UNTIL END OF KEYS              */

     CALL GET_TOKEN;               /* GET THE KEY                    */
     IF CURRENT_TOKEN ¬= '' THEN   /* IF IT IS A REAL ONE:           */
                                   /* APPEND IT TO THE KEY LIST      */
       CALL APPEND(KEYS,KEYCOUNT,KEYLEN,CURRENT_TOKEN);
   END;                            /* OF KEY FETCH LOOP              */
 END;                              /* OF GET KEYS PROCEDURE         */
1GET_MATRIX:PROCEDURE;

 /********************************************************************/
 /*  READS THE RECTANGULAR DATA ARRAY FROM THE INPUT FILE.           */
 /*     EACH CARD CONTAINS 1 ROW OF DATA, THAT IS ONE X VALUE        */
 /*     AND COLUMNS Y VALUES.                                        */
 /*  THE X VALUES MAY BE NUMERIC OR ALPHANUMERIC.  THE Y VALUES      */
 /*  MUST BE NUMERIC.                                                */
 /*  AN ALPHANUMERIC VALUE MAY BE ANY TOKEN.  A NUMERIC VALUE        */
 /*  MAY BE ANY TOKEN WHICH PL/I WILL CONVERT TO FLOAT.              */
 /********************************************************************/
  DECLARE
    I  FIXED BIN(15);              /* LOCAL INDEX                    */

  XINDEX = 0;                      /* INITIALISE THE ROW INDEX       */
  ALLROWS = 0;
  YINDEX = 0;                      /* THE INDEX TO YDATA             */
  NG = 0;
  MAXNE = 0;
  ROWS   = 0;                      /* COUNT OF MATRIX ROWS           */
  LABELLEN = 0;                    /* AND LENGTH OF X LABELS         */

  ON CONVERSION                    /* IF THERE IS A CONVERSION ERROR */
    BEGIN;                         /* IN THE DATA EXTRACTION, REPLACE*/
      ONSOURCE = '0';              /* WITH 0 AND DIAGNOSE            */
      MESSAGE = 'NON NUMERIC Y VALUE FOUND IN DATA';
    END;

  END_OF_FILE = '0'B;
  DO WHILE(END_OF_FILE = '0'B      /* WHILE THERE IS MORE DATA       */
         & MESSAGE = '');          /* AND NO ERROR IS FOUND.         */

    CALL ADMUSP6R(RECPTR,RETCODE);    /* FETCH NEXT INPUT RECORD     */
    IF RETCODE  > 0 THEN              /* IF NON ZERO RETURN          */
      DO;                             /* DIAGNOSE -                  */
       IF RETCODE = 4 THEN DO;
         END_OF_FILE = '1'B;
         DATA_CONTROL(NG) = ROWS;
         IF ROWS > MAXNE THEN MAXNE = ROWS;
                           END;
       ELSE
         MESSAGE = 'ERROR READING FILE';
      END;
    ELSE                            /* OK, RECORD FETCHED             */
     DO;
      CALL GET_TUPLE;              /* EXTRACT MATRIX ROW             */
      ROWS = ROWS + 1;             /* AND COUNT THE NUMBER OF ROWS   */
     END;

  END;                             /* OF RECORD LOOP                 */

 IF NG =  0 THEN DO;
   PCSPAIR = 0;
   CALL TRANSPOSE(YDATA,ROWS,COLUMNS-1); /*TRANSPOSE THE Y MATRIX   */
                 END;
            ELSE PCSPAIR = 1;
 /********************************************************************/
 /*   ATTEMPT TO CONVERT THE XLABELS TO NUMERIC DATA                 */
 /*   IN XDATA.                                                      */
 /********************************************************************/

  ON CONVERSION
    BEGIN;                         /* IF A CONVERSION ERROR OCCURS,  */
      XNUMERIC = '0';              /* SET FLAG TO NON NUMERIC        */
      GOTO DONE;                   /* AND STOP PROCESSING            */
    END;

  XNUMERIC = '1'B;               /* ASSUME IT WILL WORK SUCCESSFULLY */
  DO I = 0 TO ALLROWS-1;         /* PROCESS ALL XLABELS              */
                                 /* CONVERTING THEM TO NUMERIC       */
    XDATA(I+1) = SUBSTR(XLABELS,I*LABELLEN+1,LABELLEN);
  END;
 DONE:                           /* PROCESSING FINISHED              */
  REVERT CONVERSION;
 END;                            /* OF GET MATRIX PROCEDURE          */
1GET_TUPLE: PROCEDURE;

 /********************************************************************/
 /*  READS A MATRIX ROW FROM A SINGLE INPUT RECORD.                  */
 /*  THE FIRST TOKEN ON THE CARD IS THE XLABEL AND IS CONCATENATED   */
 /*  INTO THE XLABEL ARRAY.   THE REMAINING TOKENS ARE CONVERTED     */
 /*  TO NUMERIC AND PLACED IN THE YDATA ARRAY.                       */
 /*  THE NUMBER OF ITEMS EXPECTED  IS  THE VARIABLE COLUMNS.         */
 /********************************************************************/
  DCL I FIXED BIN(15);             /* INDEX TO ITEMS FETCHED         */

  CHARINDEX = 1;                   /* INITIALISE CHARACTER POINTER   */
 /********************************************************************/
 /*  FIRST DO THE FIRST COLUMN, WHICH GOES INTO XLABELS.             */
 /********************************************************************/
  IF XINDEX+1 > HBOUND(XDATA,1) THEN /* CHECK WHETHER TOO MANY ITEMS.*/
   MESSAGE = 'TOO MANY DATA ITEMS';/* AND IF SO DIAGNOSE IT.         */

  CALL GET_TOKEN;                  /* GET THE ITEM                   */
  IF (CURRENT_TOKEN = '=NG') | (CURRENT_TOKEN = '=ng') THEN DO;
     CALL GET_TOKEN;               /* GET THE KEY                    */
     IF CURRENT_TOKEN ¬= '' THEN   /* IF IT IS A REAL ONE:           */
                                   /* APPEND IT TO THE KEY LIST      */
       CALL APPEND(KEYS,KEYCOUNT,KEYLEN,CURRENT_TOKEN);
     DATA_CONTROL(NG) = ROWS;
     NG = NG + 1 ;
     IF ROWS > MAXNE THEN MAXNE = ROWS;
     ROWS = -1;
     COLUMNS = 2;
                                END;
                           ELSE DO;
     ALLROWS = ALLROWS + 1;

  IF XINDEX <= HBOUND(XDATA,1) THEN/* PROVIDED IT WILL FIT THE ARRAY */
                                   /* APPEND TOKEN TO LABEL LIST     */
    CALL APPEND(XLABELS,XINDEX,LABELLEN,CURRENT_TOKEN);

 /********************************************************************/
 /*  THEN DO THE REMAINING COLUMNS WHICH GO INTO YARRAY.             */
 /********************************************************************/

  DO I = 2 TO COLUMNS;             /* FOR ALL COLUMNS EXPECTED,      */

   YINDEX = YINDEX + 1;            /* INCREMENT YINDEX FOR NEXT SLOT */
   IF YINDEX > HBOUND(YDATA,1) THEN /*CHECK WHETHER TOO MANY ITEMS.  */
    MESSAGE = 'TOO MANY DATA ITEMS';/*AND ASSIGN IT INTO YDATA ARRAY */

   CALL GET_TOKEN;                 /* GET THE ITEM                   */
   IF YINDEX <= HBOUND(YDATA,1)    /* PROVIDED IT WILL FIT THE ARRAY */
   THEN
    YDATA(YINDEX) = CURRENT_TOKEN; /* ASSIGN IT IN (MAY NOT CONVERT) */

  END;                             /* OF Y VALUE EXTRACTION          */
                                END;
 END;                              /* OF GET TUPLE PROCEDURE         */

1GET_TOKEN: PROCEDURE;

 /********************************************************************/
 /*  READS A SINGLE TOKEN FROM THE INPUT RECORD AND PLACES           */
 /*  IT IN CURRENT_TOKEN.                                            */
 /*  A TOKEN IS EITHER:                                              */
 /*     AS SERIES OF UP TO 32 ALPHANUMERIC CHARACTERS WITHOUT        */
 /*      IMBEDDED BLANKS.                                            */
 /*  OR A NULL STRING   (INDICATING NO INPUT).                       */
 /*   IF AN _ CHARACTER IS FOUND IT IS CHANGED TO A BLANK            */
 /********************************************************************/

 DECLARE
   TOKEN_START FIXED BIN(15);      /* INDEX OF FIRST CHARACTER       */
                                   /* IN THE TOKEN                   */
 /********************************************************************/
 /*  SCAN OVER ANY INITIAL BLANKS                                    */
 /********************************************************************/
 DO WHILE ((SUBSTR(INREC,CHARINDEX,1) = ' ')
         & (CHARINDEX ¬> LENGTH(INREC)));
   CHARINDEX = CHARINDEX + 1;
 END;
 /********************************************************************/
 /*  NOW EITHER INPUT CHARACTER IS NON BLANK OR CHARINDEX            */
 /*  IS GREATER THAN THE INPUT RECORD LENGTH.                        */
 /*    - IN FORMER CASE, SCAN TO NEXT BLANK.                         */
 /********************************************************************/
 IF CHARINDEX ¬> LENGTH(INREC) THEN
  DO;                              /* THE INPUT POSITION IS VALID    */
    TOKEN_START = CHARINDEX;       /* NOTE TOKEN START               */
                                   /* SCAN TO THE END OF THE TOKEN   */
                                   /* IE TO NEXT NON BLANK           */
    DO WHILE ((SUBSTR(INREC,CHARINDEX,1) ¬= ' ')
             & (CHARINDEX ¬> LENGTH(INREC)));
                    /* REPLACE ANY  _ BY BLANK */
      IF SUBSTR(INREC,CHARINDEX,1)  = '_' THEN
         SUBSTR(INREC,CHARINDEX,1)  = ' ';
      CHARINDEX = CHARINDEX + 1;
    END;
                                   /* COPY TOKEN TO CURRENT_TOKEN    */
    CURRENT_TOKEN = SUBSTR(INREC,TOKEN_START,CHARINDEX-TOKEN_START);
  END;
 ELSE                              /* INPUT POSITION INVALID,        */
    CURRENT_TOKEN = '';            /* SET CURRENT TOKEN TO NULL      */
 END;                              /* OF GET TOKEN PROCEDURE         */
1APPEND:PROCEDURE(STRING_ARRAY,ITEMS,STRING_LENGTH,TOKEN);
 /********************************************************************/
 /*   CONCATENTATES A TOKEN ONTO A STRING ARRAY.                     */
 /*     - THE STRING ARRAY IS A STRING CONTAINING ZERO OR MORE       */
 /*       TOKENS.  THESE ARE ALL CONCATENATED TOGETHER AND EACH IS   */
 /*       PADDED TO THE LENGTH OF THE LONGEST TOKEN.                 */
 /*     - THE STRING ARRAY, THE ITEM COUNT AND THE STRING LENGTH     */
 /*       ARE ALL SET BY THE PROCEDURE.                              */
 /********************************************************************/
 DECLARE
    STRING_ARRAY CHAR(*),          /* THE CHARACTER STRING CONTAINING*/
                                   /* THE TOKENS.                    */
    ITEMS         FIXED BIN(15),   /* THE NUMBER OF TOKENS ALREADY   */
                                   /* HELD IN THE STRING ARRAY.      */
    STRING_LENGTH FIXED BIN(15),   /* THE LENGTH OF TOKENS IN THE    */
                                   /* STRING ARRAY.                  */
    TOKEN CHAR(32) VARYING,        /* THE TOKEN TO BE ADDED.         */

    NEWLENGTH    FIXED BIN(15),    /* TEMPORARY TO CONTAIN NEW LEN   */
    I            FIXED BIN(15);    /* TEMPORARY COUNTER              */

 IF LENGTH(TOKEN) > STRING_LENGTH  THEN
   DO;
    /*****************************************************************/
    /*  THE NEW TOKEN IS LONGER THAN THE OLD ONES, SO REFORMAT       */
    /*  THE STRING ARRAY FOR THE LONGER TOKENS.                      */
    /*****************************************************************/
    NEWLENGTH = LENGTH(TOKEN);            /* NEW STRING LENGTH       */
    IF NEWLENGTH*ITEMS > LENGTH(STRING_ARRAY) THEN
      MESSAGE = 'TOO MUCH STRING DATA';
    ELSE                           /* IF ENOUGH ROOM THEN            */
     DO;
      DO I = ITEMS-1 TO 0 BY -1;   /*      PROCESS ALL STRINGS BY    */
                                   /*      MOVING THEM ABOUT         */
        SUBSTR(STRING_ARRAY,I*NEWLENGTH+1,NEWLENGTH)
            = SUBSTR(STRING_ARRAY,I*STRING_LENGTH+1,STRING_LENGTH);
      END;
      STRING_LENGTH = NEWLENGTH;   /*  AND RESET STRING LENGTH.      */
     END;
   END;                            /*        END OF KEY REFORMAT     */
 /********************************************************************/
 /* NOW INSERT THE NEW KEY, EXPANDING TO KEYLEN.                     */
 /********************************************************************/
 ITEMS = ITEMS + 1;                /* INCREASE ITEM COUNT.           */
 IF STRING_LENGTH*ITEMS > LENGTH(STRING_ARRAY) THEN
    MESSAGE = 'TOO MUCH STRING DATA';
 ELSE                              /* IF THERE IS ENOUGH ROOM THEN:  */
                                   /* INSERT THE TOKEN               */
  SUBSTR(STRING_ARRAY,(ITEMS-1)*STRING_LENGTH+1,STRING_LENGTH) = TOKEN;
 END;                              /* OF APPEND PROCEDURE            */
1TRANSPOSE: PROCEDURE(INARRAY,ROWS,COLUMNS);
 /********************************************************************/
 /*   TRANSPOSES THE MATRIX INARRAY.                                 */
 /*     - THE ARRAY IS ASSUMED TO HAVE ROWS ROWS AND COLUMNS         */
 /*       COLUMNS.                                                   */
 /*     - ON INPUT IT IS STORED WITH THE ROW INDEX VARYING MOST      */
 /*       RAPIDLY. ON OUTPUT THE COLUMN INDEX VARIES MOST RAPIDLY    */
 /********************************************************************/
 DECLARE
    INARRAY (*) FLOAT,             /* THE INPUT ARRAY.               */
    ROWS          FIXED BIN(15),   /* THE NUMBER OF ROWS OF DATA     */
    COLUMNS       FIXED BIN(15),   /* THE NUMBER OF COLUMNS          */
    (I,J)         FIXED BIN(15),   /* TEMPORARY INDEXES              */
    TEMP(ROWS*COLUMNS) FLOAT;      /* TEMPORARY USED IN CONVERSION   */

    DO I = 0 TO ROWS-1;            /* TRANSPOSE THE MATRIX INTO TEMP */
      DO J = 0 TO COLUMNS-1;
        TEMP(J*ROWS+I+1) = INARRAY(I*COLUMNS+J+1);
      END;
    END;
    DO I = 1 TO ROWS*COLUMNS;      /* AND COPY IT BACK TO INARRAY    */
        INARRAY(I) = TEMP(I);
    END;
 END;                              /* OF TRANSPOSE PROCEDURE         */


 END;                              /* OF ADMUSP6                     */
*PROCESS;
1ERRPROC : PROCEDURE(AB,ERRORBLOCK) OPTIONS(COBOL);
 /********************************************************************/
 /*   PROCEDURE NOMINATED AS ERROR EXIT BY AN FSEXIT CALL.           */
 /*     - RECEIVES CONTROL WHEN AN ERROR IS DETECTED.                */
 /*       THE PARAMETER PASSED IS NOT IN ACCEPTABLE PL/I FORMAT      */
 /*       SO THE PROCEDURE IS DECLARED OPTIONS COBOL                 */
 /*     - THE APPLICATION ANCHOR BLOCK PASSED BY GDDM CONTAINS       */
 /*       THE ADDRESS OF THE MESSAGE AREA IN THE USER EXTENSION.     */
 /*       THIS AREA IS SET TO THE MESSAGE TEXT.                      */
 /*     - THE PROCEDURE IS INCLUDED IN THE MAIN COMPILATION FOR      */
 /*       CONVENIENCE, HOWVER LOGICALLY IT IS EXTERNAL.              */
 /********************************************************************/
 DECLARE
   1 ERRORBLOCK,                   /* THAT PART OF REQUIRED          */
      2 SEVERITY FIXED BIN(31),    /* THE ERROR SEVERITY             */
      2 NUMBER   FIXED BIN(31),    /* THE ERROR NUMBER               */
      2 FNAME    CHARACTER(8),     /* THE FUNCTION NAME              */
      2 MSGLEN   FIXED BIN(31),    /* MESSAGE LENGTH                 */
      2 MSGTEXT  CHARACTER(80);    /* MESSAGE TEXT                   */
 DECLARE                          /* GDDM ANCHOR BLOCK              */
    1 AB,
       2  AABSC   FIXED BIN(15),   /* SEVERITY CODE                  */
       2  AABEC   FIXED BIN(15),   /* ERROR CODE                     */
       2  AABAP   CHARACTER(4),    /* GDDM ANCHOR, ACTUALLY A POINTER*/
       2  MESSAGE CHARACTER(60);   /* MESSAGE TEXT RETURNED          */

   MESSAGE = SUBSTR(MSGTEXT,1,LENGTH(MESSAGE));
 END;                              /* OF ERRPROC  PROCEDURE          */
