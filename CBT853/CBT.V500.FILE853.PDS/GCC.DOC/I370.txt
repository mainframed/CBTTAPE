;;- Machine description for GNU compiler -- System/370 version.

;; =======================================================================
;; Note that this file is not nearly as complicated as it looks
;; at first glance. See below the copyright notice for an explanation
;; (you will get nowhere without an explanation).
;; =======================================================================


;;  Copyright (C) 1989, 1993, 1994, 1995, 1997, 1998, 1999, 2000, 2002
;;  Free Software Foundation, Inc.
;;  Contributed by Jan Stein (jan@cd.chalmers.se).
;;  Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)
;;  Lots of Bug Fixes & Enhancements by Linas Vepstas (linas@linas.org)
;;  More bug fixes by Paul Edwards (fight.subjugation@gmail.com)

;; This file is part of GCC.

;; GCC is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; GCC is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GCC; see the file COPYING.  If not, write to
;; the Free Software Foundation, 59 Temple Place - Suite 330,
;; Boston, MA 02111-1307, USA.


;; =======================================================================
;; At the heart of the GCC backend (the backend is what generates the
;; code for a particular CPU, the frontend deals with some high-level
;; language - you can basically feed an arbitrary language into the
;; front and get code for an arbitrary CPU out the back) is this
;; "machine description" file. This is where you put the S/370
;; instructions, e.g. "MH", multiply halfword, into a form that the
;; rest of the GCC compiler understands.

;; At some point in GCC's deliberations, it will have a requirement
;; to say multiply x (an integer) by say "5". This can be done by the
;; MH instruction. The thing is that "x" could actually already be in
;; a register, or it could be in memory. If in memory, it could be
;; conveniently referenced by an RX instruction (ie base + index). It
;; may not be accessible via an S address (base only), for whatever
;; reason (typically, a variable is on the stack, and offset on the
;; stack is more than 4096, so base + offset can't get to it).

;; So basically GCC needs to be made aware of whether the MH instruction
;; can operate on an S address, an RX, or only a register. The "ST"
;; instruction is RX so can operate on RX or S. In this case, MH, the
;; destination needs to be a register. It's an RX instruction though,
;; so the source can be be an RX address. However, there's an
;; additional constraint - the source must be a halfword, so this is
;; only suitable for values between -32768 and 32767 inclusive.
;; All this information needs to be communicated to the compiler.

;; Let's take a look at this instruction:
;;
;; (define_insn ""
;;   Ý(set (match_operand:SI 0 "register_operand" "=d")
;; 	(mult:SI (match_operand:SI 1 "register_operand" "0")
;; 		 (match_operand:SI 2 "immediate_operand" "K")))¨
;;   ""
;;   "*
;; {
;;   check_label_emit ();
;;   mvs_check_page (0, 4, 0);
;;   return \"MH	%0,%H2\";
;; }"
;;    Ý(set_attr "length" "4")¨
;; )
;;
;; The important things here are:
;;
;; the "mult:SI" tells it that this will do a multiply of fullword integers.
;; If it had been "DI" it would be doublewords, ie either register pairs
;; or 8 bytes of memory aligned on an 8-byte boundary. "SI" is a standard
;; integer. "DI" is double-sized integer. "HI" is a halfword integer,
;; and finally we have "QI" for a quarter, or byte operation.
;;
;; "mult" is a standard keyword that GCC knows and it will go looking for
;; a pattern of this name when it needs to do a multiply.

;; Next look at the "match_operand:SI". That tells it that the operand
;; for this instruction needs to be an integer. If e.g. this said
;; instead "DI", it would let GCC know that if it needs to multiply an
;; integer, it first needs to move it into a register pair before doing
;; this instruction. This bit is extremely important. The loading into
;; the right registers needs to be done *BEFORE* the instruction is
;; executed. It's too late at this stage of the game to start defining
;; some temporary registers you would like to use to complete this
;; operation.

;; Next we see a "0". That means operand number 0, the destination.
;;
;; Then we have "register_operand". That means that the destination
;; is a register. You can't use this to write an answer directly to
;; memory. Note that you can find this keyword, and other keywords,
;; in the "GCC internals" manual under "Machine Descriptions",
;; "RTL template", and are called the "predicate" (look for manual
;; sections called "predicates" too). Some of these
;; predicates are not documented there, they are specific to S/370.
;; e.g. "s_operand" which says that it must be an S-type (ie no
;; index) memory reference. So long as the compiler knows this in
;; advance, it will take care of moving any variable into an S-type
;; memory reference. Be careful. The predicate "r_or_s_operand"
;; doesn't mean RX or S memory address. It means that the following
;; pattern will deal with both a REGISTER and an S-type address.

;; Next we have a constraint. That's the "=d". The "=" says that
;; this operand will be an output (destination). A "+" would mean
;; that it is both input and output. And nothing would mean
;; input-only. These are documented in "constraint modifier
;; characters" under "operand constraints" under "machine descriptions".
;; The "d" bit would have been documented under "simple constraints",
;; except it is not standard with GCC. It is an S/370 extension which
;; means that it is a general register, ie even R0, rather than "a"
;; which would be an address register (ie R0 isn't allowed). This
;; lets GCC know that if it happens to have the value in R0, then
;; that's fine. It doesn't need to go to the effort of moving it
;; into say R1 in order to do the "MH" instruction.

;; That completes the first operand. The second operand is a bit
;; complicated. As you know, the MH instruction only takes 2
;; operands. But in the general case (logically, for any machine),
;; a multiply involves 3 separate things. There are two numbers
;; that are multiplied together to produce a third. In the case
;; of the MH instruction, it can only operate on itself. ie
;; instead of a = b * c we have a = a * b. We need to inform GCC
;; of that fact. We do this by saying that the second logical
;; operand is actually the exact same thing as the first. We
;; do this by setting the constraint to "0", meaning that the
;; first operand is not just constrained to being a register -
;; it's constrained to be the exact same register in operand 0!!!

;; Finally on the last parameter, we need to tell it that the
;; integer, e.g. "5", must be known at compile time. It can't
;; be a variable. If it is a variable, it might exceed the limits
;; of a halfword. So we tell it that it must be an "immediate
;; operand". But that's not all. If the number is "50000", it will
;; exceed the limit of a halfword. So we have another S/370-specific
;; constraint. This time "K". "K" means that the value must lie
;; between -32768 and 32767 so that this instruction can actually
;; be used.

;; That's the basics. You will need to refer to the manual for more
;; details. However, there's more things to be aware of. There
;; can actually be multiple constraints in the one instruction.
;; e.g. if you want to move some data from R3 to R4, you can use
;; the "LR" instruction. And to move from an RX memory address
;; you can use "L". Both of these things are just "movsi" to GCC,
;; and it expects to be able to move from a variety of data types.
;; moving a constant or an arbitrary fullword in memory, are both
;; done by the "L" instruction. But LR is only for registers.
;; So we might see a constraint of "d" for operand 1, but "di"
;; for operand 2. "g" would mean that we can take any data type.

;; If operand 1 is "=d,dm" and operand 2 is "di,F", then what
;; this means is that the "di" matches the "d", ignore the stuff
;; after the comma, and the following pattern will deal with
;; that combination. Which means that either a constant or a
;; register can be the source, and the destination will be a
;; register. If we now look after the comma, then we match
;; "dm" with "F". What that means is that an immediate floating
;; point value, such as "5.7" can be moved into either a
;; data register (d) or any memory address (m). If it could only
;; be moved into an S address, it would have an "S" there instead
;; of a "m". So if you look at any pattern which involves "MVC",
;; you will see that it is never exposed to an "m", it will
;; always have an "S" there (or something even more stringent).

;; Another thing to be aware of is that the patterns sometimes
;; have standard names (like "movdi"). You can have multiple patterns
;; to accomplish the same basic thing in different circumstances.
;; The way it is organized is to put your preferred instructions
;; first, and then the official name on the last one. A lot of
;; the S/370 instructions have a first pattern that is only enabled
;; if you activate "TARGET_CHAR_INSTRUCTIONS", which indeed, is on
;; by default.

;; Below here you will find documentation from my predecessors who
;; seem to assume you've found, read, and understood the official
;; documentation. :-)

;; =======================================================================
;; Condition codes for some of the instructions (in particular, for
;; add, sub, shift, abs, etc. are handled with the cpp macro NOTICE_UPDATE_CC
;;
;; Special constraints for 370 machine description:
;;
;;    a -- Any address register from 1 to 15.
;;    d -- Any register from 0 to 15.
;;    f -- Floating point register
;;    I -- An 8-bit constant (0..255).
;;    J -- A 12-bit constant (0..4095).
;;    K -- A 16-bit constant (-32768..32767).
;;    R -- a valid S operand in an RS, SI or SS instruction, or register
;;    S -- a valid S operand in an RS, SI or SS instruction
;;
;; Note this well:
;; When defining an instruction, e.g. the movsi pattern:
;;
;;    (define_insn ""
;;        Ý(set (match_operand:SI 0 "r_or_s_operand" "=dm,d,dm")
;;            (match_operand:SI 1 "r_or_s_operand" "diR,dim,*fF"))¨
;;
;; The "r_or_s_operand" predicate is used to recognize the instruction;
;; however, it is not further used to enforce a constraint at later stages.
;; Thus, for example, although "r_or_s_operand" bars operands of the form
;; base+index+displacement, such operands can none-the-less show up during
;; post-instruction-recog processing: thus, for example, garbage like
;; MVC     152(4,r13),0(r5,r13) might be generated if both op0 and op1 are
;; mem operands.   To avoid this, use the S constraint.
;;
;;
;; Special formats used for outputting 370 instructions.
;;
;;   %B -- Print a constant byte integer.
;;   %H -- Print a signed 16-bit constant.
;;   %K -- Print a signed 16-bit constant signed-extended to 32-bits.
;;   %L -- Print least significant word of a CONST_DOUBLE.
;;   %M -- Print most significant word of a CONST_DOUBLE.
;;   %N -- Print next register (second word of a DImode reg).
;;   %O -- Print the offset of a memory reference (PLUS (REG) (CONST_INT)).
;;   %R -- Print the register of a memory reference (PLUS (REG) (CONST_INT)).
;;   %X -- Print a constant byte integer in hex.
;;   %W -- Print a signed 32-bit int sign-extended to 64-bits.
;;
;; We have a special constraint for pattern matching.
;;
;;   s_operand -- Matches a valid S operand in a RS, SI or SS type instruction.
;;
;;   r_or_s_operand -- Matches a register or a valid S operand in a RS, SI
;;		       or SS type instruction or a register
;;
;; For MVS C/370 we use the following stack locations for:
;;
;;   136 - internal function result buffer
;;   140 - numeric conversion buffer
;;   144 - pointer to internal function result buffer
;;   148 - start of function arguments and automatic variables
;;
;; For TARGET_DIGNUS or TARGET_PDPMAC we use the stack locations for:
;;
;;   80 - numeric conversion buffer
;;   84 - pointer to internal function result buffer
;;   88 - start of function arguments and automatic variables
;;
;; To support programs larger than a page, 4096 bytes, PAGE_REGISTER points
;; to a page origin table, all internal labels are generated to reload the
;; BASE_REGISTER knowing what page it is on and all branch instructions go
;; directly to the target if it is known that the target is on the current
;; page (essentially backward references).  All forward references and off
;; page references are handled by loading the address of target into a
;; register and branching indirectly.
;;
;; Some *di patterns have been commented out per advice from RMS, as gcc
;; will generate the right things to do.
;;
;; See the note in i370.h about register 14, clobbering it, and optimization.
;; Basically, using clobber in egcs-1.1.1 will ruin ability to optimize around
;; branches, so don't do it.
;;
;; We use the "length" attirbute to store the max possible code size of an
;; insn.  We use this length to estimate the length of forward branches, to
;; determine if they're on page or off.

(define_attr "length" "" (const_int 0))

;;
;;- Test instructions.
;;

;
; tstdi instruction pattern(s).
;

(define_insn "tstdi"
  Ý(set (cc0)
	(match_operand:DI 0 "register_operand" "d"))¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 4, 0);
  return \"SRDA	%0,0\";
}"
   Ý(set_attr "length" "4")¨
)

;
; tstsi instruction pattern(s).
;

(define_insn "tstsi"
  Ý(set (cc0)
	(match_operand:SI 0 "register_operand" "d"))¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 2, 0);
  return \"LTR	%0,%0\";
}"
   Ý(set_attr "length" "2")¨
)

;
; tsthi instruction pattern(s).
;

(define_insn "tsthi"
  Ý(set (cc0)
	(match_operand:HI 0 "register_operand" "d"))¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 4, 2);
  return \"CH	%0,=H'0'\";
}"
   Ý(set_attr "length" "4")¨
)

;
; tstqi instruction pattern(s).
;

;(define_insn ""
;  Ý(set (cc0)
;	(match_operand:QI 0 "s_operand" "S"))¨
;  "unsigned_jump_follows_p (insn)"
;  "*
;{
;  check_label_emit ();
;  if (REG_P (operandsÝ0¨))
;    {
;      /* an unsigned compare to zero is always zero/not-zero...  */
;      mvs_check_page (0, 4, 4);
;      return \"N	%0,=XL4'000000FF'\";
;    }
;  mvs_check_page (0, 4, 0);
;  return \"CLI	%0,0\";
;}"
;   Ý(set_attr "length" "4")¨
;)

;(define_insn "tstqi"
;  Ý(set (cc0)
;     (match_operand:QI 0 "register_operand" "d"))¨
;  ""
;  "*
;{
;  check_label_emit ();
;  if (unsigned_jump_follows_p (insn))
;    {
;      /* an unsigned compare to zero is always zero/not-zero...  */
;      mvs_check_page (0, 4, 4);
;      return \"N	%0,=XL4'000000FF'\";
;    }
;  mvs_check_page (0, 8, 0);
;  return \"SLL	%0,24\;SRA	%0,24\";
;}"
;   Ý(set_attr "length" "8")¨
;)

;
; tstdf instruction pattern(s).
;

(define_insn "tstdf"
  Ý(set (cc0)
	(match_operand:DF 0 "general_operand" "f"))¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 2, 0);
  return \"LTDR	%0,%0\";
}"
   Ý(set_attr "length" "2")¨
)

;
; tstsf instruction pattern(s).
;

(define_insn "tstsf"
  Ý(set (cc0)
	(match_operand:SF 0 "general_operand" "f"))¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 2, 0);
  return \"LTER	%0,%0\";
}"
   Ý(set_attr "length" "2")¨
)

;;
;;- Compare instructions.
;;

;
; cmpdi instruction pattern(s).
;

;(define_insn "cmpdi"
;  Ý(set (cc0)
;	(compare (match_operand:DI 0 "register_operand" "d")
;		 (match_operand:DI 1 "general_operand" "")))¨
;  ""
;  "*
;{
;  check_label_emit ();
;  if (REG_P (operandsÝ1¨))
;    {
;      mvs_check_page (0, 8, 0);
;      if (unsigned_jump_follows_p (insn))
;        return \"CLR	%0,%1\;BNE	*+6\;CLR	%N0,%N1\";
;      return \"CR	%0,%1\;BNE	*+6\;CLR	%N0,%N1\";
;    }
;  mvs_check_page (0, 12, 0);
;  if (unsigned_jump_follows_p (insn))
;    return \"CL	%0,%M1\;BNE	*+8\;CL	%N0,%L1\";
;  return \"C	%0,%M1\;BNE	*+8\;CL	%N0,%L1\";
;}")

;
; cmpsi instruction pattern(s).
;

(define_insn "cmpsi"
  Ý(set (cc0)
	(compare (match_operand:SI 0 "register_operand" "d")
		 (match_operand:SI 1 "general_operand" "md")))¨
  ""
  "*
{
  check_label_emit ();
  if (REG_P (operandsÝ1¨))
    {
      mvs_check_page (0, 2, 0);
      if (unsigned_jump_follows_p (insn))
	return \"CLR	%0,%1\";
      return \"CR	%0,%1\";
    }
  if (GET_CODE (operandsÝ1¨) == CONST_INT)
    {
      mvs_check_page (0, 4, 4);
      if (unsigned_jump_follows_p (insn))
	 return \"CL	%0,=F'%c1'\";
      return \"C	%0,=F'%c1'\";
    }
  mvs_check_page (0, 4, 0);
  if (unsigned_jump_follows_p (insn))
    return \"CL	%0,%1\";
  return \"C	%0,%1\";
}"
   Ý(set_attr "length" "4")¨
)

;
; cmphi instruction pattern(s).
;

; deprecate constraint d because it takes multiple instructions
; and a memory access ...
(define_insn "cmphi"
  Ý(set (cc0)
	(compare (match_operand:HI 0 "register_operand" "d")
		 (match_operand:HI 1 "general_operand" "???diS")))¨
  ""
  "*
{
  check_label_emit ();
  if (REG_P (operandsÝ1¨))
    {
      mvs_check_page (0, 8, 0);
      if (unsigned_jump_follows_p (insn))
	return \"STH	%1,\" CONVLO \"(,13)\;CLM	%0,3,\" CONVLO \"(13)\";
      return \"STH	%1,\" CONVLO \"(,13)\;CH	%0,\" CONVLO \"(,13)\";
    }
  if (GET_CODE (operandsÝ1¨) == CONST_INT)
    {
      if (unsigned_jump_follows_p (insn))
        {
      mvs_check_page (0, 4, 2);
      return \"CLM	%0,3,%H1\";
        }
      mvs_check_page (0, 4, 2);
      return \"CH	%0,%H1\";
    }
  if (unsigned_jump_follows_p (insn))
    {
      mvs_check_page (0, 10, 0);
      if (REG_P (operandsÝ1¨))
	return \"STH	%1,\" CONVLO \"(,13)\;CLM	%0,3,\" CONVLO \"(13)\";
      return \"MVC	\" CONVLO \"(2,13),%1\;CLM	%0,3,\" CONVLO \"(13)\";
    }
  mvs_check_page (0, 4, 0);
  return \"CH	%0,%1\";
}"
   Ý(set_attr "length" "8")¨
)

;
; cmpqi instruction pattern(s).
;

(define_insn ""
  Ý(set (cc0)
	(compare (match_operand:QI 0 "r_or_s_operand" "dS")
		 (match_operand:QI 1 "general_operand" "diS")))¨
  "unsigned_jump_follows_p (insn)"
  "*
{
  check_label_emit ();
  if (REG_P (operandsÝ0¨))
    {
      if (REG_P (operandsÝ1¨))
	{
	  mvs_check_page (0, 8, 0);
          return \"STC	%1,\" CONVLO \"(,13)\;CLM	%0,1,\" CONVLO \"(13)\";
        }
      if (GET_CODE (operandsÝ1¨) == CONST_INT)
	{
	  mvs_check_page (0, 4, 1);
          return \"CLM	%0,1,=XL1'%X1'\";
        }
      mvs_check_page (0, 4, 0);
      return \"CLM	%0,1,%1\";
    }
  else if (GET_CODE (operandsÝ0¨) == CONST_INT)
    {
      cc_status.flags |= CC_REVERSED;
      if (REG_P (operandsÝ1¨))
	{
	  mvs_check_page (0, 4, 1);
          return \"CLM	%1,1,=XL1'%X0'\";
        }
      mvs_check_page (0, 4, 0);
      return \"CLI	%1,%B0\";
    }
  if (GET_CODE (operandsÝ1¨) == CONST_INT)
    {
      mvs_check_page (0, 4, 0);
      return \"CLI	%0,%B1\";
    }
  if (GET_CODE (operandsÝ1¨) == MEM)
    {
      mvs_check_page (0, 6, 0);
      return \"CLC	%O0(1,%R0),%1\";
    }
  cc_status.flags |= CC_REVERSED;
  mvs_check_page (0, 4, 0);
  return \"CLM	%1,1,%0\";
}"
   Ý(set_attr "length" "8")¨
)

(define_insn "cmpqi"
  Ý(set (cc0)
	(compare (match_operand:QI 0 "register_operand" "d")
		 (match_operand:QI 1 "general_operand" "di")))¨
  ""
  "*
{
  check_label_emit ();
  if (unsigned_jump_follows_p (insn))
    {
      if (GET_CODE (operandsÝ1¨) == CONST_INT)
	{
	  mvs_check_page (0, 4, 1);
          return \"CLM	%0,1,=XL1'%X1'\";
        }
      if (!(REG_P (operandsÝ1¨)))
	{
	  mvs_check_page (0, 4, 0);
          return \"CLM	%0,1,%1\";
        }
      mvs_check_page (0, 8, 0);
      return \"STC	%1,\" CONVLO \"(,13)\;CLM	%0,1,\" CONVLO \"(13)\";
    }
  if (REG_P (operandsÝ1¨))
    {
      mvs_check_page (0, 18, 0);
      return \"SLL	%0,24\;SRA	%0,24\;SLL	%1,24\;SRA	%1,24\;CR	%0,%1\";
    }
  mvs_check_page (0, 12, 0);
  return \"SLL	%0,24\;SRA	%0,24\;C	%0,%1\";
}"
   Ý(set_attr "length" "18")¨
)

;
; cmpdf instruction pattern(s).
;

(define_insn "cmpdf"
  Ý(set (cc0)
	(compare (match_operand:DF 0 "general_operand" "f,mF")
		 (match_operand:DF 1 "general_operand" "fmF,f")))¨
  ""
  "*
{
  check_label_emit ();
  if (FP_REG_P (operandsÝ0¨))
    {
      if (FP_REG_P (operandsÝ1¨))
	{
	  mvs_check_page (0, 2, 0);
	  return \"CDR	%0,%1\";
	}
      mvs_check_page (0, 4, 0);
      return \"CD	%0,%1\";
    }
  cc_status.flags |= CC_REVERSED;
  mvs_check_page (0, 4, 0);
  return \"CD	%1,%0\";
}"
   Ý(set_attr "length" "4")¨
)

;
; cmpsf instruction pattern(s).
;

(define_insn "cmpsf"
  Ý(set (cc0)
	(compare (match_operand:SF 0 "general_operand" "f,mF")
		 (match_operand:SF 1 "general_operand" "fmF,f")))¨
  ""
  "*
{
check_label_emit ();
  if (FP_REG_P (operandsÝ0¨))
    {
      if (FP_REG_P (operandsÝ1¨))
	{
	  mvs_check_page (0, 2, 0);
	  return \"CER	%0,%1\";
	}
      mvs_check_page (0, 4, 0);
      return \"CE	%0,%1\";
    }
  cc_status.flags |= CC_REVERSED;
  mvs_check_page (0, 4, 0);
  return \"CE	%1,%0\";
}"
   Ý(set_attr "length" "4")¨
)

;
; cmpmemsi instruction pattern(s).
;

(define_expand "cmpmemsi"
  Ý(set (match_operand:SI 0 "general_operand" "")
	  (compare (match_operand:BLK 1 "general_operand" "")
		   (match_operand:BLK 2 "general_operand" "")))
     (use (match_operand:SI 3 "general_operand" ""))
     (use (match_operand:SI 4 "" ""))¨
   ""
   "
{
  rtx op1, op2;

  op1 = XEXP (operandsÝ1¨, 0);
  if (GET_CODE (op1) == REG
      || (GET_CODE (op1) == PLUS && GET_CODE (XEXP (op1, 0)) == REG
	  && GET_CODE (XEXP (op1, 1)) == CONST_INT
	  && (unsigned) INTVAL (XEXP (op1, 1)) < 4096))
    {
      op1 = operandsÝ1¨;
    }
  else
    {
      op1 = gen_rtx_MEM (BLKmode, copy_to_mode_reg (SImode, op1));
    }

  op2 = XEXP (operandsÝ2¨, 0);
  if (GET_CODE (op2) == REG
      || (GET_CODE (op2) == PLUS && GET_CODE (XEXP (op2, 0)) == REG
	  && GET_CODE (XEXP (op2, 1)) == CONST_INT
	  && (unsigned) INTVAL (XEXP (op2, 1)) < 4096))
    {
      op2 = operandsÝ2¨;
    }
  else
    {
      op2 = gen_rtx_MEM (BLKmode, copy_to_mode_reg (SImode, op2));
    }

  if (GET_CODE (operandsÝ3¨) == CONST_INT
      && (unsigned)INTVAL (operandsÝ3¨) < 256)
    {
      emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2,
		gen_rtx_SET (VOIDmode, operandsÝ0¨,
			gen_rtx_COMPARE (SImode, op1, op2)), /* was VOIDmode */
		gen_rtx_USE (VOIDmode, operandsÝ3¨))));
    }
  else
    {
        /* implementation suggested by  Richard Henderson <rth@cygnus.com> */
        rtx reg1 = gen_reg_rtx (DImode);
        rtx reg2 = gen_reg_rtx (DImode);
        rtx result = operandsÝ0¨;
        rtx mem1 = operandsÝ1¨;
        rtx mem2 = operandsÝ2¨;
        rtx len = operandsÝ3¨;
        if (!CONSTANT_P (len))
          len = force_reg (SImode, len);

        /* Load up the address+length pairs.  */
        emit_insn (gen_rtx_CLOBBER (VOIDmode, reg1));
        emit_move_insn (gen_rtx_SUBREG (SImode, reg1, 0),
                        force_operand (XEXP (mem1, 0), NULL_RTX));
        emit_move_insn (gen_rtx_SUBREG (SImode, reg1, GET_MODE_SIZE (SImode)), len);

        emit_insn (gen_rtx_CLOBBER (VOIDmode, reg2));
        emit_move_insn (gen_rtx_SUBREG (SImode, reg2, 0),
                        force_operand (XEXP (mem2, 0), NULL_RTX));
        emit_move_insn (gen_rtx_SUBREG (SImode, reg2, GET_MODE_SIZE (SImode)), len);

        /* Compare! */
        emit_insn (gen_cmpmemsi_1 (result, reg1, reg2));
    }
  DONE;
}")

; Compare a block that is less than 256 bytes in length.

(define_insn ""
  Ý(set (match_operand:SI 0 "register_operand" "=d")
	(compare:SI (match_operand:BLK 1 "s_operand" "m")
		 (match_operand:BLK 2 "s_operand" "m")))
   (use (match_operand:SI 3 "immediate_operand" "I"))¨
  "((unsigned) INTVAL (operandsÝ3¨) < 256)"
  "*
{
  check_label_emit ();
  mvs_check_page (0, 22, 0);
  return \"CLC	%O1(%c3,%R1),%2\;BH	*+12\;BL	*+6\;SLR	%0,%0\;LNR	%0,%0\";
}"
   Ý(set_attr "length" "22")¨
)

; Compare a block that is larger than 255 bytes in length.
;        (mem:BLK (subreg:SI (match_operand:DI 1 "register_operand" "+d") 0))
;        (mem:BLK (subreg:SI (match_operand:DI 2 "register_operand" "+d") 0))))

(define_insn "cmpmemsi_1"
  Ý(set (match_operand:SI 0 "register_operand" "+d")
        (compare:SI
        (mem:BLK (match_operand:DI 1 "register_operand" "+d") )
        (mem:BLK (match_operand:DI 2 "register_operand" "+d") )))
   (use (match_dup 1))
   (use (match_dup 2))
   (clobber (match_dup 1))
   (clobber (match_dup 2))¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 18, 0);
  return \"LA	%0,1(0,0)\;CLCL	%1,%2\;BH	*+12\;BL	*+6\;SLR	%0,%0\;LNR	%0,%0\";
}"
   Ý(set_attr "length" "18")¨
)

;;
;;- Move instructions.
;;

;
; movdi instruction pattern(s).
;

(define_insn ""
  Ý(set (match_operand:DI 0 "nonimmediate_operand" "=d,m,S")
        (match_operand:DI 1 "general_operand" "g,d,SF"))¨
;;  Ý(set (match_operand:DI 0 "r_or_s_operand" "=dS,m")
;;        (match_operand:DI 1 "r_or_s_operand" "diS*fF,d*fF"))¨
  "TARGET_CHAR_INSTRUCTIONS"
  "*
{
  check_label_emit ();
  if (REG_P (operandsÝ0¨))
    {
      if (FP_REG_P (operandsÝ1¨))
	{
	  mvs_check_page (0, 8, 0);
	  return \"STD	%1,\" CONVLO \"(,13)\;LM	%0,%N0,\" CONVLO \"(13)\";
	}
      if (REG_P (operandsÝ1¨))
	{
	  mvs_check_page (0, 4, 0);
	  return \"LR	%0,%1\;LR	%N0,%N1\";
	}
      if (operandsÝ1¨ == const0_rtx)
	{
	  CC_STATUS_INIT;
	  mvs_check_page (0, 4, 0);
	  return \"SLR	%0,%0\;SLR	%N0,%N0\";
	}
      if (GET_CODE (operandsÝ1¨) == CONST_INT
  	  && (unsigned) INTVAL (operandsÝ1¨) < 4096)
	{
	  CC_STATUS_INIT;
	  mvs_check_page (0, 6, 0);
	  return \"SLR	%0,%0\;LA	%N0,%c1(0,0)\";
	}
      if (GET_CODE (operandsÝ1¨) == CONST_INT)
	{
	  CC_STATUS_SET (operandsÝ0¨, operandsÝ1¨);
	  mvs_check_page (0, 8, 0);
	  return \"L	%0,%1\;SRDA	%0,32\";
	}
      if (GET_CODE (operandsÝ1¨) == CONST_DOUBLE)
	{
	  mvs_check_page (0, 6, 8);
	  return \"LM	%0,%N0,%1\";
	}
      mvs_check_page (0, 4, 0);
      /*return \"LM	%0,%N0,%1\";*/
      return \"L	%0,%1\;L	%N0,4+%1\";
    }
  else if (FP_REG_P (operandsÝ1¨))
    {
      mvs_check_page (0, 4, 0);
      return \"STD	%1,%0\";
    }
  else if (REG_P (operandsÝ1¨))
    {
      mvs_check_page (0, 4, 0);
      /*return \"STM	%1,%N1,%0\"; */
      return \"ST	%1,%0\;ST	%N1,4+%0\";
    }
  mvs_check_page (0, 6, 8);
  return \"MVC	%O0(8,%R0),%1\";
}"
   Ý(set_attr "length" "8")¨
)

(define_insn "movdi"
  Ý(set (match_operand:DI 0 "nonimmediate_operand" "=d,dm")
	(match_operand:DI 1 "general_operand" "dimF,*fd"))¨
;;  Ý(set (match_operand:DI 0 "general_operand" "=d,dm")
;;	(match_operand:DI 1 "r_or_s_operand" "diSF,*fd"))¨
  ""
  "*
{
  check_label_emit ();
  if (REG_P (operandsÝ0¨))
    {
      if (FP_REG_P (operandsÝ1¨))
	{
	  mvs_check_page (0, 8, 0);
	  return \"STD	%1,\" CONVLO \"(,13)\;LM	%0,%N0,\" CONVLO \"(13)\";
	}
      if (REG_P (operandsÝ1¨))
	{
	  mvs_check_page (0, 4, 0);
	  return \"LR	%0,%1\;LR	%N0,%N1\";
	}
      if (operandsÝ1¨ == const0_rtx)
	{
	  CC_STATUS_INIT;
	  mvs_check_page (0, 4, 0);
	  return \"SLR	%0,%0\;SLR	%N0,%N0\";
	}
      if (GET_CODE (operandsÝ1¨) == CONST_INT
  	  && (unsigned) INTVAL (operandsÝ1¨) < 4096)
	{
	  CC_STATUS_INIT;
	  mvs_check_page (0, 6, 0);
	  return \"SLR	%0,%0\;LA	%N0,%c1(0,0)\";
	}
      if (GET_CODE (operandsÝ1¨) == CONST_INT)
	{
	  CC_STATUS_SET (operandsÝ0¨, operandsÝ1¨);
	  mvs_check_page (0, 8, 0);
	  return \"L	%0,%1\;SRDA	%0,32\";
	}
      mvs_check_page (0, 4, 0);
      /*return \"LM	%0,%N0,%1\";*/
      return \"L	%0,%1\;L	%N0,4+%1\";
    }
  else if (FP_REG_P (operandsÝ1¨))
    {
      mvs_check_page (0, 4, 0);
      return \"STD	%1,%0\";
    }
  mvs_check_page (0, 4, 0);
  /*return \"STM	%1,%N1,%0\"; */
  return \"ST	%1,%0\;ST	%N1,4+%0\";
}"
   Ý(set_attr "length" "8")¨
)

;; we have got to provide a movdi alternative that will go from
;; register to memory & back in its full glory.  However, we try to
;; discourage its use by listing this alternative last.
;; The problem is that the instructions above only provide
;; S-form style (base + displacement) mem access, while the
;; below provides the full (base+index+displacement) RX-form.
;; These are rarely needed, but when needed they're needed.
;; Don't use LM/STM as they can't handle a full RX-form address.

;;(define_insn ""
;;  Ý(set (match_operand:DI 0 "general_operand" "=d,???m")
;;        (match_operand:DI 1 "general_operand" "???m,d"))¨
;;
;;  ""
;;  "*
;;{
;;  check_label_emit ();
;;  if (REG_P (operandsÝ0¨))
;;    {
;;      mvs_check_page (0, 8, 0);
;;      return \"L	%0,%1\;L	%N0,4+%1\";
;;    }
;;  else if (REG_P (operandsÝ1¨))
;;    {
;;      mvs_check_page (0, 8, 0);
;;      return \"ST	%1,%0\;ST	%N1,4+%0\";
;;    }
;;  mvs_check_page (0, 6, 8);
;;  return \"MVC	%O0(8,%R0),%1\";
;;}"
;;   Ý(set_attr "length" "8")¨
;;)

;
; movsi instruction pattern(s).
;

; For some reason, presumably a bug somewhere, we need to use
; "R" in the constraint rather than "S", otherwise it doesn't
; allow MVCs to be generated in circumstances where it should.
; Using "R" is harmless enough in this circumstance though.

(define_insn "movsi"
  Ý(set (match_operand:SI 0 "nonimmediate_operand" "=d,dm,R")
	(match_operand:SI 1 "general_operand" "dimF,*fd,R"))¨
  ""
  "*
{
  check_label_emit ();
  if (REG_P (operandsÝ0¨))
    {
      if (FP_REG_P (operandsÝ1¨))
	{
	  mvs_check_page (0, 8, 0);
	  return \"STE	%1,\" CONVLO \"(,13)\;L	%0,\" CONVLO \"(,13)\";
	}
      if (REG_P (operandsÝ1¨))
	{
	  mvs_check_page (0, 2, 0);
	  return \"LR	%0,%1\";
	}
      if (operandsÝ1¨ == const0_rtx)
	{
	  CC_STATUS_INIT;
	  mvs_check_page (0, 2, 0);
	  return \"SLR	%0,%0\";
	}
      if (GET_CODE (operandsÝ1¨) == CONST_INT
	  && (unsigned) INTVAL (operandsÝ1¨) < 4096)
	{
	  mvs_check_page (0, 4, 0);
	  return \"LA	%0,%c1(0,0)\";
	}
      mvs_check_page (0, 4, 0);
      return \"L	%0,%1\";
    }
  else if (FP_REG_P (operandsÝ1¨))
    {
      mvs_check_page (0, 4, 0);
      return \"STE	%1,%0\";
    }
  else if (!REG_P (operandsÝ1¨))
    {
      mvs_check_page (0, 6, 0);
      return \"MVC	%O0(4,%R0),%1\";
    }
  mvs_check_page (0, 4, 0);
  return \"ST	%1,%0\";
}"
   Ý(set_attr "length" "8")¨
)

;
; movhi instruction pattern(s).
;

(define_insn ""
  Ý(set (match_operand:HI 0 "r_or_s_operand" "=R,d")
        (match_operand:HI 1 "general_operand" "R,g"))¨
  "TARGET_CHAR_INSTRUCTIONS"
  "*
{
  check_label_emit ();
  if (REG_P (operandsÝ0¨))
    {
      if (REG_P (operandsÝ1¨))
	{
	  mvs_check_page (0, 2, 0);
	  return \"LR	%0,%1\";
	}
      if (operandsÝ1¨ == const0_rtx)
	{
	  CC_STATUS_INIT;
	  mvs_check_page (0, 2, 0);
	  return \"SLR	%0,%0\";
	}
      if (GET_CODE (operandsÝ1¨) == CONST_INT
	  && (unsigned) INTVAL (operandsÝ1¨) < 4096)
	{
	  mvs_check_page (0, 4, 0);
	  return \"LA	%0,%c1(0,0)\";
	}
      if (GET_CODE (operandsÝ1¨) == CONST_INT)
	{
	  mvs_check_page (0, 4, 2);
	  return \"LH	%0,%H1\";
	}
      mvs_check_page (0, 4, 0);
      return \"LH	%0,%1\";
    }
  else if (REG_P (operandsÝ1¨))
    {
      mvs_check_page (0, 4, 0);
      return \"STH	%1,%0\";
    }
  if (GET_CODE (operandsÝ1¨) == CONST_INT)
    {
      mvs_check_page (0, 6, 2);
      return \"MVC	%O0(2,%R0),%H1\";
    }
  mvs_check_page (0, 6, 0);
  return \"MVC	%O0(2,%R0),%1\";
}"
   Ý(set_attr "length" "6")¨
)

(define_insn "movhi"
  Ý(set (match_operand:HI 0 "nonimmediate_operand" "=d,m")
	(match_operand:HI 1 "general_operand" "g,d"))¨
  ""
  "*
{
  check_label_emit ();
  if (REG_P (operandsÝ0¨))
    {
      if (REG_P (operandsÝ1¨))
	{
	  mvs_check_page (0, 2, 0);
	  return \"LR	%0,%1\";
	}
      if (operandsÝ1¨ == const0_rtx)
	{
	  CC_STATUS_INIT;
	  mvs_check_page (0, 2, 0);
	  return \"SLR	%0,%0\";
	}
      if (GET_CODE (operandsÝ1¨) == CONST_INT
	  && (unsigned) INTVAL (operandsÝ1¨) < 4096)
	{
	  mvs_check_page (0, 4, 0);
	  return \"LA	%0,%c1(0,0)\";
	}
      if (GET_CODE (operandsÝ1¨) == CONST_INT)
	{
	  mvs_check_page (0, 4, 2);
	  return \"LH	%0,%H1\";
	}
      mvs_check_page (0, 4, 0);
      return \"LH	%0,%1\";
    }
  mvs_check_page (0, 4, 0);
  return \"STH	%1,%0\";
}"
   Ý(set_attr "length" "4")¨
)

;
; movqi instruction pattern(s).
;

(define_insn ""
  Ý(set (match_operand:QI 0 "r_or_s_operand" "=R,d")
	(match_operand:QI 1 "general_operand" "R,g"))¨
  "TARGET_CHAR_INSTRUCTIONS"
  "*
{
  check_label_emit ();
  if (REG_P (operandsÝ0¨))
    {
      if (REG_P (operandsÝ1¨))
	{
	  mvs_check_page (0, 2, 0);
	  return \"LR	%0,%1\";
	}
      if (operandsÝ1¨ == const0_rtx)
	{
	  CC_STATUS_INIT;
	  mvs_check_page (0, 2, 0);
	  return \"SLR	%0,%0\";
	}
      if (GET_CODE (operandsÝ1¨) == CONST_INT)
	{
	  if ((INTVAL (operandsÝ1¨) >= 0)
  	      && (unsigned) INTVAL (operandsÝ1¨) < 4096)
	    {
	      mvs_check_page (0, 4, 0);
	      return \"LA	%0,%c1(0,0)\";
	    }
	  mvs_check_page (0, 4, 4);
	  return \"L	%0,=F'%c1'\";
	}
      mvs_check_page (0, 4, 0);
      return \"IC	%0,%1\";
    }
  else if (REG_P (operandsÝ1¨))
    {
      mvs_check_page (0, 4, 0);
      return \"STC	%1,%0\";
    }
  else if (GET_CODE (operandsÝ1¨) == CONST_INT)
    {
      mvs_check_page (0, 4, 0);
      return \"MVI	%0,%B1\";
    }
  mvs_check_page (0, 6, 0);
  return \"MVC	%O0(1,%R0),%1\";
}"
   Ý(set_attr "length" "6")¨
)

(define_insn "movqi"
  Ý(set (match_operand:QI 0 "nonimmediate_operand" "=d,m")
	(match_operand:QI 1 "general_operand" "g,d"))¨
  ""
  "*
{
  check_label_emit ();
  if (REG_P (operandsÝ0¨))
    {
      if (REG_P (operandsÝ1¨))
	{
	  mvs_check_page (0, 2, 0);
	  return \"LR	%0,%1\";
	}
      if (operandsÝ1¨ == const0_rtx)
	{
	  CC_STATUS_INIT;
	  mvs_check_page (0, 2, 0);
	  return \"SLR	%0,%0\";
	}
      if (GET_CODE (operandsÝ1¨) == CONST_INT)
	{
	  if ((INTVAL (operandsÝ1¨) >= 0)
  	      && (unsigned) INTVAL (operandsÝ1¨) < 4096)
	    {
	      mvs_check_page (0, 4, 0);
	      return \"LA	%0,%c1(0,0)\";
	    }
	  mvs_check_page (0, 4, 4);
	  return \"L	%0,=F'%c1'\";
	}
      mvs_check_page (0, 4, 0);
      return \"IC	%0,%1\";
    }
  mvs_check_page (0, 4, 0);
  return \"STC	%1,%0\";
}"
   Ý(set_attr "length" "4")¨
)

;
; movstrictqi instruction pattern(s).
;
; Need to comment this out in 3.4.6 because otherwise we are
; getting an IC generated followed by a branch, when there
; should have been an intervening compare.

;(define_insn "movstrictqi"
;  Ý(set (strict_low_part (match_operand:QI 0 "nonimmediate_operand" "+d"))
;   (match_operand:QI 1 "general_operand" "g"))¨
;  ""
;  "*
;{
;  check_label_emit ();
;  if (REG_P (operandsÝ1¨))
;    {
;      mvs_check_page (0, 8, 0);
;      return \"STC	%1,\" CONVLO \"(,13)\;IC	%0,\" CONVLO \"(,13)\";
;    }
;  mvs_check_page (0, 4, 0);
;  return \"IC	%0,=XL1'%X1'\";
;}"
;   Ý(set_attr "length" "8")¨
;)

;
; movstricthi instruction pattern(s).
;
; Need to comment this out in 3.4.6 because otherwise we are
; getting code like this (example from stdio):

; SLR   2,2
; IC    2,0(8)
; LA    5,92(0,0)
; CLR   2,5
; BE    L699
; BH    L702
; ICM   5,3,=H'64'
; BE    L696
; ICM   5,3,=H'78'
; BE    L694

; ie using ICM instead of LA, and then failing to actually do
; the compare! Was causing a branch to not be done (for the "+")
; in stdio ; when doing printf("%+d")

;(define_insn ""
;  Ý(set (strict_low_part (match_operand:HI 0 "register_operand" "+d"))
;	(match_operand:HI 1 "general_operand" "dSi"))¨
;  ""
;  "*
;{
;  check_label_emit ();
;  if (REG_P (operandsÝ1¨))
;    {
;      mvs_check_page (0, 8, 0);
;      return \"STH	%1,\" CONVLO \"(,13)\;ICM	%0,3,\" CONVLO \"(13)\";
;    }
;  else if (GET_CODE (operandsÝ1¨) == CONST_INT)
;    {
;      mvs_check_page (0, 4, 2);
;      return \"ICM	%0,3,%H1\";
;    }
;  mvs_check_page (0, 4, 0);
;  return \"ICM	%0,3,%1\";
;}"
;   Ý(set_attr "length" "8")¨
;)

(define_insn "movstricthi"
  Ý(set (strict_low_part (match_operand:HI 0 "nonimmediate_operand" "+dm"))
	(match_operand:HI 1 "general_operand" "d"))¨
  ""
  "*
{
  check_label_emit ();
  if (REG_P (operandsÝ0¨))
    {
      mvs_check_page (0, 8, 0);
      return \"STH	%1,\" CONVLO \"(,13)\;ICM	%0,3,\" CONVLO \"(13)\";
    }
  mvs_check_page (0, 4, 0);
  return \"STH	%1,%0\";
}"
   Ý(set_attr "length" "8")¨
)

;
; movdf instruction pattern(s).
;

(define_insn ""
;;  Ý(set (match_operand:DF 0 "r_or_s_operand" "=fm,fm,*dm")
;;        (match_operand:DF 1 "r_or_s_operand" "fmF,*dm,fmF"))¨
  Ý(set (match_operand:DF 0 "nonimmediate_operand" "=f,m,fS,*dS,???d")
      (match_operand:DF 1 "general_operand" "fmF,f,*dS,fSF,???d"))¨
  "TARGET_CHAR_INSTRUCTIONS"
  "*
{
  check_label_emit ();
  if (FP_REG_P (operandsÝ0¨))
    {
      if (FP_REG_P (operandsÝ1¨))
	{
	  mvs_check_page (0, 2, 0);
	  return \"LDR	%0,%1\";
	}
      if (REG_P (operandsÝ1¨))
	{
	  mvs_check_page (0, 8, 0);
	  return \"STM	%1,%N1,\" CONVLO \"(13)\;LD	%0,\" CONVLO \"(,13)\";
	}
      if (operandsÝ1¨ == const0_rtx)
	{
	  CC_STATUS_SET (operandsÝ0¨, operandsÝ1¨);
	  mvs_check_page (0, 2, 0);
	  return \"SDR	%0,%0\";
	}
      mvs_check_page (0, 4, 0);
      return \"LD	%0,%1\";
    }
  if (REG_P (operandsÝ0¨))
    {
      if (FP_REG_P (operandsÝ1¨))
	{
	  mvs_check_page (0, 12, 0);
	  return \"STD	%1,\" CONVLO \"(,13)\;LM	%0,%N0,\" CONVLO \"(13)\";
	}
      if (REG_P (operandsÝ1¨))
	{
	  mvs_check_page (0, 4, 0);
	  return \"LR	%0,%1\;LR	%N0,%N1\";
	}
      mvs_check_page (0, 4, 0);
      return \"LM	%0,%N0,%1\";
      /*return \"L	%0,%1\;L	%N0,4+%1\";*/
    }
  else if (FP_REG_P (operandsÝ1¨))
    {
      mvs_check_page (0, 4, 0);
      return \"STD	%1,%0\";
    }
  else if (REG_P (operandsÝ1¨))
    {
      mvs_check_page (0, 4, 0);
      /*return \"STM	%1,%N1,%0\"; */
      return \"ST	%1,%0\;ST	%N1,4+%0\";
    }
  mvs_check_page (0, 6, 8);
  return \"MVC	%O0(8,%R0),%1\";
}"
   Ý(set_attr "length" "12")¨
)

(define_insn "movdf"
;;  Ý(set (match_operand:DF 0 "general_operand" "=f,fm,m,*d")
;;	(match_operand:DF 1 "general_operand" "fmF,*d,f,fmF"))¨
  Ý(set (match_operand:DF 0 "nonimmediate_operand" "=f,m,fS,*d,???d")
      (match_operand:DF 1 "general_operand" "fmF,f,*d,SfF,???d"))¨
  ""
  "*
{
  check_label_emit ();
  if (FP_REG_P (operandsÝ0¨))
    {
      if (FP_REG_P (operandsÝ1¨))
	{
	  mvs_check_page (0, 2, 0);
	  return \"LDR	%0,%1\";
	}
      if (REG_P (operandsÝ1¨))
	{
	  mvs_check_page (0, 8, 0);
	  return \"STM	%1,%N1,\" CONVLO \"(13)\;LD	%0,\" CONVLO \"(,13)\";
	}
      if (operandsÝ1¨ == const0_rtx)
	{
	  CC_STATUS_SET (operandsÝ0¨, operandsÝ1¨);
	  mvs_check_page (0, 2, 0);
	  return \"SDR	%0,%0\";
	}
      mvs_check_page (0, 4, 0);
      return \"LD	%0,%1\";
    }
  else if (REG_P (operandsÝ0¨))
    {
      if (FP_REG_P (operandsÝ1¨))
	{
	  mvs_check_page (0, 12, 0);
	  return \"STD	%1,\" CONVLO \"(,13)\;LM	%0,%N0,\" CONVLO \"(13)\";
	}
      if (REG_P (operandsÝ1¨))
	{
	  mvs_check_page (0, 4, 0);
	  return \"LR	%0,%1\;LR	%N0,%N1\";
	}
      mvs_check_page (0, 4, 0);
      /*return \"LM	%0,%N0,%1\";*/
      return \"L	%0,%1\;L	%N0,4+%1\";
    }
  else if (FP_REG_P (operandsÝ1¨))
    {
      mvs_check_page (0, 4, 0);
      return \"STD	%1,%0\";
    }
  mvs_check_page (0, 4, 0);
  /*return \"STM	%1,%N1,%0\"; */
  return \"ST	%1,%0\;ST	%N1,4+%0\";
}"
   Ý(set_attr "length" "12")¨
)

;
; movsf instruction pattern(s).
;

(define_insn ""
;;  Ý(set (match_operand:SF 0 "r_or_s_operand" "=fm,fm,*dm")
;;        (match_operand:SF 1 "r_or_s_operand" "fmF,*dm,fmF"))¨
;;  Ý(set (match_operand:SF 0 "general_operand" "=f,m,fm,*d,S")
;;         (match_operand:SF 1 "general_operand" "fmF,fF,*d,fmF,S"))¨
  Ý(set (match_operand:SF 0 "nonimmediate_operand" "=f*d,fm,S,???d")
        (match_operand:SF 1 "general_operand" "fmF,fF*d,S,???d"))¨
  "TARGET_CHAR_INSTRUCTIONS"
  "*
{
  check_label_emit ();
  if (FP_REG_P (operandsÝ0¨))
    {
      if (FP_REG_P (operandsÝ1¨))
	{
	  mvs_check_page (0, 2, 0);
	  return \"LER	%0,%1\";
	}
      if (REG_P (operandsÝ1¨))
	{
	  mvs_check_page (0, 8, 0);
	  return \"ST	%1,\" CONVLO \"(,13)\;LE	%0,\" CONVLO \"(,13)\";
	}
      if (operandsÝ1¨ == const0_rtx)
	{
	  CC_STATUS_SET (operandsÝ0¨, operandsÝ1¨);
	  mvs_check_page (0, 2, 0);
	  return \"SER	%0,%0\";
	}
      mvs_check_page (0, 4, 0);
      return \"LE	%0,%1\";
    }
  else if (REG_P (operandsÝ0¨))
    {
      if (FP_REG_P (operandsÝ1¨))
	{
	  mvs_check_page (0, 8, 0);
	  return \"STE	%1,\" CONVLO \"(,13)\;L	%0,\" CONVLO \"(,13)\";
	}
      if (REG_P (operandsÝ1¨))
	{
	  mvs_check_page (0, 2, 0);
	  return \"LR	%0,%1\";
	}
      mvs_check_page (0, 4, 0);
      return \"L	%0,%1\";
    }
  else if (FP_REG_P (operandsÝ1¨))
    {
      mvs_check_page (0, 4, 0);
      return \"STE	%1,%0\";
    }
  else if (REG_P (operandsÝ1¨))
    {
      mvs_check_page (0, 4, 0);
      return \"ST	%1,%0\";
    }
  mvs_check_page (0, 6, 0);
  return \"MVC	%O0(4,%R0),%1\";
}"
   Ý(set_attr "length" "8")¨
)

(define_insn "movsf"
  Ý(set (match_operand:SF 0 "nonimmediate_operand" "=f,fm,m,*d")
	(match_operand:SF 1 "general_operand" "fmF,*d,f,fmF"))¨
  ""
  "*
{
  check_label_emit ();
  if (FP_REG_P (operandsÝ0¨))
    {
      if (FP_REG_P (operandsÝ1¨))
	{
	  mvs_check_page (0, 2, 0);
	  return \"LER	%0,%1\";
	}
      if (REG_P (operandsÝ1¨))
	{
	  mvs_check_page (0, 8, 0);
	  return \"ST	%1,\" CONVLO \"(,13)\;LE	%0,\" CONVLO \"(,13)\";
	}
      if (operandsÝ1¨ == const0_rtx)
	{
	  CC_STATUS_SET (operandsÝ0¨, operandsÝ1¨);
	  mvs_check_page (0, 2, 0);
	  return \"SER	%0,%0\";
	}
      mvs_check_page (0, 4, 0);
      return \"LE	%0,%1\";
    }
  else if (REG_P (operandsÝ0¨))
    {
      if (FP_REG_P (operandsÝ1¨))
	{
	  mvs_check_page (0, 8, 0);
	  return \"STE	%1,\" CONVLO \"(,13)\;L	%0,\" CONVLO \"(,13)\";
	}
      mvs_check_page (0, 4, 0);
      return \"L	%0,%1\";
    }
  else if (FP_REG_P (operandsÝ1¨))
    {
      mvs_check_page (0, 4, 0);
      return \"STE	%1,%0\";
    }
  mvs_check_page (0, 4, 0);
  return \"ST	%1,%0\";
}"
   Ý(set_attr "length" "8")¨
)

;
; clrstrsi instruction pattern(s).
; memset a block of bytes to zero.
; block must be less than 16M (24 bits) in length
;
(define_expand "clrstrsi"
  Ý(set (match_operand:BLK 0 "general_operand" "g")
        (const_int 0))
   (use (match_operand:SI  1 "general_operand" ""))
   (match_operand 2 "" "")¨
   ""
   "
{
  {
        /* implementation suggested by  Richard Henderson <rth@cygnus.com> */
        rtx reg1 = gen_reg_rtx (DImode);
        rtx reg2 = gen_reg_rtx (DImode);
        rtx mem1 = operandsÝ0¨;
        rtx zippo = gen_rtx_CONST_INT (SImode, 0);
        rtx len = operandsÝ1¨;
        if (!CONSTANT_P (len))
          len = force_reg (SImode, len);

        /* Load up the address+length pairs.  */
        emit_insn (gen_rtx_CLOBBER (VOIDmode, reg1));
        emit_move_insn (gen_rtx_SUBREG (SImode, reg1, 0),
                        force_operand (XEXP (mem1, 0), NULL_RTX));
        emit_move_insn (gen_rtx_SUBREG (SImode, reg1, GET_MODE_SIZE (SImode)), len);

        emit_insn (gen_rtx_CLOBBER (VOIDmode, reg2));
        emit_move_insn (gen_rtx_SUBREG (SImode, reg2, 0), zippo);
        emit_move_insn (gen_rtx_SUBREG (SImode, reg2, GET_MODE_SIZE (SImode)), zippo);

        /* Copy! */
        emit_insn (gen_movstrsi_1 (reg1, reg2));
  }
  DONE;
}")

;
; movstrsi instruction pattern(s).
; block must be less than 16M (24 bits) in length

(define_expand "movstrsi"
  Ý(set (match_operand:BLK 0 "general_operand" "")
        (match_operand:BLK 1 "general_operand" ""))
   (use (match_operand:SI  2 "general_operand" ""))
   (match_operand 3 "" "")¨
   ""
   "
{
  rtx op0, op1;

  op0 = XEXP (operandsÝ0¨, 0);
  if (GET_CODE (op0) == REG
      || (GET_CODE (op0) == PLUS && GET_CODE (XEXP (op0, 0)) == REG
	  && GET_CODE (XEXP (op0, 1)) == CONST_INT
	  && (unsigned) INTVAL (XEXP (op0, 1)) < 4096))
    op0 = operandsÝ0¨;
  else
    op0 = replace_equiv_address (operandsÝ0¨, copy_to_mode_reg (SImode, op0));

  op1 = XEXP (operandsÝ1¨, 0);
  if (GET_CODE (op1) == REG
      || (GET_CODE (op1) == PLUS && GET_CODE (XEXP (op1, 0)) == REG
	  && GET_CODE (XEXP (op1, 1)) == CONST_INT
	  && (unsigned) INTVAL (XEXP (op1, 1)) < 4096))
    op1 = operandsÝ1¨;
  else
    op1 = replace_equiv_address (operandsÝ1¨, copy_to_mode_reg (SImode, op1));

  if (GET_CODE (operandsÝ2¨) == CONST_INT && INTVAL (operandsÝ2¨) < 256)
    emit_insn (gen_rtx_PARALLEL (VOIDmode,
			gen_rtvec (2,
				   gen_rtx_SET (VOIDmode, op0, op1),
				   gen_rtx_USE (VOIDmode, operandsÝ2¨))));

  else
    {
        /* implementation provided by  Richard Henderson <rth@cygnus.com> */
        rtx reg1 = gen_reg_rtx (DImode);
        rtx reg2 = gen_reg_rtx (DImode);
        rtx mem1 = operandsÝ0¨;
        rtx mem2 = operandsÝ1¨;
        rtx len = operandsÝ2¨;
        if (!CONSTANT_P (len))
          len = force_reg (SImode, len);

        /* Load up the address+length pairs.  */
        emit_insn (gen_rtx_CLOBBER (VOIDmode, reg1));
        emit_move_insn (gen_rtx_SUBREG (SImode, reg1, 0),
                        force_operand (XEXP (mem1, 0), NULL_RTX));
        emit_move_insn (gen_rtx_SUBREG (SImode, reg1, GET_MODE_SIZE (SImode)), len);

        emit_insn (gen_rtx_CLOBBER (VOIDmode, reg2));
        emit_move_insn (gen_rtx_SUBREG (SImode, reg2, 0),
                        force_operand (XEXP (mem2, 0), NULL_RTX));
        emit_move_insn (gen_rtx_SUBREG (SImode, reg2, GET_MODE_SIZE (SImode)), len);

        /* Copy! */
        emit_insn (gen_movstrsi_1 (reg1, reg2));
    }
  DONE;
}")

; Move a block that is less than 256 bytes in length.

(define_insn ""
  Ý(set (match_operand:BLK 0 "s_operand" "=m")
	(match_operand:BLK 1 "s_operand" "m"))
   (use (match_operand 2 "immediate_operand" "I"))¨
  "((unsigned) INTVAL (operandsÝ2¨) < 256)"
  "*
{
  check_label_emit ();
  mvs_check_page (0, 6, 0);
  return \"MVC	%O0(%c2,%R0),%1\";
}"
   Ý(set_attr "length" "6")¨
)

; Move a block that is larger than 255 bytes in length.
;  Ý(set (mem:BLK (subreg:SI (match_operand:DI 0 "register_operand" "+d") 0))
;        (mem:BLK (subreg:SI (match_operand:DI 1 "register_operand" "+d") 0)))

(define_insn "movstrsi_1"
  Ý(set (mem:BLK (match_operand:DI 0 "register_operand" "+d") )
        (mem:BLK (match_operand:DI 1 "register_operand" "+d") ))
   (use (match_dup 0))
   (use (match_dup 1))
   (clobber (match_dup 0))
   (clobber (match_dup 1))¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 2, 0);
  return \"MVCL	%0,%1\";
}"
   Ý(set_attr "length" "2")¨
)

;;
;;- Conversion instructions.
;;

;
; extendsidi2 instruction pattern(s).
;

(define_expand "extendsidi2"
  Ý(set (match_operand:DI 0 "register_operand" "=d")
        (sign_extend:DI (match_operand:SI 1 "general_operand" "")))¨
  ""
  "
{
  if (GET_CODE (operandsÝ1¨) != CONST_INT)
    {
      emit_insn (gen_rtx_SET (VOIDmode,
		  operand_subword (operandsÝ0¨, 0, 1, DImode), operandsÝ1¨));
      emit_insn (gen_rtx_SET (VOIDmode, operandsÝ0¨,
			gen_rtx_ASHIFTRT (DImode, operandsÝ0¨,
				gen_rtx_CONST_INT (SImode, 32))));
    }
  else
    {
      if (INTVAL (operandsÝ1¨) < 0)
	{
	  emit_insn (gen_rtx_SET (VOIDmode,
				  operand_subword (operandsÝ0¨, 0, 1, DImode),
			       gen_rtx_CONST_INT (SImode, -1)));
        }
      else
	{
	  emit_insn (gen_rtx_SET (VOIDmode,
				operand_subword (operandsÝ0¨, 0, 1, DImode),
			       gen_rtx_CONST_INT (SImode, 0)));
        }
      emit_insn (gen_rtx_SET (VOIDmode, gen_lowpart (SImode, operandsÝ0¨),
			   operandsÝ1¨));
    }
  DONE;
}")

;
; extendhisi2 instruction pattern(s).
;

(define_insn "extendhisi2"
  Ý(set (match_operand:SI 0 "nonimmediate_operand" "=d,m")
	(sign_extend:SI (match_operand:HI 1 "general_operand" "g,d")))¨
  ""
  "*
{
  check_label_emit ();
  if (REG_P (operandsÝ0¨))
    {
      if (REG_P (operandsÝ1¨))
      {
        if (REGNO (operandsÝ0¨) != REGNO (operandsÝ1¨))
	  {
	    mvs_check_page (0, 10, 0);
            return \"LR	%0,%1\;SLL	%0,16\;SRA	%0,16\";
	  }
        else
          return \"\"; /* Should be empty.  16-bits regs are always 32-bits.  */
      }
      if (operandsÝ1¨ == const0_rtx)
	{
	  CC_STATUS_INIT;
	  mvs_check_page (0, 2, 0);
	  return \"SLR	%0,%0\";
	}
      if (GET_CODE (operandsÝ1¨) == CONST_INT
 	  && (unsigned) INTVAL (operandsÝ1¨) < 4096)
	{
	  mvs_check_page (0, 4, 0);
	  return \"LA	%0,%c1(0,0)\";
	}
      if (GET_CODE (operandsÝ1¨) == CONST_INT)
	{
	  mvs_check_page (0, 4, 2);
	  return \"LH	%0,%H1\";
	}
      mvs_check_page (0, 4, 0);
      return \"LH	%0,%1\";
    }
  mvs_check_page (0, 12, 0);
  return \"SLL	%1,16\;SRA	%1,16\;ST	%1,%0\";
}"
   Ý(set_attr "length" "12")¨
)

;
; extendqisi2 instruction pattern(s).
;

(define_insn "extendqisi2"
  Ý(set (match_operand:SI 0 "nonimmediate_operand" "=d")
	(sign_extend:SI (match_operand:QI 1 "general_operand" "0mi")))¨
  ""
  "*
{
  check_label_emit ();
  CC_STATUS_SET (operandsÝ0¨, operandsÝ1¨);
  if (REG_P (operandsÝ1¨))
    {
      mvs_check_page (0, 8, 0);
      return \"SLL	%0,24\;SRA	%0,24\";
    }
  if (s_operand (operandsÝ1¨, GET_MODE (operandsÝ1¨)))
    {
      mvs_check_page (0, 8, 0);
      return \"ICM	%0,8,%1\;SRA	%0,24\";
    }
  mvs_check_page (0, 12, 0);
  return \"IC	%0,%1\;SLL	%0,24\;SRA	%0,24\";
}"
   Ý(set_attr "length" "12")¨
)

;
; extendqihi2 instruction pattern(s).
;

(define_insn "extendqihi2"
  Ý(set (match_operand:HI 0 "nonimmediate_operand" "=d")
	(sign_extend:HI (match_operand:QI 1 "general_operand" "0m")))¨
  ""
  "*
{
  check_label_emit ();
  CC_STATUS_SET (operandsÝ0¨, operandsÝ1¨);
  if (REG_P (operandsÝ1¨))
    {
      mvs_check_page (0, 8, 0);
      return \"SLL	%0,24\;SRA	%0,24\";
    }
  if (s_operand (operandsÝ1¨, GET_MODE (operandsÝ1¨)))
    {
      mvs_check_page (0, 8, 0);
      return \"ICM	%0,8,%1\;SRA	%0,24\";
    }
  mvs_check_page (0, 12, 0);
  return \"IC	%0,%1\;SLL	%0,24\;SRA	%0,24\";
}"
   Ý(set_attr "length" "12")¨
)

;
; zero_extendsidi2 instruction pattern(s).
;

(define_expand "zero_extendsidi2"
  Ý(set (match_operand:DI 0 "register_operand" "=d")
        (zero_extend:DI (match_operand:SI 1 "general_operand" "")))¨
  ""
  "
{
      emit_insn (gen_rtx_SET (VOIDmode,
		  operand_subword (operandsÝ0¨, 0, 1, DImode), operandsÝ1¨));
      emit_insn (gen_rtx_SET (VOIDmode, operandsÝ0¨,
			gen_rtx_LSHIFTRT (DImode, operandsÝ0¨,
				gen_rtx_CONST_INT (SImode, 32))));
  DONE;
}")

;
; zero_extendhisi2 instruction pattern(s).
;

(define_insn "zero_extendhisi2"
  Ý(set (match_operand:SI 0 "nonimmediate_operand" "=d")
	(zero_extend:SI (match_operand:HI 1 "general_operand" "0")))¨
  ""
  "*
{
  check_label_emit ();
  /* AND only sets zero/not-zero bits not the arithmetic bits ...  */
  CC_STATUS_INIT;
  mvs_check_page (0, 4, 4);
  return \"N	%1,=XL4'0000FFFF'\";
}"
   Ý(set_attr "length" "4")¨
)

;
; zero_extendqisi2 instruction pattern(s).
;

(define_insn "zero_extendqisi2"
  Ý(set (match_operand:SI 0 "nonimmediate_operand" "=d,&d")
	(zero_extend:SI (match_operand:QI 1 "general_operand" "0i,m")))¨
  ""
  "*
{
  check_label_emit ();
  if (REG_P (operandsÝ1¨))
    {
      /* AND only sets zero/not-zero bits not the arithmetic bits ...  */
      CC_STATUS_INIT;
      mvs_check_page (0, 4, 4);
      return \"N	%0,=XL4'000000FF'\";
    }
  if (GET_CODE (operandsÝ1¨) == CONST_INT)
    {
      mvs_check_page (0, 4, 0);
      return \"LA	%0,%c1(0,0)\";
    }
  CC_STATUS_INIT;
  mvs_check_page (0, 8, 0);
  return \"SLR	%0,%0\;IC	%0,%1\";
}"
   Ý(set_attr "length" "8")¨
)

;
; zero_extendqihi2 instruction pattern(s).
;

(define_insn "zero_extendqihi2"
  Ý(set (match_operand:HI 0 "nonimmediate_operand" "=d,&d")
	(zero_extend:HI (match_operand:QI 1 "general_operand" "0i,m")))¨
  ""
  "*
{
  check_label_emit ();
  if (REG_P (operandsÝ1¨))
    {
      /* AND only sets zero/not-zero bits not the arithmetic bits ...  */
      CC_STATUS_INIT;
      mvs_check_page (0, 4, 4);
      return \"N	%0,=XL4'000000FF'\";
    }
  if (GET_CODE (operandsÝ1¨) == CONST_INT)
    {
      mvs_check_page (0, 4, 0);
      return \"LA	%0,%c1(0,0)\";
    }
  CC_STATUS_INIT;
  mvs_check_page (0, 8, 0);
  return \"SLR	%0,%0\;IC	%0,%1\";
}"
   Ý(set_attr "length" "8")¨
)

;
; truncsihi2 instruction pattern(s).
;

(define_insn "truncsihi2"
  Ý(set (match_operand:HI 0 "nonimmediate_operand" "=d,m")
	(truncate:HI (match_operand:SI 1 "general_operand" "0,d")))¨
  ""
  "*
{
  check_label_emit ();
  if (REG_P (operandsÝ0¨))
    {
      CC_STATUS_SET (operandsÝ0¨, operandsÝ1¨);
      mvs_check_page (0, 8, 0);
      return \"SLL	%0,16\;SRA	%0,16\";
    }
  mvs_check_page (0, 4, 0);
  return \"STH	%1,%0\";
}"
   Ý(set_attr "length" "8")¨
)

;
; fix_truncdfsi2 instruction pattern(s).
;

(define_insn "fix_truncdfsi2"
  Ý(set (match_operand:SI 0 "nonimmediate_operand" "=d")
        (fix:SI (truncate:DF (match_operand:DF 1 "general_operand" "f"))))
	(clobber (reg:DF 16))¨
  ""
  "*
{
  check_label_emit ();
  CC_STATUS_INIT;
  if (REGNO (operandsÝ1¨) == 16)
    {
      mvs_check_page (0, 12, 8);
      return \"AD	0,=XL8'4F08000000000000'\;STD	0,\" CONVLO \"(,13)\;L	%0,\" CONVHI \"(,13)\";
    }
  mvs_check_page (0, 14, 8);
  return \"LDR	0,%1\;AD	0,=XL8'4F08000000000000'\;STD	0,\" CONVLO \"(,13)\;L	%0,\" CONVHI \"(,13)\";
}"
   Ý(set_attr "length" "14")¨
)

;
; floatsidf2 instruction pattern(s).
;
; LE/370 mode uses the float field of the TCA.
;

(define_insn "floatsidf2"
  Ý(set (match_operand:DF 0 "nonimmediate_operand" "=f")
        (float:DF (match_operand:SI 1 "general_operand" "d")))¨
  ""
  "*
{
  check_label_emit ();
  CC_STATUS_INIT;
#if defined(TARGET_LINUX)
  mvs_check_page (0, 22, 12);
  return \"MVC	\" CONVLO \"(4,13),=XL4'4E000000'\;ST	%1,\" CONVLO \"+4(,13)\;XI	\" CONVLO \"+4(13),128\;LD	%0,\" CONVLO \"(,13)\;SD	%0,=XL8'4E00000080000000'\";
#elif defined(TARGET_DIGNUS) || defined(TARGET_PDPMAC)
  mvs_check_page (0, 22, 12);
  return \"MVC	\" CONVLO \"(4,13),=XL8'4E00000080000000'\;ST	%1,\" CONVHI \"(,13)\;XI	\" CONVHI \"(13),128\;LD	%0,\" CONVLO \"(,13)\;SD	%0,=XL8'4E00000080000000'\";
#else
  mvs_check_page (0, 16, 8);
  return \"ST	%1,508(,12)\;XI	508(12),128\;LD	%0,504(,12)\;SD	%0,=XL8'4E00000080000000'\";
#endif
}"
   Ý(set_attr "length" "22")¨
)

;
; truncdfsf2 instruction pattern(s).
;

(define_insn "truncdfsf2"
  Ý(set (match_operand:SF 0 "nonimmediate_operand" "=f")
        (float_truncate:SF (match_operand:DF 1 "general_operand" "f")))¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 2, 0);
  return \"LRER	%0,%1\";
}"
   Ý(set_attr "length" "2")¨
)

;
; extendsfdf2 instruction pattern(s).
;

(define_insn "extendsfdf2"
  Ý(set (match_operand:DF 0 "nonimmediate_operand" "=f")
        (float_extend:DF (match_operand:SF 1 "general_operand" "fmF")))¨
  ""
  "*
{
  check_label_emit ();
  CC_STATUS_SET (0, const0_rtx);
  if (FP_REG_P (operandsÝ1¨))
    {
      if (REGNO (operandsÝ0¨) == REGNO (operandsÝ1¨))
	{
	  mvs_check_page (0, 10, 0);
	  return \"STE	%1,\" CONVLO \"(,13)\;SDR	%0,%0\;LE	%0,\" CONVLO \"(,13)\";
	}
      mvs_check_page (0, 4, 0);
      return \"SDR	%0,%0\;LER	%0,%1\";
    }
  mvs_check_page (0, 6, 0);
  return \"SDR	%0,%0\;LE	%0,%1\";
}"
   Ý(set_attr "length" "10")¨
)

;;
;;- Add instructions.
;;

;
; adddi3 instruction pattern(s).
;
;
;(define_expand "adddi3"
;  Ý(set (match_operand:DI 0 "general_operand" "")
;	(plus:DI (match_operand:DI 1 "general_operand" "")
;		 (match_operand:DI 2 "general_operand" "")))¨
;  ""
;  "
;{
;  rtx label = gen_label_rtx ();
;  rtx op0_high = operand_subword (operandsÝ0¨, 0, 1, DImode);
;  rtx op0_low = gen_lowpart (SImode, operandsÝ0¨);
;
;  emit_insn (gen_rtx_SET (VOIDmode, op0_high,
;		    gen_rtx_PLUS (SImode,
;			    operand_subword (operandsÝ1¨, 0, 1, DImode),
;			    operand_subword (operandsÝ2¨, 0, 1, DImode))));
;  emit_jump_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2,
;	      gen_rtx_SET (VOIDmode, op0_low,
;		      gen_rtx_PLUS (SImode, gen_lowpart (SImode, operandsÝ1¨),
;			      gen_lowpart (SImode, operandsÝ2¨))),
;	      gen_rtx_USE (VOIDmode, gen_rtx_LABEL_REF (VOIDmode, label)))));
;  emit_insn (gen_rtx_SET (VOIDmode, op0_high,
;		    gen_rtx_PLUS (SImode, op0_high,
;			    gen_rtx_CONST_INT (SImode, 1))));
;  emit_label (label);
;  DONE;
;}")

(define_insn ""
  Ý(set (match_operand:SI 0 "nonimmediate_operand" "=d")
	(plus:SI (match_operand:SI 1 "general_operand" "%0")
		 (match_operand:SI 2 "general_operand" "g")))
   (use (label_ref (match_operand 3 "" "")))
;   (clobber (reg:SI 14))
   ¨
  ""
  "*
{
  int onpage;

  check_label_emit ();
  onpage = mvs_check_label (CODE_LABEL_NUMBER (operandsÝ3¨));
  if (REG_P (operandsÝ2¨))
    {
      if (!onpage)
	{
	  mvs_check_page (0, 8, 4);
	  return \"ALR	%0,%2\;L	14,=A(%l3)\;BCR	12,14\";
	}
      if (mvs_check_page (0, 6, 0))
	{
	  mvs_check_page (0, 2, 4);
	  return \"ALR	%0,%2\;L	14,=A(%l3)\;BCR	12,14\";
	}
      return \"ALR	%0,%2\;BC	12,%l3\";
    }
  if (!onpage)
    {
      mvs_check_page (0, 10, 4);
      return \"AL	%0,%2\;L	14,=A(%l3)\;BCR	12,14\";
    }
  if (mvs_check_page (0, 8 ,0))
    {
      mvs_check_page (0, 2, 4);
      return \"AL	%0,%2\;L	14,=A(%l3)\;BCR	12,14\";
    }
  return \"AL	%0,%2\;BC	12,%l3\";
}"
   Ý(set_attr "length" "10")¨
)

;
; addsi3 instruction pattern(s).
;
; The following insn is used when it is known that operand one is an address,
; frame, stack or argument pointer, and operand two is a constant that is
; small enough to fit in the displacement field.
; Notice that we can't allow the frame pointer to used as a normal register
; because of this insn.
;

(define_insn ""
  Ý(set (match_operand:SI 0 "register_operand" "=d")
	(plus:SI (match_operand:SI 1 "general_operand" "%a")
		 (match_operand:SI 2 "immediate_operand" "J")))¨
  "((REGNO (operandsÝ1¨) == FRAME_POINTER_REGNUM || REGNO (operandsÝ1¨) == ARG_POINTER_REGNUM || REGNO (operandsÝ1¨) == STACK_POINTER_REGNUM) && (unsigned) INTVAL (operandsÝ2¨) < 4096)"
  "*
{
  check_label_emit ();
  CC_STATUS_INIT;  /* add assumes CC but LA doesn't set CC */
  mvs_check_page (0, 4, 0);
  return \"LA	%0,%c2(,%1)\";
}"
   Ý(set_attr "length" "4")¨
)

; This insn handles additions that are relative to the frame pointer.

(define_insn ""
  Ý(set (match_operand:SI 0 "register_operand" "=d")
         (plus:SI (match_operand:SI 1 "register_operand" "%a")
                  (match_operand:SI 2 "immediate_operand" "i")))¨
  "REGNO (operandsÝ1¨) == FRAME_POINTER_REGNUM"
  "*
{
  check_label_emit ();
  if ((unsigned) INTVAL (operandsÝ2¨) < 4096)
    {
      CC_STATUS_INIT;  /* add assumes CC but LA doesn't set CC */
      mvs_check_page (0, 4, 0);
      return \"LA	%0,%c2(,%1)\";
    }
  if (REGNO (operandsÝ1¨) == REGNO (operandsÝ0¨))
    {
      CC_STATUS_INIT;
      mvs_check_page (0, 4, 0);
      return \"A	%0,%2\";
    }
  mvs_check_page (0, 6, 0);
  return \"L	%0,%2\;AR	%0,%1\";
}"
   Ý(set_attr "length" "6")¨
)

;;
;; The CC status bits for the arithmetic instructions are handled
;; in the NOTICE_UPDATE_CC macro (yeah???) and so they do not need
;; to be set below.  They only need to be invalidated if *not* set
;; (e.g. by BCTR) ... yeah I think that's right ...
;;

(define_insn "addsi3"
  Ý(set (match_operand:SI 0 "nonimmediate_operand" "=d")
	(plus:SI (match_operand:SI 1 "general_operand" "%0")
		 (match_operand:SI 2 "general_operand" "g")))¨
  ""
  "*
{
  check_label_emit ();
  if (REG_P (operandsÝ2¨))
    {
      mvs_check_page (0, 2, 0);
      return \"AR	%0,%2\";
    }
  if (GET_CODE (operandsÝ2¨) == CONST_INT)
    {
      if (INTVAL (operandsÝ2¨) == -1)
	{
          CC_STATUS_INIT;  /* add assumes CC but BCTR doesn't set CC */
	  mvs_check_page (0, 2, 0);
	  return \"BCTR	%0,0\";
	}
    }
  mvs_check_page (0, 4, 0);
  return \"A	%0,%2\";
}"
   Ý(set_attr "length" "4")¨
)

;
; addhi3 instruction pattern(s).
;

(define_insn "addhi3"
  Ý(set (match_operand:HI 0 "nonimmediate_operand" "=d")
	(plus:HI (match_operand:HI 1 "general_operand" "%0")
		 (match_operand:HI 2 "general_operand" "dmi")))¨
  ""
  "*
{
  check_label_emit ();
  if (REG_P (operandsÝ2¨))
    {
      mvs_check_page (0, 8, 0);
      return \"STH	%2,\" CONVLO \"(,13)\;AH	%0,\" CONVLO \"(,13)\";
    }
  if (GET_CODE (operandsÝ2¨) == CONST_INT)
    {
      if (INTVAL (operandsÝ2¨) == -1)
	{
          CC_STATUS_INIT;  /* add assumes CC but BCTR doesn't set CC */
	  mvs_check_page (0, 2, 0);
	  return \"BCTR	%0,0\";
	}
      mvs_check_page (0, 4, 2);
      return \"AH	%0,%H2\";
    }
  mvs_check_page (0, 4, 0);
  return \"AH	%0,%2\";
}"
   Ý(set_attr "length" "8")¨
)

;
; addqi3 instruction pattern(s).
;

(define_insn "addqi3"
  Ý(set (match_operand:QI 0 "nonimmediate_operand" "=d")
	(plus:QI (match_operand:QI 1 "general_operand" "%a")
		 (match_operand:QI 2 "general_operand" "ai")))¨
  ""
  "*
{
  check_label_emit ();
  CC_STATUS_INIT;  /* add assumes CC but LA doesn't set CC */
  mvs_check_page (0, 4, 0);
  if (REG_P (operandsÝ2¨))
    return \"LA	%0,0(%1,%2)\";
  return \"LA	%0,%B2(,%1)\";
}"
   Ý(set_attr "length" "4")¨
)

;
; adddf3 instruction pattern(s).
;

(define_insn "adddf3"
  Ý(set (match_operand:DF 0 "nonimmediate_operand" "=f")
	(plus:DF (match_operand:DF 1 "general_operand" "%0")
		 (match_operand:DF 2 "general_operand" "fmF")))¨
  ""
  "*
{
  check_label_emit ();
  if (FP_REG_P (operandsÝ2¨))
    {
      mvs_check_page (0, 2, 0);
      return \"ADR	%0,%2\";
    }
  mvs_check_page (0, 4, 0);
  return \"AD	%0,%2\";
}"
   Ý(set_attr "length" "4")¨
)

;
; addsf3 instruction pattern(s).
;

(define_insn "addsf3"
  Ý(set (match_operand:SF 0 "nonimmediate_operand" "=f")
	(plus:SF (match_operand:SF 1 "general_operand" "%0")
		 (match_operand:SF 2 "general_operand" "fmF")))¨
  ""
  "*
{
  check_label_emit ();
  if (FP_REG_P (operandsÝ2¨))
    {
      mvs_check_page (0, 2, 0);
      return \"AER	%0,%2\";
    }
  mvs_check_page (0, 4, 0);
  return \"AE	%0,%2\";
}"
   Ý(set_attr "length" "4")¨
)

;;
;;- Subtract instructions.
;;

;
; subdi3 instruction pattern(s).
;
;
;(define_expand "subdi3"
;  Ý(set (match_operand:DI 0 "general_operand" "")
;	(minus:DI (match_operand:DI 1 "general_operand" "")
;		  (match_operand:DI 2 "general_operand" "")))¨
;  ""
;  "
;{
;  rtx label = gen_label_rtx ();
;  rtx op0_high = operand_subword (operandsÝ0¨, 0, 1, DImode);
;  rtx op0_low = gen_lowpart (SImode, operandsÝ0¨);
;
;  emit_insn (gen_rtx_SET (VOIDmode, op0_high,
;		    gen_rtx_MINUS (SImode,
;			      operand_subword (operandsÝ1¨, 0, 1, DImode),
;			      operand_subword (operandsÝ2¨, 0, 1, DImode))));
;  emit_jump_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2,
;		    gen_rtx_SET (VOIDmode, op0_low,
;			      gen_rtx_MINUS (SImode,
;				      gen_lowpart (SImode, operandsÝ1¨),
;				      gen_lowpart (SImode, operandsÝ2¨))),
;		    gen_rtx_USE (VOIDmode,
;			      gen_rtx_LABEL_REF (VOIDmode, label)))));
;  emit_insn (gen_rtx_SET (VOIDmode, op0_high,
;		      gen_rtx_MINUS (SImode, op0_high,
;			      gen_rtx_CONST_INT (SImode, 1))));
;  emit_label (label);
;  DONE;
;}")

(define_insn ""
  Ý(set (match_operand:SI 0 "nonimmediate_operand" "=d")
	(minus:SI (match_operand:SI 1 "general_operand" "0")
		  (match_operand:SI 2 "general_operand" "g")))
   (use (label_ref (match_operand 3 "" "")))
;   (clobber (reg:SI 14))
   ¨
  ""
  "*
{
  int onpage;

  check_label_emit ();
  CC_STATUS_INIT;
  onpage = mvs_check_label (CODE_LABEL_NUMBER (operandsÝ3¨));
  if (REG_P (operandsÝ2¨))
    {
      if (!onpage)
	{
	  mvs_check_page (0, 8, 4);
	  return \"SLR	%0,%2\;L	14,=A(%l3)\;BCR	12,14\";
	}
      if (mvs_check_page (0, 6, 0))
	{
	  mvs_check_page (0, 2, 4);
	  return \"SLR	%0,%2\;L	14,=A(%l3)\;BCR	12,14\";
	}
      return \"SLR	%0,%2\;BC	12,%l3\";
    }
  if (!onpage)
    {
      mvs_check_page (0, 10, 4);
      return \"SL	%0,%2\;L	14,=A(%l3)\;BCR	12,14\";
    }
  if (mvs_check_page (0, 8, 0))
    {
      mvs_check_page (0, 2, 4);
      return \"SL	%0,%2\;L	14,=A(%l3)\;BCR	12,14\";
    }
  return \"SL	%0,%2\;BC	12,%l3\";
}"
   Ý(set_attr "length" "10")¨
)

;
; subsi3 instruction pattern(s).
;

(define_insn "subsi3"
  Ý(set (match_operand:SI 0 "nonimmediate_operand" "=d")
	(minus:SI (match_operand:SI 1 "general_operand" "0")
		  (match_operand:SI 2 "general_operand" "g")))¨
  ""
  "*
{
  check_label_emit ();
  if (REG_P (operandsÝ2¨))
    {
      mvs_check_page (0, 2, 0);
      return \"SR	%0,%2\";
    }
  if (operandsÝ2¨ == const1_rtx)
    {
      CC_STATUS_INIT;  /* subtract assumes CC but BCTR doesn't set CC */
      mvs_check_page (0, 2, 0);
      return \"BCTR	%0,0\";
    }
  mvs_check_page (0, 4, 0);
  return \"S	%0,%2\";
}"
   Ý(set_attr "length" "4")¨
)

;
; subhi3 instruction pattern(s).
;

(define_insn "subhi3"
  Ý(set (match_operand:HI 0 "nonimmediate_operand" "=d")
	(minus:HI (match_operand:HI 1 "general_operand" "0")
		  (match_operand:HI 2 "general_operand" "g")))¨
  ""
  "*
{
  check_label_emit ();
  if (REG_P (operandsÝ2¨))
    {
      mvs_check_page (0, 8, 0);
      return \"STH	%2,\" CONVLO \"(,13)\;SH	%0,\" CONVLO \"(,13)\";
    }
  if (operandsÝ2¨ == const1_rtx)
    {
      CC_STATUS_INIT;  /* subtract assumes CC but BCTR doesn't set CC */
      mvs_check_page (0, 2, 0);
      return \"BCTR	%0,0\";
    }
  if (GET_CODE (operandsÝ2¨) == CONST_INT)
    {
      mvs_check_page (0, 4, 2);
      return \"SH	%0,%H2\";
    }
  mvs_check_page (0, 4, 0);
  return \"SH	%0,%2\";
}"
   Ý(set_attr "length" "8")¨
)

;
; subqi3 instruction pattern(s).
;

;(define_expand "subqi3"
;  Ý(set (match_operand:QI 0 "register_operand" "=d")
;	(minus:QI (match_operand:QI 1 "general_operand" "0")
;		  (match_operand:QI 2 "general_operand" "di")))¨
;  ""
;  "
;{
;  if (REG_P (operandsÝ2¨))
;    {
;      emit_insn (gen_rtx_SET (VOIDmode, operandsÝ0¨,
;			gen_rtx_MINUS (QImode, operandsÝ1¨, operandsÝ2¨)));
;    }
;  else
;    {
;      emit_insn (gen_rtx_SET (VOIDmode, operandsÝ0¨,
;			gen_rtx_PLUS (QImode, operandsÝ1¨,
;				 negate_rtx (QImode, operandsÝ2¨))));
;    }
;  DONE;
;}")

(define_insn "subqi3"
  Ý(set (match_operand:QI 0 "register_operand" "=d")
	(minus:QI (match_operand:QI 1 "register_operand" "0")
		 (match_operand:QI 2 "register_operand" "d")))¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 2, 0);
  return \"SR	%0,%2\";
}"
   Ý(set_attr "length" "2")¨
)

;
; subdf3 instruction pattern(s).
;

(define_insn "subdf3"
  Ý(set (match_operand:DF 0 "nonimmediate_operand" "=f")
	(minus:DF (match_operand:DF 1 "general_operand" "0")
		  (match_operand:DF 2 "general_operand" "fmF")))¨
  ""
  "*
{
  check_label_emit ();
  if (FP_REG_P (operandsÝ2¨))
    {
      mvs_check_page (0, 2, 0);
      return \"SDR	%0,%2\";
    }
  mvs_check_page (0, 4, 0);
  return \"SD	%0,%2\";
}"
   Ý(set_attr "length" "4")¨
)

;
; subsf3 instruction pattern(s).
;

(define_insn "subsf3"
  Ý(set (match_operand:SF 0 "nonimmediate_operand" "=f")
	(minus:SF (match_operand:SF 1 "general_operand" "0")
		  (match_operand:SF 2 "general_operand" "fmF")))¨
  ""
  "*
{
  check_label_emit ();
  if (FP_REG_P (operandsÝ2¨))
    {
      mvs_check_page (0, 2, 0);
      return \"SER	%0,%2\";
    }
  mvs_check_page (0, 4, 0);
  return \"SE	%0,%2\";
}"
   Ý(set_attr "length" "4")¨
)

;;
;;- Multiply instructions.
;;

;
; mulsi3 instruction pattern(s).
;

(define_expand "mulsi3"
  Ý(set (match_operand:SI 0 "general_operand" "")
	(mult:SI (match_operand:SI 1 "general_operand" "")
		 (match_operand:SI 2 "general_operand" "")))¨
  ""
  "
{
  if (GET_CODE (operandsÝ1¨) == CONST_INT
      && REG_P (operandsÝ0¨)
      && CONST_OK_FOR_LETTER_P (INTVAL (operandsÝ1¨), 'K'))
    {
      emit_insn (gen_rtx_SET (VOIDmode, operandsÝ0¨,
			  gen_rtx_MULT (SImode, operandsÝ2¨, operandsÝ1¨)));
    }
  else if (GET_CODE (operandsÝ2¨) == CONST_INT
           && REG_P (operandsÝ0¨)
	   && CONST_OK_FOR_LETTER_P (INTVAL (operandsÝ2¨), 'K'))
    {
      emit_insn (gen_rtx_SET (VOIDmode, operandsÝ0¨,
			  gen_rtx_MULT (SImode, operandsÝ1¨, operandsÝ2¨)));
    }
  else
    {
      rtx r = gen_reg_rtx (DImode);

      /* XXX trouble.  Below we generate some rtx's that model what
       * is really supposed to happen with multiply on the 370/390
       * hardware, and that is all well & good.  However, during optimization
       * it can happen that the two operands are exchanged (after all,
       * multiplication is commutitive), in which case the doubleword
       * ends up in memory and everything is hosed.  The gen_reg_rtx
       * should have kept it in a reg ...  We hack around this
       * below, in the M/MR isntruction pattern, and constrain it to
       * \"di\" instead of \"g\".  But this still ends up with lots & lots of
       * movement between registers & memory and is an awful waste.
       * Dunno how to untwist it elegantly; but it seems to work for now.

       * Note, this comment doesn't seem to be relevant for 3.4.6
       * at least, so it is being opened up.
       */
      if (GET_CODE (operandsÝ1¨) == CONST_INT)
      {
      emit_insn (gen_rtx_SET (VOIDmode,
			  gen_rtx_SUBREG (SImode, r, GET_MODE_SIZE (SImode)),
					  operandsÝ1¨));
      emit_insn (gen_rtx_SET (VOIDmode, r,
			  gen_rtx_MULT (DImode, r, operandsÝ2¨)));
      }
      else
      {
      emit_insn (gen_rtx_SET (VOIDmode,
			  gen_rtx_SUBREG (SImode, r, GET_MODE_SIZE (SImode)),
					  operandsÝ2¨));
      emit_insn (gen_rtx_SET (VOIDmode, r,
			  gen_rtx_MULT (DImode, r, operandsÝ1¨)));
      }
      emit_insn (gen_rtx_SET (VOIDmode, operandsÝ0¨,
			  gen_rtx_SUBREG (SImode, r, GET_MODE_SIZE (SImode))));
    }
  DONE;
}")

(define_insn ""
  Ý(set (match_operand:SI 0 "register_operand" "=d")
	(mult:SI (match_operand:SI 1 "register_operand" "0")
		 (match_operand:SI 2 "const_int_operand" "K")))¨
  "CONST_OK_FOR_LETTER_P (INTVAL (operandsÝ2¨), 'K')"
  "*
{
  check_label_emit ();
  mvs_check_page (0, 4, 0);
  return \"MH	%0,%H2\";
}"
   Ý(set_attr "length" "4")¨
)

; See mulsi3 comment above as to why this is constrained to
; "di" rather than "g"
(define_insn ""
  Ý(set (match_operand:DI 0 "register_operand" "=d")
	(mult:DI (match_operand:DI 1 "general_operand" "0")
		 (match_operand:SI 2 "general_operand" "g")))¨
  ""
  "*
{
  check_label_emit ();
  if (REG_P (operandsÝ2¨))
    {
      mvs_check_page (0, 2, 0);
      return \"MR	%0,%2\";
    }
  mvs_check_page (0, 4, 0);
  return \"M	%0,%2\";
}"
   Ý(set_attr "length" "4")¨
)

;
; muldf3 instruction pattern(s).
;

(define_insn "muldf3"
  Ý(set (match_operand:DF 0 "nonimmediate_operand" "=f")
	(mult:DF (match_operand:DF 1 "general_operand" "%0")
		 (match_operand:DF 2 "general_operand" "fmF")))¨
  ""
  "*
{
  check_label_emit ();
  if (FP_REG_P (operandsÝ2¨))
    {
      mvs_check_page (0, 2, 0);
      return \"MDR	%0,%2\";
    }
  mvs_check_page (0, 4, 0);
  return \"MD	%0,%2\";
}"
   Ý(set_attr "length" "4")¨
)

;
; mulsf3 instruction pattern(s).
;

(define_insn "mulsf3"
  Ý(set (match_operand:SF 0 "nonimmediate_operand" "=f")
	(mult:SF (match_operand:SF 1 "general_operand" "%0")
		 (match_operand:SF 2 "general_operand" "fmF")))¨
  ""
  "*
{
  check_label_emit ();
  if (FP_REG_P (operandsÝ2¨))
    {
      mvs_check_page (0, 2, 0);
      return \"MER	%0,%2\";
    }
  mvs_check_page (0, 4, 0);
  return \"ME	%0,%2\";
}"
   Ý(set_attr "length" "4")¨
)

;;
;;- Divide instructions.
;;

;
; divsi3 instruction pattern(s).
;

(define_expand "divsi3"
  Ý(set (match_operand:SI 0 "general_operand" "")
	(div:SI (match_operand:SI 1 "general_operand" "")
		(match_operand:SI 2 "general_operand" "")))¨
  ""
  "
{
  rtx r = gen_reg_rtx (DImode);

  emit_insn (gen_extendsidi2 (r, operandsÝ1¨));
  emit_insn (gen_rtx_SET (VOIDmode, r,
			gen_rtx_DIV (DImode, r, operandsÝ2¨)));
  emit_insn (gen_rtx_SET (VOIDmode, operandsÝ0¨,
			gen_rtx_SUBREG (SImode, r, GET_MODE_SIZE (SImode))));
  DONE;
}")


;
; udivsi3 instruction pattern(s).
;

(define_expand "udivsi3"
  Ý(set (match_operand:SI 0 "general_operand" "")
	(udiv:SI (match_operand:SI 1 "general_operand" "")
		 (match_operand:SI 2 "general_operand" "")))¨
  ""
  "
{
  rtx dr = gen_reg_rtx (DImode);
  rtx dr_0 = gen_rtx_SUBREG (SImode, dr, 0);
  rtx dr_1 = gen_rtx_SUBREG (SImode, dr, GET_MODE_SIZE (SImode));


  if (GET_CODE (operandsÝ2¨) == CONST_INT)
    {
      if (INTVAL (operandsÝ2¨) > 0)
	{
	  emit_insn (gen_zero_extendsidi2 (dr, operandsÝ1¨));
	  emit_insn (gen_rtx_SET (VOIDmode, dr,
			gen_rtx_DIV (DImode, dr, operandsÝ2¨)));
	}
      else
	{
	  rtx label1 = gen_label_rtx ();

	  emit_insn (gen_rtx_SET (VOIDmode, dr_0, operandsÝ1¨));
	  emit_insn (gen_rtx_SET (VOIDmode, dr_1, const0_rtx));
	  emit_insn (gen_cmpsi (dr_0, operandsÝ2¨));
	  emit_jump_insn (gen_bltu (label1));
	  emit_insn (gen_rtx_SET (VOIDmode, dr_1, const1_rtx));
	  emit_label (label1);
	}
    }
  else
    {
      rtx label1 = gen_label_rtx ();
      rtx label2 = gen_label_rtx ();
      rtx label3 = gen_label_rtx ();
      rtx sr = gen_reg_rtx (SImode);

      emit_insn (gen_rtx_SET (VOIDmode, dr_0, operandsÝ1¨));
      emit_insn (gen_rtx_SET (VOIDmode, sr, operandsÝ2¨));
      emit_insn (gen_rtx_SET (VOIDmode, dr_1, const0_rtx));
      emit_insn (gen_cmpsi (sr, dr_0));
      emit_jump_insn (gen_bgtu (label3));
      emit_insn (gen_cmpsi (sr, const0_rtx));
      emit_jump_insn (gen_blt (label2));
      emit_insn (gen_cmpsi (sr, const1_rtx));
      emit_jump_insn (gen_beq (label1));
      emit_insn (gen_rtx_SET (VOIDmode, dr,
			  gen_rtx_LSHIFTRT (DImode, dr,
				    gen_rtx_CONST_INT (SImode, 32))));
      emit_insn (gen_rtx_SET (VOIDmode, dr,
		    gen_rtx_DIV (DImode, dr, sr)));
      emit_jump_insn (gen_jump (label3));
      emit_label (label1);
      emit_insn (gen_rtx_SET (VOIDmode, dr_1, dr_0));
      emit_jump_insn (gen_jump (label3));
      emit_label (label2);
      emit_insn (gen_rtx_SET (VOIDmode, dr_1, const1_rtx));
      emit_label (label3);
    }
  emit_insn (gen_rtx_SET (VOIDmode, operandsÝ0¨, dr_1));

  DONE;
}")

; This is used by divsi3 & udivsi3.

(define_insn ""
  Ý(set (match_operand:DI 0 "register_operand" "=d")
	(div:DI (match_operand:DI 1 "register_operand" "0")
		(match_operand:SI 2 "general_operand" "dm")))¨
  ""
  "*
{
  check_label_emit ();
  if (REG_P (operandsÝ2¨))
    {
      mvs_check_page (0, 2, 0);
      return \"DR	%0,%2\";
    }
  mvs_check_page (0, 4, 0);
  return \"D	%0,%2\";
}"
   Ý(set_attr "length" "4")¨
)

;
; divdf3 instruction pattern(s).
;

(define_insn "divdf3"
  Ý(set (match_operand:DF 0 "nonimmediate_operand" "=f")
        (div:DF (match_operand:DF 1 "general_operand" "0")
                (match_operand:DF 2 "general_operand" "fmF")))¨
  ""
  "*
{
  check_label_emit ();
  if (FP_REG_P (operandsÝ2¨))
    {
      mvs_check_page (0, 2, 0);
      return \"DDR	%0,%2\";
    }
  mvs_check_page (0, 4, 0);
  return \"DD	%0,%2\";
}"
   Ý(set_attr "length" "4")¨
)

;
; divsf3 instruction pattern(s).
;

(define_insn "divsf3"
  Ý(set (match_operand:SF 0 "nonimmediate_operand" "=f")
        (div:SF (match_operand:SF 1 "general_operand" "0")
                (match_operand:SF 2 "general_operand" "fmF")))¨
  ""
  "*
{
  check_label_emit ();
  if (FP_REG_P (operandsÝ2¨))
    {
      mvs_check_page (0, 2, 0);
      return \"DER	%0,%2\";
    }
  mvs_check_page (0, 4, 0);
  return \"DE	%0,%2\";
}"
   Ý(set_attr "length" "4")¨
)

;;
;;- Modulo instructions.
;;

;
; modsi3 instruction pattern(s).
;

(define_expand "modsi3"
  Ý(set (match_operand:SI 0 "general_operand" "")
	(mod:SI (match_operand:SI 1 "general_operand" "")
		(match_operand:SI 2 "general_operand" "")))¨
  ""
  "
{
  rtx r = gen_reg_rtx (DImode);

  emit_insn (gen_extendsidi2 (r, operandsÝ1¨));
  emit_insn (gen_rtx_SET (VOIDmode, r,
			gen_rtx_MOD (DImode, r, operandsÝ2¨)));
  emit_insn (gen_rtx_SET (VOIDmode, operandsÝ0¨,
			gen_rtx_SUBREG (SImode, r, 0)));
  DONE;
}")

;
; umodsi3 instruction pattern(s).
;

(define_expand "umodsi3"
  Ý(set (match_operand:SI 0 "general_operand" "")
	(umod:SI (match_operand:SI 1 "general_operand" "")
		 (match_operand:SI 2 "general_operand" "")))¨
  ""
  "
{
  rtx dr = gen_reg_rtx (DImode);
  rtx dr_0 = gen_rtx_SUBREG (SImode, dr, 0);

  emit_insn (gen_rtx_SET (VOIDmode, dr_0, operandsÝ1¨));

  if (GET_CODE (operandsÝ2¨) == CONST_INT)
    {
      if (INTVAL (operandsÝ2¨) > 0)
	{
	  emit_insn (gen_rtx_SET (VOIDmode, dr,
			      gen_rtx_LSHIFTRT (DImode, dr,
					gen_rtx_CONST_INT (SImode, 32))));
	  emit_insn (gen_rtx_SET (VOIDmode, dr,
			gen_rtx_MOD (DImode, dr, operandsÝ2¨)));
	}
      else
	{
	  rtx label1 = gen_label_rtx ();
	  rtx sr = gen_reg_rtx (SImode);

	  emit_insn (gen_rtx_SET (VOIDmode, sr, operandsÝ2¨));
	  emit_insn (gen_cmpsi (dr_0, sr));
	  emit_jump_insn (gen_bltu (label1));
	  emit_insn (gen_rtx_SET (VOIDmode, sr, gen_rtx_ABS (SImode, sr)));
	  emit_insn (gen_rtx_SET (VOIDmode, dr_0,
			      gen_rtx_PLUS (SImode, dr_0, sr)));
	  emit_label (label1);
	}
    }
  else
    {
      rtx label1 = gen_label_rtx ();
      rtx label2 = gen_label_rtx ();
      rtx label3 = gen_label_rtx ();
      rtx sr = gen_reg_rtx (SImode);

      emit_insn (gen_rtx_SET (VOIDmode, dr_0, operandsÝ1¨));
      emit_insn (gen_rtx_SET (VOIDmode, sr, operandsÝ2¨));
      emit_insn (gen_cmpsi (sr, dr_0));
      emit_jump_insn (gen_bgtu (label3));
      emit_insn (gen_cmpsi (sr, const0_rtx));
      emit_jump_insn (gen_blt (label2));
      emit_insn (gen_cmpsi (sr, const1_rtx));
      emit_jump_insn (gen_beq (label1));
      emit_insn (gen_rtx_SET (VOIDmode, dr,
			  gen_rtx_LSHIFTRT (DImode, dr,
				    gen_rtx_CONST_INT (SImode, 32))));
      emit_insn (gen_rtx_SET (VOIDmode, dr, gen_rtx_MOD (DImode, dr, sr)));
      emit_jump_insn (gen_jump (label3));
      emit_label (label1);
      emit_insn (gen_rtx_SET (VOIDmode, dr_0, const0_rtx));
      emit_jump_insn (gen_jump (label3));
      emit_label (label2);
      emit_insn (gen_rtx_SET (VOIDmode, dr_0,
			  gen_rtx_MINUS (SImode, dr_0, sr)));
      emit_label (label3);

    }
  emit_insn (gen_rtx_SET (VOIDmode, operandsÝ0¨, dr_0));

  DONE;
}")

; This is used by modsi3 & umodsi3.

(define_insn ""
  Ý(set (match_operand:DI 0 "register_operand" "=d")
	(mod:DI (match_operand:DI 1 "register_operand" "0")
		(match_operand:SI 2 "general_operand" "dm")))¨
  ""
  "*
{
  check_label_emit ();
  if (REG_P (operandsÝ2¨))
    {
      mvs_check_page (0, 2, 0);
      return \"DR	%0,%2\";
    }
  mvs_check_page (0, 4, 0);
  return \"D	%0,%2\";
}"
   Ý(set_attr "length" "4")¨
)

;;
;;- And instructions.
;;

;
; anddi3 instruction pattern(s).
;

;(define_expand "anddi3"
;  Ý(set (match_operand:DI 0 "general_operand" "")
;	(and:DI (match_operand:DI 1 "general_operand" "")
;		(match_operand:DI 2 "general_operand" "")))¨
;  ""
;  "
;{
;  rtx gen_andsi3();
;
;  emit_insn (gen_andsi3 (operand_subword (operandsÝ0¨, 0, 1, DImode),
;			 operand_subword (operandsÝ1¨, 0, 1, DImode),
;			 operand_subword (operandsÝ2¨, 0, 1, DImode)));
;  emit_insn (gen_andsi3 (gen_lowpart (SImode, operandsÝ0¨),
;			 gen_lowpart (SImode, operandsÝ1¨),
;			 gen_lowpart (SImode, operandsÝ2¨)));
;  DONE;
;}")


;
; andsi3 instruction pattern(s).
;

(define_insn ""
  Ý(set (match_operand:SI 0 "r_or_s_operand" "=d,R")
	(and:SI (match_operand:SI 1 "r_or_s_operand" "%0,0")
		(match_operand:SI 2 "general_operand" "g,Si")))¨
  "TARGET_CHAR_INSTRUCTIONS"
  "*
{
  check_label_emit ();
  CC_STATUS_INIT;  /* and sets CC but not how we want it */
  if (REG_P (operandsÝ2¨))
    {
      mvs_check_page (0, 2, 0);
      return \"NR	%0,%2\";
    }
  if (REG_P (operandsÝ0¨))
    {
      mvs_check_page (0, 4, 0);
      return \"N	%0,%2\";
    }
  mvs_check_page (0, 6, 0);
  return \"NC	%O0(4,%R0),%2\";
}"
   Ý(set_attr "length" "6")¨
)

(define_insn "andsi3"
  Ý(set (match_operand:SI 0 "nonimmediate_operand" "=d")
	(and:SI (match_operand:SI 1 "general_operand" "%0")
		(match_operand:SI 2 "general_operand" "g")))¨
  ""
  "*
{
  check_label_emit ();
  CC_STATUS_INIT;  /* and sets CC but not how we want it */
  if (REG_P (operandsÝ2¨))
    {
      mvs_check_page (0, 2, 0);
      return \"NR	%0,%2\";
    }
  mvs_check_page (0, 4, 0);
  return \"N	%0,%2\";
}"
   Ý(set_attr "length" "4")¨
)

;
; andhi3 instruction pattern(s).
;

(define_insn ""
  Ý(set (match_operand:HI 0 "r_or_s_operand" "=d,S")
	(and:HI (match_operand:HI 1 "r_or_s_operand" "%0,0")
		(match_operand:HI 2 "general_operand" "di,Si")))¨
  "TARGET_CHAR_INSTRUCTIONS"
  "*
{
  check_label_emit ();
  CC_STATUS_INIT;  /* and sets CC but not how we want it */
  if (REG_P (operandsÝ2¨))
    {
      mvs_check_page (0, 2, 0);
      return \"NR	%0,%2\";
    }
  if (REG_P (operandsÝ0¨))
    {
      /* %K2 == sign extend operand to 32 bits so that CH works */
      if (GET_CODE (operandsÝ2¨) == CONST_INT)
        {
          mvs_check_page (0, 4, 4);
          return \"N	%0,%K2\";
        }
      mvs_check_page (0, 4, 0);
      return \"N	%0,%2\";
    }
  if (GET_CODE (operandsÝ2¨) == CONST_INT)
    {
      mvs_check_page (0, 6, 2);
      return \"NC	%O0(2,%R0),%H2\";
    }
  mvs_check_page (0, 6, 0);
  return \"NC	%O0(2,%R0),%2\";
}"
   Ý(set_attr "length" "6")¨
)

(define_insn "andhi3"
  Ý(set (match_operand:HI 0 "register_operand" "=d")
	(and:HI (match_operand:HI 1 "register_operand" "%0")
		(match_operand:HI 2 "general_operand" "di")))¨
  ""
  "*
{
  check_label_emit ();
  CC_STATUS_INIT;  /* and sets CC but not how we want it */
  if (GET_CODE (operandsÝ2¨) == CONST_INT)
    {
      /* %K2 == sign extend operand to 32 bits so that CH works */
      mvs_check_page (0, 4, 4);
      return \"N	%0,%K2\";
    }
  mvs_check_page (0, 2, 0);
  return \"NR	%0,%2\";
}"
   Ý(set_attr "length" "4")¨
)

;
; andqi3 instruction pattern(s).
;

(define_insn ""
  Ý(set (match_operand:QI 0 "r_or_s_operand" "=d,S")
	(and:QI (match_operand:QI 1 "r_or_s_operand" "%0,0")
		(match_operand:QI 2 "general_operand" "dim,Si")))¨
  "TARGET_CHAR_INSTRUCTIONS"
  "*
{
  check_label_emit ();
  CC_STATUS_INIT;  /* and sets CC but not how we want it */
  if (REG_P (operandsÝ2¨))
    {
      mvs_check_page (0, 2, 0);
      return \"NR	%0,%2\";
    }
  if (REG_P (operandsÝ0¨))
    {
      mvs_check_page (0, 4, 0);
      return \"N	%0,%2\";
    }
  if (GET_CODE (operandsÝ2¨) == CONST_INT)
    {
      mvs_check_page (0, 4, 0);
      return \"NI	%0,%B2\";
    }
  mvs_check_page (0, 6, 0);
  return \"NC	%O0(1,%R0),%2\";
}"
   Ý(set_attr "length" "6")¨
)

(define_insn "andqi3"
  Ý(set (match_operand:QI 0 "nonimmediate_operand" "=d")
	(and:QI (match_operand:QI 1 "general_operand" "%0")
		(match_operand:QI 2 "general_operand" "di")))¨
  ""
  "*
{
  check_label_emit ();
  CC_STATUS_INIT;  /* and sets CC but not how we want it */
  if (GET_CODE (operandsÝ2¨) == CONST_INT)
    {
      mvs_check_page (0, 4, 4);
      return \"N	%0,=XL4'%X2'\";
    }
  mvs_check_page (0, 2, 0);
  return \"NR	%0,%2\";
}"
   Ý(set_attr "length" "4")¨
)

;;
;;- Bit set (inclusive or) instructions.
;;

;
; iordi3 instruction pattern(s).
;

;(define_expand "iordi3"
;  Ý(set (match_operand:DI 0 "general_operand" "")
;	(ior:DI (match_operand:DI 1 "general_operand" "")
;		(match_operand:DI 2 "general_operand" "")))¨
;  ""
;  "
;{
;  rtx gen_iorsi3();
;
;  emit_insn (gen_iorsi3 (operand_subword (operandsÝ0¨, 0, 1, DImode),
;			 operand_subword (operandsÝ1¨, 0, 1, DImode),
;			 operand_subword (operandsÝ2¨, 0, 1, DImode)));
;  emit_insn (gen_iorsi3 (gen_lowpart (SImode, operandsÝ0¨),
;			 gen_lowpart (SImode, operandsÝ1¨),
;			 gen_lowpart (SImode, operandsÝ2¨)));
;  DONE;
;}")

;
; iorsi3 instruction pattern(s).
;

(define_insn ""
  Ý(set (match_operand:SI 0 "r_or_s_operand" "=d,m")
	(ior:SI (match_operand:SI 1 "r_or_s_operand" "%0,0")
		(match_operand:SI 2 "general_operand" "g,Si")))¨
  "TARGET_CHAR_INSTRUCTIONS"
  "*
{
  check_label_emit ();
  CC_STATUS_INIT;  /* OR sets CC but not how we want it */
  if (REG_P (operandsÝ2¨))
    {
      mvs_check_page (0, 2, 0);
      return \"OR	%0,%2\";
    }
  if (REG_P (operandsÝ0¨))
    {
      mvs_check_page (0, 4, 0);
      return \"O	%0,%2\";
    }
  mvs_check_page (0, 6, 0);
  return \"OC	%O0(4,%R0),%2\";
}"
  Ý(set_attr "length" "6")¨
)

(define_insn "iorsi3"
  Ý(set (match_operand:SI 0 "nonimmediate_operand" "=d")
	(ior:SI (match_operand:SI 1 "general_operand" "%0")
		(match_operand:SI 2 "general_operand" "g")))¨
  ""
  "*
{
  check_label_emit ();
  CC_STATUS_INIT;  /* OR sets CC but not how we want it */
  if (REG_P (operandsÝ2¨))
    {
      mvs_check_page (0, 2, 0);
      return \"OR	%0,%2\";
    }
  mvs_check_page (0, 4, 0);
  return \"O	%0,%2\";
}"
   Ý(set_attr "length" "4")¨
)

;
; iorhi3 instruction pattern(s).
;

(define_insn ""
  Ý(set (match_operand:HI 0 "r_or_s_operand" "=d,m")
	(ior:HI (match_operand:HI 1 "r_or_s_operand" "%0,0")
		(match_operand:HI 2 "general_operand" "di,mi")))¨
  "TARGET_CHAR_INSTRUCTIONS"
  "*
{
  check_label_emit ();
  CC_STATUS_INIT;  /* OR sets CC but not how we want it */
  if (REG_P (operandsÝ2¨))
    {
      mvs_check_page (0, 2, 0);
      return \"OR	%0,%2\";
    }
  if (REG_P (operandsÝ0¨))
    {
      mvs_check_page (0, 4, 0);
      return \"O	%0,%2\";
    }
  if (GET_CODE (operandsÝ2¨) == CONST_INT)
    {
      mvs_check_page (0, 6, 2);
      return \"OC	%O0(2,%R0),%H2\";
    }
  mvs_check_page (0, 6, 0);
  return \"OC	%O0(2,%R0),%2\";
}"
   Ý(set_attr "length" "6")¨
)

(define_insn "iorhi3"
  Ý(set (match_operand:HI 0 "nonimmediate_operand" "=d")
	(ior:HI (match_operand:HI 1 "general_operand" "%0")
		(match_operand:HI 2 "general_operand" "di")))¨
  ""
  "*
{
  check_label_emit ();
  CC_STATUS_INIT;  /* OR sets CC but not how we want it */
  if (GET_CODE (operandsÝ2¨) == CONST_INT)
    {
      mvs_check_page (0, 4, 4);
      return \"O	%0,%K2\";
    }
  mvs_check_page (0, 2, 0);
  return \"OR	%0,%2\";
}"
   Ý(set_attr "length" "4")¨
)

;
; iorqi3 instruction pattern(s).
;

(define_insn ""
  Ý(set (match_operand:QI 0 "r_or_s_operand" "=d,m")
	(ior:QI (match_operand:QI 1 "r_or_s_operand" "%0,0")
		(match_operand:QI 2 "general_operand" "di,mi")))¨
  "TARGET_CHAR_INSTRUCTIONS"
  "*
{
  check_label_emit ();
  CC_STATUS_INIT;  /* OR sets CC but not how we want it */
  if (REG_P (operandsÝ2¨))
    {
      mvs_check_page (0, 2, 0);
      return \"OR	%0,%2\";
    }
  if (REG_P (operandsÝ0¨))
    {
      mvs_check_page (0, 4, 0);
      return \"O	%0,%2\";
    }
  if (GET_CODE (operandsÝ2¨) == CONST_INT)
    {
      mvs_check_page (0, 4, 0);
      return \"OI	%0,%B2\";
    }
  mvs_check_page (0, 6, 0);
  return \"OC	%O0(1,%R0),%2\";
}"
   Ý(set_attr "length" "6")¨
)

(define_insn "iorqi3"
  Ý(set (match_operand:QI 0 "nonimmediate_operand" "=d")
	(ior:QI (match_operand:QI 1 "general_operand" "%0")
		(match_operand:QI 2 "general_operand" "di")))¨
  ""
  "*
{
  check_label_emit ();
  CC_STATUS_INIT;  /* OR sets CC but not how we want it */
  if (GET_CODE (operandsÝ2¨) == CONST_INT)
    {
      mvs_check_page (0, 4, 4);
      return \"O	%0,=XL4'%X2'\";
    }
  mvs_check_page (0, 2, 0);
  return \"OR	%0,%2\";
}"
   Ý(set_attr "length" "4")¨
)

;;
;;- Xor instructions.
;;

;
; xordi3 instruction pattern(s).
;

;(define_expand "xordi3"
;  Ý(set (match_operand:DI 0 "general_operand" "")
;	(xor:DI (match_operand:DI 1 "general_operand" "")
;		(match_operand:DI 2 "general_operand" "")))¨
;  ""
;  "
;{
;  rtx gen_xorsi3();
;
;  emit_insn (gen_xorsi3 (operand_subword (operandsÝ0¨, 0, 1, DImode),
;			 operand_subword (operandsÝ1¨, 0, 1, DImode),
;			 operand_subword (operandsÝ2¨, 0, 1, DImode)));
;  emit_insn (gen_xorsi3 (gen_lowpart (SImode, operandsÝ0¨),
;			 gen_lowpart (SImode, operandsÝ1¨),
;			 gen_lowpart (SImode, operandsÝ2¨)));
;  DONE;
;}")

;
; xorsi3 instruction pattern(s).
;

(define_insn ""
  Ý(set (match_operand:SI 0 "r_or_s_operand" "=d,m")
	(xor:SI (match_operand:SI 1 "r_or_s_operand" "%0,0")
		(match_operand:SI 2 "general_operand" "g,Si")))¨
  "TARGET_CHAR_INSTRUCTIONS"
  "*
{
  check_label_emit ();
  CC_STATUS_INIT;  /* XOR sets CC but not how we want it */
  if (REG_P (operandsÝ2¨))
    {
      mvs_check_page (0, 2, 0);
      return \"XR	%0,%2\";
    }
  if (REG_P (operandsÝ0¨))
    {
      mvs_check_page (0, 4, 0);
      return \"X	%0,%2\";
    }
  mvs_check_page (0, 6, 0);
  return \"XC	%O0(4,%R0),%2\";
}"
   Ý(set_attr "length" "6")¨
)

(define_insn "xorsi3"
  Ý(set (match_operand:SI 0 "nonimmediate_operand" "=d")
	(xor:SI (match_operand:SI 1 "general_operand" "%0")
		(match_operand:SI 2 "general_operand" "g")))¨
  ""
  "*
{
  check_label_emit ();
  CC_STATUS_INIT;  /* XOR sets CC but not how we want it */
  if (REG_P (operandsÝ2¨))
    {
      mvs_check_page (0, 2, 0);
      return \"XR	%0,%2\";
    }
  mvs_check_page (0, 4, 0);
  return \"X	%0,%2\";
}"
  Ý(set_attr "length" "4")¨
)

;
; xorhi3 instruction pattern(s).
;

(define_insn ""
  Ý(set (match_operand:HI 0 "r_or_s_operand" "=d,m")
	(xor:HI (match_operand:HI 1 "r_or_s_operand" "%0,0")
		(match_operand:HI 2 "general_operand" "di,mi")))¨
  "TARGET_CHAR_INSTRUCTIONS"
  "*
{
  check_label_emit ();
  CC_STATUS_INIT;  /* XOR sets CC but not how we want it */
  if (REG_P (operandsÝ2¨))
    {
      mvs_check_page (0, 2, 0);
      return \"XR	%0,%2\";
    }
  if (REG_P (operandsÝ0¨))
    {
      if (GET_CODE (operandsÝ2¨) == CONST_INT)
        {
          mvs_check_page (0, 4, 4);
          return \"X	%0,%K2\";
        }
      mvs_check_page (0, 4, 0);
      return \"X	%0,%2\";
    }
  if (GET_CODE (operandsÝ2¨) == CONST_INT)
    {
      mvs_check_page (0, 6, 2);
      return \"XC	%O0(2,%R0),%H2\";
    }
  mvs_check_page (0, 6, 0);
  return \"XC	%O0(2,%R0),%2\";
}"
  Ý(set_attr "length" "6")¨
)

(define_insn "xorhi3"
  Ý(set (match_operand:HI 0 "nonimmediate_operand" "=d")
	(xor:HI (match_operand:HI 1 "general_operand" "%0")
		(match_operand:HI 2 "general_operand" "di")))¨
  ""
  "*
{
  check_label_emit ();
  CC_STATUS_INIT;  /* XOR sets CC but not how we want it */
  if (GET_CODE (operandsÝ2¨) == CONST_INT)
    {
      mvs_check_page (0, 4, 4);
      return \"X	%0,%2\";
    }
  mvs_check_page (0, 2, 0);
  return \"XR	%0,%2\";
}"
  Ý(set_attr "length" "4")¨
)

;
; xorqi3 instruction pattern(s).
;

(define_insn ""
  Ý(set (match_operand:QI 0 "r_or_s_operand" "=d,m")
	(xor:QI (match_operand:QI 1 "r_or_s_operand" "%0,0")
		(match_operand:QI 2 "general_operand" "di,mi")))¨
  "TARGET_CHAR_INSTRUCTIONS"
  "*
{
  check_label_emit ();
  CC_STATUS_INIT;  /* XOR sets CC but not how we want it */
  if (REG_P (operandsÝ2¨))
    {
      mvs_check_page (0, 2, 0);
      return \"XR	%0,%2\";
    }
  if (REG_P (operandsÝ0¨))
    {
      mvs_check_page (0, 4, 0);
      return \"X	%0,%2\";
    }
  if (GET_CODE (operandsÝ2¨) == CONST_INT)
    {
      mvs_check_page (0, 4, 0);
      return \"XI	%0,%B2\";
    }
  mvs_check_page (0, 6, 0);
  return \"XC	%O0(1,%R0),%2\";
}"
  Ý(set_attr "length" "6")¨
)

(define_insn "xorqi3"
  Ý(set (match_operand:QI 0 "nonimmediate_operand" "=d")
	(xor:QI (match_operand:QI 1 "general_operand" "%0")
		(match_operand:QI 2 "general_operand" "di")))¨
  ""
  "*
{
  check_label_emit ();
  CC_STATUS_INIT;  /* XOR sets CC but not how we want it */
  if (GET_CODE (operandsÝ2¨) == CONST_INT)
    {
      mvs_check_page (0, 4, 0);
      return \"X	%0,=XL4'%X2'\";
    }
  mvs_check_page (0, 2, 0);
  return \"XR	%0,%2\";
}"
  Ý(set_attr "length" "4")¨
)

;;
;;- Negate instructions.
;;

;
; negsi2 instruction pattern(s).
;

(define_insn "negsi2"
  Ý(set (match_operand:SI 0 "nonimmediate_operand" "=d")
	(neg:SI (match_operand:SI 1 "general_operand" "d")))¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 2, 0);
  return \"LCR	%0,%1\";
}"
  Ý(set_attr "length" "2")¨
)

;
; neghi2 instruction pattern(s).
;

(define_insn "neghi2"
  Ý(set (match_operand:HI 0 "nonimmediate_operand" "=d")
	(neg:HI (match_operand:HI 1 "general_operand" "d")))¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 10, 0);
  return \"SLL	%1,16\;SRA	%1,16\;LCR	%0,%1\";
}"
  Ý(set_attr "length" "10")¨
)

;
; negdf2 instruction pattern(s).
;

(define_insn "negdf2"
  Ý(set (match_operand:DF 0 "nonimmediate_operand" "=f")
	(neg:DF (match_operand:DF 1 "general_operand" "f")))¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 2, 0);
  return \"LCDR	%0,%1\";
}"
  Ý(set_attr "length" "2")¨
)

;
; negsf2 instruction pattern(s).
;

(define_insn "negsf2"
  Ý(set (match_operand:SF 0 "nonimmediate_operand" "=f")
	(neg:SF (match_operand:SF 1 "general_operand" "f")))¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 2, 0);
  return \"LCER	%0,%1\";
}"
  Ý(set_attr "length" "2")¨
)

;;
;;- Absolute value instructions.
;;

;
; abssi2 instruction pattern(s).
;

(define_insn "abssi2"
  Ý(set (match_operand:SI 0 "nonimmediate_operand" "=d")
	(abs:SI (match_operand:SI 1 "general_operand" "d")))¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 2, 0);
  return \"LPR	%0,%1\";
}"
  Ý(set_attr "length" "2")¨
)

;
; abshi2 instruction pattern(s).
;

(define_insn "abshi2"
  Ý(set (match_operand:HI 0 "nonimmediate_operand" "=d")
	(abs:HI (match_operand:HI 1 "general_operand" "d")))¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 10, 0);
  return \"SLL	%1,16\;SRA	%1,16\;LPR	%0,%1\";
}"
  Ý(set_attr "length" "10")¨
)

;
; absdf2 instruction pattern(s).
;

(define_insn "absdf2"
  Ý(set (match_operand:DF 0 "nonimmediate_operand" "=f")
	(abs:DF (match_operand:DF 1 "general_operand" "f")))¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 2, 0);
  return \"LPDR	%0,%1\";
}"
  Ý(set_attr "length" "2")¨
)

;
; abssf2 instruction pattern(s).
;

(define_insn "abssf2"
  Ý(set (match_operand:SF 0 "nonimmediate_operand" "=f")
	(abs:SF (match_operand:SF 1 "general_operand" "f")))¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 2, 0);
  return \"LPER	%0,%1\";
}"
  Ý(set_attr "length" "2")¨
)

;;
;;- One complement instructions.
;;

;
; one_cmpldi2 instruction pattern(s).
;

;(define_expand "one_cmpldi2"
;  Ý(set (match_operand:DI 0 "general_operand" "")
;	(not:DI (match_operand:DI 1 "general_operand" "")))¨
;  ""
;  "
;{
;  rtx gen_one_cmplsi2();
;
;  emit_insn (gen_one_cmplsi2 (operand_subword (operandsÝ0¨, 0, 1, DImode),
;			      operand_subword (operandsÝ1¨, 0, 1, DImode)));
;  emit_insn (gen_one_cmplsi2 (gen_lowpart (SImode, operandsÝ0¨),
;			      gen_lowpart (SImode, operandsÝ1¨)));
;  DONE;
;}")

;
; one_cmplsi2 instruction pattern(s).
;

(define_insn ""
  Ý(set (match_operand:SI 0 "r_or_s_operand" "=dm")
	(not:SI (match_operand:SI 1 "r_or_s_operand" "0")))¨
  "TARGET_CHAR_INSTRUCTIONS"
  "*
{
  check_label_emit ();
  CC_STATUS_INIT;  /* XOR sets CC but not how we want it */
  if (REG_P (operandsÝ0¨))
    {
      mvs_check_page (0, 4, 4);
      return \"X	%0,=F'-1'\";
    }
  CC_STATUS_INIT;
  mvs_check_page (0, 6, 4);
  return \"XC	%O0(4,%R0),=F'-1'\";
}"
  Ý(set_attr "length" "6")¨
)

(define_insn "one_cmplsi2"
  Ý(set (match_operand:SI 0 "nonimmediate_operand" "=d")
	(not:SI (match_operand:SI 1 "general_operand" "0")))¨
  ""
  "*
{
  check_label_emit ();
  CC_STATUS_INIT;  /* XOR sets CC but not how we want it */
  mvs_check_page (0, 4, 4);
  return \"X	%0,=F'-1'\";
}"
  Ý(set_attr "length" "4")¨
)

;
; one_cmplhi2 instruction pattern(s).
;

(define_insn ""
  Ý(set (match_operand:HI 0 "r_or_s_operand" "=dm")
	(not:HI (match_operand:HI 1 "r_or_s_operand" "0")))¨
  "TARGET_CHAR_INSTRUCTIONS"
  "*
{
  check_label_emit ();
  CC_STATUS_INIT;  /* XOR sets CC but not how we want it */
  if (REG_P (operandsÝ0¨))
    {
      mvs_check_page (0, 4, 4);
      return \"X	%0,=F'-1'\";
    }
  mvs_check_page (0, 6, 2);
  return \"XC	%O0(2,%R0),=XL2'FFFF'\";
}"
  Ý(set_attr "length" "6")¨
)

(define_insn "one_cmplhi2"
  Ý(set (match_operand:HI 0 "nonimmediate_operand" "=d")
	(not:HI (match_operand:HI 1 "general_operand" "0")))¨
  ""
  "*
{
  check_label_emit ();
  CC_STATUS_INIT;  /* XOR sets CC but not how we want it */
  mvs_check_page (0, 4, 4);
  return \"X	%0,=F'-1'\";
}"
  Ý(set_attr "length" "4")¨
)

;
; one_cmplqi2 instruction pattern(s).
;

(define_insn ""
  Ý(set (match_operand:QI 0 "r_or_s_operand" "=dm")
	(not:QI (match_operand:QI 1 "r_or_s_operand" "0")))¨
  "TARGET_CHAR_INSTRUCTIONS"
  "*
{
  check_label_emit ();
  CC_STATUS_INIT;  /* XOR sets CC but not how we want it */
  if (REG_P (operandsÝ0¨))
    {
      mvs_check_page (0, 4, 4);
      return \"X	%0,=F'-1'\";
    }
  mvs_check_page (0, 4, 0);
  return \"XI	%0,255\";
}"
  Ý(set_attr "length" "4")¨
)

(define_insn "one_cmplqi2"
  Ý(set (match_operand:QI 0 "nonimmediate_operand" "=d")
	(not:QI (match_operand:QI 1 "general_operand" "0")))¨
  ""
  "*
{
  check_label_emit ();
  CC_STATUS_INIT;  /* XOR sets CC but not how we want it */
  mvs_check_page (0, 4, 4);
  return \"X	%0,=F'-1'\";
}"
  Ý(set_attr "length" "4")¨
)

;;
;;- Arithmetic shift instructions.
;;

;
; ashldi3 instruction pattern(s).
;

(define_insn "ashldi3"
  Ý(set (match_operand:DI 0 "nonimmediate_operand" "=d")
	(ashift:DI (match_operand:DI 1 "general_operand" "0")
		   (match_operand:SI 2 "general_operand" "Ja")))¨
  ""
  "*
{
  check_label_emit ();
  /* this status set seems not have the desired effect,
   * proably because the 64-bit long-long test is emulated ?! */
  CC_STATUS_SET (operandsÝ0¨, operandsÝ1¨);
  mvs_check_page (0, 4, 0);
  if (REG_P (operandsÝ2¨))
    return \"SLDA	%0,0(%2)\";
  return \"SLDA	%0,%c2\";
}"
  Ý(set_attr "length" "4")¨
)

;
; ashrdi3 instruction pattern(s).
;

(define_insn "ashrdi3"
  Ý(set (match_operand:DI 0 "register_operand" "=d")
	(ashiftrt:DI (match_operand:DI 1 "general_operand" "0")
		     (match_operand:SI 2 "general_operand" "Ja")))¨
  ""
  "*
{
  check_label_emit ();
  /* this status set seems not have the desired effect,
   * proably because the 64-bit long-long test is emulated ?! */
  CC_STATUS_SET (operandsÝ0¨, operandsÝ1¨);
  mvs_check_page (0, 4, 0);
  if (REG_P (operandsÝ2¨))
    return \"SRDA	%0,0(%2)\";
  return \"SRDA	%0,%c2\";
}"
  Ý(set_attr "length" "4")¨
)

;
; ashlsi3 instruction pattern(s).
;

(define_insn "ashlsi3"
  Ý(set (match_operand:SI 0 "nonimmediate_operand" "=d")
	(ashift:SI (match_operand:SI 1 "general_operand" "0")
		   (match_operand:SI 2 "general_operand" "Ja")))¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 4, 0);
  if (REG_P (operandsÝ2¨))
    return \"SLL	%0,0(%2)\";
  return \"SLL	%0,%c2\";
}"
  Ý(set_attr "length" "4")¨
)

;
; ashrsi3 instruction pattern(s).
;

(define_insn "ashrsi3"
  Ý(set (match_operand:SI 0 "nonimmediate_operand" "=d")
	(ashiftrt:SI (match_operand:SI 1 "general_operand" "0")
		     (match_operand:SI 2 "general_operand" "Ja")))¨
  ""
  "*
{
  check_label_emit ();
  CC_STATUS_SET (operandsÝ0¨, operandsÝ1¨);
  mvs_check_page (0, 4, 0);
  if (REG_P (operandsÝ2¨))
    return \"SRA	%0,0(%2)\";
  return \"SRA	%0,%c2\";
}"
  Ý(set_attr "length" "4")¨
)

;
; ashlhi3 instruction pattern(s).
;

(define_insn "ashlhi3"
  Ý(set (match_operand:HI 0 "nonimmediate_operand" "=d")
	(ashift:HI (match_operand:HI 1 "general_operand" "0")
		   (match_operand:SI 2 "general_operand" "Ja")))¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 8, 0);
  if (REG_P (operandsÝ2¨))
    return \"SLL	%0,16(%2)\;SRA	%0,16\";
  return \"SLL	%0,16+%c2\;SRA	%0,16\";
}"
  Ý(set_attr "length" "8")¨
)

;
; ashrhi3 instruction pattern(s).
;

(define_insn "ashrhi3"
  Ý(set (match_operand:HI 0 "nonimmediate_operand" "=d")
	(ashiftrt:HI (match_operand:HI 1 "general_operand" "0")
		     (match_operand:SI 2 "general_operand" "Ja")))¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 8, 0);
  if (REG_P (operandsÝ2¨))
    return \"SLL	%0,16\;SRA	%0,16(%2)\";
  return \"SLL	%0,16\;SRA	%0,16+%c2\";
}"
  Ý(set_attr "length" "8")¨
)

;
; ashlqi3 instruction pattern(s).
;

(define_insn "ashlqi3"
  Ý(set (match_operand:QI 0 "nonimmediate_operand" "=d")
	(ashift:QI (match_operand:QI 1 "general_operand" "0")
		   (match_operand:SI 2 "general_operand" "Ja")))¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 4, 0);
  if (REG_P (operandsÝ2¨))
    return \"SLL	%0,0(%2)\";
  return \"SLL	%0,%c2\";
}"
  Ý(set_attr "length" "4")¨
)

;
; ashrqi3 instruction pattern(s).
;

(define_insn "ashrqi3"
  Ý(set (match_operand:QI 0 "nonimmediate_operand" "=d")
	(ashiftrt:QI (match_operand:QI 1 "general_operand" "0")
		     (match_operand:SI 2 "general_operand" "Ja")))¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 8, 0);
  if (REG_P (operandsÝ2¨))
    return \"SLL	%0,24\;SRA	%0,24(%2)\";
  return \"SLL	%0,24\;SRA	%0,24+%c2\";
}"
  Ý(set_attr "length" "8")¨
)

;;
;;- Logical shift instructions.
;;

;
; lshrdi3 instruction pattern(s).
;

(define_insn "lshrdi3"
  Ý(set (match_operand:DI 0 "nonimmediate_operand" "=d")
	(lshiftrt:DI (match_operand:DI 1 "general_operand" "0")
		     (match_operand:SI 2 "general_operand" "Ja")))¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 4, 0);
  if (REG_P (operandsÝ2¨))
    return \"SRDL	%0,0(%2)\";
  return \"SRDL	%0,%c2\";
}"
  Ý(set_attr "length" "4")¨
)


;
; lshrsi3 instruction pattern(s).
;

(define_insn "lshrsi3"
  Ý(set (match_operand:SI 0 "nonimmediate_operand" "=d")
	(lshiftrt:SI (match_operand:SI 1 "general_operand" "0")
		     (match_operand:SI 2 "general_operand" "Ja")))¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 4, 0);
  if (REG_P (operandsÝ2¨))
    return \"SRL	%0,0(%2)\";
  return \"SRL	%0,%c2\";
}"
  Ý(set_attr "length" "4")¨
)

;
; lshrhi3 instruction pattern(s).
;

(define_insn "lshrhi3"
  Ý(set (match_operand:HI 0 "nonimmediate_operand" "=d")
	(lshiftrt:HI (match_operand:HI 1 "general_operand" "0")
		     (match_operand:SI 2 "general_operand" "Ja")))¨
  ""
  "*
{
  check_label_emit ();
  CC_STATUS_INIT; /* AND sets the CC but not how we want it */
  if (REG_P (operandsÝ2¨))
    {
      mvs_check_page (0, 8, 4);
      return \"N	%0,=XL4'0000FFFF'\;SRL	%0,0(%2)\";
    }
  mvs_check_page (0, 8, 4);
  return \"N	%0,=XL4'0000FFFF'\;SRL	%0,%c2\";
}"
  Ý(set_attr "length" "8")¨
)

;
; lshrqi3 instruction pattern(s).
;

(define_insn "lshrqi3"
  Ý(set (match_operand:QI 0 "nonimmediate_operand" "=d")
	(lshiftrt:QI (match_operand:QI 1 "general_operand" "0")
		     (match_operand:SI 2 "general_operand" "Ja")))¨
  ""
  "*
{
  check_label_emit ();
  CC_STATUS_INIT; /* AND sets the CC but not how we want it */
  mvs_check_page (0, 8, 4);
  if (REG_P (operandsÝ2¨))
    return \"N	%0,=XL4'000000FF'\;SRL	%0,0(%2)\";
  return \"N	%0,=XL4'000000FF'\;SRL	%0,%c2\";
}"
  Ý(set_attr "length" "8")¨
)

;; =======================================================================
;;- Conditional jump instructions.
;; =======================================================================

;
; beq instruction pattern(s).
;

(define_insn "beq"
  Ý(set (pc)
	(if_then_else (eq (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))
;   (clobber (reg:SI 14))
   ¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 4, 0);
  if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operandsÝ0¨)))
    {
      return \"BE	%l0\";
    }
  mvs_check_page (0, 2, 4);
  return \"L	14,=A(%l0)\;BER	14\";
}"
  Ý(set_attr "length" "6")¨
)

;
; bne instruction pattern(s).
;

(define_insn "bne"
  Ý(set (pc)
	(if_then_else (ne (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))
;   (clobber (reg:SI 14))
   ¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 4, 0);
  if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operandsÝ0¨)))
    {
      return \"BNE	%l0\";
    }
  mvs_check_page (0, 2, 4);
  return \"L	14,=A(%l0)\;BNER	14\";
}"
  Ý(set_attr "length" "6")¨
)

;
; bgt instruction pattern(s).
;

(define_insn "bgt"
  Ý(set (pc)
	(if_then_else (gt (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))
;   (clobber (reg:SI 14))
   ¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 4, 0);
  if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operandsÝ0¨)))
    {
      return \"BH	%l0\";
    }
  mvs_check_page (0, 2, 4);
  return \"L	14,=A(%l0)\;BHR	14\";
}"
  Ý(set_attr "length" "6")¨
)

;
; bgtu instruction pattern(s).
;

(define_insn "bgtu"
  Ý(set (pc)
	(if_then_else (gtu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))
;   (clobber (reg:SI 14))
   ¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 4, 0);
  if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operandsÝ0¨)))
    {
      return \"BH	%l0\";
    }
  mvs_check_page (0, 2, 4);
  return \"L	14,=A(%l0)\;BHR	14\";
}"
  Ý(set_attr "length" "6")¨
)

;
; blt instruction pattern(s).
;

(define_insn "blt"
  Ý(set (pc)
	(if_then_else (lt (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))
;   (clobber (reg:SI 14))
   ¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 4, 0);
  if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operandsÝ0¨)))
    {
      return \"BL	%l0\";
    }
  mvs_check_page (0, 2, 4);
  return \"L	14,=A(%l0)\;BLR	14\";
}"
  Ý(set_attr "length" "6")¨
)

;
; bltu instruction pattern(s).
;

(define_insn "bltu"
  Ý(set (pc)
	(if_then_else (ltu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))
;   (clobber (reg:SI 14))
   ¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 4, 0);
  if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operandsÝ0¨)))
    {
      return \"BL	%l0\";
    }
  mvs_check_page (0, 2, 4);
  return \"L	14,=A(%l0)\;BLR	14\";
}"
  Ý(set_attr "length" "6")¨
)

;
; bge instruction pattern(s).
;

(define_insn "bge"
  Ý(set (pc)
	(if_then_else (ge (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))
;   (clobber (reg:SI 14))
   ¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 4, 0);
  if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operandsÝ0¨)))
    {
      return \"BNL	%l0\";
    }
  mvs_check_page (0, 2, 4);
  return \"L	14,=A(%l0)\;BNLR	14\";
}"
  Ý(set_attr "length" "6")¨
)

;
; bgeu instruction pattern(s).
;

(define_insn "bgeu"
  Ý(set (pc)
	(if_then_else (geu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))
;   (clobber (reg:SI 14))
   ¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 4, 0);
  if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operandsÝ0¨)))
    {
      return \"BNL	%l0\";
    }
  mvs_check_page (0, 2, 4);
  return \"L	14,=A(%l0)\;BNLR	14\";
}"
  Ý(set_attr "length" "6")¨
)

;
; ble instruction pattern(s).
;

(define_insn "ble"
  Ý(set (pc)
	(if_then_else (le (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))
;   (clobber (reg:SI 14))
   ¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 4, 0);
  if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operandsÝ0¨)))
    {
      return \"BNH	%l0\";
    }
  mvs_check_page (0, 2, 4);
  return \"L	14,=A(%l0)\;BNHR	14\";
}"
  Ý(set_attr "length" "6")¨
)

;
; bleu instruction pattern(s).
;

(define_insn "bleu"
  Ý(set (pc)
	(if_then_else (leu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))
;   (clobber (reg:SI 14))
   ¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 4, 0);
  if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operandsÝ0¨)))
    {
      return \"BNH	%l0\";
    }
  mvs_check_page (0, 2, 4);
  return \"L	14,=A(%l0)\;BNHR	14\";
}"
  Ý(set_attr "length" "6")¨
)

;;
;;- Negated conditional jump instructions.
;;

(define_insn ""
  Ý(set (pc)
	(if_then_else (eq (cc0)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))
;   (clobber (reg:SI 14))
   ¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 4, 0);
  if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operandsÝ0¨)))
    {
      return \"BNE	%l0\";
    }
  mvs_check_page (0, 2, 4);
  return \"L	14,=A(%l0)\;BNER	14\";
}"
  Ý(set_attr "length" "6")¨
)

(define_insn ""
  Ý(set (pc)
	(if_then_else (ne (cc0)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))
;   (clobber (reg:SI 14))
   ¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 4, 0);
  if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operandsÝ0¨)))
    {
      return \"BE	%l0\";
    }
  mvs_check_page (0, 2, 4);
  return \"L	14,=A(%l0)\;BER	14\";
}"
  Ý(set_attr "length" "6")¨
)

(define_insn ""
  Ý(set (pc)
	(if_then_else (gt (cc0)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))
;   (clobber (reg:SI 14))
   ¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 4, 0);
  if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operandsÝ0¨)))
    {
      return \"BNH	%l0\";
    }
  mvs_check_page (0, 2, 4);
  return \"L	14,=A(%l0)\;BNHR	14\";
}"
  Ý(set_attr "length" "6")¨
)

(define_insn ""
  Ý(set (pc)
	(if_then_else (gtu (cc0)
			   (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))
;   (clobber (reg:SI 14))
   ¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 4, 0);
  if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operandsÝ0¨)))
    {
      return \"BNH	%l0\";
    }
  mvs_check_page (0, 2, 4);
  return \"L	14,=A(%l0)\;BNHR	14\";
}"
  Ý(set_attr "length" "6")¨
)

(define_insn ""
  Ý(set (pc)
	(if_then_else (lt (cc0)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))
;   (clobber (reg:SI 14))
   ¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 4, 0);
  if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operandsÝ0¨)))
    {
      return \"BNL	%l0\";
    }
  mvs_check_page (0, 2, 4);
  return \"L	14,=A(%l0)\;BNLR	14\";
}"
  Ý(set_attr "length" "6")¨
)

(define_insn ""
  Ý(set (pc)
	(if_then_else (ltu (cc0)
			   (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))
;   (clobber (reg:SI 14))
   ¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 4, 0);
  if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operandsÝ0¨)))
    {
      return \"BNL	%l0\";
    }
  mvs_check_page (0, 2, 4);
  return \"L	14,=A(%l0)\;BNLR	14\";
}"
  Ý(set_attr "length" "6")¨
)

(define_insn ""
  Ý(set (pc)
	(if_then_else (ge (cc0)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))
;   (clobber (reg:SI 14))
   ¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 4, 0);
  if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operandsÝ0¨)))
    {
      return \"BL	%l0\";
    }
  mvs_check_page (0, 2, 4);
  return \"L	14,=A(%l0)\;BLR	14\";
}"
  Ý(set_attr "length" "6")¨
)

(define_insn ""
  Ý(set (pc)
	(if_then_else (geu (cc0)
			   (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))
;   (clobber (reg:SI 14))
   ¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 4, 0);
  if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operandsÝ0¨)))
    {
      return \"BL	%l0\";
    }
  mvs_check_page (0, 2, 4);
  return \"L	14,=A(%l0)\;BLR	14\";
}"
  Ý(set_attr "length" "6")¨
)

(define_insn ""
  Ý(set (pc)
	(if_then_else (le (cc0)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))
;   (clobber (reg:SI 14))
   ¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 4, 0);
  if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operandsÝ0¨)))
    {
      return \"BH	%l0\";
    }
  mvs_check_page (0, 2, 4);
  return \"L	14,=A(%l0)\;BHR	14\";
}"
  Ý(set_attr "length" "6")¨
)

(define_insn ""
  Ý(set (pc)
	(if_then_else (leu (cc0)
			   (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))
;   (clobber (reg:SI 14))
   ¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 4, 0);
  if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operandsÝ0¨)))
    {
      return \"BH	%l0\";
    }
  mvs_check_page (0, 2, 4);
  return \"L	14,=A(%l0)\;BHR	14\";
}"
  Ý(set_attr "length" "6")¨
)

;; ==============================================================
;;- Subtract one and jump if not zero.
;; These insns seem to not be getting matched ...
;; XXX should fix this, as it would improve for loops

(define_insn ""
  Ý(set (pc)
	(if_then_else
	 (ne (plus:SI (match_operand:SI 0 "register_operand" "+d")
		      (const_int -1))
	     (const_int 0))
	 (label_ref (match_operand 1 "" ""))
	 (pc)))
   (set (match_dup 0)
	(plus:SI (match_dup 0)
		 (const_int -1)))
;   (clobber (reg:SI 14))
   ¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 4, 0);
  if (mvs_check_label (CODE_LABEL_NUMBER (operandsÝ1¨)))
    {
      return \"BCT	%0,%l1\";
    }
  mvs_check_page (0, 2, 4);
  return \"L	14,=A(%l1)\;BCTR	%0,14\";
}"
  Ý(set_attr "length" "6")¨
)

(define_insn ""
  Ý(set (pc)
	(if_then_else
	 (eq (plus:SI (match_operand:SI 0 "register_operand" "+d")
		      (const_int -1))
	     (const_int 0))
	 (pc)
	 (label_ref (match_operand 1 "" ""))))
   (set (match_dup 0)
	(plus:SI (match_dup 0)
		 (const_int -1)))
;   (clobber (reg:SI 14))
   ¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 4, 0);
  if (mvs_check_label (CODE_LABEL_NUMBER (operandsÝ1¨)))
    {
      return \"BCT	%0,%l1\";
    }
  mvs_check_page (0, 2, 4);
  return \"L	14,=A(%l1)\;BCTR	%0,14\";
}"
  Ý(set_attr "length" "6")¨
)

;; =============================================================
;;- Unconditional jump instructions.
;;

;
; jump instruction pattern(s).
;

(define_insn "jump"
  Ý(set (pc)
	(label_ref (match_operand 0 "" "")))
;   (clobber (reg:SI 14))
   ¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 4, 0);
  if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operandsÝ0¨)))
    {
      return \"B	%l0\";
    }
  mvs_check_page (0, 2, 4);
  return \"L	14,=A(%l0)\;BR	14\";
}"
  Ý(set_attr "length" "6")¨
)

;
; indirect-jump instruction pattern(s).
; hack alert -- should check that displacement is < 4096

(define_insn "indirect_jump"
  Ý(set (pc) (match_operand:SI 0 "general_operand" "rm"))¨
  ""
  "*
{
  check_label_emit ();
  if (REG_P (operandsÝ0¨))
    {
      mvs_check_page (0, 2, 0);
      return \"BR	%0\";
    }
  mvs_check_page (0, 4, 0);
  return \"B	%0\";
}"
  Ý(set_attr "length" "4")¨
)

;
; tablejump instruction pattern(s).
;

(define_insn "tablejump"
  Ý(set (pc)
	(match_operand:SI 0 "general_operand" "am"))
   (use (label_ref (match_operand 1 "" "")))
;   (clobber (reg:SI 14))
   ¨
  ""
  "*
{
  check_label_emit ();
  if (REG_P (operandsÝ0¨))
    {
      mvs_check_page (0, 6, 0);
      return \"BR	%0\;DS	0F\";
    }
  mvs_check_page (0, 10, 0);
  return \"L	14,%0\;BR	14\;DS	0F\";
}"
  Ý(set_attr "length" "10")¨
)

;;
;;- Jump to subroutine.
;;
;; For the C/370 environment the internal functions, ie. sqrt, are called with
;; a non-standard form.  So, we must fix it here.  There's no BM like IBM.
;;
;; The ELF ABI is different from the C/370 ABI because we have a simpler,
;; more powerful way of dealing with structure-value returns.  Basically,
;; we use R1 to point at structure returns (64-bit and larger returns)
;; and R11 to point at the args.  Note that this handles double-precision
;; (64-bit) values just fine, in a less-kludged manner than the C/370 ABI.
;; Since R1 is used, we use R2 to pass the argument pointer to the routine.

;
; call instruction pattern(s).
;
; We define four call instruction patterns below. The first two patterns,
; although general, end up matching (only?) calls through function pointers.
; The last two, which require a symbol-ref to match, get used for all
; ordinary subroutine calls.

(define_insn "call"
  Ý(call (match_operand:QI 0 "memory_operand" "m")
	 (match_operand:SI 1 "immediate_operand" "i"))
;;    (clobber (reg:SI 2))
   ¨
  ""
  "*
{
#ifdef TARGET_LINUX
#ifdef STACK_GROWS_DOWNWARD
  static char tempÝ128¨;
  int i = STACK_POINTER_OFFSET;

  CC_STATUS_INIT;
  check_label_emit ();
  mvs_check_page (0, 10, 4);
  sprintf ( temp, \"LA	r2,%d(,sp)\;LA	15,%%0\;BASR	14,15\", i );
  return temp;
#else /* STACK_GROWS_DOWNWARD */
  CC_STATUS_INIT;
  check_label_emit ();
  mvs_check_page (0, 6, 4);
  return \"LA	15,%0\;BASR	14,15\";
#endif /* STACK_GROWS_DOWNWARD */

#else

  static char tempÝ128¨;
  int i = STACK_POINTER_OFFSET;

  CC_STATUS_INIT;
  check_label_emit ();
  if (mvs_function_check (XSTR (operandsÝ0¨, 0)))
    {
      mvs_check_page (0, 22, 4);
      sprintf ( temp, \"LA	1,136(,13)\;ST	1,%d(,13)\;LA 1,%d(,13)\;LA	15,%%0\;BALR	14,15\;LD	0,136(,13)\",
	     i - 4, i - 4 );
    }
  else
    {
      mvs_check_page (0, 10, 4);
      sprintf ( temp, \"LA	1,%d(,13)\;LA	15,%%0\;BALR	14,15\", i );
    }
  return temp;
#endif
}"
  Ý(set_attr "length" "22")¨
)

;
; call_value instruction pattern(s).
;

(define_insn "call_value"
  Ý(set (match_operand 0 "" "=rf")
 	(call (match_operand:QI 1 "memory_operand" "m")
 	      (match_operand:SI 2 "general_operand" "i")))
;;   (clobber (reg:SI 2))
   ¨
  ""
  "*
{
#ifdef TARGET_LINUX
#ifdef STACK_GROWS_DOWNWARD
  static char tempÝ128¨;
  int i = STACK_POINTER_OFFSET;
  CC_STATUS_INIT;
  mvs_check_page (0, 10, 4);
  sprintf ( temp, \"LA	r2,%d(,sp)\;LA	15,%%1\;BASR	14,15\", i );
  return temp;

#else /* STACK_GROWS_DOWNWARD */
  CC_STATUS_INIT;
  check_label_emit ();
  mvs_check_page (0, 6, 4);
  return \"LA	15,%1\;BASR	14,15\";
#endif /* STACK_GROWS_DOWNWARD */

#else

  static char tempÝ128¨;
  int i = STACK_POINTER_OFFSET;
  CC_STATUS_INIT;

  check_label_emit ();
  if (mvs_function_check (XSTR (operandsÝ1¨, 0)))
    {
      mvs_check_page (0, 22, 4);
      sprintf ( temp, \"LA	1,136(,13)\;ST	1,%d(,13)\;LA 1,%d(,13)\;LA	15,%%1\;BALR	14,15\;LD	0,136(,13)\",
	   i - 4, i - 4 );
    }
  else
    {
      mvs_check_page (0, 10, 4);
      sprintf ( temp, \"LA	1,%d(,13)\;LA	15,%%1\;BALR	14,15\", i );
    }
  return temp;

#endif
}"
  Ý(set_attr "length" "22")¨
)

(define_insn ""
  Ý(call (mem:QI (match_operand:SI 0 "" "i"))
	 (match_operand:SI 1 "general_operand" "g"))
;;   (clobber (reg:SI 2))
   ¨
  "GET_CODE (operandsÝ0¨) == SYMBOL_REF"
  "*
{
#ifdef TARGET_LINUX
#ifdef STACK_GROWS_DOWNWARD
  static char tempÝ128¨;
  int i = STACK_POINTER_OFFSET;
  CC_STATUS_INIT;
  mvs_check_page (0, 10, 4);
  sprintf ( temp, \"LA	r2,%d(,sp)\;L	15,%%0\;BASR	14,15\", i );
  return temp;

#else /* STACK_GROWS_DOWNWARD */
  CC_STATUS_INIT;
  check_label_emit ();
  mvs_check_page (0, 6, 4);
  return \"L	15,%0\;BASR	14,15\";
#endif /* STACK_GROWS_DOWNWARD */

#else

  static char tempÝ128¨;
  int i = STACK_POINTER_OFFSET;
  CC_STATUS_INIT;

  check_label_emit ();
  if (mvs_function_check (XSTR (operandsÝ0¨, 0)))
    {
      mvs_check_page (0, 22, 4);
      sprintf ( temp, \"LA	1,136(,13)\;ST	1,%d(,13)\;LA	1,%d(,13)\;L	15,%%0\;BALR	14,15\;LD	0,136(,13)\",
	   i - 4, i - 4 );
    }
  else
    {
      mvs_check_page (0, 10, 4);
      sprintf ( temp, \"LA	1,%d(,13)\;L	15,%%0\;BALR	14,15\", i );
    }
  return temp;
#endif
}"
  Ý(set_attr "length" "22")¨
)

(define_insn ""
  Ý(set (match_operand 0 "" "=rf")
	(call (mem:QI (match_operand:SI 1 "" "i"))
	      (match_operand:SI 2 "general_operand" "g")))
;;   (clobber (reg:SI 2))
   ¨
  "GET_CODE (operandsÝ1¨) == SYMBOL_REF"
  "*
{
#ifdef TARGET_LINUX
#ifdef STACK_GROWS_DOWNWARD
  static char tempÝ128¨;
  int i = STACK_POINTER_OFFSET;
  CC_STATUS_INIT;

  check_label_emit ();
  mvs_check_page (0, 10, 4);
  sprintf ( temp, \"LA	r2,%d(,sp)\;L	15,%%1\;BASR	14,15\", i );
  return temp;

#else /* STACK_GROWS_DOWNWARD */
  CC_STATUS_INIT;
  check_label_emit ();
  mvs_check_page (0, 6, 4);
  return \"L	15,%1\;BASR	14,15\";
#endif /* STACK_GROWS_DOWNWARD */

#else

  static char tempÝ128¨;
  int i = STACK_POINTER_OFFSET;
  CC_STATUS_INIT;

  check_label_emit ();
  if (mvs_function_check (XSTR (operandsÝ1¨, 0)))
    {
      mvs_check_page (0, 22, 4);
      sprintf ( temp, \"LA	1,136(,13)\;ST	1,%d(,13)\;LA	1,%d(,13)\;L	15,%%1\;BALR	14,15\;LD	0,136(,13)\",
	   i - 4, i - 4 );
    }
  else
    {
      mvs_check_page (0, 10, 4);
      sprintf ( temp, \"LA	1,%d(,13)\;L	15,%%1\;BALR	14,15\", i );
    }
  return temp;
#endif
}"
  Ý(set_attr "length" "22")¨
)

;;
;; Call subroutine returning any type.
;; This instruction pattern appears to be used only by the
;; expand_builtin_apply definition for __builtin_apply.  It is needed
;; since call_value might return an int in r15 or a float in fpr0 (r16)
;; and the builtin code calls abort since the reg is ambiguous. Well,
;; the below is probably broken anyway, we just want to go for now.
;;
(define_expand "untyped_call"
Ý(parallel Ý(call (match_operand 0 "" "")
                  (const_int 0))
              (match_operand 1 "" "")
              (match_operand 2 "" "")¨)¨
  ""
  "
{
  int i;

  emit_call_insn (GEN_CALL (operandsÝ0¨, const0_rtx, const0_rtx, const0_rtx));

  for (i = 0; i < XVECLEN (operandsÝ2¨, 0); i++)
    {
      rtx set = XVECEXP (operandsÝ2¨, 0, i);
      emit_move_insn (SET_DEST (set), SET_SRC (set));
    }

  /* The optimizer does not know that the call sets the function value
     registers we stored in the result block.  We avoid problems by
     claiming that all hard registers are used and clobbered at this
     point.  */
  /* emit_insn (gen_blockage ()); */

  DONE;
}")


;;
;;- Miscellaneous instructions.
;;

;
; nop instruction pattern(s).
;

(define_insn "nop"
  Ý(const_int 0)¨
  ""
  "*
{
  check_label_emit ();
  mvs_check_page (0, 2, 0);
  return \"NOPR	0\";
}"
  Ý(set_attr "length" "2")¨
)
