.*
.* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
.* <<<<<<<<<<<<<<<<<<<<<<<<<<  NOTE   >>>>>>>>>>>>>>>>>>>>>>>>>>>
.*  This file is part of the PRINTDOC system.  If this file is
.*   moved or if its formatting characteristics change, the PRINTDOC
.*   systems will have to be updated.
.*
.*  If this file is updated, please change ACS.PRINTDOC.INDEX(MANUALS)
.*   to reflect the new revision date.  This allows users to know
.*   when they should print a new copy.
.* <<<<<<<<<<<<<<<<<<<<<<<<<<  NOTE   >>>>>>>>>>>>>>>>>>>>>>>>>>>
.* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
.*
.*  This is the Structured Macros Internals Guide
.*  coded to use GML tags.  It should be invoked with options
.*  PASS(2) SYSVAR('D YES T CENTER H YES') SEC(32) LINES(16)
.*
:gdoc.
:frontm.
.ti ! 05
.tr _ &
.dh 0 spbf 4.5i
.rc 1
.rc 2 |
.se @bodyhead1 = 'Chapter'
.df figfont list (xmpfont)
:titlep.
:title stitle='Clemson Structured Macros'.
Clemson University Computer Center
:title.Structured Programming Macros
:title.Internals
:date.
:author.Last revision: October 1, 1987
:etitlep.
:toc.
:preface.
:p.
The Structured Programming Macros is a programming tool
developed at Clemson University for internal use by the
staff of the Computer Center.  However, after they were
written, the decision was made to release them to the public
since they are very useful to anyone who is programming in
System/370 Assembler language.
:p.
The manual contains information about the internals of these
macros.  There is also some useful information on internals
contained in the appendixes of the :q.Clemson University
Computer Center Structured Programming Macros User's Guide
and Reference:eq. including the PWA layout, the SWA layout
and information on macro register usage.
:p.
:body.
.se @stitle 'Structured Macros Internals
.*
:h1 id=condexp.Conditional Expressions
:p.
Conditional expressions can be coded on the
ELSEIF, ENDLOOP, ERREXIT, IF, LEAVE and LOOP macros.
All of these macros call internal macro ##COND to evaluate
the conditional expression.
:p.
Macro ##COND is described in :hdref refid=cond..  ##COND
expects a conditional expression, a tag to branch to if the
expression is false, a tag to branch to if the condition is true
and a :q.logic flag:eq..
:p.
This logic flag indicate whether the code following the ##COND
macro will be executed if the condition is true or if it is false.
If LOGIC=P is specified on ##COND, the :q.last branch:eq. generated
by ##COND will be to the :q.success code:eq..  As an example, the
ERREXIT macro uses positive (P) logic because if the condition is true,
you want to branch to the error exit.  If LOGIC=N is specified (negative
logic), the :q.last branch:eq. generated will be to the :q.fail tag:eq..
The IF macro uses negative logic because it wants to :q.fall through:eq.
to the success code if the condition is true.
:figref refid=logicfg. illustrates the difference between positive and
negative logic.
:fig id=logicfg frame=box place=inline.
.fo off
.sp 2
    IF (CLC,A,EQ,B)               IF uses negative logic
+           CLC   A,B
+           BNE   (fail tag)      Branch to fail tag
      ... instructions to execute if condition is true ...
    ENDIF
+(fail tag) DS    0H
.sp 2
    ERREXIT (CLC,A,EQ,B)          ERREXIT uses postive logic
+            CLC   A,B
+            BE    (errexit tag)  Branch to success tag
.sp 2
:figcap.Positive and negative logic
:efig.
:p.
##COND must be supplied with both a fail and success tag no matter
which type of logic is specified.  These fail and success tags are
used when generating code for ORs and ANDs.
:figref refid=orand. shows one simple example of when both tags are
used.
:fig id=orand frame=box place=inline.
.fo off
.sp 2
    IF (CLC,A,EQ,B),OR,(CLC,C,EQ,D)
+              CLC   A,B
+              BE    (success tag)   Branch to success tag
+              CLC   C,D
+              BNE   (fail tag)      Branch to fail tag
+(success tag) DS    0H
      ... instructions to execute if condition is true ...
    ENDIF
+(fail tag)    DS    0H
.sp 2
:figcap.Using both a success and a fail tag
:efig.
:h1 id=proepi.Prolog and Epilog Macros
:p.
The BLOCK, ENDBLK, PWA, ENDPWA, SWA and ENDSWA macros are
structured so that multiple environments can be supported.
These macros do a little housekeeping and call another
:q.expansion macros:eq. to do the bulk of the work.  The
names of the expansion macros to be called can be supplied
by the EXPMAC= keyword on each the above mentioned macros, or
they can be determined by a macro called ##$xxx where :q.xxx:eq. is the
value of the ENVIRON= keyword on the program block macro.
:p.
The ##$xxx macro is by far, the preferred way of supplying the
expansion macros name.  In fact, the EXPMAC= keyword is not
even documented in the user's guide.
:figref refid=expmac. contains a sample ##$xxx macro.
:fig id=expmac frame=box place=inline.
.fo off
.sp 2
         MACRO
         ##$xxx
         GBLC  _#PPMAC,_#PEMAC,_#EPMAC,_#EEMAC
         GBLC  _#SPMAC,_#SEMAC,_#IPMAC,_#IEMAC
         GBLC  _#WPMAC,_#WEMAC,_#UPMAC,_#UEMAC
_#PPMAC  SETC  '##PPOS'          PROGRAM BLOCK PROLOG MACRO NAME
_#PEMAC  SETC  '##PEOS'          PROGRAM BLOCK EPILOG MACRO NAME
_#EPMAC  SETC  '##EPSTD'         ERREXIT BLOCK PROLOG MACRO NAME
_#EEMAC  SETC  '##EESTD'         ERREXIT BLOCK EPILOG MACRO NAME
_#SPMAC  SETC  '##SPSTD'         SUBROUTINE BLOCK PROLOG MACRO
_#SEMAC  SETC  '##SESTD'         SUBROUTINE BLOCK EPILOG MACRO
_#IPMAC  SETC  '##IPSTD'         INLINE BLOCK PROLOG MACRO NAME
_#IEMAC  SETC  '##IESTD'         INLINE BLOCK EPILOG MACRO NAME
_#WPMAC  SETC  '##WPOS'          PWA PROLOG MACRO NAME
_#WEMAC  SETC  '##WESTD'         PWA EPILOG MACRO NAME
_#UPMAC  SETC  '##UPSTD'         SWA PROLOG MACRO NAME
_#UEMAC  SETC  '##UESTD'         SWA EPILOG MACRO NAME
         MEND
.sp 2
:figcap.Sample ##$xxx macro
:efig.
:p.
New expansion macros can be written to support other
environments.  For example, macros could be written to
support the JES2 or CICS environments.  Writing these
expansion macros requires a thorough understanding of the
Structured Macros.  The reference material in this manual
will be a great help in this understanding, but examining the
Structured Macros themselves will also be required.  This is
:hp2.NOT:ehp2. an OCO product.
:p.
Probably the best way to write an new expansion macro is to
start with an existing copy of a similar macro.
Be sure to set all of the global variables that are needed by the
other Structured Macros.
It will probably not be necessary to write a complete set of
expansion macros to support a new environment.  Some of the
existing macros that end with :q.STD:eq. are used to provide
part of the support for the DC, OS and PLI environments.  It
is possible that these :q.standard:eq. expansion macros will
support other environments as well.
.*
:h2.Block Expansion Macros
The BLOCK and ENDBLK macros do some housekeeping and then call
the appropriate expansion macro.
:p.
The BLOCK macro does the following processing before calling any
expansion macro:
:ul compact.
:li.Makes sure that block level will not exceed 20.
:li.Increments _#BLVL, _#MLVL and _#MNDX.
:li.Sets the new entries in _#BNAME, _#BNDX, _#BMLVL, _#BTYPE,
_#BPL1 and _#BPL2 to their appropriate values.
:eul.
The ENDBLK macro does the following processing before calling any
expansion macro:
:ul compact.
:li.Insures that _#BLVL, _#BMLVL(_#BLVL) and _#BNAME(_#BLVL) are
correct.
:li.Decrements _#MLVL.
:li.Checks the syntax of the RC keyword's value.
:eul.
After calling the expansion macro, ENDBLK decrements _#BLVL.
:h3 id=##pp.Program Block Prolog Macros
:p.
Program block prolog macros are called by the BLOCK macro.
By convention, their names start with :q.##PP:eq..
:p.
The BLOCK macro does the following additional processing before
calling this type of expansion macro:
:ul compact.
:li.Insures that the program block is at block level 1.
:li.Increments _#PB#C.
:li.Sets _#PBENC to true.
:li.Calls internal macro ##DEFSUB to define program name.
:li.Sets _#SB#C and _#SB#CPB to the  current block number.
:li.Resets _#CSFT#N to 1.
:li.Resets _#PBPLMX and _#PBWAMX to zero.
:li.Sets _#PBNAME and _#PBNDX as appropriate.
:li.Issues :q.ignored messages:eq. if keywords SWAREG, RECUR and
SAVE are specified.
:li.Calls the ##$xxx macro for the current environment.
:eul.
When the BLOCK macro calls a program block prolog macro, it
passes the values of keywords NAME, OPTIONS, SDID, WAID,
SUBOPTS, BASEREG, PWAREG, SVAREA, CPYRGHT, AMODE, RMODE,
R1SAVE, SMWA, DYNSIZE, DYNERR and PWASP
as positional parameters in the given order.
:h3 id=##pe.Program Block Epilog Macros
:p.
Program block epilog macros are called by the ENDBLK macro.
By convention, their names start with :q.##PE:eq..
:p.
When the ENDBLK macro calls a program block epilog macro, it
passes the values of keywords RC, R0 and R1
as positional parameters in the given order.
:h3 id=##ip.Inline Block Prolog Macros
:p.
Inline block prolog macros are called by the BLOCK macro.
By convention, their names
start with :q.##IP:eq..
:p.
The BLOCK macro does the following additional processing before
calling this type of expansion macro:
:ul compact.
:li.Insures that the inline block is not at block level 1.
:li.Issues :q.ignored messages:eq. if keywords
SUBOPTS, BASEREG, PWAREG, SVAREA, CPYRGHT, RMODE, R1SAVE,
SMWA, DYNSIZE, DYNERR, SWAREG, RECUR, PWASP or ENVIRON are
specified.
:eul.
When the BLOCK macro calls an inline block prolog macro, it
passes the values of keywords NAME, OPTIONS, SDID, WAID,
AMODE and SAVE as positional parameters in the given order.
:h3 id=##ie.Inline Block Epilog Macros
:p.
Inline block epilog macros are called by the ENDBLK macro.
By convention, their names start with :q.##IE:eq..
:p.
When the ENDBLK macro calls a inline block epilog macro, it
passes the values of the RC keyword
as a positional parameter.
:h3 id=##sp.Subroutine Block Prolog Macros
:p.
Subroutine block prolog macros are called by the BLOCK macro.
By convention, their names
start with :q.##SP:eq..
:p.
The BLOCK macro does the following additional processing before
calling this type of expansion macro:
:ul compact.
:li.Insures that the subroutine block is at block level 1.
:li.Issues :q.ignored messages:eq. if keywords SUBOPTS,
PWAREG, SVAREA, CPYRGHT, RMODE, R1SAVE, SMWA, DYNSIZE,
DYNERR, PWASP or ENVIRON are specified.
:eul.
When the BLOCK macro calls a subroutine block prolog macro,
it passes the values of keywords NAME, OPTIONS, SDID, WAID,
BASEREG, AMODE, SMWA, SWAREG, RECUR and SAVE as positional
parameters in the given order.
:h3 id=##se.Subroutine Block Epilog Macros
:p.
Subroutine block epilog macros are called by the ENDBLK macro.
By convention, their names
start with :q.##SE:eq..
:p.
When the ENDBLK macro calls a subroutine block epilog macro, it
passes the values of the RC keyword
as a positional parameter.
:h3 id=##ep.Error Exit Block Prolog Macros
:p.
Error exit block prolog macros are called by the BLOCK macro.
By convention, their names
start with :q.##EP:eq..
:p.
The BLOCK macro does the following additional processing before
calling this type of expansion macro:
:ul compact.
:li.Insures that the error exit block is at block level 1 and follows
a program block.
:li.Issues :q.ignored messages:eq. if keywords SUBOPTS,
BASEREG, PWAREG, SVAREA, CPYRGHT, RMODE, R1SAVE, SMWA,
DYNSIZE, DYNERR, SWAREG, RECUR, PWASP and ENVIRON are
specified.
:eul.
When the BLOCK macro calls an error exit block prolog macro, it
passes the values of keywords NAME, OPTIONS, SDID, WAID,
BASEREG, AMODE and SAVE as positional parameters in the
given order.
:h3 id=##ee.Error Exit Block Epilog Macros
:p.
Error exit block prolog macros are called by the ENDBLK macro.
By convention, their names
start with :q.##EE:eq..
:p.
When the ENDBLK macro calls a error exit block epilog macro, it
passes the values of keywords RC, R0 and R1
as positional parameters in the given order.
:h2.Work Area Expansion Macros
PWA, ENDPWA, SWA and ENDSWA call expansion macros.  They do not
do any housekeeping before calling.
:h3 id=##wp.Program Work Area Prolog Macros
:p.
PWA prolog macros are called by the PWA macro.
By convention, their names
start with :q.##WP:eq..
:p.
The PWA macro calls a PWA prolog macro with
the value of the TYPE keyword
as a positional parameter.
:h3 id=##we.Program Work Area Epilog Macros
:p.
PWA epilog macros are called by the ENDPWA macro.
By convention, their names
start with :q.##WE:eq..
:p.
The ENDPWA macro calls a PWA epilog macro without any
parameters.
:h3 id=##up.Subroutine Work Area Prolog Macros
:p.
SWA prolog macros are called by the SWA macro.
By convention, their names
start with :q.##UP:eq..
:p.
The SWA macro calls a SWA prolog macro with
the value of the TYPE keyword
as positional parameter.
:h3 id=##ue.Subroutine Work Area Epilog Macros
:p.
SWA epilog macros are called by the ENDSWA macro.
By convention, their names
start with :q.##UE:eq..
:p.
The ENDSWA macro calls a SWA epilog macro without any
positional parameters.
:h1.Internal Macros
:p.
This chapter contains all of the internal macros used by the Structured
Macros.  All of these macros begin with :q.##:eq..  The error messages
produced by these macros are documented in :cit.Clemson University
Computer Center Structured Programming Macros User's Guide and
Reference:ecit..
.kp on
:h2.Internal Macro ##$DC
:dl.
:dt.Macro:
:dd.##$DC
:dt.Abstract:
:dd.##$DC is an internal macro used to set the expansion macro names
for the DC environment.
Refer to :hdref refid=proepi. for more information on this type of
macro.
:dt. Syntax:
:dd.##$DC
:dt.Operands:
:dd.None
:edl.
.kp off
.kp on
:h2.Internal Macro ##$OS
:dl.
:dt.Macro:
:dd.##$OS
:dt.Abstract:
:dd.##$OS is an internal macro used to set the expansion macro
names for the OS environemnt.
Refer to :hdref refid=proepi. for more information on this type of
macro.
:dt. Syntax:
:dd.##$OS
:dt.Operands:
:dd.None
:edl.
.kp off
.*
.kp on
:h2.Internal Macro ##$PLI
:dl.
:dt.Macro:
:dd.##$PLI
:dt.Abstract:
:dd.##$PLI is an internal macro used to set the expansion macro
names for the PL/I environemnt.
Refer to :hdref refid=proepi. for more information on this type of
macro.
:dt. Syntax:
:dd.##$PLI
:dt.Operands:
:dd.None
:edl.
.kp off
.*
.kp on
:h2.Internal Macro ##ASMH
:dl.
:dt.Macro:
:dd.##ASMH
:dt.Abstract:
:dd.##ASMH is an internal macro used to set the global binary variable
##ASMH.  After the ##ASMH macro is invoked, the variable ##ASMH
will have the value 1 if the Level H Assembler is being used,
and the value 0 if the Level H Assembler is not being used.
:dt. Syntax:
:dd.##ASMH ((a))&lbt.,PASS=FIRST|SECOND&rbt.
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.a
:dd.This can be any value since the expression in parentheses
is not actually used by ##ASMH.  The macro makes use of the
differences in the way nested expressions are treated to determine
the assembler being used.  Therefore, the actual values passed
to ##ASMH does not matter, but it must be enclosed in double
parentheses.  Any macro or code that requires the Level H
Assembler can use ##ASMH to verify that it is being used.
:dt.PASS=
:dd.This keyword should not be used by the caller of ##ASMH.
It is used by ##ASMH itself for internal use.
:edl.
:edl.
.kp off
.*
.kp on
:h2 id=cond.Internal Macro ##COND
:dl.
:dt.Macro:
:dd.##COND
:dt.Abstract:
:dd.##COND is an internal recursive macro used by the IF, ELSEIF,
LOOP, ENDLOOP, LEAVE, and ERREXIT macros to generate compare
and branch instructions based on a boolean condition expression.
Refer to :hdref refid=condexp. for more information.
:p.
The following left recursive productions describe the syntax for
condition expressions.  Production A is a special production used
only by the IF and ELSEIF macros to allow a :hp2.,THEN:ehp2.
to be placed
after the condition expression.  Productions B defines the form of a
condition expression.
.kp off
.kp on
:dl tsize=8 termhi=0.
.tp 23 51
:dt.A
:dd.::=!B:hp2.,THEN:ehp2. | B
:dt.B
:dd.::=!B:hp2.,OR,:ehp2.C | C
:dt.C
:dd.::=!C:hp2.,AND,:ehp2.D | D
:dt.D
:dd.::=!:hp2.NOT,:ehp2.E | E
:dt.E
:dd.::=!(B) | (COMP) | COND
:dt.COMP
:dd.::=!:hp2.CLC,:ehp2.OP1,COND,OP2!|
!:hp2.CR,:ehp2.OP1,COND,OP2!|
!:hp2.C,:ehp2.OP1,COND,OP2!|
!:hp2.CP,:ehp2.OP1,COND,OP2!|
!:hp2.CH,:ehp2.OP1,COND,OP2!|
!:hp2.CLR,:ehp2.OP1,COND,OP2!|
!:hp2.CL,:ehp2.OP1,COND,OP2!|
!:hp2.CLI,:ehp2.OP1,COND,OP2!|
!:hp2.CLCL,:ehp2.OP1,COND,OP2!|
!:hp2.TM,:ehp2.OP1,COND,OP2!|
!:hp2.CLM,:ehp2.OP1,MASK,COND,OP2!|
!:hp2.TREG,:ehp2.OP1,COND!|
!:hp2.TBIT,:ehp2.&lbt.OP1,&rbt.OP2:hp2.&lbt.,ON|OFF|ANY|MIXED:ehp2.&rbt.
default ON
!:hp2.#TEST,:ehp2.OP1:hp2.&lbt.,ON|OFF|ANY&rbt.:ehp2. default ON
.kp off
.kp on
.tp 23 35 40
:dt.COND
:dd.::=!:hp2.EQ:ehp2.!|!&lbr.equal&rbr.
!:hp2.E:ehp2.!|!&lbr.equal&rbr.
!:hp2.NE:ehp2.!|!&lbr.not equal&rbr.
!:hp2.LT:ehp2.!|!&lbr.less than&rbr.
!:hp2.GT:ehp2.!|!&lbr.greater than&rbr.
!:hp2.LE:ehp2.!|!&lbr.less than or equal&rbr.
!:hp2.GE:ehp2.!|!&lbr.greater than or equal&rbr.
!:hp2.Z:ehp2.!|!&lbr.zero&rbr.
!:hp2.NZ:ehp2.!|!&lbr.not zero&rbr.
!:hp2.M:ehp2.!|!&lbr.minus or mixed&rbr.
!:hp2.NM:ehp2.!|!&lbr.not minus or not mixed&rbr.
!:hp2.P:ehp2.!|!&lbr.positive&rbr.
!:hp2.NP:ehp2.!|!&lbr.not positive&rbr.
!:hp2.O:ehp2.!|!&lbr.ones&rbr.
!:hp2.NO:ehp2.!|!&lbr.not ones&rbr.
!:hp2.ON:ehp2.!|!&lbr.on&rbr.
!:hp2.OFF:ehp2.!|!&lbr.off&rbr.
!:hp2.ANY:ehp2.!|!&lbr.any on&rbr.
!:hp2.MIXED:ehp2.!|!&lbr.mixed&rbr.
!:hp2.CC1-CC14:ehp2.!!&lbr.condition codes 1 through 14&rbr.
:dt.OP1
:dd.::=!Anything that is valid for operand 1 of the associated opcode
:dt.OP2
:dd.::=!Anything that is valid for operand 2 of the associated opcode
:dt.MASK
:dd.::=!Anything that is valid as a mask for the associated opcode
.tp
:edl.
.kp off
.kp on
:dt. Syntax:
:dd.##COND
expr,S=s,F=f&lbt.,T=A|B|C|D|E&rbt.&lbt.,L=N|P&rbt.&lbt.,B=b&rbt.,E=e
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.expr
:dd.Syslist entries.  These entries must be of a form
that can be parsed by the production specified on the T= keyword.
:dt.s
:dd.Tag to use for branch to success code
:dt.f
:dd.Tag to use for branch to fail code.
:dt.T=
:dd.Production (A|B|C|D|E) to start with.
:dt.L=
:dd.Logic (N|P).  :q.N:eq. indicates that the last branch generated
should be to fail tag.  :q.P:eq. indicates that the last branch
generated should be to success tag.
:dt.b
:dd._SYSLIST entry to start with.  Default is 1.
:dt.e
:dd._SYSLIST entry to end with.
:edl.
:edl.
.kp off
.kp on
.*
:h2.Internal Macro ##CVREG
:dl.
:dt.Macro:
:dd.##CVREG
:dt.Abstract:
:dd.##CVREG is an internal macro used to convert registers
specified as :q.Rn:eq. or :q.Rnn:eq. to the corresponding numeric value
for internal use.
:dt. Syntax:
:dd.##CVREG reg
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.reg
:dd.Register specification of the form :q.Rn:eq. or :q.Rnn:eq.
:edl.
:edl.
.kp off
.kp on
.*
:h2.Internal Macro ##DEFSUB
:dl.
:dt.Macro:
:dd.##DEFSUB
:dt.Abstract:
:dd.##DEFSUB is an internal macro used to maintain the subroutine
table.  When passed a subroutine name, it defines it to the table
if it does not already exist, and returns the subroutine number
in the global variable #SB#D.  This is used by the subroutine
block macro and by the CALLSUB macro.
:dt. Syntax:
:dd.##DEFSUB name
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.name
:dd.Name of subroutine to be defined or queried
:edl.
:edl.
.kp off
.*
.kp on
:h2.Internal Macro ##EESTD
:dl.
:dt.Macro:
:dd.##EESTD
:dt.Abstract:
:dd.##EESTD is the standard error exit epilog expansion macro.
:p.Refer to :hdref refid=##ee. for more information.
:edl.
.kp off
.*
.kp on
:h2.Internal Macro ##EPSTD
:dl.
:dt.Macro:
:dd.##EPSTD
:dt.Abstract:
:dd.##EPSTD is the standard error exit prolog expansion macro.
:p.Refer to :hdref refid=##ep. for more information.
##EPSTD ignores keywords OPTIONS, BASEREG, SDID and WAID.
:edl.
.kp off
.*
.kp on
:h2.Internal Macro ##IESTD
:dl.
:dt.Macro:
:dd.##IESTD
:dt.Abstract:
:dd.##IESTD is the standard inline block epilog expansion macro.
:p.Refer to :hdref refid=##ie. for more information.
:edl.
.kp off
.*
.kp on
:h2.Internal Macro ##IGMSG
:dl.
:dt.Macro:
:dd.##IGMSG
:dt.Abstract:
:dd.Macro ##IGMSG is used to display an operand ignored message.
It is used mostly by the prolog and epilog macros to indicate
which keyword are not supported by the given expansion macro.
:dt. Syntax:
:dd.##IGMSG kwd,kwdname
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.kwd
:dd.The value of the keyword being ignored.
:dt.kwdname
:dd.The name of the keyword being ignored.
:edl.
:edl.
.kp off
.*
.kp on
:h2.Internal Macro ##IPSTD
:dl.
:dt.Macro:
:dd.##IPSTD
:dt.Abstract:
:dd.##IPSTD is the standard inline block prolog expansion macro.
:p.Refer to :hdref refid=##ip. for more information.
##IPSTD ignores keywords OPTIONS, SDID and WAID.
:edl.
.kp off
.*
.kp on
:h2.Internal Macro ##LA
:dl.
:dt.Macro:
:dd.##LA
:dt.Abstract:
:dd.##LA is an internal macro used by PLIST to load the address
of fields that are not in standard assembler form.  It is this
macro that allows the specification of numeric and character
constants in parameter lists.
If the field is a decimal constant, a LA reg,=F'field' is done.
If the field is a character constant, a LA reg,=C'field' is done.
Otherwise, a LA reg,field is performed.
:dt. Syntax:
:dd.##LA reg,field
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.reg
:dd.Register to load
:dt.field
:dd.Field to load address of
:edl.
:edl.
.kp off
.kp on
.*
:h2.Internal Macro ##LDBS
:dl.
:dt.Macro:
:dd.##LDBS
:dt.Abstract:
:dd.##LDBS is an internal macro used by the subroutine and program
block expansion macros
to load base registers.
##LDBS loads the selected base
registers with the appropriate values and establishes addressability.
:dt. Syntax:
:dd.##LDBS name,&lbt.reg|(reg,...)&rbt.&lbt.,defreg&rbt.&lbt.,
.ct FRSTLD=YES|NO&rbt.
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.name
:dd.Tag to establish addressability on.  ##LDBS will assume that
register 15 will point to this address.  If :hp1.name:ehp1. is
specified as an asterisk (*), ##LDBS will use a
BALR :hp1.reg:ehp1.,0 to get the subroutine address.
:dt.reg
:dd.Register(s) to use as base registers for the subroutine.  These
may be any of the registers R3-R10 and no register may be repeated.
If this operand is missing the default base register will be used.
:dt.defreg
:dd.Register to use as the default base register.  This operand
is only used if :hp1.reg:ehp1. operand is null.  However, if the
:hp1.reg:ehp1. operand might be missing, :hp1.defreg:ehp1. must
be specified.
:dt.frst
:dd.Specifies whether the first base register should be loaded.
If NO is specified, the first base register is expected to be
preloaded.  NO is the default.
YES indicates that this macro should load the first base register.
:edl.
:edl.
.kp off
.*
.kp on
:h2.Internal Macro ##MREG
:dl.
:dt.Macro:
:dd.##MREG
:dt.Abstract:
:dd.##MREG is an internal macro that is used to keep up with which
registers are being used by the macros.
:dt. Syntax:
:dd.##MREG type,reg
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.type
:dd.Type of function requested.  A type of RESET causes registers
14 through 1 to be set as in use and the rest of the registers are
marked as not in use.
A type of USE or RELEASE
causes a register to be marked in use or not in use, respectively.
:dt.reg
:dd.Register to be marked as in use or not in use.
:edl.
:edl.
.kp off
.*
.kp on
:h2.Internal Macro ##ORGS
:dl.
:dt.Macro:
:dd.##ORGS
:dt.Abstract:
:dd.##ORGS is an internal macro called from ENDPWA to calculate the
amount of SWA storage that must be reserved at the end of the PWA
if Dynamic Storage Management is being used.  It is called recursively
to trace the subroutine call structure and generate ORG statements
to reserve storage.
:dt. Syntax:
:dd.##ORGS f,c
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.f
:dd.Subroutine to generate ORGs for
:dt.c
:dd.Place subroutine was called from
:edl.
:edl.
.kp off
.*
.kp on
:h2.Internal Macro ##PEDC
:dl.
:dt.Macro:
:dd.##PEDC
:dt.Abstract:
:dd.##PEDC is the program block epilog expansion macro for the DC
environment.
:p.Refer to :hdref refid=##pe. for more information.
:edl.
.kp off
.*
.kp on
:h2.Internal Macro ##PEOS
:dl.
:dt.Macro:
:dd.##PEOS
:dt.Abstract:
:dd.##PEOS is the program block epilog expansion macro for the OS
environment.
:p.Refer to :hdref refid=##pe. for more information.
:edl.
.kp off
.*
.kp on
:h2.Internal Macro ##PEPLI
:dl.
:dt.Macro:
:dd.##PEPLI
:dt.Abstract:
:dd.##PEPLI is the program block epilog expansion macro for the PL/I
environment.
:p.Refer to :hdref refid=##pe. for more information.
##PEPLI ignores keywords R0, R1 and RC.
:edl.
.kp off
.*
.kp on
:h2.Internal Macro ##PPDC
:dl.
:dt.Macro:
:dd.##PPDC
:dt.Abstract:
:dd.##PPDC is the program block prolog expansion macro for the DC
environment.
:p.Refer to :hdref refid=##pp. for more information.
##PPDC ignores keywords DYNSIZE, DYNERR, SVAREA, PWASP, SDID and WAID.
:edl.
.kp off
.*
.kp on
:h2.Internal Macro ##PPOS
:dl.
:dt.Macro:
:dd.##PPOS
:dt.Abstract:
:dd.##PPOS is the program block prolog expansion macro for the OS
environment.
:p.Refer to :hdref refid=##pp. for more information.
:edl.
.kp off
.*
.kp on
:h2.Internal Macro ##PPPLI
:dl.
:dt.Macro:
:dd.##PPPLI
:dt.Abstract:
:dd.##PPPLI is the program block prolog expansion macro for the PL/I
environment.
:p.Refer to :hdref refid=##pp. for more information.
##PPPLI ignores keywords
SVAREA, R1SAVE, SMWA, DYNSIZE, DYNERR, SWAREG, PWASP, WAID and SDID.
:edl.
.kp off
.*
.kp on
:h2.Internal Macro ##REGS
:dl.
:dt.Macro:
:dd.##REGS
:dt.Abstract:
:dd.##REGS is an internal macro used by the BLOCK macro. It
equates R0, R1, R2, ... ,R15 to 0, 1, 2, ... ,15.
:dt. Syntax:
:dd.##REGS
:dt.Operands:
:dd.None
:edl.
.kp off
.kp on
.*
:h2.Internal Macro ##RST
:dl.
:dt.Macro:
:dd.##RST
:dt.Abstract:
:dd.##RST is an internal macro used by the ENDBLK macro
to restore registers.
:dt. Syntax:
:dd.##RST &lbt.level&rbt.,R15=YES|NO
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.level
:dd.block level to restore registers from. Defaults to
current block level.
:dt.R15=
:dd.Specifies whether R15 should be restored or not.
:edl.
:edl.
.kp off
.kp on
.*
:h2.Internal Macro ##RTN
:dl.
:dt.Macro:
:dd.##RTN
:dt.Abstract:
:dd.##RTN is an internal macro used by the ENDBLK macro
to set return code, restore registers, and return.
:dt. Syntax:
:dd.##RTN &lbt.rc&rbt.,sv
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.rc
:dd.symbol - symbol indicating return code
:p.
(reg)  - register number containing return code
:dt.sv
:dd.0 - registers should not be restored
:p.
1 - registers should be restored
:edl.
:edl.
.kp off
.kp on
.*
:h2.Internal Macro ##RWREG
:dl.
:dt.Macro:
:dd.##RWREG
:dt.Abstract:
:dd.##RWREG restores the register requested from the current
Structured Macro Work Area (SMWA).
:dt. Syntax:
:dd.##RWREG reg
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.reg
:dd.register to restore from the current SMWA
:edl.
:edl.
.kp off
.*
.kp on
:h2.Internal Macro ##SESTD
:dl.
:dt.Macro:
:dd.##SESTD
:dt.Abstract:
:dd.##SESTD is the standard subroutine block epilog expansion macro.
:p.Refer to :hdref refid=##se. for more information.
##SESTD ignores keywords R0 and R1.
:edl.
.kp off
.*
.kp on
:h2.Internal Macro ##SPSTD
:dl.
:dt.Macro:
:dd.##SPSTD
:dt.Abstract:
:dd.##SPSTD is the standard subroutine block prolog expansion macro.
:p.Refer to :hdref refid=##sp. for more information.
##SPSTD ignores keywords SDID and WAID.
:edl.
.kp off
.*
.kp on
:h2.Internal Macro ##SUBOPT
:dl.
:dt.Macro:
:dd.##SUBOPT
:dt.Abstract:
:dd.##SUBOPT is used to set subroutine options.  It is called by
program block prolog macros to set default subroutine options and
by subroutine block prolog macros to set the current subroutine's
options.
:dt. Syntax:
:dd.##SUBOPT options&lbt.,DEFAULT=def&rbt.
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.option
:dd.the options to be set.
:dt.def
:dd.
YES - the options are taken as defaults
.br
NO  - the options are active for the current subroutine
:edl.
:edl.
.kp off
.*
.kp on
:h2.Internal Macro ##SWREG
:dl.
:dt.Macro:
:dd.##SWREG
:dt.Abstract:
:dd.##SWREG saves the register requested in the current
Structured Macro Workarea (SMWA).
:dt. Syntax:
:dd.##SWREG reg
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.reg
:dd.register to save in the current SMWA
:edl.
:edl.
.kp off
.*
.kp on
:h2.Internal Macro ##UESTD
:dl.
:dt.Macro:
:dd.##UESTD
:dt.Abstract:
:dd.##UESTD is the standard Subroutine Work Area (SWA)
epilog expansion macro.
:p.Refer to :hdref refid=##ue. for more information.
:edl.
.kp off
.*
.kp on
:h2.Internal Macro ##UPSTD
:dl.
:dt.Macro:
:dd.##UPSTD
:dt.Abstract:
:dd.##UPSTD is the standard Subroutine Work Area (SWA)
prolog expansion macro.
:p.Refer to :hdref refid=##up. for more information.
:edl.
.kp off
.*
.kp on
:h2.Internal Macro ##WESTD
:dl.
:dt.Macro:
:dd.##WESTD
:dt.Abstract:
:dd.##WESTD is the standard Program Work Area (PWA)
epilog expansion macro.
:p.Refer to :hdref refid=##we. for more information.
:edl.
.kp off
.*
.kp on
:h2.Internal Macro ##WPDC
:dl.
:dt.Macro:
:dd.##WPDC
:dt.Abstract:
:dd.##WPDC is the prolog macro for a DC environment Program Work Area.
:p.Refer to :hdref refid=##wp. for more information.
:edl.
.kp off
.*
.kp on
:h2.Internal Macro ##WPPLI
:dl.
:dt.Macro:
:dd.##WPPLI
:dt.Abstract:
:dd.##WPPLI is the prolog macro for an PL/I
environment Program Work Area.
:p.Refer to :hdref refid=##wp. for more information.
:edl.
.kp off
.*
.kp on
:h2.Internal Macro ##WPOS
:dl.
:dt.Macro:
:dd.##WPOS
:dt.Abstract:
:dd.##WPOS is the prolog macro for an OS environment Program Work Area.
:p.Refer to :hdref refid=##wp. for more information.
:edl.
.kp off
.*
:h1.Global Variables
:p.
This chapter contains all of the global variables used by the
Structured Macros.
All of the global variables used begin with
with :q._#:eq..
:p.
When :q.structural nesting level:eq. is used in these descriptions,
it indicates the nesting level of all structures.
The other times when :q.nesting level:eq. is used, it refers
to a particular type of structured.
:p.
For example:
:xmp.
BLOCK TYPE=PROGRAM   &lbr.Structural nesting level 1&rbr.
 ...                 &lbr.Block nesting level 1     &rbr.
 LOOP                &lbr.Structural nesting level 2&rbr.
  ...                &lbr.Loop nesting level 1      &rbr.
  IF (CLC,A,EQ,B)    &lbr.Structural nesting level 3&rbr.
   ...               &lbr.If nesting level 1        &rbr.
   IF (CLC,C,EQ,D)   &lbr.Structural nesting level 4&rbr.
    ...              &lbr.If nesting level 2        &rbr.
    LOOP             &lbr.Structural nesting level 5&rbr.
    ...              &lbr.Loop nesting level 2      &rbr.
    ENDLOOP
   ENDIF
  ENDIF
 ENDLOOP
ENDBLK
:exmp.
:dl tsize=20.
:dt._##ASMH
:dd.Logical variable _##ASMH is set by macro ##ASMH.  ##ASMH will set
the variable to 1 if Assembler H is being used; otherwise, it is set to
0.  Other macros use this variable to determine whether to do Assembler
H dependent operations.  _##ASMH is used in macros ##ASMH, ##PPDC and
##PPOS.
:dt._#BAMODE(20)
:dd.Character array _#BAMODE is used to contain the addressing modes for
the currently nested blocks.  The index to this array is the block
nesting level.  Usually variable _BLVL is used as an index.  _#BAMODE is
use in macros ##EESTD, ##EPSTD, ##IESTD, ##IPSTD, ##PEDC, ##PPDC,
##PPPLI, ##PPOS, ##SESTD, ##SPSTD, LEAVE and PLIST.
:dt._#BLVL
:dd.Arithmetic variable _#BLVL is used to hold the current block nesting
level.  The block nesting level is always one except inside inline
blocks.  _#BLVL is used in macros ##EESTD, ##EPSTD, ##IESTD, ##IPSTD,
##PEDC, ##PPDC, ##PPPLI, ##PPOS, ##RST, ##SESTD, ##SPSTD, BLOCK,
ENDBLK, LEAVE and PLIST.
:dt._#BMLVL(20)
:dd.Arithmetic array _#BMLVL is used to hold the structural nesting
level for each currently nested block.  The block nesting level is used
as an index.  The variable is used to make sure that all structures
within a block are terminated when the corresponding block's ENDBLK is
encountered.  _#BMLVL is used in macros ##PEDC, ##PPDC, BLOCK, ENDBLK,
LEAVE and PLIST.
:dt._#BNAME(20)
:dd.Character array _#BNAME holds the names of all of the currently
nested blocks.  The block nesting level is used as an index.  _#BNAME is
used in macros ##PEDC, ##PPDC, ##SPSTD, BLOCK, ENDBLK, LEAVE and PLIST.
:dt._#BNDX(20)
:dd.Arithmetic array _#BNDX is used to hold the index number used to
generate tags for a block.  _#BNDX is set by the BLOCK macro using the
current _#MDX.  _#BNDX is used in macros ##EESTD, ##EPSTD, ##IESTD,
##PEDC, ##PPDC, ##PPPLI, ##PPOS, BLOCK, ENDBLK, LEAVE and PLIST.
:dt._#BPLn(20)
:dd.Character array _#BPL1 and _#BPL2 are used to hold the first and
second parameters from the PL keyword for each currently nested block.
_#BPL1 and _#BPL2 are used in macros BLOCK and PLIST.
:dt._#BSVn(20)
:dd.Character arrays _#BSV1, _#BSV2, and _#BSV3 are used to hold the
first, second and third parameters from the SAVE keyword for each
currently nested block.  These variables are used in macros ##EPSTD,
##IPSTD, ##PPDC, ##RST, ##SPSTD and LEAVE.
:dt._#BTYPE(20)
:dd.Character array _BTYPE holds the block type for all of the currently
nested blocks.  _BTYPE is indexed by the block nesting level.  The way
blocks are currently structured in the macros, the first block type is
program, subroutine or errexit and all others are inline.  This may
change in the future.  _#BTYPE is used in macros ##IPSTD, ##PEDC,
##PPDC, BLOCK, ENDBLK, EXI, LEAVE and PLIST.
:dt._#CCAS(20)
:dd.Logical array _#CCAS is used to keep an indicate as to whether a
CASE macro has been encountered within one of the currently nested case
blocks.  The case block nesting level is used as an index.  This
indicator is used during code generation to determine if a branch to the
end of the case block is need before the code for a new case starts.
_#CCAS is used in macros CASE, CASEBLK and ENDCASE.
:dt._#CLVL
:dd.Arithmetic variable _#CLVL is used to hold the current case block
nesting level.  _#CLVL is used in macros CASE, CASEBLK, ENDCASE and
LEAVE.
:dt._#CMAXC(20)
:dd.Arithmetic array _#CMAXC is use to keep up with the maximum case
number for the corresponding case block.  The case block nesting level
is used as an index into this array.  _#CMAXC is used in macros CASE,
CASEBLK and ENDCASE.
:dt._#CMLVL(20)
:dd.Arithmetic array _#CMLVL is used to hold the structural nesting
level for each currently nested case block.  The case block nesting
level is used as an index.  The variable is used to make sure that all
structures within a case block are terminated when the corresponding
case's ENDCASE is encountered.  _#CMLVL is used in macros CASE,
CASEBLK, ENDCASE and LEAVE.
:dt._#CMULT(20)
:dd.Arithmetic array _#CMULT is used to hold the MULT= keyword for all
of the currently nested case blocks.  The case block nesting level is
used as an index.  _#CMULT is used by macro CASE, CASEBLK and ENDCASE.
:dt._#CNAME(20)
:dd.Character array _#CNAME is used to hold the names of all of the
currently nested case blocks.  The case block nesting level is used as
an index.  _#CNAME is used by macros CASE, CASEBLK, ENDCASE and LEAVE.
:dt._#CNDX(20)
:dd.Arithmetic array _#cNDX is used to hold the index number used to
generate tags for a case block.  _#CNDX is set by the CASEBLK macro
using the current _#MDX.  _#CNDX is used in macros CASE, CASEBLK,
ENDCASE and LEAVE.
:dt._#COTH(20)
:dd.Logical array _#COTH is used to determine if a CASE OTHER has
been encountered within a case block.  The case block nesting level
is used as an index.  _#COTH is used in macros CASE, CASEBLK and
ENDCASE.
:dt._#CSF(500)
:dd.Arithmetic array _#CSF along with corresponding elements in array
_#CST are used to hold a representation of which subroutines call which
subroutines.  _#CSF is set to the block number of the
:q.from:eq.subroutine while _#CST is set to the block number of the
:q.to:eq. subroutine.  This block number is the same number that is used
as an index into the array _#BNAME.  Note that the program block name is
always in the first entry of _#BNAME.  Each paired entry in _#CSF and
_#CST is unique.  Array _#CSFF and variable _#CSFT#N are very closely
related to these arrays.  _#CSF and $#CST are used in macros ##ORGS,
##WESTD and CALLSUB.
:dt._#CSFF(99)
:dd.Arithmetic array _#CSFF is used to hold the index of the first entry
in the _#CSF array for a given subroutine.  The same index used to
access a given subroutines name in array _#BNAME is used to access
_#CSFF.  _#CSFF is used in macros ##ORGS, ##WESTD and CALLSUB.
:dt._#CSFT#N
:dd.Arithmetic variable _#CSFT#N is used to hold the index for the next
unused entry in array _#CSF.  _#CSFT#N is used in macros ##ORGS,
##WESTD, BLOCK and CALLSUB.
:dt._#CSSD
:dd.Logical array _#CSSD indicates whether an adcon for an associated
subroutine has already been placed in the PSD when the LONG program
option is in effect.  The same index used to access a given subroutines
name in array _#BNAME is used to access _#CSSD.  _#CSSD(99) is used in
macro CALLSUB.
:dt._#CST(500)
:dd.Refer to array _#CSF for information on array _#CST.
:dt._#CSVST
:dd.Logical array _#CSVST is used by macro ##ORGS to determine which
programs it has already :q.visited:eq..  _#CSVST is only used by macro
##ORGS.
:dt._#CTAGS(2020)
:dd.Arithmetic array _#CTAGS is used as a 20 by 101 matrix where the
first index is the nesting level of a case block and the second index is
a case number.  The entries in this matrix contain the _#MNDX value
assigned to the corresponding CASE macro.  These entries are used in
formulating the names of tags associated with a give case.  _#CTAGS is
used in macros CASE, CASEBLK and ENDCASE.
:dt._DC#RET
:dd.Logical variable _#DC#RET is used to communicate between ##PPDC
and ##PEDC whether the user has requested the #RETURN option.
_#DC#RET is used in macros ##PEDC and ##PPDC.
:dt._#DCRTN
:dd.Logical variable _#DC#RTN is used to communicate between ##PPDC
and ##PEDC whether the user has requested the #RTN option.
_#DC#RTN is used in macros ##PEDC and ##PPDC.
:dt._#DCNTSK
:dd.Character variable _#DCNTSK is used to contain the DC next-task
code for use when ##PEDC generates :q.#RETURN NXTTASK=:eq..
_#DCNTSK is used in macros ##PEDC and ##PPDC.
:dt._#DCPWAR
:dd._#DCPWAR is a character variable that is used to contain the
name of the first PWA register specified, so that ##PEDC can use
it to issue a #FREESTG for the PWA.
_#DCPWAR is used in macros ##PEDC and ##PPDC.
:dt._#DCRENT
:dd.Logical variable _#DCRENT is set by requesting the RENT option
via ##PPDC.
_#DCRENT is used in macros ##PEDC and ##PPDC.
:dt._#DCRINT
:dd.Character variable _#DCRINT is used to contain the DC resource
timeout interval value
if specified to ##PPDC. ##PEDC uses _#DCRINT in generating
:q.#RETURN RESINT=:eq.
if the #RETURN option was requested.
_#DCRINT is used in macros ##PEDC and ##PPDC.
:dt._#DCRPGM
:dd.Character variable _#DCRPGM is used to contain the
name of the resource interval timeout handler program
if specified to ##PPDC. ##PEDC uses _#DCRPGM in generating
:q.#RETURN RESPGM=:eq.
if the #RETURN option was requested.
_#DCRINT is used in macros ##PEDC and ##PPDC.
_#DCRPGM is used in macros ##PEDC and ##PPDC.
:dt._#DCRTYP
:dd.Character variable _#DCRTYP is used to contain the
#RETURN TYPE= value of NORMAL, ABORT or CONTINUE
as specified to ##PPDC, and is used by ##PEDC to generate
:q.#RETURN TYPE=:eq. if the #RETURN option was requested.
_#DCRTYP is used in macros ##PEDC and ##PPDC.
:dt._#DCSYS
:dd.Logical variable _#DCSYS is set if the SYSTEM option was requested
by ##PPDC. _#DCSYS determines whether the #START/#RTN options or the
#RETURN option and the #RETURN-related options TYPE, RESINT, RESPGM
and NXTTASK are valid, and also causes ENV= to be set to SYS or USER
on the internally-generated #MOPT macro.
_#DCSYS is used in macros ##PEDC and ##PPDC.
:dt._#DCGSTK
:dd.Logical variable _#DCGSTK is set by ##PPDC if the GETSTK option
was requested. _#DCGSTK determines whether, if the PWA and SYSTEM
options were also specified, ##PPDC generates a #GETSTG or #GETSTK
to acquire its Program Work Area. Also, ##PEDC uses _#DCGSTK to
determine whether, if PWA and SYSTEM were specified,
if a #FREESTG is necessary or not.
:dt._#DLVL
:dd.Arithmetic variable _#DLVL is used to hold the current loop
nesting level.
_#DLVL is used in macros ENDLOOP, LEAVE and LOOP.
:dt._#DMLVL(20)
:dd.Arithmetic array _#DMLVL is used to hold the structural
nesting level for each currently nested loop.  The loop
nesting level is used as an index.  The variable is used to
make sure that all structures within a loop are terminated
when the corresponding loop's ENDLOOP is encountered.
_#DMLVL is used by macros ENDLOOP, LEAVE and LOOP.
:dt._#DNAME(20)
:dd.Character array _#DNAME holds the names of all of the
currently nested loops.  The loop nesting level is used as
an index.  _#DNAME is used in macros ENDLOOP, LEAVE and
LOOP.
:dt._#DNDX(20)
:dd.Arithmetic array _#DNDX is used to hold the index number used to
generate tags for a loop.  _#DNDX is set by the LOOP macro using the
current _#MDX.  The loop nesting level is used as an index.  _#DNDX is
used in macros ENDLOOP, LEAVE and LOOP.
:dt._#DTYPE(20)
:dd.Character array _#DTYPE is used to hold a loop type for the
currently nested loops.  The loop nesting level is used as an index.
_#DTYPE is used in macros ENDLOOP and LOOP.
:dt._#EEMAC
:dd.Character variable _#EEMAC is used to hold the default errexit
epilog macro name.  It is set by a :q.##$xxx:eq. macro.  _#EEMAC is
used in macros ##$DC, ##$PLI, ##$STD and ENDBLK.
:dt._#EPMAC
:dd.Character variable _#EPMAC is used to hold the default errexit
prolog macro name.  It is set by a :q.##$xxx:eq. macro.  _#EPMAC
is used in macros ##$DC, ##$PLI, ##$STD and BLOCK.
:dt._#IELSE(20)
:dd.Logical array _#IELSE is used to determine if an ELSE statement has
been encountered within an IF structure.  _#IELSE is used in macros
ELSE, ELSEIF, ENDIF and IF.
:dt._#IEMAC
:dd.Character variable _#IEMAC is used to hold the default inline block
epilog macro name.  It is set by a :q.##$xxx:eq. macro.  _#IEMAC
is used in macros ##$DC, ##$PLI, ##$STD and ENDBLK.
:dt._#ILVL
:dd.Arithmetic variable _#ILVL is used to hold the current if nesting
level.  _#ILVL is used in macros ELSE, ELSEIF, ENDIF, IF and LEAVE.
:dt._#IMLVL(20)
:dd.Arithmetic array _#IMLVL is used to hold the structural nesting
level for each currently nested if statement.  The if nesting level
is used as an index.  The variable is used to make sure that all
structures within an if are terminated when the corresponding if's
ENDIF is encountered.  _#IMLVL is used by macros ELSE, ELSEIF,
ENDIF, IF and LEAVE.
:dt._#INAME(20)
:dd.Character array _#INAME holds the names of all of the currently
nested if statements.  The if nesting level is used as an index.
_#INAME is used in macros ELSE, ELSEIF, ENDIF, IF and LEAVE.
:dt._#INDX(20)
:dd.Arithmetic array _#INDX is used to hold the index number used to
generate tags for a if statement.  _#INDX is set by the IF macro using
the current _#MDX.  The IF nesting level is used as an index.  _#INDX is
used in macros ELSE, ELSEIF, ENDIF, IF and LEAVE.
:dt._#INDX2(20)
:dd.Arithmetic array _#INDX is used to hold a second index number used
to generate tags in an if structure.  _#INDX2 is set by the IF and
ELSEIF macros using the current _#MDX.  The IF nesting level is used as
an index.  _#INDX2 is used in macros ELSE, ELSEIF, ENDIF and IF.
:dt._#IPMAC
:dd.Character variable _#IEMAC is used to hold the default inline block
prolog macro name.  It is set by a :q.##$xxx:eq. macro.  _#IEMAC
is used in macros ##$DC, ##$PLI, ##$STD and BLOCK.
:dt._#MCVREG
:dd.Arithmetic variable _#MCVREG is used by macro ##CVREG to pass back
the number of the register it converts.  _#MCVREG is used by macros
##CVREG, ##LDBS, ##MREG, ##PPDC, ##RST, LCBA and STRSA.
:dt._#MLVL
:dd.Arithmetic variable _#MLVL is used to hold the current structural
nesting level for all structures.  It is incremented by the start macro
for each structure and decremented by the end macro for each structure.
This variable is checked to insure the each end structure is paired up
with the correct type of begin structure.  _#MLVL is used by macros
##PEDC, ##PPDC, BLOCK, CASE, CASEBLK, ELSE, ELSEIF, ENDBLK, ENDCASE,
ENDIF, ENDLOOP, ENDPSD, ENDSSD, EXI, IF, LEAVE, LOOP, PSD and SSD.
:dt._#MNDX
:dd.Arithmetic variable _#MNDX is used to generate a unique number that
can be used by each macro to generate unique tags.  The macros first add
one to this variable and then use that number as a suffix to tags.
_#MNDX is used by variables ##COND, ##EPSTD, ##IPSTD, ##LDBS, ##PEDC,
##PEOS, ##PPDC, ##PPPLI, ##PPOS, ##SPSTD, BLOCK, CALLX, CASE, CASEBLK,
ELSEIF, ENDBLK, ENDCASE, ENDLOOP, ERREXIT, IF, LCBA, LEAVE, LOOP and
PLIST.
:dt._#PB#C
:dd.Arithmetic variable _#PB#C is set to the number of the current
.rc 2 on
program block.  _#PB#C is used by macros ##PEOS,
##PPDC, ##PPPLI, ##PPOS,
.rc 2 off
##SPSTD, ##WESTD, ##WPPLI, ##WPOS, BLOCK, EXI, PLIST, PSD and SSD.
:dt._#PBAMOD
:dd.Character variable _#PBAMOD holds the amode of the current program
block.  _#PBAMODE is used by macros ##EESTD, ##PEDC, ##PPDC, ##PPPLI,
##PPOS and PLIST.
:dt._#PBBR14
:dd.Logical variable _#PBBR14 is used to indicate whether the BR14
option is specified on a program block.  _#PBBR14 is used by macros
#PEOS and #PPOS.
:dt._#PBDERR
:dd.Character variable _#PBDERR is used to hold the _DYNERR keyword
value specified on a program block.  _#PBDERR is used by macros ##PPOS
and ##SPSTD.
:dt._#PBDSWA
:dd.Logical variable _#PBDSWA is set by a program block prolog macro to
indicate to the PWA epilog macro that a define storage for the PWA is
needed.  _#PBDSWA is used by macros ##PPDC, ##PPPLI, ##PPOS and
##WESTD.
:dt._#PBDYN
:dd.Logical variable _#PBDYN is set by a program block prolog macro to
indicate whether the DYN option is in effect.  _#PBDYN is used by macros
##PEOS, ##PPPLI, ##PPOS, ##SESTD, ##SPSTD, ##UESTD, ##UPSTD, ##WESTD,
##WPOS and PLIST.
:dt._#PBDYNS
:dd.Character variable _#PBDYNS is set by a program block prolog macro
to the value of the DYNSIZE keyword.  _#PBDYNS is used by macros
##PPOS, ##SPSTD and ##WESTD.
:dt._#PBENC
:dd.Logical variable _#PBENC is set by the BLOCK macro to indicate that
a program block has been encountered.  _#PBENC is only used by the BLOCK
macro.
.rc 2 on
:dt._#PBERRA
:dd.Logical variable _#PBERRA is set by the BLOCK macro to indicate that
the ERRADDR option is in effect.
_#PBESV is used by the ##PPOS and ERREXIT
macros.
:dt._#PBESV
:dd.Logical variable _#PBESV is set by the BLOCK macro to indicate that
the ESV option is in effect.  _#PBESV is used by the ##PEOS and ##PPOS
macros.
:dt._#PBESVP
:dd.Arithmetic variable _#PBESVP is used to hold the parameter number
that contains the ESV pointer.  _#PBESVP
is used by the ##PPOS macro.
:dt._#PBFNCD
:dd.Logical variable _#PBFNCD is set by the BLOCK macro to indicate that
the FNCODE option is in effect.  _#PBFNCD is only used by the BLOCK
macro.
:dt._#PBFNCP
:dd.Arithmetic variable _#PBFNCD is used to hold the parameter number
that contains the function code .  _#PBFNCD is used by the ##PPOS
macro.
.rc 2 off
:dt._#PBGTMN
:dd.Logical variable _#PBGTMN is set by a program block prolog macro to
indicate that a GETMAIN was done.  This tells the corresponding epilog
macro to do a FREEMAIN.  _#PBGTMN is used in macros ##PEOS and ##PPOS.
:dt._#PBLOCR
:dd.Logical variable _#PBLOCR is set by a program block prolog macro to
indicate if the LOCTR option is in effect.  _#PBLOCR is used in macros
##PEDC, ##PPDC, ##PPPLI, ##PPOS, ##SESTD, ##SPSTD, ##WESTD and EXI.
:dt._#PBLONG
:dd.Logical variable _#PBLONG is set by a program block prolog macro to
indicate if the LONG option is in effect.  _#PBLONG is used by macros
##PPDC, ##PPPLI, ##PPOS, ##SPSTD and CALLSUB.
:dt._#PBMAIN
:dd.Logical variable _#PBMAIN is set by a program block prolog macro to
indicate if the MAIN option is in effect.  _#PBMAIN is used by macros
##PEOS, ##PPPLI and ##PPOS.
:dt._#PBNAME
:dd.Character variable _#PBNAME is used to hold the program block CSECT
name.  Macros can use the variable in the name field of a CSECT
statement to get back in the CSECT of the program.  _#PBNAME is used by
macros ##PEDC, ##PPDC, ##PPPLI, ##SESTD, ##UESTD, ##WESTD, BLOCK, ENDPSD
and ENDSSD.
:dt._#PBNDX
:dd.Arithmetic variable _#PBNDX holds the value of _#MNDX used by the
current program block.  _#PBNDX is used by macros ##EESTD, ##EPSTD,
##PEDC, ##PEPLI, ##PEOS, ##PPDC, ##PPOS, ##SPSTD, BLOCK and ERREXIT.
:dt._#PBNRSV
:dd.Logical variable _#PBNRSV is set by the standard program block
prolog macro to inform the corresponding epilog macro that a
non-reentrant save area is in use.  _#PBNRSV is used by macros ##PEOS
and ##PPOS.
:dt._#PBOPTS
:dd.Logical variable _#PBOPTS is used to indicate whether the OPTSTOR
option is in effect.  _#PBOPTS is used by macros ##PPOS and ##SPSTD.
:dt._#PBPLMX
:dd.Arithmetic variable _#PBPLMX is used to keep up with the maximum
number of words that needs to be generated by the PWA macro to hold
parameter lists.  _#PBPLMX is used by macros ##PPPLI, ##PPOS, ##WPPLI,
##WPOS, BLOCK and PLIST.
:dt._#PBPPWA
:dd.Logical variable _#PBPPWA is used to keep track of whether a partial
PWA has been encountered.  _#PBPPWA is used by macros ##WESTD, ##WPPLI
and ##WPOS.
:dt._#PBPWA
:dd.Logical variable _#PBPWA is used to indicate whether the program
block has an associated PWA.  _#PBPWA is used by macros ##PEDC, ##PEOS,
##PPDC, ##PPPLI, ##PPOS, ##SESTD, ##SPSTD, ##WPPLI, ##WPOS and PLIST.
.rc 2 on
:dt._#PBPWAP
:dd.Arithmetic variable _#PBPWAP is used to hold the parameter number
that contains the PWA anchor for reusable PWAs.
_#PBPWAP is used by macros ##PEOS and ##POOS.
.rc 2 off
:dt._#PBRMOD
:dd.Character variable _#PBRMOD holds the RMODE of the program block's
CSECT.  _#PBRMOD is used in macros ##PPDC, ##PPPLI and ##PPOS.
.rc 2 on
:dt._#PBRPWA
:dd.Logical variable _#PBRPWA is used to indicate whether the REUSPWA
option is in effect.  _#PBRPWA is used by macros ##PEOS and ##PPOS.
.rc 2 off
:dt._#PBRTN0
:dd.Logical variable _#PBRTN0 is used to indicate whether the RTNR0
option is in effect.  _#PBRTN0 is used by macros ##EESTD, ##PEOS
and ##PEDC.
:dt._#PBRTN1
:dd.Logical variable _#PBRTN1 is used to indicate whether the RTNR1
option is in effect.  _#PBRTN1 is used by macros ##EESTD, ##PEOS
and ##PEDC.
:dt._#PBSAVE
:dd.Logical variable _#PBSAVE is used to indicate whether the SAVE
option is in effect for the program block.  _#PBSAVE is used by macros
##PEOS and ##PPOS.
:dt._#PBSDID
:dd.Character variable _#PBSDID is used to hold the ID to be used in
generating PSD fields.  _#PBSDID is use in macros ##PPDC, ##PPPLI and
##PPOS.
:dt._#PBSMWA
:dd.Character variable _#PBSMWA is used to hold the tag that refers to
the program block's Structured Macro Work Area.  _#PBSMWA is used by
macros ##EESTD, ##IESTD, ##PEDC, ##PPDC, ##PPPLI, ##PPOS, ##RWREG,
##SWREG, LEAVE and PLIST.
:dt._#PBVL
:dd.Logical variable _#PBVL is used to indicate whether the VL option is
in effect for the program block.  _#PBVL is used by macros ##PPDC,
##PPPLI, ##PPOS and PLIST.
:dt._#PBWAID
:dd.Character variable _#PBWAID is used to hold the ID to be used in
generating PWA fields.  _#PBWAID is use in macros ##PPDC, ##PPPLI,
##PPOS, ##WESTD, ##WPPLI and ##WPOS.
:dt._#PBWAMX
:dd.Arithmetic variable _#PBWAMX holds the number of words in the
SMWA that is automatically generated by the PWA macro.
_#PBMAMX is use by macros ##PPDC, ##PPPLI, ##PPOS, ##WPPLI, ##WPOS and
BLOCK.
:dt._#PBXA
:dd.Logical variable _#PBXA indicates whether the XA option is in
effect.  It is used by macros ##EESTD, ##EPSTD, ##IESTD, ##IPSTD,
##LDBS, ##PEDC, ##PPDC, ##PPPLI, ##PPOS, ##SESTD, ##SPSTD, CALLSUB,
CALLX, LEAVE and PLIST.
:dt._#PB370
:dd.Logical variable _#PB370 indicates whether the 370 option is in
effect.  It is used by macros ##EESTD, ##EPSTD, ##IESTD, ##IPSTD,
##LDBS, ##PEDC, ##PPDC, ##PPPLI, ##PPOS, ##SESTD, ##SPSTD, CALLSUB,
CALLX, LEAVE and PLIST.
:dt._#PEMAC
:dd.Character variable _#PEMAC holds the default program block epilog
macro name.  _#PEMAC is used in macros ##$DC, ##$PLI, ##$STD and ENDBLK.
:dt._#PPMAC
:dd.Character variable _#PPMAC holds the default program block prolog
macro name.  _#PPMAC is used in macros ##$DC, ##$PLI, ##$STD and BLOCK.
:dt._#REG(16)
:dd.Logical array _#REG is used by macro ##MREG to keep up with which
registers are used.  _#REG is only used by macro ##MREG.
:dt._#SB#C
:dd.Arithmetic variable _#SB#C is used to hold the current subroutine
block number.  _#SB#C is used by macros ##PEDC, ##SESTD, ##SPSTD,
##UESTD, ##UPSTD, BLOCK, CALLSUB, ENDPSD, ENDSSD, PLIST, SSD and STRSA.
:dt._#SB#CPB
:dd.Arithmetic variable _#SB#CPB is used to hold the
:q.subroutine block number:eq. of the current program block.
_#SB#CPB is used by macros ##WESTD, BLOCK and CALLSUB.
:dt._#SB#D
:dd.Arithmetic variable _#SB#D is passed back from ##DEFSUB to
indicate the number of the block just defined.  _#SB#D is used by
macros ##DEFSUB, ##SPSTD, BLOCK and CALLSUB.
:dt._#SB#M
:dd.Arithmetic variable _#SB#M holds the maximum subroutine block
number.  _#SB#M is used by macros ##DEFSUB and ##WESTD.
:dt._#SBCSTM
:dd.Logical variable _#SBCSTM indicates whether the CUSTOM subroutine
option is in effect.  _#SBCSTM is used by macros ##EPSTD, ##PEDC,
##SESTD, ##SPSTD, ##SUBOPT and ENDBLK.
:dt._#SBLDBS
:dd.Logical variable _#SBLDBS indicates whether the LOADBASE subroutine
option is in effect.  _#SBLDBS is used by macros ##EPSTD, ##SPSTD,
##SUBOPT and SSD.
:dt._#SBNM(99)
:dd.Character array _#SBNM is used to hold all of the subroutine names
encountered in the assembly.  The subroutine number as returned by
##DEFSUB is used as an index.  _#SBNM is used by macros ##DEFSUB,
##ORGS, ##SPSTD and ##WESTD.
:dt._#SBORGC
:dd.Arithmetic variable _#SBORGC is an ORG counter.  _#SBORGC is only
used by macro ##ORGS.
:dt._#SBPLMX
:dd.Arithmetic variable _#SBPLMX is used to keep up with the maximum
number of words that needs to be generated by the SWA macro to hold
parameter lists.  _#SBPLMX is used by ##PEDC, ##SESTD, ##SPSTD, ##UPSTD,
BLOCK, ENDBLK and PLIST.
:dt._#SBPSWA
:dd.Logical variable _#SBPSWA is used to keep track of whether a partial
SWA has been encountered.  _#SBPSWA is used by ##UESTD and ##UPSTD.
:dt._#SBREC(99)
:dd.Arithmetic array _#SBREC is used to hold the value from the RECUR
keyword for subroutines.  The subroutine number returned from ##DEFSUB
is used as an index.  _#SBREC is used by macros ##ORGS and ##SPSTD.
:dt._#SBSU
:dd.Logical variable _#SBSU indicates whether the SAVEUSING subroutine
option is in effect.  _#SBSU is used in macros ##EPSTD, ##PEDC, ##PPPLI,
##PPOS, ##SESTD, ##SPSTD and ##SUBOPT.
:dt._#SBSWA
:dd.Logical variable _#SBSWA indicates whether the SWA subroutine option
is in effect.  _#SBSWA is used in macros ##EPSTD, ##PEDC, ##SESTD,
##SPSTD, ##SUBOPT, ##UPSTD, ##WPPLI, ##WPOS, PLIST and STRSA.
:dt._#SBUSWA
:dd.Logical variable _#SBUSWA indicates whether the USERSWA subroutine
option is in effect.  _#SBSWA is used in macros ##EPSTD, ##PEDC,
##PPOS, ##SESTD, ##SPSTD and ##SUBOPT.
:dt._#SBWAMX
:dd.Arithmetic variable _#SBWAMX is used to indicate how many
fullwords are to be reserved in the SWA for use by the Structured
Macros.  This ability is currently not being used.  _#SBWAMX is
used by macro ##UPSTD.
:dt._#SDCSTM
:dd.Logical variable _#SDCSTM is used to hold the default state of the
CUSTOM subroutine option.  _#SDCSTM is used by macros ##SUBOPT.
:dt._#SDLDBS
:dd.Logical variable _#SDLDBS is used to hold the default state of the
LOADBASE subroutine option.  _#SDLDBS is used by macros ##SUBOPT.
:dt._#SDLVL
:dd.Arithmetic variable _#SDLVL is used to hold the structural level of
static data.  _#SDLVL is used in macros ENDPSD, PSD and SSD.
:dt._#SDPSD
:dd.Logical variable _#SDPSD indicate whether a PSD macro has been
encountered and an ENDPSD has not.  _#SDPSD is used in macros ENDPSD and
PSD.
:dt._#SDSSD
:dd.Logical variable _#SDSSD indicate whether a SSD macro has been
encountered and an ENDSSD has not.  _#SDSSD is used in macros ENDSSD and
SSD.
:dt._#SDSU
:dd.Logical variable _#SDSU is used to hold the default state of the
SAVEUSING subroutine option.  _#SDSU is used by macros ##SUBOPT.
:dt._#SDSVLC
:dd.Character variable _#SDSVLC is used to save the location counter.
_#SDSVLC is used by macros ENDPSD, ENDSSD, PSD and SSD.
:dt._#SDSWA
:dd.Logical variable _#SDSWA is used to hold the default state of the
SWA subroutine option.  _#SDSWA is used by macros ##SUBOPT.
:dt._#SDUSWA
:dd.Logical variable _#SDUSWA is used to hold the default state of the
USERSWA subroutine option.  _#SDUSWA is used by macros ##SUBOPT.
:dt._#SEMAC
:dd.Character variable _#SEMAC holds the default subroutine block epilog
macro name.  _#SEMAC is used in macros ##$DC, ##$PLI, ##$STD and ENDBLK.
:dt._#SPMAC
:dd.Character variable _#SPMAC holds the default subroutine block prolog
macro name.  _#SPMAC is used in macros ##$DC, ##$PLI, ##$STD and BLOCK.
:dt._#UEMAC
:dd.Character variable _#UEMAC holds the default Subroutine Work Area
epilog macro name.  _#UEMAC is used in macros ##$DC, ##$PLI, ##$STD and
ENDSWA.
:dt._#UPMAC
:dd.Character variable _#UPMAC holds the default Subroutine Work Area
prolog macro name.  _#UPMAC is used in macros ##$DC, ##$PLI, ##$STD and
SWA.
:dt._#WEMAC
:dd.Character variable _#WEMAC holds the default Program Work Area
epilog macro name.  _#WEMAC is used in macros ##$DC, ##$PLI, ##$STD and
ENDPWA.
:dt._#WPMAC
:dd.Character variable _#WPMAC holds the default Program Work Area
prolog macro name.  _#WPMAC is used in macros ##$DC, ##$PLI, ##$STD and
PWA.
:dt._#XAWARN
:dd.Logical variable _#XAWARN is used to indicate whether the warning
message has been issued indicating that the XA option was not specified.
This flag is used so that this message can be issued only once.
_#XAWARN is used by macros ##IPSTD, ##PPDC, ##SPSTD and PLIST.
:edl.
.*
:h1.Labels
:p.
This chapter contains all of the labels used by the Structured
Macros.  Each label begin with a :q.#:eq. and contains
a symbolic variable.  The symbolic variable listed may not
be the actual variable used to create the label name, but it is
representative of the variable used in the macros.
:dl tsize=25.
:dt._#PBWAID
:dd.The label contained in
_#PBWAID is set to the name of the PWA DSECT and is used as
the prefix of some PWA field names.  _#PBWAID is used in macros
##PPDC, ##PPPLI, ##PPOS, ##WESTD, ##WPDC, ##WPPLI, and ##WPPLI.
:dt._#PBWAID.PLLEN
:dd.Label _#PBWAID.PLLEN is used by macros ##PPDC, ##PPPLI, ##PPOS and
##WESTD as a tag that have the length of the PWA as its value.
:dt._#PBWID.X...
:dd.Labels _#PBWAID.XALWS, _#PBWAID.XANAB, _#PBWAID.XANAB,
_#PBWAID.XBCH, _#PBWAID.XBCH, _#PBWAID.XCEC, _#PBWAID.XCEC,
_#PBWAID.XF1A, _#PBWAID.XF1B and _#PBWAID.XS1 are used by macros
##PPPLI and ##WPPLI to refer to fields in a PLI style DSA.
:dt.#BE_#BNDX(_#BLVL)
:dd.Label #BE_#BNDX(_#BLVL) is generated by macro ENDBLK.  Macro LEAVE
generates a branch to this tag for leaving a block.
:dt.#BF_#PBNDX
:dd.Label #BF_#PBNDX is used internal to macro ##PEOS for branching
around freemain code if dynamic storage was used for the current PWA.
.rc 2 on
:dt.#BH_#PBNDX
:dd.Label #BH_#PBNDX is used by macro ##PPOS for generating code
to support reusable PWAs.
.rc 2 off
:dt.#BI_#PBNDX
:dd.Label #BI_#PBNDX is used by macro ##PPOS to branch around some
subroutine prolog code when using option DYN and OPTSTORAGE.
:dt.#BJ_#MNDX
:dd.Label #BJ_#MNDX is used by macros ##PPDC, ##PPPLI and ##PPOS
as the tag for a fullword that contains the address of the PWA.
:dt.#BK_#PBNDX
:dd.Label #BK_#PBNDX is generated by macro ##PPOS as the tag for
the dynamic storage subroutine prolog that is generated as a result
of options DYN and OPTSTORAGE.  Macro ##SPSTD generates a BAL
instruction to this tag.
.rc 2 on
:dt.#BL_#PBNDX
:dd.Label #BL_#PBNDX is used by macro ##PEOS to hop around code to
free the reusable PWA.
:dt.#BM_#PBNDX
:dd.Label #BM_#PBNDX is used by macro ##PPOS as the tag for
the DC for the start function.
:dt.#BN_#PBNDX
:dd.Label #BN_#PBNDX is used by macro ##PPOS for generating code
to support reusable PWAs.
.rc 2 off
:dt.#BO_#MNDX
:dd.Label #BO_#MNDX is used by macro ##PPOS as the tag for the default
dynamic error routine if option DYN is in effect and keyword DYNERR
is not specified.  The default error routine is a :q.DC H'0':eq. which
causes an abend S0C1.  If this default label is used, it is assigned
to variable _#PBDERR which is used in macros ##PPOS and ##SPSTD.
:dt.#BP_#MNDX
:dd.Label #BP_#MNDX is used by macros ##PPDC, ##PPPLI and ##PPOS
in the generation of
code to branch around constants generated at the top
of a CSECT.
:dt.#BQ_#PBNDX
:dd.Label #BQ_#PBNDX is generated by macros ##PEDC, ##PEPLI, and
##PEOS and is the tag that is branched to by ##EESTD to leave
the program.
:dt.#BS_#MNDX
:dd.Label #BS_#MNDX is used internally by macro ##PPPLI to skip the
call to the PLI storage overflow routine.
:dt.#BU_#MNDX
:dd.Label #BU_#MNDX is used internally by macro ##PPOS and is used
as the tag for a fullword displacement of the first NAB from the
start of the PWA.
:dt.#BV_#BNDX(_#BLVL)
:dd.Label #BV_#BNDX(_#BLVL) is used internally by macros ##EESTD and
##IESTD for branching around amode switching code when not running
under XA.
:dt.#BW_#BNDX(_#BLVL)
:dd.Label #BW_#BNDX(_#BLVL) is used internally by macros ##EESTD and
##IESTD as a tag for a fullword used for switching to amode 31.
:dt.#BW_#MNDX
:dd.Label #BW_#MNDX is used by macro ##PPOS as the tag for a fullword
containing the length of the PWA.
:dt.#BX_#PBNDX
:dd.Label #BX_#PBNDX is used as the name of the single possible
unnamed error exit by macros ##EPSTD and ERREXIT.
:dt.#BY_#MNDX
:dd.Label #BY_#MNDX is used by macros ##EPSTD, ##IPSTD, ##PPDC, ##PPPLI,
##PPOS and ##SPSTD for branching around amode setting code when not
running on XA.
:dt.#BZ_#MNDX
:dd.Label #BZ_#MNDX is used internally by macros ##EPSTD, ##IPSTD and
##SPSTD as a tag for a fullword used for switching to amode 31.
:dt.#CC_#MNDX
:dd.Label #CC_n is used as the tag for the start of a given case
and is refered to by the displacement table generated by the
ENDCASE macro.
:dt.#CE_#CNDX(_#CLVL)
:dd.Label #CE_#CNDX(_#CLVL) is the tag used for the end of a case
block and is used by macros ENDCASE and LEAVE.
:dt.#CM_#CNDX(_#CLVL)
:dd.Label #CM_#CNDX(_#CLVL) is the tag of a halfword that contains
the size of the case displacement table.  Code for this label is
generated by macros CASEBLK and ENDCASE.
:dt.#CO_#CNDX(_#CLVL)
:dd.Label #CO_#CNDX(_#CLVL) is the tag for case :q.other:eq..  Code
with this label is generated by macros CASE, CASEBLK, and ENDCASE.
:dt.#CP_#MNDX
:dd.Label #CP_#MNDX is used by macro CALLX for branching around a
:q.BASR:eq. instruction when generating bimodal instructions.
:dt.#CS_#CNDX(_#CLVL)
:dd.Label #CS_#CNDX(_#CLVL) is used by macro CASEBLK as the tag on
the :q. B *(reg):eq. instruction it generates.
:dt.#CT_#CNDX(_#CLVL)
:dd.Label #CT_#CNDX(_#CLVL) is the label for the start of the case
displacement table.  This label is used in macros CASEBLK and ENDCASE.
:dt.#CX_#MNDX
:dd.Label #CX_#MNDX is used internally to the CALLX macro for branching
around amode switching code when not running under XA.
:dt.#DB_#DNDX(_#DLVL)
:dd.Label #DB_#DNDX(_#DLVL) is the loop begin tag.  It is used by macros
LOOP and ENDLOOP.
:dt.#DE_#DNDX(_#DLVL)
:dd.Label #DE_#DNDX(_#DLVL) is the loop end tag.  It is used by macros
LEAVE, LOOP and ENDLOOP.
:dt.#DS_#MNDX
:dd.Label #DS_#MNDX is used by the LOOP macro as the :q.success tag:eq.
for WHILE loops.
:dt.#EX#_#MNDX
:dd.Label #EX#_#MNDX is used as the tag of the executed instruction by
the EXI macro.
:dt.#EXEND#_#MNDX
:dd.Label #EXEND#_#MNDX is used by the EXI macro for branching around
:q.executed:eq. instruction when the LOCTR option is not in effect.
:dt.#ID_#PB#C
:dd.Label #ID_#PB#C is used by the ##PPDC macro for branching around
the #GETSTG storage id.
:dt.#IE_#INDX(_#ILVL)
:dd.Label #IE_#INDX(_#ILVL) is the :q.end of if:eq. tag.  if is used
by macros ENDIF, ELSE, ELSEIF and LEAVE.
:dt.#IF_#INDX2(_#ILVL)
:dd.Label #IF_#INDX2(_#ILVL) is the fail tag used on ##COND in the IF
and ELSEIF macros.  This tag is used in ELSE, ELSEIF, ENDIF and IF.
:dt.#IF_#MNDX
:dd.Label #IF_#MNDX is used internally to ##COND as an :q.if fail:eq.
tag.
:dt.#IS_#MNDX
:dd.Label #IS_#MNDX is used internally to ##COND, ELSEIF, and IF
as an :q.if success:eq. tag.
:dt.#LE_#MNDX
:dd.Label #LE_#MNDX is used internally by macro LCBA for various
branching.
:dt.#LF_#MNDX
:dd.Label #LF_#MNDX is used internally by macro LCBA for various
branching and by ERREXIT and LEAVE as a :q.leave fail:eq. tag.
:dt.#LL_#MNDX
:dd.Label #LL_#MNDX is used internally by macro LCBA for various
branching.
:dt.#LQ_#MNDX
:dd.Label #LQ_#MNDX is used internally by ##LDBS.
:dt.#LR_#MNDX
:dd.Label #LR_#MNDX is used internally by ##LDBS.
:dt.#LS_#MNDX
:dd.Label #LS_#MNDX is used internally by ##LDBS and used as a :q.leave
success:eq. tag in LEAVE.
:dt.#LV_#MNDX
:dd.Label #LV_#MNDX is used internally by LEAVE to branch around
amode switching code when not running under XA.
:dt.#LW_#MNDX
:dd.Label #LW_#MNDX is used internally by the LEAVE macro when
switching to amode 31.
:dt.#PBDL_#PB#C
:dd.Label #PBDL_#PB#C is the LOCTR name of the programs static data
and for a subroutines static data if subroutine option LOADBASE is
not in effect.
:dt.#PBE_#PB#C
:dd.Label #PBE_N is the tag for EOS-64 in the PWA when the DYN option
is in effect.  This tag is used in macros ##WPDC, ##WPOS and ##PPOS.
:dt.#PBG_#PB#C
:dd.Label #PBG_#PB#C is used internally to macro ##PPOS for skipping
a getmain if options NOMAIN and DYN are in effect and there is already
room in dynamic storage for the new PWA.
:dt.#PBJ_#PB#C
:dd.Label #PBJ_#PB#C is the tag used on the DC instruction for a
non-reentrant PWA.  Macros ##PPOS, #PPDC and ##WPOS use this tag.
:dt.#PBK_#PB#C
:dd.Label #PBK_#PB#C is used internally to macro ##PPOS for skipping
a getmain if options NOMAIN and DYN are in effect and there is already
room in dynamic storage for the new PWA.
.rc 2 on
:dt.#PBL_#PB#C
:dd.Label #PBK_#PB#C is used by ##PEOS and ##PPOS to reference the ESV.
.rc 2 off
:dt.#PBN_#PB#C
:dd.Label #PBN_N is the tag of the NAB in the PWA.  This label is used
by macros ##PPOS, ##WPDC and ##WPOS.
:dt.#PBP_#PB#C
:dd.Label #PBP_#PB#C is the tag used for parameter storage in the
PWA.  This tag is used by macros PLIST, ##WPDC, ##WPPLI and ##WPOS.
:dt.#PBR_#PB#C
:dd.Label #PBR_N is the tag for a reserved field in the PWA.  This
tag is generated by macros ##WPDC and ##WPOS.
:dt.#PBS_#PB#C
:dd.Label #PBS_#PB#C is used by macro #WPOS as the tag for the
standard OS save area in the PWA.
:dt.#PBU_#PB#C
:dd.Label #PBU_N is the :q.start of user storage:eq. tag in the PWA.
This label is used by macros ##WPDC, ##WPPLI and ##WPOS.
:dt.#PBW_#PB#C
:dd.Label #PBW_#PB#C is the tag used for the default SMWA in the PWA.
It is assigned to variable _#PBSMWA.  This label is used by macros
##PPDC, ##PPPLI, ##PPOS, ##EESTD, ##IESTD, ##RWREG, ##SWREG ##WPDC,
##WPPLI and ##WPOS.
:dt.#PBX_#PB#C
:dd.Label #PBX_#PB#C is the tag in the pwa that is at the start of
the extra storage reserved for SWAs and PWAs.  This label is used by
macros ##PPOS and ##WESTD.
:dt.#SB$_#SBORGC
:dd.Label #SB$_#SBORGC is used internally to the ##ORGS macro.
:dt.#SBAD_#SB#D
:dd.Label #SBAD_#SB#D is used internally to the CALLSUB macro as a
tag for a DC instruction for the subroutine block being called.  This
tag is only used if the LONG option is in effect.
:dt.#SBD_#SB#C
:dd.Label #SBD_#SB#C is the DSECT name of SWAs.  It is used by macros
##SPSTD, ##UESTD and ##UPSTD.
:dt.#SBDL_#SB#C
:dd.Label #SBDL_#SB#C is the LOCTR name for a subroutine block's SSD.
This tag is used by macros ##SPSTD and SSD.
:dt.#SBIL_#SB#C
:dd.Label #SBIL_#SB#C is the LOCTR name for a subroutine block's
instructions.
This tag is used by macro ##SPSTD.
:dt.#SBL_#CST(_CTR)
:dd.Label #SBL_#CST(_CTR) is the :q.length of SWA:eq. tag.  It is used
by macros ##ORGS, ##SESTD and ##UESTD.
:dt.#SBLT_#SB#C
:dd.Label #SBLT_#SB#C is tag for a halfword containing the length of
a subroutine's SWA.  This label is used internally to ##SPSTD.
:dt.#SBN_#SB#C
:dd.Label #SBN_#SB#C is the tag for the NAB in the SWA with the DYN
option is in effect.  This label is used in ##UPSTD.
:dt.#SBP_#SB#C
:dd.Label #SBP_#SB#C is the tag for the parameter storage in an SWA.
This label is used in macros ##SESTD, ##UPSTD and PLIST.
:dt.#SBS_#SB#C
:dd.Label #SBS_#SB#C is the tag for the save area storage in an SWA.
This label is used in macros ##SESTD and ##UPSTD.  It is assigned to
variable _#BSV3(_#BLVL) which is used in macros ##SPSTD, ##EPSTD,
##IPSTD, ##SPSTD and ##RST.
:dt.#SBU_#SB#C
:dd.Label #SBU_#SB#C is the tag for the start of user storage in an SWA.
This label is used in macro ##UPSTD.
:dt.#SBW_#SB#C
:dd.Label #SBW_#SB#C is the tag for the Structured Macro Work Area
in an SWA.
This label is used in macro ##UPSTD.
:dt.#ST_#PB#C
:dd.Label #ST_#PB#C is used internally by ##PPDC as the tag for the
DC for the EP name.
:dt.#U_#PB#C
:dd.Label #U_#PB#C is the default id for PSDs.  This label is assigned
to _#PBSDID in macros ##PPPLI, ##PPOS and ##PPDC.
:dt.#W_#PB#C
:dd.Label #W_#PB#C is the default id for PWAs.  This label is assigned
to _#PBWAID in macros ##PPPLI, ##PPOS and ##PPDC.
:edl.
:egdoc
