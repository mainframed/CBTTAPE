.*
.* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
.* <<<<<<<<<<<<<<<<<<<<<<<<<<  NOTE   >>>>>>>>>>>>>>>>>>>>>>>>>>>
.*  This file is part of the PRINTDOC system.  If this file is
.*   moved or if its formatting characteristics change, the PRINTDOC
.*   systems will have to be updated.
.*
.*  If this file is updated, please change ACS.PRINTDOC.INDEX(MANUALS)
.*   to reflect the new revision date.  This allows users to know
.*   when they should print a new copy.
.* <<<<<<<<<<<<<<<<<<<<<<<<<<  NOTE   >>>>>>>>>>>>>>>>>>>>>>>>>>>
.* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
.*
.*  This is the Structured Macros Reference and User's Guide
.*  coded to use GML tags.  It should be invoked with options
.*  PASS(2) SYSVAR('D YES T CENTER H YES') SEC(32) PAGES(150)
.*
.df data type('data1' 8) codepage t1d0base
.ll 6.5i
:gdoc.
:frontm.
.ti ! 05
.dh 0 spbf 4.5i
.rc 1
.rc 2
.rc 3 |
.rc 4 |
.se @bodyhead1 = 'Chapter'
.df figfont list (xmpfont)
:titlep.
:title stitle='Clemson Structured Macros'.
Clemson University Computer Center
:title.Structured Programming Macros
:title.User's Guide And Reference
:date.
:author.Last revision: November 6, 1989
:etitlep.
:preface.
:p.
The Structured Programming Macros is a programming tool developed
at Clemson University for internal use by the staff of the
Computer Center.  However, after they were written, the decision
was made to release them to the public since they are very useful
to anyone who is programming in System/370 Assembler language.
:p.
The macros were designed to make the programmer's job easier by
handling the often confusing but necessary code needed in any
program.  Things like program linkage, subroutines, parameter
lists, loops, and conditional sections are handled
easily by use of the macros.  This allows the user to concentrate
on the program instead of the details, and also helps make
the code much easier to read and debug.
:p.
The Structured Programming Macros provide a means by which the
Assembler programmer can use logical programming structures
normally available only in high-level languages.
Structures like DO WHILE, DO UNTIL, IF-THEN-ELSE, and CASE
are available directly through the macros.  More complex structures,
such as SEARCH, may be coded simply through a combination of the
macros.
In addition, some useful macros that perform common
functions (such as flipping bits and clearing storage) are provided
as a convenience.
:p.
The macros are packaged in a macro library which may be concatenated
to SYSLIB for Assembler H.
(There are catalogued procedures available at Clemson that concatenate
this macro library to SYS1.MACLIB.)
:p.
Among other things, the Structured Programming Macros may be used
to handle addressing mode switching and linkage
under MVS/XA.
Should you wish to use the 31-bit addressing features, you should be
familiar with the concepts described in
:cit.MVS/XA SPL: 31-Bit Addressing,:ecit. GC28-1158.
Using the macros, it becomes very simple
to change and restore addressing modes, both inline
and for subroutine calls.
:p.
Since the Structured Programming Macros provide all of the needed
control structures, the user should not have to code any branch
instructions (and associated statement labels) in a program.
This makes the source code much neater and easier to read.
:p.
This document will serve as an introduction to the Structured
Programming Macros, and assumes that the reader is already familiar
with the uses of common structured programming techniques.
While the Structured Programming Macros
serve as a programming aid,
they are not meant to be a substitute for
a working knowledge of System/370 Assembler language and System/370
architectures.
When using these macros, the reader should not arbitrarily assume that
what the macros generate is some kind of :q.magic code:eq.. It's not: in
fact, the code generated by the macros
tends to look a lot like what a competent programmer would
write. When using the macros, look at the macro expansions
occasionally. Knowing a little about how the macros work will help
you to make better use of them.
.rc 3 on
:note.
In order to achieve the desired level of functionality within the
Structured Macros, they have been written in such a way as to
require the use of the Level H Assembler.  Although some of the
macros might not currently require Assembler H,
no guarantee is made that any of the features described here will
work with the Level F Assembler.
Use of these macros with anything other than Assembler H
is :hp2.not:ehp3. recommended.
.rc 3 off
.*
:toc.
.*
:h1.Summary of Amendments
.*
.rc 4 on
:h3.Update November 6, 1989
:ol.
:li.Two new macros (DEFUCOND and ##COND) are provided to allow the
programmer to define new conditional tests that can be inserted into
any conditional expression.
:li.The COPYERROR and COUNT suboptions have been added to the
PARMS option.
:eol.
.rc 4 off
.*
.rc 3 on
:h3.Update April 19, 1989
:ol.
:li.The Structured Macros now require the Level H Assembler for
correct operation.  Do not use them with the Level F Assembler.
:li.Changes were made in the PLIST macro to allow more flexible
specification of parameters.  Most notably, indirect referencing
is now supported.
:li.Symbols have been provided to allow the program to locate the start
of major structures such as the PWA, PSD, SWA, and SSD.
:li.An automatic prefixing facility has been added to allow
programmers to name storage tags in a subroutine without having to
worry about what tags in other subroutines have been named.
:li.A SMLIST macro has been added to control the output of the
Structured Macros listing program.  Currently, the only option is
to provide for automatic conversion of the program to uppercase
before assembly.
:eol.
.rc 3 off
.*
.rc 2 on
:h3.Update October 1, 1987
:ol.
:li.Support was added for writing Service Processors with the
Structured Macros.  Service Processors are programs that are called
repeatedly to process one of a variety of functions, and that
retain their workarea between calls.  To learn more about Service
Processors, see :cit.Clemson University Computer Center Service
Processor User's Guide and Reference:ecit..  The Service Processor
support includes new options and keywords on the BLOCK macro and
a new super option.
:li.The SMCTRL macro was added to set internal flags that affect
the operation of the Structured Macros.  Currently, this is only
used for Service Processor support.
:eol.
.rc 2 off
.*
.rc 1 on
:h3.Update March 11, 1987
:ol.
:li.An ENVIRON keyword was added to the BLOCK TYPE=PROGRAM macro to
allow for the different linkage conventions in different program
environments.  Currently, the supported environments are:  OS, DC, and
PLI.
:li.Support was added for PWAs in non-reentrant programs.
:li.R0 and R1 keywords were added to the ENDBLK macro for programs
to enable a program to pass back registers 0 and 1 to its caller.
:li.The error messages issued by internal macros have been moved to
their own section.
:li.Minor editorial changes have been made.
:eol.
.rc 1 off
.*
.*
:body.
.* don't print running footing on next page.
.rf odd sup
:h0.I. Structured Macros User's Guide
.* can print running footing after this page.
.rf odd res
.* set up new even page footing (change short title variable)
.se @stitle 'Structured Macros Users's Guide
.*
.*
:h1.Nesting Levels
:p.
There are 4 major building blocks that
can be nested. These are the
:hp1.block,:ehp1. the :hp1.if/elseif,:ehp1. the
:hp1.loop,:ehp1. and the :hp1.case block.:ehp1.
The Structured Programming Macros support nesting to a depth of
20 for each structure. The structures may be intermixed: for example,
a BLOCK can contain IF structures, and a LOOP may contain a CASE block,
which may in turn contain more LOOPs.
Levels of nesting are opened and closed by the use of complementary
macros, like BLOCK/ENDBLK, LOOP/ENDLOOP, IF/ENDIF and CASEBLK/ENDCASE.
:p.
The user of these macros might find it helpful to start
indenting source statements as nesting levels vary.
Since no labels are required in the program code, the user can
code statement starting in column two and indent while
still leaving room for comments.
Consider the
following examples: in the first, operands are coded
in fixed columns, as is common practice.
.tp 15 24 42
:fig id=unind place=inline.
.sk
       BLOCK   NAME=TEST
       IF  (condition1),THEN
       LOOP      WHILE,(condition2)
       LEAVE     (condition3,),IF=*
       ENDLOOP  WHILE
       ENDIF
       ENDBLK
:figcap.Unindented Assembler Source
:efig.
:p.
In :figref refid=indent., however,
the same instructions are indented based
on the nesting level of each.
While the second example may look unusual to the hardened Assembler
programmer, it's easier to follow
the nesting levels, and thus the logical structure, by sight alone.
:fig id=indent place=inline.
.sk
 BLOCK NAME=TEST
  IF   (condition1),THEN
   LOOP      WHILE,(condition2)
    LEAVE    LOOP=*,(condition3)
   ENDLOOP   WHILE
  ENDIF
 ENDBLK
:figcap.Indented Assembler Source
:efig.
:p.
Since the macros require proper nesting of structures to generate
tags for branches and the like,
correct pairing of complementary macros is important.
The structured assembler cataloged procedures in use at Clemson
include a pre-step that
examines your source for nesting problems and lists your program
with a nesting-level report. This pre-processor is described
later in :hdref refid=asmproc..
:p.
The nesting of structures provides a very specific path for the
program to follow.  This can be interrupted where necessary by
the use of the LEAVE macro.  This macro allows the program to
leave a structure prematurely either conditionally or unconditionally.
By default, the LEAVE macro will leave the innermost structure
of the type specified.  However, it can be used to exit a structure
from any depth.  If you are leaving from a deeply nested
series of inline blocks, restoring registers and AMODEs properly
is a complicated task.  The LEAVE macro can handle this task
nicely.  The programmer should not have to worry about this.  You
can leave an arbitrarily complex structure and LEAVE will handle
the details.
.*
.*
:h1 id=condch.Conditional Statements
:p.
Using the Structured Macros, conditional expressions are defined in
terms of the instruction(s) that will make the comparison.
Conditional expressions are mandatory on some macros (IF, ELSEIF, and
some forms of LOOP) and optional on others (LEAVE and ERREXIT).
The syntax of a conditional expression on each of these macros is
identical.
:p.
.rc 1 on
.*
:h2.Standard Conditions
The format of a single condition can be any of the following:
:sl.
:li.(:hp2.CLC,:ehp2.operand1,condition,operand2)
:li.(:hp2.CR,:ehp2.operand1,condition,operand2)
:li.(:hp2.C,:ehp2.operand1,condition,operand2)
:li.(:hp2.CP,:ehp2.operand1,condition,operand2)
:li.(:hp2.CH,:ehp2.operand1,condition,operand2)
:li.(:hp2.CLR,:ehp2.operand1,condition,operand2)
:li.(:hp2.CL,:ehp2.operand1,condition,operand2)
:li.(:hp2.CLI,:ehp2.operand1,condition,operand2)
:li.(:hp2.CLCL,:ehp2.operand1,condition,operand2)
:li.(:hp2.TM,:ehp2.operand1,condition,operand2)
:li.(:hp2.CLM,:ehp2.operand1,mask,condition,operand2)
:li.(:hp2.TREG,:ehp2.operand1,condition)
:li.(:hp2.TBIT,:ehp2.&lbt.operand1,&rbt.operand2&lbt.:hp2.
.ct ,ON|OFF|ANY|MIXED:ehp2.&rbt.)  default ON
:li.(:hp2.#TEST,:ehp2.operand1&lbt.:hp2.
.ct ,ON|OFF|ANY:ehp2.&rbt.)  default ON
:esl.
where:
:ul.
:li.The first parameter is the machine or macro instruction
that is to be used to perform the comparison.
CLC, CR, C, CP, CH, CLR, CL, CLI, CLCL,
TM and CLM are all S/370 machine instructions.  TREG is a
macro that tests a register for zero, positive,
or negative.  TBIT is another macro that is used
for testing bits.  As signified, the only conditions that
can be specified for TBIT are ON, OFF, ANY and MIXED.  #TEST
supports the IDMS/DC #TEST macro.  #TEST supports the
conditions ON, OFF and ANY.
:li.:hp2.operand1:ehp2. is the first operand of the
specified instruction or macro.  Any valid form of the operand
for the comparison being performed is allowed.
:li.:hp2.operand2:ehp2. is the second operand of the
specified instruction or macro.  Any valid form of the operand
for the comparison being performed is allowed.
:li.:hp2.mask:ehp2. is the mask operand of the CLM instruction and
can be any form that is valid in the instruction itself.
:li.:hp2.condition:ehp2. may be coded as one of the following:
:dl compact tsize=8.
:dt.EQ
:dd.Equal
:dt.E
:dd.Equal
:dt.NE
:dd.Not equal
:dt.LT
:dd.Less than
:dt.GT
:dd.Greater than
:dt.LE
:dd.Less than or equal
:dt.GE
:dd.Greater than or equal
:dt.Z
:dd.Zero
:dt.NZ
:dd.Not zero
:dt.M
:dd.Minus or mixed
:dt.NM
:dd.Not minus or not mixed
:dt.P
:dd.Positive
:dt.NP
:dd.Not positive
:dt.O
:dd.Ones or overflow
:dt.NO
:dd.Not ones or not overflow
:dt.ON
:dd.All flags on
:dt.OFF
:dd.All flags off
:dt.ANY
:dd.Any flags on
:dt.MIXED
:dd.Mixed
:dt.CCnn
:dd.Condition code, CC1 through CC14
:edl.
:eul.
.rc 1 off
:p.
The conditional expression coded will expand using the comparison
instruction(s) provided and appropriate conditional branches.
For example, instead of the expression :q.IF&rbl.A=B,THEN:eq., one
would code :q.IF&rbl.(CLC,A,EQ,B),THEN:eq., which would generate a
:q.CLC&rbl.A,B:eq. and a BNE instruction to the appropriate ELSE,
ELSEIF or ENDIF macro.
.*
:h2.Coding Conditional Expressions
:p.
Boolean expressions and nested conditions are available
when using the Structured Macros.
Using the Boolean operators AND, OR and NOT, conditional expressions
may be nested and/or concatenated on a single macro.
Under Assembler H (IEV90), the depth of nesting is
limited to 255 characters within the outer parentheses.
Multiple conditions are evaluated
following the normal precedence rules with
expressions in parentheses taking precedence and
NOT being
done before AND, and AND being done before OR.
:p.
For example, one may code:
:xmp.
 IF   NOT,(CLC,A,EQ,B)
:exmp.
:pc.
which is equivalent to:
:xmp.
 IF   (CLC,A,NE,B)
:exmp.
:pc.
Multiple conditions may be coded together, as in this example:
:xmp.
 IF   ((CLC,A,EQ,B),OR,(CLC,C,EQ,D),AND,(CLC,E,EQ,D))
:exmp.
:pc.
which is equivalent to:
:xmp.
 IF   ((CLC,A,EQ,B),OR,((CLC,C,EQ,D),AND,(CLC,E,EQ,D)))
:exmp.
:p.
The rules of Boolean algebra are followed by the Structured Macros.
For example, the Boolean expression :q.NOT (x AND y):eq. is equivalent
to :q.NOT (x) OR NOT (y):eq..  Similarly, the IF statement
:xmp.
 IF   (NOT,((CLC,A,EQ,B),AND,(CLC,C,EQ,D))),THEN
:exmp.
:pc.
and the IF statement
:xmp.
 IF   (NOT,(CLC,A,EQ,B),OR,NOT,(CLC,C,EQ,D)),THEN
:exmp.
:pc.
and the IF statement
:xmp.
 IF   ((CLC,A,NE,B),OR,(CLC,C,NE,D)),THEN
:exmp.
:pc.
will all generate identical code.
:p.
Although parentheses and the precedence rules affect the meaning
of the expressions, the comparisons are always generated in the
order that they are coded.  There are two cases where this is
significant.  Consider the following example:
:xmp.
 IF   ((CLI,A,EQ,C'Y'),AND,(C,R3,EQ,B))
:exmp.
:p.
The second comparison will only be done if the first one succeeds.
This can be very useful if you only have addressability for the
second comparison if the first one is true.
Another case where coding order is important can be illustrated by
the following two IF statements:
:xmp.
 IF   ((Z),OR,(CLC,A,EQ,B))
 IF   ((CLC,A,EQ,B),OR,(Z))
:exmp.
:p.
In the first example, the zero conditional test refers to the
condition code that exists from a previous instruction before
the IF is encountered.  In the second example, the zero conditional
test refers to the result of the compare that precedes it.
Because it is sometimes difficult to determine which comparisons
will actually be performed in a particular multiple condition IF
statement, it is usually a good practice to put a condition test
with no comparison only at the beginning of an IF.
.rc 4 on
.*
:h2 id=ucond.User-Defined Conditions
:p.
Although the conditions supported by the Structured Macros cover most
of the standard types of comparisions, there are occasionally
instances where they are not sufficient.  To avoid unpleasant
side-effects, we have decided that our conditions will never modify
storage locations or registers.  Therefore, we do not have conditions
for things like TRT (Translate and Test) which modifies registers
one and two.  In addition, many programs will have tests involving more
than a simple compare that they do repeatedly.  It would be helpful to
be able to code these tests within a Structured Macros conditional
expression.
:p.
Fortunately, there is a very easy way to get around both of these
situations.  The Structured Macros provide a facility to allow
you to define your own conditional tests that can be placed within
any conditional expression.  User-defined conditions are identified
by a percent sign (%) and may have any number of operands following
them.  For example, suppose you wanted to be able to code something
like this:
:xmp.
IF    ((TREG,R4,NZ),AND,(%TRT,0(8,R4),NE,PSDVALID))
&invellip.
ENDIF
:exmp.
Before you can use the %TRT condition, you need to do two things.
First, you must define the condition name itself and identify the
macro that will process it.  This is done with the DEFUCOND macro.
Second, you must code the macro itself.  For our %TRT example, these
two steps would look like this:
:xmp.
   DEFUCOND NAME=TRT,MACRO=TRT_UCOND   | Define the condition name.
          MACRO
 &NAME    TRT_UCOND &EXPR,&S=,&F=,&L=  | Our TRT macro.
          AIF (N'&EXPR NE 4).ERR0001   | Were we called wrong?
 &NAME    TRT   &EXPR(2),&EXPR(4)      | Do TRT instruction.
          ##COND &EXPR(3),             | Test result and branch       +
                S=&S,F=&F,L=&L         |   as appropriate.
          MEXIT
 .ERR0001 MNOTE 8,'Too many parameters in %TRT expr'
          MEND
:exmp.
:p.
There are several important requirements that all user-condition macros
must meet.  Once those are understood, writing these macros becomes
quite simple.  First, the &NAME label is required and must identify
the first executable statement generated by your macro.  The Structured
Macros will generate a unique label for &NAME so that they can branch
to your condition when it is part of a compound conditional expression.
:p.
Next come the parameters that your macro will be called with.  The
first parameter is positional and will be the entire condition that
invoked this macro including the condition name.  For our previous
example, this would be :hp2.(%TRT,0(8,R4),NE,PSDVALID):ehp2..
The individual fields within the condition can be extracted by
subscripting the expression.  For example &amp.EXPR(3) for the
third item in the expression (NE).
The next three keyword parameters (S=, F=, and L=) define the tag
names that the macro should branch to on success and failure and
indicate the logic of this conditional (P for positive and N for
negative).
:p.
The Logic keyword (L=) needs a little explaining.  Positive logic
says that the macro should branch to the success tag if the condition
is true and fall through to the following code if the condition is
false.  Positive logic is used for things like ERREXIT and LEAVE.
Negative logic says to branch to the failure tag if the condition is
false and fall through if it is true.  This is used in standard
IF statements.
:p.
The ##COND macro is an internal macro that should only be used
within other macros.  Its purpose is to evaluate a conditional
expression and properly process the S=, F=, and L= keywords.
The expression passed to ##COND can be any valid conditional
expression including boolean expressions, nested conditions, and
other user-defined conditions.  Most user-defined condition macros
will include a ##COND macro to perform the actual test and process
the S=, F=, and L= keywords.  This greatly simplifies the macro.
:p.
For another example, what if you wanted to be able to check the
status of ISPF like this?
:xmp.
IF    (%ISPFACT)
&invellip.
ELSE
&invellip.
ENDIF
:exmp.
:p.
You would need to define the %ISPFACT condition like this:
:xmp.
  DEFUCOND NAME=ISPFACT,MACRO=ISPF_UCOND
          MACRO
 &NAME    ISPF_UCOND &EXPR,&S=,&F=,&L=
          AIF (N'&EXPR NE 1).ERR0001   | Check number of parms.
 &NAME    LINK  EP=ISPQRY              | Call ISPF status routine.
          ##COND (TREG,R15,Z),         | Check condition code.        +
                S=&S,F=&F,L=&L
          MEXIT
 .ERR0001 MNOTE 8,'Too many parameters in %ISPFACT expr'
          MEND
:exmp.
:p.
There are several user-defined conditions provided in a copy member
called SMPUCOND.  These should provide good examples of how to code
user conditions and may also be useful in programs.  You can include
them in your programs by placing a :hp2.COPY SMPUCOND:ehp2. statement
at the start of your program.
:note.
Be careful when using conditions that modifiy registers or storage
locations.  When these conditions are used as part of a compound
conditional expression, they can effect the other conditions in the
expression.  Be careful of your register usage in these cases and
remember that although some conditions in an expression may be
skipped because of the logic, conditions are always evaluated in the
order they are coded.
.rc 4 off
.*
.*
:h1.Blocks
:p.
There are 4 types of :hp1.blocks:ehp1. available
with the Structured Programming Macros. These are:
the :hp1.program:ehp1. block, the :hp1.inline:ehp1.
block, the :hp1.subroutine,:ehp1.
block, and the :hp1.errexit:ehp1. block.
Each type of block may be named, and this name may be used as a
reference on the associated ENDBLK macro, and also on the LEAVE
macro.
.*
:h2.The Program Block
:p.
The :hp1.program block:ehp1.
encloses the main body of a program and corresponds roughly to a
:q.mainline:eq.. Program blocks may not be enclosed by any other
structure:  e.g. they must be used at :hp1.block level zero.:ehp1.  The
program block should be the first block coded for a program.
.rc 1 on
Options and the ENVIRON keyword
on the BLOCK TYPE=PROGRAM macro determine the type of linkage,
.rc 1 off
initialization and other program attributes to be established. The
associated ENDBLK macro will reverse the linkage when it is executed.
A LEAVE macro which either names the program block or is coded
as :q.BLOCK=*:eq. at the
program block's block level will cause a branch to the ENDBLK macro,
thus terminating the program.
:p.
.rc 1 on
When writing a program that uses both 24-bit and 31-bit
.rc 1 off
addressing under MVS/XA, a Structured Macro Workarea
(SMWA) must be provided for the macros' use.  This is automatically
provided by the SWA and PWA services, or can be specified with a
keyword on the block macro.  The SMWA is a
doubleword of storage which is used to save work registers and
addressing modes, thus allowing an AMODE change without
disturbing the registers.
.*
:h2.The Inline Block
:p.
Inline blocks are generally used to set
off a procedure from neighboring
code.
Inline blocks provide a structure which may
be exited with the LEAVE BLOCK=* macro.
Inline blocks are placed within the other types of blocks and
may be nested within themselves.
If desired, registers may be saved and restored when entering and
leaving an inline block by use of the SAVE operand on the BLOCK macro.
:p.
.rc 1 on
When writing programs that will be run on MVS/XA, the inline
.rc 1 off
block may be used to switch addressing modes :q.on the fly:eq.. For
example, the program section in :figref refid=amode. is
running AMODE 31
and RMODE 24, but needs to issue a PUT, which requires AMODE 24.
These instructions will generate the correct sequence of
instructions to save the current addressing mode,
switch to AMODE 24,
and then restore the saved addressing mode at the end of the block.
:fig id=amode place=inline.
.sk
-- AMODE 31 code --
   :
BLOCK  AMODE=24
 PUT   SYSPRINT,RECORD
ENDBLK
   :
-- AMODE 31 code --
:figcap.Switching AMODE
:efig.
.*
:h2.The Subroutine Block
:p.
Subroutine blocks contain code that is reached via the CALLSUB macro.
Subroutines coded in this manner must be at block level zero
(i.e. cannot be contained within any other block).
Subroutine blocks should be coded after the program block to which
they belong.
Subroutine blocks are meant for :q.internal:eq. subroutines, not for
a called program that follows standard OS linkage conventions.
:p.
A subroutine block is called by CALLSUB using
:hp1.:q.BAL   R14,routine:eq.:ehp1. or an equivalent sequence.
By using the SAVE operand, the subroutine may have some or
all of its registers saved and restored, although its use is optional.
If Subroutine Work Areas (SWAs) are used, registers R0-R14 are
automatically saved in the SWA and restored when the subroutine
is exited.  In this case, the SAVE operand is invalid.
The user can also specify that the USING environment should be
saved and restored around the subroutine.  This prevents any
USINGs within the subroutine from affecting the rest of the
program.
Furthermore, a subroutine may request that its AMODE be switched and
restored on entry and exit by using the AMODE operand.
:p.
The CALLSUB macro uses register 14 to link to the subroutine, but
all other registers will have the same value on entry to the subroutine
that they had in the calling program.  However, if Dynamic Storage
.rc 1 on
Management or the LONG program option is
.rc 1 off
used, register 15 will also be destroyed by the CALLSUB linkage.
See :hdref refid=large. for more information on dynamic storage.
.*
:h2.The ErrExit Block
:p.
The errexit block is executed whenever an ERREXIT macro that
refers to it is executed. Like the subroutine block, the errexit
block must be coded at block level zero.  Errexit blocks should
be coded with the subroutine blocks after the program block to
which they belong.  The ENDBLK macro associated with an errexit
block generates a branch to the program block's ENDBLK expansion,
and also allows you to specify a return code with
which the program will terminate.  This return code overrides any
return code that may appear on the program block's ENDBLK macro.
.*
.*
.rc 1 on
:h1.Program Environments
:p.
There are several types of environments for which the
Structured Macros contain explicit support.  These
environments are selected with the ENVIRON keyword of the
program block macro.  The environments are: the
:q.OS:eq. program environment which supports standard
OS linkages; the :q.DC:eq. program environment which
supports Cullinet IDMS/DC linkage; and the :q.PLI:eq.
environment which supports the execution time environment of
release 5 of the OS Optimizing Compiler.  Other types of
environments can be accommodated by coding your own
linkage.
.rc 1 off
:p.
The options and keywords on the program and subroutine block
macros allow you to control virtually all phases
of the program linkage as well as the Structured Macros
options.  All of the major initialization and termination
functions are represented by their individual keywords.
However, there are certain program types that occur
frequently.  To cut down on the number of options that need
to be coded to represent these program types, the super
options can be used.  They contain the correct combination
of options for the most common program types.
.rc 1 on
The super options for each environment are discussed in their
corresponding sections below.
.rc 1 off
.*
.rc 1 on
:h2.DC Environment
:p.
Specifying ENVIRON=DC generates support for programs to execute in the
IDMS/DC run-time environment.
This support is relatively new and perhaps does not support all
of the functions required by its users: however, a basic set of
options and super options should satisfy most IDMS/DC programmers'
needs.
:h3.System Mode And User Mode
:p.
IDMS/DC programs generally are called in either :hp1.system mode:ehp1.
or :hp1.user mode:ehp1.. As a rule, user-mode programs are called by a
#LINK or #XCTL and use #RETURN to return to their caller, while
system-mode programs are called by #CALL and return with #RTN, and also
have a slightly different set of register and linkage conventions.
IDMS/DC applications whose program names are invoked by a task code or
called by #LINK or #XCTL are almost always user-mode programs, while DC
numbered exits and map edit routines are usually system-mode programs.
Both types are supported by ENVIRON=DC.
.*
:h3.Reentrancy Under IDMS/DC
:p.
Since any IDMS/DC program may be in use
by several users at any given time, reentrancy in application programs
and DC system routines is much more valuable than under the standard
MVS environment. The savings in execution time gained by avoiding a
#GETSTG/#FREESTG and management of a reentrant program workarea are
usually far outweighed by the program pool savings and avoidance of
program management overhead gained by making a program truly
reentrant. System-mode programs, where speed and efficiency are prime
considerations, can take advantage of IDMS/DC's #GETSTK service for
:q.fast storage:eq. if their PWA storage requirements are small.
.*
:h3.*NORENT
:p.
A non-reentrant user-mode program in IDMS/DC terms means basically
the same as a non-reentrant program under the OS environment: IDMS/DC
does not allow users to share a copy of the program, but loads a new
copy each time a new user requests one. As a result, the program can
contain its variables within its CSECT without having to acquire
storage from IDMS/DC for them.
.*
:h3.*NORENTSYS
:p.
This super option defines a non-reentrant system mode program for
IDMS/DC. This option is provided for consistency: however, it is
recommended that any system mode program be assembled as reentrant,
using either the *RENTSYS or *PWASYS super option.
.*
:h3.*RENT
:p.
Reentrancy in an IDMS/DC user mode program allows IDMS/DC to share
a single copy of the program among multiple users, and also allows
the program to be loaded into the IDMS/DC reentrant program pool.
The *RENT super option causes reentrant linkage to occur, but does
not acquire any variable storage for the program.
.*
:h3.*RENTSYS
:p.
The *RENTSYS super option causes reentrant linkage to occur for an
IDMS/DC system mode routine. Like *RENT, *RENTSYS does not acquire
any variable storage for the program: thus, if local variable storage
is not needed, the overhead of #GETSTG/#FREESTG can be avoided.
.*
:h3.*PWA
:p.
The *PWA super option causes a #GETSTG and #FREESTG to be included
in the linkage and delinkage for the program, thus allowing reentrancy
and providing storage for variables. This process (except for actually
acquiring the storage) is basically the same as described
in the *PWA section under
:hdref refid=ospwa..
.*
:h3.*PWASYS
:p.
This is generally the option that system-mode programs would use if
they have any need for variable storage. If a small PWA (10 fullwords
or less) is all that's needed, the option GETSTK can be coded among
the program block's OPTIONS: this causes #GETSTK to be used to acquire
variable storage from the task's TCE stack, which is much faster than
calling #GETSTG and #FREESTG.
.*
:h2.OS Environment
:p.The OS environment is the default environment and supports
standard OS linkage.  By specifying different options, you can
have the Structured Macros do as little or as much of the
linkage as desired.  For most situations, there are super options
that will pick the correct set of options for you.
:h3.*NORENT
.rc 1 off
:p.
If a program is non-reentrant, the system will load a fresh copy
of it every time the program is invoked.  Because of this, the
program is allowed to modify itself.  Data and work areas can
be stored in the load module itself.  Most user programs can be
non-reentrant.  The *NORENT super option will automatically define a
save area in the program ID section and perform non-reentrant linkage.
.*
:h3.*RENT
:p.
Since reentrant programs are not reloaded every time they are
invoked, they are not allowed to modify any fields within themselves.
Any data that might be modified must be copied into working storage
that has been GETMAINed, and modified there.  This preserves the
integrity of the load module for other users.  The *RENT
super option provides the reentrant linkage and will automatically
GETMAIN storage for a save area.  No provision is made for a
Program Work Area (PWA).  Any storage (other than the save area)
needed by the program must be acquired by the user.
Because of this, the *RENT super option is not very useful for
new programs.  *PWA provides much better support for reentrant
programs. (see below)  *RENT was included to provide support for
those programs that already acquire their own storage or that for some
reason could not use the storage provided by *PWA.
.*
:h3 id=ospwa.*PWA
:p.
*PWA provides all the functions of *RENT, plus it will automatically
GETMAIN and FREE a Program Work Area (PWA) for the user.  The best
way to illustrate this is with an example:
:xmp.
 BLOCK NAME=MAINPROG,TYPE=PROGRAM,OPTIONS=(*PWA)
        :
        :
 ENDBLK BLOCK=MAINPROG
 PSD
        :
   Static Data
        :
 ENDPSD
 PWA
        :
   Work Area
        :
 ENDPWA
:exmp.
:p.
In the example above, the static data (constants and other data
that are not modified by the program) is placed at the end of the
.rc 3 on
program in an area called the PSD (Program Static Data)
.rc 3 off
and is included in the load module.
The PWA and ENDPWA macros define a DSECT for a block of storage
that will be acquired for the user by the BLOCK macro and freed
at the end of the program.  Space for the save area is automatically
reserved in the PWA, so the user does not need to worry about this.
The user simply needs to define any work area fields that the
program needs
between the PWA and ENDPWA macros.  After this storage is acquired
by the BLOCK macro, it is cleared for the user and addressability
is set up using register 13.  This super option makes writing
reentrant programs almost as easy as writing non-reentrant ones.
The bothersome details of computing storage requirements,
GETMAINing storage, keeping up with addresses, and FREEMAINing the
acquired storage are handled by the Structured Programming Macros.
:p.
The *PWA option and the PWA macro also provide a variety of
other features that are described in more detail in
:hdref refid=pwaswa..
.*
:h3.*MAIN
:p.
The *MAIN super option provides all of the features of *PWA and
adds the options DYN and MAIN.  This allows SWAs to be allocated
from dynamic storage instead of being statically defined in the
PWA.  See
:hdref refid=large. for more information on dynamic storage.
The *MAIN super option should be used on the program
block for any main program that uses dynamic storage.
.*
:h3.*NOMAIN
:p.
The *NOMAIN super option provides all of the features of *MAIN
except that it specifies option NOMAIN instead of MAIN.
This super option should be used on a program block that
represents an external subroutine that will be called from
another program that uses dynamic storage.
.rc 2 on
.*
:h3 *SRVPRC
:p.
The *SRVPRC super option is used by service processors.  Refer to
:cit.Clemson University Computer Center Service Processor User's
Guide and Reference:ecit. for more information on this super option.
.rc 2 off
.rc 1 on
:h2.PL/I Environment
:p.
ENVIRON=PLI supports the execution time environment of
release 5 of the OS PL/I Optimizing Compiler.  At the
current time this support is minimal, but it should satisfy
the needs of most assembler programs that run as subroutines
to PL/I programs and use the PL/I environment.
:h3.*STDPLI
:p.
This is the only PL/I environment super option and should
always be specified.  The Structured Macros' support of PL/I
is not as fully developed as it is for the OS and DC
environments.  Specifying this option will help insure
future compatibility.
:p.
This super option will provide the proper reentrant linkage
for a majority of assembler programs that run in an OS PL/I
Optimizing Compiler execution time environment.  Storage is
obtained for a PWA in the same manner as a PL/I program
obtains storage for its DSA.  A DSA in PL/I contains an OS
save area, control information and program variables.
.rc 1 off
.*
.rc 1 on
:h2.Other Environments
:p.
If you want to use the Structured Macros in other than one of
the explicitly supported environments, you can code your own
linkage or add support for the environment with prolog and
epilog macros.
:p.
If you want to code your own linkage, let the environment
default to OS and do not code any linkage-related options.
Put your own linkage before or after the program block macro
and after the end block macro for the program.  If you
do your own linkage you will not be able to use PWAs, SWAs,
PSDs, SSDs or anything related.
:p.
If the Structured Macros will be used often in this
environment or if you need to use PWAs, etc., it may be
worth the time to add support for the environment.  Refer to
the internals manual for the Structured Macros for
information on writing prolog and epilog macros if you would
like to take this approach.
:p.
To add support for an environment requires a thorough
understanding of the internals of the Structured Macros and
the support may have to be updated each time the Structured
Macros themselves are updated.  If the environment needed is
of general interest, you may want to request that it be added
as a standard part of the Structured Macros and supported as
such.
.rc 1 off
.*
.rc 1 on
:h2.Subroutine Block Super Options
:p.
Currently, all environments use the same subroutine block options
and super options.
.rc 1 off
:h3.*SWA
:p.
In any program that uses the PWA option, the internal subroutines
for that program can each have an individual Subroutine Work
Area (SWA).  The *SWA super option is specified on the
subroutine block (or the SUBOPTS= on the program block)
to provide an SWA for a subroutine.  There are
SWA and ENDSWA macros to delimit the SWA just as the PWA was
delimited.  The details about the functions of an SWA and its
relation to a PWA are described in :hdref refid=pwaswa..
.*
:h3.*NOSUBOPTS
:p.
This super option clears all the subroutine options to their
:q.no:eq. state.  If the program block has specified a default set
of subroutine options with the SUBOPTS= keyword, this super
option can be used on a subroutine block to create a subroutine
without those default options.  For example, a *NOSUBOPTS,CUSTOM
might be coded to create a subroutine with just the CUSTOM
option.
.*
.*
:h2.Conclusion
:p.
.rc 1 on
The environment support and
super options make programming much easier, since all of the
.rc 1 off
tedious initialization and termination details are taken care
of with a minimum of effort.  This allows you to worry about
program logic, and not the linkage.
They also do not lock you into only these combinations
of options.  If you wish to override any of the options in a
super option, simply code them after the super option on the
OPTIONS= keyword.  For example:
:xmp.
 BLOCK  TYPE=PROGRAM,NAME=PROG,OPTIONS=(*PWA,XA,NOREGEQU),ENVIRON=OS
:exmp.
.*
.*
:h1 id=pwaswa.Program and Subroutine Work Areas
:p.
The Program and Subroutine Work Area (PWA and SWA)
support built into the Structured
Programming Macros is a powerful tool that can be invaluable
to someone writing a complex program, and also provides services
that can be useful in even a relatively small program.
.rc 1 on
Although PWAs and SWAs are normally used in reentrant programs,
even non-reentrant programs can take advantage of the services
they provide.  If option NORENT is in effect,
the storage for the work areas will be defined
in the load module instead of being dynamically obtained at
execution time.
.rc 1 off
.*
:h2.Program Work Areas
:p.
The PWA option and PWA macro provide many services besides just
.rc 1 on
defining a block of storage to be obtained for the user.
.rc 1 off
By specifying that the program will have a PWA, you
allows the Structured Macros to automatically perform many functions.
For example, space for a SMWA for the main program and
one for each of the subroutines will be reserved in the
PWA preventing you from having to code the SMWA= keyword
on the program block.  If you wish to override this
and force the SMWA to a specific location, the
SMWA= keyword can still be used.
:p.
Also, you can have parameter lists placed in the
PWA without having to explicitly define storage for them.
The Structured Macros can compute the largest parameter list
in the program and reserve enough space in the PWA.  A separate
parameter list area is reserved for the program and each subroutine.
This is required because the program parameter storage may be
in use when a subroutine is called.  For more
information on parameter lists, see :hdref refid=parms..
:p.
Option PWA allows you to define a Subroutine Work Area (SWA) for each
subroutine that contains any work area fields that are needed only
while the subroutine is executing.  This SWA is analogous to the
PWA for the program.
.rc 3 on
.*
:h2.Reusable Program Work Areas
:p.
Under normal circumstances, the PWA for a program will be allocated
whenever the program is called, and freed before the program
terminates.  However, there are cases when a program is loaded into
memory once, and called repeatedly to perform a particular function.
Not only would it be inefficient to repeatedly acquire and free
storage for this program, it may cause problems if the program is
required to retain information between calls.
:p.
This problem is solved by a mechanism known as :hp1.Reusable PWAs:ehp1..
Using this capabilility, the Structured Macros will only allocate a
new PWA when given a start-up call and will not free the storage when
the program terminates.  When the program detects that it is being
called for the final time, it can issue a macro to instruct the
Structured Macros to free the PWA storage at the termination of the
current invocation.
:p.
When reusable PWAs are being used, the caller of the program must
keep track of the PWA address and pass it in the parameter list on
every call.  The position of the PWA address in the parameter list is
customizable.  If this address is binary zeros, the Structured
Macros will allocate storage for a new PWA and store its address back
into the parameter list.  Otherwise, they will use the passed value.
:p.
Alternatively, you can specify a parameter position for
a function code that will be provided on every call and a value that
means :q.Start:eq..  With this form, the Structured Macros will
allocate a new PWA on the Start call, and use the passed PWA value
in other cases.
:p.
When the program is in its final invocation (either because of an
error or when called to terminate), the SMCTRL macro is used to
force the Structured Macros to free the PWA at program termination.
:p.
This concept is used heavily at Clemson by what we call :hp1.Service
Processors:ehp1..  These are programs that are started once and then
called repeatedly to perform a particular type of service for their
invoker.  File handling, string manipulation, and symbol management
are all examples of functions that may be handled by service processors.
For more information about the workings of Service Processors, see
:cit.Clemson University Computer Center Service Processor User's
Guide and Reference:ecit..
.rc 3 off
.*
:h2.Subroutine Work Areas
:p.
Any subroutine that will be using an SWA should use the SWA and
ENDSWA macros to define its boundaries, just as the PWA and ENDPWA
macros are used for the program's PWA.  There are options
on the subroutine block to control SWA usage, and a super option
(*SWA) that provides the correct combination of options for SWA
usage.
:p.
SWAs provide useful functions for subroutines just as PWAs do for
programs.  SMWAs and parameter lists for the subroutines are
created as part of the SWA instead of as PWA fields.  R0-R14 are
automatically saved and restored for any subroutine that has an
SWA.  Space for this is reserved by the SWA macro, so you
do not have to code the SAVE keyword, or explicitly
reserve the space.  The registers are saved as R0-R14 so that R15
will not be restored and the subroutine can pass a return code
back in this register.
:p.
You should be aware of the implications of saving and
restoring registers.  Because of this, a subroutine can not
pass back any values to its caller by way of the registers.  It
would have to use the PWA to pass back any information.  To get
around this problem, the STRSA macro was created.  This macro
stores the current value of a register in the SWA save area
for the current subroutine.  Then when the subroutine ends, the
register will be restored to the value it had when the STRSA macro
was issued, instead of the value it had when the subroutine was
called.  You can use the STRSA macro to pass back any
registers that the calling routine needs, while allowing the
other registers to be restored to their original values.
:p.
There is a CLEARPWA option on program blocks that instructs
.rc 1 on
the macros to clear the PWA after it has been obtained.  This
.rc 1 off
option is included in all of the super options that use PWAs
so that you can count on the PWA being all zeros on entry.
However, there is not a similar option on the subroutine block
to clear the SWA.  You should never count on the SWA
contents anytime a subroutine is entered.  If the fields within the
SWA need to be set to a specific value, the subroutine must include
code to initialize these fields.
:p.
These functions of SWA usage can be a great help to the
programmer, even the subroutine does not need to have any of its own
fields defined in the SWA.  If you select the SWA option, the
Structured Macros will generate an SWA for internal use in
saving registers, etc. even if you do not code the SWA and
ENDSWA macros at the end of your subroutine.
.*
:h2.SWA Placement
:p.
With the *PWA option,
these SWAs will be included as part of the PWA for the program to
which they belong.  They will be placed in the PWA's partial area
and addressability will be off of the PWA register (R13).
.rc 3 on
This configuration of PWAs and SWAs is changed in programs that use
the Structured Macros' dynamic storage management support.  For more
information on this, see :hdref refid=dynpwa..
.rc 3 off
.*
:h2.PSDs and SSDs
:p.
The PSD and SSD macros (and their respective end macros) are used
to define the Program and Subroutine Static Data areas, just as
PWA and SWA are used to define the work areas.  These macros are
used in conjunction with the LOCTR option on the program block to
insure proper placement of the program code and static data.
They also allow fields to be defined from within the program code
that will be placed with the static data when the program is
assembled.  This facility is used by the EXI macro.
.rc 1 on
These data areas are addressed off of the same base registers as
.rc 3 on
the program and subroutine code.
.rc 3 off
.rc 1 off
.*
.*
:h1 id=large.Large Program Management
:p.
As a program becomes larger and contains more subroutines,
certain problems arise.  The PWA (which contains an SWA for each
subroutine) can grow to an unmanageable size.  Also, the program
code along with the subroutine code can become so long that it
would take several base registers to maintain addressability.
The Structured Macros provide two tools to help manage such large
programs.  They are Dynamic Storage Management and the LONG and
LOADBASE options.
.rc 1 on
Dynamic Storage Management is only available for program blocks
which are using ENVIRON=OS.
.rc 1 off
.*
:h2 id=dynpwa.PWAs and SWAs with Dynamic Storage Management
:p.
If your program has a large number of internal subroutines that
heavily use SWA storage, the size of the PWA can easily
grow to an unmanageable size.  If the fields defined in the
SWA are really only necessary when the subroutine is active,
it is not necessary to allocate enough space for all of the
SWAs.  Only enough storage to contain the PWA itself, and the
largest combination of active SWAs is required.  If there were
some way to dynamically allocate and free SWA storage as
subroutines were entered and exited, a great savings in storage
could be realized.
:p.
To solve this problem, the storage for an SWA could be GETMAINed as
the subroutine is entered and FREEd at the end, but this would
slow down the operation of the program greatly.
:p.
.rc 1 on
A much more efficient system is to obtain a large block of
.rc 1 off
storage at the beginning of the program, allocate the first part
to the PWA, and allocate the rest to SWAs as it is needed.
This block of storage can be much smaller than the size of the
PWA plus all of the SWAs, since not all of the subroutines will
be active at once.  Also, since new SWA storage is allocated for
a subroutine each time it is entered, subroutines can be called
recursively.  With this system, a GETMAIN is never done more than
once for a single program.  Enough storage is allocated for all
the program and subroutines' needs at the beginning, and storage
is assigned and taken back as subroutines are entered and exited.
:p.
This is just what the Structured Macros' Dynamic Storage
Management does. The DYN option on the program block is used
to turn on Dynamic Storage Management.
Dynamic Storage also allows subroutines to call
themselves, which adds more complexity.  Also, there is hidden
recursion, such as when subroutine A calls subroutine B, and
subroutine B in turn calls subroutine A.
.*
:h3.Recursive Subroutines with the DYN Option
:p.
Recursive subroutines cause another problem.  Since they are called
again without the previous invocation being ended, multiple copies
of the subroutine's SWA need to be allocated from dynamic storage.
Since the Structured Macros have no way of knowing how deep the
recursion might go, you need to supply this information.
On any subroutine that will be called recursively (this includes
all the programs in a recursive loop such as the one described
above), you
need to use the RECUR keyword to tell the macros the maximum
number of times the subroutine will be called recursively.
This keyword tells the macros how many copies of that subroutines
SWA could be active at once, and therefore how much room to
allocate.
If you miscalculate on the RECUR keyword, the Structured Macros
will miscalculate on the space required.  If you use too big a
number, the macros will allocate more space than is needed.
If you use too small a number, the macros will allocate too little
space, and a dynamic storage error will result.  By default, the
macros will force an ABEND 0C1 when your program runs out of
dynamic storage.  However, you can specify an error exit that will
get control when this happens with the DYNERR keyword on the
program block.
.*
:h3.Storage Calculations with the DYN Option
:p.
The Structured Macros' algorithm is very comprehensive and will
allocate enough space for all known cases.
It uses an internal macro called :hp1.##ORGS:ehp1.
to trace the subroutine
call structure of the program.  From this, it determines the
subroutines that will be active together, and how big their SWAs are.
Using this information and the size of the PWA, the macros determine
how much space they will need to GETMAIN to accommodate your program.
This tracing of the subroutine structure is more difficult than it
may seem, since the main program and each subroutine may call many
other subroutines forming a very complex tree.
However, there are
certain very complicated and unlikely combinations of subroutines
that will trick them into allocating more space than they need.
If this ever becomes a problem, it can be adjusted with the
DYNSIZE keyword on the program block.  The DYNSIZE keyword is used
to replace or adjust the value for the amount of dynamic storage
calculated by the macros.  It can be used in certain cases to
fine-tune the dynamic storage requirements.  However, in most cases
the macros themselves should calculate the correct amount, and
the DYNSIZE keyword should not be needed.
.*
:h3.SWA Addressability with the DYN Option
:p.
These SWAs will be based off of register 11, while the
subroutine itself will be addressed off of the program base, and
the PWA base will remain with register 13.
It should be noted that register 11 will be in use in DYN programs
even when a subroutine has not been invoked.
.*
:h3.Super Options Used with the DYN Option
:p.
There are two program block super options for use
with Dynamic Storage Management.
They are *MAIN and *NOMAIN.  *MAIN contains all of the options in
*PWA plus the options DYN and MAIN.  The MAIN option tells DYN that
this is a main program and that dynamic storage should always be
obtained when this program is entered.
By contrast, *NOMAIN says that this program is an external subroutine
that will be called from a main program that uses DYN.  In a *NOMAIN
program, the dynamic storage of its caller will be used if there is
enough of it.  Otherwise, more storage will be GETMAINed to accommodate
the program and its subroutines.
It should be emphasized that a program compiled with option *NOMAIN
should :hp2.only:ehp2. be called from a program that uses
Dynamic Storage Management.  Even if the *NOMAIN program
GETMAINs its own storage, it requires that registers and
storage areas be set up by the calling program.
:p.
Any *MAIN program that will be calling external subroutines with
*NOMAIN might need to use the DYNSIZE keyword to adjust its
dynamic storage to allow for what the *NOMAIN program will use.
Since the *NOMAIN program will most likely be compiled separately,
there is no way for the Structured Macros to calculate its
requirements.  However, since the *NOMAIN will get more storage if
it needs it, adjusting the storage on the *MAIN program will only
affect performance by preventing an extra GETMAIN.
.*
:h3.Storage Optimization with the DYN Option
:p.
When using the DYN option, there is a short routine added to
the beginning of each internal subroutine to obtain the new
SWA.  This is not a real problem, but if the program has a large
number of small subroutines, this can significantly lengthen the
load module.  If the size of the load module is critical, the
OPTSTOR option can be used on the program block to help remedy
this.  The OPTSTOR option will create a single copy of the
subroutine linkage code and have each subroutine branch to it.
This makes subroutine calls slower, but will reduce the size of
the load module.  However, space is rarely this critical, so the
OPTSTOR option should not be needed in most cases.
.*
:h2.LONG and LOADBASE
:p.
When a program gets to be very long with a lot of subroutines (such
as a server routine or a command processor), the CSECT can become
so large that it takes two, three, or even more base registers to
maintain addressability.  It would be nice if there was some way
to allow a subroutine to have its own base register separate from
the program's base register.  The LOADBASE option on subroutine
blocks and the LONG option on the program block provide this support.
:p.
The LOADBASE option on the subroutine block instructs the subroutine
linkage routines to establish a separate addressability to that
subroutine using the subroutine base register.  This register
defaults to R10, but another register can be selected with the
BASEREG= keyword.  Any subroutines coded in this manner will be
located at the end of the CSECT, so that they will not interfere
with the program's addressability.
:p.
If a program has any subroutines that use the LOADBASE option, the
program block must have the LONG option coded.  This option causes
CALLSUB to generate the correct linkage for LOADBASE subroutines.
Since both of these options make use of partial PSDs, the LOCTR
option is also required when using these.  However, LOCTR is
included in all of the super options, so usually you
will not have to code it.
:p.
With this scheme, the macros always keep a base to the program
and to the current subroutine.  Therefore, the program will be
able to address anything in the program and its PSD as well as
the current subroutine and its SSD.  However, one subroutine
cannot address anything in another subroutine's SSD.  If you
have any static data that will be shared among subroutines, it
should be placed in the PSD.
:p.
Since a separate base register is kept for the program and the
current subroutine, this facility is only useful in programs that
already need two or more base registers.  However, with these
options the program base register only needs to address the main
program code and its static data.  If even this can not be done
with a single base register, the main program code can be moved
to an internal subroutine with only a single CALLSUB in the
program block.
.*
:h2.Size Limitations
:p.
With the techniques described here, a very large program can be
created quite easily.  Although most programmers will never exceed
the Structured Macros' limits, it may be useful to know just how large
a program can become.
The only limitation on program length (and it's static data) is the
number of base registers you are willing to use to address it.  But
with the LONG and LOADBASE options, this is not necessarily a problem.
PWAs can be up to 16M in size, but again you must maintain
addressibility on it.
.rc 1 on
SWAs can be up to a maximum of 32K in size
if DYN is in effect.
.rc 1 off
If the majority of one of your data or work areas is a single very
large data area that you only need to address the start of, you
can place it at the end of the data area.  The user fields always
go after the fields generated by the Structured Macros.
.*
:h2.Conclusion
:p.
The long program management routines provide very useful
support for large or memory intensive programs.  A great
savings in GETMAINed storage can be achieved in programs
with large numbers of subroutines, and many of the tedious
details of subroutine linkage and program storage can be
automated.  A savings in base registers can also be achieved
in extremely long programs.  For more information on the
actual layout of dynamic storage, see :hdref refid=dynform.,
while a description of program code and static data layout
can be found in :hdref refid=codform. along with an example
of how these options should be coded.
.*
.*
:h1 id=if.The IF Structure
:p.
There are four macros that are used
to build IF structures: these are
:hp2.IF, ELSEIF, ELSE:ehp2. and :hp2.ENDIF.:ehp2.
Of these, conditions to govern
statements are coded on the IF and ELSEIF macros. Like the IF services
in many higher-level languages,
there are Boolean operators available (AND, OR, NOT) for building
complex expressions: however, the conditional statements themselves
are coded using the actual assembler compare instructions. For
example,
:xmp.
 IF    (CLC,TAG1(8),NE,6(R2)),THEN
         :
   -- success code --
         :
 ELSE
         :
   -- fail code --
         :
 ENDIF
:exmp.
:pc.
will generate:
:xmp.
.tp 15 20 40
+!CLC!TAG1(8),6(R2)!generated by IF
+!BE!failtag!generated by IF
!         :
!-- success code --
!         :
+!B!endiftag!generated by ELSE
+failtag!DS!0H!generated by ELSE
!         :
!-- fail code --
!         :
+endiftag!DS!0H!generated by ENDIF
.tp
:exmp.
:p.
Similarly,
:xmp.
 IF    ((CH,R1,EQ,A),OR,(CH,R1,EQ,B)),THEN
       :
   -- success code --
       :
 ENDIF
:exmp.
:pc.
will generate:
:xmp.
.tp 17 22 40
+!CH!R1,A!first comparison
+!BE!successtag!branch if test succeeds
+!CH!R1,B!second comparison
+!BNE!failtag!branch if test fails
+successtag!DS!0H!generated by IF
!         :
!-- success code --
!         :
+failtag!DS!0H!generated by ENDIF
+endiftag!DS!0H!generated by ENDIF
.tp
:exmp.
:p.
In these examples, one thing that you may have noticed is that
the macro expansions will generate tags and branches to them as may
be appropriate. Although these tags are used only by the macros at
assembly time, it is very handy to have them available under TSO TEST.
:p.
The IF and ELSEIF macros allow you to specify :q.conditions:eq.
.rc 1 on
in a number of ways, which are fully described
in :hdref refid=condch..
.rc 1 off
Simply stated, the :q.condition:eq. of the IF statement
provides the instruction that will be used for the actual comparison
and the appropriate condition for the subsequent branch.
For example, the statement
:xmp.
 IF   (CLC,A(6),NE,3(R1)),THEN
:exmp.
:pc.
will generate the instructions
:xmp.
.tp 15 20 40
+!CLC!A(6),3(R1)
+!BE!failtag
.tp
:exmp.
:p.
Conditions may be combined on the IF statement using Boolean
expressions NOT, AND and OR.
Also, if a condition code is known to exist when an IF is executed,
only the desired conditional operator needs to be coded. For example,
:xmp.
 TRT   TEXT,TABLE
 IF    Z,THEN
  MVC   MESSAGE(15),=CL15'TEXT NOT FOUND'
  PUT   SYSPRINT,MESSAGE
 ELSE
    :
    :
 ENDIF
:exmp.
:p.
In this example, the TRT instruction
will set a :q.zero:eq. condition code
if the translate-and-test operation fails.
The subsequent IF statement is used to generate a conditional branch
without a compare instruction.
This form of the IF statement is useful for non-comparison instructions
that set a condition code, such as arithmetic and logical
instructions. The user should avoid mixing this form of condition with
conditions that generate compare instructions, though, because the
order in which the instructions are generated may cause the condition
code to be changed prematurely.
:p.
The ELSEIF macro is similar to an ELSE macro followed by an IF macro,
except the IF nesting level is not changed.  This allows the
user to test for one condition out of a list of conditions.
For example:
:xmp.
 IF      (CLC,FUNC,EQ,=C'READ'),THEN
    :
    :
 ELSEIF  (CLC,FUNC,EQ,=C'WRITE'),THEN
    :
    :
 ELSEIF  (CLC,FUNC,EQ,=C'CLOSE'),THEN
    :
    :
 ENDIF
:exmp.
:p.
This is similar to the CASE structure, except that the CASE macro
is mainly used to select one out of a sequence of numerically ordered
items.  For more information on the CASE macro, See
:hdref refid=case..
.*
.*
:h1.Loops
:p.
Variations of the :hp1.LOOP:ehp1.
and :hp1.ENDLOOP:ehp1. macros may be used to
create the most commonly used loop structures. The types of loop
available are:
:hp1.WHILE:ehp1. loops, where completion tests are performed at
the top of the loop;
:hp1.UNTIL:ehp1. loops, where completion checking is done
at the bottom of the loop;
:hp1.BCT:ehp1. and :hp1.BXLE:ehp1. loops, where completion tests
are performed at the end of the loop;
:hp1.BXH:ehp1. loops, where completion
checks are made at the top of the loop;
and :hp1.endless:ehp1. loops, where
completion checks are made within the loop by the programmer's code.
:p.
The WHILE and UNTIL loops provide the Assembly language programmer
with the standard loop structures available in any high-level
language and the ability to control the loops with any condition
that is legal in an IF statement.
See :hdref refid=condch. for a complete description of the
conditions that can be specified with the Structured Macros.
The BCT, BXH, and BXLE loop provide support for the standard
System/370 looping statements, while preserving the structured
nature of the code.
:p.
As in the other structures, the LEAVE macro may be used to exit a
loop if desired. In the case of an endless loop, a LEAVE macro is
usually the only way to exit the loop.
:fig id=loop place=inline.
.tp 10 40
 !LOOP      WHILE,condition!|   LOOP      BXH,r1,r2
 !     :!|            :
 !ENDLOOP   WHILE!|   ENDLOOP   BXH
.sk
 !LOOP      UNTIL!|   LOOP      BXLE
 !     :!|            :
 !ENDLOOP   UNTIL,condition!|   ENDLOOP   BXLE,r1,r2
.sk
 !LOOP      UNTIL!|   LOOP      BCT
 !     :!|            :
 !ENDLOOP   UNTIL,LEAVE!|   ENDLOOP   BCT,reg
.tp
:figcap.Types of LOOP macros
:efig.
.*
.*
:h1 id=case.CASEs and CASE Blocks
:p.
The CASE structure may be used in place of the
:q.jump-table:eq. or :q.go-to-depending-on:eq. structure
and serves the same function as the Pascal CASE structure.
The macros used to create the CASE structure are CASEBLK, CASE
and ENDCASE.
The CASEBLK macro opens a case block and generates code that selects
a handler routine based on the contents of a register.
The ENDCASE macro denotes the end of a CASE block, and will be
branched to at the end of each individual CASE.
CASE macros within the CASE block frame code that will handle
an individual case, or occurrence.
:p.
A common example of the use of a CASE block might appear after a
call to some routine which may return
one of several return codes, each of which
must be handled differently, as in :figref refid=case..
:fig id=case place=inline.
IF  (TREG,R15,NZ),THEN
  CASEBLK REG=R15,MULT=4
.sk
    CASE 4
    -- code handles return code 4
.sk
    CASE 12,16
    -- code handles return codes 12 and 16
.sk
    CASE OTHER
    -- code handles other return codes
.sk
  ENDCASE
.sk
ENDIF
:figcap.The CASE Block
:efig.
:p.
Please note that since the CASE and CASEBLK macros generate a
series of branches that are selected by the value in the CASEBLK
register, it should be used to select one value from a list
of numerically ordered choices.
For comparing character data, or selecting from widely separated
values, the IF - ELSEIF structure should be used.  For more
information on ELSEIF, see its description in
:hdref refid=if..
.*
.*
.rc 3 on
:h1 id=parms stitle='Standard Linkage'.
Parameter Lists and Standard Linkage
:p.
The Structured Macros provide excellent support for the main program
being called and for calling internal and external subroutines
using standard OS linkage conventions.
A large part of this is handling standard OS parameter lists.
The standard form for these parameter lists is a sequence of fullwords,
each the address of a particular data item.  If a data item is missing,
the address pointing to it is filled in with a fullword of zeros.
Upon entry to the routine, register 1 should point to the first
fullword in the parameter list.
:p.
The handling of parameter lists consists of two pieces.  First, there
must be some way to reference :hp2.input parameter lists:ehp2..
These lists are processed by a program or subroutine block and were
created by the invoking program.
Secondly, support is needed for :hp2.generated parameter lists:ehp2..
These are parameter lists that are created by a program or
subroutine block and are then passed to an external routine or
another subroutine.  These functions are intertwined, since a
program that calls an internal subroutine may create a generated
parameter list that becomes the input parameter list of the subroutine
being called.
.*
:h2.Referencing Input Parameter Lists
:p.
The input parameter list for a program is referred to by the
Structured Macros as the :hp2.Program Parameter List:ehp2. (or PPL).
The corresponding structure for subroutines is the :hp2.Subroutine
Parameter List:ehp2. (or SPL).
The Structured Macros provide a number of options to control the
handling of input parameter lists.  These options are specified as
sub-options of the PARMS option.
:p.
The VL|NOVL parameter option identifies the input parameter list
as being either variable or fixed length.
:p.
The COPY parameter option instructs the macros to copy the input
parameter list into the current work area (PWA for programs and
SWA for subroutines).  In this case, the PPL (or SPL for subroutines)
is not the original input parameter list, but a copy of the original
made in working storage.
This has several uses.  First, it prevents
the program from modifying the original parameter list.  Modifying
an input parameter list is not allowed by the standard linkage
rules.  Second, by copying the parameter list, it is addressed
with the work area base register and a separate parameter list
register is not required.
:p.
Lastly, the COPY option
makes it easier to determine which parameters were specified
on a variable length parameter list.  The work area storage is always
large enough to hold the maximum length parameter list and is filled
with zeros before the input parameter list is copied there.  Because of
this, the program only needs to test any parameter address for zero to
see if it was specified in the original parameter list.  The COPY
option requires that the PWA option has been specified for program
blocks and that the SWA option has been specified on subroutine blocks.
.rc 4 on
:p.
The COPYERROR parameter option is required if the COPY option is used
with VL input parameter lists and is used to name the error exit that
will be invoked if the input parameter list is too large to fit in the
space reserved for it in working storage.  This will happen if the
parameter list is larger than expected or if it is not a VL parameter
list, making it impossible for the Structured Macros to determine the
last parameter.  Any error exit in the program can be specified
including the unnamed error exit and an exit code may be passed to the
error exit identifing the type of error to a multi-purpose exit.
:p.
The COUNT parameter option specifies the location of a fullword into
which the Structured Macros will place the number of parameters in
a VL input parameter list.  This can be used to verify that the
program was called with the correct number of parameters.
.rc 4 off
:p.
The USING parameter option specifies a register that will be
loaded with the starting address of the input parameter list.
This will either be the original input parameter list, or an
area within the current work area (if COPY was also specified).
Once the register is loaded, a USING is done to provide
addressibility on the parameter list.
:p.
The PREFIX option instructs the macros to use a unique parameter
list ID when generating the tag names within the PPL or SPL.  For
more information about how this is used, see :hdref refid=scope..
:p.
In order to make use of these options, a description of the
input parameter list must be provided.  There are two mutually
exclusive keywords on the BLOCK macro provided for this purpose.
:p.
If a mapping macro is already available for the input parameter list,
the PARMMAP keyword can be used to specify the Dsect name and length.
This provides a name for a USING on the parameter list, and defines
the size of the area that must be reserved for a COPY.
:p.
If a mapping macro is not available, the PARMS keyword can be used
to specify a list of tags that will be used to map the parameter
list.  These tag names will either be used to generate the
parameter list Dsect, or will be mapped to the work area storage if
COPY is being used.
:note.
Whether a parameter list is mapped by a supplied Dsect or tags
generated by the PARMS keyword, these tags will not refer to the
parameters themselves, but rather to the addresses of the parameters.
This is not a deficiency in the Structured Macros; it is simply
the way that standard OS parameters work.
.rc 3 off
.*
:h2.Generating Parameter Lists
:p.
Most external subroutines (and some internal ones)
will require some sort of parameter list
to pass data between the calling program and the subroutine.
:p.
The Structured Macros provide excellent support for building,
maintaining, and passing parameter lists.
The PLIST macro is used to create or modify a parameter list.
It also loads register one with the address of the completed list.
The following example illustrates some of the capabilities of the
PLIST macro.
.rc 3 on
:xmp.
 PLIST  (DATA1,,*DATA3,*),PL=(PARMSTOR,4)
:exmp.
.rc 3 off
:p.
This example will build a parameter list of four items at the
location pointed to by PARMSTOR.
.rc 3 on
First is a simple data item that will have its address loaded into
the parameter list.
The second item in the list is
missing, so its address will be filled in with a full word of zeros.
The third item in the list will be filled in with the contents of
DATA3 instead of a pointer to DATA3.  This form of indirect
addressing is used when the referenced storage contains a pointer
to the actual parameter.
.rc 3 off
The asterisk in the fourth position tells the PLIST macro to skip
over that position in the list and leave the value there unchanged.
This is useful if you are modifying a parameter list that was
created earlier, and you only want to update certain fields.
The fields that are not to be changed can be marked with asterisks.
Once the parameter list has been built, PLIST will load register one
with the address of PARMSTOR.
:p.
The PLIST macro allows the use of constants as well as labels when
defining parameter lists.  Observe the following example:
:xmp.
 PLIST (0,,'HELLO?',=X'FF')
:exmp.
:pc.
which is equivalent to:
:xmp.
 PLIST (=F'0',,=C'HELLO?',=X'FF')
:exmp.
Both examples generate literal constants, and then fill in the
parameter list with the addresses of these constants.  Any
decimal self-defining constant will be treated as a full word
literal and any character string in quotes will be treated
as a character literal.  Note that any other type of literal
(such as hex or binary) has to be coded as a literal.
Since decimal and character constants can be coded as constants
instead of as literals, the PLIST macro makes generating parameter
lists even more painless.
:p.
Please note in the examples above the distinction between the
first and second parameter in each list.  The first parameter is
a decimal constant of zero.  The macros will generate a full word
of zero and fill in the first position in the parameter list with
the address of it.  The second parameter is missing, so the macros
will put a full word of zeros into the parameter list itself.
This is an important distinction to remember.
:p.
There are two main types of parameter lists: variable length (VL)
and fixed length (NOVL).  In variable length parameter lists, the
last address in the list has its high bit set to one to mark it
as the end of the list.  Since the length of fixed length parameter
lists is known in advance, the end does not need to be marked.
The VL or NOVL option on the program block macro
is used to set up the default for all
.rc 3 on
parameter lists generated by the program or any of its internal
subroutines.  Note that this is distinct from the VL parameter
option (specified by the PARMS option).  The VL parameter option
describes the input parameter list.
.rc 3 off
You can specify a VL (or NOVL) keyword
on the PLIST macro to override this default.
Note that all of the super options specify VL so that you will
get variable length parameter lists by default.
If the PLIST macro is generating a VL parameter list (either
because of the VL option on the program block or the VL keyword
on the PLIST macro), the last address in the parameter list will
have its high bit set to one.  This occurs even if the last
parameter has been marked with an asterisk.
.rc 3 on
:p.
You have many choices as to where the parameter list
itself gets built.  As you have already seen, you can use the
PL= keyword to specify a tag and a number of parameters for the
parameter list.  This number should represent the size of the
storage available for the parameter list.
The number is necessary because the PLIST macro verifies that
there is enough room to hold the parameter list.  This prevents
PLIST from running over the parameter list storage into other
data fields.  If the tag has a self-defining length attribute,
the number field can be omitted.  However, because of the way
the assembler interprets lengths, you need to be careful.
To illustrate this:
:xmp.
PARMS1  DS  3F
PARMS2  DS  XL(3*4)
:exmp.
:p.
Both of the definitions above reserve enough space for a parameter list
at least three items long.  However, the assembler views the first
tag as having a length of 4 since it is just a series of fullwords.
Therefore, PLIST will assume that this storage location can hold
a parameter list of only one item.
The second example actually has a length of 12, which is what PLIST
will require if you try to build a parameter list of three items here.
.rc 3 off
.*
:h2.Automatic Parameter Lists
:p.
If your program has a PWA, you can have
.rc 3 on
storage for your generated parameter lists
.rc 3 off
automatically allocated within the PWA.  Any parameter lists
that do not include a PL= keyword in their definitions will be
placed in a special parameter list area in the PWA.  This area is
only big enough to contain the single largest parameter list in the
program and is reused when a new parameter list is needed.  For
this reason, it is most useful for parameter lists that are created,
immediately used, and can then be discarded.
:p.
A separate parameter list area is also created for any internal
subroutines that generate parameter lists themselves.  This is
because a subroutine that generates a parameter list may have been
called with one and that one must remain even though the subroutine
is generating new ones.
.rc 3 on
The subroutine parameter list area is created within the SWA for the
subroutine.
.rc 3 off
:p.
If your program does not have a PWA, you can achieve the same
effect with the PL= keyword on the block macro.  This keyword
is identical to the PL= keyword on the PLIST, CALLSUB, and CALLX
macros and defines a default parameter list area for any parameter
lists within that enclosing block.  This keyword can be used on
any type block to create a unique parameter list area for each
program section.
.*
:h2.Permanent Parameter Lists
:p.
There are still cases where you would want to code PL=
for a parameter list.  If your program requires that a subroutine
will be called many times with the same parameter list it would
help to be able to create it just once, then refer to it as often
as necessary.  Also, it may be desirable to create a parameter list
and then modify it conditionally before its use.  In either of these
cases, you can use PLIST with the PL= keyword to create
the list in its own unique location.  This prevents the list
from being overwritten by the next parameter list.  These lists
may be viewed as permanent since they remain until specifically
written over, while the automatic parameter lists only remain until
the storage is needed for the next list.
:p.
If a permanent parameter list is needed, you can
code a PLIST macro with the PL= keyword and define storage for
the parameter list, most likely in the PWA or SWA.  However, this
requires more upkeep than the other types of parameter lists.  You
must make sure that enough storage has been reserved
to contain all the parameters in the list and if the number of
parameters is changed later, the storage definition must be changed.
:p.
It would be nice if there was a way to get the Structured
Macros to generate the DS commands for you.  That way, if the
size of the parameter list changed, the storage area would
change with it.  This would give the advantages of the temporary
lists while still allowing you to keep the list
around and refer to it by name for subroutine calls or modifications
to the list.  There is such a mechanism in the macros.  It is
done with the DS= keyword on the PLIST macro.  With the DS= keyword,
you can instruct the macros to set aside storage for
a particular parameter list in the PWA or in an SWA (of course
you can only specify SWA if the parameter list is being built
in a subroutine that has one.)  For example:
:xmp.
 PLIST  (DATA1,DATA2,DATA3),PL=PARM1,DS=PWA
 PLIST  (DATA4,DATA5),PL=(PARM2,3),DS=SWA
:exmp.
:p.
When the DS= keyword is used, the PLIST macro counts the parameters
in the list and sets aside just enough storage for them with a
label supplied by the PL= keyword.  You can also force
the macro to allocate a specific amount of space by including
a number in the PL= keyword.  After a parameter list is created
using the DS= keyword, it can be referred to with just a PL=tag.
One caution on using this keyword:  Since the PLIST macro actually
defines the parameter list storage within a partial PWA, the DS=
keyword should appear on the first reference to the parameter list
that the assembler sees and no others.  All other references to the
parameter list should just use PL= to specify the tag for that
list.
.rc 3 on
.*
:h2.Calling Subroutines
:p.
Two macros are provided for calling subroutines.  CALLSUB is used
to call an internal subroutine that is included as part of the
assembly of the main program.  CALLX is used to call external
routines that have been linked with the main program or that
are dynamically loaded.  These external routines may be other
programs, or they may be IBM or vendor supplied service routines.
:p.
The CALLSUB macro generates a BAL
instruction (or BAS if the XA option is being used) to jump
to a subroutine that the program has direct addressability to.
The return address will be in register 14.  Otherwise, all registers
have the same value upon entry to the subroutine that they had
in the main program.
CALLSUB also provides the necessary linkage for Dynamic
Storage Management if DYN is being used, and for subroutines that
use LOADBASE.  In either of these cases, the contents of register
15 are also destroyed by the CALLSUB macro.
:p.
The CALLX macro is for external subroutines and generates
a BALR instruction (or BASR) with the return address in register 14
and the subroutine address in register 15.  This is the standard
format for external subroutines.
Registers 14 and 15 are the only ones destroyed by
the CALLX macro.  All others will have the same value in the
subroutine that they had in the calling program.
:p.
CALLX also differs from CALLSUB in the way that the subroutine
address is specified.  Since CALLSUB is used for internal
subroutines, the name of the subroutine is specified on the
CALLSUB macro.  To call an external subroutine with CALLX,
you should specify the address in a register, or give the
CALLX macro the address of a location that contains a pointer
to the external routine.
.rc 3 off
.*
:h2.Parameter Lists on CALLSUB and CALLX
:p.
If you are going to build a parameter list and then immediately
issue a CALLSUB or CALLX macro, you can combine these functions
in a single macro.  The CALLSUB and CALLX macros can generate
parameter lists just as PLIST does, so you can have
these macros build your parameter list for you.  For example:
.rc 3 on
:xmp.
 CALLSUB  SUBONE,(DATA1,*DATA2,100),PL=(PARMS1,3),NOVL
 CALLX    (R15),(DATA3,'ERROR')
:exmp.
.rc 3 off
:p.
This method of calling subroutines is very simple.  However, it
should be noted that the parameter list will be recreated every
time the subroutine is called.  If you are going to make
repeated calls to a subroutine with the same parameter list,
it would be better to create the parameter list once and
simply load the address of it before the subroutine call.
This can be done like this:
:xmp.
 CALLX   (R15),PL=PARMSTOR
:exmp.
.*
:h2.Recommendations
:p.
To help you better understand the types of parameter lists and calls,
here are some general conventions
to remember when using the Structured
Macros for parameter lists.  These rules are not enforced by the
macros, but are good programming practice.
When reading these rules, remember the distinction between permanent
lists that use the PL= keyword to point to a specific location and
automatic lists that are defined in default parameter list storage.
:ul.
.rc 3 on
:li.If the PARMS keyword was used to describe the input parameter
list, you will generally want a parameter option of either COPY
or USING, but not both.
:li.Since it frees a register that otherwise would be used to map the
parameter list, COPY will probably be the most common option.
:li.If the PARMMAP keyword was used to describe the input parameter
list, you will generally want the USING parameter option.  The
COPY option may be specified if you want the functions it provides.
.rc 3 off
:li.When using CALLSUB and CALLX, the PL= keyword is only really
necessary when referring to a permanent list created by a previous
PLIST macro.
:li.The PLIST macro is only needed for creating
and modifying permanent parameter
lists or when the call must be done without CALLSUB or CALLX
(With LINK for example).
:li.Permanent parameter lists should only be created with PLIST.
:li.The * notation for modifying parameters should only be used in
permanent parameter lists.
:li.Temporary parameter lists should only be created with
.rc 3 on
CALLSUB or CALLX (Except when forced to use PLIST because
the call cannot be made with CALLSUB or CALLX).
.rc 3 off
:eul.
.rc 3 on
.*
:h2.Example Source
:p.
Here is an example to show you some of the various ways in which
parameter lists can be used:
:xmp.
 BLOCK   TYPE=PROGRAM,NAME=PROG1,OPTIONS=(*PWA)
*  Call external routine and pass a parameter list
  LOAD   EP=PROG2
  CALLX  (R0),(MYDATA,'OPEN',),NOVL
 ENDBLK  BLOCK=PROG1

*  And under a separate assembly, you have
 BLOCK   TYPE=PROGRAM,NAME=PROG2,PARMS=(DATA,FUNCTION,OPT)             +
               OPTIONS=(*PWA,(PARMS,COPY,NOVL))
*  Copy actual parameter data to working storage
  L      R1,DATA               Get address of 1st parameter
  MVC    DATA1,0(R1)           Save data away
*  Create a permanent list for later use.  Note that FUNCTION contains
*  the address of the parameter we want to pass.
  PLIST  (DATA1,*FUNCTION,53),PL=PARM1,DS=PWA
*  Call subroutine using temporary list
  CALLSUB SUBONE,(DATA3,,'INIT')
*  Modify permanent list
  PLIST  (*,DATA5,*),PL=PARM1
*  Call subroutine using previous list
  CALLX  =V(EXTRSUB),PL=PARM1
 ENDBLK  BLOCK=PROG2

 BLOCK   TYPE=SUBROUTINE,NAME=SUBONE,PARMMAP=(SUBPARM,SUBPARML),       +
               OPTIONS=(*SWA,(PARMS,(USING,R9),VL))
*  Call subroutine using temporary list
*  This list will be created in SWA
  CALLX  (R15),(155,'NAME',=X'FF')
*  Create a permanent list within SWA
  PLIST  (DATA4,DATA5),PL=SWAPARM,DS=SWA
 ENDBLK  BLOCK=SUBONE
         SUBPARM DSECT=YES            Generate Dsect for input parms.
SUBPARML EQU   *-SUBPARM
:exmp.
.rc 3 off
.rc 3 on
.*
.*
:h1 id=scope.Location and Scope of Data Structures
:p.
Since the Structured Macros handle all of the implementation details
of PWAs, PSDs, SWAs, etc., a programmer should not have to reference
any of these data areas directly.
However, on the rare occasions that it is necessary, symbols are
defined by the Structured Macros that contain unique tags located
at the beginning of these structures.  These symbols are listed below:
:xmp.
   &PWA - Program Work Area           &SWA - Subroutine Work Area
   &PSD - Program Static Data         &SSD - Subroutine Static Data
   &PPL - Program Parameter List      &SPL - Subroutine Parameter List
:exmp.
:p.
In order to have these symbols available to your program, you need
to include an assembler COPY statement at the beginning of your
program for the member SMSYMS.  This is necessary because of the
Assembler H requirement that all global symbols be declared in
open code and not from within macros.
:p.
These symbols can be used by any programs that needs to calculate
offsets within any of these structures.  However, these symbols have
a much better use when used within subroutines.
.*
:h2.Local Scope within Subroutines
:p.
One of the nicer concepts of high-level languages is local scope
within subroutines.
This isolates the working storage of the subroutine from the main
program, and helps to prevent the subroutine from affecting the
program's storage in unforseen ways.  To some extent, Subroutine
Work Area accomplish this goal for assembler programs.  By giving
each subroutine its own work area instead having to share work areas
within the PWA, the chance that two subroutines will overlay each
other's storage is greatly reduced.
:p.
Another very nice feature of local scope becomes evident when it
comes time to think up names for variables and work areas.  In a
language with local scoping, you can name variables within
a subroutine without any regard for what the variables in other
subroutines have been named.  This also makes it easier to copy
a subroutine from one program to another, since the new program does
not have to be checked for variable name conflicts.
:p.
Unfortunately, 370 assembler requires that every tag be unique and
does not allow for local scoping of names.  However, the subroutine
data area symbols described above can be used to accomplish the same
effect.  They contain the name of a tag at the beginning of a data
area, but this can also be thought of as a unique id that can
be prefixed to tag names to distinguish them from identically named
tags in other subroutines.  To facilitate this use of the symbols,
abbreviated versions of them were created.  The short versions are:
:xmp.
   &SWA = &W
   &SSD = &S
   &SPL = &P
:exmp.
With these tags, a subroutine like the following can be written.
Note the use of the PREFIX parameter option to force the use of the
&amp.P. symbol in the SPL.
:xmp.
       .
  COPY    SMSYMS
       .
       .
       .
 EDITDATA    TITLE 'SUBROUTINE TO EDIT PASSED FULLWORD'
 *---------------------------------------------------------------------*
 *  SUBROUTINE  EDITDATA
 *
 *  ABSTRACT    THIS SUBROUTINE WILL TAKE THE FULLWORD PASSED IN THE
 *              FIRST PARAMETER PASSED TO IT, EDIT IT INTO A WORK AREA,
 *              AND COPY THE RESULTS INTO THE AREA POINTED TO BY THE
 *              SECOND PARAMETER.
 *---------------------------------------------------------------------*
          SPACE 3
  BLOCK   NAME=EDITDATA,TYPE=SUBROUTINE,                               +
                OPTIONS=(*SWA,(PARMS,(USING,R9),PREFIX)),              +
                PARMS=(DATAPTR,RESULT)
   L      R1,&P.DATAPTR                | GET ADDR OF FULL WORD.
   L      R2,0(,R1)                    | LOAD FULL WORD TO CONVERT.
   CVD    R2,&W.DOUBL                  | CONVERT TO DECIMAL.
   MVC    &W.MASK,&S.MASK              | COPY EDIT MASK TO WORK AREA.
   EDIT   &W.MASK,&W.DOUBL             | EDIT DECIMAL NUMBER TO EBCDIC.
   L      R1,&P.RESULT                 | GET PTR TO RESULT STORAGE.
   MVC    0(11,R1),&W.MASK             | COPY RESULT.
  ENDBLK  BLOCK=EDITDATA
          SSD
 &S.MASK  DC    CL'4020202020202020202120'
          ENDSSD
          SWA
 &W.MASK  DC    CL'4020202020202020202120'
 &W.DOUBL DS    D
          ENDSWA
:exmp.
:p.
Although this may seem strange at first, most programmers will find
that the advantages outweigh any inconveniences.
.rc 3 off
.*
.*
:h1.Miscellaneous Macros
:p.
There are several macros packaged with the Structured Macros that,
while they are not true structured programming aids, perform commonly
used functions and relieve some coding effort.
.*
:h2.Bit Manipulation
:p.
There are macros provided
that perform the 4 most common functions performed
on a bit:
:hp1.setting (OI), resetting (NI), inverting (XI):ehp1.
and :hp1.testing (TM).:ehp1.
The macros that perform these tasks are called
:hp1.SBIT, RBIT, IBIT:ehp1. and :hp1.TBIT,:ehp1. respectively.
Each macro uses the appropriate immediate instruction to operate
on a single byte; however, multiple bits within the target byte may
be changed at once.
For example, the macro
:xmp.
 SBIT  FLAGBYTE,(BIT1,BIT2,BIT3)
:exmp.
:pc.
would generate:
:xmp.
.tp 15 20 40
+!OI!FLAGBYTE,BIT1+BIT2+BIT3
.tp
:exmp.
:p.
There is also a naming convention which is optional
when using these macros. If the address of the target byte is not
provided, the macros assume that the target byte's tag is the first
5 characters of the flag name. For example, the macro
:xmp.
 IBIT  PWAF1OK
:exmp.
:pc.
would assume the flag was named :q.PWAF1:eq. and generate:
:xmp.
.tp 15 20 40
+!XI!PWAF1,PWAF1OK
.tp
:exmp.
:p.
.rc 1 on
The TBIT macro is valid as a
:q.compare:eq. instruction, allowing the
.rc 1 off
use of TBIT in conditional expressions on IF, LEAVE, LOOP and ERREXIT.
.*
:h2.Testing A Register
:p.
The TREG macro may be used in place of the :q.LTR:eq. instruction.
TREG always issues a LTR that loads the target register from itself,
thus setting the condition code without modifying any registers.
.rc 1 on
TREG is valid in a conditional expressions.
.rc 1 off
.kp on
.*
:h2.Initializing Storage
:p.
The FILL macro may be used to set areas of storage to a byte value,
such as spaces or low-values.
There are three types of FILL which may be done:
:hp1.short,:ehp1. the default, for 1 to 256 bytes,
:hp1.medium,:ehp1. for up to 4095 bytes, and
:hp1.long,:ehp1. for up to 16 megabytes.
Medium FILL may use any length constant which the LA instruction can
handle, while a long FILL must have its length in a register; otherwise,
medium and long FILL are identical.
A short FILL will not destroy any registers, as it uses MVI and MVC
to propagate its fill character, but medium and long FILL both use
MVCL, and will destroy the contents of R14, R15, R0 and R1.
.kp off
.*
:h2.Register Loading
:p.
Often it is necessary to load one, two, three, or four bytes of
data into a register from storage.  The L8, L16, L24, and L32
macros allow this to be easily accomplished.  For example,
the instruction
:xmp.
 L16   R4,DATA1
:exmp.
:pc.
will load the low-order two bytes of register four with the two
bytes at location DATA1 and clear the high-order two bytes of
register four.
These macros clear the specified register, and issue an
appropriate ICM to load the required data.
:p.
:hp2.Important note::ehp2.  Since all of
these macros except L32 clear the register
before doing the ICM, they should never be used to load
a register that is referred to in the address being loaded from.
To illustrate this:
:xmp.
 L16   R2,10(R2)
:exmp.
:pc.
would generate the following code:
:xmp.
.tp 15 20 45
+!SLR!R2,R2!CLEAR REGISTER
+!ICM!R2,B'0011',10(R2)!LOAD 16 BITS
.tp
:exmp.
:p.
In this example, register two is cleared to zero, then is
loaded with the two bytes at the location pointed to by
ten off of the contents of register two.
But since register two has been zeroed, this loads from
:hp1.absolute location ten:ehp1..  This type of problem can be very
difficult to debug because without looking at the macro
expansion, it is difficult to understand exactly what is going
on.
.*
.cp 20
:h2.Executing Instructions
:p.
The EX instruction is a very powerful tool in System/370
assembly language.  There are many cases where it is the
simplest method to operate on a variable amount of data.
However, there are problems with using the EX instruction.
Most of these stem from the placement of the instruction to
be EXecuted.  The instruction can be placed inline, right
next to the EX instruction with a branch around it.  This
is convenient, but wasteful because it requires unnecessary
branch instructions.  The instruction can be placed with
the static data, but this causes more problems.  First, the
EX instruction is removed in the source from the instruction
being EXecuted, making the program harder to read.  Second,
the USING environment of the EXecuted instruction may be
completely different from that of the EX instruction, making the
coding of meaningful labels difficult or impossible.
:p.
Perhaps the best solution is to use the LOCTR assembler instruction.
This instruction establishes a new location counter for whatever
data follows.  Any data or instruction defined with a new location
counter will be collected and placed at the end of the load module.
This way, the EXecuted instruction can be defined inline with the
current USING environment, but will be placed at the end of the
load module where no branch is needed to skip over it.
:p.
However, all of these methods have one problem in common when
used with the Structured Macros.  They all require you
to code tags in the body of the program.  Since the Structured
Macros eliminate the need for tags in the rest of the program,
this can upset the indentation scheme and make the program look
:q.messy:eq. and difficult to read.
:p.
A solution to all of these problems would be to provide a
macro to generate the EX instruction and its object and to
generate the tags automatically.  This way, the source could
still be coded without the use of any tags.  The EXI macro
is included with the Structured Macros to provide this function.
It can accept any register for the EX instruction, and allows
the user to specify any opcode and one to three operands.
For example:
:xmp.
 EXI   R3,(MVC,DEST(0),0(R10))
:exmp.
:pc.
This will generate a MVC instruction with the operands specified
and an EX instruction using register 3 and the MVC.
:p.
If the LOCTR option was specified on the program block, the EXI
macro puts the EXecuted instruction in the PSD (or the SSD if it
is within a subroutine).  If NOLOCTR was specified, EXI will generate
the instruction inline with a branch around it.
.cp 20
:h2.Loading control block addresses
:p.
.rc 1 on
There are certain system control blocks that programmers find
themselves accessing often.  The LCBA macro is provided to give
you a standard way of finding these control blocks.
The LCBA macro locates the address of the specified control block
and places it in the specified register.  The mapping macros for
any control blocks LCBA uses to find the desired control block
are not required.
.rc 1 off
The LCBA macro can be used to load the address of the:
:sl compact.
:li.current ACEE,
:li.current ASCB,
.rc 1 on
:li.current ASXB,
.rc 1 off
:li.CVT,
:li.current TCB,
:li.UJT (Clemson dependent),
:li.and UVT (Clemson dependent).
:esl.
.rc 1 on
:p.
For example:
:xmp.
 LCBA   R8,ACEE
 IF     (Z)
    -- ACEE not found code --
 ENDIF
 USING  ACEE,R8
    -- Now have ACEE --
:exmp.
.rc 1 off
.*
.cp 20
.rc 3 on
:h2.Controlling Structured Macro Operation
:p.
There are times when a decision must be made in the middle of a
program that needs to affect the operation of the Structured Macros
at a later time.  To provide for this capability, the SMCTRL macro
was created to set flags that are checked by other macros.
:p.
One example of this use is the reusable PWA support.  You
use SMCTRL to inform the macros that the PWA should be freed when
the current invocation of the program is terminated.
.rc 3 off
.*
.*
:h1.Miscellaneous Examples
This section will provide some examples for pieces of code that
programmers find themselves writing often.
.*
:h2.A Search Loop
:p.
While search routines can be as
different as the data structures they are
accessing, they are usually similar in their general structure.
This is an example of a
sequential search routine that looks through a RACF access list.
:xmp.
  BLOCK NAME=SEARCH
*
*   Set up list pointer and count for search.
*
   LA   R2,ACL
   LH   R3,ACLCNT
*
*   Now loop through the access list (ACLCNT) times.
*
   LOOP BCT
    IF  (CLC,USERID(8),EQ,0(R2)),THEN
*
*   If compare succeeds, do success code and leave.
*
          :
     -- success code --
          :
     LEAVE BLOCK=SEARCH
    ENDIF
*
*  Point to next entry, try again.
*
    LA  R2,ACLLEN(,R2)
   ENDLOOP BCT,R3
*
*  Entire ACL searched without a hit, do fail code.
*
          :
    -- fail code --
          :
  ENDBLK BLOCK=SEARCH
          :
:exmp.
.*
:h2.Scanning Text
:p.
This routine (lifted from the nesting level pre-processor)
uses a BXLE and
a BXH loop to scan a line of assembler source for its opcode.
:xmp.
.tp 47
*
*   Set up for BXLE loop:
*     R1 points to start of source code line
*     R14 contains increment for R1
*     R15 contains A(end of line) as limit for R1
*
  LA   R1,LINE!R1 -> start of line
  LA   R14,1!Set increment to 1
  LA   R15,LINE+L'LINE!R15 -> end of line
.sk
  LOOP  BXLE!Skip past any tags in col. 1
   LEAVE LOOP=*,(CLI,0(R1),EQ,X'40')
  ENDLOOP BXLE,R1,R14
.sk
*
*   Now use remaining value in R1 as start for BXH loop.
*
  LOOP  BXH,R1,R14!Now scan for opcode
.sk
   IF   (CLI,0(R1),NE,X'40')
.sk
    IF  (CLC,0(6,R1),EQ,=C'BLOCK ')!If 'BLOCK'
     IC R0,=C'B'!Set type to 'B'
     CALLSUB NEST!Call NEST
.sk
    ELSEIF (CLC,0(7,R1),EQ,=C'ENDBLK ')!Elseif 'ENDBLK'
     IC R0,=C'B'!Set type to 'B'
     CALLSUB UNNEST!Call UNNEST
.sk
    ELSEIF!!( etc. )
       :
    ENDIF
.sk
*
*   If outer IF succeeded, line is processed, so leave.
*
    LEAVE  LOOP=*
   ENDIF
.sk
  ENDLOOP BXH!End of search loop.
.tp
:exmp.
.pa
.*
:h2.A DCB EODAD Exit
:p.
One way to use a DCB EODAD exit (or SYNAD, EOV and other DCB exits)
would be to :q.fake out:eq. the macros by coding a tag at the place your
end-of-file code started and specifying EODAD=tag in the DCB.
This, however, becomes dangerous when running mixed-AMODE programs,
since the EODAD routine would have to be the same AMODE as the
routine where the GET was issued. To avoid this, one can take
advantage of the fact that R14 points to the instruction following the
GET or READ macro whenever a DCB exit is called by using an
implied CALLSUB, as follows:
:xmp.
.tp 15 20 40
  OPEN  DCB,INPUT
.sk
  LOOP  UNTIL!!!Do 'endless' loop
.sk
*
*  PWAF1EOF gets set if end-of-file was found.
*
   GET      DCB,RECORD
   LEAVE    LOOP=*,(TBIT,PWAF1EOF,ON)
   CALLSUB  EATREC
.sk
  ENDLOOP   UNTIL,LEAVE
.sk
  CLOSE DCB
         :
         :
.rc 1 on
  BLOCK NAME=EOF,TYPE=SUBROUTINE,OPTIONS=*NOSUBOPTS
.rc 1 off
   SBIT  PWAF1EOF
  ENDBLK BLOCK=EOF
         :
         :
PWAF1!DC!X'00'
PWAF1EOF!EQU!X'80'
  :
DCB!DCB!EODAD=EOF,  ...
.tp
:exmp.
:p.
If this sample were bimodal, subroutine EOF would have to be the
same AMODE as the code that issued the GET macro.
.pa
.*
:h2.Returning R0 and R1 with ENDBLK
:p.
There are many programming situations where it is desirable to
return values or pointers to a calling program using registers
zero and one. Common examples are Sort exits, lookup routines
and user SVC's.
:p.
.rc 1 on
The Structured Macros provide a method for passing back R0 and/or R1
from a program block.  You can
use the RTNR0 and/or RTNR1 options on the program block macro
and specify the R0= and/or R1= keyword on the ENDBLK for the program
and all error exits.
:xmp.
.tp 40
 BLOCK NAME=TEST,TYPE=PROGRAM,OPTIONS=*PWA,RTNR0,RTNR1
       :
       :
 ENDBLK BLOCK=TEST,RC=0,R0=8,R1=PARMLIST
       :
 BLOCK NAME=ERR1,TYPE=ERREXIT
       :
 ENDBLK BLOCK=TEST,RC=8,R0=0,R1=0
.tp
:exmp.
.rc 1 off
.rc 1 on
:p.
If you are using an internal
subroutine that has an SWA
and would like to have the subroutine return a register
to its caller, you can use the STRSA macro.
.rc 1 off
.rc 3 on
.*
.*
:h1.Structured Macros Listing Program
:p.
To aid the programmer, a listing program was written that will
analyze the nesting structure of a program and report on any problems.
It also provides a listing of the original program without the
macro expansions that tend to blur the structured nature of the
program.  Once they have gotten used to it, many programmers use
this listing for most of their work, and only refer to the assembler
listing occasionally.
JCL procedures have been provided that will run this listing program
and then feed the assembler source into the Level H Assembler.
See :hdref refid=asmproc page=no. for more information.
.*
:h2.Output of the Listing Program
:p.
Below is an example of the output of the listing program.  It displays
the original input source, along with the current nesting level
depth and a diagram of the nesting type (Block, Loop, or If).
:xmp.
.bf data
LVL NESTING    SOURCE STATEMENT              MSC0150$ V1R4  15:43 89.117

001  B    | BLOCK   NAME=TEST,TYPE=PROGRAM,OPTIONS=(*PWA) |
001  B    |*                                              |
002  BL   |  LOOP   WHILE,(CR,R4,LT,R5)                   |
003  BLI  |   IF    (C,R3,GE,XYZ)                         |
003  BLI  |    MVC  ABC,XYZ                               |
002  BL   |   ENDIF                                       |
001  B    |  ENDLOOP WHILE                                |
001  B    |  CALLSUB SUB1                                 |
001  B    |*                                              |
000       | ENDBLK  BLOCK=TEST                            |
000       |*                                              |
001  B    | BLOCK   NAME=SUB1,TYPE=SUBROUTINE             |
001  B    |  LR     R1,R2                                 |
000       | ENDBLK  BLOCK=SUB1                            |
000       |*                                              |
000       |         PSD                                   |
000       |         LTORG                                 |
000       |XYZ      DC    F'9'                            |
000       |ABC      DC    F'4'                            |
000       |         ENDPSD                                |
000       |*                                              |
000       |         PWA                                   |
000       |PWAFLAG  DS    18F                             |
000       |         ENDPWA                                |
000       |*                                              |
000       |         END                                   |
.pf
:exmp.
:p.
The Structured Macros Listing Program will also point out any
irregularities in the nesting structure of the program.  Below is the
listing produced by feeding an incorrect program into it.
:xmp.
.bf data
LVL NESTING    SOURCE STATEMENT              MSC0150$ V1R4  15:43 89.117

001  B    | BLOCK   NAME=TEST,TYPE=PROGRAM,OPTIONS=(*PWA) |
001  B    |*                                              |
002  BI   |  IF     (C,R3,GE,XYZ)                         |
002  BI   |*                                              |
002  BI   | ENDBLK  BLOCK=TEST                            |
.ct  >E-8 NESTING PROBLEM
002  BI   |*                                              |
002  BI   |         END                                   |

>E-8 ENDING STRUCTURAL LEVEL IS NON-ZERO
.pf
:exmp.
.*
:h2.Controlling Listing Program Operation
:p.
To control the operation of the Structured Macros Listing Program,
the SMLIST macro has been provided.  Parameters on this macro are
processed by the listing program itself, before the source statements
are sent to the assembler.
:p.
Currently, the only parameter available is CONVERT=YES/NO.
CONVERT=YES instructs the listing program to convert the input source
to all uppercase before feeding it to the assembler.  This allows you
to write programs in upper and lower case.
Many people find mixed case programs and comments easier to read and
this parameter makes it easy to do.
:p.
Although the assembler requires that its input be in upper case,
lower case letters are allowed in text strings.  To prevent the
listing program from converting your mixed case text strings to
upper case, place them in double quotes (") instead of single
quotes (').  The listing programs will not convert the text
between double quotes and will change the double quotes back to
single quotes before passing the line to the assembler.
:p.
With this facility, programmers can write programs like the one below.
:xmp.
 TRYLOWER    TITLE 'Example program for Structured Macros'
             SMLIST CONVERT=YES
 *---------------------------------------------------------------------*
 *  Program     TRYLOWER
 *
 *  Abstract    This illustrates the use of lower case in assembler
 *              source using the SMLIST CONVERT=YES function of the
 *              Structured Macros Listing Program.
 *---------------------------------------------------------------------*
          space 3
  block   name=trylower,type=program,options=(*pwa,xa),amode=any,
                rmode=any,r1save=r9
   l      r15,4(r9)                    | Get output routine address.
   la     r1,psdtext                   | Get pointer to text.
   balr   r14,r15                      | Call output routine.
  endblk  block=trylower
          psd
 psdtext  dc    cl80"This is a test that is true."
          endpsd
          pwa
          endpwa
:exmp.
.rc 3 off
.*
.*
.* don't print running footing on next page.
.rf odd sup
:h0.II. Structured Macros Reference
.* can print running footing after this page.
.rf odd res
.* set up new even page footing (change short title variable)
.se @stitle 'Structured Macros Reference
.*
.*
:h1.BLOCK
.* stop chapter headings from starting on odd pages
.* by redefining duplex mode and calling DSM#DUPL macro
.* back from the library.
.se SYSVARD = 'no'
.dm dsm#dupl lib
:dl.
:dt.Macro:
:dd.BLOCK
:dt.Abstract:
:dd.Structured macro used to start a block.
:dt.Syntax:
.rc 1 on
:dd.BLOCK &lbt.NAME=name&rbt.&lbt.,TYPE=type&rbt.&lbt.,ENVIRON=environ
.ct &rbt.&lbt.,keyword&lbt.,keyword,...&rbt.&rbt.
.rc 1 off
:dt.Operands:
:dd.:dl termhi=1.
:dt.name
:dd.Name of block.  This operand is required for
program and subroutine blocks.
:dt.type
:dd.Type of block.  This keyword specifies the type of block.
If this keyword is not specified, INLINE is assumed.
:p.
The type of blocks are ERREXIT, INLINE, PROGRAM, and SUBROUTINE.
:p.
An errexit block contains code to be executed when an ERREXIT
macro is executed.  This type of block must be coded at
block level zero.
:p.
Inline blocks are used to group a section of code into a logical
structure.
:p.
Subroutine blocks contain code that is executed when a CALLSUB
macro specifying its name is executed.
A subroutine block must be coded at
block level zero.
:p.
A program block is used to contain the
main code body of a program.  Program
blocks can only be specified at block level zero.
.rc 1 on
:dt.environ
:dd.Program environment.  This keyword specifies the type of
environment the program will run in.  The currently supported
environments are: OS for OS linkage, DC for IDMS/DC and
PLI for the execution environment of the PL/I Optimizing Compiler.
This keyword defaults to OS.
.rc 1 off
:dt.keyword
:dd.
Indicates linkage and initialization to be done.  Using these
keywords will cause the associated ENDBLK to do the reverse linkage.
The keywords allowed depend on the type of block being defined.
(See the sections on the individual block types for more information
on the keywords allowed.)
:edl.
.rc 1 on
.cp 6
:dt.Errors:
:dd.:ul compact.
:li.Too many parameters specified on PL keyword
:li.INLINE BLOCK must be contained within PROGRAM, SUBROUTINE, or
ERREXIT BLOCK
:li.PROGRAM BLOCK must be at block nesting level 1
:li.PROGRAM BLOCK requires NAME keyword
:li.SUBROUTINE BLOCK requires NAME keyword
:li.ENVIRON must be less than 5 alphanumeric characters
:li.SUBROUTINE BLOCK must follow ENDBLK for PROGRAM BLOCK
and be at block level zero
:li.ERREXIT BLOCK must follow ENDBLK for PROGRAM BLOCK
and be at block level zero
:li.Maximum nesting level for blocks is 20
:li.Invalid BLOCK type <type>
:eul.
:edl.
.rc 1 off
.*
.pa
:h2.BLOCK TYPE=ERREXIT
:p.
The errexit block surrounds code to be performed after a fatal
error is detected.  It is invoked by the ERREXIT macro.
The ENDBLK macro
associated with an errexit block generates a branch to the ENDBLK
code of the most recent
program block, and allows you to specify a return code
with which the program will terminate.  This return code overrides
any return code that may appear on the program block's ENDBLK macro.
One errexit block without a name keyword
can be associated with a program block, in which case, a generated
name is used.
Therefore, if you have only one errexit block, the NAME parameter
may be left off of the BLOCK and the ERREXIT macros and a name will
be automatically generated.
:dl tsize=6 headhi=1 break.
:dthd.Keywords for ERREXIT blocks:
:dt.AMODE= 24 | 31 | ANY
:dd.Specifies the addressing mode the block should run in.
Amode switching code will be generated if required.
The default is AMODE=ANY which specifies that the errexit will
run in the amode in effect when it is invoked.
:dt.PL= tag|(tag,num)
:dd.Defines the default place to build parameter lists
.rc 3 on
generated within
.rc 3 off
this block.
:hp1.Tag:ehp1 defines the label for the start of parameter list
storage and :hp1.num:ehp1. is a self-defining term that represents
the maximum number of parameter list entries that the storage at
:hp1.tag:ehp1. will hold.  This must be large
enough to contain the largest parameter list in the block.  If num
is not specified, the tag must have a length modifier that is a
self-defining term.
:dt.SAVE= (r1&lbt.,r2&rbt.,address)
:dd.Requests that the register(s) named should be saved and
restored.  The :hp1.address:ehp1. operand provides the address of a
place to save the register(s).  If more than one register is
specified, a :q.STM:eq. instruction is generated: therefore,
specification of something like :q.R14,R12,address:eq. is valid.  The
SAVE keyword may be used on errexit blocks to preserve some or
all registers without requiring a standard OS save area.  The
SAVE operand is not valid on program blocks, and should not be
confused with OPTIONS=SAVE.
.rc 1 on
:dt.Errors:
:dd.Refer to :hdref refid=interr. for macros that start with
:q.##EP:eq..
.rc 1 off
:edl.
.*
.pa
:h2.BLOCK TYPE=INLINE
:p.
The inline block is used to surround a section of code that should
be treated as a single unit.
With the inline block, AMODE can be changed at the beginning of the
block and restored at the end.  Registers can also be saved and
restored.  The inline block also allows the user to define a logical
group of code that can be exited with the LEAVE macro.
:dl tsize=6 headhi=1 break.
:dthd.Keywords for INLINE blocks:
:dt.AMODE= 24 | 31 | ANY
:dd.Specifies the addressing mode the block should run in.
Amode switching code will be generated if required.
The default is AMODE=ANY which specifies that the block will
run in the amode in effect when it is entered.
:dt.PL= tag|(tag,num)
:dd.Defines the default place to build parameter lists
.rc 3 on
generated within
.rc 3 off
this block.
:hp1.Tag:ehp1 defines the label for the start of parameter list
storage and :hp1.num:ehp1. is a self-defining term that represents
the maximum number of parameter list entries that the storage at
:hp1.tag:ehp1. will hold.  This must be large
enough to contain the largest parameter list in the block.  If num
is not specified, the tag must have a length modifier that is a
self-defining term.
:dt.SAVE= (r1&lbt.,r2&rbt.,address)
:dd.Requests that the register(s) named should be saved and
restored.  The :hp1.address:ehp1. operand provides the address of
a place to save the register(s). If more than one register is
specified, a :q.STM:eq. instruction is generated: therefore,
specification of something like :q.R14,R12,address:eq. is valid.  The
SAVE keyword may be used on inline blocks to preserve some or all
registers without requiring a standard OS save area.  The SAVE
operand is not valid on program blocks, and should not be
confused with OPTIONS=SAVE.
.rc 1 on
:dt.Errors:
:dd.Refer to :hdref refid=interr. for macros that start with
:q.##IP:eq..
.rc 1 off
:edl.
.*
.pa
.rc 1 on
:h2.BLOCK TYPE=PROGRAM,ENVIRON=DC
:p.
The IDMS/DC program block, like the OS program block, surrounds the
main body of executable code. Options on the IDMS/DC program block
determine what type of IDMS/DC linkage is to be used, how IDMS/DC
macros are to be expanded, and end-of-task information for application
programs (for example, NEXT TASK CODE), as well as reentrancy,
register equating, and PWA allocation.
:dl tsize=6 headhi=1 break.
.* --------------------------------------------------------------------*
:dthd.Keywords for program blocks with ENVIRON=DC specified:
:dt.OPTIONS= option | (option&lbt.,option&lbt.,...&rbt.&rbt.)
:dd.
:hp2.Regular options::ehp2.
These are the options for individually controlling each of the BLOCK
macro's functions.  The default value for each of these options is
the negative form (NOCSECT, NOREGEQU, etc.) but note that many of
the options are included in all of the super options.
:gl termhi=1.
:gt.CSECT|NOCSECT
:gd.Indicates that a CSECT card should be generated with the name of
the block.  If NOCSECT is specified, you
will need to code a USING name,R15 before the BLOCK macro if the
LOADBASE option is in affect.
:gt.ID|NOID
:gd.Specifies that a DC should be generated at the start of the
program, containing the program block name, assembly date, and
assembly time.  If the CPYRGHT keyword is specified, it will also be
DC'ed.
:gt.LOCTR|NOLOCTR
:gd.Cause the macros to generate LOCTR instructions for the program,
subroutines, and static data areas to insure proper placement.
This option must be selected if the program is using PSDs and SSDs
or LONG and LOADBASE.
:gt.LONG|NOLONG
:gd.Indicates that CALLSUBs should generate a BALR
(or equivalent) instead of a
BAL to allow subroutines to establish a base register.  This
option is required if the program has any subroutines that use
LOADBASE.  The LOCTR option is required if this option is specified.
:gt.MODE|NOMODE
:gd.Enables generation of AMODE and RMODE cards.
:gt.PWA|NOPWA
:gd.Specifies that this program will have a PWA.  The PWA will
be acquired using #GETSTG and freed using #FREESTG if option RENT
is in effect.  If the NORENT option is in effect, the ENDPWA macro
will generate a DS instruction to reserve storage for the PWA within
the CSECT.
The PWA and ENDPWA macros should be used to define the limits of the
PWA.  This option is required if the program has subroutines that use
SWAs.
:gt.REGEQU|NOREGEQU
:gd.Specifies that register equates are to be generated.
:gt.RENT|NORENT
:gd.Specifies that the program is reentrant and that the macros
should generate reentrant code wherever necessary.
:gt.RTNR0|NORTNR0
:gd.Indicates that register zero should be passed back to
the caller.  Use the R0= keyword on the ENDBLK macro for the
program block and error exits to specify the value to be
returned. This is only valid with OPTIONS=SYSTEM, unless the
routine is handling its own delinkage and needs a value in R0
from within the program block.
:gt.RTNR1|NORTNR1
:gd.Indicates that register one should be passed back to
the caller.  Use the R1= keyword on the ENDBLK macro for the
program block and error exits to specify the value to be
returned. This is only valid with OPTIONS=SYSTEM, unless the
routine is handling its own delinkage and needs a value in R1
from within the program block.
:gt.VL|NOVL
:gd.Forces all generated parameter lists (PLIST, CALLSUB, CALLX) to
default to VL unless overridden.
:gt.XA|NOXA
:gd.Generates support for linkage using XA instructions.  If neither
XA or 370 is specified, 370 is the default.
:gt.370|NO370
:gd.Generates support for linkage using 370 instructions.  If
OPTIONS=XA is also specified, OPTIONS=370 causes generation of code
which determines whether the program is running under MVS/XA or not,
and will cause branches around XA-dependent instructions generated by
the Structured Macros such as the amode switches.
:gt.DCMACPRT/NODCMACPRT
:gd.Provides support for the #MOPT MACPRNT=ON/OFF operand, for those
IDMS/DC macros that make use of it.
:gt.DCPRGPRT/NODCPRGPRT
:gd.Provides support for the #MOPT PRGPRNT=ON/OFF operand, for those
IDMS/DC macros that make use of it.
:gt.SYSTEM or (SYSTEM,module#) / NOSYSTEM
:gd.Presence of the SYSTEM keyword causes IDMS/DC system-mode linkage
to be generated.
:gt.#START/NO#START
:gd.Causes a #START macro to be generated by the BLOCK macro. Valid
only with the SYSTEM option.
:gt.#RTN/NO#RTN
:gd.Causes a #RTN macro to be generated by the ENDBLK macro. Valid only
with the SYSTEM option.
:gt.#RETURN/NO#RETURN
:gd.Causes ENDBLK to generate a #RETURN macro. Valid only with
NOSYSTEM option.
:gt.GETSTK
:gd.Causes BLOCK to generate a #GETSTK instead of #GETSTG. Valid only
with SYSTEM and PWA options.
:gt.(NXTTASK,taskcode)
:gd.Specifies the IDMS/DC task code which should be initiated next.
Valid only with #RETURN option.
:gt.(TYPE,returntype)
:gd.Specifies the type of program termination (NORMAL, ABORT or
CONTINUE). This option is generally used only with IDMS/DC #STAE
routines. Valid only with #RETURN option.
:gt.(RESINT,interval)
:gd.Specifies the resource timeout interval for this task termination.
Valid only with #RETURN option.
:gt.(RESPGM,pgmname)
:gd.Specifies a resource timeout handler program, which will be called
if the resource timeout interval was specified and reached.
Valid only with #RETURN option.
:gt.(EP,entrypoint)
:gd.Specifies an entry point name (other than the CSECT name) to be
included on the #START macro. If this option is not coded, the entry
point name is assumed to be :q.#ST:eq. followed by the internal program
block number (usually 1).
Valid only with SYSTEM and #START options.
:egl.
.* --------------------------------------------------------------------*
:p.
If a type of regular option is specified more than once, the last
occurrence (ie. PWA or NOPWA) is used.
:p.
:hp2.Super options::ehp2.
These are provided as combinations
of the most popular options. If one
or more options is not needed, it should be specified as desired
following the super option's specification.
:p.
*NORENT - selects options CSECT, ID, LOCTR, MODE, REGEQU,
VL and #RETURN.
:p.
*NORENTSYS - selects options CSECT, ID, LOCTR, MODE, REGEQU, VL,
#START, #RTN and SYSTEM.
:p.
*RENT - selects options CSECT, ID, LOCTR, MODE, REGEQU, RENT, VL
and #RETURN.
:p.
*RENTSYS - selects options CSECT, ID, LOCTR, MODE, REGEQU, RENT, VL,
#START, #RTN and SYSTEM.
:p.
*PWA - selects options CSECT, ID, LOCTR, MODE, PWA, REGEQU, RENT, VL
and #RETURN.
:p.
*PWASYS - selects options CSECT, ID, LOCTR, MODE, PWA, REGEQU, RENT, VL,
#START, #RTN and SYSTEM.
:p.
:dt.AMODE= 24 | 31 | ANY
:dd.Specifies the addressing mode.  This keyword causes an
AMODE card to be generated by the assembler with the
specified amode.  If this keyword is not specified, no AMODE
card will be generated.
:dt.BASEREG= reg | (reg&lbt.,reg&lbt.,...&rbt.&rbt.)
:dd.Specifies the register or registers to be used
for program addressability.  The register can not be
R0, R1, R14, or R15.
BASEREG will default to R13 if the NORENT option is in
effect and the SVAREA keyword is not specified;
otherwise, it will default to R12.
:dt.CPYRGHT= notice
:dd.Specifies a quoted string that
will be DC'ed if the ID option is in effect.
:dt.PL= tag|(tag,num)
:dd.Defines the default place to build parameter lists
.rc 3 on
generated within
.rc 3 off
this block.
:hp1.Tag:ehp1 defines the label for the start of parameter list
storage and :hp1.num:ehp1. is a self-defining term that represents
the maximum number of parameter list entries that the storage at
:hp1.tag:ehp1. will hold.  This must be large
enough to contain the largest parameter list in the block.  If num
is not specified, the tag must have a length modifier that is a
self-defining term.
:dt.PWAREG= R11 | (R11,&lbt.reg&lbt.,...&rbt.&rbt.)
:dd.Specifies the register or registers to be used
for PWA addressability.
:dt.RMODE= 24 | ANY
:dd.Specifies the residency mode.
:dt.R1SAVE= register
:dd.The number of the register that register 1 should be copied to.
Program linkage (notably the use of #GETSTG or #GETSTK)
sometimes destroys the contents of register 1 from
entry.  This keyword is useful for copying the contents of the
parameter register to another register before it is destroyed.
:dt.SMWA= address
:dd.Provides the address of a Structured Macro Workarea (SMWA). The
SMWA is a doubleword of storage which is used to preserve addressing
mode and a work register while performing AMODE switching.
The SMWA keyword is valid only on a PROGRAM block, and is required
when both the 370 and XA options are in effect, or when AMODE=ANY
is specified. The SMWA may reside in the PWA.
If the program has a PWA, space for the SMWA is
automatically allocated in the PWA, and this keyword is not
necessary.
:dt.SUBOPTS= (option,...)
:dd.Can be used to specify a default set of options for all
subroutine blocks associated with this program.  Any options
specified on subsequent subroutine blocks will be in addition to
these options.  See :hdref refid=subblk page=no. for a description
of the valid subroutine block options.
.* --------------------------------------------------------------------*
:dl tsize=6 headhi=1 break.
:dt.Errors:
:dd.Refer to ##PPDC in :hdref refid=interr..
:edl.
:edl.
.rc 1 off
.*
.pa
.rc 1 on
:h2.BLOCK TYPE=PROGRAM,ENVIRON=OS
.rc 1 off
:p.
The program block surrounds the main body of executable code.
It can perform a wide variety of linkage types and initializations,
including standard save area linkage,
register equates, automatic allocation of Program Work Area, and
Dynamic Storage Management.
If the program block keywords and options
are not used to establish linkage,  the
BLOCK macro call should follow linkage code and the associated
ENDBLK macro should be followed by the reverse linkage.
:dl tsize=6 headhi=1 break.
:dthd.Keywords for program blocks with ENVIRON=OS specified:
:dt.OPTIONS= option | (option&lbt.,option&lbt.,...&rbt.&rbt.)
:dd.
:hp2.Regular options::ehp2.
These are the options for individually controlling each of the BLOCK
macro's functions.  The default value for each of these options is
the negative form (NOBR14, NOCSECT, etc.) but note that many of
the options are included in all of the super options.
:gl termhi=1.
:gt.BR14|NOBR14
:gd.Determines whether a program block's ENDBLK macro should
generate a BR 14 instruction or not. The default is NOBR14, but note
that BR14 is included in each super option.
:gt.CLEARPWA|NOCLEARPWA
:gd.Specifies whether the PWA should be cleared to zeros or not.
.rc 2 on
:gt.CLRDEBUG|NOCLRDEBUG
:gd.Specifies whether the debug area in the ESV should be cleared at
entry to this program block.  CLRDEBUG requires the ESV option.
.rc 2 off
:gt.CSECT|NOCSECT
:gd.Indicates that a CSECT card should be generated with the name of
the block along with a USING name,R15.  If NOCSECT is specified, you
will need to code a USING name,R15 before the BLOCK macro if the
LOADBASE option is in affect.
:gt.DYN|NODYN
:gd.Indicates that Dynamic Storage Management should be used.
With this option, PWA and SWA storage is allocated from the dynamic
storage area.
When the DYN option is on, register 11 is used as a base for
SWAs and can not be used by the programmer.
.rc 2 on
:gt.ERRADDR|NOERRADDR
:gd.Indicates that the ERREXIT macro should use
a BAS instruction when branching to
an errexit block.  If a code is specified,
it will be defined in the halfword immediately following the BAS
instruction.  The effect of the ERRADDR option is that at entry to
an errexit block, the CODEREG has the address of the invoking ERREXIT
macro.  If NOERRADDR is specified, a BCC instruction is generated
by the ERREXIT macro to invoke an errexit block and the CODEREG
is loaded with the code itself.
.rc 2 off
.rc 2 on
:gt.(ESV,&lbt.parmnum&rbt.,&lbt.esvtag&rbt.)|NOESV
:gd.Specifies that an Environment Support Vector is present.  The
macros will use the ESV to locate routines to do all environment
dependent services.  Parameter :hp1.parmnum:ehp1. defaults to 3
and is the number of the parameter at input to the program block
that contains a pointer to the ESV.  If the FNCODE option is in
effect, this parameter is only referenced on the
:q.startup:eq. call.  Parameter :hp1.esvtag:ehp1. defaults to
PWAAESV and is the tag to be generated in the PWA for a word
into which the program block macro will store the address of the
ESV.  The ESV option requires the PWA and RENT options.
The NOESV option indicates that the macros should call OS
services directly.
.rc 2 off
.rc 2 on
:gt.(FNCODE,&lbt.parmnum&rbt.,&lbt.startcode&rbt.)|NOFNCODE
:gd.Specifies that a function code is passed as a parameter to
this program.  Parameter :hp1.parmnum:ehp1. defaults to 2 and is
the number of the parameter at input to the program block that
contains a pointer to the function code.  Parameter
:hp1.startcode:ehp1. defaults to AL4(1) and is the value of the
startup function code.  This parameter can be any form that is
valid to the right of a DC instruction.  This option is ignored
if option REUSPWA is not in effect.
.rc 2 off
:gt.ID|NOID
:gd.Specifies that a DC should be generated at the start of the
program, containing the program block name, assembly date, and
assembly time.  If the CPYRGHT keyword is specified, it will also be
DC'ed.
:gt.LOADBASE|NOLOADBASE
:gd.Specifies that program base registers are to be loaded. LOADBASE
is assumed if the BASEREG= keyword is specified.
:gt.LOCTR|NOLOCTR
:gd.Cause the macros to generate LOCTR instructions for the program,
subroutines, and static data areas to insure proper placement.
This option must be selected if the program is using PSDs and SSDs
or LONG and LOADBASE.
:gt.LONG|NOLONG
:gd.Indicates that CALLSUBs should generate a BALR
(or equivalent) instead of a
BAL to allow subroutines to establish a base register.  This
option is required if the program has any subroutines that use
LOADBASE.  The LOCTR option is required if this option is specified.
:gt.MAIN|NOMAIN
:gd.Indicates that this is a main program and dynamic storage should
always be obtained if Dynamic Storage Management is being used.
If NOMAIN is specified, the storage already allocated by the calling
program will be used if it is sufficient, otherwise extra storage
will be obtained.
:gt.MODE|NOMODE
:gd.Enables generation of AMODE and RMODE cards.
:gt.OPTSTOR|NOOPSTOR
:gd.Turns on storage optimization to reduce the size of the load
module.  If your program has a large number of internal subroutines,
this can save you a significant amount of storage, but will slow
down subroutine calls slightly.  This option in only valid for
programs with the DYN option.
.rc 3 on
:gt.(PARMS&lbt.,options...&rbt.)|NOPARMS
:gd.Indicates that this program has an input parameter list
and therefore register one should be preserved during program
linkage.  This option is also used to specify
options for handling the input parameter list.
Any parameter option not specified will take on its default,
:q.NO:eq. state.  The available parameter options are:
:gl compact termhi=3.
:gt.COPY|NOCOPY
:gd.Specifies that the input parameter list should be copied to the
PWA.  An area large enough to contain the entire list is reserved
and the entire parameter list is copied here at the start of the
program.  Any missing parameters (including those left off the end
of a VL parameter list) will contain an address of zero.
Use of this option requires the PWA option.
.rc 4 on
:gt.(COPYERROR,errexit&lbt.,exitcode&rbt.)|NOCOPYERROR
:gd.Identifies an error exit and optionally an exit code that will
be invoked if the input parameter list overruns the space reserved
for it in the PWA during a (PARMS,COPY,VL) operation.  This suboption
is required when (PARMS,COPY,VL) is specified.  If specified,
:hp1.exitcode:ehp1. is passed in the default code register R14 and
must follow the same restrictions as CODE= on the ERREXIT macro.
If :hp1.errexit:ehp1. is specified as a null string, e.g.
(COPYERROR,), the unnamed error exit for this program block will
be invoked in case of a copy failure.
:gt.(COUNT,tag)|NOCOUNT
:gd.Specifies that a count of the parameters actually specified in the
input parameter list be made and that the result be placed in the
fullword at location :hp1.tag:ehp1..  The use of this option requires
the VL suboption of PARMS.
.rc 4 off
:gt.PREFIX|NOPREFIX
:gd.Specifies that the tags listed in the PARMS keyword for this
block should be prefixed with the &amp.PPL symbol before placing
them within the PPL.  This give all the tags within the PPL a
unique prefix so there will not be any collisions with tags within
other structures.  If this option is specified, any references to
tags within the PPL from the program will have to be coded as:
&amp.PPL.:hp1.tag:ehp1.
:gt.(USING,reg)|NOUSING
:gd.Specifies that :hp1.reg:ehp1. should be used to establish
addressibility on the input parameter list.  The specified register
is loaded with the contents of register one unless the COPY option
is also specified.  In this case, :hp1.reg:ehp1 will be loaded with
the address of the input parameter list storage in the PWA.
:gt.VL|NOVL
:gd.Specifies that the input parameter list is a variable length (VL)
parameter list.  For VL parameter lists, the COPY option will
loop through the parameters instead of doing a block copy.  If the
COPY option is being used, the high order bit in the last item of the
copied parameter list will be cleared.
:egl.
.rc 3 off
:gt.PWA|NOPWA
:gd.Specifies that this program will have a PWA.  The PWA will
be either GETMAINed or obtained from dynamic storage if option RENT
is in effect.  If the NORENT option is in effect, the ENDPWA macro
will generate a DS instruction to reserve storage for the PWA within
the CSECT.
The PWA and ENDPWA macros should be used to define the limits of the
PWA.  This option is required if the program has subroutines that use
SWAs.
:gt.REGEQU|NOREGEQU
:gd.Specifies that register equates are to be generated.
:gt.RENT|NORENT
:gd.Specifies that the program is reentrant and that the macros
should generate reentrant code wherever necessary.
.rc 2 on
:gt.(REUSPWA,&lbt.parmnum&rbt.)|NOREUSPWA
:gd.Specifies that the same PWA storage should be used on multiple
calls to the program block.
Parameter :hp1.parmnum:ehp1. defaults to 1 and is
the number of the parameter at input to the program block that
contains a pointer to the PWA anchor.
If the FNCODE option is in effect, the PWA is obtained and its address
stored in the anchor on the :q.startup:eq. call.  If NOFNCODE is
in effect, the PWA is obtained and its address
stored when the anchor at entry
contains binary zeros.  The PWA is freed by the ENDBLK macro when
the SMCTRL macro with FREEPWA=YES specified has been executed.
REUSPWA requires the PWA, RENT and SAVE
options.  NOREUSPWA indicates that the PWA should be obtained and
freed each time the program block is called.
.rc 2 off
.rc 1 on
:gt.RTNR0|NORTNR0
:gd.Indicates that register zero should be passed back to
the caller.  Use the R0= keyword on the ENDBLK macro for the
program block and error exits to specify the value to be
returned.
:gt.RTNR1|NORTNR1
:gd.Indicates that register one should be passed back to the
caller.  Use the R1= keyword on the ENDBLK macro for the
program block and error exits to specify the value to be
returned.
.rc 1 off
:gt.SAVE|NOSAVE
:gd.Save R14-R12 in the standard save area pointed to by register 13.
:gt.SAVEAREA|NOSAVEAREA
:gd.Obtain a save area, do forward and backward linking, and point
R13 to new save area.  If NORENT was specified, the save area will
be obtained inline.  If RENT was specified, it will be GETMAINed
or obtained from the PWA.  SAVEAREA is assumed if the PWA option
is specified.
:gt.VL|NOVL
:gd.Forces all generated parameter lists (PLIST, CALLSUB, CALLX) to
default to VL unless overridden.
:gt.XA|NOXA
:gd.Generates support for linkage using XA instructions.  If neither
XA or 370 is specified, 370 is the default.
:gt.370|NO370
:gd.Generates support for linkage using 370 instructions.  If
OPTIONS=XA is also specified, OPTIONS=370 causes generation of code
which determines whether the program is running under MVS/XA or not,
and will cause branches around XA-dependent instructions generated by
the Structured Macros such as the amode switches.
:egl.
:p.
If a type of regular option is specified more than once, the last
occurrence (ie. PWA or NOPWA) is used.
:p.
:hp2.Super options::ehp2.
These are provided as combinations of the most popular options.
If one or more options is not needed, it should be specified as
desired following the super option's specification.
:p.
*NORENT - selects options NOPWA, SAVE, BR14, SAVEAREA, NORENT, ID,
.rc 2 on
CSECT, REGEQU, LOADBASE, MODE, VL, NODYN, NOMAIN, NOLONG,
LOCTR, NORTNR0, NORTNR1, NOREUSPWA, NOFNCODE, NOESV, NOERRADDR and
NOCLRDEBUG.
.rc 2 off
:p.
*RENT - selects options NOPWA, SAVE, BR14, SAVEAREA, RENT, ID,
.rc 2 on
CSECT, REGEQU, LOADBASE, MODE, VL, NODYN, NOMAIN, NOLONG,
LOCTR, NORTNR0, NORTNR1, NOREUSPWA, NOFNCODE, NOESV, NOERRADDR and
NOCLRDEBUG.
.rc 2 off
:p.
*PWA - selects options PWA, CLEARPWA, SAVE, BR14, SAVEAREA, RENT, ID,
.rc 2 on
CSECT, REGEQU, LOADBASE, MODE, VL, NODYN, NOMAIN, NOLONG,
LOCTR, NORTNR0, NORTNR1, NOREUSPWA, NOFNCODE, NOESV, NOERRADDR and
NOCLRDEBUG.
.rc 2 off
:p.
*MAIN - selects options PWA, CLEARPWA, SAVE, BR14, SAVEAREA, RENT, ID,
.rc 2 on
CSECT, REGEQU, LOADBASE, MODE, VL, DYN, MAIN, NOLONG,
LOCTR, NORTNR0, NORTNR1, NOREUSPWA, NOFNCODE, NOESV, NOERRADDR and
NOCLRDEBUG.
.rc 2 off
:p.
*NOMAIN - selects options PWA, CLEARPWA, SAVE, BR14, SAVEAREA, RENT,
.rc 2 on
ID, CSECT, REGEQU, LOADBASE, MODE, VL, DYN, NOMAIN, NOLONG,
LOCTR, NORTNR0, NORTNR1, NOREUSPWA, NOFNCODE, NOESV, NOERRADDR and
NOCLRDEBUG.
:p.
*SRVPRC - selects options PWA, CLEARPWA, SAVE, BR14, SAVEAREA, RENT,
ID, CSECT, REGEQU, LOADBASE, MODE, XA, NO370, VL, NODYN, NOMAIN,
NOLONG, LOCTR, NORTNR0, NORTNR1, (REUSPWA,1), (FNCODE,2,AL4(1)),
(ESV,3,PWAAESV), ERRADDR and CLRDEBUG.
.rc 2 off
:dt.AMODE= 24 | 31 | ANY
:dd.Specifies the addressing mode.  This keyword causes an
AMODE card to be generated by the assembler with the
specified amode.  If this keyword is not specified, no AMODE
card will be generated.
:dt.BASEREG= reg | (reg&lbt.,reg&lbt.,...&rbt.&rbt.)
:dd.Specifies the register or registers to be used
for program addressability.  The register can not be
R0, R1, R14, or R15.
BASEREG will default to R13 if the NORENT option is in
effect and the SVAREA keyword is not specified;
otherwise, it will default to R12.
:dt.CPYRGHT= notice
:dd.Specifies a quoted string that
will be DC'ed if the ID option is in effect.
:dt.DYNERR= name
:dd.Specifies the name of the dynamic storage error exit name.
If DYNERR is not specified and a dynamic storage error occurs,
an ABEND 0C1 will occur.
:dt.DYNSIZE= &lbt.+|-&rbt.size
:dd.Defines the amount of storage to be added to the PWA to be
used for additional PWAs and SWAs.  A :q.+:eq. or :q.-:eq. can be
specified to indicate that the size should be added or subtracted
from the size calculated by the macros.  If this keyword is not
specified, the size calculated by the macros is used.
.rc 3 on
:dt.PARMMAP=(dsect&lbt.,len&rbt.)
:dd.Defines the Dsect to be used to map the input parameter list
and its length.  This keyword can be used if the input parameter list
is too complicated to describe with the PARMS keyword or if the
input parameter list is a standard form described by an existing
Dsect.  :hp1.len:ehp1. is only required if COPY is specified with
the PARMS option.
This keyword is mutually exclusive with the PARMS keyword.
.rc 3 off
.rc 3 on
:dt.PARMS=(tag&lbt.,tag&lbt.,...&rbt.&rbt.)
:dd.Defines the tags used to map the input parameter list.  These
will be used to generate the Program Parameter List (PPL) Dsect or
to map the input parameter list storage in the PWA (if parameter
option COPY was specified).  This also defines the size of the
input parameter list for the COPY option.
This keyword is mutually exclusive with the PARMMAP keyword.
.rc 3 off
:dt.PL= tag|(tag,num)
:dd.Defines the default place to build parameter lists
.rc 3 on
generated within
.rc 3 off
this block.
:hp1.Tag:ehp1 defines the label for the start of parameter list
storage and :hp1.num:ehp1. is a self-defining term that represents
the maximum number of parameter list entries that the storage at
:hp1.tag:ehp1. will hold.  This must be large
enough to contain the largest parameter list in the block.  If num
is not specified, the tag must have a length modifier that is a
self-defining term.
:dt.PWAREG= R13 | (R13,&lbt.reg&lbt.,...&rbt.&rbt.)
:dd.Specifies the register or registers to be used
for PWA addressability.
:dt.PWASP= number | symbol
:dd.Specifies the number of the subpool in which the PWA is to be
GETMAINed.  PWASP may only be specified on PROGRAM blocks with
PWA included among the OPTIONS. The default subpool is zero.
:dt.RMODE= 24 | ANY
:dd.Specifies the residency mode.
:dt.R1SAVE= register
:dd.The number of the register that register 1 should be copied to.
Program linkage sometimes destroys the contents of register 1 from
entry.  This keyword is useful for copying the contents of the
parameter register to another register before it is destroyed.
:dt.SMWA= address
:dd.Provides the address of a Structured Macro Workarea (SMWA). The
SMWA is a doubleword of storage which is used to preserve addressing
mode and a work register while performing AMODE switching.
The SMWA keyword is valid only on a PROGRAM block, and is required
when both the 370 and XA options are in effect, or when AMODE=ANY
is specified. The SMWA may reside in the PWA.
If the program has a PWA, space for the SMWA is
automatically allocated in the PWA, and this keyword is not
necessary.
:dt.SUBOPTS= (option,...)
:dd.Can be used to specify a default set of options for all
subroutine blocks associated with this program.  Any options
specified on subsequent subroutine blocks will be in addition to
these options.  See :hdref refid=subblk page=no. for a description
of the valid subroutine block options.
:dt.SVAREA= tag
:dd.Can be specified if the NORENT option is in effect and specifies
a relocatable tag that will be used to address the program save
area.
.rc 1 on
:dt.Errors:
:dd.Refer to ##PPOS in :hdref refid=interr..
.rc 1 off
:edl.
.*
.rc 1 on
.pa
:h2.BLOCK TYPE=PROGRAM,ENVIRON=PLI
:p.
The program block surrounds the main body of executable
code.  If ENVIRON=PLI is specified, options can be specified
to do various initialization and termination functions
specific to the OS PL/I Optimizing Compiler's execution time
environment including obtaining and freeing a DSA, doing
register equates and automatically defining a DSA within the
Program Work Area.
:dl tsize=6 headhi=1 break.
:dthd.Keywords for program blocks with ENVIRON=PLI specified:
:dt.OPTIONS= option | (option&lbt.,option&lbt.,...&rbt.&rbt.)
:dd.
:hp2.Regular options::ehp2.
These are the options for individually controlling each of the BLOCK
macro's functions.  The default value for each of these options is
the negative form (NOREGEQU, NOCSECT, etc.) but note that many of
the options are included in all of the super options.
:gl termhi=1.
:gt.CLEARPWA|NOCLEARPWA
:gd.Specifies whether the PWA should be cleared to zeros or not.
:gt.ID|NOID
:gd.Specifies that a DC should be generated at the start of the
program, containing the program block name, assembly date, and
assembly time.  If the CPYRGHT keyword is specified, it will also be
DC'ed.
:gt.LOCTR|NOLOCTR
:gd.Cause the macros to generate LOCTR instructions for the program,
subroutines, and static data areas to insure proper placement.
This option must be selected if the program is using PSDs and SSDs
or LONG and LOADBASE.
:gt.LONG|NOLONG
:gd.Indicates that CALLSUBs should generate a BALR
(or equivalent) instead of a
BAL to allow subroutines to establish a base register.  This
option is required if the program has any subroutines that use
LOADBASE.  The LOCTR option is required if this option is specified.
:gt.MODE|NOMODE
:gd.Enables generation of AMODE and RMODE cards.
:gt.PWA
:gd.
PWA can not be specified if ENVIRON=PLI is specified, but it
is implied.  ENVIRON=PLI programs will have a PWA and can
take advantage of all of a PWA's features.  The PWA will be
obtained in the same manner as and have the same format as a
Dynamic Storage Area that is obtained by PL/I.  The PWA and
ENDPWA macros should be used to define the limits of the
PWA.
:gt.REGEQU|NOREGEQU
:gd.Specifies that register equates are to be generated.
:gt.VL|NOVL
:gd.Forces all generated parameter lists (PLIST, CALLSUB, CALLX) to
default to VL unless overridden.
:gt.XA|NOXA
:gd.Generates support for linkage using XA instructions.  If neither
XA or 370 is specified, 370 is the default.
:gt.370|NO370
:gd.Generates support for linkage using 370 instructions.  If
OPTIONS=XA is also specified, OPTIONS=370 causes generation of code
which determines whether the program is running under MVS/XA or not,
and will cause branches around XA-dependent instructions generated by
the Structured Macros such as the amode switches.
:egl.
:p.
If a type of regular option is specified more than once, the last
occurrence (ie. REGEQU or NOREGEQU) is used.
:p.
:hp2.Super options::ehp2.
These are provided as combinations
of the most popular options. If one
or more options is not needed, it should be specified as desired
following the super option's specification.
:p.
*STDPLI - selects options CLEARPWA, ID, REGEQU, MODE, NOXA, NO370,
VL, LOCTR, NOLONG.
:dt.BASEREG= R11 | (R11&lbt.,reg&lbt.,...&rbt.&rbt.)
:dd.Specifies the register or registers to be used for
program addressability.  The first register must be R11 and
the other registers can not be R0, R1, R12, R14, or R15.  BASEREG
defaults to R11.
:dt.CPYRGHT= notice
:dd.Specifies a quoted string that
will be DC'ed if the ID option is in effect.
:dt.PL= tag|(tag,num)
:dd.Defines the default place to build parameter lists
.rc 3 on
generated within
.rc 3 off
this block.  If this keyword is not specified,
the correct amount of storage will automatically be reserved
and used in the PWA.
:hp1.Tag:ehp1 defines the label for the start of parameter list
storage and :hp1.num:ehp1. is a self-defining term that represents
the maximum number of parameter list entries that the storage at
:hp1.tag:ehp1. will hold.  This must be large enough to
contain the largest parameter list in the block.  If num is
not specified, the tag must have a length modifier that is a
self-defining term.
:dt.PWAREG= R13 | (R13,&lbt.reg&lbt.,...&rbt.&rbt.)
:dd.Specifies the register or registers to be used
for PWA addressability.
:dt.RMODE= 24 | ANY
:dd.Specifies the residency mode.
:dt.SUBOPTS= (option,...)
:dd.Can be used to specify a default set of options for all
subroutine blocks associated with this program.  Any options
specified on subsequent subroutine blocks will be in addition to
these options.  See :hdref refid=subblk page=no. for a description
of the valid subroutine block options.
:dt.Errors:
:dd.Refer to ##PPPLI in :hdref refid=interr..
.rc 1 off
:edl.
.*
.pa
:h2 id=subblk.BLOCK TYPE=SUBROUTINE
:p.
The subroutine block contains code that is reached via the CALLSUB
macro.  This block must be at block level zero.  Subroutine blocks
are meant for internal subroutines, not for a called program that
follows standard OS linkage conventions.
:dl tsize=6 headhi=1 break.
:dthd.Keywords for subroutine blocks:
:dt.OPTIONS= option | (option&lbt.,option&lbt.,...&rbt.&rbt.)
:dd.
:hp2.Regular options::ehp2.
These are the options for individually controlling each of the BLOCK
macro's functions.  The default value for each of these options is
the negative form (NOSWA, NOCUSTOM, etc.).
:gl termhi=1.
:gt.CUSTOM|NOCUSTOM
:gd.Specifies that the return instructions
at the end of the subroutine block should not be generated.
This option should be used if you are going to handle
all of the linkage details yourself.
If this option is specified, no other option or keywords
on the subroutine block can be specified.
:gt.LOADBASE|NOLOADBASE
:gd.Indicates that a base register (or registers) should be loaded
to establish separate addressability to this subroutine.  The
program base register is left intact providing addressability to
the program's static data.
.rc 3 on
:gt.(PARMS&lbt.,options...&rbt.)|NOPARMS
:gd.Indicates that this subroutine has an input parameter list
and therefore register one should be preserved during subroutine
linkage.  This option is also used to specify
options for handling the input parameter list.
Any parameter option not specified will take on its default,
:q.NO:eq. state.  The available parameter options are:
:gl compact termhi=3.
:gt.COPY|NOCOPY
:gd.Specifies that the input parameter list should be copied to the
SWA.  An area large enough to contain the entire list is reserved
and the entire parameter list is copied here at the start of the
subroutine.  Any missing parameters (including those left off the end
of a VL parameter list) will contain an address of zero.
Use of this option requires the SWA option.
:gt.PREFIX|NOPREFIX
:gd.Specifies that the tags listed in the PARMS keyword for this
block should be prefixed with the &amp.SPL symbol before placing
them within the SPL.  This give all the tags within the SPL a
unique prefix so there will not be any collisions with tags within
other structures.  If this option is specified, any references to
tags within the SPL from the subroutine will have to be coded as:
&amp.SPL.:hp1.tag:ehp1. or &amp.P.:hp1.tag:ehp1..
:gt.(USING,reg)|NOUSING
:gd.Specifies that :hp1.reg:ehp1. should be used to establish
addressibility on the input parameter list.  The specified register
is loaded with the contents of register one unless the COPY option
is also specified.  In this case, :hp1.reg:ehp1 will be loaded with
the address of the input parameter list storage in the SWA.
:gt.VL|NOVL
:gd.Specifies that the input parameter list is a variable length (VL)
parameter list.  For VL parameter lists, the COPY option will
loop through the parameters instead of doing a block copy.  If the
COPY option is being used, the high order bit in the last item of the
copied parameter list will be cleared.
:egl.
.rc 3 off
:gt.SAVEUSING|NOSAVEUSING
:gd.Specifies that a :q.PUSH USING:eq. should be done before the
subroutine and a :q.POP USING:eq. should be done after to save and
restore the USING environment around the subroutine.  This
isolates any changes made to the USING environment in the
subroutine from the rest of the program.
:gt.SWA|NOSWA
:gd.Specifies that this subroutine has an SWA.  The PWA option
must be specified on the program block options to use this option.
The SWA will be obtained out of dynamic storage if the DYN option
is being used, otherwise, it is allocated within the program's PWA.
R0-R14 are automatically saved and restored if this option is
specified.  This option can not be used with the SAVE= keyword.
:egl.
:p.
:hp2.Super options::ehp2.
These are provided as combinations
of the most popular options. If one
or more options is not needed, it should be specified as desired
following the super option's specification.
:p.
*SWA - selects options SWA, SAVEUSING
:p.
*NOSUBOPTS - selects options NOSWA, NOSAVEUSING, NOLOADBASE, NOCUSTOM,
.rc 3 on
NOPARMS
.rc 3 off
:dt.AMODE= 24 | 31 | ANY
:dd.Specifies the addressing mode the block should run in.
Amode switching code will be generated if required.
The default is AMODE=ANY which specifies that the subroutine will
run in the amode of its caller.
:p.
:hp2.Restriction::ehp2.
AMODE 24 or 31 must be specified on a subroutine block if it
contains inline blocks with AMODE 24 or 31 specified.
:dt.BASEREG= reg|(reg,...)
:dd.Defines the base register(s) to be used to establish
addressability to this subroutine.  If this keyword is not
specified, register 10 is used.
.rc 1 on
The register(s) specified with this keyword are only used when
LOADBASE is in effect.
.rc 1 off
.rc 3 on
:dt.PARMMAP=(dsect&lbt.,len&rbt.)
:dd.Defines the Dsect to be used to map the input parameter list
and its length.  This keyword can be used if the input parameter list
is too complicated to describe with the PARMS keyword or if the
input parameter list is a standard form described by an existing
Dsect.  :hp1.len:ehp1. is only required if COPY is specified with
the PARMS option.
This keyword is mutually exclusive with the PARMS keyword.
.rc 3 off
.rc 3 on
:dt.PARMS=(tag&lbt.,tag&lbt.,...&rbt.&rbt.)
:dd.Defines the tags used to map the input parameter list.  These
will be used to generate the Subroutine Parameter List (SPL) Dsect or
to map the input parameter list storage in the SWA (if parameter
option COPY was specified).  This also defines the size of the
input parameter list for the COPY option.
This keyword is mutually exclusive with the PARMMAP keyword.
.rc 3 off
:dt.PL= tag|(tag,num)
:dd.Defines the default place to build parameter lists
.rc 3 on
generated within
.rc 3 off
this block.
:hp1.Tag:ehp1 defines the label for the start of parameter list
storage and :hp1.num:ehp1. is a self-defining term that represents
the maximum number of parameter list entries that the storage at
:hp1.tag:ehp1. will hold.  This must be large
enough to contain the largest parameter list in the block.  If num
is not specified, the tag must have a length modifier that is a
self-defining term.
:dt.RECUR= number
:dd.Specifies the maximum number of times the subroutine will be
called recursively.  This is used in Dynamic Storage Management
to calculate the amount of space needed for SWAs.  :hp1.Number:ehp1.
should be a self-defining term.
:dt.SAVE= (r1&lbt.,r2&rbt.,address)
:dd.Requests that the register(s) named should be saved and
restored.  The :hp1.address:ehp1. operand provides the address of a
place to save the register(s). If more than one register is
specified, a :q.STM:eq. instruction is generated: therefore,
specification of something like :q.R14,R12,address:eq. is valid.
The SAVE keyword may be used on subroutine blocks to
preserve some or all registers without requiring a standard
OS save area.  The SAVE operand is not valid on program
blocks, and should not be confused with OPTIONS=SAVE.
:dt.SWAREG= R11|(R11,reg...)
:dd.Specifies the register or registers to be used for SWA
addressability.
.rc 1 on
The register(s) specified with this keyword are only used when
DYN is in effect.
:dt.Errors:
:dd.Refer to :hdref refid=interr. for macros that start with
:q.##SP:eq..
.rc 1 off
:edl.
.*
.*
:h1.CALLSUB
:dl.
:dt.Macro:
:dd.CALLSUB
:dt.Abstract:
:dd.Macro used to call an internal subroutine with linkage provided
by the Structured Macros.
A parameter list can be created for the call and its
address loaded into register one, or register one can be loaded
with the address of a previously created list.
:dt.Syntax:
:dd.CALLSUB
name&lbt.,(parms)&rbt.&lbt.,VL|NOVL&rbt.&lbt.,PL=tag|(tag,num)&rbt.
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.name
:dd.Specifies the name of the internal subroutine to be called.
The call is performed with a :q.BAL R14,:hp1.name:ehp1.:eq. or
equivalent instruction.  If the program block option LONG has been
selected, a :q.BAL R14,R15:eq. is generated destroying the contents of
register 15.
The contents of register 15 are also destroyed if DYN is used.
:dt.parms
:dd.A list of the parameters to be included in the parameter list
that the subroutine will be called with.
A missing parameter causes zero to be filled in for the parameter
address.  An * will cause the macro to skip over that parameter,
reserving the space in the parameter list but not modifying the
data there.
.rc 3 on
An * before a tag will cause the macro to load the parameter list
with the contents of the storage referenced by the tag instead of
the address of the tag.  This provides a form of indirect addressing.
.rc 3 off
Numeric and character constants can be coded and will
be converted to fullword and character literals respectively.
If :hp1.parms:ehp1. is missing, the CALLSUB macro will simply
load register one with the address specified by PL=.
:dt.VL|NOVL
:dd.VL specifies that this is a variable length parameter list
and therefore the high bit of the last address in the list should
be set to one.  NOVL says to not set the bit.  NOVL is normally the
default, but all of the super options establish VL as the default
so that NOVL might be needed in certain cases.
:dt.tag
:dd.Specifies the address of the parameter list to used for the call
to this subroutine.  Register one will be loaded with the address of
:hp1.tag:ehp1. before the subroutine is entered.  If a parameter
list is being created for this subroutine, :hp1.tag:ehp1 also
specifies where to build it.
If the PL= keyword is not specified, the parameter
list will be created in the default parameter list storage established
by an enclosing BLOCK macro, or in PWA or SWA storage if no other
default was set up.
:dt.num
:dd.Specifies the maximum number of the parameters that the storage at
:hp1.tag:ehp1. can accommodate.  If :hp1.tag:ehp1. has a length
attribute that is a self-defining term, this operand is not necessary.
This is used to insure that the specified
parameter list will fit into the storage at :hp1.tag:ehp1..
:edl.
.kp on
:dt.Errors:
:dd.:ul compact
:li.Can not CALLSUB program block or subroutine in previous
program block
:eul.
.kp off
:edl.
.*
.*
:h1.CALLX
:dl.
:dt.Macro:
:dd.CALLX
:dt.Abstract:
:dd.Macro used to call an external subroutine with standard OS
linkage.  A parameter list can be created for the call and its
address loaded into register one, or register one can be loaded
with the address of a previously created list.
:dt.Syntax:
:dd.CALLX
addr&lbt.,(parms)&rbt.&lbt.,VL|NOVL&rbt.&lbt.,PL=tag|(tag,num)&rbt.
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.addr
:dd.Specifies the address of the external subroutine.  This
address can be of the form: :hp2.(R15)|=V(name)|tag:ehp2..
If the :hp1.tag:ehp1. form is used, :hp1.tag:ehp1. should be the
label of the address of the external subroutine.
The call is performed with a BALR R14,R15 or equivalent
instruction.
:dt.parms
:dd.A list of the parameters to be included in the parameter list
that the subroutine will be called with.
A missing parameter causes zero to be filled in for the parameter
address.  An * will cause the macro to skip over that parameter,
reserving the space in the parameter list but not modifying the
data there.
.rc 3 on
An * before a tag will cause the macro to load the parameter list
with the contents of the storage referenced by the tag instead of
the address of the tag.  This provides a form of indirect addressing.
.rc 3 off
Numeric and character constants can be coded and will
be converted to fullword and character literals respectively.
If :hp1.parms:ehp1. is missing, the CALLX macro will simply
load register one with the address specified by PL=.
:dt.VL|NOVL
:dd.VL specifies that this is a variable length parameter list
and therefore the high bit of the last address in the list should
be set to one.  NOVL says to not set the bit.  NOVL is normally the
default, but all of the super options establish VL as the default
so that NOVL might be needed in certain cases.
:dt.tag
:dd.Specifies the address of the parameter list to used for the call
to this subroutine.  Register one will be loaded with the address of
:hp1.tag:ehp1. before the subroutine is entered.  If a parameter
list is being created for this subroutine, :hp1.tag:ehp1 also
specifies where to build it.
If the PL= keyword is not specified, the parameter
list will be created in the default parameter list storage established
by an enclosing BLOCK macro, or in PWA or SWA storage if no other
default was set up.
:dt.num
:dd.Specifies the maximum number of parameters that the storage at
:hp1.tag:ehp1. can accommodate.  If :hp1.tag:ehp1. has a length
attribute that is a self-defining term, this operand is not necessary.
This is used to insure that the specified
parameter list will fit in the storage at :hp1.tag:ehp1..
:edl.
:dt.Errors:
:dd.None
:edl.
.*
.*
:h1.CASE
:dl.
:dt.Macro:
:dd.CASE
:dt.Abstract:
:dd.Structured macro used to start the code for a particular
case within a case block.  This macro must be coded between a CASEBLK
and ENDCASE macro.  The CASE macro is always associated with the
innermost CASEBLK.
:dt.Syntax:
:dd.CASE n&lbt.,n&lbt.,...&rbt.&rbt.|OTHER&lbt.,CASEBLK=name&rbt.
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.n
:dd.Specifies the case number or numbers whose code follows
the case statement.  OTHER indicates all cases not associated
with a particular case.  The case number can not be larger than
the MULT= value on the associated CASEBLK macro times 100.
:dt.name
:dd.Name specified on the associated CASEBLK macro.
:edl.
:dt.Errors:
:dd.:ul compact.
:li.CASE <casenumber> already used
:li.No operand was specified on CASE statement
:li.OTHER has already been specified in this CASEBLK
:li.CASE is not numeric
:li.CASE number can not be larger then 'MULT' * 100
:li.CASE number must be a multiple of 'MULT'
:li.CASEBLK= does not match CASE name
:li.CASE macro is not at same structural level as a CASEBLK macro
:eul.
:edl.
.*
.*
:h1.CASEBLK
:dl.
:dt.Macro:
:dd.CASEBLK
:dt.Abstract:
:dd.Structured macro used to start a case block.  Case blocks
can be nested up to twenty deep.
:dt.Syntax:
:dd.CASEBLK
REG=reg&lbt.,WREG=wreg&rbt.&lbt.,MULT=1|2|4|8&rbt.&lbt.,NAME=name&rbt.
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.reg
:dd.Specifies the register that contains the case number.
:dt.wreg
:dd.Specifies the register that CASEBLK can use internally as
a work register for address calculations.  If WREG= is not specified,
the REG= is used as a work register.  This destroys the contents of
REG.
The work register can never
be register 0.
:dt.mult
:dd.This keyword specifies that all the case numbers on the
associated CASE macros are a multiple of 1, 2, 4, or 8.  1 is the
default.
:dt.name
:dd.Specifies the name of the case block.
:edl.
:dt.Errors:
:dd.:ul compact.
:li.Invalid MULT= specified. Must be 1, 2, 4, or 8.
:li.CASEBLK can not be nested more than 20 deep
:li.REG= must be specified
:eul.
:edl.
.rc 4 on
.*
.*
:h1.DEFUCOND
:dl.
:dt.Macro:
:dd.DEFUCOND
:dt.Abstract:
:dd.Structured macro used to define the name of a user condition and
identify the macro that will process it.  With DEFUCOND the programmer
can add special case conditions to the list of standard conditions
available in conditional expressions.  For information on writing
a user condition macro, see :hdref refid=ucond..
:dt.Syntax:
:dd.DEFUCOND NAME=name,MACRO=macro
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.name
:dd.Name of the user condition being defined.  This name will be used
in conditional expressions to invoke this condition.
:dt.macro
:dd.Name of the macro that will perform this user-defined conditional
test.  This macro will be invoked by the Structured Macros whenever
a conditional expression is encountered that contains the named
condition.
:edl.
:dt.Errors:
:dd.:ul compact.
:li.NAME= must be specified
:li.MACRO= must be specified
:eul.
:edl.
.rc 4 off
.*
.*
:h1.ELSE
:dl.
:dt.Macro:
:dd.ELSE
:dt.Abstract:
:dd.Structured macro used to start the else code for an associated
IF or ELSEIF macro.  An ELSE macro is always associated
with the innermost IF structure.
:dt.Syntax:
:dd.ELSE &lbt.IF=name&rbt.
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.name
:dd.Name of associated IF macro.
:edl.
:dt.Errors:
:dd.:ul compact.
:li.IF nesting level is zero
:li.ELSE already encountered for this IF
:li.NAME= does not match corresponding IF
:li.ELSE structural level is not the same as the corresponding IF
:eul.
:edl.
.*
.*
:h1.ELSEIF
:dl.
:dt.Macro:
:dd.ELSEIF
:dt.Abstract:
:dd.Structured macro used to start the else code for an associated
IF or ELSEIF macro.  An ELSEIF macro is always associated with the
innermost IF structure.  An ELSEIF is like an ELSE macro followed
by an IF macro except that the IF nesting level stays the same.
:dt.Syntax:
:dd.ELSEIF cond&lbt.,THEN&rbt.&lbt.,IF=name&rbt.
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.cond
:dd.Conditional expression. (See :hdref refid=condch..)
:dt.name
:dd.Name on associated IF macro.
:edl.
:dt.Errors:
:dd.:ul compact.
:li.ELSEIF must be contained in IF structure
:li.ELSE for this IF precedes ELSEIF
:li.IF= does not match corresponding IF
:li.ELSEIF structural level is not the same as corresponding IF
:li.Refer to :hdref refid=interr., for possible condition errors.
:eul.
:edl.
.*
.*
:h1.ENDBLK
:dl.
:dt.Macro:
:dd.ENDBLK
:dt.Abstract:
:dd.Structured macro used to end a block structure.  Refer to the
description of the BLOCK macro for more information.
:dt.Syntax:
.rc 1 on
:dd.ENDBLK &lbt.BLOCK=name&rbt.
.ct &lbt.,RC=rc&rbt.
.ct &lbt.,R0=r0&rbt.
.ct &lbt.,R1=r1&rbt.
.rc 1 off
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.name
:dd.Name on associated BLOCK macro.
:dt.rc
:dd.Return code.
The return
code can be specified as a symbol or (Rn) where n is
the number of a register.
The default for RC is (R15).
.rc 1 on
RC= is ignored on the ENDBLK macro of a program block that is using
the PLI environment.
:dt.r0
:dd.Value to be returned in register zero.  This keyword
requires the RTNR0 option to be in effect and is only valid
on the ENDBLK for a program block and its error exits.  This
value can be specified as a symbol or (Rn) where n is the
number of a register.  The default for R0 is (R0).
:dt.r1
:dd.Value to be returned in register one.  This keyword
requires the RTNR1 option to be in effect and is only valid
on the ENDBLK for a program block and its error exits.  This
value can be specified as a symbol or (Rn) where n is the
number of a register.  The default for R1 is (R1).
.rc 1 off
:edl.
:dt.Errors:
:dd.:ul compact.
:li.<RC> invalid on RC=
:li.Block nesting level is already zero
:li.BLOCK= does not match current block
:li.Structural nesting level does not match level at entry to
corresponding block
.rc 1 on
:li.Refer to :hdref refid=interr. for macros that start with
:q.##EE:eq.,
:q.##IE:eq.,
:q.##PE:eq. or
:q.##SE:eq.
for other possible errors.
.rc 1 off
:eul.
:edl.
.*
.*
:h1.ENDCASE
:dl.
:dt.Macro:
:dd.ENDCASE
:dt.Abstract:
:dd.Structured macro used to end a case block structure.
:dt.Syntax:
:dd.ENDCASE &lbt.CASEBLK=name&rbt.
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.name
:dd.Name on associated CASEBLK macro.
:edl.
:dt.Errors:
:dd.:ul compact.
:li.CASEBLK nesting level is zero
:li.CASEBLK= does not match CASE name
:li.Structural nesting level of ENDCASE is different than corresponding
CASEBLK macro
:eul.
:edl.
.*
.*
:h1.ENDIF
:dl.
:dt.Macro:
:dd.ENDIF
:dt.Abstract:
:dd.Structured macro used to end an IF structure.
:dt.Syntax:
:dd.ENDIF &lbt.IF=name&rbt.
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.name
:dd.Name on associated IF macro.
:edl.
:dt.Errors:
:dd.:ul compact.
:li.IF nesting level is zero
:li.IF= does not match corresponding IF
:li.ENDIF is not at same structural level as corresponding IF
:eul.
:edl.
.*
.*
:h1.ENDLOOP
:dl.
:dt.Macro:
:dd.ENDLOOP
:dt.Abstract:
:dd.Structured macro used to end a LOOP structure.
See the LOOP macro for more information.
:dt.Syntax:
:dd.ENDLOOP &lbt.LOOP=name,&rbt.
.tp 22 37
!WHILE!|
!UNTIL,cond!|
!UNTIL,LEAVE!|
!BCT,reg!|
!BXH!|
!BXLE,reg,reg
.tp
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.name
:dd.Name on associated LOOP macro.
:dt.cond
:dd.Conditional expression. (See :hdref refid=condch..)
:dt.reg
:dd.Register to be used on associated instruction.
:edl.
:dt.Errors:
:dd.:ul compact.
:li.Additional positional parameters can not be specified on ENDLOOP
<type>
:li.Nesting level for loops is 0
:li.LOOP= does not match corresponding LOOP
:li.<type> does not match type on corresponding LOOP
:li.Incorrect number of parameters specified for ENDLOOP <type>
:li.LOOP type <type> is invalid
:li.Incorrect number of parameters specified on ENDLOOP UNTIL,LEAVE
:li.ENDLOOP structural level is not the same as the corresponding LOOP
:li.Refer to :hdref refid=interr., for possible condition errors.
:eul.
:edl.
.*
.*
:h1.ENDPSD
:dl.
:dt.Macro:
:dd.ENDPSD
:dt.Abstract:
:dd.Macro used to define the end of the Program Static
Data (PSD).  The ENDPSD macro is used to close either a partial
PSD within the program code, or the last PSD at the end of the
program.
:dt.Syntax:
:dd.ENDPSD
:dt.Operands:
:dd.None
:dt.Errors:
:dd.:ul compact.
:li.ENDPSD does not correspond to a PSD
:li.ENDPSD is not at the same nesting level as PSD
:eul.
:edl.
.*
.*
:h1.ENDPWA
:dl.
:dt.Macro:
:dd.ENDPWA
:dt.Abstract:
:dd.Macro used to define the end of the Program Work
Area (PWA) or to close a partial PWA.
The ENDPWA macro will define the PWAPLLEN tag
to establish the length of the PWA.  Also, if the DYN option
is being used, ENDPWA will use the ##ORGS macro to reserve
space for the SWAs.
If option NORENT is in effect, a DS instruction is generated to
reserve storage in the CSECT for the PWA.
:dt.Syntax:
:dd.ENDPWA
:dt.Operands:
:dd.None
:dt.Errors:
:dd.None
:edl.
.*
.*
:h1.ENDSSD
:dl.
:dt.Macro:
:dd.ENDSSD
:dt.Abstract:
:dd.Macro used to define the end of the Subroutine Static
Data (SSD).  The ENDSSD macro is used to close either a partial
SSD within the subroutine code, or the last SSD at the end of the
subroutine.
:dt.Syntax:
:dd.ENDSSD
:dt.Operands:
:dd.None
:dt.Errors:
:dd.:ul compact.
:li.ENDSSD does not correspond to a SSD
:li.ENDSSD is not at the same nesting level as SSD
:eul.
:edl.
.*
.*
:h1.ENDSWA
:dl.
:dt.Macro:
:dd.ENDSWA
:dt.Abstract:
:dd.Macro used to define the end of the Subroutine Work
Area (SWA).  It is also used to end a partial SWA definition.
The ENDSWA macro will
establish the length of the SWA for Dynamic Storage calculations.
ENDSWA also insures double word alignment for anything that will
follow the SWA.
:dt.Syntax:
:dd.ENDSWA
:dt.Operands:
:dd.None
:dt.Errors:
:dd.None
:edl.
.*
.*
:h1.ERREXIT
:dl.
:dt.Macro:
:dd.ERREXIT
:dt.Abstract:
:dd.Structured macro used to conditionally cause an errexit block
to be executed.
:dt.Syntax:
:dd.ERREXIT &lbt.cond&rbt.&lbt.,CODE=code&rbt.
.ct &lbt.,CODEREG=reg&rbt.&lbt.,NAME=name&rbt.
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.name
:dd.Name of errexit block to execute.  If the name is omitted
the unnamed error exit block for the program is executed.
:dt.code
:dd.Symbol representing a value from 0 to 4095.  If specified, this
code will be passed to the error exit block in the CODEREG= register.
:dt.reg
:dd.Register used for passing error code.  The default is R14.
:dt.cond
:dd.Conditional expression. (See :hdref refid=condch..)
If the expression is true, the error exit is taken.  If an expression
is not specified, the error exit is always taken.
:edl.
:dt.Errors:
:dd.:ul compact.
:li.Refer to :hdref refid=interr., for possible condition errors.
:eul.
:edl.
.*
.*
:h1.EXI
:dl.
:dt.Macro:
:dd.EXI
:dt.Abstract:
:dd.This is the EXecute Immediate macro.
It is used to generate an EX instruction and the instruction
to be executed.  This allows the EXecuted statement to be defined
at the same time the EX instruction is defined, minimizing confusion.
It also insures that the USING environment is the same as that of
the EX instruction.  The EXecuted instruction will be generated in
the PSD for the program (or SSD for a subroutine) if the program
has selected option LOCTR.  Otherwise, it will be generated inline
with a branch around it.
:dt.Syntax:
:dd.EXI reg,(opcode,op1&lbt.,op2&lbt.,op3&rbt.&rbt.)
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.reg
:dd.Specifies the register to be used in the EX instruction.
:dt.opcode
:dd.Defines the opcode to be used for the EXecuted instruction.
:dt.op1-3
:dd.Defines the operands for the EXecuted instruction.  There can
be one, two, or three operands.
:edl.
:dt.Errors:
:dd.None
:edl.
.*
.*
:h1.FILL
:dl.
:dt.Macro:
:dd.FILL
:dt.Abstract:
:dd.Macro used to fill an area of storage with a character.
:dt.Syntax:
:dd.FILL op1&lbt.,op2&rbt.&lbt.,LENGTH=len|(len,type)&rbt.
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.op1
:dd.Provides
the starting address of the storage to be cleared.
May be given as an RX-type address.
:dt.op2
:dd.Provides
a byte other than X'00' to propagate through the storage
to be cleared.
May be specified in X'nn' or C'c' form (suitable for use by MVI).
If not specified, X'00' is assumed.
:dt.len
:dd.Provides
the length of the storage area to be cleared.
May be a numeric value, a constant value or a register specification.
The default is (L'op1,SHORT).
:dt.type
:dd.Specifies
the type of clearing operation to be performed: e.g.
:q.short:eq., :q.medium:eq. or :q.long:eq..
:edl.
:dt.Errors:
:dd.:ul compact.
:li.FILL operation type invalid: Must be S)hort, M)edium, or L)ong
:li.Long form FILL requires R-Form length
:li.Length for FILL required but not specified
:li.Unable to parse FILL destination
:eul.
:dt.Caution:
:dd.If a tag is defined in a macro, FILL does not have L':hp1.tag:ehp1.
resolved for it and gets an assembly error.  To correct this, you
can code:
:xmp.
 FILL  tag,X'00',LENGTH=L'tag
:exmp.
:edl.
.*
.*
:h1.IBIT
:dl.
:dt.Macro:
:dd.IBIT
:dt.Abstract:
:dd.Macro used to invert bit flags in a byte.
:dt.Syntax:
:dd.IBIT &lbt.byte,&rbt.flag|(flag&lbt.,flag&lbt.,...&rbt.&rbt.)
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.byte
:dd.Byte that contains bit(s) to be inverted.  If this
operand is omitted,  the name of the byte is assumed to be the
first five characters of the first flag name.
:dt.flag
:dd.Byte mask with a binary one in the bit position of the mask
that corresponds to the bit to be inverted in the byte.
:edl.
:dt.Errors:
:dd.:ul compact.
:li.No more than eight flags can be specified
:li.IBIT macro can have no more than two operands
:li.If byte is not specified, flag name must be at least six characters
long
:li.If byte is not specified, the first five characters of all flags
must match
:eul.
:edl.
.*
.*
:h1.IF
:dl.
:dt.Macro:
:dd.IF
:dt.Abstract:
:dd.Structured macro used to start an IF structure.
:dt.Syntax:
:dd.IF cond&lbt.,THEN&rbt.&lbt.,NAME=name&rbt.
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.name
:dd.Name to be associated with IF structure.
:dt.cond
:dd.Conditional expression. (See :hdref refid=condch..)
:edl.
:dt.Errors:
:dd.:ul compact.
:li.IFs can only be 20 deep
:li.Refer to :hdref refid=interr., for possible condition errors.
:eul
:edl.
.*
.*
:h1.LCBA
:dl.
:dt.Macro:
:dd.LCBA
:dt.Abstract:
:dd.This macro loads the address of certain control blocks into a
register.  No registers are changed except for the register specified.
A zero condition is set if the control block can not be located.
It is not necessary for the mapping macros for the control blocks
used internally by this macros to be included in the source program.
:dt.Syntax:
:dd.LCBA reg,cb
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.reg
:dd.This operand specifies the register to be loaded.
The register must be specified as R1 through R15.
:dt.cb
:dd.One of the following control blocks can be specified:
:dl.
:dt.ACEE
:dd.The address of the current RACF Accessor Environment Element
will be loaded.  This address will be the contents of the TCBSENV field
of the current TCB
if non-zero and present; otherwise, the address will be the contents
of the ASXBSENV field of the current ASXB.
:dt.ASCB
:dd.The address of the current Address Space Control Block will be
loaded.  This address is loaded from PSAAOLD.
:dt.ASXB
:dd.The address of the current Address Space Extension Block will be
loaded.  This address is loaded from ASCBASXB.
:dt.CVT
:dd.The address of the Communications Vector Table will be loaded.
This address is loaded from location decimal 16.
:dt.TCB
:dd.The address of the current Task Control Block will be loaded.
This address is loaded from PSATOLD.
:dt.UJT
:dd.The address of the User Job Table will be loaded.  This control
block is Clemson dependent.  TCBUSER of the current TCB and its parents
TCBs are searched to find the address of the UJT.
:dt.UVT
:dd.The address of the User Communication Vector Table will be loaded.
This control block is Clemson dependent.  This address is loaded from
the three low order bytes of CVTUSER.
:edl.
:edl.
:dt.Errors:
:dd.:ul compact.
:li.<reg> is invalid.  Register must be R1-R15.
:li.<cb> is not a supported control block.
:eul
:edl.
.*
.*
:h1.LEAVE
:dl.
:dt.Macro:
:dd.LEAVE
:dt.Abstract:
:dd.Structured macro used to leave a structure.
:dt.Syntax:
:dd.LEAVE struc=name&lbt.,cond&rbt.
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.struc
:dd.Type of structure to leave.  Can be IF, LOOP, BLOCK,
or CASEBLK.
:dt.name
:dd.Name of the structure to leave.  An * can be coded to
indicate the current (innermost) structure of the specified type.
:dt.cond
:dd.Conditional expression. (See :hdref refid=condch..)
If the expression is true, the structure is left.  If an expression is
not specified, the structure is left unconditionally.
:edl.
:dt.Errors:
:dd.:ul compact.
:li.SMWA= keyword needs to be specified on program block macro
:li.Only one keyword can be specified on LEAVE
:li.Nesting level for <structure> is zero
:li.<name> is not an active <structure> name
:li.One keyword must be specified on LEAVE
:li.Refer to :hdref refid=interr., for possible condition errors.
:eul.
:edl.
.*
.*
:h1.LOOP
:dl.
:dt.Macro:
:dd.LOOP
:dt.Abstract:
:dd.Structured macro used to start a loop structure.
For LOOP WHILE loops, tests are done at the start of the loop.
For LOOP UNTIL loops, tests are done at the bottom of the loop.
If the ENDLOOP specifies UNTIL,LEAVE, the loop will continue
until a LEAVE macro is used to leave the loop.  BCT, BXH, and
BXLE loop use the assembler instruction by the same name.  BXH
instructions are generated at the top of the loop and BXLE and BCT
instructions are generated at the bottom of the loop.
:dt.Syntax:
:dd.LOOP &lbt.NAME=name,&rbt.
.tp 19 34
!WHILE,cond!|
!UNTIL!|
!BCT!|
!BXH,reg,reg!|
!BXLE
.tp
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.name
:dd.Name to be associated with loop structure.
:dt.cond
:dd.Conditional expression. (See :hdref refid=condch..)
:dt.reg
:dd.Register to be used on associated instruction.
:edl.
:dt.Errors:
:dd.:ul compact.
:li.Additional positional parameters can not be specified on LOOP
<type>
:li.LOOPs can only be nested 20 deep
:li.Incorrect number of parameters specified for LOOP BXH
:li.LOOP type <type> is invalid
:li.Refer to :hdref refid=interr., for possible condition errors.
:eul.
:edl.
.*
.*
:h1.L8, L16, L24, L32
:dl.
:dt.Macro:
:dd.L8, L16, L24, L32
:dt.Abstract:
:dd.Macro used to load a register with one, two, three, or
four bytes of data from non-aligned storage.
This macro clears the register and issues the appropriate
ICM to accomplish this.
:dt.Syntax:
:dd.Ln  reg,addr
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.n
:dd.Defines the size of the load operation in bits.  :hp1.n:ehp1.
should be either 8, 16, 24 or 32 for single byte, half word,
three byte, or full word load respectively.
:dt.reg
:dd.Specifies the register to load.  :hp2.Warning:  Since
this register is cleared before the load, it should not be used
(directly or indirectly) to specify :hp1.addr:ehp1..:ehp2.
:dt.addr
:dd.Specifies the address that register :hp1.reg:ehp1. should be
loaded from.
:edl.
:dt.Errors:
:dd.:ul compact
:li.Invalid number of operands on L<n> instruction
:eul.
:edl.
.*
.*
:h1.PLIST
:dl.
:dt.Macro:
:dd.PLIST
:dt.Abstract:
:dd.Macro used to generate or modify a parameter list.  The
parameter list can be created in default parameter list storage
or routed to a specific location.  Register one is also loaded
with the address of the completed list.
:dt.Syntax:
:dd.PLIST &lbt.(parms)&rbt.&lbt.,VL|NOVL&rbt.
.ct &lbt.,PL=tag|(tag,num)&rbt.&lbt.,DS=PWA|SWA&rbt.
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.parms
:dd.A list of the parameters to be included in the parameter list.
A missing parameter causes zero to be filled in for the parameter
address.  An * will cause the macro to skip over that parameter,
reserving the space in the parameter list but not modifying the
data there.
.rc 3 on
An * before a tag will cause the macro to load the parameter list
with the contents of the storage referenced by the tag instead of
the address of the tag.  This provides a form of indirect addressing.
.rc 3 off
Numeric and character constants can be coded and will
be converted to fullword and character literals respectively.
If :hp1.parms:ehp1. is missing, the PLIST macro will simply
load register one with the address specified by PL=.
:dt.VL|NOVL
:dd.VL specifies that this is a variable length parameter list
and therefore the high bit of the last address in the list should
be set to one.  NOVL says to not set the bit.  NOVL is normally the
default, but all of the super options establish VL as the default
so that NOVL might be needed in certain cases.
:dt.tag
:dd.Specifies the address of the parameter list to be created
or modified.  If the PL= keyword is not specified, the parameter
list will be created in the default parameter list storage established
by an enclosing BLOCK macro, or in PWA or SWA storage if no other
default was set up.
:dt.num
:dd.Specifies the maximum number of the parameters that the storage at
:hp1.tag:ehp1. can accommodate.  If :hp1.tag:ehp1. has a length
attribute that is a self-defining term, this operand is not necessary.
This is used to insure that the specified
parameter list will fit into the storage at :hp1.tag:ehp1..
:dt.DS=
:dd.Specifies that space for this list should be created in the
PWA or SWA with a label of :hp1.tag:ehp1..  The PL= keyword is
required when using this operand.  The size of :hp1.parms:ehp1.
is used to calculate the size of the storage created, unless
:hp1.num:ehp1. was specified on the PL= keyword.  In this case,
the size specified by :hp1.num:ehp1. is used.
:edl.
.kp on
:dt.Errors:
:dd.:ul compact
:li.First operand of PL keyword is required if DS keyword
is specified
:li.<ds> is not valid on the DS keyword
:li.The PL keyword must be specified on this macro or on an
enclosing BLOCK macro
:li.<tag> is not large enough to contain parameter list
:li.Invalid parameter <vl>
:li.Too many parameters specified
:li.Too many parameters on PL keyword
:eul.
.kp off
:edl.
.*
.*
:h1.PSD
:dl.
:dt.Macro:
:dd.PSD
:dt.Abstract:
:dd.Macro used to define the beginning of the Program Static
Data (PSD).  The PSD macro uses LOCTR to locate the static data
after the instructions for the program.
The PSD should be defined just before the PWA for a particular
program block if there is one.
:dt.Syntax:
:dd.PSD &lbt.TYPE=LAST|PARTIAL&rbt.
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.TYPE=
:dd.Defines whether this is the PSD macro that defines the main
body of the PSD at the end of the program (LAST), or a PSD macro
that defines a portion of the PSD from within the body of the
program (PARTIAL).  If TYPE= is not specified, TYPE=LAST is assumed.
The TYPE=PARTIAL option is included to allow macros within the
body of the program to define fields in the PSD and have them placed
with the static data.
:edl.
:dt.Errors:
:dd.:ul compact
:li.Nested PSD and SSD macros are not allowed
:eul.
:edl.
.*
.*
:h1.PWA
:dl.
:dt.Macro:
:dd.PWA
:dt.Abstract:
:dd.Macro used to define the beginning of the Program Work
Area (PWA).  The PWA macro will automatically reserve space for
.rc 1 on
a standard OS save area, the SMWA, and any parameter lists if
it is appropriate for the current environment.
.rc 1 off
Also, if the DYN option is being used,
PWA will set up the dynamic storage pointers (NAB, EOS-64).
The PWA should be defined as the last thing associated with
a particular program block.
:dt.Syntax:
:dd.PWA &lbt.TYPE=LAST|PARTIAL&rbt.
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.TYPE=
:dd.Defines whether this is the PWA macro that defines the main
body of the PWA at the end of the program (LAST), or a PWA macro
that defines a portion of the PWA from within the body of the
program (PARTIAL).  If TYPE= is not specified, TYPE=LAST is assumed.
The TYPE=PARTIAL option is included to allow macros within the
body of the program to define fields in the PWA and also generate
the code to initialize them.  So far, this feature is only used
by the PLIST macro, but can be used by any user macro.
:edl.
:dt.Errors:
:dd.:ul compact
:li.PWA option should be specified on the program block macro
:li.Invalid TYPE <type> specified on PWA macro
:eul.
:edl.
.*
.*
:h1.RBIT
:dl.
:dt.Macro:
:dd.RBIT
:dt.Abstract:
:dd.Macro used to reset bit flags in a byte.
:dt.Syntax:
:dd.RBIT &lbt.byte,&rbt.flag|(flag&lbt.,flag&lbt.,...&rbt.&rbt.)
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.byte
:dd.Byte that contains bit(s) to be reset.  If this
operand is omitted,  the name of the byte is assumed to be the
first five characters of the first flag name.
:dt.flag
:dd.Byte mask with a binary one in the bit position of the mask
that corresponds to the bit to be reset in the byte.
:edl.
:dt.Errors:
:dd.:ul compact
:li.No more than eight flags can be specified
:li.RBIT macro can have no more than two operands
:li.If byte is not specified, flag name must be at least six characters
long
:li.If byte is not specified, the first five characters of all flags
must match
:eul.
:edl.
.*
.*
:h1.SBIT
:dl.
:dt.Macro:
:dd.SBIT
:dt.Abstract:
:dd.Macro used to set bit flags in a byte.
:dt.Syntax:
:dd.SBIT &lbt.byte,&rbt.flag|(flag&lbt.,flag&lbt.,...&rbt.&rbt.)
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.byte
:dd.Byte that contains bit(s) to be set.  If this
operand is omitted,  the name of the byte is assumed to be the
first five characters of the first flag name.
:dt.flag
:dd.Byte mask with a binary one in the bit position of the mask
that corresponds to the bit to be set in the byte.
:edl.
:dt.Errors:
:dd.:ul compact.
:li.No more than eight flags can be specified
:li.SBIT macro can have no more than two operands
:li.If byte is not specified, flag name must be at least six characters
long
:li.If byte is not specified, the first five characters of all flags
must match
:eul.
:edl.
.*
.*
.rc 2 on
:h1.SMCTRL
:dl.
:dt.Macro:
:dd.SMCTRL
:dt.Abstract:
:dd.Macro used to set internal
flags to affect the operation of the Structured Macros.
:dt.Syntax:
:dd.SMCTRL FREEPWA=yesno
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.yesno
:dd.Can be YES or NO to set an internal free PWA flag on or off.
When this flag is on, the ENDBLK macro for the program block
will free the PWA.  This
parameter in only valid if the REUSPWA option is in effect.
:edl.
:dt.Errors:
:dd.:ul compact.
:li.The FREEPWA keyword is only valid if the REUSPWA option is in effect
:li.FREEPWA=<value> is not valid
:eul.
:edl.
.rc 2 off
.*
.*
.rc 3 on
:h1.SMLIST
:dl.
:dt.Macro:
:dd.SMLIST
:dt.Abstract:
:dd.Macro used to set options for the operation of the Structured
Macros Listing Program.  This macro is processed by the listing
program and not the assembler.
:dt.Syntax:
:dd.SMLIST CONVERT=yesno
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.yesno
:dd.Can be YES or NO to begin or end the automatic conversion of
assembler source to upper case.  All non-comment lines will be
converted to upper case with the exception of text between double
quotes.  This text will remain unconverted and the double quotes (")
will be replaced with single quotes (') before passing the source
on to the assembler.
:edl.
:dt.Errors:
:dd.:ul compact.
:li.INVALID SMLIST STATEMENT
:eul.
:edl.
.rc 3 off
.*
.*
.rc 3 on
:h1.SMSYMS
:dl.
:dt.Macro:
:dd.SMSYMS
:dt.Abstract:
:dd.This is not a macro, but is a copy member that must be included
at the beginning of any program that uses the structure location
symbols described in :hdref refid=scope..
:dt.Syntax:
:dd.COPY SMSYMS
:dt.Operands:
:dd.None.
:dt.Errors:
:dd.None.
:edl.
.rc 3 off
.*
.*
:h1.SSD
:dl.
:dt.Macro:
:dd.SSD
:dt.Abstract:
:dd.Macro used to define the beginning of the Subroutine Static
Data (SSD).  The SSD macro uses LOCTR to locate the static data.
If the subroutine has selected the LOADBASE option, the static
data is placed immediately after the subroutine code in
the object module.  If the
subroutine is not using LOADBASE, the subroutine static data is
placed with the program static data.
The SSD should be defined just before the SWA for a particular
subroutine block.
:dt.Syntax:
:dd.SSD &lbt.TYPE=LAST|PARTIAL&rbt.
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.TYPE=
:dd.Defines whether this is the SSD macro that defines the
main body of the SSD at the end of the subroutine (LAST), or
an SSD macro that defines a portion of the SSD from within
the body of the subroutine (PARTIAL).  If TYPE= is not
specified, TYPE=LAST is assumed.  The TYPE=PARTIAL option is
included to allow macros within the body of the subroutine to
define fields in the SSD and have them placed with the
static data.
:edl.
:dt.Errors:
:dd.:ul compact
:li.Nested PSD and SSD macros are not allowed
:eul.
:edl.
.*
.*
:h1.STRSA
:dl.
:dt.Macro:
:dd.STRSA
:dt.Abstract:
:dd.Macro used to store a register's value in the Subroutine Work
Area (SWA) save area.  If an internal subroutine contains an SWA,
registers are automatically restored when the subroutine is
exited.  If the internal subroutine needs to pass back the value
of a register, it can use this macro to save a register's current
value in the subroutine save area, so that it will not be
restored to the original value when the subroutine returns.
:dt.Syntax:
:dd.STRSA reg
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.reg
:dd.Defines the register that should be saved.  :hp1.Reg:ehp1.
should be one of the registers R0-R14.
:edl.
:dt.Errors:
:dd.:ul compact
:li.Invalid register specified - <reg>
:li.This macro can only be used in subroutine blocks with the SWA
option specified
:eul.
:edl.
.*
.*
:h1.SWA
:dl.
:dt.Macro:
:dd.SWA
:dt.Abstract:
:dd.Macro used to define the beginning of the Subroutine Work
Area (SWA).  The SWA macro will automatically reserve space for
a subroutine save area, a SMWA, any parameter lists used by
the subroutine, and the Dynamic Storage Management pointers if needed.
The SWA for a subroutine should be defined immediately after
the ENDBLK for that subroutine.
The SWA macro insures that any fields specified within the SWA will
be aligned properly.
:dt.Syntax:
:dd.SWA &lbt.TYPE=LAST|PARTIAL&rbt.
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.TYPE=
:dd.Defines whether this is the SWA macro that defines the main
body of the SWA at the end of the subroutine (LAST), or an SWA macro
that defines a portion of the SWA from within the body of the
subroutine (PARTIAL).  If TYPE= is not specified, TYPE=LAST is assumed.
The TYPE=PARTIAL option is included to allow macros within the
body of the subroutine to define fields in the SWA and also generate
the code to initialize them.  So far, this feature is only used
by the PLIST macro, but can be used by any user macro.
:edl.
:dt.Errors:
:dd.:ul compact
:li.SWA option was not specified on the subroutine block macro
or SWA already defined
:li.Invalid TYPE <type> specified on SWA macro
:eul.
:edl.
.*
.*
:h1.TBIT
:dl.
:dt.Macro:
:dd.TBIT
:dt.Abstract:
:dd.Macro used to test bit flags in a byte.
:dt.Syntax:
:dd.TBIT &lbt.byte,&rbt.flag|(flag&lbt.,flag&lbt.,...&rbt.&rbt.)
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.byte
:dd.Byte that contains bit(s) to be tested.  If this
operand is omitted,  the name of the byte is assumed to be the
first five characters of the first flag name.
:dt.flag
:dd.Byte mask with a binary one in the bit position of the mask
that corresponds to the bit to be tested in the byte.
:edl.
:dt.Errors:
:dd.:ul compact
:li.No more than eight flags can be specified
:li.TBIT macro can have no more than two operands
:li.If byte is not specified, flag name must be at least six characters
long
:li.If byte is not specified, the first five characters of all flags
must match
:li.This expression requires the Level H assembler
:eul.
:edl.
.*
.*
:h1.TREG
:dl.
:dt.Macro:
:dd.TREG
:dt.Abstract:
:dd.Macro used to test a register for zero, positive, or negative.
:dt.Syntax:
:dd.TREG reg
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.reg
:dd.Register to be tested.
:edl.
:dt.Errors:
:dd.:ul compact.
:li.TREG macro can have one and only one operand
:eul.
:edl.
.rc 4 on
.*
.*
:h1.##COND
:dl.
:dt.Macro:
:dd.##COND
:dt.Abstract:
:dd.This is an :q.internal:eq. macro for use within other macros and
not in open code.  The ##COND macro will test a conditional expression
and branch to the appropriate success or failure tags.  This macro is
intended for use in user condition macros.  For information on writing
a user condition macro, see :hdref refid=ucond..
:dt.Syntax:
:dd.##COND expr,S=stag,F=ftag,L=logic
:dt.Operands:
:dd.:dl termhi=1 tsize=6.
:dt.expr
:dd.The conditional expression to be evaluated.  This can be any valid
conditional expression and can contain previously defined user
conditions.
:dt.stag
:dd.The name of the tag that marks the beginning of the code to be
executed if the condition is true.
:dt.ftag
:dd.The name of the tag that marks the beginning of the code to be
executed if the condition is false.
:dt.logic
:dd.Either P for positive logic (branch to success if condition is
true) or N for negative logic (branch to failure, skipping over
success code if condition is false).  These last three operands are
usually passed unchanged from the operands passed in on the user
condition macro that is invoking ##COND.
:edl.
:dt.Errors:
:dd.:ul compact.
:li.Invalid option <cond> for #TEST condition
:li.Invalid or missing condition expression
:li.Invalid number of parms for <op>
:li.This expression requires the Level H assembler
:li.Invalid condition <cond>
:li.No more than 51 positional parameters can be specified
in a condition
:eul.
:edl.
.rc 4 off
.* make chapter headings start on odd pages again
.* by redefining duplex mode and calling DSM#DUPL macro
.* back from the library.
.se SYSVARD = 'yes'
.dm dsm#dupl lib
:appendix.
.*
.*
:h1 id=asmproc.Catalogued ASM Procedures At Clemson
:p.
There are four catalogued procedures available at Clemson that will
provide access to the Structured Macros: these are ASMP, ASMPC,
ASMPCL, and ASMPCLG.
These procs will perform a preprocess; preprocess and assemble;
preprocess, assemble, and link;
or preprocess, assemble, link, and go respectively.
:p.
The Structured Macro preprocessor (MSC0150$) does not change the
source input, but analyzes the use of the Structured Macros and
produces a nesting level report.  Once you have had some time
to get used to it, the nesting level report becomes very useful.
Use //P.SYSIN to provide it with your assembler source.
:p.
The assembly step executes the Level H Assembler with the options
XREF(SHORT), TERM and OBJECT. A //SYSTERM DD statement is included
in the procs, since it appears to be one of the more popular assembler
options. //SYSLIB concatenates SYS1.MACLIB and SYS2.STRUC.MACLIB.
Note that SYS2.MACLIB is not included, and must be included manually
if desired.
:p.
The link-edit step follows the same conventions as the other Clemson
compile-and-link procs, in that link-edit control cards may be
provided via //L.SYSIN. Parms LIST and MAP are provided by the proc.
:p.
The three procs have the following keyword parameters available:
.sk
.tp 13 33 45
 Keyword:!In Procs:!Default:!Used For:
.sk
 SYSOUT!All!   A!Listing SYSOUT class
 OBJECT!All but ASMP! DUMMY!ASM SYSPUNCH
 COPT!All but ASMP! <null>!ASM parameters
 LOPT!ASMPCL, ASMPCLG! <null>!Linkedit parameters
 PDS!ASMPCL! <null>!Loadlib for L.SYSLMOD
 NAME!ASMPCL! <null>!Load module name
.tp
.*
.*
:h1 id=interr.Internal Macros Error Messages
.rc 1 on
:p.The following is a list of error messages that can be
produced by internal macros used by the Structured Macros.
The character preceding the message indicates:
*-informational, 4-warning and 8-error.  Words enclosed in
angle brackets are replaced with the appropriate text when
the message is issued.
:dl.
:dt.##COND
:dd.:ul compact.
:li.8-Invalid option <cond> for #TEST condition
:li.8-Invalid or missing condition expression
:li.8-Invalid number of parms for <op>
:li.8-This expression requires the Level H assembler
:li.8-Invalid condition <cond>
:li.8-Invalid T=
:li.8-No more than 51 positional parameters can be specified
in a condition
:eul.
:dt.##EESTD
:dd.:ul compact.
:li.8-R0 keyword can not be specified if option RTNR0 is not in effect
:li.8-R1 keyword can not be specified if option RTNR1 is not in effect
:li.8-SMWA= keyword needs to be specified on program block
:eul.
:dt.##EPSTD
:dd.:ul compact.
:li.8-AMODE=<amode> is invalid on <type> block, keyword ignored
:li.*-AMODE ignored unless XA option specified for program block
:li.8-Invalid number of parameters in SAVE= keyword
:eul.
:dt.##IESTD
:dd.:ul compact.
:li.8-SMWA= keyword needs to be specified on program block macro
:eul.
:dt.##IGMSG
:dd.:ul compact.
:li.4-<kwdname>=<kwd> ignored
:eul.
:dt.##IPSTD
:dd.:ul compact.
:li.8-AMODE=<amode> is invalid on <type> block, keyword ignored
:li.*-AMODE ignored unless XA option specified for program block
:li.8-AMODE 24 or 31 must be specified on containing subroutine
:li.8-Invalid number of parameters in SAVE= keyword
:eul.
:dt.##L
:dd.:ul compact.
:li.8-Decimal self-defining terms are the only type of self-defining
terms allowed
:li.8-WREG is required if R0,*ADDR is used
:eul.
:dt.##LA
:dd.:ul compact.
:li.8-Decimal self-defining terms are the only type of self-defining
terms allowed
:eul.
:dt.##MREG
:dd.:ul compact.
:li.8-Register specification <reg> is invalid
:li.8-Register <reg> specified multiple times
:li.8-Register <reg> was not used - internal error
:li.8-Invalid type of <type> on ##MREG macro - internal error
:eul.
:dt.##ORGS
:dd.:ul compact.
:li.*-For subroutine <subname> when called from subroutine <subname>
:eul.
:dt.##PEDC
:dd.:ul compact.
:li.8-R0= invalid if option RTNR0 not specified
:li.8-R1= invalid if option RTNR1 not specified
:eul.
:dt.##PEOS
:dd.:ul compact.
:li.8-R0 keyword can not be specified if option RTNR0 is not in effect
:li.8-R1 keyword can not be specified if option RTNR1 is not in effect
:eul.
:dt.##PPDC
:dd.:ul compact.
:li.8-Invalid option <opt>
:li.4-RMODE and AMODE ignored if MODE option not specified
:li.4-RMODE and AMODE ignored if XA option not specified
:li.*-SYSTEM-MODE GETSTG generated
:li.*-#GETSTK generated: #GETSTK =(value)
:li.8-#START option required if SYSTEM option specified
:li.8-#RETURN-related operands not allowed with SYSTEM option
:li.8-#START/#RTN options not allowed with NOSYSTEM option
:li.8-#RETURN option not allowed with SYSTEM option
:li.8-EP option not allowed with NOSYSTEM option
:li.8-AMODE and RMODE requested are inconsistent
:li.8-GETSTK option requires SYSTEM option
:li.8-GETSTK option requires PWA option
:li.8-MPMODE option requires SYSTEM and #START options
:eul.
:dt.##PPOS
:dd.:ul compact.
:li.8-Invalid option &OPT
:li.4-Option DYN assumed because of option MAIN
:li.4-Option PWA assumed because of option DYN
:li.4-DYNSIZE can not be specified without option DYN
:li.8-Name required on program block macro
:li.4-RMODE and AMODE ignored if MODE option not specified
:li.4-RMODE and AMODE ignored if XA option not specified
:li.4-SVAREA= ignored when PWA option specified
:li.8-First PWAREG must be R13
:li.*-SAVEAREA option assumed because of PWA option
:li.4-SVAREA= ignored when RENT and SAVEAREA option specified
:li.*-SAVEAREA option assumed because of SVAREA= keyword
:li.*-Assuming register 1 is saved
.rc 2 on
:li.8-Option REUSPWA requires the PWA, RENT and SAVE options
:li.4-Option FNCODE is ignored when the REUSPWA option is not in effect
:li.8-Option ESV requires the PWA and RENT options
:li.8-Option CLRDEBUG requires the ESV option
.rc 2 off
:eul.
:dt.##PPPLI
:dd.:ul compact.
:li.8-Invalid option <opt>
:li.8-With ENVIRON=PLI, first BASEREG must be R11
:li.8-With ENVIRON=PLI, first PWAREG must be R13
:li.8-Name required on program block macro
:li.4-RMODE and AMODE ignored if MODE option not specified
:li.4-RMODE and AMODE ignored if XA option not specified
:eul.
:dt.##PRMOPT
:dd.:ul compact.
:li.8-USING option requires two parameters
:li.8-COPYERROR option requires two or three parameters
:li.8-<opt> is an invalid suboption of the PARMS option
:li.8-PARMS and PARMMAP keywords require the PARMS option
:li.8-PARMS and PARMMAP keywords are mutually exclusive
:li.8-Too many parameters specified on PARMMAP keyword
:li.8-Second parameter required on PARMMAP keyword if COPY PARMS option
is specified
:li.8-<type> is invalid
:li.8-##PRMOPT does not support <opt> option
:li.8-<process> is an invalid value for PROCESS keyword
:li.8-The first parameter in PARM options must be PARMS
:eul.
:dt.##SPSTD
:dd.:ul compact.
:li.8-SAVE= invalid if SWA option specified
:li.8-SWA option requires PWA option on program block
:li.8-SWAREG= can not be specified unless OPTION=SWA is specified
:li.8-AMODE= invalid for custom subroutine blocks
:li.8-SAVE= invalid for custom subroutine blocks
:li.8-CUSTOM must be specified alone
:li.8-AMODE=<amode> is invalid on subroutine block, keyword ignored
:li.*-LOADBASE assumed because BASEREG= specified
:li.8-BLOCK TYPE=SUBROUTINE requires NAME=
:li.8-LOADBASE option requires LONG option on program block
:li.8-RECUR keyword requires DYN option on program block
:li.8-R11 must be the first register specified on the SWAREG= keyword
:li.*-AMODE ignored unless XA option specified on program block
:li.8-Invalid number of parameters in SAVE= keyword
:eul.
:dt.##ST
:dd.:ul compact.
:li.8-*ADDR form of second operand requires WREG=
:eul.
:dt.##SUBOPT
:dd.:ul compact.
:li.8-<opt> is an invalid option for subroutine block
:eul.
:dt.##SWREG
:dd.:ul compact.
:li.8-SMWA= keyword is required on the program block macro to support
this function
:eul.
:dt.##UCOND
:dd.:ul compact.
:li.8-Invalid or undefined user condition name: <cond>
:eul.
:dt.##UPSTD
:dd.:ul compact.
:li.8-SWA option was not specified on the subroutine block macro
or SWA already defined
:li.8-Invalid type <type> specified on SWA macro
:eul.
:dt.##WESTD
:dd.:ul compact.
:li.*-<subname> first from index is <num>
:li.*-<num> CALLSUB from <subname>(<num>) to <subname>(<num>)
:eul.
:dt.##WPDC
:dd.:ul compact.
:li.8-PWA option should be specified on the program block macro
:li.8-Invalid type <type> specified on PWA macro
:eul.
:dt.##WPOS
:dd.:ul compact.
:li.8-PWA option should be specified on the program block macro
:li.8-Invalid type <type> specified on PWA macro
:eul.
:dt.##WPPLI
:dd.:ul compact.
:li.8-PWA option should be specified on the program block macro
:li.8-Invalid type <type> specified on PWA macro
:eul.
:edl.
.rc 1 off
.*
:h1 id=dynform.Work Area Storage Layout
.*
.*  Define the up arrow symbol
.*
.if &E'&uar = 0
.th .dv uar /|
:p.
If you are using PWAs and SWAs (with or without the DYN option),
the Structured Macros automatically allocate many fields for you.
Since the macros also manage these fields, you rarely
need to worry about them.  However, there may be some cases in
which it would be useful to know the layout of PWA and SWA storage.
That is what this appendix describes.
.*
:h2.Work Area Layout with the DYN Option
.rc 1 on
:p.
The DYN option is only available for program blocks with ENVIRON=OS
in effect.
.rc 1 off
:p.
As described in :hdref refid=pwaswa., the DYN option acquires a
single large chunk of storage at the beginning of the program
and partitions it as it is needed for internal subroutine SWAs.
The layout of the dynamic storage is shown below.
:xmp.
.bx 4 11 18 25 31 38 45 52 61 74
.tp 5 12 19 26 32 39 46 53 62
!PWA!SWA!SWA!- -!PWA!SWA!- -!Free!16 Words
.bx off
.tp 52 c 61 c 73 c
!&uar.!&uar.!&uar.
!NAB!EOS-64!EOS
:exmp.
:p.
The first thing in dynamic storage is the main program's PWA
followed by any SWAs that happen to be active for that program.
If the main program invokes an external subroutine that uses
*NOMAIN, another PWA will be generated for that program followed
by its SWAs.  At the end is free storage waiting to be allocated.
The current NAB (Next Available Byte) will contain a pointer to
the beginning of free storage.  See below to see how to find
the current NAB.
:p.
While EOS (End Of Storage) actually marks the end of the block
of storage that was GETMAINed, a pointer is kept to EOS-64
instead.  This provides a 16 word (64 byte) :q.safety zone:eq.
for use by the internal subroutine linkage routines.
These extra bytes insure that there will always be at least
16 words left in dynamic storage when a subroutine is entered.
Because of this buffer, the subroutine can save its registers
before it has to calculate remaining space and update the pointers.
:p.
Within dynamic storage, all PWAs and SWAs start on a double word
boundary.  This is to insure that any fields defined within
their DSECTs as double word will actually have that alignment.
:p.
The diagram above shows that dynamic storage is divided up into
PWAs and SWAs.  The format of a single PWA is shown below.
:xmp.
.bx 4 16 25 36 42 52 59 64 77
.tp 5 17 26 37 43 53 60 65
!Save Area!EOS-64!Reserved!NAB!Partial!SMWA!PL!User - -
!   (18F)!!!! PWA!(1)!(2)!Defined
.bx off
 &uar.
R13
:exmp.
:note.
 (1) The SMWA is variable in length.
 (2) The PL storage will be as large as required.
:p.
First is a 18 word, standard OS save area for this program.  It is
used anytime the program calls an external subroutine.  This could
be either an IBM service or a separately compiled module.  By
putting the save area at the beginning of the PWA and pointing
register 13 at it, we can use this register to keep up with both
the current save area and the beginning of PWA storage.
:p.
After the save area is a pointer to EOS-64.  This field defines the
end of the block of dynamic storage that this PWA resides in.
This field is filled in even for a *NOMAIN PWA.  The EOS-64
pointer is used in subroutine linkages to determine if there
is enough storage left for an SWA.  Following this pointer is
a fullword reserved for future use.
:p.
Next comes the NAB (Next Available Byte) for this PWA.  This
NAB points to the first byte after this PWA.  If there are
no active SWAs following this PWA, the NAB will point to the
start of free storage.  Otherwise, it will point to the first
SWA following the PWA.
:p.
Following the NAB are any fields that were defined by a
PWA TYPE=PARTIAL macro.  These fields may have been defined
by user macros, or by the DS=PWA keyword on the PLIST macro.
These fields may be any length.
Also in the partial PWA are parameter list fields for any
internal subroutines that do not have SWAs.
:p.
Following the partial fields is the SMWA (Structured Macros
Work Area).  Note that the SMWA can be variable in length
or absent.  If you specify a relocatable address
for the SMWA, one will not be allocated automatically.
:p.
Next is any space reserved for dynamically defined parameter lists
in the program block.
These lists are any that do not have a PL=tag coded on the PLIST
macro or any enclosing block.  Note that only enough space
for the largest such list is reserved instead of for all the lists.
All of these dynamic lists are created in the same place.  For more
information on PLIST processing, see :hdref refid=parms..
This field may also be variable in length or missing.
:p.
Finally come any fields that you coded between the
PWA and ENDPWA macros.  These continue until the end of the PWA.
:p.
A PWA remains in dynamic storage as long as its program is running.
The PWA is followed by any active SWAs for that program's internal
subroutines.  The SWAs are created and destroyed as the subroutines
are entered and exited.  The format of a single SWA is shown below.
:xmp.
.bx 4 11 21 31 40 46 60
.tp 5 12 22 32 41 47
!NAB!R0-R14!Partial!SMWA!PL!User - -
!! Save! SWA!(1)!(2)!Defined
.bx off
 &uar.
R11
:exmp.
:note.
 (1) The SMWA for subroutines is not used and is of zero length.
 (2) The PL storage will be as large as required.
:p.
The SWA looks very much like a PWA with a few fields missing.
The only significant difference is the 15 word subroutine save
area.  Note that this is an internal subroutine save area, and
not a standard OS save area.  The NAB for a subroutine points to
the first available byte after that subroutine's SWA.  If this
is the last SWA currently in dynamic storage, this NAB will point
to the beginning of free space.  Otherwise, it will contain the
address of the next SWA (or PWA) in dynamic storage.
:p.
R11 always points to the beginning (i.e. the NAB) of the currently
active subroutine.  If there is no subroutine active, R11 will
point to the NAB from the current PWA.  Therefore, R11 not only
provides us with a base for our SWA, it always points to the
most current NAB.
:p.
This storage scheme is very easy to maintain and perform linkages on.
When an internal subroutine is entered, it uses R15 (this is why
R15 is destroyed with the DYN option) to calculate where its SWA
will go from the current NAB (pointed to by R11).  It then saves
its registers in this new SWA and calculates a new NAB.  If there
is enough room for this SWA, the subroutine will update R11 to
point to its NAB and the linkage is complete.  Adding a new PWA
is a similar process.  The reverse linkage is even easier.  Since
the pointer to the current NAB is kept in a register, the act of
restoring registers at the end of a subroutine returns the
dynamic storage environment to the state it was in before the
subroutine was entered.  The same holds true for eliminating a
PWA when an *NOMAIN program is exited.
.*
.rc 1 on
:h2.Work Area Layout with NODYN and ENVIRON=DC
:p.
The work area layout for an ENVIRON=DC program is nearly identical
with that of an ENVIRON=OS program: the only differences are that the
PWA does not contain an 18-word OS savearea,
and the PWA in an ENVIRON=DC program is addressed by some register
other than R13 (usually R11).
.*
:xmp.
.bx 4 16 26 38 51
.tp 5 17 27 39
!Partial!SMWA!PL!User - -
! PWA!(1)!(2)!Defined
.bx off
 &uar.
R11
:exmp.
:note.
 (1) The SMWA is variable in length.
 (2) The PL storage will be as large as required.
.*
An SWA in a NODYN program is represented below.  It is identical to
the SWA for an ENVIRON=OS program with the NODYN option.
field.
:xmp.
.bx 4 14 24 33 39 53
.tp 5 15 25 34 40
!R0-R14!Partial!SMWA!PL!User - -
! Save! SWA!(1)!(2)!Defined
.bx off
 &uar.
(3)
:exmp.
:note.
 (1) The SMWA for subroutines is not used and is of zero length.
 (2) The PL storage will be as large as required.
 (3) With NODYN, the SWA will be addressed off of the PWA base.
:p.ENVIRON=DC does not currently support the DYN option.
.rc 1 off
.*
:h2.Work Area Layout with NODYN and ENVIRON=OS
:p.
If the DYN option is not being used, the program can still have
a PWA.  If this is the case, the PWA is of the following format:
:xmp.
.bx 4 16 26 33 38 51
.tp 5 17 27 34 39
!Save Area!Partial!SMWA!PL!User - -
!  (18F)! PWA!(1)!(2)!Defined
.bx off
 &uar.
R13
:exmp.
:note.
 (1) The SMWA is variable in length.
 (2) The PL storage will be as large as required.
:p.
The PWA for a NODYN program looks very much like the PWA created
in dynamic storage, except that the pointers used to keep up
with dynamic storage are not there.  Also, any SWAs defined by
this program will reside in the partial PWA area.
:p.
An SWA in a NODYN program is represented below.  Remember that this
storage is actually allocated within the PWA's :hp1.partial:ehp1.
field.
:xmp.
.bx 4 14 24 33 39 53
.tp 5 15 25 34 40
!R0-R14!Partial!SMWA!PL!User - -
! Save! SWA!(1)!(2)!Defined
.bx off
 &uar.
(3)
:exmp.
:note.
 (1) The SMWA for subroutines is not used and is of zero length.
 (2) The PL storage will be as large as required.
 (3) With NODYN, the SWA will be addressed off of the PWA base.
:p.
The SWA within a NODYN program is just like that for a DYN program,
except that the NAB is absent.
.*
.rc 1 on
:h2.Work Area Layout with NODYN and ENVIRON=PLI
:p.
The work area layout for ENVIRON=PLI is the same as the
layout for ENVIRON=OS with option NODYN in effect with the
exception that the save area is replace by a PL/I DSA.  A
DSA starts with an OS save area with the first word used for
PL/I housekeeping.  The forward link in the save area is not
used.  The save area if followed by other PL/I housekeeping
fields.  The format of the DSA is described in detail in the
execution time logic manual for the PL/I Optimizing
Compiler.
:xmp.
.bx 4 16 26 33 38 51
.tp 5 17 27 34 39
!PL/I DSA!Partial!SMWA!PL!User - -
!       ! PWA!(1)!(2)!Defined
.bx off
 &uar.
R13
:exmp.
:note.
 (1) The SMWA is variable in length.
 (2) The PL storage will be as large as required.
.rc 1 off
.*
.*
:h1 id=codform.Program Code and Static Data Layout
:p.
The use of the LOCTR instruction in the Level H Assembler allows
the Structured Macros to gather code under different location counters
and place them at the proper point in the load module.  To
preserve the integrity of the structure that the macros produce,
a program should be coded in the manner shown below.
:xmp.
 BLOCK  TYPE=PROGRAM,NAME=MAINPROG,OPTIONS=(*MAIN,LONG),
               SUBOPTS=(*SWA,LOADBASE)
       :
  CALLSUB SUBONE
       :
 ENDBLK BLOCK=MAINPROG

 BLOCK  TYPE=SUBROUTINE,NAME=SUBONE
       :
  CALLSUB SUBTWO
       :
 ENDBLK BLOCK=SUBONE
 SWA
  --- SWA Fields for SUBONE ---
 ENDSWA

 BLOCK  TYPE=SUBROUTINE,NAME=SUBTWO,RECUR=10
       :
  CALLSUB SUBTWO
       :
 ENDBLK BLOCK=SUBTWO
 SSD
  --- Subroutine Static Data for SUBTWO ---
 ENDSSD
 SWA
  --- SWA Fields for SUBTWO ---
 ENDSWA

 BLOCK  TYPE=SUBROUTINE,NAME=SUBTHREE,OPTIONS=(NOLOADBASE)
       :
  CALLSUB SUBTHREE
       :
 ENDBLK BLOCK=SUBTHREE
 SSD
  --- Subroutine Static Data for SUBTHREE ---
 ENDSSD

 PSD
  --- Program Static Data ---
 ENDPSD
 PWA
  --- PWA FIELDS ---
 ENDPWA
:exmp.
:p.
Note that not all programs will require all of these options.  If
SUBTWO was not recursive, we would not need Dynamic Storage Management.
However, it still may be of assistance in reducing storage needs.
SWAs, SSDs, and the PSD only need to be coded if
there are fields to define there.  If these areas are needed by the
macros, they will create them if you have not.  However,
the PWA and ENDPWA macros must :hp2.always:ehp2. be coded if the
program is going to use the PWA option.
:note.
If the NOLOCTR option has been selected, the macros will not
generate LOCTRs to arrange the code, and the CSECT will be arranged
as it was coded.
:p.
When the load module is actually created by the Assembler, the
layout of a single CSECT looks like the figure below:
:xmp.
.bx 4 15 29 40 53 67 75
.tp 5 16 30 41 54 68
!Program!Subroutine!Partial!PSD User!Subroutine!SSD
!Code (1)! Code (2)!PSD (3)!Fields (4)!Code (5)!(6)
.bx off
:exmp.
:dl termhi=0 tsize=6.
:dt.(1)
:dd.First in the CSECT is the code from the program block itself.
:dt.(2)
:dd.Following the program code is the code for any subroutines
that did not specify LOADBASE.  This allows these subroutines to
be addressed off of the program's base register.
:dt.(3)
:dd.The partial PSD contains any PSD fields that were defined
within the body of the program.  Also included here are the SSDs
from the subroutines without LOADBASE.  The partial PSD along
with the PSD user fields are addressed off of the program's
base register.
:dt.(4)
:dd.The PSD user fields are any static data coded
between the PSD and ENDPSD macros at the end of the program.
:dt.(5)
:dd.The subroutine code for any subroutines that use the LOADBASE
option is placed after the PSD.  If there are no subroutines that
use LOADBASE, this area and the next one are missing.
:dt.(6)
:dd.Following the code for a LOADBASE subroutine is the static
data (SSD) for that subroutine.  This data is addressed off of
the subroutine's base register.  These last two areas can be repeated
any number of times, once for each subroutine that uses the
LOADBASE option.
:edl.
.*
.*
:h1.Register Usage
:p.
.rc 1 on
With so many things being done by the macros, you may
not be sure exactly what registers are available for general use.
This appendix describes the registers used by the Structured Macros.
.rc 1 off
.rc 1 on
:h2.Register Usage for ENVIRON=DC
:p.
:h3.IDMS/DC User Mode Registers And Linkage
:ul.
:li.User mode programs are invoked by:
:ul compact.
:li.A #LINK from RHDCTSKC (task create)
:li.A #LINK or #XCTL from another program
:eul.
:li.User mode registers are used as follows:
:dl.
:dt.R15
:dd.Entry point address from caller; loaded into the specified program
base register by the BLOCK TYPE=PROGRAM macro. Also used for subroutine
linkage if the LONG option is used.
:dt.R14
:dd.This is used for returning from subroutine blocks.
:dt.R13
:dd.Not used.
:dt.R12
:dd.Default program base register.
:dt.R11
:dd.Default PWA base register.
:dt.R10
:dd.Address of the IDMS/DC CSA on entry, although this register may be
used for other things by the program.
:dt.R9
:dd.Address of the IDMS/DC task's TCE on entry, although this register
may be used for other things by the program.
:dt.R2-R8
:dd.Not used.
:dt.R1
:dd.Address of parameter list from calling program, if any
:dt.R0
:dd.Not used.
:edl.
:li.Registers are always saved across requests for IDMS/DC services,
except for R14, R15, R0 and R1.
:li.The assembler program should include an interface, either by coding
a #BALI macro among your constants somewhere, or by specifying
INCLUDE IDMSLIB(IDMSBALI) to the linkage editor.
:li.User mode programs must return to IDMS/DC using the #RETURN macro.
If you use the NO#RETURN option, you must code a #RETURN yourself at
some point after the program block's ENDBLK macro.
:eul.
:h3.IDMS/DC System Mode Registers And Linkage
:ul.
:li.System mode programs are invoked by a #CALL from another
system-mode program. Should you wish to call an external routine, you
should use #CALL instead of CALLX.
:li.System mode registers are used as follows:
:dl.
:dt.R15
:dd.Entry point address from caller; loaded into the specified program
base register by the BLOCK TYPE=PROGRAM macro. Also used for internal
subroutine linkage if the LONG option is used.
:dt.R14
:dd.This is used for returning from subroutine blocks.
:dt.R13
:dd.Not used.
:dt.R12
:dd.Program base register.
:dt.R11
:dd.Default PWA base register, for PWA's obtained by either #GETSTG
or #GETSTK.
:dt.R10
:dd.Address of the IDMS/DC CSA. This should not be modified
by the program.
:dt.R9
:dd.Address of the IDMS/DC task's TCE. This should not be modified
by the program.
:dt.R2-R8
:dd.Not used.
:dt.R1
:dd.Address of parameter list from calling program, if any
:dt.R0
:dd.Not used.
:edl.
:li.Registers R13 and R15-R1 are never saved across #CALLs.
:li.Registers R11, R12 and R14 are always saved in the current
TCE's save area stack.
:li.The caller of a routine is responsible for specifying which
of the remaining registers (R2-R8) are to be saved. For example,
.fo off
      #CALL  pgmname,(R2-R8)
.fo on
will cause R2 through R8 to be saved on the TCE stack, along with
R11, R12 and R14.
:eul.
.rc 1 off
:h2.Register Usage for ENVIRON=OS
:p.
:dl.
:dt.R15
:dd.This register is used for the address of the subroutine
when CALLSUB is used with the LONG Program Block option.
:dt.R14
.rc 1 on
:dd.This register holds the return address from any subroutine block
.rc 1 off
called by the macros.
:dt.R13
:dd.This is the base register for the PWA.  Although the PWA can
have multiple base registers,
.rc 1 on
the first one must always be R13 since
the standard OS save area for the program is at the beginning of the
PWA.
.rc 1 off
If *NORENT is used and SVAREA= is not specified, R13 is the first
program base as well as pointing to the OS save area.
:dt.R12
:dd.This is normally the base register for the program itself along
with any static data.
If the NORENT option is being used and the SVAREA=  keyword was
not specified, R13 is used for the base register instead of R12.
The BASEREG=  keyword on the Program Block can be used to specify
a different base register (or multiple base registers).
:dt.R11
:dd.If the DYN option was specified on the Program Block, R11 will
be used to establish addressibility on the SWA of the current
subroutine.  This register is in use even when no subroutine is
currently active.  Although the Subroutine Block allows you to
specify multiple base registers for the SWA, R11 must always be
the first one.
:dt.R10
:dd.If the LOADBASE options was specified on the Subroutine Block,
R10 will be used as the base register for the subroutine code.
This register is only in use while the LOADBASE subroutine is
currently active.
The BASEREG=  keyword on the Subroutine Block can be used to specify
a different base register (or multiple base registers).
:edl.
.rc 1 on
:h2.Register Usage for ENVIRON=PLI
:p.
:dl.
:dt.R15
:dd.This register is used for the address of the subroutine
when CALLSUB is used with the LONG Program Block option.
:dt.R14
:dd.This register holds the return address from any subroutine block
called by the macros.
:dt.R13
:dd.This is the base register for the PWA.  A PL/I DSA is
contained in the first part of the PWA; therefore, R13 is
also the base for the DSA.  Although the PWA can have
multiple base registers, the first one must always be R13
because PL/I requires that R13 contain a pointer to the DSA.
:dt.R12
:dd.This is the pointer to PL/I's Task Communications Area (TCA) and
should never be modified by a program.
:dt.R11
:dd.This is the first program base register for the program
itself along with any static data.
:dt.R10
:dd.If the LOADBASE options was specified on the Subroutine
Block, R10 will be used as the base register for the
subroutine code.  This register is only in use while the
LOADBASE subroutine is currently active.  The BASEREG=
keyword on the Subroutine Block can be used to specify a
different base register (or multiple base registers).
:edl.
.rc 1 off
:egdoc
